
LoRaWAN_End_Node.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000200  0802b200  0802b200  000000f4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00010440  0802b400  0802b400  000002f8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000d20  0803b840  0803b840  00010738  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0803c560  0803c560  00011618  2**0
                  CONTENTS
  4 .ARM          00000008  0803c560  0803c560  00011458  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  0803c568  0803c568  00011618  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  0803c568  0803c568  00011460  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  0803c56c  0803c56c  00011464  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         000001ac  20003400  0803c570  00011468  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .align16      00000004  0803c71c  0803c71c  00011614  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 10 .bss          00002e00  200035ac  200035ac  00011618  2**2
                  ALLOC
 11 ._user_heap_stack 00000a04  200063ac  200063ac  00011618  2**0
                  ALLOC
 12 .ARM.attributes 0000002a  00000000  00000000  00011618  2**0
                  CONTENTS, READONLY
 13 .debug_info   00082960  00000000  00000000  00011642  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 00010772  00000000  00000000  00093fa2  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_loc    00024920  00000000  00000000  000a4714  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_aranges 000028d0  00000000  00000000  000c9038  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_ranges 00004a68  00000000  00000000  000cb908  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_macro  0002f3f2  00000000  00000000  000d0370  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_line   00052465  00000000  00000000  000ff762  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_str    000e666a  00000000  00000000  00151bc7  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .comment      00000053  00000000  00000000  00238231  2**0
                  CONTENTS, READONLY
 22 .debug_frame  000072a0  00000000  00000000  00238284  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

0802b400 <__do_global_dtors_aux>:
 802b400:	b510      	push	{r4, lr}
 802b402:	4c05      	ldr	r4, [pc, #20]	; (802b418 <__do_global_dtors_aux+0x18>)
 802b404:	7823      	ldrb	r3, [r4, #0]
 802b406:	b933      	cbnz	r3, 802b416 <__do_global_dtors_aux+0x16>
 802b408:	4b04      	ldr	r3, [pc, #16]	; (802b41c <__do_global_dtors_aux+0x1c>)
 802b40a:	b113      	cbz	r3, 802b412 <__do_global_dtors_aux+0x12>
 802b40c:	4804      	ldr	r0, [pc, #16]	; (802b420 <__do_global_dtors_aux+0x20>)
 802b40e:	f3af 8000 	nop.w
 802b412:	2301      	movs	r3, #1
 802b414:	7023      	strb	r3, [r4, #0]
 802b416:	bd10      	pop	{r4, pc}
 802b418:	200035ac 	.word	0x200035ac
 802b41c:	00000000 	.word	0x00000000
 802b420:	0803b828 	.word	0x0803b828

0802b424 <frame_dummy>:
 802b424:	b508      	push	{r3, lr}
 802b426:	4b03      	ldr	r3, [pc, #12]	; (802b434 <frame_dummy+0x10>)
 802b428:	b11b      	cbz	r3, 802b432 <frame_dummy+0xe>
 802b42a:	4903      	ldr	r1, [pc, #12]	; (802b438 <frame_dummy+0x14>)
 802b42c:	4803      	ldr	r0, [pc, #12]	; (802b43c <frame_dummy+0x18>)
 802b42e:	f3af 8000 	nop.w
 802b432:	bd08      	pop	{r3, pc}
 802b434:	00000000 	.word	0x00000000
 802b438:	200035b0 	.word	0x200035b0
 802b43c:	0803b828 	.word	0x0803b828

0802b440 <strlen>:
 802b440:	4603      	mov	r3, r0
 802b442:	f813 2b01 	ldrb.w	r2, [r3], #1
 802b446:	2a00      	cmp	r2, #0
 802b448:	d1fb      	bne.n	802b442 <strlen+0x2>
 802b44a:	1a18      	subs	r0, r3, r0
 802b44c:	3801      	subs	r0, #1
 802b44e:	4770      	bx	lr

0802b450 <__aeabi_drsub>:
 802b450:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 802b454:	e002      	b.n	802b45c <__adddf3>
 802b456:	bf00      	nop

0802b458 <__aeabi_dsub>:
 802b458:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0802b45c <__adddf3>:
 802b45c:	b530      	push	{r4, r5, lr}
 802b45e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 802b462:	ea4f 0543 	mov.w	r5, r3, lsl #1
 802b466:	ea94 0f05 	teq	r4, r5
 802b46a:	bf08      	it	eq
 802b46c:	ea90 0f02 	teqeq	r0, r2
 802b470:	bf1f      	itttt	ne
 802b472:	ea54 0c00 	orrsne.w	ip, r4, r0
 802b476:	ea55 0c02 	orrsne.w	ip, r5, r2
 802b47a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 802b47e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 802b482:	f000 80e2 	beq.w	802b64a <__adddf3+0x1ee>
 802b486:	ea4f 5454 	mov.w	r4, r4, lsr #21
 802b48a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 802b48e:	bfb8      	it	lt
 802b490:	426d      	neglt	r5, r5
 802b492:	dd0c      	ble.n	802b4ae <__adddf3+0x52>
 802b494:	442c      	add	r4, r5
 802b496:	ea80 0202 	eor.w	r2, r0, r2
 802b49a:	ea81 0303 	eor.w	r3, r1, r3
 802b49e:	ea82 0000 	eor.w	r0, r2, r0
 802b4a2:	ea83 0101 	eor.w	r1, r3, r1
 802b4a6:	ea80 0202 	eor.w	r2, r0, r2
 802b4aa:	ea81 0303 	eor.w	r3, r1, r3
 802b4ae:	2d36      	cmp	r5, #54	; 0x36
 802b4b0:	bf88      	it	hi
 802b4b2:	bd30      	pophi	{r4, r5, pc}
 802b4b4:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 802b4b8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 802b4bc:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 802b4c0:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 802b4c4:	d002      	beq.n	802b4cc <__adddf3+0x70>
 802b4c6:	4240      	negs	r0, r0
 802b4c8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 802b4cc:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 802b4d0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 802b4d4:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 802b4d8:	d002      	beq.n	802b4e0 <__adddf3+0x84>
 802b4da:	4252      	negs	r2, r2
 802b4dc:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 802b4e0:	ea94 0f05 	teq	r4, r5
 802b4e4:	f000 80a7 	beq.w	802b636 <__adddf3+0x1da>
 802b4e8:	f1a4 0401 	sub.w	r4, r4, #1
 802b4ec:	f1d5 0e20 	rsbs	lr, r5, #32
 802b4f0:	db0d      	blt.n	802b50e <__adddf3+0xb2>
 802b4f2:	fa02 fc0e 	lsl.w	ip, r2, lr
 802b4f6:	fa22 f205 	lsr.w	r2, r2, r5
 802b4fa:	1880      	adds	r0, r0, r2
 802b4fc:	f141 0100 	adc.w	r1, r1, #0
 802b500:	fa03 f20e 	lsl.w	r2, r3, lr
 802b504:	1880      	adds	r0, r0, r2
 802b506:	fa43 f305 	asr.w	r3, r3, r5
 802b50a:	4159      	adcs	r1, r3
 802b50c:	e00e      	b.n	802b52c <__adddf3+0xd0>
 802b50e:	f1a5 0520 	sub.w	r5, r5, #32
 802b512:	f10e 0e20 	add.w	lr, lr, #32
 802b516:	2a01      	cmp	r2, #1
 802b518:	fa03 fc0e 	lsl.w	ip, r3, lr
 802b51c:	bf28      	it	cs
 802b51e:	f04c 0c02 	orrcs.w	ip, ip, #2
 802b522:	fa43 f305 	asr.w	r3, r3, r5
 802b526:	18c0      	adds	r0, r0, r3
 802b528:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 802b52c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 802b530:	d507      	bpl.n	802b542 <__adddf3+0xe6>
 802b532:	f04f 0e00 	mov.w	lr, #0
 802b536:	f1dc 0c00 	rsbs	ip, ip, #0
 802b53a:	eb7e 0000 	sbcs.w	r0, lr, r0
 802b53e:	eb6e 0101 	sbc.w	r1, lr, r1
 802b542:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 802b546:	d31b      	bcc.n	802b580 <__adddf3+0x124>
 802b548:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 802b54c:	d30c      	bcc.n	802b568 <__adddf3+0x10c>
 802b54e:	0849      	lsrs	r1, r1, #1
 802b550:	ea5f 0030 	movs.w	r0, r0, rrx
 802b554:	ea4f 0c3c 	mov.w	ip, ip, rrx
 802b558:	f104 0401 	add.w	r4, r4, #1
 802b55c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 802b560:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 802b564:	f080 809a 	bcs.w	802b69c <__adddf3+0x240>
 802b568:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 802b56c:	bf08      	it	eq
 802b56e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 802b572:	f150 0000 	adcs.w	r0, r0, #0
 802b576:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 802b57a:	ea41 0105 	orr.w	r1, r1, r5
 802b57e:	bd30      	pop	{r4, r5, pc}
 802b580:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 802b584:	4140      	adcs	r0, r0
 802b586:	eb41 0101 	adc.w	r1, r1, r1
 802b58a:	3c01      	subs	r4, #1
 802b58c:	bf28      	it	cs
 802b58e:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
 802b592:	d2e9      	bcs.n	802b568 <__adddf3+0x10c>
 802b594:	f091 0f00 	teq	r1, #0
 802b598:	bf04      	itt	eq
 802b59a:	4601      	moveq	r1, r0
 802b59c:	2000      	moveq	r0, #0
 802b59e:	fab1 f381 	clz	r3, r1
 802b5a2:	bf08      	it	eq
 802b5a4:	3320      	addeq	r3, #32
 802b5a6:	f1a3 030b 	sub.w	r3, r3, #11
 802b5aa:	f1b3 0220 	subs.w	r2, r3, #32
 802b5ae:	da0c      	bge.n	802b5ca <__adddf3+0x16e>
 802b5b0:	320c      	adds	r2, #12
 802b5b2:	dd08      	ble.n	802b5c6 <__adddf3+0x16a>
 802b5b4:	f102 0c14 	add.w	ip, r2, #20
 802b5b8:	f1c2 020c 	rsb	r2, r2, #12
 802b5bc:	fa01 f00c 	lsl.w	r0, r1, ip
 802b5c0:	fa21 f102 	lsr.w	r1, r1, r2
 802b5c4:	e00c      	b.n	802b5e0 <__adddf3+0x184>
 802b5c6:	f102 0214 	add.w	r2, r2, #20
 802b5ca:	bfd8      	it	le
 802b5cc:	f1c2 0c20 	rsble	ip, r2, #32
 802b5d0:	fa01 f102 	lsl.w	r1, r1, r2
 802b5d4:	fa20 fc0c 	lsr.w	ip, r0, ip
 802b5d8:	bfdc      	itt	le
 802b5da:	ea41 010c 	orrle.w	r1, r1, ip
 802b5de:	4090      	lslle	r0, r2
 802b5e0:	1ae4      	subs	r4, r4, r3
 802b5e2:	bfa2      	ittt	ge
 802b5e4:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 802b5e8:	4329      	orrge	r1, r5
 802b5ea:	bd30      	popge	{r4, r5, pc}
 802b5ec:	ea6f 0404 	mvn.w	r4, r4
 802b5f0:	3c1f      	subs	r4, #31
 802b5f2:	da1c      	bge.n	802b62e <__adddf3+0x1d2>
 802b5f4:	340c      	adds	r4, #12
 802b5f6:	dc0e      	bgt.n	802b616 <__adddf3+0x1ba>
 802b5f8:	f104 0414 	add.w	r4, r4, #20
 802b5fc:	f1c4 0220 	rsb	r2, r4, #32
 802b600:	fa20 f004 	lsr.w	r0, r0, r4
 802b604:	fa01 f302 	lsl.w	r3, r1, r2
 802b608:	ea40 0003 	orr.w	r0, r0, r3
 802b60c:	fa21 f304 	lsr.w	r3, r1, r4
 802b610:	ea45 0103 	orr.w	r1, r5, r3
 802b614:	bd30      	pop	{r4, r5, pc}
 802b616:	f1c4 040c 	rsb	r4, r4, #12
 802b61a:	f1c4 0220 	rsb	r2, r4, #32
 802b61e:	fa20 f002 	lsr.w	r0, r0, r2
 802b622:	fa01 f304 	lsl.w	r3, r1, r4
 802b626:	ea40 0003 	orr.w	r0, r0, r3
 802b62a:	4629      	mov	r1, r5
 802b62c:	bd30      	pop	{r4, r5, pc}
 802b62e:	fa21 f004 	lsr.w	r0, r1, r4
 802b632:	4629      	mov	r1, r5
 802b634:	bd30      	pop	{r4, r5, pc}
 802b636:	f094 0f00 	teq	r4, #0
 802b63a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 802b63e:	bf06      	itte	eq
 802b640:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 802b644:	3401      	addeq	r4, #1
 802b646:	3d01      	subne	r5, #1
 802b648:	e74e      	b.n	802b4e8 <__adddf3+0x8c>
 802b64a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 802b64e:	bf18      	it	ne
 802b650:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 802b654:	d029      	beq.n	802b6aa <__adddf3+0x24e>
 802b656:	ea94 0f05 	teq	r4, r5
 802b65a:	bf08      	it	eq
 802b65c:	ea90 0f02 	teqeq	r0, r2
 802b660:	d005      	beq.n	802b66e <__adddf3+0x212>
 802b662:	ea54 0c00 	orrs.w	ip, r4, r0
 802b666:	bf04      	itt	eq
 802b668:	4619      	moveq	r1, r3
 802b66a:	4610      	moveq	r0, r2
 802b66c:	bd30      	pop	{r4, r5, pc}
 802b66e:	ea91 0f03 	teq	r1, r3
 802b672:	bf1e      	ittt	ne
 802b674:	2100      	movne	r1, #0
 802b676:	2000      	movne	r0, #0
 802b678:	bd30      	popne	{r4, r5, pc}
 802b67a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 802b67e:	d105      	bne.n	802b68c <__adddf3+0x230>
 802b680:	0040      	lsls	r0, r0, #1
 802b682:	4149      	adcs	r1, r1
 802b684:	bf28      	it	cs
 802b686:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 802b68a:	bd30      	pop	{r4, r5, pc}
 802b68c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 802b690:	bf3c      	itt	cc
 802b692:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 802b696:	bd30      	popcc	{r4, r5, pc}
 802b698:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 802b69c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 802b6a0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 802b6a4:	f04f 0000 	mov.w	r0, #0
 802b6a8:	bd30      	pop	{r4, r5, pc}
 802b6aa:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 802b6ae:	bf1a      	itte	ne
 802b6b0:	4619      	movne	r1, r3
 802b6b2:	4610      	movne	r0, r2
 802b6b4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 802b6b8:	bf1c      	itt	ne
 802b6ba:	460b      	movne	r3, r1
 802b6bc:	4602      	movne	r2, r0
 802b6be:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 802b6c2:	bf06      	itte	eq
 802b6c4:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 802b6c8:	ea91 0f03 	teqeq	r1, r3
 802b6cc:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 802b6d0:	bd30      	pop	{r4, r5, pc}
 802b6d2:	bf00      	nop

0802b6d4 <__aeabi_ui2d>:
 802b6d4:	f090 0f00 	teq	r0, #0
 802b6d8:	bf04      	itt	eq
 802b6da:	2100      	moveq	r1, #0
 802b6dc:	4770      	bxeq	lr
 802b6de:	b530      	push	{r4, r5, lr}
 802b6e0:	f44f 6480 	mov.w	r4, #1024	; 0x400
 802b6e4:	f104 0432 	add.w	r4, r4, #50	; 0x32
 802b6e8:	f04f 0500 	mov.w	r5, #0
 802b6ec:	f04f 0100 	mov.w	r1, #0
 802b6f0:	e750      	b.n	802b594 <__adddf3+0x138>
 802b6f2:	bf00      	nop

0802b6f4 <__aeabi_i2d>:
 802b6f4:	f090 0f00 	teq	r0, #0
 802b6f8:	bf04      	itt	eq
 802b6fa:	2100      	moveq	r1, #0
 802b6fc:	4770      	bxeq	lr
 802b6fe:	b530      	push	{r4, r5, lr}
 802b700:	f44f 6480 	mov.w	r4, #1024	; 0x400
 802b704:	f104 0432 	add.w	r4, r4, #50	; 0x32
 802b708:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 802b70c:	bf48      	it	mi
 802b70e:	4240      	negmi	r0, r0
 802b710:	f04f 0100 	mov.w	r1, #0
 802b714:	e73e      	b.n	802b594 <__adddf3+0x138>
 802b716:	bf00      	nop

0802b718 <__aeabi_f2d>:
 802b718:	0042      	lsls	r2, r0, #1
 802b71a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 802b71e:	ea4f 0131 	mov.w	r1, r1, rrx
 802b722:	ea4f 7002 	mov.w	r0, r2, lsl #28
 802b726:	bf1f      	itttt	ne
 802b728:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 802b72c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 802b730:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 802b734:	4770      	bxne	lr
 802b736:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 802b73a:	bf08      	it	eq
 802b73c:	4770      	bxeq	lr
 802b73e:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 802b742:	bf04      	itt	eq
 802b744:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 802b748:	4770      	bxeq	lr
 802b74a:	b530      	push	{r4, r5, lr}
 802b74c:	f44f 7460 	mov.w	r4, #896	; 0x380
 802b750:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 802b754:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 802b758:	e71c      	b.n	802b594 <__adddf3+0x138>
 802b75a:	bf00      	nop

0802b75c <__aeabi_ul2d>:
 802b75c:	ea50 0201 	orrs.w	r2, r0, r1
 802b760:	bf08      	it	eq
 802b762:	4770      	bxeq	lr
 802b764:	b530      	push	{r4, r5, lr}
 802b766:	f04f 0500 	mov.w	r5, #0
 802b76a:	e00a      	b.n	802b782 <__aeabi_l2d+0x16>

0802b76c <__aeabi_l2d>:
 802b76c:	ea50 0201 	orrs.w	r2, r0, r1
 802b770:	bf08      	it	eq
 802b772:	4770      	bxeq	lr
 802b774:	b530      	push	{r4, r5, lr}
 802b776:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 802b77a:	d502      	bpl.n	802b782 <__aeabi_l2d+0x16>
 802b77c:	4240      	negs	r0, r0
 802b77e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 802b782:	f44f 6480 	mov.w	r4, #1024	; 0x400
 802b786:	f104 0432 	add.w	r4, r4, #50	; 0x32
 802b78a:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 802b78e:	f43f aed8 	beq.w	802b542 <__adddf3+0xe6>
 802b792:	f04f 0203 	mov.w	r2, #3
 802b796:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 802b79a:	bf18      	it	ne
 802b79c:	3203      	addne	r2, #3
 802b79e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 802b7a2:	bf18      	it	ne
 802b7a4:	3203      	addne	r2, #3
 802b7a6:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 802b7aa:	f1c2 0320 	rsb	r3, r2, #32
 802b7ae:	fa00 fc03 	lsl.w	ip, r0, r3
 802b7b2:	fa20 f002 	lsr.w	r0, r0, r2
 802b7b6:	fa01 fe03 	lsl.w	lr, r1, r3
 802b7ba:	ea40 000e 	orr.w	r0, r0, lr
 802b7be:	fa21 f102 	lsr.w	r1, r1, r2
 802b7c2:	4414      	add	r4, r2
 802b7c4:	e6bd      	b.n	802b542 <__adddf3+0xe6>
 802b7c6:	bf00      	nop

0802b7c8 <__gedf2>:
 802b7c8:	f04f 3cff 	mov.w	ip, #4294967295
 802b7cc:	e006      	b.n	802b7dc <__cmpdf2+0x4>
 802b7ce:	bf00      	nop

0802b7d0 <__ledf2>:
 802b7d0:	f04f 0c01 	mov.w	ip, #1
 802b7d4:	e002      	b.n	802b7dc <__cmpdf2+0x4>
 802b7d6:	bf00      	nop

0802b7d8 <__cmpdf2>:
 802b7d8:	f04f 0c01 	mov.w	ip, #1
 802b7dc:	f84d cd04 	str.w	ip, [sp, #-4]!
 802b7e0:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 802b7e4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 802b7e8:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 802b7ec:	bf18      	it	ne
 802b7ee:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 802b7f2:	d01b      	beq.n	802b82c <__cmpdf2+0x54>
 802b7f4:	b001      	add	sp, #4
 802b7f6:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 802b7fa:	bf0c      	ite	eq
 802b7fc:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 802b800:	ea91 0f03 	teqne	r1, r3
 802b804:	bf02      	ittt	eq
 802b806:	ea90 0f02 	teqeq	r0, r2
 802b80a:	2000      	moveq	r0, #0
 802b80c:	4770      	bxeq	lr
 802b80e:	f110 0f00 	cmn.w	r0, #0
 802b812:	ea91 0f03 	teq	r1, r3
 802b816:	bf58      	it	pl
 802b818:	4299      	cmppl	r1, r3
 802b81a:	bf08      	it	eq
 802b81c:	4290      	cmpeq	r0, r2
 802b81e:	bf2c      	ite	cs
 802b820:	17d8      	asrcs	r0, r3, #31
 802b822:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 802b826:	f040 0001 	orr.w	r0, r0, #1
 802b82a:	4770      	bx	lr
 802b82c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 802b830:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 802b834:	d102      	bne.n	802b83c <__cmpdf2+0x64>
 802b836:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 802b83a:	d107      	bne.n	802b84c <__cmpdf2+0x74>
 802b83c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 802b840:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 802b844:	d1d6      	bne.n	802b7f4 <__cmpdf2+0x1c>
 802b846:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 802b84a:	d0d3      	beq.n	802b7f4 <__cmpdf2+0x1c>
 802b84c:	f85d 0b04 	ldr.w	r0, [sp], #4
 802b850:	4770      	bx	lr
 802b852:	bf00      	nop

0802b854 <__aeabi_cdrcmple>:
 802b854:	4684      	mov	ip, r0
 802b856:	4610      	mov	r0, r2
 802b858:	4662      	mov	r2, ip
 802b85a:	468c      	mov	ip, r1
 802b85c:	4619      	mov	r1, r3
 802b85e:	4663      	mov	r3, ip
 802b860:	e000      	b.n	802b864 <__aeabi_cdcmpeq>
 802b862:	bf00      	nop

0802b864 <__aeabi_cdcmpeq>:
 802b864:	b501      	push	{r0, lr}
 802b866:	f7ff ffb7 	bl	802b7d8 <__cmpdf2>
 802b86a:	2800      	cmp	r0, #0
 802b86c:	bf48      	it	mi
 802b86e:	f110 0f00 	cmnmi.w	r0, #0
 802b872:	bd01      	pop	{r0, pc}

0802b874 <__aeabi_dcmpeq>:
 802b874:	f84d ed08 	str.w	lr, [sp, #-8]!
 802b878:	f7ff fff4 	bl	802b864 <__aeabi_cdcmpeq>
 802b87c:	bf0c      	ite	eq
 802b87e:	2001      	moveq	r0, #1
 802b880:	2000      	movne	r0, #0
 802b882:	f85d fb08 	ldr.w	pc, [sp], #8
 802b886:	bf00      	nop

0802b888 <__aeabi_dcmplt>:
 802b888:	f84d ed08 	str.w	lr, [sp, #-8]!
 802b88c:	f7ff ffea 	bl	802b864 <__aeabi_cdcmpeq>
 802b890:	bf34      	ite	cc
 802b892:	2001      	movcc	r0, #1
 802b894:	2000      	movcs	r0, #0
 802b896:	f85d fb08 	ldr.w	pc, [sp], #8
 802b89a:	bf00      	nop

0802b89c <__aeabi_dcmple>:
 802b89c:	f84d ed08 	str.w	lr, [sp, #-8]!
 802b8a0:	f7ff ffe0 	bl	802b864 <__aeabi_cdcmpeq>
 802b8a4:	bf94      	ite	ls
 802b8a6:	2001      	movls	r0, #1
 802b8a8:	2000      	movhi	r0, #0
 802b8aa:	f85d fb08 	ldr.w	pc, [sp], #8
 802b8ae:	bf00      	nop

0802b8b0 <__aeabi_dcmpge>:
 802b8b0:	f84d ed08 	str.w	lr, [sp, #-8]!
 802b8b4:	f7ff ffce 	bl	802b854 <__aeabi_cdrcmple>
 802b8b8:	bf94      	ite	ls
 802b8ba:	2001      	movls	r0, #1
 802b8bc:	2000      	movhi	r0, #0
 802b8be:	f85d fb08 	ldr.w	pc, [sp], #8
 802b8c2:	bf00      	nop

0802b8c4 <__aeabi_dcmpgt>:
 802b8c4:	f84d ed08 	str.w	lr, [sp, #-8]!
 802b8c8:	f7ff ffc4 	bl	802b854 <__aeabi_cdrcmple>
 802b8cc:	bf34      	ite	cc
 802b8ce:	2001      	movcc	r0, #1
 802b8d0:	2000      	movcs	r0, #0
 802b8d2:	f85d fb08 	ldr.w	pc, [sp], #8
 802b8d6:	bf00      	nop

0802b8d8 <__aeabi_d2iz>:
 802b8d8:	ea4f 0241 	mov.w	r2, r1, lsl #1
 802b8dc:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 802b8e0:	d215      	bcs.n	802b90e <__aeabi_d2iz+0x36>
 802b8e2:	d511      	bpl.n	802b908 <__aeabi_d2iz+0x30>
 802b8e4:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 802b8e8:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 802b8ec:	d912      	bls.n	802b914 <__aeabi_d2iz+0x3c>
 802b8ee:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 802b8f2:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 802b8f6:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 802b8fa:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 802b8fe:	fa23 f002 	lsr.w	r0, r3, r2
 802b902:	bf18      	it	ne
 802b904:	4240      	negne	r0, r0
 802b906:	4770      	bx	lr
 802b908:	f04f 0000 	mov.w	r0, #0
 802b90c:	4770      	bx	lr
 802b90e:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 802b912:	d105      	bne.n	802b920 <__aeabi_d2iz+0x48>
 802b914:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 802b918:	bf08      	it	eq
 802b91a:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 802b91e:	4770      	bx	lr
 802b920:	f04f 0000 	mov.w	r0, #0
 802b924:	4770      	bx	lr
 802b926:	bf00      	nop

0802b928 <__aeabi_frsub>:
 802b928:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
 802b92c:	e002      	b.n	802b934 <__addsf3>
 802b92e:	bf00      	nop

0802b930 <__aeabi_fsub>:
 802b930:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

0802b934 <__addsf3>:
 802b934:	0042      	lsls	r2, r0, #1
 802b936:	bf1f      	itttt	ne
 802b938:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 802b93c:	ea92 0f03 	teqne	r2, r3
 802b940:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 802b944:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 802b948:	d06a      	beq.n	802ba20 <__addsf3+0xec>
 802b94a:	ea4f 6212 	mov.w	r2, r2, lsr #24
 802b94e:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 802b952:	bfc1      	itttt	gt
 802b954:	18d2      	addgt	r2, r2, r3
 802b956:	4041      	eorgt	r1, r0
 802b958:	4048      	eorgt	r0, r1
 802b95a:	4041      	eorgt	r1, r0
 802b95c:	bfb8      	it	lt
 802b95e:	425b      	neglt	r3, r3
 802b960:	2b19      	cmp	r3, #25
 802b962:	bf88      	it	hi
 802b964:	4770      	bxhi	lr
 802b966:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 802b96a:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 802b96e:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 802b972:	bf18      	it	ne
 802b974:	4240      	negne	r0, r0
 802b976:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 802b97a:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 802b97e:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 802b982:	bf18      	it	ne
 802b984:	4249      	negne	r1, r1
 802b986:	ea92 0f03 	teq	r2, r3
 802b98a:	d03f      	beq.n	802ba0c <__addsf3+0xd8>
 802b98c:	f1a2 0201 	sub.w	r2, r2, #1
 802b990:	fa41 fc03 	asr.w	ip, r1, r3
 802b994:	eb10 000c 	adds.w	r0, r0, ip
 802b998:	f1c3 0320 	rsb	r3, r3, #32
 802b99c:	fa01 f103 	lsl.w	r1, r1, r3
 802b9a0:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 802b9a4:	d502      	bpl.n	802b9ac <__addsf3+0x78>
 802b9a6:	4249      	negs	r1, r1
 802b9a8:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 802b9ac:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 802b9b0:	d313      	bcc.n	802b9da <__addsf3+0xa6>
 802b9b2:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 802b9b6:	d306      	bcc.n	802b9c6 <__addsf3+0x92>
 802b9b8:	0840      	lsrs	r0, r0, #1
 802b9ba:	ea4f 0131 	mov.w	r1, r1, rrx
 802b9be:	f102 0201 	add.w	r2, r2, #1
 802b9c2:	2afe      	cmp	r2, #254	; 0xfe
 802b9c4:	d251      	bcs.n	802ba6a <__addsf3+0x136>
 802b9c6:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 802b9ca:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 802b9ce:	bf08      	it	eq
 802b9d0:	f020 0001 	biceq.w	r0, r0, #1
 802b9d4:	ea40 0003 	orr.w	r0, r0, r3
 802b9d8:	4770      	bx	lr
 802b9da:	0049      	lsls	r1, r1, #1
 802b9dc:	eb40 0000 	adc.w	r0, r0, r0
 802b9e0:	3a01      	subs	r2, #1
 802b9e2:	bf28      	it	cs
 802b9e4:	f5b0 0f00 	cmpcs.w	r0, #8388608	; 0x800000
 802b9e8:	d2ed      	bcs.n	802b9c6 <__addsf3+0x92>
 802b9ea:	fab0 fc80 	clz	ip, r0
 802b9ee:	f1ac 0c08 	sub.w	ip, ip, #8
 802b9f2:	ebb2 020c 	subs.w	r2, r2, ip
 802b9f6:	fa00 f00c 	lsl.w	r0, r0, ip
 802b9fa:	bfaa      	itet	ge
 802b9fc:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 802ba00:	4252      	neglt	r2, r2
 802ba02:	4318      	orrge	r0, r3
 802ba04:	bfbc      	itt	lt
 802ba06:	40d0      	lsrlt	r0, r2
 802ba08:	4318      	orrlt	r0, r3
 802ba0a:	4770      	bx	lr
 802ba0c:	f092 0f00 	teq	r2, #0
 802ba10:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
 802ba14:	bf06      	itte	eq
 802ba16:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
 802ba1a:	3201      	addeq	r2, #1
 802ba1c:	3b01      	subne	r3, #1
 802ba1e:	e7b5      	b.n	802b98c <__addsf3+0x58>
 802ba20:	ea4f 0341 	mov.w	r3, r1, lsl #1
 802ba24:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 802ba28:	bf18      	it	ne
 802ba2a:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 802ba2e:	d021      	beq.n	802ba74 <__addsf3+0x140>
 802ba30:	ea92 0f03 	teq	r2, r3
 802ba34:	d004      	beq.n	802ba40 <__addsf3+0x10c>
 802ba36:	f092 0f00 	teq	r2, #0
 802ba3a:	bf08      	it	eq
 802ba3c:	4608      	moveq	r0, r1
 802ba3e:	4770      	bx	lr
 802ba40:	ea90 0f01 	teq	r0, r1
 802ba44:	bf1c      	itt	ne
 802ba46:	2000      	movne	r0, #0
 802ba48:	4770      	bxne	lr
 802ba4a:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
 802ba4e:	d104      	bne.n	802ba5a <__addsf3+0x126>
 802ba50:	0040      	lsls	r0, r0, #1
 802ba52:	bf28      	it	cs
 802ba54:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
 802ba58:	4770      	bx	lr
 802ba5a:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 802ba5e:	bf3c      	itt	cc
 802ba60:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
 802ba64:	4770      	bxcc	lr
 802ba66:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 802ba6a:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
 802ba6e:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 802ba72:	4770      	bx	lr
 802ba74:	ea7f 6222 	mvns.w	r2, r2, asr #24
 802ba78:	bf16      	itet	ne
 802ba7a:	4608      	movne	r0, r1
 802ba7c:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 802ba80:	4601      	movne	r1, r0
 802ba82:	0242      	lsls	r2, r0, #9
 802ba84:	bf06      	itte	eq
 802ba86:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 802ba8a:	ea90 0f01 	teqeq	r0, r1
 802ba8e:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
 802ba92:	4770      	bx	lr

0802ba94 <__aeabi_ui2f>:
 802ba94:	f04f 0300 	mov.w	r3, #0
 802ba98:	e004      	b.n	802baa4 <__aeabi_i2f+0x8>
 802ba9a:	bf00      	nop

0802ba9c <__aeabi_i2f>:
 802ba9c:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
 802baa0:	bf48      	it	mi
 802baa2:	4240      	negmi	r0, r0
 802baa4:	ea5f 0c00 	movs.w	ip, r0
 802baa8:	bf08      	it	eq
 802baaa:	4770      	bxeq	lr
 802baac:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
 802bab0:	4601      	mov	r1, r0
 802bab2:	f04f 0000 	mov.w	r0, #0
 802bab6:	e01c      	b.n	802baf2 <__aeabi_l2f+0x2a>

0802bab8 <__aeabi_ul2f>:
 802bab8:	ea50 0201 	orrs.w	r2, r0, r1
 802babc:	bf08      	it	eq
 802babe:	4770      	bxeq	lr
 802bac0:	f04f 0300 	mov.w	r3, #0
 802bac4:	e00a      	b.n	802badc <__aeabi_l2f+0x14>
 802bac6:	bf00      	nop

0802bac8 <__aeabi_l2f>:
 802bac8:	ea50 0201 	orrs.w	r2, r0, r1
 802bacc:	bf08      	it	eq
 802bace:	4770      	bxeq	lr
 802bad0:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
 802bad4:	d502      	bpl.n	802badc <__aeabi_l2f+0x14>
 802bad6:	4240      	negs	r0, r0
 802bad8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 802badc:	ea5f 0c01 	movs.w	ip, r1
 802bae0:	bf02      	ittt	eq
 802bae2:	4684      	moveq	ip, r0
 802bae4:	4601      	moveq	r1, r0
 802bae6:	2000      	moveq	r0, #0
 802bae8:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
 802baec:	bf08      	it	eq
 802baee:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
 802baf2:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 802baf6:	fabc f28c 	clz	r2, ip
 802bafa:	3a08      	subs	r2, #8
 802bafc:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 802bb00:	db10      	blt.n	802bb24 <__aeabi_l2f+0x5c>
 802bb02:	fa01 fc02 	lsl.w	ip, r1, r2
 802bb06:	4463      	add	r3, ip
 802bb08:	fa00 fc02 	lsl.w	ip, r0, r2
 802bb0c:	f1c2 0220 	rsb	r2, r2, #32
 802bb10:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 802bb14:	fa20 f202 	lsr.w	r2, r0, r2
 802bb18:	eb43 0002 	adc.w	r0, r3, r2
 802bb1c:	bf08      	it	eq
 802bb1e:	f020 0001 	biceq.w	r0, r0, #1
 802bb22:	4770      	bx	lr
 802bb24:	f102 0220 	add.w	r2, r2, #32
 802bb28:	fa01 fc02 	lsl.w	ip, r1, r2
 802bb2c:	f1c2 0220 	rsb	r2, r2, #32
 802bb30:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 802bb34:	fa21 f202 	lsr.w	r2, r1, r2
 802bb38:	eb43 0002 	adc.w	r0, r3, r2
 802bb3c:	bf08      	it	eq
 802bb3e:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 802bb42:	4770      	bx	lr

0802bb44 <__aeabi_uldivmod>:
 802bb44:	b953      	cbnz	r3, 802bb5c <__aeabi_uldivmod+0x18>
 802bb46:	b94a      	cbnz	r2, 802bb5c <__aeabi_uldivmod+0x18>
 802bb48:	2900      	cmp	r1, #0
 802bb4a:	bf08      	it	eq
 802bb4c:	2800      	cmpeq	r0, #0
 802bb4e:	bf1c      	itt	ne
 802bb50:	f04f 31ff 	movne.w	r1, #4294967295
 802bb54:	f04f 30ff 	movne.w	r0, #4294967295
 802bb58:	f000 b96c 	b.w	802be34 <__aeabi_idiv0>
 802bb5c:	f1ad 0c08 	sub.w	ip, sp, #8
 802bb60:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 802bb64:	f000 f806 	bl	802bb74 <__udivmoddi4>
 802bb68:	f8dd e004 	ldr.w	lr, [sp, #4]
 802bb6c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 802bb70:	b004      	add	sp, #16
 802bb72:	4770      	bx	lr

0802bb74 <__udivmoddi4>:
 802bb74:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 802bb78:	9e08      	ldr	r6, [sp, #32]
 802bb7a:	460d      	mov	r5, r1
 802bb7c:	4604      	mov	r4, r0
 802bb7e:	468e      	mov	lr, r1
 802bb80:	2b00      	cmp	r3, #0
 802bb82:	f040 8082 	bne.w	802bc8a <__udivmoddi4+0x116>
 802bb86:	428a      	cmp	r2, r1
 802bb88:	4617      	mov	r7, r2
 802bb8a:	d946      	bls.n	802bc1a <__udivmoddi4+0xa6>
 802bb8c:	fab2 f282 	clz	r2, r2
 802bb90:	b14a      	cbz	r2, 802bba6 <__udivmoddi4+0x32>
 802bb92:	f1c2 0120 	rsb	r1, r2, #32
 802bb96:	fa05 f302 	lsl.w	r3, r5, r2
 802bb9a:	fa20 f101 	lsr.w	r1, r0, r1
 802bb9e:	4097      	lsls	r7, r2
 802bba0:	ea41 0e03 	orr.w	lr, r1, r3
 802bba4:	4094      	lsls	r4, r2
 802bba6:	ea4f 4817 	mov.w	r8, r7, lsr #16
 802bbaa:	0c23      	lsrs	r3, r4, #16
 802bbac:	fbbe fcf8 	udiv	ip, lr, r8
 802bbb0:	b2b9      	uxth	r1, r7
 802bbb2:	fb08 ee1c 	mls	lr, r8, ip, lr
 802bbb6:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
 802bbba:	fb0c f001 	mul.w	r0, ip, r1
 802bbbe:	4298      	cmp	r0, r3
 802bbc0:	d90a      	bls.n	802bbd8 <__udivmoddi4+0x64>
 802bbc2:	18fb      	adds	r3, r7, r3
 802bbc4:	f10c 35ff 	add.w	r5, ip, #4294967295
 802bbc8:	f080 8116 	bcs.w	802bdf8 <__udivmoddi4+0x284>
 802bbcc:	4298      	cmp	r0, r3
 802bbce:	f240 8113 	bls.w	802bdf8 <__udivmoddi4+0x284>
 802bbd2:	f1ac 0c02 	sub.w	ip, ip, #2
 802bbd6:	443b      	add	r3, r7
 802bbd8:	1a1b      	subs	r3, r3, r0
 802bbda:	b2a4      	uxth	r4, r4
 802bbdc:	fbb3 f0f8 	udiv	r0, r3, r8
 802bbe0:	fb08 3310 	mls	r3, r8, r0, r3
 802bbe4:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 802bbe8:	fb00 f101 	mul.w	r1, r0, r1
 802bbec:	42a1      	cmp	r1, r4
 802bbee:	d909      	bls.n	802bc04 <__udivmoddi4+0x90>
 802bbf0:	193c      	adds	r4, r7, r4
 802bbf2:	f100 33ff 	add.w	r3, r0, #4294967295
 802bbf6:	f080 8101 	bcs.w	802bdfc <__udivmoddi4+0x288>
 802bbfa:	42a1      	cmp	r1, r4
 802bbfc:	f240 80fe 	bls.w	802bdfc <__udivmoddi4+0x288>
 802bc00:	3802      	subs	r0, #2
 802bc02:	443c      	add	r4, r7
 802bc04:	1a64      	subs	r4, r4, r1
 802bc06:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 802bc0a:	2100      	movs	r1, #0
 802bc0c:	b11e      	cbz	r6, 802bc16 <__udivmoddi4+0xa2>
 802bc0e:	40d4      	lsrs	r4, r2
 802bc10:	2300      	movs	r3, #0
 802bc12:	e9c6 4300 	strd	r4, r3, [r6]
 802bc16:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802bc1a:	b902      	cbnz	r2, 802bc1e <__udivmoddi4+0xaa>
 802bc1c:	deff      	udf	#255	; 0xff
 802bc1e:	fab2 f282 	clz	r2, r2
 802bc22:	2a00      	cmp	r2, #0
 802bc24:	d14f      	bne.n	802bcc6 <__udivmoddi4+0x152>
 802bc26:	1bcb      	subs	r3, r1, r7
 802bc28:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 802bc2c:	fa1f f887 	uxth.w	r8, r7
 802bc30:	2101      	movs	r1, #1
 802bc32:	fbb3 fcfe 	udiv	ip, r3, lr
 802bc36:	0c25      	lsrs	r5, r4, #16
 802bc38:	fb0e 331c 	mls	r3, lr, ip, r3
 802bc3c:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 802bc40:	fb08 f30c 	mul.w	r3, r8, ip
 802bc44:	42ab      	cmp	r3, r5
 802bc46:	d907      	bls.n	802bc58 <__udivmoddi4+0xe4>
 802bc48:	197d      	adds	r5, r7, r5
 802bc4a:	f10c 30ff 	add.w	r0, ip, #4294967295
 802bc4e:	d202      	bcs.n	802bc56 <__udivmoddi4+0xe2>
 802bc50:	42ab      	cmp	r3, r5
 802bc52:	f200 80e7 	bhi.w	802be24 <__udivmoddi4+0x2b0>
 802bc56:	4684      	mov	ip, r0
 802bc58:	1aed      	subs	r5, r5, r3
 802bc5a:	b2a3      	uxth	r3, r4
 802bc5c:	fbb5 f0fe 	udiv	r0, r5, lr
 802bc60:	fb0e 5510 	mls	r5, lr, r0, r5
 802bc64:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
 802bc68:	fb08 f800 	mul.w	r8, r8, r0
 802bc6c:	45a0      	cmp	r8, r4
 802bc6e:	d907      	bls.n	802bc80 <__udivmoddi4+0x10c>
 802bc70:	193c      	adds	r4, r7, r4
 802bc72:	f100 33ff 	add.w	r3, r0, #4294967295
 802bc76:	d202      	bcs.n	802bc7e <__udivmoddi4+0x10a>
 802bc78:	45a0      	cmp	r8, r4
 802bc7a:	f200 80d7 	bhi.w	802be2c <__udivmoddi4+0x2b8>
 802bc7e:	4618      	mov	r0, r3
 802bc80:	eba4 0408 	sub.w	r4, r4, r8
 802bc84:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 802bc88:	e7c0      	b.n	802bc0c <__udivmoddi4+0x98>
 802bc8a:	428b      	cmp	r3, r1
 802bc8c:	d908      	bls.n	802bca0 <__udivmoddi4+0x12c>
 802bc8e:	2e00      	cmp	r6, #0
 802bc90:	f000 80af 	beq.w	802bdf2 <__udivmoddi4+0x27e>
 802bc94:	2100      	movs	r1, #0
 802bc96:	e9c6 0500 	strd	r0, r5, [r6]
 802bc9a:	4608      	mov	r0, r1
 802bc9c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802bca0:	fab3 f183 	clz	r1, r3
 802bca4:	2900      	cmp	r1, #0
 802bca6:	d14b      	bne.n	802bd40 <__udivmoddi4+0x1cc>
 802bca8:	42ab      	cmp	r3, r5
 802bcaa:	d302      	bcc.n	802bcb2 <__udivmoddi4+0x13e>
 802bcac:	4282      	cmp	r2, r0
 802bcae:	f200 80b7 	bhi.w	802be20 <__udivmoddi4+0x2ac>
 802bcb2:	1a84      	subs	r4, r0, r2
 802bcb4:	eb65 0303 	sbc.w	r3, r5, r3
 802bcb8:	2001      	movs	r0, #1
 802bcba:	469e      	mov	lr, r3
 802bcbc:	2e00      	cmp	r6, #0
 802bcbe:	d0aa      	beq.n	802bc16 <__udivmoddi4+0xa2>
 802bcc0:	e9c6 4e00 	strd	r4, lr, [r6]
 802bcc4:	e7a7      	b.n	802bc16 <__udivmoddi4+0xa2>
 802bcc6:	f1c2 0c20 	rsb	ip, r2, #32
 802bcca:	fa01 f302 	lsl.w	r3, r1, r2
 802bcce:	4097      	lsls	r7, r2
 802bcd0:	fa20 f00c 	lsr.w	r0, r0, ip
 802bcd4:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 802bcd8:	fa21 fc0c 	lsr.w	ip, r1, ip
 802bcdc:	4318      	orrs	r0, r3
 802bcde:	fbbc f1fe 	udiv	r1, ip, lr
 802bce2:	0c05      	lsrs	r5, r0, #16
 802bce4:	fb0e cc11 	mls	ip, lr, r1, ip
 802bce8:	fa1f f887 	uxth.w	r8, r7
 802bcec:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
 802bcf0:	fb01 f308 	mul.w	r3, r1, r8
 802bcf4:	42ab      	cmp	r3, r5
 802bcf6:	fa04 f402 	lsl.w	r4, r4, r2
 802bcfa:	d909      	bls.n	802bd10 <__udivmoddi4+0x19c>
 802bcfc:	197d      	adds	r5, r7, r5
 802bcfe:	f101 3cff 	add.w	ip, r1, #4294967295
 802bd02:	f080 808b 	bcs.w	802be1c <__udivmoddi4+0x2a8>
 802bd06:	42ab      	cmp	r3, r5
 802bd08:	f240 8088 	bls.w	802be1c <__udivmoddi4+0x2a8>
 802bd0c:	3902      	subs	r1, #2
 802bd0e:	443d      	add	r5, r7
 802bd10:	1aeb      	subs	r3, r5, r3
 802bd12:	b285      	uxth	r5, r0
 802bd14:	fbb3 f0fe 	udiv	r0, r3, lr
 802bd18:	fb0e 3310 	mls	r3, lr, r0, r3
 802bd1c:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 802bd20:	fb00 f308 	mul.w	r3, r0, r8
 802bd24:	42ab      	cmp	r3, r5
 802bd26:	d907      	bls.n	802bd38 <__udivmoddi4+0x1c4>
 802bd28:	197d      	adds	r5, r7, r5
 802bd2a:	f100 3cff 	add.w	ip, r0, #4294967295
 802bd2e:	d271      	bcs.n	802be14 <__udivmoddi4+0x2a0>
 802bd30:	42ab      	cmp	r3, r5
 802bd32:	d96f      	bls.n	802be14 <__udivmoddi4+0x2a0>
 802bd34:	3802      	subs	r0, #2
 802bd36:	443d      	add	r5, r7
 802bd38:	1aeb      	subs	r3, r5, r3
 802bd3a:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 802bd3e:	e778      	b.n	802bc32 <__udivmoddi4+0xbe>
 802bd40:	f1c1 0c20 	rsb	ip, r1, #32
 802bd44:	408b      	lsls	r3, r1
 802bd46:	fa22 f70c 	lsr.w	r7, r2, ip
 802bd4a:	431f      	orrs	r7, r3
 802bd4c:	fa20 f40c 	lsr.w	r4, r0, ip
 802bd50:	fa05 f301 	lsl.w	r3, r5, r1
 802bd54:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 802bd58:	fa25 f50c 	lsr.w	r5, r5, ip
 802bd5c:	431c      	orrs	r4, r3
 802bd5e:	0c23      	lsrs	r3, r4, #16
 802bd60:	fbb5 f9fe 	udiv	r9, r5, lr
 802bd64:	fa1f f887 	uxth.w	r8, r7
 802bd68:	fb0e 5519 	mls	r5, lr, r9, r5
 802bd6c:	ea43 4505 	orr.w	r5, r3, r5, lsl #16
 802bd70:	fb09 fa08 	mul.w	sl, r9, r8
 802bd74:	45aa      	cmp	sl, r5
 802bd76:	fa02 f201 	lsl.w	r2, r2, r1
 802bd7a:	fa00 f301 	lsl.w	r3, r0, r1
 802bd7e:	d908      	bls.n	802bd92 <__udivmoddi4+0x21e>
 802bd80:	197d      	adds	r5, r7, r5
 802bd82:	f109 30ff 	add.w	r0, r9, #4294967295
 802bd86:	d247      	bcs.n	802be18 <__udivmoddi4+0x2a4>
 802bd88:	45aa      	cmp	sl, r5
 802bd8a:	d945      	bls.n	802be18 <__udivmoddi4+0x2a4>
 802bd8c:	f1a9 0902 	sub.w	r9, r9, #2
 802bd90:	443d      	add	r5, r7
 802bd92:	eba5 050a 	sub.w	r5, r5, sl
 802bd96:	b2a4      	uxth	r4, r4
 802bd98:	fbb5 f0fe 	udiv	r0, r5, lr
 802bd9c:	fb0e 5510 	mls	r5, lr, r0, r5
 802bda0:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 802bda4:	fb00 f808 	mul.w	r8, r0, r8
 802bda8:	45a0      	cmp	r8, r4
 802bdaa:	d907      	bls.n	802bdbc <__udivmoddi4+0x248>
 802bdac:	193c      	adds	r4, r7, r4
 802bdae:	f100 35ff 	add.w	r5, r0, #4294967295
 802bdb2:	d22d      	bcs.n	802be10 <__udivmoddi4+0x29c>
 802bdb4:	45a0      	cmp	r8, r4
 802bdb6:	d92b      	bls.n	802be10 <__udivmoddi4+0x29c>
 802bdb8:	3802      	subs	r0, #2
 802bdba:	443c      	add	r4, r7
 802bdbc:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 802bdc0:	eba4 0408 	sub.w	r4, r4, r8
 802bdc4:	fba0 8902 	umull	r8, r9, r0, r2
 802bdc8:	454c      	cmp	r4, r9
 802bdca:	46c6      	mov	lr, r8
 802bdcc:	464d      	mov	r5, r9
 802bdce:	d319      	bcc.n	802be04 <__udivmoddi4+0x290>
 802bdd0:	d016      	beq.n	802be00 <__udivmoddi4+0x28c>
 802bdd2:	b15e      	cbz	r6, 802bdec <__udivmoddi4+0x278>
 802bdd4:	ebb3 020e 	subs.w	r2, r3, lr
 802bdd8:	eb64 0405 	sbc.w	r4, r4, r5
 802bddc:	fa04 fc0c 	lsl.w	ip, r4, ip
 802bde0:	40ca      	lsrs	r2, r1
 802bde2:	ea4c 0202 	orr.w	r2, ip, r2
 802bde6:	40cc      	lsrs	r4, r1
 802bde8:	e9c6 2400 	strd	r2, r4, [r6]
 802bdec:	2100      	movs	r1, #0
 802bdee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802bdf2:	4631      	mov	r1, r6
 802bdf4:	4630      	mov	r0, r6
 802bdf6:	e70e      	b.n	802bc16 <__udivmoddi4+0xa2>
 802bdf8:	46ac      	mov	ip, r5
 802bdfa:	e6ed      	b.n	802bbd8 <__udivmoddi4+0x64>
 802bdfc:	4618      	mov	r0, r3
 802bdfe:	e701      	b.n	802bc04 <__udivmoddi4+0x90>
 802be00:	4543      	cmp	r3, r8
 802be02:	d2e6      	bcs.n	802bdd2 <__udivmoddi4+0x25e>
 802be04:	ebb8 0e02 	subs.w	lr, r8, r2
 802be08:	eb69 0507 	sbc.w	r5, r9, r7
 802be0c:	3801      	subs	r0, #1
 802be0e:	e7e0      	b.n	802bdd2 <__udivmoddi4+0x25e>
 802be10:	4628      	mov	r0, r5
 802be12:	e7d3      	b.n	802bdbc <__udivmoddi4+0x248>
 802be14:	4660      	mov	r0, ip
 802be16:	e78f      	b.n	802bd38 <__udivmoddi4+0x1c4>
 802be18:	4681      	mov	r9, r0
 802be1a:	e7ba      	b.n	802bd92 <__udivmoddi4+0x21e>
 802be1c:	4661      	mov	r1, ip
 802be1e:	e777      	b.n	802bd10 <__udivmoddi4+0x19c>
 802be20:	4608      	mov	r0, r1
 802be22:	e74b      	b.n	802bcbc <__udivmoddi4+0x148>
 802be24:	f1ac 0c02 	sub.w	ip, ip, #2
 802be28:	443d      	add	r5, r7
 802be2a:	e715      	b.n	802bc58 <__udivmoddi4+0xe4>
 802be2c:	3802      	subs	r0, #2
 802be2e:	443c      	add	r4, r7
 802be30:	e726      	b.n	802bc80 <__udivmoddi4+0x10c>
 802be32:	bf00      	nop

0802be34 <__aeabi_idiv0>:
 802be34:	4770      	bx	lr
 802be36:	bf00      	nop

0802be38 <MX_ADC_Init>:
  /* USER CODE BEGIN ADC_Init 1 */

  /* USER CODE END ADC_Init 1 */
  /** Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion)
  */
  hadc.Instance = ADC;
 802be38:	4813      	ldr	r0, [pc, #76]	; (802be88 <MX_ADC_Init+0x50>)
  hadc.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
 802be3a:	4a14      	ldr	r2, [pc, #80]	; (802be8c <MX_ADC_Init+0x54>)
{
 802be3c:	b508      	push	{r3, lr}
  hadc.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
 802be3e:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 802be42:	e9c0 2300 	strd	r2, r3, [r0]
  hadc.Init.Resolution = ADC_RESOLUTION_12B;
  hadc.Init.DataAlign = ADC_DATAALIGN_RIGHT;
  hadc.Init.ScanConvMode = ADC_SCAN_DISABLE;
  hadc.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 802be46:	2204      	movs	r2, #4
  hadc.Init.Resolution = ADC_RESOLUTION_12B;
 802be48:	2300      	movs	r3, #0
  hadc.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 802be4a:	6142      	str	r2, [r0, #20]
  hadc.Init.LowPowerAutoWait = DISABLE;
  hadc.Init.LowPowerAutoPowerOff = DISABLE;
  hadc.Init.ContinuousConvMode = DISABLE;
  hadc.Init.NbrOfConversion = 1;
 802be4c:	2201      	movs	r2, #1
 802be4e:	61c2      	str	r2, [r0, #28]
  hadc.Init.DiscontinuousConvMode = DISABLE;
  hadc.Init.ExternalTrigConv = ADC_SOFTWARE_START;
  hadc.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
  hadc.Init.DMAContinuousRequests = DISABLE;
  hadc.Init.Overrun = ADC_OVR_DATA_OVERWRITTEN;
  hadc.Init.SamplingTimeCommon1 = ADC_SAMPLETIME_160CYCLES_5;
 802be50:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 802be54:	2207      	movs	r2, #7
  hadc.Init.LowPowerAutoWait = DISABLE;
 802be56:	8303      	strh	r3, [r0, #24]
  hadc.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 802be58:	e9c0 3302 	strd	r3, r3, [r0, #8]
  hadc.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 802be5c:	e9c0 3309 	strd	r3, r3, [r0, #36]	; 0x24
  hadc.Init.SamplingTimeCommon1 = ADC_SAMPLETIME_160CYCLES_5;
 802be60:	e9c0 120c 	strd	r1, r2, [r0, #48]	; 0x30
  hadc.Init.ScanConvMode = ADC_SCAN_DISABLE;
 802be64:	6103      	str	r3, [r0, #16]
  hadc.Init.ContinuousConvMode = DISABLE;
 802be66:	7683      	strb	r3, [r0, #26]
  hadc.Init.DiscontinuousConvMode = DISABLE;
 802be68:	f880 3020 	strb.w	r3, [r0, #32]
  hadc.Init.DMAContinuousRequests = DISABLE;
 802be6c:	f880 302c 	strb.w	r3, [r0, #44]	; 0x2c
  hadc.Init.SamplingTimeCommon2 = ADC_SAMPLETIME_160CYCLES_5;
 802be70:	6382      	str	r2, [r0, #56]	; 0x38
  hadc.Init.OversamplingMode = DISABLE;
 802be72:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  hadc.Init.TriggerFrequencyMode = ADC_TRIGGER_FREQ_HIGH;
 802be76:	64c3      	str	r3, [r0, #76]	; 0x4c
  if (HAL_ADC_Init(&hadc) != HAL_OK)
 802be78:	f001 fb3a 	bl	802d4f0 <HAL_ADC_Init>
 802be7c:	b118      	cbz	r0, 802be86 <MX_ADC_Init+0x4e>
  }
  /* USER CODE BEGIN ADC_Init 2 */

  /* USER CODE END ADC_Init 2 */

}
 802be7e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 802be82:	f000 ba17 	b.w	802c2b4 <Error_Handler>
}
 802be86:	bd08      	pop	{r3, pc}
 802be88:	20006154 	.word	0x20006154
 802be8c:	40012400 	.word	0x40012400

0802be90 <HAL_ADC_MspInit>:

void HAL_ADC_MspInit(ADC_HandleTypeDef* adcHandle)
{

  if(adcHandle->Instance==ADC)
 802be90:	6802      	ldr	r2, [r0, #0]
 802be92:	4b08      	ldr	r3, [pc, #32]	; (802beb4 <HAL_ADC_MspInit+0x24>)
 802be94:	429a      	cmp	r2, r3
{
 802be96:	b082      	sub	sp, #8
  if(adcHandle->Instance==ADC)
 802be98:	d10a      	bne.n	802beb0 <HAL_ADC_MspInit+0x20>
  * @retval None
  */
__STATIC_INLINE void LL_APB2_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB2ENR, Periphs);
 802be9a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802be9e:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 802bea0:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 802bea4:	661a      	str	r2, [r3, #96]	; 0x60
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
 802bea6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 802bea8:	f403 7300 	and.w	r3, r3, #512	; 0x200
 802beac:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 802beae:	9b01      	ldr	r3, [sp, #4]
    __HAL_RCC_ADC_CLK_ENABLE();
  /* USER CODE BEGIN ADC_MspInit 1 */

  /* USER CODE END ADC_MspInit 1 */
  }
}
 802beb0:	b002      	add	sp, #8
 802beb2:	4770      	bx	lr
 802beb4:	40012400 	.word	0x40012400

0802beb8 <HAL_ADC_MspDeInit>:

void HAL_ADC_MspDeInit(ADC_HandleTypeDef* adcHandle)
{

  if(adcHandle->Instance==ADC)
 802beb8:	6802      	ldr	r2, [r0, #0]
 802beba:	4b05      	ldr	r3, [pc, #20]	; (802bed0 <HAL_ADC_MspDeInit+0x18>)
 802bebc:	429a      	cmp	r2, r3
  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM17
  * @retval None
  */
__STATIC_INLINE void LL_APB2_GRP1_DisableClock(uint32_t Periphs)
{
  CLEAR_BIT(RCC->APB2ENR, Periphs);
 802bebe:	bf01      	itttt	eq
 802bec0:	f04f 42b0 	moveq.w	r2, #1476395008	; 0x58000000
 802bec4:	6e13      	ldreq	r3, [r2, #96]	; 0x60
 802bec6:	f423 7300 	biceq.w	r3, r3, #512	; 0x200
 802beca:	6613      	streq	r3, [r2, #96]	; 0x60
    __HAL_RCC_ADC_CLK_DISABLE();
  /* USER CODE BEGIN ADC_MspDeInit 1 */

  /* USER CODE END ADC_MspDeInit 1 */
  }
}
 802becc:	4770      	bx	lr
 802bece:	bf00      	nop
 802bed0:	40012400 	.word	0x40012400

0802bed4 <ADC_ReadChannels>:
/* USER CODE BEGIN PrFD */

/* USER CODE END PrFD */

static uint32_t ADC_ReadChannels(uint32_t channel)
{
 802bed4:	b530      	push	{r4, r5, lr}
 802bed6:	b085      	sub	sp, #20
  /* USER CODE BEGIN ADC_ReadChannels_1 */

  /* USER CODE END ADC_ReadChannels_1 */
  uint32_t ADCxConvertedValues = 0;
  ADC_ChannelConfTypeDef sConfig = {0};
 802bed8:	2400      	movs	r4, #0
{
 802beda:	4605      	mov	r5, r0
  ADC_ChannelConfTypeDef sConfig = {0};
 802bedc:	e9cd 4401 	strd	r4, r4, [sp, #4]
 802bee0:	9403      	str	r4, [sp, #12]

  MX_ADC_Init();
 802bee2:	f7ff ffa9 	bl	802be38 <MX_ADC_Init>

  /* Start Calibration */
  if (HAL_ADCEx_Calibration_Start(&hadc) != HAL_OK)
 802bee6:	4814      	ldr	r0, [pc, #80]	; (802bf38 <ADC_ReadChannels+0x64>)
 802bee8:	f001 feaa 	bl	802dc40 <HAL_ADCEx_Calibration_Start>
 802beec:	b108      	cbz	r0, 802bef2 <ADC_ReadChannels+0x1e>
  {
    Error_Handler();
 802beee:	f000 f9e1 	bl	802c2b4 <Error_Handler>

  /* Configure Regular Channel */
  sConfig.Channel = channel;
  sConfig.Rank = ADC_REGULAR_RANK_1;
  sConfig.SamplingTime = ADC_SAMPLINGTIME_COMMON_1;
  if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 802bef2:	4811      	ldr	r0, [pc, #68]	; (802bf38 <ADC_ReadChannels+0x64>)
  sConfig.SamplingTime = ADC_SAMPLINGTIME_COMMON_1;
 802bef4:	9403      	str	r4, [sp, #12]
  if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 802bef6:	a901      	add	r1, sp, #4
  sConfig.Rank = ADC_REGULAR_RANK_1;
 802bef8:	e9cd 5401 	strd	r5, r4, [sp, #4]
  if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 802befc:	f001 fc7a 	bl	802d7f4 <HAL_ADC_ConfigChannel>
 802bf00:	b108      	cbz	r0, 802bf06 <ADC_ReadChannels+0x32>
  {
    Error_Handler();
 802bf02:	f000 f9d7 	bl	802c2b4 <Error_Handler>
  }

  if (HAL_ADC_Start(&hadc) != HAL_OK)
 802bf06:	480c      	ldr	r0, [pc, #48]	; (802bf38 <ADC_ReadChannels+0x64>)
 802bf08:	f001 fdce 	bl	802daa8 <HAL_ADC_Start>
 802bf0c:	b108      	cbz	r0, 802bf12 <ADC_ReadChannels+0x3e>
  {
    /* Start Error */
    Error_Handler();
 802bf0e:	f000 f9d1 	bl	802c2b4 <Error_Handler>
  }
  /** Wait for end of conversion */
  HAL_ADC_PollForConversion(&hadc, HAL_MAX_DELAY);
 802bf12:	f04f 31ff 	mov.w	r1, #4294967295
 802bf16:	4808      	ldr	r0, [pc, #32]	; (802bf38 <ADC_ReadChannels+0x64>)
 802bf18:	f001 fc0e 	bl	802d738 <HAL_ADC_PollForConversion>

  /** Wait for end of conversion */
  HAL_ADC_Stop(&hadc) ;   /* it calls also ADC_Disable() */
 802bf1c:	4806      	ldr	r0, [pc, #24]	; (802bf38 <ADC_ReadChannels+0x64>)
 802bf1e:	f001 fe71 	bl	802dc04 <HAL_ADC_Stop>

  ADCxConvertedValues = HAL_ADC_GetValue(&hadc);
 802bf22:	4805      	ldr	r0, [pc, #20]	; (802bf38 <ADC_ReadChannels+0x64>)
 802bf24:	f001 fc63 	bl	802d7ee <HAL_ADC_GetValue>
 802bf28:	4604      	mov	r4, r0

  HAL_ADC_DeInit(&hadc);
 802bf2a:	4803      	ldr	r0, [pc, #12]	; (802bf38 <ADC_ReadChannels+0x64>)
 802bf2c:	f001 fe1e 	bl	802db6c <HAL_ADC_DeInit>

  return ADCxConvertedValues;
  /* USER CODE BEGIN ADC_ReadChannels_2 */

  /* USER CODE END ADC_ReadChannels_2 */
}
 802bf30:	4620      	mov	r0, r4
 802bf32:	b005      	add	sp, #20
 802bf34:	bd30      	pop	{r4, r5, pc}
 802bf36:	bf00      	nop
 802bf38:	20006154 	.word	0x20006154

0802bf3c <SYS_InitMeasurement>:
  hadc.Instance = ADC;
 802bf3c:	4b01      	ldr	r3, [pc, #4]	; (802bf44 <SYS_InitMeasurement+0x8>)
 802bf3e:	4a02      	ldr	r2, [pc, #8]	; (802bf48 <SYS_InitMeasurement+0xc>)
 802bf40:	601a      	str	r2, [r3, #0]
}
 802bf42:	4770      	bx	lr
 802bf44:	20006154 	.word	0x20006154
 802bf48:	40012400 	.word	0x40012400

0802bf4c <SYS_GetBatteryLevel>:
{
 802bf4c:	b508      	push	{r3, lr}
  measuredLevel = ADC_ReadChannels(ADC_CHANNEL_VREFINT);
 802bf4e:	4809      	ldr	r0, [pc, #36]	; (802bf74 <SYS_GetBatteryLevel+0x28>)
 802bf50:	f7ff ffc0 	bl	802bed4 <ADC_ReadChannels>
  if (measuredLevel == 0)
 802bf54:	b160      	cbz	r0, 802bf70 <SYS_GetBatteryLevel+0x24>
    if ((uint32_t)*VREFINT_CAL_ADDR != (uint32_t)0xFFFFU)
 802bf56:	4b08      	ldr	r3, [pc, #32]	; (802bf78 <SYS_GetBatteryLevel+0x2c>)
 802bf58:	881a      	ldrh	r2, [r3, #0]
 802bf5a:	f64f 73ff 	movw	r3, #65535	; 0xffff
 802bf5e:	429a      	cmp	r2, r3
      batteryLevelmV = __LL_ADC_CALC_VREFANALOG_VOLTAGE(measuredLevel,
 802bf60:	bf16      	itet	ne
 802bf62:	f640 43e4 	movwne	r3, #3300	; 0xce4
      batteryLevelmV = (VREFINT_CAL_VREF * 1510) / measuredLevel;
 802bf66:	4b05      	ldreq	r3, [pc, #20]	; (802bf7c <SYS_GetBatteryLevel+0x30>)
      batteryLevelmV = __LL_ADC_CALC_VREFANALOG_VOLTAGE(measuredLevel,
 802bf68:	4353      	mulne	r3, r2
      batteryLevelmV = (VREFINT_CAL_VREF * 1510) / measuredLevel;
 802bf6a:	fbb3 f0f0 	udiv	r0, r3, r0
 802bf6e:	b280      	uxth	r0, r0
}
 802bf70:	bd08      	pop	{r3, pc}
 802bf72:	bf00      	nop
 802bf74:	b4002000 	.word	0xb4002000
 802bf78:	1fff75aa 	.word	0x1fff75aa
 802bf7c:	004c08d8 	.word	0x004c08d8

0802bf80 <SYS_GetTemperatureLevel>:
{
 802bf80:	b513      	push	{r0, r1, r4, lr}
  uint16_t batteryLevelmV = SYS_GetBatteryLevel();
 802bf82:	f7ff ffe3 	bl	802bf4c <SYS_GetBatteryLevel>
 802bf86:	4604      	mov	r4, r0
  measuredLevel = ADC_ReadChannels(ADC_CHANNEL_TEMPSENSOR);
 802bf88:	4818      	ldr	r0, [pc, #96]	; (802bfec <SYS_GetTemperatureLevel+0x6c>)
 802bf8a:	f7ff ffa3 	bl	802bed4 <ADC_ReadChannels>
  if (((int32_t)*TEMPSENSOR_CAL2_ADDR - (int32_t)*TEMPSENSOR_CAL1_ADDR) != 0)
 802bf8e:	4b18      	ldr	r3, [pc, #96]	; (802bff0 <SYS_GetTemperatureLevel+0x70>)
 802bf90:	4a18      	ldr	r2, [pc, #96]	; (802bff4 <SYS_GetTemperatureLevel+0x74>)
 802bf92:	881b      	ldrh	r3, [r3, #0]
 802bf94:	8812      	ldrh	r2, [r2, #0]
 802bf96:	4293      	cmp	r3, r2
 802bf98:	fb00 f004 	mul.w	r0, r0, r4
 802bf9c:	d016      	beq.n	802bfcc <SYS_GetTemperatureLevel+0x4c>
    temperatureDegreeC = __LL_ADC_CALC_TEMPERATURE(batteryLevelmV,
 802bf9e:	f640 44e4 	movw	r4, #3300	; 0xce4
 802bfa2:	fbb0 f0f4 	udiv	r0, r0, r4
 802bfa6:	2464      	movs	r4, #100	; 0x64
 802bfa8:	1a80      	subs	r0, r0, r2
 802bfaa:	4344      	muls	r4, r0
 802bfac:	1a9b      	subs	r3, r3, r2
 802bfae:	fb94 f4f3 	sdiv	r4, r4, r3
    temperatureDegreeC = __LL_ADC_CALC_TEMPERATURE_TYP_PARAMS(TEMPSENSOR_TYP_AVGSLOPE,
 802bfb2:	341e      	adds	r4, #30
 802bfb4:	b224      	sxth	r4, r4
  APP_LOG(TS_ON, VLEVEL_L, "temp= %d\n\r", temperatureDegreeC);
 802bfb6:	2201      	movs	r2, #1
 802bfb8:	4b0f      	ldr	r3, [pc, #60]	; (802bff8 <SYS_GetTemperatureLevel+0x78>)
 802bfba:	9400      	str	r4, [sp, #0]
 802bfbc:	2100      	movs	r1, #0
 802bfbe:	4610      	mov	r0, r2
 802bfc0:	f00e fe64 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
  temperatureDegreeC <<= 8;
 802bfc4:	0220      	lsls	r0, r4, #8
}
 802bfc6:	b200      	sxth	r0, r0
 802bfc8:	b002      	add	sp, #8
 802bfca:	bd10      	pop	{r4, pc}
    temperatureDegreeC = __LL_ADC_CALC_TEMPERATURE_TYP_PARAMS(TEMPSENSOR_TYP_AVGSLOPE,
 802bfcc:	f640 74ff 	movw	r4, #4095	; 0xfff
 802bfd0:	fbb0 f0f4 	udiv	r0, r0, r4
 802bfd4:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 802bfd8:	4344      	muls	r4, r0
 802bfda:	f5a4 2439 	sub.w	r4, r4, #757760	; 0xb9000
 802bfde:	f5a4 640c 	sub.w	r4, r4, #2240	; 0x8c0
 802bfe2:	f640 10c4 	movw	r0, #2500	; 0x9c4
 802bfe6:	fb94 f4f0 	sdiv	r4, r4, r0
 802bfea:	e7e2      	b.n	802bfb2 <SYS_GetTemperatureLevel+0x32>
 802bfec:	b0001000 	.word	0xb0001000
 802bff0:	1fff75c8 	.word	0x1fff75c8
 802bff4:	1fff75a8 	.word	0x1fff75a8
 802bff8:	0803bd18 	.word	0x0803bd18

0802bffc <MX_DMA_Init>:
  SET_BIT(RCC->AHB1ENR, Periphs);
 802bffc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000

/**
  * Enable DMA controller clock
  */
void MX_DMA_Init(void)
{
 802c000:	b507      	push	{r0, r1, r2, lr}
 802c002:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 802c004:	f042 0204 	orr.w	r2, r2, #4
 802c008:	649a      	str	r2, [r3, #72]	; 0x48
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 802c00a:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 802c00c:	f002 0204 	and.w	r2, r2, #4
 802c010:	9201      	str	r2, [sp, #4]
  (void)tmpreg;
 802c012:	9a01      	ldr	r2, [sp, #4]
  SET_BIT(RCC->AHB1ENR, Periphs);
 802c014:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 802c016:	f042 0201 	orr.w	r2, r2, #1
 802c01a:	649a      	str	r2, [r3, #72]	; 0x48
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 802c01c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 802c01e:	f003 0301 	and.w	r3, r3, #1
 802c022:	9300      	str	r3, [sp, #0]
  __HAL_RCC_DMAMUX1_CLK_ENABLE();
  __HAL_RCC_DMA1_CLK_ENABLE();

  /* DMA interrupt init */
  /* DMA1_Channel5_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Channel5_IRQn, 2, 0);
 802c024:	2200      	movs	r2, #0
 802c026:	2102      	movs	r1, #2
 802c028:	200f      	movs	r0, #15
  (void)tmpreg;
 802c02a:	9b00      	ldr	r3, [sp, #0]
 802c02c:	f001 fe66 	bl	802dcfc <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel5_IRQn);
 802c030:	200f      	movs	r0, #15

}
 802c032:	b003      	add	sp, #12
 802c034:	f85d eb04 	ldr.w	lr, [sp], #4
  HAL_NVIC_EnableIRQ(DMA1_Channel5_IRQn);
 802c038:	f001 be92 	b.w	802dd60 <HAL_NVIC_EnableIRQ>

0802c03c <FLASH_IF_Write64>:

  /* USER CODE END FLASH_IF_Write_2 */
}

int32_t FLASH_IF_Write64(uint32_t address, uint64_t data)
{
 802c03c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
__STATIC_INLINE uint32_t LL_FLASH_IsActiveFlag_OperationSuspended(void)
{
#if defined(CORE_CM0PLUS)
  return ((READ_BIT(FLASH->C2SR, FLASH_C2SR_PESD) == (FLASH_C2SR_PESD)) ? 1UL : 0UL);
#else
  return ((READ_BIT(FLASH->SR, FLASH_SR_PESD) == (FLASH_SR_PESD)) ? 1UL : 0UL);
 802c03e:	4f0b      	ldr	r7, [pc, #44]	; (802c06c <FLASH_IF_Write64+0x30>)
 802c040:	4606      	mov	r6, r0
 802c042:	4614      	mov	r4, r2
 802c044:	461d      	mov	r5, r3
  /* USER CODE BEGIN FLASH_IF_Write64_1 */

  /* USER CODE END FLASH_IF_Write64_1 */
  while (*(uint64_t *)address != data)
 802c046:	e9d6 2300 	ldrd	r2, r3, [r6]
 802c04a:	42ab      	cmp	r3, r5
 802c04c:	bf08      	it	eq
 802c04e:	42a2      	cmpeq	r2, r4
 802c050:	d101      	bne.n	802c056 <FLASH_IF_Write64+0x1a>

  return FLASH_OK;
  /* USER CODE BEGIN HW_FLASH_Write_2 */

  /* USER CODE END HW_FLASH_Write_2 */
}
 802c052:	2000      	movs	r0, #0
 802c054:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802c056:	693b      	ldr	r3, [r7, #16]
 802c058:	031b      	lsls	r3, r3, #12
 802c05a:	d4fc      	bmi.n	802c056 <FLASH_IF_Write64+0x1a>
    HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, address, data);
 802c05c:	4622      	mov	r2, r4
 802c05e:	462b      	mov	r3, r5
 802c060:	4631      	mov	r1, r6
 802c062:	2001      	movs	r0, #1
 802c064:	f002 f932 	bl	802e2cc <HAL_FLASH_Program>
 802c068:	e7ed      	b.n	802c046 <FLASH_IF_Write64+0xa>
 802c06a:	bf00      	nop
 802c06c:	58004000 	.word	0x58004000

0802c070 <FLASH_IF_Write_Buffer>:

/* USER CODE END EF */

/* Private Functions Definition -----------------------------------------------*/
static int32_t FLASH_IF_Write_Buffer(uint32_t pDestination, uint8_t *pSource, uint32_t uLength)
{
 802c070:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 802c072:	f022 0507 	bic.w	r5, r2, #7
 802c076:	4604      	mov	r4, r0
 802c078:	4405      	add	r5, r0
 802c07a:	1a0e      	subs	r6, r1, r0
  /* USER CODE END FLASH_IF_Write_Buffer_1 */
  uint8_t *pSrc = pSource;
  uint64_t src_value;
  int32_t status = FLASH_OK;

  for (uint32_t i = 0; i < (uLength / sizeof(uint64_t)); i++)
 802c07c:	42ac      	cmp	r4, r5
 802c07e:	eb06 0104 	add.w	r1, r6, r4
 802c082:	d101      	bne.n	802c088 <FLASH_IF_Write_Buffer+0x18>
 802c084:	2000      	movs	r0, #0
      /* exit the for loop*/
      break;
    }
  }

  return status;
 802c086:	e014      	b.n	802c0b2 <FLASH_IF_Write_Buffer+0x42>
    UTIL_MEM_cpy_8(&src_value, pSrc, sizeof(uint64_t));
 802c088:	2208      	movs	r2, #8
 802c08a:	4668      	mov	r0, sp
 802c08c:	f00e ff06 	bl	803ae9c <UTIL_MEM_cpy_8>
    if (src_value != UINT64_MAX)
 802c090:	e9dd 2300 	ldrd	r2, r3, [sp]
 802c094:	1c59      	adds	r1, r3, #1
 802c096:	bf08      	it	eq
 802c098:	f1b2 3fff 	cmpeq.w	r2, #4294967295
 802c09c:	f104 0708 	add.w	r7, r4, #8
 802c0a0:	d101      	bne.n	802c0a6 <FLASH_IF_Write_Buffer+0x36>
    pDestination += sizeof(uint64_t);
 802c0a2:	463c      	mov	r4, r7
    if (status != FLASH_OK)
 802c0a4:	e7ea      	b.n	802c07c <FLASH_IF_Write_Buffer+0xc>
      status = FLASH_IF_Write64(pDestination, src_value);
 802c0a6:	4620      	mov	r0, r4
 802c0a8:	f7ff ffc8 	bl	802c03c <FLASH_IF_Write64>
    pDestination += sizeof(uint64_t);
 802c0ac:	463c      	mov	r4, r7
    if (status != FLASH_OK)
 802c0ae:	2800      	cmp	r0, #0
 802c0b0:	d0e4      	beq.n	802c07c <FLASH_IF_Write_Buffer+0xc>
  /* USER CODE BEGIN FLASH_IF_Write_Buffer_2 */

  /* USER CODE END FLASH_IF_Write_Buffer_2 */
}
 802c0b2:	b003      	add	sp, #12
 802c0b4:	bdf0      	pop	{r4, r5, r6, r7, pc}

0802c0b6 <FLASH_IF_EraseByPages>:
{
 802c0b6:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  erase_str.TypeErase = FLASH_TYPEERASE_PAGES;
 802c0b8:	2302      	movs	r3, #2
  erase_str.Page = page;
 802c0ba:	e9cd 3001 	strd	r3, r0, [sp, #4]
  erase_str.NbPages = n;
 802c0be:	9103      	str	r1, [sp, #12]
  if (interrupt)
 802c0c0:	b15a      	cbz	r2, 802c0da <FLASH_IF_EraseByPages+0x24>
    hal_status = HAL_FLASHEx_Erase_IT(&erase_str);
 802c0c2:	a801      	add	r0, sp, #4
 802c0c4:	f002 f996 	bl	802e3f4 <HAL_FLASHEx_Erase_IT>
  return ((hal_status == HAL_OK) ? FLASH_OK : ((hal_status == HAL_BUSY) ? FLASH_BUSY : FLASH_ERASE_ERROR));
 802c0c8:	b120      	cbz	r0, 802c0d4 <FLASH_IF_EraseByPages+0x1e>
 802c0ca:	2802      	cmp	r0, #2
 802c0cc:	bf0c      	ite	eq
 802c0ce:	2001      	moveq	r0, #1
 802c0d0:	f06f 0001 	mvnne.w	r0, #1
}
 802c0d4:	b005      	add	sp, #20
 802c0d6:	f85d fb04 	ldr.w	pc, [sp], #4
    hal_status = HAL_FLASHEx_Erase(&erase_str, &page_error);
 802c0da:	4669      	mov	r1, sp
 802c0dc:	a801      	add	r0, sp, #4
 802c0de:	f002 f93b 	bl	802e358 <HAL_FLASHEx_Erase>
 802c0e2:	e7f1      	b.n	802c0c8 <FLASH_IF_EraseByPages+0x12>

0802c0e4 <FLASH_IF_Write>:
{
 802c0e4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802c0e8:	469a      	mov	sl, r3
  uint32_t page_start_index = PAGE(address);
 802c0ea:	4b46      	ldr	r3, [pc, #280]	; (802c204 <FLASH_IF_Write+0x120>)
{
 802c0ec:	4691      	mov	r9, r2
  uint32_t page_end_index = PAGE(address + size - 1);
 802c0ee:	f109 4878 	add.w	r8, r9, #4160749568	; 0xf8000000
  uint32_t page_start_index = PAGE(address);
 802c0f2:	681a      	ldr	r2, [r3, #0]
 802c0f4:	4b44      	ldr	r3, [pc, #272]	; (802c208 <FLASH_IF_Write+0x124>)
  uint32_t page_end_index = PAGE(address + size - 1);
 802c0f6:	f108 38ff 	add.w	r8, r8, #4294967295
  uint32_t page_start_index = PAGE(address);
 802c0fa:	ea03 2382 	and.w	r3, r3, r2, lsl #10
  uint32_t page_end_index = PAGE(address + size - 1);
 802c0fe:	4480      	add	r8, r0
  uint32_t page_start_index = PAGE(address);
 802c100:	f100 4278 	add.w	r2, r0, #4160749568	; 0xf8000000
 802c104:	fbb2 f6f3 	udiv	r6, r2, r3
 802c108:	fb03 2616 	mls	r6, r3, r6, r2
  uint32_t page_end_index = PAGE(address + size - 1);
 802c10c:	fbb8 f2f3 	udiv	r2, r8, r3
 802c110:	fb03 8812 	mls	r8, r3, r2, r8
{
 802c114:	4605      	mov	r5, r0
  uint32_t page_start_index = PAGE(address);
 802c116:	0af6      	lsrs	r6, r6, #11
  uint32_t page_end_index = PAGE(address + size - 1);
 802c118:	ea4f 28d8 	mov.w	r8, r8, lsr #11
  if ((data == NULL) || ((size % sizeof(uint64_t)) != 0) || ((address % sizeof(uint64_t)) != 0))
 802c11c:	460f      	mov	r7, r1
 802c11e:	b921      	cbnz	r1, 802c12a <FLASH_IF_Write+0x46>
    return FLASH_PARAM_ERROR;
 802c120:	f06f 0004 	mvn.w	r0, #4
}
 802c124:	b003      	add	sp, #12
 802c126:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if ((data == NULL) || ((size % sizeof(uint64_t)) != 0) || ((address % sizeof(uint64_t)) != 0))
 802c12a:	ea40 0309 	orr.w	r3, r0, r9
 802c12e:	075b      	lsls	r3, r3, #29
 802c130:	d1f6      	bne.n	802c120 <FLASH_IF_Write+0x3c>
  if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0U)
 802c132:	4b36      	ldr	r3, [pc, #216]	; (802c20c <FLASH_IF_Write+0x128>)
 802c134:	695b      	ldr	r3, [r3, #20]
 802c136:	2b00      	cmp	r3, #0
 802c138:	db5e      	blt.n	802c1f8 <FLASH_IF_Write+0x114>
  if (page_start_index != page_end_index)
 802c13a:	4546      	cmp	r6, r8
    curr_size = FLASH_PAGE_SIZE - (address % FLASH_PAGE_SIZE);
 802c13c:	bf1a      	itte	ne
 802c13e:	f3c0 030a 	ubfxne	r3, r0, #0, #11
 802c142:	f5c3 6b00 	rsbne	fp, r3, #2048	; 0x800
 802c146:	46cb      	moveq	fp, r9
  for (uint32_t idx = page_start_index; idx <= page_end_index; idx++)
 802c148:	4546      	cmp	r6, r8
 802c14a:	d901      	bls.n	802c150 <FLASH_IF_Write+0x6c>
  int32_t status = FLASH_OK;
 802c14c:	2000      	movs	r0, #0
 802c14e:	e7e9      	b.n	802c124 <FLASH_IF_Write+0x40>
    if (FLASH_IF_IsEmpty((uint8_t *)curr_dest_addr, curr_size) != FLASH_EMPTY)
 802c150:	eb0b 0305 	add.w	r3, fp, r5
 802c154:	462c      	mov	r4, r5
  /* USER CODE END FLASH_IF_IsEmpty_1 */
  uint64_t *addr64;
  uint32_t i;

  /* start memory NOT 64bits aligned */
  while ((((uint32_t)addr) % sizeof(uint64_t)) != 0)
 802c156:	9301      	str	r3, [sp, #4]
 802c158:	9b01      	ldr	r3, [sp, #4]
 802c15a:	f014 0c07 	ands.w	ip, r4, #7
 802c15e:	eba3 0204 	sub.w	r2, r3, r4
 802c162:	d10c      	bne.n	802c17e <FLASH_IF_Write+0x9a>
    size--;
  }

  /* addr64 is 64 bits aligned */
  addr64 = (uint64_t *)addr;
  for (i = 0; i < (size / sizeof(uint64_t)); i++)
 802c164:	ea4f 0ed2 	mov.w	lr, r2, lsr #3
 802c168:	45f4      	cmp	ip, lr
 802c16a:	d130      	bne.n	802c1ce <FLASH_IF_Write+0xea>
    if (*addr64++ != UINT64_MAX)
    {
      return FLASH_NOT_EMPTY;
    }
  }
  size -= sizeof(uint64_t) * i;
 802c16c:	eba2 02cc 	sub.w	r2, r2, ip, lsl #3
 802c170:	4422      	add	r2, r4

  /* end memory NOT 64 bits aligned */
  addr = (uint8_t *)addr64;
  while (size != 0)
 802c172:	42a2      	cmp	r2, r4
 802c174:	d135      	bne.n	802c1e2 <FLASH_IF_Write+0xfe>
      if (FLASH_IF_Write_Buffer(curr_dest_addr, (uint8_t *)curr_src_addr, curr_size) != FLASH_OK)
 802c176:	465a      	mov	r2, fp
 802c178:	4639      	mov	r1, r7
 802c17a:	4628      	mov	r0, r5
 802c17c:	e021      	b.n	802c1c2 <FLASH_IF_Write+0xde>
    if (*addr++ != UINT8_MAX)
 802c17e:	f814 2b01 	ldrb.w	r2, [r4], #1
 802c182:	2aff      	cmp	r2, #255	; 0xff
 802c184:	d0e8      	beq.n	802c158 <FLASH_IF_Write+0x74>
      if (dataTempPage == NULL)
 802c186:	f1ba 0f00 	cmp.w	sl, #0
 802c18a:	d0c9      	beq.n	802c120 <FLASH_IF_Write+0x3c>
      UTIL_MEM_cpy_8(dataTempPage, (uint8_t *)(idx * FLASH_PAGE_SIZE + FLASH_BASE), FLASH_PAGE_SIZE);
 802c18c:	02f4      	lsls	r4, r6, #11
 802c18e:	f104 6400 	add.w	r4, r4, #134217728	; 0x8000000
 802c192:	f44f 6200 	mov.w	r2, #2048	; 0x800
 802c196:	4621      	mov	r1, r4
 802c198:	4650      	mov	r0, sl
 802c19a:	f00e fe7f 	bl	803ae9c <UTIL_MEM_cpy_8>
      UTIL_MEM_cpy_8(&dataTempPage[((uint32_t)curr_dest_addr) % FLASH_PAGE_SIZE], (uint8_t *)curr_src_addr, curr_size);
 802c19e:	f3c5 000a 	ubfx	r0, r5, #0, #11
 802c1a2:	fa1f f28b 	uxth.w	r2, fp
 802c1a6:	4639      	mov	r1, r7
 802c1a8:	4450      	add	r0, sl
 802c1aa:	f00e fe77 	bl	803ae9c <UTIL_MEM_cpy_8>
      if (FLASH_IF_EraseByPages(idx, 1, 0) != FLASH_OK)
 802c1ae:	2200      	movs	r2, #0
 802c1b0:	2101      	movs	r1, #1
 802c1b2:	4630      	mov	r0, r6
 802c1b4:	f7ff ff7f 	bl	802c0b6 <FLASH_IF_EraseByPages>
 802c1b8:	bb08      	cbnz	r0, 802c1fe <FLASH_IF_Write+0x11a>
        if (FLASH_IF_Write_Buffer(idx * FLASH_PAGE_SIZE + FLASH_BASE, dataTempPage, FLASH_PAGE_SIZE) != FLASH_OK)
 802c1ba:	f44f 6200 	mov.w	r2, #2048	; 0x800
 802c1be:	4651      	mov	r1, sl
 802c1c0:	4620      	mov	r0, r4
 802c1c2:	f7ff ff55 	bl	802c070 <FLASH_IF_Write_Buffer>
 802c1c6:	b188      	cbz	r0, 802c1ec <FLASH_IF_Write+0x108>
          status = FLASH_WRITE_ERROR;
 802c1c8:	f06f 0002 	mvn.w	r0, #2
 802c1cc:	e7aa      	b.n	802c124 <FLASH_IF_Write+0x40>
    if (*addr64++ != UINT64_MAX)
 802c1ce:	e8f4 0102 	ldrd	r0, r1, [r4], #8
 802c1d2:	3101      	adds	r1, #1
 802c1d4:	bf08      	it	eq
 802c1d6:	f1b0 3fff 	cmpeq.w	r0, #4294967295
 802c1da:	d1d4      	bne.n	802c186 <FLASH_IF_Write+0xa2>
  for (i = 0; i < (size / sizeof(uint64_t)); i++)
 802c1dc:	f10c 0c01 	add.w	ip, ip, #1
 802c1e0:	e7c2      	b.n	802c168 <FLASH_IF_Write+0x84>
  {
    if (*addr++ != UINT8_MAX)
 802c1e2:	f814 1b01 	ldrb.w	r1, [r4], #1
 802c1e6:	29ff      	cmp	r1, #255	; 0xff
 802c1e8:	d0c3      	beq.n	802c172 <FLASH_IF_Write+0x8e>
 802c1ea:	e7cc      	b.n	802c186 <FLASH_IF_Write+0xa2>
    curr_src_addr += curr_size;
 802c1ec:	445f      	add	r7, fp
  for (uint32_t idx = page_start_index; idx <= page_end_index; idx++)
 802c1ee:	9d01      	ldr	r5, [sp, #4]
    curr_size = size - curr_size;
 802c1f0:	eba9 0b0b 	sub.w	fp, r9, fp
  for (uint32_t idx = page_start_index; idx <= page_end_index; idx++)
 802c1f4:	3601      	adds	r6, #1
 802c1f6:	e7a7      	b.n	802c148 <FLASH_IF_Write+0x64>
    return FLASH_LOCK_ERROR;
 802c1f8:	f06f 0003 	mvn.w	r0, #3
 802c1fc:	e792      	b.n	802c124 <FLASH_IF_Write+0x40>
        status = FLASH_ERASE_ERROR;
 802c1fe:	f06f 0001 	mvn.w	r0, #1
 802c202:	e78f      	b.n	802c124 <FLASH_IF_Write+0x40>
 802c204:	1fff75e0 	.word	0x1fff75e0
 802c208:	03fffc00 	.word	0x03fffc00
 802c20c:	58004000 	.word	0x58004000

0802c210 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 802c210:	b500      	push	{lr}
 802c212:	b09b      	sub	sp, #108	; 0x6c
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 802c214:	2248      	movs	r2, #72	; 0x48
 802c216:	2100      	movs	r1, #0
 802c218:	a808      	add	r0, sp, #32
 802c21a:	f00f fa7d 	bl	803b718 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 802c21e:	221c      	movs	r2, #28
 802c220:	2100      	movs	r1, #0
 802c222:	a801      	add	r0, sp, #4
 802c224:	f00f fa78 	bl	803b718 <memset>

  /** Configure LSE Drive Capability
  */
  HAL_PWR_EnableBkUpAccess();
 802c228:	f002 fa50 	bl	802e6cc <HAL_PWR_EnableBkUpAccess>
  *         @arg @ref LL_RCC_LSEDRIVE_HIGH
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSE_SetDriveCapability(uint32_t LSEDrive)
{
  MODIFY_REG(RCC->BDCR, RCC_BDCR_LSEDRV, LSEDrive);
 802c22c:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
  /** Initializes the CPU, AHB and APB busses clocks
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSE|RCC_OSCILLATORTYPE_MSI;
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
  RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
 802c230:	2001      	movs	r0, #1
 802c232:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 802c236:	f023 0318 	bic.w	r3, r3, #24
 802c23a:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 802c23e:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
 802c242:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 802c246:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 802c24a:	f8c2 3400 	str.w	r3, [r2, #1024]	; 0x400
 802c24e:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
 802c252:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 802c256:	9300      	str	r3, [sp, #0]
 802c258:	9b00      	ldr	r3, [sp, #0]
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSE|RCC_OSCILLATORTYPE_MSI;
 802c25a:	2324      	movs	r3, #36	; 0x24
 802c25c:	9308      	str	r3, [sp, #32]
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 802c25e:	2381      	movs	r3, #129	; 0x81
 802c260:	930b      	str	r3, [sp, #44]	; 0x2c
  RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
 802c262:	2300      	movs	r3, #0
 802c264:	e9cd 0310 	strd	r0, r3, [sp, #64]	; 0x40
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_11;
 802c268:	22b0      	movs	r2, #176	; 0xb0
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 802c26a:	a808      	add	r0, sp, #32
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 802c26c:	e9cd 2312 	strd	r2, r3, [sp, #72]	; 0x48
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 802c270:	f002 fbac 	bl	802e9cc <HAL_RCC_OscConfig>
 802c274:	b108      	cbz	r0, 802c27a <SystemClock_Config+0x6a>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 802c276:	b672      	cpsid	i
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 802c278:	e7fe      	b.n	802c278 <SystemClock_Config+0x68>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK3|RCC_CLOCKTYPE_HCLK
 802c27a:	234f      	movs	r3, #79	; 0x4f
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
 802c27c:	e9cd 3001 	strd	r3, r0, [sp, #4]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 802c280:	e9cd 0003 	strd	r0, r0, [sp, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 802c284:	9005      	str	r0, [sp, #20]
  RCC_ClkInitStruct.AHBCLK3Divider = RCC_SYSCLK_DIV1;
 802c286:	9007      	str	r0, [sp, #28]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
 802c288:	2102      	movs	r1, #2
 802c28a:	a801      	add	r0, sp, #4
 802c28c:	f002 fe3e 	bl	802ef0c <HAL_RCC_ClockConfig>
 802c290:	b108      	cbz	r0, 802c296 <SystemClock_Config+0x86>
 802c292:	b672      	cpsid	i
  while (1)
 802c294:	e7fe      	b.n	802c294 <SystemClock_Config+0x84>
}
 802c296:	b01b      	add	sp, #108	; 0x6c
 802c298:	f85d fb04 	ldr.w	pc, [sp], #4

0802c29c <main>:
{
 802c29c:	b508      	push	{r3, lr}
  HAL_Init();
 802c29e:	f001 f8bb 	bl	802d418 <HAL_Init>
  SystemClock_Config();
 802c2a2:	f7ff ffb5 	bl	802c210 <SystemClock_Config>
  MX_KMS_Init();
 802c2a6:	f000 fc3f 	bl	802cb28 <MX_KMS_Init>
  MX_LoRaWAN_Init();
 802c2aa:	f000 fc40 	bl	802cb2e <MX_LoRaWAN_Init>
    MX_LoRaWAN_Process();
 802c2ae:	f000 fc45 	bl	802cb3c <MX_LoRaWAN_Process>
  while (1)
 802c2b2:	e7fc      	b.n	802c2ae <main+0x12>

0802c2b4 <Error_Handler>:
 802c2b4:	b672      	cpsid	i
  while (1)
 802c2b6:	e7fe      	b.n	802c2b6 <Error_Handler+0x2>

0802c2b8 <MX_RTC_Init>:

RTC_HandleTypeDef hrtc;

/* RTC init function */
void MX_RTC_Init(void)
{
 802c2b8:	b500      	push	{lr}
 802c2ba:	b08d      	sub	sp, #52	; 0x34

  /* USER CODE BEGIN RTC_Init 0 */

  /* USER CODE END RTC_Init 0 */

  RTC_AlarmTypeDef sAlarm = {0};
 802c2bc:	222c      	movs	r2, #44	; 0x2c
 802c2be:	2100      	movs	r1, #0
 802c2c0:	a801      	add	r0, sp, #4
 802c2c2:	f00f fa29 	bl	803b718 <memset>
  /* USER CODE BEGIN RTC_Init 1 */

  /* USER CODE END RTC_Init 1 */
  /** Initialize RTC Only
  */
  hrtc.Instance = RTC;
 802c2c6:	4817      	ldr	r0, [pc, #92]	; (802c324 <MX_RTC_Init+0x6c>)
 802c2c8:	4b17      	ldr	r3, [pc, #92]	; (802c328 <MX_RTC_Init+0x70>)
 802c2ca:	6003      	str	r3, [r0, #0]
  hrtc.Init.AsynchPrediv = RTC_PREDIV_A;
 802c2cc:	231f      	movs	r3, #31
 802c2ce:	6083      	str	r3, [r0, #8]
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
  hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
 802c2d0:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
 802c2d4:	2300      	movs	r3, #0
  hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
 802c2d6:	e9c0 3304 	strd	r3, r3, [r0, #16]
  hrtc.Init.OutPutPullUp = RTC_OUTPUT_PULLUP_NONE;
 802c2da:	e9c0 2307 	strd	r2, r3, [r0, #28]
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
 802c2de:	6183      	str	r3, [r0, #24]
  hrtc.Init.BinMode = RTC_BINARY_ONLY;
 802c2e0:	f44f 7380 	mov.w	r3, #256	; 0x100
 802c2e4:	6243      	str	r3, [r0, #36]	; 0x24
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
 802c2e6:	f003 f8dd 	bl	802f4a4 <HAL_RTC_Init>
 802c2ea:	b108      	cbz	r0, 802c2f0 <MX_RTC_Init+0x38>
  {
    Error_Handler();
 802c2ec:	f7ff ffe2 	bl	802c2b4 <Error_Handler>

  /* USER CODE END Check_RTC_BKUP */

  /** Initialize RTC and set the Time and Date
  */
  if (HAL_RTCEx_SetSSRU_IT(&hrtc) != HAL_OK)
 802c2f0:	480c      	ldr	r0, [pc, #48]	; (802c324 <MX_RTC_Init+0x6c>)
 802c2f2:	f003 f9fb 	bl	802f6ec <HAL_RTCEx_SetSSRU_IT>
 802c2f6:	b108      	cbz	r0, 802c2fc <MX_RTC_Init+0x44>
  {
    Error_Handler();
 802c2f8:	f7ff ffdc 	bl	802c2b4 <Error_Handler>
  /** Enable the Alarm A
  */
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
  sAlarm.AlarmTime.SubSeconds = 0x0;
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDBINMASK_NONE;
 802c2fc:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
 802c300:	2200      	movs	r2, #0
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDBINMASK_NONE;
 802c302:	9307      	str	r3, [sp, #28]
  sAlarm.Alarm = RTC_ALARM_A;
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, 0) != HAL_OK)
 802c304:	4807      	ldr	r0, [pc, #28]	; (802c324 <MX_RTC_Init+0x6c>)
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
 802c306:	9208      	str	r2, [sp, #32]
  sAlarm.Alarm = RTC_ALARM_A;
 802c308:	f44f 7380 	mov.w	r3, #256	; 0x100
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, 0) != HAL_OK)
 802c30c:	a901      	add	r1, sp, #4
  sAlarm.AlarmTime.SubSeconds = 0x0;
 802c30e:	9202      	str	r2, [sp, #8]
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
 802c310:	9206      	str	r2, [sp, #24]
  sAlarm.Alarm = RTC_ALARM_A;
 802c312:	930b      	str	r3, [sp, #44]	; 0x2c
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, 0) != HAL_OK)
 802c314:	f003 f922 	bl	802f55c <HAL_RTC_SetAlarm_IT>
 802c318:	b108      	cbz	r0, 802c31e <MX_RTC_Init+0x66>
  {
    Error_Handler();
 802c31a:	f7ff ffcb 	bl	802c2b4 <Error_Handler>
  }
  /* USER CODE BEGIN RTC_Init 2 */

  /* USER CODE END RTC_Init 2 */

}
 802c31e:	b00d      	add	sp, #52	; 0x34
 802c320:	f85d fb04 	ldr.w	pc, [sp], #4
 802c324:	200061b8 	.word	0x200061b8
 802c328:	40002800 	.word	0x40002800

0802c32c <HAL_RTC_MspInit>:

void HAL_RTC_MspInit(RTC_HandleTypeDef* rtcHandle)
{
 802c32c:	b510      	push	{r4, lr}
 802c32e:	4604      	mov	r4, r0
 802c330:	b090      	sub	sp, #64	; 0x40

  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 802c332:	2238      	movs	r2, #56	; 0x38
 802c334:	2100      	movs	r1, #0
 802c336:	a802      	add	r0, sp, #8
 802c338:	f00f f9ee 	bl	803b718 <memset>
  if(rtcHandle->Instance==RTC)
 802c33c:	6822      	ldr	r2, [r4, #0]
 802c33e:	4b19      	ldr	r3, [pc, #100]	; (802c3a4 <HAL_RTC_MspInit+0x78>)
 802c340:	429a      	cmp	r2, r3
 802c342:	d12c      	bne.n	802c39e <HAL_RTC_MspInit+0x72>
  /* USER CODE BEGIN RTC_MspInit 0 */

  /* USER CODE END RTC_MspInit 0 */
  /** Initializes the peripherals clocks
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 802c344:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 802c348:	9302      	str	r3, [sp, #8]
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;

    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 802c34a:	a802      	add	r0, sp, #8
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
 802c34c:	f44f 7380 	mov.w	r3, #256	; 0x100
 802c350:	930f      	str	r3, [sp, #60]	; 0x3c
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 802c352:	f002 ff17 	bl	802f184 <HAL_RCCEx_PeriphCLKConfig>
 802c356:	b108      	cbz	r0, 802c35c <HAL_RTC_MspInit+0x30>
    {
      Error_Handler();
 802c358:	f7ff ffac 	bl	802c2b4 <Error_Handler>
  * @rmtoll BDCR         RTCEN         LL_RCC_EnableRTC
  * @retval None
  */
__STATIC_INLINE void LL_RCC_EnableRTC(void)
{
  SET_BIT(RCC->BDCR, RCC_BDCR_RTCEN);
 802c35c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
    /* RTC clock enable */
    __HAL_RCC_RTC_ENABLE();
    __HAL_RCC_RTCAPB_CLK_ENABLE();

    /* RTC interrupt Init */
    HAL_NVIC_SetPriority(TAMP_STAMP_LSECSS_SSRU_IRQn, 0, 0);
 802c360:	2002      	movs	r0, #2
 802c362:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 802c366:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 802c36a:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  SET_BIT(RCC->APB1ENR1, Periphs);
 802c36e:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 802c370:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 802c374:	659a      	str	r2, [r3, #88]	; 0x58
  tmpreg = READ_BIT(RCC->APB1ENR1, Periphs);
 802c376:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 802c378:	2200      	movs	r2, #0
 802c37a:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 802c37e:	4611      	mov	r1, r2
 802c380:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 802c382:	9b01      	ldr	r3, [sp, #4]
 802c384:	f001 fcba 	bl	802dcfc <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TAMP_STAMP_LSECSS_SSRU_IRQn);
 802c388:	2002      	movs	r0, #2
 802c38a:	f001 fce9 	bl	802dd60 <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(RTC_Alarm_IRQn, 0, 0);
 802c38e:	2200      	movs	r2, #0
 802c390:	202a      	movs	r0, #42	; 0x2a
 802c392:	4611      	mov	r1, r2
 802c394:	f001 fcb2 	bl	802dcfc <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(RTC_Alarm_IRQn);
 802c398:	202a      	movs	r0, #42	; 0x2a
 802c39a:	f001 fce1 	bl	802dd60 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN RTC_MspInit 1 */

  /* USER CODE END RTC_MspInit 1 */
  }
}
 802c39e:	b010      	add	sp, #64	; 0x40
 802c3a0:	bd10      	pop	{r4, pc}
 802c3a2:	bf00      	nop
 802c3a4:	40002800 	.word	0x40002800

0802c3a8 <PWR_EnterOffMode>:
void PWR_EnterOffMode(void)
{
  /* USER CODE BEGIN EnterOffMode_1 */

  /* USER CODE END EnterOffMode_1 */
}
 802c3a8:	4770      	bx	lr
	...

0802c3ac <PWR_EnterStopMode>:

  /* USER CODE END ExitOffMode_1 */
}

void PWR_EnterStopMode(void)
{
 802c3ac:	b508      	push	{r3, lr}
  /* USER CODE BEGIN EnterStopMode_1 */

  /* USER CODE END EnterStopMode_1 */
  HAL_SuspendTick();
 802c3ae:	f001 f849 	bl	802d444 <HAL_SuspendTick>
  * @rmtoll EXTSCR       C1CSSF        LL_PWR_ClearFlag_C1STOP_C1STB
  * @retval None
  */
__STATIC_INLINE void LL_PWR_ClearFlag_C1STOP_C1STB(void)
{
  WRITE_REG(PWR->EXTSCR, PWR_EXTSCR_C1CSSF);
 802c3b2:	4b04      	ldr	r3, [pc, #16]	; (802c3c4 <PWR_EnterStopMode+0x18>)
 802c3b4:	2001      	movs	r0, #1
 802c3b6:	f8c3 0088 	str.w	r0, [r3, #136]	; 0x88
  /* USER CODE END EnterStopMode_2 */
  HAL_PWREx_EnterSTOP2Mode(PWR_STOPENTRY_WFI);
  /* USER CODE BEGIN EnterStopMode_3 */

  /* USER CODE END EnterStopMode_3 */
}
 802c3ba:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_PWREx_EnterSTOP2Mode(PWR_STOPENTRY_WFI);
 802c3be:	f002 b9df 	b.w	802e780 <HAL_PWREx_EnterSTOP2Mode>
 802c3c2:	bf00      	nop
 802c3c4:	58000400 	.word	0x58000400

0802c3c8 <PWR_ExitSleepMode>:
{
  /* USER CODE BEGIN ExitSleepMode_1 */

  /* USER CODE END ExitSleepMode_1 */
  /* Suspend sysTick */
  HAL_ResumeTick();
 802c3c8:	f001 b844 	b.w	802d454 <HAL_ResumeTick>

0802c3cc <PWR_ExitStopMode>:
{
 802c3cc:	b508      	push	{r3, lr}
  HAL_ResumeTick();
 802c3ce:	f001 f841 	bl	802d454 <HAL_ResumeTick>
}
 802c3d2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  vcom_Resume();
 802c3d6:	f000 bb77 	b.w	802cac8 <vcom_Resume>

0802c3da <PWR_EnterSleepMode>:
{
 802c3da:	b508      	push	{r3, lr}
  HAL_SuspendTick();
 802c3dc:	f001 f832 	bl	802d444 <HAL_SuspendTick>
}
 802c3e0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_SLEEPENTRY_WFI);
 802c3e4:	2101      	movs	r1, #1
 802c3e6:	2000      	movs	r0, #0
 802c3e8:	f002 b978 	b.w	802e6dc <HAL_PWR_EnterSLEEPMode>

0802c3ec <PWR_ExitOffMode>:
 802c3ec:	4770      	bx	lr

0802c3ee <HAL_MspInit>:
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 802c3ee:	4770      	bx	lr

0802c3f0 <NMI_Handler>:
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 802c3f0:	e7fe      	b.n	802c3f0 <NMI_Handler>

0802c3f2 <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 802c3f2:	e7fe      	b.n	802c3f2 <HardFault_Handler>

0802c3f4 <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 802c3f4:	e7fe      	b.n	802c3f4 <MemManage_Handler>

0802c3f6 <BusFault_Handler>:
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 802c3f6:	e7fe      	b.n	802c3f6 <BusFault_Handler>

0802c3f8 <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 802c3f8:	e7fe      	b.n	802c3f8 <UsageFault_Handler>

0802c3fa <SVC_Handler>:

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 802c3fa:	4770      	bx	lr

0802c3fc <DebugMon_Handler>:
 802c3fc:	4770      	bx	lr

0802c3fe <PendSV_Handler>:
 802c3fe:	4770      	bx	lr

0802c400 <SysTick_Handler>:
 802c400:	4770      	bx	lr
	...

0802c404 <TAMP_STAMP_LSECSS_SSRU_IRQHandler>:
void TAMP_STAMP_LSECSS_SSRU_IRQHandler(void)
{
  /* USER CODE BEGIN TAMP_STAMP_LSECSS_SSRU_IRQn 0 */

  /* USER CODE END TAMP_STAMP_LSECSS_SSRU_IRQn 0 */
  HAL_RTCEx_SSRUIRQHandler(&hrtc);
 802c404:	4801      	ldr	r0, [pc, #4]	; (802c40c <TAMP_STAMP_LSECSS_SSRU_IRQHandler+0x8>)
 802c406:	f003 b997 	b.w	802f738 <HAL_RTCEx_SSRUIRQHandler>
 802c40a:	bf00      	nop
 802c40c:	200061b8 	.word	0x200061b8

0802c410 <EXTI0_IRQHandler>:
void EXTI0_IRQHandler(void)
{
  /* USER CODE BEGIN EXTI0_IRQn 0 */

  /* USER CODE END EXTI0_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_0);
 802c410:	2001      	movs	r0, #1
 802c412:	f002 b94f 	b.w	802e6b4 <HAL_GPIO_EXTI_IRQHandler>

0802c416 <EXTI1_IRQHandler>:
void EXTI1_IRQHandler(void)
{
  /* USER CODE BEGIN EXTI1_IRQn 0 */

  /* USER CODE END EXTI1_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_1);
 802c416:	2002      	movs	r0, #2
 802c418:	f002 b94c 	b.w	802e6b4 <HAL_GPIO_EXTI_IRQHandler>

0802c41c <DMA1_Channel5_IRQHandler>:
void DMA1_Channel5_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Channel5_IRQn 0 */

  /* USER CODE END DMA1_Channel5_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_usart2_tx);
 802c41c:	4801      	ldr	r0, [pc, #4]	; (802c424 <DMA1_Channel5_IRQHandler+0x8>)
 802c41e:	f001 be7d 	b.w	802e11c <HAL_DMA_IRQHandler>
 802c422:	bf00      	nop
 802c424:	200061fc 	.word	0x200061fc

0802c428 <USART2_IRQHandler>:
void USART2_IRQHandler(void)
{
  /* USER CODE BEGIN USART2_IRQn 0 */

  /* USER CODE END USART2_IRQn 0 */
  HAL_UART_IRQHandler(&huart2);
 802c428:	4801      	ldr	r0, [pc, #4]	; (802c430 <USART2_IRQHandler+0x8>)
 802c42a:	f003 bd55 	b.w	802fed8 <HAL_UART_IRQHandler>
 802c42e:	bf00      	nop
 802c430:	2000625c 	.word	0x2000625c

0802c434 <RTC_Alarm_IRQHandler>:
void RTC_Alarm_IRQHandler(void)
{
  /* USER CODE BEGIN RTC_Alarm_IRQn 0 */

  /* USER CODE END RTC_Alarm_IRQn 0 */
  HAL_RTC_AlarmIRQHandler(&hrtc);
 802c434:	4801      	ldr	r0, [pc, #4]	; (802c43c <RTC_Alarm_IRQHandler+0x8>)
 802c436:	f002 bfb7 	b.w	802f3a8 <HAL_RTC_AlarmIRQHandler>
 802c43a:	bf00      	nop
 802c43c:	200061b8 	.word	0x200061b8

0802c440 <SUBGHZ_Radio_IRQHandler>:
void SUBGHZ_Radio_IRQHandler(void)
{
  /* USER CODE BEGIN SUBGHZ_Radio_IRQn 0 */

  /* USER CODE END SUBGHZ_Radio_IRQn 0 */
  HAL_SUBGHZ_IRQHandler(&hsubghz);
 802c440:	4801      	ldr	r0, [pc, #4]	; (802c448 <SUBGHZ_Radio_IRQHandler+0x8>)
 802c442:	f003 bc0a 	b.w	802fc5a <HAL_SUBGHZ_IRQHandler>
 802c446:	bf00      	nop
 802c448:	200061f0 	.word	0x200061f0

0802c44c <MX_SUBGHZ_Init>:
  /* USER CODE END SUBGHZ_Init 0 */

  /* USER CODE BEGIN SUBGHZ_Init 1 */

  /* USER CODE END SUBGHZ_Init 1 */
  hsubghz.Init.BaudratePrescaler = SUBGHZSPI_BAUDRATEPRESCALER_4;
 802c44c:	4805      	ldr	r0, [pc, #20]	; (802c464 <MX_SUBGHZ_Init+0x18>)
{
 802c44e:	b508      	push	{r3, lr}
  hsubghz.Init.BaudratePrescaler = SUBGHZSPI_BAUDRATEPRESCALER_4;
 802c450:	2308      	movs	r3, #8
 802c452:	6003      	str	r3, [r0, #0]
  if (HAL_SUBGHZ_Init(&hsubghz) != HAL_OK)
 802c454:	f003 f9b6 	bl	802f7c4 <HAL_SUBGHZ_Init>
 802c458:	b118      	cbz	r0, 802c462 <MX_SUBGHZ_Init+0x16>
  }
  /* USER CODE BEGIN SUBGHZ_Init 2 */

  /* USER CODE END SUBGHZ_Init 2 */

}
 802c45a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 802c45e:	f7ff bf29 	b.w	802c2b4 <Error_Handler>
}
 802c462:	bd08      	pop	{r3, pc}
 802c464:	200061f0 	.word	0x200061f0

0802c468 <HAL_SUBGHZ_MspInit>:
  * @retval None
  */
__STATIC_INLINE void LL_APB3_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB3ENR, Periphs);
 802c468:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000

void HAL_SUBGHZ_MspInit(SUBGHZ_HandleTypeDef* subghzHandle)
{
 802c46c:	b507      	push	{r0, r1, r2, lr}
 802c46e:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 802c470:	f042 0201 	orr.w	r2, r2, #1
 802c474:	665a      	str	r2, [r3, #100]	; 0x64
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB3ENR, Periphs);
 802c476:	6e5b      	ldr	r3, [r3, #100]	; 0x64
  /* USER CODE END SUBGHZ_MspInit 0 */
    /* SUBGHZ clock enable */
    __HAL_RCC_SUBGHZSPI_CLK_ENABLE();

    /* SUBGHZ interrupt Init */
    HAL_NVIC_SetPriority(SUBGHZ_Radio_IRQn, 0, 0);
 802c478:	2200      	movs	r2, #0
 802c47a:	f003 0301 	and.w	r3, r3, #1
 802c47e:	9301      	str	r3, [sp, #4]
 802c480:	4611      	mov	r1, r2
 802c482:	2032      	movs	r0, #50	; 0x32
  (void)tmpreg;
 802c484:	9b01      	ldr	r3, [sp, #4]
 802c486:	f001 fc39 	bl	802dcfc <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SUBGHZ_Radio_IRQn);
 802c48a:	2032      	movs	r0, #50	; 0x32
  /* USER CODE BEGIN SUBGHZ_MspInit 1 */

  /* USER CODE END SUBGHZ_MspInit 1 */
}
 802c48c:	b003      	add	sp, #12
 802c48e:	f85d eb04 	ldr.w	lr, [sp], #4
    HAL_NVIC_EnableIRQ(SUBGHZ_Radio_IRQn);
 802c492:	f001 bc65 	b.w	802dd60 <HAL_NVIC_EnableIRQ>
	...

0802c498 <tiny_snprintf_like.constprop.0>:
  /* USER CODE BEGIN UTIL_LPM_SetStopMode_2 */

  /* USER CODE END UTIL_LPM_SetStopMode_2 */
}

static void tiny_snprintf_like(char *buf, uint32_t maxsize, const char *strFormat, ...)
 802c498:	b40c      	push	{r2, r3}
 802c49a:	b507      	push	{r0, r1, r2, lr}
  /* USER CODE BEGIN tiny_snprintf_like_1 */

  /* USER CODE END tiny_snprintf_like_1 */
  va_list vaArgs;
  va_start(vaArgs, strFormat);
  UTIL_ADV_TRACE_VSNPRINTF(buf, maxsize, strFormat, vaArgs);
 802c49c:	4a05      	ldr	r2, [pc, #20]	; (802c4b4 <tiny_snprintf_like.constprop.0+0x1c>)
  va_start(vaArgs, strFormat);
 802c49e:	ab05      	add	r3, sp, #20
  UTIL_ADV_TRACE_VSNPRINTF(buf, maxsize, strFormat, vaArgs);
 802c4a0:	2110      	movs	r1, #16
  va_start(vaArgs, strFormat);
 802c4a2:	9301      	str	r3, [sp, #4]
  UTIL_ADV_TRACE_VSNPRINTF(buf, maxsize, strFormat, vaArgs);
 802c4a4:	f00e fffa 	bl	803b49c <tiny_vsnprintf_like>
  va_end(vaArgs);
  /* USER CODE BEGIN tiny_snprintf_like_2 */

  /* USER CODE END tiny_snprintf_like_2 */
}
 802c4a8:	b003      	add	sp, #12
 802c4aa:	f85d eb04 	ldr.w	lr, [sp], #4
 802c4ae:	b002      	add	sp, #8
 802c4b0:	4770      	bx	lr
 802c4b2:	bf00      	nop
 802c4b4:	0803bd23 	.word	0x0803bd23

0802c4b8 <TimestampNow>:
{
 802c4b8:	b530      	push	{r4, r5, lr}
 802c4ba:	b085      	sub	sp, #20
 802c4bc:	4604      	mov	r4, r0
  SysTime_t curtime = SysTimeGet();
 802c4be:	a802      	add	r0, sp, #8
{
 802c4c0:	460d      	mov	r5, r1
  SysTime_t curtime = SysTimeGet();
 802c4c2:	f00e fe17 	bl	803b0f4 <SysTimeGet>
  tiny_snprintf_like((char *)buff, MAX_TS_SIZE, "%ds%03d:", curtime.Seconds, curtime.SubSeconds);
 802c4c6:	f9bd 300c 	ldrsh.w	r3, [sp, #12]
 802c4ca:	4a06      	ldr	r2, [pc, #24]	; (802c4e4 <TimestampNow+0x2c>)
 802c4cc:	9300      	str	r3, [sp, #0]
 802c4ce:	2110      	movs	r1, #16
 802c4d0:	9b02      	ldr	r3, [sp, #8]
 802c4d2:	4620      	mov	r0, r4
 802c4d4:	f7ff ffe0 	bl	802c498 <tiny_snprintf_like.constprop.0>
  *size = strlen((char *)buff);
 802c4d8:	4620      	mov	r0, r4
 802c4da:	f7fe ffb1 	bl	802b440 <strlen>
 802c4de:	8028      	strh	r0, [r5, #0]
}
 802c4e0:	b005      	add	sp, #20
 802c4e2:	bd30      	pop	{r4, r5, pc}
 802c4e4:	0803bd23 	.word	0x0803bd23

0802c4e8 <SystemApp_Init>:
  MODIFY_REG(RCC->CFGR, RCC_CFGR_STOPWUCK, Clock);
 802c4e8:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
{
 802c4ec:	b508      	push	{r3, lr}
 802c4ee:	6893      	ldr	r3, [r2, #8]
 802c4f0:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 802c4f4:	6093      	str	r3, [r2, #8]
  UTIL_TIMER_Init();
 802c4f6:	f00e fe83 	bl	803b200 <UTIL_TIMER_Init>
  DBG_Disable();
 802c4fa:	f000 f8be 	bl	802c67a <DBG_Disable>
  DBG_ProbesInit();
 802c4fe:	f000 f8bf 	bl	802c680 <DBG_ProbesInit>
  UTIL_ADV_TRACE_Init();
 802c502:	f00e fb5b 	bl	803abbc <UTIL_ADV_TRACE_Init>
  UTIL_ADV_TRACE_RegisterTimeStampFunction(TimestampNow);
 802c506:	480d      	ldr	r0, [pc, #52]	; (802c53c <SystemApp_Init+0x54>)
 802c508:	f00e fb72 	bl	803abf0 <UTIL_ADV_TRACE_RegisterTimeStampFunction>
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPTVERR);
 802c50c:	4b0c      	ldr	r3, [pc, #48]	; (802c540 <SystemApp_Init+0x58>)
 802c50e:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 802c512:	611a      	str	r2, [r3, #16]
  UTIL_ADV_TRACE_SetVerboseLevel(VERBOSE_LEVEL);
 802c514:	2003      	movs	r0, #3
 802c516:	f00e fb71 	bl	803abfc <UTIL_ADV_TRACE_SetVerboseLevel>
  SYS_InitMeasurement();
 802c51a:	f7ff fd0f 	bl	802bf3c <SYS_InitMeasurement>
  EnvSensors_Init();
 802c51e:	f000 f8b9 	bl	802c694 <EnvSensors_Init>
  UTIL_LPM_Init();
 802c522:	f00e fc69 	bl	803adf8 <UTIL_LPM_Init>
  UTIL_LPM_SetOffMode((1 << CFG_LPM_APPLI_Id), UTIL_LPM_DISABLE);
 802c526:	2101      	movs	r1, #1
 802c528:	4608      	mov	r0, r1
 802c52a:	f00e fc83 	bl	803ae34 <UTIL_LPM_SetOffMode>
  UTIL_LPM_SetStopMode((1 << CFG_LPM_APPLI_Id), UTIL_LPM_DISABLE);
 802c52e:	2101      	movs	r1, #1
}
 802c530:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  UTIL_LPM_SetStopMode((1 << CFG_LPM_APPLI_Id), UTIL_LPM_DISABLE);
 802c534:	4608      	mov	r0, r1
 802c536:	f00e bc67 	b.w	803ae08 <UTIL_LPM_SetStopMode>
 802c53a:	bf00      	nop
 802c53c:	0802c4b9 	.word	0x0802c4b9
 802c540:	58004000 	.word	0x58004000

0802c544 <UTIL_SEQ_Idle>:
  UTIL_LPM_EnterLowPower();
 802c544:	f00e bc8c 	b.w	803ae60 <UTIL_LPM_EnterLowPower>

0802c548 <GetBatteryLevel>:
{
 802c548:	b513      	push	{r0, r1, r4, lr}
  batteryLevelmV = (uint16_t) SYS_GetBatteryLevel();
 802c54a:	f7ff fcff 	bl	802bf4c <SYS_GetBatteryLevel>
  if (batteryLevelmV > VDD_BAT)
 802c54e:	f640 33b8 	movw	r3, #3000	; 0xbb8
 802c552:	4298      	cmp	r0, r3
 802c554:	d815      	bhi.n	802c582 <GetBatteryLevel+0x3a>
  else if (batteryLevelmV < VDD_MIN)
 802c556:	f5b0 6fe1 	cmp.w	r0, #1800	; 0x708
 802c55a:	d314      	bcc.n	802c586 <GetBatteryLevel+0x3e>
    batteryLevel = (((uint32_t)(batteryLevelmV - VDD_MIN) * LORAWAN_MAX_BAT) / (VDD_BAT - VDD_MIN));
 802c55c:	f5a0 60e1 	sub.w	r0, r0, #1800	; 0x708
 802c560:	24fe      	movs	r4, #254	; 0xfe
 802c562:	4344      	muls	r4, r0
 802c564:	f44f 6396 	mov.w	r3, #1200	; 0x4b0
 802c568:	fbb4 f4f3 	udiv	r4, r4, r3
 802c56c:	b2e4      	uxtb	r4, r4
  APP_LOG(TS_ON, VLEVEL_M, "VDDA= %d\r\n", batteryLevel);
 802c56e:	4b07      	ldr	r3, [pc, #28]	; (802c58c <GetBatteryLevel+0x44>)
 802c570:	9400      	str	r4, [sp, #0]
 802c572:	2201      	movs	r2, #1
 802c574:	2100      	movs	r1, #0
 802c576:	2002      	movs	r0, #2
 802c578:	f00e fb88 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
}
 802c57c:	4620      	mov	r0, r4
 802c57e:	b002      	add	sp, #8
 802c580:	bd10      	pop	{r4, pc}
    batteryLevel = LORAWAN_MAX_BAT;
 802c582:	24fe      	movs	r4, #254	; 0xfe
 802c584:	e7f3      	b.n	802c56e <GetBatteryLevel+0x26>
    batteryLevel = 0;
 802c586:	2400      	movs	r4, #0
 802c588:	e7f1      	b.n	802c56e <GetBatteryLevel+0x26>
 802c58a:	bf00      	nop
 802c58c:	0803bd2c 	.word	0x0803bd2c

0802c590 <GetTemperatureLevel>:
{
 802c590:	b508      	push	{r3, lr}
  temperatureLevel = (uint16_t)(SYS_GetTemperatureLevel() / 256);
 802c592:	f7ff fcf5 	bl	802bf80 <SYS_GetTemperatureLevel>
 802c596:	2800      	cmp	r0, #0
 802c598:	bfb8      	it	lt
 802c59a:	30ff      	addlt	r0, #255	; 0xff
}
 802c59c:	f3c0 200f 	ubfx	r0, r0, #8, #16
 802c5a0:	bd08      	pop	{r3, pc}
	...

0802c5a4 <GetUniqueId>:
{
 802c5a4:	b538      	push	{r3, r4, r5, lr}
  * @brief  Return the Unique Device Number
  * @retval Values between Min_Data=0x00000000 and Max_Data=0xFFFFFFFF
  */
__STATIC_INLINE uint32_t LL_FLASH_GetUDN(void)
{
  return (READ_REG(*((uint32_t *)UID64_BASE)));
 802c5a6:	4b17      	ldr	r3, [pc, #92]	; (802c604 <GetUniqueId+0x60>)
 802c5a8:	681b      	ldr	r3, [r3, #0]
  if (val == 0xFFFFFFFF)  /* Normally this should not happen */
 802c5aa:	1c5a      	adds	r2, r3, #1
{
 802c5ac:	4604      	mov	r4, r0
  if (val == 0xFFFFFFFF)  /* Normally this should not happen */
 802c5ae:	d116      	bne.n	802c5de <GetUniqueId+0x3a>
    uint32_t ID_1_3_val = HAL_GetUIDw0() + HAL_GetUIDw2();
 802c5b0:	f000 ff58 	bl	802d464 <HAL_GetUIDw0>
 802c5b4:	4605      	mov	r5, r0
 802c5b6:	f000 ff61 	bl	802d47c <HAL_GetUIDw2>
 802c5ba:	4405      	add	r5, r0
    uint32_t ID_2_val = HAL_GetUIDw1();
 802c5bc:	f000 ff58 	bl	802d470 <HAL_GetUIDw1>
    id[7] = (ID_1_3_val) >> 24;
 802c5c0:	0e2b      	lsrs	r3, r5, #24
 802c5c2:	71e3      	strb	r3, [r4, #7]
    id[6] = (ID_1_3_val) >> 16;
 802c5c4:	0c2b      	lsrs	r3, r5, #16
 802c5c6:	71a3      	strb	r3, [r4, #6]
    id[5] = (ID_1_3_val) >> 8;
 802c5c8:	0a2b      	lsrs	r3, r5, #8
 802c5ca:	7163      	strb	r3, [r4, #5]
    id[3] = (ID_2_val) >> 24;
 802c5cc:	0e03      	lsrs	r3, r0, #24
 802c5ce:	70e3      	strb	r3, [r4, #3]
    id[2] = (ID_2_val) >> 16;
 802c5d0:	0c03      	lsrs	r3, r0, #16
 802c5d2:	70a3      	strb	r3, [r4, #2]
    id[1] = (ID_2_val) >> 8;
 802c5d4:	0a03      	lsrs	r3, r0, #8
    id[4] = (ID_1_3_val);
 802c5d6:	7125      	strb	r5, [r4, #4]
    id[1] = (ID_2_val) >> 8;
 802c5d8:	7063      	strb	r3, [r4, #1]
    id[0] = (ID_2_val);
 802c5da:	7020      	strb	r0, [r4, #0]
}
 802c5dc:	bd38      	pop	{r3, r4, r5, pc}
    id[6] = (val >> 8) & 0xFF;
 802c5de:	0a1a      	lsrs	r2, r3, #8
    id[7] = val & 0xFF;
 802c5e0:	71c3      	strb	r3, [r0, #7]
    id[6] = (val >> 8) & 0xFF;
 802c5e2:	7182      	strb	r2, [r0, #6]
    id[5] = (val >> 16) & 0xFF;
 802c5e4:	0c1a      	lsrs	r2, r3, #16
    id[4] = (val >> 24) & 0xFF;
 802c5e6:	0e1b      	lsrs	r3, r3, #24
 802c5e8:	7103      	strb	r3, [r0, #4]
  *         For STM32WLxxxx devices, the device ID is 0x15
  * @retval Values between Min_Data=0x00 and Max_Data=0xFF (ex: Device ID is 0x15)
  */
__STATIC_INLINE uint32_t LL_FLASH_GetDeviceID(void)
{
  return ((READ_REG(*((uint32_t *)UID64_BASE + 1U))) & 0x000000FFU);
 802c5ea:	4b07      	ldr	r3, [pc, #28]	; (802c608 <GetUniqueId+0x64>)
    id[5] = (val >> 16) & 0xFF;
 802c5ec:	7142      	strb	r2, [r0, #5]
    id[3] = val & 0xFF;
 802c5ee:	681a      	ldr	r2, [r3, #0]
 802c5f0:	70c2      	strb	r2, [r0, #3]
  * @note   For STM32WLxxxx devices, the ST Company ID is 0x0080E1
  * @retval Values between Min_Data=0x00 and Max_Data=0xFFFFFF (ex: ST Company ID is 0x0080E1)
  */
__STATIC_INLINE uint32_t LL_FLASH_GetSTCompanyID(void)
{
  return (((READ_REG(*((uint32_t *)UID64_BASE + 1U))) >> 8U) & 0x00FFFFFFU);
 802c5f2:	681b      	ldr	r3, [r3, #0]
 802c5f4:	0a1a      	lsrs	r2, r3, #8
    id[2] = val & 0xFF;
 802c5f6:	7082      	strb	r2, [r0, #2]
    id[1] = (val >> 8) & 0xFF;
 802c5f8:	0c1a      	lsrs	r2, r3, #16
    id[0] = (val >> 16) & 0xFF;
 802c5fa:	0e1b      	lsrs	r3, r3, #24
    id[1] = (val >> 8) & 0xFF;
 802c5fc:	7042      	strb	r2, [r0, #1]
    id[0] = (val >> 16) & 0xFF;
 802c5fe:	7003      	strb	r3, [r0, #0]
}
 802c600:	e7ec      	b.n	802c5dc <GetUniqueId+0x38>
 802c602:	bf00      	nop
 802c604:	1fff7580 	.word	0x1fff7580
 802c608:	1fff7584 	.word	0x1fff7584

0802c60c <GetDevAddr>:
  return (READ_REG(*((uint32_t *)UID64_BASE)));
 802c60c:	4b07      	ldr	r3, [pc, #28]	; (802c62c <GetDevAddr+0x20>)
 802c60e:	6818      	ldr	r0, [r3, #0]
  if (val == 0xFFFFFFFF)
 802c610:	1c43      	adds	r3, r0, #1
{
 802c612:	b510      	push	{r4, lr}
  if (val == 0xFFFFFFFF)
 802c614:	d108      	bne.n	802c628 <GetDevAddr+0x1c>
    val = ((HAL_GetUIDw0()) ^ (HAL_GetUIDw1()) ^ (HAL_GetUIDw2()));
 802c616:	f000 ff25 	bl	802d464 <HAL_GetUIDw0>
 802c61a:	4604      	mov	r4, r0
 802c61c:	f000 ff28 	bl	802d470 <HAL_GetUIDw1>
 802c620:	4044      	eors	r4, r0
 802c622:	f000 ff2b 	bl	802d47c <HAL_GetUIDw2>
 802c626:	4060      	eors	r0, r4
}
 802c628:	bd10      	pop	{r4, pc}
 802c62a:	bf00      	nop
 802c62c:	1fff7580 	.word	0x1fff7580

0802c630 <UTIL_ADV_TRACE_PreSendHook>:
  UTIL_LPM_SetStopMode((1 << CFG_LPM_UART_TX_Id), UTIL_LPM_DISABLE);
 802c630:	2101      	movs	r1, #1
 802c632:	2002      	movs	r0, #2
 802c634:	f00e bbe8 	b.w	803ae08 <UTIL_LPM_SetStopMode>

0802c638 <UTIL_ADV_TRACE_PostSendHook>:
  UTIL_LPM_SetStopMode((1 << CFG_LPM_UART_TX_Id), UTIL_LPM_ENABLE);
 802c638:	2100      	movs	r1, #0
 802c63a:	2002      	movs	r0, #2
 802c63c:	f00e bbe4 	b.w	803ae08 <UTIL_LPM_SetStopMode>

0802c640 <HAL_InitTick>:
  /* USER CODE END HAL_InitTick_1 */
  return HAL_OK;
  /* USER CODE BEGIN HAL_InitTick_2 */

  /* USER CODE END HAL_InitTick_2 */
}
 802c640:	2000      	movs	r0, #0
 802c642:	4770      	bx	lr

0802c644 <HAL_GetTick>:
{
  /* TIMER_IF can be based on other counter the SysTick e.g. RTC */
  /* USER CODE BEGIN HAL_GetTick_1 */

  /* USER CODE END HAL_GetTick_1 */
  return TIMER_IF_GetTimerValue();
 802c644:	f000 b844 	b.w	802c6d0 <TIMER_IF_GetTimerValue>

0802c648 <HAL_Delay>:

/**
  * @note This function overwrites the __weak one from HAL
  */
void HAL_Delay(__IO uint32_t Delay)
{
 802c648:	b082      	sub	sp, #8
 802c64a:	9001      	str	r0, [sp, #4]
  /* TIMER_IF can be based on other counter the SysTick e.g. RTC */
  /* USER CODE BEGIN HAL_Delay_1 */

  /* USER CODE END HAL_Delay_1 */
  TIMER_IF_DelayMs(Delay);
 802c64c:	9801      	ldr	r0, [sp, #4]
  /* USER CODE BEGIN HAL_Delay_2 */

  /* USER CODE END HAL_Delay_2 */
}
 802c64e:	b002      	add	sp, #8
  TIMER_IF_DelayMs(Delay);
 802c650:	f000 b8f8 	b.w	802c844 <TIMER_IF_DelayMs>

0802c654 <DBG_ConfigForLpm>:
  enable_dbg = 0;
#elif !defined (DEBUGGER_ENABLED)
#error "DEBUGGER_ENABLED not defined or out of range <0,1>"
#endif /* DEBUGGER_OFF */

  if (enable_dbg == 1)
 802c654:	2801      	cmp	r0, #1
{
 802c656:	b508      	push	{r3, lr}
  if (enable_dbg == 1)
 802c658:	d107      	bne.n	802c66a <DBG_ConfigForLpm+0x16>
  {
    HAL_DBGMCU_EnableDBGSleepMode();
 802c65a:	f000 ff15 	bl	802d488 <HAL_DBGMCU_EnableDBGSleepMode>
    HAL_DBGMCU_EnableDBGStopMode();
 802c65e:	f000 ff23 	bl	802d4a8 <HAL_DBGMCU_EnableDBGStopMode>
  }

  /* USER CODE BEGIN DBG_ConfigForLpm_Last */

  /* USER CODE END DBG_ConfigForLpm_Last */
}
 802c662:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    HAL_DBGMCU_EnableDBGStandbyMode();
 802c666:	f000 bf2f 	b.w	802d4c8 <HAL_DBGMCU_EnableDBGStandbyMode>
    HAL_DBGMCU_DisableDBGSleepMode();
 802c66a:	f000 ff15 	bl	802d498 <HAL_DBGMCU_DisableDBGSleepMode>
    HAL_DBGMCU_DisableDBGStopMode();
 802c66e:	f000 ff23 	bl	802d4b8 <HAL_DBGMCU_DisableDBGStopMode>
}
 802c672:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    HAL_DBGMCU_DisableDBGStandbyMode();
 802c676:	f000 bf2f 	b.w	802d4d8 <HAL_DBGMCU_DisableDBGStandbyMode>

0802c67a <DBG_Disable>:
  DBG_ConfigForLpm(0);
 802c67a:	2000      	movs	r0, #0
 802c67c:	f7ff bfea 	b.w	802c654 <DBG_ConfigForLpm>

0802c680 <DBG_ProbesInit>:
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_EnableIT_32_63(uint32_t ExtiLine)
{
  SET_BIT(EXTI->IMR2, ExtiLine);
 802c680:	4a03      	ldr	r2, [pc, #12]	; (802c690 <DBG_ProbesInit+0x10>)
 802c682:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 802c686:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 802c68a:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
#endif /* CORE_CM4 */

  /* USER CODE BEGIN DBG_ProbesInit_Last */

  /* USER CODE END DBG_ProbesInit_Last */
}
 802c68e:	4770      	bx	lr
 802c690:	58000800 	.word	0x58000800

0802c694 <EnvSensors_Init>:
#elif !defined (SENSOR_ENABLED)
#error SENSOR_ENABLED not defined
#endif /* SENSOR_ENABLED  */
  return 0;
  /* USER CODE END EnvSensors_Init */
}
 802c694:	2000      	movs	r0, #0
 802c696:	4770      	bx	lr

0802c698 <TIMER_IF_SetTimerContext>:
  * @retval If binary mode is none, Value between Min_Data=0x0 and Max_Data=0x7FFF
  *         else Value between Min_Data=0x0 and Max_Data=0xFFFFFFFF
  */
__STATIC_INLINE uint32_t LL_RTC_TIME_GetSubSecond(RTC_TypeDef *RTCx)
{
  return (uint32_t)(READ_BIT(RTCx->SSR, RTC_SSR_SS));
 802c698:	4b02      	ldr	r3, [pc, #8]	; (802c6a4 <TIMER_IF_SetTimerContext+0xc>)
 802c69a:	6898      	ldr	r0, [r3, #8]
}

uint32_t TIMER_IF_SetTimerContext(void)
{
  /*store time context*/
  RtcTimerContext = GetTimerTicks();
 802c69c:	4b02      	ldr	r3, [pc, #8]	; (802c6a8 <TIMER_IF_SetTimerContext+0x10>)
static inline uint32_t GetTimerTicks(void)
{
  /* USER CODE BEGIN GetTimerTicks */

  /* USER CODE END GetTimerTicks */
  return (UINT32_MAX - LL_RTC_TIME_GetSubSecond(RTC));
 802c69e:	43c0      	mvns	r0, r0
  RtcTimerContext = GetTimerTicks();
 802c6a0:	6018      	str	r0, [r3, #0]
}
 802c6a2:	4770      	bx	lr
 802c6a4:	40002800 	.word	0x40002800
 802c6a8:	200035c8 	.word	0x200035c8

0802c6ac <TIMER_IF_GetTimerContext>:
}
 802c6ac:	4b01      	ldr	r3, [pc, #4]	; (802c6b4 <TIMER_IF_GetTimerContext+0x8>)
 802c6ae:	6818      	ldr	r0, [r3, #0]
 802c6b0:	4770      	bx	lr
 802c6b2:	bf00      	nop
 802c6b4:	200035c8 	.word	0x200035c8

0802c6b8 <TIMER_IF_GetTimerElapsedTime>:
 802c6b8:	4b03      	ldr	r3, [pc, #12]	; (802c6c8 <TIMER_IF_GetTimerElapsedTime+0x10>)
  ret = ((uint32_t)(GetTimerTicks() - RtcTimerContext));
 802c6ba:	4a04      	ldr	r2, [pc, #16]	; (802c6cc <TIMER_IF_GetTimerElapsedTime+0x14>)
 802c6bc:	689b      	ldr	r3, [r3, #8]
 802c6be:	6810      	ldr	r0, [r2, #0]
  return (UINT32_MAX - LL_RTC_TIME_GetSubSecond(RTC));
 802c6c0:	43db      	mvns	r3, r3
}
 802c6c2:	1a18      	subs	r0, r3, r0
 802c6c4:	4770      	bx	lr
 802c6c6:	bf00      	nop
 802c6c8:	40002800 	.word	0x40002800
 802c6cc:	200035c8 	.word	0x200035c8

0802c6d0 <TIMER_IF_GetTimerValue>:
  if (RTC_Initialized == true)
 802c6d0:	4b03      	ldr	r3, [pc, #12]	; (802c6e0 <TIMER_IF_GetTimerValue+0x10>)
 802c6d2:	7918      	ldrb	r0, [r3, #4]
 802c6d4:	b110      	cbz	r0, 802c6dc <TIMER_IF_GetTimerValue+0xc>
 802c6d6:	4b03      	ldr	r3, [pc, #12]	; (802c6e4 <TIMER_IF_GetTimerValue+0x14>)
 802c6d8:	6898      	ldr	r0, [r3, #8]
  return (UINT32_MAX - LL_RTC_TIME_GetSubSecond(RTC));
 802c6da:	43c0      	mvns	r0, r0
}
 802c6dc:	4770      	bx	lr
 802c6de:	bf00      	nop
 802c6e0:	200035c8 	.word	0x200035c8
 802c6e4:	40002800 	.word	0x40002800

0802c6e8 <TIMER_IF_GetMinimumTimeout>:
}
 802c6e8:	2003      	movs	r0, #3
 802c6ea:	4770      	bx	lr

0802c6ec <TIMER_IF_Convert_ms2Tick>:
{
 802c6ec:	b508      	push	{r3, lr}
 802c6ee:	4601      	mov	r1, r0
  ret = ((uint32_t)((((uint64_t) timeMilliSec) << RTC_N_PREDIV_S) / 1000));
 802c6f0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 802c6f4:	2300      	movs	r3, #0
 802c6f6:	0280      	lsls	r0, r0, #10
 802c6f8:	0d89      	lsrs	r1, r1, #22
 802c6fa:	f7ff fa23 	bl	802bb44 <__aeabi_uldivmod>
}
 802c6fe:	bd08      	pop	{r3, pc}

0802c700 <TIMER_IF_Convert_Tick2ms>:
  ret = ((uint32_t)((((uint64_t)(tick)) * 1000) >> RTC_N_PREDIV_S));
 802c700:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 802c704:	fba0 2302 	umull	r2, r3, r0, r2
 802c708:	0a90      	lsrs	r0, r2, #10
}
 802c70a:	ea40 5083 	orr.w	r0, r0, r3, lsl #22
 802c70e:	4770      	bx	lr

0802c710 <TIMER_IF_StopTimer>:
{
 802c710:	b510      	push	{r4, lr}
  __HAL_RTC_ALARM_CLEAR_FLAG(&hrtc, RTC_FLAG_ALRAF);
 802c712:	4b07      	ldr	r3, [pc, #28]	; (802c730 <TIMER_IF_StopTimer+0x20>)
  HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_A);
 802c714:	4c07      	ldr	r4, [pc, #28]	; (802c734 <TIMER_IF_StopTimer+0x24>)
  __HAL_RTC_ALARM_CLEAR_FLAG(&hrtc, RTC_FLAG_ALRAF);
 802c716:	2201      	movs	r2, #1
 802c718:	65da      	str	r2, [r3, #92]	; 0x5c
  HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_A);
 802c71a:	f44f 7180 	mov.w	r1, #256	; 0x100
 802c71e:	4620      	mov	r0, r4
 802c720:	f002 fe06 	bl	802f330 <HAL_RTC_DeactivateAlarm>
  hrtc.IsEnabled.RtcFeatures = UINT32_MAX;
 802c724:	f04f 33ff 	mov.w	r3, #4294967295
 802c728:	6323      	str	r3, [r4, #48]	; 0x30
}
 802c72a:	2000      	movs	r0, #0
 802c72c:	bd10      	pop	{r4, pc}
 802c72e:	bf00      	nop
 802c730:	40002800 	.word	0x40002800
 802c734:	200061b8 	.word	0x200061b8

0802c738 <TIMER_IF_BkUp_Write_Seconds>:
{
 802c738:	4602      	mov	r2, r0
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_SECONDS, Seconds);
 802c73a:	2100      	movs	r1, #0
 802c73c:	4801      	ldr	r0, [pc, #4]	; (802c744 <TIMER_IF_BkUp_Write_Seconds+0xc>)
 802c73e:	f003 b80c 	b.w	802f75a <HAL_RTCEx_BKUPWrite>
 802c742:	bf00      	nop
 802c744:	200061b8 	.word	0x200061b8

0802c748 <TIMER_IF_BkUp_Write_SubSeconds>:
{
 802c748:	4602      	mov	r2, r0
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_SUBSECONDS, SubSeconds);
 802c74a:	2101      	movs	r1, #1
 802c74c:	4801      	ldr	r0, [pc, #4]	; (802c754 <TIMER_IF_BkUp_Write_SubSeconds+0xc>)
 802c74e:	f003 b804 	b.w	802f75a <HAL_RTCEx_BKUPWrite>
 802c752:	bf00      	nop
 802c754:	200061b8 	.word	0x200061b8

0802c758 <TIMER_IF_StartTimer>:
{
 802c758:	b510      	push	{r4, lr}
 802c75a:	b08c      	sub	sp, #48	; 0x30
  RTC_AlarmTypeDef sAlarm = {0};
 802c75c:	222c      	movs	r2, #44	; 0x2c
 802c75e:	2100      	movs	r1, #0
{
 802c760:	4604      	mov	r4, r0
  RTC_AlarmTypeDef sAlarm = {0};
 802c762:	a801      	add	r0, sp, #4
 802c764:	f00e ffd8 	bl	803b718 <memset>
  TIMER_IF_StopTimer();
 802c768:	f7ff ffd2 	bl	802c710 <TIMER_IF_StopTimer>
  timeout += RtcTimerContext;
 802c76c:	4b0c      	ldr	r3, [pc, #48]	; (802c7a0 <TIMER_IF_StartTimer+0x48>)
 802c76e:	6818      	ldr	r0, [r3, #0]
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
 802c770:	2300      	movs	r3, #0
  timeout += RtcTimerContext;
 802c772:	4404      	add	r4, r0
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
 802c774:	9308      	str	r3, [sp, #32]
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
 802c776:	9306      	str	r3, [sp, #24]
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDBINMASK_NONE;
 802c778:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
  sAlarm.AlarmTime.SubSeconds = UINT32_MAX - timeout;
 802c77c:	43e4      	mvns	r4, r4
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDBINMASK_NONE;
 802c77e:	9307      	str	r3, [sp, #28]
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 802c780:	4808      	ldr	r0, [pc, #32]	; (802c7a4 <TIMER_IF_StartTimer+0x4c>)
  sAlarm.AlarmTime.SubSeconds = UINT32_MAX - timeout;
 802c782:	9402      	str	r4, [sp, #8]
  sAlarm.Alarm = RTC_ALARM_A;
 802c784:	f44f 7380 	mov.w	r3, #256	; 0x100
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 802c788:	2201      	movs	r2, #1
 802c78a:	a901      	add	r1, sp, #4
  sAlarm.Alarm = RTC_ALARM_A;
 802c78c:	930b      	str	r3, [sp, #44]	; 0x2c
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 802c78e:	f002 fee5 	bl	802f55c <HAL_RTC_SetAlarm_IT>
 802c792:	b108      	cbz	r0, 802c798 <TIMER_IF_StartTimer+0x40>
    Error_Handler();
 802c794:	f7ff fd8e 	bl	802c2b4 <Error_Handler>
}
 802c798:	2000      	movs	r0, #0
 802c79a:	b00c      	add	sp, #48	; 0x30
 802c79c:	bd10      	pop	{r4, pc}
 802c79e:	bf00      	nop
 802c7a0:	200035c8 	.word	0x200035c8
 802c7a4:	200061b8 	.word	0x200061b8

0802c7a8 <TIMER_IF_GetTime>:
 802c7a8:	4b0c      	ldr	r3, [pc, #48]	; (802c7dc <TIMER_IF_GetTime+0x34>)
{
 802c7aa:	b570      	push	{r4, r5, r6, lr}
 802c7ac:	689c      	ldr	r4, [r3, #8]
 802c7ae:	4606      	mov	r6, r0
  MSBticks = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_MSBTICKS);
 802c7b0:	2102      	movs	r1, #2
 802c7b2:	480b      	ldr	r0, [pc, #44]	; (802c7e0 <TIMER_IF_GetTime+0x38>)
 802c7b4:	f002 ffd8 	bl	802f768 <HAL_RTCEx_BKUPRead>
  return (UINT32_MAX - LL_RTC_TIME_GetSubSecond(RTC));
 802c7b8:	43e4      	mvns	r4, r4
  ticks = (((uint64_t) timerValueMSB) << 32) + timerValueLsb;
 802c7ba:	2200      	movs	r2, #0
 802c7bc:	1912      	adds	r2, r2, r4
  ticks = (uint32_t) ticks & RTC_PREDIV_S;
 802c7be:	f3c2 0409 	ubfx	r4, r2, #0, #10
  ret = ((uint32_t)((((uint64_t)(tick)) * 1000) >> RTC_N_PREDIV_S));
 802c7c2:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 802c7c6:	fba4 4501 	umull	r4, r5, r4, r1
  ticks = (((uint64_t) timerValueMSB) << 32) + timerValueLsb;
 802c7ca:	f140 0300 	adc.w	r3, r0, #0
  ret = ((uint32_t)((((uint64_t)(tick)) * 1000) >> RTC_N_PREDIV_S));
 802c7ce:	0aa4      	lsrs	r4, r4, #10
  seconds = (uint32_t)(ticks >> RTC_N_PREDIV_S);
 802c7d0:	0a90      	lsrs	r0, r2, #10
  *mSeconds = TIMER_IF_Convert_Tick2ms(ticks);
 802c7d2:	8034      	strh	r4, [r6, #0]
}
 802c7d4:	ea40 5083 	orr.w	r0, r0, r3, lsl #22
 802c7d8:	bd70      	pop	{r4, r5, r6, pc}
 802c7da:	bf00      	nop
 802c7dc:	40002800 	.word	0x40002800
 802c7e0:	200061b8 	.word	0x200061b8

0802c7e4 <TIMER_IF_BkUp_Read_Seconds>:
  ret = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_SECONDS);
 802c7e4:	4801      	ldr	r0, [pc, #4]	; (802c7ec <TIMER_IF_BkUp_Read_Seconds+0x8>)
 802c7e6:	2100      	movs	r1, #0
 802c7e8:	f002 bfbe 	b.w	802f768 <HAL_RTCEx_BKUPRead>
 802c7ec:	200061b8 	.word	0x200061b8

0802c7f0 <TIMER_IF_BkUp_Read_SubSeconds>:
  ret = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_SUBSECONDS);
 802c7f0:	4801      	ldr	r0, [pc, #4]	; (802c7f8 <TIMER_IF_BkUp_Read_SubSeconds+0x8>)
 802c7f2:	2101      	movs	r1, #1
 802c7f4:	f002 bfb8 	b.w	802f768 <HAL_RTCEx_BKUPRead>
 802c7f8:	200061b8 	.word	0x200061b8

0802c7fc <TIMER_IF_Init>:
{
 802c7fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (RTC_Initialized == false)
 802c7fe:	4d0f      	ldr	r5, [pc, #60]	; (802c83c <TIMER_IF_Init+0x40>)
 802c800:	792e      	ldrb	r6, [r5, #4]
 802c802:	b9ce      	cbnz	r6, 802c838 <TIMER_IF_Init+0x3c>
    hrtc.IsEnabled.RtcFeatures = UINT32_MAX;
 802c804:	4c0e      	ldr	r4, [pc, #56]	; (802c840 <TIMER_IF_Init+0x44>)
 802c806:	f04f 37ff 	mov.w	r7, #4294967295
 802c80a:	6327      	str	r7, [r4, #48]	; 0x30
    MX_RTC_Init();
 802c80c:	f7ff fd54 	bl	802c2b8 <MX_RTC_Init>
    TIMER_IF_StopTimer();
 802c810:	f7ff ff7e 	bl	802c710 <TIMER_IF_StopTimer>
    HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_A);
 802c814:	f44f 7180 	mov.w	r1, #256	; 0x100
 802c818:	4620      	mov	r0, r4
 802c81a:	f002 fd89 	bl	802f330 <HAL_RTC_DeactivateAlarm>
    HAL_RTCEx_EnableBypassShadow(&hrtc);
 802c81e:	4620      	mov	r0, r4
    hrtc.IsEnabled.RtcFeatures = UINT32_MAX;
 802c820:	6327      	str	r7, [r4, #48]	; 0x30
    HAL_RTCEx_EnableBypassShadow(&hrtc);
 802c822:	f002 ff45 	bl	802f6b0 <HAL_RTCEx_EnableBypassShadow>
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_MSBTICKS, MSBticks);
 802c826:	4632      	mov	r2, r6
 802c828:	2102      	movs	r1, #2
 802c82a:	4620      	mov	r0, r4
 802c82c:	f002 ff95 	bl	802f75a <HAL_RTCEx_BKUPWrite>
    TIMER_IF_SetTimerContext();
 802c830:	f7ff ff32 	bl	802c698 <TIMER_IF_SetTimerContext>
    RTC_Initialized = true;
 802c834:	2301      	movs	r3, #1
 802c836:	712b      	strb	r3, [r5, #4]
}
 802c838:	2000      	movs	r0, #0
 802c83a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802c83c:	200035c8 	.word	0x200035c8
 802c840:	200061b8 	.word	0x200061b8

0802c844 <TIMER_IF_DelayMs>:
{
 802c844:	4601      	mov	r1, r0
 802c846:	b508      	push	{r3, lr}
  ret = ((uint32_t)((((uint64_t) timeMilliSec) << RTC_N_PREDIV_S) / 1000));
 802c848:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 802c84c:	2300      	movs	r3, #0
 802c84e:	0280      	lsls	r0, r0, #10
 802c850:	0d89      	lsrs	r1, r1, #22
 802c852:	f7ff f977 	bl	802bb44 <__aeabi_uldivmod>
 802c856:	4a05      	ldr	r2, [pc, #20]	; (802c86c <TIMER_IF_DelayMs+0x28>)
 802c858:	6891      	ldr	r1, [r2, #8]
  return (UINT32_MAX - LL_RTC_TIME_GetSubSecond(RTC));
 802c85a:	43c9      	mvns	r1, r1
 802c85c:	6893      	ldr	r3, [r2, #8]
 802c85e:	43db      	mvns	r3, r3
  while (((GetTimerTicks() - timeout)) < delayTicks)
 802c860:	1a5b      	subs	r3, r3, r1
 802c862:	4283      	cmp	r3, r0
 802c864:	d300      	bcc.n	802c868 <TIMER_IF_DelayMs+0x24>
}
 802c866:	bd08      	pop	{r3, pc}
    __NOP();
 802c868:	bf00      	nop
 802c86a:	e7f7      	b.n	802c85c <TIMER_IF_DelayMs+0x18>
 802c86c:	40002800 	.word	0x40002800

0802c870 <HAL_RTC_AlarmAEventCallback>:
  UTIL_TIMER_IRQ_MAP_PROCESS();
 802c870:	f00e bdd0 	b.w	803b414 <UTIL_TIMER_IRQ_Handler>

0802c874 <HAL_RTCEx_SSRUEventCallback>:
{
 802c874:	b510      	push	{r4, lr}
  MSBticks = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_MSBTICKS);
 802c876:	4c06      	ldr	r4, [pc, #24]	; (802c890 <HAL_RTCEx_SSRUEventCallback+0x1c>)
 802c878:	2102      	movs	r1, #2
 802c87a:	4620      	mov	r0, r4
 802c87c:	f002 ff74 	bl	802f768 <HAL_RTCEx_BKUPRead>
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_MSBTICKS, MSBticks);
 802c880:	2102      	movs	r1, #2
 802c882:	1c42      	adds	r2, r0, #1
 802c884:	4620      	mov	r0, r4
}
 802c886:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_MSBTICKS, MSBticks);
 802c88a:	f002 bf66 	b.w	802f75a <HAL_RTCEx_BKUPWrite>
 802c88e:	bf00      	nop
 802c890:	200061b8 	.word	0x200061b8

0802c894 <MX_USART2_UART_Init>:
  /* USER CODE END USART2_Init 0 */

  /* USER CODE BEGIN USART2_Init 1 */

  /* USER CODE END USART2_Init 1 */
  huart2.Instance = USART2;
 802c894:	4816      	ldr	r0, [pc, #88]	; (802c8f0 <MX_USART2_UART_Init+0x5c>)
  huart2.Init.BaudRate = 115200;
 802c896:	4a17      	ldr	r2, [pc, #92]	; (802c8f4 <MX_USART2_UART_Init+0x60>)
{
 802c898:	b508      	push	{r3, lr}
  huart2.Init.BaudRate = 115200;
 802c89a:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
 802c89e:	e9c0 2300 	strd	r2, r3, [r0]
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 802c8a2:	2300      	movs	r3, #0
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
 802c8a4:	220c      	movs	r2, #12
  huart2.Init.StopBits = UART_STOPBITS_1;
 802c8a6:	e9c0 3302 	strd	r3, r3, [r0, #8]
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 802c8aa:	e9c0 2305 	strd	r2, r3, [r0, #20]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 802c8ae:	e9c0 3307 	strd	r3, r3, [r0, #28]
  huart2.Init.ClockPrescaler = UART_PRESCALER_DIV1;
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 802c8b2:	e9c0 3309 	strd	r3, r3, [r0, #36]	; 0x24
  huart2.Init.Parity = UART_PARITY_NONE;
 802c8b6:	6103      	str	r3, [r0, #16]
  if (HAL_UART_Init(&huart2) != HAL_OK)
 802c8b8:	f004 f874 	bl	80309a4 <HAL_UART_Init>
 802c8bc:	b108      	cbz	r0, 802c8c2 <MX_USART2_UART_Init+0x2e>
  {
    Error_Handler();
 802c8be:	f7ff fcf9 	bl	802c2b4 <Error_Handler>
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart2, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
 802c8c2:	480b      	ldr	r0, [pc, #44]	; (802c8f0 <MX_USART2_UART_Init+0x5c>)
 802c8c4:	2100      	movs	r1, #0
 802c8c6:	f004 f9f4 	bl	8030cb2 <HAL_UARTEx_SetTxFifoThreshold>
 802c8ca:	b108      	cbz	r0, 802c8d0 <MX_USART2_UART_Init+0x3c>
  {
    Error_Handler();
 802c8cc:	f7ff fcf2 	bl	802c2b4 <Error_Handler>
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart2, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
 802c8d0:	4807      	ldr	r0, [pc, #28]	; (802c8f0 <MX_USART2_UART_Init+0x5c>)
 802c8d2:	2100      	movs	r1, #0
 802c8d4:	f004 fa11 	bl	8030cfa <HAL_UARTEx_SetRxFifoThreshold>
 802c8d8:	b108      	cbz	r0, 802c8de <MX_USART2_UART_Init+0x4a>
  {
    Error_Handler();
 802c8da:	f7ff fceb 	bl	802c2b4 <Error_Handler>
  }
  if (HAL_UARTEx_EnableFifoMode(&huart2) != HAL_OK)
 802c8de:	4804      	ldr	r0, [pc, #16]	; (802c8f0 <MX_USART2_UART_Init+0x5c>)
 802c8e0:	f004 f9c4 	bl	8030c6c <HAL_UARTEx_EnableFifoMode>
 802c8e4:	b118      	cbz	r0, 802c8ee <MX_USART2_UART_Init+0x5a>
  }
  /* USER CODE BEGIN USART2_Init 2 */

  /* USER CODE END USART2_Init 2 */

}
 802c8e6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 802c8ea:	f7ff bce3 	b.w	802c2b4 <Error_Handler>
}
 802c8ee:	bd08      	pop	{r3, pc}
 802c8f0:	2000625c 	.word	0x2000625c
 802c8f4:	40004400 	.word	0x40004400

0802c8f8 <HAL_UART_MspInit>:

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
 802c8f8:	b570      	push	{r4, r5, r6, lr}
 802c8fa:	b096      	sub	sp, #88	; 0x58
 802c8fc:	4606      	mov	r6, r0

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 802c8fe:	2214      	movs	r2, #20
 802c900:	2100      	movs	r1, #0
 802c902:	a803      	add	r0, sp, #12
 802c904:	f00e ff08 	bl	803b718 <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 802c908:	2238      	movs	r2, #56	; 0x38
 802c90a:	2100      	movs	r1, #0
 802c90c:	a808      	add	r0, sp, #32
 802c90e:	f00e ff03 	bl	803b718 <memset>
  if(uartHandle->Instance==USART2)
 802c912:	6832      	ldr	r2, [r6, #0]
 802c914:	4b2b      	ldr	r3, [pc, #172]	; (802c9c4 <HAL_UART_MspInit+0xcc>)
 802c916:	429a      	cmp	r2, r3
 802c918:	d151      	bne.n	802c9be <HAL_UART_MspInit+0xc6>
  /* USER CODE BEGIN USART2_MspInit 0 */

  /* USER CODE END USART2_MspInit 0 */
  /** Initializes the peripherals clocks
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART2;
 802c91a:	2302      	movs	r3, #2
 802c91c:	9308      	str	r3, [sp, #32]
    PeriphClkInitStruct.Usart2ClockSelection = RCC_USART2CLKSOURCE_SYSCLK;
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 802c91e:	a808      	add	r0, sp, #32
    PeriphClkInitStruct.Usart2ClockSelection = RCC_USART2CLKSOURCE_SYSCLK;
 802c920:	4b29      	ldr	r3, [pc, #164]	; (802c9c8 <HAL_UART_MspInit+0xd0>)
 802c922:	930a      	str	r3, [sp, #40]	; 0x28
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 802c924:	f002 fc2e 	bl	802f184 <HAL_RCCEx_PeriphCLKConfig>
 802c928:	b108      	cbz	r0, 802c92e <HAL_UART_MspInit+0x36>
    {
      Error_Handler();
 802c92a:	f7ff fcc3 	bl	802c2b4 <Error_Handler>
  SET_BIT(RCC->APB1ENR1, Periphs);
 802c92e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
    PA2     ------> USART2_TX
    */
    GPIO_InitStruct.Pin = USARTx_RX_Pin|USARTx_TX_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 802c932:	2500      	movs	r5, #0
 802c934:	6d9a      	ldr	r2, [r3, #88]	; 0x58
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* USART2 DMA Init */
    /* USART2_TX Init */
    hdma_usart2_tx.Instance = DMA1_Channel5;
 802c936:	4c25      	ldr	r4, [pc, #148]	; (802c9cc <HAL_UART_MspInit+0xd4>)
 802c938:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 802c93c:	659a      	str	r2, [r3, #88]	; 0x58
  tmpreg = READ_BIT(RCC->APB1ENR1, Periphs);
 802c93e:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 802c940:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
 802c944:	9202      	str	r2, [sp, #8]
  (void)tmpreg;
 802c946:	9a02      	ldr	r2, [sp, #8]
  SET_BIT(RCC->AHB2ENR, Periphs);
 802c948:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 802c94a:	f042 0201 	orr.w	r2, r2, #1
 802c94e:	64da      	str	r2, [r3, #76]	; 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 802c950:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 802c952:	f003 0301 	and.w	r3, r3, #1
 802c956:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 802c958:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 802c95a:	220c      	movs	r2, #12
 802c95c:	2302      	movs	r3, #2
 802c95e:	e9cd 2303 	strd	r2, r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 802c962:	2303      	movs	r3, #3
 802c964:	e9cd 5305 	strd	r5, r3, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 802c968:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 802c96a:	2307      	movs	r3, #7
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 802c96c:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 802c970:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 802c972:	f001 fd71 	bl	802e458 <HAL_GPIO_Init>
    hdma_usart2_tx.Init.Request = DMA_REQUEST_USART2_TX;
 802c976:	4916      	ldr	r1, [pc, #88]	; (802c9d0 <HAL_UART_MspInit+0xd8>)
    hdma_usart2_tx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_usart2_tx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_usart2_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_usart2_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_usart2_tx.Init.Mode = DMA_NORMAL;
    hdma_usart2_tx.Init.Priority = DMA_PRIORITY_LOW;
 802c978:	6225      	str	r5, [r4, #32]
    hdma_usart2_tx.Init.Request = DMA_REQUEST_USART2_TX;
 802c97a:	2314      	movs	r3, #20
 802c97c:	e9c4 1300 	strd	r1, r3, [r4]
    hdma_usart2_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 802c980:	2310      	movs	r3, #16
    hdma_usart2_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 802c982:	e9c4 3502 	strd	r3, r5, [r4, #8]
    if (HAL_DMA_Init(&hdma_usart2_tx) != HAL_OK)
 802c986:	4620      	mov	r0, r4
    hdma_usart2_tx.Init.MemInc = DMA_MINC_ENABLE;
 802c988:	2380      	movs	r3, #128	; 0x80
    hdma_usart2_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 802c98a:	e9c4 3504 	strd	r3, r5, [r4, #16]
    hdma_usart2_tx.Init.Mode = DMA_NORMAL;
 802c98e:	e9c4 5506 	strd	r5, r5, [r4, #24]
    if (HAL_DMA_Init(&hdma_usart2_tx) != HAL_OK)
 802c992:	f001 fa47 	bl	802de24 <HAL_DMA_Init>
 802c996:	b108      	cbz	r0, 802c99c <HAL_UART_MspInit+0xa4>
    {
      Error_Handler();
 802c998:	f7ff fc8c 	bl	802c2b4 <Error_Handler>
    }

    if (HAL_DMA_ConfigChannelAttributes(&hdma_usart2_tx, DMA_CHANNEL_NPRIV) != HAL_OK)
 802c99c:	480b      	ldr	r0, [pc, #44]	; (802c9cc <HAL_UART_MspInit+0xd4>)
 802c99e:	2110      	movs	r1, #16
 802c9a0:	f001 fc12 	bl	802e1c8 <HAL_DMA_ConfigChannelAttributes>
 802c9a4:	b108      	cbz	r0, 802c9aa <HAL_UART_MspInit+0xb2>
    {
      Error_Handler();
 802c9a6:	f7ff fc85 	bl	802c2b4 <Error_Handler>
    }

    __HAL_LINKDMA(uartHandle,hdmatx,hdma_usart2_tx);

    /* USART2 interrupt Init */
    HAL_NVIC_SetPriority(USART2_IRQn, 2, 0);
 802c9aa:	2025      	movs	r0, #37	; 0x25
    __HAL_LINKDMA(uartHandle,hdmatx,hdma_usart2_tx);
 802c9ac:	67b4      	str	r4, [r6, #120]	; 0x78
    HAL_NVIC_SetPriority(USART2_IRQn, 2, 0);
 802c9ae:	2200      	movs	r2, #0
 802c9b0:	2102      	movs	r1, #2
    __HAL_LINKDMA(uartHandle,hdmatx,hdma_usart2_tx);
 802c9b2:	62a6      	str	r6, [r4, #40]	; 0x28
    HAL_NVIC_SetPriority(USART2_IRQn, 2, 0);
 802c9b4:	f001 f9a2 	bl	802dcfc <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART2_IRQn);
 802c9b8:	2025      	movs	r0, #37	; 0x25
 802c9ba:	f001 f9d1 	bl	802dd60 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USART2_MspInit 1 */

  /* USER CODE END USART2_MspInit 1 */
  }
}
 802c9be:	b016      	add	sp, #88	; 0x58
 802c9c0:	bd70      	pop	{r4, r5, r6, pc}
 802c9c2:	bf00      	nop
 802c9c4:	40004400 	.word	0x40004400
 802c9c8:	000c0004 	.word	0x000c0004
 802c9cc:	200061fc 	.word	0x200061fc
 802c9d0:	40020058 	.word	0x40020058

0802c9d4 <HAL_UART_MspDeInit>:

void HAL_UART_MspDeInit(UART_HandleTypeDef* uartHandle)
{

  if(uartHandle->Instance==USART2)
 802c9d4:	6802      	ldr	r2, [r0, #0]
 802c9d6:	4b0c      	ldr	r3, [pc, #48]	; (802ca08 <HAL_UART_MspDeInit+0x34>)
 802c9d8:	429a      	cmp	r2, r3
{
 802c9da:	b510      	push	{r4, lr}
 802c9dc:	4604      	mov	r4, r0
  if(uartHandle->Instance==USART2)
 802c9de:	d112      	bne.n	802ca06 <HAL_UART_MspDeInit+0x32>
  CLEAR_BIT(RCC->APB1ENR1, Periphs);
 802c9e0:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000

    /**USART2 GPIO Configuration
    PA3     ------> USART2_RX
    PA2     ------> USART2_TX
    */
    HAL_GPIO_DeInit(GPIOA, USARTx_RX_Pin|USARTx_TX_Pin);
 802c9e4:	210c      	movs	r1, #12
 802c9e6:	6d93      	ldr	r3, [r2, #88]	; 0x58
 802c9e8:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 802c9ec:	6593      	str	r3, [r2, #88]	; 0x58
 802c9ee:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 802c9f2:	f001 fddd 	bl	802e5b0 <HAL_GPIO_DeInit>

    /* USART2 DMA DeInit */
    HAL_DMA_DeInit(uartHandle->hdmatx);
 802c9f6:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 802c9f8:	f001 fa86 	bl	802df08 <HAL_DMA_DeInit>
    HAL_NVIC_DisableIRQ(USART2_IRQn);
  /* USER CODE BEGIN USART2_MspDeInit 1 */

  /* USER CODE END USART2_MspDeInit 1 */
  }
}
 802c9fc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    HAL_NVIC_DisableIRQ(USART2_IRQn);
 802ca00:	2025      	movs	r0, #37	; 0x25
 802ca02:	f001 b9bb 	b.w	802dd7c <HAL_NVIC_DisableIRQ>
}
 802ca06:	bd10      	pop	{r4, pc}
 802ca08:	40004400 	.word	0x40004400

0802ca0c <vcom_Trace_DMA>:

  /* USER CODE END vcom_Trace_2 */
}

UTIL_ADV_TRACE_Status_t vcom_Trace_DMA(uint8_t *p_data, uint16_t size)
{
 802ca0c:	b508      	push	{r3, lr}
 802ca0e:	460a      	mov	r2, r1
  /* USER CODE BEGIN vcom_Trace_DMA_1 */

  /* USER CODE END vcom_Trace_DMA_1 */
  HAL_UART_Transmit_DMA(&huart2, p_data, size);
 802ca10:	4601      	mov	r1, r0
 802ca12:	4802      	ldr	r0, [pc, #8]	; (802ca1c <vcom_Trace_DMA+0x10>)
 802ca14:	f003 f9b2 	bl	802fd7c <HAL_UART_Transmit_DMA>
  return UTIL_ADV_TRACE_OK;
  /* USER CODE BEGIN vcom_Trace_DMA_2 */

  /* USER CODE END vcom_Trace_DMA_2 */
}
 802ca18:	2000      	movs	r0, #0
 802ca1a:	bd08      	pop	{r3, pc}
 802ca1c:	2000625c 	.word	0x2000625c

0802ca20 <vcom_ReceiveInit>:

UTIL_ADV_TRACE_Status_t vcom_ReceiveInit(void (*RxCb)(uint8_t *rxChar, uint16_t size, uint8_t error))
{
 802ca20:	b513      	push	{r0, r1, r4, lr}

  /* USER CODE END vcom_ReceiveInit_1 */
  UART_WakeUpTypeDef WakeUpSelection;

  /*record call back*/
  RxCpltCallback = RxCb;
 802ca22:	4b11      	ldr	r3, [pc, #68]	; (802ca68 <vcom_ReceiveInit+0x48>)

  /*Set wakeUp event on start bit*/
  WakeUpSelection.WakeUpEvent = UART_WAKEUP_ON_STARTBIT;

  HAL_UARTEx_StopModeWakeUpSourceConfig(&huart2, WakeUpSelection);
 802ca24:	4c11      	ldr	r4, [pc, #68]	; (802ca6c <vcom_ReceiveInit+0x4c>)
  RxCpltCallback = RxCb;
 802ca26:	6018      	str	r0, [r3, #0]
  WakeUpSelection.WakeUpEvent = UART_WAKEUP_ON_STARTBIT;
 802ca28:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 802ca2c:	9300      	str	r3, [sp, #0]
  HAL_UARTEx_StopModeWakeUpSourceConfig(&huart2, WakeUpSelection);
 802ca2e:	ab02      	add	r3, sp, #8
 802ca30:	e913 0006 	ldmdb	r3, {r1, r2}
 802ca34:	4620      	mov	r0, r4
 802ca36:	f004 f8bc 	bl	8030bb2 <HAL_UARTEx_StopModeWakeUpSourceConfig>

  /* Make sure that no UART transfer is on-going */
  while (__HAL_UART_GET_FLAG(&huart2, USART_ISR_BUSY) == SET);
 802ca3a:	6823      	ldr	r3, [r4, #0]
 802ca3c:	69da      	ldr	r2, [r3, #28]
 802ca3e:	03d1      	lsls	r1, r2, #15
 802ca40:	d4fc      	bmi.n	802ca3c <vcom_ReceiveInit+0x1c>

  /* Make sure that UART is ready to receive)   */
  while (__HAL_UART_GET_FLAG(&huart2, USART_ISR_REACK) == RESET);
 802ca42:	69da      	ldr	r2, [r3, #28]
 802ca44:	0252      	lsls	r2, r2, #9
 802ca46:	d5fc      	bpl.n	802ca42 <vcom_ReceiveInit+0x22>

  /* Enable USART interrupt */
  __HAL_UART_ENABLE_IT(&huart2, UART_IT_WUF);
 802ca48:	689a      	ldr	r2, [r3, #8]

  /*Enable wakeup from stop mode*/
  HAL_UARTEx_EnableStopMode(&huart2);
 802ca4a:	4808      	ldr	r0, [pc, #32]	; (802ca6c <vcom_ReceiveInit+0x4c>)
  __HAL_UART_ENABLE_IT(&huart2, UART_IT_WUF);
 802ca4c:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 802ca50:	609a      	str	r2, [r3, #8]
  HAL_UARTEx_EnableStopMode(&huart2);
 802ca52:	f004 f8f5 	bl	8030c40 <HAL_UARTEx_EnableStopMode>

  /*Start LPUART receive on IT*/
  HAL_UART_Receive_IT(&huart2, &charRx, 1);
 802ca56:	4906      	ldr	r1, [pc, #24]	; (802ca70 <vcom_ReceiveInit+0x50>)
 802ca58:	4804      	ldr	r0, [pc, #16]	; (802ca6c <vcom_ReceiveInit+0x4c>)
 802ca5a:	2201      	movs	r2, #1
 802ca5c:	f004 f85a 	bl	8030b14 <HAL_UART_Receive_IT>

  return UTIL_ADV_TRACE_OK;
  /* USER CODE BEGIN vcom_ReceiveInit_2 */

  /* USER CODE END vcom_ReceiveInit_2 */
}
 802ca60:	2000      	movs	r0, #0
 802ca62:	b002      	add	sp, #8
 802ca64:	bd10      	pop	{r4, pc}
 802ca66:	bf00      	nop
 802ca68:	200035d0 	.word	0x200035d0
 802ca6c:	2000625c 	.word	0x2000625c
 802ca70:	200062ec 	.word	0x200062ec

0802ca74 <vcom_Init>:
{
 802ca74:	b508      	push	{r3, lr}
  TxCpltCallback = cb;
 802ca76:	4b07      	ldr	r3, [pc, #28]	; (802ca94 <vcom_Init+0x20>)
 802ca78:	6058      	str	r0, [r3, #4]
  MX_DMA_Init();
 802ca7a:	f7ff fabf 	bl	802bffc <MX_DMA_Init>
  MX_USART2_UART_Init();
 802ca7e:	f7ff ff09 	bl	802c894 <MX_USART2_UART_Init>
  SET_BIT(EXTI->IMR1, ExtiLine);
 802ca82:	4a05      	ldr	r2, [pc, #20]	; (802ca98 <vcom_Init+0x24>)
 802ca84:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
 802ca88:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 802ca8c:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
}
 802ca90:	2000      	movs	r0, #0
 802ca92:	bd08      	pop	{r3, pc}
 802ca94:	200035d0 	.word	0x200035d0
 802ca98:	58000800 	.word	0x58000800

0802ca9c <vcom_DeInit>:
{
 802ca9c:	b508      	push	{r3, lr}
  SET_BIT(RCC->APB1RSTR1, Periphs);
 802ca9e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
  HAL_UART_MspDeInit(&huart2);
 802caa2:	4808      	ldr	r0, [pc, #32]	; (802cac4 <vcom_DeInit+0x28>)
 802caa4:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 802caa6:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 802caaa:	639a      	str	r2, [r3, #56]	; 0x38
  CLEAR_BIT(RCC->APB1RSTR1, Periphs);
 802caac:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 802caae:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 802cab2:	639a      	str	r2, [r3, #56]	; 0x38
 802cab4:	f7ff ff8e 	bl	802c9d4 <HAL_UART_MspDeInit>
  HAL_NVIC_DisableIRQ(DMA1_Channel5_IRQn);
 802cab8:	200f      	movs	r0, #15
 802caba:	f001 f95f 	bl	802dd7c <HAL_NVIC_DisableIRQ>
}
 802cabe:	2000      	movs	r0, #0
 802cac0:	bd08      	pop	{r3, pc}
 802cac2:	bf00      	nop
 802cac4:	2000625c 	.word	0x2000625c

0802cac8 <vcom_Resume>:

void vcom_Resume(void)
{
 802cac8:	b508      	push	{r3, lr}
  /* USER CODE BEGIN vcom_Resume_1 */

  /* USER CODE END vcom_Resume_1 */
  /*to re-enable lost UART settings*/
  if (HAL_UART_Init(&huart2) != HAL_OK)
 802caca:	4807      	ldr	r0, [pc, #28]	; (802cae8 <vcom_Resume+0x20>)
 802cacc:	f003 ff6a 	bl	80309a4 <HAL_UART_Init>
 802cad0:	b108      	cbz	r0, 802cad6 <vcom_Resume+0xe>
  {
    Error_Handler();
 802cad2:	f7ff fbef 	bl	802c2b4 <Error_Handler>
  }

  /*to re-enable lost DMA settings*/
  if (HAL_DMA_Init(&hdma_usart2_tx) != HAL_OK)
 802cad6:	4805      	ldr	r0, [pc, #20]	; (802caec <vcom_Resume+0x24>)
 802cad8:	f001 f9a4 	bl	802de24 <HAL_DMA_Init>
 802cadc:	b118      	cbz	r0, 802cae6 <vcom_Resume+0x1e>
    Error_Handler();
  }
  /* USER CODE BEGIN vcom_Resume_2 */

  /* USER CODE END vcom_Resume_2 */
}
 802cade:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 802cae2:	f7ff bbe7 	b.w	802c2b4 <Error_Handler>
}
 802cae6:	bd08      	pop	{r3, pc}
 802cae8:	2000625c 	.word	0x2000625c
 802caec:	200061fc 	.word	0x200061fc

0802caf0 <HAL_UART_TxCpltCallback>:
{
  /* USER CODE BEGIN HAL_UART_TxCpltCallback_1 */

  /* USER CODE END HAL_UART_TxCpltCallback_1 */
  /* buffer transmission complete*/
  TxCpltCallback(NULL);
 802caf0:	4b01      	ldr	r3, [pc, #4]	; (802caf8 <HAL_UART_TxCpltCallback+0x8>)
 802caf2:	2000      	movs	r0, #0
 802caf4:	685b      	ldr	r3, [r3, #4]
 802caf6:	4718      	bx	r3
 802caf8:	200035d0 	.word	0x200035d0

0802cafc <HAL_UART_RxCpltCallback>:
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart2)
{
  /* USER CODE BEGIN HAL_UART_RxCpltCallback_1 */

  /* USER CODE END HAL_UART_RxCpltCallback_1 */
  if ((NULL != RxCpltCallback) && (HAL_UART_ERROR_NONE == huart2->ErrorCode))
 802cafc:	4b08      	ldr	r3, [pc, #32]	; (802cb20 <HAL_UART_RxCpltCallback+0x24>)
 802cafe:	681b      	ldr	r3, [r3, #0]
{
 802cb00:	b510      	push	{r4, lr}
 802cb02:	4604      	mov	r4, r0
  if ((NULL != RxCpltCallback) && (HAL_UART_ERROR_NONE == huart2->ErrorCode))
 802cb04:	b12b      	cbz	r3, 802cb12 <HAL_UART_RxCpltCallback+0x16>
 802cb06:	f8d0 208c 	ldr.w	r2, [r0, #140]	; 0x8c
 802cb0a:	b912      	cbnz	r2, 802cb12 <HAL_UART_RxCpltCallback+0x16>
  {
    RxCpltCallback(&charRx, 1, 0);
 802cb0c:	4805      	ldr	r0, [pc, #20]	; (802cb24 <HAL_UART_RxCpltCallback+0x28>)
 802cb0e:	2101      	movs	r1, #1
 802cb10:	4798      	blx	r3
  }
  HAL_UART_Receive_IT(huart2, &charRx, 1);
 802cb12:	4620      	mov	r0, r4
 802cb14:	4903      	ldr	r1, [pc, #12]	; (802cb24 <HAL_UART_RxCpltCallback+0x28>)
  /* USER CODE BEGIN HAL_UART_RxCpltCallback_2 */

  /* USER CODE END HAL_UART_RxCpltCallback_2 */
}
 802cb16:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  HAL_UART_Receive_IT(huart2, &charRx, 1);
 802cb1a:	2201      	movs	r2, #1
 802cb1c:	f003 bffa 	b.w	8030b14 <HAL_UART_Receive_IT>
 802cb20:	200035d0 	.word	0x200035d0
 802cb24:	200062ec 	.word	0x200062ec

0802cb28 <MX_KMS_Init>:
{
/***************************************/
   /**
  */

  C_Initialize(NULL);
 802cb28:	2000      	movs	r0, #0
 802cb2a:	f7dc b861 	b.w	8008bf0 <SE_KMS_Initialize>

0802cb2e <MX_LoRaWAN_Init>:
/* USER CODE END PFP */

/* Exported functions --------------------------------------------------------*/

void MX_LoRaWAN_Init(void)
{
 802cb2e:	b508      	push	{r3, lr}
  /* USER CODE BEGIN MX_LoRaWAN_Init_1 */

  /* USER CODE END MX_LoRaWAN_Init_1 */
  SystemApp_Init();
 802cb30:	f7ff fcda 	bl	802c4e8 <SystemApp_Init>
  /* USER CODE END MX_LoRaWAN_Init_2 */
  LoRaWAN_Init();
  /* USER CODE BEGIN MX_LoRaWAN_Init_3 */

  /* USER CODE END MX_LoRaWAN_Init_3 */
}
 802cb34:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  LoRaWAN_Init();
 802cb38:	f000 b98a 	b.w	802ce50 <LoRaWAN_Init>

0802cb3c <MX_LoRaWAN_Process>:
void MX_LoRaWAN_Process(void)
{
  /* USER CODE BEGIN MX_LoRaWAN_Process_1 */

  /* USER CODE END MX_LoRaWAN_Process_1 */
  UTIL_SEQ_Run(UTIL_SEQ_DEFAULT);
 802cb3c:	f04f 30ff 	mov.w	r0, #4294967295
 802cb40:	f00e b9f4 	b.w	803af2c <UTIL_SEQ_Run>

0802cb44 <FwUpdateAgent_Run>:
/* USER CODE END PFP */

/* Exported functions --------------------------------------------------------*/
#if (INTEROP_TEST_MODE == 0)
void FwUpdateAgent_Run(void)
{
 802cb44:	b530      	push	{r4, r5, lr}
  /* USER CODE BEGIN FwUpdateAgent_Run_1 */

  /* USER CODE END FwUpdateAgent_Run_1 */
  int32_t status = FLASH_OK;
  uint8_t fw_header_dwl_slot[SE_FW_HEADER_TOT_LEN];
  uint32_t first_page = PAGE(FRAG_DECODER_SWAP_REGION_START);
 802cb46:	4b1d      	ldr	r3, [pc, #116]	; (802cbbc <FwUpdateAgent_Run+0x78>)
  uint32_t nb_pages = PAGE(FRAG_DECODER_SWAP_REGION_START + SFU_IMG_IMAGE_OFFSET - 1) - first_page + 1U;

  /* Read header in slot 1 */
  UTIL_MEM_cpy_8(fw_header_dwl_slot, (void *)FRAG_DECODER_DWL_REGION_START, SE_FW_HEADER_TOT_LEN);
 802cb48:	491d      	ldr	r1, [pc, #116]	; (802cbc0 <FwUpdateAgent_Run+0x7c>)
  uint32_t first_page = PAGE(FRAG_DECODER_SWAP_REGION_START);
 802cb4a:	681c      	ldr	r4, [r3, #0]
{
 802cb4c:	b0d1      	sub	sp, #324	; 0x144
  UTIL_MEM_cpy_8(fw_header_dwl_slot, (void *)FRAG_DECODER_DWL_REGION_START, SE_FW_HEADER_TOT_LEN);
 802cb4e:	f44f 72a0 	mov.w	r2, #320	; 0x140
 802cb52:	4668      	mov	r0, sp
 802cb54:	f00e f9a2 	bl	803ae9c <UTIL_MEM_cpy_8>

  /* Ask for installation at next reset */
  if (HAL_FLASH_Unlock() == HAL_OK)
 802cb58:	f001 fb6c 	bl	802e234 <HAL_FLASH_Unlock>
 802cb5c:	4602      	mov	r2, r0
 802cb5e:	bb58      	cbnz	r0, 802cbb8 <FwUpdateAgent_Run+0x74>
  uint32_t first_page = PAGE(FRAG_DECODER_SWAP_REGION_START);
 802cb60:	4d18      	ldr	r5, [pc, #96]	; (802cbc4 <FwUpdateAgent_Run+0x80>)
 802cb62:	4b19      	ldr	r3, [pc, #100]	; (802cbc8 <FwUpdateAgent_Run+0x84>)
  uint32_t nb_pages = PAGE(FRAG_DECODER_SWAP_REGION_START + SFU_IMG_IMAGE_OFFSET - 1) - first_page + 1U;
 802cb64:	f205 10ff 	addw	r0, r5, #511	; 0x1ff
  uint32_t first_page = PAGE(FRAG_DECODER_SWAP_REGION_START);
 802cb68:	ea03 2384 	and.w	r3, r3, r4, lsl #10
  uint32_t nb_pages = PAGE(FRAG_DECODER_SWAP_REGION_START + SFU_IMG_IMAGE_OFFSET - 1) - first_page + 1U;
 802cb6c:	fbb0 f1f3 	udiv	r1, r0, r3
 802cb70:	fb03 0111 	mls	r1, r3, r1, r0
 802cb74:	0ac9      	lsrs	r1, r1, #11
  uint32_t first_page = PAGE(FRAG_DECODER_SWAP_REGION_START);
 802cb76:	fbb5 f4f3 	udiv	r4, r5, r3
  uint32_t nb_pages = PAGE(FRAG_DECODER_SWAP_REGION_START + SFU_IMG_IMAGE_OFFSET - 1) - first_page + 1U;
 802cb7a:	3101      	adds	r1, #1
  uint32_t first_page = PAGE(FRAG_DECODER_SWAP_REGION_START);
 802cb7c:	fb03 5414 	mls	r4, r3, r4, r5
  uint32_t nb_pages = PAGE(FRAG_DECODER_SWAP_REGION_START + SFU_IMG_IMAGE_OFFSET - 1) - first_page + 1U;
 802cb80:	eba1 21d4 	sub.w	r1, r1, r4, lsr #11
  {
    status = FLASH_IF_EraseByPages(first_page, nb_pages, 0U);
 802cb84:	0ae0      	lsrs	r0, r4, #11
 802cb86:	b289      	uxth	r1, r1
 802cb88:	f7ff fa95 	bl	802c0b6 <FLASH_IF_EraseByPages>

    if (status == FLASH_OK)
 802cb8c:	4604      	mov	r4, r0
 802cb8e:	b940      	cbnz	r0, 802cba2 <FwUpdateAgent_Run+0x5e>
    {
      status = FLASH_IF_Write(FRAG_DECODER_SWAP_REGION_START, fw_header_dwl_slot, SE_FW_HEADER_TOT_LEN, NULL);
 802cb90:	4603      	mov	r3, r0
 802cb92:	f44f 72a0 	mov.w	r2, #320	; 0x140
 802cb96:	4669      	mov	r1, sp
 802cb98:	f105 6000 	add.w	r0, r5, #134217728	; 0x8000000
 802cb9c:	f7ff faa2 	bl	802c0e4 <FLASH_IF_Write>
 802cba0:	4604      	mov	r4, r0
    }
    HAL_FLASH_Lock();
 802cba2:	f001 fb59 	bl	802e258 <HAL_FLASH_Lock>
  else
  {
    status = FLASH_LOCK_ERROR;
  }

  if (status == FLASH_OK)
 802cba6:	b93c      	cbnz	r4, 802cbb8 <FwUpdateAgent_Run+0x74>
  {
    /* System Reboot*/
    // NVIC_SystemReset();
    APP_LOG(TS_OFF, VLEVEL_M, "Ready to install the new image at next reset\r\n");
 802cba8:	4b08      	ldr	r3, [pc, #32]	; (802cbcc <FwUpdateAgent_Run+0x88>)
  }
  else
  {
    APP_LOG(TS_OFF, VLEVEL_M, "FW Update Agent Run Failed\r\n");
 802cbaa:	2200      	movs	r2, #0
 802cbac:	4611      	mov	r1, r2
 802cbae:	2002      	movs	r0, #2
 802cbb0:	f00e f86c 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
  }
  /* USER CODE BEGIN FwUpdateAgent_Run_2 */

  /* USER CODE END FwUpdateAgent_Run_2 */
}
 802cbb4:	b051      	add	sp, #324	; 0x144
 802cbb6:	bd30      	pop	{r4, r5, pc}
    APP_LOG(TS_OFF, VLEVEL_M, "FW Update Agent Run Failed\r\n");
 802cbb8:	4b05      	ldr	r3, [pc, #20]	; (802cbd0 <FwUpdateAgent_Run+0x8c>)
 802cbba:	e7f6      	b.n	802cbaa <FwUpdateAgent_Run+0x66>
 802cbbc:	1fff75e0 	.word	0x1fff75e0
 802cbc0:	08016000 	.word	0x08016000
 802cbc4:	00015000 	.word	0x00015000
 802cbc8:	03fffc00 	.word	0x03fffc00
 802cbcc:	0803bd37 	.word	0x0803bd37
 802cbd0:	0803bd66 	.word	0x0803bd66

0802cbd4 <OnMacProcessNotify>:
static void OnMacProcessNotify(void)
{
  /* USER CODE BEGIN OnMacProcessNotify_1 */

  /* USER CODE END OnMacProcessNotify_1 */
  UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_LmHandlerProcess), CFG_SEQ_Prio_0);
 802cbd4:	2100      	movs	r1, #0
 802cbd6:	2001      	movs	r0, #1
 802cbd8:	f00e b972 	b.w	803aec0 <UTIL_SEQ_SetTask>

0802cbdc <OnClassChange>:
  if (deviceClass == CLASS_C)
 802cbdc:	2802      	cmp	r0, #2
    UTIL_TIMER_Stop(&TxTimer);
 802cbde:	4803      	ldr	r0, [pc, #12]	; (802cbec <OnClassChange+0x10>)
  if (deviceClass == CLASS_C)
 802cbe0:	d101      	bne.n	802cbe6 <OnClassChange+0xa>
    UTIL_TIMER_Stop(&TxTimer);
 802cbe2:	f00e bb75 	b.w	803b2d0 <UTIL_TIMER_Stop>
    UTIL_TIMER_Start(&TxTimer);
 802cbe6:	f00e bbc3 	b.w	803b370 <UTIL_TIMER_Start>
 802cbea:	bf00      	nop
 802cbec:	200035d8 	.word	0x200035d8

0802cbf0 <OnRxData>:
{
 802cbf0:	b530      	push	{r4, r5, lr}
 802cbf2:	460d      	mov	r5, r1
 802cbf4:	b087      	sub	sp, #28
  if ((appData != NULL) || (params != NULL))
 802cbf6:	4604      	mov	r4, r0
 802cbf8:	b908      	cbnz	r0, 802cbfe <OnRxData+0xe>
 802cbfa:	2900      	cmp	r1, #0
 802cbfc:	d057      	beq.n	802ccae <OnRxData+0xbe>
    BSP_LED_On(LED_BLUE) ;
 802cbfe:	2000      	movs	r0, #0
 802cc00:	f000 faec 	bl	802d1dc <BSP_LED_On>
    UTIL_TIMER_Start(&RxLedTimer);
 802cc04:	482b      	ldr	r0, [pc, #172]	; (802ccb4 <OnRxData+0xc4>)
 802cc06:	f00e fbb3 	bl	803b370 <UTIL_TIMER_Start>
    APP_LOG(TS_OFF, VLEVEL_M, "\r\n###### ========== MCPS-Indication ==========\r\n");
 802cc0a:	2200      	movs	r2, #0
 802cc0c:	4611      	mov	r1, r2
 802cc0e:	4b2a      	ldr	r3, [pc, #168]	; (802ccb8 <OnRxData+0xc8>)
 802cc10:	2002      	movs	r0, #2
 802cc12:	f00e f83b 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
    APP_LOG(TS_OFF, VLEVEL_H, "###### D/L FRAME:%04d | SLOT:%s | PORT:%d | DR:%d | RSSI:%d | SNR:%d\r\n",
 802cc16:	f995 3004 	ldrsb.w	r3, [r5, #4]
 802cc1a:	9305      	str	r3, [sp, #20]
 802cc1c:	f995 3003 	ldrsb.w	r3, [r5, #3]
 802cc20:	9304      	str	r3, [sp, #16]
 802cc22:	f995 3002 	ldrsb.w	r3, [r5, #2]
 802cc26:	9303      	str	r3, [sp, #12]
 802cc28:	7823      	ldrb	r3, [r4, #0]
 802cc2a:	9302      	str	r3, [sp, #8]
 802cc2c:	f995 200c 	ldrsb.w	r2, [r5, #12]
 802cc30:	4b22      	ldr	r3, [pc, #136]	; (802ccbc <OnRxData+0xcc>)
 802cc32:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 802cc36:	9301      	str	r3, [sp, #4]
 802cc38:	68ab      	ldr	r3, [r5, #8]
 802cc3a:	9300      	str	r3, [sp, #0]
 802cc3c:	2200      	movs	r2, #0
 802cc3e:	4b20      	ldr	r3, [pc, #128]	; (802ccc0 <OnRxData+0xd0>)
 802cc40:	4611      	mov	r1, r2
 802cc42:	2003      	movs	r0, #3
 802cc44:	f00e f822 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
    switch (appData->Port)
 802cc48:	7825      	ldrb	r5, [r4, #0]
 802cc4a:	2d02      	cmp	r5, #2
 802cc4c:	d010      	beq.n	802cc70 <OnRxData+0x80>
 802cc4e:	2d03      	cmp	r5, #3
 802cc50:	d12d      	bne.n	802ccae <OnRxData+0xbe>
        if (appData->BufferSize == 1)
 802cc52:	7863      	ldrb	r3, [r4, #1]
 802cc54:	2b01      	cmp	r3, #1
 802cc56:	d12a      	bne.n	802ccae <OnRxData+0xbe>
          switch (appData->Buffer[0])
 802cc58:	6863      	ldr	r3, [r4, #4]
 802cc5a:	7818      	ldrb	r0, [r3, #0]
 802cc5c:	2801      	cmp	r0, #1
 802cc5e:	d002      	beq.n	802cc66 <OnRxData+0x76>
 802cc60:	2802      	cmp	r0, #2
 802cc62:	d000      	beq.n	802cc66 <OnRxData+0x76>
 802cc64:	bb18      	cbnz	r0, 802ccae <OnRxData+0xbe>
}
 802cc66:	b007      	add	sp, #28
 802cc68:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
              LmHandlerRequestClass(CLASS_C);
 802cc6c:	f004 bc82 	b.w	8031574 <LmHandlerRequestClass>
        if (appData->BufferSize == 1)
 802cc70:	7863      	ldrb	r3, [r4, #1]
 802cc72:	2b01      	cmp	r3, #1
 802cc74:	d11b      	bne.n	802ccae <OnRxData+0xbe>
          AppLedStateOn = appData->Buffer[0] & 0x01;
 802cc76:	6863      	ldr	r3, [r4, #4]
 802cc78:	781a      	ldrb	r2, [r3, #0]
          if (AppLedStateOn == RESET)
 802cc7a:	f012 0201 	ands.w	r2, r2, #1
 802cc7e:	d10a      	bne.n	802cc96 <OnRxData+0xa6>
            APP_LOG(TS_OFF, VLEVEL_H,   "LED OFF\r\n");
 802cc80:	4b10      	ldr	r3, [pc, #64]	; (802ccc4 <OnRxData+0xd4>)
 802cc82:	4611      	mov	r1, r2
 802cc84:	2003      	movs	r0, #3
 802cc86:	f00e f801 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
            BSP_LED_Off(LED_RED) ;
 802cc8a:	4628      	mov	r0, r5
}
 802cc8c:	b007      	add	sp, #28
 802cc8e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
            BSP_LED_Off(LED_RED) ;
 802cc92:	f000 bab1 	b.w	802d1f8 <BSP_LED_Off>
            APP_LOG(TS_OFF, VLEVEL_H, "LED ON\r\n");
 802cc96:	2200      	movs	r2, #0
 802cc98:	4b0b      	ldr	r3, [pc, #44]	; (802ccc8 <OnRxData+0xd8>)
 802cc9a:	4611      	mov	r1, r2
 802cc9c:	2003      	movs	r0, #3
 802cc9e:	f00d fff5 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
            BSP_LED_On(LED_RED) ;
 802cca2:	4628      	mov	r0, r5
}
 802cca4:	b007      	add	sp, #28
 802cca6:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
            BSP_LED_On(LED_RED) ;
 802ccaa:	f000 ba97 	b.w	802d1dc <BSP_LED_On>
}
 802ccae:	b007      	add	sp, #28
 802ccb0:	bd30      	pop	{r4, r5, pc}
 802ccb2:	bf00      	nop
 802ccb4:	200035f0 	.word	0x200035f0
 802ccb8:	0803bd83 	.word	0x0803bd83
 802ccbc:	0803b8d8 	.word	0x0803b8d8
 802ccc0:	0803bdb4 	.word	0x0803bdb4
 802ccc4:	0803bdfb 	.word	0x0803bdfb
 802ccc8:	0803be05 	.word	0x0803be05

0802cccc <OnRxTimerLedEvent>:
  BSP_LED_Off(LED_BLUE) ;
 802cccc:	2000      	movs	r0, #0
 802ccce:	f000 ba93 	b.w	802d1f8 <BSP_LED_Off>

0802ccd2 <OnTxTimerLedEvent>:
  BSP_LED_Off(LED_GREEN) ;
 802ccd2:	2001      	movs	r0, #1
 802ccd4:	f000 ba90 	b.w	802d1f8 <BSP_LED_Off>

0802ccd8 <OnJoinTimerLedEvent>:
  BSP_LED_Toggle(LED_RED) ;
 802ccd8:	2002      	movs	r0, #2
 802ccda:	f000 ba9b 	b.w	802d214 <BSP_LED_Toggle>
	...

0802cce0 <OnTxData>:
{
 802cce0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  if ((params != NULL))
 802cce2:	4604      	mov	r4, r0
 802cce4:	2800      	cmp	r0, #0
 802cce6:	d034      	beq.n	802cd52 <OnTxData+0x72>
    if (params->IsMcpsConfirm != 0)
 802cce8:	7803      	ldrb	r3, [r0, #0]
 802ccea:	2b00      	cmp	r3, #0
 802ccec:	d031      	beq.n	802cd52 <OnTxData+0x72>
      BSP_LED_On(LED_GREEN) ;
 802ccee:	2001      	movs	r0, #1
 802ccf0:	f000 fa74 	bl	802d1dc <BSP_LED_On>
      UTIL_TIMER_Start(&TxLedTimer);
 802ccf4:	481c      	ldr	r0, [pc, #112]	; (802cd68 <OnTxData+0x88>)
 802ccf6:	f00e fb3b 	bl	803b370 <UTIL_TIMER_Start>
      APP_LOG(TS_OFF, VLEVEL_M, "\r\n###### ========== MCPS-Confirm =============\r\n");
 802ccfa:	2200      	movs	r2, #0
 802ccfc:	4611      	mov	r1, r2
 802ccfe:	4b1b      	ldr	r3, [pc, #108]	; (802cd6c <OnTxData+0x8c>)
 802cd00:	2002      	movs	r0, #2
 802cd02:	f00d ffc3 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
      APP_LOG(TS_OFF, VLEVEL_H, "###### U/L FRAME:%04d | PORT:%d | DR:%d | PWR:%d", params->UplinkCounter,
 802cd06:	f994 3014 	ldrsb.w	r3, [r4, #20]
 802cd0a:	9303      	str	r3, [sp, #12]
 802cd0c:	f994 3004 	ldrsb.w	r3, [r4, #4]
 802cd10:	9302      	str	r3, [sp, #8]
 802cd12:	7b23      	ldrb	r3, [r4, #12]
 802cd14:	9301      	str	r3, [sp, #4]
 802cd16:	68a3      	ldr	r3, [r4, #8]
 802cd18:	9300      	str	r3, [sp, #0]
 802cd1a:	2200      	movs	r2, #0
 802cd1c:	4611      	mov	r1, r2
 802cd1e:	4b14      	ldr	r3, [pc, #80]	; (802cd70 <OnTxData+0x90>)
 802cd20:	2003      	movs	r0, #3
 802cd22:	f00d ffb3 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
      APP_LOG(TS_OFF, VLEVEL_H, " | MSG TYPE:");
 802cd26:	2200      	movs	r2, #0
 802cd28:	4b12      	ldr	r3, [pc, #72]	; (802cd74 <OnTxData+0x94>)
 802cd2a:	4611      	mov	r1, r2
 802cd2c:	2003      	movs	r0, #3
 802cd2e:	f00d ffad 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
      if (params->MsgType == LORAMAC_HANDLER_CONFIRMED_MSG)
 802cd32:	78a3      	ldrb	r3, [r4, #2]
 802cd34:	2b01      	cmp	r3, #1
 802cd36:	d10e      	bne.n	802cd56 <OnTxData+0x76>
        APP_LOG(TS_OFF, VLEVEL_H, "CONFIRMED [%s]\r\n", (params->AckReceived != 0) ? "ACK" : "NACK");
 802cd38:	78e1      	ldrb	r1, [r4, #3]
 802cd3a:	4a0f      	ldr	r2, [pc, #60]	; (802cd78 <OnTxData+0x98>)
 802cd3c:	4b0f      	ldr	r3, [pc, #60]	; (802cd7c <OnTxData+0x9c>)
 802cd3e:	2900      	cmp	r1, #0
 802cd40:	bf08      	it	eq
 802cd42:	4613      	moveq	r3, r2
 802cd44:	2200      	movs	r2, #0
 802cd46:	9300      	str	r3, [sp, #0]
 802cd48:	4611      	mov	r1, r2
 802cd4a:	4b0d      	ldr	r3, [pc, #52]	; (802cd80 <OnTxData+0xa0>)
 802cd4c:	2003      	movs	r0, #3
 802cd4e:	f00d ff9d 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
}
 802cd52:	b004      	add	sp, #16
 802cd54:	bd10      	pop	{r4, pc}
        APP_LOG(TS_OFF, VLEVEL_H, "UNCONFIRMED\r\n");
 802cd56:	2200      	movs	r2, #0
 802cd58:	4b0a      	ldr	r3, [pc, #40]	; (802cd84 <OnTxData+0xa4>)
 802cd5a:	4611      	mov	r1, r2
 802cd5c:	2003      	movs	r0, #3
}
 802cd5e:	b004      	add	sp, #16
 802cd60:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        APP_LOG(TS_OFF, VLEVEL_H, "UNCONFIRMED\r\n");
 802cd64:	f00d bf92 	b.w	803ac8c <UTIL_ADV_TRACE_COND_FSend>
 802cd68:	20003608 	.word	0x20003608
 802cd6c:	0803be13 	.word	0x0803be13
 802cd70:	0803be44 	.word	0x0803be44
 802cd74:	0803be75 	.word	0x0803be75
 802cd78:	0803be0e 	.word	0x0803be0e
 802cd7c:	0803be0f 	.word	0x0803be0f
 802cd80:	0803be82 	.word	0x0803be82
 802cd84:	0803be93 	.word	0x0803be93

0802cd88 <OnJoinRequest>:
{
 802cd88:	b570      	push	{r4, r5, r6, lr}
  if (joinParams != NULL)
 802cd8a:	4605      	mov	r5, r0
 802cd8c:	b320      	cbz	r0, 802cdd8 <OnJoinRequest+0x50>
    if (joinParams->Status == LORAMAC_HANDLER_SUCCESS)
 802cd8e:	f990 4001 	ldrsb.w	r4, [r0, #1]
 802cd92:	b9cc      	cbnz	r4, 802cdc8 <OnJoinRequest+0x40>
      UTIL_TIMER_Stop(&JoinLedTimer);
 802cd94:	4811      	ldr	r0, [pc, #68]	; (802cddc <OnJoinRequest+0x54>)
 802cd96:	f00e fa9b 	bl	803b2d0 <UTIL_TIMER_Stop>
      BSP_LED_Off(LED_RED) ;
 802cd9a:	2002      	movs	r0, #2
 802cd9c:	f000 fa2c 	bl	802d1f8 <BSP_LED_Off>
      APP_LOG(TS_OFF, VLEVEL_M, "\r\n###### = JOINED = ");
 802cda0:	4622      	mov	r2, r4
 802cda2:	4621      	mov	r1, r4
 802cda4:	4b0e      	ldr	r3, [pc, #56]	; (802cde0 <OnJoinRequest+0x58>)
 802cda6:	2002      	movs	r0, #2
 802cda8:	f00d ff70 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
      if (joinParams->Mode == ACTIVATION_TYPE_ABP)
 802cdac:	78ab      	ldrb	r3, [r5, #2]
 802cdae:	2b01      	cmp	r3, #1
        APP_LOG(TS_OFF, VLEVEL_M, "OTAA =====================\r\n");
 802cdb0:	4622      	mov	r2, r4
 802cdb2:	4621      	mov	r1, r4
        APP_LOG(TS_OFF, VLEVEL_M, "ABP ======================\r\n");
 802cdb4:	bf0c      	ite	eq
 802cdb6:	4b0b      	ldreq	r3, [pc, #44]	; (802cde4 <OnJoinRequest+0x5c>)
        APP_LOG(TS_OFF, VLEVEL_M, "OTAA =====================\r\n");
 802cdb8:	4b0b      	ldrne	r3, [pc, #44]	; (802cde8 <OnJoinRequest+0x60>)
 802cdba:	2002      	movs	r0, #2
 802cdbc:	f00d ff66 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
}
 802cdc0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      LmHandlerDeviceTimeReq();
 802cdc4:	f004 ba98 	b.w	80312f8 <LmHandlerDeviceTimeReq>
      APP_LOG(TS_OFF, VLEVEL_M, "\r\n###### = JOIN FAILED\r\n");
 802cdc8:	2200      	movs	r2, #0
}
 802cdca:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      APP_LOG(TS_OFF, VLEVEL_M, "\r\n###### = JOIN FAILED\r\n");
 802cdce:	4b07      	ldr	r3, [pc, #28]	; (802cdec <OnJoinRequest+0x64>)
 802cdd0:	4611      	mov	r1, r2
 802cdd2:	2002      	movs	r0, #2
 802cdd4:	f00d bf5a 	b.w	803ac8c <UTIL_ADV_TRACE_COND_FSend>
}
 802cdd8:	bd70      	pop	{r4, r5, r6, pc}
 802cdda:	bf00      	nop
 802cddc:	20003620 	.word	0x20003620
 802cde0:	0803bea1 	.word	0x0803bea1
 802cde4:	0803beb6 	.word	0x0803beb6
 802cde8:	0803bed3 	.word	0x0803bed3
 802cdec:	0803bef0 	.word	0x0803bef0

0802cdf0 <SendTxData>:
{
 802cdf0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  AppData.Port = LORAWAN_USER_APP_PORT;
 802cdf2:	4814      	ldr	r0, [pc, #80]	; (802ce44 <SendTxData+0x54>)
  AppData.Buffer[j++] = 0;
 802cdf4:	6842      	ldr	r2, [r0, #4]
  UTIL_TIMER_Time_t nextTxIn = 0;
 802cdf6:	2400      	movs	r4, #0
  AppData.Port = LORAWAN_USER_APP_PORT;
 802cdf8:	2302      	movs	r3, #2
  UTIL_TIMER_Time_t nextTxIn = 0;
 802cdfa:	9403      	str	r4, [sp, #12]
  AppData.Port = LORAWAN_USER_APP_PORT;
 802cdfc:	7003      	strb	r3, [r0, #0]
  AppData.Buffer[j++] = 0;
 802cdfe:	7014      	strb	r4, [r2, #0]
  AppData.Buffer[j++] = 3;
 802ce00:	6842      	ldr	r2, [r0, #4]
 802ce02:	2103      	movs	r1, #3
 802ce04:	7051      	strb	r1, [r2, #1]
  AppData.BufferSize = j;
 802ce06:	7043      	strb	r3, [r0, #1]
  if (LORAMAC_HANDLER_SUCCESS == LmHandlerSend(&AppData, LORAWAN_DEFAULT_CONFIRMED_MSG_STATE, &nextTxIn, false))
 802ce08:	4621      	mov	r1, r4
 802ce0a:	4623      	mov	r3, r4
 802ce0c:	aa03      	add	r2, sp, #12
 802ce0e:	f004 fc71 	bl	80316f4 <LmHandlerSend>
 802ce12:	4601      	mov	r1, r0
 802ce14:	b930      	cbnz	r0, 802ce24 <SendTxData+0x34>
    APP_LOG(TS_ON, VLEVEL_L, "SEND REQUEST\r\n");
 802ce16:	2201      	movs	r2, #1
 802ce18:	4b0b      	ldr	r3, [pc, #44]	; (802ce48 <SendTxData+0x58>)
 802ce1a:	4610      	mov	r0, r2
 802ce1c:	f00d ff36 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
}
 802ce20:	b004      	add	sp, #16
 802ce22:	bd10      	pop	{r4, pc}
  else if (nextTxIn > 0)
 802ce24:	9b03      	ldr	r3, [sp, #12]
 802ce26:	2b00      	cmp	r3, #0
 802ce28:	d0fa      	beq.n	802ce20 <SendTxData+0x30>
    APP_LOG(TS_ON, VLEVEL_L, "Next Tx in  : ~%d second(s)\r\n", (nextTxIn / 1000));
 802ce2a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 802ce2e:	fbb3 f3f2 	udiv	r3, r3, r2
 802ce32:	2201      	movs	r2, #1
 802ce34:	9300      	str	r3, [sp, #0]
 802ce36:	4621      	mov	r1, r4
 802ce38:	4b04      	ldr	r3, [pc, #16]	; (802ce4c <SendTxData+0x5c>)
 802ce3a:	4610      	mov	r0, r2
 802ce3c:	f00d ff26 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
}
 802ce40:	e7ee      	b.n	802ce20 <SendTxData+0x30>
 802ce42:	bf00      	nop
 802ce44:	20003400 	.word	0x20003400
 802ce48:	0803bf09 	.word	0x0803bf09
 802ce4c:	0803bf18 	.word	0x0803bf18

0802ce50 <LoRaWAN_Init>:
{
 802ce50:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  BSP_LED_Init(LED_BLUE);
 802ce54:	2000      	movs	r0, #0
{
 802ce56:	b085      	sub	sp, #20
  BSP_LED_Init(LED_BLUE);
 802ce58:	f000 f99a 	bl	802d190 <BSP_LED_Init>
  BSP_LED_Init(LED_GREEN);
 802ce5c:	2001      	movs	r0, #1
 802ce5e:	f000 f997 	bl	802d190 <BSP_LED_Init>
  BSP_LED_Init(LED_RED);
 802ce62:	2002      	movs	r0, #2
 802ce64:	f000 f994 	bl	802d190 <BSP_LED_Init>
  BSP_PB_Init(BUTTON_SW2, BUTTON_MODE_EXTI);
 802ce68:	2101      	movs	r1, #1
 802ce6a:	4608      	mov	r0, r1
 802ce6c:	f000 f9e0 	bl	802d230 <BSP_PB_Init>
  APP_LOG(TS_OFF, VLEVEL_M, "APP_VERSION:        V%X.%X.%X\r\n",
 802ce70:	2501      	movs	r5, #1
 802ce72:	2603      	movs	r6, #3
 802ce74:	2200      	movs	r2, #0
  APP_LOG(TS_OFF, VLEVEL_M, "MW_LORAWAN_VERSION: V%X.%X.%X\r\n",
 802ce76:	2400      	movs	r4, #0
  APP_LOG(TS_OFF, VLEVEL_M, "APP_VERSION:        V%X.%X.%X\r\n",
 802ce78:	e9cd 5601 	strd	r5, r6, [sp, #4]
 802ce7c:	4611      	mov	r1, r2
 802ce7e:	4b34      	ldr	r3, [pc, #208]	; (802cf50 <LoRaWAN_Init+0x100>)
 802ce80:	9500      	str	r5, [sp, #0]
 802ce82:	2002      	movs	r0, #2
 802ce84:	f00d ff02 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
  APP_LOG(TS_OFF, VLEVEL_M, "MW_LORAWAN_VERSION: V%X.%X.%X\r\n",
 802ce88:	2702      	movs	r7, #2
 802ce8a:	e9cd 6401 	strd	r6, r4, [sp, #4]
  UTIL_TIMER_Create(&TxLedTimer, 0xFFFFFFFFU, UTIL_TIMER_ONESHOT, OnTxTimerLedEvent, NULL);
 802ce8e:	4e31      	ldr	r6, [pc, #196]	; (802cf54 <LoRaWAN_Init+0x104>)
  APP_LOG(TS_OFF, VLEVEL_M, "MW_LORAWAN_VERSION: V%X.%X.%X\r\n",
 802ce90:	4b31      	ldr	r3, [pc, #196]	; (802cf58 <LoRaWAN_Init+0x108>)
 802ce92:	9700      	str	r7, [sp, #0]
 802ce94:	4622      	mov	r2, r4
 802ce96:	4621      	mov	r1, r4
 802ce98:	4638      	mov	r0, r7
 802ce9a:	f00d fef7 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
  UTIL_TIMER_Create(&TxLedTimer, 0xFFFFFFFFU, UTIL_TIMER_ONESHOT, OnTxTimerLedEvent, NULL);
 802ce9e:	f106 0930 	add.w	r9, r6, #48	; 0x30
  APP_LOG(TS_OFF, VLEVEL_M, "MW_RADIO_VERSION:   V%X.%X.%X\r\n",
 802cea2:	4622      	mov	r2, r4
 802cea4:	4621      	mov	r1, r4
 802cea6:	e9cd 5401 	strd	r5, r4, [sp, #4]
 802ceaa:	4b2c      	ldr	r3, [pc, #176]	; (802cf5c <LoRaWAN_Init+0x10c>)
 802ceac:	9500      	str	r5, [sp, #0]
 802ceae:	4638      	mov	r0, r7
 802ceb0:	f00d feec 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
  UTIL_TIMER_Create(&RxLedTimer, 0xFFFFFFFFU, UTIL_TIMER_ONESHOT, OnRxTimerLedEvent, NULL);
 802ceb4:	f106 0818 	add.w	r8, r6, #24
  UTIL_TIMER_Create(&TxLedTimer, 0xFFFFFFFFU, UTIL_TIMER_ONESHOT, OnTxTimerLedEvent, NULL);
 802ceb8:	4622      	mov	r2, r4
 802ceba:	4b29      	ldr	r3, [pc, #164]	; (802cf60 <LoRaWAN_Init+0x110>)
 802cebc:	9400      	str	r4, [sp, #0]
 802cebe:	f04f 31ff 	mov.w	r1, #4294967295
 802cec2:	4648      	mov	r0, r9
 802cec4:	f00e f9a6 	bl	803b214 <UTIL_TIMER_Create>
  UTIL_TIMER_Create(&JoinLedTimer, 0xFFFFFFFFU, UTIL_TIMER_PERIODIC, OnJoinTimerLedEvent, NULL);
 802cec8:	3648      	adds	r6, #72	; 0x48
  UTIL_TIMER_Create(&RxLedTimer, 0xFFFFFFFFU, UTIL_TIMER_ONESHOT, OnRxTimerLedEvent, NULL);
 802ceca:	4622      	mov	r2, r4
 802cecc:	4b25      	ldr	r3, [pc, #148]	; (802cf64 <LoRaWAN_Init+0x114>)
 802cece:	9400      	str	r4, [sp, #0]
 802ced0:	f04f 31ff 	mov.w	r1, #4294967295
 802ced4:	4640      	mov	r0, r8
 802ced6:	f00e f99d 	bl	803b214 <UTIL_TIMER_Create>
  UTIL_TIMER_Create(&JoinLedTimer, 0xFFFFFFFFU, UTIL_TIMER_PERIODIC, OnJoinTimerLedEvent, NULL);
 802ceda:	4b23      	ldr	r3, [pc, #140]	; (802cf68 <LoRaWAN_Init+0x118>)
 802cedc:	9400      	str	r4, [sp, #0]
 802cede:	462a      	mov	r2, r5
 802cee0:	f04f 31ff 	mov.w	r1, #4294967295
 802cee4:	4630      	mov	r0, r6
 802cee6:	f00e f995 	bl	803b214 <UTIL_TIMER_Create>
  UTIL_TIMER_SetPeriod(&TxLedTimer, 500);
 802ceea:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 802ceee:	4648      	mov	r0, r9
 802cef0:	f00e fa78 	bl	803b3e4 <UTIL_TIMER_SetPeriod>
  UTIL_TIMER_SetPeriod(&RxLedTimer, 500);
 802cef4:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 802cef8:	4640      	mov	r0, r8
 802cefa:	f00e fa73 	bl	803b3e4 <UTIL_TIMER_SetPeriod>
  UTIL_TIMER_SetPeriod(&JoinLedTimer, 500);
 802cefe:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 802cf02:	4630      	mov	r0, r6
 802cf04:	f00e fa6e 	bl	803b3e4 <UTIL_TIMER_SetPeriod>
  LmHandlerInit(&LmHandlerCallbacks);
 802cf08:	f8df 8068 	ldr.w	r8, [pc, #104]	; 802cf74 <LoRaWAN_Init+0x124>
  UTIL_SEQ_RegTask((1 << CFG_SEQ_Task_LmHandlerProcess), UTIL_SEQ_RFU, LmHandlerProcess);
 802cf0c:	4a17      	ldr	r2, [pc, #92]	; (802cf6c <LoRaWAN_Init+0x11c>)
 802cf0e:	4621      	mov	r1, r4
 802cf10:	4628      	mov	r0, r5
 802cf12:	f00e f87f 	bl	803b014 <UTIL_SEQ_RegTask>
  UTIL_SEQ_RegTask((1 << CFG_SEQ_Task_LoRaSendOnTxTimerOrButtonEvent), UTIL_SEQ_RFU, SendTxData);
 802cf16:	4621      	mov	r1, r4
 802cf18:	4a15      	ldr	r2, [pc, #84]	; (802cf70 <LoRaWAN_Init+0x120>)
 802cf1a:	4638      	mov	r0, r7
 802cf1c:	f00e f87a 	bl	803b014 <UTIL_SEQ_RegTask>
  LoraInfo_Init();
 802cf20:	f000 f832 	bl	802cf88 <LoraInfo_Init>
  LmHandlerInit(&LmHandlerCallbacks);
 802cf24:	f108 0008 	add.w	r0, r8, #8
 802cf28:	f004 fd96 	bl	8031a58 <LmHandlerInit>
  LmHandlerConfigure(&LmHandlerParams);
 802cf2c:	f108 003c 	add.w	r0, r8, #60	; 0x3c
 802cf30:	f004 fa16 	bl	8031360 <LmHandlerConfigure>
  UTIL_TIMER_Start(&JoinLedTimer);
 802cf34:	4630      	mov	r0, r6
 802cf36:	f00e fa1b 	bl	803b370 <UTIL_TIMER_Start>
  LmHandlerJoin(ActivationType);
 802cf3a:	4638      	mov	r0, r7
 802cf3c:	f004 fb78 	bl	8031630 <LmHandlerJoin>
    BSP_PB_Init(BUTTON_SW1, BUTTON_MODE_EXTI);
 802cf40:	4629      	mov	r1, r5
 802cf42:	4620      	mov	r0, r4
}
 802cf44:	b005      	add	sp, #20
 802cf46:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    BSP_PB_Init(BUTTON_SW1, BUTTON_MODE_EXTI);
 802cf4a:	f000 b971 	b.w	802d230 <BSP_PB_Init>
 802cf4e:	bf00      	nop
 802cf50:	0803bf36 	.word	0x0803bf36
 802cf54:	200035d8 	.word	0x200035d8
 802cf58:	0803bf56 	.word	0x0803bf56
 802cf5c:	0803bf76 	.word	0x0803bf76
 802cf60:	0802ccd3 	.word	0x0802ccd3
 802cf64:	0802cccd 	.word	0x0802cccd
 802cf68:	0802ccd9 	.word	0x0802ccd9
 802cf6c:	08031511 	.word	0x08031511
 802cf70:	0802cdf1 	.word	0x0802cdf1
 802cf74:	20003400 	.word	0x20003400

0802cf78 <HAL_GPIO_EXTI_Callback>:
  switch (GPIO_Pin)
 802cf78:	2801      	cmp	r0, #1
 802cf7a:	d103      	bne.n	802cf84 <HAL_GPIO_EXTI_Callback+0xc>
      UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_LoRaSendOnTxTimerOrButtonEvent), CFG_SEQ_Prio_0);
 802cf7c:	2100      	movs	r1, #0
 802cf7e:	2002      	movs	r0, #2
 802cf80:	f00d bf9e 	b.w	803aec0 <UTIL_SEQ_SetTask>
}
 802cf84:	4770      	bx	lr
	...

0802cf88 <LoraInfo_Init>:
/* Exported functions --------------------------------------------------------*/
void LoraInfo_Init(void)
{
  loraInfo.ActivationMode = 0;
  loraInfo.Region = 0;
  loraInfo.ClassB = 0;
 802cf88:	4b05      	ldr	r3, [pc, #20]	; (802cfa0 <LoraInfo_Init+0x18>)
#endif /* REGION_KR920 */
#ifdef  REGION_IN865
  loraInfo.Region |= (1 << LORAMAC_REGION_IN865) ;
#endif /* REGION_IN865 */
#ifdef  REGION_US915
  loraInfo.Region |= (1 << LORAMAC_REGION_US915) ;
 802cf8a:	f44f 7290 	mov.w	r2, #288	; 0x120
 802cf8e:	2100      	movs	r1, #0
 802cf90:	e9c3 2101 	strd	r2, r1, [r3, #4]

#if (!defined (LORAWAN_KMS) || (LORAWAN_KMS == 0))
  loraInfo.Kms = 0;
  loraInfo.ActivationMode = 3;
#else /* LORAWAN_KMS == 1 */
  loraInfo.Kms = 1;
 802cf94:	2201      	movs	r2, #1
 802cf96:	60da      	str	r2, [r3, #12]
  loraInfo.ActivationMode = ACTIVATION_BY_PERSONALIZATION + (OVER_THE_AIR_ACTIVATION << 1);
 802cf98:	2203      	movs	r2, #3
 802cf9a:	601a      	str	r2, [r3, #0]
#endif /* LORAWAN_KMS */
  /* USER CODE BEGIN LoraInfo_Init_2 */

  /* USER CODE END LoraInfo_Init_2 */
}
 802cf9c:	4770      	bx	lr
 802cf9e:	bf00      	nop
 802cfa0:	2000372c 	.word	0x2000372c

0802cfa4 <LoraInfo_GetPtr>:
{
  /* USER CODE BEGIN LoraInfo_GetPtr */

  /* USER CODE END LoraInfo_GetPtr */
  return &loraInfo;
}
 802cfa4:	4800      	ldr	r0, [pc, #0]	; (802cfa8 <LoraInfo_GetPtr+0x4>)
 802cfa6:	4770      	bx	lr
 802cfa8:	2000372c 	.word	0x2000372c

0802cfac <FRAG_DECODER_IF_Erase>:

/* USER CODE END PFP */

/* Exported functions --------------------------------------------------------*/
int32_t FRAG_DECODER_IF_Erase(void)
{
 802cfac:	b538      	push	{r3, r4, r5, lr}
  /* USER CODE END FRAG_DECODER_IF_Erase_1 */
  int32_t status = FLASH_OK;
#if (INTEROP_TEST_MODE == 1)
  UTIL_MEM_set_8(UnfragmentedData, 0xFF, UNFRAGMENTED_DATA_SIZE);
#else /* INTEROP_TEST_MODE == 0 */
  uint32_t first_page = PAGE(FRAG_DECODER_DWL_REGION_START);
 802cfae:	4b16      	ldr	r3, [pc, #88]	; (802d008 <FRAG_DECODER_IF_Erase+0x5c>)
 802cfb0:	4c16      	ldr	r4, [pc, #88]	; (802d00c <FRAG_DECODER_IF_Erase+0x60>)
 802cfb2:	681b      	ldr	r3, [r3, #0]
 802cfb4:	4a16      	ldr	r2, [pc, #88]	; (802d010 <FRAG_DECODER_IF_Erase+0x64>)
 802cfb6:	ea04 2383 	and.w	r3, r4, r3, lsl #10
 802cfba:	6894      	ldr	r4, [r2, #8]
  uint32_t nb_pages = PAGE(FRAG_DECODER_DWL_REGION_START + FRAG_DECODER_DWL_REGION_SIZE - 1) - first_page + 1U;
 802cfbc:	4a15      	ldr	r2, [pc, #84]	; (802d014 <FRAG_DECODER_IF_Erase+0x68>)
  uint32_t first_page = PAGE(FRAG_DECODER_DWL_REGION_START);
 802cfbe:	f104 4478 	add.w	r4, r4, #4160749568	; 0xf8000000
 802cfc2:	fbb4 f1f3 	udiv	r1, r4, r3
 802cfc6:	fb03 4111 	mls	r1, r3, r1, r4
  uint32_t nb_pages = PAGE(FRAG_DECODER_DWL_REGION_START + FRAG_DECODER_DWL_REGION_SIZE - 1) - first_page + 1U;
 802cfca:	6894      	ldr	r4, [r2, #8]
 802cfcc:	f104 4278 	add.w	r2, r4, #4160749568	; 0xf8000000
 802cfd0:	fbb2 f4f3 	udiv	r4, r2, r3
 802cfd4:	fb03 2414 	mls	r4, r3, r4, r2
 802cfd8:	0ae4      	lsrs	r4, r4, #11
 802cfda:	3401      	adds	r4, #1
  uint32_t first_page = PAGE(FRAG_DECODER_DWL_REGION_START);
 802cfdc:	0acd      	lsrs	r5, r1, #11
  uint32_t nb_pages = PAGE(FRAG_DECODER_DWL_REGION_START + FRAG_DECODER_DWL_REGION_SIZE - 1) - first_page + 1U;
 802cfde:	eba4 24d1 	sub.w	r4, r4, r1, lsr #11

  if (HAL_FLASH_Unlock() == HAL_OK)
 802cfe2:	f001 f927 	bl	802e234 <HAL_FLASH_Unlock>
 802cfe6:	4602      	mov	r2, r0
 802cfe8:	b958      	cbnz	r0, 802d002 <FRAG_DECODER_IF_Erase+0x56>
  {
    status = FLASH_IF_EraseByPages(first_page, nb_pages, 0U);
 802cfea:	b2a1      	uxth	r1, r4
 802cfec:	4628      	mov	r0, r5
 802cfee:	f7ff f862 	bl	802c0b6 <FLASH_IF_EraseByPages>
 802cff2:	4604      	mov	r4, r0
    /* Lock the Flash to disable the flash control register access (recommended
    to protect the FLASH memory against possible unwanted operation) *********/
    HAL_FLASH_Lock();
 802cff4:	f001 f930 	bl	802e258 <HAL_FLASH_Lock>
  {
    status = FLASH_LOCK_ERROR;
  }

#endif /* INTEROP_TEST_MODE */
  if (status != FLASH_OK)
 802cff8:	1e20      	subs	r0, r4, #0
 802cffa:	bf18      	it	ne
 802cffc:	2001      	movne	r0, #1
 802cffe:	4240      	negs	r0, r0
  }
  return status;
  /* USER CODE BEGIN FRAG_DECODER_IF_Erase_2 */

  /* USER CODE END FRAG_DECODER_IF_Erase_2 */
}
 802d000:	bd38      	pop	{r3, r4, r5, pc}
    status = FLASH_ERROR;
 802d002:	f04f 30ff 	mov.w	r0, #4294967295
  return status;
 802d006:	e7fb      	b.n	802d000 <FRAG_DECODER_IF_Erase+0x54>
 802d008:	1fff75e0 	.word	0x1fff75e0
 802d00c:	03fffc00 	.word	0x03fffc00
 802d010:	0803b8b8 	.word	0x0803b8b8
 802d014:	0803b8a8 	.word	0x0803b8a8

0802d018 <FRAG_DECODER_IF_Write>:

int32_t FRAG_DECODER_IF_Write(uint32_t addr, uint8_t *data, uint32_t size)
{
 802d018:	b573      	push	{r0, r1, r4, r5, r6, lr}
 802d01a:	4604      	mov	r4, r0
 802d01c:	460d      	mov	r5, r1
 802d01e:	4616      	mov	r6, r2

#if (INTEROP_TEST_MODE == 1)  /*write fragment in RAM - Caching mode*/
  UTIL_MEM_cpy_8(&UnfragmentedData[addr], data, size);
#else /* INTEROP_TEST_MODE == 0 */

  if (HAL_FLASH_Unlock() == HAL_OK)
 802d020:	f001 f908 	bl	802e234 <HAL_FLASH_Unlock>
 802d024:	b9b8      	cbnz	r0, 802d056 <FRAG_DECODER_IF_Write+0x3e>
  {
    status = FLASH_IF_Write(FRAG_DECODER_DWL_REGION_START + addr, data, size, FRAG_DECODER_IF_RAM_buffer);
 802d026:	480d      	ldr	r0, [pc, #52]	; (802d05c <FRAG_DECODER_IF_Write+0x44>)
 802d028:	4b0d      	ldr	r3, [pc, #52]	; (802d060 <FRAG_DECODER_IF_Write+0x48>)
 802d02a:	6880      	ldr	r0, [r0, #8]
 802d02c:	4632      	mov	r2, r6
 802d02e:	4420      	add	r0, r4
 802d030:	4629      	mov	r1, r5
 802d032:	f7ff f857 	bl	802c0e4 <FLASH_IF_Write>
 802d036:	4604      	mov	r4, r0
    HAL_FLASH_Lock();
 802d038:	f001 f90e 	bl	802e258 <HAL_FLASH_Lock>
  else
  {
    status = FLASH_LOCK_ERROR;
  }

  if (status != FLASH_OK)
 802d03c:	b144      	cbz	r4, 802d050 <FRAG_DECODER_IF_Write+0x38>
  {
    APP_LOG(TS_OFF, VLEVEL_M, "\r\n....... !! FLASH_IF_WRITE_ERROR: %d !! .......\r\n", status);
 802d03e:	2200      	movs	r2, #0
 802d040:	9400      	str	r4, [sp, #0]
 802d042:	4b08      	ldr	r3, [pc, #32]	; (802d064 <FRAG_DECODER_IF_Write+0x4c>)
 802d044:	4611      	mov	r1, r2
 802d046:	2002      	movs	r0, #2
 802d048:	f00d fe20 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
  }
#endif /* INTEROP_TEST_MODE */
  if (status != FLASH_OK)
  {
    status = FLASH_ERROR;
 802d04c:	f04f 34ff 	mov.w	r4, #4294967295
  }
  return status;
  /* USER CODE BEGIN FRAG_DECODER_IF_Write_2 */

  /* USER CODE END FRAG_DECODER_IF_Write_2 */
}
 802d050:	4620      	mov	r0, r4
 802d052:	b002      	add	sp, #8
 802d054:	bd70      	pop	{r4, r5, r6, pc}
    status = FLASH_LOCK_ERROR;
 802d056:	f06f 0403 	mvn.w	r4, #3
 802d05a:	e7f0      	b.n	802d03e <FRAG_DECODER_IF_Write+0x26>
 802d05c:	0803b8b8 	.word	0x0803b8b8
 802d060:	2000373c 	.word	0x2000373c
 802d064:	0803bfc8 	.word	0x0803bfc8

0802d068 <FRAG_DECODER_IF_OnProgress>:

  /* USER CODE END FRAG_DECODER_IF_Read_2 */
}

void FRAG_DECODER_IF_OnProgress(uint16_t fragCounter, uint16_t fragNb, uint8_t fragSize, uint16_t fragNbLost)
{
 802d068:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 802d06a:	4614      	mov	r4, r2
  /* USER CODE BEGIN FRAG_DECODER_IF_OnProgress_1 */

  /* USER CODE END FRAG_DECODER_IF_OnProgress_1 */
  APP_LOG(TS_OFF, VLEVEL_M, "\r\n....... FRAG_DECODER in Progress .......\r\n");
 802d06c:	2200      	movs	r2, #0
{
 802d06e:	4606      	mov	r6, r0
 802d070:	460d      	mov	r5, r1
 802d072:	461f      	mov	r7, r3
  APP_LOG(TS_OFF, VLEVEL_M, "\r\n....... FRAG_DECODER in Progress .......\r\n");
 802d074:	4611      	mov	r1, r2
 802d076:	4b0f      	ldr	r3, [pc, #60]	; (802d0b4 <FRAG_DECODER_IF_OnProgress+0x4c>)
 802d078:	2002      	movs	r0, #2
 802d07a:	f00d fe07 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
  APP_LOG(TS_OFF, VLEVEL_M, "RECEIVED    : %5d / %5d Fragments\r\n", fragCounter, fragNb);
 802d07e:	2200      	movs	r2, #0
 802d080:	e9cd 6500 	strd	r6, r5, [sp]
 802d084:	4611      	mov	r1, r2
 802d086:	4b0c      	ldr	r3, [pc, #48]	; (802d0b8 <FRAG_DECODER_IF_OnProgress+0x50>)
 802d088:	2002      	movs	r0, #2
 802d08a:	f00d fdff 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
  APP_LOG(TS_OFF, VLEVEL_M, "              %5d / %5d Bytes\r\n", fragCounter * fragSize, fragNb * fragSize);
 802d08e:	4365      	muls	r5, r4
 802d090:	2200      	movs	r2, #0
 802d092:	4374      	muls	r4, r6
 802d094:	4611      	mov	r1, r2
 802d096:	4b09      	ldr	r3, [pc, #36]	; (802d0bc <FRAG_DECODER_IF_OnProgress+0x54>)
 802d098:	9501      	str	r5, [sp, #4]
 802d09a:	9400      	str	r4, [sp, #0]
 802d09c:	2002      	movs	r0, #2
 802d09e:	f00d fdf5 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
  APP_LOG(TS_OFF, VLEVEL_M, "LOST        :       %7d Fragments\r\n\r\n", fragNbLost);
 802d0a2:	2200      	movs	r2, #0
 802d0a4:	4b06      	ldr	r3, [pc, #24]	; (802d0c0 <FRAG_DECODER_IF_OnProgress+0x58>)
 802d0a6:	9700      	str	r7, [sp, #0]
 802d0a8:	4611      	mov	r1, r2
 802d0aa:	2002      	movs	r0, #2
 802d0ac:	f00d fdee 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
  BSP_LED_Toggle(LED_BLUE);
#endif /* INTEROP_TEST_MODE == 1 */
  /* USER CODE BEGIN FRAG_DECODER_IF_OnProgress_2 */

  /* USER CODE END FRAG_DECODER_IF_OnProgress_2 */
}
 802d0b0:	b003      	add	sp, #12
 802d0b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802d0b4:	0803bffb 	.word	0x0803bffb
 802d0b8:	0803c028 	.word	0x0803c028
 802d0bc:	0803c04c 	.word	0x0803c04c
 802d0c0:	0803c06c 	.word	0x0803c06c

0802d0c4 <FRAG_DECODER_IF_Read>:
{
 802d0c4:	b508      	push	{r3, lr}
 802d0c6:	460b      	mov	r3, r1
  UTIL_MEM_cpy_8(data, (void *)(FRAG_DECODER_DWL_REGION_START + addr), size);
 802d0c8:	4904      	ldr	r1, [pc, #16]	; (802d0dc <FRAG_DECODER_IF_Read+0x18>)
 802d0ca:	6889      	ldr	r1, [r1, #8]
 802d0cc:	b292      	uxth	r2, r2
 802d0ce:	4401      	add	r1, r0
 802d0d0:	4618      	mov	r0, r3
 802d0d2:	f00d fee3 	bl	803ae9c <UTIL_MEM_cpy_8>
}
 802d0d6:	2000      	movs	r0, #0
 802d0d8:	bd08      	pop	{r3, pc}
 802d0da:	bf00      	nop
 802d0dc:	0803b8b8 	.word	0x0803b8b8

0802d0e0 <FRAG_DECODER_IF_OnDone>:

void FRAG_DECODER_IF_OnDone(int32_t status, uint32_t size)
{
 802d0e0:	b513      	push	{r0, r1, r4, lr}
  /* USER CODE BEGIN FRAG_DECODER_IF_OnDone_1 */

  /* USER CODE END FRAG_DECODER_IF_OnDone_1 */
  APP_LOG(TS_OFF, VLEVEL_M, "\r\n....... FRAG_DECODER Finished .......\r\n");
 802d0e2:	2200      	movs	r2, #0
{
 802d0e4:	4604      	mov	r4, r0
  APP_LOG(TS_OFF, VLEVEL_M, "\r\n....... FRAG_DECODER Finished .......\r\n");
 802d0e6:	4611      	mov	r1, r2
 802d0e8:	4b07      	ldr	r3, [pc, #28]	; (802d108 <FRAG_DECODER_IF_OnDone+0x28>)
 802d0ea:	2002      	movs	r0, #2
 802d0ec:	f00d fdce 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
  APP_LOG(TS_OFF, VLEVEL_M, "STATUS      : %d\r\n", status);
 802d0f0:	2200      	movs	r2, #0
 802d0f2:	4b06      	ldr	r3, [pc, #24]	; (802d10c <FRAG_DECODER_IF_OnDone+0x2c>)
 802d0f4:	9400      	str	r4, [sp, #0]
 802d0f6:	4611      	mov	r1, r2
 802d0f8:	2002      	movs	r0, #2
 802d0fa:	f00d fdc7 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
  BSP_LED_Off(LED_BLUE);
#endif /* INTEROP_TEST_MODE == 1 */
  /* USER CODE BEGIN FRAG_DECODER_IF_OnDone_2 */

  /* USER CODE END FRAG_DECODER_IF_OnDone_2 */
}
 802d0fe:	b002      	add	sp, #8
 802d100:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  FwUpdateAgent_Run();
 802d104:	f7ff bd1e 	b.w	802cb44 <FwUpdateAgent_Run>
 802d108:	0803c092 	.word	0x0803c092
 802d10c:	0803c0bc 	.word	0x0803c0bc

0802d110 <RBI_Init>:
   *       or at https://github.com/STMicroelectronics/STM32CubeWL/tree/main/Drivers/BSP/STM32WLxx_Nucleo/
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration */
  return BSP_RADIO_Init();
 802d110:	f000 b8e6 	b.w	802d2e0 <BSP_RADIO_Init>

0802d114 <RBI_ConfigRFSwitch>:
   *       or at https://github.com/STMicroelectronics/STM32CubeWL/tree/main/Drivers/BSP/STM32WLxx_Nucleo/
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration */
  return BSP_RADIO_ConfigRFSwitch((BSP_RADIO_Switch_TypeDef) Config);
 802d114:	f000 b924 	b.w	802d360 <BSP_RADIO_ConfigRFSwitch>

0802d118 <RBI_GetTxConfig>:
   *       or at https://github.com/STMicroelectronics/STM32CubeWL/tree/main/Drivers/BSP/STM32WLxx_Nucleo/
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration */
  return BSP_RADIO_GetTxConfig();
 802d118:	f000 b956 	b.w	802d3c8 <BSP_RADIO_GetTxConfig>

0802d11c <RBI_IsTCXO>:
   *       or at https://github.com/STMicroelectronics/STM32CubeWL/tree/main/Drivers/BSP/STM32WLxx_Nucleo/
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration */
  return BSP_RADIO_IsTCXO();
 802d11c:	f000 b956 	b.w	802d3cc <BSP_RADIO_IsTCXO>

0802d120 <RBI_IsDCDC>:
   *       or at https://github.com/STMicroelectronics/STM32CubeWL/tree/main/Drivers/BSP/STM32WLxx_Nucleo/
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration */
  return BSP_RADIO_IsDCDC();
 802d120:	f000 b956 	b.w	802d3d0 <BSP_RADIO_IsDCDC>

0802d124 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 802d124:	480d      	ldr	r0, [pc, #52]	; (802d15c <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 802d126:	4685      	mov	sp, r0

/* Call the clock system initialization function.*/
  bl  SystemInit
 802d128:	f000 f954 	bl	802d3d4 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 802d12c:	480c      	ldr	r0, [pc, #48]	; (802d160 <LoopForever+0x6>)
  ldr r1, =_edata
 802d12e:	490d      	ldr	r1, [pc, #52]	; (802d164 <LoopForever+0xa>)
  ldr r2, =_sidata
 802d130:	4a0d      	ldr	r2, [pc, #52]	; (802d168 <LoopForever+0xe>)
  movs r3, #0
 802d132:	2300      	movs	r3, #0
  b LoopCopyDataInit
 802d134:	e002      	b.n	802d13c <LoopCopyDataInit>

0802d136 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 802d136:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 802d138:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 802d13a:	3304      	adds	r3, #4

0802d13c <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 802d13c:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 802d13e:	428c      	cmp	r4, r1
  bcc CopyDataInit
 802d140:	d3f9      	bcc.n	802d136 <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 802d142:	4a0a      	ldr	r2, [pc, #40]	; (802d16c <LoopForever+0x12>)
  ldr r4, =_ebss
 802d144:	4c0a      	ldr	r4, [pc, #40]	; (802d170 <LoopForever+0x16>)
  movs r3, #0
 802d146:	2300      	movs	r3, #0
  b LoopFillZerobss
 802d148:	e001      	b.n	802d14e <LoopFillZerobss>

0802d14a <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 802d14a:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 802d14c:	3204      	adds	r2, #4

0802d14e <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 802d14e:	42a2      	cmp	r2, r4
  bcc FillZerobss
 802d150:	d3fb      	bcc.n	802d14a <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 802d152:	f00e fabd 	bl	803b6d0 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 802d156:	f7ff f8a1 	bl	802c29c <main>

0802d15a <LoopForever>:

LoopForever:
    b LoopForever
 802d15a:	e7fe      	b.n	802d15a <LoopForever>
  ldr   r0, =_estack
 802d15c:	20008000 	.word	0x20008000
  ldr r0, =_sdata
 802d160:	20003400 	.word	0x20003400
  ldr r1, =_edata
 802d164:	200035ac 	.word	0x200035ac
  ldr r2, =_sidata
 802d168:	0803c570 	.word	0x0803c570
  ldr r2, =_sbss
 802d16c:	200035ac 	.word	0x200035ac
  ldr r4, =_ebss
 802d170:	200063ac 	.word	0x200063ac

0802d174 <ADC_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 802d174:	e7fe      	b.n	802d174 <ADC_IRQHandler>

0802d176 <LL_AHB2_GRP1_EnableClock>:
  SET_BIT(RCC->AHB2ENR, Periphs);
 802d176:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
{
 802d17a:	b082      	sub	sp, #8
  SET_BIT(RCC->AHB2ENR, Periphs);
 802d17c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 802d17e:	4302      	orrs	r2, r0
 802d180:	64da      	str	r2, [r3, #76]	; 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 802d182:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 802d184:	4018      	ands	r0, r3
 802d186:	9001      	str	r0, [sp, #4]
  (void)tmpreg;
 802d188:	9b01      	ldr	r3, [sp, #4]
}
 802d18a:	b002      	add	sp, #8
 802d18c:	4770      	bx	lr
	...

0802d190 <BSP_LED_Init>:
  *            @arg LED2
  *            @arg LED3
  * @retval BSP status
  */
int32_t BSP_LED_Init(Led_TypeDef Led)
{
 802d190:	b570      	push	{r4, r5, r6, lr}
 802d192:	b086      	sub	sp, #24
 802d194:	4604      	mov	r4, r0
  GPIO_InitTypeDef  gpio_init_structure = {0};
 802d196:	2214      	movs	r2, #20
 802d198:	2100      	movs	r1, #0
 802d19a:	a801      	add	r0, sp, #4
 802d19c:	f00e fabc 	bl	803b718 <memset>
  
  /* Enable the GPIO_LED Clock */
  LEDx_GPIO_CLK_ENABLE(Led);
 802d1a0:	2002      	movs	r0, #2
 802d1a2:	f7ff ffe8 	bl	802d176 <LL_AHB2_GRP1_EnableClock>

  /* Configure the GPIO_LED pin */
  gpio_init_structure.Pin = LED_PIN[Led];
 802d1a6:	4b0c      	ldr	r3, [pc, #48]	; (802d1d8 <BSP_LED_Init+0x48>)
 802d1a8:	f833 6014 	ldrh.w	r6, [r3, r4, lsl #1]
 802d1ac:	9601      	str	r6, [sp, #4]
  gpio_init_structure.Mode = GPIO_MODE_OUTPUT_PP;
  gpio_init_structure.Pull = GPIO_NOPULL;
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;
  
  HAL_GPIO_Init(LED_PORT[Led], &gpio_init_structure);
 802d1ae:	eb03 0384 	add.w	r3, r3, r4, lsl #2
  gpio_init_structure.Pull = GPIO_NOPULL;
 802d1b2:	2500      	movs	r5, #0
  HAL_GPIO_Init(LED_PORT[Led], &gpio_init_structure);
 802d1b4:	689c      	ldr	r4, [r3, #8]
  gpio_init_structure.Pull = GPIO_NOPULL;
 802d1b6:	2201      	movs	r2, #1
 802d1b8:	e9cd 2502 	strd	r2, r5, [sp, #8]
  HAL_GPIO_Init(LED_PORT[Led], &gpio_init_structure);
 802d1bc:	a901      	add	r1, sp, #4
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;
 802d1be:	2202      	movs	r2, #2
  HAL_GPIO_Init(LED_PORT[Led], &gpio_init_structure);
 802d1c0:	4620      	mov	r0, r4
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;
 802d1c2:	9204      	str	r2, [sp, #16]
  HAL_GPIO_Init(LED_PORT[Led], &gpio_init_structure);
 802d1c4:	f001 f948 	bl	802e458 <HAL_GPIO_Init>
  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_RESET);
 802d1c8:	4620      	mov	r0, r4
 802d1ca:	462a      	mov	r2, r5
 802d1cc:	4631      	mov	r1, r6
 802d1ce:	f001 fa63 	bl	802e698 <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
}
 802d1d2:	4628      	mov	r0, r5
 802d1d4:	b006      	add	sp, #24
 802d1d6:	bd70      	pop	{r4, r5, r6, pc}
 802d1d8:	0803b904 	.word	0x0803b904

0802d1dc <BSP_LED_On>:
  *            @arg LED3
  * @retval BSP status
  */
int32_t BSP_LED_On(Led_TypeDef Led)
{
  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_SET); 
 802d1dc:	4b05      	ldr	r3, [pc, #20]	; (802d1f4 <BSP_LED_On+0x18>)
{
 802d1de:	b510      	push	{r4, lr}
  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_SET); 
 802d1e0:	eb03 0480 	add.w	r4, r3, r0, lsl #2
 802d1e4:	f833 1010 	ldrh.w	r1, [r3, r0, lsl #1]
 802d1e8:	68a0      	ldr	r0, [r4, #8]
 802d1ea:	2201      	movs	r2, #1
 802d1ec:	f001 fa54 	bl	802e698 <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
}
 802d1f0:	2000      	movs	r0, #0
 802d1f2:	bd10      	pop	{r4, pc}
 802d1f4:	0803b904 	.word	0x0803b904

0802d1f8 <BSP_LED_Off>:
  *            @arg LED3
  * @retval BSP status
  */
int32_t BSP_LED_Off(Led_TypeDef Led)
{
  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_RESET); 
 802d1f8:	4b05      	ldr	r3, [pc, #20]	; (802d210 <BSP_LED_Off+0x18>)
{
 802d1fa:	b510      	push	{r4, lr}
  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_RESET); 
 802d1fc:	eb03 0480 	add.w	r4, r3, r0, lsl #2
 802d200:	f833 1010 	ldrh.w	r1, [r3, r0, lsl #1]
 802d204:	68a0      	ldr	r0, [r4, #8]
 802d206:	2200      	movs	r2, #0
 802d208:	f001 fa46 	bl	802e698 <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
}
 802d20c:	2000      	movs	r0, #0
 802d20e:	bd10      	pop	{r4, pc}
 802d210:	0803b904 	.word	0x0803b904

0802d214 <BSP_LED_Toggle>:
  *            @arg LED2
  *            @arg LED3
  * @retval BSP status
  */
int32_t BSP_LED_Toggle(Led_TypeDef Led)
{
 802d214:	b508      	push	{r3, lr}
  HAL_GPIO_TogglePin(LED_PORT[Led], LED_PIN[Led]);
 802d216:	4b05      	ldr	r3, [pc, #20]	; (802d22c <BSP_LED_Toggle+0x18>)
 802d218:	eb03 0280 	add.w	r2, r3, r0, lsl #2
 802d21c:	f833 1010 	ldrh.w	r1, [r3, r0, lsl #1]
 802d220:	6890      	ldr	r0, [r2, #8]
 802d222:	f001 fa3e 	bl	802e6a2 <HAL_GPIO_TogglePin>

  return BSP_ERROR_NONE;
}
 802d226:	2000      	movs	r0, #0
 802d228:	bd08      	pop	{r3, pc}
 802d22a:	bf00      	nop
 802d22c:	0803b904 	.word	0x0803b904

0802d230 <BSP_PB_Init>:
  *     @arg BUTTON_MODE_EXTI: Button will be connected to EXTI line with interrupt
  *                            generation capability  
  * @retval BSP status
  */
int32_t BSP_PB_Init(Button_TypeDef Button, ButtonMode_TypeDef ButtonMode)
{
 802d230:	b5f0      	push	{r4, r5, r6, r7, lr}
 802d232:	b087      	sub	sp, #28
 802d234:	4604      	mov	r4, r0
 802d236:	460f      	mov	r7, r1
  GPIO_InitTypeDef gpio_init_structure = {0};
 802d238:	2214      	movs	r2, #20
 802d23a:	2100      	movs	r1, #0
 802d23c:	a801      	add	r0, sp, #4
 802d23e:	f00e fa6b 	bl	803b718 <memset>
  static BSP_EXTI_LineCallback button_callback[BUTTONn] = {BUTTON_SW1_EXTI_Callback, BUTTON_SW2_EXTI_Callback, BUTTON_SW3_EXTI_Callback};
  static uint32_t button_interrupt_priority[BUTTONn] = {BSP_BUTTON_SWx_IT_PRIORITY, BSP_BUTTON_SWx_IT_PRIORITY, BSP_BUTTON_SWx_IT_PRIORITY};
  static const uint32_t button_exti_line[BUTTONn] = {BUTTON_SW1_EXTI_LINE, BUTTON_SW2_EXTI_LINE, BUTTON_SW3_EXTI_LINE};

  /* Enable the BUTTON Clock */
  BUTTONx_GPIO_CLK_ENABLE(Button);
 802d242:	2c01      	cmp	r4, #1
 802d244:	d816      	bhi.n	802d274 <BSP_PB_Init+0x44>
 802d246:	2001      	movs	r0, #1
 802d248:	f7ff ff95 	bl	802d176 <LL_AHB2_GRP1_EnableClock>
  
  gpio_init_structure.Pin = BUTTON_PIN[Button];
 802d24c:	4d1a      	ldr	r5, [pc, #104]	; (802d2b8 <BSP_PB_Init+0x88>)
 802d24e:	eb05 0344 	add.w	r3, r5, r4, lsl #1
 802d252:	eb05 0684 	add.w	r6, r5, r4, lsl #2
 802d256:	8a9b      	ldrh	r3, [r3, #20]
 802d258:	9301      	str	r3, [sp, #4]
  gpio_init_structure.Pull = GPIO_PULLUP;
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;
 802d25a:	2201      	movs	r2, #1
 802d25c:	2302      	movs	r3, #2
 802d25e:	e9cd 2303 	strd	r2, r3, [sp, #12]

  if(ButtonMode == BUTTON_MODE_GPIO)
 802d262:	69f0      	ldr	r0, [r6, #28]
 802d264:	b957      	cbnz	r7, 802d27c <BSP_PB_Init+0x4c>
  {
    /* Configure Button pin as input */
    gpio_init_structure.Mode = GPIO_MODE_INPUT;
    HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
 802d266:	a901      	add	r1, sp, #4
    gpio_init_structure.Mode = GPIO_MODE_INPUT;
 802d268:	9702      	str	r7, [sp, #8]
    HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
 802d26a:	f001 f8f5 	bl	802e458 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority((BUTTON_IRQn[Button]), button_interrupt_priority[Button], 0x00);
    HAL_NVIC_EnableIRQ((BUTTON_IRQn[Button]));
  }

  return BSP_ERROR_NONE;
}
 802d26e:	2000      	movs	r0, #0
 802d270:	b007      	add	sp, #28
 802d272:	bdf0      	pop	{r4, r5, r6, r7, pc}
  BUTTONx_GPIO_CLK_ENABLE(Button);
 802d274:	2c02      	cmp	r4, #2
 802d276:	d1e9      	bne.n	802d24c <BSP_PB_Init+0x1c>
 802d278:	2004      	movs	r0, #4
 802d27a:	e7e5      	b.n	802d248 <BSP_PB_Init+0x18>
    (void)HAL_EXTI_GetHandle(&hpb_exti[Button], button_exti_line[Button]);
 802d27c:	4f0f      	ldr	r7, [pc, #60]	; (802d2bc <BSP_PB_Init+0x8c>)
    gpio_init_structure.Mode = GPIO_MODE_IT_FALLING;
 802d27e:	f44f 1304 	mov.w	r3, #2162688	; 0x210000
    (void)HAL_EXTI_GetHandle(&hpb_exti[Button], button_exti_line[Button]);
 802d282:	eb07 07c4 	add.w	r7, r7, r4, lsl #3
    HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
 802d286:	a901      	add	r1, sp, #4
    gpio_init_structure.Mode = GPIO_MODE_IT_FALLING;
 802d288:	9302      	str	r3, [sp, #8]
    HAL_NVIC_SetPriority((BUTTON_IRQn[Button]), button_interrupt_priority[Button], 0x00);
 802d28a:	442c      	add	r4, r5
    HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
 802d28c:	f001 f8e4 	bl	802e458 <HAL_GPIO_Init>
    (void)HAL_EXTI_GetHandle(&hpb_exti[Button], button_exti_line[Button]);
 802d290:	6ab1      	ldr	r1, [r6, #40]	; 0x28
 802d292:	4638      	mov	r0, r7
 802d294:	f000 ffaf 	bl	802e1f6 <HAL_EXTI_GetHandle>
    (void)HAL_EXTI_RegisterCallback(&hpb_exti[Button],  HAL_EXTI_COMMON_CB_ID, button_callback[Button]);
 802d298:	6b72      	ldr	r2, [r6, #52]	; 0x34
 802d29a:	2100      	movs	r1, #0
 802d29c:	4638      	mov	r0, r7
 802d29e:	f000 ffa3 	bl	802e1e8 <HAL_EXTI_RegisterCallback>
    HAL_NVIC_SetPriority((BUTTON_IRQn[Button]), button_interrupt_priority[Button], 0x00);
 802d2a2:	f994 4040 	ldrsb.w	r4, [r4, #64]	; 0x40
 802d2a6:	6c71      	ldr	r1, [r6, #68]	; 0x44
 802d2a8:	4620      	mov	r0, r4
 802d2aa:	2200      	movs	r2, #0
 802d2ac:	f000 fd26 	bl	802dcfc <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ((BUTTON_IRQn[Button]));
 802d2b0:	4620      	mov	r0, r4
 802d2b2:	f000 fd55 	bl	802dd60 <HAL_NVIC_EnableIRQ>
 802d2b6:	e7da      	b.n	802d26e <BSP_PB_Init+0x3e>
 802d2b8:	0803b904 	.word	0x0803b904
 802d2bc:	200062f0 	.word	0x200062f0

0802d2c0 <BSP_PB_Callback>:
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Button);

  /* This function should be implemented by the user application.
     It is called into this driver when an event on Button is triggered. */
}
 802d2c0:	4770      	bx	lr

0802d2c2 <BUTTON_SW3_EXTI_Callback>:
/**
  * @brief  Button SW3 EXTI line detection callback.
  * @retval None
  */
static void BUTTON_SW3_EXTI_Callback(void)
{
 802d2c2:	b508      	push	{r3, lr}
  BSP_PB_Callback(BUTTON_SW3);
 802d2c4:	2002      	movs	r0, #2
 802d2c6:	f7ff fffb 	bl	802d2c0 <BSP_PB_Callback>
}
 802d2ca:	bd08      	pop	{r3, pc}

0802d2cc <BUTTON_SW2_EXTI_Callback>:
{
 802d2cc:	b508      	push	{r3, lr}
  BSP_PB_Callback(BUTTON_SW2);
 802d2ce:	2001      	movs	r0, #1
 802d2d0:	f7ff fff6 	bl	802d2c0 <BSP_PB_Callback>
}
 802d2d4:	bd08      	pop	{r3, pc}

0802d2d6 <BUTTON_SW1_EXTI_Callback>:
{
 802d2d6:	b508      	push	{r3, lr}
  BSP_PB_Callback(BUTTON_SW1);
 802d2d8:	2000      	movs	r0, #0
 802d2da:	f7ff fff1 	bl	802d2c0 <BSP_PB_Callback>
}
 802d2de:	bd08      	pop	{r3, pc}

0802d2e0 <BSP_RADIO_Init>:
/**
  * @brief  Init Radio Switch 
  * @retval BSP status
  */
int32_t BSP_RADIO_Init(void)
{
 802d2e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802d2e4:	b086      	sub	sp, #24
  GPIO_InitTypeDef  gpio_init_structure = {0};
 802d2e6:	2400      	movs	r4, #0
  SET_BIT(RCC->AHB2ENR, Periphs);
 802d2e8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802d2ec:	9405      	str	r4, [sp, #20]
 802d2ee:	6cda      	ldr	r2, [r3, #76]	; 0x4c
  gpio_init_structure.Pin   = RF_SW_CTRL1_PIN;
  gpio_init_structure.Mode  = GPIO_MODE_OUTPUT_PP;
  gpio_init_structure.Pull  = GPIO_NOPULL;
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  
  HAL_GPIO_Init(RF_SW_CTRL1_GPIO_PORT, &gpio_init_structure);
 802d2f0:	4d1a      	ldr	r5, [pc, #104]	; (802d35c <BSP_RADIO_Init+0x7c>)
 802d2f2:	f042 0204 	orr.w	r2, r2, #4
 802d2f6:	64da      	str	r2, [r3, #76]	; 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 802d2f8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  gpio_init_structure.Pull  = GPIO_NOPULL;
 802d2fa:	9403      	str	r4, [sp, #12]
 802d2fc:	f003 0304 	and.w	r3, r3, #4
 802d300:	9300      	str	r3, [sp, #0]
  (void)tmpreg;
 802d302:	9b00      	ldr	r3, [sp, #0]
  gpio_init_structure.Mode  = GPIO_MODE_OUTPUT_PP;
 802d304:	2710      	movs	r7, #16
 802d306:	2301      	movs	r3, #1
 802d308:	e9cd 7301 	strd	r7, r3, [sp, #4]
  HAL_GPIO_Init(RF_SW_CTRL1_GPIO_PORT, &gpio_init_structure);
 802d30c:	a901      	add	r1, sp, #4
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 802d30e:	2303      	movs	r3, #3
  HAL_GPIO_Init(RF_SW_CTRL1_GPIO_PORT, &gpio_init_structure);
 802d310:	4628      	mov	r0, r5
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 802d312:	9304      	str	r3, [sp, #16]
  
  gpio_init_structure.Pin = RF_SW_CTRL2_PIN;
 802d314:	f04f 0820 	mov.w	r8, #32
  HAL_GPIO_Init(RF_SW_CTRL1_GPIO_PORT, &gpio_init_structure);
 802d318:	f001 f89e 	bl	802e458 <HAL_GPIO_Init>
  HAL_GPIO_Init(RF_SW_CTRL2_GPIO_PORT, &gpio_init_structure);
 802d31c:	a901      	add	r1, sp, #4
 802d31e:	4628      	mov	r0, r5
  
  gpio_init_structure.Pin = RF_SW_CTRL3_PIN;
 802d320:	2608      	movs	r6, #8
  gpio_init_structure.Pin = RF_SW_CTRL2_PIN;
 802d322:	f8cd 8004 	str.w	r8, [sp, #4]
  HAL_GPIO_Init(RF_SW_CTRL2_GPIO_PORT, &gpio_init_structure);
 802d326:	f001 f897 	bl	802e458 <HAL_GPIO_Init>
  HAL_GPIO_Init(RF_SW_CTRL3_GPIO_PORT, &gpio_init_structure);
 802d32a:	a901      	add	r1, sp, #4
 802d32c:	4628      	mov	r0, r5
  gpio_init_structure.Pin = RF_SW_CTRL3_PIN;
 802d32e:	9601      	str	r6, [sp, #4]
  HAL_GPIO_Init(RF_SW_CTRL3_GPIO_PORT, &gpio_init_structure);
 802d330:	f001 f892 	bl	802e458 <HAL_GPIO_Init>

  HAL_GPIO_WritePin(RF_SW_CTRL2_GPIO_PORT, RF_SW_CTRL2_PIN, GPIO_PIN_RESET); 
 802d334:	4622      	mov	r2, r4
 802d336:	4641      	mov	r1, r8
 802d338:	4628      	mov	r0, r5
 802d33a:	f001 f9ad 	bl	802e698 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_RESET); 
 802d33e:	4622      	mov	r2, r4
 802d340:	4639      	mov	r1, r7
 802d342:	4628      	mov	r0, r5
 802d344:	f001 f9a8 	bl	802e698 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_RESET); 
 802d348:	4628      	mov	r0, r5
 802d34a:	4622      	mov	r2, r4
 802d34c:	4631      	mov	r1, r6
 802d34e:	f001 f9a3 	bl	802e698 <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
}
 802d352:	4620      	mov	r0, r4
 802d354:	b006      	add	sp, #24
 802d356:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802d35a:	bf00      	nop
 802d35c:	48000800 	.word	0x48000800

0802d360 <BSP_RADIO_ConfigRFSwitch>:
  *           @arg RADIO_SWITCH_RFO_LP
  *           @arg RADIO_SWITCH_RFO_HP
  * @retval BSP status
  */
int32_t BSP_RADIO_ConfigRFSwitch(BSP_RADIO_Switch_TypeDef Config)
{
 802d360:	b508      	push	{r3, lr}
 802d362:	2803      	cmp	r0, #3
 802d364:	d812      	bhi.n	802d38c <BSP_RADIO_ConfigRFSwitch+0x2c>
 802d366:	e8df f000 	tbb	[pc, r0]
 802d36a:	1302      	.short	0x1302
 802d36c:	261a      	.short	0x261a
  switch (Config)
  {
    case RADIO_SWITCH_OFF:
    {
      /* Turn off switch */
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_RESET);
 802d36e:	2200      	movs	r2, #0
 802d370:	4814      	ldr	r0, [pc, #80]	; (802d3c4 <BSP_RADIO_ConfigRFSwitch+0x64>)
 802d372:	2108      	movs	r1, #8
 802d374:	f001 f990 	bl	802e698 <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_RESET);
 802d378:	2200      	movs	r2, #0
    }
    case RADIO_SWITCH_RX:
    {
      /*Turns On in Rx Mode the RF Switch */
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_SET);
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_SET); 
 802d37a:	4812      	ldr	r0, [pc, #72]	; (802d3c4 <BSP_RADIO_ConfigRFSwitch+0x64>)
 802d37c:	2110      	movs	r1, #16
 802d37e:	f001 f98b 	bl	802e698 <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL2_GPIO_PORT, RF_SW_CTRL2_PIN, GPIO_PIN_RESET); 
 802d382:	2200      	movs	r2, #0
    case RADIO_SWITCH_RFO_HP:
    {
      /*Turns On in Tx High Power the RF Switch */
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_SET);
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_RESET); 
      HAL_GPIO_WritePin(RF_SW_CTRL2_GPIO_PORT, RF_SW_CTRL2_PIN, GPIO_PIN_SET); 
 802d384:	480f      	ldr	r0, [pc, #60]	; (802d3c4 <BSP_RADIO_ConfigRFSwitch+0x64>)
 802d386:	2120      	movs	r1, #32
 802d388:	f001 f986 	bl	802e698 <HAL_GPIO_WritePin>
    default:
      break;    
  }  

  return BSP_ERROR_NONE;
}
 802d38c:	2000      	movs	r0, #0
 802d38e:	bd08      	pop	{r3, pc}
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_SET);
 802d390:	2201      	movs	r2, #1
 802d392:	480c      	ldr	r0, [pc, #48]	; (802d3c4 <BSP_RADIO_ConfigRFSwitch+0x64>)
 802d394:	2108      	movs	r1, #8
 802d396:	f001 f97f 	bl	802e698 <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_SET); 
 802d39a:	2201      	movs	r2, #1
 802d39c:	e7ed      	b.n	802d37a <BSP_RADIO_ConfigRFSwitch+0x1a>
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_SET);
 802d39e:	2201      	movs	r2, #1
 802d3a0:	4808      	ldr	r0, [pc, #32]	; (802d3c4 <BSP_RADIO_ConfigRFSwitch+0x64>)
 802d3a2:	2108      	movs	r1, #8
 802d3a4:	f001 f978 	bl	802e698 <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_SET); 
 802d3a8:	2201      	movs	r2, #1
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_RESET); 
 802d3aa:	4806      	ldr	r0, [pc, #24]	; (802d3c4 <BSP_RADIO_ConfigRFSwitch+0x64>)
 802d3ac:	2110      	movs	r1, #16
 802d3ae:	f001 f973 	bl	802e698 <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL2_GPIO_PORT, RF_SW_CTRL2_PIN, GPIO_PIN_SET); 
 802d3b2:	2201      	movs	r2, #1
 802d3b4:	e7e6      	b.n	802d384 <BSP_RADIO_ConfigRFSwitch+0x24>
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_SET);
 802d3b6:	2201      	movs	r2, #1
 802d3b8:	4802      	ldr	r0, [pc, #8]	; (802d3c4 <BSP_RADIO_ConfigRFSwitch+0x64>)
 802d3ba:	2108      	movs	r1, #8
 802d3bc:	f001 f96c 	bl	802e698 <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_RESET); 
 802d3c0:	2200      	movs	r2, #0
 802d3c2:	e7f2      	b.n	802d3aa <BSP_RADIO_ConfigRFSwitch+0x4a>
 802d3c4:	48000800 	.word	0x48000800

0802d3c8 <BSP_RADIO_GetTxConfig>:
  *  RADIO_CONF_RFO_HP
  */
int32_t BSP_RADIO_GetTxConfig(void)
{
  return RADIO_CONF_RFO_LP_HP;
}
 802d3c8:	2000      	movs	r0, #0
 802d3ca:	4770      	bx	lr

0802d3cc <BSP_RADIO_IsTCXO>:
  *  RADIO_CONF_TCXO_SUPPORTED
  */
int32_t BSP_RADIO_IsTCXO(void)
{
  return RADIO_CONF_TCXO_SUPPORTED;
}
 802d3cc:	2001      	movs	r0, #1
 802d3ce:	4770      	bx	lr

0802d3d0 <BSP_RADIO_IsDCDC>:
 802d3d0:	2001      	movs	r0, #1
 802d3d2:	4770      	bx	lr

0802d3d4 <SystemInit>:
  * @retval None
  */
void SystemInit(void)
{
  /* Configure the Vector Table location  ------------------*/
  SCB->VTOR = INTVECT_START;
 802d3d4:	4b0c      	ldr	r3, [pc, #48]	; (802d408 <SystemInit+0x34>)
 802d3d6:	4a0d      	ldr	r2, [pc, #52]	; (802d40c <SystemInit+0x38>)
 802d3d8:	609a      	str	r2, [r3, #8]
  SCB->CPACR |= ((3UL << (10UL*2UL))|(3UL << (11UL*2UL)));  /* set CP10 and CP11 Full Access */
#endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 802d3da:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802d3de:	681a      	ldr	r2, [r3, #0]
 802d3e0:	f042 0201 	orr.w	r2, r2, #1
 802d3e4:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00070000U;
 802d3e6:	f44f 22e0 	mov.w	r2, #458752	; 0x70000
 802d3ea:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON , HSION, and PLLON bits */
  /* RCC->CR &= 0xEAF6FFFFU; */
  RCC->CR &= 0x2321EFF;
 802d3ec:	6819      	ldr	r1, [r3, #0]
 802d3ee:	4a08      	ldr	r2, [pc, #32]	; (802d410 <SystemInit+0x3c>)
 802d3f0:	400a      	ands	r2, r1
 802d3f2:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x22040100;
 802d3f4:	4a07      	ldr	r2, [pc, #28]	; (802d414 <SystemInit+0x40>)
 802d3f6:	60da      	str	r2, [r3, #12]

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFDFFFFFFU;
 802d3f8:	681a      	ldr	r2, [r3, #0]
 802d3fa:	f022 7200 	bic.w	r2, r2, #33554432	; 0x2000000
 802d3fe:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000U;
 802d400:	2200      	movs	r2, #0
 802d402:	619a      	str	r2, [r3, #24]
}
 802d404:	4770      	bx	lr
 802d406:	bf00      	nop
 802d408:	e000ed00 	.word	0xe000ed00
 802d40c:	0802b200 	.word	0x0802b200
 802d410:	02321eff 	.word	0x02321eff
 802d414:	22040100 	.word	0x22040100

0802d418 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 802d418:	b510      	push	{r4, lr}
#endif /* PREFETCH_ENABLE */

#ifdef CORE_CM0PLUS
#else
  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 802d41a:	2003      	movs	r0, #3
 802d41c:	f000 fc5c 	bl	802dcd8 <HAL_NVIC_SetPriorityGrouping>

  /* Update the SystemCoreClock global variable */
#if defined(DUAL_CORE) && defined(CORE_CM0PLUS)
  SystemCoreClock = HAL_RCC_GetHCLK2Freq();
#else
  SystemCoreClock = HAL_RCC_GetHCLKFreq();
 802d420:	f001 fac4 	bl	802e9ac <HAL_RCC_GetHCLKFreq>
 802d424:	4b06      	ldr	r3, [pc, #24]	; (802d440 <HAL_Init+0x28>)
 802d426:	6018      	str	r0, [r3, #0]
#endif

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 802d428:	200f      	movs	r0, #15
 802d42a:	f7ff f909 	bl	802c640 <HAL_InitTick>
 802d42e:	4604      	mov	r4, r0
 802d430:	b918      	cbnz	r0, 802d43a <HAL_Init+0x22>
    status = HAL_ERROR;
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
 802d432:	f7fe ffdc 	bl	802c3ee <HAL_MspInit>
  }

  /* Return function status */
  return status;
}
 802d436:	4620      	mov	r0, r4
 802d438:	bd10      	pop	{r4, pc}
    status = HAL_ERROR;
 802d43a:	2401      	movs	r4, #1
 802d43c:	e7fb      	b.n	802d436 <HAL_Init+0x1e>
 802d43e:	bf00      	nop
 802d440:	2000344c 	.word	0x2000344c

0802d444 <HAL_SuspendTick>:
  * @retval None
  */
__weak void HAL_SuspendTick(void)
{
  /* Disable SysTick Interrupt */
  CLEAR_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
 802d444:	4a02      	ldr	r2, [pc, #8]	; (802d450 <HAL_SuspendTick+0xc>)
 802d446:	6813      	ldr	r3, [r2, #0]
 802d448:	f023 0302 	bic.w	r3, r3, #2
 802d44c:	6013      	str	r3, [r2, #0]
}
 802d44e:	4770      	bx	lr
 802d450:	e000e010 	.word	0xe000e010

0802d454 <HAL_ResumeTick>:
  * @retval None
  */
__weak void HAL_ResumeTick(void)
{
  /* Enable SysTick Interrupt */
  SET_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
 802d454:	4a02      	ldr	r2, [pc, #8]	; (802d460 <HAL_ResumeTick+0xc>)
 802d456:	6813      	ldr	r3, [r2, #0]
 802d458:	f043 0302 	orr.w	r3, r3, #2
 802d45c:	6013      	str	r3, [r2, #0]
}
 802d45e:	4770      	bx	lr
 802d460:	e000e010 	.word	0xe000e010

0802d464 <HAL_GetUIDw0>:
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw0(void)
{
  return (READ_REG(*((uint32_t *)UID_BASE)));
}
 802d464:	4b01      	ldr	r3, [pc, #4]	; (802d46c <HAL_GetUIDw0+0x8>)
 802d466:	6818      	ldr	r0, [r3, #0]
 802d468:	4770      	bx	lr
 802d46a:	bf00      	nop
 802d46c:	1fff7590 	.word	0x1fff7590

0802d470 <HAL_GetUIDw1>:
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw1(void)
{
  return (READ_REG(*((uint32_t *)(UID_BASE + 4U))));
}
 802d470:	4b01      	ldr	r3, [pc, #4]	; (802d478 <HAL_GetUIDw1+0x8>)
 802d472:	6818      	ldr	r0, [r3, #0]
 802d474:	4770      	bx	lr
 802d476:	bf00      	nop
 802d478:	1fff7594 	.word	0x1fff7594

0802d47c <HAL_GetUIDw2>:
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw2(void)
{
  return (READ_REG(*((uint32_t *)(UID_BASE + 8U))));
}
 802d47c:	4b01      	ldr	r3, [pc, #4]	; (802d484 <HAL_GetUIDw2+0x8>)
 802d47e:	6818      	ldr	r0, [r3, #0]
 802d480:	4770      	bx	lr
 802d482:	bf00      	nop
 802d484:	1fff7598 	.word	0x1fff7598

0802d488 <HAL_DBGMCU_EnableDBGSleepMode>:
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
 802d488:	4a02      	ldr	r2, [pc, #8]	; (802d494 <HAL_DBGMCU_EnableDBGSleepMode+0xc>)
 802d48a:	6853      	ldr	r3, [r2, #4]
 802d48c:	f043 0301 	orr.w	r3, r3, #1
 802d490:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_EnableDBGSleepMode(void)
{
  LL_DBGMCU_EnableDBGSleepMode();
}
 802d492:	4770      	bx	lr
 802d494:	e0042000 	.word	0xe0042000

0802d498 <HAL_DBGMCU_DisableDBGSleepMode>:
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
 802d498:	4a02      	ldr	r2, [pc, #8]	; (802d4a4 <HAL_DBGMCU_DisableDBGSleepMode+0xc>)
 802d49a:	6853      	ldr	r3, [r2, #4]
 802d49c:	f023 0301 	bic.w	r3, r3, #1
 802d4a0:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_DisableDBGSleepMode(void)
{
  LL_DBGMCU_DisableDBGSleepMode();
}
 802d4a2:	4770      	bx	lr
 802d4a4:	e0042000 	.word	0xe0042000

0802d4a8 <HAL_DBGMCU_EnableDBGStopMode>:
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
 802d4a8:	4a02      	ldr	r2, [pc, #8]	; (802d4b4 <HAL_DBGMCU_EnableDBGStopMode+0xc>)
 802d4aa:	6853      	ldr	r3, [r2, #4]
 802d4ac:	f043 0302 	orr.w	r3, r3, #2
 802d4b0:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_EnableDBGStopMode(void)
{
  LL_DBGMCU_EnableDBGStopMode();
}
 802d4b2:	4770      	bx	lr
 802d4b4:	e0042000 	.word	0xe0042000

0802d4b8 <HAL_DBGMCU_DisableDBGStopMode>:
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
 802d4b8:	4a02      	ldr	r2, [pc, #8]	; (802d4c4 <HAL_DBGMCU_DisableDBGStopMode+0xc>)
 802d4ba:	6853      	ldr	r3, [r2, #4]
 802d4bc:	f023 0302 	bic.w	r3, r3, #2
 802d4c0:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_DisableDBGStopMode(void)
{
  LL_DBGMCU_DisableDBGStopMode();
}
 802d4c2:	4770      	bx	lr
 802d4c4:	e0042000 	.word	0xe0042000

0802d4c8 <HAL_DBGMCU_EnableDBGStandbyMode>:
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
 802d4c8:	4a02      	ldr	r2, [pc, #8]	; (802d4d4 <HAL_DBGMCU_EnableDBGStandbyMode+0xc>)
 802d4ca:	6853      	ldr	r3, [r2, #4]
 802d4cc:	f043 0304 	orr.w	r3, r3, #4
 802d4d0:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_EnableDBGStandbyMode(void)
{
  LL_DBGMCU_EnableDBGStandbyMode();
}
 802d4d2:	4770      	bx	lr
 802d4d4:	e0042000 	.word	0xe0042000

0802d4d8 <HAL_DBGMCU_DisableDBGStandbyMode>:
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
 802d4d8:	4a02      	ldr	r2, [pc, #8]	; (802d4e4 <HAL_DBGMCU_DisableDBGStandbyMode+0xc>)
 802d4da:	6853      	ldr	r3, [r2, #4]
 802d4dc:	f023 0304 	bic.w	r3, r3, #4
 802d4e0:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_DisableDBGStandbyMode(void)
{
  LL_DBGMCU_DisableDBGStandbyMode();
}
 802d4e2:	4770      	bx	lr
 802d4e4:	e0042000 	.word	0xe0042000

0802d4e8 <LL_ADC_REG_IsConversionOngoing>:
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group regular.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsConversionOngoing(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 802d4e8:	6880      	ldr	r0, [r0, #8]
}
 802d4ea:	f3c0 0080 	ubfx	r0, r0, #2, #1
 802d4ee:	4770      	bx	lr

0802d4f0 <HAL_ADC_Init>:
  *         of structure "ADC_InitTypeDef".
  * @param hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef *hadc)
{
 802d4f0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  uint32_t tmpCFGR1 = 0UL;
  uint32_t tmpCFGR2 = 0UL;
  uint32_t tmp_adc_reg_is_conversion_on_going;
  __IO uint32_t wait_loop_index = 0UL;
 802d4f4:	2300      	movs	r3, #0
 802d4f6:	9301      	str	r3, [sp, #4]

  /* Check ADC handle */
  if (hadc == NULL)
 802d4f8:	4604      	mov	r4, r0
 802d4fa:	2800      	cmp	r0, #0
 802d4fc:	f000 810a 	beq.w	802d714 <HAL_ADC_Init+0x224>
  /* continuous mode is disabled.                                             */
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));

  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  if (hadc->State == HAL_ADC_STATE_RESET)
 802d500:	6d85      	ldr	r5, [r0, #88]	; 0x58
 802d502:	b925      	cbnz	r5, 802d50e <HAL_ADC_Init+0x1e>

    /* Init the low level hardware */
    hadc->MspInitCallback(hadc);
#else
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
 802d504:	f7fe fcc4 	bl	802be90 <HAL_ADC_MspInit>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Set ADC error code to none */
    ADC_CLEAR_ERRORCODE(hadc);
 802d508:	65e5      	str	r5, [r4, #92]	; 0x5c

    /* Initialize Lock */
    hadc->Lock = HAL_UNLOCKED;
 802d50a:	f884 5054 	strb.w	r5, [r4, #84]	; 0x54
  }

  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
 802d50e:	6820      	ldr	r0, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 802d510:	6883      	ldr	r3, [r0, #8]
 802d512:	00d9      	lsls	r1, r3, #3
 802d514:	f140 80b3 	bpl.w	802d67e <HAL_ADC_Init+0x18e>
 802d518:	6883      	ldr	r3, [r0, #8]
 802d51a:	00da      	lsls	r2, r3, #3
 802d51c:	f100 80c6 	bmi.w	802d6ac <HAL_ADC_Init+0x1bc>
  /* or not ADC is coming from state reset (if any potential problem of       */
  /* clocking, voltage regulator would not be enabled).                       */
  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 802d520:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802d522:	f043 0310 	orr.w	r3, r3, #16
 802d526:	65a3      	str	r3, [r4, #88]	; 0x58

    /* Set ADC error code to ADC peripheral internal error */
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 802d528:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 802d52a:	f043 0301 	orr.w	r3, r3, #1
 802d52e:	65e3      	str	r3, [r4, #92]	; 0x5c

    tmp_hal_status = HAL_ERROR;
 802d530:	2101      	movs	r1, #1

  /* Configuration of ADC parameters if previous preliminary actions are      */
  /* correctly completed and if there is no conversion on going on regular    */
  /* group (ADC may already be enabled at this point if HAL_ADC_Init() is     */
  /* called to update a parameter on the fly).                                */
  tmp_adc_reg_is_conversion_on_going = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 802d532:	f7ff ffd9 	bl	802d4e8 <LL_ADC_REG_IsConversionOngoing>

  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 802d536:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802d538:	f003 0310 	and.w	r3, r3, #16
 802d53c:	4318      	orrs	r0, r3
      && (tmp_adc_reg_is_conversion_on_going == 0UL)
     )
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 802d53e:	6da3      	ldr	r3, [r4, #88]	; 0x58
  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 802d540:	f040 80ea 	bne.w	802d718 <HAL_ADC_Init+0x228>
    ADC_STATE_CLR_SET(hadc->State,
 802d544:	f423 7381 	bic.w	r3, r3, #258	; 0x102
 802d548:	f043 0302 	orr.w	r3, r3, #2
    /*  - Oversampling                                                        */
    /*  - Trigger frequency mode                                              */
    /* Note: If low power mode AutoPowerOff is enabled, ADC enable            */
    /*       and disable phases are performed automatically by hardware       */
    /*       (in this case, flag ADC_FLAG_RDY is not set).                    */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 802d54c:	6822      	ldr	r2, [r4, #0]
    ADC_STATE_CLR_SET(hadc->State,
 802d54e:	65a3      	str	r3, [r4, #88]	; 0x58
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 802d550:	6893      	ldr	r3, [r2, #8]
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 802d552:	07db      	lsls	r3, r3, #31
 802d554:	f100 80ac 	bmi.w	802d6b0 <HAL_ADC_Init+0x1c0>
      /* parameters):                                                         */
      /*   - internal measurement paths (VrefInt, ...)                        */
      /*     (set into HAL_ADC_ConfigChannel() )                              */

      /* Configuration of ADC resolution                                      */
      MODIFY_REG(hadc->Instance->CFGR1,
 802d558:	68d3      	ldr	r3, [r2, #12]
 802d55a:	68a5      	ldr	r5, [r4, #8]
                 ADC_CFGR1_RES,
                 hadc->Init.Resolution);

      tmpCFGR2 |= ((hadc->Init.ClockPrescaler & ADC_CFGR2_CKMODE) |
 802d55c:	6866      	ldr	r6, [r4, #4]
      MODIFY_REG(hadc->Instance->CFGR1,
 802d55e:	f023 0318 	bic.w	r3, r3, #24
 802d562:	432b      	orrs	r3, r5
 802d564:	60d3      	str	r3, [r2, #12]
      tmpCFGR2 |= ((hadc->Init.ClockPrescaler & ADC_CFGR2_CKMODE) |
 802d566:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 802d568:	f006 4c40 	and.w	ip, r6, #3221225472	; 0xc0000000
 802d56c:	ea4c 0503 	orr.w	r5, ip, r3
                   hadc->Init.TriggerFrequencyMode
                  );

      if (hadc->Init.OversamplingMode == ENABLE)
 802d570:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
 802d574:	2b01      	cmp	r3, #1
 802d576:	d109      	bne.n	802d58c <HAL_ADC_Init+0x9c>
      {
        tmpCFGR2 |= (ADC_CFGR2_OVSE |
 802d578:	e9d4 3710 	ldrd	r3, r7, [r4, #64]	; 0x40
 802d57c:	433b      	orrs	r3, r7
 802d57e:	432b      	orrs	r3, r5
 802d580:	6ca5      	ldr	r5, [r4, #72]	; 0x48
 802d582:	432b      	orrs	r3, r5
 802d584:	ea43 030c 	orr.w	r3, r3, ip
 802d588:	f043 0501 	orr.w	r5, r3, #1
                     hadc->Init.Oversampling.RightBitShift |
                     hadc->Init.Oversampling.TriggeredMode
                    );
      }

      MODIFY_REG(hadc->Instance->CFGR2,
 802d58c:	6917      	ldr	r7, [r2, #16]
 802d58e:	4b64      	ldr	r3, [pc, #400]	; (802d720 <HAL_ADC_Init+0x230>)
 802d590:	403b      	ands	r3, r7
 802d592:	432b      	orrs	r3, r5
 802d594:	6113      	str	r3, [r2, #16]
                 ADC_CFGR2_TOVS,
                 tmpCFGR2);

      /* Configuration of ADC clock mode: asynchronous clock source           */
      /* with selectable prescaler.                                           */
      if (((hadc->Init.ClockPrescaler) != ADC_CLOCK_SYNC_PCLK_DIV1) &&
 802d596:	f026 4300 	bic.w	r3, r6, #2147483648	; 0x80000000
 802d59a:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 802d59e:	d00a      	beq.n	802d5b6 <HAL_ADC_Init+0xc6>
          ((hadc->Init.ClockPrescaler) != ADC_CLOCK_SYNC_PCLK_DIV2) &&
 802d5a0:	f1b6 4f00 	cmp.w	r6, #2147483648	; 0x80000000
 802d5a4:	d007      	beq.n	802d5b6 <HAL_ADC_Init+0xc6>
          ((hadc->Init.ClockPrescaler) != ADC_CLOCK_SYNC_PCLK_DIV4))
      {
        MODIFY_REG(ADC_COMMON->CCR,
 802d5a6:	4f5f      	ldr	r7, [pc, #380]	; (802d724 <HAL_ADC_Init+0x234>)
 802d5a8:	683b      	ldr	r3, [r7, #0]
 802d5aa:	f406 1670 	and.w	r6, r6, #3932160	; 0x3c0000
 802d5ae:	f423 1370 	bic.w	r3, r3, #3932160	; 0x3c0000
 802d5b2:	431e      	orrs	r6, r3
 802d5b4:	603e      	str	r6, [r7, #0]
    /*  - data alignment                                                      */
    /*  - resolution                                                          */
    /*  - scan direction                                                      */
    /*  - DMA continuous request                                              */
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)      |
                 ADC_CFGR1_AUTOOFF((uint32_t)hadc->Init.LowPowerAutoPowerOff)   |
 802d5b6:	7e63      	ldrb	r3, [r4, #25]
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)      |
 802d5b8:	7e26      	ldrb	r6, [r4, #24]
 802d5ba:	68e7      	ldr	r7, [r4, #12]
                 ADC_CFGR1_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)  |
                 ADC_CFGR1_OVERRUN(hadc->Init.Overrun)                          |
 802d5bc:	f8d4 c030 	ldr.w	ip, [r4, #48]	; 0x30
                 hadc->Init.DataAlign                                           |
                 ADC_SCAN_SEQ_MODE(hadc->Init.ScanConvMode)                     |
                 ADC_CFGR1_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests));
 802d5c0:	f894 802c 	ldrb.w	r8, [r4, #44]	; 0x2c
                 ADC_CFGR1_AUTOOFF((uint32_t)hadc->Init.LowPowerAutoPowerOff)   |
 802d5c4:	03db      	lsls	r3, r3, #15
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)      |
 802d5c6:	ea43 3386 	orr.w	r3, r3, r6, lsl #14
                 ADC_CFGR1_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)  |
 802d5ca:	7ea6      	ldrb	r6, [r4, #26]
 802d5cc:	433b      	orrs	r3, r7
                 ADC_CFGR1_OVERRUN(hadc->Init.Overrun)                          |
 802d5ce:	f1bc 0f00 	cmp.w	ip, #0
 802d5d2:	ea43 3346 	orr.w	r3, r3, r6, lsl #13
 802d5d6:	bf18      	it	ne
 802d5d8:	f44f 5c80 	movne.w	ip, #4096	; 0x1000
                 ADC_SCAN_SEQ_MODE(hadc->Init.ScanConvMode)                     |
 802d5dc:	6927      	ldr	r7, [r4, #16]
 802d5de:	ea43 0348 	orr.w	r3, r3, r8, lsl #1
 802d5e2:	ea43 030c 	orr.w	r3, r3, ip

    /* Update setting of discontinuous mode only if continuous mode is disabled */
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 802d5e6:	f894 c020 	ldrb.w	ip, [r4, #32]
                 ADC_SCAN_SEQ_MODE(hadc->Init.ScanConvMode)                     |
 802d5ea:	2f00      	cmp	r7, #0
 802d5ec:	bfb4      	ite	lt
 802d5ee:	f027 4e00 	biclt.w	lr, r7, #2147483648	; 0x80000000
 802d5f2:	f44f 1e00 	movge.w	lr, #2097152	; 0x200000
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 802d5f6:	f1bc 0f01 	cmp.w	ip, #1
                 ADC_SCAN_SEQ_MODE(hadc->Init.ScanConvMode)                     |
 802d5fa:	ea43 0e0e 	orr.w	lr, r3, lr
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 802d5fe:	d103      	bne.n	802d608 <HAL_ADC_Init+0x118>
    {
      if (hadc->Init.ContinuousConvMode == DISABLE)
 802d600:	2e00      	cmp	r6, #0
 802d602:	d157      	bne.n	802d6b4 <HAL_ADC_Init+0x1c4>
      {
        /* Enable the selected ADC group regular discontinuous mode */
        tmpCFGR1 |= ADC_CFGR1_DISCEN;
 802d604:	f44e 3e80 	orr.w	lr, lr, #65536	; 0x10000
    /* Enable external trigger if trigger selection is different of software  */
    /* start.                                                                 */
    /* Note: This configuration keeps the hardware feature of parameter       */
    /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
    /*       software start.                                                  */
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 802d608:	6a66      	ldr	r6, [r4, #36]	; 0x24
 802d60a:	b12e      	cbz	r6, 802d618 <HAL_ADC_Init+0x128>
    {
      tmpCFGR1 |= ((hadc->Init.ExternalTrigConv & ADC_CFGR1_EXTSEL) |
 802d60c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 802d60e:	f406 76e0 	and.w	r6, r6, #448	; 0x1c0
 802d612:	431e      	orrs	r6, r3
 802d614:	ea4e 0e06 	orr.w	lr, lr, r6
                   hadc->Init.ExternalTrigConvEdge);
    }

    /* Update ADC configuration register with previous settings */
    MODIFY_REG(hadc->Instance->CFGR1,
 802d618:	68d6      	ldr	r6, [r2, #12]
 802d61a:	f426 36fe 	bic.w	r6, r6, #130048	; 0x1fc00
 802d61e:	f426 76f3 	bic.w	r6, r6, #486	; 0x1e6
 802d622:	ea46 060e 	orr.w	r6, r6, lr
 802d626:	60d6      	str	r6, [r2, #12]
               ADC_CFGR1_ALIGN   |
               ADC_CFGR1_SCANDIR |
               ADC_CFGR1_DMACFG,
               tmpCFGR1);

    MODIFY_REG(hadc->Instance->CFGR2,
 802d628:	f8d2 c010 	ldr.w	ip, [r2, #16]
 802d62c:	4e3e      	ldr	r6, [pc, #248]	; (802d728 <HAL_ADC_Init+0x238>)
 802d62e:	ea0c 0606 	and.w	r6, ip, r6
 802d632:	4335      	orrs	r5, r6
 802d634:	6115      	str	r5, [r2, #16]
  MODIFY_REG(ADCx->SMPR,
 802d636:	6955      	ldr	r5, [r2, #20]
 802d638:	6b66      	ldr	r6, [r4, #52]	; 0x34
 802d63a:	f025 0507 	bic.w	r5, r5, #7
 802d63e:	4335      	orrs	r5, r6
 802d640:	6155      	str	r5, [r2, #20]
 802d642:	6955      	ldr	r5, [r2, #20]
 802d644:	6ba6      	ldr	r6, [r4, #56]	; 0x38
 802d646:	f025 0570 	bic.w	r5, r5, #112	; 0x70
 802d64a:	ea45 1506 	orr.w	r5, r5, r6, lsl #4
 802d64e:	6155      	str	r5, [r2, #20]
    /*   emulated by software for alignment over all STM32 devices.           */
    /* - if scan mode is enabled, regular channels sequence length is set to  */
    /*   parameter "NbrOfConversion".                                         */
    /*   Channels must be configured into each rank using function            */
    /*   "HAL_ADC_ConfigChannel()".                                           */
    if (hadc->Init.ScanConvMode == ADC_SCAN_DISABLE)
 802d650:	2f00      	cmp	r7, #0
 802d652:	d138      	bne.n	802d6c6 <HAL_ADC_Init+0x1d6>
      if (ADCGroupRegularSequencerRanksCount == 1UL)
      {
        /* Set ADC group regular sequencer:                                   */
        /* Set sequencer scan length by clearing ranks above rank 1           */
        /* and do not modify rank 1 value.                                    */
        SET_BIT(hadc->Instance->CHSELR,
 802d654:	6a90      	ldr	r0, [r2, #40]	; 0x28
 802d656:	f060 000f 	orn	r0, r0, #15
        /*          therefore after the first call of "HAL_ADC_Init()",       */
        /*          each rank corresponding to parameter "NbrOfConversion"    */
        /*          must be set using "HAL_ADC_ConfigChannel()".              */
        /*  - Set sequencer scan length by clearing ranks above maximum rank  */
        /*    and do not modify other ranks value.                            */
        MODIFY_REG(hadc->Instance->CHSELR,
 802d65a:	6290      	str	r0, [r2, #40]	; 0x28
    /* Check back that ADC registers have effectively been configured to      */
    /* ensure of no potential problem of ADC core peripheral clocking.        */
    /* Check through register CFGR1 (excluding analog watchdog configuration: */
    /* set into separate dedicated function, and bits of ADC resolution set   */
    /* out of temporary variable 'tmpCFGR1').                                 */
    if ((hadc->Instance->CFGR1 & ~(ADC_CFGR1_AWD1CH | ADC_CFGR1_AWD1EN | ADC_CFGR1_AWD1SGL | ADC_CFGR1_RES))
 802d65c:	68d0      	ldr	r0, [r2, #12]
 802d65e:	4a33      	ldr	r2, [pc, #204]	; (802d72c <HAL_ADC_Init+0x23c>)
 802d660:	4002      	ands	r2, r0
 802d662:	4572      	cmp	r2, lr
 802d664:	d14c      	bne.n	802d700 <HAL_ADC_Init+0x210>
        == tmpCFGR1)
    {
      /* Set ADC error code to none */
      ADC_CLEAR_ERRORCODE(hadc);
 802d666:	2300      	movs	r3, #0
 802d668:	65e3      	str	r3, [r4, #92]	; 0x5c

      /* Set the ADC state */
      ADC_STATE_CLR_SET(hadc->State,
 802d66a:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802d66c:	f023 0303 	bic.w	r3, r3, #3
 802d670:	f043 0301 	orr.w	r3, r3, #1
 802d674:	65a3      	str	r3, [r4, #88]	; 0x58

    tmp_hal_status = HAL_ERROR;
  }

  return tmp_hal_status;
}
 802d676:	4608      	mov	r0, r1
 802d678:	b002      	add	sp, #8
 802d67a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  MODIFY_REG(ADCx->CR,
 802d67e:	6883      	ldr	r3, [r0, #8]
    wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 802d680:	4a2b      	ldr	r2, [pc, #172]	; (802d730 <HAL_ADC_Init+0x240>)
 802d682:	f023 4310 	bic.w	r3, r3, #2415919104	; 0x90000000
 802d686:	f023 0317 	bic.w	r3, r3, #23
 802d68a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 802d68e:	6083      	str	r3, [r0, #8]
 802d690:	4b28      	ldr	r3, [pc, #160]	; (802d734 <HAL_ADC_Init+0x244>)
 802d692:	681b      	ldr	r3, [r3, #0]
 802d694:	fbb3 f3f2 	udiv	r3, r3, r2
 802d698:	3301      	adds	r3, #1
 802d69a:	005b      	lsls	r3, r3, #1
      wait_loop_index--;
 802d69c:	9301      	str	r3, [sp, #4]
    while (wait_loop_index != 0UL)
 802d69e:	9b01      	ldr	r3, [sp, #4]
 802d6a0:	2b00      	cmp	r3, #0
 802d6a2:	f43f af39 	beq.w	802d518 <HAL_ADC_Init+0x28>
      wait_loop_index--;
 802d6a6:	9b01      	ldr	r3, [sp, #4]
 802d6a8:	3b01      	subs	r3, #1
 802d6aa:	e7f7      	b.n	802d69c <HAL_ADC_Init+0x1ac>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 802d6ac:	2100      	movs	r1, #0
 802d6ae:	e740      	b.n	802d532 <HAL_ADC_Init+0x42>
  uint32_t tmpCFGR2 = 0UL;
 802d6b0:	4605      	mov	r5, r0
 802d6b2:	e780      	b.n	802d5b6 <HAL_ADC_Init+0xc6>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 802d6b4:	6da6      	ldr	r6, [r4, #88]	; 0x58
 802d6b6:	f046 0620 	orr.w	r6, r6, #32
 802d6ba:	65a6      	str	r6, [r4, #88]	; 0x58
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 802d6bc:	6de6      	ldr	r6, [r4, #92]	; 0x5c
 802d6be:	f046 0601 	orr.w	r6, r6, #1
 802d6c2:	65e6      	str	r6, [r4, #92]	; 0x5c
 802d6c4:	e7a0      	b.n	802d608 <HAL_ADC_Init+0x118>
    else if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
 802d6c6:	f5b7 1f00 	cmp.w	r7, #2097152	; 0x200000
 802d6ca:	d1c7      	bne.n	802d65c <HAL_ADC_Init+0x16c>
        if (((hadc->ADCGroupRegularSequencerRanks >> (ADCGroupRegularSequencerRanksCount * 4UL)) & ADC_CHSELR_SQ1) ==
 802d6cc:	6e26      	ldr	r6, [r4, #96]	; 0x60
 802d6ce:	0085      	lsls	r5, r0, #2
 802d6d0:	fa26 f505 	lsr.w	r5, r6, r5
 802d6d4:	f005 050f 	and.w	r5, r5, #15
 802d6d8:	2d0f      	cmp	r5, #15
 802d6da:	d00e      	beq.n	802d6fa <HAL_ADC_Init+0x20a>
      for (ADCGroupRegularSequencerRanksCount = 0UL; ADCGroupRegularSequencerRanksCount < (8UL); ADCGroupRegularSequencerRanksCount++)
 802d6dc:	3001      	adds	r0, #1
 802d6de:	2808      	cmp	r0, #8
 802d6e0:	d1f5      	bne.n	802d6ce <HAL_ADC_Init+0x1de>
        MODIFY_REG(hadc->Instance->CHSELR,
 802d6e2:	6a90      	ldr	r0, [r2, #40]	; 0x28
 802d6e4:	69e0      	ldr	r0, [r4, #28]
 802d6e6:	3801      	subs	r0, #1
 802d6e8:	0080      	lsls	r0, r0, #2
 802d6ea:	f000 001c 	and.w	r0, r0, #28
 802d6ee:	f06f 050f 	mvn.w	r5, #15
 802d6f2:	fa05 f000 	lsl.w	r0, r5, r0
 802d6f6:	4330      	orrs	r0, r6
 802d6f8:	e7af      	b.n	802d65a <HAL_ADC_Init+0x16a>
      if (ADCGroupRegularSequencerRanksCount == 1UL)
 802d6fa:	2801      	cmp	r0, #1
 802d6fc:	d0aa      	beq.n	802d654 <HAL_ADC_Init+0x164>
 802d6fe:	e7f0      	b.n	802d6e2 <HAL_ADC_Init+0x1f2>
      ADC_STATE_CLR_SET(hadc->State,
 802d700:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802d702:	f023 0312 	bic.w	r3, r3, #18
 802d706:	f043 0310 	orr.w	r3, r3, #16
 802d70a:	65a3      	str	r3, [r4, #88]	; 0x58
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 802d70c:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 802d70e:	f043 0301 	orr.w	r3, r3, #1
 802d712:	65e3      	str	r3, [r4, #92]	; 0x5c
    return HAL_ERROR;
 802d714:	2101      	movs	r1, #1
 802d716:	e7ae      	b.n	802d676 <HAL_ADC_Init+0x186>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 802d718:	f043 0310 	orr.w	r3, r3, #16
 802d71c:	65a3      	str	r3, [r4, #88]	; 0x58
    tmp_hal_status = HAL_ERROR;
 802d71e:	e7f9      	b.n	802d714 <HAL_ADC_Init+0x224>
 802d720:	1ffffc02 	.word	0x1ffffc02
 802d724:	40012708 	.word	0x40012708
 802d728:	dffffc02 	.word	0xdffffc02
 802d72c:	833fffe7 	.word	0x833fffe7
 802d730:	00030d40 	.word	0x00030d40
 802d734:	2000344c 	.word	0x2000344c

0802d738 <HAL_ADC_PollForConversion>:
  * @param hadc ADC handle
  * @param Timeout Timeout value in millisecond.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef *hadc, uint32_t Timeout)
{
 802d738:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  /* If end of conversion selected to end of sequence conversions */
  if (hadc->Init.EOCSelection == ADC_EOC_SEQ_CONV)
 802d73a:	6945      	ldr	r5, [r0, #20]
 802d73c:	2d08      	cmp	r5, #8
{
 802d73e:	4604      	mov	r4, r0
 802d740:	460e      	mov	r6, r1
  if (hadc->Init.EOCSelection == ADC_EOC_SEQ_CONV)
 802d742:	d00a      	beq.n	802d75a <HAL_ADC_PollForConversion+0x22>
    /* each conversion:                                                       */
    /* Particular case is ADC configured in DMA mode and ADC sequencer with   */
    /* several ranks and polling for end of each conversion.                  */
    /* For code simplicity sake, this particular case is generalized to       */
    /* ADC configured in DMA mode and and polling for end of each conversion. */
    if ((hadc->Instance->CFGR1 & ADC_CFGR1_DMAEN) != 0UL)
 802d744:	6803      	ldr	r3, [r0, #0]
 802d746:	68db      	ldr	r3, [r3, #12]
 802d748:	07d9      	lsls	r1, r3, #31
 802d74a:	d505      	bpl.n	802d758 <HAL_ADC_PollForConversion+0x20>
    {
      /* Update ADC state machine to error */
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 802d74c:	6d83      	ldr	r3, [r0, #88]	; 0x58
 802d74e:	f043 0320 	orr.w	r3, r3, #32
 802d752:	6583      	str	r3, [r0, #88]	; 0x58

      return HAL_ERROR;
 802d754:	2001      	movs	r0, #1
    __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS));
  }

  /* Return function status */
  return HAL_OK;
}
 802d756:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      tmp_flag_end = (ADC_FLAG_EOC);
 802d758:	2504      	movs	r5, #4
  tickstart = HAL_GetTick();
 802d75a:	f7fe ff73 	bl	802c644 <HAL_GetTick>
 802d75e:	4607      	mov	r7, r0
  while ((hadc->Instance->ISR & tmp_flag_end) == 0UL)
 802d760:	6820      	ldr	r0, [r4, #0]
 802d762:	6803      	ldr	r3, [r0, #0]
 802d764:	422b      	tst	r3, r5
 802d766:	d022      	beq.n	802d7ae <HAL_ADC_PollForConversion+0x76>
  SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
 802d768:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802d76a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 802d76e:	65a3      	str	r3, [r4, #88]	; 0x58
  return ((READ_BIT(ADCx->CFGR1, ADC_CFGR1_EXTEN) == (LL_ADC_REG_TRIG_SOFTWARE & ADC_CFGR1_EXTEN)) ? 1UL : 0UL);
 802d770:	68c3      	ldr	r3, [r0, #12]
 802d772:	f413 6f40 	tst.w	r3, #3072	; 0xc00
 802d776:	d114      	bne.n	802d7a2 <HAL_ADC_PollForConversion+0x6a>
      && (hadc->Init.ContinuousConvMode == DISABLE)
 802d778:	7ea3      	ldrb	r3, [r4, #26]
 802d77a:	b993      	cbnz	r3, 802d7a2 <HAL_ADC_PollForConversion+0x6a>
    if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS))
 802d77c:	6803      	ldr	r3, [r0, #0]
 802d77e:	071b      	lsls	r3, r3, #28
 802d780:	d50f      	bpl.n	802d7a2 <HAL_ADC_PollForConversion+0x6a>
      if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 802d782:	f7ff feb1 	bl	802d4e8 <LL_ADC_REG_IsConversionOngoing>
 802d786:	bb38      	cbnz	r0, 802d7d8 <HAL_ADC_PollForConversion+0xa0>
        __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC | ADC_IT_EOS);
 802d788:	6822      	ldr	r2, [r4, #0]
 802d78a:	6853      	ldr	r3, [r2, #4]
 802d78c:	f023 030c 	bic.w	r3, r3, #12
 802d790:	6053      	str	r3, [r2, #4]
        ADC_STATE_CLR_SET(hadc->State,
 802d792:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802d794:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 802d798:	f023 0301 	bic.w	r3, r3, #1
 802d79c:	f043 0301 	orr.w	r3, r3, #1
 802d7a0:	65a3      	str	r3, [r4, #88]	; 0x58
  if (hadc->Init.LowPowerAutoWait == DISABLE)
 802d7a2:	7e20      	ldrb	r0, [r4, #24]
 802d7a4:	bb08      	cbnz	r0, 802d7ea <HAL_ADC_PollForConversion+0xb2>
    __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS));
 802d7a6:	6823      	ldr	r3, [r4, #0]
 802d7a8:	220c      	movs	r2, #12
 802d7aa:	601a      	str	r2, [r3, #0]
 802d7ac:	e7d3      	b.n	802d756 <HAL_ADC_PollForConversion+0x1e>
    if (Timeout != HAL_MAX_DELAY)
 802d7ae:	1c72      	adds	r2, r6, #1
 802d7b0:	d0d7      	beq.n	802d762 <HAL_ADC_PollForConversion+0x2a>
      if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0UL))
 802d7b2:	f7fe ff47 	bl	802c644 <HAL_GetTick>
 802d7b6:	1bc0      	subs	r0, r0, r7
 802d7b8:	42b0      	cmp	r0, r6
 802d7ba:	d801      	bhi.n	802d7c0 <HAL_ADC_PollForConversion+0x88>
 802d7bc:	2e00      	cmp	r6, #0
 802d7be:	d1cf      	bne.n	802d760 <HAL_ADC_PollForConversion+0x28>
        if ((hadc->Instance->ISR & tmp_flag_end) == 0UL)
 802d7c0:	6823      	ldr	r3, [r4, #0]
 802d7c2:	681b      	ldr	r3, [r3, #0]
 802d7c4:	402b      	ands	r3, r5
 802d7c6:	d1cb      	bne.n	802d760 <HAL_ADC_PollForConversion+0x28>
          SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 802d7c8:	6da2      	ldr	r2, [r4, #88]	; 0x58
          __HAL_UNLOCK(hadc);
 802d7ca:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54
          SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 802d7ce:	f042 0204 	orr.w	r2, r2, #4
 802d7d2:	65a2      	str	r2, [r4, #88]	; 0x58
          return HAL_TIMEOUT;
 802d7d4:	2003      	movs	r0, #3
 802d7d6:	e7be      	b.n	802d756 <HAL_ADC_PollForConversion+0x1e>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 802d7d8:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802d7da:	f043 0320 	orr.w	r3, r3, #32
 802d7de:	65a3      	str	r3, [r4, #88]	; 0x58
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 802d7e0:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 802d7e2:	f043 0301 	orr.w	r3, r3, #1
 802d7e6:	65e3      	str	r3, [r4, #92]	; 0x5c
 802d7e8:	e7db      	b.n	802d7a2 <HAL_ADC_PollForConversion+0x6a>
  return HAL_OK;
 802d7ea:	2000      	movs	r0, #0
 802d7ec:	e7b3      	b.n	802d756 <HAL_ADC_PollForConversion+0x1e>

0802d7ee <HAL_ADC_GetValue>:

  /* Note: EOC flag is not cleared here by software because automatically     */
  /*       cleared by hardware when reading register DR.                      */

  /* Return ADC converted value */
  return hadc->Instance->DR;
 802d7ee:	6803      	ldr	r3, [r0, #0]
 802d7f0:	6c18      	ldr	r0, [r3, #64]	; 0x40
}
 802d7f2:	4770      	bx	lr

0802d7f4 <HAL_ADC_ConfigChannel>:
  * @param hadc ADC handle
  * @param pConfig Structure of ADC channel assigned to ADC group regular.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef *hadc, ADC_ChannelConfTypeDef *pConfig)
{
 802d7f4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  uint32_t tmp_config_internal_channel;
  __IO uint32_t wait_loop_index = 0UL;
 802d7f6:	2300      	movs	r3, #0
 802d7f8:	9301      	str	r3, [sp, #4]
    assert_param(IS_ADC_REGULAR_NB_CONV(hadc->Init.NbrOfConversion));

    assert_param(IS_ADC_REGULAR_RANK(pConfig->Rank));
  }

  __HAL_LOCK(hadc);
 802d7fa:	f890 3054 	ldrb.w	r3, [r0, #84]	; 0x54
 802d7fe:	2b01      	cmp	r3, #1
{
 802d800:	4604      	mov	r4, r0
  __HAL_LOCK(hadc);
 802d802:	f000 80bb 	beq.w	802d97c <HAL_ADC_ConfigChannel+0x188>
 802d806:	2301      	movs	r3, #1
 802d808:	f880 3054 	strb.w	r3, [r0, #84]	; 0x54
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Channel number                                                        */
  /*  - Channel sampling time                                                 */
  /*  - Management of internal measurement channels: VrefInt/TempSensor/Vbat  */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 802d80c:	6800      	ldr	r0, [r0, #0]
 802d80e:	f7ff fe6b 	bl	802d4e8 <LL_ADC_REG_IsConversionOngoing>
 802d812:	2800      	cmp	r0, #0
 802d814:	f040 80ac 	bne.w	802d970 <HAL_ADC_ConfigChannel+0x17c>
    /* If sequencer set to not fully configurable with channel rank set to    */
    /* none, remove the channel from the sequencer.                           */
    /* Otherwise (sequencer set to fully configurable or to to not fully      */
    /* configurable with channel rank to be set), configure the selected      */
    /* channel.                                                               */
    if (pConfig->Rank != ADC_RANK_NONE)
 802d818:	6848      	ldr	r0, [r1, #4]
 802d81a:	6923      	ldr	r3, [r4, #16]
 802d81c:	680a      	ldr	r2, [r1, #0]
 802d81e:	2802      	cmp	r0, #2
 802d820:	f023 0304 	bic.w	r3, r3, #4
 802d824:	d07c      	beq.n	802d920 <HAL_ADC_ConfigChannel+0x12c>
      /* Note: ADC channel configuration requires few ADC clock cycles        */
      /*       to be ready. Processing of ADC settings in this function       */
      /*       induce that a specific wait time is not necessary.             */
      /*       For more details on ADC channel configuration ready,           */
      /*       refer to function "LL_ADC_IsActiveFlag_CCRDY()".               */
      if ((hadc->Init.ScanConvMode == ADC_SCAN_SEQ_FIXED)       ||
 802d826:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 802d82a:	6825      	ldr	r5, [r4, #0]
 802d82c:	f3c2 0e11 	ubfx	lr, r2, #0, #18
 802d830:	d113      	bne.n	802d85a <HAL_ADC_ConfigChannel+0x66>
  SET_BIT(ADCx->CHSELR, (Channel & ADC_CHANNEL_ID_BITFIELD_MASK));
 802d832:	6aab      	ldr	r3, [r5, #40]	; 0x28
 802d834:	ea43 030e 	orr.w	r3, r3, lr
  MODIFY_REG(ADCx->CHSELR,
 802d838:	62ab      	str	r3, [r5, #40]	; 0x28
  MODIFY_REG(ADCx->SMPR,
 802d83a:	688b      	ldr	r3, [r1, #8]
 802d83c:	6968      	ldr	r0, [r5, #20]
 802d83e:	ea03 2302 	and.w	r3, r3, r2, lsl #8
 802d842:	f023 437c 	bic.w	r3, r3, #4227858432	; 0xfc000000
 802d846:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 802d84a:	ea20 2102 	bic.w	r1, r0, r2, lsl #8
 802d84e:	430b      	orrs	r3, r1
      /* internal measurement paths enable: If internal channel selected,     */
      /* enable dedicated internal buffers and path.                          */
      /* Note: these internal measurement paths can be disabled using         */
      /*       HAL_ADC_DeInit() or removing the channel from sequencer with   */
      /*       channel configuration parameter "Rank".                        */
      if (__LL_ADC_IS_CHANNEL_INTERNAL(pConfig->Channel))
 802d850:	2a00      	cmp	r2, #0
 802d852:	616b      	str	r3, [r5, #20]
 802d854:	db26      	blt.n	802d8a4 <HAL_ADC_ConfigChannel+0xb0>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 802d856:	2000      	movs	r0, #0
}
 802d858:	e050      	b.n	802d8fc <HAL_ADC_ConfigChannel+0x108>
        MODIFY_REG(hadc->ADCGroupRegularSequencerRanks,
 802d85a:	6e23      	ldr	r3, [r4, #96]	; 0x60
 802d85c:	f000 071f 	and.w	r7, r0, #31
 802d860:	f04f 0c0f 	mov.w	ip, #15
 802d864:	fa0c fc07 	lsl.w	ip, ip, r7
 802d868:	ea6f 060c 	mvn.w	r6, ip
 802d86c:	ea23 0c0c 	bic.w	ip, r3, ip
 802d870:	f1be 0f00 	cmp.w	lr, #0
 802d874:	d111      	bne.n	802d89a <HAL_ADC_ConfigChannel+0xa6>
 802d876:	f3c2 6384 	ubfx	r3, r2, #26, #5
 802d87a:	40bb      	lsls	r3, r7
 802d87c:	ea43 030c 	orr.w	r3, r3, ip
 802d880:	6623      	str	r3, [r4, #96]	; 0x60
        if (((pConfig->Rank >> 2UL) + 1UL) <= hadc->Init.NbrOfConversion)
 802d882:	0880      	lsrs	r0, r0, #2
 802d884:	69e3      	ldr	r3, [r4, #28]
 802d886:	3001      	adds	r0, #1
 802d888:	4298      	cmp	r0, r3
 802d88a:	d8d6      	bhi.n	802d83a <HAL_ADC_ConfigChannel+0x46>
  MODIFY_REG(ADCx->CHSELR,
 802d88c:	6aa8      	ldr	r0, [r5, #40]	; 0x28
 802d88e:	f3c2 6383 	ubfx	r3, r2, #26, #4
 802d892:	40bb      	lsls	r3, r7
 802d894:	4006      	ands	r6, r0
 802d896:	4333      	orrs	r3, r6
 802d898:	e7ce      	b.n	802d838 <HAL_ADC_ConfigChannel+0x44>
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 802d89a:	fa92 f3a2 	rbit	r3, r2
   */
  if (value == 0U)
  {
    return 32U;
  }
  return __builtin_clz(value);
 802d89e:	fab3 f383 	clz	r3, r3
 802d8a2:	e7ea      	b.n	802d87a <HAL_ADC_ConfigChannel+0x86>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 802d8a4:	4936      	ldr	r1, [pc, #216]	; (802d980 <HAL_ADC_ConfigChannel+0x18c>)
      {
        tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));

        /* If the requested internal measurement path has already been enabled,   */
        /* bypass the configuration processing.                                   */
        if ((pConfig->Channel == ADC_CHANNEL_TEMPSENSOR) &&
 802d8a6:	4837      	ldr	r0, [pc, #220]	; (802d984 <HAL_ADC_ConfigChannel+0x190>)
 802d8a8:	680b      	ldr	r3, [r1, #0]
 802d8aa:	4282      	cmp	r2, r0
 802d8ac:	f003 75e0 	and.w	r5, r3, #29360128	; 0x1c00000
 802d8b0:	d117      	bne.n	802d8e2 <HAL_ADC_ConfigChannel+0xee>
 802d8b2:	021b      	lsls	r3, r3, #8
 802d8b4:	d4cf      	bmi.n	802d856 <HAL_ADC_ConfigChannel+0x62>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 802d8b6:	680b      	ldr	r3, [r1, #0]
          /* Delay for temperature sensor stabilization time */
          /* Wait loop initialization and execution */
          /* Note: Variable divided by 2 to compensate partially              */
          /*       CPU processing cycles, scaling in us split to not          */
          /*       exceed 32 bits register capacity and handle low frequency. */
          wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 802d8b8:	4a33      	ldr	r2, [pc, #204]	; (802d988 <HAL_ADC_ConfigChannel+0x194>)
 802d8ba:	f023 73e0 	bic.w	r3, r3, #29360128	; 0x1c00000
 802d8be:	432b      	orrs	r3, r5
 802d8c0:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 802d8c4:	600b      	str	r3, [r1, #0]
 802d8c6:	4b31      	ldr	r3, [pc, #196]	; (802d98c <HAL_ADC_ConfigChannel+0x198>)
 802d8c8:	681b      	ldr	r3, [r3, #0]
 802d8ca:	fbb3 f2f2 	udiv	r2, r3, r2
 802d8ce:	230c      	movs	r3, #12
 802d8d0:	fb02 3303 	mla	r3, r2, r3, r3
          while (wait_loop_index != 0UL)
          {
            wait_loop_index--;
 802d8d4:	9301      	str	r3, [sp, #4]
          while (wait_loop_index != 0UL)
 802d8d6:	9b01      	ldr	r3, [sp, #4]
 802d8d8:	2b00      	cmp	r3, #0
 802d8da:	d0bc      	beq.n	802d856 <HAL_ADC_ConfigChannel+0x62>
            wait_loop_index--;
 802d8dc:	9b01      	ldr	r3, [sp, #4]
 802d8de:	3b01      	subs	r3, #1
 802d8e0:	e7f8      	b.n	802d8d4 <HAL_ADC_ConfigChannel+0xe0>
          }
        }
        else if ((pConfig->Channel == ADC_CHANNEL_VBAT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
 802d8e2:	482b      	ldr	r0, [pc, #172]	; (802d990 <HAL_ADC_ConfigChannel+0x19c>)
 802d8e4:	4282      	cmp	r2, r0
 802d8e6:	d10e      	bne.n	802d906 <HAL_ADC_ConfigChannel+0x112>
 802d8e8:	f013 7080 	ands.w	r0, r3, #16777216	; 0x1000000
 802d8ec:	d1b3      	bne.n	802d856 <HAL_ADC_ConfigChannel+0x62>
 802d8ee:	680b      	ldr	r3, [r1, #0]
 802d8f0:	f023 73e0 	bic.w	r3, r3, #29360128	; 0x1c00000
 802d8f4:	432b      	orrs	r3, r5
 802d8f6:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 802d8fa:	600b      	str	r3, [r1, #0]
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);

    tmp_hal_status = HAL_ERROR;
  }

  __HAL_UNLOCK(hadc);
 802d8fc:	2300      	movs	r3, #0
 802d8fe:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54

  return tmp_hal_status;
}
 802d902:	b003      	add	sp, #12
 802d904:	bdf0      	pop	{r4, r5, r6, r7, pc}
        else if ((pConfig->Channel == ADC_CHANNEL_VREFINT) &&
 802d906:	4823      	ldr	r0, [pc, #140]	; (802d994 <HAL_ADC_ConfigChannel+0x1a0>)
 802d908:	4282      	cmp	r2, r0
 802d90a:	d1a4      	bne.n	802d856 <HAL_ADC_ConfigChannel+0x62>
 802d90c:	f413 0080 	ands.w	r0, r3, #4194304	; 0x400000
 802d910:	d1a1      	bne.n	802d856 <HAL_ADC_ConfigChannel+0x62>
 802d912:	680b      	ldr	r3, [r1, #0]
 802d914:	f023 73e0 	bic.w	r3, r3, #29360128	; 0x1c00000
 802d918:	432b      	orrs	r3, r5
 802d91a:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 802d91e:	e7ec      	b.n	802d8fa <HAL_ADC_ConfigChannel+0x106>
      if ((hadc->Init.ScanConvMode == ADC_SCAN_SEQ_FIXED)       ||
 802d920:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 802d924:	d106      	bne.n	802d934 <HAL_ADC_ConfigChannel+0x140>
        LL_ADC_REG_SetSequencerChRem(hadc->Instance, pConfig->Channel);
 802d926:	6821      	ldr	r1, [r4, #0]
  CLEAR_BIT(ADCx->CHSELR, (Channel & ADC_CHANNEL_ID_BITFIELD_MASK));
 802d928:	6a8b      	ldr	r3, [r1, #40]	; 0x28
 802d92a:	f3c2 0011 	ubfx	r0, r2, #0, #18
 802d92e:	ea23 0300 	bic.w	r3, r3, r0
 802d932:	628b      	str	r3, [r1, #40]	; 0x28
      if (__LL_ADC_IS_CHANNEL_INTERNAL(pConfig->Channel))
 802d934:	2a00      	cmp	r2, #0
 802d936:	da8e      	bge.n	802d856 <HAL_ADC_ConfigChannel+0x62>
        if (pConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 802d938:	4812      	ldr	r0, [pc, #72]	; (802d984 <HAL_ADC_ConfigChannel+0x190>)
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 802d93a:	4911      	ldr	r1, [pc, #68]	; (802d980 <HAL_ADC_ConfigChannel+0x18c>)
 802d93c:	4282      	cmp	r2, r0
 802d93e:	680b      	ldr	r3, [r1, #0]
 802d940:	d107      	bne.n	802d952 <HAL_ADC_ConfigChannel+0x15e>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 802d942:	680a      	ldr	r2, [r1, #0]
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 802d944:	f003 73a0 	and.w	r3, r3, #20971520	; 0x1400000
 802d948:	f022 72e0 	bic.w	r2, r2, #29360128	; 0x1c00000
 802d94c:	4313      	orrs	r3, r2
 802d94e:	600b      	str	r3, [r1, #0]
 802d950:	e781      	b.n	802d856 <HAL_ADC_ConfigChannel+0x62>
        else if (pConfig->Channel == ADC_CHANNEL_VBAT)
 802d952:	480f      	ldr	r0, [pc, #60]	; (802d990 <HAL_ADC_ConfigChannel+0x19c>)
 802d954:	4282      	cmp	r2, r0
 802d956:	d103      	bne.n	802d960 <HAL_ADC_ConfigChannel+0x16c>
 802d958:	680a      	ldr	r2, [r1, #0]
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 802d95a:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
 802d95e:	e7f3      	b.n	802d948 <HAL_ADC_ConfigChannel+0x154>
        else if (pConfig->Channel == ADC_CHANNEL_VREFINT)
 802d960:	480c      	ldr	r0, [pc, #48]	; (802d994 <HAL_ADC_ConfigChannel+0x1a0>)
 802d962:	4282      	cmp	r2, r0
 802d964:	f47f af77 	bne.w	802d856 <HAL_ADC_ConfigChannel+0x62>
 802d968:	680a      	ldr	r2, [r1, #0]
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 802d96a:	f003 73c0 	and.w	r3, r3, #25165824	; 0x1800000
 802d96e:	e7eb      	b.n	802d948 <HAL_ADC_ConfigChannel+0x154>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 802d970:	6da2      	ldr	r2, [r4, #88]	; 0x58
 802d972:	f042 0220 	orr.w	r2, r2, #32
 802d976:	65a2      	str	r2, [r4, #88]	; 0x58
    tmp_hal_status = HAL_ERROR;
 802d978:	4618      	mov	r0, r3
 802d97a:	e7bf      	b.n	802d8fc <HAL_ADC_ConfigChannel+0x108>
  __HAL_LOCK(hadc);
 802d97c:	2002      	movs	r0, #2
 802d97e:	e7c0      	b.n	802d902 <HAL_ADC_ConfigChannel+0x10e>
 802d980:	40012708 	.word	0x40012708
 802d984:	b0001000 	.word	0xb0001000
 802d988:	00030d40 	.word	0x00030d40
 802d98c:	2000344c 	.word	0x2000344c
 802d990:	b8004000 	.word	0xb8004000
 802d994:	b4002000 	.word	0xb4002000

0802d998 <ADC_ConversionStop>:
  *         stopped to disable the ADC.
  * @param  hadc ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_ConversionStop(ADC_HandleTypeDef *hadc)
{
 802d998:	b538      	push	{r3, r4, r5, lr}
 802d99a:	4604      	mov	r4, r0
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  /* Verification if ADC is not already stopped on regular group to bypass    */
  /* this function if not needed.                                             */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) != 0UL)
 802d99c:	6800      	ldr	r0, [r0, #0]
 802d99e:	f7ff fda3 	bl	802d4e8 <LL_ADC_REG_IsConversionOngoing>
 802d9a2:	b908      	cbnz	r0, 802d9a8 <ADC_ConversionStop+0x10>
    }

  }

  /* Return HAL status */
  return HAL_OK;
 802d9a4:	2000      	movs	r0, #0
}
 802d9a6:	bd38      	pop	{r3, r4, r5, pc}
    if (LL_ADC_IsDisableOngoing(hadc->Instance) == 0UL)
 802d9a8:	6822      	ldr	r2, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADDIS) == (ADC_CR_ADDIS)) ? 1UL : 0UL);
 802d9aa:	6893      	ldr	r3, [r2, #8]
 802d9ac:	0799      	lsls	r1, r3, #30
 802d9ae:	d407      	bmi.n	802d9c0 <ADC_ConversionStop+0x28>
  MODIFY_REG(ADCx->CR,
 802d9b0:	6893      	ldr	r3, [r2, #8]
 802d9b2:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802d9b6:	f023 0317 	bic.w	r3, r3, #23
 802d9ba:	f043 0310 	orr.w	r3, r3, #16
 802d9be:	6093      	str	r3, [r2, #8]
    tickstart = HAL_GetTick();
 802d9c0:	f7fe fe40 	bl	802c644 <HAL_GetTick>
 802d9c4:	4605      	mov	r5, r0
    while ((hadc->Instance->CR & ADC_CR_ADSTART) != 0UL)
 802d9c6:	6823      	ldr	r3, [r4, #0]
 802d9c8:	689b      	ldr	r3, [r3, #8]
 802d9ca:	075b      	lsls	r3, r3, #29
 802d9cc:	d5ea      	bpl.n	802d9a4 <ADC_ConversionStop+0xc>
      if ((HAL_GetTick() - tickstart) > ADC_STOP_CONVERSION_TIMEOUT)
 802d9ce:	f7fe fe39 	bl	802c644 <HAL_GetTick>
 802d9d2:	1b40      	subs	r0, r0, r5
 802d9d4:	2802      	cmp	r0, #2
 802d9d6:	d9f6      	bls.n	802d9c6 <ADC_ConversionStop+0x2e>
        if ((hadc->Instance->CR & ADC_CR_ADSTART) != 0UL)
 802d9d8:	6823      	ldr	r3, [r4, #0]
 802d9da:	689b      	ldr	r3, [r3, #8]
 802d9dc:	075a      	lsls	r2, r3, #29
 802d9de:	d5f2      	bpl.n	802d9c6 <ADC_ConversionStop+0x2e>
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 802d9e0:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802d9e2:	f043 0310 	orr.w	r3, r3, #16
 802d9e6:	65a3      	str	r3, [r4, #88]	; 0x58
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 802d9e8:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 802d9ea:	f043 0301 	orr.w	r3, r3, #1
 802d9ee:	65e3      	str	r3, [r4, #92]	; 0x5c
 802d9f0:	2001      	movs	r0, #1
 802d9f2:	e7d8      	b.n	802d9a6 <ADC_ConversionStop+0xe>

0802d9f4 <ADC_Enable>:
  *         and voltage regulator must be enabled (done into HAL_ADC_Init()).
  * @param hadc ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_Enable(ADC_HandleTypeDef *hadc)
{
 802d9f4:	b573      	push	{r0, r1, r4, r5, r6, lr}
  uint32_t tickstart;
  __IO uint32_t wait_loop_index = 0UL;
 802d9f6:	2300      	movs	r3, #0

  /* ADC enable and wait for ADC ready (in case of ADC is disabled or         */
  /* enabling phase not yet completed: flag ADC ready not yet set).           */
  /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
  /* causes: ADC clock not running, ...).                                     */
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 802d9f8:	6802      	ldr	r2, [r0, #0]
  __IO uint32_t wait_loop_index = 0UL;
 802d9fa:	9301      	str	r3, [sp, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 802d9fc:	6893      	ldr	r3, [r2, #8]
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 802d9fe:	07dd      	lsls	r5, r3, #31
{
 802da00:	4604      	mov	r4, r0
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 802da02:	d502      	bpl.n	802da0a <ADC_Enable+0x16>
      }
    }
  }

  /* Return HAL status */
  return HAL_OK;
 802da04:	2000      	movs	r0, #0
}
 802da06:	b002      	add	sp, #8
 802da08:	bd70      	pop	{r4, r5, r6, pc}
    if ((hadc->Instance->CR & (ADC_CR_ADCAL | ADC_CR_ADSTP | ADC_CR_ADSTART | ADC_CR_ADDIS | ADC_CR_ADEN)) != 0UL)
 802da0a:	6891      	ldr	r1, [r2, #8]
 802da0c:	4b21      	ldr	r3, [pc, #132]	; (802da94 <ADC_Enable+0xa0>)
 802da0e:	4219      	tst	r1, r3
 802da10:	d009      	beq.n	802da26 <ADC_Enable+0x32>
            SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 802da12:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802da14:	f043 0310 	orr.w	r3, r3, #16
 802da18:	65a3      	str	r3, [r4, #88]	; 0x58
            SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 802da1a:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 802da1c:	f043 0301 	orr.w	r3, r3, #1
 802da20:	65e3      	str	r3, [r4, #92]	; 0x5c
            return HAL_ERROR;
 802da22:	2001      	movs	r0, #1
 802da24:	e7ef      	b.n	802da06 <ADC_Enable+0x12>
  MODIFY_REG(ADCx->CR,
 802da26:	6893      	ldr	r3, [r2, #8]
 802da28:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802da2c:	f023 0317 	bic.w	r3, r3, #23
 802da30:	f043 0301 	orr.w	r3, r3, #1
 802da34:	6093      	str	r3, [r2, #8]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 802da36:	4b18      	ldr	r3, [pc, #96]	; (802da98 <ADC_Enable+0xa4>)
 802da38:	681b      	ldr	r3, [r3, #0]
    if ((LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) & LL_ADC_PATH_INTERNAL_TEMPSENSOR) != 0UL)
 802da3a:	0218      	lsls	r0, r3, #8
 802da3c:	d41c      	bmi.n	802da78 <ADC_Enable+0x84>
    if (hadc->Init.LowPowerAutoPowerOff != ENABLE)
 802da3e:	7e63      	ldrb	r3, [r4, #25]
 802da40:	2b01      	cmp	r3, #1
 802da42:	d0df      	beq.n	802da04 <ADC_Enable+0x10>
      tickstart = HAL_GetTick();
 802da44:	f7fe fdfe 	bl	802c644 <HAL_GetTick>
  MODIFY_REG(ADCx->CR,
 802da48:	4e14      	ldr	r6, [pc, #80]	; (802da9c <ADC_Enable+0xa8>)
 802da4a:	4605      	mov	r5, r0
      while (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
 802da4c:	6822      	ldr	r2, [r4, #0]
 802da4e:	6813      	ldr	r3, [r2, #0]
 802da50:	07db      	lsls	r3, r3, #31
 802da52:	d4d7      	bmi.n	802da04 <ADC_Enable+0x10>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 802da54:	6893      	ldr	r3, [r2, #8]
        if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 802da56:	07d9      	lsls	r1, r3, #31
  MODIFY_REG(ADCx->CR,
 802da58:	bf5f      	itttt	pl
 802da5a:	6893      	ldrpl	r3, [r2, #8]
 802da5c:	4033      	andpl	r3, r6
 802da5e:	f043 0301 	orrpl.w	r3, r3, #1
 802da62:	6093      	strpl	r3, [r2, #8]
        if ((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
 802da64:	f7fe fdee 	bl	802c644 <HAL_GetTick>
 802da68:	1b40      	subs	r0, r0, r5
 802da6a:	2802      	cmp	r0, #2
 802da6c:	d9ee      	bls.n	802da4c <ADC_Enable+0x58>
          if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
 802da6e:	6823      	ldr	r3, [r4, #0]
 802da70:	681b      	ldr	r3, [r3, #0]
 802da72:	07da      	lsls	r2, r3, #31
 802da74:	d4ea      	bmi.n	802da4c <ADC_Enable+0x58>
 802da76:	e7cc      	b.n	802da12 <ADC_Enable+0x1e>
      wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_BUFFER_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 802da78:	4b09      	ldr	r3, [pc, #36]	; (802daa0 <ADC_Enable+0xac>)
 802da7a:	4a0a      	ldr	r2, [pc, #40]	; (802daa4 <ADC_Enable+0xb0>)
 802da7c:	681b      	ldr	r3, [r3, #0]
 802da7e:	fbb3 f3f2 	udiv	r3, r3, r2
 802da82:	3301      	adds	r3, #1
        wait_loop_index--;
 802da84:	9301      	str	r3, [sp, #4]
      while (wait_loop_index != 0UL)
 802da86:	9b01      	ldr	r3, [sp, #4]
 802da88:	2b00      	cmp	r3, #0
 802da8a:	d0d8      	beq.n	802da3e <ADC_Enable+0x4a>
        wait_loop_index--;
 802da8c:	9b01      	ldr	r3, [sp, #4]
 802da8e:	3b01      	subs	r3, #1
 802da90:	e7f8      	b.n	802da84 <ADC_Enable+0x90>
 802da92:	bf00      	nop
 802da94:	80000017 	.word	0x80000017
 802da98:	40012708 	.word	0x40012708
 802da9c:	7fffffe8 	.word	0x7fffffe8
 802daa0:	2000344c 	.word	0x2000344c
 802daa4:	00030d40 	.word	0x00030d40

0802daa8 <HAL_ADC_Start>:
{
 802daa8:	b538      	push	{r3, r4, r5, lr}
 802daaa:	4604      	mov	r4, r0
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 802daac:	6800      	ldr	r0, [r0, #0]
 802daae:	f7ff fd1b 	bl	802d4e8 <LL_ADC_REG_IsConversionOngoing>
 802dab2:	4605      	mov	r5, r0
 802dab4:	bb20      	cbnz	r0, 802db00 <HAL_ADC_Start+0x58>
    __HAL_LOCK(hadc);
 802dab6:	f894 3054 	ldrb.w	r3, [r4, #84]	; 0x54
 802daba:	2b01      	cmp	r3, #1
 802dabc:	d020      	beq.n	802db00 <HAL_ADC_Start+0x58>
 802dabe:	2301      	movs	r3, #1
 802dac0:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54
    tmp_hal_status = ADC_Enable(hadc);
 802dac4:	4620      	mov	r0, r4
 802dac6:	f7ff ff95 	bl	802d9f4 <ADC_Enable>
    if (tmp_hal_status == HAL_OK)
 802daca:	b9b0      	cbnz	r0, 802dafa <HAL_ADC_Start+0x52>
      ADC_STATE_CLR_SET(hadc->State,
 802dacc:	6da3      	ldr	r3, [r4, #88]	; 0x58
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 802dace:	6822      	ldr	r2, [r4, #0]
      ADC_STATE_CLR_SET(hadc->State,
 802dad0:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 802dad4:	f023 0301 	bic.w	r3, r3, #1
 802dad8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 802dadc:	65a3      	str	r3, [r4, #88]	; 0x58
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 802dade:	231c      	movs	r3, #28
      ADC_CLEAR_ERRORCODE(hadc);
 802dae0:	65e0      	str	r0, [r4, #92]	; 0x5c
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 802dae2:	6013      	str	r3, [r2, #0]
      __HAL_UNLOCK(hadc);
 802dae4:	f884 0054 	strb.w	r0, [r4, #84]	; 0x54
  MODIFY_REG(ADCx->CR,
 802dae8:	6893      	ldr	r3, [r2, #8]
 802daea:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802daee:	f023 0317 	bic.w	r3, r3, #23
 802daf2:	f043 0304 	orr.w	r3, r3, #4
 802daf6:	6093      	str	r3, [r2, #8]
}
 802daf8:	bd38      	pop	{r3, r4, r5, pc}
      __HAL_UNLOCK(hadc);
 802dafa:	f884 5054 	strb.w	r5, [r4, #84]	; 0x54
 802dafe:	e7fb      	b.n	802daf8 <HAL_ADC_Start+0x50>
    tmp_hal_status = HAL_BUSY;
 802db00:	2002      	movs	r0, #2
 802db02:	e7f9      	b.n	802daf8 <HAL_ADC_Start+0x50>

0802db04 <ADC_Disable>:
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_Disable(ADC_HandleTypeDef *hadc)
{
  uint32_t tickstart;
  const uint32_t tmp_adc_is_disable_on_going = LL_ADC_IsDisableOngoing(hadc->Instance);
 802db04:	6802      	ldr	r2, [r0, #0]
{
 802db06:	b538      	push	{r3, r4, r5, lr}
  return ((READ_BIT(ADCx->CR, ADC_CR_ADDIS) == (ADC_CR_ADDIS)) ? 1UL : 0UL);
 802db08:	6893      	ldr	r3, [r2, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 802db0a:	6891      	ldr	r1, [r2, #8]
 802db0c:	4604      	mov	r4, r0

  /* Verification if ADC is not already disabled:                             */
  /* Note: forbidden to disable ADC (set bit ADC_CR_ADDIS) if ADC is already  */
  /*       disabled.                                                          */
  if ((LL_ADC_IsEnabled(hadc->Instance) != 0UL)
 802db0e:	07c8      	lsls	r0, r1, #31
 802db10:	d401      	bmi.n	802db16 <ADC_Disable+0x12>
      }
    }
  }

  /* Return HAL status */
  return HAL_OK;
 802db12:	2000      	movs	r0, #0
}
 802db14:	bd38      	pop	{r3, r4, r5, pc}
      && (tmp_adc_is_disable_on_going == 0UL)
 802db16:	0799      	lsls	r1, r3, #30
 802db18:	d4fb      	bmi.n	802db12 <ADC_Disable+0xe>
    if ((hadc->Instance->CR & (ADC_CR_ADSTART | ADC_CR_ADEN)) == ADC_CR_ADEN)
 802db1a:	6893      	ldr	r3, [r2, #8]
 802db1c:	f003 0305 	and.w	r3, r3, #5
 802db20:	2b01      	cmp	r3, #1
 802db22:	d119      	bne.n	802db58 <ADC_Disable+0x54>
  MODIFY_REG(ADCx->CR,
 802db24:	6893      	ldr	r3, [r2, #8]
 802db26:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802db2a:	f023 0317 	bic.w	r3, r3, #23
 802db2e:	f043 0302 	orr.w	r3, r3, #2
 802db32:	6093      	str	r3, [r2, #8]
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOSMP | ADC_FLAG_RDY));
 802db34:	2303      	movs	r3, #3
 802db36:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 802db38:	f7fe fd84 	bl	802c644 <HAL_GetTick>
 802db3c:	4605      	mov	r5, r0
    while ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
 802db3e:	6823      	ldr	r3, [r4, #0]
 802db40:	689b      	ldr	r3, [r3, #8]
 802db42:	07db      	lsls	r3, r3, #31
 802db44:	d5e5      	bpl.n	802db12 <ADC_Disable+0xe>
      if ((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
 802db46:	f7fe fd7d 	bl	802c644 <HAL_GetTick>
 802db4a:	1b40      	subs	r0, r0, r5
 802db4c:	2802      	cmp	r0, #2
 802db4e:	d9f6      	bls.n	802db3e <ADC_Disable+0x3a>
        if ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
 802db50:	6823      	ldr	r3, [r4, #0]
 802db52:	689b      	ldr	r3, [r3, #8]
 802db54:	07da      	lsls	r2, r3, #31
 802db56:	d5f2      	bpl.n	802db3e <ADC_Disable+0x3a>
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 802db58:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802db5a:	f043 0310 	orr.w	r3, r3, #16
 802db5e:	65a3      	str	r3, [r4, #88]	; 0x58
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 802db60:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 802db62:	f043 0301 	orr.w	r3, r3, #1
 802db66:	65e3      	str	r3, [r4, #92]	; 0x5c
          return HAL_ERROR;
 802db68:	2001      	movs	r0, #1
 802db6a:	e7d3      	b.n	802db14 <ADC_Disable+0x10>

0802db6c <HAL_ADC_DeInit>:
{
 802db6c:	b570      	push	{r4, r5, r6, lr}
  if (hadc == NULL)
 802db6e:	4604      	mov	r4, r0
 802db70:	2800      	cmp	r0, #0
 802db72:	d041      	beq.n	802dbf8 <HAL_ADC_DeInit+0x8c>
  SET_BIT(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL);
 802db74:	6d83      	ldr	r3, [r0, #88]	; 0x58
 802db76:	f043 0302 	orr.w	r3, r3, #2
 802db7a:	6583      	str	r3, [r0, #88]	; 0x58
  tmp_hal_status = ADC_ConversionStop(hadc);
 802db7c:	f7ff ff0c 	bl	802d998 <ADC_ConversionStop>
  if (tmp_hal_status == HAL_OK)
 802db80:	4605      	mov	r5, r0
 802db82:	b968      	cbnz	r0, 802dba0 <HAL_ADC_DeInit+0x34>
    tmp_hal_status = ADC_Disable(hadc);
 802db84:	4620      	mov	r0, r4
 802db86:	f7ff ffbd 	bl	802db04 <ADC_Disable>
    if (tmp_hal_status == HAL_OK)
 802db8a:	4605      	mov	r5, r0
 802db8c:	b908      	cbnz	r0, 802db92 <HAL_ADC_DeInit+0x26>
      hadc->State = HAL_ADC_STATE_READY;
 802db8e:	2301      	movs	r3, #1
 802db90:	65a3      	str	r3, [r4, #88]	; 0x58
    LL_ADC_DisableInternalRegulator(hadc->Instance);
 802db92:	6822      	ldr	r2, [r4, #0]
  CLEAR_BIT(ADCx->CR, (ADC_CR_ADVREGEN | ADC_CR_BITS_PROPERTY_RS));
 802db94:	6893      	ldr	r3, [r2, #8]
 802db96:	f023 4310 	bic.w	r3, r3, #2415919104	; 0x90000000
 802db9a:	f023 0317 	bic.w	r3, r3, #23
 802db9e:	6093      	str	r3, [r2, #8]
  __HAL_ADC_DISABLE_IT(hadc, (ADC_IT_AWD3  | ADC_IT_AWD2 |
 802dba0:	6823      	ldr	r3, [r4, #0]
 802dba2:	685a      	ldr	r2, [r3, #4]
 802dba4:	f422 7267 	bic.w	r2, r2, #924	; 0x39c
 802dba8:	f022 0203 	bic.w	r2, r2, #3
 802dbac:	605a      	str	r2, [r3, #4]
  __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_AWD3  | ADC_FLAG_AWD2 |
 802dbae:	f240 329f 	movw	r2, #927	; 0x39f
 802dbb2:	601a      	str	r2, [r3, #0]
  hadc->Instance->CFGR1 &= ~(ADC_CFGR1_AWD1CH   | ADC_CFGR1_AWD1EN  | ADC_CFGR1_AWD1SGL | ADC_CFGR1_DISCEN |
 802dbb4:	68d9      	ldr	r1, [r3, #12]
 802dbb6:	4a11      	ldr	r2, [pc, #68]	; (802dbfc <HAL_ADC_DeInit+0x90>)
 802dbb8:	400a      	ands	r2, r1
 802dbba:	60da      	str	r2, [r3, #12]
  hadc->Instance->CFGR2 &= ~ADC_CFGR2_CKMODE;
 802dbbc:	691a      	ldr	r2, [r3, #16]
 802dbbe:	f022 4240 	bic.w	r2, r2, #3221225472	; 0xc0000000
 802dbc2:	611a      	str	r2, [r3, #16]
  hadc->Instance->SMPR &= ~ADC_SMPR_SMP1;
 802dbc4:	695a      	ldr	r2, [r3, #20]
 802dbc6:	f022 0207 	bic.w	r2, r2, #7
 802dbca:	615a      	str	r2, [r3, #20]
  hadc->Instance->TR1 &= ~(ADC_TR1_HT1 | ADC_TR1_LT1);
 802dbcc:	6a1a      	ldr	r2, [r3, #32]
 802dbce:	f002 22f0 	and.w	r2, r2, #4026593280	; 0xf000f000
 802dbd2:	621a      	str	r2, [r3, #32]
  hadc->Instance->CHSELR &= ~(ADC_CHSELR_SQ_ALL);
 802dbd4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  ADC_COMMON->CCR &= ~(ADC_CCR_VBATEN | ADC_CCR_TSEN | ADC_CCR_VREFEN | ADC_CCR_PRESC);
 802dbd6:	4a0a      	ldr	r2, [pc, #40]	; (802dc00 <HAL_ADC_DeInit+0x94>)
  hadc->Instance->CHSELR &= ~(ADC_CHSELR_SQ_ALL);
 802dbd8:	2600      	movs	r6, #0
 802dbda:	629e      	str	r6, [r3, #40]	; 0x28
  ADC_COMMON->CCR &= ~(ADC_CCR_VBATEN | ADC_CCR_TSEN | ADC_CCR_VREFEN | ADC_CCR_PRESC);
 802dbdc:	6813      	ldr	r3, [r2, #0]
 802dbde:	f023 73fe 	bic.w	r3, r3, #33292288	; 0x1fc0000
 802dbe2:	6013      	str	r3, [r2, #0]
  HAL_ADC_MspDeInit(hadc);
 802dbe4:	4620      	mov	r0, r4
 802dbe6:	f7fe f967 	bl	802beb8 <HAL_ADC_MspDeInit>
  ADC_CLEAR_ERRORCODE(hadc);
 802dbea:	65e6      	str	r6, [r4, #92]	; 0x5c
  hadc->ADCGroupRegularSequencerRanks = 0x00000000UL;
 802dbec:	6626      	str	r6, [r4, #96]	; 0x60
  hadc->State = HAL_ADC_STATE_RESET;
 802dbee:	65a6      	str	r6, [r4, #88]	; 0x58
  __HAL_UNLOCK(hadc);
 802dbf0:	f884 6054 	strb.w	r6, [r4, #84]	; 0x54
}
 802dbf4:	4628      	mov	r0, r5
 802dbf6:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
 802dbf8:	2501      	movs	r5, #1
 802dbfa:	e7fb      	b.n	802dbf4 <HAL_ADC_DeInit+0x88>
 802dbfc:	833e0200 	.word	0x833e0200
 802dc00:	40012708 	.word	0x40012708

0802dc04 <HAL_ADC_Stop>:
{
 802dc04:	b510      	push	{r4, lr}
  __HAL_LOCK(hadc);
 802dc06:	f890 3054 	ldrb.w	r3, [r0, #84]	; 0x54
 802dc0a:	2b01      	cmp	r3, #1
{
 802dc0c:	4604      	mov	r4, r0
  __HAL_LOCK(hadc);
 802dc0e:	d015      	beq.n	802dc3c <HAL_ADC_Stop+0x38>
 802dc10:	2301      	movs	r3, #1
 802dc12:	f880 3054 	strb.w	r3, [r0, #84]	; 0x54
  tmp_hal_status = ADC_ConversionStop(hadc);
 802dc16:	f7ff febf 	bl	802d998 <ADC_ConversionStop>
  if (tmp_hal_status == HAL_OK)
 802dc1a:	b958      	cbnz	r0, 802dc34 <HAL_ADC_Stop+0x30>
    tmp_hal_status = ADC_Disable(hadc);
 802dc1c:	4620      	mov	r0, r4
 802dc1e:	f7ff ff71 	bl	802db04 <ADC_Disable>
    if (tmp_hal_status == HAL_OK)
 802dc22:	b938      	cbnz	r0, 802dc34 <HAL_ADC_Stop+0x30>
      ADC_STATE_CLR_SET(hadc->State,
 802dc24:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802dc26:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 802dc2a:	f023 0301 	bic.w	r3, r3, #1
 802dc2e:	f043 0301 	orr.w	r3, r3, #1
 802dc32:	65a3      	str	r3, [r4, #88]	; 0x58
  __HAL_UNLOCK(hadc);
 802dc34:	2300      	movs	r3, #0
 802dc36:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54
}
 802dc3a:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hadc);
 802dc3c:	2002      	movs	r0, #2
 802dc3e:	e7fc      	b.n	802dc3a <HAL_ADC_Stop+0x36>

0802dc40 <HAL_ADCEx_Calibration_Start>:
  *         HAL_ADC_GetValue() (value on 7 bits: from DR[6;0]).
  * @param  hadc       ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef *hadc)
{
 802dc40:	b513      	push	{r0, r1, r4, lr}
  HAL_StatusTypeDef tmp_hal_status;
  __IO uint32_t wait_loop_index = 0UL;
 802dc42:	2300      	movs	r3, #0
 802dc44:	9301      	str	r3, [sp, #4]
  uint32_t backup_setting_adc_dma_transfer; /* Note: Variable not declared as volatile because register read is already declared as volatile */

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  __HAL_LOCK(hadc);
 802dc46:	f890 3054 	ldrb.w	r3, [r0, #84]	; 0x54
 802dc4a:	2b01      	cmp	r3, #1
{
 802dc4c:	4604      	mov	r4, r0
  __HAL_LOCK(hadc);
 802dc4e:	d040      	beq.n	802dcd2 <HAL_ADCEx_Calibration_Start+0x92>
 802dc50:	2301      	movs	r3, #1
 802dc52:	f880 3054 	strb.w	r3, [r0, #84]	; 0x54

  /* Calibration prerequisite: ADC must be disabled. */

  /* Disable the ADC (if not already disabled) */
  tmp_hal_status = ADC_Disable(hadc);
 802dc56:	f7ff ff55 	bl	802db04 <ADC_Disable>

  /* Check if ADC is effectively disabled */
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 802dc5a:	6823      	ldr	r3, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 802dc5c:	689a      	ldr	r2, [r3, #8]
 802dc5e:	07d2      	lsls	r2, r2, #31
 802dc60:	d433      	bmi.n	802dcca <HAL_ADCEx_Calibration_Start+0x8a>
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 802dc62:	6da2      	ldr	r2, [r4, #88]	; 0x58
 802dc64:	f422 7281 	bic.w	r2, r2, #258	; 0x102
 802dc68:	f042 0202 	orr.w	r2, r2, #2
 802dc6c:	65a2      	str	r2, [r4, #88]	; 0x58
    /* Note: Specificity of this STM32 series: Calibration factor is          */
    /*       available in data register and also transferred by DMA.          */
    /*       To not insert ADC calibration factor among ADC conversion data   */
    /*       in array variable, DMA transfer must be disabled during          */
    /*       calibration.                                                     */
    backup_setting_adc_dma_transfer = READ_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 802dc6e:	68d9      	ldr	r1, [r3, #12]
    CLEAR_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 802dc70:	68da      	ldr	r2, [r3, #12]
 802dc72:	f022 0203 	bic.w	r2, r2, #3
 802dc76:	60da      	str	r2, [r3, #12]

    /* Start ADC calibration */
    SET_BIT(hadc->Instance->CR, ADC_CR_ADCAL);
 802dc78:	689a      	ldr	r2, [r3, #8]
 802dc7a:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
    backup_setting_adc_dma_transfer = READ_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 802dc7e:	f001 0103 	and.w	r1, r1, #3
    SET_BIT(hadc->Instance->CR, ADC_CR_ADCAL);
 802dc82:	609a      	str	r2, [r3, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADCAL) == (ADC_CR_ADCAL)) ? 1UL : 0UL);
 802dc84:	689a      	ldr	r2, [r3, #8]
 802dc86:	2a00      	cmp	r2, #0
 802dc88:	da12      	bge.n	802dcb0 <HAL_ADCEx_Calibration_Start+0x70>

    /* Wait for calibration completion */
    while (LL_ADC_IsCalibrationOnGoing(hadc->Instance) != 0UL)
    {
      wait_loop_index++;
 802dc8a:	9a01      	ldr	r2, [sp, #4]
 802dc8c:	3201      	adds	r2, #1
 802dc8e:	9201      	str	r2, [sp, #4]
      if (wait_loop_index >= ADC_CALIBRATION_TIMEOUT)
 802dc90:	9a01      	ldr	r2, [sp, #4]
 802dc92:	f5b2 3f2e 	cmp.w	r2, #178176	; 0x2b800
 802dc96:	d3f5      	bcc.n	802dc84 <HAL_ADCEx_Calibration_Start+0x44>
      {
        /* Update ADC state machine to error */
        ADC_STATE_CLR_SET(hadc->State,
 802dc98:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802dc9a:	f023 0312 	bic.w	r3, r3, #18
 802dc9e:	f043 0310 	orr.w	r3, r3, #16
 802dca2:	65a3      	str	r3, [r4, #88]	; 0x58
                          HAL_ADC_STATE_BUSY_INTERNAL,
                          HAL_ADC_STATE_ERROR_INTERNAL);

        __HAL_UNLOCK(hadc);
 802dca4:	2300      	movs	r3, #0
 802dca6:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54

        return HAL_ERROR;
 802dcaa:	2001      	movs	r0, #1
  }

  __HAL_UNLOCK(hadc);

  return tmp_hal_status;
}
 802dcac:	b002      	add	sp, #8
 802dcae:	bd10      	pop	{r4, pc}
    SET_BIT(hadc->Instance->CFGR1, backup_setting_adc_dma_transfer);
 802dcb0:	68da      	ldr	r2, [r3, #12]
 802dcb2:	430a      	orrs	r2, r1
 802dcb4:	60da      	str	r2, [r3, #12]
    ADC_STATE_CLR_SET(hadc->State,
 802dcb6:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802dcb8:	f023 0303 	bic.w	r3, r3, #3
 802dcbc:	f043 0301 	orr.w	r3, r3, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 802dcc0:	65a3      	str	r3, [r4, #88]	; 0x58
  __HAL_UNLOCK(hadc);
 802dcc2:	2300      	movs	r3, #0
 802dcc4:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54
  return tmp_hal_status;
 802dcc8:	e7f0      	b.n	802dcac <HAL_ADCEx_Calibration_Start+0x6c>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 802dcca:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802dccc:	f043 0310 	orr.w	r3, r3, #16
 802dcd0:	e7f6      	b.n	802dcc0 <HAL_ADCEx_Calibration_Start+0x80>
  __HAL_LOCK(hadc);
 802dcd2:	2002      	movs	r0, #2
 802dcd4:	e7ea      	b.n	802dcac <HAL_ADCEx_Calibration_Start+0x6c>
	...

0802dcd8 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 802dcd8:	4907      	ldr	r1, [pc, #28]	; (802dcf8 <HAL_NVIC_SetPriorityGrouping+0x20>)
 802dcda:	68ca      	ldr	r2, [r1, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 802dcdc:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 802dce0:	0203      	lsls	r3, r0, #8
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 802dce2:	0412      	lsls	r2, r2, #16
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 802dce4:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 802dce8:	0c12      	lsrs	r2, r2, #16
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 802dcea:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 802dcec:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 802dcf0:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  SCB->AIRCR =  reg_value;
 802dcf4:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 802dcf6:	4770      	bx	lr
 802dcf8:	e000ed00 	.word	0xe000ed00

0802dcfc <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 802dcfc:	4b16      	ldr	r3, [pc, #88]	; (802dd58 <HAL_NVIC_SetPriority+0x5c>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 802dcfe:	b530      	push	{r4, r5, lr}
 802dd00:	68dc      	ldr	r4, [r3, #12]
 802dd02:	f3c4 2402 	ubfx	r4, r4, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 802dd06:	f1c4 0307 	rsb	r3, r4, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 802dd0a:	1d25      	adds	r5, r4, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 802dd0c:	2b04      	cmp	r3, #4
 802dd0e:	bf28      	it	cs
 802dd10:	2304      	movcs	r3, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 802dd12:	2d06      	cmp	r5, #6

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 802dd14:	f04f 35ff 	mov.w	r5, #4294967295
 802dd18:	fa05 f303 	lsl.w	r3, r5, r3
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 802dd1c:	bf8c      	ite	hi
 802dd1e:	3c03      	subhi	r4, #3
 802dd20:	2400      	movls	r4, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 802dd22:	ea21 0303 	bic.w	r3, r1, r3
 802dd26:	40a3      	lsls	r3, r4
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 802dd28:	fa05 f404 	lsl.w	r4, r5, r4
 802dd2c:	ea22 0204 	bic.w	r2, r2, r4
  if ((int32_t)(IRQn) >= 0)
 802dd30:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 802dd32:	ea43 0302 	orr.w	r3, r3, r2
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802dd36:	bfac      	ite	ge
 802dd38:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802dd3c:	4a07      	ldrlt	r2, [pc, #28]	; (802dd5c <HAL_NVIC_SetPriority+0x60>)
 802dd3e:	ea4f 1303 	mov.w	r3, r3, lsl #4
 802dd42:	bfb8      	it	lt
 802dd44:	f000 000f 	andlt.w	r0, r0, #15
 802dd48:	b2db      	uxtb	r3, r3
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802dd4a:	bfaa      	itet	ge
 802dd4c:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802dd50:	5413      	strblt	r3, [r2, r0]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802dd52:	f880 3300 	strbge.w	r3, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 802dd56:	bd30      	pop	{r4, r5, pc}
 802dd58:	e000ed00 	.word	0xe000ed00
 802dd5c:	e000ed14 	.word	0xe000ed14

0802dd60 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 802dd60:	2800      	cmp	r0, #0
 802dd62:	db08      	blt.n	802dd76 <HAL_NVIC_EnableIRQ+0x16>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 802dd64:	2301      	movs	r3, #1
 802dd66:	0942      	lsrs	r2, r0, #5
 802dd68:	f000 001f 	and.w	r0, r0, #31
 802dd6c:	fa03 f000 	lsl.w	r0, r3, r0
 802dd70:	4b01      	ldr	r3, [pc, #4]	; (802dd78 <HAL_NVIC_EnableIRQ+0x18>)
 802dd72:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 802dd76:	4770      	bx	lr
 802dd78:	e000e100 	.word	0xe000e100

0802dd7c <HAL_NVIC_DisableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 802dd7c:	2800      	cmp	r0, #0
 802dd7e:	db0d      	blt.n	802dd9c <HAL_NVIC_DisableIRQ+0x20>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 802dd80:	0943      	lsrs	r3, r0, #5
 802dd82:	2201      	movs	r2, #1
 802dd84:	f000 001f 	and.w	r0, r0, #31
 802dd88:	fa02 f000 	lsl.w	r0, r2, r0
 802dd8c:	3320      	adds	r3, #32
 802dd8e:	4a04      	ldr	r2, [pc, #16]	; (802dda0 <HAL_NVIC_DisableIRQ+0x24>)
 802dd90:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
 802dd94:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 802dd98:	f3bf 8f6f 	isb	sy
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
}
 802dd9c:	4770      	bx	lr
 802dd9e:	bf00      	nop
 802dda0:	e000e100 	.word	0xe000e100

0802dda4 <DMA_SetConfig>:
  * @param DstAddress The destination memory Buffer address
  * @param DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 802dda4:	b570      	push	{r4, r5, r6, lr}
  /* Clear the DMAMUX synchro overrun flag */
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 802dda6:	e9d0 4513 	ldrd	r4, r5, [r0, #76]	; 0x4c
 802ddaa:	6065      	str	r5, [r4, #4]

  if (hdma->DMAmuxRequestGen != 0U)
 802ddac:	6d44      	ldr	r4, [r0, #84]	; 0x54
 802ddae:	b114      	cbz	r4, 802ddb6 <DMA_SetConfig+0x12>
  {
    /* Clear the DMAMUX request generator overrun flag */
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 802ddb0:	e9d0 4516 	ldrd	r4, r5, [r0, #88]	; 0x58
 802ddb4:	6065      	str	r5, [r4, #4]
  }

  /* Clear all flags */
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 802ddb6:	e9d0 5410 	ldrd	r5, r4, [r0, #64]	; 0x40
 802ddba:	f004 061c 	and.w	r6, r4, #28
 802ddbe:	2401      	movs	r4, #1
 802ddc0:	40b4      	lsls	r4, r6
 802ddc2:	606c      	str	r4, [r5, #4]

  /* Configure DMA Channel data length */
  hdma->Instance->CNDTR = DataLength;
 802ddc4:	6804      	ldr	r4, [r0, #0]
 802ddc6:	6063      	str	r3, [r4, #4]

  /* Memory to Peripheral */
  if ((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 802ddc8:	6883      	ldr	r3, [r0, #8]
 802ddca:	2b10      	cmp	r3, #16
  {
    /* Configure DMA Channel destination address */
    hdma->Instance->CPAR = DstAddress;
 802ddcc:	bf0b      	itete	eq
 802ddce:	60a2      	streq	r2, [r4, #8]
  }
  /* Peripheral to Memory */
  else
  {
    /* Configure DMA Channel source address */
    hdma->Instance->CPAR = SrcAddress;
 802ddd0:	60a1      	strne	r1, [r4, #8]
    hdma->Instance->CMAR = SrcAddress;
 802ddd2:	60e1      	streq	r1, [r4, #12]

    /* Configure DMA Channel destination address */
    hdma->Instance->CMAR = DstAddress;
 802ddd4:	60e2      	strne	r2, [r4, #12]
  }
}
 802ddd6:	bd70      	pop	{r4, r5, r6, pc}

0802ddd8 <DMA_CalcDMAMUXChannelBaseAndMask>:
static void DMA_CalcDMAMUXChannelBaseAndMask(DMA_HandleTypeDef *hdma)
{
  uint32_t channel_number;

  /* check if instance is not outside the DMA channel range */
  if ((uint32_t)hdma->Instance < (uint32_t)DMA2_Channel1)
 802ddd8:	6802      	ldr	r2, [r0, #0]
 802ddda:	6c41      	ldr	r1, [r0, #68]	; 0x44
 802dddc:	b2d3      	uxtb	r3, r2
{
 802ddde:	b510      	push	{r4, lr}
 802dde0:	3b08      	subs	r3, #8
 802dde2:	2414      	movs	r4, #20
 802dde4:	fbb3 f3f4 	udiv	r3, r3, r4
  if ((uint32_t)hdma->Instance < (uint32_t)DMA2_Channel1)
 802dde8:	4c0b      	ldr	r4, [pc, #44]	; (802de18 <DMA_CalcDMAMUXChannelBaseAndMask+0x40>)
 802ddea:	42a2      	cmp	r2, r4
  }
  else
  {
    /* DMA2 */
    /* Associate a DMA Channel to a DMAMUX channel */
    hdma->DMAmuxChannel = (DMAMUX1_Channel7 + (hdma->ChannelIndex >> 2U));
 802ddec:	bf88      	it	hi
 802ddee:	4a0b      	ldrhi	r2, [pc, #44]	; (802de1c <DMA_CalcDMAMUXChannelBaseAndMask+0x44>)
 802ddf0:	f021 0103 	bic.w	r1, r1, #3
    hdma->DMAmuxChannel = (DMAMUX1_Channel0 + (hdma->ChannelIndex >> 2U));
 802ddf4:	bf99      	ittee	ls
 802ddf6:	f101 4280 	addls.w	r2, r1, #1073741824	; 0x40000000
 802ddfa:	f502 3202 	addls.w	r2, r2, #133120	; 0x20800
    hdma->DMAmuxChannel = (DMAMUX1_Channel7 + (hdma->ChannelIndex >> 2U));
 802ddfe:	1852      	addhi	r2, r2, r1

    /* Prepare channel_number used for DMAmuxChannelStatusMask computation */
    channel_number = (((((uint32_t)hdma->Instance & 0xFFU) - 8U) / 20U) + 7U);
 802de00:	3307      	addhi	r3, #7
 802de02:	6482      	str	r2, [r0, #72]	; 0x48
  }

  /* Initialize the field DMAmuxChannelStatus to DMAMUX1_ChannelStatus base */
  hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
 802de04:	4a06      	ldr	r2, [pc, #24]	; (802de20 <DMA_CalcDMAMUXChannelBaseAndMask+0x48>)
 802de06:	64c2      	str	r2, [r0, #76]	; 0x4c

  /* Initialize the field DMAmuxChannelStatusMask with the corresponding index of the DMAMUX channel selected for the current ChannelIndex */
  hdma->DMAmuxChannelStatusMask = 1UL << (channel_number & 0x1FU);
 802de08:	f003 031f 	and.w	r3, r3, #31
 802de0c:	2201      	movs	r2, #1
 802de0e:	fa02 f303 	lsl.w	r3, r2, r3
 802de12:	6503      	str	r3, [r0, #80]	; 0x50
}
 802de14:	bd10      	pop	{r4, pc}
 802de16:	bf00      	nop
 802de18:	40020407 	.word	0x40020407
 802de1c:	4002081c 	.word	0x4002081c
 802de20:	40020880 	.word	0x40020880

0802de24 <HAL_DMA_Init>:
{
 802de24:	b510      	push	{r4, lr}
  if (hdma == NULL)
 802de26:	2800      	cmp	r0, #0
 802de28:	d060      	beq.n	802deec <HAL_DMA_Init+0xc8>
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 802de2a:	6802      	ldr	r2, [r0, #0]
 802de2c:	4b30      	ldr	r3, [pc, #192]	; (802def0 <HAL_DMA_Init+0xcc>)
 802de2e:	429a      	cmp	r2, r3
 802de30:	f04f 0414 	mov.w	r4, #20
 802de34:	d84d      	bhi.n	802ded2 <HAL_DMA_Init+0xae>
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 802de36:	492f      	ldr	r1, [pc, #188]	; (802def4 <HAL_DMA_Init+0xd0>)
 802de38:	4411      	add	r1, r2
 802de3a:	fbb1 f1f4 	udiv	r1, r1, r4
 802de3e:	0089      	lsls	r1, r1, #2
 802de40:	6441      	str	r1, [r0, #68]	; 0x44
    hdma->DmaBaseAddress = DMA1;
 802de42:	f2a3 4307 	subw	r3, r3, #1031	; 0x407
    hdma->DmaBaseAddress = DMA2;
 802de46:	6403      	str	r3, [r0, #64]	; 0x40
  hdma->State = HAL_DMA_STATE_BUSY;
 802de48:	2302      	movs	r3, #2
 802de4a:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
  CLEAR_BIT(hdma->Instance->CCR, (DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 802de4e:	6813      	ldr	r3, [r2, #0]
 802de50:	f423 43ff 	bic.w	r3, r3, #32640	; 0x7f80
 802de54:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 802de58:	6013      	str	r3, [r2, #0]
  SET_BIT(hdma->Instance->CCR, (hdma->Init.Direction           |                               \
 802de5a:	e9d0 3402 	ldrd	r3, r4, [r0, #8]
 802de5e:	4323      	orrs	r3, r4
 802de60:	6904      	ldr	r4, [r0, #16]
 802de62:	6811      	ldr	r1, [r2, #0]
 802de64:	4323      	orrs	r3, r4
 802de66:	6944      	ldr	r4, [r0, #20]
 802de68:	4323      	orrs	r3, r4
 802de6a:	6984      	ldr	r4, [r0, #24]
 802de6c:	4323      	orrs	r3, r4
 802de6e:	69c4      	ldr	r4, [r0, #28]
 802de70:	4323      	orrs	r3, r4
 802de72:	6a04      	ldr	r4, [r0, #32]
 802de74:	4323      	orrs	r3, r4
 802de76:	430b      	orrs	r3, r1
 802de78:	6013      	str	r3, [r2, #0]
  DMA_CalcDMAMUXChannelBaseAndMask(hdma);
 802de7a:	f7ff ffad 	bl	802ddd8 <DMA_CalcDMAMUXChannelBaseAndMask>
  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 802de7e:	6883      	ldr	r3, [r0, #8]
  hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 802de80:	6c81      	ldr	r1, [r0, #72]	; 0x48
  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 802de82:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
    hdma->Init.Request = DMA_REQUEST_MEM2MEM;
 802de86:	bf04      	itt	eq
 802de88:	2300      	moveq	r3, #0
 802de8a:	6043      	streq	r3, [r0, #4]
  hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 802de8c:	6842      	ldr	r2, [r0, #4]
 802de8e:	f002 037f 	and.w	r3, r2, #127	; 0x7f
 802de92:	600b      	str	r3, [r1, #0]
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 802de94:	e9d0 1413 	ldrd	r1, r4, [r0, #76]	; 0x4c
  if (((hdma->Init.Request >  0UL) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 802de98:	3a01      	subs	r2, #1
 802de9a:	2a03      	cmp	r2, #3
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 802de9c:	604c      	str	r4, [r1, #4]
  if (((hdma->Init.Request >  0UL) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 802de9e:	d820      	bhi.n	802dee2 <HAL_DMA_Init+0xbe>
static void DMA_CalcDMAMUXRequestGenBaseAndMask(DMA_HandleTypeDef *hdma)
{
  uint32_t request =  hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID;

  /* DMA Channels are connected to DMAMUX1 request generator blocks*/
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 802dea0:	4a15      	ldr	r2, [pc, #84]	; (802def8 <HAL_DMA_Init+0xd4>)

  hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
 802dea2:	4c16      	ldr	r4, [pc, #88]	; (802defc <HAL_DMA_Init+0xd8>)
 802dea4:	6584      	str	r4, [r0, #88]	; 0x58
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 802dea6:	441a      	add	r2, r3

  /* here "Request" is either DMA_REQUEST_GENERATOR0 to DMA_REQUEST_GENERATOR3, i.e. <= 4*/
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x3U);
 802dea8:	3b01      	subs	r3, #1
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 802deaa:	0092      	lsls	r2, r2, #2
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x3U);
 802deac:	2101      	movs	r1, #1
 802deae:	f003 0303 	and.w	r3, r3, #3
 802deb2:	fa01 f303 	lsl.w	r3, r1, r3
    hdma->DMAmuxRequestGen->RGCR = 0U;
 802deb6:	2100      	movs	r1, #0
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 802deb8:	6542      	str	r2, [r0, #84]	; 0x54
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x3U);
 802deba:	65c3      	str	r3, [r0, #92]	; 0x5c
    hdma->DMAmuxRequestGen->RGCR = 0U;
 802debc:	6011      	str	r1, [r2, #0]
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 802debe:	6063      	str	r3, [r4, #4]
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 802dec0:	2300      	movs	r3, #0
  hdma->State = HAL_DMA_STATE_READY;
 802dec2:	2201      	movs	r2, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 802dec4:	63c3      	str	r3, [r0, #60]	; 0x3c
  __HAL_UNLOCK(hdma);
 802dec6:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
  hdma->State = HAL_DMA_STATE_READY;
 802deca:	f880 2025 	strb.w	r2, [r0, #37]	; 0x25
  return HAL_OK;
 802dece:	4618      	mov	r0, r3
}
 802ded0:	bd10      	pop	{r4, pc}
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2U;
 802ded2:	4b0b      	ldr	r3, [pc, #44]	; (802df00 <HAL_DMA_Init+0xdc>)
 802ded4:	4413      	add	r3, r2
 802ded6:	fbb3 f3f4 	udiv	r3, r3, r4
 802deda:	009b      	lsls	r3, r3, #2
 802dedc:	6443      	str	r3, [r0, #68]	; 0x44
    hdma->DmaBaseAddress = DMA2;
 802dede:	4b09      	ldr	r3, [pc, #36]	; (802df04 <HAL_DMA_Init+0xe0>)
 802dee0:	e7b1      	b.n	802de46 <HAL_DMA_Init+0x22>
    hdma->DMAmuxRequestGen = 0U;
 802dee2:	2300      	movs	r3, #0
    hdma->DMAmuxRequestGenStatus = 0U;
 802dee4:	e9c0 3315 	strd	r3, r3, [r0, #84]	; 0x54
    hdma->DMAmuxRequestGenStatusMask = 0U;
 802dee8:	65c3      	str	r3, [r0, #92]	; 0x5c
 802deea:	e7e9      	b.n	802dec0 <HAL_DMA_Init+0x9c>
    return HAL_ERROR;
 802deec:	2001      	movs	r0, #1
 802deee:	e7ef      	b.n	802ded0 <HAL_DMA_Init+0xac>
 802def0:	40020407 	.word	0x40020407
 802def4:	bffdfff8 	.word	0xbffdfff8
 802def8:	1000823f 	.word	0x1000823f
 802defc:	40020940 	.word	0x40020940
 802df00:	bffdfbf8 	.word	0xbffdfbf8
 802df04:	40020400 	.word	0x40020400

0802df08 <HAL_DMA_DeInit>:
{
 802df08:	b538      	push	{r3, r4, r5, lr}
  if (NULL == hdma)
 802df0a:	2800      	cmp	r0, #0
 802df0c:	d045      	beq.n	802df9a <HAL_DMA_DeInit+0x92>
  __HAL_DMA_DISABLE(hdma);
 802df0e:	6801      	ldr	r1, [r0, #0]
 802df10:	680b      	ldr	r3, [r1, #0]
 802df12:	f023 0301 	bic.w	r3, r3, #1
 802df16:	600b      	str	r3, [r1, #0]
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 802df18:	4b21      	ldr	r3, [pc, #132]	; (802dfa0 <HAL_DMA_DeInit+0x98>)
 802df1a:	4299      	cmp	r1, r3
 802df1c:	f04f 0414 	mov.w	r4, #20
 802df20:	d833      	bhi.n	802df8a <HAL_DMA_DeInit+0x82>
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 802df22:	4a20      	ldr	r2, [pc, #128]	; (802dfa4 <HAL_DMA_DeInit+0x9c>)
 802df24:	440a      	add	r2, r1
 802df26:	fbb2 f2f4 	udiv	r2, r2, r4
 802df2a:	0092      	lsls	r2, r2, #2
 802df2c:	6442      	str	r2, [r0, #68]	; 0x44
    hdma->DmaBaseAddress = DMA1;
 802df2e:	f2a3 4307 	subw	r3, r3, #1031	; 0x407
    hdma->DmaBaseAddress = DMA2;
 802df32:	6403      	str	r3, [r0, #64]	; 0x40
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 802df34:	e9d0 2310 	ldrd	r2, r3, [r0, #64]	; 0x40
 802df38:	2401      	movs	r4, #1
 802df3a:	f003 031c 	and.w	r3, r3, #28
 802df3e:	fa04 f303 	lsl.w	r3, r4, r3
  hdma->Instance->CCR = 0U;
 802df42:	2500      	movs	r5, #0
 802df44:	600d      	str	r5, [r1, #0]
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 802df46:	6053      	str	r3, [r2, #4]
  DMA_CalcDMAMUXChannelBaseAndMask(hdma);
 802df48:	f7ff ff46 	bl	802ddd8 <DMA_CalcDMAMUXChannelBaseAndMask>
  hdma->DMAmuxChannel->CCR = 0U;
 802df4c:	6c83      	ldr	r3, [r0, #72]	; 0x48
  if (((hdma->Init.Request >  0UL) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 802df4e:	6841      	ldr	r1, [r0, #4]
  hdma->DMAmuxChannel->CCR = 0U;
 802df50:	601d      	str	r5, [r3, #0]
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 802df52:	e9d0 3213 	ldrd	r3, r2, [r0, #76]	; 0x4c
 802df56:	605a      	str	r2, [r3, #4]
  if (((hdma->Init.Request >  0UL) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 802df58:	1e4a      	subs	r2, r1, #1
 802df5a:	2a03      	cmp	r2, #3
 802df5c:	d806      	bhi.n	802df6c <HAL_DMA_DeInit+0x64>
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 802df5e:	4b12      	ldr	r3, [pc, #72]	; (802dfa8 <HAL_DMA_DeInit+0xa0>)
 802df60:	440b      	add	r3, r1
 802df62:	009b      	lsls	r3, r3, #2
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x3U);
 802df64:	4094      	lsls	r4, r2
    hdma->DMAmuxRequestGen->RGCR = 0U;
 802df66:	601d      	str	r5, [r3, #0]
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 802df68:	4b10      	ldr	r3, [pc, #64]	; (802dfac <HAL_DMA_DeInit+0xa4>)
 802df6a:	605c      	str	r4, [r3, #4]
  hdma->DMAmuxRequestGen = 0U;
 802df6c:	2300      	movs	r3, #0
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 802df6e:	63c3      	str	r3, [r0, #60]	; 0x3c
  hdma->DMAmuxRequestGenStatus = 0U;
 802df70:	e9c0 3315 	strd	r3, r3, [r0, #84]	; 0x54
  hdma->XferHalfCpltCallback = NULL;
 802df74:	e9c0 330b 	strd	r3, r3, [r0, #44]	; 0x2c
  hdma->XferAbortCallback = NULL;
 802df78:	e9c0 330d 	strd	r3, r3, [r0, #52]	; 0x34
  hdma->DMAmuxRequestGenStatusMask = 0U;
 802df7c:	65c3      	str	r3, [r0, #92]	; 0x5c
  hdma->State = HAL_DMA_STATE_RESET;
 802df7e:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
  __HAL_UNLOCK(hdma);
 802df82:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
  return HAL_OK;
 802df86:	4618      	mov	r0, r3
}
 802df88:	bd38      	pop	{r3, r4, r5, pc}
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2U;
 802df8a:	4b09      	ldr	r3, [pc, #36]	; (802dfb0 <HAL_DMA_DeInit+0xa8>)
 802df8c:	440b      	add	r3, r1
 802df8e:	fbb3 f3f4 	udiv	r3, r3, r4
 802df92:	009b      	lsls	r3, r3, #2
 802df94:	6443      	str	r3, [r0, #68]	; 0x44
    hdma->DmaBaseAddress = DMA2;
 802df96:	4b07      	ldr	r3, [pc, #28]	; (802dfb4 <HAL_DMA_DeInit+0xac>)
 802df98:	e7cb      	b.n	802df32 <HAL_DMA_DeInit+0x2a>
    return HAL_ERROR;
 802df9a:	2001      	movs	r0, #1
 802df9c:	e7f4      	b.n	802df88 <HAL_DMA_DeInit+0x80>
 802df9e:	bf00      	nop
 802dfa0:	40020407 	.word	0x40020407
 802dfa4:	bffdfff8 	.word	0xbffdfff8
 802dfa8:	1000823f 	.word	0x1000823f
 802dfac:	40020940 	.word	0x40020940
 802dfb0:	bffdfbf8 	.word	0xbffdfbf8
 802dfb4:	40020400 	.word	0x40020400

0802dfb8 <HAL_DMA_Start_IT>:
{
 802dfb8:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(hdma);
 802dfba:	f890 5024 	ldrb.w	r5, [r0, #36]	; 0x24
 802dfbe:	2d01      	cmp	r5, #1
{
 802dfc0:	4604      	mov	r4, r0
  __HAL_LOCK(hdma);
 802dfc2:	d03c      	beq.n	802e03e <HAL_DMA_Start_IT+0x86>
  if (hdma->State == HAL_DMA_STATE_READY)
 802dfc4:	f890 6025 	ldrb.w	r6, [r0, #37]	; 0x25
  __HAL_LOCK(hdma);
 802dfc8:	2501      	movs	r5, #1
  if (hdma->State == HAL_DMA_STATE_READY)
 802dfca:	42ae      	cmp	r6, r5
  __HAL_LOCK(hdma);
 802dfcc:	f880 5024 	strb.w	r5, [r0, #36]	; 0x24
  if (hdma->State == HAL_DMA_STATE_READY)
 802dfd0:	f04f 0600 	mov.w	r6, #0
 802dfd4:	d12d      	bne.n	802e032 <HAL_DMA_Start_IT+0x7a>
    hdma->State = HAL_DMA_STATE_BUSY;
 802dfd6:	2502      	movs	r5, #2
 802dfd8:	f880 5025 	strb.w	r5, [r0, #37]	; 0x25
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 802dfdc:	63c6      	str	r6, [r0, #60]	; 0x3c
    __HAL_DMA_DISABLE(hdma);
 802dfde:	6806      	ldr	r6, [r0, #0]
 802dfe0:	6835      	ldr	r5, [r6, #0]
 802dfe2:	f025 0501 	bic.w	r5, r5, #1
 802dfe6:	6035      	str	r5, [r6, #0]
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
 802dfe8:	f7ff fedc 	bl	802dda4 <DMA_SetConfig>
    if (NULL != hdma->XferHalfCpltCallback)
 802dfec:	6b02      	ldr	r2, [r0, #48]	; 0x30
 802dfee:	6803      	ldr	r3, [r0, #0]
 802dff0:	b1ba      	cbz	r2, 802e022 <HAL_DMA_Start_IT+0x6a>
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 802dff2:	681a      	ldr	r2, [r3, #0]
 802dff4:	f042 020e 	orr.w	r2, r2, #14
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_TE));
 802dff8:	601a      	str	r2, [r3, #0]
    if ((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)
 802dffa:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 802dffc:	6811      	ldr	r1, [r2, #0]
 802dffe:	03c9      	lsls	r1, r1, #15
      hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;
 802e000:	bf42      	ittt	mi
 802e002:	6811      	ldrmi	r1, [r2, #0]
 802e004:	f441 7180 	orrmi.w	r1, r1, #256	; 0x100
 802e008:	6011      	strmi	r1, [r2, #0]
    if (hdma->DMAmuxRequestGen != 0U)
 802e00a:	6d62      	ldr	r2, [r4, #84]	; 0x54
 802e00c:	b11a      	cbz	r2, 802e016 <HAL_DMA_Start_IT+0x5e>
      hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
 802e00e:	6811      	ldr	r1, [r2, #0]
 802e010:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 802e014:	6011      	str	r1, [r2, #0]
    __HAL_DMA_ENABLE(hdma);
 802e016:	681a      	ldr	r2, [r3, #0]
 802e018:	f042 0201 	orr.w	r2, r2, #1
 802e01c:	601a      	str	r2, [r3, #0]
  HAL_StatusTypeDef status = HAL_OK;
 802e01e:	2000      	movs	r0, #0
}
 802e020:	bd70      	pop	{r4, r5, r6, pc}
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 802e022:	681a      	ldr	r2, [r3, #0]
 802e024:	f022 0204 	bic.w	r2, r2, #4
 802e028:	601a      	str	r2, [r3, #0]
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_TE));
 802e02a:	681a      	ldr	r2, [r3, #0]
 802e02c:	f042 020a 	orr.w	r2, r2, #10
 802e030:	e7e2      	b.n	802dff8 <HAL_DMA_Start_IT+0x40>
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
 802e032:	2380      	movs	r3, #128	; 0x80
 802e034:	63c3      	str	r3, [r0, #60]	; 0x3c
    __HAL_UNLOCK(hdma);
 802e036:	f880 6024 	strb.w	r6, [r0, #36]	; 0x24
    status = HAL_ERROR;
 802e03a:	4628      	mov	r0, r5
 802e03c:	e7f0      	b.n	802e020 <HAL_DMA_Start_IT+0x68>
  __HAL_LOCK(hdma);
 802e03e:	2002      	movs	r0, #2
 802e040:	e7ee      	b.n	802e020 <HAL_DMA_Start_IT+0x68>

0802e042 <HAL_DMA_Abort>:
  if (NULL == hdma)
 802e042:	b140      	cbz	r0, 802e056 <HAL_DMA_Abort+0x14>
  if (hdma->State != HAL_DMA_STATE_BUSY)
 802e044:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
 802e048:	2b02      	cmp	r3, #2
 802e04a:	d006      	beq.n	802e05a <HAL_DMA_Abort+0x18>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 802e04c:	2304      	movs	r3, #4
 802e04e:	63c3      	str	r3, [r0, #60]	; 0x3c
    __HAL_UNLOCK(hdma);
 802e050:	2300      	movs	r3, #0
 802e052:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
    return HAL_ERROR;
 802e056:	2001      	movs	r0, #1
}
 802e058:	4770      	bx	lr
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 802e05a:	6803      	ldr	r3, [r0, #0]
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 802e05c:	6c81      	ldr	r1, [r0, #72]	; 0x48
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 802e05e:	681a      	ldr	r2, [r3, #0]
 802e060:	f022 020e 	bic.w	r2, r2, #14
 802e064:	601a      	str	r2, [r3, #0]
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 802e066:	680a      	ldr	r2, [r1, #0]
 802e068:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 802e06c:	600a      	str	r2, [r1, #0]
    __HAL_DMA_DISABLE(hdma);
 802e06e:	681a      	ldr	r2, [r3, #0]
 802e070:	f022 0201 	bic.w	r2, r2, #1
 802e074:	601a      	str	r2, [r3, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 802e076:	e9d0 1310 	ldrd	r1, r3, [r0, #64]	; 0x40
 802e07a:	f003 021c 	and.w	r2, r3, #28
 802e07e:	2301      	movs	r3, #1
 802e080:	4093      	lsls	r3, r2
 802e082:	604b      	str	r3, [r1, #4]
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 802e084:	e9d0 3213 	ldrd	r3, r2, [r0, #76]	; 0x4c
 802e088:	605a      	str	r2, [r3, #4]
    if (hdma->DMAmuxRequestGen != 0U)
 802e08a:	6d43      	ldr	r3, [r0, #84]	; 0x54
 802e08c:	b133      	cbz	r3, 802e09c <HAL_DMA_Abort+0x5a>
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 802e08e:	681a      	ldr	r2, [r3, #0]
 802e090:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 802e094:	601a      	str	r2, [r3, #0]
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 802e096:	e9d0 3216 	ldrd	r3, r2, [r0, #88]	; 0x58
 802e09a:	605a      	str	r2, [r3, #4]
    hdma->State = HAL_DMA_STATE_READY;
 802e09c:	2301      	movs	r3, #1
 802e09e:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
    __HAL_UNLOCK(hdma);
 802e0a2:	2300      	movs	r3, #0
 802e0a4:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
  return HAL_OK;
 802e0a8:	4618      	mov	r0, r3
 802e0aa:	4770      	bx	lr

0802e0ac <HAL_DMA_Abort_IT>:
{
 802e0ac:	b510      	push	{r4, lr}
  if (hdma->State != HAL_DMA_STATE_BUSY)
 802e0ae:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
 802e0b2:	2b02      	cmp	r3, #2
 802e0b4:	d003      	beq.n	802e0be <HAL_DMA_Abort_IT+0x12>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 802e0b6:	2304      	movs	r3, #4
 802e0b8:	63c3      	str	r3, [r0, #60]	; 0x3c
    status = HAL_ERROR;
 802e0ba:	2001      	movs	r0, #1
}
 802e0bc:	bd10      	pop	{r4, pc}
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 802e0be:	6803      	ldr	r3, [r0, #0]
 802e0c0:	681a      	ldr	r2, [r3, #0]
 802e0c2:	f022 020e 	bic.w	r2, r2, #14
 802e0c6:	601a      	str	r2, [r3, #0]
    __HAL_DMA_DISABLE(hdma);
 802e0c8:	681a      	ldr	r2, [r3, #0]
 802e0ca:	f022 0201 	bic.w	r2, r2, #1
 802e0ce:	601a      	str	r2, [r3, #0]
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 802e0d0:	6c82      	ldr	r2, [r0, #72]	; 0x48
 802e0d2:	6813      	ldr	r3, [r2, #0]
 802e0d4:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 802e0d8:	6013      	str	r3, [r2, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 802e0da:	e9d0 1310 	ldrd	r1, r3, [r0, #64]	; 0x40
 802e0de:	f003 021c 	and.w	r2, r3, #28
 802e0e2:	2301      	movs	r3, #1
 802e0e4:	4093      	lsls	r3, r2
 802e0e6:	604b      	str	r3, [r1, #4]
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 802e0e8:	e9d0 3213 	ldrd	r3, r2, [r0, #76]	; 0x4c
 802e0ec:	605a      	str	r2, [r3, #4]
    if (hdma->DMAmuxRequestGen != 0U)
 802e0ee:	6d43      	ldr	r3, [r0, #84]	; 0x54
 802e0f0:	b133      	cbz	r3, 802e100 <HAL_DMA_Abort_IT+0x54>
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 802e0f2:	681a      	ldr	r2, [r3, #0]
 802e0f4:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 802e0f8:	601a      	str	r2, [r3, #0]
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 802e0fa:	e9d0 3216 	ldrd	r3, r2, [r0, #88]	; 0x58
 802e0fe:	605a      	str	r2, [r3, #4]
    hdma->State = HAL_DMA_STATE_READY;
 802e100:	2301      	movs	r3, #1
 802e102:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
    if (hdma->XferAbortCallback != NULL)
 802e106:	6b83      	ldr	r3, [r0, #56]	; 0x38
    __HAL_UNLOCK(hdma);
 802e108:	2400      	movs	r4, #0
 802e10a:	f880 4024 	strb.w	r4, [r0, #36]	; 0x24
    if (hdma->XferAbortCallback != NULL)
 802e10e:	b113      	cbz	r3, 802e116 <HAL_DMA_Abort_IT+0x6a>
      hdma->XferAbortCallback(hdma);
 802e110:	4798      	blx	r3
  HAL_StatusTypeDef status = HAL_OK;
 802e112:	4620      	mov	r0, r4
 802e114:	e7d2      	b.n	802e0bc <HAL_DMA_Abort_IT+0x10>
 802e116:	4618      	mov	r0, r3
 802e118:	e7d0      	b.n	802e0bc <HAL_DMA_Abort_IT+0x10>
	...

0802e11c <HAL_DMA_IRQHandler>:
{
 802e11c:	b470      	push	{r4, r5, r6}
  if (((flag_it & (DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1CU))) != 0U) && ((source_it & DMA_IT_HT) != 0U))
 802e11e:	6c42      	ldr	r2, [r0, #68]	; 0x44
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 802e120:	6c04      	ldr	r4, [r0, #64]	; 0x40
  uint32_t source_it = hdma->Instance->CCR;
 802e122:	6803      	ldr	r3, [r0, #0]
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 802e124:	6826      	ldr	r6, [r4, #0]
  uint32_t source_it = hdma->Instance->CCR;
 802e126:	681d      	ldr	r5, [r3, #0]
  if (((flag_it & (DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1CU))) != 0U) && ((source_it & DMA_IT_HT) != 0U))
 802e128:	f002 021c 	and.w	r2, r2, #28
 802e12c:	2104      	movs	r1, #4
 802e12e:	4091      	lsls	r1, r2
 802e130:	4231      	tst	r1, r6
 802e132:	d00f      	beq.n	802e154 <HAL_DMA_IRQHandler+0x38>
 802e134:	f015 0f04 	tst.w	r5, #4
 802e138:	d00c      	beq.n	802e154 <HAL_DMA_IRQHandler+0x38>
      if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 802e13a:	681a      	ldr	r2, [r3, #0]
 802e13c:	0692      	lsls	r2, r2, #26
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 802e13e:	bf5e      	ittt	pl
 802e140:	681a      	ldrpl	r2, [r3, #0]
 802e142:	f022 0204 	bicpl.w	r2, r2, #4
 802e146:	601a      	strpl	r2, [r3, #0]
      if (hdma->XferHalfCpltCallback != NULL)
 802e148:	6b03      	ldr	r3, [r0, #48]	; 0x30
      hdma->DmaBaseAddress->IFCR = DMA_ISR_HTIF1 << (hdma->ChannelIndex & 0x1CU);
 802e14a:	6061      	str	r1, [r4, #4]
    if (hdma->XferErrorCallback != NULL)
 802e14c:	2b00      	cmp	r3, #0
 802e14e:	d033      	beq.n	802e1b8 <HAL_DMA_IRQHandler+0x9c>
}
 802e150:	bc70      	pop	{r4, r5, r6}
      hdma->XferErrorCallback(hdma);
 802e152:	4718      	bx	r3
  else if ((0U != (flag_it & (DMA_FLAG_TC1 << (hdma->ChannelIndex & 0x1CU)))) && (0U != (source_it & DMA_IT_TC)))
 802e154:	2102      	movs	r1, #2
 802e156:	4091      	lsls	r1, r2
 802e158:	4231      	tst	r1, r6
 802e15a:	d017      	beq.n	802e18c <HAL_DMA_IRQHandler+0x70>
 802e15c:	f015 0f02 	tst.w	r5, #2
 802e160:	d014      	beq.n	802e18c <HAL_DMA_IRQHandler+0x70>
      if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 802e162:	681a      	ldr	r2, [r3, #0]
 802e164:	0694      	lsls	r4, r2, #26
 802e166:	d406      	bmi.n	802e176 <HAL_DMA_IRQHandler+0x5a>
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
 802e168:	681a      	ldr	r2, [r3, #0]
 802e16a:	f022 020a 	bic.w	r2, r2, #10
 802e16e:	601a      	str	r2, [r3, #0]
        hdma->State = HAL_DMA_STATE_READY;
 802e170:	2201      	movs	r2, #1
 802e172:	f880 2025 	strb.w	r2, [r0, #37]	; 0x25
      __HAL_DMA_CLEAR_FLAG(hdma, (DMA_FLAG_TC1 << (hdma->ChannelIndex & 0x1CU)));
 802e176:	4a11      	ldr	r2, [pc, #68]	; (802e1bc <HAL_DMA_IRQHandler+0xa0>)
 802e178:	4293      	cmp	r3, r2
 802e17a:	bf8c      	ite	hi
 802e17c:	4b10      	ldrhi	r3, [pc, #64]	; (802e1c0 <HAL_DMA_IRQHandler+0xa4>)
 802e17e:	4b11      	ldrls	r3, [pc, #68]	; (802e1c4 <HAL_DMA_IRQHandler+0xa8>)
 802e180:	6059      	str	r1, [r3, #4]
      __HAL_UNLOCK(hdma);
 802e182:	2300      	movs	r3, #0
 802e184:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
      if (hdma->XferCpltCallback != NULL)
 802e188:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 802e18a:	e7df      	b.n	802e14c <HAL_DMA_IRQHandler+0x30>
  else if (((flag_it & (DMA_FLAG_TE1 << (hdma->ChannelIndex & 0x1CU))) != 0U) && ((source_it & DMA_IT_TE) != 0U))
 802e18c:	2108      	movs	r1, #8
 802e18e:	4091      	lsls	r1, r2
 802e190:	4231      	tst	r1, r6
 802e192:	d011      	beq.n	802e1b8 <HAL_DMA_IRQHandler+0x9c>
 802e194:	0729      	lsls	r1, r5, #28
 802e196:	d50f      	bpl.n	802e1b8 <HAL_DMA_IRQHandler+0x9c>
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 802e198:	6819      	ldr	r1, [r3, #0]
 802e19a:	f021 010e 	bic.w	r1, r1, #14
 802e19e:	6019      	str	r1, [r3, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 802e1a0:	2301      	movs	r3, #1
 802e1a2:	fa03 f202 	lsl.w	r2, r3, r2
 802e1a6:	6062      	str	r2, [r4, #4]
    hdma->ErrorCode = HAL_DMA_ERROR_TE;
 802e1a8:	63c3      	str	r3, [r0, #60]	; 0x3c
    hdma->State = HAL_DMA_STATE_READY;
 802e1aa:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
    __HAL_UNLOCK(hdma);
 802e1ae:	2300      	movs	r3, #0
 802e1b0:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
    if (hdma->XferErrorCallback != NULL)
 802e1b4:	6b43      	ldr	r3, [r0, #52]	; 0x34
 802e1b6:	e7c9      	b.n	802e14c <HAL_DMA_IRQHandler+0x30>
}
 802e1b8:	bc70      	pop	{r4, r5, r6}
 802e1ba:	4770      	bx	lr
 802e1bc:	40020080 	.word	0x40020080
 802e1c0:	40020400 	.word	0x40020400
 802e1c4:	40020000 	.word	0x40020000

0802e1c8 <HAL_DMA_ConfigChannelAttributes>:
  if (hdma == NULL)
 802e1c8:	b160      	cbz	r0, 802e1e4 <HAL_DMA_ConfigChannelAttributes+0x1c>
  ccr = READ_REG(hdma->Instance->CCR);
 802e1ca:	6802      	ldr	r2, [r0, #0]
  if ((ChannelAttributes & DMA_CHANNEL_ATTR_PRIV_MASK) != 0U)
 802e1cc:	06c8      	lsls	r0, r1, #27
  ccr = READ_REG(hdma->Instance->CCR);
 802e1ce:	6813      	ldr	r3, [r2, #0]
  if ((ChannelAttributes & DMA_CHANNEL_ATTR_PRIV_MASK) != 0U)
 802e1d0:	d505      	bpl.n	802e1de <HAL_DMA_ConfigChannelAttributes+0x16>
    if ((ChannelAttributes & DMA_CCR_PRIV) != 0U)
 802e1d2:	02c9      	lsls	r1, r1, #11
      SET_BIT(ccr, DMA_CCR_PRIV);
 802e1d4:	bf4c      	ite	mi
 802e1d6:	f443 1380 	orrmi.w	r3, r3, #1048576	; 0x100000
      CLEAR_BIT(ccr, DMA_CCR_PRIV);
 802e1da:	f423 1380 	bicpl.w	r3, r3, #1048576	; 0x100000
  WRITE_REG(hdma->Instance->CCR, ccr);
 802e1de:	6013      	str	r3, [r2, #0]
  return status;
 802e1e0:	2000      	movs	r0, #0
 802e1e2:	4770      	bx	lr
    return status;
 802e1e4:	2001      	movs	r0, #1
}
 802e1e6:	4770      	bx	lr

0802e1e8 <HAL_EXTI_RegisterCallback>:
  *         This parameter can be one of @arg @ref EXTI_CallbackIDTypeDef values.
  * @param  pPendingCbfn function pointer to be stored as callback.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_RegisterCallback(EXTI_HandleTypeDef *hexti, EXTI_CallbackIDTypeDef CallbackID, void (*pPendingCbfn)(void))
{
 802e1e8:	4603      	mov	r3, r0
  HAL_StatusTypeDef status = HAL_OK;

  switch (CallbackID)
 802e1ea:	4608      	mov	r0, r1
 802e1ec:	b909      	cbnz	r1, 802e1f2 <HAL_EXTI_RegisterCallback+0xa>
  {
    case  HAL_EXTI_COMMON_CB_ID:
      hexti->PendingCallback = pPendingCbfn;
 802e1ee:	605a      	str	r2, [r3, #4]
      break;
 802e1f0:	4770      	bx	lr

    default:
      status = HAL_ERROR;
 802e1f2:	2001      	movs	r0, #1
      break;
  }

  return status;
}
 802e1f4:	4770      	bx	lr

0802e1f6 <HAL_EXTI_GetHandle>:
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(ExtiLine));

  /* Check null pointer */
  if (hexti == NULL)
 802e1f6:	b110      	cbz	r0, 802e1fe <HAL_EXTI_GetHandle+0x8>
    return HAL_ERROR;
  }
  else
  {
    /* Store line number as handle private field */
    hexti->Line = ExtiLine;
 802e1f8:	6001      	str	r1, [r0, #0]

    return HAL_OK;
 802e1fa:	2000      	movs	r0, #0
 802e1fc:	4770      	bx	lr
    return HAL_ERROR;
 802e1fe:	2001      	movs	r0, #1
  }
}
 802e200:	4770      	bx	lr
	...

0802e204 <FLASH_Program_Fast>:

  /* Set FSTPG bit */
#ifdef CORE_CM0PLUS
  SET_BIT(FLASH->C2CR, FLASH_CR_FSTPG);
#else
  SET_BIT(FLASH->CR, FLASH_CR_FSTPG);
 802e204:	4b0a      	ldr	r3, [pc, #40]	; (802e230 <FLASH_Program_Fast+0x2c>)
 802e206:	695a      	ldr	r2, [r3, #20]
 802e208:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
{
 802e20c:	b530      	push	{r4, r5, lr}
  SET_BIT(FLASH->CR, FLASH_CR_FSTPG);
 802e20e:	615a      	str	r2, [r3, #20]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 802e210:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 802e214:	b672      	cpsid	i
}
 802e216:	2200      	movs	r2, #0
  __disable_irq();

  /* Program the double word of the row */
  do
  {
    *dest_addr = *src_addr;
 802e218:	588d      	ldr	r5, [r1, r2]
 802e21a:	5085      	str	r5, [r0, r2]
    dest_addr++;
    src_addr++;
    row_index--;
  }
  while (row_index != 0U);
 802e21c:	3204      	adds	r2, #4
 802e21e:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 802e222:	d1f9      	bne.n	802e218 <FLASH_Program_Fast+0x14>

  /* wait for BSY in order to be sure that flash operation is ended before
     allowing prefetch in flash. Timeout does not return status, as it will
     be anyway done later */
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != 0U)
 802e224:	691a      	ldr	r2, [r3, #16]
 802e226:	03d2      	lsls	r2, r2, #15
 802e228:	d4fc      	bmi.n	802e224 <FLASH_Program_Fast+0x20>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 802e22a:	f384 8810 	msr	PRIMASK, r4
  {
  }

  /* Exit critical section: restore previous priority mask */
  __set_PRIMASK(primask_bit);
}
 802e22e:	bd30      	pop	{r4, r5, pc}
 802e230:	58004000 	.word	0x58004000

0802e234 <HAL_FLASH_Unlock>:
  if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0U)
 802e234:	4b06      	ldr	r3, [pc, #24]	; (802e250 <HAL_FLASH_Unlock+0x1c>)
 802e236:	695a      	ldr	r2, [r3, #20]
 802e238:	2a00      	cmp	r2, #0
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 802e23a:	bfbf      	itttt	lt
 802e23c:	4a05      	ldrlt	r2, [pc, #20]	; (802e254 <HAL_FLASH_Unlock+0x20>)
 802e23e:	609a      	strlt	r2, [r3, #8]
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 802e240:	f102 3288 	addlt.w	r2, r2, #2290649224	; 0x88888888
 802e244:	609a      	strlt	r2, [r3, #8]
    if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0U)
 802e246:	bfba      	itte	lt
 802e248:	6958      	ldrlt	r0, [r3, #20]
  HAL_StatusTypeDef status = HAL_OK;
 802e24a:	0fc0      	lsrlt	r0, r0, #31
 802e24c:	2000      	movge	r0, #0
}
 802e24e:	4770      	bx	lr
 802e250:	58004000 	.word	0x58004000
 802e254:	45670123 	.word	0x45670123

0802e258 <HAL_FLASH_Lock>:
  SET_BIT(FLASH->CR, FLASH_CR_LOCK);
 802e258:	4b04      	ldr	r3, [pc, #16]	; (802e26c <HAL_FLASH_Lock+0x14>)
 802e25a:	695a      	ldr	r2, [r3, #20]
 802e25c:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 802e260:	615a      	str	r2, [r3, #20]
  if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) == 0U)
 802e262:	6958      	ldr	r0, [r3, #20]
}
 802e264:	43c0      	mvns	r0, r0
 802e266:	0fc0      	lsrs	r0, r0, #31
 802e268:	4770      	bx	lr
 802e26a:	bf00      	nop
 802e26c:	58004000 	.word	0x58004000

0802e270 <FLASH_WaitForLastOperation>:
{
 802e270:	b570      	push	{r4, r5, r6, lr}
 802e272:	4605      	mov	r5, r0
  uint32_t tickstart = HAL_GetTick();
 802e274:	f7fe f9e6 	bl	802c644 <HAL_GetTick>
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 802e278:	4e12      	ldr	r6, [pc, #72]	; (802e2c4 <FLASH_WaitForLastOperation+0x54>)
  uint32_t tickstart = HAL_GetTick();
 802e27a:	4604      	mov	r4, r0
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 802e27c:	6933      	ldr	r3, [r6, #16]
 802e27e:	03d9      	lsls	r1, r3, #15
 802e280:	d413      	bmi.n	802e2aa <FLASH_WaitForLastOperation+0x3a>
  error = FLASH->SR;
 802e282:	6933      	ldr	r3, [r6, #16]
  if ((error & FLASH_FLAG_EOP) != 0U)
 802e284:	07da      	lsls	r2, r3, #31
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 802e286:	bf44      	itt	mi
 802e288:	2201      	movmi	r2, #1
 802e28a:	6132      	strmi	r2, [r6, #16]
  error &= FLASH_FLAG_SR_ERRORS;
 802e28c:	f24c 32fa 	movw	r2, #50170	; 0xc3fa
  __HAL_FLASH_CLEAR_FLAG(error);
 802e290:	4013      	ands	r3, r2
 802e292:	d111      	bne.n	802e2b8 <FLASH_WaitForLastOperation+0x48>
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_CFGBSY))
 802e294:	4e0b      	ldr	r6, [pc, #44]	; (802e2c4 <FLASH_WaitForLastOperation+0x54>)
 802e296:	6930      	ldr	r0, [r6, #16]
 802e298:	f410 2080 	ands.w	r0, r0, #262144	; 0x40000
 802e29c:	d00b      	beq.n	802e2b6 <FLASH_WaitForLastOperation+0x46>
    if ((HAL_GetTick() - tickstart) >= Timeout)
 802e29e:	f7fe f9d1 	bl	802c644 <HAL_GetTick>
 802e2a2:	1b00      	subs	r0, r0, r4
 802e2a4:	42a8      	cmp	r0, r5
 802e2a6:	d3f6      	bcc.n	802e296 <FLASH_WaitForLastOperation+0x26>
 802e2a8:	e004      	b.n	802e2b4 <FLASH_WaitForLastOperation+0x44>
    if ((HAL_GetTick() - tickstart) >= Timeout)
 802e2aa:	f7fe f9cb 	bl	802c644 <HAL_GetTick>
 802e2ae:	1b00      	subs	r0, r0, r4
 802e2b0:	42a8      	cmp	r0, r5
 802e2b2:	d3e3      	bcc.n	802e27c <FLASH_WaitForLastOperation+0xc>
      return HAL_TIMEOUT;
 802e2b4:	2003      	movs	r0, #3
}
 802e2b6:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_FLASH_CLEAR_FLAG(error);
 802e2b8:	4a02      	ldr	r2, [pc, #8]	; (802e2c4 <FLASH_WaitForLastOperation+0x54>)
 802e2ba:	6113      	str	r3, [r2, #16]
    pFlash.ErrorCode = error;
 802e2bc:	4a02      	ldr	r2, [pc, #8]	; (802e2c8 <FLASH_WaitForLastOperation+0x58>)
    return HAL_ERROR;
 802e2be:	2001      	movs	r0, #1
    pFlash.ErrorCode = error;
 802e2c0:	6053      	str	r3, [r2, #4]
    return HAL_ERROR;
 802e2c2:	e7f8      	b.n	802e2b6 <FLASH_WaitForLastOperation+0x46>
 802e2c4:	58004000 	.word	0x58004000
 802e2c8:	20003f3c 	.word	0x20003f3c

0802e2cc <HAL_FLASH_Program>:
{
 802e2cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __HAL_LOCK(&pFlash);
 802e2d0:	4c18      	ldr	r4, [pc, #96]	; (802e334 <HAL_FLASH_Program+0x68>)
{
 802e2d2:	4698      	mov	r8, r3
  __HAL_LOCK(&pFlash);
 802e2d4:	7823      	ldrb	r3, [r4, #0]
 802e2d6:	2b01      	cmp	r3, #1
{
 802e2d8:	4606      	mov	r6, r0
 802e2da:	460d      	mov	r5, r1
 802e2dc:	4617      	mov	r7, r2
  __HAL_LOCK(&pFlash);
 802e2de:	d026      	beq.n	802e32e <HAL_FLASH_Program+0x62>
 802e2e0:	2301      	movs	r3, #1
 802e2e2:	7023      	strb	r3, [r4, #0]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e2e4:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 802e2e8:	2300      	movs	r3, #0
 802e2ea:	6063      	str	r3, [r4, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e2ec:	f7ff ffc0 	bl	802e270 <FLASH_WaitForLastOperation>
  if (status == HAL_OK)
 802e2f0:	b9a0      	cbnz	r0, 802e31c <HAL_FLASH_Program+0x50>
    if (TypeProgram == FLASH_TYPEPROGRAM_DOUBLEWORD)
 802e2f2:	2e01      	cmp	r6, #1
 802e2f4:	d116      	bne.n	802e324 <HAL_FLASH_Program+0x58>
  SET_BIT(FLASH->CR, FLASH_CR_PG);
 802e2f6:	4a10      	ldr	r2, [pc, #64]	; (802e338 <HAL_FLASH_Program+0x6c>)
 802e2f8:	6953      	ldr	r3, [r2, #20]
 802e2fa:	f043 0301 	orr.w	r3, r3, #1
 802e2fe:	6153      	str	r3, [r2, #20]
  *(uint32_t *)Address = (uint32_t)Data;
 802e300:	602f      	str	r7, [r5, #0]
  __ASM volatile ("isb 0xF":::"memory");
 802e302:	f3bf 8f6f 	isb	sy
  *(uint32_t *)(Address + 4U) = (uint32_t)(Data >> 32U);
 802e306:	f8c5 8004 	str.w	r8, [r5, #4]
    status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e30a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 802e30e:	f7ff ffaf 	bl	802e270 <FLASH_WaitForLastOperation>
    CLEAR_BIT(FLASH->CR, TypeProgram);
 802e312:	4a09      	ldr	r2, [pc, #36]	; (802e338 <HAL_FLASH_Program+0x6c>)
 802e314:	6953      	ldr	r3, [r2, #20]
 802e316:	ea23 0606 	bic.w	r6, r3, r6
 802e31a:	6156      	str	r6, [r2, #20]
  __HAL_UNLOCK(&pFlash);
 802e31c:	2300      	movs	r3, #0
 802e31e:	7023      	strb	r3, [r4, #0]
}
 802e320:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      FLASH_Program_Fast(Address, (uint32_t)Data);
 802e324:	4639      	mov	r1, r7
 802e326:	4628      	mov	r0, r5
 802e328:	f7ff ff6c 	bl	802e204 <FLASH_Program_Fast>
 802e32c:	e7ed      	b.n	802e30a <HAL_FLASH_Program+0x3e>
  __HAL_LOCK(&pFlash);
 802e32e:	2002      	movs	r0, #2
 802e330:	e7f6      	b.n	802e320 <HAL_FLASH_Program+0x54>
 802e332:	bf00      	nop
 802e334:	20003f3c 	.word	0x20003f3c
 802e338:	58004000 	.word	0x58004000

0802e33c <FLASH_PageErase>:

  /* Proceed to erase the page */
#ifdef CORE_CM0PLUS
  MODIFY_REG(FLASH->C2CR, FLASH_CR_PNB, ((Page << FLASH_CR_PNB_Pos) | FLASH_CR_PER | FLASH_CR_STRT));
#else
  MODIFY_REG(FLASH->CR, FLASH_CR_PNB, ((Page << FLASH_CR_PNB_Pos) | FLASH_CR_PER | FLASH_CR_STRT));
 802e33c:	4a05      	ldr	r2, [pc, #20]	; (802e354 <FLASH_PageErase+0x18>)
 802e33e:	6953      	ldr	r3, [r2, #20]
 802e340:	f423 737e 	bic.w	r3, r3, #1016	; 0x3f8
 802e344:	ea43 00c0 	orr.w	r0, r3, r0, lsl #3
 802e348:	f440 3080 	orr.w	r0, r0, #65536	; 0x10000
 802e34c:	f040 0002 	orr.w	r0, r0, #2
 802e350:	6150      	str	r0, [r2, #20]
#endif
}
 802e352:	4770      	bx	lr
 802e354:	58004000 	.word	0x58004000

0802e358 <HAL_FLASHEx_Erase>:
{
 802e358:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __HAL_LOCK(&pFlash);
 802e35c:	4d23      	ldr	r5, [pc, #140]	; (802e3ec <HAL_FLASHEx_Erase+0x94>)
 802e35e:	782b      	ldrb	r3, [r5, #0]
 802e360:	2b01      	cmp	r3, #1
{
 802e362:	4606      	mov	r6, r0
 802e364:	4688      	mov	r8, r1
  __HAL_LOCK(&pFlash);
 802e366:	d03f      	beq.n	802e3e8 <HAL_FLASHEx_Erase+0x90>
 802e368:	2301      	movs	r3, #1
 802e36a:	702b      	strb	r3, [r5, #0]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e36c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 802e370:	2300      	movs	r3, #0
 802e372:	606b      	str	r3, [r5, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e374:	f7ff ff7c 	bl	802e270 <FLASH_WaitForLastOperation>
  if (status == HAL_OK)
 802e378:	4604      	mov	r4, r0
 802e37a:	b988      	cbnz	r0, 802e3a0 <HAL_FLASHEx_Erase+0x48>
    if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 802e37c:	6833      	ldr	r3, [r6, #0]
 802e37e:	2b04      	cmp	r3, #4
 802e380:	d113      	bne.n	802e3aa <HAL_FLASHEx_Erase+0x52>
  SET_BIT(FLASH->CR, (FLASH_CR_MER | FLASH_CR_STRT));
 802e382:	4a1b      	ldr	r2, [pc, #108]	; (802e3f0 <HAL_FLASHEx_Erase+0x98>)
 802e384:	6953      	ldr	r3, [r2, #20]
 802e386:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 802e38a:	f043 0304 	orr.w	r3, r3, #4
 802e38e:	6153      	str	r3, [r2, #20]
      status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e390:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 802e394:	f7ff ff6c 	bl	802e270 <FLASH_WaitForLastOperation>
 802e398:	4604      	mov	r4, r0
  * @retval None
  */
void FLASH_FlushCaches(void)
{
  /* Flush instruction cache  */
  if (READ_BIT(FLASH->ACR, FLASH_ACR_ICEN) == 1U)
 802e39a:	4b15      	ldr	r3, [pc, #84]	; (802e3f0 <HAL_FLASHEx_Erase+0x98>)
 802e39c:	681a      	ldr	r2, [r3, #0]
  }

#ifdef CORE_CM0PLUS
#else
  /* Flush data cache */
  if (READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) == 1U)
 802e39e:	681b      	ldr	r3, [r3, #0]
  __HAL_UNLOCK(&pFlash);
 802e3a0:	2300      	movs	r3, #0
 802e3a2:	702b      	strb	r3, [r5, #0]
}
 802e3a4:	4620      	mov	r0, r4
 802e3a6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      *PageError = 0xFFFFFFFFU;
 802e3aa:	f04f 33ff 	mov.w	r3, #4294967295
 802e3ae:	f8c8 3000 	str.w	r3, [r8]
      for (index = pEraseInit->Page; index < (pEraseInit->Page + pEraseInit->NbPages); index++)
 802e3b2:	6877      	ldr	r7, [r6, #4]
 802e3b4:	e9d6 3201 	ldrd	r3, r2, [r6, #4]
 802e3b8:	4413      	add	r3, r2
 802e3ba:	42bb      	cmp	r3, r7
 802e3bc:	d90a      	bls.n	802e3d4 <HAL_FLASHEx_Erase+0x7c>
        FLASH_PageErase(index);
 802e3be:	4638      	mov	r0, r7
 802e3c0:	f7ff ffbc 	bl	802e33c <FLASH_PageErase>
        status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e3c4:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 802e3c8:	f7ff ff52 	bl	802e270 <FLASH_WaitForLastOperation>
        if (status != HAL_OK)
 802e3cc:	b150      	cbz	r0, 802e3e4 <HAL_FLASHEx_Erase+0x8c>
          *PageError = index;
 802e3ce:	f8c8 7000 	str.w	r7, [r8]
        status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e3d2:	4604      	mov	r4, r0
static void FLASH_AcknowledgePageErase(void)
{
#ifdef CORE_CM0PLUS
  CLEAR_BIT(FLASH->C2CR, (FLASH_CR_PER | FLASH_CR_PNB));
#else
  CLEAR_BIT(FLASH->CR, (FLASH_CR_PER | FLASH_CR_PNB));
 802e3d4:	4a06      	ldr	r2, [pc, #24]	; (802e3f0 <HAL_FLASHEx_Erase+0x98>)
 802e3d6:	6953      	ldr	r3, [r2, #20]
 802e3d8:	f423 737e 	bic.w	r3, r3, #1016	; 0x3f8
 802e3dc:	f023 0302 	bic.w	r3, r3, #2
 802e3e0:	6153      	str	r3, [r2, #20]
#endif
}
 802e3e2:	e7da      	b.n	802e39a <HAL_FLASHEx_Erase+0x42>
      for (index = pEraseInit->Page; index < (pEraseInit->Page + pEraseInit->NbPages); index++)
 802e3e4:	3701      	adds	r7, #1
 802e3e6:	e7e5      	b.n	802e3b4 <HAL_FLASHEx_Erase+0x5c>
  __HAL_LOCK(&pFlash);
 802e3e8:	2402      	movs	r4, #2
 802e3ea:	e7db      	b.n	802e3a4 <HAL_FLASHEx_Erase+0x4c>
 802e3ec:	20003f3c 	.word	0x20003f3c
 802e3f0:	58004000 	.word	0x58004000

0802e3f4 <HAL_FLASHEx_Erase_IT>:
{
 802e3f4:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(&pFlash);
 802e3f6:	4c16      	ldr	r4, [pc, #88]	; (802e450 <HAL_FLASHEx_Erase_IT+0x5c>)
 802e3f8:	7823      	ldrb	r3, [r4, #0]
 802e3fa:	2b01      	cmp	r3, #1
{
 802e3fc:	4605      	mov	r5, r0
  __HAL_LOCK(&pFlash);
 802e3fe:	d025      	beq.n	802e44c <HAL_FLASHEx_Erase_IT+0x58>
 802e400:	2301      	movs	r3, #1
 802e402:	7023      	strb	r3, [r4, #0]
  pFlash.ProcedureOnGoing = pEraseInit->TypeErase;
 802e404:	6803      	ldr	r3, [r0, #0]
 802e406:	60a3      	str	r3, [r4, #8]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 802e408:	2600      	movs	r6, #0
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e40a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 802e40e:	6066      	str	r6, [r4, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e410:	f7ff ff2e 	bl	802e270 <FLASH_WaitForLastOperation>
  if (status != HAL_OK)
 802e414:	4601      	mov	r1, r0
 802e416:	b110      	cbz	r0, 802e41e <HAL_FLASHEx_Erase_IT+0x2a>
    __HAL_UNLOCK(&pFlash);
 802e418:	7026      	strb	r6, [r4, #0]
}
 802e41a:	4608      	mov	r0, r1
 802e41c:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP | FLASH_IT_OPERR);
 802e41e:	4a0d      	ldr	r2, [pc, #52]	; (802e454 <HAL_FLASHEx_Erase_IT+0x60>)
 802e420:	6953      	ldr	r3, [r2, #20]
 802e422:	f043 7340 	orr.w	r3, r3, #50331648	; 0x3000000
 802e426:	6153      	str	r3, [r2, #20]
    if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 802e428:	682b      	ldr	r3, [r5, #0]
 802e42a:	2b04      	cmp	r3, #4
 802e42c:	d107      	bne.n	802e43e <HAL_FLASHEx_Erase_IT+0x4a>
      pFlash.Page = 0;
 802e42e:	6120      	str	r0, [r4, #16]
  SET_BIT(FLASH->CR, (FLASH_CR_MER | FLASH_CR_STRT));
 802e430:	6953      	ldr	r3, [r2, #20]
 802e432:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 802e436:	f043 0304 	orr.w	r3, r3, #4
 802e43a:	6153      	str	r3, [r2, #20]
}
 802e43c:	e7ed      	b.n	802e41a <HAL_FLASHEx_Erase_IT+0x26>
      pFlash.NbPagesToErase = pEraseInit->NbPages;
 802e43e:	68ab      	ldr	r3, [r5, #8]
      pFlash.Page = pEraseInit->Page;
 802e440:	6868      	ldr	r0, [r5, #4]
      pFlash.NbPagesToErase = pEraseInit->NbPages;
 802e442:	6163      	str	r3, [r4, #20]
      pFlash.Page = pEraseInit->Page;
 802e444:	6120      	str	r0, [r4, #16]
      FLASH_PageErase(pEraseInit->Page);
 802e446:	f7ff ff79 	bl	802e33c <FLASH_PageErase>
 802e44a:	e7e6      	b.n	802e41a <HAL_FLASHEx_Erase_IT+0x26>
  __HAL_LOCK(&pFlash);
 802e44c:	2102      	movs	r1, #2
 802e44e:	e7e4      	b.n	802e41a <HAL_FLASHEx_Erase_IT+0x26>
 802e450:	20003f3c 	.word	0x20003f3c
 802e454:	58004000 	.word	0x58004000

0802e458 <HAL_GPIO_Init>:
  * @param GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 802e458:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

        /* Clear EXTI line configuration */
#ifdef CORE_CM0PLUS
        temp = EXTI->C2IMR1;
#else
        temp = EXTI->IMR1;
 802e45c:	4c52      	ldr	r4, [pc, #328]	; (802e5a8 <HAL_GPIO_Init+0x150>)
  uint32_t position = 0x00u;
 802e45e:	2300      	movs	r3, #0
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 802e460:	f04f 090f 	mov.w	r9, #15
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 802e464:	680a      	ldr	r2, [r1, #0]
 802e466:	fa32 f503 	lsrs.w	r5, r2, r3
 802e46a:	d101      	bne.n	802e470 <HAL_GPIO_Init+0x18>
      }
    }

    position++;
  }
}
 802e46c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 802e470:	2501      	movs	r5, #1
 802e472:	fa05 f803 	lsl.w	r8, r5, r3
    if (iocurrent != 0x00u)
 802e476:	ea18 0202 	ands.w	r2, r8, r2
 802e47a:	f000 808f 	beq.w	802e59c <HAL_GPIO_Init+0x144>
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 802e47e:	684e      	ldr	r6, [r1, #4]
 802e480:	2703      	movs	r7, #3
 802e482:	f006 0503 	and.w	r5, r6, #3
 802e486:	ea4f 0e43 	mov.w	lr, r3, lsl #1
 802e48a:	fa07 fc0e 	lsl.w	ip, r7, lr
 802e48e:	1e6f      	subs	r7, r5, #1
 802e490:	2f01      	cmp	r7, #1
 802e492:	ea6f 0c0c 	mvn.w	ip, ip
 802e496:	d832      	bhi.n	802e4fe <HAL_GPIO_Init+0xa6>
        temp = GPIOx->OSPEEDR;
 802e498:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 802e49a:	ea07 0a0c 	and.w	sl, r7, ip
        temp |= (GPIO_Init->Speed << (position * 2U));
 802e49e:	68cf      	ldr	r7, [r1, #12]
 802e4a0:	fa07 f70e 	lsl.w	r7, r7, lr
 802e4a4:	ea47 070a 	orr.w	r7, r7, sl
        GPIOx->OSPEEDR = temp;
 802e4a8:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 802e4aa:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 802e4ac:	ea27 0808 	bic.w	r8, r7, r8
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 802e4b0:	f3c6 1700 	ubfx	r7, r6, #4, #1
 802e4b4:	409f      	lsls	r7, r3
 802e4b6:	ea47 0708 	orr.w	r7, r7, r8
        GPIOx->OTYPER = temp;
 802e4ba:	6047      	str	r7, [r0, #4]
        temp = GPIOx->PUPDR;
 802e4bc:	68c7      	ldr	r7, [r0, #12]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 802e4be:	ea07 080c 	and.w	r8, r7, ip
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 802e4c2:	688f      	ldr	r7, [r1, #8]
 802e4c4:	fa07 f70e 	lsl.w	r7, r7, lr
 802e4c8:	ea47 0708 	orr.w	r7, r7, r8
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 802e4cc:	2d02      	cmp	r5, #2
        GPIOx->PUPDR = temp;
 802e4ce:	60c7      	str	r7, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 802e4d0:	d117      	bne.n	802e502 <HAL_GPIO_Init+0xaa>
        temp = GPIOx->AFR[position >> 3U];
 802e4d2:	ea4f 08d3 	mov.w	r8, r3, lsr #3
 802e4d6:	eb00 0888 	add.w	r8, r0, r8, lsl #2
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 802e4da:	f003 0a07 	and.w	sl, r3, #7
        temp = GPIOx->AFR[position >> 3U];
 802e4de:	f8d8 7020 	ldr.w	r7, [r8, #32]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 802e4e2:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 802e4e6:	fa09 fb0a 	lsl.w	fp, r9, sl
 802e4ea:	ea27 0b0b 	bic.w	fp, r7, fp
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 802e4ee:	690f      	ldr	r7, [r1, #16]
 802e4f0:	fa07 f70a 	lsl.w	r7, r7, sl
 802e4f4:	ea47 070b 	orr.w	r7, r7, fp
        GPIOx->AFR[position >> 3u] = temp;
 802e4f8:	f8c8 7020 	str.w	r7, [r8, #32]
 802e4fc:	e001      	b.n	802e502 <HAL_GPIO_Init+0xaa>
      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 802e4fe:	2d03      	cmp	r5, #3
 802e500:	d1dc      	bne.n	802e4bc <HAL_GPIO_Init+0x64>
      temp = GPIOx->MODER;
 802e502:	6807      	ldr	r7, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 802e504:	ea07 0c0c 	and.w	ip, r7, ip
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 802e508:	fa05 f70e 	lsl.w	r7, r5, lr
 802e50c:	ea47 070c 	orr.w	r7, r7, ip
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 802e510:	f416 3f40 	tst.w	r6, #196608	; 0x30000
      GPIOx->MODER = temp;
 802e514:	6007      	str	r7, [r0, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 802e516:	d041      	beq.n	802e59c <HAL_GPIO_Init+0x144>
        temp = SYSCFG->EXTICR[position >> 2u];
 802e518:	f023 0703 	bic.w	r7, r3, #3
 802e51c:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
 802e520:	f507 3780 	add.w	r7, r7, #65536	; 0x10000
        temp &= ~(0x07uL << (4U * (position & 0x03U)));
 802e524:	f003 0c03 	and.w	ip, r3, #3
        temp = SYSCFG->EXTICR[position >> 2u];
 802e528:	68bd      	ldr	r5, [r7, #8]
        temp &= ~(0x07uL << (4U * (position & 0x03U)));
 802e52a:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 802e52e:	f04f 0e07 	mov.w	lr, #7
 802e532:	fa0e fe0c 	lsl.w	lr, lr, ip
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 802e536:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
        temp &= ~(0x07uL << (4U * (position & 0x03U)));
 802e53a:	ea25 0e0e 	bic.w	lr, r5, lr
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 802e53e:	d02f      	beq.n	802e5a0 <HAL_GPIO_Init+0x148>
 802e540:	4d1a      	ldr	r5, [pc, #104]	; (802e5ac <HAL_GPIO_Init+0x154>)
 802e542:	42a8      	cmp	r0, r5
 802e544:	d02e      	beq.n	802e5a4 <HAL_GPIO_Init+0x14c>
 802e546:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 802e54a:	42a8      	cmp	r0, r5
 802e54c:	bf0c      	ite	eq
 802e54e:	2502      	moveq	r5, #2
 802e550:	2507      	movne	r5, #7
 802e552:	fa05 f50c 	lsl.w	r5, r5, ip
 802e556:	ea45 050e 	orr.w	r5, r5, lr
        SYSCFG->EXTICR[position >> 2u] = temp;
 802e55a:	60bd      	str	r5, [r7, #8]
        temp = EXTI->IMR1;
 802e55c:	f8d4 5080 	ldr.w	r5, [r4, #128]	; 0x80
        temp &= ~(iocurrent);
 802e560:	43d7      	mvns	r7, r2
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00u)
 802e562:	f416 3f80 	tst.w	r6, #65536	; 0x10000
        temp &= ~(iocurrent);
 802e566:	bf0c      	ite	eq
 802e568:	403d      	andeq	r5, r7
          temp |= iocurrent;
 802e56a:	4315      	orrne	r5, r2
        EXTI->IMR1 = temp;
 802e56c:	f8c4 5080 	str.w	r5, [r4, #128]	; 0x80
        temp = EXTI->EMR1;
 802e570:	f8d4 5084 	ldr.w	r5, [r4, #132]	; 0x84
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
 802e574:	f416 3f00 	tst.w	r6, #131072	; 0x20000
        temp &= ~(iocurrent);
 802e578:	bf0c      	ite	eq
 802e57a:	403d      	andeq	r5, r7
          temp |= iocurrent;
 802e57c:	4315      	orrne	r5, r2
        EXTI->EMR1 = temp;
 802e57e:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
        temp = EXTI->RTSR1;
 802e582:	6825      	ldr	r5, [r4, #0]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
 802e584:	f416 1f80 	tst.w	r6, #1048576	; 0x100000
        temp &= ~(iocurrent);
 802e588:	bf0c      	ite	eq
 802e58a:	403d      	andeq	r5, r7
          temp |= iocurrent;
 802e58c:	4315      	orrne	r5, r2
        EXTI->RTSR1 = temp;
 802e58e:	6025      	str	r5, [r4, #0]
        temp = EXTI->FTSR1;
 802e590:	6865      	ldr	r5, [r4, #4]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
 802e592:	02b6      	lsls	r6, r6, #10
        temp &= ~(iocurrent);
 802e594:	bf54      	ite	pl
 802e596:	403d      	andpl	r5, r7
          temp |= iocurrent;
 802e598:	4315      	orrmi	r5, r2
        EXTI->FTSR1 = temp;
 802e59a:	6065      	str	r5, [r4, #4]
    position++;
 802e59c:	3301      	adds	r3, #1
 802e59e:	e761      	b.n	802e464 <HAL_GPIO_Init+0xc>
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 802e5a0:	2500      	movs	r5, #0
 802e5a2:	e7d6      	b.n	802e552 <HAL_GPIO_Init+0xfa>
 802e5a4:	2501      	movs	r5, #1
 802e5a6:	e7d4      	b.n	802e552 <HAL_GPIO_Init+0xfa>
 802e5a8:	58000800 	.word	0x58000800
 802e5ac:	48000400 	.word	0x48000400

0802e5b0 <HAL_GPIO_DeInit>:
        /* Clear EXTI line configuration */
#ifdef CORE_CM0PLUS
        EXTI->C2IMR1 &= ~(iocurrent);
        EXTI->C2EMR1 &= ~(iocurrent);
#else
        EXTI->IMR1 &= ~(iocurrent);
 802e5b0:	4a37      	ldr	r2, [pc, #220]	; (802e690 <HAL_GPIO_DeInit+0xe0>)
{
 802e5b2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t position = 0x00u;
 802e5b6:	2300      	movs	r3, #0
    iocurrent = (GPIO_Pin) & (1uL << position);
 802e5b8:	f04f 0a01 	mov.w	sl, #1
      tmp &= (0x07uL << (4U * (position & 0x03U)));
 802e5bc:	f04f 0b07 	mov.w	fp, #7
      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
 802e5c0:	f04f 090f 	mov.w	r9, #15
  while ((GPIO_Pin >> position) != 0x00u)
 802e5c4:	fa31 f403 	lsrs.w	r4, r1, r3
 802e5c8:	d101      	bne.n	802e5ce <HAL_GPIO_DeInit+0x1e>
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
    }

    position++;
  }
}
 802e5ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Pin) & (1uL << position);
 802e5ce:	fa0a fc03 	lsl.w	ip, sl, r3
    if (iocurrent != 0x00u)
 802e5d2:	ea1c 0601 	ands.w	r6, ip, r1
 802e5d6:	d054      	beq.n	802e682 <HAL_GPIO_DeInit+0xd2>
      tmp = SYSCFG->EXTICR[position >> 2u];
 802e5d8:	f023 0403 	bic.w	r4, r3, #3
 802e5dc:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 802e5e0:	f504 3480 	add.w	r4, r4, #65536	; 0x10000
      tmp &= (0x07uL << (4U * (position & 0x03U)));
 802e5e4:	f003 0703 	and.w	r7, r3, #3
      tmp = SYSCFG->EXTICR[position >> 2u];
 802e5e8:	68a5      	ldr	r5, [r4, #8]
      tmp &= (0x07uL << (4U * (position & 0x03U)));
 802e5ea:	00bf      	lsls	r7, r7, #2
 802e5ec:	fa0b f807 	lsl.w	r8, fp, r7
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 802e5f0:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
      tmp &= (0x07uL << (4U * (position & 0x03U)));
 802e5f4:	ea08 0e05 	and.w	lr, r8, r5
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 802e5f8:	d045      	beq.n	802e686 <HAL_GPIO_DeInit+0xd6>
 802e5fa:	4d26      	ldr	r5, [pc, #152]	; (802e694 <HAL_GPIO_DeInit+0xe4>)
 802e5fc:	42a8      	cmp	r0, r5
 802e5fe:	d044      	beq.n	802e68a <HAL_GPIO_DeInit+0xda>
 802e600:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 802e604:	42a8      	cmp	r0, r5
 802e606:	bf0c      	ite	eq
 802e608:	2502      	moveq	r5, #2
 802e60a:	2507      	movne	r5, #7
 802e60c:	40bd      	lsls	r5, r7
 802e60e:	4575      	cmp	r5, lr
 802e610:	d117      	bne.n	802e642 <HAL_GPIO_DeInit+0x92>
        EXTI->IMR1 &= ~(iocurrent);
 802e612:	f8d2 5080 	ldr.w	r5, [r2, #128]	; 0x80
 802e616:	ea25 0506 	bic.w	r5, r5, r6
 802e61a:	f8c2 5080 	str.w	r5, [r2, #128]	; 0x80
        EXTI->EMR1 &= ~(iocurrent);
 802e61e:	f8d2 5084 	ldr.w	r5, [r2, #132]	; 0x84
 802e622:	ea25 0506 	bic.w	r5, r5, r6
 802e626:	f8c2 5084 	str.w	r5, [r2, #132]	; 0x84
        EXTI->RTSR1 &= ~(iocurrent);
 802e62a:	6815      	ldr	r5, [r2, #0]
 802e62c:	ea25 0506 	bic.w	r5, r5, r6
 802e630:	6015      	str	r5, [r2, #0]
        EXTI->FTSR1 &= ~(iocurrent);
 802e632:	6855      	ldr	r5, [r2, #4]
 802e634:	ea25 0606 	bic.w	r6, r5, r6
 802e638:	6056      	str	r6, [r2, #4]
        SYSCFG->EXTICR[position >> 2u] &= ~tmp;
 802e63a:	68a5      	ldr	r5, [r4, #8]
 802e63c:	ea25 0508 	bic.w	r5, r5, r8
 802e640:	60a5      	str	r5, [r4, #8]
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
 802e642:	6805      	ldr	r5, [r0, #0]
 802e644:	2603      	movs	r6, #3
 802e646:	005c      	lsls	r4, r3, #1
 802e648:	fa06 f404 	lsl.w	r4, r6, r4
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
 802e64c:	fa23 f606 	lsr.w	r6, r3, r6
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
 802e650:	4325      	orrs	r5, r4
 802e652:	eb00 0686 	add.w	r6, r0, r6, lsl #2
 802e656:	6005      	str	r5, [r0, #0]
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
 802e658:	f003 0507 	and.w	r5, r3, #7
 802e65c:	6a37      	ldr	r7, [r6, #32]
 802e65e:	00ad      	lsls	r5, r5, #2
 802e660:	fa09 f505 	lsl.w	r5, r9, r5
 802e664:	ea27 0505 	bic.w	r5, r7, r5
 802e668:	6235      	str	r5, [r6, #32]
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 802e66a:	6885      	ldr	r5, [r0, #8]
 802e66c:	ea25 0504 	bic.w	r5, r5, r4
 802e670:	6085      	str	r5, [r0, #8]
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
 802e672:	6845      	ldr	r5, [r0, #4]
 802e674:	ea25 050c 	bic.w	r5, r5, ip
 802e678:	6045      	str	r5, [r0, #4]
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 802e67a:	68c5      	ldr	r5, [r0, #12]
 802e67c:	ea25 0404 	bic.w	r4, r5, r4
 802e680:	60c4      	str	r4, [r0, #12]
    position++;
 802e682:	3301      	adds	r3, #1
 802e684:	e79e      	b.n	802e5c4 <HAL_GPIO_DeInit+0x14>
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 802e686:	2500      	movs	r5, #0
 802e688:	e7c0      	b.n	802e60c <HAL_GPIO_DeInit+0x5c>
 802e68a:	2501      	movs	r5, #1
 802e68c:	e7be      	b.n	802e60c <HAL_GPIO_DeInit+0x5c>
 802e68e:	bf00      	nop
 802e690:	58000800 	.word	0x58000800
 802e694:	48000400 	.word	0x48000400

0802e698 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 802e698:	b10a      	cbz	r2, 802e69e <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 802e69a:	6181      	str	r1, [r0, #24]
 802e69c:	4770      	bx	lr
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 802e69e:	6281      	str	r1, [r0, #40]	; 0x28
  }
}
 802e6a0:	4770      	bx	lr

0802e6a2 <HAL_GPIO_TogglePin>:

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
 802e6a2:	6943      	ldr	r3, [r0, #20]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
 802e6a4:	ea01 0203 	and.w	r2, r1, r3
 802e6a8:	ea21 0103 	bic.w	r1, r1, r3
 802e6ac:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 802e6b0:	6181      	str	r1, [r0, #24]
}
 802e6b2:	4770      	bx	lr

0802e6b4 <HAL_GPIO_EXTI_IRQHandler>:
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
  /* EXTI line interrupt detected */
  if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)
 802e6b4:	4a04      	ldr	r2, [pc, #16]	; (802e6c8 <HAL_GPIO_EXTI_IRQHandler+0x14>)
 802e6b6:	68d1      	ldr	r1, [r2, #12]
 802e6b8:	4201      	tst	r1, r0
{
 802e6ba:	b508      	push	{r3, lr}
  if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)
 802e6bc:	d002      	beq.n	802e6c4 <HAL_GPIO_EXTI_IRQHandler+0x10>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 802e6be:	60d0      	str	r0, [r2, #12]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 802e6c0:	f7fe fc5a 	bl	802cf78 <HAL_GPIO_EXTI_Callback>
  }
}
 802e6c4:	bd08      	pop	{r3, pc}
 802e6c6:	bf00      	nop
 802e6c8:	58000800 	.word	0x58000800

0802e6cc <HAL_PWR_EnableBkUpAccess>:
  *         backup domain.
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
 802e6cc:	4a02      	ldr	r2, [pc, #8]	; (802e6d8 <HAL_PWR_EnableBkUpAccess+0xc>)
 802e6ce:	6813      	ldr	r3, [r2, #0]
 802e6d0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 802e6d4:	6013      	str	r3, [r2, #0]
}
 802e6d6:	4770      	bx	lr
 802e6d8:	58000400 	.word	0x58000400

0802e6dc <HAL_PWR_EnterSLEEPMode>:
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR(Regulator));
  assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));

  /* Set Regulator parameter */
  if (Regulator == PWR_MAINREGULATOR_ON)
 802e6dc:	4b0d      	ldr	r3, [pc, #52]	; (802e714 <HAL_PWR_EnterSLEEPMode+0x38>)
{
 802e6de:	b510      	push	{r4, lr}
  {
    /* If in low-power run mode at this point, exit it */
    if (HAL_IS_BIT_SET(PWR->SR2, (PWR_SR2_REGLPF)))
 802e6e0:	695b      	ldr	r3, [r3, #20]
{
 802e6e2:	460c      	mov	r4, r1
  if (Regulator == PWR_MAINREGULATOR_ON)
 802e6e4:	b928      	cbnz	r0, 802e6f2 <HAL_PWR_EnterSLEEPMode+0x16>
    if (HAL_IS_BIT_SET(PWR->SR2, (PWR_SR2_REGLPF)))
 802e6e6:	059a      	lsls	r2, r3, #22
 802e6e8:	d507      	bpl.n	802e6fa <HAL_PWR_EnterSLEEPMode+0x1e>
    {
      if (HAL_PWREx_DisableLowPowerRunMode() != HAL_OK)
 802e6ea:	f000 f827 	bl	802e73c <HAL_PWREx_DisableLowPowerRunMode>
 802e6ee:	b120      	cbz	r0, 802e6fa <HAL_PWR_EnterSLEEPMode+0x1e>
    /* Request Wait For Event */
    __SEV();
    __WFE();
    __WFE();
  }
}
 802e6f0:	bd10      	pop	{r4, pc}
    if (HAL_IS_BIT_CLR(PWR->SR2, (PWR_SR2_REGLPF)))
 802e6f2:	059b      	lsls	r3, r3, #22
 802e6f4:	d401      	bmi.n	802e6fa <HAL_PWR_EnterSLEEPMode+0x1e>
      HAL_PWREx_EnableLowPowerRunMode();
 802e6f6:	f000 f819 	bl	802e72c <HAL_PWREx_EnableLowPowerRunMode>
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 802e6fa:	4a07      	ldr	r2, [pc, #28]	; (802e718 <HAL_PWR_EnterSLEEPMode+0x3c>)
 802e6fc:	6913      	ldr	r3, [r2, #16]
  if (SLEEPEntry == PWR_SLEEPENTRY_WFI)
 802e6fe:	2c01      	cmp	r4, #1
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 802e700:	f023 0304 	bic.w	r3, r3, #4
 802e704:	6113      	str	r3, [r2, #16]
  if (SLEEPEntry == PWR_SLEEPENTRY_WFI)
 802e706:	d101      	bne.n	802e70c <HAL_PWR_EnterSLEEPMode+0x30>
    __WFI();
 802e708:	bf30      	wfi
 802e70a:	e7f1      	b.n	802e6f0 <HAL_PWR_EnterSLEEPMode+0x14>
    __SEV();
 802e70c:	bf40      	sev
    __WFE();
 802e70e:	bf20      	wfe
    __WFE();
 802e710:	bf20      	wfe
 802e712:	e7ed      	b.n	802e6f0 <HAL_PWR_EnterSLEEPMode+0x14>
 802e714:	58000400 	.word	0x58000400
 802e718:	e000ed00 	.word	0xe000ed00

0802e71c <HAL_PWREx_GetVoltageRange>:
  * @brief Return Voltage Scaling Range.
  * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_SCALE1 or PWPWR_REGULATOR_VOLTAGE_SCALE2)
  */
uint32_t HAL_PWREx_GetVoltageRange(void)
{
  return (PWR->CR1 & PWR_CR1_VOS);
 802e71c:	4b02      	ldr	r3, [pc, #8]	; (802e728 <HAL_PWREx_GetVoltageRange+0xc>)
 802e71e:	6818      	ldr	r0, [r3, #0]
}
 802e720:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
 802e724:	4770      	bx	lr
 802e726:	bf00      	nop
 802e728:	58000400 	.word	0x58000400

0802e72c <HAL_PWREx_EnableLowPowerRunMode>:
  * @retval None
  */
void HAL_PWREx_EnableLowPowerRunMode(void)
{
  /* Set Regulator parameter */
  SET_BIT(PWR->CR1, PWR_CR1_LPR);
 802e72c:	4a02      	ldr	r2, [pc, #8]	; (802e738 <HAL_PWREx_EnableLowPowerRunMode+0xc>)
 802e72e:	6813      	ldr	r3, [r2, #0]
 802e730:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 802e734:	6013      	str	r3, [r2, #0]
}
 802e736:	4770      	bx	lr
 802e738:	58000400 	.word	0x58000400

0802e73c <HAL_PWREx_DisableLowPowerRunMode>:
HAL_StatusTypeDef HAL_PWREx_DisableLowPowerRunMode(void)
{
  uint32_t wait_loop_index;

  /* Clear LPR bit */
  CLEAR_BIT(PWR->CR1, PWR_CR1_LPR);
 802e73c:	4a0d      	ldr	r2, [pc, #52]	; (802e774 <HAL_PWREx_DisableLowPowerRunMode+0x38>)
 802e73e:	6813      	ldr	r3, [r2, #0]
 802e740:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 802e744:	6013      	str	r3, [r2, #0]

  /* Wait until REGLPF is reset */
  wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000UL);
 802e746:	4b0c      	ldr	r3, [pc, #48]	; (802e778 <HAL_PWREx_DisableLowPowerRunMode+0x3c>)
 802e748:	6819      	ldr	r1, [r3, #0]
 802e74a:	2332      	movs	r3, #50	; 0x32
 802e74c:	434b      	muls	r3, r1
 802e74e:	490b      	ldr	r1, [pc, #44]	; (802e77c <HAL_PWREx_DisableLowPowerRunMode+0x40>)
 802e750:	fbb3 f3f1 	udiv	r3, r3, r1
  while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF)) && (wait_loop_index != 0U))
 802e754:	4611      	mov	r1, r2
 802e756:	6950      	ldr	r0, [r2, #20]
 802e758:	f410 7f00 	tst.w	r0, #512	; 0x200
 802e75c:	d000      	beq.n	802e760 <HAL_PWREx_DisableLowPowerRunMode+0x24>
 802e75e:	b933      	cbnz	r3, 802e76e <HAL_PWREx_DisableLowPowerRunMode+0x32>
  {
    wait_loop_index--;
  }
  if (HAL_IS_BIT_SET(PWR->SR2, (PWR_SR2_REGLPF)))
 802e760:	694b      	ldr	r3, [r1, #20]
  {
    return HAL_TIMEOUT;
 802e762:	f413 7f00 	tst.w	r3, #512	; 0x200
  }

  return HAL_OK;
}
 802e766:	bf14      	ite	ne
 802e768:	2003      	movne	r0, #3
 802e76a:	2000      	moveq	r0, #0
 802e76c:	4770      	bx	lr
    wait_loop_index--;
 802e76e:	3b01      	subs	r3, #1
 802e770:	e7f1      	b.n	802e756 <HAL_PWREx_DisableLowPowerRunMode+0x1a>
 802e772:	bf00      	nop
 802e774:	58000400 	.word	0x58000400
 802e778:	2000344c 	.word	0x2000344c
 802e77c:	000f4240 	.word	0x000f4240

0802e780 <HAL_PWREx_EnterSTOP2Mode>:
#ifdef CORE_CM0PLUS
  /* Set Stop mode 2 */
  MODIFY_REG(PWR->C2CR1, PWR_C2CR1_LPMS, PWR_LOWPOWERMODE_STOP2);
#else
  /* Set Stop mode 2 */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_LOWPOWERMODE_STOP2);
 802e780:	4a0b      	ldr	r2, [pc, #44]	; (802e7b0 <HAL_PWREx_EnterSTOP2Mode+0x30>)
 802e782:	6813      	ldr	r3, [r2, #0]
 802e784:	f023 0307 	bic.w	r3, r3, #7
 802e788:	f043 0302 	orr.w	r3, r3, #2
 802e78c:	6013      	str	r3, [r2, #0]
#endif

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 802e78e:	4b09      	ldr	r3, [pc, #36]	; (802e7b4 <HAL_PWREx_EnterSTOP2Mode+0x34>)
 802e790:	691a      	ldr	r2, [r3, #16]

  /* Select Stop mode entry --------------------------------------------------*/
  if (STOPEntry == PWR_STOPENTRY_WFI)
 802e792:	2801      	cmp	r0, #1
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 802e794:	f042 0204 	orr.w	r2, r2, #4
 802e798:	611a      	str	r2, [r3, #16]
  if (STOPEntry == PWR_STOPENTRY_WFI)
 802e79a:	d105      	bne.n	802e7a8 <HAL_PWREx_EnterSTOP2Mode+0x28>
  {
    /* Request Wait For Interrupt */
    __WFI();
 802e79c:	bf30      	wfi
    __WFE();
    __WFE();
  }

  /* Reset SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 802e79e:	691a      	ldr	r2, [r3, #16]
 802e7a0:	f022 0204 	bic.w	r2, r2, #4
 802e7a4:	611a      	str	r2, [r3, #16]
}
 802e7a6:	4770      	bx	lr
    __SEV();
 802e7a8:	bf40      	sev
    __WFE();
 802e7aa:	bf20      	wfe
    __WFE();
 802e7ac:	bf20      	wfe
 802e7ae:	e7f6      	b.n	802e79e <HAL_PWREx_EnterSTOP2Mode+0x1e>
 802e7b0:	58000400 	.word	0x58000400
 802e7b4:	e000ed00 	.word	0xe000ed00

0802e7b8 <LL_RCC_HSE_IsReady>:
  return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
 802e7b8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802e7bc:	6818      	ldr	r0, [r3, #0]
}
 802e7be:	f3c0 4040 	ubfx	r0, r0, #17, #1
 802e7c2:	4770      	bx	lr

0802e7c4 <LL_RCC_HSI_IsReady>:
  return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
 802e7c4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802e7c8:	6818      	ldr	r0, [r3, #0]
}
 802e7ca:	f3c0 2080 	ubfx	r0, r0, #10, #1
 802e7ce:	4770      	bx	lr

0802e7d0 <LL_RCC_MSI_IsReady>:
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRDY) == (RCC_CR_MSIRDY)) ? 1UL : 0UL);
 802e7d0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802e7d4:	6818      	ldr	r0, [r3, #0]
}
 802e7d6:	f3c0 0040 	ubfx	r0, r0, #1, #1
 802e7da:	4770      	bx	lr

0802e7dc <LL_RCC_MSI_SetCalibTrimming>:
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_MSITRIM, Value << RCC_ICSCR_MSITRIM_Pos);
 802e7dc:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 802e7e0:	6853      	ldr	r3, [r2, #4]
 802e7e2:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 802e7e6:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 802e7ea:	6053      	str	r3, [r2, #4]
}
 802e7ec:	4770      	bx	lr

0802e7ee <LL_RCC_PLL_IsReady>:
  * @rmtoll CR           PLLRDY        LL_RCC_PLL_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_IsReady(void)
{
  return ((READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY)) ? 1UL : 0UL);
 802e7ee:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802e7f2:	6818      	ldr	r0, [r3, #0]
}
 802e7f4:	f3c0 6040 	ubfx	r0, r0, #25, #1
 802e7f8:	4770      	bx	lr
	...

0802e7fc <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  MSI_Range  MSI range value from @ref RCC_MSIRANGE_0 to @ref RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t MSI_Range)
{
 802e7fc:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  return (uint32_t)(READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPRE) << 4);
 802e7fe:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
  uint32_t flash_clksrcfreq;
  uint32_t msifreq;

  /* MSI frequency range in Hz */
  msifreq           = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSIRANGESEL_RUN, MSI_Range);
  flash_clksrcfreq  = __LL_RCC_CALC_HCLK3_FREQ(msifreq, LL_RCC_GetAHB3Prescaler());
 802e802:	4a2c      	ldr	r2, [pc, #176]	; (802e8b4 <RCC_SetFlashLatencyFromMSIRange+0xb8>)
 802e804:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
  msifreq           = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSIRANGESEL_RUN, MSI_Range);
 802e808:	f3c0 1003 	ubfx	r0, r0, #4, #4
  flash_clksrcfreq  = __LL_RCC_CALC_HCLK3_FREQ(msifreq, LL_RCC_GetAHB3Prescaler());
 802e80c:	f003 030f 	and.w	r3, r3, #15
 802e810:	f852 4020 	ldr.w	r4, [r2, r0, lsl #2]
 802e814:	4a28      	ldr	r2, [pc, #160]	; (802e8b8 <RCC_SetFlashLatencyFromMSIRange+0xbc>)
 802e816:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 802e81a:	fbb4 f4f3 	udiv	r4, r4, r3

  return RCC_SetFlashLatency((flash_clksrcfreq / MEGA_HZ), HAL_PWREx_GetVoltageRange());
 802e81e:	f7ff ff7d 	bl	802e71c <HAL_PWREx_GetVoltageRange>

  /* Flash Clock source (HCLK3) range in MHz for VCORE range2 */
  const uint16_t FLASH_CLK_SRC_RANGE_VOS2[] = {6, 12, 16};

  /* Flash Latency range */
  const uint32_t FLASH_LATENCY_RANGE[] = {FLASH_LATENCY_0, FLASH_LATENCY_1, FLASH_LATENCY_2};
 802e822:	4b26      	ldr	r3, [pc, #152]	; (802e8bc <RCC_SetFlashLatencyFromMSIRange+0xc0>)
  return RCC_SetFlashLatency((flash_clksrcfreq / MEGA_HZ), HAL_PWREx_GetVoltageRange());
 802e824:	4605      	mov	r5, r0
  const uint32_t FLASH_LATENCY_RANGE[] = {FLASH_LATENCY_0, FLASH_LATENCY_1, FLASH_LATENCY_2};
 802e826:	e893 0007 	ldmia.w	r3, {r0, r1, r2}

  uint32_t latency   = FLASH_LATENCY_0;  /* default value 0WS */
  uint32_t tickstart;

  if (VCORE_Voltage == PWR_REGULATOR_VOLTAGE_SCALE1)
 802e82a:	f5b5 7f00 	cmp.w	r5, #512	; 0x200
  const uint32_t FLASH_LATENCY_RANGE[] = {FLASH_LATENCY_0, FLASH_LATENCY_1, FLASH_LATENCY_2};
 802e82e:	ab04      	add	r3, sp, #16
 802e830:	e903 0007 	stmdb	r3, {r0, r1, r2}
  if (VCORE_Voltage == PWR_REGULATOR_VOLTAGE_SCALE1)
 802e834:	d010      	beq.n	802e858 <RCC_SetFlashLatencyFromMSIRange+0x5c>
  }
  else  /* PWR_REGULATOR_VOLTAGE_SCALE2 */
  {
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
    {
      if (Flash_ClkSrcFreq <= FLASH_CLK_SRC_RANGE_VOS2[index])
 802e836:	4b22      	ldr	r3, [pc, #136]	; (802e8c0 <RCC_SetFlashLatencyFromMSIRange+0xc4>)
 802e838:	429c      	cmp	r4, r3
 802e83a:	d318      	bcc.n	802e86e <RCC_SetFlashLatencyFromMSIRange+0x72>
 802e83c:	f503 03b7 	add.w	r3, r3, #5996544	; 0x5b8000
 802e840:	f603 537f 	addw	r3, r3, #3455	; 0xd7f
 802e844:	429c      	cmp	r4, r3
 802e846:	d929      	bls.n	802e89c <RCC_SetFlashLatencyFromMSIRange+0xa0>
 802e848:	f503 1374 	add.w	r3, r3, #3997696	; 0x3d0000
 802e84c:	f503 6310 	add.w	r3, r3, #2304	; 0x900
      if (Flash_ClkSrcFreq <= FLASH_CLK_SRC_RANGE_VOS1[index])
 802e850:	429c      	cmp	r4, r3
 802e852:	d825      	bhi.n	802e8a0 <RCC_SetFlashLatencyFromMSIRange+0xa4>
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
 802e854:	2302      	movs	r3, #2
 802e856:	e00b      	b.n	802e870 <RCC_SetFlashLatencyFromMSIRange+0x74>
      if (Flash_ClkSrcFreq <= FLASH_CLK_SRC_RANGE_VOS1[index])
 802e858:	4b1a      	ldr	r3, [pc, #104]	; (802e8c4 <RCC_SetFlashLatencyFromMSIRange+0xc8>)
 802e85a:	429c      	cmp	r4, r3
 802e85c:	d907      	bls.n	802e86e <RCC_SetFlashLatencyFromMSIRange+0x72>
 802e85e:	4b1a      	ldr	r3, [pc, #104]	; (802e8c8 <RCC_SetFlashLatencyFromMSIRange+0xcc>)
 802e860:	429c      	cmp	r4, r3
 802e862:	d91b      	bls.n	802e89c <RCC_SetFlashLatencyFromMSIRange+0xa0>
 802e864:	f503 0337 	add.w	r3, r3, #11993088	; 0xb70000
 802e868:	f503 53d8 	add.w	r3, r3, #6912	; 0x1b00
 802e86c:	e7f0      	b.n	802e850 <RCC_SetFlashLatencyFromMSIRange+0x54>
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
 802e86e:	2300      	movs	r3, #0
      {
        latency = FLASH_LATENCY_RANGE[index];
 802e870:	aa04      	add	r2, sp, #16
 802e872:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 802e876:	f853 4c0c 	ldr.w	r4, [r3, #-12]
        break;
      }
    }
  }

  __HAL_FLASH_SET_LATENCY(latency);
 802e87a:	4d14      	ldr	r5, [pc, #80]	; (802e8cc <RCC_SetFlashLatencyFromMSIRange+0xd0>)
 802e87c:	682b      	ldr	r3, [r5, #0]
 802e87e:	f023 0307 	bic.w	r3, r3, #7
 802e882:	4323      	orrs	r3, r4
 802e884:	602b      	str	r3, [r5, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 802e886:	f7fd fedd 	bl	802c644 <HAL_GetTick>
 802e88a:	4606      	mov	r6, r0

  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  while (__HAL_FLASH_GET_LATENCY() != latency)
 802e88c:	682b      	ldr	r3, [r5, #0]
 802e88e:	f003 0307 	and.w	r3, r3, #7
 802e892:	429c      	cmp	r4, r3
 802e894:	d106      	bne.n	802e8a4 <RCC_SetFlashLatencyFromMSIRange+0xa8>
    if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
    {
      return HAL_TIMEOUT;
    }
  }
  return HAL_OK;
 802e896:	2000      	movs	r0, #0
}
 802e898:	b004      	add	sp, #16
 802e89a:	bd70      	pop	{r4, r5, r6, pc}
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
 802e89c:	2301      	movs	r3, #1
 802e89e:	e7e7      	b.n	802e870 <RCC_SetFlashLatencyFromMSIRange+0x74>
  uint32_t latency   = FLASH_LATENCY_0;  /* default value 0WS */
 802e8a0:	2400      	movs	r4, #0
 802e8a2:	e7ea      	b.n	802e87a <RCC_SetFlashLatencyFromMSIRange+0x7e>
    if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 802e8a4:	f7fd fece 	bl	802c644 <HAL_GetTick>
 802e8a8:	1b80      	subs	r0, r0, r6
 802e8aa:	2802      	cmp	r0, #2
 802e8ac:	d9ee      	bls.n	802e88c <RCC_SetFlashLatencyFromMSIRange+0x90>
      return HAL_TIMEOUT;
 802e8ae:	2003      	movs	r0, #3
 802e8b0:	e7f2      	b.n	802e898 <RCC_SetFlashLatencyFromMSIRange+0x9c>
 802e8b2:	bf00      	nop
 802e8b4:	0803b954 	.word	0x0803b954
 802e8b8:	0803b994 	.word	0x0803b994
 802e8bc:	0803b9f4 	.word	0x0803b9f4
 802e8c0:	006acfc0 	.word	0x006acfc0
 802e8c4:	0121eabf 	.word	0x0121eabf
 802e8c8:	0234933f 	.word	0x0234933f
 802e8cc:	58004000 	.word	0x58004000

0802e8d0 <HAL_RCC_GetSysClockFreq>:
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 802e8d0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
{
 802e8d4:	b510      	push	{r4, lr}
 802e8d6:	689a      	ldr	r2, [r3, #8]
  *         @arg @ref LL_RCC_PLLSOURCE_HSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetMainSource(void)
{
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 802e8d8:	68d9      	ldr	r1, [r3, #12]
  if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 802e8da:	f012 020c 	ands.w	r2, r2, #12
 802e8de:	d005      	beq.n	802e8ec <HAL_RCC_GetSysClockFreq+0x1c>
 802e8e0:	2a0c      	cmp	r2, #12
 802e8e2:	d14a      	bne.n	802e97a <HAL_RCC_GetSysClockFreq+0xaa>
 802e8e4:	f001 0303 	and.w	r3, r1, #3
      ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pllsource == RCC_PLLSOURCE_MSI)))
 802e8e8:	2b01      	cmp	r3, #1
 802e8ea:	d150      	bne.n	802e98e <HAL_RCC_GetSysClockFreq+0xbe>
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == (RCC_CR_MSIRGSEL)) ? 1UL : 0UL);
 802e8ec:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 802e8f0:	482b      	ldr	r0, [pc, #172]	; (802e9a0 <HAL_RCC_GetSysClockFreq+0xd0>)
 802e8f2:	680b      	ldr	r3, [r1, #0]
 802e8f4:	f013 0308 	ands.w	r3, r3, #8
 802e8f8:	d006      	beq.n	802e908 <HAL_RCC_GetSysClockFreq+0x38>
 802e8fa:	680b      	ldr	r3, [r1, #0]
 802e8fc:	f013 0308 	ands.w	r3, r3, #8
 802e900:	d137      	bne.n	802e972 <HAL_RCC_GetSysClockFreq+0xa2>
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 802e902:	f8d1 1094 	ldr.w	r1, [r1, #148]	; 0x94
 802e906:	e007      	b.n	802e918 <HAL_RCC_GetSysClockFreq+0x48>
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == (RCC_CR_MSIRGSEL)) ? 1UL : 0UL);
 802e908:	680c      	ldr	r4, [r1, #0]
 802e90a:	0724      	lsls	r4, r4, #28
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 802e90c:	bf56      	itet	pl
 802e90e:	f8d1 3094 	ldrpl.w	r3, [r1, #148]	; 0x94
  return (uint32_t)(READ_BIT(RCC->CR, RCC_CR_MSIRANGE));
 802e912:	6809      	ldrmi	r1, [r1, #0]
    msifreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
 802e914:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 802e918:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
      sysclockfreq = msifreq;
 802e91c:	2a00      	cmp	r2, #0
 802e91e:	bf0c      	ite	eq
 802e920:	4618      	moveq	r0, r3
 802e922:	2000      	movne	r0, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 802e924:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 802e928:	688a      	ldr	r2, [r1, #8]
 802e92a:	f002 020c 	and.w	r2, r2, #12
  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 802e92e:	2a0c      	cmp	r2, #12
 802e930:	d11e      	bne.n	802e970 <HAL_RCC_GetSysClockFreq+0xa0>
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 802e932:	68ca      	ldr	r2, [r1, #12]
 802e934:	f002 0203 	and.w	r2, r2, #3
    switch (pllsource)
 802e938:	2a02      	cmp	r2, #2
 802e93a:	d02e      	beq.n	802e99a <HAL_RCC_GetSysClockFreq+0xca>
 802e93c:	2a03      	cmp	r2, #3
 802e93e:	d106      	bne.n	802e94e <HAL_RCC_GetSysClockFreq+0x7e>
  return ((READ_BIT(RCC->CR, RCC_CR_HSEPRE) == (RCC_CR_HSEPRE)) ? 1UL : 0UL);
 802e940:	680b      	ldr	r3, [r1, #0]
          pllinputfreq = HSE_VALUE / 2U;
 802e942:	4818      	ldr	r0, [pc, #96]	; (802e9a4 <HAL_RCC_GetSysClockFreq+0xd4>)
 802e944:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 802e948:	4b17      	ldr	r3, [pc, #92]	; (802e9a8 <HAL_RCC_GetSysClockFreq+0xd8>)
 802e94a:	bf18      	it	ne
 802e94c:	4603      	movne	r3, r0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 802e94e:	f04f 40b0 	mov.w	r0, #1476395008	; 0x58000000
 802e952:	68c1      	ldr	r1, [r0, #12]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM));
 802e954:	68c2      	ldr	r2, [r0, #12]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR));
 802e956:	68c0      	ldr	r0, [r0, #12]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 802e958:	f3c1 2106 	ubfx	r1, r1, #8, #7
    sysclockfreq = __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
 802e95c:	f3c2 1202 	ubfx	r2, r2, #4, #3
 802e960:	0f40      	lsrs	r0, r0, #29
 802e962:	434b      	muls	r3, r1
 802e964:	3201      	adds	r2, #1
 802e966:	3001      	adds	r0, #1
 802e968:	fbb3 f3f2 	udiv	r3, r3, r2
 802e96c:	fbb3 f0f0 	udiv	r0, r3, r0
}
 802e970:	bd10      	pop	{r4, pc}
  return (uint32_t)(READ_BIT(RCC->CR, RCC_CR_MSIRANGE));
 802e972:	680b      	ldr	r3, [r1, #0]
    msifreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
 802e974:	f3c3 1303 	ubfx	r3, r3, #4, #4
 802e978:	e7ce      	b.n	802e918 <HAL_RCC_GetSysClockFreq+0x48>
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI)
 802e97a:	2a04      	cmp	r2, #4
 802e97c:	d00a      	beq.n	802e994 <HAL_RCC_GetSysClockFreq+0xc4>
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 802e97e:	2a08      	cmp	r2, #8
 802e980:	d105      	bne.n	802e98e <HAL_RCC_GetSysClockFreq+0xbe>
  return ((READ_BIT(RCC->CR, RCC_CR_HSEPRE) == (RCC_CR_HSEPRE)) ? 1UL : 0UL);
 802e982:	681b      	ldr	r3, [r3, #0]
 802e984:	f413 1380 	ands.w	r3, r3, #1048576	; 0x100000
 802e988:	d104      	bne.n	802e994 <HAL_RCC_GetSysClockFreq+0xc4>
      sysclockfreq = HSE_VALUE;
 802e98a:	4807      	ldr	r0, [pc, #28]	; (802e9a8 <HAL_RCC_GetSysClockFreq+0xd8>)
 802e98c:	e7ca      	b.n	802e924 <HAL_RCC_GetSysClockFreq+0x54>
  uint32_t msifreq = 0U;
 802e98e:	2300      	movs	r3, #0
  uint32_t sysclockfreq = 0U;
 802e990:	4618      	mov	r0, r3
 802e992:	e7c7      	b.n	802e924 <HAL_RCC_GetSysClockFreq+0x54>
      sysclockfreq = HSE_VALUE / 2U;
 802e994:	4803      	ldr	r0, [pc, #12]	; (802e9a4 <HAL_RCC_GetSysClockFreq+0xd4>)
  uint32_t msifreq = 0U;
 802e996:	2300      	movs	r3, #0
 802e998:	e7c4      	b.n	802e924 <HAL_RCC_GetSysClockFreq+0x54>
        pllinputfreq = HSI_VALUE;
 802e99a:	4b02      	ldr	r3, [pc, #8]	; (802e9a4 <HAL_RCC_GetSysClockFreq+0xd4>)
 802e99c:	e7d7      	b.n	802e94e <HAL_RCC_GetSysClockFreq+0x7e>
 802e99e:	bf00      	nop
 802e9a0:	0803b954 	.word	0x0803b954
 802e9a4:	00f42400 	.word	0x00f42400
 802e9a8:	01e84800 	.word	0x01e84800

0802e9ac <HAL_RCC_GetHCLKFreq>:
{
 802e9ac:	b508      	push	{r3, lr}
  return ((uint32_t)(__LL_RCC_CALC_HCLK1_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler())));
 802e9ae:	f7ff ff8f 	bl	802e8d0 <HAL_RCC_GetSysClockFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
 802e9b2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802e9b6:	4a04      	ldr	r2, [pc, #16]	; (802e9c8 <HAL_RCC_GetHCLKFreq+0x1c>)
 802e9b8:	689b      	ldr	r3, [r3, #8]
 802e9ba:	f3c3 1303 	ubfx	r3, r3, #4, #4
 802e9be:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
}
 802e9c2:	fbb0 f0f3 	udiv	r0, r0, r3
 802e9c6:	bd08      	pop	{r3, pc}
 802e9c8:	0803b994 	.word	0x0803b994

0802e9cc <HAL_RCC_OscConfig>:
{
 802e9cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (RCC_OscInitStruct == NULL)
 802e9d0:	4604      	mov	r4, r0
 802e9d2:	2800      	cmp	r0, #0
 802e9d4:	d055      	beq.n	802ea82 <HAL_RCC_OscConfig+0xb6>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 802e9d6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802e9da:	689e      	ldr	r6, [r3, #8]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 802e9dc:	68dd      	ldr	r5, [r3, #12]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 802e9de:	6803      	ldr	r3, [r0, #0]
 802e9e0:	0699      	lsls	r1, r3, #26
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 802e9e2:	f006 060c 	and.w	r6, r6, #12
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 802e9e6:	f005 0503 	and.w	r5, r5, #3
 802e9ea:	d56b      	bpl.n	802eac4 <HAL_RCC_OscConfig+0xf8>
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 802e9ec:	b11e      	cbz	r6, 802e9f6 <HAL_RCC_OscConfig+0x2a>
 802e9ee:	2e0c      	cmp	r6, #12
 802e9f0:	d149      	bne.n	802ea86 <HAL_RCC_OscConfig+0xba>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_MSI)))
 802e9f2:	2d01      	cmp	r5, #1
 802e9f4:	d147      	bne.n	802ea86 <HAL_RCC_OscConfig+0xba>
      if ((LL_RCC_MSI_IsReady() != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 802e9f6:	f7ff feeb 	bl	802e7d0 <LL_RCC_MSI_IsReady>
 802e9fa:	b110      	cbz	r0, 802ea02 <HAL_RCC_OscConfig+0x36>
 802e9fc:	6a23      	ldr	r3, [r4, #32]
 802e9fe:	2b00      	cmp	r3, #0
 802ea00:	d03f      	beq.n	802ea82 <HAL_RCC_OscConfig+0xb6>
        if (RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 802ea02:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802ea06:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 802ea08:	681a      	ldr	r2, [r3, #0]
 802ea0a:	0712      	lsls	r2, r2, #28
 802ea0c:	bf56      	itet	pl
 802ea0e:	f8d3 3094 	ldrpl.w	r3, [r3, #148]	; 0x94
 802ea12:	681b      	ldrmi	r3, [r3, #0]
 802ea14:	091b      	lsrpl	r3, r3, #4
 802ea16:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 802ea1a:	4298      	cmp	r0, r3
 802ea1c:	d91e      	bls.n	802ea5c <HAL_RCC_OscConfig+0x90>
          if (RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 802ea1e:	f7ff feed 	bl	802e7fc <RCC_SetFlashLatencyFromMSIRange>
 802ea22:	2800      	cmp	r0, #0
 802ea24:	d12d      	bne.n	802ea82 <HAL_RCC_OscConfig+0xb6>
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 802ea26:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 802ea2a:	6813      	ldr	r3, [r2, #0]
 802ea2c:	f043 0308 	orr.w	r3, r3, #8
 802ea30:	6013      	str	r3, [r2, #0]
 802ea32:	6813      	ldr	r3, [r2, #0]
 802ea34:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 802ea36:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 802ea3a:	430b      	orrs	r3, r1
 802ea3c:	6013      	str	r3, [r2, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 802ea3e:	6a60      	ldr	r0, [r4, #36]	; 0x24
 802ea40:	f7ff fecc 	bl	802e7dc <LL_RCC_MSI_SetCalibTrimming>
        SystemCoreClock = HAL_RCC_GetHCLKFreq();
 802ea44:	f7ff ffb2 	bl	802e9ac <HAL_RCC_GetHCLKFreq>
 802ea48:	4bac      	ldr	r3, [pc, #688]	; (802ecfc <HAL_RCC_OscConfig+0x330>)
 802ea4a:	6018      	str	r0, [r3, #0]
        status = HAL_InitTick(uwTickPrio);
 802ea4c:	4bac      	ldr	r3, [pc, #688]	; (802ed00 <HAL_RCC_OscConfig+0x334>)
 802ea4e:	6818      	ldr	r0, [r3, #0]
 802ea50:	f7fd fdf6 	bl	802c640 <HAL_InitTick>
        if (status != HAL_OK)
 802ea54:	2800      	cmp	r0, #0
 802ea56:	d035      	beq.n	802eac4 <HAL_RCC_OscConfig+0xf8>
}
 802ea58:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 802ea5c:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 802ea60:	6813      	ldr	r3, [r2, #0]
 802ea62:	f043 0308 	orr.w	r3, r3, #8
 802ea66:	6013      	str	r3, [r2, #0]
 802ea68:	6813      	ldr	r3, [r2, #0]
 802ea6a:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 802ea6e:	4303      	orrs	r3, r0
 802ea70:	6013      	str	r3, [r2, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 802ea72:	6a60      	ldr	r0, [r4, #36]	; 0x24
 802ea74:	f7ff feb2 	bl	802e7dc <LL_RCC_MSI_SetCalibTrimming>
          if (RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 802ea78:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 802ea7a:	f7ff febf 	bl	802e7fc <RCC_SetFlashLatencyFromMSIRange>
 802ea7e:	2800      	cmp	r0, #0
 802ea80:	d0e0      	beq.n	802ea44 <HAL_RCC_OscConfig+0x78>
          return HAL_ERROR;
 802ea82:	2001      	movs	r0, #1
 802ea84:	e7e8      	b.n	802ea58 <HAL_RCC_OscConfig+0x8c>
      if (RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 802ea86:	6a22      	ldr	r2, [r4, #32]
 802ea88:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802ea8c:	2a00      	cmp	r2, #0
 802ea8e:	d054      	beq.n	802eb3a <HAL_RCC_OscConfig+0x16e>
  SET_BIT(RCC->CR, RCC_CR_MSION);
 802ea90:	681a      	ldr	r2, [r3, #0]
 802ea92:	f042 0201 	orr.w	r2, r2, #1
 802ea96:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 802ea98:	f7fd fdd4 	bl	802c644 <HAL_GetTick>
 802ea9c:	4607      	mov	r7, r0
        while (LL_RCC_MSI_IsReady() == 0U)
 802ea9e:	f7ff fe97 	bl	802e7d0 <LL_RCC_MSI_IsReady>
 802eaa2:	2800      	cmp	r0, #0
 802eaa4:	d042      	beq.n	802eb2c <HAL_RCC_OscConfig+0x160>
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 802eaa6:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 802eaaa:	6813      	ldr	r3, [r2, #0]
 802eaac:	f043 0308 	orr.w	r3, r3, #8
 802eab0:	6013      	str	r3, [r2, #0]
 802eab2:	6813      	ldr	r3, [r2, #0]
 802eab4:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 802eab6:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 802eaba:	430b      	orrs	r3, r1
 802eabc:	6013      	str	r3, [r2, #0]
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 802eabe:	6a60      	ldr	r0, [r4, #36]	; 0x24
 802eac0:	f7ff fe8c 	bl	802e7dc <LL_RCC_MSI_SetCalibTrimming>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 802eac4:	6823      	ldr	r3, [r4, #0]
 802eac6:	07db      	lsls	r3, r3, #31
 802eac8:	d448      	bmi.n	802eb5c <HAL_RCC_OscConfig+0x190>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 802eaca:	6823      	ldr	r3, [r4, #0]
 802eacc:	079f      	lsls	r7, r3, #30
 802eace:	f100 8090 	bmi.w	802ebf2 <HAL_RCC_OscConfig+0x226>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 802ead2:	6823      	ldr	r3, [r4, #0]
 802ead4:	071d      	lsls	r5, r3, #28
 802ead6:	f140 80fc 	bpl.w	802ecd2 <HAL_RCC_OscConfig+0x306>
    if (RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 802eada:	69a3      	ldr	r3, [r4, #24]
 802eadc:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
 802eae0:	2b00      	cmp	r3, #0
 802eae2:	f000 80e3 	beq.w	802ecac <HAL_RCC_OscConfig+0x2e0>
      uint32_t csr_temp = RCC->CSR;
 802eae6:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
      if (RCC_OscInitStruct->LSIDiv != (csr_temp & RCC_CSR_LSIPRE))
 802eaea:	69e1      	ldr	r1, [r4, #28]
 802eaec:	f003 0210 	and.w	r2, r3, #16
 802eaf0:	4291      	cmp	r1, r2
 802eaf2:	f000 80c6 	beq.w	802ec82 <HAL_RCC_OscConfig+0x2b6>
        if (((csr_temp & RCC_CSR_LSIRDY) == RCC_CSR_LSIRDY) && \
 802eaf6:	f003 0203 	and.w	r2, r3, #3
 802eafa:	2a02      	cmp	r2, #2
 802eafc:	d0c1      	beq.n	802ea82 <HAL_RCC_OscConfig+0xb6>
        if ((csr_temp & RCC_CSR_LSION) == RCC_CSR_LSION)
 802eafe:	07d8      	lsls	r0, r3, #31
 802eb00:	f140 80b5 	bpl.w	802ec6e <HAL_RCC_OscConfig+0x2a2>
  CLEAR_BIT(RCC->CSR, RCC_CSR_LSION);
 802eb04:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 802eb08:	f023 0301 	bic.w	r3, r3, #1
 802eb0c:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94
          tickstart = HAL_GetTick();
 802eb10:	f7fd fd98 	bl	802c644 <HAL_GetTick>
 802eb14:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == (RCC_CSR_LSIRDY)) ? 1UL : 0UL);
 802eb16:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 802eb1a:	0799      	lsls	r1, r3, #30
 802eb1c:	f140 80a7 	bpl.w	802ec6e <HAL_RCC_OscConfig+0x2a2>
            if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 802eb20:	f7fd fd90 	bl	802c644 <HAL_GetTick>
 802eb24:	1bc3      	subs	r3, r0, r7
 802eb26:	2b11      	cmp	r3, #17
 802eb28:	d9f5      	bls.n	802eb16 <HAL_RCC_OscConfig+0x14a>
 802eb2a:	e004      	b.n	802eb36 <HAL_RCC_OscConfig+0x16a>
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 802eb2c:	f7fd fd8a 	bl	802c644 <HAL_GetTick>
 802eb30:	1bc0      	subs	r0, r0, r7
 802eb32:	2802      	cmp	r0, #2
 802eb34:	d9b3      	bls.n	802ea9e <HAL_RCC_OscConfig+0xd2>
            return HAL_TIMEOUT;
 802eb36:	2003      	movs	r0, #3
 802eb38:	e78e      	b.n	802ea58 <HAL_RCC_OscConfig+0x8c>
  CLEAR_BIT(RCC->CR, RCC_CR_MSION);
 802eb3a:	681a      	ldr	r2, [r3, #0]
 802eb3c:	f022 0201 	bic.w	r2, r2, #1
 802eb40:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 802eb42:	f7fd fd7f 	bl	802c644 <HAL_GetTick>
 802eb46:	4607      	mov	r7, r0
        while (LL_RCC_MSI_IsReady() != 0U)
 802eb48:	f7ff fe42 	bl	802e7d0 <LL_RCC_MSI_IsReady>
 802eb4c:	2800      	cmp	r0, #0
 802eb4e:	d0b9      	beq.n	802eac4 <HAL_RCC_OscConfig+0xf8>
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 802eb50:	f7fd fd78 	bl	802c644 <HAL_GetTick>
 802eb54:	1bc0      	subs	r0, r0, r7
 802eb56:	2802      	cmp	r0, #2
 802eb58:	d9f6      	bls.n	802eb48 <HAL_RCC_OscConfig+0x17c>
 802eb5a:	e7ec      	b.n	802eb36 <HAL_RCC_OscConfig+0x16a>
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE) ||
 802eb5c:	2e08      	cmp	r6, #8
 802eb5e:	d003      	beq.n	802eb68 <HAL_RCC_OscConfig+0x19c>
 802eb60:	2e0c      	cmp	r6, #12
 802eb62:	d109      	bne.n	802eb78 <HAL_RCC_OscConfig+0x1ac>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSE)))
 802eb64:	2d03      	cmp	r5, #3
 802eb66:	d107      	bne.n	802eb78 <HAL_RCC_OscConfig+0x1ac>
      if ((LL_RCC_HSE_IsReady() != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 802eb68:	f7ff fe26 	bl	802e7b8 <LL_RCC_HSE_IsReady>
 802eb6c:	2800      	cmp	r0, #0
 802eb6e:	d0ac      	beq.n	802eaca <HAL_RCC_OscConfig+0xfe>
 802eb70:	6863      	ldr	r3, [r4, #4]
 802eb72:	2b00      	cmp	r3, #0
 802eb74:	d1a9      	bne.n	802eaca <HAL_RCC_OscConfig+0xfe>
 802eb76:	e784      	b.n	802ea82 <HAL_RCC_OscConfig+0xb6>
      MODIFY_REG(RCC->CR, RCC_CR_HSEPRE, RCC_OscInitStruct->HSEDiv);
 802eb78:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802eb7c:	68a1      	ldr	r1, [r4, #8]
 802eb7e:	681a      	ldr	r2, [r3, #0]
 802eb80:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 802eb84:	430a      	orrs	r2, r1
 802eb86:	601a      	str	r2, [r3, #0]
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 802eb88:	6862      	ldr	r2, [r4, #4]
 802eb8a:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 802eb8e:	d110      	bne.n	802ebb2 <HAL_RCC_OscConfig+0x1e6>
  SET_BIT(RCC->CR, RCC_CR_HSEON);
 802eb90:	681a      	ldr	r2, [r3, #0]
 802eb92:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 802eb96:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 802eb98:	f7fd fd54 	bl	802c644 <HAL_GetTick>
 802eb9c:	4607      	mov	r7, r0
        while (LL_RCC_HSE_IsReady() == 0U)
 802eb9e:	f7ff fe0b 	bl	802e7b8 <LL_RCC_HSE_IsReady>
 802eba2:	2800      	cmp	r0, #0
 802eba4:	d191      	bne.n	802eaca <HAL_RCC_OscConfig+0xfe>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 802eba6:	f7fd fd4d 	bl	802c644 <HAL_GetTick>
 802ebaa:	1bc0      	subs	r0, r0, r7
 802ebac:	2864      	cmp	r0, #100	; 0x64
 802ebae:	d9f6      	bls.n	802eb9e <HAL_RCC_OscConfig+0x1d2>
 802ebb0:	e7c1      	b.n	802eb36 <HAL_RCC_OscConfig+0x16a>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 802ebb2:	f5b2 1f04 	cmp.w	r2, #2162688	; 0x210000
 802ebb6:	d104      	bne.n	802ebc2 <HAL_RCC_OscConfig+0x1f6>
  SET_BIT(RCC->CR, RCC_CR_HSEBYPPWR);
 802ebb8:	681a      	ldr	r2, [r3, #0]
 802ebba:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 802ebbe:	601a      	str	r2, [r3, #0]
 802ebc0:	e7e6      	b.n	802eb90 <HAL_RCC_OscConfig+0x1c4>
  CLEAR_BIT(RCC->CR, RCC_CR_HSEON);
 802ebc2:	6819      	ldr	r1, [r3, #0]
 802ebc4:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 802ebc8:	6019      	str	r1, [r3, #0]
  CLEAR_BIT(RCC->CR, RCC_CR_HSEBYPPWR);
 802ebca:	6819      	ldr	r1, [r3, #0]
 802ebcc:	f421 1100 	bic.w	r1, r1, #2097152	; 0x200000
 802ebd0:	6019      	str	r1, [r3, #0]
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 802ebd2:	2a00      	cmp	r2, #0
 802ebd4:	d1e0      	bne.n	802eb98 <HAL_RCC_OscConfig+0x1cc>
        tickstart = HAL_GetTick();
 802ebd6:	f7fd fd35 	bl	802c644 <HAL_GetTick>
 802ebda:	4607      	mov	r7, r0
        while (LL_RCC_HSE_IsReady() != 0U)
 802ebdc:	f7ff fdec 	bl	802e7b8 <LL_RCC_HSE_IsReady>
 802ebe0:	2800      	cmp	r0, #0
 802ebe2:	f43f af72 	beq.w	802eaca <HAL_RCC_OscConfig+0xfe>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 802ebe6:	f7fd fd2d 	bl	802c644 <HAL_GetTick>
 802ebea:	1bc0      	subs	r0, r0, r7
 802ebec:	2864      	cmp	r0, #100	; 0x64
 802ebee:	d9f5      	bls.n	802ebdc <HAL_RCC_OscConfig+0x210>
 802ebf0:	e7a1      	b.n	802eb36 <HAL_RCC_OscConfig+0x16a>
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI) ||
 802ebf2:	2e04      	cmp	r6, #4
 802ebf4:	d003      	beq.n	802ebfe <HAL_RCC_OscConfig+0x232>
 802ebf6:	2e0c      	cmp	r6, #12
 802ebf8:	d112      	bne.n	802ec20 <HAL_RCC_OscConfig+0x254>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSI)))
 802ebfa:	2d02      	cmp	r5, #2
 802ebfc:	d110      	bne.n	802ec20 <HAL_RCC_OscConfig+0x254>
      if ((LL_RCC_HSI_IsReady() != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 802ebfe:	f7ff fde1 	bl	802e7c4 <LL_RCC_HSI_IsReady>
 802ec02:	b118      	cbz	r0, 802ec0c <HAL_RCC_OscConfig+0x240>
 802ec04:	6923      	ldr	r3, [r4, #16]
 802ec06:	2b00      	cmp	r3, #0
 802ec08:	f43f af3b 	beq.w	802ea82 <HAL_RCC_OscConfig+0xb6>
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_HSITRIM, Value << RCC_ICSCR_HSITRIM_Pos);
 802ec0c:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 802ec10:	6961      	ldr	r1, [r4, #20]
 802ec12:	6853      	ldr	r3, [r2, #4]
 802ec14:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 802ec18:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 802ec1c:	6053      	str	r3, [r2, #4]
}
 802ec1e:	e758      	b.n	802ead2 <HAL_RCC_OscConfig+0x106>
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 802ec20:	6922      	ldr	r2, [r4, #16]
 802ec22:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802ec26:	b182      	cbz	r2, 802ec4a <HAL_RCC_OscConfig+0x27e>
  SET_BIT(RCC->CR, RCC_CR_HSION);
 802ec28:	681a      	ldr	r2, [r3, #0]
 802ec2a:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 802ec2e:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 802ec30:	f7fd fd08 	bl	802c644 <HAL_GetTick>
 802ec34:	4605      	mov	r5, r0
        while (LL_RCC_HSI_IsReady() == 0U)
 802ec36:	f7ff fdc5 	bl	802e7c4 <LL_RCC_HSI_IsReady>
 802ec3a:	2800      	cmp	r0, #0
 802ec3c:	d1e6      	bne.n	802ec0c <HAL_RCC_OscConfig+0x240>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 802ec3e:	f7fd fd01 	bl	802c644 <HAL_GetTick>
 802ec42:	1b40      	subs	r0, r0, r5
 802ec44:	2802      	cmp	r0, #2
 802ec46:	d9f6      	bls.n	802ec36 <HAL_RCC_OscConfig+0x26a>
 802ec48:	e775      	b.n	802eb36 <HAL_RCC_OscConfig+0x16a>
  CLEAR_BIT(RCC->CR, RCC_CR_HSION);
 802ec4a:	681a      	ldr	r2, [r3, #0]
 802ec4c:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 802ec50:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 802ec52:	f7fd fcf7 	bl	802c644 <HAL_GetTick>
 802ec56:	4605      	mov	r5, r0
        while (LL_RCC_HSI_IsReady() != 0U)
 802ec58:	f7ff fdb4 	bl	802e7c4 <LL_RCC_HSI_IsReady>
 802ec5c:	2800      	cmp	r0, #0
 802ec5e:	f43f af38 	beq.w	802ead2 <HAL_RCC_OscConfig+0x106>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 802ec62:	f7fd fcef 	bl	802c644 <HAL_GetTick>
 802ec66:	1b40      	subs	r0, r0, r5
 802ec68:	2802      	cmp	r0, #2
 802ec6a:	d9f5      	bls.n	802ec58 <HAL_RCC_OscConfig+0x28c>
 802ec6c:	e763      	b.n	802eb36 <HAL_RCC_OscConfig+0x16a>
        MODIFY_REG(RCC->CSR, RCC_CSR_LSIPRE, RCC_OscInitStruct->LSIDiv);
 802ec6e:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 802ec72:	69e1      	ldr	r1, [r4, #28]
 802ec74:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
 802ec78:	f023 0310 	bic.w	r3, r3, #16
 802ec7c:	430b      	orrs	r3, r1
 802ec7e:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
  SET_BIT(RCC->CSR, RCC_CSR_LSION);
 802ec82:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
 802ec86:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 802ec8a:	f043 0301 	orr.w	r3, r3, #1
 802ec8e:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94
      tickstart = HAL_GetTick();
 802ec92:	f7fd fcd7 	bl	802c644 <HAL_GetTick>
 802ec96:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == (RCC_CSR_LSIRDY)) ? 1UL : 0UL);
 802ec98:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 802ec9c:	079a      	lsls	r2, r3, #30
 802ec9e:	d418      	bmi.n	802ecd2 <HAL_RCC_OscConfig+0x306>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 802eca0:	f7fd fcd0 	bl	802c644 <HAL_GetTick>
 802eca4:	1bc3      	subs	r3, r0, r7
 802eca6:	2b11      	cmp	r3, #17
 802eca8:	d9f6      	bls.n	802ec98 <HAL_RCC_OscConfig+0x2cc>
 802ecaa:	e744      	b.n	802eb36 <HAL_RCC_OscConfig+0x16a>
  CLEAR_BIT(RCC->CSR, RCC_CSR_LSION);
 802ecac:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 802ecb0:	f023 0301 	bic.w	r3, r3, #1
 802ecb4:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94
      tickstart = HAL_GetTick();
 802ecb8:	f7fd fcc4 	bl	802c644 <HAL_GetTick>
 802ecbc:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == (RCC_CSR_LSIRDY)) ? 1UL : 0UL);
 802ecbe:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 802ecc2:	079b      	lsls	r3, r3, #30
 802ecc4:	d505      	bpl.n	802ecd2 <HAL_RCC_OscConfig+0x306>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 802ecc6:	f7fd fcbd 	bl	802c644 <HAL_GetTick>
 802ecca:	1bc3      	subs	r3, r0, r7
 802eccc:	2b11      	cmp	r3, #17
 802ecce:	d9f6      	bls.n	802ecbe <HAL_RCC_OscConfig+0x2f2>
 802ecd0:	e731      	b.n	802eb36 <HAL_RCC_OscConfig+0x16a>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 802ecd2:	6823      	ldr	r3, [r4, #0]
 802ecd4:	0758      	lsls	r0, r3, #29
 802ecd6:	d553      	bpl.n	802ed80 <HAL_RCC_OscConfig+0x3b4>
  return ((READ_BIT(PWR->CR1, PWR_CR1_DBP) == (PWR_CR1_DBP)) ? 1UL : 0UL);
 802ecd8:	4d0a      	ldr	r5, [pc, #40]	; (802ed04 <HAL_RCC_OscConfig+0x338>)
 802ecda:	682b      	ldr	r3, [r5, #0]
 802ecdc:	05d9      	lsls	r1, r3, #23
 802ecde:	d413      	bmi.n	802ed08 <HAL_RCC_OscConfig+0x33c>
      HAL_PWR_EnableBkUpAccess();
 802ece0:	f7ff fcf4 	bl	802e6cc <HAL_PWR_EnableBkUpAccess>
      tickstart = HAL_GetTick();
 802ece4:	f7fd fcae 	bl	802c644 <HAL_GetTick>
 802ece8:	4607      	mov	r7, r0
 802ecea:	682b      	ldr	r3, [r5, #0]
 802ecec:	05da      	lsls	r2, r3, #23
 802ecee:	d40b      	bmi.n	802ed08 <HAL_RCC_OscConfig+0x33c>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 802ecf0:	f7fd fca8 	bl	802c644 <HAL_GetTick>
 802ecf4:	1bc3      	subs	r3, r0, r7
 802ecf6:	2b02      	cmp	r3, #2
 802ecf8:	d9f7      	bls.n	802ecea <HAL_RCC_OscConfig+0x31e>
 802ecfa:	e71c      	b.n	802eb36 <HAL_RCC_OscConfig+0x16a>
 802ecfc:	2000344c 	.word	0x2000344c
 802ed00:	20003454 	.word	0x20003454
 802ed04:	58000400 	.word	0x58000400
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 802ed08:	68e3      	ldr	r3, [r4, #12]
 802ed0a:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
 802ed0e:	2b00      	cmp	r3, #0
 802ed10:	d058      	beq.n	802edc4 <HAL_RCC_OscConfig+0x3f8>
          || (RCC_OscInitStruct->LSEState == RCC_LSE_BYPASS_RTC_ONLY))
 802ed12:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 802ed16:	2b05      	cmp	r3, #5
        SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
 802ed18:	bf02      	ittt	eq
 802ed1a:	f8d5 3090 	ldreq.w	r3, [r5, #144]	; 0x90
 802ed1e:	f043 0304 	orreq.w	r3, r3, #4
 802ed22:	f8c5 3090 	streq.w	r3, [r5, #144]	; 0x90
      SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 802ed26:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
      tickstart = HAL_GetTick();
 802ed2a:	f7fd fc8b 	bl	802c644 <HAL_GetTick>
      SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 802ed2e:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802ed32:	f043 0301 	orr.w	r3, r3, #1
      tickstart = HAL_GetTick();
 802ed36:	4607      	mov	r7, r0
      SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 802ed38:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802ed3c:	f241 3888 	movw	r8, #5000	; 0x1388
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? 1UL : 0UL);
 802ed40:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802ed44:	079b      	lsls	r3, r3, #30
 802ed46:	d405      	bmi.n	802ed54 <HAL_RCC_OscConfig+0x388>
 802ed48:	f7fd fc7c 	bl	802c644 <HAL_GetTick>
 802ed4c:	1bc3      	subs	r3, r0, r7
 802ed4e:	4543      	cmp	r3, r8
 802ed50:	d9f6      	bls.n	802ed40 <HAL_RCC_OscConfig+0x374>
 802ed52:	e6f0      	b.n	802eb36 <HAL_RCC_OscConfig+0x16a>
      if ((RCC_OscInitStruct->LSEState == RCC_LSE_ON)
 802ed54:	68e3      	ldr	r3, [r4, #12]
 802ed56:	f023 0304 	bic.w	r3, r3, #4
 802ed5a:	2b81      	cmp	r3, #129	; 0x81
 802ed5c:	d11b      	bne.n	802ed96 <HAL_RCC_OscConfig+0x3ca>
        tickstart = HAL_GetTick();
 802ed5e:	f7fd fc71 	bl	802c644 <HAL_GetTick>
        SET_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 802ed62:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802ed66:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 802ed6a:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        tickstart = HAL_GetTick();
 802ed6e:	4607      	mov	r7, r0
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) == 0U)
 802ed70:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802ed74:	f241 3888 	movw	r8, #5000	; 0x1388
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) == 0U)
 802ed78:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802ed7c:	0518      	lsls	r0, r3, #20
 802ed7e:	d504      	bpl.n	802ed8a <HAL_RCC_OscConfig+0x3be>
  if (RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 802ed80:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 802ed82:	2800      	cmp	r0, #0
 802ed84:	d14a      	bne.n	802ee1c <HAL_RCC_OscConfig+0x450>
  return HAL_OK;
 802ed86:	2000      	movs	r0, #0
 802ed88:	e666      	b.n	802ea58 <HAL_RCC_OscConfig+0x8c>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802ed8a:	f7fd fc5b 	bl	802c644 <HAL_GetTick>
 802ed8e:	1bc0      	subs	r0, r0, r7
 802ed90:	4540      	cmp	r0, r8
 802ed92:	d9f1      	bls.n	802ed78 <HAL_RCC_OscConfig+0x3ac>
 802ed94:	e6cf      	b.n	802eb36 <HAL_RCC_OscConfig+0x16a>
        tickstart = HAL_GetTick();
 802ed96:	f7fd fc55 	bl	802c644 <HAL_GetTick>
        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 802ed9a:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802ed9e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 802eda2:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        tickstart = HAL_GetTick();
 802eda6:	4607      	mov	r7, r0
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 802eda8:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802edac:	f241 3888 	movw	r8, #5000	; 0x1388
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 802edb0:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802edb4:	0519      	lsls	r1, r3, #20
 802edb6:	d5e3      	bpl.n	802ed80 <HAL_RCC_OscConfig+0x3b4>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802edb8:	f7fd fc44 	bl	802c644 <HAL_GetTick>
 802edbc:	1bc0      	subs	r0, r0, r7
 802edbe:	4540      	cmp	r0, r8
 802edc0:	d9f6      	bls.n	802edb0 <HAL_RCC_OscConfig+0x3e4>
 802edc2:	e6b8      	b.n	802eb36 <HAL_RCC_OscConfig+0x16a>
      tickstart = HAL_GetTick();
 802edc4:	f7fd fc3e 	bl	802c644 <HAL_GetTick>
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 802edc8:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802edcc:	f023 0380 	bic.w	r3, r3, #128	; 0x80
      tickstart = HAL_GetTick();
 802edd0:	4607      	mov	r7, r0
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 802edd2:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802edd6:	f241 3888 	movw	r8, #5000	; 0x1388
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 802edda:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802edde:	051a      	lsls	r2, r3, #20
 802ede0:	d416      	bmi.n	802ee10 <HAL_RCC_OscConfig+0x444>
      tickstart = HAL_GetTick();
 802ede2:	f7fd fc2f 	bl	802c644 <HAL_GetTick>
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 802ede6:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802edea:	f023 0301 	bic.w	r3, r3, #1
 802edee:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
      tickstart = HAL_GetTick();
 802edf2:	4607      	mov	r7, r0
 802edf4:	f04f 48b0 	mov.w	r8, #1476395008	; 0x58000000
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802edf8:	f241 3588 	movw	r5, #5000	; 0x1388
 802edfc:	f8d8 3090 	ldr.w	r3, [r8, #144]	; 0x90
 802ee00:	079b      	lsls	r3, r3, #30
 802ee02:	d5bd      	bpl.n	802ed80 <HAL_RCC_OscConfig+0x3b4>
 802ee04:	f7fd fc1e 	bl	802c644 <HAL_GetTick>
 802ee08:	1bc3      	subs	r3, r0, r7
 802ee0a:	42ab      	cmp	r3, r5
 802ee0c:	d9f6      	bls.n	802edfc <HAL_RCC_OscConfig+0x430>
 802ee0e:	e692      	b.n	802eb36 <HAL_RCC_OscConfig+0x16a>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802ee10:	f7fd fc18 	bl	802c644 <HAL_GetTick>
 802ee14:	1bc0      	subs	r0, r0, r7
 802ee16:	4540      	cmp	r0, r8
 802ee18:	d9df      	bls.n	802edda <HAL_RCC_OscConfig+0x40e>
 802ee1a:	e68c      	b.n	802eb36 <HAL_RCC_OscConfig+0x16a>
    if (sysclk_source != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 802ee1c:	2e0c      	cmp	r6, #12
 802ee1e:	d053      	beq.n	802eec8 <HAL_RCC_OscConfig+0x4fc>
      if (RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 802ee20:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802ee24:	2802      	cmp	r0, #2
  CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
 802ee26:	681a      	ldr	r2, [r3, #0]
 802ee28:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 802ee2c:	601a      	str	r2, [r3, #0]
 802ee2e:	d133      	bne.n	802ee98 <HAL_RCC_OscConfig+0x4cc>
        tickstart = HAL_GetTick();
 802ee30:	f7fd fc08 	bl	802c644 <HAL_GetTick>
 802ee34:	4605      	mov	r5, r0
        while (LL_RCC_PLL_IsReady() != 0U)
 802ee36:	f7ff fcda 	bl	802e7ee <LL_RCC_PLL_IsReady>
 802ee3a:	bb38      	cbnz	r0, 802ee8c <HAL_RCC_OscConfig+0x4c0>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 802ee3c:	e9d4 310c 	ldrd	r3, r1, [r4, #48]	; 0x30
 802ee40:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 802ee44:	430b      	orrs	r3, r1
 802ee46:	68d0      	ldr	r0, [r2, #12]
 802ee48:	492f      	ldr	r1, [pc, #188]	; (802ef08 <HAL_RCC_OscConfig+0x53c>)
 802ee4a:	4001      	ands	r1, r0
 802ee4c:	430b      	orrs	r3, r1
 802ee4e:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 802ee50:	430b      	orrs	r3, r1
 802ee52:	6c21      	ldr	r1, [r4, #64]	; 0x40
 802ee54:	430b      	orrs	r3, r1
 802ee56:	6c61      	ldr	r1, [r4, #68]	; 0x44
 802ee58:	430b      	orrs	r3, r1
 802ee5a:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 802ee5c:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 802ee60:	60d3      	str	r3, [r2, #12]
  SET_BIT(RCC->CR, RCC_CR_PLLON);
 802ee62:	6813      	ldr	r3, [r2, #0]
 802ee64:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 802ee68:	6013      	str	r3, [r2, #0]
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 802ee6a:	68d3      	ldr	r3, [r2, #12]
 802ee6c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 802ee70:	60d3      	str	r3, [r2, #12]
        tickstart = HAL_GetTick();
 802ee72:	f7fd fbe7 	bl	802c644 <HAL_GetTick>
 802ee76:	4604      	mov	r4, r0
        while (LL_RCC_PLL_IsReady() == 0U)
 802ee78:	f7ff fcb9 	bl	802e7ee <LL_RCC_PLL_IsReady>
 802ee7c:	2800      	cmp	r0, #0
 802ee7e:	d182      	bne.n	802ed86 <HAL_RCC_OscConfig+0x3ba>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 802ee80:	f7fd fbe0 	bl	802c644 <HAL_GetTick>
 802ee84:	1b00      	subs	r0, r0, r4
 802ee86:	280a      	cmp	r0, #10
 802ee88:	d9f6      	bls.n	802ee78 <HAL_RCC_OscConfig+0x4ac>
 802ee8a:	e654      	b.n	802eb36 <HAL_RCC_OscConfig+0x16a>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 802ee8c:	f7fd fbda 	bl	802c644 <HAL_GetTick>
 802ee90:	1b40      	subs	r0, r0, r5
 802ee92:	280a      	cmp	r0, #10
 802ee94:	d9cf      	bls.n	802ee36 <HAL_RCC_OscConfig+0x46a>
 802ee96:	e64e      	b.n	802eb36 <HAL_RCC_OscConfig+0x16a>
        MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PLLSOURCE_NONE);
 802ee98:	68da      	ldr	r2, [r3, #12]
 802ee9a:	f022 0203 	bic.w	r2, r2, #3
 802ee9e:	60da      	str	r2, [r3, #12]
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_RNGCLK | RCC_PLL_ADCCLK);
 802eea0:	68da      	ldr	r2, [r3, #12]
 802eea2:	f022 5288 	bic.w	r2, r2, #285212672	; 0x11000000
 802eea6:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 802eeaa:	60da      	str	r2, [r3, #12]
        tickstart = HAL_GetTick();
 802eeac:	f7fd fbca 	bl	802c644 <HAL_GetTick>
 802eeb0:	4604      	mov	r4, r0
        while (LL_RCC_PLL_IsReady() != 0U)
 802eeb2:	f7ff fc9c 	bl	802e7ee <LL_RCC_PLL_IsReady>
 802eeb6:	2800      	cmp	r0, #0
 802eeb8:	f43f af65 	beq.w	802ed86 <HAL_RCC_OscConfig+0x3ba>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 802eebc:	f7fd fbc2 	bl	802c644 <HAL_GetTick>
 802eec0:	1b00      	subs	r0, r0, r4
 802eec2:	280a      	cmp	r0, #10
 802eec4:	d9f5      	bls.n	802eeb2 <HAL_RCC_OscConfig+0x4e6>
 802eec6:	e636      	b.n	802eb36 <HAL_RCC_OscConfig+0x16a>
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 802eec8:	2801      	cmp	r0, #1
 802eeca:	f43f adc5 	beq.w	802ea58 <HAL_RCC_OscConfig+0x8c>
        pll_config = RCC->PLLCFGR;
 802eece:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
        if ((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource)
 802eed2:	6b22      	ldr	r2, [r4, #48]	; 0x30
        pll_config = RCC->PLLCFGR;
 802eed4:	68db      	ldr	r3, [r3, #12]
        if ((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource)
 802eed6:	f003 0103 	and.w	r1, r3, #3
 802eeda:	4291      	cmp	r1, r2
 802eedc:	f47f add1 	bne.w	802ea82 <HAL_RCC_OscConfig+0xb6>
            || (READ_BIT(pll_config, RCC_PLLCFGR_PLLM)   != RCC_OscInitStruct->PLL.PLLM)
 802eee0:	6b61      	ldr	r1, [r4, #52]	; 0x34
 802eee2:	f003 0270 	and.w	r2, r3, #112	; 0x70
 802eee6:	428a      	cmp	r2, r1
 802eee8:	f47f adcb 	bne.w	802ea82 <HAL_RCC_OscConfig+0xb6>
            || (READ_BIT(pll_config, RCC_PLLCFGR_PLLN)   != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos))
 802eeec:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 802eeee:	f403 42fe 	and.w	r2, r3, #32512	; 0x7f00
 802eef2:	ebb2 2f01 	cmp.w	r2, r1, lsl #8
 802eef6:	f47f adc4 	bne.w	802ea82 <HAL_RCC_OscConfig+0xb6>
            || (READ_BIT(pll_config, RCC_PLLCFGR_PLLR)   != RCC_OscInitStruct->PLL.PLLR))
 802eefa:	6c62      	ldr	r2, [r4, #68]	; 0x44
 802eefc:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
 802ef00:	4293      	cmp	r3, r2
 802ef02:	f43f af40 	beq.w	802ed86 <HAL_RCC_OscConfig+0x3ba>
 802ef06:	e5bc      	b.n	802ea82 <HAL_RCC_OscConfig+0xb6>
 802ef08:	11c1808c 	.word	0x11c1808c

0802ef0c <HAL_RCC_ClockConfig>:
{
 802ef0c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802ef10:	460d      	mov	r5, r1
  if (RCC_ClkInitStruct == NULL)
 802ef12:	4604      	mov	r4, r0
 802ef14:	b910      	cbnz	r0, 802ef1c <HAL_RCC_ClockConfig+0x10>
    return HAL_ERROR;
 802ef16:	2001      	movs	r0, #1
}
 802ef18:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 802ef1c:	4e74      	ldr	r6, [pc, #464]	; (802f0f0 <HAL_RCC_ClockConfig+0x1e4>)
 802ef1e:	6833      	ldr	r3, [r6, #0]
 802ef20:	f003 0307 	and.w	r3, r3, #7
 802ef24:	428b      	cmp	r3, r1
 802ef26:	d316      	bcc.n	802ef56 <HAL_RCC_ClockConfig+0x4a>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 802ef28:	6823      	ldr	r3, [r4, #0]
 802ef2a:	079a      	lsls	r2, r3, #30
 802ef2c:	d527      	bpl.n	802ef7e <HAL_RCC_ClockConfig+0x72>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
 802ef2e:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
 802ef32:	68a2      	ldr	r2, [r4, #8]
 802ef34:	68b3      	ldr	r3, [r6, #8]
 802ef36:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 802ef3a:	4313      	orrs	r3, r2
 802ef3c:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 802ef3e:	f7fd fb81 	bl	802c644 <HAL_GetTick>
 802ef42:	4607      	mov	r7, r0
  * @rmtoll CFGR         HPREF       LL_RCC_IsActiveFlag_HPRE
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_HPRE(void)
{
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_HPREF) == (RCC_CFGR_HPREF)) ? 1UL : 0UL);
 802ef44:	68b3      	ldr	r3, [r6, #8]
 802ef46:	03db      	lsls	r3, r3, #15
 802ef48:	d419      	bmi.n	802ef7e <HAL_RCC_ClockConfig+0x72>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 802ef4a:	f7fd fb7b 	bl	802c644 <HAL_GetTick>
 802ef4e:	1bc3      	subs	r3, r0, r7
 802ef50:	2b02      	cmp	r3, #2
 802ef52:	d9f7      	bls.n	802ef44 <HAL_RCC_ClockConfig+0x38>
 802ef54:	e011      	b.n	802ef7a <HAL_RCC_ClockConfig+0x6e>
    __HAL_FLASH_SET_LATENCY(FLatency);
 802ef56:	6833      	ldr	r3, [r6, #0]
 802ef58:	f023 0307 	bic.w	r3, r3, #7
 802ef5c:	430b      	orrs	r3, r1
 802ef5e:	6033      	str	r3, [r6, #0]
    tickstart = HAL_GetTick();
 802ef60:	f7fd fb70 	bl	802c644 <HAL_GetTick>
 802ef64:	4607      	mov	r7, r0
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 802ef66:	6833      	ldr	r3, [r6, #0]
 802ef68:	f003 0307 	and.w	r3, r3, #7
 802ef6c:	42ab      	cmp	r3, r5
 802ef6e:	d0db      	beq.n	802ef28 <HAL_RCC_ClockConfig+0x1c>
      if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 802ef70:	f7fd fb68 	bl	802c644 <HAL_GetTick>
 802ef74:	1bc0      	subs	r0, r0, r7
 802ef76:	2802      	cmp	r0, #2
 802ef78:	d9f5      	bls.n	802ef66 <HAL_RCC_ClockConfig+0x5a>
        return HAL_TIMEOUT;
 802ef7a:	2003      	movs	r0, #3
 802ef7c:	e7cc      	b.n	802ef18 <HAL_RCC_ClockConfig+0xc>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK2) == RCC_CLOCKTYPE_HCLK2)
 802ef7e:	6823      	ldr	r3, [r4, #0]
 802ef80:	0698      	lsls	r0, r3, #26
 802ef82:	d516      	bpl.n	802efb2 <HAL_RCC_ClockConfig+0xa6>
  MODIFY_REG(RCC->EXTCFGR, RCC_EXTCFGR_C2HPRE, Prescaler);
 802ef84:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
 802ef88:	6962      	ldr	r2, [r4, #20]
 802ef8a:	f8d6 3108 	ldr.w	r3, [r6, #264]	; 0x108
 802ef8e:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 802ef92:	4313      	orrs	r3, r2
 802ef94:	f8c6 3108 	str.w	r3, [r6, #264]	; 0x108
    tickstart = HAL_GetTick();
 802ef98:	f7fd fb54 	bl	802c644 <HAL_GetTick>
 802ef9c:	4607      	mov	r7, r0
  * @rmtoll EXTCFGR         C2HPREF       LL_RCC_IsActiveFlag_C2HPRE
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_C2HPRE(void)
{
  return ((READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_C2HPREF) == (RCC_EXTCFGR_C2HPREF)) ? 1UL : 0UL);
 802ef9e:	f8d6 3108 	ldr.w	r3, [r6, #264]	; 0x108
 802efa2:	0399      	lsls	r1, r3, #14
 802efa4:	d405      	bmi.n	802efb2 <HAL_RCC_ClockConfig+0xa6>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 802efa6:	f7fd fb4d 	bl	802c644 <HAL_GetTick>
 802efaa:	1bc3      	subs	r3, r0, r7
 802efac:	2b02      	cmp	r3, #2
 802efae:	d9f6      	bls.n	802ef9e <HAL_RCC_ClockConfig+0x92>
 802efb0:	e7e3      	b.n	802ef7a <HAL_RCC_ClockConfig+0x6e>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK3) == RCC_CLOCKTYPE_HCLK3)
 802efb2:	6823      	ldr	r3, [r4, #0]
 802efb4:	065a      	lsls	r2, r3, #25
 802efb6:	d517      	bpl.n	802efe8 <HAL_RCC_ClockConfig+0xdc>
  MODIFY_REG(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPRE, Prescaler >> 4);
 802efb8:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
 802efbc:	69a2      	ldr	r2, [r4, #24]
 802efbe:	f8d6 3108 	ldr.w	r3, [r6, #264]	; 0x108
 802efc2:	f023 030f 	bic.w	r3, r3, #15
 802efc6:	ea43 1312 	orr.w	r3, r3, r2, lsr #4
 802efca:	f8c6 3108 	str.w	r3, [r6, #264]	; 0x108
    tickstart = HAL_GetTick();
 802efce:	f7fd fb39 	bl	802c644 <HAL_GetTick>
 802efd2:	4607      	mov	r7, r0
  * @rmtoll EXTCFGR         SHDHPREF       LL_RCC_IsActiveFlag_SHDHPRE
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_SHDHPRE(void)
{
  return ((READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPREF) == (RCC_EXTCFGR_SHDHPREF)) ? 1UL : 0UL);
 802efd4:	f8d6 3108 	ldr.w	r3, [r6, #264]	; 0x108
 802efd8:	03db      	lsls	r3, r3, #15
 802efda:	d405      	bmi.n	802efe8 <HAL_RCC_ClockConfig+0xdc>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 802efdc:	f7fd fb32 	bl	802c644 <HAL_GetTick>
 802efe0:	1bc3      	subs	r3, r0, r7
 802efe2:	2b02      	cmp	r3, #2
 802efe4:	d9f6      	bls.n	802efd4 <HAL_RCC_ClockConfig+0xc8>
 802efe6:	e7c8      	b.n	802ef7a <HAL_RCC_ClockConfig+0x6e>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 802efe8:	6823      	ldr	r3, [r4, #0]
 802efea:	075e      	lsls	r6, r3, #29
 802efec:	d513      	bpl.n	802f016 <HAL_RCC_ClockConfig+0x10a>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, Prescaler);
 802efee:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
 802eff2:	68e2      	ldr	r2, [r4, #12]
 802eff4:	68b3      	ldr	r3, [r6, #8]
 802eff6:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 802effa:	4313      	orrs	r3, r2
 802effc:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 802effe:	f7fd fb21 	bl	802c644 <HAL_GetTick>
 802f002:	4607      	mov	r7, r0
  * @rmtoll CFGR         PPRE1F       LL_RCC_IsActiveFlag_PPRE1
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_PPRE1(void)
{
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1F) == (RCC_CFGR_PPRE1F)) ? 1UL : 0UL);
 802f004:	68b3      	ldr	r3, [r6, #8]
 802f006:	0398      	lsls	r0, r3, #14
 802f008:	d405      	bmi.n	802f016 <HAL_RCC_ClockConfig+0x10a>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 802f00a:	f7fd fb1b 	bl	802c644 <HAL_GetTick>
 802f00e:	1bc3      	subs	r3, r0, r7
 802f010:	2b02      	cmp	r3, #2
 802f012:	d9f7      	bls.n	802f004 <HAL_RCC_ClockConfig+0xf8>
 802f014:	e7b1      	b.n	802ef7a <HAL_RCC_ClockConfig+0x6e>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 802f016:	6823      	ldr	r3, [r4, #0]
 802f018:	0719      	lsls	r1, r3, #28
 802f01a:	d514      	bpl.n	802f046 <HAL_RCC_ClockConfig+0x13a>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, Prescaler);
 802f01c:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
    LL_RCC_SetAPB2Prescaler((RCC_ClkInitStruct->APB2CLKDivider) << 3U);
 802f020:	6922      	ldr	r2, [r4, #16]
 802f022:	68b3      	ldr	r3, [r6, #8]
 802f024:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 802f028:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 802f02c:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 802f02e:	f7fd fb09 	bl	802c644 <HAL_GetTick>
 802f032:	4607      	mov	r7, r0
  * @rmtoll CFGR         PPRE2F       LL_RCC_IsActiveFlag_PPRE2
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_PPRE2(void)
{
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2F) == (RCC_CFGR_PPRE2F)) ? 1UL : 0UL);
 802f034:	68b3      	ldr	r3, [r6, #8]
 802f036:	035a      	lsls	r2, r3, #13
 802f038:	d405      	bmi.n	802f046 <HAL_RCC_ClockConfig+0x13a>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 802f03a:	f7fd fb03 	bl	802c644 <HAL_GetTick>
 802f03e:	1bc3      	subs	r3, r0, r7
 802f040:	2b02      	cmp	r3, #2
 802f042:	d9f7      	bls.n	802f034 <HAL_RCC_ClockConfig+0x128>
 802f044:	e799      	b.n	802ef7a <HAL_RCC_ClockConfig+0x6e>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 802f046:	6823      	ldr	r3, [r4, #0]
 802f048:	07db      	lsls	r3, r3, #31
 802f04a:	d40f      	bmi.n	802f06c <HAL_RCC_ClockConfig+0x160>
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 802f04c:	4c28      	ldr	r4, [pc, #160]	; (802f0f0 <HAL_RCC_ClockConfig+0x1e4>)
 802f04e:	6823      	ldr	r3, [r4, #0]
 802f050:	f003 0307 	and.w	r3, r3, #7
 802f054:	42ab      	cmp	r3, r5
 802f056:	d837      	bhi.n	802f0c8 <HAL_RCC_ClockConfig+0x1bc>
  SystemCoreClock = HAL_RCC_GetHCLKFreq();
 802f058:	f7ff fca8 	bl	802e9ac <HAL_RCC_GetHCLKFreq>
 802f05c:	4b25      	ldr	r3, [pc, #148]	; (802f0f4 <HAL_RCC_ClockConfig+0x1e8>)
 802f05e:	6018      	str	r0, [r3, #0]
  return HAL_InitTick(uwTickPrio);
 802f060:	4b25      	ldr	r3, [pc, #148]	; (802f0f8 <HAL_RCC_ClockConfig+0x1ec>)
}
 802f062:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  return HAL_InitTick(uwTickPrio);
 802f066:	6818      	ldr	r0, [r3, #0]
 802f068:	f7fd baea 	b.w	802c640 <HAL_InitTick>
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 802f06c:	6863      	ldr	r3, [r4, #4]
 802f06e:	2b02      	cmp	r3, #2
 802f070:	d11e      	bne.n	802f0b0 <HAL_RCC_ClockConfig+0x1a4>
      if (LL_RCC_HSE_IsReady() == 0U)
 802f072:	f7ff fba1 	bl	802e7b8 <LL_RCC_HSE_IsReady>
      if (LL_RCC_HSI_IsReady() == 0U)
 802f076:	2800      	cmp	r0, #0
 802f078:	f43f af4d 	beq.w	802ef16 <HAL_RCC_ClockConfig+0xa>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
 802f07c:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
 802f080:	6862      	ldr	r2, [r4, #4]
 802f082:	68b3      	ldr	r3, [r6, #8]
 802f084:	f023 0303 	bic.w	r3, r3, #3
 802f088:	4313      	orrs	r3, r2
 802f08a:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 802f08c:	f7fd fada 	bl	802c644 <HAL_GetTick>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 802f090:	f241 3888 	movw	r8, #5000	; 0x1388
    tickstart = HAL_GetTick();
 802f094:	4607      	mov	r7, r0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 802f096:	68b3      	ldr	r3, [r6, #8]
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 802f098:	6862      	ldr	r2, [r4, #4]
 802f09a:	f003 030c 	and.w	r3, r3, #12
 802f09e:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 802f0a2:	d0d3      	beq.n	802f04c <HAL_RCC_ClockConfig+0x140>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 802f0a4:	f7fd face 	bl	802c644 <HAL_GetTick>
 802f0a8:	1bc0      	subs	r0, r0, r7
 802f0aa:	4540      	cmp	r0, r8
 802f0ac:	d9f3      	bls.n	802f096 <HAL_RCC_ClockConfig+0x18a>
 802f0ae:	e764      	b.n	802ef7a <HAL_RCC_ClockConfig+0x6e>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 802f0b0:	2b03      	cmp	r3, #3
 802f0b2:	d102      	bne.n	802f0ba <HAL_RCC_ClockConfig+0x1ae>
      if (LL_RCC_PLL_IsReady() == 0U)
 802f0b4:	f7ff fb9b 	bl	802e7ee <LL_RCC_PLL_IsReady>
 802f0b8:	e7dd      	b.n	802f076 <HAL_RCC_ClockConfig+0x16a>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 802f0ba:	b913      	cbnz	r3, 802f0c2 <HAL_RCC_ClockConfig+0x1b6>
      if (LL_RCC_MSI_IsReady() == 0U)
 802f0bc:	f7ff fb88 	bl	802e7d0 <LL_RCC_MSI_IsReady>
 802f0c0:	e7d9      	b.n	802f076 <HAL_RCC_ClockConfig+0x16a>
      if (LL_RCC_HSI_IsReady() == 0U)
 802f0c2:	f7ff fb7f 	bl	802e7c4 <LL_RCC_HSI_IsReady>
 802f0c6:	e7d6      	b.n	802f076 <HAL_RCC_ClockConfig+0x16a>
    __HAL_FLASH_SET_LATENCY(FLatency);
 802f0c8:	6823      	ldr	r3, [r4, #0]
 802f0ca:	f023 0307 	bic.w	r3, r3, #7
 802f0ce:	432b      	orrs	r3, r5
 802f0d0:	6023      	str	r3, [r4, #0]
    tickstart = HAL_GetTick();
 802f0d2:	f7fd fab7 	bl	802c644 <HAL_GetTick>
 802f0d6:	4606      	mov	r6, r0
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 802f0d8:	6823      	ldr	r3, [r4, #0]
 802f0da:	f003 0307 	and.w	r3, r3, #7
 802f0de:	42ab      	cmp	r3, r5
 802f0e0:	d0ba      	beq.n	802f058 <HAL_RCC_ClockConfig+0x14c>
      if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 802f0e2:	f7fd faaf 	bl	802c644 <HAL_GetTick>
 802f0e6:	1b80      	subs	r0, r0, r6
 802f0e8:	2802      	cmp	r0, #2
 802f0ea:	d9f5      	bls.n	802f0d8 <HAL_RCC_ClockConfig+0x1cc>
 802f0ec:	e745      	b.n	802ef7a <HAL_RCC_ClockConfig+0x6e>
 802f0ee:	bf00      	nop
 802f0f0:	58004000 	.word	0x58004000
 802f0f4:	2000344c 	.word	0x2000344c
 802f0f8:	20003454 	.word	0x20003454

0802f0fc <HAL_RCC_GetPCLK1Freq>:
{
 802f0fc:	b508      	push	{r3, lr}
  return ((uint32_t)(__LL_RCC_CALC_PCLK1_FREQ(HAL_RCC_GetHCLKFreq(), LL_RCC_GetAPB1Prescaler())));
 802f0fe:	f7ff fc55 	bl	802e9ac <HAL_RCC_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1));
 802f102:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802f106:	4a04      	ldr	r2, [pc, #16]	; (802f118 <HAL_RCC_GetPCLK1Freq+0x1c>)
 802f108:	689b      	ldr	r3, [r3, #8]
 802f10a:	f3c3 2302 	ubfx	r3, r3, #8, #3
 802f10e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
}
 802f112:	40d8      	lsrs	r0, r3
 802f114:	bd08      	pop	{r3, pc}
 802f116:	bf00      	nop
 802f118:	0803b9d4 	.word	0x0803b9d4

0802f11c <HAL_RCC_GetPCLK2Freq>:
{
 802f11c:	b508      	push	{r3, lr}
  return ((uint32_t)(__LL_RCC_CALC_PCLK2_FREQ(HAL_RCC_GetHCLKFreq(), LL_RCC_GetAPB2Prescaler())));
 802f11e:	f7ff fc45 	bl	802e9ac <HAL_RCC_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2));
 802f122:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802f126:	4a04      	ldr	r2, [pc, #16]	; (802f138 <HAL_RCC_GetPCLK2Freq+0x1c>)
 802f128:	689b      	ldr	r3, [r3, #8]
 802f12a:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 802f12e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
}
 802f132:	40d8      	lsrs	r0, r3
 802f134:	bd08      	pop	{r3, pc}
 802f136:	bf00      	nop
 802f138:	0803b9d4 	.word	0x0803b9d4

0802f13c <LL_RCC_LSE_IsReady>:
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? 1UL : 0UL);
 802f13c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802f140:	f8d3 0090 	ldr.w	r0, [r3, #144]	; 0x90
}
 802f144:	f3c0 0040 	ubfx	r0, r0, #1, #1
 802f148:	4770      	bx	lr

0802f14a <LL_RCC_SetI2CClockSource>:
  MODIFY_REG(RCC->CCIPR, ((I2CxSource >> 4) & 0x000FF000U), ((I2CxSource << 4) & 0x000FF000U));
 802f14a:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 802f14e:	0902      	lsrs	r2, r0, #4
 802f150:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 802f154:	f402 227f 	and.w	r2, r2, #1044480	; 0xff000
 802f158:	0100      	lsls	r0, r0, #4
 802f15a:	ea23 0302 	bic.w	r3, r3, r2
 802f15e:	f400 207f 	and.w	r0, r0, #1044480	; 0xff000
 802f162:	4318      	orrs	r0, r3
 802f164:	f8c1 0088 	str.w	r0, [r1, #136]	; 0x88
}
 802f168:	4770      	bx	lr

0802f16a <LL_RCC_SetLPTIMClockSource>:
  MODIFY_REG(RCC->CCIPR, (LPTIMxSource & 0xFFFF0000U), (LPTIMxSource << 16));
 802f16a:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 802f16e:	0c02      	lsrs	r2, r0, #16
 802f170:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 802f174:	0412      	lsls	r2, r2, #16
 802f176:	ea23 0302 	bic.w	r3, r3, r2
 802f17a:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 802f17e:	f8c1 0088 	str.w	r0, [r1, #136]	; 0x88
}
 802f182:	4770      	bx	lr

0802f184 <HAL_RCCEx_PeriphCLKConfig>:
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 802f184:	b570      	push	{r4, r5, r6, lr}

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*-------------------------- RTC clock source configuration ----------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 802f186:	6805      	ldr	r5, [r0, #0]
 802f188:	f415 3580 	ands.w	r5, r5, #65536	; 0x10000
{
 802f18c:	4604      	mov	r4, r0
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 802f18e:	d038      	beq.n	802f202 <HAL_RCCEx_PeriphCLKConfig+0x7e>
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));


    /* Enable write access to Backup domain */
    HAL_PWR_EnableBkUpAccess();
 802f190:	f7ff fa9c 	bl	802e6cc <HAL_PWR_EnableBkUpAccess>

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 802f194:	f7fd fa56 	bl	802c644 <HAL_GetTick>

    while (!(READ_BIT(PWR->CR1, PWR_CR1_DBP) == (PWR_CR1_DBP)))
 802f198:	4e64      	ldr	r6, [pc, #400]	; (802f32c <HAL_RCCEx_PeriphCLKConfig+0x1a8>)
    tickstart = HAL_GetTick();
 802f19a:	4605      	mov	r5, r0
    while (!(READ_BIT(PWR->CR1, PWR_CR1_DBP) == (PWR_CR1_DBP)))
 802f19c:	6833      	ldr	r3, [r6, #0]
 802f19e:	05db      	lsls	r3, r3, #23
 802f1a0:	d529      	bpl.n	802f1f6 <HAL_RCCEx_PeriphCLKConfig+0x72>
  return (uint32_t)(READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL));
 802f1a2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
    }

    if (ret == HAL_OK)
    {
      /* Reset the Backup domain only if the RTC Clock source selection is modified */
      if (LL_RCC_GetRTCClockSource() != PeriphClkInit->RTCClockSelection)
 802f1a6:	6b61      	ldr	r1, [r4, #52]	; 0x34
 802f1a8:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 802f1ac:	f402 7240 	and.w	r2, r2, #768	; 0x300
 802f1b0:	4291      	cmp	r1, r2
 802f1b2:	d014      	beq.n	802f1de <HAL_RCCEx_PeriphCLKConfig+0x5a>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 802f1b4:	f8d3 1090 	ldr.w	r1, [r3, #144]	; 0x90
  SET_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 802f1b8:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 802f1bc:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 802f1c0:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 802f1c4:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 802f1c8:	f421 7040 	bic.w	r0, r1, #768	; 0x300
 802f1cc:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpregister;
      }

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSERDY))
 802f1d0:	078d      	lsls	r5, r1, #30
 802f1d2:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
        RCC->BDCR = tmpregister;
 802f1d6:	f8c3 0090 	str.w	r0, [r3, #144]	; 0x90
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSERDY))
 802f1da:	f100 8096 	bmi.w	802f30a <HAL_RCCEx_PeriphCLKConfig+0x186>
  MODIFY_REG(RCC->BDCR, RCC_BDCR_RTCSEL, Source);
 802f1de:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 802f1e2:	6b61      	ldr	r1, [r4, #52]	; 0x34
 802f1e4:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 802f1e8:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 802f1ec:	430b      	orrs	r3, r1
 802f1ee:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  HAL_StatusTypeDef status  = HAL_OK;   /* Final status */
 802f1f2:	2500      	movs	r5, #0
}
 802f1f4:	e005      	b.n	802f202 <HAL_RCCEx_PeriphCLKConfig+0x7e>
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 802f1f6:	f7fd fa25 	bl	802c644 <HAL_GetTick>
 802f1fa:	1b40      	subs	r0, r0, r5
 802f1fc:	2802      	cmp	r0, #2
 802f1fe:	d9cd      	bls.n	802f19c <HAL_RCCEx_PeriphCLKConfig+0x18>
        ret = HAL_TIMEOUT;
 802f200:	2503      	movs	r5, #3
    }

  }

  /*-------------------- USART1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 802f202:	6822      	ldr	r2, [r4, #0]
 802f204:	07d0      	lsls	r0, r2, #31
 802f206:	d50a      	bpl.n	802f21e <HAL_RCCEx_PeriphCLKConfig+0x9a>
  MODIFY_REG(RCC->CCIPR, (USARTxSource >> 16), (USARTxSource & 0x0000FFFFU));
 802f208:	f04f 40b0 	mov.w	r0, #1476395008	; 0x58000000
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 802f20c:	6861      	ldr	r1, [r4, #4]
 802f20e:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
 802f212:	ea23 4311 	bic.w	r3, r3, r1, lsr #16
 802f216:	b289      	uxth	r1, r1
 802f218:	430b      	orrs	r3, r1
 802f21a:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
  }

  /*-------------------- USART2 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 802f21e:	0791      	lsls	r1, r2, #30
 802f220:	d50a      	bpl.n	802f238 <HAL_RCCEx_PeriphCLKConfig+0xb4>
 802f222:	f04f 40b0 	mov.w	r0, #1476395008	; 0x58000000
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 802f226:	68a1      	ldr	r1, [r4, #8]
 802f228:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
 802f22c:	ea23 4311 	bic.w	r3, r3, r1, lsr #16
 802f230:	b289      	uxth	r1, r1
 802f232:	430b      	orrs	r3, r1
 802f234:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
  }

  /*-------------------- LPUART1 clock source configuration ------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 802f238:	0693      	lsls	r3, r2, #26
 802f23a:	d509      	bpl.n	802f250 <HAL_RCCEx_PeriphCLKConfig+0xcc>
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_LPUART1SEL, LPUARTxSource);
 802f23c:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 802f240:	6920      	ldr	r0, [r4, #16]
 802f242:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 802f246:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 802f24a:	4303      	orrs	r3, r0
 802f24c:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
  }

  /*-------------------- LPTIM1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 802f250:	0596      	lsls	r6, r2, #22
 802f252:	d502      	bpl.n	802f25a <HAL_RCCEx_PeriphCLKConfig+0xd6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));

    /* Configure the LPTIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 802f254:	6a20      	ldr	r0, [r4, #32]
 802f256:	f7ff ff88 	bl	802f16a <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------- LPTIM2 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 802f25a:	6823      	ldr	r3, [r4, #0]
 802f25c:	0558      	lsls	r0, r3, #21
 802f25e:	d502      	bpl.n	802f266 <HAL_RCCEx_PeriphCLKConfig+0xe2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM2CLKSOURCE(PeriphClkInit->Lptim2ClockSelection));

    /* Configure the LPTIM2 clock source */
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 802f260:	6a60      	ldr	r0, [r4, #36]	; 0x24
 802f262:	f7ff ff82 	bl	802f16a <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------- LPTIM3 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM3) == (RCC_PERIPHCLK_LPTIM3))
 802f266:	6823      	ldr	r3, [r4, #0]
 802f268:	0519      	lsls	r1, r3, #20
 802f26a:	d502      	bpl.n	802f272 <HAL_RCCEx_PeriphCLKConfig+0xee>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM3CLKSOURCE(PeriphClkInit->Lptim3ClockSelection));

    /* Configure the LPTIM3 clock source */
    __HAL_RCC_LPTIM3_CONFIG(PeriphClkInit->Lptim3ClockSelection);
 802f26c:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 802f26e:	f7ff ff7c 	bl	802f16a <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------- I2C1 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 802f272:	6823      	ldr	r3, [r4, #0]
 802f274:	065a      	lsls	r2, r3, #25
 802f276:	d502      	bpl.n	802f27e <HAL_RCCEx_PeriphCLKConfig+0xfa>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 802f278:	6960      	ldr	r0, [r4, #20]
 802f27a:	f7ff ff66 	bl	802f14a <LL_RCC_SetI2CClockSource>
  }

  /*-------------------- I2C2 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 802f27e:	6823      	ldr	r3, [r4, #0]
 802f280:	061b      	lsls	r3, r3, #24
 802f282:	d502      	bpl.n	802f28a <HAL_RCCEx_PeriphCLKConfig+0x106>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 802f284:	69a0      	ldr	r0, [r4, #24]
 802f286:	f7ff ff60 	bl	802f14a <LL_RCC_SetI2CClockSource>
  }

  /*-------------------- I2C3 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 802f28a:	6823      	ldr	r3, [r4, #0]
 802f28c:	05de      	lsls	r6, r3, #23
 802f28e:	d502      	bpl.n	802f296 <HAL_RCCEx_PeriphCLKConfig+0x112>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 802f290:	69e0      	ldr	r0, [r4, #28]
 802f292:	f7ff ff5a 	bl	802f14a <LL_RCC_SetI2CClockSource>
  }

  /*-------------------- I2S2 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S2) == (RCC_PERIPHCLK_I2S2))
 802f296:	6821      	ldr	r1, [r4, #0]
 802f298:	06c8      	lsls	r0, r1, #27
 802f29a:	d510      	bpl.n	802f2be <HAL_RCCEx_PeriphCLKConfig+0x13a>
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_I2S2SEL, I2SxSource);
 802f29c:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2S2CLKSOURCE(PeriphClkInit->I2s2ClockSelection));

    /* Configure the I2S2 clock source */
    __HAL_RCC_I2S2_CONFIG(PeriphClkInit->I2s2ClockSelection);
 802f2a0:	68e0      	ldr	r0, [r4, #12]
 802f2a2:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 802f2a6:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 802f2aa:	4303      	orrs	r3, r0
 802f2ac:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

    if (PeriphClkInit->I2s2ClockSelection == RCC_I2S2CLKSOURCE_PLL)
 802f2b0:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
    {
      /* Enable RCC_PLL_I2S2CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_I2S2CLK);
 802f2b4:	bf02      	ittt	eq
 802f2b6:	68d3      	ldreq	r3, [r2, #12]
 802f2b8:	f043 7380 	orreq.w	r3, r3, #16777216	; 0x1000000
 802f2bc:	60d3      	streq	r3, [r2, #12]
    }
  }

  /*-------------------- RNG clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 802f2be:	040a      	lsls	r2, r1, #16
 802f2c0:	d50e      	bpl.n	802f2e0 <HAL_RCCEx_PeriphCLKConfig+0x15c>
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_RNGSEL, RNGxSource);
 802f2c2:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
  {
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 802f2c6:	6b20      	ldr	r0, [r4, #48]	; 0x30
 802f2c8:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 802f2cc:	f023 4340 	bic.w	r3, r3, #3221225472	; 0xc0000000
 802f2d0:	4303      	orrs	r3, r0
 802f2d2:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

    if (PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 802f2d6:	b918      	cbnz	r0, 802f2e0 <HAL_RCCEx_PeriphCLKConfig+0x15c>
    {
      /* Enable RCC_PLL_RNGCLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_RNGCLK);
 802f2d8:	68d3      	ldr	r3, [r2, #12]
 802f2da:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 802f2de:	60d3      	str	r3, [r2, #12]
    }
  }

  /*-------------------- ADC clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 802f2e0:	044b      	lsls	r3, r1, #17
 802f2e2:	d510      	bpl.n	802f306 <HAL_RCCEx_PeriphCLKConfig+0x182>
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_ADCSEL, ADCxSource);
 802f2e4:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));

    /* Configure the ADC interface clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 802f2e8:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 802f2ea:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 802f2ee:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 802f2f2:	430b      	orrs	r3, r1

    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLL)
 802f2f4:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
 802f2f8:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
 802f2fc:	d103      	bne.n	802f306 <HAL_RCCEx_PeriphCLKConfig+0x182>
    {
      /* Enable RCC_PLL_RNGCLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_ADCCLK);
 802f2fe:	68d3      	ldr	r3, [r2, #12]
 802f300:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 802f304:	60d3      	str	r3, [r2, #12]
    }
  }

  return status;
}
 802f306:	4628      	mov	r0, r5
 802f308:	bd70      	pop	{r4, r5, r6, pc}
        tickstart = HAL_GetTick();
 802f30a:	f7fd f99b 	bl	802c644 <HAL_GetTick>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802f30e:	f241 3688 	movw	r6, #5000	; 0x1388
        tickstart = HAL_GetTick();
 802f312:	4605      	mov	r5, r0
        while (LL_RCC_LSE_IsReady() != 1U)
 802f314:	f7ff ff12 	bl	802f13c <LL_RCC_LSE_IsReady>
 802f318:	2801      	cmp	r0, #1
 802f31a:	f43f af60 	beq.w	802f1de <HAL_RCCEx_PeriphCLKConfig+0x5a>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802f31e:	f7fd f991 	bl	802c644 <HAL_GetTick>
 802f322:	1b40      	subs	r0, r0, r5
 802f324:	42b0      	cmp	r0, r6
 802f326:	d9f5      	bls.n	802f314 <HAL_RCCEx_PeriphCLKConfig+0x190>
 802f328:	e76a      	b.n	802f200 <HAL_RCCEx_PeriphCLKConfig+0x7c>
 802f32a:	bf00      	nop
 802f32c:	58000400 	.word	0x58000400

0802f330 <HAL_RTC_DeactivateAlarm>:
  *            @arg RTC_ALARM_A:  AlarmA
  *            @arg RTC_ALARM_B:  AlarmB
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_DeactivateAlarm(RTC_HandleTypeDef *hrtc, uint32_t Alarm)
{
 802f330:	b530      	push	{r4, r5, lr}
  /* Check the parameters */
  assert_param(IS_RTC_ALARM(Alarm));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 802f332:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 802f336:	2b01      	cmp	r3, #1
 802f338:	f04f 0202 	mov.w	r2, #2
 802f33c:	d022      	beq.n	802f384 <HAL_RTC_DeactivateAlarm+0x54>

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f33e:	4b19      	ldr	r3, [pc, #100]	; (802f3a4 <HAL_RTC_DeactivateAlarm+0x74>)
  hrtc->State = HAL_RTC_STATE_BUSY;
 802f340:	f880 202d 	strb.w	r2, [r0, #45]	; 0x2d
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f344:	24ca      	movs	r4, #202	; 0xca
  __HAL_LOCK(hrtc);
 802f346:	2501      	movs	r5, #1
 802f348:	f880 502c 	strb.w	r5, [r0, #44]	; 0x2c
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f34c:	625c      	str	r4, [r3, #36]	; 0x24
 802f34e:	2453      	movs	r4, #83	; 0x53
 802f350:	625c      	str	r4, [r3, #36]	; 0x24

  if (Alarm == RTC_ALARM_A)
 802f352:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 802f356:	6b04      	ldr	r4, [r0, #48]	; 0x30
 802f358:	d116      	bne.n	802f388 <HAL_RTC_DeactivateAlarm+0x58>
  {
    /* AlarmA, In case of interrupt mode is used, the interrupt source must disabled */
    CLEAR_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 802f35a:	699a      	ldr	r2, [r3, #24]
 802f35c:	f422 5288 	bic.w	r2, r2, #4352	; 0x1100
 802f360:	619a      	str	r2, [r3, #24]

    /* AlarmA, Clear SSCLR */
    CLEAR_BIT(RTC->ALRMASSR, RTC_ALRMASSR_SSCLR);
 802f362:	6c5a      	ldr	r2, [r3, #68]	; 0x44

    /* Store in the handle the Alarm A disabled */
    CLEAR_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRAMF);
 802f364:	f024 0401 	bic.w	r4, r4, #1
    CLEAR_BIT(RTC->ALRMASSR, RTC_ALRMASSR_SSCLR);
 802f368:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 802f36c:	645a      	str	r2, [r3, #68]	; 0x44
    CLEAR_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRAMF);
 802f36e:	6304      	str	r4, [r0, #48]	; 0x30

    /* Clear AlarmA flag */
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
 802f370:	65dd      	str	r5, [r3, #92]	; 0x5c
    /* Clear AlarmB flag */
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 802f372:	4b0c      	ldr	r3, [pc, #48]	; (802f3a4 <HAL_RTC_DeactivateAlarm+0x74>)
 802f374:	22ff      	movs	r2, #255	; 0xff
 802f376:	625a      	str	r2, [r3, #36]	; 0x24

  hrtc->State = HAL_RTC_STATE_READY;
 802f378:	2301      	movs	r3, #1

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 802f37a:	2200      	movs	r2, #0
  hrtc->State = HAL_RTC_STATE_READY;
 802f37c:	f880 302d 	strb.w	r3, [r0, #45]	; 0x2d
  __HAL_UNLOCK(hrtc);
 802f380:	f880 202c 	strb.w	r2, [r0, #44]	; 0x2c
  __HAL_LOCK(hrtc);
 802f384:	4610      	mov	r0, r2

  return HAL_OK;
}
 802f386:	bd30      	pop	{r4, r5, pc}
    CLEAR_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 802f388:	6999      	ldr	r1, [r3, #24]
 802f38a:	f421 5108 	bic.w	r1, r1, #8704	; 0x2200
 802f38e:	6199      	str	r1, [r3, #24]
    CLEAR_BIT(RTC->ALRMBSSR, RTC_ALRMBSSR_SSCLR);
 802f390:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
    CLEAR_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRBMF);
 802f392:	f024 0402 	bic.w	r4, r4, #2
    CLEAR_BIT(RTC->ALRMBSSR, RTC_ALRMBSSR_SSCLR);
 802f396:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 802f39a:	64d9      	str	r1, [r3, #76]	; 0x4c
    CLEAR_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRBMF);
 802f39c:	6304      	str	r4, [r0, #48]	; 0x30
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
 802f39e:	65da      	str	r2, [r3, #92]	; 0x5c
 802f3a0:	e7e7      	b.n	802f372 <HAL_RTC_DeactivateAlarm+0x42>
 802f3a2:	bf00      	nop
 802f3a4:	40002800 	.word	0x40002800

0802f3a8 <HAL_RTC_AlarmIRQHandler>:
  * @brief  Handle Alarm interrupt request.
  * @param  hrtc RTC handle
  * @retval None
  */
void HAL_RTC_AlarmIRQHandler(RTC_HandleTypeDef *hrtc)
{
 802f3a8:	b570      	push	{r4, r5, r6, lr}
  uint32_t tmp = READ_REG(RTC->MISR) & READ_REG(hrtc->IsEnabled.RtcFeatures);
 802f3aa:	4d0b      	ldr	r5, [pc, #44]	; (802f3d8 <HAL_RTC_AlarmIRQHandler+0x30>)
 802f3ac:	6b03      	ldr	r3, [r0, #48]	; 0x30
 802f3ae:	6d6e      	ldr	r6, [r5, #84]	; 0x54
 802f3b0:	401e      	ands	r6, r3

  if ((tmp & RTC_MISR_ALRAMF) != 0U)
 802f3b2:	07f2      	lsls	r2, r6, #31
{
 802f3b4:	4604      	mov	r4, r0
  if ((tmp & RTC_MISR_ALRAMF) != 0U)
 802f3b6:	d503      	bpl.n	802f3c0 <HAL_RTC_AlarmIRQHandler+0x18>
  {
    /* Clear the AlarmA interrupt pending bit */
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
 802f3b8:	2301      	movs	r3, #1
 802f3ba:	65eb      	str	r3, [r5, #92]	; 0x5c

#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
    /* Call Compare Match registered Callback */
    hrtc->AlarmAEventCallback(hrtc);
#else
    HAL_RTC_AlarmAEventCallback(hrtc);
 802f3bc:	f7fd fa58 	bl	802c870 <HAL_RTC_AlarmAEventCallback>
#endif
  }

  if ((tmp & RTC_MISR_ALRBMF) != 0U)
 802f3c0:	07b3      	lsls	r3, r6, #30
 802f3c2:	d504      	bpl.n	802f3ce <HAL_RTC_AlarmIRQHandler+0x26>
  {
    /* Clear the AlarmB interrupt pending bit */
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
 802f3c4:	2302      	movs	r3, #2
 802f3c6:	65eb      	str	r3, [r5, #92]	; 0x5c

#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
    /* Call Compare Match registered Callback */
    hrtc->AlarmBEventCallback(hrtc);
#else
    HAL_RTCEx_AlarmBEventCallback(hrtc);
 802f3c8:	4620      	mov	r0, r4
 802f3ca:	f000 f9c5 	bl	802f758 <HAL_RTCEx_AlarmBEventCallback>
#endif
  }

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 802f3ce:	2301      	movs	r3, #1
 802f3d0:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
}
 802f3d4:	bd70      	pop	{r4, r5, r6, pc}
 802f3d6:	bf00      	nop
 802f3d8:	40002800 	.word	0x40002800

0802f3dc <HAL_RTC_WaitForSynchro>:
  *         correctly copied into the RTC_TR and RTC_DR shadow registers.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef *hrtc)
{
 802f3dc:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart;

  UNUSED(hrtc);
  /* Clear RSF flag */
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_RSF);
 802f3de:	4c0a      	ldr	r4, [pc, #40]	; (802f408 <HAL_RTC_WaitForSynchro+0x2c>)
 802f3e0:	68e3      	ldr	r3, [r4, #12]
 802f3e2:	f023 0320 	bic.w	r3, r3, #32
 802f3e6:	60e3      	str	r3, [r4, #12]

  tickstart = HAL_GetTick();
 802f3e8:	f7fd f92c 	bl	802c644 <HAL_GetTick>
 802f3ec:	4605      	mov	r5, r0

  /* Wait the registers to be synchronised */
  while (READ_BIT(RTC->ICSR, RTC_ICSR_RSF) == 0U)
 802f3ee:	68e3      	ldr	r3, [r4, #12]
 802f3f0:	069b      	lsls	r3, r3, #26
 802f3f2:	d501      	bpl.n	802f3f8 <HAL_RTC_WaitForSynchro+0x1c>
    {
      return HAL_TIMEOUT;
    }
  }

  return HAL_OK;
 802f3f4:	2000      	movs	r0, #0
}
 802f3f6:	bd38      	pop	{r3, r4, r5, pc}
    if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 802f3f8:	f7fd f924 	bl	802c644 <HAL_GetTick>
 802f3fc:	1b40      	subs	r0, r0, r5
 802f3fe:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 802f402:	d9f4      	bls.n	802f3ee <HAL_RTC_WaitForSynchro+0x12>
      return HAL_TIMEOUT;
 802f404:	2003      	movs	r0, #3
 802f406:	e7f6      	b.n	802f3f6 <HAL_RTC_WaitForSynchro+0x1a>
 802f408:	40002800 	.word	0x40002800

0802f40c <RTC_EnterInitMode>:
  *         __HAL_RTC_WRITEPROTECTION_DISABLE() before calling this function.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef *hrtc)
{
 802f40c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;

  UNUSED(hrtc);
  /* Check if the Initialization mode is set */
  if (READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U)
 802f410:	4d11      	ldr	r5, [pc, #68]	; (802f458 <RTC_EnterInitMode+0x4c>)
 802f412:	68ec      	ldr	r4, [r5, #12]
 802f414:	f014 0440 	ands.w	r4, r4, #64	; 0x40
{
 802f418:	4607      	mov	r7, r0
  if (READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U)
 802f41a:	d11a      	bne.n	802f452 <RTC_EnterInitMode+0x46>
  {
    /* Set the Initialization mode */
    SET_BIT(RTC->ICSR, RTC_ICSR_INIT);
 802f41c:	68eb      	ldr	r3, [r5, #12]
 802f41e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 802f422:	60eb      	str	r3, [r5, #12]

    tickstart = HAL_GetTick();
 802f424:	f7fd f90e 	bl	802c644 <HAL_GetTick>
    while ((READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U) && (status != HAL_TIMEOUT))
    {
      if ((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
      {
        status = HAL_TIMEOUT;
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 802f428:	f04f 0803 	mov.w	r8, #3
    tickstart = HAL_GetTick();
 802f42c:	4606      	mov	r6, r0
    while ((READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U) && (status != HAL_TIMEOUT))
 802f42e:	68eb      	ldr	r3, [r5, #12]
 802f430:	065b      	lsls	r3, r3, #25
 802f432:	d401      	bmi.n	802f438 <RTC_EnterInitMode+0x2c>
 802f434:	2c03      	cmp	r4, #3
 802f436:	d102      	bne.n	802f43e <RTC_EnterInitMode+0x32>
      }
    }
  }

  return status;
}
 802f438:	4620      	mov	r0, r4
 802f43a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if ((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
 802f43e:	f7fd f901 	bl	802c644 <HAL_GetTick>
 802f442:	1b80      	subs	r0, r0, r6
 802f444:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 802f448:	bf84      	itt	hi
 802f44a:	f887 802d 	strbhi.w	r8, [r7, #45]	; 0x2d
        status = HAL_TIMEOUT;
 802f44e:	2403      	movhi	r4, #3
 802f450:	e7ed      	b.n	802f42e <RTC_EnterInitMode+0x22>
  HAL_StatusTypeDef status = HAL_OK;
 802f452:	2400      	movs	r4, #0
 802f454:	e7f0      	b.n	802f438 <RTC_EnterInitMode+0x2c>
 802f456:	bf00      	nop
 802f458:	40002800 	.word	0x40002800

0802f45c <RTC_ExitInitMode>:
HAL_StatusTypeDef RTC_ExitInitMode(RTC_HandleTypeDef *hrtc)
{
  HAL_StatusTypeDef status = HAL_OK;

  /* Exit Initialization mode */
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_INIT);
 802f45c:	4b10      	ldr	r3, [pc, #64]	; (802f4a0 <RTC_ExitInitMode+0x44>)
 802f45e:	68da      	ldr	r2, [r3, #12]
 802f460:	f022 0280 	bic.w	r2, r2, #128	; 0x80
{
 802f464:	b510      	push	{r4, lr}
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_INIT);
 802f466:	60da      	str	r2, [r3, #12]

  /* If CR_BYPSHAD bit = 0, wait for synchro */
  if (READ_BIT(RTC->CR, RTC_CR_BYPSHAD) == 0U)
 802f468:	699a      	ldr	r2, [r3, #24]
 802f46a:	0692      	lsls	r2, r2, #26
{
 802f46c:	4604      	mov	r4, r0
  if (READ_BIT(RTC->CR, RTC_CR_BYPSHAD) == 0U)
 802f46e:	d406      	bmi.n	802f47e <RTC_ExitInitMode+0x22>
  {
    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 802f470:	f7ff ffb4 	bl	802f3dc <HAL_RTC_WaitForSynchro>
 802f474:	b110      	cbz	r0, 802f47c <RTC_ExitInitMode+0x20>
    {
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 802f476:	2003      	movs	r0, #3
 802f478:	f884 002d 	strb.w	r0, [r4, #45]	; 0x2d
    /* Restore BYPSHAD bit */
    SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
  }

  return status;
}
 802f47c:	bd10      	pop	{r4, pc}
    CLEAR_BIT(RTC->CR, RTC_CR_BYPSHAD);
 802f47e:	699a      	ldr	r2, [r3, #24]
 802f480:	f022 0220 	bic.w	r2, r2, #32
 802f484:	619a      	str	r2, [r3, #24]
    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 802f486:	f7ff ffa9 	bl	802f3dc <HAL_RTC_WaitForSynchro>
 802f48a:	b110      	cbz	r0, 802f492 <RTC_ExitInitMode+0x36>
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 802f48c:	2003      	movs	r0, #3
 802f48e:	f884 002d 	strb.w	r0, [r4, #45]	; 0x2d
    SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
 802f492:	4a03      	ldr	r2, [pc, #12]	; (802f4a0 <RTC_ExitInitMode+0x44>)
 802f494:	6993      	ldr	r3, [r2, #24]
 802f496:	f043 0320 	orr.w	r3, r3, #32
 802f49a:	6193      	str	r3, [r2, #24]
  return status;
 802f49c:	e7ee      	b.n	802f47c <RTC_ExitInitMode+0x20>
 802f49e:	bf00      	nop
 802f4a0:	40002800 	.word	0x40002800

0802f4a4 <HAL_RTC_Init>:
{
 802f4a4:	b538      	push	{r3, r4, r5, lr}
  if (hrtc != NULL)
 802f4a6:	4604      	mov	r4, r0
 802f4a8:	2800      	cmp	r0, #0
 802f4aa:	d047      	beq.n	802f53c <HAL_RTC_Init+0x98>
    if (hrtc->State == HAL_RTC_STATE_RESET)
 802f4ac:	f890 302d 	ldrb.w	r3, [r0, #45]	; 0x2d
 802f4b0:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 802f4b4:	b91b      	cbnz	r3, 802f4be <HAL_RTC_Init+0x1a>
      hrtc->Lock = HAL_UNLOCKED;
 802f4b6:	f880 202c 	strb.w	r2, [r0, #44]	; 0x2c
      HAL_RTC_MspInit(hrtc);
 802f4ba:	f7fc ff37 	bl	802c32c <HAL_RTC_MspInit>
    __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f4be:	4d20      	ldr	r5, [pc, #128]	; (802f540 <HAL_RTC_Init+0x9c>)
    hrtc->State = HAL_RTC_STATE_BUSY;
 802f4c0:	2302      	movs	r3, #2
 802f4c2:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
    __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f4c6:	23ca      	movs	r3, #202	; 0xca
 802f4c8:	626b      	str	r3, [r5, #36]	; 0x24
 802f4ca:	2353      	movs	r3, #83	; 0x53
 802f4cc:	626b      	str	r3, [r5, #36]	; 0x24
    status = RTC_EnterInitMode(hrtc);
 802f4ce:	4620      	mov	r0, r4
 802f4d0:	f7ff ff9c 	bl	802f40c <RTC_EnterInitMode>
    if (status == HAL_OK)
 802f4d4:	bb70      	cbnz	r0, 802f534 <HAL_RTC_Init+0x90>
      CLEAR_BIT(RTC->CR, (RTC_CR_FMT | RTC_CR_POL | RTC_CR_OSEL | RTC_CR_TAMPOE));
 802f4d6:	69ab      	ldr	r3, [r5, #24]
 802f4d8:	f023 638e 	bic.w	r3, r3, #74448896	; 0x4700000
 802f4dc:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 802f4e0:	61ab      	str	r3, [r5, #24]
      SET_BIT(RTC->CR, (hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity));
 802f4e2:	6921      	ldr	r1, [r4, #16]
 802f4e4:	6863      	ldr	r3, [r4, #4]
 802f4e6:	69aa      	ldr	r2, [r5, #24]
 802f4e8:	430b      	orrs	r3, r1
 802f4ea:	4313      	orrs	r3, r2
 802f4ec:	69a2      	ldr	r2, [r4, #24]
 802f4ee:	4313      	orrs	r3, r2
 802f4f0:	61ab      	str	r3, [r5, #24]
      WRITE_REG(RTC->PRER, ((hrtc->Init.SynchPrediv) | (hrtc->Init.AsynchPrediv << RTC_PRER_PREDIV_A_Pos)));
 802f4f2:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 802f4f6:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 802f4fa:	612b      	str	r3, [r5, #16]
      MODIFY_REG(RTC->ICSR, RTC_ICSR_BIN | RTC_ICSR_BCDU, hrtc->Init.BinMode | hrtc->Init.BinMixBcdU);
 802f4fc:	e9d4 3109 	ldrd	r3, r1, [r4, #36]	; 0x24
 802f500:	68ea      	ldr	r2, [r5, #12]
 802f502:	430b      	orrs	r3, r1
 802f504:	f422 52f8 	bic.w	r2, r2, #7936	; 0x1f00
 802f508:	4313      	orrs	r3, r2
 802f50a:	60eb      	str	r3, [r5, #12]
      status = RTC_ExitInitMode(hrtc);
 802f50c:	4620      	mov	r0, r4
 802f50e:	f7ff ffa5 	bl	802f45c <RTC_ExitInitMode>
      if (status == HAL_OK)
 802f512:	b978      	cbnz	r0, 802f534 <HAL_RTC_Init+0x90>
        MODIFY_REG(RTC->CR, \
 802f514:	e9d4 1307 	ldrd	r1, r3, [r4, #28]
 802f518:	69aa      	ldr	r2, [r5, #24]
 802f51a:	430b      	orrs	r3, r1
 802f51c:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
 802f520:	4313      	orrs	r3, r2
 802f522:	6962      	ldr	r2, [r4, #20]
 802f524:	4313      	orrs	r3, r2
 802f526:	61ab      	str	r3, [r5, #24]
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 802f528:	23ff      	movs	r3, #255	; 0xff
 802f52a:	626b      	str	r3, [r5, #36]	; 0x24
      hrtc->State = HAL_RTC_STATE_READY;
 802f52c:	2301      	movs	r3, #1
 802f52e:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
}
 802f532:	bd38      	pop	{r3, r4, r5, pc}
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 802f534:	4b02      	ldr	r3, [pc, #8]	; (802f540 <HAL_RTC_Init+0x9c>)
 802f536:	22ff      	movs	r2, #255	; 0xff
 802f538:	625a      	str	r2, [r3, #36]	; 0x24
    if (status == HAL_OK)
 802f53a:	e7fa      	b.n	802f532 <HAL_RTC_Init+0x8e>
  HAL_StatusTypeDef status = HAL_ERROR;
 802f53c:	2001      	movs	r0, #1
 802f53e:	e7f8      	b.n	802f532 <HAL_RTC_Init+0x8e>
 802f540:	40002800 	.word	0x40002800

0802f544 <RTC_ByteToBcd2>:
  * @param  Value Byte to be converted
  * @retval Converted byte
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0U;
 802f544:	2300      	movs	r3, #0
  uint8_t tmp_Value = Value;

  while (tmp_Value >= 10U)
 802f546:	2809      	cmp	r0, #9
 802f548:	d803      	bhi.n	802f552 <RTC_ByteToBcd2+0xe>
  {
    bcdhigh++;
    tmp_Value -= 10U;
  }

  return ((uint8_t)(bcdhigh << 4U) | tmp_Value);
 802f54a:	ea40 1003 	orr.w	r0, r0, r3, lsl #4
}
 802f54e:	b2c0      	uxtb	r0, r0
 802f550:	4770      	bx	lr
    tmp_Value -= 10U;
 802f552:	380a      	subs	r0, #10
    bcdhigh++;
 802f554:	3301      	adds	r3, #1
    tmp_Value -= 10U;
 802f556:	b2c0      	uxtb	r0, r0
 802f558:	e7f5      	b.n	802f546 <RTC_ByteToBcd2+0x2>
	...

0802f55c <HAL_RTC_SetAlarm_IT>:
{
 802f55c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  __HAL_LOCK(hrtc);
 802f560:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 802f564:	2b01      	cmp	r3, #1
{
 802f566:	4605      	mov	r5, r0
 802f568:	f04f 0002 	mov.w	r0, #2
  __HAL_LOCK(hrtc);
 802f56c:	d067      	beq.n	802f63e <HAL_RTC_SetAlarm_IT+0xe2>
 802f56e:	2301      	movs	r3, #1
 802f570:	f885 302c 	strb.w	r3, [r5, #44]	; 0x2c
  binaryMode = READ_BIT(RTC->ICSR, RTC_ICSR_BIN);
 802f574:	4b4c      	ldr	r3, [pc, #304]	; (802f6a8 <HAL_RTC_SetAlarm_IT+0x14c>)
  hrtc->State = HAL_RTC_STATE_BUSY;
 802f576:	f885 002d 	strb.w	r0, [r5, #45]	; 0x2d
  binaryMode = READ_BIT(RTC->ICSR, RTC_ICSR_BIN);
 802f57a:	68de      	ldr	r6, [r3, #12]
 802f57c:	f406 7640 	and.w	r6, r6, #768	; 0x300
  if (binaryMode != RTC_BINARY_ONLY)
 802f580:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
 802f584:	d076      	beq.n	802f674 <HAL_RTC_SetAlarm_IT+0x118>
    if (Format == RTC_FORMAT_BIN)
 802f586:	694c      	ldr	r4, [r1, #20]
 802f588:	7808      	ldrb	r0, [r1, #0]
 802f58a:	f891 8001 	ldrb.w	r8, [r1, #1]
 802f58e:	f891 a002 	ldrb.w	sl, [r1, #2]
 802f592:	f891 7024 	ldrb.w	r7, [r1, #36]	; 0x24
 802f596:	2a00      	cmp	r2, #0
 802f598:	d153      	bne.n	802f642 <HAL_RTC_SetAlarm_IT+0xe6>
      if (READ_BIT(RTC->CR, RTC_CR_FMT) != 0U)
 802f59a:	699a      	ldr	r2, [r3, #24]
 802f59c:	f012 0240 	ands.w	r2, r2, #64	; 0x40
        sAlarm->AlarmTime.TimeFormat = 0x00U;
 802f5a0:	bf08      	it	eq
 802f5a2:	70ca      	strbeq	r2, [r1, #3]
      tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 802f5a4:	f7ff ffce 	bl	802f544 <RTC_ByteToBcd2>
 802f5a8:	4681      	mov	r9, r0
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
 802f5aa:	4640      	mov	r0, r8
 802f5ac:	f7ff ffca 	bl	802f544 <RTC_ByteToBcd2>
 802f5b0:	4680      	mov	r8, r0
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds) << RTC_ALRMAR_SU_Pos) | \
 802f5b2:	4650      	mov	r0, sl
 802f5b4:	f7ff ffc6 	bl	802f544 <RTC_ByteToBcd2>
 802f5b8:	4682      	mov	sl, r0
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << RTC_ALRMAR_DU_Pos) | \
 802f5ba:	4638      	mov	r0, r7
 802f5bc:	f7ff ffc2 	bl	802f544 <RTC_ByteToBcd2>
      tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 802f5c0:	6a0a      	ldr	r2, [r1, #32]
                ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
 802f5c2:	78cb      	ldrb	r3, [r1, #3]
      tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 802f5c4:	4314      	orrs	r4, r2
 802f5c6:	ea44 5483 	orr.w	r4, r4, r3, lsl #22
 802f5ca:	ea44 030a 	orr.w	r3, r4, sl
 802f5ce:	ea43 4309 	orr.w	r3, r3, r9, lsl #16
 802f5d2:	ea43 2308 	orr.w	r3, r3, r8, lsl #8
 802f5d6:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f5da:	4a33      	ldr	r2, [pc, #204]	; (802f6a8 <HAL_RTC_SetAlarm_IT+0x14c>)
 802f5dc:	20ca      	movs	r0, #202	; 0xca
 802f5de:	6250      	str	r0, [r2, #36]	; 0x24
 802f5e0:	2053      	movs	r0, #83	; 0x53
 802f5e2:	6250      	str	r0, [r2, #36]	; 0x24
  if (sAlarm->Alarm == RTC_ALARM_A)
 802f5e4:	6a8c      	ldr	r4, [r1, #40]	; 0x28
 802f5e6:	6988      	ldr	r0, [r1, #24]
 802f5e8:	f5b4 7f80 	cmp.w	r4, #256	; 0x100
    CLEAR_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 802f5ec:	6994      	ldr	r4, [r2, #24]
  if (sAlarm->Alarm == RTC_ALARM_A)
 802f5ee:	d143      	bne.n	802f678 <HAL_RTC_SetAlarm_IT+0x11c>
    CLEAR_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 802f5f0:	f424 5488 	bic.w	r4, r4, #4352	; 0x1100
 802f5f4:	6194      	str	r4, [r2, #24]
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
 802f5f6:	2401      	movs	r4, #1
 802f5f8:	65d4      	str	r4, [r2, #92]	; 0x5c
    if (binaryMode == RTC_BINARY_ONLY)
 802f5fa:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
      RTC->ALRMASSR = sAlarm->AlarmSubSecondMask | sAlarm->BinaryAutoClr;
 802f5fe:	bf0a      	itet	eq
 802f600:	69cb      	ldreq	r3, [r1, #28]
      WRITE_REG(RTC->ALRMAR, tmpreg);
 802f602:	6413      	strne	r3, [r2, #64]	; 0x40
      RTC->ALRMASSR = sAlarm->AlarmSubSecondMask | sAlarm->BinaryAutoClr;
 802f604:	4318      	orreq	r0, r3
      WRITE_REG(RTC->ALRMASSR, sAlarm->AlarmSubSecondMask);
 802f606:	6450      	str	r0, [r2, #68]	; 0x44
    WRITE_REG(RTC->ALRABINR, sAlarm->AlarmTime.SubSeconds);
 802f608:	4b27      	ldr	r3, [pc, #156]	; (802f6a8 <HAL_RTC_SetAlarm_IT+0x14c>)
 802f60a:	684a      	ldr	r2, [r1, #4]
 802f60c:	671a      	str	r2, [r3, #112]	; 0x70
    SET_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRAMF);
 802f60e:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 802f610:	f042 0201 	orr.w	r2, r2, #1
 802f614:	632a      	str	r2, [r5, #48]	; 0x30
    SET_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 802f616:	699a      	ldr	r2, [r3, #24]
 802f618:	f442 5288 	orr.w	r2, r2, #4352	; 0x1100
    SET_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 802f61c:	619a      	str	r2, [r3, #24]
  __HAL_RTC_ALARM_EXTI_ENABLE_IT();
 802f61e:	4a23      	ldr	r2, [pc, #140]	; (802f6ac <HAL_RTC_SetAlarm_IT+0x150>)
 802f620:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
 802f624:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 802f628:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 802f62c:	4b1e      	ldr	r3, [pc, #120]	; (802f6a8 <HAL_RTC_SetAlarm_IT+0x14c>)
 802f62e:	22ff      	movs	r2, #255	; 0xff
 802f630:	625a      	str	r2, [r3, #36]	; 0x24
  __HAL_UNLOCK(hrtc);
 802f632:	2000      	movs	r0, #0
  hrtc->State = HAL_RTC_STATE_READY;
 802f634:	2301      	movs	r3, #1
 802f636:	f885 302d 	strb.w	r3, [r5, #45]	; 0x2d
  __HAL_UNLOCK(hrtc);
 802f63a:	f885 002c 	strb.w	r0, [r5, #44]	; 0x2c
}
 802f63e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      if( sAlarm->AlarmMask != RTC_ALARMMASK_ALL )
 802f642:	f1b4 3f80 	cmp.w	r4, #2155905152	; 0x80808080
 802f646:	d007      	beq.n	802f658 <HAL_RTC_SetAlarm_IT+0xfc>
        if( sAlarm->AlarmMask != RTC_ALARMMASK_HOURS )
 802f648:	f5b4 0f00 	cmp.w	r4, #8388608	; 0x800000
 802f64c:	d004      	beq.n	802f658 <HAL_RTC_SetAlarm_IT+0xfc>
          if (READ_BIT(RTC->CR, RTC_CR_FMT) != 0U)
 802f64e:	699a      	ldr	r2, [r3, #24]
 802f650:	f012 0240 	ands.w	r2, r2, #64	; 0x40
            sAlarm->AlarmTime.TimeFormat = 0x00U;
 802f654:	bf08      	it	eq
 802f656:	70ca      	strbeq	r2, [r1, #3]
      tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 802f658:	6a0a      	ldr	r2, [r1, #32]
 802f65a:	4314      	orrs	r4, r2
 802f65c:	ea44 040a 	orr.w	r4, r4, sl
 802f660:	ea44 4300 	orr.w	r3, r4, r0, lsl #16
                ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
 802f664:	78c8      	ldrb	r0, [r1, #3]
      tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 802f666:	ea43 2308 	orr.w	r3, r3, r8, lsl #8
 802f66a:	ea43 5380 	orr.w	r3, r3, r0, lsl #22
 802f66e:	ea43 6307 	orr.w	r3, r3, r7, lsl #24
 802f672:	e7b2      	b.n	802f5da <HAL_RTC_SetAlarm_IT+0x7e>
  uint32_t tmpreg = 0;
 802f674:	2300      	movs	r3, #0
 802f676:	e7b0      	b.n	802f5da <HAL_RTC_SetAlarm_IT+0x7e>
    CLEAR_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 802f678:	f424 5408 	bic.w	r4, r4, #8704	; 0x2200
 802f67c:	6194      	str	r4, [r2, #24]
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
 802f67e:	2402      	movs	r4, #2
 802f680:	65d4      	str	r4, [r2, #92]	; 0x5c
    if (binaryMode == RTC_BINARY_ONLY)
 802f682:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
      WRITE_REG(RTC->ALRMBSSR, sAlarm->AlarmSubSecondMask | sAlarm->BinaryAutoClr);
 802f686:	bf0a      	itet	eq
 802f688:	69cb      	ldreq	r3, [r1, #28]
      WRITE_REG(RTC->ALRMBR, tmpreg);
 802f68a:	6493      	strne	r3, [r2, #72]	; 0x48
      WRITE_REG(RTC->ALRMBSSR, sAlarm->AlarmSubSecondMask | sAlarm->BinaryAutoClr);
 802f68c:	4318      	orreq	r0, r3
      WRITE_REG(RTC->ALRMBSSR, sAlarm->AlarmSubSecondMask);
 802f68e:	64d0      	str	r0, [r2, #76]	; 0x4c
    WRITE_REG(RTC->ALRBBINR, sAlarm->AlarmTime.SubSeconds);
 802f690:	4b05      	ldr	r3, [pc, #20]	; (802f6a8 <HAL_RTC_SetAlarm_IT+0x14c>)
 802f692:	684a      	ldr	r2, [r1, #4]
 802f694:	675a      	str	r2, [r3, #116]	; 0x74
    SET_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRBMF);
 802f696:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 802f698:	f042 0202 	orr.w	r2, r2, #2
 802f69c:	632a      	str	r2, [r5, #48]	; 0x30
    SET_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 802f69e:	699a      	ldr	r2, [r3, #24]
 802f6a0:	f442 5208 	orr.w	r2, r2, #8704	; 0x2200
 802f6a4:	e7ba      	b.n	802f61c <HAL_RTC_SetAlarm_IT+0xc0>
 802f6a6:	bf00      	nop
 802f6a8:	40002800 	.word	0x40002800
 802f6ac:	58000800 	.word	0x58000800

0802f6b0 <HAL_RTCEx_EnableBypassShadow>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_EnableBypassShadow(RTC_HandleTypeDef *hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);
 802f6b0:	f890 202c 	ldrb.w	r2, [r0, #44]	; 0x2c
 802f6b4:	2a01      	cmp	r2, #1
{
 802f6b6:	4603      	mov	r3, r0
 802f6b8:	f04f 0002 	mov.w	r0, #2
  __HAL_LOCK(hrtc);
 802f6bc:	d012      	beq.n	802f6e4 <HAL_RTCEx_EnableBypassShadow+0x34>

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f6be:	4a0a      	ldr	r2, [pc, #40]	; (802f6e8 <HAL_RTCEx_EnableBypassShadow+0x38>)
  hrtc->State = HAL_RTC_STATE_BUSY;
 802f6c0:	f883 002d 	strb.w	r0, [r3, #45]	; 0x2d
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f6c4:	21ca      	movs	r1, #202	; 0xca
 802f6c6:	6251      	str	r1, [r2, #36]	; 0x24
 802f6c8:	2153      	movs	r1, #83	; 0x53
 802f6ca:	6251      	str	r1, [r2, #36]	; 0x24

  /* Set the BYPSHAD bit */
  SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
 802f6cc:	6991      	ldr	r1, [r2, #24]
 802f6ce:	f041 0120 	orr.w	r1, r1, #32
 802f6d2:	6191      	str	r1, [r2, #24]

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 802f6d4:	21ff      	movs	r1, #255	; 0xff
 802f6d6:	6251      	str	r1, [r2, #36]	; 0x24

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 802f6d8:	2000      	movs	r0, #0
  hrtc->State = HAL_RTC_STATE_READY;
 802f6da:	2201      	movs	r2, #1
 802f6dc:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
  __HAL_UNLOCK(hrtc);
 802f6e0:	f883 002c 	strb.w	r0, [r3, #44]	; 0x2c

  return HAL_OK;
}
 802f6e4:	4770      	bx	lr
 802f6e6:	bf00      	nop
 802f6e8:	40002800 	.word	0x40002800

0802f6ec <HAL_RTCEx_SetSSRU_IT>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetSSRU_IT(RTC_HandleTypeDef *hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);
 802f6ec:	f890 202c 	ldrb.w	r2, [r0, #44]	; 0x2c
 802f6f0:	2a01      	cmp	r2, #1
{
 802f6f2:	4603      	mov	r3, r0
 802f6f4:	f04f 0002 	mov.w	r0, #2
  __HAL_LOCK(hrtc);
 802f6f8:	d019      	beq.n	802f72e <HAL_RTCEx_SetSSRU_IT+0x42>

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f6fa:	4a0d      	ldr	r2, [pc, #52]	; (802f730 <HAL_RTCEx_SetSSRU_IT+0x44>)
  hrtc->State = HAL_RTC_STATE_BUSY;
 802f6fc:	f883 002d 	strb.w	r0, [r3, #45]	; 0x2d
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f700:	21ca      	movs	r1, #202	; 0xca
 802f702:	6251      	str	r1, [r2, #36]	; 0x24
 802f704:	2153      	movs	r1, #83	; 0x53
 802f706:	6251      	str	r1, [r2, #36]	; 0x24

  /* Enable IT SSRU */
  __HAL_RTC_SSRU_ENABLE_IT(hrtc, RTC_IT_SSRU);
 802f708:	6991      	ldr	r1, [r2, #24]

  /* RTC SSRU Interrupt Configuration: EXTI configuration */
  __HAL_RTC_SSRU_EXTI_ENABLE_IT();
 802f70a:	480a      	ldr	r0, [pc, #40]	; (802f734 <HAL_RTCEx_SetSSRU_IT+0x48>)
  __HAL_RTC_SSRU_ENABLE_IT(hrtc, RTC_IT_SSRU);
 802f70c:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 802f710:	6191      	str	r1, [r2, #24]
  __HAL_RTC_SSRU_EXTI_ENABLE_IT();
 802f712:	f8d0 1080 	ldr.w	r1, [r0, #128]	; 0x80
 802f716:	f441 2180 	orr.w	r1, r1, #262144	; 0x40000
 802f71a:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 802f71e:	21ff      	movs	r1, #255	; 0xff
 802f720:	6251      	str	r1, [r2, #36]	; 0x24

  hrtc->State = HAL_RTC_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 802f722:	2000      	movs	r0, #0
  hrtc->State = HAL_RTC_STATE_READY;
 802f724:	2201      	movs	r2, #1
 802f726:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
  __HAL_UNLOCK(hrtc);
 802f72a:	f883 002c 	strb.w	r0, [r3, #44]	; 0x2c

  return HAL_OK;
}
 802f72e:	4770      	bx	lr
 802f730:	40002800 	.word	0x40002800
 802f734:	58000800 	.word	0x58000800

0802f738 <HAL_RTCEx_SSRUIRQHandler>:
  * @param  hrtc RTC handle
  * @retval None
  */
void HAL_RTCEx_SSRUIRQHandler(RTC_HandleTypeDef *hrtc)
{
  if ((RTC->MISR & RTC_MISR_SSRUMF) != 0u)
 802f738:	4b06      	ldr	r3, [pc, #24]	; (802f754 <HAL_RTCEx_SSRUIRQHandler+0x1c>)
 802f73a:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 802f73c:	0652      	lsls	r2, r2, #25
{
 802f73e:	b510      	push	{r4, lr}
 802f740:	4604      	mov	r4, r0
  if ((RTC->MISR & RTC_MISR_SSRUMF) != 0u)
 802f742:	d503      	bpl.n	802f74c <HAL_RTCEx_SSRUIRQHandler+0x14>
  {
    /* Immediately clear flags */
    RTC->SCR = RTC_SCR_CSSRUF;
 802f744:	2240      	movs	r2, #64	; 0x40
 802f746:	65da      	str	r2, [r3, #92]	; 0x5c
    /* SSRU callback */
#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
    /* Call SSRUEvent registered Callback */
    hrtc->SSRUEventCallback(hrtc);
#else
    HAL_RTCEx_SSRUEventCallback(hrtc);
 802f748:	f7fd f894 	bl	802c874 <HAL_RTCEx_SSRUEventCallback>
#endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
  }

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 802f74c:	2301      	movs	r3, #1
 802f74e:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
}
 802f752:	bd10      	pop	{r4, pc}
 802f754:	40002800 	.word	0x40002800

0802f758 <HAL_RTCEx_AlarmBEventCallback>:
 802f758:	4770      	bx	lr

0802f75a <HAL_RTCEx_BKUPWrite>:
  UNUSED(hrtc);
  /* Check the parameters */
  assert_param(IS_RTC_BKP(BackupRegister));

  tmp = (uint32_t) & (TAMP->BKP0R);
  tmp += (BackupRegister * 4U);
 802f75a:	0089      	lsls	r1, r1, #2
 802f75c:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 802f760:	f501 4131 	add.w	r1, r1, #45312	; 0xb100

  /* Write the specified register */
  *(__IO uint32_t *)tmp = (uint32_t)Data;
 802f764:	600a      	str	r2, [r1, #0]
}
 802f766:	4770      	bx	lr

0802f768 <HAL_RTCEx_BKUPRead>:
  UNUSED(hrtc);
  /* Check the parameters */
  assert_param(IS_RTC_BKP(BackupRegister));

  tmp = (uint32_t) & (TAMP->BKP0R);
  tmp += (BackupRegister * 4U);
 802f768:	0089      	lsls	r1, r1, #2
 802f76a:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 802f76e:	f501 4131 	add.w	r1, r1, #45312	; 0xb100

  /* Read the specified register */
  return (*(__IO uint32_t *)tmp);
 802f772:	6808      	ldr	r0, [r1, #0]
}
 802f774:	4770      	bx	lr
	...

0802f778 <LL_PWR_UnselectSUBGHZSPI_NSS>:
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 802f778:	4a03      	ldr	r2, [pc, #12]	; (802f788 <LL_PWR_UnselectSUBGHZSPI_NSS+0x10>)
 802f77a:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 802f77e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 802f782:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 802f786:	4770      	bx	lr
 802f788:	58000400 	.word	0x58000400

0802f78c <LL_PWR_SelectSUBGHZSPI_NSS>:
  CLEAR_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 802f78c:	4a03      	ldr	r2, [pc, #12]	; (802f79c <LL_PWR_SelectSUBGHZSPI_NSS+0x10>)
 802f78e:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 802f792:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 802f796:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 802f79a:	4770      	bx	lr
 802f79c:	58000400 	.word	0x58000400

0802f7a0 <SUBGHZSPI_Init>:
{
  /* Check the parameters */
  assert_param(IS_SUBGHZ_ALL_INSTANCE(SUBGHZSPI));

  /* Disable SUBGHZSPI Peripheral */
  CLEAR_BIT(SUBGHZSPI->CR1, SPI_CR1_SPE);
 802f7a0:	4b07      	ldr	r3, [pc, #28]	; (802f7c0 <SUBGHZSPI_Init+0x20>)
 802f7a2:	681a      	ldr	r2, [r3, #0]
 802f7a4:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 802f7a8:	601a      	str	r2, [r3, #0]
   *       NSS management: Internal (Done with External bit inside PWR        *
   *  Communication speed: BaudratePrescaler                             *
   *            First bit: MSB                                                *
   *      CRC calculation: Disable                                            *
   *--------------------------------------------------------------------------*/
  WRITE_REG(SUBGHZSPI->CR1, (SPI_CR1_MSTR | SPI_CR1_SSI | BaudratePrescaler | SPI_CR1_SSM));
 802f7aa:	f440 7041 	orr.w	r0, r0, #772	; 0x304
   *            Data Size: 8bits                                              *
   *              TI Mode: Disable                                            *
   *            NSS Pulse: Disable                                            *
   *    Rx FIFO Threshold: 8bits                                              *
   *--------------------------------------------------------------------------*/
  WRITE_REG(SUBGHZSPI->CR2, (SPI_CR2_FRXTH |  SPI_CR2_DS_0 | SPI_CR2_DS_1 | SPI_CR2_DS_2));
 802f7ae:	f44f 52b8 	mov.w	r2, #5888	; 0x1700
  WRITE_REG(SUBGHZSPI->CR1, (SPI_CR1_MSTR | SPI_CR1_SSI | BaudratePrescaler | SPI_CR1_SSM));
 802f7b2:	6018      	str	r0, [r3, #0]
  WRITE_REG(SUBGHZSPI->CR2, (SPI_CR2_FRXTH |  SPI_CR2_DS_0 | SPI_CR2_DS_1 | SPI_CR2_DS_2));
 802f7b4:	605a      	str	r2, [r3, #4]

  /* Enable SUBGHZSPI Peripheral */
  SET_BIT(SUBGHZSPI->CR1, SPI_CR1_SPE);
 802f7b6:	681a      	ldr	r2, [r3, #0]
 802f7b8:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 802f7bc:	601a      	str	r2, [r3, #0]
}
 802f7be:	4770      	bx	lr
 802f7c0:	58010000 	.word	0x58010000

0802f7c4 <HAL_SUBGHZ_Init>:
{
 802f7c4:	b513      	push	{r0, r1, r4, lr}
  if (hsubghz == NULL)
 802f7c6:	4604      	mov	r4, r0
 802f7c8:	2800      	cmp	r0, #0
 802f7ca:	d042      	beq.n	802f852 <HAL_SUBGHZ_Init+0x8e>
  if (hsubghz->State == HAL_SUBGHZ_STATE_RESET)
 802f7cc:	7983      	ldrb	r3, [r0, #6]
 802f7ce:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 802f7d2:	b913      	cbnz	r3, 802f7da <HAL_SUBGHZ_Init+0x16>
    hsubghz->Lock = HAL_UNLOCKED;
 802f7d4:	7142      	strb	r2, [r0, #5]
    HAL_SUBGHZ_MspInit(hsubghz);
 802f7d6:	f7fc fe47 	bl	802c468 <HAL_SUBGHZ_MspInit>
  hsubghz->State = HAL_SUBGHZ_STATE_BUSY;
 802f7da:	2302      	movs	r3, #2
 802f7dc:	71a3      	strb	r3, [r4, #6]
  CLEAR_BIT(RCC->CSR, RCC_CSR_RFRST);
 802f7de:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802f7e2:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 802f7e6:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 802f7ea:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f7ee:	4a1a      	ldr	r2, [pc, #104]	; (802f858 <HAL_SUBGHZ_Init+0x94>)
 802f7f0:	6811      	ldr	r1, [r2, #0]
 802f7f2:	221c      	movs	r2, #28
 802f7f4:	434a      	muls	r2, r1
 802f7f6:	0cd2      	lsrs	r2, r2, #19
 802f7f8:	2164      	movs	r1, #100	; 0x64
 802f7fa:	434a      	muls	r2, r1
 802f7fc:	9201      	str	r2, [sp, #4]
    if (count == 0U)
 802f7fe:	9a01      	ldr	r2, [sp, #4]
 802f800:	b9f2      	cbnz	r2, 802f840 <HAL_SUBGHZ_Init+0x7c>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 802f802:	2101      	movs	r1, #1
 802f804:	60a1      	str	r1, [r4, #8]
  LL_PWR_UnselectSUBGHZSPI_NSS();
 802f806:	f7ff ffb7 	bl	802f778 <LL_PWR_UnselectSUBGHZSPI_NSS>
  SET_BIT(EXTI->IMR2, ExtiLine);
 802f80a:	4a14      	ldr	r2, [pc, #80]	; (802f85c <HAL_SUBGHZ_Init+0x98>)
 802f80c:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 802f810:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 802f814:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  MODIFY_REG(PWR->CR3, PWR_CR3_EWRFBUSY, RadioBusyTrigger);
 802f818:	4b11      	ldr	r3, [pc, #68]	; (802f860 <HAL_SUBGHZ_Init+0x9c>)
 802f81a:	689a      	ldr	r2, [r3, #8]
 802f81c:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 802f820:	609a      	str	r2, [r3, #8]
  WRITE_REG(PWR->SCR, PWR_SCR_CWRFBUSYF);
 802f822:	f44f 6200 	mov.w	r2, #2048	; 0x800
 802f826:	619a      	str	r2, [r3, #24]
  if (status == HAL_OK)
 802f828:	b929      	cbnz	r1, 802f836 <HAL_SUBGHZ_Init+0x72>
    SUBGHZSPI_Init(hsubghz->Init.BaudratePrescaler);
 802f82a:	6820      	ldr	r0, [r4, #0]
 802f82c:	f7ff ffb8 	bl	802f7a0 <SUBGHZSPI_Init>
    hsubghz->DeepSleep = SUBGHZ_DEEP_SLEEP_ENABLE;
 802f830:	2301      	movs	r3, #1
 802f832:	7123      	strb	r3, [r4, #4]
    hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_NONE;
 802f834:	60a1      	str	r1, [r4, #8]
  hsubghz->State     = HAL_SUBGHZ_STATE_READY;
 802f836:	2301      	movs	r3, #1
 802f838:	71a3      	strb	r3, [r4, #6]
}
 802f83a:	4608      	mov	r0, r1
 802f83c:	b002      	add	sp, #8
 802f83e:	bd10      	pop	{r4, pc}
    count--;
 802f840:	9a01      	ldr	r2, [sp, #4]
 802f842:	3a01      	subs	r2, #1
 802f844:	9201      	str	r2, [sp, #4]
  return ((READ_BIT(RCC->CSR, RCC_CSR_RFRSTF) == (RCC_CSR_RFRSTF)) ? 1UL : 0UL);
 802f846:	f8d3 1094 	ldr.w	r1, [r3, #148]	; 0x94
 802f84a:	f411 4180 	ands.w	r1, r1, #16384	; 0x4000
 802f84e:	d1d6      	bne.n	802f7fe <HAL_SUBGHZ_Init+0x3a>
 802f850:	e7d9      	b.n	802f806 <HAL_SUBGHZ_Init+0x42>
    return status;
 802f852:	2101      	movs	r1, #1
 802f854:	e7f1      	b.n	802f83a <HAL_SUBGHZ_Init+0x76>
 802f856:	bf00      	nop
 802f858:	2000344c 	.word	0x2000344c
 802f85c:	58000800 	.word	0x58000800
 802f860:	58000400 	.word	0x58000400

0802f864 <SUBGHZSPI_Transmit>:
  * @param  Data  data to transmit
  * @retval HAL status
  */
HAL_StatusTypeDef SUBGHZSPI_Transmit(SUBGHZ_HandleTypeDef *hsubghz,
                                     uint8_t Data)
{
 802f864:	b513      	push	{r0, r1, r4, lr}
 802f866:	4602      	mov	r2, r0
  HAL_StatusTypeDef status = HAL_OK;
  __IO uint32_t count;

  /* Handle Tx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f868:	4817      	ldr	r0, [pc, #92]	; (802f8c8 <SUBGHZSPI_Transmit+0x64>)
 802f86a:	6804      	ldr	r4, [r0, #0]
 802f86c:	231c      	movs	r3, #28
 802f86e:	4363      	muls	r3, r4
 802f870:	0cdb      	lsrs	r3, r3, #19
 802f872:	2464      	movs	r4, #100	; 0x64
 802f874:	4363      	muls	r3, r4
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_TXE) != (SPI_SR_TXE));
 802f876:	4c15      	ldr	r4, [pc, #84]	; (802f8cc <SUBGHZSPI_Transmit+0x68>)
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f878:	9301      	str	r3, [sp, #4]
 802f87a:	4603      	mov	r3, r0
    if (count == 0U)
 802f87c:	9801      	ldr	r0, [sp, #4]
 802f87e:	b998      	cbnz	r0, 802f8a8 <SUBGHZSPI_Transmit+0x44>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 802f880:	2001      	movs	r0, #1
 802f882:	6090      	str	r0, [r2, #8]

  /* Transmit Data*/
#if defined (__GNUC__)
  __IO uint8_t *spidr = ((__IO uint8_t *)&SUBGHZSPI->DR);
  *spidr = Data;
 802f884:	4c12      	ldr	r4, [pc, #72]	; (802f8d0 <SUBGHZSPI_Transmit+0x6c>)
 802f886:	7021      	strb	r1, [r4, #0]
  *((__IO uint8_t *)&SUBGHZSPI->DR) = Data;
#endif /* __GNUC__ */

  /* Handle Rx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f888:	6819      	ldr	r1, [r3, #0]
 802f88a:	231c      	movs	r3, #28
 802f88c:	434b      	muls	r3, r1
 802f88e:	0cdb      	lsrs	r3, r3, #19
 802f890:	2164      	movs	r1, #100	; 0x64
 802f892:	434b      	muls	r3, r1
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_RXNE) != (SPI_SR_RXNE));
 802f894:	490d      	ldr	r1, [pc, #52]	; (802f8cc <SUBGHZSPI_Transmit+0x68>)
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f896:	9301      	str	r3, [sp, #4]
    if (count == 0U)
 802f898:	9b01      	ldr	r3, [sp, #4]
 802f89a:	b96b      	cbnz	r3, 802f8b8 <SUBGHZSPI_Transmit+0x54>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 802f89c:	2001      	movs	r0, #1
 802f89e:	6090      	str	r0, [r2, #8]

  /* Flush Rx data */
  READ_REG(SUBGHZSPI->DR);
 802f8a0:	4b0a      	ldr	r3, [pc, #40]	; (802f8cc <SUBGHZSPI_Transmit+0x68>)
 802f8a2:	68db      	ldr	r3, [r3, #12]

  return status;
}
 802f8a4:	b002      	add	sp, #8
 802f8a6:	bd10      	pop	{r4, pc}
    count--;
 802f8a8:	9801      	ldr	r0, [sp, #4]
 802f8aa:	3801      	subs	r0, #1
 802f8ac:	9001      	str	r0, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_TXE) != (SPI_SR_TXE));
 802f8ae:	68a0      	ldr	r0, [r4, #8]
 802f8b0:	0780      	lsls	r0, r0, #30
 802f8b2:	d5e3      	bpl.n	802f87c <SUBGHZSPI_Transmit+0x18>
  HAL_StatusTypeDef status = HAL_OK;
 802f8b4:	2000      	movs	r0, #0
 802f8b6:	e7e5      	b.n	802f884 <SUBGHZSPI_Transmit+0x20>
    count--;
 802f8b8:	9b01      	ldr	r3, [sp, #4]
 802f8ba:	3b01      	subs	r3, #1
 802f8bc:	9301      	str	r3, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_RXNE) != (SPI_SR_RXNE));
 802f8be:	688b      	ldr	r3, [r1, #8]
 802f8c0:	07db      	lsls	r3, r3, #31
 802f8c2:	d5e9      	bpl.n	802f898 <SUBGHZSPI_Transmit+0x34>
 802f8c4:	e7ec      	b.n	802f8a0 <SUBGHZSPI_Transmit+0x3c>
 802f8c6:	bf00      	nop
 802f8c8:	2000344c 	.word	0x2000344c
 802f8cc:	58010000 	.word	0x58010000
 802f8d0:	5801000c 	.word	0x5801000c

0802f8d4 <SUBGHZSPI_Receive>:
  * @param  pData  pointer on data to receive
  * @retval HAL status
  */
HAL_StatusTypeDef SUBGHZSPI_Receive(SUBGHZ_HandleTypeDef *hsubghz,
                                    uint8_t *pData)
{
 802f8d4:	b537      	push	{r0, r1, r2, r4, r5, lr}
 802f8d6:	4602      	mov	r2, r0
  HAL_StatusTypeDef status = HAL_OK;
  __IO uint32_t count;

  /* Handle Tx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f8d8:	4818      	ldr	r0, [pc, #96]	; (802f93c <SUBGHZSPI_Receive+0x68>)
 802f8da:	6804      	ldr	r4, [r0, #0]
 802f8dc:	231c      	movs	r3, #28
 802f8de:	4363      	muls	r3, r4
 802f8e0:	0cdb      	lsrs	r3, r3, #19
 802f8e2:	2464      	movs	r4, #100	; 0x64
 802f8e4:	4363      	muls	r3, r4
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_TXE) != (SPI_SR_TXE));
 802f8e6:	4c16      	ldr	r4, [pc, #88]	; (802f940 <SUBGHZSPI_Receive+0x6c>)
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f8e8:	9301      	str	r3, [sp, #4]
 802f8ea:	4603      	mov	r3, r0
    if (count == 0U)
 802f8ec:	9801      	ldr	r0, [sp, #4]
 802f8ee:	b9a8      	cbnz	r0, 802f91c <SUBGHZSPI_Receive+0x48>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 802f8f0:	2001      	movs	r0, #1
 802f8f2:	6090      	str	r0, [r2, #8]

  /* Transmit Data*/
#if defined (__GNUC__)
  __IO uint8_t *spidr = ((__IO uint8_t *)&SUBGHZSPI->DR);
  *spidr = SUBGHZ_DUMMY_DATA;
 802f8f4:	4c13      	ldr	r4, [pc, #76]	; (802f944 <SUBGHZSPI_Receive+0x70>)
 802f8f6:	25ff      	movs	r5, #255	; 0xff
 802f8f8:	7025      	strb	r5, [r4, #0]
  *((__IO uint8_t *)&SUBGHZSPI->DR) = SUBGHZ_DUMMY_DATA;
#endif /* __GNUC__ */

  /* Handle Rx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f8fa:	681c      	ldr	r4, [r3, #0]
 802f8fc:	231c      	movs	r3, #28
 802f8fe:	4363      	muls	r3, r4
 802f900:	0cdb      	lsrs	r3, r3, #19
 802f902:	2464      	movs	r4, #100	; 0x64
 802f904:	4363      	muls	r3, r4
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_RXNE) != (SPI_SR_RXNE));
 802f906:	4c0e      	ldr	r4, [pc, #56]	; (802f940 <SUBGHZSPI_Receive+0x6c>)
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f908:	9301      	str	r3, [sp, #4]
    if (count == 0U)
 802f90a:	9b01      	ldr	r3, [sp, #4]
 802f90c:	b973      	cbnz	r3, 802f92c <SUBGHZSPI_Receive+0x58>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 802f90e:	2001      	movs	r0, #1
 802f910:	6090      	str	r0, [r2, #8]

  /* Retrieve pData */
  *pData = (uint8_t)(READ_REG(SUBGHZSPI->DR));
 802f912:	4b0b      	ldr	r3, [pc, #44]	; (802f940 <SUBGHZSPI_Receive+0x6c>)
 802f914:	68db      	ldr	r3, [r3, #12]
 802f916:	700b      	strb	r3, [r1, #0]

  return status;
}
 802f918:	b003      	add	sp, #12
 802f91a:	bd30      	pop	{r4, r5, pc}
    count--;
 802f91c:	9801      	ldr	r0, [sp, #4]
 802f91e:	3801      	subs	r0, #1
 802f920:	9001      	str	r0, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_TXE) != (SPI_SR_TXE));
 802f922:	68a0      	ldr	r0, [r4, #8]
 802f924:	0780      	lsls	r0, r0, #30
 802f926:	d5e1      	bpl.n	802f8ec <SUBGHZSPI_Receive+0x18>
  HAL_StatusTypeDef status = HAL_OK;
 802f928:	2000      	movs	r0, #0
 802f92a:	e7e3      	b.n	802f8f4 <SUBGHZSPI_Receive+0x20>
    count--;
 802f92c:	9b01      	ldr	r3, [sp, #4]
 802f92e:	3b01      	subs	r3, #1
 802f930:	9301      	str	r3, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_RXNE) != (SPI_SR_RXNE));
 802f932:	68a3      	ldr	r3, [r4, #8]
 802f934:	07db      	lsls	r3, r3, #31
 802f936:	d5e8      	bpl.n	802f90a <SUBGHZSPI_Receive+0x36>
 802f938:	e7eb      	b.n	802f912 <SUBGHZSPI_Receive+0x3e>
 802f93a:	bf00      	nop
 802f93c:	2000344c 	.word	0x2000344c
 802f940:	58010000 	.word	0x58010000
 802f944:	5801000c 	.word	0x5801000c

0802f948 <SUBGHZ_WaitOnBusy>:
  HAL_StatusTypeDef status;
  __IO uint32_t count;
  uint32_t mask;

  status = HAL_OK;
  count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_RFBUSY_LOOP_TIME;
 802f948:	4b0f      	ldr	r3, [pc, #60]	; (802f988 <SUBGHZ_WaitOnBusy+0x40>)
{
 802f94a:	b513      	push	{r0, r1, r4, lr}
  count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_RFBUSY_LOOP_TIME;
 802f94c:	681a      	ldr	r2, [r3, #0]
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYMS) == (PWR_SR2_RFBUSYMS)) ? 1UL : 0UL);
 802f94e:	4c0f      	ldr	r4, [pc, #60]	; (802f98c <SUBGHZ_WaitOnBusy+0x44>)
 802f950:	2318      	movs	r3, #24
 802f952:	4353      	muls	r3, r2
 802f954:	0d1b      	lsrs	r3, r3, #20
 802f956:	2264      	movs	r2, #100	; 0x64
 802f958:	4353      	muls	r3, r2
{
 802f95a:	4601      	mov	r1, r0
  count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_RFBUSY_LOOP_TIME;
 802f95c:	9301      	str	r3, [sp, #4]
 802f95e:	6962      	ldr	r2, [r4, #20]
  /* Wait until Busy signal is set */
  do
  {
    mask = LL_PWR_IsActiveFlag_RFBUSYMS();

    if (count == 0U)
 802f960:	9b01      	ldr	r3, [sp, #4]
 802f962:	f002 0204 	and.w	r2, r2, #4
 802f966:	b923      	cbnz	r3, 802f972 <SUBGHZ_WaitOnBusy+0x2a>
    {
      status  = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_RF_BUSY;
 802f968:	2302      	movs	r3, #2
 802f96a:	608b      	str	r3, [r1, #8]
      status  = HAL_ERROR;
 802f96c:	2001      	movs	r0, #1
    }
    count--;
  } while ((LL_PWR_IsActiveFlag_RFBUSYS()& mask) == 1UL);

  return status;
}
 802f96e:	b002      	add	sp, #8
 802f970:	bd10      	pop	{r4, pc}
    count--;
 802f972:	9b01      	ldr	r3, [sp, #4]
 802f974:	3b01      	subs	r3, #1
 802f976:	9301      	str	r3, [sp, #4]
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYS) == (PWR_SR2_RFBUSYS)) ? 1UL : 0UL);
 802f978:	6960      	ldr	r0, [r4, #20]
 802f97a:	f010 0002 	ands.w	r0, r0, #2
 802f97e:	d0f6      	beq.n	802f96e <SUBGHZ_WaitOnBusy+0x26>
  } while ((LL_PWR_IsActiveFlag_RFBUSYS()& mask) == 1UL);
 802f980:	2a00      	cmp	r2, #0
 802f982:	d1ec      	bne.n	802f95e <SUBGHZ_WaitOnBusy+0x16>
  status = HAL_OK;
 802f984:	4610      	mov	r0, r2
 802f986:	e7f2      	b.n	802f96e <SUBGHZ_WaitOnBusy+0x26>
 802f988:	2000344c 	.word	0x2000344c
 802f98c:	58000400 	.word	0x58000400

0802f990 <SUBGHZ_CheckDeviceReady>:
{
 802f990:	b507      	push	{r0, r1, r2, lr}
  if (hsubghz->DeepSleep == SUBGHZ_DEEP_SLEEP_ENABLE)
 802f992:	7903      	ldrb	r3, [r0, #4]
 802f994:	2b01      	cmp	r3, #1
 802f996:	d10f      	bne.n	802f9b8 <SUBGHZ_CheckDeviceReady+0x28>
    count  = SUBGHZ_NSS_LOOP_TIME;
 802f998:	4b0a      	ldr	r3, [pc, #40]	; (802f9c4 <SUBGHZ_CheckDeviceReady+0x34>)
 802f99a:	681a      	ldr	r2, [r3, #0]
 802f99c:	2318      	movs	r3, #24
 802f99e:	4353      	muls	r3, r2
 802f9a0:	0c1b      	lsrs	r3, r3, #16
 802f9a2:	9301      	str	r3, [sp, #4]
    LL_PWR_SelectSUBGHZSPI_NSS();
 802f9a4:	f7ff fef2 	bl	802f78c <LL_PWR_SelectSUBGHZSPI_NSS>
      count--;
 802f9a8:	9b01      	ldr	r3, [sp, #4]
 802f9aa:	3b01      	subs	r3, #1
 802f9ac:	9301      	str	r3, [sp, #4]
    } while (count != 0UL);
 802f9ae:	9b01      	ldr	r3, [sp, #4]
 802f9b0:	2b00      	cmp	r3, #0
 802f9b2:	d1f9      	bne.n	802f9a8 <SUBGHZ_CheckDeviceReady+0x18>
    LL_PWR_UnselectSUBGHZSPI_NSS();
 802f9b4:	f7ff fee0 	bl	802f778 <LL_PWR_UnselectSUBGHZSPI_NSS>
}
 802f9b8:	b003      	add	sp, #12
 802f9ba:	f85d eb04 	ldr.w	lr, [sp], #4
  return (SUBGHZ_WaitOnBusy(hsubghz));
 802f9be:	f7ff bfc3 	b.w	802f948 <SUBGHZ_WaitOnBusy>
 802f9c2:	bf00      	nop
 802f9c4:	2000344c 	.word	0x2000344c

0802f9c8 <HAL_SUBGHZ_WriteRegisters>:
{
 802f9c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802f9ca:	461e      	mov	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802f9cc:	7983      	ldrb	r3, [r0, #6]
 802f9ce:	2b01      	cmp	r3, #1
{
 802f9d0:	4615      	mov	r5, r2
 802f9d2:	4604      	mov	r4, r0
 802f9d4:	460f      	mov	r7, r1
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802f9d6:	b2da      	uxtb	r2, r3
 802f9d8:	d12d      	bne.n	802fa36 <HAL_SUBGHZ_WriteRegisters+0x6e>
    __HAL_LOCK(hsubghz);
 802f9da:	7943      	ldrb	r3, [r0, #5]
 802f9dc:	2b01      	cmp	r3, #1
 802f9de:	d02a      	beq.n	802fa36 <HAL_SUBGHZ_WriteRegisters+0x6e>
    hsubghz->State = HAL_SUBGHZ_STATE_BUSY;
 802f9e0:	2302      	movs	r3, #2
    __HAL_LOCK(hsubghz);
 802f9e2:	7142      	strb	r2, [r0, #5]
    hsubghz->State = HAL_SUBGHZ_STATE_BUSY;
 802f9e4:	7183      	strb	r3, [r0, #6]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 802f9e6:	f7ff ffd3 	bl	802f990 <SUBGHZ_CheckDeviceReady>
    LL_PWR_SelectSUBGHZSPI_NSS();
 802f9ea:	f7ff fecf 	bl	802f78c <LL_PWR_SelectSUBGHZSPI_NSS>
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_WRITE_REGISTER);
 802f9ee:	210d      	movs	r1, #13
 802f9f0:	4620      	mov	r0, r4
 802f9f2:	f7ff ff37 	bl	802f864 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)((Address & 0xFF00U) >> 8U));
 802f9f6:	0a39      	lsrs	r1, r7, #8
 802f9f8:	4620      	mov	r0, r4
 802f9fa:	f7ff ff33 	bl	802f864 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)(Address & 0x00FFU));
 802f9fe:	b2f9      	uxtb	r1, r7
 802fa00:	4620      	mov	r0, r4
 802fa02:	f7ff ff2f 	bl	802f864 <SUBGHZSPI_Transmit>
HAL_StatusTypeDef HAL_SUBGHZ_WriteRegisters(SUBGHZ_HandleTypeDef *hsubghz,
 802fa06:	442e      	add	r6, r5
    for (uint16_t i = 0U; i < Size; i++)
 802fa08:	42b5      	cmp	r5, r6
 802fa0a:	d10e      	bne.n	802fa2a <HAL_SUBGHZ_WriteRegisters+0x62>
    LL_PWR_UnselectSUBGHZSPI_NSS();
 802fa0c:	f7ff feb4 	bl	802f778 <LL_PWR_UnselectSUBGHZSPI_NSS>
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 802fa10:	4620      	mov	r0, r4
 802fa12:	f7ff ff99 	bl	802f948 <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 802fa16:	68a0      	ldr	r0, [r4, #8]
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fa18:	2301      	movs	r3, #1
      status = HAL_ERROR;
 802fa1a:	3800      	subs	r0, #0
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fa1c:	71a3      	strb	r3, [r4, #6]
    __HAL_UNLOCK(hsubghz);
 802fa1e:	f04f 0300 	mov.w	r3, #0
      status = HAL_ERROR;
 802fa22:	bf18      	it	ne
 802fa24:	2001      	movne	r0, #1
    __HAL_UNLOCK(hsubghz);
 802fa26:	7163      	strb	r3, [r4, #5]
}
 802fa28:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void)SUBGHZSPI_Transmit(hsubghz, pBuffer[i]);
 802fa2a:	f815 1b01 	ldrb.w	r1, [r5], #1
 802fa2e:	4620      	mov	r0, r4
 802fa30:	f7ff ff18 	bl	802f864 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 802fa34:	e7e8      	b.n	802fa08 <HAL_SUBGHZ_WriteRegisters+0x40>
    return HAL_BUSY;
 802fa36:	2002      	movs	r0, #2
 802fa38:	e7f6      	b.n	802fa28 <HAL_SUBGHZ_WriteRegisters+0x60>

0802fa3a <HAL_SUBGHZ_ReadRegisters>:
{
 802fa3a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802fa3c:	461e      	mov	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fa3e:	7983      	ldrb	r3, [r0, #6]
 802fa40:	2b01      	cmp	r3, #1
{
 802fa42:	4615      	mov	r5, r2
 802fa44:	4604      	mov	r4, r0
 802fa46:	460f      	mov	r7, r1
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fa48:	b2da      	uxtb	r2, r3
 802fa4a:	d12f      	bne.n	802faac <HAL_SUBGHZ_ReadRegisters+0x72>
    __HAL_LOCK(hsubghz);
 802fa4c:	7943      	ldrb	r3, [r0, #5]
 802fa4e:	2b01      	cmp	r3, #1
 802fa50:	d02c      	beq.n	802faac <HAL_SUBGHZ_ReadRegisters+0x72>
 802fa52:	7142      	strb	r2, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 802fa54:	f7ff ff9c 	bl	802f990 <SUBGHZ_CheckDeviceReady>
    LL_PWR_SelectSUBGHZSPI_NSS();
 802fa58:	f7ff fe98 	bl	802f78c <LL_PWR_SelectSUBGHZSPI_NSS>
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_READ_REGISTER);
 802fa5c:	211d      	movs	r1, #29
 802fa5e:	4620      	mov	r0, r4
 802fa60:	f7ff ff00 	bl	802f864 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)((Address & 0xFF00U) >> 8U));
 802fa64:	0a39      	lsrs	r1, r7, #8
 802fa66:	4620      	mov	r0, r4
 802fa68:	f7ff fefc 	bl	802f864 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)(Address & 0x00FFU));
 802fa6c:	b2f9      	uxtb	r1, r7
 802fa6e:	4620      	mov	r0, r4
 802fa70:	f7ff fef8 	bl	802f864 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, 0U);
 802fa74:	2100      	movs	r1, #0
 802fa76:	4620      	mov	r0, r4
 802fa78:	f7ff fef4 	bl	802f864 <SUBGHZSPI_Transmit>
HAL_StatusTypeDef HAL_SUBGHZ_ReadRegisters(SUBGHZ_HandleTypeDef *hsubghz,
 802fa7c:	442e      	add	r6, r5
    for (uint16_t i = 0U; i < Size; i++)
 802fa7e:	42b5      	cmp	r5, r6
 802fa80:	d10e      	bne.n	802faa0 <HAL_SUBGHZ_ReadRegisters+0x66>
    LL_PWR_UnselectSUBGHZSPI_NSS();
 802fa82:	f7ff fe79 	bl	802f778 <LL_PWR_UnselectSUBGHZSPI_NSS>
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 802fa86:	4620      	mov	r0, r4
 802fa88:	f7ff ff5e 	bl	802f948 <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 802fa8c:	68a0      	ldr	r0, [r4, #8]
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fa8e:	2301      	movs	r3, #1
      status = HAL_ERROR;
 802fa90:	3800      	subs	r0, #0
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fa92:	71a3      	strb	r3, [r4, #6]
    __HAL_UNLOCK(hsubghz);
 802fa94:	f04f 0300 	mov.w	r3, #0
      status = HAL_ERROR;
 802fa98:	bf18      	it	ne
 802fa9a:	2001      	movne	r0, #1
    __HAL_UNLOCK(hsubghz);
 802fa9c:	7163      	strb	r3, [r4, #5]
}
 802fa9e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void)SUBGHZSPI_Receive(hsubghz, (pData));
 802faa0:	4629      	mov	r1, r5
 802faa2:	4620      	mov	r0, r4
 802faa4:	f7ff ff16 	bl	802f8d4 <SUBGHZSPI_Receive>
      pData++;
 802faa8:	3501      	adds	r5, #1
    for (uint16_t i = 0U; i < Size; i++)
 802faaa:	e7e8      	b.n	802fa7e <HAL_SUBGHZ_ReadRegisters+0x44>
    return HAL_BUSY;
 802faac:	2002      	movs	r0, #2
 802faae:	e7f6      	b.n	802fa9e <HAL_SUBGHZ_ReadRegisters+0x64>

0802fab0 <HAL_SUBGHZ_ExecSetCmd>:
{
 802fab0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802fab2:	461f      	mov	r7, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fab4:	7983      	ldrb	r3, [r0, #6]
 802fab6:	2b01      	cmp	r3, #1
{
 802fab8:	4615      	mov	r5, r2
 802faba:	4604      	mov	r4, r0
 802fabc:	460e      	mov	r6, r1
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fabe:	b2da      	uxtb	r2, r3
 802fac0:	d12c      	bne.n	802fb1c <HAL_SUBGHZ_ExecSetCmd+0x6c>
    __HAL_LOCK(hsubghz);
 802fac2:	7943      	ldrb	r3, [r0, #5]
 802fac4:	2b01      	cmp	r3, #1
 802fac6:	d029      	beq.n	802fb1c <HAL_SUBGHZ_ExecSetCmd+0x6c>
 802fac8:	7142      	strb	r2, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 802faca:	f7ff ff61 	bl	802f990 <SUBGHZ_CheckDeviceReady>
    if ((Command == RADIO_SET_SLEEP) || (Command == RADIO_SET_RXDUTYCYCLE))
 802face:	f006 03ef 	and.w	r3, r6, #239	; 0xef
 802fad2:	f1a3 0284 	sub.w	r2, r3, #132	; 0x84
 802fad6:	4253      	negs	r3, r2
 802fad8:	4153      	adcs	r3, r2
 802fada:	7123      	strb	r3, [r4, #4]
    LL_PWR_SelectSUBGHZSPI_NSS();
 802fadc:	f7ff fe56 	bl	802f78c <LL_PWR_SelectSUBGHZSPI_NSS>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)Command);
 802fae0:	4631      	mov	r1, r6
 802fae2:	4620      	mov	r0, r4
 802fae4:	f7ff febe 	bl	802f864 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 802fae8:	442f      	add	r7, r5
 802faea:	42af      	cmp	r7, r5
 802faec:	d110      	bne.n	802fb10 <HAL_SUBGHZ_ExecSetCmd+0x60>
    LL_PWR_UnselectSUBGHZSPI_NSS();
 802faee:	f7ff fe43 	bl	802f778 <LL_PWR_UnselectSUBGHZSPI_NSS>
    if (Command != RADIO_SET_SLEEP)
 802faf2:	2e84      	cmp	r6, #132	; 0x84
 802faf4:	d002      	beq.n	802fafc <HAL_SUBGHZ_ExecSetCmd+0x4c>
      (void)SUBGHZ_WaitOnBusy(hsubghz);
 802faf6:	4620      	mov	r0, r4
 802faf8:	f7ff ff26 	bl	802f948 <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 802fafc:	68a0      	ldr	r0, [r4, #8]
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fafe:	2301      	movs	r3, #1
      status = HAL_ERROR;
 802fb00:	3800      	subs	r0, #0
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fb02:	71a3      	strb	r3, [r4, #6]
    __HAL_UNLOCK(hsubghz);
 802fb04:	f04f 0300 	mov.w	r3, #0
      status = HAL_ERROR;
 802fb08:	bf18      	it	ne
 802fb0a:	2001      	movne	r0, #1
    __HAL_UNLOCK(hsubghz);
 802fb0c:	7163      	strb	r3, [r4, #5]
}
 802fb0e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void)SUBGHZSPI_Transmit(hsubghz, pBuffer[i]);
 802fb10:	f815 1b01 	ldrb.w	r1, [r5], #1
 802fb14:	4620      	mov	r0, r4
 802fb16:	f7ff fea5 	bl	802f864 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 802fb1a:	e7e6      	b.n	802faea <HAL_SUBGHZ_ExecSetCmd+0x3a>
    return HAL_BUSY;
 802fb1c:	2002      	movs	r0, #2
 802fb1e:	e7f6      	b.n	802fb0e <HAL_SUBGHZ_ExecSetCmd+0x5e>

0802fb20 <HAL_SUBGHZ_WriteBuffer>:
{
 802fb20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802fb22:	461e      	mov	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fb24:	7983      	ldrb	r3, [r0, #6]
 802fb26:	2b01      	cmp	r3, #1
{
 802fb28:	4615      	mov	r5, r2
 802fb2a:	4604      	mov	r4, r0
 802fb2c:	460f      	mov	r7, r1
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fb2e:	b2da      	uxtb	r2, r3
 802fb30:	d127      	bne.n	802fb82 <HAL_SUBGHZ_WriteBuffer+0x62>
    __HAL_LOCK(hsubghz);
 802fb32:	7943      	ldrb	r3, [r0, #5]
 802fb34:	2b01      	cmp	r3, #1
 802fb36:	d024      	beq.n	802fb82 <HAL_SUBGHZ_WriteBuffer+0x62>
 802fb38:	7142      	strb	r2, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 802fb3a:	f7ff ff29 	bl	802f990 <SUBGHZ_CheckDeviceReady>
    LL_PWR_SelectSUBGHZSPI_NSS();
 802fb3e:	f7ff fe25 	bl	802f78c <LL_PWR_SelectSUBGHZSPI_NSS>
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_WRITE_BUFFER);
 802fb42:	210e      	movs	r1, #14
 802fb44:	4620      	mov	r0, r4
 802fb46:	f7ff fe8d 	bl	802f864 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, Offset);
 802fb4a:	4639      	mov	r1, r7
 802fb4c:	4620      	mov	r0, r4
 802fb4e:	f7ff fe89 	bl	802f864 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 802fb52:	442e      	add	r6, r5
 802fb54:	42b5      	cmp	r5, r6
 802fb56:	d10e      	bne.n	802fb76 <HAL_SUBGHZ_WriteBuffer+0x56>
    LL_PWR_UnselectSUBGHZSPI_NSS();
 802fb58:	f7ff fe0e 	bl	802f778 <LL_PWR_UnselectSUBGHZSPI_NSS>
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 802fb5c:	4620      	mov	r0, r4
 802fb5e:	f7ff fef3 	bl	802f948 <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 802fb62:	68a0      	ldr	r0, [r4, #8]
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fb64:	2301      	movs	r3, #1
      status = HAL_ERROR;
 802fb66:	3800      	subs	r0, #0
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fb68:	71a3      	strb	r3, [r4, #6]
    __HAL_UNLOCK(hsubghz);
 802fb6a:	f04f 0300 	mov.w	r3, #0
      status = HAL_ERROR;
 802fb6e:	bf18      	it	ne
 802fb70:	2001      	movne	r0, #1
    __HAL_UNLOCK(hsubghz);
 802fb72:	7163      	strb	r3, [r4, #5]
}
 802fb74:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void)SUBGHZSPI_Transmit(hsubghz, pBuffer[i]);
 802fb76:	f815 1b01 	ldrb.w	r1, [r5], #1
 802fb7a:	4620      	mov	r0, r4
 802fb7c:	f7ff fe72 	bl	802f864 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 802fb80:	e7e8      	b.n	802fb54 <HAL_SUBGHZ_WriteBuffer+0x34>
    return HAL_BUSY;
 802fb82:	2002      	movs	r0, #2
 802fb84:	e7f6      	b.n	802fb74 <HAL_SUBGHZ_WriteBuffer+0x54>

0802fb86 <HAL_SUBGHZ_ReadBuffer>:
{
 802fb86:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802fb88:	461e      	mov	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fb8a:	7983      	ldrb	r3, [r0, #6]
 802fb8c:	2b01      	cmp	r3, #1
{
 802fb8e:	4615      	mov	r5, r2
 802fb90:	4604      	mov	r4, r0
 802fb92:	460f      	mov	r7, r1
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fb94:	b2da      	uxtb	r2, r3
 802fb96:	d12b      	bne.n	802fbf0 <HAL_SUBGHZ_ReadBuffer+0x6a>
    __HAL_LOCK(hsubghz);
 802fb98:	7943      	ldrb	r3, [r0, #5]
 802fb9a:	2b01      	cmp	r3, #1
 802fb9c:	d028      	beq.n	802fbf0 <HAL_SUBGHZ_ReadBuffer+0x6a>
 802fb9e:	7142      	strb	r2, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 802fba0:	f7ff fef6 	bl	802f990 <SUBGHZ_CheckDeviceReady>
    LL_PWR_SelectSUBGHZSPI_NSS();
 802fba4:	f7ff fdf2 	bl	802f78c <LL_PWR_SelectSUBGHZSPI_NSS>
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_READ_BUFFER);
 802fba8:	211e      	movs	r1, #30
 802fbaa:	4620      	mov	r0, r4
 802fbac:	f7ff fe5a 	bl	802f864 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, Offset);
 802fbb0:	4639      	mov	r1, r7
 802fbb2:	4620      	mov	r0, r4
 802fbb4:	f7ff fe56 	bl	802f864 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, 0x00U);
 802fbb8:	2100      	movs	r1, #0
 802fbba:	4620      	mov	r0, r4
 802fbbc:	f7ff fe52 	bl	802f864 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 802fbc0:	442e      	add	r6, r5
 802fbc2:	42b5      	cmp	r5, r6
 802fbc4:	d10e      	bne.n	802fbe4 <HAL_SUBGHZ_ReadBuffer+0x5e>
    LL_PWR_UnselectSUBGHZSPI_NSS();
 802fbc6:	f7ff fdd7 	bl	802f778 <LL_PWR_UnselectSUBGHZSPI_NSS>
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 802fbca:	4620      	mov	r0, r4
 802fbcc:	f7ff febc 	bl	802f948 <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 802fbd0:	68a0      	ldr	r0, [r4, #8]
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fbd2:	2301      	movs	r3, #1
      status = HAL_ERROR;
 802fbd4:	3800      	subs	r0, #0
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fbd6:	71a3      	strb	r3, [r4, #6]
    __HAL_UNLOCK(hsubghz);
 802fbd8:	f04f 0300 	mov.w	r3, #0
      status = HAL_ERROR;
 802fbdc:	bf18      	it	ne
 802fbde:	2001      	movne	r0, #1
    __HAL_UNLOCK(hsubghz);
 802fbe0:	7163      	strb	r3, [r4, #5]
}
 802fbe2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void)SUBGHZSPI_Receive(hsubghz, (pData));
 802fbe4:	4629      	mov	r1, r5
 802fbe6:	4620      	mov	r0, r4
 802fbe8:	f7ff fe74 	bl	802f8d4 <SUBGHZSPI_Receive>
      pData++;
 802fbec:	3501      	adds	r5, #1
    for (uint16_t i = 0U; i < Size; i++)
 802fbee:	e7e8      	b.n	802fbc2 <HAL_SUBGHZ_ReadBuffer+0x3c>
    return HAL_BUSY;
 802fbf0:	2002      	movs	r0, #2
 802fbf2:	e7f6      	b.n	802fbe2 <HAL_SUBGHZ_ReadBuffer+0x5c>

0802fbf4 <HAL_SUBGHZ_ExecGetCmd>:
{
 802fbf4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802fbf6:	461e      	mov	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fbf8:	7983      	ldrb	r3, [r0, #6]
 802fbfa:	2b01      	cmp	r3, #1
{
 802fbfc:	4615      	mov	r5, r2
 802fbfe:	4604      	mov	r4, r0
 802fc00:	460f      	mov	r7, r1
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fc02:	b2da      	uxtb	r2, r3
 802fc04:	d127      	bne.n	802fc56 <HAL_SUBGHZ_ExecGetCmd+0x62>
    __HAL_LOCK(hsubghz);
 802fc06:	7943      	ldrb	r3, [r0, #5]
 802fc08:	2b01      	cmp	r3, #1
 802fc0a:	d024      	beq.n	802fc56 <HAL_SUBGHZ_ExecGetCmd+0x62>
 802fc0c:	7142      	strb	r2, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 802fc0e:	f7ff febf 	bl	802f990 <SUBGHZ_CheckDeviceReady>
    LL_PWR_SelectSUBGHZSPI_NSS();
 802fc12:	f7ff fdbb 	bl	802f78c <LL_PWR_SelectSUBGHZSPI_NSS>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)Command);
 802fc16:	4639      	mov	r1, r7
 802fc18:	4620      	mov	r0, r4
 802fc1a:	f7ff fe23 	bl	802f864 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, 0x00U);
 802fc1e:	2100      	movs	r1, #0
 802fc20:	4620      	mov	r0, r4
 802fc22:	f7ff fe1f 	bl	802f864 <SUBGHZSPI_Transmit>
HAL_StatusTypeDef HAL_SUBGHZ_ReadRegisters(SUBGHZ_HandleTypeDef *hsubghz,
 802fc26:	442e      	add	r6, r5
    for (uint16_t i = 0U; i < Size; i++)
 802fc28:	42b5      	cmp	r5, r6
 802fc2a:	d10e      	bne.n	802fc4a <HAL_SUBGHZ_ExecGetCmd+0x56>
    LL_PWR_UnselectSUBGHZSPI_NSS();
 802fc2c:	f7ff fda4 	bl	802f778 <LL_PWR_UnselectSUBGHZSPI_NSS>
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 802fc30:	4620      	mov	r0, r4
 802fc32:	f7ff fe89 	bl	802f948 <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 802fc36:	68a0      	ldr	r0, [r4, #8]
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fc38:	2301      	movs	r3, #1
      status = HAL_ERROR;
 802fc3a:	3800      	subs	r0, #0
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fc3c:	71a3      	strb	r3, [r4, #6]
    __HAL_UNLOCK(hsubghz);
 802fc3e:	f04f 0300 	mov.w	r3, #0
      status = HAL_ERROR;
 802fc42:	bf18      	it	ne
 802fc44:	2001      	movne	r0, #1
    __HAL_UNLOCK(hsubghz);
 802fc46:	7163      	strb	r3, [r4, #5]
}
 802fc48:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void)SUBGHZSPI_Receive(hsubghz, (pData));
 802fc4a:	4629      	mov	r1, r5
 802fc4c:	4620      	mov	r0, r4
 802fc4e:	f7ff fe41 	bl	802f8d4 <SUBGHZSPI_Receive>
      pData++;
 802fc52:	3501      	adds	r5, #1
    for (uint16_t i = 0U; i < Size; i++)
 802fc54:	e7e8      	b.n	802fc28 <HAL_SUBGHZ_ExecGetCmd+0x34>
    return HAL_BUSY;
 802fc56:	2002      	movs	r0, #2
 802fc58:	e7f6      	b.n	802fc48 <HAL_SUBGHZ_ExecGetCmd+0x54>

0802fc5a <HAL_SUBGHZ_IRQHandler>:
{
 802fc5a:	b537      	push	{r0, r1, r2, r4, r5, lr}
  uint8_t tmpisr[2] = {0};
 802fc5c:	2300      	movs	r3, #0
 802fc5e:	f8ad 3004 	strh.w	r3, [sp, #4]
  (void)HAL_SUBGHZ_ExecGetCmd(hsubghz, RADIO_GET_IRQSTATUS, tmpisr, 2);
 802fc62:	aa01      	add	r2, sp, #4
 802fc64:	2302      	movs	r3, #2
 802fc66:	2112      	movs	r1, #18
{
 802fc68:	4604      	mov	r4, r0
  (void)HAL_SUBGHZ_ExecGetCmd(hsubghz, RADIO_GET_IRQSTATUS, tmpisr, 2);
 802fc6a:	f7ff ffc3 	bl	802fbf4 <HAL_SUBGHZ_ExecGetCmd>
  itsource = (itsource << 8) | tmpisr[1];
 802fc6e:	f89d 3005 	ldrb.w	r3, [sp, #5]
 802fc72:	f89d 5004 	ldrb.w	r5, [sp, #4]
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_TX_CPLT) != RESET)
 802fc76:	07da      	lsls	r2, r3, #31
  itsource = (itsource << 8) | tmpisr[1];
 802fc78:	ea43 2505 	orr.w	r5, r3, r5, lsl #8
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_TX_CPLT) != RESET)
 802fc7c:	d502      	bpl.n	802fc84 <HAL_SUBGHZ_IRQHandler+0x2a>
    HAL_SUBGHZ_TxCpltCallback(hsubghz);
 802fc7e:	4620      	mov	r0, r4
 802fc80:	f00a fea4 	bl	803a9cc <HAL_SUBGHZ_TxCpltCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_RX_CPLT) != RESET)
 802fc84:	07ab      	lsls	r3, r5, #30
 802fc86:	d502      	bpl.n	802fc8e <HAL_SUBGHZ_IRQHandler+0x34>
    HAL_SUBGHZ_RxCpltCallback(hsubghz);
 802fc88:	4620      	mov	r0, r4
 802fc8a:	f00a fea5 	bl	803a9d8 <HAL_SUBGHZ_RxCpltCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_PREAMBLE_DETECTED) != RESET)
 802fc8e:	0768      	lsls	r0, r5, #29
 802fc90:	d502      	bpl.n	802fc98 <HAL_SUBGHZ_IRQHandler+0x3e>
    HAL_SUBGHZ_PreambleDetectedCallback(hsubghz);
 802fc92:	4620      	mov	r0, r4
 802fc94:	f00a feca 	bl	803aa2c <HAL_SUBGHZ_PreambleDetectedCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_SYNCWORD_VALID) != RESET)
 802fc98:	0729      	lsls	r1, r5, #28
 802fc9a:	d502      	bpl.n	802fca2 <HAL_SUBGHZ_IRQHandler+0x48>
    HAL_SUBGHZ_SyncWordValidCallback(hsubghz);
 802fc9c:	4620      	mov	r0, r4
 802fc9e:	f00a fecb 	bl	803aa38 <HAL_SUBGHZ_SyncWordValidCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_HEADER_VALID) != RESET)
 802fca2:	06ea      	lsls	r2, r5, #27
 802fca4:	d502      	bpl.n	802fcac <HAL_SUBGHZ_IRQHandler+0x52>
    HAL_SUBGHZ_HeaderValidCallback(hsubghz);
 802fca6:	4620      	mov	r0, r4
 802fca8:	f00a fecc 	bl	803aa44 <HAL_SUBGHZ_HeaderValidCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_HEADER_ERROR) != RESET)
 802fcac:	06ab      	lsls	r3, r5, #26
 802fcae:	d502      	bpl.n	802fcb6 <HAL_SUBGHZ_IRQHandler+0x5c>
    HAL_SUBGHZ_HeaderErrorCallback(hsubghz);
 802fcb0:	4620      	mov	r0, r4
 802fcb2:	f00a feb5 	bl	803aa20 <HAL_SUBGHZ_HeaderErrorCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_CRC_ERROR) != RESET)
 802fcb6:	0668      	lsls	r0, r5, #25
 802fcb8:	d502      	bpl.n	802fcc0 <HAL_SUBGHZ_IRQHandler+0x66>
    HAL_SUBGHZ_CRCErrorCallback(hsubghz);
 802fcba:	4620      	mov	r0, r4
 802fcbc:	f00a fe92 	bl	803a9e4 <HAL_SUBGHZ_CRCErrorCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_CAD_DONE) != RESET)
 802fcc0:	0629      	lsls	r1, r5, #24
 802fcc2:	d507      	bpl.n	802fcd4 <HAL_SUBGHZ_IRQHandler+0x7a>
    if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_CAD_ACTIVITY_DETECTED) != RESET)
 802fcc4:	05ea      	lsls	r2, r5, #23
 802fcc6:	f3c5 2100 	ubfx	r1, r5, #8, #1
      HAL_SUBGHZ_CADStatusCallback(hsubghz, HAL_SUBGHZ_CAD_CLEAR);
 802fcca:	4620      	mov	r0, r4
      HAL_SUBGHZ_CADStatusCallback(hsubghz, HAL_SUBGHZ_CAD_DETECTED);
 802fccc:	bf48      	it	mi
 802fcce:	2101      	movmi	r1, #1
      HAL_SUBGHZ_CADStatusCallback(hsubghz, HAL_SUBGHZ_CAD_CLEAR);
 802fcd0:	f00a fe8e 	bl	803a9f0 <HAL_SUBGHZ_CADStatusCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_RX_TX_TIMEOUT) != RESET)
 802fcd4:	05ab      	lsls	r3, r5, #22
 802fcd6:	d502      	bpl.n	802fcde <HAL_SUBGHZ_IRQHandler+0x84>
    HAL_SUBGHZ_RxTxTimeoutCallback(hsubghz);
 802fcd8:	4620      	mov	r0, r4
 802fcda:	f00a fe99 	bl	803aa10 <HAL_SUBGHZ_RxTxTimeoutCallback>
  (void)HAL_SUBGHZ_ExecSetCmd(hsubghz, RADIO_CLR_IRQSTATUS, tmpisr, 2);
 802fcde:	2302      	movs	r3, #2
 802fce0:	aa01      	add	r2, sp, #4
 802fce2:	4619      	mov	r1, r3
 802fce4:	4620      	mov	r0, r4
 802fce6:	f7ff fee3 	bl	802fab0 <HAL_SUBGHZ_ExecSetCmd>
}
 802fcea:	b003      	add	sp, #12
 802fcec:	bd30      	pop	{r4, r5, pc}

0802fcee <UART_EndTxTransfer>:
  * @retval None
  */
static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable TXEIE, TCIE, TXFT interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE | USART_CR1_TCIE));
 802fcee:	6802      	ldr	r2, [r0, #0]
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802fcf0:	e852 3f00 	ldrex	r3, [r2]
 802fcf4:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802fcf8:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 802fcfc:	6802      	ldr	r2, [r0, #0]
 802fcfe:	2900      	cmp	r1, #0
 802fd00:	d1f5      	bne.n	802fcee <UART_EndTxTransfer>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802fd02:	f102 0308 	add.w	r3, r2, #8
 802fd06:	e853 3f00 	ldrex	r3, [r3]
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_TXFTIE));
 802fd0a:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802fd0e:	f102 0c08 	add.w	ip, r2, #8
 802fd12:	e84c 3100 	strex	r1, r3, [ip]
 802fd16:	2900      	cmp	r1, #0
 802fd18:	d1f3      	bne.n	802fd02 <UART_EndTxTransfer+0x14>

  /* At end of Tx process, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 802fd1a:	2320      	movs	r3, #32
 802fd1c:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
}
 802fd20:	4770      	bx	lr
	...

0802fd24 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
 802fd24:	b510      	push	{r4, lr}
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 802fd26:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802fd28:	e852 3f00 	ldrex	r3, [r2]
 802fd2c:	f423 7390 	bic.w	r3, r3, #288	; 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802fd30:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 802fd34:	6802      	ldr	r2, [r0, #0]
 802fd36:	2900      	cmp	r1, #0
 802fd38:	d1f5      	bne.n	802fd26 <UART_EndRxTransfer+0x2>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 802fd3a:	4c0f      	ldr	r4, [pc, #60]	; (802fd78 <UART_EndRxTransfer+0x54>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802fd3c:	f102 0308 	add.w	r3, r2, #8
 802fd40:	e853 3f00 	ldrex	r3, [r3]
 802fd44:	4023      	ands	r3, r4
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802fd46:	f102 0c08 	add.w	ip, r2, #8
 802fd4a:	e84c 3100 	strex	r1, r3, [ip]
 802fd4e:	2900      	cmp	r1, #0
 802fd50:	d1f4      	bne.n	802fd3c <UART_EndRxTransfer+0x18>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 802fd52:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 802fd54:	2b01      	cmp	r3, #1
 802fd56:	d107      	bne.n	802fd68 <UART_EndRxTransfer+0x44>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802fd58:	e852 3f00 	ldrex	r3, [r2]
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 802fd5c:	f023 0310 	bic.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802fd60:	e842 3100 	strex	r1, r3, [r2]
 802fd64:	2900      	cmp	r1, #0
 802fd66:	d1f7      	bne.n	802fd58 <UART_EndRxTransfer+0x34>
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 802fd68:	2320      	movs	r3, #32
 802fd6a:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 802fd6e:	2300      	movs	r3, #0
 802fd70:	66c3      	str	r3, [r0, #108]	; 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 802fd72:	6703      	str	r3, [r0, #112]	; 0x70
}
 802fd74:	bd10      	pop	{r4, pc}
 802fd76:	bf00      	nop
 802fd78:	effffffe 	.word	0xeffffffe

0802fd7c <HAL_UART_Transmit_DMA>:
{
 802fd7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802fd7e:	4604      	mov	r4, r0
 802fd80:	4613      	mov	r3, r2
  if (huart->gState == HAL_UART_STATE_READY)
 802fd82:	f8d4 7084 	ldr.w	r7, [r4, #132]	; 0x84
 802fd86:	2f20      	cmp	r7, #32
 802fd88:	d143      	bne.n	802fe12 <HAL_UART_Transmit_DMA+0x96>
    if ((pData == NULL) || (Size == 0U))
 802fd8a:	b361      	cbz	r1, 802fde6 <HAL_UART_Transmit_DMA+0x6a>
 802fd8c:	b35a      	cbz	r2, 802fde6 <HAL_UART_Transmit_DMA+0x6a>
    __HAL_LOCK(huart);
 802fd8e:	f894 2080 	ldrb.w	r2, [r4, #128]	; 0x80
 802fd92:	2a01      	cmp	r2, #1
 802fd94:	d03d      	beq.n	802fe12 <HAL_UART_Transmit_DMA+0x96>
    if (huart->hdmatx != NULL)
 802fd96:	6fa0      	ldr	r0, [r4, #120]	; 0x78
    huart->TxXferCount = Size;
 802fd98:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
    __HAL_LOCK(huart);
 802fd9c:	2501      	movs	r5, #1
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 802fd9e:	2600      	movs	r6, #0
    huart->gState = HAL_UART_STATE_BUSY_TX;
 802fda0:	2221      	movs	r2, #33	; 0x21
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 802fda2:	f8c4 608c 	str.w	r6, [r4, #140]	; 0x8c
    __HAL_LOCK(huart);
 802fda6:	f884 5080 	strb.w	r5, [r4, #128]	; 0x80
    huart->pTxBuffPtr  = pData;
 802fdaa:	6521      	str	r1, [r4, #80]	; 0x50
    huart->TxXferSize  = Size;
 802fdac:	f8a4 3054 	strh.w	r3, [r4, #84]	; 0x54
    huart->gState = HAL_UART_STATE_BUSY_TX;
 802fdb0:	f8c4 2084 	str.w	r2, [r4, #132]	; 0x84
    if (huart->hdmatx != NULL)
 802fdb4:	b1c8      	cbz	r0, 802fdea <HAL_UART_Transmit_DMA+0x6e>
      huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
 802fdb6:	f8df c060 	ldr.w	ip, [pc, #96]	; 802fe18 <HAL_UART_Transmit_DMA+0x9c>
 802fdba:	6822      	ldr	r2, [r4, #0]
 802fdbc:	f8c0 c02c 	str.w	ip, [r0, #44]	; 0x2c
      huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
 802fdc0:	f8df c058 	ldr.w	ip, [pc, #88]	; 802fe1c <HAL_UART_Transmit_DMA+0xa0>
 802fdc4:	f8c0 c030 	str.w	ip, [r0, #48]	; 0x30
      huart->hdmatx->XferErrorCallback = UART_DMAError;
 802fdc8:	f8df c054 	ldr.w	ip, [pc, #84]	; 802fe20 <HAL_UART_Transmit_DMA+0xa4>
      if (HAL_DMA_Start_IT(huart->hdmatx, (uint32_t)huart->pTxBuffPtr, (uint32_t)&huart->Instance->TDR, Size) != HAL_OK)
 802fdcc:	3228      	adds	r2, #40	; 0x28
      huart->hdmatx->XferAbortCallback = NULL;
 802fdce:	e9c0 c60d 	strd	ip, r6, [r0, #52]	; 0x34
      if (HAL_DMA_Start_IT(huart->hdmatx, (uint32_t)huart->pTxBuffPtr, (uint32_t)&huart->Instance->TDR, Size) != HAL_OK)
 802fdd2:	f7fe f8f1 	bl	802dfb8 <HAL_DMA_Start_IT>
 802fdd6:	b140      	cbz	r0, 802fdea <HAL_UART_Transmit_DMA+0x6e>
        huart->ErrorCode = HAL_UART_ERROR_DMA;
 802fdd8:	2310      	movs	r3, #16
 802fdda:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
        __HAL_UNLOCK(huart);
 802fdde:	f884 6080 	strb.w	r6, [r4, #128]	; 0x80
        huart->gState = HAL_UART_STATE_READY;
 802fde2:	f8c4 7084 	str.w	r7, [r4, #132]	; 0x84
      return HAL_ERROR;
 802fde6:	2001      	movs	r0, #1
 802fde8:	e012      	b.n	802fe10 <HAL_UART_Transmit_DMA+0x94>
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_TCF);
 802fdea:	6823      	ldr	r3, [r4, #0]
 802fdec:	2240      	movs	r2, #64	; 0x40
 802fdee:	621a      	str	r2, [r3, #32]
    __HAL_UNLOCK(huart);
 802fdf0:	2300      	movs	r3, #0
 802fdf2:	6822      	ldr	r2, [r4, #0]
 802fdf4:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802fdf8:	f102 0308 	add.w	r3, r2, #8
 802fdfc:	e853 3f00 	ldrex	r3, [r3]
    ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 802fe00:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802fe04:	f102 0108 	add.w	r1, r2, #8
 802fe08:	e841 3000 	strex	r0, r3, [r1]
 802fe0c:	2800      	cmp	r0, #0
 802fe0e:	d1f3      	bne.n	802fdf8 <HAL_UART_Transmit_DMA+0x7c>
}
 802fe10:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_BUSY;
 802fe12:	2002      	movs	r0, #2
 802fe14:	e7fc      	b.n	802fe10 <HAL_UART_Transmit_DMA+0x94>
 802fe16:	bf00      	nop
 802fe18:	0802fe25 	.word	0x0802fe25
 802fe1c:	0802fe6d 	.word	0x0802fe6d
 802fe20:	0802fe79 	.word	0x0802fe79

0802fe24 <UART_DMATransmitCplt>:
  * @brief DMA UART transmit process complete callback.
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
{
 802fe24:	b508      	push	{r3, lr}
 802fe26:	4603      	mov	r3, r0
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 802fe28:	6a80      	ldr	r0, [r0, #40]	; 0x28

  /* DMA Normal mode */
  if (HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC))
 802fe2a:	681b      	ldr	r3, [r3, #0]
 802fe2c:	681b      	ldr	r3, [r3, #0]
 802fe2e:	f013 0320 	ands.w	r3, r3, #32
 802fe32:	d117      	bne.n	802fe64 <UART_DMATransmitCplt+0x40>
  {
    huart->TxXferCount = 0U;
 802fe34:	f8a0 3056 	strh.w	r3, [r0, #86]	; 0x56

    /* Disable the DMA transfer for transmit request by resetting the DMAT bit
       in the UART CR3 register */
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 802fe38:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802fe3a:	f102 0308 	add.w	r3, r2, #8
 802fe3e:	e853 3f00 	ldrex	r3, [r3]
 802fe42:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802fe46:	3208      	adds	r2, #8
 802fe48:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 802fe4c:	6802      	ldr	r2, [r0, #0]
 802fe4e:	2900      	cmp	r1, #0
 802fe50:	d1f2      	bne.n	802fe38 <UART_DMATransmitCplt+0x14>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802fe52:	e852 3f00 	ldrex	r3, [r2]

    /* Enable the UART Transmit Complete Interrupt */
    ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 802fe56:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802fe5a:	e842 3100 	strex	r1, r3, [r2]
 802fe5e:	2900      	cmp	r1, #0
 802fe60:	d1f7      	bne.n	802fe52 <UART_DMATransmitCplt+0x2e>
#else
    /*Call legacy weak Tx complete callback*/
    HAL_UART_TxCpltCallback(huart);
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
  }
}
 802fe62:	bd08      	pop	{r3, pc}
    HAL_UART_TxCpltCallback(huart);
 802fe64:	f7fc fe44 	bl	802caf0 <HAL_UART_TxCpltCallback>
}
 802fe68:	e7fb      	b.n	802fe62 <UART_DMATransmitCplt+0x3e>

0802fe6a <HAL_UART_TxHalfCpltCallback>:
 802fe6a:	4770      	bx	lr

0802fe6c <UART_DMATxHalfCplt>:
  * @brief DMA UART transmit process half complete callback.
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
{
 802fe6c:	b508      	push	{r3, lr}
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx Half complete callback*/
  huart->TxHalfCpltCallback(huart);
#else
  /*Call legacy weak Tx Half complete callback*/
  HAL_UART_TxHalfCpltCallback(huart);
 802fe6e:	6a80      	ldr	r0, [r0, #40]	; 0x28
 802fe70:	f7ff fffb 	bl	802fe6a <HAL_UART_TxHalfCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 802fe74:	bd08      	pop	{r3, pc}

0802fe76 <HAL_UART_ErrorCallback>:
 802fe76:	4770      	bx	lr

0802fe78 <UART_DMAError>:
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMAError(DMA_HandleTypeDef *hdma)
{
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 802fe78:	6a80      	ldr	r0, [r0, #40]	; 0x28

  const HAL_UART_StateTypeDef gstate = huart->gState;
  const HAL_UART_StateTypeDef rxstate = huart->RxState;

  /* Stop UART DMA Tx request if ongoing */
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
 802fe7a:	6802      	ldr	r2, [r0, #0]
  const HAL_UART_StateTypeDef gstate = huart->gState;
 802fe7c:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
{
 802fe80:	b510      	push	{r4, lr}
  const HAL_UART_StateTypeDef rxstate = huart->RxState;
 802fe82:	f8d0 4088 	ldr.w	r4, [r0, #136]	; 0x88
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
 802fe86:	6892      	ldr	r2, [r2, #8]
 802fe88:	0612      	lsls	r2, r2, #24
 802fe8a:	d506      	bpl.n	802fe9a <UART_DMAError+0x22>
 802fe8c:	2b21      	cmp	r3, #33	; 0x21
 802fe8e:	d104      	bne.n	802fe9a <UART_DMAError+0x22>
      (gstate == HAL_UART_STATE_BUSY_TX))
  {
    huart->TxXferCount = 0U;
 802fe90:	2300      	movs	r3, #0
 802fe92:	f8a0 3056 	strh.w	r3, [r0, #86]	; 0x56
    UART_EndTxTransfer(huart);
 802fe96:	f7ff ff2a 	bl	802fcee <UART_EndTxTransfer>
  }

  /* Stop UART DMA Rx request if ongoing */
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) &&
 802fe9a:	6803      	ldr	r3, [r0, #0]
 802fe9c:	689b      	ldr	r3, [r3, #8]
 802fe9e:	065b      	lsls	r3, r3, #25
 802fea0:	d506      	bpl.n	802feb0 <UART_DMAError+0x38>
 802fea2:	2c22      	cmp	r4, #34	; 0x22
 802fea4:	d104      	bne.n	802feb0 <UART_DMAError+0x38>
      (rxstate == HAL_UART_STATE_BUSY_RX))
  {
    huart->RxXferCount = 0U;
 802fea6:	2300      	movs	r3, #0
 802fea8:	f8a0 305e 	strh.w	r3, [r0, #94]	; 0x5e
    UART_EndRxTransfer(huart);
 802feac:	f7ff ff3a 	bl	802fd24 <UART_EndRxTransfer>
  }

  huart->ErrorCode |= HAL_UART_ERROR_DMA;
 802feb0:	f8d0 308c 	ldr.w	r3, [r0, #140]	; 0x8c
 802feb4:	f043 0310 	orr.w	r3, r3, #16
 802feb8:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 802febc:	f7ff ffdb 	bl	802fe76 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 802fec0:	bd10      	pop	{r4, pc}

0802fec2 <UART_DMAAbortOnError>:
  *         (To be called at end of DMA Abort procedure following error occurrence).
  * @param  hdma DMA handle.
  * @retval None
  */
static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
 802fec2:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 802fec4:	6a80      	ldr	r0, [r0, #40]	; 0x28
  huart->RxXferCount = 0U;
 802fec6:	2300      	movs	r3, #0
 802fec8:	f8a0 305e 	strh.w	r3, [r0, #94]	; 0x5e
  huart->TxXferCount = 0U;
 802fecc:	f8a0 3056 	strh.w	r3, [r0, #86]	; 0x56
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 802fed0:	f7ff ffd1 	bl	802fe76 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 802fed4:	bd08      	pop	{r3, pc}

0802fed6 <HAL_UARTEx_RxEventCallback>:
}
 802fed6:	4770      	bx	lr

0802fed8 <HAL_UART_IRQHandler>:
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
 802fed8:	6803      	ldr	r3, [r0, #0]
 802feda:	69da      	ldr	r2, [r3, #28]
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 802fedc:	6819      	ldr	r1, [r3, #0]
{
 802fede:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (errorflags == 0U)
 802fee2:	f640 060f 	movw	r6, #2063	; 0x80f
 802fee6:	4232      	tst	r2, r6
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 802fee8:	689d      	ldr	r5, [r3, #8]
{
 802feea:	4604      	mov	r4, r0
  if (errorflags == 0U)
 802feec:	d110      	bne.n	802ff10 <HAL_UART_IRQHandler+0x38>
    if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)
 802feee:	0696      	lsls	r6, r2, #26
 802fef0:	f140 8096 	bpl.w	8030020 <HAL_UART_IRQHandler+0x148>
        && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)
 802fef4:	f001 0620 	and.w	r6, r1, #32
            || ((cr3its & USART_CR3_RXFTIE) != 0U)))
 802fef8:	f005 5780 	and.w	r7, r5, #268435456	; 0x10000000
 802fefc:	433e      	orrs	r6, r7
 802fefe:	f000 808f 	beq.w	8030020 <HAL_UART_IRQHandler+0x148>
      if (huart->RxISR != NULL)
 802ff02:	6f03      	ldr	r3, [r0, #112]	; 0x70
 802ff04:	2b00      	cmp	r3, #0
 802ff06:	f000 8084 	beq.w	8030012 <HAL_UART_IRQHandler+0x13a>
}
 802ff0a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 802ff0e:	4718      	bx	r3
      && ((((cr3its & (USART_CR3_RXFTIE | USART_CR3_EIE)) != 0U)
 802ff10:	4ea7      	ldr	r6, [pc, #668]	; (80301b0 <HAL_UART_IRQHandler+0x2d8>)
           || ((cr1its & (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_RTOIE)) != 0U))))
 802ff12:	48a8      	ldr	r0, [pc, #672]	; (80301b4 <HAL_UART_IRQHandler+0x2dc>)
      && ((((cr3its & (USART_CR3_RXFTIE | USART_CR3_EIE)) != 0U)
 802ff14:	402e      	ands	r6, r5
           || ((cr1its & (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_RTOIE)) != 0U))))
 802ff16:	4008      	ands	r0, r1
 802ff18:	4330      	orrs	r0, r6
 802ff1a:	f000 8081 	beq.w	8030020 <HAL_UART_IRQHandler+0x148>
    if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 802ff1e:	07d7      	lsls	r7, r2, #31
 802ff20:	d509      	bpl.n	802ff36 <HAL_UART_IRQHandler+0x5e>
 802ff22:	05c8      	lsls	r0, r1, #23
 802ff24:	d507      	bpl.n	802ff36 <HAL_UART_IRQHandler+0x5e>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 802ff26:	2001      	movs	r0, #1
 802ff28:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 802ff2a:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 802ff2e:	f040 0001 	orr.w	r0, r0, #1
 802ff32:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 802ff36:	0797      	lsls	r7, r2, #30
 802ff38:	d509      	bpl.n	802ff4e <HAL_UART_IRQHandler+0x76>
 802ff3a:	07e8      	lsls	r0, r5, #31
 802ff3c:	d507      	bpl.n	802ff4e <HAL_UART_IRQHandler+0x76>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 802ff3e:	2002      	movs	r0, #2
 802ff40:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 802ff42:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 802ff46:	f040 0004 	orr.w	r0, r0, #4
 802ff4a:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 802ff4e:	0757      	lsls	r7, r2, #29
 802ff50:	d509      	bpl.n	802ff66 <HAL_UART_IRQHandler+0x8e>
 802ff52:	07e8      	lsls	r0, r5, #31
 802ff54:	d507      	bpl.n	802ff66 <HAL_UART_IRQHandler+0x8e>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 802ff56:	2004      	movs	r0, #4
 802ff58:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 802ff5a:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 802ff5e:	f040 0002 	orr.w	r0, r0, #2
 802ff62:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    if (((isrflags & USART_ISR_ORE) != 0U)
 802ff66:	0717      	lsls	r7, r2, #28
 802ff68:	d50b      	bpl.n	802ff82 <HAL_UART_IRQHandler+0xaa>
        && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U) ||
 802ff6a:	f001 0020 	and.w	r0, r1, #32
 802ff6e:	4330      	orrs	r0, r6
 802ff70:	d007      	beq.n	802ff82 <HAL_UART_IRQHandler+0xaa>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 802ff72:	2008      	movs	r0, #8
 802ff74:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 802ff76:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 802ff7a:	f040 0008 	orr.w	r0, r0, #8
 802ff7e:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    if (((isrflags & USART_ISR_RTOF) != 0U) && ((cr1its & USART_CR1_RTOIE) != 0U))
 802ff82:	0516      	lsls	r6, r2, #20
 802ff84:	d50a      	bpl.n	802ff9c <HAL_UART_IRQHandler+0xc4>
 802ff86:	0148      	lsls	r0, r1, #5
 802ff88:	d508      	bpl.n	802ff9c <HAL_UART_IRQHandler+0xc4>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 802ff8a:	f44f 6000 	mov.w	r0, #2048	; 0x800
 802ff8e:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_RTO;
 802ff90:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 802ff94:	f043 0320 	orr.w	r3, r3, #32
 802ff98:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 802ff9c:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 802ffa0:	2b00      	cmp	r3, #0
 802ffa2:	d036      	beq.n	8030012 <HAL_UART_IRQHandler+0x13a>
      if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)
 802ffa4:	0693      	lsls	r3, r2, #26
 802ffa6:	d50a      	bpl.n	802ffbe <HAL_UART_IRQHandler+0xe6>
          && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)
 802ffa8:	f001 0120 	and.w	r1, r1, #32
              || ((cr3its & USART_CR3_RXFTIE) != 0U)))
 802ffac:	f005 5580 	and.w	r5, r5, #268435456	; 0x10000000
 802ffb0:	ea51 0305 	orrs.w	r3, r1, r5
 802ffb4:	d003      	beq.n	802ffbe <HAL_UART_IRQHandler+0xe6>
        if (huart->RxISR != NULL)
 802ffb6:	6f23      	ldr	r3, [r4, #112]	; 0x70
 802ffb8:	b10b      	cbz	r3, 802ffbe <HAL_UART_IRQHandler+0xe6>
          huart->RxISR(huart);
 802ffba:	4620      	mov	r0, r4
 802ffbc:	4798      	blx	r3
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 802ffbe:	6823      	ldr	r3, [r4, #0]
      errorcode = huart->ErrorCode;
 802ffc0:	f8d4 508c 	ldr.w	r5, [r4, #140]	; 0x8c
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 802ffc4:	689b      	ldr	r3, [r3, #8]
          ((errorcode & (HAL_UART_ERROR_RTO | HAL_UART_ERROR_ORE)) != 0U))
 802ffc6:	f005 0528 	and.w	r5, r5, #40	; 0x28
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 802ffca:	f003 0340 	and.w	r3, r3, #64	; 0x40
 802ffce:	431d      	orrs	r5, r3
        UART_EndRxTransfer(huart);
 802ffd0:	4620      	mov	r0, r4
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 802ffd2:	d020      	beq.n	8030016 <HAL_UART_IRQHandler+0x13e>
        UART_EndRxTransfer(huart);
 802ffd4:	f7ff fea6 	bl	802fd24 <UART_EndRxTransfer>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 802ffd8:	6822      	ldr	r2, [r4, #0]
 802ffda:	6893      	ldr	r3, [r2, #8]
 802ffdc:	065f      	lsls	r7, r3, #25
 802ffde:	d515      	bpl.n	803000c <HAL_UART_IRQHandler+0x134>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802ffe0:	f102 0308 	add.w	r3, r2, #8
 802ffe4:	e853 3f00 	ldrex	r3, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 802ffe8:	f023 0340 	bic.w	r3, r3, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802ffec:	f102 0008 	add.w	r0, r2, #8
 802fff0:	e840 3100 	strex	r1, r3, [r0]
 802fff4:	2900      	cmp	r1, #0
 802fff6:	d1f3      	bne.n	802ffe0 <HAL_UART_IRQHandler+0x108>
          if (huart->hdmarx != NULL)
 802fff8:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 802fffa:	b138      	cbz	r0, 803000c <HAL_UART_IRQHandler+0x134>
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 802fffc:	4b6e      	ldr	r3, [pc, #440]	; (80301b8 <HAL_UART_IRQHandler+0x2e0>)
 802fffe:	6383      	str	r3, [r0, #56]	; 0x38
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 8030000:	f7fe f854 	bl	802e0ac <HAL_DMA_Abort_IT>
 8030004:	b128      	cbz	r0, 8030012 <HAL_UART_IRQHandler+0x13a>
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8030006:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 8030008:	6b83      	ldr	r3, [r0, #56]	; 0x38
 803000a:	e77e      	b.n	802ff0a <HAL_UART_IRQHandler+0x32>
            HAL_UART_ErrorCallback(huart);
 803000c:	4620      	mov	r0, r4
 803000e:	f7ff ff32 	bl	802fe76 <HAL_UART_ErrorCallback>
}
 8030012:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        HAL_UART_ErrorCallback(huart);
 8030016:	f7ff ff2e 	bl	802fe76 <HAL_UART_ErrorCallback>
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 803001a:	f8c4 508c 	str.w	r5, [r4, #140]	; 0x8c
 803001e:	e7f8      	b.n	8030012 <HAL_UART_IRQHandler+0x13a>
  if (  (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8030020:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8030022:	2801      	cmp	r0, #1
 8030024:	f040 8081 	bne.w	803012a <HAL_UART_IRQHandler+0x252>
      &&((isrflags & USART_ISR_IDLE) != 0U)
 8030028:	06d6      	lsls	r6, r2, #27
 803002a:	d57e      	bpl.n	803012a <HAL_UART_IRQHandler+0x252>
      &&((cr1its & USART_ISR_IDLE) != 0U))
 803002c:	06c8      	lsls	r0, r1, #27
 803002e:	d57c      	bpl.n	803012a <HAL_UART_IRQHandler+0x252>
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 8030030:	2210      	movs	r2, #16
 8030032:	621a      	str	r2, [r3, #32]
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8030034:	689a      	ldr	r2, [r3, #8]
 8030036:	0651      	lsls	r1, r2, #25
 8030038:	d547      	bpl.n	80300ca <HAL_UART_IRQHandler+0x1f2>
      uint16_t nb_remaining_rx_data = (uint16_t) __HAL_DMA_GET_COUNTER(huart->hdmarx);
 803003a:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
 803003c:	6811      	ldr	r1, [r2, #0]
 803003e:	684a      	ldr	r2, [r1, #4]
 8030040:	b292      	uxth	r2, r2
      if (  (nb_remaining_rx_data > 0U)
 8030042:	2a00      	cmp	r2, #0
 8030044:	d0e5      	beq.n	8030012 <HAL_UART_IRQHandler+0x13a>
          &&(nb_remaining_rx_data < huart->RxXferSize))
 8030046:	f8b4 005c 	ldrh.w	r0, [r4, #92]	; 0x5c
 803004a:	4290      	cmp	r0, r2
 803004c:	d9e1      	bls.n	8030012 <HAL_UART_IRQHandler+0x13a>
        huart->RxXferCount = nb_remaining_rx_data;
 803004e:	f8a4 205e 	strh.w	r2, [r4, #94]	; 0x5e
        if (HAL_IS_BIT_CLR(huart->hdmarx->Instance->CCR, DMA_CCR_CIRC))
 8030052:	680a      	ldr	r2, [r1, #0]
 8030054:	0692      	lsls	r2, r2, #26
 8030056:	d42e      	bmi.n	80300b6 <HAL_UART_IRQHandler+0x1de>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030058:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 803005c:	f422 7280 	bic.w	r2, r2, #256	; 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030060:	e843 2100 	strex	r1, r2, [r3]
 8030064:	2900      	cmp	r1, #0
 8030066:	d1f7      	bne.n	8030058 <HAL_UART_IRQHandler+0x180>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030068:	f103 0208 	add.w	r2, r3, #8
 803006c:	e852 2f00 	ldrex	r2, [r2]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8030070:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030074:	f103 0008 	add.w	r0, r3, #8
 8030078:	e840 2100 	strex	r1, r2, [r0]
 803007c:	2900      	cmp	r1, #0
 803007e:	d1f3      	bne.n	8030068 <HAL_UART_IRQHandler+0x190>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030080:	f103 0208 	add.w	r2, r3, #8
 8030084:	e852 2f00 	ldrex	r2, [r2]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8030088:	f022 0240 	bic.w	r2, r2, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 803008c:	f103 0008 	add.w	r0, r3, #8
 8030090:	e840 2100 	strex	r1, r2, [r0]
 8030094:	2900      	cmp	r1, #0
 8030096:	d1f3      	bne.n	8030080 <HAL_UART_IRQHandler+0x1a8>
          huart->RxState = HAL_UART_STATE_READY;
 8030098:	2220      	movs	r2, #32
 803009a:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 803009e:	66e1      	str	r1, [r4, #108]	; 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80300a0:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 80300a4:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80300a8:	e843 2100 	strex	r1, r2, [r3]
 80300ac:	2900      	cmp	r1, #0
 80300ae:	d1f7      	bne.n	80300a0 <HAL_UART_IRQHandler+0x1c8>
          (void)HAL_DMA_Abort(huart->hdmarx);
 80300b0:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 80300b2:	f7fd ffc6 	bl	802e042 <HAL_DMA_Abort>
        HAL_UARTEx_RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
 80300b6:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 80300ba:	f8b4 105c 	ldrh.w	r1, [r4, #92]	; 0x5c
 80300be:	1ac9      	subs	r1, r1, r3
 80300c0:	b289      	uxth	r1, r1
        HAL_UARTEx_RxEventCallback(huart, nb_rx_data);
 80300c2:	4620      	mov	r0, r4
 80300c4:	f7ff ff07 	bl	802fed6 <HAL_UARTEx_RxEventCallback>
 80300c8:	e7a3      	b.n	8030012 <HAL_UART_IRQHandler+0x13a>
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 80300ca:	f8b4 105e 	ldrh.w	r1, [r4, #94]	; 0x5e
 80300ce:	b28a      	uxth	r2, r1
      if (  (huart->RxXferCount > 0U)
 80300d0:	f8b4 105e 	ldrh.w	r1, [r4, #94]	; 0x5e
 80300d4:	b289      	uxth	r1, r1
 80300d6:	2900      	cmp	r1, #0
 80300d8:	d09b      	beq.n	8030012 <HAL_UART_IRQHandler+0x13a>
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 80300da:	f8b4 105c 	ldrh.w	r1, [r4, #92]	; 0x5c
 80300de:	1a89      	subs	r1, r1, r2
 80300e0:	b289      	uxth	r1, r1
          &&(nb_rx_data > 0U) )
 80300e2:	2900      	cmp	r1, #0
 80300e4:	d095      	beq.n	8030012 <HAL_UART_IRQHandler+0x13a>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80300e6:	e853 2f00 	ldrex	r2, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 80300ea:	f422 7290 	bic.w	r2, r2, #288	; 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80300ee:	e843 2000 	strex	r0, r2, [r3]
 80300f2:	2800      	cmp	r0, #0
 80300f4:	d1f7      	bne.n	80300e6 <HAL_UART_IRQHandler+0x20e>
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 80300f6:	4d31      	ldr	r5, [pc, #196]	; (80301bc <HAL_UART_IRQHandler+0x2e4>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80300f8:	f103 0208 	add.w	r2, r3, #8
 80300fc:	e852 2f00 	ldrex	r2, [r2]
 8030100:	402a      	ands	r2, r5
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030102:	f103 0608 	add.w	r6, r3, #8
 8030106:	e846 2000 	strex	r0, r2, [r6]
 803010a:	2800      	cmp	r0, #0
 803010c:	d1f4      	bne.n	80300f8 <HAL_UART_IRQHandler+0x220>
        huart->RxState = HAL_UART_STATE_READY;
 803010e:	2220      	movs	r2, #32
 8030110:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
        huart->RxISR = NULL;
 8030114:	6720      	str	r0, [r4, #112]	; 0x70
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8030116:	66e0      	str	r0, [r4, #108]	; 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030118:	e853 2f00 	ldrex	r2, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 803011c:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030120:	e843 2000 	strex	r0, r2, [r3]
 8030124:	2800      	cmp	r0, #0
 8030126:	d1f7      	bne.n	8030118 <HAL_UART_IRQHandler+0x240>
 8030128:	e7cb      	b.n	80300c2 <HAL_UART_IRQHandler+0x1ea>
  if (((isrflags & USART_ISR_WUF) != 0U) && ((cr3its & USART_CR3_WUFIE) != 0U))
 803012a:	02d7      	lsls	r7, r2, #11
 803012c:	d509      	bpl.n	8030142 <HAL_UART_IRQHandler+0x26a>
 803012e:	026e      	lsls	r6, r5, #9
 8030130:	d507      	bpl.n	8030142 <HAL_UART_IRQHandler+0x26a>
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);
 8030132:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    HAL_UARTEx_WakeupCallback(huart);
 8030136:	4620      	mov	r0, r4
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);
 8030138:	621a      	str	r2, [r3, #32]
}
 803013a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    HAL_UARTEx_WakeupCallback(huart);
 803013e:	f000 bd35 	b.w	8030bac <HAL_UARTEx_WakeupCallback>
  if (((isrflags & USART_ISR_TXE_TXFNF) != 0U)
 8030142:	0610      	lsls	r0, r2, #24
 8030144:	d50b      	bpl.n	803015e <HAL_UART_IRQHandler+0x286>
      && (((cr1its & USART_CR1_TXEIE_TXFNFIE) != 0U)
 8030146:	f001 0080 	and.w	r0, r1, #128	; 0x80
          || ((cr3its & USART_CR3_TXFTIE) != 0U)))
 803014a:	f405 0500 	and.w	r5, r5, #8388608	; 0x800000
 803014e:	4328      	orrs	r0, r5
 8030150:	d005      	beq.n	803015e <HAL_UART_IRQHandler+0x286>
    if (huart->TxISR != NULL)
 8030152:	6f63      	ldr	r3, [r4, #116]	; 0x74
 8030154:	2b00      	cmp	r3, #0
 8030156:	f43f af5c 	beq.w	8030012 <HAL_UART_IRQHandler+0x13a>
      huart->TxISR(huart);
 803015a:	4620      	mov	r0, r4
 803015c:	e6d5      	b.n	802ff0a <HAL_UART_IRQHandler+0x32>
  if (((isrflags & USART_ISR_TC) != 0U) && ((cr1its & USART_CR1_TCIE) != 0U))
 803015e:	0657      	lsls	r7, r2, #25
 8030160:	d511      	bpl.n	8030186 <HAL_UART_IRQHandler+0x2ae>
 8030162:	064e      	lsls	r6, r1, #25
 8030164:	d50f      	bpl.n	8030186 <HAL_UART_IRQHandler+0x2ae>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030166:	e853 2f00 	ldrex	r2, [r3]
  * @retval None
  */
static void UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
  /* Disable the UART Transmit Complete Interrupt */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 803016a:	f022 0240 	bic.w	r2, r2, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 803016e:	e843 2100 	strex	r1, r2, [r3]
 8030172:	2900      	cmp	r1, #0
 8030174:	d1f7      	bne.n	8030166 <HAL_UART_IRQHandler+0x28e>

  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 8030176:	2320      	movs	r3, #32
 8030178:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84

  /* Cleat TxISR function pointer */
  huart->TxISR = NULL;
 803017c:	6761      	str	r1, [r4, #116]	; 0x74
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx complete callback*/
  huart->TxCpltCallback(huart);
#else
  /*Call legacy weak Tx complete callback*/
  HAL_UART_TxCpltCallback(huart);
 803017e:	4620      	mov	r0, r4
 8030180:	f7fc fcb6 	bl	802caf0 <HAL_UART_TxCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 8030184:	e745      	b.n	8030012 <HAL_UART_IRQHandler+0x13a>
  if (((isrflags & USART_ISR_TXFE) != 0U) && ((cr1its & USART_CR1_TXFEIE) != 0U))
 8030186:	0215      	lsls	r5, r2, #8
 8030188:	d506      	bpl.n	8030198 <HAL_UART_IRQHandler+0x2c0>
 803018a:	0048      	lsls	r0, r1, #1
 803018c:	d504      	bpl.n	8030198 <HAL_UART_IRQHandler+0x2c0>
    HAL_UARTEx_TxFifoEmptyCallback(huart);
 803018e:	4620      	mov	r0, r4
}
 8030190:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    HAL_UARTEx_TxFifoEmptyCallback(huart);
 8030194:	f000 bd0c 	b.w	8030bb0 <HAL_UARTEx_TxFifoEmptyCallback>
  if (((isrflags & USART_ISR_RXFF) != 0U) && ((cr1its & USART_CR1_RXFFIE) != 0U))
 8030198:	01d3      	lsls	r3, r2, #7
 803019a:	f57f af3a 	bpl.w	8030012 <HAL_UART_IRQHandler+0x13a>
 803019e:	2900      	cmp	r1, #0
 80301a0:	f6bf af37 	bge.w	8030012 <HAL_UART_IRQHandler+0x13a>
    HAL_UARTEx_RxFifoFullCallback(huart);
 80301a4:	4620      	mov	r0, r4
}
 80301a6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    HAL_UARTEx_RxFifoFullCallback(huart);
 80301aa:	f000 bd00 	b.w	8030bae <HAL_UARTEx_RxFifoFullCallback>
 80301ae:	bf00      	nop
 80301b0:	10000001 	.word	0x10000001
 80301b4:	04000120 	.word	0x04000120
 80301b8:	0802fec3 	.word	0x0802fec3
 80301bc:	effffffe 	.word	0xeffffffe

080301c0 <UART_RxISR_16BIT.part.0>:
/**
  * @brief RX interrupt handler for 7 or 8 bits data word length .
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_8BIT(UART_HandleTypeDef *huart)
 80301c0:	b508      	push	{r3, lr}
    huart->RxXferCount--;

    if (huart->RxXferCount == 0U)
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupts */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 80301c2:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80301c4:	e852 3f00 	ldrex	r3, [r2]
 80301c8:	f423 7390 	bic.w	r3, r3, #288	; 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80301cc:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 80301d0:	6803      	ldr	r3, [r0, #0]
 80301d2:	2900      	cmp	r1, #0
 80301d4:	d1f5      	bne.n	80301c2 <UART_RxISR_16BIT.part.0+0x2>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80301d6:	f103 0208 	add.w	r2, r3, #8
 80301da:	e852 2f00 	ldrex	r2, [r2]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80301de:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80301e2:	f103 0c08 	add.w	ip, r3, #8
 80301e6:	e84c 2100 	strex	r1, r2, [ip]
 80301ea:	2900      	cmp	r1, #0
 80301ec:	d1f3      	bne.n	80301d6 <UART_RxISR_16BIT.part.0+0x16>

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 80301ee:	2220      	movs	r2, #32
 80301f0:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
      /* Clear RxISR function pointer */
      huart->RxISR = NULL;

      /* Check current reception Mode :
         If Reception till IDLE event has been selected : */
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 80301f4:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
      huart->RxISR = NULL;
 80301f6:	6701      	str	r1, [r0, #112]	; 0x70
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 80301f8:	2a01      	cmp	r2, #1
 80301fa:	d112      	bne.n	8030222 <UART_RxISR_16BIT.part.0+0x62>
      {
        /* Set reception type to Standard */
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80301fc:	66c1      	str	r1, [r0, #108]	; 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80301fe:	e853 2f00 	ldrex	r2, [r3]

        /* Disable IDLE interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8030202:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030206:	e843 2100 	strex	r1, r2, [r3]
 803020a:	2900      	cmp	r1, #0
 803020c:	d1f7      	bne.n	80301fe <UART_RxISR_16BIT.part.0+0x3e>

        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 803020e:	69da      	ldr	r2, [r3, #28]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, huart->RxXferSize);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8030210:	f8b0 105c 	ldrh.w	r1, [r0, #92]	; 0x5c
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 8030214:	06d2      	lsls	r2, r2, #27
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 8030216:	bf44      	itt	mi
 8030218:	2210      	movmi	r2, #16
 803021a:	621a      	strmi	r2, [r3, #32]
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 803021c:	f7ff fe5b 	bl	802fed6 <HAL_UARTEx_RxEventCallback>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 8030220:	bd08      	pop	{r3, pc}
        HAL_UART_RxCpltCallback(huart);
 8030222:	f7fc fc6b 	bl	802cafc <HAL_UART_RxCpltCallback>
}
 8030226:	e7fb      	b.n	8030220 <UART_RxISR_16BIT.part.0+0x60>

08030228 <UART_RxISR_16BIT>:
  uint16_t *tmp;
  uint16_t uhMask = huart->Mask;
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8030228:	f8d0 1088 	ldr.w	r1, [r0, #136]	; 0x88
 803022c:	6802      	ldr	r2, [r0, #0]
 803022e:	2922      	cmp	r1, #34	; 0x22
 8030230:	d113      	bne.n	803025a <UART_RxISR_16BIT+0x32>
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8030232:	6a51      	ldr	r1, [r2, #36]	; 0x24
    tmp = (uint16_t *) huart->pRxBuffPtr ;
    *tmp = (uint16_t)(uhdata & uhMask);
 8030234:	f8b0 2060 	ldrh.w	r2, [r0, #96]	; 0x60
 8030238:	4011      	ands	r1, r2
 803023a:	6d82      	ldr	r2, [r0, #88]	; 0x58
 803023c:	f822 1b02 	strh.w	r1, [r2], #2
    huart->pRxBuffPtr += 2U;
 8030240:	6582      	str	r2, [r0, #88]	; 0x58
    huart->RxXferCount--;
 8030242:	f8b0 205e 	ldrh.w	r2, [r0, #94]	; 0x5e
 8030246:	3a01      	subs	r2, #1
 8030248:	b292      	uxth	r2, r2
 803024a:	f8a0 205e 	strh.w	r2, [r0, #94]	; 0x5e

    if (huart->RxXferCount == 0U)
 803024e:	f8b0 305e 	ldrh.w	r3, [r0, #94]	; 0x5e
 8030252:	b29b      	uxth	r3, r3
 8030254:	b92b      	cbnz	r3, 8030262 <UART_RxISR_16BIT+0x3a>
 8030256:	f7ff bfb3 	b.w	80301c0 <UART_RxISR_16BIT.part.0>
    }
  }
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 803025a:	6993      	ldr	r3, [r2, #24]
 803025c:	f043 0308 	orr.w	r3, r3, #8
 8030260:	6193      	str	r3, [r2, #24]
  }
}
 8030262:	4770      	bx	lr

08030264 <UART_RxISR_8BIT>:
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8030264:	f8d0 1088 	ldr.w	r1, [r0, #136]	; 0x88
 8030268:	6802      	ldr	r2, [r0, #0]
 803026a:	2922      	cmp	r1, #34	; 0x22
{
 803026c:	b410      	push	{r4}
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 803026e:	d115      	bne.n	803029c <UART_RxISR_8BIT+0x38>
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8030270:	6a52      	ldr	r2, [r2, #36]	; 0x24
    *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 8030272:	f890 4060 	ldrb.w	r4, [r0, #96]	; 0x60
 8030276:	6d81      	ldr	r1, [r0, #88]	; 0x58
 8030278:	4022      	ands	r2, r4
 803027a:	700a      	strb	r2, [r1, #0]
    huart->pRxBuffPtr++;
 803027c:	6d82      	ldr	r2, [r0, #88]	; 0x58
 803027e:	3201      	adds	r2, #1
 8030280:	6582      	str	r2, [r0, #88]	; 0x58
    huart->RxXferCount--;
 8030282:	f8b0 205e 	ldrh.w	r2, [r0, #94]	; 0x5e
 8030286:	3a01      	subs	r2, #1
 8030288:	b292      	uxth	r2, r2
 803028a:	f8a0 205e 	strh.w	r2, [r0, #94]	; 0x5e
    if (huart->RxXferCount == 0U)
 803028e:	f8b0 305e 	ldrh.w	r3, [r0, #94]	; 0x5e
 8030292:	b29b      	uxth	r3, r3
 8030294:	b933      	cbnz	r3, 80302a4 <UART_RxISR_8BIT+0x40>
}
 8030296:	bc10      	pop	{r4}
 8030298:	f7ff bf92 	b.w	80301c0 <UART_RxISR_16BIT.part.0>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 803029c:	6993      	ldr	r3, [r2, #24]
 803029e:	f043 0308 	orr.w	r3, r3, #8
 80302a2:	6193      	str	r3, [r2, #24]
}
 80302a4:	bc10      	pop	{r4}
 80302a6:	4770      	bx	lr

080302a8 <UART_RxISR_8BIT_FIFOEN>:
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_8BIT_FIFOEN(UART_HandleTypeDef *huart)
{
 80302a8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint16_t  uhMask = huart->Mask;
  uint16_t  uhdata;
  uint16_t  nb_rx_data;
  uint16_t  rxdatacount;
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
 80302ac:	6803      	ldr	r3, [r0, #0]
 80302ae:	69dd      	ldr	r5, [r3, #28]
  uint32_t  cr1its   = READ_REG(huart->Instance->CR1);
 80302b0:	f8d3 8000 	ldr.w	r8, [r3]
  uint32_t  cr3its   = READ_REG(huart->Instance->CR3);
 80302b4:	689e      	ldr	r6, [r3, #8]

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 80302b6:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 80302ba:	2a22      	cmp	r2, #34	; 0x22
{
 80302bc:	4604      	mov	r4, r0
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 80302be:	f040 80a7 	bne.w	8030410 <UART_RxISR_8BIT_FIFOEN+0x168>
  uint16_t  uhMask = huart->Mask;
 80302c2:	f8b0 7060 	ldrh.w	r7, [r0, #96]	; 0x60
  {
    nb_rx_data = huart->NbRxDataToProcess;
 80302c6:	f8b0 9068 	ldrh.w	r9, [r0, #104]	; 0x68
        /* Disable the UART Parity Error Interrupt and RXFT interrupt*/
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);

        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error)
           and RX FIFO Threshold interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 80302ca:	f8df b154 	ldr.w	fp, [pc, #340]	; 8030420 <UART_RxISR_8BIT_FIFOEN+0x178>
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 80302ce:	f04f 0a00 	mov.w	sl, #0
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 80302d2:	f006 0601 	and.w	r6, r6, #1
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 80302d6:	f1b9 0f00 	cmp.w	r9, #0
 80302da:	d001      	beq.n	80302e0 <UART_RxISR_8BIT_FIFOEN+0x38>
 80302dc:	06ab      	lsls	r3, r5, #26
 80302de:	d420      	bmi.n	8030322 <UART_RxISR_8BIT_FIFOEN+0x7a>

    /* When remaining number of bytes to receive is less than the RX FIFO
    threshold, next incoming frames are processed as if FIFO mode was
    disabled (i.e. one interrupt per received frame).
    */
    rxdatacount = huart->RxXferCount;
 80302e0:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 80302e4:	b29b      	uxth	r3, r3
    if ((rxdatacount != 0U) && (rxdatacount < huart->NbRxDataToProcess))
 80302e6:	b1d3      	cbz	r3, 803031e <UART_RxISR_8BIT_FIFOEN+0x76>
 80302e8:	f8b4 2068 	ldrh.w	r2, [r4, #104]	; 0x68
 80302ec:	429a      	cmp	r2, r3
 80302ee:	d916      	bls.n	803031e <UART_RxISR_8BIT_FIFOEN+0x76>
    {
      /* Disable the UART RXFT interrupt*/
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 80302f0:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80302f2:	f102 0308 	add.w	r3, r2, #8
 80302f6:	e853 3f00 	ldrex	r3, [r3]
 80302fa:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80302fe:	3208      	adds	r2, #8
 8030300:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 8030304:	6822      	ldr	r2, [r4, #0]
 8030306:	2900      	cmp	r1, #0
 8030308:	d1f2      	bne.n	80302f0 <UART_RxISR_8BIT_FIFOEN+0x48>

      /* Update the RxISR function pointer */
      huart->RxISR = UART_RxISR_8BIT;
 803030a:	4b44      	ldr	r3, [pc, #272]	; (803041c <UART_RxISR_8BIT_FIFOEN+0x174>)
 803030c:	6723      	str	r3, [r4, #112]	; 0x70
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 803030e:	e852 3f00 	ldrex	r3, [r2]

      /* Enable the UART Data Register Not Empty interrupt */
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
 8030312:	f043 0320 	orr.w	r3, r3, #32
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030316:	e842 3100 	strex	r1, r3, [r2]
 803031a:	2900      	cmp	r1, #0
 803031c:	d1f7      	bne.n	803030e <UART_RxISR_8BIT_FIFOEN+0x66>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 803031e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8030322:	6823      	ldr	r3, [r4, #0]
      *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 8030324:	6da2      	ldr	r2, [r4, #88]	; 0x58
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8030326:	6a5b      	ldr	r3, [r3, #36]	; 0x24
      *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 8030328:	403b      	ands	r3, r7
 803032a:	7013      	strb	r3, [r2, #0]
      huart->pRxBuffPtr++;
 803032c:	6da3      	ldr	r3, [r4, #88]	; 0x58
 803032e:	3301      	adds	r3, #1
 8030330:	65a3      	str	r3, [r4, #88]	; 0x58
      huart->RxXferCount--;
 8030332:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 8030336:	3b01      	subs	r3, #1
 8030338:	b29b      	uxth	r3, r3
 803033a:	f8a4 305e 	strh.w	r3, [r4, #94]	; 0x5e
      isrflags = READ_REG(huart->Instance->ISR);
 803033e:	6823      	ldr	r3, [r4, #0]
 8030340:	69dd      	ldr	r5, [r3, #28]
      if ((isrflags & (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE)) != 0U)
 8030342:	0769      	lsls	r1, r5, #29
 8030344:	d02a      	beq.n	803039c <UART_RxISR_8BIT_FIFOEN+0xf4>
        if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 8030346:	07ea      	lsls	r2, r5, #31
 8030348:	d50a      	bpl.n	8030360 <UART_RxISR_8BIT_FIFOEN+0xb8>
 803034a:	f418 7f80 	tst.w	r8, #256	; 0x100
 803034e:	d007      	beq.n	8030360 <UART_RxISR_8BIT_FIFOEN+0xb8>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 8030350:	2201      	movs	r2, #1
 8030352:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_PE;
 8030354:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 8030358:	f042 0201 	orr.w	r2, r2, #1
 803035c:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
        if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8030360:	07a8      	lsls	r0, r5, #30
 8030362:	d508      	bpl.n	8030376 <UART_RxISR_8BIT_FIFOEN+0xce>
 8030364:	b13e      	cbz	r6, 8030376 <UART_RxISR_8BIT_FIFOEN+0xce>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 8030366:	2202      	movs	r2, #2
 8030368:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_FE;
 803036a:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 803036e:	f042 0204 	orr.w	r2, r2, #4
 8030372:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8030376:	0769      	lsls	r1, r5, #29
 8030378:	d508      	bpl.n	803038c <UART_RxISR_8BIT_FIFOEN+0xe4>
 803037a:	b13e      	cbz	r6, 803038c <UART_RxISR_8BIT_FIFOEN+0xe4>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 803037c:	2204      	movs	r2, #4
 803037e:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_NE;
 8030380:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 8030384:	f043 0302 	orr.w	r3, r3, #2
 8030388:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
        if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 803038c:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 8030390:	b123      	cbz	r3, 803039c <UART_RxISR_8BIT_FIFOEN+0xf4>
          HAL_UART_ErrorCallback(huart);
 8030392:	4620      	mov	r0, r4
 8030394:	f7ff fd6f 	bl	802fe76 <HAL_UART_ErrorCallback>
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 8030398:	f8c4 a08c 	str.w	sl, [r4, #140]	; 0x8c
      if (huart->RxXferCount == 0U)
 803039c:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 80303a0:	b29b      	uxth	r3, r3
 80303a2:	2b00      	cmp	r3, #0
 80303a4:	d197      	bne.n	80302d6 <UART_RxISR_8BIT_FIFOEN+0x2e>
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 80303a6:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80303a8:	e852 3f00 	ldrex	r3, [r2]
 80303ac:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80303b0:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 80303b4:	6823      	ldr	r3, [r4, #0]
 80303b6:	2900      	cmp	r1, #0
 80303b8:	d1f5      	bne.n	80303a6 <UART_RxISR_8BIT_FIFOEN+0xfe>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80303ba:	f103 0208 	add.w	r2, r3, #8
 80303be:	e852 2f00 	ldrex	r2, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 80303c2:	ea02 020b 	and.w	r2, r2, fp
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80303c6:	f103 0008 	add.w	r0, r3, #8
 80303ca:	e840 2100 	strex	r1, r2, [r0]
 80303ce:	2900      	cmp	r1, #0
 80303d0:	d1f3      	bne.n	80303ba <UART_RxISR_8BIT_FIFOEN+0x112>
        huart->RxState = HAL_UART_STATE_READY;
 80303d2:	2220      	movs	r2, #32
 80303d4:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 80303d8:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
        huart->RxISR = NULL;
 80303da:	6721      	str	r1, [r4, #112]	; 0x70
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 80303dc:	2a01      	cmp	r2, #1
 80303de:	d113      	bne.n	8030408 <UART_RxISR_8BIT_FIFOEN+0x160>
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80303e0:	66e1      	str	r1, [r4, #108]	; 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80303e2:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 80303e6:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80303ea:	e843 2100 	strex	r1, r2, [r3]
 80303ee:	2900      	cmp	r1, #0
 80303f0:	d1f7      	bne.n	80303e2 <UART_RxISR_8BIT_FIFOEN+0x13a>
          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 80303f2:	69da      	ldr	r2, [r3, #28]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 80303f4:	f8b4 105c 	ldrh.w	r1, [r4, #92]	; 0x5c
          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 80303f8:	06d2      	lsls	r2, r2, #27
            __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 80303fa:	bf44      	itt	mi
 80303fc:	2210      	movmi	r2, #16
 80303fe:	621a      	strmi	r2, [r3, #32]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8030400:	4620      	mov	r0, r4
 8030402:	f7ff fd68 	bl	802fed6 <HAL_UARTEx_RxEventCallback>
 8030406:	e766      	b.n	80302d6 <UART_RxISR_8BIT_FIFOEN+0x2e>
          HAL_UART_RxCpltCallback(huart);
 8030408:	4620      	mov	r0, r4
 803040a:	f7fc fb77 	bl	802cafc <HAL_UART_RxCpltCallback>
 803040e:	e762      	b.n	80302d6 <UART_RxISR_8BIT_FIFOEN+0x2e>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 8030410:	699a      	ldr	r2, [r3, #24]
 8030412:	f042 0208 	orr.w	r2, r2, #8
 8030416:	619a      	str	r2, [r3, #24]
}
 8030418:	e781      	b.n	803031e <UART_RxISR_8BIT_FIFOEN+0x76>
 803041a:	bf00      	nop
 803041c:	08030265 	.word	0x08030265
 8030420:	effffffe 	.word	0xeffffffe

08030424 <UART_RxISR_16BIT_FIFOEN>:
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_16BIT_FIFOEN(UART_HandleTypeDef *huart)
{
 8030424:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint16_t *tmp;
  uint16_t  uhMask = huart->Mask;
  uint16_t  uhdata;
  uint16_t  nb_rx_data;
  uint16_t  rxdatacount;
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
 8030428:	6803      	ldr	r3, [r0, #0]
 803042a:	69dd      	ldr	r5, [r3, #28]
  uint32_t  cr1its   = READ_REG(huart->Instance->CR1);
 803042c:	f8d3 8000 	ldr.w	r8, [r3]
  uint32_t  cr3its   = READ_REG(huart->Instance->CR3);
 8030430:	689e      	ldr	r6, [r3, #8]

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8030432:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8030436:	2a22      	cmp	r2, #34	; 0x22
{
 8030438:	4604      	mov	r4, r0
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 803043a:	f040 80a5 	bne.w	8030588 <UART_RxISR_16BIT_FIFOEN+0x164>
  uint16_t  uhMask = huart->Mask;
 803043e:	f8b0 7060 	ldrh.w	r7, [r0, #96]	; 0x60
  {
    nb_rx_data = huart->NbRxDataToProcess;
 8030442:	f8b0 9068 	ldrh.w	r9, [r0, #104]	; 0x68
        /* Disable the UART Parity Error Interrupt and RXFT interrupt*/
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);

        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error)
           and RX FIFO Threshold interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 8030446:	f8df b150 	ldr.w	fp, [pc, #336]	; 8030598 <UART_RxISR_16BIT_FIFOEN+0x174>
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 803044a:	f04f 0a00 	mov.w	sl, #0
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 803044e:	f006 0601 	and.w	r6, r6, #1
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 8030452:	f1b9 0f00 	cmp.w	r9, #0
 8030456:	d001      	beq.n	803045c <UART_RxISR_16BIT_FIFOEN+0x38>
 8030458:	06ab      	lsls	r3, r5, #26
 803045a:	d420      	bmi.n	803049e <UART_RxISR_16BIT_FIFOEN+0x7a>

    /* When remaining number of bytes to receive is less than the RX FIFO
    threshold, next incoming frames are processed as if FIFO mode was
    disabled (i.e. one interrupt per received frame).
    */
    rxdatacount = huart->RxXferCount;
 803045c:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 8030460:	b29b      	uxth	r3, r3
    if ((rxdatacount != 0U) && (rxdatacount < huart->NbRxDataToProcess))
 8030462:	b1d3      	cbz	r3, 803049a <UART_RxISR_16BIT_FIFOEN+0x76>
 8030464:	f8b4 2068 	ldrh.w	r2, [r4, #104]	; 0x68
 8030468:	429a      	cmp	r2, r3
 803046a:	d916      	bls.n	803049a <UART_RxISR_16BIT_FIFOEN+0x76>
    {
      /* Disable the UART RXFT interrupt*/
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 803046c:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 803046e:	f102 0308 	add.w	r3, r2, #8
 8030472:	e853 3f00 	ldrex	r3, [r3]
 8030476:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 803047a:	3208      	adds	r2, #8
 803047c:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 8030480:	6822      	ldr	r2, [r4, #0]
 8030482:	2900      	cmp	r1, #0
 8030484:	d1f2      	bne.n	803046c <UART_RxISR_16BIT_FIFOEN+0x48>

      /* Update the RxISR function pointer */
      huart->RxISR = UART_RxISR_16BIT;
 8030486:	4b43      	ldr	r3, [pc, #268]	; (8030594 <UART_RxISR_16BIT_FIFOEN+0x170>)
 8030488:	6723      	str	r3, [r4, #112]	; 0x70
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 803048a:	e852 3f00 	ldrex	r3, [r2]

      /* Enable the UART Data Register Not Empty interrupt */
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
 803048e:	f043 0320 	orr.w	r3, r3, #32
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030492:	e842 3100 	strex	r1, r3, [r2]
 8030496:	2900      	cmp	r1, #0
 8030498:	d1f7      	bne.n	803048a <UART_RxISR_16BIT_FIFOEN+0x66>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 803049a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 803049e:	6823      	ldr	r3, [r4, #0]
      *tmp = (uint16_t)(uhdata & uhMask);
 80304a0:	6da2      	ldr	r2, [r4, #88]	; 0x58
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 80304a2:	6a59      	ldr	r1, [r3, #36]	; 0x24
      *tmp = (uint16_t)(uhdata & uhMask);
 80304a4:	4039      	ands	r1, r7
 80304a6:	f822 1b02 	strh.w	r1, [r2], #2
      huart->pRxBuffPtr += 2U;
 80304aa:	65a2      	str	r2, [r4, #88]	; 0x58
      huart->RxXferCount--;
 80304ac:	f8b4 205e 	ldrh.w	r2, [r4, #94]	; 0x5e
 80304b0:	3a01      	subs	r2, #1
 80304b2:	b292      	uxth	r2, r2
 80304b4:	f8a4 205e 	strh.w	r2, [r4, #94]	; 0x5e
      isrflags = READ_REG(huart->Instance->ISR);
 80304b8:	69dd      	ldr	r5, [r3, #28]
      if ((isrflags & (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE)) != 0U)
 80304ba:	0769      	lsls	r1, r5, #29
 80304bc:	d02a      	beq.n	8030514 <UART_RxISR_16BIT_FIFOEN+0xf0>
        if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 80304be:	07ea      	lsls	r2, r5, #31
 80304c0:	d50a      	bpl.n	80304d8 <UART_RxISR_16BIT_FIFOEN+0xb4>
 80304c2:	f418 7f80 	tst.w	r8, #256	; 0x100
 80304c6:	d007      	beq.n	80304d8 <UART_RxISR_16BIT_FIFOEN+0xb4>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 80304c8:	2201      	movs	r2, #1
 80304ca:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_PE;
 80304cc:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 80304d0:	f042 0201 	orr.w	r2, r2, #1
 80304d4:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
        if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 80304d8:	07a8      	lsls	r0, r5, #30
 80304da:	d508      	bpl.n	80304ee <UART_RxISR_16BIT_FIFOEN+0xca>
 80304dc:	b13e      	cbz	r6, 80304ee <UART_RxISR_16BIT_FIFOEN+0xca>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 80304de:	2202      	movs	r2, #2
 80304e0:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_FE;
 80304e2:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 80304e6:	f042 0204 	orr.w	r2, r2, #4
 80304ea:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 80304ee:	0769      	lsls	r1, r5, #29
 80304f0:	d508      	bpl.n	8030504 <UART_RxISR_16BIT_FIFOEN+0xe0>
 80304f2:	b13e      	cbz	r6, 8030504 <UART_RxISR_16BIT_FIFOEN+0xe0>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 80304f4:	2204      	movs	r2, #4
 80304f6:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_NE;
 80304f8:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 80304fc:	f043 0302 	orr.w	r3, r3, #2
 8030500:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
        if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 8030504:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 8030508:	b123      	cbz	r3, 8030514 <UART_RxISR_16BIT_FIFOEN+0xf0>
          HAL_UART_ErrorCallback(huart);
 803050a:	4620      	mov	r0, r4
 803050c:	f7ff fcb3 	bl	802fe76 <HAL_UART_ErrorCallback>
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 8030510:	f8c4 a08c 	str.w	sl, [r4, #140]	; 0x8c
      if (huart->RxXferCount == 0U)
 8030514:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 8030518:	b29b      	uxth	r3, r3
 803051a:	2b00      	cmp	r3, #0
 803051c:	d199      	bne.n	8030452 <UART_RxISR_16BIT_FIFOEN+0x2e>
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 803051e:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030520:	e852 3f00 	ldrex	r3, [r2]
 8030524:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030528:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 803052c:	6823      	ldr	r3, [r4, #0]
 803052e:	2900      	cmp	r1, #0
 8030530:	d1f5      	bne.n	803051e <UART_RxISR_16BIT_FIFOEN+0xfa>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030532:	f103 0208 	add.w	r2, r3, #8
 8030536:	e852 2f00 	ldrex	r2, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 803053a:	ea02 020b 	and.w	r2, r2, fp
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 803053e:	f103 0008 	add.w	r0, r3, #8
 8030542:	e840 2100 	strex	r1, r2, [r0]
 8030546:	2900      	cmp	r1, #0
 8030548:	d1f3      	bne.n	8030532 <UART_RxISR_16BIT_FIFOEN+0x10e>
        huart->RxState = HAL_UART_STATE_READY;
 803054a:	2220      	movs	r2, #32
 803054c:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8030550:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
        huart->RxISR = NULL;
 8030552:	6721      	str	r1, [r4, #112]	; 0x70
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8030554:	2a01      	cmp	r2, #1
 8030556:	d113      	bne.n	8030580 <UART_RxISR_16BIT_FIFOEN+0x15c>
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8030558:	66e1      	str	r1, [r4, #108]	; 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 803055a:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 803055e:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030562:	e843 2100 	strex	r1, r2, [r3]
 8030566:	2900      	cmp	r1, #0
 8030568:	d1f7      	bne.n	803055a <UART_RxISR_16BIT_FIFOEN+0x136>
          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 803056a:	69da      	ldr	r2, [r3, #28]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 803056c:	f8b4 105c 	ldrh.w	r1, [r4, #92]	; 0x5c
          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 8030570:	06d2      	lsls	r2, r2, #27
            __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 8030572:	bf44      	itt	mi
 8030574:	2210      	movmi	r2, #16
 8030576:	621a      	strmi	r2, [r3, #32]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8030578:	4620      	mov	r0, r4
 803057a:	f7ff fcac 	bl	802fed6 <HAL_UARTEx_RxEventCallback>
 803057e:	e768      	b.n	8030452 <UART_RxISR_16BIT_FIFOEN+0x2e>
          HAL_UART_RxCpltCallback(huart);
 8030580:	4620      	mov	r0, r4
 8030582:	f7fc fabb 	bl	802cafc <HAL_UART_RxCpltCallback>
 8030586:	e764      	b.n	8030452 <UART_RxISR_16BIT_FIFOEN+0x2e>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 8030588:	699a      	ldr	r2, [r3, #24]
 803058a:	f042 0208 	orr.w	r2, r2, #8
 803058e:	619a      	str	r2, [r3, #24]
}
 8030590:	e783      	b.n	803049a <UART_RxISR_16BIT_FIFOEN+0x76>
 8030592:	bf00      	nop
 8030594:	08030229 	.word	0x08030229
 8030598:	effffffe 	.word	0xeffffffe

0803059c <UART_SetConfig>:
{
 803059c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 803059e:	4604      	mov	r4, r0
  if (UART_INSTANCE_LOWPOWER(huart))
 80305a0:	6803      	ldr	r3, [r0, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80305a2:	6921      	ldr	r1, [r4, #16]
 80305a4:	68a2      	ldr	r2, [r4, #8]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80305a6:	681d      	ldr	r5, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80305a8:	69c0      	ldr	r0, [r0, #28]
 80305aa:	430a      	orrs	r2, r1
 80305ac:	6961      	ldr	r1, [r4, #20]
 80305ae:	430a      	orrs	r2, r1
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80305b0:	497f      	ldr	r1, [pc, #508]	; (80307b0 <UART_SetConfig+0x214>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80305b2:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80305b4:	4029      	ands	r1, r5
 80305b6:	430a      	orrs	r2, r1
 80305b8:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80305ba:	685a      	ldr	r2, [r3, #4]
 80305bc:	68e1      	ldr	r1, [r4, #12]
 80305be:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 80305c2:	430a      	orrs	r2, r1
 80305c4:	605a      	str	r2, [r3, #4]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 80305c6:	4a7b      	ldr	r2, [pc, #492]	; (80307b4 <UART_SetConfig+0x218>)
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 80305c8:	69a1      	ldr	r1, [r4, #24]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 80305ca:	4293      	cmp	r3, r2
    tmpreg |= huart->Init.OneBitSampling;
 80305cc:	bf1c      	itt	ne
 80305ce:	6a22      	ldrne	r2, [r4, #32]
 80305d0:	4311      	orrne	r1, r2
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 80305d2:	689a      	ldr	r2, [r3, #8]
 80305d4:	f022 426e 	bic.w	r2, r2, #3992977408	; 0xee000000
 80305d8:	f422 6230 	bic.w	r2, r2, #2816	; 0xb00
 80305dc:	430a      	orrs	r2, r1
 80305de:	609a      	str	r2, [r3, #8]
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 80305e0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80305e2:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80305e4:	f022 020f 	bic.w	r2, r2, #15
 80305e8:	430a      	orrs	r2, r1
 80305ea:	62da      	str	r2, [r3, #44]	; 0x2c
  UART_GETCLOCKSOURCE(huart, clocksource);
 80305ec:	4a72      	ldr	r2, [pc, #456]	; (80307b8 <UART_SetConfig+0x21c>)
 80305ee:	4293      	cmp	r3, r2
 80305f0:	d11c      	bne.n	803062c <UART_SetConfig+0x90>
  return (uint32_t)(READ_BIT(RCC->CCIPR, USARTx) | (USARTx << 16));
 80305f2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80305f6:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80305fa:	f003 0303 	and.w	r3, r3, #3
 80305fe:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
 8030602:	f5a3 3340 	sub.w	r3, r3, #196608	; 0x30000
 8030606:	3b01      	subs	r3, #1
 8030608:	2b02      	cmp	r3, #2
 803060a:	f200 80cb 	bhi.w	80307a4 <UART_SetConfig+0x208>
 803060e:	4a6b      	ldr	r2, [pc, #428]	; (80307bc <UART_SetConfig+0x220>)
 8030610:	5c9b      	ldrb	r3, [r3, r2]
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8030612:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 8030616:	f040 808c 	bne.w	8030732 <UART_SetConfig+0x196>
    switch (clocksource)
 803061a:	2b08      	cmp	r3, #8
 803061c:	d824      	bhi.n	8030668 <UART_SetConfig+0xcc>
 803061e:	e8df f003 	tbb	[pc, r3]
 8030622:	c462      	.short	0xc462
 8030624:	23832386 	.word	0x23832386
 8030628:	2323      	.short	0x2323
 803062a:	66          	.byte	0x66
 803062b:	00          	.byte	0x00
  UART_GETCLOCKSOURCE(huart, clocksource);
 803062c:	4a64      	ldr	r2, [pc, #400]	; (80307c0 <UART_SetConfig+0x224>)
 803062e:	4293      	cmp	r3, r2
 8030630:	d109      	bne.n	8030646 <UART_SetConfig+0xaa>
 8030632:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8030636:	4a63      	ldr	r2, [pc, #396]	; (80307c4 <UART_SetConfig+0x228>)
 8030638:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 803063c:	f003 030c 	and.w	r3, r3, #12
 8030640:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
 8030644:	e7e4      	b.n	8030610 <UART_SetConfig+0x74>
 8030646:	4a5b      	ldr	r2, [pc, #364]	; (80307b4 <UART_SetConfig+0x218>)
 8030648:	4293      	cmp	r3, r2
 803064a:	d10d      	bne.n	8030668 <UART_SetConfig+0xcc>
  return (uint32_t)(READ_BIT(RCC->CCIPR, LPUARTx));
 803064c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8030650:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8030654:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
 8030658:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 803065c:	d01a      	beq.n	8030694 <UART_SetConfig+0xf8>
 803065e:	d805      	bhi.n	803066c <UART_SetConfig+0xd0>
 8030660:	b153      	cbz	r3, 8030678 <UART_SetConfig+0xdc>
 8030662:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8030666:	d012      	beq.n	803068e <UART_SetConfig+0xf2>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8030668:	2001      	movs	r0, #1
 803066a:	e009      	b.n	8030680 <UART_SetConfig+0xe4>
  UART_GETCLOCKSOURCE(huart, clocksource);
 803066c:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 8030670:	d1fa      	bne.n	8030668 <UART_SetConfig+0xcc>
        pclk = (uint32_t) LSE_VALUE;
 8030672:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8030676:	e00e      	b.n	8030696 <UART_SetConfig+0xfa>
        pclk = HAL_RCC_GetPCLK1Freq();
 8030678:	f7fe fd40 	bl	802f0fc <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 803067c:	b958      	cbnz	r0, 8030696 <UART_SetConfig+0xfa>
 803067e:	2000      	movs	r0, #0
  huart->NbRxDataToProcess = 1;
 8030680:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 8030684:	66a3      	str	r3, [r4, #104]	; 0x68
  huart->RxISR = NULL;
 8030686:	2300      	movs	r3, #0
  huart->TxISR = NULL;
 8030688:	e9c4 331c 	strd	r3, r3, [r4, #112]	; 0x70
}
 803068c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        pclk = HAL_RCC_GetSysClockFreq();
 803068e:	f7fe f91f 	bl	802e8d0 <HAL_RCC_GetSysClockFreq>
        break;
 8030692:	e7f3      	b.n	803067c <UART_SetConfig+0xe0>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8030694:	484c      	ldr	r0, [pc, #304]	; (80307c8 <UART_SetConfig+0x22c>)
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 8030696:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8030698:	4b48      	ldr	r3, [pc, #288]	; (80307bc <UART_SetConfig+0x220>)
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 803069a:	6865      	ldr	r5, [r4, #4]
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 803069c:	eb03 0342 	add.w	r3, r3, r2, lsl #1
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 80306a0:	eb05 0145 	add.w	r1, r5, r5, lsl #1
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 80306a4:	8a1a      	ldrh	r2, [r3, #16]
 80306a6:	fbb0 f3f2 	udiv	r3, r0, r2
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 80306aa:	4299      	cmp	r1, r3
 80306ac:	d8dc      	bhi.n	8030668 <UART_SetConfig+0xcc>
 80306ae:	ebb3 3f05 	cmp.w	r3, r5, lsl #12
 80306b2:	d8d9      	bhi.n	8030668 <UART_SetConfig+0xcc>
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 80306b4:	2300      	movs	r3, #0
 80306b6:	2100      	movs	r1, #0
 80306b8:	f7fb fa44 	bl	802bb44 <__aeabi_uldivmod>
 80306bc:	020f      	lsls	r7, r1, #8
 80306be:	ea47 6710 	orr.w	r7, r7, r0, lsr #24
 80306c2:	0206      	lsls	r6, r0, #8
 80306c4:	0868      	lsrs	r0, r5, #1
 80306c6:	1830      	adds	r0, r6, r0
 80306c8:	462a      	mov	r2, r5
 80306ca:	f04f 0300 	mov.w	r3, #0
 80306ce:	f147 0100 	adc.w	r1, r7, #0
 80306d2:	f7fb fa37 	bl	802bb44 <__aeabi_uldivmod>
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 80306d6:	4b3d      	ldr	r3, [pc, #244]	; (80307cc <UART_SetConfig+0x230>)
 80306d8:	f5a0 7240 	sub.w	r2, r0, #768	; 0x300
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 80306dc:	429a      	cmp	r2, r3
 80306de:	d8c3      	bhi.n	8030668 <UART_SetConfig+0xcc>
        huart->Instance->BRR = usartdiv;
 80306e0:	6823      	ldr	r3, [r4, #0]
 80306e2:	60d8      	str	r0, [r3, #12]
 80306e4:	e7cb      	b.n	803067e <UART_SetConfig+0xe2>
        pclk = HAL_RCC_GetPCLK1Freq();
 80306e6:	f7fe fd09 	bl	802f0fc <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 80306ea:	2800      	cmp	r0, #0
 80306ec:	d0c7      	beq.n	803067e <UART_SetConfig+0xe2>
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 80306ee:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80306f0:	4b32      	ldr	r3, [pc, #200]	; (80307bc <UART_SetConfig+0x220>)
 80306f2:	6862      	ldr	r2, [r4, #4]
 80306f4:	eb03 0341 	add.w	r3, r3, r1, lsl #1
 80306f8:	8a1b      	ldrh	r3, [r3, #16]
 80306fa:	fbb0 f3f3 	udiv	r3, r0, r3
 80306fe:	0850      	lsrs	r0, r2, #1
 8030700:	eb00 0043 	add.w	r0, r0, r3, lsl #1
 8030704:	fbb0 f0f2 	udiv	r0, r0, r2
 8030708:	b283      	uxth	r3, r0
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 803070a:	f1a3 0110 	sub.w	r1, r3, #16
 803070e:	f64f 72ef 	movw	r2, #65519	; 0xffef
 8030712:	4291      	cmp	r1, r2
 8030714:	d8a8      	bhi.n	8030668 <UART_SetConfig+0xcc>
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 8030716:	f020 000f 	bic.w	r0, r0, #15
        huart->Instance->BRR = brrtemp;
 803071a:	6822      	ldr	r2, [r4, #0]
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 803071c:	b280      	uxth	r0, r0
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 803071e:	f3c3 0342 	ubfx	r3, r3, #1, #3
        huart->Instance->BRR = brrtemp;
 8030722:	4318      	orrs	r0, r3
 8030724:	60d0      	str	r0, [r2, #12]
 8030726:	e7aa      	b.n	803067e <UART_SetConfig+0xe2>
        pclk = HAL_RCC_GetSysClockFreq();
 8030728:	f7fe f8d2 	bl	802e8d0 <HAL_RCC_GetSysClockFreq>
        break;
 803072c:	e7dd      	b.n	80306ea <UART_SetConfig+0x14e>
        pclk = (uint32_t) HSI_VALUE;
 803072e:	4826      	ldr	r0, [pc, #152]	; (80307c8 <UART_SetConfig+0x22c>)
 8030730:	e7dd      	b.n	80306ee <UART_SetConfig+0x152>
    switch (clocksource)
 8030732:	2b08      	cmp	r3, #8
 8030734:	d898      	bhi.n	8030668 <UART_SetConfig+0xcc>
 8030736:	a201      	add	r2, pc, #4	; (adr r2, 803073c <UART_SetConfig+0x1a0>)
 8030738:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 803073c:	08030789 	.word	0x08030789
 8030740:	08030795 	.word	0x08030795
 8030744:	080307a1 	.word	0x080307a1
 8030748:	08030669 	.word	0x08030669
 803074c:	0803079b 	.word	0x0803079b
 8030750:	08030669 	.word	0x08030669
 8030754:	08030669 	.word	0x08030669
 8030758:	08030669 	.word	0x08030669
 803075c:	08030761 	.word	0x08030761
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8030760:	f44f 4000 	mov.w	r0, #32768	; 0x8000
      usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8030764:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8030766:	4b15      	ldr	r3, [pc, #84]	; (80307bc <UART_SetConfig+0x220>)
 8030768:	6862      	ldr	r2, [r4, #4]
 803076a:	eb03 0341 	add.w	r3, r3, r1, lsl #1
 803076e:	8a1b      	ldrh	r3, [r3, #16]
 8030770:	fbb0 f0f3 	udiv	r0, r0, r3
 8030774:	eb00 0052 	add.w	r0, r0, r2, lsr #1
 8030778:	fbb0 f0f2 	udiv	r0, r0, r2
 803077c:	b280      	uxth	r0, r0
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 803077e:	f1a0 0210 	sub.w	r2, r0, #16
 8030782:	f64f 73ef 	movw	r3, #65519	; 0xffef
 8030786:	e7a9      	b.n	80306dc <UART_SetConfig+0x140>
        pclk = HAL_RCC_GetPCLK1Freq();
 8030788:	f7fe fcb8 	bl	802f0fc <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 803078c:	2800      	cmp	r0, #0
 803078e:	f43f af76 	beq.w	803067e <UART_SetConfig+0xe2>
 8030792:	e7e7      	b.n	8030764 <UART_SetConfig+0x1c8>
        pclk = HAL_RCC_GetPCLK2Freq();
 8030794:	f7fe fcc2 	bl	802f11c <HAL_RCC_GetPCLK2Freq>
        break;
 8030798:	e7f8      	b.n	803078c <UART_SetConfig+0x1f0>
        pclk = HAL_RCC_GetSysClockFreq();
 803079a:	f7fe f899 	bl	802e8d0 <HAL_RCC_GetSysClockFreq>
        break;
 803079e:	e7f5      	b.n	803078c <UART_SetConfig+0x1f0>
        pclk = (uint32_t) HSI_VALUE;
 80307a0:	4809      	ldr	r0, [pc, #36]	; (80307c8 <UART_SetConfig+0x22c>)
 80307a2:	e7df      	b.n	8030764 <UART_SetConfig+0x1c8>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80307a4:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 80307a8:	d1f4      	bne.n	8030794 <UART_SetConfig+0x1f8>
        pclk = HAL_RCC_GetPCLK2Freq();
 80307aa:	f7fe fcb7 	bl	802f11c <HAL_RCC_GetPCLK2Freq>
        break;
 80307ae:	e79c      	b.n	80306ea <UART_SetConfig+0x14e>
 80307b0:	cfff69f3 	.word	0xcfff69f3
 80307b4:	40008000 	.word	0x40008000
 80307b8:	40013800 	.word	0x40013800
 80307bc:	0803ba00 	.word	0x0803ba00
 80307c0:	40004400 	.word	0x40004400
 80307c4:	07f7ba03 	.word	0x07f7ba03
 80307c8:	00f42400 	.word	0x00f42400
 80307cc:	000ffcff 	.word	0x000ffcff

080307d0 <UART_AdvFeatureConfig>:
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 80307d0:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80307d2:	07da      	lsls	r2, r3, #31
{
 80307d4:	b510      	push	{r4, lr}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 80307d6:	d506      	bpl.n	80307e6 <UART_AdvFeatureConfig+0x16>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 80307d8:	6801      	ldr	r1, [r0, #0]
 80307da:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 80307dc:	684a      	ldr	r2, [r1, #4]
 80307de:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 80307e2:	4322      	orrs	r2, r4
 80307e4:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 80307e6:	079c      	lsls	r4, r3, #30
 80307e8:	d506      	bpl.n	80307f8 <UART_AdvFeatureConfig+0x28>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 80307ea:	6801      	ldr	r1, [r0, #0]
 80307ec:	6b04      	ldr	r4, [r0, #48]	; 0x30
 80307ee:	684a      	ldr	r2, [r1, #4]
 80307f0:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80307f4:	4322      	orrs	r2, r4
 80307f6:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 80307f8:	0759      	lsls	r1, r3, #29
 80307fa:	d506      	bpl.n	803080a <UART_AdvFeatureConfig+0x3a>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 80307fc:	6801      	ldr	r1, [r0, #0]
 80307fe:	6b44      	ldr	r4, [r0, #52]	; 0x34
 8030800:	684a      	ldr	r2, [r1, #4]
 8030802:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8030806:	4322      	orrs	r2, r4
 8030808:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 803080a:	071a      	lsls	r2, r3, #28
 803080c:	d506      	bpl.n	803081c <UART_AdvFeatureConfig+0x4c>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 803080e:	6801      	ldr	r1, [r0, #0]
 8030810:	6b84      	ldr	r4, [r0, #56]	; 0x38
 8030812:	684a      	ldr	r2, [r1, #4]
 8030814:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8030818:	4322      	orrs	r2, r4
 803081a:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 803081c:	06dc      	lsls	r4, r3, #27
 803081e:	d506      	bpl.n	803082e <UART_AdvFeatureConfig+0x5e>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 8030820:	6801      	ldr	r1, [r0, #0]
 8030822:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 8030824:	688a      	ldr	r2, [r1, #8]
 8030826:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 803082a:	4322      	orrs	r2, r4
 803082c:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 803082e:	0699      	lsls	r1, r3, #26
 8030830:	d506      	bpl.n	8030840 <UART_AdvFeatureConfig+0x70>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 8030832:	6801      	ldr	r1, [r0, #0]
 8030834:	6c04      	ldr	r4, [r0, #64]	; 0x40
 8030836:	688a      	ldr	r2, [r1, #8]
 8030838:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 803083c:	4322      	orrs	r2, r4
 803083e:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 8030840:	065a      	lsls	r2, r3, #25
 8030842:	d50f      	bpl.n	8030864 <UART_AdvFeatureConfig+0x94>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8030844:	6801      	ldr	r1, [r0, #0]
 8030846:	6c44      	ldr	r4, [r0, #68]	; 0x44
 8030848:	684a      	ldr	r2, [r1, #4]
 803084a:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 803084e:	4322      	orrs	r2, r4
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8030850:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8030854:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8030856:	d105      	bne.n	8030864 <UART_AdvFeatureConfig+0x94>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 8030858:	684a      	ldr	r2, [r1, #4]
 803085a:	6c84      	ldr	r4, [r0, #72]	; 0x48
 803085c:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
 8030860:	4322      	orrs	r2, r4
 8030862:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 8030864:	061b      	lsls	r3, r3, #24
 8030866:	d506      	bpl.n	8030876 <UART_AdvFeatureConfig+0xa6>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 8030868:	6802      	ldr	r2, [r0, #0]
 803086a:	6cc1      	ldr	r1, [r0, #76]	; 0x4c
 803086c:	6853      	ldr	r3, [r2, #4]
 803086e:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 8030872:	430b      	orrs	r3, r1
 8030874:	6053      	str	r3, [r2, #4]
}
 8030876:	bd10      	pop	{r4, pc}

08030878 <UART_WaitOnFlagUntilTimeout>:
{
 8030878:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 803087c:	f8dd 8018 	ldr.w	r8, [sp, #24]
 8030880:	4604      	mov	r4, r0
 8030882:	460e      	mov	r6, r1
 8030884:	4615      	mov	r5, r2
 8030886:	461f      	mov	r7, r3
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8030888:	6822      	ldr	r2, [r4, #0]
 803088a:	69d3      	ldr	r3, [r2, #28]
 803088c:	ea36 0303 	bics.w	r3, r6, r3
 8030890:	bf0c      	ite	eq
 8030892:	2301      	moveq	r3, #1
 8030894:	2300      	movne	r3, #0
 8030896:	42ab      	cmp	r3, r5
 8030898:	d001      	beq.n	803089e <UART_WaitOnFlagUntilTimeout+0x26>
  return HAL_OK;
 803089a:	2000      	movs	r0, #0
 803089c:	e027      	b.n	80308ee <UART_WaitOnFlagUntilTimeout+0x76>
    if (Timeout != HAL_MAX_DELAY)
 803089e:	f1b8 3fff 	cmp.w	r8, #4294967295
 80308a2:	d0f2      	beq.n	803088a <UART_WaitOnFlagUntilTimeout+0x12>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80308a4:	f7fb fece 	bl	802c644 <HAL_GetTick>
 80308a8:	1bc0      	subs	r0, r0, r7
 80308aa:	4540      	cmp	r0, r8
 80308ac:	6820      	ldr	r0, [r4, #0]
 80308ae:	d802      	bhi.n	80308b6 <UART_WaitOnFlagUntilTimeout+0x3e>
 80308b0:	f1b8 0f00 	cmp.w	r8, #0
 80308b4:	d11d      	bne.n	80308f2 <UART_WaitOnFlagUntilTimeout+0x7a>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80308b6:	e850 3f00 	ldrex	r3, [r0]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |
 80308ba:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80308be:	e840 3200 	strex	r2, r3, [r0]
 80308c2:	2a00      	cmp	r2, #0
 80308c4:	d1f7      	bne.n	80308b6 <UART_WaitOnFlagUntilTimeout+0x3e>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80308c6:	f100 0308 	add.w	r3, r0, #8
 80308ca:	e853 3f00 	ldrex	r3, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80308ce:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80308d2:	f100 0108 	add.w	r1, r0, #8
 80308d6:	e841 3200 	strex	r2, r3, [r1]
 80308da:	2a00      	cmp	r2, #0
 80308dc:	d1f3      	bne.n	80308c6 <UART_WaitOnFlagUntilTimeout+0x4e>
        huart->gState = HAL_UART_STATE_READY;
 80308de:	2320      	movs	r3, #32
 80308e0:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
        huart->RxState = HAL_UART_STATE_READY;
 80308e4:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
          __HAL_UNLOCK(huart);
 80308e8:	f884 2080 	strb.w	r2, [r4, #128]	; 0x80
          return HAL_TIMEOUT;
 80308ec:	2003      	movs	r0, #3
}
 80308ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 80308f2:	6803      	ldr	r3, [r0, #0]
 80308f4:	075a      	lsls	r2, r3, #29
 80308f6:	d5c7      	bpl.n	8030888 <UART_WaitOnFlagUntilTimeout+0x10>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 80308f8:	69c3      	ldr	r3, [r0, #28]
 80308fa:	051b      	lsls	r3, r3, #20
 80308fc:	d5c4      	bpl.n	8030888 <UART_WaitOnFlagUntilTimeout+0x10>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 80308fe:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8030902:	6203      	str	r3, [r0, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030904:	e850 3f00 	ldrex	r3, [r0]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |
 8030908:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 803090c:	e840 3200 	strex	r2, r3, [r0]
 8030910:	2a00      	cmp	r2, #0
 8030912:	d1f7      	bne.n	8030904 <UART_WaitOnFlagUntilTimeout+0x8c>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030914:	f100 0308 	add.w	r3, r0, #8
 8030918:	e853 3f00 	ldrex	r3, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 803091c:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030920:	f100 0108 	add.w	r1, r0, #8
 8030924:	e841 3200 	strex	r2, r3, [r1]
 8030928:	2a00      	cmp	r2, #0
 803092a:	d1f3      	bne.n	8030914 <UART_WaitOnFlagUntilTimeout+0x9c>
          huart->gState = HAL_UART_STATE_READY;
 803092c:	2320      	movs	r3, #32
 803092e:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
          huart->RxState = HAL_UART_STATE_READY;
 8030932:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 8030936:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
 803093a:	e7d5      	b.n	80308e8 <UART_WaitOnFlagUntilTimeout+0x70>

0803093c <UART_CheckIdleState>:
{
 803093c:	b573      	push	{r0, r1, r4, r5, r6, lr}
 803093e:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8030940:	2600      	movs	r6, #0
 8030942:	f8c0 608c 	str.w	r6, [r0, #140]	; 0x8c
  tickstart = HAL_GetTick();
 8030946:	f7fb fe7d 	bl	802c644 <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 803094a:	6823      	ldr	r3, [r4, #0]
 803094c:	681b      	ldr	r3, [r3, #0]
 803094e:	071a      	lsls	r2, r3, #28
  tickstart = HAL_GetTick();
 8030950:	4605      	mov	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8030952:	d418      	bmi.n	8030986 <UART_CheckIdleState+0x4a>
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 8030954:	6823      	ldr	r3, [r4, #0]
 8030956:	681b      	ldr	r3, [r3, #0]
 8030958:	075b      	lsls	r3, r3, #29
 803095a:	d50a      	bpl.n	8030972 <UART_CheckIdleState+0x36>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 803095c:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 8030960:	9300      	str	r3, [sp, #0]
 8030962:	2200      	movs	r2, #0
 8030964:	462b      	mov	r3, r5
 8030966:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 803096a:	4620      	mov	r0, r4
 803096c:	f7ff ff84 	bl	8030878 <UART_WaitOnFlagUntilTimeout>
 8030970:	b9a8      	cbnz	r0, 803099e <UART_CheckIdleState+0x62>
  huart->gState = HAL_UART_STATE_READY;
 8030972:	2320      	movs	r3, #32
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8030974:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
 8030976:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  __HAL_UNLOCK(huart);
 803097a:	f884 0080 	strb.w	r0, [r4, #128]	; 0x80
  huart->RxState = HAL_UART_STATE_READY;
 803097e:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8030982:	66e0      	str	r0, [r4, #108]	; 0x6c
  return HAL_OK;
 8030984:	e00c      	b.n	80309a0 <UART_CheckIdleState+0x64>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8030986:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 803098a:	9300      	str	r3, [sp, #0]
 803098c:	4632      	mov	r2, r6
 803098e:	4603      	mov	r3, r0
 8030990:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 8030994:	4620      	mov	r0, r4
 8030996:	f7ff ff6f 	bl	8030878 <UART_WaitOnFlagUntilTimeout>
 803099a:	2800      	cmp	r0, #0
 803099c:	d0da      	beq.n	8030954 <UART_CheckIdleState+0x18>
      return HAL_TIMEOUT;
 803099e:	2003      	movs	r0, #3
}
 80309a0:	b002      	add	sp, #8
 80309a2:	bd70      	pop	{r4, r5, r6, pc}

080309a4 <HAL_UART_Init>:
{
 80309a4:	b510      	push	{r4, lr}
  if (huart == NULL)
 80309a6:	4604      	mov	r4, r0
 80309a8:	b350      	cbz	r0, 8030a00 <HAL_UART_Init+0x5c>
  if (huart->gState == HAL_UART_STATE_RESET)
 80309aa:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
 80309ae:	b91b      	cbnz	r3, 80309b8 <HAL_UART_Init+0x14>
    huart->Lock = HAL_UNLOCKED;
 80309b0:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
    HAL_UART_MspInit(huart);
 80309b4:	f7fb ffa0 	bl	802c8f8 <HAL_UART_MspInit>
  __HAL_UART_DISABLE(huart);
 80309b8:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 80309ba:	2324      	movs	r3, #36	; 0x24
 80309bc:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  __HAL_UART_DISABLE(huart);
 80309c0:	6813      	ldr	r3, [r2, #0]
 80309c2:	f023 0301 	bic.w	r3, r3, #1
 80309c6:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 80309c8:	4620      	mov	r0, r4
 80309ca:	f7ff fde7 	bl	803059c <UART_SetConfig>
 80309ce:	2801      	cmp	r0, #1
 80309d0:	d016      	beq.n	8030a00 <HAL_UART_Init+0x5c>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 80309d2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80309d4:	b113      	cbz	r3, 80309dc <HAL_UART_Init+0x38>
    UART_AdvFeatureConfig(huart);
 80309d6:	4620      	mov	r0, r4
 80309d8:	f7ff fefa 	bl	80307d0 <UART_AdvFeatureConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 80309dc:	6823      	ldr	r3, [r4, #0]
 80309de:	685a      	ldr	r2, [r3, #4]
 80309e0:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 80309e4:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 80309e6:	689a      	ldr	r2, [r3, #8]
 80309e8:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 80309ec:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 80309ee:	681a      	ldr	r2, [r3, #0]
 80309f0:	f042 0201 	orr.w	r2, r2, #1
  return (UART_CheckIdleState(huart));
 80309f4:	4620      	mov	r0, r4
  __HAL_UART_ENABLE(huart);
 80309f6:	601a      	str	r2, [r3, #0]
}
 80309f8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return (UART_CheckIdleState(huart));
 80309fc:	f7ff bf9e 	b.w	803093c <UART_CheckIdleState>
}
 8030a00:	2001      	movs	r0, #1
 8030a02:	bd10      	pop	{r4, pc}

08030a04 <UART_Start_Receive_IT>:
  UART_MASK_COMPUTATION(huart);
 8030a04:	6883      	ldr	r3, [r0, #8]
{
 8030a06:	b510      	push	{r4, lr}
  UART_MASK_COMPUTATION(huart);
 8030a08:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
  huart->pRxBuffPtr  = pData;
 8030a0c:	6581      	str	r1, [r0, #88]	; 0x58
  huart->RxISR       = NULL;
 8030a0e:	f04f 0100 	mov.w	r1, #0
  huart->RxXferSize  = Size;
 8030a12:	f8a0 205c 	strh.w	r2, [r0, #92]	; 0x5c
  huart->RxXferCount = Size;
 8030a16:	f8a0 205e 	strh.w	r2, [r0, #94]	; 0x5e
  huart->RxISR       = NULL;
 8030a1a:	6701      	str	r1, [r0, #112]	; 0x70
  UART_MASK_COMPUTATION(huart);
 8030a1c:	d147      	bne.n	8030aae <UART_Start_Receive_IT+0xaa>
 8030a1e:	6903      	ldr	r3, [r0, #16]
 8030a20:	2b00      	cmp	r3, #0
 8030a22:	d142      	bne.n	8030aaa <UART_Start_Receive_IT+0xa6>
 8030a24:	f240 13ff 	movw	r3, #511	; 0x1ff
 8030a28:	f8a0 3060 	strh.w	r3, [r0, #96]	; 0x60
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8030a2c:	2300      	movs	r3, #0
 8030a2e:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
  huart->RxState = HAL_UART_STATE_BUSY_RX;
 8030a32:	2322      	movs	r3, #34	; 0x22
 8030a34:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
  ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8030a38:	6801      	ldr	r1, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030a3a:	f101 0308 	add.w	r3, r1, #8
 8030a3e:	e853 3f00 	ldrex	r3, [r3]
 8030a42:	f043 0301 	orr.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030a46:	3108      	adds	r1, #8
 8030a48:	e841 3400 	strex	r4, r3, [r1]
   return(result);
 8030a4c:	6803      	ldr	r3, [r0, #0]
 8030a4e:	2c00      	cmp	r4, #0
 8030a50:	d1f2      	bne.n	8030a38 <UART_Start_Receive_IT+0x34>
  if ((huart->FifoMode == UART_FIFOMODE_ENABLE) && (Size >= huart->NbRxDataToProcess))
 8030a52:	6e44      	ldr	r4, [r0, #100]	; 0x64
 8030a54:	6881      	ldr	r1, [r0, #8]
 8030a56:	f1b4 5f00 	cmp.w	r4, #536870912	; 0x20000000
 8030a5a:	d13b      	bne.n	8030ad4 <UART_Start_Receive_IT+0xd0>
 8030a5c:	f8b0 4068 	ldrh.w	r4, [r0, #104]	; 0x68
 8030a60:	4294      	cmp	r4, r2
 8030a62:	d837      	bhi.n	8030ad4 <UART_Start_Receive_IT+0xd0>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8030a64:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 8030a68:	d132      	bne.n	8030ad0 <UART_Start_Receive_IT+0xcc>
 8030a6a:	6904      	ldr	r4, [r0, #16]
      huart->RxISR = UART_RxISR_16BIT_FIFOEN;
 8030a6c:	4a25      	ldr	r2, [pc, #148]	; (8030b04 <UART_Start_Receive_IT+0x100>)
 8030a6e:	4926      	ldr	r1, [pc, #152]	; (8030b08 <UART_Start_Receive_IT+0x104>)
 8030a70:	2c00      	cmp	r4, #0
 8030a72:	bf08      	it	eq
 8030a74:	460a      	moveq	r2, r1
 8030a76:	6702      	str	r2, [r0, #112]	; 0x70
    __HAL_UNLOCK(huart);
 8030a78:	2200      	movs	r2, #0
 8030a7a:	f880 2080 	strb.w	r2, [r0, #128]	; 0x80
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030a7e:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8030a82:	f442 7280 	orr.w	r2, r2, #256	; 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030a86:	e843 2100 	strex	r1, r2, [r3]
 8030a8a:	2900      	cmp	r1, #0
 8030a8c:	d1f7      	bne.n	8030a7e <UART_Start_Receive_IT+0x7a>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030a8e:	f103 0208 	add.w	r2, r3, #8
 8030a92:	e852 2f00 	ldrex	r2, [r2]
    ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 8030a96:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030a9a:	f103 0008 	add.w	r0, r3, #8
 8030a9e:	e840 2100 	strex	r1, r2, [r0]
 8030aa2:	2900      	cmp	r1, #0
 8030aa4:	d1f3      	bne.n	8030a8e <UART_Start_Receive_IT+0x8a>
}
 8030aa6:	2000      	movs	r0, #0
 8030aa8:	bd10      	pop	{r4, pc}
  UART_MASK_COMPUTATION(huart);
 8030aaa:	23ff      	movs	r3, #255	; 0xff
 8030aac:	e7bc      	b.n	8030a28 <UART_Start_Receive_IT+0x24>
 8030aae:	b923      	cbnz	r3, 8030aba <UART_Start_Receive_IT+0xb6>
 8030ab0:	6903      	ldr	r3, [r0, #16]
 8030ab2:	2b00      	cmp	r3, #0
 8030ab4:	d0f9      	beq.n	8030aaa <UART_Start_Receive_IT+0xa6>
 8030ab6:	237f      	movs	r3, #127	; 0x7f
 8030ab8:	e7b6      	b.n	8030a28 <UART_Start_Receive_IT+0x24>
 8030aba:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8030abe:	d104      	bne.n	8030aca <UART_Start_Receive_IT+0xc6>
 8030ac0:	6903      	ldr	r3, [r0, #16]
 8030ac2:	2b00      	cmp	r3, #0
 8030ac4:	d0f7      	beq.n	8030ab6 <UART_Start_Receive_IT+0xb2>
 8030ac6:	233f      	movs	r3, #63	; 0x3f
 8030ac8:	e7ae      	b.n	8030a28 <UART_Start_Receive_IT+0x24>
 8030aca:	f8a0 1060 	strh.w	r1, [r0, #96]	; 0x60
 8030ace:	e7ad      	b.n	8030a2c <UART_Start_Receive_IT+0x28>
      huart->RxISR = UART_RxISR_8BIT_FIFOEN;
 8030ad0:	4a0c      	ldr	r2, [pc, #48]	; (8030b04 <UART_Start_Receive_IT+0x100>)
 8030ad2:	e7d0      	b.n	8030a76 <UART_Start_Receive_IT+0x72>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8030ad4:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 8030ad8:	d112      	bne.n	8030b00 <UART_Start_Receive_IT+0xfc>
 8030ada:	6904      	ldr	r4, [r0, #16]
      huart->RxISR = UART_RxISR_16BIT;
 8030adc:	4a0b      	ldr	r2, [pc, #44]	; (8030b0c <UART_Start_Receive_IT+0x108>)
 8030ade:	490c      	ldr	r1, [pc, #48]	; (8030b10 <UART_Start_Receive_IT+0x10c>)
 8030ae0:	2c00      	cmp	r4, #0
 8030ae2:	bf08      	it	eq
 8030ae4:	460a      	moveq	r2, r1
 8030ae6:	6702      	str	r2, [r0, #112]	; 0x70
    __HAL_UNLOCK(huart);
 8030ae8:	2200      	movs	r2, #0
 8030aea:	f880 2080 	strb.w	r2, [r0, #128]	; 0x80
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030aee:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE);
 8030af2:	f442 7290 	orr.w	r2, r2, #288	; 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030af6:	e843 2100 	strex	r1, r2, [r3]
 8030afa:	2900      	cmp	r1, #0
 8030afc:	d1f7      	bne.n	8030aee <UART_Start_Receive_IT+0xea>
 8030afe:	e7d2      	b.n	8030aa6 <UART_Start_Receive_IT+0xa2>
      huart->RxISR = UART_RxISR_8BIT;
 8030b00:	4a02      	ldr	r2, [pc, #8]	; (8030b0c <UART_Start_Receive_IT+0x108>)
 8030b02:	e7f0      	b.n	8030ae6 <UART_Start_Receive_IT+0xe2>
 8030b04:	080302a9 	.word	0x080302a9
 8030b08:	08030425 	.word	0x08030425
 8030b0c:	08030265 	.word	0x08030265
 8030b10:	08030229 	.word	0x08030229

08030b14 <HAL_UART_Receive_IT>:
  if (huart->RxState == HAL_UART_STATE_READY)
 8030b14:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
 8030b18:	2b20      	cmp	r3, #32
{
 8030b1a:	b430      	push	{r4, r5}
  if (huart->RxState == HAL_UART_STATE_READY)
 8030b1c:	d11f      	bne.n	8030b5e <HAL_UART_Receive_IT+0x4a>
    if ((pData == NULL) || (Size == 0U))
 8030b1e:	b1d9      	cbz	r1, 8030b58 <HAL_UART_Receive_IT+0x44>
 8030b20:	b1d2      	cbz	r2, 8030b58 <HAL_UART_Receive_IT+0x44>
    __HAL_LOCK(huart);
 8030b22:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 8030b26:	2b01      	cmp	r3, #1
 8030b28:	d019      	beq.n	8030b5e <HAL_UART_Receive_IT+0x4a>
 8030b2a:	2301      	movs	r3, #1
 8030b2c:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8030b30:	2300      	movs	r3, #0
    if (!(IS_LPUART_INSTANCE(huart->Instance)))
 8030b32:	6804      	ldr	r4, [r0, #0]
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8030b34:	66c3      	str	r3, [r0, #108]	; 0x6c
    if (!(IS_LPUART_INSTANCE(huart->Instance)))
 8030b36:	4b0b      	ldr	r3, [pc, #44]	; (8030b64 <HAL_UART_Receive_IT+0x50>)
 8030b38:	429c      	cmp	r4, r3
 8030b3a:	d00a      	beq.n	8030b52 <HAL_UART_Receive_IT+0x3e>
      if(READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 8030b3c:	6863      	ldr	r3, [r4, #4]
 8030b3e:	021b      	lsls	r3, r3, #8
 8030b40:	d507      	bpl.n	8030b52 <HAL_UART_Receive_IT+0x3e>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030b42:	e854 3f00 	ldrex	r3, [r4]
        ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 8030b46:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030b4a:	e844 3500 	strex	r5, r3, [r4]
 8030b4e:	2d00      	cmp	r5, #0
 8030b50:	d1f7      	bne.n	8030b42 <HAL_UART_Receive_IT+0x2e>
}
 8030b52:	bc30      	pop	{r4, r5}
    return(UART_Start_Receive_IT(huart, pData, Size));
 8030b54:	f7ff bf56 	b.w	8030a04 <UART_Start_Receive_IT>
      return HAL_ERROR;
 8030b58:	2001      	movs	r0, #1
}
 8030b5a:	bc30      	pop	{r4, r5}
 8030b5c:	4770      	bx	lr
    return HAL_BUSY;
 8030b5e:	2002      	movs	r0, #2
 8030b60:	e7fb      	b.n	8030b5a <HAL_UART_Receive_IT+0x46>
 8030b62:	bf00      	nop
 8030b64:	40008000 	.word	0x40008000

08030b68 <UARTEx_SetNbDataToProcess>:
  uint8_t rx_fifo_threshold;
  uint8_t tx_fifo_threshold;
  static const uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
  static const uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};

  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 8030b68:	6e43      	ldr	r3, [r0, #100]	; 0x64
{
 8030b6a:	b510      	push	{r4, lr}
  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 8030b6c:	b91b      	cbnz	r3, 8030b76 <UARTEx_SetNbDataToProcess+0xe>
  {
    huart->NbTxDataToProcess = 1U;
    huart->NbRxDataToProcess = 1U;
 8030b6e:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 8030b72:	6683      	str	r3, [r0, #104]	; 0x68
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
                               (uint16_t)denominator[tx_fifo_threshold];
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
                               (uint16_t)denominator[rx_fifo_threshold];
  }
}
 8030b74:	bd10      	pop	{r4, pc}
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
 8030b76:	6803      	ldr	r3, [r0, #0]
 8030b78:	689c      	ldr	r4, [r3, #8]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 8030b7a:	689a      	ldr	r2, [r3, #8]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8030b7c:	4b0a      	ldr	r3, [pc, #40]	; (8030ba8 <UARTEx_SetNbDataToProcess+0x40>)
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 8030b7e:	0f52      	lsrs	r2, r2, #29
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8030b80:	5c99      	ldrb	r1, [r3, r2]
                               (uint16_t)denominator[tx_fifo_threshold];
 8030b82:	441a      	add	r2, r3
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8030b84:	00c9      	lsls	r1, r1, #3
                               (uint16_t)denominator[tx_fifo_threshold];
 8030b86:	7a12      	ldrb	r2, [r2, #8]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8030b88:	fbb1 f2f2 	udiv	r2, r1, r2
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8030b8c:	f3c4 6142 	ubfx	r1, r4, #25, #3
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8030b90:	f8a0 206a 	strh.w	r2, [r0, #106]	; 0x6a
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8030b94:	5c5a      	ldrb	r2, [r3, r1]
                               (uint16_t)denominator[rx_fifo_threshold];
 8030b96:	440b      	add	r3, r1
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8030b98:	00d2      	lsls	r2, r2, #3
                               (uint16_t)denominator[rx_fifo_threshold];
 8030b9a:	7a1b      	ldrb	r3, [r3, #8]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8030b9c:	fbb2 f3f3 	udiv	r3, r2, r3
 8030ba0:	f8a0 3068 	strh.w	r3, [r0, #104]	; 0x68
}
 8030ba4:	e7e6      	b.n	8030b74 <UARTEx_SetNbDataToProcess+0xc>
 8030ba6:	bf00      	nop
 8030ba8:	0803ba28 	.word	0x0803ba28

08030bac <HAL_UARTEx_WakeupCallback>:
}
 8030bac:	4770      	bx	lr

08030bae <HAL_UARTEx_RxFifoFullCallback>:
 8030bae:	4770      	bx	lr

08030bb0 <HAL_UARTEx_TxFifoEmptyCallback>:
 8030bb0:	4770      	bx	lr

08030bb2 <HAL_UARTEx_StopModeWakeUpSourceConfig>:
{
 8030bb2:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8030bb4:	ab04      	add	r3, sp, #16
 8030bb6:	e903 0006 	stmdb	r3, {r1, r2}
  __HAL_LOCK(huart);
 8030bba:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 8030bbe:	9902      	ldr	r1, [sp, #8]
 8030bc0:	2b01      	cmp	r3, #1
{
 8030bc2:	4604      	mov	r4, r0
  __HAL_LOCK(huart);
 8030bc4:	d03a      	beq.n	8030c3c <HAL_UARTEx_StopModeWakeUpSourceConfig+0x8a>
 8030bc6:	2301      	movs	r3, #1
 8030bc8:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
  huart->gState = HAL_UART_STATE_BUSY;
 8030bcc:	2324      	movs	r3, #36	; 0x24
 8030bce:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  __HAL_UART_DISABLE(huart);
 8030bd2:	6803      	ldr	r3, [r0, #0]
 8030bd4:	681a      	ldr	r2, [r3, #0]
 8030bd6:	f022 0201 	bic.w	r2, r2, #1
 8030bda:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_WUS, WakeUpSelection.WakeUpEvent);
 8030bdc:	689a      	ldr	r2, [r3, #8]
 8030bde:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8030be2:	430a      	orrs	r2, r1
 8030be4:	609a      	str	r2, [r3, #8]
  if (WakeUpSelection.WakeUpEvent == UART_WAKEUP_ON_ADDRESS)
 8030be6:	b971      	cbnz	r1, 8030c06 <HAL_UARTEx_StopModeWakeUpSourceConfig+0x54>
  MODIFY_REG(huart->Instance->CR2, USART_CR2_ADDM7, WakeUpSelection.AddressLength);
 8030be8:	6859      	ldr	r1, [r3, #4]
 8030bea:	f8bd 200c 	ldrh.w	r2, [sp, #12]
    UARTEx_Wakeup_AddressConfig(huart, WakeUpSelection);
 8030bee:	f89d 000e 	ldrb.w	r0, [sp, #14]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_ADDM7, WakeUpSelection.AddressLength);
 8030bf2:	f021 0110 	bic.w	r1, r1, #16
 8030bf6:	4311      	orrs	r1, r2
 8030bf8:	6059      	str	r1, [r3, #4]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, ((uint32_t)WakeUpSelection.Address << UART_CR2_ADDRESS_LSB_POS));
 8030bfa:	685a      	ldr	r2, [r3, #4]
 8030bfc:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 8030c00:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
 8030c04:	605a      	str	r2, [r3, #4]
  __HAL_UART_ENABLE(huart);
 8030c06:	681a      	ldr	r2, [r3, #0]
 8030c08:	f042 0201 	orr.w	r2, r2, #1
 8030c0c:	601a      	str	r2, [r3, #0]
  tickstart = HAL_GetTick();
 8030c0e:	f7fb fd19 	bl	802c644 <HAL_GetTick>
  if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8030c12:	f06f 427e 	mvn.w	r2, #4261412864	; 0xfe000000
  tickstart = HAL_GetTick();
 8030c16:	4603      	mov	r3, r0
  if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8030c18:	9200      	str	r2, [sp, #0]
 8030c1a:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 8030c1e:	2200      	movs	r2, #0
 8030c20:	4620      	mov	r0, r4
 8030c22:	f7ff fe29 	bl	8030878 <UART_WaitOnFlagUntilTimeout>
 8030c26:	b938      	cbnz	r0, 8030c38 <HAL_UARTEx_StopModeWakeUpSourceConfig+0x86>
    huart->gState = HAL_UART_STATE_READY;
 8030c28:	2320      	movs	r3, #32
 8030c2a:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  __HAL_UNLOCK(huart);
 8030c2e:	2300      	movs	r3, #0
 8030c30:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
}
 8030c34:	b004      	add	sp, #16
 8030c36:	bd10      	pop	{r4, pc}
    status = HAL_TIMEOUT;
 8030c38:	2003      	movs	r0, #3
 8030c3a:	e7f8      	b.n	8030c2e <HAL_UARTEx_StopModeWakeUpSourceConfig+0x7c>
  __HAL_LOCK(huart);
 8030c3c:	2002      	movs	r0, #2
 8030c3e:	e7f9      	b.n	8030c34 <HAL_UARTEx_StopModeWakeUpSourceConfig+0x82>

08030c40 <HAL_UARTEx_EnableStopMode>:
  __HAL_LOCK(huart);
 8030c40:	f890 2080 	ldrb.w	r2, [r0, #128]	; 0x80
 8030c44:	2a01      	cmp	r2, #1
{
 8030c46:	4603      	mov	r3, r0
  __HAL_LOCK(huart);
 8030c48:	d00e      	beq.n	8030c68 <HAL_UARTEx_EnableStopMode+0x28>
 8030c4a:	2201      	movs	r2, #1
 8030c4c:	f880 2080 	strb.w	r2, [r0, #128]	; 0x80
  ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_UESM);
 8030c50:	6819      	ldr	r1, [r3, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030c52:	e851 2f00 	ldrex	r2, [r1]
 8030c56:	f042 0202 	orr.w	r2, r2, #2
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030c5a:	e841 2000 	strex	r0, r2, [r1]
 8030c5e:	2800      	cmp	r0, #0
 8030c60:	d1f6      	bne.n	8030c50 <HAL_UARTEx_EnableStopMode+0x10>
  __HAL_UNLOCK(huart);
 8030c62:	f883 0080 	strb.w	r0, [r3, #128]	; 0x80
  return HAL_OK;
 8030c66:	4770      	bx	lr
  __HAL_LOCK(huart);
 8030c68:	2002      	movs	r0, #2
}
 8030c6a:	4770      	bx	lr

08030c6c <HAL_UARTEx_EnableFifoMode>:
{
 8030c6c:	b510      	push	{r4, lr}
  __HAL_LOCK(huart);
 8030c6e:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 8030c72:	2b01      	cmp	r3, #1
{
 8030c74:	4604      	mov	r4, r0
  __HAL_LOCK(huart);
 8030c76:	d01a      	beq.n	8030cae <HAL_UARTEx_EnableFifoMode+0x42>
 8030c78:	2301      	movs	r3, #1
 8030c7a:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
  huart->gState = HAL_UART_STATE_BUSY;
 8030c7e:	2324      	movs	r3, #36	; 0x24
 8030c80:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8030c84:	6803      	ldr	r3, [r0, #0]
 8030c86:	681a      	ldr	r2, [r3, #0]
  __HAL_UART_DISABLE(huart);
 8030c88:	6819      	ldr	r1, [r3, #0]
 8030c8a:	f021 0101 	bic.w	r1, r1, #1
 8030c8e:	6019      	str	r1, [r3, #0]
  SET_BIT(tmpcr1, USART_CR1_FIFOEN);
 8030c90:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
  huart->FifoMode = UART_FIFOMODE_ENABLE;
 8030c94:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
 8030c98:	6641      	str	r1, [r0, #100]	; 0x64
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8030c9a:	601a      	str	r2, [r3, #0]
  UARTEx_SetNbDataToProcess(huart);
 8030c9c:	f7ff ff64 	bl	8030b68 <UARTEx_SetNbDataToProcess>
  huart->gState = HAL_UART_STATE_READY;
 8030ca0:	2320      	movs	r3, #32
 8030ca2:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  __HAL_UNLOCK(huart);
 8030ca6:	2000      	movs	r0, #0
 8030ca8:	f884 0080 	strb.w	r0, [r4, #128]	; 0x80
}
 8030cac:	bd10      	pop	{r4, pc}
  __HAL_LOCK(huart);
 8030cae:	2002      	movs	r0, #2
 8030cb0:	e7fc      	b.n	8030cac <HAL_UARTEx_EnableFifoMode+0x40>

08030cb2 <HAL_UARTEx_SetTxFifoThreshold>:
{
 8030cb2:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(huart);
 8030cb4:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 8030cb8:	2b01      	cmp	r3, #1
{
 8030cba:	4604      	mov	r4, r0
  __HAL_LOCK(huart);
 8030cbc:	d01b      	beq.n	8030cf6 <HAL_UARTEx_SetTxFifoThreshold+0x44>
 8030cbe:	2301      	movs	r3, #1
 8030cc0:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
  huart->gState = HAL_UART_STATE_BUSY;
 8030cc4:	2324      	movs	r3, #36	; 0x24
 8030cc6:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8030cca:	6803      	ldr	r3, [r0, #0]
 8030ccc:	681d      	ldr	r5, [r3, #0]
  __HAL_UART_DISABLE(huart);
 8030cce:	681a      	ldr	r2, [r3, #0]
 8030cd0:	f022 0201 	bic.w	r2, r2, #1
 8030cd4:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
 8030cd6:	689a      	ldr	r2, [r3, #8]
 8030cd8:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
 8030cdc:	4311      	orrs	r1, r2
 8030cde:	6099      	str	r1, [r3, #8]
  UARTEx_SetNbDataToProcess(huart);
 8030ce0:	f7ff ff42 	bl	8030b68 <UARTEx_SetNbDataToProcess>
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8030ce4:	6803      	ldr	r3, [r0, #0]
 8030ce6:	601d      	str	r5, [r3, #0]
  huart->gState = HAL_UART_STATE_READY;
 8030ce8:	2320      	movs	r3, #32
 8030cea:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  __HAL_UNLOCK(huart);
 8030cee:	2000      	movs	r0, #0
 8030cf0:	f884 0080 	strb.w	r0, [r4, #128]	; 0x80
}
 8030cf4:	bd38      	pop	{r3, r4, r5, pc}
  __HAL_LOCK(huart);
 8030cf6:	2002      	movs	r0, #2
 8030cf8:	e7fc      	b.n	8030cf4 <HAL_UARTEx_SetTxFifoThreshold+0x42>

08030cfa <HAL_UARTEx_SetRxFifoThreshold>:
{
 8030cfa:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(huart);
 8030cfc:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 8030d00:	2b01      	cmp	r3, #1
{
 8030d02:	4604      	mov	r4, r0
  __HAL_LOCK(huart);
 8030d04:	d01b      	beq.n	8030d3e <HAL_UARTEx_SetRxFifoThreshold+0x44>
 8030d06:	2301      	movs	r3, #1
 8030d08:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
  huart->gState = HAL_UART_STATE_BUSY;
 8030d0c:	2324      	movs	r3, #36	; 0x24
 8030d0e:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8030d12:	6803      	ldr	r3, [r0, #0]
 8030d14:	681d      	ldr	r5, [r3, #0]
  __HAL_UART_DISABLE(huart);
 8030d16:	681a      	ldr	r2, [r3, #0]
 8030d18:	f022 0201 	bic.w	r2, r2, #1
 8030d1c:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
 8030d1e:	689a      	ldr	r2, [r3, #8]
 8030d20:	f022 6260 	bic.w	r2, r2, #234881024	; 0xe000000
 8030d24:	4311      	orrs	r1, r2
 8030d26:	6099      	str	r1, [r3, #8]
  UARTEx_SetNbDataToProcess(huart);
 8030d28:	f7ff ff1e 	bl	8030b68 <UARTEx_SetNbDataToProcess>
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8030d2c:	6803      	ldr	r3, [r0, #0]
 8030d2e:	601d      	str	r5, [r3, #0]
  huart->gState = HAL_UART_STATE_READY;
 8030d30:	2320      	movs	r3, #32
 8030d32:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  __HAL_UNLOCK(huart);
 8030d36:	2000      	movs	r0, #0
 8030d38:	f884 0080 	strb.w	r0, [r4, #128]	; 0x80
}
 8030d3c:	bd38      	pop	{r3, r4, r5, pc}
  __HAL_LOCK(huart);
 8030d3e:	2002      	movs	r0, #2
 8030d40:	e7fc      	b.n	8030d3c <HAL_UARTEx_SetRxFifoThreshold+0x42>
	...

08030d44 <SetRow>:
 * Fragmentation decoder algorithm utilities
 *=============================================================================
 */

static void SetRow( uint8_t *src, uint16_t row, uint16_t size )
{
 8030d44:	460b      	mov	r3, r1
    if( ( FragDecoder.Callbacks != NULL ) && ( FragDecoder.Callbacks->FragDecoderWrite != NULL ) )
 8030d46:	4907      	ldr	r1, [pc, #28]	; (8030d64 <SetRow+0x20>)
 8030d48:	6809      	ldr	r1, [r1, #0]
{
 8030d4a:	b430      	push	{r4, r5}
    if( ( FragDecoder.Callbacks != NULL ) && ( FragDecoder.Callbacks->FragDecoderWrite != NULL ) )
 8030d4c:	b139      	cbz	r1, 8030d5e <SetRow+0x1a>
 8030d4e:	684d      	ldr	r5, [r1, #4]
 8030d50:	b12d      	cbz	r5, 8030d5e <SetRow+0x1a>
    {
        FragDecoder.Callbacks->FragDecoderWrite( row * size, src, size );
 8030d52:	4601      	mov	r1, r0
 8030d54:	fb02 f003 	mul.w	r0, r2, r3
 8030d58:	462b      	mov	r3, r5
    }
}
 8030d5a:	bc30      	pop	{r4, r5}
        FragDecoder.Callbacks->FragDecoderWrite( row * size, src, size );
 8030d5c:	4718      	bx	r3
}
 8030d5e:	bc30      	pop	{r4, r5}
 8030d60:	4770      	bx	lr
 8030d62:	bf00      	nop
 8030d64:	20003f54 	.word	0x20003f54

08030d68 <GetRow>:

static void GetRow( uint8_t *dst, uint16_t row, uint16_t size )
{
 8030d68:	460b      	mov	r3, r1
    if( ( FragDecoder.Callbacks != NULL ) && ( FragDecoder.Callbacks->FragDecoderRead != NULL ) )
 8030d6a:	4907      	ldr	r1, [pc, #28]	; (8030d88 <GetRow+0x20>)
 8030d6c:	6809      	ldr	r1, [r1, #0]
{
 8030d6e:	b430      	push	{r4, r5}
    if( ( FragDecoder.Callbacks != NULL ) && ( FragDecoder.Callbacks->FragDecoderRead != NULL ) )
 8030d70:	b139      	cbz	r1, 8030d82 <GetRow+0x1a>
 8030d72:	688d      	ldr	r5, [r1, #8]
 8030d74:	b12d      	cbz	r5, 8030d82 <GetRow+0x1a>
    {
        FragDecoder.Callbacks->FragDecoderRead( row * size, dst, size );
 8030d76:	4601      	mov	r1, r0
 8030d78:	fb02 f003 	mul.w	r0, r2, r3
 8030d7c:	462b      	mov	r3, r5
    }
}
 8030d7e:	bc30      	pop	{r4, r5}
        FragDecoder.Callbacks->FragDecoderRead( row * size, dst, size );
 8030d80:	4718      	bx	r3
}
 8030d82:	bc30      	pop	{r4, r5}
 8030d84:	4770      	bx	lr
 8030d86:	bf00      	nop
 8030d88:	20003f54 	.word	0x20003f54

08030d8c <GetParity>:

static uint8_t GetParity( uint16_t index, uint8_t *matrixRow  )
{
    uint8_t parity;
    parity = matrixRow[index >> 3];
 8030d8c:	08c3      	lsrs	r3, r0, #3
    parity = ( parity >> ( 7 - ( index % 8 ) ) ) & 0x01;
 8030d8e:	43c0      	mvns	r0, r0
 8030d90:	5ccb      	ldrb	r3, [r1, r3]
 8030d92:	f000 0007 	and.w	r0, r0, #7
 8030d96:	fa43 f000 	asr.w	r0, r3, r0
    return parity;
}
 8030d9a:	f000 0001 	and.w	r0, r0, #1
 8030d9e:	4770      	bx	lr

08030da0 <SetParity>:

static void SetParity( uint16_t index, uint8_t *matrixRow, uint8_t parity )
{
    uint8_t mask = 0xFF - ( 1 << ( 7 - ( index % 8 ) ) );
 8030da0:	43c3      	mvns	r3, r0
 8030da2:	f003 0307 	and.w	r3, r3, #7
    parity = parity << ( 7 - ( index % 8 ) );
    matrixRow[index >> 3] = ( matrixRow[index >> 3] & mask ) + parity;
 8030da6:	08c0      	lsrs	r0, r0, #3
{
 8030da8:	b510      	push	{r4, lr}
    parity = parity << ( 7 - ( index % 8 ) );
 8030daa:	fa02 f403 	lsl.w	r4, r2, r3
    uint8_t mask = 0xFF - ( 1 << ( 7 - ( index % 8 ) ) );
 8030dae:	2201      	movs	r2, #1
 8030db0:	fa02 f303 	lsl.w	r3, r2, r3
    matrixRow[index >> 3] = ( matrixRow[index >> 3] & mask ) + parity;
 8030db4:	5c0a      	ldrb	r2, [r1, r0]
 8030db6:	ea22 0203 	bic.w	r2, r2, r3
 8030dba:	4422      	add	r2, r4
 8030dbc:	540a      	strb	r2, [r1, r0]
}
 8030dbe:	bd10      	pop	{r4, pc}

08030dc0 <XorDataLine>:
    }
    return false;
}

static void XorDataLine( uint8_t *line1, uint8_t *line2, int32_t size )
{
 8030dc0:	b530      	push	{r4, r5, lr}
 8030dc2:	3801      	subs	r0, #1
    for( int32_t i = 0; i < size; i++ )
 8030dc4:	2300      	movs	r3, #0
 8030dc6:	4293      	cmp	r3, r2
 8030dc8:	d100      	bne.n	8030dcc <XorDataLine+0xc>
    {
        line1[i] = line1[i] ^ line2[i];
    }
}
 8030dca:	bd30      	pop	{r4, r5, pc}
        line1[i] = line1[i] ^ line2[i];
 8030dcc:	5ccd      	ldrb	r5, [r1, r3]
 8030dce:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 8030dd2:	406c      	eors	r4, r5
 8030dd4:	7004      	strb	r4, [r0, #0]
    for( int32_t i = 0; i < size; i++ )
 8030dd6:	3301      	adds	r3, #1
 8030dd8:	e7f5      	b.n	8030dc6 <XorDataLine+0x6>

08030dda <XorParityLine>:

static void XorParityLine( uint8_t* line1, uint8_t* line2, int32_t size )
{
 8030dda:	e92d 41d8 	stmdb	sp!, {r3, r4, r6, r7, r8, lr}
 8030dde:	4606      	mov	r6, r0
 8030de0:	4688      	mov	r8, r1
 8030de2:	b297      	uxth	r7, r2
    for( int32_t i = 0; i < size; i++ )
 8030de4:	2400      	movs	r4, #0
 8030de6:	42bc      	cmp	r4, r7
 8030de8:	d101      	bne.n	8030dee <XorParityLine+0x14>
    {
        SetParity( i, line1, ( GetParity( i, line1 ) ^ GetParity( i, line2 ) ) );
    }
}
 8030dea:	e8bd 81d8 	ldmia.w	sp!, {r3, r4, r6, r7, r8, pc}
        SetParity( i, line1, ( GetParity( i, line1 ) ^ GetParity( i, line2 ) ) );
 8030dee:	4631      	mov	r1, r6
 8030df0:	4620      	mov	r0, r4
 8030df2:	f7ff ffcb 	bl	8030d8c <GetParity>
 8030df6:	4641      	mov	r1, r8
 8030df8:	4602      	mov	r2, r0
 8030dfa:	4620      	mov	r0, r4
 8030dfc:	f7ff ffc6 	bl	8030d8c <GetParity>
 8030e00:	4042      	eors	r2, r0
 8030e02:	b2d2      	uxtb	r2, r2
 8030e04:	4620      	mov	r0, r4
 8030e06:	4631      	mov	r1, r6
 8030e08:	3401      	adds	r4, #1
 8030e0a:	f7ff ffc9 	bl	8030da0 <SetParity>
    for( int32_t i = 0; i < size; i++ )
 8030e0e:	b2a4      	uxth	r4, r4
 8030e10:	e7e9      	b.n	8030de6 <XorParityLine+0xc>
	...

08030e14 <FragFindMissingFrags>:
 * \param [OUT] FragDecoder.FragNbMissingIndex[] array is updated in place
 */
static void FragFindMissingFrags( uint16_t counter )
{
    int32_t i;
    for( i = FragDecoder.Status.FragNbLastRx; i < ( counter - 1 ); i++ )
 8030e14:	4b13      	ldr	r3, [pc, #76]	; (8030e64 <FragFindMissingFrags+0x50>)
{
 8030e16:	b5f0      	push	{r4, r5, r6, r7, lr}
    for( i = FragDecoder.Status.FragNbLastRx; i < ( counter - 1 ); i++ )
 8030e18:	f8b3 6882 	ldrh.w	r6, [r3, #2178]	; 0x882
    {
        if( i < FragDecoder.FragNb )
 8030e1c:	889c      	ldrh	r4, [r3, #4]
 8030e1e:	f8b3 1880 	ldrh.w	r1, [r3, #2176]	; 0x880
    for( i = FragDecoder.Status.FragNbLastRx; i < ( counter - 1 ); i++ )
 8030e22:	4635      	mov	r5, r6
 8030e24:	2700      	movs	r7, #0
 8030e26:	1e42      	subs	r2, r0, #1
 8030e28:	42aa      	cmp	r2, r5
 8030e2a:	dc0f      	bgt.n	8030e4c <FragFindMissingFrags+0x38>
 8030e2c:	43f2      	mvns	r2, r6
 8030e2e:	4402      	add	r2, r0
 8030e30:	4286      	cmp	r6, r0
 8030e32:	bf28      	it	cs
 8030e34:	2200      	movcs	r2, #0
 8030e36:	4432      	add	r2, r6
 8030e38:	b10f      	cbz	r7, 8030e3e <FragFindMissingFrags+0x2a>
 8030e3a:	f8a3 1880 	strh.w	r1, [r3, #2176]	; 0x880
        {
            FragDecoder.Status.FragNbLost++;
            FragDecoder.FragNbMissingIndex[i] = FragDecoder.Status.FragNbLost;
        }
    }
    if( i < FragDecoder.FragNb )
 8030e3e:	4294      	cmp	r4, r2
    {
        FragDecoder.Status.FragNbLastRx = counter;
    }
    else
    {
        FragDecoder.Status.FragNbLastRx = FragDecoder.FragNb + 1;
 8030e40:	bfdc      	itt	le
 8030e42:	1c60      	addle	r0, r4, #1
 8030e44:	b280      	uxthle	r0, r0
 8030e46:	f8a3 0882 	strh.w	r0, [r3, #2178]	; 0x882
    }
}
 8030e4a:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if( i < FragDecoder.FragNb )
 8030e4c:	42ac      	cmp	r4, r5
 8030e4e:	dd06      	ble.n	8030e5e <FragFindMissingFrags+0x4a>
            FragDecoder.FragNbMissingIndex[i] = FragDecoder.Status.FragNbLost;
 8030e50:	eb03 0745 	add.w	r7, r3, r5, lsl #1
            FragDecoder.Status.FragNbLost++;
 8030e54:	3101      	adds	r1, #1
 8030e56:	b289      	uxth	r1, r1
            FragDecoder.FragNbMissingIndex[i] = FragDecoder.Status.FragNbLost;
 8030e58:	f8a7 12dc 	strh.w	r1, [r7, #732]	; 0x2dc
 8030e5c:	2701      	movs	r7, #1
    for( i = FragDecoder.Status.FragNbLastRx; i < ( counter - 1 ); i++ )
 8030e5e:	3501      	adds	r5, #1
 8030e60:	e7e2      	b.n	8030e28 <FragFindMissingFrags+0x14>
 8030e62:	bf00      	nop
 8030e64:	20003f54 	.word	0x20003f54

08030e68 <FragFindMissingIndex>:
 *
 * \retval counter The counter value associated to the x th missing frag
 */
static uint16_t FragFindMissingIndex( uint16_t x )
{
    for( uint16_t i = 0; i < FragDecoder.FragNb; i++ )
 8030e68:	4b09      	ldr	r3, [pc, #36]	; (8030e90 <FragFindMissingIndex+0x28>)
{
 8030e6a:	b530      	push	{r4, r5, lr}
    for( uint16_t i = 0; i < FragDecoder.FragNb; i++ )
 8030e6c:	2200      	movs	r2, #0
 8030e6e:	889c      	ldrh	r4, [r3, #4]
    {
        if( FragDecoder.FragNbMissingIndex[i] == ( x + 1 ) )
 8030e70:	1c41      	adds	r1, r0, #1
 8030e72:	f503 7337 	add.w	r3, r3, #732	; 0x2dc
 8030e76:	b290      	uxth	r0, r2
    for( uint16_t i = 0; i < FragDecoder.FragNb; i++ )
 8030e78:	4284      	cmp	r4, r0
 8030e7a:	d801      	bhi.n	8030e80 <FragFindMissingIndex+0x18>
        {
            return i;
        }
    }
    return 0;
 8030e7c:	2000      	movs	r0, #0
 8030e7e:	e005      	b.n	8030e8c <FragFindMissingIndex+0x24>
        if( FragDecoder.FragNbMissingIndex[i] == ( x + 1 ) )
 8030e80:	f833 5b02 	ldrh.w	r5, [r3], #2
 8030e84:	428d      	cmp	r5, r1
 8030e86:	f102 0201 	add.w	r2, r2, #1
 8030e8a:	d1f4      	bne.n	8030e76 <FragFindMissingIndex+0xe>
}
 8030e8c:	bd30      	pop	{r4, r5, pc}
 8030e8e:	bf00      	nop
 8030e90:	20003f54 	.word	0x20003f54

08030e94 <FragExtractLineFromBinaryMatrix>:
 * \param [IN] bitArray  Pointer to the bit array
 * \param [IN] rowIndex  Matrix row index
 * \param [IN] bitsInRow Number of bits in one row
 */
static void FragExtractLineFromBinaryMatrix( uint8_t* bitArray, uint16_t rowIndex, uint16_t bitsInRow )
{
 8030e94:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8030e98:	4680      	mov	r8, r0
 8030e9a:	4616      	mov	r6, r2
    uint32_t findByte = 0;
    uint32_t findBitInByte = 0;

    if( rowIndex > 0 )
 8030e9c:	460d      	mov	r5, r1
 8030e9e:	b309      	cbz	r1, 8030ee4 <FragExtractLineFromBinaryMatrix+0x50>
    {
        findByte      = ( rowIndex * bitsInRow - ( ( rowIndex * ( rowIndex - 1 ) ) >> 1 ) ) >> 3;
 8030ea0:	1e4b      	subs	r3, r1, #1
 8030ea2:	434b      	muls	r3, r1
 8030ea4:	fb01 f402 	mul.w	r4, r1, r2
 8030ea8:	eba4 0463 	sub.w	r4, r4, r3, asr #1
        findBitInByte = ( rowIndex * bitsInRow - ( ( rowIndex * ( rowIndex - 1 ) ) >> 1 ) ) % 8;
 8030eac:	4263      	negs	r3, r4
 8030eae:	f003 0307 	and.w	r3, r3, #7
        findByte      = ( rowIndex * bitsInRow - ( ( rowIndex * ( rowIndex - 1 ) ) >> 1 ) ) >> 3;
 8030eb2:	ea4f 07e4 	mov.w	r7, r4, asr #3
        findBitInByte = ( rowIndex * bitsInRow - ( ( rowIndex * ( rowIndex - 1 ) ) >> 1 ) ) % 8;
 8030eb6:	f04f 0900 	mov.w	r9, #0
 8030eba:	f004 0407 	and.w	r4, r4, #7
 8030ebe:	bf58      	it	pl
 8030ec0:	425c      	negpl	r4, r3
    }
    if( rowIndex > 0 )
    {
        for( uint16_t i = 0; i < rowIndex; i++ )
 8030ec2:	45a9      	cmp	r9, r5
 8030ec4:	fa1f f089 	uxth.w	r0, r9
 8030ec8:	d105      	bne.n	8030ed6 <FragExtractLineFromBinaryMatrix+0x42>
    }
    for( uint16_t i = rowIndex; i < bitsInRow; i++ )
    {
        SetParity( i,
                   bitArray, 
                   ( FragDecoder.MatrixM2B[findByte] >> ( 7 - findBitInByte ) ) & 0x01 );
 8030eca:	f8df 9048 	ldr.w	r9, [pc, #72]	; 8030f14 <FragExtractLineFromBinaryMatrix+0x80>
    for( uint16_t i = rowIndex; i < bitsInRow; i++ )
 8030ece:	42b5      	cmp	r5, r6
 8030ed0:	d30b      	bcc.n	8030eea <FragExtractLineFromBinaryMatrix+0x56>
        {
            findBitInByte = 0;
            findByte++;
        }
    }
}
 8030ed2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            SetParity( i, bitArray, 0 );
 8030ed6:	2200      	movs	r2, #0
 8030ed8:	4641      	mov	r1, r8
 8030eda:	f7ff ff61 	bl	8030da0 <SetParity>
        for( uint16_t i = 0; i < rowIndex; i++ )
 8030ede:	f109 0901 	add.w	r9, r9, #1
 8030ee2:	e7ee      	b.n	8030ec2 <FragExtractLineFromBinaryMatrix+0x2e>
    uint32_t findBitInByte = 0;
 8030ee4:	460c      	mov	r4, r1
    uint32_t findByte = 0;
 8030ee6:	460f      	mov	r7, r1
 8030ee8:	e7ef      	b.n	8030eca <FragExtractLineFromBinaryMatrix+0x36>
                   ( FragDecoder.MatrixM2B[findByte] >> ( 7 - findBitInByte ) ) & 0x01 );
 8030eea:	eb09 0307 	add.w	r3, r9, r7
        SetParity( i,
 8030eee:	4628      	mov	r0, r5
                   ( FragDecoder.MatrixM2B[findByte] >> ( 7 - findBitInByte ) ) & 0x01 );
 8030ef0:	7b1a      	ldrb	r2, [r3, #12]
 8030ef2:	f1c4 0307 	rsb	r3, r4, #7
 8030ef6:	411a      	asrs	r2, r3
        findBitInByte++;
 8030ef8:	3401      	adds	r4, #1
        SetParity( i,
 8030efa:	f002 0201 	and.w	r2, r2, #1
 8030efe:	4641      	mov	r1, r8
 8030f00:	f7ff ff4e 	bl	8030da0 <SetParity>
    for( uint16_t i = rowIndex; i < bitsInRow; i++ )
 8030f04:	3501      	adds	r5, #1
        if( findBitInByte == 8 )
 8030f06:	2c08      	cmp	r4, #8
            findByte++;
 8030f08:	bf04      	itt	eq
 8030f0a:	3701      	addeq	r7, #1
            findBitInByte = 0;
 8030f0c:	2400      	moveq	r4, #0
    for( uint16_t i = rowIndex; i < bitsInRow; i++ )
 8030f0e:	b2ad      	uxth	r5, r5
 8030f10:	e7dd      	b.n	8030ece <FragExtractLineFromBinaryMatrix+0x3a>
 8030f12:	bf00      	nop
 8030f14:	20003f54 	.word	0x20003f54

08030f18 <FragDecoderInit>:
{
 8030f18:	b510      	push	{r4, lr}
    FragDecoder.Callbacks = callbacks;
 8030f1a:	4c15      	ldr	r4, [pc, #84]	; (8030f70 <FragDecoderInit+0x58>)
    FragDecoder.Status.FragNbLost = 0;
 8030f1c:	2300      	movs	r3, #0
    FragDecoder.FragNb = fragNb;                                // FragNb = FRAG_MAX_SIZE
 8030f1e:	80a0      	strh	r0, [r4, #4]
    FragDecoder.FragSize = fragSize;                            // number of byte on a row
 8030f20:	71a1      	strb	r1, [r4, #6]
    FragDecoder.Status.FragNbLost = 0;
 8030f22:	f8c4 3880 	str.w	r3, [r4, #2176]	; 0x880
    FragDecoder.M2BLine = 0;
 8030f26:	60a3      	str	r3, [r4, #8]
    FragDecoder.Callbacks = callbacks;
 8030f28:	6022      	str	r2, [r4, #0]
    for( uint16_t i = 0; i < FRAG_MAX_NB; i++ )
 8030f2a:	f504 7137 	add.w	r1, r4, #732	; 0x2dc
    FragDecoder.M2BLine = 0;
 8030f2e:	f44f 7333 	mov.w	r3, #716	; 0x2cc
        FragDecoder.FragNbMissingIndex[i] = 1;
 8030f32:	2001      	movs	r0, #1
 8030f34:	3b01      	subs	r3, #1
 8030f36:	b29b      	uxth	r3, r3
 8030f38:	f821 0b02 	strh.w	r0, [r1], #2
    for( uint16_t i = 0; i < FRAG_MAX_NB; i++ )
 8030f3c:	2b00      	cmp	r3, #0
 8030f3e:	d1f9      	bne.n	8030f34 <FragDecoderInit+0x1c>
 8030f40:	490c      	ldr	r1, [pc, #48]	; (8030f74 <FragDecoderInit+0x5c>)
        FragDecoder.S[i] = 0;
 8030f42:	4618      	mov	r0, r3
    for( uint32_t i = 0; i < ( ( FRAG_MAX_REDUNDANCY >> 3 ) + 1 ); i++ )
 8030f44:	3301      	adds	r3, #1
 8030f46:	2b0a      	cmp	r3, #10
        FragDecoder.S[i] = 0;
 8030f48:	f801 0b01 	strb.w	r0, [r1], #1
    for( uint32_t i = 0; i < ( ( FRAG_MAX_REDUNDANCY >> 3 ) + 1 ); i++ )
 8030f4c:	d1fa      	bne.n	8030f44 <FragDecoderInit+0x2c>
 8030f4e:	490a      	ldr	r1, [pc, #40]	; (8030f78 <FragDecoderInit+0x60>)
    for( uint32_t i = 0; i < ( ( ( FRAG_MAX_REDUNDANCY >> 3 ) + 1 ) * FRAG_MAX_REDUNDANCY ); i++ )
 8030f50:	2300      	movs	r3, #0
       FragDecoder.MatrixM2B[i] = 0xFF;
 8030f52:	20ff      	movs	r0, #255	; 0xff
    for( uint32_t i = 0; i < ( ( ( FRAG_MAX_REDUNDANCY >> 3 ) + 1 ) * FRAG_MAX_REDUNDANCY ); i++ )
 8030f54:	3301      	adds	r3, #1
 8030f56:	f5b3 7f34 	cmp.w	r3, #720	; 0x2d0
       FragDecoder.MatrixM2B[i] = 0xFF;
 8030f5a:	f801 0b01 	strb.w	r0, [r1], #1
    for( uint32_t i = 0; i < ( ( ( FRAG_MAX_REDUNDANCY >> 3 ) + 1 ) * FRAG_MAX_REDUNDANCY ); i++ )
 8030f5e:	d1f9      	bne.n	8030f54 <FragDecoderInit+0x3c>
    if (FragDecoder.Callbacks->FragDecoderErase != NULL)
 8030f60:	6813      	ldr	r3, [r2, #0]
 8030f62:	b103      	cbz	r3, 8030f66 <FragDecoderInit+0x4e>
        FragDecoder.Callbacks->FragDecoderErase();
 8030f64:	4798      	blx	r3
    FragDecoder.Status.FragNbLost = 0;
 8030f66:	2300      	movs	r3, #0
 8030f68:	f8c4 3880 	str.w	r3, [r4, #2176]	; 0x880
}
 8030f6c:	bd10      	pop	{r4, pc}
 8030f6e:	bf00      	nop
 8030f70:	20003f54 	.word	0x20003f54
 8030f74:	200047c8 	.word	0x200047c8
 8030f78:	20003f60 	.word	0x20003f60

08030f7c <FragDecoderGetMaxFileSize>:
}
 8030f7c:	4800      	ldr	r0, [pc, #0]	; (8030f80 <FragDecoderGetMaxFileSize+0x4>)
 8030f7e:	4770      	bx	lr
 8030f80:	00014fa0 	.word	0x00014fa0

08030f84 <FragDecoderProcess>:
{
 8030f84:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8030f88:	b0bd      	sub	sp, #244	; 0xf4
 8030f8a:	4604      	mov	r4, r0
    UTIL_MEM_set_8(matrixRow, 0, (FRAG_MAX_NB >> 3) + 1);
 8030f8c:	225a      	movs	r2, #90	; 0x5a
 8030f8e:	a807      	add	r0, sp, #28
{
 8030f90:	460f      	mov	r7, r1
    UTIL_MEM_set_8(matrixRow, 0, (FRAG_MAX_NB >> 3) + 1);
 8030f92:	2100      	movs	r1, #0
 8030f94:	f009 ff8c 	bl	803aeb0 <UTIL_MEM_set_8>
    UTIL_MEM_set_8(matrixDataTemp, 0, FRAG_MAX_SIZE);
 8030f98:	2278      	movs	r2, #120	; 0x78
 8030f9a:	eb0d 0002 	add.w	r0, sp, r2
 8030f9e:	2100      	movs	r1, #0
 8030fa0:	f009 ff86 	bl	803aeb0 <UTIL_MEM_set_8>
    FragDecoder.Status.FragNbRx = fragCounter;
 8030fa4:	4eba      	ldr	r6, [pc, #744]	; (8031290 <FragDecoderProcess+0x30c>)
    UTIL_MEM_set_8(dataTempVector, 0, (FRAG_MAX_REDUNDANCY >> 3) + 1);
 8030fa6:	220a      	movs	r2, #10
 8030fa8:	2100      	movs	r1, #0
 8030faa:	a801      	add	r0, sp, #4
 8030fac:	f009 ff80 	bl	803aeb0 <UTIL_MEM_set_8>
    UTIL_MEM_set_8(dataTempVector2, 0, (FRAG_MAX_REDUNDANCY >> 3) + 1);
 8030fb0:	220a      	movs	r2, #10
 8030fb2:	2100      	movs	r1, #0
 8030fb4:	a804      	add	r0, sp, #16
 8030fb6:	f009 ff7b 	bl	803aeb0 <UTIL_MEM_set_8>
    if( fragCounter < FragDecoder.Status.FragNbLastRx )
 8030fba:	f8b6 3882 	ldrh.w	r3, [r6, #2178]	; 0x882
    FragDecoder.Status.FragNbRx = fragCounter;
 8030fbe:	f8a6 487e 	strh.w	r4, [r6, #2174]	; 0x87e
    if( fragCounter < FragDecoder.Status.FragNbLastRx )
 8030fc2:	42a3      	cmp	r3, r4
 8030fc4:	4635      	mov	r5, r6
 8030fc6:	d904      	bls.n	8030fd2 <FragDecoderProcess+0x4e>
        return FRAG_SESSION_ONGOING;  // Drop frame out of order
 8030fc8:	f04f 30ff 	mov.w	r0, #4294967295
}
 8030fcc:	b03d      	add	sp, #244	; 0xf4
 8030fce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( fragCounter < ( FragDecoder.FragNb + 1 ) )
 8030fd2:	88b3      	ldrh	r3, [r6, #4]
 8030fd4:	42a3      	cmp	r3, r4
 8030fd6:	d318      	bcc.n	803100a <FragDecoderProcess+0x86>
        SetRow( rawData, fragCounter - 1, FragDecoder.FragSize );
 8030fd8:	1e61      	subs	r1, r4, #1
 8030fda:	79b2      	ldrb	r2, [r6, #6]
 8030fdc:	b289      	uxth	r1, r1
 8030fde:	4638      	mov	r0, r7
 8030fe0:	f7ff feb0 	bl	8030d44 <SetRow>
        FragDecoder.FragNbMissingIndex[fragCounter - 1] = 0;
 8030fe4:	f204 136b 	addw	r3, r4, #363	; 0x16b
 8030fe8:	eb06 0343 	add.w	r3, r6, r3, lsl #1
 8030fec:	2200      	movs	r2, #0
        FragFindMissingFrags( fragCounter );
 8030fee:	4620      	mov	r0, r4
        FragDecoder.FragNbMissingIndex[fragCounter - 1] = 0;
 8030ff0:	809a      	strh	r2, [r3, #4]
        FragFindMissingFrags( fragCounter );
 8030ff2:	f7ff ff0f 	bl	8030e14 <FragFindMissingFrags>
        if ((fragCounter == FragDecoder.FragNb) && (FragDecoder.Status.FragNbLost == 0U))
 8030ff6:	88b3      	ldrh	r3, [r6, #4]
 8030ff8:	42a3      	cmp	r3, r4
 8030ffa:	d1e5      	bne.n	8030fc8 <FragDecoderProcess+0x44>
 8030ffc:	f8b6 0880 	ldrh.w	r0, [r6, #2176]	; 0x880
 8031000:	3800      	subs	r0, #0
 8031002:	bf18      	it	ne
 8031004:	2001      	movne	r0, #1
 8031006:	4240      	negs	r0, r0
 8031008:	e7e0      	b.n	8030fcc <FragDecoderProcess+0x48>
        if( FragDecoder.Status.FragNbLost > FRAG_MAX_REDUNDANCY )
 803100a:	f8b6 3880 	ldrh.w	r3, [r6, #2176]	; 0x880
 803100e:	2b48      	cmp	r3, #72	; 0x48
 8031010:	d904      	bls.n	803101c <FragDecoderProcess+0x98>
           FragDecoder.Status.MatrixError = 1;
 8031012:	2301      	movs	r3, #1
 8031014:	f886 3884 	strb.w	r3, [r6, #2180]	; 0x884
           return FRAG_SESSION_FINISHED;
 8031018:	2000      	movs	r0, #0
 803101a:	e7d7      	b.n	8030fcc <FragDecoderProcess+0x48>
        FragFindMissingFrags( fragCounter );
 803101c:	4620      	mov	r0, r4
 803101e:	f7ff fef9 	bl	8030e14 <FragFindMissingFrags>
        if( FragDecoder.Status.FragNbLost == 0 )
 8031022:	f8b6 0880 	ldrh.w	r0, [r6, #2176]	; 0x880
 8031026:	2800      	cmp	r0, #0
 8031028:	d0d0      	beq.n	8030fcc <FragDecoderProcess+0x48>
        FragGetParityMatrixRow( fragCounter - FragDecoder.FragNb, FragDecoder.FragNb, matrixRow );
 803102a:	f8b6 9004 	ldrh.w	r9, [r6, #4]
    if( IsPowerOfTwo( m ) != false )
 803102e:	2300      	movs	r3, #0
        FragGetParityMatrixRow( fragCounter - FragDecoder.FragNb, FragDecoder.FragNb, matrixRow );
 8031030:	eba4 0409 	sub.w	r4, r4, r9
    uint8_t sumBit = 0;
 8031034:	461e      	mov	r6, r3
        sumBit += ( x & ( 1 << i ) ) >> i;
 8031036:	2101      	movs	r1, #1
 8031038:	fa01 f203 	lsl.w	r2, r1, r3
 803103c:	ea02 0209 	and.w	r2, r2, r9
 8031040:	40da      	lsrs	r2, r3
 8031042:	3301      	adds	r3, #1
 8031044:	4416      	add	r6, r2
    for( uint8_t i = 0; i < 32; i++ )
 8031046:	2b20      	cmp	r3, #32
        sumBit += ( x & ( 1 << i ) ) >> i;
 8031048:	b2f6      	uxtb	r6, r6
    for( uint8_t i = 0; i < 32; i++ )
 803104a:	d1f5      	bne.n	8031038 <FragDecoderProcess+0xb4>
    if( sumBit == 1 )
 803104c:	1e73      	subs	r3, r6, #1
 803104e:	425e      	negs	r6, r3
    x = 1 + ( 1001 * n );
 8031050:	f240 30e9 	movw	r0, #1001	; 0x3e9
 8031054:	fb00 f404 	mul.w	r4, r0, r4
    if( sumBit == 1 )
 8031058:	415e      	adcs	r6, r3
    for( uint8_t i = 0; i < ( ( m >> 3 ) + 1 ); i++ )
 803105a:	2300      	movs	r3, #0
    x = 1 + ( 1001 * n );
 803105c:	3401      	adds	r4, #1
    for( uint8_t i = 0; i < ( ( m >> 3 ) + 1 ); i++ )
 803105e:	ea4f 02e9 	mov.w	r2, r9, asr #3
        matrixRow[i] = 0;
 8031062:	4618      	mov	r0, r3
 8031064:	a93c      	add	r1, sp, #240	; 0xf0
 8031066:	4419      	add	r1, r3
    for( uint8_t i = 0; i < ( ( m >> 3 ) + 1 ); i++ )
 8031068:	3301      	adds	r3, #1
 803106a:	b2db      	uxtb	r3, r3
 803106c:	429a      	cmp	r2, r3
        matrixRow[i] = 0;
 803106e:	f801 0cd4 	strb.w	r0, [r1, #-212]
    for( uint8_t i = 0; i < ( ( m >> 3 ) + 1 ); i++ )
 8031072:	daf7      	bge.n	8031064 <FragDecoderProcess+0xe0>
    while( nbCoeff < ( m >> 1 ) )
 8031074:	ea4f 0b69 	mov.w	fp, r9, asr #1
    int32_t nbCoeff = 0;
 8031078:	f04f 0a00 	mov.w	sl, #0
            r = x % ( m + mTemp );
 803107c:	444e      	add	r6, r9
    while( nbCoeff < ( m >> 1 ) )
 803107e:	45da      	cmp	sl, fp
 8031080:	db0c      	blt.n	803109c <FragDecoderProcess+0x118>
        for( int32_t i = 0; i < FragDecoder.FragNb; i++ )
 8031082:	2600      	movs	r6, #0
    int32_t first = 0;
 8031084:	46b0      	mov	r8, r6
        for( int32_t i = 0; i < FragDecoder.FragNb; i++ )
 8031086:	88ab      	ldrh	r3, [r5, #4]
 8031088:	42b3      	cmp	r3, r6
 803108a:	dc28      	bgt.n	80310de <FragDecoderProcess+0x15a>
        firstOneInRow = BitArrayFindFirstOne( dataTempVector, FragDecoder.Status.FragNbLost );
 803108c:	f8b5 6880 	ldrh.w	r6, [r5, #2176]	; 0x880
    for( uint16_t i = 0; i < size; i++)
 8031090:	2200      	movs	r2, #0
 8031092:	b294      	uxth	r4, r2
 8031094:	42a6      	cmp	r6, r4
 8031096:	d848      	bhi.n	803112a <FragDecoderProcess+0x1a6>
    return 0;
 8031098:	2400      	movs	r4, #0
 803109a:	e04e      	b.n	803113a <FragDecoderProcess+0x1b6>
    return ( value >> 1 ) + ( ( b0 ^ b1 ) << 22 );
 803109c:	ea84 1364 	eor.w	r3, r4, r4, asr #5
 80310a0:	059b      	lsls	r3, r3, #22
 80310a2:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 80310a6:	eb03 0464 	add.w	r4, r3, r4, asr #1
            r = x % ( m + mTemp );
 80310aa:	fb94 f8f6 	sdiv	r8, r4, r6
 80310ae:	fb06 4818 	mls	r8, r6, r8, r4
        while( r >= m )
 80310b2:	45c1      	cmp	r9, r8
 80310b4:	ddf2      	ble.n	803109c <FragDecoderProcess+0x118>
        if ((GetParity(r, matrixRow) == 0) || (LmhpFragmentationGetPackageVersion() == 1U))
 80310b6:	fa1f f888 	uxth.w	r8, r8
 80310ba:	a907      	add	r1, sp, #28
 80310bc:	4640      	mov	r0, r8
 80310be:	f7ff fe65 	bl	8030d8c <GetParity>
 80310c2:	b938      	cbnz	r0, 80310d4 <FragDecoderProcess+0x150>
            SetParity(r, matrixRow, 1);
 80310c4:	2201      	movs	r2, #1
 80310c6:	a907      	add	r1, sp, #28
 80310c8:	4640      	mov	r0, r8
 80310ca:	f7ff fe69 	bl	8030da0 <SetParity>
            nbCoeff += 1;
 80310ce:	f10a 0a01 	add.w	sl, sl, #1
 80310d2:	e7d4      	b.n	803107e <FragDecoderProcess+0xfa>
        if ((GetParity(r, matrixRow) == 0) || (LmhpFragmentationGetPackageVersion() == 1U))
 80310d4:	f001 fbb8 	bl	8032848 <LmhpFragmentationGetPackageVersion>
 80310d8:	2801      	cmp	r0, #1
 80310da:	d1d0      	bne.n	803107e <FragDecoderProcess+0xfa>
 80310dc:	e7f2      	b.n	80310c4 <FragDecoderProcess+0x140>
            if( GetParity( i , matrixRow ) == 1 )
 80310de:	fa1f f986 	uxth.w	r9, r6
 80310e2:	a907      	add	r1, sp, #28
 80310e4:	4648      	mov	r0, r9
 80310e6:	f7ff fe51 	bl	8030d8c <GetParity>
 80310ea:	2801      	cmp	r0, #1
 80310ec:	4604      	mov	r4, r0
 80310ee:	d112      	bne.n	8031116 <FragDecoderProcess+0x192>
                if( FragDecoder.FragNbMissingIndex[i] == 0 )
 80310f0:	eb05 0346 	add.w	r3, r5, r6, lsl #1
 80310f4:	f8b3 22dc 	ldrh.w	r2, [r3, #732]	; 0x2dc
 80310f8:	b97a      	cbnz	r2, 803111a <FragDecoderProcess+0x196>
                    SetParity( i, matrixRow, 0 );
 80310fa:	a907      	add	r1, sp, #28
 80310fc:	4648      	mov	r0, r9
 80310fe:	f7ff fe4f 	bl	8030da0 <SetParity>
                    GetRow( matrixDataTemp, i, FragDecoder.FragSize );
 8031102:	79aa      	ldrb	r2, [r5, #6]
 8031104:	4649      	mov	r1, r9
 8031106:	a81e      	add	r0, sp, #120	; 0x78
 8031108:	f7ff fe2e 	bl	8030d68 <GetRow>
                    XorDataLine( rawData, matrixDataTemp, FragDecoder.FragSize );
 803110c:	79aa      	ldrb	r2, [r5, #6]
 803110e:	a91e      	add	r1, sp, #120	; 0x78
 8031110:	4638      	mov	r0, r7
 8031112:	f7ff fe55 	bl	8030dc0 <XorDataLine>
        for( int32_t i = 0; i < FragDecoder.FragNb; i++ )
 8031116:	3601      	adds	r6, #1
 8031118:	e7b5      	b.n	8031086 <FragDecoderProcess+0x102>
                    SetParity( FragDecoder.FragNbMissingIndex[i] - 1, dataTempVector, 1 );
 803111a:	1e50      	subs	r0, r2, #1
 803111c:	a901      	add	r1, sp, #4
 803111e:	4622      	mov	r2, r4
 8031120:	b280      	uxth	r0, r0
 8031122:	f7ff fe3d 	bl	8030da0 <SetParity>
                        first = 1;
 8031126:	46a0      	mov	r8, r4
 8031128:	e7f5      	b.n	8031116 <FragDecoderProcess+0x192>
        if ( GetParity( i, bitArray ) == 1 )
 803112a:	a901      	add	r1, sp, #4
 803112c:	4620      	mov	r0, r4
 803112e:	f7ff fe2d 	bl	8030d8c <GetParity>
 8031132:	2801      	cmp	r0, #1
 8031134:	f102 0201 	add.w	r2, r2, #1
 8031138:	d1ab      	bne.n	8031092 <FragDecoderProcess+0x10e>
        if( first > 0 )
 803113a:	f1b8 0f00 	cmp.w	r8, #0
 803113e:	f43f af43 	beq.w	8030fc8 <FragDecoderProcess+0x44>
            while( GetParity( firstOneInRow, FragDecoder.S ) == 1 )
 8031142:	f8df 8150 	ldr.w	r8, [pc, #336]	; 8031294 <FragDecoderProcess+0x310>
 8031146:	4641      	mov	r1, r8
 8031148:	4620      	mov	r0, r4
 803114a:	f7ff fe1f 	bl	8030d8c <GetParity>
 803114e:	2801      	cmp	r0, #1
 8031150:	f8b5 2880 	ldrh.w	r2, [r5, #2176]	; 0x880
 8031154:	d004      	beq.n	8031160 <FragDecoderProcess+0x1dc>
static void FragPushLineToBinaryMatrix( uint8_t *bitArray, uint16_t rowIndex, uint16_t bitsInRow )
{
    uint32_t findByte = 0;
    uint32_t findBitInByte = 0;

    if ( rowIndex > 0) {
 8031156:	2c00      	cmp	r4, #0
 8031158:	d15b      	bne.n	8031212 <FragDecoderProcess+0x28e>
    uint32_t findBitInByte = 0;
 803115a:	4626      	mov	r6, r4
    uint32_t findByte = 0;
 803115c:	46a1      	mov	r9, r4
 803115e:	e067      	b.n	8031230 <FragDecoderProcess+0x2ac>
                FragExtractLineFromBinaryMatrix( dataTempVector2, firstOneInRow, FragDecoder.Status.FragNbLost );
 8031160:	4621      	mov	r1, r4
 8031162:	a804      	add	r0, sp, #16
 8031164:	f7ff fe96 	bl	8030e94 <FragExtractLineFromBinaryMatrix>
                XorParityLine( dataTempVector, dataTempVector2, FragDecoder.Status.FragNbLost );
 8031168:	f8b5 2880 	ldrh.w	r2, [r5, #2176]	; 0x880
 803116c:	a904      	add	r1, sp, #16
 803116e:	a801      	add	r0, sp, #4
 8031170:	f7ff fe33 	bl	8030dda <XorParityLine>
                li = FragFindMissingIndex( firstOneInRow );
 8031174:	4620      	mov	r0, r4
 8031176:	f7ff fe77 	bl	8030e68 <FragFindMissingIndex>
                GetRow( matrixDataTemp, li, FragDecoder.FragSize );
 803117a:	79aa      	ldrb	r2, [r5, #6]
                li = FragFindMissingIndex( firstOneInRow );
 803117c:	4601      	mov	r1, r0
                GetRow( matrixDataTemp, li, FragDecoder.FragSize );
 803117e:	a81e      	add	r0, sp, #120	; 0x78
 8031180:	f7ff fdf2 	bl	8030d68 <GetRow>
                XorDataLine( rawData, matrixDataTemp, FragDecoder.FragSize );
 8031184:	79aa      	ldrb	r2, [r5, #6]
 8031186:	a91e      	add	r1, sp, #120	; 0x78
 8031188:	4638      	mov	r0, r7
 803118a:	f7ff fe19 	bl	8030dc0 <XorDataLine>
                if( BitArrayIsAllZeros( dataTempVector, FragDecoder.Status.FragNbLost ) )
 803118e:	f8b5 6880 	ldrh.w	r6, [r5, #2176]	; 0x880
    for( uint16_t i = 0; i < size; i++ )
 8031192:	2200      	movs	r2, #0
 8031194:	b290      	uxth	r0, r2
 8031196:	4286      	cmp	r6, r0
 8031198:	d825      	bhi.n	80311e6 <FragDecoderProcess+0x262>
            if( FragDecoder.M2BLine == FragDecoder.Status.FragNbLost )
 803119a:	f8b5 3880 	ldrh.w	r3, [r5, #2176]	; 0x880
 803119e:	68ac      	ldr	r4, [r5, #8]
 80311a0:	429c      	cmp	r4, r3
 80311a2:	f47f af11 	bne.w	8030fc8 <FragDecoderProcess+0x44>
                if( FragDecoder.Status.FragNbLost > 1 )
 80311a6:	2c01      	cmp	r4, #1
 80311a8:	4620      	mov	r0, r4
 80311aa:	f67f af0f 	bls.w	8030fcc <FragDecoderProcess+0x48>
                        GetRow( matrixDataTemp, li, FragDecoder.FragSize );
 80311ae:	4d38      	ldr	r5, [pc, #224]	; (8031290 <FragDecoderProcess+0x30c>)
                    for( i = ( FragDecoder.Status.FragNbLost - 2 ); i >= 0 ; i-- )
 80311b0:	3c02      	subs	r4, #2
                        li = FragFindMissingIndex( i );
 80311b2:	fa1f fa84 	uxth.w	sl, r4
 80311b6:	4650      	mov	r0, sl
 80311b8:	f7ff fe56 	bl	8030e68 <FragFindMissingIndex>
                        GetRow( matrixDataTemp, li, FragDecoder.FragSize );
 80311bc:	79aa      	ldrb	r2, [r5, #6]
 80311be:	4601      	mov	r1, r0
                        li = FragFindMissingIndex( i );
 80311c0:	4680      	mov	r8, r0
                        GetRow( matrixDataTemp, li, FragDecoder.FragSize );
 80311c2:	a81e      	add	r0, sp, #120	; 0x78
 80311c4:	f7ff fdd0 	bl	8030d68 <GetRow>
                        for( j = ( FragDecoder.Status.FragNbLost - 1 ); j > i; j--)
 80311c8:	f8b5 6880 	ldrh.w	r6, [r5, #2176]	; 0x880
 80311cc:	3e01      	subs	r6, #1
 80311ce:	42a6      	cmp	r6, r4
 80311d0:	dc62      	bgt.n	8031298 <FragDecoderProcess+0x314>
                        SetRow( matrixDataTemp, li, FragDecoder.FragSize );
 80311d2:	79aa      	ldrb	r2, [r5, #6]
 80311d4:	4641      	mov	r1, r8
 80311d6:	a81e      	add	r0, sp, #120	; 0x78
 80311d8:	f7ff fdb4 	bl	8030d44 <SetRow>
                    for( i = ( FragDecoder.Status.FragNbLost - 2 ); i >= 0 ; i-- )
 80311dc:	3c01      	subs	r4, #1
 80311de:	d2e8      	bcs.n	80311b2 <FragDecoderProcess+0x22e>
                    return FragDecoder.Status.FragNbLost;
 80311e0:	f8b5 0880 	ldrh.w	r0, [r5, #2176]	; 0x880
 80311e4:	e6f2      	b.n	8030fcc <FragDecoderProcess+0x48>
        if( GetParity( i, bitArray ) == 1 )
 80311e6:	a901      	add	r1, sp, #4
 80311e8:	f7ff fdd0 	bl	8030d8c <GetParity>
 80311ec:	2801      	cmp	r0, #1
 80311ee:	f102 0201 	add.w	r2, r2, #1
 80311f2:	d1cf      	bne.n	8031194 <FragDecoderProcess+0x210>
 80311f4:	2200      	movs	r2, #0
 80311f6:	e007      	b.n	8031208 <FragDecoderProcess+0x284>
        if ( GetParity( i, bitArray ) == 1 )
 80311f8:	a901      	add	r1, sp, #4
 80311fa:	4620      	mov	r0, r4
 80311fc:	f7ff fdc6 	bl	8030d8c <GetParity>
 8031200:	2801      	cmp	r0, #1
 8031202:	f102 0201 	add.w	r2, r2, #1
 8031206:	d09e      	beq.n	8031146 <FragDecoderProcess+0x1c2>
 8031208:	b294      	uxth	r4, r2
    for( uint16_t i = 0; i < size; i++)
 803120a:	42a6      	cmp	r6, r4
 803120c:	d8f4      	bhi.n	80311f8 <FragDecoderProcess+0x274>
    return 0;
 803120e:	2400      	movs	r4, #0
 8031210:	e799      	b.n	8031146 <FragDecoderProcess+0x1c2>
        findByte      = ( rowIndex * bitsInRow - ( ( rowIndex * ( rowIndex - 1 ) ) >> 1 ) ) >> 3;
 8031212:	1e63      	subs	r3, r4, #1
 8031214:	4363      	muls	r3, r4
 8031216:	fb04 f602 	mul.w	r6, r4, r2
 803121a:	eba6 0663 	sub.w	r6, r6, r3, asr #1
        findBitInByte = ( rowIndex * bitsInRow - ( ( rowIndex * ( rowIndex - 1 ) ) >> 1 ) ) % 8;
 803121e:	4273      	negs	r3, r6
 8031220:	f003 0307 	and.w	r3, r3, #7
        findByte      = ( rowIndex * bitsInRow - ( ( rowIndex * ( rowIndex - 1 ) ) >> 1 ) ) >> 3;
 8031224:	ea4f 09e6 	mov.w	r9, r6, asr #3
        findBitInByte = ( rowIndex * bitsInRow - ( ( rowIndex * ( rowIndex - 1 ) ) >> 1 ) ) % 8;
 8031228:	f006 0607 	and.w	r6, r6, #7
 803122c:	bf58      	it	pl
 803122e:	425e      	negpl	r6, r3
    uint32_t findByte = 0;
 8031230:	46a0      	mov	r8, r4
    }
    for( uint16_t i = rowIndex; i < bitsInRow; i++ )
    {
        if( GetParity( i, bitArray ) == 0 )
        {
            FragDecoder.MatrixM2B[findByte] = FragDecoder.MatrixM2B[findByte] & ( 0xFF - ( 1 << ( 7 - findBitInByte ) ) );
 8031232:	f04f 0a01 	mov.w	sl, #1
 8031236:	e018      	b.n	803126a <FragDecoderProcess+0x2e6>
        if( GetParity( i, bitArray ) == 0 )
 8031238:	a901      	add	r1, sp, #4
 803123a:	4640      	mov	r0, r8
 803123c:	f7ff fda6 	bl	8030d8c <GetParity>
 8031240:	b948      	cbnz	r0, 8031256 <FragDecoderProcess+0x2d2>
            FragDecoder.MatrixM2B[findByte] = FragDecoder.MatrixM2B[findByte] & ( 0xFF - ( 1 << ( 7 - findBitInByte ) ) );
 8031242:	eb05 0309 	add.w	r3, r5, r9
 8031246:	f1c6 0107 	rsb	r1, r6, #7
 803124a:	fa0a f001 	lsl.w	r0, sl, r1
 803124e:	7b19      	ldrb	r1, [r3, #12]
 8031250:	ea21 0100 	bic.w	r1, r1, r0
 8031254:	7319      	strb	r1, [r3, #12]
        }
        findBitInByte++;
 8031256:	3601      	adds	r6, #1
        if( findBitInByte == 8 )
 8031258:	2e08      	cmp	r6, #8
    for( uint16_t i = rowIndex; i < bitsInRow; i++ )
 803125a:	f108 0801 	add.w	r8, r8, #1
        {
            findBitInByte = 0;
            findByte++;
 803125e:	bf04      	itt	eq
 8031260:	f109 0901 	addeq.w	r9, r9, #1
            findBitInByte = 0;
 8031264:	2600      	moveq	r6, #0
    for( uint16_t i = rowIndex; i < bitsInRow; i++ )
 8031266:	fa1f f888 	uxth.w	r8, r8
 803126a:	4542      	cmp	r2, r8
 803126c:	d8e4      	bhi.n	8031238 <FragDecoderProcess+0x2b4>
                li = FragFindMissingIndex( firstOneInRow );
 803126e:	4620      	mov	r0, r4
 8031270:	f7ff fdfa 	bl	8030e68 <FragFindMissingIndex>
                SetRow( rawData, li, FragDecoder.FragSize );
 8031274:	79aa      	ldrb	r2, [r5, #6]
                li = FragFindMissingIndex( firstOneInRow );
 8031276:	4601      	mov	r1, r0
                SetRow( rawData, li, FragDecoder.FragSize );
 8031278:	4638      	mov	r0, r7
 803127a:	f7ff fd63 	bl	8030d44 <SetRow>
                SetParity( firstOneInRow, FragDecoder.S, 1 );
 803127e:	4905      	ldr	r1, [pc, #20]	; (8031294 <FragDecoderProcess+0x310>)
 8031280:	2201      	movs	r2, #1
 8031282:	4620      	mov	r0, r4
 8031284:	f7ff fd8c 	bl	8030da0 <SetParity>
                FragDecoder.M2BLine++;
 8031288:	68ab      	ldr	r3, [r5, #8]
 803128a:	3301      	adds	r3, #1
 803128c:	60ab      	str	r3, [r5, #8]
 803128e:	e784      	b.n	803119a <FragDecoderProcess+0x216>
 8031290:	20003f54 	.word	0x20003f54
 8031294:	200047c8 	.word	0x200047c8
                            FragExtractLineFromBinaryMatrix( dataTempVector2, i, FragDecoder.Status.FragNbLost );
 8031298:	f8b5 2880 	ldrh.w	r2, [r5, #2176]	; 0x880
 803129c:	4651      	mov	r1, sl
 803129e:	a804      	add	r0, sp, #16
 80312a0:	fa1f f986 	uxth.w	r9, r6
 80312a4:	f7ff fdf6 	bl	8030e94 <FragExtractLineFromBinaryMatrix>
                            FragExtractLineFromBinaryMatrix( dataTempVector, j, FragDecoder.Status.FragNbLost );
 80312a8:	f8b5 2880 	ldrh.w	r2, [r5, #2176]	; 0x880
 80312ac:	4649      	mov	r1, r9
 80312ae:	a801      	add	r0, sp, #4
 80312b0:	f7ff fdf0 	bl	8030e94 <FragExtractLineFromBinaryMatrix>
                            if( GetParity( j, dataTempVector2 ) == 1 )
 80312b4:	a904      	add	r1, sp, #16
 80312b6:	4648      	mov	r0, r9
 80312b8:	f7ff fd68 	bl	8030d8c <GetParity>
 80312bc:	2801      	cmp	r0, #1
 80312be:	d185      	bne.n	80311cc <FragDecoderProcess+0x248>
                                XorParityLine( dataTempVector2, dataTempVector, FragDecoder.Status.FragNbLost );
 80312c0:	f8b5 2880 	ldrh.w	r2, [r5, #2176]	; 0x880
 80312c4:	a901      	add	r1, sp, #4
 80312c6:	a804      	add	r0, sp, #16
 80312c8:	f7ff fd87 	bl	8030dda <XorParityLine>
                                lj = FragFindMissingIndex( j );
 80312cc:	4648      	mov	r0, r9
 80312ce:	f7ff fdcb 	bl	8030e68 <FragFindMissingIndex>
                                GetRow( rawData, lj, FragDecoder.FragSize );
 80312d2:	79aa      	ldrb	r2, [r5, #6]
                                lj = FragFindMissingIndex( j );
 80312d4:	4601      	mov	r1, r0
                                GetRow( rawData, lj, FragDecoder.FragSize );
 80312d6:	4638      	mov	r0, r7
 80312d8:	f7ff fd46 	bl	8030d68 <GetRow>
                                XorDataLine( matrixDataTemp , rawData , FragDecoder.FragSize );
 80312dc:	79aa      	ldrb	r2, [r5, #6]
 80312de:	4639      	mov	r1, r7
 80312e0:	a81e      	add	r0, sp, #120	; 0x78
 80312e2:	f7ff fd6d 	bl	8030dc0 <XorDataLine>
 80312e6:	e771      	b.n	80311cc <FragDecoderProcess+0x248>

080312e8 <FragDecoderGetStatus>:
    return FragDecoder.Status;
 80312e8:	4902      	ldr	r1, [pc, #8]	; (80312f4 <FragDecoderGetStatus+0xc>)
 80312ea:	680a      	ldr	r2, [r1, #0]
 80312ec:	6002      	str	r2, [r0, #0]
 80312ee:	684a      	ldr	r2, [r1, #4]
 80312f0:	6042      	str	r2, [r0, #4]
}
 80312f2:	4770      	bx	lr
 80312f4:	200047d2 	.word	0x200047d2

080312f8 <LmHandlerDeviceTimeReq>:
        return LORAMAC_HANDLER_ERROR;
    }
}

LmHandlerErrorStatus_t LmHandlerDeviceTimeReq( void )
{
 80312f8:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    LoRaMacStatus_t status;
    MlmeReq_t mlmeReq;

    mlmeReq.Type = MLME_DEVICE_TIME;
 80312fa:	230a      	movs	r3, #10

    status = LoRaMacMlmeRequest( &mlmeReq );
 80312fc:	a801      	add	r0, sp, #4
    mlmeReq.Type = MLME_DEVICE_TIME;
 80312fe:	f88d 3004 	strb.w	r3, [sp, #4]
    status = LoRaMacMlmeRequest( &mlmeReq );
 8031302:	f004 f81b 	bl	803533c <LoRaMacMlmeRequest>

    if( status == LORAMAC_STATUS_OK )
 8031306:	3800      	subs	r0, #0
 8031308:	bf18      	it	ne
 803130a:	2001      	movne	r0, #1
    }
    else
    {
        return LORAMAC_HANDLER_ERROR;
    }
}
 803130c:	4240      	negs	r0, r0
 803130e:	b007      	add	sp, #28
 8031310:	f85d fb04 	ldr.w	pc, [sp], #4

08031314 <McpsConfirm>:
 * LORAMAC NOTIFICATIONS HANDLING
 *=============================================================================
 */

static void McpsConfirm( McpsConfirm_t *mcpsConfirm )
{
 8031314:	b570      	push	{r4, r5, r6, lr}
    TxParams.IsMcpsConfirm = 1;
 8031316:	4c11      	ldr	r4, [pc, #68]	; (803135c <McpsConfirm+0x48>)
 8031318:	2301      	movs	r3, #1
 803131a:	7023      	strb	r3, [r4, #0]
    TxParams.Status = mcpsConfirm->Status;
 803131c:	7843      	ldrb	r3, [r0, #1]
 803131e:	7063      	strb	r3, [r4, #1]
    TxParams.Datarate = mcpsConfirm->Datarate;
 8031320:	7883      	ldrb	r3, [r0, #2]
 8031322:	7123      	strb	r3, [r4, #4]
    TxParams.UplinkCounter = mcpsConfirm->UpLinkCounter;
 8031324:	68c3      	ldr	r3, [r0, #12]
 8031326:	60a3      	str	r3, [r4, #8]
    TxParams.TxPower = mcpsConfirm->TxPower;
 8031328:	78c3      	ldrb	r3, [r0, #3]
 803132a:	7523      	strb	r3, [r4, #20]
    TxParams.Channel = mcpsConfirm->Channel;
 803132c:	6903      	ldr	r3, [r0, #16]
 803132e:	7563      	strb	r3, [r4, #21]
    TxParams.AckReceived = mcpsConfirm->AckReceived;
 8031330:	7903      	ldrb	r3, [r0, #4]
 8031332:	70e3      	strb	r3, [r4, #3]

    LmHandlerCallbacks->OnTxData( &TxParams );
 8031334:	69a3      	ldr	r3, [r4, #24]
{
 8031336:	4605      	mov	r5, r0
    LmHandlerCallbacks->OnTxData( &TxParams );
 8031338:	6a1b      	ldr	r3, [r3, #32]
 803133a:	4620      	mov	r0, r4
 803133c:	4798      	blx	r3
    }
}

static void LmHandlerPackagesNotify( PackageNotifyTypes_t notifyType, void *params )
{
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 803133e:	341c      	adds	r4, #28
 8031340:	2600      	movs	r6, #0
    {
        if( LmHandlerPackages[i] != NULL )
 8031342:	f854 3b04 	ldr.w	r3, [r4], #4
 8031346:	b11b      	cbz	r3, 8031350 <McpsConfirm+0x3c>
        {
            switch( notifyType )
            {
                case PACKAGE_MCPS_CONFIRM:
                {
                    if( LmHandlerPackages[i]->OnMcpsConfirmProcess != NULL )
 8031348:	699b      	ldr	r3, [r3, #24]
 803134a:	b10b      	cbz	r3, 8031350 <McpsConfirm+0x3c>
                    {
                        LmHandlerPackages[i]->OnMcpsConfirmProcess( ( McpsConfirm_t* ) params );
 803134c:	4628      	mov	r0, r5
 803134e:	4798      	blx	r3
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 8031350:	3601      	adds	r6, #1
 8031352:	b2f3      	uxtb	r3, r6
 8031354:	2b05      	cmp	r3, #5
 8031356:	b276      	sxtb	r6, r6
 8031358:	d1f3      	bne.n	8031342 <McpsConfirm+0x2e>
}
 803135a:	bd70      	pop	{r4, r5, r6, pc}
 803135c:	200047dc 	.word	0x200047dc

08031360 <LmHandlerConfigure>:
{
 8031360:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    UTIL_MEM_cpy_8((void *)&LmHandlerParams, (const void *)handlerParams, sizeof(LmHandlerParams_t));
 8031364:	4e63      	ldr	r6, [pc, #396]	; (80314f4 <LmHandlerConfigure+0x194>)
{
 8031366:	4601      	mov	r1, r0
    UTIL_MEM_cpy_8((void *)&LmHandlerParams, (const void *)handlerParams, sizeof(LmHandlerParams_t));
 8031368:	2210      	movs	r2, #16
{
 803136a:	b09e      	sub	sp, #120	; 0x78
    UTIL_MEM_cpy_8((void *)&LmHandlerParams, (const void *)handlerParams, sizeof(LmHandlerParams_t));
 803136c:	f106 0030 	add.w	r0, r6, #48	; 0x30
 8031370:	f009 fd94 	bl	803ae9c <UTIL_MEM_cpy_8>
    loraInfo = LoraInfo_GetPtr();
 8031374:	f7fb fe16 	bl	802cfa4 <LoraInfo_GetPtr>
    if (0U != ((1 << (LmHandlerParams.ActiveRegion)) & (loraInfo->Region)))
 8031378:	f896 2030 	ldrb.w	r2, [r6, #48]	; 0x30
 803137c:	6843      	ldr	r3, [r0, #4]
 803137e:	2701      	movs	r7, #1
 8031380:	fa07 f102 	lsl.w	r1, r7, r2
 8031384:	4019      	ands	r1, r3
 8031386:	d00a      	beq.n	803139e <LmHandlerConfigure+0x3e>
        if (LoRaMacInitialization(&LoRaMacPrimitives, &LoRaMacCallbacks, LmHandlerParams.ActiveRegion) != LORAMAC_STATUS_OK)
 8031388:	f106 0140 	add.w	r1, r6, #64	; 0x40
 803138c:	f106 0054 	add.w	r0, r6, #84	; 0x54
 8031390:	f003 fa0c 	bl	80347ac <LoRaMacInitialization>
 8031394:	4605      	mov	r5, r0
 8031396:	b140      	cbz	r0, 80313aa <LmHandlerConfigure+0x4a>
            return LORAMAC_HANDLER_ERROR;
 8031398:	f04f 30ff 	mov.w	r0, #4294967295
 803139c:	e0a6      	b.n	80314ec <LmHandlerConfigure+0x18c>
        MW_LOG(TS_ON, VLEVEL_ALWAYS, "error: Region is not defined in the MW: set lorawan_conf.h accordingly\r\n");
 803139e:	4b56      	ldr	r3, [pc, #344]	; (80314f8 <LmHandlerConfigure+0x198>)
 80313a0:	463a      	mov	r2, r7
 80313a2:	4608      	mov	r0, r1
 80313a4:	f009 fc72 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
        while (1) {}  /* error: Region is not defined in the MW */
 80313a8:	e7fe      	b.n	80313a8 <LmHandlerConfigure+0x48>
    nbNvmData = NvmDataMgmtRestore( );
 80313aa:	f005 f977 	bl	803669c <NvmDataMgmtRestore>
    if( nbNvmData > 0 )
 80313ae:	3800      	subs	r0, #0
    memcpy1( CommissioningParams.DevEui, mibReq.Param.DevEui, 8 );
 80313b0:	4c52      	ldr	r4, [pc, #328]	; (80314fc <LmHandlerConfigure+0x19c>)
    if( nbNvmData > 0 )
 80313b2:	bf18      	it	ne
 80313b4:	2001      	movne	r0, #1
    mibReq.Type = MIB_DEV_EUI;
 80313b6:	f04f 0802 	mov.w	r8, #2
    if( nbNvmData > 0 )
 80313ba:	f886 0064 	strb.w	r0, [r6, #100]	; 0x64
    LoRaMacMibGetRequestConfirm( &mibReq );
 80313be:	a80c      	add	r0, sp, #48	; 0x30
    mibReq.Type = MIB_DEV_EUI;
 80313c0:	f88d 8030 	strb.w	r8, [sp, #48]	; 0x30
    LoRaMacMibGetRequestConfirm( &mibReq );
 80313c4:	f003 fc12 	bl	8034bec <LoRaMacMibGetRequestConfirm>
    memcpy1( CommissioningParams.DevEui, mibReq.Param.DevEui, 8 );
 80313c8:	990d      	ldr	r1, [sp, #52]	; 0x34
 80313ca:	2208      	movs	r2, #8
 80313cc:	4620      	mov	r0, r4
 80313ce:	f007 fd77 	bl	8038ec0 <memcpy1>
    mibReq.Type = MIB_JOIN_EUI;
 80313d2:	2303      	movs	r3, #3
    LoRaMacMibGetRequestConfirm( &mibReq );
 80313d4:	a80c      	add	r0, sp, #48	; 0x30
    mibReq.Type = MIB_JOIN_EUI;
 80313d6:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
    LoRaMacMibGetRequestConfirm( &mibReq );
 80313da:	f003 fc07 	bl	8034bec <LoRaMacMibGetRequestConfirm>
    memcpy1( CommissioningParams.JoinEui, mibReq.Param.JoinEui, 8 );
 80313de:	2208      	movs	r2, #8
 80313e0:	18a0      	adds	r0, r4, r2
 80313e2:	990d      	ldr	r1, [sp, #52]	; 0x34
 80313e4:	f007 fd6c 	bl	8038ec0 <memcpy1>
    mibReq.Type = MIB_DEV_ADDR;
 80313e8:	2306      	movs	r3, #6
 80313ea:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
    LoRaMacMibSetRequestConfirm(&mibReq);
 80313ee:	a80c      	add	r0, sp, #48	; 0x30
    mibReq.Param.DevAddr = CommissioningParams.DevAddr;
 80313f0:	6963      	ldr	r3, [r4, #20]
 80313f2:	930d      	str	r3, [sp, #52]	; 0x34
    LoRaMacMibSetRequestConfirm(&mibReq);
 80313f4:	f003 fcb6 	bl	8034d64 <LoRaMacMibSetRequestConfirm>
    MW_LOG(TS_OFF, VLEVEL_M, "###### DevEui:  %02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\r\n",
 80313f8:	79e3      	ldrb	r3, [r4, #7]
 80313fa:	9307      	str	r3, [sp, #28]
 80313fc:	79a3      	ldrb	r3, [r4, #6]
 80313fe:	9306      	str	r3, [sp, #24]
 8031400:	7963      	ldrb	r3, [r4, #5]
 8031402:	9305      	str	r3, [sp, #20]
 8031404:	7923      	ldrb	r3, [r4, #4]
 8031406:	9304      	str	r3, [sp, #16]
 8031408:	78e3      	ldrb	r3, [r4, #3]
 803140a:	9303      	str	r3, [sp, #12]
 803140c:	78a3      	ldrb	r3, [r4, #2]
 803140e:	9302      	str	r3, [sp, #8]
 8031410:	7863      	ldrb	r3, [r4, #1]
 8031412:	9301      	str	r3, [sp, #4]
 8031414:	7823      	ldrb	r3, [r4, #0]
 8031416:	9300      	str	r3, [sp, #0]
 8031418:	462a      	mov	r2, r5
 803141a:	4b39      	ldr	r3, [pc, #228]	; (8031500 <LmHandlerConfigure+0x1a0>)
 803141c:	4629      	mov	r1, r5
 803141e:	4640      	mov	r0, r8
 8031420:	f009 fc34 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
    MW_LOG(TS_OFF, VLEVEL_M, "###### AppEui:  %02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\r\n",
 8031424:	7be3      	ldrb	r3, [r4, #15]
 8031426:	9307      	str	r3, [sp, #28]
 8031428:	7ba3      	ldrb	r3, [r4, #14]
 803142a:	9306      	str	r3, [sp, #24]
 803142c:	7b63      	ldrb	r3, [r4, #13]
 803142e:	9305      	str	r3, [sp, #20]
 8031430:	7b23      	ldrb	r3, [r4, #12]
 8031432:	9304      	str	r3, [sp, #16]
 8031434:	7ae3      	ldrb	r3, [r4, #11]
 8031436:	9303      	str	r3, [sp, #12]
 8031438:	7aa3      	ldrb	r3, [r4, #10]
 803143a:	9302      	str	r3, [sp, #8]
 803143c:	7a63      	ldrb	r3, [r4, #9]
 803143e:	9301      	str	r3, [sp, #4]
 8031440:	7a23      	ldrb	r3, [r4, #8]
 8031442:	9300      	str	r3, [sp, #0]
 8031444:	462a      	mov	r2, r5
 8031446:	4b2f      	ldr	r3, [pc, #188]	; (8031504 <LmHandlerConfigure+0x1a4>)
 8031448:	4629      	mov	r1, r5
 803144a:	4640      	mov	r0, r8
 803144c:	f009 fc1e 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
    MW_LOG(TS_OFF, VLEVEL_M, "###### DevAddr: %02X:%02X:%02X:%02X\r\n",
 8031450:	7d23      	ldrb	r3, [r4, #20]
 8031452:	9303      	str	r3, [sp, #12]
 8031454:	7d63      	ldrb	r3, [r4, #21]
 8031456:	9302      	str	r3, [sp, #8]
 8031458:	7da3      	ldrb	r3, [r4, #22]
 803145a:	9301      	str	r3, [sp, #4]
 803145c:	7de3      	ldrb	r3, [r4, #23]
 803145e:	9300      	str	r3, [sp, #0]
 8031460:	462a      	mov	r2, r5
 8031462:	4b29      	ldr	r3, [pc, #164]	; (8031508 <LmHandlerConfigure+0x1a8>)
 8031464:	4629      	mov	r1, r5
 8031466:	4640      	mov	r0, r8
 8031468:	f009 fc10 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
    MW_LOG(TS_OFF, VLEVEL_L, "###### KMS ENABLED \r\n");
 803146c:	462a      	mov	r2, r5
 803146e:	4629      	mov	r1, r5
 8031470:	4b26      	ldr	r3, [pc, #152]	; (803150c <LmHandlerConfigure+0x1ac>)
 8031472:	4638      	mov	r0, r7
 8031474:	f009 fc0a 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
    mibReq.Type = MIB_PUBLIC_NETWORK;
 8031478:	240f      	movs	r4, #15
    LoRaMacMibSetRequestConfirm(&mibReq);
 803147a:	a80c      	add	r0, sp, #48	; 0x30
    mibReq.Type = MIB_PUBLIC_NETWORK;
 803147c:	f88d 4030 	strb.w	r4, [sp, #48]	; 0x30
    mibReq.Param.EnablePublicNetwork = LORAWAN_PUBLIC_NETWORK;
 8031480:	f88d 7034 	strb.w	r7, [sp, #52]	; 0x34
    LoRaMacMibSetRequestConfirm(&mibReq);
 8031484:	f003 fc6e 	bl	8034d64 <LoRaMacMibSetRequestConfirm>
    mibReq.Type = MIB_NET_ID;
 8031488:	2305      	movs	r3, #5
    LoRaMacMibSetRequestConfirm(&mibReq);
 803148a:	a80c      	add	r0, sp, #48	; 0x30
    mibReq.Type = MIB_NET_ID;
 803148c:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
    mibReq.Param.NetID = LORAWAN_NETWORK_ID;
 8031490:	950d      	str	r5, [sp, #52]	; 0x34
    LoRaMacMibSetRequestConfirm(&mibReq);
 8031492:	f003 fc67 	bl	8034d64 <LoRaMacMibSetRequestConfirm>
    mibReq.Type = MIB_REPEATER_SUPPORT;
 8031496:	2310      	movs	r3, #16
    LoRaMacMibSetRequestConfirm( &mibReq );
 8031498:	a80c      	add	r0, sp, #48	; 0x30
    mibReq.Type = MIB_REPEATER_SUPPORT;
 803149a:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
    mibReq.Param.EnableRepeaterSupport = LORAWAN_REPEATER_SUPPORT;
 803149e:	f88d 5034 	strb.w	r5, [sp, #52]	; 0x34
    LoRaMacMibSetRequestConfirm( &mibReq );
 80314a2:	f003 fc5f 	bl	8034d64 <LoRaMacMibSetRequestConfirm>
    mibReq.Type = MIB_ADR;
 80314a6:	2304      	movs	r3, #4
 80314a8:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
    LoRaMacMibSetRequestConfirm( &mibReq );
 80314ac:	a80c      	add	r0, sp, #48	; 0x30
    mibReq.Param.AdrEnable = LmHandlerParams.AdrEnable;
 80314ae:	f896 3032 	ldrb.w	r3, [r6, #50]	; 0x32
 80314b2:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
    LoRaMacMibSetRequestConfirm( &mibReq );
 80314b6:	f003 fc55 	bl	8034d64 <LoRaMacMibSetRequestConfirm>
    phyParam = RegionGetPhyParam( LmHandlerParams.ActiveRegion, &getPhy );
 80314ba:	a90a      	add	r1, sp, #40	; 0x28
 80314bc:	f896 0030 	ldrb.w	r0, [r6, #48]	; 0x30
    getPhy.Attribute = PHY_DUTY_CYCLE;
 80314c0:	f88d 4028 	strb.w	r4, [sp, #40]	; 0x28
    phyParam = RegionGetPhyParam( LmHandlerParams.ActiveRegion, &getPhy );
 80314c4:	f005 f8f5 	bl	80366b2 <RegionGetPhyParam>
    LmHandlerParams.DutyCycleEnabled = (bool) phyParam.Value;
 80314c8:	3800      	subs	r0, #0
 80314ca:	bf18      	it	ne
 80314cc:	2001      	movne	r0, #1
    mibReq.Type = MIB_SYSTEM_MAX_RX_ERROR;
 80314ce:	2322      	movs	r3, #34	; 0x22
    LmHandlerParams.DutyCycleEnabled = (bool) phyParam.Value;
 80314d0:	f886 0035 	strb.w	r0, [r6, #53]	; 0x35
    mibReq.Type = MIB_SYSTEM_MAX_RX_ERROR;
 80314d4:	f88d 3054 	strb.w	r3, [sp, #84]	; 0x54
    if( LoRaMacMibSetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 80314d8:	a815      	add	r0, sp, #84	; 0x54
    mibReq.Param.SystemMaxRxError = maxErrorInMs;
 80314da:	2314      	movs	r3, #20
 80314dc:	9316      	str	r3, [sp, #88]	; 0x58
    if( LoRaMacMibSetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 80314de:	f003 fc41 	bl	8034d64 <LoRaMacMibSetRequestConfirm>
    LoRaMacTestSetDutyCycleOn( LmHandlerParams.DutyCycleEnabled );
 80314e2:	f896 0035 	ldrb.w	r0, [r6, #53]	; 0x35
 80314e6:	f004 f9a1 	bl	803582c <LoRaMacTestSetDutyCycleOn>
    return LORAMAC_HANDLER_SUCCESS;
 80314ea:	4628      	mov	r0, r5
}
 80314ec:	b01e      	add	sp, #120	; 0x78
 80314ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80314f2:	bf00      	nop
 80314f4:	200047dc 	.word	0x200047dc
 80314f8:	0803c0cf 	.word	0x0803c0cf
 80314fc:	20003458 	.word	0x20003458
 8031500:	0803c118 	.word	0x0803c118
 8031504:	0803c152 	.word	0x0803c152
 8031508:	0803c18c 	.word	0x0803c18c
 803150c:	0803c1b2 	.word	0x0803c1b2

08031510 <LmHandlerProcess>:
{
 8031510:	b538      	push	{r3, r4, r5, lr}
    LoRaMacProcess( );
 8031512:	f002 fc89 	bl	8033e28 <LoRaMacProcess>
    }
}

static void LmHandlerPackagesProcess( void )
{
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 8031516:	4d0c      	ldr	r5, [pc, #48]	; (8031548 <LmHandlerProcess+0x38>)
    LoRaMacProcess( );
 8031518:	2405      	movs	r4, #5
    {
        if( ( LmHandlerPackages[i] != NULL ) &&
 803151a:	f855 3b04 	ldr.w	r3, [r5], #4
 803151e:	b15b      	cbz	r3, 8031538 <LmHandlerProcess+0x28>
 8031520:	691b      	ldr	r3, [r3, #16]
 8031522:	b14b      	cbz	r3, 8031538 <LmHandlerProcess+0x28>
    if (( id < PKG_MAX_NUMBER ) && ( LmHandlerPackages[id]->IsInitialized != NULL ))
 8031524:	f855 3c04 	ldr.w	r3, [r5, #-4]
 8031528:	689b      	ldr	r3, [r3, #8]
 803152a:	b12b      	cbz	r3, 8031538 <LmHandlerProcess+0x28>
        return LmHandlerPackages[id]->IsInitialized( );
 803152c:	4798      	blx	r3
            ( LmHandlerPackages[i]->Process != NULL ) &&
 803152e:	b118      	cbz	r0, 8031538 <LmHandlerProcess+0x28>
            ( LmHandlerPackageIsInitialized( i ) != false ) )
        {
            LmHandlerPackages[i]->Process( );
 8031530:	f855 3c04 	ldr.w	r3, [r5, #-4]
 8031534:	691b      	ldr	r3, [r3, #16]
 8031536:	4798      	blx	r3
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 8031538:	3c01      	subs	r4, #1
 803153a:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
 803153e:	d1ec      	bne.n	803151a <LmHandlerProcess+0xa>
}
 8031540:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    NvmDataMgmtStore( );
 8031544:	f005 b8a8 	b.w	8036698 <NvmDataMgmtStore>
 8031548:	200047f8 	.word	0x200047f8

0803154c <LmHandlerJoinStatus>:
{
 803154c:	b500      	push	{lr}
 803154e:	b08b      	sub	sp, #44	; 0x2c
    mibReq.Type = MIB_NETWORK_ACTIVATION;
 8031550:	2301      	movs	r3, #1
    status = LoRaMacMibGetRequestConfirm( &mibReq );
 8031552:	a801      	add	r0, sp, #4
    mibReq.Type = MIB_NETWORK_ACTIVATION;
 8031554:	f88d 3004 	strb.w	r3, [sp, #4]
    status = LoRaMacMibGetRequestConfirm( &mibReq );
 8031558:	f003 fb48 	bl	8034bec <LoRaMacMibGetRequestConfirm>
    if( status == LORAMAC_STATUS_OK )
 803155c:	b938      	cbnz	r0, 803156e <LmHandlerJoinStatus+0x22>
        if( mibReq.Param.NetworkActivation == ACTIVATION_TYPE_NONE )
 803155e:	f89d 0008 	ldrb.w	r0, [sp, #8]
            return LORAMAC_HANDLER_RESET;
 8031562:	3800      	subs	r0, #0
 8031564:	bf18      	it	ne
 8031566:	2001      	movne	r0, #1
}
 8031568:	b00b      	add	sp, #44	; 0x2c
 803156a:	f85d fb04 	ldr.w	pc, [sp], #4
        return LORAMAC_HANDLER_RESET;
 803156e:	2000      	movs	r0, #0
 8031570:	e7fa      	b.n	8031568 <LmHandlerJoinStatus+0x1c>
	...

08031574 <LmHandlerRequestClass>:
{
 8031574:	b530      	push	{r4, r5, lr}
 8031576:	b08d      	sub	sp, #52	; 0x34
 8031578:	4605      	mov	r5, r0
    if (LoRaMacIsBusy() == true)
 803157a:	f002 fc47 	bl	8033e0c <LoRaMacIsBusy>
 803157e:	4604      	mov	r4, r0
 8031580:	2800      	cmp	r0, #0
 8031582:	d14a      	bne.n	803161a <LmHandlerRequestClass+0xa6>
    if (LmHandlerJoinStatus() != LORAMAC_HANDLER_SET)
 8031584:	f7ff ffe2 	bl	803154c <LmHandlerJoinStatus>
 8031588:	2801      	cmp	r0, #1
 803158a:	d149      	bne.n	8031620 <LmHandlerRequestClass+0xac>
    if ( LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 803158c:	a803      	add	r0, sp, #12
    mibReq.Type = MIB_DEVICE_CLASS;
 803158e:	f88d 400c 	strb.w	r4, [sp, #12]
    if ( LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 8031592:	f003 fb2b 	bl	8034bec <LoRaMacMibGetRequestConfirm>
 8031596:	b110      	cbz	r0, 803159e <LmHandlerRequestClass+0x2a>
        switch( newClass )
 8031598:	f04f 30ff 	mov.w	r0, #4294967295
 803159c:	e004      	b.n	80315a8 <LmHandlerRequestClass+0x34>
    currentClass = mibReq.Param.Class;
 803159e:	f89d 3010 	ldrb.w	r3, [sp, #16]
    if( currentClass != newClass )
 80315a2:	42ab      	cmp	r3, r5
 80315a4:	d102      	bne.n	80315ac <LmHandlerRequestClass+0x38>
    LmHandlerErrorStatus_t errorStatus = LORAMAC_HANDLER_SUCCESS;
 80315a6:	2000      	movs	r0, #0
}
 80315a8:	b00d      	add	sp, #52	; 0x34
 80315aa:	bd30      	pop	{r4, r5, pc}
        switch( newClass )
 80315ac:	2d01      	cmp	r5, #1
 80315ae:	d0f3      	beq.n	8031598 <LmHandlerRequestClass+0x24>
 80315b0:	2d02      	cmp	r5, #2
 80315b2:	d01a      	beq.n	80315ea <LmHandlerRequestClass+0x76>
 80315b4:	2d00      	cmp	r5, #0
 80315b6:	d1f7      	bne.n	80315a8 <LmHandlerRequestClass+0x34>
                if( currentClass != CLASS_A )
 80315b8:	2b00      	cmp	r3, #0
 80315ba:	d0f4      	beq.n	80315a6 <LmHandlerRequestClass+0x32>
                    if( LoRaMacMibSetRequestConfirm( &mibReq ) == LORAMAC_STATUS_OK )
 80315bc:	a803      	add	r0, sp, #12
                    mibReq.Param.Class = newClass;
 80315be:	f88d 5010 	strb.w	r5, [sp, #16]
                    if( LoRaMacMibSetRequestConfirm( &mibReq ) == LORAMAC_STATUS_OK )
 80315c2:	f003 fbcf 	bl	8034d64 <LoRaMacMibSetRequestConfirm>
 80315c6:	4602      	mov	r2, r0
 80315c8:	2800      	cmp	r0, #0
 80315ca:	d1e5      	bne.n	8031598 <LmHandlerRequestClass+0x24>
    }
}

static void DisplayClassUpdate(DeviceClass_t deviceClass)
{
    MW_LOG(TS_OFF, VLEVEL_M, "Switch to Class %c done\r\n", "ABC"[deviceClass]);
 80315cc:	2341      	movs	r3, #65	; 0x41
 80315ce:	9300      	str	r3, [sp, #0]
 80315d0:	4601      	mov	r1, r0
 80315d2:	4b15      	ldr	r3, [pc, #84]	; (8031628 <LmHandlerRequestClass+0xb4>)
 80315d4:	2002      	movs	r0, #2
 80315d6:	f009 fb59 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
                        if (LmHandlerCallbacks->OnClassChange != NULL)
 80315da:	4b14      	ldr	r3, [pc, #80]	; (803162c <LmHandlerRequestClass+0xb8>)
 80315dc:	699b      	ldr	r3, [r3, #24]
 80315de:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80315e0:	2b00      	cmp	r3, #0
 80315e2:	d0e0      	beq.n	80315a6 <LmHandlerRequestClass+0x32>
                            LmHandlerCallbacks->OnClassChange( newClass );
 80315e4:	2000      	movs	r0, #0
 80315e6:	4798      	blx	r3
 80315e8:	e7dd      	b.n	80315a6 <LmHandlerRequestClass+0x32>
                if( currentClass != CLASS_A )
 80315ea:	2b00      	cmp	r3, #0
 80315ec:	d1d4      	bne.n	8031598 <LmHandlerRequestClass+0x24>
                    if (LoRaMacMibSetRequestConfirm( &mibReq ) == LORAMAC_STATUS_OK)
 80315ee:	a803      	add	r0, sp, #12
                    mibReq.Param.Class = newClass;
 80315f0:	f88d 5010 	strb.w	r5, [sp, #16]
                    if (LoRaMacMibSetRequestConfirm( &mibReq ) == LORAMAC_STATUS_OK)
 80315f4:	f003 fbb6 	bl	8034d64 <LoRaMacMibSetRequestConfirm>
 80315f8:	2800      	cmp	r0, #0
 80315fa:	d1cd      	bne.n	8031598 <LmHandlerRequestClass+0x24>
    MW_LOG(TS_OFF, VLEVEL_M, "Switch to Class %c done\r\n", "ABC"[deviceClass]);
 80315fc:	2343      	movs	r3, #67	; 0x43
 80315fe:	9300      	str	r3, [sp, #0]
 8031600:	4602      	mov	r2, r0
 8031602:	4b09      	ldr	r3, [pc, #36]	; (8031628 <LmHandlerRequestClass+0xb4>)
 8031604:	4601      	mov	r1, r0
 8031606:	4628      	mov	r0, r5
 8031608:	f009 fb40 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
                        if (LmHandlerCallbacks->OnClassChange != NULL)
 803160c:	4b07      	ldr	r3, [pc, #28]	; (803162c <LmHandlerRequestClass+0xb8>)
 803160e:	699b      	ldr	r3, [r3, #24]
 8031610:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8031612:	2b00      	cmp	r3, #0
 8031614:	d0c7      	beq.n	80315a6 <LmHandlerRequestClass+0x32>
                            LmHandlerCallbacks->OnClassChange( newClass );
 8031616:	4628      	mov	r0, r5
 8031618:	e7e5      	b.n	80315e6 <LmHandlerRequestClass+0x72>
        return LORAMAC_HANDLER_BUSY_ERROR;
 803161a:	f06f 0001 	mvn.w	r0, #1
 803161e:	e7c3      	b.n	80315a8 <LmHandlerRequestClass+0x34>
        return LORAMAC_HANDLER_NO_NETWORK_JOINED;
 8031620:	f06f 0002 	mvn.w	r0, #2
 8031624:	e7c0      	b.n	80315a8 <LmHandlerRequestClass+0x34>
 8031626:	bf00      	nop
 8031628:	0803c1c8 	.word	0x0803c1c8
 803162c:	200047dc 	.word	0x200047dc

08031630 <LmHandlerJoin>:
{
 8031630:	b530      	push	{r4, r5, lr}
    if ( mode == ACTIVATION_TYPE_OTAA )
 8031632:	2802      	cmp	r0, #2
 8031634:	4b1f      	ldr	r3, [pc, #124]	; (80316b4 <LmHandlerJoin+0x84>)
 8031636:	4c20      	ldr	r4, [pc, #128]	; (80316b8 <LmHandlerJoin+0x88>)
{
 8031638:	b08b      	sub	sp, #44	; 0x2c
 803163a:	f04f 0501 	mov.w	r5, #1
    if ( mode == ACTIVATION_TYPE_OTAA )
 803163e:	d10d      	bne.n	803165c <LmHandlerJoin+0x2c>
        JoinParams.Mode = ACTIVATION_TYPE_OTAA;
 8031640:	7698      	strb	r0, [r3, #26]
        LoRaMacStart();
 8031642:	f003 fa73 	bl	8034b2c <LoRaMacStart>
        mlmeReq.Req.Join.Datarate = LmHandlerParams.TxDatarate;
 8031646:	f894 3033 	ldrb.w	r3, [r4, #51]	; 0x33
        mlmeReq.Type = MLME_JOIN;
 803164a:	f88d 5004 	strb.w	r5, [sp, #4]
        LoRaMacMlmeRequest( &mlmeReq );
 803164e:	a801      	add	r0, sp, #4
        mlmeReq.Req.Join.Datarate = LmHandlerParams.TxDatarate;
 8031650:	f88d 3008 	strb.w	r3, [sp, #8]
        LoRaMacMlmeRequest( &mlmeReq );
 8031654:	f003 fe72 	bl	803533c <LoRaMacMlmeRequest>
}
 8031658:	b00b      	add	sp, #44	; 0x2c
 803165a:	bd30      	pop	{r4, r5, pc}
        JoinParams.Datarate = LmHandlerParams.TxDatarate;
 803165c:	f894 2033 	ldrb.w	r2, [r4, #51]	; 0x33
 8031660:	761a      	strb	r2, [r3, #24]
        JoinParams.Status = LORAMAC_HANDLER_SUCCESS;
 8031662:	2200      	movs	r2, #0
        JoinParams.Mode = ACTIVATION_TYPE_ABP;
 8031664:	769d      	strb	r5, [r3, #26]
        JoinParams.Status = LORAMAC_HANDLER_SUCCESS;
 8031666:	765a      	strb	r2, [r3, #25]
        if (CtxRestoreDone == false)
 8031668:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
 803166c:	b97b      	cbnz	r3, 803168e <LmHandlerJoin+0x5e>
            mibReq.Type = MIB_ABP_LORAWAN_VERSION;
 803166e:	2327      	movs	r3, #39	; 0x27
 8031670:	f88d 3004 	strb.w	r3, [sp, #4]
            LoRaMacMibSetRequestConfirm(&mibReq);
 8031674:	a801      	add	r0, sp, #4
            mibReq.Param.AbpLrWanVersion.Value = ABP_ACTIVATION_LRWAN_VERSION;
 8031676:	4b11      	ldr	r3, [pc, #68]	; (80316bc <LmHandlerJoin+0x8c>)
 8031678:	9302      	str	r3, [sp, #8]
            LoRaMacMibSetRequestConfirm(&mibReq);
 803167a:	f003 fb73 	bl	8034d64 <LoRaMacMibSetRequestConfirm>
            SecureElementSetObjHandler(NWK_S_KEY, KMS_NWK_S_KEY_OBJECT_HANDLE);
 803167e:	2110      	movs	r1, #16
 8031680:	2002      	movs	r0, #2
 8031682:	f007 f8e3 	bl	803884c <SecureElementSetObjHandler>
            SecureElementSetObjHandler(APP_S_KEY, KMS_APP_S_KEY_OBJECT_HANDLE);
 8031686:	2111      	movs	r1, #17
 8031688:	2003      	movs	r0, #3
 803168a:	f007 f8df 	bl	803884c <SecureElementSetObjHandler>
        LoRaMacStart();
 803168e:	f003 fa4d 	bl	8034b2c <LoRaMacStart>
        mibReq.Type = MIB_NETWORK_ACTIVATION;
 8031692:	2301      	movs	r3, #1
        LoRaMacMibSetRequestConfirm( &mibReq );
 8031694:	a801      	add	r0, sp, #4
        mibReq.Type = MIB_NETWORK_ACTIVATION;
 8031696:	f88d 3004 	strb.w	r3, [sp, #4]
        mibReq.Param.NetworkActivation = ACTIVATION_TYPE_ABP;
 803169a:	f88d 3008 	strb.w	r3, [sp, #8]
        LoRaMacMibSetRequestConfirm( &mibReq );
 803169e:	f003 fb61 	bl	8034d64 <LoRaMacMibSetRequestConfirm>
        LmHandlerCallbacks->OnJoinRequest( &JoinParams );
 80316a2:	69a3      	ldr	r3, [r4, #24]
 80316a4:	4806      	ldr	r0, [pc, #24]	; (80316c0 <LmHandlerJoin+0x90>)
 80316a6:	69db      	ldr	r3, [r3, #28]
 80316a8:	4798      	blx	r3
        LmHandlerRequestClass(LmHandlerParams.DefaultClass);
 80316aa:	f894 0031 	ldrb.w	r0, [r4, #49]	; 0x31
 80316ae:	f7ff ff61 	bl	8031574 <LmHandlerRequestClass>
}
 80316b2:	e7d1      	b.n	8031658 <LmHandlerJoin+0x28>
 80316b4:	20003458 	.word	0x20003458
 80316b8:	200047dc 	.word	0x200047dc
 80316bc:	01000300 	.word	0x01000300
 80316c0:	20003470 	.word	0x20003470

080316c4 <LmHandlerIsBusy>:
{
 80316c4:	b510      	push	{r4, lr}
    if( LoRaMacIsBusy( ) == true )
 80316c6:	f002 fba1 	bl	8033e0c <LoRaMacIsBusy>
 80316ca:	b940      	cbnz	r0, 80316de <LmHandlerIsBusy+0x1a>
    if( LmHandlerJoinStatus( ) != LORAMAC_HANDLER_SET )
 80316cc:	f7ff ff3e 	bl	803154c <LmHandlerJoinStatus>
 80316d0:	2801      	cmp	r0, #1
 80316d2:	d005      	beq.n	80316e0 <LmHandlerIsBusy+0x1c>
        LmHandlerJoin( JoinParams.Mode );
 80316d4:	4b05      	ldr	r3, [pc, #20]	; (80316ec <LmHandlerIsBusy+0x28>)
 80316d6:	7e98      	ldrb	r0, [r3, #26]
 80316d8:	f7ff ffaa 	bl	8031630 <LmHandlerJoin>
        return true;
 80316dc:	2001      	movs	r0, #1
}
 80316de:	bd10      	pop	{r4, pc}
    if( LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->IsRunning( ) == true )
 80316e0:	4b03      	ldr	r3, [pc, #12]	; (80316f0 <LmHandlerIsBusy+0x2c>)
 80316e2:	69db      	ldr	r3, [r3, #28]
}
 80316e4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    if( LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->IsRunning( ) == true )
 80316e8:	68db      	ldr	r3, [r3, #12]
 80316ea:	4718      	bx	r3
 80316ec:	20003458 	.word	0x20003458
 80316f0:	200047dc 	.word	0x200047dc

080316f4 <LmHandlerSend>:
{
 80316f4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80316f8:	b087      	sub	sp, #28
 80316fa:	4604      	mov	r4, r0
 80316fc:	460e      	mov	r6, r1
 80316fe:	4617      	mov	r7, r2
 8031700:	4698      	mov	r8, r3
    if (LoRaMacIsBusy() == true)
 8031702:	f002 fb83 	bl	8033e0c <LoRaMacIsBusy>
 8031706:	2800      	cmp	r0, #0
 8031708:	d154      	bne.n	80317b4 <LmHandlerSend+0xc0>
    if( LmHandlerJoinStatus( ) != LORAMAC_HANDLER_SET )
 803170a:	f7ff ff1f 	bl	803154c <LmHandlerJoinStatus>
 803170e:	2801      	cmp	r0, #1
 8031710:	d008      	beq.n	8031724 <LmHandlerSend+0x30>
        LmHandlerJoin(JoinParams.Mode);
 8031712:	4b2d      	ldr	r3, [pc, #180]	; (80317c8 <LmHandlerSend+0xd4>)
 8031714:	7e98      	ldrb	r0, [r3, #26]
 8031716:	f7ff ff8b 	bl	8031630 <LmHandlerJoin>
        return LORAMAC_HANDLER_NO_NETWORK_JOINED;
 803171a:	f06f 0002 	mvn.w	r0, #2
}
 803171e:	b007      	add	sp, #28
 8031720:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if( ( LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->IsRunning( ) == true ) && ( appData->Port != LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->Port ) && ( appData->Port != 0 ) )
 8031724:	f8df 90ac 	ldr.w	r9, [pc, #172]	; 80317d4 <LmHandlerSend+0xe0>
 8031728:	f8d9 301c 	ldr.w	r3, [r9, #28]
 803172c:	68db      	ldr	r3, [r3, #12]
 803172e:	4798      	blx	r3
 8031730:	464d      	mov	r5, r9
 8031732:	b138      	cbz	r0, 8031744 <LmHandlerSend+0x50>
 8031734:	f8d9 201c 	ldr.w	r2, [r9, #28]
 8031738:	7823      	ldrb	r3, [r4, #0]
 803173a:	7812      	ldrb	r2, [r2, #0]
 803173c:	429a      	cmp	r2, r3
 803173e:	d001      	beq.n	8031744 <LmHandlerSend+0x50>
 8031740:	2b00      	cmp	r3, #0
 8031742:	d13a      	bne.n	80317ba <LmHandlerSend+0xc6>
    mcpsReq.Req.Unconfirmed.Datarate = LmHandlerParams.TxDatarate;
 8031744:	f895 3033 	ldrb.w	r3, [r5, #51]	; 0x33
    if( LoRaMacQueryTxPossible( appData->BufferSize, &txInfo ) != LORAMAC_STATUS_OK )
 8031748:	7860      	ldrb	r0, [r4, #1]
    mcpsReq.Req.Unconfirmed.Datarate = LmHandlerParams.TxDatarate;
 803174a:	f88d 3012 	strb.w	r3, [sp, #18]
    if( LoRaMacQueryTxPossible( appData->BufferSize, &txInfo ) != LORAMAC_STATUS_OK )
 803174e:	4669      	mov	r1, sp
 8031750:	f003 f9f4 	bl	8034b3c <LoRaMacQueryTxPossible>
 8031754:	b1d0      	cbz	r0, 803178c <LmHandlerSend+0x98>
        TxParams.MsgType = LORAMAC_HANDLER_UNCONFIRMED_MSG;
 8031756:	2200      	movs	r2, #0
 8031758:	70aa      	strb	r2, [r5, #2]
        mcpsReq.Type = MCPS_UNCONFIRMED;
 803175a:	f88d 2004 	strb.w	r2, [sp, #4]
        mcpsReq.Req.Unconfirmed.fBuffer = NULL;
 803175e:	9203      	str	r2, [sp, #12]
        mcpsReq.Req.Unconfirmed.fBufferSize = 0;
 8031760:	f8ad 2010 	strh.w	r2, [sp, #16]
    TxParams.AppData = *appData;
 8031764:	e894 0003 	ldmia.w	r4, {r0, r1}
 8031768:	4b18      	ldr	r3, [pc, #96]	; (80317cc <LmHandlerSend+0xd8>)
 803176a:	e883 0003 	stmia.w	r3, {r0, r1}
    TxParams.Datarate = LmHandlerParams.TxDatarate;
 803176e:	f895 3033 	ldrb.w	r3, [r5, #51]	; 0x33
 8031772:	712b      	strb	r3, [r5, #4]
    status = LoRaMacMcpsRequest(&mcpsReq, allowDelayedTx);
 8031774:	4641      	mov	r1, r8
 8031776:	a801      	add	r0, sp, #4
 8031778:	f003 fed2 	bl	8035520 <LoRaMacMcpsRequest>
    if (nextTxIn != NULL)
 803177c:	b10f      	cbz	r7, 8031782 <LmHandlerSend+0x8e>
        *nextTxIn = mcpsReq.ReqReturn.DutyCycleWaitTime;
 803177e:	9b05      	ldr	r3, [sp, #20]
 8031780:	603b      	str	r3, [r7, #0]
    switch (status)
 8031782:	2811      	cmp	r0, #17
 8031784:	d81c      	bhi.n	80317c0 <LmHandlerSend+0xcc>
 8031786:	4b12      	ldr	r3, [pc, #72]	; (80317d0 <LmHandlerSend+0xdc>)
 8031788:	5618      	ldrsb	r0, [r3, r0]
 803178a:	e7c8      	b.n	803171e <LmHandlerSend+0x2a>
        TxParams.MsgType = isTxConfirmed;
 803178c:	70ae      	strb	r6, [r5, #2]
        mcpsReq.Req.Unconfirmed.fPort = appData->Port;
 803178e:	7823      	ldrb	r3, [r4, #0]
 8031790:	f88d 3008 	strb.w	r3, [sp, #8]
        mcpsReq.Req.Unconfirmed.fBufferSize = appData->BufferSize;
 8031794:	7863      	ldrb	r3, [r4, #1]
 8031796:	f8ad 3010 	strh.w	r3, [sp, #16]
        mcpsReq.Req.Unconfirmed.fBuffer = appData->Buffer;
 803179a:	6863      	ldr	r3, [r4, #4]
 803179c:	9303      	str	r3, [sp, #12]
        if( isTxConfirmed == LORAMAC_HANDLER_UNCONFIRMED_MSG )
 803179e:	b916      	cbnz	r6, 80317a6 <LmHandlerSend+0xb2>
            mcpsReq.Type = MCPS_UNCONFIRMED;
 80317a0:	f88d 6004 	strb.w	r6, [sp, #4]
 80317a4:	e7de      	b.n	8031764 <LmHandlerSend+0x70>
            mcpsReq.Type = MCPS_CONFIRMED;
 80317a6:	2301      	movs	r3, #1
 80317a8:	f88d 3004 	strb.w	r3, [sp, #4]
            mcpsReq.Req.Confirmed.NbTrials = 8;
 80317ac:	2308      	movs	r3, #8
 80317ae:	f88d 3013 	strb.w	r3, [sp, #19]
 80317b2:	e7d7      	b.n	8031764 <LmHandlerSend+0x70>
        return LORAMAC_HANDLER_BUSY_ERROR;
 80317b4:	f06f 0001 	mvn.w	r0, #1
 80317b8:	e7b1      	b.n	803171e <LmHandlerSend+0x2a>
        return LORAMAC_HANDLER_COMPLIANCE_RUNNING;
 80317ba:	f06f 0003 	mvn.w	r0, #3
 80317be:	e7ae      	b.n	803171e <LmHandlerSend+0x2a>
 80317c0:	f04f 30ff 	mov.w	r0, #4294967295
 80317c4:	e7ab      	b.n	803171e <LmHandlerSend+0x2a>
 80317c6:	bf00      	nop
 80317c8:	20003458 	.word	0x20003458
 80317cc:	200047e8 	.word	0x200047e8
 80317d0:	0803ba38 	.word	0x0803ba38
 80317d4:	200047dc 	.word	0x200047dc

080317d8 <MlmeIndication>:
{
 80317d8:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80317da:	4604      	mov	r4, r0
    RxParams.IsMcpsIndication = 0;
 80317dc:	4b14      	ldr	r3, [pc, #80]	; (8031830 <MlmeIndication+0x58>)
    RxParams.Status = mlmeIndication->Status;
 80317de:	7862      	ldrb	r2, [r4, #1]
 80317e0:	775a      	strb	r2, [r3, #29]
    RxParams.IsMcpsIndication = 0;
 80317e2:	2000      	movs	r0, #0
 80317e4:	7718      	strb	r0, [r3, #28]
    RxParams.Rssi = RxStatus->Rssi;
 80317e6:	880d      	ldrh	r5, [r1, #0]
 80317e8:	77dd      	strb	r5, [r3, #31]
    RxParams.Snr = RxStatus->Snr;
 80317ea:	788d      	ldrb	r5, [r1, #2]
 80317ec:	f883 5020 	strb.w	r5, [r3, #32]
    RxParams.RxSlot = RxStatus->RxSlot;
 80317f0:	78c9      	ldrb	r1, [r1, #3]
 80317f2:	f883 1028 	strb.w	r1, [r3, #40]	; 0x28
    if( RxParams.Status != LORAMAC_EVENT_INFO_STATUS_BEACON_LOCKED )
 80317f6:	2a0e      	cmp	r2, #14
 80317f8:	d005      	beq.n	8031806 <MlmeIndication+0x2e>
        LmHandlerCallbacks->OnRxData( NULL, &RxParams );
 80317fa:	4a0e      	ldr	r2, [pc, #56]	; (8031834 <MlmeIndication+0x5c>)
 80317fc:	6992      	ldr	r2, [r2, #24]
 80317fe:	f103 011c 	add.w	r1, r3, #28
 8031802:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8031804:	4790      	blx	r2
    switch( mlmeIndication->MlmeIndication )
 8031806:	7823      	ldrb	r3, [r4, #0]
 8031808:	2b07      	cmp	r3, #7
 803180a:	d10e      	bne.n	803182a <MlmeIndication+0x52>
            LmHandlerAppData_t appData =
 803180c:	2300      	movs	r3, #0
 803180e:	f8ad 3000 	strh.w	r3, [sp]
 8031812:	9301      	str	r3, [sp, #4]
            if( LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->IsRunning( ) == false )
 8031814:	4b07      	ldr	r3, [pc, #28]	; (8031834 <MlmeIndication+0x5c>)
 8031816:	69db      	ldr	r3, [r3, #28]
 8031818:	68db      	ldr	r3, [r3, #12]
 803181a:	4798      	blx	r3
 803181c:	4602      	mov	r2, r0
 803181e:	b920      	cbnz	r0, 803182a <MlmeIndication+0x52>
                LmHandlerSend( &appData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true );
 8031820:	4601      	mov	r1, r0
 8031822:	2301      	movs	r3, #1
 8031824:	4668      	mov	r0, sp
 8031826:	f7ff ff65 	bl	80316f4 <LmHandlerSend>
}
 803182a:	b003      	add	sp, #12
 803182c:	bd30      	pop	{r4, r5, pc}
 803182e:	bf00      	nop
 8031830:	20003458 	.word	0x20003458
 8031834:	200047dc 	.word	0x200047dc

08031838 <LmHandlerGetCurrentClass>:
{
 8031838:	b510      	push	{r4, lr}
    if (deviceClass == NULL)
 803183a:	4604      	mov	r4, r0
{
 803183c:	b08a      	sub	sp, #40	; 0x28
    if (deviceClass == NULL)
 803183e:	b918      	cbnz	r0, 8031848 <LmHandlerGetCurrentClass+0x10>
        return LORAMAC_HANDLER_ERROR;
 8031840:	f04f 30ff 	mov.w	r0, #4294967295
}
 8031844:	b00a      	add	sp, #40	; 0x28
 8031846:	bd10      	pop	{r4, pc}
    mibReq.Type = MIB_DEVICE_CLASS;
 8031848:	2300      	movs	r3, #0
    if (LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK)
 803184a:	a801      	add	r0, sp, #4
    mibReq.Type = MIB_DEVICE_CLASS;
 803184c:	f88d 3004 	strb.w	r3, [sp, #4]
    if (LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK)
 8031850:	f003 f9cc 	bl	8034bec <LoRaMacMibGetRequestConfirm>
 8031854:	2800      	cmp	r0, #0
 8031856:	d1f3      	bne.n	8031840 <LmHandlerGetCurrentClass+0x8>
    *deviceClass = mibReq.Param.Class;
 8031858:	f89d 3008 	ldrb.w	r3, [sp, #8]
 803185c:	7023      	strb	r3, [r4, #0]
    return LORAMAC_HANDLER_SUCCESS;
 803185e:	e7f1      	b.n	8031844 <LmHandlerGetCurrentClass+0xc>

08031860 <McpsIndication>:
{
 8031860:	b5f0      	push	{r4, r5, r6, r7, lr}
 8031862:	b087      	sub	sp, #28
    DeviceClass_t deviceClass = CLASS_A;
 8031864:	2300      	movs	r3, #0
 8031866:	f88d 3007 	strb.w	r3, [sp, #7]
    RxParams.IsMcpsIndication = 1;
 803186a:	4b2c      	ldr	r3, [pc, #176]	; (803191c <McpsIndication+0xbc>)
 803186c:	2201      	movs	r2, #1
 803186e:	771a      	strb	r2, [r3, #28]
    RxParams.Status = mcpsIndication->Status;
 8031870:	7842      	ldrb	r2, [r0, #1]
 8031872:	775a      	strb	r2, [r3, #29]
{
 8031874:	4604      	mov	r4, r0
    if( RxParams.Status != LORAMAC_EVENT_INFO_STATUS_OK )
 8031876:	2a00      	cmp	r2, #0
 8031878:	d146      	bne.n	8031908 <McpsIndication+0xa8>
    RxParams.Datarate = mcpsIndication->RxDatarate;
 803187a:	7902      	ldrb	r2, [r0, #4]
 803187c:	779a      	strb	r2, [r3, #30]
    RxParams.Rssi = RxStatus->Rssi;
 803187e:	880a      	ldrh	r2, [r1, #0]
 8031880:	77da      	strb	r2, [r3, #31]
    RxParams.Snr = RxStatus->Snr;
 8031882:	788a      	ldrb	r2, [r1, #2]
 8031884:	f883 2020 	strb.w	r2, [r3, #32]
    RxParams.RxSlot = RxStatus->RxSlot;
 8031888:	78ca      	ldrb	r2, [r1, #3]
 803188a:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
    RxParams.DownlinkCounter = mcpsIndication->DownLinkCounter;
 803188e:	6902      	ldr	r2, [r0, #16]
 8031890:	625a      	str	r2, [r3, #36]	; 0x24
    appData.Port = mcpsIndication->Port;
 8031892:	78c2      	ldrb	r2, [r0, #3]
    LmHandlerCallbacks->OnRxData(&appData, &RxParams);
 8031894:	4e22      	ldr	r6, [pc, #136]	; (8031920 <McpsIndication+0xc0>)
    appData.Port = mcpsIndication->Port;
 8031896:	f88d 2008 	strb.w	r2, [sp, #8]
    appData.BufferSize = mcpsIndication->BufferSize;
 803189a:	7b02      	ldrb	r2, [r0, #12]
 803189c:	f88d 2009 	strb.w	r2, [sp, #9]
    appData.Buffer = mcpsIndication->Buffer;
 80318a0:	6882      	ldr	r2, [r0, #8]
 80318a2:	9203      	str	r2, [sp, #12]
    LmHandlerCallbacks->OnRxData(&appData, &RxParams);
 80318a4:	69b2      	ldr	r2, [r6, #24]
 80318a6:	f103 011c 	add.w	r1, r3, #28
 80318aa:	6a52      	ldr	r2, [r2, #36]	; 0x24
 80318ac:	a802      	add	r0, sp, #8
 80318ae:	4790      	blx	r2
    if ((LmHandlerCallbacks->OnSysTimeUpdate != NULL) && (mcpsIndication->DeviceTimeAnsReceived == true))
 80318b0:	69b3      	ldr	r3, [r6, #24]
 80318b2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80318b4:	b113      	cbz	r3, 80318bc <McpsIndication+0x5c>
 80318b6:	7e22      	ldrb	r2, [r4, #24]
 80318b8:	b102      	cbz	r2, 80318bc <McpsIndication+0x5c>
        LmHandlerCallbacks->OnSysTimeUpdate( );
 80318ba:	4798      	blx	r3
 80318bc:	4f19      	ldr	r7, [pc, #100]	; (8031924 <McpsIndication+0xc4>)
{
 80318be:	2500      	movs	r5, #0
        if( LmHandlerPackages[i] != NULL )
 80318c0:	f857 3b04 	ldr.w	r3, [r7], #4
 80318c4:	b153      	cbz	r3, 80318dc <McpsIndication+0x7c>
                    if( ( LmHandlerPackages[i]->OnMcpsIndicationProcess != NULL ) &&
 80318c6:	69da      	ldr	r2, [r3, #28]
 80318c8:	b142      	cbz	r2, 80318dc <McpsIndication+0x7c>
 80318ca:	781a      	ldrb	r2, [r3, #0]
 80318cc:	78e3      	ldrb	r3, [r4, #3]
 80318ce:	429a      	cmp	r2, r3
 80318d0:	d11c      	bne.n	803190c <McpsIndication+0xac>
                        LmHandlerPackages[i]->OnMcpsIndicationProcess( ( McpsIndication_t* )params );
 80318d2:	f857 3c04 	ldr.w	r3, [r7, #-4]
 80318d6:	4620      	mov	r0, r4
 80318d8:	69db      	ldr	r3, [r3, #28]
 80318da:	4798      	blx	r3
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 80318dc:	1c6b      	adds	r3, r5, #1
 80318de:	b2da      	uxtb	r2, r3
 80318e0:	2a05      	cmp	r2, #5
 80318e2:	b25d      	sxtb	r5, r3
 80318e4:	d1ec      	bne.n	80318c0 <McpsIndication+0x60>
    LmHandlerGetCurrentClass(&deviceClass);
 80318e6:	f10d 0007 	add.w	r0, sp, #7
 80318ea:	f7ff ffa5 	bl	8031838 <LmHandlerGetCurrentClass>
    if ((mcpsIndication->FramePending == true) && (deviceClass == CLASS_A))
 80318ee:	7963      	ldrb	r3, [r4, #5]
 80318f0:	2b01      	cmp	r3, #1
 80318f2:	d109      	bne.n	8031908 <McpsIndication+0xa8>
 80318f4:	f89d 2007 	ldrb.w	r2, [sp, #7]
 80318f8:	b932      	cbnz	r2, 8031908 <McpsIndication+0xa8>
        LmHandlerSend(&appData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true);
 80318fa:	4611      	mov	r1, r2
 80318fc:	a804      	add	r0, sp, #16
        LmHandlerAppData_t appData =
 80318fe:	f8ad 2010 	strh.w	r2, [sp, #16]
 8031902:	9205      	str	r2, [sp, #20]
        LmHandlerSend(&appData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true);
 8031904:	f7ff fef6 	bl	80316f4 <LmHandlerSend>
}
 8031908:	b007      	add	sp, #28
 803190a:	bdf0      	pop	{r4, r5, r6, r7, pc}
                        ( ( LmHandlerPackages[i]->Port == ((McpsIndication_t* )params)->Port ) ||
 803190c:	2d00      	cmp	r5, #0
 803190e:	d1e5      	bne.n	80318dc <McpsIndication+0x7c>
                          ( ( i == PACKAGE_ID_COMPLIANCE ) && ( LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->IsRunning() ))))
 8031910:	69f3      	ldr	r3, [r6, #28]
 8031912:	68db      	ldr	r3, [r3, #12]
 8031914:	4798      	blx	r3
 8031916:	2800      	cmp	r0, #0
 8031918:	d1db      	bne.n	80318d2 <McpsIndication+0x72>
 803191a:	e7df      	b.n	80318dc <McpsIndication+0x7c>
 803191c:	20003458 	.word	0x20003458
 8031920:	200047dc 	.word	0x200047dc
 8031924:	200047f8 	.word	0x200047f8

08031928 <LmHandlerGetTxDatarate>:
{
 8031928:	b510      	push	{r4, lr}
    if (txDatarate == NULL)
 803192a:	4604      	mov	r4, r0
{
 803192c:	b08a      	sub	sp, #40	; 0x28
    if (txDatarate == NULL)
 803192e:	b918      	cbnz	r0, 8031938 <LmHandlerGetTxDatarate+0x10>
        return LORAMAC_HANDLER_ERROR;
 8031930:	f04f 30ff 	mov.w	r0, #4294967295
}
 8031934:	b00a      	add	sp, #40	; 0x28
 8031936:	bd10      	pop	{r4, pc}
    mibGet.Type = MIB_CHANNELS_DATARATE;
 8031938:	231f      	movs	r3, #31
    if (LoRaMacMibGetRequestConfirm( &mibGet ) != LORAMAC_STATUS_OK)
 803193a:	a801      	add	r0, sp, #4
    mibGet.Type = MIB_CHANNELS_DATARATE;
 803193c:	f88d 3004 	strb.w	r3, [sp, #4]
    if (LoRaMacMibGetRequestConfirm( &mibGet ) != LORAMAC_STATUS_OK)
 8031940:	f003 f954 	bl	8034bec <LoRaMacMibGetRequestConfirm>
 8031944:	2800      	cmp	r0, #0
 8031946:	d1f3      	bne.n	8031930 <LmHandlerGetTxDatarate+0x8>
    LmHandlerParams.TxDatarate = *txDatarate;
 8031948:	4a03      	ldr	r2, [pc, #12]	; (8031958 <LmHandlerGetTxDatarate+0x30>)
    *txDatarate = mibGet.Param.ChannelsDatarate;
 803194a:	f99d 3008 	ldrsb.w	r3, [sp, #8]
 803194e:	7023      	strb	r3, [r4, #0]
    LmHandlerParams.TxDatarate = *txDatarate;
 8031950:	f882 3033 	strb.w	r3, [r2, #51]	; 0x33
    return LORAMAC_HANDLER_SUCCESS;
 8031954:	e7ee      	b.n	8031934 <LmHandlerGetTxDatarate+0xc>
 8031956:	bf00      	nop
 8031958:	200047dc 	.word	0x200047dc

0803195c <MlmeConfirm>:
{
 803195c:	b5f0      	push	{r4, r5, r6, r7, lr}
    TxParams.IsMcpsConfirm = 0;
 803195e:	4e23      	ldr	r6, [pc, #140]	; (80319ec <MlmeConfirm+0x90>)
    TxParams.Status = mlmeConfirm->Status;
 8031960:	7843      	ldrb	r3, [r0, #1]
 8031962:	7073      	strb	r3, [r6, #1]
    LmHandlerCallbacks->OnTxData( &TxParams );
 8031964:	69b3      	ldr	r3, [r6, #24]
    TxParams.IsMcpsConfirm = 0;
 8031966:	2500      	movs	r5, #0
    LmHandlerCallbacks->OnTxData( &TxParams );
 8031968:	6a1b      	ldr	r3, [r3, #32]
    TxParams.IsMcpsConfirm = 0;
 803196a:	7035      	strb	r5, [r6, #0]
{
 803196c:	b08b      	sub	sp, #44	; 0x2c
 803196e:	4604      	mov	r4, r0
    LmHandlerCallbacks->OnTxData( &TxParams );
 8031970:	4630      	mov	r0, r6
 8031972:	4798      	blx	r3
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 8031974:	f106 071c 	add.w	r7, r6, #28
        if( LmHandlerPackages[i] != NULL )
 8031978:	f857 3b04 	ldr.w	r3, [r7], #4
 803197c:	b11b      	cbz	r3, 8031986 <MlmeConfirm+0x2a>
                    if( LmHandlerPackages[i]->OnMlmeConfirmProcess != NULL )
 803197e:	6a1b      	ldr	r3, [r3, #32]
 8031980:	b10b      	cbz	r3, 8031986 <MlmeConfirm+0x2a>
                        LmHandlerPackages[i]->OnMlmeConfirmProcess( ( MlmeConfirm_t* )params );
 8031982:	4620      	mov	r0, r4
 8031984:	4798      	blx	r3
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 8031986:	3501      	adds	r5, #1
 8031988:	b2eb      	uxtb	r3, r5
 803198a:	2b05      	cmp	r3, #5
 803198c:	b26d      	sxtb	r5, r5
 803198e:	d1f3      	bne.n	8031978 <MlmeConfirm+0x1c>
    switch( mlmeConfirm->MlmeRequest )
 8031990:	7823      	ldrb	r3, [r4, #0]
 8031992:	2b01      	cmp	r3, #1
 8031994:	d003      	beq.n	803199e <MlmeConfirm+0x42>
 8031996:	2b04      	cmp	r3, #4
 8031998:	d01d      	beq.n	80319d6 <MlmeConfirm+0x7a>
}
 803199a:	b00b      	add	sp, #44	; 0x2c
 803199c:	bdf0      	pop	{r4, r5, r6, r7, pc}
            CommissioningParams.DevAddr = mibReq.Param.DevAddr;
 803199e:	4d14      	ldr	r5, [pc, #80]	; (80319f0 <MlmeConfirm+0x94>)
            mibReq.Type = MIB_DEV_ADDR;
 80319a0:	2306      	movs	r3, #6
            LoRaMacMibGetRequestConfirm( &mibReq );
 80319a2:	a801      	add	r0, sp, #4
            mibReq.Type = MIB_DEV_ADDR;
 80319a4:	f88d 3004 	strb.w	r3, [sp, #4]
            LoRaMacMibGetRequestConfirm( &mibReq );
 80319a8:	f003 f920 	bl	8034bec <LoRaMacMibGetRequestConfirm>
            CommissioningParams.DevAddr = mibReq.Param.DevAddr;
 80319ac:	9b02      	ldr	r3, [sp, #8]
 80319ae:	616b      	str	r3, [r5, #20]
            LmHandlerGetTxDatarate( &JoinParams.Datarate );
 80319b0:	f105 0018 	add.w	r0, r5, #24
 80319b4:	f7ff ffb8 	bl	8031928 <LmHandlerGetTxDatarate>
            if( mlmeConfirm->Status == LORAMAC_EVENT_INFO_STATUS_OK )
 80319b8:	7863      	ldrb	r3, [r4, #1]
 80319ba:	b94b      	cbnz	r3, 80319d0 <MlmeConfirm+0x74>
                LmHandlerRequestClass(LmHandlerParams.DefaultClass);
 80319bc:	f896 0031 	ldrb.w	r0, [r6, #49]	; 0x31
                JoinParams.Status = LORAMAC_HANDLER_SUCCESS;
 80319c0:	766b      	strb	r3, [r5, #25]
                LmHandlerRequestClass(LmHandlerParams.DefaultClass);
 80319c2:	f7ff fdd7 	bl	8031574 <LmHandlerRequestClass>
            LmHandlerCallbacks->OnJoinRequest( &JoinParams );
 80319c6:	69b3      	ldr	r3, [r6, #24]
 80319c8:	480a      	ldr	r0, [pc, #40]	; (80319f4 <MlmeConfirm+0x98>)
 80319ca:	69db      	ldr	r3, [r3, #28]
 80319cc:	4798      	blx	r3
}
 80319ce:	e7e4      	b.n	803199a <MlmeConfirm+0x3e>
                JoinParams.Status = LORAMAC_HANDLER_ERROR;
 80319d0:	23ff      	movs	r3, #255	; 0xff
 80319d2:	766b      	strb	r3, [r5, #25]
 80319d4:	e7f7      	b.n	80319c6 <MlmeConfirm+0x6a>
            RxParams.LinkCheck = true;
 80319d6:	4b06      	ldr	r3, [pc, #24]	; (80319f0 <MlmeConfirm+0x94>)
 80319d8:	2201      	movs	r2, #1
 80319da:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
            RxParams.DemodMargin = mlmeConfirm->DemodMargin;
 80319de:	7a22      	ldrb	r2, [r4, #8]
 80319e0:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
            RxParams.NbGateways = mlmeConfirm->NbGateways;
 80319e4:	7a62      	ldrb	r2, [r4, #9]
 80319e6:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
}
 80319ea:	e7d6      	b.n	803199a <MlmeConfirm+0x3e>
 80319ec:	200047dc 	.word	0x200047dc
 80319f0:	20003458 	.word	0x20003458
 80319f4:	20003470 	.word	0x20003470

080319f8 <LmHandlerPackageRegister>:
{
 80319f8:	b537      	push	{r0, r1, r2, r4, r5, lr}
    LmhPackage_t *package = NULL;
 80319fa:	2300      	movs	r3, #0
{
 80319fc:	460d      	mov	r5, r1
    LmhPackage_t *package = NULL;
 80319fe:	9301      	str	r3, [sp, #4]
    switch( id )
 8031a00:	4604      	mov	r4, r0
 8031a02:	b9c8      	cbnz	r0, 8031a38 <LmHandlerPackageRegister+0x40>
            package = LmhpCompliancePackageFactory( );
 8031a04:	f000 fb94 	bl	8032130 <LmhpCompliancePackageFactory>
 8031a08:	9001      	str	r0, [sp, #4]
    if( package != NULL )
 8031a0a:	9b01      	ldr	r3, [sp, #4]
 8031a0c:	b1c3      	cbz	r3, 8031a40 <LmHandlerPackageRegister+0x48>
        LmHandlerPackages[id]->OnJoinRequest = LmHandlerJoin;
 8031a0e:	4a0e      	ldr	r2, [pc, #56]	; (8031a48 <LmHandlerPackageRegister+0x50>)
        LmHandlerPackages[id] = package;
 8031a10:	490e      	ldr	r1, [pc, #56]	; (8031a4c <LmHandlerPackageRegister+0x54>)
        LmHandlerPackages[id]->OnJoinRequest = LmHandlerJoin;
 8031a12:	625a      	str	r2, [r3, #36]	; 0x24
        LmHandlerPackages[id]->OnSendRequest = LmHandlerSend;
 8031a14:	4a0e      	ldr	r2, [pc, #56]	; (8031a50 <LmHandlerPackageRegister+0x58>)
 8031a16:	629a      	str	r2, [r3, #40]	; 0x28
        LmHandlerPackages[id]->OnDeviceTimeRequest = LmHandlerDeviceTimeReq;
 8031a18:	4a0e      	ldr	r2, [pc, #56]	; (8031a54 <LmHandlerPackageRegister+0x5c>)
 8031a1a:	62da      	str	r2, [r3, #44]	; 0x2c
        LmHandlerPackages[id]->OnPackageProcessEvent = LmHandlerCallbacks->OnMacProcess;
 8031a1c:	698a      	ldr	r2, [r1, #24]
        LmHandlerPackages[id] = package;
 8031a1e:	eb01 0484 	add.w	r4, r1, r4, lsl #2
        LmHandlerPackages[id]->OnPackageProcessEvent = LmHandlerCallbacks->OnMacProcess;
 8031a22:	6912      	ldr	r2, [r2, #16]
 8031a24:	615a      	str	r2, [r3, #20]
        LmHandlerPackages[id] = package;
 8031a26:	61e3      	str	r3, [r4, #28]
        LmHandlerPackages[id]->Init( params, AppData.Buffer, AppData.BufferSize );
 8031a28:	4628      	mov	r0, r5
 8031a2a:	685b      	ldr	r3, [r3, #4]
 8031a2c:	22f2      	movs	r2, #242	; 0xf2
 8031a2e:	3165      	adds	r1, #101	; 0x65
 8031a30:	4798      	blx	r3
        return LORAMAC_HANDLER_SUCCESS;
 8031a32:	2000      	movs	r0, #0
}
 8031a34:	b003      	add	sp, #12
 8031a36:	bd30      	pop	{r4, r5, pc}
            LmhpPackagesRegister(id, &package);
 8031a38:	a901      	add	r1, sp, #4
 8031a3a:	f000 ff27 	bl	803288c <LmhpPackagesRegister>
            break;
 8031a3e:	e7e4      	b.n	8031a0a <LmHandlerPackageRegister+0x12>
        return LORAMAC_HANDLER_ERROR;
 8031a40:	f04f 30ff 	mov.w	r0, #4294967295
 8031a44:	e7f6      	b.n	8031a34 <LmHandlerPackageRegister+0x3c>
 8031a46:	bf00      	nop
 8031a48:	08031631 	.word	0x08031631
 8031a4c:	200047dc 	.word	0x200047dc
 8031a50:	080316f5 	.word	0x080316f5
 8031a54:	080312f9 	.word	0x080312f9

08031a58 <LmHandlerInit>:
{
 8031a58:	b508      	push	{r3, lr}
    LmHandlerCallbacks = handlerCallbacks;
 8031a5a:	4b11      	ldr	r3, [pc, #68]	; (8031aa0 <LmHandlerInit+0x48>)
    LoRaMacPrimitives.MacMcpsConfirm = McpsConfirm;
 8031a5c:	4a11      	ldr	r2, [pc, #68]	; (8031aa4 <LmHandlerInit+0x4c>)
 8031a5e:	655a      	str	r2, [r3, #84]	; 0x54
    LoRaMacPrimitives.MacMcpsIndication = McpsIndication;
 8031a60:	4a11      	ldr	r2, [pc, #68]	; (8031aa8 <LmHandlerInit+0x50>)
 8031a62:	659a      	str	r2, [r3, #88]	; 0x58
    LoRaMacPrimitives.MacMlmeConfirm = MlmeConfirm;
 8031a64:	4a11      	ldr	r2, [pc, #68]	; (8031aac <LmHandlerInit+0x54>)
 8031a66:	65da      	str	r2, [r3, #92]	; 0x5c
    LoRaMacPrimitives.MacMlmeIndication = MlmeIndication;
 8031a68:	4a11      	ldr	r2, [pc, #68]	; (8031ab0 <LmHandlerInit+0x58>)
 8031a6a:	661a      	str	r2, [r3, #96]	; 0x60
    LoRaMacCallbacks.GetBatteryLevel = LmHandlerCallbacks->GetBatteryLevel;
 8031a6c:	6802      	ldr	r2, [r0, #0]
 8031a6e:	641a      	str	r2, [r3, #64]	; 0x40
    LoRaMacCallbacks.GetTemperatureLevel = LmHandlerCallbacks->GetTemperature;
 8031a70:	6842      	ldr	r2, [r0, #4]
 8031a72:	645a      	str	r2, [r3, #68]	; 0x44
    LoRaMacCallbacks.GetUniqueId = LmHandlerCallbacks->GetUniqueId;
 8031a74:	6882      	ldr	r2, [r0, #8]
 8031a76:	649a      	str	r2, [r3, #72]	; 0x48
    LoRaMacCallbacks.NvmDataChange  = NvmDataMgmtEvent;
 8031a78:	4a0e      	ldr	r2, [pc, #56]	; (8031ab4 <LmHandlerInit+0x5c>)
    LmHandlerCallbacks = handlerCallbacks;
 8031a7a:	6198      	str	r0, [r3, #24]
    LoRaMacCallbacks.NvmDataChange  = NvmDataMgmtEvent;
 8031a7c:	64da      	str	r2, [r3, #76]	; 0x4c
    if (LmHandlerPackageRegister(PACKAGE_ID_COMPLIANCE, &LmhpComplianceParams) != LORAMAC_HANDLER_SUCCESS)
 8031a7e:	490e      	ldr	r1, [pc, #56]	; (8031ab8 <LmHandlerInit+0x60>)
    LoRaMacCallbacks.MacProcessNotify = LmHandlerCallbacks->OnMacProcess;
 8031a80:	6902      	ldr	r2, [r0, #16]
 8031a82:	651a      	str	r2, [r3, #80]	; 0x50
    if (LmHandlerPackageRegister(PACKAGE_ID_COMPLIANCE, &LmhpComplianceParams) != LORAMAC_HANDLER_SUCCESS)
 8031a84:	2000      	movs	r0, #0
 8031a86:	f7ff ffb7 	bl	80319f8 <LmHandlerPackageRegister>
 8031a8a:	b930      	cbnz	r0, 8031a9a <LmHandlerInit+0x42>
    if (LmhpPackagesRegistrationInit() != LORAMAC_HANDLER_SUCCESS)
 8031a8c:	f000 fede 	bl	803284c <LmhpPackagesRegistrationInit>
 8031a90:	3800      	subs	r0, #0
 8031a92:	bf18      	it	ne
 8031a94:	2001      	movne	r0, #1
 8031a96:	4240      	negs	r0, r0
}
 8031a98:	bd08      	pop	{r3, pc}
        return LORAMAC_HANDLER_ERROR;
 8031a9a:	f04f 30ff 	mov.w	r0, #4294967295
 8031a9e:	e7fb      	b.n	8031a98 <LmHandlerInit+0x40>
 8031aa0:	200047dc 	.word	0x200047dc
 8031aa4:	08031315 	.word	0x08031315
 8031aa8:	08031861 	.word	0x08031861
 8031aac:	0803195d 	.word	0x0803195d
 8031ab0:	080317d9 	.word	0x080317d9
 8031ab4:	08036697 	.word	0x08036697
 8031ab8:	20003484 	.word	0x20003484

08031abc <LmHandlerGetDutyCycleEnable>:
    if (dutyCycleEnable == NULL)
 8031abc:	b128      	cbz	r0, 8031aca <LmHandlerGetDutyCycleEnable+0xe>
    *dutyCycleEnable = LmHandlerParams.DutyCycleEnabled;
 8031abe:	4b04      	ldr	r3, [pc, #16]	; (8031ad0 <LmHandlerGetDutyCycleEnable+0x14>)
 8031ac0:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8031ac4:	7003      	strb	r3, [r0, #0]
    return LORAMAC_HANDLER_SUCCESS;
 8031ac6:	2000      	movs	r0, #0
 8031ac8:	4770      	bx	lr
        return LORAMAC_HANDLER_ERROR;
 8031aca:	f04f 30ff 	mov.w	r0, #4294967295
}
 8031ace:	4770      	bx	lr
 8031ad0:	200047dc 	.word	0x200047dc

08031ad4 <LmHandlerSetDutyCycleEnable>:
{
 8031ad4:	b508      	push	{r3, lr}
    LmHandlerParams.DutyCycleEnabled = dutyCycleEnable;
 8031ad6:	4b03      	ldr	r3, [pc, #12]	; (8031ae4 <LmHandlerSetDutyCycleEnable+0x10>)
 8031ad8:	f883 0035 	strb.w	r0, [r3, #53]	; 0x35
    LoRaMacTestSetDutyCycleOn(dutyCycleEnable);
 8031adc:	f003 fea6 	bl	803582c <LoRaMacTestSetDutyCycleOn>
}
 8031ae0:	2000      	movs	r0, #0
 8031ae2:	bd08      	pop	{r3, pc}
 8031ae4:	200047dc 	.word	0x200047dc

08031ae8 <LmhpClockSyncIsInitialized>:
}

static bool LmhpClockSyncIsInitialized( void )
{
    return LmhpClockSyncState.Initialized;
}
 8031ae8:	4b01      	ldr	r3, [pc, #4]	; (8031af0 <LmhpClockSyncIsInitialized+0x8>)
 8031aea:	7818      	ldrb	r0, [r3, #0]
 8031aec:	4770      	bx	lr
 8031aee:	bf00      	nop
 8031af0:	20004934 	.word	0x20004934

08031af4 <LmhpClockSyncIsRunning>:

static bool LmhpClockSyncIsRunning( void )
{
    if( LmhpClockSyncState.Initialized == false )
 8031af4:	4b02      	ldr	r3, [pc, #8]	; (8031b00 <LmhpClockSyncIsRunning+0xc>)
 8031af6:	7818      	ldrb	r0, [r3, #0]
 8031af8:	b100      	cbz	r0, 8031afc <LmhpClockSyncIsRunning+0x8>
    {
        return false;
    }

    return LmhpClockSyncState.IsRunning;
 8031afa:	7858      	ldrb	r0, [r3, #1]
}
 8031afc:	4770      	bx	lr
 8031afe:	bf00      	nop
 8031b00:	20004934 	.word	0x20004934

08031b04 <OnPeriodicTimeStartTimer>:

    return status;
}

static void OnPeriodicTimeStartTimer(void *context)
{
 8031b04:	b510      	push	{r4, lr}
  LmhpClockSyncState.NbTransmissions = 1;
 8031b06:	4805      	ldr	r0, [pc, #20]	; (8031b1c <OnPeriodicTimeStartTimer+0x18>)
 8031b08:	2301      	movs	r3, #1
 8031b0a:	7343      	strb	r3, [r0, #13]
  TimerStart(&PeriodicTimeStartTimer);
 8031b0c:	3010      	adds	r0, #16
 8031b0e:	f009 fc2f 	bl	803b370 <UTIL_TIMER_Start>
  LmhpClockSyncPackage.OnPackageProcessEvent();
 8031b12:	4b03      	ldr	r3, [pc, #12]	; (8031b20 <OnPeriodicTimeStartTimer+0x1c>)
}
 8031b14:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  LmhpClockSyncPackage.OnPackageProcessEvent();
 8031b18:	695b      	ldr	r3, [r3, #20]
 8031b1a:	4718      	bx	r3
 8031b1c:	20004934 	.word	0x20004934
 8031b20:	20003490 	.word	0x20003490

08031b24 <LmhpClockSyncOnMcpsIndication>:
{
 8031b24:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if( mcpsIndication->Port != CLOCK_SYNC_PORT )
 8031b28:	78c3      	ldrb	r3, [r0, #3]
 8031b2a:	2bca      	cmp	r3, #202	; 0xca
{
 8031b2c:	b085      	sub	sp, #20
 8031b2e:	4680      	mov	r8, r0
    if( mcpsIndication->Port != CLOCK_SYNC_PORT )
 8031b30:	f000 80ba 	beq.w	8031ca8 <LmhpClockSyncOnMcpsIndication+0x184>
}
 8031b34:	b005      	add	sp, #20
 8031b36:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        switch( mcpsIndication->Buffer[cmdIndex++] )
 8031b3a:	f8d8 1008 	ldr.w	r1, [r8, #8]
 8031b3e:	5cc8      	ldrb	r0, [r1, r3]
 8031b40:	1c5a      	adds	r2, r3, #1
 8031b42:	b2d2      	uxtb	r2, r2
 8031b44:	2803      	cmp	r0, #3
 8031b46:	d80f      	bhi.n	8031b68 <LmhpClockSyncOnMcpsIndication+0x44>
 8031b48:	e8df f000 	tbb	[pc, r0]
 8031b4c:	a76e1002 	.word	0xa76e1002
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = CLOCK_SYNC_PKG_VERSION_ANS;
 8031b50:	6871      	ldr	r1, [r6, #4]
 8031b52:	2300      	movs	r3, #0
 8031b54:	550b      	strb	r3, [r1, r4]
 8031b56:	1c60      	adds	r0, r4, #1
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = CLOCK_SYNC_ID;
 8031b58:	1ca3      	adds	r3, r4, #2
 8031b5a:	b2db      	uxtb	r3, r3
 8031b5c:	b2c0      	uxtb	r0, r0
 8031b5e:	2501      	movs	r5, #1
 8031b60:	540d      	strb	r5, [r1, r0]
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = CLOCK_SYNC_VERSION;
 8031b62:	3403      	adds	r4, #3
 8031b64:	54cd      	strb	r5, [r1, r3]
 8031b66:	b2e4      	uxtb	r4, r4
        switch( mcpsIndication->Buffer[cmdIndex++] )
 8031b68:	4617      	mov	r7, r2
 8031b6a:	e03b      	b.n	8031be4 <LmhpClockSyncOnMcpsIndication+0xc0>
                LmhpClockSyncState.NbTransmissions = 0;
 8031b6c:	2000      	movs	r0, #0
 8031b6e:	7370      	strb	r0, [r6, #13]
                if( mcpsIndication->DeviceTimeAnsReceived == true )
 8031b70:	f898 0018 	ldrb.w	r0, [r8, #24]
 8031b74:	1d9f      	adds	r7, r3, #6
 8031b76:	b2ff      	uxtb	r7, r7
 8031b78:	2800      	cmp	r0, #0
 8031b7a:	d133      	bne.n	8031be4 <LmhpClockSyncOnMcpsIndication+0xc0>
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8031b7c:	1d58      	adds	r0, r3, #5
                if( ( mcpsIndication->Buffer[cmdIndex++] & 0x0F ) == LmhpClockSyncState.TimeReqParam.Fields.TokenReq )
 8031b7e:	b2c0      	uxtb	r0, r0
 8031b80:	7a35      	ldrb	r5, [r6, #8]
 8031b82:	5c08      	ldrb	r0, [r1, r0]
 8031b84:	f005 050f 	and.w	r5, r5, #15
 8031b88:	f000 000f 	and.w	r0, r0, #15
 8031b8c:	4285      	cmp	r5, r0
 8031b8e:	d129      	bne.n	8031be4 <LmhpClockSyncOnMcpsIndication+0xc0>
                timeCorrection  = ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8031b90:	5c8d      	ldrb	r5, [r1, r2]
 8031b92:	1c9a      	adds	r2, r3, #2
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8031b94:	b2d2      	uxtb	r2, r2
                    curTime = SysTimeGet( );
 8031b96:	f10d 0b08 	add.w	fp, sp, #8
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8031b9a:	5c8a      	ldrb	r2, [r1, r2]
 8031b9c:	eb05 2502 	add.w	r5, r5, r2, lsl #8
 8031ba0:	1cda      	adds	r2, r3, #3
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8031ba2:	b2d2      	uxtb	r2, r2
 8031ba4:	3304      	adds	r3, #4
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8031ba6:	b2db      	uxtb	r3, r3
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8031ba8:	5c8a      	ldrb	r2, [r1, r2]
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8031baa:	5ccb      	ldrb	r3, [r1, r3]
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8031bac:	eb05 4502 	add.w	r5, r5, r2, lsl #16
                    curTime = SysTimeGet( );
 8031bb0:	4658      	mov	r0, fp
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8031bb2:	eb05 6503 	add.w	r5, r5, r3, lsl #24
                    curTime = SysTimeGet( );
 8031bb6:	f009 fa9d 	bl	803b0f4 <SysTimeGet>
                    curTime.Seconds += timeCorrection;
 8031bba:	9b02      	ldr	r3, [sp, #8]
 8031bbc:	442b      	add	r3, r5
                    SysTimeSet( curTime );
 8031bbe:	9302      	str	r3, [sp, #8]
 8031bc0:	e89b 0003 	ldmia.w	fp, {r0, r1}
 8031bc4:	f009 fa6e 	bl	803b0a4 <SysTimeSet>
                    LmhpClockSyncState.TimeReqParam.Fields.TokenReq = ( LmhpClockSyncState.TimeReqParam.Fields.TokenReq + 1 ) & 0x0F;
 8031bc8:	7a33      	ldrb	r3, [r6, #8]
 8031bca:	f3c3 0203 	ubfx	r2, r3, #0, #4
 8031bce:	3201      	adds	r2, #1
 8031bd0:	f362 0303 	bfi	r3, r2, #0, #4
 8031bd4:	7233      	strb	r3, [r6, #8]
                    if( LmhpClockSyncPackage.OnSysTimeUpdate != NULL )
 8031bd6:	4b38      	ldr	r3, [pc, #224]	; (8031cb8 <LmhpClockSyncOnMcpsIndication+0x194>)
 8031bd8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8031bda:	b11b      	cbz	r3, 8031be4 <LmhpClockSyncOnMcpsIndication+0xc0>
                        if( ( timeCorrection >= -1 ) && ( timeCorrection <= 1 ) )
 8031bdc:	3501      	adds	r5, #1
 8031bde:	2d02      	cmp	r5, #2
 8031be0:	d800      	bhi.n	8031be4 <LmhpClockSyncOnMcpsIndication+0xc0>
                            LmhpClockSyncPackage.OnSysTimeUpdate( );
 8031be2:	4798      	blx	r3
        switch( mcpsIndication->Buffer[cmdIndex++] )
 8031be4:	463b      	mov	r3, r7
    while( cmdIndex < mcpsIndication->BufferSize )
 8031be6:	f898 200c 	ldrb.w	r2, [r8, #12]
 8031bea:	429a      	cmp	r2, r3
 8031bec:	d8a5      	bhi.n	8031b3a <LmhpClockSyncOnMcpsIndication+0x16>
    if( dataBufferIndex != 0 )
 8031bee:	2c00      	cmp	r4, #0
 8031bf0:	d0a0      	beq.n	8031b34 <LmhpClockSyncOnMcpsIndication+0x10>
        LmHandlerAppData_t appData =
 8031bf2:	23ca      	movs	r3, #202	; 0xca
 8031bf4:	f88d 3008 	strb.w	r3, [sp, #8]
            .Buffer = LmhpClockSyncState.DataBuffer,
 8031bf8:	4b30      	ldr	r3, [pc, #192]	; (8031cbc <LmhpClockSyncOnMcpsIndication+0x198>)
        LmHandlerAppData_t appData =
 8031bfa:	f88d 4009 	strb.w	r4, [sp, #9]
 8031bfe:	685b      	ldr	r3, [r3, #4]
 8031c00:	9303      	str	r3, [sp, #12]
        LmHandlerGetDutyCycleEnable(&current_dutycycle);
 8031c02:	f10d 0007 	add.w	r0, sp, #7
 8031c06:	f7ff ff59 	bl	8031abc <LmHandlerGetDutyCycleEnable>
        LmHandlerSetDutyCycleEnable(false);
 8031c0a:	2000      	movs	r0, #0
 8031c0c:	f7ff ff62 	bl	8031ad4 <LmHandlerSetDutyCycleEnable>
        LmhpClockSyncPackage.OnSendRequest(&appData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true);
 8031c10:	4b29      	ldr	r3, [pc, #164]	; (8031cb8 <LmhpClockSyncOnMcpsIndication+0x194>)
 8031c12:	2200      	movs	r2, #0
 8031c14:	6a9c      	ldr	r4, [r3, #40]	; 0x28
 8031c16:	4611      	mov	r1, r2
 8031c18:	2301      	movs	r3, #1
 8031c1a:	a802      	add	r0, sp, #8
 8031c1c:	47a0      	blx	r4
        LmHandlerSetDutyCycleEnable(current_dutycycle);
 8031c1e:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8031c22:	f7ff ff57 	bl	8031ad4 <LmHandlerSetDutyCycleEnable>
 8031c26:	e785      	b.n	8031b34 <LmhpClockSyncOnMcpsIndication+0x10>
                uint32_t periodTime = mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8031c28:	1cdf      	adds	r7, r3, #3
                cmdIndex++;
 8031c2a:	3302      	adds	r3, #2
                uint32_t periodTime = mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8031c2c:	b2db      	uxtb	r3, r3
                periodTime = (128 << periodTime) + randr(0, 30);
 8031c2e:	2000      	movs	r0, #0
                uint32_t periodTime = mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8031c30:	5ccd      	ldrb	r5, [r1, r3]
 8031c32:	f005 010f 	and.w	r1, r5, #15
                periodTime = (128 << periodTime) + randr(0, 30);
 8031c36:	2580      	movs	r5, #128	; 0x80
 8031c38:	408d      	lsls	r5, r1
 8031c3a:	211e      	movs	r1, #30
 8031c3c:	f007 f924 	bl	8038e88 <randr>
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = CLOCK_SYNC_APP_TIME_PERIOD_ANS;
 8031c40:	6872      	ldr	r2, [r6, #4]
 8031c42:	2302      	movs	r3, #2
 8031c44:	5513      	strb	r3, [r2, r4]
 8031c46:	1c63      	adds	r3, r4, #1
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = 0x00;
 8031c48:	b2db      	uxtb	r3, r3
 8031c4a:	2100      	movs	r1, #0
 8031c4c:	54d1      	strb	r1, [r2, r3]
                periodTime = (128 << periodTime) + randr(0, 30);
 8031c4e:	4683      	mov	fp, r0
                SysTime_t curTime = SysTimeGet( );
 8031c50:	a802      	add	r0, sp, #8
 8031c52:	f009 fa4f 	bl	803b0f4 <SysTimeGet>
                curTime.Seconds -= UNIX_GPS_EPOCH_OFFSET;
 8031c56:	9b02      	ldr	r3, [sp, #8]
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 0  ) & 0xFF;
 8031c58:	6872      	ldr	r2, [r6, #4]
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = 0x00;
 8031c5a:	1ca1      	adds	r1, r4, #2
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 0  ) & 0xFF;
 8031c5c:	b2c9      	uxtb	r1, r1
                curTime.Seconds -= UNIX_GPS_EPOCH_OFFSET;
 8031c5e:	4453      	add	r3, sl
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 0  ) & 0xFF;
 8031c60:	5453      	strb	r3, [r2, r1]
 8031c62:	1ce1      	adds	r1, r4, #3
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 8  ) & 0xFF;
 8031c64:	b2c9      	uxtb	r1, r1
 8031c66:	0a18      	lsrs	r0, r3, #8
 8031c68:	5450      	strb	r0, [r2, r1]
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 16 ) & 0xFF;
 8031c6a:	1d61      	adds	r1, r4, #5
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 8  ) & 0xFF;
 8031c6c:	1d20      	adds	r0, r4, #4
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 16 ) & 0xFF;
 8031c6e:	b2c9      	uxtb	r1, r1
 8031c70:	b2c0      	uxtb	r0, r0
 8031c72:	ea4f 4c13 	mov.w	ip, r3, lsr #16
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 24 ) & 0xFF;
 8031c76:	0e1b      	lsrs	r3, r3, #24
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 16 ) & 0xFF;
 8031c78:	f802 c000 	strb.w	ip, [r2, r0]
                periodTime = (128 << periodTime) + randr(0, 30);
 8031c7c:	445d      	add	r5, fp
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 24 ) & 0xFF;
 8031c7e:	5453      	strb	r3, [r2, r1]
                TimerSetValue(&PeriodicTimeStartTimer, periodTime * 1000);
 8031c80:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8031c84:	4369      	muls	r1, r5
 8031c86:	4648      	mov	r0, r9
 8031c88:	f009 fbac 	bl	803b3e4 <UTIL_TIMER_SetPeriod>
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 24 ) & 0xFF;
 8031c8c:	3406      	adds	r4, #6
                TimerStart(&PeriodicTimeStartTimer);
 8031c8e:	4648      	mov	r0, r9
                uint32_t periodTime = mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8031c90:	b2ff      	uxtb	r7, r7
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 24 ) & 0xFF;
 8031c92:	b2e4      	uxtb	r4, r4
                TimerStart(&PeriodicTimeStartTimer);
 8031c94:	f009 fb6c 	bl	803b370 <UTIL_TIMER_Start>
                break;
 8031c98:	e7a4      	b.n	8031be4 <LmhpClockSyncOnMcpsIndication+0xc0>
                LmhpClockSyncState.NbTransmissions = mcpsIndication->Buffer[cmdIndex++] & 0X07;
 8031c9a:	3302      	adds	r3, #2
 8031c9c:	b2df      	uxtb	r7, r3
 8031c9e:	5c8b      	ldrb	r3, [r1, r2]
 8031ca0:	f003 0307 	and.w	r3, r3, #7
 8031ca4:	7373      	strb	r3, [r6, #13]
                break;
 8031ca6:	e79d      	b.n	8031be4 <LmhpClockSyncOnMcpsIndication+0xc0>
                LmhpClockSyncState.NbTransmissions = mcpsIndication->Buffer[cmdIndex++] & 0X07;
 8031ca8:	4e04      	ldr	r6, [pc, #16]	; (8031cbc <LmhpClockSyncOnMcpsIndication+0x198>)
                curTime.Seconds -= UNIX_GPS_EPOCH_OFFSET;
 8031caa:	f8df a014 	ldr.w	sl, [pc, #20]	; 8031cc0 <LmhpClockSyncOnMcpsIndication+0x19c>
    uint8_t dataBufferIndex = 0;
 8031cae:	2400      	movs	r4, #0
    uint8_t cmdIndex = 0;
 8031cb0:	4623      	mov	r3, r4
                TimerSetValue(&PeriodicTimeStartTimer, periodTime * 1000);
 8031cb2:	f106 0910 	add.w	r9, r6, #16
 8031cb6:	e796      	b.n	8031be6 <LmhpClockSyncOnMcpsIndication+0xc2>
 8031cb8:	20003490 	.word	0x20003490
 8031cbc:	20004934 	.word	0x20004934
 8031cc0:	ed2ac280 	.word	0xed2ac280

08031cc4 <LmhpClockSyncOnMcpsConfirm>:
{
 8031cc4:	b510      	push	{r4, lr}
    if( LmhpClockSyncState.AppTimeReqPending == true )
 8031cc6:	4c11      	ldr	r4, [pc, #68]	; (8031d0c <LmhpClockSyncOnMcpsConfirm+0x48>)
 8031cc8:	7a63      	ldrb	r3, [r4, #9]
{
 8031cca:	b08a      	sub	sp, #40	; 0x28
    if( LmhpClockSyncState.AppTimeReqPending == true )
 8031ccc:	b1e3      	cbz	r3, 8031d08 <LmhpClockSyncOnMcpsConfirm+0x44>
        mibReq.Type = MIB_ADR;
 8031cce:	2304      	movs	r3, #4
 8031cd0:	f88d 3004 	strb.w	r3, [sp, #4]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8031cd4:	a801      	add	r0, sp, #4
        mibReq.Param.AdrEnable = LmhpClockSyncState.AdrEnabledPrev;
 8031cd6:	7aa3      	ldrb	r3, [r4, #10]
 8031cd8:	f88d 3008 	strb.w	r3, [sp, #8]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8031cdc:	f003 f842 	bl	8034d64 <LoRaMacMibSetRequestConfirm>
        mibReq.Type = MIB_CHANNELS_NB_TRANS;
 8031ce0:	2318      	movs	r3, #24
 8031ce2:	f88d 3004 	strb.w	r3, [sp, #4]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8031ce6:	a801      	add	r0, sp, #4
        mibReq.Param.ChannelsNbTrans = LmhpClockSyncState.NbTransPrev;
 8031ce8:	7ae3      	ldrb	r3, [r4, #11]
 8031cea:	f88d 3008 	strb.w	r3, [sp, #8]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8031cee:	f003 f839 	bl	8034d64 <LoRaMacMibSetRequestConfirm>
        mibReq.Type = MIB_CHANNELS_DATARATE;
 8031cf2:	231f      	movs	r3, #31
 8031cf4:	f88d 3004 	strb.w	r3, [sp, #4]
        LoRaMacMibSetRequestConfirm( &mibReq );        
 8031cf8:	a801      	add	r0, sp, #4
        mibReq.Param.ChannelsDatarate = LmhpClockSyncState.DataratePrev;
 8031cfa:	7b23      	ldrb	r3, [r4, #12]
 8031cfc:	f88d 3008 	strb.w	r3, [sp, #8]
        LoRaMacMibSetRequestConfirm( &mibReq );        
 8031d00:	f003 f830 	bl	8034d64 <LoRaMacMibSetRequestConfirm>
        LmhpClockSyncState.AppTimeReqPending = false;
 8031d04:	2300      	movs	r3, #0
 8031d06:	7263      	strb	r3, [r4, #9]
}
 8031d08:	b00a      	add	sp, #40	; 0x28
 8031d0a:	bd10      	pop	{r4, pc}
 8031d0c:	20004934 	.word	0x20004934

08031d10 <LmhpClockSyncInit>:
{
 8031d10:	b507      	push	{r0, r1, r2, lr}
 8031d12:	480a      	ldr	r0, [pc, #40]	; (8031d3c <LmhpClockSyncInit+0x2c>)
    if( dataBuffer != NULL )
 8031d14:	b179      	cbz	r1, 8031d36 <LmhpClockSyncInit+0x26>
        LmhpClockSyncState.DataBufferMaxSize = dataBufferMaxSize;
 8031d16:	7082      	strb	r2, [r0, #2]
        LmhpClockSyncState.Initialized = true;
 8031d18:	f240 1301 	movw	r3, #257	; 0x101
        TimerInit(&PeriodicTimeStartTimer, OnPeriodicTimeStartTimer);
 8031d1c:	2200      	movs	r2, #0
        LmhpClockSyncState.DataBuffer = dataBuffer;
 8031d1e:	6041      	str	r1, [r0, #4]
        LmhpClockSyncState.Initialized = true;
 8031d20:	f820 3b10 	strh.w	r3, [r0], #16
        TimerInit(&PeriodicTimeStartTimer, OnPeriodicTimeStartTimer);
 8031d24:	f04f 31ff 	mov.w	r1, #4294967295
 8031d28:	4b05      	ldr	r3, [pc, #20]	; (8031d40 <LmhpClockSyncInit+0x30>)
 8031d2a:	9200      	str	r2, [sp, #0]
 8031d2c:	f009 fa72 	bl	803b214 <UTIL_TIMER_Create>
}
 8031d30:	b003      	add	sp, #12
 8031d32:	f85d fb04 	ldr.w	pc, [sp], #4
        LmhpClockSyncState.Initialized = false;
 8031d36:	8001      	strh	r1, [r0, #0]
}
 8031d38:	e7fa      	b.n	8031d30 <LmhpClockSyncInit+0x20>
 8031d3a:	bf00      	nop
 8031d3c:	20004934 	.word	0x20004934
 8031d40:	08031b05 	.word	0x08031b05

08031d44 <LmhpClockSyncPackageFactory>:
}
 8031d44:	4800      	ldr	r0, [pc, #0]	; (8031d48 <LmhpClockSyncPackageFactory+0x4>)
 8031d46:	4770      	bx	lr
 8031d48:	20003490 	.word	0x20003490

08031d4c <LmhpClockSyncAppTimeReq>:
{
 8031d4c:	b570      	push	{r4, r5, r6, lr}
 8031d4e:	b08c      	sub	sp, #48	; 0x30
    if( LmHandlerIsBusy( ) == true )
 8031d50:	f7ff fcb8 	bl	80316c4 <LmHandlerIsBusy>
 8031d54:	2800      	cmp	r0, #0
 8031d56:	d15b      	bne.n	8031e10 <LmhpClockSyncAppTimeReq+0xc4>
    if( LmhpClockSyncState.AppTimeReqPending == false )
 8031d58:	4c2f      	ldr	r4, [pc, #188]	; (8031e18 <LmhpClockSyncAppTimeReq+0xcc>)
 8031d5a:	4e30      	ldr	r6, [pc, #192]	; (8031e1c <LmhpClockSyncAppTimeReq+0xd0>)
 8031d5c:	7a65      	ldrb	r5, [r4, #9]
 8031d5e:	bb3d      	cbnz	r5, 8031db0 <LmhpClockSyncAppTimeReq+0x64>
        mibReq.Type = MIB_ADR;
 8031d60:	2304      	movs	r3, #4
        LoRaMacMibGetRequestConfirm( &mibReq );
 8031d62:	a803      	add	r0, sp, #12
        mibReq.Type = MIB_ADR;
 8031d64:	f88d 300c 	strb.w	r3, [sp, #12]
        LoRaMacMibGetRequestConfirm( &mibReq );
 8031d68:	f002 ff40 	bl	8034bec <LoRaMacMibGetRequestConfirm>
        LmhpClockSyncState.AdrEnabledPrev = mibReq.Param.AdrEnable;
 8031d6c:	f89d 3010 	ldrb.w	r3, [sp, #16]
 8031d70:	72a3      	strb	r3, [r4, #10]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8031d72:	a803      	add	r0, sp, #12
        mibReq.Param.AdrEnable = false;
 8031d74:	f88d 5010 	strb.w	r5, [sp, #16]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8031d78:	f002 fff4 	bl	8034d64 <LoRaMacMibSetRequestConfirm>
        mibReq.Type = MIB_CHANNELS_NB_TRANS;
 8031d7c:	2318      	movs	r3, #24
        LoRaMacMibGetRequestConfirm( &mibReq );
 8031d7e:	a803      	add	r0, sp, #12
        mibReq.Type = MIB_CHANNELS_NB_TRANS;
 8031d80:	f88d 300c 	strb.w	r3, [sp, #12]
        LoRaMacMibGetRequestConfirm( &mibReq );
 8031d84:	f002 ff32 	bl	8034bec <LoRaMacMibGetRequestConfirm>
        LmhpClockSyncState.NbTransPrev = mibReq.Param.ChannelsNbTrans;
 8031d88:	f89d 3010 	ldrb.w	r3, [sp, #16]
 8031d8c:	72e3      	strb	r3, [r4, #11]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8031d8e:	a803      	add	r0, sp, #12
        mibReq.Param.ChannelsNbTrans = 1;
 8031d90:	2301      	movs	r3, #1
 8031d92:	f88d 3010 	strb.w	r3, [sp, #16]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8031d96:	f002 ffe5 	bl	8034d64 <LoRaMacMibSetRequestConfirm>
        mibReq.Type = MIB_CHANNELS_DATARATE;
 8031d9a:	231f      	movs	r3, #31
        LoRaMacMibGetRequestConfirm( &mibReq );  
 8031d9c:	a803      	add	r0, sp, #12
        mibReq.Type = MIB_CHANNELS_DATARATE;
 8031d9e:	f88d 300c 	strb.w	r3, [sp, #12]
        LoRaMacMibGetRequestConfirm( &mibReq );  
 8031da2:	f002 ff23 	bl	8034bec <LoRaMacMibGetRequestConfirm>
        LmhpClockSyncState.DataratePrev = mibReq.Param.ChannelsDatarate;
 8031da6:	f89d 3010 	ldrb.w	r3, [sp, #16]
 8031daa:	7323      	strb	r3, [r4, #12]
        LmhpClockSyncPackage.OnDeviceTimeRequest( );
 8031dac:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8031dae:	4798      	blx	r3
    SysTime_t curTime = SysTimeGet( );
 8031db0:	a801      	add	r0, sp, #4
 8031db2:	f009 f99f 	bl	803b0f4 <SysTimeGet>
    curTime.Seconds -= UNIX_GPS_EPOCH_OFFSET;
 8031db6:	9b01      	ldr	r3, [sp, #4]
 8031db8:	4a19      	ldr	r2, [pc, #100]	; (8031e20 <LmhpClockSyncAppTimeReq+0xd4>)
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = CLOCK_SYNC_APP_TIME_REQ;
 8031dba:	6861      	ldr	r1, [r4, #4]
    curTime.Seconds -= UNIX_GPS_EPOCH_OFFSET;
 8031dbc:	441a      	add	r2, r3
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 8  ) & 0xFF;
 8031dbe:	0a13      	lsrs	r3, r2, #8
 8031dc0:	708b      	strb	r3, [r1, #2]
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 16 ) & 0xFF;
 8031dc2:	0c13      	lsrs	r3, r2, #16
 8031dc4:	70cb      	strb	r3, [r1, #3]
    LmhpClockSyncState.TimeReqParam.Fields.AnsRequired = 0;
 8031dc6:	7a23      	ldrb	r3, [r4, #8]
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 0  ) & 0xFF;
 8031dc8:	704a      	strb	r2, [r1, #1]
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = CLOCK_SYNC_APP_TIME_REQ;
 8031dca:	2501      	movs	r5, #1
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 24 ) & 0xFF;
 8031dcc:	0e12      	lsrs	r2, r2, #24
    LmhpClockSyncState.TimeReqParam.Fields.AnsRequired = 0;
 8031dce:	f36f 1304 	bfc	r3, #4, #1
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 24 ) & 0xFF;
 8031dd2:	710a      	strb	r2, [r1, #4]
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = LmhpClockSyncState.TimeReqParam.Value;
 8031dd4:	714b      	strb	r3, [r1, #5]
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = CLOCK_SYNC_APP_TIME_REQ;
 8031dd6:	700d      	strb	r5, [r1, #0]
    LmhpClockSyncState.TimeReqParam.Fields.AnsRequired = 0;
 8031dd8:	7223      	strb	r3, [r4, #8]
    LmHandlerGetDutyCycleEnable(&current_dutycycle);
 8031dda:	f10d 0003 	add.w	r0, sp, #3
    LmHandlerAppData_t appData =
 8031dde:	f240 63ca 	movw	r3, #1738	; 0x6ca
 8031de2:	f8ad 300c 	strh.w	r3, [sp, #12]
 8031de6:	9104      	str	r1, [sp, #16]
    LmhpClockSyncState.AppTimeReqPending = true;
 8031de8:	7265      	strb	r5, [r4, #9]
    LmHandlerGetDutyCycleEnable(&current_dutycycle);
 8031dea:	f7ff fe67 	bl	8031abc <LmHandlerGetDutyCycleEnable>
    LmHandlerSetDutyCycleEnable(false);
 8031dee:	2000      	movs	r0, #0
 8031df0:	f7ff fe70 	bl	8031ad4 <LmHandlerSetDutyCycleEnable>
    LmHandlerErrorStatus_t status = LmhpClockSyncPackage.OnSendRequest(&appData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true);
 8031df4:	2200      	movs	r2, #0
 8031df6:	6ab4      	ldr	r4, [r6, #40]	; 0x28
 8031df8:	462b      	mov	r3, r5
 8031dfa:	4611      	mov	r1, r2
 8031dfc:	a803      	add	r0, sp, #12
 8031dfe:	47a0      	blx	r4
 8031e00:	4604      	mov	r4, r0
    LmHandlerSetDutyCycleEnable(current_dutycycle);
 8031e02:	f89d 0003 	ldrb.w	r0, [sp, #3]
 8031e06:	f7ff fe65 	bl	8031ad4 <LmHandlerSetDutyCycleEnable>
}
 8031e0a:	4620      	mov	r0, r4
 8031e0c:	b00c      	add	sp, #48	; 0x30
 8031e0e:	bd70      	pop	{r4, r5, r6, pc}
        return LORAMAC_HANDLER_ERROR;
 8031e10:	f04f 34ff 	mov.w	r4, #4294967295
 8031e14:	e7f9      	b.n	8031e0a <LmhpClockSyncAppTimeReq+0xbe>
 8031e16:	bf00      	nop
 8031e18:	20004934 	.word	0x20004934
 8031e1c:	20003490 	.word	0x20003490
 8031e20:	ed2ac280 	.word	0xed2ac280

08031e24 <LmhpClockSyncProcess>:
{
 8031e24:	b510      	push	{r4, lr}
    if( LmhpClockSyncState.NbTransmissions > 0 )
 8031e26:	4c05      	ldr	r4, [pc, #20]	; (8031e3c <LmhpClockSyncProcess+0x18>)
 8031e28:	7b63      	ldrb	r3, [r4, #13]
 8031e2a:	b12b      	cbz	r3, 8031e38 <LmhpClockSyncProcess+0x14>
        if( LmhpClockSyncAppTimeReq( ) == LORAMAC_HANDLER_SUCCESS )
 8031e2c:	f7ff ff8e 	bl	8031d4c <LmhpClockSyncAppTimeReq>
 8031e30:	b910      	cbnz	r0, 8031e38 <LmhpClockSyncProcess+0x14>
            LmhpClockSyncState.NbTransmissions--;
 8031e32:	7b63      	ldrb	r3, [r4, #13]
 8031e34:	3b01      	subs	r3, #1
 8031e36:	7363      	strb	r3, [r4, #13]
}
 8031e38:	bd10      	pop	{r4, pc}
 8031e3a:	bf00      	nop
 8031e3c:	20004934 	.word	0x20004934

08031e40 <LmhpComplianceInit>:
    return &LmhpCompliancePackage;
}

static void LmhpComplianceInit( void *params, uint8_t *dataBuffer, uint8_t dataBufferMaxSize )
{
    if( ( params != NULL ) && ( dataBuffer != NULL ) )
 8031e40:	4b05      	ldr	r3, [pc, #20]	; (8031e58 <LmhpComplianceInit+0x18>)
 8031e42:	b130      	cbz	r0, 8031e52 <LmhpComplianceInit+0x12>
 8031e44:	b129      	cbz	r1, 8031e52 <LmhpComplianceInit+0x12>
    {
        LmhpComplianceParams = ( LmhpComplianceParams_t* )params;
        ComplianceTestState.DataBuffer = dataBuffer;
        ComplianceTestState.DataBufferMaxSize = dataBufferMaxSize;
 8031e46:	725a      	strb	r2, [r3, #9]
        LmhpComplianceParams = ( LmhpComplianceParams_t* )params;
 8031e48:	6018      	str	r0, [r3, #0]
        ComplianceTestState.DataBuffer = dataBuffer;
 8031e4a:	60d9      	str	r1, [r3, #12]
        ComplianceTestState.Initialized = true;
 8031e4c:	2201      	movs	r2, #1
    }
    else
    {
        LmhpComplianceParams = NULL;
        ComplianceTestState.Initialized = false;
 8031e4e:	711a      	strb	r2, [r3, #4]
    }
}
 8031e50:	4770      	bx	lr
        LmhpComplianceParams = NULL;
 8031e52:	2200      	movs	r2, #0
 8031e54:	601a      	str	r2, [r3, #0]
 8031e56:	e7fa      	b.n	8031e4e <LmhpComplianceInit+0xe>
 8031e58:	2000495c 	.word	0x2000495c

08031e5c <LmhpComplianceIsInitialized>:

static bool LmhpComplianceIsInitialized( void )
{
    return ComplianceTestState.Initialized;
}
 8031e5c:	4b01      	ldr	r3, [pc, #4]	; (8031e64 <LmhpComplianceIsInitialized+0x8>)
 8031e5e:	7918      	ldrb	r0, [r3, #4]
 8031e60:	4770      	bx	lr
 8031e62:	bf00      	nop
 8031e64:	2000495c 	.word	0x2000495c

08031e68 <LmhpComplianceIsRunning>:

static bool LmhpComplianceIsRunning( void )
{
    if( ComplianceTestState.Initialized == false )
 8031e68:	4b02      	ldr	r3, [pc, #8]	; (8031e74 <LmhpComplianceIsRunning+0xc>)
 8031e6a:	7918      	ldrb	r0, [r3, #4]
 8031e6c:	b100      	cbz	r0, 8031e70 <LmhpComplianceIsRunning+0x8>
    {
        return false;
    }

    return ComplianceTestState.IsRunning;
 8031e6e:	7958      	ldrb	r0, [r3, #5]
}
 8031e70:	4770      	bx	lr
 8031e72:	bf00      	nop
 8031e74:	2000495c 	.word	0x2000495c

08031e78 <LmhpComplianceProcess>:
}

static void LmhpComplianceProcess( void )
{
    /* Nothing to process */
}
 8031e78:	4770      	bx	lr
	...

08031e7c <LmhpComplianceOnMcpsConfirm>:
    if (ComplianceTestState.Initialized == false)
 8031e7c:	4b06      	ldr	r3, [pc, #24]	; (8031e98 <LmhpComplianceOnMcpsConfirm+0x1c>)
 8031e7e:	791a      	ldrb	r2, [r3, #4]
 8031e80:	b14a      	cbz	r2, 8031e96 <LmhpComplianceOnMcpsConfirm+0x1a>
    if ((ComplianceTestState.IsRunning == true) &&
 8031e82:	795a      	ldrb	r2, [r3, #5]
 8031e84:	b13a      	cbz	r2, 8031e96 <LmhpComplianceOnMcpsConfirm+0x1a>
 8031e86:	7802      	ldrb	r2, [r0, #0]
 8031e88:	2a01      	cmp	r2, #1
 8031e8a:	d104      	bne.n	8031e96 <LmhpComplianceOnMcpsConfirm+0x1a>
        (mcpsConfirm->McpsRequest == MCPS_CONFIRMED) &&
 8031e8c:	7902      	ldrb	r2, [r0, #4]
 8031e8e:	b112      	cbz	r2, 8031e96 <LmhpComplianceOnMcpsConfirm+0x1a>
        ComplianceTestState.DownLinkCounter++;
 8031e90:	8a1a      	ldrh	r2, [r3, #16]
 8031e92:	3201      	adds	r2, #1
 8031e94:	821a      	strh	r2, [r3, #16]
}
 8031e96:	4770      	bx	lr
 8031e98:	2000495c 	.word	0x2000495c

08031e9c <LmhpComplianceOnMlmeConfirm>:
    if( ComplianceTestState.Initialized == false )
 8031e9c:	4b07      	ldr	r3, [pc, #28]	; (8031ebc <LmhpComplianceOnMlmeConfirm+0x20>)
 8031e9e:	791a      	ldrb	r2, [r3, #4]
 8031ea0:	b152      	cbz	r2, 8031eb8 <LmhpComplianceOnMlmeConfirm+0x1c>
    if( ComplianceTestState.IsRunning == false )
 8031ea2:	795a      	ldrb	r2, [r3, #5]
 8031ea4:	b142      	cbz	r2, 8031eb8 <LmhpComplianceOnMlmeConfirm+0x1c>
    if( mlmeConfirm->MlmeRequest == MLME_LINK_CHECK )
 8031ea6:	7802      	ldrb	r2, [r0, #0]
 8031ea8:	2a04      	cmp	r2, #4
 8031eaa:	d105      	bne.n	8031eb8 <LmhpComplianceOnMlmeConfirm+0x1c>
        ComplianceTestState.LinkCheck = true;
 8031eac:	2201      	movs	r2, #1
 8031eae:	749a      	strb	r2, [r3, #18]
        ComplianceTestState.DemodMargin = mlmeConfirm->DemodMargin;
 8031eb0:	7a02      	ldrb	r2, [r0, #8]
 8031eb2:	74da      	strb	r2, [r3, #19]
        ComplianceTestState.NbGateways = mlmeConfirm->NbGateways;
 8031eb4:	7a42      	ldrb	r2, [r0, #9]
 8031eb6:	751a      	strb	r2, [r3, #20]
}
 8031eb8:	4770      	bx	lr
 8031eba:	bf00      	nop
 8031ebc:	2000495c 	.word	0x2000495c

08031ec0 <LmhpComplianceTxProcess>:
{
 8031ec0:	b537      	push	{r0, r1, r2, r4, r5, lr}
    if( ComplianceTestState.Initialized == false )
 8031ec2:	4c1b      	ldr	r4, [pc, #108]	; (8031f30 <LmhpComplianceTxProcess+0x70>)
 8031ec4:	7923      	ldrb	r3, [r4, #4]
 8031ec6:	b383      	cbz	r3, 8031f2a <LmhpComplianceTxProcess+0x6a>
    if( ComplianceTestState.IsRunning == false )
 8031ec8:	7960      	ldrb	r0, [r4, #5]
 8031eca:	b328      	cbz	r0, 8031f18 <LmhpComplianceTxProcess+0x58>
    if( ComplianceTestState.LinkCheck == true )
 8031ecc:	7ca2      	ldrb	r2, [r4, #18]
 8031ece:	68e3      	ldr	r3, [r4, #12]
 8031ed0:	b162      	cbz	r2, 8031eec <LmhpComplianceTxProcess+0x2c>
        ComplianceTestState.LinkCheck = false;
 8031ed2:	2200      	movs	r2, #0
 8031ed4:	74a2      	strb	r2, [r4, #18]
        ComplianceTestState.DataBufferSize = 3;
 8031ed6:	2203      	movs	r2, #3
 8031ed8:	72a2      	strb	r2, [r4, #10]
        ComplianceTestState.DataBuffer[0] = 5;
 8031eda:	2205      	movs	r2, #5
 8031edc:	701a      	strb	r2, [r3, #0]
        ComplianceTestState.DataBuffer[1] = ComplianceTestState.DemodMargin;
 8031ede:	7ce2      	ldrb	r2, [r4, #19]
 8031ee0:	705a      	strb	r2, [r3, #1]
        ComplianceTestState.DataBuffer[2] = ComplianceTestState.NbGateways;
 8031ee2:	7d22      	ldrb	r2, [r4, #20]
 8031ee4:	709a      	strb	r2, [r3, #2]
            ComplianceTestState.State = 1;
 8031ee6:	2201      	movs	r2, #1
 8031ee8:	71a2      	strb	r2, [r4, #6]
            break;
 8031eea:	e004      	b.n	8031ef6 <LmhpComplianceTxProcess+0x36>
        switch( ComplianceTestState.State )
 8031eec:	79a2      	ldrb	r2, [r4, #6]
 8031eee:	2a01      	cmp	r2, #1
 8031ef0:	d014      	beq.n	8031f1c <LmhpComplianceTxProcess+0x5c>
 8031ef2:	2a04      	cmp	r2, #4
 8031ef4:	d0f7      	beq.n	8031ee6 <LmhpComplianceTxProcess+0x26>
    LmHandlerAppData_t appData =
 8031ef6:	22e0      	movs	r2, #224	; 0xe0
 8031ef8:	f88d 2000 	strb.w	r2, [sp]
    TimerStart( &ComplianceTxNextPacketTimer );
 8031efc:	480d      	ldr	r0, [pc, #52]	; (8031f34 <LmhpComplianceTxProcess+0x74>)
    LmHandlerAppData_t appData =
 8031efe:	7aa2      	ldrb	r2, [r4, #10]
 8031f00:	f88d 2001 	strb.w	r2, [sp, #1]
 8031f04:	9301      	str	r3, [sp, #4]
    TimerStart( &ComplianceTxNextPacketTimer );
 8031f06:	f009 fa33 	bl	803b370 <UTIL_TIMER_Start>
    return LmhpCompliancePackage.OnSendRequest( &appData, ( LmHandlerMsgTypes_t )ComplianceTestState.IsTxConfirmed, NULL, true );
 8031f0a:	4b0b      	ldr	r3, [pc, #44]	; (8031f38 <LmhpComplianceTxProcess+0x78>)
 8031f0c:	79e1      	ldrb	r1, [r4, #7]
 8031f0e:	6a9d      	ldr	r5, [r3, #40]	; 0x28
 8031f10:	2200      	movs	r2, #0
 8031f12:	2301      	movs	r3, #1
 8031f14:	4668      	mov	r0, sp
 8031f16:	47a8      	blx	r5
}
 8031f18:	b003      	add	sp, #12
 8031f1a:	bd30      	pop	{r4, r5, pc}
            ComplianceTestState.DataBufferSize = 2;
 8031f1c:	2202      	movs	r2, #2
 8031f1e:	72a2      	strb	r2, [r4, #10]
            ComplianceTestState.DataBuffer[0] = ComplianceTestState.DownLinkCounter >> 8;
 8031f20:	8a22      	ldrh	r2, [r4, #16]
            ComplianceTestState.DataBuffer[1] = ComplianceTestState.DownLinkCounter;
 8031f22:	705a      	strb	r2, [r3, #1]
            ComplianceTestState.DataBuffer[0] = ComplianceTestState.DownLinkCounter >> 8;
 8031f24:	0a11      	lsrs	r1, r2, #8
 8031f26:	7019      	strb	r1, [r3, #0]
            break;
 8031f28:	e7e5      	b.n	8031ef6 <LmhpComplianceTxProcess+0x36>
        return LORAMAC_HANDLER_ERROR;
 8031f2a:	f04f 30ff 	mov.w	r0, #4294967295
 8031f2e:	e7f3      	b.n	8031f18 <LmhpComplianceTxProcess+0x58>
 8031f30:	2000495c 	.word	0x2000495c
 8031f34:	20004974 	.word	0x20004974
 8031f38:	200034c4 	.word	0x200034c4

08031f3c <OnComplianceTxNextPacketTimerEvent>:

static void OnComplianceTxNextPacketTimerEvent( void* context )
{
    LmhpComplianceTxProcess( );
 8031f3c:	f7ff bfc0 	b.w	8031ec0 <LmhpComplianceTxProcess>

08031f40 <LmhpComplianceOnMcpsIndication>:
{
 8031f40:	b530      	push	{r4, r5, lr}
    if( ComplianceTestState.Initialized == false )
 8031f42:	4c77      	ldr	r4, [pc, #476]	; (8032120 <LmhpComplianceOnMcpsIndication+0x1e0>)
 8031f44:	7923      	ldrb	r3, [r4, #4]
{
 8031f46:	b08d      	sub	sp, #52	; 0x34
    if( ComplianceTestState.Initialized == false )
 8031f48:	2b00      	cmp	r3, #0
 8031f4a:	d042      	beq.n	8031fd2 <LmhpComplianceOnMcpsIndication+0x92>
    if( mcpsIndication->RxData == false )
 8031f4c:	7b43      	ldrb	r3, [r0, #13]
 8031f4e:	2b00      	cmp	r3, #0
 8031f50:	d03f      	beq.n	8031fd2 <LmhpComplianceOnMcpsIndication+0x92>
    if ((ComplianceTestState.IsRunning == true) &&
 8031f52:	7965      	ldrb	r5, [r4, #5]
 8031f54:	b125      	cbz	r5, 8031f60 <LmhpComplianceOnMcpsIndication+0x20>
 8031f56:	7b83      	ldrb	r3, [r0, #14]
 8031f58:	b913      	cbnz	r3, 8031f60 <LmhpComplianceOnMcpsIndication+0x20>
        ComplianceTestState.DownLinkCounter++;
 8031f5a:	8a23      	ldrh	r3, [r4, #16]
 8031f5c:	3301      	adds	r3, #1
 8031f5e:	8223      	strh	r3, [r4, #16]
    if( mcpsIndication->Port != COMPLIANCE_PORT )
 8031f60:	78c1      	ldrb	r1, [r0, #3]
 8031f62:	29e0      	cmp	r1, #224	; 0xe0
 8031f64:	d135      	bne.n	8031fd2 <LmhpComplianceOnMcpsIndication+0x92>
    if( ComplianceTestState.IsRunning == false )
 8031f66:	2d00      	cmp	r5, #0
 8031f68:	d135      	bne.n	8031fd6 <LmhpComplianceOnMcpsIndication+0x96>
        if( ( mcpsIndication->BufferSize == 4 ) &&
 8031f6a:	7b02      	ldrb	r2, [r0, #12]
 8031f6c:	2a04      	cmp	r2, #4
 8031f6e:	d130      	bne.n	8031fd2 <LmhpComplianceOnMcpsIndication+0x92>
            ( mcpsIndication->Buffer[0] == 0x01 ) &&
 8031f70:	6883      	ldr	r3, [r0, #8]
        if( ( mcpsIndication->BufferSize == 4 ) &&
 8031f72:	7818      	ldrb	r0, [r3, #0]
 8031f74:	2801      	cmp	r0, #1
 8031f76:	d12c      	bne.n	8031fd2 <LmhpComplianceOnMcpsIndication+0x92>
            ( mcpsIndication->Buffer[0] == 0x01 ) &&
 8031f78:	7858      	ldrb	r0, [r3, #1]
 8031f7a:	2801      	cmp	r0, #1
 8031f7c:	d129      	bne.n	8031fd2 <LmhpComplianceOnMcpsIndication+0x92>
            ( mcpsIndication->Buffer[1] == 0x01 ) &&
 8031f7e:	7898      	ldrb	r0, [r3, #2]
 8031f80:	2801      	cmp	r0, #1
 8031f82:	d126      	bne.n	8031fd2 <LmhpComplianceOnMcpsIndication+0x92>
            ( mcpsIndication->Buffer[2] == 0x01 ) &&
 8031f84:	78db      	ldrb	r3, [r3, #3]
 8031f86:	2b01      	cmp	r3, #1
 8031f88:	d123      	bne.n	8031fd2 <LmhpComplianceOnMcpsIndication+0x92>
            ComplianceTestState.DataBufferSize = 2;
 8031f8a:	2002      	movs	r0, #2
 8031f8c:	72a0      	strb	r0, [r4, #10]
            LoRaMacMibSetRequestConfirm( &mibReq );
 8031f8e:	a803      	add	r0, sp, #12
            ComplianceTestState.IsRunning = true;
 8031f90:	7163      	strb	r3, [r4, #5]
            ComplianceTestState.State = 1;
 8031f92:	80e3      	strh	r3, [r4, #6]
            mibReq.Param.AdrEnable = true;
 8031f94:	f88d 3010 	strb.w	r3, [sp, #16]
            ComplianceTestState.Port = 224;
 8031f98:	7221      	strb	r1, [r4, #8]
            mibReq.Type = MIB_ADR;
 8031f9a:	f88d 200c 	strb.w	r2, [sp, #12]
            ComplianceTestState.DownLinkCounter = 0;
 8031f9e:	6125      	str	r5, [r4, #16]
            ComplianceTestState.NbGateways = 0;
 8031fa0:	7525      	strb	r5, [r4, #20]
            LoRaMacMibSetRequestConfirm( &mibReq );
 8031fa2:	f002 fedf 	bl	8034d64 <LoRaMacMibSetRequestConfirm>
            LoRaMacTestSetDutyCycleOn( false );
 8031fa6:	4628      	mov	r0, r5
 8031fa8:	f003 fc40 	bl	803582c <LoRaMacTestSetDutyCycleOn>
            if( LmhpComplianceParams->StopPeripherals != NULL )
 8031fac:	6823      	ldr	r3, [r4, #0]
 8031fae:	685b      	ldr	r3, [r3, #4]
 8031fb0:	b103      	cbz	r3, 8031fb4 <LmhpComplianceOnMcpsIndication+0x74>
                LmhpComplianceParams->StopPeripherals( );
 8031fb2:	4798      	blx	r3
            TimerInit( &ComplianceTxNextPacketTimer, OnComplianceTxNextPacketTimerEvent );
 8031fb4:	2200      	movs	r2, #0
 8031fb6:	4b5b      	ldr	r3, [pc, #364]	; (8032124 <LmhpComplianceOnMcpsIndication+0x1e4>)
 8031fb8:	9200      	str	r2, [sp, #0]
 8031fba:	f04f 31ff 	mov.w	r1, #4294967295
 8031fbe:	485a      	ldr	r0, [pc, #360]	; (8032128 <LmhpComplianceOnMcpsIndication+0x1e8>)
 8031fc0:	f009 f928 	bl	803b214 <UTIL_TIMER_Create>
            TimerSetValue( &ComplianceTxNextPacketTimer, COMPLIANCE_TX_DUTYCYCLE );
 8031fc4:	f241 3188 	movw	r1, #5000	; 0x1388
 8031fc8:	4857      	ldr	r0, [pc, #348]	; (8032128 <LmhpComplianceOnMcpsIndication+0x1e8>)
 8031fca:	f009 fa0b 	bl	803b3e4 <UTIL_TIMER_SetPeriod>
            LmhpComplianceTxProcess( );
 8031fce:	f7ff ff77 	bl	8031ec0 <LmhpComplianceTxProcess>
}
 8031fd2:	b00d      	add	sp, #52	; 0x34
 8031fd4:	bd30      	pop	{r4, r5, pc}
        ComplianceTestState.State = mcpsIndication->Buffer[0];
 8031fd6:	6883      	ldr	r3, [r0, #8]
 8031fd8:	781a      	ldrb	r2, [r3, #0]
 8031fda:	71a2      	strb	r2, [r4, #6]
        switch( ComplianceTestState.State )
 8031fdc:	2a0a      	cmp	r2, #10
 8031fde:	d8f8      	bhi.n	8031fd2 <LmhpComplianceOnMcpsIndication+0x92>
 8031fe0:	e8df f002 	tbb	[pc, r2]
 8031fe4:	27232006 	.word	0x27232006
 8031fe8:	60433c29 	.word	0x60433c29
 8031fec:	8d8b      	.short	0x8d8b
 8031fee:	97          	.byte	0x97
 8031fef:	00          	.byte	0x00
                TimerStop( &ComplianceTxNextPacketTimer );
 8031ff0:	484d      	ldr	r0, [pc, #308]	; (8032128 <LmhpComplianceOnMcpsIndication+0x1e8>)
 8031ff2:	f009 f96d 	bl	803b2d0 <UTIL_TIMER_Stop>
                ComplianceTestState.DownLinkCounter = 0;
 8031ff6:	2300      	movs	r3, #0
 8031ff8:	8223      	strh	r3, [r4, #16]
                ComplianceTestState.IsRunning = false;
 8031ffa:	7163      	strb	r3, [r4, #5]
                mibReq.Type = MIB_ADR;
 8031ffc:	2304      	movs	r3, #4
 8031ffe:	f88d 300c 	strb.w	r3, [sp, #12]
                mibReq.Param.AdrEnable = LmhpComplianceParams->AdrEnabled;
 8032002:	6823      	ldr	r3, [r4, #0]
                LoRaMacMibSetRequestConfirm( &mibReq );
 8032004:	a803      	add	r0, sp, #12
                mibReq.Param.AdrEnable = LmhpComplianceParams->AdrEnabled;
 8032006:	781b      	ldrb	r3, [r3, #0]
 8032008:	f88d 3010 	strb.w	r3, [sp, #16]
                LoRaMacMibSetRequestConfirm( &mibReq );
 803200c:	f002 feaa 	bl	8034d64 <LoRaMacMibSetRequestConfirm>
                LoRaMacTestSetDutyCycleOn( LmhpComplianceParams->DutyCycleEnabled );
 8032010:	6823      	ldr	r3, [r4, #0]
 8032012:	7858      	ldrb	r0, [r3, #1]
 8032014:	f003 fc0a 	bl	803582c <LoRaMacTestSetDutyCycleOn>
                if( LmhpComplianceParams->StartPeripherals != NULL )
 8032018:	6823      	ldr	r3, [r4, #0]
 803201a:	689b      	ldr	r3, [r3, #8]
 803201c:	2b00      	cmp	r3, #0
 803201e:	d0d8      	beq.n	8031fd2 <LmhpComplianceOnMcpsIndication+0x92>
                    LmhpComplianceParams->StartPeripherals( );
 8032020:	4798      	blx	r3
            break;
 8032022:	e7d6      	b.n	8031fd2 <LmhpComplianceOnMcpsIndication+0x92>
            ComplianceTestState.DataBufferSize = 2;
 8032024:	2302      	movs	r3, #2
 8032026:	72a3      	strb	r3, [r4, #10]
            break;
 8032028:	e7d3      	b.n	8031fd2 <LmhpComplianceOnMcpsIndication+0x92>
            ComplianceTestState.State = 1;
 803202a:	f240 1301 	movw	r3, #257	; 0x101
            ComplianceTestState.State = 1;
 803202e:	80e3      	strh	r3, [r4, #6]
            break;
 8032030:	e7cf      	b.n	8031fd2 <LmhpComplianceOnMcpsIndication+0x92>
            ComplianceTestState.State = 1;
 8032032:	2301      	movs	r3, #1
 8032034:	e7fb      	b.n	803202e <LmhpComplianceOnMcpsIndication+0xee>
            ComplianceTestState.DataBuffer[0] = 4;
 8032036:	68e5      	ldr	r5, [r4, #12]
            ComplianceTestState.DataBufferSize = mcpsIndication->BufferSize;
 8032038:	7b03      	ldrb	r3, [r0, #12]
 803203a:	72a3      	strb	r3, [r4, #10]
            ComplianceTestState.DataBuffer[0] = 4;
 803203c:	2204      	movs	r2, #4
 803203e:	702a      	strb	r2, [r5, #0]
            for( uint8_t i = 1; i < MIN( ComplianceTestState.DataBufferSize, ComplianceTestState.DataBufferMaxSize ); i++ )
 8032040:	7a62      	ldrb	r2, [r4, #9]
 8032042:	429a      	cmp	r2, r3
 8032044:	bf28      	it	cs
 8032046:	461a      	movcs	r2, r3
 8032048:	2300      	movs	r3, #0
 803204a:	3301      	adds	r3, #1
 803204c:	b2d9      	uxtb	r1, r3
 803204e:	428a      	cmp	r2, r1
 8032050:	d9bf      	bls.n	8031fd2 <LmhpComplianceOnMcpsIndication+0x92>
                ComplianceTestState.DataBuffer[i] = mcpsIndication->Buffer[i] + 1;
 8032052:	6881      	ldr	r1, [r0, #8]
 8032054:	5cc9      	ldrb	r1, [r1, r3]
 8032056:	3101      	adds	r1, #1
 8032058:	54e9      	strb	r1, [r5, r3]
            for( uint8_t i = 1; i < MIN( ComplianceTestState.DataBufferSize, ComplianceTestState.DataBufferMaxSize ); i++ )
 803205a:	e7f6      	b.n	803204a <LmhpComplianceOnMcpsIndication+0x10a>
                mlmeReq.Type = MLME_LINK_CHECK;
 803205c:	2304      	movs	r3, #4
                mlmeReq.Type = MLME_DEVICE_TIME;
 803205e:	f88d 300c 	strb.w	r3, [sp, #12]
                LoRaMacMlmeRequest( &mlmeReq );
 8032062:	a803      	add	r0, sp, #12
 8032064:	f003 f96a 	bl	803533c <LoRaMacMlmeRequest>
            break;
 8032068:	e7b3      	b.n	8031fd2 <LmhpComplianceOnMcpsIndication+0x92>
                TimerStop(&ComplianceTxNextPacketTimer);
 803206a:	482f      	ldr	r0, [pc, #188]	; (8032128 <LmhpComplianceOnMcpsIndication+0x1e8>)
 803206c:	f009 f930 	bl	803b2d0 <UTIL_TIMER_Stop>
                ComplianceTestState.DownLinkCounter = 0;
 8032070:	2300      	movs	r3, #0
 8032072:	8223      	strh	r3, [r4, #16]
                ComplianceTestState.IsRunning = false;
 8032074:	7163      	strb	r3, [r4, #5]
                mibReq.Type = MIB_ADR;
 8032076:	2304      	movs	r3, #4
 8032078:	f88d 300c 	strb.w	r3, [sp, #12]
                mibReq.Param.AdrEnable = LmhpComplianceParams->AdrEnabled;
 803207c:	6823      	ldr	r3, [r4, #0]
                LoRaMacMibSetRequestConfirm( &mibReq );
 803207e:	a803      	add	r0, sp, #12
                mibReq.Param.AdrEnable = LmhpComplianceParams->AdrEnabled;
 8032080:	781b      	ldrb	r3, [r3, #0]
 8032082:	f88d 3010 	strb.w	r3, [sp, #16]
                LoRaMacMibSetRequestConfirm( &mibReq );
 8032086:	f002 fe6d 	bl	8034d64 <LoRaMacMibSetRequestConfirm>
                LoRaMacTestSetDutyCycleOn( LmhpComplianceParams->DutyCycleEnabled );
 803208a:	6823      	ldr	r3, [r4, #0]
 803208c:	7858      	ldrb	r0, [r3, #1]
 803208e:	f003 fbcd 	bl	803582c <LoRaMacTestSetDutyCycleOn>
                if( LmhpComplianceParams->StartPeripherals != NULL )
 8032092:	6823      	ldr	r3, [r4, #0]
 8032094:	689b      	ldr	r3, [r3, #8]
 8032096:	b103      	cbz	r3, 803209a <LmhpComplianceOnMcpsIndication+0x15a>
                    LmhpComplianceParams->StartPeripherals( );
 8032098:	4798      	blx	r3
                LmhpCompliancePackage.OnJoinRequest( ACTIVATION_TYPE_OTAA );
 803209a:	4b24      	ldr	r3, [pc, #144]	; (803212c <LmhpComplianceOnMcpsIndication+0x1ec>)
 803209c:	2002      	movs	r0, #2
 803209e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80320a0:	4798      	blx	r3
            break;
 80320a2:	e796      	b.n	8031fd2 <LmhpComplianceOnMcpsIndication+0x92>
                if( mcpsIndication->BufferSize == 3 )
 80320a4:	7b02      	ldrb	r2, [r0, #12]
 80320a6:	2a03      	cmp	r2, #3
 80320a8:	d10e      	bne.n	80320c8 <LmhpComplianceOnMcpsIndication+0x188>
                    mlmeReq.Type = MLME_TXCW;
 80320aa:	2205      	movs	r2, #5
 80320ac:	f88d 200c 	strb.w	r2, [sp, #12]
                    mlmeReq.Req.TxCw.Timeout = ( uint16_t )( ( mcpsIndication->Buffer[1] << 8 ) | mcpsIndication->Buffer[2] );
 80320b0:	785a      	ldrb	r2, [r3, #1]
 80320b2:	789b      	ldrb	r3, [r3, #2]
 80320b4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80320b8:	f8ad 3010 	strh.w	r3, [sp, #16]
                LoRaMacMlmeRequest( &mlmeReq );
 80320bc:	a803      	add	r0, sp, #12
 80320be:	f003 f93d 	bl	803533c <LoRaMacMlmeRequest>
                ComplianceTestState.State = 1;
 80320c2:	2301      	movs	r3, #1
 80320c4:	71a3      	strb	r3, [r4, #6]
            break;
 80320c6:	e784      	b.n	8031fd2 <LmhpComplianceOnMcpsIndication+0x92>
                else if( mcpsIndication->BufferSize == 7 )
 80320c8:	2a07      	cmp	r2, #7
 80320ca:	d1f7      	bne.n	80320bc <LmhpComplianceOnMcpsIndication+0x17c>
                    mlmeReq.Type = MLME_TXCW_1;
 80320cc:	2206      	movs	r2, #6
 80320ce:	f88d 200c 	strb.w	r2, [sp, #12]
                    mlmeReq.Req.TxCw.Timeout = ( uint16_t )( ( mcpsIndication->Buffer[1] << 8 ) | mcpsIndication->Buffer[2] );
 80320d2:	7859      	ldrb	r1, [r3, #1]
 80320d4:	789a      	ldrb	r2, [r3, #2]
 80320d6:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 80320da:	f8ad 2010 	strh.w	r2, [sp, #16]
                    mlmeReq.Req.TxCw.Frequency = ( uint32_t )( ( mcpsIndication->Buffer[3] << 16 ) | ( mcpsIndication->Buffer[4] << 8 ) | mcpsIndication->Buffer[5] ) * 100;
 80320de:	791a      	ldrb	r2, [r3, #4]
 80320e0:	78d9      	ldrb	r1, [r3, #3]
 80320e2:	0212      	lsls	r2, r2, #8
 80320e4:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 80320e8:	7959      	ldrb	r1, [r3, #5]
 80320ea:	430a      	orrs	r2, r1
 80320ec:	2164      	movs	r1, #100	; 0x64
 80320ee:	434a      	muls	r2, r1
 80320f0:	9205      	str	r2, [sp, #20]
                    mlmeReq.Req.TxCw.Power = mcpsIndication->Buffer[6];
 80320f2:	799b      	ldrb	r3, [r3, #6]
 80320f4:	f88d 3018 	strb.w	r3, [sp, #24]
 80320f8:	e7e0      	b.n	80320bc <LmhpComplianceOnMcpsIndication+0x17c>
                mlmeReq.Type = MLME_DEVICE_TIME;
 80320fa:	230a      	movs	r3, #10
 80320fc:	e7af      	b.n	803205e <LmhpComplianceOnMcpsIndication+0x11e>
                mibReq.Type = MIB_DEVICE_CLASS;
 80320fe:	2200      	movs	r2, #0
 8032100:	f88d 200c 	strb.w	r2, [sp, #12]
                mibReq.Param.Class = ( DeviceClass_t )mcpsIndication->Buffer[1];;
 8032104:	785b      	ldrb	r3, [r3, #1]
 8032106:	f88d 3010 	strb.w	r3, [sp, #16]
                LoRaMacMibSetRequestConfirm( &mibReq );
 803210a:	a803      	add	r0, sp, #12
 803210c:	f002 fe2a 	bl	8034d64 <LoRaMacMibSetRequestConfirm>
            break;
 8032110:	e75f      	b.n	8031fd2 <LmhpComplianceOnMcpsIndication+0x92>
                mlmeReq.Type = MLME_PING_SLOT_INFO;
 8032112:	220d      	movs	r2, #13
 8032114:	f88d 200c 	strb.w	r2, [sp, #12]
                mlmeReq.Req.PingSlotInfo.PingSlot.Value = mcpsIndication->Buffer[1];
 8032118:	785b      	ldrb	r3, [r3, #1]
 803211a:	f88d 3010 	strb.w	r3, [sp, #16]
 803211e:	e7a0      	b.n	8032062 <LmhpComplianceOnMcpsIndication+0x122>
 8032120:	2000495c 	.word	0x2000495c
 8032124:	08031f3d 	.word	0x08031f3d
 8032128:	20004974 	.word	0x20004974
 803212c:	200034c4 	.word	0x200034c4

08032130 <LmhpCompliancePackageFactory>:
}
 8032130:	4800      	ldr	r0, [pc, #0]	; (8032134 <LmhpCompliancePackageFactory+0x4>)
 8032132:	4770      	bx	lr
 8032134:	200034c4 	.word	0x200034c4

08032138 <__NVIC_SystemReset>:
  __ASM volatile ("dsb 0xF":::"memory");
 8032138:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 803213c:	4905      	ldr	r1, [pc, #20]	; (8032154 <__NVIC_SystemReset+0x1c>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 803213e:	4b06      	ldr	r3, [pc, #24]	; (8032158 <__NVIC_SystemReset+0x20>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8032140:	68ca      	ldr	r2, [r1, #12]
 8032142:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8032146:	4313      	orrs	r3, r2
 8032148:	60cb      	str	r3, [r1, #12]
 803214a:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 803214e:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 8032150:	e7fd      	b.n	803214e <__NVIC_SystemReset+0x16>
 8032152:	bf00      	nop
 8032154:	e000ed00 	.word	0xe000ed00
 8032158:	05fa0004 	.word	0x05fa0004

0803215c <LmhpFirmwareManagementIsInitialized>:
}

static bool LmhpFirmwareManagementIsInitialized(void)
{
  return LmhpFirmwareManagementState.Initialized;
}
 803215c:	4b01      	ldr	r3, [pc, #4]	; (8032164 <LmhpFirmwareManagementIsInitialized+0x8>)
 803215e:	7818      	ldrb	r0, [r3, #0]
 8032160:	4770      	bx	lr
 8032162:	bf00      	nop
 8032164:	2000498c 	.word	0x2000498c

08032168 <LmhpFirmwareManagementIsRunning>:

static bool LmhpFirmwareManagementIsRunning(void)
{
  if (LmhpFirmwareManagementState.Initialized == false)
 8032168:	4b02      	ldr	r3, [pc, #8]	; (8032174 <LmhpFirmwareManagementIsRunning+0xc>)
 803216a:	7818      	ldrb	r0, [r3, #0]
 803216c:	b100      	cbz	r0, 8032170 <LmhpFirmwareManagementIsRunning+0x8>
  {
    return false;
  }

  return LmhpFirmwareManagementState.IsRunning;
 803216e:	7858      	ldrb	r0, [r3, #1]
}
 8032170:	4770      	bx	lr
 8032172:	bf00      	nop
 8032174:	2000498c 	.word	0x2000498c

08032178 <LmhpFirmwareManagementProcess>:

static void LmhpFirmwareManagementProcess(void)
{
  /* Not yet implemented */
}
 8032178:	4770      	bx	lr

0803217a <OnRebootTimer>:
    LmHandlerSetDutyCycleEnable(current_dutycycle);
  }
}

static void OnRebootTimer(void *context)
{
 803217a:	b508      	push	{r3, lr}
  NVIC_SystemReset();
 803217c:	f7ff ffdc 	bl	8032138 <__NVIC_SystemReset>

08032180 <LmhpFirmwareManagementOnMcpsIndication>:
{
 8032180:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_DELETE_IMAGE_ANS;
 8032184:	f8df a1d4 	ldr.w	sl, [pc, #468]	; 803235c <LmhpFirmwareManagementOnMcpsIndication+0x1dc>
  uint8_t dataBufferIndex = 0;
 8032188:	2400      	movs	r4, #0
{
 803218a:	4680      	mov	r8, r0
  uint8_t cmdIndex = 0;
 803218c:	4623      	mov	r3, r4
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_DELETE_IMAGE_ANS;
 803218e:	f04f 0905 	mov.w	r9, #5
            TimerSetValue(&RebootTimer, rebootCountdown * 1000);
 8032192:	f10a 0708 	add.w	r7, sl, #8
  while (cmdIndex < mcpsIndication->BufferSize)
 8032196:	f898 200c 	ldrb.w	r2, [r8, #12]
 803219a:	429a      	cmp	r2, r3
 803219c:	d81d      	bhi.n	80321da <LmhpFirmwareManagementOnMcpsIndication+0x5a>
  if (dataBufferIndex != 0)
 803219e:	b1cc      	cbz	r4, 80321d4 <LmhpFirmwareManagementOnMcpsIndication+0x54>
    LmHandlerAppData_t appData =
 80321a0:	23cb      	movs	r3, #203	; 0xcb
 80321a2:	f88d 3008 	strb.w	r3, [sp, #8]
      .Buffer = LmhpFirmwareManagementState.DataBuffer,
 80321a6:	4b6d      	ldr	r3, [pc, #436]	; (803235c <LmhpFirmwareManagementOnMcpsIndication+0x1dc>)
    LmHandlerAppData_t appData =
 80321a8:	f88d 4009 	strb.w	r4, [sp, #9]
 80321ac:	685b      	ldr	r3, [r3, #4]
 80321ae:	9303      	str	r3, [sp, #12]
    LmHandlerGetDutyCycleEnable(&current_dutycycle);
 80321b0:	f10d 0007 	add.w	r0, sp, #7
 80321b4:	f7ff fc82 	bl	8031abc <LmHandlerGetDutyCycleEnable>
    LmHandlerSetDutyCycleEnable(false);
 80321b8:	2000      	movs	r0, #0
 80321ba:	f7ff fc8b 	bl	8031ad4 <LmHandlerSetDutyCycleEnable>
    LmhpFirmwareManagementPackage.OnSendRequest(&appData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true);
 80321be:	4b68      	ldr	r3, [pc, #416]	; (8032360 <LmhpFirmwareManagementOnMcpsIndication+0x1e0>)
 80321c0:	2200      	movs	r2, #0
 80321c2:	6a9c      	ldr	r4, [r3, #40]	; 0x28
 80321c4:	4611      	mov	r1, r2
 80321c6:	2301      	movs	r3, #1
 80321c8:	a802      	add	r0, sp, #8
 80321ca:	47a0      	blx	r4
    LmHandlerSetDutyCycleEnable(current_dutycycle);
 80321cc:	f89d 0007 	ldrb.w	r0, [sp, #7]
 80321d0:	f7ff fc80 	bl	8031ad4 <LmHandlerSetDutyCycleEnable>
}
 80321d4:	b004      	add	sp, #16
 80321d6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    switch (mcpsIndication->Buffer[cmdIndex++])
 80321da:	f8d8 2008 	ldr.w	r2, [r8, #8]
 80321de:	5cd1      	ldrb	r1, [r2, r3]
 80321e0:	1c5e      	adds	r6, r3, #1
 80321e2:	b2f6      	uxtb	r6, r6
 80321e4:	2905      	cmp	r1, #5
 80321e6:	d832      	bhi.n	803224e <LmhpFirmwareManagementOnMcpsIndication+0xce>
 80321e8:	e8df f001 	tbb	[pc, r1]
 80321ec:	73331103 	.word	0x73331103
 80321f0:	aea3      	.short	0xaea3
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_PKG_VERSION_ANS;
 80321f2:	1c61      	adds	r1, r4, #1
 80321f4:	f8da 2004 	ldr.w	r2, [sl, #4]
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_ID;
 80321f8:	b2c9      	uxtb	r1, r1
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_PKG_VERSION_ANS;
 80321fa:	2300      	movs	r3, #0
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_ID;
 80321fc:	2004      	movs	r0, #4
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_PKG_VERSION_ANS;
 80321fe:	5513      	strb	r3, [r2, r4]
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_ID;
 8032200:	1ca3      	adds	r3, r4, #2
 8032202:	5450      	strb	r0, [r2, r1]
 8032204:	b2db      	uxtb	r3, r3
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_VERSION;
 8032206:	3403      	adds	r4, #3
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = 0x01;
 8032208:	b2e4      	uxtb	r4, r4
 803220a:	2101      	movs	r1, #1
 803220c:	e09a      	b.n	8032344 <LmhpFirmwareManagementOnMcpsIndication+0x1c4>
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_VERSION_ANS;
 803220e:	2201      	movs	r2, #1
 8032210:	f8da 3004 	ldr.w	r3, [sl, #4]
 8032214:	18a1      	adds	r1, r4, r2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (FW_VERSION >> 0) & 0xFF;
 8032216:	b2c9      	uxtb	r1, r1
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_VERSION_ANS;
 8032218:	551a      	strb	r2, [r3, r4]
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (FW_VERSION >> 0) & 0xFF;
 803221a:	2200      	movs	r2, #0
 803221c:	545a      	strb	r2, [r3, r1]
 803221e:	1ca1      	adds	r1, r4, #2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (FW_VERSION >> 8) & 0xFF;
 8032220:	b2c9      	uxtb	r1, r1
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (HW_VERSION >> 8) & 0xFF;
 8032222:	1de0      	adds	r0, r4, #7
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (FW_VERSION >> 8) & 0xFF;
 8032224:	545a      	strb	r2, [r3, r1]
 8032226:	1ce1      	adds	r1, r4, #3
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (FW_VERSION >> 16) & 0xFF;
 8032228:	b2c9      	uxtb	r1, r1
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (HW_VERSION >> 16) & 0xFF;
 803222a:	b2c0      	uxtb	r0, r0
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (FW_VERSION >> 16) & 0xFF;
 803222c:	545a      	strb	r2, [r3, r1]
 803222e:	1d21      	adds	r1, r4, #4
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (FW_VERSION >> 24) & 0xFF;
 8032230:	b2c9      	uxtb	r1, r1
 8032232:	545a      	strb	r2, [r3, r1]
 8032234:	1d61      	adds	r1, r4, #5
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (HW_VERSION >> 0) & 0xFF;
 8032236:	b2c9      	uxtb	r1, r1
 8032238:	545a      	strb	r2, [r3, r1]
 803223a:	1da1      	adds	r1, r4, #6
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (HW_VERSION >> 8) & 0xFF;
 803223c:	b2c9      	uxtb	r1, r1
 803223e:	545a      	strb	r2, [r3, r1]
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (HW_VERSION >> 16) & 0xFF;
 8032240:	f104 0108 	add.w	r1, r4, #8
 8032244:	b2c9      	uxtb	r1, r1
 8032246:	541a      	strb	r2, [r3, r0]
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (HW_VERSION >> 24) & 0xFF;
 8032248:	3409      	adds	r4, #9
 803224a:	545a      	strb	r2, [r3, r1]
 803224c:	b2e4      	uxtb	r4, r4
{
 803224e:	4633      	mov	r3, r6
 8032250:	e7a1      	b.n	8032196 <LmhpFirmwareManagementOnMcpsIndication+0x16>
        rebootTimeReq  = (mcpsIndication->Buffer[cmdIndex++] << 0) & 0x000000FF;
 8032252:	1c99      	adds	r1, r3, #2
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 8) & 0x0000FF00;
 8032254:	b2c9      	uxtb	r1, r1
        rebootTimeReq  = (mcpsIndication->Buffer[cmdIndex++] << 0) & 0x000000FF;
 8032256:	5d90      	ldrb	r0, [r2, r6]
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 8) & 0x0000FF00;
 8032258:	5c56      	ldrb	r6, [r2, r1]
 803225a:	1cd9      	adds	r1, r3, #3
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 16) & 0x00FF0000;
 803225c:	b2c9      	uxtb	r1, r1
 803225e:	5c55      	ldrb	r5, [r2, r1]
 8032260:	042d      	lsls	r5, r5, #16
 8032262:	eb05 2506 	add.w	r5, r5, r6, lsl #8
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 24) & 0xFF000000;
 8032266:	1d5e      	adds	r6, r3, #5
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 16) & 0x00FF0000;
 8032268:	3304      	adds	r3, #4
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 24) & 0xFF000000;
 803226a:	b2db      	uxtb	r3, r3
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 16) & 0x00FF0000;
 803226c:	4405      	add	r5, r0
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 24) & 0xFF000000;
 803226e:	5cd3      	ldrb	r3, [r2, r3]
        if (rebootTimeReq == 0)
 8032270:	eb15 6503 	adds.w	r5, r5, r3, lsl #24
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 24) & 0xFF000000;
 8032274:	b2f6      	uxtb	r6, r6
        if (rebootTimeReq == 0)
 8032276:	d101      	bne.n	803227c <LmhpFirmwareManagementOnMcpsIndication+0xfc>
          NVIC_SystemReset();
 8032278:	f7ff ff5e 	bl	8032138 <__NVIC_SystemReset>
        else if (rebootTimeReq == 0xFFFFFFFF)
 803227c:	1c6b      	adds	r3, r5, #1
 803227e:	d118      	bne.n	80322b2 <LmhpFirmwareManagementOnMcpsIndication+0x132>
          TimerStop(&RebootTimer);
 8032280:	4638      	mov	r0, r7
 8032282:	f009 f825 	bl	803b2d0 <UTIL_TIMER_Stop>
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_REBOOT_TIME_ANS;
 8032286:	f8da 3004 	ldr.w	r3, [sl, #4]
 803228a:	2202      	movs	r2, #2
 803228c:	551a      	strb	r2, [r3, r4]
 803228e:	1c62      	adds	r2, r4, #1
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 0) & 0xFF;
 8032290:	b2d2      	uxtb	r2, r2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 8) & 0xFF;
 8032292:	0a29      	lsrs	r1, r5, #8
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 0) & 0xFF;
 8032294:	549d      	strb	r5, [r3, r2]
 8032296:	1ca2      	adds	r2, r4, #2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 8) & 0xFF;
 8032298:	b2d2      	uxtb	r2, r2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 16) & 0xFF;
 803229a:	0c28      	lsrs	r0, r5, #16
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 8) & 0xFF;
 803229c:	5499      	strb	r1, [r3, r2]
 803229e:	1ce1      	adds	r1, r4, #3
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 16) & 0xFF;
 80322a0:	b2c9      	uxtb	r1, r1
 80322a2:	1d22      	adds	r2, r4, #4
 80322a4:	5458      	strb	r0, [r3, r1]
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 24) & 0xFF;
 80322a6:	3405      	adds	r4, #5
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 16) & 0xFF;
 80322a8:	b2d2      	uxtb	r2, r2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 24) & 0xFF;
 80322aa:	b2e4      	uxtb	r4, r4
 80322ac:	0e2d      	lsrs	r5, r5, #24
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootCountdown >> 16) & 0xFF;
 80322ae:	549d      	strb	r5, [r3, r2]
        break;
 80322b0:	e7cd      	b.n	803224e <LmhpFirmwareManagementOnMcpsIndication+0xce>
          curTime = SysTimeGet();
 80322b2:	a802      	add	r0, sp, #8
 80322b4:	f008 ff1e 	bl	803b0f4 <SysTimeGet>
          rebootTimeAns = rebootTimeReq - curTime.Seconds;
 80322b8:	9b02      	ldr	r3, [sp, #8]
          if (rebootTimeAns > 0)
 80322ba:	1aed      	subs	r5, r5, r3
 80322bc:	d0e3      	beq.n	8032286 <LmhpFirmwareManagementOnMcpsIndication+0x106>
            TimerSetValue(&RebootTimer, rebootTimeAns * 1000);
 80322be:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 80322c2:	4369      	muls	r1, r5
 80322c4:	4638      	mov	r0, r7
 80322c6:	f009 f88d 	bl	803b3e4 <UTIL_TIMER_SetPeriod>
            TimerStart(&RebootTimer);
 80322ca:	4638      	mov	r0, r7
 80322cc:	f009 f850 	bl	803b370 <UTIL_TIMER_Start>
 80322d0:	e7d9      	b.n	8032286 <LmhpFirmwareManagementOnMcpsIndication+0x106>
        rebootCountdown  = (mcpsIndication->Buffer[cmdIndex++] << 0) & 0x000000FF;
 80322d2:	5d91      	ldrb	r1, [r2, r6]
 80322d4:	1c98      	adds	r0, r3, #2
        rebootCountdown += (mcpsIndication->Buffer[cmdIndex++] << 16) & 0x00FF0000;
 80322d6:	1d1e      	adds	r6, r3, #4
        rebootCountdown += (mcpsIndication->Buffer[cmdIndex++] << 8) & 0x0000FF00;
 80322d8:	3303      	adds	r3, #3
        rebootCountdown += (mcpsIndication->Buffer[cmdIndex++] << 16) & 0x00FF0000;
 80322da:	b2db      	uxtb	r3, r3
        rebootCountdown += (mcpsIndication->Buffer[cmdIndex++] << 8) & 0x0000FF00;
 80322dc:	b2c0      	uxtb	r0, r0
        rebootCountdown += (mcpsIndication->Buffer[cmdIndex++] << 16) & 0x00FF0000;
 80322de:	5cd5      	ldrb	r5, [r2, r3]
        rebootCountdown += (mcpsIndication->Buffer[cmdIndex++] << 8) & 0x0000FF00;
 80322e0:	5c10      	ldrb	r0, [r2, r0]
        rebootCountdown += (mcpsIndication->Buffer[cmdIndex++] << 16) & 0x00FF0000;
 80322e2:	042d      	lsls	r5, r5, #16
 80322e4:	eb05 2500 	add.w	r5, r5, r0, lsl #8
        if (rebootCountdown == 0)
 80322e8:	186d      	adds	r5, r5, r1
        rebootCountdown += (mcpsIndication->Buffer[cmdIndex++] << 16) & 0x00FF0000;
 80322ea:	b2f6      	uxtb	r6, r6
        if (rebootCountdown == 0)
 80322ec:	d0c4      	beq.n	8032278 <LmhpFirmwareManagementOnMcpsIndication+0xf8>
        else if (rebootCountdown == 0xFFFFFF)
 80322ee:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 80322f2:	429d      	cmp	r5, r3
 80322f4:	d113      	bne.n	803231e <LmhpFirmwareManagementOnMcpsIndication+0x19e>
          TimerStop(&RebootTimer);
 80322f6:	4638      	mov	r0, r7
 80322f8:	f008 ffea 	bl	803b2d0 <UTIL_TIMER_Stop>
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_REBOOT_COUNTDOWN_ANS;
 80322fc:	f8da 3004 	ldr.w	r3, [sl, #4]
 8032300:	2203      	movs	r2, #3
 8032302:	551a      	strb	r2, [r3, r4]
 8032304:	1c62      	adds	r2, r4, #1
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootCountdown >> 0) & 0xFF;
 8032306:	b2d2      	uxtb	r2, r2
 8032308:	1ca1      	adds	r1, r4, #2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootCountdown >> 8) & 0xFF;
 803230a:	b2c9      	uxtb	r1, r1
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootCountdown >> 0) & 0xFF;
 803230c:	549d      	strb	r5, [r3, r2]
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootCountdown >> 8) & 0xFF;
 803230e:	0a28      	lsrs	r0, r5, #8
 8032310:	1ce2      	adds	r2, r4, #3
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootCountdown >> 16) & 0xFF;
 8032312:	3404      	adds	r4, #4
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootCountdown >> 8) & 0xFF;
 8032314:	5458      	strb	r0, [r3, r1]
 8032316:	b2d2      	uxtb	r2, r2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootCountdown >> 16) & 0xFF;
 8032318:	b2e4      	uxtb	r4, r4
 803231a:	0c2d      	lsrs	r5, r5, #16
 803231c:	e7c7      	b.n	80322ae <LmhpFirmwareManagementOnMcpsIndication+0x12e>
            TimerSetValue(&RebootTimer, rebootCountdown * 1000);
 803231e:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8032322:	4369      	muls	r1, r5
 8032324:	4638      	mov	r0, r7
 8032326:	f009 f85d 	bl	803b3e4 <UTIL_TIMER_SetPeriod>
            TimerStart(&RebootTimer);
 803232a:	4638      	mov	r0, r7
 803232c:	f009 f820 	bl	803b370 <UTIL_TIMER_Start>
 8032330:	e7e4      	b.n	80322fc <LmhpFirmwareManagementOnMcpsIndication+0x17c>
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_UPGRADE_IMAGE_ANS;
 8032332:	f8da 2004 	ldr.w	r2, [sl, #4]
 8032336:	2104      	movs	r1, #4
 8032338:	5511      	strb	r1, [r2, r4]
 803233a:	1c63      	adds	r3, r4, #1
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = imageStatus & 0x03;
 803233c:	3402      	adds	r4, #2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_UPGRADE_IMAGE_ANS;
 803233e:	b2db      	uxtb	r3, r3
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = imageStatus & 0x03;
 8032340:	b2e4      	uxtb	r4, r4
 8032342:	2100      	movs	r1, #0
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = 0x01;
 8032344:	54d1      	strb	r1, [r2, r3]
        break;
 8032346:	e782      	b.n	803224e <LmhpFirmwareManagementOnMcpsIndication+0xce>
        firmwareVersion += (mcpsIndication->Buffer[cmdIndex++] << 24) & 0xFF000000;
 8032348:	3305      	adds	r3, #5
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_DELETE_IMAGE_ANS;
 803234a:	f8da 2004 	ldr.w	r2, [sl, #4]
        firmwareVersion += (mcpsIndication->Buffer[cmdIndex++] << 24) & 0xFF000000;
 803234e:	b2de      	uxtb	r6, r3
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_DELETE_IMAGE_ANS;
 8032350:	1c63      	adds	r3, r4, #1
 8032352:	f802 9004 	strb.w	r9, [r2, r4]
 8032356:	b2db      	uxtb	r3, r3
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = 0x01;
 8032358:	3402      	adds	r4, #2
 803235a:	e755      	b.n	8032208 <LmhpFirmwareManagementOnMcpsIndication+0x88>
 803235c:	2000498c 	.word	0x2000498c
 8032360:	200034f8 	.word	0x200034f8

08032364 <LmhpFirmwareManagementInit>:
{
 8032364:	b507      	push	{r0, r1, r2, lr}
 8032366:	480a      	ldr	r0, [pc, #40]	; (8032390 <LmhpFirmwareManagementInit+0x2c>)
  if (dataBuffer != NULL)
 8032368:	b179      	cbz	r1, 803238a <LmhpFirmwareManagementInit+0x26>
    LmhpFirmwareManagementState.DataBufferMaxSize = dataBufferMaxSize;
 803236a:	7082      	strb	r2, [r0, #2]
    LmhpFirmwareManagementState.Initialized = true;
 803236c:	f240 1301 	movw	r3, #257	; 0x101
    TimerInit(&RebootTimer, OnRebootTimer);
 8032370:	2200      	movs	r2, #0
    LmhpFirmwareManagementState.DataBuffer = dataBuffer;
 8032372:	6041      	str	r1, [r0, #4]
    LmhpFirmwareManagementState.Initialized = true;
 8032374:	f820 3b08 	strh.w	r3, [r0], #8
    TimerInit(&RebootTimer, OnRebootTimer);
 8032378:	f04f 31ff 	mov.w	r1, #4294967295
 803237c:	4b05      	ldr	r3, [pc, #20]	; (8032394 <LmhpFirmwareManagementInit+0x30>)
 803237e:	9200      	str	r2, [sp, #0]
 8032380:	f008 ff48 	bl	803b214 <UTIL_TIMER_Create>
}
 8032384:	b003      	add	sp, #12
 8032386:	f85d fb04 	ldr.w	pc, [sp], #4
    LmhpFirmwareManagementState.Initialized = false;
 803238a:	8001      	strh	r1, [r0, #0]
}
 803238c:	e7fa      	b.n	8032384 <LmhpFirmwareManagementInit+0x20>
 803238e:	bf00      	nop
 8032390:	2000498c 	.word	0x2000498c
 8032394:	0803217b 	.word	0x0803217b

08032398 <LmhpFirmwareManagementPackageFactory>:
}
 8032398:	4800      	ldr	r0, [pc, #0]	; (803239c <LmhpFirmwareManagementPackageFactory+0x4>)
 803239a:	4770      	bx	lr
 803239c:	200034f8 	.word	0x200034f8

080323a0 <LmhpFragmentationIsInitialized>:
}

static bool LmhpFragmentationIsInitialized( void )
{
    return LmhpFragmentationState.Initialized;
}
 80323a0:	4b01      	ldr	r3, [pc, #4]	; (80323a8 <LmhpFragmentationIsInitialized+0x8>)
 80323a2:	7818      	ldrb	r0, [r3, #0]
 80323a4:	4770      	bx	lr
 80323a6:	bf00      	nop
 80323a8:	200049ac 	.word	0x200049ac

080323ac <LmhpFragmentationIsRunning>:

static bool LmhpFragmentationIsRunning( void )
{
    if( LmhpFragmentationState.Initialized == false )
 80323ac:	4b02      	ldr	r3, [pc, #8]	; (80323b8 <LmhpFragmentationIsRunning+0xc>)
 80323ae:	7818      	ldrb	r0, [r3, #0]
 80323b0:	b100      	cbz	r0, 80323b4 <LmhpFragmentationIsRunning+0x8>
    {
        return false;
    }

    return LmhpFragmentationState.IsRunning;
 80323b2:	7858      	ldrb	r0, [r3, #1]
}
 80323b4:	4770      	bx	lr
 80323b6:	bf00      	nop
 80323b8:	200049ac 	.word	0x200049ac

080323bc <LmhpFragmentationInit>:
{
 80323bc:	b513      	push	{r0, r1, r4, lr}
 80323be:	4c0f      	ldr	r4, [pc, #60]	; (80323fc <LmhpFragmentationInit+0x40>)
    if( ( params != NULL ) && ( dataBuffer != NULL ) )
 80323c0:	b1c0      	cbz	r0, 80323f4 <LmhpFragmentationInit+0x38>
 80323c2:	b1b9      	cbz	r1, 80323f4 <LmhpFragmentationInit+0x38>
        LmhpFragmentationState.Initialized = true;
 80323c4:	f240 1301 	movw	r3, #257	; 0x101
        LmhpFragmentationState.DataBufferMaxSize = dataBufferMaxSize;
 80323c8:	70e2      	strb	r2, [r4, #3]
        TxDelayTime = 0;
 80323ca:	2200      	movs	r2, #0
        LmhpFragmentationParams = ( LmhpFragmentationParams_t* )params;
 80323cc:	60e0      	str	r0, [r4, #12]
        LmhpFragmentationState.DataBuffer = dataBuffer;
 80323ce:	6061      	str	r1, [r4, #4]
        LmhpFragmentationState.Initialized = true;
 80323d0:	8023      	strh	r3, [r4, #0]
        TimerInit( &FragmentTxDelayTimer, OnFragmentTxDelay );
 80323d2:	9200      	str	r2, [sp, #0]
 80323d4:	4b0a      	ldr	r3, [pc, #40]	; (8032400 <LmhpFragmentationInit+0x44>)
        TxDelayTime = 0;
 80323d6:	6122      	str	r2, [r4, #16]
        TimerInit( &FragmentTxDelayTimer, OnFragmentTxDelay );
 80323d8:	f04f 31ff 	mov.w	r1, #4294967295
 80323dc:	f104 0014 	add.w	r0, r4, #20
 80323e0:	f008 ff18 	bl	803b214 <UTIL_TIMER_Create>
    UTIL_MEM_set_8( FragSessionData, 0, sizeof(FragSessionData) );
 80323e4:	4807      	ldr	r0, [pc, #28]	; (8032404 <LmhpFragmentationInit+0x48>)
 80323e6:	2260      	movs	r2, #96	; 0x60
 80323e8:	2100      	movs	r1, #0
}
 80323ea:	b002      	add	sp, #8
 80323ec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    UTIL_MEM_set_8( FragSessionData, 0, sizeof(FragSessionData) );
 80323f0:	f008 bd5e 	b.w	803aeb0 <UTIL_MEM_set_8>
        LmhpFragmentationParams = NULL;
 80323f4:	2300      	movs	r3, #0
 80323f6:	60e3      	str	r3, [r4, #12]
        LmhpFragmentationState.Initialized = false;
 80323f8:	8023      	strh	r3, [r4, #0]
 80323fa:	e7f3      	b.n	80323e4 <LmhpFragmentationInit+0x28>
 80323fc:	200049ac 	.word	0x200049ac
 8032400:	08032409 	.word	0x08032409
 8032404:	200049d8 	.word	0x200049d8

08032408 <OnFragmentTxDelay>:
{
 8032408:	b510      	push	{r4, lr}
    TimerStop( &FragmentTxDelayTimer );
 803240a:	4c06      	ldr	r4, [pc, #24]	; (8032424 <OnFragmentTxDelay+0x1c>)
 803240c:	f104 0014 	add.w	r0, r4, #20
 8032410:	f008 ff5e 	bl	803b2d0 <UTIL_TIMER_Stop>
    LmhpFragmentationState.TxDelayState = FRAGMENTATION_TX_DELAY_STATE_PENDING;
 8032414:	2302      	movs	r3, #2
 8032416:	70a3      	strb	r3, [r4, #2]
    LmhpFragmentationPackage.OnPackageProcessEvent();
 8032418:	4b03      	ldr	r3, [pc, #12]	; (8032428 <OnFragmentTxDelay+0x20>)
}
 803241a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    LmhpFragmentationPackage.OnPackageProcessEvent();
 803241e:	695b      	ldr	r3, [r3, #20]
 8032420:	4718      	bx	r3
 8032422:	bf00      	nop
 8032424:	200049ac 	.word	0x200049ac
 8032428:	2000352c 	.word	0x2000352c

0803242c <LmhpFragmentationOnMcpsIndication>:
            break;
    }
}

static void LmhpFragmentationOnMcpsIndication( McpsIndication_t *mcpsIndication )
{
 803242c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    // Answer struct for the commands.
    LmHandlerAppData_t cmdReplyAppData;
    // Co-efficient used to calculate delay.
    uint8_t blockAckDelay = 0;

    if( mcpsIndication->Port != FRAGMENTATION_PORT )
 8032430:	78c3      	ldrb	r3, [r0, #3]
 8032432:	2bc9      	cmp	r3, #201	; 0xc9
{
 8032434:	b093      	sub	sp, #76	; 0x4c
 8032436:	4607      	mov	r7, r0
    if( mcpsIndication->Port != FRAGMENTATION_PORT )
 8032438:	d12a      	bne.n	8032490 <LmhpFragmentationOnMcpsIndication+0x64>
    uint8_t blockAckDelay = 0;
 803243a:	2300      	movs	r3, #0
                fragCounter = ( mcpsIndication->Buffer[cmdIndex++] << 0 ) & 0x00FF;
                fragCounter |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;

                fragIndex = ( fragCounter >> 14 ) & 0x03;
                fragCounter &= 0x3FFF;
                if (FragSessionData[fragIndex].FragGroupData.IsActive == false)
 803243c:	4eb8      	ldr	r6, [pc, #736]	; (8032720 <LmhpFragmentationOnMcpsIndication+0x2f4>)
    uint8_t blockAckDelay = 0;
 803243e:	9301      	str	r3, [sp, #4]
    bool isAnswerDelayed = false;
 8032440:	4699      	mov	r9, r3
    uint8_t dataBufferIndex = 0;
 8032442:	461c      	mov	r4, r3
    uint8_t cmdIndex = 0;
 8032444:	469b      	mov	fp, r3
    while( cmdIndex < mcpsIndication->BufferSize )
 8032446:	7b39      	ldrb	r1, [r7, #12]
 8032448:	458b      	cmp	fp, r1
 803244a:	d324      	bcc.n	8032496 <LmhpFragmentationOnMcpsIndication+0x6a>

    // After processing the commands, if the end-node has to reply back then a flag is checked if the
    // reply is to be sent immediately or with a delay.
    // In some scenarios it is not desired that multiple end-notes send uplinks at the same time to
    // the same server. (Example: Fragment status during a multicast FUOTA)
    if( dataBufferIndex != 0 )
 803244c:	b304      	cbz	r4, 8032490 <LmhpFragmentationOnMcpsIndication+0x64>
    {
        // Prepare Answer that is to be transmitted
        cmdReplyAppData.Buffer = LmhpFragmentationState.DataBuffer;
 803244e:	4db4      	ldr	r5, [pc, #720]	; (8032720 <LmhpFragmentationOnMcpsIndication+0x2f4>)
        cmdReplyAppData.BufferSize = dataBufferIndex;
 8032450:	f88d 4031 	strb.w	r4, [sp, #49]	; 0x31
        cmdReplyAppData.Buffer = LmhpFragmentationState.DataBuffer;
 8032454:	686b      	ldr	r3, [r5, #4]
 8032456:	930d      	str	r3, [sp, #52]	; 0x34
        cmdReplyAppData.Port = FRAGMENTATION_PORT;
 8032458:	23c9      	movs	r3, #201	; 0xc9
 803245a:	4eb2      	ldr	r6, [pc, #712]	; (8032724 <LmhpFragmentationOnMcpsIndication+0x2f8>)
 803245c:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30

        if( isAnswerDelayed == true )
 8032460:	ac0c      	add	r4, sp, #48	; 0x30
 8032462:	f1b9 0f00 	cmp.w	r9, #0
 8032466:	f000 81ae 	beq.w	80327c6 <LmhpFragmentationOnMcpsIndication+0x39a>
            // Delay = Pseudo Random Delay * 1000 milli seconds.
            // Eg: blockAckDelay = 7
            //     Pseudo Random Delay = rand(0:1) * 2^11
            //     rand(0:1) seconds = rand(0:1000) milliseconds
            //     Delay = rand(0:1000) * 2048 => 2048000ms = 34 minutes
            TxDelayTime = randr( 0, 1000 ) * ( 1 << ( blockAckDelay + 4 ) );
 803246a:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 803246e:	2000      	movs	r0, #0
 8032470:	f006 fd0a 	bl	8038e88 <randr>
 8032474:	9b01      	ldr	r3, [sp, #4]
 8032476:	3304      	adds	r3, #4
 8032478:	fa00 f303 	lsl.w	r3, r0, r3
            DelayedReplyAppData = cmdReplyAppData;
 803247c:	e894 0003 	ldmia.w	r4, {r0, r1}
            TxDelayTime = randr( 0, 1000 ) * ( 1 << ( blockAckDelay + 4 ) );
 8032480:	612b      	str	r3, [r5, #16]
            DelayedReplyAppData = cmdReplyAppData;
 8032482:	4ba9      	ldr	r3, [pc, #676]	; (8032728 <LmhpFragmentationOnMcpsIndication+0x2fc>)
 8032484:	e883 0003 	stmia.w	r3, {r0, r1}
            LmhpFragmentationState.TxDelayState = FRAGMENTATION_TX_DELAY_STATE_START;
 8032488:	2301      	movs	r3, #1
 803248a:	70ab      	strb	r3, [r5, #2]
            LmhpFragmentationPackage.OnPackageProcessEvent();
 803248c:	6973      	ldr	r3, [r6, #20]
 803248e:	4798      	blx	r3

            /* restore initial Duty Cycle */
            LmHandlerSetDutyCycleEnable( current_dutycycle );
        }
    }
}
 8032490:	b013      	add	sp, #76	; 0x4c
 8032492:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        switch( mcpsIndication->Buffer[cmdIndex++] )
 8032496:	68bb      	ldr	r3, [r7, #8]
 8032498:	f813 200b 	ldrb.w	r2, [r3, fp]
 803249c:	f10b 0a01 	add.w	sl, fp, #1
 80324a0:	fa5f fa8a 	uxtb.w	sl, sl
 80324a4:	2a08      	cmp	r2, #8
 80324a6:	d81a      	bhi.n	80324de <LmhpFragmentationOnMcpsIndication+0xb2>
 80324a8:	e8df f012 	tbh	[pc, r2, lsl #1]
 80324ac:	001b0009 	.word	0x001b0009
 80324b0:	00ef005d 	.word	0x00ef005d
 80324b4:	00190019 	.word	0x00190019
 80324b8:	00190019 	.word	0x00190019
 80324bc:	0111      	.short	0x0111
                if( mcpsIndication->Multicast == 1 )
 80324be:	78bb      	ldrb	r3, [r7, #2]
 80324c0:	2b01      	cmp	r3, #1
 80324c2:	d00c      	beq.n	80324de <LmhpFragmentationOnMcpsIndication+0xb2>
                LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FRAGMENTATION_PKG_VERSION_ANS;
 80324c4:	6872      	ldr	r2, [r6, #4]
 80324c6:	2300      	movs	r3, #0
 80324c8:	1c61      	adds	r1, r4, #1
 80324ca:	5513      	strb	r3, [r2, r4]
                LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FRAGMENTATION_ID;
 80324cc:	b2c9      	uxtb	r1, r1
 80324ce:	1ca3      	adds	r3, r4, #2
 80324d0:	2003      	movs	r0, #3
 80324d2:	b2db      	uxtb	r3, r3
 80324d4:	5450      	strb	r0, [r2, r1]
                LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FRAGMENTATION_VERSION;
 80324d6:	2101      	movs	r1, #1
 80324d8:	4404      	add	r4, r0
 80324da:	54d1      	strb	r1, [r2, r3]
 80324dc:	b2e4      	uxtb	r4, r4
                break;
 80324de:	46d3      	mov	fp, sl
 80324e0:	e7b1      	b.n	8032446 <LmhpFragmentationOnMcpsIndication+0x1a>
                uint8_t fragIndex = mcpsIndication->Buffer[cmdIndex++];
 80324e2:	f813 a00a 	ldrb.w	sl, [r3, sl]
                FragSessionData[fragIndex].FragDecoderStatus = FragDecoderGetStatus( );
 80324e6:	a808      	add	r0, sp, #32
 80324e8:	2318      	movs	r3, #24
 80324ea:	f3ca 0541 	ubfx	r5, sl, #1, #2
 80324ee:	fb03 6805 	mla	r8, r3, r5, r6
 80324f2:	f7fe fef9 	bl	80312e8 <FragDecoderGetStatus>
 80324f6:	9808      	ldr	r0, [sp, #32]
 80324f8:	9909      	ldr	r1, [sp, #36]	; 0x24
                uint8_t fragIndex = mcpsIndication->Buffer[cmdIndex++];
 80324fa:	f10b 0b02 	add.w	fp, fp, #2
                FragSessionData[fragIndex].FragDecoderStatus = FragDecoderGetStatus( );
 80324fe:	f108 0338 	add.w	r3, r8, #56	; 0x38
                if( ( participants == 1 ) ||
 8032502:	f01a 0f01 	tst.w	sl, #1
                FragSessionData[fragIndex].FragDecoderStatus = FragDecoderGetStatus( );
 8032506:	c303      	stmia	r3!, {r0, r1}
                uint8_t fragIndex = mcpsIndication->Buffer[cmdIndex++];
 8032508:	fa5f fb8b 	uxtb.w	fp, fp
                if( ( participants == 1 ) ||
 803250c:	d102      	bne.n	8032514 <LmhpFragmentationOnMcpsIndication+0xe8>
                    ( ( participants == 0 ) && ( FragSessionData[fragIndex].FragDecoderStatus.FragNbLost > 0 ) ) )
 803250e:	f8b8 303a 	ldrh.w	r3, [r8, #58]	; 0x3a
 8032512:	b333      	cbz	r3, 8032562 <LmhpFragmentationOnMcpsIndication+0x136>
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FRAGMENTATION_FRAG_STATUS_ANS;
 8032514:	6872      	ldr	r2, [r6, #4]
 8032516:	f04f 0901 	mov.w	r9, #1
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.FragNbRx & 0xFF;
 803251a:	2318      	movs	r3, #24
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FRAGMENTATION_FRAG_STATUS_ANS;
 803251c:	f802 9004 	strb.w	r9, [r2, r4]
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.FragNbRx & 0xFF;
 8032520:	fb03 6305 	mla	r3, r3, r5, r6
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FRAGMENTATION_FRAG_STATUS_ANS;
 8032524:	eb04 0109 	add.w	r1, r4, r9
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.FragNbRx & 0xFF;
 8032528:	b2c9      	uxtb	r1, r1
 803252a:	8f18      	ldrh	r0, [r3, #56]	; 0x38
 803252c:	5450      	strb	r0, [r2, r1]
                                                                           ( ( FragSessionData[fragIndex].FragDecoderStatus.FragNbRx >> 8 ) & 0x3F );
 803252e:	8f19      	ldrh	r1, [r3, #56]	; 0x38
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.FragNbRx & 0xFF;
 8032530:	1ca0      	adds	r0, r4, #2
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = ( fragIndex << 6 ) |
 8032532:	b2c0      	uxtb	r0, r0
                                                                           ( ( FragSessionData[fragIndex].FragDecoderStatus.FragNbRx >> 8 ) & 0x3F );
 8032534:	f3c1 2105 	ubfx	r1, r1, #8, #6
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = ( fragIndex << 6 ) |
 8032538:	ea41 1185 	orr.w	r1, r1, r5, lsl #6
 803253c:	5411      	strb	r1, [r2, r0]
 803253e:	1ce0      	adds	r0, r4, #3
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.FragNbLost;
 8032540:	b2c0      	uxtb	r0, r0
 8032542:	8f5d      	ldrh	r5, [r3, #58]	; 0x3a
 8032544:	5415      	strb	r5, [r2, r0]
 8032546:	1d21      	adds	r1, r4, #4
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.MatrixError & 0x01;
 8032548:	f893 003e 	ldrb.w	r0, [r3, #62]	; 0x3e
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.FragNbLost;
 803254c:	b2c9      	uxtb	r1, r1
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.MatrixError & 0x01;
 803254e:	ea00 0009 	and.w	r0, r0, r9
 8032552:	5450      	strb	r0, [r2, r1]
                    blockAckDelay = FragSessionData[fragIndex].FragGroupData.Control.Fields.BlockAckDelay;
 8032554:	f893 0031 	ldrb.w	r0, [r3, #49]	; 0x31
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.MatrixError & 0x01;
 8032558:	3405      	adds	r4, #5
                    blockAckDelay = FragSessionData[fragIndex].FragGroupData.Control.Fields.BlockAckDelay;
 803255a:	f000 0307 	and.w	r3, r0, #7
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.MatrixError & 0x01;
 803255e:	b2e4      	uxtb	r4, r4
                    blockAckDelay = FragSessionData[fragIndex].FragGroupData.Control.Fields.BlockAckDelay;
 8032560:	9301      	str	r3, [sp, #4]
                uint8_t fragIndex = mcpsIndication->Buffer[cmdIndex++];
 8032562:	46da      	mov	sl, fp
 8032564:	e7bb      	b.n	80324de <LmhpFragmentationOnMcpsIndication+0xb2>
                if( mcpsIndication->Multicast == 1 )
 8032566:	78ba      	ldrb	r2, [r7, #2]
 8032568:	2a01      	cmp	r2, #1
 803256a:	d0b8      	beq.n	80324de <LmhpFragmentationOnMcpsIndication+0xb2>
                fragSessionData.FragGroupData.FragSession.Value = mcpsIndication->Buffer[cmdIndex++];
 803256c:	f813 200a 	ldrb.w	r2, [r3, sl]
 8032570:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
                fragSessionData.FragGroupData.FragNb =  ( mcpsIndication->Buffer[cmdIndex++] << 0 ) & 0x00FF;
 8032574:	f10b 0203 	add.w	r2, fp, #3
                fragSessionData.FragGroupData.FragNb |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 8032578:	b2d2      	uxtb	r2, r2
                fragSessionData.FragGroupData.Padding = mcpsIndication->Buffer[cmdIndex++];
 803257a:	f10b 0007 	add.w	r0, fp, #7
                fragSessionData.FragGroupData.FragNb |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 803257e:	5c99      	ldrb	r1, [r3, r2]
                fragSessionData.FragGroupData.FragSession.Value = mcpsIndication->Buffer[cmdIndex++];
 8032580:	f10b 0202 	add.w	r2, fp, #2
                fragSessionData.FragGroupData.FragNb =  ( mcpsIndication->Buffer[cmdIndex++] << 0 ) & 0x00FF;
 8032584:	b2d2      	uxtb	r2, r2
                fragSessionData.FragGroupData.Descriptor =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032586:	b2c0      	uxtb	r0, r0
                fragSessionData.FragGroupData.FragNb |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 8032588:	f813 8002 	ldrb.w	r8, [r3, r2]
                fragSessionData.FragGroupData.Descriptor =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 803258c:	5c18      	ldrb	r0, [r3, r0]
 803258e:	9002      	str	r0, [sp, #8]
                fragSessionData.FragGroupData.FragNb |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 8032590:	f10b 0204 	add.w	r2, fp, #4
                fragSessionData.FragGroupData.FragSize = mcpsIndication->Buffer[cmdIndex++];
 8032594:	b2d2      	uxtb	r2, r2
                fragSessionData.FragGroupData.Descriptor =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032596:	f10b 0008 	add.w	r0, fp, #8
                fragSessionData.FragGroupData.FragSize = mcpsIndication->Buffer[cmdIndex++];
 803259a:	f813 9002 	ldrb.w	r9, [r3, r2]
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 803259e:	b2c0      	uxtb	r0, r0
                fragSessionData.FragGroupData.FragSize = mcpsIndication->Buffer[cmdIndex++];
 80325a0:	f10b 0205 	add.w	r2, fp, #5
                fragSessionData.FragGroupData.Control.Value = mcpsIndication->Buffer[cmdIndex++];
 80325a4:	b2d2      	uxtb	r2, r2
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 80325a6:	5c18      	ldrb	r0, [r3, r0]
                fragSessionData.FragGroupData.Control.Value = mcpsIndication->Buffer[cmdIndex++];
 80325a8:	5c9a      	ldrb	r2, [r3, r2]
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 80325aa:	9003      	str	r0, [sp, #12]
                fragSessionData.FragGroupData.FragNb |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 80325ac:	ea48 2801 	orr.w	r8, r8, r1, lsl #8
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 80325b0:	f10b 0009 	add.w	r0, fp, #9
                fragSessionData.FragGroupData.Control.Value = mcpsIndication->Buffer[cmdIndex++];
 80325b4:	f10b 0106 	add.w	r1, fp, #6
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 80325b8:	f10b 0a0b 	add.w	sl, fp, #11
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 80325bc:	f10b 0b0a 	add.w	fp, fp, #10
                fragSessionData.FragGroupData.Padding = mcpsIndication->Buffer[cmdIndex++];
 80325c0:	b2c9      	uxtb	r1, r1
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 80325c2:	b2c0      	uxtb	r0, r0
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 80325c4:	fa5f fb8b 	uxtb.w	fp, fp
                if( fragSessionData.FragGroupData.Control.Fields.FragAlgo > 0 )
 80325c8:	f012 0f38 	tst.w	r2, #56	; 0x38
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 80325cc:	5c18      	ldrb	r0, [r3, r0]
                fragSessionData.FragGroupData.Padding = mcpsIndication->Buffer[cmdIndex++];
 80325ce:	5c59      	ldrb	r1, [r3, r1]
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 80325d0:	f813 b00b 	ldrb.w	fp, [r3, fp]
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 80325d4:	9004      	str	r0, [sp, #16]
                    status |= 0x01; // Encoding unsupported
 80325d6:	bf14      	ite	ne
 80325d8:	2301      	movne	r3, #1
 80325da:	2300      	moveq	r3, #0
                if( ( fragSessionData.FragGroupData.FragNb > FRAG_MAX_NB ) || 
 80325dc:	f5b8 7f33 	cmp.w	r8, #716	; 0x2cc
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 80325e0:	fa5f fa8a 	uxtb.w	sl, sl
                if( ( fragSessionData.FragGroupData.FragNb > FRAG_MAX_NB ) || 
 80325e4:	d941      	bls.n	803266a <LmhpFragmentationOnMcpsIndication+0x23e>
                    status |= 0x02; // Not enough Memory
 80325e6:	f043 0302 	orr.w	r3, r3, #2
                status |= ( fragSessionData.FragGroupData.FragSession.Fields.FragIndex << 6 ) & 0xC0;
 80325ea:	f89d c031 	ldrb.w	ip, [sp, #49]	; 0x31
 80325ee:	f3cc 1c01 	ubfx	ip, ip, #4, #2
 80325f2:	ea43 158c 	orr.w	r5, r3, ip, lsl #6
                if( ( status & 0x0F ) == 0 )
 80325f6:	071b      	lsls	r3, r3, #28
 80325f8:	d12c      	bne.n	8032654 <LmhpFragmentationOnMcpsIndication+0x228>
                    FragSessionData[fragSessionData.FragGroupData.FragSession.Fields.FragIndex] = fragSessionData;
 80325fa:	2301      	movs	r3, #1
 80325fc:	f88d 2035 	strb.w	r2, [sp, #53]	; 0x35
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032600:	9a04      	ldr	r2, [sp, #16]
                    FragSessionData[fragSessionData.FragGroupData.FragSession.Fields.FragIndex] = fragSessionData;
 8032602:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032606:	ea4f 630b 	mov.w	r3, fp, lsl #24
 803260a:	eb03 4302 	add.w	r3, r3, r2, lsl #16
 803260e:	9a02      	ldr	r2, [sp, #8]
                    FragSessionData[fragSessionData.FragGroupData.FragSession.Fields.FragIndex] = fragSessionData;
 8032610:	f8ad 8032 	strh.w	r8, [sp, #50]	; 0x32
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032614:	4413      	add	r3, r2
 8032616:	9a03      	ldr	r2, [sp, #12]
                    FragSessionData[fragSessionData.FragGroupData.FragSession.Fields.FragIndex] = fragSessionData;
 8032618:	f88d 9034 	strb.w	r9, [sp, #52]	; 0x34
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 803261c:	eb03 2302 	add.w	r3, r3, r2, lsl #8
                    FragSessionData[fragSessionData.FragGroupData.FragSession.Fields.FragIndex] = fragSessionData;
 8032620:	930e      	str	r3, [sp, #56]	; 0x38
 8032622:	f04f 33ff 	mov.w	r3, #4294967295
 8032626:	9311      	str	r3, [sp, #68]	; 0x44
 8032628:	f88d 1036 	strb.w	r1, [sp, #54]	; 0x36
 803262c:	2318      	movs	r3, #24
 803262e:	f10d 0e30 	add.w	lr, sp, #48	; 0x30
 8032632:	fb03 6c0c 	mla	ip, r3, ip, r6
 8032636:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 803263a:	f10c 0c2c 	add.w	ip, ip, #44	; 0x2c
 803263e:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 8032642:	e89e 0003 	ldmia.w	lr, {r0, r1}
                    FragDecoderInit( fragSessionData.FragGroupData.FragNb,
 8032646:	68f2      	ldr	r2, [r6, #12]
                    FragSessionData[fragSessionData.FragGroupData.FragSession.Fields.FragIndex] = fragSessionData;
 8032648:	e88c 0003 	stmia.w	ip, {r0, r1}
                    FragDecoderInit( fragSessionData.FragGroupData.FragNb,
 803264c:	4649      	mov	r1, r9
 803264e:	4640      	mov	r0, r8
 8032650:	f7fe fc62 	bl	8030f18 <FragDecoderInit>
                LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FRAGMENTATION_FRAG_SESSION_SETUP_ANS;
 8032654:	1c63      	adds	r3, r4, #1
 8032656:	6872      	ldr	r2, [r6, #4]
 8032658:	b2db      	uxtb	r3, r3
 803265a:	2102      	movs	r1, #2
 803265c:	5511      	strb	r1, [r2, r4]
                LmhpFragmentationState.DataBuffer[dataBufferIndex++] = status;
 803265e:	440c      	add	r4, r1
 8032660:	54d5      	strb	r5, [r2, r3]
 8032662:	b2e4      	uxtb	r4, r4
                isAnswerDelayed = false;
 8032664:	f04f 0900 	mov.w	r9, #0
                break;
 8032668:	e739      	b.n	80324de <LmhpFragmentationOnMcpsIndication+0xb2>
                if( ( fragSessionData.FragGroupData.FragNb > FRAG_MAX_NB ) || 
 803266a:	f1b9 0f78 	cmp.w	r9, #120	; 0x78
 803266e:	d8ba      	bhi.n	80325e6 <LmhpFragmentationOnMcpsIndication+0x1ba>
 8032670:	e9cd 1306 	strd	r1, r3, [sp, #24]
 8032674:	9205      	str	r2, [sp, #20]
                    ( ( fragSessionData.FragGroupData.FragNb * fragSessionData.FragGroupData.FragSize ) > FragDecoderGetMaxFileSize( ) ) )
 8032676:	f7fe fc81 	bl	8030f7c <FragDecoderGetMaxFileSize>
 803267a:	fb09 f508 	mul.w	r5, r9, r8
                    ( fragSessionData.FragGroupData.FragSize > FRAG_MAX_SIZE ) ||
 803267e:	4285      	cmp	r5, r0
 8032680:	e9dd 2105 	ldrd	r2, r1, [sp, #20]
 8032684:	9b07      	ldr	r3, [sp, #28]
 8032686:	d8ae      	bhi.n	80325e6 <LmhpFragmentationOnMcpsIndication+0x1ba>
 8032688:	e7af      	b.n	80325ea <LmhpFragmentationOnMcpsIndication+0x1be>
                if( mcpsIndication->Multicast == 1 )
 803268a:	78ba      	ldrb	r2, [r7, #2]
 803268c:	2a01      	cmp	r2, #1
 803268e:	f43f af26 	beq.w	80324de <LmhpFragmentationOnMcpsIndication+0xb2>
                uint8_t id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032692:	f813 300a 	ldrb.w	r3, [r3, sl]
                if( ( id >= FRAGMENTATION_MAX_SESSIONS ) || ( FragSessionData[id].FragGroupData.IsActive == false ) )
 8032696:	2218      	movs	r2, #24
                uint8_t id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032698:	f003 0303 	and.w	r3, r3, #3
                if( ( id >= FRAGMENTATION_MAX_SESSIONS ) || ( FragSessionData[id].FragGroupData.IsActive == false ) )
 803269c:	fb02 6203 	mla	r2, r2, r3, r6
                uint8_t id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 80326a0:	f10b 0b02 	add.w	fp, fp, #2
                if( ( id >= FRAGMENTATION_MAX_SESSIONS ) || ( FragSessionData[id].FragGroupData.IsActive == false ) )
 80326a4:	f892 102c 	ldrb.w	r1, [r2, #44]	; 0x2c
                uint8_t id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 80326a8:	fa5f fb8b 	uxtb.w	fp, fp
                if( ( id >= FRAGMENTATION_MAX_SESSIONS ) || ( FragSessionData[id].FragGroupData.IsActive == false ) )
 80326ac:	b959      	cbnz	r1, 80326c6 <LmhpFragmentationOnMcpsIndication+0x29a>
                    status |= 0x04; // Session does not exist
 80326ae:	f043 0304 	orr.w	r3, r3, #4
                LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FRAGMENTATION_FRAG_SESSION_DELETE_ANS;
 80326b2:	6871      	ldr	r1, [r6, #4]
 80326b4:	1c62      	adds	r2, r4, #1
 80326b6:	b2d2      	uxtb	r2, r2
 80326b8:	2003      	movs	r0, #3
 80326ba:	5508      	strb	r0, [r1, r4]
                LmhpFragmentationState.DataBuffer[dataBufferIndex++] = status;
 80326bc:	3402      	adds	r4, #2
 80326be:	548b      	strb	r3, [r1, r2]
 80326c0:	b2e4      	uxtb	r4, r4
                uint8_t id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 80326c2:	46da      	mov	sl, fp
 80326c4:	e7ce      	b.n	8032664 <LmhpFragmentationOnMcpsIndication+0x238>
                    FragSessionData[id].FragGroupData.IsActive = false;
 80326c6:	2100      	movs	r1, #0
 80326c8:	f882 102c 	strb.w	r1, [r2, #44]	; 0x2c
 80326cc:	e7f1      	b.n	80326b2 <LmhpFragmentationOnMcpsIndication+0x286>
                fragCounter = ( mcpsIndication->Buffer[cmdIndex++] << 0 ) & 0x00FF;
 80326ce:	f10b 0202 	add.w	r2, fp, #2
                fragCounter |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 80326d2:	b2d2      	uxtb	r2, r2
 80326d4:	f813 8002 	ldrb.w	r8, [r3, r2]
 80326d8:	f813 300a 	ldrb.w	r3, [r3, sl]
                if (FragSessionData[fragIndex].FragGroupData.IsActive == false)
 80326dc:	2218      	movs	r2, #24
                fragCounter |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 80326de:	ea43 2308 	orr.w	r3, r3, r8, lsl #8
                if (FragSessionData[fragIndex].FragGroupData.IsActive == false)
 80326e2:	ea4f 1898 	mov.w	r8, r8, lsr #6
 80326e6:	fb02 6208 	mla	r2, r2, r8, r6
 80326ea:	f102 052c 	add.w	r5, r2, #44	; 0x2c
 80326ee:	f892 202c 	ldrb.w	r2, [r2, #44]	; 0x2c
 80326f2:	2a00      	cmp	r2, #0
 80326f4:	d065      	beq.n	80327c2 <LmhpFragmentationOnMcpsIndication+0x396>
                if( mcpsIndication->Multicast == 1 )
 80326f6:	78ba      	ldrb	r2, [r7, #2]
 80326f8:	2a01      	cmp	r2, #1
 80326fa:	d117      	bne.n	803272c <LmhpFragmentationOnMcpsIndication+0x300>
                    uint8_t groupId = LoRaMacMcChannelGetGroupId( mcpsIndication->DevAddress );
 80326fc:	6978      	ldr	r0, [r7, #20]
 80326fe:	9302      	str	r3, [sp, #8]
 8032700:	f002 fdc0 	bl	8035284 <LoRaMacMcChannelGetGroupId>
                    if( ( groupId == 0xFF ) ||
 8032704:	28ff      	cmp	r0, #255	; 0xff
 8032706:	d008      	beq.n	803271a <LmhpFragmentationOnMcpsIndication+0x2ee>
                        ( ( FragSessionData[fragIndex].FragGroupData.FragSession.Fields.McGroupBitMask & ( 1 << groupId ) ) == 0 ) )
 8032708:	786a      	ldrb	r2, [r5, #1]
                    if( ( groupId == 0xFF ) ||
 803270a:	9b02      	ldr	r3, [sp, #8]
                        ( ( FragSessionData[fragIndex].FragGroupData.FragSession.Fields.McGroupBitMask & ( 1 << groupId ) ) == 0 ) )
 803270c:	f002 020f 	and.w	r2, r2, #15
 8032710:	fa42 f000 	asr.w	r0, r2, r0
                    if( ( groupId == 0xFF ) ||
 8032714:	f010 0f01 	tst.w	r0, #1
 8032718:	d108      	bne.n	803272c <LmhpFragmentationOnMcpsIndication+0x300>
                        cmdIndex = mcpsIndication->BufferSize;
 803271a:	f897 a00c 	ldrb.w	sl, [r7, #12]
                        break;
 803271e:	e6de      	b.n	80324de <LmhpFragmentationOnMcpsIndication+0xb2>
 8032720:	200049ac 	.word	0x200049ac
 8032724:	2000352c 	.word	0x2000352c
 8032728:	20006308 	.word	0x20006308
                if (FragSessionData[fragIndex].FragDecoderProcessStatus == FRAG_SESSION_ONGOING)
 803272c:	2218      	movs	r2, #24
 803272e:	fb02 6a08 	mla	sl, r2, r8, r6
                fragCounter |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 8032732:	f10b 0503 	add.w	r5, fp, #3
                if (FragSessionData[fragIndex].FragDecoderProcessStatus == FRAG_SESSION_ONGOING)
 8032736:	f8da 2040 	ldr.w	r2, [sl, #64]	; 0x40
 803273a:	3201      	adds	r2, #1
                fragCounter |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 803273c:	b2ed      	uxtb	r5, r5
                if (FragSessionData[fragIndex].FragDecoderProcessStatus == FRAG_SESSION_ONGOING)
 803273e:	d137      	bne.n	80327b0 <LmhpFragmentationOnMcpsIndication+0x384>
                    FragSessionData[fragIndex].FragDecoderProcessStatus = FragDecoderProcess( fragCounter, &mcpsIndication->Buffer[cmdIndex] );
 8032740:	68b9      	ldr	r1, [r7, #8]
 8032742:	f3c3 000d 	ubfx	r0, r3, #0, #14
 8032746:	4429      	add	r1, r5
 8032748:	f7fe fc1c 	bl	8030f84 <FragDecoderProcess>
 803274c:	f8ca 0040 	str.w	r0, [sl, #64]	; 0x40
                    FragSessionData[fragIndex].FragDecoderStatus = FragDecoderGetStatus( );
 8032750:	a808      	add	r0, sp, #32
 8032752:	f7fe fdc9 	bl	80312e8 <FragDecoderGetStatus>
 8032756:	9808      	ldr	r0, [sp, #32]
 8032758:	9909      	ldr	r1, [sp, #36]	; 0x24
 803275a:	f10a 0338 	add.w	r3, sl, #56	; 0x38
 803275e:	c303      	stmia	r3!, {r0, r1}
                    if( LmhpFragmentationParams->OnProgress != NULL )
 8032760:	68f3      	ldr	r3, [r6, #12]
 8032762:	f8d3 b00c 	ldr.w	fp, [r3, #12]
 8032766:	f1bb 0f00 	cmp.w	fp, #0
 803276a:	d008      	beq.n	803277e <LmhpFragmentationOnMcpsIndication+0x352>
                        LmhpFragmentationParams->OnProgress( FragSessionData[fragIndex].FragDecoderStatus.FragNbRx,
 803276c:	f8ba 303a 	ldrh.w	r3, [sl, #58]	; 0x3a
 8032770:	f89a 2030 	ldrb.w	r2, [sl, #48]	; 0x30
 8032774:	f8ba 102e 	ldrh.w	r1, [sl, #46]	; 0x2e
 8032778:	f8ba 0038 	ldrh.w	r0, [sl, #56]	; 0x38
 803277c:	47d8      	blx	fp
                    if( FragSessionData[fragIndex].FragDecoderProcessStatus >= 0 )
 803277e:	2318      	movs	r3, #24
 8032780:	fb03 6308 	mla	r3, r3, r8, r6
 8032784:	6c18      	ldr	r0, [r3, #64]	; 0x40
 8032786:	2800      	cmp	r0, #0
 8032788:	db12      	blt.n	80327b0 <LmhpFragmentationOnMcpsIndication+0x384>
                        if( LmhpFragmentationParams->OnDone != NULL )
 803278a:	68f2      	ldr	r2, [r6, #12]
 803278c:	6912      	ldr	r2, [r2, #16]
 803278e:	b14a      	cbz	r2, 80327a4 <LmhpFragmentationOnMcpsIndication+0x378>
                                                            ( FragSessionData[fragIndex].FragGroupData.FragNb * FragSessionData[fragIndex].FragGroupData.FragSize ) - FragSessionData[fragIndex].FragGroupData.Padding );
 8032790:	f8b3 c02e 	ldrh.w	ip, [r3, #46]	; 0x2e
 8032794:	f893 1030 	ldrb.w	r1, [r3, #48]	; 0x30
 8032798:	f893 3032 	ldrb.w	r3, [r3, #50]	; 0x32
 803279c:	fb01 f10c 	mul.w	r1, r1, ip
                            LmhpFragmentationParams->OnDone( FragSessionData[fragIndex].FragDecoderProcessStatus,
 80327a0:	1ac9      	subs	r1, r1, r3
 80327a2:	4790      	blx	r2
                        FragSessionData[fragIndex].FragDecoderProcessStatus = FRAG_SESSION_NOT_STARTED;
 80327a4:	2318      	movs	r3, #24
 80327a6:	fb03 6308 	mla	r3, r3, r8, r6
 80327aa:	f06f 0201 	mvn.w	r2, #1
 80327ae:	641a      	str	r2, [r3, #64]	; 0x40
                cmdIndex += FragSessionData[fragIndex].FragGroupData.FragSize;
 80327b0:	2318      	movs	r3, #24
 80327b2:	fb03 6808 	mla	r8, r3, r8, r6
 80327b6:	f898 a030 	ldrb.w	sl, [r8, #48]	; 0x30
 80327ba:	4455      	add	r5, sl
 80327bc:	fa5f fa85 	uxtb.w	sl, r5
                break;
 80327c0:	e68d      	b.n	80324de <LmhpFragmentationOnMcpsIndication+0xb2>
 80327c2:	468a      	mov	sl, r1
 80327c4:	e68b      	b.n	80324de <LmhpFragmentationOnMcpsIndication+0xb2>
            LmHandlerGetDutyCycleEnable( &current_dutycycle );
 80327c6:	f10d 002f 	add.w	r0, sp, #47	; 0x2f
 80327ca:	f7ff f977 	bl	8031abc <LmHandlerGetDutyCycleEnable>
            LmHandlerSetDutyCycleEnable( false );
 80327ce:	4648      	mov	r0, r9
 80327d0:	f7ff f980 	bl	8031ad4 <LmHandlerSetDutyCycleEnable>
            LmhpFragmentationPackage.OnSendRequest( &cmdReplyAppData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true );
 80327d4:	6ab5      	ldr	r5, [r6, #40]	; 0x28
 80327d6:	2301      	movs	r3, #1
 80327d8:	464a      	mov	r2, r9
 80327da:	4649      	mov	r1, r9
 80327dc:	4620      	mov	r0, r4
 80327de:	47a8      	blx	r5
            LmHandlerSetDutyCycleEnable( current_dutycycle );
 80327e0:	f89d 002f 	ldrb.w	r0, [sp, #47]	; 0x2f
 80327e4:	f7ff f976 	bl	8031ad4 <LmHandlerSetDutyCycleEnable>
 80327e8:	e652      	b.n	8032490 <LmhpFragmentationOnMcpsIndication+0x64>
 80327ea:	bf00      	nop

080327ec <LmhpFragmentationProcess>:
{
 80327ec:	b538      	push	{r3, r4, r5, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80327ee:	f3ef 8210 	mrs	r2, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80327f2:	b672      	cpsid	i
    delayTimerState = LmhpFragmentationState.TxDelayState;
 80327f4:	4c0f      	ldr	r4, [pc, #60]	; (8032834 <LmhpFragmentationProcess+0x48>)
 80327f6:	78a3      	ldrb	r3, [r4, #2]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80327f8:	f382 8810 	msr	PRIMASK, r2
    switch( delayTimerState )
 80327fc:	2b01      	cmp	r3, #1
 80327fe:	d002      	beq.n	8032806 <LmhpFragmentationProcess+0x1a>
 8032800:	2b02      	cmp	r3, #2
 8032802:	d00b      	beq.n	803281c <LmhpFragmentationProcess+0x30>
}
 8032804:	bd38      	pop	{r3, r4, r5, pc}
            TimerSetValue( &FragmentTxDelayTimer, TxDelayTime );
 8032806:	6921      	ldr	r1, [r4, #16]
 8032808:	f104 0014 	add.w	r0, r4, #20
 803280c:	f008 fdea 	bl	803b3e4 <UTIL_TIMER_SetPeriod>
            TimerStart( &FragmentTxDelayTimer );
 8032810:	f104 0014 	add.w	r0, r4, #20
}
 8032814:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
            TimerStart( &FragmentTxDelayTimer );
 8032818:	f008 bdaa 	b.w	803b370 <UTIL_TIMER_Start>
            if (LORAMAC_HANDLER_SUCCESS == LmhpFragmentationPackage.OnSendRequest( &DelayedReplyAppData,
 803281c:	4b06      	ldr	r3, [pc, #24]	; (8032838 <LmhpFragmentationProcess+0x4c>)
 803281e:	4807      	ldr	r0, [pc, #28]	; (803283c <LmhpFragmentationProcess+0x50>)
 8032820:	6a9d      	ldr	r5, [r3, #40]	; 0x28
 8032822:	2200      	movs	r2, #0
 8032824:	2301      	movs	r3, #1
 8032826:	4611      	mov	r1, r2
 8032828:	47a8      	blx	r5
 803282a:	2800      	cmp	r0, #0
 803282c:	d1ea      	bne.n	8032804 <LmhpFragmentationProcess+0x18>
                LmhpFragmentationState.TxDelayState = FRAGMENTATION_TX_DELAY_STATE_IDLE;
 803282e:	70a0      	strb	r0, [r4, #2]
}
 8032830:	e7e8      	b.n	8032804 <LmhpFragmentationProcess+0x18>
 8032832:	bf00      	nop
 8032834:	200049ac 	.word	0x200049ac
 8032838:	2000352c 	.word	0x2000352c
 803283c:	20006308 	.word	0x20006308

08032840 <LmhpFragmentationPackageFactory>:
}
 8032840:	4800      	ldr	r0, [pc, #0]	; (8032844 <LmhpFragmentationPackageFactory+0x4>)
 8032842:	4770      	bx	lr
 8032844:	2000352c 	.word	0x2000352c

08032848 <LmhpFragmentationGetPackageVersion>:
}
 8032848:	2001      	movs	r0, #1
 803284a:	4770      	bx	lr

0803284c <LmhpPackagesRegistrationInit>:
/* Private variables ---------------------------------------------------------*/

/* Exported functions ---------------------------------------------------------*/
LmHandlerErrorStatus_t LmhpPackagesRegistrationInit(void)
{
  if (LmHandlerPackageRegister(PACKAGE_ID_CLOCK_SYNC, NULL) != LORAMAC_HANDLER_SUCCESS)
 803284c:	2100      	movs	r1, #0
{
 803284e:	b508      	push	{r3, lr}
  if (LmHandlerPackageRegister(PACKAGE_ID_CLOCK_SYNC, NULL) != LORAMAC_HANDLER_SUCCESS)
 8032850:	2001      	movs	r0, #1
 8032852:	f7ff f8d1 	bl	80319f8 <LmHandlerPackageRegister>
 8032856:	4601      	mov	r1, r0
 8032858:	b110      	cbz	r0, 8032860 <LmhpPackagesRegistrationInit+0x14>
  {
    return LORAMAC_HANDLER_ERROR;
 803285a:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return LORAMAC_HANDLER_ERROR;
  }

  return LORAMAC_HANDLER_SUCCESS;
}
 803285e:	bd08      	pop	{r3, pc}
  else if (LmHandlerPackageRegister(PACKAGE_ID_REMOTE_MCAST_SETUP, NULL) != LORAMAC_HANDLER_SUCCESS)
 8032860:	2002      	movs	r0, #2
 8032862:	f7ff f8c9 	bl	80319f8 <LmHandlerPackageRegister>
 8032866:	2800      	cmp	r0, #0
 8032868:	d1f7      	bne.n	803285a <LmhpPackagesRegistrationInit+0xe>
  else if (LmHandlerPackageRegister(PACKAGE_ID_FRAGMENTATION, (LmhpFragmentationParams_t *)&FRAG_DECODER_IF_FragmentationParams) != LORAMAC_HANDLER_SUCCESS)
 803286a:	4907      	ldr	r1, [pc, #28]	; (8032888 <LmhpPackagesRegistrationInit+0x3c>)
 803286c:	2003      	movs	r0, #3
 803286e:	f7ff f8c3 	bl	80319f8 <LmHandlerPackageRegister>
 8032872:	4601      	mov	r1, r0
 8032874:	2800      	cmp	r0, #0
 8032876:	d1f0      	bne.n	803285a <LmhpPackagesRegistrationInit+0xe>
  else if (LmHandlerPackageRegister(PACKAGE_ID_FIRMWARE_MANAGEMENT, NULL) != LORAMAC_HANDLER_SUCCESS)
 8032878:	2004      	movs	r0, #4
 803287a:	f7ff f8bd 	bl	80319f8 <LmHandlerPackageRegister>
 803287e:	3800      	subs	r0, #0
 8032880:	bf18      	it	ne
 8032882:	2001      	movne	r0, #1
 8032884:	4240      	negs	r0, r0
 8032886:	e7ea      	b.n	803285e <LmhpPackagesRegistrationInit+0x12>
 8032888:	0803b8f0 	.word	0x0803b8f0

0803288c <LmhpPackagesRegister>:

LmHandlerErrorStatus_t LmhpPackagesRegister(uint8_t id, LmhPackage_t **package)
{
 803288c:	b510      	push	{r4, lr}
  if (package == NULL)
 803288e:	460c      	mov	r4, r1
 8032890:	b1a1      	cbz	r1, 80328bc <LmhpPackagesRegister+0x30>
  {
    return LORAMAC_HANDLER_ERROR;
  }
  switch (id)
 8032892:	3801      	subs	r0, #1
 8032894:	2803      	cmp	r0, #3
 8032896:	d806      	bhi.n	80328a6 <LmhpPackagesRegister+0x1a>
 8032898:	e8df f000 	tbb	[pc, r0]
 803289c:	0d0a0702 	.word	0x0d0a0702
  {
    case PACKAGE_ID_CLOCK_SYNC:
    {
      *package = LmhpClockSyncPackageFactory();
 80328a0:	f7ff fa50 	bl	8031d44 <LmhpClockSyncPackageFactory>
      *package = LmhpFragmentationPackageFactory();
      break;
    }
    case PACKAGE_ID_FIRMWARE_MANAGEMENT:
    {
      *package = LmhpFirmwareManagementPackageFactory();
 80328a4:	6020      	str	r0, [r4, #0]
  if (package == NULL)
 80328a6:	2000      	movs	r0, #0
 80328a8:	e00a      	b.n	80328c0 <LmhpPackagesRegister+0x34>
      *package = LmhpRemoteMcastSetupPackageFactory();
 80328aa:	f000 fb45 	bl	8032f38 <LmhpRemoteMcastSetupPackageFactory>
 80328ae:	e7f9      	b.n	80328a4 <LmhpPackagesRegister+0x18>
      *package = LmhpFragmentationPackageFactory();
 80328b0:	f7ff ffc6 	bl	8032840 <LmhpFragmentationPackageFactory>
 80328b4:	e7f6      	b.n	80328a4 <LmhpPackagesRegister+0x18>
      *package = LmhpFirmwareManagementPackageFactory();
 80328b6:	f7ff fd6f 	bl	8032398 <LmhpFirmwareManagementPackageFactory>
 80328ba:	e7f3      	b.n	80328a4 <LmhpPackagesRegister+0x18>
    return LORAMAC_HANDLER_ERROR;
 80328bc:	f04f 30ff 	mov.w	r0, #4294967295
      break;
    }
  }

  return LORAMAC_HANDLER_SUCCESS;
}
 80328c0:	bd10      	pop	{r4, pc}
	...

080328c4 <LmhpRemoteMcastSetupIsInitialized>:
}

static bool LmhpRemoteMcastSetupIsInitialized( void )
{
    return LmhpRemoteMcastSetupState.Initialized;
}
 80328c4:	4b01      	ldr	r3, [pc, #4]	; (80328cc <LmhpRemoteMcastSetupIsInitialized+0x8>)
 80328c6:	7818      	ldrb	r0, [r3, #0]
 80328c8:	4770      	bx	lr
 80328ca:	bf00      	nop
 80328cc:	20004a38 	.word	0x20004a38

080328d0 <LmhpRemoteMcastSetupIsRunning>:

static bool LmhpRemoteMcastSetupIsRunning( void )
{
    if( LmhpRemoteMcastSetupState.Initialized == false )
 80328d0:	4b02      	ldr	r3, [pc, #8]	; (80328dc <LmhpRemoteMcastSetupIsRunning+0xc>)
 80328d2:	7818      	ldrb	r0, [r3, #0]
 80328d4:	b100      	cbz	r0, 80328d8 <LmhpRemoteMcastSetupIsRunning+0x8>
    {
        return false;
    }

    return LmhpRemoteMcastSetupState.IsRunning;
 80328d6:	7858      	ldrb	r0, [r3, #1]
}
 80328d8:	4770      	bx	lr
 80328da:	bf00      	nop
 80328dc:	20004a38 	.word	0x20004a38

080328e0 <LmhpRemoteMcastSetupInit>:
{
 80328e0:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80328e2:	4c10      	ldr	r4, [pc, #64]	; (8032924 <LmhpRemoteMcastSetupInit+0x44>)
    if( dataBuffer != NULL )
 80328e4:	b1e1      	cbz	r1, 8032920 <LmhpRemoteMcastSetupInit+0x40>
        LmhpRemoteMcastSetupState.Initialized = true;
 80328e6:	4620      	mov	r0, r4
        TimerInit( &SessionStartTimer, OnSessionStartTimer );
 80328e8:	2500      	movs	r5, #0
        LmhpRemoteMcastSetupState.Initialized = true;
 80328ea:	f240 1301 	movw	r3, #257	; 0x101
 80328ee:	f820 3b08 	strh.w	r3, [r0], #8
        LmhpRemoteMcastSetupState.DataBuffer = dataBuffer;
 80328f2:	6061      	str	r1, [r4, #4]
        TimerInit( &SessionStartTimer, OnSessionStartTimer );
 80328f4:	4b0c      	ldr	r3, [pc, #48]	; (8032928 <LmhpRemoteMcastSetupInit+0x48>)
        LmhpRemoteMcastSetupState.DataBufferMaxSize = dataBufferMaxSize;
 80328f6:	70e2      	strb	r2, [r4, #3]
        TimerInit( &SessionStartTimer, OnSessionStartTimer );
 80328f8:	f04f 31ff 	mov.w	r1, #4294967295
 80328fc:	462a      	mov	r2, r5
 80328fe:	9500      	str	r5, [sp, #0]
 8032900:	f008 fc88 	bl	803b214 <UTIL_TIMER_Create>
        TimerInit( &SessionStopTimer, OnSessionStopTimer );
 8032904:	4b09      	ldr	r3, [pc, #36]	; (803292c <LmhpRemoteMcastSetupInit+0x4c>)
 8032906:	9500      	str	r5, [sp, #0]
 8032908:	462a      	mov	r2, r5
 803290a:	f04f 31ff 	mov.w	r1, #4294967295
 803290e:	f104 0020 	add.w	r0, r4, #32
 8032912:	f008 fc7f 	bl	803b214 <UTIL_TIMER_Create>
        McSessionData[id].McGroupData.McGroupEnabled = false;
 8032916:	2300      	movs	r3, #0
 8032918:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
}
 803291c:	b003      	add	sp, #12
 803291e:	bd30      	pop	{r4, r5, pc}
        LmhpRemoteMcastSetupState.Initialized = false;
 8032920:	8021      	strh	r1, [r4, #0]
 8032922:	e7f8      	b.n	8032916 <LmhpRemoteMcastSetupInit+0x36>
 8032924:	20004a38 	.word	0x20004a38
 8032928:	08032955 	.word	0x08032955
 803292c:	08032931 	.word	0x08032931

08032930 <OnSessionStopTimer>:
    LmhpRemoteMcastSetupState.SessionState = REMOTE_MCAST_SETUP_SESSION_STATE_START;
    LmhpRemoteMcastSetupPackage.OnPackageProcessEvent();
}

static void OnSessionStopTimer( void *context )
{
 8032930:	b510      	push	{r4, lr}
    TimerStop( &SessionStopTimer );
 8032932:	4c06      	ldr	r4, [pc, #24]	; (803294c <OnSessionStopTimer+0x1c>)
 8032934:	f104 0020 	add.w	r0, r4, #32
 8032938:	f008 fcca 	bl	803b2d0 <UTIL_TIMER_Stop>
    LmhpRemoteMcastSetupState.SessionState = REMOTE_MCAST_SETUP_SESSION_STATE_STOP;
 803293c:	2302      	movs	r3, #2
 803293e:	70a3      	strb	r3, [r4, #2]
    LmhpRemoteMcastSetupPackage.OnPackageProcessEvent();
 8032940:	4b03      	ldr	r3, [pc, #12]	; (8032950 <OnSessionStopTimer+0x20>)
}
 8032942:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    LmhpRemoteMcastSetupPackage.OnPackageProcessEvent();
 8032946:	695b      	ldr	r3, [r3, #20]
 8032948:	4718      	bx	r3
 803294a:	bf00      	nop
 803294c:	20004a38 	.word	0x20004a38
 8032950:	20003560 	.word	0x20003560

08032954 <OnSessionStartTimer>:
{
 8032954:	b510      	push	{r4, lr}
    TimerStop( &SessionStartTimer );
 8032956:	4c06      	ldr	r4, [pc, #24]	; (8032970 <OnSessionStartTimer+0x1c>)
 8032958:	f104 0008 	add.w	r0, r4, #8
 803295c:	f008 fcb8 	bl	803b2d0 <UTIL_TIMER_Stop>
    LmhpRemoteMcastSetupState.SessionState = REMOTE_MCAST_SETUP_SESSION_STATE_START;
 8032960:	2301      	movs	r3, #1
 8032962:	70a3      	strb	r3, [r4, #2]
    LmhpRemoteMcastSetupPackage.OnPackageProcessEvent();
 8032964:	4b03      	ldr	r3, [pc, #12]	; (8032974 <OnSessionStartTimer+0x20>)
}
 8032966:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    LmhpRemoteMcastSetupPackage.OnPackageProcessEvent();
 803296a:	695b      	ldr	r3, [r3, #20]
 803296c:	4718      	bx	r3
 803296e:	bf00      	nop
 8032970:	20004a38 	.word	0x20004a38
 8032974:	20003560 	.word	0x20003560

08032978 <LmhpRemoteMcastSetupOnMcpsIndication>:
{
 8032978:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if( mcpsIndication->Port != REMOTE_MCAST_SETUP_PORT )
 803297c:	78c3      	ldrb	r3, [r0, #3]
 803297e:	2bc8      	cmp	r3, #200	; 0xc8
{
 8032980:	b091      	sub	sp, #68	; 0x44
 8032982:	4682      	mov	sl, r0
    if( mcpsIndication->Port != REMOTE_MCAST_SETUP_PORT )
 8032984:	f000 8293 	beq.w	8032eae <LmhpRemoteMcastSetupOnMcpsIndication+0x536>
}
 8032988:	b011      	add	sp, #68	; 0x44
 803298a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        switch( mcpsIndication->Buffer[cmdIndex++] )
 803298e:	f8da 0008 	ldr.w	r0, [sl, #8]
 8032992:	5c81      	ldrb	r1, [r0, r2]
 8032994:	1c57      	adds	r7, r2, #1
 8032996:	b2ff      	uxtb	r7, r7
 8032998:	2904      	cmp	r1, #4
 803299a:	d813      	bhi.n	80329c4 <LmhpRemoteMcastSetupOnMcpsIndication+0x4c>
 803299c:	e8df f011 	tbh	[pc, r1, lsl #1]
 80329a0:	009c0005 	.word	0x009c0005
 80329a4:	01a800dd 	.word	0x01a800dd
 80329a8:	01d8      	.short	0x01d8
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_PKG_VERSION_ANS;
 80329aa:	6872      	ldr	r2, [r6, #4]
 80329ac:	2300      	movs	r3, #0
 80329ae:	1c61      	adds	r1, r4, #1
 80329b0:	5513      	strb	r3, [r2, r4]
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_ID;
 80329b2:	b2c9      	uxtb	r1, r1
 80329b4:	1ca3      	adds	r3, r4, #2
 80329b6:	b2db      	uxtb	r3, r3
 80329b8:	2002      	movs	r0, #2
 80329ba:	5450      	strb	r0, [r2, r1]
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_VERSION;
 80329bc:	2101      	movs	r1, #1
 80329be:	3403      	adds	r4, #3
 80329c0:	54d1      	strb	r1, [r2, r3]
 80329c2:	b2e4      	uxtb	r4, r4
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 80329c4:	463a      	mov	r2, r7
    while( cmdIndex < mcpsIndication->BufferSize )
 80329c6:	f89a 300c 	ldrb.w	r3, [sl, #12]
 80329ca:	4293      	cmp	r3, r2
 80329cc:	d8df      	bhi.n	803298e <LmhpRemoteMcastSetupOnMcpsIndication+0x16>
    if( dataBufferIndex != 0 )
 80329ce:	2c00      	cmp	r4, #0
 80329d0:	d0da      	beq.n	8032988 <LmhpRemoteMcastSetupOnMcpsIndication+0x10>
        LmHandlerAppData_t appData =
 80329d2:	f88d 4021 	strb.w	r4, [sp, #33]	; 0x21
            .Buffer = LmhpRemoteMcastSetupState.DataBuffer,
 80329d6:	4cb9      	ldr	r4, [pc, #740]	; (8032cbc <LmhpRemoteMcastSetupOnMcpsIndication+0x344>)
        LmHandlerAppData_t appData =
 80329d8:	23c8      	movs	r3, #200	; 0xc8
 80329da:	f88d 3020 	strb.w	r3, [sp, #32]
        LmHandlerGetDutyCycleEnable( &current_dutycycle );
 80329de:	f10d 001f 	add.w	r0, sp, #31
        LmHandlerAppData_t appData =
 80329e2:	6863      	ldr	r3, [r4, #4]
 80329e4:	9309      	str	r3, [sp, #36]	; 0x24
        LmHandlerGetDutyCycleEnable( &current_dutycycle );
 80329e6:	f7ff f869 	bl	8031abc <LmHandlerGetDutyCycleEnable>
        LmHandlerSetDutyCycleEnable( false );
 80329ea:	2000      	movs	r0, #0
 80329ec:	f7ff f872 	bl	8031ad4 <LmHandlerSetDutyCycleEnable>
        LmhpRemoteMcastSetupPackage.OnSendRequest( &appData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true );
 80329f0:	4bb3      	ldr	r3, [pc, #716]	; (8032cc0 <LmhpRemoteMcastSetupOnMcpsIndication+0x348>)
 80329f2:	2200      	movs	r2, #0
 80329f4:	6a9e      	ldr	r6, [r3, #40]	; 0x28
 80329f6:	4611      	mov	r1, r2
 80329f8:	2301      	movs	r3, #1
 80329fa:	a808      	add	r0, sp, #32
 80329fc:	47b0      	blx	r6
        LmHandlerSetDutyCycleEnable( current_dutycycle );
 80329fe:	f89d 001f 	ldrb.w	r0, [sp, #31]
 8032a02:	f7ff f867 	bl	8031ad4 <LmHandlerSetDutyCycleEnable>
        if (id != 0xFF && id < LORAMAC_MAX_MC_CTX)
 8032a06:	2d00      	cmp	r5, #0
 8032a08:	d1be      	bne.n	8032988 <LmhpRemoteMcastSetupOnMcpsIndication+0x10>
            MW_LOG(TS_OFF, VLEVEL_M, "ID          : %d\r\n", McSessionData[id].McGroupData.IdHeader.Fields.McGroupId);
 8032a0a:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
                MW_LOG(TS_OFF, VLEVEL_M, "-%02X",  McSessionData[id].McGroupData.McKeyEncrypted[i]);
 8032a0e:	4fad      	ldr	r7, [pc, #692]	; (8032cc4 <LmhpRemoteMcastSetupOnMcpsIndication+0x34c>)
            MW_LOG(TS_OFF, VLEVEL_M, "ID          : %d\r\n", McSessionData[id].McGroupData.IdHeader.Fields.McGroupId);
 8032a10:	f003 0303 	and.w	r3, r3, #3
 8032a14:	462a      	mov	r2, r5
 8032a16:	4629      	mov	r1, r5
 8032a18:	9300      	str	r3, [sp, #0]
 8032a1a:	2002      	movs	r0, #2
 8032a1c:	4baa      	ldr	r3, [pc, #680]	; (8032cc8 <LmhpRemoteMcastSetupOnMcpsIndication+0x350>)
 8032a1e:	f008 f935 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
            MW_LOG(TS_OFF, VLEVEL_M, "McAddr      : %08X\r\n", McSessionData[id].McGroupData.McAddr);
 8032a22:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8032a24:	9300      	str	r3, [sp, #0]
 8032a26:	462a      	mov	r2, r5
 8032a28:	4629      	mov	r1, r5
 8032a2a:	4ba8      	ldr	r3, [pc, #672]	; (8032ccc <LmhpRemoteMcastSetupOnMcpsIndication+0x354>)
 8032a2c:	2002      	movs	r0, #2
 8032a2e:	f008 f92d 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
            MW_LOG(TS_OFF, VLEVEL_M, "McKey       : %02X", McSessionData[id].McGroupData.McKeyEncrypted[0]);
 8032a32:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8032a36:	9300      	str	r3, [sp, #0]
 8032a38:	462a      	mov	r2, r5
 8032a3a:	4629      	mov	r1, r5
 8032a3c:	4ba4      	ldr	r3, [pc, #656]	; (8032cd0 <LmhpRemoteMcastSetupOnMcpsIndication+0x358>)
 8032a3e:	2002      	movs	r0, #2
 8032a40:	f008 f924 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
            for ( int i = 1; i < 16; i++ )
 8032a44:	f104 0641 	add.w	r6, r4, #65	; 0x41
 8032a48:	2501      	movs	r5, #1
                MW_LOG(TS_OFF, VLEVEL_M, "-%02X",  McSessionData[id].McGroupData.McKeyEncrypted[i]);
 8032a4a:	f816 3b01 	ldrb.w	r3, [r6], #1
 8032a4e:	9300      	str	r3, [sp, #0]
 8032a50:	2200      	movs	r2, #0
 8032a52:	463b      	mov	r3, r7
 8032a54:	4611      	mov	r1, r2
 8032a56:	2002      	movs	r0, #2
            for ( int i = 1; i < 16; i++ )
 8032a58:	3501      	adds	r5, #1
                MW_LOG(TS_OFF, VLEVEL_M, "-%02X",  McSessionData[id].McGroupData.McKeyEncrypted[i]);
 8032a5a:	f008 f917 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
            for ( int i = 1; i < 16; i++ )
 8032a5e:	2d10      	cmp	r5, #16
 8032a60:	d1f3      	bne.n	8032a4a <LmhpRemoteMcastSetupOnMcpsIndication+0xd2>
            MW_LOG(TS_OFF, VLEVEL_M, "\r\n");
 8032a62:	2200      	movs	r2, #0
 8032a64:	4611      	mov	r1, r2
 8032a66:	4b9b      	ldr	r3, [pc, #620]	; (8032cd4 <LmhpRemoteMcastSetupOnMcpsIndication+0x35c>)
 8032a68:	2002      	movs	r0, #2
 8032a6a:	f008 f90f 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
            MW_LOG(TS_OFF, VLEVEL_M, "McFCountMin : %u\r\n",  McSessionData[id].McGroupData.McFCountMin);
 8032a6e:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8032a70:	9300      	str	r3, [sp, #0]
 8032a72:	2200      	movs	r2, #0
 8032a74:	4611      	mov	r1, r2
 8032a76:	4b98      	ldr	r3, [pc, #608]	; (8032cd8 <LmhpRemoteMcastSetupOnMcpsIndication+0x360>)
 8032a78:	2002      	movs	r0, #2
 8032a7a:	f008 f907 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
            MW_LOG(TS_OFF, VLEVEL_M, "McFCountMax : %u\r\n",  McSessionData[id].McGroupData.McFCountMax);
 8032a7e:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8032a80:	9300      	str	r3, [sp, #0]
 8032a82:	2200      	movs	r2, #0
 8032a84:	4611      	mov	r1, r2
 8032a86:	4b95      	ldr	r3, [pc, #596]	; (8032cdc <LmhpRemoteMcastSetupOnMcpsIndication+0x364>)
 8032a88:	2002      	movs	r0, #2
 8032a8a:	f008 f8ff 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
            MW_LOG(TS_OFF, VLEVEL_M, "SessionTime : %u\r\n",  McSessionData[id].SessionTime);
 8032a8e:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8032a90:	9300      	str	r3, [sp, #0]
 8032a92:	2200      	movs	r2, #0
 8032a94:	4611      	mov	r1, r2
 8032a96:	4b92      	ldr	r3, [pc, #584]	; (8032ce0 <LmhpRemoteMcastSetupOnMcpsIndication+0x368>)
 8032a98:	2002      	movs	r0, #2
 8032a9a:	f008 f8f7 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
            MW_LOG(TS_OFF, VLEVEL_M, "SessionTimeT: %d s\r\n", (1 << McSessionData[id].SessionTimeout));
 8032a9e:	f894 2060 	ldrb.w	r2, [r4, #96]	; 0x60
 8032aa2:	2301      	movs	r3, #1
 8032aa4:	4093      	lsls	r3, r2
 8032aa6:	2200      	movs	r2, #0
 8032aa8:	9300      	str	r3, [sp, #0]
 8032aaa:	4611      	mov	r1, r2
 8032aac:	4b8d      	ldr	r3, [pc, #564]	; (8032ce4 <LmhpRemoteMcastSetupOnMcpsIndication+0x36c>)
 8032aae:	2002      	movs	r0, #2
 8032ab0:	f008 f8ec 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
            MW_LOG(TS_OFF, VLEVEL_M, "Rx Freq     : %u\r\n", McSessionData[id].RxParams.ClassC.Frequency);
 8032ab4:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8032ab6:	9300      	str	r3, [sp, #0]
 8032ab8:	2200      	movs	r2, #0
 8032aba:	4611      	mov	r1, r2
 8032abc:	4b8a      	ldr	r3, [pc, #552]	; (8032ce8 <LmhpRemoteMcastSetupOnMcpsIndication+0x370>)
 8032abe:	2002      	movs	r0, #2
 8032ac0:	f008 f8e4 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
            MW_LOG(TS_OFF, VLEVEL_M, "Rx DR       : DR_%d\r\n", McSessionData[id].RxParams.ClassC.Datarate);
 8032ac4:	f994 3068 	ldrsb.w	r3, [r4, #104]	; 0x68
 8032ac8:	9300      	str	r3, [sp, #0]
 8032aca:	2200      	movs	r2, #0
 8032acc:	4b87      	ldr	r3, [pc, #540]	; (8032cec <LmhpRemoteMcastSetupOnMcpsIndication+0x374>)
 8032ace:	4611      	mov	r1, r2
 8032ad0:	2002      	movs	r0, #2
 8032ad2:	f008 f8db 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
 8032ad6:	e757      	b.n	8032988 <LmhpRemoteMcastSetupOnMcpsIndication+0x10>
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_STATUS_ANS;
 8032ad8:	6875      	ldr	r5, [r6, #4]
                uint8_t reqGroupMask = mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8032ada:	5dc7      	ldrb	r7, [r0, r7]
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_STATUS_ANS;
 8032adc:	2301      	movs	r3, #1
 8032ade:	552b      	strb	r3, [r5, r4]
                uint8_t reqGroupMask = mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8032ae0:	3202      	adds	r2, #2
                for (id = 0; id < LORAMAC_MAX_MC_CTX; id++)
 8032ae2:	2300      	movs	r3, #0
                dataBufferIndex++;
 8032ae4:	3402      	adds	r4, #2
                uint8_t reqGroupMask = mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8032ae6:	b2d2      	uxtb	r2, r2
                dataBufferIndex++;
 8032ae8:	b2e4      	uxtb	r4, r4
                uint8_t AnsGroupMask = 0x00;
 8032aea:	469c      	mov	ip, r3
                for (id = 0; id < LORAMAC_MAX_MC_CTX; id++)
 8032aec:	4618      	mov	r0, r3
 8032aee:	f007 0701 	and.w	r7, r7, #1
                    if( McSessionData[id].McGroupData.McGroupEnabled )
 8032af2:	f896 e038 	ldrb.w	lr, [r6, #56]	; 0x38
                for (id = 0; id < LORAMAC_MAX_MC_CTX; id++)
 8032af6:	b140      	cbz	r0, 8032b0a <LmhpRemoteMcastSetupOnMcpsIndication+0x192>
                LmhpRemoteMcastSetupState.DataBuffer[1] = (nbAvailableGroups & 0x07) << 4 | (AnsGroupMask & 0x0F);
 8032af8:	011b      	lsls	r3, r3, #4
 8032afa:	f003 0370 	and.w	r3, r3, #112	; 0x70
 8032afe:	ea43 030c 	orr.w	r3, r3, ip
 8032b02:	706b      	strb	r3, [r5, #1]
                uint8_t reqGroupMask = mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8032b04:	4617      	mov	r7, r2
                break;
 8032b06:	460d      	mov	r5, r1
 8032b08:	e75c      	b.n	80329c4 <LmhpRemoteMcastSetupOnMcpsIndication+0x4c>
                    if( McSessionData[id].McGroupData.McGroupEnabled )
 8032b0a:	f1be 0f00 	cmp.w	lr, #0
 8032b0e:	d0f3      	beq.n	8032af8 <LmhpRemoteMcastSetupOnMcpsIndication+0x180>
                        if( ( reqGroupMask & ( 1 << id ) ) != 0 )
 8032b10:	b307      	cbz	r7, 8032b54 <LmhpRemoteMcastSetupOnMcpsIndication+0x1dc>
                            LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = id;
 8032b12:	5528      	strb	r0, [r5, r4]
 8032b14:	f104 0c01 	add.w	ip, r4, #1
                            LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (McSessionData[id].McGroupData.McAddr >> 0) & 0xFF;
 8032b18:	fa5f fc8c 	uxtb.w	ip, ip
 8032b1c:	6bf0      	ldr	r0, [r6, #60]	; 0x3c
 8032b1e:	f805 000c 	strb.w	r0, [r5, ip]
 8032b22:	f104 0c02 	add.w	ip, r4, #2
                            LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (McSessionData[id].McGroupData.McAddr >> 8) & 0xFF;
 8032b26:	6bf0      	ldr	r0, [r6, #60]	; 0x3c
 8032b28:	fa5f fc8c 	uxtb.w	ip, ip
 8032b2c:	0a00      	lsrs	r0, r0, #8
 8032b2e:	f805 000c 	strb.w	r0, [r5, ip]
 8032b32:	f104 0c03 	add.w	ip, r4, #3
                            LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (McSessionData[id].McGroupData.McAddr >> 16) & 0xFF;
 8032b36:	fa5f fc8c 	uxtb.w	ip, ip
 8032b3a:	f8b6 e03e 	ldrh.w	lr, [r6, #62]	; 0x3e
 8032b3e:	f805 e00c 	strb.w	lr, [r5, ip]
 8032b42:	1d20      	adds	r0, r4, #4
 8032b44:	b2c0      	uxtb	r0, r0
                            LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (McSessionData[id].McGroupData.McAddr >> 24) & 0xFF;
 8032b46:	f896 c03f 	ldrb.w	ip, [r6, #63]	; 0x3f
 8032b4a:	f805 c000 	strb.w	ip, [r5, r0]
 8032b4e:	3405      	adds	r4, #5
 8032b50:	b2e4      	uxtb	r4, r4
                            AnsGroupMask |= (1 << id);
 8032b52:	46bc      	mov	ip, r7
 8032b54:	3301      	adds	r3, #1
 8032b56:	4608      	mov	r0, r1
 8032b58:	e7cb      	b.n	8032af2 <LmhpRemoteMcastSetupOnMcpsIndication+0x17a>
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032b5a:	5dc5      	ldrb	r5, [r0, r7]
                McSessionData[id].McGroupData.IdHeader.Value = id;
 8032b5c:	f04f 0c34 	mov.w	ip, #52	; 0x34
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032b60:	f005 0503 	and.w	r5, r5, #3
                McSessionData[id].McGroupData.IdHeader.Value = id;
 8032b64:	fb0c 6705 	mla	r7, ip, r5, r6
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032b68:	1c93      	adds	r3, r2, #2
                McSessionData[id].McGroupData.McAddr =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032b6a:	b2db      	uxtb	r3, r3
                McSessionData[id].McGroupData.IdHeader.Value = id;
 8032b6c:	f887 5039 	strb.w	r5, [r7, #57]	; 0x39
                McSessionData[id].McGroupData.McAddr =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032b70:	5cc1      	ldrb	r1, [r0, r3]
 8032b72:	63f9      	str	r1, [r7, #60]	; 0x3c
 8032b74:	1cd3      	adds	r3, r2, #3
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032b76:	b2db      	uxtb	r3, r3
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032b78:	f102 0e05 	add.w	lr, r2, #5
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032b7c:	5cc3      	ldrb	r3, [r0, r3]
 8032b7e:	eb01 2103 	add.w	r1, r1, r3, lsl #8
 8032b82:	1d13      	adds	r3, r2, #4
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032b84:	b2db      	uxtb	r3, r3
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032b86:	63f9      	str	r1, [r7, #60]	; 0x3c
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032b88:	5cc3      	ldrb	r3, [r0, r3]
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032b8a:	fa5f fe8e 	uxtb.w	lr, lr
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032b8e:	eb01 4103 	add.w	r1, r1, r3, lsl #16
 8032b92:	63f9      	str	r1, [r7, #60]	; 0x3c
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032b94:	f810 e00e 	ldrb.w	lr, [r0, lr]
 8032b98:	fb0c bc05 	mla	ip, ip, r5, fp
 8032b9c:	eb01 610e 	add.w	r1, r1, lr, lsl #24
 8032ba0:	63f9      	str	r1, [r7, #60]	; 0x3c
 8032ba2:	9103      	str	r1, [sp, #12]
 8032ba4:	f10c 0108 	add.w	r1, ip, #8
 8032ba8:	1d93      	adds	r3, r2, #6
 8032baa:	9104      	str	r1, [sp, #16]
 8032bac:	460f      	mov	r7, r1
 8032bae:	f102 0116 	add.w	r1, r2, #22
 8032bb2:	b2db      	uxtb	r3, r3
                for( int8_t i = 0; i < 16; i++ )
 8032bb4:	fa5f fe81 	uxtb.w	lr, r1
                    McSessionData[id].McGroupData.McKeyEncrypted[i] = mcpsIndication->Buffer[cmdIndex++];
 8032bb8:	469c      	mov	ip, r3
 8032bba:	3301      	adds	r3, #1
 8032bbc:	b2db      	uxtb	r3, r3
 8032bbe:	f810 c00c 	ldrb.w	ip, [r0, ip]
 8032bc2:	f807 cb01 	strb.w	ip, [r7], #1
                for( int8_t i = 0; i < 16; i++ )
 8032bc6:	4573      	cmp	r3, lr
 8032bc8:	d1f6      	bne.n	8032bb8 <LmhpRemoteMcastSetupOnMcpsIndication+0x240>
                McSessionData[id].McGroupData.McFCountMin =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032bca:	b2c9      	uxtb	r1, r1
 8032bcc:	f04f 0834 	mov.w	r8, #52	; 0x34
 8032bd0:	5c43      	ldrb	r3, [r0, r1]
 8032bd2:	fb08 6805 	mla	r8, r8, r5, r6
 8032bd6:	f102 0117 	add.w	r1, r2, #23
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032bda:	b2c9      	uxtb	r1, r1
                McSessionData[id].McGroupData.McFCountMin =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032bdc:	f8c8 3050 	str.w	r3, [r8, #80]	; 0x50
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032be0:	5c41      	ldrb	r1, [r0, r1]
 8032be2:	eb03 2301 	add.w	r3, r3, r1, lsl #8
 8032be6:	f102 0118 	add.w	r1, r2, #24
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032bea:	b2c9      	uxtb	r1, r1
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032bec:	f8c8 3050 	str.w	r3, [r8, #80]	; 0x50
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032bf0:	5c41      	ldrb	r1, [r0, r1]
 8032bf2:	eb03 4301 	add.w	r3, r3, r1, lsl #16
 8032bf6:	f102 0119 	add.w	r1, r2, #25
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032bfa:	b2c9      	uxtb	r1, r1
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032bfc:	f8c8 3050 	str.w	r3, [r8, #80]	; 0x50
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032c00:	5c41      	ldrb	r1, [r0, r1]
 8032c02:	eb03 6301 	add.w	r3, r3, r1, lsl #24
 8032c06:	f102 011a 	add.w	r1, r2, #26
                McSessionData[id].McGroupData.McFCountMax =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032c0a:	b2c9      	uxtb	r1, r1
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032c0c:	f8c8 3050 	str.w	r3, [r8, #80]	; 0x50
                McSessionData[id].McGroupData.McFCountMax =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032c10:	f102 071b 	add.w	r7, r2, #27
 8032c14:	5c41      	ldrb	r1, [r0, r1]
 8032c16:	f8c8 1054 	str.w	r1, [r8, #84]	; 0x54
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032c1a:	b2ff      	uxtb	r7, r7
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032c1c:	9305      	str	r3, [sp, #20]
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032c1e:	f810 9007 	ldrb.w	r9, [r0, r7]
 8032c22:	f102 071c 	add.w	r7, r2, #28
 8032c26:	eb01 2109 	add.w	r1, r1, r9, lsl #8
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032c2a:	b2ff      	uxtb	r7, r7
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032c2c:	f8c8 1054 	str.w	r1, [r8, #84]	; 0x54
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032c30:	f810 9007 	ldrb.w	r9, [r0, r7]
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032c34:	f102 071e 	add.w	r7, r2, #30
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032c38:	321d      	adds	r2, #29
 8032c3a:	eb01 4109 	add.w	r1, r1, r9, lsl #16
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032c3e:	b2d2      	uxtb	r2, r2
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032c40:	f8c8 1054 	str.w	r1, [r8, #84]	; 0x54
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032c44:	f810 9002 	ldrb.w	r9, [r0, r2]
 8032c48:	eb01 6909 	add.w	r9, r1, r9, lsl #24
                McChannelParams_t channel =
 8032c4c:	2214      	movs	r2, #20
 8032c4e:	2100      	movs	r1, #0
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032c50:	f8c8 9054 	str.w	r9, [r8, #84]	; 0x54
                McChannelParams_t channel =
 8032c54:	a80b      	add	r0, sp, #44	; 0x2c
 8032c56:	f008 fd5f 	bl	803b718 <memset>
 8032c5a:	f240 2201 	movw	r2, #513	; 0x201
 8032c5e:	f8ad 2020 	strh.w	r2, [sp, #32]
 8032c62:	2201      	movs	r2, #1
 8032c64:	9b03      	ldr	r3, [sp, #12]
 8032c66:	f88d 2022 	strb.w	r2, [sp, #34]	; 0x22
                    .GroupID = ( AddressIdentifier_t )McSessionData[id].McGroupData.IdHeader.Fields.McGroupId,
 8032c6a:	f898 1039 	ldrb.w	r1, [r8, #57]	; 0x39
                McChannelParams_t channel =
 8032c6e:	9309      	str	r3, [sp, #36]	; 0x24
 8032c70:	9b04      	ldr	r3, [sp, #16]
 8032c72:	930a      	str	r3, [sp, #40]	; 0x28
 8032c74:	9b05      	ldr	r3, [sp, #20]
                    .GroupID = ( AddressIdentifier_t )McSessionData[id].McGroupData.IdHeader.Fields.McGroupId,
 8032c76:	f3c1 0101 	ubfx	r1, r1, #0, #2
                if( LoRaMacMcChannelSetup( &channel ) == LORAMAC_STATUS_OK )
 8032c7a:	a808      	add	r0, sp, #32
                McChannelParams_t channel =
 8032c7c:	e9cd 390c 	strd	r3, r9, [sp, #48]	; 0x30
 8032c80:	f88d 1023 	strb.w	r1, [sp, #35]	; 0x23
                if( LoRaMacMcChannelSetup( &channel ) == LORAMAC_STATUS_OK )
 8032c84:	f002 fa8c 	bl	80351a0 <LoRaMacMcChannelSetup>
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032c88:	b2ff      	uxtb	r7, r7
                if( LoRaMacMcChannelSetup( &channel ) == LORAMAC_STATUS_OK )
 8032c8a:	2201      	movs	r2, #1
 8032c8c:	b998      	cbnz	r0, 8032cb6 <LmhpRemoteMcastSetupOnMcpsIndication+0x33e>
                    McSessionData[id].McGroupData.McGroupEnabled = true;
 8032c8e:	f888 2038 	strb.w	r2, [r8, #56]	; 0x38
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_SETUP_ANS;
 8032c92:	6871      	ldr	r1, [r6, #4]
 8032c94:	2302      	movs	r3, #2
 8032c96:	550b      	strb	r3, [r1, r4]
 8032c98:	1c62      	adds	r2, r4, #1
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = ( idError << 2 ) | McSessionData[id].McGroupData.IdHeader.Fields.McGroupId;
 8032c9a:	441c      	add	r4, r3
 8032c9c:	2334      	movs	r3, #52	; 0x34
 8032c9e:	fb03 6305 	mla	r3, r3, r5, r6
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_SETUP_ANS;
 8032ca2:	b2d2      	uxtb	r2, r2
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = ( idError << 2 ) | McSessionData[id].McGroupData.IdHeader.Fields.McGroupId;
 8032ca4:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 8032ca8:	f3c3 0301 	ubfx	r3, r3, #0, #2
 8032cac:	ea43 0080 	orr.w	r0, r3, r0, lsl #2
 8032cb0:	5488      	strb	r0, [r1, r2]
 8032cb2:	b2e4      	uxtb	r4, r4
                break;
 8032cb4:	e686      	b.n	80329c4 <LmhpRemoteMcastSetupOnMcpsIndication+0x4c>
                uint8_t idError = 0x01; // One bit value
 8032cb6:	4610      	mov	r0, r2
 8032cb8:	e7eb      	b.n	8032c92 <LmhpRemoteMcastSetupOnMcpsIndication+0x31a>
 8032cba:	bf00      	nop
 8032cbc:	20004a38 	.word	0x20004a38
 8032cc0:	20003560 	.word	0x20003560
 8032cc4:	0803c238 	.word	0x0803c238
 8032cc8:	0803c1fd 	.word	0x0803c1fd
 8032ccc:	0803c210 	.word	0x0803c210
 8032cd0:	0803c225 	.word	0x0803c225
 8032cd4:	0803c08f 	.word	0x0803c08f
 8032cd8:	0803c23e 	.word	0x0803c23e
 8032cdc:	0803c251 	.word	0x0803c251
 8032ce0:	0803c264 	.word	0x0803c264
 8032ce4:	0803c277 	.word	0x0803c277
 8032ce8:	0803c28c 	.word	0x0803c28c
 8032cec:	0803c29f 	.word	0x0803c29f
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032cf0:	5dc5      	ldrb	r5, [r0, r7]
                McSessionData[id].McGroupData.IdHeader.Value = 0;
 8032cf2:	2034      	movs	r0, #52	; 0x34
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032cf4:	f005 0503 	and.w	r5, r5, #3
                McSessionData[id].McGroupData.IdHeader.Value = 0;
 8032cf8:	fb00 6705 	mla	r7, r0, r5, r6
 8032cfc:	f04f 0900 	mov.w	r9, #0
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032d00:	3202      	adds	r2, #2
                UTIL_MEM_set_8( McSessionData[id].McGroupData.McKeyEncrypted, 0x00, 16 );
 8032d02:	fb00 b005 	mla	r0, r0, r5, fp
                McSessionData[id].McGroupData.IdHeader.Value = 0;
 8032d06:	f887 9039 	strb.w	r9, [r7, #57]	; 0x39
                McSessionData[id].McGroupData.McAddr = 0;
 8032d0a:	f8c7 903c 	str.w	r9, [r7, #60]	; 0x3c
                UTIL_MEM_set_8( McSessionData[id].McGroupData.McKeyEncrypted, 0x00, 16 );
 8032d0e:	4649      	mov	r1, r9
 8032d10:	3008      	adds	r0, #8
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032d12:	fa5f f882 	uxtb.w	r8, r2
                UTIL_MEM_set_8( McSessionData[id].McGroupData.McKeyEncrypted, 0x00, 16 );
 8032d16:	2210      	movs	r2, #16
 8032d18:	f008 f8ca 	bl	803aeb0 <UTIL_MEM_set_8>
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_DELETE_ANS;
 8032d1c:	6873      	ldr	r3, [r6, #4]
 8032d1e:	2203      	movs	r2, #3
                McSessionData[id].McGroupData.McFCountMax = 0;
 8032d20:	e9c7 9914 	strd	r9, r9, [r7, #80]	; 0x50
                if( LoRaMacMcChannelDelete( ( AddressIdentifier_t )id ) != LORAMAC_STATUS_OK )
 8032d24:	4628      	mov	r0, r5
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_DELETE_ANS;
 8032d26:	f104 0901 	add.w	r9, r4, #1
 8032d2a:	551a      	strb	r2, [r3, r4]
 8032d2c:	fa5f f989 	uxtb.w	r9, r9
                if( LoRaMacMcChannelDelete( ( AddressIdentifier_t )id ) != LORAMAC_STATUS_OK )
 8032d30:	f002 fa84 	bl	803523c <LoRaMacMcChannelDelete>
 8032d34:	b140      	cbz	r0, 8032d48 <LmhpRemoteMcastSetupOnMcpsIndication+0x3d0>
                    status |= 0x04; // McGroupUndefined bit set
 8032d36:	f045 0304 	orr.w	r3, r5, #4
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = status;
 8032d3a:	6872      	ldr	r2, [r6, #4]
 8032d3c:	3402      	adds	r4, #2
 8032d3e:	f802 3009 	strb.w	r3, [r2, r9]
 8032d42:	b2e4      	uxtb	r4, r4
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032d44:	4647      	mov	r7, r8
                break;
 8032d46:	e63d      	b.n	80329c4 <LmhpRemoteMcastSetupOnMcpsIndication+0x4c>
                    McSessionData[id].McGroupData.McGroupEnabled = false;
 8032d48:	f887 0038 	strb.w	r0, [r7, #56]	; 0x38
                status = id;
 8032d4c:	462b      	mov	r3, r5
 8032d4e:	e7f4      	b.n	8032d3a <LmhpRemoteMcastSetupOnMcpsIndication+0x3c2>
                uint8_t status = 0x00;
 8032d50:	f04f 0300 	mov.w	r3, #0
 8032d54:	f88d 301f 	strb.w	r3, [sp, #31]
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032d58:	5dc5      	ldrb	r5, [r0, r7]
 8032d5a:	1c93      	adds	r3, r2, #2
 8032d5c:	f005 0503 	and.w	r5, r5, #3
                McSessionData[id].SessionTime =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032d60:	b2db      	uxtb	r3, r3
 8032d62:	2134      	movs	r1, #52	; 0x34
 8032d64:	fb01 6805 	mla	r8, r1, r5, r6
 8032d68:	f102 0c03 	add.w	ip, r2, #3
 8032d6c:	5cc7      	ldrb	r7, [r0, r3]
 8032d6e:	f8c8 705c 	str.w	r7, [r8, #92]	; 0x5c
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032d72:	fa5f fc8c 	uxtb.w	ip, ip
                McSessionData[id].SessionTime += UNIX_GPS_EPOCH_OFFSET;
 8032d76:	4b51      	ldr	r3, [pc, #324]	; (8032ebc <LmhpRemoteMcastSetupOnMcpsIndication+0x544>)
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032d78:	f810 c00c 	ldrb.w	ip, [r0, ip]
 8032d7c:	eb07 270c 	add.w	r7, r7, ip, lsl #8
 8032d80:	f102 0c04 	add.w	ip, r2, #4
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032d84:	fa5f fc8c 	uxtb.w	ip, ip
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032d88:	f8c8 705c 	str.w	r7, [r8, #92]	; 0x5c
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032d8c:	f810 c00c 	ldrb.w	ip, [r0, ip]
 8032d90:	eb07 470c 	add.w	r7, r7, ip, lsl #16
 8032d94:	f102 0c05 	add.w	ip, r2, #5
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032d98:	fa5f fc8c 	uxtb.w	ip, ip
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032d9c:	f8c8 705c 	str.w	r7, [r8, #92]	; 0x5c
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032da0:	f810 c00c 	ldrb.w	ip, [r0, ip]
                McSessionData[id].SessionTime += UNIX_GPS_EPOCH_OFFSET;
 8032da4:	eb03 6c0c 	add.w	ip, r3, ip, lsl #24
 8032da8:	4467      	add	r7, ip
 8032daa:	f8c8 705c 	str.w	r7, [r8, #92]	; 0x5c
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032dae:	1d97      	adds	r7, r2, #6
                McSessionData[id].SessionTimeout =  mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8032db0:	b2ff      	uxtb	r7, r7
                McSessionData[id].RxParams.ClassC.Frequency =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032db2:	f102 0c08 	add.w	ip, r2, #8
                McSessionData[id].SessionTimeout =  mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8032db6:	5dc7      	ldrb	r7, [r0, r7]
 8032db8:	f007 070f 	and.w	r7, r7, #15
 8032dbc:	f888 7060 	strb.w	r7, [r8, #96]	; 0x60
 8032dc0:	1dd7      	adds	r7, r2, #7
                McSessionData[id].RxParams.ClassC.Frequency =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032dc2:	b2ff      	uxtb	r7, r7
                McSessionData[id].RxParams.ClassC.Frequency |= ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032dc4:	fa5f fc8c 	uxtb.w	ip, ip
                McSessionData[id].RxParams.ClassC.Frequency =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032dc8:	5dc7      	ldrb	r7, [r0, r7]
 8032dca:	f8c8 7064 	str.w	r7, [r8, #100]	; 0x64
                McSessionData[id].RxParams.ClassC.Frequency |= ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032dce:	f810 c00c 	ldrb.w	ip, [r0, ip]
 8032dd2:	ea47 270c 	orr.w	r7, r7, ip, lsl #8
 8032dd6:	f102 0c09 	add.w	ip, r2, #9
                McSessionData[id].RxParams.ClassC.Frequency |= ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032dda:	fa5f fc8c 	uxtb.w	ip, ip
                McSessionData[id].RxParams.ClassC.Frequency |= ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032dde:	f8c8 7064 	str.w	r7, [r8, #100]	; 0x64
                McSessionData[id].RxParams.ClassC.Frequency |= ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032de2:	f810 c00c 	ldrb.w	ip, [r0, ip]
 8032de6:	ea47 470c 	orr.w	r7, r7, ip, lsl #16
                McSessionData[id].RxParams.ClassC.Frequency *= 100;
 8032dea:	f04f 0c64 	mov.w	ip, #100	; 0x64
 8032dee:	fb0c f707 	mul.w	r7, ip, r7
 8032df2:	f8c8 7064 	str.w	r7, [r8, #100]	; 0x64
                McSessionData[id].RxParams.ClassC.Datarate = mcpsIndication->Buffer[cmdIndex++];
 8032df6:	f102 070b 	add.w	r7, r2, #11
                McSessionData[id].RxParams.ClassC.Frequency |= ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032dfa:	320a      	adds	r2, #10
                McSessionData[id].RxParams.ClassC.Datarate = mcpsIndication->Buffer[cmdIndex++];
 8032dfc:	b2d2      	uxtb	r2, r2
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_CLASS_C_SESSION_ANS;
 8032dfe:	f104 0901 	add.w	r9, r4, #1
                McSessionData[id].RxParams.ClassC.Datarate = mcpsIndication->Buffer[cmdIndex++];
 8032e02:	5c82      	ldrb	r2, [r0, r2]
 8032e04:	f888 2068 	strb.w	r2, [r8, #104]	; 0x68
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_CLASS_C_SESSION_ANS;
 8032e08:	6872      	ldr	r2, [r6, #4]
 8032e0a:	2004      	movs	r0, #4
                if( LoRaMacMcChannelSetupRxParams( ( AddressIdentifier_t )id, &McSessionData[id].RxParams, &status ) == LORAMAC_STATUS_OK )
 8032e0c:	fb01 b105 	mla	r1, r1, r5, fp
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_CLASS_C_SESSION_ANS;
 8032e10:	5510      	strb	r0, [r2, r4]
 8032e12:	fa5f f389 	uxtb.w	r3, r9
                if( LoRaMacMcChannelSetupRxParams( ( AddressIdentifier_t )id, &McSessionData[id].RxParams, &status ) == LORAMAC_STATUS_OK )
 8032e16:	f10d 021f 	add.w	r2, sp, #31
 8032e1a:	312c      	adds	r1, #44	; 0x2c
 8032e1c:	4628      	mov	r0, r5
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_CLASS_C_SESSION_ANS;
 8032e1e:	9303      	str	r3, [sp, #12]
                if( LoRaMacMcChannelSetupRxParams( ( AddressIdentifier_t )id, &McSessionData[id].RxParams, &status ) == LORAMAC_STATUS_OK )
 8032e20:	f002 fa3a 	bl	8035298 <LoRaMacMcChannelSetupRxParams>
                McSessionData[id].RxParams.ClassC.Datarate = mcpsIndication->Buffer[cmdIndex++];
 8032e24:	b2ff      	uxtb	r7, r7
                if( LoRaMacMcChannelSetupRxParams( ( AddressIdentifier_t )id, &McSessionData[id].RxParams, &status ) == LORAMAC_STATUS_OK )
 8032e26:	4681      	mov	r9, r0
 8032e28:	2800      	cmp	r0, #0
 8032e2a:	d13d      	bne.n	8032ea8 <LmhpRemoteMcastSetupOnMcpsIndication+0x530>
                    curTime = SysTimeGet( );
 8032e2c:	a808      	add	r0, sp, #32
 8032e2e:	f008 f961 	bl	803b0f4 <SysTimeGet>
                    timeToSessionStart = McSessionData[id].SessionTime - curTime.Seconds;
 8032e32:	f8d8 105c 	ldr.w	r1, [r8, #92]	; 0x5c
 8032e36:	9b08      	ldr	r3, [sp, #32]
 8032e38:	eba1 0803 	sub.w	r8, r1, r3
                    if( timeToSessionStart > 0 )
 8032e3c:	f1b8 0f00 	cmp.w	r8, #0
 8032e40:	dd2b      	ble.n	8032e9a <LmhpRemoteMcastSetupOnMcpsIndication+0x522>
                        TimerSetValue( &SessionStartTimer, timeToSessionStart * 1000 );
 8032e42:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8032e46:	fb01 f108 	mul.w	r1, r1, r8
 8032e4a:	481d      	ldr	r0, [pc, #116]	; (8032ec0 <LmhpRemoteMcastSetupOnMcpsIndication+0x548>)
 8032e4c:	9104      	str	r1, [sp, #16]
 8032e4e:	f008 fac9 	bl	803b3e4 <UTIL_TIMER_SetPeriod>
                        TimerStart( &SessionStartTimer );
 8032e52:	481b      	ldr	r0, [pc, #108]	; (8032ec0 <LmhpRemoteMcastSetupOnMcpsIndication+0x548>)
 8032e54:	f008 fa8c 	bl	803b370 <UTIL_TIMER_Start>
                        MW_LOG(TS_OFF, VLEVEL_M, "Time2SessionStart: %d ms\r\n", timeToSessionStart * 1000);
 8032e58:	9904      	ldr	r1, [sp, #16]
 8032e5a:	9100      	str	r1, [sp, #0]
 8032e5c:	4b19      	ldr	r3, [pc, #100]	; (8032ec4 <LmhpRemoteMcastSetupOnMcpsIndication+0x54c>)
 8032e5e:	464a      	mov	r2, r9
 8032e60:	4649      	mov	r1, r9
 8032e62:	2002      	movs	r0, #2
 8032e64:	f007 ff12 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = status;
 8032e68:	6872      	ldr	r2, [r6, #4]
 8032e6a:	f89d 101f 	ldrb.w	r1, [sp, #31]
 8032e6e:	9803      	ldr	r0, [sp, #12]
 8032e70:	1ca3      	adds	r3, r4, #2
 8032e72:	5411      	strb	r1, [r2, r0]
 8032e74:	b2db      	uxtb	r3, r3
                if( status == 0x00 )
 8032e76:	b971      	cbnz	r1, 8032e96 <LmhpRemoteMcastSetupOnMcpsIndication+0x51e>
                    LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (timeToSessionStart >> 0) & 0xFF;
 8032e78:	f802 8003 	strb.w	r8, [r2, r3]
 8032e7c:	1ce3      	adds	r3, r4, #3
                    LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (timeToSessionStart >> 8) & 0xFF;
 8032e7e:	b2db      	uxtb	r3, r3
 8032e80:	ea4f 2128 	mov.w	r1, r8, asr #8
 8032e84:	54d1      	strb	r1, [r2, r3]
                    LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (timeToSessionStart >> 16) & 0xFF;
 8032e86:	1d63      	adds	r3, r4, #5
                    LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (timeToSessionStart >> 8) & 0xFF;
 8032e88:	3404      	adds	r4, #4
                    LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (timeToSessionStart >> 16) & 0xFF;
 8032e8a:	b2e4      	uxtb	r4, r4
 8032e8c:	ea4f 4828 	mov.w	r8, r8, asr #16
 8032e90:	f802 8004 	strb.w	r8, [r2, r4]
 8032e94:	b2db      	uxtb	r3, r3
                break;
 8032e96:	461c      	mov	r4, r3
 8032e98:	e594      	b.n	80329c4 <LmhpRemoteMcastSetupOnMcpsIndication+0x4c>
                        status |= 0x10;
 8032e9a:	f89d 301f 	ldrb.w	r3, [sp, #31]
 8032e9e:	f043 0310 	orr.w	r3, r3, #16
 8032ea2:	f88d 301f 	strb.w	r3, [sp, #31]
 8032ea6:	e7df      	b.n	8032e68 <LmhpRemoteMcastSetupOnMcpsIndication+0x4f0>
                int32_t timeToSessionStart = 0;
 8032ea8:	f04f 0800 	mov.w	r8, #0
 8032eac:	e7dc      	b.n	8032e68 <LmhpRemoteMcastSetupOnMcpsIndication+0x4f0>
                McSessionData[id].SessionTime =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032eae:	4e06      	ldr	r6, [pc, #24]	; (8032ec8 <LmhpRemoteMcastSetupOnMcpsIndication+0x550>)
    uint8_t dataBufferIndex = 0;
 8032eb0:	2400      	movs	r4, #0
    uint8_t id = 0xFF;
 8032eb2:	25ff      	movs	r5, #255	; 0xff
    uint8_t cmdIndex = 0;
 8032eb4:	4622      	mov	r2, r4
                if( LoRaMacMcChannelSetupRxParams( ( AddressIdentifier_t )id, &McSessionData[id].RxParams, &status ) == LORAMAC_STATUS_OK )
 8032eb6:	f106 0b38 	add.w	fp, r6, #56	; 0x38
 8032eba:	e584      	b.n	80329c6 <LmhpRemoteMcastSetupOnMcpsIndication+0x4e>
 8032ebc:	12d53d80 	.word	0x12d53d80
 8032ec0:	20004a40 	.word	0x20004a40
 8032ec4:	0803c1e2 	.word	0x0803c1e2
 8032ec8:	20004a38 	.word	0x20004a38

08032ecc <LmhpRemoteMcastSetupProcess>:
{
 8032ecc:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8032ece:	f3ef 8210 	mrs	r2, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8032ed2:	b672      	cpsid	i
    state = LmhpRemoteMcastSetupState.SessionState;
 8032ed4:	4c17      	ldr	r4, [pc, #92]	; (8032f34 <LmhpRemoteMcastSetupProcess+0x68>)
 8032ed6:	78a3      	ldrb	r3, [r4, #2]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8032ed8:	f382 8810 	msr	PRIMASK, r2
    switch( state )
 8032edc:	2b01      	cmp	r3, #1
 8032ede:	d002      	beq.n	8032ee6 <LmhpRemoteMcastSetupProcess+0x1a>
 8032ee0:	2b02      	cmp	r3, #2
 8032ee2:	d01d      	beq.n	8032f20 <LmhpRemoteMcastSetupProcess+0x54>
}
 8032ee4:	bd10      	pop	{r4, pc}
            if ( LmHandlerRequestClass( CLASS_C ) == LORAMAC_HANDLER_SUCCESS )
 8032ee6:	2002      	movs	r0, #2
 8032ee8:	f7fe fb44 	bl	8031574 <LmHandlerRequestClass>
 8032eec:	b960      	cbnz	r0, 8032f08 <LmhpRemoteMcastSetupProcess+0x3c>
                TimerSetValue( &SessionStopTimer, ( 1 << McSessionData[0].SessionTimeout ) * 1000 );
 8032eee:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
                LmhpRemoteMcastSetupState.SessionState = REMOTE_MCAST_SETUP_SESSION_STATE_IDLE;
 8032ef2:	70a0      	strb	r0, [r4, #2]
                TimerSetValue( &SessionStopTimer, ( 1 << McSessionData[0].SessionTimeout ) * 1000 );
 8032ef4:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8032ef8:	4099      	lsls	r1, r3
                TimerSetValue( &SessionStopTimer, 1000 );
 8032efa:	f104 0020 	add.w	r0, r4, #32
 8032efe:	f008 fa71 	bl	803b3e4 <UTIL_TIMER_SetPeriod>
                TimerStart(&SessionStopTimer);
 8032f02:	f104 0020 	add.w	r0, r4, #32
 8032f06:	e007      	b.n	8032f18 <LmhpRemoteMcastSetupProcess+0x4c>
                TimerSetValue( &SessionStartTimer, 1000 );
 8032f08:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8032f0c:	f104 0008 	add.w	r0, r4, #8
 8032f10:	f008 fa68 	bl	803b3e4 <UTIL_TIMER_SetPeriod>
                TimerStart(&SessionStartTimer);
 8032f14:	f104 0008 	add.w	r0, r4, #8
}
 8032f18:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
                TimerStart(&SessionStopTimer);
 8032f1c:	f008 ba28 	b.w	803b370 <UTIL_TIMER_Start>
            if ( LmHandlerRequestClass( CLASS_A ) == LORAMAC_HANDLER_SUCCESS )
 8032f20:	2000      	movs	r0, #0
 8032f22:	f7fe fb27 	bl	8031574 <LmHandlerRequestClass>
 8032f26:	b908      	cbnz	r0, 8032f2c <LmhpRemoteMcastSetupProcess+0x60>
                LmhpRemoteMcastSetupState.SessionState = REMOTE_MCAST_SETUP_SESSION_STATE_IDLE;
 8032f28:	70a0      	strb	r0, [r4, #2]
 8032f2a:	e7db      	b.n	8032ee4 <LmhpRemoteMcastSetupProcess+0x18>
                TimerSetValue( &SessionStopTimer, 1000 );
 8032f2c:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8032f30:	e7e3      	b.n	8032efa <LmhpRemoteMcastSetupProcess+0x2e>
 8032f32:	bf00      	nop
 8032f34:	20004a38 	.word	0x20004a38

08032f38 <LmhpRemoteMcastSetupPackageFactory>:
}
 8032f38:	4800      	ldr	r0, [pc, #0]	; (8032f3c <LmhpRemoteMcastSetupPackageFactory+0x4>)
 8032f3a:	4770      	bx	lr
 8032f3c:	20003560 	.word	0x20003560

08032f40 <OnRadioRxError>:
    MW_LOG(TS_ON, VLEVEL_M, "MAC txTimeOut\r\n" );
}

static void OnRadioRxError( void )
{
    LoRaMacRadioEvents.Events.RxError = 1;
 8032f40:	4b05      	ldr	r3, [pc, #20]	; (8032f58 <OnRadioRxError+0x18>)
 8032f42:	781a      	ldrb	r2, [r3, #0]
 8032f44:	f042 0202 	orr.w	r2, r2, #2
 8032f48:	701a      	strb	r2, [r3, #0]

    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 8032f4a:	f8d3 334c 	ldr.w	r3, [r3, #844]	; 0x34c
 8032f4e:	b113      	cbz	r3, 8032f56 <OnRadioRxError+0x16>
 8032f50:	691b      	ldr	r3, [r3, #16]
 8032f52:	b103      	cbz	r3, 8032f56 <OnRadioRxError+0x16>
    {
        MacCtx.MacCallbacks->MacProcessNotify( );
 8032f54:	4718      	bx	r3
    }
}
 8032f56:	4770      	bx	lr
 8032f58:	20004aa4 	.word	0x20004aa4

08032f5c <UpdateRxSlotIdleState>:
    MW_LOG(TS_ON, VLEVEL_M, "MAC rxTimeOut\r\n" );
}

static void UpdateRxSlotIdleState( void )
{
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 8032f5c:	4a04      	ldr	r2, [pc, #16]	; (8032f70 <UpdateRxSlotIdleState+0x14>)
 8032f5e:	f892 3608 	ldrb.w	r3, [r2, #1544]	; 0x608
 8032f62:	2b02      	cmp	r3, #2
    {
        MacCtx.RxSlot = RX_SLOT_NONE;
 8032f64:	bf18      	it	ne
 8032f66:	2306      	movne	r3, #6
 8032f68:	f882 3484 	strb.w	r3, [r2, #1156]	; 0x484
    }
    else
    {
        MacCtx.RxSlot = RX_SLOT_WIN_CLASS_C;
    }
}
 8032f6c:	4770      	bx	lr
 8032f6e:	bf00      	nop
 8032f70:	20004aa4 	.word	0x20004aa4

08032f74 <StopRetransmission>:
    return false;
}

static bool StopRetransmission( void )
{
    if( ( MacCtx.MacFlags.Bits.McpsInd == 0 ) ||
 8032f74:	4b0f      	ldr	r3, [pc, #60]	; (8032fb4 <StopRetransmission+0x40>)
 8032f76:	f893 2485 	ldrb.w	r2, [r3, #1157]	; 0x485
 8032f7a:	0792      	lsls	r2, r2, #30
 8032f7c:	d503      	bpl.n	8032f86 <StopRetransmission+0x12>
 8032f7e:	f893 2483 	ldrb.w	r2, [r3, #1155]	; 0x483
 8032f82:	2a01      	cmp	r2, #1
 8032f84:	d907      	bls.n	8032f96 <StopRetransmission+0x22>
        ( ( MacCtx.RxStatus.RxSlot != RX_SLOT_WIN_1 ) &&
          ( MacCtx.RxStatus.RxSlot != RX_SLOT_WIN_2 ) ) )
    {   // Maximum repetitions without downlink. Increase ADR Ack counter.
        // Only process the case when the MAC did not receive a downlink.
        if( Nvm.MacGroup2.AdrCtrlOn == true )
 8032f86:	f893 260a 	ldrb.w	r2, [r3, #1546]	; 0x60a
 8032f8a:	b122      	cbz	r2, 8032f96 <StopRetransmission+0x22>
        {
            Nvm.MacGroup1.AdrAckCounter++;
 8032f8c:	f8d3 2534 	ldr.w	r2, [r3, #1332]	; 0x534
 8032f90:	3201      	adds	r2, #1
 8032f92:	f8c3 2534 	str.w	r2, [r3, #1332]	; 0x534
        }
    }

    MacCtx.ChannelsNbTransCounter = 0;
 8032f96:	2200      	movs	r2, #0
 8032f98:	f883 2414 	strb.w	r2, [r3, #1044]	; 0x414
    MacCtx.NodeAckRequested = false;
 8032f9c:	f883 2418 	strb.w	r2, [r3, #1048]	; 0x418
    MacCtx.AckTimeoutRetry = false;
 8032fa0:	f883 2417 	strb.w	r2, [r3, #1047]	; 0x417
    MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 8032fa4:	f8d3 2344 	ldr.w	r2, [r3, #836]	; 0x344
 8032fa8:	f022 0202 	bic.w	r2, r2, #2
 8032fac:	f8c3 2344 	str.w	r2, [r3, #836]	; 0x344

    return true;
}
 8032fb0:	2001      	movs	r0, #1
 8032fb2:	4770      	bx	lr
 8032fb4:	20004aa4 	.word	0x20004aa4

08032fb8 <GetMaxAppPayloadWithoutFOptsLength>:
{
 8032fb8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8032fba:	4b0c      	ldr	r3, [pc, #48]	; (8032fec <GetMaxAppPayloadWithoutFOptsLength+0x34>)
    getPhy.Datarate = datarate;
 8032fbc:	f88d 0009 	strb.w	r0, [sp, #9]
    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8032fc0:	f893 2580 	ldrb.w	r2, [r3, #1408]	; 0x580
 8032fc4:	f88d 200a 	strb.w	r2, [sp, #10]
    getPhy.Attribute = PHY_MAX_PAYLOAD;
 8032fc8:	220d      	movs	r2, #13
 8032fca:	f88d 2008 	strb.w	r2, [sp, #8]
    if( Nvm.MacGroup2.MacParams.RepeaterSupport == true )
 8032fce:	f893 258c 	ldrb.w	r2, [r3, #1420]	; 0x58c
 8032fd2:	b112      	cbz	r2, 8032fda <GetMaxAppPayloadWithoutFOptsLength+0x22>
        getPhy.Attribute = PHY_MAX_PAYLOAD_REPEATER;
 8032fd4:	220e      	movs	r2, #14
 8032fd6:	f88d 2008 	strb.w	r2, [sp, #8]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8032fda:	f893 054c 	ldrb.w	r0, [r3, #1356]	; 0x54c
 8032fde:	a902      	add	r1, sp, #8
 8032fe0:	f003 fb67 	bl	80366b2 <RegionGetPhyParam>
}
 8032fe4:	b2c0      	uxtb	r0, r0
 8032fe6:	b005      	add	sp, #20
 8032fe8:	f85d fb04 	ldr.w	pc, [sp], #4
 8032fec:	20004aa4 	.word	0x20004aa4

08032ff0 <OnAckTimeoutTimerEvent>:
{
 8032ff0:	b510      	push	{r4, lr}
    TimerStop( &MacCtx.AckTimeoutTimer );
 8032ff2:	4c0f      	ldr	r4, [pc, #60]	; (8033030 <OnAckTimeoutTimerEvent+0x40>)
 8032ff4:	f504 707f 	add.w	r0, r4, #1020	; 0x3fc
 8032ff8:	f008 f96a 	bl	803b2d0 <UTIL_TIMER_Stop>
    if( MacCtx.NodeAckRequested == true )
 8032ffc:	f894 2418 	ldrb.w	r2, [r4, #1048]	; 0x418
 8033000:	4623      	mov	r3, r4
 8033002:	b112      	cbz	r2, 803300a <OnAckTimeoutTimerEvent+0x1a>
        MacCtx.AckTimeoutRetry = true;
 8033004:	2201      	movs	r2, #1
 8033006:	f884 2417 	strb.w	r2, [r4, #1047]	; 0x417
    if( Nvm.MacGroup2.DeviceClass == CLASS_C )
 803300a:	f893 2608 	ldrb.w	r2, [r3, #1544]	; 0x608
 803300e:	2a02      	cmp	r2, #2
        MacCtx.MacFlags.Bits.MacDone = 1;
 8033010:	bf02      	ittt	eq
 8033012:	f893 2485 	ldrbeq.w	r2, [r3, #1157]	; 0x485
 8033016:	f042 0220 	orreq.w	r2, r2, #32
 803301a:	f883 2485 	strbeq.w	r2, [r3, #1157]	; 0x485
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 803301e:	f8d3 334c 	ldr.w	r3, [r3, #844]	; 0x34c
 8033022:	b123      	cbz	r3, 803302e <OnAckTimeoutTimerEvent+0x3e>
 8033024:	691b      	ldr	r3, [r3, #16]
 8033026:	b113      	cbz	r3, 803302e <OnAckTimeoutTimerEvent+0x3e>
}
 8033028:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        MacCtx.MacCallbacks->MacProcessNotify( );
 803302c:	4718      	bx	r3
}
 803302e:	bd10      	pop	{r4, pc}
 8033030:	20004aa4 	.word	0x20004aa4

08033034 <PrepareRxDoneAbort>:
{
 8033034:	b510      	push	{r4, lr}
    MacCtx.MacState |= LORAMAC_RX_ABORT;
 8033036:	4c0c      	ldr	r4, [pc, #48]	; (8033068 <PrepareRxDoneAbort+0x34>)
 8033038:	f8d4 2344 	ldr.w	r2, [r4, #836]	; 0x344
 803303c:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8033040:	f8c4 2344 	str.w	r2, [r4, #836]	; 0x344
    if( MacCtx.NodeAckRequested == true )
 8033044:	f894 2418 	ldrb.w	r2, [r4, #1048]	; 0x418
 8033048:	b112      	cbz	r2, 8033050 <PrepareRxDoneAbort+0x1c>
        OnAckTimeoutTimerEvent( NULL );
 803304a:	2000      	movs	r0, #0
 803304c:	f7ff ffd0 	bl	8032ff0 <OnAckTimeoutTimerEvent>
    MacCtx.MacFlags.Bits.McpsInd = 1;
 8033050:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 8033054:	f023 0322 	bic.w	r3, r3, #34	; 0x22
 8033058:	f043 0322 	orr.w	r3, r3, #34	; 0x22
 803305c:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
}
 8033060:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    UpdateRxSlotIdleState( );
 8033064:	f7ff bf7a 	b.w	8032f5c <UpdateRxSlotIdleState>
 8033068:	20004aa4 	.word	0x20004aa4

0803306c <HandleRadioRxErrorTimeout>:
{
 803306c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 8033070:	4c2c      	ldr	r4, [pc, #176]	; (8033124 <HandleRadioRxErrorTimeout+0xb8>)
 8033072:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 8033076:	2b02      	cmp	r3, #2
{
 8033078:	4607      	mov	r7, r0
 803307a:	460e      	mov	r6, r1
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 803307c:	d002      	beq.n	8033084 <HandleRadioRxErrorTimeout+0x18>
        Radio.Sleep( );
 803307e:	4b2a      	ldr	r3, [pc, #168]	; (8033128 <HandleRadioRxErrorTimeout+0xbc>)
 8033080:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8033082:	4798      	blx	r3
    if( LoRaMacClassBIsBeaconExpected( ) == true )
 8033084:	f002 fc5d 	bl	8035942 <LoRaMacClassBIsBeaconExpected>
 8033088:	4605      	mov	r5, r0
 803308a:	b128      	cbz	r0, 8033098 <HandleRadioRxErrorTimeout+0x2c>
        LoRaMacClassBSetBeaconState( BEACON_STATE_TIMEOUT );
 803308c:	2002      	movs	r0, #2
 803308e:	f002 fc4e 	bl	803592e <LoRaMacClassBSetBeaconState>
        LoRaMacClassBBeaconTimerEvent( NULL );
 8033092:	2000      	movs	r0, #0
 8033094:	f002 fc50 	bl	8035938 <LoRaMacClassBBeaconTimerEvent>
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 8033098:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 803309c:	2b01      	cmp	r3, #1
 803309e:	d117      	bne.n	80330d0 <HandleRadioRxErrorTimeout+0x64>
        if( LoRaMacClassBIsPingExpected( ) == true )
 80330a0:	f002 fc51 	bl	8035946 <LoRaMacClassBIsPingExpected>
 80330a4:	4680      	mov	r8, r0
 80330a6:	b130      	cbz	r0, 80330b6 <HandleRadioRxErrorTimeout+0x4a>
            LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 80330a8:	2000      	movs	r0, #0
 80330aa:	f002 fc41 	bl	8035930 <LoRaMacClassBSetPingSlotState>
            LoRaMacClassBPingSlotTimerEvent( NULL );
 80330ae:	2000      	movs	r0, #0
 80330b0:	f002 fc43 	bl	803593a <LoRaMacClassBPingSlotTimerEvent>
            classBRx = true;
 80330b4:	4645      	mov	r5, r8
        if( LoRaMacClassBIsMulticastExpected( ) == true )
 80330b6:	f002 fc48 	bl	803594a <LoRaMacClassBIsMulticastExpected>
 80330ba:	b148      	cbz	r0, 80330d0 <HandleRadioRxErrorTimeout+0x64>
            LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 80330bc:	2000      	movs	r0, #0
 80330be:	f002 fc38 	bl	8035932 <LoRaMacClassBSetMulticastSlotState>
            LoRaMacClassBMulticastSlotTimerEvent( NULL );
 80330c2:	2000      	movs	r0, #0
 80330c4:	f002 fc3a 	bl	803593c <LoRaMacClassBMulticastSlotTimerEvent>
}
 80330c8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    UpdateRxSlotIdleState( );
 80330cc:	f7ff bf46 	b.w	8032f5c <UpdateRxSlotIdleState>
    if( classBRx == false )
 80330d0:	2d00      	cmp	r5, #0
 80330d2:	d1f9      	bne.n	80330c8 <HandleRadioRxErrorTimeout+0x5c>
        if( MacCtx.RxSlot == RX_SLOT_WIN_1 )
 80330d4:	f894 2484 	ldrb.w	r2, [r4, #1156]	; 0x484
 80330d8:	f894 3418 	ldrb.w	r3, [r4, #1048]	; 0x418
 80330dc:	b9ba      	cbnz	r2, 803310e <HandleRadioRxErrorTimeout+0xa2>
            if( MacCtx.NodeAckRequested == true )
 80330de:	b10b      	cbz	r3, 80330e4 <HandleRadioRxErrorTimeout+0x78>
                MacCtx.McpsConfirm.Status = rx1EventInfoStatus;
 80330e0:	f884 743d 	strb.w	r7, [r4, #1085]	; 0x43d
            LoRaMacConfirmQueueSetStatusCmn( rx1EventInfoStatus );
 80330e4:	4638      	mov	r0, r7
 80330e6:	f002 fdd9 	bl	8035c9c <LoRaMacConfirmQueueSetStatusCmn>
            if( TimerGetElapsedTime( Nvm.MacGroup1.LastTxDoneTime ) >= MacCtx.RxWindow2Delay )
 80330ea:	f8d4 0538 	ldr.w	r0, [r4, #1336]	; 0x538
 80330ee:	f008 f8b5 	bl	803b25c <UTIL_TIMER_GetElapsedTime>
 80330f2:	f8d4 33b8 	ldr.w	r3, [r4, #952]	; 0x3b8
 80330f6:	4298      	cmp	r0, r3
 80330f8:	d3e6      	bcc.n	80330c8 <HandleRadioRxErrorTimeout+0x5c>
                TimerStop( &MacCtx.RxWindowTimer2 );
 80330fa:	480c      	ldr	r0, [pc, #48]	; (803312c <HandleRadioRxErrorTimeout+0xc0>)
 80330fc:	f008 f8e8 	bl	803b2d0 <UTIL_TIMER_Stop>
                MacCtx.MacFlags.Bits.MacDone = 1;
 8033100:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 8033104:	f043 0320 	orr.w	r3, r3, #32
 8033108:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
 803310c:	e7dc      	b.n	80330c8 <HandleRadioRxErrorTimeout+0x5c>
            if( MacCtx.NodeAckRequested == true )
 803310e:	b10b      	cbz	r3, 8033114 <HandleRadioRxErrorTimeout+0xa8>
                MacCtx.McpsConfirm.Status = rx2EventInfoStatus;
 8033110:	f884 643d 	strb.w	r6, [r4, #1085]	; 0x43d
            LoRaMacConfirmQueueSetStatusCmn( rx2EventInfoStatus );
 8033114:	4630      	mov	r0, r6
 8033116:	f002 fdc1 	bl	8035c9c <LoRaMacConfirmQueueSetStatusCmn>
            if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 803311a:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 803311e:	2b02      	cmp	r3, #2
 8033120:	d1ee      	bne.n	8033100 <HandleRadioRxErrorTimeout+0x94>
 8033122:	e7d1      	b.n	80330c8 <HandleRadioRxErrorTimeout+0x5c>
 8033124:	20004aa4 	.word	0x20004aa4
 8033128:	0803bbc0 	.word	0x0803bbc0
 803312c:	20004e40 	.word	0x20004e40

08033130 <OnRadioRxTimeout>:
    LoRaMacRadioEvents.Events.RxTimeout = 1;
 8033130:	4b09      	ldr	r3, [pc, #36]	; (8033158 <OnRadioRxTimeout+0x28>)
 8033132:	781a      	ldrb	r2, [r3, #0]
 8033134:	f042 0201 	orr.w	r2, r2, #1
{
 8033138:	b510      	push	{r4, lr}
    LoRaMacRadioEvents.Events.RxTimeout = 1;
 803313a:	701a      	strb	r2, [r3, #0]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 803313c:	f8d3 334c 	ldr.w	r3, [r3, #844]	; 0x34c
 8033140:	b113      	cbz	r3, 8033148 <OnRadioRxTimeout+0x18>
 8033142:	691b      	ldr	r3, [r3, #16]
 8033144:	b103      	cbz	r3, 8033148 <OnRadioRxTimeout+0x18>
        MacCtx.MacCallbacks->MacProcessNotify( );
 8033146:	4798      	blx	r3
}
 8033148:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    MW_LOG(TS_ON, VLEVEL_M, "MAC rxTimeOut\r\n" );
 803314c:	4b03      	ldr	r3, [pc, #12]	; (803315c <OnRadioRxTimeout+0x2c>)
 803314e:	2201      	movs	r2, #1
 8033150:	2100      	movs	r1, #0
 8033152:	2002      	movs	r0, #2
 8033154:	f007 bd9a 	b.w	803ac8c <UTIL_ADV_TRACE_COND_FSend>
 8033158:	20004aa4 	.word	0x20004aa4
 803315c:	0803c2b5 	.word	0x0803c2b5

08033160 <OnRadioTxTimeout>:
    LoRaMacRadioEvents.Events.TxTimeout = 1;
 8033160:	4b09      	ldr	r3, [pc, #36]	; (8033188 <OnRadioTxTimeout+0x28>)
 8033162:	781a      	ldrb	r2, [r3, #0]
 8033164:	f042 0204 	orr.w	r2, r2, #4
{
 8033168:	b510      	push	{r4, lr}
    LoRaMacRadioEvents.Events.TxTimeout = 1;
 803316a:	701a      	strb	r2, [r3, #0]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 803316c:	f8d3 334c 	ldr.w	r3, [r3, #844]	; 0x34c
 8033170:	b113      	cbz	r3, 8033178 <OnRadioTxTimeout+0x18>
 8033172:	691b      	ldr	r3, [r3, #16]
 8033174:	b103      	cbz	r3, 8033178 <OnRadioTxTimeout+0x18>
        MacCtx.MacCallbacks->MacProcessNotify( );
 8033176:	4798      	blx	r3
}
 8033178:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    MW_LOG(TS_ON, VLEVEL_M, "MAC txTimeOut\r\n" );
 803317c:	4b03      	ldr	r3, [pc, #12]	; (803318c <OnRadioTxTimeout+0x2c>)
 803317e:	2201      	movs	r2, #1
 8033180:	2100      	movs	r1, #0
 8033182:	2002      	movs	r0, #2
 8033184:	f007 bd82 	b.w	803ac8c <UTIL_ADV_TRACE_COND_FSend>
 8033188:	20004aa4 	.word	0x20004aa4
 803318c:	0803c2c5 	.word	0x0803c2c5

08033190 <OnRadioRxDone>:
{
 8033190:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8033194:	4616      	mov	r6, r2
 8033196:	461d      	mov	r5, r3
 8033198:	4680      	mov	r8, r0
 803319a:	460f      	mov	r7, r1
    RxDoneParams.LastRxDone = TimerGetCurrentTime( );
 803319c:	f008 f854 	bl	803b248 <UTIL_TIMER_GetCurrentTime>
    LoRaMacRadioEvents.Events.RxDone = 1;
 80331a0:	4b0c      	ldr	r3, [pc, #48]	; (80331d4 <OnRadioRxDone+0x44>)
    RxDoneParams.LastRxDone = TimerGetCurrentTime( );
 80331a2:	4c0d      	ldr	r4, [pc, #52]	; (80331d8 <OnRadioRxDone+0x48>)
    LoRaMacRadioEvents.Events.RxDone = 1;
 80331a4:	781a      	ldrb	r2, [r3, #0]
    RxDoneParams.Size = size;
 80331a6:	8127      	strh	r7, [r4, #8]
    LoRaMacRadioEvents.Events.RxDone = 1;
 80331a8:	f042 0208 	orr.w	r2, r2, #8
 80331ac:	701a      	strb	r2, [r3, #0]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 80331ae:	f8d3 334c 	ldr.w	r3, [r3, #844]	; 0x34c
    RxDoneParams.Rssi = rssi;
 80331b2:	8166      	strh	r6, [r4, #10]
    RxDoneParams.Payload = payload;
 80331b4:	e9c4 0800 	strd	r0, r8, [r4]
    RxDoneParams.Snr = snr;
 80331b8:	7325      	strb	r5, [r4, #12]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 80331ba:	b113      	cbz	r3, 80331c2 <OnRadioRxDone+0x32>
 80331bc:	691b      	ldr	r3, [r3, #16]
 80331be:	b103      	cbz	r3, 80331c2 <OnRadioRxDone+0x32>
        MacCtx.MacCallbacks->MacProcessNotify( );
 80331c0:	4798      	blx	r3
}
 80331c2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    MW_LOG(TS_ON, VLEVEL_M, "MAC rxDone\r\n" );
 80331c6:	4b05      	ldr	r3, [pc, #20]	; (80331dc <OnRadioRxDone+0x4c>)
 80331c8:	2201      	movs	r2, #1
 80331ca:	2100      	movs	r1, #0
 80331cc:	2002      	movs	r0, #2
 80331ce:	f007 bd5d 	b.w	803ac8c <UTIL_ADV_TRACE_COND_FSend>
 80331d2:	bf00      	nop
 80331d4:	20004aa4 	.word	0x20004aa4
 80331d8:	20006314 	.word	0x20006314
 80331dc:	0803c2d5 	.word	0x0803c2d5

080331e0 <OnRadioTxDone>:
{
 80331e0:	b537      	push	{r0, r1, r2, r4, r5, lr}
    TxDoneParams.CurTime = TimerGetCurrentTime( );
 80331e2:	f008 f831 	bl	803b248 <UTIL_TIMER_GetCurrentTime>
 80331e6:	4b10      	ldr	r3, [pc, #64]	; (8033228 <OnRadioTxDone+0x48>)
    MacCtx.LastTxSysTime = SysTimeGet( );
 80331e8:	4c10      	ldr	r4, [pc, #64]	; (803322c <OnRadioTxDone+0x4c>)
    TxDoneParams.CurTime = TimerGetCurrentTime( );
 80331ea:	6018      	str	r0, [r3, #0]
    MacCtx.LastTxSysTime = SysTimeGet( );
 80331ec:	466d      	mov	r5, sp
 80331ee:	4628      	mov	r0, r5
 80331f0:	f007 ff80 	bl	803b0f4 <SysTimeGet>
 80331f4:	e895 0003 	ldmia.w	r5, {r0, r1}
 80331f8:	f504 734f 	add.w	r3, r4, #828	; 0x33c
 80331fc:	e883 0003 	stmia.w	r3, {r0, r1}
    LoRaMacRadioEvents.Events.TxDone = 1;
 8033200:	7823      	ldrb	r3, [r4, #0]
 8033202:	f043 0310 	orr.w	r3, r3, #16
 8033206:	7023      	strb	r3, [r4, #0]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 8033208:	f8d4 334c 	ldr.w	r3, [r4, #844]	; 0x34c
 803320c:	b113      	cbz	r3, 8033214 <OnRadioTxDone+0x34>
 803320e:	691b      	ldr	r3, [r3, #16]
 8033210:	b103      	cbz	r3, 8033214 <OnRadioTxDone+0x34>
        MacCtx.MacCallbacks->MacProcessNotify( );
 8033212:	4798      	blx	r3
    MW_LOG(TS_ON, VLEVEL_M, "MAC txDone\r\n" );
 8033214:	4b06      	ldr	r3, [pc, #24]	; (8033230 <OnRadioTxDone+0x50>)
 8033216:	2201      	movs	r2, #1
 8033218:	2100      	movs	r1, #0
 803321a:	2002      	movs	r0, #2
}
 803321c:	b003      	add	sp, #12
 803321e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    MW_LOG(TS_ON, VLEVEL_M, "MAC txDone\r\n" );
 8033222:	f007 bd33 	b.w	803ac8c <UTIL_ADV_TRACE_COND_FSend>
 8033226:	bf00      	nop
 8033228:	20006310 	.word	0x20006310
 803322c:	20004aa4 	.word	0x20004aa4
 8033230:	0803c2e2 	.word	0x0803c2e2

08033234 <ResetMacParameters>:
{
 8033234:	b5f0      	push	{r4, r5, r6, r7, lr}
    Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_NONE;
 8033236:	4c46      	ldr	r4, [pc, #280]	; (8033350 <ResetMacParameters+0x11c>)
    Nvm.MacGroup1.ChannelsTxPower = Nvm.MacGroup2.ChannelsTxPowerDefault;
 8033238:	f8b4 25d0 	ldrh.w	r2, [r4, #1488]	; 0x5d0
    Nvm.MacGroup2.MacParams.Rx2Channel = Nvm.MacGroup2.MacParamsDefaults.Rx2Channel;
 803323c:	f8d4 15b4 	ldr.w	r1, [r4, #1460]	; 0x5b4
 8033240:	f8d4 05b0 	ldr.w	r0, [r4, #1456]	; 0x5b0
    Nvm.MacGroup1.ChannelsTxPower = Nvm.MacGroup2.ChannelsTxPowerDefault;
 8033244:	f8a4 2544 	strh.w	r2, [r4, #1348]	; 0x544
    Nvm.MacGroup2.MacParams.Rx1DrOffset = Nvm.MacGroup2.MacParamsDefaults.Rx1DrOffset;
 8033248:	f894 25ad 	ldrb.w	r2, [r4, #1453]	; 0x5ad
 803324c:	f884 256d 	strb.w	r2, [r4, #1389]	; 0x56d
    Nvm.MacGroup2.MacParams.Rx2Channel = Nvm.MacGroup2.MacParamsDefaults.Rx2Channel;
 8033250:	f504 62ae 	add.w	r2, r4, #1392	; 0x570
 8033254:	e882 0003 	stmia.w	r2, {r0, r1}
    Nvm.MacGroup2.MacParams.RxCChannel = Nvm.MacGroup2.MacParamsDefaults.RxCChannel;
 8033258:	f8d4 15bc 	ldr.w	r1, [r4, #1468]	; 0x5bc
 803325c:	f8d4 05b8 	ldr.w	r0, [r4, #1464]	; 0x5b8
 8033260:	f504 62af 	add.w	r2, r4, #1400	; 0x578
{
 8033264:	b08f      	sub	sp, #60	; 0x3c
    Nvm.MacGroup2.MacParams.RxCChannel = Nvm.MacGroup2.MacParamsDefaults.RxCChannel;
 8033266:	e882 0003 	stmia.w	r2, {r0, r1}
    Nvm.MacGroup2.MacParams.UplinkDwellTime = Nvm.MacGroup2.MacParamsDefaults.UplinkDwellTime;
 803326a:	f8b4 25c0 	ldrh.w	r2, [r4, #1472]	; 0x5c0
 803326e:	f8a4 2580 	strh.w	r2, [r4, #1408]	; 0x580
    Nvm.MacGroup2.AggregatedDCycle = 1;
 8033272:	2301      	movs	r3, #1
    Nvm.MacGroup2.MacParams.MaxEirp = Nvm.MacGroup2.MacParamsDefaults.MaxEirp;
 8033274:	f8d4 25c4 	ldr.w	r2, [r4, #1476]	; 0x5c4
    Nvm.MacGroup2.AggregatedDCycle = 1;
 8033278:	f8a4 360e 	strh.w	r3, [r4, #1550]	; 0x60e
    Nvm.MacGroup2.MacParams.MaxEirp = Nvm.MacGroup2.MacParamsDefaults.MaxEirp;
 803327c:	f8c4 2584 	str.w	r2, [r4, #1412]	; 0x584
    params.Type = INIT_TYPE_RESET_TO_DEFAULT_CHANNELS;
 8033280:	f88d 3014 	strb.w	r3, [sp, #20]
    Nvm.MacGroup2.MacParams.AntennaGain = Nvm.MacGroup2.MacParamsDefaults.AntennaGain;
 8033284:	f8d4 25c8 	ldr.w	r2, [r4, #1480]	; 0x5c8
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 8033288:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    Nvm.MacGroup2.MacParams.AntennaGain = Nvm.MacGroup2.MacParamsDefaults.AntennaGain;
 803328c:	f8c4 2588 	str.w	r2, [r4, #1416]	; 0x588
    params.NvmGroup1 = &Nvm.RegionGroup1;
 8033290:	f504 63e5 	add.w	r3, r4, #1832	; 0x728
    Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_NONE;
 8033294:	2500      	movs	r5, #0
    MacCtx.ChannelsNbTransCounter = 0;
 8033296:	4a2f      	ldr	r2, [pc, #188]	; (8033354 <ResetMacParameters+0x120>)
    params.NvmGroup1 = &Nvm.RegionGroup1;
 8033298:	9303      	str	r3, [sp, #12]
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 803329a:	a903      	add	r1, sp, #12
    params.NvmGroup2 = &Nvm.RegionGroup2;
 803329c:	f204 73cc 	addw	r3, r4, #1996	; 0x7cc
    MacCtx.ChannelsNbTransCounter = 0;
 80332a0:	f8c4 2414 	str.w	r2, [r4, #1044]	; 0x414
    params.NvmGroup2 = &Nvm.RegionGroup2;
 80332a4:	9304      	str	r3, [sp, #16]
    Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_NONE;
 80332a6:	f884 561c 	strb.w	r5, [r4, #1564]	; 0x61c
    Nvm.MacGroup1.AdrAckCounter = 0;
 80332aa:	f8c4 5534 	str.w	r5, [r4, #1332]	; 0x534
    Nvm.MacGroup2.MaxDCycle = 0;
 80332ae:	f884 560b 	strb.w	r5, [r4, #1547]	; 0x60b
    MacCtx.NodeAckRequested = false;
 80332b2:	f884 5418 	strb.w	r5, [r4, #1048]	; 0x418
    Nvm.MacGroup1.SrvAckRequested = false;
 80332b6:	f884 5546 	strb.w	r5, [r4, #1350]	; 0x546
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 80332ba:	f003 fa15 	bl	80366e8 <RegionInitDefaults>
    MacCtx.RxWindow2Config.Frequency = Nvm.MacGroup2.MacParams.Rx2Channel.Frequency;
 80332be:	f8d4 3570 	ldr.w	r3, [r4, #1392]	; 0x570
 80332c2:	f8c4 33d4 	str.w	r3, [r4, #980]	; 0x3d4
    MacCtx.RxWindow2Config.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 80332c6:	f894 3581 	ldrb.w	r3, [r4, #1409]	; 0x581
 80332ca:	f884 33e0 	strb.w	r3, [r4, #992]	; 0x3e0
    MacCtx.RxWindow2Config.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport; /* ST_WORKAROUND: Keep repeater feature */
 80332ce:	f894 358c 	ldrb.w	r3, [r4, #1420]	; 0x58c
 80332d2:	f884 33e1 	strb.w	r3, [r4, #993]	; 0x3e1
    MacCtx.RxWindow2Config.RxContinuous = false;
 80332d6:	f44f 7380 	mov.w	r3, #256	; 0x100
 80332da:	f8a4 33e2 	strh.w	r3, [r4, #994]	; 0x3e2
    MacCtx.RxWindow2Config.Channel = MacCtx.Channel;
 80332de:	f884 53d0 	strb.w	r5, [r4, #976]	; 0x3d0
    MacCtx.RxWindowCConfig = MacCtx.RxWindow2Config;
 80332e2:	f504 7774 	add.w	r7, r4, #976	; 0x3d0
 80332e6:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 80332e8:	f504 7679 	add.w	r6, r4, #996	; 0x3e4
 80332ec:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 80332ee:	683b      	ldr	r3, [r7, #0]
 80332f0:	6033      	str	r3, [r6, #0]
    MacCtx.RxWindowCConfig.RxContinuous = true;
 80332f2:	f240 2301 	movw	r3, #513	; 0x201
 80332f6:	f8a4 33f6 	strh.w	r3, [r4, #1014]	; 0x3f6
    if( MacCtx.MacCallbacks != NULL )
 80332fa:	f8d4 334c 	ldr.w	r3, [r4, #844]	; 0x34c
    MacCtx.Channel = 0;
 80332fe:	f884 5419 	strb.w	r5, [r4, #1049]	; 0x419
    classBCallbacks.MacProcessNotify = NULL;
 8033302:	e9cd 5501 	strd	r5, r5, [sp, #4]
    if( MacCtx.MacCallbacks != NULL )
 8033306:	b11b      	cbz	r3, 8033310 <ResetMacParameters+0xdc>
        classBCallbacks.GetTemperatureLevel = MacCtx.MacCallbacks->GetTemperatureLevel;
 8033308:	685a      	ldr	r2, [r3, #4]
        classBCallbacks.MacProcessNotify = MacCtx.MacCallbacks->MacProcessNotify;
 803330a:	691b      	ldr	r3, [r3, #16]
        classBCallbacks.GetTemperatureLevel = MacCtx.MacCallbacks->GetTemperatureLevel;
 803330c:	9201      	str	r2, [sp, #4]
        classBCallbacks.MacProcessNotify = MacCtx.MacCallbacks->MacProcessNotify;
 803330e:	9302      	str	r3, [sp, #8]
    classBParams.MlmeIndication = &MacCtx.MlmeIndication;
 8033310:	4a11      	ldr	r2, [pc, #68]	; (8033358 <ResetMacParameters+0x124>)
 8033312:	9206      	str	r2, [sp, #24]
    classBParams.McpsIndication = &MacCtx.McpsIndication;
 8033314:	f1a2 0344 	sub.w	r3, r2, #68	; 0x44
 8033318:	9307      	str	r3, [sp, #28]
    classBParams.MlmeConfirm = &MacCtx.MlmeConfirm;
 803331a:	f1a2 0314 	sub.w	r3, r2, #20
 803331e:	9308      	str	r3, [sp, #32]
    classBParams.LoRaMacFlags = &MacCtx.MacFlags;
 8033320:	f102 0321 	add.w	r3, r2, #33	; 0x21
 8033324:	9309      	str	r3, [sp, #36]	; 0x24
    classBParams.LoRaMacDevAddr = &Nvm.MacGroup2.DevAddr;
 8033326:	f502 73ba 	add.w	r3, r2, #372	; 0x174
 803332a:	930a      	str	r3, [sp, #40]	; 0x28
    classBParams.LoRaMacRegion = &Nvm.MacGroup2.Region;
 803332c:	f102 03e8 	add.w	r3, r2, #232	; 0xe8
 8033330:	930b      	str	r3, [sp, #44]	; 0x2c
    classBParams.LoRaMacParams = &Nvm.MacGroup2.MacParams;
 8033332:	f102 03ec 	add.w	r3, r2, #236	; 0xec
 8033336:	930c      	str	r3, [sp, #48]	; 0x30
    LoRaMacClassBInit( &classBParams, &classBCallbacks, &Nvm.ClassB );
 8033338:	a901      	add	r1, sp, #4
    classBParams.MulticastChannels = &Nvm.MacGroup2.MulticastChannelList[0];
 803333a:	f502 73bc 	add.w	r3, r2, #376	; 0x178
    LoRaMacClassBInit( &classBParams, &classBCallbacks, &Nvm.ClassB );
 803333e:	a806      	add	r0, sp, #24
 8033340:	f202 62e4 	addw	r2, r2, #1764	; 0x6e4
    classBParams.MulticastChannels = &Nvm.MacGroup2.MulticastChannelList[0];
 8033344:	930d      	str	r3, [sp, #52]	; 0x34
    LoRaMacClassBInit( &classBParams, &classBCallbacks, &Nvm.ClassB );
 8033346:	f002 faf1 	bl	803592c <LoRaMacClassBInit>
}
 803334a:	b00f      	add	sp, #60	; 0x3c
 803334c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 803334e:	bf00      	nop
 8033350:	20004aa4 	.word	0x20004aa4
 8033354:	00010100 	.word	0x00010100
 8033358:	20004f08 	.word	0x20004f08

0803335c <ScheduleTx>:
{
 803335c:	b5f0      	push	{r4, r5, r6, r7, lr}
 803335e:	b093      	sub	sp, #76	; 0x4c
 8033360:	4607      	mov	r7, r0
    if( LoRaMacClassBIsBeaconExpected( ) == true )
 8033362:	f002 faee 	bl	8035942 <LoRaMacClassBIsBeaconExpected>
 8033366:	2800      	cmp	r0, #0
 8033368:	f040 8163 	bne.w	8033632 <ScheduleTx+0x2d6>
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 803336c:	4cb2      	ldr	r4, [pc, #712]	; (8033638 <ScheduleTx+0x2dc>)
 803336e:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 8033372:	2b01      	cmp	r3, #1
 8033374:	d009      	beq.n	803338a <ScheduleTx+0x2e>
    if( Nvm.MacGroup1.AggregatedTimeOff == 0 )
 8033376:	f8d4 353c 	ldr.w	r3, [r4, #1340]	; 0x53c
 803337a:	b193      	cbz	r3, 80333a2 <ScheduleTx+0x46>
    switch( MacCtx.TxMsg.Type )
 803337c:	f894 3108 	ldrb.w	r3, [r4, #264]	; 0x108
 8033380:	b1c3      	cbz	r3, 80333b4 <ScheduleTx+0x58>
 8033382:	2b04      	cmp	r3, #4
 8033384:	d076      	beq.n	8033474 <ScheduleTx+0x118>
            return LORAMAC_STATUS_PARAMETER_INVALID;
 8033386:	2503      	movs	r5, #3
 8033388:	e003      	b.n	8033392 <ScheduleTx+0x36>
        if( LoRaMacClassBIsPingExpected( ) == true )
 803338a:	f002 fadc 	bl	8035946 <LoRaMacClassBIsPingExpected>
 803338e:	b118      	cbz	r0, 8033398 <ScheduleTx+0x3c>
            return LORAMAC_STATUS_BUSY_PING_SLOT_WINDOW_TIME;
 8033390:	250f      	movs	r5, #15
}
 8033392:	4628      	mov	r0, r5
 8033394:	b013      	add	sp, #76	; 0x4c
 8033396:	bdf0      	pop	{r4, r5, r6, r7, pc}
        else if( LoRaMacClassBIsMulticastExpected( ) == true )
 8033398:	f002 fad7 	bl	803594a <LoRaMacClassBIsMulticastExpected>
 803339c:	2800      	cmp	r0, #0
 803339e:	d0ea      	beq.n	8033376 <ScheduleTx+0x1a>
 80333a0:	e7f6      	b.n	8033390 <ScheduleTx+0x34>
        Nvm.MacGroup1.AggregatedTimeOff = ( MacCtx.TxTimeOnAir * Nvm.MacGroup2.AggregatedDCycle - MacCtx.TxTimeOnAir );
 80333a2:	f8b4 360e 	ldrh.w	r3, [r4, #1550]	; 0x60e
 80333a6:	1e5a      	subs	r2, r3, #1
 80333a8:	f8d4 341c 	ldr.w	r3, [r4, #1052]	; 0x41c
 80333ac:	4353      	muls	r3, r2
 80333ae:	f8c4 353c 	str.w	r3, [r4, #1340]	; 0x53c
 80333b2:	e7e3      	b.n	803337c <ScheduleTx+0x20>
            serializeStatus = LoRaMacSerializerJoinRequest( &MacCtx.TxMsg.Message.JoinReq );
 80333b4:	48a1      	ldr	r0, [pc, #644]	; (803363c <ScheduleTx+0x2e0>)
 80333b6:	f003 f8ce 	bl	8036556 <LoRaMacSerializerJoinRequest>
            if( LORAMAC_SERIALIZER_SUCCESS != serializeStatus )
 80333ba:	2800      	cmp	r0, #0
 80333bc:	f040 8135 	bne.w	803362a <ScheduleTx+0x2ce>
            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.Data.BufSize;
 80333c0:	f894 3110 	ldrb.w	r3, [r4, #272]	; 0x110
 80333c4:	80a3      	strh	r3, [r4, #4]
    nextChan.AggrTimeOff = Nvm.MacGroup1.AggregatedTimeOff;
 80333c6:	f8d4 353c 	ldr.w	r3, [r4, #1340]	; 0x53c
 80333ca:	930c      	str	r3, [sp, #48]	; 0x30
    nextChan.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );
 80333cc:	ae06      	add	r6, sp, #24
    nextChan.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 80333ce:	f894 3545 	ldrb.w	r3, [r4, #1349]	; 0x545
 80333d2:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
    nextChan.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );
 80333d6:	4630      	mov	r0, r6
    nextChan.DutyCycleEnabled = Nvm.MacGroup2.DutyCycleOn;
 80333d8:	f894 360c 	ldrb.w	r3, [r4, #1548]	; 0x60c
 80333dc:	f88d 303a 	strb.w	r3, [sp, #58]	; 0x3a
    nextChan.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );
 80333e0:	f007 feae 	bl	803b140 <SysTimeGetMcuTime>
 80333e4:	f8d4 3614 	ldr.w	r3, [r4, #1556]	; 0x614
 80333e8:	9300      	str	r3, [sp, #0]
 80333ea:	ad02      	add	r5, sp, #8
 80333ec:	e896 0006 	ldmia.w	r6, {r1, r2}
 80333f0:	f8d4 3610 	ldr.w	r3, [r4, #1552]	; 0x610
 80333f4:	4628      	mov	r0, r5
 80333f6:	f007 fe39 	bl	803b06c <SysTimeSub>
 80333fa:	e895 0003 	ldmia.w	r5, {r0, r1}
 80333fe:	ab0f      	add	r3, sp, #60	; 0x3c
 8033400:	e883 0003 	stmia.w	r3, {r0, r1}
    nextChan.LastAggrTx = Nvm.MacGroup1.LastTxDoneTime;
 8033404:	f8d4 3538 	ldr.w	r3, [r4, #1336]	; 0x538
 8033408:	930d      	str	r3, [sp, #52]	; 0x34
    nextChan.LastTxIsJoinRequest = false;
 803340a:	2300      	movs	r3, #0
 803340c:	f88d 3044 	strb.w	r3, [sp, #68]	; 0x44
    nextChan.PktLen = MacCtx.PktBufferLen;
 8033410:	88a3      	ldrh	r3, [r4, #4]
 8033412:	f8ad 3046 	strh.w	r3, [sp, #70]	; 0x46
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 8033416:	f894 361c 	ldrb.w	r3, [r4, #1564]	; 0x61c
    nextChan.Joined = true;
 803341a:	2201      	movs	r2, #1
 803341c:	f88d 2039 	strb.w	r2, [sp, #57]	; 0x39
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 8033420:	b91b      	cbnz	r3, 803342a <ScheduleTx+0xce>
        nextChan.LastTxIsJoinRequest = true;
 8033422:	f88d 2044 	strb.w	r2, [sp, #68]	; 0x44
        nextChan.Joined = false;
 8033426:	f88d 3039 	strb.w	r3, [sp, #57]	; 0x39
    status = RegionNextChannel( Nvm.MacGroup2.Region, &nextChan, &MacCtx.Channel, &MacCtx.DutyCycleWaitTime, &Nvm.MacGroup1.AggregatedTimeOff );
 803342a:	4e85      	ldr	r6, [pc, #532]	; (8033640 <ScheduleTx+0x2e4>)
 803342c:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
 8033430:	9600      	str	r6, [sp, #0]
 8033432:	f46f 7291 	mvn.w	r2, #290	; 0x122
 8033436:	f1a6 03b4 	sub.w	r3, r6, #180	; 0xb4
 803343a:	18b2      	adds	r2, r6, r2
 803343c:	a90c      	add	r1, sp, #48	; 0x30
 803343e:	f003 fa06 	bl	803684e <RegionNextChannel>
    if( status != LORAMAC_STATUS_OK )
 8033442:	4605      	mov	r5, r0
 8033444:	b1d0      	cbz	r0, 803347c <ScheduleTx+0x120>
        if( ( status == LORAMAC_STATUS_DUTYCYCLE_RESTRICTED ) &&
 8033446:	280b      	cmp	r0, #11
 8033448:	d1a3      	bne.n	8033392 <ScheduleTx+0x36>
 803344a:	2f00      	cmp	r7, #0
 803344c:	d0a1      	beq.n	8033392 <ScheduleTx+0x36>
            if( MacCtx.DutyCycleWaitTime != 0 )
 803344e:	f8d4 1488 	ldr.w	r1, [r4, #1160]	; 0x488
 8033452:	b169      	cbz	r1, 8033470 <ScheduleTx+0x114>
                MacCtx.MacState |= LORAMAC_TX_DELAYED;
 8033454:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
                TimerSetValue( &MacCtx.TxDelayedTimer, MacCtx.DutyCycleWaitTime );
 8033458:	f5a6 70e8 	sub.w	r0, r6, #464	; 0x1d0
                MacCtx.MacState |= LORAMAC_TX_DELAYED;
 803345c:	f043 0320 	orr.w	r3, r3, #32
 8033460:	f8c4 3344 	str.w	r3, [r4, #836]	; 0x344
                TimerSetValue( &MacCtx.TxDelayedTimer, MacCtx.DutyCycleWaitTime );
 8033464:	f007 ffbe 	bl	803b3e4 <UTIL_TIMER_SetPeriod>
                TimerStart( &MacCtx.TxDelayedTimer );
 8033468:	f5a6 70e8 	sub.w	r0, r6, #464	; 0x1d0
 803346c:	f007 ff80 	bl	803b370 <UTIL_TIMER_Start>
            return LORAMAC_STATUS_OK;
 8033470:	2500      	movs	r5, #0
 8033472:	e78e      	b.n	8033392 <ScheduleTx+0x36>
            serializeStatus = LoRaMacSerializerData( &MacCtx.TxMsg.Message.Data );
 8033474:	4871      	ldr	r0, [pc, #452]	; (803363c <ScheduleTx+0x2e0>)
 8033476:	f003 f8a2 	bl	80365be <LoRaMacSerializerData>
 803347a:	e79e      	b.n	80333ba <ScheduleTx+0x5e>
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 803347c:	f894 754c 	ldrb.w	r7, [r4, #1356]	; 0x54c
                                     RegionApplyDrOffset( Nvm.MacGroup2.Region,
 8033480:	f994 356d 	ldrsb.w	r3, [r4, #1389]	; 0x56d
 8033484:	f994 2545 	ldrsb.w	r2, [r4, #1349]	; 0x545
 8033488:	f894 1581 	ldrb.w	r1, [r4, #1409]	; 0x581
 803348c:	4638      	mov	r0, r7
 803348e:	f003 f9fc 	bl	803688a <RegionApplyDrOffset>
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 8033492:	f5a6 73c0 	sub.w	r3, r6, #384	; 0x180
 8033496:	b241      	sxtb	r1, r0
 8033498:	f894 2554 	ldrb.w	r2, [r4, #1364]	; 0x554
 803349c:	9300      	str	r3, [sp, #0]
 803349e:	4638      	mov	r0, r7
 80334a0:	f8d4 3550 	ldr.w	r3, [r4, #1360]	; 0x550
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 80334a4:	f5a6 76b6 	sub.w	r6, r6, #364	; 0x16c
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 80334a8:	f003 f94d 	bl	8036746 <RegionComputeRxWindowParameters>
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 80334ac:	f8d4 3550 	ldr.w	r3, [r4, #1360]	; 0x550
 80334b0:	f994 1574 	ldrsb.w	r1, [r4, #1396]	; 0x574
 80334b4:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
 80334b8:	9600      	str	r6, [sp, #0]
 80334ba:	f894 2554 	ldrb.w	r2, [r4, #1364]	; 0x554
 80334be:	f003 f942 	bl	8036746 <RegionComputeRxWindowParameters>
    MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.ReceiveDelay2 + MacCtx.RxWindow2Config.WindowOffset;
 80334c2:	f8d4 03dc 	ldr.w	r0, [r4, #988]	; 0x3dc
 80334c6:	f8d4 1560 	ldr.w	r1, [r4, #1376]	; 0x560
    MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.ReceiveDelay1 + MacCtx.RxWindow1Config.WindowOffset;
 80334ca:	f8d4 63c8 	ldr.w	r6, [r4, #968]	; 0x3c8
 80334ce:	f8d4 355c 	ldr.w	r3, [r4, #1372]	; 0x55c
    MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.ReceiveDelay2 + MacCtx.RxWindow2Config.WindowOffset;
 80334d2:	4401      	add	r1, r0
 80334d4:	f8c4 13b8 	str.w	r1, [r4, #952]	; 0x3b8
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 80334d8:	f894 161c 	ldrb.w	r1, [r4, #1564]	; 0x61c
    MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.ReceiveDelay1 + MacCtx.RxWindow1Config.WindowOffset;
 80334dc:	4433      	add	r3, r6
 80334de:	f8c4 33b4 	str.w	r3, [r4, #948]	; 0x3b4
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 80334e2:	b949      	cbnz	r1, 80334f8 <ScheduleTx+0x19c>
        MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay1 + MacCtx.RxWindow1Config.WindowOffset;
 80334e4:	f8d4 2564 	ldr.w	r2, [r4, #1380]	; 0x564
        MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay2 + MacCtx.RxWindow2Config.WindowOffset;
 80334e8:	f8d4 3568 	ldr.w	r3, [r4, #1384]	; 0x568
        MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay1 + MacCtx.RxWindow1Config.WindowOffset;
 80334ec:	4432      	add	r2, r6
        MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay2 + MacCtx.RxWindow2Config.WindowOffset;
 80334ee:	4403      	add	r3, r0
        MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay1 + MacCtx.RxWindow1Config.WindowOffset;
 80334f0:	f8c4 23b4 	str.w	r2, [r4, #948]	; 0x3b4
        MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay2 + MacCtx.RxWindow2Config.WindowOffset;
 80334f4:	f8c4 33b8 	str.w	r3, [r4, #952]	; 0x3b8
    size_t macCmdsSize = 0;
 80334f8:	2300      	movs	r3, #0
 80334fa:	9308      	str	r3, [sp, #32]
    if( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE )
 80334fc:	b181      	cbz	r1, 8033520 <ScheduleTx+0x1c4>
        if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )
 80334fe:	a808      	add	r0, sp, #32
 8033500:	f002 fae4 	bl	8035acc <LoRaMacCommandsGetSizeSerializedCmds>
 8033504:	2800      	cmp	r0, #0
 8033506:	d14a      	bne.n	803359e <ScheduleTx+0x242>
    maxN = GetMaxAppPayloadWithoutFOptsLength( datarate );
 8033508:	f994 0545 	ldrsb.w	r0, [r4, #1349]	; 0x545
        if( ValidatePayloadLength( MacCtx.AppDataSize, Nvm.MacGroup1.ChannelsDatarate, macCmdsSize ) == false )
 803350c:	f894 623b 	ldrb.w	r6, [r4, #571]	; 0x23b
 8033510:	f89d 7020 	ldrb.w	r7, [sp, #32]
    maxN = GetMaxAppPayloadWithoutFOptsLength( datarate );
 8033514:	f7ff fd50 	bl	8032fb8 <GetMaxAppPayloadWithoutFOptsLength>
    if( ( payloadSize <= maxN ) && ( payloadSize <= LORAMAC_PHY_MAXPAYLOAD ) )
 8033518:	443e      	add	r6, r7
 803351a:	b280      	uxth	r0, r0
 803351c:	42b0      	cmp	r0, r6
 803351e:	d33c      	bcc.n	803359a <ScheduleTx+0x23e>
    int8_t txPower = 0;
 8033520:	2300      	movs	r3, #0
 8033522:	f88d 3013 	strb.w	r3, [sp, #19]
    txConfig.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 8033526:	f894 3545 	ldrb.w	r3, [r4, #1349]	; 0x545
 803352a:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
    txConfig.TxPower = Nvm.MacGroup1.ChannelsTxPower;
 803352e:	f894 3544 	ldrb.w	r3, [r4, #1348]	; 0x544
 8033532:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    txConfig.MaxEirp = Nvm.MacGroup2.MacParams.MaxEirp;
 8033536:	f8d4 3584 	ldr.w	r3, [r4, #1412]	; 0x584
 803353a:	9309      	str	r3, [sp, #36]	; 0x24
    txConfig.AntennaGain = Nvm.MacGroup2.MacParams.AntennaGain;
 803353c:	f8d4 3588 	ldr.w	r3, [r4, #1416]	; 0x588
 8033540:	930a      	str	r3, [sp, #40]	; 0x28
    txConfig.PktLen = MacCtx.PktBufferLen;
 8033542:	88a3      	ldrh	r3, [r4, #4]
    return SendFrameOnChannel( MacCtx.Channel );
 8033544:	f894 6419 	ldrb.w	r6, [r4, #1049]	; 0x419
    txConfig.PktLen = MacCtx.PktBufferLen;
 8033548:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
    RegionTxConfig( Nvm.MacGroup2.Region, &txConfig, &txPower, &MacCtx.TxTimeOnAir );
 803354c:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
 8033550:	4b3c      	ldr	r3, [pc, #240]	; (8033644 <ScheduleTx+0x2e8>)
    txConfig.Channel = channel;
 8033552:	f88d 6020 	strb.w	r6, [sp, #32]
    RegionTxConfig( Nvm.MacGroup2.Region, &txConfig, &txPower, &MacCtx.TxTimeOnAir );
 8033556:	f10d 0213 	add.w	r2, sp, #19
 803355a:	a908      	add	r1, sp, #32
 803355c:	f003 f912 	bl	8036784 <RegionTxConfig>
    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 8033560:	2301      	movs	r3, #1
 8033562:	f884 343d 	strb.w	r3, [r4, #1085]	; 0x43d
    MacCtx.McpsConfirm.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 8033566:	f894 3545 	ldrb.w	r3, [r4, #1349]	; 0x545
 803356a:	f884 343e 	strb.w	r3, [r4, #1086]	; 0x43e
    MacCtx.McpsConfirm.TxPower = txPower;
 803356e:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8033572:	f884 343f 	strb.w	r3, [r4, #1087]	; 0x43f
    MacCtx.McpsConfirm.TxTimeOnAir = MacCtx.TxTimeOnAir;
 8033576:	f8d4 341c 	ldr.w	r3, [r4, #1052]	; 0x41c
    MacCtx.McpsConfirm.Channel = channel;
 803357a:	f8c4 644c 	str.w	r6, [r4, #1100]	; 0x44c
    MacCtx.McpsConfirm.TxTimeOnAir = MacCtx.TxTimeOnAir;
 803357e:	f8c4 3444 	str.w	r3, [r4, #1092]	; 0x444
    MacCtx.MlmeConfirm.TxTimeOnAir = MacCtx.TxTimeOnAir;
 8033582:	f8c4 3454 	str.w	r3, [r4, #1108]	; 0x454
    if( LoRaMacClassBIsBeaconModeActive( ) == true )
 8033586:	f002 f9e2 	bl	803594e <LoRaMacClassBIsBeaconModeActive>
 803358a:	b150      	cbz	r0, 80335a2 <ScheduleTx+0x246>
        TimerTime_t collisionTime = LoRaMacClassBIsUplinkCollision( MacCtx.TxTimeOnAir );
 803358c:	f8d4 041c 	ldr.w	r0, [r4, #1052]	; 0x41c
 8033590:	f002 f9ef 	bl	8035972 <LoRaMacClassBIsUplinkCollision>
        if( collisionTime > 0 )
 8033594:	b128      	cbz	r0, 80335a2 <ScheduleTx+0x246>
            return LORAMAC_STATUS_BUSY_UPLINK_COLLISION;
 8033596:	2510      	movs	r5, #16
    return SendFrameOnChannel( MacCtx.Channel );
 8033598:	e6fb      	b.n	8033392 <ScheduleTx+0x36>
            return LORAMAC_STATUS_LENGTH_ERROR;
 803359a:	2508      	movs	r5, #8
 803359c:	e6f9      	b.n	8033392 <ScheduleTx+0x36>
            return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 803359e:	2513      	movs	r5, #19
 80335a0:	e6f7      	b.n	8033392 <ScheduleTx+0x36>
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 80335a2:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 80335a6:	2b01      	cmp	r3, #1
 80335a8:	d101      	bne.n	80335ae <ScheduleTx+0x252>
        LoRaMacClassBStopRxSlots( );
 80335aa:	f002 f9e4 	bl	8035976 <LoRaMacClassBStopRxSlots>
    LoRaMacClassBHaltBeaconing( );
 80335ae:	f002 f9d1 	bl	8035954 <LoRaMacClassBHaltBeaconing>
    uint32_t fCntUp = 0;
 80335b2:	2300      	movs	r3, #0
 80335b4:	9305      	str	r3, [sp, #20]
    switch( MacCtx.TxMsg.Type )
 80335b6:	f894 3108 	ldrb.w	r3, [r4, #264]	; 0x108
    status = SecureFrame( Nvm.MacGroup1.ChannelsDatarate, MacCtx.Channel );
 80335ba:	f994 6545 	ldrsb.w	r6, [r4, #1349]	; 0x545
 80335be:	f894 7419 	ldrb.w	r7, [r4, #1049]	; 0x419
    switch( MacCtx.TxMsg.Type )
 80335c2:	b1bb      	cbz	r3, 80335f4 <ScheduleTx+0x298>
 80335c4:	2b04      	cmp	r3, #4
 80335c6:	f47f aede 	bne.w	8033386 <ScheduleTx+0x2a>
            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetFCntUp( &fCntUp ) )
 80335ca:	a805      	add	r0, sp, #20
 80335cc:	f002 fce2 	bl	8035f94 <LoRaMacCryptoGetFCntUp>
 80335d0:	bb68      	cbnz	r0, 803362e <ScheduleTx+0x2d2>
            if( ( MacCtx.ChannelsNbTransCounter >= 1 ) || ( MacCtx.AckTimeoutRetriesCounter > 1 ) )
 80335d2:	f894 3414 	ldrb.w	r3, [r4, #1044]	; 0x414
 80335d6:	b91b      	cbnz	r3, 80335e0 <ScheduleTx+0x284>
 80335d8:	f894 3416 	ldrb.w	r3, [r4, #1046]	; 0x416
 80335dc:	2b01      	cmp	r3, #1
 80335de:	d902      	bls.n	80335e6 <ScheduleTx+0x28a>
                fCntUp -= 1;
 80335e0:	9b05      	ldr	r3, [sp, #20]
 80335e2:	3b01      	subs	r3, #1
 80335e4:	9305      	str	r3, [sp, #20]
            macCryptoStatus = LoRaMacCryptoSecureMessage( fCntUp, txDr, txCh, &MacCtx.TxMsg.Message.Data );
 80335e6:	4b15      	ldr	r3, [pc, #84]	; (803363c <ScheduleTx+0x2e0>)
 80335e8:	9805      	ldr	r0, [sp, #20]
 80335ea:	463a      	mov	r2, r7
 80335ec:	b2f1      	uxtb	r1, r6
 80335ee:	f002 fd47 	bl	8036080 <LoRaMacCryptoSecureMessage>
 80335f2:	e002      	b.n	80335fa <ScheduleTx+0x29e>
            macCryptoStatus = LoRaMacCryptoPrepareJoinRequest( &MacCtx.TxMsg.Message.JoinReq );
 80335f4:	4811      	ldr	r0, [pc, #68]	; (803363c <ScheduleTx+0x2e0>)
 80335f6:	f002 fd1b 	bl	8036030 <LoRaMacCryptoPrepareJoinRequest>
            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )
 80335fa:	b9b0      	cbnz	r0, 803362a <ScheduleTx+0x2ce>
            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.Data.BufSize;
 80335fc:	f894 3110 	ldrb.w	r3, [r4, #272]	; 0x110
 8033600:	80a3      	strh	r3, [r4, #4]
    MacCtx.MacState |= LORAMAC_TX_RUNNING;
 8033602:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 8033606:	f043 0302 	orr.w	r3, r3, #2
 803360a:	f8c4 3344 	str.w	r3, [r4, #836]	; 0x344
    if( MacCtx.NodeAckRequested == false )
 803360e:	f894 3418 	ldrb.w	r3, [r4, #1048]	; 0x418
 8033612:	b923      	cbnz	r3, 803361e <ScheduleTx+0x2c2>
        MacCtx.ChannelsNbTransCounter++;
 8033614:	f894 3414 	ldrb.w	r3, [r4, #1044]	; 0x414
 8033618:	3301      	adds	r3, #1
 803361a:	f884 3414 	strb.w	r3, [r4, #1044]	; 0x414
    Radio.Send( MacCtx.PktBuffer, MacCtx.PktBufferLen );
 803361e:	4b0a      	ldr	r3, [pc, #40]	; (8033648 <ScheduleTx+0x2ec>)
 8033620:	7921      	ldrb	r1, [r4, #4]
 8033622:	480a      	ldr	r0, [pc, #40]	; (803364c <ScheduleTx+0x2f0>)
 8033624:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8033626:	4798      	blx	r3
    return LORAMAC_STATUS_OK;
 8033628:	e6b3      	b.n	8033392 <ScheduleTx+0x36>
                return LORAMAC_STATUS_CRYPTO_ERROR;
 803362a:	2511      	movs	r5, #17
 803362c:	e6b1      	b.n	8033392 <ScheduleTx+0x36>
                return LORAMAC_STATUS_FCNT_HANDLER_ERROR;
 803362e:	2512      	movs	r5, #18
 8033630:	e6af      	b.n	8033392 <ScheduleTx+0x36>
        return LORAMAC_STATUS_BUSY_BEACON_RESERVED_TIME;
 8033632:	250e      	movs	r5, #14
 8033634:	e6ad      	b.n	8033392 <ScheduleTx+0x36>
 8033636:	bf00      	nop
 8033638:	20004aa4 	.word	0x20004aa4
 803363c:	20004bb0 	.word	0x20004bb0
 8033640:	20004fe0 	.word	0x20004fe0
 8033644:	20004ec0 	.word	0x20004ec0
 8033648:	0803bbc0 	.word	0x0803bbc0
 803364c:	20004aaa 	.word	0x20004aaa

08033650 <OnTxDelayedTimerEvent>:
{
 8033650:	b510      	push	{r4, lr}
    TimerStop( &MacCtx.TxDelayedTimer );
 8033652:	4c11      	ldr	r4, [pc, #68]	; (8033698 <OnTxDelayedTimerEvent+0x48>)
 8033654:	f504 705b 	add.w	r0, r4, #876	; 0x36c
 8033658:	f007 fe3a 	bl	803b2d0 <UTIL_TIMER_Stop>
    MacCtx.MacState &= ~LORAMAC_TX_DELAYED;
 803365c:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
    switch( ScheduleTx( true ) )
 8033660:	2001      	movs	r0, #1
    MacCtx.MacState &= ~LORAMAC_TX_DELAYED;
 8033662:	f023 0320 	bic.w	r3, r3, #32
 8033666:	f8c4 3344 	str.w	r3, [r4, #836]	; 0x344
    switch( ScheduleTx( true ) )
 803366a:	f7ff fe77 	bl	803335c <ScheduleTx>
 803366e:	b190      	cbz	r0, 8033696 <OnTxDelayedTimerEvent+0x46>
 8033670:	280b      	cmp	r0, #11
 8033672:	d010      	beq.n	8033696 <OnTxDelayedTimerEvent+0x46>
            MacCtx.McpsConfirm.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 8033674:	f894 3545 	ldrb.w	r3, [r4, #1349]	; 0x545
 8033678:	f884 343e 	strb.w	r3, [r4, #1086]	; 0x43e
            MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR;
 803367c:	2009      	movs	r0, #9
            MacCtx.McpsConfirm.NbRetries = MacCtx.AckTimeoutRetriesCounter;
 803367e:	f894 3416 	ldrb.w	r3, [r4, #1046]	; 0x416
 8033682:	f884 3441 	strb.w	r3, [r4, #1089]	; 0x441
            MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR;
 8033686:	f884 043d 	strb.w	r0, [r4, #1085]	; 0x43d
            LoRaMacConfirmQueueSetStatusCmn( LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR );
 803368a:	f002 fb07 	bl	8035c9c <LoRaMacConfirmQueueSetStatusCmn>
}
 803368e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            StopRetransmission( );
 8033692:	f7ff bc6f 	b.w	8032f74 <StopRetransmission>
}
 8033696:	bd10      	pop	{r4, pc}
 8033698:	20004aa4 	.word	0x20004aa4

0803369c <OpenContinuousRxCWindow>:
{
 803369c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 803369e:	4c12      	ldr	r4, [pc, #72]	; (80336e8 <OpenContinuousRxCWindow+0x4c>)
 80336a0:	f504 7579 	add.w	r5, r4, #996	; 0x3e4
 80336a4:	f8d4 3550 	ldr.w	r3, [r4, #1360]	; 0x550
 80336a8:	f894 2554 	ldrb.w	r2, [r4, #1364]	; 0x554
 80336ac:	f994 157c 	ldrsb.w	r1, [r4, #1404]	; 0x57c
 80336b0:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
 80336b4:	9500      	str	r5, [sp, #0]
 80336b6:	f003 f846 	bl	8036746 <RegionComputeRxWindowParameters>
    MacCtx.RxWindowCConfig.RxContinuous = true;
 80336ba:	f240 2301 	movw	r3, #513	; 0x201
    if( RegionRxConfig( Nvm.MacGroup2.Region, &MacCtx.RxWindowCConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )
 80336be:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    MacCtx.RxWindowCConfig.RxContinuous = true;
 80336c2:	f8a4 33f6 	strh.w	r3, [r4, #1014]	; 0x3f6
    if( RegionRxConfig( Nvm.MacGroup2.Region, &MacCtx.RxWindowCConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )
 80336c6:	f204 4224 	addw	r2, r4, #1060	; 0x424
 80336ca:	4629      	mov	r1, r5
 80336cc:	f003 f84d 	bl	803676a <RegionRxConfig>
 80336d0:	b138      	cbz	r0, 80336e2 <OpenContinuousRxCWindow+0x46>
        Radio.Rx( 0 ); // Continuous mode
 80336d2:	4b06      	ldr	r3, [pc, #24]	; (80336ec <OpenContinuousRxCWindow+0x50>)
 80336d4:	2000      	movs	r0, #0
 80336d6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80336d8:	4798      	blx	r3
        MacCtx.RxSlot = MacCtx.RxWindowCConfig.RxSlot;
 80336da:	f894 33f7 	ldrb.w	r3, [r4, #1015]	; 0x3f7
 80336de:	f884 3484 	strb.w	r3, [r4, #1156]	; 0x484
}
 80336e2:	b003      	add	sp, #12
 80336e4:	bd30      	pop	{r4, r5, pc}
 80336e6:	bf00      	nop
 80336e8:	20004aa4 	.word	0x20004aa4
 80336ec:	0803bbc0 	.word	0x0803bbc0

080336f0 <SwitchClass>:
{
 80336f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    switch( Nvm.MacGroup2.DeviceClass )
 80336f2:	4f2f      	ldr	r7, [pc, #188]	; (80337b0 <SwitchClass+0xc0>)
 80336f4:	f897 5608 	ldrb.w	r5, [r7, #1544]	; 0x608
 80336f8:	2d01      	cmp	r5, #1
{
 80336fa:	4606      	mov	r6, r0
 80336fc:	463c      	mov	r4, r7
    switch( Nvm.MacGroup2.DeviceClass )
 80336fe:	d046      	beq.n	803378e <SwitchClass+0x9e>
 8033700:	2d02      	cmp	r5, #2
 8033702:	d04c      	beq.n	803379e <SwitchClass+0xae>
 8033704:	b945      	cbnz	r5, 8033718 <SwitchClass+0x28>
            if( deviceClass == CLASS_A )
 8033706:	b948      	cbnz	r0, 803371c <SwitchClass+0x2c>
                Nvm.MacGroup2.MacParams.RxCChannel = Nvm.MacGroup2.MacParams.Rx2Channel;
 8033708:	f8d7 1574 	ldr.w	r1, [r7, #1396]	; 0x574
 803370c:	f8d7 0570 	ldr.w	r0, [r7, #1392]	; 0x570
 8033710:	f507 63af 	add.w	r3, r7, #1400	; 0x578
 8033714:	e883 0003 	stmia.w	r3, {r0, r1}
    LoRaMacStatus_t status = LORAMAC_STATUS_PARAMETER_INVALID;
 8033718:	2503      	movs	r5, #3
 803371a:	e036      	b.n	803378a <SwitchClass+0x9a>
            if( deviceClass == CLASS_B )
 803371c:	2801      	cmp	r0, #1
 803371e:	d036      	beq.n	803378e <SwitchClass+0x9e>
            if( deviceClass == CLASS_C )
 8033720:	2802      	cmp	r0, #2
 8033722:	d1f9      	bne.n	8033718 <SwitchClass+0x28>
                MacCtx.RxWindowCConfig = MacCtx.RxWindow2Config;
 8033724:	f504 7c74 	add.w	ip, r4, #976	; 0x3d0
                Nvm.MacGroup2.DeviceClass = deviceClass;
 8033728:	f884 0608 	strb.w	r0, [r4, #1544]	; 0x608
                MacCtx.RxWindowCConfig = MacCtx.RxWindow2Config;
 803372c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8033730:	f507 7779 	add.w	r7, r7, #996	; 0x3e4
 8033734:	c70f      	stmia	r7!, {r0, r1, r2, r3}
 8033736:	f8dc 3000 	ldr.w	r3, [ip]
 803373a:	603b      	str	r3, [r7, #0]
                    if( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.IsEnabled == true )
 803373c:	f894 35de 	ldrb.w	r3, [r4, #1502]	; 0x5de
                MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C;
 8033740:	f884 63f7 	strb.w	r6, [r4, #1015]	; 0x3f7
                    if( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.IsEnabled == true )
 8033744:	b1cb      	cbz	r3, 803377a <SwitchClass+0x8a>
                        Nvm.MacGroup2.MacParams.RxCChannel.Frequency = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.RxParams.ClassC.Frequency;
 8033746:	f8d4 35f4 	ldr.w	r3, [r4, #1524]	; 0x5f4
 803374a:	f8c4 3578 	str.w	r3, [r4, #1400]	; 0x578
                        MacCtx.RxWindowCConfig.Frequency = Nvm.MacGroup2.MacParams.RxCChannel.Frequency;
 803374e:	f8c4 33e8 	str.w	r3, [r4, #1000]	; 0x3e8
                        MacCtx.RxWindowCConfig.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 8033752:	f894 3581 	ldrb.w	r3, [r4, #1409]	; 0x581
                        Nvm.MacGroup2.MacParams.RxCChannel.Datarate = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.RxParams.ClassC.Datarate;
 8033756:	f894 25f8 	ldrb.w	r2, [r4, #1528]	; 0x5f8
                        MacCtx.RxWindowCConfig.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 803375a:	f884 33f4 	strb.w	r3, [r4, #1012]	; 0x3f4
                        MacCtx.RxWindowCConfig.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport; /* ST_WORKAROUND: Keep repeater feature */
 803375e:	f894 358c 	ldrb.w	r3, [r4, #1420]	; 0x58c
                        Nvm.MacGroup2.MacParams.RxCChannel.Datarate = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.RxParams.ClassC.Datarate;
 8033762:	f884 257c 	strb.w	r2, [r4, #1404]	; 0x57c
                        MacCtx.RxWindowCConfig.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport; /* ST_WORKAROUND: Keep repeater feature */
 8033766:	f884 33f5 	strb.w	r3, [r4, #1013]	; 0x3f5
                        MacCtx.RxWindowCConfig.Channel = MacCtx.Channel;
 803376a:	f894 2419 	ldrb.w	r2, [r4, #1049]	; 0x419
 803376e:	f884 23e4 	strb.w	r2, [r4, #996]	; 0x3e4
                        MacCtx.RxWindowCConfig.RxContinuous = true;
 8033772:	f240 3301 	movw	r3, #769	; 0x301
 8033776:	f8a4 33f6 	strh.w	r3, [r4, #1014]	; 0x3f6
                MacCtx.NodeAckRequested = false;
 803377a:	2300      	movs	r3, #0
 803377c:	f884 3418 	strb.w	r3, [r4, #1048]	; 0x418
                Radio.Sleep( );
 8033780:	4b0c      	ldr	r3, [pc, #48]	; (80337b4 <SwitchClass+0xc4>)
 8033782:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8033784:	4798      	blx	r3
                OpenContinuousRxCWindow( );
 8033786:	f7ff ff89 	bl	803369c <OpenContinuousRxCWindow>
}
 803378a:	4628      	mov	r0, r5
 803378c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            status = LoRaMacClassBSwitchClass( deviceClass );
 803378e:	f002 f8e3 	bl	8035958 <LoRaMacClassBSwitchClass>
            if( status == LORAMAC_STATUS_OK )
 8033792:	4605      	mov	r5, r0
 8033794:	2800      	cmp	r0, #0
 8033796:	d1f8      	bne.n	803378a <SwitchClass+0x9a>
                Nvm.MacGroup2.DeviceClass = deviceClass;
 8033798:	f887 6608 	strb.w	r6, [r7, #1544]	; 0x608
 803379c:	e7f5      	b.n	803378a <SwitchClass+0x9a>
            if( deviceClass == CLASS_A )
 803379e:	2800      	cmp	r0, #0
 80337a0:	d1ba      	bne.n	8033718 <SwitchClass+0x28>
                Radio.Sleep( );
 80337a2:	4b04      	ldr	r3, [pc, #16]	; (80337b4 <SwitchClass+0xc4>)
                Nvm.MacGroup2.DeviceClass = deviceClass;
 80337a4:	f887 0608 	strb.w	r0, [r7, #1544]	; 0x608
                Radio.Sleep( );
 80337a8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80337aa:	4798      	blx	r3
                status = LORAMAC_STATUS_OK;
 80337ac:	4635      	mov	r5, r6
 80337ae:	e7ec      	b.n	803378a <SwitchClass+0x9a>
 80337b0:	20004aa4 	.word	0x20004aa4
 80337b4:	0803bbc0 	.word	0x0803bbc0

080337b8 <RxWindowSetup.constprop.0>:
static void RxWindowSetup( TimerEvent_t* rxTimer, RxConfigParams_t* rxConfig )
 80337b8:	b570      	push	{r4, r5, r6, lr}
    Radio.Standby( );
 80337ba:	4e0b      	ldr	r6, [pc, #44]	; (80337e8 <RxWindowSetup.constprop.0+0x30>)
    if( RegionRxConfig( Nvm.MacGroup2.Region, rxConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )
 80337bc:	4c0b      	ldr	r4, [pc, #44]	; (80337ec <RxWindowSetup.constprop.0+0x34>)
static void RxWindowSetup( TimerEvent_t* rxTimer, RxConfigParams_t* rxConfig )
 80337be:	460d      	mov	r5, r1
    TimerStop( rxTimer );
 80337c0:	f007 fd86 	bl	803b2d0 <UTIL_TIMER_Stop>
    Radio.Standby( );
 80337c4:	6b33      	ldr	r3, [r6, #48]	; 0x30
 80337c6:	4798      	blx	r3
    if( RegionRxConfig( Nvm.MacGroup2.Region, rxConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )
 80337c8:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
 80337cc:	f204 4224 	addw	r2, r4, #1060	; 0x424
 80337d0:	4629      	mov	r1, r5
 80337d2:	f002 ffca 	bl	803676a <RegionRxConfig>
 80337d6:	b130      	cbz	r0, 80337e6 <RxWindowSetup.constprop.0+0x2e>
        Radio.Rx( Nvm.MacGroup2.MacParams.MaxRxWindow );
 80337d8:	6b73      	ldr	r3, [r6, #52]	; 0x34
 80337da:	f8d4 0558 	ldr.w	r0, [r4, #1368]	; 0x558
 80337de:	4798      	blx	r3
        MacCtx.RxSlot = rxConfig->RxSlot;
 80337e0:	7ceb      	ldrb	r3, [r5, #19]
 80337e2:	f884 3484 	strb.w	r3, [r4, #1156]	; 0x484
}
 80337e6:	bd70      	pop	{r4, r5, r6, pc}
 80337e8:	0803bbc0 	.word	0x0803bbc0
 80337ec:	20004aa4 	.word	0x20004aa4

080337f0 <OnRxWindow1TimerEvent>:
    MacCtx.RxWindow1Config.Channel = MacCtx.Channel;
 80337f0:	480c      	ldr	r0, [pc, #48]	; (8033824 <OnRxWindow1TimerEvent+0x34>)
 80337f2:	f890 3419 	ldrb.w	r3, [r0, #1049]	; 0x419
 80337f6:	f880 33bc 	strb.w	r3, [r0, #956]	; 0x3bc
    MacCtx.RxWindow1Config.DrOffset = Nvm.MacGroup2.MacParams.Rx1DrOffset;
 80337fa:	f890 356d 	ldrb.w	r3, [r0, #1389]	; 0x56d
 80337fe:	f880 33bf 	strb.w	r3, [r0, #959]	; 0x3bf
    MacCtx.RxWindow1Config.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 8033802:	f890 3581 	ldrb.w	r3, [r0, #1409]	; 0x581
 8033806:	f880 33cc 	strb.w	r3, [r0, #972]	; 0x3cc
    MacCtx.RxWindow1Config.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport; /* ST_WORKAROUND: Keep repeater feature */
 803380a:	f890 358c 	ldrb.w	r3, [r0, #1420]	; 0x58c
 803380e:	f880 33cd 	strb.w	r3, [r0, #973]	; 0x3cd
    MacCtx.RxWindow1Config.RxContinuous = false;
 8033812:	2300      	movs	r3, #0
 8033814:	f8a0 33ce 	strh.w	r3, [r0, #974]	; 0x3ce
    RxWindowSetup( &MacCtx.RxWindowTimer1, &MacCtx.RxWindow1Config );
 8033818:	f500 716f 	add.w	r1, r0, #956	; 0x3bc
 803381c:	f500 7061 	add.w	r0, r0, #900	; 0x384
 8033820:	f7ff bfca 	b.w	80337b8 <RxWindowSetup.constprop.0>
 8033824:	20004aa4 	.word	0x20004aa4

08033828 <OnRxWindow2TimerEvent>:
    if( MacCtx.RxSlot == RX_SLOT_WIN_1 )
 8033828:	480f      	ldr	r0, [pc, #60]	; (8033868 <OnRxWindow2TimerEvent+0x40>)
 803382a:	f890 3484 	ldrb.w	r3, [r0, #1156]	; 0x484
 803382e:	b1cb      	cbz	r3, 8033864 <OnRxWindow2TimerEvent+0x3c>
    MacCtx.RxWindow2Config.Channel = MacCtx.Channel;
 8033830:	f890 3419 	ldrb.w	r3, [r0, #1049]	; 0x419
 8033834:	f880 33d0 	strb.w	r3, [r0, #976]	; 0x3d0
    MacCtx.RxWindow2Config.Frequency = Nvm.MacGroup2.MacParams.Rx2Channel.Frequency;
 8033838:	f8d0 3570 	ldr.w	r3, [r0, #1392]	; 0x570
 803383c:	f8c0 33d4 	str.w	r3, [r0, #980]	; 0x3d4
    MacCtx.RxWindow2Config.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 8033840:	f890 3581 	ldrb.w	r3, [r0, #1409]	; 0x581
 8033844:	f880 33e0 	strb.w	r3, [r0, #992]	; 0x3e0
    MacCtx.RxWindow2Config.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport; /* ST_WORKAROUND: Keep repeater feature */
 8033848:	f890 358c 	ldrb.w	r3, [r0, #1420]	; 0x58c
 803384c:	f880 33e1 	strb.w	r3, [r0, #993]	; 0x3e1
    MacCtx.RxWindow2Config.RxContinuous = false;
 8033850:	f44f 7380 	mov.w	r3, #256	; 0x100
 8033854:	f8a0 33e2 	strh.w	r3, [r0, #994]	; 0x3e2
    RxWindowSetup( &MacCtx.RxWindowTimer2, &MacCtx.RxWindow2Config );
 8033858:	f500 7174 	add.w	r1, r0, #976	; 0x3d0
 803385c:	f500 7067 	add.w	r0, r0, #924	; 0x39c
 8033860:	f7ff bfaa 	b.w	80337b8 <RxWindowSetup.constprop.0>
}
 8033864:	4770      	bx	lr
 8033866:	bf00      	nop
 8033868:	20004aa4 	.word	0x20004aa4

0803386c <ProcessMacCommands.isra.0.constprop.0>:
static void ProcessMacCommands( uint8_t *payload, uint8_t macIndex, uint8_t commandsSize, int8_t snr, LoRaMacRxSlot_t rxSlot )
 803386c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8033870:	b091      	sub	sp, #68	; 0x44
    uint8_t status = 0;
 8033872:	2700      	movs	r7, #0
                    if( ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_PING_SLOT ) && ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT ) )
 8033874:	4dc3      	ldr	r5, [pc, #780]	; (8033b84 <ProcessMacCommands.isra.0.constprop.0+0x318>)
    uint8_t status = 0;
 8033876:	f88d 7015 	strb.w	r7, [sp, #21]
static void ProcessMacCommands( uint8_t *payload, uint8_t macIndex, uint8_t commandsSize, int8_t snr, LoRaMacRxSlot_t rxSlot )
 803387a:	4606      	mov	r6, r0
 803387c:	4688      	mov	r8, r1
 803387e:	4693      	mov	fp, r2
    uint8_t macCmdPayload[2] = { 0x00, 0x00 };
 8033880:	f8ad 7018 	strh.w	r7, [sp, #24]
    while( macIndex < commandsSize )
 8033884:	46b9      	mov	r9, r7
 8033886:	45c1      	cmp	r9, r8
 8033888:	d302      	bcc.n	8033890 <ProcessMacCommands.isra.0.constprop.0+0x24>
}
 803388a:	b011      	add	sp, #68	; 0x44
 803388c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if( ( LoRaMacCommandsGetCmdSize( payload[macIndex] ) + macIndex ) > commandsSize )
 8033890:	f816 0009 	ldrb.w	r0, [r6, r9]
 8033894:	f002 f96c 	bl	8035b70 <LoRaMacCommandsGetCmdSize>
 8033898:	4448      	add	r0, r9
 803389a:	4540      	cmp	r0, r8
 803389c:	dcf5      	bgt.n	803388a <ProcessMacCommands.isra.0.constprop.0+0x1e>
        switch( payload[macIndex++] )
 803389e:	f816 3009 	ldrb.w	r3, [r6, r9]
 80338a2:	f109 0401 	add.w	r4, r9, #1
 80338a6:	3b02      	subs	r3, #2
 80338a8:	b2e4      	uxtb	r4, r4
 80338aa:	2b11      	cmp	r3, #17
 80338ac:	d8ed      	bhi.n	803388a <ProcessMacCommands.isra.0.constprop.0+0x1e>
 80338ae:	a201      	add	r2, pc, #4	; (adr r2, 80338b4 <ProcessMacCommands.isra.0.constprop.0+0x48>)
 80338b0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80338b4:	080338fd 	.word	0x080338fd
 80338b8:	0803392d 	.word	0x0803392d
 80338bc:	080339e9 	.word	0x080339e9
 80338c0:	08033a11 	.word	0x08033a11
 80338c4:	08033aa9 	.word	0x08033aa9
 80338c8:	08033ad1 	.word	0x08033ad1
 80338cc:	08033b43 	.word	0x08033b43
 80338d0:	08033b89 	.word	0x08033b89
 80338d4:	08033c11 	.word	0x08033c11
 80338d8:	0803388b 	.word	0x0803388b
 80338dc:	0803388b 	.word	0x0803388b
 80338e0:	08033c6f 	.word	0x08033c6f
 80338e4:	0803388b 	.word	0x0803388b
 80338e8:	0803388b 	.word	0x0803388b
 80338ec:	08033d25 	.word	0x08033d25
 80338f0:	08033d4b 	.word	0x08033d4b
 80338f4:	08033d8f 	.word	0x08033d8f
 80338f8:	08033dcd 	.word	0x08033dcd
                if( LoRaMacConfirmQueueIsCmdActive( MLME_LINK_CHECK ) == true )
 80338fc:	2004      	movs	r0, #4
 80338fe:	f002 f9e7 	bl	8035cd0 <LoRaMacConfirmQueueIsCmdActive>
 8033902:	b188      	cbz	r0, 8033928 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_LINK_CHECK );
 8033904:	2104      	movs	r1, #4
 8033906:	2000      	movs	r0, #0
 8033908:	f002 f9a6 	bl	8035c58 <LoRaMacConfirmQueueSetStatus>
                    MacCtx.MlmeConfirm.DemodMargin = payload[macIndex++];
 803390c:	5d33      	ldrb	r3, [r6, r4]
 803390e:	f885 3458 	strb.w	r3, [r5, #1112]	; 0x458
                    MacCtx.MlmeConfirm.NbGateways = payload[macIndex++];
 8033912:	f109 0403 	add.w	r4, r9, #3
                    MacCtx.MlmeConfirm.DemodMargin = payload[macIndex++];
 8033916:	f109 0902 	add.w	r9, r9, #2
                    MacCtx.MlmeConfirm.NbGateways = payload[macIndex++];
 803391a:	fa5f f989 	uxtb.w	r9, r9
 803391e:	b2e4      	uxtb	r4, r4
 8033920:	f816 3009 	ldrb.w	r3, [r6, r9]
 8033924:	f885 3459 	strb.w	r3, [r5, #1113]	; 0x459
                uint8_t eirpDwellTime = payload[macIndex++];
 8033928:	46a1      	mov	r9, r4
 803392a:	e7ac      	b.n	8033886 <ProcessMacCommands.isra.0.constprop.0+0x1a>
                int8_t linkAdrDatarate = DR_0;
 803392c:	2300      	movs	r3, #0
 803392e:	f88d 3016 	strb.w	r3, [sp, #22]
                int8_t linkAdrTxPower = TX_POWER_0;
 8033932:	f88d 3017 	strb.w	r3, [sp, #23]
                uint8_t linkAdrNbRep = 0;
 8033936:	f88d 301c 	strb.w	r3, [sp, #28]
                uint8_t linkAdrNbBytesParsed = 0;
 803393a:	f88d 3020 	strb.w	r3, [sp, #32]
                if( adrBlockFound == false )
 803393e:	2f00      	cmp	r7, #0
 8033940:	d150      	bne.n	80339e4 <ProcessMacCommands.isra.0.constprop.0+0x178>
                    linkAdrReq.PayloadSize = commandsSize - ( macIndex - 1 );
 8033942:	eba8 0309 	sub.w	r3, r8, r9
 8033946:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
                    linkAdrReq.AdrEnabled = Nvm.MacGroup2.AdrCtrlOn;
 803394a:	f895 360a 	ldrb.w	r3, [r5, #1546]	; 0x60a
 803394e:	f88d 303a 	strb.w	r3, [sp, #58]	; 0x3a
                    linkAdrReq.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8033952:	f895 3580 	ldrb.w	r3, [r5, #1408]	; 0x580
 8033956:	f88d 3039 	strb.w	r3, [sp, #57]	; 0x39
                    linkAdrReq.CurrentDatarate = Nvm.MacGroup1.ChannelsDatarate;
 803395a:	f895 3545 	ldrb.w	r3, [r5, #1349]	; 0x545
 803395e:	f88d 303b 	strb.w	r3, [sp, #59]	; 0x3b
                    linkAdrReq.CurrentTxPower = Nvm.MacGroup1.ChannelsTxPower;
 8033962:	f895 3544 	ldrb.w	r3, [r5, #1348]	; 0x544
 8033966:	f88d 303c 	strb.w	r3, [sp, #60]	; 0x3c
                    linkAdrReq.CurrentNbRep = Nvm.MacGroup2.MacParams.ChannelsNbTrans;
 803396a:	f895 356c 	ldrb.w	r3, [r5, #1388]	; 0x56c
 803396e:	f88d 303d 	strb.w	r3, [sp, #61]	; 0x3d
                    linkAdrReq.Version = Nvm.MacGroup2.Version;
 8033972:	f8d5 3618 	ldr.w	r3, [r5, #1560]	; 0x618
 8033976:	930c      	str	r3, [sp, #48]	; 0x30
                    status = RegionLinkAdrReq( Nvm.MacGroup2.Region, &linkAdrReq, &linkAdrDatarate,
 8033978:	ab08      	add	r3, sp, #32
 803397a:	9301      	str	r3, [sp, #4]
                    linkAdrReq.Payload = &payload[macIndex - 1];
 803397c:	3c01      	subs	r4, #1
                    status = RegionLinkAdrReq( Nvm.MacGroup2.Region, &linkAdrReq, &linkAdrDatarate,
 803397e:	ab07      	add	r3, sp, #28
 8033980:	9300      	str	r3, [sp, #0]
 8033982:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
                    linkAdrReq.Payload = &payload[macIndex - 1];
 8033986:	4434      	add	r4, r6
                    status = RegionLinkAdrReq( Nvm.MacGroup2.Region, &linkAdrReq, &linkAdrDatarate,
 8033988:	f10d 0317 	add.w	r3, sp, #23
 803398c:	f10d 0216 	add.w	r2, sp, #22
 8033990:	a90c      	add	r1, sp, #48	; 0x30
                    linkAdrReq.Payload = &payload[macIndex - 1];
 8033992:	940d      	str	r4, [sp, #52]	; 0x34
                    status = RegionLinkAdrReq( Nvm.MacGroup2.Region, &linkAdrReq, &linkAdrDatarate,
 8033994:	f002 ff08 	bl	80367a8 <RegionLinkAdrReq>
 8033998:	f88d 0015 	strb.w	r0, [sp, #21]
                    if( ( status & 0x07 ) == 0x07 )
 803399c:	f000 0007 	and.w	r0, r0, #7
 80339a0:	2807      	cmp	r0, #7
 80339a2:	d10b      	bne.n	80339bc <ProcessMacCommands.isra.0.constprop.0+0x150>
                        Nvm.MacGroup1.ChannelsDatarate = linkAdrDatarate;
 80339a4:	f89d 3016 	ldrb.w	r3, [sp, #22]
 80339a8:	f885 3545 	strb.w	r3, [r5, #1349]	; 0x545
                        Nvm.MacGroup1.ChannelsTxPower = linkAdrTxPower;
 80339ac:	f89d 3017 	ldrb.w	r3, [sp, #23]
 80339b0:	f885 3544 	strb.w	r3, [r5, #1348]	; 0x544
                        Nvm.MacGroup2.MacParams.ChannelsNbTrans = linkAdrNbRep;
 80339b4:	f89d 301c 	ldrb.w	r3, [sp, #28]
 80339b8:	f885 356c 	strb.w	r3, [r5, #1388]	; 0x56c
static void ProcessMacCommands( uint8_t *payload, uint8_t macIndex, uint8_t commandsSize, int8_t snr, LoRaMacRxSlot_t rxSlot )
 80339bc:	2700      	movs	r7, #0
                    for( uint8_t i = 0; i < ( linkAdrNbBytesParsed / 5 ); i++ )
 80339be:	f04f 0a05 	mov.w	sl, #5
 80339c2:	e006      	b.n	80339d2 <ProcessMacCommands.isra.0.constprop.0+0x166>
                        LoRaMacCommandsAddCmd( MOTE_MAC_LINK_ADR_ANS, &status, 1 );
 80339c4:	2201      	movs	r2, #1
 80339c6:	f10d 0115 	add.w	r1, sp, #21
 80339ca:	2003      	movs	r0, #3
 80339cc:	f001 ffe4 	bl	8035998 <LoRaMacCommandsAddCmd>
                    for( uint8_t i = 0; i < ( linkAdrNbBytesParsed / 5 ); i++ )
 80339d0:	3701      	adds	r7, #1
 80339d2:	b2fb      	uxtb	r3, r7
 80339d4:	f89d 4020 	ldrb.w	r4, [sp, #32]
 80339d8:	fbb4 f2fa 	udiv	r2, r4, sl
 80339dc:	429a      	cmp	r2, r3
 80339de:	d8f1      	bhi.n	80339c4 <ProcessMacCommands.isra.0.constprop.0+0x158>
                    macIndex += linkAdrNbBytesParsed - 1;
 80339e0:	444c      	add	r4, r9
 80339e2:	b2e4      	uxtb	r4, r4
                break;
 80339e4:	2701      	movs	r7, #1
 80339e6:	e79f      	b.n	8033928 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                Nvm.MacGroup2.MaxDCycle = payload[macIndex++] & 0x0F;
 80339e8:	5d33      	ldrb	r3, [r6, r4]
                Nvm.MacGroup2.AggregatedDCycle = 1 << Nvm.MacGroup2.MaxDCycle;
 80339ea:	2201      	movs	r2, #1
                Nvm.MacGroup2.MaxDCycle = payload[macIndex++] & 0x0F;
 80339ec:	f003 030f 	and.w	r3, r3, #15
 80339f0:	f109 0902 	add.w	r9, r9, #2
 80339f4:	f885 360b 	strb.w	r3, [r5, #1547]	; 0x60b
                Nvm.MacGroup2.AggregatedDCycle = 1 << Nvm.MacGroup2.MaxDCycle;
 80339f8:	fa02 f303 	lsl.w	r3, r2, r3
                Nvm.MacGroup2.MaxDCycle = payload[macIndex++] & 0x0F;
 80339fc:	fa5f f989 	uxtb.w	r9, r9
                Nvm.MacGroup2.AggregatedDCycle = 1 << Nvm.MacGroup2.MaxDCycle;
 8033a00:	f8a5 360e 	strh.w	r3, [r5, #1550]	; 0x60e
                LoRaMacCommandsAddCmd( MOTE_MAC_DUTY_CYCLE_ANS, macCmdPayload, 0 );
 8033a04:	2200      	movs	r2, #0
 8033a06:	a906      	add	r1, sp, #24
 8033a08:	2004      	movs	r0, #4
                    LoRaMacCommandsAddCmd( MOTE_MAC_TX_PARAM_SETUP_ANS, macCmdPayload, 0 );
 8033a0a:	f001 ffc5 	bl	8035998 <LoRaMacCommandsAddCmd>
                break;
 8033a0e:	e0b7      	b.n	8033b80 <ProcessMacCommands.isra.0.constprop.0+0x314>
                status = 0x07;
 8033a10:	2307      	movs	r3, #7
 8033a12:	f88d 3015 	strb.w	r3, [sp, #21]
                rxParamSetupReq.DrOffset = ( payload[macIndex] >> 4 ) & 0x07;
 8033a16:	5d33      	ldrb	r3, [r6, r4]
                status = RegionRxParamSetupReq( Nvm.MacGroup2.Region, &rxParamSetupReq );
 8033a18:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
                rxParamSetupReq.DrOffset = ( payload[macIndex] >> 4 ) & 0x07;
 8033a1c:	f3c3 1202 	ubfx	r2, r3, #4, #3
                rxParamSetupReq.Datarate = payload[macIndex] & 0x0F;
 8033a20:	f003 030f 	and.w	r3, r3, #15
                rxParamSetupReq.DrOffset = ( payload[macIndex] >> 4 ) & 0x07;
 8033a24:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
                rxParamSetupReq.Datarate = payload[macIndex] & 0x0F;
 8033a28:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033a2c:	f109 0204 	add.w	r2, r9, #4
                rxParamSetupReq.Frequency = ( uint32_t ) payload[macIndex++];
 8033a30:	f109 0303 	add.w	r3, r9, #3
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033a34:	b2db      	uxtb	r3, r3
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033a36:	b2d2      	uxtb	r2, r2
 8033a38:	f109 0405 	add.w	r4, r9, #5
                macIndex++;
 8033a3c:	f109 0902 	add.w	r9, r9, #2
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033a40:	5cf1      	ldrb	r1, [r6, r3]
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033a42:	5cb3      	ldrb	r3, [r6, r2]
                rxParamSetupReq.Frequency = ( uint32_t ) payload[macIndex++];
 8033a44:	fa5f f989 	uxtb.w	r9, r9
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033a48:	041b      	lsls	r3, r3, #16
                rxParamSetupReq.Frequency = ( uint32_t ) payload[macIndex++];
 8033a4a:	f816 2009 	ldrb.w	r2, [r6, r9]
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033a4e:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8033a52:	4313      	orrs	r3, r2
                rxParamSetupReq.Frequency *= 100;
 8033a54:	2264      	movs	r2, #100	; 0x64
 8033a56:	4353      	muls	r3, r2
                status = RegionRxParamSetupReq( Nvm.MacGroup2.Region, &rxParamSetupReq );
 8033a58:	a90c      	add	r1, sp, #48	; 0x30
                rxParamSetupReq.Frequency *= 100;
 8033a5a:	930d      	str	r3, [sp, #52]	; 0x34
                status = RegionRxParamSetupReq( Nvm.MacGroup2.Region, &rxParamSetupReq );
 8033a5c:	f002 feba 	bl	80367d4 <RegionRxParamSetupReq>
                if( ( status & 0x07 ) == 0x07 )
 8033a60:	f000 0307 	and.w	r3, r0, #7
 8033a64:	2b07      	cmp	r3, #7
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033a66:	b2e4      	uxtb	r4, r4
                status = RegionRxParamSetupReq( Nvm.MacGroup2.Region, &rxParamSetupReq );
 8033a68:	f88d 0015 	strb.w	r0, [sp, #21]
                if( ( status & 0x07 ) == 0x07 )
 8033a6c:	d10e      	bne.n	8033a8c <ProcessMacCommands.isra.0.constprop.0+0x220>
                    Nvm.MacGroup2.MacParams.Rx2Channel.Datarate = rxParamSetupReq.Datarate;
 8033a6e:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
 8033a72:	f885 3574 	strb.w	r3, [r5, #1396]	; 0x574
                    Nvm.MacGroup2.MacParams.RxCChannel.Datarate = rxParamSetupReq.Datarate;
 8033a76:	f885 357c 	strb.w	r3, [r5, #1404]	; 0x57c
                    Nvm.MacGroup2.MacParams.Rx2Channel.Frequency = rxParamSetupReq.Frequency;
 8033a7a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8033a7c:	f8c5 3570 	str.w	r3, [r5, #1392]	; 0x570
                    Nvm.MacGroup2.MacParams.RxCChannel.Frequency = rxParamSetupReq.Frequency;
 8033a80:	f8c5 3578 	str.w	r3, [r5, #1400]	; 0x578
                    Nvm.MacGroup2.MacParams.Rx1DrOffset = rxParamSetupReq.DrOffset;
 8033a84:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
 8033a88:	f885 356d 	strb.w	r3, [r5, #1389]	; 0x56d
                macCmdPayload[0] = status;
 8033a8c:	f88d 0018 	strb.w	r0, [sp, #24]
                LoRaMacCommandsAddCmd( MOTE_MAC_RX_PARAM_SETUP_ANS, macCmdPayload, 1 );
 8033a90:	2201      	movs	r2, #1
 8033a92:	a906      	add	r1, sp, #24
 8033a94:	2005      	movs	r0, #5
                    LoRaMacCommandsAddCmd( MOTE_MAC_DL_CHANNEL_ANS, macCmdPayload, 1 );
 8033a96:	f001 ff7f 	bl	8035998 <LoRaMacCommandsAddCmd>
    MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 1;
 8033a9a:	f895 3485 	ldrb.w	r3, [r5, #1157]	; 0x485
 8033a9e:	f043 0310 	orr.w	r3, r3, #16
 8033aa2:	f885 3485 	strb.w	r3, [r5, #1157]	; 0x485
}
 8033aa6:	e73f      	b.n	8033928 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->GetBatteryLevel != NULL ) )
 8033aa8:	f8d5 334c 	ldr.w	r3, [r5, #844]	; 0x34c
 8033aac:	b173      	cbz	r3, 8033acc <ProcessMacCommands.isra.0.constprop.0+0x260>
 8033aae:	681b      	ldr	r3, [r3, #0]
 8033ab0:	b163      	cbz	r3, 8033acc <ProcessMacCommands.isra.0.constprop.0+0x260>
                    batteryLevel = MacCtx.MacCallbacks->GetBatteryLevel( );
 8033ab2:	4798      	blx	r3
                macCmdPayload[1] = ( uint8_t )( snr & 0x3F );
 8033ab4:	f00b 033f 	and.w	r3, fp, #63	; 0x3f
                macCmdPayload[0] = batteryLevel;
 8033ab8:	f88d 0018 	strb.w	r0, [sp, #24]
                macCmdPayload[1] = ( uint8_t )( snr & 0x3F );
 8033abc:	f88d 3019 	strb.w	r3, [sp, #25]
                LoRaMacCommandsAddCmd( MOTE_MAC_DEV_STATUS_ANS, macCmdPayload, 2 );
 8033ac0:	2202      	movs	r2, #2
 8033ac2:	a906      	add	r1, sp, #24
 8033ac4:	2006      	movs	r0, #6
                    LoRaMacCommandsAddCmd( MOTE_MAC_BEACON_FREQ_ANS, macCmdPayload, 1 );
 8033ac6:	f001 ff67 	bl	8035998 <LoRaMacCommandsAddCmd>
                break;
 8033aca:	e72d      	b.n	8033928 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                uint8_t batteryLevel = BAT_LEVEL_NO_MEASURE;
 8033acc:	20ff      	movs	r0, #255	; 0xff
 8033ace:	e7f1      	b.n	8033ab4 <ProcessMacCommands.isra.0.constprop.0+0x248>
                status = 0x03;
 8033ad0:	2303      	movs	r3, #3
 8033ad2:	f88d 3015 	strb.w	r3, [sp, #21]
                newChannelReq.ChannelId = payload[macIndex++];
 8033ad6:	5d33      	ldrb	r3, [r6, r4]
 8033ad8:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
                newChannelReq.NewChannel = &chParam;
 8033adc:	ab0c      	add	r3, sp, #48	; 0x30
 8033ade:	9308      	str	r3, [sp, #32]
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033ae0:	f109 0204 	add.w	r2, r9, #4
                chParam.Frequency = ( uint32_t ) payload[macIndex++];
 8033ae4:	f109 0303 	add.w	r3, r9, #3
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033ae8:	b2db      	uxtb	r3, r3
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033aea:	b2d2      	uxtb	r2, r2
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033aec:	5cf1      	ldrb	r1, [r6, r3]
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033aee:	5cb3      	ldrb	r3, [r6, r2]
                status = ( uint8_t )RegionNewChannelReq( Nvm.MacGroup2.Region, &newChannelReq );
 8033af0:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
                newChannelReq.ChannelId = payload[macIndex++];
 8033af4:	f109 0202 	add.w	r2, r9, #2
                chParam.Frequency = ( uint32_t ) payload[macIndex++];
 8033af8:	b2d2      	uxtb	r2, r2
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033afa:	041b      	lsls	r3, r3, #16
                chParam.Frequency = ( uint32_t ) payload[macIndex++];
 8033afc:	5cb2      	ldrb	r2, [r6, r2]
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033afe:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8033b02:	4313      	orrs	r3, r2
                chParam.DrRange.Value = payload[macIndex++];
 8033b04:	f109 0406 	add.w	r4, r9, #6
                chParam.Frequency *= 100;
 8033b08:	2264      	movs	r2, #100	; 0x64
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033b0a:	f109 0905 	add.w	r9, r9, #5
                chParam.Frequency *= 100;
 8033b0e:	4353      	muls	r3, r2
                chParam.DrRange.Value = payload[macIndex++];
 8033b10:	fa5f f989 	uxtb.w	r9, r9
                chParam.Frequency *= 100;
 8033b14:	930c      	str	r3, [sp, #48]	; 0x30
                chParam.Rx1Frequency = 0;
 8033b16:	2300      	movs	r3, #0
 8033b18:	930d      	str	r3, [sp, #52]	; 0x34
                status = ( uint8_t )RegionNewChannelReq( Nvm.MacGroup2.Region, &newChannelReq );
 8033b1a:	a908      	add	r1, sp, #32
                chParam.DrRange.Value = payload[macIndex++];
 8033b1c:	f816 3009 	ldrb.w	r3, [r6, r9]
 8033b20:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
                status = ( uint8_t )RegionNewChannelReq( Nvm.MacGroup2.Region, &newChannelReq );
 8033b24:	f002 fe62 	bl	80367ec <RegionNewChannelReq>
 8033b28:	b2c3      	uxtb	r3, r0
                if( ( int8_t )status >= 0 )
 8033b2a:	2800      	cmp	r0, #0
                chParam.DrRange.Value = payload[macIndex++];
 8033b2c:	b2e4      	uxtb	r4, r4
                status = ( uint8_t )RegionNewChannelReq( Nvm.MacGroup2.Region, &newChannelReq );
 8033b2e:	f88d 3015 	strb.w	r3, [sp, #21]
                if( ( int8_t )status >= 0 )
 8033b32:	f6ff aef9 	blt.w	8033928 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                    macCmdPayload[0] = status;
 8033b36:	f88d 3018 	strb.w	r3, [sp, #24]
                    LoRaMacCommandsAddCmd( MOTE_MAC_NEW_CHANNEL_ANS, macCmdPayload, 1 );
 8033b3a:	2201      	movs	r2, #1
 8033b3c:	a906      	add	r1, sp, #24
 8033b3e:	2007      	movs	r0, #7
 8033b40:	e7c1      	b.n	8033ac6 <ProcessMacCommands.isra.0.constprop.0+0x25a>
                uint8_t delay = payload[macIndex++] & 0x0F;
 8033b42:	5d33      	ldrb	r3, [r6, r4]
 8033b44:	f003 030f 	and.w	r3, r3, #15
                Nvm.MacGroup2.MacParams.ReceiveDelay1 = delay * 1000;
 8033b48:	2b01      	cmp	r3, #1
 8033b4a:	bf38      	it	cc
 8033b4c:	2301      	movcc	r3, #1
 8033b4e:	461a      	mov	r2, r3
 8033b50:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8033b54:	4353      	muls	r3, r2
 8033b56:	f8c5 355c 	str.w	r3, [r5, #1372]	; 0x55c
                LoRaMacCommandsAddCmd( MOTE_MAC_RX_TIMING_SETUP_ANS, macCmdPayload, 0 );
 8033b5a:	2200      	movs	r2, #0
                Nvm.MacGroup2.MacParams.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay1 + 1000;
 8033b5c:	f503 737a 	add.w	r3, r3, #1000	; 0x3e8
                LoRaMacCommandsAddCmd( MOTE_MAC_RX_TIMING_SETUP_ANS, macCmdPayload, 0 );
 8033b60:	a906      	add	r1, sp, #24
 8033b62:	2008      	movs	r0, #8
                Nvm.MacGroup2.MacParams.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay1 + 1000;
 8033b64:	f8c5 3560 	str.w	r3, [r5, #1376]	; 0x560
                LoRaMacCommandsAddCmd( MOTE_MAC_RX_TIMING_SETUP_ANS, macCmdPayload, 0 );
 8033b68:	f001 ff16 	bl	8035998 <LoRaMacCommandsAddCmd>
    MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 1;
 8033b6c:	f895 3485 	ldrb.w	r3, [r5, #1157]	; 0x485
                uint8_t delay = payload[macIndex++] & 0x0F;
 8033b70:	f109 0902 	add.w	r9, r9, #2
    MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 1;
 8033b74:	f043 0310 	orr.w	r3, r3, #16
                uint8_t delay = payload[macIndex++] & 0x0F;
 8033b78:	fa5f f989 	uxtb.w	r9, r9
    MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 1;
 8033b7c:	f885 3485 	strb.w	r3, [r5, #1157]	; 0x485
                uint8_t delay = payload[macIndex++] & 0x0F;
 8033b80:	464c      	mov	r4, r9
}
 8033b82:	e6d1      	b.n	8033928 <ProcessMacCommands.isra.0.constprop.0+0xbc>
 8033b84:	20004aa4 	.word	0x20004aa4
                uint8_t eirpDwellTime = payload[macIndex++];
 8033b88:	5d33      	ldrb	r3, [r6, r4]
                if( RegionTxParamSetupReq( Nvm.MacGroup2.Region, &txParamSetupReq ) != -1 )
 8033b8a:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
                txParamSetupReq.UplinkDwellTime = 0;
 8033b8e:	2200      	movs	r2, #0
 8033b90:	f88d 201c 	strb.w	r2, [sp, #28]
                if( ( eirpDwellTime & 0x20 ) == 0x20 )
 8033b94:	f013 0220 	ands.w	r2, r3, #32
                    txParamSetupReq.DownlinkDwellTime = 1;
 8033b98:	bf18      	it	ne
 8033b9a:	2201      	movne	r2, #1
 8033b9c:	f88d 201d 	strb.w	r2, [sp, #29]
                if( ( eirpDwellTime & 0x10 ) == 0x10 )
 8033ba0:	06da      	lsls	r2, r3, #27
                    txParamSetupReq.UplinkDwellTime = 1;
 8033ba2:	bf48      	it	mi
 8033ba4:	2201      	movmi	r2, #1
                txParamSetupReq.MaxEirp = eirpDwellTime & 0x0F;
 8033ba6:	f003 030f 	and.w	r3, r3, #15
                if( RegionTxParamSetupReq( Nvm.MacGroup2.Region, &txParamSetupReq ) != -1 )
 8033baa:	a907      	add	r1, sp, #28
                    txParamSetupReq.UplinkDwellTime = 1;
 8033bac:	bf48      	it	mi
 8033bae:	f88d 201c 	strbmi.w	r2, [sp, #28]
                txParamSetupReq.MaxEirp = eirpDwellTime & 0x0F;
 8033bb2:	f88d 301e 	strb.w	r3, [sp, #30]
                if( RegionTxParamSetupReq( Nvm.MacGroup2.Region, &txParamSetupReq ) != -1 )
 8033bb6:	f002 fe25 	bl	8036804 <RegionTxParamSetupReq>
                uint8_t eirpDwellTime = payload[macIndex++];
 8033bba:	f109 0902 	add.w	r9, r9, #2
                if( RegionTxParamSetupReq( Nvm.MacGroup2.Region, &txParamSetupReq ) != -1 )
 8033bbe:	3001      	adds	r0, #1
                uint8_t eirpDwellTime = payload[macIndex++];
 8033bc0:	fa5f f989 	uxtb.w	r9, r9
                if( RegionTxParamSetupReq( Nvm.MacGroup2.Region, &txParamSetupReq ) != -1 )
 8033bc4:	d0dc      	beq.n	8033b80 <ProcessMacCommands.isra.0.constprop.0+0x314>
                    Nvm.MacGroup2.MacParams.UplinkDwellTime = txParamSetupReq.UplinkDwellTime;
 8033bc6:	f8bd 301c 	ldrh.w	r3, [sp, #28]
                    Nvm.MacGroup2.MacParams.MaxEirp = LoRaMacMaxEirpTable[txParamSetupReq.MaxEirp];
 8033bca:	4a8e      	ldr	r2, [pc, #568]	; (8033e04 <ProcessMacCommands.isra.0.constprop.0+0x598>)
                    Nvm.MacGroup2.MacParams.UplinkDwellTime = txParamSetupReq.UplinkDwellTime;
 8033bcc:	f8a5 3580 	strh.w	r3, [r5, #1408]	; 0x580
                    Nvm.MacGroup2.MacParams.MaxEirp = LoRaMacMaxEirpTable[txParamSetupReq.MaxEirp];
 8033bd0:	f89d 301e 	ldrb.w	r3, [sp, #30]
                    Nvm.MacGroup2.MacParams.UplinkDwellTime = txParamSetupReq.UplinkDwellTime;
 8033bd4:	f89d 401c 	ldrb.w	r4, [sp, #28]
                    Nvm.MacGroup2.MacParams.MaxEirp = LoRaMacMaxEirpTable[txParamSetupReq.MaxEirp];
 8033bd8:	5cd0      	ldrb	r0, [r2, r3]
 8033bda:	f7f7 ff5b 	bl	802ba94 <__aeabi_ui2f>
                    getPhy.Attribute = PHY_MIN_TX_DR;
 8033bde:	2302      	movs	r3, #2
                    Nvm.MacGroup2.MacParams.MaxEirp = LoRaMacMaxEirpTable[txParamSetupReq.MaxEirp];
 8033be0:	f8c5 0584 	str.w	r0, [r5, #1412]	; 0x584
                    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8033be4:	a90c      	add	r1, sp, #48	; 0x30
 8033be6:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
                    getPhy.Attribute = PHY_MIN_TX_DR;
 8033bea:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
                    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8033bee:	f88d 4032 	strb.w	r4, [sp, #50]	; 0x32
                    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8033bf2:	f002 fd5e 	bl	80366b2 <RegionGetPhyParam>
                    Nvm.MacGroup1.ChannelsDatarate = MAX( Nvm.MacGroup1.ChannelsDatarate, ( int8_t )phyParam.Value );
 8033bf6:	f995 3545 	ldrsb.w	r3, [r5, #1349]	; 0x545
                    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8033bfa:	9008      	str	r0, [sp, #32]
                    Nvm.MacGroup1.ChannelsDatarate = MAX( Nvm.MacGroup1.ChannelsDatarate, ( int8_t )phyParam.Value );
 8033bfc:	b240      	sxtb	r0, r0
 8033bfe:	4298      	cmp	r0, r3
 8033c00:	bfb8      	it	lt
 8033c02:	4618      	movlt	r0, r3
 8033c04:	f885 0545 	strb.w	r0, [r5, #1349]	; 0x545
                    LoRaMacCommandsAddCmd( MOTE_MAC_TX_PARAM_SETUP_ANS, macCmdPayload, 0 );
 8033c08:	2200      	movs	r2, #0
 8033c0a:	a906      	add	r1, sp, #24
 8033c0c:	2009      	movs	r0, #9
 8033c0e:	e6fc      	b.n	8033a0a <ProcessMacCommands.isra.0.constprop.0+0x19e>
                status = 0x03;
 8033c10:	2303      	movs	r3, #3
 8033c12:	f88d 3015 	strb.w	r3, [sp, #21]
                dlChannelReq.ChannelId = payload[macIndex++];
 8033c16:	5d33      	ldrb	r3, [r6, r4]
 8033c18:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033c1c:	f109 0204 	add.w	r2, r9, #4
                dlChannelReq.Rx1Frequency = ( uint32_t ) payload[macIndex++];
 8033c20:	f109 0303 	add.w	r3, r9, #3
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033c24:	b2db      	uxtb	r3, r3
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033c26:	b2d2      	uxtb	r2, r2
 8033c28:	f109 0405 	add.w	r4, r9, #5
                dlChannelReq.ChannelId = payload[macIndex++];
 8033c2c:	f109 0902 	add.w	r9, r9, #2
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033c30:	5cf1      	ldrb	r1, [r6, r3]
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033c32:	5cb3      	ldrb	r3, [r6, r2]
                status = ( uint8_t )RegionDlChannelReq( Nvm.MacGroup2.Region, &dlChannelReq );
 8033c34:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
                dlChannelReq.Rx1Frequency = ( uint32_t ) payload[macIndex++];
 8033c38:	fa5f f989 	uxtb.w	r9, r9
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033c3c:	041b      	lsls	r3, r3, #16
                dlChannelReq.Rx1Frequency = ( uint32_t ) payload[macIndex++];
 8033c3e:	f816 2009 	ldrb.w	r2, [r6, r9]
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033c42:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8033c46:	4313      	orrs	r3, r2
                dlChannelReq.Rx1Frequency *= 100;
 8033c48:	2264      	movs	r2, #100	; 0x64
 8033c4a:	4353      	muls	r3, r2
                status = ( uint8_t )RegionDlChannelReq( Nvm.MacGroup2.Region, &dlChannelReq );
 8033c4c:	a90c      	add	r1, sp, #48	; 0x30
                dlChannelReq.Rx1Frequency *= 100;
 8033c4e:	930d      	str	r3, [sp, #52]	; 0x34
                status = ( uint8_t )RegionDlChannelReq( Nvm.MacGroup2.Region, &dlChannelReq );
 8033c50:	f002 fde4 	bl	803681c <RegionDlChannelReq>
 8033c54:	b2c3      	uxtb	r3, r0
                if( ( int8_t )status >= 0 )
 8033c56:	2800      	cmp	r0, #0
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033c58:	b2e4      	uxtb	r4, r4
                status = ( uint8_t )RegionDlChannelReq( Nvm.MacGroup2.Region, &dlChannelReq );
 8033c5a:	f88d 3015 	strb.w	r3, [sp, #21]
                if( ( int8_t )status >= 0 )
 8033c5e:	f6ff ae63 	blt.w	8033928 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                    macCmdPayload[0] = status;
 8033c62:	f88d 3018 	strb.w	r3, [sp, #24]
                    LoRaMacCommandsAddCmd( MOTE_MAC_DL_CHANNEL_ANS, macCmdPayload, 1 );
 8033c66:	2201      	movs	r2, #1
 8033c68:	a906      	add	r1, sp, #24
 8033c6a:	200a      	movs	r0, #10
 8033c6c:	e713      	b.n	8033a96 <ProcessMacCommands.isra.0.constprop.0+0x22a>
                if( LoRaMacConfirmQueueIsCmdActive( MLME_DEVICE_TIME ) == true )
 8033c6e:	200a      	movs	r0, #10
 8033c70:	f002 f82e 	bl	8035cd0 <LoRaMacConfirmQueueIsCmdActive>
 8033c74:	2800      	cmp	r0, #0
 8033c76:	f43f ae57 	beq.w	8033928 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_DEVICE_TIME );
 8033c7a:	210a      	movs	r1, #10
 8033c7c:	2000      	movs	r0, #0
 8033c7e:	f001 ffeb 	bl	8035c58 <LoRaMacConfirmQueueSetStatus>
                    SysTime_t sysTime = { 0 };
 8033c82:	2300      	movs	r3, #0
 8033c84:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 8;
 8033c88:	f109 0203 	add.w	r2, r9, #3
                    gpsEpochTime.Seconds = ( uint32_t )payload[macIndex++];
 8033c8c:	f109 0302 	add.w	r3, r9, #2
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 8;
 8033c90:	b2db      	uxtb	r3, r3
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 16;
 8033c92:	b2d2      	uxtb	r2, r2
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 8;
 8033c94:	5cf1      	ldrb	r1, [r6, r3]
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 16;
 8033c96:	5cb3      	ldrb	r3, [r6, r2]
                    gpsEpochTime.Seconds = ( uint32_t )payload[macIndex++];
 8033c98:	5d32      	ldrb	r2, [r6, r4]
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 16;
 8033c9a:	041b      	lsls	r3, r3, #16
 8033c9c:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8033ca0:	4313      	orrs	r3, r2
 8033ca2:	f109 0204 	add.w	r2, r9, #4
                    gpsEpochTime.SubSeconds = payload[macIndex++];
 8033ca6:	f109 0406 	add.w	r4, r9, #6
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 24;
 8033caa:	b2d2      	uxtb	r2, r2
 8033cac:	f109 0905 	add.w	r9, r9, #5
                    gpsEpochTime.SubSeconds = payload[macIndex++];
 8033cb0:	fa5f f989 	uxtb.w	r9, r9
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 24;
 8033cb4:	5cb2      	ldrb	r2, [r6, r2]
                    gpsEpochTime.SubSeconds = ( int16_t )( ( ( int32_t )gpsEpochTime.SubSeconds * 1000 ) >> 8 );
 8033cb6:	f816 1009 	ldrb.w	r1, [r6, r9]
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 24;
 8033cba:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
                    gpsEpochTime.SubSeconds = ( int16_t )( ( ( int32_t )gpsEpochTime.SubSeconds * 1000 ) >> 8 );
 8033cbe:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8033cc2:	434a      	muls	r2, r1
                    sysTimeCurrent = SysTimeGet( );
 8033cc4:	f10d 0a30 	add.w	sl, sp, #48	; 0x30
                    gpsEpochTime.SubSeconds = ( int16_t )( ( ( int32_t )gpsEpochTime.SubSeconds * 1000 ) >> 8 );
 8033cc8:	1212      	asrs	r2, r2, #8
                    sysTimeCurrent = SysTimeGet( );
 8033cca:	4650      	mov	r0, sl
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 24;
 8033ccc:	9303      	str	r3, [sp, #12]
                    gpsEpochTime.SubSeconds = ( int16_t )( ( ( int32_t )gpsEpochTime.SubSeconds * 1000 ) >> 8 );
 8033cce:	f8ad 2024 	strh.w	r2, [sp, #36]	; 0x24
                    sysTimeCurrent = SysTimeGet( );
 8033cd2:	f007 fa0f 	bl	803b0f4 <SysTimeGet>
                    sysTime.Seconds += UNIX_GPS_EPOCH_OFFSET;
 8033cd6:	9b03      	ldr	r3, [sp, #12]
 8033cd8:	f103 5396 	add.w	r3, r3, #314572800	; 0x12c00000
 8033cdc:	f503 13a9 	add.w	r3, r3, #1384448	; 0x152000
 8033ce0:	f503 53ec 	add.w	r3, r3, #7552	; 0x1d80
                    sysTime = SysTimeAdd( sysTimeCurrent, SysTimeSub( sysTime, MacCtx.LastTxSysTime ) );
 8033ce4:	9308      	str	r3, [sp, #32]
 8033ce6:	f8d5 3340 	ldr.w	r3, [r5, #832]	; 0x340
 8033cea:	9300      	str	r3, [sp, #0]
 8033cec:	f10d 0920 	add.w	r9, sp, #32
 8033cf0:	e899 0006 	ldmia.w	r9, {r1, r2}
 8033cf4:	f8d5 333c 	ldr.w	r3, [r5, #828]	; 0x33c
 8033cf8:	a80a      	add	r0, sp, #40	; 0x28
 8033cfa:	f007 f9b7 	bl	803b06c <SysTimeSub>
 8033cfe:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8033d00:	9300      	str	r3, [sp, #0]
 8033d02:	e89a 0006 	ldmia.w	sl, {r1, r2}
 8033d06:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8033d08:	4648      	mov	r0, r9
 8033d0a:	f007 f993 	bl	803b034 <SysTimeAdd>
                    SysTimeSet( sysTime );
 8033d0e:	e899 0003 	ldmia.w	r9, {r0, r1}
 8033d12:	f007 f9c7 	bl	803b0a4 <SysTimeSet>
                    LoRaMacClassBDeviceTimeAns( );
 8033d16:	f001 fe29 	bl	803596c <LoRaMacClassBDeviceTimeAns>
                    MacCtx.McpsIndication.DeviceTimeAnsReceived = true;
 8033d1a:	2301      	movs	r3, #1
                    gpsEpochTime.SubSeconds = payload[macIndex++];
 8033d1c:	b2e4      	uxtb	r4, r4
                    MacCtx.McpsIndication.DeviceTimeAnsReceived = true;
 8033d1e:	f885 3438 	strb.w	r3, [r5, #1080]	; 0x438
 8033d22:	e601      	b.n	8033928 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                if( LoRaMacConfirmQueueIsCmdActive( MLME_PING_SLOT_INFO ) == true )
 8033d24:	200d      	movs	r0, #13
 8033d26:	f001 ffd3 	bl	8035cd0 <LoRaMacConfirmQueueIsCmdActive>
 8033d2a:	2800      	cmp	r0, #0
 8033d2c:	f43f adfc 	beq.w	8033928 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_PING_SLOT_INFO );
 8033d30:	210d      	movs	r1, #13
 8033d32:	2000      	movs	r0, #0
 8033d34:	f001 ff90 	bl	8035c58 <LoRaMacConfirmQueueSetStatus>
                    if( ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_PING_SLOT ) && ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT ) )
 8033d38:	f895 3484 	ldrb.w	r3, [r5, #1156]	; 0x484
 8033d3c:	3b04      	subs	r3, #4
 8033d3e:	2b01      	cmp	r3, #1
 8033d40:	f67f adf2 	bls.w	8033928 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                        LoRaMacClassBPingSlotInfoAns( );
 8033d44:	f001 fe0e 	bl	8035964 <LoRaMacClassBPingSlotInfoAns>
 8033d48:	e5ee      	b.n	8033928 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                frequency = ( uint32_t )payload[macIndex++];
 8033d4a:	f109 0202 	add.w	r2, r9, #2
                frequency |= ( uint32_t )payload[macIndex++] << 8;
 8033d4e:	b2d2      	uxtb	r2, r2
                frequency = ( uint32_t )payload[macIndex++];
 8033d50:	5d31      	ldrb	r1, [r6, r4]
                frequency |= ( uint32_t )payload[macIndex++] << 8;
 8033d52:	5cb0      	ldrb	r0, [r6, r2]
 8033d54:	f109 0203 	add.w	r2, r9, #3
                frequency |= ( uint32_t )payload[macIndex++] << 16;
 8033d58:	b2d2      	uxtb	r2, r2
                datarate = payload[macIndex++] & 0x0F;
 8033d5a:	f109 0405 	add.w	r4, r9, #5
                frequency |= ( uint32_t )payload[macIndex++] << 16;
 8033d5e:	5cb3      	ldrb	r3, [r6, r2]
 8033d60:	f109 0904 	add.w	r9, r9, #4
                datarate = payload[macIndex++] & 0x0F;
 8033d64:	fa5f f989 	uxtb.w	r9, r9
                frequency |= ( uint32_t )payload[macIndex++] << 16;
 8033d68:	041b      	lsls	r3, r3, #16
 8033d6a:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
                datarate = payload[macIndex++] & 0x0F;
 8033d6e:	f816 0009 	ldrb.w	r0, [r6, r9]
                frequency |= ( uint32_t )payload[macIndex++] << 16;
 8033d72:	430b      	orrs	r3, r1
                status = LoRaMacClassBPingSlotChannelReq( datarate, frequency );
 8033d74:	2164      	movs	r1, #100	; 0x64
 8033d76:	4359      	muls	r1, r3
 8033d78:	f000 000f 	and.w	r0, r0, #15
 8033d7c:	f001 fdf3 	bl	8035966 <LoRaMacClassBPingSlotChannelReq>
                datarate = payload[macIndex++] & 0x0F;
 8033d80:	b2e4      	uxtb	r4, r4
                macCmdPayload[0] = status;
 8033d82:	f88d 0018 	strb.w	r0, [sp, #24]
                LoRaMacCommandsAddCmd( MOTE_MAC_PING_SLOT_FREQ_ANS, macCmdPayload, 1 );
 8033d86:	2201      	movs	r2, #1
 8033d88:	a906      	add	r1, sp, #24
 8033d8a:	2011      	movs	r0, #17
 8033d8c:	e69b      	b.n	8033ac6 <ProcessMacCommands.isra.0.constprop.0+0x25a>
                if( LoRaMacConfirmQueueIsCmdActive( MLME_BEACON_TIMING ) == true )
 8033d8e:	200e      	movs	r0, #14
 8033d90:	f001 ff9e 	bl	8035cd0 <LoRaMacConfirmQueueIsCmdActive>
 8033d94:	2800      	cmp	r0, #0
 8033d96:	f43f adc7 	beq.w	8033928 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_BEACON_TIMING );
 8033d9a:	210e      	movs	r1, #14
 8033d9c:	2000      	movs	r0, #0
 8033d9e:	f001 ff5b 	bl	8035c58 <LoRaMacConfirmQueueSetStatus>
                    beaconTimingDelay = ( uint16_t )payload[macIndex++];
 8033da2:	f109 0302 	add.w	r3, r9, #2
                    beaconTimingDelay |= ( uint16_t )payload[macIndex++] << 8;
 8033da6:	b2db      	uxtb	r3, r3
                    LoRaMacClassBBeaconTimingAns( beaconTimingDelay, beaconTimingChannel, RxDoneParams.LastRxDone );
 8033da8:	4a17      	ldr	r2, [pc, #92]	; (8033e08 <ProcessMacCommands.isra.0.constprop.0+0x59c>)
                    beaconTimingDelay |= ( uint16_t )payload[macIndex++] << 8;
 8033daa:	5cf0      	ldrb	r0, [r6, r3]
 8033dac:	5d33      	ldrb	r3, [r6, r4]
                    LoRaMacClassBBeaconTimingAns( beaconTimingDelay, beaconTimingChannel, RxDoneParams.LastRxDone );
 8033dae:	6812      	ldr	r2, [r2, #0]
                    beaconTimingChannel = payload[macIndex++];
 8033db0:	f109 0404 	add.w	r4, r9, #4
                    beaconTimingDelay |= ( uint16_t )payload[macIndex++] << 8;
 8033db4:	f109 0903 	add.w	r9, r9, #3
                    beaconTimingChannel = payload[macIndex++];
 8033db8:	fa5f f989 	uxtb.w	r9, r9
                    LoRaMacClassBBeaconTimingAns( beaconTimingDelay, beaconTimingChannel, RxDoneParams.LastRxDone );
 8033dbc:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 8033dc0:	f816 1009 	ldrb.w	r1, [r6, r9]
                    beaconTimingChannel = payload[macIndex++];
 8033dc4:	b2e4      	uxtb	r4, r4
                    LoRaMacClassBBeaconTimingAns( beaconTimingDelay, beaconTimingChannel, RxDoneParams.LastRxDone );
 8033dc6:	f001 fdd0 	bl	803596a <LoRaMacClassBBeaconTimingAns>
 8033dca:	e5ad      	b.n	8033928 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                    frequency = ( uint32_t )payload[macIndex++];
 8033dcc:	5d30      	ldrb	r0, [r6, r4]
 8033dce:	f109 0302 	add.w	r3, r9, #2
                    frequency |= ( uint32_t )payload[macIndex++] << 16;
 8033dd2:	f109 0404 	add.w	r4, r9, #4
                    frequency |= ( uint32_t )payload[macIndex++] << 8;
 8033dd6:	f109 0903 	add.w	r9, r9, #3
 8033dda:	b2db      	uxtb	r3, r3
                    frequency |= ( uint32_t )payload[macIndex++] << 16;
 8033ddc:	fa5f f989 	uxtb.w	r9, r9
                    frequency |= ( uint32_t )payload[macIndex++] << 8;
 8033de0:	5cf2      	ldrb	r2, [r6, r3]
                    frequency |= ( uint32_t )payload[macIndex++] << 16;
 8033de2:	f816 3009 	ldrb.w	r3, [r6, r9]
 8033de6:	041b      	lsls	r3, r3, #16
 8033de8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8033dec:	4303      	orrs	r3, r0
                    if( LoRaMacClassBBeaconFreqReq( frequency ) == true )
 8033dee:	2064      	movs	r0, #100	; 0x64
 8033df0:	4358      	muls	r0, r3
 8033df2:	f001 fdbc 	bl	803596e <LoRaMacClassBBeaconFreqReq>
                    frequency |= ( uint32_t )payload[macIndex++] << 16;
 8033df6:	b2e4      	uxtb	r4, r4
                    if( LoRaMacClassBBeaconFreqReq( frequency ) == true )
 8033df8:	f88d 0018 	strb.w	r0, [sp, #24]
                    LoRaMacCommandsAddCmd( MOTE_MAC_BEACON_FREQ_ANS, macCmdPayload, 1 );
 8033dfc:	2201      	movs	r2, #1
 8033dfe:	a906      	add	r1, sp, #24
 8033e00:	2013      	movs	r0, #19
 8033e02:	e660      	b.n	8033ac6 <ProcessMacCommands.isra.0.constprop.0+0x25a>
 8033e04:	0803ba4a 	.word	0x0803ba4a
 8033e08:	20006314 	.word	0x20006314

08033e0c <LoRaMacIsBusy>:
    if( ( MacCtx.MacState == LORAMAC_IDLE ) &&
 8033e0c:	4b05      	ldr	r3, [pc, #20]	; (8033e24 <LoRaMacIsBusy+0x18>)
 8033e0e:	f8d3 2344 	ldr.w	r2, [r3, #836]	; 0x344
 8033e12:	b92a      	cbnz	r2, 8033e20 <LoRaMacIsBusy+0x14>
 8033e14:	f893 0486 	ldrb.w	r0, [r3, #1158]	; 0x486
 8033e18:	3801      	subs	r0, #1
 8033e1a:	bf18      	it	ne
 8033e1c:	2001      	movne	r0, #1
 8033e1e:	4770      	bx	lr
    return true;
 8033e20:	2001      	movs	r0, #1
}
 8033e22:	4770      	bx	lr
 8033e24:	20004aa4 	.word	0x20004aa4

08033e28 <LoRaMacProcess>:
{
 8033e28:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8033e2c:	b0a5      	sub	sp, #148	; 0x94
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8033e2e:	f3ef 8210 	mrs	r2, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8033e32:	b672      	cpsid	i
    events = LoRaMacRadioEvents;
 8033e34:	4ccf      	ldr	r4, [pc, #828]	; (8034174 <LoRaMacProcess+0x34c>)
    LoRaMacRadioEvents.Value = 0;
 8033e36:	2100      	movs	r1, #0
    events = LoRaMacRadioEvents;
 8033e38:	6823      	ldr	r3, [r4, #0]
    LoRaMacRadioEvents.Value = 0;
 8033e3a:	6021      	str	r1, [r4, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8033e3c:	f382 8810 	msr	PRIMASK, r2
    if( events.Value != 0 )
 8033e40:	2b00      	cmp	r3, #0
 8033e42:	f000 80cd 	beq.w	8033fe0 <LoRaMacProcess+0x1b8>
        if( events.Events.TxDone == 1 )
 8033e46:	06da      	lsls	r2, r3, #27
 8033e48:	fa5f fa83 	uxtb.w	sl, r3
 8033e4c:	d560      	bpl.n	8033f10 <LoRaMacProcess+0xe8>
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 8033e4e:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 8033e52:	2b02      	cmp	r3, #2
 8033e54:	d002      	beq.n	8033e5c <LoRaMacProcess+0x34>
        Radio.Sleep( );
 8033e56:	4bc8      	ldr	r3, [pc, #800]	; (8034178 <LoRaMacProcess+0x350>)
 8033e58:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8033e5a:	4798      	blx	r3
    TimerSetValue( &MacCtx.RxWindowTimer1, MacCtx.RxWindow1Delay );
 8033e5c:	f8d4 13b4 	ldr.w	r1, [r4, #948]	; 0x3b4
 8033e60:	48c6      	ldr	r0, [pc, #792]	; (803417c <LoRaMacProcess+0x354>)
 8033e62:	f007 fabf 	bl	803b3e4 <UTIL_TIMER_SetPeriod>
    TimerStart( &MacCtx.RxWindowTimer1 );
 8033e66:	48c5      	ldr	r0, [pc, #788]	; (803417c <LoRaMacProcess+0x354>)
 8033e68:	f007 fa82 	bl	803b370 <UTIL_TIMER_Start>
    TimerSetValue( &MacCtx.RxWindowTimer2, MacCtx.RxWindow2Delay );
 8033e6c:	f8d4 13b8 	ldr.w	r1, [r4, #952]	; 0x3b8
 8033e70:	48c3      	ldr	r0, [pc, #780]	; (8034180 <LoRaMacProcess+0x358>)
 8033e72:	f007 fab7 	bl	803b3e4 <UTIL_TIMER_SetPeriod>
    TimerStart( &MacCtx.RxWindowTimer2 );
 8033e76:	48c2      	ldr	r0, [pc, #776]	; (8034180 <LoRaMacProcess+0x358>)
 8033e78:	f007 fa7a 	bl	803b370 <UTIL_TIMER_Start>
    if( ( Nvm.MacGroup2.DeviceClass == CLASS_C ) || ( MacCtx.NodeAckRequested == true ) )
 8033e7c:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 8033e80:	2b02      	cmp	r3, #2
 8033e82:	d002      	beq.n	8033e8a <LoRaMacProcess+0x62>
 8033e84:	f894 3418 	ldrb.w	r3, [r4, #1048]	; 0x418
 8033e88:	b18b      	cbz	r3, 8033eae <LoRaMacProcess+0x86>
        getPhy.Attribute = PHY_ACK_TIMEOUT;
 8033e8a:	2316      	movs	r3, #22
        phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8033e8c:	a90e      	add	r1, sp, #56	; 0x38
 8033e8e:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
        getPhy.Attribute = PHY_ACK_TIMEOUT;
 8033e92:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
        phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8033e96:	f002 fc0c 	bl	80366b2 <RegionGetPhyParam>
        TimerSetValue( &MacCtx.AckTimeoutTimer, MacCtx.RxWindow2Delay + phyParam.Value );
 8033e9a:	f8d4 13b8 	ldr.w	r1, [r4, #952]	; 0x3b8
        phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8033e9e:	900c      	str	r0, [sp, #48]	; 0x30
        TimerSetValue( &MacCtx.AckTimeoutTimer, MacCtx.RxWindow2Delay + phyParam.Value );
 8033ea0:	4401      	add	r1, r0
 8033ea2:	48b8      	ldr	r0, [pc, #736]	; (8034184 <LoRaMacProcess+0x35c>)
 8033ea4:	f007 fa9e 	bl	803b3e4 <UTIL_TIMER_SetPeriod>
        TimerStart( &MacCtx.AckTimeoutTimer );
 8033ea8:	48b6      	ldr	r0, [pc, #728]	; (8034184 <LoRaMacProcess+0x35c>)
 8033eaa:	f007 fa61 	bl	803b370 <UTIL_TIMER_Start>
    Nvm.MacGroup1.LastTxDoneTime = TxDoneParams.CurTime;
 8033eae:	4bb6      	ldr	r3, [pc, #728]	; (8034188 <LoRaMacProcess+0x360>)
    txDone.Channel = MacCtx.Channel;
 8033eb0:	f894 2419 	ldrb.w	r2, [r4, #1049]	; 0x419
    Nvm.MacGroup1.LastTxDoneTime = TxDoneParams.CurTime;
 8033eb4:	681b      	ldr	r3, [r3, #0]
 8033eb6:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    txDone.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );
 8033eba:	ae0a      	add	r6, sp, #40	; 0x28
 8033ebc:	4630      	mov	r0, r6
    txDone.Channel = MacCtx.Channel;
 8033ebe:	f88d 2060 	strb.w	r2, [sp, #96]	; 0x60
    txDone.LastTxDoneTime = TxDoneParams.CurTime;
 8033ec2:	9319      	str	r3, [sp, #100]	; 0x64
    txDone.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );
 8033ec4:	f007 f93c 	bl	803b140 <SysTimeGetMcuTime>
 8033ec8:	f8d4 3614 	ldr.w	r3, [r4, #1556]	; 0x614
 8033ecc:	9300      	str	r3, [sp, #0]
 8033ece:	ad04      	add	r5, sp, #16
 8033ed0:	e896 0006 	ldmia.w	r6, {r1, r2}
 8033ed4:	f8d4 3610 	ldr.w	r3, [r4, #1552]	; 0x610
 8033ed8:	4628      	mov	r0, r5
 8033eda:	f007 f8c7 	bl	803b06c <SysTimeSub>
 8033ede:	e895 0003 	ldmia.w	r5, {r0, r1}
 8033ee2:	ab1b      	add	r3, sp, #108	; 0x6c
 8033ee4:	e883 0003 	stmia.w	r3, {r0, r1}
    txDone.LastTxAirTime = MacCtx.TxTimeOnAir;
 8033ee8:	f8d4 341c 	ldr.w	r3, [r4, #1052]	; 0x41c
 8033eec:	931a      	str	r3, [sp, #104]	; 0x68
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 8033eee:	f894 361c 	ldrb.w	r3, [r4, #1564]	; 0x61c
    RegionSetBandTxDone( Nvm.MacGroup2.Region, &txDone );
 8033ef2:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
        txDone.Joined  = false;
 8033ef6:	2b00      	cmp	r3, #0
 8033ef8:	bf18      	it	ne
 8033efa:	2301      	movne	r3, #1
    RegionSetBandTxDone( Nvm.MacGroup2.Region, &txDone );
 8033efc:	a918      	add	r1, sp, #96	; 0x60
        txDone.Joined  = false;
 8033efe:	f88d 3061 	strb.w	r3, [sp, #97]	; 0x61
    RegionSetBandTxDone( Nvm.MacGroup2.Region, &txDone );
 8033f02:	f002 fbe6 	bl	80366d2 <RegionSetBandTxDone>
    if( MacCtx.NodeAckRequested == false )
 8033f06:	f894 3418 	ldrb.w	r3, [r4, #1048]	; 0x418
 8033f0a:	b90b      	cbnz	r3, 8033f10 <LoRaMacProcess+0xe8>
        MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;
 8033f0c:	f884 343d 	strb.w	r3, [r4, #1085]	; 0x43d
        if( events.Events.RxDone == 1 )
 8033f10:	f01a 0f08 	tst.w	sl, #8
 8033f14:	d039      	beq.n	8033f8a <LoRaMacProcess+0x162>
    uint8_t *payload = RxDoneParams.Payload;
 8033f16:	4b9d      	ldr	r3, [pc, #628]	; (803418c <LoRaMacProcess+0x364>)
    uint32_t address = Nvm.MacGroup2.DevAddr;
 8033f18:	f8d4 25d8 	ldr.w	r2, [r4, #1496]	; 0x5d8
    uint8_t *payload = RxDoneParams.Payload;
 8033f1c:	685e      	ldr	r6, [r3, #4]
    uint16_t size = RxDoneParams.Size;
 8033f1e:	891d      	ldrh	r5, [r3, #8]
    int16_t rssi = RxDoneParams.Rssi;
 8033f20:	f9b3 700a 	ldrsh.w	r7, [r3, #10]
    int8_t snr = RxDoneParams.Snr;
 8033f24:	f993 900c 	ldrsb.w	r9, [r3, #12]
    uint32_t address = Nvm.MacGroup2.DevAddr;
 8033f28:	9203      	str	r2, [sp, #12]
    uint32_t downLinkCounter = 0;
 8033f2a:	2300      	movs	r3, #0
 8033f2c:	9307      	str	r3, [sp, #28]
    MacCtx.McpsConfirm.AckReceived = false;
 8033f2e:	f884 3440 	strb.w	r3, [r4, #1088]	; 0x440
    MacCtx.McpsIndication.Multicast = 0;
 8033f32:	f8a4 3422 	strh.w	r3, [r4, #1058]	; 0x422
    MacCtx.McpsIndication.FramePending = 0;
 8033f36:	f884 3425 	strb.w	r3, [r4, #1061]	; 0x425
    MacCtx.McpsIndication.Buffer = NULL;
 8033f3a:	f8c4 3428 	str.w	r3, [r4, #1064]	; 0x428
    MacCtx.McpsIndication.BufferSize = 0;
 8033f3e:	f8a4 342c 	strh.w	r3, [r4, #1068]	; 0x42c
    MacCtx.McpsIndication.AckReceived = false;
 8033f42:	f884 342e 	strb.w	r3, [r4, #1070]	; 0x42e
    MacCtx.McpsIndication.DownLinkCounter = 0;
 8033f46:	f8c4 3430 	str.w	r3, [r4, #1072]	; 0x430
    MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED;
 8033f4a:	f884 3420 	strb.w	r3, [r4, #1056]	; 0x420
    MacCtx.McpsIndication.DevAddress = 0;
 8033f4e:	f8c4 3434 	str.w	r3, [r4, #1076]	; 0x434
    MacCtx.McpsIndication.DeviceTimeAnsReceived = false;
 8033f52:	f884 3438 	strb.w	r3, [r4, #1080]	; 0x438
    Radio.Sleep( );
 8033f56:	4b88      	ldr	r3, [pc, #544]	; (8034178 <LoRaMacProcess+0x350>)
    MacCtx.RxStatus.RxSlot = MacCtx.RxSlot;
 8033f58:	f894 2484 	ldrb.w	r2, [r4, #1156]	; 0x484
    Radio.Sleep( );
 8033f5c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    MacCtx.RxStatus.RxSlot = MacCtx.RxSlot;
 8033f5e:	f884 2483 	strb.w	r2, [r4, #1155]	; 0x483
    MacCtx.RxStatus.Rssi = rssi;
 8033f62:	f8a4 7480 	strh.w	r7, [r4, #1152]	; 0x480
    MacCtx.RxStatus.Snr = snr;
 8033f66:	f884 9482 	strb.w	r9, [r4, #1154]	; 0x482
    Radio.Sleep( );
 8033f6a:	4798      	blx	r3
    TimerStop( &MacCtx.RxWindowTimer2 );
 8033f6c:	4884      	ldr	r0, [pc, #528]	; (8034180 <LoRaMacProcess+0x358>)
 8033f6e:	f007 f9af 	bl	803b2d0 <UTIL_TIMER_Stop>
    if( LoRaMacClassBRxBeacon( payload, size ) == true )
 8033f72:	4629      	mov	r1, r5
 8033f74:	4630      	mov	r0, r6
 8033f76:	f001 fce2 	bl	803593e <LoRaMacClassBRxBeacon>
 8033f7a:	4680      	mov	r8, r0
 8033f7c:	2800      	cmp	r0, #0
 8033f7e:	f000 8169 	beq.w	8034254 <LoRaMacProcess+0x42c>
        MacCtx.MlmeIndication.BeaconInfo.Rssi = rssi;
 8033f82:	f8a4 7476 	strh.w	r7, [r4, #1142]	; 0x476
        MacCtx.MlmeIndication.BeaconInfo.Snr = snr;
 8033f86:	f884 9478 	strb.w	r9, [r4, #1144]	; 0x478
        if( events.Events.TxTimeout == 1 )
 8033f8a:	f01a 0f04 	tst.w	sl, #4
 8033f8e:	d019      	beq.n	8033fc4 <LoRaMacProcess+0x19c>
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 8033f90:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 8033f94:	2b02      	cmp	r3, #2
 8033f96:	d002      	beq.n	8033f9e <LoRaMacProcess+0x176>
        Radio.Sleep( );
 8033f98:	4b77      	ldr	r3, [pc, #476]	; (8034178 <LoRaMacProcess+0x350>)
 8033f9a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8033f9c:	4798      	blx	r3
    UpdateRxSlotIdleState( );
 8033f9e:	f7fe ffdd 	bl	8032f5c <UpdateRxSlotIdleState>
    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT;
 8033fa2:	2002      	movs	r0, #2
 8033fa4:	f884 043d 	strb.w	r0, [r4, #1085]	; 0x43d
    LoRaMacConfirmQueueSetStatusCmn( LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT );
 8033fa8:	f001 fe78 	bl	8035c9c <LoRaMacConfirmQueueSetStatusCmn>
    if( MacCtx.NodeAckRequested == true )
 8033fac:	f894 3418 	ldrb.w	r3, [r4, #1048]	; 0x418
 8033fb0:	b113      	cbz	r3, 8033fb8 <LoRaMacProcess+0x190>
        MacCtx.AckTimeoutRetry = true;
 8033fb2:	2301      	movs	r3, #1
 8033fb4:	f884 3417 	strb.w	r3, [r4, #1047]	; 0x417
    MacCtx.MacFlags.Bits.MacDone = 1;
 8033fb8:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 8033fbc:	f043 0320 	orr.w	r3, r3, #32
 8033fc0:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
        if( events.Events.RxError == 1 )
 8033fc4:	f01a 0f02 	tst.w	sl, #2
 8033fc8:	d003      	beq.n	8033fd2 <LoRaMacProcess+0x1aa>
    HandleRadioRxErrorTimeout( LORAMAC_EVENT_INFO_STATUS_RX1_ERROR, LORAMAC_EVENT_INFO_STATUS_RX2_ERROR );
 8033fca:	2106      	movs	r1, #6
 8033fcc:	2005      	movs	r0, #5
 8033fce:	f7ff f84d 	bl	803306c <HandleRadioRxErrorTimeout>
        if( events.Events.RxTimeout == 1 )
 8033fd2:	f01a 0f01 	tst.w	sl, #1
 8033fd6:	d003      	beq.n	8033fe0 <LoRaMacProcess+0x1b8>
    HandleRadioRxErrorTimeout( LORAMAC_EVENT_INFO_STATUS_RX1_TIMEOUT, LORAMAC_EVENT_INFO_STATUS_RX2_TIMEOUT );
 8033fd8:	2104      	movs	r1, #4
 8033fda:	2003      	movs	r0, #3
 8033fdc:	f7ff f846 	bl	803306c <HandleRadioRxErrorTimeout>
    LoRaMacClassBProcess( );
 8033fe0:	f001 fccb 	bl	803597a <LoRaMacClassBProcess>
    if( MacCtx.MacFlags.Bits.MacDone == 1 )
 8033fe4:	f894 2485 	ldrb.w	r2, [r4, #1157]	; 0x485
 8033fe8:	0697      	lsls	r7, r2, #26
 8033fea:	f140 80f9 	bpl.w	80341e0 <LoRaMacProcess+0x3b8>
    MacCtx.AllowRequests = requestState;
 8033fee:	2300      	movs	r3, #0
 8033ff0:	f884 3486 	strb.w	r3, [r4, #1158]	; 0x486
    if( ( MacCtx.MacState & LORAMAC_RX_ABORT ) == LORAMAC_RX_ABORT )
 8033ff4:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 8033ff8:	061e      	lsls	r6, r3, #24
        MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 8033ffa:	bf44      	itt	mi
 8033ffc:	f023 0382 	bicmi.w	r3, r3, #130	; 0x82
 8034000:	f8c4 3344 	strmi.w	r3, [r4, #836]	; 0x344
    MacCtx.McpsConfirm.NbRetries = MacCtx.AckTimeoutRetriesCounter;
}

static uint8_t IsRequestPending( void )
{
    if( ( MacCtx.MacFlags.Bits.MlmeReq == 1 ) ||
 8034004:	f012 0f05 	tst.w	r2, #5
 8034008:	f000 832c 	beq.w	8034664 <LoRaMacProcess+0x83c>
    if( ( LoRaMacConfirmQueueIsCmdActive( MLME_BEACON_ACQUISITION ) == true ) &&
 803400c:	200c      	movs	r0, #12
 803400e:	f001 fe5f 	bl	8035cd0 <LoRaMacConfirmQueueIsCmdActive>
 8034012:	2800      	cmp	r0, #0
 8034014:	f000 8326 	beq.w	8034664 <LoRaMacProcess+0x83c>
        ( MacCtx.MacFlags.Bits.McpsReq == 0 ) )
 8034018:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
    if( ( LoRaMacConfirmQueueIsCmdActive( MLME_BEACON_ACQUISITION ) == true ) &&
 803401c:	07dd      	lsls	r5, r3, #31
 803401e:	f100 8321 	bmi.w	8034664 <LoRaMacProcess+0x83c>
        if( MacCtx.MacFlags.Bits.MlmeReq == 1 )
 8034022:	0758      	lsls	r0, r3, #29
 8034024:	f140 8332 	bpl.w	803468c <LoRaMacProcess+0x864>
            MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 8034028:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 803402c:	f023 0302 	bic.w	r3, r3, #2
 8034030:	f8c4 3344 	str.w	r3, [r4, #836]	; 0x344
    if( MacCtx.MacState == LORAMAC_IDLE )
 8034034:	f8d4 2344 	ldr.w	r2, [r4, #836]	; 0x344
 8034038:	2a00      	cmp	r2, #0
 803403a:	f040 80ce 	bne.w	80341da <LoRaMacProcess+0x3b2>
 803403e:	f894 5485 	ldrb.w	r5, [r4, #1157]	; 0x485
        if( MacCtx.MacFlags.Bits.McpsReq == 1 )
 8034042:	f015 0101 	ands.w	r1, r5, #1
            MacCtx.MacFlags.Bits.McpsReq = 0;
 8034046:	bf1e      	ittt	ne
 8034048:	462b      	movne	r3, r5
 803404a:	f362 0300 	bfine	r3, r2, #0, #1
 803404e:	f884 3485 	strbne.w	r3, [r4, #1157]	; 0x485
        if( MacCtx.MacFlags.Bits.MlmeReq == 1 )
 8034052:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 8034056:	075e      	lsls	r6, r3, #29
            MacCtx.MacFlags.Bits.MlmeReq = 0;
 8034058:	bf44      	itt	mi
 803405a:	f36f 0382 	bfcmi	r3, #2, #1
 803405e:	f884 3485 	strbmi.w	r3, [r4, #1157]	; 0x485
    MacCtx.AllowRequests = requestState;
 8034062:	2301      	movs	r3, #1
 8034064:	f884 3486 	strb.w	r3, [r4, #1158]	; 0x486
        if( reqEvents.Bits.McpsReq == 1 )
 8034068:	b121      	cbz	r1, 8034074 <LoRaMacProcess+0x24c>
            MacCtx.MacPrimitives->MacMcpsConfirm( &MacCtx.McpsConfirm );
 803406a:	f8d4 3348 	ldr.w	r3, [r4, #840]	; 0x348
 803406e:	4848      	ldr	r0, [pc, #288]	; (8034190 <LoRaMacProcess+0x368>)
 8034070:	681b      	ldr	r3, [r3, #0]
 8034072:	4798      	blx	r3
        if( reqEvents.Bits.MlmeReq == 1 )
 8034074:	076d      	lsls	r5, r5, #29
 8034076:	d50b      	bpl.n	8034090 <LoRaMacProcess+0x268>
            LoRaMacConfirmQueueHandleCb( &MacCtx.MlmeConfirm );
 8034078:	4846      	ldr	r0, [pc, #280]	; (8034194 <LoRaMacProcess+0x36c>)
 803407a:	f001 fe35 	bl	8035ce8 <LoRaMacConfirmQueueHandleCb>
            if( LoRaMacConfirmQueueGetCnt( ) > 0 )
 803407e:	f001 fe5d 	bl	8035d3c <LoRaMacConfirmQueueGetCnt>
 8034082:	b128      	cbz	r0, 8034090 <LoRaMacProcess+0x268>
                MacCtx.MacFlags.Bits.MlmeReq = 1;
 8034084:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 8034088:	f043 0304 	orr.w	r3, r3, #4
 803408c:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
        LoRaMacClassBResumeBeaconing( );
 8034090:	f001 fc61 	bl	8035956 <LoRaMacClassBResumeBeaconing>
        MacCtx.MacFlags.Bits.MacDone = 0;
 8034094:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 8034098:	f36f 1345 	bfc	r3, #5, #1
 803409c:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
    if( MacCtx.MacState == LORAMAC_IDLE )
 80340a0:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 80340a4:	2b00      	cmp	r3, #0
 80340a6:	f040 8098 	bne.w	80341da <LoRaMacProcess+0x3b2>
        LoRaMacCommandsStickyCmdsPending( &isStickyMacCommandPending );
 80340aa:	a818      	add	r0, sp, #96	; 0x60
        bool isStickyMacCommandPending = false;
 80340ac:	f88d 3060 	strb.w	r3, [sp, #96]	; 0x60
        LoRaMacCommandsStickyCmdsPending( &isStickyMacCommandPending );
 80340b0:	f001 fd4a 	bl	8035b48 <LoRaMacCommandsStickyCmdsPending>
        if( isStickyMacCommandPending == true )
 80340b4:	f89d 3060 	ldrb.w	r3, [sp, #96]	; 0x60
 80340b8:	b12b      	cbz	r3, 80340c6 <LoRaMacProcess+0x29e>
    MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 1;
 80340ba:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 80340be:	f043 0310 	orr.w	r3, r3, #16
 80340c2:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
    if( MacCtx.MacState != LORAMAC_IDLE )
 80340c6:	f8d4 5344 	ldr.w	r5, [r4, #836]	; 0x344
 80340ca:	2d00      	cmp	r5, #0
 80340cc:	f040 8085 	bne.w	80341da <LoRaMacProcess+0x3b2>
    crc = Crc32( ( uint8_t* ) &nvmData->Crypto, sizeof( nvmData->Crypto ) -
 80340d0:	2124      	movs	r1, #36	; 0x24
 80340d2:	4831      	ldr	r0, [pc, #196]	; (8034198 <LoRaMacProcess+0x370>)
 80340d4:	f004 ff10 	bl	8038ef8 <Crc32>
    if( crc != nvmData->Crypto.Crc32 )
 80340d8:	f8d4 3530 	ldr.w	r3, [r4, #1328]	; 0x530
 80340dc:	4298      	cmp	r0, r3
        nvmData->Crypto.Crc32 = crc;
 80340de:	bf18      	it	ne
 80340e0:	f8c4 0530 	strne.w	r0, [r4, #1328]	; 0x530
    crc = Crc32( ( uint8_t* ) &nvmData->MacGroup1, sizeof( nvmData->MacGroup1 ) -
 80340e4:	f04f 0114 	mov.w	r1, #20
 80340e8:	482c      	ldr	r0, [pc, #176]	; (803419c <LoRaMacProcess+0x374>)
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_CRYPTO;
 80340ea:	bf18      	it	ne
 80340ec:	2501      	movne	r5, #1
    crc = Crc32( ( uint8_t* ) &nvmData->MacGroup1, sizeof( nvmData->MacGroup1 ) -
 80340ee:	f004 ff03 	bl	8038ef8 <Crc32>
    if( crc != nvmData->MacGroup1.Crc32 )
 80340f2:	f8d4 3548 	ldr.w	r3, [r4, #1352]	; 0x548
 80340f6:	4298      	cmp	r0, r3
        nvmData->MacGroup1.Crc32 = crc;
 80340f8:	bf18      	it	ne
 80340fa:	f8c4 0548 	strne.w	r0, [r4, #1352]	; 0x548
    crc = Crc32( ( uint8_t* ) &nvmData->MacGroup2, sizeof( nvmData->MacGroup2 ) -
 80340fe:	f04f 01d4 	mov.w	r1, #212	; 0xd4
 8034102:	4827      	ldr	r0, [pc, #156]	; (80341a0 <LoRaMacProcess+0x378>)
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_MAC_GROUP1;
 8034104:	bf18      	it	ne
 8034106:	f045 0502 	orrne.w	r5, r5, #2
    crc = Crc32( ( uint8_t* ) &nvmData->MacGroup2, sizeof( nvmData->MacGroup2 ) -
 803410a:	f004 fef5 	bl	8038ef8 <Crc32>
    if( crc != nvmData->MacGroup2.Crc32 )
 803410e:	f8d4 3620 	ldr.w	r3, [r4, #1568]	; 0x620
 8034112:	4298      	cmp	r0, r3
        nvmData->MacGroup2.Crc32 = crc;
 8034114:	bf18      	it	ne
 8034116:	f8c4 0620 	strne.w	r0, [r4, #1568]	; 0x620
    crc = Crc32( ( uint8_t* ) &nvmData->SecureElement, sizeof( nvmData->SecureElement ) -
 803411a:	f44f 7180 	mov.w	r1, #256	; 0x100
 803411e:	4821      	ldr	r0, [pc, #132]	; (80341a4 <LoRaMacProcess+0x37c>)
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_MAC_GROUP2;
 8034120:	bf18      	it	ne
 8034122:	f045 0504 	orrne.w	r5, r5, #4
    crc = Crc32( ( uint8_t* ) &nvmData->SecureElement, sizeof( nvmData->SecureElement ) -
 8034126:	f004 fee7 	bl	8038ef8 <Crc32>
    if( crc != nvmData->SecureElement.Crc32 )
 803412a:	f8d4 3724 	ldr.w	r3, [r4, #1828]	; 0x724
 803412e:	4298      	cmp	r0, r3
        nvmData->SecureElement.Crc32 = crc;
 8034130:	bf18      	it	ne
 8034132:	f8c4 0724 	strne.w	r0, [r4, #1828]	; 0x724
    crc = Crc32( ( uint8_t* ) &nvmData->RegionGroup1, sizeof( nvmData->RegionGroup1 ) -
 8034136:	f04f 01a0 	mov.w	r1, #160	; 0xa0
 803413a:	481b      	ldr	r0, [pc, #108]	; (80341a8 <LoRaMacProcess+0x380>)
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_SECURE_ELEMENT;
 803413c:	bf18      	it	ne
 803413e:	f045 0508 	orrne.w	r5, r5, #8
    crc = Crc32( ( uint8_t* ) &nvmData->RegionGroup1, sizeof( nvmData->RegionGroup1 ) -
 8034142:	f004 fed9 	bl	8038ef8 <Crc32>
    if( crc != nvmData->RegionGroup1.Crc32 )
 8034146:	f8d4 37c8 	ldr.w	r3, [r4, #1992]	; 0x7c8
 803414a:	4298      	cmp	r0, r3
        nvmData->RegionGroup1.Crc32 = crc;
 803414c:	bf18      	it	ne
 803414e:	f8c4 07c8 	strne.w	r0, [r4, #1992]	; 0x7c8
    crc = Crc32( ( uint8_t* ) &nvmData->RegionGroup2, sizeof( nvmData->RegionGroup2 ) -
 8034152:	f44f 715e 	mov.w	r1, #888	; 0x378
 8034156:	4815      	ldr	r0, [pc, #84]	; (80341ac <LoRaMacProcess+0x384>)
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_REGION_GROUP1;
 8034158:	bf18      	it	ne
 803415a:	f045 0510 	orrne.w	r5, r5, #16
    crc = Crc32( ( uint8_t* ) &nvmData->RegionGroup2, sizeof( nvmData->RegionGroup2 ) -
 803415e:	f004 fecb 	bl	8038ef8 <Crc32>
    if( crc != nvmData->RegionGroup2.Crc32 )
 8034162:	f8d4 3b44 	ldr.w	r3, [r4, #2884]	; 0xb44
 8034166:	4298      	cmp	r0, r3
        nvmData->RegionGroup2.Crc32 = crc;
 8034168:	bf18      	it	ne
 803416a:	f8c4 0b44 	strne.w	r0, [r4, #2884]	; 0xb44
    crc = Crc32( ( uint8_t* ) &nvmData->ClassB, sizeof( nvmData->ClassB ) -
 803416e:	f04f 0114 	mov.w	r1, #20
 8034172:	e01d      	b.n	80341b0 <LoRaMacProcess+0x388>
 8034174:	20004aa4 	.word	0x20004aa4
 8034178:	0803bbc0 	.word	0x0803bbc0
 803417c:	20004e28 	.word	0x20004e28
 8034180:	20004e40 	.word	0x20004e40
 8034184:	20004ea0 	.word	0x20004ea0
 8034188:	20006310 	.word	0x20006310
 803418c:	20006314 	.word	0x20006314
 8034190:	20004ee0 	.word	0x20004ee0
 8034194:	20004ef4 	.word	0x20004ef4
 8034198:	20004fb0 	.word	0x20004fb0
 803419c:	20004fd8 	.word	0x20004fd8
 80341a0:	20004ff0 	.word	0x20004ff0
 80341a4:	200050c8 	.word	0x200050c8
 80341a8:	200051cc 	.word	0x200051cc
 80341ac:	20005270 	.word	0x20005270
 80341b0:	487f      	ldr	r0, [pc, #508]	; (80343b0 <LoRaMacProcess+0x588>)
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_REGION_GROUP2;
 80341b2:	bf18      	it	ne
 80341b4:	f045 0520 	orrne.w	r5, r5, #32
    crc = Crc32( ( uint8_t* ) &nvmData->ClassB, sizeof( nvmData->ClassB ) -
 80341b8:	f004 fe9e 	bl	8038ef8 <Crc32>
    if( crc != nvmData->ClassB.Crc32 )
 80341bc:	f8d4 3b5c 	ldr.w	r3, [r4, #2908]	; 0xb5c
 80341c0:	4298      	cmp	r0, r3
    if( ( MacCtx.MacCallbacks != NULL ) &&
 80341c2:	f8d4 334c 	ldr.w	r3, [r4, #844]	; 0x34c
        nvmData->ClassB.Crc32 = crc;
 80341c6:	bf1c      	itt	ne
 80341c8:	f8c4 0b5c 	strne.w	r0, [r4, #2908]	; 0xb5c
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_CLASS_B;
 80341cc:	f045 0540 	orrne.w	r5, r5, #64	; 0x40
    if( ( MacCtx.MacCallbacks != NULL ) &&
 80341d0:	b11b      	cbz	r3, 80341da <LoRaMacProcess+0x3b2>
        ( MacCtx.MacCallbacks->NvmDataChange  != NULL ) )
 80341d2:	68db      	ldr	r3, [r3, #12]
    if( ( MacCtx.MacCallbacks != NULL ) &&
 80341d4:	b10b      	cbz	r3, 80341da <LoRaMacProcess+0x3b2>
        MacCtx.MacCallbacks->NvmDataChange ( notifyFlags );
 80341d6:	4628      	mov	r0, r5
 80341d8:	4798      	blx	r3
    MacCtx.AllowRequests = requestState;
 80341da:	2301      	movs	r3, #1
 80341dc:	f884 3486 	strb.w	r3, [r4, #1158]	; 0x486
    if( MacCtx.MacFlags.Bits.MlmeInd == 1 )
 80341e0:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 80341e4:	0718      	lsls	r0, r3, #28
 80341e6:	d50a      	bpl.n	80341fe <LoRaMacProcess+0x3d6>
        MacCtx.MacFlags.Bits.MlmeInd = 0;
 80341e8:	f36f 03c3 	bfc	r3, #3, #1
        MacCtx.MacPrimitives->MacMlmeIndication( &MacCtx.MlmeIndication, &MacCtx.RxStatus );
 80341ec:	4971      	ldr	r1, [pc, #452]	; (80343b4 <LoRaMacProcess+0x58c>)
        MacCtx.MacFlags.Bits.MlmeInd = 0;
 80341ee:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
        MacCtx.MacPrimitives->MacMlmeIndication( &MacCtx.MlmeIndication, &MacCtx.RxStatus );
 80341f2:	f8d4 3348 	ldr.w	r3, [r4, #840]	; 0x348
 80341f6:	f1a1 001c 	sub.w	r0, r1, #28
 80341fa:	68db      	ldr	r3, [r3, #12]
 80341fc:	4798      	blx	r3
    if( MacCtx.MacFlags.Bits.MlmeSchedUplinkInd == 1 )
 80341fe:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 8034202:	06d9      	lsls	r1, r3, #27
 8034204:	d50e      	bpl.n	8034224 <LoRaMacProcess+0x3fc>
        schduleUplinkIndication.MlmeIndication = MLME_SCHEDULE_UPLINK;
 8034206:	2307      	movs	r3, #7
 8034208:	f8ad 3060 	strh.w	r3, [sp, #96]	; 0x60
        MacCtx.MacPrimitives->MacMlmeIndication( &schduleUplinkIndication, &MacCtx.RxStatus );
 803420c:	f8d4 3348 	ldr.w	r3, [r4, #840]	; 0x348
 8034210:	4968      	ldr	r1, [pc, #416]	; (80343b4 <LoRaMacProcess+0x58c>)
 8034212:	68db      	ldr	r3, [r3, #12]
 8034214:	a818      	add	r0, sp, #96	; 0x60
 8034216:	4798      	blx	r3
        MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 0;
 8034218:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 803421c:	f36f 1304 	bfc	r3, #4, #1
 8034220:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
    if( MacCtx.MacFlags.Bits.McpsInd == 1 )
 8034224:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 8034228:	079a      	lsls	r2, r3, #30
 803422a:	d50a      	bpl.n	8034242 <LoRaMacProcess+0x41a>
        MacCtx.MacFlags.Bits.McpsInd = 0;
 803422c:	f36f 0341 	bfc	r3, #1, #1
        MacCtx.MacPrimitives->MacMcpsIndication( &MacCtx.McpsIndication, &MacCtx.RxStatus );
 8034230:	4960      	ldr	r1, [pc, #384]	; (80343b4 <LoRaMacProcess+0x58c>)
        MacCtx.MacFlags.Bits.McpsInd = 0;
 8034232:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
        MacCtx.MacPrimitives->MacMcpsIndication( &MacCtx.McpsIndication, &MacCtx.RxStatus );
 8034236:	f8d4 3348 	ldr.w	r3, [r4, #840]	; 0x348
 803423a:	f1a1 0060 	sub.w	r0, r1, #96	; 0x60
 803423e:	685b      	ldr	r3, [r3, #4]
 8034240:	4798      	blx	r3
    if( MacCtx.RxSlot == RX_SLOT_WIN_CLASS_C )
 8034242:	f894 3484 	ldrb.w	r3, [r4, #1156]	; 0x484
 8034246:	2b02      	cmp	r3, #2
 8034248:	d101      	bne.n	803424e <LoRaMacProcess+0x426>
        OpenContinuousRxCWindow( );
 803424a:	f7ff fa27 	bl	803369c <OpenContinuousRxCWindow>
}
 803424e:	b025      	add	sp, #148	; 0x94
 8034250:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 8034254:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 8034258:	2b01      	cmp	r3, #1
 803425a:	d10c      	bne.n	8034276 <LoRaMacProcess+0x44e>
        if( LoRaMacClassBIsPingExpected( ) == true )
 803425c:	f001 fb73 	bl	8035946 <LoRaMacClassBIsPingExpected>
 8034260:	4607      	mov	r7, r0
 8034262:	b1c8      	cbz	r0, 8034298 <LoRaMacProcess+0x470>
            LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 8034264:	4640      	mov	r0, r8
 8034266:	f001 fb63 	bl	8035930 <LoRaMacClassBSetPingSlotState>
            LoRaMacClassBPingSlotTimerEvent( NULL );
 803426a:	4640      	mov	r0, r8
 803426c:	f001 fb65 	bl	803593a <LoRaMacClassBPingSlotTimerEvent>
            MacCtx.RxStatus.RxSlot = RX_SLOT_WIN_CLASS_B_PING_SLOT;
 8034270:	2304      	movs	r3, #4
            MacCtx.RxStatus.RxSlot = RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT;
 8034272:	f884 3483 	strb.w	r3, [r4, #1155]	; 0x483
    macHdr.Value = payload[pktHeaderLen++];
 8034276:	f896 b000 	ldrb.w	fp, [r6]
    switch( macHdr.Bits.MType )
 803427a:	ea4f 135b 	mov.w	r3, fp, lsr #5
 803427e:	3b01      	subs	r3, #1
 8034280:	2b06      	cmp	r3, #6
 8034282:	f200 81e3 	bhi.w	803464c <LoRaMacProcess+0x824>
 8034286:	e8df f013 	tbh	[pc, r3, lsl #1]
 803428a:	0013      	.short	0x0013
 803428c:	009a01e1 	.word	0x009a01e1
 8034290:	009701e1 	.word	0x009701e1
 8034294:	01d201e1 	.word	0x01d201e1
        else if( LoRaMacClassBIsMulticastExpected( ) == true )
 8034298:	f001 fb57 	bl	803594a <LoRaMacClassBIsMulticastExpected>
 803429c:	2800      	cmp	r0, #0
 803429e:	d0ea      	beq.n	8034276 <LoRaMacProcess+0x44e>
            LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 80342a0:	4638      	mov	r0, r7
 80342a2:	f001 fb46 	bl	8035932 <LoRaMacClassBSetMulticastSlotState>
            LoRaMacClassBMulticastSlotTimerEvent( NULL );
 80342a6:	4638      	mov	r0, r7
 80342a8:	f001 fb48 	bl	803593c <LoRaMacClassBMulticastSlotTimerEvent>
            MacCtx.RxStatus.RxSlot = RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT;
 80342ac:	2305      	movs	r3, #5
 80342ae:	e7e0      	b.n	8034272 <LoRaMacProcess+0x44a>
            if( size < LORAMAC_JOIN_ACCEPT_FRAME_MIN_SIZE )
 80342b0:	2d10      	cmp	r5, #16
 80342b2:	d803      	bhi.n	80342bc <LoRaMacProcess+0x494>
                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 80342b4:	2301      	movs	r3, #1
 80342b6:	f884 3421 	strb.w	r3, [r4, #1057]	; 0x421
 80342ba:	e123      	b.n	8034504 <LoRaMacProcess+0x6dc>
            if( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE )
 80342bc:	f894 361c 	ldrb.w	r3, [r4, #1564]	; 0x61c
            macMsgJoinAccept.Buffer = payload;
 80342c0:	960e      	str	r6, [sp, #56]	; 0x38
            macMsgJoinAccept.BufSize = size;
 80342c2:	b2ed      	uxtb	r5, r5
 80342c4:	f88d 503c 	strb.w	r5, [sp, #60]	; 0x3c
            if( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE )
 80342c8:	2b00      	cmp	r3, #0
 80342ca:	d1f3      	bne.n	80342b4 <LoRaMacProcess+0x48c>
            macCryptoStatus = LoRaMacCryptoHandleJoinAccept( JOIN_REQ, SecureElementGetJoinEui( ), &macMsgJoinAccept );
 80342cc:	f004 fdd0 	bl	8038e70 <SecureElementGetJoinEui>
 80342d0:	aa0e      	add	r2, sp, #56	; 0x38
 80342d2:	4601      	mov	r1, r0
 80342d4:	20ff      	movs	r0, #255	; 0xff
 80342d6:	f001 ffdb 	bl	8036290 <LoRaMacCryptoHandleJoinAccept>
            if( LORAMAC_CRYPTO_SUCCESS == macCryptoStatus )
 80342da:	2800      	cmp	r0, #0
 80342dc:	d160      	bne.n	80343a0 <LoRaMacProcess+0x578>
                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[2] << 16 );
 80342de:	f89d 3043 	ldrb.w	r3, [sp, #67]	; 0x43
                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[1] << 8 );
 80342e2:	f89d 2042 	ldrb.w	r2, [sp, #66]	; 0x42
                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[2] << 16 );
 80342e6:	041b      	lsls	r3, r3, #16
 80342e8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
                Nvm.MacGroup2.NetID = ( uint32_t ) macMsgJoinAccept.NetID[0];
 80342ec:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[2] << 16 );
 80342f0:	4313      	orrs	r3, r2
 80342f2:	f8c4 35d4 	str.w	r3, [r4, #1492]	; 0x5d4
                Nvm.MacGroup2.DevAddr = macMsgJoinAccept.DevAddr;
 80342f6:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80342f8:	f8c4 35d8 	str.w	r3, [r4, #1496]	; 0x5d8
                Nvm.MacGroup2.MacParams.Rx1DrOffset = macMsgJoinAccept.DLSettings.Bits.RX1DRoffset;
 80342fc:	f89d 3048 	ldrb.w	r3, [sp, #72]	; 0x48
 8034300:	f3c3 1202 	ubfx	r2, r3, #4, #3
                Nvm.MacGroup2.MacParams.Rx2Channel.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;
 8034304:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8034308:	f884 3574 	strb.w	r3, [r4, #1396]	; 0x574
                Nvm.MacGroup2.MacParams.RxCChannel.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;
 803430c:	f884 357c 	strb.w	r3, [r4, #1404]	; 0x57c
                Nvm.MacGroup2.MacParams.ReceiveDelay1 = macMsgJoinAccept.RxDelay;
 8034310:	f89d 3049 	ldrb.w	r3, [sp, #73]	; 0x49
                Nvm.MacGroup2.MacParams.Rx1DrOffset = macMsgJoinAccept.DLSettings.Bits.RX1DRoffset;
 8034314:	f884 256d 	strb.w	r2, [r4, #1389]	; 0x56d
                if( Nvm.MacGroup2.MacParams.ReceiveDelay1 == 0 )
 8034318:	2b00      	cmp	r3, #0
 803431a:	d03f      	beq.n	803439c <LoRaMacProcess+0x574>
                    Nvm.MacGroup2.MacParams.ReceiveDelay1 = 1;
 803431c:	f8c4 355c 	str.w	r3, [r4, #1372]	; 0x55c
                Nvm.MacGroup2.MacParams.ReceiveDelay1 *= 1000;
 8034320:	f8d4 255c 	ldr.w	r2, [r4, #1372]	; 0x55c
                RegionApplyCFList( Nvm.MacGroup2.Region, &applyCFList );
 8034324:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
                Nvm.MacGroup2.MacParams.ReceiveDelay1 *= 1000;
 8034328:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 803432c:	4353      	muls	r3, r2
 803432e:	f8c4 355c 	str.w	r3, [r4, #1372]	; 0x55c
                Nvm.MacGroup2.MacParams.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay1 + 1000;
 8034332:	f503 737a 	add.w	r3, r3, #1000	; 0x3e8
 8034336:	f8c4 3560 	str.w	r3, [r4, #1376]	; 0x560
                Nvm.MacGroup2.Version.Fields.Minor = 0;
 803433a:	2600      	movs	r6, #0
                applyCFList.Payload = macMsgJoinAccept.CFList;
 803433c:	f10d 034a 	add.w	r3, sp, #74	; 0x4a
                applyCFList.Size = size - 17;
 8034340:	3d11      	subs	r5, #17
                RegionApplyCFList( Nvm.MacGroup2.Region, &applyCFList );
 8034342:	a90c      	add	r1, sp, #48	; 0x30
                applyCFList.Payload = macMsgJoinAccept.CFList;
 8034344:	930c      	str	r3, [sp, #48]	; 0x30
                Nvm.MacGroup2.Version.Fields.Minor = 0;
 8034346:	f884 661a 	strb.w	r6, [r4, #1562]	; 0x61a
                applyCFList.Size = size - 17;
 803434a:	f88d 5034 	strb.w	r5, [sp, #52]	; 0x34
                RegionApplyCFList( Nvm.MacGroup2.Region, &applyCFList );
 803434e:	f002 f9e3 	bl	8036718 <RegionApplyCFList>
                Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_OTAA;
 8034352:	2302      	movs	r3, #2
                if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )
 8034354:	2001      	movs	r0, #1
                Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_OTAA;
 8034356:	f884 361c 	strb.w	r3, [r4, #1564]	; 0x61c
                if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )
 803435a:	f001 fcb9 	bl	8035cd0 <LoRaMacConfirmQueueIsCmdActive>
 803435e:	b118      	cbz	r0, 8034368 <LoRaMacProcess+0x540>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_JOIN );
 8034360:	2101      	movs	r1, #1
 8034362:	4630      	mov	r0, r6
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL, MLME_JOIN );
 8034364:	f001 fc78 	bl	8035c58 <LoRaMacConfirmQueueSetStatus>
            MacCtx.MacFlags.Bits.MlmeInd = 1;
 8034368:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 803436c:	f043 0308 	orr.w	r3, r3, #8
            MacCtx.MacFlags.Bits.McpsInd = 1;
 8034370:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
    if( MacCtx.NodeAckRequested == true )
 8034374:	f894 3418 	ldrb.w	r3, [r4, #1048]	; 0x418
 8034378:	2b00      	cmp	r3, #0
 803437a:	f000 816d 	beq.w	8034658 <LoRaMacProcess+0x830>
        if( MacCtx.McpsConfirm.AckReceived == true )
 803437e:	f894 3440 	ldrb.w	r3, [r4, #1088]	; 0x440
 8034382:	b113      	cbz	r3, 803438a <LoRaMacProcess+0x562>
            OnAckTimeoutTimerEvent( NULL );
 8034384:	2000      	movs	r0, #0
 8034386:	f7fe fe33 	bl	8032ff0 <OnAckTimeoutTimerEvent>
    MacCtx.MacFlags.Bits.MacDone = 1;
 803438a:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 803438e:	f043 0320 	orr.w	r3, r3, #32
 8034392:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
    UpdateRxSlotIdleState( );
 8034396:	f7fe fde1 	bl	8032f5c <UpdateRxSlotIdleState>
 803439a:	e5f6      	b.n	8033f8a <LoRaMacProcess+0x162>
                    Nvm.MacGroup2.MacParams.ReceiveDelay1 = 1;
 803439c:	2301      	movs	r3, #1
 803439e:	e7bd      	b.n	803431c <LoRaMacProcess+0x4f4>
                if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )
 80343a0:	2001      	movs	r0, #1
 80343a2:	f001 fc95 	bl	8035cd0 <LoRaMacConfirmQueueIsCmdActive>
 80343a6:	2800      	cmp	r0, #0
 80343a8:	d0de      	beq.n	8034368 <LoRaMacProcess+0x540>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL, MLME_JOIN );
 80343aa:	2101      	movs	r1, #1
 80343ac:	2007      	movs	r0, #7
 80343ae:	e7d9      	b.n	8034364 <LoRaMacProcess+0x53c>
 80343b0:	200055ec 	.word	0x200055ec
 80343b4:	20004f24 	.word	0x20004f24
            MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED;
 80343b8:	2301      	movs	r3, #1
 80343ba:	f884 3420 	strb.w	r3, [r4, #1056]	; 0x420
            getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 80343be:	f894 3581 	ldrb.w	r3, [r4, #1409]	; 0x581
 80343c2:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
            getPhy.Datarate = MacCtx.McpsIndication.RxDatarate;
 80343c6:	f894 3424 	ldrb.w	r3, [r4, #1060]	; 0x424
 80343ca:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
            getPhy.Attribute = PHY_MAX_PAYLOAD;
 80343ce:	230d      	movs	r3, #13
 80343d0:	f88d 3020 	strb.w	r3, [sp, #32]
            if( Nvm.MacGroup2.MacParams.RepeaterSupport == true )
 80343d4:	f894 358c 	ldrb.w	r3, [r4, #1420]	; 0x58c
 80343d8:	b113      	cbz	r3, 80343e0 <LoRaMacProcess+0x5b8>
                getPhy.Attribute = PHY_MAX_PAYLOAD_REPEATER;
 80343da:	230e      	movs	r3, #14
 80343dc:	f88d 3020 	strb.w	r3, [sp, #32]
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80343e0:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
 80343e4:	a908      	add	r1, sp, #32
 80343e6:	f002 f964 	bl	80366b2 <RegionGetPhyParam>
            if( ( MAX( 0, ( int16_t )( ( int16_t ) size - ( int16_t ) LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE ) ) > ( int16_t )phyParam.Value ) ||
 80343ea:	f1a5 030d 	sub.w	r3, r5, #13
 80343ee:	b21b      	sxth	r3, r3
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80343f0:	9006      	str	r0, [sp, #24]
            if( ( MAX( 0, ( int16_t )( ( int16_t ) size - ( int16_t ) LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE ) ) > ( int16_t )phyParam.Value ) ||
 80343f2:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 80343f6:	b200      	sxth	r0, r0
 80343f8:	4283      	cmp	r3, r0
 80343fa:	f73f af5b 	bgt.w	80342b4 <LoRaMacProcess+0x48c>
 80343fe:	2d0b      	cmp	r5, #11
 8034400:	f67f af58 	bls.w	80342b4 <LoRaMacProcess+0x48c>
            macMsgData.FRMPayload = MacCtx.RxPayload;
 8034404:	4bb9      	ldr	r3, [pc, #740]	; (80346ec <LoRaMacProcess+0x8c4>)
 8034406:	9321      	str	r3, [sp, #132]	; 0x84
            if( LORAMAC_PARSER_SUCCESS != LoRaMacParserData( &macMsgData ) )
 8034408:	a818      	add	r0, sp, #96	; 0x60
            macMsgData.FRMPayloadSize = LORAMAC_PHY_MAXPAYLOAD;
 803440a:	23ff      	movs	r3, #255	; 0xff
            macMsgData.Buffer = payload;
 803440c:	9618      	str	r6, [sp, #96]	; 0x60
            macMsgData.BufSize = size;
 803440e:	f88d 5064 	strb.w	r5, [sp, #100]	; 0x64
            macMsgData.FRMPayloadSize = LORAMAC_PHY_MAXPAYLOAD;
 8034412:	f88d 3088 	strb.w	r3, [sp, #136]	; 0x88
            if( LORAMAC_PARSER_SUCCESS != LoRaMacParserData( &macMsgData ) )
 8034416:	f002 f843 	bl	80364a0 <LoRaMacParserData>
 803441a:	4606      	mov	r6, r0
 803441c:	2800      	cmp	r0, #0
 803441e:	f47f af49 	bne.w	80342b4 <LoRaMacProcess+0x48c>
    if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen > 0 ) && ( macMsg->FPort > 0 ) )
 8034422:	f89d 306c 	ldrb.w	r3, [sp, #108]	; 0x6c
            MacCtx.McpsIndication.DevAddress = macMsgData.FHDR.DevAddr;
 8034426:	991a      	ldr	r1, [sp, #104]	; 0x68
 8034428:	f8c4 1434 	str.w	r1, [r4, #1076]	; 0x434
    if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen > 0 ) && ( macMsg->FPort > 0 ) )
 803442c:	f013 020f 	ands.w	r2, r3, #15
 8034430:	d003      	beq.n	803443a <LoRaMacProcess+0x612>
 8034432:	f89d 0080 	ldrb.w	r0, [sp, #128]	; 0x80
 8034436:	2800      	cmp	r0, #0
 8034438:	d167      	bne.n	803450a <LoRaMacProcess+0x6e2>
    else if( macMsg->FRMPayloadSize == 0 )
 803443a:	f89d 0088 	ldrb.w	r0, [sp, #136]	; 0x88
 803443e:	2800      	cmp	r0, #0
 8034440:	d065      	beq.n	803450e <LoRaMacProcess+0x6e6>
    else if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen == 0 ) && ( macMsg->FPort == 0 ) )
 8034442:	2a00      	cmp	r2, #0
 8034444:	f47f af36 	bne.w	80342b4 <LoRaMacProcess+0x48c>
 8034448:	f89d 2080 	ldrb.w	r2, [sp, #128]	; 0x80
        *fType = FRAME_TYPE_D;
 803444c:	2a00      	cmp	r2, #0
 803444e:	bf0c      	ite	eq
 8034450:	2502      	moveq	r5, #2
 8034452:	2503      	movne	r5, #3
            downLinkCounter = 0;
 8034454:	2200      	movs	r2, #0
 8034456:	9207      	str	r2, [sp, #28]
                if( ( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.Address == macMsgData.FHDR.DevAddr ) &&
 8034458:	f8d4 25e0 	ldr.w	r2, [r4, #1504]	; 0x5e0
 803445c:	4291      	cmp	r1, r2
 803445e:	d158      	bne.n	8034512 <LoRaMacProcess+0x6ea>
 8034460:	f894 15de 	ldrb.w	r1, [r4, #1502]	; 0x5de
 8034464:	2900      	cmp	r1, #0
 8034466:	d054      	beq.n	8034512 <LoRaMacProcess+0x6ea>
                    downLinkCounter = *( Nvm.MacGroup2.MulticastChannelList[i].DownLinkCounter );
 8034468:	f8d4 15fc 	ldr.w	r1, [r4, #1532]	; 0x5fc
                    addrID = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.GroupID;
 803446c:	f894 85df 	ldrb.w	r8, [r4, #1503]	; 0x5df
                    downLinkCounter = *( Nvm.MacGroup2.MulticastChannelList[i].DownLinkCounter );
 8034470:	6809      	ldr	r1, [r1, #0]
 8034472:	9107      	str	r1, [sp, #28]
                    if( Nvm.MacGroup2.DeviceClass == CLASS_C )
 8034474:	f894 1608 	ldrb.w	r1, [r4, #1544]	; 0x608
 8034478:	2902      	cmp	r1, #2
 803447a:	d102      	bne.n	8034482 <LoRaMacProcess+0x65a>
                        MacCtx.RxStatus.RxSlot = RX_SLOT_WIN_CLASS_C_MULTICAST;
 803447c:	2103      	movs	r1, #3
 803447e:	f884 1483 	strb.w	r1, [r4, #1155]	; 0x483
            if( ( multicast == 1 ) && ( ( fType != FRAME_TYPE_D ) ||
 8034482:	2d03      	cmp	r5, #3
 8034484:	f47f af16 	bne.w	80342b4 <LoRaMacProcess+0x48c>
                                        ( macMsgData.FHDR.FCtrl.Bits.Ack != 0 ) ||
 8034488:	f013 0f60 	tst.w	r3, #96	; 0x60
 803448c:	f47f af12 	bne.w	80342b4 <LoRaMacProcess+0x48c>
 8034490:	9203      	str	r2, [sp, #12]
 8034492:	2601      	movs	r6, #1
            getPhy.Attribute = PHY_MAX_FCNT_GAP;
 8034494:	2315      	movs	r3, #21
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034496:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
            getPhy.Attribute = PHY_MAX_FCNT_GAP;
 803449a:	f88d 3020 	strb.w	r3, [sp, #32]
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803449e:	a908      	add	r1, sp, #32
 80344a0:	f002 f907 	bl	80366b2 <RegionGetPhyParam>
            macCryptoStatus = GetFCntDown( addrID, fType, &macMsgData, Nvm.MacGroup2.Version, phyParam.Value, &fCntID, &downLinkCounter );
 80344a4:	f894 761a 	ldrb.w	r7, [r4, #1562]	; 0x61a
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80344a8:	9006      	str	r0, [sp, #24]
    switch( addrID )
 80344aa:	f1b8 0f00 	cmp.w	r8, #0
 80344ae:	d033      	beq.n	8034518 <LoRaMacProcess+0x6f0>
 80344b0:	f1b8 0f01 	cmp.w	r8, #1
 80344b4:	d13c      	bne.n	8034530 <LoRaMacProcess+0x708>
            if( lrWanVersion.Fields.Minor == 1 )
 80344b6:	2f01      	cmp	r7, #1
 80344b8:	d130      	bne.n	803451c <LoRaMacProcess+0x6f4>
                if( ( fType == FRAME_TYPE_A ) || ( fType == FRAME_TYPE_D ) )
 80344ba:	b38d      	cbz	r5, 8034520 <LoRaMacProcess+0x6f8>
                    *fCntID = A_FCNT_DOWN;
 80344bc:	2d03      	cmp	r5, #3
 80344be:	bf14      	ite	ne
 80344c0:	4647      	movne	r7, r8
 80344c2:	2702      	moveq	r7, #2
    return LoRaMacCryptoGetFCntDown( *fCntID, maxFCntGap, macMsg->FHDR.FCnt, currentDown );
 80344c4:	f8bd 206e 	ldrh.w	r2, [sp, #110]	; 0x6e
 80344c8:	f8bd 1018 	ldrh.w	r1, [sp, #24]
 80344cc:	ab07      	add	r3, sp, #28
 80344ce:	4638      	mov	r0, r7
 80344d0:	f001 fd6c 	bl	8035fac <LoRaMacCryptoGetFCntDown>
            if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS )
 80344d4:	b370      	cbz	r0, 8034534 <LoRaMacProcess+0x70c>
                if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_FCNT_DUPLICATED )
 80344d6:	2807      	cmp	r0, #7
 80344d8:	d124      	bne.n	8034524 <LoRaMacProcess+0x6fc>
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_REPEATED;
 80344da:	2308      	movs	r3, #8
 80344dc:	f884 3421 	strb.w	r3, [r4, #1057]	; 0x421
                    if( ( Nvm.MacGroup2.Version.Fields.Minor == 0 ) && ( macHdr.Bits.MType == FRAME_TYPE_DATA_CONFIRMED_DOWN ) && ( Nvm.MacGroup1.LastRxMic == macMsgData.MIC ) )
 80344e0:	f894 361a 	ldrb.w	r3, [r4, #1562]	; 0x61a
 80344e4:	b95b      	cbnz	r3, 80344fe <LoRaMacProcess+0x6d6>
 80344e6:	f00b 03e0 	and.w	r3, fp, #224	; 0xe0
 80344ea:	2ba0      	cmp	r3, #160	; 0xa0
 80344ec:	d107      	bne.n	80344fe <LoRaMacProcess+0x6d6>
 80344ee:	f8d4 2540 	ldr.w	r2, [r4, #1344]	; 0x540
 80344f2:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 80344f4:	429a      	cmp	r2, r3
 80344f6:	d102      	bne.n	80344fe <LoRaMacProcess+0x6d6>
                        Nvm.MacGroup1.SrvAckRequested = true;
 80344f8:	2301      	movs	r3, #1
 80344fa:	f884 3546 	strb.w	r3, [r4, #1350]	; 0x546
                MacCtx.McpsIndication.DownLinkCounter = downLinkCounter;
 80344fe:	9b07      	ldr	r3, [sp, #28]
 8034500:	f8c4 3430 	str.w	r3, [r4, #1072]	; 0x430
                PrepareRxDoneAbort( );
 8034504:	f7fe fd96 	bl	8033034 <PrepareRxDoneAbort>
                return;
 8034508:	e53f      	b.n	8033f8a <LoRaMacProcess+0x162>
        *fType = FRAME_TYPE_A;
 803450a:	4635      	mov	r5, r6
 803450c:	e7a2      	b.n	8034454 <LoRaMacProcess+0x62c>
        *fType = FRAME_TYPE_B;
 803450e:	2501      	movs	r5, #1
 8034510:	e7a0      	b.n	8034454 <LoRaMacProcess+0x62c>
 8034512:	f04f 0801 	mov.w	r8, #1
 8034516:	e7bd      	b.n	8034494 <LoRaMacProcess+0x66c>
    switch( addrID )
 8034518:	2704      	movs	r7, #4
 803451a:	e7d3      	b.n	80344c4 <LoRaMacProcess+0x69c>
                *fCntID = FCNT_DOWN;
 803451c:	2703      	movs	r7, #3
 803451e:	e7d1      	b.n	80344c4 <LoRaMacProcess+0x69c>
                    *fCntID = A_FCNT_DOWN;
 8034520:	2702      	movs	r7, #2
 8034522:	e7cf      	b.n	80344c4 <LoRaMacProcess+0x69c>
                else if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_MAX_GAP_FCNT )
 8034524:	2808      	cmp	r0, #8
 8034526:	d103      	bne.n	8034530 <LoRaMacProcess+0x708>
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_TOO_MANY_FRAMES_LOSS;
 8034528:	230a      	movs	r3, #10
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 803452a:	f884 3421 	strb.w	r3, [r4, #1057]	; 0x421
 803452e:	e7e6      	b.n	80344fe <LoRaMacProcess+0x6d6>
 8034530:	2301      	movs	r3, #1
 8034532:	e7fa      	b.n	803452a <LoRaMacProcess+0x702>
            macCryptoStatus = LoRaMacCryptoUnsecureMessage( addrID, address, fCntID, downLinkCounter, &macMsgData );
 8034534:	ab18      	add	r3, sp, #96	; 0x60
 8034536:	9300      	str	r3, [sp, #0]
 8034538:	9903      	ldr	r1, [sp, #12]
 803453a:	9b07      	ldr	r3, [sp, #28]
 803453c:	463a      	mov	r2, r7
 803453e:	4640      	mov	r0, r8
 8034540:	f001 fe04 	bl	803614c <LoRaMacCryptoUnsecureMessage>
            if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS )
 8034544:	b120      	cbz	r0, 8034550 <LoRaMacProcess+0x728>
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_MIC_FAIL;
 8034546:	2802      	cmp	r0, #2
 8034548:	bf0c      	ite	eq
 803454a:	230b      	moveq	r3, #11
 803454c:	230c      	movne	r3, #12
 803454e:	e6b2      	b.n	80342b6 <LoRaMacProcess+0x48e>
            MacCtx.McpsIndication.FramePending = macMsgData.FHDR.FCtrl.Bits.FPending;
 8034550:	f89d 306c 	ldrb.w	r3, [sp, #108]	; 0x6c
            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK;
 8034554:	f884 0421 	strb.w	r0, [r4, #1057]	; 0x421
            MacCtx.McpsIndication.FramePending = macMsgData.FHDR.FCtrl.Bits.FPending;
 8034558:	f3c3 1200 	ubfx	r2, r3, #4, #1
 803455c:	f884 2425 	strb.w	r2, [r4, #1061]	; 0x425
            MacCtx.McpsIndication.DownLinkCounter = downLinkCounter;
 8034560:	9a07      	ldr	r2, [sp, #28]
 8034562:	f8c4 2430 	str.w	r2, [r4, #1072]	; 0x430
            if( ( MacCtx.RxStatus.RxSlot == RX_SLOT_WIN_1 ) ||
 8034566:	f894 2483 	ldrb.w	r2, [r4, #1155]	; 0x483
            MacCtx.McpsIndication.Multicast = multicast;
 803456a:	f884 6422 	strb.w	r6, [r4, #1058]	; 0x422
            if( ( MacCtx.RxStatus.RxSlot == RX_SLOT_WIN_1 ) ||
 803456e:	2a01      	cmp	r2, #1
            MacCtx.McpsIndication.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;
 8034570:	f3c3 1340 	ubfx	r3, r3, #5, #1
                Nvm.MacGroup1.AdrAckCounter = 0;
 8034574:	bf98      	it	ls
 8034576:	f8c4 0534 	strls.w	r0, [r4, #1332]	; 0x534
            if( multicast == 1 )
 803457a:	2e01      	cmp	r6, #1
            MacCtx.McpsIndication.Buffer = NULL;
 803457c:	f8c4 0428 	str.w	r0, [r4, #1064]	; 0x428
            MacCtx.McpsIndication.BufferSize = 0;
 8034580:	f884 042c 	strb.w	r0, [r4, #1068]	; 0x42c
            MacCtx.McpsIndication.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;
 8034584:	f884 342e 	strb.w	r3, [r4, #1070]	; 0x42e
            MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;
 8034588:	f884 043d 	strb.w	r0, [r4, #1085]	; 0x43d
            MacCtx.McpsConfirm.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;
 803458c:	f884 3440 	strb.w	r3, [r4, #1088]	; 0x440
            if( multicast == 1 )
 8034590:	d12b      	bne.n	80345ea <LoRaMacProcess+0x7c2>
                MacCtx.McpsIndication.McpsIndication = MCPS_MULTICAST;
 8034592:	2302      	movs	r3, #2
    if( rxSlot == RX_SLOT_WIN_1 || rxSlot == RX_SLOT_WIN_2  )
 8034594:	2a01      	cmp	r2, #1
                    MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED;
 8034596:	f884 3420 	strb.w	r3, [r4, #1056]	; 0x420
            RemoveMacCommands( MacCtx.RxStatus.RxSlot, macMsgData.FHDR.FCtrl, MacCtx.McpsConfirm.McpsRequest );
 803459a:	f894 143c 	ldrb.w	r1, [r4, #1084]	; 0x43c
 803459e:	f89d 306c 	ldrb.w	r3, [sp, #108]	; 0x6c
    if( rxSlot == RX_SLOT_WIN_1 || rxSlot == RX_SLOT_WIN_2  )
 80345a2:	d805      	bhi.n	80345b0 <LoRaMacProcess+0x788>
        if( request == MCPS_CONFIRMED )
 80345a4:	2901      	cmp	r1, #1
 80345a6:	d101      	bne.n	80345ac <LoRaMacProcess+0x784>
            if( fCtrl.Bits.Ack == 1 )
 80345a8:	069b      	lsls	r3, r3, #26
 80345aa:	d501      	bpl.n	80345b0 <LoRaMacProcess+0x788>
                LoRaMacCommandsRemoveStickyAnsCmds( );
 80345ac:	f001 fa7c 	bl	8035aa8 <LoRaMacCommandsRemoveStickyAnsCmds>
            switch( fType )
 80345b0:	2d02      	cmp	r5, #2
 80345b2:	d02d      	beq.n	8034610 <LoRaMacProcess+0x7e8>
 80345b4:	2d03      	cmp	r5, #3
 80345b6:	d009      	beq.n	80345cc <LoRaMacProcess+0x7a4>
 80345b8:	f89d 106c 	ldrb.w	r1, [sp, #108]	; 0x6c
 80345bc:	2d01      	cmp	r5, #1
                    ProcessMacCommands( macMsgData.FHDR.FOpts, 0, macMsgData.FHDR.FCtrl.Bits.FOptsLen, snr, MacCtx.RxStatus.RxSlot );
 80345be:	464a      	mov	r2, r9
 80345c0:	f001 010f 	and.w	r1, r1, #15
 80345c4:	a81c      	add	r0, sp, #112	; 0x70
 80345c6:	d027      	beq.n	8034618 <LoRaMacProcess+0x7f0>
 80345c8:	f7ff f950 	bl	803386c <ProcessMacCommands.isra.0.constprop.0>
                    MacCtx.McpsIndication.Port = macMsgData.FPort;
 80345cc:	f89d 3080 	ldrb.w	r3, [sp, #128]	; 0x80
 80345d0:	f884 3423 	strb.w	r3, [r4, #1059]	; 0x423
                    MacCtx.McpsIndication.Buffer = macMsgData.FRMPayload;
 80345d4:	9b21      	ldr	r3, [sp, #132]	; 0x84
 80345d6:	f8c4 3428 	str.w	r3, [r4, #1064]	; 0x428
                    MacCtx.McpsIndication.BufferSize = macMsgData.FRMPayloadSize;
 80345da:	f89d 3088 	ldrb.w	r3, [sp, #136]	; 0x88
 80345de:	f884 342c 	strb.w	r3, [r4, #1068]	; 0x42c
                    MacCtx.McpsIndication.RxData = true;
 80345e2:	2301      	movs	r3, #1
 80345e4:	f884 342d 	strb.w	r3, [r4, #1069]	; 0x42d
                    break;
 80345e8:	e01c      	b.n	8034624 <LoRaMacProcess+0x7fc>
                if( macHdr.Bits.MType == FRAME_TYPE_DATA_CONFIRMED_DOWN )
 80345ea:	f00b 03e0 	and.w	r3, fp, #224	; 0xe0
 80345ee:	2ba0      	cmp	r3, #160	; 0xa0
 80345f0:	d10a      	bne.n	8034608 <LoRaMacProcess+0x7e0>
                    if( Nvm.MacGroup2.Version.Fields.Minor == 0 )
 80345f2:	f894 161a 	ldrb.w	r1, [r4, #1562]	; 0x61a
                    Nvm.MacGroup1.SrvAckRequested = true;
 80345f6:	2301      	movs	r3, #1
 80345f8:	f884 3546 	strb.w	r3, [r4, #1350]	; 0x546
                    if( Nvm.MacGroup2.Version.Fields.Minor == 0 )
 80345fc:	2900      	cmp	r1, #0
 80345fe:	d1c9      	bne.n	8034594 <LoRaMacProcess+0x76c>
                        Nvm.MacGroup1.LastRxMic = macMsgData.MIC;
 8034600:	9923      	ldr	r1, [sp, #140]	; 0x8c
 8034602:	f8c4 1540 	str.w	r1, [r4, #1344]	; 0x540
                    MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED;
 8034606:	e7c5      	b.n	8034594 <LoRaMacProcess+0x76c>
                    Nvm.MacGroup1.SrvAckRequested = false;
 8034608:	2300      	movs	r3, #0
 803460a:	f884 3546 	strb.w	r3, [r4, #1350]	; 0x546
 803460e:	e7c1      	b.n	8034594 <LoRaMacProcess+0x76c>
                    ProcessMacCommands( macMsgData.FRMPayload, 0, macMsgData.FRMPayloadSize, snr, MacCtx.RxStatus.RxSlot );
 8034610:	f89d 1088 	ldrb.w	r1, [sp, #136]	; 0x88
 8034614:	9821      	ldr	r0, [sp, #132]	; 0x84
 8034616:	464a      	mov	r2, r9
 8034618:	f7ff f928 	bl	803386c <ProcessMacCommands.isra.0.constprop.0>
                    MacCtx.McpsIndication.Port = macMsgData.FPort;
 803461c:	f89d 3080 	ldrb.w	r3, [sp, #128]	; 0x80
 8034620:	f884 3423 	strb.w	r3, [r4, #1059]	; 0x423
            MacCtx.MacFlags.Bits.McpsInd = 1;
 8034624:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 8034628:	f043 0302 	orr.w	r3, r3, #2
 803462c:	e6a0      	b.n	8034370 <LoRaMacProcess+0x548>
            memcpy1( MacCtx.RxPayload, &payload[pktHeaderLen], size - pktHeaderLen );
 803462e:	4f2f      	ldr	r7, [pc, #188]	; (80346ec <LoRaMacProcess+0x8c4>)
 8034630:	3d01      	subs	r5, #1
 8034632:	b2aa      	uxth	r2, r5
 8034634:	1c71      	adds	r1, r6, #1
 8034636:	4638      	mov	r0, r7
 8034638:	f004 fc42 	bl	8038ec0 <memcpy1>
            MacCtx.McpsIndication.McpsIndication = MCPS_PROPRIETARY;
 803463c:	2303      	movs	r3, #3
 803463e:	f8a4 3420 	strh.w	r3, [r4, #1056]	; 0x420
            MacCtx.McpsIndication.Buffer = MacCtx.RxPayload;
 8034642:	f8c4 7428 	str.w	r7, [r4, #1064]	; 0x428
            MacCtx.McpsIndication.BufferSize = size - pktHeaderLen;
 8034646:	f884 542c 	strb.w	r5, [r4, #1068]	; 0x42c
            MacCtx.MacFlags.Bits.McpsInd = 1;
 803464a:	e7eb      	b.n	8034624 <LoRaMacProcess+0x7fc>
            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 803464c:	2301      	movs	r3, #1
 803464e:	f884 3421 	strb.w	r3, [r4, #1057]	; 0x421
            PrepareRxDoneAbort( );
 8034652:	f7fe fcef 	bl	8033034 <PrepareRxDoneAbort>
            break;
 8034656:	e68d      	b.n	8034374 <LoRaMacProcess+0x54c>
        if( Nvm.MacGroup2.DeviceClass == CLASS_C )
 8034658:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 803465c:	2b02      	cmp	r3, #2
 803465e:	f47f ae94 	bne.w	803438a <LoRaMacProcess+0x562>
 8034662:	e68f      	b.n	8034384 <LoRaMacProcess+0x55c>
    if( MacCtx.MacFlags.Bits.MlmeReq == 1 )
 8034664:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 8034668:	0759      	lsls	r1, r3, #29
 803466a:	d50f      	bpl.n	803468c <LoRaMacProcess+0x864>
        if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )
 803466c:	2001      	movs	r0, #1
 803466e:	f001 fb2f 	bl	8035cd0 <LoRaMacConfirmQueueIsCmdActive>
 8034672:	b380      	cbz	r0, 80346d6 <LoRaMacProcess+0x8ae>
            if( LoRaMacConfirmQueueGetStatus( MLME_JOIN ) == LORAMAC_EVENT_INFO_STATUS_OK )
 8034674:	2001      	movs	r0, #1
 8034676:	f001 fb01 	bl	8035c7c <LoRaMacConfirmQueueGetStatus>
 803467a:	b908      	cbnz	r0, 8034680 <LoRaMacProcess+0x858>
                MacCtx.ChannelsNbTransCounter = 0;
 803467c:	f884 0414 	strb.w	r0, [r4, #1044]	; 0x414
            MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 8034680:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 8034684:	f023 0302 	bic.w	r3, r3, #2
 8034688:	f8c4 3344 	str.w	r3, [r4, #836]	; 0x344
    if( MacCtx.MacFlags.Bits.McpsReq == 1 )
 803468c:	f894 1485 	ldrb.w	r1, [r4, #1157]	; 0x485
 8034690:	07ca      	lsls	r2, r1, #31
 8034692:	f57f accf 	bpl.w	8034034 <LoRaMacProcess+0x20c>
        if( ( MacCtx.McpsConfirm.McpsRequest == MCPS_UNCONFIRMED ) ||
 8034696:	f894 343c 	ldrb.w	r3, [r4, #1084]	; 0x43c
 803469a:	b10b      	cbz	r3, 80346a0 <LoRaMacProcess+0x878>
 803469c:	2b03      	cmp	r3, #3
 803469e:	d129      	bne.n	80346f4 <LoRaMacProcess+0x8cc>
    if( MacCtx.ChannelsNbTransCounter >=
 80346a0:	f894 2414 	ldrb.w	r2, [r4, #1044]	; 0x414
 80346a4:	f894 356c 	ldrb.w	r3, [r4, #1388]	; 0x56c
 80346a8:	429a      	cmp	r2, r3
 80346aa:	d208      	bcs.n	80346be <LoRaMacProcess+0x896>
    else if( MacCtx.MacFlags.Bits.McpsInd == 1 )
 80346ac:	078b      	lsls	r3, r1, #30
 80346ae:	d553      	bpl.n	8034758 <LoRaMacProcess+0x930>
        if( Nvm.MacGroup2.DeviceClass == CLASS_A )
 80346b0:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 80346b4:	b11b      	cbz	r3, 80346be <LoRaMacProcess+0x896>
            if( MacCtx.RxStatus.RxSlot == RX_SLOT_WIN_1 )
 80346b6:	f894 3483 	ldrb.w	r3, [r4, #1155]	; 0x483
 80346ba:	2b00      	cmp	r3, #0
 80346bc:	d14c      	bne.n	8034758 <LoRaMacProcess+0x930>
            TimerStop( &MacCtx.TxDelayedTimer );
 80346be:	480c      	ldr	r0, [pc, #48]	; (80346f0 <LoRaMacProcess+0x8c8>)
 80346c0:	f006 fe06 	bl	803b2d0 <UTIL_TIMER_Stop>
            MacCtx.MacState &= ~LORAMAC_TX_DELAYED;
 80346c4:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 80346c8:	f023 0320 	bic.w	r3, r3, #32
 80346cc:	f8c4 3344 	str.w	r3, [r4, #836]	; 0x344
            StopRetransmission( );
 80346d0:	f7fe fc50 	bl	8032f74 <StopRetransmission>
 80346d4:	e4ae      	b.n	8034034 <LoRaMacProcess+0x20c>
        else if( ( LoRaMacConfirmQueueIsCmdActive( MLME_TXCW ) == true ) ||
 80346d6:	2005      	movs	r0, #5
 80346d8:	f001 fafa 	bl	8035cd0 <LoRaMacConfirmQueueIsCmdActive>
 80346dc:	2800      	cmp	r0, #0
 80346de:	d1cf      	bne.n	8034680 <LoRaMacProcess+0x858>
                 ( LoRaMacConfirmQueueIsCmdActive( MLME_TXCW_1 ) == true ) )
 80346e0:	2006      	movs	r0, #6
 80346e2:	f001 faf5 	bl	8035cd0 <LoRaMacConfirmQueueIsCmdActive>
        else if( ( LoRaMacConfirmQueueIsCmdActive( MLME_TXCW ) == true ) ||
 80346e6:	2800      	cmp	r0, #0
 80346e8:	d1ca      	bne.n	8034680 <LoRaMacProcess+0x858>
 80346ea:	e7cf      	b.n	803468c <LoRaMacProcess+0x864>
 80346ec:	20004ce0 	.word	0x20004ce0
 80346f0:	20004e10 	.word	0x20004e10
        else if( MacCtx.McpsConfirm.McpsRequest == MCPS_CONFIRMED )
 80346f4:	2b01      	cmp	r3, #1
 80346f6:	d12f      	bne.n	8034758 <LoRaMacProcess+0x930>
            if( MacCtx.AckTimeoutRetry == true )
 80346f8:	f894 2417 	ldrb.w	r2, [r4, #1047]	; 0x417
 80346fc:	2a00      	cmp	r2, #0
 80346fe:	f43f ac99 	beq.w	8034034 <LoRaMacProcess+0x20c>
    if( MacCtx.AckTimeoutRetriesCounter >=
 8034702:	f894 3416 	ldrb.w	r3, [r4, #1046]	; 0x416
        MacCtx.AckTimeoutRetries )
 8034706:	f894 0415 	ldrb.w	r0, [r4, #1045]	; 0x415
    if( MacCtx.AckTimeoutRetriesCounter >=
 803470a:	4283      	cmp	r3, r0
 803470c:	d204      	bcs.n	8034718 <LoRaMacProcess+0x8f0>
    else if( MacCtx.MacFlags.Bits.McpsInd == 1 )
 803470e:	f011 0202 	ands.w	r2, r1, #2
        if( MacCtx.McpsConfirm.AckReceived == true )
 8034712:	bf18      	it	ne
 8034714:	f894 2440 	ldrbne.w	r2, [r4, #1088]	; 0x440
                if( Nvm.MacGroup2.Version.Fields.Minor == 0 )
 8034718:	f894 161a 	ldrb.w	r1, [r4, #1562]	; 0x61a
 803471c:	2900      	cmp	r1, #0
 803471e:	d13f      	bne.n	80347a0 <LoRaMacProcess+0x978>
                    if( stopRetransmission == false )
 8034720:	bb32      	cbnz	r2, 8034770 <LoRaMacProcess+0x948>
    if( MacCtx.AckTimeoutRetriesCounter < MacCtx.AckTimeoutRetries )
 8034722:	4283      	cmp	r3, r0
 8034724:	d218      	bcs.n	8034758 <LoRaMacProcess+0x930>
        MacCtx.AckTimeoutRetriesCounter++;
 8034726:	3301      	adds	r3, #1
 8034728:	b2db      	uxtb	r3, r3
        if( ( MacCtx.AckTimeoutRetriesCounter % 2 ) == 1 )
 803472a:	07df      	lsls	r7, r3, #31
        MacCtx.AckTimeoutRetriesCounter++;
 803472c:	f884 3416 	strb.w	r3, [r4, #1046]	; 0x416
        if( ( MacCtx.AckTimeoutRetriesCounter % 2 ) == 1 )
 8034730:	d512      	bpl.n	8034758 <LoRaMacProcess+0x930>
            getPhy.Attribute = PHY_NEXT_LOWER_TX_DR;
 8034732:	2322      	movs	r3, #34	; 0x22
 8034734:	f88d 3060 	strb.w	r3, [sp, #96]	; 0x60
            getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8034738:	f894 3580 	ldrb.w	r3, [r4, #1408]	; 0x580
 803473c:	f88d 3062 	strb.w	r3, [sp, #98]	; 0x62
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034740:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
            getPhy.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 8034744:	f894 3545 	ldrb.w	r3, [r4, #1349]	; 0x545
 8034748:	f88d 3061 	strb.w	r3, [sp, #97]	; 0x61
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803474c:	a918      	add	r1, sp, #96	; 0x60
 803474e:	f001 ffb0 	bl	80366b2 <RegionGetPhyParam>
 8034752:	900e      	str	r0, [sp, #56]	; 0x38
            Nvm.MacGroup1.ChannelsDatarate = phyParam.Value;
 8034754:	f884 0545 	strb.w	r0, [r4, #1349]	; 0x545
            MacCtx.MacFlags.Bits.MacDone = 0;
 8034758:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
            MacCtx.AckTimeoutRetry = false;
 803475c:	2000      	movs	r0, #0
            MacCtx.MacFlags.Bits.MacDone = 0;
 803475e:	f36f 1345 	bfc	r3, #5, #1
 8034762:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
            MacCtx.AckTimeoutRetry = false;
 8034766:	f884 0417 	strb.w	r0, [r4, #1047]	; 0x417
            OnTxDelayedTimerEvent( NULL );
 803476a:	f7fe ff71 	bl	8033650 <OnTxDelayedTimerEvent>
 803476e:	e461      	b.n	8034034 <LoRaMacProcess+0x20c>
    if( MacCtx.McpsConfirm.AckReceived == false )
 8034770:	f894 5440 	ldrb.w	r5, [r4, #1088]	; 0x440
 8034774:	b97d      	cbnz	r5, 8034796 <LoRaMacProcess+0x96e>
        params.Type = INIT_TYPE_ACTIVATE_DEFAULT_CHANNELS;
 8034776:	2302      	movs	r3, #2
 8034778:	f88d 3068 	strb.w	r3, [sp, #104]	; 0x68
        params.NvmGroup1 = &Nvm.RegionGroup1;
 803477c:	4b0a      	ldr	r3, [pc, #40]	; (80347a8 <LoRaMacProcess+0x980>)
 803477e:	9318      	str	r3, [sp, #96]	; 0x60
        RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 8034780:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
        params.NvmGroup2 = &Nvm.RegionGroup2;
 8034784:	33a4      	adds	r3, #164	; 0xa4
        RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 8034786:	a918      	add	r1, sp, #96	; 0x60
        params.NvmGroup2 = &Nvm.RegionGroup2;
 8034788:	9319      	str	r3, [sp, #100]	; 0x64
        RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 803478a:	f001 ffad 	bl	80366e8 <RegionInitDefaults>
        MacCtx.NodeAckRequested = false;
 803478e:	f884 5418 	strb.w	r5, [r4, #1048]	; 0x418
        MacCtx.McpsConfirm.AckReceived = false;
 8034792:	f884 5440 	strb.w	r5, [r4, #1088]	; 0x440
    MacCtx.McpsConfirm.NbRetries = MacCtx.AckTimeoutRetriesCounter;
 8034796:	f894 3416 	ldrb.w	r3, [r4, #1046]	; 0x416
 803479a:	f884 3441 	strb.w	r3, [r4, #1089]	; 0x441
        if( stopRetransmission == true )
 803479e:	e78e      	b.n	80346be <LoRaMacProcess+0x896>
 80347a0:	2a00      	cmp	r2, #0
 80347a2:	d0d9      	beq.n	8034758 <LoRaMacProcess+0x930>
 80347a4:	e78b      	b.n	80346be <LoRaMacProcess+0x896>
 80347a6:	bf00      	nop
 80347a8:	200051cc 	.word	0x200051cc

080347ac <LoRaMacInitialization>:
    return 0;
}


LoRaMacStatus_t LoRaMacInitialization( LoRaMacPrimitives_t* primitives, LoRaMacCallback_t* callbacks, LoRaMacRegion_t region )
{
 80347ac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80347b0:	4688      	mov	r8, r1
 80347b2:	b08a      	sub	sp, #40	; 0x28
 80347b4:	4691      	mov	r9, r2
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;

    if( ( primitives == NULL ) ||
 80347b6:	4606      	mov	r6, r0
 80347b8:	2800      	cmp	r0, #0
 80347ba:	f000 8197 	beq.w	8034aec <LoRaMacInitialization+0x340>
 80347be:	2900      	cmp	r1, #0
 80347c0:	f000 8194 	beq.w	8034aec <LoRaMacInitialization+0x340>
        ( callbacks == NULL ) )
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }

    if( ( primitives->MacMcpsConfirm == NULL ) ||
 80347c4:	6803      	ldr	r3, [r0, #0]
 80347c6:	2b00      	cmp	r3, #0
 80347c8:	f000 8190 	beq.w	8034aec <LoRaMacInitialization+0x340>
 80347cc:	6843      	ldr	r3, [r0, #4]
 80347ce:	2b00      	cmp	r3, #0
 80347d0:	f000 818c 	beq.w	8034aec <LoRaMacInitialization+0x340>
        ( primitives->MacMcpsIndication == NULL ) ||
 80347d4:	6883      	ldr	r3, [r0, #8]
 80347d6:	2b00      	cmp	r3, #0
 80347d8:	f000 8188 	beq.w	8034aec <LoRaMacInitialization+0x340>
        ( primitives->MacMlmeConfirm == NULL ) ||
 80347dc:	68c3      	ldr	r3, [r0, #12]
 80347de:	2b00      	cmp	r3, #0
 80347e0:	f000 8184 	beq.w	8034aec <LoRaMacInitialization+0x340>
        ( primitives->MacMlmeIndication == NULL ) )
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }
    // Verify if the region is supported
    if( RegionIsActive( region ) == false )
 80347e4:	4610      	mov	r0, r2
 80347e6:	f001 ff5b 	bl	80366a0 <RegionIsActive>
 80347ea:	2800      	cmp	r0, #0
 80347ec:	f000 8180 	beq.w	8034af0 <LoRaMacInitialization+0x344>

    // Confirm queue reset
    LoRaMacConfirmQueueInit( primitives );

    // Initialize the module context with zeros
    memset1( ( uint8_t* ) &Nvm, 0x00, sizeof( LoRaMacNvmData_t ) );
 80347f0:	4cc1      	ldr	r4, [pc, #772]	; (8034af8 <LoRaMacInitialization+0x34c>)
    LoRaMacConfirmQueueInit( primitives );
 80347f2:	4630      	mov	r0, r6
 80347f4:	f001 f9e4 	bl	8035bc0 <LoRaMacConfirmQueueInit>
    memset1( ( uint8_t* ) &Nvm, 0x00, sizeof( LoRaMacNvmData_t ) );
 80347f8:	f240 6254 	movw	r2, #1620	; 0x654
 80347fc:	2100      	movs	r1, #0
 80347fe:	f204 500c 	addw	r0, r4, #1292	; 0x50c
 8034802:	f004 fb71 	bl	8038ee8 <memset1>
    memset1( ( uint8_t* ) &MacCtx, 0x00, sizeof( LoRaMacCtx_t ) );
 8034806:	f44f 62a1 	mov.w	r2, #1288	; 0x508
 803480a:	2100      	movs	r1, #0
 803480c:	1d20      	adds	r0, r4, #4
 803480e:	f004 fb6b 	bl	8038ee8 <memset1>
    Nvm.MacGroup2.Region = region;
    Nvm.MacGroup2.DeviceClass = CLASS_A;
    Nvm.MacGroup2.MacParams.RepeaterSupport = false; /* ST_WORKAROUND: Keep repeater feature */

    // Setup version
    Nvm.MacGroup2.Version.Value = LORAMAC_VERSION;
 8034812:	4bba      	ldr	r3, [pc, #744]	; (8034afc <LoRaMacInitialization+0x350>)
 8034814:	f8c4 3618 	str.w	r3, [r4, #1560]	; 0x618
    Nvm.MacGroup2.DeviceClass = CLASS_A;
 8034818:	2500      	movs	r5, #0
    MacCtx.AckTimeoutRetriesCounter = 1;
 803481a:	2701      	movs	r7, #1

    // Reset to defaults
    getPhy.Attribute = PHY_DUTY_CYCLE;
 803481c:	230f      	movs	r3, #15
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803481e:	a905      	add	r1, sp, #20
 8034820:	4648      	mov	r0, r9
    getPhy.Attribute = PHY_DUTY_CYCLE;
 8034822:	f88d 3014 	strb.w	r3, [sp, #20]
    Nvm.MacGroup2.Region = region;
 8034826:	f884 954c 	strb.w	r9, [r4, #1356]	; 0x54c
    Nvm.MacGroup2.DeviceClass = CLASS_A;
 803482a:	f884 5608 	strb.w	r5, [r4, #1544]	; 0x608
    Nvm.MacGroup2.MacParams.RepeaterSupport = false; /* ST_WORKAROUND: Keep repeater feature */
 803482e:	f884 558c 	strb.w	r5, [r4, #1420]	; 0x58c
    MacCtx.AckTimeoutRetriesCounter = 1;
 8034832:	f884 7416 	strb.w	r7, [r4, #1046]	; 0x416
    MacCtx.AckTimeoutRetries = 1;
 8034836:	f884 7415 	strb.w	r7, [r4, #1045]	; 0x415
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803483a:	f001 ff3a 	bl	80366b2 <RegionGetPhyParam>
    Nvm.MacGroup2.DutyCycleOn = ( bool ) phyParam.Value;
 803483e:	1b40      	subs	r0, r0, r5
 8034840:	bf18      	it	ne
 8034842:	2001      	movne	r0, #1

    getPhy.Attribute = PHY_DEF_TX_POWER;
 8034844:	f04f 0a0a 	mov.w	sl, #10
    Nvm.MacGroup2.DutyCycleOn = ( bool ) phyParam.Value;
 8034848:	f884 060c 	strb.w	r0, [r4, #1548]	; 0x60c
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803484c:	a905      	add	r1, sp, #20
 803484e:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_TX_POWER;
 8034852:	f88d a014 	strb.w	sl, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034856:	f001 ff2c 	bl	80366b2 <RegionGetPhyParam>
    Nvm.MacGroup2.ChannelsTxPowerDefault = phyParam.Value;

    getPhy.Attribute = PHY_DEF_TX_DR;
 803485a:	f04f 0906 	mov.w	r9, #6
    Nvm.MacGroup2.ChannelsTxPowerDefault = phyParam.Value;
 803485e:	f884 05d0 	strb.w	r0, [r4, #1488]	; 0x5d0
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034862:	a905      	add	r1, sp, #20
 8034864:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_TX_DR;
 8034868:	f88d 9014 	strb.w	r9, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803486c:	f001 ff21 	bl	80366b2 <RegionGetPhyParam>
    Nvm.MacGroup2.ChannelsDatarateDefault = phyParam.Value;

    getPhy.Attribute = PHY_MAX_RX_WINDOW;
 8034870:	2310      	movs	r3, #16
    Nvm.MacGroup2.ChannelsDatarateDefault = phyParam.Value;
 8034872:	f884 05d1 	strb.w	r0, [r4, #1489]	; 0x5d1
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034876:	a905      	add	r1, sp, #20
 8034878:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_MAX_RX_WINDOW;
 803487c:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034880:	f001 ff17 	bl	80366b2 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.MaxRxWindow = phyParam.Value;

    getPhy.Attribute = PHY_RECEIVE_DELAY1;
 8034884:	2311      	movs	r3, #17
    Nvm.MacGroup2.MacParamsDefaults.MaxRxWindow = phyParam.Value;
 8034886:	f8c4 0598 	str.w	r0, [r4, #1432]	; 0x598
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803488a:	a905      	add	r1, sp, #20
 803488c:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_RECEIVE_DELAY1;
 8034890:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034894:	f001 ff0d 	bl	80366b2 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay1 = phyParam.Value;

    getPhy.Attribute = PHY_RECEIVE_DELAY2;
 8034898:	2312      	movs	r3, #18
    Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay1 = phyParam.Value;
 803489a:	f8c4 059c 	str.w	r0, [r4, #1436]	; 0x59c
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803489e:	a905      	add	r1, sp, #20
 80348a0:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_RECEIVE_DELAY2;
 80348a4:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348a8:	f001 ff03 	bl	80366b2 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay2 = phyParam.Value;

    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY1;
 80348ac:	2313      	movs	r3, #19
    Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay2 = phyParam.Value;
 80348ae:	f8c4 05a0 	str.w	r0, [r4, #1440]	; 0x5a0
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348b2:	a905      	add	r1, sp, #20
 80348b4:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY1;
 80348b8:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348bc:	f001 fef9 	bl	80366b2 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay1 = phyParam.Value;

    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY2;
 80348c0:	2314      	movs	r3, #20
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348c2:	eb0d 0103 	add.w	r1, sp, r3
    Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay1 = phyParam.Value;
 80348c6:	f8c4 05a4 	str.w	r0, [r4, #1444]	; 0x5a4
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348ca:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY2;
 80348ce:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348d2:	f001 feee 	bl	80366b2 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay2 = phyParam.Value;

    getPhy.Attribute = PHY_DEF_DR1_OFFSET;
 80348d6:	2317      	movs	r3, #23
    Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay2 = phyParam.Value;
 80348d8:	f8c4 05a8 	str.w	r0, [r4, #1448]	; 0x5a8
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348dc:	a905      	add	r1, sp, #20
 80348de:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_DR1_OFFSET;
 80348e2:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348e6:	f001 fee4 	bl	80366b2 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.Rx1DrOffset = phyParam.Value;

    getPhy.Attribute = PHY_DEF_RX2_FREQUENCY;
 80348ea:	2318      	movs	r3, #24
    Nvm.MacGroup2.MacParamsDefaults.Rx1DrOffset = phyParam.Value;
 80348ec:	f884 05ad 	strb.w	r0, [r4, #1453]	; 0x5ad
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348f0:	a905      	add	r1, sp, #20
 80348f2:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_RX2_FREQUENCY;
 80348f6:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348fa:	f001 feda 	bl	80366b2 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.Rx2Channel.Frequency = phyParam.Value;
    Nvm.MacGroup2.MacParamsDefaults.RxCChannel.Frequency = phyParam.Value;

    getPhy.Attribute = PHY_DEF_RX2_DR;
 80348fe:	2319      	movs	r3, #25
    Nvm.MacGroup2.MacParamsDefaults.Rx2Channel.Frequency = phyParam.Value;
 8034900:	f8c4 05b0 	str.w	r0, [r4, #1456]	; 0x5b0
    Nvm.MacGroup2.MacParamsDefaults.RxCChannel.Frequency = phyParam.Value;
 8034904:	f8c4 05b8 	str.w	r0, [r4, #1464]	; 0x5b8
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034908:	a905      	add	r1, sp, #20
 803490a:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_RX2_DR;
 803490e:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034912:	f001 fece 	bl	80366b2 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.Rx2Channel.Datarate = phyParam.Value;
 8034916:	b2c0      	uxtb	r0, r0
    Nvm.MacGroup2.MacParamsDefaults.RxCChannel.Datarate = phyParam.Value;

    getPhy.Attribute = PHY_DEF_UPLINK_DWELL_TIME;
 8034918:	231e      	movs	r3, #30
    Nvm.MacGroup2.MacParamsDefaults.Rx2Channel.Datarate = phyParam.Value;
 803491a:	f884 05b4 	strb.w	r0, [r4, #1460]	; 0x5b4
    Nvm.MacGroup2.MacParamsDefaults.RxCChannel.Datarate = phyParam.Value;
 803491e:	f884 05bc 	strb.w	r0, [r4, #1468]	; 0x5bc
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034922:	a905      	add	r1, sp, #20
 8034924:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_UPLINK_DWELL_TIME;
 8034928:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803492c:	f001 fec1 	bl	80366b2 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.UplinkDwellTime = phyParam.Value;

    getPhy.Attribute = PHY_DEF_DOWNLINK_DWELL_TIME;
 8034930:	231f      	movs	r3, #31
    Nvm.MacGroup2.MacParamsDefaults.UplinkDwellTime = phyParam.Value;
 8034932:	f884 05c0 	strb.w	r0, [r4, #1472]	; 0x5c0
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034936:	a905      	add	r1, sp, #20
 8034938:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_DOWNLINK_DWELL_TIME;
 803493c:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034940:	f001 feb7 	bl	80366b2 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.DownlinkDwellTime = phyParam.Value;

    getPhy.Attribute = PHY_DEF_MAX_EIRP;
 8034944:	2320      	movs	r3, #32
    Nvm.MacGroup2.MacParamsDefaults.DownlinkDwellTime = phyParam.Value;
 8034946:	f884 05c1 	strb.w	r0, [r4, #1473]	; 0x5c1
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803494a:	a905      	add	r1, sp, #20
 803494c:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_MAX_EIRP;
 8034950:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034954:	f001 fead 	bl	80366b2 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.MaxEirp = phyParam.fValue;

    getPhy.Attribute = PHY_DEF_ANTENNA_GAIN;
 8034958:	2321      	movs	r3, #33	; 0x21
    Nvm.MacGroup2.MacParamsDefaults.MaxEirp = phyParam.fValue;
 803495a:	f8c4 05c4 	str.w	r0, [r4, #1476]	; 0x5c4
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803495e:	a905      	add	r1, sp, #20
 8034960:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_ANTENNA_GAIN;
 8034964:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034968:	f001 fea3 	bl	80366b2 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.AntennaGain = phyParam.fValue;

    getPhy.Attribute = PHY_DEF_ADR_ACK_LIMIT;
 803496c:	230b      	movs	r3, #11
    Nvm.MacGroup2.MacParamsDefaults.AntennaGain = phyParam.fValue;
 803496e:	f8c4 05c8 	str.w	r0, [r4, #1480]	; 0x5c8
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034972:	a905      	add	r1, sp, #20
 8034974:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_ADR_ACK_LIMIT;
 8034978:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803497c:	f001 fe99 	bl	80366b2 <RegionGetPhyParam>
    MacCtx.AdrAckLimit = phyParam.Value;

    getPhy.Attribute = PHY_DEF_ADR_ACK_DELAY;
 8034980:	230c      	movs	r3, #12
    MacCtx.AdrAckLimit = phyParam.Value;
 8034982:	f8a4 03f8 	strh.w	r0, [r4, #1016]	; 0x3f8
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034986:	a905      	add	r1, sp, #20
 8034988:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_ADR_ACK_DELAY;
 803498c:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034990:	f001 fe8f 	bl	80366b2 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError = 10;
    Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols = 6;

    Nvm.MacGroup2.MacParams.SystemMaxRxError = Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError;
    Nvm.MacGroup2.MacParams.MinRxSymbols = Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols;
    Nvm.MacGroup2.MacParams.MaxRxWindow = Nvm.MacGroup2.MacParamsDefaults.MaxRxWindow;
 8034994:	f8d4 3598 	ldr.w	r3, [r4, #1432]	; 0x598
 8034998:	f8c4 3558 	str.w	r3, [r4, #1368]	; 0x558
    Nvm.MacGroup2.MacParams.ReceiveDelay1 = Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay1;
 803499c:	f8d4 359c 	ldr.w	r3, [r4, #1436]	; 0x59c
 80349a0:	f8c4 355c 	str.w	r3, [r4, #1372]	; 0x55c
    Nvm.MacGroup2.MacParams.ReceiveDelay2 = Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay2;
 80349a4:	f8d4 35a0 	ldr.w	r3, [r4, #1440]	; 0x5a0
 80349a8:	f8c4 3560 	str.w	r3, [r4, #1376]	; 0x560
    Nvm.MacGroup2.MacParams.JoinAcceptDelay1 = Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay1;
 80349ac:	f8d4 35a4 	ldr.w	r3, [r4, #1444]	; 0x5a4
 80349b0:	f8c4 3564 	str.w	r3, [r4, #1380]	; 0x564
    Nvm.MacGroup2.MacParams.JoinAcceptDelay2 = Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay2;
 80349b4:	f8d4 35a8 	ldr.w	r3, [r4, #1448]	; 0x5a8
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80349b8:	9004      	str	r0, [sp, #16]

    InitDefaultsParams_t params;
    params.Type = INIT_TYPE_DEFAULTS;
    params.NvmGroup1 = &Nvm.RegionGroup1;
    params.NvmGroup2 = &Nvm.RegionGroup2;
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 80349ba:	a907      	add	r1, sp, #28
    MacCtx.AdrAckDelay = phyParam.Value;
 80349bc:	f8a4 03fa 	strh.w	r0, [r4, #1018]	; 0x3fa
    Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols = 6;
 80349c0:	f884 9594 	strb.w	r9, [r4, #1428]	; 0x594
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 80349c4:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    Nvm.MacGroup2.MacParams.MinRxSymbols = Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols;
 80349c8:	f884 9554 	strb.w	r9, [r4, #1364]	; 0x554
    Nvm.MacGroup2.MacParams.JoinAcceptDelay2 = Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay2;
 80349cc:	f8c4 3568 	str.w	r3, [r4, #1384]	; 0x568
    params.NvmGroup1 = &Nvm.RegionGroup1;
 80349d0:	f504 69e5 	add.w	r9, r4, #1832	; 0x728
    params.NvmGroup2 = &Nvm.RegionGroup2;
 80349d4:	f204 73cc 	addw	r3, r4, #1996	; 0x7cc
 80349d8:	9308      	str	r3, [sp, #32]
    params.Type = INIT_TYPE_DEFAULTS;
 80349da:	f88d 5024 	strb.w	r5, [sp, #36]	; 0x24
    Nvm.MacGroup2.MacParamsDefaults.ChannelsNbTrans = 1;
 80349de:	f884 75ac 	strb.w	r7, [r4, #1452]	; 0x5ac
    Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError = 10;
 80349e2:	f8c4 a590 	str.w	sl, [r4, #1424]	; 0x590
    Nvm.MacGroup2.MacParams.SystemMaxRxError = Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError;
 80349e6:	f8c4 a550 	str.w	sl, [r4, #1360]	; 0x550
    Nvm.MacGroup2.MacParams.ChannelsNbTrans = Nvm.MacGroup2.MacParamsDefaults.ChannelsNbTrans;
 80349ea:	f884 756c 	strb.w	r7, [r4, #1388]	; 0x56c
    params.NvmGroup1 = &Nvm.RegionGroup1;
 80349ee:	f8cd 901c 	str.w	r9, [sp, #28]
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 80349f2:	f001 fe79 	bl	80366e8 <RegionInitDefaults>

    MacCtx.MacCallbacks = callbacks;
 80349f6:	f8c4 834c 	str.w	r8, [r4, #844]	; 0x34c
    ResetMacParameters( );
 80349fa:	f7fe fc1b 	bl	8033234 <ResetMacParameters>
    // Reset duty cycle times
    Nvm.MacGroup1.LastTxDoneTime = 0;
    Nvm.MacGroup1.AggregatedTimeOff = 0;

    // Initialize timers
    TimerInit( &MacCtx.TxDelayedTimer, OnTxDelayedTimerEvent );
 80349fe:	462a      	mov	r2, r5
 8034a00:	4b3f      	ldr	r3, [pc, #252]	; (8034b00 <LoRaMacInitialization+0x354>)
 8034a02:	9500      	str	r5, [sp, #0]
 8034a04:	f04f 31ff 	mov.w	r1, #4294967295
 8034a08:	f504 705b 	add.w	r0, r4, #876	; 0x36c
    MacCtx.MacPrimitives = primitives;
 8034a0c:	f8c4 6348 	str.w	r6, [r4, #840]	; 0x348
    MacCtx.MacFlags.Value = 0;
 8034a10:	f884 5485 	strb.w	r5, [r4, #1157]	; 0x485
    Nvm.MacGroup1.LastTxDoneTime = 0;
 8034a14:	f8c4 5538 	str.w	r5, [r4, #1336]	; 0x538
    Nvm.MacGroup1.AggregatedTimeOff = 0;
 8034a18:	f8c4 553c 	str.w	r5, [r4, #1340]	; 0x53c
    Nvm.MacGroup2.PublicNetwork = true;
 8034a1c:	f884 7609 	strb.w	r7, [r4, #1545]	; 0x609
    MacCtx.MacState = LORAMAC_STOPPED;
 8034a20:	f8c4 7344 	str.w	r7, [r4, #836]	; 0x344
    TimerInit( &MacCtx.TxDelayedTimer, OnTxDelayedTimerEvent );
 8034a24:	f006 fbf6 	bl	803b214 <UTIL_TIMER_Create>
    TimerInit( &MacCtx.RxWindowTimer1, OnRxWindow1TimerEvent );
 8034a28:	462a      	mov	r2, r5
 8034a2a:	4b36      	ldr	r3, [pc, #216]	; (8034b04 <LoRaMacInitialization+0x358>)
 8034a2c:	9500      	str	r5, [sp, #0]
 8034a2e:	f04f 31ff 	mov.w	r1, #4294967295
 8034a32:	f504 7061 	add.w	r0, r4, #900	; 0x384
 8034a36:	f006 fbed 	bl	803b214 <UTIL_TIMER_Create>
    TimerInit( &MacCtx.RxWindowTimer2, OnRxWindow2TimerEvent );
 8034a3a:	462a      	mov	r2, r5
 8034a3c:	4b32      	ldr	r3, [pc, #200]	; (8034b08 <LoRaMacInitialization+0x35c>)
 8034a3e:	9500      	str	r5, [sp, #0]
 8034a40:	f04f 31ff 	mov.w	r1, #4294967295
 8034a44:	f504 7067 	add.w	r0, r4, #924	; 0x39c
 8034a48:	f006 fbe4 	bl	803b214 <UTIL_TIMER_Create>
    TimerInit( &MacCtx.AckTimeoutTimer, OnAckTimeoutTimerEvent );
 8034a4c:	462a      	mov	r2, r5
 8034a4e:	4b2f      	ldr	r3, [pc, #188]	; (8034b0c <LoRaMacInitialization+0x360>)
 8034a50:	9500      	str	r5, [sp, #0]
 8034a52:	f04f 31ff 	mov.w	r1, #4294967295

    // Store the current initialization time
    Nvm.MacGroup2.InitializationTime = SysTimeGetMcuTime( );
 8034a56:	ad02      	add	r5, sp, #8
    TimerInit( &MacCtx.AckTimeoutTimer, OnAckTimeoutTimerEvent );
 8034a58:	f504 707f 	add.w	r0, r4, #1020	; 0x3fc
 8034a5c:	f006 fbda 	bl	803b214 <UTIL_TIMER_Create>
    Nvm.MacGroup2.InitializationTime = SysTimeGetMcuTime( );
 8034a60:	4628      	mov	r0, r5
 8034a62:	f006 fb6d 	bl	803b140 <SysTimeGetMcuTime>
 8034a66:	e895 0003 	ldmia.w	r5, {r0, r1}
 8034a6a:	f504 63c2 	add.w	r3, r4, #1552	; 0x610
 8034a6e:	e883 0003 	stmia.w	r3, {r0, r1}

    // Initialize Radio driver
    MacCtx.RadioEvents.TxDone = OnRadioTxDone;
 8034a72:	4b27      	ldr	r3, [pc, #156]	; (8034b10 <LoRaMacInitialization+0x364>)
 8034a74:	f8c4 3350 	str.w	r3, [r4, #848]	; 0x350
    MacCtx.RadioEvents.RxDone = OnRadioRxDone;
 8034a78:	4b26      	ldr	r3, [pc, #152]	; (8034b14 <LoRaMacInitialization+0x368>)
 8034a7a:	f8c4 3358 	str.w	r3, [r4, #856]	; 0x358
    MacCtx.RadioEvents.RxError = OnRadioRxError;
 8034a7e:	4b26      	ldr	r3, [pc, #152]	; (8034b18 <LoRaMacInitialization+0x36c>)
 8034a80:	f8c4 3360 	str.w	r3, [r4, #864]	; 0x360
    MacCtx.RadioEvents.TxTimeout = OnRadioTxTimeout;
    MacCtx.RadioEvents.RxTimeout = OnRadioRxTimeout;
    Radio.Init( &MacCtx.RadioEvents );
 8034a84:	4e25      	ldr	r6, [pc, #148]	; (8034b1c <LoRaMacInitialization+0x370>)
    MacCtx.RadioEvents.TxTimeout = OnRadioTxTimeout;
 8034a86:	4b26      	ldr	r3, [pc, #152]	; (8034b20 <LoRaMacInitialization+0x374>)
 8034a88:	f8c4 3354 	str.w	r3, [r4, #852]	; 0x354
    MacCtx.RadioEvents.RxTimeout = OnRadioRxTimeout;
 8034a8c:	4b25      	ldr	r3, [pc, #148]	; (8034b24 <LoRaMacInitialization+0x378>)
 8034a8e:	f8c4 335c 	str.w	r3, [r4, #860]	; 0x35c
    Radio.Init( &MacCtx.RadioEvents );
 8034a92:	f504 7054 	add.w	r0, r4, #848	; 0x350
 8034a96:	6833      	ldr	r3, [r6, #0]
 8034a98:	4798      	blx	r3

    // Initialize the Secure Element driver
    if( SecureElementInit( &Nvm.SecureElement, callbacks->GetUniqueId ) != SECURE_ELEMENT_SUCCESS ) /* ST_WORKAROUND: Add unique ID callback as input parameter */
 8034a9a:	f8d8 1008 	ldr.w	r1, [r8, #8]
 8034a9e:	f204 6024 	addw	r0, r4, #1572	; 0x624
 8034aa2:	f003 feeb 	bl	803887c <SecureElementInit>
 8034aa6:	b120      	cbz	r0, 8034ab2 <LoRaMacInitialization+0x306>
    {
        return LORAMAC_STATUS_CRYPTO_ERROR;
 8034aa8:	2511      	movs	r5, #17
    Radio.Sleep( );

    LoRaMacEnableRequests( LORAMAC_REQUEST_HANDLING_ON );

    return LORAMAC_STATUS_OK;
}
 8034aaa:	4628      	mov	r0, r5
 8034aac:	b00a      	add	sp, #40	; 0x28
 8034aae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if( LoRaMacCryptoInit( &Nvm.Crypto ) != LORAMAC_CRYPTO_SUCCESS )
 8034ab2:	f5a9 7007 	sub.w	r0, r9, #540	; 0x21c
 8034ab6:	f001 fa49 	bl	8035f4c <LoRaMacCryptoInit>
 8034aba:	2800      	cmp	r0, #0
 8034abc:	d1f4      	bne.n	8034aa8 <LoRaMacInitialization+0x2fc>
    if( LoRaMacCommandsInit( ) != LORAMAC_COMMANDS_SUCCESS )
 8034abe:	f000 ff5d 	bl	803597c <LoRaMacCommandsInit>
 8034ac2:	b9b8      	cbnz	r0, 8034af4 <LoRaMacInitialization+0x348>
    if( LoRaMacCryptoSetMulticastReference( Nvm.MacGroup2.MulticastChannelList ) != LORAMAC_CRYPTO_SUCCESS )
 8034ac4:	4818      	ldr	r0, [pc, #96]	; (8034b28 <LoRaMacInitialization+0x37c>)
 8034ac6:	f001 faa7 	bl	8036018 <LoRaMacCryptoSetMulticastReference>
 8034aca:	4605      	mov	r5, r0
 8034acc:	2800      	cmp	r0, #0
 8034ace:	d1eb      	bne.n	8034aa8 <LoRaMacInitialization+0x2fc>
    srand1( Radio.Random( ) );
 8034ad0:	6973      	ldr	r3, [r6, #20]
 8034ad2:	4798      	blx	r3
 8034ad4:	f004 f9d2 	bl	8038e7c <srand1>
    Radio.SetPublicNetwork( Nvm.MacGroup2.PublicNetwork );
 8034ad8:	6db3      	ldr	r3, [r6, #88]	; 0x58
 8034ada:	f894 0609 	ldrb.w	r0, [r4, #1545]	; 0x609
 8034ade:	4798      	blx	r3
    Radio.Sleep( );
 8034ae0:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8034ae2:	4798      	blx	r3
    MacCtx.AllowRequests = requestState;
 8034ae4:	2301      	movs	r3, #1
 8034ae6:	f884 3486 	strb.w	r3, [r4, #1158]	; 0x486
    return LORAMAC_STATUS_OK;
 8034aea:	e7de      	b.n	8034aaa <LoRaMacInitialization+0x2fe>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 8034aec:	2503      	movs	r5, #3
 8034aee:	e7dc      	b.n	8034aaa <LoRaMacInitialization+0x2fe>
        return LORAMAC_STATUS_REGION_NOT_SUPPORTED;
 8034af0:	2509      	movs	r5, #9
 8034af2:	e7da      	b.n	8034aaa <LoRaMacInitialization+0x2fe>
        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 8034af4:	2513      	movs	r5, #19
 8034af6:	e7d8      	b.n	8034aaa <LoRaMacInitialization+0x2fe>
 8034af8:	20004aa4 	.word	0x20004aa4
 8034afc:	01000300 	.word	0x01000300
 8034b00:	08033651 	.word	0x08033651
 8034b04:	080337f1 	.word	0x080337f1
 8034b08:	08033829 	.word	0x08033829
 8034b0c:	08032ff1 	.word	0x08032ff1
 8034b10:	080331e1 	.word	0x080331e1
 8034b14:	08033191 	.word	0x08033191
 8034b18:	08032f41 	.word	0x08032f41
 8034b1c:	0803bbc0 	.word	0x0803bbc0
 8034b20:	08033161 	.word	0x08033161
 8034b24:	08033131 	.word	0x08033131
 8034b28:	20005080 	.word	0x20005080

08034b2c <LoRaMacStart>:

LoRaMacStatus_t LoRaMacStart( void )
{
    MacCtx.MacState = LORAMAC_IDLE;
 8034b2c:	4b02      	ldr	r3, [pc, #8]	; (8034b38 <LoRaMacStart+0xc>)
 8034b2e:	2000      	movs	r0, #0
 8034b30:	f8c3 0344 	str.w	r0, [r3, #836]	; 0x344
    return LORAMAC_STATUS_OK;
}
 8034b34:	4770      	bx	lr
 8034b36:	bf00      	nop
 8034b38:	20004aa4 	.word	0x20004aa4

08034b3c <LoRaMacQueryTxPossible>:
    }
    return LORAMAC_STATUS_BUSY;
}

LoRaMacStatus_t LoRaMacQueryTxPossible( uint8_t size, LoRaMacTxInfo_t* txInfo )
{
 8034b3c:	b530      	push	{r4, r5, lr}
    CalcNextAdrParams_t adrNext;
    uint32_t adrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 8034b3e:	4b2a      	ldr	r3, [pc, #168]	; (8034be8 <LoRaMacQueryTxPossible+0xac>)
{
 8034b40:	b089      	sub	sp, #36	; 0x24
 8034b42:	4605      	mov	r5, r0
    int8_t datarate = Nvm.MacGroup2.ChannelsDatarateDefault;
 8034b44:	f893 05d1 	ldrb.w	r0, [r3, #1489]	; 0x5d1
 8034b48:	f88d 0002 	strb.w	r0, [sp, #2]
    int8_t txPower = Nvm.MacGroup2.ChannelsTxPowerDefault;
 8034b4c:	f893 05d0 	ldrb.w	r0, [r3, #1488]	; 0x5d0
    uint32_t adrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 8034b50:	f8d3 2534 	ldr.w	r2, [r3, #1332]	; 0x534
    int8_t txPower = Nvm.MacGroup2.ChannelsTxPowerDefault;
 8034b54:	f88d 0003 	strb.w	r0, [sp, #3]
    size_t macCmdsSize = 0;
 8034b58:	2000      	movs	r0, #0
    uint32_t adrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 8034b5a:	9201      	str	r2, [sp, #4]
    size_t macCmdsSize = 0;
 8034b5c:	9002      	str	r0, [sp, #8]

    if( txInfo == NULL )
 8034b5e:	460c      	mov	r4, r1
 8034b60:	2900      	cmp	r1, #0
 8034b62:	d03c      	beq.n	8034bde <LoRaMacQueryTxPossible+0xa2>

    // Setup ADR request
    adrNext.Version = Nvm.MacGroup2.Version;
    adrNext.UpdateChanMask = false;
    adrNext.AdrEnabled = Nvm.MacGroup2.AdrCtrlOn;
    adrNext.AdrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 8034b64:	9205      	str	r2, [sp, #20]
    adrNext.AdrAckLimit = MacCtx.AdrAckLimit;
 8034b66:	f8d3 23f8 	ldr.w	r2, [r3, #1016]	; 0x3f8
 8034b6a:	9206      	str	r2, [sp, #24]
    adrNext.AdrAckDelay = MacCtx.AdrAckDelay;
    adrNext.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 8034b6c:	f8b3 2544 	ldrh.w	r2, [r3, #1348]	; 0x544
    adrNext.Version = Nvm.MacGroup2.Version;
 8034b70:	f8d3 1618 	ldr.w	r1, [r3, #1560]	; 0x618
 8034b74:	9103      	str	r1, [sp, #12]
    adrNext.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 8034b76:	ba52      	rev16	r2, r2
    adrNext.AdrEnabled = Nvm.MacGroup2.AdrCtrlOn;
 8034b78:	f893 160a 	ldrb.w	r1, [r3, #1546]	; 0x60a
    adrNext.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 8034b7c:	f8ad 201c 	strh.w	r2, [sp, #28]
    adrNext.TxPower = Nvm.MacGroup1.ChannelsTxPower;
    adrNext.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8034b80:	f893 2580 	ldrb.w	r2, [r3, #1408]	; 0x580
    adrNext.Region = Nvm.MacGroup2.Region;
 8034b84:	f893 354c 	ldrb.w	r3, [r3, #1356]	; 0x54c
    adrNext.UpdateChanMask = false;
 8034b88:	f88d 0010 	strb.w	r0, [sp, #16]
    adrNext.AdrEnabled = Nvm.MacGroup2.AdrCtrlOn;
 8034b8c:	f88d 1011 	strb.w	r1, [sp, #17]
    adrNext.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8034b90:	f88d 201e 	strb.w	r2, [sp, #30]
    adrNext.Region = Nvm.MacGroup2.Region;
 8034b94:	f88d 301f 	strb.w	r3, [sp, #31]

    // We call the function for information purposes only. We don't want to
    // apply the datarate, the tx power and the ADR ack counter.
    LoRaMacAdrCalcNext( &adrNext, &datarate, &txPower, &adrAckCounter );
 8034b98:	f10d 0203 	add.w	r2, sp, #3
 8034b9c:	ab01      	add	r3, sp, #4
 8034b9e:	f10d 0102 	add.w	r1, sp, #2
 8034ba2:	a803      	add	r0, sp, #12
 8034ba4:	f000 fe54 	bl	8035850 <LoRaMacAdrCalcNext>

    txInfo->CurrentPossiblePayloadSize = GetMaxAppPayloadWithoutFOptsLength( datarate );
 8034ba8:	f99d 0002 	ldrsb.w	r0, [sp, #2]
 8034bac:	f7fe fa04 	bl	8032fb8 <GetMaxAppPayloadWithoutFOptsLength>
 8034bb0:	7060      	strb	r0, [r4, #1]

    if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )
 8034bb2:	a802      	add	r0, sp, #8
 8034bb4:	f000 ff8a 	bl	8035acc <LoRaMacCommandsGetSizeSerializedCmds>
 8034bb8:	b998      	cbnz	r0, 8034be2 <LoRaMacQueryTxPossible+0xa6>
    {
        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
    }

    // Verify if the MAC commands fit into the FOpts and into the maximum payload.
    if( ( LORA_MAC_COMMAND_MAX_FOPTS_LENGTH >= macCmdsSize ) && ( txInfo->CurrentPossiblePayloadSize >= macCmdsSize ) )
 8034bba:	9b02      	ldr	r3, [sp, #8]
 8034bbc:	2b0f      	cmp	r3, #15
 8034bbe:	d80a      	bhi.n	8034bd6 <LoRaMacQueryTxPossible+0x9a>
 8034bc0:	7862      	ldrb	r2, [r4, #1]
 8034bc2:	4293      	cmp	r3, r2
 8034bc4:	d807      	bhi.n	8034bd6 <LoRaMacQueryTxPossible+0x9a>
    {
        txInfo->MaxPossibleApplicationDataSize = txInfo->CurrentPossiblePayloadSize - macCmdsSize;
 8034bc6:	1ad1      	subs	r1, r2, r3

        // Verify if the application data together with MAC command fit into the maximum payload.
        if( txInfo->CurrentPossiblePayloadSize >= ( macCmdsSize + size ) )
 8034bc8:	441d      	add	r5, r3
        txInfo->MaxPossibleApplicationDataSize = txInfo->CurrentPossiblePayloadSize - macCmdsSize;
 8034bca:	7021      	strb	r1, [r4, #0]
        {
            return LORAMAC_STATUS_OK;
        }
        else
        {
           return LORAMAC_STATUS_LENGTH_ERROR;
 8034bcc:	42aa      	cmp	r2, r5
 8034bce:	bf38      	it	cc
 8034bd0:	2008      	movcc	r0, #8
    else
    {
        txInfo->MaxPossibleApplicationDataSize = 0;
        return LORAMAC_STATUS_LENGTH_ERROR;
    }
}
 8034bd2:	b009      	add	sp, #36	; 0x24
 8034bd4:	bd30      	pop	{r4, r5, pc}
        txInfo->MaxPossibleApplicationDataSize = 0;
 8034bd6:	2300      	movs	r3, #0
 8034bd8:	7023      	strb	r3, [r4, #0]
        return LORAMAC_STATUS_LENGTH_ERROR;
 8034bda:	2008      	movs	r0, #8
 8034bdc:	e7f9      	b.n	8034bd2 <LoRaMacQueryTxPossible+0x96>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 8034bde:	2003      	movs	r0, #3
 8034be0:	e7f7      	b.n	8034bd2 <LoRaMacQueryTxPossible+0x96>
        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 8034be2:	2013      	movs	r0, #19
 8034be4:	e7f5      	b.n	8034bd2 <LoRaMacQueryTxPossible+0x96>
 8034be6:	bf00      	nop
 8034be8:	20004aa4 	.word	0x20004aa4

08034bec <LoRaMacMibGetRequestConfirm>:

LoRaMacStatus_t LoRaMacMibGetRequestConfirm( MibRequestConfirm_t* mibGet )
{
 8034bec:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;

    if( mibGet == NULL )
 8034bee:	4604      	mov	r4, r0
 8034bf0:	2800      	cmp	r0, #0
 8034bf2:	f000 80a8 	beq.w	8034d46 <LoRaMacMibGetRequestConfirm+0x15a>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }

    switch( mibGet->Type )
 8034bf6:	7800      	ldrb	r0, [r0, #0]
 8034bf8:	2828      	cmp	r0, #40	; 0x28
 8034bfa:	f200 80a0 	bhi.w	8034d3e <LoRaMacMibGetRequestConfirm+0x152>
 8034bfe:	e8df f000 	tbb	[pc, r0]
 8034c02:	1b15      	.short	0x1b15
 8034c04:	2c282520 	.word	0x2c282520
 8034c08:	9e9e9e31 	.word	0x9e9e9e31
 8034c0c:	9e9e9e9e 	.word	0x9e9e9e9e
 8034c10:	3d39359e 	.word	0x3d39359e
 8034c14:	54514e47 	.word	0x54514e47
 8034c18:	5f5b5759 	.word	0x5f5b5759
 8034c1c:	6f6b6763 	.word	0x6f6b6763
 8034c20:	7b7f7773 	.word	0x7b7f7773
 8034c24:	928b8783 	.word	0x928b8783
 8034c28:	9e90      	.short	0x9e90
 8034c2a:	96          	.byte	0x96
 8034c2b:	00          	.byte	0x00
    {
        case MIB_DEVICE_CLASS:
        {
            mibGet->Param.Class = Nvm.MacGroup2.DeviceClass;
 8034c2c:	4b47      	ldr	r3, [pc, #284]	; (8034d4c <LoRaMacMibGetRequestConfirm+0x160>)
 8034c2e:	f893 3608 	ldrb.w	r3, [r3, #1544]	; 0x608
 8034c32:	7123      	strb	r3, [r4, #4]
            status = LoRaMacClassBMibGetRequestConfirm( mibGet );
            break;
        }
    }
    return status;
}
 8034c34:	b004      	add	sp, #16
 8034c36:	bd10      	pop	{r4, pc}
            mibGet->Param.NetworkActivation = Nvm.MacGroup2.NetworkActivation;
 8034c38:	4b44      	ldr	r3, [pc, #272]	; (8034d4c <LoRaMacMibGetRequestConfirm+0x160>)
 8034c3a:	f893 361c 	ldrb.w	r3, [r3, #1564]	; 0x61c
            mibGet->Param.AdrEnable = Nvm.MacGroup2.AdrCtrlOn;
 8034c3e:	7123      	strb	r3, [r4, #4]
            break;
 8034c40:	e002      	b.n	8034c48 <LoRaMacMibGetRequestConfirm+0x5c>
            mibGet->Param.DevEui = SecureElementGetDevEui( );
 8034c42:	f004 f8ff 	bl	8038e44 <SecureElementGetDevEui>
            mibGet->Param.JoinEui = SecureElementGetJoinEui( );
 8034c46:	6060      	str	r0, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 8034c48:	2000      	movs	r0, #0
            break;
 8034c4a:	e7f3      	b.n	8034c34 <LoRaMacMibGetRequestConfirm+0x48>
            mibGet->Param.JoinEui = SecureElementGetJoinEui( );
 8034c4c:	f004 f910 	bl	8038e70 <SecureElementGetJoinEui>
 8034c50:	e7f9      	b.n	8034c46 <LoRaMacMibGetRequestConfirm+0x5a>
            mibGet->Param.AdrEnable = Nvm.MacGroup2.AdrCtrlOn;
 8034c52:	4b3e      	ldr	r3, [pc, #248]	; (8034d4c <LoRaMacMibGetRequestConfirm+0x160>)
 8034c54:	f893 360a 	ldrb.w	r3, [r3, #1546]	; 0x60a
 8034c58:	e7f1      	b.n	8034c3e <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.NetID = Nvm.MacGroup2.NetID;
 8034c5a:	4b3c      	ldr	r3, [pc, #240]	; (8034d4c <LoRaMacMibGetRequestConfirm+0x160>)
 8034c5c:	f8d3 35d4 	ldr.w	r3, [r3, #1492]	; 0x5d4
            mibGet->Param.Contexts = GetNvmData( );
 8034c60:	6063      	str	r3, [r4, #4]
            break;
 8034c62:	e7f1      	b.n	8034c48 <LoRaMacMibGetRequestConfirm+0x5c>
            mibGet->Param.DevAddr = Nvm.MacGroup2.DevAddr;
 8034c64:	4b39      	ldr	r3, [pc, #228]	; (8034d4c <LoRaMacMibGetRequestConfirm+0x160>)
 8034c66:	f8d3 35d8 	ldr.w	r3, [r3, #1496]	; 0x5d8
 8034c6a:	e7f9      	b.n	8034c60 <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.EnablePublicNetwork = Nvm.MacGroup2.PublicNetwork;
 8034c6c:	4b37      	ldr	r3, [pc, #220]	; (8034d4c <LoRaMacMibGetRequestConfirm+0x160>)
 8034c6e:	f893 3609 	ldrb.w	r3, [r3, #1545]	; 0x609
 8034c72:	e7e4      	b.n	8034c3e <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.EnableRepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport;
 8034c74:	4b35      	ldr	r3, [pc, #212]	; (8034d4c <LoRaMacMibGetRequestConfirm+0x160>)
 8034c76:	f893 358c 	ldrb.w	r3, [r3, #1420]	; 0x58c
 8034c7a:	e7e0      	b.n	8034c3e <LoRaMacMibGetRequestConfirm+0x52>
            getPhy.Attribute = PHY_CHANNELS;
 8034c7c:	231d      	movs	r3, #29
            getPhy.Attribute = PHY_CHANNELS_MASK;
 8034c7e:	f88d 3008 	strb.w	r3, [sp, #8]
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034c82:	4b32      	ldr	r3, [pc, #200]	; (8034d4c <LoRaMacMibGetRequestConfirm+0x160>)
 8034c84:	a902      	add	r1, sp, #8
 8034c86:	f893 054c 	ldrb.w	r0, [r3, #1356]	; 0x54c
 8034c8a:	f001 fd12 	bl	80366b2 <RegionGetPhyParam>
 8034c8e:	e7da      	b.n	8034c46 <LoRaMacMibGetRequestConfirm+0x5a>
            mibGet->Param.Rx2Channel = Nvm.MacGroup2.MacParams.Rx2Channel;
 8034c90:	4b2f      	ldr	r3, [pc, #188]	; (8034d50 <LoRaMacMibGetRequestConfirm+0x164>)
 8034c92:	3404      	adds	r4, #4
            mibGet->Param.RxCChannel = Nvm.MacGroup2.MacParamsDefaults.RxCChannel;
 8034c94:	e893 0003 	ldmia.w	r3, {r0, r1}
 8034c98:	e884 0003 	stmia.w	r4, {r0, r1}
            break;
 8034c9c:	e7d4      	b.n	8034c48 <LoRaMacMibGetRequestConfirm+0x5c>
            mibGet->Param.Rx2Channel = Nvm.MacGroup2.MacParamsDefaults.Rx2Channel;
 8034c9e:	4b2d      	ldr	r3, [pc, #180]	; (8034d54 <LoRaMacMibGetRequestConfirm+0x168>)
 8034ca0:	3404      	adds	r4, #4
 8034ca2:	e7f7      	b.n	8034c94 <LoRaMacMibGetRequestConfirm+0xa8>
            mibGet->Param.RxCChannel = Nvm.MacGroup2.MacParams.RxCChannel;
 8034ca4:	4b2c      	ldr	r3, [pc, #176]	; (8034d58 <LoRaMacMibGetRequestConfirm+0x16c>)
 8034ca6:	3404      	adds	r4, #4
 8034ca8:	e7f4      	b.n	8034c94 <LoRaMacMibGetRequestConfirm+0xa8>
            mibGet->Param.RxCChannel = Nvm.MacGroup2.MacParamsDefaults.RxCChannel;
 8034caa:	4b2c      	ldr	r3, [pc, #176]	; (8034d5c <LoRaMacMibGetRequestConfirm+0x170>)
 8034cac:	3404      	adds	r4, #4
 8034cae:	e7f1      	b.n	8034c94 <LoRaMacMibGetRequestConfirm+0xa8>
            getPhy.Attribute = PHY_CHANNELS_DEFAULT_MASK;
 8034cb0:	231b      	movs	r3, #27
 8034cb2:	e7e4      	b.n	8034c7e <LoRaMacMibGetRequestConfirm+0x92>
            getPhy.Attribute = PHY_CHANNELS_MASK;
 8034cb4:	231a      	movs	r3, #26
 8034cb6:	e7e2      	b.n	8034c7e <LoRaMacMibGetRequestConfirm+0x92>
            mibGet->Param.ChannelsNbTrans = Nvm.MacGroup2.MacParams.ChannelsNbTrans;
 8034cb8:	4b24      	ldr	r3, [pc, #144]	; (8034d4c <LoRaMacMibGetRequestConfirm+0x160>)
 8034cba:	f893 356c 	ldrb.w	r3, [r3, #1388]	; 0x56c
 8034cbe:	e7be      	b.n	8034c3e <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.MaxRxWindow = Nvm.MacGroup2.MacParams.MaxRxWindow;
 8034cc0:	4b22      	ldr	r3, [pc, #136]	; (8034d4c <LoRaMacMibGetRequestConfirm+0x160>)
 8034cc2:	f8d3 3558 	ldr.w	r3, [r3, #1368]	; 0x558
 8034cc6:	e7cb      	b.n	8034c60 <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.ReceiveDelay1 = Nvm.MacGroup2.MacParams.ReceiveDelay1;
 8034cc8:	4b20      	ldr	r3, [pc, #128]	; (8034d4c <LoRaMacMibGetRequestConfirm+0x160>)
 8034cca:	f8d3 355c 	ldr.w	r3, [r3, #1372]	; 0x55c
 8034cce:	e7c7      	b.n	8034c60 <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay2;
 8034cd0:	4b1e      	ldr	r3, [pc, #120]	; (8034d4c <LoRaMacMibGetRequestConfirm+0x160>)
 8034cd2:	f8d3 3560 	ldr.w	r3, [r3, #1376]	; 0x560
 8034cd6:	e7c3      	b.n	8034c60 <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.JoinAcceptDelay1 = Nvm.MacGroup2.MacParams.JoinAcceptDelay1;
 8034cd8:	4b1c      	ldr	r3, [pc, #112]	; (8034d4c <LoRaMacMibGetRequestConfirm+0x160>)
 8034cda:	f8d3 3564 	ldr.w	r3, [r3, #1380]	; 0x564
 8034cde:	e7bf      	b.n	8034c60 <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.JoinAcceptDelay2 = Nvm.MacGroup2.MacParams.JoinAcceptDelay2;
 8034ce0:	4b1a      	ldr	r3, [pc, #104]	; (8034d4c <LoRaMacMibGetRequestConfirm+0x160>)
 8034ce2:	f8d3 3568 	ldr.w	r3, [r3, #1384]	; 0x568
 8034ce6:	e7bb      	b.n	8034c60 <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.ChannelsDefaultDatarate = Nvm.MacGroup2.ChannelsDatarateDefault;
 8034ce8:	4b18      	ldr	r3, [pc, #96]	; (8034d4c <LoRaMacMibGetRequestConfirm+0x160>)
 8034cea:	f893 35d1 	ldrb.w	r3, [r3, #1489]	; 0x5d1
 8034cee:	e7a6      	b.n	8034c3e <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.ChannelsDatarate = Nvm.MacGroup1.ChannelsDatarate;
 8034cf0:	4b16      	ldr	r3, [pc, #88]	; (8034d4c <LoRaMacMibGetRequestConfirm+0x160>)
 8034cf2:	f893 3545 	ldrb.w	r3, [r3, #1349]	; 0x545
 8034cf6:	e7a2      	b.n	8034c3e <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.ChannelsDefaultTxPower = Nvm.MacGroup2.ChannelsTxPowerDefault;
 8034cf8:	4b14      	ldr	r3, [pc, #80]	; (8034d4c <LoRaMacMibGetRequestConfirm+0x160>)
 8034cfa:	f893 35d0 	ldrb.w	r3, [r3, #1488]	; 0x5d0
 8034cfe:	e79e      	b.n	8034c3e <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.ChannelsTxPower = Nvm.MacGroup1.ChannelsTxPower;
 8034d00:	4b12      	ldr	r3, [pc, #72]	; (8034d4c <LoRaMacMibGetRequestConfirm+0x160>)
 8034d02:	f893 3544 	ldrb.w	r3, [r3, #1348]	; 0x544
 8034d06:	e79a      	b.n	8034c3e <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.SystemMaxRxError = Nvm.MacGroup2.MacParams.SystemMaxRxError;
 8034d08:	4b10      	ldr	r3, [pc, #64]	; (8034d4c <LoRaMacMibGetRequestConfirm+0x160>)
 8034d0a:	f8d3 3550 	ldr.w	r3, [r3, #1360]	; 0x550
 8034d0e:	e7a7      	b.n	8034c60 <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.MinRxSymbols = Nvm.MacGroup2.MacParams.MinRxSymbols;
 8034d10:	4b0e      	ldr	r3, [pc, #56]	; (8034d4c <LoRaMacMibGetRequestConfirm+0x160>)
 8034d12:	f893 3554 	ldrb.w	r3, [r3, #1364]	; 0x554
 8034d16:	e792      	b.n	8034c3e <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.AntennaGain = Nvm.MacGroup2.MacParams.AntennaGain;
 8034d18:	4b0c      	ldr	r3, [pc, #48]	; (8034d4c <LoRaMacMibGetRequestConfirm+0x160>)
 8034d1a:	f8d3 3588 	ldr.w	r3, [r3, #1416]	; 0x588
            mibGet->Param.DefaultAntennaGain = Nvm.MacGroup2.MacParamsDefaults.AntennaGain;
 8034d1e:	6063      	str	r3, [r4, #4]
            break;
 8034d20:	e792      	b.n	8034c48 <LoRaMacMibGetRequestConfirm+0x5c>
            mibGet->Param.Contexts = GetNvmData( );
 8034d22:	4b0f      	ldr	r3, [pc, #60]	; (8034d60 <LoRaMacMibGetRequestConfirm+0x174>)
 8034d24:	e79c      	b.n	8034c60 <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.DefaultAntennaGain = Nvm.MacGroup2.MacParamsDefaults.AntennaGain;
 8034d26:	4b09      	ldr	r3, [pc, #36]	; (8034d4c <LoRaMacMibGetRequestConfirm+0x160>)
 8034d28:	f8d3 35c8 	ldr.w	r3, [r3, #1480]	; 0x5c8
 8034d2c:	e7f7      	b.n	8034d1e <LoRaMacMibGetRequestConfirm+0x132>
            mibGet->Param.LrWanVersion.LoRaWan = Nvm.MacGroup2.Version;
 8034d2e:	4b07      	ldr	r3, [pc, #28]	; (8034d4c <LoRaMacMibGetRequestConfirm+0x160>)
 8034d30:	f8d3 3618 	ldr.w	r3, [r3, #1560]	; 0x618
 8034d34:	6063      	str	r3, [r4, #4]
            mibGet->Param.LrWanVersion.LoRaWanRegion = RegionGetVersion( );
 8034d36:	f001 fdbb 	bl	80368b0 <RegionGetVersion>
 8034d3a:	60a0      	str	r0, [r4, #8]
 8034d3c:	e784      	b.n	8034c48 <LoRaMacMibGetRequestConfirm+0x5c>
            status = LoRaMacClassBMibGetRequestConfirm( mibGet );
 8034d3e:	4620      	mov	r0, r4
 8034d40:	f000 fe0c 	bl	803595c <LoRaMacClassBMibGetRequestConfirm>
            break;
 8034d44:	e776      	b.n	8034c34 <LoRaMacMibGetRequestConfirm+0x48>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 8034d46:	2003      	movs	r0, #3
 8034d48:	e774      	b.n	8034c34 <LoRaMacMibGetRequestConfirm+0x48>
 8034d4a:	bf00      	nop
 8034d4c:	20004aa4 	.word	0x20004aa4
 8034d50:	20005014 	.word	0x20005014
 8034d54:	20005054 	.word	0x20005054
 8034d58:	2000501c 	.word	0x2000501c
 8034d5c:	2000505c 	.word	0x2000505c
 8034d60:	20004fb0 	.word	0x20004fb0

08034d64 <LoRaMacMibSetRequestConfirm>:

LoRaMacStatus_t LoRaMacMibSetRequestConfirm( MibRequestConfirm_t* mibSet )
{
 8034d64:	b573      	push	{r0, r1, r4, r5, r6, lr}
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
    ChanMaskSetParams_t chanMaskSet;
    VerifyParams_t verify;

    if( mibSet == NULL )
 8034d66:	4604      	mov	r4, r0
 8034d68:	2800      	cmp	r0, #0
 8034d6a:	d044      	beq.n	8034df6 <LoRaMacMibSetRequestConfirm+0x92>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }
    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 8034d6c:	4da5      	ldr	r5, [pc, #660]	; (8035004 <LoRaMacMibSetRequestConfirm+0x2a0>)
 8034d6e:	f8d5 3344 	ldr.w	r3, [r5, #836]	; 0x344
 8034d72:	079a      	lsls	r2, r3, #30
 8034d74:	f100 8206 	bmi.w	8035184 <LoRaMacMibSetRequestConfirm+0x420>
    {
        return LORAMAC_STATUS_BUSY;
    }

    switch( mibSet->Type )
 8034d78:	7802      	ldrb	r2, [r0, #0]
 8034d7a:	2a27      	cmp	r2, #39	; 0x27
 8034d7c:	f200 81ff 	bhi.w	803517e <LoRaMacMibSetRequestConfirm+0x41a>
 8034d80:	e8df f012 	tbh	[pc, r2, lsl #1]
 8034d84:	002d0028 	.word	0x002d0028
 8034d88:	003b0034 	.word	0x003b0034
 8034d8c:	0043003f 	.word	0x0043003f
 8034d90:	004b0047 	.word	0x004b0047
 8034d94:	005a0055 	.word	0x005a0055
 8034d98:	0064005f 	.word	0x0064005f
 8034d9c:	006e0069 	.word	0x006e0069
 8034da0:	00780073 	.word	0x00780073
 8034da4:	01fd0081 	.word	0x01fd0081
 8034da8:	00a40085 	.word	0x00a40085
 8034dac:	00da00b5 	.word	0x00da00b5
 8034db0:	00ec00fa 	.word	0x00ec00fa
 8034db4:	010600fe 	.word	0x010600fe
 8034db8:	010e010a 	.word	0x010e010a
 8034dbc:	01160112 	.word	0x01160112
 8034dc0:	012b011a 	.word	0x012b011a
 8034dc4:	014c015d 	.word	0x014c015d
 8034dc8:	0174016e 	.word	0x0174016e
 8034dcc:	017e017a 	.word	0x017e017a
 8034dd0:	01f20182 	.word	0x01f20182
    {
        case MIB_DEVICE_CLASS:
        {
            status = SwitchClass( mibSet->Param.Class );
 8034dd4:	7900      	ldrb	r0, [r0, #4]
 8034dd6:	f7fe fc8b 	bl	80336f0 <SwitchClass>
            status = LoRaMacMibClassBSetRequestConfirm( mibSet );
            break;
        }
    }
    return status;
}
 8034dda:	b002      	add	sp, #8
 8034ddc:	bd70      	pop	{r4, r5, r6, pc}
            if( mibSet->Param.NetworkActivation != ACTIVATION_TYPE_OTAA  )
 8034dde:	7903      	ldrb	r3, [r0, #4]
 8034de0:	2b02      	cmp	r3, #2
 8034de2:	d008      	beq.n	8034df6 <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup2.NetworkActivation = mibSet->Param.NetworkActivation;
 8034de4:	f885 361c 	strb.w	r3, [r5, #1564]	; 0x61c
    return LORAMAC_STATUS_OK;
 8034de8:	2000      	movs	r0, #0
 8034dea:	e7f6      	b.n	8034dda <LoRaMacMibSetRequestConfirm+0x76>
            if( SecureElementSetDevEui( mibSet->Param.DevEui ) != SECURE_ELEMENT_SUCCESS )
 8034dec:	6840      	ldr	r0, [r0, #4]
 8034dee:	f004 f81b 	bl	8038e28 <SecureElementSetDevEui>
 8034df2:	2800      	cmp	r0, #0
 8034df4:	d0f8      	beq.n	8034de8 <LoRaMacMibSetRequestConfirm+0x84>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 8034df6:	2003      	movs	r0, #3
 8034df8:	e7ef      	b.n	8034dda <LoRaMacMibSetRequestConfirm+0x76>
            if( SecureElementSetJoinEui( mibSet->Param.JoinEui ) != SECURE_ELEMENT_SUCCESS )
 8034dfa:	6840      	ldr	r0, [r0, #4]
 8034dfc:	f004 f828 	bl	8038e50 <SecureElementSetJoinEui>
 8034e00:	e7f7      	b.n	8034df2 <LoRaMacMibSetRequestConfirm+0x8e>
            Nvm.MacGroup2.AdrCtrlOn = mibSet->Param.AdrEnable;
 8034e02:	7903      	ldrb	r3, [r0, #4]
 8034e04:	f885 360a 	strb.w	r3, [r5, #1546]	; 0x60a
            break;
 8034e08:	e7ee      	b.n	8034de8 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.NetID = mibSet->Param.NetID;
 8034e0a:	6843      	ldr	r3, [r0, #4]
 8034e0c:	f8c5 35d4 	str.w	r3, [r5, #1492]	; 0x5d4
            break;
 8034e10:	e7ea      	b.n	8034de8 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.DevAddr = mibSet->Param.DevAddr;
 8034e12:	6843      	ldr	r3, [r0, #4]
 8034e14:	f8c5 35d8 	str.w	r3, [r5, #1496]	; 0x5d8
            break;
 8034e18:	e7e6      	b.n	8034de8 <LoRaMacMibSetRequestConfirm+0x84>
            if( mibSet->Param.AppKey != NULL )
 8034e1a:	6841      	ldr	r1, [r0, #4]
 8034e1c:	2900      	cmp	r1, #0
 8034e1e:	d0ea      	beq.n	8034df6 <LoRaMacMibSetRequestConfirm+0x92>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( APP_KEY, mibSet->Param.AppKey ) )
 8034e20:	2000      	movs	r0, #0
 8034e22:	f001 fa1f 	bl	8036264 <LoRaMacCryptoSetKey>
 8034e26:	2800      	cmp	r0, #0
 8034e28:	d0de      	beq.n	8034de8 <LoRaMacMibSetRequestConfirm+0x84>
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 8034e2a:	2011      	movs	r0, #17
 8034e2c:	e7d5      	b.n	8034dda <LoRaMacMibSetRequestConfirm+0x76>
            if( mibSet->Param.NwkKey != NULL )
 8034e2e:	6841      	ldr	r1, [r0, #4]
 8034e30:	2900      	cmp	r1, #0
 8034e32:	d0e0      	beq.n	8034df6 <LoRaMacMibSetRequestConfirm+0x92>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( NWK_KEY, mibSet->Param.NwkKey ) )
 8034e34:	2001      	movs	r0, #1
 8034e36:	e7f4      	b.n	8034e22 <LoRaMacMibSetRequestConfirm+0xbe>
            if( mibSet->Param.NwkSKey != NULL )
 8034e38:	6841      	ldr	r1, [r0, #4]
 8034e3a:	2900      	cmp	r1, #0
 8034e3c:	d0db      	beq.n	8034df6 <LoRaMacMibSetRequestConfirm+0x92>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( NWK_S_KEY, mibSet->Param.NwkSKey ) )
 8034e3e:	2002      	movs	r0, #2
 8034e40:	e7ef      	b.n	8034e22 <LoRaMacMibSetRequestConfirm+0xbe>
            if( mibSet->Param.AppSKey != NULL )
 8034e42:	6841      	ldr	r1, [r0, #4]
 8034e44:	2900      	cmp	r1, #0
 8034e46:	d0d6      	beq.n	8034df6 <LoRaMacMibSetRequestConfirm+0x92>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( APP_S_KEY, mibSet->Param.AppSKey ) )
 8034e48:	2003      	movs	r0, #3
 8034e4a:	e7ea      	b.n	8034e22 <LoRaMacMibSetRequestConfirm+0xbe>
            if( mibSet->Param.McKEKey != NULL )
 8034e4c:	6841      	ldr	r1, [r0, #4]
 8034e4e:	2900      	cmp	r1, #0
 8034e50:	d0d1      	beq.n	8034df6 <LoRaMacMibSetRequestConfirm+0x92>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KE_KEY, mibSet->Param.McKEKey ) )
 8034e52:	207f      	movs	r0, #127	; 0x7f
 8034e54:	e7e5      	b.n	8034e22 <LoRaMacMibSetRequestConfirm+0xbe>
            if( mibSet->Param.McKey0 != NULL )
 8034e56:	6841      	ldr	r1, [r0, #4]
 8034e58:	2900      	cmp	r1, #0
 8034e5a:	d0cc      	beq.n	8034df6 <LoRaMacMibSetRequestConfirm+0x92>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KEY_0, mibSet->Param.McKey0 ) )
 8034e5c:	2080      	movs	r0, #128	; 0x80
 8034e5e:	e7e0      	b.n	8034e22 <LoRaMacMibSetRequestConfirm+0xbe>
            if( mibSet->Param.McAppSKey0 != NULL )
 8034e60:	6841      	ldr	r1, [r0, #4]
 8034e62:	2900      	cmp	r1, #0
 8034e64:	d0c7      	beq.n	8034df6 <LoRaMacMibSetRequestConfirm+0x92>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_APP_S_KEY_0, mibSet->Param.McAppSKey0 ) )
 8034e66:	2081      	movs	r0, #129	; 0x81
 8034e68:	e7db      	b.n	8034e22 <LoRaMacMibSetRequestConfirm+0xbe>
            if( mibSet->Param.McNwkSKey0 != NULL )
 8034e6a:	6841      	ldr	r1, [r0, #4]
 8034e6c:	2900      	cmp	r1, #0
 8034e6e:	d0c2      	beq.n	8034df6 <LoRaMacMibSetRequestConfirm+0x92>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_NWK_S_KEY_0, mibSet->Param.McNwkSKey0 ) )
 8034e70:	2082      	movs	r0, #130	; 0x82
 8034e72:	e7d6      	b.n	8034e22 <LoRaMacMibSetRequestConfirm+0xbe>
            Radio.SetPublicNetwork( Nvm.MacGroup2.PublicNetwork );
 8034e74:	4c64      	ldr	r4, [pc, #400]	; (8035008 <LoRaMacMibSetRequestConfirm+0x2a4>)
            Nvm.MacGroup2.PublicNetwork = mibSet->Param.EnablePublicNetwork;
 8034e76:	7900      	ldrb	r0, [r0, #4]
            Radio.SetPublicNetwork( Nvm.MacGroup2.PublicNetwork );
 8034e78:	6da3      	ldr	r3, [r4, #88]	; 0x58
            Nvm.MacGroup2.PublicNetwork = mibSet->Param.EnablePublicNetwork;
 8034e7a:	f885 0609 	strb.w	r0, [r5, #1545]	; 0x609
            Radio.SetPublicNetwork( Nvm.MacGroup2.PublicNetwork );
 8034e7e:	4798      	blx	r3
            Radio.Sleep( );
 8034e80:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8034e82:	4798      	blx	r3
            break;
 8034e84:	e7b0      	b.n	8034de8 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.RepeaterSupport = mibSet->Param.EnableRepeaterSupport;
 8034e86:	7903      	ldrb	r3, [r0, #4]
 8034e88:	f885 358c 	strb.w	r3, [r5, #1420]	; 0x58c
            break;
 8034e8c:	e7ac      	b.n	8034de8 <LoRaMacMibSetRequestConfirm+0x84>
            verify.DatarateParams.Datarate = mibSet->Param.Rx2Channel.Datarate;
 8034e8e:	7a03      	ldrb	r3, [r0, #8]
 8034e90:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) != true )
 8034e94:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 8034e98:	f895 3581 	ldrb.w	r3, [r5, #1409]	; 0x581
 8034e9c:	f88d 3001 	strb.w	r3, [sp, #1]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) != true )
 8034ea0:	2207      	movs	r2, #7
 8034ea2:	4669      	mov	r1, sp
 8034ea4:	f001 fc2b 	bl	80366fe <RegionVerify>
 8034ea8:	2800      	cmp	r0, #0
 8034eaa:	d0a4      	beq.n	8034df6 <LoRaMacMibSetRequestConfirm+0x92>
                verify.Frequency = mibSet->Param.Rx2Channel.Frequency;
 8034eac:	6863      	ldr	r3, [r4, #4]
                if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_FREQUENCY ) != true )
 8034eae:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
                verify.Frequency = mibSet->Param.Rx2Channel.Frequency;
 8034eb2:	9300      	str	r3, [sp, #0]
                if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_FREQUENCY ) != true )
 8034eb4:	2200      	movs	r2, #0
 8034eb6:	4669      	mov	r1, sp
 8034eb8:	f001 fc21 	bl	80366fe <RegionVerify>
 8034ebc:	2800      	cmp	r0, #0
 8034ebe:	d09a      	beq.n	8034df6 <LoRaMacMibSetRequestConfirm+0x92>
                    Nvm.MacGroup2.MacParams.Rx2Channel = mibSet->Param.Rx2Channel;
 8034ec0:	4b52      	ldr	r3, [pc, #328]	; (803500c <LoRaMacMibSetRequestConfirm+0x2a8>)
                Nvm.MacGroup2.MacParamsDefaults.Rx2Channel = mibSet->Param.Rx2DefaultChannel;
 8034ec2:	e9d4 0101 	ldrd	r0, r1, [r4, #4]
 8034ec6:	e883 0003 	stmia.w	r3, {r0, r1}
 8034eca:	e78d      	b.n	8034de8 <LoRaMacMibSetRequestConfirm+0x84>
            verify.DatarateParams.Datarate = mibSet->Param.Rx2Channel.Datarate;
 8034ecc:	7a03      	ldrb	r3, [r0, #8]
 8034ece:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 8034ed2:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 8034ed6:	f895 3581 	ldrb.w	r3, [r5, #1409]	; 0x581
 8034eda:	f88d 3001 	strb.w	r3, [sp, #1]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 8034ede:	2207      	movs	r2, #7
 8034ee0:	4669      	mov	r1, sp
 8034ee2:	f001 fc0c 	bl	80366fe <RegionVerify>
 8034ee6:	2800      	cmp	r0, #0
 8034ee8:	d085      	beq.n	8034df6 <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup2.MacParamsDefaults.Rx2Channel = mibSet->Param.Rx2DefaultChannel;
 8034eea:	4b49      	ldr	r3, [pc, #292]	; (8035010 <LoRaMacMibSetRequestConfirm+0x2ac>)
 8034eec:	e7e9      	b.n	8034ec2 <LoRaMacMibSetRequestConfirm+0x15e>
            verify.DatarateParams.Datarate = mibSet->Param.RxCChannel.Datarate;
 8034eee:	7a03      	ldrb	r3, [r0, #8]
 8034ef0:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 8034ef4:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 8034ef8:	f895 3581 	ldrb.w	r3, [r5, #1409]	; 0x581
 8034efc:	f88d 3001 	strb.w	r3, [sp, #1]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 8034f00:	2207      	movs	r2, #7
 8034f02:	4669      	mov	r1, sp
 8034f04:	f001 fbfb 	bl	80366fe <RegionVerify>
 8034f08:	2800      	cmp	r0, #0
 8034f0a:	f43f af74 	beq.w	8034df6 <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup2.MacParams.RxCChannel = mibSet->Param.RxCChannel;
 8034f0e:	e9d4 0101 	ldrd	r0, r1, [r4, #4]
 8034f12:	4b40      	ldr	r3, [pc, #256]	; (8035014 <LoRaMacMibSetRequestConfirm+0x2b0>)
 8034f14:	e883 0003 	stmia.w	r3, {r0, r1}
                if( ( Nvm.MacGroup2.DeviceClass == CLASS_C ) && ( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE ) )
 8034f18:	f895 3608 	ldrb.w	r3, [r5, #1544]	; 0x608
 8034f1c:	2b02      	cmp	r3, #2
 8034f1e:	f47f af63 	bne.w	8034de8 <LoRaMacMibSetRequestConfirm+0x84>
 8034f22:	f895 361c 	ldrb.w	r3, [r5, #1564]	; 0x61c
 8034f26:	2b00      	cmp	r3, #0
 8034f28:	f43f af5e 	beq.w	8034de8 <LoRaMacMibSetRequestConfirm+0x84>
                    Radio.Sleep( );
 8034f2c:	4b36      	ldr	r3, [pc, #216]	; (8035008 <LoRaMacMibSetRequestConfirm+0x2a4>)
 8034f2e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8034f30:	4798      	blx	r3
                    OpenContinuousRxCWindow( );
 8034f32:	f7fe fbb3 	bl	803369c <OpenContinuousRxCWindow>
 8034f36:	e757      	b.n	8034de8 <LoRaMacMibSetRequestConfirm+0x84>
            verify.DatarateParams.Datarate = mibSet->Param.RxCChannel.Datarate;
 8034f38:	7a03      	ldrb	r3, [r0, #8]
 8034f3a:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 8034f3e:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 8034f42:	f895 3581 	ldrb.w	r3, [r5, #1409]	; 0x581
 8034f46:	f88d 3001 	strb.w	r3, [sp, #1]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 8034f4a:	2207      	movs	r2, #7
 8034f4c:	4669      	mov	r1, sp
 8034f4e:	f001 fbd6 	bl	80366fe <RegionVerify>
 8034f52:	2800      	cmp	r0, #0
 8034f54:	f43f af4f 	beq.w	8034df6 <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup2.MacParamsDefaults.RxCChannel = mibSet->Param.RxCDefaultChannel;
 8034f58:	4b2f      	ldr	r3, [pc, #188]	; (8035018 <LoRaMacMibSetRequestConfirm+0x2b4>)
 8034f5a:	e7b2      	b.n	8034ec2 <LoRaMacMibSetRequestConfirm+0x15e>
            chanMaskSet.ChannelsMaskIn = mibSet->Param.ChannelsDefaultMask;
 8034f5c:	6843      	ldr	r3, [r0, #4]
 8034f5e:	9300      	str	r3, [sp, #0]
            chanMaskSet.ChannelsMaskType = CHANNELS_DEFAULT_MASK;
 8034f60:	2301      	movs	r3, #1
            if( RegionChanMaskSet( Nvm.MacGroup2.Region, &chanMaskSet ) == false )
 8034f62:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            chanMaskSet.ChannelsMaskType = CHANNELS_MASK;
 8034f66:	f88d 3004 	strb.w	r3, [sp, #4]
            if( RegionChanMaskSet( Nvm.MacGroup2.Region, &chanMaskSet ) == false )
 8034f6a:	4669      	mov	r1, sp
 8034f6c:	f001 fbdf 	bl	803672e <RegionChanMaskSet>
 8034f70:	2800      	cmp	r0, #0
 8034f72:	f47f af39 	bne.w	8034de8 <LoRaMacMibSetRequestConfirm+0x84>
 8034f76:	e73e      	b.n	8034df6 <LoRaMacMibSetRequestConfirm+0x92>
            chanMaskSet.ChannelsMaskIn = mibSet->Param.ChannelsMask;
 8034f78:	6843      	ldr	r3, [r0, #4]
 8034f7a:	9300      	str	r3, [sp, #0]
            chanMaskSet.ChannelsMaskType = CHANNELS_MASK;
 8034f7c:	2300      	movs	r3, #0
 8034f7e:	e7f0      	b.n	8034f62 <LoRaMacMibSetRequestConfirm+0x1fe>
            if( ( mibSet->Param.ChannelsNbTrans >= 1 ) &&
 8034f80:	7903      	ldrb	r3, [r0, #4]
 8034f82:	1e5a      	subs	r2, r3, #1
 8034f84:	2a0e      	cmp	r2, #14
 8034f86:	f63f af36 	bhi.w	8034df6 <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup2.MacParams.ChannelsNbTrans = mibSet->Param.ChannelsNbTrans;
 8034f8a:	f885 356c 	strb.w	r3, [r5, #1388]	; 0x56c
 8034f8e:	e72b      	b.n	8034de8 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.MaxRxWindow = mibSet->Param.MaxRxWindow;
 8034f90:	6843      	ldr	r3, [r0, #4]
 8034f92:	f8c5 3558 	str.w	r3, [r5, #1368]	; 0x558
            break;
 8034f96:	e727      	b.n	8034de8 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.ReceiveDelay1 = mibSet->Param.ReceiveDelay1;
 8034f98:	6843      	ldr	r3, [r0, #4]
 8034f9a:	f8c5 355c 	str.w	r3, [r5, #1372]	; 0x55c
            break;
 8034f9e:	e723      	b.n	8034de8 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.ReceiveDelay2 = mibSet->Param.ReceiveDelay2;
 8034fa0:	6843      	ldr	r3, [r0, #4]
 8034fa2:	f8c5 3560 	str.w	r3, [r5, #1376]	; 0x560
            break;
 8034fa6:	e71f      	b.n	8034de8 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.JoinAcceptDelay1 = mibSet->Param.JoinAcceptDelay1;
 8034fa8:	6843      	ldr	r3, [r0, #4]
 8034faa:	f8c5 3564 	str.w	r3, [r5, #1380]	; 0x564
            break;
 8034fae:	e71b      	b.n	8034de8 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.JoinAcceptDelay2 = mibSet->Param.JoinAcceptDelay2;
 8034fb0:	6843      	ldr	r3, [r0, #4]
 8034fb2:	f8c5 3568 	str.w	r3, [r5, #1384]	; 0x568
            break;
 8034fb6:	e717      	b.n	8034de8 <LoRaMacMibSetRequestConfirm+0x84>
            verify.DatarateParams.Datarate = mibSet->Param.ChannelsDefaultDatarate;
 8034fb8:	7903      	ldrb	r3, [r0, #4]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_DR ) == true )
 8034fba:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            verify.DatarateParams.Datarate = mibSet->Param.ChannelsDefaultDatarate;
 8034fbe:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_DR ) == true )
 8034fc2:	2206      	movs	r2, #6
 8034fc4:	4669      	mov	r1, sp
 8034fc6:	f001 fb9a 	bl	80366fe <RegionVerify>
 8034fca:	2800      	cmp	r0, #0
 8034fcc:	f43f af13 	beq.w	8034df6 <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup2.ChannelsDatarateDefault = verify.DatarateParams.Datarate;
 8034fd0:	f89d 3000 	ldrb.w	r3, [sp]
 8034fd4:	f885 35d1 	strb.w	r3, [r5, #1489]	; 0x5d1
 8034fd8:	e706      	b.n	8034de8 <LoRaMacMibSetRequestConfirm+0x84>
            verify.DatarateParams.Datarate = mibSet->Param.ChannelsDatarate;
 8034fda:	7903      	ldrb	r3, [r0, #4]
 8034fdc:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_DR ) == true )
 8034fe0:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            verify.DatarateParams.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8034fe4:	f895 3580 	ldrb.w	r3, [r5, #1408]	; 0x580
 8034fe8:	f88d 3002 	strb.w	r3, [sp, #2]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_DR ) == true )
 8034fec:	2205      	movs	r2, #5
 8034fee:	4669      	mov	r1, sp
 8034ff0:	f001 fb85 	bl	80366fe <RegionVerify>
 8034ff4:	2800      	cmp	r0, #0
 8034ff6:	f43f aefe 	beq.w	8034df6 <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup1.ChannelsDatarate = verify.DatarateParams.Datarate;
 8034ffa:	f89d 3000 	ldrb.w	r3, [sp]
 8034ffe:	f885 3545 	strb.w	r3, [r5, #1349]	; 0x545
 8035002:	e6f1      	b.n	8034de8 <LoRaMacMibSetRequestConfirm+0x84>
 8035004:	20004aa4 	.word	0x20004aa4
 8035008:	0803bbc0 	.word	0x0803bbc0
 803500c:	20005014 	.word	0x20005014
 8035010:	20005054 	.word	0x20005054
 8035014:	2000501c 	.word	0x2000501c
 8035018:	2000505c 	.word	0x2000505c
            verify.TxPower = mibSet->Param.ChannelsDefaultTxPower;
 803501c:	7903      	ldrb	r3, [r0, #4]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_POWER ) == true )
 803501e:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            verify.TxPower = mibSet->Param.ChannelsDefaultTxPower;
 8035022:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_POWER ) == true )
 8035026:	220a      	movs	r2, #10
 8035028:	4669      	mov	r1, sp
 803502a:	f001 fb68 	bl	80366fe <RegionVerify>
 803502e:	2800      	cmp	r0, #0
 8035030:	f43f aee1 	beq.w	8034df6 <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup2.ChannelsTxPowerDefault = verify.TxPower;
 8035034:	f89d 3000 	ldrb.w	r3, [sp]
 8035038:	f885 35d0 	strb.w	r3, [r5, #1488]	; 0x5d0
 803503c:	e6d4      	b.n	8034de8 <LoRaMacMibSetRequestConfirm+0x84>
            verify.TxPower = mibSet->Param.ChannelsTxPower;
 803503e:	7903      	ldrb	r3, [r0, #4]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_POWER ) == true )
 8035040:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            verify.TxPower = mibSet->Param.ChannelsTxPower;
 8035044:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_POWER ) == true )
 8035048:	2209      	movs	r2, #9
 803504a:	4669      	mov	r1, sp
 803504c:	f001 fb57 	bl	80366fe <RegionVerify>
 8035050:	2800      	cmp	r0, #0
 8035052:	f43f aed0 	beq.w	8034df6 <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup1.ChannelsTxPower = verify.TxPower;
 8035056:	f89d 3000 	ldrb.w	r3, [sp]
 803505a:	f885 3544 	strb.w	r3, [r5, #1348]	; 0x544
 803505e:	e6c3      	b.n	8034de8 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.SystemMaxRxError = Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError = mibSet->Param.SystemMaxRxError;
 8035060:	6843      	ldr	r3, [r0, #4]
 8035062:	f8c5 3590 	str.w	r3, [r5, #1424]	; 0x590
 8035066:	f8c5 3550 	str.w	r3, [r5, #1360]	; 0x550
            break;
 803506a:	e6bd      	b.n	8034de8 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.MinRxSymbols = Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols = mibSet->Param.MinRxSymbols;
 803506c:	7903      	ldrb	r3, [r0, #4]
 803506e:	f885 3594 	strb.w	r3, [r5, #1428]	; 0x594
 8035072:	f885 3554 	strb.w	r3, [r5, #1364]	; 0x554
            break;
 8035076:	e6b7      	b.n	8034de8 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.AntennaGain = mibSet->Param.AntennaGain;
 8035078:	6843      	ldr	r3, [r0, #4]
 803507a:	f8c5 3588 	str.w	r3, [r5, #1416]	; 0x588
            break;
 803507e:	e6b3      	b.n	8034de8 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParamsDefaults.AntennaGain = mibSet->Param.DefaultAntennaGain;
 8035080:	6843      	ldr	r3, [r0, #4]
 8035082:	f8c5 35c8 	str.w	r3, [r5, #1480]	; 0x5c8
            break;
 8035086:	e6af      	b.n	8034de8 <LoRaMacMibSetRequestConfirm+0x84>
            if( mibSet->Param.Contexts != 0 )
 8035088:	6844      	ldr	r4, [r0, #4]
 803508a:	2c00      	cmp	r4, #0
 803508c:	f43f aeb3 	beq.w	8034df6 <LoRaMacMibSetRequestConfirm+0x92>
    if( MacCtx.MacState != LORAMAC_STOPPED )
 8035090:	2b01      	cmp	r3, #1
 8035092:	d177      	bne.n	8035184 <LoRaMacMibSetRequestConfirm+0x420>
    crc = Crc32( ( uint8_t* ) &nvm->Crypto, sizeof( nvm->Crypto ) -
 8035094:	2124      	movs	r1, #36	; 0x24
 8035096:	4620      	mov	r0, r4
 8035098:	f003 ff2e 	bl	8038ef8 <Crc32>
    if( crc == nvm->Crypto.Crc32 )
 803509c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 803509e:	4298      	cmp	r0, r3
 80350a0:	d104      	bne.n	80350ac <LoRaMacMibSetRequestConfirm+0x348>
        memcpy1( ( uint8_t* ) &Nvm.Crypto, ( uint8_t* ) &nvm->Crypto,
 80350a2:	4839      	ldr	r0, [pc, #228]	; (8035188 <LoRaMacMibSetRequestConfirm+0x424>)
 80350a4:	2228      	movs	r2, #40	; 0x28
 80350a6:	4621      	mov	r1, r4
 80350a8:	f003 ff0a 	bl	8038ec0 <memcpy1>
    crc = Crc32( ( uint8_t* ) &nvm->MacGroup1, sizeof( nvm->MacGroup1 ) -
 80350ac:	f104 0628 	add.w	r6, r4, #40	; 0x28
 80350b0:	2114      	movs	r1, #20
 80350b2:	4630      	mov	r0, r6
 80350b4:	f003 ff20 	bl	8038ef8 <Crc32>
    if( crc == nvm->MacGroup1.Crc32 )
 80350b8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80350ba:	4298      	cmp	r0, r3
 80350bc:	d104      	bne.n	80350c8 <LoRaMacMibSetRequestConfirm+0x364>
        memcpy1( ( uint8_t* ) &Nvm.MacGroup1, ( uint8_t* ) &nvm->MacGroup1,
 80350be:	4833      	ldr	r0, [pc, #204]	; (803518c <LoRaMacMibSetRequestConfirm+0x428>)
 80350c0:	2218      	movs	r2, #24
 80350c2:	4631      	mov	r1, r6
 80350c4:	f003 fefc 	bl	8038ec0 <memcpy1>
    crc = Crc32( ( uint8_t* ) &nvm->MacGroup2, sizeof( nvm->MacGroup2 ) -
 80350c8:	f104 0640 	add.w	r6, r4, #64	; 0x40
 80350cc:	21d4      	movs	r1, #212	; 0xd4
 80350ce:	4630      	mov	r0, r6
 80350d0:	f003 ff12 	bl	8038ef8 <Crc32>
    if( crc == nvm->MacGroup2.Crc32 )
 80350d4:	f8d4 3114 	ldr.w	r3, [r4, #276]	; 0x114
 80350d8:	4298      	cmp	r0, r3
 80350da:	d114      	bne.n	8035106 <LoRaMacMibSetRequestConfirm+0x3a2>
        memcpy1( ( uint8_t* ) &Nvm.MacGroup2, ( uint8_t* ) &nvm->MacGroup2,
 80350dc:	482c      	ldr	r0, [pc, #176]	; (8035190 <LoRaMacMibSetRequestConfirm+0x42c>)
 80350de:	22d8      	movs	r2, #216	; 0xd8
 80350e0:	4631      	mov	r1, r6
 80350e2:	f003 feed 	bl	8038ec0 <memcpy1>
        MacCtx.RxWindowCConfig.Channel = MacCtx.Channel;
 80350e6:	f895 3419 	ldrb.w	r3, [r5, #1049]	; 0x419
 80350ea:	f885 33e4 	strb.w	r3, [r5, #996]	; 0x3e4
        MacCtx.RxWindowCConfig.Frequency = Nvm.MacGroup2.MacParams.RxCChannel.Frequency;
 80350ee:	f8d5 3578 	ldr.w	r3, [r5, #1400]	; 0x578
 80350f2:	f8c5 33e8 	str.w	r3, [r5, #1000]	; 0x3e8
        MacCtx.RxWindowCConfig.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 80350f6:	f895 3581 	ldrb.w	r3, [r5, #1409]	; 0x581
 80350fa:	f885 33f4 	strb.w	r3, [r5, #1012]	; 0x3f4
        MacCtx.RxWindowCConfig.RxContinuous = true;
 80350fe:	f240 2301 	movw	r3, #513	; 0x201
 8035102:	f8a5 33f6 	strh.w	r3, [r5, #1014]	; 0x3f6
    crc = Crc32( ( uint8_t* ) &nvm->SecureElement, sizeof( nvm->SecureElement ) -
 8035106:	f504 758c 	add.w	r5, r4, #280	; 0x118
 803510a:	f44f 7180 	mov.w	r1, #256	; 0x100
 803510e:	4628      	mov	r0, r5
 8035110:	f003 fef2 	bl	8038ef8 <Crc32>
    if( crc == nvm->SecureElement.Crc32 )
 8035114:	f8d4 3218 	ldr.w	r3, [r4, #536]	; 0x218
 8035118:	4298      	cmp	r0, r3
 803511a:	d105      	bne.n	8035128 <LoRaMacMibSetRequestConfirm+0x3c4>
        memcpy1( ( uint8_t* ) &Nvm.SecureElement,( uint8_t* ) &nvm->SecureElement,
 803511c:	481d      	ldr	r0, [pc, #116]	; (8035194 <LoRaMacMibSetRequestConfirm+0x430>)
 803511e:	f44f 7282 	mov.w	r2, #260	; 0x104
 8035122:	4629      	mov	r1, r5
 8035124:	f003 fecc 	bl	8038ec0 <memcpy1>
    crc = Crc32( ( uint8_t* ) &nvm->RegionGroup1, sizeof( nvm->RegionGroup1 ) -
 8035128:	f504 7507 	add.w	r5, r4, #540	; 0x21c
 803512c:	21a0      	movs	r1, #160	; 0xa0
 803512e:	4628      	mov	r0, r5
 8035130:	f003 fee2 	bl	8038ef8 <Crc32>
    if( crc == nvm->RegionGroup1.Crc32 )
 8035134:	f8d4 32bc 	ldr.w	r3, [r4, #700]	; 0x2bc
 8035138:	4298      	cmp	r0, r3
 803513a:	d104      	bne.n	8035146 <LoRaMacMibSetRequestConfirm+0x3e2>
        memcpy1( ( uint8_t* ) &Nvm.RegionGroup1,( uint8_t* ) &nvm->RegionGroup1,
 803513c:	4816      	ldr	r0, [pc, #88]	; (8035198 <LoRaMacMibSetRequestConfirm+0x434>)
 803513e:	22a4      	movs	r2, #164	; 0xa4
 8035140:	4629      	mov	r1, r5
 8035142:	f003 febd 	bl	8038ec0 <memcpy1>
    crc = Crc32( ( uint8_t* ) &nvm->ClassB, sizeof( nvm->ClassB ) -
 8035146:	f204 653c 	addw	r5, r4, #1596	; 0x63c
 803514a:	2114      	movs	r1, #20
 803514c:	4628      	mov	r0, r5
 803514e:	f003 fed3 	bl	8038ef8 <Crc32>
    if( crc == nvm->ClassB.Crc32 )
 8035152:	f8d4 3650 	ldr.w	r3, [r4, #1616]	; 0x650
 8035156:	4298      	cmp	r0, r3
 8035158:	f47f ae46 	bne.w	8034de8 <LoRaMacMibSetRequestConfirm+0x84>
        memcpy1( ( uint8_t* ) &Nvm.ClassB,( uint8_t* ) &nvm->ClassB,
 803515c:	480f      	ldr	r0, [pc, #60]	; (803519c <LoRaMacMibSetRequestConfirm+0x438>)
 803515e:	2218      	movs	r2, #24
 8035160:	4629      	mov	r1, r5
 8035162:	f003 fead 	bl	8038ec0 <memcpy1>
 8035166:	e63f      	b.n	8034de8 <LoRaMacMibSetRequestConfirm+0x84>
            if( mibSet->Param.AbpLrWanVersion.Fields.Minor <= 1 )
 8035168:	7983      	ldrb	r3, [r0, #6]
 803516a:	2b01      	cmp	r3, #1
 803516c:	f63f ae43 	bhi.w	8034df6 <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup2.Version = mibSet->Param.AbpLrWanVersion;
 8035170:	6843      	ldr	r3, [r0, #4]
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetLrWanVersion( mibSet->Param.AbpLrWanVersion ) )
 8035172:	6840      	ldr	r0, [r0, #4]
                Nvm.MacGroup2.Version = mibSet->Param.AbpLrWanVersion;
 8035174:	f8c5 3618 	str.w	r3, [r5, #1560]	; 0x618
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetLrWanVersion( mibSet->Param.AbpLrWanVersion ) )
 8035178:	f000 ff04 	bl	8035f84 <LoRaMacCryptoSetLrWanVersion>
 803517c:	e653      	b.n	8034e26 <LoRaMacMibSetRequestConfirm+0xc2>
            status = LoRaMacMibClassBSetRequestConfirm( mibSet );
 803517e:	f000 fbef 	bl	8035960 <LoRaMacMibClassBSetRequestConfirm>
            break;
 8035182:	e62a      	b.n	8034dda <LoRaMacMibSetRequestConfirm+0x76>
        return LORAMAC_STATUS_BUSY;
 8035184:	2001      	movs	r0, #1
 8035186:	e628      	b.n	8034dda <LoRaMacMibSetRequestConfirm+0x76>
 8035188:	20004fb0 	.word	0x20004fb0
 803518c:	20004fd8 	.word	0x20004fd8
 8035190:	20004ff0 	.word	0x20004ff0
 8035194:	200050c8 	.word	0x200050c8
 8035198:	200051cc 	.word	0x200051cc
 803519c:	200055ec 	.word	0x200055ec

080351a0 <LoRaMacMcChannelSetup>:
    return LORAMAC_STATUS_OK;
}

LoRaMacStatus_t LoRaMacMcChannelSetup( McChannelParams_t *channel )
{
    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 80351a0:	4b24      	ldr	r3, [pc, #144]	; (8035234 <LoRaMacMcChannelSetup+0x94>)
 80351a2:	f8d3 2344 	ldr.w	r2, [r3, #836]	; 0x344
 80351a6:	f012 0f02 	tst.w	r2, #2
{
 80351aa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80351ae:	4604      	mov	r4, r0
 80351b0:	4698      	mov	r8, r3
    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 80351b2:	d13b      	bne.n	803522c <LoRaMacMcChannelSetup+0x8c>
    {
        return LORAMAC_STATUS_BUSY;
    }

    if( channel->GroupID >= LORAMAC_MAX_MC_CTX )
 80351b4:	78c7      	ldrb	r7, [r0, #3]
 80351b6:	2f00      	cmp	r7, #0
 80351b8:	d13a      	bne.n	8035230 <LoRaMacMcChannelSetup+0x90>
    {
        return LORAMAC_STATUS_MC_GROUP_UNDEFINED;
    }

    Nvm.MacGroup2.MulticastChannelList[channel->GroupID].ChannelParams = *channel;
 80351ba:	4606      	mov	r6, r0
 80351bc:	f203 55dc 	addw	r5, r3, #1500	; 0x5dc
 80351c0:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80351c2:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80351c4:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
 80351c8:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}

    if( channel->IsRemotelySetup == true )
 80351cc:	7823      	ldrb	r3, [r4, #0]
#if ( LORAMAC_MAX_MC_CTX > 3 )
            , MC_KEY_3
#endif /* LORAMAC_MAX_MC_CTX > 3 */
        };
        /* ST_WORKAROUND_END */
        if( LoRaMacCryptoSetKey( mcKeys[channel->GroupID], channel->McKeys.McKeyE ) != LORAMAC_CRYPTO_SUCCESS )
 80351ce:	68a1      	ldr	r1, [r4, #8]
    if( channel->IsRemotelySetup == true )
 80351d0:	b313      	cbz	r3, 8035218 <LoRaMacMcChannelSetup+0x78>
        if( LoRaMacCryptoSetKey( mcKeys[channel->GroupID], channel->McKeys.McKeyE ) != LORAMAC_CRYPTO_SUCCESS )
 80351d2:	2080      	movs	r0, #128	; 0x80
 80351d4:	f001 f846 	bl	8036264 <LoRaMacCryptoSetKey>
 80351d8:	b118      	cbz	r0, 80351e2 <LoRaMacMcChannelSetup+0x42>
{
 80351da:	2711      	movs	r7, #17
    }

    // Reset multicast channel downlink counter to initial value.
    *Nvm.MacGroup2.MulticastChannelList[channel->GroupID].DownLinkCounter = FCNT_DOWN_INITAL_VALUE;
    return LORAMAC_STATUS_OK;
}
 80351dc:	4638      	mov	r0, r7
 80351de:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if( LoRaMacCryptoDeriveMcSessionKeyPair( channel->GroupID, channel->Address ) != LORAMAC_CRYPTO_SUCCESS )
 80351e2:	6861      	ldr	r1, [r4, #4]
 80351e4:	78e0      	ldrb	r0, [r4, #3]
 80351e6:	f001 f8c5 	bl	8036374 <LoRaMacCryptoDeriveMcSessionKeyPair>
        if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( mcNwkSKeys[channel->GroupID], channel->McKeys.Session.McNwkSKey ) )
 80351ea:	2800      	cmp	r0, #0
 80351ec:	d1f5      	bne.n	80351da <LoRaMacMcChannelSetup+0x3a>
    if( channel->Class == CLASS_B )
 80351ee:	7863      	ldrb	r3, [r4, #1]
 80351f0:	2b01      	cmp	r3, #1
 80351f2:	d107      	bne.n	8035204 <LoRaMacMcChannelSetup+0x64>
        LoRaMacClassBSetMulticastPeriodicity( &Nvm.MacGroup2.MulticastChannelList[channel->GroupID] );
 80351f4:	78e0      	ldrb	r0, [r4, #3]
 80351f6:	4b10      	ldr	r3, [pc, #64]	; (8035238 <LoRaMacMcChannelSetup+0x98>)
 80351f8:	222c      	movs	r2, #44	; 0x2c
 80351fa:	fb02 3000 	mla	r0, r2, r0, r3
 80351fe:	30d0      	adds	r0, #208	; 0xd0
 8035200:	f000 fbba 	bl	8035978 <LoRaMacClassBSetMulticastPeriodicity>
    *Nvm.MacGroup2.MulticastChannelList[channel->GroupID].DownLinkCounter = FCNT_DOWN_INITAL_VALUE;
 8035204:	78e3      	ldrb	r3, [r4, #3]
 8035206:	222c      	movs	r2, #44	; 0x2c
 8035208:	fb02 8803 	mla	r8, r2, r3, r8
 803520c:	f04f 32ff 	mov.w	r2, #4294967295
 8035210:	f8d8 35fc 	ldr.w	r3, [r8, #1532]	; 0x5fc
 8035214:	601a      	str	r2, [r3, #0]
    return LORAMAC_STATUS_OK;
 8035216:	e7e1      	b.n	80351dc <LoRaMacMcChannelSetup+0x3c>
        if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( mcAppSKeys[channel->GroupID], channel->McKeys.Session.McAppSKey ) )
 8035218:	2081      	movs	r0, #129	; 0x81
 803521a:	f001 f823 	bl	8036264 <LoRaMacCryptoSetKey>
 803521e:	2800      	cmp	r0, #0
 8035220:	d1db      	bne.n	80351da <LoRaMacMcChannelSetup+0x3a>
        if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( mcNwkSKeys[channel->GroupID], channel->McKeys.Session.McNwkSKey ) )
 8035222:	68e1      	ldr	r1, [r4, #12]
 8035224:	2082      	movs	r0, #130	; 0x82
 8035226:	f001 f81d 	bl	8036264 <LoRaMacCryptoSetKey>
 803522a:	e7de      	b.n	80351ea <LoRaMacMcChannelSetup+0x4a>
        return LORAMAC_STATUS_BUSY;
 803522c:	2701      	movs	r7, #1
 803522e:	e7d5      	b.n	80351dc <LoRaMacMcChannelSetup+0x3c>
        return LORAMAC_STATUS_MC_GROUP_UNDEFINED;
 8035230:	2716      	movs	r7, #22
 8035232:	e7d3      	b.n	80351dc <LoRaMacMcChannelSetup+0x3c>
 8035234:	20004aa4 	.word	0x20004aa4
 8035238:	20004fb0 	.word	0x20004fb0

0803523c <LoRaMacMcChannelDelete>:

LoRaMacStatus_t LoRaMacMcChannelDelete( AddressIdentifier_t groupID )
{
 803523c:	b570      	push	{r4, r5, r6, lr}
    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 803523e:	4c10      	ldr	r4, [pc, #64]	; (8035280 <LoRaMacMcChannelDelete+0x44>)
 8035240:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 8035244:	079b      	lsls	r3, r3, #30
{
 8035246:	b088      	sub	sp, #32
 8035248:	4606      	mov	r6, r0
    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 803524a:	d414      	bmi.n	8035276 <LoRaMacMcChannelDelete+0x3a>
    {
        return LORAMAC_STATUS_BUSY;
    }

    if( ( groupID >= LORAMAC_MAX_MC_CTX ) ||
 803524c:	b9a8      	cbnz	r0, 803527a <LoRaMacMcChannelDelete+0x3e>
 803524e:	f894 35de 	ldrb.w	r3, [r4, #1502]	; 0x5de
 8035252:	b193      	cbz	r3, 803527a <LoRaMacMcChannelDelete+0x3e>
    }

    McChannelParams_t channel;

    // Set all channel fields with 0
    memset1( ( uint8_t* )&channel, 0, sizeof( McChannelParams_t ) );
 8035254:	4601      	mov	r1, r0
 8035256:	2220      	movs	r2, #32
 8035258:	4668      	mov	r0, sp

    Nvm.MacGroup2.MulticastChannelList[groupID].ChannelParams = channel;
 803525a:	466d      	mov	r5, sp
    memset1( ( uint8_t* )&channel, 0, sizeof( McChannelParams_t ) );
 803525c:	f003 fe44 	bl	8038ee8 <memset1>
    Nvm.MacGroup2.MulticastChannelList[groupID].ChannelParams = channel;
 8035260:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8035262:	f204 54dc 	addw	r4, r4, #1500	; 0x5dc
 8035266:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8035268:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 803526c:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    return LORAMAC_STATUS_OK;
}
 8035270:	4630      	mov	r0, r6
 8035272:	b008      	add	sp, #32
 8035274:	bd70      	pop	{r4, r5, r6, pc}
        return LORAMAC_STATUS_BUSY;
 8035276:	2601      	movs	r6, #1
 8035278:	e7fa      	b.n	8035270 <LoRaMacMcChannelDelete+0x34>
        return LORAMAC_STATUS_MC_GROUP_UNDEFINED;
 803527a:	2616      	movs	r6, #22
 803527c:	e7f8      	b.n	8035270 <LoRaMacMcChannelDelete+0x34>
 803527e:	bf00      	nop
 8035280:	20004aa4 	.word	0x20004aa4

08035284 <LoRaMacMcChannelGetGroupId>:

uint8_t LoRaMacMcChannelGetGroupId( uint32_t mcAddress )
{
    for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
    {
        if( mcAddress == Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.Address )
 8035284:	4b03      	ldr	r3, [pc, #12]	; (8035294 <LoRaMacMcChannelGetGroupId+0x10>)
 8035286:	f8d3 35e0 	ldr.w	r3, [r3, #1504]	; 0x5e0
        {
            return i;
        }
    }
    return 0xFF;
}
 803528a:	4283      	cmp	r3, r0
 803528c:	bf14      	ite	ne
 803528e:	20ff      	movne	r0, #255	; 0xff
 8035290:	2000      	moveq	r0, #0
 8035292:	4770      	bx	lr
 8035294:	20004aa4 	.word	0x20004aa4

08035298 <LoRaMacMcChannelSetupRxParams>:

LoRaMacStatus_t LoRaMacMcChannelSetupRxParams( AddressIdentifier_t groupID, McRxParams_t *rxParams, uint8_t *status )
{
   *status = 0x1C + ( groupID & 0x03 );
 8035298:	f000 0303 	and.w	r3, r0, #3
{
 803529c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   *status = 0x1C + ( groupID & 0x03 );
 803529e:	331c      	adds	r3, #28

    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 80352a0:	4e24      	ldr	r6, [pc, #144]	; (8035334 <LoRaMacMcChannelSetupRxParams+0x9c>)
   *status = 0x1C + ( groupID & 0x03 );
 80352a2:	7013      	strb	r3, [r2, #0]
{
 80352a4:	4615      	mov	r5, r2
    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 80352a6:	f8d6 2344 	ldr.w	r2, [r6, #836]	; 0x344
 80352aa:	0792      	lsls	r2, r2, #30
{
 80352ac:	4604      	mov	r4, r0
 80352ae:	460f      	mov	r7, r1
    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 80352b0:	d439      	bmi.n	8035326 <LoRaMacMcChannelSetupRxParams+0x8e>
    {
        return LORAMAC_STATUS_BUSY;
    }

    DeviceClass_t devClass = Nvm.MacGroup2.MulticastChannelList[groupID].ChannelParams.Class;
 80352b2:	222c      	movs	r2, #44	; 0x2c
 80352b4:	fb02 6200 	mla	r2, r2, r0, r6
 80352b8:	f892 25dd 	ldrb.w	r2, [r2, #1501]	; 0x5dd
    if( ( devClass == CLASS_A ) || ( devClass > CLASS_C ) )
 80352bc:	1e51      	subs	r1, r2, #1
 80352be:	2901      	cmp	r1, #1
 80352c0:	d833      	bhi.n	803532a <LoRaMacMcChannelSetupRxParams+0x92>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }

    if( ( groupID >= LORAMAC_MAX_MC_CTX ) ||
 80352c2:	bba0      	cbnz	r0, 803532e <LoRaMacMcChannelSetupRxParams+0x96>
 80352c4:	f896 15de 	ldrb.w	r1, [r6, #1502]	; 0x5de
 80352c8:	b389      	cbz	r1, 803532e <LoRaMacMcChannelSetupRxParams+0x96>
        ( Nvm.MacGroup2.MulticastChannelList[groupID].ChannelParams.IsEnabled == false ) )
    {
        return LORAMAC_STATUS_MC_GROUP_UNDEFINED;
    }
    *status &= 0x0F; // groupID OK
 80352ca:	f003 030f 	and.w	r3, r3, #15
 80352ce:	702b      	strb	r3, [r5, #0]

    VerifyParams_t verify;
    // Check datarate
    if( devClass == CLASS_B )
    {
        verify.DatarateParams.Datarate = rxParams->ClassB.Datarate;
 80352d0:	f997 3004 	ldrsb.w	r3, [r7, #4]
 80352d4:	f88d 3004 	strb.w	r3, [sp, #4]
    {
        verify.DatarateParams.Datarate = rxParams->ClassC.Datarate;
    }
    verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;

    if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 80352d8:	f896 054c 	ldrb.w	r0, [r6, #1356]	; 0x54c
    verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 80352dc:	f896 3581 	ldrb.w	r3, [r6, #1409]	; 0x581
 80352e0:	f88d 3005 	strb.w	r3, [sp, #5]
    if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 80352e4:	2207      	movs	r2, #7
 80352e6:	a901      	add	r1, sp, #4
 80352e8:	f001 fa09 	bl	80366fe <RegionVerify>
 80352ec:	b118      	cbz	r0, 80352f6 <LoRaMacMcChannelSetupRxParams+0x5e>
    {
        *status &= 0xFB; // datarate OK
 80352ee:	782b      	ldrb	r3, [r5, #0]
 80352f0:	f023 0304 	bic.w	r3, r3, #4
 80352f4:	702b      	strb	r3, [r5, #0]
    }

    // Check frequency
    if( devClass == CLASS_B )
 80352f6:	683b      	ldr	r3, [r7, #0]
    }
    else
    {
        verify.Frequency = rxParams->ClassC.Frequency;
    }
    if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_FREQUENCY ) == true )
 80352f8:	f896 054c 	ldrb.w	r0, [r6, #1356]	; 0x54c
 80352fc:	9301      	str	r3, [sp, #4]
 80352fe:	2200      	movs	r2, #0
 8035300:	a901      	add	r1, sp, #4
 8035302:	f001 f9fc 	bl	80366fe <RegionVerify>
 8035306:	b118      	cbz	r0, 8035310 <LoRaMacMcChannelSetupRxParams+0x78>
    {
        *status &= 0xF7; // frequency OK
 8035308:	782b      	ldrb	r3, [r5, #0]
 803530a:	f023 0308 	bic.w	r3, r3, #8
 803530e:	702b      	strb	r3, [r5, #0]
    }

    if( *status == ( groupID & 0x03 ) )
 8035310:	782b      	ldrb	r3, [r5, #0]
 8035312:	b92b      	cbnz	r3, 8035320 <LoRaMacMcChannelSetupRxParams+0x88>
    {
        // Apply parameters
        Nvm.MacGroup2.MulticastChannelList[groupID].ChannelParams.RxParams = *rxParams;
 8035314:	e897 0003 	ldmia.w	r7, {r0, r1}
 8035318:	4a07      	ldr	r2, [pc, #28]	; (8035338 <LoRaMacMcChannelSetupRxParams+0xa0>)
 803531a:	e882 0003 	stmia.w	r2, {r0, r1}
    }
    return LORAMAC_STATUS_OK;
 803531e:	461c      	mov	r4, r3
}
 8035320:	4620      	mov	r0, r4
 8035322:	b003      	add	sp, #12
 8035324:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return LORAMAC_STATUS_BUSY;
 8035326:	2401      	movs	r4, #1
 8035328:	e7fa      	b.n	8035320 <LoRaMacMcChannelSetupRxParams+0x88>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 803532a:	2403      	movs	r4, #3
 803532c:	e7f8      	b.n	8035320 <LoRaMacMcChannelSetupRxParams+0x88>
        return LORAMAC_STATUS_MC_GROUP_UNDEFINED;
 803532e:	2416      	movs	r4, #22
 8035330:	e7f6      	b.n	8035320 <LoRaMacMcChannelSetupRxParams+0x88>
 8035332:	bf00      	nop
 8035334:	20004aa4 	.word	0x20004aa4
 8035338:	20005098 	.word	0x20005098

0803533c <LoRaMacMlmeRequest>:

LoRaMacStatus_t LoRaMacMlmeRequest( MlmeReq_t* mlmeRequest )
{
 803533c:	b5f0      	push	{r4, r5, r6, r7, lr}
 803533e:	b087      	sub	sp, #28
    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;
    MlmeConfirmQueue_t queueElement;
    uint8_t macCmdPayload[2] = { 0x00, 0x00 };
 8035340:	2300      	movs	r3, #0
 8035342:	f8ad 3000 	strh.w	r3, [sp]

    if( mlmeRequest == NULL )
 8035346:	4606      	mov	r6, r0
 8035348:	2800      	cmp	r0, #0
 803534a:	f000 80df 	beq.w	803550c <LoRaMacMlmeRequest+0x1d0>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }
    if( LoRaMacIsBusy( ) == true )
 803534e:	f7fe fd5d 	bl	8033e0c <LoRaMacIsBusy>
 8035352:	b118      	cbz	r0, 803535c <LoRaMacMlmeRequest+0x20>
    {
        return LORAMAC_STATUS_BUSY;
 8035354:	2501      	movs	r5, #1
    else
    {
        LoRaMacConfirmQueueAdd( &queueElement );
    }
    return status;
}
 8035356:	4628      	mov	r0, r5
 8035358:	b007      	add	sp, #28
 803535a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if( LoRaMacConfirmQueueIsFull( ) == true )
 803535c:	f000 fcf4 	bl	8035d48 <LoRaMacConfirmQueueIsFull>
 8035360:	2800      	cmp	r0, #0
 8035362:	d1f7      	bne.n	8035354 <LoRaMacMlmeRequest+0x18>
    if( LoRaMacConfirmQueueGetCnt( ) == 0 )
 8035364:	f000 fcea 	bl	8035d3c <LoRaMacConfirmQueueGetCnt>
 8035368:	4601      	mov	r1, r0
 803536a:	b918      	cbnz	r0, 8035374 <LoRaMacMlmeRequest+0x38>
        memset1( ( uint8_t* ) &MacCtx.MlmeConfirm, 0, sizeof( MacCtx.MlmeConfirm ) );
 803536c:	4868      	ldr	r0, [pc, #416]	; (8035510 <LoRaMacMlmeRequest+0x1d4>)
 803536e:	2214      	movs	r2, #20
 8035370:	f003 fdba 	bl	8038ee8 <memset1>
    MacCtx.MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 8035374:	4c67      	ldr	r4, [pc, #412]	; (8035514 <LoRaMacMlmeRequest+0x1d8>)
    MacCtx.MacFlags.Bits.MlmeReq = 1;
 8035376:	f894 2485 	ldrb.w	r2, [r4, #1157]	; 0x485
    MacCtx.MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 803537a:	2301      	movs	r3, #1
    MacCtx.MacFlags.Bits.MlmeReq = 1;
 803537c:	f042 0204 	orr.w	r2, r2, #4
    MacCtx.MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 8035380:	f884 3451 	strb.w	r3, [r4, #1105]	; 0x451
    MacCtx.MacFlags.Bits.MlmeReq = 1;
 8035384:	f884 2485 	strb.w	r2, [r4, #1157]	; 0x485
    queueElement.Request = mlmeRequest->Type;
 8035388:	7832      	ldrb	r2, [r6, #0]
 803538a:	f88d 2004 	strb.w	r2, [sp, #4]
    queueElement.RestrictCommonReadyToHandle = false;
 803538e:	2100      	movs	r1, #0
 8035390:	3a01      	subs	r2, #1
    queueElement.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 8035392:	f88d 3005 	strb.w	r3, [sp, #5]
    queueElement.RestrictCommonReadyToHandle = false;
 8035396:	f88d 1007 	strb.w	r1, [sp, #7]
    switch( mlmeRequest->Type )
 803539a:	2a0d      	cmp	r2, #13
 803539c:	f200 80ae 	bhi.w	80354fc <LoRaMacMlmeRequest+0x1c0>
 80353a0:	e8df f002 	tbb	[pc, r2]
 80353a4:	57acac07 	.word	0x57acac07
 80353a8:	acac8261 	.word	0xacac8261
 80353ac:	a0ac8aac 	.word	0xa0ac8aac
 80353b0:	9c8e      	.short	0x9c8e
            if( ( MacCtx.MacState & LORAMAC_TX_DELAYED ) == LORAMAC_TX_DELAYED )
 80353b2:	f8d4 5344 	ldr.w	r5, [r4, #836]	; 0x344
 80353b6:	f015 0520 	ands.w	r5, r5, #32
 80353ba:	d1cb      	bne.n	8035354 <LoRaMacMlmeRequest+0x18>
            ResetMacParameters( );
 80353bc:	f7fd ff3a 	bl	8033234 <ResetMacParameters>
            Nvm.MacGroup1.ChannelsDatarate = RegionAlternateDr( Nvm.MacGroup2.Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR );
 80353c0:	462a      	mov	r2, r5
 80353c2:	f996 1004 	ldrsb.w	r1, [r6, #4]
 80353c6:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
            MacCtx.TxMsg.Message.JoinReq.Buffer = MacCtx.PktBuffer;
 80353ca:	4f53      	ldr	r7, [pc, #332]	; (8035518 <LoRaMacMlmeRequest+0x1dc>)
            Nvm.MacGroup1.ChannelsDatarate = RegionAlternateDr( Nvm.MacGroup2.Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR );
 80353cc:	f001 fa32 	bl	8036834 <RegionAlternateDr>
            queueElement.Status = LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL;
 80353d0:	2307      	movs	r3, #7
            Nvm.MacGroup1.ChannelsDatarate = RegionAlternateDr( Nvm.MacGroup2.Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR );
 80353d2:	f884 0545 	strb.w	r0, [r4, #1349]	; 0x545
            SwitchClass( CLASS_A );
 80353d6:	4628      	mov	r0, r5
            queueElement.Status = LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL;
 80353d8:	f88d 3005 	strb.w	r3, [sp, #5]
            SwitchClass( CLASS_A );
 80353dc:	f7fe f988 	bl	80336f0 <SwitchClass>
            MacCtx.TxMsg.Message.JoinReq.BufSize = LORAMAC_PHY_MAXPAYLOAD;
 80353e0:	23ff      	movs	r3, #255	; 0xff
 80353e2:	f884 3110 	strb.w	r3, [r4, #272]	; 0x110
            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_JOIN_REQUEST;
 80353e6:	f884 5108 	strb.w	r5, [r4, #264]	; 0x108
            MacCtx.TxMsg.Message.JoinReq.MHDR.Value = macHdr.Value;
 80353ea:	f884 5111 	strb.w	r5, [r4, #273]	; 0x111
            MacCtx.TxMsg.Message.JoinReq.Buffer = MacCtx.PktBuffer;
 80353ee:	f8c4 710c 	str.w	r7, [r4, #268]	; 0x10c
            memcpy1( MacCtx.TxMsg.Message.JoinReq.JoinEUI, SecureElementGetJoinEui( ), LORAMAC_JOIN_EUI_FIELD_SIZE );
 80353f2:	f003 fd3d 	bl	8038e70 <SecureElementGetJoinEui>
 80353f6:	2208      	movs	r2, #8
 80353f8:	4601      	mov	r1, r0
 80353fa:	f507 7086 	add.w	r0, r7, #268	; 0x10c
 80353fe:	f003 fd5f 	bl	8038ec0 <memcpy1>
            memcpy1( MacCtx.TxMsg.Message.JoinReq.DevEUI, SecureElementGetDevEui( ), LORAMAC_DEV_EUI_FIELD_SIZE );
 8035402:	f003 fd1f 	bl	8038e44 <SecureElementGetDevEui>
 8035406:	2208      	movs	r2, #8
 8035408:	4601      	mov	r1, r0
 803540a:	f507 708a 	add.w	r0, r7, #276	; 0x114
 803540e:	f003 fd57 	bl	8038ec0 <memcpy1>
    status = ScheduleTx( allowDelayedTx );
 8035412:	4628      	mov	r0, r5
 8035414:	f7fd ffa2 	bl	803335c <ScheduleTx>
            if( status != LORAMAC_STATUS_OK )
 8035418:	4605      	mov	r5, r0
 803541a:	b140      	cbz	r0, 803542e <LoRaMacMlmeRequest+0xf2>
                Nvm.MacGroup1.ChannelsDatarate = RegionAlternateDr( Nvm.MacGroup2.Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR_RESTORE );
 803541c:	f996 1004 	ldrsb.w	r1, [r6, #4]
 8035420:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
 8035424:	2201      	movs	r2, #1
 8035426:	f001 fa05 	bl	8036834 <RegionAlternateDr>
 803542a:	f884 0545 	strb.w	r0, [r4, #1349]	; 0x545
    mlmeRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;
 803542e:	f8d4 3488 	ldr.w	r3, [r4, #1160]	; 0x488
 8035432:	6133      	str	r3, [r6, #16]
    if( status != LORAMAC_STATUS_OK )
 8035434:	2d00      	cmp	r5, #0
 8035436:	d065      	beq.n	8035504 <LoRaMacMlmeRequest+0x1c8>
        if( LoRaMacConfirmQueueGetCnt( ) == 0 )
 8035438:	f000 fc80 	bl	8035d3c <LoRaMacConfirmQueueGetCnt>
 803543c:	2800      	cmp	r0, #0
 803543e:	d18a      	bne.n	8035356 <LoRaMacMlmeRequest+0x1a>
            MacCtx.MacFlags.Bits.MlmeReq = 0;
 8035440:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
            MacCtx.NodeAckRequested = false;
 8035444:	f884 0418 	strb.w	r0, [r4, #1048]	; 0x418
            MacCtx.MacFlags.Bits.MlmeReq = 0;
 8035448:	f360 0382 	bfi	r3, r0, #2, #1
 803544c:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
 8035450:	e781      	b.n	8035356 <LoRaMacMlmeRequest+0x1a>
            if( LoRaMacCommandsAddCmd( MOTE_MAC_LINK_CHECK_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )
 8035452:	2200      	movs	r2, #0
 8035454:	4669      	mov	r1, sp
 8035456:	2002      	movs	r0, #2
 8035458:	f000 fa9e 	bl	8035998 <LoRaMacCommandsAddCmd>
 803545c:	b908      	cbnz	r0, 8035462 <LoRaMacMlmeRequest+0x126>
            status = SetTxContinuousWave( mlmeRequest->Req.TxCw.Timeout );
 803545e:	2500      	movs	r5, #0
            break;
 8035460:	e7e5      	b.n	803542e <LoRaMacMlmeRequest+0xf2>
                status = LORAMAC_STATUS_MAC_COMMAD_ERROR;
 8035462:	2513      	movs	r5, #19
 8035464:	e7e3      	b.n	803542e <LoRaMacMlmeRequest+0xf2>
    continuousWave.Channel = MacCtx.Channel;
 8035466:	f894 2419 	ldrb.w	r2, [r4, #1049]	; 0x419
 803546a:	f88d 2008 	strb.w	r2, [sp, #8]
    continuousWave.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 803546e:	f894 2545 	ldrb.w	r2, [r4, #1349]	; 0x545
 8035472:	f88d 2009 	strb.w	r2, [sp, #9]
    continuousWave.TxPower = Nvm.MacGroup1.ChannelsTxPower;
 8035476:	f894 2544 	ldrb.w	r2, [r4, #1348]	; 0x544
 803547a:	f88d 200a 	strb.w	r2, [sp, #10]
    continuousWave.MaxEirp = Nvm.MacGroup2.MacParams.MaxEirp;
 803547e:	f8d4 2584 	ldr.w	r2, [r4, #1412]	; 0x584
            status = SetTxContinuousWave( mlmeRequest->Req.TxCw.Timeout );
 8035482:	88b3      	ldrh	r3, [r6, #4]
    continuousWave.MaxEirp = Nvm.MacGroup2.MacParams.MaxEirp;
 8035484:	9203      	str	r2, [sp, #12]
    RegionSetContinuousWave( Nvm.MacGroup2.Region, &continuousWave );
 8035486:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    continuousWave.AntennaGain = Nvm.MacGroup2.MacParams.AntennaGain;
 803548a:	f8d4 2588 	ldr.w	r2, [r4, #1416]	; 0x588
 803548e:	9204      	str	r2, [sp, #16]
    RegionSetContinuousWave( Nvm.MacGroup2.Region, &continuousWave );
 8035490:	a902      	add	r1, sp, #8
    continuousWave.Timeout = timeout;
 8035492:	f8ad 3014 	strh.w	r3, [sp, #20]
    RegionSetContinuousWave( Nvm.MacGroup2.Region, &continuousWave );
 8035496:	f001 f9ed 	bl	8036874 <RegionSetContinuousWave>
    MacCtx.MacState |= LORAMAC_TX_RUNNING;
 803549a:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 803549e:	f043 0302 	orr.w	r3, r3, #2
 80354a2:	f8c4 3344 	str.w	r3, [r4, #836]	; 0x344
 80354a6:	e7da      	b.n	803545e <LoRaMacMlmeRequest+0x122>
    Radio.SetTxContinuousWave( frequency, power, timeout );
 80354a8:	4b1c      	ldr	r3, [pc, #112]	; (803551c <LoRaMacMlmeRequest+0x1e0>)
 80354aa:	88b2      	ldrh	r2, [r6, #4]
 80354ac:	f996 100c 	ldrsb.w	r1, [r6, #12]
 80354b0:	68b0      	ldr	r0, [r6, #8]
 80354b2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80354b4:	4798      	blx	r3
    MacCtx.MacState |= LORAMAC_TX_RUNNING;
 80354b6:	e7f0      	b.n	803549a <LoRaMacMlmeRequest+0x15e>
            if( LoRaMacCommandsAddCmd( MOTE_MAC_DEVICE_TIME_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )
 80354b8:	2200      	movs	r2, #0
 80354ba:	4669      	mov	r1, sp
 80354bc:	200d      	movs	r0, #13
 80354be:	e7cb      	b.n	8035458 <LoRaMacMlmeRequest+0x11c>
            if( Nvm.MacGroup2.DeviceClass == CLASS_A )
 80354c0:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 80354c4:	b9d3      	cbnz	r3, 80354fc <LoRaMacMlmeRequest+0x1c0>
                uint8_t value = mlmeRequest->Req.PingSlotInfo.PingSlot.Value;
 80354c6:	7935      	ldrb	r5, [r6, #4]
                LoRaMacClassBSetPingSlotInfo( mlmeRequest->Req.PingSlotInfo.PingSlot.Fields.Periodicity );
 80354c8:	f005 0007 	and.w	r0, r5, #7
 80354cc:	f000 fa41 	bl	8035952 <LoRaMacClassBSetPingSlotInfo>
                macCmdPayload[0] = value;
 80354d0:	f88d 5000 	strb.w	r5, [sp]
                if( LoRaMacCommandsAddCmd( MOTE_MAC_PING_SLOT_INFO_REQ, macCmdPayload, 1 ) != LORAMAC_COMMANDS_SUCCESS )
 80354d4:	2201      	movs	r2, #1
 80354d6:	4669      	mov	r1, sp
 80354d8:	2010      	movs	r0, #16
 80354da:	e7bd      	b.n	8035458 <LoRaMacMlmeRequest+0x11c>
            if( LoRaMacCommandsAddCmd( MOTE_MAC_BEACON_TIMING_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )
 80354dc:	2200      	movs	r2, #0
 80354de:	4669      	mov	r1, sp
 80354e0:	2012      	movs	r0, #18
 80354e2:	e7b9      	b.n	8035458 <LoRaMacMlmeRequest+0x11c>
            queueElement.RestrictCommonReadyToHandle = true;
 80354e4:	f88d 3007 	strb.w	r3, [sp, #7]
            if( LoRaMacClassBIsAcquisitionInProgress( ) == false )
 80354e8:	f000 fa24 	bl	8035934 <LoRaMacClassBIsAcquisitionInProgress>
 80354ec:	4605      	mov	r5, r0
 80354ee:	b938      	cbnz	r0, 8035500 <LoRaMacMlmeRequest+0x1c4>
                LoRaMacClassBSetBeaconState( BEACON_STATE_ACQUISITION );
 80354f0:	f000 fa1d 	bl	803592e <LoRaMacClassBSetBeaconState>
                LoRaMacClassBBeaconTimerEvent( NULL );
 80354f4:	4628      	mov	r0, r5
 80354f6:	f000 fa1f 	bl	8035938 <LoRaMacClassBBeaconTimerEvent>
                status = LORAMAC_STATUS_OK;
 80354fa:	e798      	b.n	803542e <LoRaMacMlmeRequest+0xf2>
    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;
 80354fc:	2502      	movs	r5, #2
 80354fe:	e796      	b.n	803542e <LoRaMacMlmeRequest+0xf2>
                status = LORAMAC_STATUS_BUSY;
 8035500:	2501      	movs	r5, #1
 8035502:	e794      	b.n	803542e <LoRaMacMlmeRequest+0xf2>
        LoRaMacConfirmQueueAdd( &queueElement );
 8035504:	a801      	add	r0, sp, #4
 8035506:	f000 fb6f 	bl	8035be8 <LoRaMacConfirmQueueAdd>
 803550a:	e724      	b.n	8035356 <LoRaMacMlmeRequest+0x1a>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 803550c:	2503      	movs	r5, #3
 803550e:	e722      	b.n	8035356 <LoRaMacMlmeRequest+0x1a>
 8035510:	20004ef4 	.word	0x20004ef4
 8035514:	20004aa4 	.word	0x20004aa4
 8035518:	20004aaa 	.word	0x20004aaa
 803551c:	0803bbc0 	.word	0x0803bbc0

08035520 <LoRaMacMcpsRequest>:

/* ST_WORKAROUND_BEGIN: Update MCPS request with new input parameter to allow delayed tx */
LoRaMacStatus_t LoRaMacMcpsRequest( McpsReq_t* mcpsRequest, bool allowDelayedTx )
{
 8035520:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8035524:	b08f      	sub	sp, #60	; 0x3c
 8035526:	2600      	movs	r6, #0
 8035528:	9101      	str	r1, [sp, #4]
    /* ST_WORKAROUND_END */
    uint16_t fBufferSize;
    int8_t datarate = DR_0;
    bool readyToSend = false;

    if( mcpsRequest == NULL )
 803552a:	4605      	mov	r5, r0
 803552c:	b918      	cbnz	r0, 8035536 <LoRaMacMcpsRequest+0x16>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
 803552e:	2003      	movs	r0, #3

    // Fill return structure
    mcpsRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;

    return status;
}
 8035530:	b00f      	add	sp, #60	; 0x3c
 8035532:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( LoRaMacIsBusy( ) == true )
 8035536:	f7fe fc69 	bl	8033e0c <LoRaMacIsBusy>
 803553a:	4680      	mov	r8, r0
 803553c:	2800      	cmp	r0, #0
 803553e:	f040 815f 	bne.w	8035800 <LoRaMacMcpsRequest+0x2e0>
    memset1( ( uint8_t* ) &MacCtx.McpsConfirm, 0, sizeof( MacCtx.McpsConfirm ) );
 8035542:	4cb5      	ldr	r4, [pc, #724]	; (8035818 <LoRaMacMcpsRequest+0x2f8>)
 8035544:	4601      	mov	r1, r0
    macHdr.Value = 0;
 8035546:	4607      	mov	r7, r0
    memset1( ( uint8_t* ) &MacCtx.McpsConfirm, 0, sizeof( MacCtx.McpsConfirm ) );
 8035548:	2214      	movs	r2, #20
 803554a:	f204 403c 	addw	r0, r4, #1084	; 0x43c
 803554e:	f003 fccb 	bl	8038ee8 <memset1>
    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 8035552:	2101      	movs	r1, #1
 8035554:	f884 143d 	strb.w	r1, [r4, #1085]	; 0x43d
    MacCtx.AckTimeoutRetriesCounter = 1;
 8035558:	f884 1416 	strb.w	r1, [r4, #1046]	; 0x416
    switch( mcpsRequest->Type )
 803555c:	7828      	ldrb	r0, [r5, #0]
 803555e:	4288      	cmp	r0, r1
 8035560:	f000 80ac 	beq.w	80356bc <LoRaMacMcpsRequest+0x19c>
 8035564:	2803      	cmp	r0, #3
 8035566:	f000 80bb 	beq.w	80356e0 <LoRaMacMcpsRequest+0x1c0>
 803556a:	2800      	cmp	r0, #0
 803556c:	f040 80c5 	bne.w	80356fa <LoRaMacMcpsRequest+0x1da>
            MacCtx.AckTimeoutRetries = 1;
 8035570:	f884 1415 	strb.w	r1, [r4, #1045]	; 0x415
            macHdr.Bits.MType = FRAME_TYPE_DATA_UNCONFIRMED_UP;
 8035574:	2302      	movs	r3, #2
            fPort = mcpsRequest->Req.Unconfirmed.fPort;
 8035576:	f895 a004 	ldrb.w	sl, [r5, #4]
            fBuffer = mcpsRequest->Req.Unconfirmed.fBuffer;
 803557a:	f8d5 9008 	ldr.w	r9, [r5, #8]
            fBufferSize = mcpsRequest->Req.Unconfirmed.fBufferSize;
 803557e:	89ae      	ldrh	r6, [r5, #12]
            datarate = mcpsRequest->Req.Unconfirmed.Datarate;
 8035580:	f995 b00e 	ldrsb.w	fp, [r5, #14]
            macHdr.Bits.MType = FRAME_TYPE_DATA_UNCONFIRMED_UP;
 8035584:	f363 1747 	bfi	r7, r3, #5, #3
            readyToSend = true;
 8035588:	4688      	mov	r8, r1
    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 803558a:	f894 1580 	ldrb.w	r1, [r4, #1408]	; 0x580
 803558e:	f88d 101e 	strb.w	r1, [sp, #30]
    getPhy.Attribute = PHY_MIN_TX_DR;
 8035592:	2302      	movs	r3, #2
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8035594:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_MIN_TX_DR;
 8035598:	f88d 301c 	strb.w	r3, [sp, #28]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803559c:	a907      	add	r1, sp, #28
 803559e:	f001 f888 	bl	80366b2 <RegionGetPhyParam>
    if( readyToSend == true )
 80355a2:	2302      	movs	r3, #2
 80355a4:	f1b8 0f00 	cmp.w	r8, #0
 80355a8:	f000 8128 	beq.w	80357fc <LoRaMacMcpsRequest+0x2dc>
        if( Nvm.MacGroup2.AdrCtrlOn == false )
 80355ac:	f894 360a 	ldrb.w	r3, [r4, #1546]	; 0x60a
 80355b0:	b9ab      	cbnz	r3, 80355de <LoRaMacMcpsRequest+0xbe>
    datarate = MAX( datarate, ( int8_t )phyParam.Value );
 80355b2:	b240      	sxtb	r0, r0
 80355b4:	4558      	cmp	r0, fp
 80355b6:	bfb8      	it	lt
 80355b8:	4658      	movlt	r0, fp
            verify.DatarateParams.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 80355ba:	f894 3580 	ldrb.w	r3, [r4, #1408]	; 0x580
            verify.DatarateParams.Datarate = datarate;
 80355be:	f88d 000c 	strb.w	r0, [sp, #12]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_DR ) == true )
 80355c2:	2205      	movs	r2, #5
 80355c4:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
            verify.DatarateParams.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 80355c8:	f88d 300e 	strb.w	r3, [sp, #14]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_DR ) == true )
 80355cc:	a903      	add	r1, sp, #12
 80355ce:	f001 f896 	bl	80366fe <RegionVerify>
 80355d2:	2800      	cmp	r0, #0
 80355d4:	d0ab      	beq.n	803552e <LoRaMacMcpsRequest+0xe>
                Nvm.MacGroup1.ChannelsDatarate = verify.DatarateParams.Datarate;
 80355d6:	f89d 300c 	ldrb.w	r3, [sp, #12]
 80355da:	f884 3545 	strb.w	r3, [r4, #1349]	; 0x545
    int8_t txPower = Nvm.MacGroup1.ChannelsTxPower;
 80355de:	f8b4 2544 	ldrh.w	r2, [r4, #1348]	; 0x544
 80355e2:	f8b4 3544 	ldrh.w	r3, [r4, #1348]	; 0x544
 80355e6:	9200      	str	r2, [sp, #0]
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 80355e8:	f894 261c 	ldrb.w	r2, [r4, #1564]	; 0x61c
    uint32_t adrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 80355ec:	f8d4 1534 	ldr.w	r1, [r4, #1332]	; 0x534
 80355f0:	9104      	str	r1, [sp, #16]
 80355f2:	ba5b      	rev16	r3, r3
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 80355f4:	2a00      	cmp	r2, #0
 80355f6:	f000 80ff 	beq.w	80357f8 <LoRaMacMcpsRequest+0x2d8>
    if( Nvm.MacGroup2.MaxDCycle == 0 )
 80355fa:	f894 260b 	ldrb.w	r2, [r4, #1547]	; 0x60b
 80355fe:	b90a      	cbnz	r2, 8035604 <LoRaMacMcpsRequest+0xe4>
        Nvm.MacGroup1.AggregatedTimeOff = 0;
 8035600:	f8c4 253c 	str.w	r2, [r4, #1340]	; 0x53c
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 8035604:	f894 2608 	ldrb.w	r2, [r4, #1544]	; 0x608
    fCtrl.Bits.Adr           = Nvm.MacGroup2.AdrCtrlOn;
 8035608:	f894 060a 	ldrb.w	r0, [r4, #1546]	; 0x60a
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 803560c:	f102 3cff 	add.w	ip, r2, #4294967295
    fCtrl.Value = 0;
 8035610:	f04f 0800 	mov.w	r8, #0
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 8035614:	f1dc 0200 	rsbs	r2, ip, #0
 8035618:	eb42 020c 	adc.w	r2, r2, ip
    fCtrl.Bits.Adr           = Nvm.MacGroup2.AdrCtrlOn;
 803561c:	f360 18c7 	bfi	r8, r0, #7, #1
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 8035620:	f362 1804 	bfi	r8, r2, #4, #1
    if( Nvm.MacGroup1.SrvAckRequested == true )
 8035624:	f894 2546 	ldrb.w	r2, [r4, #1350]	; 0x546
 8035628:	b10a      	cbz	r2, 803562e <LoRaMacMcpsRequest+0x10e>
        fCtrl.Bits.Ack = 1;
 803562a:	f048 0820 	orr.w	r8, r8, #32
    adrNext.Version = Nvm.MacGroup2.Version;
 803562e:	f8d4 2618 	ldr.w	r2, [r4, #1560]	; 0x618
 8035632:	9209      	str	r2, [sp, #36]	; 0x24
    adrNext.AdrAckLimit = MacCtx.AdrAckLimit;
 8035634:	f8d4 23f8 	ldr.w	r2, [r4, #1016]	; 0x3f8
 8035638:	920c      	str	r2, [sp, #48]	; 0x30
    adrNext.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 803563a:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
    fCtrl.Bits.AdrAckReq = LoRaMacAdrCalcNext( &adrNext, &Nvm.MacGroup1.ChannelsDatarate,
 803563e:	4a77      	ldr	r2, [pc, #476]	; (803581c <LoRaMacMcpsRequest+0x2fc>)
    adrNext.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8035640:	f894 3580 	ldrb.w	r3, [r4, #1408]	; 0x580
 8035644:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    adrNext.UpdateChanMask = true;
 8035648:	f04f 0b01 	mov.w	fp, #1
    adrNext.Region = Nvm.MacGroup2.Region;
 803564c:	f894 354c 	ldrb.w	r3, [r4, #1356]	; 0x54c
    adrNext.AdrEnabled = fCtrl.Bits.Adr;
 8035650:	f88d 0029 	strb.w	r0, [sp, #41]	; 0x29
    adrNext.AdrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 8035654:	910b      	str	r1, [sp, #44]	; 0x2c
    adrNext.Region = Nvm.MacGroup2.Region;
 8035656:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    fCtrl.Bits.AdrAckReq = LoRaMacAdrCalcNext( &adrNext, &Nvm.MacGroup1.ChannelsDatarate,
 803565a:	eb02 010b 	add.w	r1, r2, fp
 803565e:	ab04      	add	r3, sp, #16
 8035660:	a809      	add	r0, sp, #36	; 0x24
    adrNext.UpdateChanMask = true;
 8035662:	f88d b028 	strb.w	fp, [sp, #40]	; 0x28
    fCtrl.Bits.AdrAckReq = LoRaMacAdrCalcNext( &adrNext, &Nvm.MacGroup1.ChannelsDatarate,
 8035666:	f000 f8f3 	bl	8035850 <LoRaMacAdrCalcNext>
    MacCtx.PktBufferLen = 0;
 803566a:	2300      	movs	r3, #0
        fBufferSize = 0;
 803566c:	4599      	cmp	r9, r3
 803566e:	bf08      	it	eq
 8035670:	461e      	moveq	r6, r3
    memcpy1( MacCtx.AppData, ( uint8_t* ) fBuffer, fBufferSize );
 8035672:	4632      	mov	r2, r6
    fCtrl.Bits.AdrAckReq = LoRaMacAdrCalcNext( &adrNext, &Nvm.MacGroup1.ChannelsDatarate,
 8035674:	f360 1886 	bfi	r8, r0, #6, #1
    memcpy1( MacCtx.AppData, ( uint8_t* ) fBuffer, fBufferSize );
 8035678:	4649      	mov	r1, r9
 803567a:	4869      	ldr	r0, [pc, #420]	; (8035820 <LoRaMacMcpsRequest+0x300>)
    MacCtx.PktBufferLen = 0;
 803567c:	80a3      	strh	r3, [r4, #4]
    size_t macCmdsSize = 0;
 803567e:	e9cd 3305 	strd	r3, r3, [sp, #20]
    MacCtx.NodeAckRequested = false;
 8035682:	f884 3418 	strb.w	r3, [r4, #1048]	; 0x418
    memcpy1( MacCtx.AppData, ( uint8_t* ) fBuffer, fBufferSize );
 8035686:	f003 fc1b 	bl	8038ec0 <memcpy1>
    MacCtx.PktBuffer[0] = macHdr->Value;
 803568a:	b2fb      	uxtb	r3, r7
 803568c:	71a7      	strb	r7, [r4, #6]
    switch( macHdr->Bits.MType )
 803568e:	f3c7 1742 	ubfx	r7, r7, #5, #3
    MacCtx.AppDataSize = fBufferSize;
 8035692:	b2f2      	uxtb	r2, r6
    switch( macHdr->Bits.MType )
 8035694:	2f04      	cmp	r7, #4
    MacCtx.AppDataSize = fBufferSize;
 8035696:	f884 223b 	strb.w	r2, [r4, #571]	; 0x23b
    switch( macHdr->Bits.MType )
 803569a:	d032      	beq.n	8035702 <LoRaMacMcpsRequest+0x1e2>
 803569c:	2f07      	cmp	r7, #7
 803569e:	f000 809b 	beq.w	80357d8 <LoRaMacMcpsRequest+0x2b8>
 80356a2:	2f02      	cmp	r7, #2
 80356a4:	d02f      	beq.n	8035706 <LoRaMacMcpsRequest+0x1e6>
            return LORAMAC_STATUS_SERVICE_UNKNOWN;
 80356a6:	2002      	movs	r0, #2
        Nvm.MacGroup1.ChannelsTxPower = txPower;
 80356a8:	9b00      	ldr	r3, [sp, #0]
 80356aa:	f8a4 3544 	strh.w	r3, [r4, #1348]	; 0x544
            MacCtx.NodeAckRequested = false;
 80356ae:	2300      	movs	r3, #0
 80356b0:	f884 3418 	strb.w	r3, [r4, #1048]	; 0x418
    mcpsRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;
 80356b4:	f8d4 3488 	ldr.w	r3, [r4, #1160]	; 0x488
 80356b8:	612b      	str	r3, [r5, #16]
    return status;
 80356ba:	e739      	b.n	8035530 <LoRaMacMcpsRequest+0x10>
            MacCtx.AckTimeoutRetries = MIN( mcpsRequest->Req.Confirmed.NbTrials, MAX_ACK_RETRIES );
 80356bc:	7beb      	ldrb	r3, [r5, #15]
 80356be:	2b08      	cmp	r3, #8
 80356c0:	bf28      	it	cs
 80356c2:	2308      	movcs	r3, #8
 80356c4:	f884 3415 	strb.w	r3, [r4, #1045]	; 0x415
            macHdr.Bits.MType = FRAME_TYPE_DATA_CONFIRMED_UP;
 80356c8:	2304      	movs	r3, #4
            fPort = mcpsRequest->Req.Confirmed.fPort;
 80356ca:	f895 a004 	ldrb.w	sl, [r5, #4]
            fBuffer = mcpsRequest->Req.Confirmed.fBuffer;
 80356ce:	f8d5 9008 	ldr.w	r9, [r5, #8]
            fBufferSize = mcpsRequest->Req.Confirmed.fBufferSize;
 80356d2:	89ae      	ldrh	r6, [r5, #12]
            datarate = mcpsRequest->Req.Confirmed.Datarate;
 80356d4:	f995 b00e 	ldrsb.w	fp, [r5, #14]
            macHdr.Bits.MType = FRAME_TYPE_DATA_CONFIRMED_UP;
 80356d8:	f363 1747 	bfi	r7, r3, #5, #3
            readyToSend = true;
 80356dc:	4680      	mov	r8, r0
            break;
 80356de:	e754      	b.n	803558a <LoRaMacMcpsRequest+0x6a>
            MacCtx.AckTimeoutRetries = 1;
 80356e0:	f884 1415 	strb.w	r1, [r4, #1045]	; 0x415
            fBuffer = mcpsRequest->Req.Proprietary.fBuffer;
 80356e4:	f8d5 9004 	ldr.w	r9, [r5, #4]
            fBufferSize = mcpsRequest->Req.Proprietary.fBufferSize;
 80356e8:	892e      	ldrh	r6, [r5, #8]
            datarate = mcpsRequest->Req.Proprietary.Datarate;
 80356ea:	f995 b00a 	ldrsb.w	fp, [r5, #10]
            macHdr.Bits.MType = FRAME_TYPE_PROPRIETARY;
 80356ee:	f067 071f 	orn	r7, r7, #31
            readyToSend = true;
 80356f2:	4688      	mov	r8, r1
    uint8_t fPort = 0;
 80356f4:	f04f 0a00 	mov.w	sl, #0
            break;
 80356f8:	e747      	b.n	803558a <LoRaMacMcpsRequest+0x6a>
    switch( mcpsRequest->Type )
 80356fa:	46c3      	mov	fp, r8
 80356fc:	46c1      	mov	r9, r8
 80356fe:	46c2      	mov	sl, r8
 8035700:	e743      	b.n	803558a <LoRaMacMcpsRequest+0x6a>
            MacCtx.NodeAckRequested = true;
 8035702:	f884 b418 	strb.w	fp, [r4, #1048]	; 0x418
            MacCtx.TxMsg.Message.Data.Buffer = MacCtx.PktBuffer;
 8035706:	4f47      	ldr	r7, [pc, #284]	; (8035824 <LoRaMacMcpsRequest+0x304>)
            MacCtx.TxMsg.Message.Data.MHDR.Value = macHdr->Value;
 8035708:	f884 3111 	strb.w	r3, [r4, #273]	; 0x111
            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_DATA;
 803570c:	2104      	movs	r1, #4
            MacCtx.TxMsg.Message.Data.FHDR.DevAddr = Nvm.MacGroup2.DevAddr;
 803570e:	f8d4 35d8 	ldr.w	r3, [r4, #1496]	; 0x5d8
            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_DATA;
 8035712:	f884 1108 	strb.w	r1, [r4, #264]	; 0x108
            MacCtx.TxMsg.Message.Data.FHDR.DevAddr = Nvm.MacGroup2.DevAddr;
 8035716:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
            MacCtx.TxMsg.Message.Data.BufSize = LORAMAC_PHY_MAXPAYLOAD;
 803571a:	21ff      	movs	r1, #255	; 0xff
            MacCtx.TxMsg.Message.Data.FRMPayload = MacCtx.AppData;
 803571c:	f507 739b 	add.w	r3, r7, #310	; 0x136
            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetFCntUp( &fCntUp ) )
 8035720:	a805      	add	r0, sp, #20
            MacCtx.TxMsg.Message.Data.Buffer = MacCtx.PktBuffer;
 8035722:	f8c4 710c 	str.w	r7, [r4, #268]	; 0x10c
            MacCtx.TxMsg.Message.Data.BufSize = LORAMAC_PHY_MAXPAYLOAD;
 8035726:	f884 1110 	strb.w	r1, [r4, #272]	; 0x110
            MacCtx.TxMsg.Message.Data.FPort = fPort;
 803572a:	f884 a12c 	strb.w	sl, [r4, #300]	; 0x12c
            MacCtx.TxMsg.Message.Data.FHDR.FCtrl.Value = fCtrl->Value;
 803572e:	f884 8118 	strb.w	r8, [r4, #280]	; 0x118
            MacCtx.TxMsg.Message.Data.FRMPayloadSize = MacCtx.AppDataSize;
 8035732:	f884 2134 	strb.w	r2, [r4, #308]	; 0x134
            MacCtx.TxMsg.Message.Data.FRMPayload = MacCtx.AppData;
 8035736:	f8c4 3130 	str.w	r3, [r4, #304]	; 0x130
            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetFCntUp( &fCntUp ) )
 803573a:	f000 fc2b 	bl	8035f94 <LoRaMacCryptoGetFCntUp>
 803573e:	2800      	cmp	r0, #0
 8035740:	d158      	bne.n	80357f4 <LoRaMacMcpsRequest+0x2d4>
            MacCtx.TxMsg.Message.Data.FHDR.FCnt = ( uint16_t )fCntUp;
 8035742:	9b05      	ldr	r3, [sp, #20]
            MacCtx.McpsConfirm.AckReceived = false;
 8035744:	f8a4 0440 	strh.w	r0, [r4, #1088]	; 0x440
            if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )
 8035748:	a806      	add	r0, sp, #24
            MacCtx.TxMsg.Message.Data.FHDR.FCnt = ( uint16_t )fCntUp;
 803574a:	f8a4 311a 	strh.w	r3, [r4, #282]	; 0x11a
            MacCtx.McpsConfirm.UpLinkCounter = fCntUp;
 803574e:	f8c4 3448 	str.w	r3, [r4, #1096]	; 0x448
            if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )
 8035752:	f000 f9bb 	bl	8035acc <LoRaMacCommandsGetSizeSerializedCmds>
 8035756:	bb68      	cbnz	r0, 80357b4 <LoRaMacMcpsRequest+0x294>
            if( macCmdsSize > 0 )
 8035758:	9b06      	ldr	r3, [sp, #24]
 803575a:	b1ab      	cbz	r3, 8035788 <LoRaMacMcpsRequest+0x268>
                availableSize = GetMaxAppPayloadWithoutFOptsLength( Nvm.MacGroup1.ChannelsDatarate );
 803575c:	f994 0545 	ldrsb.w	r0, [r4, #1349]	; 0x545
 8035760:	f7fd fc2a 	bl	8032fb8 <GetMaxAppPayloadWithoutFOptsLength>
                if( ( MacCtx.AppDataSize > 0 ) && ( macCmdsSize <= LORA_MAC_COMMAND_MAX_FOPTS_LENGTH ) )
 8035764:	f894 323b 	ldrb.w	r3, [r4, #571]	; 0x23b
 8035768:	b333      	cbz	r3, 80357b8 <LoRaMacMcpsRequest+0x298>
 803576a:	9b06      	ldr	r3, [sp, #24]
 803576c:	2b0f      	cmp	r3, #15
 803576e:	d81a      	bhi.n	80357a6 <LoRaMacMcpsRequest+0x286>
                    if( LoRaMacCommandsSerializeCmds( LORA_MAC_COMMAND_MAX_FOPTS_LENGTH, &macCmdsSize, MacCtx.TxMsg.Message.Data.FHDR.FOpts ) != LORAMAC_COMMANDS_SUCCESS )
 8035770:	f507 728b 	add.w	r2, r7, #278	; 0x116
 8035774:	a906      	add	r1, sp, #24
 8035776:	200f      	movs	r0, #15
 8035778:	f000 f9b4 	bl	8035ae4 <LoRaMacCommandsSerializeCmds>
 803577c:	b9d0      	cbnz	r0, 80357b4 <LoRaMacMcpsRequest+0x294>
                    fCtrl->Bits.FOptsLen = macCmdsSize;
 803577e:	9b06      	ldr	r3, [sp, #24]
 8035780:	f363 0803 	bfi	r8, r3, #0, #4
                    MacCtx.TxMsg.Message.Data.FHDR.FCtrl.Value = fCtrl->Value;
 8035784:	f884 8118 	strb.w	r8, [r4, #280]	; 0x118
        status = ScheduleTx( allowDelayedTx ); /* ST_WORKAROUND: Update Send request with new input parameter to allow delayed tx */
 8035788:	9801      	ldr	r0, [sp, #4]
 803578a:	f7fd fde7 	bl	803335c <ScheduleTx>
    if( status != LORAMAC_STATUS_OK )
 803578e:	2800      	cmp	r0, #0
 8035790:	d18a      	bne.n	80356a8 <LoRaMacMcpsRequest+0x188>
        Nvm.MacGroup1.AdrAckCounter = adrAckCounter;
 8035792:	9b04      	ldr	r3, [sp, #16]
        Nvm.MacGroup1.SrvAckRequested = false;
 8035794:	f884 0546 	strb.w	r0, [r4, #1350]	; 0x546
        Nvm.MacGroup1.AdrAckCounter = adrAckCounter;
 8035798:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
        if( LoRaMacCommandsRemoveNoneStickyCmds( ) != LORAMAC_COMMANDS_SUCCESS )
 803579c:	f000 f976 	bl	8035a8c <LoRaMacCommandsRemoveNoneStickyCmds>
 80357a0:	b380      	cbz	r0, 8035804 <LoRaMacMcpsRequest+0x2e4>
            return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 80357a2:	2013      	movs	r0, #19
 80357a4:	e783      	b.n	80356ae <LoRaMacMcpsRequest+0x18e>
                    if( LoRaMacCommandsSerializeCmds( availableSize, &macCmdsSize, MacCtx.MacCommandsBuffer ) != LORAMAC_COMMANDS_SUCCESS )
 80357a6:	f207 4286 	addw	r2, r7, #1158	; 0x486
 80357aa:	a906      	add	r1, sp, #24
 80357ac:	f000 f99a 	bl	8035ae4 <LoRaMacCommandsSerializeCmds>
 80357b0:	2800      	cmp	r0, #0
 80357b2:	d0e9      	beq.n	8035788 <LoRaMacMcpsRequest+0x268>
                        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 80357b4:	2013      	movs	r0, #19
 80357b6:	e777      	b.n	80356a8 <LoRaMacMcpsRequest+0x188>
                    if( LoRaMacCommandsSerializeCmds( availableSize, &macCmdsSize, MacCtx.MacCommandsBuffer ) != LORAMAC_COMMANDS_SUCCESS )
 80357b8:	f207 4786 	addw	r7, r7, #1158	; 0x486
 80357bc:	463a      	mov	r2, r7
 80357be:	a906      	add	r1, sp, #24
 80357c0:	f000 f990 	bl	8035ae4 <LoRaMacCommandsSerializeCmds>
 80357c4:	2800      	cmp	r0, #0
 80357c6:	d1f5      	bne.n	80357b4 <LoRaMacMcpsRequest+0x294>
                    MacCtx.TxMsg.Message.Data.FRMPayloadSize = macCmdsSize;
 80357c8:	9b06      	ldr	r3, [sp, #24]
                    MacCtx.TxMsg.Message.Data.FPort = 0;
 80357ca:	f884 012c 	strb.w	r0, [r4, #300]	; 0x12c
                    MacCtx.TxMsg.Message.Data.FRMPayload = MacCtx.MacCommandsBuffer;
 80357ce:	f8c4 7130 	str.w	r7, [r4, #304]	; 0x130
                    MacCtx.TxMsg.Message.Data.FRMPayloadSize = macCmdsSize;
 80357d2:	f884 3134 	strb.w	r3, [r4, #308]	; 0x134
    if( ( status == LORAMAC_STATUS_OK ) || ( status == LORAMAC_STATUS_SKIPPED_APP_DATA ) )
 80357d6:	e7d7      	b.n	8035788 <LoRaMacMcpsRequest+0x268>
            if( ( fBuffer != NULL ) && ( MacCtx.AppDataSize > 0 ) )
 80357d8:	f1b9 0f00 	cmp.w	r9, #0
 80357dc:	d0d4      	beq.n	8035788 <LoRaMacMcpsRequest+0x268>
 80357de:	2a00      	cmp	r2, #0
 80357e0:	d0d2      	beq.n	8035788 <LoRaMacMcpsRequest+0x268>
                memcpy1( MacCtx.PktBuffer + LORAMAC_MHDR_FIELD_SIZE, ( uint8_t* ) fBuffer, MacCtx.AppDataSize );
 80357e2:	4811      	ldr	r0, [pc, #68]	; (8035828 <LoRaMacMcpsRequest+0x308>)
 80357e4:	4649      	mov	r1, r9
 80357e6:	f003 fb6b 	bl	8038ec0 <memcpy1>
                MacCtx.PktBufferLen = LORAMAC_MHDR_FIELD_SIZE + MacCtx.AppDataSize;
 80357ea:	f894 323b 	ldrb.w	r3, [r4, #571]	; 0x23b
 80357ee:	3301      	adds	r3, #1
 80357f0:	80a3      	strh	r3, [r4, #4]
    if( ( status == LORAMAC_STATUS_OK ) || ( status == LORAMAC_STATUS_SKIPPED_APP_DATA ) )
 80357f2:	e7c9      	b.n	8035788 <LoRaMacMcpsRequest+0x268>
                return LORAMAC_STATUS_FCNT_HANDLER_ERROR;
 80357f4:	2012      	movs	r0, #18
 80357f6:	e757      	b.n	80356a8 <LoRaMacMcpsRequest+0x188>
        return LORAMAC_STATUS_NO_NETWORK_JOINED;
 80357f8:	2007      	movs	r0, #7
 80357fa:	e758      	b.n	80356ae <LoRaMacMcpsRequest+0x18e>
    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;
 80357fc:	4618      	mov	r0, r3
 80357fe:	e759      	b.n	80356b4 <LoRaMacMcpsRequest+0x194>
        return LORAMAC_STATUS_BUSY;
 8035800:	2001      	movs	r0, #1
 8035802:	e695      	b.n	8035530 <LoRaMacMcpsRequest+0x10>
            MacCtx.McpsConfirm.McpsRequest = mcpsRequest->Type;
 8035804:	782b      	ldrb	r3, [r5, #0]
 8035806:	f884 343c 	strb.w	r3, [r4, #1084]	; 0x43c
            MacCtx.MacFlags.Bits.McpsReq = 1;
 803580a:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 803580e:	f043 0301 	orr.w	r3, r3, #1
 8035812:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
 8035816:	e74d      	b.n	80356b4 <LoRaMacMcpsRequest+0x194>
 8035818:	20004aa4 	.word	0x20004aa4
 803581c:	20004fe8 	.word	0x20004fe8
 8035820:	20004be0 	.word	0x20004be0
 8035824:	20004aaa 	.word	0x20004aaa
 8035828:	20004aab 	.word	0x20004aab

0803582c <LoRaMacTestSetDutyCycleOn>:
/* ST_WORKAROUND_END */

void LoRaMacTestSetDutyCycleOn( bool enable )
{
 803582c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    VerifyParams_t verify;

    verify.DutyCycle = enable;

    if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DUTY_CYCLE ) == true )
 803582e:	4d07      	ldr	r5, [pc, #28]	; (803584c <LoRaMacTestSetDutyCycleOn+0x20>)
    verify.DutyCycle = enable;
 8035830:	f88d 0004 	strb.w	r0, [sp, #4]
{
 8035834:	4604      	mov	r4, r0
    if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DUTY_CYCLE ) == true )
 8035836:	220f      	movs	r2, #15
 8035838:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
 803583c:	a901      	add	r1, sp, #4
 803583e:	f000 ff5e 	bl	80366fe <RegionVerify>
 8035842:	b108      	cbz	r0, 8035848 <LoRaMacTestSetDutyCycleOn+0x1c>
    {
        Nvm.MacGroup2.DutyCycleOn = enable;
 8035844:	f885 460c 	strb.w	r4, [r5, #1548]	; 0x60c
    }
}
 8035848:	b003      	add	sp, #12
 803584a:	bd30      	pop	{r4, r5, pc}
 803584c:	20004aa4 	.word	0x20004aa4

08035850 <LoRaMacAdrCalcNext>:
 * \param [OUT] adrAckCounter The calculated ADR acknowledgement counter.
 *
 * \retval Returns true, if an ADR request should be performed.
 */
bool LoRaMacAdrCalcNext( CalcNextAdrParams_t* adrNext, int8_t* drOut, int8_t* txPowOut, uint32_t* adrAckCounter )
{
 8035850:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if( adrNext->Version.Fields.Minor == 0 )
 8035854:	f890 9002 	ldrb.w	r9, [r0, #2]
{
 8035858:	b08b      	sub	sp, #44	; 0x2c
 803585a:	4604      	mov	r4, r0
 803585c:	468a      	mov	sl, r1
 803585e:	9201      	str	r2, [sp, #4]
    if( adrNext->Version.Fields.Minor == 0 )
 8035860:	f1b9 0f00 	cmp.w	r9, #0
 8035864:	d160      	bne.n	8035928 <LoRaMacAdrCalcNext+0xd8>
    if( adrNext->AdrEnabled == true )
 8035866:	7945      	ldrb	r5, [r0, #5]
    *adrAckCounter = adrNext->AdrAckCounter;
 8035868:	6881      	ldr	r1, [r0, #8]
    int8_t datarate = adrNext->Datarate;
 803586a:	f990 2010 	ldrsb.w	r2, [r0, #16]
    int8_t txPower = adrNext->TxPower;
 803586e:	f990 8011 	ldrsb.w	r8, [r0, #17]
    *adrAckCounter = adrNext->AdrAckCounter;
 8035872:	6019      	str	r1, [r3, #0]
    if( adrNext->AdrEnabled == true )
 8035874:	2d00      	cmp	r5, #0
 8035876:	d055      	beq.n	8035924 <LoRaMacAdrCalcNext+0xd4>
        getPhy.UplinkDwellTime = adrNext->UplinkDwellTime;
 8035878:	7c81      	ldrb	r1, [r0, #18]
 803587a:	f88d 1016 	strb.w	r1, [sp, #22]
        phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 803587e:	7cc0      	ldrb	r0, [r0, #19]
        getPhy.Attribute = PHY_MIN_TX_DR;
 8035880:	f04f 0b02 	mov.w	fp, #2
        phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 8035884:	a905      	add	r1, sp, #20
 8035886:	e9cd 2302 	strd	r2, r3, [sp, #8]
        getPhy.Attribute = PHY_MIN_TX_DR;
 803588a:	f88d b014 	strb.w	fp, [sp, #20]
        phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 803588e:	f000 ff10 	bl	80366b2 <RegionGetPhyParam>
        datarate = MAX( datarate, minTxDatarate );
 8035892:	9a02      	ldr	r2, [sp, #8]
        minTxDatarate = phyParam.Value;
 8035894:	b247      	sxtb	r7, r0
        datarate = MAX( datarate, minTxDatarate );
 8035896:	42ba      	cmp	r2, r7
 8035898:	4616      	mov	r6, r2
 803589a:	bfb8      	it	lt
 803589c:	463e      	movlt	r6, r7
        if( datarate == minTxDatarate )
 803589e:	42ba      	cmp	r2, r7
 80358a0:	dc0c      	bgt.n	80358bc <LoRaMacAdrCalcNext+0x6c>
            *adrAckCounter = 0;
 80358a2:	9b03      	ldr	r3, [sp, #12]
 80358a4:	f8c3 9000 	str.w	r9, [r3]
                        adrAckReq = false;
 80358a8:	464d      	mov	r5, r9
    *txPowOut = txPower;
 80358aa:	9b01      	ldr	r3, [sp, #4]
    *drOut = datarate;
 80358ac:	f88a 6000 	strb.w	r6, [sl]
    *txPowOut = txPower;
 80358b0:	f883 8000 	strb.w	r8, [r3]
    {
        return CalcNextV10X( adrNext, drOut, txPowOut, adrAckCounter );
    }
    return false;
}
 80358b4:	4628      	mov	r0, r5
 80358b6:	b00b      	add	sp, #44	; 0x2c
 80358b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            if( adrNext->AdrAckCounter >=  adrNext->AdrAckLimit )
 80358bc:	68a2      	ldr	r2, [r4, #8]
 80358be:	89a1      	ldrh	r1, [r4, #12]
            if( adrNext->AdrAckCounter >= ( adrNext->AdrAckLimit + adrNext->AdrAckDelay ) )
 80358c0:	89e3      	ldrh	r3, [r4, #14]
            if( adrNext->AdrAckCounter >=  adrNext->AdrAckLimit )
 80358c2:	428a      	cmp	r2, r1
            if( adrNext->AdrAckCounter >= ( adrNext->AdrAckLimit + adrNext->AdrAckDelay ) )
 80358c4:	440b      	add	r3, r1
            if( adrNext->AdrAckCounter >=  adrNext->AdrAckLimit )
 80358c6:	bf34      	ite	cc
 80358c8:	2500      	movcc	r5, #0
 80358ca:	2501      	movcs	r5, #1
            if( adrNext->AdrAckCounter >= ( adrNext->AdrAckLimit + adrNext->AdrAckDelay ) )
 80358cc:	429a      	cmp	r2, r3
 80358ce:	d3ec      	bcc.n	80358aa <LoRaMacAdrCalcNext+0x5a>
                getPhy.Attribute = PHY_MAX_TX_POWER;
 80358d0:	2308      	movs	r3, #8
                phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 80358d2:	a905      	add	r1, sp, #20
 80358d4:	7ce0      	ldrb	r0, [r4, #19]
                getPhy.Attribute = PHY_MAX_TX_POWER;
 80358d6:	f88d 3014 	strb.w	r3, [sp, #20]
                phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 80358da:	f000 feea 	bl	80366b2 <RegionGetPhyParam>
                if( ( adrNext->AdrAckCounter % adrNext->AdrAckDelay ) == 1 )
 80358de:	89e2      	ldrh	r2, [r4, #14]
 80358e0:	68a1      	ldr	r1, [r4, #8]
 80358e2:	fbb1 f3f2 	udiv	r3, r1, r2
 80358e6:	fb02 1313 	mls	r3, r2, r3, r1
 80358ea:	2b01      	cmp	r3, #1
                txPower = phyParam.Value;
 80358ec:	fa4f f880 	sxtb.w	r8, r0
                if( ( adrNext->AdrAckCounter % adrNext->AdrAckDelay ) == 1 )
 80358f0:	d1db      	bne.n	80358aa <LoRaMacAdrCalcNext+0x5a>
                    getPhy.Attribute = PHY_NEXT_LOWER_TX_DR;
 80358f2:	2322      	movs	r3, #34	; 0x22
 80358f4:	f88d 3014 	strb.w	r3, [sp, #20]
                    phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 80358f8:	7ce0      	ldrb	r0, [r4, #19]
                    getPhy.UplinkDwellTime = adrNext->UplinkDwellTime;
 80358fa:	7ca3      	ldrb	r3, [r4, #18]
                    getPhy.Datarate = datarate;
 80358fc:	f88d 6015 	strb.w	r6, [sp, #21]
                    phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 8035900:	a905      	add	r1, sp, #20
                    getPhy.UplinkDwellTime = adrNext->UplinkDwellTime;
 8035902:	f88d 3016 	strb.w	r3, [sp, #22]
                    phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 8035906:	f000 fed4 	bl	80366b2 <RegionGetPhyParam>
                    datarate = phyParam.Value;
 803590a:	b246      	sxtb	r6, r0
                    if( datarate == minTxDatarate )
 803590c:	42b7      	cmp	r7, r6
 803590e:	d1cc      	bne.n	80358aa <LoRaMacAdrCalcNext+0x5a>
                        if( adrNext->UpdateChanMask == true )
 8035910:	7925      	ldrb	r5, [r4, #4]
 8035912:	2d00      	cmp	r5, #0
 8035914:	d0c9      	beq.n	80358aa <LoRaMacAdrCalcNext+0x5a>
                            RegionInitDefaults( adrNext->Region, &params );
 8035916:	7ce0      	ldrb	r0, [r4, #19]
                            params.Type = INIT_TYPE_ACTIVATE_DEFAULT_CHANNELS;
 8035918:	f88d b024 	strb.w	fp, [sp, #36]	; 0x24
                            RegionInitDefaults( adrNext->Region, &params );
 803591c:	a907      	add	r1, sp, #28
 803591e:	f000 fee3 	bl	80366e8 <RegionInitDefaults>
 8035922:	e7c1      	b.n	80358a8 <LoRaMacAdrCalcNext+0x58>
    int8_t datarate = adrNext->Datarate;
 8035924:	4616      	mov	r6, r2
 8035926:	e7c0      	b.n	80358aa <LoRaMacAdrCalcNext+0x5a>
    return false;
 8035928:	2500      	movs	r5, #0
 803592a:	e7c3      	b.n	80358b4 <LoRaMacAdrCalcNext+0x64>

0803592c <LoRaMacClassBInit>:
    TimerInit( &Ctx.PingSlotTimer, LoRaMacClassBPingSlotTimerEvent );
    TimerInit( &Ctx.MulticastSlotTimer, LoRaMacClassBMulticastSlotTimerEvent );

    InitClassB( );
#endif /* LORAMAC_CLASSB_ENABLED */
}
 803592c:	4770      	bx	lr

0803592e <LoRaMacClassBSetBeaconState>:
        {
            Ctx.BeaconState = beaconState;
        }
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 803592e:	4770      	bx	lr

08035930 <LoRaMacClassBSetPingSlotState>:
 8035930:	4770      	bx	lr

08035932 <LoRaMacClassBSetMulticastSlotState>:
 8035932:	4770      	bx	lr

08035934 <LoRaMacClassBIsAcquisitionInProgress>:
    }
    return false;
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 8035934:	2000      	movs	r0, #0
 8035936:	4770      	bx	lr

08035938 <LoRaMacClassBBeaconTimerEvent>:
    if( Ctx.LoRaMacClassBCallbacks.MacProcessNotify != NULL )
    {
        Ctx.LoRaMacClassBCallbacks.MacProcessNotify( );
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 8035938:	4770      	bx	lr

0803593a <LoRaMacClassBPingSlotTimerEvent>:
 803593a:	4770      	bx	lr

0803593c <LoRaMacClassBMulticastSlotTimerEvent>:
 803593c:	4770      	bx	lr

0803593e <LoRaMacClassBRxBeacon>:
    }
    return beaconProcessed;
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 803593e:	2000      	movs	r0, #0
 8035940:	4770      	bx	lr

08035942 <LoRaMacClassBIsBeaconExpected>:
 8035942:	2000      	movs	r0, #0
 8035944:	4770      	bx	lr

08035946 <LoRaMacClassBIsPingExpected>:
 8035946:	2000      	movs	r0, #0
 8035948:	4770      	bx	lr

0803594a <LoRaMacClassBIsMulticastExpected>:
 803594a:	2000      	movs	r0, #0
 803594c:	4770      	bx	lr

0803594e <LoRaMacClassBIsBeaconModeActive>:
 803594e:	2000      	movs	r0, #0
 8035950:	4770      	bx	lr

08035952 <LoRaMacClassBSetPingSlotInfo>:
 8035952:	4770      	bx	lr

08035954 <LoRaMacClassBHaltBeaconing>:

        // Halt ping and multicast slot state machines
        LoRaMacClassBStopRxSlots( );
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 8035954:	4770      	bx	lr

08035956 <LoRaMacClassBResumeBeaconing>:
 8035956:	4770      	bx	lr

08035958 <LoRaMacClassBSwitchClass>:
    }
    return LORAMAC_STATUS_SERVICE_UNKNOWN;
#else
    return LORAMAC_STATUS_SERVICE_UNKNOWN;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 8035958:	2002      	movs	r0, #2
 803595a:	4770      	bx	lr

0803595c <LoRaMacClassBMibGetRequestConfirm>:
    }
    return status;
#else
    return LORAMAC_STATUS_SERVICE_UNKNOWN;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 803595c:	2002      	movs	r0, #2
 803595e:	4770      	bx	lr

08035960 <LoRaMacMibClassBSetRequestConfirm>:
 8035960:	2002      	movs	r0, #2
 8035962:	4770      	bx	lr

08035964 <LoRaMacClassBPingSlotInfoAns>:
 8035964:	4770      	bx	lr

08035966 <LoRaMacClassBPingSlotChannelReq>:

    return status;
#else
    return 0;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 8035966:	2000      	movs	r0, #0
 8035968:	4770      	bx	lr

0803596a <LoRaMacClassBBeaconTimingAns>:

        Ctx.LoRaMacClassBParams.MlmeConfirm->BeaconTimingDelay = Ctx.BeaconCtx.BeaconTimingDelay;
        Ctx.LoRaMacClassBParams.MlmeConfirm->BeaconTimingChannel = Ctx.BeaconCtx.BeaconTimingChannel;
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 803596a:	4770      	bx	lr

0803596c <LoRaMacClassBDeviceTimeAns>:
 803596c:	4770      	bx	lr

0803596e <LoRaMacClassBBeaconFreqReq>:
    }
    return false;
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 803596e:	2000      	movs	r0, #0
 8035970:	4770      	bx	lr

08035972 <LoRaMacClassBIsUplinkCollision>:
    }
    return 0;
#else
    return 0;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 8035972:	2000      	movs	r0, #0
 8035974:	4770      	bx	lr

08035976 <LoRaMacClassBStopRxSlots>:
 8035976:	4770      	bx	lr

08035978 <LoRaMacClassBSetMulticastPeriodicity>:
 8035978:	4770      	bx	lr

0803597a <LoRaMacClassBProcess>:
 803597a:	4770      	bx	lr

0803597c <LoRaMacCommandsInit>:
            return false;
    }
}

LoRaMacCommandStatus_t LoRaMacCommandsInit( void )
{
 803597c:	b510      	push	{r4, lr}
    // Initialize with default
    memset1( ( uint8_t* )&CommandsCtx, 0, sizeof( CommandsCtx ) );
 803597e:	4c05      	ldr	r4, [pc, #20]	; (8035994 <LoRaMacCommandsInit+0x18>)
 8035980:	22fc      	movs	r2, #252	; 0xfc
 8035982:	4620      	mov	r0, r4
 8035984:	2100      	movs	r1, #0
 8035986:	f003 faaf 	bl	8038ee8 <memset1>
    list->First = NULL;
 803598a:	2000      	movs	r0, #0
    list->Last = NULL;
 803598c:	e9c4 0000 	strd	r0, r0, [r4]

    LinkedListInit( &CommandsCtx.MacCommandList );

    return LORAMAC_COMMANDS_SUCCESS;
}
 8035990:	bd10      	pop	{r4, pc}
 8035992:	bf00      	nop
 8035994:	20005604 	.word	0x20005604

08035998 <LoRaMacCommandsAddCmd>:

LoRaMacCommandStatus_t LoRaMacCommandsAddCmd( uint8_t cid, uint8_t* payload, size_t payloadSize )
{
 8035998:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 803599c:	4680      	mov	r8, r0
 803599e:	4616      	mov	r6, r2
    if( payload == NULL )
 80359a0:	2900      	cmp	r1, #0
 80359a2:	d03d      	beq.n	8035a20 <LoRaMacCommandsAddCmd+0x88>
 80359a4:	4c22      	ldr	r4, [pc, #136]	; (8035a30 <LoRaMacCommandsAddCmd+0x98>)
 80359a6:	2300      	movs	r3, #0
    while( IsSlotFree( ( const MacCommand_t* )&CommandsCtx.MacCommandSlots[itr] ) == false )
 80359a8:	1c65      	adds	r5, r4, #1
 80359aa:	4622      	mov	r2, r4
 80359ac:	0118      	lsls	r0, r3, #4
 80359ae:	3410      	adds	r4, #16
        if( mem[size] != 0x00 )
 80359b0:	f812 7f01 	ldrb.w	r7, [r2, #1]!
 80359b4:	bbb7      	cbnz	r7, 8035a24 <LoRaMacCommandsAddCmd+0x8c>
    for( uint16_t size = 0; size < sizeof( MacCommand_t ); size++ )
 80359b6:	42a2      	cmp	r2, r4
 80359b8:	d1fa      	bne.n	80359b0 <LoRaMacCommandsAddCmd+0x18>
    if( list->First == NULL )
 80359ba:	4c1e      	ldr	r4, [pc, #120]	; (8035a34 <LoRaMacCommandsAddCmd+0x9c>)
 80359bc:	6822      	ldr	r2, [r4, #0]
 80359be:	b902      	cbnz	r2, 80359c2 <LoRaMacCommandsAddCmd+0x2a>
        list->First = element;
 80359c0:	6025      	str	r5, [r4, #0]
    if( list->Last )
 80359c2:	6862      	ldr	r2, [r4, #4]
 80359c4:	b102      	cbz	r2, 80359c8 <LoRaMacCommandsAddCmd+0x30>
        list->Last->Next = element;
 80359c6:	6015      	str	r5, [r2, #0]
    list->Last = element;
 80359c8:	6065      	str	r5, [r4, #4]
        return LORAMAC_COMMANDS_ERROR;
    }

    // Set Values
    newCmd->CID = cid;
    newCmd->PayloadSize = payloadSize;
 80359ca:	1c5d      	adds	r5, r3, #1
    element->Next = NULL;
 80359cc:	1822      	adds	r2, r4, r0
    newCmd->PayloadSize = payloadSize;
 80359ce:	012b      	lsls	r3, r5, #4
    element->Next = NULL;
 80359d0:	f04f 0c00 	mov.w	ip, #0
    memcpy1( ( uint8_t* )newCmd->Payload, payload, payloadSize );
 80359d4:	300d      	adds	r0, #13
    element->Next = NULL;
 80359d6:	f8c2 c008 	str.w	ip, [r2, #8]
    newCmd->CID = cid;
 80359da:	f882 800c 	strb.w	r8, [r2, #12]
    newCmd->PayloadSize = payloadSize;
 80359de:	50e6      	str	r6, [r4, r3]
    memcpy1( ( uint8_t* )newCmd->Payload, payload, payloadSize );
 80359e0:	b2b2      	uxth	r2, r6
 80359e2:	4420      	add	r0, r4
 80359e4:	f003 fa6c 	bl	8038ec0 <memcpy1>
    switch( cid )
 80359e8:	f1b8 0f05 	cmp.w	r8, #5
 80359ec:	d015      	beq.n	8035a1a <LoRaMacCommandsAddCmd+0x82>
 80359ee:	f1a8 0808 	sub.w	r8, r8, #8
 80359f2:	f1b8 0f02 	cmp.w	r8, #2
 80359f6:	bf8c      	ite	hi
 80359f8:	f04f 0800 	movhi.w	r8, #0
 80359fc:	f04f 0801 	movls.w	r8, #1
    newCmd->IsSticky = IsSticky( cid );
 8035a00:	eb04 1305 	add.w	r3, r4, r5, lsl #4
 8035a04:	f883 8004 	strb.w	r8, [r3, #4]

    CommandsCtx.SerializedCmdsSize += ( CID_FIELD_SIZE + payloadSize );
 8035a08:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
 8035a0c:	3301      	adds	r3, #1
 8035a0e:	4433      	add	r3, r6
 8035a10:	f8c4 30f8 	str.w	r3, [r4, #248]	; 0xf8

    return LORAMAC_COMMANDS_SUCCESS;
}
 8035a14:	4638      	mov	r0, r7
 8035a16:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            return true;
 8035a1a:	f04f 0801 	mov.w	r8, #1
 8035a1e:	e7ef      	b.n	8035a00 <LoRaMacCommandsAddCmd+0x68>
        return LORAMAC_COMMANDS_ERROR_NPE;
 8035a20:	2701      	movs	r7, #1
 8035a22:	e7f7      	b.n	8035a14 <LoRaMacCommandsAddCmd+0x7c>
        if( itr == NUM_OF_MAC_COMMANDS )
 8035a24:	3301      	adds	r3, #1
 8035a26:	2b0f      	cmp	r3, #15
 8035a28:	d1be      	bne.n	80359a8 <LoRaMacCommandsAddCmd+0x10>
        return LORAMAC_COMMANDS_ERROR_MEMORY;
 8035a2a:	2702      	movs	r7, #2
 8035a2c:	e7f2      	b.n	8035a14 <LoRaMacCommandsAddCmd+0x7c>
 8035a2e:	bf00      	nop
 8035a30:	2000560b 	.word	0x2000560b
 8035a34:	20005604 	.word	0x20005604

08035a38 <LoRaMacCommandsRemoveCmd>:

LoRaMacCommandStatus_t LoRaMacCommandsRemoveCmd( MacCommand_t* macCmd )
{
 8035a38:	b510      	push	{r4, lr}
    if( macCmd == NULL )
 8035a3a:	b310      	cbz	r0, 8035a82 <LoRaMacCommandsRemoveCmd+0x4a>
    curElement = list->First;
 8035a3c:	4b12      	ldr	r3, [pc, #72]	; (8035a88 <LoRaMacCommandsRemoveCmd+0x50>)
 8035a3e:	681a      	ldr	r2, [r3, #0]
    if( element != curElement )
 8035a40:	4290      	cmp	r0, r2
 8035a42:	d104      	bne.n	8035a4e <LoRaMacCommandsRemoveCmd+0x16>
        list->First = element->Next;
 8035a44:	6802      	ldr	r2, [r0, #0]
 8035a46:	601a      	str	r2, [r3, #0]
 8035a48:	2200      	movs	r2, #0
 8035a4a:	e004      	b.n	8035a56 <LoRaMacCommandsRemoveCmd+0x1e>
 8035a4c:	460a      	mov	r2, r1
        while( ( curElement != NULL ) && ( curElement->Next != element ) )
 8035a4e:	b112      	cbz	r2, 8035a56 <LoRaMacCommandsRemoveCmd+0x1e>
 8035a50:	6811      	ldr	r1, [r2, #0]
 8035a52:	4288      	cmp	r0, r1
 8035a54:	d1fa      	bne.n	8035a4c <LoRaMacCommandsRemoveCmd+0x14>
    if( list->Last == element )
 8035a56:	6859      	ldr	r1, [r3, #4]
 8035a58:	4288      	cmp	r0, r1
        list->Last = PrevElement;
 8035a5a:	bf08      	it	eq
 8035a5c:	605a      	streq	r2, [r3, #4]
    if( PrevElement != NULL )
 8035a5e:	b10a      	cbz	r2, 8035a64 <LoRaMacCommandsRemoveCmd+0x2c>
        PrevElement->Next = element->Next;
 8035a60:	6801      	ldr	r1, [r0, #0]
 8035a62:	6011      	str	r1, [r2, #0]
    if( LinkedListRemove( &CommandsCtx.MacCommandList, macCmd ) == false )
    {
        return LORAMAC_COMMANDS_ERROR_CMD_NOT_FOUND;
    }

    CommandsCtx.SerializedCmdsSize -= ( CID_FIELD_SIZE + macCmd->PayloadSize );
 8035a64:	f8d3 20f8 	ldr.w	r2, [r3, #248]	; 0xf8
 8035a68:	6881      	ldr	r1, [r0, #8]
 8035a6a:	3a01      	subs	r2, #1
    element->Next = NULL;
 8035a6c:	2400      	movs	r4, #0
    CommandsCtx.SerializedCmdsSize -= ( CID_FIELD_SIZE + macCmd->PayloadSize );
 8035a6e:	1a52      	subs	r2, r2, r1
    element->Next = NULL;
 8035a70:	6004      	str	r4, [r0, #0]
    memset1( ( uint8_t* )slot, 0x00, sizeof( MacCommand_t ) );
 8035a72:	4621      	mov	r1, r4
    CommandsCtx.SerializedCmdsSize -= ( CID_FIELD_SIZE + macCmd->PayloadSize );
 8035a74:	f8c3 20f8 	str.w	r2, [r3, #248]	; 0xf8
    memset1( ( uint8_t* )slot, 0x00, sizeof( MacCommand_t ) );
 8035a78:	2210      	movs	r2, #16
 8035a7a:	f003 fa35 	bl	8038ee8 <memset1>
    return true;
 8035a7e:	4620      	mov	r0, r4
    {
        return LORAMAC_COMMANDS_ERROR;
    }

    return LORAMAC_COMMANDS_SUCCESS;
}
 8035a80:	bd10      	pop	{r4, pc}
        return LORAMAC_COMMANDS_ERROR_NPE;
 8035a82:	2001      	movs	r0, #1
 8035a84:	e7fc      	b.n	8035a80 <LoRaMacCommandsRemoveCmd+0x48>
 8035a86:	bf00      	nop
 8035a88:	20005604 	.word	0x20005604

08035a8c <LoRaMacCommandsRemoveNoneStickyCmds>:
    }
    return LORAMAC_COMMANDS_SUCCESS;
}

LoRaMacCommandStatus_t LoRaMacCommandsRemoveNoneStickyCmds( void )
{
 8035a8c:	b510      	push	{r4, lr}
    MacCommand_t* curElement;
    MacCommand_t* nexElement;

    // Start at the head of the list
    curElement = CommandsCtx.MacCommandList.First;
 8035a8e:	4b05      	ldr	r3, [pc, #20]	; (8035aa4 <LoRaMacCommandsRemoveNoneStickyCmds+0x18>)
 8035a90:	6818      	ldr	r0, [r3, #0]

    // Loop through all elements
    while( curElement != NULL )
 8035a92:	b900      	cbnz	r0, 8035a96 <LoRaMacCommandsRemoveNoneStickyCmds+0xa>
            curElement = curElement->Next;
        }
    }

    return LORAMAC_COMMANDS_SUCCESS;
}
 8035a94:	bd10      	pop	{r4, pc}
        if( curElement->IsSticky == false )
 8035a96:	7b03      	ldrb	r3, [r0, #12]
 8035a98:	6804      	ldr	r4, [r0, #0]
 8035a9a:	b90b      	cbnz	r3, 8035aa0 <LoRaMacCommandsRemoveNoneStickyCmds+0x14>
            LoRaMacCommandsRemoveCmd( curElement );
 8035a9c:	f7ff ffcc 	bl	8035a38 <LoRaMacCommandsRemoveCmd>
{
 8035aa0:	4620      	mov	r0, r4
 8035aa2:	e7f6      	b.n	8035a92 <LoRaMacCommandsRemoveNoneStickyCmds+0x6>
 8035aa4:	20005604 	.word	0x20005604

08035aa8 <LoRaMacCommandsRemoveStickyAnsCmds>:

LoRaMacCommandStatus_t LoRaMacCommandsRemoveStickyAnsCmds( void )
{
 8035aa8:	b510      	push	{r4, lr}
    MacCommand_t* curElement;
    MacCommand_t* nexElement;

    // Start at the head of the list
    curElement = CommandsCtx.MacCommandList.First;
 8035aaa:	4b07      	ldr	r3, [pc, #28]	; (8035ac8 <LoRaMacCommandsRemoveStickyAnsCmds+0x20>)
 8035aac:	6818      	ldr	r0, [r3, #0]

    // Loop through all elements
    while( curElement != NULL )
 8035aae:	b900      	cbnz	r0, 8035ab2 <LoRaMacCommandsRemoveStickyAnsCmds+0xa>
        }
        curElement = nexElement;
    }

    return LORAMAC_COMMANDS_SUCCESS;
}
 8035ab0:	bd10      	pop	{r4, pc}
        if( IsSticky( curElement->CID ) == true )
 8035ab2:	7903      	ldrb	r3, [r0, #4]
        nexElement = curElement->Next;
 8035ab4:	6804      	ldr	r4, [r0, #0]
    switch( cid )
 8035ab6:	2b05      	cmp	r3, #5
 8035ab8:	d002      	beq.n	8035ac0 <LoRaMacCommandsRemoveStickyAnsCmds+0x18>
 8035aba:	3b08      	subs	r3, #8
 8035abc:	2b02      	cmp	r3, #2
 8035abe:	d801      	bhi.n	8035ac4 <LoRaMacCommandsRemoveStickyAnsCmds+0x1c>
            LoRaMacCommandsRemoveCmd( curElement );
 8035ac0:	f7ff ffba 	bl	8035a38 <LoRaMacCommandsRemoveCmd>
{
 8035ac4:	4620      	mov	r0, r4
 8035ac6:	e7f2      	b.n	8035aae <LoRaMacCommandsRemoveStickyAnsCmds+0x6>
 8035ac8:	20005604 	.word	0x20005604

08035acc <LoRaMacCommandsGetSizeSerializedCmds>:

LoRaMacCommandStatus_t LoRaMacCommandsGetSizeSerializedCmds( size_t* size )
{
    if( size == NULL )
 8035acc:	b128      	cbz	r0, 8035ada <LoRaMacCommandsGetSizeSerializedCmds+0xe>
    {
        return LORAMAC_COMMANDS_ERROR_NPE;
    }
    *size = CommandsCtx.SerializedCmdsSize;
 8035ace:	4b04      	ldr	r3, [pc, #16]	; (8035ae0 <LoRaMacCommandsGetSizeSerializedCmds+0x14>)
 8035ad0:	f8d3 30f8 	ldr.w	r3, [r3, #248]	; 0xf8
 8035ad4:	6003      	str	r3, [r0, #0]
    return LORAMAC_COMMANDS_SUCCESS;
 8035ad6:	2000      	movs	r0, #0
 8035ad8:	4770      	bx	lr
        return LORAMAC_COMMANDS_ERROR_NPE;
 8035ada:	2001      	movs	r0, #1
}
 8035adc:	4770      	bx	lr
 8035ade:	bf00      	nop
 8035ae0:	20005604 	.word	0x20005604

08035ae4 <LoRaMacCommandsSerializeCmds>:

LoRaMacCommandStatus_t LoRaMacCommandsSerializeCmds( size_t availableSize, size_t* effectiveSize, uint8_t* buffer )
{
 8035ae4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8035ae8:	4607      	mov	r7, r0
 8035aea:	460e      	mov	r6, r1
    MacCommand_t* curElement = CommandsCtx.MacCommandList.First;
    MacCommand_t* nextElement;
    uint8_t itr = 0;

    if( ( buffer == NULL ) || ( effectiveSize == NULL ) )
 8035aec:	4615      	mov	r5, r2
 8035aee:	b332      	cbz	r2, 8035b3e <LoRaMacCommandsSerializeCmds+0x5a>
 8035af0:	b329      	cbz	r1, 8035b3e <LoRaMacCommandsSerializeCmds+0x5a>
    MacCommand_t* curElement = CommandsCtx.MacCommandList.First;
 8035af2:	4b14      	ldr	r3, [pc, #80]	; (8035b44 <LoRaMacCommandsSerializeCmds+0x60>)
 8035af4:	681c      	ldr	r4, [r3, #0]
    uint8_t itr = 0;
 8035af6:	2300      	movs	r3, #0
    {
        return LORAMAC_COMMANDS_ERROR_NPE;
    }

    // Loop through all elements which fits into the buffer
    while( curElement != NULL )
 8035af8:	b92c      	cbnz	r4, 8035b06 <LoRaMacCommandsSerializeCmds+0x22>
        LoRaMacCommandsRemoveCmd( curElement );
        curElement = nextElement;
    }

    // Fetch the effective size of the mac commands
    LoRaMacCommandsGetSizeSerializedCmds( effectiveSize );
 8035afa:	4630      	mov	r0, r6
 8035afc:	f7ff ffe6 	bl	8035acc <LoRaMacCommandsGetSizeSerializedCmds>

    return LORAMAC_COMMANDS_SUCCESS;
 8035b00:	2000      	movs	r0, #0
}
 8035b02:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if( ( availableSize - itr ) >= ( CID_FIELD_SIZE + curElement->PayloadSize ) )
 8035b06:	68a2      	ldr	r2, [r4, #8]
 8035b08:	1af9      	subs	r1, r7, r3
 8035b0a:	3201      	adds	r2, #1
 8035b0c:	4291      	cmp	r1, r2
 8035b0e:	d30f      	bcc.n	8035b30 <LoRaMacCommandsSerializeCmds+0x4c>
            buffer[itr++] = curElement->CID;
 8035b10:	7922      	ldrb	r2, [r4, #4]
 8035b12:	54ea      	strb	r2, [r5, r3]
 8035b14:	1c58      	adds	r0, r3, #1
            memcpy1( &buffer[itr], curElement->Payload, curElement->PayloadSize );
 8035b16:	8922      	ldrh	r2, [r4, #8]
            buffer[itr++] = curElement->CID;
 8035b18:	fa5f f880 	uxtb.w	r8, r0
            memcpy1( &buffer[itr], curElement->Payload, curElement->PayloadSize );
 8035b1c:	1d61      	adds	r1, r4, #5
 8035b1e:	fa55 f080 	uxtab	r0, r5, r0
 8035b22:	f003 f9cd 	bl	8038ec0 <memcpy1>
            itr += curElement->PayloadSize;
 8035b26:	68a3      	ldr	r3, [r4, #8]
        curElement = curElement->Next;
 8035b28:	6824      	ldr	r4, [r4, #0]
            itr += curElement->PayloadSize;
 8035b2a:	4443      	add	r3, r8
 8035b2c:	b2db      	uxtb	r3, r3
        curElement = curElement->Next;
 8035b2e:	e7e3      	b.n	8035af8 <LoRaMacCommandsSerializeCmds+0x14>
        nextElement = curElement->Next;
 8035b30:	4620      	mov	r0, r4
 8035b32:	6824      	ldr	r4, [r4, #0]
        LoRaMacCommandsRemoveCmd( curElement );
 8035b34:	f7ff ff80 	bl	8035a38 <LoRaMacCommandsRemoveCmd>
    while( curElement != NULL )
 8035b38:	2c00      	cmp	r4, #0
 8035b3a:	d1f9      	bne.n	8035b30 <LoRaMacCommandsSerializeCmds+0x4c>
 8035b3c:	e7dd      	b.n	8035afa <LoRaMacCommandsSerializeCmds+0x16>
        return LORAMAC_COMMANDS_ERROR_NPE;
 8035b3e:	2001      	movs	r0, #1
 8035b40:	e7df      	b.n	8035b02 <LoRaMacCommandsSerializeCmds+0x1e>
 8035b42:	bf00      	nop
 8035b44:	20005604 	.word	0x20005604

08035b48 <LoRaMacCommandsStickyCmdsPending>:

LoRaMacCommandStatus_t LoRaMacCommandsStickyCmdsPending( bool* cmdsPending )
{
    if( cmdsPending == NULL )
 8035b48:	4603      	mov	r3, r0
 8035b4a:	b168      	cbz	r0, 8035b68 <LoRaMacCommandsStickyCmdsPending+0x20>
    {
        return LORAMAC_COMMANDS_ERROR_NPE;
    }
    MacCommand_t* curElement;
    curElement = CommandsCtx.MacCommandList.First;
 8035b4c:	4a07      	ldr	r2, [pc, #28]	; (8035b6c <LoRaMacCommandsStickyCmdsPending+0x24>)
 8035b4e:	6810      	ldr	r0, [r2, #0]

    *cmdsPending = false;
 8035b50:	2200      	movs	r2, #0
 8035b52:	701a      	strb	r2, [r3, #0]

    // Loop through all elements
    while( curElement != NULL )
 8035b54:	b900      	cbnz	r0, 8035b58 <LoRaMacCommandsStickyCmdsPending+0x10>
 8035b56:	4770      	bx	lr
    {
        if( curElement->IsSticky == true )
 8035b58:	7b02      	ldrb	r2, [r0, #12]
 8035b5a:	b11a      	cbz	r2, 8035b64 <LoRaMacCommandsStickyCmdsPending+0x1c>
        {
            // Found one sticky MAC command
            *cmdsPending = true;
 8035b5c:	2201      	movs	r2, #1
 8035b5e:	701a      	strb	r2, [r3, #0]
            return LORAMAC_COMMANDS_SUCCESS;
 8035b60:	2000      	movs	r0, #0
 8035b62:	4770      	bx	lr
        }
        curElement = curElement->Next;
 8035b64:	6800      	ldr	r0, [r0, #0]
 8035b66:	e7f5      	b.n	8035b54 <LoRaMacCommandsStickyCmdsPending+0xc>
        return LORAMAC_COMMANDS_ERROR_NPE;
 8035b68:	2001      	movs	r0, #1
    }

    return LORAMAC_COMMANDS_SUCCESS;
}
 8035b6a:	4770      	bx	lr
 8035b6c:	20005604 	.word	0x20005604

08035b70 <LoRaMacCommandsGetCmdSize>:
uint8_t LoRaMacCommandsGetCmdSize( uint8_t cid )
{
    uint8_t cidSize = 0;

    // Decode Frame MAC commands
    switch( cid )
 8035b70:	3802      	subs	r0, #2
 8035b72:	b2c0      	uxtb	r0, r0
 8035b74:	2811      	cmp	r0, #17
 8035b76:	bf9a      	itte	ls
 8035b78:	4b01      	ldrls	r3, [pc, #4]	; (8035b80 <LoRaMacCommandsGetCmdSize+0x10>)
 8035b7a:	5c18      	ldrbls	r0, [r3, r0]
{
 8035b7c:	2000      	movhi	r0, #0
            // Unknown command. ABORT MAC commands processing
            break;
        }
    }
    return cidSize;
}
 8035b7e:	4770      	bx	lr
 8035b80:	0803ba5a 	.word	0x0803ba5a

08035b84 <GetElement.isra.0>:
        return true;
    }
    return false;
}

static MlmeConfirmQueue_t* GetElement( Mlme_t request, MlmeConfirmQueue_t* bufferStart, MlmeConfirmQueue_t* bufferEnd )
 8035b84:	b530      	push	{r4, r5, lr}
{
    MlmeConfirmQueue_t* element = bufferStart;

    if( IsListEmpty( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == true )
 8035b86:	4b0c      	ldr	r3, [pc, #48]	; (8035bb8 <GetElement.isra.0+0x34>)
 8035b88:	f893 2020 	ldrb.w	r2, [r3, #32]
static MlmeConfirmQueue_t* GetElement( Mlme_t request, MlmeConfirmQueue_t* bufferStart, MlmeConfirmQueue_t* bufferEnd )
 8035b8c:	4604      	mov	r4, r0
 8035b8e:	4608      	mov	r0, r1
    if( count == 0 )
 8035b90:	b17a      	cbz	r2, 8035bb2 <GetElement.isra.0+0x2e>
 8035b92:	2100      	movs	r1, #0
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 8035b94:	331c      	adds	r3, #28
    {
        return NULL;
    }

    for( uint8_t elementCnt = 0; elementCnt < ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt; elementCnt++ )
 8035b96:	b2cd      	uxtb	r5, r1
 8035b98:	42aa      	cmp	r2, r5
 8035b9a:	d801      	bhi.n	8035ba0 <GetElement.isra.0+0x1c>
        return NULL;
 8035b9c:	2000      	movs	r0, #0
        }
        element = IncreaseBufferPointer( element );
    }

    return NULL;
}
 8035b9e:	bd30      	pop	{r4, r5, pc}
        if( element->Request == request )
 8035ba0:	7805      	ldrb	r5, [r0, #0]
 8035ba2:	42a5      	cmp	r5, r4
 8035ba4:	d0fb      	beq.n	8035b9e <GetElement.isra.0+0x1a>
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 8035ba6:	4298      	cmp	r0, r3
        bufferPointer = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 8035ba8:	bf0c      	ite	eq
 8035baa:	4804      	ldreq	r0, [pc, #16]	; (8035bbc <GetElement.isra.0+0x38>)
        bufferPointer++;
 8035bac:	3004      	addne	r0, #4
    for( uint8_t elementCnt = 0; elementCnt < ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt; elementCnt++ )
 8035bae:	3101      	adds	r1, #1
 8035bb0:	e7f1      	b.n	8035b96 <GetElement.isra.0+0x12>
        return NULL;
 8035bb2:	4610      	mov	r0, r2
 8035bb4:	e7f3      	b.n	8035b9e <GetElement.isra.0+0x1a>
 8035bb6:	bf00      	nop
 8035bb8:	20005700 	.word	0x20005700
 8035bbc:	2000570c 	.word	0x2000570c

08035bc0 <LoRaMacConfirmQueueInit>:

void LoRaMacConfirmQueueInit( LoRaMacPrimitives_t* primitives )
{
 8035bc0:	b510      	push	{r4, lr}
    ConfirmQueueCtx.Primitives = primitives;
 8035bc2:	4c08      	ldr	r4, [pc, #32]	; (8035be4 <LoRaMacConfirmQueueInit+0x24>)

    // Init counter
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt = 0;
 8035bc4:	2300      	movs	r3, #0
    ConfirmQueueCtx.Primitives = primitives;
 8035bc6:	6020      	str	r0, [r4, #0]

    // Init buffer
    ConfirmQueueCtx.BufferStart = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
    ConfirmQueueCtx.BufferEnd = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;

    memset1( ( uint8_t* )ConfirmQueueCtx.Nvm.MlmeConfirmQueue, 0xFF, sizeof( ConfirmQueueCtx.Nvm.MlmeConfirmQueue ) );
 8035bc8:	2214      	movs	r2, #20
    ConfirmQueueCtx.BufferStart = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 8035bca:	f104 000c 	add.w	r0, r4, #12
    memset1( ( uint8_t* )ConfirmQueueCtx.Nvm.MlmeConfirmQueue, 0xFF, sizeof( ConfirmQueueCtx.Nvm.MlmeConfirmQueue ) );
 8035bce:	21ff      	movs	r1, #255	; 0xff
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt = 0;
 8035bd0:	f884 3020 	strb.w	r3, [r4, #32]
    ConfirmQueueCtx.BufferEnd = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 8035bd4:	e9c4 0001 	strd	r0, r0, [r4, #4]
    memset1( ( uint8_t* )ConfirmQueueCtx.Nvm.MlmeConfirmQueue, 0xFF, sizeof( ConfirmQueueCtx.Nvm.MlmeConfirmQueue ) );
 8035bd8:	f003 f986 	bl	8038ee8 <memset1>

    // Common status
    ConfirmQueueCtx.Nvm.CommonStatus = LORAMAC_EVENT_INFO_STATUS_ERROR;
 8035bdc:	2301      	movs	r3, #1
 8035bde:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
}
 8035be2:	bd10      	pop	{r4, pc}
 8035be4:	20005700 	.word	0x20005700

08035be8 <LoRaMacConfirmQueueAdd>:

bool LoRaMacConfirmQueueAdd( MlmeConfirmQueue_t* mlmeConfirm )
{
    if( IsListFull( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == true )
 8035be8:	4b0f      	ldr	r3, [pc, #60]	; (8035c28 <LoRaMacConfirmQueueAdd+0x40>)
    if( count >= LORA_MAC_MLME_CONFIRM_QUEUE_LEN )
 8035bea:	f893 2020 	ldrb.w	r2, [r3, #32]
 8035bee:	2a04      	cmp	r2, #4
 8035bf0:	d817      	bhi.n	8035c22 <LoRaMacConfirmQueueAdd+0x3a>
        // Protect the buffer against overwrites
        return false;
    }

    // Add the element to the ring buffer
    ConfirmQueueCtx.BufferEnd->Request = mlmeConfirm->Request;
 8035bf2:	689a      	ldr	r2, [r3, #8]
 8035bf4:	7801      	ldrb	r1, [r0, #0]
 8035bf6:	7011      	strb	r1, [r2, #0]
    ConfirmQueueCtx.BufferEnd->Status = mlmeConfirm->Status;
 8035bf8:	7841      	ldrb	r1, [r0, #1]
 8035bfa:	7051      	strb	r1, [r2, #1]
    ConfirmQueueCtx.BufferEnd->RestrictCommonReadyToHandle = mlmeConfirm->RestrictCommonReadyToHandle;
 8035bfc:	78c1      	ldrb	r1, [r0, #3]
 8035bfe:	70d1      	strb	r1, [r2, #3]
    ConfirmQueueCtx.BufferEnd->ReadyToHandle = false;
 8035c00:	2100      	movs	r1, #0
 8035c02:	7091      	strb	r1, [r2, #2]
    // Increase counter
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt++;
 8035c04:	f893 1020 	ldrb.w	r1, [r3, #32]
 8035c08:	3101      	adds	r1, #1
 8035c0a:	f883 1020 	strb.w	r1, [r3, #32]
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 8035c0e:	f103 011c 	add.w	r1, r3, #28
 8035c12:	428a      	cmp	r2, r1
        bufferPointer++;
 8035c14:	bf14      	ite	ne
 8035c16:	3204      	addne	r2, #4
        bufferPointer = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 8035c18:	f103 020c 	addeq.w	r2, r3, #12
    // Update end pointer
    ConfirmQueueCtx.BufferEnd = IncreaseBufferPointer( ConfirmQueueCtx.BufferEnd );
 8035c1c:	609a      	str	r2, [r3, #8]
 8035c1e:	2001      	movs	r0, #1
 8035c20:	4770      	bx	lr
        return false;
 8035c22:	2000      	movs	r0, #0

    return true;
}
 8035c24:	4770      	bx	lr
 8035c26:	bf00      	nop
 8035c28:	20005700 	.word	0x20005700

08035c2c <LoRaMacConfirmQueueRemoveFirst>:
    return true;
}

bool LoRaMacConfirmQueueRemoveFirst( void )
{
    if( IsListEmpty( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == true )
 8035c2c:	4b09      	ldr	r3, [pc, #36]	; (8035c54 <LoRaMacConfirmQueueRemoveFirst+0x28>)
 8035c2e:	f893 0020 	ldrb.w	r0, [r3, #32]
    if( count == 0 )
 8035c32:	b168      	cbz	r0, 8035c50 <LoRaMacConfirmQueueRemoveFirst+0x24>
    }

    // Increase counter
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt--;
    // Update start pointer
    ConfirmQueueCtx.BufferStart = IncreaseBufferPointer( ConfirmQueueCtx.BufferStart );
 8035c34:	685a      	ldr	r2, [r3, #4]
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 8035c36:	f103 011c 	add.w	r1, r3, #28
 8035c3a:	428a      	cmp	r2, r1
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt--;
 8035c3c:	f100 30ff 	add.w	r0, r0, #4294967295
        bufferPointer++;
 8035c40:	bf14      	ite	ne
 8035c42:	3204      	addne	r2, #4
        bufferPointer = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 8035c44:	f103 020c 	addeq.w	r2, r3, #12
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt--;
 8035c48:	f883 0020 	strb.w	r0, [r3, #32]
    ConfirmQueueCtx.BufferStart = IncreaseBufferPointer( ConfirmQueueCtx.BufferStart );
 8035c4c:	605a      	str	r2, [r3, #4]

    return true;
 8035c4e:	2001      	movs	r0, #1
}
 8035c50:	4770      	bx	lr
 8035c52:	bf00      	nop
 8035c54:	20005700 	.word	0x20005700

08035c58 <LoRaMacConfirmQueueSetStatus>:

void LoRaMacConfirmQueueSetStatus( LoRaMacEventInfoStatus_t status, Mlme_t request )
{
 8035c58:	b510      	push	{r4, lr}
    MlmeConfirmQueue_t* element = NULL;

    if( IsListEmpty( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == false )
 8035c5a:	4b07      	ldr	r3, [pc, #28]	; (8035c78 <LoRaMacConfirmQueueSetStatus+0x20>)
    if( count == 0 )
 8035c5c:	f893 2020 	ldrb.w	r2, [r3, #32]
{
 8035c60:	4604      	mov	r4, r0
 8035c62:	4608      	mov	r0, r1
    if( count == 0 )
 8035c64:	b132      	cbz	r2, 8035c74 <LoRaMacConfirmQueueSetStatus+0x1c>
    {
        element = GetElement( request, ConfirmQueueCtx.BufferStart, ConfirmQueueCtx.BufferEnd );
 8035c66:	6859      	ldr	r1, [r3, #4]
 8035c68:	f7ff ff8c 	bl	8035b84 <GetElement.isra.0>
        if( element != NULL )
 8035c6c:	b110      	cbz	r0, 8035c74 <LoRaMacConfirmQueueSetStatus+0x1c>
        {
            element->Status = status;
            element->ReadyToHandle = true;
 8035c6e:	2301      	movs	r3, #1
            element->Status = status;
 8035c70:	7044      	strb	r4, [r0, #1]
            element->ReadyToHandle = true;
 8035c72:	7083      	strb	r3, [r0, #2]
        }
    }
}
 8035c74:	bd10      	pop	{r4, pc}
 8035c76:	bf00      	nop
 8035c78:	20005700 	.word	0x20005700

08035c7c <LoRaMacConfirmQueueGetStatus>:

LoRaMacEventInfoStatus_t LoRaMacConfirmQueueGetStatus( Mlme_t request )
{
 8035c7c:	b508      	push	{r3, lr}
    MlmeConfirmQueue_t* element = NULL;

    if( IsListEmpty( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == false )
 8035c7e:	4b06      	ldr	r3, [pc, #24]	; (8035c98 <LoRaMacConfirmQueueGetStatus+0x1c>)
    if( count == 0 )
 8035c80:	f893 2020 	ldrb.w	r2, [r3, #32]
 8035c84:	b12a      	cbz	r2, 8035c92 <LoRaMacConfirmQueueGetStatus+0x16>
    {
        element = GetElement( request, ConfirmQueueCtx.BufferStart, ConfirmQueueCtx.BufferEnd );
 8035c86:	6859      	ldr	r1, [r3, #4]
 8035c88:	f7ff ff7c 	bl	8035b84 <GetElement.isra.0>
        if( element != NULL )
 8035c8c:	b108      	cbz	r0, 8035c92 <LoRaMacConfirmQueueGetStatus+0x16>
        {
            return element->Status;
 8035c8e:	7840      	ldrb	r0, [r0, #1]
        }
    }
    return LORAMAC_EVENT_INFO_STATUS_ERROR;
}
 8035c90:	bd08      	pop	{r3, pc}
    return LORAMAC_EVENT_INFO_STATUS_ERROR;
 8035c92:	2001      	movs	r0, #1
 8035c94:	e7fc      	b.n	8035c90 <LoRaMacConfirmQueueGetStatus+0x14>
 8035c96:	bf00      	nop
 8035c98:	20005700 	.word	0x20005700

08035c9c <LoRaMacConfirmQueueSetStatusCmn>:

void LoRaMacConfirmQueueSetStatusCmn( LoRaMacEventInfoStatus_t status )
{
 8035c9c:	b530      	push	{r4, r5, lr}
    MlmeConfirmQueue_t* element = ConfirmQueueCtx.BufferStart;
 8035c9e:	4a0a      	ldr	r2, [pc, #40]	; (8035cc8 <LoRaMacConfirmQueueSetStatusCmn+0x2c>)
    if( count == 0 )
 8035ca0:	f892 1020 	ldrb.w	r1, [r2, #32]
    MlmeConfirmQueue_t* element = ConfirmQueueCtx.BufferStart;
 8035ca4:	6853      	ldr	r3, [r2, #4]

    ConfirmQueueCtx.Nvm.CommonStatus = status;
 8035ca6:	f882 0021 	strb.w	r0, [r2, #33]	; 0x21
    if( count == 0 )
 8035caa:	b161      	cbz	r1, 8035cc6 <LoRaMacConfirmQueueSetStatusCmn+0x2a>
            if( element->RestrictCommonReadyToHandle == false )
            {
                element->ReadyToHandle = true;
            }
            element = IncreaseBufferPointer( element );
        }while( element != ConfirmQueueCtx.BufferEnd );
 8035cac:	6891      	ldr	r1, [r2, #8]
                element->ReadyToHandle = true;
 8035cae:	2401      	movs	r4, #1
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 8035cb0:	321c      	adds	r2, #28
            if( element->RestrictCommonReadyToHandle == false )
 8035cb2:	78dd      	ldrb	r5, [r3, #3]
            element->Status = status;
 8035cb4:	7058      	strb	r0, [r3, #1]
            if( element->RestrictCommonReadyToHandle == false )
 8035cb6:	b905      	cbnz	r5, 8035cba <LoRaMacConfirmQueueSetStatusCmn+0x1e>
                element->ReadyToHandle = true;
 8035cb8:	709c      	strb	r4, [r3, #2]
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 8035cba:	4293      	cmp	r3, r2
        bufferPointer = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 8035cbc:	bf0c      	ite	eq
 8035cbe:	4b03      	ldreq	r3, [pc, #12]	; (8035ccc <LoRaMacConfirmQueueSetStatusCmn+0x30>)
        bufferPointer++;
 8035cc0:	3304      	addne	r3, #4
        }while( element != ConfirmQueueCtx.BufferEnd );
 8035cc2:	4299      	cmp	r1, r3
 8035cc4:	d1f5      	bne.n	8035cb2 <LoRaMacConfirmQueueSetStatusCmn+0x16>
    }
}
 8035cc6:	bd30      	pop	{r4, r5, pc}
 8035cc8:	20005700 	.word	0x20005700
 8035ccc:	2000570c 	.word	0x2000570c

08035cd0 <LoRaMacConfirmQueueIsCmdActive>:
{
    return ConfirmQueueCtx.Nvm.CommonStatus;
}

bool LoRaMacConfirmQueueIsCmdActive( Mlme_t request )
{
 8035cd0:	b508      	push	{r3, lr}
    if( GetElement( request, ConfirmQueueCtx.BufferStart, ConfirmQueueCtx.BufferEnd ) != NULL )
 8035cd2:	4b04      	ldr	r3, [pc, #16]	; (8035ce4 <LoRaMacConfirmQueueIsCmdActive+0x14>)
 8035cd4:	6859      	ldr	r1, [r3, #4]
 8035cd6:	f7ff ff55 	bl	8035b84 <GetElement.isra.0>
    {
        return true;
    }
    return false;
}
 8035cda:	3800      	subs	r0, #0
 8035cdc:	bf18      	it	ne
 8035cde:	2001      	movne	r0, #1
 8035ce0:	bd08      	pop	{r3, pc}
 8035ce2:	bf00      	nop
 8035ce4:	20005700 	.word	0x20005700

08035ce8 <LoRaMacConfirmQueueHandleCb>:

void LoRaMacConfirmQueueHandleCb( MlmeConfirm_t* mlmeConfirm )
{
 8035ce8:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    uint8_t nbElements = ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt;
 8035cec:	4d12      	ldr	r5, [pc, #72]	; (8035d38 <LoRaMacConfirmQueueHandleCb+0x50>)
 8035cee:	f895 8020 	ldrb.w	r8, [r5, #32]
{
 8035cf2:	4604      	mov	r4, r0
    bool readyToHandle = false;
    MlmeConfirmQueue_t mlmeConfirmToStore;

    for( uint8_t i = 0; i < nbElements; i++ )
 8035cf4:	2600      	movs	r6, #0
 8035cf6:	b2f3      	uxtb	r3, r6
 8035cf8:	4598      	cmp	r8, r3
 8035cfa:	d802      	bhi.n	8035d02 <LoRaMacConfirmQueueHandleCb+0x1a>
        {
            // Add a request which has not been finished again to the queue
            LoRaMacConfirmQueueAdd( &mlmeConfirmToStore );
        }
    }
}
 8035cfc:	b002      	add	sp, #8
 8035cfe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        mlmeConfirm->MlmeRequest = ConfirmQueueCtx.BufferStart->Request;
 8035d02:	686b      	ldr	r3, [r5, #4]
 8035d04:	7819      	ldrb	r1, [r3, #0]
 8035d06:	7021      	strb	r1, [r4, #0]
        mlmeConfirm->Status = ConfirmQueueCtx.BufferStart->Status;
 8035d08:	785a      	ldrb	r2, [r3, #1]
 8035d0a:	7062      	strb	r2, [r4, #1]
        readyToHandle = ConfirmQueueCtx.BufferStart->ReadyToHandle;
 8035d0c:	789f      	ldrb	r7, [r3, #2]
        if( readyToHandle == true )
 8035d0e:	b15f      	cbz	r7, 8035d28 <LoRaMacConfirmQueueHandleCb+0x40>
            ConfirmQueueCtx.Primitives->MacMlmeConfirm( mlmeConfirm );
 8035d10:	682b      	ldr	r3, [r5, #0]
 8035d12:	4620      	mov	r0, r4
 8035d14:	689b      	ldr	r3, [r3, #8]
 8035d16:	4798      	blx	r3
        LoRaMacConfirmQueueRemoveFirst( );
 8035d18:	f7ff ff88 	bl	8035c2c <LoRaMacConfirmQueueRemoveFirst>
        if( readyToHandle == false )
 8035d1c:	b917      	cbnz	r7, 8035d24 <LoRaMacConfirmQueueHandleCb+0x3c>
            LoRaMacConfirmQueueAdd( &mlmeConfirmToStore );
 8035d1e:	a801      	add	r0, sp, #4
 8035d20:	f7ff ff62 	bl	8035be8 <LoRaMacConfirmQueueAdd>
    for( uint8_t i = 0; i < nbElements; i++ )
 8035d24:	3601      	adds	r6, #1
 8035d26:	e7e6      	b.n	8035cf6 <LoRaMacConfirmQueueHandleCb+0xe>
            mlmeConfirmToStore.RestrictCommonReadyToHandle = ConfirmQueueCtx.BufferStart->RestrictCommonReadyToHandle;
 8035d28:	78db      	ldrb	r3, [r3, #3]
            mlmeConfirmToStore.Request = ConfirmQueueCtx.BufferStart->Request;
 8035d2a:	f88d 1004 	strb.w	r1, [sp, #4]
            mlmeConfirmToStore.Status = ConfirmQueueCtx.BufferStart->Status;
 8035d2e:	f88d 2005 	strb.w	r2, [sp, #5]
            mlmeConfirmToStore.RestrictCommonReadyToHandle = ConfirmQueueCtx.BufferStart->RestrictCommonReadyToHandle;
 8035d32:	f88d 3007 	strb.w	r3, [sp, #7]
 8035d36:	e7ef      	b.n	8035d18 <LoRaMacConfirmQueueHandleCb+0x30>
 8035d38:	20005700 	.word	0x20005700

08035d3c <LoRaMacConfirmQueueGetCnt>:

uint8_t LoRaMacConfirmQueueGetCnt( void )
{
    return ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt;
}
 8035d3c:	4b01      	ldr	r3, [pc, #4]	; (8035d44 <LoRaMacConfirmQueueGetCnt+0x8>)
 8035d3e:	f893 0020 	ldrb.w	r0, [r3, #32]
 8035d42:	4770      	bx	lr
 8035d44:	20005700 	.word	0x20005700

08035d48 <LoRaMacConfirmQueueIsFull>:

bool LoRaMacConfirmQueueIsFull( void )
{
    if( IsListFull( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == true )
 8035d48:	4b03      	ldr	r3, [pc, #12]	; (8035d58 <LoRaMacConfirmQueueIsFull+0x10>)
    if( count >= LORA_MAC_MLME_CONFIRM_QUEUE_LEN )
 8035d4a:	f893 0020 	ldrb.w	r0, [r3, #32]
    }
    else
    {
        return false;
    }
}
 8035d4e:	2804      	cmp	r0, #4
 8035d50:	bf94      	ite	ls
 8035d52:	2000      	movls	r0, #0
 8035d54:	2001      	movhi	r0, #1
 8035d56:	4770      	bx	lr
 8035d58:	20005700 	.word	0x20005700

08035d5c <DeriveSessionKey10x>:
 * \param[IN]  netID          - Network Identifier
 * \param[IN]  deviceNonce    - Device nonce
 * \retval                    - Status of the operation
 */
static LoRaMacCryptoStatus_t DeriveSessionKey10x( KeyIdentifier_t keyID, uint32_t joinNonce, uint32_t netID, uint16_t devNonce )
{
 8035d5c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    uint8_t compBase[16] = { 0 };
 8035d5e:	2400      	movs	r4, #0
 8035d60:	e9cd 4402 	strd	r4, r4, [sp, #8]

    /* ST_WORKAROUND_BEGIN: integrate 1.1.x keys only if required */
    switch( keyID )
 8035d64:	1e44      	subs	r4, r0, #1
 8035d66:	f88d 4000 	strb.w	r4, [sp]
        default:
            return LORAMAC_CRYPTO_ERROR_INVALID_KEY_ID;
    }
   /* ST_WORKAROUND_END */

    compBase[1] = ( uint8_t )( ( joinNonce >> 0 ) & 0xFF );
 8035d6a:	f88d 1001 	strb.w	r1, [sp, #1]
    compBase[2] = ( uint8_t )( ( joinNonce >> 8 ) & 0xFF );
 8035d6e:	0a0c      	lsrs	r4, r1, #8
    compBase[3] = ( uint8_t )( ( joinNonce >> 16 ) & 0xFF );

    compBase[4] = ( uint8_t )( ( netID >> 0 ) & 0xFF );
 8035d70:	f8ad 2004 	strh.w	r2, [sp, #4]
    compBase[3] = ( uint8_t )( ( joinNonce >> 16 ) & 0xFF );
 8035d74:	0c09      	lsrs	r1, r1, #16
    compBase[5] = ( uint8_t )( ( netID >> 8 ) & 0xFF );
    compBase[6] = ( uint8_t )( ( netID >> 16 ) & 0xFF );
 8035d76:	0c12      	lsrs	r2, r2, #16
    compBase[3] = ( uint8_t )( ( joinNonce >> 16 ) & 0xFF );
 8035d78:	f88d 1003 	strb.w	r1, [sp, #3]
    compBase[6] = ( uint8_t )( ( netID >> 16 ) & 0xFF );
 8035d7c:	f88d 2006 	strb.w	r2, [sp, #6]

    compBase[7] = ( uint8_t )( ( devNonce >> 0 ) & 0xFF );
 8035d80:	f88d 3007 	strb.w	r3, [sp, #7]
    compBase[8] = ( uint8_t )( ( devNonce >> 8 ) & 0xFF );

    if( SecureElementDeriveAndStoreKey( compBase, NWK_KEY, keyID ) != SECURE_ELEMENT_SUCCESS )
 8035d84:	4602      	mov	r2, r0
    compBase[8] = ( uint8_t )( ( devNonce >> 8 ) & 0xFF );
 8035d86:	0a1b      	lsrs	r3, r3, #8
    if( SecureElementDeriveAndStoreKey( compBase, NWK_KEY, keyID ) != SECURE_ELEMENT_SUCCESS )
 8035d88:	2101      	movs	r1, #1
 8035d8a:	4668      	mov	r0, sp
    compBase[2] = ( uint8_t )( ( joinNonce >> 8 ) & 0xFF );
 8035d8c:	f88d 4002 	strb.w	r4, [sp, #2]
    compBase[8] = ( uint8_t )( ( devNonce >> 8 ) & 0xFF );
 8035d90:	f88d 3008 	strb.w	r3, [sp, #8]
    if( SecureElementDeriveAndStoreKey( compBase, NWK_KEY, keyID ) != SECURE_ELEMENT_SUCCESS )
 8035d94:	f002 ffa0 	bl	8038cd8 <SecureElementDeriveAndStoreKey>
 8035d98:	2800      	cmp	r0, #0
    {
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
    }

    return LORAMAC_CRYPTO_SUCCESS;
}
 8035d9a:	bf18      	it	ne
 8035d9c:	200f      	movne	r0, #15
 8035d9e:	b004      	add	sp, #16
 8035da0:	bd10      	pop	{r4, pc}

08035da2 <PayloadEncrypt>:
{
 8035da2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8035da6:	b088      	sub	sp, #32
 8035da8:	4617      	mov	r7, r2
 8035daa:	460d      	mov	r5, r1
 8035dac:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    if( buffer == 0 )
 8035dae:	4606      	mov	r6, r0
 8035db0:	2800      	cmp	r0, #0
 8035db2:	d04d      	beq.n	8035e50 <PayloadEncrypt+0xae>
    uint8_t sBlock[16] = { 0 };
 8035db4:	2400      	movs	r4, #0
    aBlock[0] = 0x01;
 8035db6:	2101      	movs	r1, #1
    uint8_t aBlock[16] = { 0 };
 8035db8:	e9cd 4404 	strd	r4, r4, [sp, #16]
    aBlock[0] = 0x01;
 8035dbc:	f88d 1010 	strb.w	r1, [sp, #16]
    aBlock[5] = dir;
 8035dc0:	f89d 1038 	ldrb.w	r1, [sp, #56]	; 0x38
 8035dc4:	f88d 1015 	strb.w	r1, [sp, #21]
    aBlock[6] = address & 0xFF;
 8035dc8:	f8ad 3016 	strh.w	r3, [sp, #22]
    aBlock[8] = ( address >> 16 ) & 0xFF;
 8035dcc:	0c19      	lsrs	r1, r3, #16
    uint8_t sBlock[16] = { 0 };
 8035dce:	e9cd 4400 	strd	r4, r4, [sp]
    aBlock[9] = ( address >> 24 ) & 0xFF;
 8035dd2:	0e1b      	lsrs	r3, r3, #24
    uint8_t sBlock[16] = { 0 };
 8035dd4:	e9cd 4402 	strd	r4, r4, [sp, #8]
    aBlock[9] = ( address >> 24 ) & 0xFF;
 8035dd8:	f88d 3019 	strb.w	r3, [sp, #25]
    aBlock[10] = frameCounter & 0xFF;
 8035ddc:	f8ad 201a 	strh.w	r2, [sp, #26]
    aBlock[12] = ( frameCounter >> 16 ) & 0xFF;
 8035de0:	0c13      	lsrs	r3, r2, #16
    aBlock[13] = ( frameCounter >> 24 ) & 0xFF;
 8035de2:	0e12      	lsrs	r2, r2, #24
    uint8_t aBlock[16] = { 0 };
 8035de4:	9407      	str	r4, [sp, #28]
    aBlock[8] = ( address >> 16 ) & 0xFF;
 8035de6:	f88d 1018 	strb.w	r1, [sp, #24]
    aBlock[12] = ( frameCounter >> 16 ) & 0xFF;
 8035dea:	f88d 301c 	strb.w	r3, [sp, #28]
    aBlock[13] = ( frameCounter >> 24 ) & 0xFF;
 8035dee:	f88d 201d 	strb.w	r2, [sp, #29]
    while( size > 0 )
 8035df2:	b2e3      	uxtb	r3, r4
 8035df4:	ea4f 1803 	mov.w	r8, r3, lsl #4
 8035df8:	2d00      	cmp	r5, #0
 8035dfa:	fa5f f888 	uxtb.w	r8, r8
 8035dfe:	dc03      	bgt.n	8035e08 <PayloadEncrypt+0x66>
    return LORAMAC_CRYPTO_SUCCESS;
 8035e00:	2000      	movs	r0, #0
}
 8035e02:	b008      	add	sp, #32
 8035e04:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        aBlock[15] = ctr & 0xFF;
 8035e08:	3301      	adds	r3, #1
        if( SecureElementAesEncrypt( aBlock, 16, keyID, sBlock ) != SECURE_ELEMENT_SUCCESS )
 8035e0a:	2110      	movs	r1, #16
        aBlock[15] = ctr & 0xFF;
 8035e0c:	f88d 301f 	strb.w	r3, [sp, #31]
        if( SecureElementAesEncrypt( aBlock, 16, keyID, sBlock ) != SECURE_ELEMENT_SUCCESS )
 8035e10:	463a      	mov	r2, r7
 8035e12:	466b      	mov	r3, sp
 8035e14:	eb0d 0001 	add.w	r0, sp, r1
 8035e18:	f002 fe76 	bl	8038b08 <SecureElementAesEncrypt>
 8035e1c:	4603      	mov	r3, r0
 8035e1e:	b9c8      	cbnz	r0, 8035e54 <PayloadEncrypt+0xb2>
        for( uint8_t i = 0; i < ( ( size > 16 ) ? 16 : size ); i++ )
 8035e20:	2d10      	cmp	r5, #16
 8035e22:	46ac      	mov	ip, r5
 8035e24:	bfa8      	it	ge
 8035e26:	f04f 0c10 	movge.w	ip, #16
 8035e2a:	b2da      	uxtb	r2, r3
 8035e2c:	4562      	cmp	r2, ip
 8035e2e:	f103 0301 	add.w	r3, r3, #1
 8035e32:	db03      	blt.n	8035e3c <PayloadEncrypt+0x9a>
        size -= 16;
 8035e34:	3d10      	subs	r5, #16
 8035e36:	b22d      	sxth	r5, r5
        bufferIndex += 16;
 8035e38:	3401      	adds	r4, #1
 8035e3a:	e7da      	b.n	8035df2 <PayloadEncrypt+0x50>
            buffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i];
 8035e3c:	a908      	add	r1, sp, #32
 8035e3e:	eb08 0002 	add.w	r0, r8, r2
 8035e42:	440a      	add	r2, r1
 8035e44:	5c31      	ldrb	r1, [r6, r0]
 8035e46:	f812 2c20 	ldrb.w	r2, [r2, #-32]
 8035e4a:	404a      	eors	r2, r1
 8035e4c:	5432      	strb	r2, [r6, r0]
        for( uint8_t i = 0; i < ( ( size > 16 ) ? 16 : size ); i++ )
 8035e4e:	e7ec      	b.n	8035e2a <PayloadEncrypt+0x88>
        return LORAMAC_CRYPTO_ERROR_NPE;
 8035e50:	200a      	movs	r0, #10
 8035e52:	e7d6      	b.n	8035e02 <PayloadEncrypt+0x60>
            return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 8035e54:	200f      	movs	r0, #15
 8035e56:	e7d4      	b.n	8035e02 <PayloadEncrypt+0x60>

08035e58 <GetLastFcntDown>:
{
    if( lastDown == NULL )
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
    }
    switch( fCntID )
 8035e58:	3801      	subs	r0, #1
 8035e5a:	2803      	cmp	r0, #3
 8035e5c:	d81c      	bhi.n	8035e98 <GetLastFcntDown+0x40>
 8035e5e:	e8df f000 	tbb	[pc, r0]
 8035e62:	0a02      	.short	0x0a02
 8035e64:	1610      	.short	0x1610
    {
        case N_FCNT_DOWN:
            *lastDown = CryptoNvm->FCntList.NFCntDown;
 8035e66:	4b0d      	ldr	r3, [pc, #52]	; (8035e9c <GetLastFcntDown+0x44>)
 8035e68:	681b      	ldr	r3, [r3, #0]
 8035e6a:	691a      	ldr	r2, [r3, #16]
 8035e6c:	600a      	str	r2, [r1, #0]
            CryptoNvm->LastDownFCnt = CryptoNvm->FCntList.NFCntDown;
 8035e6e:	691a      	ldr	r2, [r3, #16]
            break;
        case A_FCNT_DOWN:
            *lastDown = CryptoNvm->FCntList.AFCntDown;
            CryptoNvm->LastDownFCnt = CryptoNvm->FCntList.AFCntDown;
 8035e70:	621a      	str	r2, [r3, #32]
            break;
#endif /* LORAMAC_MAX_MC_CTX > 3 */
        default:
            return LORAMAC_CRYPTO_FAIL_FCNT_ID;
    }
    return LORAMAC_CRYPTO_SUCCESS;
 8035e72:	2000      	movs	r0, #0
            break;
 8035e74:	4770      	bx	lr
            *lastDown = CryptoNvm->FCntList.AFCntDown;
 8035e76:	4b09      	ldr	r3, [pc, #36]	; (8035e9c <GetLastFcntDown+0x44>)
 8035e78:	681b      	ldr	r3, [r3, #0]
 8035e7a:	695a      	ldr	r2, [r3, #20]
 8035e7c:	600a      	str	r2, [r1, #0]
            CryptoNvm->LastDownFCnt = CryptoNvm->FCntList.AFCntDown;
 8035e7e:	695a      	ldr	r2, [r3, #20]
 8035e80:	e7f6      	b.n	8035e70 <GetLastFcntDown+0x18>
            *lastDown = CryptoNvm->FCntList.FCntDown;
 8035e82:	4b06      	ldr	r3, [pc, #24]	; (8035e9c <GetLastFcntDown+0x44>)
 8035e84:	681b      	ldr	r3, [r3, #0]
 8035e86:	699a      	ldr	r2, [r3, #24]
 8035e88:	600a      	str	r2, [r1, #0]
            CryptoNvm->LastDownFCnt = CryptoNvm->FCntList.FCntDown;
 8035e8a:	699a      	ldr	r2, [r3, #24]
 8035e8c:	e7f0      	b.n	8035e70 <GetLastFcntDown+0x18>
            *lastDown = CryptoNvm->FCntList.McFCntDown[0];
 8035e8e:	4b03      	ldr	r3, [pc, #12]	; (8035e9c <GetLastFcntDown+0x44>)
 8035e90:	681b      	ldr	r3, [r3, #0]
 8035e92:	69db      	ldr	r3, [r3, #28]
 8035e94:	600b      	str	r3, [r1, #0]
            break;
 8035e96:	e7ec      	b.n	8035e72 <GetLastFcntDown+0x1a>
            CryptoNvm->LastDownFCnt = CryptoNvm->FCntList.NFCntDown;
 8035e98:	2005      	movs	r0, #5
}
 8035e9a:	4770      	bx	lr
 8035e9c:	20005724 	.word	0x20005724

08035ea0 <LoRaMacCryptoDeriveMcKEKey.part.0>:
    }

    return LORAMAC_CRYPTO_SUCCESS;
}

LoRaMacCryptoStatus_t LoRaMacCryptoDeriveMcKEKey( KeyIdentifier_t keyID )
 8035ea0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    // Prevent other keys than McRootKey
    if( keyID != MC_ROOT_KEY )
    {
        return LORAMAC_CRYPTO_ERROR_INVALID_KEY_ID;
    }
    uint8_t compBase[16] = { 0 };
 8035ea2:	2300      	movs	r3, #0

    if( SecureElementDeriveAndStoreKey( compBase, keyID, MC_KE_KEY ) != SECURE_ELEMENT_SUCCESS )
 8035ea4:	227f      	movs	r2, #127	; 0x7f
 8035ea6:	2104      	movs	r1, #4
 8035ea8:	4668      	mov	r0, sp
    uint8_t compBase[16] = { 0 };
 8035eaa:	e9cd 3300 	strd	r3, r3, [sp]
 8035eae:	e9cd 3302 	strd	r3, r3, [sp, #8]
    if( SecureElementDeriveAndStoreKey( compBase, keyID, MC_KE_KEY ) != SECURE_ELEMENT_SUCCESS )
 8035eb2:	f002 ff11 	bl	8038cd8 <SecureElementDeriveAndStoreKey>
 8035eb6:	2800      	cmp	r0, #0
    {
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
    }

    return LORAMAC_CRYPTO_SUCCESS;
}
 8035eb8:	bf18      	it	ne
 8035eba:	200f      	movne	r0, #15
 8035ebc:	b005      	add	sp, #20
 8035ebe:	f85d fb04 	ldr.w	pc, [sp], #4

08035ec2 <VerifyCmacB0.isra.0.constprop.0>:
static LoRaMacCryptoStatus_t VerifyCmacB0( uint8_t* msg, uint16_t len, KeyIdentifier_t keyID, bool isAck, uint8_t dir, uint32_t devAddr, uint32_t fCnt, uint32_t expectedCmac )
 8035ec2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8035ec6:	b0c4      	sub	sp, #272	; 0x110
 8035ec8:	460c      	mov	r4, r1
 8035eca:	9e4a      	ldr	r6, [sp, #296]	; 0x128
 8035ecc:	4617      	mov	r7, r2
 8035ece:	461d      	mov	r5, r3
    if( msg == 0 )
 8035ed0:	4680      	mov	r8, r0
 8035ed2:	b3b8      	cbz	r0, 8035f44 <VerifyCmacB0.isra.0.constprop.0+0x82>
    if( len > CRYPTO_MAXMESSAGE_SIZE )
 8035ed4:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 8035ed8:	d836      	bhi.n	8035f48 <VerifyCmacB0.isra.0.constprop.0+0x86>
    memset1( micBuff, 0, CRYPTO_BUFFER_SIZE );
 8035eda:	f44f 7288 	mov.w	r2, #272	; 0x110
 8035ede:	2100      	movs	r1, #0
 8035ee0:	4668      	mov	r0, sp
 8035ee2:	f003 f801 	bl	8038ee8 <memset1>
    b0[0] = 0x49;
 8035ee6:	2349      	movs	r3, #73	; 0x49
 8035ee8:	9300      	str	r3, [sp, #0]
    b0[4] = 0x00;
 8035eea:	f44f 7380 	mov.w	r3, #256	; 0x100
 8035eee:	f8ad 3004 	strh.w	r3, [sp, #4]
    b0[8] = ( devAddr >> 16 ) & 0xFF;
 8035ef2:	0c2b      	lsrs	r3, r5, #16
 8035ef4:	f88d 3008 	strb.w	r3, [sp, #8]
    b0[12] = ( fCnt >> 16 ) & 0xFF;
 8035ef8:	0c33      	lsrs	r3, r6, #16
    b0[6] = devAddr & 0xFF;
 8035efa:	f8ad 5006 	strh.w	r5, [sp, #6]
    b0[10] = fCnt & 0xFF;
 8035efe:	f8ad 600a 	strh.w	r6, [sp, #10]
    b0[12] = ( fCnt >> 16 ) & 0xFF;
 8035f02:	f88d 300c 	strb.w	r3, [sp, #12]
    memcpy1( ( micBuff + MIC_BLOCK_BX_SIZE ), msg, len );
 8035f06:	4622      	mov	r2, r4
    b0[14] = 0x00;
 8035f08:	2300      	movs	r3, #0
    memcpy1( ( micBuff + MIC_BLOCK_BX_SIZE ), msg, len );
 8035f0a:	4641      	mov	r1, r8
 8035f0c:	a804      	add	r0, sp, #16
    b0[9] = ( devAddr >> 24 ) & 0xFF;
 8035f0e:	0e2d      	lsrs	r5, r5, #24
    b0[13] = ( fCnt >> 24 ) & 0xFF;
 8035f10:	0e36      	lsrs	r6, r6, #24
    b0[14] = 0x00;
 8035f12:	f88d 300e 	strb.w	r3, [sp, #14]
    b0[9] = ( devAddr >> 24 ) & 0xFF;
 8035f16:	f88d 5009 	strb.w	r5, [sp, #9]
    b0[13] = ( fCnt >> 24 ) & 0xFF;
 8035f1a:	f88d 600d 	strb.w	r6, [sp, #13]
    b0[15] = msgLen & 0xFF;
 8035f1e:	f88d 400f 	strb.w	r4, [sp, #15]
    memcpy1( ( micBuff + MIC_BLOCK_BX_SIZE ), msg, len );
 8035f22:	f002 ffcd 	bl	8038ec0 <memcpy1>
    retval = SecureElementVerifyAesCmac( micBuff, ( len + MIC_BLOCK_BX_SIZE ), expectedCmac, keyID );
 8035f26:	f104 0110 	add.w	r1, r4, #16
 8035f2a:	9a4b      	ldr	r2, [sp, #300]	; 0x12c
 8035f2c:	463b      	mov	r3, r7
 8035f2e:	b289      	uxth	r1, r1
 8035f30:	4668      	mov	r0, sp
 8035f32:	f002 fdab 	bl	8038a8c <SecureElementVerifyAesCmac>
    if( retval == SECURE_ELEMENT_SUCCESS )
 8035f36:	b110      	cbz	r0, 8035f3e <VerifyCmacB0.isra.0.constprop.0+0x7c>
    return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 8035f38:	2801      	cmp	r0, #1
 8035f3a:	bf18      	it	ne
 8035f3c:	200f      	movne	r0, #15
}
 8035f3e:	b044      	add	sp, #272	; 0x110
 8035f40:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return LORAMAC_CRYPTO_ERROR_NPE;
 8035f44:	200a      	movs	r0, #10
 8035f46:	e7fa      	b.n	8035f3e <VerifyCmacB0.isra.0.constprop.0+0x7c>
        return LORAMAC_CRYPTO_ERROR_BUF_SIZE;
 8035f48:	200e      	movs	r0, #14
 8035f4a:	e7f8      	b.n	8035f3e <VerifyCmacB0.isra.0.constprop.0+0x7c>

08035f4c <LoRaMacCryptoInit>:
{
 8035f4c:	b510      	push	{r4, lr}
    if( nvm == NULL )
 8035f4e:	b190      	cbz	r0, 8035f76 <LoRaMacCryptoInit+0x2a>
    CryptoNvm = nvm;
 8035f50:	4c0a      	ldr	r4, [pc, #40]	; (8035f7c <LoRaMacCryptoInit+0x30>)
    memset1( ( uint8_t* )CryptoNvm, 0, sizeof( LoRaMacCryptoNvmData_t ) );
 8035f52:	2228      	movs	r2, #40	; 0x28
 8035f54:	2100      	movs	r1, #0
    CryptoNvm = nvm;
 8035f56:	6020      	str	r0, [r4, #0]
    memset1( ( uint8_t* )CryptoNvm, 0, sizeof( LoRaMacCryptoNvmData_t ) );
 8035f58:	f002 ffc6 	bl	8038ee8 <memset1>
    CryptoNvm->LrWanVersion.Fields.Major = 1;
 8035f5c:	6823      	ldr	r3, [r4, #0]
    CryptoNvm->LrWanVersion.Fields.Revision = 0;
 8035f5e:	4a08      	ldr	r2, [pc, #32]	; (8035f80 <LoRaMacCryptoInit+0x34>)
 8035f60:	601a      	str	r2, [r3, #0]
    CryptoNvm->FCntList.NFCntDown = FCNT_DOWN_INITAL_VALUE;
 8035f62:	2000      	movs	r0, #0
 8035f64:	f04f 32ff 	mov.w	r2, #4294967295
 8035f68:	e9c3 0203 	strd	r0, r2, [r3, #12]
    CryptoNvm->FCntList.FCntDown = FCNT_DOWN_INITAL_VALUE;
 8035f6c:	e9c3 2205 	strd	r2, r2, [r3, #20]
        CryptoNvm->FCntList.McFCntDown[i] = FCNT_DOWN_INITAL_VALUE;
 8035f70:	e9c3 2207 	strd	r2, r2, [r3, #28]
}
 8035f74:	bd10      	pop	{r4, pc}
        return LORAMAC_CRYPTO_FAIL_PARAM;
 8035f76:	2009      	movs	r0, #9
 8035f78:	e7fc      	b.n	8035f74 <LoRaMacCryptoInit+0x28>
 8035f7a:	bf00      	nop
 8035f7c:	20005724 	.word	0x20005724
 8035f80:	01010100 	.word	0x01010100

08035f84 <LoRaMacCryptoSetLrWanVersion>:
    CryptoNvm->LrWanVersion = version;
 8035f84:	4b02      	ldr	r3, [pc, #8]	; (8035f90 <LoRaMacCryptoSetLrWanVersion+0xc>)
 8035f86:	681b      	ldr	r3, [r3, #0]
 8035f88:	6018      	str	r0, [r3, #0]
}
 8035f8a:	2000      	movs	r0, #0
 8035f8c:	4770      	bx	lr
 8035f8e:	bf00      	nop
 8035f90:	20005724 	.word	0x20005724

08035f94 <LoRaMacCryptoGetFCntUp>:
    if( currentUp == NULL )
 8035f94:	b130      	cbz	r0, 8035fa4 <LoRaMacCryptoGetFCntUp+0x10>
    *currentUp = CryptoNvm->FCntList.FCntUp + 1;
 8035f96:	4b04      	ldr	r3, [pc, #16]	; (8035fa8 <LoRaMacCryptoGetFCntUp+0x14>)
 8035f98:	681b      	ldr	r3, [r3, #0]
 8035f9a:	68db      	ldr	r3, [r3, #12]
 8035f9c:	3301      	adds	r3, #1
 8035f9e:	6003      	str	r3, [r0, #0]
    return LORAMAC_CRYPTO_SUCCESS;
 8035fa0:	2000      	movs	r0, #0
 8035fa2:	4770      	bx	lr
        return LORAMAC_CRYPTO_ERROR_NPE;
 8035fa4:	200a      	movs	r0, #10
}
 8035fa6:	4770      	bx	lr
 8035fa8:	20005724 	.word	0x20005724

08035fac <LoRaMacCryptoGetFCntDown>:
{
 8035fac:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8035fae:	4617      	mov	r7, r2
    uint32_t lastDown = 0;
 8035fb0:	2200      	movs	r2, #0
{
 8035fb2:	460e      	mov	r6, r1
    uint32_t lastDown = 0;
 8035fb4:	9201      	str	r2, [sp, #4]
    if( currentDown == NULL )
 8035fb6:	461c      	mov	r4, r3
 8035fb8:	b353      	cbz	r3, 8036010 <LoRaMacCryptoGetFCntDown+0x64>
    cryptoStatus = GetLastFcntDown( fCntID, &lastDown );
 8035fba:	a901      	add	r1, sp, #4
 8035fbc:	f7ff ff4c 	bl	8035e58 <GetLastFcntDown>
    if( cryptoStatus != LORAMAC_CRYPTO_SUCCESS )
 8035fc0:	b9e8      	cbnz	r0, 8035ffe <LoRaMacCryptoGetFCntDown+0x52>
    if( lastDown == FCNT_DOWN_INITAL_VALUE )
 8035fc2:	9d01      	ldr	r5, [sp, #4]
 8035fc4:	1c6b      	adds	r3, r5, #1
 8035fc6:	d110      	bne.n	8035fea <LoRaMacCryptoGetFCntDown+0x3e>
        *currentDown = frameFcnt;
 8035fc8:	6027      	str	r7, [r4, #0]
    if( CryptoNvm->LrWanVersion.Fields.Minor == 0 )
 8035fca:	4b12      	ldr	r3, [pc, #72]	; (8036014 <LoRaMacCryptoGetFCntDown+0x68>)
 8035fcc:	681b      	ldr	r3, [r3, #0]
 8035fce:	789b      	ldrb	r3, [r3, #2]
 8035fd0:	b9ab      	cbnz	r3, 8035ffe <LoRaMacCryptoGetFCntDown+0x52>
        if( ( ( int64_t )*currentDown - ( int64_t )lastDown ) >= maxFCntGap )
 8035fd2:	6822      	ldr	r2, [r4, #0]
 8035fd4:	b2b6      	uxth	r6, r6
 8035fd6:	1b52      	subs	r2, r2, r5
 8035fd8:	eb62 0302 	sbc.w	r3, r2, r2
 8035fdc:	2700      	movs	r7, #0
 8035fde:	42b2      	cmp	r2, r6
 8035fe0:	41bb      	sbcs	r3, r7
            return LORAMAC_CRYPTO_FAIL_MAX_GAP_FCNT;
 8035fe2:	bfb4      	ite	lt
 8035fe4:	2000      	movlt	r0, #0
 8035fe6:	2008      	movge	r0, #8
 8035fe8:	e009      	b.n	8035ffe <LoRaMacCryptoGetFCntDown+0x52>
        fCntDiff = ( int32_t )( ( int64_t )frameFcnt - ( int64_t )( lastDown & 0x0000FFFF ) );
 8035fea:	b2a9      	uxth	r1, r5
 8035fec:	1a79      	subs	r1, r7, r1
        if( fCntDiff > 0 )
 8035fee:	2900      	cmp	r1, #0
 8035ff0:	dd02      	ble.n	8035ff8 <LoRaMacCryptoGetFCntDown+0x4c>
            *currentDown = lastDown + fCntDiff;
 8035ff2:	4429      	add	r1, r5
 8035ff4:	6021      	str	r1, [r4, #0]
 8035ff6:	e7e8      	b.n	8035fca <LoRaMacCryptoGetFCntDown+0x1e>
        else if( fCntDiff == 0 )
 8035ff8:	d103      	bne.n	8036002 <LoRaMacCryptoGetFCntDown+0x56>
            *currentDown = lastDown;
 8035ffa:	6025      	str	r5, [r4, #0]
            return LORAMAC_CRYPTO_FAIL_FCNT_DUPLICATED;
 8035ffc:	2007      	movs	r0, #7
}
 8035ffe:	b003      	add	sp, #12
 8036000:	bdf0      	pop	{r4, r5, r6, r7, pc}
            *currentDown = ( lastDown & 0xFFFF0000 ) + 0x10000 + frameFcnt;
 8036002:	0c2b      	lsrs	r3, r5, #16
 8036004:	041b      	lsls	r3, r3, #16
 8036006:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 803600a:	443b      	add	r3, r7
 803600c:	6023      	str	r3, [r4, #0]
 803600e:	e7dc      	b.n	8035fca <LoRaMacCryptoGetFCntDown+0x1e>
        return LORAMAC_CRYPTO_ERROR_NPE;
 8036010:	200a      	movs	r0, #10
 8036012:	e7f4      	b.n	8035ffe <LoRaMacCryptoGetFCntDown+0x52>
 8036014:	20005724 	.word	0x20005724

08036018 <LoRaMacCryptoSetMulticastReference>:
    if( multicastList == NULL )
 8036018:	b128      	cbz	r0, 8036026 <LoRaMacCryptoSetMulticastReference+0xe>
        multicastList[i].DownLinkCounter = &CryptoNvm->FCntList.McFCntDown[i];
 803601a:	4b04      	ldr	r3, [pc, #16]	; (803602c <LoRaMacCryptoSetMulticastReference+0x14>)
 803601c:	681b      	ldr	r3, [r3, #0]
 803601e:	331c      	adds	r3, #28
 8036020:	6203      	str	r3, [r0, #32]
    return LORAMAC_CRYPTO_SUCCESS;
 8036022:	2000      	movs	r0, #0
 8036024:	4770      	bx	lr
        return LORAMAC_CRYPTO_ERROR_NPE;
 8036026:	200a      	movs	r0, #10
}
 8036028:	4770      	bx	lr
 803602a:	bf00      	nop
 803602c:	20005724 	.word	0x20005724

08036030 <LoRaMacCryptoPrepareJoinRequest>:
{
 8036030:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    if( macMsg == 0 )
 8036032:	4604      	mov	r4, r0
 8036034:	b1f0      	cbz	r0, 8036074 <LoRaMacCryptoPrepareJoinRequest+0x44>
    uint32_t devNonce = 0;
 8036036:	2300      	movs	r3, #0
    SecureElementRandomNumber( &devNonce );
 8036038:	a803      	add	r0, sp, #12
    uint32_t devNonce = 0;
 803603a:	9303      	str	r3, [sp, #12]
    SecureElementRandomNumber( &devNonce );
 803603c:	f002 fee6 	bl	8038e0c <SecureElementRandomNumber>
    CryptoNvm->DevNonce = devNonce;
 8036040:	4a0e      	ldr	r2, [pc, #56]	; (803607c <LoRaMacCryptoPrepareJoinRequest+0x4c>)
 8036042:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 8036046:	6812      	ldr	r2, [r2, #0]
    if( LoRaMacSerializerJoinRequest( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 8036048:	4620      	mov	r0, r4
    CryptoNvm->DevNonce = devNonce;
 803604a:	8093      	strh	r3, [r2, #4]
    macMsg->DevNonce = CryptoNvm->DevNonce;
 803604c:	82e3      	strh	r3, [r4, #22]
    if( LoRaMacSerializerJoinRequest( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 803604e:	f000 fa82 	bl	8036556 <LoRaMacSerializerJoinRequest>
 8036052:	b960      	cbnz	r0, 803606e <LoRaMacCryptoPrepareJoinRequest+0x3e>
    if( SecureElementComputeAesCmac( NULL, macMsg->Buffer, ( LORAMAC_JOIN_REQ_MSG_SIZE - LORAMAC_MIC_FIELD_SIZE ), micComputationKeyID, &macMsg->MIC ) != SECURE_ELEMENT_SUCCESS )
 8036054:	f104 0318 	add.w	r3, r4, #24
 8036058:	9300      	str	r3, [sp, #0]
 803605a:	6821      	ldr	r1, [r4, #0]
 803605c:	2301      	movs	r3, #1
 803605e:	2213      	movs	r2, #19
 8036060:	f002 fcae 	bl	80389c0 <SecureElementComputeAesCmac>
 8036064:	b940      	cbnz	r0, 8036078 <LoRaMacCryptoPrepareJoinRequest+0x48>
    if( LoRaMacSerializerJoinRequest( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 8036066:	4620      	mov	r0, r4
 8036068:	f000 fa75 	bl	8036556 <LoRaMacSerializerJoinRequest>
 803606c:	b100      	cbz	r0, 8036070 <LoRaMacCryptoPrepareJoinRequest+0x40>
        return LORAMAC_CRYPTO_ERROR_SERIALIZER;
 803606e:	2011      	movs	r0, #17
}
 8036070:	b004      	add	sp, #16
 8036072:	bd10      	pop	{r4, pc}
        return LORAMAC_CRYPTO_ERROR_NPE;
 8036074:	200a      	movs	r0, #10
 8036076:	e7fb      	b.n	8036070 <LoRaMacCryptoPrepareJoinRequest+0x40>
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 8036078:	200f      	movs	r0, #15
 803607a:	e7f9      	b.n	8036070 <LoRaMacCryptoPrepareJoinRequest+0x40>
 803607c:	20005724 	.word	0x20005724

08036080 <LoRaMacCryptoSecureMessage>:
{
 8036080:	b5f0      	push	{r4, r5, r6, r7, lr}
 8036082:	4605      	mov	r5, r0
 8036084:	b087      	sub	sp, #28
    if( macMsg == NULL )
 8036086:	461c      	mov	r4, r3
 8036088:	b323      	cbz	r3, 80360d4 <LoRaMacCryptoSecureMessage+0x54>
    if( fCntUp < CryptoNvm->FCntList.FCntUp )
 803608a:	4e2f      	ldr	r6, [pc, #188]	; (8036148 <LoRaMacCryptoSecureMessage+0xc8>)
 803608c:	6833      	ldr	r3, [r6, #0]
 803608e:	68db      	ldr	r3, [r3, #12]
 8036090:	4283      	cmp	r3, r0
 8036092:	d856      	bhi.n	8036142 <LoRaMacCryptoSecureMessage+0xc2>
    if( macMsg->FPort == 0 )
 8036094:	f894 2020 	ldrb.w	r2, [r4, #32]
        payloadDecryptionKeyID = NWK_S_KEY;
 8036098:	2a00      	cmp	r2, #0
 803609a:	bf14      	ite	ne
 803609c:	2203      	movne	r2, #3
 803609e:	2202      	moveq	r2, #2
    if( fCntUp > CryptoNvm->FCntList.FCntUp )
 80360a0:	4283      	cmp	r3, r0
 80360a2:	d305      	bcc.n	80360b0 <LoRaMacCryptoSecureMessage+0x30>
    if( LoRaMacSerializerData( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 80360a4:	4620      	mov	r0, r4
 80360a6:	f000 fa8a 	bl	80365be <LoRaMacSerializerData>
 80360aa:	b170      	cbz	r0, 80360ca <LoRaMacCryptoSecureMessage+0x4a>
        return LORAMAC_CRYPTO_ERROR_SERIALIZER;
 80360ac:	2011      	movs	r0, #17
 80360ae:	e00a      	b.n	80360c6 <LoRaMacCryptoSecureMessage+0x46>
        retval = PayloadEncrypt( macMsg->FRMPayload, macMsg->FRMPayloadSize, payloadDecryptionKeyID, macMsg->FHDR.DevAddr, UPLINK, fCntUp );
 80360b0:	2300      	movs	r3, #0
 80360b2:	9001      	str	r0, [sp, #4]
 80360b4:	9300      	str	r3, [sp, #0]
 80360b6:	68a3      	ldr	r3, [r4, #8]
 80360b8:	f894 1028 	ldrb.w	r1, [r4, #40]	; 0x28
 80360bc:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80360be:	f7ff fe70 	bl	8035da2 <PayloadEncrypt>
        if( retval != LORAMAC_CRYPTO_SUCCESS )
 80360c2:	2800      	cmp	r0, #0
 80360c4:	d0ee      	beq.n	80360a4 <LoRaMacCryptoSecureMessage+0x24>
}
 80360c6:	b007      	add	sp, #28
 80360c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
        retval = ComputeCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), payloadDecryptionKeyID, false, UPLINK, macMsg->FHDR.DevAddr, fCntUp, &macMsg->MIC );
 80360ca:	7923      	ldrb	r3, [r4, #4]
 80360cc:	6821      	ldr	r1, [r4, #0]
 80360ce:	3b04      	subs	r3, #4
 80360d0:	b29a      	uxth	r2, r3
    if( ( msg == 0 ) || ( cmac == 0 ) )
 80360d2:	b909      	cbnz	r1, 80360d8 <LoRaMacCryptoSecureMessage+0x58>
        return LORAMAC_CRYPTO_ERROR_NPE;
 80360d4:	200a      	movs	r0, #10
 80360d6:	e7f6      	b.n	80360c6 <LoRaMacCryptoSecureMessage+0x46>
    if( len > CRYPTO_MAXMESSAGE_SIZE )
 80360d8:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 80360dc:	d82f      	bhi.n	803613e <LoRaMacCryptoSecureMessage+0xbe>
        retval = ComputeCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), payloadDecryptionKeyID, false, UPLINK, macMsg->FHDR.DevAddr, fCntUp, &macMsg->MIC );
 80360de:	68a7      	ldr	r7, [r4, #8]
    b0[5] = dir;
 80360e0:	f8b4 c008 	ldrh.w	ip, [r4, #8]
    b0[6] = devAddr & 0xFF;
 80360e4:	f8ad c00e 	strh.w	ip, [sp, #14]
    b0[8] = ( devAddr >> 16 ) & 0xFF;
 80360e8:	ea4f 4c17 	mov.w	ip, r7, lsr #16
    b0[9] = ( devAddr >> 24 ) & 0xFF;
 80360ec:	0e3f      	lsrs	r7, r7, #24
 80360ee:	f88d 7011 	strb.w	r7, [sp, #17]
    b0[15] = msgLen & 0xFF;
 80360f2:	f88d 3017 	strb.w	r3, [sp, #23]
    b0[12] = ( fCnt >> 16 ) & 0xFF;
 80360f6:	0c2f      	lsrs	r7, r5, #16
        retval = ComputeCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), payloadDecryptionKeyID, false, UPLINK, macMsg->FHDR.DevAddr, fCntUp, &macMsg->MIC );
 80360f8:	f104 032c 	add.w	r3, r4, #44	; 0x2c
    b0[0] = 0x49;
 80360fc:	f04f 0e49 	mov.w	lr, #73	; 0x49
    b0[4] = 0x00;
 8036100:	f8ad 000c 	strh.w	r0, [sp, #12]
    b0[12] = ( fCnt >> 16 ) & 0xFF;
 8036104:	f88d 7014 	strb.w	r7, [sp, #20]
    b0[14] = 0x00;
 8036108:	f88d 0016 	strb.w	r0, [sp, #22]
    b0[13] = ( fCnt >> 24 ) & 0xFF;
 803610c:	0e2f      	lsrs	r7, r5, #24
    if( SecureElementComputeAesCmac( micBuff, msg, len, keyID, cmac ) != SECURE_ELEMENT_SUCCESS )
 803610e:	9300      	str	r3, [sp, #0]
 8036110:	a802      	add	r0, sp, #8
 8036112:	2302      	movs	r3, #2
    b0[0] = 0x49;
 8036114:	f8cd e008 	str.w	lr, [sp, #8]
    b0[8] = ( devAddr >> 16 ) & 0xFF;
 8036118:	f88d c010 	strb.w	ip, [sp, #16]
    b0[10] = fCnt & 0xFF;
 803611c:	f8ad 5012 	strh.w	r5, [sp, #18]
    b0[13] = ( fCnt >> 24 ) & 0xFF;
 8036120:	f88d 7015 	strb.w	r7, [sp, #21]
    if( SecureElementComputeAesCmac( micBuff, msg, len, keyID, cmac ) != SECURE_ELEMENT_SUCCESS )
 8036124:	f002 fc4c 	bl	80389c0 <SecureElementComputeAesCmac>
 8036128:	b108      	cbz	r0, 803612e <LoRaMacCryptoSecureMessage+0xae>
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 803612a:	200f      	movs	r0, #15
 803612c:	e7cb      	b.n	80360c6 <LoRaMacCryptoSecureMessage+0x46>
    if( LoRaMacSerializerData( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 803612e:	4620      	mov	r0, r4
 8036130:	f000 fa45 	bl	80365be <LoRaMacSerializerData>
 8036134:	2800      	cmp	r0, #0
 8036136:	d1b9      	bne.n	80360ac <LoRaMacCryptoSecureMessage+0x2c>
    CryptoNvm->FCntList.FCntUp = fCntUp;
 8036138:	6833      	ldr	r3, [r6, #0]
 803613a:	60dd      	str	r5, [r3, #12]
    return LORAMAC_CRYPTO_SUCCESS;
 803613c:	e7c3      	b.n	80360c6 <LoRaMacCryptoSecureMessage+0x46>
        return LORAMAC_CRYPTO_ERROR_BUF_SIZE;
 803613e:	200e      	movs	r0, #14
 8036140:	e7c1      	b.n	80360c6 <LoRaMacCryptoSecureMessage+0x46>
        return LORAMAC_CRYPTO_FAIL_FCNT_SMALLER;
 8036142:	2006      	movs	r0, #6
 8036144:	e7bf      	b.n	80360c6 <LoRaMacCryptoSecureMessage+0x46>
 8036146:	bf00      	nop
 8036148:	20005724 	.word	0x20005724

0803614c <LoRaMacCryptoUnsecureMessage>:
{
 803614c:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 8036150:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 8036152:	4680      	mov	r8, r0
 8036154:	460f      	mov	r7, r1
 8036156:	4616      	mov	r6, r2
 8036158:	461c      	mov	r4, r3
    if( macMsg == 0 )
 803615a:	2d00      	cmp	r5, #0
 803615c:	d059      	beq.n	8036212 <LoRaMacCryptoUnsecureMessage+0xc6>
    uint32_t lastDown = 0;
 803615e:	2300      	movs	r3, #0
    if( GetLastFcntDown( fCntID, &lastDown ) != LORAMAC_CRYPTO_SUCCESS )
 8036160:	a903      	add	r1, sp, #12
 8036162:	4610      	mov	r0, r2
    uint32_t lastDown = 0;
 8036164:	9303      	str	r3, [sp, #12]
    if( GetLastFcntDown( fCntID, &lastDown ) != LORAMAC_CRYPTO_SUCCESS )
 8036166:	f7ff fe77 	bl	8035e58 <GetLastFcntDown>
 803616a:	b118      	cbz	r0, 8036174 <LoRaMacCryptoUnsecureMessage+0x28>
        return LORAMAC_CRYPTO_FAIL_FCNT_SMALLER;
 803616c:	2006      	movs	r0, #6
}
 803616e:	b004      	add	sp, #16
 8036170:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if( ( currentDown > lastDown ) ||
 8036174:	9b03      	ldr	r3, [sp, #12]
 8036176:	429c      	cmp	r4, r3
 8036178:	d801      	bhi.n	803617e <LoRaMacCryptoUnsecureMessage+0x32>
 803617a:	3301      	adds	r3, #1
 803617c:	d1f6      	bne.n	803616c <LoRaMacCryptoUnsecureMessage+0x20>
    if( LoRaMacParserData( macMsg ) != LORAMAC_PARSER_SUCCESS )
 803617e:	4628      	mov	r0, r5
 8036180:	f000 f98e 	bl	80364a0 <LoRaMacParserData>
 8036184:	2800      	cmp	r0, #0
 8036186:	d146      	bne.n	8036216 <LoRaMacCryptoUnsecureMessage+0xca>
        if( KeyAddrList[i].AddrID == addrID )
 8036188:	4b26      	ldr	r3, [pc, #152]	; (8036224 <LoRaMacCryptoUnsecureMessage+0xd8>)
 803618a:	781a      	ldrb	r2, [r3, #0]
 803618c:	4542      	cmp	r2, r8
 803618e:	d003      	beq.n	8036198 <LoRaMacCryptoUnsecureMessage+0x4c>
 8036190:	791a      	ldrb	r2, [r3, #4]
 8036192:	4542      	cmp	r2, r8
 8036194:	d141      	bne.n	803621a <LoRaMacCryptoUnsecureMessage+0xce>
 8036196:	2001      	movs	r0, #1
    if( address != macMsg->FHDR.DevAddr )
 8036198:	68aa      	ldr	r2, [r5, #8]
 803619a:	42ba      	cmp	r2, r7
 803619c:	d13f      	bne.n	803621e <LoRaMacCryptoUnsecureMessage+0xd2>
    payloadDecryptionKeyID = curItem->AppSkey;
 803619e:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    retval = VerifyCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), micComputationKeyID, isAck, DOWNLINK, address, fCntDown, macMsg->MIC );
 80361a2:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    payloadDecryptionKeyID = curItem->AppSkey;
 80361a4:	f890 8001 	ldrb.w	r8, [r0, #1]
    retval = VerifyCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), micComputationKeyID, isAck, DOWNLINK, address, fCntDown, macMsg->MIC );
 80361a8:	7929      	ldrb	r1, [r5, #4]
 80361aa:	e9cd 4300 	strd	r4, r3, [sp]
 80361ae:	3904      	subs	r1, #4
 80361b0:	7882      	ldrb	r2, [r0, #2]
 80361b2:	6828      	ldr	r0, [r5, #0]
 80361b4:	463b      	mov	r3, r7
 80361b6:	b289      	uxth	r1, r1
 80361b8:	f7ff fe83 	bl	8035ec2 <VerifyCmacB0.isra.0.constprop.0>
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 80361bc:	2800      	cmp	r0, #0
 80361be:	d1d6      	bne.n	803616e <LoRaMacCryptoUnsecureMessage+0x22>
    if( macMsg->FPort == 0 )
 80361c0:	f895 3020 	ldrb.w	r3, [r5, #32]
    retval = PayloadEncrypt( macMsg->FRMPayload, macMsg->FRMPayloadSize, payloadDecryptionKeyID, address, DOWNLINK, fCntDown );
 80361c4:	9401      	str	r4, [sp, #4]
        payloadDecryptionKeyID = NWK_S_KEY;
 80361c6:	2b00      	cmp	r3, #0
    retval = PayloadEncrypt( macMsg->FRMPayload, macMsg->FRMPayloadSize, payloadDecryptionKeyID, address, DOWNLINK, fCntDown );
 80361c8:	f04f 0301 	mov.w	r3, #1
 80361cc:	9300      	str	r3, [sp, #0]
 80361ce:	bf14      	ite	ne
 80361d0:	4642      	movne	r2, r8
 80361d2:	2202      	moveq	r2, #2
 80361d4:	f895 1028 	ldrb.w	r1, [r5, #40]	; 0x28
 80361d8:	6a68      	ldr	r0, [r5, #36]	; 0x24
 80361da:	463b      	mov	r3, r7
 80361dc:	f7ff fde1 	bl	8035da2 <PayloadEncrypt>
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 80361e0:	2800      	cmp	r0, #0
 80361e2:	d1c4      	bne.n	803616e <LoRaMacCryptoUnsecureMessage+0x22>
    switch( fCntID )
 80361e4:	3e01      	subs	r6, #1
 80361e6:	2e03      	cmp	r6, #3
 80361e8:	d8c1      	bhi.n	803616e <LoRaMacCryptoUnsecureMessage+0x22>
 80361ea:	e8df f006 	tbb	[pc, r6]
 80361ee:	0602      	.short	0x0602
 80361f0:	0e0a      	.short	0x0e0a
            CryptoNvm->FCntList.NFCntDown = currentDown;
 80361f2:	4b0d      	ldr	r3, [pc, #52]	; (8036228 <LoRaMacCryptoUnsecureMessage+0xdc>)
 80361f4:	681b      	ldr	r3, [r3, #0]
 80361f6:	611c      	str	r4, [r3, #16]
            break;
 80361f8:	e7b9      	b.n	803616e <LoRaMacCryptoUnsecureMessage+0x22>
            CryptoNvm->FCntList.AFCntDown = currentDown;
 80361fa:	4b0b      	ldr	r3, [pc, #44]	; (8036228 <LoRaMacCryptoUnsecureMessage+0xdc>)
 80361fc:	681b      	ldr	r3, [r3, #0]
 80361fe:	615c      	str	r4, [r3, #20]
            break;
 8036200:	e7b5      	b.n	803616e <LoRaMacCryptoUnsecureMessage+0x22>
            CryptoNvm->FCntList.FCntDown = currentDown;
 8036202:	4b09      	ldr	r3, [pc, #36]	; (8036228 <LoRaMacCryptoUnsecureMessage+0xdc>)
 8036204:	681b      	ldr	r3, [r3, #0]
 8036206:	619c      	str	r4, [r3, #24]
            break;
 8036208:	e7b1      	b.n	803616e <LoRaMacCryptoUnsecureMessage+0x22>
            CryptoNvm->FCntList.McFCntDown[0] = currentDown;
 803620a:	4b07      	ldr	r3, [pc, #28]	; (8036228 <LoRaMacCryptoUnsecureMessage+0xdc>)
 803620c:	681b      	ldr	r3, [r3, #0]
 803620e:	61dc      	str	r4, [r3, #28]
            break;
 8036210:	e7ad      	b.n	803616e <LoRaMacCryptoUnsecureMessage+0x22>
        return LORAMAC_CRYPTO_ERROR_NPE;
 8036212:	200a      	movs	r0, #10
 8036214:	e7ab      	b.n	803616e <LoRaMacCryptoUnsecureMessage+0x22>
        return LORAMAC_CRYPTO_ERROR_PARSER;
 8036216:	2010      	movs	r0, #16
 8036218:	e7a9      	b.n	803616e <LoRaMacCryptoUnsecureMessage+0x22>
    return LORAMAC_CRYPTO_ERROR_INVALID_ADDR_ID;
 803621a:	200c      	movs	r0, #12
 803621c:	e7a7      	b.n	803616e <LoRaMacCryptoUnsecureMessage+0x22>
        return LORAMAC_CRYPTO_FAIL_ADDRESS;
 803621e:	2002      	movs	r0, #2
 8036220:	e7a5      	b.n	803616e <LoRaMacCryptoUnsecureMessage+0x22>
 8036222:	bf00      	nop
 8036224:	20003594 	.word	0x20003594
 8036228:	20005724 	.word	0x20005724

0803622c <LoRaMacCryptoDeriveMcRootKey>:
{
 803622c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    if( keyID != APP_KEY )
 803622e:	b9b1      	cbnz	r1, 803625e <LoRaMacCryptoDeriveMcRootKey+0x32>
    if( versionMinor == 1 )
 8036230:	2801      	cmp	r0, #1
    uint8_t compBase[16] = { 0 };
 8036232:	e9cd 1100 	strd	r1, r1, [sp]
        compBase[0] = 0x20;
 8036236:	bf08      	it	eq
 8036238:	2320      	moveq	r3, #32
    uint8_t compBase[16] = { 0 };
 803623a:	e9cd 1102 	strd	r1, r1, [sp, #8]
    if( SecureElementDeriveAndStoreKey( compBase, keyID, MC_ROOT_KEY ) != SECURE_ELEMENT_SUCCESS )
 803623e:	f04f 0204 	mov.w	r2, #4
 8036242:	f04f 0100 	mov.w	r1, #0
 8036246:	4668      	mov	r0, sp
        compBase[0] = 0x20;
 8036248:	bf08      	it	eq
 803624a:	f88d 3000 	strbeq.w	r3, [sp]
    if( SecureElementDeriveAndStoreKey( compBase, keyID, MC_ROOT_KEY ) != SECURE_ELEMENT_SUCCESS )
 803624e:	f002 fd43 	bl	8038cd8 <SecureElementDeriveAndStoreKey>
 8036252:	2800      	cmp	r0, #0
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 8036254:	bf18      	it	ne
 8036256:	200f      	movne	r0, #15
}
 8036258:	b005      	add	sp, #20
 803625a:	f85d fb04 	ldr.w	pc, [sp], #4
        return LORAMAC_CRYPTO_ERROR_INVALID_KEY_ID;
 803625e:	200b      	movs	r0, #11
 8036260:	e7fa      	b.n	8036258 <LoRaMacCryptoDeriveMcRootKey+0x2c>
	...

08036264 <LoRaMacCryptoSetKey>:
{
 8036264:	b538      	push	{r3, r4, r5, lr}
 8036266:	4605      	mov	r5, r0
    if( SecureElementSetKey( keyID, key ) != SECURE_ELEMENT_SUCCESS )
 8036268:	f002 fcb0 	bl	8038bcc <SecureElementSetKey>
 803626c:	4604      	mov	r4, r0
 803626e:	b950      	cbnz	r0, 8036286 <LoRaMacCryptoSetKey+0x22>
    if( keyID == APP_KEY )
 8036270:	b955      	cbnz	r5, 8036288 <LoRaMacCryptoSetKey+0x24>
        if( LoRaMacCryptoDeriveMcRootKey( CryptoNvm->LrWanVersion.Fields.Minor, keyID ) != LORAMAC_CRYPTO_SUCCESS )
 8036272:	4b06      	ldr	r3, [pc, #24]	; (803628c <LoRaMacCryptoSetKey+0x28>)
 8036274:	681b      	ldr	r3, [r3, #0]
 8036276:	4601      	mov	r1, r0
 8036278:	7898      	ldrb	r0, [r3, #2]
 803627a:	f7ff ffd7 	bl	803622c <LoRaMacCryptoDeriveMcRootKey>
 803627e:	b910      	cbnz	r0, 8036286 <LoRaMacCryptoSetKey+0x22>
    if( keyID != MC_ROOT_KEY )
 8036280:	f7ff fe0e 	bl	8035ea0 <LoRaMacCryptoDeriveMcKEKey.part.0>
        if( LoRaMacCryptoDeriveMcKEKey( MC_ROOT_KEY ) != LORAMAC_CRYPTO_SUCCESS )
 8036284:	b100      	cbz	r0, 8036288 <LoRaMacCryptoSetKey+0x24>
            return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 8036286:	240f      	movs	r4, #15
}
 8036288:	4620      	mov	r0, r4
 803628a:	bd38      	pop	{r3, r4, r5, pc}
 803628c:	20005724 	.word	0x20005724

08036290 <LoRaMacCryptoHandleJoinAccept>:
{
 8036290:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8036294:	4680      	mov	r8, r0
 8036296:	b08f      	sub	sp, #60	; 0x3c
 8036298:	460d      	mov	r5, r1
    if( ( macMsg == 0 ) || ( joinEUI == 0 ) )
 803629a:	4614      	mov	r4, r2
 803629c:	2a00      	cmp	r2, #0
 803629e:	d05f      	beq.n	8036360 <LoRaMacCryptoHandleJoinAccept+0xd0>
 80362a0:	2900      	cmp	r1, #0
 80362a2:	d05d      	beq.n	8036360 <LoRaMacCryptoHandleJoinAccept+0xd0>
    uint8_t decJoinAccept[LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE] = { 0 };
 80362a4:	2600      	movs	r6, #0
 80362a6:	4631      	mov	r1, r6
 80362a8:	221d      	movs	r2, #29
 80362aa:	a806      	add	r0, sp, #24
 80362ac:	9605      	str	r6, [sp, #20]
 80362ae:	f005 fa33 	bl	803b718 <memset>
    uint8_t versionMinor         = 0;
 80362b2:	f88d 6013 	strb.w	r6, [sp, #19]
    uint16_t nonce               = CryptoNvm->DevNonce;
 80362b6:	4e2e      	ldr	r6, [pc, #184]	; (8036370 <LoRaMacCryptoHandleJoinAccept+0xe0>)
 80362b8:	6833      	ldr	r3, [r6, #0]
    if( SecureElementProcessJoinAccept( joinReqType, joinEUI, nonce, macMsg->Buffer,
 80362ba:	f10d 0914 	add.w	r9, sp, #20
    uint16_t nonce               = CryptoNvm->DevNonce;
 80362be:	889f      	ldrh	r7, [r3, #4]
    if( SecureElementProcessJoinAccept( joinReqType, joinEUI, nonce, macMsg->Buffer,
 80362c0:	f8cd 9004 	str.w	r9, [sp, #4]
 80362c4:	f10d 0313 	add.w	r3, sp, #19
 80362c8:	9302      	str	r3, [sp, #8]
 80362ca:	7923      	ldrb	r3, [r4, #4]
 80362cc:	9300      	str	r3, [sp, #0]
 80362ce:	6823      	ldr	r3, [r4, #0]
 80362d0:	463a      	mov	r2, r7
 80362d2:	4629      	mov	r1, r5
 80362d4:	4640      	mov	r0, r8
 80362d6:	f002 fd55 	bl	8038d84 <SecureElementProcessJoinAccept>
 80362da:	2800      	cmp	r0, #0
 80362dc:	d142      	bne.n	8036364 <LoRaMacCryptoHandleJoinAccept+0xd4>
    memcpy1( macMsg->Buffer, decJoinAccept, macMsg->BufSize );
 80362de:	4649      	mov	r1, r9
 80362e0:	7922      	ldrb	r2, [r4, #4]
 80362e2:	6820      	ldr	r0, [r4, #0]
 80362e4:	f002 fdec 	bl	8038ec0 <memcpy1>
    if( LoRaMacParserJoinAccept( macMsg ) != LORAMAC_PARSER_SUCCESS )
 80362e8:	4620      	mov	r0, r4
 80362ea:	f000 f88b 	bl	8036404 <LoRaMacParserJoinAccept>
 80362ee:	4601      	mov	r1, r0
 80362f0:	2800      	cmp	r0, #0
 80362f2:	d139      	bne.n	8036368 <LoRaMacCryptoHandleJoinAccept+0xd8>
    currentJoinNonce |= ( ( uint32_t )macMsg->JoinNonce[2] << 16 );
 80362f4:	7a25      	ldrb	r5, [r4, #8]
    currentJoinNonce |= ( ( uint32_t )macMsg->JoinNonce[1] << 8 );
 80362f6:	79e2      	ldrb	r2, [r4, #7]
    currentJoinNonce = ( uint32_t )macMsg->JoinNonce[0];
 80362f8:	79a3      	ldrb	r3, [r4, #6]
    currentJoinNonce |= ( ( uint32_t )macMsg->JoinNonce[2] << 16 );
 80362fa:	042d      	lsls	r5, r5, #16
 80362fc:	ea45 2502 	orr.w	r5, r5, r2, lsl #8
 8036300:	431d      	orrs	r5, r3
    if( currentJoinNonce != CryptoNvm->JoinNonce )
 8036302:	6833      	ldr	r3, [r6, #0]
 8036304:	689a      	ldr	r2, [r3, #8]
 8036306:	42aa      	cmp	r2, r5
 8036308:	d030      	beq.n	803636c <LoRaMacCryptoHandleJoinAccept+0xdc>
    retval = LoRaMacCryptoDeriveMcRootKey( versionMinor, APP_KEY );
 803630a:	f89d 0013 	ldrb.w	r0, [sp, #19]
        CryptoNvm->JoinNonce = currentJoinNonce;
 803630e:	609d      	str	r5, [r3, #8]
    retval = LoRaMacCryptoDeriveMcRootKey( versionMinor, APP_KEY );
 8036310:	f7ff ff8c 	bl	803622c <LoRaMacCryptoDeriveMcRootKey>
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 8036314:	bb08      	cbnz	r0, 803635a <LoRaMacCryptoHandleJoinAccept+0xca>
    if( keyID != MC_ROOT_KEY )
 8036316:	f7ff fdc3 	bl	8035ea0 <LoRaMacCryptoDeriveMcKEKey.part.0>
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 803631a:	b9f0      	cbnz	r0, 803635a <LoRaMacCryptoHandleJoinAccept+0xca>
        netID = ( uint32_t )macMsg->NetID[0];
 803631c:	7a62      	ldrb	r2, [r4, #9]
        netID |= ( ( uint32_t )macMsg->NetID[1] << 8 );
 803631e:	7aa3      	ldrb	r3, [r4, #10]
        netID |= ( ( uint32_t )macMsg->NetID[2] << 16 );
 8036320:	7ae4      	ldrb	r4, [r4, #11]
 8036322:	0424      	lsls	r4, r4, #16
 8036324:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
 8036328:	4314      	orrs	r4, r2
        retval = DeriveSessionKey10x( APP_S_KEY, currentJoinNonce, netID, nonce );
 803632a:	463b      	mov	r3, r7
 803632c:	4622      	mov	r2, r4
 803632e:	4629      	mov	r1, r5
 8036330:	2003      	movs	r0, #3
 8036332:	f7ff fd13 	bl	8035d5c <DeriveSessionKey10x>
        if( retval != LORAMAC_CRYPTO_SUCCESS )
 8036336:	b980      	cbnz	r0, 803635a <LoRaMacCryptoHandleJoinAccept+0xca>
        retval = DeriveSessionKey10x( NWK_S_KEY, currentJoinNonce, netID, nonce );
 8036338:	463b      	mov	r3, r7
 803633a:	4622      	mov	r2, r4
 803633c:	4629      	mov	r1, r5
 803633e:	2002      	movs	r0, #2
 8036340:	f7ff fd0c 	bl	8035d5c <DeriveSessionKey10x>
        if( retval != LORAMAC_CRYPTO_SUCCESS )
 8036344:	b948      	cbnz	r0, 803635a <LoRaMacCryptoHandleJoinAccept+0xca>
    CryptoNvm->LrWanVersion.Fields.Minor = versionMinor;
 8036346:	6833      	ldr	r3, [r6, #0]
 8036348:	f89d 2013 	ldrb.w	r2, [sp, #19]
 803634c:	709a      	strb	r2, [r3, #2]
    CryptoNvm->FCntList.FCntDown = FCNT_DOWN_INITAL_VALUE;
 803634e:	f04f 32ff 	mov.w	r2, #4294967295
    CryptoNvm->FCntList.AFCntDown = FCNT_DOWN_INITAL_VALUE;
 8036352:	e9c3 2204 	strd	r2, r2, [r3, #16]
    CryptoNvm->FCntList.FCntUp = 0;
 8036356:	60d8      	str	r0, [r3, #12]
    CryptoNvm->FCntList.FCntDown = FCNT_DOWN_INITAL_VALUE;
 8036358:	619a      	str	r2, [r3, #24]
}
 803635a:	b00f      	add	sp, #60	; 0x3c
 803635c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        return LORAMAC_CRYPTO_ERROR_NPE;
 8036360:	200a      	movs	r0, #10
 8036362:	e7fa      	b.n	803635a <LoRaMacCryptoHandleJoinAccept+0xca>
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 8036364:	200f      	movs	r0, #15
 8036366:	e7f8      	b.n	803635a <LoRaMacCryptoHandleJoinAccept+0xca>
        return LORAMAC_CRYPTO_ERROR_PARSER;
 8036368:	2010      	movs	r0, #16
 803636a:	e7f6      	b.n	803635a <LoRaMacCryptoHandleJoinAccept+0xca>
        return LORAMAC_CRYPTO_FAIL_JOIN_NONCE;
 803636c:	2003      	movs	r0, #3
 803636e:	e7f4      	b.n	803635a <LoRaMacCryptoHandleJoinAccept+0xca>
 8036370:	20005724 	.word	0x20005724

08036374 <LoRaMacCryptoDeriveMcSessionKeyPair>:

LoRaMacCryptoStatus_t LoRaMacCryptoDeriveMcSessionKeyPair( AddressIdentifier_t addrID, uint32_t mcAddr )
{
 8036374:	b570      	push	{r4, r5, r6, lr}
 8036376:	b088      	sub	sp, #32
    if( mcAddr == 0 )
 8036378:	2900      	cmp	r1, #0
 803637a:	d03d      	beq.n	80363f8 <LoRaMacCryptoDeriveMcSessionKeyPair+0x84>
        if( KeyAddrList[i].AddrID == addrID )
 803637c:	4c20      	ldr	r4, [pc, #128]	; (8036400 <LoRaMacCryptoDeriveMcSessionKeyPair+0x8c>)
 803637e:	7823      	ldrb	r3, [r4, #0]
 8036380:	4283      	cmp	r3, r0
 8036382:	d037      	beq.n	80363f4 <LoRaMacCryptoDeriveMcSessionKeyPair+0x80>
 8036384:	7923      	ldrb	r3, [r4, #4]
 8036386:	4283      	cmp	r3, r0
 8036388:	d138      	bne.n	80363fc <LoRaMacCryptoDeriveMcSessionKeyPair+0x88>
 803638a:	2201      	movs	r2, #1
    }

    // McAppSKey = aes128_encrypt(McKey, 0x01 | McAddr | pad16)
    // McNwkSKey = aes128_encrypt(McKey, 0x02 | McAddr | pad16)

    uint8_t compBaseAppS[16] = { 0 };
 803638c:	2300      	movs	r3, #0
 803638e:	e9cd 3301 	strd	r3, r3, [sp, #4]
    uint8_t compBaseNwkS[16] = { 0 };
 8036392:	e9cd 3305 	strd	r3, r3, [sp, #20]
    compBaseNwkS[1] = mcAddr & 0xFF;
    compBaseNwkS[2] = ( mcAddr >> 8 ) & 0xFF;
    compBaseNwkS[3] = ( mcAddr >> 16 ) & 0xFF;
    compBaseNwkS[4] = ( mcAddr >> 24 ) & 0xFF;

    if( SecureElementDeriveAndStoreKey( compBaseAppS, curItem->RootKey, curItem->AppSkey ) != SECURE_ELEMENT_SUCCESS )
 8036396:	eb04 0482 	add.w	r4, r4, r2, lsl #2
    uint8_t compBaseAppS[16] = { 0 };
 803639a:	9303      	str	r3, [sp, #12]
    uint8_t compBaseNwkS[16] = { 0 };
 803639c:	9307      	str	r3, [sp, #28]
    compBaseAppS[0] = 0x01;
 803639e:	2301      	movs	r3, #1
    compBaseAppS[2] = ( mcAddr >> 8 ) & 0xFF;
 80363a0:	f3c1 2007 	ubfx	r0, r1, #8, #8
    compBaseAppS[1] = mcAddr & 0xFF;
 80363a4:	b2cd      	uxtb	r5, r1
    compBaseAppS[0] = 0x01;
 80363a6:	f88d 3000 	strb.w	r3, [sp]
    compBaseAppS[3] = ( mcAddr >> 16 ) & 0xFF;
 80363aa:	f3c1 4307 	ubfx	r3, r1, #16, #8
    compBaseAppS[4] = ( mcAddr >> 24 ) & 0xFF;
 80363ae:	0e09      	lsrs	r1, r1, #24
    compBaseAppS[2] = ( mcAddr >> 8 ) & 0xFF;
 80363b0:	f88d 0002 	strb.w	r0, [sp, #2]
    compBaseAppS[4] = ( mcAddr >> 24 ) & 0xFF;
 80363b4:	f88d 1004 	strb.w	r1, [sp, #4]
    compBaseNwkS[0] = 0x02;
 80363b8:	2602      	movs	r6, #2
    compBaseNwkS[2] = ( mcAddr >> 8 ) & 0xFF;
 80363ba:	f88d 0012 	strb.w	r0, [sp, #18]
    compBaseNwkS[4] = ( mcAddr >> 24 ) & 0xFF;
 80363be:	f88d 1014 	strb.w	r1, [sp, #20]
    if( SecureElementDeriveAndStoreKey( compBaseAppS, curItem->RootKey, curItem->AppSkey ) != SECURE_ELEMENT_SUCCESS )
 80363c2:	7862      	ldrb	r2, [r4, #1]
 80363c4:	78e1      	ldrb	r1, [r4, #3]
    compBaseAppS[1] = mcAddr & 0xFF;
 80363c6:	f88d 5001 	strb.w	r5, [sp, #1]
    if( SecureElementDeriveAndStoreKey( compBaseAppS, curItem->RootKey, curItem->AppSkey ) != SECURE_ELEMENT_SUCCESS )
 80363ca:	4668      	mov	r0, sp
    compBaseAppS[3] = ( mcAddr >> 16 ) & 0xFF;
 80363cc:	f88d 3003 	strb.w	r3, [sp, #3]
    compBaseNwkS[0] = 0x02;
 80363d0:	f88d 6010 	strb.w	r6, [sp, #16]
    compBaseNwkS[1] = mcAddr & 0xFF;
 80363d4:	f88d 5011 	strb.w	r5, [sp, #17]
    compBaseNwkS[3] = ( mcAddr >> 16 ) & 0xFF;
 80363d8:	f88d 3013 	strb.w	r3, [sp, #19]
    if( SecureElementDeriveAndStoreKey( compBaseAppS, curItem->RootKey, curItem->AppSkey ) != SECURE_ELEMENT_SUCCESS )
 80363dc:	f002 fc7c 	bl	8038cd8 <SecureElementDeriveAndStoreKey>
 80363e0:	b928      	cbnz	r0, 80363ee <LoRaMacCryptoDeriveMcSessionKeyPair+0x7a>
    {
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
    }

    if( SecureElementDeriveAndStoreKey( compBaseNwkS, curItem->RootKey, curItem->NwkSkey ) != SECURE_ELEMENT_SUCCESS )
 80363e2:	78a2      	ldrb	r2, [r4, #2]
 80363e4:	78e1      	ldrb	r1, [r4, #3]
 80363e6:	a804      	add	r0, sp, #16
 80363e8:	f002 fc76 	bl	8038cd8 <SecureElementDeriveAndStoreKey>
 80363ec:	b100      	cbz	r0, 80363f0 <LoRaMacCryptoDeriveMcSessionKeyPair+0x7c>
    {
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 80363ee:	200f      	movs	r0, #15
    }

    return LORAMAC_CRYPTO_SUCCESS;
}
 80363f0:	b008      	add	sp, #32
 80363f2:	bd70      	pop	{r4, r5, r6, pc}
        if( KeyAddrList[i].AddrID == addrID )
 80363f4:	2200      	movs	r2, #0
 80363f6:	e7c9      	b.n	803638c <LoRaMacCryptoDeriveMcSessionKeyPair+0x18>
        return LORAMAC_CRYPTO_ERROR_NPE;
 80363f8:	200a      	movs	r0, #10
 80363fa:	e7f9      	b.n	80363f0 <LoRaMacCryptoDeriveMcSessionKeyPair+0x7c>
    return LORAMAC_CRYPTO_ERROR_INVALID_ADDR_ID;
 80363fc:	200c      	movs	r0, #12
 80363fe:	e7f7      	b.n	80363f0 <LoRaMacCryptoDeriveMcSessionKeyPair+0x7c>
 8036400:	20003594 	.word	0x20003594

08036404 <LoRaMacParserJoinAccept>:
 */
#include "LoRaMacParser.h"
#include "utilities.h"

LoRaMacParserStatus_t LoRaMacParserJoinAccept( LoRaMacMessageJoinAccept_t* macMsg )
{
 8036404:	b510      	push	{r4, lr}
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 8036406:	4604      	mov	r4, r0
 8036408:	2800      	cmp	r0, #0
 803640a:	d045      	beq.n	8036498 <LoRaMacParserJoinAccept+0x94>
 803640c:	6801      	ldr	r1, [r0, #0]
 803640e:	2900      	cmp	r1, #0
 8036410:	d042      	beq.n	8036498 <LoRaMacParserJoinAccept+0x94>
        return LORAMAC_PARSER_ERROR_NPE;
    }

    uint16_t bufItr = 0;

    macMsg->MHDR.Value = macMsg->Buffer[bufItr++];
 8036412:	f811 3b01 	ldrb.w	r3, [r1], #1
 8036416:	7143      	strb	r3, [r0, #5]

    memcpy1( macMsg->JoinNonce, &macMsg->Buffer[bufItr], 3 );
 8036418:	2203      	movs	r2, #3
 803641a:	3006      	adds	r0, #6
 803641c:	f002 fd50 	bl	8038ec0 <memcpy1>
    bufItr = bufItr + 3;

    memcpy1( macMsg->NetID, &macMsg->Buffer[bufItr], 3 );
 8036420:	4620      	mov	r0, r4
 8036422:	2203      	movs	r2, #3
 8036424:	f850 1b09 	ldr.w	r1, [r0], #9
 8036428:	3104      	adds	r1, #4
 803642a:	f002 fd49 	bl	8038ec0 <memcpy1>
    bufItr = bufItr + 3;

    macMsg->DevAddr = ( uint32_t ) macMsg->Buffer[bufItr++];
 803642e:	6821      	ldr	r1, [r4, #0]
 8036430:	79cb      	ldrb	r3, [r1, #7]
 8036432:	60e3      	str	r3, [r4, #12]
    macMsg->DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 8036434:	7a0a      	ldrb	r2, [r1, #8]
 8036436:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 803643a:	60e3      	str	r3, [r4, #12]
    macMsg->DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 803643c:	7a4a      	ldrb	r2, [r1, #9]
 803643e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8036442:	60e3      	str	r3, [r4, #12]
    macMsg->DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 24 );
 8036444:	7a8a      	ldrb	r2, [r1, #10]
 8036446:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 803644a:	60e3      	str	r3, [r4, #12]

    macMsg->DLSettings.Value = macMsg->Buffer[bufItr++];
 803644c:	7acb      	ldrb	r3, [r1, #11]
 803644e:	7423      	strb	r3, [r4, #16]

    macMsg->RxDelay = macMsg->Buffer[bufItr++];
 8036450:	7b0b      	ldrb	r3, [r1, #12]
 8036452:	7463      	strb	r3, [r4, #17]

    if( ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE - bufItr ) == LORAMAC_CF_LIST_FIELD_SIZE )
 8036454:	7923      	ldrb	r3, [r4, #4]
 8036456:	2b21      	cmp	r3, #33	; 0x21
 8036458:	d11a      	bne.n	8036490 <LoRaMacParserJoinAccept+0x8c>
    {
        memcpy1( macMsg->CFList, &macMsg->Buffer[bufItr], LORAMAC_CF_LIST_FIELD_SIZE );
 803645a:	2210      	movs	r2, #16
 803645c:	310d      	adds	r1, #13
 803645e:	f104 0012 	add.w	r0, r4, #18
 8036462:	f002 fd2d 	bl	8038ec0 <memcpy1>
        bufItr = bufItr + LORAMAC_CF_LIST_FIELD_SIZE;
 8036466:	221d      	movs	r2, #29
    else if( ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE - bufItr ) > 0 )
    {
        return LORAMAC_PARSER_FAIL;
    }

    macMsg->MIC = ( uint32_t ) macMsg->Buffer[bufItr++];
 8036468:	6821      	ldr	r1, [r4, #0]
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 803646a:	1c50      	adds	r0, r2, #1
    macMsg->MIC = ( uint32_t ) macMsg->Buffer[bufItr++];
 803646c:	5c8b      	ldrb	r3, [r1, r2]
 803646e:	6263      	str	r3, [r4, #36]	; 0x24
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 8036470:	5c08      	ldrb	r0, [r1, r0]
 8036472:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 8036476:	1c90      	adds	r0, r2, #2
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 8036478:	6263      	str	r3, [r4, #36]	; 0x24
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 803647a:	5c08      	ldrb	r0, [r1, r0]
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 24 );
 803647c:	3203      	adds	r2, #3
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 803647e:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
 8036482:	6263      	str	r3, [r4, #36]	; 0x24
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 24 );
 8036484:	5c8a      	ldrb	r2, [r1, r2]
 8036486:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 803648a:	6263      	str	r3, [r4, #36]	; 0x24

    return LORAMAC_PARSER_SUCCESS;
 803648c:	2000      	movs	r0, #0
}
 803648e:	bd10      	pop	{r4, pc}
    else if( ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE - bufItr ) > 0 )
 8036490:	2b11      	cmp	r3, #17
 8036492:	dc03      	bgt.n	803649c <LoRaMacParserJoinAccept+0x98>
    macMsg->RxDelay = macMsg->Buffer[bufItr++];
 8036494:	220d      	movs	r2, #13
 8036496:	e7e7      	b.n	8036468 <LoRaMacParserJoinAccept+0x64>
        return LORAMAC_PARSER_ERROR_NPE;
 8036498:	2002      	movs	r0, #2
 803649a:	e7f8      	b.n	803648e <LoRaMacParserJoinAccept+0x8a>
        return LORAMAC_PARSER_FAIL;
 803649c:	2001      	movs	r0, #1
 803649e:	e7f6      	b.n	803648e <LoRaMacParserJoinAccept+0x8a>

080364a0 <LoRaMacParserData>:

LoRaMacParserStatus_t LoRaMacParserData( LoRaMacMessageData_t* macMsg )
{
 80364a0:	b510      	push	{r4, lr}
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 80364a2:	4604      	mov	r4, r0
 80364a4:	2800      	cmp	r0, #0
 80364a6:	d054      	beq.n	8036552 <LoRaMacParserData+0xb2>
 80364a8:	6801      	ldr	r1, [r0, #0]
 80364aa:	2900      	cmp	r1, #0
 80364ac:	d051      	beq.n	8036552 <LoRaMacParserData+0xb2>
        return LORAMAC_PARSER_ERROR_NPE;
    }

    uint16_t bufItr = 0;

    macMsg->MHDR.Value = macMsg->Buffer[bufItr++];
 80364ae:	780b      	ldrb	r3, [r1, #0]
 80364b0:	7143      	strb	r3, [r0, #5]

    macMsg->FHDR.DevAddr = macMsg->Buffer[bufItr++];
 80364b2:	784b      	ldrb	r3, [r1, #1]
 80364b4:	6083      	str	r3, [r0, #8]
    macMsg->FHDR.DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 80364b6:	788a      	ldrb	r2, [r1, #2]
 80364b8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80364bc:	6083      	str	r3, [r0, #8]
    macMsg->FHDR.DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 80364be:	78ca      	ldrb	r2, [r1, #3]
 80364c0:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80364c4:	6083      	str	r3, [r0, #8]
    macMsg->FHDR.DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 24 );
 80364c6:	790a      	ldrb	r2, [r1, #4]
 80364c8:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80364cc:	6083      	str	r3, [r0, #8]

    macMsg->FHDR.FCtrl.Value = macMsg->Buffer[bufItr++];
 80364ce:	794b      	ldrb	r3, [r1, #5]
 80364d0:	7303      	strb	r3, [r0, #12]

    macMsg->FHDR.FCnt = macMsg->Buffer[bufItr++];
 80364d2:	798b      	ldrb	r3, [r1, #6]
 80364d4:	81c3      	strh	r3, [r0, #14]
    macMsg->FHDR.FCnt |= macMsg->Buffer[bufItr++] << 8;
 80364d6:	79ca      	ldrb	r2, [r1, #7]
 80364d8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8

    if( macMsg->FHDR.FCtrl.Bits.FOptsLen <= 15 )
    {
        memcpy1( macMsg->FHDR.FOpts, &macMsg->Buffer[bufItr], macMsg->FHDR.FCtrl.Bits.FOptsLen );
 80364dc:	7b02      	ldrb	r2, [r0, #12]
    macMsg->FHDR.FCnt |= macMsg->Buffer[bufItr++] << 8;
 80364de:	81c3      	strh	r3, [r0, #14]
        memcpy1( macMsg->FHDR.FOpts, &macMsg->Buffer[bufItr], macMsg->FHDR.FCtrl.Bits.FOptsLen );
 80364e0:	f002 020f 	and.w	r2, r2, #15
 80364e4:	3108      	adds	r1, #8
 80364e6:	3010      	adds	r0, #16
 80364e8:	f002 fcea 	bl	8038ec0 <memcpy1>
        bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 80364ec:	7b23      	ldrb	r3, [r4, #12]
    {
        return LORAMAC_PARSER_FAIL;
    }

    // Initialize anyway with zero.
    macMsg->FPort = 0;
 80364ee:	2200      	movs	r2, #0
        bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 80364f0:	f003 030f 	and.w	r3, r3, #15
    macMsg->FPort = 0;
 80364f4:	f884 2020 	strb.w	r2, [r4, #32]
    macMsg->FRMPayloadSize = 0;
 80364f8:	f884 2028 	strb.w	r2, [r4, #40]	; 0x28

    if( ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE ) > 0 )
 80364fc:	7922      	ldrb	r2, [r4, #4]
        bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 80364fe:	f103 0008 	add.w	r0, r3, #8
    if( ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE ) > 0 )
 8036502:	1a11      	subs	r1, r2, r0
 8036504:	2904      	cmp	r1, #4
 8036506:	dd0d      	ble.n	8036524 <LoRaMacParserData+0x84>
    {
        macMsg->FPort = macMsg->Buffer[bufItr++];
 8036508:	6821      	ldr	r1, [r4, #0]
 803650a:	3309      	adds	r3, #9

        macMsg->FRMPayloadSize = ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE );
 803650c:	3a04      	subs	r2, #4
 803650e:	1ad2      	subs	r2, r2, r3
        macMsg->FPort = macMsg->Buffer[bufItr++];
 8036510:	5c08      	ldrb	r0, [r1, r0]
 8036512:	f884 0020 	strb.w	r0, [r4, #32]
        macMsg->FRMPayloadSize = ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE );
 8036516:	b2d2      	uxtb	r2, r2
        memcpy1( macMsg->FRMPayload, &macMsg->Buffer[bufItr], macMsg->FRMPayloadSize );
 8036518:	6a60      	ldr	r0, [r4, #36]	; 0x24
        macMsg->FRMPayloadSize = ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE );
 803651a:	f884 2028 	strb.w	r2, [r4, #40]	; 0x28
        memcpy1( macMsg->FRMPayload, &macMsg->Buffer[bufItr], macMsg->FRMPayloadSize );
 803651e:	4419      	add	r1, r3
 8036520:	f002 fcce 	bl	8038ec0 <memcpy1>
        bufItr = bufItr + macMsg->FRMPayloadSize;
    }

    macMsg->MIC = ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE )];
 8036524:	7923      	ldrb	r3, [r4, #4]
 8036526:	6822      	ldr	r2, [r4, #0]
 8036528:	441a      	add	r2, r3
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 1] << 8 );
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 2] << 16 );
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 3] << 24 );

    return LORAMAC_PARSER_SUCCESS;
 803652a:	2000      	movs	r0, #0
    macMsg->MIC = ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE )];
 803652c:	f812 3c04 	ldrb.w	r3, [r2, #-4]
 8036530:	62e3      	str	r3, [r4, #44]	; 0x2c
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 1] << 8 );
 8036532:	f812 1c03 	ldrb.w	r1, [r2, #-3]
 8036536:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 803653a:	62e3      	str	r3, [r4, #44]	; 0x2c
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 2] << 16 );
 803653c:	f812 1c02 	ldrb.w	r1, [r2, #-2]
 8036540:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8036544:	62e3      	str	r3, [r4, #44]	; 0x2c
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 3] << 24 );
 8036546:	f812 2c01 	ldrb.w	r2, [r2, #-1]
 803654a:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 803654e:	62e3      	str	r3, [r4, #44]	; 0x2c
}
 8036550:	bd10      	pop	{r4, pc}
        return LORAMAC_PARSER_ERROR_NPE;
 8036552:	2002      	movs	r0, #2
 8036554:	e7fc      	b.n	8036550 <LoRaMacParserData+0xb0>

08036556 <LoRaMacSerializerJoinRequest>:
 */
#include "LoRaMacSerializer.h"
#include "utilities.h"

LoRaMacSerializerStatus_t LoRaMacSerializerJoinRequest( LoRaMacMessageJoinRequest_t* macMsg )
{
 8036556:	b510      	push	{r4, lr}
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 8036558:	4604      	mov	r4, r0
 803655a:	b360      	cbz	r0, 80365b6 <LoRaMacSerializerJoinRequest+0x60>
 803655c:	6803      	ldr	r3, [r0, #0]
 803655e:	b353      	cbz	r3, 80365b6 <LoRaMacSerializerJoinRequest+0x60>
    }

    uint16_t bufItr = 0;

    // Check macMsg->BufSize
    if( macMsg->BufSize < LORAMAC_JOIN_REQ_MSG_SIZE )
 8036560:	7902      	ldrb	r2, [r0, #4]
 8036562:	2a16      	cmp	r2, #22
 8036564:	d929      	bls.n	80365ba <LoRaMacSerializerJoinRequest+0x64>
    {
        return LORAMAC_SERIALIZER_ERROR_BUF_SIZE;
    }

    macMsg->Buffer[bufItr++] = macMsg->MHDR.Value;
 8036566:	7942      	ldrb	r2, [r0, #5]
 8036568:	701a      	strb	r2, [r3, #0]

    memcpyr( &macMsg->Buffer[bufItr], macMsg->JoinEUI, LORAMAC_JOIN_EUI_FIELD_SIZE );
 803656a:	4601      	mov	r1, r0
 803656c:	2208      	movs	r2, #8
 803656e:	f851 0b06 	ldr.w	r0, [r1], #6
 8036572:	3001      	adds	r0, #1
 8036574:	f002 fcae 	bl	8038ed4 <memcpyr>
    bufItr += LORAMAC_JOIN_EUI_FIELD_SIZE;

    memcpyr( &macMsg->Buffer[bufItr], macMsg->DevEUI, LORAMAC_DEV_EUI_FIELD_SIZE );
 8036578:	4621      	mov	r1, r4
 803657a:	2208      	movs	r2, #8
 803657c:	f851 0b0e 	ldr.w	r0, [r1], #14
 8036580:	3009      	adds	r0, #9
 8036582:	f002 fca7 	bl	8038ed4 <memcpyr>
    bufItr += LORAMAC_DEV_EUI_FIELD_SIZE;

    macMsg->Buffer[bufItr++] = macMsg->DevNonce & 0xFF;
 8036586:	6823      	ldr	r3, [r4, #0]
 8036588:	8ae2      	ldrh	r2, [r4, #22]
 803658a:	745a      	strb	r2, [r3, #17]
    macMsg->Buffer[bufItr++] = ( macMsg->DevNonce >> 8 ) & 0xFF;
 803658c:	8ae3      	ldrh	r3, [r4, #22]
 803658e:	6822      	ldr	r2, [r4, #0]
 8036590:	0a1b      	lsrs	r3, r3, #8
 8036592:	7493      	strb	r3, [r2, #18]

    macMsg->Buffer[bufItr++] = macMsg->MIC & 0xFF;
 8036594:	6823      	ldr	r3, [r4, #0]
 8036596:	69a2      	ldr	r2, [r4, #24]
 8036598:	74da      	strb	r2, [r3, #19]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 8 ) & 0xFF;
 803659a:	69a3      	ldr	r3, [r4, #24]
 803659c:	6822      	ldr	r2, [r4, #0]
 803659e:	0a1b      	lsrs	r3, r3, #8
 80365a0:	7513      	strb	r3, [r2, #20]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 16 ) & 0xFF;
 80365a2:	6823      	ldr	r3, [r4, #0]
 80365a4:	8b62      	ldrh	r2, [r4, #26]
 80365a6:	755a      	strb	r2, [r3, #21]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 24 ) & 0xFF;
 80365a8:	6823      	ldr	r3, [r4, #0]
 80365aa:	7ee2      	ldrb	r2, [r4, #27]
 80365ac:	759a      	strb	r2, [r3, #22]

    macMsg->BufSize = bufItr;
 80365ae:	2317      	movs	r3, #23
 80365b0:	7123      	strb	r3, [r4, #4]

    return LORAMAC_SERIALIZER_SUCCESS;
 80365b2:	2000      	movs	r0, #0
}
 80365b4:	bd10      	pop	{r4, pc}
        return LORAMAC_SERIALIZER_ERROR_NPE;
 80365b6:	2001      	movs	r0, #1
 80365b8:	e7fc      	b.n	80365b4 <LoRaMacSerializerJoinRequest+0x5e>
        return LORAMAC_SERIALIZER_ERROR_BUF_SIZE;
 80365ba:	2002      	movs	r0, #2
 80365bc:	e7fa      	b.n	80365b4 <LoRaMacSerializerJoinRequest+0x5e>

080365be <LoRaMacSerializerData>:

    return LORAMAC_SERIALIZER_SUCCESS;
}

LoRaMacSerializerStatus_t LoRaMacSerializerData( LoRaMacMessageData_t* macMsg )
{
 80365be:	b538      	push	{r3, r4, r5, lr}
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 80365c0:	4604      	mov	r4, r0
 80365c2:	2800      	cmp	r0, #0
 80365c4:	d063      	beq.n	803668e <LoRaMacSerializerData+0xd0>
 80365c6:	6801      	ldr	r1, [r0, #0]
 80365c8:	2900      	cmp	r1, #0
 80365ca:	d060      	beq.n	803668e <LoRaMacSerializerData+0xd0>
    uint16_t computedBufSize =   LORAMAC_MHDR_FIELD_SIZE
                               + LORAMAC_FHDR_DEV_ADDR_FIELD_SIZE
                               + LORAMAC_FHDR_F_CTRL_FIELD_SIZE
                               + LORAMAC_FHDR_F_CNT_FIELD_SIZE;

    computedBufSize += macMsg->FHDR.FCtrl.Bits.FOptsLen;
 80365cc:	7b03      	ldrb	r3, [r0, #12]

    if( macMsg->FRMPayloadSize > 0 )
 80365ce:	f890 2028 	ldrb.w	r2, [r0, #40]	; 0x28
    computedBufSize += macMsg->FHDR.FCtrl.Bits.FOptsLen;
 80365d2:	f003 030f 	and.w	r3, r3, #15
    if( macMsg->FRMPayloadSize > 0 )
 80365d6:	2a00      	cmp	r2, #0
 80365d8:	d157      	bne.n	803668a <LoRaMacSerializerData+0xcc>
    computedBufSize += macMsg->FHDR.FCtrl.Bits.FOptsLen;
 80365da:	3308      	adds	r3, #8
    }

    computedBufSize += macMsg->FRMPayloadSize;
    computedBufSize += LORAMAC_MIC_FIELD_SIZE;

    if( macMsg->BufSize < computedBufSize )
 80365dc:	7920      	ldrb	r0, [r4, #4]
    computedBufSize += LORAMAC_MIC_FIELD_SIZE;
 80365de:	3204      	adds	r2, #4
    if( macMsg->BufSize < computedBufSize )
 80365e0:	4413      	add	r3, r2
 80365e2:	4298      	cmp	r0, r3
 80365e4:	d355      	bcc.n	8036692 <LoRaMacSerializerData+0xd4>
    {
        return LORAMAC_SERIALIZER_ERROR_BUF_SIZE;
    }

    macMsg->Buffer[bufItr++] = macMsg->MHDR.Value;
 80365e6:	7963      	ldrb	r3, [r4, #5]
 80365e8:	700b      	strb	r3, [r1, #0]

    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr ) & 0xFF;
 80365ea:	6823      	ldr	r3, [r4, #0]
 80365ec:	68a2      	ldr	r2, [r4, #8]
 80365ee:	705a      	strb	r2, [r3, #1]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr >> 8 ) & 0xFF;
 80365f0:	68a3      	ldr	r3, [r4, #8]
 80365f2:	6822      	ldr	r2, [r4, #0]
 80365f4:	0a1b      	lsrs	r3, r3, #8
 80365f6:	7093      	strb	r3, [r2, #2]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr >> 16 ) & 0xFF;
 80365f8:	6823      	ldr	r3, [r4, #0]
 80365fa:	8962      	ldrh	r2, [r4, #10]
 80365fc:	70da      	strb	r2, [r3, #3]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr >> 24 ) & 0xFF;
 80365fe:	6823      	ldr	r3, [r4, #0]
 8036600:	7ae2      	ldrb	r2, [r4, #11]
 8036602:	711a      	strb	r2, [r3, #4]

    macMsg->Buffer[bufItr++] = macMsg->FHDR.FCtrl.Value;
 8036604:	6823      	ldr	r3, [r4, #0]
 8036606:	7b22      	ldrb	r2, [r4, #12]
 8036608:	715a      	strb	r2, [r3, #5]

    macMsg->Buffer[bufItr++] = macMsg->FHDR.FCnt & 0xFF;
 803660a:	6823      	ldr	r3, [r4, #0]
 803660c:	89e2      	ldrh	r2, [r4, #14]
 803660e:	719a      	strb	r2, [r3, #6]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.FCnt >> 8 ) & 0xFF;
 8036610:	89e3      	ldrh	r3, [r4, #14]
 8036612:	6822      	ldr	r2, [r4, #0]
 8036614:	0a1b      	lsrs	r3, r3, #8

    memcpy1( &macMsg->Buffer[bufItr], macMsg->FHDR.FOpts, macMsg->FHDR.FCtrl.Bits.FOptsLen );
 8036616:	4621      	mov	r1, r4
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.FCnt >> 8 ) & 0xFF;
 8036618:	71d3      	strb	r3, [r2, #7]
    memcpy1( &macMsg->Buffer[bufItr], macMsg->FHDR.FOpts, macMsg->FHDR.FCtrl.Bits.FOptsLen );
 803661a:	7b22      	ldrb	r2, [r4, #12]
 803661c:	f851 0b10 	ldr.w	r0, [r1], #16
 8036620:	f002 020f 	and.w	r2, r2, #15
 8036624:	3008      	adds	r0, #8
 8036626:	f002 fc4b 	bl	8038ec0 <memcpy1>
    bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 803662a:	7b23      	ldrb	r3, [r4, #12]

    if( macMsg->FRMPayloadSize > 0 )
 803662c:	f894 2028 	ldrb.w	r2, [r4, #40]	; 0x28
    bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 8036630:	f003 030f 	and.w	r3, r3, #15
 8036634:	f103 0508 	add.w	r5, r3, #8
    if( macMsg->FRMPayloadSize > 0 )
 8036638:	b12a      	cbz	r2, 8036646 <LoRaMacSerializerData+0x88>
    {
        macMsg->Buffer[bufItr++] = macMsg->FPort;
 803663a:	6822      	ldr	r2, [r4, #0]
 803663c:	f894 1020 	ldrb.w	r1, [r4, #32]
 8036640:	5551      	strb	r1, [r2, r5]
 8036642:	f103 0509 	add.w	r5, r3, #9
    }

    memcpy1( &macMsg->Buffer[bufItr], macMsg->FRMPayload, macMsg->FRMPayloadSize );
 8036646:	6820      	ldr	r0, [r4, #0]
 8036648:	f894 2028 	ldrb.w	r2, [r4, #40]	; 0x28
 803664c:	6a61      	ldr	r1, [r4, #36]	; 0x24
 803664e:	4428      	add	r0, r5
 8036650:	f002 fc36 	bl	8038ec0 <memcpy1>
    bufItr = bufItr + macMsg->FRMPayloadSize;
 8036654:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28

    macMsg->Buffer[bufItr++] = macMsg->MIC & 0xFF;
 8036658:	6822      	ldr	r2, [r4, #0]
 803665a:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
    bufItr = bufItr + macMsg->FRMPayloadSize;
 803665c:	442b      	add	r3, r5
    macMsg->Buffer[bufItr++] = macMsg->MIC & 0xFF;
 803665e:	54d1      	strb	r1, [r2, r3]
 8036660:	1c5a      	adds	r2, r3, #1
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 8 ) & 0xFF;
 8036662:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8036664:	6820      	ldr	r0, [r4, #0]
 8036666:	b292      	uxth	r2, r2
 8036668:	0a09      	lsrs	r1, r1, #8
 803666a:	5481      	strb	r1, [r0, r2]
 803666c:	1c9a      	adds	r2, r3, #2
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 16 ) & 0xFF;
 803666e:	6821      	ldr	r1, [r4, #0]
 8036670:	8de0      	ldrh	r0, [r4, #46]	; 0x2e
 8036672:	b292      	uxth	r2, r2
 8036674:	5488      	strb	r0, [r1, r2]
 8036676:	1cda      	adds	r2, r3, #3
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 24 ) & 0xFF;
 8036678:	6821      	ldr	r1, [r4, #0]
 803667a:	f894 002f 	ldrb.w	r0, [r4, #47]	; 0x2f
 803667e:	b292      	uxth	r2, r2
 8036680:	3304      	adds	r3, #4
 8036682:	5488      	strb	r0, [r1, r2]

    macMsg->BufSize = bufItr;
 8036684:	7123      	strb	r3, [r4, #4]

    return LORAMAC_SERIALIZER_SUCCESS;
 8036686:	2000      	movs	r0, #0
}
 8036688:	bd38      	pop	{r3, r4, r5, pc}
        computedBufSize += LORAMAC_F_PORT_FIELD_SIZE;
 803668a:	3309      	adds	r3, #9
 803668c:	e7a6      	b.n	80365dc <LoRaMacSerializerData+0x1e>
        return LORAMAC_SERIALIZER_ERROR_NPE;
 803668e:	2001      	movs	r0, #1
 8036690:	e7fa      	b.n	8036688 <LoRaMacSerializerData+0xca>
        return LORAMAC_SERIALIZER_ERROR_BUF_SIZE;
 8036692:	2002      	movs	r0, #2
 8036694:	e7f8      	b.n	8036688 <LoRaMacSerializerData+0xca>

08036696 <NvmDataMgmtEvent>:
void NvmDataMgmtEvent( uint16_t notifyFlags )
{
#if( CONTEXT_MANAGEMENT_ENABLED == 1 )
    NvmNotifyFlags = notifyFlags;
#endif /* CONTEXT_MANAGEMENT_ENABLED == 1 */
}
 8036696:	4770      	bx	lr

08036698 <NvmDataMgmtStore>:
    LoRaMacStart( );
    return dataSize;
#else
    return 0;
#endif
}
 8036698:	2000      	movs	r0, #0
 803669a:	4770      	bx	lr

0803669c <NvmDataMgmtRestore>:
 803669c:	2000      	movs	r0, #0
 803669e:	4770      	bx	lr

080366a0 <RegionIsActive>:
#define RU864_RX_BEACON_SETUP( )
#endif

bool RegionIsActive( LoRaMacRegion_t region )
{
    switch( region )
 80366a0:	2805      	cmp	r0, #5
 80366a2:	d004      	beq.n	80366ae <RegionIsActive+0xe>
 80366a4:	f1a0 0308 	sub.w	r3, r0, #8
 80366a8:	4258      	negs	r0, r3
 80366aa:	4158      	adcs	r0, r3
 80366ac:	4770      	bx	lr
        AS923_IS_ACTIVE( );
        AU915_IS_ACTIVE( );
        CN470_IS_ACTIVE( );
        CN779_IS_ACTIVE( );
        EU433_IS_ACTIVE( );
        EU868_IS_ACTIVE( );
 80366ae:	2001      	movs	r0, #1
        default:
        {
            return false;
        }
    }
}
 80366b0:	4770      	bx	lr

080366b2 <RegionGetPhyParam>:

PhyParam_t RegionGetPhyParam( LoRaMacRegion_t region, GetPhyParams_t* getPhy )
{
 80366b2:	4603      	mov	r3, r0
    PhyParam_t phyParam = { 0 };
    switch( region )
 80366b4:	2b05      	cmp	r3, #5
{
 80366b6:	b082      	sub	sp, #8
 80366b8:	4608      	mov	r0, r1
    switch( region )
 80366ba:	d004      	beq.n	80366c6 <RegionGetPhyParam+0x14>
 80366bc:	2b08      	cmp	r3, #8
 80366be:	d005      	beq.n	80366cc <RegionGetPhyParam+0x1a>
        default:
        {
            return phyParam;
        }
    }
}
 80366c0:	2000      	movs	r0, #0
 80366c2:	b002      	add	sp, #8
 80366c4:	4770      	bx	lr
 80366c6:	b002      	add	sp, #8
        EU868_GET_PHY_PARAM( );
 80366c8:	f000 bcf4 	b.w	80370b4 <RegionEU868GetPhyParam>
}
 80366cc:	b002      	add	sp, #8
        US915_GET_PHY_PARAM( );
 80366ce:	f001 ba35 	b.w	8037b3c <RegionUS915GetPhyParam>

080366d2 <RegionSetBandTxDone>:

void RegionSetBandTxDone( LoRaMacRegion_t region, SetBandTxDoneParams_t* txDone )
{
 80366d2:	4603      	mov	r3, r0
    switch( region )
 80366d4:	2b05      	cmp	r3, #5
{
 80366d6:	4608      	mov	r0, r1
    switch( region )
 80366d8:	d002      	beq.n	80366e0 <RegionSetBandTxDone+0xe>
 80366da:	2b08      	cmp	r3, #8
 80366dc:	d002      	beq.n	80366e4 <RegionSetBandTxDone+0x12>
 80366de:	4770      	bx	lr
        AS923_SET_BAND_TX_DONE( );
        AU915_SET_BAND_TX_DONE( );
        CN470_SET_BAND_TX_DONE( );
        CN779_SET_BAND_TX_DONE( );
        EU433_SET_BAND_TX_DONE( );
        EU868_SET_BAND_TX_DONE( );
 80366e0:	f000 bd88 	b.w	80371f4 <RegionEU868SetBandTxDone>
        KR920_SET_BAND_TX_DONE( );
        IN865_SET_BAND_TX_DONE( );
        US915_SET_BAND_TX_DONE( );
 80366e4:	f001 bad4 	b.w	8037c90 <RegionUS915SetBandTxDone>

080366e8 <RegionInitDefaults>:
        }
    }
}

void RegionInitDefaults( LoRaMacRegion_t region, InitDefaultsParams_t* params )
{
 80366e8:	4603      	mov	r3, r0
    switch( region )
 80366ea:	2b05      	cmp	r3, #5
{
 80366ec:	4608      	mov	r0, r1
    switch( region )
 80366ee:	d002      	beq.n	80366f6 <RegionInitDefaults+0xe>
 80366f0:	2b08      	cmp	r3, #8
 80366f2:	d002      	beq.n	80366fa <RegionInitDefaults+0x12>
 80366f4:	4770      	bx	lr
        AS923_INIT_DEFAULTS( );
        AU915_INIT_DEFAULTS( );
        CN470_INIT_DEFAULTS( );
        CN779_INIT_DEFAULTS( );
        EU433_INIT_DEFAULTS( );
        EU868_INIT_DEFAULTS( );
 80366f6:	f000 bd95 	b.w	8037224 <RegionEU868InitDefaults>
        KR920_INIT_DEFAULTS( );
        IN865_INIT_DEFAULTS( );
        US915_INIT_DEFAULTS( );
 80366fa:	f001 bae1 	b.w	8037cc0 <RegionUS915InitDefaults>

080366fe <RegionVerify>:
        }
    }
}

bool RegionVerify( LoRaMacRegion_t region, VerifyParams_t* verify, PhyAttribute_t phyAttribute )
{
 80366fe:	4603      	mov	r3, r0
    switch( region )
 8036700:	2b05      	cmp	r3, #5
{
 8036702:	4608      	mov	r0, r1
 8036704:	4611      	mov	r1, r2
    switch( region )
 8036706:	d003      	beq.n	8036710 <RegionVerify+0x12>
 8036708:	2b08      	cmp	r3, #8
 803670a:	d003      	beq.n	8036714 <RegionVerify+0x16>
        default:
        {
            return false;
        }
    }
}
 803670c:	2000      	movs	r0, #0
 803670e:	4770      	bx	lr
        EU868_VERIFY( );
 8036710:	f000 bdea 	b.w	80372e8 <RegionEU868Verify>
        US915_VERIFY( );
 8036714:	f001 bb56 	b.w	8037dc4 <RegionUS915Verify>

08036718 <RegionApplyCFList>:

void RegionApplyCFList( LoRaMacRegion_t region, ApplyCFListParams_t* applyCFList )
{
 8036718:	4603      	mov	r3, r0
    switch( region )
 803671a:	2b05      	cmp	r3, #5
{
 803671c:	4608      	mov	r0, r1
    switch( region )
 803671e:	d002      	beq.n	8036726 <RegionApplyCFList+0xe>
 8036720:	2b08      	cmp	r3, #8
 8036722:	d002      	beq.n	803672a <RegionApplyCFList+0x12>
 8036724:	4770      	bx	lr
        AS923_APPLY_CF_LIST( );
        AU915_APPLY_CF_LIST( );
        CN470_APPLY_CF_LIST( );
        CN779_APPLY_CF_LIST( );
        EU433_APPLY_CF_LIST( );
        EU868_APPLY_CF_LIST( );
 8036726:	f001 b93f 	b.w	80379a8 <RegionEU868ApplyCFList>
        KR920_APPLY_CF_LIST( );
        IN865_APPLY_CF_LIST( );
        US915_APPLY_CF_LIST( );
 803672a:	f001 bb6d 	b.w	8037e08 <RegionUS915ApplyCFList>

0803672e <RegionChanMaskSet>:
        }
    }
}

bool RegionChanMaskSet( LoRaMacRegion_t region, ChanMaskSetParams_t* chanMaskSet )
{
 803672e:	4603      	mov	r3, r0
    switch( region )
 8036730:	2b05      	cmp	r3, #5
{
 8036732:	4608      	mov	r0, r1
    switch( region )
 8036734:	d003      	beq.n	803673e <RegionChanMaskSet+0x10>
 8036736:	2b08      	cmp	r3, #8
 8036738:	d003      	beq.n	8036742 <RegionChanMaskSet+0x14>
        default:
        {
            return false;
        }
    }
}
 803673a:	2000      	movs	r0, #0
 803673c:	4770      	bx	lr
        EU868_CHAN_MASK_SET( );
 803673e:	f000 bdfb 	b.w	8037338 <RegionEU868ChanMaskSet>
        US915_CHAN_MASK_SET( );
 8036742:	f001 bb8b 	b.w	8037e5c <RegionUS915ChanMaskSet>

08036746 <RegionComputeRxWindowParameters>:

void RegionComputeRxWindowParameters( LoRaMacRegion_t region, int8_t datarate, uint8_t minRxSymbols, uint32_t rxError, RxConfigParams_t *rxConfigParams )
{
 8036746:	b410      	push	{r4}
 8036748:	4604      	mov	r4, r0
    switch( region )
 803674a:	2c05      	cmp	r4, #5
{
 803674c:	4608      	mov	r0, r1
 803674e:	4611      	mov	r1, r2
 8036750:	461a      	mov	r2, r3
 8036752:	9b01      	ldr	r3, [sp, #4]
    switch( region )
 8036754:	d003      	beq.n	803675e <RegionComputeRxWindowParameters+0x18>
 8036756:	2c08      	cmp	r4, #8
 8036758:	d004      	beq.n	8036764 <RegionComputeRxWindowParameters+0x1e>
        default:
        {
            break;
        }
    }
}
 803675a:	bc10      	pop	{r4}
 803675c:	4770      	bx	lr
 803675e:	bc10      	pop	{r4}
        EU868_COMPUTE_RX_WINDOW_PARAMETERS( );
 8036760:	f000 be08 	b.w	8037374 <RegionEU868ComputeRxWindowParameters>
}
 8036764:	bc10      	pop	{r4}
        US915_COMPUTE_RX_WINDOW_PARAMETERS( );
 8036766:	f001 bbb3 	b.w	8037ed0 <RegionUS915ComputeRxWindowParameters>

0803676a <RegionRxConfig>:

bool RegionRxConfig( LoRaMacRegion_t region, RxConfigParams_t* rxConfig, int8_t* datarate )
{
 803676a:	4603      	mov	r3, r0
    switch( region )
 803676c:	2b05      	cmp	r3, #5
{
 803676e:	4608      	mov	r0, r1
 8036770:	4611      	mov	r1, r2
    switch( region )
 8036772:	d003      	beq.n	803677c <RegionRxConfig+0x12>
 8036774:	2b08      	cmp	r3, #8
 8036776:	d003      	beq.n	8036780 <RegionRxConfig+0x16>
        default:
        {
            return false;
        }
    }
}
 8036778:	2000      	movs	r0, #0
 803677a:	4770      	bx	lr
        EU868_RX_CONFIG( );
 803677c:	f000 be2c 	b.w	80373d8 <RegionEU868RxConfig>
        US915_RX_CONFIG( );
 8036780:	f001 bbd2 	b.w	8037f28 <RegionUS915RxConfig>

08036784 <RegionTxConfig>:

bool RegionTxConfig( LoRaMacRegion_t region, TxConfigParams_t* txConfig, int8_t* txPower, TimerTime_t* txTimeOnAir )
{
 8036784:	b410      	push	{r4}
 8036786:	4604      	mov	r4, r0
    switch( region )
 8036788:	2c05      	cmp	r4, #5
{
 803678a:	4608      	mov	r0, r1
 803678c:	4611      	mov	r1, r2
 803678e:	461a      	mov	r2, r3
    switch( region )
 8036790:	d004      	beq.n	803679c <RegionTxConfig+0x18>
 8036792:	2c08      	cmp	r4, #8
 8036794:	d005      	beq.n	80367a2 <RegionTxConfig+0x1e>
        default:
        {
            return false;
        }
    }
}
 8036796:	2000      	movs	r0, #0
 8036798:	bc10      	pop	{r4}
 803679a:	4770      	bx	lr
 803679c:	bc10      	pop	{r4}
        EU868_TX_CONFIG( );
 803679e:	f000 be99 	b.w	80374d4 <RegionEU868TxConfig>
}
 80367a2:	bc10      	pop	{r4}
        US915_TX_CONFIG( );
 80367a4:	f001 bc14 	b.w	8037fd0 <RegionUS915TxConfig>

080367a8 <RegionLinkAdrReq>:

uint8_t RegionLinkAdrReq( LoRaMacRegion_t region, LinkAdrReqParams_t* linkAdrReq, int8_t* drOut, int8_t* txPowOut, uint8_t* nbRepOut, uint8_t* nbBytesParsed )
{
 80367a8:	b430      	push	{r4, r5}
 80367aa:	4604      	mov	r4, r0
    switch( region )
 80367ac:	2c05      	cmp	r4, #5
{
 80367ae:	4608      	mov	r0, r1
 80367b0:	4611      	mov	r1, r2
 80367b2:	461a      	mov	r2, r3
 80367b4:	e9dd 3502 	ldrd	r3, r5, [sp, #8]
    switch( region )
 80367b8:	d004      	beq.n	80367c4 <RegionLinkAdrReq+0x1c>
 80367ba:	2c08      	cmp	r4, #8
 80367bc:	d006      	beq.n	80367cc <RegionLinkAdrReq+0x24>
        default:
        {
            return 0;
        }
    }
}
 80367be:	2000      	movs	r0, #0
 80367c0:	bc30      	pop	{r4, r5}
 80367c2:	4770      	bx	lr
        EU868_LINK_ADR_REQ( );
 80367c4:	9502      	str	r5, [sp, #8]
}
 80367c6:	bc30      	pop	{r4, r5}
        EU868_LINK_ADR_REQ( );
 80367c8:	f000 bf08 	b.w	80375dc <RegionEU868LinkAdrReq>
        US915_LINK_ADR_REQ( );
 80367cc:	9502      	str	r5, [sp, #8]
}
 80367ce:	bc30      	pop	{r4, r5}
        US915_LINK_ADR_REQ( );
 80367d0:	f001 bc86 	b.w	80380e0 <RegionUS915LinkAdrReq>

080367d4 <RegionRxParamSetupReq>:

uint8_t RegionRxParamSetupReq( LoRaMacRegion_t region, RxParamSetupReqParams_t* rxParamSetupReq )
{
 80367d4:	4603      	mov	r3, r0
    switch( region )
 80367d6:	2b05      	cmp	r3, #5
{
 80367d8:	4608      	mov	r0, r1
    switch( region )
 80367da:	d003      	beq.n	80367e4 <RegionRxParamSetupReq+0x10>
 80367dc:	2b08      	cmp	r3, #8
 80367de:	d003      	beq.n	80367e8 <RegionRxParamSetupReq+0x14>
        default:
        {
            return 0;
        }
    }
}
 80367e0:	2000      	movs	r0, #0
 80367e2:	4770      	bx	lr
        EU868_RX_PARAM_SETUP_REQ( );
 80367e4:	f000 bfa8 	b.w	8037738 <RegionEU868RxParamSetupReq>
        US915_RX_PARAM_SETUP_REQ( );
 80367e8:	f001 bd90 	b.w	803830c <RegionUS915RxParamSetupReq>

080367ec <RegionNewChannelReq>:

int8_t RegionNewChannelReq( LoRaMacRegion_t region, NewChannelReqParams_t* newChannelReq )
{
 80367ec:	4603      	mov	r3, r0
    switch( region )
 80367ee:	2b05      	cmp	r3, #5
{
 80367f0:	4608      	mov	r0, r1
    switch( region )
 80367f2:	d003      	beq.n	80367fc <RegionNewChannelReq+0x10>
 80367f4:	2b08      	cmp	r3, #8
 80367f6:	d003      	beq.n	8036800 <RegionNewChannelReq+0x14>
        default:
        {
            return 0;
        }
    }
}
 80367f8:	2000      	movs	r0, #0
 80367fa:	4770      	bx	lr
        EU868_NEW_CHANNEL_REQ( );
 80367fc:	f001 b912 	b.w	8037a24 <RegionEU868NewChannelReq>
        US915_NEW_CHANNEL_REQ( );
 8036800:	f001 bdb0 	b.w	8038364 <RegionUS915NewChannelReq>

08036804 <RegionTxParamSetupReq>:

int8_t RegionTxParamSetupReq( LoRaMacRegion_t region, TxParamSetupReqParams_t* txParamSetupReq )
{
 8036804:	4603      	mov	r3, r0
    switch( region )
 8036806:	2b05      	cmp	r3, #5
{
 8036808:	4608      	mov	r0, r1
    switch( region )
 803680a:	d003      	beq.n	8036814 <RegionTxParamSetupReq+0x10>
 803680c:	2b08      	cmp	r3, #8
 803680e:	d003      	beq.n	8036818 <RegionTxParamSetupReq+0x14>
        default:
        {
            return 0;
        }
    }
}
 8036810:	2000      	movs	r0, #0
 8036812:	4770      	bx	lr
        EU868_TX_PARAM_SETUP_REQ( );
 8036814:	f000 bfb3 	b.w	803777e <RegionEU868TxParamSetupReq>
        US915_TX_PARAM_SETUP_REQ( );
 8036818:	f001 bda7 	b.w	803836a <RegionUS915TxParamSetupReq>

0803681c <RegionDlChannelReq>:

int8_t RegionDlChannelReq( LoRaMacRegion_t region, DlChannelReqParams_t* dlChannelReq )
{
 803681c:	4603      	mov	r3, r0
    switch( region )
 803681e:	2b05      	cmp	r3, #5
{
 8036820:	4608      	mov	r0, r1
    switch( region )
 8036822:	d003      	beq.n	803682c <RegionDlChannelReq+0x10>
 8036824:	2b08      	cmp	r3, #8
 8036826:	d003      	beq.n	8036830 <RegionDlChannelReq+0x14>
        default:
        {
            return 0;
        }
    }
}
 8036828:	2000      	movs	r0, #0
 803682a:	4770      	bx	lr
        EU868_DL_CHANNEL_REQ( );
 803682c:	f000 bfaa 	b.w	8037784 <RegionEU868DlChannelReq>
        US915_DL_CHANNEL_REQ( );
 8036830:	f001 bd9e 	b.w	8038370 <RegionUS915DlChannelReq>

08036834 <RegionAlternateDr>:

int8_t RegionAlternateDr( LoRaMacRegion_t region, int8_t currentDr, AlternateDrType_t type )
{
 8036834:	4603      	mov	r3, r0
    switch( region )
 8036836:	2b05      	cmp	r3, #5
{
 8036838:	4608      	mov	r0, r1
 803683a:	4611      	mov	r1, r2
    switch( region )
 803683c:	d003      	beq.n	8036846 <RegionAlternateDr+0x12>
 803683e:	2b08      	cmp	r3, #8
 8036840:	d003      	beq.n	803684a <RegionAlternateDr+0x16>
        default:
        {
            return 0;
        }
    }
}
 8036842:	2000      	movs	r0, #0
 8036844:	4770      	bx	lr
        EU868_ALTERNATE_DR( );
 8036846:	f000 bfc1 	b.w	80377cc <RegionEU868AlternateDr>
        US915_ALTERNATE_DR( );
 803684a:	f001 bd95 	b.w	8038378 <RegionUS915AlternateDr>

0803684e <RegionNextChannel>:

LoRaMacStatus_t RegionNextChannel( LoRaMacRegion_t region, NextChanParams_t* nextChanParams, uint8_t* channel, TimerTime_t* time, TimerTime_t* aggregatedTimeOff )
{
 803684e:	b410      	push	{r4}
 8036850:	4604      	mov	r4, r0
    switch( region )
 8036852:	2c05      	cmp	r4, #5
{
 8036854:	4608      	mov	r0, r1
 8036856:	4611      	mov	r1, r2
 8036858:	461a      	mov	r2, r3
 803685a:	9b01      	ldr	r3, [sp, #4]
    switch( region )
 803685c:	d004      	beq.n	8036868 <RegionNextChannel+0x1a>
 803685e:	2c08      	cmp	r4, #8
 8036860:	d005      	beq.n	803686e <RegionNextChannel+0x20>
        default:
        {
            return LORAMAC_STATUS_REGION_NOT_SUPPORTED;
        }
    }
}
 8036862:	2009      	movs	r0, #9
 8036864:	bc10      	pop	{r4}
 8036866:	4770      	bx	lr
 8036868:	bc10      	pop	{r4}
        EU868_NEXT_CHANNEL( );
 803686a:	f000 bfb1 	b.w	80377d0 <RegionEU868NextChannel>
}
 803686e:	bc10      	pop	{r4}
        US915_NEXT_CHANNEL( );
 8036870:	f001 bd9a 	b.w	80383a8 <RegionUS915NextChannel>

08036874 <RegionSetContinuousWave>:
        }
    }
}

void RegionSetContinuousWave( LoRaMacRegion_t region, ContinuousWaveParams_t* continuousWave )
{
 8036874:	4603      	mov	r3, r0
    switch( region )
 8036876:	2b05      	cmp	r3, #5
{
 8036878:	4608      	mov	r0, r1
    switch( region )
 803687a:	d002      	beq.n	8036882 <RegionSetContinuousWave+0xe>
 803687c:	2b08      	cmp	r3, #8
 803687e:	d002      	beq.n	8036886 <RegionSetContinuousWave+0x12>
 8036880:	4770      	bx	lr
        AS923_SET_CONTINUOUS_WAVE( );
        AU915_SET_CONTINUOUS_WAVE( );
        CN470_SET_CONTINUOUS_WAVE( );
        CN779_SET_CONTINUOUS_WAVE( );
        EU433_SET_CONTINUOUS_WAVE( );
        EU868_SET_CONTINUOUS_WAVE( );
 8036882:	f001 b8f1 	b.w	8037a68 <RegionEU868SetContinuousWave>
        KR920_SET_CONTINUOUS_WAVE( );
        IN865_SET_CONTINUOUS_WAVE( );
        US915_SET_CONTINUOUS_WAVE( );
 8036886:	f001 be2b 	b.w	80384e0 <RegionUS915SetContinuousWave>

0803688a <RegionApplyDrOffset>:
        }
    }
}

uint8_t RegionApplyDrOffset( LoRaMacRegion_t region, uint8_t downlinkDwellTime, int8_t dr, int8_t drOffset )
{
 803688a:	b410      	push	{r4}
 803688c:	4604      	mov	r4, r0
    switch( region )
 803688e:	2c05      	cmp	r4, #5
{
 8036890:	4608      	mov	r0, r1
 8036892:	4611      	mov	r1, r2
 8036894:	461a      	mov	r2, r3
    switch( region )
 8036896:	d004      	beq.n	80368a2 <RegionApplyDrOffset+0x18>
 8036898:	2c08      	cmp	r4, #8
 803689a:	d005      	beq.n	80368a8 <RegionApplyDrOffset+0x1e>
        default:
        {
            return dr;
        }
    }
}
 803689c:	b2c8      	uxtb	r0, r1
 803689e:	bc10      	pop	{r4}
 80368a0:	4770      	bx	lr
 80368a2:	bc10      	pop	{r4}
        EU868_APPLY_DR_OFFSET( );
 80368a4:	f001 b908 	b.w	8037ab8 <RegionEU868ApplyDrOffset>
}
 80368a8:	bc10      	pop	{r4}
        US915_APPLY_DR_OFFSET( );
 80368aa:	f001 be61 	b.w	8038570 <RegionUS915ApplyDrOffset>
	...

080368b0 <RegionGetVersion>:
    Version_t version;

    version.Value = REGION_VERSION;

    return version;
}
 80368b0:	4800      	ldr	r0, [pc, #0]	; (80368b4 <RegionGetVersion+0x4>)
 80368b2:	4770      	bx	lr
 80368b4:	01000300 	.word	0x01000300

080368b8 <RegionBaseUSComputeNext125kHzJoinChannel>:
    return LORAMAC_STATUS_OK;
}

LoRaMacStatus_t RegionBaseUSComputeNext125kHzJoinChannel( uint16_t* channelsMaskRemaining,
                                                          uint8_t* groupsCurrentIndex, uint8_t* newChannelIndex )
{
 80368b8:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    uint8_t currentChannelMaskLeftIndex;
    uint16_t currentChannelMaskLeft;
    uint8_t findAvailableChannelsIndex[8] = { 0 };
 80368bc:	2300      	movs	r3, #0
 80368be:	e9cd 3300 	strd	r3, r3, [sp]
{
 80368c2:	460e      	mov	r6, r1
 80368c4:	4690      	mov	r8, r2
    uint8_t availableChannels = 0;
    uint8_t startIndex;

    // Null pointer check
    if( channelsMaskRemaining == NULL || groupsCurrentIndex == NULL || newChannelIndex == NULL )
 80368c6:	4607      	mov	r7, r0
 80368c8:	b918      	cbnz	r0, 80368d2 <RegionBaseUSComputeNext125kHzJoinChannel+0x1a>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
 80368ca:	2003      	movs	r0, #3
        *groupsCurrentIndex = startIndex;
        return LORAMAC_STATUS_OK;
    }

    return LORAMAC_STATUS_PARAMETER_INVALID;
}
 80368cc:	b002      	add	sp, #8
 80368ce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if( channelsMaskRemaining == NULL || groupsCurrentIndex == NULL || newChannelIndex == NULL )
 80368d2:	2900      	cmp	r1, #0
 80368d4:	d0f9      	beq.n	80368ca <RegionBaseUSComputeNext125kHzJoinChannel+0x12>
 80368d6:	2a00      	cmp	r2, #0
 80368d8:	d0f7      	beq.n	80368ca <RegionBaseUSComputeNext125kHzJoinChannel+0x12>
    startIndex = *groupsCurrentIndex;
 80368da:	780c      	ldrb	r4, [r1, #0]
        if( ( startIndex % 2 ) == 0 )
 80368dc:	0863      	lsrs	r3, r4, #1
 80368de:	07e0      	lsls	r0, r4, #31
            currentChannelMaskLeft = ( channelsMaskRemaining[currentChannelMaskLeftIndex] & 0x00FF );
 80368e0:	f837 1013 	ldrh.w	r1, [r7, r3, lsl #1]
{
 80368e4:	f04f 0300 	mov.w	r3, #0
            currentChannelMaskLeft = ( channelsMaskRemaining[currentChannelMaskLeftIndex] & 0x00FF );
 80368e8:	bf54      	ite	pl
 80368ea:	b2c9      	uxtbpl	r1, r1
            currentChannelMaskLeft = ( ( channelsMaskRemaining[currentChannelMaskLeftIndex] >> 8 ) & 0x00FF );
 80368ec:	0a09      	lsrmi	r1, r1, #8
    *availableChannels = 0;
 80368ee:	461d      	mov	r5, r3
        if( ( currentChannelMaskLeft & ( 1 << i ) ) != 0 )
 80368f0:	fa41 f203 	asr.w	r2, r1, r3
 80368f4:	07d2      	lsls	r2, r2, #31
 80368f6:	b2d8      	uxtb	r0, r3
 80368f8:	d505      	bpl.n	8036906 <RegionBaseUSComputeNext125kHzJoinChannel+0x4e>
            findAvailableChannelsIndex[*availableChannels] = i;
 80368fa:	aa02      	add	r2, sp, #8
 80368fc:	442a      	add	r2, r5
            ( *availableChannels )++;
 80368fe:	3501      	adds	r5, #1
            findAvailableChannelsIndex[*availableChannels] = i;
 8036900:	f802 0c08 	strb.w	r0, [r2, #-8]
            ( *availableChannels )++;
 8036904:	b2ed      	uxtb	r5, r5
    for( uint8_t i = 0; i < 8; i++ )
 8036906:	3301      	adds	r3, #1
 8036908:	2b08      	cmp	r3, #8
 803690a:	d1f1      	bne.n	80368f0 <RegionBaseUSComputeNext125kHzJoinChannel+0x38>
        if ( availableChannels > 0 )
 803690c:	b15d      	cbz	r5, 8036926 <RegionBaseUSComputeNext125kHzJoinChannel+0x6e>
            *newChannelIndex = ( startIndex * 8 ) + findAvailableChannelsIndex[randr( 0, ( availableChannels - 1 ) )];
 803690e:	1e69      	subs	r1, r5, #1
 8036910:	2000      	movs	r0, #0
 8036912:	f002 fab9 	bl	8038e88 <randr>
 8036916:	ab02      	add	r3, sp, #8
 8036918:	4418      	add	r0, r3
 803691a:	f810 3c08 	ldrb.w	r3, [r0, #-8]
 803691e:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 8036922:	f888 3000 	strb.w	r3, [r8]
        startIndex++;
 8036926:	3401      	adds	r4, #1
 8036928:	b2e4      	uxtb	r4, r4
            startIndex = 0;
 803692a:	2c08      	cmp	r4, #8
 803692c:	bf28      	it	cs
 803692e:	2400      	movcs	r4, #0
    } while( ( availableChannels == 0 ) && ( startIndex != *groupsCurrentIndex ) );
 8036930:	b91d      	cbnz	r5, 803693a <RegionBaseUSComputeNext125kHzJoinChannel+0x82>
 8036932:	7833      	ldrb	r3, [r6, #0]
 8036934:	42a3      	cmp	r3, r4
 8036936:	d1d1      	bne.n	80368dc <RegionBaseUSComputeNext125kHzJoinChannel+0x24>
 8036938:	e7c7      	b.n	80368ca <RegionBaseUSComputeNext125kHzJoinChannel+0x12>
        *groupsCurrentIndex = startIndex;
 803693a:	7034      	strb	r4, [r6, #0]
        return LORAMAC_STATUS_OK;
 803693c:	2000      	movs	r0, #0
 803693e:	e7c5      	b.n	80368cc <RegionBaseUSComputeNext125kHzJoinChannel+0x14>

08036940 <RegionBaseUSCalcDownlinkFrequency>:
uint32_t RegionBaseUSCalcDownlinkFrequency( uint8_t channel, uint32_t frequency,
                                            uint32_t stepwidth )
{
    // Calculate the frequency
    return frequency + ( channel * stepwidth );
}
 8036940:	fb02 1000 	mla	r0, r2, r0, r1
 8036944:	4770      	bx	lr

08036946 <RegionCommonChanVerifyDr>:
    }
    return nbActiveBits;
}

bool RegionCommonChanVerifyDr( uint8_t nbChannels, uint16_t* channelsMask, int8_t dr, int8_t minDr, int8_t maxDr, ChannelParams_t* channels )
{
 8036946:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    return false;
}

uint8_t RegionCommonValueInRange( int8_t value, int8_t min, int8_t max )
{
    if( ( value >= min ) && ( value <= max ) )
 803694a:	429a      	cmp	r2, r3
{
 803694c:	9f07      	ldr	r7, [sp, #28]
    if( ( value >= min ) && ( value <= max ) )
 803694e:	db03      	blt.n	8036958 <RegionCommonChanVerifyDr+0x12>
 8036950:	f99d 3018 	ldrsb.w	r3, [sp, #24]
 8036954:	429a      	cmp	r2, r3
 8036956:	dd24      	ble.n	80369a2 <RegionCommonChanVerifyDr+0x5c>
        return false;
 8036958:	2000      	movs	r0, #0
}
 803695a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            if( ( ( channelsMask[k] & ( 1 << j ) ) != 0 ) )
 803695e:	f831 8014 	ldrh.w	r8, [r1, r4, lsl #1]
 8036962:	fb1e 7303 	smlabb	r3, lr, r3, r7
 8036966:	2500      	movs	r5, #0
 8036968:	fa48 f605 	asr.w	r6, r8, r5
 803696c:	07f6      	lsls	r6, r6, #31
 803696e:	d50e      	bpl.n	803698e <RegionCommonChanVerifyDr+0x48>
                if( RegionCommonValueInRange( dr, ( channels[i + j].DrRange.Fields.Min & 0x0F ),
 8036970:	fb0e 3605 	mla	r6, lr, r5, r3
                                                  ( channels[i + j].DrRange.Fields.Max & 0x0F ) ) == 1 )
 8036974:	f896 c008 	ldrb.w	ip, [r6, #8]
 8036978:	f34c 1603 	sbfx	r6, ip, #4, #4
    if( ( value >= min ) && ( value <= max ) )
 803697c:	f00c 0c0f 	and.w	ip, ip, #15
 8036980:	4562      	cmp	r2, ip
                                                  ( channels[i + j].DrRange.Fields.Max & 0x0F ) ) == 1 )
 8036982:	b276      	sxtb	r6, r6
    if( ( value >= min ) && ( value <= max ) )
 8036984:	db03      	blt.n	803698e <RegionCommonChanVerifyDr+0x48>
 8036986:	f006 060f 	and.w	r6, r6, #15
 803698a:	42b2      	cmp	r2, r6
 803698c:	dd0d      	ble.n	80369aa <RegionCommonChanVerifyDr+0x64>
        for( uint8_t j = 0; j < 16; j++ )
 803698e:	3501      	adds	r5, #1
 8036990:	2d10      	cmp	r5, #16
 8036992:	d1e9      	bne.n	8036968 <RegionCommonChanVerifyDr+0x22>
    for( uint8_t i = 0, k = 0; i < nbChannels; i += 16, k++ )
 8036994:	3401      	adds	r4, #1
 8036996:	b2e4      	uxtb	r4, r4
 8036998:	0123      	lsls	r3, r4, #4
 803699a:	b2db      	uxtb	r3, r3
 803699c:	4298      	cmp	r0, r3
 803699e:	d8de      	bhi.n	803695e <RegionCommonChanVerifyDr+0x18>
 80369a0:	e7da      	b.n	8036958 <RegionCommonChanVerifyDr+0x12>
 80369a2:	2400      	movs	r4, #0
 80369a4:	f04f 0e0c 	mov.w	lr, #12
 80369a8:	e7f6      	b.n	8036998 <RegionCommonChanVerifyDr+0x52>
                    return true;
 80369aa:	2001      	movs	r0, #1
 80369ac:	e7d5      	b.n	803695a <RegionCommonChanVerifyDr+0x14>

080369ae <RegionCommonValueInRange>:
    if( ( value >= min ) && ( value <= max ) )
 80369ae:	4288      	cmp	r0, r1
 80369b0:	db04      	blt.n	80369bc <RegionCommonValueInRange+0xe>
    {
        return 1;
 80369b2:	4290      	cmp	r0, r2
 80369b4:	bfcc      	ite	gt
 80369b6:	2000      	movgt	r0, #0
 80369b8:	2001      	movle	r0, #1
 80369ba:	4770      	bx	lr
    }
    return 0;
 80369bc:	2000      	movs	r0, #0
}
 80369be:	4770      	bx	lr

080369c0 <RegionCommonChanDisable>:

bool RegionCommonChanDisable( uint16_t* channelsMask, uint8_t id, uint8_t maxChannels )
{
 80369c0:	b510      	push	{r4, lr}
    uint8_t index = id / 16;

    if( ( index > ( maxChannels / 16 ) ) || ( id >= maxChannels ) )
 80369c2:	0914      	lsrs	r4, r2, #4
 80369c4:	ebb4 1f11 	cmp.w	r4, r1, lsr #4
{
 80369c8:	4603      	mov	r3, r0
    uint8_t index = id / 16;
 80369ca:	ea4f 1011 	mov.w	r0, r1, lsr #4
    if( ( index > ( maxChannels / 16 ) ) || ( id >= maxChannels ) )
 80369ce:	d30e      	bcc.n	80369ee <RegionCommonChanDisable+0x2e>
 80369d0:	4291      	cmp	r1, r2
 80369d2:	d20c      	bcs.n	80369ee <RegionCommonChanDisable+0x2e>
    {
        return false;
    }

    // Deactivate channel
    channelsMask[index] &= ~( 1 << ( id % 16 ) );
 80369d4:	b202      	sxth	r2, r0
 80369d6:	f001 010f 	and.w	r1, r1, #15
 80369da:	f833 4012 	ldrh.w	r4, [r3, r2, lsl #1]
 80369de:	2001      	movs	r0, #1
 80369e0:	fa00 f101 	lsl.w	r1, r0, r1
 80369e4:	ea24 0101 	bic.w	r1, r4, r1
 80369e8:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]

    return true;
}
 80369ec:	bd10      	pop	{r4, pc}
        return false;
 80369ee:	2000      	movs	r0, #0
 80369f0:	e7fc      	b.n	80369ec <RegionCommonChanDisable+0x2c>

080369f2 <RegionCommonCountChannels>:

uint8_t RegionCommonCountChannels( uint16_t* channelsMask, uint8_t startIdx, uint8_t stopIdx )
{
 80369f2:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint8_t nbChannels = 0;

    if( channelsMask == NULL )
 80369f4:	b128      	cbz	r0, 8036a02 <RegionCommonCountChannels+0x10>
 80369f6:	eb00 0541 	add.w	r5, r0, r1, lsl #1
        if( ( mask & ( 1 << j ) ) == ( 1 << j ) )
 80369fa:	2601      	movs	r6, #1
    uint8_t nbChannels = 0;
 80369fc:	2000      	movs	r0, #0
    {
        return 0;
    }

    for( uint8_t i = startIdx; i < stopIdx; i++ )
 80369fe:	4291      	cmp	r1, r2
 8036a00:	d300      	bcc.n	8036a04 <RegionCommonCountChannels+0x12>
    {
        nbChannels += CountChannels( channelsMask[i], 16 );
    }

    return nbChannels;
}
 8036a02:	bdf0      	pop	{r4, r5, r6, r7, pc}
        nbChannels += CountChannels( channelsMask[i], 16 );
 8036a04:	2400      	movs	r4, #0
 8036a06:	f835 7b02 	ldrh.w	r7, [r5], #2
    uint8_t nbActiveBits = 0;
 8036a0a:	4623      	mov	r3, r4
        if( ( mask & ( 1 << j ) ) == ( 1 << j ) )
 8036a0c:	fa06 fc04 	lsl.w	ip, r6, r4
 8036a10:	ea3c 0c07 	bics.w	ip, ip, r7
            nbActiveBits++;
 8036a14:	bf08      	it	eq
 8036a16:	3301      	addeq	r3, #1
 8036a18:	f104 0401 	add.w	r4, r4, #1
 8036a1c:	bf08      	it	eq
 8036a1e:	b2db      	uxtbeq	r3, r3
    for( uint8_t j = 0; j < nbBits; j++ )
 8036a20:	2c10      	cmp	r4, #16
 8036a22:	d1f3      	bne.n	8036a0c <RegionCommonCountChannels+0x1a>
        nbChannels += CountChannels( channelsMask[i], 16 );
 8036a24:	4418      	add	r0, r3
    for( uint8_t i = startIdx; i < stopIdx; i++ )
 8036a26:	3101      	adds	r1, #1
        nbChannels += CountChannels( channelsMask[i], 16 );
 8036a28:	b2c0      	uxtb	r0, r0
    for( uint8_t i = startIdx; i < stopIdx; i++ )
 8036a2a:	b2c9      	uxtb	r1, r1
 8036a2c:	e7e7      	b.n	80369fe <RegionCommonCountChannels+0xc>

08036a2e <RegionCommonChanMaskCopy>:

void RegionCommonChanMaskCopy( uint16_t* channelsMaskDest, uint16_t* channelsMaskSrc, uint8_t len )
{
 8036a2e:	b510      	push	{r4, lr}
    if( ( channelsMaskDest != NULL ) && ( channelsMaskSrc != NULL ) )
 8036a30:	b100      	cbz	r0, 8036a34 <RegionCommonChanMaskCopy+0x6>
 8036a32:	b949      	cbnz	r1, 8036a48 <RegionCommonChanMaskCopy+0x1a>
        for( uint8_t i = 0; i < len; i++ )
        {
            channelsMaskDest[i] = channelsMaskSrc[i];
        }
    }
}
 8036a34:	bd10      	pop	{r4, pc}
            channelsMaskDest[i] = channelsMaskSrc[i];
 8036a36:	f831 4013 	ldrh.w	r4, [r1, r3, lsl #1]
 8036a3a:	f820 4013 	strh.w	r4, [r0, r3, lsl #1]
        for( uint8_t i = 0; i < len; i++ )
 8036a3e:	3301      	adds	r3, #1
 8036a40:	b2dc      	uxtb	r4, r3
 8036a42:	42a2      	cmp	r2, r4
 8036a44:	d8f7      	bhi.n	8036a36 <RegionCommonChanMaskCopy+0x8>
 8036a46:	e7f5      	b.n	8036a34 <RegionCommonChanMaskCopy+0x6>
 8036a48:	2300      	movs	r3, #0
 8036a4a:	e7f9      	b.n	8036a40 <RegionCommonChanMaskCopy+0x12>

08036a4c <RegionCommonSetBandTxDone>:

void RegionCommonSetBandTxDone( Band_t* band, TimerTime_t lastTxAirTime, bool joined, SysTime_t elapsedTimeSinceStartup )
{
 8036a4c:	b082      	sub	sp, #8
 8036a4e:	b530      	push	{r4, r5, lr}
    // Get the band duty cycle. If not joined, the function either returns the join duty cycle
    // or the band duty cycle, whichever is more restrictive.
    uint16_t dutyCycle = GetDutyCycle( band, joined, elapsedTimeSinceStartup );
 8036a50:	8804      	ldrh	r4, [r0, #0]
{
 8036a52:	9304      	str	r3, [sp, #16]
    if( joined == false )
 8036a54:	b972      	cbnz	r2, 8036a74 <RegionCommonSetBandTxDone+0x28>
        if( elapsedTimeSinceStartup.Seconds < BACKOFF_DUTY_CYCLE_1_HOUR_IN_S )
 8036a56:	f5b3 6f61 	cmp.w	r3, #3600	; 0xe10
 8036a5a:	d319      	bcc.n	8036a90 <RegionCommonSetBandTxDone+0x44>
            joinDutyCycle = BACKOFF_DC_24_HOURS;
 8036a5c:	f649 25af 	movw	r5, #39599	; 0x9aaf
 8036a60:	f242 7210 	movw	r2, #10000	; 0x2710
 8036a64:	42ab      	cmp	r3, r5
 8036a66:	bf8c      	ite	hi
 8036a68:	4613      	movhi	r3, r2
 8036a6a:	f44f 737a 	movls.w	r3, #1000	; 0x3e8
        dutyCycle = MAX( dutyCycle, joinDutyCycle );
 8036a6e:	429c      	cmp	r4, r3
 8036a70:	bf38      	it	cc
 8036a72:	461c      	movcc	r4, r3

    // Reduce with transmission time
    if( band->TimeCredits > ( lastTxAirTime * dutyCycle ) )
 8036a74:	2c01      	cmp	r4, #1
 8036a76:	bf38      	it	cc
 8036a78:	2401      	movcc	r4, #1
 8036a7a:	4361      	muls	r1, r4
    }
    else
    {
        band->TimeCredits = 0;
    }
}
 8036a7c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    if( band->TimeCredits > ( lastTxAirTime * dutyCycle ) )
 8036a80:	68c3      	ldr	r3, [r0, #12]
 8036a82:	428b      	cmp	r3, r1
        band->TimeCredits -= ( lastTxAirTime * dutyCycle );
 8036a84:	bf8c      	ite	hi
 8036a86:	1a59      	subhi	r1, r3, r1
        band->TimeCredits = 0;
 8036a88:	2100      	movls	r1, #0
 8036a8a:	60c1      	str	r1, [r0, #12]
}
 8036a8c:	b002      	add	sp, #8
 8036a8e:	4770      	bx	lr
            joinDutyCycle = BACKOFF_DC_1_HOUR;
 8036a90:	2364      	movs	r3, #100	; 0x64
 8036a92:	e7ec      	b.n	8036a6e <RegionCommonSetBandTxDone+0x22>

08036a94 <RegionCommonUpdateBandTimeOff>:

TimerTime_t RegionCommonUpdateBandTimeOff( bool joined, Band_t* bands,
                                           uint8_t nbBands, bool dutyCycleEnabled,
                                           bool lastTxIsJoinRequest, SysTime_t elapsedTimeSinceStartup,
                                           TimerTime_t expectedTimeOnAir )
{
 8036a94:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8036a98:	b091      	sub	sp, #68	; 0x44
 8036a9a:	4615      	mov	r5, r2
 8036a9c:	f8dd 806c 	ldr.w	r8, [sp, #108]	; 0x6c
 8036aa0:	9305      	str	r3, [sp, #20]
 8036aa2:	f89d 3068 	ldrb.w	r3, [sp, #104]	; 0x68
 8036aa6:	9309      	str	r3, [sp, #36]	; 0x24
 8036aa8:	460c      	mov	r4, r1
 8036aaa:	4606      	mov	r6, r0
    TimerTime_t minTimeToWait = TIMERTIME_T_MAX;
    TimerTime_t currentTime = TimerGetCurrentTime( );
 8036aac:	f004 fbcc 	bl	803b248 <UTIL_TIMER_GetCurrentTime>
                timeDiff.Seconds = ( elapsedTimeSinceStartup.Seconds - BACKOFF_DUTY_CYCLE_24_HOURS_IN_S ) / BACKOFF_24_HOURS_IN_S;
 8036ab0:	4b68      	ldr	r3, [pc, #416]	; (8036c54 <RegionCommonUpdateBandTimeOff+0x1c0>)
 8036ab2:	f8df b1b8 	ldr.w	fp, [pc, #440]	; 8036c6c <RegionCommonUpdateBandTimeOff+0x1d8>
    TimerTime_t currentTime = TimerGetCurrentTime( );
 8036ab6:	9006      	str	r0, [sp, #24]
                timeDiff.Seconds = ( elapsedTimeSinceStartup.Seconds - BACKOFF_DUTY_CYCLE_24_HOURS_IN_S ) / BACKOFF_24_HOURS_IN_S;
 8036ab8:	f5a8 32f6 	sub.w	r2, r8, #125952	; 0x1ec00
 8036abc:	3a30      	subs	r2, #48	; 0x30
 8036abe:	fbb2 f2f3 	udiv	r2, r2, r3
                timeDiff.Seconds *= BACKOFF_24_HOURS_IN_S;
 8036ac2:	4353      	muls	r3, r2
                timeDiff.Seconds += BACKOFF_DUTY_CYCLE_24_HOURS_IN_S;
 8036ac4:	f503 32f6 	add.w	r2, r3, #125952	; 0x1ec00
 8036ac8:	3230      	adds	r2, #48	; 0x30
                    backoffTimeRange.Seconds = BACKOFF_DUTY_CYCLE_24_HOURS_IN_S;
                }
                // Calculate the time to wait.
                if( elapsedTimeSinceStartup.Seconds > BACKOFF_DUTY_CYCLE_24_HOURS_IN_S )
                {
                    backoffTimeRange.Seconds += BACKOFF_24_HOURS_IN_S * ( ( ( elapsedTimeSinceStartup.Seconds - BACKOFF_DUTY_CYCLE_24_HOURS_IN_S ) / BACKOFF_24_HOURS_IN_S ) + 1 );
 8036aca:	f503 33a8 	add.w	r3, r3, #86016	; 0x15000
 8036ace:	f503 73c0 	add.w	r3, r3, #384	; 0x180
                timeDiff.Seconds += BACKOFF_DUTY_CYCLE_24_HOURS_IN_S;
 8036ad2:	9204      	str	r2, [sp, #16]
 8036ad4:	2218      	movs	r2, #24
                    backoffTimeRange.Seconds += BACKOFF_24_HOURS_IN_S * ( ( ( elapsedTimeSinceStartup.Seconds - BACKOFF_DUTY_CYCLE_24_HOURS_IN_S ) / BACKOFF_24_HOURS_IN_S ) + 1 );
 8036ad6:	9303      	str	r3, [sp, #12]
 8036ad8:	fb12 4305 	smlabb	r3, r2, r5, r4
 8036adc:	9307      	str	r3, [sp, #28]
    uint8_t validBands = 0;
 8036ade:	2500      	movs	r5, #0
    TimerTime_t minTimeToWait = TIMERTIME_T_MAX;
 8036ae0:	f04f 3aff 	mov.w	sl, #4294967295
    for( uint8_t i = 0; i < nbBands; i++ )
 8036ae4:	9b07      	ldr	r3, [sp, #28]
 8036ae6:	42a3      	cmp	r3, r4
 8036ae8:	d107      	bne.n	8036afa <RegionCommonUpdateBandTimeOff+0x66>

    if( validBands == 0 )
    {
        // There is no valid band available to handle a transmission
        // in the given DUTY_CYCLE_TIME_PERIOD.
        return TIMERTIME_T_MAX;
 8036aea:	2d00      	cmp	r5, #0
    }
    return minTimeToWait;
}
 8036aec:	bf14      	ite	ne
 8036aee:	4650      	movne	r0, sl
 8036af0:	f04f 30ff 	moveq.w	r0, #4294967295
 8036af4:	b011      	add	sp, #68	; 0x44
 8036af6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        dutyCycle = UpdateTimeCredits( &bands[i], joined, dutyCycleEnabled,
 8036afa:	f9bd 3070 	ldrsh.w	r3, [sp, #112]	; 0x70
 8036afe:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
    TimerTime_t elapsedTime = SysTimeToMs( elapsedTimeSinceStartup );
 8036b02:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8036b04:	f8cd 806c 	str.w	r8, [sp, #108]	; 0x6c
 8036b08:	4640      	mov	r0, r8
 8036b0a:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
 8036b0e:	f004 fb2d 	bl	803b16c <SysTimeToMs>
    dutyCycle = GetDutyCycle( band, joined, elapsedTimeSinceStartup );
 8036b12:	f8b4 9000 	ldrh.w	r9, [r4]
    if( joined == false )
 8036b16:	b96e      	cbnz	r6, 8036b34 <RegionCommonUpdateBandTimeOff+0xa0>
        if( elapsedTimeSinceStartup.Seconds < BACKOFF_DUTY_CYCLE_1_HOUR_IN_S )
 8036b18:	f5b8 6f61 	cmp.w	r8, #3600	; 0xe10
 8036b1c:	d35b      	bcc.n	8036bd6 <RegionCommonUpdateBandTimeOff+0x142>
            joinDutyCycle = BACKOFF_DC_24_HOURS;
 8036b1e:	f649 22af 	movw	r2, #39599	; 0x9aaf
 8036b22:	f242 7310 	movw	r3, #10000	; 0x2710
 8036b26:	4590      	cmp	r8, r2
 8036b28:	bf98      	it	ls
 8036b2a:	f44f 737a 	movls.w	r3, #1000	; 0x3e8
        dutyCycle = MAX( dutyCycle, joinDutyCycle );
 8036b2e:	4599      	cmp	r9, r3
 8036b30:	bf38      	it	cc
 8036b32:	4699      	movcc	r9, r3
    if( dutyCycle == 0 )
 8036b34:	464b      	mov	r3, r9
 8036b36:	2b01      	cmp	r3, #1
 8036b38:	bf38      	it	cc
 8036b3a:	2301      	movcc	r3, #1
 8036b3c:	9308      	str	r3, [sp, #32]
    if( joined == false )
 8036b3e:	2e00      	cmp	r6, #0
 8036b40:	d152      	bne.n	8036be8 <RegionCommonUpdateBandTimeOff+0x154>
        if( dutyCycle == BACKOFF_DC_1_HOUR )
 8036b42:	f1b9 0f64 	cmp.w	r9, #100	; 0x64
 8036b46:	d148      	bne.n	8036bda <RegionCommonUpdateBandTimeOff+0x146>
            band->LastMaxCreditAssignTime = elapsedTime;
 8036b48:	60a0      	str	r0, [r4, #8]
            maxCredits = DUTY_CYCLE_TIME_PERIOD;
 8036b4a:	465f      	mov	r7, fp
        timeDiff = SysTimeSub( elapsedTimeSinceStartup, SysTimeFromMs( band->LastMaxCreditAssignTime ) );
 8036b4c:	68a1      	ldr	r1, [r4, #8]
 8036b4e:	a80e      	add	r0, sp, #56	; 0x38
 8036b50:	f004 fb2c 	bl	803b1ac <SysTimeFromMs>
 8036b54:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8036b56:	9300      	str	r3, [sp, #0]
 8036b58:	e9dd 120a 	ldrd	r1, r2, [sp, #40]	; 0x28
 8036b5c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8036b5e:	a80c      	add	r0, sp, #48	; 0x30
 8036b60:	f004 fa84 	bl	803b06c <SysTimeSub>
        if( ( ( dutyCycleEnabled == false ) && ( lastTxIsJoinRequest == false ) ) ||
 8036b64:	9b05      	ldr	r3, [sp, #20]
 8036b66:	b90b      	cbnz	r3, 8036b6c <RegionCommonUpdateBandTimeOff+0xd8>
 8036b68:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8036b6a:	b133      	cbz	r3, 8036b7a <RegionCommonUpdateBandTimeOff+0xe6>
 8036b6c:	6923      	ldr	r3, [r4, #16]
 8036b6e:	42bb      	cmp	r3, r7
 8036b70:	d103      	bne.n	8036b7a <RegionCommonUpdateBandTimeOff+0xe6>
            ( band->MaxTimeCredits != maxCredits ) ||
 8036b72:	4b39      	ldr	r3, [pc, #228]	; (8036c58 <RegionCommonUpdateBandTimeOff+0x1c4>)
 8036b74:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8036b76:	429a      	cmp	r2, r3
 8036b78:	d90d      	bls.n	8036b96 <RegionCommonUpdateBandTimeOff+0x102>
            if( elapsedTimeSinceStartup.Seconds >= BACKOFF_DUTY_CYCLE_24_HOURS_IN_S )
 8036b7a:	4b38      	ldr	r3, [pc, #224]	; (8036c5c <RegionCommonUpdateBandTimeOff+0x1c8>)
            band->TimeCredits = maxCredits;
 8036b7c:	60e7      	str	r7, [r4, #12]
            if( elapsedTimeSinceStartup.Seconds >= BACKOFF_DUTY_CYCLE_24_HOURS_IN_S )
 8036b7e:	4598      	cmp	r8, r3
 8036b80:	d909      	bls.n	8036b96 <RegionCommonUpdateBandTimeOff+0x102>
                timeDiff.SubSeconds = 0;
 8036b82:	2300      	movs	r3, #0
 8036b84:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
                band->LastMaxCreditAssignTime = SysTimeToMs( timeDiff );
 8036b88:	9b04      	ldr	r3, [sp, #16]
 8036b8a:	990d      	ldr	r1, [sp, #52]	; 0x34
 8036b8c:	930c      	str	r3, [sp, #48]	; 0x30
 8036b8e:	4618      	mov	r0, r3
 8036b90:	f004 faec 	bl	803b16c <SysTimeToMs>
 8036b94:	60a0      	str	r0, [r4, #8]
    if( band->LastBandUpdateTime == 0 )
 8036b96:	6860      	ldr	r0, [r4, #4]
 8036b98:	b900      	cbnz	r0, 8036b9c <RegionCommonUpdateBandTimeOff+0x108>
        band->TimeCredits = maxCredits;
 8036b9a:	60e7      	str	r7, [r4, #12]
    band->MaxTimeCredits = maxCredits;
 8036b9c:	6127      	str	r7, [r4, #16]
    if( joined == true )
 8036b9e:	b126      	cbz	r6, 8036baa <RegionCommonUpdateBandTimeOff+0x116>
        band->TimeCredits += TimerGetElapsedTime( band->LastBandUpdateTime );
 8036ba0:	f004 fb5c 	bl	803b25c <UTIL_TIMER_GetElapsedTime>
 8036ba4:	68e3      	ldr	r3, [r4, #12]
 8036ba6:	4403      	add	r3, r0
 8036ba8:	60e3      	str	r3, [r4, #12]
    if( band->TimeCredits > band->MaxTimeCredits )
 8036baa:	e9d4 3203 	ldrd	r3, r2, [r4, #12]
 8036bae:	4293      	cmp	r3, r2
    band->LastBandUpdateTime = currentTime;
 8036bb0:	9b06      	ldr	r3, [sp, #24]
        creditCosts = expectedTimeOnAir * dutyCycle;
 8036bb2:	991d      	ldr	r1, [sp, #116]	; 0x74
    band->LastBandUpdateTime = currentTime;
 8036bb4:	6063      	str	r3, [r4, #4]
        creditCosts = expectedTimeOnAir * dutyCycle;
 8036bb6:	9b08      	ldr	r3, [sp, #32]
        band->TimeCredits = band->MaxTimeCredits;
 8036bb8:	bf88      	it	hi
 8036bba:	60e2      	strhi	r2, [r4, #12]
        creditCosts = expectedTimeOnAir * dutyCycle;
 8036bbc:	434b      	muls	r3, r1
        if( ( bands[i].TimeCredits > creditCosts ) ||
 8036bbe:	68e1      	ldr	r1, [r4, #12]
 8036bc0:	4299      	cmp	r1, r3
 8036bc2:	d802      	bhi.n	8036bca <RegionCommonUpdateBandTimeOff+0x136>
 8036bc4:	9805      	ldr	r0, [sp, #20]
 8036bc6:	b9a8      	cbnz	r0, 8036bf4 <RegionCommonUpdateBandTimeOff+0x160>
            ( ( dutyCycleEnabled == false ) && ( joined == true ) ) )
 8036bc8:	b1a6      	cbz	r6, 8036bf4 <RegionCommonUpdateBandTimeOff+0x160>
            bands[i].ReadyForTransmission = true;
 8036bca:	2301      	movs	r3, #1
            validBands++;
 8036bcc:	441d      	add	r5, r3
            bands[i].ReadyForTransmission = true;
 8036bce:	7523      	strb	r3, [r4, #20]
            validBands++;
 8036bd0:	b2ed      	uxtb	r5, r5
    for( uint8_t i = 0; i < nbBands; i++ )
 8036bd2:	3418      	adds	r4, #24
 8036bd4:	e786      	b.n	8036ae4 <RegionCommonUpdateBandTimeOff+0x50>
            joinDutyCycle = BACKOFF_DC_1_HOUR;
 8036bd6:	2364      	movs	r3, #100	; 0x64
 8036bd8:	e7a9      	b.n	8036b2e <RegionCommonUpdateBandTimeOff+0x9a>
        else if( dutyCycle == BACKOFF_DC_10_HOURS )
 8036bda:	f5b9 7f7a 	cmp.w	r9, #1000	; 0x3e8
            maxCredits = DUTY_CYCLE_TIME_PERIOD * 10;
 8036bde:	bf0a      	itet	eq
 8036be0:	4f1f      	ldreq	r7, [pc, #124]	; (8036c60 <RegionCommonUpdateBandTimeOff+0x1cc>)
            maxCredits = DUTY_CYCLE_TIME_PERIOD * 24;
 8036be2:	4f20      	ldrne	r7, [pc, #128]	; (8036c64 <RegionCommonUpdateBandTimeOff+0x1d0>)
            band->LastMaxCreditAssignTime = elapsedTime;
 8036be4:	60a0      	streq	r0, [r4, #8]
 8036be6:	e7b1      	b.n	8036b4c <RegionCommonUpdateBandTimeOff+0xb8>
        if( dutyCycleEnabled == false )
 8036be8:	9b05      	ldr	r3, [sp, #20]
 8036bea:	b90b      	cbnz	r3, 8036bf0 <RegionCommonUpdateBandTimeOff+0x15c>
            band->TimeCredits = maxCredits;
 8036bec:	f8c4 b00c 	str.w	fp, [r4, #12]
    TimerTime_t maxCredits = DUTY_CYCLE_TIME_PERIOD;
 8036bf0:	465f      	mov	r7, fp
 8036bf2:	e7d0      	b.n	8036b96 <RegionCommonUpdateBandTimeOff+0x102>
            bands[i].ReadyForTransmission = false;
 8036bf4:	2000      	movs	r0, #0
            if( bands[i].MaxTimeCredits > creditCosts )
 8036bf6:	4293      	cmp	r3, r2
            bands[i].ReadyForTransmission = false;
 8036bf8:	7520      	strb	r0, [r4, #20]
            if( bands[i].MaxTimeCredits > creditCosts )
 8036bfa:	d206      	bcs.n	8036c0a <RegionCommonUpdateBandTimeOff+0x176>
                minTimeToWait = MIN( minTimeToWait, ( creditCosts - bands[i].TimeCredits ) );
 8036bfc:	1a5b      	subs	r3, r3, r1
 8036bfe:	459a      	cmp	sl, r3
                validBands++;
 8036c00:	f105 0501 	add.w	r5, r5, #1
                minTimeToWait = MIN( minTimeToWait, ( creditCosts - bands[i].TimeCredits ) );
 8036c04:	bf28      	it	cs
 8036c06:	469a      	movcs	sl, r3
                validBands++;
 8036c08:	b2ed      	uxtb	r5, r5
            if( joined == false )
 8036c0a:	2e00      	cmp	r6, #0
 8036c0c:	d1e1      	bne.n	8036bd2 <RegionCommonUpdateBandTimeOff+0x13e>
                if( dutyCycle == BACKOFF_DC_1_HOUR )
 8036c0e:	f1b9 0f64 	cmp.w	r9, #100	; 0x64
 8036c12:	4a15      	ldr	r2, [pc, #84]	; (8036c68 <RegionCommonUpdateBandTimeOff+0x1d4>)
                SysTime_t backoffTimeRange = {
 8036c14:	f8ad 6034 	strh.w	r6, [sp, #52]	; 0x34
                if( dutyCycle == BACKOFF_DC_1_HOUR )
 8036c18:	d019      	beq.n	8036c4e <RegionCommonUpdateBandTimeOff+0x1ba>
                    backoffTimeRange.Seconds = BACKOFF_DUTY_CYCLE_24_HOURS_IN_S;
 8036c1a:	f649 23b0 	movw	r3, #39600	; 0x9ab0
 8036c1e:	f5b9 7f7a 	cmp.w	r9, #1000	; 0x3e8
 8036c22:	bf18      	it	ne
 8036c24:	4613      	movne	r3, r2
                if( elapsedTimeSinceStartup.Seconds > BACKOFF_DUTY_CYCLE_24_HOURS_IN_S )
 8036c26:	4590      	cmp	r8, r2
                    backoffTimeRange.Seconds += BACKOFF_24_HOURS_IN_S * ( ( ( elapsedTimeSinceStartup.Seconds - BACKOFF_DUTY_CYCLE_24_HOURS_IN_S ) / BACKOFF_24_HOURS_IN_S ) + 1 );
 8036c28:	bf84      	itt	hi
 8036c2a:	9a03      	ldrhi	r2, [sp, #12]
 8036c2c:	189b      	addhi	r3, r3, r2
                backoffTimeRange  = SysTimeSub( backoffTimeRange, elapsedTimeSinceStartup );
 8036c2e:	930c      	str	r3, [sp, #48]	; 0x30
 8036c30:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8036c32:	9300      	str	r3, [sp, #0]
 8036c34:	af0c      	add	r7, sp, #48	; 0x30
 8036c36:	e897 0006 	ldmia.w	r7, {r1, r2}
 8036c3a:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8036c3c:	4638      	mov	r0, r7
 8036c3e:	f004 fa15 	bl	803b06c <SysTimeSub>
                minTimeToWait = SysTimeToMs( backoffTimeRange );
 8036c42:	e897 0003 	ldmia.w	r7, {r0, r1}
 8036c46:	f004 fa91 	bl	803b16c <SysTimeToMs>
 8036c4a:	4682      	mov	sl, r0
 8036c4c:	e7c1      	b.n	8036bd2 <RegionCommonUpdateBandTimeOff+0x13e>
                    backoffTimeRange.Seconds = BACKOFF_DUTY_CYCLE_1_HOUR_IN_S;
 8036c4e:	f44f 6361 	mov.w	r3, #3600	; 0xe10
 8036c52:	e7e8      	b.n	8036c26 <RegionCommonUpdateBandTimeOff+0x192>
 8036c54:	00015180 	.word	0x00015180
 8036c58:	0001517f 	.word	0x0001517f
 8036c5c:	0001ec2f 	.word	0x0001ec2f
 8036c60:	0112a880 	.word	0x0112a880
 8036c64:	02932e00 	.word	0x02932e00
 8036c68:	0001ec30 	.word	0x0001ec30
 8036c6c:	001b7740 	.word	0x001b7740

08036c70 <RegionCommonParseLinkAdrReq>:

uint8_t RegionCommonParseLinkAdrReq( uint8_t* payload, RegionCommonLinkAdrParams_t* linkAdrParams )
{
    uint8_t retIndex = 0;

    if( payload[0] == SRV_MAC_LINK_ADR_REQ )
 8036c70:	7803      	ldrb	r3, [r0, #0]
 8036c72:	2b03      	cmp	r3, #3
 8036c74:	d114      	bne.n	8036ca0 <RegionCommonParseLinkAdrReq+0x30>
    {
        // Parse datarate and tx power
        linkAdrParams->Datarate = payload[1];
 8036c76:	7843      	ldrb	r3, [r0, #1]
        linkAdrParams->TxPower = linkAdrParams->Datarate & 0x0F;
 8036c78:	f003 020f 	and.w	r2, r3, #15
        linkAdrParams->Datarate = ( linkAdrParams->Datarate >> 4 ) & 0x0F;
 8036c7c:	091b      	lsrs	r3, r3, #4
        linkAdrParams->TxPower = linkAdrParams->Datarate & 0x0F;
 8036c7e:	708a      	strb	r2, [r1, #2]
        linkAdrParams->Datarate = ( linkAdrParams->Datarate >> 4 ) & 0x0F;
 8036c80:	704b      	strb	r3, [r1, #1]
        // Parse ChMask
        linkAdrParams->ChMask = ( uint16_t )payload[2];
 8036c82:	7883      	ldrb	r3, [r0, #2]
 8036c84:	808b      	strh	r3, [r1, #4]
        linkAdrParams->ChMask |= ( uint16_t )payload[3] << 8;
 8036c86:	78c2      	ldrb	r2, [r0, #3]
 8036c88:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8036c8c:	808b      	strh	r3, [r1, #4]
        // Parse ChMaskCtrl and nbRep
        linkAdrParams->NbRep = payload[4];
 8036c8e:	7903      	ldrb	r3, [r0, #4]
        linkAdrParams->ChMaskCtrl = ( linkAdrParams->NbRep >> 4 ) & 0x07;
 8036c90:	f3c3 1202 	ubfx	r2, r3, #4, #3
        linkAdrParams->NbRep &= 0x0F;
 8036c94:	f003 030f 	and.w	r3, r3, #15
        linkAdrParams->ChMaskCtrl = ( linkAdrParams->NbRep >> 4 ) & 0x07;
 8036c98:	70ca      	strb	r2, [r1, #3]
        linkAdrParams->NbRep &= 0x0F;
 8036c9a:	700b      	strb	r3, [r1, #0]

        // LinkAdrReq has 4 bytes length + 1 byte CMD
        retIndex = 5;
 8036c9c:	2005      	movs	r0, #5
 8036c9e:	4770      	bx	lr
    uint8_t retIndex = 0;
 8036ca0:	2000      	movs	r0, #0
    }
    return retIndex;
}
 8036ca2:	4770      	bx	lr

08036ca4 <RegionCommonLinkAdrReqVerifyParams>:

uint8_t RegionCommonLinkAdrReqVerifyParams( RegionCommonLinkAdrReqVerifyParams_t* verifyParams, int8_t* dr, int8_t* txPow, uint8_t* nbRep )
{
 8036ca4:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 8036ca8:	4698      	mov	r8, r3
    int8_t datarate = verifyParams->Datarate;
    int8_t txPower = verifyParams->TxPower;
    int8_t nbRepetitions = verifyParams->NbRep;

    // Handle the case when ADR is off.
    if( verifyParams->AdrEnabled == false )
 8036caa:	7943      	ldrb	r3, [r0, #5]
    uint8_t status = verifyParams->Status;
 8036cac:	7905      	ldrb	r5, [r0, #4]
    int8_t txPower = verifyParams->TxPower;
 8036cae:	f990 7007 	ldrsb.w	r7, [r0, #7]
    int8_t nbRepetitions = verifyParams->NbRep;
 8036cb2:	7a06      	ldrb	r6, [r0, #8]
{
 8036cb4:	4691      	mov	r9, r2
 8036cb6:	4604      	mov	r4, r0
    int8_t datarate = verifyParams->Datarate;
 8036cb8:	f990 2006 	ldrsb.w	r2, [r0, #6]
{
 8036cbc:	468a      	mov	sl, r1
    if( verifyParams->AdrEnabled == false )
 8036cbe:	b31b      	cbz	r3, 8036d08 <RegionCommonLinkAdrReqVerifyParams+0x64>
    int8_t nbRepetitions = verifyParams->NbRep;
 8036cc0:	b276      	sxtb	r6, r6
        nbRepetitions = verifyParams->CurrentNbRep;
        datarate =  verifyParams->CurrentDatarate;
        txPower =  verifyParams->CurrentTxPower;
    }

    if( status != 0 )
 8036cc2:	b1bd      	cbz	r5, 8036cf4 <RegionCommonLinkAdrReqVerifyParams+0x50>
    {
        // Verify datarate. The variable phyParam. Value contains the minimum allowed datarate.
        if( RegionCommonChanVerifyDr( verifyParams->NbChannels, verifyParams->ChannelsMask, datarate,
 8036cc4:	69a3      	ldr	r3, [r4, #24]
 8036cc6:	9301      	str	r3, [sp, #4]
 8036cc8:	f994 3015 	ldrsb.w	r3, [r4, #21]
 8036ccc:	9300      	str	r3, [sp, #0]
 8036cce:	6921      	ldr	r1, [r4, #16]
 8036cd0:	f994 3014 	ldrsb.w	r3, [r4, #20]
 8036cd4:	7b20      	ldrb	r0, [r4, #12]
 8036cd6:	f7ff fe36 	bl	8036946 <RegionCommonChanVerifyDr>
 8036cda:	b908      	cbnz	r0, 8036ce0 <RegionCommonLinkAdrReqVerifyParams+0x3c>
                                      verifyParams->MinDatarate, verifyParams->MaxDatarate, verifyParams->Channels  ) == false )
        {
            status &= 0xFD; // Datarate KO
 8036cdc:	f005 05fd 	and.w	r5, r5, #253	; 0xfd
        }

        // Verify tx power
        if( RegionCommonValueInRange( txPower, verifyParams->MaxTxPower, verifyParams->MinTxPower ) == 0 )
 8036ce0:	f994 301d 	ldrsb.w	r3, [r4, #29]
 8036ce4:	f994 101c 	ldrsb.w	r1, [r4, #28]
    if( ( value >= min ) && ( value <= max ) )
 8036ce8:	42bb      	cmp	r3, r7
 8036cea:	dc14      	bgt.n	8036d16 <RegionCommonLinkAdrReqVerifyParams+0x72>
 8036cec:	42b9      	cmp	r1, r7
 8036cee:	da13      	bge.n	8036d18 <RegionCommonLinkAdrReqVerifyParams+0x74>
            { // Apply maximum TX power. Accept TX power.
                txPower = verifyParams->MaxTxPower;
            }
            else
            {
                status &= 0xFB; // TxPower KO
 8036cf0:	f005 05fb 	and.w	r5, r5, #251	; 0xfb
    *dr = datarate;
    *txPow = txPower;
    *nbRep = nbRepetitions;

    return status;
}
 8036cf4:	4628      	mov	r0, r5
    *dr = datarate;
 8036cf6:	f88a 2000 	strb.w	r2, [sl]
    *txPow = txPower;
 8036cfa:	f889 7000 	strb.w	r7, [r9]
    *nbRep = nbRepetitions;
 8036cfe:	f888 6000 	strb.w	r6, [r8]
}
 8036d02:	b002      	add	sp, #8
 8036d04:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        nbRepetitions = verifyParams->CurrentNbRep;
 8036d08:	f990 600b 	ldrsb.w	r6, [r0, #11]
        datarate =  verifyParams->CurrentDatarate;
 8036d0c:	f990 2009 	ldrsb.w	r2, [r0, #9]
        txPower =  verifyParams->CurrentTxPower;
 8036d10:	f990 700a 	ldrsb.w	r7, [r0, #10]
 8036d14:	e7d5      	b.n	8036cc2 <RegionCommonLinkAdrReqVerifyParams+0x1e>
 8036d16:	461f      	mov	r7, r3
    if( status == 0x07 )
 8036d18:	2d07      	cmp	r5, #7
 8036d1a:	d1eb      	bne.n	8036cf4 <RegionCommonLinkAdrReqVerifyParams+0x50>
            nbRepetitions = 1;
 8036d1c:	2e00      	cmp	r6, #0
 8036d1e:	bf08      	it	eq
 8036d20:	2601      	moveq	r6, #1
 8036d22:	e7e7      	b.n	8036cf4 <RegionCommonLinkAdrReqVerifyParams+0x50>

08036d24 <RegionCommonComputeSymbolTimeLoRa>:

uint32_t RegionCommonComputeSymbolTimeLoRa( uint8_t phyDr, uint32_t bandwidthInHz )
{
    return ( 1 << phyDr ) * 1000000 / bandwidthInHz;
 8036d24:	4b02      	ldr	r3, [pc, #8]	; (8036d30 <RegionCommonComputeSymbolTimeLoRa+0xc>)
 8036d26:	fa03 f000 	lsl.w	r0, r3, r0
}
 8036d2a:	fbb0 f0f1 	udiv	r0, r0, r1
 8036d2e:	4770      	bx	lr
 8036d30:	000f4240 	.word	0x000f4240

08036d34 <RegionCommonComputeSymbolTimeFsk>:

uint32_t RegionCommonComputeSymbolTimeFsk( uint8_t phyDrInKbps )
{
    return 8000 / ( uint32_t )phyDrInKbps; // 1 symbol equals 1 byte
}
 8036d34:	f44f 53fa 	mov.w	r3, #8000	; 0x1f40
 8036d38:	fbb3 f0f0 	udiv	r0, r3, r0
 8036d3c:	4770      	bx	lr

08036d3e <RegionCommonComputeRxWindowParameters>:

void RegionCommonComputeRxWindowParameters( uint32_t tSymbolInUs, uint8_t minRxSymbols, uint32_t rxErrorInMs, uint32_t wakeUpTimeInMs, uint32_t* windowTimeoutInSymbols, int32_t* windowOffsetInMs )
{
 8036d3e:	b530      	push	{r4, r5, lr}
    *windowTimeoutInSymbols = MAX( DIV_CEIL( ( ( 2 * minRxSymbols - 8 ) * tSymbolInUs + 2 * ( rxErrorInMs * 1000 ) ),  tSymbolInUs ), minRxSymbols ); // Computed number of symbols
 8036d40:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 8036d44:	1f0c      	subs	r4, r1, #4
 8036d46:	436a      	muls	r2, r5
 8036d48:	fb00 2204 	mla	r2, r0, r4, r2
 8036d4c:	0052      	lsls	r2, r2, #1
 8036d4e:	bf1e      	ittt	ne
 8036d50:	f100 34ff 	addne.w	r4, r0, #4294967295
 8036d54:	1912      	addne	r2, r2, r4
 8036d56:	fbb2 f2f0 	udivne	r2, r2, r0
 8036d5a:	428a      	cmp	r2, r1
 8036d5c:	bf38      	it	cc
 8036d5e:	460a      	movcc	r2, r1
 8036d60:	9903      	ldr	r1, [sp, #12]
 8036d62:	600a      	str	r2, [r1, #0]
    *windowOffsetInMs = ( int32_t )DIV_CEIL( ( int32_t )( 4 * tSymbolInUs ) -
 8036d64:	0081      	lsls	r1, r0, #2
 8036d66:	4350      	muls	r0, r2
 8036d68:	bf1c      	itt	ne
 8036d6a:	3001      	addne	r0, #1
 8036d6c:	0840      	lsrne	r0, r0, #1
 8036d6e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8036d72:	1a08      	subs	r0, r1, r0
 8036d74:	fb02 0313 	mls	r3, r2, r3, r0
 8036d78:	2b00      	cmp	r3, #0
 8036d7a:	bfca      	itet	gt
 8036d7c:	f203 33e7 	addwgt	r3, r3, #999	; 0x3e7
 8036d80:	fb93 f3f2 	sdivle	r3, r3, r2
 8036d84:	fbb3 f3f2 	udivgt	r3, r3, r2
 8036d88:	9a04      	ldr	r2, [sp, #16]
 8036d8a:	6013      	str	r3, [r2, #0]
                                               ( int32_t )DIV_CEIL( ( *windowTimeoutInSymbols * tSymbolInUs ), 2 ) -
                                               ( int32_t )( wakeUpTimeInMs * 1000 ), 1000 );
}
 8036d8c:	bd30      	pop	{r4, r5, pc}

08036d8e <RegionCommonComputeTxPower>:

int8_t RegionCommonComputeTxPower( int8_t txPowerIndex, float maxEirp, float antennaGain )
{
 8036d8e:	b538      	push	{r3, r4, r5, lr}
    int8_t phyTxPower = 0;

    phyTxPower = ( int8_t )floor( ( maxEirp - ( txPowerIndex * 2U ) ) - antennaGain );
 8036d90:	0040      	lsls	r0, r0, #1
{
 8036d92:	4614      	mov	r4, r2
 8036d94:	460d      	mov	r5, r1
    phyTxPower = ( int8_t )floor( ( maxEirp - ( txPowerIndex * 2U ) ) - antennaGain );
 8036d96:	f7f4 fe7d 	bl	802ba94 <__aeabi_ui2f>
 8036d9a:	4601      	mov	r1, r0
 8036d9c:	4628      	mov	r0, r5
 8036d9e:	f7f4 fdc7 	bl	802b930 <__aeabi_fsub>
 8036da2:	4621      	mov	r1, r4
 8036da4:	f7f4 fdc4 	bl	802b930 <__aeabi_fsub>
 8036da8:	f7f4 fcb6 	bl	802b718 <__aeabi_f2d>
 8036dac:	f004 fcbc 	bl	803b728 <floor>
 8036db0:	f7f4 fd92 	bl	802b8d8 <__aeabi_d2iz>

    return phyTxPower;
}
 8036db4:	b240      	sxtb	r0, r0
 8036db6:	bd38      	pop	{r3, r4, r5, pc}

08036db8 <RegionCommonCountNbOfEnabledChannels>:
    /* ST_WORKAROUND_END */
}

void RegionCommonCountNbOfEnabledChannels( RegionCommonCountNbOfEnabledChannelsParams_t* countNbOfEnabledChannelsParams,
                                           uint8_t* enabledChannels, uint8_t* nbEnabledChannels, uint8_t* nbRestrictedChannels )
{
 8036db8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8036dbc:	e9cd 2300 	strd	r2, r3, [sp]
    uint8_t nbChannelCount = 0;
    uint8_t nbRestrictedChannelsCount = 0;

    for( uint8_t i = 0, k = 0; i < countNbOfEnabledChannelsParams->MaxNbChannels; i += 16, k++ )
 8036dc0:	2300      	movs	r3, #0
    uint8_t nbRestrictedChannelsCount = 0;
 8036dc2:	461d      	mov	r5, r3
    uint8_t nbChannelCount = 0;
 8036dc4:	461e      	mov	r6, r3
    {
        for( uint8_t j = 0; j < 16; j++ )
        {
            if( ( countNbOfEnabledChannelsParams->ChannelsMask[k] & ( 1 << j ) ) != 0 )
            {
                if( countNbOfEnabledChannelsParams->Channels[i + j].Frequency == 0 )
 8036dc6:	f04f 090c 	mov.w	r9, #12
 8036dca:	011a      	lsls	r2, r3, #4
    for( uint8_t i = 0, k = 0; i < countNbOfEnabledChannelsParams->MaxNbChannels; i += 16, k++ )
 8036dcc:	8a04      	ldrh	r4, [r0, #16]
 8036dce:	fa5f f882 	uxtb.w	r8, r2
 8036dd2:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 8036dd6:	4294      	cmp	r4, r2
 8036dd8:	d806      	bhi.n	8036de8 <RegionCommonCountNbOfEnabledChannels+0x30>
                }
                enabledChannels[nbChannelCount++] = i + j;
            }
        }
    }
    *nbEnabledChannels = nbChannelCount;
 8036dda:	9b00      	ldr	r3, [sp, #0]
 8036ddc:	701e      	strb	r6, [r3, #0]
    *nbRestrictedChannels = nbRestrictedChannelsCount;
 8036dde:	9b01      	ldr	r3, [sp, #4]
 8036de0:	701d      	strb	r5, [r3, #0]
}
 8036de2:	b003      	add	sp, #12
 8036de4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            if( ( countNbOfEnabledChannelsParams->ChannelsMask[k] & ( 1 << j ) ) != 0 )
 8036de8:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8036dec:	2200      	movs	r2, #0
 8036dee:	6844      	ldr	r4, [r0, #4]
 8036df0:	f834 400c 	ldrh.w	r4, [r4, ip]
 8036df4:	4114      	asrs	r4, r2
 8036df6:	07e7      	lsls	r7, r4, #31
 8036df8:	d52a      	bpl.n	8036e50 <RegionCommonCountNbOfEnabledChannels+0x98>
                if( countNbOfEnabledChannelsParams->Channels[i + j].Frequency == 0 )
 8036dfa:	eb02 0e08 	add.w	lr, r2, r8
 8036dfe:	6887      	ldr	r7, [r0, #8]
 8036e00:	fb09 f40e 	mul.w	r4, r9, lr
 8036e04:	eb07 0a04 	add.w	sl, r7, r4
 8036e08:	593c      	ldr	r4, [r7, r4]
 8036e0a:	b30c      	cbz	r4, 8036e50 <RegionCommonCountNbOfEnabledChannels+0x98>
                if( ( countNbOfEnabledChannelsParams->Joined == false ) &&
 8036e0c:	7804      	ldrb	r4, [r0, #0]
 8036e0e:	b934      	cbnz	r4, 8036e1e <RegionCommonCountNbOfEnabledChannels+0x66>
                    ( countNbOfEnabledChannelsParams->JoinChannels != NULL ) )
 8036e10:	6944      	ldr	r4, [r0, #20]
                if( ( countNbOfEnabledChannelsParams->Joined == false ) &&
 8036e12:	b124      	cbz	r4, 8036e1e <RegionCommonCountNbOfEnabledChannels+0x66>
                    if( ( countNbOfEnabledChannelsParams->JoinChannels[k] & ( 1 << j ) ) == 0 )
 8036e14:	f834 400c 	ldrh.w	r4, [r4, ip]
 8036e18:	4114      	asrs	r4, r2
 8036e1a:	07e4      	lsls	r4, r4, #31
 8036e1c:	d518      	bpl.n	8036e50 <RegionCommonCountNbOfEnabledChannels+0x98>
                                              countNbOfEnabledChannelsParams->Channels[i + j].DrRange.Fields.Min,
 8036e1e:	f89a 4008 	ldrb.w	r4, [sl, #8]
                if( RegionCommonValueInRange( countNbOfEnabledChannelsParams->Datarate,
 8036e22:	f990 b001 	ldrsb.w	fp, [r0, #1]
                                              countNbOfEnabledChannelsParams->Channels[i + j].DrRange.Fields.Min,
 8036e26:	f344 0703 	sbfx	r7, r4, #0, #4
    if( ( value >= min ) && ( value <= max ) )
 8036e2a:	b27f      	sxtb	r7, r7
 8036e2c:	455f      	cmp	r7, fp
 8036e2e:	dc0f      	bgt.n	8036e50 <RegionCommonCountNbOfEnabledChannels+0x98>
                                              countNbOfEnabledChannelsParams->Channels[i + j].DrRange.Fields.Max ) == false )
 8036e30:	f344 1403 	sbfx	r4, r4, #4, #4
    if( ( value >= min ) && ( value <= max ) )
 8036e34:	b264      	sxtb	r4, r4
 8036e36:	455c      	cmp	r4, fp
 8036e38:	db0a      	blt.n	8036e50 <RegionCommonCountNbOfEnabledChannels+0x98>
                if( countNbOfEnabledChannelsParams->Bands[countNbOfEnabledChannelsParams->Channels[i + j].Band].ReadyForTransmission == false )
 8036e3a:	f89a 4009 	ldrb.w	r4, [sl, #9]
 8036e3e:	eb04 0744 	add.w	r7, r4, r4, lsl #1
 8036e42:	68c4      	ldr	r4, [r0, #12]
 8036e44:	eb04 04c7 	add.w	r4, r4, r7, lsl #3
 8036e48:	7d24      	ldrb	r4, [r4, #20]
 8036e4a:	b93c      	cbnz	r4, 8036e5c <RegionCommonCountNbOfEnabledChannels+0xa4>
                    nbRestrictedChannelsCount++;
 8036e4c:	3501      	adds	r5, #1
 8036e4e:	b2ed      	uxtb	r5, r5
        for( uint8_t j = 0; j < 16; j++ )
 8036e50:	3201      	adds	r2, #1
 8036e52:	2a10      	cmp	r2, #16
 8036e54:	d1cb      	bne.n	8036dee <RegionCommonCountNbOfEnabledChannels+0x36>
    for( uint8_t i = 0, k = 0; i < countNbOfEnabledChannelsParams->MaxNbChannels; i += 16, k++ )
 8036e56:	3301      	adds	r3, #1
 8036e58:	b2db      	uxtb	r3, r3
 8036e5a:	e7b6      	b.n	8036dca <RegionCommonCountNbOfEnabledChannels+0x12>
                enabledChannels[nbChannelCount++] = i + j;
 8036e5c:	1c74      	adds	r4, r6, #1
 8036e5e:	f801 e006 	strb.w	lr, [r1, r6]
 8036e62:	b2e6      	uxtb	r6, r4
 8036e64:	e7f4      	b.n	8036e50 <RegionCommonCountNbOfEnabledChannels+0x98>

08036e66 <RegionCommonIdentifyChannels>:

LoRaMacStatus_t RegionCommonIdentifyChannels( RegionCommonIdentifyChannelsParam_t* identifyChannelsParam,
                                              TimerTime_t* aggregatedTimeOff, uint8_t* enabledChannels,
                                              uint8_t* nbEnabledChannels, uint8_t* nbRestrictedChannels,
                                              TimerTime_t* nextTxDelay )
{
 8036e66:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 8036e6a:	4604      	mov	r4, r0
    TimerTime_t elapsed = TimerGetElapsedTime( identifyChannelsParam->LastAggrTx );
 8036e6c:	6840      	ldr	r0, [r0, #4]
{
 8036e6e:	e9dd 780c 	ldrd	r7, r8, [sp, #48]	; 0x30
 8036e72:	461e      	mov	r6, r3
 8036e74:	468a      	mov	sl, r1
 8036e76:	4691      	mov	r9, r2
    TimerTime_t elapsed = TimerGetElapsedTime( identifyChannelsParam->LastAggrTx );
 8036e78:	f004 f9f0 	bl	803b25c <UTIL_TIMER_GetElapsedTime>
    *nextTxDelay = identifyChannelsParam->AggrTimeOff - elapsed;
 8036e7c:	6823      	ldr	r3, [r4, #0]
 8036e7e:	1a1b      	subs	r3, r3, r0
 8036e80:	f8c8 3000 	str.w	r3, [r8]
    *nbRestrictedChannels = 1;
    *nbEnabledChannels = 0;
 8036e84:	2500      	movs	r5, #0
    *nbRestrictedChannels = 1;
 8036e86:	2301      	movs	r3, #1
 8036e88:	703b      	strb	r3, [r7, #0]
    *nbEnabledChannels = 0;
 8036e8a:	7035      	strb	r5, [r6, #0]

    if( ( identifyChannelsParam->LastAggrTx == 0 ) ||
 8036e8c:	6863      	ldr	r3, [r4, #4]
 8036e8e:	b113      	cbz	r3, 8036e96 <RegionCommonIdentifyChannels+0x30>
 8036e90:	6823      	ldr	r3, [r4, #0]
 8036e92:	4283      	cmp	r3, r0
 8036e94:	d825      	bhi.n	8036ee2 <RegionCommonIdentifyChannels+0x7c>
        ( identifyChannelsParam->AggrTimeOff <= elapsed ) )
    {
        // Reset Aggregated time off
        *aggregatedTimeOff = 0;
 8036e96:	f8ca 5000 	str.w	r5, [sl]

        // Update bands Time OFF
        *nextTxDelay = RegionCommonUpdateBandTimeOff( identifyChannelsParam->CountNbOfEnabledChannelsParam->Joined,
 8036e9a:	f8d4 c01c 	ldr.w	ip, [r4, #28]
 8036e9e:	69a3      	ldr	r3, [r4, #24]
 8036ea0:	f89c e000 	ldrb.w	lr, [ip]
 8036ea4:	9303      	str	r3, [sp, #12]
 8036ea6:	e9d4 0103 	ldrd	r0, r1, [r4, #12]
 8036eaa:	ab01      	add	r3, sp, #4
 8036eac:	e883 0003 	stmia.w	r3, {r0, r1}
 8036eb0:	7d23      	ldrb	r3, [r4, #20]
 8036eb2:	9300      	str	r3, [sp, #0]
 8036eb4:	f8dc 100c 	ldr.w	r1, [ip, #12]
 8036eb8:	7a23      	ldrb	r3, [r4, #8]
 8036eba:	7a62      	ldrb	r2, [r4, #9]
 8036ebc:	4670      	mov	r0, lr
 8036ebe:	f7ff fde9 	bl	8036a94 <RegionCommonUpdateBandTimeOff>
                                                      identifyChannelsParam->DutyCycleEnabled,
                                                      identifyChannelsParam->LastTxIsJoinRequest,
                                                      identifyChannelsParam->ElapsedTimeSinceStartUp,
                                                      identifyChannelsParam->ExpectedTimeOnAir );

        RegionCommonCountNbOfEnabledChannels( identifyChannelsParam->CountNbOfEnabledChannelsParam, enabledChannels,
 8036ec2:	463b      	mov	r3, r7
        *nextTxDelay = RegionCommonUpdateBandTimeOff( identifyChannelsParam->CountNbOfEnabledChannelsParam->Joined,
 8036ec4:	f8c8 0000 	str.w	r0, [r8]
        RegionCommonCountNbOfEnabledChannels( identifyChannelsParam->CountNbOfEnabledChannelsParam, enabledChannels,
 8036ec8:	4632      	mov	r2, r6
 8036eca:	69e0      	ldr	r0, [r4, #28]
 8036ecc:	4649      	mov	r1, r9
 8036ece:	f7ff ff73 	bl	8036db8 <RegionCommonCountNbOfEnabledChannels>
                                              nbEnabledChannels, nbRestrictedChannels );
    }

    if( *nbEnabledChannels > 0 )
 8036ed2:	7833      	ldrb	r3, [r6, #0]
 8036ed4:	b12b      	cbz	r3, 8036ee2 <RegionCommonIdentifyChannels+0x7c>
    {
        *nextTxDelay = 0;
 8036ed6:	f8c8 5000 	str.w	r5, [r8]
        return LORAMAC_STATUS_OK;
 8036eda:	2000      	movs	r0, #0
    }
    else
    {
        return LORAMAC_STATUS_NO_CHANNEL_FOUND;
    }
}
 8036edc:	b004      	add	sp, #16
 8036ede:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    else if( *nbRestrictedChannels > 0 )
 8036ee2:	783b      	ldrb	r3, [r7, #0]
        return LORAMAC_STATUS_NO_CHANNEL_FOUND;
 8036ee4:	2b00      	cmp	r3, #0
 8036ee6:	bf14      	ite	ne
 8036ee8:	200b      	movne	r0, #11
 8036eea:	200c      	moveq	r0, #12
 8036eec:	e7f6      	b.n	8036edc <RegionCommonIdentifyChannels+0x76>

08036eee <RegionCommonGetNextLowerTxDr>:

int8_t RegionCommonGetNextLowerTxDr( RegionCommonGetNextLowerTxDrParams_t *params )
{
 8036eee:	b537      	push	{r0, r1, r2, r4, r5, lr}
    int8_t drLocal = params->CurrentDr;
 8036ef0:	f990 2000 	ldrsb.w	r2, [r0]

    if( params->CurrentDr == params->MinDr )
 8036ef4:	f990 5002 	ldrsb.w	r5, [r0, #2]
 8036ef8:	4295      	cmp	r5, r2
{
 8036efa:	4604      	mov	r4, r0
    if( params->CurrentDr == params->MinDr )
 8036efc:	d00f      	beq.n	8036f1e <RegionCommonGetNextLowerTxDr+0x30>
    }
    else
    {
        do
        {
            drLocal = ( drLocal - 1 );
 8036efe:	3a01      	subs	r2, #1
 8036f00:	b252      	sxtb	r2, r2
        } while( ( drLocal != params->MinDr ) &&
                 ( RegionCommonChanVerifyDr( params->NbChannels, params->ChannelsMask, drLocal, params->MinDr, params->MaxDr, params->Channels  ) == false ) );
 8036f02:	42aa      	cmp	r2, r5
 8036f04:	d00b      	beq.n	8036f1e <RegionCommonGetNextLowerTxDr+0x30>
 8036f06:	68a3      	ldr	r3, [r4, #8]
 8036f08:	9301      	str	r3, [sp, #4]
 8036f0a:	f994 3001 	ldrsb.w	r3, [r4, #1]
 8036f0e:	9300      	str	r3, [sp, #0]
 8036f10:	6861      	ldr	r1, [r4, #4]
 8036f12:	78e0      	ldrb	r0, [r4, #3]
 8036f14:	462b      	mov	r3, r5
 8036f16:	f7ff fd16 	bl	8036946 <RegionCommonChanVerifyDr>
        } while( ( drLocal != params->MinDr ) &&
 8036f1a:	2800      	cmp	r0, #0
 8036f1c:	d0ef      	beq.n	8036efe <RegionCommonGetNextLowerTxDr+0x10>

        return drLocal;
    }
}
 8036f1e:	4610      	mov	r0, r2
 8036f20:	b003      	add	sp, #12
 8036f22:	bd30      	pop	{r4, r5, pc}

08036f24 <RegionCommonLimitTxPower>:

int8_t RegionCommonLimitTxPower( int8_t txPower, int8_t maxBandTxPower )
{
    // Limit tx power to the band max
    return MAX( txPower, maxBandTxPower );
}
 8036f24:	4288      	cmp	r0, r1
 8036f26:	bfb8      	it	lt
 8036f28:	4608      	movlt	r0, r1
 8036f2a:	4770      	bx	lr

08036f2c <RegionCommonGetBandwidth>:

uint32_t RegionCommonGetBandwidth( uint32_t drIndex, const uint32_t* bandwidths )
{
    switch( bandwidths[drIndex] )
 8036f2c:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
 8036f30:	4b05      	ldr	r3, [pc, #20]	; (8036f48 <RegionCommonGetBandwidth+0x1c>)
 8036f32:	4298      	cmp	r0, r3
 8036f34:	d005      	beq.n	8036f42 <RegionCommonGetBandwidth+0x16>
        case 125000:
            return 0;
        case 250000:
            return 1;
        case 500000:
            return 2;
 8036f36:	4b05      	ldr	r3, [pc, #20]	; (8036f4c <RegionCommonGetBandwidth+0x20>)
 8036f38:	4298      	cmp	r0, r3
 8036f3a:	bf0c      	ite	eq
 8036f3c:	2002      	moveq	r0, #2
 8036f3e:	2000      	movne	r0, #0
 8036f40:	4770      	bx	lr
    switch( bandwidths[drIndex] )
 8036f42:	2001      	movs	r0, #1
    }
}
 8036f44:	4770      	bx	lr
 8036f46:	bf00      	nop
 8036f48:	0003d090 	.word	0x0003d090
 8036f4c:	0007a120 	.word	0x0007a120

08036f50 <RegionCommonRxConfigPrint>:

/* ST_WORKAROUND_BEGIN: Print Tx/Rx config */
void RegionCommonRxConfigPrint(LoRaMacRxSlot_t rxSlot, uint32_t frequency, int8_t dr)
{
 8036f50:	b5f0      	push	{r4, r5, r6, r7, lr}
    const char *slotStrings[] = { "1", "2", "C", "Multi_C", "P", "Multi_P" };
 8036f52:	4d13      	ldr	r5, [pc, #76]	; (8036fa0 <RegionCommonRxConfigPrint+0x50>)
{
 8036f54:	4606      	mov	r6, r0
 8036f56:	460f      	mov	r7, r1
 8036f58:	4694      	mov	ip, r2
    const char *slotStrings[] = { "1", "2", "C", "Multi_C", "P", "Multi_P" };
 8036f5a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
{
 8036f5c:	b08b      	sub	sp, #44	; 0x2c
    const char *slotStrings[] = { "1", "2", "C", "Multi_C", "P", "Multi_P" };
 8036f5e:	ac04      	add	r4, sp, #16
 8036f60:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8036f62:	e895 0003 	ldmia.w	r5, {r0, r1}

    if ( rxSlot < RX_SLOT_NONE )
 8036f66:	2e05      	cmp	r6, #5
    const char *slotStrings[] = { "1", "2", "C", "Multi_C", "P", "Multi_P" };
 8036f68:	e884 0003 	stmia.w	r4, {r0, r1}
    if ( rxSlot < RX_SLOT_NONE )
 8036f6c:	d80f      	bhi.n	8036f8e <RegionCommonRxConfigPrint+0x3e>
    {
        MW_LOG(TS_ON, VLEVEL_M,  "RX_%s on freq %d Hz at DR %d\r\n", slotStrings[rxSlot], frequency, dr );
 8036f6e:	ab0a      	add	r3, sp, #40	; 0x28
 8036f70:	e9cd 7c01 	strd	r7, ip, [sp, #4]
 8036f74:	eb03 0686 	add.w	r6, r3, r6, lsl #2
 8036f78:	2201      	movs	r2, #1
 8036f7a:	f856 3c18 	ldr.w	r3, [r6, #-24]
 8036f7e:	9300      	str	r3, [sp, #0]
 8036f80:	2100      	movs	r1, #0
 8036f82:	4b08      	ldr	r3, [pc, #32]	; (8036fa4 <RegionCommonRxConfigPrint+0x54>)
 8036f84:	2002      	movs	r0, #2
 8036f86:	f003 fe81 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
    }
    else
    {
        MW_LOG(TS_ON, VLEVEL_M,  "RX on freq %d Hz at DR %d\r\n", frequency, dr );
    }
}
 8036f8a:	b00b      	add	sp, #44	; 0x2c
 8036f8c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        MW_LOG(TS_ON, VLEVEL_M,  "RX on freq %d Hz at DR %d\r\n", frequency, dr );
 8036f8e:	e9cd 7c00 	strd	r7, ip, [sp]
 8036f92:	4b05      	ldr	r3, [pc, #20]	; (8036fa8 <RegionCommonRxConfigPrint+0x58>)
 8036f94:	2201      	movs	r2, #1
 8036f96:	2100      	movs	r1, #0
 8036f98:	2002      	movs	r0, #2
 8036f9a:	f003 fe77 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
}
 8036f9e:	e7f4      	b.n	8036f8a <RegionCommonRxConfigPrint+0x3a>
 8036fa0:	0803ba6c 	.word	0x0803ba6c
 8036fa4:	0803c31e 	.word	0x0803c31e
 8036fa8:	0803c33d 	.word	0x0803c33d

08036fac <RegionCommonTxConfigPrint>:

void RegionCommonTxConfigPrint(uint32_t frequency, int8_t dr)
{
 8036fac:	b507      	push	{r0, r1, r2, lr}
    MW_LOG(TS_ON, VLEVEL_M,  "TX on freq %d Hz at DR %d\r\n", frequency, dr );
 8036fae:	4b05      	ldr	r3, [pc, #20]	; (8036fc4 <RegionCommonTxConfigPrint+0x18>)
 8036fb0:	e9cd 0100 	strd	r0, r1, [sp]
 8036fb4:	2201      	movs	r2, #1
 8036fb6:	2100      	movs	r1, #0
 8036fb8:	2002      	movs	r0, #2
 8036fba:	f003 fe67 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
}
 8036fbe:	b003      	add	sp, #12
 8036fc0:	f85d fb04 	ldr.w	pc, [sp], #4
 8036fc4:	0803c359 	.word	0x0803c359

08036fc8 <GetTimeOnAir>:
    }
    return true;
}

static TimerTime_t GetTimeOnAir( int8_t datarate, uint16_t pktLen )
{
 8036fc8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8036fca:	460c      	mov	r4, r1
    int8_t phyDr = DataratesEU868[datarate];
 8036fcc:	4910      	ldr	r1, [pc, #64]	; (8037010 <GetTimeOnAir+0x48>)
{
 8036fce:	b085      	sub	sp, #20
    int8_t phyDr = DataratesEU868[datarate];
 8036fd0:	560f      	ldrsb	r7, [r1, r0]
    uint32_t bandwidth = RegionCommonGetBandwidth( datarate, BandwidthsEU868 );
 8036fd2:	3108      	adds	r1, #8
{
 8036fd4:	4605      	mov	r5, r0
    uint32_t bandwidth = RegionCommonGetBandwidth( datarate, BandwidthsEU868 );
 8036fd6:	f7ff ffa9 	bl	8036f2c <RegionCommonGetBandwidth>
 8036fda:	4b0e      	ldr	r3, [pc, #56]	; (8037014 <GetTimeOnAir+0x4c>)
 8036fdc:	b2e4      	uxtb	r4, r4
 8036fde:	6a5e      	ldr	r6, [r3, #36]	; 0x24
    TimerTime_t timeOnAir = 0;

    if( datarate == DR_7 )
 8036fe0:	2d07      	cmp	r5, #7
 8036fe2:	f04f 0301 	mov.w	r3, #1
    { // High Speed FSK channel
        timeOnAir = Radio.TimeOnAir( MODEM_FSK, bandwidth, phyDr * 1000, 0, 5, false, pktLen, true );
 8036fe6:	e9cd 4302 	strd	r4, r3, [sp, #8]
    uint32_t bandwidth = RegionCommonGetBandwidth( datarate, BandwidthsEU868 );
 8036fea:	4601      	mov	r1, r0
    if( datarate == DR_7 )
 8036fec:	d10a      	bne.n	8037004 <GetTimeOnAir+0x3c>
        timeOnAir = Radio.TimeOnAir( MODEM_FSK, bandwidth, phyDr * 1000, 0, 5, false, pktLen, true );
 8036fee:	2205      	movs	r2, #5
 8036ff0:	2300      	movs	r3, #0
 8036ff2:	e9cd 2300 	strd	r2, r3, [sp]
 8036ff6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8036ffa:	437a      	muls	r2, r7
    }
    else
    {
        timeOnAir = Radio.TimeOnAir( MODEM_LORA, bandwidth, phyDr, 1, 8, false, pktLen, true );
 8036ffc:	4618      	mov	r0, r3
 8036ffe:	47b0      	blx	r6
    }
    return timeOnAir;
}
 8037000:	b005      	add	sp, #20
 8037002:	bdf0      	pop	{r4, r5, r6, r7, pc}
        timeOnAir = Radio.TimeOnAir( MODEM_LORA, bandwidth, phyDr, 1, 8, false, pktLen, true );
 8037004:	2208      	movs	r2, #8
 8037006:	2000      	movs	r0, #0
 8037008:	e9cd 2000 	strd	r2, r0, [sp]
 803700c:	463a      	mov	r2, r7
 803700e:	e7f5      	b.n	8036ffc <GetTimeOnAir+0x34>
 8037010:	0803ba84 	.word	0x0803ba84
 8037014:	0803bbc0 	.word	0x0803bbc0

08037018 <VerifyRfFreq>:
{
 8037018:	b538      	push	{r3, r4, r5, lr}
    if( Radio.CheckRfFrequency( freq ) == false )
 803701a:	4b19      	ldr	r3, [pc, #100]	; (8037080 <VerifyRfFreq+0x68>)
 803701c:	6a1b      	ldr	r3, [r3, #32]
{
 803701e:	4605      	mov	r5, r0
 8037020:	460c      	mov	r4, r1
    if( Radio.CheckRfFrequency( freq ) == false )
 8037022:	4798      	blx	r3
 8037024:	b130      	cbz	r0, 8037034 <VerifyRfFreq+0x1c>
    if( ( freq >= 863000000 ) && ( freq < 865000000 ) )
 8037026:	4b17      	ldr	r3, [pc, #92]	; (8037084 <VerifyRfFreq+0x6c>)
 8037028:	4a17      	ldr	r2, [pc, #92]	; (8037088 <VerifyRfFreq+0x70>)
 803702a:	442b      	add	r3, r5
 803702c:	4293      	cmp	r3, r2
 803702e:	d802      	bhi.n	8037036 <VerifyRfFreq+0x1e>
        *band = 2;
 8037030:	2302      	movs	r3, #2
        *band = 3;
 8037032:	7023      	strb	r3, [r4, #0]
}
 8037034:	bd38      	pop	{r3, r4, r5, pc}
    else if( ( freq >= 865000000 ) && ( freq <= 868000000 ) )
 8037036:	4b15      	ldr	r3, [pc, #84]	; (803708c <VerifyRfFreq+0x74>)
 8037038:	4a15      	ldr	r2, [pc, #84]	; (8037090 <VerifyRfFreq+0x78>)
 803703a:	442b      	add	r3, r5
 803703c:	4293      	cmp	r3, r2
 803703e:	d801      	bhi.n	8037044 <VerifyRfFreq+0x2c>
        *band = 0;
 8037040:	2300      	movs	r3, #0
 8037042:	e7f6      	b.n	8037032 <VerifyRfFreq+0x1a>
    else if( ( freq > 868000000 ) && ( freq <= 868600000 ) )
 8037044:	4b13      	ldr	r3, [pc, #76]	; (8037094 <VerifyRfFreq+0x7c>)
 8037046:	4a14      	ldr	r2, [pc, #80]	; (8037098 <VerifyRfFreq+0x80>)
 8037048:	442b      	add	r3, r5
 803704a:	4293      	cmp	r3, r2
 803704c:	d801      	bhi.n	8037052 <VerifyRfFreq+0x3a>
        *band = 1;
 803704e:	2301      	movs	r3, #1
 8037050:	e7ef      	b.n	8037032 <VerifyRfFreq+0x1a>
    else if( ( freq >= 868700000 ) && ( freq <= 869200000 ) )
 8037052:	4b12      	ldr	r3, [pc, #72]	; (803709c <VerifyRfFreq+0x84>)
 8037054:	4a12      	ldr	r2, [pc, #72]	; (80370a0 <VerifyRfFreq+0x88>)
 8037056:	442b      	add	r3, r5
 8037058:	4293      	cmp	r3, r2
 803705a:	d801      	bhi.n	8037060 <VerifyRfFreq+0x48>
        *band = 5;
 803705c:	2305      	movs	r3, #5
 803705e:	e7e8      	b.n	8037032 <VerifyRfFreq+0x1a>
    else if( ( freq >= 869400000 ) && ( freq <= 869650000 ) )
 8037060:	4b10      	ldr	r3, [pc, #64]	; (80370a4 <VerifyRfFreq+0x8c>)
 8037062:	4a11      	ldr	r2, [pc, #68]	; (80370a8 <VerifyRfFreq+0x90>)
 8037064:	442b      	add	r3, r5
 8037066:	4293      	cmp	r3, r2
 8037068:	d801      	bhi.n	803706e <VerifyRfFreq+0x56>
        *band = 3;
 803706a:	2303      	movs	r3, #3
 803706c:	e7e1      	b.n	8037032 <VerifyRfFreq+0x1a>
    else if( ( freq >= 869700000 ) && ( freq <= 870000000 ) )
 803706e:	4b0f      	ldr	r3, [pc, #60]	; (80370ac <VerifyRfFreq+0x94>)
 8037070:	4a0f      	ldr	r2, [pc, #60]	; (80370b0 <VerifyRfFreq+0x98>)
 8037072:	442b      	add	r3, r5
 8037074:	4293      	cmp	r3, r2
 8037076:	d801      	bhi.n	803707c <VerifyRfFreq+0x64>
        *band = 4;
 8037078:	2304      	movs	r3, #4
 803707a:	e7da      	b.n	8037032 <VerifyRfFreq+0x1a>
        return false;
 803707c:	2000      	movs	r0, #0
 803707e:	e7d9      	b.n	8037034 <VerifyRfFreq+0x1c>
 8037080:	0803bbc0 	.word	0x0803bbc0
 8037084:	cc8faa40 	.word	0xcc8faa40
 8037088:	001e847f 	.word	0x001e847f
 803708c:	cc7125c0 	.word	0xcc7125c0
 8037090:	002dc6c0 	.word	0x002dc6c0
 8037094:	cc435eff 	.word	0xcc435eff
 8037098:	000927bf 	.word	0x000927bf
 803709c:	cc38b0a0 	.word	0xcc38b0a0
 80370a0:	0007a120 	.word	0x0007a120
 80370a4:	cc2e0240 	.word	0xcc2e0240
 80370a8:	0003d090 	.word	0x0003d090
 80370ac:	cc296e60 	.word	0xcc296e60
 80370b0:	000493e0 	.word	0x000493e0

080370b4 <RegionEU868GetPhyParam>:
#endif /* REGION_EU868 */

PhyParam_t RegionEU868GetPhyParam( GetPhyParams_t* getPhy )
{
 80370b4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 80370b6:	7802      	ldrb	r2, [r0, #0]
    PhyParam_t phyParam = { 0 };
 80370b8:	2300      	movs	r3, #0
 80370ba:	3a0b      	subs	r2, #11
 80370bc:	9300      	str	r3, [sp, #0]

#if defined( REGION_EU868 )
    switch( getPhy->Attribute )
 80370be:	2a2e      	cmp	r2, #46	; 0x2e
 80370c0:	d871      	bhi.n	80371a6 <RegionEU868GetPhyParam+0xf2>
 80370c2:	e8df f002 	tbb	[pc, r2]
 80370c6:	302d      	.short	0x302d
 80370c8:	42403932 	.word	0x42403932
 80370cc:	4e4b4845 	.word	0x4e4b4845
 80370d0:	5c705451 	.word	0x5c705451
 80370d4:	68635e70 	.word	0x68635e70
 80370d8:	6d70706a 	.word	0x6d70706a
 80370dc:	70701874 	.word	0x70701874
 80370e0:	70707070 	.word	0x70707070
 80370e4:	70707070 	.word	0x70707070
 80370e8:	5c707070 	.word	0x5c707070
 80370ec:	70707d76 	.word	0x70707d76
 80370f0:	7f707d5c 	.word	0x7f707d5c
 80370f4:	84          	.byte	0x84
 80370f5:	00          	.byte	0x00
            phyParam.Value = EU868_DEFAULT_DATARATE;
            break;
        }
        case PHY_NEXT_LOWER_TX_DR:
        {
            RegionCommonGetNextLowerTxDrParams_t nextLowerTxDrParams =
 80370f6:	7843      	ldrb	r3, [r0, #1]
 80370f8:	f88d 3004 	strb.w	r3, [sp, #4]
 80370fc:	2307      	movs	r3, #7
 80370fe:	f88d 3005 	strb.w	r3, [sp, #5]
 8037102:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8037106:	f8ad 3006 	strh.w	r3, [sp, #6]
            {
                .CurrentDr = getPhy->Datarate,
                .MaxDr = ( int8_t )EU868_TX_MAX_DATARATE,
                .MinDr = ( int8_t )EU868_TX_MIN_DATARATE,
                .NbChannels = EU868_MAX_NB_CHANNELS,
                .ChannelsMask = RegionNvmGroup2->ChannelsMask,
 803710a:	4b34      	ldr	r3, [pc, #208]	; (80371dc <RegionEU868GetPhyParam+0x128>)
 803710c:	681b      	ldr	r3, [r3, #0]
                .Channels = RegionNvmGroup2->Channels,
            };
            phyParam.Value = RegionCommonGetNextLowerTxDr( &nextLowerTxDrParams );
 803710e:	a801      	add	r0, sp, #4
                .ChannelsMask = RegionNvmGroup2->ChannelsMask,
 8037110:	f503 7258 	add.w	r2, r3, #864	; 0x360
            RegionCommonGetNextLowerTxDrParams_t nextLowerTxDrParams =
 8037114:	e9cd 2302 	strd	r2, r3, [sp, #8]
            phyParam.Value = RegionCommonGetNextLowerTxDr( &nextLowerTxDrParams );
 8037118:	f7ff fee9 	bl	8036eee <RegionCommonGetNextLowerTxDr>
            phyParam.Value = DataratesEU868[getPhy->Datarate];
            break;
        }
        case PHY_BW_FROM_DR:
        {
            phyParam.Value = RegionCommonGetBandwidth( getPhy->Datarate, BandwidthsEU868 );
 803711c:	9000      	str	r0, [sp, #0]
            break;
 803711e:	e042      	b.n	80371a6 <RegionEU868GetPhyParam+0xf2>
            phyParam.Value = REGION_COMMON_DEFAULT_ADR_ACK_LIMIT;
 8037120:	2340      	movs	r3, #64	; 0x40
            phyParam.Value = EU868_BEACON_CHANNEL_DR;
 8037122:	9300      	str	r3, [sp, #0]
            break;
 8037124:	e03f      	b.n	80371a6 <RegionEU868GetPhyParam+0xf2>
            phyParam.Value = REGION_COMMON_DEFAULT_ADR_ACK_DELAY;
 8037126:	2320      	movs	r3, #32
 8037128:	e7fb      	b.n	8037122 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = MaxPayloadOfDatarateEU868[getPhy->Datarate];
 803712a:	f990 2001 	ldrsb.w	r2, [r0, #1]
 803712e:	4b2c      	ldr	r3, [pc, #176]	; (80371e0 <RegionEU868GetPhyParam+0x12c>)
 8037130:	4413      	add	r3, r2
 8037132:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8037136:	e7f4      	b.n	8037122 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = MaxPayloadOfDatarateRepeaterEU868[getPhy->Datarate];
 8037138:	f990 2001 	ldrsb.w	r2, [r0, #1]
 803713c:	4b28      	ldr	r3, [pc, #160]	; (80371e0 <RegionEU868GetPhyParam+0x12c>)
 803713e:	4413      	add	r3, r2
 8037140:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8037144:	e7ed      	b.n	8037122 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = EU868_DUTY_CYCLE_ENABLED;
 8037146:	2301      	movs	r3, #1
 8037148:	e7eb      	b.n	8037122 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = EU868_MAX_RX_WINDOW;
 803714a:	f640 33b8 	movw	r3, #3000	; 0xbb8
 803714e:	e7e8      	b.n	8037122 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = REGION_COMMON_DEFAULT_RECEIVE_DELAY1;
 8037150:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8037154:	e7e5      	b.n	8037122 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = REGION_COMMON_DEFAULT_RECEIVE_DELAY2;
 8037156:	f44f 63fa 	mov.w	r3, #2000	; 0x7d0
 803715a:	e7e2      	b.n	8037122 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = REGION_COMMON_DEFAULT_JOIN_ACCEPT_DELAY1;
 803715c:	f241 3388 	movw	r3, #5000	; 0x1388
 8037160:	e7df      	b.n	8037122 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = REGION_COMMON_DEFAULT_JOIN_ACCEPT_DELAY2;
 8037162:	f241 7370 	movw	r3, #6000	; 0x1770
 8037166:	e7dc      	b.n	8037122 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = REGION_COMMON_DEFAULT_MAX_FCNT_GAP;
 8037168:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 803716c:	e7d9      	b.n	8037122 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = ( REGION_COMMON_DEFAULT_ACK_TIMEOUT + randr( -REGION_COMMON_DEFAULT_ACK_TIMEOUT_RND, REGION_COMMON_DEFAULT_ACK_TIMEOUT_RND ) );
 803716e:	481d      	ldr	r0, [pc, #116]	; (80371e4 <RegionEU868GetPhyParam+0x130>)
 8037170:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8037174:	f001 fe88 	bl	8038e88 <randr>
 8037178:	f500 60fa 	add.w	r0, r0, #2000	; 0x7d0
 803717c:	e7ce      	b.n	803711c <RegionEU868GetPhyParam+0x68>
            phyParam.Value = EU868_RX_WND_2_FREQ;
 803717e:	4b1a      	ldr	r3, [pc, #104]	; (80371e8 <RegionEU868GetPhyParam+0x134>)
 8037180:	e7cf      	b.n	8037122 <RegionEU868GetPhyParam+0x6e>
            phyParam.ChannelsMask = RegionNvmGroup2->ChannelsMask;
 8037182:	4b16      	ldr	r3, [pc, #88]	; (80371dc <RegionEU868GetPhyParam+0x128>)
 8037184:	681b      	ldr	r3, [r3, #0]
 8037186:	f503 7358 	add.w	r3, r3, #864	; 0x360
 803718a:	e7ca      	b.n	8037122 <RegionEU868GetPhyParam+0x6e>
            phyParam.ChannelsMask = RegionNvmGroup2->ChannelsDefaultMask;
 803718c:	4b13      	ldr	r3, [pc, #76]	; (80371dc <RegionEU868GetPhyParam+0x128>)
 803718e:	681b      	ldr	r3, [r3, #0]
 8037190:	f503 735b 	add.w	r3, r3, #876	; 0x36c
 8037194:	e7c5      	b.n	8037122 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = EU868_MAX_NB_CHANNELS;
 8037196:	2310      	movs	r3, #16
 8037198:	e7c3      	b.n	8037122 <RegionEU868GetPhyParam+0x6e>
            phyParam.Channels = RegionNvmGroup2->Channels;
 803719a:	4b10      	ldr	r3, [pc, #64]	; (80371dc <RegionEU868GetPhyParam+0x128>)
 803719c:	681b      	ldr	r3, [r3, #0]
 803719e:	e7c0      	b.n	8037122 <RegionEU868GetPhyParam+0x6e>
            phyParam.fValue = EU868_DEFAULT_MAX_EIRP;
 80371a0:	f04f 4383 	mov.w	r3, #1098907648	; 0x41800000
            phyParam.fValue = EU868_DEFAULT_ANTENNA_GAIN;
 80371a4:	9300      	str	r3, [sp, #0]
        }
    }

#endif /* REGION_EU868 */
    return phyParam;
}
 80371a6:	9800      	ldr	r0, [sp, #0]
 80371a8:	b005      	add	sp, #20
 80371aa:	f85d fb04 	ldr.w	pc, [sp], #4
            phyParam.fValue = EU868_DEFAULT_ANTENNA_GAIN;
 80371ae:	4b0f      	ldr	r3, [pc, #60]	; (80371ec <RegionEU868GetPhyParam+0x138>)
 80371b0:	e7f8      	b.n	80371a4 <RegionEU868GetPhyParam+0xf0>
            phyParam.BeaconFormat.BeaconSize = EU868_BEACON_SIZE;
 80371b2:	f240 2211 	movw	r2, #529	; 0x211
 80371b6:	f8ad 2000 	strh.w	r2, [sp]
            phyParam.BeaconFormat.Rfu2Size = EU868_RFU2_SIZE;
 80371ba:	f88d 3002 	strb.w	r3, [sp, #2]
            break;
 80371be:	e7f2      	b.n	80371a6 <RegionEU868GetPhyParam+0xf2>
            phyParam.Value = EU868_BEACON_CHANNEL_DR;
 80371c0:	2303      	movs	r3, #3
 80371c2:	e7ae      	b.n	8037122 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = DataratesEU868[getPhy->Datarate];
 80371c4:	f990 3001 	ldrsb.w	r3, [r0, #1]
 80371c8:	4a05      	ldr	r2, [pc, #20]	; (80371e0 <RegionEU868GetPhyParam+0x12c>)
 80371ca:	5cd3      	ldrb	r3, [r2, r3]
 80371cc:	e7a9      	b.n	8037122 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = RegionCommonGetBandwidth( getPhy->Datarate, BandwidthsEU868 );
 80371ce:	4908      	ldr	r1, [pc, #32]	; (80371f0 <RegionEU868GetPhyParam+0x13c>)
 80371d0:	f990 0001 	ldrsb.w	r0, [r0, #1]
 80371d4:	f7ff feaa 	bl	8036f2c <RegionCommonGetBandwidth>
 80371d8:	e7a0      	b.n	803711c <RegionEU868GetPhyParam+0x68>
 80371da:	bf00      	nop
 80371dc:	20005728 	.word	0x20005728
 80371e0:	0803ba84 	.word	0x0803ba84
 80371e4:	fffffc18 	.word	0xfffffc18
 80371e8:	33d3e608 	.word	0x33d3e608
 80371ec:	4009999a 	.word	0x4009999a
 80371f0:	0803ba8c 	.word	0x0803ba8c

080371f4 <RegionEU868SetBandTxDone>:

void RegionEU868SetBandTxDone( SetBandTxDoneParams_t* txDone )
{
 80371f4:	b537      	push	{r0, r1, r2, r4, r5, lr}
#if defined( REGION_EU868 )
    RegionCommonSetBandTxDone( &RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txDone->Channel].Band],
 80371f6:	4a0a      	ldr	r2, [pc, #40]	; (8037220 <RegionEU868SetBandTxDone+0x2c>)
 80371f8:	7803      	ldrb	r3, [r0, #0]
 80371fa:	6811      	ldr	r1, [r2, #0]
 80371fc:	6855      	ldr	r5, [r2, #4]
 80371fe:	240c      	movs	r4, #12
 8037200:	fb04 1303 	mla	r3, r4, r3, r1
 8037204:	7a5b      	ldrb	r3, [r3, #9]
 8037206:	eb03 0443 	add.w	r4, r3, r3, lsl #1
 803720a:	6903      	ldr	r3, [r0, #16]
 803720c:	9300      	str	r3, [sp, #0]
 803720e:	68c3      	ldr	r3, [r0, #12]
 8037210:	7842      	ldrb	r2, [r0, #1]
 8037212:	6881      	ldr	r1, [r0, #8]
 8037214:	eb05 00c4 	add.w	r0, r5, r4, lsl #3
 8037218:	f7ff fc18 	bl	8036a4c <RegionCommonSetBandTxDone>
                               txDone->LastTxAirTime, txDone->Joined, txDone->ElapsedTimeSinceStartUp );
#endif /* REGION_EU868 */
}
 803721c:	b003      	add	sp, #12
 803721e:	bd30      	pop	{r4, r5, pc}
 8037220:	20005728 	.word	0x20005728

08037224 <RegionEU868InitDefaults>:

void RegionEU868InitDefaults( InitDefaultsParams_t* params )
{
 8037224:	b530      	push	{r4, r5, lr}
 8037226:	b0a5      	sub	sp, #148	; 0x94
 8037228:	4604      	mov	r4, r0
#if defined( REGION_EU868 )
    Band_t bands[EU868_MAX_NB_BANDS] =
 803722a:	2290      	movs	r2, #144	; 0x90
 803722c:	2100      	movs	r1, #0
 803722e:	4668      	mov	r0, sp
 8037230:	f004 fa72 	bl	803b718 <memset>
 8037234:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8037238:	f8ad 2030 	strh.w	r2, [sp, #48]	; 0x30
 803723c:	f8ad 2078 	strh.w	r2, [sp, #120]	; 0x78
        EU868_BAND3,
        EU868_BAND4,
        EU868_BAND5,
    };

    switch( params->Type )
 8037240:	7a22      	ldrb	r2, [r4, #8]
    Band_t bands[EU868_MAX_NB_BANDS] =
 8037242:	2364      	movs	r3, #100	; 0x64
 8037244:	210a      	movs	r1, #10
    switch( params->Type )
 8037246:	2a01      	cmp	r2, #1
    Band_t bands[EU868_MAX_NB_BANDS] =
 8037248:	f8ad 3000 	strh.w	r3, [sp]
 803724c:	f8ad 3018 	strh.w	r3, [sp, #24]
 8037250:	f8ad 1048 	strh.w	r1, [sp, #72]	; 0x48
 8037254:	f8ad 3060 	strh.w	r3, [sp, #96]	; 0x60
    switch( params->Type )
 8037258:	d02d      	beq.n	80372b6 <RegionEU868InitDefaults+0x92>
 803725a:	2a02      	cmp	r2, #2
 803725c:	d036      	beq.n	80372cc <RegionEU868InitDefaults+0xa8>
 803725e:	bb42      	cbnz	r2, 80372b2 <RegionEU868InitDefaults+0x8e>
    {
        case INIT_TYPE_DEFAULTS:
        {
            if( ( params->NvmGroup1 == NULL ) || ( params->NvmGroup2 == NULL ) )
 8037260:	6820      	ldr	r0, [r4, #0]
 8037262:	b330      	cbz	r0, 80372b2 <RegionEU868InitDefaults+0x8e>
 8037264:	6863      	ldr	r3, [r4, #4]
 8037266:	b323      	cbz	r3, 80372b2 <RegionEU868InitDefaults+0x8e>
            {
                return;
            }

            RegionNvmGroup1 = (RegionNvmDataGroup1_t*) params->NvmGroup1;
 8037268:	4c1d      	ldr	r4, [pc, #116]	; (80372e0 <RegionEU868InitDefaults+0xbc>)
            RegionNvmGroup2 = (RegionNvmDataGroup2_t*) params->NvmGroup2;

            // Default bands
            memcpy1( ( uint8_t* )RegionNvmGroup1->Bands, ( uint8_t* )bands, sizeof( Band_t ) * EU868_MAX_NB_BANDS );
 803726a:	2290      	movs	r2, #144	; 0x90
 803726c:	4669      	mov	r1, sp
            RegionNvmGroup2 = (RegionNvmDataGroup2_t*) params->NvmGroup2;
 803726e:	e9c4 3000 	strd	r3, r0, [r4]
            memcpy1( ( uint8_t* )RegionNvmGroup1->Bands, ( uint8_t* )bands, sizeof( Band_t ) * EU868_MAX_NB_BANDS );
 8037272:	f001 fe25 	bl	8038ec0 <memcpy1>

            // Default channels
            RegionNvmGroup2->Channels[0] = ( ChannelParams_t ) EU868_LC1;
 8037276:	4b1b      	ldr	r3, [pc, #108]	; (80372e4 <RegionEU868InitDefaults+0xc0>)
 8037278:	6824      	ldr	r4, [r4, #0]
 803727a:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 803727e:	e884 0007 	stmia.w	r4, {r0, r1, r2}
            RegionNvmGroup2->Channels[1] = ( ChannelParams_t ) EU868_LC2;
 8037282:	f103 020c 	add.w	r2, r3, #12
 8037286:	ca07      	ldmia	r2, {r0, r1, r2}
 8037288:	f104 050c 	add.w	r5, r4, #12
            RegionNvmGroup2->Channels[2] = ( ChannelParams_t ) EU868_LC3;
 803728c:	3318      	adds	r3, #24
            RegionNvmGroup2->Channels[1] = ( ChannelParams_t ) EU868_LC2;
 803728e:	e885 0007 	stmia.w	r5, {r0, r1, r2}
            RegionNvmGroup2->Channels[2] = ( ChannelParams_t ) EU868_LC3;
 8037292:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8037296:	f104 0518 	add.w	r5, r4, #24

            // Default ChannelsMask
            RegionNvmGroup2->ChannelsDefaultMask[0] = LC( 1 ) + LC( 2 ) + LC( 3 );
 803729a:	2307      	movs	r3, #7
            RegionNvmGroup2->Channels[2] = ( ChannelParams_t ) EU868_LC3;
 803729c:	e885 0007 	stmia.w	r5, {r0, r1, r2}
            RegionNvmGroup2->ChannelsDefaultMask[0] = LC( 1 ) + LC( 2 ) + LC( 3 );
 80372a0:	f8a4 336c 	strh.w	r3, [r4, #876]	; 0x36c

            // Update the channels mask
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
 80372a4:	2201      	movs	r2, #1
 80372a6:	f504 715b 	add.w	r1, r4, #876	; 0x36c
 80372aa:	f504 7058 	add.w	r0, r4, #864	; 0x360
            // Reset Channels Rx1Frequency to default 0
            RegionNvmGroup2->Channels[0].Rx1Frequency = 0;
            RegionNvmGroup2->Channels[1].Rx1Frequency = 0;
            RegionNvmGroup2->Channels[2].Rx1Frequency = 0;
            // Update the channels mask
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
 80372ae:	f7ff fbbe 	bl	8036a2e <RegionCommonChanMaskCopy>
        {
            break;
        }
    }
#endif /* REGION_EU868 */
}
 80372b2:	b025      	add	sp, #148	; 0x94
 80372b4:	bd30      	pop	{r4, r5, pc}
            RegionNvmGroup2->Channels[0].Rx1Frequency = 0;
 80372b6:	4b0a      	ldr	r3, [pc, #40]	; (80372e0 <RegionEU868InitDefaults+0xbc>)
 80372b8:	6818      	ldr	r0, [r3, #0]
 80372ba:	2300      	movs	r3, #0
 80372bc:	6043      	str	r3, [r0, #4]
            RegionNvmGroup2->Channels[1].Rx1Frequency = 0;
 80372be:	6103      	str	r3, [r0, #16]
            RegionNvmGroup2->Channels[2].Rx1Frequency = 0;
 80372c0:	61c3      	str	r3, [r0, #28]
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
 80372c2:	f500 715b 	add.w	r1, r0, #876	; 0x36c
 80372c6:	f500 7058 	add.w	r0, r0, #864	; 0x360
 80372ca:	e7f0      	b.n	80372ae <RegionEU868InitDefaults+0x8a>
            RegionNvmGroup2->ChannelsMask[0] |= RegionNvmGroup2->ChannelsDefaultMask[0];
 80372cc:	4b04      	ldr	r3, [pc, #16]	; (80372e0 <RegionEU868InitDefaults+0xbc>)
 80372ce:	681b      	ldr	r3, [r3, #0]
 80372d0:	f8b3 2360 	ldrh.w	r2, [r3, #864]	; 0x360
 80372d4:	f8b3 136c 	ldrh.w	r1, [r3, #876]	; 0x36c
 80372d8:	430a      	orrs	r2, r1
 80372da:	f8a3 2360 	strh.w	r2, [r3, #864]	; 0x360
            break;
 80372de:	e7e8      	b.n	80372b2 <RegionEU868InitDefaults+0x8e>
 80372e0:	20005728 	.word	0x20005728
 80372e4:	0803babc 	.word	0x0803babc

080372e8 <RegionEU868Verify>:

bool RegionEU868Verify( VerifyParams_t* verify, PhyAttribute_t phyAttribute )
{
 80372e8:	b507      	push	{r0, r1, r2, lr}
 80372ea:	290f      	cmp	r1, #15
 80372ec:	d809      	bhi.n	8037302 <RegionEU868Verify+0x1a>
 80372ee:	e8df f001 	tbb	[pc, r1]
 80372f2:	080c      	.short	0x080c
 80372f4:	1f080808 	.word	0x1f080808
 80372f8:	1f081f15 	.word	0x1f081f15
 80372fc:	0808081f 	.word	0x0808081f
 8037300:	2108      	.short	0x2108
            // Remark: switched min and max!
            return RegionCommonValueInRange( verify->TxPower, EU868_MAX_TX_POWER, EU868_MIN_TX_POWER );
        }
        case PHY_DUTY_CYCLE:
        {
            return EU868_DUTY_CYCLE_ENABLED;
 8037302:	2000      	movs	r0, #0
            return false;
    }
#else
    return false;
#endif /* REGION_EU868 */
}
 8037304:	b003      	add	sp, #12
 8037306:	f85d fb04 	ldr.w	pc, [sp], #4
            uint8_t band = 0;
 803730a:	2300      	movs	r3, #0
            return VerifyRfFreq( verify->Frequency, &band );
 803730c:	f10d 0107 	add.w	r1, sp, #7
 8037310:	6800      	ldr	r0, [r0, #0]
            uint8_t band = 0;
 8037312:	f88d 3007 	strb.w	r3, [sp, #7]
            return VerifyRfFreq( verify->Frequency, &band );
 8037316:	f7ff fe7f 	bl	8037018 <VerifyRfFreq>
 803731a:	e7f3      	b.n	8037304 <RegionEU868Verify+0x1c>
            return RegionCommonValueInRange( verify->DatarateParams.Datarate, DR_0, DR_5 );
 803731c:	2205      	movs	r2, #5
 803731e:	f990 0000 	ldrsb.w	r0, [r0]
 8037322:	2100      	movs	r1, #0
 8037324:	f7ff fb43 	bl	80369ae <RegionCommonValueInRange>
 8037328:	3800      	subs	r0, #0
 803732a:	bf18      	it	ne
 803732c:	2001      	movne	r0, #1
 803732e:	e7e9      	b.n	8037304 <RegionEU868Verify+0x1c>
            return RegionCommonValueInRange( verify->TxPower, EU868_MAX_TX_POWER, EU868_MIN_TX_POWER );
 8037330:	2207      	movs	r2, #7
 8037332:	e7f4      	b.n	803731e <RegionEU868Verify+0x36>
            return EU868_DUTY_CYCLE_ENABLED;
 8037334:	2001      	movs	r0, #1
 8037336:	e7e5      	b.n	8037304 <RegionEU868Verify+0x1c>

08037338 <RegionEU868ChanMaskSet>:
    }
#endif /* REGION_EU868 */
}

bool RegionEU868ChanMaskSet( ChanMaskSetParams_t* chanMaskSet )
{
 8037338:	b510      	push	{r4, lr}
#if defined( REGION_EU868 )
    switch( chanMaskSet->ChannelsMaskType )
 803733a:	7904      	ldrb	r4, [r0, #4]
 803733c:	b11c      	cbz	r4, 8037346 <RegionEU868ChanMaskSet+0xe>
 803733e:	2c01      	cmp	r4, #1
 8037340:	d00b      	beq.n	803735a <RegionEU868ChanMaskSet+0x22>
 8037342:	2000      	movs	r0, #0
    }
    return true;
#else
    return false;
#endif /* REGION_EU868 */
}
 8037344:	bd10      	pop	{r4, pc}
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, chanMaskSet->ChannelsMaskIn, CHANNELS_MASK_SIZE );
 8037346:	4b0a      	ldr	r3, [pc, #40]	; (8037370 <RegionEU868ChanMaskSet+0x38>)
 8037348:	6801      	ldr	r1, [r0, #0]
 803734a:	681b      	ldr	r3, [r3, #0]
 803734c:	2201      	movs	r2, #1
 803734e:	f503 7058 	add.w	r0, r3, #864	; 0x360
 8037352:	f7ff fb6c 	bl	8036a2e <RegionCommonChanMaskCopy>
    return true;
 8037356:	2001      	movs	r0, #1
            break;
 8037358:	e7f4      	b.n	8037344 <RegionEU868ChanMaskSet+0xc>
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsDefaultMask, chanMaskSet->ChannelsMaskIn, CHANNELS_MASK_SIZE );
 803735a:	4b05      	ldr	r3, [pc, #20]	; (8037370 <RegionEU868ChanMaskSet+0x38>)
 803735c:	6801      	ldr	r1, [r0, #0]
 803735e:	681b      	ldr	r3, [r3, #0]
 8037360:	4622      	mov	r2, r4
 8037362:	f503 705b 	add.w	r0, r3, #876	; 0x36c
 8037366:	f7ff fb62 	bl	8036a2e <RegionCommonChanMaskCopy>
    return true;
 803736a:	4620      	mov	r0, r4
            break;
 803736c:	e7ea      	b.n	8037344 <RegionEU868ChanMaskSet+0xc>
 803736e:	bf00      	nop
 8037370:	20005728 	.word	0x20005728

08037374 <RegionEU868ComputeRxWindowParameters>:

void RegionEU868ComputeRxWindowParameters( int8_t datarate, uint8_t minRxSymbols, uint32_t rxError, RxConfigParams_t *rxConfigParams )
{
 8037374:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
#if defined( REGION_EU868 )
    uint32_t tSymbolInUs = 0;

    // Get the datarate, perform a boundary check
    rxConfigParams->Datarate = MIN( datarate, EU868_RX_MAX_DATARATE );
 8037376:	2807      	cmp	r0, #7
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsEU868 );
 8037378:	4d15      	ldr	r5, [pc, #84]	; (80373d0 <RegionEU868ComputeRxWindowParameters+0x5c>)
{
 803737a:	461c      	mov	r4, r3
    rxConfigParams->Datarate = MIN( datarate, EU868_RX_MAX_DATARATE );
 803737c:	bfa8      	it	ge
 803737e:	2007      	movge	r0, #7
 8037380:	7058      	strb	r0, [r3, #1]
{
 8037382:	460e      	mov	r6, r1
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsEU868 );
 8037384:	f105 0108 	add.w	r1, r5, #8
{
 8037388:	4617      	mov	r7, r2
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsEU868 );
 803738a:	f7ff fdcf 	bl	8036f2c <RegionCommonGetBandwidth>

    if( rxConfigParams->Datarate == DR_7 )
 803738e:	f994 3001 	ldrsb.w	r3, [r4, #1]
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsEU868 );
 8037392:	70a0      	strb	r0, [r4, #2]
    if( rxConfigParams->Datarate == DR_7 )
 8037394:	2b07      	cmp	r3, #7
 8037396:	d113      	bne.n	80373c0 <RegionEU868ComputeRxWindowParameters+0x4c>
    { // FSK
        tSymbolInUs = RegionCommonComputeSymbolTimeFsk( DataratesEU868[rxConfigParams->Datarate] );
 8037398:	2032      	movs	r0, #50	; 0x32
 803739a:	f7ff fccb 	bl	8036d34 <RegionCommonComputeSymbolTimeFsk>
    else
    { // LoRa
        tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesEU868[rxConfigParams->Datarate], BandwidthsEU868[rxConfigParams->Datarate] );
    }

    RegionCommonComputeRxWindowParameters( tSymbolInUs, minRxSymbols, rxError, Radio.GetWakeupTime( ), &rxConfigParams->WindowTimeout, &rxConfigParams->WindowOffset );
 803739e:	4b0d      	ldr	r3, [pc, #52]	; (80373d4 <RegionEU868ComputeRxWindowParameters+0x60>)
 80373a0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
        tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesEU868[rxConfigParams->Datarate], BandwidthsEU868[rxConfigParams->Datarate] );
 80373a2:	4605      	mov	r5, r0
    RegionCommonComputeRxWindowParameters( tSymbolInUs, minRxSymbols, rxError, Radio.GetWakeupTime( ), &rxConfigParams->WindowTimeout, &rxConfigParams->WindowOffset );
 80373a4:	4798      	blx	r3
 80373a6:	f104 020c 	add.w	r2, r4, #12
 80373aa:	3408      	adds	r4, #8
 80373ac:	4603      	mov	r3, r0
 80373ae:	9201      	str	r2, [sp, #4]
 80373b0:	9400      	str	r4, [sp, #0]
 80373b2:	463a      	mov	r2, r7
 80373b4:	4631      	mov	r1, r6
 80373b6:	4628      	mov	r0, r5
 80373b8:	f7ff fcc1 	bl	8036d3e <RegionCommonComputeRxWindowParameters>
#endif /* REGION_EU868 */
}
 80373bc:	b003      	add	sp, #12
 80373be:	bdf0      	pop	{r4, r5, r6, r7, pc}
        tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesEU868[rxConfigParams->Datarate], BandwidthsEU868[rxConfigParams->Datarate] );
 80373c0:	eb05 0283 	add.w	r2, r5, r3, lsl #2
 80373c4:	5ce8      	ldrb	r0, [r5, r3]
 80373c6:	6891      	ldr	r1, [r2, #8]
 80373c8:	f7ff fcac 	bl	8036d24 <RegionCommonComputeSymbolTimeLoRa>
 80373cc:	e7e7      	b.n	803739e <RegionEU868ComputeRxWindowParameters+0x2a>
 80373ce:	bf00      	nop
 80373d0:	0803ba84 	.word	0x0803ba84
 80373d4:	0803bbc0 	.word	0x0803bbc0

080373d8 <RegionEU868RxConfig>:

bool RegionEU868RxConfig( RxConfigParams_t* rxConfig, int8_t* datarate )
{
 80373d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int8_t dr = rxConfig->Datarate;
    uint8_t maxPayload = 0;
    int8_t phyDr = 0;
    uint32_t frequency = rxConfig->Frequency;

    if( Radio.GetStatus( ) != RF_IDLE )
 80373dc:	4e39      	ldr	r6, [pc, #228]	; (80374c4 <RegionEU868RxConfig+0xec>)
    int8_t dr = rxConfig->Datarate;
 80373de:	f990 7001 	ldrsb.w	r7, [r0, #1]
    if( Radio.GetStatus( ) != RF_IDLE )
 80373e2:	6873      	ldr	r3, [r6, #4]
    uint32_t frequency = rxConfig->Frequency;
 80373e4:	f8d0 9004 	ldr.w	r9, [r0, #4]
{
 80373e8:	b08d      	sub	sp, #52	; 0x34
 80373ea:	4604      	mov	r4, r0
 80373ec:	468a      	mov	sl, r1
    if( Radio.GetStatus( ) != RF_IDLE )
 80373ee:	4798      	blx	r3
 80373f0:	46b0      	mov	r8, r6
 80373f2:	4605      	mov	r5, r0
 80373f4:	2800      	cmp	r0, #0
 80373f6:	d163      	bne.n	80374c0 <RegionEU868RxConfig+0xe8>
    {
        return false;
    }

    if( rxConfig->RxSlot == RX_SLOT_WIN_1 )
 80373f8:	7ce3      	ldrb	r3, [r4, #19]
 80373fa:	b963      	cbnz	r3, 8037416 <RegionEU868RxConfig+0x3e>
    {
        // Apply window 1 frequency
        frequency = RegionNvmGroup2->Channels[rxConfig->Channel].Frequency;
 80373fc:	4a32      	ldr	r2, [pc, #200]	; (80374c8 <RegionEU868RxConfig+0xf0>)
 80373fe:	7823      	ldrb	r3, [r4, #0]
 8037400:	6812      	ldr	r2, [r2, #0]
 8037402:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8037406:	eb02 0183 	add.w	r1, r2, r3, lsl #2
 803740a:	f852 9023 	ldr.w	r9, [r2, r3, lsl #2]
        // Apply the alternative RX 1 window frequency, if it is available
        if( RegionNvmGroup2->Channels[rxConfig->Channel].Rx1Frequency != 0 )
 803740e:	684b      	ldr	r3, [r1, #4]
 8037410:	2b00      	cmp	r3, #0
 8037412:	bf18      	it	ne
 8037414:	4699      	movne	r9, r3
            frequency = RegionNvmGroup2->Channels[rxConfig->Channel].Rx1Frequency;
        }
    }

    // Read the physical datarate from the datarates table
    phyDr = DataratesEU868[dr];
 8037416:	4e2d      	ldr	r6, [pc, #180]	; (80374cc <RegionEU868RxConfig+0xf4>)

    Radio.SetChannel( frequency );
 8037418:	f8d8 300c 	ldr.w	r3, [r8, #12]
    phyDr = DataratesEU868[dr];
 803741c:	f916 b007 	ldrsb.w	fp, [r6, r7]
    Radio.SetChannel( frequency );
 8037420:	4648      	mov	r0, r9
 8037422:	4798      	blx	r3

    // Radio configuration
    if( dr == DR_7 )
 8037424:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8037428:	68a0      	ldr	r0, [r4, #8]
 803742a:	960b      	str	r6, [sp, #44]	; 0x2c
 803742c:	469c      	mov	ip, r3
 803742e:	2f07      	cmp	r7, #7
 8037430:	7ca3      	ldrb	r3, [r4, #18]
    {
        modem = MODEM_FSK;
        Radio.SetRxConfig( modem, 50000, phyDr * 1000, 0, 83333, 5, rxConfig->WindowTimeout, false, 0, true, 0, 0, false, rxConfig->RxContinuous );
 8037432:	9309      	str	r3, [sp, #36]	; 0x24
    if( dr == DR_7 )
 8037434:	d12d      	bne.n	8037492 <RegionEU868RxConfig+0xba>
        Radio.SetRxConfig( modem, 50000, phyDr * 1000, 0, 83333, 5, rxConfig->WindowTimeout, false, 0, true, 0, 0, false, rxConfig->RxContinuous );
 8037436:	2300      	movs	r3, #0
 8037438:	2101      	movs	r1, #1
 803743a:	e9cd 3104 	strd	r3, r1, [sp, #16]
 803743e:	4924      	ldr	r1, [pc, #144]	; (80374d0 <RegionEU868RxConfig+0xf8>)
 8037440:	9306      	str	r3, [sp, #24]
 8037442:	2205      	movs	r2, #5
 8037444:	e9cd 3307 	strd	r3, r3, [sp, #28]
 8037448:	e9cd 1200 	strd	r1, r2, [sp]
 803744c:	b280      	uxth	r0, r0
 803744e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8037452:	9002      	str	r0, [sp, #8]
 8037454:	9303      	str	r3, [sp, #12]
 8037456:	fb02 f20b 	mul.w	r2, r2, fp
 803745a:	f24c 3150 	movw	r1, #50000	; 0xc350
 803745e:	4618      	mov	r0, r3
    }
    else
    {
        modem = MODEM_LORA;
        Radio.SetRxConfig( modem, rxConfig->Bandwidth, phyDr, 1, 0, 8, rxConfig->WindowTimeout, false, 0, false, 0, 0, true, rxConfig->RxContinuous );
 8037460:	4666      	mov	r6, ip
 8037462:	47b0      	blx	r6
    }

    /* ST_WORKAROUND_BEGIN: Keep repeater feature */
    if( rxConfig->RepeaterSupport == true )
 8037464:	7c63      	ldrb	r3, [r4, #17]
 8037466:	b333      	cbz	r3, 80374b6 <RegionEU868RxConfig+0xde>
    {
        maxPayload = MaxPayloadOfDatarateRepeaterEU868[dr];
 8037468:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 803746a:	443b      	add	r3, r7
 803746c:	f893 1030 	ldrb.w	r1, [r3, #48]	; 0x30
    else
    {
        maxPayload = MaxPayloadOfDatarateEU868[dr];
    }

    Radio.SetMaxPayloadLength( modem, maxPayload + LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE );
 8037470:	f8d8 3054 	ldr.w	r3, [r8, #84]	; 0x54
 8037474:	310d      	adds	r1, #13
 8037476:	b2c9      	uxtb	r1, r1
 8037478:	4628      	mov	r0, r5
 803747a:	4798      	blx	r3
    /* ST_WORKAROUND_END */

    /* ST_WORKAROUND_BEGIN: Print Rx config */
    RegionCommonRxConfigPrint(rxConfig->RxSlot, frequency, dr);
 803747c:	7ce0      	ldrb	r0, [r4, #19]
 803747e:	463a      	mov	r2, r7
 8037480:	4649      	mov	r1, r9
 8037482:	f7ff fd65 	bl	8036f50 <RegionCommonRxConfigPrint>
    /* ST_WORKAROUND_END */

    *datarate = (uint8_t) dr;
 8037486:	f88a 7000 	strb.w	r7, [sl]
    return true;
 803748a:	2001      	movs	r0, #1
#else
    return false;
#endif /* REGION_EU868 */
}
 803748c:	b00d      	add	sp, #52	; 0x34
 803748e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        Radio.SetRxConfig( modem, rxConfig->Bandwidth, phyDr, 1, 0, 8, rxConfig->WindowTimeout, false, 0, false, 0, 0, true, rxConfig->RxContinuous );
 8037492:	2100      	movs	r1, #0
 8037494:	2501      	movs	r5, #1
 8037496:	b280      	uxth	r0, r0
 8037498:	2308      	movs	r3, #8
 803749a:	e9cd 1300 	strd	r1, r3, [sp]
 803749e:	e9cd 1507 	strd	r1, r5, [sp, #28]
 80374a2:	e9cd 1105 	strd	r1, r1, [sp, #20]
 80374a6:	e9cd 1103 	strd	r1, r1, [sp, #12]
 80374aa:	9002      	str	r0, [sp, #8]
 80374ac:	78a1      	ldrb	r1, [r4, #2]
 80374ae:	462b      	mov	r3, r5
 80374b0:	465a      	mov	r2, fp
 80374b2:	4628      	mov	r0, r5
 80374b4:	e7d4      	b.n	8037460 <RegionEU868RxConfig+0x88>
        maxPayload = MaxPayloadOfDatarateEU868[dr];
 80374b6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80374b8:	443b      	add	r3, r7
 80374ba:	f893 1028 	ldrb.w	r1, [r3, #40]	; 0x28
 80374be:	e7d7      	b.n	8037470 <RegionEU868RxConfig+0x98>
        return false;
 80374c0:	2000      	movs	r0, #0
 80374c2:	e7e3      	b.n	803748c <RegionEU868RxConfig+0xb4>
 80374c4:	0803bbc0 	.word	0x0803bbc0
 80374c8:	20005728 	.word	0x20005728
 80374cc:	0803ba84 	.word	0x0803ba84
 80374d0:	00014585 	.word	0x00014585

080374d4 <RegionEU868TxConfig>:

bool RegionEU868TxConfig( TxConfigParams_t* txConfig, int8_t* txPower, TimerTime_t* txTimeOnAir )
{
 80374d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if defined( REGION_EU868 )
    RadioModems_t modem;
    int8_t phyDr = DataratesEU868[txConfig->Datarate];
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
 80374d8:	4f3d      	ldr	r7, [pc, #244]	; (80375d0 <RegionEU868TxConfig+0xfc>)
    int8_t phyDr = DataratesEU868[txConfig->Datarate];
 80374da:	f990 3001 	ldrsb.w	r3, [r0, #1]
 80374de:	4e3d      	ldr	r6, [pc, #244]	; (80375d4 <RegionEU868TxConfig+0x100>)
{
 80374e0:	b08f      	sub	sp, #60	; 0x3c
 80374e2:	e9cd 120b 	strd	r1, r2, [sp, #44]	; 0x2c
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
 80374e6:	e9d7 1200 	ldrd	r1, r2, [r7]
{
 80374ea:	4604      	mov	r4, r0
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
 80374ec:	7800      	ldrb	r0, [r0, #0]
    int8_t phyDr = DataratesEU868[txConfig->Datarate];
 80374ee:	56f3      	ldrsb	r3, [r6, r3]
 80374f0:	930d      	str	r3, [sp, #52]	; 0x34
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
 80374f2:	250c      	movs	r5, #12
 80374f4:	fb05 1100 	mla	r1, r5, r0, r1
 80374f8:	2018      	movs	r0, #24
 80374fa:	7a49      	ldrb	r1, [r1, #9]
 80374fc:	fb00 2201 	mla	r2, r0, r1, r2
 8037500:	f994 0002 	ldrsb.w	r0, [r4, #2]
 8037504:	f992 1002 	ldrsb.w	r1, [r2, #2]
 8037508:	f7ff fd0c 	bl	8036f24 <RegionCommonLimitTxPower>
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsEU868 );
 803750c:	f106 0108 	add.w	r1, r6, #8
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
 8037510:	4681      	mov	r9, r0
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsEU868 );
 8037512:	f994 0001 	ldrsb.w	r0, [r4, #1]
 8037516:	f7ff fd09 	bl	8036f2c <RegionCommonGetBandwidth>
    int8_t phyTxPower = 0;

    // Calculate physical TX power
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, txConfig->MaxEirp, txConfig->AntennaGain );
 803751a:	68a2      	ldr	r2, [r4, #8]
 803751c:	6861      	ldr	r1, [r4, #4]
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsEU868 );
 803751e:	4683      	mov	fp, r0
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, txConfig->MaxEirp, txConfig->AntennaGain );
 8037520:	4648      	mov	r0, r9
 8037522:	f7ff fc34 	bl	8036d8e <RegionCommonComputeTxPower>
 8037526:	4682      	mov	sl, r0

    // Setup the radio frequency
    Radio.SetChannel( RegionNvmGroup2->Channels[txConfig->Channel].Frequency );
 8037528:	7820      	ldrb	r0, [r4, #0]
 803752a:	6839      	ldr	r1, [r7, #0]
 803752c:	4368      	muls	r0, r5
 803752e:	4d2a      	ldr	r5, [pc, #168]	; (80375d8 <RegionEU868TxConfig+0x104>)
 8037530:	5808      	ldr	r0, [r1, r0]
 8037532:	68ea      	ldr	r2, [r5, #12]
 8037534:	4790      	blx	r2

    if( txConfig->Datarate == DR_7 )
 8037536:	f994 2001 	ldrsb.w	r2, [r4, #1]
 803753a:	69eb      	ldr	r3, [r5, #28]
 803753c:	2a07      	cmp	r2, #7
 803753e:	46a8      	mov	r8, r5
 8037540:	f44f 627a 	mov.w	r2, #4000	; 0xfa0
 8037544:	f04f 0500 	mov.w	r5, #0
 8037548:	469c      	mov	ip, r3
    { // High Speed FSK channel
        modem = MODEM_FSK;
        Radio.SetTxConfig( modem, phyTxPower, 25000, bandwidth, phyDr * 1000, 0, 5, false, true, 0, 0, false, 4000 );
 803754a:	e9cd 5207 	strd	r5, r2, [sp, #28]
 803754e:	e9cd 5505 	strd	r5, r5, [sp, #20]
    if( txConfig->Datarate == DR_7 )
 8037552:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8037554:	d12c      	bne.n	80375b0 <RegionEU868TxConfig+0xdc>
        Radio.SetTxConfig( modem, phyTxPower, 25000, bandwidth, phyDr * 1000, 0, 5, false, true, 0, 0, false, 4000 );
 8037556:	2201      	movs	r2, #1
 8037558:	e9cd 5203 	strd	r5, r2, [sp, #12]
 803755c:	2205      	movs	r2, #5
 803755e:	e9cd 5201 	strd	r5, r2, [sp, #4]
 8037562:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8037566:	4353      	muls	r3, r2
 8037568:	9300      	str	r3, [sp, #0]
 803756a:	f246 12a8 	movw	r2, #25000	; 0x61a8
 803756e:	465b      	mov	r3, fp
 8037570:	4651      	mov	r1, sl
 8037572:	4628      	mov	r0, r5
 8037574:	4666      	mov	r6, ip
 8037576:	47b0      	blx	r6
    {
        modem = MODEM_LORA;
        Radio.SetTxConfig( modem, phyTxPower, 0, bandwidth, phyDr, 1, 8, false, true, 0, 0, false, 4000 );
    }
    /* ST_WORKAROUND_BEGIN: Print Tx config */
    RegionCommonTxConfigPrint(RegionNvmGroup2->Channels[txConfig->Channel].Frequency, txConfig->Datarate);
 8037578:	7821      	ldrb	r1, [r4, #0]
 803757a:	683a      	ldr	r2, [r7, #0]
 803757c:	230c      	movs	r3, #12
 803757e:	434b      	muls	r3, r1
 8037580:	f994 1001 	ldrsb.w	r1, [r4, #1]
 8037584:	58d0      	ldr	r0, [r2, r3]
 8037586:	f7ff fd11 	bl	8036fac <RegionCommonTxConfigPrint>
    /* ST_WORKAROUND_END */

    // Update time-on-air
    *txTimeOnAir = GetTimeOnAir( txConfig->Datarate, txConfig->PktLen );
 803758a:	89a1      	ldrh	r1, [r4, #12]
 803758c:	f994 0001 	ldrsb.w	r0, [r4, #1]
 8037590:	f7ff fd1a 	bl	8036fc8 <GetTimeOnAir>
 8037594:	9b0c      	ldr	r3, [sp, #48]	; 0x30

    // Setup maximum payload length of the radio driver
    Radio.SetMaxPayloadLength( modem, txConfig->PktLen );
 8037596:	7b21      	ldrb	r1, [r4, #12]
    *txTimeOnAir = GetTimeOnAir( txConfig->Datarate, txConfig->PktLen );
 8037598:	6018      	str	r0, [r3, #0]
    Radio.SetMaxPayloadLength( modem, txConfig->PktLen );
 803759a:	f8d8 3054 	ldr.w	r3, [r8, #84]	; 0x54
 803759e:	4628      	mov	r0, r5
 80375a0:	4798      	blx	r3

    *txPower = txPowerLimited;
 80375a2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    return true;
#else
    return false;
#endif /* REGION_EU868 */
}
 80375a4:	2001      	movs	r0, #1
    *txPower = txPowerLimited;
 80375a6:	f883 9000 	strb.w	r9, [r3]
}
 80375aa:	b00f      	add	sp, #60	; 0x3c
 80375ac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        Radio.SetTxConfig( modem, phyTxPower, 0, bandwidth, phyDr, 1, 8, false, true, 0, 0, false, 4000 );
 80375b0:	2601      	movs	r6, #1
 80375b2:	2208      	movs	r2, #8
 80375b4:	e9cd 5603 	strd	r5, r6, [sp, #12]
 80375b8:	e9cd 6201 	strd	r6, r2, [sp, #4]
 80375bc:	9300      	str	r3, [sp, #0]
 80375be:	462a      	mov	r2, r5
 80375c0:	465b      	mov	r3, fp
 80375c2:	4665      	mov	r5, ip
 80375c4:	4651      	mov	r1, sl
 80375c6:	4630      	mov	r0, r6
 80375c8:	47a8      	blx	r5
        modem = MODEM_LORA;
 80375ca:	4635      	mov	r5, r6
 80375cc:	e7d4      	b.n	8037578 <RegionEU868TxConfig+0xa4>
 80375ce:	bf00      	nop
 80375d0:	20005728 	.word	0x20005728
 80375d4:	0803ba84 	.word	0x0803ba84
 80375d8:	0803bbc0 	.word	0x0803bbc0

080375dc <RegionEU868LinkAdrReq>:

uint8_t RegionEU868LinkAdrReq( LinkAdrReqParams_t* linkAdrReq, int8_t* drOut, int8_t* txPowOut, uint8_t* nbRepOut, uint8_t* nbBytesParsed )
{
 80375dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80375e0:	b08d      	sub	sp, #52	; 0x34
    uint8_t status = 0x07;
#if defined( REGION_EU868 )
    RegionCommonLinkAdrParams_t linkAdrParams = { 0 };
 80375e2:	2400      	movs	r4, #0
{
 80375e4:	4605      	mov	r5, r0
 80375e6:	468a      	mov	sl, r1
 80375e8:	4691      	mov	r9, r2
 80375ea:	4698      	mov	r8, r3
    RegionCommonLinkAdrParams_t linkAdrParams = { 0 };
 80375ec:	9402      	str	r4, [sp, #8]
 80375ee:	f8ad 400c 	strh.w	r4, [sp, #12]
    uint8_t nextIndex = 0;
    uint8_t bytesProcessed = 0;
    uint16_t chMask = 0;
 80375f2:	f8ad 4006 	strh.w	r4, [sp, #6]
    uint8_t status = 0x07;
 80375f6:	2607      	movs	r6, #7
            {
                if( linkAdrParams.ChMaskCtrl == 6 )
                {
                    if( RegionNvmGroup2->Channels[i].Frequency != 0 )
                    {
                        chMask |= 1 << i;
 80375f8:	f04f 0b01 	mov.w	fp, #1
    while( bytesProcessed < linkAdrReq->PayloadSize )
 80375fc:	7a2b      	ldrb	r3, [r5, #8]
 80375fe:	42a3      	cmp	r3, r4
 8037600:	d906      	bls.n	8037610 <RegionEU868LinkAdrReq+0x34>
        nextIndex = RegionCommonParseLinkAdrReq( &( linkAdrReq->Payload[bytesProcessed] ), &linkAdrParams );
 8037602:	6868      	ldr	r0, [r5, #4]
 8037604:	a902      	add	r1, sp, #8
 8037606:	4420      	add	r0, r4
 8037608:	f7ff fb32 	bl	8036c70 <RegionCommonParseLinkAdrReq>
        if( nextIndex == 0 )
 803760c:	2800      	cmp	r0, #0
 803760e:	d154      	bne.n	80376ba <RegionEU868LinkAdrReq+0xde>
    getPhy.Attribute = PHY_MIN_TX_DR;
    getPhy.UplinkDwellTime = linkAdrReq->UplinkDwellTime;
    phyParam = RegionEU868GetPhyParam( &getPhy );

    linkAdrVerifyParams.Status = status;
    linkAdrVerifyParams.AdrEnabled = linkAdrReq->AdrEnabled;
 8037610:	7aab      	ldrb	r3, [r5, #10]
 8037612:	f88d 3015 	strb.w	r3, [sp, #21]
    linkAdrVerifyParams.Datarate = linkAdrParams.Datarate;
 8037616:	f89d 3009 	ldrb.w	r3, [sp, #9]
 803761a:	f88d 3016 	strb.w	r3, [sp, #22]
    linkAdrVerifyParams.TxPower = linkAdrParams.TxPower;
 803761e:	f89d 300a 	ldrb.w	r3, [sp, #10]
 8037622:	f88d 3017 	strb.w	r3, [sp, #23]
    linkAdrVerifyParams.NbRep = linkAdrParams.NbRep;
 8037626:	f89d 3008 	ldrb.w	r3, [sp, #8]
 803762a:	f88d 3018 	strb.w	r3, [sp, #24]
    linkAdrVerifyParams.CurrentDatarate = linkAdrReq->CurrentDatarate;
 803762e:	7aeb      	ldrb	r3, [r5, #11]
 8037630:	f88d 3019 	strb.w	r3, [sp, #25]
    linkAdrVerifyParams.CurrentTxPower = linkAdrReq->CurrentTxPower;
 8037634:	7b2b      	ldrb	r3, [r5, #12]
 8037636:	f88d 301a 	strb.w	r3, [sp, #26]
    linkAdrVerifyParams.CurrentNbRep = linkAdrReq->CurrentNbRep;
 803763a:	7b6b      	ldrb	r3, [r5, #13]
 803763c:	f88d 301b 	strb.w	r3, [sp, #27]
    linkAdrVerifyParams.NbChannels = EU868_MAX_NB_CHANNELS;
 8037640:	2310      	movs	r3, #16
    linkAdrVerifyParams.Status = status;
 8037642:	f88d 6014 	strb.w	r6, [sp, #20]
    linkAdrVerifyParams.NbChannels = EU868_MAX_NB_CHANNELS;
 8037646:	f88d 301c 	strb.w	r3, [sp, #28]
    linkAdrVerifyParams.ChannelsMask = &chMask;
    linkAdrVerifyParams.MinDatarate = ( int8_t )phyParam.Value;
    linkAdrVerifyParams.MaxDatarate = EU868_TX_MAX_DATARATE;
    linkAdrVerifyParams.Channels = RegionNvmGroup2->Channels;
 803764a:	4e3a      	ldr	r6, [pc, #232]	; (8037734 <RegionEU868LinkAdrReq+0x158>)
    linkAdrVerifyParams.ChannelsMask = &chMask;
 803764c:	f10d 0306 	add.w	r3, sp, #6
 8037650:	9308      	str	r3, [sp, #32]
    linkAdrVerifyParams.MinDatarate = ( int8_t )phyParam.Value;
 8037652:	f44f 63e0 	mov.w	r3, #1792	; 0x700
 8037656:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
    linkAdrVerifyParams.Channels = RegionNvmGroup2->Channels;
 803765a:	6833      	ldr	r3, [r6, #0]
 803765c:	930a      	str	r3, [sp, #40]	; 0x28
    linkAdrVerifyParams.MinTxPower = EU868_MIN_TX_POWER;
 803765e:	2307      	movs	r3, #7
 8037660:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
    linkAdrVerifyParams.MaxTxPower = EU868_MAX_TX_POWER;
    linkAdrVerifyParams.Version = linkAdrReq->Version;
 8037664:	682b      	ldr	r3, [r5, #0]
 8037666:	9304      	str	r3, [sp, #16]

    // Verify the parameters and update, if necessary
    status = RegionCommonLinkAdrReqVerifyParams( &linkAdrVerifyParams, &linkAdrParams.Datarate, &linkAdrParams.TxPower, &linkAdrParams.NbRep );
 8037668:	f10d 020a 	add.w	r2, sp, #10
 803766c:	ab02      	add	r3, sp, #8
 803766e:	f10d 0109 	add.w	r1, sp, #9
 8037672:	a804      	add	r0, sp, #16
 8037674:	f7ff fb16 	bl	8036ca4 <RegionCommonLinkAdrReqVerifyParams>

    // Update channelsMask if everything is correct
    if( status == 0x07 )
 8037678:	2807      	cmp	r0, #7
    status = RegionCommonLinkAdrReqVerifyParams( &linkAdrVerifyParams, &linkAdrParams.Datarate, &linkAdrParams.TxPower, &linkAdrParams.NbRep );
 803767a:	4605      	mov	r5, r0
    if( status == 0x07 )
 803767c:	d10b      	bne.n	8037696 <RegionEU868LinkAdrReq+0xba>
    {
        // Set the channels mask to a default value
        memset1( ( uint8_t* ) RegionNvmGroup2->ChannelsMask, 0, sizeof( RegionNvmGroup2->ChannelsMask ) );
 803767e:	6830      	ldr	r0, [r6, #0]
 8037680:	220c      	movs	r2, #12
 8037682:	2100      	movs	r1, #0
 8037684:	f500 7058 	add.w	r0, r0, #864	; 0x360
 8037688:	f001 fc2e 	bl	8038ee8 <memset1>
        // Update the channels mask
        RegionNvmGroup2->ChannelsMask[0] = chMask;
 803768c:	6833      	ldr	r3, [r6, #0]
 803768e:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 8037692:	f8a3 2360 	strh.w	r2, [r3, #864]	; 0x360
    }

    // Update status variables
    *drOut = linkAdrParams.Datarate;
 8037696:	f89d 3009 	ldrb.w	r3, [sp, #9]
 803769a:	f88a 3000 	strb.w	r3, [sl]
    *txPowOut = linkAdrParams.TxPower;
 803769e:	f89d 300a 	ldrb.w	r3, [sp, #10]
 80376a2:	f889 3000 	strb.w	r3, [r9]
    *nbRepOut = linkAdrParams.NbRep;
 80376a6:	f89d 3008 	ldrb.w	r3, [sp, #8]
 80376aa:	f888 3000 	strb.w	r3, [r8]
    *nbBytesParsed = bytesProcessed;
 80376ae:	9b16      	ldr	r3, [sp, #88]	; 0x58

#endif /* REGION_EU868 */
    return status;
}
 80376b0:	4628      	mov	r0, r5
    *nbBytesParsed = bytesProcessed;
 80376b2:	701c      	strb	r4, [r3, #0]
}
 80376b4:	b00d      	add	sp, #52	; 0x34
 80376b6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if( ( linkAdrParams.ChMaskCtrl == 0 ) && ( chMask == 0 ) )
 80376ba:	f89d 300b 	ldrb.w	r3, [sp, #11]
        chMask = linkAdrParams.ChMask;
 80376be:	f8bd 700c 	ldrh.w	r7, [sp, #12]
 80376c2:	f8ad 7006 	strh.w	r7, [sp, #6]
        bytesProcessed += nextIndex;
 80376c6:	4404      	add	r4, r0
 80376c8:	b2e4      	uxtb	r4, r4
        if( ( linkAdrParams.ChMaskCtrl == 0 ) && ( chMask == 0 ) )
 80376ca:	b9f3      	cbnz	r3, 803770a <RegionEU868LinkAdrReq+0x12e>
 80376cc:	b317      	cbz	r7, 8037714 <RegionEU868LinkAdrReq+0x138>
                        ( RegionNvmGroup2->Channels[i].Frequency == 0 ) )
 80376ce:	4a19      	ldr	r2, [pc, #100]	; (8037734 <RegionEU868LinkAdrReq+0x158>)
 80376d0:	2000      	movs	r0, #0
 80376d2:	6811      	ldr	r1, [r2, #0]
 80376d4:	2607      	movs	r6, #7
 80376d6:	4602      	mov	r2, r0
 80376d8:	f04f 0c0c 	mov.w	ip, #12
                if( linkAdrParams.ChMaskCtrl == 6 )
 80376dc:	2b06      	cmp	r3, #6
 80376de:	d11b      	bne.n	8037718 <RegionEU868LinkAdrReq+0x13c>
                    if( RegionNvmGroup2->Channels[i].Frequency != 0 )
 80376e0:	fb0c fe00 	mul.w	lr, ip, r0
 80376e4:	f851 e00e 	ldr.w	lr, [r1, lr]
 80376e8:	f1be 0f00 	cmp.w	lr, #0
 80376ec:	d004      	beq.n	80376f8 <RegionEU868LinkAdrReq+0x11c>
                        chMask |= 1 << i;
 80376ee:	fa0b f200 	lsl.w	r2, fp, r0
 80376f2:	4317      	orrs	r7, r2
 80376f4:	b2bf      	uxth	r7, r7
 80376f6:	2201      	movs	r2, #1
            for( uint8_t i = 0; i < EU868_MAX_NB_CHANNELS; i++ )
 80376f8:	3001      	adds	r0, #1
 80376fa:	2810      	cmp	r0, #16
 80376fc:	d1ee      	bne.n	80376dc <RegionEU868LinkAdrReq+0x100>
 80376fe:	2a00      	cmp	r2, #0
 8037700:	f43f af7c 	beq.w	80375fc <RegionEU868LinkAdrReq+0x20>
 8037704:	f8ad 7006 	strh.w	r7, [sp, #6]
 8037708:	e778      	b.n	80375fc <RegionEU868LinkAdrReq+0x20>
        else if( ( ( linkAdrParams.ChMaskCtrl >= 1 ) && ( linkAdrParams.ChMaskCtrl <= 5 )) ||
 803770a:	1e5a      	subs	r2, r3, #1
 803770c:	2a04      	cmp	r2, #4
 803770e:	d901      	bls.n	8037714 <RegionEU868LinkAdrReq+0x138>
 8037710:	2b06      	cmp	r3, #6
 8037712:	d0dc      	beq.n	80376ce <RegionEU868LinkAdrReq+0xf2>
            status &= 0xFE; // Channel mask KO
 8037714:	2606      	movs	r6, #6
 8037716:	e771      	b.n	80375fc <RegionEU868LinkAdrReq+0x20>
                    if( ( ( chMask & ( 1 << i ) ) != 0 ) &&
 8037718:	fa47 fe00 	asr.w	lr, r7, r0
 803771c:	f01e 0f01 	tst.w	lr, #1
 8037720:	d0ea      	beq.n	80376f8 <RegionEU868LinkAdrReq+0x11c>
                        ( RegionNvmGroup2->Channels[i].Frequency == 0 ) )
 8037722:	fb0c fe00 	mul.w	lr, ip, r0
                    if( ( ( chMask & ( 1 << i ) ) != 0 ) &&
 8037726:	f851 e00e 	ldr.w	lr, [r1, lr]
                        status &= 0xFE; // Channel mask KO
 803772a:	f1be 0f00 	cmp.w	lr, #0
 803772e:	bf08      	it	eq
 8037730:	2606      	moveq	r6, #6
 8037732:	e7e1      	b.n	80376f8 <RegionEU868LinkAdrReq+0x11c>
 8037734:	20005728 	.word	0x20005728

08037738 <RegionEU868RxParamSetupReq>:

uint8_t RegionEU868RxParamSetupReq( RxParamSetupReqParams_t* rxParamSetupReq )
{
 8037738:	b573      	push	{r0, r1, r4, r5, r6, lr}
    uint8_t status = 0x07;
#if defined( REGION_EU868 )
    uint8_t band = 0;
 803773a:	2600      	movs	r6, #0
{
 803773c:	4605      	mov	r5, r0

    // Verify radio frequency
    if( VerifyRfFreq( rxParamSetupReq->Frequency, &band ) == false )
 803773e:	f10d 0107 	add.w	r1, sp, #7
 8037742:	6840      	ldr	r0, [r0, #4]
    uint8_t band = 0;
 8037744:	f88d 6007 	strb.w	r6, [sp, #7]
    if( VerifyRfFreq( rxParamSetupReq->Frequency, &band ) == false )
 8037748:	f7ff fc66 	bl	8037018 <VerifyRfFreq>
    {
        status &= 0xFE; // Channel frequency KO
    }

    // Verify datarate
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, EU868_RX_MIN_DATARATE, EU868_RX_MAX_DATARATE ) == false )
 803774c:	2207      	movs	r2, #7
    if( VerifyRfFreq( rxParamSetupReq->Frequency, &band ) == false )
 803774e:	42b0      	cmp	r0, r6
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, EU868_RX_MIN_DATARATE, EU868_RX_MAX_DATARATE ) == false )
 8037750:	4631      	mov	r1, r6
 8037752:	f995 0000 	ldrsb.w	r0, [r5]
        status &= 0xFE; // Channel frequency KO
 8037756:	bf14      	ite	ne
 8037758:	2407      	movne	r4, #7
 803775a:	2406      	moveq	r4, #6
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, EU868_RX_MIN_DATARATE, EU868_RX_MAX_DATARATE ) == false )
 803775c:	f7ff f927 	bl	80369ae <RegionCommonValueInRange>
 8037760:	b908      	cbnz	r0, 8037766 <RegionEU868RxParamSetupReq+0x2e>
    {
        status &= 0xFD; // Datarate KO
 8037762:	f004 0405 	and.w	r4, r4, #5
    }

    // Verify datarate offset
    if( RegionCommonValueInRange( rxParamSetupReq->DrOffset, EU868_MIN_RX1_DR_OFFSET, EU868_MAX_RX1_DR_OFFSET ) == false )
 8037766:	f995 0001 	ldrsb.w	r0, [r5, #1]
 803776a:	2205      	movs	r2, #5
 803776c:	2100      	movs	r1, #0
 803776e:	f7ff f91e 	bl	80369ae <RegionCommonValueInRange>
 8037772:	b908      	cbnz	r0, 8037778 <RegionEU868RxParamSetupReq+0x40>
    {
        status &= 0xFB; // Rx1DrOffset range KO
 8037774:	f004 04fb 	and.w	r4, r4, #251	; 0xfb
    }

#endif /* REGION_EU868 */
    return status;
}
 8037778:	4620      	mov	r0, r4
 803777a:	b002      	add	sp, #8
 803777c:	bd70      	pop	{r4, r5, r6, pc}

0803777e <RegionEU868TxParamSetupReq>:

int8_t RegionEU868TxParamSetupReq( TxParamSetupReqParams_t* txParamSetupReq )
{
    // Do not accept the request
    return -1;
}
 803777e:	f04f 30ff 	mov.w	r0, #4294967295
 8037782:	4770      	bx	lr

08037784 <RegionEU868DlChannelReq>:

int8_t RegionEU868DlChannelReq( DlChannelReqParams_t* dlChannelReq )
{
 8037784:	b513      	push	{r0, r1, r4, lr}
 8037786:	4604      	mov	r4, r0
    uint8_t status = 0x03;
#if defined( REGION_EU868 )
    uint8_t band = 0;
 8037788:	2300      	movs	r3, #0

    // Verify if the frequency is supported
    if( VerifyRfFreq( dlChannelReq->Rx1Frequency, &band ) == false )
 803778a:	f10d 0107 	add.w	r1, sp, #7
 803778e:	6840      	ldr	r0, [r0, #4]
    uint8_t band = 0;
 8037790:	f88d 3007 	strb.w	r3, [sp, #7]
    if( VerifyRfFreq( dlChannelReq->Rx1Frequency, &band ) == false )
 8037794:	f7ff fc40 	bl	8037018 <VerifyRfFreq>
 8037798:	7823      	ldrb	r3, [r4, #0]
 803779a:	4a0b      	ldr	r2, [pc, #44]	; (80377c8 <RegionEU868DlChannelReq+0x44>)
 803779c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80377a0:	6812      	ldr	r2, [r2, #0]
 80377a2:	eb02 0183 	add.w	r1, r2, r3, lsl #2
    {
        status &= 0xFE;
    }

    // Verify if an uplink frequency exists
    if( RegionNvmGroup2->Channels[dlChannelReq->ChannelId].Frequency == 0 )
 80377a6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    if( VerifyRfFreq( dlChannelReq->Rx1Frequency, &band ) == false )
 80377aa:	2800      	cmp	r0, #0
        status &= 0xFE;
 80377ac:	bf14      	ite	ne
 80377ae:	2003      	movne	r0, #3
 80377b0:	2002      	moveq	r0, #2
    if( RegionNvmGroup2->Channels[dlChannelReq->ChannelId].Frequency == 0 )
 80377b2:	b91b      	cbnz	r3, 80377bc <RegionEU868DlChannelReq+0x38>
    {
        status &= 0xFD;
 80377b4:	f000 0001 	and.w	r0, r0, #1
        RegionNvmGroup2->Channels[dlChannelReq->ChannelId].Rx1Frequency = dlChannelReq->Rx1Frequency;
    }

#endif /* REGION_EU868 */
    return status;
}
 80377b8:	b002      	add	sp, #8
 80377ba:	bd10      	pop	{r4, pc}
    if( status == 0x03 )
 80377bc:	2803      	cmp	r0, #3
        RegionNvmGroup2->Channels[dlChannelReq->ChannelId].Rx1Frequency = dlChannelReq->Rx1Frequency;
 80377be:	bf06      	itte	eq
 80377c0:	6863      	ldreq	r3, [r4, #4]
 80377c2:	604b      	streq	r3, [r1, #4]
 80377c4:	2002      	movne	r0, #2
 80377c6:	e7f7      	b.n	80377b8 <RegionEU868DlChannelReq+0x34>
 80377c8:	20005728 	.word	0x20005728

080377cc <RegionEU868AlternateDr>:
#if defined( REGION_EU868 )
    return currentDr;
#else
    return -1;
#endif /* REGION_EU868 */
}
 80377cc:	4770      	bx	lr
	...

080377d0 <RegionEU868NextChannel>:

LoRaMacStatus_t RegionEU868NextChannel( NextChanParams_t* nextChanParams, uint8_t* channel, TimerTime_t* time, TimerTime_t* aggregatedTimeOff )
{
 80377d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    RegionCommonIdentifyChannelsParam_t identifyChannelsParam;
    RegionCommonCountNbOfEnabledChannelsParams_t countChannelsParams;
    LoRaMacStatus_t status = LORAMAC_STATUS_NO_CHANNEL_FOUND;
    uint16_t joinChannels = EU868_JOIN_CHANNELS;

    if( RegionCommonCountChannels( RegionNvmGroup2->ChannelsMask, 0, 1 ) == 0 )
 80377d4:	4d38      	ldr	r5, [pc, #224]	; (80378b8 <RegionEU868NextChannel+0xe8>)
{
 80377d6:	4604      	mov	r4, r0
    if( RegionCommonCountChannels( RegionNvmGroup2->ChannelsMask, 0, 1 ) == 0 )
 80377d8:	6828      	ldr	r0, [r5, #0]
{
 80377da:	b096      	sub	sp, #88	; 0x58
 80377dc:	460e      	mov	r6, r1
 80377de:	4690      	mov	r8, r2
    uint8_t nbEnabledChannels = 0;
 80377e0:	2100      	movs	r1, #0
{
 80377e2:	461f      	mov	r7, r3
    if( RegionCommonCountChannels( RegionNvmGroup2->ChannelsMask, 0, 1 ) == 0 )
 80377e4:	2201      	movs	r2, #1
    uint16_t joinChannels = EU868_JOIN_CHANNELS;
 80377e6:	2307      	movs	r3, #7
    if( RegionCommonCountChannels( RegionNvmGroup2->ChannelsMask, 0, 1 ) == 0 )
 80377e8:	f500 7058 	add.w	r0, r0, #864	; 0x360
    uint8_t enabledChannels[EU868_MAX_NB_CHANNELS] = { 0 };
 80377ec:	e9cd 1104 	strd	r1, r1, [sp, #16]
 80377f0:	e9cd 1106 	strd	r1, r1, [sp, #24]
    uint8_t nbEnabledChannels = 0;
 80377f4:	f88d 100c 	strb.w	r1, [sp, #12]
    uint8_t nbRestrictedChannels = 0;
 80377f8:	f88d 100d 	strb.w	r1, [sp, #13]
    uint16_t joinChannels = EU868_JOIN_CHANNELS;
 80377fc:	f8ad 300e 	strh.w	r3, [sp, #14]
    if( RegionCommonCountChannels( RegionNvmGroup2->ChannelsMask, 0, 1 ) == 0 )
 8037800:	f7ff f8f7 	bl	80369f2 <RegionCommonCountChannels>
 8037804:	b930      	cbnz	r0, 8037814 <RegionEU868NextChannel+0x44>
    { // Reactivate default channels
        RegionNvmGroup2->ChannelsMask[0] |= LC( 1 ) + LC( 2 ) + LC( 3 );
 8037806:	682a      	ldr	r2, [r5, #0]
 8037808:	f8b2 3360 	ldrh.w	r3, [r2, #864]	; 0x360
 803780c:	f043 0307 	orr.w	r3, r3, #7
 8037810:	f8a2 3360 	strh.w	r3, [r2, #864]	; 0x360
    }

    // Search how many channels are enabled
    countChannelsParams.Joined = nextChanParams->Joined;
    countChannelsParams.Datarate = nextChanParams->Datarate;
    countChannelsParams.ChannelsMask = RegionNvmGroup2->ChannelsMask;
 8037814:	682a      	ldr	r2, [r5, #0]
    countChannelsParams.Joined = nextChanParams->Joined;
 8037816:	7a63      	ldrb	r3, [r4, #9]
 8037818:	f88d 3020 	strb.w	r3, [sp, #32]
    countChannelsParams.ChannelsMask = RegionNvmGroup2->ChannelsMask;
 803781c:	f502 7158 	add.w	r1, r2, #864	; 0x360
    countChannelsParams.Channels = RegionNvmGroup2->Channels;
 8037820:	e9cd 1209 	strd	r1, r2, [sp, #36]	; 0x24
    countChannelsParams.Bands = RegionNvmGroup1->Bands;
 8037824:	686a      	ldr	r2, [r5, #4]
 8037826:	920b      	str	r2, [sp, #44]	; 0x2c
    countChannelsParams.MaxNbChannels = EU868_MAX_NB_CHANNELS;
 8037828:	2210      	movs	r2, #16
 803782a:	f8ad 2030 	strh.w	r2, [sp, #48]	; 0x30
    countChannelsParams.JoinChannels = &joinChannels;
 803782e:	f10d 020e 	add.w	r2, sp, #14
 8037832:	920d      	str	r2, [sp, #52]	; 0x34

    identifyChannelsParam.AggrTimeOff = nextChanParams->AggrTimeOff;
 8037834:	6822      	ldr	r2, [r4, #0]
 8037836:	920e      	str	r2, [sp, #56]	; 0x38
    identifyChannelsParam.LastAggrTx = nextChanParams->LastAggrTx;
 8037838:	6862      	ldr	r2, [r4, #4]
 803783a:	920f      	str	r2, [sp, #60]	; 0x3c
    identifyChannelsParam.DutyCycleEnabled = nextChanParams->DutyCycleEnabled;
    identifyChannelsParam.MaxBands = EU868_MAX_NB_BANDS;

    identifyChannelsParam.ElapsedTimeSinceStartUp = nextChanParams->ElapsedTimeSinceStartUp;
 803783c:	e9d4 0103 	ldrd	r0, r1, [r4, #12]
    identifyChannelsParam.DutyCycleEnabled = nextChanParams->DutyCycleEnabled;
 8037840:	7aa2      	ldrb	r2, [r4, #10]
    countChannelsParams.Datarate = nextChanParams->Datarate;
 8037842:	f994 3008 	ldrsb.w	r3, [r4, #8]
    identifyChannelsParam.DutyCycleEnabled = nextChanParams->DutyCycleEnabled;
 8037846:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
    identifyChannelsParam.MaxBands = EU868_MAX_NB_BANDS;
 803784a:	2206      	movs	r2, #6
 803784c:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
    identifyChannelsParam.ElapsedTimeSinceStartUp = nextChanParams->ElapsedTimeSinceStartUp;
 8037850:	aa11      	add	r2, sp, #68	; 0x44
 8037852:	e882 0003 	stmia.w	r2, {r0, r1}
    identifyChannelsParam.LastTxIsJoinRequest = nextChanParams->LastTxIsJoinRequest;
 8037856:	7d22      	ldrb	r2, [r4, #20]
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 8037858:	8ae1      	ldrh	r1, [r4, #22]
    countChannelsParams.Datarate = nextChanParams->Datarate;
 803785a:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 803785e:	4618      	mov	r0, r3
    identifyChannelsParam.LastTxIsJoinRequest = nextChanParams->LastTxIsJoinRequest;
 8037860:	f88d 204c 	strb.w	r2, [sp, #76]	; 0x4c
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 8037864:	f7ff fbb0 	bl	8036fc8 <GetTimeOnAir>

    identifyChannelsParam.CountNbOfEnabledChannelsParam = &countChannelsParams;
 8037868:	ab08      	add	r3, sp, #32
 803786a:	9315      	str	r3, [sp, #84]	; 0x54

    status = RegionCommonIdentifyChannels( &identifyChannelsParam, aggregatedTimeOff, enabledChannels,
 803786c:	f10d 030d 	add.w	r3, sp, #13
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 8037870:	9014      	str	r0, [sp, #80]	; 0x50
    status = RegionCommonIdentifyChannels( &identifyChannelsParam, aggregatedTimeOff, enabledChannels,
 8037872:	9300      	str	r3, [sp, #0]
 8037874:	f8cd 8004 	str.w	r8, [sp, #4]
 8037878:	ab03      	add	r3, sp, #12
 803787a:	aa04      	add	r2, sp, #16
 803787c:	4639      	mov	r1, r7
 803787e:	a80e      	add	r0, sp, #56	; 0x38
 8037880:	f7ff faf1 	bl	8036e66 <RegionCommonIdentifyChannels>
                                           &nbEnabledChannels, &nbRestrictedChannels, time );

    if( status == LORAMAC_STATUS_OK )
 8037884:	4604      	mov	r4, r0
 8037886:	b968      	cbnz	r0, 80378a4 <RegionEU868NextChannel+0xd4>
    {
        // We found a valid channel
        *channel = enabledChannels[randr( 0, nbEnabledChannels - 1 )];
 8037888:	f89d 100c 	ldrb.w	r1, [sp, #12]
 803788c:	3901      	subs	r1, #1
 803788e:	f001 fafb 	bl	8038e88 <randr>
 8037892:	ab16      	add	r3, sp, #88	; 0x58
 8037894:	4418      	add	r0, r3
 8037896:	f810 3c48 	ldrb.w	r3, [r0, #-72]
 803789a:	7033      	strb	r3, [r6, #0]
    }
    return status;
#else
    return LORAMAC_STATUS_NO_CHANNEL_FOUND;
#endif /* REGION_EU868 */
}
 803789c:	4620      	mov	r0, r4
 803789e:	b016      	add	sp, #88	; 0x58
 80378a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    else if( status == LORAMAC_STATUS_NO_CHANNEL_FOUND )
 80378a4:	280c      	cmp	r0, #12
        RegionNvmGroup2->ChannelsMask[0] |= LC( 1 ) + LC( 2 ) + LC( 3 );
 80378a6:	bf01      	itttt	eq
 80378a8:	682a      	ldreq	r2, [r5, #0]
 80378aa:	f8b2 3360 	ldrheq.w	r3, [r2, #864]	; 0x360
 80378ae:	f043 0307 	orreq.w	r3, r3, #7
 80378b2:	f8a2 3360 	strheq.w	r3, [r2, #864]	; 0x360
 80378b6:	e7f1      	b.n	803789c <RegionEU868NextChannel+0xcc>
 80378b8:	20005728 	.word	0x20005728

080378bc <RegionEU868ChannelAdd>:

LoRaMacStatus_t RegionEU868ChannelAdd( ChannelAddParams_t* channelAdd )
{
 80378bc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
#if defined( REGION_EU868 )
    uint8_t band = 0;
    bool drInvalid = false;
    bool freqInvalid = false;
    uint8_t id = channelAdd->ChannelId;
 80378be:	7906      	ldrb	r6, [r0, #4]
    uint8_t band = 0;
 80378c0:	2700      	movs	r7, #0

    if( id < EU868_NUMB_DEFAULT_CHANNELS )
 80378c2:	2e02      	cmp	r6, #2
{
 80378c4:	4605      	mov	r5, r0
    uint8_t band = 0;
 80378c6:	f88d 7007 	strb.w	r7, [sp, #7]
    if( id < EU868_NUMB_DEFAULT_CHANNELS )
 80378ca:	d802      	bhi.n	80378d2 <RegionEU868ChannelAdd+0x16>
    {
        return LORAMAC_STATUS_FREQ_AND_DR_INVALID;
 80378cc:	2006      	movs	r0, #6
    RegionNvmGroup2->ChannelsMask[0] |= ( 1 << id );
    return LORAMAC_STATUS_OK;
#else
    return LORAMAC_STATUS_NO_CHANNEL_FOUND;
#endif /* REGION_EU868 */
}
 80378ce:	b003      	add	sp, #12
 80378d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if( id >= EU868_MAX_NB_CHANNELS )
 80378d2:	2e0f      	cmp	r6, #15
 80378d4:	d82d      	bhi.n	8037932 <RegionEU868ChannelAdd+0x76>
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Min, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 80378d6:	6803      	ldr	r3, [r0, #0]
 80378d8:	7a18      	ldrb	r0, [r3, #8]
 80378da:	f340 0003 	sbfx	r0, r0, #0, #4
 80378de:	2207      	movs	r2, #7
 80378e0:	4639      	mov	r1, r7
 80378e2:	b240      	sxtb	r0, r0
 80378e4:	f7ff f863 	bl	80369ae <RegionCommonValueInRange>
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Max, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 80378e8:	682b      	ldr	r3, [r5, #0]
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Min, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 80378ea:	4604      	mov	r4, r0
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Max, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 80378ec:	7a18      	ldrb	r0, [r3, #8]
 80378ee:	f340 1003 	sbfx	r0, r0, #4, #4
 80378f2:	2207      	movs	r2, #7
 80378f4:	4639      	mov	r1, r7
 80378f6:	b240      	sxtb	r0, r0
 80378f8:	f7ff f859 	bl	80369ae <RegionCommonValueInRange>
 80378fc:	b1b8      	cbz	r0, 803792e <RegionEU868ChannelAdd+0x72>
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Min, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 80378fe:	fab4 f484 	clz	r4, r4
 8037902:	0964      	lsrs	r4, r4, #5
    if( channelAdd->NewChannel->DrRange.Fields.Min > channelAdd->NewChannel->DrRange.Fields.Max )
 8037904:	6828      	ldr	r0, [r5, #0]
 8037906:	7a03      	ldrb	r3, [r0, #8]
        if( VerifyRfFreq( channelAdd->NewChannel->Frequency, &band ) == false )
 8037908:	6800      	ldr	r0, [r0, #0]
    if( channelAdd->NewChannel->DrRange.Fields.Min > channelAdd->NewChannel->DrRange.Fields.Max )
 803790a:	f343 0203 	sbfx	r2, r3, #0, #4
 803790e:	f343 1303 	sbfx	r3, r3, #4, #4
 8037912:	b252      	sxtb	r2, r2
 8037914:	b25b      	sxtb	r3, r3
        if( VerifyRfFreq( channelAdd->NewChannel->Frequency, &band ) == false )
 8037916:	f10d 0107 	add.w	r1, sp, #7
        drInvalid = true;
 803791a:	429a      	cmp	r2, r3
 803791c:	bfc8      	it	gt
 803791e:	2401      	movgt	r4, #1
        if( VerifyRfFreq( channelAdd->NewChannel->Frequency, &band ) == false )
 8037920:	f7ff fb7a 	bl	8037018 <VerifyRfFreq>
 8037924:	b948      	cbnz	r0, 803793a <RegionEU868ChannelAdd+0x7e>
    if( ( drInvalid == true ) && ( freqInvalid == true ) )
 8037926:	2c00      	cmp	r4, #0
 8037928:	d1d0      	bne.n	80378cc <RegionEU868ChannelAdd+0x10>
        return LORAMAC_STATUS_FREQUENCY_INVALID;
 803792a:	2004      	movs	r0, #4
 803792c:	e7cf      	b.n	80378ce <RegionEU868ChannelAdd+0x12>
        drInvalid = true;
 803792e:	2401      	movs	r4, #1
 8037930:	e7e8      	b.n	8037904 <RegionEU868ChannelAdd+0x48>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 8037932:	2003      	movs	r0, #3
 8037934:	e7cb      	b.n	80378ce <RegionEU868ChannelAdd+0x12>
        return LORAMAC_STATUS_DATARATE_INVALID;
 8037936:	2005      	movs	r0, #5
 8037938:	e7c9      	b.n	80378ce <RegionEU868ChannelAdd+0x12>
    if( ( drInvalid == true ) && ( freqInvalid == true ) )
 803793a:	2c00      	cmp	r4, #0
 803793c:	d1fb      	bne.n	8037936 <RegionEU868ChannelAdd+0x7a>
    memcpy1( ( uint8_t* ) &(RegionNvmGroup2->Channels[id]), ( uint8_t* ) channelAdd->NewChannel, sizeof( RegionNvmGroup2->Channels[id] ) );
 803793e:	4f0d      	ldr	r7, [pc, #52]	; (8037974 <RegionEU868ChannelAdd+0xb8>)
 8037940:	6829      	ldr	r1, [r5, #0]
 8037942:	683b      	ldr	r3, [r7, #0]
 8037944:	eb06 0046 	add.w	r0, r6, r6, lsl #1
 8037948:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 803794c:	220c      	movs	r2, #12
 803794e:	f001 fab7 	bl	8038ec0 <memcpy1>
    RegionNvmGroup2->Channels[id].Band = band;
 8037952:	683a      	ldr	r2, [r7, #0]
 8037954:	f89d 1007 	ldrb.w	r1, [sp, #7]
 8037958:	230c      	movs	r3, #12
 803795a:	fb03 2306 	mla	r3, r3, r6, r2
    return LORAMAC_STATUS_OK;
 803795e:	4620      	mov	r0, r4
    RegionNvmGroup2->Channels[id].Band = band;
 8037960:	7259      	strb	r1, [r3, #9]
    RegionNvmGroup2->ChannelsMask[0] |= ( 1 << id );
 8037962:	2301      	movs	r3, #1
 8037964:	fa03 f606 	lsl.w	r6, r3, r6
 8037968:	f8b2 3360 	ldrh.w	r3, [r2, #864]	; 0x360
 803796c:	431e      	orrs	r6, r3
 803796e:	f8a2 6360 	strh.w	r6, [r2, #864]	; 0x360
    return LORAMAC_STATUS_OK;
 8037972:	e7ac      	b.n	80378ce <RegionEU868ChannelAdd+0x12>
 8037974:	20005728 	.word	0x20005728

08037978 <RegionEU868ChannelsRemove>:

bool RegionEU868ChannelsRemove( ChannelRemoveParams_t* channelRemove  )
{
 8037978:	b410      	push	{r4}
#if defined( REGION_EU868 )
    uint8_t id = channelRemove->ChannelId;
 803797a:	7801      	ldrb	r1, [r0, #0]

    if( id < EU868_NUMB_DEFAULT_CHANNELS )
 803797c:	2902      	cmp	r1, #2
 803797e:	d90e      	bls.n	803799e <RegionEU868ChannelsRemove+0x26>
    {
        return false;
    }

    // Remove the channel from the list of channels
    RegionNvmGroup2->Channels[id] = ( ChannelParams_t ){ 0, 0, { 0 }, 0 };
 8037980:	4b08      	ldr	r3, [pc, #32]	; (80379a4 <RegionEU868ChannelsRemove+0x2c>)
 8037982:	6818      	ldr	r0, [r3, #0]
 8037984:	230c      	movs	r3, #12
 8037986:	434b      	muls	r3, r1
 8037988:	18c4      	adds	r4, r0, r3
 803798a:	2200      	movs	r2, #0
 803798c:	50c2      	str	r2, [r0, r3]
 803798e:	e9c4 2201 	strd	r2, r2, [r4, #4]

    return RegionCommonChanDisable( RegionNvmGroup2->ChannelsMask, id, EU868_MAX_NB_CHANNELS );
 8037992:	f500 7058 	add.w	r0, r0, #864	; 0x360
#else
    return false;
#endif /* REGION_EU868 */
}
 8037996:	bc10      	pop	{r4}
    return RegionCommonChanDisable( RegionNvmGroup2->ChannelsMask, id, EU868_MAX_NB_CHANNELS );
 8037998:	2210      	movs	r2, #16
 803799a:	f7ff b811 	b.w	80369c0 <RegionCommonChanDisable>
}
 803799e:	2000      	movs	r0, #0
 80379a0:	bc10      	pop	{r4}
 80379a2:	4770      	bx	lr
 80379a4:	20005728 	.word	0x20005728

080379a8 <RegionEU868ApplyCFList>:
{
 80379a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80379ac:	b086      	sub	sp, #24
    newChannel.DrRange.Value = ( DR_5 << 4 ) | DR_0;
 80379ae:	2350      	movs	r3, #80	; 0x50
 80379b0:	f88d 3014 	strb.w	r3, [sp, #20]
    if( applyCFList->Size != 16 )
 80379b4:	7903      	ldrb	r3, [r0, #4]
 80379b6:	2b10      	cmp	r3, #16
{
 80379b8:	4607      	mov	r7, r0
    if( applyCFList->Size != 16 )
 80379ba:	d130      	bne.n	8037a1e <RegionEU868ApplyCFList+0x76>
    if( applyCFList->Payload[15] != 0 )
 80379bc:	6803      	ldr	r3, [r0, #0]
 80379be:	7bdd      	ldrb	r5, [r3, #15]
 80379c0:	bb6d      	cbnz	r5, 8037a1e <RegionEU868ApplyCFList+0x76>
    for( uint8_t i = 0, chanIdx = EU868_NUMB_DEFAULT_CHANNELS; chanIdx < EU868_MAX_NB_CHANNELS; i+=3, chanIdx++ )
 80379c2:	2403      	movs	r4, #3
            newChannel.Frequency = 0;
 80379c4:	46a8      	mov	r8, r5
            newChannel.Frequency *= 100;
 80379c6:	2664      	movs	r6, #100	; 0x64
        if( chanIdx < ( EU868_NUMB_CHANNELS_CF_LIST + EU868_NUMB_DEFAULT_CHANNELS ) )
 80379c8:	2c07      	cmp	r4, #7
 80379ca:	d814      	bhi.n	80379f6 <RegionEU868ApplyCFList+0x4e>
            newChannel.Frequency = (uint32_t) applyCFList->Payload[i];
 80379cc:	683a      	ldr	r2, [r7, #0]
 80379ce:	5d53      	ldrb	r3, [r2, r5]
 80379d0:	9303      	str	r3, [sp, #12]
            newChannel.Frequency |= ( (uint32_t) applyCFList->Payload[i + 1] << 8 );
 80379d2:	442a      	add	r2, r5
 80379d4:	7851      	ldrb	r1, [r2, #1]
 80379d6:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 80379da:	9303      	str	r3, [sp, #12]
            newChannel.Frequency |= ( (uint32_t) applyCFList->Payload[i + 2] << 16 );
 80379dc:	7892      	ldrb	r2, [r2, #2]
 80379de:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
            newChannel.Frequency *= 100;
 80379e2:	4373      	muls	r3, r6
            newChannel.Rx1Frequency = 0;
 80379e4:	e9cd 3803 	strd	r3, r8, [sp, #12]
        if( newChannel.Frequency != 0 )
 80379e8:	b963      	cbnz	r3, 8037a04 <RegionEU868ApplyCFList+0x5c>
            RegionEU868ChannelsRemove( &channelRemove );
 80379ea:	4668      	mov	r0, sp
            channelRemove.ChannelId = chanIdx;
 80379ec:	f88d 4000 	strb.w	r4, [sp]
            RegionEU868ChannelsRemove( &channelRemove );
 80379f0:	f7ff ffc2 	bl	8037978 <RegionEU868ChannelsRemove>
 80379f4:	e00d      	b.n	8037a12 <RegionEU868ApplyCFList+0x6a>
            newChannel.Frequency = 0;
 80379f6:	f8cd 800c 	str.w	r8, [sp, #12]
            newChannel.DrRange.Value = 0;
 80379fa:	f88d 8014 	strb.w	r8, [sp, #20]
            newChannel.Rx1Frequency = 0;
 80379fe:	f8cd 8010 	str.w	r8, [sp, #16]
        if( newChannel.Frequency != 0 )
 8037a02:	e7f2      	b.n	80379ea <RegionEU868ApplyCFList+0x42>
            channelAdd.NewChannel = &newChannel;
 8037a04:	ab03      	add	r3, sp, #12
            RegionEU868ChannelAdd( &channelAdd );
 8037a06:	a801      	add	r0, sp, #4
            channelAdd.NewChannel = &newChannel;
 8037a08:	9301      	str	r3, [sp, #4]
            channelAdd.ChannelId = chanIdx;
 8037a0a:	f88d 4008 	strb.w	r4, [sp, #8]
            RegionEU868ChannelAdd( &channelAdd );
 8037a0e:	f7ff ff55 	bl	80378bc <RegionEU868ChannelAdd>
    for( uint8_t i = 0, chanIdx = EU868_NUMB_DEFAULT_CHANNELS; chanIdx < EU868_MAX_NB_CHANNELS; i+=3, chanIdx++ )
 8037a12:	3401      	adds	r4, #1
 8037a14:	b2e4      	uxtb	r4, r4
 8037a16:	2c10      	cmp	r4, #16
 8037a18:	f105 0503 	add.w	r5, r5, #3
 8037a1c:	d1d4      	bne.n	80379c8 <RegionEU868ApplyCFList+0x20>
}
 8037a1e:	b006      	add	sp, #24
 8037a20:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08037a24 <RegionEU868NewChannelReq>:
{
 8037a24:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    if( newChannelReq->NewChannel->Frequency == 0 )
 8037a26:	6802      	ldr	r2, [r0, #0]
 8037a28:	7903      	ldrb	r3, [r0, #4]
 8037a2a:	6811      	ldr	r1, [r2, #0]
 8037a2c:	b951      	cbnz	r1, 8037a44 <RegionEU868NewChannelReq+0x20>
        if( RegionEU868ChannelsRemove( &channelRemove ) == false )
 8037a2e:	a801      	add	r0, sp, #4
        channelRemove.ChannelId = newChannelReq->ChannelId;
 8037a30:	f88d 3004 	strb.w	r3, [sp, #4]
        if( RegionEU868ChannelsRemove( &channelRemove ) == false )
 8037a34:	f7ff ffa0 	bl	8037978 <RegionEU868ChannelsRemove>
 8037a38:	b988      	cbnz	r0, 8037a5e <RegionEU868NewChannelReq+0x3a>
            status &= 0xFC;
 8037a3a:	2000      	movs	r0, #0
}
 8037a3c:	b240      	sxtb	r0, r0
 8037a3e:	b005      	add	sp, #20
 8037a40:	f85d fb04 	ldr.w	pc, [sp], #4
        switch( RegionEU868ChannelAdd( &channelAdd ) )
 8037a44:	a802      	add	r0, sp, #8
        channelAdd.NewChannel = newChannelReq->NewChannel;
 8037a46:	9202      	str	r2, [sp, #8]
        channelAdd.ChannelId = newChannelReq->ChannelId;
 8037a48:	f88d 300c 	strb.w	r3, [sp, #12]
        switch( RegionEU868ChannelAdd( &channelAdd ) )
 8037a4c:	f7ff ff36 	bl	80378bc <RegionEU868ChannelAdd>
 8037a50:	2806      	cmp	r0, #6
 8037a52:	d8f2      	bhi.n	8037a3a <RegionEU868NewChannelReq+0x16>
 8037a54:	4b03      	ldr	r3, [pc, #12]	; (8037a64 <RegionEU868NewChannelReq+0x40>)
 8037a56:	4418      	add	r0, r3
 8037a58:	f890 005c 	ldrb.w	r0, [r0, #92]	; 0x5c
 8037a5c:	e7ee      	b.n	8037a3c <RegionEU868NewChannelReq+0x18>
    uint8_t status = 0x03;
 8037a5e:	2003      	movs	r0, #3
 8037a60:	e7ec      	b.n	8037a3c <RegionEU868NewChannelReq+0x18>
 8037a62:	bf00      	nop
 8037a64:	0803ba84 	.word	0x0803ba84

08037a68 <RegionEU868SetContinuousWave>:

void RegionEU868SetContinuousWave( ContinuousWaveParams_t* continuousWave )
{
 8037a68:	b570      	push	{r4, r5, r6, lr}
#if defined( REGION_EU868 )
    int8_t txPowerLimited = RegionCommonLimitTxPower( continuousWave->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[continuousWave->Channel].Band].TxMaxPower );
 8037a6a:	4e11      	ldr	r6, [pc, #68]	; (8037ab0 <RegionEU868SetContinuousWave+0x48>)
 8037a6c:	7802      	ldrb	r2, [r0, #0]
 8037a6e:	e9d6 3100 	ldrd	r3, r1, [r6]
 8037a72:	250c      	movs	r5, #12
 8037a74:	fb05 3202 	mla	r2, r5, r2, r3
{
 8037a78:	4604      	mov	r4, r0
    int8_t txPowerLimited = RegionCommonLimitTxPower( continuousWave->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[continuousWave->Channel].Band].TxMaxPower );
 8037a7a:	7a53      	ldrb	r3, [r2, #9]
 8037a7c:	f990 0002 	ldrsb.w	r0, [r0, #2]
 8037a80:	2218      	movs	r2, #24
 8037a82:	fb02 1303 	mla	r3, r2, r3, r1
 8037a86:	f993 1002 	ldrsb.w	r1, [r3, #2]
 8037a8a:	f7ff fa4b 	bl	8036f24 <RegionCommonLimitTxPower>
    int8_t phyTxPower = 0;
    uint32_t frequency = RegionNvmGroup2->Channels[continuousWave->Channel].Frequency;
 8037a8e:	7822      	ldrb	r2, [r4, #0]
 8037a90:	6833      	ldr	r3, [r6, #0]

    // Calculate physical TX power
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, continuousWave->MaxEirp, continuousWave->AntennaGain );
 8037a92:	6861      	ldr	r1, [r4, #4]
    uint32_t frequency = RegionNvmGroup2->Channels[continuousWave->Channel].Frequency;
 8037a94:	4355      	muls	r5, r2
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, continuousWave->MaxEirp, continuousWave->AntennaGain );
 8037a96:	68a2      	ldr	r2, [r4, #8]
    uint32_t frequency = RegionNvmGroup2->Channels[continuousWave->Channel].Frequency;
 8037a98:	595d      	ldr	r5, [r3, r5]
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, continuousWave->MaxEirp, continuousWave->AntennaGain );
 8037a9a:	f7ff f978 	bl	8036d8e <RegionCommonComputeTxPower>

    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 8037a9e:	4b05      	ldr	r3, [pc, #20]	; (8037ab4 <RegionEU868SetContinuousWave+0x4c>)
 8037aa0:	89a2      	ldrh	r2, [r4, #12]
 8037aa2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, continuousWave->MaxEirp, continuousWave->AntennaGain );
 8037aa4:	4601      	mov	r1, r0
    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 8037aa6:	4628      	mov	r0, r5
#endif /* REGION_EU868 */
}
 8037aa8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 8037aac:	4718      	bx	r3
 8037aae:	bf00      	nop
 8037ab0:	20005728 	.word	0x20005728
 8037ab4:	0803bbc0 	.word	0x0803bbc0

08037ab8 <RegionEU868ApplyDrOffset>:

uint8_t RegionEU868ApplyDrOffset( uint8_t downlinkDwellTime, int8_t dr, int8_t drOffset )
{
#if defined( REGION_EU868 )
    int8_t datarate = dr - drOffset;
 8037ab8:	1a88      	subs	r0, r1, r2
 8037aba:	b240      	sxtb	r0, r0

    if( datarate < 0 )
    {
        datarate = DR_0;
    }
    return datarate;
 8037abc:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
#else
    return 0;
#endif /* REGION_EU868 */
}
 8037ac0:	b2c0      	uxtb	r0, r0
 8037ac2:	4770      	bx	lr

08037ac4 <GetTimeOnAir>:
    }
    return true;
}

static TimerTime_t GetTimeOnAir( int8_t datarate, uint16_t pktLen )
{
 8037ac4:	b530      	push	{r4, r5, lr}
 8037ac6:	460c      	mov	r4, r1
    int8_t phyDr = DataratesUS915[datarate];
 8037ac8:	490a      	ldr	r1, [pc, #40]	; (8037af4 <GetTimeOnAir+0x30>)
{
 8037aca:	b085      	sub	sp, #20
    int8_t phyDr = DataratesUS915[datarate];
 8037acc:	560d      	ldrsb	r5, [r1, r0]
    uint32_t bandwidth = RegionCommonGetBandwidth( datarate, BandwidthsUS915 );
 8037ace:	3110      	adds	r1, #16
 8037ad0:	f7ff fa2c 	bl	8036f2c <RegionCommonGetBandwidth>

    return Radio.TimeOnAir( MODEM_LORA, bandwidth, phyDr, 1, 8, false, pktLen, true );
 8037ad4:	2208      	movs	r2, #8
    uint32_t bandwidth = RegionCommonGetBandwidth( datarate, BandwidthsUS915 );
 8037ad6:	4601      	mov	r1, r0
    return Radio.TimeOnAir( MODEM_LORA, bandwidth, phyDr, 1, 8, false, pktLen, true );
 8037ad8:	2000      	movs	r0, #0
 8037ada:	e9cd 2000 	strd	r2, r0, [sp]
 8037ade:	4a06      	ldr	r2, [pc, #24]	; (8037af8 <GetTimeOnAir+0x34>)
 8037ae0:	2301      	movs	r3, #1
 8037ae2:	b2e4      	uxtb	r4, r4
 8037ae4:	9402      	str	r4, [sp, #8]
 8037ae6:	9303      	str	r3, [sp, #12]
 8037ae8:	6a54      	ldr	r4, [r2, #36]	; 0x24
 8037aea:	4618      	mov	r0, r3
 8037aec:	462a      	mov	r2, r5
 8037aee:	47a0      	blx	r4
}
 8037af0:	b005      	add	sp, #20
 8037af2:	bd30      	pop	{r4, r5, pc}
 8037af4:	0803bae8 	.word	0x0803bae8
 8037af8:	0803bbc0 	.word	0x0803bbc0

08037afc <VerifyRfFreq>:
    if( Radio.CheckRfFrequency( freq ) == false )
 8037afc:	4b0b      	ldr	r3, [pc, #44]	; (8037b2c <VerifyRfFreq+0x30>)
{
 8037afe:	b510      	push	{r4, lr}
    if( Radio.CheckRfFrequency( freq ) == false )
 8037b00:	6a1b      	ldr	r3, [r3, #32]
{
 8037b02:	4604      	mov	r4, r0
    if( Radio.CheckRfFrequency( freq ) == false )
 8037b04:	4798      	blx	r3
 8037b06:	b168      	cbz	r0, 8037b24 <VerifyRfFreq+0x28>
    if( ( freq < US915_FIRST_RX1_CHANNEL ) ||
 8037b08:	4b09      	ldr	r3, [pc, #36]	; (8037b30 <VerifyRfFreq+0x34>)
 8037b0a:	4a0a      	ldr	r2, [pc, #40]	; (8037b34 <VerifyRfFreq+0x38>)
 8037b0c:	4423      	add	r3, r4
 8037b0e:	4293      	cmp	r3, r2
 8037b10:	d809      	bhi.n	8037b26 <VerifyRfFreq+0x2a>
        ( freq > US915_LAST_RX1_CHANNEL ) ||
 8037b12:	4a09      	ldr	r2, [pc, #36]	; (8037b38 <VerifyRfFreq+0x3c>)
 8037b14:	4353      	muls	r3, r2
 8037b16:	f641 32f6 	movw	r2, #7158	; 0x1bf6
 8037b1a:	ebb2 1fb3 	cmp.w	r2, r3, ror #6
 8037b1e:	bf2c      	ite	cs
 8037b20:	2001      	movcs	r0, #1
 8037b22:	2000      	movcc	r0, #0
}
 8037b24:	bd10      	pop	{r4, pc}
        return false;
 8037b26:	2000      	movs	r0, #0
 8037b28:	e7fc      	b.n	8037b24 <VerifyRfFreq+0x28>
 8037b2a:	bf00      	nop
 8037b2c:	0803bbc0 	.word	0x0803bbc0
 8037b30:	c8f78f60 	.word	0xc8f78f60
 8037b34:	00401640 	.word	0x00401640
 8037b38:	5943f75f 	.word	0x5943f75f

08037b3c <RegionUS915GetPhyParam>:
#endif /* REGION_US915 */

PhyParam_t RegionUS915GetPhyParam( GetPhyParams_t* getPhy )
{
 8037b3c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    PhyParam_t phyParam = { 0 };
 8037b3e:	2300      	movs	r3, #0
 8037b40:	9300      	str	r3, [sp, #0]

#if defined( REGION_US915 )
    switch( getPhy->Attribute )
 8037b42:	7803      	ldrb	r3, [r0, #0]
 8037b44:	3b01      	subs	r3, #1
 8037b46:	2b38      	cmp	r3, #56	; 0x38
 8037b48:	d875      	bhi.n	8037c36 <RegionUS915GetPhyParam+0xfa>
 8037b4a:	e8df f003 	tbb	[pc, r3]
 8037b4e:	741d      	.short	0x741d
 8037b50:	74747474 	.word	0x74747474
 8037b54:	74747474 	.word	0x74747474
 8037b58:	40393735 	.word	0x40393735
 8037b5c:	4d4a4774 	.word	0x4d4a4774
 8037b60:	59565350 	.word	0x59565350
 8037b64:	631d6174 	.word	0x631d6174
 8037b68:	746f6d68 	.word	0x746f6d68
 8037b6c:	20787274 	.word	0x20787274
 8037b70:	74747474 	.word	0x74747474
 8037b74:	74747474 	.word	0x74747474
 8037b78:	74747474 	.word	0x74747474
 8037b7c:	1d807a74 	.word	0x1d807a74
 8037b80:	1d7a741d 	.word	0x1d7a741d
 8037b84:	881d      	.short	0x881d
 8037b86:	8d          	.byte	0x8d
 8037b87:	00          	.byte	0x00
    {
        case PHY_MIN_RX_DR:
        {
            phyParam.Value = US915_RX_MIN_DATARATE;
 8037b88:	2308      	movs	r3, #8
            phyParam.Value = US915_BEACON_NB_CHANNELS;
            break;
        }
        case PHY_SF_FROM_DR:
        {
            phyParam.Value = DataratesUS915[getPhy->Datarate];
 8037b8a:	9300      	str	r3, [sp, #0]
            break;
 8037b8c:	e053      	b.n	8037c36 <RegionUS915GetPhyParam+0xfa>
            RegionCommonGetNextLowerTxDrParams_t nextLowerTxDrParams =
 8037b8e:	7843      	ldrb	r3, [r0, #1]
 8037b90:	f88d 3004 	strb.w	r3, [sp, #4]
 8037b94:	2304      	movs	r3, #4
 8037b96:	f88d 3005 	strb.w	r3, [sp, #5]
 8037b9a:	f44f 4390 	mov.w	r3, #18432	; 0x4800
 8037b9e:	f8ad 3006 	strh.w	r3, [sp, #6]
                .ChannelsMask = RegionNvmGroup2->ChannelsMask,
 8037ba2:	4b34      	ldr	r3, [pc, #208]	; (8037c74 <RegionUS915GetPhyParam+0x138>)
 8037ba4:	681b      	ldr	r3, [r3, #0]
            phyParam.Value = RegionCommonGetNextLowerTxDr( &nextLowerTxDrParams );
 8037ba6:	a801      	add	r0, sp, #4
                .ChannelsMask = RegionNvmGroup2->ChannelsMask,
 8037ba8:	f503 7258 	add.w	r2, r3, #864	; 0x360
            RegionCommonGetNextLowerTxDrParams_t nextLowerTxDrParams =
 8037bac:	e9cd 2302 	strd	r2, r3, [sp, #8]
            phyParam.Value = RegionCommonGetNextLowerTxDr( &nextLowerTxDrParams );
 8037bb0:	f7ff f99d 	bl	8036eee <RegionCommonGetNextLowerTxDr>
        }
        case PHY_BW_FROM_DR:
        {
            phyParam.Value = RegionCommonGetBandwidth( getPhy->Datarate, BandwidthsUS915 );
 8037bb4:	9000      	str	r0, [sp, #0]
            break;
 8037bb6:	e03e      	b.n	8037c36 <RegionUS915GetPhyParam+0xfa>
            phyParam.Value = REGION_COMMON_DEFAULT_ADR_ACK_LIMIT;
 8037bb8:	2340      	movs	r3, #64	; 0x40
 8037bba:	e7e6      	b.n	8037b8a <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = REGION_COMMON_DEFAULT_ADR_ACK_DELAY;
 8037bbc:	2320      	movs	r3, #32
 8037bbe:	e7e4      	b.n	8037b8a <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = MaxPayloadOfDatarateUS915[getPhy->Datarate];
 8037bc0:	f990 2001 	ldrsb.w	r2, [r0, #1]
 8037bc4:	4b2c      	ldr	r3, [pc, #176]	; (8037c78 <RegionUS915GetPhyParam+0x13c>)
 8037bc6:	4413      	add	r3, r2
 8037bc8:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 8037bcc:	e7dd      	b.n	8037b8a <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = MaxPayloadOfDatarateRepeaterUS915[getPhy->Datarate];
 8037bce:	f990 2001 	ldrsb.w	r2, [r0, #1]
 8037bd2:	4b29      	ldr	r3, [pc, #164]	; (8037c78 <RegionUS915GetPhyParam+0x13c>)
 8037bd4:	4413      	add	r3, r2
 8037bd6:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8037bda:	e7d6      	b.n	8037b8a <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = US915_MAX_RX_WINDOW;
 8037bdc:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8037be0:	e7d3      	b.n	8037b8a <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = REGION_COMMON_DEFAULT_RECEIVE_DELAY1;
 8037be2:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8037be6:	e7d0      	b.n	8037b8a <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = REGION_COMMON_DEFAULT_RECEIVE_DELAY2;
 8037be8:	f44f 63fa 	mov.w	r3, #2000	; 0x7d0
 8037bec:	e7cd      	b.n	8037b8a <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = REGION_COMMON_DEFAULT_JOIN_ACCEPT_DELAY1;
 8037bee:	f241 3388 	movw	r3, #5000	; 0x1388
 8037bf2:	e7ca      	b.n	8037b8a <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = REGION_COMMON_DEFAULT_JOIN_ACCEPT_DELAY2;
 8037bf4:	f241 7370 	movw	r3, #6000	; 0x1770
 8037bf8:	e7c7      	b.n	8037b8a <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = REGION_COMMON_DEFAULT_MAX_FCNT_GAP;
 8037bfa:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8037bfe:	e7c4      	b.n	8037b8a <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = ( REGION_COMMON_DEFAULT_ACK_TIMEOUT + randr( -REGION_COMMON_DEFAULT_ACK_TIMEOUT_RND, REGION_COMMON_DEFAULT_ACK_TIMEOUT_RND ) );
 8037c00:	481e      	ldr	r0, [pc, #120]	; (8037c7c <RegionUS915GetPhyParam+0x140>)
 8037c02:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8037c06:	f001 f93f 	bl	8038e88 <randr>
 8037c0a:	f500 60fa 	add.w	r0, r0, #2000	; 0x7d0
 8037c0e:	e7d1      	b.n	8037bb4 <RegionUS915GetPhyParam+0x78>
            phyParam.Value = US915_RX_WND_2_FREQ;
 8037c10:	4b1b      	ldr	r3, [pc, #108]	; (8037c80 <RegionUS915GetPhyParam+0x144>)
 8037c12:	e7ba      	b.n	8037b8a <RegionUS915GetPhyParam+0x4e>
            phyParam.ChannelsMask = RegionNvmGroup2->ChannelsMask;
 8037c14:	4b17      	ldr	r3, [pc, #92]	; (8037c74 <RegionUS915GetPhyParam+0x138>)
 8037c16:	681b      	ldr	r3, [r3, #0]
 8037c18:	f503 7358 	add.w	r3, r3, #864	; 0x360
 8037c1c:	e7b5      	b.n	8037b8a <RegionUS915GetPhyParam+0x4e>
            phyParam.ChannelsMask = RegionNvmGroup2->ChannelsDefaultMask;
 8037c1e:	4b15      	ldr	r3, [pc, #84]	; (8037c74 <RegionUS915GetPhyParam+0x138>)
 8037c20:	681b      	ldr	r3, [r3, #0]
 8037c22:	f503 735b 	add.w	r3, r3, #876	; 0x36c
 8037c26:	e7b0      	b.n	8037b8a <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = US915_MAX_NB_CHANNELS;
 8037c28:	2348      	movs	r3, #72	; 0x48
 8037c2a:	e7ae      	b.n	8037b8a <RegionUS915GetPhyParam+0x4e>
            phyParam.Channels = RegionNvmGroup2->Channels;
 8037c2c:	4b11      	ldr	r3, [pc, #68]	; (8037c74 <RegionUS915GetPhyParam+0x138>)
 8037c2e:	681b      	ldr	r3, [r3, #0]
 8037c30:	e7ab      	b.n	8037b8a <RegionUS915GetPhyParam+0x4e>
            phyParam.fValue = US915_DEFAULT_MAX_ERP + 2.15f;
 8037c32:	4b14      	ldr	r3, [pc, #80]	; (8037c84 <RegionUS915GetPhyParam+0x148>)
            phyParam.fValue = 0;
 8037c34:	9300      	str	r3, [sp, #0]
        }
    }

#endif /* REGION_US915 */
    return phyParam;
}
 8037c36:	9800      	ldr	r0, [sp, #0]
 8037c38:	b005      	add	sp, #20
 8037c3a:	f85d fb04 	ldr.w	pc, [sp], #4
            phyParam.fValue = 0;
 8037c3e:	2300      	movs	r3, #0
 8037c40:	e7f8      	b.n	8037c34 <RegionUS915GetPhyParam+0xf8>
            phyParam.Value = RegionBaseUSCalcDownlinkFrequency( getPhy->Channel,
 8037c42:	4a11      	ldr	r2, [pc, #68]	; (8037c88 <RegionUS915GetPhyParam+0x14c>)
 8037c44:	490e      	ldr	r1, [pc, #56]	; (8037c80 <RegionUS915GetPhyParam+0x144>)
 8037c46:	7900      	ldrb	r0, [r0, #4]
 8037c48:	f7fe fe7a 	bl	8036940 <RegionBaseUSCalcDownlinkFrequency>
 8037c4c:	e7b2      	b.n	8037bb4 <RegionUS915GetPhyParam+0x78>
            phyParam.BeaconFormat.BeaconSize = US915_BEACON_SIZE;
 8037c4e:	f240 5317 	movw	r3, #1303	; 0x517
 8037c52:	f8ad 3000 	strh.w	r3, [sp]
            phyParam.BeaconFormat.Rfu2Size = US915_RFU2_SIZE;
 8037c56:	2303      	movs	r3, #3
 8037c58:	f88d 3002 	strb.w	r3, [sp, #2]
            break;
 8037c5c:	e7eb      	b.n	8037c36 <RegionUS915GetPhyParam+0xfa>
            phyParam.Value = DataratesUS915[getPhy->Datarate];
 8037c5e:	f990 3001 	ldrsb.w	r3, [r0, #1]
 8037c62:	4a05      	ldr	r2, [pc, #20]	; (8037c78 <RegionUS915GetPhyParam+0x13c>)
 8037c64:	5cd3      	ldrb	r3, [r2, r3]
 8037c66:	e790      	b.n	8037b8a <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = RegionCommonGetBandwidth( getPhy->Datarate, BandwidthsUS915 );
 8037c68:	4908      	ldr	r1, [pc, #32]	; (8037c8c <RegionUS915GetPhyParam+0x150>)
 8037c6a:	f990 0001 	ldrsb.w	r0, [r0, #1]
 8037c6e:	f7ff f95d 	bl	8036f2c <RegionCommonGetBandwidth>
 8037c72:	e79f      	b.n	8037bb4 <RegionUS915GetPhyParam+0x78>
 8037c74:	20005730 	.word	0x20005730
 8037c78:	0803bae8 	.word	0x0803bae8
 8037c7c:	fffffc18 	.word	0xfffffc18
 8037c80:	370870a0 	.word	0x370870a0
 8037c84:	4200999a 	.word	0x4200999a
 8037c88:	000927c0 	.word	0x000927c0
 8037c8c:	0803baf8 	.word	0x0803baf8

08037c90 <RegionUS915SetBandTxDone>:

void RegionUS915SetBandTxDone( SetBandTxDoneParams_t* txDone )
{
 8037c90:	b537      	push	{r0, r1, r2, r4, r5, lr}
#if defined( REGION_US915 )
    RegionCommonSetBandTxDone( &RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txDone->Channel].Band],
 8037c92:	4a0a      	ldr	r2, [pc, #40]	; (8037cbc <RegionUS915SetBandTxDone+0x2c>)
 8037c94:	7803      	ldrb	r3, [r0, #0]
 8037c96:	6811      	ldr	r1, [r2, #0]
 8037c98:	6855      	ldr	r5, [r2, #4]
 8037c9a:	240c      	movs	r4, #12
 8037c9c:	fb04 1303 	mla	r3, r4, r3, r1
 8037ca0:	7a5b      	ldrb	r3, [r3, #9]
 8037ca2:	eb03 0443 	add.w	r4, r3, r3, lsl #1
 8037ca6:	6903      	ldr	r3, [r0, #16]
 8037ca8:	9300      	str	r3, [sp, #0]
 8037caa:	68c3      	ldr	r3, [r0, #12]
 8037cac:	7842      	ldrb	r2, [r0, #1]
 8037cae:	6881      	ldr	r1, [r0, #8]
 8037cb0:	eb05 00c4 	add.w	r0, r5, r4, lsl #3
 8037cb4:	f7fe feca 	bl	8036a4c <RegionCommonSetBandTxDone>
                               txDone->LastTxAirTime, txDone->Joined, txDone->ElapsedTimeSinceStartUp );
#endif /* REGION_US915 */
}
 8037cb8:	b003      	add	sp, #12
 8037cba:	bd30      	pop	{r4, r5, pc}
 8037cbc:	20005730 	.word	0x20005730

08037cc0 <RegionUS915InitDefaults>:

void RegionUS915InitDefaults( InitDefaultsParams_t* params )
{
 8037cc0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8037cc2:	b087      	sub	sp, #28
#if defined( REGION_US915 )
    Band_t bands[US915_MAX_NB_BANDS] =
 8037cc4:	2301      	movs	r3, #1
    {
       US915_BAND0
    };

    switch( params->Type )
 8037cc6:	7a04      	ldrb	r4, [r0, #8]
    Band_t bands[US915_MAX_NB_BANDS] =
 8037cc8:	f8ad 3000 	strh.w	r3, [sp]
 8037ccc:	2300      	movs	r3, #0
 8037cce:	e9cd 3301 	strd	r3, r3, [sp, #4]
 8037cd2:	e9cd 3303 	strd	r3, r3, [sp, #12]
{
 8037cd6:	4602      	mov	r2, r0
    Band_t bands[US915_MAX_NB_BANDS] =
 8037cd8:	f88d 3002 	strb.w	r3, [sp, #2]
 8037cdc:	f88d 3014 	strb.w	r3, [sp, #20]
    switch( params->Type )
 8037ce0:	b124      	cbz	r4, 8037cec <RegionUS915InitDefaults+0x2c>
 8037ce2:	3c01      	subs	r4, #1
 8037ce4:	2c01      	cmp	r4, #1
 8037ce6:	d94a      	bls.n	8037d7e <RegionUS915InitDefaults+0xbe>
        {
            break;
        }
    }
#endif /* REGION_US915 */
}
 8037ce8:	b007      	add	sp, #28
 8037cea:	bdf0      	pop	{r4, r5, r6, r7, pc}
            if( ( params->NvmGroup1 == NULL ) || ( params->NvmGroup2 == NULL ) )
 8037cec:	6800      	ldr	r0, [r0, #0]
 8037cee:	2800      	cmp	r0, #0
 8037cf0:	d0fa      	beq.n	8037ce8 <RegionUS915InitDefaults+0x28>
 8037cf2:	6853      	ldr	r3, [r2, #4]
 8037cf4:	2b00      	cmp	r3, #0
 8037cf6:	d0f7      	beq.n	8037ce8 <RegionUS915InitDefaults+0x28>
            RegionNvmGroup1 = (RegionNvmDataGroup1_t*) params->NvmGroup1;
 8037cf8:	4d2d      	ldr	r5, [pc, #180]	; (8037db0 <RegionUS915InitDefaults+0xf0>)
            RegionNvmGroup1->JoinChannelGroupsCurrentIndex = 0;
 8037cfa:	f8a0 409c 	strh.w	r4, [r0, #156]	; 0x9c
            memcpy1( ( uint8_t* )RegionNvmGroup1->Bands, ( uint8_t* )bands, sizeof( Band_t ) * US915_MAX_NB_BANDS );
 8037cfe:	2218      	movs	r2, #24
 8037d00:	4669      	mov	r1, sp
            RegionNvmGroup2 = (RegionNvmDataGroup2_t*) params->NvmGroup2;
 8037d02:	e9c5 3000 	strd	r3, r0, [r5]
            memcpy1( ( uint8_t* )RegionNvmGroup1->Bands, ( uint8_t* )bands, sizeof( Band_t ) * US915_MAX_NB_BANDS );
 8037d06:	f001 f8db 	bl	8038ec0 <memcpy1>
                RegionNvmGroup2->Channels[i].Frequency = 902300000 + i * 200000;
 8037d0a:	6828      	ldr	r0, [r5, #0]
 8037d0c:	4b29      	ldr	r3, [pc, #164]	; (8037db4 <RegionUS915InitDefaults+0xf4>)
            for( uint8_t i = 0; i < US915_MAX_NB_CHANNELS - 8; i++ )
 8037d0e:	4e2a      	ldr	r6, [pc, #168]	; (8037db8 <RegionUS915InitDefaults+0xf8>)
 8037d10:	4602      	mov	r2, r0
                RegionNvmGroup2->Channels[i].Frequency = 902300000 + i * 200000;
 8037d12:	4601      	mov	r1, r0
                RegionNvmGroup2->Channels[i].DrRange.Value = ( DR_3 << 4 ) | DR_0;
 8037d14:	2730      	movs	r7, #48	; 0x30
                RegionNvmGroup2->Channels[i].Frequency = 902300000 + i * 200000;
 8037d16:	600b      	str	r3, [r1, #0]
                RegionNvmGroup2->Channels[i].DrRange.Value = ( DR_3 << 4 ) | DR_0;
 8037d18:	f503 3343 	add.w	r3, r3, #199680	; 0x30c00
 8037d1c:	f503 73a0 	add.w	r3, r3, #320	; 0x140
            for( uint8_t i = 0; i < US915_MAX_NB_CHANNELS - 8; i++ )
 8037d20:	42b3      	cmp	r3, r6
                RegionNvmGroup2->Channels[i].DrRange.Value = ( DR_3 << 4 ) | DR_0;
 8037d22:	720f      	strb	r7, [r1, #8]
                RegionNvmGroup2->Channels[i].Band = 0;
 8037d24:	724c      	strb	r4, [r1, #9]
            for( uint8_t i = 0; i < US915_MAX_NB_CHANNELS - 8; i++ )
 8037d26:	f101 010c 	add.w	r1, r1, #12
 8037d2a:	d1f4      	bne.n	8037d16 <RegionUS915InitDefaults+0x56>
 8037d2c:	4b23      	ldr	r3, [pc, #140]	; (8037dbc <RegionUS915InitDefaults+0xfc>)
            for( uint8_t i = US915_MAX_NB_CHANNELS - 8; i < US915_MAX_NB_CHANNELS; i++ )
 8037d2e:	4924      	ldr	r1, [pc, #144]	; (8037dc0 <RegionUS915InitDefaults+0x100>)
                RegionNvmGroup2->Channels[i].DrRange.Value = ( DR_4 << 4 ) | DR_4;
 8037d30:	2644      	movs	r6, #68	; 0x44
                RegionNvmGroup2->Channels[i].Band = 0;
 8037d32:	2400      	movs	r4, #0
                RegionNvmGroup2->Channels[i].Frequency = 903000000 + ( i - ( US915_MAX_NB_CHANNELS - 8 ) ) * 1600000;
 8037d34:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
                RegionNvmGroup2->Channels[i].DrRange.Value = ( DR_4 << 4 ) | DR_4;
 8037d38:	f503 13c3 	add.w	r3, r3, #1597440	; 0x186000
 8037d3c:	f503 6320 	add.w	r3, r3, #2560	; 0xa00
            for( uint8_t i = US915_MAX_NB_CHANNELS - 8; i < US915_MAX_NB_CHANNELS; i++ )
 8037d40:	428b      	cmp	r3, r1
                RegionNvmGroup2->Channels[i].DrRange.Value = ( DR_4 << 4 ) | DR_4;
 8037d42:	f882 6308 	strb.w	r6, [r2, #776]	; 0x308
                RegionNvmGroup2->Channels[i].Band = 0;
 8037d46:	f882 4309 	strb.w	r4, [r2, #777]	; 0x309
            for( uint8_t i = US915_MAX_NB_CHANNELS - 8; i < US915_MAX_NB_CHANNELS; i++ )
 8037d4a:	f102 020c 	add.w	r2, r2, #12
 8037d4e:	d1f1      	bne.n	8037d34 <RegionUS915InitDefaults+0x74>
            RegionNvmGroup2->ChannelsDefaultMask[0] = 0xFFFF;
 8037d50:	f04f 33ff 	mov.w	r3, #4294967295
            RegionNvmGroup2->ChannelsDefaultMask[2] = 0xFFFF;
 8037d54:	e9c0 33db 	strd	r3, r3, [r0, #876]	; 0x36c
            RegionNvmGroup2->ChannelsDefaultMask[4] = 0x00FF;
 8037d58:	23ff      	movs	r3, #255	; 0xff
 8037d5a:	f8c0 3374 	str.w	r3, [r0, #884]	; 0x374
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
 8037d5e:	f500 715b 	add.w	r1, r0, #876	; 0x36c
 8037d62:	2206      	movs	r2, #6
 8037d64:	f500 7058 	add.w	r0, r0, #864	; 0x360
 8037d68:	f7fe fe61 	bl	8036a2e <RegionCommonChanMaskCopy>
            RegionCommonChanMaskCopy( RegionNvmGroup1->ChannelsMaskRemaining, RegionNvmGroup2->ChannelsMask, CHANNELS_MASK_SIZE );
 8037d6c:	e9d5 1000 	ldrd	r1, r0, [r5]
 8037d70:	2206      	movs	r2, #6
 8037d72:	f501 7158 	add.w	r1, r1, #864	; 0x360
 8037d76:	3090      	adds	r0, #144	; 0x90
 8037d78:	f7fe fe59 	bl	8036a2e <RegionCommonChanMaskCopy>
            break;
 8037d7c:	e7b4      	b.n	8037ce8 <RegionUS915InitDefaults+0x28>
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
 8037d7e:	4c0c      	ldr	r4, [pc, #48]	; (8037db0 <RegionUS915InitDefaults+0xf0>)
 8037d80:	6820      	ldr	r0, [r4, #0]
 8037d82:	2206      	movs	r2, #6
 8037d84:	f500 715b 	add.w	r1, r0, #876	; 0x36c
 8037d88:	f500 7058 	add.w	r0, r0, #864	; 0x360
 8037d8c:	f7fe fe4f 	bl	8036a2e <RegionCommonChanMaskCopy>
                RegionNvmGroup1->ChannelsMaskRemaining[i] &= RegionNvmGroup2->ChannelsMask[i];
 8037d90:	6863      	ldr	r3, [r4, #4]
 8037d92:	6821      	ldr	r1, [r4, #0]
 8037d94:	f103 0290 	add.w	r2, r3, #144	; 0x90
 8037d98:	f501 7158 	add.w	r1, r1, #864	; 0x360
 8037d9c:	339c      	adds	r3, #156	; 0x9c
 8037d9e:	8810      	ldrh	r0, [r2, #0]
 8037da0:	f831 4b02 	ldrh.w	r4, [r1], #2
 8037da4:	4020      	ands	r0, r4
 8037da6:	f822 0b02 	strh.w	r0, [r2], #2
            for( uint8_t i = 0; i < CHANNELS_MASK_SIZE; i++ )
 8037daa:	429a      	cmp	r2, r3
 8037dac:	d1f7      	bne.n	8037d9e <RegionUS915InitDefaults+0xde>
 8037dae:	e79b      	b.n	8037ce8 <RegionUS915InitDefaults+0x28>
 8037db0:	20005730 	.word	0x20005730
 8037db4:	35c80160 	.word	0x35c80160
 8037db8:	368b5160 	.word	0x368b5160
 8037dbc:	35d2afc0 	.word	0x35d2afc0
 8037dc0:	3695ffc0 	.word	0x3695ffc0

08037dc4 <RegionUS915Verify>:

bool RegionUS915Verify( VerifyParams_t* verify, PhyAttribute_t phyAttribute )
{
 8037dc4:	b508      	push	{r3, lr}
 8037dc6:	290a      	cmp	r1, #10
 8037dc8:	d81b      	bhi.n	8037e02 <RegionUS915Verify+0x3e>
 8037dca:	e8df f001 	tbb	[pc, r1]
 8037dce:	1a06      	.short	0x1a06
 8037dd0:	0b1a1a1a 	.word	0x0b1a1a1a
 8037dd4:	181a0e0b 	.word	0x181a0e0b
 8037dd8:	18          	.byte	0x18
 8037dd9:	00          	.byte	0x00
            return false;
    }
#else
    return false;
#endif /* REGION_US915 */
}
 8037dda:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            return VerifyRfFreq( verify->Frequency );
 8037dde:	6800      	ldr	r0, [r0, #0]
 8037de0:	f7ff be8c 	b.w	8037afc <VerifyRfFreq>
            return RegionCommonValueInRange( verify->DatarateParams.Datarate, US915_TX_MIN_DATARATE, US915_TX_MAX_DATARATE );
 8037de4:	2204      	movs	r2, #4
            return RegionCommonValueInRange( verify->TxPower, US915_MAX_TX_POWER, US915_MIN_TX_POWER );
 8037de6:	2100      	movs	r1, #0
 8037de8:	e001      	b.n	8037dee <RegionUS915Verify+0x2a>
            return RegionCommonValueInRange( verify->DatarateParams.Datarate, US915_RX_MIN_DATARATE, US915_RX_MAX_DATARATE );
 8037dea:	220d      	movs	r2, #13
 8037dec:	2108      	movs	r1, #8
            return RegionCommonValueInRange( verify->TxPower, US915_MAX_TX_POWER, US915_MIN_TX_POWER );
 8037dee:	f990 0000 	ldrsb.w	r0, [r0]
 8037df2:	f7fe fddc 	bl	80369ae <RegionCommonValueInRange>
 8037df6:	3800      	subs	r0, #0
 8037df8:	bf18      	it	ne
 8037dfa:	2001      	movne	r0, #1
}
 8037dfc:	bd08      	pop	{r3, pc}
            return RegionCommonValueInRange( verify->TxPower, US915_MAX_TX_POWER, US915_MIN_TX_POWER );
 8037dfe:	220e      	movs	r2, #14
 8037e00:	e7f1      	b.n	8037de6 <RegionUS915Verify+0x22>
{
 8037e02:	2000      	movs	r0, #0
 8037e04:	e7fa      	b.n	8037dfc <RegionUS915Verify+0x38>
	...

08037e08 <RegionUS915ApplyCFList>:

void RegionUS915ApplyCFList( ApplyCFListParams_t* applyCFList )
{
 8037e08:	b5f0      	push	{r4, r5, r6, r7, lr}
#if defined( REGION_US915 )
    // Size of the optional CF list must be 16 byte
    if( applyCFList->Size != 16 )
 8037e0a:	7903      	ldrb	r3, [r0, #4]
 8037e0c:	2b10      	cmp	r3, #16
 8037e0e:	d122      	bne.n	8037e56 <RegionUS915ApplyCFList+0x4e>
    {
        return;
    }

    // Last byte CFListType must be 0x01 to indicate the CFList contains a series of ChMask fields
    if( applyCFList->Payload[15] != 0x01 )
 8037e10:	6804      	ldr	r4, [r0, #0]
 8037e12:	7be3      	ldrb	r3, [r4, #15]
 8037e14:	2b01      	cmp	r3, #1
 8037e16:	d11e      	bne.n	8037e56 <RegionUS915ApplyCFList+0x4e>
    }

    // ChMask0 - ChMask4 must be set (every ChMask has 16 bit)
    for( uint8_t chMaskItr = 0, cntPayload = 0; chMaskItr <= 4; chMaskItr++, cntPayload+=2 )
    {
        RegionNvmGroup2->ChannelsMask[chMaskItr] = (uint16_t) (0x00FF & applyCFList->Payload[cntPayload]);
 8037e18:	4b0f      	ldr	r3, [pc, #60]	; (8037e58 <RegionUS915ApplyCFList+0x50>)
 8037e1a:	681d      	ldr	r5, [r3, #0]
 8037e1c:	6859      	ldr	r1, [r3, #4]
 8037e1e:	f505 7058 	add.w	r0, r5, #864	; 0x360
 8037e22:	3190      	adds	r1, #144	; 0x90
        if( chMaskItr == 4 )
        {
            RegionNvmGroup2->ChannelsMask[chMaskItr] = RegionNvmGroup2->ChannelsMask[chMaskItr] & CHANNELS_MASK_500KHZ_MASK;
        }
        // Set the channel mask to the remaining
        RegionNvmGroup1->ChannelsMaskRemaining[chMaskItr] &= RegionNvmGroup2->ChannelsMask[chMaskItr];
 8037e24:	2200      	movs	r2, #0
        RegionNvmGroup2->ChannelsMask[chMaskItr] |= (uint16_t) (applyCFList->Payload[cntPayload+1] << 8);
 8037e26:	1c67      	adds	r7, r4, #1
        RegionNvmGroup2->ChannelsMask[chMaskItr] = (uint16_t) (0x00FF & applyCFList->Payload[cntPayload]);
 8037e28:	f814 3012 	ldrb.w	r3, [r4, r2, lsl #1]
 8037e2c:	8003      	strh	r3, [r0, #0]
        RegionNvmGroup2->ChannelsMask[chMaskItr] |= (uint16_t) (applyCFList->Payload[cntPayload+1] << 8);
 8037e2e:	f817 6012 	ldrb.w	r6, [r7, r2, lsl #1]
        if( chMaskItr == 4 )
 8037e32:	2a04      	cmp	r2, #4
        RegionNvmGroup2->ChannelsMask[chMaskItr] |= (uint16_t) (applyCFList->Payload[cntPayload+1] << 8);
 8037e34:	ea43 2306 	orr.w	r3, r3, r6, lsl #8
 8037e38:	f820 3b02 	strh.w	r3, [r0], #2
            RegionNvmGroup2->ChannelsMask[chMaskItr] = RegionNvmGroup2->ChannelsMask[chMaskItr] & CHANNELS_MASK_500KHZ_MASK;
 8037e3c:	bf04      	itt	eq
 8037e3e:	b2db      	uxtbeq	r3, r3
 8037e40:	f8a5 3368 	strheq.w	r3, [r5, #872]	; 0x368
        RegionNvmGroup1->ChannelsMaskRemaining[chMaskItr] &= RegionNvmGroup2->ChannelsMask[chMaskItr];
 8037e44:	880b      	ldrh	r3, [r1, #0]
 8037e46:	f830 6c02 	ldrh.w	r6, [r0, #-2]
 8037e4a:	3201      	adds	r2, #1
 8037e4c:	4033      	ands	r3, r6
    for( uint8_t chMaskItr = 0, cntPayload = 0; chMaskItr <= 4; chMaskItr++, cntPayload+=2 )
 8037e4e:	2a05      	cmp	r2, #5
        RegionNvmGroup1->ChannelsMaskRemaining[chMaskItr] &= RegionNvmGroup2->ChannelsMask[chMaskItr];
 8037e50:	f821 3b02 	strh.w	r3, [r1], #2
    for( uint8_t chMaskItr = 0, cntPayload = 0; chMaskItr <= 4; chMaskItr++, cntPayload+=2 )
 8037e54:	d1e8      	bne.n	8037e28 <RegionUS915ApplyCFList+0x20>
    }
#endif /* REGION_US915 */
}
 8037e56:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8037e58:	20005730 	.word	0x20005730

08037e5c <RegionUS915ChanMaskSet>:

bool RegionUS915ChanMaskSet( ChanMaskSetParams_t* chanMaskSet )
{
 8037e5c:	b570      	push	{r4, r5, r6, lr}
#if defined( REGION_US915 )
    uint8_t nbChannels = RegionCommonCountChannels( chanMaskSet->ChannelsMaskIn, 0, 4 );
 8037e5e:	2204      	movs	r2, #4
{
 8037e60:	4605      	mov	r5, r0
    uint8_t nbChannels = RegionCommonCountChannels( chanMaskSet->ChannelsMaskIn, 0, 4 );
 8037e62:	2100      	movs	r1, #0
 8037e64:	6800      	ldr	r0, [r0, #0]
 8037e66:	f7fe fdc4 	bl	80369f2 <RegionCommonCountChannels>

    // Check the number of active channels
    if( ( nbChannels < 2 ) &&
 8037e6a:	2801      	cmp	r0, #1
 8037e6c:	d003      	beq.n	8037e76 <RegionUS915ChanMaskSet+0x1a>
        ( nbChannels > 0 ) )
    {
        return false;
    }

    switch( chanMaskSet->ChannelsMaskType )
 8037e6e:	792c      	ldrb	r4, [r5, #4]
 8037e70:	b11c      	cbz	r4, 8037e7a <RegionUS915ChanMaskSet+0x1e>
 8037e72:	2c01      	cmp	r4, #1
 8037e74:	d020      	beq.n	8037eb8 <RegionUS915ChanMaskSet+0x5c>
        return false;
 8037e76:	2000      	movs	r0, #0
 8037e78:	e01d      	b.n	8037eb6 <RegionUS915ChanMaskSet+0x5a>
    {
        case CHANNELS_MASK:
        {
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, chanMaskSet->ChannelsMaskIn, CHANNELS_MASK_SIZE );
 8037e7a:	4e14      	ldr	r6, [pc, #80]	; (8037ecc <RegionUS915ChanMaskSet+0x70>)
 8037e7c:	6829      	ldr	r1, [r5, #0]
 8037e7e:	6830      	ldr	r0, [r6, #0]
 8037e80:	2206      	movs	r2, #6
 8037e82:	f500 7058 	add.w	r0, r0, #864	; 0x360
 8037e86:	f7fe fdd2 	bl	8036a2e <RegionCommonChanMaskCopy>

            RegionNvmGroup2->ChannelsDefaultMask[4] = RegionNvmGroup2->ChannelsDefaultMask[4] & CHANNELS_MASK_500KHZ_MASK;
 8037e8a:	6833      	ldr	r3, [r6, #0]
 8037e8c:	f893 2374 	ldrb.w	r2, [r3, #884]	; 0x374
 8037e90:	f8a3 2374 	strh.w	r2, [r3, #884]	; 0x374
            RegionNvmGroup2->ChannelsDefaultMask[5] = 0x0000;

            for( uint8_t i = 0; i < CHANNELS_MASK_SIZE; i++ )
            { // Copy-And the channels mask
                RegionNvmGroup1->ChannelsMaskRemaining[i] &= RegionNvmGroup2->ChannelsMask[i];
 8037e94:	6872      	ldr	r2, [r6, #4]
            RegionNvmGroup2->ChannelsDefaultMask[5] = 0x0000;
 8037e96:	f8a3 4376 	strh.w	r4, [r3, #886]	; 0x376
            for( uint8_t i = 0; i < CHANNELS_MASK_SIZE; i++ )
 8037e9a:	f102 0190 	add.w	r1, r2, #144	; 0x90
 8037e9e:	f503 7358 	add.w	r3, r3, #864	; 0x360
 8037ea2:	329c      	adds	r2, #156	; 0x9c
                RegionNvmGroup1->ChannelsMaskRemaining[i] &= RegionNvmGroup2->ChannelsMask[i];
 8037ea4:	8808      	ldrh	r0, [r1, #0]
 8037ea6:	f833 4b02 	ldrh.w	r4, [r3], #2
 8037eaa:	4020      	ands	r0, r4
 8037eac:	f821 0b02 	strh.w	r0, [r1], #2
            for( uint8_t i = 0; i < CHANNELS_MASK_SIZE; i++ )
 8037eb0:	4291      	cmp	r1, r2
 8037eb2:	d1f7      	bne.n	8037ea4 <RegionUS915ChanMaskSet+0x48>
            break;
        }
        default:
            return false;
    }
    return true;
 8037eb4:	2001      	movs	r0, #1
#else
    return false;
#endif /* REGION_US915 */
}
 8037eb6:	bd70      	pop	{r4, r5, r6, pc}
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsDefaultMask, chanMaskSet->ChannelsMaskIn, CHANNELS_MASK_SIZE );
 8037eb8:	4b04      	ldr	r3, [pc, #16]	; (8037ecc <RegionUS915ChanMaskSet+0x70>)
 8037eba:	6829      	ldr	r1, [r5, #0]
 8037ebc:	6818      	ldr	r0, [r3, #0]
 8037ebe:	2206      	movs	r2, #6
 8037ec0:	f500 705b 	add.w	r0, r0, #876	; 0x36c
 8037ec4:	f7fe fdb3 	bl	8036a2e <RegionCommonChanMaskCopy>
            break;
 8037ec8:	e7f4      	b.n	8037eb4 <RegionUS915ChanMaskSet+0x58>
 8037eca:	bf00      	nop
 8037ecc:	20005730 	.word	0x20005730

08037ed0 <RegionUS915ComputeRxWindowParameters>:

void RegionUS915ComputeRxWindowParameters( int8_t datarate, uint8_t minRxSymbols, uint32_t rxError, RxConfigParams_t *rxConfigParams )
{
 8037ed0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
#if defined( REGION_US915 )
    uint32_t tSymbolInUs = 0;

    // Get the datarate, perform a boundary check
    rxConfigParams->Datarate = MIN( datarate, US915_RX_MAX_DATARATE );
 8037ed2:	280d      	cmp	r0, #13
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsUS915 );
 8037ed4:	4d12      	ldr	r5, [pc, #72]	; (8037f20 <RegionUS915ComputeRxWindowParameters+0x50>)
    rxConfigParams->Datarate = MIN( datarate, US915_RX_MAX_DATARATE );
 8037ed6:	bfa8      	it	ge
 8037ed8:	200d      	movge	r0, #13
{
 8037eda:	461c      	mov	r4, r3
 8037edc:	460e      	mov	r6, r1
    rxConfigParams->Datarate = MIN( datarate, US915_RX_MAX_DATARATE );
 8037ede:	7058      	strb	r0, [r3, #1]
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsUS915 );
 8037ee0:	f105 0110 	add.w	r1, r5, #16
{
 8037ee4:	4617      	mov	r7, r2
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsUS915 );
 8037ee6:	f7ff f821 	bl	8036f2c <RegionCommonGetBandwidth>

    tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesUS915[rxConfigParams->Datarate], BandwidthsUS915[rxConfigParams->Datarate] );
 8037eea:	f994 3001 	ldrsb.w	r3, [r4, #1]
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsUS915 );
 8037eee:	70a0      	strb	r0, [r4, #2]
    tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesUS915[rxConfigParams->Datarate], BandwidthsUS915[rxConfigParams->Datarate] );
 8037ef0:	eb05 0283 	add.w	r2, r5, r3, lsl #2
 8037ef4:	5ce8      	ldrb	r0, [r5, r3]
 8037ef6:	6911      	ldr	r1, [r2, #16]
 8037ef8:	f7fe ff14 	bl	8036d24 <RegionCommonComputeSymbolTimeLoRa>

    RegionCommonComputeRxWindowParameters( tSymbolInUs, minRxSymbols, rxError, Radio.GetWakeupTime( ), &rxConfigParams->WindowTimeout, &rxConfigParams->WindowOffset );
 8037efc:	4b09      	ldr	r3, [pc, #36]	; (8037f24 <RegionUS915ComputeRxWindowParameters+0x54>)
 8037efe:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesUS915[rxConfigParams->Datarate], BandwidthsUS915[rxConfigParams->Datarate] );
 8037f00:	4605      	mov	r5, r0
    RegionCommonComputeRxWindowParameters( tSymbolInUs, minRxSymbols, rxError, Radio.GetWakeupTime( ), &rxConfigParams->WindowTimeout, &rxConfigParams->WindowOffset );
 8037f02:	4798      	blx	r3
 8037f04:	f104 020c 	add.w	r2, r4, #12
 8037f08:	3408      	adds	r4, #8
 8037f0a:	4603      	mov	r3, r0
 8037f0c:	9201      	str	r2, [sp, #4]
 8037f0e:	9400      	str	r4, [sp, #0]
 8037f10:	463a      	mov	r2, r7
 8037f12:	4631      	mov	r1, r6
 8037f14:	4628      	mov	r0, r5
 8037f16:	f7fe ff12 	bl	8036d3e <RegionCommonComputeRxWindowParameters>
#endif /* REGION_US915 */
}
 8037f1a:	b003      	add	sp, #12
 8037f1c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8037f1e:	bf00      	nop
 8037f20:	0803bae8 	.word	0x0803bae8
 8037f24:	0803bbc0 	.word	0x0803bbc0

08037f28 <RegionUS915RxConfig>:

bool RegionUS915RxConfig( RxConfigParams_t* rxConfig, int8_t* datarate )
{
 8037f28:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int8_t dr = rxConfig->Datarate;
    uint8_t maxPayload = 0;
    int8_t phyDr = 0;
    uint32_t frequency = rxConfig->Frequency;

    if( Radio.GetStatus( ) != RF_IDLE )
 8037f2c:	4e24      	ldr	r6, [pc, #144]	; (8037fc0 <RegionUS915RxConfig+0x98>)
    int8_t dr = rxConfig->Datarate;
 8037f2e:	f990 9001 	ldrsb.w	r9, [r0, #1]
    if( Radio.GetStatus( ) != RF_IDLE )
 8037f32:	6873      	ldr	r3, [r6, #4]
    uint32_t frequency = rxConfig->Frequency;
 8037f34:	6845      	ldr	r5, [r0, #4]
{
 8037f36:	b08b      	sub	sp, #44	; 0x2c
 8037f38:	4604      	mov	r4, r0
 8037f3a:	468a      	mov	sl, r1
    if( Radio.GetStatus( ) != RF_IDLE )
 8037f3c:	4798      	blx	r3
 8037f3e:	2800      	cmp	r0, #0
 8037f40:	d13c      	bne.n	8037fbc <RegionUS915RxConfig+0x94>
    {
        return false;
    }

    if( rxConfig->RxSlot == RX_SLOT_WIN_1 )
 8037f42:	7ce3      	ldrb	r3, [r4, #19]
 8037f44:	b933      	cbnz	r3, 8037f54 <RegionUS915RxConfig+0x2c>
    {
        // Apply window 1 frequency
        frequency = US915_FIRST_RX1_CHANNEL + ( rxConfig->Channel % 8 ) * US915_STEPWIDTH_RX1_CHANNEL;
 8037f46:	7825      	ldrb	r5, [r4, #0]
 8037f48:	4a1e      	ldr	r2, [pc, #120]	; (8037fc4 <RegionUS915RxConfig+0x9c>)
 8037f4a:	4b1f      	ldr	r3, [pc, #124]	; (8037fc8 <RegionUS915RxConfig+0xa0>)
 8037f4c:	f005 0507 	and.w	r5, r5, #7
 8037f50:	fb02 3505 	mla	r5, r2, r5, r3
    }

    // Read the physical datarate from the datarates table
    phyDr = DataratesUS915[dr];
 8037f54:	f8df 8074 	ldr.w	r8, [pc, #116]	; 8037fcc <RegionUS915RxConfig+0xa4>

    Radio.SetChannel( frequency );
 8037f58:	68f3      	ldr	r3, [r6, #12]
    phyDr = DataratesUS915[dr];
 8037f5a:	f918 b009 	ldrsb.w	fp, [r8, r9]
    Radio.SetChannel( frequency );
 8037f5e:	4628      	mov	r0, r5
 8037f60:	4798      	blx	r3

    // Radio configuration
    Radio.SetRxConfig( MODEM_LORA, rxConfig->Bandwidth, phyDr, 1, 0, 8, rxConfig->WindowTimeout, false, 0, false, 0, 0, true, rxConfig->RxContinuous );
 8037f62:	8922      	ldrh	r2, [r4, #8]
 8037f64:	9202      	str	r2, [sp, #8]
 8037f66:	2000      	movs	r0, #0
 8037f68:	2208      	movs	r2, #8
 8037f6a:	e9cd 0200 	strd	r0, r2, [sp]
 8037f6e:	7ca3      	ldrb	r3, [r4, #18]
 8037f70:	69b2      	ldr	r2, [r6, #24]
 8037f72:	9309      	str	r3, [sp, #36]	; 0x24
 8037f74:	2301      	movs	r3, #1
 8037f76:	e9cd 0307 	strd	r0, r3, [sp, #28]
 8037f7a:	e9cd 0005 	strd	r0, r0, [sp, #20]
 8037f7e:	e9cd 0003 	strd	r0, r0, [sp, #12]
 8037f82:	4617      	mov	r7, r2
 8037f84:	4618      	mov	r0, r3
 8037f86:	78a1      	ldrb	r1, [r4, #2]
 8037f88:	465a      	mov	r2, fp
 8037f8a:	47b8      	blx	r7

    /* ST_WORKAROUND_BEGIN: Keep repeater feature */
    if( rxConfig->RepeaterSupport == true )
 8037f8c:	7c63      	ldrb	r3, [r4, #17]
 8037f8e:	44c8      	add	r8, r9
 8037f90:	b18b      	cbz	r3, 8037fb6 <RegionUS915RxConfig+0x8e>
    {
        maxPayload = MaxPayloadOfDatarateRepeaterUS915[dr];
 8037f92:	f898 1060 	ldrb.w	r1, [r8, #96]	; 0x60
    else
    {
        maxPayload = MaxPayloadOfDatarateUS915[dr];
    }

    Radio.SetMaxPayloadLength( MODEM_LORA, maxPayload + LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE );
 8037f96:	6d73      	ldr	r3, [r6, #84]	; 0x54
 8037f98:	310d      	adds	r1, #13
 8037f9a:	b2c9      	uxtb	r1, r1
 8037f9c:	2001      	movs	r0, #1
 8037f9e:	4798      	blx	r3
    /* ST_WORKAROUND_END */

    /* ST_WORKAROUND_BEGIN: Print Rx config */
    RegionCommonRxConfigPrint(rxConfig->RxSlot, frequency, dr);
 8037fa0:	7ce0      	ldrb	r0, [r4, #19]
 8037fa2:	464a      	mov	r2, r9
 8037fa4:	4629      	mov	r1, r5
 8037fa6:	f7fe ffd3 	bl	8036f50 <RegionCommonRxConfigPrint>
    /* ST_WORKAROUND_END */

    *datarate = (uint8_t) dr;
 8037faa:	f88a 9000 	strb.w	r9, [sl]
    return true;
 8037fae:	2001      	movs	r0, #1
#else
    return false;
#endif /* REGION_US915 */
}
 8037fb0:	b00b      	add	sp, #44	; 0x2c
 8037fb2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        maxPayload = MaxPayloadOfDatarateUS915[dr];
 8037fb6:	f898 1050 	ldrb.w	r1, [r8, #80]	; 0x50
 8037fba:	e7ec      	b.n	8037f96 <RegionUS915RxConfig+0x6e>
        return false;
 8037fbc:	2000      	movs	r0, #0
 8037fbe:	e7f7      	b.n	8037fb0 <RegionUS915RxConfig+0x88>
 8037fc0:	0803bbc0 	.word	0x0803bbc0
 8037fc4:	000927c0 	.word	0x000927c0
 8037fc8:	370870a0 	.word	0x370870a0
 8037fcc:	0803bae8 	.word	0x0803bae8

08037fd0 <RegionUS915TxConfig>:

bool RegionUS915TxConfig( TxConfigParams_t* txConfig, int8_t* txPower, TimerTime_t* txTimeOnAir )
{
 8037fd0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if defined( REGION_US915 )
    int8_t phyDr = DataratesUS915[txConfig->Datarate];
    int8_t txPowerLimited = LimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower, txConfig->Datarate, RegionNvmGroup2->ChannelsMask );
 8037fd4:	4e3d      	ldr	r6, [pc, #244]	; (80380cc <RegionUS915TxConfig+0xfc>)
    int8_t phyDr = DataratesUS915[txConfig->Datarate];
 8037fd6:	f990 b001 	ldrsb.w	fp, [r0, #1]
 8037fda:	4b3d      	ldr	r3, [pc, #244]	; (80380d0 <RegionUS915TxConfig+0x100>)
    int8_t txPowerLimited = LimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower, txConfig->Datarate, RegionNvmGroup2->ChannelsMask );
 8037fdc:	f990 8002 	ldrsb.w	r8, [r0, #2]
    int8_t phyDr = DataratesUS915[txConfig->Datarate];
 8037fe0:	f913 700b 	ldrsb.w	r7, [r3, fp]
    int8_t txPowerLimited = LimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower, txConfig->Datarate, RegionNvmGroup2->ChannelsMask );
 8037fe4:	7803      	ldrb	r3, [r0, #0]
{
 8037fe6:	b08f      	sub	sp, #60	; 0x3c
 8037fe8:	4692      	mov	sl, r2
    int8_t txPowerLimited = LimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower, txConfig->Datarate, RegionNvmGroup2->ChannelsMask );
 8037fea:	e9d6 9200 	ldrd	r9, r2, [r6]
{
 8037fee:	910b      	str	r1, [sp, #44]	; 0x2c
    int8_t txPowerLimited = LimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower, txConfig->Datarate, RegionNvmGroup2->ChannelsMask );
 8037ff0:	210c      	movs	r1, #12
 8037ff2:	fb01 9303 	mla	r3, r1, r3, r9
 8037ff6:	2118      	movs	r1, #24
 8037ff8:	7a5b      	ldrb	r3, [r3, #9]
 8037ffa:	fb01 2303 	mla	r3, r1, r3, r2
{
 8037ffe:	4604      	mov	r4, r0
    txPowerResult =  RegionCommonLimitTxPower( txPower, maxBandTxPower );
 8038000:	f993 1002 	ldrsb.w	r1, [r3, #2]
 8038004:	4640      	mov	r0, r8
 8038006:	f7fe ff8d 	bl	8036f24 <RegionCommonLimitTxPower>
    if( datarate == DR_4 )
 803800a:	f1bb 0f04 	cmp.w	fp, #4
    txPowerResult =  RegionCommonLimitTxPower( txPower, maxBandTxPower );
 803800e:	4605      	mov	r5, r0
    if( datarate == DR_4 )
 8038010:	d14e      	bne.n	80380b0 <RegionUS915TxConfig+0xe0>
        txPowerResult = MAX( txPower, TX_POWER_2 );
 8038012:	4645      	mov	r5, r8
 8038014:	2d02      	cmp	r5, #2
 8038016:	bfb8      	it	lt
 8038018:	2502      	movlt	r5, #2
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsUS915 );
 803801a:	492e      	ldr	r1, [pc, #184]	; (80380d4 <RegionUS915TxConfig+0x104>)
 803801c:	f994 0001 	ldrsb.w	r0, [r4, #1]

    // Calculate physical TX power
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );

    // Setup the radio frequency
    Radio.SetChannel( RegionNvmGroup2->Channels[txConfig->Channel].Frequency );
 8038020:	f8df b0b8 	ldr.w	fp, [pc, #184]	; 80380dc <RegionUS915TxConfig+0x10c>
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsUS915 );
 8038024:	f7fe ff82 	bl	8036f2c <RegionCommonGetBandwidth>
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );
 8038028:	492b      	ldr	r1, [pc, #172]	; (80380d8 <RegionUS915TxConfig+0x108>)
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsUS915 );
 803802a:	900d      	str	r0, [sp, #52]	; 0x34
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );
 803802c:	2200      	movs	r2, #0
 803802e:	4628      	mov	r0, r5
 8038030:	f7fe fead 	bl	8036d8e <RegionCommonComputeTxPower>
    Radio.SetChannel( RegionNvmGroup2->Channels[txConfig->Channel].Frequency );
 8038034:	f894 c000 	ldrb.w	ip, [r4]
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );
 8038038:	900c      	str	r0, [sp, #48]	; 0x30
    Radio.SetChannel( RegionNvmGroup2->Channels[txConfig->Channel].Frequency );
 803803a:	f04f 090c 	mov.w	r9, #12
 803803e:	fb09 fc0c 	mul.w	ip, r9, ip
 8038042:	6830      	ldr	r0, [r6, #0]
 8038044:	f8db 200c 	ldr.w	r2, [fp, #12]
 8038048:	f850 000c 	ldr.w	r0, [r0, ip]
 803804c:	4790      	blx	r2

    Radio.SetTxConfig( MODEM_LORA, phyTxPower, 0, bandwidth, phyDr, 1, 8, false, true, 0, 0, false, 4000 );
 803804e:	f04f 0801 	mov.w	r8, #1
 8038052:	2200      	movs	r2, #0
 8038054:	f44f 637a 	mov.w	r3, #4000	; 0xfa0
 8038058:	2008      	movs	r0, #8
 803805a:	e9cd 2307 	strd	r2, r3, [sp, #28]
 803805e:	e9cd 2205 	strd	r2, r2, [sp, #20]
 8038062:	e9dd 130c 	ldrd	r1, r3, [sp, #48]	; 0x30
 8038066:	e9cd 2803 	strd	r2, r8, [sp, #12]
 803806a:	e9cd 8001 	strd	r8, r0, [sp, #4]
 803806e:	9700      	str	r7, [sp, #0]
 8038070:	4640      	mov	r0, r8
 8038072:	f8db 701c 	ldr.w	r7, [fp, #28]
 8038076:	47b8      	blx	r7
    /* ST_WORKAROUND_BEGIN: Print Tx config */
    RegionCommonTxConfigPrint(RegionNvmGroup2->Channels[txConfig->Channel].Frequency, txConfig->Datarate);
 8038078:	7822      	ldrb	r2, [r4, #0]
 803807a:	6833      	ldr	r3, [r6, #0]
 803807c:	f994 1001 	ldrsb.w	r1, [r4, #1]
 8038080:	fb09 f902 	mul.w	r9, r9, r2
 8038084:	f853 0009 	ldr.w	r0, [r3, r9]
 8038088:	f7fe ff90 	bl	8036fac <RegionCommonTxConfigPrint>
    /* ST_WORKAROUND_END */

    // Setup maximum payload length of the radio driver
    Radio.SetMaxPayloadLength( MODEM_LORA, txConfig->PktLen );
 803808c:	f8db 3054 	ldr.w	r3, [fp, #84]	; 0x54
 8038090:	7b21      	ldrb	r1, [r4, #12]
 8038092:	4640      	mov	r0, r8
 8038094:	4798      	blx	r3

    // Update time-on-air
    *txTimeOnAir = GetTimeOnAir( txConfig->Datarate, txConfig->PktLen );
 8038096:	89a1      	ldrh	r1, [r4, #12]
 8038098:	f994 0001 	ldrsb.w	r0, [r4, #1]
 803809c:	f7ff fd12 	bl	8037ac4 <GetTimeOnAir>

    *txPower = txPowerLimited;
 80380a0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    *txTimeOnAir = GetTimeOnAir( txConfig->Datarate, txConfig->PktLen );
 80380a2:	f8ca 0000 	str.w	r0, [sl]
    return true;
#else
    return false;
#endif /* REGION_US915 */
}
 80380a6:	4640      	mov	r0, r8
    *txPower = txPowerLimited;
 80380a8:	701d      	strb	r5, [r3, #0]
}
 80380aa:	b00f      	add	sp, #60	; 0x3c
 80380ac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if( RegionCommonCountChannels( channelsMask, 0, 4 ) < 50 )
 80380b0:	2204      	movs	r2, #4
 80380b2:	2100      	movs	r1, #0
 80380b4:	f509 7058 	add.w	r0, r9, #864	; 0x360
 80380b8:	f7fe fc9b 	bl	80369f2 <RegionCommonCountChannels>
 80380bc:	2831      	cmp	r0, #49	; 0x31
 80380be:	d8ac      	bhi.n	803801a <RegionUS915TxConfig+0x4a>
            txPowerResult = MAX( txPower, TX_POWER_5 );
 80380c0:	4645      	mov	r5, r8
 80380c2:	2d05      	cmp	r5, #5
 80380c4:	bfb8      	it	lt
 80380c6:	2505      	movlt	r5, #5
 80380c8:	e7a7      	b.n	803801a <RegionUS915TxConfig+0x4a>
 80380ca:	bf00      	nop
 80380cc:	20005730 	.word	0x20005730
 80380d0:	0803bae8 	.word	0x0803bae8
 80380d4:	0803baf8 	.word	0x0803baf8
 80380d8:	41f00000 	.word	0x41f00000
 80380dc:	0803bbc0 	.word	0x0803bbc0

080380e0 <RegionUS915LinkAdrReq>:

uint8_t RegionUS915LinkAdrReq( LinkAdrReqParams_t* linkAdrReq, int8_t* drOut, int8_t* txPowOut, uint8_t* nbRepOut, uint8_t* nbBytesParsed )
{
 80380e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;
    RegionCommonLinkAdrReqVerifyParams_t linkAdrVerifyParams;

    // Initialize local copy of channels mask
    RegionCommonChanMaskCopy( channelsMask, RegionNvmGroup2->ChannelsMask, CHANNELS_MASK_SIZE );
 80380e4:	4e88      	ldr	r6, [pc, #544]	; (8038308 <RegionUS915LinkAdrReq+0x228>)
{
 80380e6:	b095      	sub	sp, #84	; 0x54
 80380e8:	e9cd 1201 	strd	r1, r2, [sp, #4]
    RegionCommonChanMaskCopy( channelsMask, RegionNvmGroup2->ChannelsMask, CHANNELS_MASK_SIZE );
 80380ec:	6831      	ldr	r1, [r6, #0]
{
 80380ee:	9303      	str	r3, [sp, #12]
    uint16_t channelsMask[CHANNELS_MASK_SIZE] = { 0, 0, 0, 0, 0, 0 };
 80380f0:	af09      	add	r7, sp, #36	; 0x24
    RegionCommonLinkAdrParams_t linkAdrParams = { 0 };
 80380f2:	2400      	movs	r4, #0
{
 80380f4:	4605      	mov	r5, r0
    RegionCommonChanMaskCopy( channelsMask, RegionNvmGroup2->ChannelsMask, CHANNELS_MASK_SIZE );
 80380f6:	2206      	movs	r2, #6
 80380f8:	f501 7158 	add.w	r1, r1, #864	; 0x360
 80380fc:	4638      	mov	r0, r7
    uint16_t channelsMask[CHANNELS_MASK_SIZE] = { 0, 0, 0, 0, 0, 0 };
 80380fe:	e9c7 4401 	strd	r4, r4, [r7, #4]
    RegionCommonLinkAdrParams_t linkAdrParams = { 0 };
 8038102:	9407      	str	r4, [sp, #28]
 8038104:	f8ad 4020 	strh.w	r4, [sp, #32]
    uint16_t channelsMask[CHANNELS_MASK_SIZE] = { 0, 0, 0, 0, 0, 0 };
 8038108:	9409      	str	r4, [sp, #36]	; 0x24
    RegionCommonChanMaskCopy( channelsMask, RegionNvmGroup2->ChannelsMask, CHANNELS_MASK_SIZE );
 803810a:	f7fe fc90 	bl	8036a2e <RegionCommonChanMaskCopy>
            channelsMask[4] = linkAdrParams.ChMask & CHANNELS_MASK_500KHZ_MASK;
        }
        else if( linkAdrParams.ChMaskCtrl == 7 )
        {
            // Disable all 125 kHz channels
            channelsMask[0] = 0x0000;
 803810e:	46a0      	mov	r8, r4
            channelsMask[0] = 0xFFFF;
 8038110:	f04f 39ff 	mov.w	r9, #4294967295
    while( bytesProcessed < linkAdrReq->PayloadSize )
 8038114:	7a2b      	ldrb	r3, [r5, #8]
 8038116:	42a3      	cmp	r3, r4
 8038118:	d907      	bls.n	803812a <RegionUS915LinkAdrReq+0x4a>
        nextIndex = RegionCommonParseLinkAdrReq( &( linkAdrReq->Payload[bytesProcessed] ), &linkAdrParams );
 803811a:	6868      	ldr	r0, [r5, #4]
 803811c:	a907      	add	r1, sp, #28
 803811e:	4420      	add	r0, r4
 8038120:	f7fe fda6 	bl	8036c70 <RegionCommonParseLinkAdrReq>
        if( nextIndex == 0 )
 8038124:	2800      	cmp	r0, #0
 8038126:	f040 808c 	bne.w	8038242 <RegionUS915LinkAdrReq+0x162>
            channelsMask[linkAdrParams.ChMaskCtrl] = linkAdrParams.ChMask;
        }
    }

    // FCC 15.247 paragraph F mandates to hop on at least 2 125 kHz channels
    if( ( linkAdrParams.Datarate < DR_4 ) && ( RegionCommonCountChannels( channelsMask, 0, 4 ) < 2 ) )
 803812a:	f99d 301d 	ldrsb.w	r3, [sp, #29]
 803812e:	2b03      	cmp	r3, #3
 8038130:	dc07      	bgt.n	8038142 <RegionUS915LinkAdrReq+0x62>
 8038132:	2204      	movs	r2, #4
 8038134:	2100      	movs	r1, #0
 8038136:	a809      	add	r0, sp, #36	; 0x24
 8038138:	f7fe fc5b 	bl	80369f2 <RegionCommonCountChannels>
 803813c:	2801      	cmp	r0, #1
 803813e:	f240 80df 	bls.w	8038300 <RegionUS915LinkAdrReq+0x220>
    uint8_t bytesProcessed = 0;
 8038142:	f04f 0807 	mov.w	r8, #7
    {
        status &= 0xFE; // Channel mask KO
    }

    // Get the minimum possible datarate
    getPhy.Attribute = PHY_MIN_TX_DR;
 8038146:	2302      	movs	r3, #2
 8038148:	f88d 3014 	strb.w	r3, [sp, #20]
    getPhy.UplinkDwellTime = linkAdrReq->UplinkDwellTime;
    phyParam = RegionUS915GetPhyParam( &getPhy );
 803814c:	a805      	add	r0, sp, #20
    getPhy.UplinkDwellTime = linkAdrReq->UplinkDwellTime;
 803814e:	7a6b      	ldrb	r3, [r5, #9]
 8038150:	f88d 3016 	strb.w	r3, [sp, #22]
    phyParam = RegionUS915GetPhyParam( &getPhy );
 8038154:	f7ff fcf2 	bl	8037b3c <RegionUS915GetPhyParam>

    linkAdrVerifyParams.Status = status;
    linkAdrVerifyParams.AdrEnabled = linkAdrReq->AdrEnabled;
 8038158:	7aab      	ldrb	r3, [r5, #10]
 803815a:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
    linkAdrVerifyParams.Datarate = linkAdrParams.Datarate;
 803815e:	f89d 301d 	ldrb.w	r3, [sp, #29]
 8038162:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    linkAdrVerifyParams.TxPower = linkAdrParams.TxPower;
 8038166:	f89d 301e 	ldrb.w	r3, [sp, #30]
 803816a:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    linkAdrVerifyParams.NbRep = linkAdrParams.NbRep;
 803816e:	f89d 301c 	ldrb.w	r3, [sp, #28]
 8038172:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
    linkAdrVerifyParams.CurrentDatarate = linkAdrReq->CurrentDatarate;
 8038176:	7aeb      	ldrb	r3, [r5, #11]
 8038178:	f88d 3039 	strb.w	r3, [sp, #57]	; 0x39
    linkAdrVerifyParams.CurrentTxPower = linkAdrReq->CurrentTxPower;
 803817c:	7b2b      	ldrb	r3, [r5, #12]
 803817e:	f88d 303a 	strb.w	r3, [sp, #58]	; 0x3a
    linkAdrVerifyParams.CurrentNbRep = linkAdrReq->CurrentNbRep;
 8038182:	7b6b      	ldrb	r3, [r5, #13]
 8038184:	f88d 303b 	strb.w	r3, [sp, #59]	; 0x3b
    linkAdrVerifyParams.NbChannels = US915_MAX_NB_CHANNELS;
 8038188:	2348      	movs	r3, #72	; 0x48
 803818a:	f88d 303c 	strb.w	r3, [sp, #60]	; 0x3c
    linkAdrVerifyParams.ChannelsMask = channelsMask;
    linkAdrVerifyParams.MinDatarate = ( int8_t )phyParam.Value;
    linkAdrVerifyParams.MaxDatarate = US915_TX_MAX_DATARATE;
 803818e:	2304      	movs	r3, #4
 8038190:	f88d 3045 	strb.w	r3, [sp, #69]	; 0x45
    linkAdrVerifyParams.Channels = RegionNvmGroup2->Channels;
 8038194:	6833      	ldr	r3, [r6, #0]
 8038196:	9312      	str	r3, [sp, #72]	; 0x48
    linkAdrVerifyParams.MinTxPower = US915_MIN_TX_POWER;
 8038198:	230e      	movs	r3, #14
 803819a:	f8ad 304c 	strh.w	r3, [sp, #76]	; 0x4c
    linkAdrVerifyParams.MaxTxPower = US915_MAX_TX_POWER;
    linkAdrVerifyParams.Version = linkAdrReq->Version;
 803819e:	682b      	ldr	r3, [r5, #0]
    phyParam = RegionUS915GetPhyParam( &getPhy );
 80381a0:	9004      	str	r0, [sp, #16]
    linkAdrVerifyParams.MinDatarate = ( int8_t )phyParam.Value;
 80381a2:	f88d 0044 	strb.w	r0, [sp, #68]	; 0x44
    linkAdrVerifyParams.Version = linkAdrReq->Version;
 80381a6:	930c      	str	r3, [sp, #48]	; 0x30

    // Verify the parameters and update, if necessary
    status = RegionCommonLinkAdrReqVerifyParams( &linkAdrVerifyParams, &linkAdrParams.Datarate, &linkAdrParams.TxPower, &linkAdrParams.NbRep );
 80381a8:	f10d 021e 	add.w	r2, sp, #30
 80381ac:	ab07      	add	r3, sp, #28
 80381ae:	f10d 011d 	add.w	r1, sp, #29
 80381b2:	a80c      	add	r0, sp, #48	; 0x30
    linkAdrVerifyParams.Status = status;
 80381b4:	f88d 8034 	strb.w	r8, [sp, #52]	; 0x34
    linkAdrVerifyParams.ChannelsMask = channelsMask;
 80381b8:	9710      	str	r7, [sp, #64]	; 0x40
    status = RegionCommonLinkAdrReqVerifyParams( &linkAdrVerifyParams, &linkAdrParams.Datarate, &linkAdrParams.TxPower, &linkAdrParams.NbRep );
 80381ba:	f7fe fd73 	bl	8036ca4 <RegionCommonLinkAdrReqVerifyParams>

    // Update channelsMask if everything is correct
    if( status == 0x07 )
 80381be:	2807      	cmp	r0, #7
    status = RegionCommonLinkAdrReqVerifyParams( &linkAdrVerifyParams, &linkAdrParams.Datarate, &linkAdrParams.TxPower, &linkAdrParams.NbRep );
 80381c0:	4605      	mov	r5, r0
    if( status == 0x07 )
 80381c2:	d12c      	bne.n	803821e <RegionUS915LinkAdrReq+0x13e>
    {
        // Copy Mask
        RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, channelsMask, 6 );
 80381c4:	6830      	ldr	r0, [r6, #0]
 80381c6:	2206      	movs	r2, #6
 80381c8:	4639      	mov	r1, r7
 80381ca:	f500 7058 	add.w	r0, r0, #864	; 0x360
 80381ce:	f7fe fc2e 	bl	8036a2e <RegionCommonChanMaskCopy>

        RegionNvmGroup1->ChannelsMaskRemaining[0] &= RegionNvmGroup2->ChannelsMask[0];
 80381d2:	e9d6 2300 	ldrd	r2, r3, [r6]
 80381d6:	f8b2 0360 	ldrh.w	r0, [r2, #864]	; 0x360
 80381da:	f8b3 1090 	ldrh.w	r1, [r3, #144]	; 0x90
 80381de:	4001      	ands	r1, r0
 80381e0:	f8a3 1090 	strh.w	r1, [r3, #144]	; 0x90
        RegionNvmGroup1->ChannelsMaskRemaining[1] &= RegionNvmGroup2->ChannelsMask[1];
 80381e4:	f8b2 0362 	ldrh.w	r0, [r2, #866]	; 0x362
 80381e8:	f8b3 1092 	ldrh.w	r1, [r3, #146]	; 0x92
 80381ec:	4001      	ands	r1, r0
 80381ee:	f8a3 1092 	strh.w	r1, [r3, #146]	; 0x92
        RegionNvmGroup1->ChannelsMaskRemaining[2] &= RegionNvmGroup2->ChannelsMask[2];
 80381f2:	f8b2 0364 	ldrh.w	r0, [r2, #868]	; 0x364
 80381f6:	f8b3 1094 	ldrh.w	r1, [r3, #148]	; 0x94
 80381fa:	4001      	ands	r1, r0
 80381fc:	f8a3 1094 	strh.w	r1, [r3, #148]	; 0x94
        RegionNvmGroup1->ChannelsMaskRemaining[3] &= RegionNvmGroup2->ChannelsMask[3];
 8038200:	f8b2 0366 	ldrh.w	r0, [r2, #870]	; 0x366
 8038204:	f8b3 1096 	ldrh.w	r1, [r3, #150]	; 0x96
 8038208:	4001      	ands	r1, r0
 803820a:	f8a3 1096 	strh.w	r1, [r3, #150]	; 0x96
        RegionNvmGroup1->ChannelsMaskRemaining[4] = RegionNvmGroup2->ChannelsMask[4];
 803820e:	f8b2 1368 	ldrh.w	r1, [r2, #872]	; 0x368
        RegionNvmGroup1->ChannelsMaskRemaining[5] = RegionNvmGroup2->ChannelsMask[5];
 8038212:	f8b2 236a 	ldrh.w	r2, [r2, #874]	; 0x36a
        RegionNvmGroup1->ChannelsMaskRemaining[4] = RegionNvmGroup2->ChannelsMask[4];
 8038216:	f8a3 1098 	strh.w	r1, [r3, #152]	; 0x98
        RegionNvmGroup1->ChannelsMaskRemaining[5] = RegionNvmGroup2->ChannelsMask[5];
 803821a:	f8a3 209a 	strh.w	r2, [r3, #154]	; 0x9a
    }

    // Update status variables
    *drOut = linkAdrParams.Datarate;
 803821e:	9a01      	ldr	r2, [sp, #4]
 8038220:	f89d 301d 	ldrb.w	r3, [sp, #29]
 8038224:	7013      	strb	r3, [r2, #0]
    *txPowOut = linkAdrParams.TxPower;
 8038226:	9a02      	ldr	r2, [sp, #8]
 8038228:	f89d 301e 	ldrb.w	r3, [sp, #30]
 803822c:	7013      	strb	r3, [r2, #0]
    *nbRepOut = linkAdrParams.NbRep;
 803822e:	9a03      	ldr	r2, [sp, #12]
 8038230:	f89d 301c 	ldrb.w	r3, [sp, #28]
 8038234:	7013      	strb	r3, [r2, #0]
    *nbBytesParsed = bytesProcessed;
 8038236:	9b1e      	ldr	r3, [sp, #120]	; 0x78

#endif /* REGION_US915 */
    return status;
}
 8038238:	4628      	mov	r0, r5
    *nbBytesParsed = bytesProcessed;
 803823a:	701c      	strb	r4, [r3, #0]
}
 803823c:	b015      	add	sp, #84	; 0x54
 803823e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if( linkAdrParams.ChMaskCtrl == 6 )
 8038242:	f89d 301f 	ldrb.w	r3, [sp, #31]
 8038246:	f8bd 2020 	ldrh.w	r2, [sp, #32]
        bytesProcessed += nextIndex;
 803824a:	4404      	add	r4, r0
        if( linkAdrParams.ChMaskCtrl == 6 )
 803824c:	2b06      	cmp	r3, #6
        bytesProcessed += nextIndex;
 803824e:	b2e4      	uxtb	r4, r4
        if( linkAdrParams.ChMaskCtrl == 6 )
 8038250:	d105      	bne.n	803825e <RegionUS915LinkAdrReq+0x17e>
            channelsMask[2] = 0xFFFF;
 8038252:	e9cd 9909 	strd	r9, r9, [sp, #36]	; 0x24
            channelsMask[4] = linkAdrParams.ChMask & CHANNELS_MASK_500KHZ_MASK;
 8038256:	b2d2      	uxtb	r2, r2
 8038258:	f8ad 202c 	strh.w	r2, [sp, #44]	; 0x2c
 803825c:	e75a      	b.n	8038114 <RegionUS915LinkAdrReq+0x34>
        else if( linkAdrParams.ChMaskCtrl == 7 )
 803825e:	2b07      	cmp	r3, #7
 8038260:	d102      	bne.n	8038268 <RegionUS915LinkAdrReq+0x188>
            channelsMask[2] = 0x0000;
 8038262:	e9cd 8809 	strd	r8, r8, [sp, #36]	; 0x24
 8038266:	e7f6      	b.n	8038256 <RegionUS915LinkAdrReq+0x176>
        else if( linkAdrParams.ChMaskCtrl == 5 )
 8038268:	2b05      	cmp	r3, #5
 803826a:	d143      	bne.n	80382f4 <RegionUS915LinkAdrReq+0x214>
                if( ( ( linkAdrParams.ChMask & 0x00FF ) & ( bitMask << i ) ) != 0 )
 803826c:	f04f 0c00 	mov.w	ip, #0
 8038270:	b2d2      	uxtb	r2, r2
            uint8_t cntChannelMask = 0;
 8038272:	4661      	mov	r1, ip
                if( ( ( linkAdrParams.ChMask & 0x00FF ) & ( bitMask << i ) ) != 0 )
 8038274:	2301      	movs	r3, #1
 8038276:	fa03 fa0c 	lsl.w	sl, r3, ip
 803827a:	ea0c 0b03 	and.w	fp, ip, r3
 803827e:	ab14      	add	r3, sp, #80	; 0x50
 8038280:	eb03 0e41 	add.w	lr, r3, r1, lsl #1
 8038284:	ea12 0f0a 	tst.w	r2, sl
 8038288:	f83e 3c2c 	ldrh.w	r3, [lr, #-44]
 803828c:	fa0f f08a 	sxth.w	r0, sl
 8038290:	d01d      	beq.n	80382ce <RegionUS915LinkAdrReq+0x1ee>
                    if( ( i % 2 ) == 0 )
 8038292:	f1bb 0f00 	cmp.w	fp, #0
 8038296:	d10e      	bne.n	80382b6 <RegionUS915LinkAdrReq+0x1d6>
                        channelsMask[cntChannelMask] |= 0x00FF;
 8038298:	f043 03ff 	orr.w	r3, r3, #255	; 0xff
 803829c:	f82e 3c2c 	strh.w	r3, [lr, #-44]
                        channelsMask[4] |= ( bitMask << i );
 80382a0:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
 80382a4:	4318      	orrs	r0, r3
                        channelsMask[4] &= ~( bitMask << i );
 80382a6:	f8ad 002c 	strh.w	r0, [sp, #44]	; 0x2c
            for( uint8_t i = 0; i <= 7; i++ )
 80382aa:	f10c 0c01 	add.w	ip, ip, #1
 80382ae:	f1bc 0f08 	cmp.w	ip, #8
 80382b2:	d1df      	bne.n	8038274 <RegionUS915LinkAdrReq+0x194>
 80382b4:	e72e      	b.n	8038114 <RegionUS915LinkAdrReq+0x34>
                        channelsMask[cntChannelMask] |= 0xFF00;
 80382b6:	f063 03ff 	orn	r3, r3, #255	; 0xff
 80382ba:	f82e 3c2c 	strh.w	r3, [lr, #-44]
                        channelsMask[4] |= ( bitMask << i );
 80382be:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
 80382c2:	4318      	orrs	r0, r3
                        cntChannelMask++;
 80382c4:	3101      	adds	r1, #1
                        channelsMask[4] &= ~( bitMask << i );
 80382c6:	f8ad 002c 	strh.w	r0, [sp, #44]	; 0x2c
                        cntChannelMask++;
 80382ca:	b2c9      	uxtb	r1, r1
 80382cc:	e7ed      	b.n	80382aa <RegionUS915LinkAdrReq+0x1ca>
                    if( ( i % 2 ) == 0 )
 80382ce:	43c0      	mvns	r0, r0
 80382d0:	f1bb 0f00 	cmp.w	fp, #0
 80382d4:	d107      	bne.n	80382e6 <RegionUS915LinkAdrReq+0x206>
                        channelsMask[cntChannelMask] &= 0xFF00;
 80382d6:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 80382da:	f82e 3c2c 	strh.w	r3, [lr, #-44]
                        channelsMask[4] &= ~( bitMask << i );
 80382de:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
 80382e2:	4018      	ands	r0, r3
 80382e4:	e7df      	b.n	80382a6 <RegionUS915LinkAdrReq+0x1c6>
                        channelsMask[cntChannelMask] &= 0x00FF;
 80382e6:	b2db      	uxtb	r3, r3
 80382e8:	f82e 3c2c 	strh.w	r3, [lr, #-44]
                        channelsMask[4] &= ~( bitMask << i );
 80382ec:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
 80382f0:	4018      	ands	r0, r3
 80382f2:	e7e7      	b.n	80382c4 <RegionUS915LinkAdrReq+0x1e4>
            channelsMask[linkAdrParams.ChMaskCtrl] = linkAdrParams.ChMask;
 80382f4:	a914      	add	r1, sp, #80	; 0x50
 80382f6:	eb01 0343 	add.w	r3, r1, r3, lsl #1
 80382fa:	f823 2c2c 	strh.w	r2, [r3, #-44]
 80382fe:	e709      	b.n	8038114 <RegionUS915LinkAdrReq+0x34>
        status &= 0xFE; // Channel mask KO
 8038300:	f04f 0806 	mov.w	r8, #6
 8038304:	e71f      	b.n	8038146 <RegionUS915LinkAdrReq+0x66>
 8038306:	bf00      	nop
 8038308:	20005730 	.word	0x20005730

0803830c <RegionUS915RxParamSetupReq>:

uint8_t RegionUS915RxParamSetupReq( RxParamSetupReqParams_t* rxParamSetupReq )
{
 803830c:	b538      	push	{r3, r4, r5, lr}
 803830e:	4605      	mov	r5, r0
    uint8_t status = 0x07;
#if defined( REGION_US915 )

    // Verify radio frequency
    if( VerifyRfFreq( rxParamSetupReq->Frequency ) == false )
 8038310:	6840      	ldr	r0, [r0, #4]
 8038312:	f7ff fbf3 	bl	8037afc <VerifyRfFreq>
    {
        status &= 0xFE; // Channel frequency KO
    }

    // Verify datarate
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, US915_RX_MIN_DATARATE, US915_RX_MAX_DATARATE ) == false )
 8038316:	220d      	movs	r2, #13
        status &= 0xFE; // Channel frequency KO
 8038318:	2800      	cmp	r0, #0
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, US915_RX_MIN_DATARATE, US915_RX_MAX_DATARATE ) == false )
 803831a:	f04f 0108 	mov.w	r1, #8
 803831e:	f995 0000 	ldrsb.w	r0, [r5]
        status &= 0xFE; // Channel frequency KO
 8038322:	bf14      	ite	ne
 8038324:	2407      	movne	r4, #7
 8038326:	2406      	moveq	r4, #6
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, US915_RX_MIN_DATARATE, US915_RX_MAX_DATARATE ) == false )
 8038328:	f7fe fb41 	bl	80369ae <RegionCommonValueInRange>
 803832c:	b908      	cbnz	r0, 8038332 <RegionUS915RxParamSetupReq+0x26>
    {
        status &= 0xFD; // Datarate KO
 803832e:	f004 0405 	and.w	r4, r4, #5
    }
    if( ( RegionCommonValueInRange( rxParamSetupReq->Datarate, DR_5, DR_7 ) == true ) ||
 8038332:	f995 0000 	ldrsb.w	r0, [r5]
 8038336:	2207      	movs	r2, #7
 8038338:	2105      	movs	r1, #5
 803833a:	f7fe fb38 	bl	80369ae <RegionCommonValueInRange>
 803833e:	2801      	cmp	r0, #1
 8038340:	d003      	beq.n	803834a <RegionUS915RxParamSetupReq+0x3e>
 8038342:	f995 3000 	ldrsb.w	r3, [r5]
 8038346:	2b0d      	cmp	r3, #13
 8038348:	dd01      	ble.n	803834e <RegionUS915RxParamSetupReq+0x42>
        ( rxParamSetupReq->Datarate > DR_13 ) )
    {
        status &= 0xFD; // Datarate KO
 803834a:	f004 04fd 	and.w	r4, r4, #253	; 0xfd
    }

    // Verify datarate offset
    if( RegionCommonValueInRange( rxParamSetupReq->DrOffset, US915_MIN_RX1_DR_OFFSET, US915_MAX_RX1_DR_OFFSET ) == false )
 803834e:	f995 0001 	ldrsb.w	r0, [r5, #1]
 8038352:	2203      	movs	r2, #3
 8038354:	2100      	movs	r1, #0
 8038356:	f7fe fb2a 	bl	80369ae <RegionCommonValueInRange>
 803835a:	b908      	cbnz	r0, 8038360 <RegionUS915RxParamSetupReq+0x54>
    {
        status &= 0xFB; // Rx1DrOffset range KO
 803835c:	f004 04fb 	and.w	r4, r4, #251	; 0xfb
    }

#endif /* REGION_US915 */
    return status;
}
 8038360:	4620      	mov	r0, r4
 8038362:	bd38      	pop	{r3, r4, r5, pc}

08038364 <RegionUS915NewChannelReq>:

int8_t RegionUS915NewChannelReq( NewChannelReqParams_t* newChannelReq )
{
    // Do not accept the request
    return -1;
}
 8038364:	f04f 30ff 	mov.w	r0, #4294967295
 8038368:	4770      	bx	lr

0803836a <RegionUS915TxParamSetupReq>:
 803836a:	f04f 30ff 	mov.w	r0, #4294967295
 803836e:	4770      	bx	lr

08038370 <RegionUS915DlChannelReq>:
 8038370:	f04f 30ff 	mov.w	r0, #4294967295
 8038374:	4770      	bx	lr
	...

08038378 <RegionUS915AlternateDr>:
int8_t RegionUS915AlternateDr( int8_t currentDr, AlternateDrType_t type )
{
#if defined( REGION_US915 )
    // Alternates the data rate according to the channel sequence:
    // Eight times a 125kHz DR_0 and then one 500kHz DR_4 channel
    if( type == ALTERNATE_DR )
 8038378:	4b0a      	ldr	r3, [pc, #40]	; (80383a4 <RegionUS915AlternateDr+0x2c>)
 803837a:	685a      	ldr	r2, [r3, #4]
 803837c:	f892 309d 	ldrb.w	r3, [r2, #157]	; 0x9d
 8038380:	b971      	cbnz	r1, 80383a0 <RegionUS915AlternateDr+0x28>
    {
        RegionNvmGroup1->JoinTrialsCounter++;
 8038382:	3301      	adds	r3, #1
    }
    else
    {
        RegionNvmGroup1->JoinTrialsCounter--;
 8038384:	f882 309d 	strb.w	r3, [r2, #157]	; 0x9d
 8038388:	f892 309d 	ldrb.w	r3, [r2, #157]	; 0x9d
 803838c:	ebc3 02c3 	rsb	r2, r3, r3, lsl #3
 8038390:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    }

    if( RegionNvmGroup1->JoinTrialsCounter % 9 == 0 )
 8038394:	b2db      	uxtb	r3, r3
        // Use DR_4 every 9th times.
        currentDr = DR_4;
    }
    else
    {
        currentDr = DR_0;
 8038396:	2b1d      	cmp	r3, #29
    }
    return currentDr;
#else
    return -1;
#endif /* REGION_US915 */
}
 8038398:	bf34      	ite	cc
 803839a:	2004      	movcc	r0, #4
 803839c:	2000      	movcs	r0, #0
 803839e:	4770      	bx	lr
        RegionNvmGroup1->JoinTrialsCounter--;
 80383a0:	3b01      	subs	r3, #1
 80383a2:	e7ef      	b.n	8038384 <RegionUS915AlternateDr+0xc>
 80383a4:	20005730 	.word	0x20005730

080383a8 <RegionUS915NextChannel>:

LoRaMacStatus_t RegionUS915NextChannel( NextChanParams_t* nextChanParams, uint8_t* channel, TimerTime_t* time, TimerTime_t* aggregatedTimeOff )
{
 80383a8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
#if defined( REGION_US915 )
    uint8_t nbEnabledChannels = 0;
 80383ac:	2600      	movs	r6, #0
{
 80383ae:	b0a5      	sub	sp, #148	; 0x94
    RegionCommonIdentifyChannelsParam_t identifyChannelsParam;
    RegionCommonCountNbOfEnabledChannelsParams_t countChannelsParams;
    LoRaMacStatus_t status = LORAMAC_STATUS_NO_CHANNEL_FOUND;

    // Count 125kHz channels
    if( RegionCommonCountChannels( RegionNvmGroup1->ChannelsMaskRemaining, 0, 4 ) == 0 )
 80383b0:	4d4a      	ldr	r5, [pc, #296]	; (80384dc <RegionUS915NextChannel+0x134>)
    uint8_t nbEnabledChannels = 0;
 80383b2:	f88d 600e 	strb.w	r6, [sp, #14]
{
 80383b6:	4604      	mov	r4, r0
 80383b8:	460f      	mov	r7, r1
 80383ba:	4691      	mov	r9, r2
    uint8_t enabledChannels[US915_MAX_NB_CHANNELS] = { 0 };
 80383bc:	4631      	mov	r1, r6
 80383be:	2244      	movs	r2, #68	; 0x44
 80383c0:	a813      	add	r0, sp, #76	; 0x4c
{
 80383c2:	4698      	mov	r8, r3
    uint8_t nbRestrictedChannels = 0;
 80383c4:	f88d 600f 	strb.w	r6, [sp, #15]
    uint8_t enabledChannels[US915_MAX_NB_CHANNELS] = { 0 };
 80383c8:	9612      	str	r6, [sp, #72]	; 0x48
 80383ca:	f003 f9a5 	bl	803b718 <memset>
    if( RegionCommonCountChannels( RegionNvmGroup1->ChannelsMaskRemaining, 0, 4 ) == 0 )
 80383ce:	6868      	ldr	r0, [r5, #4]
 80383d0:	4631      	mov	r1, r6
 80383d2:	2204      	movs	r2, #4
 80383d4:	3090      	adds	r0, #144	; 0x90
 80383d6:	f7fe fb0c 	bl	80369f2 <RegionCommonCountChannels>
 80383da:	4606      	mov	r6, r0
 80383dc:	b950      	cbnz	r0, 80383f4 <RegionUS915NextChannel+0x4c>
    { // Reactivate default channels
        RegionCommonChanMaskCopy( RegionNvmGroup1->ChannelsMaskRemaining, RegionNvmGroup2->ChannelsMask, 4  );
 80383de:	e9d5 1000 	ldrd	r1, r0, [r5]
 80383e2:	2204      	movs	r2, #4
 80383e4:	f501 7158 	add.w	r1, r1, #864	; 0x360
 80383e8:	3090      	adds	r0, #144	; 0x90
 80383ea:	f7fe fb20 	bl	8036a2e <RegionCommonChanMaskCopy>

        RegionNvmGroup1->JoinChannelGroupsCurrentIndex = 0;
 80383ee:	686b      	ldr	r3, [r5, #4]
 80383f0:	f883 609c 	strb.w	r6, [r3, #156]	; 0x9c
    }
    // Check other channels
    if( nextChanParams->Datarate >= DR_4 )
 80383f4:	f994 3008 	ldrsb.w	r3, [r4, #8]
 80383f8:	2b03      	cmp	r3, #3
 80383fa:	e9d5 2100 	ldrd	r2, r1, [r5]
 80383fe:	dd06      	ble.n	803840e <RegionUS915NextChannel+0x66>
    {
        if( ( RegionNvmGroup1->ChannelsMaskRemaining[4] & CHANNELS_MASK_500KHZ_MASK ) == 0 )
 8038400:	f891 0098 	ldrb.w	r0, [r1, #152]	; 0x98
 8038404:	b918      	cbnz	r0, 803840e <RegionUS915NextChannel+0x66>
        {
            RegionNvmGroup1->ChannelsMaskRemaining[4] = RegionNvmGroup2->ChannelsMask[4];
 8038406:	f8b2 0368 	ldrh.w	r0, [r2, #872]	; 0x368
 803840a:	f8a1 0098 	strh.w	r0, [r1, #152]	; 0x98
        }
    }

    // Search how many channels are enabled
    countChannelsParams.Joined = nextChanParams->Joined;
 803840e:	7a60      	ldrb	r0, [r4, #9]
 8038410:	f88d 0010 	strb.w	r0, [sp, #16]
    countChannelsParams.Datarate = nextChanParams->Datarate;
    countChannelsParams.ChannelsMask = RegionNvmGroup1->ChannelsMaskRemaining;
 8038414:	f101 0090 	add.w	r0, r1, #144	; 0x90
    countChannelsParams.Channels = RegionNvmGroup2->Channels;
 8038418:	e9cd 0205 	strd	r0, r2, [sp, #20]
    countChannelsParams.Bands = RegionNvmGroup1->Bands;
    countChannelsParams.MaxNbChannels = US915_MAX_NB_CHANNELS;
 803841c:	2248      	movs	r2, #72	; 0x48
 803841e:	f8ad 2020 	strh.w	r2, [sp, #32]
    countChannelsParams.JoinChannels = NULL;
 8038422:	2200      	movs	r2, #0
 8038424:	9209      	str	r2, [sp, #36]	; 0x24

    identifyChannelsParam.AggrTimeOff = nextChanParams->AggrTimeOff;
 8038426:	6822      	ldr	r2, [r4, #0]
 8038428:	920a      	str	r2, [sp, #40]	; 0x28
    identifyChannelsParam.LastAggrTx = nextChanParams->LastAggrTx;
 803842a:	6862      	ldr	r2, [r4, #4]
    countChannelsParams.Bands = RegionNvmGroup1->Bands;
 803842c:	9107      	str	r1, [sp, #28]
    identifyChannelsParam.LastAggrTx = nextChanParams->LastAggrTx;
 803842e:	920b      	str	r2, [sp, #44]	; 0x2c
    identifyChannelsParam.DutyCycleEnabled = nextChanParams->DutyCycleEnabled;
    identifyChannelsParam.MaxBands = US915_MAX_NB_BANDS;

    identifyChannelsParam.ElapsedTimeSinceStartUp = nextChanParams->ElapsedTimeSinceStartUp;
 8038430:	e9d4 0103 	ldrd	r0, r1, [r4, #12]
    identifyChannelsParam.DutyCycleEnabled = nextChanParams->DutyCycleEnabled;
 8038434:	7aa2      	ldrb	r2, [r4, #10]
 8038436:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
    identifyChannelsParam.MaxBands = US915_MAX_NB_BANDS;
 803843a:	2201      	movs	r2, #1
 803843c:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
    identifyChannelsParam.ElapsedTimeSinceStartUp = nextChanParams->ElapsedTimeSinceStartUp;
 8038440:	aa0d      	add	r2, sp, #52	; 0x34
 8038442:	e882 0003 	stmia.w	r2, {r0, r1}
    identifyChannelsParam.LastTxIsJoinRequest = nextChanParams->LastTxIsJoinRequest;
 8038446:	7d22      	ldrb	r2, [r4, #20]
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 8038448:	8ae1      	ldrh	r1, [r4, #22]
    countChannelsParams.Datarate = nextChanParams->Datarate;
 803844a:	f88d 3011 	strb.w	r3, [sp, #17]
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 803844e:	4618      	mov	r0, r3
    identifyChannelsParam.LastTxIsJoinRequest = nextChanParams->LastTxIsJoinRequest;
 8038450:	f88d 203c 	strb.w	r2, [sp, #60]	; 0x3c
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 8038454:	f7ff fb36 	bl	8037ac4 <GetTimeOnAir>

    identifyChannelsParam.CountNbOfEnabledChannelsParam = &countChannelsParams;
 8038458:	ab04      	add	r3, sp, #16
 803845a:	9311      	str	r3, [sp, #68]	; 0x44

    status = RegionCommonIdentifyChannels( &identifyChannelsParam, aggregatedTimeOff, enabledChannels,
 803845c:	f10d 030f 	add.w	r3, sp, #15
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 8038460:	9010      	str	r0, [sp, #64]	; 0x40
    status = RegionCommonIdentifyChannels( &identifyChannelsParam, aggregatedTimeOff, enabledChannels,
 8038462:	9300      	str	r3, [sp, #0]
 8038464:	f8cd 9004 	str.w	r9, [sp, #4]
 8038468:	f10d 030e 	add.w	r3, sp, #14
 803846c:	aa12      	add	r2, sp, #72	; 0x48
 803846e:	4641      	mov	r1, r8
 8038470:	a80a      	add	r0, sp, #40	; 0x28
 8038472:	f7fe fcf8 	bl	8036e66 <RegionCommonIdentifyChannels>
                                           &nbEnabledChannels, &nbRestrictedChannels, time );

    if( status == LORAMAC_STATUS_OK )
 8038476:	4606      	mov	r6, r0
 8038478:	b988      	cbnz	r0, 803849e <RegionUS915NextChannel+0xf6>
    {
        if( nextChanParams->Joined == true )
 803847a:	7a63      	ldrb	r3, [r4, #9]
 803847c:	b19b      	cbz	r3, 80384a6 <RegionUS915NextChannel+0xfe>
        {
            // Choose randomly on of the remaining channels
            *channel = enabledChannels[randr( 0, nbEnabledChannels - 1 )];
 803847e:	f89d 100e 	ldrb.w	r1, [sp, #14]
 8038482:	3901      	subs	r1, #1
 8038484:	f000 fd00 	bl	8038e88 <randr>
 8038488:	ab24      	add	r3, sp, #144	; 0x90
 803848a:	4418      	add	r0, r3
 803848c:	f810 3c48 	ldrb.w	r3, [r0, #-72]
                uint8_t i = 0;
                while( ( ( RegionNvmGroup1->ChannelsMaskRemaining[4] & CHANNELS_MASK_500KHZ_MASK ) & ( 1 << i ) ) == 0 )
                {
                    i++;
                }
                *channel = 64 + i;
 8038490:	703b      	strb	r3, [r7, #0]
            }
        }

        // Disable the channel in the mask
        RegionCommonChanDisable( RegionNvmGroup1->ChannelsMaskRemaining, *channel, US915_MAX_NB_CHANNELS );
 8038492:	6868      	ldr	r0, [r5, #4]
 8038494:	7839      	ldrb	r1, [r7, #0]
 8038496:	2248      	movs	r2, #72	; 0x48
 8038498:	3090      	adds	r0, #144	; 0x90
 803849a:	f7fe fa91 	bl	80369c0 <RegionCommonChanDisable>
    }
    return status;
#else
    return LORAMAC_STATUS_NO_CHANNEL_FOUND;
#endif /* REGION_US915 */
}
 803849e:	4630      	mov	r0, r6
 80384a0:	b025      	add	sp, #148	; 0x94
 80384a2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            if( nextChanParams->Datarate == DR_0 )
 80384a6:	f994 3008 	ldrsb.w	r3, [r4, #8]
 80384aa:	6868      	ldr	r0, [r5, #4]
 80384ac:	b15b      	cbz	r3, 80384c6 <RegionUS915NextChannel+0x11e>
                while( ( ( RegionNvmGroup1->ChannelsMaskRemaining[4] & CHANNELS_MASK_500KHZ_MASK ) & ( 1 << i ) ) == 0 )
 80384ae:	f890 0098 	ldrb.w	r0, [r0, #152]	; 0x98
 80384b2:	4632      	mov	r2, r6
 80384b4:	b2d3      	uxtb	r3, r2
 80384b6:	fa40 f103 	asr.w	r1, r0, r3
 80384ba:	07c9      	lsls	r1, r1, #31
 80384bc:	f102 0201 	add.w	r2, r2, #1
 80384c0:	d5f8      	bpl.n	80384b4 <RegionUS915NextChannel+0x10c>
                *channel = 64 + i;
 80384c2:	3340      	adds	r3, #64	; 0x40
 80384c4:	e7e4      	b.n	8038490 <RegionUS915NextChannel+0xe8>
                if( RegionBaseUSComputeNext125kHzJoinChannel( ( uint16_t* ) RegionNvmGroup1->ChannelsMaskRemaining,
 80384c6:	f100 019c 	add.w	r1, r0, #156	; 0x9c
 80384ca:	463a      	mov	r2, r7
 80384cc:	3090      	adds	r0, #144	; 0x90
 80384ce:	f7fe f9f3 	bl	80368b8 <RegionBaseUSComputeNext125kHzJoinChannel>
 80384d2:	2803      	cmp	r0, #3
 80384d4:	d1dd      	bne.n	8038492 <RegionUS915NextChannel+0xea>
                    return LORAMAC_STATUS_PARAMETER_INVALID;
 80384d6:	4606      	mov	r6, r0
 80384d8:	e7e1      	b.n	803849e <RegionUS915NextChannel+0xf6>
 80384da:	bf00      	nop
 80384dc:	20005730 	.word	0x20005730

080384e0 <RegionUS915SetContinuousWave>:
{
    return LORAMAC_STATUS_PARAMETER_INVALID;
}

void RegionUS915SetContinuousWave( ContinuousWaveParams_t* continuousWave )
{
 80384e0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
#if defined( REGION_US915 )
    int8_t txPowerLimited = LimitTxPower( continuousWave->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[continuousWave->Channel].Band].TxMaxPower, continuousWave->Datarate, RegionNvmGroup2->ChannelsMask );
 80384e4:	4e1f      	ldr	r6, [pc, #124]	; (8038564 <RegionUS915SetContinuousWave+0x84>)
 80384e6:	7802      	ldrb	r2, [r0, #0]
 80384e8:	f8d6 8000 	ldr.w	r8, [r6]
 80384ec:	6871      	ldr	r1, [r6, #4]
 80384ee:	f990 7002 	ldrsb.w	r7, [r0, #2]
 80384f2:	f990 9001 	ldrsb.w	r9, [r0, #1]
 80384f6:	230c      	movs	r3, #12
 80384f8:	fb03 8202 	mla	r2, r3, r2, r8
{
 80384fc:	4604      	mov	r4, r0
    int8_t txPowerLimited = LimitTxPower( continuousWave->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[continuousWave->Channel].Band].TxMaxPower, continuousWave->Datarate, RegionNvmGroup2->ChannelsMask );
 80384fe:	7a53      	ldrb	r3, [r2, #9]
 8038500:	2218      	movs	r2, #24
 8038502:	fb02 1303 	mla	r3, r2, r3, r1
    txPowerResult =  RegionCommonLimitTxPower( txPower, maxBandTxPower );
 8038506:	4638      	mov	r0, r7
 8038508:	f993 1002 	ldrsb.w	r1, [r3, #2]
 803850c:	f7fe fd0a 	bl	8036f24 <RegionCommonLimitTxPower>
    if( datarate == DR_4 )
 8038510:	f1b9 0f04 	cmp.w	r9, #4
    txPowerResult =  RegionCommonLimitTxPower( txPower, maxBandTxPower );
 8038514:	4605      	mov	r5, r0
    if( datarate == DR_4 )
 8038516:	d117      	bne.n	8038548 <RegionUS915SetContinuousWave+0x68>
        txPowerResult = MAX( txPower, TX_POWER_2 );
 8038518:	2f02      	cmp	r7, #2
 803851a:	463d      	mov	r5, r7
 803851c:	bfb8      	it	lt
 803851e:	2502      	movlt	r5, #2
    int8_t phyTxPower = 0;
    uint32_t frequency = RegionNvmGroup2->Channels[continuousWave->Channel].Frequency;
 8038520:	7821      	ldrb	r1, [r4, #0]
 8038522:	6832      	ldr	r2, [r6, #0]
 8038524:	230c      	movs	r3, #12
 8038526:	434b      	muls	r3, r1

    // Calculate physical TX power
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );
 8038528:	4628      	mov	r0, r5
    uint32_t frequency = RegionNvmGroup2->Channels[continuousWave->Channel].Frequency;
 803852a:	58d6      	ldr	r6, [r2, r3]
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );
 803852c:	490e      	ldr	r1, [pc, #56]	; (8038568 <RegionUS915SetContinuousWave+0x88>)
 803852e:	2200      	movs	r2, #0
 8038530:	f7fe fc2d 	bl	8036d8e <RegionCommonComputeTxPower>

    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 8038534:	4b0d      	ldr	r3, [pc, #52]	; (803856c <RegionUS915SetContinuousWave+0x8c>)
 8038536:	89a2      	ldrh	r2, [r4, #12]
 8038538:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 803853a:	9301      	str	r3, [sp, #4]
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );
 803853c:	4601      	mov	r1, r0
    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 803853e:	4630      	mov	r0, r6
#endif /* REGION_US915 */
}
 8038540:	b003      	add	sp, #12
 8038542:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 8038546:	4718      	bx	r3
        if( RegionCommonCountChannels( channelsMask, 0, 4 ) < 50 )
 8038548:	2204      	movs	r2, #4
 803854a:	2100      	movs	r1, #0
 803854c:	f508 7058 	add.w	r0, r8, #864	; 0x360
 8038550:	f7fe fa4f 	bl	80369f2 <RegionCommonCountChannels>
 8038554:	2831      	cmp	r0, #49	; 0x31
 8038556:	d8e3      	bhi.n	8038520 <RegionUS915SetContinuousWave+0x40>
            txPowerResult = MAX( txPower, TX_POWER_5 );
 8038558:	2f05      	cmp	r7, #5
 803855a:	463d      	mov	r5, r7
 803855c:	bfb8      	it	lt
 803855e:	2505      	movlt	r5, #5
 8038560:	e7de      	b.n	8038520 <RegionUS915SetContinuousWave+0x40>
 8038562:	bf00      	nop
 8038564:	20005730 	.word	0x20005730
 8038568:	41f00000 	.word	0x41f00000
 803856c:	0803bbc0 	.word	0x0803bbc0

08038570 <RegionUS915ApplyDrOffset>:

uint8_t RegionUS915ApplyDrOffset( uint8_t downlinkDwellTime, int8_t dr, int8_t drOffset )
{
#if defined( REGION_US915 )
    int8_t datarate = DatarateOffsetsUS915[dr][drOffset];
 8038570:	4b04      	ldr	r3, [pc, #16]	; (8038584 <RegionUS915ApplyDrOffset+0x14>)
 8038572:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 8038576:	4413      	add	r3, r2
 8038578:	f993 0070 	ldrsb.w	r0, [r3, #112]	; 0x70

    if( datarate < 0 )
    {
        datarate = DR_0;
    }
    return datarate;
 803857c:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
#else
    return 0;
#endif /* REGION_US915 */
}
 8038580:	b2c0      	uxtb	r0, r0
 8038582:	4770      	bx	lr
 8038584:	0803bae8 	.word	0x0803bae8

08038588 <GetKeyIndexByID>:
 */
static SecureElementStatus_t GetKeyIndexByID( KeyIdentifier_t keyID, CK_OBJECT_HANDLE *keyIndex )
{
    for (uint8_t i = 0; i < NUM_OF_KEYS; i++)
    {
        if (SeNvm->KeyList[i].KeyID == keyID)
 8038588:	4b0a      	ldr	r3, [pc, #40]	; (80385b4 <GetKeyIndexByID+0x2c>)
 803858a:	681a      	ldr	r2, [r3, #0]
{
 803858c:	b5f0      	push	{r4, r5, r6, r7, lr}
        if (SeNvm->KeyList[i].KeyID == keyID)
 803858e:	2300      	movs	r3, #0
 8038590:	f102 0510 	add.w	r5, r2, #16
 8038594:	2618      	movs	r6, #24
 8038596:	fb06 f403 	mul.w	r4, r6, r3
 803859a:	5d2f      	ldrb	r7, [r5, r4]
 803859c:	4287      	cmp	r7, r0
 803859e:	d104      	bne.n	80385aa <GetKeyIndexByID+0x22>
        {
            *keyIndex = SeNvm->KeyList[i].Object_Index;
 80385a0:	4422      	add	r2, r4
            return SECURE_ELEMENT_SUCCESS;
 80385a2:	2000      	movs	r0, #0
            *keyIndex = SeNvm->KeyList[i].Object_Index;
 80385a4:	6a53      	ldr	r3, [r2, #36]	; 0x24
 80385a6:	600b      	str	r3, [r1, #0]
        }
    }
    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
}
 80385a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    for (uint8_t i = 0; i < NUM_OF_KEYS; i++)
 80385aa:	3301      	adds	r3, #1
 80385ac:	2b0a      	cmp	r3, #10
 80385ae:	d1f2      	bne.n	8038596 <GetKeyIndexByID+0xe>
    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 80385b0:	2003      	movs	r0, #3
 80385b2:	e7f9      	b.n	80385a8 <GetKeyIndexByID+0x20>
 80385b4:	20005738 	.word	0x20005738

080385b8 <SecureElementGetKeyByID>:
    return SECURE_ELEMENT_SUCCESS;
}

/* ST_WORKAROUND_BEGIN: Add KMS specific functions */
SecureElementStatus_t SecureElementGetKeyByID( KeyIdentifier_t keyID, Key_t **keyItem )
{
 80385b8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80385bc:	b08d      	sub	sp, #52	; 0x34
    CK_SESSION_HANDLE session;
    CK_FLAGS session_flags = CKF_SERIAL_SESSION;  /* Read ONLY session */
    CK_OBJECT_HANDLE key_handle = (CK_OBJECT_HANDLE)(~0UL);
    CK_ULONG derive_key_template_class = CKO_SECRET_KEY;
    uint8_t extractable_key[16] = {0};
    CK_ATTRIBUTE key_attribute_template = {CKA_VALUE, (CK_VOID_PTR) &derive_key_template_class, 16UL};
 80385be:	2211      	movs	r2, #17
    CK_ULONG derive_key_template_class = CKO_SECRET_KEY;
 80385c0:	2304      	movs	r3, #4
    uint8_t index_keylist = 0;
    for (index_keylist = 0; index_keylist < NUM_OF_KEYS; index_keylist++)
    {
        if (SeNvm->KeyList[index_keylist].KeyID == keyID)
 80385c2:	4e27      	ldr	r6, [pc, #156]	; (8038660 <SecureElementGetKeyByID+0xa8>)
    CK_ATTRIBUTE key_attribute_template = {CKA_VALUE, (CK_VOID_PTR) &derive_key_template_class, 16UL};
 80385c4:	9205      	str	r2, [sp, #20]
 80385c6:	aa04      	add	r2, sp, #16
    CK_ULONG derive_key_template_class = CKO_SECRET_KEY;
 80385c8:	9304      	str	r3, [sp, #16]
    CK_ATTRIBUTE key_attribute_template = {CKA_VALUE, (CK_VOID_PTR) &derive_key_template_class, 16UL};
 80385ca:	9206      	str	r2, [sp, #24]
    uint8_t extractable_key[16] = {0};
 80385cc:	2300      	movs	r3, #0
    CK_ATTRIBUTE key_attribute_template = {CKA_VALUE, (CK_VOID_PTR) &derive_key_template_class, 16UL};
 80385ce:	2210      	movs	r2, #16
 80385d0:	9207      	str	r2, [sp, #28]
    uint8_t extractable_key[16] = {0};
 80385d2:	e9cd 3308 	strd	r3, r3, [sp, #32]
        if (SeNvm->KeyList[index_keylist].KeyID == keyID)
 80385d6:	6832      	ldr	r2, [r6, #0]
    uint8_t extractable_key[16] = {0};
 80385d8:	e9cd 330a 	strd	r3, r3, [sp, #40]	; 0x28
{
 80385dc:	460f      	mov	r7, r1
        if (SeNvm->KeyList[index_keylist].KeyID == keyID)
 80385de:	2418      	movs	r4, #24
 80385e0:	f102 0110 	add.w	r1, r2, #16
 80385e4:	fb04 f503 	mul.w	r5, r4, r3
 80385e8:	f811 c005 	ldrb.w	ip, [r1, r5]
 80385ec:	4584      	cmp	ip, r0
 80385ee:	d107      	bne.n	8038600 <SecureElementGetKeyByID+0x48>
        {
            key_handle = SeNvm->KeyList[index_keylist].Object_Index;
 80385f0:	442a      	add	r2, r5
 80385f2:	f8d2 9024 	ldr.w	r9, [r2, #36]	; 0x24
            break;
        }
    }
    if (key_handle == (CK_OBJECT_HANDLE)(~0UL))
 80385f6:	f1b9 3fff 	cmp.w	r9, #4294967295
 80385fa:	d105      	bne.n	8038608 <SecureElementGetKeyByID+0x50>
    {
        return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 80385fc:	2003      	movs	r0, #3
 80385fe:	e02c      	b.n	803865a <SecureElementGetKeyByID+0xa2>
    for (index_keylist = 0; index_keylist < NUM_OF_KEYS; index_keylist++)
 8038600:	3301      	adds	r3, #1
 8038602:	2b0a      	cmp	r3, #10
 8038604:	d1ee      	bne.n	80385e4 <SecureElementGetKeyByID+0x2c>
 8038606:	e7f9      	b.n	80385fc <SecureElementGetKeyByID+0x44>
    }

    /* Open session with KMS */
    rv = C_OpenSession(0, session_flags, NULL, 0, &session);
 8038608:	ab03      	add	r3, sp, #12
 803860a:	9300      	str	r3, [sp, #0]
 803860c:	2300      	movs	r3, #0
 803860e:	461a      	mov	r2, r3
 8038610:	2104      	movs	r1, #4
 8038612:	4618      	mov	r0, r3
 8038614:	f7d0 fba2 	bl	8008d5c <SE_KMS_OpenSession>

    /* Get key to display */
    if (rv == CKR_OK)
 8038618:	4604      	mov	r4, r0
 803861a:	b9b8      	cbnz	r0, 803864c <SecureElementGetKeyByID+0x94>
    {
        key_attribute_template.pValue = extractable_key;
        rv = C_GetAttributeValue(session, key_handle, &key_attribute_template, 1UL);
 803861c:	9803      	ldr	r0, [sp, #12]
        key_attribute_template.pValue = extractable_key;
 803861e:	f10d 0820 	add.w	r8, sp, #32
        rv = C_GetAttributeValue(session, key_handle, &key_attribute_template, 1UL);
 8038622:	2301      	movs	r3, #1
 8038624:	aa05      	add	r2, sp, #20
 8038626:	4649      	mov	r1, r9
        key_attribute_template.pValue = extractable_key;
 8038628:	f8cd 8018 	str.w	r8, [sp, #24]
        rv = C_GetAttributeValue(session, key_handle, &key_attribute_template, 1UL);
 803862c:	f7d0 fc06 	bl	8008e3c <SE_KMS_GetAttributeValue>
    }
    if (rv == CKR_OK)
 8038630:	4604      	mov	r4, r0
 8038632:	b958      	cbnz	r0, 803864c <SecureElementGetKeyByID+0x94>
    {
        memcpy1(SeNvm->KeyList[index_keylist].KeyValue, extractable_key, sizeof(extractable_key));
 8038634:	6833      	ldr	r3, [r6, #0]
 8038636:	f105 0011 	add.w	r0, r5, #17
 803863a:	4418      	add	r0, r3
 803863c:	2210      	movs	r2, #16
 803863e:	4641      	mov	r1, r8
 8038640:	f000 fc3e 	bl	8038ec0 <memcpy1>
        *keyItem = &(SeNvm->KeyList[index_keylist]);
 8038644:	6833      	ldr	r3, [r6, #0]
 8038646:	3510      	adds	r5, #16
 8038648:	441d      	add	r5, r3
 803864a:	603d      	str	r5, [r7, #0]
    }

    /* Close sessions */
    (void)C_CloseSession(session);
 803864c:	9803      	ldr	r0, [sp, #12]
 803864e:	f7d0 fba5 	bl	8008d9c <SE_KMS_CloseSession>

    if (rv != CKR_OK)
    {
        return SECURE_ELEMENT_ERROR;
 8038652:	2c00      	cmp	r4, #0
 8038654:	bf0c      	ite	eq
 8038656:	2000      	moveq	r0, #0
 8038658:	2006      	movne	r0, #6
    }
    return SECURE_ELEMENT_SUCCESS;

#endif /* LORAWAN_KMS == 1 */
}
 803865a:	b00d      	add	sp, #52	; 0x34
 803865c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8038660:	20005738 	.word	0x20005738

08038664 <PrintKey>:
{
 8038664:	b510      	push	{r4, lr}
 8038666:	b092      	sub	sp, #72	; 0x48
    retval = SecureElementGetKeyByID(key, &keyItem);
 8038668:	a911      	add	r1, sp, #68	; 0x44
{
 803866a:	4604      	mov	r4, r0
    retval = SecureElementGetKeyByID(key, &keyItem);
 803866c:	f7ff ffa4 	bl	80385b8 <SecureElementGetKeyByID>
    if (retval == SECURE_ELEMENT_SUCCESS)
 8038670:	4602      	mov	r2, r0
 8038672:	2800      	cmp	r0, #0
 8038674:	d131      	bne.n	80386da <PrintKey+0x76>
        if (key == APP_KEY)
 8038676:	b914      	cbnz	r4, 803867e <PrintKey+0x1a>
            MW_LOG(TS_OFF, VLEVEL_M, "###### AppKey:      ");
 8038678:	4b27      	ldr	r3, [pc, #156]	; (8038718 <PrintKey+0xb4>)
            MW_LOG(TS_OFF, VLEVEL_M, "###### MCNwkSKey_0: ");
 803867a:	2200      	movs	r2, #0
 803867c:	e002      	b.n	8038684 <PrintKey+0x20>
        else if (key == NWK_KEY)
 803867e:	2c01      	cmp	r4, #1
 8038680:	d12d      	bne.n	80386de <PrintKey+0x7a>
            MW_LOG(TS_OFF, VLEVEL_M, "###### NwkKey:      ");
 8038682:	4b26      	ldr	r3, [pc, #152]	; (803871c <PrintKey+0xb8>)
            MW_LOG(TS_OFF, VLEVEL_M, "###### MCNwkSKey_0: ");
 8038684:	4611      	mov	r1, r2
 8038686:	2002      	movs	r0, #2
 8038688:	f002 fb00 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
        MW_LOG(TS_OFF, VLEVEL_M, "%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\r\n",
 803868c:	9b11      	ldr	r3, [sp, #68]	; 0x44
 803868e:	7c1a      	ldrb	r2, [r3, #16]
 8038690:	920f      	str	r2, [sp, #60]	; 0x3c
 8038692:	7bda      	ldrb	r2, [r3, #15]
 8038694:	920e      	str	r2, [sp, #56]	; 0x38
 8038696:	7b9a      	ldrb	r2, [r3, #14]
 8038698:	920d      	str	r2, [sp, #52]	; 0x34
 803869a:	7b5a      	ldrb	r2, [r3, #13]
 803869c:	920c      	str	r2, [sp, #48]	; 0x30
 803869e:	7b1a      	ldrb	r2, [r3, #12]
 80386a0:	920b      	str	r2, [sp, #44]	; 0x2c
 80386a2:	7ada      	ldrb	r2, [r3, #11]
 80386a4:	920a      	str	r2, [sp, #40]	; 0x28
 80386a6:	7a9a      	ldrb	r2, [r3, #10]
 80386a8:	9209      	str	r2, [sp, #36]	; 0x24
 80386aa:	7a5a      	ldrb	r2, [r3, #9]
 80386ac:	9208      	str	r2, [sp, #32]
 80386ae:	7a1a      	ldrb	r2, [r3, #8]
 80386b0:	9207      	str	r2, [sp, #28]
 80386b2:	79da      	ldrb	r2, [r3, #7]
 80386b4:	9206      	str	r2, [sp, #24]
 80386b6:	799a      	ldrb	r2, [r3, #6]
 80386b8:	9205      	str	r2, [sp, #20]
 80386ba:	795a      	ldrb	r2, [r3, #5]
 80386bc:	9204      	str	r2, [sp, #16]
 80386be:	791a      	ldrb	r2, [r3, #4]
 80386c0:	9203      	str	r2, [sp, #12]
 80386c2:	78da      	ldrb	r2, [r3, #3]
 80386c4:	9202      	str	r2, [sp, #8]
 80386c6:	789a      	ldrb	r2, [r3, #2]
 80386c8:	9201      	str	r2, [sp, #4]
 80386ca:	785b      	ldrb	r3, [r3, #1]
 80386cc:	9300      	str	r3, [sp, #0]
 80386ce:	2200      	movs	r2, #0
 80386d0:	4b13      	ldr	r3, [pc, #76]	; (8038720 <PrintKey+0xbc>)
 80386d2:	4611      	mov	r1, r2
 80386d4:	2002      	movs	r0, #2
 80386d6:	f002 fad9 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
}
 80386da:	b012      	add	sp, #72	; 0x48
 80386dc:	bd10      	pop	{r4, pc}
        else if (key == APP_S_KEY)
 80386de:	2c03      	cmp	r4, #3
 80386e0:	d101      	bne.n	80386e6 <PrintKey+0x82>
            MW_LOG(TS_OFF, VLEVEL_M, "###### AppSKey:     ");
 80386e2:	4b10      	ldr	r3, [pc, #64]	; (8038724 <PrintKey+0xc0>)
 80386e4:	e7ce      	b.n	8038684 <PrintKey+0x20>
        else if (key == NWK_S_KEY)
 80386e6:	2c02      	cmp	r4, #2
 80386e8:	d101      	bne.n	80386ee <PrintKey+0x8a>
            MW_LOG(TS_OFF, VLEVEL_M, "###### NwkSKey:     ");
 80386ea:	4b0f      	ldr	r3, [pc, #60]	; (8038728 <PrintKey+0xc4>)
 80386ec:	e7ca      	b.n	8038684 <PrintKey+0x20>
        else if (key == MC_ROOT_KEY)
 80386ee:	2c04      	cmp	r4, #4
 80386f0:	d101      	bne.n	80386f6 <PrintKey+0x92>
            MW_LOG(TS_OFF, VLEVEL_M, "###### MCRootKey:   ");
 80386f2:	4b0e      	ldr	r3, [pc, #56]	; (803872c <PrintKey+0xc8>)
 80386f4:	e7c6      	b.n	8038684 <PrintKey+0x20>
        else if (key == MC_KE_KEY)
 80386f6:	2c7f      	cmp	r4, #127	; 0x7f
 80386f8:	d101      	bne.n	80386fe <PrintKey+0x9a>
            MW_LOG(TS_OFF, VLEVEL_M, "###### MCKEKey:     ");
 80386fa:	4b0d      	ldr	r3, [pc, #52]	; (8038730 <PrintKey+0xcc>)
 80386fc:	e7c2      	b.n	8038684 <PrintKey+0x20>
        else if (key == MC_KEY_0)
 80386fe:	2c80      	cmp	r4, #128	; 0x80
 8038700:	d101      	bne.n	8038706 <PrintKey+0xa2>
            MW_LOG(TS_OFF, VLEVEL_M, "###### MCKey_0:     ");
 8038702:	4b0c      	ldr	r3, [pc, #48]	; (8038734 <PrintKey+0xd0>)
 8038704:	e7be      	b.n	8038684 <PrintKey+0x20>
        else if (key == MC_APP_S_KEY_0)
 8038706:	2c81      	cmp	r4, #129	; 0x81
 8038708:	d101      	bne.n	803870e <PrintKey+0xaa>
            MW_LOG(TS_OFF, VLEVEL_M, "###### MCAppSKey_0: ");
 803870a:	4b0b      	ldr	r3, [pc, #44]	; (8038738 <PrintKey+0xd4>)
 803870c:	e7ba      	b.n	8038684 <PrintKey+0x20>
        else if (key == MC_NWK_S_KEY_0)
 803870e:	2c82      	cmp	r4, #130	; 0x82
 8038710:	d1bc      	bne.n	803868c <PrintKey+0x28>
            MW_LOG(TS_OFF, VLEVEL_M, "###### MCNwkSKey_0: ");
 8038712:	4b0a      	ldr	r3, [pc, #40]	; (803873c <PrintKey+0xd8>)
 8038714:	e7b1      	b.n	803867a <PrintKey+0x16>
 8038716:	bf00      	nop
 8038718:	0803c375 	.word	0x0803c375
 803871c:	0803c38a 	.word	0x0803c38a
 8038720:	0803c432 	.word	0x0803c432
 8038724:	0803c39f 	.word	0x0803c39f
 8038728:	0803c3b4 	.word	0x0803c3b4
 803872c:	0803c3c9 	.word	0x0803c3c9
 8038730:	0803c3de 	.word	0x0803c3de
 8038734:	0803c3f3 	.word	0x0803c3f3
 8038738:	0803c408 	.word	0x0803c408
 803873c:	0803c41d 	.word	0x0803c41d

08038740 <SecureElementDeleteDynamicKeys>:

SecureElementStatus_t SecureElementDeleteDynamicKeys( KeyIdentifier_t keyID, uint32_t *key_label )
{
 8038740:	b530      	push	{r4, r5, lr}
 8038742:	b095      	sub	sp, #84	; 0x54
#else /* LORAWAN_KMS == 1 */
    CK_RV rv;
    CK_SESSION_HANDLE session;
    CK_FLAGS session_flags = CKF_SERIAL_SESSION;    /* Read ONLY session */
    CK_OBJECT_HANDLE hObject[NUM_OF_KEYS];
    CK_ULONG local_template_label[] = {GlobalTemplateLabel, 0UL};
 8038744:	4b37      	ldr	r3, [pc, #220]	; (8038824 <SecureElementDeleteDynamicKeys+0xe4>)
 8038746:	9305      	str	r3, [sp, #20]
    CK_ATTRIBUTE dynamic_key_template = {CKA_LABEL, (CK_VOID_PTR)local_template_label, sizeof(local_template_label)};
 8038748:	2303      	movs	r3, #3
 803874a:	9307      	str	r3, [sp, #28]
 803874c:	ab05      	add	r3, sp, #20
 803874e:	9308      	str	r3, [sp, #32]
 8038750:	2308      	movs	r3, #8
 8038752:	9309      	str	r3, [sp, #36]	; 0x24
    switch (keyID)
 8038754:	2804      	cmp	r0, #4
    uint32_t ulCount = 0;
 8038756:	f04f 0300 	mov.w	r3, #0
 803875a:	9304      	str	r3, [sp, #16]
    switch (keyID)
 803875c:	d90b      	bls.n	8038776 <SecureElementDeleteDynamicKeys+0x36>
 803875e:	387f      	subs	r0, #127	; 0x7f
 8038760:	b2c3      	uxtb	r3, r0
 8038762:	2b03      	cmp	r3, #3
 8038764:	d901      	bls.n	803876a <SecureElementDeleteDynamicKeys+0x2a>
 8038766:	2006      	movs	r0, #6
 8038768:	e038      	b.n	80387dc <SecureElementDeleteDynamicKeys+0x9c>
 803876a:	2803      	cmp	r0, #3
 803876c:	d8fb      	bhi.n	8038766 <SecureElementDeleteDynamicKeys+0x26>
 803876e:	e8df f000 	tbb	[pc, r0]
 8038772:	413f      	.short	0x413f
 8038774:	4543      	.short	0x4543
 8038776:	3801      	subs	r0, #1
 8038778:	2803      	cmp	r0, #3
 803877a:	d803      	bhi.n	8038784 <SecureElementDeleteDynamicKeys+0x44>
 803877c:	e8df f000 	tbb	[pc, r0]
 8038780:	36343230 	.word	0x36343230
            *specificLabel = 0x5F505041U;
 8038784:	4b28      	ldr	r3, [pc, #160]	; (8038828 <SecureElementDeleteDynamicKeys+0xe8>)
            *specificLabel = 0x30534E4DU;
 8038786:	9306      	str	r3, [sp, #24]

    if (SECURE_ELEMENT_SUCCESS != GetSpecificLabelByID(keyID, &local_template_label[1]))
    {
        return SECURE_ELEMENT_ERROR;
    }
    *key_label = local_template_label[1];
 8038788:	9b06      	ldr	r3, [sp, #24]
 803878a:	600b      	str	r3, [r1, #0]

    /* Open session with KMS */
    rv = C_OpenSession(0,    session_flags, NULL, 0, &session);
 803878c:	ab03      	add	r3, sp, #12
 803878e:	9300      	str	r3, [sp, #0]
 8038790:	2300      	movs	r3, #0
 8038792:	461a      	mov	r2, r3
 8038794:	2104      	movs	r1, #4
 8038796:	4618      	mov	r0, r3
 8038798:	f7d0 fae0 	bl	8008d5c <SE_KMS_OpenSession>

    /* Search from Template pattern */
    if (rv == CKR_OK)
 803879c:	4604      	mov	r4, r0
 803879e:	b990      	cbnz	r0, 80387c6 <SecureElementDeleteDynamicKeys+0x86>
    {
        rv = C_FindObjectsInit(session, &dynamic_key_template, sizeof(dynamic_key_template) / sizeof(CK_ATTRIBUTE));
 80387a0:	9803      	ldr	r0, [sp, #12]
 80387a2:	2201      	movs	r2, #1
 80387a4:	a907      	add	r1, sp, #28
 80387a6:	f7d0 fb85 	bl	8008eb4 <SE_KMS_FindObjectsInit>
    }

    /* Find all existing keys handle Template pattern */
    if (rv == CKR_OK)
 80387aa:	4604      	mov	r4, r0
 80387ac:	b958      	cbnz	r0, 80387c6 <SecureElementDeleteDynamicKeys+0x86>
    {
        rv = C_FindObjects(session, hObject, NUM_OF_KEYS, (CK_ULONG *) &ulCount);
 80387ae:	9803      	ldr	r0, [sp, #12]
 80387b0:	ab04      	add	r3, sp, #16
 80387b2:	220a      	movs	r2, #10
 80387b4:	a90a      	add	r1, sp, #40	; 0x28
 80387b6:	f7d0 fb99 	bl	8008eec <SE_KMS_FindObjects>
    }

    if (rv == CKR_OK)
 80387ba:	4604      	mov	r4, r0
 80387bc:	b918      	cbnz	r0, 80387c6 <SecureElementDeleteDynamicKeys+0x86>
    {
        rv = C_FindObjectsFinal(session);
 80387be:	9803      	ldr	r0, [sp, #12]
 80387c0:	f7d0 fbb2 	bl	8008f28 <SE_KMS_FindObjectsFinal>
 80387c4:	4604      	mov	r4, r0
    }

    if (ulCount <= NUM_OF_KEYS)
 80387c6:	9b04      	ldr	r3, [sp, #16]
 80387c8:	2b0a      	cmp	r3, #10
 80387ca:	d929      	bls.n	8038820 <SecureElementDeleteDynamicKeys+0xe0>
            }
        }
    }

    /* Close sessions */
    if (session > 0)
 80387cc:	9803      	ldr	r0, [sp, #12]
 80387ce:	b108      	cbz	r0, 80387d4 <SecureElementDeleteDynamicKeys+0x94>
    {
        (void)C_CloseSession(session);
 80387d0:	f7d0 fae4 	bl	8008d9c <SE_KMS_CloseSession>
    }

    if (rv != CKR_OK)
    {
        return SECURE_ELEMENT_ERROR;
 80387d4:	2c00      	cmp	r4, #0
 80387d6:	bf0c      	ite	eq
 80387d8:	2000      	moveq	r0, #0
 80387da:	2006      	movne	r0, #6
    }
    return SECURE_ELEMENT_SUCCESS;
#endif /* LORAWAN_KMS == 1 */
}
 80387dc:	b015      	add	sp, #84	; 0x54
 80387de:	bd30      	pop	{r4, r5, pc}
            *specificLabel = 0x5F4B574EU;
 80387e0:	4b12      	ldr	r3, [pc, #72]	; (803882c <SecureElementDeleteDynamicKeys+0xec>)
 80387e2:	e7d0      	b.n	8038786 <SecureElementDeleteDynamicKeys+0x46>
            *specificLabel = 0x534B574EU;
 80387e4:	4b12      	ldr	r3, [pc, #72]	; (8038830 <SecureElementDeleteDynamicKeys+0xf0>)
 80387e6:	e7ce      	b.n	8038786 <SecureElementDeleteDynamicKeys+0x46>
            *specificLabel = 0x53505041U;
 80387e8:	4b12      	ldr	r3, [pc, #72]	; (8038834 <SecureElementDeleteDynamicKeys+0xf4>)
 80387ea:	e7cc      	b.n	8038786 <SecureElementDeleteDynamicKeys+0x46>
            *specificLabel = 0x5452434DU;
 80387ec:	4b12      	ldr	r3, [pc, #72]	; (8038838 <SecureElementDeleteDynamicKeys+0xf8>)
 80387ee:	e7ca      	b.n	8038786 <SecureElementDeleteDynamicKeys+0x46>
            *specificLabel = 0x454B434DU;
 80387f0:	4b12      	ldr	r3, [pc, #72]	; (803883c <SecureElementDeleteDynamicKeys+0xfc>)
 80387f2:	e7c8      	b.n	8038786 <SecureElementDeleteDynamicKeys+0x46>
            *specificLabel = 0x304B434DU;
 80387f4:	4b12      	ldr	r3, [pc, #72]	; (8038840 <SecureElementDeleteDynamicKeys+0x100>)
 80387f6:	e7c6      	b.n	8038786 <SecureElementDeleteDynamicKeys+0x46>
            *specificLabel = 0x3053414DU;
 80387f8:	4b12      	ldr	r3, [pc, #72]	; (8038844 <SecureElementDeleteDynamicKeys+0x104>)
 80387fa:	e7c4      	b.n	8038786 <SecureElementDeleteDynamicKeys+0x46>
            *specificLabel = 0x30534E4DU;
 80387fc:	4b12      	ldr	r3, [pc, #72]	; (8038848 <SecureElementDeleteDynamicKeys+0x108>)
 80387fe:	e7c2      	b.n	8038786 <SecureElementDeleteDynamicKeys+0x46>
            if (rv == CKR_OK)
 8038800:	b944      	cbnz	r4, 8038814 <SecureElementDeleteDynamicKeys+0xd4>
                rv = C_DestroyObject(session, hObject[i]);
 8038802:	aa14      	add	r2, sp, #80	; 0x50
 8038804:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8038808:	9803      	ldr	r0, [sp, #12]
 803880a:	f853 1c28 	ldr.w	r1, [r3, #-40]
 803880e:	f7d0 fafb 	bl	8008e08 <SE_KMS_DestroyObject>
 8038812:	4604      	mov	r4, r0
        for (uint8_t i = 0; i < ulCount; i++)
 8038814:	3501      	adds	r5, #1
 8038816:	9a04      	ldr	r2, [sp, #16]
 8038818:	b2eb      	uxtb	r3, r5
 803881a:	429a      	cmp	r2, r3
 803881c:	d8f0      	bhi.n	8038800 <SecureElementDeleteDynamicKeys+0xc0>
 803881e:	e7d5      	b.n	80387cc <SecureElementDeleteDynamicKeys+0x8c>
 8038820:	2500      	movs	r5, #0
 8038822:	e7f8      	b.n	8038816 <SecureElementDeleteDynamicKeys+0xd6>
 8038824:	444e524c 	.word	0x444e524c
 8038828:	5f505041 	.word	0x5f505041
 803882c:	5f4b574e 	.word	0x5f4b574e
 8038830:	534b574e 	.word	0x534b574e
 8038834:	53505041 	.word	0x53505041
 8038838:	5452434d 	.word	0x5452434d
 803883c:	454b434d 	.word	0x454b434d
 8038840:	304b434d 	.word	0x304b434d
 8038844:	3053414d 	.word	0x3053414d
 8038848:	30534e4d 	.word	0x30534e4d

0803884c <SecureElementSetObjHandler>:
#if (!defined (LORAWAN_KMS) || (LORAWAN_KMS == 0))
    return SECURE_ELEMENT_ERROR;
#else /* LORAWAN_KMS == 1 */
    for (uint8_t i = 0; i < NUM_OF_KEYS; i++)
    {
        if (SeNvm->KeyList[i].KeyID == keyID)
 803884c:	4b0a      	ldr	r3, [pc, #40]	; (8038878 <SecureElementSetObjHandler+0x2c>)
 803884e:	681a      	ldr	r2, [r3, #0]
{
 8038850:	b5f0      	push	{r4, r5, r6, r7, lr}
        if (SeNvm->KeyList[i].KeyID == keyID)
 8038852:	2300      	movs	r3, #0
 8038854:	f102 0510 	add.w	r5, r2, #16
 8038858:	2618      	movs	r6, #24
 803885a:	fb06 f403 	mul.w	r4, r6, r3
 803885e:	5d2f      	ldrb	r7, [r5, r4]
 8038860:	4287      	cmp	r7, r0
 8038862:	d103      	bne.n	803886c <SecureElementSetObjHandler+0x20>
        {
            SeNvm->KeyList[i].Object_Index = (CK_OBJECT_HANDLE) keyIndex;
 8038864:	4422      	add	r2, r4
            return SECURE_ELEMENT_SUCCESS;
 8038866:	2000      	movs	r0, #0
            SeNvm->KeyList[i].Object_Index = (CK_OBJECT_HANDLE) keyIndex;
 8038868:	6251      	str	r1, [r2, #36]	; 0x24
        }
    }
    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
#endif /* LORAWAN_KMS */
}
 803886a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    for (uint8_t i = 0; i < NUM_OF_KEYS; i++)
 803886c:	3301      	adds	r3, #1
 803886e:	2b0a      	cmp	r3, #10
 8038870:	d1f3      	bne.n	803885a <SecureElementSetObjHandler+0xe>
    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 8038872:	2003      	movs	r0, #3
 8038874:	e7f9      	b.n	803886a <SecureElementSetObjHandler+0x1e>
 8038876:	bf00      	nop
 8038878:	20005738 	.word	0x20005738

0803887c <SecureElementInit>:
{
 803887c:	b510      	push	{r4, lr}
    uint8_t devEUI[SE_EUI_SIZE] = LORAWAN_DEVICE_EUI;
 803887e:	4b4c      	ldr	r3, [pc, #304]	; (80389b0 <SecureElementInit+0x134>)
{
 8038880:	b092      	sub	sp, #72	; 0x48
    uint8_t devEUI[SE_EUI_SIZE] = LORAWAN_DEVICE_EUI;
 8038882:	6859      	ldr	r1, [r3, #4]
{
 8038884:	4602      	mov	r2, r0
    uint8_t devEUI[SE_EUI_SIZE] = LORAWAN_DEVICE_EUI;
 8038886:	6818      	ldr	r0, [r3, #0]
 8038888:	ac04      	add	r4, sp, #16
 803888a:	c403      	stmia	r4!, {r0, r1}
    uint8_t joinEUI[SE_EUI_SIZE] = LORAWAN_JOIN_EUI;
 803888c:	f853 0f08 	ldr.w	r0, [r3, #8]!
 8038890:	6859      	ldr	r1, [r3, #4]
 8038892:	ac06      	add	r4, sp, #24
 8038894:	c403      	stmia	r4!, {r0, r1}
    if (nvm == NULL)
 8038896:	4610      	mov	r0, r2
 8038898:	2a00      	cmp	r2, #0
 803889a:	f000 8087 	beq.w	80389ac <SecureElementInit+0x130>
    SeNvm = nvm;
 803889e:	4c45      	ldr	r4, [pc, #276]	; (80389b4 <SecureElementInit+0x138>)
    memcpy1((uint8_t *)SeNvm->DevEui, devEUI, SE_EUI_SIZE);
 80388a0:	a904      	add	r1, sp, #16
    SeNvm = nvm;
 80388a2:	6022      	str	r2, [r4, #0]
    memcpy1((uint8_t *)SeNvm->DevEui, devEUI, SE_EUI_SIZE);
 80388a4:	2208      	movs	r2, #8
 80388a6:	f000 fb0b 	bl	8038ec0 <memcpy1>
    memcpy1((uint8_t *)SeNvm->JoinEui, joinEUI, SE_EUI_SIZE);
 80388aa:	6820      	ldr	r0, [r4, #0]
 80388ac:	2208      	movs	r2, #8
 80388ae:	4410      	add	r0, r2
 80388b0:	a906      	add	r1, sp, #24
 80388b2:	f000 fb05 	bl	8038ec0 <memcpy1>
    SeNvm->KeyList[itr++].KeyID = APP_KEY;
 80388b6:	6822      	ldr	r2, [r4, #0]
    SeNvm->KeyList[itr++].KeyID = MC_KE_KEY;
 80388b8:	207f      	movs	r0, #127	; 0x7f
 80388ba:	f882 0088 	strb.w	r0, [r2, #136]	; 0x88
    SeNvm->KeyList[itr++].KeyID = NWK_KEY;
 80388be:	2101      	movs	r1, #1
    SeNvm->KeyList[itr++].KeyID = MC_KEY_0;
 80388c0:	2080      	movs	r0, #128	; 0x80
    SeNvm->KeyList[itr++].KeyID = NWK_KEY;
 80388c2:	f882 1028 	strb.w	r1, [r2, #40]	; 0x28
    SeNvm->KeyList[itr++].KeyID = MC_KEY_0;
 80388c6:	f882 00a0 	strb.w	r0, [r2, #160]	; 0xa0
    SeNvm->KeyList[itr++].KeyID = NWK_S_KEY;
 80388ca:	2102      	movs	r1, #2
    SeNvm->KeyList[itr++].KeyID = MC_APP_S_KEY_0;
 80388cc:	2081      	movs	r0, #129	; 0x81
    SeNvm->KeyList[itr++].KeyID = NWK_S_KEY;
 80388ce:	f882 1040 	strb.w	r1, [r2, #64]	; 0x40
    SeNvm->KeyList[itr++].KeyID = MC_APP_S_KEY_0;
 80388d2:	f882 00b8 	strb.w	r0, [r2, #184]	; 0xb8
    SeNvm->KeyList[itr++].KeyID = APP_S_KEY;
 80388d6:	2103      	movs	r1, #3
    SeNvm->KeyList[itr++].KeyID = MC_NWK_S_KEY_0;
 80388d8:	2082      	movs	r0, #130	; 0x82
    SeNvm->KeyList[itr++].KeyID = APP_KEY;
 80388da:	2300      	movs	r3, #0
    SeNvm->KeyList[itr++].KeyID = APP_S_KEY;
 80388dc:	f882 1058 	strb.w	r1, [r2, #88]	; 0x58
    SeNvm->KeyList[itr++].KeyID = MC_NWK_S_KEY_0;
 80388e0:	f882 00d0 	strb.w	r0, [r2, #208]	; 0xd0
    SeNvm->KeyList[itr++].KeyID = MC_ROOT_KEY;
 80388e4:	2104      	movs	r1, #4
    SeNvm->KeyList[itr].KeyID = SLOT_RAND_ZERO_KEY;
 80388e6:	2083      	movs	r0, #131	; 0x83
 80388e8:	f882 00e8 	strb.w	r0, [r2, #232]	; 0xe8
    SeNvm->KeyList[itr++].KeyID = APP_KEY;
 80388ec:	7413      	strb	r3, [r2, #16]
    SeNvm->KeyList[itr++].KeyID = MC_ROOT_KEY;
 80388ee:	f882 1070 	strb.w	r1, [r2, #112]	; 0x70
    rv = C_OpenSession(0,  session_flags, NULL, 0, &session);
 80388f2:	aa02      	add	r2, sp, #8
 80388f4:	9200      	str	r2, [sp, #0]
 80388f6:	4618      	mov	r0, r3
 80388f8:	461a      	mov	r2, r3
    uint32_t ulCount = 0;
 80388fa:	9303      	str	r3, [sp, #12]
    rv = C_OpenSession(0,  session_flags, NULL, 0, &session);
 80388fc:	f7d0 fa2e 	bl	8008d5c <SE_KMS_OpenSession>
    if (rv == CKR_OK)
 8038900:	b978      	cbnz	r0, 8038922 <SecureElementInit+0xa6>
        rv = C_FindObjectsInit(session, NULL, 0);
 8038902:	4602      	mov	r2, r0
 8038904:	4601      	mov	r1, r0
 8038906:	9802      	ldr	r0, [sp, #8]
 8038908:	f7d0 fad4 	bl	8008eb4 <SE_KMS_FindObjectsInit>
    if (rv == CKR_OK)
 803890c:	b948      	cbnz	r0, 8038922 <SecureElementInit+0xa6>
        rv = C_FindObjects(session, hObject, NUM_OF_KEYS, (CK_ULONG *) &ulCount);
 803890e:	9802      	ldr	r0, [sp, #8]
 8038910:	ab03      	add	r3, sp, #12
 8038912:	220a      	movs	r2, #10
 8038914:	a908      	add	r1, sp, #32
 8038916:	f7d0 fae9 	bl	8008eec <SE_KMS_FindObjects>
    if (rv == CKR_OK)
 803891a:	b910      	cbnz	r0, 8038922 <SecureElementInit+0xa6>
        rv = C_FindObjectsFinal(session);
 803891c:	9802      	ldr	r0, [sp, #8]
 803891e:	f7d0 fb03 	bl	8008f28 <SE_KMS_FindObjectsFinal>
    if (ulCount <= NUM_OF_KEYS)
 8038922:	9b03      	ldr	r3, [sp, #12]
 8038924:	2b0a      	cmp	r3, #10
 8038926:	d93f      	bls.n	80389a8 <SecureElementInit+0x12c>
    if (session > 0)
 8038928:	9802      	ldr	r0, [sp, #8]
 803892a:	b108      	cbz	r0, 8038930 <SecureElementInit+0xb4>
        (void)C_CloseSession(session);
 803892c:	f7d0 fa36 	bl	8008d9c <SE_KMS_CloseSession>
    SecureElementSetObjHandler(APP_KEY, KMS_APP_KEY_OBJECT_HANDLE);
 8038930:	210e      	movs	r1, #14
 8038932:	2000      	movs	r0, #0
 8038934:	f7ff ff8a 	bl	803884c <SecureElementSetObjHandler>
    SecureElementSetObjHandler(NWK_KEY, KMS_NWK_KEY_OBJECT_HANDLE);
 8038938:	210f      	movs	r1, #15
 803893a:	2001      	movs	r0, #1
 803893c:	f7ff ff86 	bl	803884c <SecureElementSetObjHandler>
    SecureElementSetObjHandler(APP_S_KEY, KMS_APP_S_KEY_OBJECT_HANDLE);
 8038940:	2111      	movs	r1, #17
 8038942:	2003      	movs	r0, #3
 8038944:	f7ff ff82 	bl	803884c <SecureElementSetObjHandler>
    SecureElementSetObjHandler(NWK_S_KEY, KMS_NWK_S_KEY_OBJECT_HANDLE);
 8038948:	2110      	movs	r1, #16
 803894a:	2002      	movs	r0, #2
 803894c:	f7ff ff7e 	bl	803884c <SecureElementSetObjHandler>
    MW_LOG(TS_OFF, VLEVEL_M, "###### OTAA ######\r\n");
 8038950:	2200      	movs	r2, #0
 8038952:	4611      	mov	r1, r2
 8038954:	4b18      	ldr	r3, [pc, #96]	; (80389b8 <SecureElementInit+0x13c>)
 8038956:	2002      	movs	r0, #2
 8038958:	f002 f998 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
    PrintKey(APP_KEY);
 803895c:	2000      	movs	r0, #0
 803895e:	f7ff fe81 	bl	8038664 <PrintKey>
    PrintKey(NWK_KEY);
 8038962:	2001      	movs	r0, #1
 8038964:	f7ff fe7e 	bl	8038664 <PrintKey>
    MW_LOG(TS_OFF, VLEVEL_M, "###### ABP  ######\r\n");
 8038968:	2200      	movs	r2, #0
 803896a:	4b14      	ldr	r3, [pc, #80]	; (80389bc <SecureElementInit+0x140>)
 803896c:	4611      	mov	r1, r2
 803896e:	2002      	movs	r0, #2
 8038970:	f002 f98c 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
    PrintKey(APP_S_KEY);
 8038974:	2003      	movs	r0, #3
 8038976:	f7ff fe75 	bl	8038664 <PrintKey>
    PrintKey(NWK_S_KEY);
 803897a:	2002      	movs	r0, #2
 803897c:	f7ff fe72 	bl	8038664 <PrintKey>
    return SECURE_ELEMENT_SUCCESS;
 8038980:	2000      	movs	r0, #0
}
 8038982:	b012      	add	sp, #72	; 0x48
 8038984:	bd10      	pop	{r4, pc}
            if (hObject[i] > LAST_KMS_KEY_OBJECT_HANDLE)
 8038986:	aa12      	add	r2, sp, #72	; 0x48
 8038988:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 803898c:	f853 1c28 	ldr.w	r1, [r3, #-40]
 8038990:	2912      	cmp	r1, #18
 8038992:	d903      	bls.n	803899c <SecureElementInit+0x120>
                if (rv == CKR_OK)
 8038994:	b910      	cbnz	r0, 803899c <SecureElementInit+0x120>
                    rv = C_DestroyObject(session, hObject[i]);
 8038996:	9802      	ldr	r0, [sp, #8]
 8038998:	f7d0 fa36 	bl	8008e08 <SE_KMS_DestroyObject>
        for (uint8_t i = 0; i < ulCount; i++)
 803899c:	3401      	adds	r4, #1
 803899e:	9a03      	ldr	r2, [sp, #12]
 80389a0:	b2e3      	uxtb	r3, r4
 80389a2:	4293      	cmp	r3, r2
 80389a4:	d3ef      	bcc.n	8038986 <SecureElementInit+0x10a>
 80389a6:	e7bf      	b.n	8038928 <SecureElementInit+0xac>
 80389a8:	2400      	movs	r4, #0
 80389aa:	e7f8      	b.n	803899e <SecureElementInit+0x122>
        return SECURE_ELEMENT_ERROR_NPE;
 80389ac:	2002      	movs	r0, #2
 80389ae:	e7e8      	b.n	8038982 <SecureElementInit+0x106>
 80389b0:	0803bb6c 	.word	0x0803bb6c
 80389b4:	20005738 	.word	0x20005738
 80389b8:	0803c484 	.word	0x0803c484
 80389bc:	0803c499 	.word	0x0803c499

080389c0 <SecureElementComputeAesCmac>:
#endif /* LORAWAN_KMS */
}

SecureElementStatus_t SecureElementComputeAesCmac( uint8_t* micBxBuffer, uint8_t* buffer, uint16_t size,
                                                   KeyIdentifier_t keyID, uint32_t* cmac )
{
 80389c0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80389c4:	b089      	sub	sp, #36	; 0x24
    if( keyID >= LORAMAC_CRYPTO_MULTICAST_KEYS )
 80389c6:	2b7e      	cmp	r3, #126	; 0x7e
{
 80389c8:	4681      	mov	r9, r0
 80389ca:	9f10      	ldr	r7, [sp, #64]	; 0x40
 80389cc:	4688      	mov	r8, r1
 80389ce:	4616      	mov	r6, r2
 80389d0:	4618      	mov	r0, r3
    if( keyID >= LORAMAC_CRYPTO_MULTICAST_KEYS )
 80389d2:	d851      	bhi.n	8038a78 <SecureElementComputeAesCmac+0xb8>
    if( ( buffer == NULL ) || ( cmac == NULL ) )
 80389d4:	2900      	cmp	r1, #0
 80389d6:	d04d      	beq.n	8038a74 <SecureElementComputeAesCmac+0xb4>
 80389d8:	2f00      	cmp	r7, #0
 80389da:	d04b      	beq.n	8038a74 <SecureElementComputeAesCmac+0xb4>
    uint32_t tag_lenth = 0;
 80389dc:	2300      	movs	r3, #0
    CK_MECHANISM aes_cmac_mechanism = { CKM_AES_CMAC, (CK_VOID_PTR)NULL, 0 };
 80389de:	f241 028a 	movw	r2, #4234	; 0x108a
    SecureElementStatus_t retval = GetKeyIndexByID(keyID, &key_handle);
 80389e2:	a904      	add	r1, sp, #16
    CK_MECHANISM aes_cmac_mechanism = { CKM_AES_CMAC, (CK_VOID_PTR)NULL, 0 };
 80389e4:	e9cd 2305 	strd	r2, r3, [sp, #20]
    uint32_t tag_lenth = 0;
 80389e8:	9303      	str	r3, [sp, #12]
    CK_MECHANISM aes_cmac_mechanism = { CKM_AES_CMAC, (CK_VOID_PTR)NULL, 0 };
 80389ea:	9307      	str	r3, [sp, #28]
    SecureElementStatus_t retval = GetKeyIndexByID(keyID, &key_handle);
 80389ec:	f7ff fdcc 	bl	8038588 <GetKeyIndexByID>
    if (retval != SECURE_ELEMENT_SUCCESS)
 80389f0:	4605      	mov	r5, r0
 80389f2:	2800      	cmp	r0, #0
 80389f4:	d131      	bne.n	8038a5a <SecureElementComputeAesCmac+0x9a>
    rv = C_OpenSession(0,    session_flags, NULL, 0, &session);
 80389f6:	ab02      	add	r3, sp, #8
 80389f8:	9300      	str	r3, [sp, #0]
 80389fa:	4602      	mov	r2, r0
 80389fc:	4603      	mov	r3, r0
 80389fe:	2104      	movs	r1, #4
 8038a00:	f7d0 f9ac 	bl	8008d5c <SE_KMS_OpenSession>
    if (rv == CKR_OK)
 8038a04:	4604      	mov	r4, r0
 8038a06:	b9f0      	cbnz	r0, 8038a46 <SecureElementComputeAesCmac+0x86>
        rv = C_SignInit(session, &aes_cmac_mechanism, key_handle);
 8038a08:	9a04      	ldr	r2, [sp, #16]
 8038a0a:	9802      	ldr	r0, [sp, #8]
 8038a0c:	a905      	add	r1, sp, #20
 8038a0e:	f7d0 fc05 	bl	800921c <SE_KMS_SignInit>
    if (rv == CKR_OK)
 8038a12:	4604      	mov	r4, r0
 8038a14:	b9b8      	cbnz	r0, 8038a46 <SecureElementComputeAesCmac+0x86>
        if (micBxBuffer != NULL)
 8038a16:	ac03      	add	r4, sp, #12
 8038a18:	f1b9 0f00 	cmp.w	r9, #0
 8038a1c:	d021      	beq.n	8038a62 <SecureElementComputeAesCmac+0xa2>
            memcpy1((uint8_t *) &input_align_combined_buf[0], (uint8_t *) micBxBuffer, SE_KEY_SIZE);
 8038a1e:	4817      	ldr	r0, [pc, #92]	; (8038a7c <SecureElementComputeAesCmac+0xbc>)
 8038a20:	2210      	movs	r2, #16
 8038a22:	4649      	mov	r1, r9
 8038a24:	f000 fa4c 	bl	8038ec0 <memcpy1>
            memcpy1((uint8_t *) &input_align_combined_buf[SE_KEY_SIZE], (uint8_t *) buffer, size);
 8038a28:	4632      	mov	r2, r6
 8038a2a:	4815      	ldr	r0, [pc, #84]	; (8038a80 <SecureElementComputeAesCmac+0xc0>)
 8038a2c:	4641      	mov	r1, r8
 8038a2e:	f000 fa47 	bl	8038ec0 <memcpy1>
            rv = C_Sign(session, (CK_BYTE_PTR)&input_align_combined_buf[0], size + SE_KEY_SIZE, &tag[0],
 8038a32:	4b14      	ldr	r3, [pc, #80]	; (8038a84 <SecureElementComputeAesCmac+0xc4>)
 8038a34:	9400      	str	r4, [sp, #0]
 8038a36:	f106 0210 	add.w	r2, r6, #16
            rv = C_Sign(session, (CK_BYTE_PTR)&input_align_combined_buf[0], size, &tag[0],
 8038a3a:	9802      	ldr	r0, [sp, #8]
 8038a3c:	f5a3 7190 	sub.w	r1, r3, #288	; 0x120
 8038a40:	f7d0 fc08 	bl	8009254 <SE_KMS_Sign>
 8038a44:	4604      	mov	r4, r0
    (void)C_CloseSession(session);
 8038a46:	9802      	ldr	r0, [sp, #8]
 8038a48:	f7d0 f9a8 	bl	8008d9c <SE_KMS_CloseSession>
    *cmac = (uint32_t)((uint32_t) tag[3] << 24 | (uint32_t) tag[2] << 16 | (uint32_t) tag[1] << 8 |
 8038a4c:	4b0e      	ldr	r3, [pc, #56]	; (8038a88 <SecureElementComputeAesCmac+0xc8>)
        retval = SECURE_ELEMENT_ERROR;
 8038a4e:	2c00      	cmp	r4, #0
    *cmac = (uint32_t)((uint32_t) tag[3] << 24 | (uint32_t) tag[2] << 16 | (uint32_t) tag[1] << 8 |
 8038a50:	f8d3 3124 	ldr.w	r3, [r3, #292]	; 0x124
 8038a54:	603b      	str	r3, [r7, #0]
        retval = SECURE_ELEMENT_ERROR;
 8038a56:	bf18      	it	ne
 8038a58:	2506      	movne	r5, #6
        // Never accept multicast key identifier for cmac computation
        return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
    }

    return ComputeCmac( micBxBuffer, buffer, size, keyID, cmac );
}
 8038a5a:	4628      	mov	r0, r5
 8038a5c:	b009      	add	sp, #36	; 0x24
 8038a5e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            memcpy1((uint8_t *) &input_align_combined_buf[0], (uint8_t *) buffer, size);
 8038a62:	4632      	mov	r2, r6
 8038a64:	4805      	ldr	r0, [pc, #20]	; (8038a7c <SecureElementComputeAesCmac+0xbc>)
 8038a66:	4641      	mov	r1, r8
 8038a68:	f000 fa2a 	bl	8038ec0 <memcpy1>
            rv = C_Sign(session, (CK_BYTE_PTR)&input_align_combined_buf[0], size, &tag[0],
 8038a6c:	4b05      	ldr	r3, [pc, #20]	; (8038a84 <SecureElementComputeAesCmac+0xc4>)
 8038a6e:	9400      	str	r4, [sp, #0]
 8038a70:	4632      	mov	r2, r6
 8038a72:	e7e2      	b.n	8038a3a <SecureElementComputeAesCmac+0x7a>
        return SECURE_ELEMENT_ERROR_NPE;
 8038a74:	2502      	movs	r5, #2
    return ComputeCmac( micBxBuffer, buffer, size, keyID, cmac );
 8038a76:	e7f0      	b.n	8038a5a <SecureElementComputeAesCmac+0x9a>
        return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 8038a78:	2503      	movs	r5, #3
 8038a7a:	e7ee      	b.n	8038a5a <SecureElementComputeAesCmac+0x9a>
 8038a7c:	2000573c 	.word	0x2000573c
 8038a80:	2000574c 	.word	0x2000574c
 8038a84:	2000585c 	.word	0x2000585c
 8038a88:	20005738 	.word	0x20005738

08038a8c <SecureElementVerifyAesCmac>:

SecureElementStatus_t SecureElementVerifyAesCmac( uint8_t* buffer, uint16_t size, uint32_t expectedCmac,
                                                  KeyIdentifier_t keyID )
{
 8038a8c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8038a8e:	b08b      	sub	sp, #44	; 0x2c
 8038a90:	460e      	mov	r6, r1
 8038a92:	9203      	str	r2, [sp, #12]
    if( buffer == NULL )
 8038a94:	4607      	mov	r7, r0
 8038a96:	2800      	cmp	r0, #0
 8038a98:	d032      	beq.n	8038b00 <SecureElementVerifyAesCmac+0x74>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

    /* AES CMAC Authentication variables */
    CK_MECHANISM aes_cmac_mechanism = { CKM_AES_CMAC, (CK_VOID_PTR)NULL, 0 };
 8038a9a:	2200      	movs	r2, #0
 8038a9c:	f241 018a 	movw	r1, #4234	; 0x108a
 8038aa0:	e9cd 1207 	strd	r1, r2, [sp, #28]

    retval = GetKeyIndexByID(keyID, &object_handle);
 8038aa4:	4618      	mov	r0, r3
 8038aa6:	a906      	add	r1, sp, #24
    CK_MECHANISM aes_cmac_mechanism = { CKM_AES_CMAC, (CK_VOID_PTR)NULL, 0 };
 8038aa8:	9209      	str	r2, [sp, #36]	; 0x24
    retval = GetKeyIndexByID(keyID, &object_handle);
 8038aaa:	f7ff fd6d 	bl	8038588 <GetKeyIndexByID>
    if (retval != SECURE_ELEMENT_SUCCESS)
 8038aae:	4605      	mov	r5, r0
 8038ab0:	bb18      	cbnz	r0, 8038afa <SecureElementVerifyAesCmac+0x6e>
    {
        return retval;
    }

    /* Open session with KMS */
    rv = C_OpenSession(0,    session_flags, NULL, 0, &session);
 8038ab2:	ab05      	add	r3, sp, #20
 8038ab4:	9300      	str	r3, [sp, #0]
 8038ab6:	4602      	mov	r2, r0
 8038ab8:	4603      	mov	r3, r0
 8038aba:	2104      	movs	r1, #4
 8038abc:	f7d0 f94e 	bl	8008d5c <SE_KMS_OpenSession>

    /* Configure session to Verify the message in AES CMAC with settings included into the mechanism */
    if (rv == CKR_OK)
 8038ac0:	4604      	mov	r4, r0
 8038ac2:	b9a0      	cbnz	r0, 8038aee <SecureElementVerifyAesCmac+0x62>
    {
        rv = C_VerifyInit(session, &aes_cmac_mechanism, object_handle);
 8038ac4:	9a06      	ldr	r2, [sp, #24]
 8038ac6:	9805      	ldr	r0, [sp, #20]
 8038ac8:	a907      	add	r1, sp, #28
 8038aca:	f7d0 fbe3 	bl	8009294 <SE_KMS_VerifyInit>
    }

    /* Verify the message */
    if (rv == CKR_OK)
 8038ace:	4604      	mov	r4, r0
 8038ad0:	b968      	cbnz	r0, 8038aee <SecureElementVerifyAesCmac+0x62>
    {
        memcpy1(input_align_combined_buf, buffer, size);
 8038ad2:	480c      	ldr	r0, [pc, #48]	; (8038b04 <SecureElementVerifyAesCmac+0x78>)
 8038ad4:	4632      	mov	r2, r6
 8038ad6:	4639      	mov	r1, r7
 8038ad8:	f000 f9f2 	bl	8038ec0 <memcpy1>
        rv = C_Verify(session, (CK_BYTE_PTR)input_align_combined_buf, size, (CK_BYTE_PTR)&expectedCmac, 4);
 8038adc:	2304      	movs	r3, #4
 8038ade:	9300      	str	r3, [sp, #0]
 8038ae0:	4908      	ldr	r1, [pc, #32]	; (8038b04 <SecureElementVerifyAesCmac+0x78>)
 8038ae2:	9805      	ldr	r0, [sp, #20]
 8038ae4:	ab03      	add	r3, sp, #12
 8038ae6:	4632      	mov	r2, r6
 8038ae8:	f7d0 fbf0 	bl	80092cc <SE_KMS_Verify>
 8038aec:	4604      	mov	r4, r0
    }

    (void)C_CloseSession(session);
 8038aee:	9805      	ldr	r0, [sp, #20]
 8038af0:	f7d0 f954 	bl	8008d9c <SE_KMS_CloseSession>

    if (rv != CKR_OK)
    {
        retval = SECURE_ELEMENT_ERROR;
 8038af4:	2c00      	cmp	r4, #0
 8038af6:	bf18      	it	ne
 8038af8:	2506      	movne	r5, #6
    }

#endif /* LORAWAN_KMS */

    return retval;
}
 8038afa:	4628      	mov	r0, r5
 8038afc:	b00b      	add	sp, #44	; 0x2c
 8038afe:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 8038b00:	2502      	movs	r5, #2
 8038b02:	e7fa      	b.n	8038afa <SecureElementVerifyAesCmac+0x6e>
 8038b04:	2000573c 	.word	0x2000573c

08038b08 <SecureElementAesEncrypt>:

SecureElementStatus_t SecureElementAesEncrypt( uint8_t* buffer, uint16_t size, KeyIdentifier_t keyID,
                                               uint8_t* encBuffer )
{
 8038b08:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8038b0c:	460e      	mov	r6, r1
 8038b0e:	b08e      	sub	sp, #56	; 0x38
 8038b10:	461f      	mov	r7, r3
    if( buffer == NULL || encBuffer == NULL )
 8038b12:	4680      	mov	r8, r0
 8038b14:	2800      	cmp	r0, #0
 8038b16:	d050      	beq.n	8038bba <SecureElementAesEncrypt+0xb2>
 8038b18:	2b00      	cmp	r3, #0
 8038b1a:	d04e      	beq.n	8038bba <SecureElementAesEncrypt+0xb2>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

    // Check if the size is divisible by 16,
    if( ( size % 16 ) != 0 )
 8038b1c:	f011 040f 	ands.w	r4, r1, #15
 8038b20:	d14d      	bne.n	8038bbe <SecureElementAesEncrypt+0xb6>
    uint32_t encrypted_length = 0;
    CK_OBJECT_HANDLE object_handle;
    uint8_t dummy_tag[SE_KEY_SIZE] = {0};
    uint32_t dummy_tag_lenth = 0;

    CK_MECHANISM aes_ecb_mechanism = { CKM_AES_ECB, (CK_VOID_PTR *) NULL, 0 };
 8038b22:	f241 0381 	movw	r3, #4225	; 0x1081

    SecureElementStatus_t retval = GetKeyIndexByID(keyID, &object_handle);
 8038b26:	a905      	add	r1, sp, #20
 8038b28:	4610      	mov	r0, r2
    uint8_t dummy_tag[SE_KEY_SIZE] = {0};
 8038b2a:	e9cd 440a 	strd	r4, r4, [sp, #40]	; 0x28
 8038b2e:	e9cd 440c 	strd	r4, r4, [sp, #48]	; 0x30
    CK_MECHANISM aes_ecb_mechanism = { CKM_AES_ECB, (CK_VOID_PTR *) NULL, 0 };
 8038b32:	e9cd 3407 	strd	r3, r4, [sp, #28]
    uint32_t encrypted_length = 0;
 8038b36:	9404      	str	r4, [sp, #16]
    uint32_t dummy_tag_lenth = 0;
 8038b38:	9406      	str	r4, [sp, #24]
    CK_MECHANISM aes_ecb_mechanism = { CKM_AES_ECB, (CK_VOID_PTR *) NULL, 0 };
 8038b3a:	9409      	str	r4, [sp, #36]	; 0x24
    SecureElementStatus_t retval = GetKeyIndexByID(keyID, &object_handle);
 8038b3c:	f7ff fd24 	bl	8038588 <GetKeyIndexByID>
    if (retval != SECURE_ELEMENT_SUCCESS)
 8038b40:	4605      	mov	r5, r0
 8038b42:	2800      	cmp	r0, #0
 8038b44:	d135      	bne.n	8038bb2 <SecureElementAesEncrypt+0xaa>
    {
        return retval;
    }

    /* Open session with KMS */
    rv = C_OpenSession(0,    session_flags, NULL, 0, &session);
 8038b46:	ab03      	add	r3, sp, #12
 8038b48:	9300      	str	r3, [sp, #0]
 8038b4a:	4602      	mov	r2, r0
 8038b4c:	4603      	mov	r3, r0
 8038b4e:	2104      	movs	r1, #4
 8038b50:	f7d0 f904 	bl	8008d5c <SE_KMS_OpenSession>

    /* Configure session to encrypt message in AES ECB with settings included into the mechanism */
    if (rv == CKR_OK)
 8038b54:	4604      	mov	r4, r0
 8038b56:	bb30      	cbnz	r0, 8038ba6 <SecureElementAesEncrypt+0x9e>
    {
        rv = C_EncryptInit(session, &aes_ecb_mechanism, object_handle);
 8038b58:	9a05      	ldr	r2, [sp, #20]
 8038b5a:	9803      	ldr	r0, [sp, #12]
 8038b5c:	a907      	add	r1, sp, #28
 8038b5e:	f7d0 f9fb 	bl	8008f58 <SE_KMS_EncryptInit>
    }

    /* Encrypt clear message */
    if (rv == CKR_OK)
 8038b62:	4604      	mov	r4, r0
 8038b64:	b9f8      	cbnz	r0, 8038ba6 <SecureElementAesEncrypt+0x9e>
    {
        memcpy1(input_align_combined_buf, buffer, size);
 8038b66:	4817      	ldr	r0, [pc, #92]	; (8038bc4 <SecureElementAesEncrypt+0xbc>)
 8038b68:	4632      	mov	r2, r6
 8038b6a:	4641      	mov	r1, r8
 8038b6c:	f000 f9a8 	bl	8038ec0 <memcpy1>
        encrypted_length = sizeof(output_align);
 8038b70:	f44f 7387 	mov.w	r3, #270	; 0x10e
 8038b74:	9304      	str	r3, [sp, #16]
        rv = C_EncryptUpdate(session, (CK_BYTE_PTR)input_align_combined_buf, size,
 8038b76:	ab04      	add	r3, sp, #16
 8038b78:	9300      	str	r3, [sp, #0]
 8038b7a:	4b13      	ldr	r3, [pc, #76]	; (8038bc8 <SecureElementAesEncrypt+0xc0>)
 8038b7c:	9803      	ldr	r0, [sp, #12]
 8038b7e:	4632      	mov	r2, r6
 8038b80:	f5a3 7198 	sub.w	r1, r3, #304	; 0x130
 8038b84:	f7d0 fa24 	bl	8008fd0 <SE_KMS_EncryptUpdate>
                             output_align, (CK_ULONG_PTR)&encrypted_length);
        memcpy1(encBuffer, output_align, size);
 8038b88:	490f      	ldr	r1, [pc, #60]	; (8038bc8 <SecureElementAesEncrypt+0xc0>)
        rv = C_EncryptUpdate(session, (CK_BYTE_PTR)input_align_combined_buf, size,
 8038b8a:	4604      	mov	r4, r0
        memcpy1(encBuffer, output_align, size);
 8038b8c:	4632      	mov	r2, r6
 8038b8e:	4638      	mov	r0, r7
 8038b90:	f000 f996 	bl	8038ec0 <memcpy1>
    }

    /* In this case C_EncryptFinal is just called to Free the Alloc mem */
    if (rv == CKR_OK)
 8038b94:	b93c      	cbnz	r4, 8038ba6 <SecureElementAesEncrypt+0x9e>
    {
        dummy_tag_lenth = sizeof(tag);
 8038b96:	2310      	movs	r3, #16
        rv = C_EncryptFinal(session, &dummy_tag[0], (CK_ULONG_PTR)&dummy_tag_lenth);
 8038b98:	9803      	ldr	r0, [sp, #12]
        dummy_tag_lenth = sizeof(tag);
 8038b9a:	9306      	str	r3, [sp, #24]
        rv = C_EncryptFinal(session, &dummy_tag[0], (CK_ULONG_PTR)&dummy_tag_lenth);
 8038b9c:	aa06      	add	r2, sp, #24
 8038b9e:	a90a      	add	r1, sp, #40	; 0x28
 8038ba0:	f7d0 fa36 	bl	8009010 <SE_KMS_EncryptFinal>
 8038ba4:	4604      	mov	r4, r0
    }

    /* Close session with KMS */
    (void)C_CloseSession(session);
 8038ba6:	9803      	ldr	r0, [sp, #12]
 8038ba8:	f7d0 f8f8 	bl	8008d9c <SE_KMS_CloseSession>

    if (rv != CKR_OK)
    {
        retval = SECURE_ELEMENT_ERROR;
 8038bac:	2c00      	cmp	r4, #0
 8038bae:	bf18      	it	ne
 8038bb0:	2506      	movne	r5, #6
    }
#endif /* LORAWAN_KMS */

    return retval;
}
 8038bb2:	4628      	mov	r0, r5
 8038bb4:	b00e      	add	sp, #56	; 0x38
 8038bb6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 8038bba:	2502      	movs	r5, #2
 8038bbc:	e7f9      	b.n	8038bb2 <SecureElementAesEncrypt+0xaa>
        return SECURE_ELEMENT_ERROR_BUF_SIZE;
 8038bbe:	2505      	movs	r5, #5
 8038bc0:	e7f7      	b.n	8038bb2 <SecureElementAesEncrypt+0xaa>
 8038bc2:	bf00      	nop
 8038bc4:	2000573c 	.word	0x2000573c
 8038bc8:	2000586c 	.word	0x2000586c

08038bcc <SecureElementSetKey>:
{
 8038bcc:	b570      	push	{r4, r5, r6, lr}
 8038bce:	4606      	mov	r6, r0
 8038bd0:	b0a0      	sub	sp, #128	; 0x80
    if( key == NULL )
 8038bd2:	4608      	mov	r0, r1
 8038bd4:	2900      	cmp	r1, #0
 8038bd6:	d07a      	beq.n	8038cce <SecureElementSetKey+0x102>
    CK_ULONG template_type = CKK_AES;
 8038bd8:	2204      	movs	r2, #4
 8038bda:	231f      	movs	r3, #31
 8038bdc:	e9cd 2304 	strd	r2, r3, [sp, #16]
    CK_ULONG template_true = CK_TRUE;
 8038be0:	680b      	ldr	r3, [r1, #0]
 8038be2:	ba1b      	rev	r3, r3
    uint32_t key_ui32[] =
 8038be4:	9309      	str	r3, [sp, #36]	; 0x24
 8038be6:	684b      	ldr	r3, [r1, #4]
 8038be8:	ba1b      	rev	r3, r3
 8038bea:	930a      	str	r3, [sp, #40]	; 0x28
 8038bec:	688b      	ldr	r3, [r1, #8]
 8038bee:	ba1b      	rev	r3, r3
 8038bf0:	930b      	str	r3, [sp, #44]	; 0x2c
 8038bf2:	68cb      	ldr	r3, [r1, #12]
    uint32_t specific_label[] = {GlobalTemplateLabel, 0UL};
 8038bf4:	4937      	ldr	r1, [pc, #220]	; (8038cd4 <SecureElementSetKey+0x108>)
 8038bf6:	ba1b      	rev	r3, r3
    uint32_t key_ui32[] =
 8038bf8:	930c      	str	r3, [sp, #48]	; 0x30
    uint32_t specific_label[] = {GlobalTemplateLabel, 0UL};
 8038bfa:	2300      	movs	r3, #0
    CK_ULONG template_true = CK_TRUE;
 8038bfc:	2201      	movs	r2, #1
    uint32_t specific_label[] = {GlobalTemplateLabel, 0UL};
 8038bfe:	e9cd 1307 	strd	r1, r3, [sp, #28]
    CK_ATTRIBUTE key_attribute_template[] =
 8038c02:	a904      	add	r1, sp, #16
 8038c04:	e9cd 1212 	strd	r1, r2, [sp, #72]	; 0x48
 8038c08:	f44f 7180 	mov.w	r1, #256	; 0x100
 8038c0c:	9114      	str	r1, [sp, #80]	; 0x50
 8038c0e:	a905      	add	r1, sp, #20
 8038c10:	e9cd 1215 	strd	r1, r2, [sp, #84]	; 0x54
 8038c14:	2111      	movs	r1, #17
 8038c16:	9117      	str	r1, [sp, #92]	; 0x5c
 8038c18:	a909      	add	r1, sp, #36	; 0x24
 8038c1a:	f44f 74b1 	mov.w	r4, #354	; 0x162
 8038c1e:	9118      	str	r1, [sp, #96]	; 0x60
 8038c20:	2110      	movs	r1, #16
 8038c22:	e9cd 1419 	strd	r1, r4, [sp, #100]	; 0x64
 8038c26:	ac06      	add	r4, sp, #24
 8038c28:	e9cd 421b 	strd	r4, r2, [sp, #108]	; 0x6c
    CK_ULONG template_true = CK_TRUE;
 8038c2c:	9206      	str	r2, [sp, #24]
    CK_ATTRIBUTE key_attribute_template[] =
 8038c2e:	2203      	movs	r2, #3
 8038c30:	921d      	str	r2, [sp, #116]	; 0x74
 8038c32:	aa07      	add	r2, sp, #28
 8038c34:	921e      	str	r2, [sp, #120]	; 0x78
    if ( keyID == MC_KEY_0 )
 8038c36:	2e80      	cmp	r6, #128	; 0x80
    CK_ATTRIBUTE key_attribute_template[] =
 8038c38:	f04f 0208 	mov.w	r2, #8
 8038c3c:	9311      	str	r3, [sp, #68]	; 0x44
 8038c3e:	921f      	str	r2, [sp, #124]	; 0x7c
    if ( keyID == MC_KEY_0 )
 8038c40:	d118      	bne.n	8038c74 <SecureElementSetKey+0xa8>
        uint8_t decryptedKey[16] = { 0 };
 8038c42:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
 8038c46:	e9cd 330f 	strd	r3, r3, [sp, #60]	; 0x3c
        if (SECURE_ELEMENT_SUCCESS != SecureElementAesEncrypt( key, 16, MC_KE_KEY, decryptedKey ))
 8038c4a:	227f      	movs	r2, #127	; 0x7f
 8038c4c:	ab0d      	add	r3, sp, #52	; 0x34
 8038c4e:	f7ff ff5b 	bl	8038b08 <SecureElementAesEncrypt>
 8038c52:	b118      	cbz	r0, 8038c5c <SecureElementSetKey+0x90>
        return SECURE_ELEMENT_ERROR;
 8038c54:	2406      	movs	r4, #6
}
 8038c56:	4620      	mov	r0, r4
 8038c58:	b020      	add	sp, #128	; 0x80
 8038c5a:	bd70      	pop	{r4, r5, r6, pc}
        key_ui32[0] = decryptedKey[3]  | (decryptedKey[2] << 8)  | (decryptedKey[1] << 16)  | (decryptedKey[0] << 24);
 8038c5c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8038c5e:	ba1b      	rev	r3, r3
 8038c60:	9309      	str	r3, [sp, #36]	; 0x24
        key_ui32[1] = decryptedKey[7]  | (decryptedKey[6] << 8)  | (decryptedKey[5] << 16)  | (decryptedKey[4] << 24);
 8038c62:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8038c64:	ba1b      	rev	r3, r3
 8038c66:	930a      	str	r3, [sp, #40]	; 0x28
        key_ui32[2] = decryptedKey[11] | (decryptedKey[10] << 8) | (decryptedKey[9] << 16)  | (decryptedKey[8] << 24);
 8038c68:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8038c6a:	ba1b      	rev	r3, r3
 8038c6c:	930b      	str	r3, [sp, #44]	; 0x2c
        key_ui32[3] = decryptedKey[15] | (decryptedKey[14] << 8) | (decryptedKey[13] << 16) | (decryptedKey[12] << 24);
 8038c6e:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8038c70:	ba1b      	rev	r3, r3
 8038c72:	930c      	str	r3, [sp, #48]	; 0x30
    if (SECURE_ELEMENT_SUCCESS != GetKeyIndexByID(keyID, &key_handle))
 8038c74:	a90d      	add	r1, sp, #52	; 0x34
 8038c76:	4630      	mov	r0, r6
 8038c78:	f7ff fc86 	bl	8038588 <GetKeyIndexByID>
 8038c7c:	2800      	cmp	r0, #0
 8038c7e:	d1e9      	bne.n	8038c54 <SecureElementSetKey+0x88>
    if (SECURE_ELEMENT_SUCCESS != SecureElementDeleteDynamicKeys(keyID, &specific_label[1]))
 8038c80:	a908      	add	r1, sp, #32
 8038c82:	4630      	mov	r0, r6
 8038c84:	f7ff fd5c 	bl	8038740 <SecureElementDeleteDynamicKeys>
 8038c88:	4603      	mov	r3, r0
 8038c8a:	2800      	cmp	r0, #0
 8038c8c:	d1e2      	bne.n	8038c54 <SecureElementSetKey+0x88>
    rv = C_OpenSession(0, session_flags, NULL, 0, &session);
 8038c8e:	aa03      	add	r2, sp, #12
 8038c90:	9200      	str	r2, [sp, #0]
 8038c92:	2104      	movs	r1, #4
 8038c94:	4602      	mov	r2, r0
 8038c96:	f7d0 f861 	bl	8008d5c <SE_KMS_OpenSession>
    if (rv == CKR_OK)
 8038c9a:	4605      	mov	r5, r0
 8038c9c:	b9a8      	cbnz	r0, 8038cca <SecureElementSetKey+0xfe>
        rv = C_CreateObject(session, key_attribute_template, sizeof(key_attribute_template) / sizeof(CK_ATTRIBUTE),
 8038c9e:	9803      	ldr	r0, [sp, #12]
 8038ca0:	ab0d      	add	r3, sp, #52	; 0x34
 8038ca2:	2205      	movs	r2, #5
 8038ca4:	a911      	add	r1, sp, #68	; 0x44
 8038ca6:	f7d0 f891 	bl	8008dcc <SE_KMS_CreateObject>
    if (rv == CKR_OK)
 8038caa:	4605      	mov	r5, r0
 8038cac:	b968      	cbnz	r0, 8038cca <SecureElementSetKey+0xfe>
        retval = SecureElementSetObjHandler(keyID, key_handle);
 8038cae:	990d      	ldr	r1, [sp, #52]	; 0x34
 8038cb0:	4630      	mov	r0, r6
 8038cb2:	f7ff fdcb 	bl	803884c <SecureElementSetObjHandler>
 8038cb6:	4604      	mov	r4, r0
    PrintKey(keyID);
 8038cb8:	4630      	mov	r0, r6
 8038cba:	f7ff fcd3 	bl	8038664 <PrintKey>
    (void)C_CloseSession(session);
 8038cbe:	9803      	ldr	r0, [sp, #12]
 8038cc0:	f7d0 f86c 	bl	8008d9c <SE_KMS_CloseSession>
    if (rv != CKR_OK)
 8038cc4:	2d00      	cmp	r5, #0
 8038cc6:	d0c6      	beq.n	8038c56 <SecureElementSetKey+0x8a>
 8038cc8:	e7c4      	b.n	8038c54 <SecureElementSetKey+0x88>
    SecureElementStatus_t retval = SECURE_ELEMENT_ERROR;
 8038cca:	2406      	movs	r4, #6
 8038ccc:	e7f4      	b.n	8038cb8 <SecureElementSetKey+0xec>
        return SECURE_ELEMENT_ERROR_NPE;
 8038cce:	2402      	movs	r4, #2
 8038cd0:	e7c1      	b.n	8038c56 <SecureElementSetKey+0x8a>
 8038cd2:	bf00      	nop
 8038cd4:	444e524c 	.word	0x444e524c

08038cd8 <SecureElementDeriveAndStoreKey>:

SecureElementStatus_t SecureElementDeriveAndStoreKey( uint8_t* input, KeyIdentifier_t rootKeyID,
                                                      KeyIdentifier_t targetKeyID )
{
 8038cd8:	b570      	push	{r4, r5, r6, lr}
 8038cda:	460b      	mov	r3, r1
 8038cdc:	b08e      	sub	sp, #56	; 0x38
 8038cde:	4616      	mov	r6, r2
    if( input == NULL )
 8038ce0:	2800      	cmp	r0, #0
 8038ce2:	d049      	beq.n	8038d78 <SecureElementDeriveAndStoreKey+0xa0>
    }

    SecureElementStatus_t retval  = SECURE_ELEMENT_ERROR;

    // In case of MC_KE_KEY, only McRootKey can be used as root key
    if( targetKeyID == MC_KE_KEY )
 8038ce4:	2a7f      	cmp	r2, #127	; 0x7f
 8038ce6:	d101      	bne.n	8038cec <SecureElementDeriveAndStoreKey+0x14>
    {
        if( rootKeyID != MC_ROOT_KEY )
 8038ce8:	2904      	cmp	r1, #4
 8038cea:	d147      	bne.n	8038d7c <SecureElementDeriveAndStoreKey+0xa4>
#else /* LORAWAN_KMS == 1 */
    CK_RV rv;
    CK_SESSION_HANDLE session;
    CK_FLAGS session_flags = CKF_SERIAL_SESSION;    /* Read ONLY session */
    /* Key derivation */
    CK_MECHANISM            mech = {CKM_AES_ECB_ENCRYPT_DATA, input, SE_KEY_SIZE};
 8038cec:	f241 1204 	movw	r2, #4356	; 0x1104
 8038cf0:	e9cd 2008 	strd	r2, r0, [sp, #32]
    CK_OBJECT_HANDLE  derived_object_handle;
    CK_OBJECT_HANDLE    rootkey_object_handle;
    uint32_t specific_label[] = {GlobalTemplateLabel, 0UL};
 8038cf4:	4822      	ldr	r0, [pc, #136]	; (8038d80 <SecureElementDeriveAndStoreKey+0xa8>)
    CK_MECHANISM            mech = {CKM_AES_ECB_ENCRYPT_DATA, input, SE_KEY_SIZE};
 8038cf6:	2210      	movs	r2, #16
 8038cf8:	920a      	str	r2, [sp, #40]	; 0x28
    uint32_t specific_label[] = {GlobalTemplateLabel, 0UL};
 8038cfa:	2200      	movs	r2, #0
 8038cfc:	e9cd 0206 	strd	r0, r2, [sp, #24]
    CK_ATTRIBUTE DeriveKey_template = {CKA_LABEL, (CK_VOID_PTR)specific_label, sizeof(specific_label)};
 8038d00:	2203      	movs	r2, #3
 8038d02:	920b      	str	r2, [sp, #44]	; 0x2c
 8038d04:	aa06      	add	r2, sp, #24
 8038d06:	920c      	str	r2, [sp, #48]	; 0x30

    /* Derive key */
    if (SECURE_ELEMENT_SUCCESS != GetKeyIndexByID(rootKeyID, &rootkey_object_handle))
 8038d08:	a905      	add	r1, sp, #20
    CK_ATTRIBUTE DeriveKey_template = {CKA_LABEL, (CK_VOID_PTR)specific_label, sizeof(specific_label)};
 8038d0a:	2208      	movs	r2, #8
    if (SECURE_ELEMENT_SUCCESS != GetKeyIndexByID(rootKeyID, &rootkey_object_handle))
 8038d0c:	4618      	mov	r0, r3
    CK_ATTRIBUTE DeriveKey_template = {CKA_LABEL, (CK_VOID_PTR)specific_label, sizeof(specific_label)};
 8038d0e:	920d      	str	r2, [sp, #52]	; 0x34
    if (SECURE_ELEMENT_SUCCESS != GetKeyIndexByID(rootKeyID, &rootkey_object_handle))
 8038d10:	f7ff fc3a 	bl	8038588 <GetKeyIndexByID>
 8038d14:	bb50      	cbnz	r0, 8038d6c <SecureElementDeriveAndStoreKey+0x94>
    {
        return SECURE_ELEMENT_ERROR;
    }

    if (SECURE_ELEMENT_SUCCESS != GetKeyIndexByID(targetKeyID, &derived_object_handle))
 8038d16:	ac04      	add	r4, sp, #16
 8038d18:	4621      	mov	r1, r4
 8038d1a:	4630      	mov	r0, r6
 8038d1c:	f7ff fc34 	bl	8038588 <GetKeyIndexByID>
 8038d20:	bb20      	cbnz	r0, 8038d6c <SecureElementDeriveAndStoreKey+0x94>
    {
        return SECURE_ELEMENT_ERROR;
    }

    if (SECURE_ELEMENT_SUCCESS != SecureElementDeleteDynamicKeys(targetKeyID, &specific_label[1]))
 8038d22:	a907      	add	r1, sp, #28
 8038d24:	4630      	mov	r0, r6
 8038d26:	f7ff fd0b 	bl	8038740 <SecureElementDeleteDynamicKeys>
 8038d2a:	4603      	mov	r3, r0
 8038d2c:	b9f0      	cbnz	r0, 8038d6c <SecureElementDeriveAndStoreKey+0x94>
    {
        return SECURE_ELEMENT_ERROR;
    }

    /* Open session with KMS */
    rv = C_OpenSession(0,    session_flags, NULL, 0, &session);
 8038d2e:	aa03      	add	r2, sp, #12
 8038d30:	9200      	str	r2, [sp, #0]
 8038d32:	2104      	movs	r1, #4
 8038d34:	4602      	mov	r2, r0
 8038d36:	f7d0 f811 	bl	8008d5c <SE_KMS_OpenSession>

    /* Derive key with pass phrase */
    if (rv == CKR_OK)
 8038d3a:	4605      	mov	r5, r0
 8038d3c:	b9d0      	cbnz	r0, 8038d74 <SecureElementDeriveAndStoreKey+0x9c>
    {
        rv = C_DeriveKey(session, &(mech), rootkey_object_handle,
 8038d3e:	2301      	movs	r3, #1
 8038d40:	9300      	str	r3, [sp, #0]
 8038d42:	9a05      	ldr	r2, [sp, #20]
 8038d44:	9803      	ldr	r0, [sp, #12]
 8038d46:	9401      	str	r4, [sp, #4]
 8038d48:	ab0b      	add	r3, sp, #44	; 0x2c
 8038d4a:	a908      	add	r1, sp, #32
 8038d4c:	f7d0 fade 	bl	800930c <SE_KMS_DeriveKey>
                         &DeriveKey_template, sizeof(DeriveKey_template) / sizeof(CK_ATTRIBUTE), &derived_object_handle);
    }

    if (rv == CKR_OK)
 8038d50:	4605      	mov	r5, r0
 8038d52:	b978      	cbnz	r0, 8038d74 <SecureElementDeriveAndStoreKey+0x9c>
    {
        /* Store Derived Index in table */
        retval = SecureElementSetObjHandler(targetKeyID, derived_object_handle);
 8038d54:	9904      	ldr	r1, [sp, #16]
 8038d56:	4630      	mov	r0, r6
 8038d58:	f7ff fd78 	bl	803884c <SecureElementSetObjHandler>
 8038d5c:	4604      	mov	r4, r0
    }

    PrintKey(targetKeyID);
 8038d5e:	4630      	mov	r0, r6
 8038d60:	f7ff fc80 	bl	8038664 <PrintKey>

    /* Close session with KMS */
    (void)C_CloseSession(session);
 8038d64:	9803      	ldr	r0, [sp, #12]
 8038d66:	f7d0 f819 	bl	8008d9c <SE_KMS_CloseSession>

    if (rv != CKR_OK)
 8038d6a:	b105      	cbz	r5, 8038d6e <SecureElementDeriveAndStoreKey+0x96>
    {
        retval = SECURE_ELEMENT_ERROR;
 8038d6c:	2406      	movs	r4, #6
    }
    return retval;
#endif /* LORAWAN_KMS */
}
 8038d6e:	4620      	mov	r0, r4
 8038d70:	b00e      	add	sp, #56	; 0x38
 8038d72:	bd70      	pop	{r4, r5, r6, pc}
    SecureElementStatus_t retval  = SECURE_ELEMENT_ERROR;
 8038d74:	2406      	movs	r4, #6
 8038d76:	e7f2      	b.n	8038d5e <SecureElementDeriveAndStoreKey+0x86>
        return SECURE_ELEMENT_ERROR_NPE;
 8038d78:	2402      	movs	r4, #2
 8038d7a:	e7f8      	b.n	8038d6e <SecureElementDeriveAndStoreKey+0x96>
            return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 8038d7c:	2403      	movs	r4, #3
 8038d7e:	e7f6      	b.n	8038d6e <SecureElementDeriveAndStoreKey+0x96>
 8038d80:	444e524c 	.word	0x444e524c

08038d84 <SecureElementProcessJoinAccept>:

SecureElementStatus_t SecureElementProcessJoinAccept( JoinReqIdentifier_t joinReqType, uint8_t* joinEui,
                                                      uint16_t devNonce, uint8_t* encJoinAccept,
                                                      uint8_t encJoinAcceptSize, uint8_t* decJoinAccept,
                                                      uint8_t* versionMinor )
{
 8038d84:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if( ( encJoinAccept == NULL ) || ( decJoinAccept == NULL ) || ( versionMinor == NULL ) )
 8038d88:	461f      	mov	r7, r3
{
 8038d8a:	e9dd 5807 	ldrd	r5, r8, [sp, #28]
 8038d8e:	f89d 4018 	ldrb.w	r4, [sp, #24]
    if( ( encJoinAccept == NULL ) || ( decJoinAccept == NULL ) || ( versionMinor == NULL ) )
 8038d92:	b393      	cbz	r3, 8038dfa <SecureElementProcessJoinAccept+0x76>
 8038d94:	b38d      	cbz	r5, 8038dfa <SecureElementProcessJoinAccept+0x76>
 8038d96:	f1b8 0f00 	cmp.w	r8, #0
 8038d9a:	d02e      	beq.n	8038dfa <SecureElementProcessJoinAccept+0x76>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

    // Check that frame size isn't bigger than a JoinAccept with CFList size
    if( encJoinAcceptSize > LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE )
 8038d9c:	2c21      	cmp	r4, #33	; 0x21
 8038d9e:	d82e      	bhi.n	8038dfe <SecureElementProcessJoinAccept+0x7a>
    {
        encKeyID = J_S_ENC_KEY;
    }
#endif /* USE_LRWAN_1_1_X_CRYPTO == 1 */

    memcpy1( decJoinAccept, encJoinAccept, encJoinAcceptSize );
 8038da0:	b2a6      	uxth	r6, r4
 8038da2:	4619      	mov	r1, r3
 8038da4:	4632      	mov	r2, r6
 8038da6:	4628      	mov	r0, r5
 8038da8:	f000 f88a 	bl	8038ec0 <memcpy1>

    // Decrypt JoinAccept, skip MHDR
    if( SecureElementAesEncrypt( encJoinAccept + LORAMAC_MHDR_FIELD_SIZE, encJoinAcceptSize - LORAMAC_MHDR_FIELD_SIZE,
 8038dac:	1e71      	subs	r1, r6, #1
 8038dae:	2201      	movs	r2, #1
 8038db0:	1c6b      	adds	r3, r5, #1
 8038db2:	b289      	uxth	r1, r1
 8038db4:	18b8      	adds	r0, r7, r2
 8038db6:	f7ff fea7 	bl	8038b08 <SecureElementAesEncrypt>
 8038dba:	bb10      	cbnz	r0, 8038e02 <SecureElementProcessJoinAccept+0x7e>
                                 encKeyID, decJoinAccept + LORAMAC_MHDR_FIELD_SIZE ) != SECURE_ELEMENT_SUCCESS )
    {
        return SECURE_ELEMENT_FAIL_ENCRYPT;
    }

    *versionMinor = ( ( decJoinAccept[11] & 0x80 ) == 0x80 ) ? 1 : 0;
 8038dbc:	7aeb      	ldrb	r3, [r5, #11]
 8038dbe:	09db      	lsrs	r3, r3, #7
 8038dc0:	f888 3000 	strb.w	r3, [r8]
    //  - Header buffer to be used for MIC computation
    //        - LoRaWAN 1.0.x : micHeader = [MHDR(1)]
    //        - LoRaWAN 1.1.x : micHeader = [JoinReqType(1), JoinEUI(8), DevNonce(2), MHDR(1)]

    // Verify mic
    if( *versionMinor == 0 )
 8038dc4:	b9fb      	cbnz	r3, 8038e06 <SecureElementProcessJoinAccept+0x82>
    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 2] << 16 );
 8038dc6:	192b      	adds	r3, r5, r4
    {
        // For LoRaWAN 1.0.x
        //   cmac = aes128_cmac(NwkKey, MHDR |  JoinNonce | NetID | DevAddr | DLSettings | RxDelay | CFList |
        //   CFListType)
        if( SecureElementVerifyAesCmac( decJoinAccept, ( encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE ), mic, NWK_KEY ) !=
 8038dc8:	1f31      	subs	r1, r6, #4
    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 3] << 24 );
 8038dca:	f813 0c01 	ldrb.w	r0, [r3, #-1]
    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 2] << 16 );
 8038dce:	f813 2c02 	ldrb.w	r2, [r3, #-2]
    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 3] << 24 );
 8038dd2:	0600      	lsls	r0, r0, #24
 8038dd4:	ea40 4002 	orr.w	r0, r0, r2, lsl #16
    mic = ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE] << 0 );
 8038dd8:	f813 2c04 	ldrb.w	r2, [r3, #-4]
 8038ddc:	4310      	orrs	r0, r2
    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 1] << 8 );
 8038dde:	f813 2c03 	ldrb.w	r2, [r3, #-3]
        if( SecureElementVerifyAesCmac( decJoinAccept, ( encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE ), mic, NWK_KEY ) !=
 8038de2:	b289      	uxth	r1, r1
 8038de4:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
 8038de8:	2301      	movs	r3, #1
 8038dea:	4628      	mov	r0, r5
 8038dec:	f7ff fe4e 	bl	8038a8c <SecureElementVerifyAesCmac>
        return SECURE_ELEMENT_ERROR_NPE;
 8038df0:	3800      	subs	r0, #0
 8038df2:	bf18      	it	ne
 8038df4:	2001      	movne	r0, #1
    {
        return SECURE_ELEMENT_ERROR_INVALID_LORAWAM_SPEC_VERSION;
    }

    return SECURE_ELEMENT_SUCCESS;
}
 8038df6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 8038dfa:	2002      	movs	r0, #2
 8038dfc:	e7fb      	b.n	8038df6 <SecureElementProcessJoinAccept+0x72>
        return SECURE_ELEMENT_ERROR_BUF_SIZE;
 8038dfe:	2005      	movs	r0, #5
 8038e00:	e7f9      	b.n	8038df6 <SecureElementProcessJoinAccept+0x72>
        return SECURE_ELEMENT_FAIL_ENCRYPT;
 8038e02:	2007      	movs	r0, #7
 8038e04:	e7f7      	b.n	8038df6 <SecureElementProcessJoinAccept+0x72>
        return SECURE_ELEMENT_ERROR_INVALID_LORAWAM_SPEC_VERSION;
 8038e06:	2004      	movs	r0, #4
 8038e08:	e7f5      	b.n	8038df6 <SecureElementProcessJoinAccept+0x72>
	...

08038e0c <SecureElementRandomNumber>:

SecureElementStatus_t SecureElementRandomNumber( uint32_t* randomNum )
{
 8038e0c:	b510      	push	{r4, lr}
    if( randomNum == NULL )
 8038e0e:	4604      	mov	r4, r0
 8038e10:	b128      	cbz	r0, 8038e1e <SecureElementRandomNumber+0x12>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }
    *randomNum = Radio.Random();
 8038e12:	4b04      	ldr	r3, [pc, #16]	; (8038e24 <SecureElementRandomNumber+0x18>)
 8038e14:	695b      	ldr	r3, [r3, #20]
 8038e16:	4798      	blx	r3
 8038e18:	6020      	str	r0, [r4, #0]
    return SECURE_ELEMENT_SUCCESS;
 8038e1a:	2000      	movs	r0, #0
}
 8038e1c:	bd10      	pop	{r4, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 8038e1e:	2002      	movs	r0, #2
 8038e20:	e7fc      	b.n	8038e1c <SecureElementRandomNumber+0x10>
 8038e22:	bf00      	nop
 8038e24:	0803bbc0 	.word	0x0803bbc0

08038e28 <SecureElementSetDevEui>:

SecureElementStatus_t SecureElementSetDevEui( uint8_t* devEui )
{
 8038e28:	b508      	push	{r3, lr}
    if( devEui == NULL )
 8038e2a:	4601      	mov	r1, r0
 8038e2c:	b130      	cbz	r0, 8038e3c <SecureElementSetDevEui+0x14>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }
    memcpy1( SeNvm->DevEui, devEui, SE_EUI_SIZE );
 8038e2e:	4b04      	ldr	r3, [pc, #16]	; (8038e40 <SecureElementSetDevEui+0x18>)
 8038e30:	2208      	movs	r2, #8
 8038e32:	6818      	ldr	r0, [r3, #0]
 8038e34:	f000 f844 	bl	8038ec0 <memcpy1>
    return SECURE_ELEMENT_SUCCESS;
 8038e38:	2000      	movs	r0, #0
}
 8038e3a:	bd08      	pop	{r3, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 8038e3c:	2002      	movs	r0, #2
 8038e3e:	e7fc      	b.n	8038e3a <SecureElementSetDevEui+0x12>
 8038e40:	20005738 	.word	0x20005738

08038e44 <SecureElementGetDevEui>:

uint8_t* SecureElementGetDevEui( void )
{
    return SeNvm->DevEui;
}
 8038e44:	4b01      	ldr	r3, [pc, #4]	; (8038e4c <SecureElementGetDevEui+0x8>)
 8038e46:	6818      	ldr	r0, [r3, #0]
 8038e48:	4770      	bx	lr
 8038e4a:	bf00      	nop
 8038e4c:	20005738 	.word	0x20005738

08038e50 <SecureElementSetJoinEui>:

SecureElementStatus_t SecureElementSetJoinEui( uint8_t* joinEui )
{
 8038e50:	b508      	push	{r3, lr}
    if( joinEui == NULL )
 8038e52:	4601      	mov	r1, r0
 8038e54:	b138      	cbz	r0, 8038e66 <SecureElementSetJoinEui+0x16>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }
    memcpy1( SeNvm->JoinEui, joinEui, SE_EUI_SIZE );
 8038e56:	4b05      	ldr	r3, [pc, #20]	; (8038e6c <SecureElementSetJoinEui+0x1c>)
 8038e58:	6818      	ldr	r0, [r3, #0]
 8038e5a:	2208      	movs	r2, #8
 8038e5c:	4410      	add	r0, r2
 8038e5e:	f000 f82f 	bl	8038ec0 <memcpy1>
    return SECURE_ELEMENT_SUCCESS;
 8038e62:	2000      	movs	r0, #0
}
 8038e64:	bd08      	pop	{r3, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 8038e66:	2002      	movs	r0, #2
 8038e68:	e7fc      	b.n	8038e64 <SecureElementSetJoinEui+0x14>
 8038e6a:	bf00      	nop
 8038e6c:	20005738 	.word	0x20005738

08038e70 <SecureElementGetJoinEui>:

uint8_t* SecureElementGetJoinEui( void )
{
    return SeNvm->JoinEui;
 8038e70:	4b01      	ldr	r3, [pc, #4]	; (8038e78 <SecureElementGetJoinEui+0x8>)
 8038e72:	6818      	ldr	r0, [r3, #0]
}
 8038e74:	3008      	adds	r0, #8
 8038e76:	4770      	bx	lr
 8038e78:	20005738 	.word	0x20005738

08038e7c <srand1>:
    return ( ( next = next * 1103515245L + 12345L ) % RAND_LOCAL_MAX );
}

void srand1( uint32_t seed )
{
    next = seed;
 8038e7c:	4b01      	ldr	r3, [pc, #4]	; (8038e84 <srand1+0x8>)
 8038e7e:	6018      	str	r0, [r3, #0]
}
 8038e80:	4770      	bx	lr
 8038e82:	bf00      	nop
 8038e84:	2000359c 	.word	0x2000359c

08038e88 <randr>:
    return ( ( next = next * 1103515245L + 12345L ) % RAND_LOCAL_MAX );
 8038e88:	4a0b      	ldr	r2, [pc, #44]	; (8038eb8 <randr+0x30>)
// Standard random functions redefinition end

int32_t randr( int32_t min, int32_t max )
{
 8038e8a:	b530      	push	{r4, r5, lr}
    return ( ( next = next * 1103515245L + 12345L ) % RAND_LOCAL_MAX );
 8038e8c:	6813      	ldr	r3, [r2, #0]
 8038e8e:	4d0b      	ldr	r5, [pc, #44]	; (8038ebc <randr+0x34>)
 8038e90:	f243 0439 	movw	r4, #12345	; 0x3039
 8038e94:	fb05 4303 	mla	r3, r5, r3, r4
 8038e98:	6013      	str	r3, [r2, #0]
    return ( int32_t )rand1( ) % ( max - min + 1 ) + min;
 8038e9a:	1a09      	subs	r1, r1, r0
    return ( ( next = next * 1103515245L + 12345L ) % RAND_LOCAL_MAX );
 8038e9c:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
 8038ea0:	fbb3 f2f2 	udiv	r2, r3, r2
 8038ea4:	ebc2 72c2 	rsb	r2, r2, r2, lsl #31
    return ( int32_t )rand1( ) % ( max - min + 1 ) + min;
 8038ea8:	3101      	adds	r1, #1
    return ( ( next = next * 1103515245L + 12345L ) % RAND_LOCAL_MAX );
 8038eaa:	1a9b      	subs	r3, r3, r2
    return ( int32_t )rand1( ) % ( max - min + 1 ) + min;
 8038eac:	fb93 f2f1 	sdiv	r2, r3, r1
 8038eb0:	fb01 3312 	mls	r3, r1, r2, r3
}
 8038eb4:	4418      	add	r0, r3
 8038eb6:	bd30      	pop	{r4, r5, pc}
 8038eb8:	2000359c 	.word	0x2000359c
 8038ebc:	41c64e6d 	.word	0x41c64e6d

08038ec0 <memcpy1>:

void memcpy1( uint8_t *dst, const uint8_t *src, uint16_t size )
{
    while( size-- )
 8038ec0:	3801      	subs	r0, #1
 8038ec2:	440a      	add	r2, r1
 8038ec4:	4291      	cmp	r1, r2
 8038ec6:	d100      	bne.n	8038eca <memcpy1+0xa>
    {
        *dst++ = *src++;
    }
}
 8038ec8:	4770      	bx	lr
        *dst++ = *src++;
 8038eca:	f811 3b01 	ldrb.w	r3, [r1], #1
 8038ece:	f800 3f01 	strb.w	r3, [r0, #1]!
 8038ed2:	e7f7      	b.n	8038ec4 <memcpy1+0x4>

08038ed4 <memcpyr>:

void memcpyr( uint8_t *dst, const uint8_t *src, uint16_t size )
{
    dst = dst + ( size - 1 );
    while( size-- )
 8038ed4:	4410      	add	r0, r2
 8038ed6:	440a      	add	r2, r1
 8038ed8:	4291      	cmp	r1, r2
 8038eda:	d100      	bne.n	8038ede <memcpyr+0xa>
    {
        *dst-- = *src++;
    }
}
 8038edc:	4770      	bx	lr
        *dst-- = *src++;
 8038ede:	f811 3b01 	ldrb.w	r3, [r1], #1
 8038ee2:	f800 3d01 	strb.w	r3, [r0, #-1]!
 8038ee6:	e7f7      	b.n	8038ed8 <memcpyr+0x4>

08038ee8 <memset1>:

void memset1( uint8_t *dst, uint8_t value, uint16_t size )
{
    while( size-- )
 8038ee8:	4402      	add	r2, r0
 8038eea:	4290      	cmp	r0, r2
 8038eec:	d100      	bne.n	8038ef0 <memset1+0x8>
    {
        *dst++ = value;
    }
}
 8038eee:	4770      	bx	lr
        *dst++ = value;
 8038ef0:	f800 1b01 	strb.w	r1, [r0], #1
 8038ef4:	e7f9      	b.n	8038eea <memset1+0x2>
	...

08038ef8 <Crc32>:
        return '?';
    }
}

uint32_t Crc32( uint8_t *buffer, uint16_t length )
{
 8038ef8:	b530      	push	{r4, r5, lr}
    const uint32_t reversedPolynom = 0xEDB88320;

    // CRC initial value
    uint32_t crc = 0xFFFFFFFF;

    if( buffer == NULL )
 8038efa:	b130      	cbz	r0, 8038f0a <Crc32+0x12>
    for( uint16_t i = 0; i < length; ++i )
    {
        crc ^= ( uint32_t )buffer[i];
        for( uint16_t i = 0; i < 8; i++ )
        {
            crc = ( crc >> 1 ) ^ ( reversedPolynom & ~( ( crc & 0x01 ) - 1 ) );
 8038efc:	4d0a      	ldr	r5, [pc, #40]	; (8038f28 <Crc32+0x30>)
 8038efe:	4401      	add	r1, r0
    uint32_t crc = 0xFFFFFFFF;
 8038f00:	f04f 33ff 	mov.w	r3, #4294967295
    for( uint16_t i = 0; i < length; ++i )
 8038f04:	4281      	cmp	r1, r0
 8038f06:	d101      	bne.n	8038f0c <Crc32+0x14>
        }
    }

    return ~crc;
 8038f08:	43d8      	mvns	r0, r3
}
 8038f0a:	bd30      	pop	{r4, r5, pc}
        crc ^= ( uint32_t )buffer[i];
 8038f0c:	f810 2b01 	ldrb.w	r2, [r0], #1
 8038f10:	4053      	eors	r3, r2
 8038f12:	2208      	movs	r2, #8
            crc = ( crc >> 1 ) ^ ( reversedPolynom & ~( ( crc & 0x01 ) - 1 ) );
 8038f14:	f343 0400 	sbfx	r4, r3, #0, #1
 8038f18:	3a01      	subs	r2, #1
 8038f1a:	402c      	ands	r4, r5
 8038f1c:	b292      	uxth	r2, r2
 8038f1e:	ea84 0353 	eor.w	r3, r4, r3, lsr #1
        for( uint16_t i = 0; i < 8; i++ )
 8038f22:	2a00      	cmp	r2, #0
 8038f24:	d1f6      	bne.n	8038f14 <Crc32+0x1c>
 8038f26:	e7ed      	b.n	8038f04 <Crc32+0xc>
 8038f28:	edb88320 	.word	0xedb88320

08038f2c <RadioCheckRfFrequency>:
}

static bool RadioCheckRfFrequency( uint32_t frequency )
{
    return true;
}
 8038f2c:	2001      	movs	r0, #1
 8038f2e:	4770      	bx	lr

08038f30 <RadioOnTxTimeoutIrq>:
{
    /* ST_WORKAROUND_BEGIN: Reset DBG pin */
    DBG_GPIO_RADIO_TX(RST);
    /* ST_WORKAROUND_END */

    if( ( RadioEvents != NULL ) && ( RadioEvents->TxTimeout != NULL ) )
 8038f30:	4b03      	ldr	r3, [pc, #12]	; (8038f40 <RadioOnTxTimeoutIrq+0x10>)
 8038f32:	681b      	ldr	r3, [r3, #0]
 8038f34:	b113      	cbz	r3, 8038f3c <RadioOnTxTimeoutIrq+0xc>
 8038f36:	685b      	ldr	r3, [r3, #4]
 8038f38:	b103      	cbz	r3, 8038f3c <RadioOnTxTimeoutIrq+0xc>
    {
        RadioEvents->TxTimeout( );
 8038f3a:	4718      	bx	r3
}
 8038f3c:	4770      	bx	lr
 8038f3e:	bf00      	nop
 8038f40:	2000597c 	.word	0x2000597c

08038f44 <RadioOnRxTimeoutIrq>:
{
    /* ST_WORKAROUND_BEGIN: Reset DBG pin */
    DBG_GPIO_RADIO_RX(RST);
    /* ST_WORKAROUND_END */

    if( ( RadioEvents != NULL ) && ( RadioEvents->RxTimeout != NULL ) )
 8038f44:	4b03      	ldr	r3, [pc, #12]	; (8038f54 <RadioOnRxTimeoutIrq+0x10>)
 8038f46:	681b      	ldr	r3, [r3, #0]
 8038f48:	b113      	cbz	r3, 8038f50 <RadioOnRxTimeoutIrq+0xc>
 8038f4a:	68db      	ldr	r3, [r3, #12]
 8038f4c:	b103      	cbz	r3, 8038f50 <RadioOnRxTimeoutIrq+0xc>
    {
        RadioEvents->RxTimeout( );
 8038f4e:	4718      	bx	r3
}
 8038f50:	4770      	bx	lr
 8038f52:	bf00      	nop
 8038f54:	2000597c 	.word	0x2000597c

08038f58 <RadioRead>:
    return SUBGRF_ReadRegister(addr);
 8038f58:	f001 baf4 	b.w	803a544 <SUBGRF_ReadRegister>

08038f5c <RadioWrite>:
    SUBGRF_WriteRegister(addr, data );
 8038f5c:	f001 ba2c 	b.w	803a3b8 <SUBGRF_WriteRegister>

08038f60 <RadioTxCw>:
    SUBGRF_SetTxInfinitePreamble( );
    SUBGRF_SetTx( 0x0fffff );
}

static void RadioTxCw( int8_t power )
{
 8038f60:	b508      	push	{r3, lr}
    uint8_t paselect = SUBGRF_SetRfTxPower( power );
 8038f62:	f001 fd1c 	bl	803a99e <SUBGRF_SetRfTxPower>
    SUBGRF_SetSwitch( paselect, RFSWITCH_TX );
 8038f66:	2101      	movs	r1, #1
 8038f68:	f001 fd03 	bl	803a972 <SUBGRF_SetSwitch>
    SUBGRF_SetTxContinuousWave( );
}
 8038f6c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    SUBGRF_SetTxContinuousWave( );
 8038f70:	f001 b90c 	b.w	803a18c <SUBGRF_SetTxContinuousWave>

08038f74 <RadioSetRxDutyCycle>:
{
 8038f74:	b538      	push	{r3, r4, r5, lr}
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_RX);
 8038f76:	4b07      	ldr	r3, [pc, #28]	; (8038f94 <RadioSetRxDutyCycle+0x20>)
{
 8038f78:	4604      	mov	r4, r0
 8038f7a:	460d      	mov	r5, r1
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_RX);
 8038f7c:	f893 0056 	ldrb.w	r0, [r3, #86]	; 0x56
 8038f80:	2100      	movs	r1, #0
 8038f82:	f001 fcf6 	bl	803a972 <SUBGRF_SetSwitch>
    SUBGRF_SetRxDutyCycle( rxTime, sleepTime );
 8038f86:	4629      	mov	r1, r5
 8038f88:	4620      	mov	r0, r4
}
 8038f8a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    SUBGRF_SetRxDutyCycle( rxTime, sleepTime );
 8038f8e:	f001 b8d5 	b.w	803a13c <SUBGRF_SetRxDutyCycle>
 8038f92:	bf00      	nop
 8038f94:	20006324 	.word	0x20006324

08038f98 <RadioStandby>:
    SUBGRF_SetStandby( STDBY_RC );
 8038f98:	2000      	movs	r0, #0
 8038f9a:	f001 b88d 	b.w	803a0b8 <SUBGRF_SetStandby>
	...

08038fa0 <RadioGetStatus>:
{
 8038fa0:	b508      	push	{r3, lr}
    switch( SUBGRF_GetOperatingMode( ) )
 8038fa2:	f001 f883 	bl	803a0ac <SUBGRF_GetOperatingMode>
 8038fa6:	3804      	subs	r0, #4
 8038fa8:	b2c0      	uxtb	r0, r0
 8038faa:	2803      	cmp	r0, #3
 8038fac:	bf96      	itet	ls
 8038fae:	4b02      	ldrls	r3, [pc, #8]	; (8038fb8 <RadioGetStatus+0x18>)
 8038fb0:	2000      	movhi	r0, #0
 8038fb2:	5c18      	ldrbls	r0, [r3, r0]
}
 8038fb4:	bd08      	pop	{r3, pc}
 8038fb6:	bf00      	nop
 8038fb8:	0803bb7c 	.word	0x0803bb7c

08038fbc <RadioIrqProcess>:
{
 8038fbc:	b573      	push	{r0, r1, r4, r5, r6, lr}
    switch ( SubgRf.RadioIrq )
 8038fbe:	4e84      	ldr	r6, [pc, #528]	; (80391d0 <RadioIrqProcess+0x214>)
 8038fc0:	f8b6 3054 	ldrh.w	r3, [r6, #84]	; 0x54
    uint8_t size = 0;
 8038fc4:	2400      	movs	r4, #0
    switch ( SubgRf.RadioIrq )
 8038fc6:	2b20      	cmp	r3, #32
    uint8_t size = 0;
 8038fc8:	f88d 4003 	strb.w	r4, [sp, #3]
    int32_t cfo = 0;
 8038fcc:	9401      	str	r4, [sp, #4]
    switch ( SubgRf.RadioIrq )
 8038fce:	4635      	mov	r5, r6
 8038fd0:	f000 80d9 	beq.w	8039186 <RadioIrqProcess+0x1ca>
 8038fd4:	d810      	bhi.n	8038ff8 <RadioIrqProcess+0x3c>
 8038fd6:	2b08      	cmp	r3, #8
 8038fd8:	d809      	bhi.n	8038fee <RadioIrqProcess+0x32>
 8038fda:	b15b      	cbz	r3, 8038ff4 <RadioIrqProcess+0x38>
 8038fdc:	3b01      	subs	r3, #1
 8038fde:	2b07      	cmp	r3, #7
 8038fe0:	d808      	bhi.n	8038ff4 <RadioIrqProcess+0x38>
 8038fe2:	e8df f003 	tbb	[pc, r3]
 8038fe6:	4e39      	.short	0x4e39
 8038fe8:	0707b907 	.word	0x0707b907
 8038fec:	c007      	.short	0xc007
 8038fee:	2b10      	cmp	r3, #16
 8038ff0:	f000 80c7 	beq.w	8039182 <RadioIrqProcess+0x1c6>
}
 8038ff4:	b002      	add	sp, #8
 8038ff6:	bd70      	pop	{r4, r5, r6, pc}
    switch ( SubgRf.RadioIrq )
 8038ff8:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8038ffc:	f000 808c 	beq.w	8039118 <RadioIrqProcess+0x15c>
 8039000:	d811      	bhi.n	8039026 <RadioIrqProcess+0x6a>
 8039002:	2b40      	cmp	r3, #64	; 0x40
 8039004:	f000 80d2 	beq.w	80391ac <RadioIrqProcess+0x1f0>
 8039008:	2b80      	cmp	r3, #128	; 0x80
 803900a:	d1f3      	bne.n	8038ff4 <RadioIrqProcess+0x38>
        SUBGRF_SetStandby( STDBY_RC );
 803900c:	4620      	mov	r0, r4
 803900e:	f001 f853 	bl	803a0b8 <SUBGRF_SetStandby>
        if( ( RadioEvents != NULL ) && ( RadioEvents->CadDone != NULL ) )
 8039012:	4b70      	ldr	r3, [pc, #448]	; (80391d4 <RadioIrqProcess+0x218>)
 8039014:	681b      	ldr	r3, [r3, #0]
 8039016:	2b00      	cmp	r3, #0
 8039018:	d0ec      	beq.n	8038ff4 <RadioIrqProcess+0x38>
 803901a:	699b      	ldr	r3, [r3, #24]
 803901c:	2b00      	cmp	r3, #0
 803901e:	d0e9      	beq.n	8038ff4 <RadioIrqProcess+0x38>
            RadioEvents->CadDone( false );
 8039020:	4620      	mov	r0, r4
            RadioEvents->CadDone( true );
 8039022:	4798      	blx	r3
 8039024:	e7e6      	b.n	8038ff4 <RadioIrqProcess+0x38>
    switch ( SubgRf.RadioIrq )
 8039026:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 803902a:	d1e3      	bne.n	8038ff4 <RadioIrqProcess+0x38>
        MW_LOG( TS_ON, VLEVEL_M,  "IRQ_RX_TX_TIMEOUT\r\n" );
 803902c:	4b6a      	ldr	r3, [pc, #424]	; (80391d8 <RadioIrqProcess+0x21c>)
 803902e:	2201      	movs	r2, #1
 8039030:	4621      	mov	r1, r4
 8039032:	2002      	movs	r0, #2
 8039034:	f001 fe2a 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
        if( SUBGRF_GetOperatingMode( ) == MODE_TX )
 8039038:	f001 f838 	bl	803a0ac <SUBGRF_GetOperatingMode>
 803903c:	2804      	cmp	r0, #4
 803903e:	d179      	bne.n	8039134 <RadioIrqProcess+0x178>
            TimerStop( &TxTimeoutTimer );
 8039040:	4866      	ldr	r0, [pc, #408]	; (80391dc <RadioIrqProcess+0x220>)
 8039042:	f002 f945 	bl	803b2d0 <UTIL_TIMER_Stop>
            SUBGRF_SetStandby( STDBY_RC );
 8039046:	4620      	mov	r0, r4
 8039048:	f001 f836 	bl	803a0b8 <SUBGRF_SetStandby>
            if( ( RadioEvents != NULL ) && ( RadioEvents->TxTimeout != NULL ) )
 803904c:	4b61      	ldr	r3, [pc, #388]	; (80391d4 <RadioIrqProcess+0x218>)
 803904e:	681b      	ldr	r3, [r3, #0]
 8039050:	2b00      	cmp	r3, #0
 8039052:	d0cf      	beq.n	8038ff4 <RadioIrqProcess+0x38>
 8039054:	685b      	ldr	r3, [r3, #4]
 8039056:	e010      	b.n	803907a <RadioIrqProcess+0xbe>
        TimerStop( &TxTimeoutTimer );
 8039058:	4860      	ldr	r0, [pc, #384]	; (80391dc <RadioIrqProcess+0x220>)
 803905a:	f002 f939 	bl	803b2d0 <UTIL_TIMER_Stop>
        SUBGRF_SetStandby( STDBY_RC );
 803905e:	2000      	movs	r0, #0
 8039060:	f001 f82a 	bl	803a0b8 <SUBGRF_SetStandby>
        if ( RFW_Is_LongPacketModeEnabled() == 1 )
 8039064:	f001 fd56 	bl	803ab14 <RFW_Is_LongPacketModeEnabled>
 8039068:	2801      	cmp	r0, #1
 803906a:	d101      	bne.n	8039070 <RadioIrqProcess+0xb4>
            RFW_DeInit_TxLongPacket( );
 803906c:	f001 fd5b 	bl	803ab26 <RFW_DeInit_TxLongPacket>
        if( ( RadioEvents != NULL ) && ( RadioEvents->TxDone != NULL ) )
 8039070:	4b58      	ldr	r3, [pc, #352]	; (80391d4 <RadioIrqProcess+0x218>)
 8039072:	681b      	ldr	r3, [r3, #0]
 8039074:	2b00      	cmp	r3, #0
 8039076:	d0bd      	beq.n	8038ff4 <RadioIrqProcess+0x38>
 8039078:	681b      	ldr	r3, [r3, #0]
        if( ( RadioEvents != NULL ) && ( RadioEvents->RxError ) )
 803907a:	2b00      	cmp	r3, #0
 803907c:	d0ba      	beq.n	8038ff4 <RadioIrqProcess+0x38>
            RadioEvents->RxError( );
 803907e:	4798      	blx	r3
}
 8039080:	e7b8      	b.n	8038ff4 <RadioIrqProcess+0x38>
        TimerStop( &RxTimeoutTimer );
 8039082:	4857      	ldr	r0, [pc, #348]	; (80391e0 <RadioIrqProcess+0x224>)
 8039084:	f002 f924 	bl	803b2d0 <UTIL_TIMER_Stop>
        if( SubgRf.RxContinuous == false )
 8039088:	7874      	ldrb	r4, [r6, #1]
 803908a:	b994      	cbnz	r4, 80390b2 <RadioIrqProcess+0xf6>
            SUBGRF_SetStandby( STDBY_RC );
 803908c:	4620      	mov	r0, r4
 803908e:	f001 f813 	bl	803a0b8 <SUBGRF_SetStandby>
            SUBGRF_WriteRegister( 0x0902, 0x00 );
 8039092:	4621      	mov	r1, r4
 8039094:	f640 1002 	movw	r0, #2306	; 0x902
 8039098:	f001 f98e 	bl	803a3b8 <SUBGRF_WriteRegister>
            SUBGRF_WriteRegister( 0x0944, SUBGRF_ReadRegister( 0x0944 ) | ( 1 << 1 ) );
 803909c:	f640 1044 	movw	r0, #2372	; 0x944
 80390a0:	f001 fa50 	bl	803a544 <SUBGRF_ReadRegister>
 80390a4:	f040 0102 	orr.w	r1, r0, #2
 80390a8:	b2c9      	uxtb	r1, r1
 80390aa:	f640 1044 	movw	r0, #2372	; 0x944
 80390ae:	f001 f983 	bl	803a3b8 <SUBGRF_WriteRegister>
        SUBGRF_GetPayload( RadioBuffer, &size , 255 );
 80390b2:	4c48      	ldr	r4, [pc, #288]	; (80391d4 <RadioIrqProcess+0x218>)
 80390b4:	22ff      	movs	r2, #255	; 0xff
 80390b6:	f10d 0103 	add.w	r1, sp, #3
 80390ba:	1d20      	adds	r0, r4, #4
 80390bc:	f001 fc40 	bl	803a940 <SUBGRF_GetPayload>
        SUBGRF_GetPacketStatus( &(SubgRf.PacketStatus) );
 80390c0:	4848      	ldr	r0, [pc, #288]	; (80391e4 <RadioIrqProcess+0x228>)
 80390c2:	f001 f93f 	bl	803a344 <SUBGRF_GetPacketStatus>
        if( ( RadioEvents != NULL ) && ( RadioEvents->RxDone != NULL ) )
 80390c6:	6823      	ldr	r3, [r4, #0]
 80390c8:	2b00      	cmp	r3, #0
 80390ca:	d093      	beq.n	8038ff4 <RadioIrqProcess+0x38>
 80390cc:	689e      	ldr	r6, [r3, #8]
 80390ce:	2e00      	cmp	r6, #0
 80390d0:	d090      	beq.n	8038ff4 <RadioIrqProcess+0x38>
            switch ( SubgRf.PacketStatus.packetType )
 80390d2:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
 80390d6:	2b01      	cmp	r3, #1
 80390d8:	d108      	bne.n	80390ec <RadioIrqProcess+0x130>
                RadioEvents->RxDone( RadioBuffer, size, SubgRf.PacketStatus.Params.LoRa.RssiPkt, SubgRf.PacketStatus.Params.LoRa.SnrPkt );
 80390da:	f995 3031 	ldrsb.w	r3, [r5, #49]	; 0x31
 80390de:	f995 2030 	ldrsb.w	r2, [r5, #48]	; 0x30
 80390e2:	f89d 1003 	ldrb.w	r1, [sp, #3]
 80390e6:	1d20      	adds	r0, r4, #4
 80390e8:	47b0      	blx	r6
                break;
 80390ea:	e783      	b.n	8038ff4 <RadioIrqProcess+0x38>
                SUBGRF_GetCFO( SubgRf.ModulationParams.Params.Gfsk.BitRate, &cfo );
 80390ec:	6be8      	ldr	r0, [r5, #60]	; 0x3c
 80390ee:	a901      	add	r1, sp, #4
 80390f0:	f001 fcc4 	bl	803aa7c <SUBGRF_GetCFO>
                RadioEvents->RxDone( RadioBuffer, size, SubgRf.PacketStatus.Params.Gfsk.RssiAvg, (int8_t) DIVR(cfo, 1000) );
 80390f4:	4620      	mov	r0, r4
 80390f6:	9b01      	ldr	r3, [sp, #4]
 80390f8:	f89d 1003 	ldrb.w	r1, [sp, #3]
 80390fc:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8039100:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
 8039104:	fb93 f3f2 	sdiv	r3, r3, r2
 8039108:	f850 2b04 	ldr.w	r2, [r0], #4
 803910c:	b25b      	sxtb	r3, r3
 803910e:	6894      	ldr	r4, [r2, #8]
 8039110:	f995 2029 	ldrsb.w	r2, [r5, #41]	; 0x29
 8039114:	47a0      	blx	r4
                break;
 8039116:	e76d      	b.n	8038ff4 <RadioIrqProcess+0x38>
        SUBGRF_SetStandby( STDBY_RC );
 8039118:	4620      	mov	r0, r4
 803911a:	f000 ffcd 	bl	803a0b8 <SUBGRF_SetStandby>
        if( ( RadioEvents != NULL ) && ( RadioEvents->CadDone != NULL ) )
 803911e:	4b2d      	ldr	r3, [pc, #180]	; (80391d4 <RadioIrqProcess+0x218>)
 8039120:	681b      	ldr	r3, [r3, #0]
 8039122:	2b00      	cmp	r3, #0
 8039124:	f43f af66 	beq.w	8038ff4 <RadioIrqProcess+0x38>
 8039128:	699b      	ldr	r3, [r3, #24]
 803912a:	2b00      	cmp	r3, #0
 803912c:	f43f af62 	beq.w	8038ff4 <RadioIrqProcess+0x38>
            RadioEvents->CadDone( true );
 8039130:	2001      	movs	r0, #1
 8039132:	e776      	b.n	8039022 <RadioIrqProcess+0x66>
        else if( SUBGRF_GetOperatingMode( ) == MODE_RX )
 8039134:	f000 ffba 	bl	803a0ac <SUBGRF_GetOperatingMode>
 8039138:	2805      	cmp	r0, #5
 803913a:	f47f af5b 	bne.w	8038ff4 <RadioIrqProcess+0x38>
            TimerStop( &RxTimeoutTimer );
 803913e:	4828      	ldr	r0, [pc, #160]	; (80391e0 <RadioIrqProcess+0x224>)
 8039140:	f002 f8c6 	bl	803b2d0 <UTIL_TIMER_Stop>
            SUBGRF_SetStandby( STDBY_RC );
 8039144:	4620      	mov	r0, r4
 8039146:	f000 ffb7 	bl	803a0b8 <SUBGRF_SetStandby>
            if( ( RadioEvents != NULL ) && ( RadioEvents->RxTimeout != NULL ) )
 803914a:	4b22      	ldr	r3, [pc, #136]	; (80391d4 <RadioIrqProcess+0x218>)
 803914c:	681b      	ldr	r3, [r3, #0]
 803914e:	2b00      	cmp	r3, #0
 8039150:	f43f af50 	beq.w	8038ff4 <RadioIrqProcess+0x38>
 8039154:	68db      	ldr	r3, [r3, #12]
 8039156:	e790      	b.n	803907a <RadioIrqProcess+0xbe>
        MW_LOG( TS_ON, VLEVEL_M,  "PRE OK\r\n" );
 8039158:	4b23      	ldr	r3, [pc, #140]	; (80391e8 <RadioIrqProcess+0x22c>)
            MW_LOG( TS_ON, VLEVEL_M,  "HDR KO\r\n" );
 803915a:	2201      	movs	r2, #1
 803915c:	2100      	movs	r1, #0
 803915e:	2002      	movs	r0, #2
 8039160:	f001 fd94 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
 8039164:	e746      	b.n	8038ff4 <RadioIrqProcess+0x38>
        MW_LOG( TS_ON, VLEVEL_M,  "SYNC OK\r\n" );
 8039166:	4b21      	ldr	r3, [pc, #132]	; (80391ec <RadioIrqProcess+0x230>)
 8039168:	2201      	movs	r2, #1
 803916a:	2100      	movs	r1, #0
 803916c:	2002      	movs	r0, #2
 803916e:	f001 fd8d 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
        if ( 1UL == RFW_Is_Init( ) )
 8039172:	f001 fccd 	bl	803ab10 <RFW_Is_Init>
 8039176:	2801      	cmp	r0, #1
 8039178:	f47f af3c 	bne.w	8038ff4 <RadioIrqProcess+0x38>
            RFW_ReceivePayload( );
 803917c:	f001 fcd4 	bl	803ab28 <RFW_ReceivePayload>
 8039180:	e738      	b.n	8038ff4 <RadioIrqProcess+0x38>
        MW_LOG( TS_ON, VLEVEL_M,  "HDR OK\r\n" );
 8039182:	4b1b      	ldr	r3, [pc, #108]	; (80391f0 <RadioIrqProcess+0x234>)
 8039184:	e7e9      	b.n	803915a <RadioIrqProcess+0x19e>
        TimerStop( &RxTimeoutTimer );
 8039186:	4816      	ldr	r0, [pc, #88]	; (80391e0 <RadioIrqProcess+0x224>)
 8039188:	f002 f8a2 	bl	803b2d0 <UTIL_TIMER_Stop>
        if( SubgRf.RxContinuous == false )
 803918c:	7870      	ldrb	r0, [r6, #1]
 803918e:	b908      	cbnz	r0, 8039194 <RadioIrqProcess+0x1d8>
            SUBGRF_SetStandby( STDBY_RC );
 8039190:	f000 ff92 	bl	803a0b8 <SUBGRF_SetStandby>
        if( ( RadioEvents != NULL ) && ( RadioEvents->RxTimeout != NULL ) )
 8039194:	4b0f      	ldr	r3, [pc, #60]	; (80391d4 <RadioIrqProcess+0x218>)
 8039196:	681b      	ldr	r3, [r3, #0]
 8039198:	2b00      	cmp	r3, #0
 803919a:	f43f af2b 	beq.w	8038ff4 <RadioIrqProcess+0x38>
 803919e:	68db      	ldr	r3, [r3, #12]
 80391a0:	2b00      	cmp	r3, #0
 80391a2:	f43f af27 	beq.w	8038ff4 <RadioIrqProcess+0x38>
            RadioEvents->RxTimeout( );
 80391a6:	4798      	blx	r3
            MW_LOG( TS_ON, VLEVEL_M,  "HDR KO\r\n" );
 80391a8:	4b12      	ldr	r3, [pc, #72]	; (80391f4 <RadioIrqProcess+0x238>)
 80391aa:	e7d6      	b.n	803915a <RadioIrqProcess+0x19e>
        MW_LOG( TS_ON, VLEVEL_M,  "IRQ_CRC_ERROR\r\n" );
 80391ac:	4b12      	ldr	r3, [pc, #72]	; (80391f8 <RadioIrqProcess+0x23c>)
 80391ae:	2201      	movs	r2, #1
 80391b0:	4621      	mov	r1, r4
 80391b2:	2002      	movs	r0, #2
 80391b4:	f001 fd6a 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
        if( SubgRf.RxContinuous == false )
 80391b8:	7870      	ldrb	r0, [r6, #1]
 80391ba:	b908      	cbnz	r0, 80391c0 <RadioIrqProcess+0x204>
            SUBGRF_SetStandby( STDBY_RC );
 80391bc:	f000 ff7c 	bl	803a0b8 <SUBGRF_SetStandby>
        if( ( RadioEvents != NULL ) && ( RadioEvents->RxError ) )
 80391c0:	4b04      	ldr	r3, [pc, #16]	; (80391d4 <RadioIrqProcess+0x218>)
 80391c2:	681b      	ldr	r3, [r3, #0]
 80391c4:	2b00      	cmp	r3, #0
 80391c6:	f43f af15 	beq.w	8038ff4 <RadioIrqProcess+0x38>
 80391ca:	691b      	ldr	r3, [r3, #16]
 80391cc:	e755      	b.n	803907a <RadioIrqProcess+0xbe>
 80391ce:	bf00      	nop
 80391d0:	20006324 	.word	0x20006324
 80391d4:	2000597c 	.word	0x2000597c
 80391d8:	0803c4ae 	.word	0x0803c4ae
 80391dc:	2000637c 	.word	0x2000637c
 80391e0:	20006394 	.word	0x20006394
 80391e4:	20006348 	.word	0x20006348
 80391e8:	0803c4c2 	.word	0x0803c4c2
 80391ec:	0803c4cb 	.word	0x0803c4cb
 80391f0:	0803c4d5 	.word	0x0803c4d5
 80391f4:	0803c4de 	.word	0x0803c4de
 80391f8:	0803c4e7 	.word	0x0803c4e7

080391fc <RadioOnDioIrq>:
    SubgRf.RadioIrq = radioIrq;
 80391fc:	4b02      	ldr	r3, [pc, #8]	; (8039208 <RadioOnDioIrq+0xc>)
 80391fe:	f8a3 0054 	strh.w	r0, [r3, #84]	; 0x54
    RADIO_IRQ_PROCESS();
 8039202:	f7ff bedb 	b.w	8038fbc <RadioIrqProcess>
 8039206:	bf00      	nop
 8039208:	20006324 	.word	0x20006324

0803920c <RadioGetWakeupTime>:
{
 803920c:	b508      	push	{r3, lr}
    return SUBGRF_GetRadioWakeUpTime() + RADIO_WAKEUP_TIME;
 803920e:	f001 fbdb 	bl	803a9c8 <SUBGRF_GetRadioWakeUpTime>
}
 8039212:	3003      	adds	r0, #3
 8039214:	bd08      	pop	{r3, pc}

08039216 <RadioReadRegisters>:
    SUBGRF_ReadRegisters( addr, buffer, size );
 8039216:	f001 bb21 	b.w	803a85c <SUBGRF_ReadRegisters>

0803921a <RadioWriteRegisters>:
    SUBGRF_WriteRegisters( addr, buffer, size );
 803921a:	f001 ba7f 	b.w	803a71c <SUBGRF_WriteRegisters>

0803921e <RadioRssi>:
{
 803921e:	b508      	push	{r3, lr}
    return SUBGRF_GetRssiInst( );
 8039220:	f001 f883 	bl	803a32a <SUBGRF_GetRssiInst>
}
 8039224:	b200      	sxth	r0, r0
 8039226:	bd08      	pop	{r3, pc}

08039228 <RadioSetTxContinuousWave>:
{
 8039228:	b538      	push	{r3, r4, r5, lr}
 803922a:	460d      	mov	r5, r1
 803922c:	4614      	mov	r4, r2
    SUBGRF_SetRfFrequency( freq );
 803922e:	f001 f851 	bl	803a2d4 <SUBGRF_SetRfFrequency>
    antswitchpow = SUBGRF_SetRfTxPower( power );
 8039232:	4628      	mov	r0, r5
 8039234:	f001 fbb3 	bl	803a99e <SUBGRF_SetRfTxPower>
    TimerSetValue( &TxTimeoutTimer, timeout );
 8039238:	4d08      	ldr	r5, [pc, #32]	; (803925c <RadioSetTxContinuousWave+0x34>)
    SUBGRF_SetSwitch(antswitchpow, RFSWITCH_TX);
 803923a:	2101      	movs	r1, #1
 803923c:	f001 fb99 	bl	803a972 <SUBGRF_SetSwitch>
    SUBGRF_SetTxContinuousWave( );
 8039240:	f000 ffa4 	bl	803a18c <SUBGRF_SetTxContinuousWave>
    TimerSetValue( &TxTimeoutTimer, timeout );
 8039244:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8039248:	4361      	muls	r1, r4
 803924a:	4628      	mov	r0, r5
 803924c:	f002 f8ca 	bl	803b3e4 <UTIL_TIMER_SetPeriod>
    TimerStart( &TxTimeoutTimer );
 8039250:	4628      	mov	r0, r5
}
 8039252:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    TimerStart( &TxTimeoutTimer );
 8039256:	f002 b88b 	b.w	803b370 <UTIL_TIMER_Start>
 803925a:	bf00      	nop
 803925c:	2000637c 	.word	0x2000637c

08039260 <RadioSetChannel>:
    SUBGRF_SetRfFrequency( freq );
 8039260:	f001 b838 	b.w	803a2d4 <SUBGRF_SetRfFrequency>

08039264 <RadioStartCad>:
{
 8039264:	b508      	push	{r3, lr}
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_RX);
 8039266:	4b08      	ldr	r3, [pc, #32]	; (8039288 <RadioStartCad+0x24>)
 8039268:	2100      	movs	r1, #0
 803926a:	f893 0056 	ldrb.w	r0, [r3, #86]	; 0x56
 803926e:	f001 fb80 	bl	803a972 <SUBGRF_SetSwitch>
    SUBGRF_SetDioIrqParams( IRQ_CAD_CLEAR | IRQ_CAD_DETECTED,
 8039272:	2300      	movs	r3, #0
 8039274:	f44f 71c0 	mov.w	r1, #384	; 0x180
 8039278:	461a      	mov	r2, r3
 803927a:	4608      	mov	r0, r1
 803927c:	f001 f800 	bl	803a280 <SUBGRF_SetDioIrqParams>
}
 8039280:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    SUBGRF_SetCad( );
 8039284:	f000 bf76 	b.w	803a174 <SUBGRF_SetCad>
 8039288:	20006324 	.word	0x20006324

0803928c <RadioSleep>:
{
 803928c:	b508      	push	{r3, lr}
    SUBGRF_SetSleep( params );
 803928e:	f04f 0004 	mov.w	r0, #4
 8039292:	f001 f9ab 	bl	803a5ec <SUBGRF_SetSleep>
}
 8039296:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RADIO_DELAY_MS( 2 );
 803929a:	2002      	movs	r0, #2
 803929c:	f7f3 b9d4 	b.w	802c648 <HAL_Delay>

080392a0 <RadioTimeOnAir>:
{
 80392a0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80392a2:	f8bd 5014 	ldrh.w	r5, [sp, #20]
 80392a6:	f89d e018 	ldrb.w	lr, [sp, #24]
 80392aa:	f89d c01c 	ldrb.w	ip, [sp, #28]
 80392ae:	f89d 4020 	ldrb.w	r4, [sp, #32]
    switch( modem )
 80392b2:	b140      	cbz	r0, 80392c6 <RadioTimeOnAir+0x26>
 80392b4:	2801      	cmp	r0, #1
 80392b6:	d019      	beq.n	80392ec <RadioTimeOnAir+0x4c>
 80392b8:	2201      	movs	r2, #1
 80392ba:	2300      	movs	r3, #0
    return DIVC(numerator, denominator); /* ST_WORKAROUND : simplified calculation with macro usage */
 80392bc:	4413      	add	r3, r2
 80392be:	1e58      	subs	r0, r3, #1
 80392c0:	fbb0 f0f2 	udiv	r0, r0, r2
}
 80392c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
           ( ( fixLen == false ) ? 8 : 0 ) + 24 +
 80392c6:	f1be 0f00 	cmp.w	lr, #0
 80392ca:	bf0c      	ite	eq
 80392cc:	2308      	moveq	r3, #8
 80392ce:	2300      	movne	r3, #0
           ( ( payloadLen + ( ( crcOn == true ) ? 2 : 0 ) ) << 3 );
 80392d0:	2c00      	cmp	r4, #0
    return ( preambleLen << 3 ) +
 80392d2:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
           ( ( payloadLen + ( ( crcOn == true ) ? 2 : 0 ) ) << 3 );
 80392d6:	bf14      	ite	ne
 80392d8:	2402      	movne	r4, #2
 80392da:	2400      	moveq	r4, #0
           ( ( fixLen == false ) ? 8 : 0 ) + 24 +
 80392dc:	3318      	adds	r3, #24
           ( ( payloadLen + ( ( crcOn == true ) ? 2 : 0 ) ) << 3 );
 80392de:	4464      	add	r4, ip
           ( ( fixLen == false ) ? 8 : 0 ) + 24 +
 80392e0:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
            numerator   = 1000U * RadioGetGfskTimeOnAirNumerator( datarate, coderate,
 80392e4:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80392e8:	4363      	muls	r3, r4
        break;
 80392ea:	e7e7      	b.n	80392bc <RadioTimeOnAir+0x1c>
    int32_t crDenom           = coderate + 4;
 80392ec:	1d1e      	adds	r6, r3, #4
    if( ( datarate == 5 ) || ( datarate == 6 ) )
 80392ee:	1f53      	subs	r3, r2, #5
 80392f0:	2b01      	cmp	r3, #1
 80392f2:	d802      	bhi.n	80392fa <RadioTimeOnAir+0x5a>
        if( preambleLen < 12 )
 80392f4:	2d0c      	cmp	r5, #12
 80392f6:	bf38      	it	cc
 80392f8:	250c      	movcc	r5, #12
    if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 80392fa:	2900      	cmp	r1, #0
 80392fc:	d138      	bne.n	8039370 <RadioTimeOnAir+0xd0>
 80392fe:	f1a2 070b 	sub.w	r7, r2, #11
 8039302:	2f01      	cmp	r7, #1
 8039304:	bf8c      	ite	hi
 8039306:	2700      	movhi	r7, #0
 8039308:	2701      	movls	r7, #1
                            ( crcOn ? 16 : 0 ) -
 803930a:	2c00      	cmp	r4, #0
 803930c:	bf14      	ite	ne
 803930e:	2410      	movne	r4, #16
 8039310:	2400      	moveq	r4, #0
    int32_t ceilNumerator = ( payloadLen << 3 ) +
 8039312:	eb04 04cc 	add.w	r4, r4, ip, lsl #3
                            ( fixLen ? 0 : 20 );
 8039316:	f1be 0f00 	cmp.w	lr, #0
 803931a:	bf14      	ite	ne
 803931c:	2000      	movne	r0, #0
 803931e:	2014      	moveq	r0, #20
                            ( crcOn ? 16 : 0 ) -
 8039320:	eba4 0482 	sub.w	r4, r4, r2, lsl #2
    if( datarate <= 6 )
 8039324:	2a06      	cmp	r2, #6
                            ( 4 * datarate ) +
 8039326:	4404      	add	r4, r0
 8039328:	ea4f 0382 	mov.w	r3, r2, lsl #2
 803932c:	f1a2 0002 	sub.w	r0, r2, #2
    if( datarate <= 6 )
 8039330:	d902      	bls.n	8039338 <RadioTimeOnAir+0x98>
        ceilNumerator += 8;
 8039332:	3408      	adds	r4, #8
        if( lowDatareOptimize == true )
 8039334:	b107      	cbz	r7, 8039338 <RadioTimeOnAir+0x98>
            ceilDenominator = 4 * ( datarate - 2 );
 8039336:	0083      	lsls	r3, r0, #2
        ( ( ceilNumerator + ceilDenominator - 1 ) / ceilDenominator ) * crDenom + preambleLen + 12;
 8039338:	2c00      	cmp	r4, #0
 803933a:	bfac      	ite	ge
 803933c:	191c      	addge	r4, r3, r4
 803933e:	1c1c      	addlt	r4, r3, #0
 8039340:	3c01      	subs	r4, #1
 8039342:	fb94 f3f3 	sdiv	r3, r4, r3
            denominator = RadioGetLoRaBandwidthInHz( Bandwidths[bandwidth] );
 8039346:	4c0f      	ldr	r4, [pc, #60]	; (8039384 <RadioTimeOnAir+0xe4>)
 8039348:	4421      	add	r1, r4
    if( datarate <= 6 )
 803934a:	2a06      	cmp	r2, #6
            denominator = RadioGetLoRaBandwidthInHz( Bandwidths[bandwidth] );
 803934c:	7909      	ldrb	r1, [r1, #4]
        ( ( ceilNumerator + ceilDenominator - 1 ) / ceilDenominator ) * crDenom + preambleLen + 12;
 803934e:	fb06 5303 	mla	r3, r6, r3, r5
    int32_t intermediate =
 8039352:	bf8c      	ite	hi
 8039354:	330c      	addhi	r3, #12
        intermediate += 2;
 8039356:	330e      	addls	r3, #14
    switch( bw )
 8039358:	290a      	cmp	r1, #10
 803935a:	d812      	bhi.n	8039382 <RadioTimeOnAir+0xe2>
    return ( uint32_t )( ( 4 * intermediate + 1 ) * ( 1 << ( datarate - 2 ) ) );
 803935c:	009b      	lsls	r3, r3, #2
 803935e:	3301      	adds	r3, #1
 8039360:	eb04 0481 	add.w	r4, r4, r1, lsl #2
            numerator   = 1000U * RadioGetLoRaTimeOnAirNumerator( bandwidth, datarate,
 8039364:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    return ( uint32_t )( ( 4 * intermediate + 1 ) * ( 1 << ( datarate - 2 ) ) );
 8039368:	4083      	lsls	r3, r0
            numerator   = 1000U * RadioGetLoRaTimeOnAirNumerator( bandwidth, datarate,
 803936a:	4353      	muls	r3, r2
 803936c:	68a2      	ldr	r2, [r4, #8]
 803936e:	e7a5      	b.n	80392bc <RadioTimeOnAir+0x1c>
    if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 8039370:	2901      	cmp	r1, #1
 8039372:	d104      	bne.n	803937e <RadioTimeOnAir+0xde>
        ( ( bandwidth == 1 ) && ( datarate == 12 ) ) )
 8039374:	f1a2 030c 	sub.w	r3, r2, #12
 8039378:	425f      	negs	r7, r3
 803937a:	415f      	adcs	r7, r3
 803937c:	e7c5      	b.n	803930a <RadioTimeOnAir+0x6a>
    bool    lowDatareOptimize = false;
 803937e:	2700      	movs	r7, #0
 8039380:	e7c3      	b.n	803930a <RadioTimeOnAir+0x6a>
    return DIVC(numerator, denominator); /* ST_WORKAROUND : simplified calculation with macro usage */
 8039382:	deff      	udf	#255	; 0xff
 8039384:	0803bb7c 	.word	0x0803bb7c

08039388 <RadioSetMaxPayloadLength>:
    if( modem == MODEM_LORA )
 8039388:	2801      	cmp	r0, #1
 803938a:	4808      	ldr	r0, [pc, #32]	; (80393ac <RadioSetMaxPayloadLength+0x24>)
 803938c:	d105      	bne.n	803939a <RadioSetMaxPayloadLength+0x12>
        SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength = max;
 803938e:	4b08      	ldr	r3, [pc, #32]	; (80393b0 <RadioSetMaxPayloadLength+0x28>)
 8039390:	77c1      	strb	r1, [r0, #31]
 8039392:	7019      	strb	r1, [r3, #0]
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039394:	300e      	adds	r0, #14
 8039396:	f001 b9ff 	b.w	803a798 <SUBGRF_SetPacketParams>
        if( SubgRf.PacketParams.Params.Gfsk.HeaderType == RADIO_PACKET_VARIABLE_LENGTH )
 803939a:	7d43      	ldrb	r3, [r0, #21]
 803939c:	2b01      	cmp	r3, #1
 803939e:	d103      	bne.n	80393a8 <RadioSetMaxPayloadLength+0x20>
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength = max;
 80393a0:	4b03      	ldr	r3, [pc, #12]	; (80393b0 <RadioSetMaxPayloadLength+0x28>)
 80393a2:	7581      	strb	r1, [r0, #22]
 80393a4:	7019      	strb	r1, [r3, #0]
 80393a6:	e7f5      	b.n	8039394 <RadioSetMaxPayloadLength+0xc>
}
 80393a8:	4770      	bx	lr
 80393aa:	bf00      	nop
 80393ac:	20006324 	.word	0x20006324
 80393b0:	200035a0 	.word	0x200035a0

080393b4 <RadioRxBoosted>:
{
 80393b4:	b510      	push	{r4, lr}
 80393b6:	4604      	mov	r4, r0
    if (1UL==RFW_Is_Init())
 80393b8:	f001 fbaa 	bl	803ab10 <RFW_Is_Init>
 80393bc:	2801      	cmp	r0, #1
 80393be:	d117      	bne.n	80393f0 <RadioRxBoosted+0x3c>
      RFW_ReceiveInit();
 80393c0:	f001 fbae 	bl	803ab20 <RFW_ReceiveInit>
    if( timeout != 0 )
 80393c4:	b134      	cbz	r4, 80393d4 <RadioRxBoosted+0x20>
        TimerSetValue( &RxTimeoutTimer, timeout );
 80393c6:	4810      	ldr	r0, [pc, #64]	; (8039408 <RadioRxBoosted+0x54>)
 80393c8:	4621      	mov	r1, r4
 80393ca:	f002 f80b 	bl	803b3e4 <UTIL_TIMER_SetPeriod>
        TimerStart( &RxTimeoutTimer );
 80393ce:	480e      	ldr	r0, [pc, #56]	; (8039408 <RadioRxBoosted+0x54>)
 80393d0:	f001 ffce 	bl	803b370 <UTIL_TIMER_Start>
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_RX);
 80393d4:	4c0d      	ldr	r4, [pc, #52]	; (803940c <RadioRxBoosted+0x58>)
 80393d6:	2100      	movs	r1, #0
 80393d8:	f894 0056 	ldrb.w	r0, [r4, #86]	; 0x56
 80393dc:	f001 fac9 	bl	803a972 <SUBGRF_SetSwitch>
    if( SubgRf.RxContinuous == true )
 80393e0:	7863      	ldrb	r3, [r4, #1]
 80393e2:	b16b      	cbz	r3, 8039400 <RadioRxBoosted+0x4c>
        SUBGRF_SetRxBoosted( 0xFFFFFF ); // Rx Continuous
 80393e4:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
}
 80393e8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        SUBGRF_SetRxBoosted( SubgRf.RxTimeout << 6 );
 80393ec:	f000 bff4 	b.w	803a3d8 <SUBGRF_SetRxBoosted>
      SUBGRF_SetDioIrqParams( IRQ_RX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_CRC_ERROR | IRQ_HEADER_ERROR | IRQ_RX_DBG,
 80393f0:	2300      	movs	r3, #0
 80393f2:	f240 2162 	movw	r1, #610	; 0x262
 80393f6:	461a      	mov	r2, r3
 80393f8:	4608      	mov	r0, r1
 80393fa:	f000 ff41 	bl	803a280 <SUBGRF_SetDioIrqParams>
 80393fe:	e7e1      	b.n	80393c4 <RadioRxBoosted+0x10>
        SUBGRF_SetRxBoosted( SubgRf.RxTimeout << 6 );
 8039400:	68a0      	ldr	r0, [r4, #8]
 8039402:	0180      	lsls	r0, r0, #6
 8039404:	e7f0      	b.n	80393e8 <RadioRxBoosted+0x34>
 8039406:	bf00      	nop
 8039408:	20006394 	.word	0x20006394
 803940c:	20006324 	.word	0x20006324

08039410 <RadioRx>:
{
 8039410:	b510      	push	{r4, lr}
 8039412:	4604      	mov	r4, r0
    if ( 1UL == RFW_Is_Init( ) )
 8039414:	f001 fb7c 	bl	803ab10 <RFW_Is_Init>
 8039418:	2801      	cmp	r0, #1
 803941a:	d117      	bne.n	803944c <RadioRx+0x3c>
      RFW_ReceiveInit( );
 803941c:	f001 fb80 	bl	803ab20 <RFW_ReceiveInit>
    if( timeout != 0 )
 8039420:	b134      	cbz	r4, 8039430 <RadioRx+0x20>
        TimerSetValue( &RxTimeoutTimer, timeout );
 8039422:	4810      	ldr	r0, [pc, #64]	; (8039464 <RadioRx+0x54>)
 8039424:	4621      	mov	r1, r4
 8039426:	f001 ffdd 	bl	803b3e4 <UTIL_TIMER_SetPeriod>
        TimerStart( &RxTimeoutTimer );
 803942a:	480e      	ldr	r0, [pc, #56]	; (8039464 <RadioRx+0x54>)
 803942c:	f001 ffa0 	bl	803b370 <UTIL_TIMER_Start>
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_RX);
 8039430:	4c0d      	ldr	r4, [pc, #52]	; (8039468 <RadioRx+0x58>)
 8039432:	2100      	movs	r1, #0
 8039434:	f894 0056 	ldrb.w	r0, [r4, #86]	; 0x56
 8039438:	f001 fa9b 	bl	803a972 <SUBGRF_SetSwitch>
    if( SubgRf.RxContinuous == true )
 803943c:	7863      	ldrb	r3, [r4, #1]
 803943e:	b16b      	cbz	r3, 803945c <RadioRx+0x4c>
        SUBGRF_SetRx( 0xFFFFFF ); // Rx Continuous
 8039440:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
}
 8039444:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        SUBGRF_SetRx( SubgRf.RxTimeout << 6 );
 8039448:	f000 be62 	b.w	803a110 <SUBGRF_SetRx>
      SUBGRF_SetDioIrqParams( IRQ_RX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_CRC_ERROR | IRQ_HEADER_ERROR | IRQ_RX_DBG,
 803944c:	2300      	movs	r3, #0
 803944e:	f240 2162 	movw	r1, #610	; 0x262
 8039452:	461a      	mov	r2, r3
 8039454:	4608      	mov	r0, r1
 8039456:	f000 ff13 	bl	803a280 <SUBGRF_SetDioIrqParams>
 803945a:	e7e1      	b.n	8039420 <RadioRx+0x10>
        SUBGRF_SetRx( SubgRf.RxTimeout << 6 );
 803945c:	68a0      	ldr	r0, [r4, #8]
 803945e:	0180      	lsls	r0, r0, #6
 8039460:	e7f0      	b.n	8039444 <RadioRx+0x34>
 8039462:	bf00      	nop
 8039464:	20006394 	.word	0x20006394
 8039468:	20006324 	.word	0x20006324

0803946c <RadioSetPublicNetwork>:
    SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous = enable;
 803946c:	4b0d      	ldr	r3, [pc, #52]	; (80394a4 <RadioSetPublicNetwork+0x38>)
{
 803946e:	b510      	push	{r4, lr}
 8039470:	4604      	mov	r4, r0
    SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous = enable;
 8039472:	7318      	strb	r0, [r3, #12]
 8039474:	7358      	strb	r0, [r3, #13]
    RadioSetModem( MODEM_LORA );
 8039476:	2001      	movs	r0, #1
 8039478:	f000 f816 	bl	80394a8 <RadioSetModem>
    if( enable == true )
 803947c:	b15c      	cbz	r4, 8039496 <RadioSetPublicNetwork+0x2a>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD, ( LORA_MAC_PUBLIC_SYNCWORD >> 8 ) & 0xFF );
 803947e:	2134      	movs	r1, #52	; 0x34
 8039480:	f44f 60e8 	mov.w	r0, #1856	; 0x740
 8039484:	f000 ff98 	bl	803a3b8 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PUBLIC_SYNCWORD & 0xFF );
 8039488:	2144      	movs	r1, #68	; 0x44
}
 803948a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PRIVATE_SYNCWORD & 0xFF );
 803948e:	f240 7041 	movw	r0, #1857	; 0x741
 8039492:	f000 bf91 	b.w	803a3b8 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD, ( LORA_MAC_PRIVATE_SYNCWORD >> 8 ) & 0xFF );
 8039496:	2114      	movs	r1, #20
 8039498:	f44f 60e8 	mov.w	r0, #1856	; 0x740
 803949c:	f000 ff8c 	bl	803a3b8 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PRIVATE_SYNCWORD & 0xFF );
 80394a0:	2124      	movs	r1, #36	; 0x24
 80394a2:	e7f2      	b.n	803948a <RadioSetPublicNetwork+0x1e>
 80394a4:	20006324 	.word	0x20006324

080394a8 <RadioSetModem>:
{
 80394a8:	b538      	push	{r3, r4, r5, lr}
    SubgRf.Modem = modem;
 80394aa:	4d0f      	ldr	r5, [pc, #60]	; (80394e8 <RadioSetModem+0x40>)
{
 80394ac:	4604      	mov	r4, r0
    SubgRf.Modem = modem;
 80394ae:	7028      	strb	r0, [r5, #0]
    RFW_SetRadioModem(modem);
 80394b0:	f001 fb3b 	bl	803ab2a <RFW_SetRadioModem>
    switch( modem )
 80394b4:	2c01      	cmp	r4, #1
 80394b6:	d00a      	beq.n	80394ce <RadioSetModem+0x26>
 80394b8:	3c02      	subs	r4, #2
 80394ba:	2c01      	cmp	r4, #1
 80394bc:	f04f 0400 	mov.w	r4, #0
        SUBGRF_SetPacketType( PACKET_TYPE_BPSK );
 80394c0:	bf94      	ite	ls
 80394c2:	2002      	movls	r0, #2
        SUBGRF_SetPacketType( PACKET_TYPE_GFSK );
 80394c4:	4620      	movhi	r0, r4
 80394c6:	f000 ffbb 	bl	803a440 <SUBGRF_SetPacketType>
        SubgRf.PublicNetwork.Current = false;
 80394ca:	736c      	strb	r4, [r5, #13]
}
 80394cc:	bd38      	pop	{r3, r4, r5, pc}
        SUBGRF_SetPacketType( PACKET_TYPE_LORA );
 80394ce:	4620      	mov	r0, r4
 80394d0:	f000 ffb6 	bl	803a440 <SUBGRF_SetPacketType>
        if( SubgRf.PublicNetwork.Current != SubgRf.PublicNetwork.Previous )
 80394d4:	7b28      	ldrb	r0, [r5, #12]
 80394d6:	7b6b      	ldrb	r3, [r5, #13]
 80394d8:	4283      	cmp	r3, r0
 80394da:	d0f7      	beq.n	80394cc <RadioSetModem+0x24>
            SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous;
 80394dc:	7368      	strb	r0, [r5, #13]
}
 80394de:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
            RadioSetPublicNetwork( SubgRf.PublicNetwork.Current );
 80394e2:	f7ff bfc3 	b.w	803946c <RadioSetPublicNetwork>
 80394e6:	bf00      	nop
 80394e8:	20006324 	.word	0x20006324

080394ec <RadioSetTxGenericConfig>:
    }
    return status;
}

static int32_t RadioSetTxGenericConfig( GenericModems_t modem, TxConfigGeneric_t* config, int8_t power, uint32_t timeout )
{
 80394ec:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80394f0:	4605      	mov	r5, r0
 80394f2:	b087      	sub	sp, #28
    uint8_t syncword[8] = {0};
 80394f4:	2700      	movs	r7, #0
 80394f6:	e9cd 7701 	strd	r7, r7, [sp, #4]
{
 80394fa:	460c      	mov	r4, r1
 80394fc:	4691      	mov	r9, r2
 80394fe:	4698      	mov	r8, r3
    RFW_DeInit( ); /* switch Off FwPacketDecoding by default */
 8039500:	f001 fb05 	bl	803ab0e <RFW_DeInit>
    switch( modem )
 8039504:	2d01      	cmp	r5, #1
 8039506:	d078      	beq.n	80395fa <RadioSetTxGenericConfig+0x10e>
 8039508:	2d02      	cmp	r5, #2
 803950a:	f000 80c4 	beq.w	8039696 <RadioSetTxGenericConfig+0x1aa>
 803950e:	2d00      	cmp	r5, #0
 8039510:	d15c      	bne.n	80395cc <RadioSetTxGenericConfig+0xe0>
    {
    case GENERIC_FSK:
        if( ( config->fsk.BitRate == 0 ) || ( config->fsk.PreambleLen == 0 ) )
 8039512:	68a3      	ldr	r3, [r4, #8]
 8039514:	2b00      	cmp	r3, #0
 8039516:	f000 80d2 	beq.w	80396be <RadioSetTxGenericConfig+0x1d2>
 803951a:	6922      	ldr	r2, [r4, #16]
 803951c:	2a00      	cmp	r2, #0
 803951e:	f000 80ce 	beq.w	80396be <RadioSetTxGenericConfig+0x1d2>
        {
            return -1;
        }
        if( config->fsk.SyncWordLength > 8 )
 8039522:	7d22      	ldrb	r2, [r4, #20]
 8039524:	2a08      	cmp	r2, #8
 8039526:	f200 80ca 	bhi.w	80396be <RadioSetTxGenericConfig+0x1d2>
        }
        else
        {
            for(int i = 0; i < config->fsk.SyncWordLength; i++)
            {
                syncword[i] = config->fsk.SyncWord[i];
 803952a:	a901      	add	r1, sp, #4
            for(int i = 0; i < config->fsk.SyncWordLength; i++)
 803952c:	42aa      	cmp	r2, r5
 803952e:	dc5b      	bgt.n	80395e8 <RadioSetTxGenericConfig+0xfc>
            }
        }
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 8039530:	4d64      	ldr	r5, [pc, #400]	; (80396c4 <RadioSetTxGenericConfig+0x1d8>)
 8039532:	2600      	movs	r6, #0
 8039534:	f885 6038 	strb.w	r6, [r5, #56]	; 0x38
        SubgRf.ModulationParams.Params.Gfsk.BitRate = config->fsk.BitRate;
 8039538:	63eb      	str	r3, [r5, #60]	; 0x3c
        SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = ( RadioModShapings_t ) config->fsk.ModulationShaping;
 803953a:	7823      	ldrb	r3, [r4, #0]
 803953c:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
        SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( config->fsk.Bandwidth );
 8039540:	6860      	ldr	r0, [r4, #4]
 8039542:	f001 fa85 	bl	803aa50 <SUBGRF_GetFskBandwidthRegValue>
 8039546:	f885 0045 	strb.w	r0, [r5, #69]	; 0x45
        SubgRf.ModulationParams.Params.Gfsk.Fdev = config->fsk.FrequencyDeviation;
 803954a:	68e3      	ldr	r3, [r4, #12]
 803954c:	642b      	str	r3, [r5, #64]	; 0x40
    
        SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
        SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( config->fsk.PreambleLen ) << 3; // convert byte into bit
 803954e:	6923      	ldr	r3, [r4, #16]
        SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS; // don't care in tx
        SubgRf.PacketParams.Params.Gfsk.SyncWordLength = ( config->fsk.SyncWordLength ) << 3; // convert byte into bit
        SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF; // don't care in tx

        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING ) || ( config->fsk.HeaderType == RADIO_FSK_PACKET_2BYTES_LENGTH ) )
 8039550:	f894 1024 	ldrb.w	r1, [r4, #36]	; 0x24
        SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 8039554:	73ae      	strb	r6, [r5, #14]
        SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( config->fsk.PreambleLen ) << 3; // convert byte into bit
 8039556:	00db      	lsls	r3, r3, #3
 8039558:	822b      	strh	r3, [r5, #16]
        SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS; // don't care in tx
 803955a:	2304      	movs	r3, #4
 803955c:	74ab      	strb	r3, [r5, #18]
        SubgRf.PacketParams.Params.Gfsk.SyncWordLength = ( config->fsk.SyncWordLength ) << 3; // convert byte into bit
 803955e:	7d23      	ldrb	r3, [r4, #20]
        SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF; // don't care in tx
 8039560:	752e      	strb	r6, [r5, #20]
        SubgRf.PacketParams.Params.Gfsk.SyncWordLength = ( config->fsk.SyncWordLength ) << 3; // convert byte into bit
 8039562:	00db      	lsls	r3, r3, #3
        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING ) || ( config->fsk.HeaderType == RADIO_FSK_PACKET_2BYTES_LENGTH ) )
 8039564:	2902      	cmp	r1, #2
        SubgRf.PacketParams.Params.Gfsk.SyncWordLength = ( config->fsk.SyncWordLength ) << 3; // convert byte into bit
 8039566:	74eb      	strb	r3, [r5, #19]
        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING ) || ( config->fsk.HeaderType == RADIO_FSK_PACKET_2BYTES_LENGTH ) )
 8039568:	462e      	mov	r6, r5
 803956a:	7fe3      	ldrb	r3, [r4, #31]
 803956c:	d002      	beq.n	8039574 <RadioSetTxGenericConfig+0x88>
 803956e:	7fa2      	ldrb	r2, [r4, #30]
 8039570:	2a02      	cmp	r2, #2
 8039572:	d13e      	bne.n	80395f2 <RadioSetTxGenericConfig+0x106>
        {
            /* Supports only RADIO_FSK_CRC_2_BYTES_IBM or RADIO_FSK_CRC_2_BYTES_CCIT */
            if( ( config->fsk.CrcLength != RADIO_FSK_CRC_2_BYTES_IBM ) && ( config->fsk.CrcLength != RADIO_FSK_CRC_2_BYTES_CCIT ) &&( config->fsk.CrcLength != RADIO_FSK_CRC_OFF ) )
 8039574:	f103 020f 	add.w	r2, r3, #15
 8039578:	b2d2      	uxtb	r2, r2
 803957a:	2a01      	cmp	r2, #1
 803957c:	d902      	bls.n	8039584 <RadioSetTxGenericConfig+0x98>
 803957e:	2b01      	cmp	r3, #1
 8039580:	f040 809d 	bne.w	80396be <RadioSetTxGenericConfig+0x1d2>
                return -1;
            }
            ConfigGeneric_t ConfigGeneric;
            ConfigGeneric.rtx = CONFIG_TX;
            ConfigGeneric.TxConfig = config;
            if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &TxTimeoutTimer ) )
 8039584:	4b50      	ldr	r3, [pc, #320]	; (80396c8 <RadioSetTxGenericConfig+0x1dc>)
 8039586:	4a51      	ldr	r2, [pc, #324]	; (80396cc <RadioSetTxGenericConfig+0x1e0>)
 8039588:	6819      	ldr	r1, [r3, #0]
            ConfigGeneric.TxConfig = config;
 803958a:	9403      	str	r4, [sp, #12]
            ConfigGeneric.rtx = CONFIG_TX;
 803958c:	2501      	movs	r5, #1
            if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &TxTimeoutTimer ) )
 803958e:	a803      	add	r0, sp, #12
            ConfigGeneric.rtx = CONFIG_TX;
 8039590:	f88d 5014 	strb.w	r5, [sp, #20]
            if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &TxTimeoutTimer ) )
 8039594:	f001 fab8 	bl	803ab08 <RFW_Init>
 8039598:	2800      	cmp	r0, #0
 803959a:	f040 8090 	bne.w	80396be <RadioSetTxGenericConfig+0x1d2>
            {
              return -1;
            }
            /* whitening off, will be processed by FW, switch off built-in radio whitening */
            SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) RADIO_FSK_DC_FREE_OFF;
 803959e:	7630      	strb	r0, [r6, #24]
            /* Crc processed by FW, switch off built-in radio Crc */
            SubgRf.PacketParams.Params.Gfsk.CrcLength = (RadioCrcTypes_t) RADIO_CRC_OFF;
 80395a0:	75f5      	strb	r5, [r6, #23]
            /* length contained in Tx, but will be processed by FW after de-whitening */
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) RADIO_PACKET_FIXED_LENGTH;
 80395a2:	7570      	strb	r0, [r6, #21]
          SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) config->fsk.CrcLength;
          SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) config->fsk.Whitening;
          SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) config->fsk.HeaderType;
        }

        RadioStandby( );
 80395a4:	f7ff fcf8 	bl	8038f98 <RadioStandby>
        RadioSetModem( MODEM_FSK );
 80395a8:	2000      	movs	r0, #0
 80395aa:	f7ff ff7d 	bl	80394a8 <RadioSetModem>
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 80395ae:	4848      	ldr	r0, [pc, #288]	; (80396d0 <RadioSetTxGenericConfig+0x1e4>)
 80395b0:	f000 ff5c 	bl	803a46c <SUBGRF_SetModulationParams>
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 80395b4:	4847      	ldr	r0, [pc, #284]	; (80396d4 <RadioSetTxGenericConfig+0x1e8>)
 80395b6:	f001 f8ef 	bl	803a798 <SUBGRF_SetPacketParams>
        SUBGRF_SetSyncWord( syncword );
 80395ba:	a801      	add	r0, sp, #4
 80395bc:	f001 f8be 	bl	803a73c <SUBGRF_SetSyncWord>
        SUBGRF_SetWhiteningSeed( config->fsk.whiteSeed );
 80395c0:	8ba0      	ldrh	r0, [r4, #28]
 80395c2:	f001 f82d 	bl	803a620 <SUBGRF_SetWhiteningSeed>
        SUBGRF_SetCrcPolynomial(config->fsk.CrcPolynomial );
 80395c6:	8c20      	ldrh	r0, [r4, #32]
 80395c8:	f001 f8d4 	bl	803a774 <SUBGRF_SetCrcPolynomial>
        break;
    default:
        break;
    }

    SubgRf.AntSwitchPaSelect = SUBGRF_SetRfTxPower( power );
 80395cc:	4648      	mov	r0, r9
 80395ce:	f001 f9e6 	bl	803a99e <SUBGRF_SetRfTxPower>
 80395d2:	4c3c      	ldr	r4, [pc, #240]	; (80396c4 <RadioSetTxGenericConfig+0x1d8>)
 80395d4:	f884 0056 	strb.w	r0, [r4, #86]	; 0x56
    RFW_SetAntSwitch( SubgRf.AntSwitchPaSelect );
 80395d8:	f001 fa9e 	bl	803ab18 <RFW_SetAntSwitch>
    SubgRf.TxTimeout = timeout;
 80395dc:	f8c4 8004 	str.w	r8, [r4, #4]
    return 0;
 80395e0:	2000      	movs	r0, #0
}
 80395e2:	b007      	add	sp, #28
 80395e4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
                syncword[i] = config->fsk.SyncWord[i];
 80395e8:	69a0      	ldr	r0, [r4, #24]
 80395ea:	5d40      	ldrb	r0, [r0, r5]
 80395ec:	5468      	strb	r0, [r5, r1]
            for(int i = 0; i < config->fsk.SyncWordLength; i++)
 80395ee:	3501      	adds	r5, #1
 80395f0:	e79c      	b.n	803952c <RadioSetTxGenericConfig+0x40>
          SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) config->fsk.CrcLength;
 80395f2:	75eb      	strb	r3, [r5, #23]
          SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) config->fsk.Whitening;
 80395f4:	7629      	strb	r1, [r5, #24]
          SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) config->fsk.HeaderType;
 80395f6:	756a      	strb	r2, [r5, #21]
 80395f8:	e7d4      	b.n	80395a4 <RadioSetTxGenericConfig+0xb8>
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_LORA;
 80395fa:	4e32      	ldr	r6, [pc, #200]	; (80396c4 <RadioSetTxGenericConfig+0x1d8>)
 80395fc:	f886 5038 	strb.w	r5, [r6, #56]	; 0x38
        SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t ) config->lora.SpreadingFactor;
 8039600:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 8039604:	f886 3050 	strb.w	r3, [r6, #80]	; 0x50
        SubgRf.ModulationParams.Params.LoRa.Bandwidth = ( RadioLoRaBandwidths_t ) config->lora.Bandwidth;
 8039608:	f894 2029 	ldrb.w	r2, [r4, #41]	; 0x29
 803960c:	f886 2051 	strb.w	r2, [r6, #81]	; 0x51
        SubgRf.ModulationParams.Params.LoRa.CodingRate = ( RadioLoRaCodingRates_t ) config->lora.Coderate;
 8039610:	f894 202a 	ldrb.w	r2, [r4, #42]	; 0x2a
 8039614:	f886 2052 	strb.w	r2, [r6, #82]	; 0x52
        switch( config->lora.LowDatarateOptimize )
 8039618:	f894 102b 	ldrb.w	r1, [r4, #43]	; 0x2b
 803961c:	2901      	cmp	r1, #1
 803961e:	d002      	beq.n	8039626 <RadioSetTxGenericConfig+0x13a>
 8039620:	2902      	cmp	r1, #2
 8039622:	d02b      	beq.n	803967c <RadioSetTxGenericConfig+0x190>
 8039624:	b909      	cbnz	r1, 803962a <RadioSetTxGenericConfig+0x13e>
            SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 1;
 8039626:	f886 1053 	strb.w	r1, [r6, #83]	; 0x53
        SubgRf.PacketParams.Params.LoRa.PreambleLength = config->lora.PreambleLen;
 803962a:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 803962c:	83b3      	strh	r3, [r6, #28]
        SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t ) config->lora.LengthMode;
 803962e:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
 8039632:	77b3      	strb	r3, [r6, #30]
        SubgRf.PacketParams.Params.LoRa.CrcMode = ( RadioLoRaCrcModes_t ) config->lora.CrcMode;
 8039634:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
 8039638:	f886 3020 	strb.w	r3, [r6, #32]
        SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 803963c:	2501      	movs	r5, #1
        SubgRf.PacketParams.Params.LoRa.InvertIQ = ( RadioLoRaIQModes_t ) config->lora.IqInverted;
 803963e:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
 8039642:	f886 3021 	strb.w	r3, [r6, #33]	; 0x21
        SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 8039646:	73b5      	strb	r5, [r6, #14]
        RadioStandby( );
 8039648:	f7ff fca6 	bl	8038f98 <RadioStandby>
        RadioSetModem( MODEM_LORA );
 803964c:	4628      	mov	r0, r5
 803964e:	f7ff ff2b 	bl	80394a8 <RadioSetModem>
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8039652:	481f      	ldr	r0, [pc, #124]	; (80396d0 <RadioSetTxGenericConfig+0x1e4>)
 8039654:	f000 ff0a 	bl	803a46c <SUBGRF_SetModulationParams>
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039658:	481e      	ldr	r0, [pc, #120]	; (80396d4 <RadioSetTxGenericConfig+0x1e8>)
 803965a:	f001 f89d 	bl	803a798 <SUBGRF_SetPacketParams>
        if( SubgRf.ModulationParams.Params.LoRa.Bandwidth == LORA_BW_500 )
 803965e:	f896 3051 	ldrb.w	r3, [r6, #81]	; 0x51
 8039662:	2b06      	cmp	r3, #6
            SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) & ~( 1 << 2 ) );
 8039664:	f640 0089 	movw	r0, #2185	; 0x889
        if( SubgRf.ModulationParams.Params.LoRa.Bandwidth == LORA_BW_500 )
 8039668:	d10f      	bne.n	803968a <RadioSetTxGenericConfig+0x19e>
            SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) & ~( 1 << 2 ) );
 803966a:	f000 ff6b 	bl	803a544 <SUBGRF_ReadRegister>
 803966e:	f000 01fb 	and.w	r1, r0, #251	; 0xfb
            SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) | ( 1 << 2 ) );
 8039672:	f640 0089 	movw	r0, #2185	; 0x889
 8039676:	f000 fe9f 	bl	803a3b8 <SUBGRF_WriteRegister>
 803967a:	e7a7      	b.n	80395cc <RadioSetTxGenericConfig+0xe0>
            if( ( config->lora.SpreadingFactor == RADIO_LORA_SF11 ) || ( config->lora.SpreadingFactor == RADIO_LORA_SF12 ) )
 803967c:	3b0b      	subs	r3, #11
              SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 1;
 803967e:	2b01      	cmp	r3, #1
 8039680:	bf88      	it	hi
 8039682:	463d      	movhi	r5, r7
 8039684:	f886 5053 	strb.w	r5, [r6, #83]	; 0x53
 8039688:	e7cf      	b.n	803962a <RadioSetTxGenericConfig+0x13e>
            SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) | ( 1 << 2 ) );
 803968a:	f000 ff5b 	bl	803a544 <SUBGRF_ReadRegister>
 803968e:	f040 0104 	orr.w	r1, r0, #4
 8039692:	b2c9      	uxtb	r1, r1
 8039694:	e7ed      	b.n	8039672 <RadioSetTxGenericConfig+0x186>
        if( ( config->bpsk.BitRate == 0 ) || ( config->bpsk.BitRate > 1000 ) )
 8039696:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8039698:	3b01      	subs	r3, #1
 803969a:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 803969e:	d20e      	bcs.n	80396be <RadioSetTxGenericConfig+0x1d2>
        RadioSetModem( MODEM_BPSK );
 80396a0:	4628      	mov	r0, r5
 80396a2:	f7ff ff01 	bl	80394a8 <RadioSetModem>
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_BPSK;
 80396a6:	4807      	ldr	r0, [pc, #28]	; (80396c4 <RadioSetTxGenericConfig+0x1d8>)
 80396a8:	f880 5038 	strb.w	r5, [r0, #56]	; 0x38
        SubgRf.ModulationParams.Params.Bpsk.BitRate = config->bpsk.BitRate;
 80396ac:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80396ae:	6483      	str	r3, [r0, #72]	; 0x48
        SubgRf.ModulationParams.Params.Bpsk.ModulationShaping = MOD_SHAPING_DBPSK;
 80396b0:	2316      	movs	r3, #22
 80396b2:	f880 304c 	strb.w	r3, [r0, #76]	; 0x4c
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 80396b6:	3038      	adds	r0, #56	; 0x38
 80396b8:	f000 fed8 	bl	803a46c <SUBGRF_SetModulationParams>
        break;
 80396bc:	e786      	b.n	80395cc <RadioSetTxGenericConfig+0xe0>
            return -1;
 80396be:	f04f 30ff 	mov.w	r0, #4294967295
 80396c2:	e78e      	b.n	80395e2 <RadioSetTxGenericConfig+0xf6>
 80396c4:	20006324 	.word	0x20006324
 80396c8:	2000597c 	.word	0x2000597c
 80396cc:	2000637c 	.word	0x2000637c
 80396d0:	2000635c 	.word	0x2000635c
 80396d4:	20006332 	.word	0x20006332

080396d8 <RadioSetRxGenericConfig>:
{
 80396d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uint8_t syncword[8] = {0};
 80396dc:	2600      	movs	r6, #0
{
 80396de:	b086      	sub	sp, #24
 80396e0:	4698      	mov	r8, r3
 80396e2:	4614      	mov	r4, r2
    uint8_t syncword[8] = {0};
 80396e4:	e9cd 6601 	strd	r6, r6, [sp, #4]
{
 80396e8:	4607      	mov	r7, r0
 80396ea:	460d      	mov	r5, r1
    RFW_DeInit( ); /* switch Off FwPacketDecoding by default */
 80396ec:	f001 fa0f 	bl	803ab0e <RFW_DeInit>
        symbTimeout = 0;
 80396f0:	42b4      	cmp	r4, r6
    SubgRf.RxContinuous = ( rxContinuous == 0 ) ? false : true;
 80396f2:	4c77      	ldr	r4, [pc, #476]	; (80398d0 <RadioSetRxGenericConfig+0x1f8>)
 80396f4:	bf16      	itet	ne
 80396f6:	2301      	movne	r3, #1
 80396f8:	4633      	moveq	r3, r6
        symbTimeout = 0;
 80396fa:	46b0      	movne	r8, r6
    SubgRf.RxContinuous = ( rxContinuous == 0 ) ? false : true;
 80396fc:	7063      	strb	r3, [r4, #1]
    switch( modem )
 80396fe:	b137      	cbz	r7, 803970e <RadioSetRxGenericConfig+0x36>
 8039700:	2f01      	cmp	r7, #1
 8039702:	f000 8082 	beq.w	803980a <RadioSetRxGenericConfig+0x132>
    return status;
 8039706:	2000      	movs	r0, #0
}
 8039708:	b006      	add	sp, #24
 803970a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if( ( config->fsk.BitRate == 0 ) || ( config->fsk.PreambleLen == 0 ) )
 803970e:	68eb      	ldr	r3, [r5, #12]
 8039710:	2b00      	cmp	r3, #0
 8039712:	f000 80d9 	beq.w	80398c8 <RadioSetRxGenericConfig+0x1f0>
 8039716:	692b      	ldr	r3, [r5, #16]
 8039718:	2b00      	cmp	r3, #0
 803971a:	f000 80d5 	beq.w	80398c8 <RadioSetRxGenericConfig+0x1f0>
        if( config->fsk.SyncWordLength > 8 )
 803971e:	7d6b      	ldrb	r3, [r5, #21]
 8039720:	2b08      	cmp	r3, #8
 8039722:	f200 80d1 	bhi.w	80398c8 <RadioSetRxGenericConfig+0x1f0>
            for(int i = 0; i < config->fsk.SyncWordLength; i++)
 8039726:	4638      	mov	r0, r7
                syncword[i] = config->fsk.SyncWord[i];
 8039728:	aa01      	add	r2, sp, #4
            for(int i = 0; i < config->fsk.SyncWordLength; i++)
 803972a:	4283      	cmp	r3, r0
 803972c:	dc62      	bgt.n	80397f4 <RadioSetRxGenericConfig+0x11c>
        SUBGRF_SetStopRxTimerOnPreambleDetect( ( config->fsk.StopTimerOnPreambleDetect == 0 ) ? false : true );
 803972e:	6828      	ldr	r0, [r5, #0]
 8039730:	3800      	subs	r0, #0
 8039732:	bf18      	it	ne
 8039734:	2001      	movne	r0, #1
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 8039736:	2600      	movs	r6, #0
        SUBGRF_SetStopRxTimerOnPreambleDetect( ( config->fsk.StopTimerOnPreambleDetect == 0 ) ? false : true );
 8039738:	f000 fd32 	bl	803a1a0 <SUBGRF_SetStopRxTimerOnPreambleDetect>
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 803973c:	f884 6038 	strb.w	r6, [r4, #56]	; 0x38
        SubgRf.ModulationParams.Params.Gfsk.BitRate = config->fsk.BitRate;
 8039740:	68eb      	ldr	r3, [r5, #12]
 8039742:	63e3      	str	r3, [r4, #60]	; 0x3c
        SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = (RadioModShapings_t) config->fsk.ModulationShaping;
 8039744:	792b      	ldrb	r3, [r5, #4]
 8039746:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
        SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( config->fsk.Bandwidth );
 803974a:	68a8      	ldr	r0, [r5, #8]
 803974c:	f001 f980 	bl	803aa50 <SUBGRF_GetFskBandwidthRegValue>
 8039750:	f884 0045 	strb.w	r0, [r4, #69]	; 0x45
        SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( config->fsk.PreambleLen ) << 3 ; // convert byte into bit
 8039754:	692b      	ldr	r3, [r5, #16]
        SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 8039756:	73a6      	strb	r6, [r4, #14]
        SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( config->fsk.PreambleLen ) << 3 ; // convert byte into bit
 8039758:	00db      	lsls	r3, r3, #3
 803975a:	8223      	strh	r3, [r4, #16]
        SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = ( RadioPreambleDetection_t ) config->fsk.PreambleMinDetect;
 803975c:	7d2b      	ldrb	r3, [r5, #20]
 803975e:	74a3      	strb	r3, [r4, #18]
        SubgRf.PacketParams.Params.Gfsk.SyncWordLength = ( config->fsk.SyncWordLength ) << 3; // convert byte into bit
 8039760:	7d6b      	ldrb	r3, [r5, #21]
 8039762:	00db      	lsls	r3, r3, #3
 8039764:	74e3      	strb	r3, [r4, #19]
        SubgRf.PacketParams.Params.Gfsk.AddrComp = ( RadioAddressComp_t ) config->fsk.AddrComp;
 8039766:	f895 3022 	ldrb.w	r3, [r5, #34]	; 0x22
 803976a:	7523      	strb	r3, [r4, #20]
        if( config->fsk.LengthMode == RADIO_FSK_PACKET_FIXED_LENGTH )
 803976c:	f895 3023 	ldrb.w	r3, [r5, #35]	; 0x23
 8039770:	2b00      	cmp	r3, #0
 8039772:	d144      	bne.n	80397fe <RadioSetRxGenericConfig+0x126>
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = config->fsk.MaxPayloadLength;
 8039774:	69ea      	ldr	r2, [r5, #28]
        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING ) || ( config->fsk.LengthMode == RADIO_FSK_PACKET_2BYTES_LENGTH ) )
 8039776:	f895 102a 	ldrb.w	r1, [r5, #42]	; 0x2a
          SubgRf.PacketParams.Params.Gfsk.PayloadLength = 0xFF;
 803977a:	75a2      	strb	r2, [r4, #22]
        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING ) || ( config->fsk.LengthMode == RADIO_FSK_PACKET_2BYTES_LENGTH ) )
 803977c:	2902      	cmp	r1, #2
 803977e:	f895 2024 	ldrb.w	r2, [r5, #36]	; 0x24
 8039782:	d001      	beq.n	8039788 <RadioSetRxGenericConfig+0xb0>
 8039784:	2b02      	cmp	r3, #2
 8039786:	d13c      	bne.n	8039802 <RadioSetRxGenericConfig+0x12a>
          if( ( config->fsk.CrcLength != RADIO_FSK_CRC_2_BYTES_IBM ) && ( config->fsk.CrcLength != RADIO_FSK_CRC_2_BYTES_CCIT ) && ( config->fsk.CrcLength != RADIO_FSK_CRC_OFF ) )
 8039788:	f102 030f 	add.w	r3, r2, #15
 803978c:	b2db      	uxtb	r3, r3
 803978e:	2b01      	cmp	r3, #1
 8039790:	d902      	bls.n	8039798 <RadioSetRxGenericConfig+0xc0>
 8039792:	2a01      	cmp	r2, #1
 8039794:	f040 8098 	bne.w	80398c8 <RadioSetRxGenericConfig+0x1f0>
          ConfigGeneric.rtx = CONFIG_RX;
 8039798:	2300      	movs	r3, #0
 803979a:	f88d 3014 	strb.w	r3, [sp, #20]
          if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &RxTimeoutTimer ) )
 803979e:	4b4d      	ldr	r3, [pc, #308]	; (80398d4 <RadioSetRxGenericConfig+0x1fc>)
 80397a0:	4a4d      	ldr	r2, [pc, #308]	; (80398d8 <RadioSetRxGenericConfig+0x200>)
 80397a2:	6819      	ldr	r1, [r3, #0]
          ConfigGeneric.RxConfig = config;
 80397a4:	9504      	str	r5, [sp, #16]
          if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &RxTimeoutTimer ) )
 80397a6:	a803      	add	r0, sp, #12
 80397a8:	f001 f9ae 	bl	803ab08 <RFW_Init>
 80397ac:	2800      	cmp	r0, #0
 80397ae:	f040 808b 	bne.w	80398c8 <RadioSetRxGenericConfig+0x1f0>
          SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) RADIO_CRC_OFF;
 80397b2:	2301      	movs	r3, #1
          SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) RADIO_FSK_DC_FREE_OFF;
 80397b4:	7620      	strb	r0, [r4, #24]
          SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) RADIO_CRC_OFF;
 80397b6:	75e3      	strb	r3, [r4, #23]
          SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) RADIO_PACKET_FIXED_LENGTH;
 80397b8:	7560      	strb	r0, [r4, #21]
        RadioStandby( );
 80397ba:	f7ff fbed 	bl	8038f98 <RadioStandby>
        RadioSetModem( MODEM_FSK );
 80397be:	2000      	movs	r0, #0
 80397c0:	f7ff fe72 	bl	80394a8 <RadioSetModem>
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 80397c4:	4845      	ldr	r0, [pc, #276]	; (80398dc <RadioSetRxGenericConfig+0x204>)
 80397c6:	f000 fe51 	bl	803a46c <SUBGRF_SetModulationParams>
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 80397ca:	4845      	ldr	r0, [pc, #276]	; (80398e0 <RadioSetRxGenericConfig+0x208>)
 80397cc:	f000 ffe4 	bl	803a798 <SUBGRF_SetPacketParams>
        SUBGRF_SetSyncWord( syncword );
 80397d0:	a801      	add	r0, sp, #4
 80397d2:	f000 ffb3 	bl	803a73c <SUBGRF_SetSyncWord>
        SUBGRF_SetWhiteningSeed( config->fsk.whiteSeed );
 80397d6:	8c28      	ldrh	r0, [r5, #32]
 80397d8:	f000 ff22 	bl	803a620 <SUBGRF_SetWhiteningSeed>
        SUBGRF_SetCrcPolynomial( config->fsk.CrcPolynomial );
 80397dc:	8ce8      	ldrh	r0, [r5, #38]	; 0x26
 80397de:	f000 ffc9 	bl	803a774 <SUBGRF_SetCrcPolynomial>
        SubgRf.RxTimeout = ( uint32_t )( ( symbTimeout * 1000 * 8 ) / config->fsk.BitRate );
 80397e2:	f44f 53fa 	mov.w	r3, #8000	; 0x1f40
 80397e6:	fb03 f808 	mul.w	r8, r3, r8
 80397ea:	68eb      	ldr	r3, [r5, #12]
 80397ec:	fbb8 f3f3 	udiv	r3, r8, r3
        SubgRf.RxTimeout = 0xFFFF;
 80397f0:	60a3      	str	r3, [r4, #8]
 80397f2:	e788      	b.n	8039706 <RadioSetRxGenericConfig+0x2e>
                syncword[i] = config->fsk.SyncWord[i];
 80397f4:	69a9      	ldr	r1, [r5, #24]
 80397f6:	5c09      	ldrb	r1, [r1, r0]
 80397f8:	5481      	strb	r1, [r0, r2]
            for(int i = 0; i < config->fsk.SyncWordLength; i++)
 80397fa:	3001      	adds	r0, #1
 80397fc:	e795      	b.n	803972a <RadioSetRxGenericConfig+0x52>
          SubgRf.PacketParams.Params.Gfsk.PayloadLength = 0xFF;
 80397fe:	22ff      	movs	r2, #255	; 0xff
 8039800:	e7b9      	b.n	8039776 <RadioSetRxGenericConfig+0x9e>
          SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) config->fsk.CrcLength;
 8039802:	75e2      	strb	r2, [r4, #23]
          SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) config->fsk.Whitening;
 8039804:	7621      	strb	r1, [r4, #24]
          SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) config->fsk.LengthMode;
 8039806:	7563      	strb	r3, [r4, #21]
 8039808:	e7d7      	b.n	80397ba <RadioSetRxGenericConfig+0xe2>
        if( config->lora.PreambleLen == 0 )
 803980a:	8eab      	ldrh	r3, [r5, #52]	; 0x34
 803980c:	2b00      	cmp	r3, #0
 803980e:	d05b      	beq.n	80398c8 <RadioSetRxGenericConfig+0x1f0>
        if( config->lora.LengthMode == RADIO_LORA_PACKET_FIXED_LENGTH )
 8039810:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
        SUBGRF_SetStopRxTimerOnPreambleDetect( ( config->lora.StopTimerOnPreambleDetect == 0 ) ? false : true );
 8039814:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
        if( config->lora.LengthMode == RADIO_LORA_PACKET_FIXED_LENGTH )
 8039816:	2b01      	cmp	r3, #1
            MaxPayloadLength = config->fsk.MaxPayloadLength;
 8039818:	bf0c      	ite	eq
 803981a:	7f2f      	ldrbeq	r7, [r5, #28]
            MaxPayloadLength = 0xFF;
 803981c:	27ff      	movne	r7, #255	; 0xff
        SUBGRF_SetStopRxTimerOnPreambleDetect( ( config->lora.StopTimerOnPreambleDetect == 0 ) ? false : true );
 803981e:	3800      	subs	r0, #0
 8039820:	bf18      	it	ne
 8039822:	2001      	movne	r0, #1
 8039824:	f000 fcbc 	bl	803a1a0 <SUBGRF_SetStopRxTimerOnPreambleDetect>
        SUBGRF_SetLoRaSymbNumTimeout( symbTimeout );
 8039828:	fa5f f088 	uxtb.w	r0, r8
 803982c:	f000 fdf0 	bl	803a410 <SUBGRF_SetLoRaSymbNumTimeout>
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_LORA;
 8039830:	2101      	movs	r1, #1
 8039832:	f884 1038 	strb.w	r1, [r4, #56]	; 0x38
        SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t ) config->lora.SpreadingFactor;
 8039836:	f895 2030 	ldrb.w	r2, [r5, #48]	; 0x30
 803983a:	f884 2050 	strb.w	r2, [r4, #80]	; 0x50
        SubgRf.ModulationParams.Params.LoRa.Bandwidth = ( RadioLoRaBandwidths_t ) config->lora.Bandwidth;
 803983e:	f895 3031 	ldrb.w	r3, [r5, #49]	; 0x31
 8039842:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
        SubgRf.ModulationParams.Params.LoRa.CodingRate = ( RadioLoRaCodingRates_t ) config->lora.Coderate;
 8039846:	f895 3032 	ldrb.w	r3, [r5, #50]	; 0x32
 803984a:	f884 3052 	strb.w	r3, [r4, #82]	; 0x52
        switch( config->lora.LowDatarateOptimize )
 803984e:	f895 3033 	ldrb.w	r3, [r5, #51]	; 0x33
 8039852:	428b      	cmp	r3, r1
 8039854:	d002      	beq.n	803985c <RadioSetRxGenericConfig+0x184>
 8039856:	2b02      	cmp	r3, #2
 8039858:	d003      	beq.n	8039862 <RadioSetRxGenericConfig+0x18a>
 803985a:	b93b      	cbnz	r3, 803986c <RadioSetRxGenericConfig+0x194>
              SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0;
 803985c:	f884 3053 	strb.w	r3, [r4, #83]	; 0x53
 8039860:	e004      	b.n	803986c <RadioSetRxGenericConfig+0x194>
            if( ( config->lora.SpreadingFactor == RADIO_LORA_SF11 ) || ( config->lora.SpreadingFactor == RADIO_LORA_SF12 ) )
 8039862:	3a0b      	subs	r2, #11
 8039864:	2a01      	cmp	r2, #1
 8039866:	d827      	bhi.n	80398b8 <RadioSetRxGenericConfig+0x1e0>
              SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 1;
 8039868:	f884 1053 	strb.w	r1, [r4, #83]	; 0x53
        SubgRf.PacketParams.Params.LoRa.PreambleLength = config->lora.PreambleLen;
 803986c:	8eab      	ldrh	r3, [r5, #52]	; 0x34
 803986e:	83a3      	strh	r3, [r4, #28]
        SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t ) config->lora.LengthMode;
 8039870:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
 8039874:	77a3      	strb	r3, [r4, #30]
        SubgRf.PacketParams.Params.LoRa.CrcMode = ( RadioLoRaCrcModes_t ) config->lora.CrcMode;
 8039876:	8f2b      	ldrh	r3, [r5, #56]	; 0x38
 8039878:	8423      	strh	r3, [r4, #32]
        SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 803987a:	2601      	movs	r6, #1
 803987c:	73a6      	strb	r6, [r4, #14]
        SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength;
 803987e:	77e7      	strb	r7, [r4, #31]
        RadioStandby( );
 8039880:	f7ff fb8a 	bl	8038f98 <RadioStandby>
        RadioSetModem( MODEM_LORA );
 8039884:	4630      	mov	r0, r6
 8039886:	f7ff fe0f 	bl	80394a8 <RadioSetModem>
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 803988a:	4814      	ldr	r0, [pc, #80]	; (80398dc <RadioSetRxGenericConfig+0x204>)
 803988c:	f000 fdee 	bl	803a46c <SUBGRF_SetModulationParams>
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039890:	4813      	ldr	r0, [pc, #76]	; (80398e0 <RadioSetRxGenericConfig+0x208>)
 8039892:	f000 ff81 	bl	803a798 <SUBGRF_SetPacketParams>
        if( SubgRf.PacketParams.Params.LoRa.InvertIQ == LORA_IQ_INVERTED )
 8039896:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
 803989a:	42b3      	cmp	r3, r6
            SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) & ~( 1 << 2 ) );
 803989c:	f240 7036 	movw	r0, #1846	; 0x736
        if( SubgRf.PacketParams.Params.LoRa.InvertIQ == LORA_IQ_INVERTED )
 80398a0:	d10c      	bne.n	80398bc <RadioSetRxGenericConfig+0x1e4>
            SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) & ~( 1 << 2 ) );
 80398a2:	f000 fe4f 	bl	803a544 <SUBGRF_ReadRegister>
 80398a6:	f000 01fb 	and.w	r1, r0, #251	; 0xfb
            SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) | ( 1 << 2 ) );
 80398aa:	f240 7036 	movw	r0, #1846	; 0x736
 80398ae:	f000 fd83 	bl	803a3b8 <SUBGRF_WriteRegister>
        SubgRf.RxTimeout = 0xFFFF;
 80398b2:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80398b6:	e79b      	b.n	80397f0 <RadioSetRxGenericConfig+0x118>
              SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0;
 80398b8:	2300      	movs	r3, #0
 80398ba:	e7cf      	b.n	803985c <RadioSetRxGenericConfig+0x184>
            SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) | ( 1 << 2 ) );
 80398bc:	f000 fe42 	bl	803a544 <SUBGRF_ReadRegister>
 80398c0:	f040 0104 	orr.w	r1, r0, #4
 80398c4:	b2c9      	uxtb	r1, r1
 80398c6:	e7f0      	b.n	80398aa <RadioSetRxGenericConfig+0x1d2>
            return -1;
 80398c8:	f04f 30ff 	mov.w	r0, #4294967295
 80398cc:	e71c      	b.n	8039708 <RadioSetRxGenericConfig+0x30>
 80398ce:	bf00      	nop
 80398d0:	20006324 	.word	0x20006324
 80398d4:	2000597c 	.word	0x2000597c
 80398d8:	20006394 	.word	0x20006394
 80398dc:	2000635c 	.word	0x2000635c
 80398e0:	20006332 	.word	0x20006332

080398e4 <RadioSetTxConfig>:
{
 80398e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80398e8:	b085      	sub	sp, #20
 80398ea:	4682      	mov	sl, r0
 80398ec:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 80398ee:	f8bd b040 	ldrh.w	fp, [sp, #64]	; 0x40
 80398f2:	f89d 7044 	ldrb.w	r7, [sp, #68]	; 0x44
 80398f6:	f89d 9048 	ldrb.w	r9, [sp, #72]	; 0x48
 80398fa:	9201      	str	r2, [sp, #4]
 80398fc:	4688      	mov	r8, r1
 80398fe:	461e      	mov	r6, r3
    RFW_DeInit(); /* ST_WORKAROUND: Switch Off FwPacketDecoding by default */
 8039900:	f001 f905 	bl	803ab0e <RFW_DeInit>
    switch( modem )
 8039904:	f1ba 0f01 	cmp.w	sl, #1
 8039908:	4c54      	ldr	r4, [pc, #336]	; (8039a5c <RadioSetTxConfig+0x178>)
 803990a:	d051      	beq.n	80399b0 <RadioSetTxConfig+0xcc>
 803990c:	f1ba 0f03 	cmp.w	sl, #3
 8039910:	f000 8094 	beq.w	8039a3c <RadioSetTxConfig+0x158>
 8039914:	f1ba 0f00 	cmp.w	sl, #0
 8039918:	d13e      	bne.n	8039998 <RadioSetTxConfig+0xb4>
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_1;
 803991a:	220b      	movs	r2, #11
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 803991c:	4630      	mov	r0, r6
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_1;
 803991e:	f884 2044 	strb.w	r2, [r4, #68]	; 0x44
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 8039922:	f884 a038 	strb.w	sl, [r4, #56]	; 0x38
            SubgRf.ModulationParams.Params.Gfsk.BitRate = datarate;
 8039926:	63e5      	str	r5, [r4, #60]	; 0x3c
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8039928:	f001 f892 	bl	803aa50 <SUBGRF_GetFskBandwidthRegValue>
            SubgRf.ModulationParams.Params.Gfsk.Fdev = fdev;
 803992c:	9b01      	ldr	r3, [sp, #4]
 803992e:	6423      	str	r3, [r4, #64]	; 0x40
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 8039930:	ea4f 03cb 	mov.w	r3, fp, lsl #3
            if( crcOn == true )
 8039934:	f1b9 0f00 	cmp.w	r9, #0
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 8039938:	8223      	strh	r3, [r4, #16]
            SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS;
 803993a:	f641 0304 	movw	r3, #6148	; 0x1804
 803993e:	8263      	strh	r3, [r4, #18]
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 8039940:	bf14      	ite	ne
 8039942:	23f2      	movne	r3, #242	; 0xf2
 8039944:	2301      	moveq	r3, #1
 8039946:	75e3      	strb	r3, [r4, #23]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( fixLen == true ) ? RADIO_PACKET_FIXED_LENGTH : RADIO_PACKET_VARIABLE_LENGTH;
 8039948:	f087 0701 	eor.w	r7, r7, #1
            SubgRf.PacketParams.Params.Gfsk.DcFree = RADIO_DC_FREEWHITENING;
 803994c:	2301      	movs	r3, #1
 803994e:	7623      	strb	r3, [r4, #24]
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8039950:	f884 0045 	strb.w	r0, [r4, #69]	; 0x45
            SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 8039954:	f884 a00e 	strb.w	sl, [r4, #14]
            SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF;
 8039958:	f884 a014 	strb.w	sl, [r4, #20]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( fixLen == true ) ? RADIO_PACKET_FIXED_LENGTH : RADIO_PACKET_VARIABLE_LENGTH;
 803995c:	7567      	strb	r7, [r4, #21]
            RadioStandby( );
 803995e:	f7ff fb1b 	bl	8038f98 <RadioStandby>
            RadioSetModem( ( SubgRf.ModulationParams.PacketType == PACKET_TYPE_GFSK ) ? MODEM_FSK : MODEM_LORA );
 8039962:	f894 0038 	ldrb.w	r0, [r4, #56]	; 0x38
 8039966:	3800      	subs	r0, #0
 8039968:	bf18      	it	ne
 803996a:	2001      	movne	r0, #1
 803996c:	f7ff fd9c 	bl	80394a8 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8039970:	f104 0038 	add.w	r0, r4, #56	; 0x38
 8039974:	f000 fd7a 	bl	803a46c <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039978:	f104 000e 	add.w	r0, r4, #14
 803997c:	f000 ff0c 	bl	803a798 <SUBGRF_SetPacketParams>
            SUBGRF_SetSyncWord( ( uint8_t[] ){ 0xC1, 0x94, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00 } );
 8039980:	4a37      	ldr	r2, [pc, #220]	; (8039a60 <RadioSetTxConfig+0x17c>)
 8039982:	6810      	ldr	r0, [r2, #0]
 8039984:	6851      	ldr	r1, [r2, #4]
 8039986:	ab02      	add	r3, sp, #8
 8039988:	c303      	stmia	r3!, {r0, r1}
 803998a:	a802      	add	r0, sp, #8
 803998c:	f000 fed6 	bl	803a73c <SUBGRF_SetSyncWord>
            SUBGRF_SetWhiteningSeed( 0x01FF );
 8039990:	f240 10ff 	movw	r0, #511	; 0x1ff
 8039994:	f000 fe44 	bl	803a620 <SUBGRF_SetWhiteningSeed>
    SubgRf.AntSwitchPaSelect = SUBGRF_SetRfTxPower( power );
 8039998:	4640      	mov	r0, r8
 803999a:	f001 f800 	bl	803a99e <SUBGRF_SetRfTxPower>
 803999e:	f884 0056 	strb.w	r0, [r4, #86]	; 0x56
    RFW_SetAntSwitch( SubgRf.AntSwitchPaSelect ); /* ST_WORKAROUND: ?????? */
 80399a2:	f001 f8b9 	bl	803ab18 <RFW_SetAntSwitch>
    SubgRf.TxTimeout = timeout;
 80399a6:	9b16      	ldr	r3, [sp, #88]	; 0x58
 80399a8:	6063      	str	r3, [r4, #4]
}
 80399aa:	b005      	add	sp, #20
 80399ac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            SubgRf.ModulationParams.Params.LoRa.Bandwidth =  Bandwidths[bandwidth];
 80399b0:	492c      	ldr	r1, [pc, #176]	; (8039a64 <RadioSetTxConfig+0x180>)
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_LORA;
 80399b2:	f884 a038 	strb.w	sl, [r4, #56]	; 0x38
            SubgRf.ModulationParams.Params.LoRa.Bandwidth =  Bandwidths[bandwidth];
 80399b6:	4431      	add	r1, r6
            SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t ) datarate;
 80399b8:	b2ea      	uxtb	r2, r5
            SubgRf.ModulationParams.Params.LoRa.Bandwidth =  Bandwidths[bandwidth];
 80399ba:	7909      	ldrb	r1, [r1, #4]
 80399bc:	f884 1051 	strb.w	r1, [r4, #81]	; 0x51
            SubgRf.ModulationParams.Params.LoRa.CodingRate= ( RadioLoRaCodingRates_t )coderate;
 80399c0:	f89d 103c 	ldrb.w	r1, [sp, #60]	; 0x3c
            SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t ) datarate;
 80399c4:	f884 2050 	strb.w	r2, [r4, #80]	; 0x50
            SubgRf.ModulationParams.Params.LoRa.CodingRate= ( RadioLoRaCodingRates_t )coderate;
 80399c8:	f884 1052 	strb.w	r1, [r4, #82]	; 0x52
            if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 80399cc:	bb56      	cbnz	r6, 8039a24 <RadioSetTxConfig+0x140>
 80399ce:	3d0b      	subs	r5, #11
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x00;
 80399d0:	2d01      	cmp	r5, #1
 80399d2:	bf8c      	ite	hi
 80399d4:	2500      	movhi	r5, #0
 80399d6:	2501      	movls	r5, #1
            SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 80399d8:	2101      	movs	r1, #1
            if( ( SubgRf.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF5 ) ||
 80399da:	3a05      	subs	r2, #5
 80399dc:	428a      	cmp	r2, r1
 80399de:	f884 5053 	strb.w	r5, [r4, #83]	; 0x53
            SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 80399e2:	73a1      	strb	r1, [r4, #14]
            if( ( SubgRf.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF5 ) ||
 80399e4:	d827      	bhi.n	8039a36 <RadioSetTxConfig+0x152>
                if( preambleLen < 12 )
 80399e6:	f1bb 0f0b 	cmp.w	fp, #11
 80399ea:	d824      	bhi.n	8039a36 <RadioSetTxConfig+0x152>
                    SubgRf.PacketParams.Params.LoRa.PreambleLength = 12;
 80399ec:	230c      	movs	r3, #12
 80399ee:	83a3      	strh	r3, [r4, #28]
            SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength;
 80399f0:	4b1d      	ldr	r3, [pc, #116]	; (8039a68 <RadioSetTxConfig+0x184>)
            SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t )fixLen;
 80399f2:	77a7      	strb	r7, [r4, #30]
            SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength;
 80399f4:	781b      	ldrb	r3, [r3, #0]
 80399f6:	77e3      	strb	r3, [r4, #31]
            SubgRf.PacketParams.Params.LoRa.InvertIQ = ( RadioLoRaIQModes_t )iqInverted;
 80399f8:	f89d 3054 	ldrb.w	r3, [sp, #84]	; 0x54
 80399fc:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
            SubgRf.PacketParams.Params.LoRa.CrcMode = ( RadioLoRaCrcModes_t )crcOn;
 8039a00:	f884 9020 	strb.w	r9, [r4, #32]
            RadioStandby( );
 8039a04:	f7ff fac8 	bl	8038f98 <RadioStandby>
            RadioSetModem( ( SubgRf.ModulationParams.PacketType == PACKET_TYPE_GFSK ) ? MODEM_FSK : MODEM_LORA );
 8039a08:	f894 0038 	ldrb.w	r0, [r4, #56]	; 0x38
 8039a0c:	3800      	subs	r0, #0
 8039a0e:	bf18      	it	ne
 8039a10:	2001      	movne	r0, #1
 8039a12:	f7ff fd49 	bl	80394a8 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8039a16:	4815      	ldr	r0, [pc, #84]	; (8039a6c <RadioSetTxConfig+0x188>)
 8039a18:	f000 fd28 	bl	803a46c <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039a1c:	4814      	ldr	r0, [pc, #80]	; (8039a70 <RadioSetTxConfig+0x18c>)
 8039a1e:	f000 febb 	bl	803a798 <SUBGRF_SetPacketParams>
            break;
 8039a22:	e7b9      	b.n	8039998 <RadioSetTxConfig+0xb4>
            if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 8039a24:	2e01      	cmp	r6, #1
 8039a26:	d104      	bne.n	8039a32 <RadioSetTxConfig+0x14e>
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x00;
 8039a28:	f1a5 030c 	sub.w	r3, r5, #12
 8039a2c:	425d      	negs	r5, r3
 8039a2e:	415d      	adcs	r5, r3
 8039a30:	e7d2      	b.n	80399d8 <RadioSetTxConfig+0xf4>
 8039a32:	2500      	movs	r5, #0
 8039a34:	e7d0      	b.n	80399d8 <RadioSetTxConfig+0xf4>
                    SubgRf.PacketParams.Params.LoRa.PreambleLength = preambleLen;
 8039a36:	f8a4 b01c 	strh.w	fp, [r4, #28]
 8039a3a:	e7d9      	b.n	80399f0 <RadioSetTxConfig+0x10c>
            RadioSetModem(MODEM_SIGFOX_TX);
 8039a3c:	4650      	mov	r0, sl
 8039a3e:	f7ff fd33 	bl	80394a8 <RadioSetModem>
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_BPSK;
 8039a42:	2302      	movs	r3, #2
 8039a44:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8039a48:	f104 0038 	add.w	r0, r4, #56	; 0x38
            SubgRf.ModulationParams.Params.Bpsk.ModulationShaping = MOD_SHAPING_DBPSK;
 8039a4c:	2316      	movs	r3, #22
            SubgRf.ModulationParams.Params.Bpsk.BitRate           = datarate;
 8039a4e:	64a5      	str	r5, [r4, #72]	; 0x48
            SubgRf.ModulationParams.Params.Bpsk.ModulationShaping = MOD_SHAPING_DBPSK;
 8039a50:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8039a54:	f000 fd0a 	bl	803a46c <SUBGRF_SetModulationParams>
            break;
 8039a58:	e79e      	b.n	8039998 <RadioSetTxConfig+0xb4>
 8039a5a:	bf00      	nop
 8039a5c:	20006324 	.word	0x20006324
 8039a60:	0803bbb0 	.word	0x0803bbb0
 8039a64:	0803bb7c 	.word	0x0803bb7c
 8039a68:	200035a0 	.word	0x200035a0
 8039a6c:	2000635c 	.word	0x2000635c
 8039a70:	20006332 	.word	0x20006332

08039a74 <RadioSetRxConfig>:
{
 8039a74:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8039a78:	b087      	sub	sp, #28
    SubgRf.RxContinuous = rxContinuous;
 8039a7a:	f8df b2d4 	ldr.w	fp, [pc, #724]	; 8039d50 <RadioSetRxConfig+0x2dc>
{
 8039a7e:	9301      	str	r3, [sp, #4]
 8039a80:	4605      	mov	r5, r0
 8039a82:	f89d 3054 	ldrb.w	r3, [sp, #84]	; 0x54
 8039a86:	f89d 0050 	ldrb.w	r0, [sp, #80]	; 0x50
 8039a8a:	f8bd 8048 	ldrh.w	r8, [sp, #72]	; 0x48
 8039a8e:	f89d 904c 	ldrb.w	r9, [sp, #76]	; 0x4c
 8039a92:	9003      	str	r0, [sp, #12]
 8039a94:	460f      	mov	r7, r1
 8039a96:	f89d 1064 	ldrb.w	r1, [sp, #100]	; 0x64
    SubgRf.RxContinuous = rxContinuous;
 8039a9a:	f88b 1001 	strb.w	r1, [fp, #1]
 8039a9e:	9102      	str	r1, [sp, #8]
{
 8039aa0:	f8bd 6044 	ldrh.w	r6, [sp, #68]	; 0x44
 8039aa4:	9300      	str	r3, [sp, #0]
 8039aa6:	4614      	mov	r4, r2
    RFW_DeInit(); /* ST_WORKAROUND: Switch Off FwPacketDecoding by default */
 8039aa8:	f001 f831 	bl	803ab0e <RFW_DeInit>
        symbTimeout = 0;
 8039aac:	9902      	ldr	r1, [sp, #8]
        MaxPayloadLength = 0xFF;
 8039aae:	9803      	ldr	r0, [sp, #12]
        symbTimeout = 0;
 8039ab0:	2900      	cmp	r1, #0
 8039ab2:	bf18      	it	ne
 8039ab4:	f04f 0800 	movne.w	r8, #0
    if( fixLen == true )
 8039ab8:	499f      	ldr	r1, [pc, #636]	; (8039d38 <RadioSetRxConfig+0x2c4>)
        MaxPayloadLength = 0xFF;
 8039aba:	f1b9 0f00 	cmp.w	r9, #0
 8039abe:	bf08      	it	eq
 8039ac0:	20ff      	moveq	r0, #255	; 0xff
    switch( modem )
 8039ac2:	2d01      	cmp	r5, #1
 8039ac4:	46da      	mov	sl, fp
 8039ac6:	7008      	strb	r0, [r1, #0]
 8039ac8:	f000 80cc 	beq.w	8039c64 <RadioSetRxConfig+0x1f0>
 8039acc:	2d04      	cmp	r5, #4
 8039ace:	d04c      	beq.n	8039b6a <RadioSetRxConfig+0xf6>
 8039ad0:	2d00      	cmp	r5, #0
 8039ad2:	f040 80c4 	bne.w	8039c5e <RadioSetRxConfig+0x1ea>
            SUBGRF_SetStopRxTimerOnPreambleDetect( false );
 8039ad6:	4628      	mov	r0, r5
 8039ad8:	f000 fb62 	bl	803a1a0 <SUBGRF_SetStopRxTimerOnPreambleDetect>
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_1;
 8039adc:	220b      	movs	r2, #11
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8039ade:	4638      	mov	r0, r7
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_1;
 8039ae0:	f88b 2044 	strb.w	r2, [fp, #68]	; 0x44
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 8039ae4:	f88b 5038 	strb.w	r5, [fp, #56]	; 0x38
            SubgRf.ModulationParams.Params.Gfsk.BitRate = datarate;
 8039ae8:	f8cb 403c 	str.w	r4, [fp, #60]	; 0x3c
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8039aec:	f000 ffb0 	bl	803aa50 <SUBGRF_GetFskBandwidthRegValue>
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 8039af0:	9b00      	ldr	r3, [sp, #0]
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength;
 8039af2:	4991      	ldr	r1, [pc, #580]	; (8039d38 <RadioSetRxConfig+0x2c4>)
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8039af4:	f88b 0045 	strb.w	r0, [fp, #69]	; 0x45
            SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS;
 8039af8:	f641 0204 	movw	r2, #6148	; 0x1804
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 8039afc:	2b00      	cmp	r3, #0
            SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS;
 8039afe:	f8ab 2012 	strh.w	r2, [fp, #18]
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength;
 8039b02:	780a      	ldrb	r2, [r1, #0]
 8039b04:	f88b 2016 	strb.w	r2, [fp, #22]
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 8039b08:	bf14      	ite	ne
 8039b0a:	22f2      	movne	r2, #242	; 0xf2
 8039b0c:	2201      	moveq	r2, #1
 8039b0e:	f88b 2017 	strb.w	r2, [fp, #23]
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 8039b12:	00f6      	lsls	r6, r6, #3
            SubgRf.PacketParams.Params.Gfsk.DcFree = RADIO_DC_FREEWHITENING;
 8039b14:	2201      	movs	r2, #1
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( fixLen == true ) ? RADIO_PACKET_FIXED_LENGTH : RADIO_PACKET_VARIABLE_LENGTH;
 8039b16:	f089 0901 	eor.w	r9, r9, #1
            SubgRf.PacketParams.Params.Gfsk.DcFree = RADIO_DC_FREEWHITENING;
 8039b1a:	f88b 2018 	strb.w	r2, [fp, #24]
            SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 8039b1e:	f88b 500e 	strb.w	r5, [fp, #14]
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 8039b22:	f8ab 6010 	strh.w	r6, [fp, #16]
            SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF;
 8039b26:	f88b 5014 	strb.w	r5, [fp, #20]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( fixLen == true ) ? RADIO_PACKET_FIXED_LENGTH : RADIO_PACKET_VARIABLE_LENGTH;
 8039b2a:	f88b 9015 	strb.w	r9, [fp, #21]
            RadioStandby( );
 8039b2e:	f7ff fa33 	bl	8038f98 <RadioStandby>
            RadioSetModem( ( SubgRf.ModulationParams.PacketType == PACKET_TYPE_GFSK ) ? MODEM_FSK : MODEM_LORA );
 8039b32:	f89b 0038 	ldrb.w	r0, [fp, #56]	; 0x38
 8039b36:	3800      	subs	r0, #0
 8039b38:	bf18      	it	ne
 8039b3a:	2001      	movne	r0, #1
 8039b3c:	f7ff fcb4 	bl	80394a8 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8039b40:	f10b 0038 	add.w	r0, fp, #56	; 0x38
 8039b44:	f000 fc92 	bl	803a46c <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039b48:	f10b 000e 	add.w	r0, fp, #14
 8039b4c:	f000 fe24 	bl	803a798 <SUBGRF_SetPacketParams>
            SUBGRF_SetSyncWord( ( uint8_t[] ){ 0xC1, 0x94, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00 } );
 8039b50:	497a      	ldr	r1, [pc, #488]	; (8039d3c <RadioSetRxConfig+0x2c8>)
 8039b52:	6808      	ldr	r0, [r1, #0]
 8039b54:	6849      	ldr	r1, [r1, #4]
 8039b56:	aa04      	add	r2, sp, #16
 8039b58:	c203      	stmia	r2!, {r0, r1}
 8039b5a:	a804      	add	r0, sp, #16
 8039b5c:	f000 fdee 	bl	803a73c <SUBGRF_SetSyncWord>
            SUBGRF_SetWhiteningSeed( 0x01FF );
 8039b60:	f240 10ff 	movw	r0, #511	; 0x1ff
 8039b64:	f000 fd5c 	bl	803a620 <SUBGRF_SetWhiteningSeed>
 8039b68:	e071      	b.n	8039c4e <RadioSetRxConfig+0x1da>
            SUBGRF_SetStopRxTimerOnPreambleDetect( true );
 8039b6a:	2001      	movs	r0, #1
 8039b6c:	f000 fb18 	bl	803a1a0 <SUBGRF_SetStopRxTimerOnPreambleDetect>
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_05;
 8039b70:	2209      	movs	r2, #9
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 8039b72:	f04f 0900 	mov.w	r9, #0
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_05;
 8039b76:	f88b 2044 	strb.w	r2, [fp, #68]	; 0x44
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8039b7a:	4638      	mov	r0, r7
            SubgRf.ModulationParams.Params.Gfsk.Fdev = 800;
 8039b7c:	f44f 7248 	mov.w	r2, #800	; 0x320
 8039b80:	f8cb 2040 	str.w	r2, [fp, #64]	; 0x40
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 8039b84:	f88b 9038 	strb.w	r9, [fp, #56]	; 0x38
            SubgRf.ModulationParams.Params.Gfsk.BitRate = datarate;
 8039b88:	f8cb 403c 	str.w	r4, [fp, #60]	; 0x3c
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8039b8c:	f000 ff60 	bl	803aa50 <SUBGRF_GetFskBandwidthRegValue>
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength;
 8039b90:	4969      	ldr	r1, [pc, #420]	; (8039d38 <RadioSetRxConfig+0x2c4>)
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8039b92:	f88b 0045 	strb.w	r0, [fp, #69]	; 0x45
            SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_OFF;
 8039b96:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8039b9a:	f8ab 2012 	strh.w	r2, [fp, #18]
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength;
 8039b9e:	780a      	ldrb	r2, [r1, #0]
 8039ba0:	f88b 2016 	strb.w	r2, [fp, #22]
            RadioSetModem( MODEM_SIGFOX_RX );
 8039ba4:	4628      	mov	r0, r5
            SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 8039ba6:	2201      	movs	r2, #1
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 8039ba8:	00f6      	lsls	r6, r6, #3
            SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 8039baa:	f88b 2017 	strb.w	r2, [fp, #23]
            SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 8039bae:	f88b 900e 	strb.w	r9, [fp, #14]
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 8039bb2:	f8ab 6010 	strh.w	r6, [fp, #16]
            SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF;
 8039bb6:	f8ab 9014 	strh.w	r9, [fp, #20]
            SubgRf.PacketParams.Params.Gfsk.DcFree = RADIO_DC_FREE_OFF;
 8039bba:	f88b 9018 	strb.w	r9, [fp, #24]
            RadioSetModem( MODEM_SIGFOX_RX );
 8039bbe:	f7ff fc73 	bl	80394a8 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8039bc2:	f10b 0038 	add.w	r0, fp, #56	; 0x38
 8039bc6:	f000 fc51 	bl	803a46c <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039bca:	f10b 000e 	add.w	r0, fp, #14
 8039bce:	f000 fde3 	bl	803a798 <SUBGRF_SetPacketParams>
            SUBGRF_SetSyncWord( ( uint8_t[] ){0xB2, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } );
 8039bd2:	495b      	ldr	r1, [pc, #364]	; (8039d40 <RadioSetRxConfig+0x2cc>)
 8039bd4:	6808      	ldr	r0, [r1, #0]
 8039bd6:	6849      	ldr	r1, [r1, #4]
 8039bd8:	aa04      	add	r2, sp, #16
 8039bda:	c203      	stmia	r2!, {r0, r1}
 8039bdc:	a804      	add	r0, sp, #16
 8039bde:	f000 fdad 	bl	803a73c <SUBGRF_SetSyncWord>
            SUBGRF_SetWhiteningSeed( 0x01FF );
 8039be2:	f240 10ff 	movw	r0, #511	; 0x1ff
 8039be6:	f000 fd1b 	bl	803a620 <SUBGRF_SetWhiteningSeed>
    return SUBGRF_ReadRegister(addr);
 8039bea:	f640 00b8 	movw	r0, #2232	; 0x8b8
 8039bee:	f000 fca9 	bl	803a544 <SUBGRF_ReadRegister>
    SUBGRF_WriteRegister(addr, data );
 8039bf2:	f000 01ef 	and.w	r1, r0, #239	; 0xef
 8039bf6:	f640 00b8 	movw	r0, #2232	; 0x8b8
 8039bfa:	f000 fbdd 	bl	803a3b8 <SUBGRF_WriteRegister>
 8039bfe:	4629      	mov	r1, r5
 8039c00:	f640 00b9 	movw	r0, #2233	; 0x8b9
 8039c04:	f000 fbd8 	bl	803a3b8 <SUBGRF_WriteRegister>
    return SUBGRF_ReadRegister(addr);
 8039c08:	f640 009b 	movw	r0, #2203	; 0x89b
 8039c0c:	f000 fc9a 	bl	803a544 <SUBGRF_ReadRegister>
            RadioWrite(0x89b, (modReg| (0x1<<3) ) );
 8039c10:	f000 01e3 	and.w	r1, r0, #227	; 0xe3
    SUBGRF_WriteRegister(addr, data );
 8039c14:	f041 0108 	orr.w	r1, r1, #8
 8039c18:	f640 009b 	movw	r0, #2203	; 0x89b
 8039c1c:	f000 fbcc 	bl	803a3b8 <SUBGRF_WriteRegister>
    return SUBGRF_ReadRegister(addr);
 8039c20:	f240 60d1 	movw	r0, #1745	; 0x6d1
 8039c24:	f000 fc8e 	bl	803a544 <SUBGRF_ReadRegister>
            RadioWrite(0x6d1, (modReg| (0x3<<3) ));
 8039c28:	f040 0118 	orr.w	r1, r0, #24
    SUBGRF_WriteRegister(addr, data );
 8039c2c:	b2c9      	uxtb	r1, r1
 8039c2e:	f240 60d1 	movw	r0, #1745	; 0x6d1
 8039c32:	f000 fbc1 	bl	803a3b8 <SUBGRF_WriteRegister>
    return SUBGRF_ReadRegister(addr);
 8039c36:	f240 60ac 	movw	r0, #1708	; 0x6ac
 8039c3a:	f000 fc83 	bl	803a544 <SUBGRF_ReadRegister>
            RadioWrite(0x6ac, (modReg| (0x5<<4) ));
 8039c3e:	f000 018f 	and.w	r1, r0, #143	; 0x8f
    SUBGRF_WriteRegister(addr, data );
 8039c42:	f041 0150 	orr.w	r1, r1, #80	; 0x50
 8039c46:	f240 60ac 	movw	r0, #1708	; 0x6ac
 8039c4a:	f000 fbb5 	bl	803a3b8 <SUBGRF_WriteRegister>
            SubgRf.RxTimeout = ( uint32_t )(( symbTimeout * 8 * 1000 ) /datarate);
 8039c4e:	f44f 52fa 	mov.w	r2, #8000	; 0x1f40
 8039c52:	fb02 f808 	mul.w	r8, r2, r8
 8039c56:	fbb8 f4f4 	udiv	r4, r8, r4
 8039c5a:	f8cb 4008 	str.w	r4, [fp, #8]
}
 8039c5e:	b007      	add	sp, #28
 8039c60:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            SUBGRF_SetStopRxTimerOnPreambleDetect( false );
 8039c64:	2000      	movs	r0, #0
 8039c66:	f000 fa9b 	bl	803a1a0 <SUBGRF_SetStopRxTimerOnPreambleDetect>
            SubgRf.ModulationParams.Params.LoRa.Bandwidth = Bandwidths[bandwidth];
 8039c6a:	4936      	ldr	r1, [pc, #216]	; (8039d44 <RadioSetRxConfig+0x2d0>)
            SubgRf.ModulationParams.Params.LoRa.CodingRate = ( RadioLoRaCodingRates_t )coderate;
 8039c6c:	9a01      	ldr	r2, [sp, #4]
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_LORA;
 8039c6e:	f88b 5038 	strb.w	r5, [fp, #56]	; 0x38
            SubgRf.ModulationParams.Params.LoRa.Bandwidth = Bandwidths[bandwidth];
 8039c72:	4439      	add	r1, r7
            SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t )datarate;
 8039c74:	b2e3      	uxtb	r3, r4
            SubgRf.ModulationParams.Params.LoRa.Bandwidth = Bandwidths[bandwidth];
 8039c76:	7909      	ldrb	r1, [r1, #4]
            SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t )datarate;
 8039c78:	f88b 3050 	strb.w	r3, [fp, #80]	; 0x50
            SubgRf.ModulationParams.Params.LoRa.Bandwidth = Bandwidths[bandwidth];
 8039c7c:	f88b 1051 	strb.w	r1, [fp, #81]	; 0x51
            SubgRf.ModulationParams.Params.LoRa.CodingRate = ( RadioLoRaCodingRates_t )coderate;
 8039c80:	f88b 2052 	strb.w	r2, [fp, #82]	; 0x52
            if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 8039c84:	2f00      	cmp	r7, #0
 8039c86:	d144      	bne.n	8039d12 <RadioSetRxConfig+0x29e>
 8039c88:	3c0b      	subs	r4, #11
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x00;
 8039c8a:	2c01      	cmp	r4, #1
 8039c8c:	bf8c      	ite	hi
 8039c8e:	2400      	movhi	r4, #0
 8039c90:	2401      	movls	r4, #1
            SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 8039c92:	2101      	movs	r1, #1
            if( ( SubgRf.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF5 ) ||
 8039c94:	3b05      	subs	r3, #5
 8039c96:	428b      	cmp	r3, r1
 8039c98:	f88a 4053 	strb.w	r4, [sl, #83]	; 0x53
            SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 8039c9c:	f88a 100e 	strb.w	r1, [sl, #14]
            if( ( SubgRf.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF5 ) ||
 8039ca0:	d840      	bhi.n	8039d24 <RadioSetRxConfig+0x2b0>
                if( preambleLen < 12 )
 8039ca2:	2e0b      	cmp	r6, #11
 8039ca4:	d83e      	bhi.n	8039d24 <RadioSetRxConfig+0x2b0>
                    SubgRf.PacketParams.Params.LoRa.PreambleLength = 12;
 8039ca6:	230c      	movs	r3, #12
 8039ca8:	f8aa 301c 	strh.w	r3, [sl, #28]
            SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength;
 8039cac:	4b22      	ldr	r3, [pc, #136]	; (8039d38 <RadioSetRxConfig+0x2c4>)
            SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t )fixLen;
 8039cae:	f88a 901e 	strb.w	r9, [sl, #30]
            SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength;
 8039cb2:	781b      	ldrb	r3, [r3, #0]
 8039cb4:	f88a 301f 	strb.w	r3, [sl, #31]
            SubgRf.PacketParams.Params.LoRa.CrcMode = ( RadioLoRaCrcModes_t )crcOn;
 8039cb8:	9b00      	ldr	r3, [sp, #0]
 8039cba:	f88a 3020 	strb.w	r3, [sl, #32]
            SubgRf.PacketParams.Params.LoRa.InvertIQ = ( RadioLoRaIQModes_t )iqInverted;
 8039cbe:	f89d 3060 	ldrb.w	r3, [sp, #96]	; 0x60
 8039cc2:	f88a 3021 	strb.w	r3, [sl, #33]	; 0x21
            RadioStandby( );
 8039cc6:	f7ff f967 	bl	8038f98 <RadioStandby>
            RadioSetModem( ( SubgRf.ModulationParams.PacketType == PACKET_TYPE_GFSK ) ? MODEM_FSK : MODEM_LORA );
 8039cca:	f89a 0038 	ldrb.w	r0, [sl, #56]	; 0x38
 8039cce:	3800      	subs	r0, #0
 8039cd0:	bf18      	it	ne
 8039cd2:	2001      	movne	r0, #1
 8039cd4:	f7ff fbe8 	bl	80394a8 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8039cd8:	481b      	ldr	r0, [pc, #108]	; (8039d48 <RadioSetRxConfig+0x2d4>)
 8039cda:	f000 fbc7 	bl	803a46c <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039cde:	481b      	ldr	r0, [pc, #108]	; (8039d4c <RadioSetRxConfig+0x2d8>)
 8039ce0:	f000 fd5a 	bl	803a798 <SUBGRF_SetPacketParams>
            SUBGRF_SetLoRaSymbNumTimeout( symbTimeout );
 8039ce4:	fa5f f088 	uxtb.w	r0, r8
 8039ce8:	f000 fb92 	bl	803a410 <SUBGRF_SetLoRaSymbNumTimeout>
            if( SubgRf.PacketParams.Params.LoRa.InvertIQ == LORA_IQ_INVERTED )
 8039cec:	f89a 3021 	ldrb.w	r3, [sl, #33]	; 0x21
 8039cf0:	2b01      	cmp	r3, #1
                SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) & ~( 1 << 2 ) );
 8039cf2:	f240 7036 	movw	r0, #1846	; 0x736
            if( SubgRf.PacketParams.Params.LoRa.InvertIQ == LORA_IQ_INVERTED )
 8039cf6:	d118      	bne.n	8039d2a <RadioSetRxConfig+0x2b6>
                SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) & ~( 1 << 2 ) );
 8039cf8:	f000 fc24 	bl	803a544 <SUBGRF_ReadRegister>
 8039cfc:	f000 01fb 	and.w	r1, r0, #251	; 0xfb
                SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) | ( 1 << 2 ) );
 8039d00:	f240 7036 	movw	r0, #1846	; 0x736
 8039d04:	f000 fb58 	bl	803a3b8 <SUBGRF_WriteRegister>
            SubgRf.RxTimeout = 0xFFFF;
 8039d08:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8039d0c:	f8ca 3008 	str.w	r3, [sl, #8]
}
 8039d10:	e7a5      	b.n	8039c5e <RadioSetRxConfig+0x1ea>
            if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 8039d12:	2f01      	cmp	r7, #1
 8039d14:	d104      	bne.n	8039d20 <RadioSetRxConfig+0x2ac>
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x00;
 8039d16:	f1a4 020c 	sub.w	r2, r4, #12
 8039d1a:	4254      	negs	r4, r2
 8039d1c:	4154      	adcs	r4, r2
 8039d1e:	e7b8      	b.n	8039c92 <RadioSetRxConfig+0x21e>
 8039d20:	2400      	movs	r4, #0
 8039d22:	e7b6      	b.n	8039c92 <RadioSetRxConfig+0x21e>
                    SubgRf.PacketParams.Params.LoRa.PreambleLength = preambleLen;
 8039d24:	f8aa 601c 	strh.w	r6, [sl, #28]
 8039d28:	e7c0      	b.n	8039cac <RadioSetRxConfig+0x238>
                SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) | ( 1 << 2 ) );
 8039d2a:	f000 fc0b 	bl	803a544 <SUBGRF_ReadRegister>
 8039d2e:	f040 0104 	orr.w	r1, r0, #4
 8039d32:	b2c9      	uxtb	r1, r1
 8039d34:	e7e4      	b.n	8039d00 <RadioSetRxConfig+0x28c>
 8039d36:	bf00      	nop
 8039d38:	200035a0 	.word	0x200035a0
 8039d3c:	0803bbb0 	.word	0x0803bbb0
 8039d40:	0803bbb8 	.word	0x0803bbb8
 8039d44:	0803bb7c 	.word	0x0803bb7c
 8039d48:	2000635c 	.word	0x2000635c
 8039d4c:	20006332 	.word	0x20006332
 8039d50:	20006324 	.word	0x20006324

08039d54 <RadioRandom>:
{
 8039d54:	b508      	push	{r3, lr}
    RadioSetModem( MODEM_LORA );
 8039d56:	2001      	movs	r0, #1
 8039d58:	f7ff fba6 	bl	80394a8 <RadioSetModem>
    SUBGRF_SetDioIrqParams( IRQ_RADIO_NONE, IRQ_RADIO_NONE, IRQ_RADIO_NONE, IRQ_RADIO_NONE );
 8039d5c:	2300      	movs	r3, #0
 8039d5e:	461a      	mov	r2, r3
 8039d60:	4619      	mov	r1, r3
 8039d62:	4618      	mov	r0, r3
 8039d64:	f000 fa8c 	bl	803a280 <SUBGRF_SetDioIrqParams>
}
 8039d68:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    rnd = SUBGRF_GetRandom();
 8039d6c:	f000 bd86 	b.w	803a87c <SUBGRF_GetRandom>

08039d70 <RadioIsChannelFree>:
{
 8039d70:	b5f0      	push	{r4, r5, r6, r7, lr}
 8039d72:	b08b      	sub	sp, #44	; 0x2c
 8039d74:	460d      	mov	r5, r1
 8039d76:	4604      	mov	r4, r0
 8039d78:	4617      	mov	r7, r2
 8039d7a:	461e      	mov	r6, r3
    RadioStandby( );
 8039d7c:	f7ff f90c 	bl	8038f98 <RadioStandby>
    RadioSetModem( MODEM_FSK );
 8039d80:	2000      	movs	r0, #0
 8039d82:	f7ff fb91 	bl	80394a8 <RadioSetModem>
    SUBGRF_SetRfFrequency( freq );
 8039d86:	4620      	mov	r0, r4
 8039d88:	f000 faa4 	bl	803a2d4 <SUBGRF_SetRfFrequency>
    RadioSetRxConfig( MODEM_FSK, rxBandwidth, 600, 0, rxBandwidth, 3, 0, false,
 8039d8c:	2400      	movs	r4, #0
 8039d8e:	2301      	movs	r3, #1
 8039d90:	e9cd 4308 	strd	r4, r3, [sp, #32]
 8039d94:	2303      	movs	r3, #3
 8039d96:	f44f 7216 	mov.w	r2, #600	; 0x258
 8039d9a:	4629      	mov	r1, r5
 8039d9c:	4620      	mov	r0, r4
 8039d9e:	e9cd 4406 	strd	r4, r4, [sp, #24]
 8039da2:	e9cd 4404 	strd	r4, r4, [sp, #16]
 8039da6:	e9cd 4402 	strd	r4, r4, [sp, #8]
 8039daa:	e9cd 5300 	strd	r5, r3, [sp]
 8039dae:	4623      	mov	r3, r4
 8039db0:	f7ff fe60 	bl	8039a74 <RadioSetRxConfig>
    RadioRx( 0 );
 8039db4:	4620      	mov	r0, r4
 8039db6:	f7ff fb2b 	bl	8039410 <RadioRx>
    RADIO_DELAY_MS( RadioGetWakeupTime( ) );
 8039dba:	f7ff fa27 	bl	803920c <RadioGetWakeupTime>
 8039dbe:	f7f2 fc43 	bl	802c648 <HAL_Delay>
    carrierSenseTime = TimerGetCurrentTime( );
 8039dc2:	f001 fa41 	bl	803b248 <UTIL_TIMER_GetCurrentTime>
 8039dc6:	4604      	mov	r4, r0
    while( TimerGetElapsedTime( carrierSenseTime ) < maxCarrierSenseTime )
 8039dc8:	4620      	mov	r0, r4
 8039dca:	f001 fa47 	bl	803b25c <UTIL_TIMER_GetElapsedTime>
 8039dce:	42b0      	cmp	r0, r6
 8039dd0:	d305      	bcc.n	8039dde <RadioIsChannelFree+0x6e>
    bool status = true;
 8039dd2:	2401      	movs	r4, #1
    RadioStandby( );
 8039dd4:	f7ff f8e0 	bl	8038f98 <RadioStandby>
}
 8039dd8:	4620      	mov	r0, r4
 8039dda:	b00b      	add	sp, #44	; 0x2c
 8039ddc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return SUBGRF_GetRssiInst( );
 8039dde:	f000 faa4 	bl	803a32a <SUBGRF_GetRssiInst>
        if( rssi > rssiThresh )
 8039de2:	b200      	sxth	r0, r0
 8039de4:	4287      	cmp	r7, r0
 8039de6:	daef      	bge.n	8039dc8 <RadioIsChannelFree+0x58>
            status = false;
 8039de8:	2400      	movs	r4, #0
 8039dea:	e7f3      	b.n	8039dd4 <RadioIsChannelFree+0x64>

08039dec <RadioInit>:
    RadioEvents = events;
 8039dec:	4b1e      	ldr	r3, [pc, #120]	; (8039e68 <RadioInit+0x7c>)
{
 8039dee:	b573      	push	{r0, r1, r4, r5, r6, lr}
    RadioEvents = events;
 8039df0:	6018      	str	r0, [r3, #0]
    SubgRf.RxContinuous = false;
 8039df2:	4b1e      	ldr	r3, [pc, #120]	; (8039e6c <RadioInit+0x80>)
    SUBGRF_Init( RadioOnDioIrq );
 8039df4:	481e      	ldr	r0, [pc, #120]	; (8039e70 <RadioInit+0x84>)
    TimerInit( &TxTimeoutTimer, RadioOnTxTimeoutIrq );
 8039df6:	4e1f      	ldr	r6, [pc, #124]	; (8039e74 <RadioInit+0x88>)
    TimerInit( &RxTimeoutTimer, RadioOnRxTimeoutIrq );
 8039df8:	4d1f      	ldr	r5, [pc, #124]	; (8039e78 <RadioInit+0x8c>)
    SubgRf.RxContinuous = false;
 8039dfa:	2400      	movs	r4, #0
    SubgRf.RxTimeout = 0;
 8039dfc:	e9c3 4401 	strd	r4, r4, [r3, #4]
    SubgRf.RxContinuous = false;
 8039e00:	705c      	strb	r4, [r3, #1]
    SUBGRF_Init( RadioOnDioIrq );
 8039e02:	f000 fbc3 	bl	803a58c <SUBGRF_Init>
    RadioSetPublicNetwork( false );
 8039e06:	4620      	mov	r0, r4
 8039e08:	f7ff fb30 	bl	803946c <RadioSetPublicNetwork>
    SUBGRF_SetRegulatorMode(  );
 8039e0c:	f000 f9d4 	bl	803a1b8 <SUBGRF_SetRegulatorMode>
    SUBGRF_SetBufferBaseAddress( 0x00, 0x00 );
 8039e10:	4621      	mov	r1, r4
 8039e12:	4620      	mov	r0, r4
 8039e14:	f000 fa7c 	bl	803a310 <SUBGRF_SetBufferBaseAddress>
    SUBGRF_SetTxParams(RFO_LP, 0, RADIO_RAMP_200_US);
 8039e18:	4621      	mov	r1, r4
 8039e1a:	2204      	movs	r2, #4
 8039e1c:	2001      	movs	r0, #1
 8039e1e:	f000 fc1b 	bl	803a658 <SUBGRF_SetTxParams>
    SUBGRF_SetDioIrqParams( IRQ_RADIO_ALL, IRQ_RADIO_ALL, IRQ_RADIO_NONE, IRQ_RADIO_NONE );
 8039e22:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8039e26:	4623      	mov	r3, r4
 8039e28:	4622      	mov	r2, r4
 8039e2a:	4608      	mov	r0, r1
 8039e2c:	f000 fa28 	bl	803a280 <SUBGRF_SetDioIrqParams>
    RadioSleep();
 8039e30:	f7ff fa2c 	bl	803928c <RadioSleep>
    TimerInit( &TxTimeoutTimer, RadioOnTxTimeoutIrq );
 8039e34:	4622      	mov	r2, r4
 8039e36:	4b11      	ldr	r3, [pc, #68]	; (8039e7c <RadioInit+0x90>)
 8039e38:	9400      	str	r4, [sp, #0]
 8039e3a:	f04f 31ff 	mov.w	r1, #4294967295
 8039e3e:	4630      	mov	r0, r6
 8039e40:	f001 f9e8 	bl	803b214 <UTIL_TIMER_Create>
    TimerInit( &RxTimeoutTimer, RadioOnRxTimeoutIrq );
 8039e44:	4b0e      	ldr	r3, [pc, #56]	; (8039e80 <RadioInit+0x94>)
 8039e46:	9400      	str	r4, [sp, #0]
 8039e48:	4622      	mov	r2, r4
 8039e4a:	f04f 31ff 	mov.w	r1, #4294967295
 8039e4e:	4628      	mov	r0, r5
 8039e50:	f001 f9e0 	bl	803b214 <UTIL_TIMER_Create>
    TimerStop( &TxTimeoutTimer );
 8039e54:	4630      	mov	r0, r6
 8039e56:	f001 fa3b 	bl	803b2d0 <UTIL_TIMER_Stop>
    TimerStop( &RxTimeoutTimer );
 8039e5a:	4628      	mov	r0, r5
}
 8039e5c:	b002      	add	sp, #8
 8039e5e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    TimerStop( &RxTimeoutTimer );
 8039e62:	f001 ba35 	b.w	803b2d0 <UTIL_TIMER_Stop>
 8039e66:	bf00      	nop
 8039e68:	2000597c 	.word	0x2000597c
 8039e6c:	20006324 	.word	0x20006324
 8039e70:	080391fd 	.word	0x080391fd
 8039e74:	2000637c 	.word	0x2000637c
 8039e78:	20006394 	.word	0x20006394
 8039e7c:	08038f31 	.word	0x08038f31
 8039e80:	08038f45 	.word	0x08038f45

08039e84 <RadioSend>:
{
 8039e84:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    SUBGRF_SetDioIrqParams( IRQ_TX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_TX_DBG,
 8039e86:	2300      	movs	r3, #0
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_TX);
 8039e88:	4d66      	ldr	r5, [pc, #408]	; (803a024 <RadioSend+0x1a0>)
{
 8039e8a:	460c      	mov	r4, r1
    SUBGRF_SetDioIrqParams( IRQ_TX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_TX_DBG,
 8039e8c:	f240 2101 	movw	r1, #513	; 0x201
 8039e90:	461a      	mov	r2, r3
{
 8039e92:	4606      	mov	r6, r0
    SUBGRF_SetDioIrqParams( IRQ_TX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_TX_DBG,
 8039e94:	4608      	mov	r0, r1
 8039e96:	f000 f9f3 	bl	803a280 <SUBGRF_SetDioIrqParams>
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_TX);
 8039e9a:	f895 0056 	ldrb.w	r0, [r5, #86]	; 0x56
 8039e9e:	2101      	movs	r1, #1
 8039ea0:	f000 fd67 	bl	803a972 <SUBGRF_SetSwitch>
    if((SubgRf.Modem==MODEM_LORA) && (SubgRf.ModulationParams.Params.LoRa.Bandwidth == LORA_BW_500 ))
 8039ea4:	782b      	ldrb	r3, [r5, #0]
 8039ea6:	2b01      	cmp	r3, #1
        SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) & ~( 1 << 2 ) );
 8039ea8:	f640 0089 	movw	r0, #2185	; 0x889
    if((SubgRf.Modem==MODEM_LORA) && (SubgRf.ModulationParams.Params.LoRa.Bandwidth == LORA_BW_500 ))
 8039eac:	d112      	bne.n	8039ed4 <RadioSend+0x50>
 8039eae:	f895 3051 	ldrb.w	r3, [r5, #81]	; 0x51
 8039eb2:	2b06      	cmp	r3, #6
 8039eb4:	d10e      	bne.n	8039ed4 <RadioSend+0x50>
        SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) & ~( 1 << 2 ) );
 8039eb6:	f000 fb45 	bl	803a544 <SUBGRF_ReadRegister>
 8039eba:	f000 01fb 	and.w	r1, r0, #251	; 0xfb
        SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) | ( 1 << 2 ) );
 8039ebe:	f640 0089 	movw	r0, #2185	; 0x889
 8039ec2:	f000 fa79 	bl	803a3b8 <SUBGRF_WriteRegister>
    switch(SubgRf.Modem)
 8039ec6:	782b      	ldrb	r3, [r5, #0]
 8039ec8:	2b03      	cmp	r3, #3
 8039eca:	d86f      	bhi.n	8039fac <RadioSend+0x128>
 8039ecc:	e8df f003 	tbb	[pc, r3]
 8039ed0:	08804e55 	.word	0x08804e55
        SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) | ( 1 << 2 ) );
 8039ed4:	f000 fb36 	bl	803a544 <SUBGRF_ReadRegister>
 8039ed8:	f040 0104 	orr.w	r1, r0, #4
 8039edc:	b2c9      	uxtb	r1, r1
 8039ede:	e7ee      	b.n	8039ebe <RadioSend+0x3a>
 8039ee0:	4a51      	ldr	r2, [pc, #324]	; (803a028 <RadioSend+0x1a4>)
 8039ee2:	1e73      	subs	r3, r6, #1
 8039ee4:	4610      	mov	r0, r2
    for (i = 0; i < size; i++)
 8039ee6:	f1c6 0701 	rsb	r7, r6, #1
        outBuffer[i] = 0;
 8039eea:	f04f 0c00 	mov.w	ip, #0
    for (i = 0; i < size; i++)
 8039eee:	18f9      	adds	r1, r7, r3
 8039ef0:	428c      	cmp	r4, r1
 8039ef2:	dc71      	bgt.n	8039fd8 <RadioSend+0x154>
    for (i = 0; i < (size * 8); i++)
 8039ef4:	2300      	movs	r3, #0
 8039ef6:	00e7      	lsls	r7, r4, #3
    uint8_t prevInt = 0;
 8039ef8:	4619      	mov	r1, r3
    for (i = 0; i < (size * 8); i++)
 8039efa:	42bb      	cmp	r3, r7
 8039efc:	d173      	bne.n	8039fe6 <RadioSend+0x162>
    outBuffer[size] = ( prevInt << 7 ) | ( prevInt << 6 ) | ( ( ( !prevInt ) & 0x01 ) << 5 ) ;
 8039efe:	4a4b      	ldr	r2, [pc, #300]	; (803a02c <RadioSend+0x1a8>)
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039f00:	484b      	ldr	r0, [pc, #300]	; (803a030 <RadioSend+0x1ac>)
    outBuffer[size] = ( prevInt << 7 ) | ( prevInt << 6 ) | ( ( ( !prevInt ) & 0x01 ) << 5 ) ;
 8039f02:	2900      	cmp	r1, #0
 8039f04:	ea4f 1381 	mov.w	r3, r1, lsl #6
 8039f08:	ea43 13c1 	orr.w	r3, r3, r1, lsl #7
 8039f0c:	4422      	add	r2, r4
 8039f0e:	bf0c      	ite	eq
 8039f10:	2120      	moveq	r1, #32
 8039f12:	2100      	movne	r1, #0
 8039f14:	430b      	orrs	r3, r1
            SubgRf.PacketParams.Params.Bpsk.PayloadLength = size + 1;
 8039f16:	1c66      	adds	r6, r4, #1
    outBuffer[size] = ( prevInt << 7 ) | ( prevInt << 6 ) | ( ( ( !prevInt ) & 0x01 ) << 5 ) ;
 8039f18:	7113      	strb	r3, [r2, #4]
            SubgRf.PacketParams.Params.Bpsk.PayloadLength = size + 1;
 8039f1a:	b2f6      	uxtb	r6, r6
            SubgRf.PacketParams.PacketType = PACKET_TYPE_BPSK;
 8039f1c:	2302      	movs	r3, #2
 8039f1e:	73ab      	strb	r3, [r5, #14]
            SubgRf.PacketParams.Params.Bpsk.PayloadLength = size + 1;
 8039f20:	76ae      	strb	r6, [r5, #26]
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039f22:	f000 fc39 	bl	803a798 <SUBGRF_SetPacketParams>
    SUBGRF_WriteRegister(addr, data );
 8039f26:	2100      	movs	r1, #0
 8039f28:	20f1      	movs	r0, #241	; 0xf1
 8039f2a:	f000 fa45 	bl	803a3b8 <SUBGRF_WriteRegister>
 8039f2e:	2100      	movs	r1, #0
 8039f30:	20f0      	movs	r0, #240	; 0xf0
 8039f32:	f000 fa41 	bl	803a3b8 <SUBGRF_WriteRegister>
            if( SubgRf.ModulationParams.Params.Bpsk.BitRate == 100 )
 8039f36:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8039f38:	2b64      	cmp	r3, #100	; 0x64
 8039f3a:	d16d      	bne.n	803a018 <RadioSend+0x194>
    SUBGRF_WriteRegister(addr, data );
 8039f3c:	2170      	movs	r1, #112	; 0x70
 8039f3e:	20f3      	movs	r0, #243	; 0xf3
 8039f40:	f000 fa3a 	bl	803a3b8 <SUBGRF_WriteRegister>
 8039f44:	211d      	movs	r1, #29
 8039f46:	20f2      	movs	r0, #242	; 0xf2
 8039f48:	f000 fa36 	bl	803a3b8 <SUBGRF_WriteRegister>
            uint16_t bitNum = ( size * 8 ) + 2;
 8039f4c:	00e1      	lsls	r1, r4, #3
 8039f4e:	1c8c      	adds	r4, r1, #2
    SUBGRF_WriteRegister(addr, data );
 8039f50:	20f4      	movs	r0, #244	; 0xf4
 8039f52:	0a09      	lsrs	r1, r1, #8
 8039f54:	f000 fa30 	bl	803a3b8 <SUBGRF_WriteRegister>
 8039f58:	f004 01fe 	and.w	r1, r4, #254	; 0xfe
 8039f5c:	20f5      	movs	r0, #245	; 0xf5
 8039f5e:	f000 fa2b 	bl	803a3b8 <SUBGRF_WriteRegister>
            SUBGRF_SendPayload( RadioBuffer, size+1 , 0xFFFFFF );
 8039f62:	4831      	ldr	r0, [pc, #196]	; (803a028 <RadioSend+0x1a4>)
 8039f64:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
 8039f68:	4631      	mov	r1, r6
 8039f6a:	e01d      	b.n	8039fa8 <RadioSend+0x124>
            SubgRf.PacketParams.Params.LoRa.PayloadLength = size;
 8039f6c:	77ec      	strb	r4, [r5, #31]
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039f6e:	4830      	ldr	r0, [pc, #192]	; (803a030 <RadioSend+0x1ac>)
 8039f70:	f000 fc12 	bl	803a798 <SUBGRF_SetPacketParams>
            SUBGRF_SendPayload( buffer, size, 0 );
 8039f74:	2200      	movs	r2, #0
 8039f76:	4621      	mov	r1, r4
 8039f78:	e015      	b.n	8039fa6 <RadioSend+0x122>
            if ( 1UL == RFW_Is_Init( ) )
 8039f7a:	f000 fdc9 	bl	803ab10 <RFW_Is_Init>
 8039f7e:	2801      	cmp	r0, #1
 8039f80:	4607      	mov	r7, r0
 8039f82:	d123      	bne.n	8039fcc <RadioSend+0x148>
              if ( 0UL == RFW_TransmitInit( buffer,size, &outsize ) )
 8039f84:	4621      	mov	r1, r4
 8039f86:	f10d 0207 	add.w	r2, sp, #7
 8039f8a:	4630      	mov	r0, r6
 8039f8c:	f000 fdc5 	bl	803ab1a <RFW_TransmitInit>
 8039f90:	4604      	mov	r4, r0
 8039f92:	b998      	cbnz	r0, 8039fbc <RadioSend+0x138>
                  SubgRf.PacketParams.Params.Gfsk.PayloadLength = outsize;
 8039f94:	f89d 3007 	ldrb.w	r3, [sp, #7]
                  SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039f98:	4825      	ldr	r0, [pc, #148]	; (803a030 <RadioSend+0x1ac>)
                  SubgRf.PacketParams.Params.Gfsk.PayloadLength = outsize;
 8039f9a:	75ab      	strb	r3, [r5, #22]
                  SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039f9c:	f000 fbfc 	bl	803a798 <SUBGRF_SetPacketParams>
                  SUBGRF_SendPayload( buffer, outsize, 0 );
 8039fa0:	f89d 1007 	ldrb.w	r1, [sp, #7]
 8039fa4:	4622      	mov	r2, r4
            SUBGRF_SendPayload( buffer, size, 0 );
 8039fa6:	4630      	mov	r0, r6
            SUBGRF_SendPayload( RadioBuffer, size+1 , 0xFFFFFF );
 8039fa8:	f000 fcb1 	bl	803a90e <SUBGRF_SendPayload>
    TimerSetValue( &TxTimeoutTimer, SubgRf.TxTimeout );
 8039fac:	6869      	ldr	r1, [r5, #4]
 8039fae:	4821      	ldr	r0, [pc, #132]	; (803a034 <RadioSend+0x1b0>)
 8039fb0:	f001 fa18 	bl	803b3e4 <UTIL_TIMER_SetPeriod>
    TimerStart( &TxTimeoutTimer );
 8039fb4:	481f      	ldr	r0, [pc, #124]	; (803a034 <RadioSend+0x1b0>)
 8039fb6:	f001 f9db 	bl	803b370 <UTIL_TIMER_Start>
 8039fba:	e005      	b.n	8039fc8 <RadioSend+0x144>
                MW_LOG( TS_ON, VLEVEL_M, "RadioSend Oversize\r\n");
 8039fbc:	4b1e      	ldr	r3, [pc, #120]	; (803a038 <RadioSend+0x1b4>)
 8039fbe:	463a      	mov	r2, r7
 8039fc0:	2100      	movs	r1, #0
 8039fc2:	2002      	movs	r0, #2
 8039fc4:	f000 fe62 	bl	803ac8c <UTIL_ADV_TRACE_COND_FSend>
}
 8039fc8:	b003      	add	sp, #12
 8039fca:	bdf0      	pop	{r4, r5, r6, r7, pc}
              SubgRf.PacketParams.Params.Gfsk.PayloadLength = size;
 8039fcc:	75ac      	strb	r4, [r5, #22]
              SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039fce:	e7ce      	b.n	8039f6e <RadioSend+0xea>
            SubgRf.PacketParams.PacketType = PACKET_TYPE_BPSK;
 8039fd0:	2302      	movs	r3, #2
 8039fd2:	73ab      	strb	r3, [r5, #14]
            SubgRf.PacketParams.Params.Bpsk.PayloadLength = size;
 8039fd4:	76ac      	strb	r4, [r5, #26]
 8039fd6:	e7ca      	b.n	8039f6e <RadioSend+0xea>
        inBuffer[i] = ~inBuffer[i];
 8039fd8:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 8039fdc:	43c9      	mvns	r1, r1
 8039fde:	7019      	strb	r1, [r3, #0]
        outBuffer[i] = 0;
 8039fe0:	f802 cb01 	strb.w	ip, [r2], #1
    for (i = 0; i < size; i++)
 8039fe4:	e783      	b.n	8039eee <RadioSend+0x6a>
        index_bit = 7 - ( i % 8 );
 8039fe6:	43da      	mvns	r2, r3
 8039fe8:	f002 0c07 	and.w	ip, r2, #7
        index_byte = i / 8;
 8039fec:	10da      	asrs	r2, r3, #3
        index_bit_out = 7 - ( ( i + 1 ) % 8 );
 8039fee:	3301      	adds	r3, #1
        currBit = ( inBuffer[index_byte] >> index_bit ) & 0x01;
 8039ff0:	5cb2      	ldrb	r2, [r6, r2]
 8039ff2:	fa42 f20c 	asr.w	r2, r2, ip
 8039ff6:	f002 0201 	and.w	r2, r2, #1
        index_byte_out = ( i + 1 ) / 8;
 8039ffa:	ea4f 0ce3 	mov.w	ip, r3, asr #3
        prevInt ^= currBit;
 8039ffe:	4051      	eors	r1, r2
        index_bit_out = 7 - ( ( i + 1 ) % 8 );
 803a000:	43da      	mvns	r2, r3
        outBuffer[index_byte_out] |= ( prevInt << index_bit_out );
 803a002:	f810 e00c 	ldrb.w	lr, [r0, ip]
 803a006:	f002 0207 	and.w	r2, r2, #7
 803a00a:	fa01 f202 	lsl.w	r2, r1, r2
 803a00e:	ea42 020e 	orr.w	r2, r2, lr
 803a012:	f800 200c 	strb.w	r2, [r0, ip]
    for (i = 0; i < (size * 8); i++)
 803a016:	e770      	b.n	8039efa <RadioSend+0x76>
    SUBGRF_WriteRegister(addr, data );
 803a018:	21e1      	movs	r1, #225	; 0xe1
 803a01a:	20f3      	movs	r0, #243	; 0xf3
 803a01c:	f000 f9cc 	bl	803a3b8 <SUBGRF_WriteRegister>
 803a020:	2104      	movs	r1, #4
 803a022:	e790      	b.n	8039f46 <RadioSend+0xc2>
 803a024:	20006324 	.word	0x20006324
 803a028:	20005980 	.word	0x20005980
 803a02c:	2000597c 	.word	0x2000597c
 803a030:	20006332 	.word	0x20006332
 803a034:	2000637c 	.word	0x2000637c
 803a038:	0803c4f7 	.word	0x0803c4f7

0803a03c <RadioTxPrbs>:
{
 803a03c:	b508      	push	{r3, lr}
    SUBGRF_SetSwitch( SubgRf.AntSwitchPaSelect, RFSWITCH_TX );
 803a03e:	4b09      	ldr	r3, [pc, #36]	; (803a064 <RadioTxPrbs+0x28>)
 803a040:	2101      	movs	r1, #1
 803a042:	f893 0056 	ldrb.w	r0, [r3, #86]	; 0x56
 803a046:	f000 fc94 	bl	803a972 <SUBGRF_SetSwitch>
    SUBGRF_WriteRegister(addr, data );
 803a04a:	f44f 60d7 	mov.w	r0, #1720	; 0x6b8
 803a04e:	212d      	movs	r1, #45	; 0x2d
 803a050:	f000 f9b2 	bl	803a3b8 <SUBGRF_WriteRegister>
    SUBGRF_SetTxInfinitePreamble( );
 803a054:	f000 f89f 	bl	803a196 <SUBGRF_SetTxInfinitePreamble>
}
 803a058:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    SUBGRF_SetTx( 0x0fffff );
 803a05c:	4802      	ldr	r0, [pc, #8]	; (803a068 <RadioTxPrbs+0x2c>)
 803a05e:	f000 b841 	b.w	803a0e4 <SUBGRF_SetTx>
 803a062:	bf00      	nop
 803a064:	20006324 	.word	0x20006324
 803a068:	000fffff 	.word	0x000fffff

0803a06c <SUBGRF_WriteCommand>:
    CRITICAL_SECTION_END();
}

void SUBGRF_WriteCommand( SUBGHZ_RadioSetCmd_t Command, uint8_t *pBuffer,
                                        uint16_t Size )
{
 803a06c:	b510      	push	{r4, lr}
 803a06e:	4613      	mov	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803a070:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803a074:	b672      	cpsid	i
    CRITICAL_SECTION_BEGIN();
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 803a076:	460a      	mov	r2, r1
 803a078:	4601      	mov	r1, r0
 803a07a:	4803      	ldr	r0, [pc, #12]	; (803a088 <SUBGRF_WriteCommand+0x1c>)
 803a07c:	f7f5 fd18 	bl	802fab0 <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803a080:	f384 8810 	msr	PRIMASK, r4
    CRITICAL_SECTION_END();
}
 803a084:	bd10      	pop	{r4, pc}
 803a086:	bf00      	nop
 803a088:	200061f0 	.word	0x200061f0

0803a08c <SUBGRF_ReadCommand>:

void SUBGRF_ReadCommand( SUBGHZ_RadioGetCmd_t Command, uint8_t *pBuffer,
                                        uint16_t Size )
{
 803a08c:	b510      	push	{r4, lr}
 803a08e:	4613      	mov	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803a090:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803a094:	b672      	cpsid	i
    CRITICAL_SECTION_BEGIN();
    HAL_SUBGHZ_ExecGetCmd( &hsubghz, Command, pBuffer, Size );
 803a096:	460a      	mov	r2, r1
 803a098:	4601      	mov	r1, r0
 803a09a:	4803      	ldr	r0, [pc, #12]	; (803a0a8 <SUBGRF_ReadCommand+0x1c>)
 803a09c:	f7f5 fdaa 	bl	802fbf4 <HAL_SUBGHZ_ExecGetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803a0a0:	f384 8810 	msr	PRIMASK, r4
    CRITICAL_SECTION_END();
}
 803a0a4:	bd10      	pop	{r4, pc}
 803a0a6:	bf00      	nop
 803a0a8:	200061f0 	.word	0x200061f0

0803a0ac <SUBGRF_GetOperatingMode>:
}
 803a0ac:	4b01      	ldr	r3, [pc, #4]	; (803a0b4 <SUBGRF_GetOperatingMode+0x8>)
 803a0ae:	7818      	ldrb	r0, [r3, #0]
 803a0b0:	4770      	bx	lr
 803a0b2:	bf00      	nop
 803a0b4:	20005a80 	.word	0x20005a80

0803a0b8 <SUBGRF_SetStandby>:
{
 803a0b8:	b507      	push	{r0, r1, r2, lr}
    SUBGRF_WriteCommand( RADIO_SET_STANDBY, ( uint8_t* )&standbyConfig, 1 );
 803a0ba:	2201      	movs	r2, #1
{
 803a0bc:	f88d 0007 	strb.w	r0, [sp, #7]
    SUBGRF_WriteCommand( RADIO_SET_STANDBY, ( uint8_t* )&standbyConfig, 1 );
 803a0c0:	f10d 0107 	add.w	r1, sp, #7
 803a0c4:	2080      	movs	r0, #128	; 0x80
 803a0c6:	f7ff ffd1 	bl	803a06c <SUBGRF_WriteCommand>
    if( standbyConfig == STDBY_RC )
 803a0ca:	f89d 3007 	ldrb.w	r3, [sp, #7]
 803a0ce:	2b00      	cmp	r3, #0
 803a0d0:	4b03      	ldr	r3, [pc, #12]	; (803a0e0 <SUBGRF_SetStandby+0x28>)
        OperatingMode = MODE_STDBY_XOSC;
 803a0d2:	bf0c      	ite	eq
 803a0d4:	2201      	moveq	r2, #1
 803a0d6:	2202      	movne	r2, #2
 803a0d8:	701a      	strb	r2, [r3, #0]
}
 803a0da:	b003      	add	sp, #12
 803a0dc:	f85d fb04 	ldr.w	pc, [sp], #4
 803a0e0:	20005a80 	.word	0x20005a80

0803a0e4 <SUBGRF_SetTx>:
{
 803a0e4:	b507      	push	{r0, r1, r2, lr}
    OperatingMode = MODE_TX;
 803a0e6:	4b09      	ldr	r3, [pc, #36]	; (803a10c <SUBGRF_SetTx+0x28>)
    buf[2] = ( uint8_t )( timeout & 0xFF );
 803a0e8:	f88d 0006 	strb.w	r0, [sp, #6]
    OperatingMode = MODE_TX;
 803a0ec:	2204      	movs	r2, #4
 803a0ee:	701a      	strb	r2, [r3, #0]
    buf[0] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 803a0f0:	0c03      	lsrs	r3, r0, #16
 803a0f2:	f88d 3004 	strb.w	r3, [sp, #4]
    SUBGRF_WriteCommand( RADIO_SET_TX, buf, 3 );
 803a0f6:	2203      	movs	r2, #3
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 803a0f8:	0a03      	lsrs	r3, r0, #8
    SUBGRF_WriteCommand( RADIO_SET_TX, buf, 3 );
 803a0fa:	a901      	add	r1, sp, #4
 803a0fc:	2083      	movs	r0, #131	; 0x83
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 803a0fe:	f88d 3005 	strb.w	r3, [sp, #5]
    SUBGRF_WriteCommand( RADIO_SET_TX, buf, 3 );
 803a102:	f7ff ffb3 	bl	803a06c <SUBGRF_WriteCommand>
}
 803a106:	b003      	add	sp, #12
 803a108:	f85d fb04 	ldr.w	pc, [sp], #4
 803a10c:	20005a80 	.word	0x20005a80

0803a110 <SUBGRF_SetRx>:
{
 803a110:	b507      	push	{r0, r1, r2, lr}
    OperatingMode = MODE_RX;
 803a112:	4b09      	ldr	r3, [pc, #36]	; (803a138 <SUBGRF_SetRx+0x28>)
    buf[2] = ( uint8_t )( timeout & 0xFF );
 803a114:	f88d 0006 	strb.w	r0, [sp, #6]
    OperatingMode = MODE_RX;
 803a118:	2205      	movs	r2, #5
 803a11a:	701a      	strb	r2, [r3, #0]
    buf[0] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 803a11c:	0c03      	lsrs	r3, r0, #16
 803a11e:	f88d 3004 	strb.w	r3, [sp, #4]
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 803a122:	2203      	movs	r2, #3
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 803a124:	0a03      	lsrs	r3, r0, #8
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 803a126:	a901      	add	r1, sp, #4
 803a128:	2082      	movs	r0, #130	; 0x82
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 803a12a:	f88d 3005 	strb.w	r3, [sp, #5]
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 803a12e:	f7ff ff9d 	bl	803a06c <SUBGRF_WriteCommand>
}
 803a132:	b003      	add	sp, #12
 803a134:	f85d fb04 	ldr.w	pc, [sp], #4
 803a138:	20005a80 	.word	0x20005a80

0803a13c <SUBGRF_SetRxDutyCycle>:
{
 803a13c:	b507      	push	{r0, r1, r2, lr}
    buf[0] = ( uint8_t )( ( rxTime >> 16 ) & 0xFF );
 803a13e:	0c03      	lsrs	r3, r0, #16
 803a140:	f88d 3000 	strb.w	r3, [sp]
    buf[1] = ( uint8_t )( ( rxTime >> 8 ) & 0xFF );
 803a144:	0a03      	lsrs	r3, r0, #8
 803a146:	f88d 3001 	strb.w	r3, [sp, #1]
    buf[3] = ( uint8_t )( ( sleepTime >> 16 ) & 0xFF );
 803a14a:	0c0b      	lsrs	r3, r1, #16
    buf[4] = ( uint8_t )( ( sleepTime >> 8 ) & 0xFF );
 803a14c:	ba49      	rev16	r1, r1
    buf[2] = ( uint8_t )( rxTime & 0xFF );
 803a14e:	f88d 0002 	strb.w	r0, [sp, #2]
    buf[4] = ( uint8_t )( ( sleepTime >> 8 ) & 0xFF );
 803a152:	f8ad 1004 	strh.w	r1, [sp, #4]
    SUBGRF_WriteCommand( RADIO_SET_RXDUTYCYCLE, buf, 6 );
 803a156:	2206      	movs	r2, #6
 803a158:	4669      	mov	r1, sp
 803a15a:	2094      	movs	r0, #148	; 0x94
    buf[3] = ( uint8_t )( ( sleepTime >> 16 ) & 0xFF );
 803a15c:	f88d 3003 	strb.w	r3, [sp, #3]
    SUBGRF_WriteCommand( RADIO_SET_RXDUTYCYCLE, buf, 6 );
 803a160:	f7ff ff84 	bl	803a06c <SUBGRF_WriteCommand>
    OperatingMode = MODE_RX_DC;
 803a164:	4b02      	ldr	r3, [pc, #8]	; (803a170 <SUBGRF_SetRxDutyCycle+0x34>)
 803a166:	2206      	movs	r2, #6
 803a168:	701a      	strb	r2, [r3, #0]
}
 803a16a:	b003      	add	sp, #12
 803a16c:	f85d fb04 	ldr.w	pc, [sp], #4
 803a170:	20005a80 	.word	0x20005a80

0803a174 <SUBGRF_SetCad>:
    SUBGRF_WriteCommand( RADIO_SET_CAD, 0, 0 );
 803a174:	2200      	movs	r2, #0
{
 803a176:	b508      	push	{r3, lr}
    SUBGRF_WriteCommand( RADIO_SET_CAD, 0, 0 );
 803a178:	4611      	mov	r1, r2
 803a17a:	20c5      	movs	r0, #197	; 0xc5
 803a17c:	f7ff ff76 	bl	803a06c <SUBGRF_WriteCommand>
    OperatingMode = MODE_CAD;
 803a180:	4b01      	ldr	r3, [pc, #4]	; (803a188 <SUBGRF_SetCad+0x14>)
 803a182:	2207      	movs	r2, #7
 803a184:	701a      	strb	r2, [r3, #0]
}
 803a186:	bd08      	pop	{r3, pc}
 803a188:	20005a80 	.word	0x20005a80

0803a18c <SUBGRF_SetTxContinuousWave>:
    SUBGRF_WriteCommand( RADIO_SET_TXCONTINUOUSWAVE, 0, 0 );
 803a18c:	2200      	movs	r2, #0
 803a18e:	4611      	mov	r1, r2
 803a190:	20d1      	movs	r0, #209	; 0xd1
 803a192:	f7ff bf6b 	b.w	803a06c <SUBGRF_WriteCommand>

0803a196 <SUBGRF_SetTxInfinitePreamble>:
    SUBGRF_WriteCommand( RADIO_SET_TXCONTINUOUSPREAMBLE, 0, 0 );
 803a196:	2200      	movs	r2, #0
 803a198:	4611      	mov	r1, r2
 803a19a:	20d2      	movs	r0, #210	; 0xd2
 803a19c:	f7ff bf66 	b.w	803a06c <SUBGRF_WriteCommand>

0803a1a0 <SUBGRF_SetStopRxTimerOnPreambleDetect>:
{
 803a1a0:	b507      	push	{r0, r1, r2, lr}
    SUBGRF_WriteCommand( RADIO_SET_STOPRXTIMERONPREAMBLE, ( uint8_t* )&enable, 1 );
 803a1a2:	2201      	movs	r2, #1
{
 803a1a4:	f88d 0007 	strb.w	r0, [sp, #7]
    SUBGRF_WriteCommand( RADIO_SET_STOPRXTIMERONPREAMBLE, ( uint8_t* )&enable, 1 );
 803a1a8:	f10d 0107 	add.w	r1, sp, #7
 803a1ac:	209f      	movs	r0, #159	; 0x9f
 803a1ae:	f7ff ff5d 	bl	803a06c <SUBGRF_WriteCommand>
}
 803a1b2:	b003      	add	sp, #12
 803a1b4:	f85d fb04 	ldr.w	pc, [sp], #4

0803a1b8 <SUBGRF_SetRegulatorMode>:
{
 803a1b8:	b507      	push	{r0, r1, r2, lr}
    if ( ( 1UL == RBI_IsDCDC() ) && ( 1UL == DCDC_ENABLE ) )
 803a1ba:	f7f2 ffb1 	bl	802d120 <RBI_IsDCDC>
 803a1be:	1e43      	subs	r3, r0, #1
 803a1c0:	4258      	negs	r0, r3
 803a1c2:	4158      	adcs	r0, r3
 803a1c4:	f88d 0007 	strb.w	r0, [sp, #7]
    SUBGRF_WriteCommand( RADIO_SET_REGULATORMODE, ( uint8_t* )&mode, 1 );
 803a1c8:	2201      	movs	r2, #1
 803a1ca:	f10d 0107 	add.w	r1, sp, #7
 803a1ce:	2096      	movs	r0, #150	; 0x96
 803a1d0:	f7ff ff4c 	bl	803a06c <SUBGRF_WriteCommand>
}
 803a1d4:	b003      	add	sp, #12
 803a1d6:	f85d fb04 	ldr.w	pc, [sp], #4

0803a1da <SUBGRF_Calibrate>:
{
 803a1da:	b507      	push	{r0, r1, r2, lr}
                      ( ( uint8_t )calibParam.Fields.RC13MEnable << 1 ) |
 803a1dc:	f000 007f 	and.w	r0, r0, #127	; 0x7f
    uint8_t value = ( ( ( uint8_t )calibParam.Fields.ImgEnable << 6 ) |
 803a1e0:	f88d 0007 	strb.w	r0, [sp, #7]
    SUBGRF_WriteCommand( RADIO_CALIBRATE, &value, 1 );
 803a1e4:	2201      	movs	r2, #1
 803a1e6:	f10d 0107 	add.w	r1, sp, #7
 803a1ea:	2089      	movs	r0, #137	; 0x89
 803a1ec:	f7ff ff3e 	bl	803a06c <SUBGRF_WriteCommand>
}
 803a1f0:	b003      	add	sp, #12
 803a1f2:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0803a1f8 <SUBGRF_CalibrateImage>:
    if( freq > 900000000 )
 803a1f8:	4b13      	ldr	r3, [pc, #76]	; (803a248 <SUBGRF_CalibrateImage+0x50>)
 803a1fa:	4298      	cmp	r0, r3
{
 803a1fc:	b507      	push	{r0, r1, r2, lr}
    if( freq > 900000000 )
 803a1fe:	d90b      	bls.n	803a218 <SUBGRF_CalibrateImage+0x20>
        calFreq[0] = 0xE1;
 803a200:	f64e 13e1 	movw	r3, #59873	; 0xe9e1
        calFreq[0] = 0x6B;
 803a204:	f8ad 3004 	strh.w	r3, [sp, #4]
    SUBGRF_WriteCommand( RADIO_CALIBRATEIMAGE, calFreq, 2 );
 803a208:	2202      	movs	r2, #2
 803a20a:	a901      	add	r1, sp, #4
 803a20c:	2098      	movs	r0, #152	; 0x98
 803a20e:	f7ff ff2d 	bl	803a06c <SUBGRF_WriteCommand>
}
 803a212:	b003      	add	sp, #12
 803a214:	f85d fb04 	ldr.w	pc, [sp], #4
    else if( freq > 850000000 )
 803a218:	4b0c      	ldr	r3, [pc, #48]	; (803a24c <SUBGRF_CalibrateImage+0x54>)
 803a21a:	4298      	cmp	r0, r3
 803a21c:	d902      	bls.n	803a224 <SUBGRF_CalibrateImage+0x2c>
        calFreq[0] = 0xD7;
 803a21e:	f64d 33d7 	movw	r3, #56279	; 0xdbd7
 803a222:	e7ef      	b.n	803a204 <SUBGRF_CalibrateImage+0xc>
    else if( freq > 770000000 )
 803a224:	4b0a      	ldr	r3, [pc, #40]	; (803a250 <SUBGRF_CalibrateImage+0x58>)
 803a226:	4298      	cmp	r0, r3
 803a228:	d902      	bls.n	803a230 <SUBGRF_CalibrateImage+0x38>
        calFreq[0] = 0xC1;
 803a22a:	f24c 53c1 	movw	r3, #50625	; 0xc5c1
 803a22e:	e7e9      	b.n	803a204 <SUBGRF_CalibrateImage+0xc>
    else if( freq > 460000000 )
 803a230:	4b08      	ldr	r3, [pc, #32]	; (803a254 <SUBGRF_CalibrateImage+0x5c>)
 803a232:	4298      	cmp	r0, r3
 803a234:	d902      	bls.n	803a23c <SUBGRF_CalibrateImage+0x44>
        calFreq[0] = 0x75;
 803a236:	f248 1375 	movw	r3, #33141	; 0x8175
 803a23a:	e7e3      	b.n	803a204 <SUBGRF_CalibrateImage+0xc>
    else if( freq > 425000000 )
 803a23c:	4b06      	ldr	r3, [pc, #24]	; (803a258 <SUBGRF_CalibrateImage+0x60>)
 803a23e:	4298      	cmp	r0, r3
 803a240:	d9e2      	bls.n	803a208 <SUBGRF_CalibrateImage+0x10>
        calFreq[0] = 0x6B;
 803a242:	f646 736b 	movw	r3, #28523	; 0x6f6b
 803a246:	e7dd      	b.n	803a204 <SUBGRF_CalibrateImage+0xc>
 803a248:	35a4e900 	.word	0x35a4e900
 803a24c:	32a9f880 	.word	0x32a9f880
 803a250:	2de54480 	.word	0x2de54480
 803a254:	1b6b0b00 	.word	0x1b6b0b00
 803a258:	1954fc40 	.word	0x1954fc40

0803a25c <SUBGRF_SetPaConfig>:
{
 803a25c:	b507      	push	{r0, r1, r2, lr}
    buf[2] = deviceSel;
 803a25e:	f88d 2006 	strb.w	r2, [sp, #6]
    SUBGRF_WriteCommand( RADIO_SET_PACONFIG, buf, 4 );
 803a262:	2204      	movs	r2, #4
    buf[0] = paDutyCycle;
 803a264:	f88d 0004 	strb.w	r0, [sp, #4]
    buf[1] = hpMax;
 803a268:	f88d 1005 	strb.w	r1, [sp, #5]
    SUBGRF_WriteCommand( RADIO_SET_PACONFIG, buf, 4 );
 803a26c:	2095      	movs	r0, #149	; 0x95
 803a26e:	eb0d 0102 	add.w	r1, sp, r2
    buf[3] = paLut;
 803a272:	f88d 3007 	strb.w	r3, [sp, #7]
    SUBGRF_WriteCommand( RADIO_SET_PACONFIG, buf, 4 );
 803a276:	f7ff fef9 	bl	803a06c <SUBGRF_WriteCommand>
}
 803a27a:	b003      	add	sp, #12
 803a27c:	f85d fb04 	ldr.w	pc, [sp], #4

0803a280 <SUBGRF_SetDioIrqParams>:
{
 803a280:	b507      	push	{r0, r1, r2, lr}
    buf[4] = ( uint8_t )( ( dio2Mask >> 8 ) & 0x00FF );
 803a282:	ba52      	rev16	r2, r2
 803a284:	f8ad 2004 	strh.w	r2, [sp, #4]
    buf[0] = ( uint8_t )( ( irqMask >> 8 ) & 0x00FF );
 803a288:	ba40      	rev16	r0, r0
    SUBGRF_WriteCommand( RADIO_CFG_DIOIRQ, buf, 8 );
 803a28a:	2208      	movs	r2, #8
    buf[2] = ( uint8_t )( ( dio1Mask >> 8 ) & 0x00FF );
 803a28c:	ba49      	rev16	r1, r1
    buf[0] = ( uint8_t )( ( irqMask >> 8 ) & 0x00FF );
 803a28e:	f8ad 0000 	strh.w	r0, [sp]
    buf[2] = ( uint8_t )( ( dio1Mask >> 8 ) & 0x00FF );
 803a292:	f8ad 1002 	strh.w	r1, [sp, #2]
    buf[6] = ( uint8_t )( ( dio3Mask >> 8 ) & 0x00FF );
 803a296:	ba5b      	rev16	r3, r3
    SUBGRF_WriteCommand( RADIO_CFG_DIOIRQ, buf, 8 );
 803a298:	4669      	mov	r1, sp
 803a29a:	4610      	mov	r0, r2
    buf[6] = ( uint8_t )( ( dio3Mask >> 8 ) & 0x00FF );
 803a29c:	f8ad 3006 	strh.w	r3, [sp, #6]
    SUBGRF_WriteCommand( RADIO_CFG_DIOIRQ, buf, 8 );
 803a2a0:	f7ff fee4 	bl	803a06c <SUBGRF_WriteCommand>
}
 803a2a4:	b003      	add	sp, #12
 803a2a6:	f85d fb04 	ldr.w	pc, [sp], #4

0803a2aa <SUBGRF_SetTcxoMode>:
{
 803a2aa:	b507      	push	{r0, r1, r2, lr}
    buf[1] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 803a2ac:	0c0b      	lsrs	r3, r1, #16
    SUBGRF_WriteCommand( RADIO_SET_TCXOMODE, buf, 4 );
 803a2ae:	2204      	movs	r2, #4
    buf[0] = tcxoVoltage & 0x07;
 803a2b0:	f000 0007 	and.w	r0, r0, #7
    buf[2] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 803a2b4:	ba49      	rev16	r1, r1
    buf[0] = tcxoVoltage & 0x07;
 803a2b6:	f88d 0004 	strb.w	r0, [sp, #4]
    buf[2] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 803a2ba:	f8ad 1006 	strh.w	r1, [sp, #6]
    SUBGRF_WriteCommand( RADIO_SET_TCXOMODE, buf, 4 );
 803a2be:	2097      	movs	r0, #151	; 0x97
 803a2c0:	eb0d 0102 	add.w	r1, sp, r2
    buf[1] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 803a2c4:	f88d 3005 	strb.w	r3, [sp, #5]
    SUBGRF_WriteCommand( RADIO_SET_TCXOMODE, buf, 4 );
 803a2c8:	f7ff fed0 	bl	803a06c <SUBGRF_WriteCommand>
}
 803a2cc:	b003      	add	sp, #12
 803a2ce:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0803a2d4 <SUBGRF_SetRfFrequency>:
{
 803a2d4:	b537      	push	{r0, r1, r2, r4, r5, lr}
    if( ImageCalibrated == false )
 803a2d6:	4d0c      	ldr	r5, [pc, #48]	; (803a308 <SUBGRF_SetRfFrequency+0x34>)
 803a2d8:	786b      	ldrb	r3, [r5, #1]
{
 803a2da:	4604      	mov	r4, r0
    if( ImageCalibrated == false )
 803a2dc:	b91b      	cbnz	r3, 803a2e6 <SUBGRF_SetRfFrequency+0x12>
        SUBGRF_CalibrateImage( frequency );
 803a2de:	f7ff ff8b 	bl	803a1f8 <SUBGRF_CalibrateImage>
        ImageCalibrated = true;
 803a2e2:	2301      	movs	r3, #1
 803a2e4:	706b      	strb	r3, [r5, #1]
    SX_FREQ_TO_CHANNEL(chan, frequency);   
 803a2e6:	2300      	movs	r3, #0
 803a2e8:	4a08      	ldr	r2, [pc, #32]	; (803a30c <SUBGRF_SetRfFrequency+0x38>)
 803a2ea:	0660      	lsls	r0, r4, #25
 803a2ec:	09e1      	lsrs	r1, r4, #7
 803a2ee:	f7f1 fc29 	bl	802bb44 <__aeabi_uldivmod>
    SUBGRF_WriteCommand( RADIO_SET_RFFREQUENCY, buf, 4 );
 803a2f2:	2204      	movs	r2, #4
 803a2f4:	ba00      	rev	r0, r0
    buf[0] = ( uint8_t )( ( chan >> 24 ) & 0xFF );
 803a2f6:	9001      	str	r0, [sp, #4]
    SUBGRF_WriteCommand( RADIO_SET_RFFREQUENCY, buf, 4 );
 803a2f8:	eb0d 0102 	add.w	r1, sp, r2
 803a2fc:	2086      	movs	r0, #134	; 0x86
 803a2fe:	f7ff feb5 	bl	803a06c <SUBGRF_WriteCommand>
}
 803a302:	b003      	add	sp, #12
 803a304:	bd30      	pop	{r4, r5, pc}
 803a306:	bf00      	nop
 803a308:	20005a80 	.word	0x20005a80
 803a30c:	01e84800 	.word	0x01e84800

0803a310 <SUBGRF_SetBufferBaseAddress>:
{
 803a310:	b507      	push	{r0, r1, r2, lr}
    SUBGRF_WriteCommand( RADIO_SET_BUFFERBASEADDRESS, buf, 2 );
 803a312:	2202      	movs	r2, #2
    buf[0] = txBaseAddress;
 803a314:	f88d 0004 	strb.w	r0, [sp, #4]
    buf[1] = rxBaseAddress;
 803a318:	f88d 1005 	strb.w	r1, [sp, #5]
    SUBGRF_WriteCommand( RADIO_SET_BUFFERBASEADDRESS, buf, 2 );
 803a31c:	208f      	movs	r0, #143	; 0x8f
 803a31e:	a901      	add	r1, sp, #4
 803a320:	f7ff fea4 	bl	803a06c <SUBGRF_WriteCommand>
}
 803a324:	b003      	add	sp, #12
 803a326:	f85d fb04 	ldr.w	pc, [sp], #4

0803a32a <SUBGRF_GetRssiInst>:
{
 803a32a:	b507      	push	{r0, r1, r2, lr}
    SUBGRF_ReadCommand( RADIO_GET_RSSIINST, buf, 1 );
 803a32c:	2201      	movs	r2, #1
 803a32e:	a901      	add	r1, sp, #4
 803a330:	2015      	movs	r0, #21
 803a332:	f7ff feab 	bl	803a08c <SUBGRF_ReadCommand>
    rssi = -buf[0] >> 1;
 803a336:	f89d 0004 	ldrb.w	r0, [sp, #4]
 803a33a:	4240      	negs	r0, r0
}
 803a33c:	1040      	asrs	r0, r0, #1
 803a33e:	b003      	add	sp, #12
 803a340:	f85d fb04 	ldr.w	pc, [sp], #4

0803a344 <SUBGRF_GetPacketStatus>:
{
 803a344:	b513      	push	{r0, r1, r4, lr}
    SUBGRF_ReadCommand( RADIO_GET_PACKETSTATUS, status, 3 );
 803a346:	2203      	movs	r2, #3
{
 803a348:	4604      	mov	r4, r0
    SUBGRF_ReadCommand( RADIO_GET_PACKETSTATUS, status, 3 );
 803a34a:	a901      	add	r1, sp, #4
 803a34c:	2014      	movs	r0, #20
 803a34e:	f7ff fe9d 	bl	803a08c <SUBGRF_ReadCommand>
    return PacketType;
 803a352:	4918      	ldr	r1, [pc, #96]	; (803a3b4 <SUBGRF_GetPacketStatus+0x70>)
 803a354:	788a      	ldrb	r2, [r1, #2]
    pktStatus->packetType = SUBGRF_GetPacketType( );
 803a356:	7022      	strb	r2, [r4, #0]
    switch( pktStatus->packetType )
 803a358:	b14a      	cbz	r2, 803a36e <SUBGRF_GetPacketStatus+0x2a>
 803a35a:	2a01      	cmp	r2, #1
 803a35c:	d017      	beq.n	803a38e <SUBGRF_GetPacketStatus+0x4a>
            RADIO_MEMSET8( pktStatus, 0, sizeof( PacketStatus_t ) );
 803a35e:	2214      	movs	r2, #20
 803a360:	2100      	movs	r1, #0
 803a362:	4620      	mov	r0, r4
 803a364:	f000 fda4 	bl	803aeb0 <UTIL_MEM_set_8>
            pktStatus->packetType = PACKET_TYPE_NONE;
 803a368:	230f      	movs	r3, #15
 803a36a:	7023      	strb	r3, [r4, #0]
}
 803a36c:	e00d      	b.n	803a38a <SUBGRF_GetPacketStatus+0x46>
            pktStatus->Params.Gfsk.RxStatus = status[0];
 803a36e:	f89d 3004 	ldrb.w	r3, [sp, #4]
 803a372:	7123      	strb	r3, [r4, #4]
            pktStatus->Params.Gfsk.RssiSync = -status[1] >> 1;
 803a374:	f89d 3005 	ldrb.w	r3, [sp, #5]
            pktStatus->Params.Gfsk.FreqError = 0;
 803a378:	60a2      	str	r2, [r4, #8]
            pktStatus->Params.Gfsk.RssiSync = -status[1] >> 1;
 803a37a:	425b      	negs	r3, r3
 803a37c:	105b      	asrs	r3, r3, #1
 803a37e:	71a3      	strb	r3, [r4, #6]
            pktStatus->Params.Gfsk.RssiAvg = -status[2] >> 1;
 803a380:	f89d 3006 	ldrb.w	r3, [sp, #6]
 803a384:	425b      	negs	r3, r3
 803a386:	105b      	asrs	r3, r3, #1
 803a388:	7163      	strb	r3, [r4, #5]
}
 803a38a:	b002      	add	sp, #8
 803a38c:	bd10      	pop	{r4, pc}
            pktStatus->Params.LoRa.RssiPkt = -status[0] >> 1;
 803a38e:	f89d 3004 	ldrb.w	r3, [sp, #4]
 803a392:	425b      	negs	r3, r3
 803a394:	105b      	asrs	r3, r3, #1
 803a396:	7323      	strb	r3, [r4, #12]
            pktStatus->Params.LoRa.SnrPkt = ( ( ( int8_t )status[1] ) + 2 ) >> 2;
 803a398:	f99d 3005 	ldrsb.w	r3, [sp, #5]
 803a39c:	3302      	adds	r3, #2
 803a39e:	109b      	asrs	r3, r3, #2
 803a3a0:	7363      	strb	r3, [r4, #13]
            pktStatus->Params.LoRa.SignalRssiPkt = -status[2] >> 1;
 803a3a2:	f89d 3006 	ldrb.w	r3, [sp, #6]
 803a3a6:	425b      	negs	r3, r3
 803a3a8:	105b      	asrs	r3, r3, #1
 803a3aa:	73a3      	strb	r3, [r4, #14]
            pktStatus->Params.LoRa.FreqError = FrequencyError;
 803a3ac:	684b      	ldr	r3, [r1, #4]
 803a3ae:	6123      	str	r3, [r4, #16]
            break;
 803a3b0:	e7eb      	b.n	803a38a <SUBGRF_GetPacketStatus+0x46>
 803a3b2:	bf00      	nop
 803a3b4:	20005a80 	.word	0x20005a80

0803a3b8 <SUBGRF_WriteRegister>:
{
 803a3b8:	b507      	push	{r0, r1, r2, lr}
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 803a3ba:	2301      	movs	r3, #1
{
 803a3bc:	f88d 1007 	strb.w	r1, [sp, #7]
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 803a3c0:	f10d 0207 	add.w	r2, sp, #7
 803a3c4:	4601      	mov	r1, r0
 803a3c6:	4803      	ldr	r0, [pc, #12]	; (803a3d4 <SUBGRF_WriteRegister+0x1c>)
 803a3c8:	f7f5 fafe 	bl	802f9c8 <HAL_SUBGHZ_WriteRegisters>
}
 803a3cc:	b003      	add	sp, #12
 803a3ce:	f85d fb04 	ldr.w	pc, [sp], #4
 803a3d2:	bf00      	nop
 803a3d4:	200061f0 	.word	0x200061f0

0803a3d8 <SUBGRF_SetRxBoosted>:
{
 803a3d8:	b513      	push	{r0, r1, r4, lr}
    OperatingMode = MODE_RX;
 803a3da:	4b0c      	ldr	r3, [pc, #48]	; (803a40c <SUBGRF_SetRxBoosted+0x34>)
{
 803a3dc:	4604      	mov	r4, r0
    OperatingMode = MODE_RX;
 803a3de:	2205      	movs	r2, #5
    SUBGRF_WriteRegister( REG_RX_GAIN, 0x97 ); // max LNA gain, increase current by ~2mA for around ~3dB in sensitivity
 803a3e0:	2197      	movs	r1, #151	; 0x97
 803a3e2:	f640 00ac 	movw	r0, #2220	; 0x8ac
    OperatingMode = MODE_RX;
 803a3e6:	701a      	strb	r2, [r3, #0]
    SUBGRF_WriteRegister( REG_RX_GAIN, 0x97 ); // max LNA gain, increase current by ~2mA for around ~3dB in sensitivity
 803a3e8:	f7ff ffe6 	bl	803a3b8 <SUBGRF_WriteRegister>
    buf[0] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 803a3ec:	0c23      	lsrs	r3, r4, #16
 803a3ee:	f88d 3004 	strb.w	r3, [sp, #4]
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 803a3f2:	2203      	movs	r2, #3
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 803a3f4:	0a23      	lsrs	r3, r4, #8
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 803a3f6:	a901      	add	r1, sp, #4
 803a3f8:	2082      	movs	r0, #130	; 0x82
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 803a3fa:	f88d 3005 	strb.w	r3, [sp, #5]
    buf[2] = ( uint8_t )( timeout & 0xFF );
 803a3fe:	f88d 4006 	strb.w	r4, [sp, #6]
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 803a402:	f7ff fe33 	bl	803a06c <SUBGRF_WriteCommand>
}
 803a406:	b002      	add	sp, #8
 803a408:	bd10      	pop	{r4, pc}
 803a40a:	bf00      	nop
 803a40c:	20005a80 	.word	0x20005a80

0803a410 <SUBGRF_SetLoRaSymbNumTimeout>:
{
 803a410:	b507      	push	{r0, r1, r2, lr}
    SUBGRF_WriteCommand( RADIO_SET_LORASYMBTIMEOUT, &symbNum, 1 );
 803a412:	2201      	movs	r2, #1
{
 803a414:	f88d 0007 	strb.w	r0, [sp, #7]
    SUBGRF_WriteCommand( RADIO_SET_LORASYMBTIMEOUT, &symbNum, 1 );
 803a418:	f10d 0107 	add.w	r1, sp, #7
 803a41c:	20a0      	movs	r0, #160	; 0xa0
 803a41e:	f7ff fe25 	bl	803a06c <SUBGRF_WriteCommand>
    if( symbNum >= 64 )
 803a422:	f89d 1007 	ldrb.w	r1, [sp, #7]
 803a426:	293f      	cmp	r1, #63	; 0x3f
 803a428:	d907      	bls.n	803a43a <SUBGRF_SetLoRaSymbNumTimeout+0x2a>
        reg = exp + ( mant << 3 );
 803a42a:	f001 01f8 	and.w	r1, r1, #248	; 0xf8
 803a42e:	3101      	adds	r1, #1
        SUBGRF_WriteRegister( REG_LR_SYNCH_TIMEOUT, reg );
 803a430:	b2c9      	uxtb	r1, r1
 803a432:	f240 7006 	movw	r0, #1798	; 0x706
 803a436:	f7ff ffbf 	bl	803a3b8 <SUBGRF_WriteRegister>
}
 803a43a:	b003      	add	sp, #12
 803a43c:	f85d fb04 	ldr.w	pc, [sp], #4

0803a440 <SUBGRF_SetPacketType>:
{
 803a440:	b507      	push	{r0, r1, r2, lr}
    PacketType = packetType;
 803a442:	4b09      	ldr	r3, [pc, #36]	; (803a468 <SUBGRF_SetPacketType+0x28>)
{
 803a444:	f88d 0007 	strb.w	r0, [sp, #7]
 803a448:	4601      	mov	r1, r0
    PacketType = packetType;
 803a44a:	7098      	strb	r0, [r3, #2]
    if( packetType == PACKET_TYPE_GFSK )
 803a44c:	b918      	cbnz	r0, 803a456 <SUBGRF_SetPacketType+0x16>
        SUBGRF_WriteRegister( REG_BIT_SYNC, 0x00 );
 803a44e:	f240 60ac 	movw	r0, #1708	; 0x6ac
 803a452:	f7ff ffb1 	bl	803a3b8 <SUBGRF_WriteRegister>
    SUBGRF_WriteCommand( RADIO_SET_PACKETTYPE, ( uint8_t* )&packetType, 1 );
 803a456:	2201      	movs	r2, #1
 803a458:	f10d 0107 	add.w	r1, sp, #7
 803a45c:	208a      	movs	r0, #138	; 0x8a
 803a45e:	f7ff fe05 	bl	803a06c <SUBGRF_WriteCommand>
}
 803a462:	b003      	add	sp, #12
 803a464:	f85d fb04 	ldr.w	pc, [sp], #4
 803a468:	20005a80 	.word	0x20005a80

0803a46c <SUBGRF_SetModulationParams>:
{
 803a46c:	b513      	push	{r0, r1, r4, lr}
    uint8_t buf[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 803a46e:	4a31      	ldr	r2, [pc, #196]	; (803a534 <SUBGRF_SetModulationParams+0xc8>)
{
 803a470:	4604      	mov	r4, r0
    uint8_t buf[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 803a472:	6851      	ldr	r1, [r2, #4]
 803a474:	6810      	ldr	r0, [r2, #0]
 803a476:	466b      	mov	r3, sp
 803a478:	c303      	stmia	r3!, {r0, r1}
    if( PacketType != modulationParams->PacketType )
 803a47a:	4b2f      	ldr	r3, [pc, #188]	; (803a538 <SUBGRF_SetModulationParams+0xcc>)
 803a47c:	7820      	ldrb	r0, [r4, #0]
 803a47e:	789b      	ldrb	r3, [r3, #2]
 803a480:	4283      	cmp	r3, r0
 803a482:	d001      	beq.n	803a488 <SUBGRF_SetModulationParams+0x1c>
        SUBGRF_SetPacketType( modulationParams->PacketType );
 803a484:	f7ff ffdc 	bl	803a440 <SUBGRF_SetPacketType>
    switch( modulationParams->PacketType )
 803a488:	7823      	ldrb	r3, [r4, #0]
 803a48a:	2b03      	cmp	r3, #3
 803a48c:	d827      	bhi.n	803a4de <SUBGRF_SetModulationParams+0x72>
 803a48e:	e8df f003 	tbb	[pc, r3]
 803a492:	3902      	.short	0x3902
 803a494:	3c28      	.short	0x3c28
        tempVal = ( uint32_t )(( 32 * XTAL_FREQ ) / modulationParams->Params.Gfsk.BitRate );
 803a496:	6862      	ldr	r2, [r4, #4]
 803a498:	4b28      	ldr	r3, [pc, #160]	; (803a53c <SUBGRF_SetModulationParams+0xd0>)
 803a49a:	fbb3 f3f2 	udiv	r3, r3, r2
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 803a49e:	0c1a      	lsrs	r2, r3, #16
        SX_FREQ_TO_CHANNEL(tempVal, modulationParams->Params.Gfsk.Fdev);
 803a4a0:	68a1      	ldr	r1, [r4, #8]
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 803a4a2:	f88d 2000 	strb.w	r2, [sp]
        buf[2] = tempVal & 0xFF;
 803a4a6:	f88d 3002 	strb.w	r3, [sp, #2]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 803a4aa:	0a1a      	lsrs	r2, r3, #8
        buf[3] = modulationParams->Params.Gfsk.ModulationShaping;
 803a4ac:	7b23      	ldrb	r3, [r4, #12]
 803a4ae:	f88d 3003 	strb.w	r3, [sp, #3]
        buf[4] = modulationParams->Params.Gfsk.Bandwidth;
 803a4b2:	7b63      	ldrb	r3, [r4, #13]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 803a4b4:	f88d 2001 	strb.w	r2, [sp, #1]
        buf[4] = modulationParams->Params.Gfsk.Bandwidth;
 803a4b8:	f88d 3004 	strb.w	r3, [sp, #4]
        SX_FREQ_TO_CHANNEL(tempVal, modulationParams->Params.Gfsk.Fdev);
 803a4bc:	4a20      	ldr	r2, [pc, #128]	; (803a540 <SUBGRF_SetModulationParams+0xd4>)
 803a4be:	2300      	movs	r3, #0
 803a4c0:	0648      	lsls	r0, r1, #25
 803a4c2:	09c9      	lsrs	r1, r1, #7
 803a4c4:	f7f1 fb3e 	bl	802bb44 <__aeabi_uldivmod>
        buf[5] = ( tempVal >> 16 ) & 0xFF;
 803a4c8:	0c03      	lsrs	r3, r0, #16
        buf[6] = ( tempVal >> 8 ) & 0xFF;
 803a4ca:	ba40      	rev16	r0, r0
        buf[5] = ( tempVal >> 16 ) & 0xFF;
 803a4cc:	f88d 3005 	strb.w	r3, [sp, #5]
        buf[6] = ( tempVal >> 8 ) & 0xFF;
 803a4d0:	f8ad 0006 	strh.w	r0, [sp, #6]
        SUBGRF_WriteCommand( RADIO_SET_MODULATIONPARAMS, buf, n );
 803a4d4:	2208      	movs	r2, #8
        SUBGRF_WriteCommand( RADIO_SET_MODULATIONPARAMS, buf, n );
 803a4d6:	4669      	mov	r1, sp
 803a4d8:	208b      	movs	r0, #139	; 0x8b
 803a4da:	f7ff fdc7 	bl	803a06c <SUBGRF_WriteCommand>
}
 803a4de:	b002      	add	sp, #8
 803a4e0:	bd10      	pop	{r4, pc}
        tempVal = ( uint32_t ) (( 32 * XTAL_FREQ) / modulationParams->Params.Bpsk.BitRate );
 803a4e2:	6922      	ldr	r2, [r4, #16]
 803a4e4:	4b15      	ldr	r3, [pc, #84]	; (803a53c <SUBGRF_SetModulationParams+0xd0>)
 803a4e6:	fbb3 f3f2 	udiv	r3, r3, r2
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 803a4ea:	0c1a      	lsrs	r2, r3, #16
 803a4ec:	f88d 2000 	strb.w	r2, [sp]
        buf[2] = tempVal & 0xFF;
 803a4f0:	f88d 3002 	strb.w	r3, [sp, #2]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 803a4f4:	0a1a      	lsrs	r2, r3, #8
        buf[3] = modulationParams->Params.Bpsk.ModulationShaping;
 803a4f6:	7d23      	ldrb	r3, [r4, #20]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 803a4f8:	f88d 2001 	strb.w	r2, [sp, #1]
        buf[3] = modulationParams->Params.Bpsk.ModulationShaping;
 803a4fc:	f88d 3003 	strb.w	r3, [sp, #3]
        SUBGRF_WriteCommand( RADIO_SET_MODULATIONPARAMS, buf, n );
 803a500:	2204      	movs	r2, #4
 803a502:	e7e8      	b.n	803a4d6 <SUBGRF_SetModulationParams+0x6a>
        buf[0] = modulationParams->Params.LoRa.SpreadingFactor;
 803a504:	69a3      	ldr	r3, [r4, #24]
 803a506:	9300      	str	r3, [sp, #0]
 803a508:	e7fa      	b.n	803a500 <SUBGRF_SetModulationParams+0x94>
        tempVal = ( uint32_t )(( 32 *XTAL_FREQ) / modulationParams->Params.Gfsk.BitRate );
 803a50a:	6862      	ldr	r2, [r4, #4]
 803a50c:	4b0b      	ldr	r3, [pc, #44]	; (803a53c <SUBGRF_SetModulationParams+0xd0>)
 803a50e:	fbb3 f3f2 	udiv	r3, r3, r2
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 803a512:	0c1a      	lsrs	r2, r3, #16
 803a514:	f88d 2000 	strb.w	r2, [sp]
        buf[2] = tempVal & 0xFF;
 803a518:	f88d 3002 	strb.w	r3, [sp, #2]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 803a51c:	0a1a      	lsrs	r2, r3, #8
        buf[3] = modulationParams->Params.Gfsk.ModulationShaping;
 803a51e:	7b23      	ldrb	r3, [r4, #12]
 803a520:	f88d 3003 	strb.w	r3, [sp, #3]
        buf[4] = modulationParams->Params.Gfsk.Bandwidth;
 803a524:	7b63      	ldrb	r3, [r4, #13]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 803a526:	f88d 2001 	strb.w	r2, [sp, #1]
        buf[4] = modulationParams->Params.Gfsk.Bandwidth;
 803a52a:	f88d 3004 	strb.w	r3, [sp, #4]
        SUBGRF_WriteCommand( RADIO_SET_MODULATIONPARAMS, buf, n );
 803a52e:	2205      	movs	r2, #5
 803a530:	e7d1      	b.n	803a4d6 <SUBGRF_SetModulationParams+0x6a>
 803a532:	bf00      	nop
 803a534:	0803bc44 	.word	0x0803bc44
 803a538:	20005a80 	.word	0x20005a80
 803a53c:	3d090000 	.word	0x3d090000
 803a540:	01e84800 	.word	0x01e84800

0803a544 <SUBGRF_ReadRegister>:
{
 803a544:	b507      	push	{r0, r1, r2, lr}
    HAL_SUBGHZ_ReadRegisters( &hsubghz, addr, &data, 1 );
 803a546:	2301      	movs	r3, #1
{
 803a548:	4601      	mov	r1, r0
    HAL_SUBGHZ_ReadRegisters( &hsubghz, addr, &data, 1 );
 803a54a:	f10d 0207 	add.w	r2, sp, #7
 803a54e:	4804      	ldr	r0, [pc, #16]	; (803a560 <SUBGRF_ReadRegister+0x1c>)
 803a550:	f7f5 fa73 	bl	802fa3a <HAL_SUBGHZ_ReadRegisters>
}
 803a554:	f89d 0007 	ldrb.w	r0, [sp, #7]
 803a558:	b003      	add	sp, #12
 803a55a:	f85d fb04 	ldr.w	pc, [sp], #4
 803a55e:	bf00      	nop
 803a560:	200061f0 	.word	0x200061f0

0803a564 <Radio_SMPS_Set>:
{
    RadioOnDioIrqCb( IRQ_HEADER_VALID );
}

static void Radio_SMPS_Set(uint8_t level)
{
 803a564:	b510      	push	{r4, lr}
 803a566:	4604      	mov	r4, r0
  if ( 1U == RBI_IsDCDC() )
 803a568:	f7f2 fdda 	bl	802d120 <RBI_IsDCDC>
 803a56c:	2801      	cmp	r0, #1
 803a56e:	d10c      	bne.n	803a58a <Radio_SMPS_Set+0x26>
  {
    uint8_t modReg;
    modReg= SUBGRF_ReadRegister(SUBGHZ_SMPSC2R);
 803a570:	f640 1023 	movw	r0, #2339	; 0x923
 803a574:	f7ff ffe6 	bl	803a544 <SUBGRF_ReadRegister>
    modReg&= (~SMPS_DRV_MASK);
    SUBGRF_WriteRegister(SUBGHZ_SMPSC2R, modReg | level);
 803a578:	f000 01f9 	and.w	r1, r0, #249	; 0xf9
 803a57c:	4321      	orrs	r1, r4
 803a57e:	f640 1023 	movw	r0, #2339	; 0x923
  }
}
 803a582:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    SUBGRF_WriteRegister(SUBGHZ_SMPSC2R, modReg | level);
 803a586:	f7ff bf17 	b.w	803a3b8 <SUBGRF_WriteRegister>
}
 803a58a:	bd10      	pop	{r4, pc}

0803a58c <SUBGRF_Init>:
{
 803a58c:	b538      	push	{r3, r4, r5, lr}
 803a58e:	4c16      	ldr	r4, [pc, #88]	; (803a5e8 <SUBGRF_Init+0x5c>)
    if ( dioIrq != NULL)
 803a590:	b100      	cbz	r0, 803a594 <SUBGRF_Init+0x8>
        RadioOnDioIrqCb = dioIrq;
 803a592:	60a0      	str	r0, [r4, #8]
    RADIO_INIT();
 803a594:	f7f1 ff5a 	bl	802c44c <MX_SUBGHZ_Init>
    ImageCalibrated = false;
 803a598:	2500      	movs	r5, #0
    Radio_SMPS_Set(SMPS_DRIVE_SETTING_DEFAULT);
 803a59a:	2002      	movs	r0, #2
 803a59c:	f7ff ffe2 	bl	803a564 <Radio_SMPS_Set>
    SUBGRF_SetStandby( STDBY_RC );
 803a5a0:	4628      	mov	r0, r5
    ImageCalibrated = false;
 803a5a2:	7065      	strb	r5, [r4, #1]
    SUBGRF_SetStandby( STDBY_RC );
 803a5a4:	f7ff fd88 	bl	803a0b8 <SUBGRF_SetStandby>
    if (1U == RBI_IsTCXO() )
 803a5a8:	f7f2 fdb8 	bl	802d11c <RBI_IsTCXO>
 803a5ac:	2801      	cmp	r0, #1
 803a5ae:	d110      	bne.n	803a5d2 <SUBGRF_Init+0x46>
        SUBGRF_SetTcxoMode( TCXO_CTRL_VOLTAGE, RF_WAKEUP_TIME << 6 );// 100 ms
 803a5b0:	2140      	movs	r1, #64	; 0x40
 803a5b2:	f7ff fe7a 	bl	803a2aa <SUBGRF_SetTcxoMode>
        SUBGRF_WriteRegister( REG_XTA_TRIM, 0x00 );
 803a5b6:	f640 1011 	movw	r0, #2321	; 0x911
 803a5ba:	4629      	mov	r1, r5
 803a5bc:	f7ff fefc 	bl	803a3b8 <SUBGRF_WriteRegister>
        SUBGRF_Calibrate( calibParam );
 803a5c0:	f04f 007f 	mov.w	r0, #127	; 0x7f
 803a5c4:	f7ff fe09 	bl	803a1da <SUBGRF_Calibrate>
    RBI_Init();
 803a5c8:	f7f2 fda2 	bl	802d110 <RBI_Init>
    OperatingMode = MODE_STDBY_RC;
 803a5cc:	2301      	movs	r3, #1
 803a5ce:	7023      	strb	r3, [r4, #0]
}
 803a5d0:	bd38      	pop	{r3, r4, r5, pc}
        SUBGRF_WriteRegister( REG_XTA_TRIM, XTAL_DEFAULT_CAP_VALUE );
 803a5d2:	2120      	movs	r1, #32
 803a5d4:	f640 1011 	movw	r0, #2321	; 0x911
 803a5d8:	f7ff feee 	bl	803a3b8 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_XTB_TRIM, XTAL_DEFAULT_CAP_VALUE );
 803a5dc:	2120      	movs	r1, #32
 803a5de:	f640 1012 	movw	r0, #2322	; 0x912
 803a5e2:	f7ff fee9 	bl	803a3b8 <SUBGRF_WriteRegister>
 803a5e6:	e7ef      	b.n	803a5c8 <SUBGRF_Init+0x3c>
 803a5e8:	20005a80 	.word	0x20005a80

0803a5ec <SUBGRF_SetSleep>:
{
 803a5ec:	b513      	push	{r0, r1, r4, lr}
 803a5ee:	4604      	mov	r4, r0
    RBI_ConfigRFSwitch(RBI_SWITCH_OFF);
 803a5f0:	2000      	movs	r0, #0
 803a5f2:	f7f2 fd8f 	bl	802d114 <RBI_ConfigRFSwitch>
    Radio_SMPS_Set(SMPS_DRIVE_SETTING_DEFAULT);
 803a5f6:	2002      	movs	r0, #2
 803a5f8:	f7ff ffb4 	bl	803a564 <Radio_SMPS_Set>
                      ( ( uint8_t )sleepConfig.Fields.Reset << 1 ) |
 803a5fc:	f004 0407 	and.w	r4, r4, #7
    SUBGRF_WriteCommand( RADIO_SET_SLEEP, &value, 1 );
 803a600:	2201      	movs	r2, #1
 803a602:	f10d 0107 	add.w	r1, sp, #7
 803a606:	2084      	movs	r0, #132	; 0x84
    uint8_t value = ( ( ( uint8_t )sleepConfig.Fields.WarmStart << 2 ) |
 803a608:	f88d 4007 	strb.w	r4, [sp, #7]
    SUBGRF_WriteCommand( RADIO_SET_SLEEP, &value, 1 );
 803a60c:	f7ff fd2e 	bl	803a06c <SUBGRF_WriteCommand>
    OperatingMode = MODE_SLEEP;
 803a610:	4b02      	ldr	r3, [pc, #8]	; (803a61c <SUBGRF_SetSleep+0x30>)
 803a612:	2200      	movs	r2, #0
 803a614:	701a      	strb	r2, [r3, #0]
}
 803a616:	b002      	add	sp, #8
 803a618:	bd10      	pop	{r4, pc}
 803a61a:	bf00      	nop
 803a61c:	20005a80 	.word	0x20005a80

0803a620 <SUBGRF_SetWhiteningSeed>:
{
 803a620:	b510      	push	{r4, lr}
    return PacketType;
 803a622:	4b0c      	ldr	r3, [pc, #48]	; (803a654 <SUBGRF_SetWhiteningSeed+0x34>)
    switch( SUBGRF_GetPacketType( ) )
 803a624:	789b      	ldrb	r3, [r3, #2]
{
 803a626:	4604      	mov	r4, r0
    switch( SUBGRF_GetPacketType( ) )
 803a628:	b99b      	cbnz	r3, 803a652 <SUBGRF_SetWhiteningSeed+0x32>
            regValue = SUBGRF_ReadRegister( REG_LR_WHITSEEDBASEADDR_MSB ) & 0xFE;
 803a62a:	f44f 60d7 	mov.w	r0, #1720	; 0x6b8
 803a62e:	f7ff ff89 	bl	803a544 <SUBGRF_ReadRegister>
            regValue = ( ( seed >> 8 ) & 0x01 ) | regValue;
 803a632:	f3c4 2100 	ubfx	r1, r4, #8, #1
 803a636:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
            SUBGRF_WriteRegister( REG_LR_WHITSEEDBASEADDR_MSB, regValue ); // only 1 bit.
 803a63a:	4301      	orrs	r1, r0
 803a63c:	f44f 60d7 	mov.w	r0, #1720	; 0x6b8
 803a640:	f7ff feba 	bl	803a3b8 <SUBGRF_WriteRegister>
            SUBGRF_WriteRegister( REG_LR_WHITSEEDBASEADDR_LSB, (uint8_t)seed );
 803a644:	b2e1      	uxtb	r1, r4
 803a646:	f240 60b9 	movw	r0, #1721	; 0x6b9
}
 803a64a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            SUBGRF_WriteRegister( REG_LR_WHITSEEDBASEADDR_LSB, (uint8_t)seed );
 803a64e:	f7ff beb3 	b.w	803a3b8 <SUBGRF_WriteRegister>
}
 803a652:	bd10      	pop	{r4, pc}
 803a654:	20005a80 	.word	0x20005a80

0803a658 <SUBGRF_SetTxParams>:
    if( paSelect == RFO_LP )
 803a658:	2801      	cmp	r0, #1
{
 803a65a:	b537      	push	{r0, r1, r2, r4, r5, lr}
 803a65c:	4603      	mov	r3, r0
 803a65e:	460c      	mov	r4, r1
 803a660:	4615      	mov	r5, r2
    if( paSelect == RFO_LP )
 803a662:	d120      	bne.n	803a6a6 <SUBGRF_SetTxParams+0x4e>
        if( power == 15 )
 803a664:	2c0f      	cmp	r4, #15
            SUBGRF_SetPaConfig( 0x06, 0x00, 0x01, 0x01 );
 803a666:	4602      	mov	r2, r0
 803a668:	f04f 0100 	mov.w	r1, #0
 803a66c:	bf0c      	ite	eq
 803a66e:	2006      	moveq	r0, #6
            SUBGRF_SetPaConfig( 0x04, 0x00, 0x01, 0x01 );
 803a670:	2004      	movne	r0, #4
 803a672:	f7ff fdf3 	bl	803a25c <SUBGRF_SetPaConfig>
        if( power >= 14 )
 803a676:	f06f 0110 	mvn.w	r1, #16
 803a67a:	428c      	cmp	r4, r1
 803a67c:	bfb8      	it	lt
 803a67e:	460c      	movlt	r4, r1
 803a680:	2c0e      	cmp	r4, #14
 803a682:	bfa8      	it	ge
 803a684:	240e      	movge	r4, #14
        SUBGRF_WriteRegister( REG_OCP, 0x18 ); // current max is 80 mA for the whole device
 803a686:	2118      	movs	r1, #24
        SUBGRF_WriteRegister( REG_OCP, 0x38 ); // current max 160mA for the whole device
 803a688:	f640 00e7 	movw	r0, #2279	; 0x8e7
 803a68c:	f7ff fe94 	bl	803a3b8 <SUBGRF_WriteRegister>
    SUBGRF_WriteCommand( RADIO_SET_TXPARAMS, buf, 2 );
 803a690:	2202      	movs	r2, #2
 803a692:	a901      	add	r1, sp, #4
 803a694:	208e      	movs	r0, #142	; 0x8e
    buf[0] = power;
 803a696:	f88d 4004 	strb.w	r4, [sp, #4]
    buf[1] = ( uint8_t )rampTime;
 803a69a:	f88d 5005 	strb.w	r5, [sp, #5]
    SUBGRF_WriteCommand( RADIO_SET_TXPARAMS, buf, 2 );
 803a69e:	f7ff fce5 	bl	803a06c <SUBGRF_WriteCommand>
}
 803a6a2:	b003      	add	sp, #12
 803a6a4:	bd30      	pop	{r4, r5, pc}
        SUBGRF_WriteRegister( REG_TX_CLAMP, SUBGRF_ReadRegister( REG_TX_CLAMP ) | ( 0x0F << 1 ) );
 803a6a6:	f640 00d8 	movw	r0, #2264	; 0x8d8
 803a6aa:	f7ff ff4b 	bl	803a544 <SUBGRF_ReadRegister>
 803a6ae:	f040 011e 	orr.w	r1, r0, #30
 803a6b2:	b2c9      	uxtb	r1, r1
 803a6b4:	f640 00d8 	movw	r0, #2264	; 0x8d8
 803a6b8:	f7ff fe7e 	bl	803a3b8 <SUBGRF_WriteRegister>
        SUBGRF_SetPaConfig( 0x04, 0x07, 0x00, 0x01 );
 803a6bc:	2107      	movs	r1, #7
 803a6be:	2301      	movs	r3, #1
 803a6c0:	2200      	movs	r2, #0
 803a6c2:	2004      	movs	r0, #4
 803a6c4:	f7ff fdca 	bl	803a25c <SUBGRF_SetPaConfig>
        if( power > 22 )
 803a6c8:	f06f 0108 	mvn.w	r1, #8
 803a6cc:	428c      	cmp	r4, r1
 803a6ce:	bfb8      	it	lt
 803a6d0:	460c      	movlt	r4, r1
 803a6d2:	2c16      	cmp	r4, #22
 803a6d4:	bfa8      	it	ge
 803a6d6:	2416      	movge	r4, #22
        SUBGRF_WriteRegister( REG_OCP, 0x38 ); // current max 160mA for the whole device
 803a6d8:	2138      	movs	r1, #56	; 0x38
 803a6da:	e7d5      	b.n	803a688 <SUBGRF_SetTxParams+0x30>

0803a6dc <SUBGRF_GetRxBufferStatus>:
{
 803a6dc:	b537      	push	{r0, r1, r2, r4, r5, lr}
    SUBGRF_ReadCommand( RADIO_GET_RXBUFFERSTATUS, status, 2 );
 803a6de:	2202      	movs	r2, #2
{
 803a6e0:	4604      	mov	r4, r0
 803a6e2:	460d      	mov	r5, r1
    SUBGRF_ReadCommand( RADIO_GET_RXBUFFERSTATUS, status, 2 );
 803a6e4:	2013      	movs	r0, #19
 803a6e6:	a901      	add	r1, sp, #4
 803a6e8:	f7ff fcd0 	bl	803a08c <SUBGRF_ReadCommand>
    return PacketType;
 803a6ec:	4b0a      	ldr	r3, [pc, #40]	; (803a718 <SUBGRF_GetRxBufferStatus+0x3c>)
    if( ( SUBGRF_GetPacketType( ) == PACKET_TYPE_LORA ) && ( LoRaHeaderType == LORA_PACKET_FIXED_LENGTH ) )
 803a6ee:	789a      	ldrb	r2, [r3, #2]
 803a6f0:	2a01      	cmp	r2, #1
 803a6f2:	d10c      	bne.n	803a70e <SUBGRF_GetRxBufferStatus+0x32>
 803a6f4:	7b1b      	ldrb	r3, [r3, #12]
 803a6f6:	2b01      	cmp	r3, #1
 803a6f8:	d109      	bne.n	803a70e <SUBGRF_GetRxBufferStatus+0x32>
        *payloadLength = SUBGRF_ReadRegister( REG_LR_PAYLOADLENGTH );
 803a6fa:	f240 7002 	movw	r0, #1794	; 0x702
 803a6fe:	f7ff ff21 	bl	803a544 <SUBGRF_ReadRegister>
 803a702:	7020      	strb	r0, [r4, #0]
    *rxStartBufferPointer = status[1];
 803a704:	f89d 3005 	ldrb.w	r3, [sp, #5]
 803a708:	702b      	strb	r3, [r5, #0]
}
 803a70a:	b003      	add	sp, #12
 803a70c:	bd30      	pop	{r4, r5, pc}
        *payloadLength = status[0];
 803a70e:	f89d 3004 	ldrb.w	r3, [sp, #4]
 803a712:	7023      	strb	r3, [r4, #0]
 803a714:	e7f6      	b.n	803a704 <SUBGRF_GetRxBufferStatus+0x28>
 803a716:	bf00      	nop
 803a718:	20005a80 	.word	0x20005a80

0803a71c <SUBGRF_WriteRegisters>:
{
 803a71c:	b510      	push	{r4, lr}
 803a71e:	4613      	mov	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803a720:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803a724:	b672      	cpsid	i
    HAL_SUBGHZ_WriteRegisters( &hsubghz, address, buffer, size );
 803a726:	460a      	mov	r2, r1
 803a728:	4601      	mov	r1, r0
 803a72a:	4803      	ldr	r0, [pc, #12]	; (803a738 <SUBGRF_WriteRegisters+0x1c>)
 803a72c:	f7f5 f94c 	bl	802f9c8 <HAL_SUBGHZ_WriteRegisters>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803a730:	f384 8810 	msr	PRIMASK, r4
}
 803a734:	bd10      	pop	{r4, pc}
 803a736:	bf00      	nop
 803a738:	200061f0 	.word	0x200061f0

0803a73c <SUBGRF_SetSyncWord>:
{
 803a73c:	b508      	push	{r3, lr}
 803a73e:	4601      	mov	r1, r0
    SUBGRF_WriteRegisters( REG_LR_SYNCWORDBASEADDRESS, syncWord, 8 );
 803a740:	2208      	movs	r2, #8
 803a742:	f44f 60d8 	mov.w	r0, #1728	; 0x6c0
 803a746:	f7ff ffe9 	bl	803a71c <SUBGRF_WriteRegisters>
}
 803a74a:	2000      	movs	r0, #0
 803a74c:	bd08      	pop	{r3, pc}
	...

0803a750 <SUBGRF_SetCrcSeed>:
{
 803a750:	b507      	push	{r0, r1, r2, lr}
    return PacketType;
 803a752:	4b07      	ldr	r3, [pc, #28]	; (803a770 <SUBGRF_SetCrcSeed+0x20>)
    switch( SUBGRF_GetPacketType( ) )
 803a754:	789b      	ldrb	r3, [r3, #2]
    buf[0] = ( uint8_t )( ( seed >> 8 ) & 0xFF );
 803a756:	ba40      	rev16	r0, r0
 803a758:	f8ad 0004 	strh.w	r0, [sp, #4]
    switch( SUBGRF_GetPacketType( ) )
 803a75c:	b92b      	cbnz	r3, 803a76a <SUBGRF_SetCrcSeed+0x1a>
            SUBGRF_WriteRegisters( REG_LR_CRCSEEDBASEADDR, buf, 2 );
 803a75e:	2202      	movs	r2, #2
 803a760:	a901      	add	r1, sp, #4
 803a762:	f240 60bc 	movw	r0, #1724	; 0x6bc
 803a766:	f7ff ffd9 	bl	803a71c <SUBGRF_WriteRegisters>
}
 803a76a:	b003      	add	sp, #12
 803a76c:	f85d fb04 	ldr.w	pc, [sp], #4
 803a770:	20005a80 	.word	0x20005a80

0803a774 <SUBGRF_SetCrcPolynomial>:
{
 803a774:	b507      	push	{r0, r1, r2, lr}
    return PacketType;
 803a776:	4b07      	ldr	r3, [pc, #28]	; (803a794 <SUBGRF_SetCrcPolynomial+0x20>)
    switch( SUBGRF_GetPacketType( ) )
 803a778:	789b      	ldrb	r3, [r3, #2]
    buf[0] = ( uint8_t )( ( polynomial >> 8 ) & 0xFF );
 803a77a:	ba40      	rev16	r0, r0
 803a77c:	f8ad 0004 	strh.w	r0, [sp, #4]
    switch( SUBGRF_GetPacketType( ) )
 803a780:	b92b      	cbnz	r3, 803a78e <SUBGRF_SetCrcPolynomial+0x1a>
            SUBGRF_WriteRegisters( REG_LR_CRCPOLYBASEADDR, buf, 2 );
 803a782:	2202      	movs	r2, #2
 803a784:	a901      	add	r1, sp, #4
 803a786:	f240 60be 	movw	r0, #1726	; 0x6be
 803a78a:	f7ff ffc7 	bl	803a71c <SUBGRF_WriteRegisters>
}
 803a78e:	b003      	add	sp, #12
 803a790:	f85d fb04 	ldr.w	pc, [sp], #4
 803a794:	20005a80 	.word	0x20005a80

0803a798 <SUBGRF_SetPacketParams>:
{
 803a798:	b530      	push	{r4, r5, lr}
    uint8_t buf[9] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 803a79a:	4a2e      	ldr	r2, [pc, #184]	; (803a854 <SUBGRF_SetPacketParams+0xbc>)
    if( PacketType != packetParams->PacketType )
 803a79c:	4d2e      	ldr	r5, [pc, #184]	; (803a858 <SUBGRF_SetPacketParams+0xc0>)
    uint8_t buf[9] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 803a79e:	6851      	ldr	r1, [r2, #4]
{
 803a7a0:	4604      	mov	r4, r0
 803a7a2:	b085      	sub	sp, #20
    uint8_t buf[9] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 803a7a4:	6810      	ldr	r0, [r2, #0]
 803a7a6:	7a12      	ldrb	r2, [r2, #8]
 803a7a8:	ab01      	add	r3, sp, #4
 803a7aa:	c303      	stmia	r3!, {r0, r1}
    if( PacketType != packetParams->PacketType )
 803a7ac:	7820      	ldrb	r0, [r4, #0]
    uint8_t buf[9] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 803a7ae:	701a      	strb	r2, [r3, #0]
    if( PacketType != packetParams->PacketType )
 803a7b0:	78aa      	ldrb	r2, [r5, #2]
 803a7b2:	4282      	cmp	r2, r0
 803a7b4:	d001      	beq.n	803a7ba <SUBGRF_SetPacketParams+0x22>
        SUBGRF_SetPacketType( packetParams->PacketType );
 803a7b6:	f7ff fe43 	bl	803a440 <SUBGRF_SetPacketType>
    switch( packetParams->PacketType )
 803a7ba:	7823      	ldrb	r3, [r4, #0]
 803a7bc:	2b03      	cmp	r3, #3
 803a7be:	d826      	bhi.n	803a80e <SUBGRF_SetPacketParams+0x76>
 803a7c0:	e8df f003 	tbb	[pc, r3]
 803a7c4:	02333802 	.word	0x02333802
        if( packetParams->Params.Gfsk.CrcLength == RADIO_CRC_2_BYTES_IBM )
 803a7c8:	7a63      	ldrb	r3, [r4, #9]
 803a7ca:	2bf1      	cmp	r3, #241	; 0xf1
 803a7cc:	d121      	bne.n	803a812 <SUBGRF_SetPacketParams+0x7a>
            SUBGRF_SetCrcSeed( CRC_IBM_SEED );
 803a7ce:	f64f 70ff 	movw	r0, #65535	; 0xffff
 803a7d2:	f7ff ffbd 	bl	803a750 <SUBGRF_SetCrcSeed>
            SUBGRF_SetCrcPolynomial( CRC_POLYNOMIAL_IBM );
 803a7d6:	f248 0005 	movw	r0, #32773	; 0x8005
 803a7da:	f7ff ffcb 	bl	803a774 <SUBGRF_SetCrcPolynomial>
            crcVal = RADIO_CRC_2_BYTES;
 803a7de:	2302      	movs	r3, #2
        buf[0] = ( packetParams->Params.Gfsk.PreambleLength >> 8 ) & 0xFF;
 803a7e0:	8862      	ldrh	r2, [r4, #2]
        buf[2] = packetParams->Params.Gfsk.PreambleMinDetect;
 803a7e2:	88a1      	ldrh	r1, [r4, #4]
 803a7e4:	f8ad 1006 	strh.w	r1, [sp, #6]
        buf[0] = ( packetParams->Params.Gfsk.PreambleLength >> 8 ) & 0xFF;
 803a7e8:	ba52      	rev16	r2, r2
        buf[4] = packetParams->Params.Gfsk.AddrComp;
 803a7ea:	88e1      	ldrh	r1, [r4, #6]
        buf[0] = ( packetParams->Params.Gfsk.PreambleLength >> 8 ) & 0xFF;
 803a7ec:	f8ad 2004 	strh.w	r2, [sp, #4]
        buf[7] = crcVal;
 803a7f0:	f88d 300b 	strb.w	r3, [sp, #11]
        buf[6] = packetParams->Params.Gfsk.PayloadLength;
 803a7f4:	7a22      	ldrb	r2, [r4, #8]
        buf[8] = packetParams->Params.Gfsk.DcFree;
 803a7f6:	7aa3      	ldrb	r3, [r4, #10]
        buf[6] = packetParams->Params.Gfsk.PayloadLength;
 803a7f8:	f88d 200a 	strb.w	r2, [sp, #10]
        buf[4] = packetParams->Params.Gfsk.AddrComp;
 803a7fc:	f8ad 1008 	strh.w	r1, [sp, #8]
        buf[8] = packetParams->Params.Gfsk.DcFree;
 803a800:	f88d 300c 	strb.w	r3, [sp, #12]
        n = 9;
 803a804:	2209      	movs	r2, #9
    SUBGRF_WriteCommand( RADIO_SET_PACKETPARAMS, buf, n );
 803a806:	a901      	add	r1, sp, #4
 803a808:	208c      	movs	r0, #140	; 0x8c
 803a80a:	f7ff fc2f 	bl	803a06c <SUBGRF_WriteCommand>
}
 803a80e:	b005      	add	sp, #20
 803a810:	bd30      	pop	{r4, r5, pc}
        else if( packetParams->Params.Gfsk.CrcLength == RADIO_CRC_2_BYTES_CCIT )
 803a812:	2bf2      	cmp	r3, #242	; 0xf2
 803a814:	d1e4      	bne.n	803a7e0 <SUBGRF_SetPacketParams+0x48>
            SUBGRF_SetCrcSeed( CRC_CCITT_SEED );
 803a816:	f641 500f 	movw	r0, #7439	; 0x1d0f
 803a81a:	f7ff ff99 	bl	803a750 <SUBGRF_SetCrcSeed>
            SUBGRF_SetCrcPolynomial( CRC_POLYNOMIAL_CCITT );
 803a81e:	f241 0021 	movw	r0, #4129	; 0x1021
 803a822:	f7ff ffa7 	bl	803a774 <SUBGRF_SetCrcPolynomial>
            crcVal = RADIO_CRC_2_BYTES_INV;
 803a826:	2306      	movs	r3, #6
 803a828:	e7da      	b.n	803a7e0 <SUBGRF_SetPacketParams+0x48>
        buf[0] = packetParams->Params.Bpsk.PayloadLength;
 803a82a:	7b23      	ldrb	r3, [r4, #12]
 803a82c:	f88d 3004 	strb.w	r3, [sp, #4]
        n = 1;
 803a830:	2201      	movs	r2, #1
        break;
 803a832:	e7e8      	b.n	803a806 <SUBGRF_SetPacketParams+0x6e>
        buf[0] = ( packetParams->Params.LoRa.PreambleLength >> 8 ) & 0xFF;
 803a834:	89e3      	ldrh	r3, [r4, #14]
 803a836:	ba5b      	rev16	r3, r3
 803a838:	f8ad 3004 	strh.w	r3, [sp, #4]
        buf[2] = LoRaHeaderType = packetParams->Params.LoRa.HeaderType;
 803a83c:	7c23      	ldrb	r3, [r4, #16]
 803a83e:	732b      	strb	r3, [r5, #12]
 803a840:	f88d 3006 	strb.w	r3, [sp, #6]
        buf[3] = packetParams->Params.LoRa.PayloadLength;
 803a844:	7c63      	ldrb	r3, [r4, #17]
 803a846:	f88d 3007 	strb.w	r3, [sp, #7]
        buf[4] = packetParams->Params.LoRa.CrcMode;
 803a84a:	8a63      	ldrh	r3, [r4, #18]
 803a84c:	f8ad 3008 	strh.w	r3, [sp, #8]
        n = 6;
 803a850:	2206      	movs	r2, #6
        break;
 803a852:	e7d8      	b.n	803a806 <SUBGRF_SetPacketParams+0x6e>
 803a854:	0803bc4c 	.word	0x0803bc4c
 803a858:	20005a80 	.word	0x20005a80

0803a85c <SUBGRF_ReadRegisters>:
{
 803a85c:	b510      	push	{r4, lr}
 803a85e:	4613      	mov	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803a860:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803a864:	b672      	cpsid	i
    HAL_SUBGHZ_ReadRegisters( &hsubghz, address, buffer, size );
 803a866:	460a      	mov	r2, r1
 803a868:	4601      	mov	r1, r0
 803a86a:	4803      	ldr	r0, [pc, #12]	; (803a878 <SUBGRF_ReadRegisters+0x1c>)
 803a86c:	f7f5 f8e5 	bl	802fa3a <HAL_SUBGHZ_ReadRegisters>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803a870:	f384 8810 	msr	PRIMASK, r4
}
 803a874:	bd10      	pop	{r4, pc}
 803a876:	bf00      	nop
 803a878:	200061f0 	.word	0x200061f0

0803a87c <SUBGRF_GetRandom>:
{
 803a87c:	b573      	push	{r0, r1, r4, r5, r6, lr}
    uint32_t number = 0;
 803a87e:	2600      	movs	r6, #0
    regAnaLna = SUBGRF_ReadRegister( REG_ANA_LNA );
 803a880:	f640 00e2 	movw	r0, #2274	; 0x8e2
    uint32_t number = 0;
 803a884:	9601      	str	r6, [sp, #4]
    regAnaLna = SUBGRF_ReadRegister( REG_ANA_LNA );
 803a886:	f7ff fe5d 	bl	803a544 <SUBGRF_ReadRegister>
    SUBGRF_WriteRegister( REG_ANA_LNA, regAnaLna & ~( 1 << 0 ) );
 803a88a:	f000 01fe 	and.w	r1, r0, #254	; 0xfe
    regAnaLna = SUBGRF_ReadRegister( REG_ANA_LNA );
 803a88e:	4605      	mov	r5, r0
    SUBGRF_WriteRegister( REG_ANA_LNA, regAnaLna & ~( 1 << 0 ) );
 803a890:	f640 00e2 	movw	r0, #2274	; 0x8e2
 803a894:	f7ff fd90 	bl	803a3b8 <SUBGRF_WriteRegister>
    regAnaMixer = SUBGRF_ReadRegister( REG_ANA_MIXER );
 803a898:	f640 00e5 	movw	r0, #2277	; 0x8e5
 803a89c:	f7ff fe52 	bl	803a544 <SUBGRF_ReadRegister>
    SUBGRF_WriteRegister( REG_ANA_MIXER, regAnaMixer & ~( 1 << 7 ) );
 803a8a0:	f000 017f 	and.w	r1, r0, #127	; 0x7f
    regAnaMixer = SUBGRF_ReadRegister( REG_ANA_MIXER );
 803a8a4:	4604      	mov	r4, r0
    SUBGRF_WriteRegister( REG_ANA_MIXER, regAnaMixer & ~( 1 << 7 ) );
 803a8a6:	f640 00e5 	movw	r0, #2277	; 0x8e5
 803a8aa:	f7ff fd85 	bl	803a3b8 <SUBGRF_WriteRegister>
    SUBGRF_SetRx( 0xFFFFFF ); // Rx Continuous
 803a8ae:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 803a8b2:	f7ff fc2d 	bl	803a110 <SUBGRF_SetRx>
    SUBGRF_ReadRegisters( RANDOM_NUMBER_GENERATORBASEADDR, ( uint8_t* )&number, 4 );
 803a8b6:	2204      	movs	r2, #4
 803a8b8:	eb0d 0102 	add.w	r1, sp, r2
 803a8bc:	f640 0019 	movw	r0, #2073	; 0x819
 803a8c0:	f7ff ffcc 	bl	803a85c <SUBGRF_ReadRegisters>
    SUBGRF_SetStandby( STDBY_RC );
 803a8c4:	4630      	mov	r0, r6
 803a8c6:	f7ff fbf7 	bl	803a0b8 <SUBGRF_SetStandby>
    SUBGRF_WriteRegister( REG_ANA_LNA, regAnaLna );
 803a8ca:	4629      	mov	r1, r5
 803a8cc:	f640 00e2 	movw	r0, #2274	; 0x8e2
 803a8d0:	f7ff fd72 	bl	803a3b8 <SUBGRF_WriteRegister>
    SUBGRF_WriteRegister( REG_ANA_MIXER, regAnaMixer );
 803a8d4:	4621      	mov	r1, r4
 803a8d6:	f640 00e5 	movw	r0, #2277	; 0x8e5
 803a8da:	f7ff fd6d 	bl	803a3b8 <SUBGRF_WriteRegister>
}
 803a8de:	9801      	ldr	r0, [sp, #4]
 803a8e0:	b002      	add	sp, #8
 803a8e2:	bd70      	pop	{r4, r5, r6, pc}

0803a8e4 <SUBGRF_WriteBuffer>:
{
 803a8e4:	b510      	push	{r4, lr}
 803a8e6:	4613      	mov	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803a8e8:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803a8ec:	b672      	cpsid	i
    HAL_SUBGHZ_WriteBuffer( &hsubghz, offset, buffer, size );
 803a8ee:	460a      	mov	r2, r1
 803a8f0:	4601      	mov	r1, r0
 803a8f2:	4803      	ldr	r0, [pc, #12]	; (803a900 <SUBGRF_WriteBuffer+0x1c>)
 803a8f4:	f7f5 f914 	bl	802fb20 <HAL_SUBGHZ_WriteBuffer>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803a8f8:	f384 8810 	msr	PRIMASK, r4
}
 803a8fc:	bd10      	pop	{r4, pc}
 803a8fe:	bf00      	nop
 803a900:	200061f0 	.word	0x200061f0

0803a904 <SUBGRF_SetPayload>:
{
 803a904:	460a      	mov	r2, r1
    SUBGRF_WriteBuffer( 0x00, payload, size );
 803a906:	4601      	mov	r1, r0
 803a908:	2000      	movs	r0, #0
 803a90a:	f7ff bfeb 	b.w	803a8e4 <SUBGRF_WriteBuffer>

0803a90e <SUBGRF_SendPayload>:
{
 803a90e:	b510      	push	{r4, lr}
 803a910:	4614      	mov	r4, r2
    SUBGRF_SetPayload( payload, size );
 803a912:	f7ff fff7 	bl	803a904 <SUBGRF_SetPayload>
    SUBGRF_SetTx( timeout );
 803a916:	4620      	mov	r0, r4
}
 803a918:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    SUBGRF_SetTx( timeout );
 803a91c:	f7ff bbe2 	b.w	803a0e4 <SUBGRF_SetTx>

0803a920 <SUBGRF_ReadBuffer>:
{
 803a920:	b510      	push	{r4, lr}
 803a922:	4613      	mov	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803a924:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803a928:	b672      	cpsid	i
    HAL_SUBGHZ_ReadBuffer( &hsubghz, offset, buffer, size );
 803a92a:	460a      	mov	r2, r1
 803a92c:	4601      	mov	r1, r0
 803a92e:	4803      	ldr	r0, [pc, #12]	; (803a93c <SUBGRF_ReadBuffer+0x1c>)
 803a930:	f7f5 f929 	bl	802fb86 <HAL_SUBGHZ_ReadBuffer>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803a934:	f384 8810 	msr	PRIMASK, r4
}
 803a938:	bd10      	pop	{r4, pc}
 803a93a:	bf00      	nop
 803a93c:	200061f0 	.word	0x200061f0

0803a940 <SUBGRF_GetPayload>:
{
 803a940:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 803a942:	460d      	mov	r5, r1
 803a944:	4606      	mov	r6, r0
    uint8_t offset = 0;
 803a946:	2400      	movs	r4, #0
    SUBGRF_GetRxBufferStatus( size, &offset );
 803a948:	f10d 0107 	add.w	r1, sp, #7
 803a94c:	4628      	mov	r0, r5
{
 803a94e:	4617      	mov	r7, r2
    uint8_t offset = 0;
 803a950:	f88d 4007 	strb.w	r4, [sp, #7]
    SUBGRF_GetRxBufferStatus( size, &offset );
 803a954:	f7ff fec2 	bl	803a6dc <SUBGRF_GetRxBufferStatus>
    if( *size > maxSize )
 803a958:	782a      	ldrb	r2, [r5, #0]
 803a95a:	42ba      	cmp	r2, r7
 803a95c:	d807      	bhi.n	803a96e <SUBGRF_GetPayload+0x2e>
    SUBGRF_ReadBuffer( offset, buffer, *size );
 803a95e:	f89d 0007 	ldrb.w	r0, [sp, #7]
 803a962:	4631      	mov	r1, r6
 803a964:	f7ff ffdc 	bl	803a920 <SUBGRF_ReadBuffer>
    return 0;
 803a968:	4620      	mov	r0, r4
}
 803a96a:	b003      	add	sp, #12
 803a96c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return 1;
 803a96e:	2001      	movs	r0, #1
 803a970:	e7fb      	b.n	803a96a <SUBGRF_GetPayload+0x2a>

0803a972 <SUBGRF_SetSwitch>:
    if (rxtx == RFSWITCH_TX)
 803a972:	2901      	cmp	r1, #1
{
 803a974:	b508      	push	{r3, lr}
 803a976:	4603      	mov	r3, r0
 803a978:	4608      	mov	r0, r1
    if (rxtx == RFSWITCH_TX)
 803a97a:	d10e      	bne.n	803a99a <SUBGRF_SetSwitch+0x28>
        if (paSelect == RFO_LP)
 803a97c:	2b01      	cmp	r3, #1
 803a97e:	d107      	bne.n	803a990 <SUBGRF_SetSwitch+0x1e>
            Radio_SMPS_Set(SMPS_DRIVE_SETTING_MAX);
 803a980:	2004      	movs	r0, #4
 803a982:	f7ff fdef 	bl	803a564 <Radio_SMPS_Set>
            state = RBI_SWITCH_RFO_LP;
 803a986:	2002      	movs	r0, #2
}
 803a988:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RBI_ConfigRFSwitch(state);
 803a98c:	f7f2 bbc2 	b.w	802d114 <RBI_ConfigRFSwitch>
        if (paSelect == RFO_HP)
 803a990:	2b02      	cmp	r3, #2
            state = RBI_SWITCH_RFO_HP;
 803a992:	bf14      	ite	ne
 803a994:	4608      	movne	r0, r1
 803a996:	2003      	moveq	r0, #3
 803a998:	e7f6      	b.n	803a988 <SUBGRF_SetSwitch+0x16>
    RBI_Switch_TypeDef state = RBI_SWITCH_RX;
 803a99a:	2001      	movs	r0, #1
 803a99c:	e7f4      	b.n	803a988 <SUBGRF_SetSwitch+0x16>

0803a99e <SUBGRF_SetRfTxPower>:
{
 803a99e:	b538      	push	{r3, r4, r5, lr}
 803a9a0:	4604      	mov	r4, r0
    int32_t TxConfig = RBI_GetTxConfig();
 803a9a2:	f7f2 fbb9 	bl	802d118 <RBI_GetTxConfig>
    switch (TxConfig)
 803a9a6:	b150      	cbz	r0, 803a9be <SUBGRF_SetRfTxPower+0x20>
 803a9a8:	2802      	cmp	r0, #2
 803a9aa:	bf14      	ite	ne
 803a9ac:	2501      	movne	r5, #1
 803a9ae:	2502      	moveq	r5, #2
    SUBGRF_SetTxParams( paSelect, power, RADIO_RAMP_40_US );
 803a9b0:	4628      	mov	r0, r5
 803a9b2:	2202      	movs	r2, #2
 803a9b4:	4621      	mov	r1, r4
 803a9b6:	f7ff fe4f 	bl	803a658 <SUBGRF_SetTxParams>
}
 803a9ba:	4628      	mov	r0, r5
 803a9bc:	bd38      	pop	{r3, r4, r5, pc}
            if (power > 15)
 803a9be:	2c0f      	cmp	r4, #15
                paSelect = RFO_LP;
 803a9c0:	bfcc      	ite	gt
 803a9c2:	2502      	movgt	r5, #2
 803a9c4:	2501      	movle	r5, #1
 803a9c6:	e7f3      	b.n	803a9b0 <SUBGRF_SetRfTxPower+0x12>

0803a9c8 <SUBGRF_GetRadioWakeUpTime>:
}
 803a9c8:	2001      	movs	r0, #1
 803a9ca:	4770      	bx	lr

0803a9cc <HAL_SUBGHZ_TxCpltCallback>:
    RadioOnDioIrqCb( IRQ_TX_DONE );
 803a9cc:	4b01      	ldr	r3, [pc, #4]	; (803a9d4 <HAL_SUBGHZ_TxCpltCallback+0x8>)
 803a9ce:	2001      	movs	r0, #1
 803a9d0:	689b      	ldr	r3, [r3, #8]
 803a9d2:	4718      	bx	r3
 803a9d4:	20005a80 	.word	0x20005a80

0803a9d8 <HAL_SUBGHZ_RxCpltCallback>:
    RadioOnDioIrqCb( IRQ_RX_DONE );
 803a9d8:	4b01      	ldr	r3, [pc, #4]	; (803a9e0 <HAL_SUBGHZ_RxCpltCallback+0x8>)
 803a9da:	2002      	movs	r0, #2
 803a9dc:	689b      	ldr	r3, [r3, #8]
 803a9de:	4718      	bx	r3
 803a9e0:	20005a80 	.word	0x20005a80

0803a9e4 <HAL_SUBGHZ_CRCErrorCallback>:
    RadioOnDioIrqCb( IRQ_CRC_ERROR);
 803a9e4:	4b01      	ldr	r3, [pc, #4]	; (803a9ec <HAL_SUBGHZ_CRCErrorCallback+0x8>)
 803a9e6:	2040      	movs	r0, #64	; 0x40
 803a9e8:	689b      	ldr	r3, [r3, #8]
 803a9ea:	4718      	bx	r3
 803a9ec:	20005a80 	.word	0x20005a80

0803a9f0 <HAL_SUBGHZ_CADStatusCallback>:
    switch (cadstatus)
 803a9f0:	b111      	cbz	r1, 803a9f8 <HAL_SUBGHZ_CADStatusCallback+0x8>
 803a9f2:	2901      	cmp	r1, #1
 803a9f4:	d004      	beq.n	803aa00 <HAL_SUBGHZ_CADStatusCallback+0x10>
 803a9f6:	4770      	bx	lr
            RadioOnDioIrqCb( IRQ_CAD_CLEAR);
 803a9f8:	4b04      	ldr	r3, [pc, #16]	; (803aa0c <HAL_SUBGHZ_CADStatusCallback+0x1c>)
 803a9fa:	689b      	ldr	r3, [r3, #8]
 803a9fc:	2080      	movs	r0, #128	; 0x80
            RadioOnDioIrqCb( IRQ_CAD_DETECTED);
 803a9fe:	4718      	bx	r3
 803aa00:	4b02      	ldr	r3, [pc, #8]	; (803aa0c <HAL_SUBGHZ_CADStatusCallback+0x1c>)
 803aa02:	f44f 7080 	mov.w	r0, #256	; 0x100
 803aa06:	689b      	ldr	r3, [r3, #8]
 803aa08:	e7f9      	b.n	803a9fe <HAL_SUBGHZ_CADStatusCallback+0xe>
 803aa0a:	bf00      	nop
 803aa0c:	20005a80 	.word	0x20005a80

0803aa10 <HAL_SUBGHZ_RxTxTimeoutCallback>:
    RadioOnDioIrqCb( IRQ_RX_TX_TIMEOUT );
 803aa10:	4b02      	ldr	r3, [pc, #8]	; (803aa1c <HAL_SUBGHZ_RxTxTimeoutCallback+0xc>)
 803aa12:	f44f 7000 	mov.w	r0, #512	; 0x200
 803aa16:	689b      	ldr	r3, [r3, #8]
 803aa18:	4718      	bx	r3
 803aa1a:	bf00      	nop
 803aa1c:	20005a80 	.word	0x20005a80

0803aa20 <HAL_SUBGHZ_HeaderErrorCallback>:
    RadioOnDioIrqCb( IRQ_HEADER_ERROR );
 803aa20:	4b01      	ldr	r3, [pc, #4]	; (803aa28 <HAL_SUBGHZ_HeaderErrorCallback+0x8>)
 803aa22:	2020      	movs	r0, #32
 803aa24:	689b      	ldr	r3, [r3, #8]
 803aa26:	4718      	bx	r3
 803aa28:	20005a80 	.word	0x20005a80

0803aa2c <HAL_SUBGHZ_PreambleDetectedCallback>:
    RadioOnDioIrqCb( IRQ_PREAMBLE_DETECTED );
 803aa2c:	4b01      	ldr	r3, [pc, #4]	; (803aa34 <HAL_SUBGHZ_PreambleDetectedCallback+0x8>)
 803aa2e:	2004      	movs	r0, #4
 803aa30:	689b      	ldr	r3, [r3, #8]
 803aa32:	4718      	bx	r3
 803aa34:	20005a80 	.word	0x20005a80

0803aa38 <HAL_SUBGHZ_SyncWordValidCallback>:
    RadioOnDioIrqCb( IRQ_SYNCWORD_VALID );
 803aa38:	4b01      	ldr	r3, [pc, #4]	; (803aa40 <HAL_SUBGHZ_SyncWordValidCallback+0x8>)
 803aa3a:	2008      	movs	r0, #8
 803aa3c:	689b      	ldr	r3, [r3, #8]
 803aa3e:	4718      	bx	r3
 803aa40:	20005a80 	.word	0x20005a80

0803aa44 <HAL_SUBGHZ_HeaderValidCallback>:
    RadioOnDioIrqCb( IRQ_HEADER_VALID );
 803aa44:	4b01      	ldr	r3, [pc, #4]	; (803aa4c <HAL_SUBGHZ_HeaderValidCallback+0x8>)
 803aa46:	2010      	movs	r0, #16
 803aa48:	689b      	ldr	r3, [r3, #8]
 803aa4a:	4718      	bx	r3
 803aa4c:	20005a80 	.word	0x20005a80

0803aa50 <SUBGRF_GetFskBandwidthRegValue>:

uint8_t SUBGRF_GetFskBandwidthRegValue( uint32_t bandwidth )
{
 803aa50:	b510      	push	{r4, lr}
    uint8_t i;

    if( bandwidth == 0 )
 803aa52:	b178      	cbz	r0, 803aa74 <SUBGRF_GetFskBandwidthRegValue+0x24>
    }

    /* ST_WORKAROUND_BEGIN: Simplified loop */
    for( i = 0; i < ( sizeof( FskBandwidths ) / sizeof( FskBandwidth_t ) ); i++ )
    {
        if ( bandwidth < FskBandwidths[i].bandwidth )
 803aa54:	4a08      	ldr	r2, [pc, #32]	; (803aa78 <SUBGRF_GetFskBandwidthRegValue+0x28>)
 803aa56:	2300      	movs	r3, #0
 803aa58:	f102 0114 	add.w	r1, r2, #20
 803aa5c:	f851 4033 	ldr.w	r4, [r1, r3, lsl #3]
 803aa60:	4284      	cmp	r4, r0
 803aa62:	d903      	bls.n	803aa6c <SUBGRF_GetFskBandwidthRegValue+0x1c>
        {
            return FskBandwidths[i].RegValue;
 803aa64:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 803aa68:	7e18      	ldrb	r0, [r3, #24]
        }
    }
    /* ST_WORKAROUND_END */
    // ERROR: Value not found
    while( 1 );
}
 803aa6a:	bd10      	pop	{r4, pc}
    for( i = 0; i < ( sizeof( FskBandwidths ) / sizeof( FskBandwidth_t ) ); i++ )
 803aa6c:	3301      	adds	r3, #1
 803aa6e:	2b16      	cmp	r3, #22
 803aa70:	d1f4      	bne.n	803aa5c <SUBGRF_GetFskBandwidthRegValue+0xc>
    while( 1 );
 803aa72:	e7fe      	b.n	803aa72 <SUBGRF_GetFskBandwidthRegValue+0x22>
        return( 0x1F );
 803aa74:	201f      	movs	r0, #31
 803aa76:	e7f8      	b.n	803aa6a <SUBGRF_GetFskBandwidthRegValue+0x1a>
 803aa78:	0803bc44 	.word	0x0803bc44

0803aa7c <SUBGRF_GetCFO>:
void SUBGRF_GetCFO( uint32_t bitRate, int32_t *cfo)
{
 803aa7c:	b573      	push	{r0, r1, r4, r5, r6, lr}
  uint8_t BwMant[] = {4, 8, 10, 12};
 803aa7e:	4b1d      	ldr	r3, [pc, #116]	; (803aaf4 <SUBGRF_GetCFO+0x78>)
 803aa80:	9301      	str	r3, [sp, #4]
{
 803aa82:	4604      	mov	r4, r0
  /* read demod bandwidth: mant bit4:3, exp bits 2:0 */
  uint8_t reg = (SUBGRF_ReadRegister( SUBGHZ_BWSEL ));
 803aa84:	f640 0007 	movw	r0, #2055	; 0x807
{
 803aa88:	460d      	mov	r5, r1
  uint8_t reg = (SUBGRF_ReadRegister( SUBGHZ_BWSEL ));
 803aa8a:	f7ff fd5b 	bl	803a544 <SUBGRF_ReadRegister>
  uint8_t bandwidth_mant = BwMant[( reg >> 3 ) & 0x3];
 803aa8e:	aa02      	add	r2, sp, #8
 803aa90:	f3c0 03c1 	ubfx	r3, r0, #3, #2
 803aa94:	4413      	add	r3, r2
  uint8_t bandwidth_exp = reg & 0x7;
  uint32_t cf_fs = XTAL_FREQ / ( bandwidth_mant * ( 1 << ( bandwidth_exp - 1 )));
 803aa96:	f813 2c04 	ldrb.w	r2, [r3, #-4]
 803aa9a:	f000 0307 	and.w	r3, r0, #7
 803aa9e:	3b01      	subs	r3, #1
 803aaa0:	fa02 f003 	lsl.w	r0, r2, r3
 803aaa4:	4b14      	ldr	r3, [pc, #80]	; (803aaf8 <SUBGRF_GetCFO+0x7c>)
 803aaa6:	fbb3 f3f0 	udiv	r3, r3, r0
  uint32_t cf_osr = cf_fs / bitRate;
 803aaaa:	fbb3 f0f4 	udiv	r0, r3, r4
  uint8_t interp = 1;
  /* calculate demod interpolation factor */
  if (cf_osr * interp < 8)
 803aaae:	2807      	cmp	r0, #7
 803aab0:	d81d      	bhi.n	803aaee <SUBGRF_GetCFO+0x72>
  {
    interp = 2;
  }
  if (cf_osr * interp < 4)
 803aab2:	0040      	lsls	r0, r0, #1
  {
    interp = 4;
 803aab4:	2803      	cmp	r0, #3
 803aab6:	bf8c      	ite	hi
 803aab8:	2402      	movhi	r4, #2
 803aaba:	2404      	movls	r4, #4
  }
  /* calculate demod sampling frequency */
  uint32_t fs = cf_fs* interp;
  /* get the cfo registers */
  int32_t cfo_bin = ( SUBGRF_ReadRegister( SUBGHZ_CFO_H ) & 0xF ) << 8;
 803aabc:	f44f 60d6 	mov.w	r0, #1712	; 0x6b0
  uint32_t fs = cf_fs* interp;
 803aac0:	435c      	muls	r4, r3
  int32_t cfo_bin = ( SUBGRF_ReadRegister( SUBGHZ_CFO_H ) & 0xF ) << 8;
 803aac2:	f7ff fd3f 	bl	803a544 <SUBGRF_ReadRegister>
 803aac6:	0200      	lsls	r0, r0, #8
 803aac8:	f400 6670 	and.w	r6, r0, #3840	; 0xf00
  cfo_bin |= SUBGRF_ReadRegister( SUBGHZ_CFO_L );
 803aacc:	f240 60b1 	movw	r0, #1713	; 0x6b1
 803aad0:	f7ff fd38 	bl	803a544 <SUBGRF_ReadRegister>
 803aad4:	4330      	orrs	r0, r6
  /* negate if 12 bits sign bit is 1 */
  if (( cfo_bin & 0x800 ) == 0x800 )
 803aad6:	0503      	lsls	r3, r0, #20
  {
    cfo_bin |= 0xFFFFF000;
 803aad8:	bf44      	itt	mi
 803aada:	ea6f 5000 	mvnmi.w	r0, r0, lsl #20
 803aade:	ea6f 5010 	mvnmi.w	r0, r0, lsr #20
  }
  /* calculate cfo in Hz */
  /* shift by 5 first to not saturate, cfo_bin on 12bits */
  *cfo = ((int32_t)( cfo_bin * ( fs >> 5 ))) >> ( 12 - 5 );
 803aae2:	0963      	lsrs	r3, r4, #5
 803aae4:	4358      	muls	r0, r3
 803aae6:	11c0      	asrs	r0, r0, #7
 803aae8:	6028      	str	r0, [r5, #0]
}
 803aaea:	b002      	add	sp, #8
 803aaec:	bd70      	pop	{r4, r5, r6, pc}
  uint8_t interp = 1;
 803aaee:	2401      	movs	r4, #1
 803aaf0:	e7e4      	b.n	803aabc <SUBGRF_GetCFO+0x40>
 803aaf2:	bf00      	nop
 803aaf4:	0c0a0804 	.word	0x0c0a0804
 803aaf8:	01e84800 	.word	0x01e84800

0803aafc <RFW_TransmitLongPacket>:
  }
#else
  status= -1;
#endif
  return status;
}
 803aafc:	f04f 30ff 	mov.w	r0, #4294967295
 803ab00:	4770      	bx	lr

0803ab02 <RFW_ReceiveLongPacket>:
  }
#else
  status= -1;
#endif
  return status;
}
 803ab02:	f04f 30ff 	mov.w	r0, #4294967295
 803ab06:	4770      	bx	lr

0803ab08 <RFW_Init>:
  TimerInit( &RFWPacket.Timer, RFW_GetPayloadTimerEvent );
  return 0;
#else
  return -1;
#endif
}
 803ab08:	f04f 30ff 	mov.w	r0, #4294967295
 803ab0c:	4770      	bx	lr

0803ab0e <RFW_DeInit>:
void RFW_DeInit( void)
{
#if (RFW_ENABLE ==1 )
  RFWPacket.Init.Enable=0; /*Disable the RFWPacket decoding*/
#endif
}
 803ab0e:	4770      	bx	lr

0803ab10 <RFW_Is_Init>:
#if (RFW_ENABLE ==1 )
  return RFWPacket.Init.Enable;
#else
  return 0;
#endif
}
 803ab10:	2000      	movs	r0, #0
 803ab12:	4770      	bx	lr

0803ab14 <RFW_Is_LongPacketModeEnabled>:
 803ab14:	2000      	movs	r0, #0
 803ab16:	4770      	bx	lr

0803ab18 <RFW_SetAntSwitch>:
 803ab18:	4770      	bx	lr

0803ab1a <RFW_TransmitInit>:
    
    status= 0;
  }
#endif
  return status;
}
 803ab1a:	f04f 30ff 	mov.w	r0, #4294967295
 803ab1e:	4770      	bx	lr

0803ab20 <RFW_ReceiveInit>:
  RFWPacket.LongPacketModeEnable=0;
  return 0;
#else
  return -1;
#endif
}
 803ab20:	f04f 30ff 	mov.w	r0, #4294967295
 803ab24:	4770      	bx	lr

0803ab26 <RFW_DeInit_TxLongPacket>:
 803ab26:	4770      	bx	lr

0803ab28 <RFW_ReceivePayload>:
 803ab28:	4770      	bx	lr

0803ab2a <RFW_SetRadioModem>:
void RFW_SetRadioModem(RadioModems_t Modem)
{
#if (RFW_ENABLE ==1 )
  RFWPacket.Init.Modem= Modem;
#endif
}
 803ab2a:	4770      	bx	lr

0803ab2c <TRACE_AllocateBufer>:
 * @param  Size to allocate within fifo
 * @param  Pos position within the fifo
 * @retval write position inside the buffer is -1 no space available.
 */
static int16_t TRACE_AllocateBufer(uint16_t Size, uint16_t *Pos)
{
 803ab2c:	b570      	push	{r4, r5, r6, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803ab2e:	f3ef 8610 	mrs	r6, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803ab32:	b672      	cpsid	i
  uint16_t freesize;
  int16_t ret = -1;

  UTIL_ADV_TRACE_ENTER_CRITICAL_SECTION();

  if(ADV_TRACE_Ctx.TraceWrPtr == ADV_TRACE_Ctx.TraceRdPtr)
 803ab34:	4b14      	ldr	r3, [pc, #80]	; (803ab88 <TRACE_AllocateBufer+0x5c>)
 803ab36:	8a5c      	ldrh	r4, [r3, #18]
 803ab38:	8a1a      	ldrh	r2, [r3, #16]
 803ab3a:	4294      	cmp	r4, r2
 803ab3c:	d113      	bne.n	803ab66 <TRACE_AllocateBufer+0x3a>
  {
#ifdef UTIL_ADV_TRACE_UNCHUNK_MODE
    freesize = (uint16_t)(UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceWrPtr);
 803ab3e:	f5c4 6280 	rsb	r2, r4, #1024	; 0x400
    if((Size >= freesize) && (ADV_TRACE_Ctx.TraceRdPtr > Size))
 803ab42:	b292      	uxth	r2, r2
 803ab44:	4290      	cmp	r0, r2
 803ab46:	d306      	bcc.n	803ab56 <TRACE_AllocateBufer+0x2a>
 803ab48:	4284      	cmp	r4, r0
  {
#ifdef UTIL_ADV_TRACE_UNCHUNK_MODE
    if (ADV_TRACE_Ctx.TraceWrPtr > ADV_TRACE_Ctx.TraceRdPtr)
    {
      freesize = (uint16_t)(UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceWrPtr);
      if((Size >= freesize) && (ADV_TRACE_Ctx.TraceRdPtr > Size)) 
 803ab4a:	d918      	bls.n	803ab7e <TRACE_AllocateBufer+0x52>
      {
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_DETECTED;
 803ab4c:	2201      	movs	r2, #1
 803ab4e:	709a      	strb	r2, [r3, #2]
        ADV_TRACE_Ctx.unchunk_enabled = ADV_TRACE_Ctx.TraceWrPtr;
        freesize = ADV_TRACE_Ctx.TraceRdPtr;
        ADV_TRACE_Ctx.TraceWrPtr = 0;
 803ab50:	2200      	movs	r2, #0
        ADV_TRACE_Ctx.unchunk_enabled = ADV_TRACE_Ctx.TraceWrPtr;
 803ab52:	801c      	strh	r4, [r3, #0]
        ADV_TRACE_Ctx.TraceWrPtr = 0;
 803ab54:	825a      	strh	r2, [r3, #18]
#endif
  }

  if(freesize > Size)
  {
    *Pos = ADV_TRACE_Ctx.TraceWrPtr;
 803ab56:	8a5a      	ldrh	r2, [r3, #18]
 803ab58:	800a      	strh	r2, [r1, #0]
    ADV_TRACE_Ctx.TraceWrPtr = (ADV_TRACE_Ctx.TraceWrPtr + Size) % UTIL_ADV_TRACE_FIFO_SIZE;
 803ab5a:	4410      	add	r0, r2
 803ab5c:	f3c0 0009 	ubfx	r0, r0, #0, #10
 803ab60:	8258      	strh	r0, [r3, #18]
    ret = 0;
 803ab62:	2000      	movs	r0, #0
 803ab64:	e00d      	b.n	803ab82 <TRACE_AllocateBufer+0x56>
    if (ADV_TRACE_Ctx.TraceWrPtr > ADV_TRACE_Ctx.TraceRdPtr)
 803ab66:	d906      	bls.n	803ab76 <TRACE_AllocateBufer+0x4a>
      freesize = (uint16_t)(UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceWrPtr);
 803ab68:	f5c4 6580 	rsb	r5, r4, #1024	; 0x400
      if((Size >= freesize) && (ADV_TRACE_Ctx.TraceRdPtr > Size)) 
 803ab6c:	b2ad      	uxth	r5, r5
 803ab6e:	4285      	cmp	r5, r0
 803ab70:	d8f1      	bhi.n	803ab56 <TRACE_AllocateBufer+0x2a>
 803ab72:	4282      	cmp	r2, r0
 803ab74:	e7e9      	b.n	803ab4a <TRACE_AllocateBufer+0x1e>
      freesize = (uint16_t)(ADV_TRACE_Ctx.TraceRdPtr - ADV_TRACE_Ctx.TraceWrPtr);
 803ab76:	1b12      	subs	r2, r2, r4
  if(freesize > Size)
 803ab78:	b292      	uxth	r2, r2
 803ab7a:	4282      	cmp	r2, r0
 803ab7c:	d8eb      	bhi.n	803ab56 <TRACE_AllocateBufer+0x2a>
  int16_t ret = -1;
 803ab7e:	f04f 30ff 	mov.w	r0, #4294967295
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803ab82:	f386 8810 	msr	PRIMASK, r6
  }
#endif

  UTIL_ADV_TRACE_EXIT_CRITICAL_SECTION();
  return ret;
}
 803ab86:	bd70      	pop	{r4, r5, r6, pc}
 803ab88:	20005a90 	.word	0x20005a90

0803ab8c <TRACE_Lock>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803ab8c:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803ab90:	b672      	cpsid	i
 * @retval None.
 */
static void TRACE_Lock(void)
{
  UTIL_ADV_TRACE_ENTER_CRITICAL_SECTION();
  ADV_TRACE_Ctx.TraceLock++;
 803ab92:	4a03      	ldr	r2, [pc, #12]	; (803aba0 <TRACE_Lock+0x14>)
 803ab94:	8ad3      	ldrh	r3, [r2, #22]
 803ab96:	3301      	adds	r3, #1
 803ab98:	82d3      	strh	r3, [r2, #22]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803ab9a:	f381 8810 	msr	PRIMASK, r1
  UTIL_ADV_TRACE_EXIT_CRITICAL_SECTION();
}
 803ab9e:	4770      	bx	lr
 803aba0:	20005a90 	.word	0x20005a90

0803aba4 <TRACE_UnLock>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803aba4:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803aba8:	b672      	cpsid	i
 * @retval None.
 */
static void TRACE_UnLock(void)
{
  UTIL_ADV_TRACE_ENTER_CRITICAL_SECTION();
  ADV_TRACE_Ctx.TraceLock--;
 803abaa:	4a03      	ldr	r2, [pc, #12]	; (803abb8 <TRACE_UnLock+0x14>)
 803abac:	8ad3      	ldrh	r3, [r2, #22]
 803abae:	3b01      	subs	r3, #1
 803abb0:	82d3      	strh	r3, [r2, #22]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803abb2:	f381 8810 	msr	PRIMASK, r1
  UTIL_ADV_TRACE_EXIT_CRITICAL_SECTION();
}
 803abb6:	4770      	bx	lr
 803abb8:	20005a90 	.word	0x20005a90

0803abbc <UTIL_ADV_TRACE_Init>:
{
 803abbc:	b510      	push	{r4, lr}
  (void)UTIL_ADV_TRACE_MEMSET8(&ADV_TRACE_Ctx, 0x0, sizeof(ADV_TRACE_Context));
 803abbe:	4c09      	ldr	r4, [pc, #36]	; (803abe4 <UTIL_ADV_TRACE_Init+0x28>)
 803abc0:	2218      	movs	r2, #24
 803abc2:	4620      	mov	r0, r4
 803abc4:	2100      	movs	r1, #0
 803abc6:	f000 f973 	bl	803aeb0 <UTIL_MEM_set_8>
  (void)UTIL_ADV_TRACE_MEMSET8(&ADV_TRACE_Buffer, 0x0, sizeof(ADV_TRACE_Buffer));
 803abca:	f104 0018 	add.w	r0, r4, #24
 803abce:	f44f 6280 	mov.w	r2, #1024	; 0x400
 803abd2:	2100      	movs	r1, #0
 803abd4:	f000 f96c 	bl	803aeb0 <UTIL_MEM_set_8>
  return UTIL_TraceDriver.Init(TRACE_TxCpltCallback);
 803abd8:	4b03      	ldr	r3, [pc, #12]	; (803abe8 <UTIL_ADV_TRACE_Init+0x2c>)
 803abda:	4804      	ldr	r0, [pc, #16]	; (803abec <UTIL_ADV_TRACE_Init+0x30>)
 803abdc:	681b      	ldr	r3, [r3, #0]
}
 803abde:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return UTIL_TraceDriver.Init(TRACE_TxCpltCallback);
 803abe2:	4718      	bx	r3
 803abe4:	20005a90 	.word	0x20005a90
 803abe8:	0803b898 	.word	0x0803b898
 803abec:	0803ad5d 	.word	0x0803ad5d

0803abf0 <UTIL_ADV_TRACE_RegisterTimeStampFunction>:
  ADV_TRACE_Ctx.timestamp_func = *cb;
 803abf0:	4b01      	ldr	r3, [pc, #4]	; (803abf8 <UTIL_ADV_TRACE_RegisterTimeStampFunction+0x8>)
 803abf2:	6058      	str	r0, [r3, #4]
}
 803abf4:	4770      	bx	lr
 803abf6:	bf00      	nop
 803abf8:	20005a90 	.word	0x20005a90

0803abfc <UTIL_ADV_TRACE_SetVerboseLevel>:
  ADV_TRACE_Ctx.CurrentVerboseLevel = Level;
 803abfc:	4b01      	ldr	r3, [pc, #4]	; (803ac04 <UTIL_ADV_TRACE_SetVerboseLevel+0x8>)
 803abfe:	7218      	strb	r0, [r3, #8]
}
 803ac00:	4770      	bx	lr
 803ac02:	bf00      	nop
 803ac04:	20005a90 	.word	0x20005a90

0803ac08 <TRACE_Send>:
{
 803ac08:	b573      	push	{r0, r1, r4, r5, r6, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803ac0a:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803ac0e:	b672      	cpsid	i
 * @brief  UnLock the trace buffer.
 * @retval None.
 */
static uint32_t TRACE_IsLocked(void)
{
  return (ADV_TRACE_Ctx.TraceLock == 0u? 0u: 1u);
 803ac10:	4c1b      	ldr	r4, [pc, #108]	; (803ac80 <TRACE_Send+0x78>)
  if(TRACE_IsLocked() == 0u)
 803ac12:	8ae0      	ldrh	r0, [r4, #22]
 803ac14:	2800      	cmp	r0, #0
 803ac16:	d12e      	bne.n	803ac76 <TRACE_Send+0x6e>
    TRACE_Lock();
 803ac18:	f7ff ffb8 	bl	803ab8c <TRACE_Lock>
    if(ADV_TRACE_Ctx.TraceRdPtr != ADV_TRACE_Ctx.TraceWrPtr)
 803ac1c:	8a26      	ldrh	r6, [r4, #16]
 803ac1e:	8a62      	ldrh	r2, [r4, #18]
 803ac20:	4296      	cmp	r6, r2
 803ac22:	d026      	beq.n	803ac72 <TRACE_Send+0x6a>
      if(TRACE_UNCHUNK_DETECTED == ADV_TRACE_Ctx.unchunk_status)
 803ac24:	78a1      	ldrb	r1, [r4, #2]
 803ac26:	2901      	cmp	r1, #1
 803ac28:	d111      	bne.n	803ac4e <TRACE_Send+0x46>
        ADV_TRACE_Ctx.TraceSentSize = (uint16_t) (ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr);
 803ac2a:	8823      	ldrh	r3, [r4, #0]
        ADV_TRACE_Ctx.unchunk_enabled = 0;
 803ac2c:	8020      	strh	r0, [r4, #0]
        ADV_TRACE_Ctx.TraceSentSize = (uint16_t) (ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr);
 803ac2e:	1b9b      	subs	r3, r3, r6
 803ac30:	b29b      	uxth	r3, r3
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_TRANSFER;
 803ac32:	2102      	movs	r1, #2
        ADV_TRACE_Ctx.TraceSentSize = (uint16_t) (ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr);
 803ac34:	82a3      	strh	r3, [r4, #20]
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_TRANSFER;
 803ac36:	70a1      	strb	r1, [r4, #2]
        if(0u == ADV_TRACE_Ctx.TraceSentSize)
 803ac38:	b95b      	cbnz	r3, 803ac52 <TRACE_Send+0x4a>
          ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_NONE;
 803ac3a:	70a3      	strb	r3, [r4, #2]
          ADV_TRACE_Ctx.TraceRdPtr = 0;
 803ac3c:	8223      	strh	r3, [r4, #16]
        if(ADV_TRACE_Ctx.TraceWrPtr > ADV_TRACE_Ctx.TraceRdPtr)
 803ac3e:	8a23      	ldrh	r3, [r4, #16]
 803ac40:	429a      	cmp	r2, r3
          ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.TraceWrPtr - ADV_TRACE_Ctx.TraceRdPtr;
 803ac42:	bf8c      	ite	hi
 803ac44:	1ad3      	subhi	r3, r2, r3
          ADV_TRACE_Ctx.TraceSentSize = UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceRdPtr;
 803ac46:	f5c3 6380 	rsbls	r3, r3, #1024	; 0x400
 803ac4a:	82a3      	strh	r3, [r4, #20]
 803ac4c:	e001      	b.n	803ac52 <TRACE_Send+0x4a>
      if(TRACE_UNCHUNK_NONE == ADV_TRACE_Ctx.unchunk_status)
 803ac4e:	2900      	cmp	r1, #0
 803ac50:	d0f5      	beq.n	803ac3e <TRACE_Send+0x36>
      ptr = &ADV_TRACE_Buffer[ADV_TRACE_Ctx.TraceRdPtr];
 803ac52:	8a20      	ldrh	r0, [r4, #16]
 803ac54:	4e0b      	ldr	r6, [pc, #44]	; (803ac84 <TRACE_Send+0x7c>)
 803ac56:	4406      	add	r6, r0
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803ac58:	f385 8810 	msr	PRIMASK, r5
      UTIL_ADV_TRACE_PreSendHook();
 803ac5c:	f7f1 fce8 	bl	802c630 <UTIL_ADV_TRACE_PreSendHook>
      ret = UTIL_TraceDriver.Send(ptr, ADV_TRACE_Ctx.TraceSentSize);
 803ac60:	4b09      	ldr	r3, [pc, #36]	; (803ac88 <TRACE_Send+0x80>)
 803ac62:	8aa1      	ldrh	r1, [r4, #20]
 803ac64:	68db      	ldr	r3, [r3, #12]
 803ac66:	9301      	str	r3, [sp, #4]
 803ac68:	4630      	mov	r0, r6
}
 803ac6a:	b002      	add	sp, #8
 803ac6c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      ret = UTIL_TraceDriver.Send(ptr, ADV_TRACE_Ctx.TraceSentSize);
 803ac70:	4718      	bx	r3
      TRACE_UnLock();
 803ac72:	f7ff ff97 	bl	803aba4 <TRACE_UnLock>
 803ac76:	f385 8810 	msr	PRIMASK, r5
}
 803ac7a:	2000      	movs	r0, #0
 803ac7c:	b002      	add	sp, #8
 803ac7e:	bd70      	pop	{r4, r5, r6, pc}
 803ac80:	20005a90 	.word	0x20005a90
 803ac84:	20005aa8 	.word	0x20005aa8
 803ac88:	0803b898 	.word	0x0803b898

0803ac8c <UTIL_ADV_TRACE_COND_FSend>:
{
 803ac8c:	b408      	push	{r3}
 803ac8e:	b5f0      	push	{r4, r5, r6, r7, lr}
  if(!(ADV_TRACE_Ctx.CurrentVerboseLevel >= VerboseLevel))
 803ac90:	4c2f      	ldr	r4, [pc, #188]	; (803ad50 <UTIL_ADV_TRACE_COND_FSend+0xc4>)
{
 803ac92:	b086      	sub	sp, #24
  uint16_t timestamp_size = 0u;
 803ac94:	2300      	movs	r3, #0
 803ac96:	f8ad 3000 	strh.w	r3, [sp]
  if(!(ADV_TRACE_Ctx.CurrentVerboseLevel >= VerboseLevel))
 803ac9a:	7a23      	ldrb	r3, [r4, #8]
{
 803ac9c:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
  if(!(ADV_TRACE_Ctx.CurrentVerboseLevel >= VerboseLevel))
 803ac9e:	4283      	cmp	r3, r0
 803aca0:	d34f      	bcc.n	803ad42 <UTIL_ADV_TRACE_COND_FSend+0xb6>
  if((Region & ADV_TRACE_Ctx.RegionMask) != Region)
 803aca2:	68e3      	ldr	r3, [r4, #12]
 803aca4:	ea31 0303 	bics.w	r3, r1, r3
 803aca8:	d14e      	bne.n	803ad48 <UTIL_ADV_TRACE_COND_FSend+0xbc>
  if((ADV_TRACE_Ctx.timestamp_func != NULL) && (TimeStampState != 0u))
 803acaa:	6863      	ldr	r3, [r4, #4]
 803acac:	b11b      	cbz	r3, 803acb6 <UTIL_ADV_TRACE_COND_FSend+0x2a>
 803acae:	b112      	cbz	r2, 803acb6 <UTIL_ADV_TRACE_COND_FSend+0x2a>
    ADV_TRACE_Ctx.timestamp_func(buf,&timestamp_size);
 803acb0:	4669      	mov	r1, sp
 803acb2:	a802      	add	r0, sp, #8
 803acb4:	4798      	blx	r3
  va_start( vaArgs, strFormat);
 803acb6:	ab0c      	add	r3, sp, #48	; 0x30
  buff_size =(uint16_t)UTIL_ADV_TRACE_VSNPRINTF((char *)sztmp,UTIL_ADV_TRACE_TMP_BUF_SIZE, strFormat, vaArgs);
 803acb8:	462a      	mov	r2, r5
 803acba:	f44f 7100 	mov.w	r1, #512	; 0x200
 803acbe:	4825      	ldr	r0, [pc, #148]	; (803ad54 <UTIL_ADV_TRACE_COND_FSend+0xc8>)
  va_start( vaArgs, strFormat);
 803acc0:	9301      	str	r3, [sp, #4]
  buff_size =(uint16_t)UTIL_ADV_TRACE_VSNPRINTF((char *)sztmp,UTIL_ADV_TRACE_TMP_BUF_SIZE, strFormat, vaArgs);
 803acc2:	f000 fbeb 	bl	803b49c <tiny_vsnprintf_like>
  TRACE_Lock();
 803acc6:	f7ff ff61 	bl	803ab8c <TRACE_Lock>
  if (TRACE_AllocateBufer((buff_size+timestamp_size),&writepos) != -1)
 803acca:	f8bd 3000 	ldrh.w	r3, [sp]
 803acce:	4418      	add	r0, r3
 803acd0:	f10d 0102 	add.w	r1, sp, #2
 803acd4:	b280      	uxth	r0, r0
 803acd6:	f7ff ff29 	bl	803ab2c <TRACE_AllocateBufer>
 803acda:	3001      	adds	r0, #1
 803acdc:	d02c      	beq.n	803ad38 <UTIL_ADV_TRACE_COND_FSend+0xac>
    for (idx = 0u; idx < timestamp_size; idx++)
 803acde:	2200      	movs	r2, #0
 803ace0:	f8bd 3000 	ldrh.w	r3, [sp]
 803ace4:	f8bd 7002 	ldrh.w	r7, [sp, #2]
 803ace8:	4616      	mov	r6, r2
      ADV_TRACE_Buffer[writepos] = buf[idx];
 803acea:	f10d 0c08 	add.w	ip, sp, #8
 803acee:	b290      	uxth	r0, r2
 803acf0:	fa17 f182 	uxtah	r1, r7, r2
    for (idx = 0u; idx < timestamp_size; idx++)
 803acf4:	4283      	cmp	r3, r0
 803acf6:	b289      	uxth	r1, r1
 803acf8:	d817      	bhi.n	803ad2a <UTIL_ADV_TRACE_COND_FSend+0x9e>
 803acfa:	443b      	add	r3, r7
 803acfc:	b29b      	uxth	r3, r3
 803acfe:	b10e      	cbz	r6, 803ad04 <UTIL_ADV_TRACE_COND_FSend+0x78>
 803ad00:	f8ad 3002 	strh.w	r3, [sp, #2]
    (void)UTIL_ADV_TRACE_VSNPRINTF((char *)(&ADV_TRACE_Buffer[writepos]), UTIL_ADV_TRACE_TMP_BUF_SIZE, strFormat, vaArgs);
 803ad04:	f8bd 0002 	ldrh.w	r0, [sp, #2]
 803ad08:	4c13      	ldr	r4, [pc, #76]	; (803ad58 <UTIL_ADV_TRACE_COND_FSend+0xcc>)
 803ad0a:	9b01      	ldr	r3, [sp, #4]
 803ad0c:	462a      	mov	r2, r5
 803ad0e:	f44f 7100 	mov.w	r1, #512	; 0x200
 803ad12:	4420      	add	r0, r4
 803ad14:	f000 fbc2 	bl	803b49c <tiny_vsnprintf_like>
    TRACE_UnLock();
 803ad18:	f7ff ff44 	bl	803aba4 <TRACE_UnLock>
    return TRACE_Send();
 803ad1c:	f7ff ff74 	bl	803ac08 <TRACE_Send>
}
 803ad20:	b006      	add	sp, #24
 803ad22:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 803ad26:	b001      	add	sp, #4
 803ad28:	4770      	bx	lr
      ADV_TRACE_Buffer[writepos] = buf[idx];
 803ad2a:	4421      	add	r1, r4
 803ad2c:	f812 000c 	ldrb.w	r0, [r2, ip]
 803ad30:	7608      	strb	r0, [r1, #24]
    for (idx = 0u; idx < timestamp_size; idx++)
 803ad32:	3201      	adds	r2, #1
      ADV_TRACE_Buffer[writepos] = buf[idx];
 803ad34:	2601      	movs	r6, #1
 803ad36:	e7da      	b.n	803acee <UTIL_ADV_TRACE_COND_FSend+0x62>
  TRACE_UnLock();
 803ad38:	f7ff ff34 	bl	803aba4 <TRACE_UnLock>
  return UTIL_ADV_TRACE_MEM_FULL;
 803ad3c:	f06f 0002 	mvn.w	r0, #2
 803ad40:	e7ee      	b.n	803ad20 <UTIL_ADV_TRACE_COND_FSend+0x94>
    return UTIL_ADV_TRACE_GIVEUP;
 803ad42:	f06f 0004 	mvn.w	r0, #4
 803ad46:	e7eb      	b.n	803ad20 <UTIL_ADV_TRACE_COND_FSend+0x94>
    return UTIL_ADV_TRACE_REGIONMASKED;
 803ad48:	f06f 0005 	mvn.w	r0, #5
 803ad4c:	e7e8      	b.n	803ad20 <UTIL_ADV_TRACE_COND_FSend+0x94>
 803ad4e:	bf00      	nop
 803ad50:	20005a90 	.word	0x20005a90
 803ad54:	20005ea8 	.word	0x20005ea8
 803ad58:	20005aa8 	.word	0x20005aa8

0803ad5c <TRACE_TxCpltCallback>:
{
 803ad5c:	b537      	push	{r0, r1, r2, r4, r5, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803ad5e:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803ad62:	b672      	cpsid	i
  if(TRACE_UNCHUNK_TRANSFER == ADV_TRACE_Ctx.unchunk_status)
 803ad64:	4b21      	ldr	r3, [pc, #132]	; (803adec <TRACE_TxCpltCallback+0x90>)
 803ad66:	789a      	ldrb	r2, [r3, #2]
 803ad68:	2a02      	cmp	r2, #2
    ADV_TRACE_Ctx.TraceRdPtr = (ADV_TRACE_Ctx.TraceRdPtr + ADV_TRACE_Ctx.TraceSentSize) % UTIL_ADV_TRACE_FIFO_SIZE;
 803ad6a:	bf1d      	ittte	ne
 803ad6c:	8a1a      	ldrhne	r2, [r3, #16]
 803ad6e:	8a99      	ldrhne	r1, [r3, #20]
 803ad70:	1852      	addne	r2, r2, r1
    ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_NONE;
 803ad72:	2200      	moveq	r2, #0
    ADV_TRACE_Ctx.TraceRdPtr = (ADV_TRACE_Ctx.TraceRdPtr + ADV_TRACE_Ctx.TraceSentSize) % UTIL_ADV_TRACE_FIFO_SIZE;
 803ad74:	bf18      	it	ne
 803ad76:	f3c2 0209 	ubfxne	r2, r2, #0, #10
 803ad7a:	821a      	strh	r2, [r3, #16]
  if((ADV_TRACE_Ctx.TraceRdPtr != ADV_TRACE_Ctx.TraceWrPtr) && (1u == ADV_TRACE_Ctx.TraceLock))
 803ad7c:	8a1d      	ldrh	r5, [r3, #16]
 803ad7e:	8a59      	ldrh	r1, [r3, #18]
    ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_NONE;
 803ad80:	bf08      	it	eq
 803ad82:	709a      	strbeq	r2, [r3, #2]
  if((ADV_TRACE_Ctx.TraceRdPtr != ADV_TRACE_Ctx.TraceWrPtr) && (1u == ADV_TRACE_Ctx.TraceLock))
 803ad84:	428d      	cmp	r5, r1
 803ad86:	d027      	beq.n	803add8 <TRACE_TxCpltCallback+0x7c>
 803ad88:	8ada      	ldrh	r2, [r3, #22]
 803ad8a:	2a01      	cmp	r2, #1
 803ad8c:	d124      	bne.n	803add8 <TRACE_TxCpltCallback+0x7c>
    if(TRACE_UNCHUNK_DETECTED == ADV_TRACE_Ctx.unchunk_status)
 803ad8e:	7898      	ldrb	r0, [r3, #2]
 803ad90:	2801      	cmp	r0, #1
 803ad92:	d112      	bne.n	803adba <TRACE_TxCpltCallback+0x5e>
      ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr;
 803ad94:	881a      	ldrh	r2, [r3, #0]
      ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_TRANSFER;
 803ad96:	2002      	movs	r0, #2
      ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr;
 803ad98:	1b52      	subs	r2, r2, r5
 803ad9a:	b292      	uxth	r2, r2
      ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_TRANSFER;
 803ad9c:	7098      	strb	r0, [r3, #2]
      ADV_TRACE_Ctx.unchunk_enabled = 0;
 803ad9e:	2000      	movs	r0, #0
      ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr;
 803ada0:	829a      	strh	r2, [r3, #20]
      ADV_TRACE_Ctx.unchunk_enabled = 0;
 803ada2:	8018      	strh	r0, [r3, #0]
      if(0u == ADV_TRACE_Ctx.TraceSentSize)
 803ada4:	b95a      	cbnz	r2, 803adbe <TRACE_TxCpltCallback+0x62>
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_NONE;
 803ada6:	709a      	strb	r2, [r3, #2]
        ADV_TRACE_Ctx.TraceRdPtr = 0;
 803ada8:	821a      	strh	r2, [r3, #16]
      if(ADV_TRACE_Ctx.TraceWrPtr > ADV_TRACE_Ctx.TraceRdPtr)
 803adaa:	8a1a      	ldrh	r2, [r3, #16]
 803adac:	4291      	cmp	r1, r2
        ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.TraceWrPtr - ADV_TRACE_Ctx.TraceRdPtr;
 803adae:	bf8c      	ite	hi
 803adb0:	1a8a      	subhi	r2, r1, r2
        ADV_TRACE_Ctx.TraceSentSize = UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceRdPtr;
 803adb2:	f5c2 6280 	rsbls	r2, r2, #1024	; 0x400
 803adb6:	829a      	strh	r2, [r3, #20]
 803adb8:	e001      	b.n	803adbe <TRACE_TxCpltCallback+0x62>
    if(TRACE_UNCHUNK_NONE == ADV_TRACE_Ctx.unchunk_status)
 803adba:	2800      	cmp	r0, #0
 803adbc:	d0f5      	beq.n	803adaa <TRACE_TxCpltCallback+0x4e>
    ptr = &ADV_TRACE_Buffer[ADV_TRACE_Ctx.TraceRdPtr];
 803adbe:	8a1a      	ldrh	r2, [r3, #16]
 803adc0:	480b      	ldr	r0, [pc, #44]	; (803adf0 <TRACE_TxCpltCallback+0x94>)
 803adc2:	4410      	add	r0, r2
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803adc4:	f384 8810 	msr	PRIMASK, r4
    UTIL_TraceDriver.Send(ptr, ADV_TRACE_Ctx.TraceSentSize);
 803adc8:	4a0a      	ldr	r2, [pc, #40]	; (803adf4 <TRACE_TxCpltCallback+0x98>)
 803adca:	8a99      	ldrh	r1, [r3, #20]
 803adcc:	68d3      	ldr	r3, [r2, #12]
 803adce:	9301      	str	r3, [sp, #4]
}
 803add0:	b003      	add	sp, #12
 803add2:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    UTIL_TraceDriver.Send(ptr, ADV_TRACE_Ctx.TraceSentSize);
 803add6:	4718      	bx	r3
 803add8:	f384 8810 	msr	PRIMASK, r4
    UTIL_ADV_TRACE_PostSendHook();
 803addc:	f7f1 fc2c 	bl	802c638 <UTIL_ADV_TRACE_PostSendHook>
}
 803ade0:	b003      	add	sp, #12
 803ade2:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    TRACE_UnLock();
 803ade6:	f7ff bedd 	b.w	803aba4 <TRACE_UnLock>
 803adea:	bf00      	nop
 803adec:	20005a90 	.word	0x20005a90
 803adf0:	20005aa8 	.word	0x20005aa8
 803adf4:	0803b898 	.word	0x0803b898

0803adf8 <UTIL_LPM_Init>:
/** @addtogroup TINY_LPM_Exported_function
  * @{
  */
void UTIL_LPM_Init( void )
{
  StopModeDisable = UTIL_LPM_NO_BIT_SET;
 803adf8:	4b02      	ldr	r3, [pc, #8]	; (803ae04 <UTIL_LPM_Init+0xc>)
 803adfa:	2200      	movs	r2, #0
  OffModeDisable = UTIL_LPM_NO_BIT_SET;
 803adfc:	e9c3 2200 	strd	r2, r2, [r3]
  UTIL_LPM_INIT_CRITICAL_SECTION( );
}
 803ae00:	4770      	bx	lr
 803ae02:	bf00      	nop
 803ae04:	200060a8 	.word	0x200060a8

0803ae08 <UTIL_LPM_SetStopMode>:
void UTIL_LPM_DeInit( void )
{
}

void UTIL_LPM_SetStopMode( UTIL_LPM_bm_t lpm_id_bm, UTIL_LPM_State_t state )
{
 803ae08:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803ae0a:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803ae0e:	b672      	cpsid	i
  UTIL_LPM_ENTER_CRITICAL_SECTION( );
  
  switch( state )
 803ae10:	b141      	cbz	r1, 803ae24 <UTIL_LPM_SetStopMode+0x1c>
 803ae12:	2901      	cmp	r1, #1
 803ae14:	d103      	bne.n	803ae1e <UTIL_LPM_SetStopMode+0x16>
  {
  case UTIL_LPM_DISABLE:
    {
      StopModeDisable |= lpm_id_bm;
 803ae16:	4a06      	ldr	r2, [pc, #24]	; (803ae30 <UTIL_LPM_SetStopMode+0x28>)
 803ae18:	6813      	ldr	r3, [r2, #0]
 803ae1a:	4318      	orrs	r0, r3
      break;
    }
  case UTIL_LPM_ENABLE:
    {
      StopModeDisable &= ( ~lpm_id_bm );
 803ae1c:	6010      	str	r0, [r2, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803ae1e:	f384 8810 	msr	PRIMASK, r4
      break;
    }
  }
  
  UTIL_LPM_EXIT_CRITICAL_SECTION( );
}
 803ae22:	bd10      	pop	{r4, pc}
      StopModeDisable &= ( ~lpm_id_bm );
 803ae24:	4a02      	ldr	r2, [pc, #8]	; (803ae30 <UTIL_LPM_SetStopMode+0x28>)
 803ae26:	6813      	ldr	r3, [r2, #0]
 803ae28:	ea23 0000 	bic.w	r0, r3, r0
 803ae2c:	e7f6      	b.n	803ae1c <UTIL_LPM_SetStopMode+0x14>
 803ae2e:	bf00      	nop
 803ae30:	200060a8 	.word	0x200060a8

0803ae34 <UTIL_LPM_SetOffMode>:

void UTIL_LPM_SetOffMode( UTIL_LPM_bm_t lpm_id_bm, UTIL_LPM_State_t state )
{
 803ae34:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803ae36:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803ae3a:	b672      	cpsid	i
  UTIL_LPM_ENTER_CRITICAL_SECTION( );
  
  switch(state)
 803ae3c:	b141      	cbz	r1, 803ae50 <UTIL_LPM_SetOffMode+0x1c>
 803ae3e:	2901      	cmp	r1, #1
 803ae40:	d103      	bne.n	803ae4a <UTIL_LPM_SetOffMode+0x16>
  {
  case UTIL_LPM_DISABLE:
    {
      OffModeDisable |= lpm_id_bm;
 803ae42:	4a06      	ldr	r2, [pc, #24]	; (803ae5c <UTIL_LPM_SetOffMode+0x28>)
 803ae44:	6853      	ldr	r3, [r2, #4]
 803ae46:	4318      	orrs	r0, r3
      break;
    }
  case UTIL_LPM_ENABLE:
    {
      OffModeDisable &= ( ~lpm_id_bm );
 803ae48:	6050      	str	r0, [r2, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803ae4a:	f384 8810 	msr	PRIMASK, r4
      break;
    }
  }
  
  UTIL_LPM_EXIT_CRITICAL_SECTION( );
}
 803ae4e:	bd10      	pop	{r4, pc}
      OffModeDisable &= ( ~lpm_id_bm );
 803ae50:	4a02      	ldr	r2, [pc, #8]	; (803ae5c <UTIL_LPM_SetOffMode+0x28>)
 803ae52:	6853      	ldr	r3, [r2, #4]
 803ae54:	ea23 0000 	bic.w	r0, r3, r0
 803ae58:	e7f6      	b.n	803ae48 <UTIL_LPM_SetOffMode+0x14>
 803ae5a:	bf00      	nop
 803ae5c:	200060a8 	.word	0x200060a8

0803ae60 <UTIL_LPM_EnterLowPower>:

  return mode_selected;
}

void UTIL_LPM_EnterLowPower( void )
{
 803ae60:	b538      	push	{r3, r4, r5, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803ae62:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803ae66:	b672      	cpsid	i
  UTIL_LPM_ENTER_CRITICAL_SECTION_ELP( );

  if( StopModeDisable != UTIL_LPM_NO_BIT_SET )
 803ae68:	4b0a      	ldr	r3, [pc, #40]	; (803ae94 <UTIL_LPM_EnterLowPower+0x34>)
 803ae6a:	4c0b      	ldr	r4, [pc, #44]	; (803ae98 <UTIL_LPM_EnterLowPower+0x38>)
 803ae6c:	681a      	ldr	r2, [r3, #0]
 803ae6e:	b132      	cbz	r2, 803ae7e <UTIL_LPM_EnterLowPower+0x1e>
  {
    /**
     * At least one user disallows Stop Mode
     * SLEEP mode is required
     */
      UTIL_PowerDriver.EnterSleepMode( );
 803ae70:	6823      	ldr	r3, [r4, #0]
 803ae72:	4798      	blx	r3
      UTIL_PowerDriver.ExitSleepMode( );
 803ae74:	6863      	ldr	r3, [r4, #4]
    {
      /**
       * OFF mode is required
       */
      UTIL_PowerDriver.EnterOffMode( );
      UTIL_PowerDriver.ExitOffMode( );
 803ae76:	4798      	blx	r3
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803ae78:	f385 8810 	msr	PRIMASK, r5
    }
  }
  
  UTIL_LPM_EXIT_CRITICAL_SECTION_ELP( );
}
 803ae7c:	bd38      	pop	{r3, r4, r5, pc}
    if( OffModeDisable != UTIL_LPM_NO_BIT_SET )
 803ae7e:	685b      	ldr	r3, [r3, #4]
 803ae80:	b11b      	cbz	r3, 803ae8a <UTIL_LPM_EnterLowPower+0x2a>
        UTIL_PowerDriver.EnterStopMode( );
 803ae82:	68a3      	ldr	r3, [r4, #8]
 803ae84:	4798      	blx	r3
        UTIL_PowerDriver.ExitStopMode( );
 803ae86:	68e3      	ldr	r3, [r4, #12]
 803ae88:	e7f5      	b.n	803ae76 <UTIL_LPM_EnterLowPower+0x16>
      UTIL_PowerDriver.EnterOffMode( );
 803ae8a:	6923      	ldr	r3, [r4, #16]
 803ae8c:	4798      	blx	r3
      UTIL_PowerDriver.ExitOffMode( );
 803ae8e:	6963      	ldr	r3, [r4, #20]
 803ae90:	e7f1      	b.n	803ae76 <UTIL_LPM_EnterLowPower+0x16>
 803ae92:	bf00      	nop
 803ae94:	200060a8 	.word	0x200060a8
 803ae98:	0803b840 	.word	0x0803b840

0803ae9c <UTIL_MEM_cpy_8>:
void UTIL_MEM_cpy_8( void *dst, const void *src, uint16_t size )
{
  uint8_t* dst8= (uint8_t *) dst;
  uint8_t* src8= (uint8_t *) src;

  while( size-- )
 803ae9c:	3801      	subs	r0, #1
 803ae9e:	440a      	add	r2, r1
 803aea0:	4291      	cmp	r1, r2
 803aea2:	d100      	bne.n	803aea6 <UTIL_MEM_cpy_8+0xa>
    {
        *dst8++ = *src8++;
    }
}
 803aea4:	4770      	bx	lr
        *dst8++ = *src8++;
 803aea6:	f811 3b01 	ldrb.w	r3, [r1], #1
 803aeaa:	f800 3f01 	strb.w	r3, [r0, #1]!
 803aeae:	e7f7      	b.n	803aea0 <UTIL_MEM_cpy_8+0x4>

0803aeb0 <UTIL_MEM_set_8>:
}

void UTIL_MEM_set_8( void *dst, uint8_t value, uint16_t size )
{
  uint8_t* dst8= (uint8_t *) dst;
  while( size-- )
 803aeb0:	4402      	add	r2, r0
 803aeb2:	4290      	cmp	r0, r2
 803aeb4:	d100      	bne.n	803aeb8 <UTIL_MEM_set_8+0x8>
  {
    *dst8++ = value;
  }
}
 803aeb6:	4770      	bx	lr
    *dst8++ = value;
 803aeb8:	f800 1b01 	strb.w	r1, [r0], #1
 803aebc:	e7f9      	b.n	803aeb2 <UTIL_MEM_set_8+0x2>
	...

0803aec0 <UTIL_SEQ_SetTask>:

  return;
}

void UTIL_SEQ_SetTask( UTIL_SEQ_bm_t TaskId_bm , uint32_t Task_Prio )
{
 803aec0:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803aec2:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803aec6:	b672      	cpsid	i
  UTIL_SEQ_ENTER_CRITICAL_SECTION( );

  TaskSet |= TaskId_bm;
 803aec8:	4b06      	ldr	r3, [pc, #24]	; (803aee4 <UTIL_SEQ_SetTask+0x24>)
 803aeca:	681a      	ldr	r2, [r3, #0]
 803aecc:	4302      	orrs	r2, r0
 803aece:	601a      	str	r2, [r3, #0]
  TaskPrio[Task_Prio].priority |= TaskId_bm;
 803aed0:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 803aed4:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 803aed8:	4310      	orrs	r0, r2
 803aeda:	f8c3 0090 	str.w	r0, [r3, #144]	; 0x90
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803aede:	f384 8810 	msr	PRIMASK, r4

  UTIL_SEQ_EXIT_CRITICAL_SECTION( );

  return;
}
 803aee2:	bd10      	pop	{r4, pc}
 803aee4:	200060b0 	.word	0x200060b0

0803aee8 <UTIL_SEQ_PreIdle>:
 803aee8:	4770      	bx	lr

0803aeea <UTIL_SEQ_PostIdle>:
 803aeea:	4770      	bx	lr

0803aeec <SEQ_BitPosition>:
 */
uint8_t SEQ_BitPosition(uint32_t Value)
{
  uint8_t n = 0U;

  if ((Value & 0xFFFF0000U) == 0U)  { n  = 16U; Value <<= 16U;  }
 803aeec:	0c03      	lsrs	r3, r0, #16
 803aeee:	041b      	lsls	r3, r3, #16
 803aef0:	b9c3      	cbnz	r3, 803af24 <SEQ_BitPosition+0x38>
 803aef2:	0400      	lsls	r0, r0, #16
 803aef4:	2310      	movs	r3, #16
  if ((Value & 0xFF000000U) == 0U)  { n +=  8U; Value <<=  8U;  }
 803aef6:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
 803aefa:	bf02      	ittt	eq
 803aefc:	3308      	addeq	r3, #8
 803aefe:	0200      	lsleq	r0, r0, #8
 803af00:	b2db      	uxtbeq	r3, r3
  if ((Value & 0xF0000000U) == 0U)  { n +=  4U; Value <<=  4U;  }
 803af02:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
 803af06:	bf08      	it	eq
 803af08:	0100      	lsleq	r0, r0, #4

  n += SEQ_clz_table_4bit[Value >> (32-4)];

  return (uint8_t)(31U-n);
 803af0a:	4a07      	ldr	r2, [pc, #28]	; (803af28 <SEQ_BitPosition+0x3c>)
  n += SEQ_clz_table_4bit[Value >> (32-4)];
 803af0c:	ea4f 7010 	mov.w	r0, r0, lsr #28
  if ((Value & 0xF0000000U) == 0U)  { n +=  4U; Value <<=  4U;  }
 803af10:	bf08      	it	eq
 803af12:	3304      	addeq	r3, #4
  return (uint8_t)(31U-n);
 803af14:	5c10      	ldrb	r0, [r2, r0]
  if ((Value & 0xF0000000U) == 0U)  { n +=  4U; Value <<=  4U;  }
 803af16:	bf08      	it	eq
 803af18:	b2db      	uxtbeq	r3, r3
  return (uint8_t)(31U-n);
 803af1a:	f1c3 031f 	rsb	r3, r3, #31
 803af1e:	1a18      	subs	r0, r3, r0
}
 803af20:	b2c0      	uxtb	r0, r0
 803af22:	4770      	bx	lr
  uint8_t n = 0U;
 803af24:	2300      	movs	r3, #0
 803af26:	e7e6      	b.n	803aef6 <SEQ_BitPosition+0xa>
 803af28:	0803bd08 	.word	0x0803bd08

0803af2c <UTIL_SEQ_Run>:
{
 803af2c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  super_mask_backup = SuperMask;
 803af30:	4d36      	ldr	r5, [pc, #216]	; (803b00c <UTIL_SEQ_Run+0xe0>)
  while(((TaskSet & TaskMask & SuperMask) != 0U) && ((EvtSet & EvtWaited)==0U))
 803af32:	f8df 80dc 	ldr.w	r8, [pc, #220]	; 803b010 <UTIL_SEQ_Run+0xe4>
  super_mask_backup = SuperMask;
 803af36:	686e      	ldr	r6, [r5, #4]
  SuperMask &= Mask_bm;
 803af38:	4030      	ands	r0, r6
 803af3a:	6068      	str	r0, [r5, #4]
  while(((TaskSet & TaskMask & SuperMask) != 0U) && ((EvtSet & EvtWaited)==0U))
 803af3c:	4644      	mov	r4, r8
      counter++;
 803af3e:	2701      	movs	r7, #1
  while(((TaskSet & TaskMask & SuperMask) != 0U) && ((EvtSet & EvtWaited)==0U))
 803af40:	e9d5 2000 	ldrd	r2, r0, [r5]
 803af44:	f8d8 3000 	ldr.w	r3, [r8]
 803af48:	4013      	ands	r3, r2
 803af4a:	4203      	tst	r3, r0
 803af4c:	d043      	beq.n	803afd6 <UTIL_SEQ_Run+0xaa>
 803af4e:	e9d8 3101 	ldrd	r3, r1, [r8, #4]
 803af52:	400b      	ands	r3, r1
 803af54:	d13f      	bne.n	803afd6 <UTIL_SEQ_Run+0xaa>
    while((TaskPrio[counter].priority & TaskMask & SuperMask)== 0U)
 803af56:	4002      	ands	r2, r0
 803af58:	f8d8 0090 	ldr.w	r0, [r8, #144]	; 0x90
 803af5c:	4010      	ands	r0, r2
 803af5e:	d103      	bne.n	803af68 <UTIL_SEQ_Run+0x3c>
 803af60:	f8d8 0098 	ldr.w	r0, [r8, #152]	; 0x98
      counter++;
 803af64:	2301      	movs	r3, #1
    while((TaskPrio[counter].priority & TaskMask & SuperMask)== 0U)
 803af66:	4010      	ands	r0, r2
    if ((TaskPrio[counter].round_robin & current_task_set) == 0U)
 803af68:	00d9      	lsls	r1, r3, #3
 803af6a:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
    CurrentTaskIdx = (SEQ_BitPosition(current_task_set & TaskPrio[counter].round_robin));
 803af6e:	4421      	add	r1, r4
    if ((TaskPrio[counter].round_robin & current_task_set) == 0U)
 803af70:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 803af74:	4210      	tst	r0, r2
      TaskPrio[counter].round_robin = UTIL_SEQ_ALL_BIT_SET;
 803af76:	bf04      	itt	eq
 803af78:	f04f 32ff 	moveq.w	r2, #4294967295
 803af7c:	f8c3 2094 	streq.w	r2, [r3, #148]	; 0x94
    CurrentTaskIdx = (SEQ_BitPosition(current_task_set & TaskPrio[counter].round_robin));
 803af80:	f8d1 9094 	ldr.w	r9, [r1, #148]	; 0x94
 803af84:	ea09 0000 	and.w	r0, r9, r0
 803af88:	f7ff ffb0 	bl	803aeec <SEQ_BitPosition>
 803af8c:	60e0      	str	r0, [r4, #12]
    TaskPrio[counter].round_robin &= ~(1U << CurrentTaskIdx);
 803af8e:	fa07 f000 	lsl.w	r0, r7, r0
 803af92:	ea29 0000 	bic.w	r0, r9, r0
 803af96:	f8c1 0094 	str.w	r0, [r1, #148]	; 0x94
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803af9a:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803af9e:	b672      	cpsid	i
    TaskSet &= ~(1U << CurrentTaskIdx);
 803afa0:	68e3      	ldr	r3, [r4, #12]
 803afa2:	6822      	ldr	r2, [r4, #0]
 803afa4:	fa07 f303 	lsl.w	r3, r7, r3
 803afa8:	ea22 0203 	bic.w	r2, r2, r3
 803afac:	6022      	str	r2, [r4, #0]
      TaskPrio[counter - 1U].priority &= ~(1U << CurrentTaskIdx);
 803afae:	f8d4 2098 	ldr.w	r2, [r4, #152]	; 0x98
 803afb2:	ea22 0203 	bic.w	r2, r2, r3
 803afb6:	f8c4 2098 	str.w	r2, [r4, #152]	; 0x98
 803afba:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
 803afbe:	ea22 0303 	bic.w	r3, r2, r3
 803afc2:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803afc6:	f381 8810 	msr	PRIMASK, r1
    TaskCb[CurrentTaskIdx]( );
 803afca:	68e3      	ldr	r3, [r4, #12]
 803afcc:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 803afd0:	691b      	ldr	r3, [r3, #16]
 803afd2:	4798      	blx	r3
 803afd4:	e7b4      	b.n	803af40 <UTIL_SEQ_Run+0x14>
  CurrentTaskIdx = UTIL_SEQ_NOTASKRUNNING;
 803afd6:	f04f 33ff 	mov.w	r3, #4294967295
 803afda:	60e3      	str	r3, [r4, #12]
  UTIL_SEQ_PreIdle( );
 803afdc:	f7ff ff84 	bl	803aee8 <UTIL_SEQ_PreIdle>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803afe0:	f3ef 8710 	mrs	r7, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803afe4:	b672      	cpsid	i
  if (!(((TaskSet & TaskMask & SuperMask) != 0U) || ((EvtSet & EvtWaited)!= 0U))) 
 803afe6:	682a      	ldr	r2, [r5, #0]
 803afe8:	6823      	ldr	r3, [r4, #0]
 803afea:	4013      	ands	r3, r2
 803afec:	686a      	ldr	r2, [r5, #4]
 803afee:	4013      	ands	r3, r2
 803aff0:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 803aff4:	400a      	ands	r2, r1
 803aff6:	4313      	orrs	r3, r2
 803aff8:	d101      	bne.n	803affe <UTIL_SEQ_Run+0xd2>
	UTIL_SEQ_Idle( );
 803affa:	f7f1 faa3 	bl	802c544 <UTIL_SEQ_Idle>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803affe:	f387 8810 	msr	PRIMASK, r7
  UTIL_SEQ_PostIdle( );
 803b002:	f7ff ff72 	bl	803aeea <UTIL_SEQ_PostIdle>
  SuperMask = super_mask_backup;
 803b006:	606e      	str	r6, [r5, #4]
}
 803b008:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 803b00c:	200035a4 	.word	0x200035a4
 803b010:	200060b0 	.word	0x200060b0

0803b014 <UTIL_SEQ_RegTask>:
{
 803b014:	b510      	push	{r4, lr}
 803b016:	4611      	mov	r1, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803b018:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803b01c:	b672      	cpsid	i
  TaskCb[SEQ_BitPosition(TaskId_bm)] = Task;
 803b01e:	f7ff ff65 	bl	803aeec <SEQ_BitPosition>
 803b022:	4b03      	ldr	r3, [pc, #12]	; (803b030 <UTIL_SEQ_RegTask+0x1c>)
 803b024:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 803b028:	6119      	str	r1, [r3, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803b02a:	f384 8810 	msr	PRIMASK, r4
}
 803b02e:	bd10      	pop	{r4, pc}
 803b030:	200060b0 	.word	0x200060b0

0803b034 <SysTimeAdd>:
  * @addtogroup SYSTIME_exported_function
  *  @{
  */

SysTime_t SysTimeAdd( SysTime_t a, SysTime_t b )
{
 803b034:	b082      	sub	sp, #8
 803b036:	b082      	sub	sp, #8
 803b038:	f10d 0c08 	add.w	ip, sp, #8
 803b03c:	e90c 0006 	stmdb	ip, {r1, r2}
  SysTime_t c =  { .Seconds = 0, .SubSeconds = 0 };

  c.Seconds = a.Seconds + b.Seconds;
 803b040:	9a00      	ldr	r2, [sp, #0]
  c.SubSeconds = a.SubSeconds + b.SubSeconds;
 803b042:	f8bd 1010 	ldrh.w	r1, [sp, #16]
{
 803b046:	9303      	str	r3, [sp, #12]
  c.Seconds = a.Seconds + b.Seconds;
 803b048:	4413      	add	r3, r2
  c.SubSeconds = a.SubSeconds + b.SubSeconds;
 803b04a:	f8bd 2004 	ldrh.w	r2, [sp, #4]
 803b04e:	440a      	add	r2, r1
 803b050:	b291      	uxth	r1, r2
 803b052:	b212      	sxth	r2, r2
  if( c.SubSeconds >= 1000 )
 803b054:	f5b2 7f7a 	cmp.w	r2, #1000	; 0x3e8
  {
    c.Seconds++;
    c.SubSeconds -= 1000;
 803b058:	bfa2      	ittt	ge
 803b05a:	f5a1 727a 	subge.w	r2, r1, #1000	; 0x3e8
    c.Seconds++;
 803b05e:	3301      	addge	r3, #1
    c.SubSeconds -= 1000;
 803b060:	b212      	sxthge	r2, r2
  }
  return c;
 803b062:	6003      	str	r3, [r0, #0]
 803b064:	8082      	strh	r2, [r0, #4]
}
 803b066:	b002      	add	sp, #8
 803b068:	b002      	add	sp, #8
 803b06a:	4770      	bx	lr

0803b06c <SysTimeSub>:

SysTime_t SysTimeSub( SysTime_t a, SysTime_t b )
{
 803b06c:	b082      	sub	sp, #8
 803b06e:	b082      	sub	sp, #8
 803b070:	f10d 0c08 	add.w	ip, sp, #8
 803b074:	e90c 0006 	stmdb	ip, {r1, r2}
  SysTime_t c = { .Seconds = 0, .SubSeconds = 0 };

  c.Seconds = a.Seconds - b.Seconds;
 803b078:	9a00      	ldr	r2, [sp, #0]
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 803b07a:	f8bd 1010 	ldrh.w	r1, [sp, #16]
{
 803b07e:	9303      	str	r3, [sp, #12]
  c.Seconds = a.Seconds - b.Seconds;
 803b080:	1ad3      	subs	r3, r2, r3
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 803b082:	f8bd 2004 	ldrh.w	r2, [sp, #4]
 803b086:	1a52      	subs	r2, r2, r1
 803b088:	b291      	uxth	r1, r2
 803b08a:	b212      	sxth	r2, r2
  if( c.SubSeconds < 0 )
 803b08c:	2a00      	cmp	r2, #0
  {
    c.Seconds--;
    c.SubSeconds += 1000;
 803b08e:	bfbe      	ittt	lt
 803b090:	f501 727a 	addlt.w	r2, r1, #1000	; 0x3e8
    c.Seconds--;
 803b094:	f103 33ff 	addlt.w	r3, r3, #4294967295
    c.SubSeconds += 1000;
 803b098:	b212      	sxthlt	r2, r2
  }
  return c;
 803b09a:	6003      	str	r3, [r0, #0]
 803b09c:	8082      	strh	r2, [r0, #4]
}
 803b09e:	b002      	add	sp, #8
 803b0a0:	b002      	add	sp, #8
 803b0a2:	4770      	bx	lr

0803b0a4 <SysTimeSet>:

void SysTimeSet( SysTime_t sysTime )
{
 803b0a4:	b530      	push	{r4, r5, lr}
 803b0a6:	b085      	sub	sp, #20
  SysTime_t DeltaTime;
  
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };

  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 803b0a8:	4d11      	ldr	r5, [pc, #68]	; (803b0f0 <SysTimeSet+0x4c>)
{
 803b0aa:	466b      	mov	r3, sp
 803b0ac:	e883 0003 	stmia.w	r3, {r0, r1}
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 803b0b0:	2300      	movs	r3, #0
 803b0b2:	9302      	str	r3, [sp, #8]
 803b0b4:	f8ad 300c 	strh.w	r3, [sp, #12]
  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 803b0b8:	a803      	add	r0, sp, #12
 803b0ba:	692b      	ldr	r3, [r5, #16]
 803b0bc:	4798      	blx	r3
  c.Seconds = a.Seconds - b.Seconds;
 803b0be:	9b00      	ldr	r3, [sp, #0]
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 803b0c0:	f8bd 4004 	ldrh.w	r4, [sp, #4]
  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 803b0c4:	9002      	str	r0, [sp, #8]
  c.Seconds = a.Seconds - b.Seconds;
 803b0c6:	1a18      	subs	r0, r3, r0
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 803b0c8:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 803b0cc:	1ae4      	subs	r4, r4, r3
 803b0ce:	b2a3      	uxth	r3, r4
 803b0d0:	b224      	sxth	r4, r4
  if( c.SubSeconds < 0 )
 803b0d2:	2c00      	cmp	r4, #0
    c.SubSeconds += 1000;
 803b0d4:	bfbe      	ittt	lt
 803b0d6:	f503 747a 	addlt.w	r4, r3, #1000	; 0x3e8
    c.Seconds--;
 803b0da:	f100 30ff 	addlt.w	r0, r0, #4294967295
    c.SubSeconds += 1000;
 803b0de:	b224      	sxthlt	r4, r4

  // sysTime is UNIX epoch
  DeltaTime = SysTimeSub( sysTime, calendarTime );

  UTIL_SYSTIMDriver.BKUPWrite_Seconds( DeltaTime.Seconds );
 803b0e0:	682b      	ldr	r3, [r5, #0]
 803b0e2:	4798      	blx	r3
  UTIL_SYSTIMDriver.BKUPWrite_SubSeconds( ( uint32_t ) DeltaTime.SubSeconds );
 803b0e4:	68ab      	ldr	r3, [r5, #8]
 803b0e6:	4620      	mov	r0, r4
 803b0e8:	4798      	blx	r3
}
 803b0ea:	b005      	add	sp, #20
 803b0ec:	bd30      	pop	{r4, r5, pc}
 803b0ee:	bf00      	nop
 803b0f0:	0803b858 	.word	0x0803b858

0803b0f4 <SysTimeGet>:

SysTime_t SysTimeGet( void )
{
 803b0f4:	b573      	push	{r0, r1, r4, r5, r6, lr}
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
  SysTime_t sysTime = { .Seconds = 0, .SubSeconds = 0 };
  SysTime_t DeltaTime;

  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 803b0f6:	4e11      	ldr	r6, [pc, #68]	; (803b13c <SysTimeGet+0x48>)
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 803b0f8:	2300      	movs	r3, #0
{
 803b0fa:	4605      	mov	r5, r0
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 803b0fc:	9300      	str	r3, [sp, #0]
 803b0fe:	f8ad 3004 	strh.w	r3, [sp, #4]
  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 803b102:	a801      	add	r0, sp, #4
 803b104:	6933      	ldr	r3, [r6, #16]
 803b106:	4798      	blx	r3

  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b108:	68f3      	ldr	r3, [r6, #12]
  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 803b10a:	9000      	str	r0, [sp, #0]
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b10c:	4798      	blx	r3
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 803b10e:	6873      	ldr	r3, [r6, #4]
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b110:	4604      	mov	r4, r0
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 803b112:	4798      	blx	r3
  c.Seconds = a.Seconds + b.Seconds;
 803b114:	9b00      	ldr	r3, [sp, #0]
 803b116:	4418      	add	r0, r3
  c.SubSeconds = a.SubSeconds + b.SubSeconds;
 803b118:	f8bd 3004 	ldrh.w	r3, [sp, #4]
 803b11c:	4423      	add	r3, r4
 803b11e:	b29a      	uxth	r2, r3
 803b120:	b21b      	sxth	r3, r3
  if( c.SubSeconds >= 1000 )
 803b122:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
    c.Seconds++;
 803b126:	bfa2      	ittt	ge
 803b128:	3001      	addge	r0, #1
    c.SubSeconds -= 1000;
 803b12a:	f5a2 737a 	subge.w	r3, r2, #1000	; 0x3e8
 803b12e:	b21b      	sxthge	r3, r3

  sysTime = SysTimeAdd( DeltaTime, calendarTime );

  return sysTime;
 803b130:	6028      	str	r0, [r5, #0]
}
 803b132:	4628      	mov	r0, r5
  return sysTime;
 803b134:	80ab      	strh	r3, [r5, #4]
}
 803b136:	b002      	add	sp, #8
 803b138:	bd70      	pop	{r4, r5, r6, pc}
 803b13a:	bf00      	nop
 803b13c:	0803b858 	.word	0x0803b858

0803b140 <SysTimeGetMcuTime>:


SysTime_t SysTimeGetMcuTime( void )
{
 803b140:	b537      	push	{r0, r1, r2, r4, r5, lr}
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 803b142:	2300      	movs	r3, #0
 803b144:	9300      	str	r3, [sp, #0]
 803b146:	f8ad 3004 	strh.w	r3, [sp, #4]

  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 803b14a:	4b07      	ldr	r3, [pc, #28]	; (803b168 <SysTimeGetMcuTime+0x28>)
{
 803b14c:	4604      	mov	r4, r0
  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 803b14e:	691b      	ldr	r3, [r3, #16]
 803b150:	a801      	add	r0, sp, #4
 803b152:	4798      	blx	r3
 803b154:	466d      	mov	r5, sp
 803b156:	9000      	str	r0, [sp, #0]
  
  return calendarTime;
 803b158:	e895 0003 	ldmia.w	r5, {r0, r1}
 803b15c:	e884 0003 	stmia.w	r4, {r0, r1}
}
 803b160:	4620      	mov	r0, r4
 803b162:	b003      	add	sp, #12
 803b164:	bd30      	pop	{r4, r5, pc}
 803b166:	bf00      	nop
 803b168:	0803b858 	.word	0x0803b858

0803b16c <SysTimeToMs>:

uint32_t SysTimeToMs( SysTime_t sysTime )
{
 803b16c:	b537      	push	{r0, r1, r2, r4, r5, lr}
  SysTime_t DeltaTime;
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b16e:	4d0e      	ldr	r5, [pc, #56]	; (803b1a8 <SysTimeToMs+0x3c>)
{
 803b170:	ab02      	add	r3, sp, #8
 803b172:	e903 0003 	stmdb	r3, {r0, r1}
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b176:	68eb      	ldr	r3, [r5, #12]
 803b178:	4798      	blx	r3
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 803b17a:	686b      	ldr	r3, [r5, #4]
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b17c:	4604      	mov	r4, r0
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 803b17e:	4798      	blx	r3
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 803b180:	f8bd 3004 	ldrh.w	r3, [sp, #4]
  c.Seconds = a.Seconds - b.Seconds;
 803b184:	9a00      	ldr	r2, [sp, #0]
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 803b186:	1b1b      	subs	r3, r3, r4
  c.Seconds = a.Seconds - b.Seconds;
 803b188:	1a12      	subs	r2, r2, r0
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 803b18a:	b298      	uxth	r0, r3
 803b18c:	b21b      	sxth	r3, r3
  if( c.SubSeconds < 0 )
 803b18e:	2b00      	cmp	r3, #0
    c.SubSeconds += 1000;
 803b190:	bfbe      	ittt	lt
 803b192:	f500 707a 	addlt.w	r0, r0, #1000	; 0x3e8
 803b196:	b203      	sxthlt	r3, r0
    c.Seconds--;
 803b198:	f102 32ff 	addlt.w	r2, r2, #4294967295
  
  SysTime_t calendarTime = SysTimeSub( sysTime, DeltaTime );
  return calendarTime.Seconds * 1000 + calendarTime.SubSeconds;
}
 803b19c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 803b1a0:	fb00 3002 	mla	r0, r0, r2, r3
 803b1a4:	b003      	add	sp, #12
 803b1a6:	bd30      	pop	{r4, r5, pc}
 803b1a8:	0803b858 	.word	0x0803b858

0803b1ac <SysTimeFromMs>:

SysTime_t SysTimeFromMs( uint32_t timeMs )
{
 803b1ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t seconds = timeMs / 1000;
 803b1b0:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 803b1b4:	fbb1 f5f5 	udiv	r5, r1, r5
  SysTime_t sysTime = { .Seconds = seconds, .SubSeconds =  timeMs - seconds * 1000 };
 803b1b8:	ebc5 1345 	rsb	r3, r5, r5, lsl #5
  SysTime_t DeltaTime = { 0 };

  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b1bc:	f8df 803c 	ldr.w	r8, [pc, #60]	; 803b1fc <SysTimeFromMs+0x50>
  SysTime_t sysTime = { .Seconds = seconds, .SubSeconds =  timeMs - seconds * 1000 };
 803b1c0:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 803b1c4:	eba1 03c3 	sub.w	r3, r1, r3, lsl #3
 803b1c8:	b29c      	uxth	r4, r3
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b1ca:	f8d8 300c 	ldr.w	r3, [r8, #12]
{
 803b1ce:	4606      	mov	r6, r0
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b1d0:	4798      	blx	r3
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 803b1d2:	f8d8 3004 	ldr.w	r3, [r8, #4]
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b1d6:	4607      	mov	r7, r0
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 803b1d8:	4798      	blx	r3
  c.SubSeconds = a.SubSeconds + b.SubSeconds;
 803b1da:	19e3      	adds	r3, r4, r7
 803b1dc:	b29a      	uxth	r2, r3
 803b1de:	b21b      	sxth	r3, r3
  if( c.SubSeconds >= 1000 )
 803b1e0:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
  c.Seconds = a.Seconds + b.Seconds;
 803b1e4:	4405      	add	r5, r0
    c.SubSeconds -= 1000;
 803b1e6:	bfa2      	ittt	ge
 803b1e8:	f5a2 737a 	subge.w	r3, r2, #1000	; 0x3e8
    c.Seconds++;
 803b1ec:	3501      	addge	r5, #1
    c.SubSeconds -= 1000;
 803b1ee:	b21b      	sxthge	r3, r3
  return c;
 803b1f0:	6035      	str	r5, [r6, #0]
 803b1f2:	80b3      	strh	r3, [r6, #4]
  return SysTimeAdd( sysTime, DeltaTime );
}
 803b1f4:	4630      	mov	r0, r6
 803b1f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 803b1fa:	bf00      	nop
 803b1fc:	0803b858 	.word	0x0803b858

0803b200 <UTIL_TIMER_Init>:
  */

UTIL_TIMER_Status_t UTIL_TIMER_Init(void)
{
  UTIL_TIMER_INIT_CRITICAL_SECTION();
  TimerListHead = NULL;
 803b200:	4b02      	ldr	r3, [pc, #8]	; (803b20c <UTIL_TIMER_Init+0xc>)
 803b202:	2200      	movs	r2, #0
 803b204:	601a      	str	r2, [r3, #0]
  return UTIL_TimerDriver.InitTimer();
 803b206:	4b02      	ldr	r3, [pc, #8]	; (803b210 <UTIL_TIMER_Init+0x10>)
 803b208:	681b      	ldr	r3, [r3, #0]
 803b20a:	4718      	bx	r3
 803b20c:	20006150 	.word	0x20006150
 803b210:	0803b86c 	.word	0x0803b86c

0803b214 <UTIL_TIMER_Create>:
{
  return UTIL_TimerDriver.DeInitTimer();
}

UTIL_TIMER_Status_t UTIL_TIMER_Create( UTIL_TIMER_Object_t *TimerObject, uint32_t PeriodValue, UTIL_TIMER_Mode_t Mode, void ( *Callback )( void *), void *Argument)
{
 803b214:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 803b216:	4604      	mov	r4, r0
 803b218:	4617      	mov	r7, r2
 803b21a:	4608      	mov	r0, r1
 803b21c:	461e      	mov	r6, r3
  if((TimerObject != NULL) && (Callback != NULL))
 803b21e:	b17c      	cbz	r4, 803b240 <UTIL_TIMER_Create+0x2c>
 803b220:	b173      	cbz	r3, 803b240 <UTIL_TIMER_Create+0x2c>
  {
    TimerObject->Timestamp = 0U;
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(PeriodValue);
 803b222:	4b08      	ldr	r3, [pc, #32]	; (803b244 <UTIL_TIMER_Create+0x30>)
    TimerObject->Timestamp = 0U;
 803b224:	2500      	movs	r5, #0
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(PeriodValue);
 803b226:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    TimerObject->Timestamp = 0U;
 803b228:	6025      	str	r5, [r4, #0]
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(PeriodValue);
 803b22a:	4798      	blx	r3
    TimerObject->IsPending = 0U;
    TimerObject->IsRunning = 0U;
    TimerObject->IsReloadStopped = 0U;
    TimerObject->Callback = Callback;
    TimerObject->argument = Argument;
 803b22c:	9b06      	ldr	r3, [sp, #24]
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(PeriodValue);
 803b22e:	6060      	str	r0, [r4, #4]
    TimerObject->IsPending = 0U;
 803b230:	8125      	strh	r5, [r4, #8]
    TimerObject->IsReloadStopped = 0U;
 803b232:	72a5      	strb	r5, [r4, #10]
    TimerObject->Callback = Callback;
 803b234:	60e6      	str	r6, [r4, #12]
    TimerObject->argument = Argument;
 803b236:	6123      	str	r3, [r4, #16]
    TimerObject->Mode = Mode;
 803b238:	72e7      	strb	r7, [r4, #11]
    TimerObject->Next = NULL;
 803b23a:	6165      	str	r5, [r4, #20]
    return UTIL_TIMER_OK;
 803b23c:	4628      	mov	r0, r5
  }
  else
  {
    return UTIL_TIMER_INVALID_PARAM;
  }
}
 803b23e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return UTIL_TIMER_INVALID_PARAM;
 803b240:	2001      	movs	r0, #1
 803b242:	e7fc      	b.n	803b23e <UTIL_TIMER_Create+0x2a>
 803b244:	0803b86c 	.word	0x0803b86c

0803b248 <UTIL_TIMER_GetCurrentTime>:
  }
  UTIL_TIMER_EXIT_CRITICAL_SECTION();
}

UTIL_TIMER_Time_t UTIL_TIMER_GetCurrentTime(void)
{
 803b248:	b510      	push	{r4, lr}
  uint32_t now = UTIL_TimerDriver.GetTimerValue( );
 803b24a:	4c03      	ldr	r4, [pc, #12]	; (803b258 <UTIL_TIMER_GetCurrentTime+0x10>)
 803b24c:	69e3      	ldr	r3, [r4, #28]
 803b24e:	4798      	blx	r3
  return  UTIL_TimerDriver.Tick2ms(now);
 803b250:	6aa3      	ldr	r3, [r4, #40]	; 0x28
}
 803b252:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return  UTIL_TimerDriver.Tick2ms(now);
 803b256:	4718      	bx	r3
 803b258:	0803b86c 	.word	0x0803b86c

0803b25c <UTIL_TIMER_GetElapsedTime>:

UTIL_TIMER_Time_t UTIL_TIMER_GetElapsedTime(UTIL_TIMER_Time_t past )
{
 803b25c:	b570      	push	{r4, r5, r6, lr}
  uint32_t nowInTicks = UTIL_TimerDriver.GetTimerValue( );
 803b25e:	4d06      	ldr	r5, [pc, #24]	; (803b278 <UTIL_TIMER_GetElapsedTime+0x1c>)
 803b260:	69eb      	ldr	r3, [r5, #28]
{
 803b262:	4606      	mov	r6, r0
  uint32_t nowInTicks = UTIL_TimerDriver.GetTimerValue( );
 803b264:	4798      	blx	r3
  uint32_t pastInTicks = UTIL_TimerDriver.ms2Tick( past );
 803b266:	6a6b      	ldr	r3, [r5, #36]	; 0x24
  uint32_t nowInTicks = UTIL_TimerDriver.GetTimerValue( );
 803b268:	4604      	mov	r4, r0
  uint32_t pastInTicks = UTIL_TimerDriver.ms2Tick( past );
 803b26a:	4630      	mov	r0, r6
 803b26c:	4798      	blx	r3
  /* intentional wrap around. Works Ok if tick duation below 1ms */
  return UTIL_TimerDriver.Tick2ms( nowInTicks- pastInTicks );
 803b26e:	6aab      	ldr	r3, [r5, #40]	; 0x28
 803b270:	1a20      	subs	r0, r4, r0
}
 803b272:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  return UTIL_TimerDriver.Tick2ms( nowInTicks- pastInTicks );
 803b276:	4718      	bx	r3
 803b278:	0803b86c 	.word	0x0803b86c

0803b27c <TimerExists>:
 * @param TimerObject Structure containing the timer object parameters
 * @retval 1 (the object is already in the list) or 0
 */
bool TimerExists( UTIL_TIMER_Object_t *TimerObject )
{
  UTIL_TIMER_Object_t* cur = TimerListHead;
 803b27c:	4a05      	ldr	r2, [pc, #20]	; (803b294 <TimerExists+0x18>)
{
 803b27e:	4603      	mov	r3, r0
  UTIL_TIMER_Object_t* cur = TimerListHead;
 803b280:	6810      	ldr	r0, [r2, #0]

  while( cur != NULL )
 803b282:	b900      	cbnz	r0, 803b286 <TimerExists+0xa>
 803b284:	4770      	bx	lr
  {
    if( cur == TimerObject )
 803b286:	4298      	cmp	r0, r3
 803b288:	d001      	beq.n	803b28e <TimerExists+0x12>
    {
      return true;
    }
    cur = cur->Next;
 803b28a:	6940      	ldr	r0, [r0, #20]
 803b28c:	e7f9      	b.n	803b282 <TimerExists+0x6>
      return true;
 803b28e:	2001      	movs	r0, #1
  }
  return false;
}
 803b290:	4770      	bx	lr
 803b292:	bf00      	nop
 803b294:	20006150 	.word	0x20006150

0803b298 <TimerSetTimeout>:
 * @brief Sets a timeout with the duration "timestamp"
 *
 * @param TimerObject Structure containing the timer object parameters
 */
void TimerSetTimeout( UTIL_TIMER_Object_t *TimerObject )
{
 803b298:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  uint32_t minTicks= UTIL_TimerDriver.GetMinimumTimeout( );
 803b29c:	4d0b      	ldr	r5, [pc, #44]	; (803b2cc <TimerSetTimeout+0x34>)
 803b29e:	6a2b      	ldr	r3, [r5, #32]
{
 803b2a0:	4604      	mov	r4, r0
  uint32_t minTicks= UTIL_TimerDriver.GetMinimumTimeout( );
 803b2a2:	4798      	blx	r3
  TimerObject->IsPending = 1;
 803b2a4:	2301      	movs	r3, #1

  /* In case deadline too soon */
  if(TimerObject->Timestamp  < (UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks) )
 803b2a6:	69af      	ldr	r7, [r5, #24]
  TimerObject->IsPending = 1;
 803b2a8:	7223      	strb	r3, [r4, #8]
  if(TimerObject->Timestamp  < (UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks) )
 803b2aa:	f8d4 8000 	ldr.w	r8, [r4]
  uint32_t minTicks= UTIL_TimerDriver.GetMinimumTimeout( );
 803b2ae:	4606      	mov	r6, r0
  if(TimerObject->Timestamp  < (UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks) )
 803b2b0:	47b8      	blx	r7
 803b2b2:	4430      	add	r0, r6
 803b2b4:	4580      	cmp	r8, r0
 803b2b6:	d202      	bcs.n	803b2be <TimerSetTimeout+0x26>
  {
	  TimerObject->Timestamp = UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks;
 803b2b8:	47b8      	blx	r7
 803b2ba:	4406      	add	r6, r0
 803b2bc:	6026      	str	r6, [r4, #0]
  }
  UTIL_TimerDriver.StartTimerEvt( TimerObject->Timestamp );
 803b2be:	68ab      	ldr	r3, [r5, #8]
 803b2c0:	6820      	ldr	r0, [r4, #0]
 803b2c2:	9301      	str	r3, [sp, #4]
}
 803b2c4:	b002      	add	sp, #8
 803b2c6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  UTIL_TimerDriver.StartTimerEvt( TimerObject->Timestamp );
 803b2ca:	4718      	bx	r3
 803b2cc:	0803b86c 	.word	0x0803b86c

0803b2d0 <UTIL_TIMER_Stop>:
{
 803b2d0:	b570      	push	{r4, r5, r6, lr}
  if (NULL != TimerObject)
 803b2d2:	b320      	cbz	r0, 803b31e <UTIL_TIMER_Stop+0x4e>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803b2d4:	f3ef 8610 	mrs	r6, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803b2d8:	b672      	cpsid	i
    UTIL_TIMER_Object_t* prev = TimerListHead;
 803b2da:	4d12      	ldr	r5, [pc, #72]	; (803b324 <UTIL_TIMER_Stop+0x54>)
 803b2dc:	682b      	ldr	r3, [r5, #0]
    TimerObject->IsReloadStopped = 1U;
 803b2de:	2201      	movs	r2, #1
 803b2e0:	7282      	strb	r2, [r0, #10]
    if(NULL != TimerListHead)
 803b2e2:	b153      	cbz	r3, 803b2fa <UTIL_TIMER_Stop+0x2a>
      TimerObject->IsRunning = 0U;
 803b2e4:	2200      	movs	r2, #0
      if( TimerListHead == TimerObject ) /* Stop the Head */
 803b2e6:	4298      	cmp	r0, r3
      TimerObject->IsRunning = 0U;
 803b2e8:	7242      	strb	r2, [r0, #9]
      if( TimerListHead == TimerObject ) /* Stop the Head */
 803b2ea:	d10f      	bne.n	803b30c <UTIL_TIMER_Stop+0x3c>
 803b2ec:	6944      	ldr	r4, [r0, #20]
          TimerListHead->IsPending = 0;
 803b2ee:	7202      	strb	r2, [r0, #8]
          if( TimerListHead->Next != NULL )
 803b2f0:	b13c      	cbz	r4, 803b302 <UTIL_TIMER_Stop+0x32>
            TimerSetTimeout( TimerListHead );
 803b2f2:	4620      	mov	r0, r4
            TimerListHead = TimerListHead->Next;
 803b2f4:	602c      	str	r4, [r5, #0]
            TimerSetTimeout( TimerListHead );
 803b2f6:	f7ff ffcf 	bl	803b298 <TimerSetTimeout>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803b2fa:	f386 8810 	msr	PRIMASK, r6
}
 803b2fe:	2000      	movs	r0, #0
}
 803b300:	bd70      	pop	{r4, r5, r6, pc}
            UTIL_TimerDriver.StopTimerEvt( );
 803b302:	4b09      	ldr	r3, [pc, #36]	; (803b328 <UTIL_TIMER_Stop+0x58>)
 803b304:	68db      	ldr	r3, [r3, #12]
 803b306:	4798      	blx	r3
            TimerListHead = NULL;
 803b308:	602c      	str	r4, [r5, #0]
 803b30a:	e7f6      	b.n	803b2fa <UTIL_TIMER_Stop+0x2a>
            cur = cur->Next;
 803b30c:	461a      	mov	r2, r3
 803b30e:	695b      	ldr	r3, [r3, #20]
        while( cur != NULL )
 803b310:	2b00      	cmp	r3, #0
 803b312:	d0f2      	beq.n	803b2fa <UTIL_TIMER_Stop+0x2a>
          if( cur == TimerObject )
 803b314:	4298      	cmp	r0, r3
 803b316:	d1f9      	bne.n	803b30c <UTIL_TIMER_Stop+0x3c>
            if( cur->Next != NULL )
 803b318:	6943      	ldr	r3, [r0, #20]
              prev->Next = cur;
 803b31a:	6153      	str	r3, [r2, #20]
 803b31c:	e7ed      	b.n	803b2fa <UTIL_TIMER_Stop+0x2a>
    ret = UTIL_TIMER_INVALID_PARAM;
 803b31e:	2001      	movs	r0, #1
 803b320:	e7ee      	b.n	803b300 <UTIL_TIMER_Stop+0x30>
 803b322:	bf00      	nop
 803b324:	20006150 	.word	0x20006150
 803b328:	0803b86c 	.word	0x0803b86c

0803b32c <TimerInsertTimer>:
 *
 * @param TimerObject Structure containing the timer object parameters
 */
void TimerInsertTimer( UTIL_TIMER_Object_t *TimerObject)
{
  UTIL_TIMER_Object_t* cur = TimerListHead;
 803b32c:	4b09      	ldr	r3, [pc, #36]	; (803b354 <TimerInsertTimer+0x28>)
{
 803b32e:	b510      	push	{r4, lr}
  UTIL_TIMER_Object_t* cur = TimerListHead;
 803b330:	681b      	ldr	r3, [r3, #0]
  UTIL_TIMER_Object_t* next = TimerListHead->Next;
 803b332:	695a      	ldr	r2, [r3, #20]

  while (cur->Next != NULL )
 803b334:	6959      	ldr	r1, [r3, #20]
 803b336:	b911      	cbnz	r1, 803b33e <TimerInsertTimer+0x12>
        TimerObject->Next = next;
        return;

    }
  }
  cur->Next = TimerObject;
 803b338:	6158      	str	r0, [r3, #20]
  TimerObject->Next = NULL;
 803b33a:	6141      	str	r1, [r0, #20]
 803b33c:	e008      	b.n	803b350 <TimerInsertTimer+0x24>
    if( TimerObject->Timestamp  > next->Timestamp )
 803b33e:	6804      	ldr	r4, [r0, #0]
 803b340:	6811      	ldr	r1, [r2, #0]
 803b342:	428c      	cmp	r4, r1
 803b344:	d902      	bls.n	803b34c <TimerInsertTimer+0x20>
        next = next->Next;
 803b346:	4613      	mov	r3, r2
 803b348:	6952      	ldr	r2, [r2, #20]
 803b34a:	e7f3      	b.n	803b334 <TimerInsertTimer+0x8>
        cur->Next = TimerObject;
 803b34c:	6158      	str	r0, [r3, #20]
        TimerObject->Next = next;
 803b34e:	6142      	str	r2, [r0, #20]
}
 803b350:	bd10      	pop	{r4, pc}
 803b352:	bf00      	nop
 803b354:	20006150 	.word	0x20006150

0803b358 <TimerInsertNewHeadTimer>:
 * @remark The list is automatically sorted. The list head always contains the
 *         next timer to expire.
 */
void TimerInsertNewHeadTimer( UTIL_TIMER_Object_t *TimerObject )
{
  UTIL_TIMER_Object_t* cur = TimerListHead;
 803b358:	4b04      	ldr	r3, [pc, #16]	; (803b36c <TimerInsertNewHeadTimer+0x14>)
 803b35a:	681a      	ldr	r2, [r3, #0]

  if( cur != NULL )
 803b35c:	b10a      	cbz	r2, 803b362 <TimerInsertNewHeadTimer+0xa>
  {
    cur->IsPending = 0;
 803b35e:	2100      	movs	r1, #0
 803b360:	7211      	strb	r1, [r2, #8]
  }

  TimerObject->Next = cur;
 803b362:	6142      	str	r2, [r0, #20]
  TimerListHead = TimerObject;
 803b364:	6018      	str	r0, [r3, #0]
  TimerSetTimeout( TimerListHead );
 803b366:	f7ff bf97 	b.w	803b298 <TimerSetTimeout>
 803b36a:	bf00      	nop
 803b36c:	20006150 	.word	0x20006150

0803b370 <UTIL_TIMER_Start>:
{
 803b370:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if(( TimerObject != NULL ) && ( TimerExists( TimerObject ) == false ) && (TimerObject->IsRunning == 0U))
 803b374:	4604      	mov	r4, r0
 803b376:	2800      	cmp	r0, #0
 803b378:	d02d      	beq.n	803b3d6 <UTIL_TIMER_Start+0x66>
 803b37a:	f7ff ff7f 	bl	803b27c <TimerExists>
 803b37e:	bb50      	cbnz	r0, 803b3d6 <UTIL_TIMER_Start+0x66>
 803b380:	7a65      	ldrb	r5, [r4, #9]
 803b382:	bb45      	cbnz	r5, 803b3d6 <UTIL_TIMER_Start+0x66>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803b384:	f3ef 8810 	mrs	r8, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803b388:	b672      	cpsid	i
    minValue = UTIL_TimerDriver.GetMinimumTimeout( );
 803b38a:	4e14      	ldr	r6, [pc, #80]	; (803b3dc <UTIL_TIMER_Start+0x6c>)
    ticks = TimerObject->ReloadValue;
 803b38c:	6867      	ldr	r7, [r4, #4]
    minValue = UTIL_TimerDriver.GetMinimumTimeout( );
 803b38e:	6a33      	ldr	r3, [r6, #32]
 803b390:	4798      	blx	r3
    TimerObject->Timestamp = ticks;
 803b392:	4287      	cmp	r7, r0
 803b394:	bf2c      	ite	cs
 803b396:	6027      	strcs	r7, [r4, #0]
 803b398:	6020      	strcc	r0, [r4, #0]
    if( TimerListHead == NULL )
 803b39a:	4f11      	ldr	r7, [pc, #68]	; (803b3e0 <UTIL_TIMER_Start+0x70>)
    TimerObject->IsReloadStopped = 0U;
 803b39c:	72a5      	strb	r5, [r4, #10]
    TimerObject->IsPending = 0U;
 803b39e:	f44f 7380 	mov.w	r3, #256	; 0x100
 803b3a2:	8123      	strh	r3, [r4, #8]
    if( TimerListHead == NULL )
 803b3a4:	683b      	ldr	r3, [r7, #0]
 803b3a6:	b94b      	cbnz	r3, 803b3bc <UTIL_TIMER_Start+0x4c>
      UTIL_TimerDriver.SetTimerContext();
 803b3a8:	6933      	ldr	r3, [r6, #16]
 803b3aa:	4798      	blx	r3
      TimerInsertNewHeadTimer( TimerObject ); /* insert a timeout at now+obj->Timestamp */
 803b3ac:	4620      	mov	r0, r4
        TimerInsertNewHeadTimer( TimerObject);
 803b3ae:	f7ff ffd3 	bl	803b358 <TimerInsertNewHeadTimer>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803b3b2:	f388 8810 	msr	PRIMASK, r8
}
 803b3b6:	4628      	mov	r0, r5
 803b3b8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      elapsedTime = UTIL_TimerDriver.GetTimerElapsedTime( );
 803b3bc:	69b3      	ldr	r3, [r6, #24]
 803b3be:	4798      	blx	r3
      TimerObject->Timestamp += elapsedTime;
 803b3c0:	6823      	ldr	r3, [r4, #0]
 803b3c2:	4418      	add	r0, r3
      if( TimerObject->Timestamp < TimerListHead->Timestamp )
 803b3c4:	683b      	ldr	r3, [r7, #0]
      TimerObject->Timestamp += elapsedTime;
 803b3c6:	6020      	str	r0, [r4, #0]
      if( TimerObject->Timestamp < TimerListHead->Timestamp )
 803b3c8:	681b      	ldr	r3, [r3, #0]
 803b3ca:	4298      	cmp	r0, r3
        TimerInsertNewHeadTimer( TimerObject);
 803b3cc:	4620      	mov	r0, r4
      if( TimerObject->Timestamp < TimerListHead->Timestamp )
 803b3ce:	d3ee      	bcc.n	803b3ae <UTIL_TIMER_Start+0x3e>
        TimerInsertTimer( TimerObject);
 803b3d0:	f7ff ffac 	bl	803b32c <TimerInsertTimer>
 803b3d4:	e7ed      	b.n	803b3b2 <UTIL_TIMER_Start+0x42>
    ret =  UTIL_TIMER_INVALID_PARAM;
 803b3d6:	2501      	movs	r5, #1
 803b3d8:	e7ed      	b.n	803b3b6 <UTIL_TIMER_Start+0x46>
 803b3da:	bf00      	nop
 803b3dc:	0803b86c 	.word	0x0803b86c
 803b3e0:	20006150 	.word	0x20006150

0803b3e4 <UTIL_TIMER_SetPeriod>:
{
 803b3e4:	b510      	push	{r4, lr}
 803b3e6:	4604      	mov	r4, r0
 803b3e8:	4608      	mov	r0, r1
  if(NULL == TimerObject)
 803b3ea:	b17c      	cbz	r4, 803b40c <UTIL_TIMER_SetPeriod+0x28>
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(NewPeriodValue);
 803b3ec:	4b08      	ldr	r3, [pc, #32]	; (803b410 <UTIL_TIMER_SetPeriod+0x2c>)
 803b3ee:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 803b3f0:	4798      	blx	r3
 803b3f2:	6060      	str	r0, [r4, #4]
    if(TimerExists(TimerObject))
 803b3f4:	4620      	mov	r0, r4
 803b3f6:	f7ff ff41 	bl	803b27c <TimerExists>
 803b3fa:	b140      	cbz	r0, 803b40e <UTIL_TIMER_SetPeriod+0x2a>
      (void)UTIL_TIMER_Stop(TimerObject);
 803b3fc:	4620      	mov	r0, r4
 803b3fe:	f7ff ff67 	bl	803b2d0 <UTIL_TIMER_Stop>
      ret = UTIL_TIMER_Start(TimerObject);
 803b402:	4620      	mov	r0, r4
}
 803b404:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      ret = UTIL_TIMER_Start(TimerObject);
 803b408:	f7ff bfb2 	b.w	803b370 <UTIL_TIMER_Start>
	  ret = UTIL_TIMER_INVALID_PARAM;
 803b40c:	2001      	movs	r0, #1
}
 803b40e:	bd10      	pop	{r4, pc}
 803b410:	0803b86c 	.word	0x0803b86c

0803b414 <UTIL_TIMER_IRQ_Handler>:
{
 803b414:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803b418:	f3ef 8710 	mrs	r7, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803b41c:	b672      	cpsid	i
  old  =  UTIL_TimerDriver.GetTimerContext( );
 803b41e:	4e1d      	ldr	r6, [pc, #116]	; (803b494 <UTIL_TIMER_IRQ_Handler+0x80>)
  if ( TimerListHead != NULL )
 803b420:	4c1d      	ldr	r4, [pc, #116]	; (803b498 <UTIL_TIMER_IRQ_Handler+0x84>)
  old  =  UTIL_TimerDriver.GetTimerContext( );
 803b422:	6973      	ldr	r3, [r6, #20]
 803b424:	4798      	blx	r3
  now  =  UTIL_TimerDriver.SetTimerContext( );
 803b426:	6933      	ldr	r3, [r6, #16]
  old  =  UTIL_TimerDriver.GetTimerContext( );
 803b428:	4605      	mov	r5, r0
  now  =  UTIL_TimerDriver.SetTimerContext( );
 803b42a:	4798      	blx	r3
  if ( TimerListHead != NULL )
 803b42c:	6823      	ldr	r3, [r4, #0]
 803b42e:	b94b      	cbnz	r3, 803b444 <UTIL_TIMER_IRQ_Handler+0x30>
      cur->IsPending = 0;
 803b430:	f04f 0800 	mov.w	r8, #0
  while ((TimerListHead != NULL) && ((TimerListHead->Timestamp == 0U) || (TimerListHead->Timestamp < UTIL_TimerDriver.GetTimerElapsedTime(  ))))
 803b434:	6823      	ldr	r3, [r4, #0]
 803b436:	b98b      	cbnz	r3, 803b45c <UTIL_TIMER_IRQ_Handler+0x48>
  if(( TimerListHead != NULL ) && (TimerListHead->IsPending == 0U))
 803b438:	6820      	ldr	r0, [r4, #0]
 803b43a:	bb28      	cbnz	r0, 803b488 <UTIL_TIMER_IRQ_Handler+0x74>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803b43c:	f387 8810 	msr	PRIMASK, r7
}
 803b440:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  DeltaContext = now  - old; /*intentional wrap around */
 803b444:	1b41      	subs	r1, r0, r5
        cur->Timestamp -= DeltaContext;
 803b446:	1a2d      	subs	r5, r5, r0
      if (cur->Timestamp > DeltaContext)
 803b448:	681a      	ldr	r2, [r3, #0]
 803b44a:	428a      	cmp	r2, r1
        cur->Timestamp -= DeltaContext;
 803b44c:	bf8c      	ite	hi
 803b44e:	1952      	addhi	r2, r2, r5
        cur->Timestamp = 0;
 803b450:	2200      	movls	r2, #0
 803b452:	601a      	str	r2, [r3, #0]
      cur = cur->Next;
 803b454:	695b      	ldr	r3, [r3, #20]
    } while(cur != NULL);
 803b456:	2b00      	cmp	r3, #0
 803b458:	d1f6      	bne.n	803b448 <UTIL_TIMER_IRQ_Handler+0x34>
 803b45a:	e7e9      	b.n	803b430 <UTIL_TIMER_IRQ_Handler+0x1c>
  while ((TimerListHead != NULL) && ((TimerListHead->Timestamp == 0U) || (TimerListHead->Timestamp < UTIL_TimerDriver.GetTimerElapsedTime(  ))))
 803b45c:	681d      	ldr	r5, [r3, #0]
 803b45e:	b11d      	cbz	r5, 803b468 <UTIL_TIMER_IRQ_Handler+0x54>
 803b460:	69b3      	ldr	r3, [r6, #24]
 803b462:	4798      	blx	r3
 803b464:	4285      	cmp	r5, r0
 803b466:	d2e7      	bcs.n	803b438 <UTIL_TIMER_IRQ_Handler+0x24>
      cur = TimerListHead;
 803b468:	6825      	ldr	r5, [r4, #0]
      TimerListHead = TimerListHead->Next;
 803b46a:	696b      	ldr	r3, [r5, #20]
 803b46c:	6023      	str	r3, [r4, #0]
      cur->IsPending = 0;
 803b46e:	f8a5 8008 	strh.w	r8, [r5, #8]
      cur->Callback(cur->argument);
 803b472:	e9d5 3003 	ldrd	r3, r0, [r5, #12]
 803b476:	4798      	blx	r3
      if(( cur->Mode == UTIL_TIMER_PERIODIC) && (cur->IsReloadStopped == 0U))
 803b478:	896b      	ldrh	r3, [r5, #10]
 803b47a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 803b47e:	d1d9      	bne.n	803b434 <UTIL_TIMER_IRQ_Handler+0x20>
        (void)UTIL_TIMER_Start(cur);
 803b480:	4628      	mov	r0, r5
 803b482:	f7ff ff75 	bl	803b370 <UTIL_TIMER_Start>
 803b486:	e7d5      	b.n	803b434 <UTIL_TIMER_IRQ_Handler+0x20>
  if(( TimerListHead != NULL ) && (TimerListHead->IsPending == 0U))
 803b488:	7a03      	ldrb	r3, [r0, #8]
 803b48a:	2b00      	cmp	r3, #0
 803b48c:	d1d6      	bne.n	803b43c <UTIL_TIMER_IRQ_Handler+0x28>
    TimerSetTimeout( TimerListHead );
 803b48e:	f7ff ff03 	bl	803b298 <TimerSetTimeout>
 803b492:	e7d3      	b.n	803b43c <UTIL_TIMER_IRQ_Handler+0x28>
 803b494:	0803b86c 	.word	0x0803b86c
 803b498:	20006150 	.word	0x20006150

0803b49c <tiny_vsnprintf_like>:

#define CHECK_STR_SIZE(_buf, _str, _size) \
  if ((((_str) - (_buf)) >= ((_size)-1))) { break; }

int tiny_vsnprintf_like(char *buf, const int size, const char *fmt, va_list args)
{
 803b49c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 803b4a0:	b099      	sub	sp, #100	; 0x64

  int field_width;      // Width of output field
  int precision;        // Min. # of digits for integers; max number of chars for from string
  int qualifier;        // 'h', 'l', or 'L' for integer fields

  if (size <= 0)
 803b4a2:	2900      	cmp	r1, #0
{
 803b4a4:	4683      	mov	fp, r0
  if (size <= 0)
 803b4a6:	9105      	str	r1, [sp, #20]
 803b4a8:	f340 8109 	ble.w	803b6be <tiny_vsnprintf_like+0x222>
  {
    return 0;
  }
  
  for (str = buf; *fmt || ((str - buf) >= size-1); fmt++)
 803b4ac:	4604      	mov	r4, r0
  if (!(type & (ZEROPAD /* TINY option   | LEFT */))) while (size-- > 0) ASSIGN_STR(' ');
 803b4ae:	f04f 0920 	mov.w	r9, #32
  for (str = buf; *fmt || ((str - buf) >= size-1); fmt++)
 803b4b2:	9905      	ldr	r1, [sp, #20]
 803b4b4:	7815      	ldrb	r5, [r2, #0]
 803b4b6:	eba4 000b 	sub.w	r0, r4, fp
 803b4ba:	3901      	subs	r1, #1
 803b4bc:	b925      	cbnz	r5, 803b4c8 <tiny_vsnprintf_like+0x2c>
      num = va_arg(args, unsigned int);

    str = ee_number(str, ((size - 1) - (str - buf)), num, base, field_width, precision, flags);
  }

  *str = '\0';
 803b4be:	2300      	movs	r3, #0
 803b4c0:	7023      	strb	r3, [r4, #0]
  return str - buf;
}
 803b4c2:	b019      	add	sp, #100	; 0x64
 803b4c4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    CHECK_STR_SIZE(buf, str, size);
 803b4c8:	4288      	cmp	r0, r1
 803b4ca:	daf8      	bge.n	803b4be <tiny_vsnprintf_like+0x22>
    if (*fmt != '%')
 803b4cc:	2d25      	cmp	r5, #37	; 0x25
 803b4ce:	d004      	beq.n	803b4da <tiny_vsnprintf_like+0x3e>
      *str++ = *fmt;
 803b4d0:	f804 5b01 	strb.w	r5, [r4], #1
      continue;
 803b4d4:	4616      	mov	r6, r2
  for (str = buf; *fmt || ((str - buf) >= size-1); fmt++)
 803b4d6:	1c72      	adds	r2, r6, #1
 803b4d8:	e7eb      	b.n	803b4b2 <tiny_vsnprintf_like+0x16>
    if (*fmt == '0')
 803b4da:	f892 e001 	ldrb.w	lr, [r2, #1]
 803b4de:	1c56      	adds	r6, r2, #1
 803b4e0:	f1ae 0230 	sub.w	r2, lr, #48	; 0x30
 803b4e4:	4250      	negs	r0, r2
 803b4e6:	4150      	adcs	r0, r2
    if (is_digit(*fmt))
 803b4e8:	f1ae 0230 	sub.w	r2, lr, #48	; 0x30
 803b4ec:	2a09      	cmp	r2, #9
 803b4ee:	d828      	bhi.n	803b542 <tiny_vsnprintf_like+0xa6>
 803b4f0:	4637      	mov	r7, r6
  int i = 0;
 803b4f2:	2500      	movs	r5, #0
 803b4f4:	463e      	mov	r6, r7
  while (is_digit(**s)) i = i*10 + *((*s)++) - '0';
 803b4f6:	f817 2b01 	ldrb.w	r2, [r7], #1
 803b4fa:	f1a2 0c30 	sub.w	ip, r2, #48	; 0x30
 803b4fe:	f1bc 0f09 	cmp.w	ip, #9
 803b502:	d919      	bls.n	803b538 <tiny_vsnprintf_like+0x9c>
    switch (*fmt)
 803b504:	7832      	ldrb	r2, [r6, #0]
 803b506:	2a69      	cmp	r2, #105	; 0x69
 803b508:	f000 8097 	beq.w	803b63a <tiny_vsnprintf_like+0x19e>
 803b50c:	d81c      	bhi.n	803b548 <tiny_vsnprintf_like+0xac>
 803b50e:	2a63      	cmp	r2, #99	; 0x63
 803b510:	d028      	beq.n	803b564 <tiny_vsnprintf_like+0xc8>
 803b512:	2a64      	cmp	r2, #100	; 0x64
 803b514:	f000 8091 	beq.w	803b63a <tiny_vsnprintf_like+0x19e>
 803b518:	2a58      	cmp	r2, #88	; 0x58
 803b51a:	d059      	beq.n	803b5d0 <tiny_vsnprintf_like+0x134>
        if (*fmt != '%') *str++ = '%';
 803b51c:	2a25      	cmp	r2, #37	; 0x25
 803b51e:	d119      	bne.n	803b554 <tiny_vsnprintf_like+0xb8>
        if (*fmt)
 803b520:	7832      	ldrb	r2, [r6, #0]
 803b522:	2a00      	cmp	r2, #0
 803b524:	f000 808d 	beq.w	803b642 <tiny_vsnprintf_like+0x1a6>
          *str++ = *fmt;
 803b528:	f804 2b01 	strb.w	r2, [r4], #1
        CHECK_STR_SIZE(buf, str, size);
 803b52c:	eba4 020b 	sub.w	r2, r4, fp
 803b530:	428a      	cmp	r2, r1
 803b532:	f280 8084 	bge.w	803b63e <tiny_vsnprintf_like+0x1a2>
 803b536:	e7ce      	b.n	803b4d6 <tiny_vsnprintf_like+0x3a>
  while (is_digit(**s)) i = i*10 + *((*s)++) - '0';
 803b538:	260a      	movs	r6, #10
 803b53a:	fb06 2505 	mla	r5, r6, r5, r2
 803b53e:	3d30      	subs	r5, #48	; 0x30
 803b540:	e7d8      	b.n	803b4f4 <tiny_vsnprintf_like+0x58>
    field_width = -1;
 803b542:	f04f 35ff 	mov.w	r5, #4294967295
 803b546:	e7dd      	b.n	803b504 <tiny_vsnprintf_like+0x68>
    switch (*fmt)
 803b548:	2a75      	cmp	r2, #117	; 0x75
 803b54a:	d078      	beq.n	803b63e <tiny_vsnprintf_like+0x1a2>
 803b54c:	2a78      	cmp	r2, #120	; 0x78
 803b54e:	d041      	beq.n	803b5d4 <tiny_vsnprintf_like+0x138>
 803b550:	2a73      	cmp	r2, #115	; 0x73
 803b552:	d01c      	beq.n	803b58e <tiny_vsnprintf_like+0xf2>
        if (*fmt != '%') *str++ = '%';
 803b554:	2225      	movs	r2, #37	; 0x25
 803b556:	f804 2b01 	strb.w	r2, [r4], #1
        CHECK_STR_SIZE(buf, str, size);
 803b55a:	eba4 020b 	sub.w	r2, r4, fp
 803b55e:	428a      	cmp	r2, r1
 803b560:	da6d      	bge.n	803b63e <tiny_vsnprintf_like+0x1a2>
 803b562:	e7dd      	b.n	803b520 <tiny_vsnprintf_like+0x84>
 803b564:	1e61      	subs	r1, r4, #1
    switch (*fmt)
 803b566:	462a      	mov	r2, r5
          while (--field_width > 0) *str++ = ' ';
 803b568:	3a01      	subs	r2, #1
 803b56a:	2a00      	cmp	r2, #0
 803b56c:	dc0c      	bgt.n	803b588 <tiny_vsnprintf_like+0xec>
 803b56e:	2d00      	cmp	r5, #0
 803b570:	f105 32ff 	add.w	r2, r5, #4294967295
 803b574:	bfd8      	it	le
 803b576:	2200      	movle	r2, #0
 803b578:	4422      	add	r2, r4
        *str++ = (unsigned char) va_arg(args, int);
 803b57a:	f853 1b04 	ldr.w	r1, [r3], #4
 803b57e:	7011      	strb	r1, [r2, #0]
 803b580:	bfd8      	it	le
 803b582:	2501      	movle	r5, #1
 803b584:	442c      	add	r4, r5
        continue;
 803b586:	e7a6      	b.n	803b4d6 <tiny_vsnprintf_like+0x3a>
          while (--field_width > 0) *str++ = ' ';
 803b588:	f801 9f01 	strb.w	r9, [r1, #1]!
 803b58c:	e7ec      	b.n	803b568 <tiny_vsnprintf_like+0xcc>
        s = va_arg(args, char *);
 803b58e:	4698      	mov	r8, r3
        if (!s) s = "<NULL>";
 803b590:	4b4c      	ldr	r3, [pc, #304]	; (803b6c4 <tiny_vsnprintf_like+0x228>)
        s = va_arg(args, char *);
 803b592:	f858 7b04 	ldr.w	r7, [r8], #4
        if (!s) s = "<NULL>";
 803b596:	2f00      	cmp	r7, #0
 803b598:	bf08      	it	eq
 803b59a:	461f      	moveq	r7, r3
        len = strlen(s);
 803b59c:	4638      	mov	r0, r7
 803b59e:	f7ef ff4f 	bl	802b440 <strlen>
          while (len < field_width--) *str++ = ' ';
 803b5a2:	4623      	mov	r3, r4
 803b5a4:	1961      	adds	r1, r4, r5
 803b5a6:	1aca      	subs	r2, r1, r3
 803b5a8:	4290      	cmp	r0, r2
 803b5aa:	db0a      	blt.n	803b5c2 <tiny_vsnprintf_like+0x126>
 803b5ac:	1a2b      	subs	r3, r5, r0
 803b5ae:	4285      	cmp	r5, r0
 803b5b0:	bfb8      	it	lt
 803b5b2:	2300      	movlt	r3, #0
 803b5b4:	441c      	add	r4, r3
        for (i = 0; i < len; ++i) *str++ = *s++;
 803b5b6:	2300      	movs	r3, #0
 803b5b8:	4283      	cmp	r3, r0
 803b5ba:	db05      	blt.n	803b5c8 <tiny_vsnprintf_like+0x12c>
 803b5bc:	4404      	add	r4, r0
        s = va_arg(args, char *);
 803b5be:	4643      	mov	r3, r8
 803b5c0:	e789      	b.n	803b4d6 <tiny_vsnprintf_like+0x3a>
          while (len < field_width--) *str++ = ' ';
 803b5c2:	f803 9b01 	strb.w	r9, [r3], #1
 803b5c6:	e7ee      	b.n	803b5a6 <tiny_vsnprintf_like+0x10a>
        for (i = 0; i < len; ++i) *str++ = *s++;
 803b5c8:	5cfa      	ldrb	r2, [r7, r3]
 803b5ca:	54e2      	strb	r2, [r4, r3]
 803b5cc:	3301      	adds	r3, #1
 803b5ce:	e7f3      	b.n	803b5b8 <tiny_vsnprintf_like+0x11c>
        flags |= UPPERCASE;
 803b5d0:	f040 0040 	orr.w	r0, r0, #64	; 0x40
    switch (*fmt)
 803b5d4:	2710      	movs	r7, #16
    str = ee_number(str, ((size - 1) - (str - buf)), num, base, field_width, precision, flags);
 803b5d6:	eba4 020b 	sub.w	r2, r4, fp
 803b5da:	9302      	str	r3, [sp, #8]
 803b5dc:	1a8b      	subs	r3, r1, r2
 803b5de:	9301      	str	r3, [sp, #4]
 803b5e0:	9b02      	ldr	r3, [sp, #8]
  char *dig = lower_digits;
 803b5e2:	4a39      	ldr	r2, [pc, #228]	; (803b6c8 <tiny_vsnprintf_like+0x22c>)
    str = ee_number(str, ((size - 1) - (str - buf)), num, base, field_width, precision, flags);
 803b5e4:	f853 1b04 	ldr.w	r1, [r3], #4
 803b5e8:	9302      	str	r3, [sp, #8]
  char *dig = lower_digits;
 803b5ea:	f010 0f40 	tst.w	r0, #64	; 0x40
 803b5ee:	4b37      	ldr	r3, [pc, #220]	; (803b6cc <tiny_vsnprintf_like+0x230>)
 803b5f0:	bf08      	it	eq
 803b5f2:	4613      	moveq	r3, r2
  c = (type & ZEROPAD) ? '0' : ' ';
 803b5f4:	f1be 0f30 	cmp.w	lr, #48	; 0x30
  char *dig = lower_digits;
 803b5f8:	9303      	str	r3, [sp, #12]
  c = (type & ZEROPAD) ? '0' : ' ';
 803b5fa:	bf0c      	ite	eq
 803b5fc:	2330      	moveq	r3, #48	; 0x30
 803b5fe:	2320      	movne	r3, #32
 803b600:	9304      	str	r3, [sp, #16]
  if (type & SIGN)
 803b602:	0783      	lsls	r3, r0, #30
 803b604:	d51f      	bpl.n	803b646 <tiny_vsnprintf_like+0x1aa>
    if (num < 0)
 803b606:	2900      	cmp	r1, #0
 803b608:	da1d      	bge.n	803b646 <tiny_vsnprintf_like+0x1aa>
      num = -num;
 803b60a:	4249      	negs	r1, r1
      size--;
 803b60c:	3d01      	subs	r5, #1
      sign = '-';
 803b60e:	f04f 0c2d 	mov.w	ip, #45	; 0x2d
    while (num != 0)
 803b612:	ab07      	add	r3, sp, #28
 803b614:	461a      	mov	r2, r3
  i = 0;
 803b616:	2000      	movs	r0, #0
      tmp[i++] = dig[((unsigned long) num) % (unsigned) base];
 803b618:	4688      	mov	r8, r1
 803b61a:	9b03      	ldr	r3, [sp, #12]
 803b61c:	fbb1 f1f7 	udiv	r1, r1, r7
 803b620:	fb07 8a11 	mls	sl, r7, r1, r8
    while (num != 0)
 803b624:	4547      	cmp	r7, r8
      tmp[i++] = dig[((unsigned long) num) % (unsigned) base];
 803b626:	f813 a00a 	ldrb.w	sl, [r3, sl]
 803b62a:	4613      	mov	r3, r2
 803b62c:	f100 0001 	add.w	r0, r0, #1
 803b630:	f803 ab01 	strb.w	sl, [r3], #1
 803b634:	461a      	mov	r2, r3
    while (num != 0)
 803b636:	d9ef      	bls.n	803b618 <tiny_vsnprintf_like+0x17c>
 803b638:	e00e      	b.n	803b658 <tiny_vsnprintf_like+0x1bc>
        flags |= SIGN;
 803b63a:	f040 0002 	orr.w	r0, r0, #2
    base = 10;
 803b63e:	270a      	movs	r7, #10
 803b640:	e7c9      	b.n	803b5d6 <tiny_vsnprintf_like+0x13a>
          --fmt;
 803b642:	3e01      	subs	r6, #1
        CHECK_STR_SIZE(buf, str, size);
 803b644:	e747      	b.n	803b4d6 <tiny_vsnprintf_like+0x3a>
  if (num == 0)
 803b646:	b111      	cbz	r1, 803b64e <tiny_vsnprintf_like+0x1b2>
 803b648:	f04f 0c00 	mov.w	ip, #0
 803b64c:	e7e1      	b.n	803b612 <tiny_vsnprintf_like+0x176>
    tmp[i++] = '0';
 803b64e:	2030      	movs	r0, #48	; 0x30
 803b650:	f88d 001c 	strb.w	r0, [sp, #28]
 803b654:	468c      	mov	ip, r1
 803b656:	2001      	movs	r0, #1
  if (!(type & (ZEROPAD /* TINY option   | LEFT */))) while (size-- > 0) ASSIGN_STR(' ');
 803b658:	f1be 0f30 	cmp.w	lr, #48	; 0x30
  size -= precision;
 803b65c:	eba5 0500 	sub.w	r5, r5, r0
  if (!(type & (ZEROPAD /* TINY option   | LEFT */))) while (size-- > 0) ASSIGN_STR(' ');
 803b660:	d110      	bne.n	803b684 <tiny_vsnprintf_like+0x1e8>
  if (sign) ASSIGN_STR(sign);
 803b662:	f1bc 0f00 	cmp.w	ip, #0
 803b666:	d028      	beq.n	803b6ba <tiny_vsnprintf_like+0x21e>
 803b668:	9b01      	ldr	r3, [sp, #4]
 803b66a:	f804 cb01 	strb.w	ip, [r4], #1
 803b66e:	3b01      	subs	r3, #1
 803b670:	9301      	str	r3, [sp, #4]
 803b672:	d122      	bne.n	803b6ba <tiny_vsnprintf_like+0x21e>
 803b674:	9b02      	ldr	r3, [sp, #8]
 803b676:	e72e      	b.n	803b4d6 <tiny_vsnprintf_like+0x3a>
  if (!(type & (ZEROPAD /* TINY option   | LEFT */))) while (size-- > 0) ASSIGN_STR(' ');
 803b678:	9b01      	ldr	r3, [sp, #4]
 803b67a:	f804 9b01 	strb.w	r9, [r4], #1
 803b67e:	3b01      	subs	r3, #1
 803b680:	9301      	str	r3, [sp, #4]
 803b682:	d0f7      	beq.n	803b674 <tiny_vsnprintf_like+0x1d8>
 803b684:	2d00      	cmp	r5, #0
 803b686:	f105 35ff 	add.w	r5, r5, #4294967295
 803b68a:	dcf5      	bgt.n	803b678 <tiny_vsnprintf_like+0x1dc>
 803b68c:	e7e9      	b.n	803b662 <tiny_vsnprintf_like+0x1c6>
  while (size-- > 0) ASSIGN_STR(c);
 803b68e:	9b04      	ldr	r3, [sp, #16]
 803b690:	f804 3b01 	strb.w	r3, [r4], #1
 803b694:	9b01      	ldr	r3, [sp, #4]
 803b696:	3b01      	subs	r3, #1
 803b698:	9301      	str	r3, [sp, #4]
 803b69a:	d0eb      	beq.n	803b674 <tiny_vsnprintf_like+0x1d8>
 803b69c:	1b29      	subs	r1, r5, r4
 803b69e:	2900      	cmp	r1, #0
 803b6a0:	dcf5      	bgt.n	803b68e <tiny_vsnprintf_like+0x1f2>
  while (i-- > 0) ASSIGN_STR(tmp[i]);
 803b6a2:	9b01      	ldr	r3, [sp, #4]
 803b6a4:	4423      	add	r3, r4
 803b6a6:	461a      	mov	r2, r3
 803b6a8:	3801      	subs	r0, #1
 803b6aa:	d3e3      	bcc.n	803b674 <tiny_vsnprintf_like+0x1d8>
 803b6ac:	ab07      	add	r3, sp, #28
 803b6ae:	5c19      	ldrb	r1, [r3, r0]
 803b6b0:	f804 1b01 	strb.w	r1, [r4], #1
 803b6b4:	4294      	cmp	r4, r2
 803b6b6:	d1f7      	bne.n	803b6a8 <tiny_vsnprintf_like+0x20c>
 803b6b8:	e7dc      	b.n	803b674 <tiny_vsnprintf_like+0x1d8>
 803b6ba:	4425      	add	r5, r4
 803b6bc:	e7ee      	b.n	803b69c <tiny_vsnprintf_like+0x200>
    return 0;
 803b6be:	2000      	movs	r0, #0
 803b6c0:	e6ff      	b.n	803b4c2 <tiny_vsnprintf_like+0x26>
 803b6c2:	bf00      	nop
 803b6c4:	0803c50c 	.word	0x0803c50c
 803b6c8:	0803c538 	.word	0x0803c538
 803b6cc:	0803c513 	.word	0x0803c513

0803b6d0 <__libc_init_array>:
 803b6d0:	b570      	push	{r4, r5, r6, lr}
 803b6d2:	4d0d      	ldr	r5, [pc, #52]	; (803b708 <__libc_init_array+0x38>)
 803b6d4:	4c0d      	ldr	r4, [pc, #52]	; (803b70c <__libc_init_array+0x3c>)
 803b6d6:	1b64      	subs	r4, r4, r5
 803b6d8:	10a4      	asrs	r4, r4, #2
 803b6da:	2600      	movs	r6, #0
 803b6dc:	42a6      	cmp	r6, r4
 803b6de:	d109      	bne.n	803b6f4 <__libc_init_array+0x24>
 803b6e0:	4d0b      	ldr	r5, [pc, #44]	; (803b710 <__libc_init_array+0x40>)
 803b6e2:	4c0c      	ldr	r4, [pc, #48]	; (803b714 <__libc_init_array+0x44>)
 803b6e4:	f000 f8a0 	bl	803b828 <_init>
 803b6e8:	1b64      	subs	r4, r4, r5
 803b6ea:	10a4      	asrs	r4, r4, #2
 803b6ec:	2600      	movs	r6, #0
 803b6ee:	42a6      	cmp	r6, r4
 803b6f0:	d105      	bne.n	803b6fe <__libc_init_array+0x2e>
 803b6f2:	bd70      	pop	{r4, r5, r6, pc}
 803b6f4:	f855 3b04 	ldr.w	r3, [r5], #4
 803b6f8:	4798      	blx	r3
 803b6fa:	3601      	adds	r6, #1
 803b6fc:	e7ee      	b.n	803b6dc <__libc_init_array+0xc>
 803b6fe:	f855 3b04 	ldr.w	r3, [r5], #4
 803b702:	4798      	blx	r3
 803b704:	3601      	adds	r6, #1
 803b706:	e7f2      	b.n	803b6ee <__libc_init_array+0x1e>
 803b708:	0803c568 	.word	0x0803c568
 803b70c:	0803c568 	.word	0x0803c568
 803b710:	0803c568 	.word	0x0803c568
 803b714:	0803c56c 	.word	0x0803c56c

0803b718 <memset>:
 803b718:	4402      	add	r2, r0
 803b71a:	4603      	mov	r3, r0
 803b71c:	4293      	cmp	r3, r2
 803b71e:	d100      	bne.n	803b722 <memset+0xa>
 803b720:	4770      	bx	lr
 803b722:	f803 1b01 	strb.w	r1, [r3], #1
 803b726:	e7f9      	b.n	803b71c <memset+0x4>

0803b728 <floor>:
 803b728:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 803b72c:	f3c1 580a 	ubfx	r8, r1, #20, #11
 803b730:	f2a8 36ff 	subw	r6, r8, #1023	; 0x3ff
 803b734:	2e13      	cmp	r6, #19
 803b736:	4602      	mov	r2, r0
 803b738:	460b      	mov	r3, r1
 803b73a:	4607      	mov	r7, r0
 803b73c:	460c      	mov	r4, r1
 803b73e:	4605      	mov	r5, r0
 803b740:	dc34      	bgt.n	803b7ac <floor+0x84>
 803b742:	2e00      	cmp	r6, #0
 803b744:	da15      	bge.n	803b772 <floor+0x4a>
 803b746:	a334      	add	r3, pc, #208	; (adr r3, 803b818 <floor+0xf0>)
 803b748:	e9d3 2300 	ldrd	r2, r3, [r3]
 803b74c:	f7ef fe86 	bl	802b45c <__adddf3>
 803b750:	2200      	movs	r2, #0
 803b752:	2300      	movs	r3, #0
 803b754:	f7f0 f8b6 	bl	802b8c4 <__aeabi_dcmpgt>
 803b758:	b140      	cbz	r0, 803b76c <floor+0x44>
 803b75a:	2c00      	cmp	r4, #0
 803b75c:	da59      	bge.n	803b812 <floor+0xea>
 803b75e:	f024 4300 	bic.w	r3, r4, #2147483648	; 0x80000000
 803b762:	ea57 0503 	orrs.w	r5, r7, r3
 803b766:	d001      	beq.n	803b76c <floor+0x44>
 803b768:	4c2d      	ldr	r4, [pc, #180]	; (803b820 <floor+0xf8>)
 803b76a:	2500      	movs	r5, #0
 803b76c:	4623      	mov	r3, r4
 803b76e:	462f      	mov	r7, r5
 803b770:	e025      	b.n	803b7be <floor+0x96>
 803b772:	4a2c      	ldr	r2, [pc, #176]	; (803b824 <floor+0xfc>)
 803b774:	fa42 f806 	asr.w	r8, r2, r6
 803b778:	ea01 0208 	and.w	r2, r1, r8
 803b77c:	4302      	orrs	r2, r0
 803b77e:	d01e      	beq.n	803b7be <floor+0x96>
 803b780:	a325      	add	r3, pc, #148	; (adr r3, 803b818 <floor+0xf0>)
 803b782:	e9d3 2300 	ldrd	r2, r3, [r3]
 803b786:	f7ef fe69 	bl	802b45c <__adddf3>
 803b78a:	2200      	movs	r2, #0
 803b78c:	2300      	movs	r3, #0
 803b78e:	f7f0 f899 	bl	802b8c4 <__aeabi_dcmpgt>
 803b792:	2800      	cmp	r0, #0
 803b794:	d0ea      	beq.n	803b76c <floor+0x44>
 803b796:	2c00      	cmp	r4, #0
 803b798:	bfbe      	ittt	lt
 803b79a:	f44f 1380 	movlt.w	r3, #1048576	; 0x100000
 803b79e:	fa43 f606 	asrlt.w	r6, r3, r6
 803b7a2:	19a4      	addlt	r4, r4, r6
 803b7a4:	ea24 0408 	bic.w	r4, r4, r8
 803b7a8:	2500      	movs	r5, #0
 803b7aa:	e7df      	b.n	803b76c <floor+0x44>
 803b7ac:	2e33      	cmp	r6, #51	; 0x33
 803b7ae:	dd0a      	ble.n	803b7c6 <floor+0x9e>
 803b7b0:	f5b6 6f80 	cmp.w	r6, #1024	; 0x400
 803b7b4:	d103      	bne.n	803b7be <floor+0x96>
 803b7b6:	f7ef fe51 	bl	802b45c <__adddf3>
 803b7ba:	4607      	mov	r7, r0
 803b7bc:	460b      	mov	r3, r1
 803b7be:	4638      	mov	r0, r7
 803b7c0:	4619      	mov	r1, r3
 803b7c2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 803b7c6:	f2a8 4813 	subw	r8, r8, #1043	; 0x413
 803b7ca:	f04f 32ff 	mov.w	r2, #4294967295
 803b7ce:	fa22 f808 	lsr.w	r8, r2, r8
 803b7d2:	ea18 0f00 	tst.w	r8, r0
 803b7d6:	d0f2      	beq.n	803b7be <floor+0x96>
 803b7d8:	a30f      	add	r3, pc, #60	; (adr r3, 803b818 <floor+0xf0>)
 803b7da:	e9d3 2300 	ldrd	r2, r3, [r3]
 803b7de:	f7ef fe3d 	bl	802b45c <__adddf3>
 803b7e2:	2200      	movs	r2, #0
 803b7e4:	2300      	movs	r3, #0
 803b7e6:	f7f0 f86d 	bl	802b8c4 <__aeabi_dcmpgt>
 803b7ea:	2800      	cmp	r0, #0
 803b7ec:	d0be      	beq.n	803b76c <floor+0x44>
 803b7ee:	2c00      	cmp	r4, #0
 803b7f0:	da02      	bge.n	803b7f8 <floor+0xd0>
 803b7f2:	2e14      	cmp	r6, #20
 803b7f4:	d103      	bne.n	803b7fe <floor+0xd6>
 803b7f6:	3401      	adds	r4, #1
 803b7f8:	ea25 0508 	bic.w	r5, r5, r8
 803b7fc:	e7b6      	b.n	803b76c <floor+0x44>
 803b7fe:	2301      	movs	r3, #1
 803b800:	f1c6 0634 	rsb	r6, r6, #52	; 0x34
 803b804:	fa03 f606 	lsl.w	r6, r3, r6
 803b808:	4435      	add	r5, r6
 803b80a:	42bd      	cmp	r5, r7
 803b80c:	bf38      	it	cc
 803b80e:	18e4      	addcc	r4, r4, r3
 803b810:	e7f2      	b.n	803b7f8 <floor+0xd0>
 803b812:	2500      	movs	r5, #0
 803b814:	462c      	mov	r4, r5
 803b816:	e7a9      	b.n	803b76c <floor+0x44>
 803b818:	8800759c 	.word	0x8800759c
 803b81c:	7e37e43c 	.word	0x7e37e43c
 803b820:	bff00000 	.word	0xbff00000
 803b824:	000fffff 	.word	0x000fffff

0803b828 <_init>:
 803b828:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 803b82a:	bf00      	nop
 803b82c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 803b82e:	bc08      	pop	{r3}
 803b830:	469e      	mov	lr, r3
 803b832:	4770      	bx	lr

0803b834 <_fini>:
 803b834:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 803b836:	bf00      	nop
 803b838:	bcf8      	pop	{r3, r4, r5, r6, r7}
 803b83a:	bc08      	pop	{r3}
 803b83c:	469e      	mov	lr, r3
 803b83e:	4770      	bx	lr
