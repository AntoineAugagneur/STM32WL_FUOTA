
LoRaWAN_End_Node.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000200  0802b200  0802b200  000000f4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000104b0  0802b400  0802b400  000002f8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000d60  0803b8b0  0803b8b0  000107a8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0803c610  0803c610  000116c8  2**0
                  CONTENTS
  4 .ARM          00000008  0803c610  0803c610  00011508  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  0803c618  0803c618  000116c8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  0803c618  0803c618  00011510  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  0803c61c  0803c61c  00011514  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         000001ac  20003400  0803c620  00011518  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .align16      00000004  0803c7cc  0803c7cc  000116c4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 10 .bss          00002e00  200035ac  200035ac  000116c8  2**2
                  ALLOC
 11 ._user_heap_stack 00000a04  200063ac  200063ac  000116c8  2**0
                  ALLOC
 12 .ARM.attributes 0000002a  00000000  00000000  000116c8  2**0
                  CONTENTS, READONLY
 13 .debug_info   00082a2a  00000000  00000000  000116f2  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 00010795  00000000  00000000  0009411c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_loc    00024951  00000000  00000000  000a48b1  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_aranges 000028d8  00000000  00000000  000c9208  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_ranges 00004a88  00000000  00000000  000cbae0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_macro  0002f3fc  00000000  00000000  000d0568  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_line   000524f1  00000000  00000000  000ff964  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_str    000e6679  00000000  00000000  00151e55  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .comment      00000053  00000000  00000000  002384ce  2**0
                  CONTENTS, READONLY
 22 .debug_frame  000072c4  00000000  00000000  00238524  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

0802b400 <__do_global_dtors_aux>:
 802b400:	b510      	push	{r4, lr}
 802b402:	4c05      	ldr	r4, [pc, #20]	; (802b418 <__do_global_dtors_aux+0x18>)
 802b404:	7823      	ldrb	r3, [r4, #0]
 802b406:	b933      	cbnz	r3, 802b416 <__do_global_dtors_aux+0x16>
 802b408:	4b04      	ldr	r3, [pc, #16]	; (802b41c <__do_global_dtors_aux+0x1c>)
 802b40a:	b113      	cbz	r3, 802b412 <__do_global_dtors_aux+0x12>
 802b40c:	4804      	ldr	r0, [pc, #16]	; (802b420 <__do_global_dtors_aux+0x20>)
 802b40e:	f3af 8000 	nop.w
 802b412:	2301      	movs	r3, #1
 802b414:	7023      	strb	r3, [r4, #0]
 802b416:	bd10      	pop	{r4, pc}
 802b418:	200035ac 	.word	0x200035ac
 802b41c:	00000000 	.word	0x00000000
 802b420:	0803b898 	.word	0x0803b898

0802b424 <frame_dummy>:
 802b424:	b508      	push	{r3, lr}
 802b426:	4b03      	ldr	r3, [pc, #12]	; (802b434 <frame_dummy+0x10>)
 802b428:	b11b      	cbz	r3, 802b432 <frame_dummy+0xe>
 802b42a:	4903      	ldr	r1, [pc, #12]	; (802b438 <frame_dummy+0x14>)
 802b42c:	4803      	ldr	r0, [pc, #12]	; (802b43c <frame_dummy+0x18>)
 802b42e:	f3af 8000 	nop.w
 802b432:	bd08      	pop	{r3, pc}
 802b434:	00000000 	.word	0x00000000
 802b438:	200035b0 	.word	0x200035b0
 802b43c:	0803b898 	.word	0x0803b898

0802b440 <strlen>:
 802b440:	4603      	mov	r3, r0
 802b442:	f813 2b01 	ldrb.w	r2, [r3], #1
 802b446:	2a00      	cmp	r2, #0
 802b448:	d1fb      	bne.n	802b442 <strlen+0x2>
 802b44a:	1a18      	subs	r0, r3, r0
 802b44c:	3801      	subs	r0, #1
 802b44e:	4770      	bx	lr

0802b450 <__aeabi_drsub>:
 802b450:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 802b454:	e002      	b.n	802b45c <__adddf3>
 802b456:	bf00      	nop

0802b458 <__aeabi_dsub>:
 802b458:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0802b45c <__adddf3>:
 802b45c:	b530      	push	{r4, r5, lr}
 802b45e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 802b462:	ea4f 0543 	mov.w	r5, r3, lsl #1
 802b466:	ea94 0f05 	teq	r4, r5
 802b46a:	bf08      	it	eq
 802b46c:	ea90 0f02 	teqeq	r0, r2
 802b470:	bf1f      	itttt	ne
 802b472:	ea54 0c00 	orrsne.w	ip, r4, r0
 802b476:	ea55 0c02 	orrsne.w	ip, r5, r2
 802b47a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 802b47e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 802b482:	f000 80e2 	beq.w	802b64a <__adddf3+0x1ee>
 802b486:	ea4f 5454 	mov.w	r4, r4, lsr #21
 802b48a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 802b48e:	bfb8      	it	lt
 802b490:	426d      	neglt	r5, r5
 802b492:	dd0c      	ble.n	802b4ae <__adddf3+0x52>
 802b494:	442c      	add	r4, r5
 802b496:	ea80 0202 	eor.w	r2, r0, r2
 802b49a:	ea81 0303 	eor.w	r3, r1, r3
 802b49e:	ea82 0000 	eor.w	r0, r2, r0
 802b4a2:	ea83 0101 	eor.w	r1, r3, r1
 802b4a6:	ea80 0202 	eor.w	r2, r0, r2
 802b4aa:	ea81 0303 	eor.w	r3, r1, r3
 802b4ae:	2d36      	cmp	r5, #54	; 0x36
 802b4b0:	bf88      	it	hi
 802b4b2:	bd30      	pophi	{r4, r5, pc}
 802b4b4:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 802b4b8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 802b4bc:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 802b4c0:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 802b4c4:	d002      	beq.n	802b4cc <__adddf3+0x70>
 802b4c6:	4240      	negs	r0, r0
 802b4c8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 802b4cc:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 802b4d0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 802b4d4:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 802b4d8:	d002      	beq.n	802b4e0 <__adddf3+0x84>
 802b4da:	4252      	negs	r2, r2
 802b4dc:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 802b4e0:	ea94 0f05 	teq	r4, r5
 802b4e4:	f000 80a7 	beq.w	802b636 <__adddf3+0x1da>
 802b4e8:	f1a4 0401 	sub.w	r4, r4, #1
 802b4ec:	f1d5 0e20 	rsbs	lr, r5, #32
 802b4f0:	db0d      	blt.n	802b50e <__adddf3+0xb2>
 802b4f2:	fa02 fc0e 	lsl.w	ip, r2, lr
 802b4f6:	fa22 f205 	lsr.w	r2, r2, r5
 802b4fa:	1880      	adds	r0, r0, r2
 802b4fc:	f141 0100 	adc.w	r1, r1, #0
 802b500:	fa03 f20e 	lsl.w	r2, r3, lr
 802b504:	1880      	adds	r0, r0, r2
 802b506:	fa43 f305 	asr.w	r3, r3, r5
 802b50a:	4159      	adcs	r1, r3
 802b50c:	e00e      	b.n	802b52c <__adddf3+0xd0>
 802b50e:	f1a5 0520 	sub.w	r5, r5, #32
 802b512:	f10e 0e20 	add.w	lr, lr, #32
 802b516:	2a01      	cmp	r2, #1
 802b518:	fa03 fc0e 	lsl.w	ip, r3, lr
 802b51c:	bf28      	it	cs
 802b51e:	f04c 0c02 	orrcs.w	ip, ip, #2
 802b522:	fa43 f305 	asr.w	r3, r3, r5
 802b526:	18c0      	adds	r0, r0, r3
 802b528:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 802b52c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 802b530:	d507      	bpl.n	802b542 <__adddf3+0xe6>
 802b532:	f04f 0e00 	mov.w	lr, #0
 802b536:	f1dc 0c00 	rsbs	ip, ip, #0
 802b53a:	eb7e 0000 	sbcs.w	r0, lr, r0
 802b53e:	eb6e 0101 	sbc.w	r1, lr, r1
 802b542:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 802b546:	d31b      	bcc.n	802b580 <__adddf3+0x124>
 802b548:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 802b54c:	d30c      	bcc.n	802b568 <__adddf3+0x10c>
 802b54e:	0849      	lsrs	r1, r1, #1
 802b550:	ea5f 0030 	movs.w	r0, r0, rrx
 802b554:	ea4f 0c3c 	mov.w	ip, ip, rrx
 802b558:	f104 0401 	add.w	r4, r4, #1
 802b55c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 802b560:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 802b564:	f080 809a 	bcs.w	802b69c <__adddf3+0x240>
 802b568:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 802b56c:	bf08      	it	eq
 802b56e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 802b572:	f150 0000 	adcs.w	r0, r0, #0
 802b576:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 802b57a:	ea41 0105 	orr.w	r1, r1, r5
 802b57e:	bd30      	pop	{r4, r5, pc}
 802b580:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 802b584:	4140      	adcs	r0, r0
 802b586:	eb41 0101 	adc.w	r1, r1, r1
 802b58a:	3c01      	subs	r4, #1
 802b58c:	bf28      	it	cs
 802b58e:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
 802b592:	d2e9      	bcs.n	802b568 <__adddf3+0x10c>
 802b594:	f091 0f00 	teq	r1, #0
 802b598:	bf04      	itt	eq
 802b59a:	4601      	moveq	r1, r0
 802b59c:	2000      	moveq	r0, #0
 802b59e:	fab1 f381 	clz	r3, r1
 802b5a2:	bf08      	it	eq
 802b5a4:	3320      	addeq	r3, #32
 802b5a6:	f1a3 030b 	sub.w	r3, r3, #11
 802b5aa:	f1b3 0220 	subs.w	r2, r3, #32
 802b5ae:	da0c      	bge.n	802b5ca <__adddf3+0x16e>
 802b5b0:	320c      	adds	r2, #12
 802b5b2:	dd08      	ble.n	802b5c6 <__adddf3+0x16a>
 802b5b4:	f102 0c14 	add.w	ip, r2, #20
 802b5b8:	f1c2 020c 	rsb	r2, r2, #12
 802b5bc:	fa01 f00c 	lsl.w	r0, r1, ip
 802b5c0:	fa21 f102 	lsr.w	r1, r1, r2
 802b5c4:	e00c      	b.n	802b5e0 <__adddf3+0x184>
 802b5c6:	f102 0214 	add.w	r2, r2, #20
 802b5ca:	bfd8      	it	le
 802b5cc:	f1c2 0c20 	rsble	ip, r2, #32
 802b5d0:	fa01 f102 	lsl.w	r1, r1, r2
 802b5d4:	fa20 fc0c 	lsr.w	ip, r0, ip
 802b5d8:	bfdc      	itt	le
 802b5da:	ea41 010c 	orrle.w	r1, r1, ip
 802b5de:	4090      	lslle	r0, r2
 802b5e0:	1ae4      	subs	r4, r4, r3
 802b5e2:	bfa2      	ittt	ge
 802b5e4:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 802b5e8:	4329      	orrge	r1, r5
 802b5ea:	bd30      	popge	{r4, r5, pc}
 802b5ec:	ea6f 0404 	mvn.w	r4, r4
 802b5f0:	3c1f      	subs	r4, #31
 802b5f2:	da1c      	bge.n	802b62e <__adddf3+0x1d2>
 802b5f4:	340c      	adds	r4, #12
 802b5f6:	dc0e      	bgt.n	802b616 <__adddf3+0x1ba>
 802b5f8:	f104 0414 	add.w	r4, r4, #20
 802b5fc:	f1c4 0220 	rsb	r2, r4, #32
 802b600:	fa20 f004 	lsr.w	r0, r0, r4
 802b604:	fa01 f302 	lsl.w	r3, r1, r2
 802b608:	ea40 0003 	orr.w	r0, r0, r3
 802b60c:	fa21 f304 	lsr.w	r3, r1, r4
 802b610:	ea45 0103 	orr.w	r1, r5, r3
 802b614:	bd30      	pop	{r4, r5, pc}
 802b616:	f1c4 040c 	rsb	r4, r4, #12
 802b61a:	f1c4 0220 	rsb	r2, r4, #32
 802b61e:	fa20 f002 	lsr.w	r0, r0, r2
 802b622:	fa01 f304 	lsl.w	r3, r1, r4
 802b626:	ea40 0003 	orr.w	r0, r0, r3
 802b62a:	4629      	mov	r1, r5
 802b62c:	bd30      	pop	{r4, r5, pc}
 802b62e:	fa21 f004 	lsr.w	r0, r1, r4
 802b632:	4629      	mov	r1, r5
 802b634:	bd30      	pop	{r4, r5, pc}
 802b636:	f094 0f00 	teq	r4, #0
 802b63a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 802b63e:	bf06      	itte	eq
 802b640:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 802b644:	3401      	addeq	r4, #1
 802b646:	3d01      	subne	r5, #1
 802b648:	e74e      	b.n	802b4e8 <__adddf3+0x8c>
 802b64a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 802b64e:	bf18      	it	ne
 802b650:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 802b654:	d029      	beq.n	802b6aa <__adddf3+0x24e>
 802b656:	ea94 0f05 	teq	r4, r5
 802b65a:	bf08      	it	eq
 802b65c:	ea90 0f02 	teqeq	r0, r2
 802b660:	d005      	beq.n	802b66e <__adddf3+0x212>
 802b662:	ea54 0c00 	orrs.w	ip, r4, r0
 802b666:	bf04      	itt	eq
 802b668:	4619      	moveq	r1, r3
 802b66a:	4610      	moveq	r0, r2
 802b66c:	bd30      	pop	{r4, r5, pc}
 802b66e:	ea91 0f03 	teq	r1, r3
 802b672:	bf1e      	ittt	ne
 802b674:	2100      	movne	r1, #0
 802b676:	2000      	movne	r0, #0
 802b678:	bd30      	popne	{r4, r5, pc}
 802b67a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 802b67e:	d105      	bne.n	802b68c <__adddf3+0x230>
 802b680:	0040      	lsls	r0, r0, #1
 802b682:	4149      	adcs	r1, r1
 802b684:	bf28      	it	cs
 802b686:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 802b68a:	bd30      	pop	{r4, r5, pc}
 802b68c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 802b690:	bf3c      	itt	cc
 802b692:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 802b696:	bd30      	popcc	{r4, r5, pc}
 802b698:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 802b69c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 802b6a0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 802b6a4:	f04f 0000 	mov.w	r0, #0
 802b6a8:	bd30      	pop	{r4, r5, pc}
 802b6aa:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 802b6ae:	bf1a      	itte	ne
 802b6b0:	4619      	movne	r1, r3
 802b6b2:	4610      	movne	r0, r2
 802b6b4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 802b6b8:	bf1c      	itt	ne
 802b6ba:	460b      	movne	r3, r1
 802b6bc:	4602      	movne	r2, r0
 802b6be:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 802b6c2:	bf06      	itte	eq
 802b6c4:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 802b6c8:	ea91 0f03 	teqeq	r1, r3
 802b6cc:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 802b6d0:	bd30      	pop	{r4, r5, pc}
 802b6d2:	bf00      	nop

0802b6d4 <__aeabi_ui2d>:
 802b6d4:	f090 0f00 	teq	r0, #0
 802b6d8:	bf04      	itt	eq
 802b6da:	2100      	moveq	r1, #0
 802b6dc:	4770      	bxeq	lr
 802b6de:	b530      	push	{r4, r5, lr}
 802b6e0:	f44f 6480 	mov.w	r4, #1024	; 0x400
 802b6e4:	f104 0432 	add.w	r4, r4, #50	; 0x32
 802b6e8:	f04f 0500 	mov.w	r5, #0
 802b6ec:	f04f 0100 	mov.w	r1, #0
 802b6f0:	e750      	b.n	802b594 <__adddf3+0x138>
 802b6f2:	bf00      	nop

0802b6f4 <__aeabi_i2d>:
 802b6f4:	f090 0f00 	teq	r0, #0
 802b6f8:	bf04      	itt	eq
 802b6fa:	2100      	moveq	r1, #0
 802b6fc:	4770      	bxeq	lr
 802b6fe:	b530      	push	{r4, r5, lr}
 802b700:	f44f 6480 	mov.w	r4, #1024	; 0x400
 802b704:	f104 0432 	add.w	r4, r4, #50	; 0x32
 802b708:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 802b70c:	bf48      	it	mi
 802b70e:	4240      	negmi	r0, r0
 802b710:	f04f 0100 	mov.w	r1, #0
 802b714:	e73e      	b.n	802b594 <__adddf3+0x138>
 802b716:	bf00      	nop

0802b718 <__aeabi_f2d>:
 802b718:	0042      	lsls	r2, r0, #1
 802b71a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 802b71e:	ea4f 0131 	mov.w	r1, r1, rrx
 802b722:	ea4f 7002 	mov.w	r0, r2, lsl #28
 802b726:	bf1f      	itttt	ne
 802b728:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 802b72c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 802b730:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 802b734:	4770      	bxne	lr
 802b736:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 802b73a:	bf08      	it	eq
 802b73c:	4770      	bxeq	lr
 802b73e:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 802b742:	bf04      	itt	eq
 802b744:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 802b748:	4770      	bxeq	lr
 802b74a:	b530      	push	{r4, r5, lr}
 802b74c:	f44f 7460 	mov.w	r4, #896	; 0x380
 802b750:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 802b754:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 802b758:	e71c      	b.n	802b594 <__adddf3+0x138>
 802b75a:	bf00      	nop

0802b75c <__aeabi_ul2d>:
 802b75c:	ea50 0201 	orrs.w	r2, r0, r1
 802b760:	bf08      	it	eq
 802b762:	4770      	bxeq	lr
 802b764:	b530      	push	{r4, r5, lr}
 802b766:	f04f 0500 	mov.w	r5, #0
 802b76a:	e00a      	b.n	802b782 <__aeabi_l2d+0x16>

0802b76c <__aeabi_l2d>:
 802b76c:	ea50 0201 	orrs.w	r2, r0, r1
 802b770:	bf08      	it	eq
 802b772:	4770      	bxeq	lr
 802b774:	b530      	push	{r4, r5, lr}
 802b776:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 802b77a:	d502      	bpl.n	802b782 <__aeabi_l2d+0x16>
 802b77c:	4240      	negs	r0, r0
 802b77e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 802b782:	f44f 6480 	mov.w	r4, #1024	; 0x400
 802b786:	f104 0432 	add.w	r4, r4, #50	; 0x32
 802b78a:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 802b78e:	f43f aed8 	beq.w	802b542 <__adddf3+0xe6>
 802b792:	f04f 0203 	mov.w	r2, #3
 802b796:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 802b79a:	bf18      	it	ne
 802b79c:	3203      	addne	r2, #3
 802b79e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 802b7a2:	bf18      	it	ne
 802b7a4:	3203      	addne	r2, #3
 802b7a6:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 802b7aa:	f1c2 0320 	rsb	r3, r2, #32
 802b7ae:	fa00 fc03 	lsl.w	ip, r0, r3
 802b7b2:	fa20 f002 	lsr.w	r0, r0, r2
 802b7b6:	fa01 fe03 	lsl.w	lr, r1, r3
 802b7ba:	ea40 000e 	orr.w	r0, r0, lr
 802b7be:	fa21 f102 	lsr.w	r1, r1, r2
 802b7c2:	4414      	add	r4, r2
 802b7c4:	e6bd      	b.n	802b542 <__adddf3+0xe6>
 802b7c6:	bf00      	nop

0802b7c8 <__gedf2>:
 802b7c8:	f04f 3cff 	mov.w	ip, #4294967295
 802b7cc:	e006      	b.n	802b7dc <__cmpdf2+0x4>
 802b7ce:	bf00      	nop

0802b7d0 <__ledf2>:
 802b7d0:	f04f 0c01 	mov.w	ip, #1
 802b7d4:	e002      	b.n	802b7dc <__cmpdf2+0x4>
 802b7d6:	bf00      	nop

0802b7d8 <__cmpdf2>:
 802b7d8:	f04f 0c01 	mov.w	ip, #1
 802b7dc:	f84d cd04 	str.w	ip, [sp, #-4]!
 802b7e0:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 802b7e4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 802b7e8:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 802b7ec:	bf18      	it	ne
 802b7ee:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 802b7f2:	d01b      	beq.n	802b82c <__cmpdf2+0x54>
 802b7f4:	b001      	add	sp, #4
 802b7f6:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 802b7fa:	bf0c      	ite	eq
 802b7fc:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 802b800:	ea91 0f03 	teqne	r1, r3
 802b804:	bf02      	ittt	eq
 802b806:	ea90 0f02 	teqeq	r0, r2
 802b80a:	2000      	moveq	r0, #0
 802b80c:	4770      	bxeq	lr
 802b80e:	f110 0f00 	cmn.w	r0, #0
 802b812:	ea91 0f03 	teq	r1, r3
 802b816:	bf58      	it	pl
 802b818:	4299      	cmppl	r1, r3
 802b81a:	bf08      	it	eq
 802b81c:	4290      	cmpeq	r0, r2
 802b81e:	bf2c      	ite	cs
 802b820:	17d8      	asrcs	r0, r3, #31
 802b822:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 802b826:	f040 0001 	orr.w	r0, r0, #1
 802b82a:	4770      	bx	lr
 802b82c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 802b830:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 802b834:	d102      	bne.n	802b83c <__cmpdf2+0x64>
 802b836:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 802b83a:	d107      	bne.n	802b84c <__cmpdf2+0x74>
 802b83c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 802b840:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 802b844:	d1d6      	bne.n	802b7f4 <__cmpdf2+0x1c>
 802b846:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 802b84a:	d0d3      	beq.n	802b7f4 <__cmpdf2+0x1c>
 802b84c:	f85d 0b04 	ldr.w	r0, [sp], #4
 802b850:	4770      	bx	lr
 802b852:	bf00      	nop

0802b854 <__aeabi_cdrcmple>:
 802b854:	4684      	mov	ip, r0
 802b856:	4610      	mov	r0, r2
 802b858:	4662      	mov	r2, ip
 802b85a:	468c      	mov	ip, r1
 802b85c:	4619      	mov	r1, r3
 802b85e:	4663      	mov	r3, ip
 802b860:	e000      	b.n	802b864 <__aeabi_cdcmpeq>
 802b862:	bf00      	nop

0802b864 <__aeabi_cdcmpeq>:
 802b864:	b501      	push	{r0, lr}
 802b866:	f7ff ffb7 	bl	802b7d8 <__cmpdf2>
 802b86a:	2800      	cmp	r0, #0
 802b86c:	bf48      	it	mi
 802b86e:	f110 0f00 	cmnmi.w	r0, #0
 802b872:	bd01      	pop	{r0, pc}

0802b874 <__aeabi_dcmpeq>:
 802b874:	f84d ed08 	str.w	lr, [sp, #-8]!
 802b878:	f7ff fff4 	bl	802b864 <__aeabi_cdcmpeq>
 802b87c:	bf0c      	ite	eq
 802b87e:	2001      	moveq	r0, #1
 802b880:	2000      	movne	r0, #0
 802b882:	f85d fb08 	ldr.w	pc, [sp], #8
 802b886:	bf00      	nop

0802b888 <__aeabi_dcmplt>:
 802b888:	f84d ed08 	str.w	lr, [sp, #-8]!
 802b88c:	f7ff ffea 	bl	802b864 <__aeabi_cdcmpeq>
 802b890:	bf34      	ite	cc
 802b892:	2001      	movcc	r0, #1
 802b894:	2000      	movcs	r0, #0
 802b896:	f85d fb08 	ldr.w	pc, [sp], #8
 802b89a:	bf00      	nop

0802b89c <__aeabi_dcmple>:
 802b89c:	f84d ed08 	str.w	lr, [sp, #-8]!
 802b8a0:	f7ff ffe0 	bl	802b864 <__aeabi_cdcmpeq>
 802b8a4:	bf94      	ite	ls
 802b8a6:	2001      	movls	r0, #1
 802b8a8:	2000      	movhi	r0, #0
 802b8aa:	f85d fb08 	ldr.w	pc, [sp], #8
 802b8ae:	bf00      	nop

0802b8b0 <__aeabi_dcmpge>:
 802b8b0:	f84d ed08 	str.w	lr, [sp, #-8]!
 802b8b4:	f7ff ffce 	bl	802b854 <__aeabi_cdrcmple>
 802b8b8:	bf94      	ite	ls
 802b8ba:	2001      	movls	r0, #1
 802b8bc:	2000      	movhi	r0, #0
 802b8be:	f85d fb08 	ldr.w	pc, [sp], #8
 802b8c2:	bf00      	nop

0802b8c4 <__aeabi_dcmpgt>:
 802b8c4:	f84d ed08 	str.w	lr, [sp, #-8]!
 802b8c8:	f7ff ffc4 	bl	802b854 <__aeabi_cdrcmple>
 802b8cc:	bf34      	ite	cc
 802b8ce:	2001      	movcc	r0, #1
 802b8d0:	2000      	movcs	r0, #0
 802b8d2:	f85d fb08 	ldr.w	pc, [sp], #8
 802b8d6:	bf00      	nop

0802b8d8 <__aeabi_d2iz>:
 802b8d8:	ea4f 0241 	mov.w	r2, r1, lsl #1
 802b8dc:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 802b8e0:	d215      	bcs.n	802b90e <__aeabi_d2iz+0x36>
 802b8e2:	d511      	bpl.n	802b908 <__aeabi_d2iz+0x30>
 802b8e4:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 802b8e8:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 802b8ec:	d912      	bls.n	802b914 <__aeabi_d2iz+0x3c>
 802b8ee:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 802b8f2:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 802b8f6:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 802b8fa:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 802b8fe:	fa23 f002 	lsr.w	r0, r3, r2
 802b902:	bf18      	it	ne
 802b904:	4240      	negne	r0, r0
 802b906:	4770      	bx	lr
 802b908:	f04f 0000 	mov.w	r0, #0
 802b90c:	4770      	bx	lr
 802b90e:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 802b912:	d105      	bne.n	802b920 <__aeabi_d2iz+0x48>
 802b914:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 802b918:	bf08      	it	eq
 802b91a:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 802b91e:	4770      	bx	lr
 802b920:	f04f 0000 	mov.w	r0, #0
 802b924:	4770      	bx	lr
 802b926:	bf00      	nop

0802b928 <__aeabi_frsub>:
 802b928:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
 802b92c:	e002      	b.n	802b934 <__addsf3>
 802b92e:	bf00      	nop

0802b930 <__aeabi_fsub>:
 802b930:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

0802b934 <__addsf3>:
 802b934:	0042      	lsls	r2, r0, #1
 802b936:	bf1f      	itttt	ne
 802b938:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 802b93c:	ea92 0f03 	teqne	r2, r3
 802b940:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 802b944:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 802b948:	d06a      	beq.n	802ba20 <__addsf3+0xec>
 802b94a:	ea4f 6212 	mov.w	r2, r2, lsr #24
 802b94e:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 802b952:	bfc1      	itttt	gt
 802b954:	18d2      	addgt	r2, r2, r3
 802b956:	4041      	eorgt	r1, r0
 802b958:	4048      	eorgt	r0, r1
 802b95a:	4041      	eorgt	r1, r0
 802b95c:	bfb8      	it	lt
 802b95e:	425b      	neglt	r3, r3
 802b960:	2b19      	cmp	r3, #25
 802b962:	bf88      	it	hi
 802b964:	4770      	bxhi	lr
 802b966:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 802b96a:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 802b96e:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 802b972:	bf18      	it	ne
 802b974:	4240      	negne	r0, r0
 802b976:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 802b97a:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 802b97e:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 802b982:	bf18      	it	ne
 802b984:	4249      	negne	r1, r1
 802b986:	ea92 0f03 	teq	r2, r3
 802b98a:	d03f      	beq.n	802ba0c <__addsf3+0xd8>
 802b98c:	f1a2 0201 	sub.w	r2, r2, #1
 802b990:	fa41 fc03 	asr.w	ip, r1, r3
 802b994:	eb10 000c 	adds.w	r0, r0, ip
 802b998:	f1c3 0320 	rsb	r3, r3, #32
 802b99c:	fa01 f103 	lsl.w	r1, r1, r3
 802b9a0:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 802b9a4:	d502      	bpl.n	802b9ac <__addsf3+0x78>
 802b9a6:	4249      	negs	r1, r1
 802b9a8:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 802b9ac:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 802b9b0:	d313      	bcc.n	802b9da <__addsf3+0xa6>
 802b9b2:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 802b9b6:	d306      	bcc.n	802b9c6 <__addsf3+0x92>
 802b9b8:	0840      	lsrs	r0, r0, #1
 802b9ba:	ea4f 0131 	mov.w	r1, r1, rrx
 802b9be:	f102 0201 	add.w	r2, r2, #1
 802b9c2:	2afe      	cmp	r2, #254	; 0xfe
 802b9c4:	d251      	bcs.n	802ba6a <__addsf3+0x136>
 802b9c6:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 802b9ca:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 802b9ce:	bf08      	it	eq
 802b9d0:	f020 0001 	biceq.w	r0, r0, #1
 802b9d4:	ea40 0003 	orr.w	r0, r0, r3
 802b9d8:	4770      	bx	lr
 802b9da:	0049      	lsls	r1, r1, #1
 802b9dc:	eb40 0000 	adc.w	r0, r0, r0
 802b9e0:	3a01      	subs	r2, #1
 802b9e2:	bf28      	it	cs
 802b9e4:	f5b0 0f00 	cmpcs.w	r0, #8388608	; 0x800000
 802b9e8:	d2ed      	bcs.n	802b9c6 <__addsf3+0x92>
 802b9ea:	fab0 fc80 	clz	ip, r0
 802b9ee:	f1ac 0c08 	sub.w	ip, ip, #8
 802b9f2:	ebb2 020c 	subs.w	r2, r2, ip
 802b9f6:	fa00 f00c 	lsl.w	r0, r0, ip
 802b9fa:	bfaa      	itet	ge
 802b9fc:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 802ba00:	4252      	neglt	r2, r2
 802ba02:	4318      	orrge	r0, r3
 802ba04:	bfbc      	itt	lt
 802ba06:	40d0      	lsrlt	r0, r2
 802ba08:	4318      	orrlt	r0, r3
 802ba0a:	4770      	bx	lr
 802ba0c:	f092 0f00 	teq	r2, #0
 802ba10:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
 802ba14:	bf06      	itte	eq
 802ba16:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
 802ba1a:	3201      	addeq	r2, #1
 802ba1c:	3b01      	subne	r3, #1
 802ba1e:	e7b5      	b.n	802b98c <__addsf3+0x58>
 802ba20:	ea4f 0341 	mov.w	r3, r1, lsl #1
 802ba24:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 802ba28:	bf18      	it	ne
 802ba2a:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 802ba2e:	d021      	beq.n	802ba74 <__addsf3+0x140>
 802ba30:	ea92 0f03 	teq	r2, r3
 802ba34:	d004      	beq.n	802ba40 <__addsf3+0x10c>
 802ba36:	f092 0f00 	teq	r2, #0
 802ba3a:	bf08      	it	eq
 802ba3c:	4608      	moveq	r0, r1
 802ba3e:	4770      	bx	lr
 802ba40:	ea90 0f01 	teq	r0, r1
 802ba44:	bf1c      	itt	ne
 802ba46:	2000      	movne	r0, #0
 802ba48:	4770      	bxne	lr
 802ba4a:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
 802ba4e:	d104      	bne.n	802ba5a <__addsf3+0x126>
 802ba50:	0040      	lsls	r0, r0, #1
 802ba52:	bf28      	it	cs
 802ba54:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
 802ba58:	4770      	bx	lr
 802ba5a:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 802ba5e:	bf3c      	itt	cc
 802ba60:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
 802ba64:	4770      	bxcc	lr
 802ba66:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 802ba6a:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
 802ba6e:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 802ba72:	4770      	bx	lr
 802ba74:	ea7f 6222 	mvns.w	r2, r2, asr #24
 802ba78:	bf16      	itet	ne
 802ba7a:	4608      	movne	r0, r1
 802ba7c:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 802ba80:	4601      	movne	r1, r0
 802ba82:	0242      	lsls	r2, r0, #9
 802ba84:	bf06      	itte	eq
 802ba86:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 802ba8a:	ea90 0f01 	teqeq	r0, r1
 802ba8e:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
 802ba92:	4770      	bx	lr

0802ba94 <__aeabi_ui2f>:
 802ba94:	f04f 0300 	mov.w	r3, #0
 802ba98:	e004      	b.n	802baa4 <__aeabi_i2f+0x8>
 802ba9a:	bf00      	nop

0802ba9c <__aeabi_i2f>:
 802ba9c:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
 802baa0:	bf48      	it	mi
 802baa2:	4240      	negmi	r0, r0
 802baa4:	ea5f 0c00 	movs.w	ip, r0
 802baa8:	bf08      	it	eq
 802baaa:	4770      	bxeq	lr
 802baac:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
 802bab0:	4601      	mov	r1, r0
 802bab2:	f04f 0000 	mov.w	r0, #0
 802bab6:	e01c      	b.n	802baf2 <__aeabi_l2f+0x2a>

0802bab8 <__aeabi_ul2f>:
 802bab8:	ea50 0201 	orrs.w	r2, r0, r1
 802babc:	bf08      	it	eq
 802babe:	4770      	bxeq	lr
 802bac0:	f04f 0300 	mov.w	r3, #0
 802bac4:	e00a      	b.n	802badc <__aeabi_l2f+0x14>
 802bac6:	bf00      	nop

0802bac8 <__aeabi_l2f>:
 802bac8:	ea50 0201 	orrs.w	r2, r0, r1
 802bacc:	bf08      	it	eq
 802bace:	4770      	bxeq	lr
 802bad0:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
 802bad4:	d502      	bpl.n	802badc <__aeabi_l2f+0x14>
 802bad6:	4240      	negs	r0, r0
 802bad8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 802badc:	ea5f 0c01 	movs.w	ip, r1
 802bae0:	bf02      	ittt	eq
 802bae2:	4684      	moveq	ip, r0
 802bae4:	4601      	moveq	r1, r0
 802bae6:	2000      	moveq	r0, #0
 802bae8:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
 802baec:	bf08      	it	eq
 802baee:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
 802baf2:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 802baf6:	fabc f28c 	clz	r2, ip
 802bafa:	3a08      	subs	r2, #8
 802bafc:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 802bb00:	db10      	blt.n	802bb24 <__aeabi_l2f+0x5c>
 802bb02:	fa01 fc02 	lsl.w	ip, r1, r2
 802bb06:	4463      	add	r3, ip
 802bb08:	fa00 fc02 	lsl.w	ip, r0, r2
 802bb0c:	f1c2 0220 	rsb	r2, r2, #32
 802bb10:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 802bb14:	fa20 f202 	lsr.w	r2, r0, r2
 802bb18:	eb43 0002 	adc.w	r0, r3, r2
 802bb1c:	bf08      	it	eq
 802bb1e:	f020 0001 	biceq.w	r0, r0, #1
 802bb22:	4770      	bx	lr
 802bb24:	f102 0220 	add.w	r2, r2, #32
 802bb28:	fa01 fc02 	lsl.w	ip, r1, r2
 802bb2c:	f1c2 0220 	rsb	r2, r2, #32
 802bb30:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 802bb34:	fa21 f202 	lsr.w	r2, r1, r2
 802bb38:	eb43 0002 	adc.w	r0, r3, r2
 802bb3c:	bf08      	it	eq
 802bb3e:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 802bb42:	4770      	bx	lr

0802bb44 <__aeabi_uldivmod>:
 802bb44:	b953      	cbnz	r3, 802bb5c <__aeabi_uldivmod+0x18>
 802bb46:	b94a      	cbnz	r2, 802bb5c <__aeabi_uldivmod+0x18>
 802bb48:	2900      	cmp	r1, #0
 802bb4a:	bf08      	it	eq
 802bb4c:	2800      	cmpeq	r0, #0
 802bb4e:	bf1c      	itt	ne
 802bb50:	f04f 31ff 	movne.w	r1, #4294967295
 802bb54:	f04f 30ff 	movne.w	r0, #4294967295
 802bb58:	f000 b96c 	b.w	802be34 <__aeabi_idiv0>
 802bb5c:	f1ad 0c08 	sub.w	ip, sp, #8
 802bb60:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 802bb64:	f000 f806 	bl	802bb74 <__udivmoddi4>
 802bb68:	f8dd e004 	ldr.w	lr, [sp, #4]
 802bb6c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 802bb70:	b004      	add	sp, #16
 802bb72:	4770      	bx	lr

0802bb74 <__udivmoddi4>:
 802bb74:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 802bb78:	9e08      	ldr	r6, [sp, #32]
 802bb7a:	460d      	mov	r5, r1
 802bb7c:	4604      	mov	r4, r0
 802bb7e:	468e      	mov	lr, r1
 802bb80:	2b00      	cmp	r3, #0
 802bb82:	f040 8082 	bne.w	802bc8a <__udivmoddi4+0x116>
 802bb86:	428a      	cmp	r2, r1
 802bb88:	4617      	mov	r7, r2
 802bb8a:	d946      	bls.n	802bc1a <__udivmoddi4+0xa6>
 802bb8c:	fab2 f282 	clz	r2, r2
 802bb90:	b14a      	cbz	r2, 802bba6 <__udivmoddi4+0x32>
 802bb92:	f1c2 0120 	rsb	r1, r2, #32
 802bb96:	fa05 f302 	lsl.w	r3, r5, r2
 802bb9a:	fa20 f101 	lsr.w	r1, r0, r1
 802bb9e:	4097      	lsls	r7, r2
 802bba0:	ea41 0e03 	orr.w	lr, r1, r3
 802bba4:	4094      	lsls	r4, r2
 802bba6:	ea4f 4817 	mov.w	r8, r7, lsr #16
 802bbaa:	0c23      	lsrs	r3, r4, #16
 802bbac:	fbbe fcf8 	udiv	ip, lr, r8
 802bbb0:	b2b9      	uxth	r1, r7
 802bbb2:	fb08 ee1c 	mls	lr, r8, ip, lr
 802bbb6:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
 802bbba:	fb0c f001 	mul.w	r0, ip, r1
 802bbbe:	4298      	cmp	r0, r3
 802bbc0:	d90a      	bls.n	802bbd8 <__udivmoddi4+0x64>
 802bbc2:	18fb      	adds	r3, r7, r3
 802bbc4:	f10c 35ff 	add.w	r5, ip, #4294967295
 802bbc8:	f080 8116 	bcs.w	802bdf8 <__udivmoddi4+0x284>
 802bbcc:	4298      	cmp	r0, r3
 802bbce:	f240 8113 	bls.w	802bdf8 <__udivmoddi4+0x284>
 802bbd2:	f1ac 0c02 	sub.w	ip, ip, #2
 802bbd6:	443b      	add	r3, r7
 802bbd8:	1a1b      	subs	r3, r3, r0
 802bbda:	b2a4      	uxth	r4, r4
 802bbdc:	fbb3 f0f8 	udiv	r0, r3, r8
 802bbe0:	fb08 3310 	mls	r3, r8, r0, r3
 802bbe4:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 802bbe8:	fb00 f101 	mul.w	r1, r0, r1
 802bbec:	42a1      	cmp	r1, r4
 802bbee:	d909      	bls.n	802bc04 <__udivmoddi4+0x90>
 802bbf0:	193c      	adds	r4, r7, r4
 802bbf2:	f100 33ff 	add.w	r3, r0, #4294967295
 802bbf6:	f080 8101 	bcs.w	802bdfc <__udivmoddi4+0x288>
 802bbfa:	42a1      	cmp	r1, r4
 802bbfc:	f240 80fe 	bls.w	802bdfc <__udivmoddi4+0x288>
 802bc00:	3802      	subs	r0, #2
 802bc02:	443c      	add	r4, r7
 802bc04:	1a64      	subs	r4, r4, r1
 802bc06:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 802bc0a:	2100      	movs	r1, #0
 802bc0c:	b11e      	cbz	r6, 802bc16 <__udivmoddi4+0xa2>
 802bc0e:	40d4      	lsrs	r4, r2
 802bc10:	2300      	movs	r3, #0
 802bc12:	e9c6 4300 	strd	r4, r3, [r6]
 802bc16:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802bc1a:	b902      	cbnz	r2, 802bc1e <__udivmoddi4+0xaa>
 802bc1c:	deff      	udf	#255	; 0xff
 802bc1e:	fab2 f282 	clz	r2, r2
 802bc22:	2a00      	cmp	r2, #0
 802bc24:	d14f      	bne.n	802bcc6 <__udivmoddi4+0x152>
 802bc26:	1bcb      	subs	r3, r1, r7
 802bc28:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 802bc2c:	fa1f f887 	uxth.w	r8, r7
 802bc30:	2101      	movs	r1, #1
 802bc32:	fbb3 fcfe 	udiv	ip, r3, lr
 802bc36:	0c25      	lsrs	r5, r4, #16
 802bc38:	fb0e 331c 	mls	r3, lr, ip, r3
 802bc3c:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 802bc40:	fb08 f30c 	mul.w	r3, r8, ip
 802bc44:	42ab      	cmp	r3, r5
 802bc46:	d907      	bls.n	802bc58 <__udivmoddi4+0xe4>
 802bc48:	197d      	adds	r5, r7, r5
 802bc4a:	f10c 30ff 	add.w	r0, ip, #4294967295
 802bc4e:	d202      	bcs.n	802bc56 <__udivmoddi4+0xe2>
 802bc50:	42ab      	cmp	r3, r5
 802bc52:	f200 80e7 	bhi.w	802be24 <__udivmoddi4+0x2b0>
 802bc56:	4684      	mov	ip, r0
 802bc58:	1aed      	subs	r5, r5, r3
 802bc5a:	b2a3      	uxth	r3, r4
 802bc5c:	fbb5 f0fe 	udiv	r0, r5, lr
 802bc60:	fb0e 5510 	mls	r5, lr, r0, r5
 802bc64:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
 802bc68:	fb08 f800 	mul.w	r8, r8, r0
 802bc6c:	45a0      	cmp	r8, r4
 802bc6e:	d907      	bls.n	802bc80 <__udivmoddi4+0x10c>
 802bc70:	193c      	adds	r4, r7, r4
 802bc72:	f100 33ff 	add.w	r3, r0, #4294967295
 802bc76:	d202      	bcs.n	802bc7e <__udivmoddi4+0x10a>
 802bc78:	45a0      	cmp	r8, r4
 802bc7a:	f200 80d7 	bhi.w	802be2c <__udivmoddi4+0x2b8>
 802bc7e:	4618      	mov	r0, r3
 802bc80:	eba4 0408 	sub.w	r4, r4, r8
 802bc84:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 802bc88:	e7c0      	b.n	802bc0c <__udivmoddi4+0x98>
 802bc8a:	428b      	cmp	r3, r1
 802bc8c:	d908      	bls.n	802bca0 <__udivmoddi4+0x12c>
 802bc8e:	2e00      	cmp	r6, #0
 802bc90:	f000 80af 	beq.w	802bdf2 <__udivmoddi4+0x27e>
 802bc94:	2100      	movs	r1, #0
 802bc96:	e9c6 0500 	strd	r0, r5, [r6]
 802bc9a:	4608      	mov	r0, r1
 802bc9c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802bca0:	fab3 f183 	clz	r1, r3
 802bca4:	2900      	cmp	r1, #0
 802bca6:	d14b      	bne.n	802bd40 <__udivmoddi4+0x1cc>
 802bca8:	42ab      	cmp	r3, r5
 802bcaa:	d302      	bcc.n	802bcb2 <__udivmoddi4+0x13e>
 802bcac:	4282      	cmp	r2, r0
 802bcae:	f200 80b7 	bhi.w	802be20 <__udivmoddi4+0x2ac>
 802bcb2:	1a84      	subs	r4, r0, r2
 802bcb4:	eb65 0303 	sbc.w	r3, r5, r3
 802bcb8:	2001      	movs	r0, #1
 802bcba:	469e      	mov	lr, r3
 802bcbc:	2e00      	cmp	r6, #0
 802bcbe:	d0aa      	beq.n	802bc16 <__udivmoddi4+0xa2>
 802bcc0:	e9c6 4e00 	strd	r4, lr, [r6]
 802bcc4:	e7a7      	b.n	802bc16 <__udivmoddi4+0xa2>
 802bcc6:	f1c2 0c20 	rsb	ip, r2, #32
 802bcca:	fa01 f302 	lsl.w	r3, r1, r2
 802bcce:	4097      	lsls	r7, r2
 802bcd0:	fa20 f00c 	lsr.w	r0, r0, ip
 802bcd4:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 802bcd8:	fa21 fc0c 	lsr.w	ip, r1, ip
 802bcdc:	4318      	orrs	r0, r3
 802bcde:	fbbc f1fe 	udiv	r1, ip, lr
 802bce2:	0c05      	lsrs	r5, r0, #16
 802bce4:	fb0e cc11 	mls	ip, lr, r1, ip
 802bce8:	fa1f f887 	uxth.w	r8, r7
 802bcec:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
 802bcf0:	fb01 f308 	mul.w	r3, r1, r8
 802bcf4:	42ab      	cmp	r3, r5
 802bcf6:	fa04 f402 	lsl.w	r4, r4, r2
 802bcfa:	d909      	bls.n	802bd10 <__udivmoddi4+0x19c>
 802bcfc:	197d      	adds	r5, r7, r5
 802bcfe:	f101 3cff 	add.w	ip, r1, #4294967295
 802bd02:	f080 808b 	bcs.w	802be1c <__udivmoddi4+0x2a8>
 802bd06:	42ab      	cmp	r3, r5
 802bd08:	f240 8088 	bls.w	802be1c <__udivmoddi4+0x2a8>
 802bd0c:	3902      	subs	r1, #2
 802bd0e:	443d      	add	r5, r7
 802bd10:	1aeb      	subs	r3, r5, r3
 802bd12:	b285      	uxth	r5, r0
 802bd14:	fbb3 f0fe 	udiv	r0, r3, lr
 802bd18:	fb0e 3310 	mls	r3, lr, r0, r3
 802bd1c:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 802bd20:	fb00 f308 	mul.w	r3, r0, r8
 802bd24:	42ab      	cmp	r3, r5
 802bd26:	d907      	bls.n	802bd38 <__udivmoddi4+0x1c4>
 802bd28:	197d      	adds	r5, r7, r5
 802bd2a:	f100 3cff 	add.w	ip, r0, #4294967295
 802bd2e:	d271      	bcs.n	802be14 <__udivmoddi4+0x2a0>
 802bd30:	42ab      	cmp	r3, r5
 802bd32:	d96f      	bls.n	802be14 <__udivmoddi4+0x2a0>
 802bd34:	3802      	subs	r0, #2
 802bd36:	443d      	add	r5, r7
 802bd38:	1aeb      	subs	r3, r5, r3
 802bd3a:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 802bd3e:	e778      	b.n	802bc32 <__udivmoddi4+0xbe>
 802bd40:	f1c1 0c20 	rsb	ip, r1, #32
 802bd44:	408b      	lsls	r3, r1
 802bd46:	fa22 f70c 	lsr.w	r7, r2, ip
 802bd4a:	431f      	orrs	r7, r3
 802bd4c:	fa20 f40c 	lsr.w	r4, r0, ip
 802bd50:	fa05 f301 	lsl.w	r3, r5, r1
 802bd54:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 802bd58:	fa25 f50c 	lsr.w	r5, r5, ip
 802bd5c:	431c      	orrs	r4, r3
 802bd5e:	0c23      	lsrs	r3, r4, #16
 802bd60:	fbb5 f9fe 	udiv	r9, r5, lr
 802bd64:	fa1f f887 	uxth.w	r8, r7
 802bd68:	fb0e 5519 	mls	r5, lr, r9, r5
 802bd6c:	ea43 4505 	orr.w	r5, r3, r5, lsl #16
 802bd70:	fb09 fa08 	mul.w	sl, r9, r8
 802bd74:	45aa      	cmp	sl, r5
 802bd76:	fa02 f201 	lsl.w	r2, r2, r1
 802bd7a:	fa00 f301 	lsl.w	r3, r0, r1
 802bd7e:	d908      	bls.n	802bd92 <__udivmoddi4+0x21e>
 802bd80:	197d      	adds	r5, r7, r5
 802bd82:	f109 30ff 	add.w	r0, r9, #4294967295
 802bd86:	d247      	bcs.n	802be18 <__udivmoddi4+0x2a4>
 802bd88:	45aa      	cmp	sl, r5
 802bd8a:	d945      	bls.n	802be18 <__udivmoddi4+0x2a4>
 802bd8c:	f1a9 0902 	sub.w	r9, r9, #2
 802bd90:	443d      	add	r5, r7
 802bd92:	eba5 050a 	sub.w	r5, r5, sl
 802bd96:	b2a4      	uxth	r4, r4
 802bd98:	fbb5 f0fe 	udiv	r0, r5, lr
 802bd9c:	fb0e 5510 	mls	r5, lr, r0, r5
 802bda0:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 802bda4:	fb00 f808 	mul.w	r8, r0, r8
 802bda8:	45a0      	cmp	r8, r4
 802bdaa:	d907      	bls.n	802bdbc <__udivmoddi4+0x248>
 802bdac:	193c      	adds	r4, r7, r4
 802bdae:	f100 35ff 	add.w	r5, r0, #4294967295
 802bdb2:	d22d      	bcs.n	802be10 <__udivmoddi4+0x29c>
 802bdb4:	45a0      	cmp	r8, r4
 802bdb6:	d92b      	bls.n	802be10 <__udivmoddi4+0x29c>
 802bdb8:	3802      	subs	r0, #2
 802bdba:	443c      	add	r4, r7
 802bdbc:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 802bdc0:	eba4 0408 	sub.w	r4, r4, r8
 802bdc4:	fba0 8902 	umull	r8, r9, r0, r2
 802bdc8:	454c      	cmp	r4, r9
 802bdca:	46c6      	mov	lr, r8
 802bdcc:	464d      	mov	r5, r9
 802bdce:	d319      	bcc.n	802be04 <__udivmoddi4+0x290>
 802bdd0:	d016      	beq.n	802be00 <__udivmoddi4+0x28c>
 802bdd2:	b15e      	cbz	r6, 802bdec <__udivmoddi4+0x278>
 802bdd4:	ebb3 020e 	subs.w	r2, r3, lr
 802bdd8:	eb64 0405 	sbc.w	r4, r4, r5
 802bddc:	fa04 fc0c 	lsl.w	ip, r4, ip
 802bde0:	40ca      	lsrs	r2, r1
 802bde2:	ea4c 0202 	orr.w	r2, ip, r2
 802bde6:	40cc      	lsrs	r4, r1
 802bde8:	e9c6 2400 	strd	r2, r4, [r6]
 802bdec:	2100      	movs	r1, #0
 802bdee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802bdf2:	4631      	mov	r1, r6
 802bdf4:	4630      	mov	r0, r6
 802bdf6:	e70e      	b.n	802bc16 <__udivmoddi4+0xa2>
 802bdf8:	46ac      	mov	ip, r5
 802bdfa:	e6ed      	b.n	802bbd8 <__udivmoddi4+0x64>
 802bdfc:	4618      	mov	r0, r3
 802bdfe:	e701      	b.n	802bc04 <__udivmoddi4+0x90>
 802be00:	4543      	cmp	r3, r8
 802be02:	d2e6      	bcs.n	802bdd2 <__udivmoddi4+0x25e>
 802be04:	ebb8 0e02 	subs.w	lr, r8, r2
 802be08:	eb69 0507 	sbc.w	r5, r9, r7
 802be0c:	3801      	subs	r0, #1
 802be0e:	e7e0      	b.n	802bdd2 <__udivmoddi4+0x25e>
 802be10:	4628      	mov	r0, r5
 802be12:	e7d3      	b.n	802bdbc <__udivmoddi4+0x248>
 802be14:	4660      	mov	r0, ip
 802be16:	e78f      	b.n	802bd38 <__udivmoddi4+0x1c4>
 802be18:	4681      	mov	r9, r0
 802be1a:	e7ba      	b.n	802bd92 <__udivmoddi4+0x21e>
 802be1c:	4661      	mov	r1, ip
 802be1e:	e777      	b.n	802bd10 <__udivmoddi4+0x19c>
 802be20:	4608      	mov	r0, r1
 802be22:	e74b      	b.n	802bcbc <__udivmoddi4+0x148>
 802be24:	f1ac 0c02 	sub.w	ip, ip, #2
 802be28:	443d      	add	r5, r7
 802be2a:	e715      	b.n	802bc58 <__udivmoddi4+0xe4>
 802be2c:	3802      	subs	r0, #2
 802be2e:	443c      	add	r4, r7
 802be30:	e726      	b.n	802bc80 <__udivmoddi4+0x10c>
 802be32:	bf00      	nop

0802be34 <__aeabi_idiv0>:
 802be34:	4770      	bx	lr
 802be36:	bf00      	nop

0802be38 <MX_ADC_Init>:
  /* USER CODE BEGIN ADC_Init 1 */

  /* USER CODE END ADC_Init 1 */
  /** Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion)
  */
  hadc.Instance = ADC;
 802be38:	4813      	ldr	r0, [pc, #76]	; (802be88 <MX_ADC_Init+0x50>)
  hadc.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
 802be3a:	4a14      	ldr	r2, [pc, #80]	; (802be8c <MX_ADC_Init+0x54>)
{
 802be3c:	b508      	push	{r3, lr}
  hadc.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
 802be3e:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 802be42:	e9c0 2300 	strd	r2, r3, [r0]
  hadc.Init.Resolution = ADC_RESOLUTION_12B;
  hadc.Init.DataAlign = ADC_DATAALIGN_RIGHT;
  hadc.Init.ScanConvMode = ADC_SCAN_DISABLE;
  hadc.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 802be46:	2204      	movs	r2, #4
  hadc.Init.Resolution = ADC_RESOLUTION_12B;
 802be48:	2300      	movs	r3, #0
  hadc.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 802be4a:	6142      	str	r2, [r0, #20]
  hadc.Init.LowPowerAutoWait = DISABLE;
  hadc.Init.LowPowerAutoPowerOff = DISABLE;
  hadc.Init.ContinuousConvMode = DISABLE;
  hadc.Init.NbrOfConversion = 1;
 802be4c:	2201      	movs	r2, #1
 802be4e:	61c2      	str	r2, [r0, #28]
  hadc.Init.DiscontinuousConvMode = DISABLE;
  hadc.Init.ExternalTrigConv = ADC_SOFTWARE_START;
  hadc.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
  hadc.Init.DMAContinuousRequests = DISABLE;
  hadc.Init.Overrun = ADC_OVR_DATA_OVERWRITTEN;
  hadc.Init.SamplingTimeCommon1 = ADC_SAMPLETIME_160CYCLES_5;
 802be50:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 802be54:	2207      	movs	r2, #7
  hadc.Init.LowPowerAutoWait = DISABLE;
 802be56:	8303      	strh	r3, [r0, #24]
  hadc.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 802be58:	e9c0 3302 	strd	r3, r3, [r0, #8]
  hadc.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 802be5c:	e9c0 3309 	strd	r3, r3, [r0, #36]	; 0x24
  hadc.Init.SamplingTimeCommon1 = ADC_SAMPLETIME_160CYCLES_5;
 802be60:	e9c0 120c 	strd	r1, r2, [r0, #48]	; 0x30
  hadc.Init.ScanConvMode = ADC_SCAN_DISABLE;
 802be64:	6103      	str	r3, [r0, #16]
  hadc.Init.ContinuousConvMode = DISABLE;
 802be66:	7683      	strb	r3, [r0, #26]
  hadc.Init.DiscontinuousConvMode = DISABLE;
 802be68:	f880 3020 	strb.w	r3, [r0, #32]
  hadc.Init.DMAContinuousRequests = DISABLE;
 802be6c:	f880 302c 	strb.w	r3, [r0, #44]	; 0x2c
  hadc.Init.SamplingTimeCommon2 = ADC_SAMPLETIME_160CYCLES_5;
 802be70:	6382      	str	r2, [r0, #56]	; 0x38
  hadc.Init.OversamplingMode = DISABLE;
 802be72:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  hadc.Init.TriggerFrequencyMode = ADC_TRIGGER_FREQ_HIGH;
 802be76:	64c3      	str	r3, [r0, #76]	; 0x4c
  if (HAL_ADC_Init(&hadc) != HAL_OK)
 802be78:	f001 fb6c 	bl	802d554 <HAL_ADC_Init>
 802be7c:	b118      	cbz	r0, 802be86 <MX_ADC_Init+0x4e>
  }
  /* USER CODE BEGIN ADC_Init 2 */

  /* USER CODE END ADC_Init 2 */

}
 802be7e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 802be82:	f000 ba17 	b.w	802c2b4 <Error_Handler>
}
 802be86:	bd08      	pop	{r3, pc}
 802be88:	20006154 	.word	0x20006154
 802be8c:	40012400 	.word	0x40012400

0802be90 <HAL_ADC_MspInit>:

void HAL_ADC_MspInit(ADC_HandleTypeDef* adcHandle)
{

  if(adcHandle->Instance==ADC)
 802be90:	6802      	ldr	r2, [r0, #0]
 802be92:	4b08      	ldr	r3, [pc, #32]	; (802beb4 <HAL_ADC_MspInit+0x24>)
 802be94:	429a      	cmp	r2, r3
{
 802be96:	b082      	sub	sp, #8
  if(adcHandle->Instance==ADC)
 802be98:	d10a      	bne.n	802beb0 <HAL_ADC_MspInit+0x20>
  * @retval None
  */
__STATIC_INLINE void LL_APB2_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB2ENR, Periphs);
 802be9a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802be9e:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 802bea0:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 802bea4:	661a      	str	r2, [r3, #96]	; 0x60
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
 802bea6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 802bea8:	f403 7300 	and.w	r3, r3, #512	; 0x200
 802beac:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 802beae:	9b01      	ldr	r3, [sp, #4]
    __HAL_RCC_ADC_CLK_ENABLE();
  /* USER CODE BEGIN ADC_MspInit 1 */

  /* USER CODE END ADC_MspInit 1 */
  }
}
 802beb0:	b002      	add	sp, #8
 802beb2:	4770      	bx	lr
 802beb4:	40012400 	.word	0x40012400

0802beb8 <HAL_ADC_MspDeInit>:

void HAL_ADC_MspDeInit(ADC_HandleTypeDef* adcHandle)
{

  if(adcHandle->Instance==ADC)
 802beb8:	6802      	ldr	r2, [r0, #0]
 802beba:	4b05      	ldr	r3, [pc, #20]	; (802bed0 <HAL_ADC_MspDeInit+0x18>)
 802bebc:	429a      	cmp	r2, r3
  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM17
  * @retval None
  */
__STATIC_INLINE void LL_APB2_GRP1_DisableClock(uint32_t Periphs)
{
  CLEAR_BIT(RCC->APB2ENR, Periphs);
 802bebe:	bf01      	itttt	eq
 802bec0:	f04f 42b0 	moveq.w	r2, #1476395008	; 0x58000000
 802bec4:	6e13      	ldreq	r3, [r2, #96]	; 0x60
 802bec6:	f423 7300 	biceq.w	r3, r3, #512	; 0x200
 802beca:	6613      	streq	r3, [r2, #96]	; 0x60
    __HAL_RCC_ADC_CLK_DISABLE();
  /* USER CODE BEGIN ADC_MspDeInit 1 */

  /* USER CODE END ADC_MspDeInit 1 */
  }
}
 802becc:	4770      	bx	lr
 802bece:	bf00      	nop
 802bed0:	40012400 	.word	0x40012400

0802bed4 <ADC_ReadChannels>:
/* USER CODE BEGIN PrFD */

/* USER CODE END PrFD */

static uint32_t ADC_ReadChannels(uint32_t channel)
{
 802bed4:	b530      	push	{r4, r5, lr}
 802bed6:	b085      	sub	sp, #20
  /* USER CODE BEGIN ADC_ReadChannels_1 */

  /* USER CODE END ADC_ReadChannels_1 */
  uint32_t ADCxConvertedValues = 0;
  ADC_ChannelConfTypeDef sConfig = {0};
 802bed8:	2400      	movs	r4, #0
{
 802beda:	4605      	mov	r5, r0
  ADC_ChannelConfTypeDef sConfig = {0};
 802bedc:	e9cd 4401 	strd	r4, r4, [sp, #4]
 802bee0:	9403      	str	r4, [sp, #12]

  MX_ADC_Init();
 802bee2:	f7ff ffa9 	bl	802be38 <MX_ADC_Init>

  /* Start Calibration */
  if (HAL_ADCEx_Calibration_Start(&hadc) != HAL_OK)
 802bee6:	4814      	ldr	r0, [pc, #80]	; (802bf38 <ADC_ReadChannels+0x64>)
 802bee8:	f001 fedc 	bl	802dca4 <HAL_ADCEx_Calibration_Start>
 802beec:	b108      	cbz	r0, 802bef2 <ADC_ReadChannels+0x1e>
  {
    Error_Handler();
 802beee:	f000 f9e1 	bl	802c2b4 <Error_Handler>

  /* Configure Regular Channel */
  sConfig.Channel = channel;
  sConfig.Rank = ADC_REGULAR_RANK_1;
  sConfig.SamplingTime = ADC_SAMPLINGTIME_COMMON_1;
  if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 802bef2:	4811      	ldr	r0, [pc, #68]	; (802bf38 <ADC_ReadChannels+0x64>)
  sConfig.SamplingTime = ADC_SAMPLINGTIME_COMMON_1;
 802bef4:	9403      	str	r4, [sp, #12]
  if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 802bef6:	a901      	add	r1, sp, #4
  sConfig.Rank = ADC_REGULAR_RANK_1;
 802bef8:	e9cd 5401 	strd	r5, r4, [sp, #4]
  if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 802befc:	f001 fcac 	bl	802d858 <HAL_ADC_ConfigChannel>
 802bf00:	b108      	cbz	r0, 802bf06 <ADC_ReadChannels+0x32>
  {
    Error_Handler();
 802bf02:	f000 f9d7 	bl	802c2b4 <Error_Handler>
  }

  if (HAL_ADC_Start(&hadc) != HAL_OK)
 802bf06:	480c      	ldr	r0, [pc, #48]	; (802bf38 <ADC_ReadChannels+0x64>)
 802bf08:	f001 fe00 	bl	802db0c <HAL_ADC_Start>
 802bf0c:	b108      	cbz	r0, 802bf12 <ADC_ReadChannels+0x3e>
  {
    /* Start Error */
    Error_Handler();
 802bf0e:	f000 f9d1 	bl	802c2b4 <Error_Handler>
  }
  /** Wait for end of conversion */
  HAL_ADC_PollForConversion(&hadc, HAL_MAX_DELAY);
 802bf12:	f04f 31ff 	mov.w	r1, #4294967295
 802bf16:	4808      	ldr	r0, [pc, #32]	; (802bf38 <ADC_ReadChannels+0x64>)
 802bf18:	f001 fc40 	bl	802d79c <HAL_ADC_PollForConversion>

  /** Wait for end of conversion */
  HAL_ADC_Stop(&hadc) ;   /* it calls also ADC_Disable() */
 802bf1c:	4806      	ldr	r0, [pc, #24]	; (802bf38 <ADC_ReadChannels+0x64>)
 802bf1e:	f001 fea3 	bl	802dc68 <HAL_ADC_Stop>

  ADCxConvertedValues = HAL_ADC_GetValue(&hadc);
 802bf22:	4805      	ldr	r0, [pc, #20]	; (802bf38 <ADC_ReadChannels+0x64>)
 802bf24:	f001 fc95 	bl	802d852 <HAL_ADC_GetValue>
 802bf28:	4604      	mov	r4, r0

  HAL_ADC_DeInit(&hadc);
 802bf2a:	4803      	ldr	r0, [pc, #12]	; (802bf38 <ADC_ReadChannels+0x64>)
 802bf2c:	f001 fe50 	bl	802dbd0 <HAL_ADC_DeInit>

  return ADCxConvertedValues;
  /* USER CODE BEGIN ADC_ReadChannels_2 */

  /* USER CODE END ADC_ReadChannels_2 */
}
 802bf30:	4620      	mov	r0, r4
 802bf32:	b005      	add	sp, #20
 802bf34:	bd30      	pop	{r4, r5, pc}
 802bf36:	bf00      	nop
 802bf38:	20006154 	.word	0x20006154

0802bf3c <SYS_InitMeasurement>:
  hadc.Instance = ADC;
 802bf3c:	4b01      	ldr	r3, [pc, #4]	; (802bf44 <SYS_InitMeasurement+0x8>)
 802bf3e:	4a02      	ldr	r2, [pc, #8]	; (802bf48 <SYS_InitMeasurement+0xc>)
 802bf40:	601a      	str	r2, [r3, #0]
}
 802bf42:	4770      	bx	lr
 802bf44:	20006154 	.word	0x20006154
 802bf48:	40012400 	.word	0x40012400

0802bf4c <SYS_GetBatteryLevel>:
{
 802bf4c:	b508      	push	{r3, lr}
  measuredLevel = ADC_ReadChannels(ADC_CHANNEL_VREFINT);
 802bf4e:	4809      	ldr	r0, [pc, #36]	; (802bf74 <SYS_GetBatteryLevel+0x28>)
 802bf50:	f7ff ffc0 	bl	802bed4 <ADC_ReadChannels>
  if (measuredLevel == 0)
 802bf54:	b160      	cbz	r0, 802bf70 <SYS_GetBatteryLevel+0x24>
    if ((uint32_t)*VREFINT_CAL_ADDR != (uint32_t)0xFFFFU)
 802bf56:	4b08      	ldr	r3, [pc, #32]	; (802bf78 <SYS_GetBatteryLevel+0x2c>)
 802bf58:	881a      	ldrh	r2, [r3, #0]
 802bf5a:	f64f 73ff 	movw	r3, #65535	; 0xffff
 802bf5e:	429a      	cmp	r2, r3
      batteryLevelmV = __LL_ADC_CALC_VREFANALOG_VOLTAGE(measuredLevel,
 802bf60:	bf16      	itet	ne
 802bf62:	f640 43e4 	movwne	r3, #3300	; 0xce4
      batteryLevelmV = (VREFINT_CAL_VREF * 1510) / measuredLevel;
 802bf66:	4b05      	ldreq	r3, [pc, #20]	; (802bf7c <SYS_GetBatteryLevel+0x30>)
      batteryLevelmV = __LL_ADC_CALC_VREFANALOG_VOLTAGE(measuredLevel,
 802bf68:	4353      	mulne	r3, r2
      batteryLevelmV = (VREFINT_CAL_VREF * 1510) / measuredLevel;
 802bf6a:	fbb3 f0f0 	udiv	r0, r3, r0
 802bf6e:	b280      	uxth	r0, r0
}
 802bf70:	bd08      	pop	{r3, pc}
 802bf72:	bf00      	nop
 802bf74:	b4002000 	.word	0xb4002000
 802bf78:	1fff75aa 	.word	0x1fff75aa
 802bf7c:	004c08d8 	.word	0x004c08d8

0802bf80 <SYS_GetTemperatureLevel>:
{
 802bf80:	b513      	push	{r0, r1, r4, lr}
  uint16_t batteryLevelmV = SYS_GetBatteryLevel();
 802bf82:	f7ff ffe3 	bl	802bf4c <SYS_GetBatteryLevel>
 802bf86:	4604      	mov	r4, r0
  measuredLevel = ADC_ReadChannels(ADC_CHANNEL_TEMPSENSOR);
 802bf88:	4818      	ldr	r0, [pc, #96]	; (802bfec <SYS_GetTemperatureLevel+0x6c>)
 802bf8a:	f7ff ffa3 	bl	802bed4 <ADC_ReadChannels>
  if (((int32_t)*TEMPSENSOR_CAL2_ADDR - (int32_t)*TEMPSENSOR_CAL1_ADDR) != 0)
 802bf8e:	4b18      	ldr	r3, [pc, #96]	; (802bff0 <SYS_GetTemperatureLevel+0x70>)
 802bf90:	4a18      	ldr	r2, [pc, #96]	; (802bff4 <SYS_GetTemperatureLevel+0x74>)
 802bf92:	881b      	ldrh	r3, [r3, #0]
 802bf94:	8812      	ldrh	r2, [r2, #0]
 802bf96:	4293      	cmp	r3, r2
 802bf98:	fb00 f004 	mul.w	r0, r0, r4
 802bf9c:	d016      	beq.n	802bfcc <SYS_GetTemperatureLevel+0x4c>
    temperatureDegreeC = __LL_ADC_CALC_TEMPERATURE(batteryLevelmV,
 802bf9e:	f640 44e4 	movw	r4, #3300	; 0xce4
 802bfa2:	fbb0 f0f4 	udiv	r0, r0, r4
 802bfa6:	2464      	movs	r4, #100	; 0x64
 802bfa8:	1a80      	subs	r0, r0, r2
 802bfaa:	4344      	muls	r4, r0
 802bfac:	1a9b      	subs	r3, r3, r2
 802bfae:	fb94 f4f3 	sdiv	r4, r4, r3
    temperatureDegreeC = __LL_ADC_CALC_TEMPERATURE_TYP_PARAMS(TEMPSENSOR_TYP_AVGSLOPE,
 802bfb2:	341e      	adds	r4, #30
 802bfb4:	b224      	sxth	r4, r4
  APP_LOG(TS_ON, VLEVEL_L, "temp= %d\n\r", temperatureDegreeC);
 802bfb6:	2201      	movs	r2, #1
 802bfb8:	4b0f      	ldr	r3, [pc, #60]	; (802bff8 <SYS_GetTemperatureLevel+0x78>)
 802bfba:	9400      	str	r4, [sp, #0]
 802bfbc:	2100      	movs	r1, #0
 802bfbe:	4610      	mov	r0, r2
 802bfc0:	f00e fe9a 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
  temperatureDegreeC <<= 8;
 802bfc4:	0220      	lsls	r0, r4, #8
}
 802bfc6:	b200      	sxth	r0, r0
 802bfc8:	b002      	add	sp, #8
 802bfca:	bd10      	pop	{r4, pc}
    temperatureDegreeC = __LL_ADC_CALC_TEMPERATURE_TYP_PARAMS(TEMPSENSOR_TYP_AVGSLOPE,
 802bfcc:	f640 74ff 	movw	r4, #4095	; 0xfff
 802bfd0:	fbb0 f0f4 	udiv	r0, r0, r4
 802bfd4:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 802bfd8:	4344      	muls	r4, r0
 802bfda:	f5a4 2439 	sub.w	r4, r4, #757760	; 0xb9000
 802bfde:	f5a4 640c 	sub.w	r4, r4, #2240	; 0x8c0
 802bfe2:	f640 10c4 	movw	r0, #2500	; 0x9c4
 802bfe6:	fb94 f4f0 	sdiv	r4, r4, r0
 802bfea:	e7e2      	b.n	802bfb2 <SYS_GetTemperatureLevel+0x32>
 802bfec:	b0001000 	.word	0xb0001000
 802bff0:	1fff75c8 	.word	0x1fff75c8
 802bff4:	1fff75a8 	.word	0x1fff75a8
 802bff8:	0803bd88 	.word	0x0803bd88

0802bffc <MX_DMA_Init>:
  SET_BIT(RCC->AHB1ENR, Periphs);
 802bffc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000

/**
  * Enable DMA controller clock
  */
void MX_DMA_Init(void)
{
 802c000:	b507      	push	{r0, r1, r2, lr}
 802c002:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 802c004:	f042 0204 	orr.w	r2, r2, #4
 802c008:	649a      	str	r2, [r3, #72]	; 0x48
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 802c00a:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 802c00c:	f002 0204 	and.w	r2, r2, #4
 802c010:	9201      	str	r2, [sp, #4]
  (void)tmpreg;
 802c012:	9a01      	ldr	r2, [sp, #4]
  SET_BIT(RCC->AHB1ENR, Periphs);
 802c014:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 802c016:	f042 0201 	orr.w	r2, r2, #1
 802c01a:	649a      	str	r2, [r3, #72]	; 0x48
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 802c01c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 802c01e:	f003 0301 	and.w	r3, r3, #1
 802c022:	9300      	str	r3, [sp, #0]
  __HAL_RCC_DMAMUX1_CLK_ENABLE();
  __HAL_RCC_DMA1_CLK_ENABLE();

  /* DMA interrupt init */
  /* DMA1_Channel5_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Channel5_IRQn, 2, 0);
 802c024:	2200      	movs	r2, #0
 802c026:	2102      	movs	r1, #2
 802c028:	200f      	movs	r0, #15
  (void)tmpreg;
 802c02a:	9b00      	ldr	r3, [sp, #0]
 802c02c:	f001 fe98 	bl	802dd60 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel5_IRQn);
 802c030:	200f      	movs	r0, #15

}
 802c032:	b003      	add	sp, #12
 802c034:	f85d eb04 	ldr.w	lr, [sp], #4
  HAL_NVIC_EnableIRQ(DMA1_Channel5_IRQn);
 802c038:	f001 bec4 	b.w	802ddc4 <HAL_NVIC_EnableIRQ>

0802c03c <FLASH_IF_Write64>:

  /* USER CODE END FLASH_IF_Write_2 */
}

int32_t FLASH_IF_Write64(uint32_t address, uint64_t data)
{
 802c03c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
__STATIC_INLINE uint32_t LL_FLASH_IsActiveFlag_OperationSuspended(void)
{
#if defined(CORE_CM0PLUS)
  return ((READ_BIT(FLASH->C2SR, FLASH_C2SR_PESD) == (FLASH_C2SR_PESD)) ? 1UL : 0UL);
#else
  return ((READ_BIT(FLASH->SR, FLASH_SR_PESD) == (FLASH_SR_PESD)) ? 1UL : 0UL);
 802c03e:	4f0b      	ldr	r7, [pc, #44]	; (802c06c <FLASH_IF_Write64+0x30>)
 802c040:	4606      	mov	r6, r0
 802c042:	4614      	mov	r4, r2
 802c044:	461d      	mov	r5, r3
  /* USER CODE BEGIN FLASH_IF_Write64_1 */

  /* USER CODE END FLASH_IF_Write64_1 */
  while (*(uint64_t *)address != data)
 802c046:	e9d6 2300 	ldrd	r2, r3, [r6]
 802c04a:	42ab      	cmp	r3, r5
 802c04c:	bf08      	it	eq
 802c04e:	42a2      	cmpeq	r2, r4
 802c050:	d101      	bne.n	802c056 <FLASH_IF_Write64+0x1a>

  return FLASH_OK;
  /* USER CODE BEGIN HW_FLASH_Write_2 */

  /* USER CODE END HW_FLASH_Write_2 */
}
 802c052:	2000      	movs	r0, #0
 802c054:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802c056:	693b      	ldr	r3, [r7, #16]
 802c058:	031b      	lsls	r3, r3, #12
 802c05a:	d4fc      	bmi.n	802c056 <FLASH_IF_Write64+0x1a>
    HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, address, data);
 802c05c:	4622      	mov	r2, r4
 802c05e:	462b      	mov	r3, r5
 802c060:	4631      	mov	r1, r6
 802c062:	2001      	movs	r0, #1
 802c064:	f002 f964 	bl	802e330 <HAL_FLASH_Program>
 802c068:	e7ed      	b.n	802c046 <FLASH_IF_Write64+0xa>
 802c06a:	bf00      	nop
 802c06c:	58004000 	.word	0x58004000

0802c070 <FLASH_IF_Write_Buffer>:

/* USER CODE END EF */

/* Private Functions Definition -----------------------------------------------*/
static int32_t FLASH_IF_Write_Buffer(uint32_t pDestination, uint8_t *pSource, uint32_t uLength)
{
 802c070:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 802c072:	f022 0507 	bic.w	r5, r2, #7
 802c076:	4604      	mov	r4, r0
 802c078:	4405      	add	r5, r0
 802c07a:	1a0e      	subs	r6, r1, r0
  /* USER CODE END FLASH_IF_Write_Buffer_1 */
  uint8_t *pSrc = pSource;
  uint64_t src_value;
  int32_t status = FLASH_OK;

  for (uint32_t i = 0; i < (uLength / sizeof(uint64_t)); i++)
 802c07c:	42ac      	cmp	r4, r5
 802c07e:	eb06 0104 	add.w	r1, r6, r4
 802c082:	d101      	bne.n	802c088 <FLASH_IF_Write_Buffer+0x18>
 802c084:	2000      	movs	r0, #0
      /* exit the for loop*/
      break;
    }
  }

  return status;
 802c086:	e014      	b.n	802c0b2 <FLASH_IF_Write_Buffer+0x42>
    UTIL_MEM_cpy_8(&src_value, pSrc, sizeof(uint64_t));
 802c088:	2208      	movs	r2, #8
 802c08a:	4668      	mov	r0, sp
 802c08c:	f00e ff3c 	bl	803af08 <UTIL_MEM_cpy_8>
    if (src_value != UINT64_MAX)
 802c090:	e9dd 2300 	ldrd	r2, r3, [sp]
 802c094:	1c59      	adds	r1, r3, #1
 802c096:	bf08      	it	eq
 802c098:	f1b2 3fff 	cmpeq.w	r2, #4294967295
 802c09c:	f104 0708 	add.w	r7, r4, #8
 802c0a0:	d101      	bne.n	802c0a6 <FLASH_IF_Write_Buffer+0x36>
    pDestination += sizeof(uint64_t);
 802c0a2:	463c      	mov	r4, r7
    if (status != FLASH_OK)
 802c0a4:	e7ea      	b.n	802c07c <FLASH_IF_Write_Buffer+0xc>
      status = FLASH_IF_Write64(pDestination, src_value);
 802c0a6:	4620      	mov	r0, r4
 802c0a8:	f7ff ffc8 	bl	802c03c <FLASH_IF_Write64>
    pDestination += sizeof(uint64_t);
 802c0ac:	463c      	mov	r4, r7
    if (status != FLASH_OK)
 802c0ae:	2800      	cmp	r0, #0
 802c0b0:	d0e4      	beq.n	802c07c <FLASH_IF_Write_Buffer+0xc>
  /* USER CODE BEGIN FLASH_IF_Write_Buffer_2 */

  /* USER CODE END FLASH_IF_Write_Buffer_2 */
}
 802c0b2:	b003      	add	sp, #12
 802c0b4:	bdf0      	pop	{r4, r5, r6, r7, pc}

0802c0b6 <FLASH_IF_EraseByPages>:
{
 802c0b6:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  erase_str.TypeErase = FLASH_TYPEERASE_PAGES;
 802c0b8:	2302      	movs	r3, #2
  erase_str.Page = page;
 802c0ba:	e9cd 3001 	strd	r3, r0, [sp, #4]
  erase_str.NbPages = n;
 802c0be:	9103      	str	r1, [sp, #12]
  if (interrupt)
 802c0c0:	b15a      	cbz	r2, 802c0da <FLASH_IF_EraseByPages+0x24>
    hal_status = HAL_FLASHEx_Erase_IT(&erase_str);
 802c0c2:	a801      	add	r0, sp, #4
 802c0c4:	f002 f9c8 	bl	802e458 <HAL_FLASHEx_Erase_IT>
  return ((hal_status == HAL_OK) ? FLASH_OK : ((hal_status == HAL_BUSY) ? FLASH_BUSY : FLASH_ERASE_ERROR));
 802c0c8:	b120      	cbz	r0, 802c0d4 <FLASH_IF_EraseByPages+0x1e>
 802c0ca:	2802      	cmp	r0, #2
 802c0cc:	bf0c      	ite	eq
 802c0ce:	2001      	moveq	r0, #1
 802c0d0:	f06f 0001 	mvnne.w	r0, #1
}
 802c0d4:	b005      	add	sp, #20
 802c0d6:	f85d fb04 	ldr.w	pc, [sp], #4
    hal_status = HAL_FLASHEx_Erase(&erase_str, &page_error);
 802c0da:	4669      	mov	r1, sp
 802c0dc:	a801      	add	r0, sp, #4
 802c0de:	f002 f96d 	bl	802e3bc <HAL_FLASHEx_Erase>
 802c0e2:	e7f1      	b.n	802c0c8 <FLASH_IF_EraseByPages+0x12>

0802c0e4 <FLASH_IF_Write>:
{
 802c0e4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802c0e8:	469a      	mov	sl, r3
  uint32_t page_start_index = PAGE(address);
 802c0ea:	4b46      	ldr	r3, [pc, #280]	; (802c204 <FLASH_IF_Write+0x120>)
{
 802c0ec:	4691      	mov	r9, r2
  uint32_t page_end_index = PAGE(address + size - 1);
 802c0ee:	f109 4878 	add.w	r8, r9, #4160749568	; 0xf8000000
  uint32_t page_start_index = PAGE(address);
 802c0f2:	681a      	ldr	r2, [r3, #0]
 802c0f4:	4b44      	ldr	r3, [pc, #272]	; (802c208 <FLASH_IF_Write+0x124>)
  uint32_t page_end_index = PAGE(address + size - 1);
 802c0f6:	f108 38ff 	add.w	r8, r8, #4294967295
  uint32_t page_start_index = PAGE(address);
 802c0fa:	ea03 2382 	and.w	r3, r3, r2, lsl #10
  uint32_t page_end_index = PAGE(address + size - 1);
 802c0fe:	4480      	add	r8, r0
  uint32_t page_start_index = PAGE(address);
 802c100:	f100 4278 	add.w	r2, r0, #4160749568	; 0xf8000000
 802c104:	fbb2 f6f3 	udiv	r6, r2, r3
 802c108:	fb03 2616 	mls	r6, r3, r6, r2
  uint32_t page_end_index = PAGE(address + size - 1);
 802c10c:	fbb8 f2f3 	udiv	r2, r8, r3
 802c110:	fb03 8812 	mls	r8, r3, r2, r8
{
 802c114:	4605      	mov	r5, r0
  uint32_t page_start_index = PAGE(address);
 802c116:	0af6      	lsrs	r6, r6, #11
  uint32_t page_end_index = PAGE(address + size - 1);
 802c118:	ea4f 28d8 	mov.w	r8, r8, lsr #11
  if ((data == NULL) || ((size % sizeof(uint64_t)) != 0) || ((address % sizeof(uint64_t)) != 0))
 802c11c:	460f      	mov	r7, r1
 802c11e:	b921      	cbnz	r1, 802c12a <FLASH_IF_Write+0x46>
    return FLASH_PARAM_ERROR;
 802c120:	f06f 0004 	mvn.w	r0, #4
}
 802c124:	b003      	add	sp, #12
 802c126:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if ((data == NULL) || ((size % sizeof(uint64_t)) != 0) || ((address % sizeof(uint64_t)) != 0))
 802c12a:	ea40 0309 	orr.w	r3, r0, r9
 802c12e:	075b      	lsls	r3, r3, #29
 802c130:	d1f6      	bne.n	802c120 <FLASH_IF_Write+0x3c>
  if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0U)
 802c132:	4b36      	ldr	r3, [pc, #216]	; (802c20c <FLASH_IF_Write+0x128>)
 802c134:	695b      	ldr	r3, [r3, #20]
 802c136:	2b00      	cmp	r3, #0
 802c138:	db5e      	blt.n	802c1f8 <FLASH_IF_Write+0x114>
  if (page_start_index != page_end_index)
 802c13a:	4546      	cmp	r6, r8
    curr_size = FLASH_PAGE_SIZE - (address % FLASH_PAGE_SIZE);
 802c13c:	bf1a      	itte	ne
 802c13e:	f3c0 030a 	ubfxne	r3, r0, #0, #11
 802c142:	f5c3 6b00 	rsbne	fp, r3, #2048	; 0x800
 802c146:	46cb      	moveq	fp, r9
  for (uint32_t idx = page_start_index; idx <= page_end_index; idx++)
 802c148:	4546      	cmp	r6, r8
 802c14a:	d901      	bls.n	802c150 <FLASH_IF_Write+0x6c>
  int32_t status = FLASH_OK;
 802c14c:	2000      	movs	r0, #0
 802c14e:	e7e9      	b.n	802c124 <FLASH_IF_Write+0x40>
    if (FLASH_IF_IsEmpty((uint8_t *)curr_dest_addr, curr_size) != FLASH_EMPTY)
 802c150:	eb0b 0305 	add.w	r3, fp, r5
 802c154:	462c      	mov	r4, r5
  /* USER CODE END FLASH_IF_IsEmpty_1 */
  uint64_t *addr64;
  uint32_t i;

  /* start memory NOT 64bits aligned */
  while ((((uint32_t)addr) % sizeof(uint64_t)) != 0)
 802c156:	9301      	str	r3, [sp, #4]
 802c158:	9b01      	ldr	r3, [sp, #4]
 802c15a:	f014 0c07 	ands.w	ip, r4, #7
 802c15e:	eba3 0204 	sub.w	r2, r3, r4
 802c162:	d10c      	bne.n	802c17e <FLASH_IF_Write+0x9a>
    size--;
  }

  /* addr64 is 64 bits aligned */
  addr64 = (uint64_t *)addr;
  for (i = 0; i < (size / sizeof(uint64_t)); i++)
 802c164:	ea4f 0ed2 	mov.w	lr, r2, lsr #3
 802c168:	45f4      	cmp	ip, lr
 802c16a:	d130      	bne.n	802c1ce <FLASH_IF_Write+0xea>
    if (*addr64++ != UINT64_MAX)
    {
      return FLASH_NOT_EMPTY;
    }
  }
  size -= sizeof(uint64_t) * i;
 802c16c:	eba2 02cc 	sub.w	r2, r2, ip, lsl #3
 802c170:	4422      	add	r2, r4

  /* end memory NOT 64 bits aligned */
  addr = (uint8_t *)addr64;
  while (size != 0)
 802c172:	42a2      	cmp	r2, r4
 802c174:	d135      	bne.n	802c1e2 <FLASH_IF_Write+0xfe>
      if (FLASH_IF_Write_Buffer(curr_dest_addr, (uint8_t *)curr_src_addr, curr_size) != FLASH_OK)
 802c176:	465a      	mov	r2, fp
 802c178:	4639      	mov	r1, r7
 802c17a:	4628      	mov	r0, r5
 802c17c:	e021      	b.n	802c1c2 <FLASH_IF_Write+0xde>
    if (*addr++ != UINT8_MAX)
 802c17e:	f814 2b01 	ldrb.w	r2, [r4], #1
 802c182:	2aff      	cmp	r2, #255	; 0xff
 802c184:	d0e8      	beq.n	802c158 <FLASH_IF_Write+0x74>
      if (dataTempPage == NULL)
 802c186:	f1ba 0f00 	cmp.w	sl, #0
 802c18a:	d0c9      	beq.n	802c120 <FLASH_IF_Write+0x3c>
      UTIL_MEM_cpy_8(dataTempPage, (uint8_t *)(idx * FLASH_PAGE_SIZE + FLASH_BASE), FLASH_PAGE_SIZE);
 802c18c:	02f4      	lsls	r4, r6, #11
 802c18e:	f104 6400 	add.w	r4, r4, #134217728	; 0x8000000
 802c192:	f44f 6200 	mov.w	r2, #2048	; 0x800
 802c196:	4621      	mov	r1, r4
 802c198:	4650      	mov	r0, sl
 802c19a:	f00e feb5 	bl	803af08 <UTIL_MEM_cpy_8>
      UTIL_MEM_cpy_8(&dataTempPage[((uint32_t)curr_dest_addr) % FLASH_PAGE_SIZE], (uint8_t *)curr_src_addr, curr_size);
 802c19e:	f3c5 000a 	ubfx	r0, r5, #0, #11
 802c1a2:	fa1f f28b 	uxth.w	r2, fp
 802c1a6:	4639      	mov	r1, r7
 802c1a8:	4450      	add	r0, sl
 802c1aa:	f00e fead 	bl	803af08 <UTIL_MEM_cpy_8>
      if (FLASH_IF_EraseByPages(idx, 1, 0) != FLASH_OK)
 802c1ae:	2200      	movs	r2, #0
 802c1b0:	2101      	movs	r1, #1
 802c1b2:	4630      	mov	r0, r6
 802c1b4:	f7ff ff7f 	bl	802c0b6 <FLASH_IF_EraseByPages>
 802c1b8:	bb08      	cbnz	r0, 802c1fe <FLASH_IF_Write+0x11a>
        if (FLASH_IF_Write_Buffer(idx * FLASH_PAGE_SIZE + FLASH_BASE, dataTempPage, FLASH_PAGE_SIZE) != FLASH_OK)
 802c1ba:	f44f 6200 	mov.w	r2, #2048	; 0x800
 802c1be:	4651      	mov	r1, sl
 802c1c0:	4620      	mov	r0, r4
 802c1c2:	f7ff ff55 	bl	802c070 <FLASH_IF_Write_Buffer>
 802c1c6:	b188      	cbz	r0, 802c1ec <FLASH_IF_Write+0x108>
          status = FLASH_WRITE_ERROR;
 802c1c8:	f06f 0002 	mvn.w	r0, #2
 802c1cc:	e7aa      	b.n	802c124 <FLASH_IF_Write+0x40>
    if (*addr64++ != UINT64_MAX)
 802c1ce:	e8f4 0102 	ldrd	r0, r1, [r4], #8
 802c1d2:	3101      	adds	r1, #1
 802c1d4:	bf08      	it	eq
 802c1d6:	f1b0 3fff 	cmpeq.w	r0, #4294967295
 802c1da:	d1d4      	bne.n	802c186 <FLASH_IF_Write+0xa2>
  for (i = 0; i < (size / sizeof(uint64_t)); i++)
 802c1dc:	f10c 0c01 	add.w	ip, ip, #1
 802c1e0:	e7c2      	b.n	802c168 <FLASH_IF_Write+0x84>
  {
    if (*addr++ != UINT8_MAX)
 802c1e2:	f814 1b01 	ldrb.w	r1, [r4], #1
 802c1e6:	29ff      	cmp	r1, #255	; 0xff
 802c1e8:	d0c3      	beq.n	802c172 <FLASH_IF_Write+0x8e>
 802c1ea:	e7cc      	b.n	802c186 <FLASH_IF_Write+0xa2>
    curr_src_addr += curr_size;
 802c1ec:	445f      	add	r7, fp
  for (uint32_t idx = page_start_index; idx <= page_end_index; idx++)
 802c1ee:	9d01      	ldr	r5, [sp, #4]
    curr_size = size - curr_size;
 802c1f0:	eba9 0b0b 	sub.w	fp, r9, fp
  for (uint32_t idx = page_start_index; idx <= page_end_index; idx++)
 802c1f4:	3601      	adds	r6, #1
 802c1f6:	e7a7      	b.n	802c148 <FLASH_IF_Write+0x64>
    return FLASH_LOCK_ERROR;
 802c1f8:	f06f 0003 	mvn.w	r0, #3
 802c1fc:	e792      	b.n	802c124 <FLASH_IF_Write+0x40>
        status = FLASH_ERASE_ERROR;
 802c1fe:	f06f 0001 	mvn.w	r0, #1
 802c202:	e78f      	b.n	802c124 <FLASH_IF_Write+0x40>
 802c204:	1fff75e0 	.word	0x1fff75e0
 802c208:	03fffc00 	.word	0x03fffc00
 802c20c:	58004000 	.word	0x58004000

0802c210 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 802c210:	b500      	push	{lr}
 802c212:	b09b      	sub	sp, #108	; 0x6c
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 802c214:	2248      	movs	r2, #72	; 0x48
 802c216:	2100      	movs	r1, #0
 802c218:	a808      	add	r0, sp, #32
 802c21a:	f00f fab3 	bl	803b784 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 802c21e:	221c      	movs	r2, #28
 802c220:	2100      	movs	r1, #0
 802c222:	a801      	add	r0, sp, #4
 802c224:	f00f faae 	bl	803b784 <memset>

  /** Configure LSE Drive Capability
  */
  HAL_PWR_EnableBkUpAccess();
 802c228:	f002 fa82 	bl	802e730 <HAL_PWR_EnableBkUpAccess>
  *         @arg @ref LL_RCC_LSEDRIVE_HIGH
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSE_SetDriveCapability(uint32_t LSEDrive)
{
  MODIFY_REG(RCC->BDCR, RCC_BDCR_LSEDRV, LSEDrive);
 802c22c:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
  /** Initializes the CPU, AHB and APB busses clocks
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSE|RCC_OSCILLATORTYPE_MSI;
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
  RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
 802c230:	2001      	movs	r0, #1
 802c232:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 802c236:	f023 0318 	bic.w	r3, r3, #24
 802c23a:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 802c23e:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
 802c242:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 802c246:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 802c24a:	f8c2 3400 	str.w	r3, [r2, #1024]	; 0x400
 802c24e:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
 802c252:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 802c256:	9300      	str	r3, [sp, #0]
 802c258:	9b00      	ldr	r3, [sp, #0]
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSE|RCC_OSCILLATORTYPE_MSI;
 802c25a:	2324      	movs	r3, #36	; 0x24
 802c25c:	9308      	str	r3, [sp, #32]
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 802c25e:	2381      	movs	r3, #129	; 0x81
 802c260:	930b      	str	r3, [sp, #44]	; 0x2c
  RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
 802c262:	2300      	movs	r3, #0
 802c264:	e9cd 0310 	strd	r0, r3, [sp, #64]	; 0x40
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_11;
 802c268:	22b0      	movs	r2, #176	; 0xb0
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 802c26a:	a808      	add	r0, sp, #32
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 802c26c:	e9cd 2312 	strd	r2, r3, [sp, #72]	; 0x48
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 802c270:	f002 fbde 	bl	802ea30 <HAL_RCC_OscConfig>
 802c274:	b108      	cbz	r0, 802c27a <SystemClock_Config+0x6a>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 802c276:	b672      	cpsid	i
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 802c278:	e7fe      	b.n	802c278 <SystemClock_Config+0x68>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK3|RCC_CLOCKTYPE_HCLK
 802c27a:	234f      	movs	r3, #79	; 0x4f
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
 802c27c:	e9cd 3001 	strd	r3, r0, [sp, #4]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 802c280:	e9cd 0003 	strd	r0, r0, [sp, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 802c284:	9005      	str	r0, [sp, #20]
  RCC_ClkInitStruct.AHBCLK3Divider = RCC_SYSCLK_DIV1;
 802c286:	9007      	str	r0, [sp, #28]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
 802c288:	2102      	movs	r1, #2
 802c28a:	a801      	add	r0, sp, #4
 802c28c:	f002 fe70 	bl	802ef70 <HAL_RCC_ClockConfig>
 802c290:	b108      	cbz	r0, 802c296 <SystemClock_Config+0x86>
 802c292:	b672      	cpsid	i
  while (1)
 802c294:	e7fe      	b.n	802c294 <SystemClock_Config+0x84>
}
 802c296:	b01b      	add	sp, #108	; 0x6c
 802c298:	f85d fb04 	ldr.w	pc, [sp], #4

0802c29c <main>:
{
 802c29c:	b508      	push	{r3, lr}
  HAL_Init();
 802c29e:	f001 f8ed 	bl	802d47c <HAL_Init>
  SystemClock_Config();
 802c2a2:	f7ff ffb5 	bl	802c210 <SystemClock_Config>
  MX_KMS_Init();
 802c2a6:	f000 fc3f 	bl	802cb28 <MX_KMS_Init>
  MX_LoRaWAN_Init();
 802c2aa:	f000 fc40 	bl	802cb2e <MX_LoRaWAN_Init>
    MX_LoRaWAN_Process();
 802c2ae:	f000 fc45 	bl	802cb3c <MX_LoRaWAN_Process>
  while (1)
 802c2b2:	e7fc      	b.n	802c2ae <main+0x12>

0802c2b4 <Error_Handler>:
 802c2b4:	b672      	cpsid	i
  while (1)
 802c2b6:	e7fe      	b.n	802c2b6 <Error_Handler+0x2>

0802c2b8 <MX_RTC_Init>:

RTC_HandleTypeDef hrtc;

/* RTC init function */
void MX_RTC_Init(void)
{
 802c2b8:	b500      	push	{lr}
 802c2ba:	b08d      	sub	sp, #52	; 0x34

  /* USER CODE BEGIN RTC_Init 0 */

  /* USER CODE END RTC_Init 0 */

  RTC_AlarmTypeDef sAlarm = {0};
 802c2bc:	222c      	movs	r2, #44	; 0x2c
 802c2be:	2100      	movs	r1, #0
 802c2c0:	a801      	add	r0, sp, #4
 802c2c2:	f00f fa5f 	bl	803b784 <memset>
  /* USER CODE BEGIN RTC_Init 1 */

  /* USER CODE END RTC_Init 1 */
  /** Initialize RTC Only
  */
  hrtc.Instance = RTC;
 802c2c6:	4817      	ldr	r0, [pc, #92]	; (802c324 <MX_RTC_Init+0x6c>)
 802c2c8:	4b17      	ldr	r3, [pc, #92]	; (802c328 <MX_RTC_Init+0x70>)
 802c2ca:	6003      	str	r3, [r0, #0]
  hrtc.Init.AsynchPrediv = RTC_PREDIV_A;
 802c2cc:	231f      	movs	r3, #31
 802c2ce:	6083      	str	r3, [r0, #8]
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
  hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
 802c2d0:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
 802c2d4:	2300      	movs	r3, #0
  hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
 802c2d6:	e9c0 3304 	strd	r3, r3, [r0, #16]
  hrtc.Init.OutPutPullUp = RTC_OUTPUT_PULLUP_NONE;
 802c2da:	e9c0 2307 	strd	r2, r3, [r0, #28]
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
 802c2de:	6183      	str	r3, [r0, #24]
  hrtc.Init.BinMode = RTC_BINARY_ONLY;
 802c2e0:	f44f 7380 	mov.w	r3, #256	; 0x100
 802c2e4:	6243      	str	r3, [r0, #36]	; 0x24
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
 802c2e6:	f003 f90f 	bl	802f508 <HAL_RTC_Init>
 802c2ea:	b108      	cbz	r0, 802c2f0 <MX_RTC_Init+0x38>
  {
    Error_Handler();
 802c2ec:	f7ff ffe2 	bl	802c2b4 <Error_Handler>

  /* USER CODE END Check_RTC_BKUP */

  /** Initialize RTC and set the Time and Date
  */
  if (HAL_RTCEx_SetSSRU_IT(&hrtc) != HAL_OK)
 802c2f0:	480c      	ldr	r0, [pc, #48]	; (802c324 <MX_RTC_Init+0x6c>)
 802c2f2:	f003 fa2d 	bl	802f750 <HAL_RTCEx_SetSSRU_IT>
 802c2f6:	b108      	cbz	r0, 802c2fc <MX_RTC_Init+0x44>
  {
    Error_Handler();
 802c2f8:	f7ff ffdc 	bl	802c2b4 <Error_Handler>
  /** Enable the Alarm A
  */
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
  sAlarm.AlarmTime.SubSeconds = 0x0;
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDBINMASK_NONE;
 802c2fc:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
 802c300:	2200      	movs	r2, #0
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDBINMASK_NONE;
 802c302:	9307      	str	r3, [sp, #28]
  sAlarm.Alarm = RTC_ALARM_A;
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, 0) != HAL_OK)
 802c304:	4807      	ldr	r0, [pc, #28]	; (802c324 <MX_RTC_Init+0x6c>)
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
 802c306:	9208      	str	r2, [sp, #32]
  sAlarm.Alarm = RTC_ALARM_A;
 802c308:	f44f 7380 	mov.w	r3, #256	; 0x100
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, 0) != HAL_OK)
 802c30c:	a901      	add	r1, sp, #4
  sAlarm.AlarmTime.SubSeconds = 0x0;
 802c30e:	9202      	str	r2, [sp, #8]
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
 802c310:	9206      	str	r2, [sp, #24]
  sAlarm.Alarm = RTC_ALARM_A;
 802c312:	930b      	str	r3, [sp, #44]	; 0x2c
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, 0) != HAL_OK)
 802c314:	f003 f954 	bl	802f5c0 <HAL_RTC_SetAlarm_IT>
 802c318:	b108      	cbz	r0, 802c31e <MX_RTC_Init+0x66>
  {
    Error_Handler();
 802c31a:	f7ff ffcb 	bl	802c2b4 <Error_Handler>
  }
  /* USER CODE BEGIN RTC_Init 2 */

  /* USER CODE END RTC_Init 2 */

}
 802c31e:	b00d      	add	sp, #52	; 0x34
 802c320:	f85d fb04 	ldr.w	pc, [sp], #4
 802c324:	200061b8 	.word	0x200061b8
 802c328:	40002800 	.word	0x40002800

0802c32c <HAL_RTC_MspInit>:

void HAL_RTC_MspInit(RTC_HandleTypeDef* rtcHandle)
{
 802c32c:	b510      	push	{r4, lr}
 802c32e:	4604      	mov	r4, r0
 802c330:	b090      	sub	sp, #64	; 0x40

  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 802c332:	2238      	movs	r2, #56	; 0x38
 802c334:	2100      	movs	r1, #0
 802c336:	a802      	add	r0, sp, #8
 802c338:	f00f fa24 	bl	803b784 <memset>
  if(rtcHandle->Instance==RTC)
 802c33c:	6822      	ldr	r2, [r4, #0]
 802c33e:	4b19      	ldr	r3, [pc, #100]	; (802c3a4 <HAL_RTC_MspInit+0x78>)
 802c340:	429a      	cmp	r2, r3
 802c342:	d12c      	bne.n	802c39e <HAL_RTC_MspInit+0x72>
  /* USER CODE BEGIN RTC_MspInit 0 */

  /* USER CODE END RTC_MspInit 0 */
  /** Initializes the peripherals clocks
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 802c344:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 802c348:	9302      	str	r3, [sp, #8]
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;

    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 802c34a:	a802      	add	r0, sp, #8
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
 802c34c:	f44f 7380 	mov.w	r3, #256	; 0x100
 802c350:	930f      	str	r3, [sp, #60]	; 0x3c
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 802c352:	f002 ff49 	bl	802f1e8 <HAL_RCCEx_PeriphCLKConfig>
 802c356:	b108      	cbz	r0, 802c35c <HAL_RTC_MspInit+0x30>
    {
      Error_Handler();
 802c358:	f7ff ffac 	bl	802c2b4 <Error_Handler>
  * @rmtoll BDCR         RTCEN         LL_RCC_EnableRTC
  * @retval None
  */
__STATIC_INLINE void LL_RCC_EnableRTC(void)
{
  SET_BIT(RCC->BDCR, RCC_BDCR_RTCEN);
 802c35c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
    /* RTC clock enable */
    __HAL_RCC_RTC_ENABLE();
    __HAL_RCC_RTCAPB_CLK_ENABLE();

    /* RTC interrupt Init */
    HAL_NVIC_SetPriority(TAMP_STAMP_LSECSS_SSRU_IRQn, 0, 0);
 802c360:	2002      	movs	r0, #2
 802c362:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 802c366:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 802c36a:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  SET_BIT(RCC->APB1ENR1, Periphs);
 802c36e:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 802c370:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 802c374:	659a      	str	r2, [r3, #88]	; 0x58
  tmpreg = READ_BIT(RCC->APB1ENR1, Periphs);
 802c376:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 802c378:	2200      	movs	r2, #0
 802c37a:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 802c37e:	4611      	mov	r1, r2
 802c380:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 802c382:	9b01      	ldr	r3, [sp, #4]
 802c384:	f001 fcec 	bl	802dd60 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TAMP_STAMP_LSECSS_SSRU_IRQn);
 802c388:	2002      	movs	r0, #2
 802c38a:	f001 fd1b 	bl	802ddc4 <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(RTC_Alarm_IRQn, 0, 0);
 802c38e:	2200      	movs	r2, #0
 802c390:	202a      	movs	r0, #42	; 0x2a
 802c392:	4611      	mov	r1, r2
 802c394:	f001 fce4 	bl	802dd60 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(RTC_Alarm_IRQn);
 802c398:	202a      	movs	r0, #42	; 0x2a
 802c39a:	f001 fd13 	bl	802ddc4 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN RTC_MspInit 1 */

  /* USER CODE END RTC_MspInit 1 */
  }
}
 802c39e:	b010      	add	sp, #64	; 0x40
 802c3a0:	bd10      	pop	{r4, pc}
 802c3a2:	bf00      	nop
 802c3a4:	40002800 	.word	0x40002800

0802c3a8 <PWR_EnterOffMode>:
void PWR_EnterOffMode(void)
{
  /* USER CODE BEGIN EnterOffMode_1 */

  /* USER CODE END EnterOffMode_1 */
}
 802c3a8:	4770      	bx	lr
	...

0802c3ac <PWR_EnterStopMode>:

  /* USER CODE END ExitOffMode_1 */
}

void PWR_EnterStopMode(void)
{
 802c3ac:	b508      	push	{r3, lr}
  /* USER CODE BEGIN EnterStopMode_1 */

  /* USER CODE END EnterStopMode_1 */
  HAL_SuspendTick();
 802c3ae:	f001 f87b 	bl	802d4a8 <HAL_SuspendTick>
  * @rmtoll EXTSCR       C1CSSF        LL_PWR_ClearFlag_C1STOP_C1STB
  * @retval None
  */
__STATIC_INLINE void LL_PWR_ClearFlag_C1STOP_C1STB(void)
{
  WRITE_REG(PWR->EXTSCR, PWR_EXTSCR_C1CSSF);
 802c3b2:	4b04      	ldr	r3, [pc, #16]	; (802c3c4 <PWR_EnterStopMode+0x18>)
 802c3b4:	2001      	movs	r0, #1
 802c3b6:	f8c3 0088 	str.w	r0, [r3, #136]	; 0x88
  /* USER CODE END EnterStopMode_2 */
  HAL_PWREx_EnterSTOP2Mode(PWR_STOPENTRY_WFI);
  /* USER CODE BEGIN EnterStopMode_3 */

  /* USER CODE END EnterStopMode_3 */
}
 802c3ba:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_PWREx_EnterSTOP2Mode(PWR_STOPENTRY_WFI);
 802c3be:	f002 ba11 	b.w	802e7e4 <HAL_PWREx_EnterSTOP2Mode>
 802c3c2:	bf00      	nop
 802c3c4:	58000400 	.word	0x58000400

0802c3c8 <PWR_ExitSleepMode>:
{
  /* USER CODE BEGIN ExitSleepMode_1 */

  /* USER CODE END ExitSleepMode_1 */
  /* Suspend sysTick */
  HAL_ResumeTick();
 802c3c8:	f001 b876 	b.w	802d4b8 <HAL_ResumeTick>

0802c3cc <PWR_ExitStopMode>:
{
 802c3cc:	b508      	push	{r3, lr}
  HAL_ResumeTick();
 802c3ce:	f001 f873 	bl	802d4b8 <HAL_ResumeTick>
}
 802c3d2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  vcom_Resume();
 802c3d6:	f000 bb77 	b.w	802cac8 <vcom_Resume>

0802c3da <PWR_EnterSleepMode>:
{
 802c3da:	b508      	push	{r3, lr}
  HAL_SuspendTick();
 802c3dc:	f001 f864 	bl	802d4a8 <HAL_SuspendTick>
}
 802c3e0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_SLEEPENTRY_WFI);
 802c3e4:	2101      	movs	r1, #1
 802c3e6:	2000      	movs	r0, #0
 802c3e8:	f002 b9aa 	b.w	802e740 <HAL_PWR_EnterSLEEPMode>

0802c3ec <PWR_ExitOffMode>:
 802c3ec:	4770      	bx	lr

0802c3ee <HAL_MspInit>:
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 802c3ee:	4770      	bx	lr

0802c3f0 <NMI_Handler>:
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 802c3f0:	e7fe      	b.n	802c3f0 <NMI_Handler>

0802c3f2 <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 802c3f2:	e7fe      	b.n	802c3f2 <HardFault_Handler>

0802c3f4 <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 802c3f4:	e7fe      	b.n	802c3f4 <MemManage_Handler>

0802c3f6 <BusFault_Handler>:
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 802c3f6:	e7fe      	b.n	802c3f6 <BusFault_Handler>

0802c3f8 <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 802c3f8:	e7fe      	b.n	802c3f8 <UsageFault_Handler>

0802c3fa <SVC_Handler>:

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 802c3fa:	4770      	bx	lr

0802c3fc <DebugMon_Handler>:
 802c3fc:	4770      	bx	lr

0802c3fe <PendSV_Handler>:
 802c3fe:	4770      	bx	lr

0802c400 <SysTick_Handler>:
 802c400:	4770      	bx	lr
	...

0802c404 <TAMP_STAMP_LSECSS_SSRU_IRQHandler>:
void TAMP_STAMP_LSECSS_SSRU_IRQHandler(void)
{
  /* USER CODE BEGIN TAMP_STAMP_LSECSS_SSRU_IRQn 0 */

  /* USER CODE END TAMP_STAMP_LSECSS_SSRU_IRQn 0 */
  HAL_RTCEx_SSRUIRQHandler(&hrtc);
 802c404:	4801      	ldr	r0, [pc, #4]	; (802c40c <TAMP_STAMP_LSECSS_SSRU_IRQHandler+0x8>)
 802c406:	f003 b9c9 	b.w	802f79c <HAL_RTCEx_SSRUIRQHandler>
 802c40a:	bf00      	nop
 802c40c:	200061b8 	.word	0x200061b8

0802c410 <EXTI0_IRQHandler>:
void EXTI0_IRQHandler(void)
{
  /* USER CODE BEGIN EXTI0_IRQn 0 */

  /* USER CODE END EXTI0_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_0);
 802c410:	2001      	movs	r0, #1
 802c412:	f002 b981 	b.w	802e718 <HAL_GPIO_EXTI_IRQHandler>

0802c416 <EXTI1_IRQHandler>:
void EXTI1_IRQHandler(void)
{
  /* USER CODE BEGIN EXTI1_IRQn 0 */

  /* USER CODE END EXTI1_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_1);
 802c416:	2002      	movs	r0, #2
 802c418:	f002 b97e 	b.w	802e718 <HAL_GPIO_EXTI_IRQHandler>

0802c41c <DMA1_Channel5_IRQHandler>:
void DMA1_Channel5_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Channel5_IRQn 0 */

  /* USER CODE END DMA1_Channel5_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_usart2_tx);
 802c41c:	4801      	ldr	r0, [pc, #4]	; (802c424 <DMA1_Channel5_IRQHandler+0x8>)
 802c41e:	f001 beaf 	b.w	802e180 <HAL_DMA_IRQHandler>
 802c422:	bf00      	nop
 802c424:	200061fc 	.word	0x200061fc

0802c428 <USART2_IRQHandler>:
void USART2_IRQHandler(void)
{
  /* USER CODE BEGIN USART2_IRQn 0 */

  /* USER CODE END USART2_IRQn 0 */
  HAL_UART_IRQHandler(&huart2);
 802c428:	4801      	ldr	r0, [pc, #4]	; (802c430 <USART2_IRQHandler+0x8>)
 802c42a:	f003 bd87 	b.w	802ff3c <HAL_UART_IRQHandler>
 802c42e:	bf00      	nop
 802c430:	2000625c 	.word	0x2000625c

0802c434 <RTC_Alarm_IRQHandler>:
void RTC_Alarm_IRQHandler(void)
{
  /* USER CODE BEGIN RTC_Alarm_IRQn 0 */

  /* USER CODE END RTC_Alarm_IRQn 0 */
  HAL_RTC_AlarmIRQHandler(&hrtc);
 802c434:	4801      	ldr	r0, [pc, #4]	; (802c43c <RTC_Alarm_IRQHandler+0x8>)
 802c436:	f002 bfe9 	b.w	802f40c <HAL_RTC_AlarmIRQHandler>
 802c43a:	bf00      	nop
 802c43c:	200061b8 	.word	0x200061b8

0802c440 <SUBGHZ_Radio_IRQHandler>:
void SUBGHZ_Radio_IRQHandler(void)
{
  /* USER CODE BEGIN SUBGHZ_Radio_IRQn 0 */

  /* USER CODE END SUBGHZ_Radio_IRQn 0 */
  HAL_SUBGHZ_IRQHandler(&hsubghz);
 802c440:	4801      	ldr	r0, [pc, #4]	; (802c448 <SUBGHZ_Radio_IRQHandler+0x8>)
 802c442:	f003 bc3c 	b.w	802fcbe <HAL_SUBGHZ_IRQHandler>
 802c446:	bf00      	nop
 802c448:	200061f0 	.word	0x200061f0

0802c44c <MX_SUBGHZ_Init>:
  /* USER CODE END SUBGHZ_Init 0 */

  /* USER CODE BEGIN SUBGHZ_Init 1 */

  /* USER CODE END SUBGHZ_Init 1 */
  hsubghz.Init.BaudratePrescaler = SUBGHZSPI_BAUDRATEPRESCALER_4;
 802c44c:	4805      	ldr	r0, [pc, #20]	; (802c464 <MX_SUBGHZ_Init+0x18>)
{
 802c44e:	b508      	push	{r3, lr}
  hsubghz.Init.BaudratePrescaler = SUBGHZSPI_BAUDRATEPRESCALER_4;
 802c450:	2308      	movs	r3, #8
 802c452:	6003      	str	r3, [r0, #0]
  if (HAL_SUBGHZ_Init(&hsubghz) != HAL_OK)
 802c454:	f003 f9e8 	bl	802f828 <HAL_SUBGHZ_Init>
 802c458:	b118      	cbz	r0, 802c462 <MX_SUBGHZ_Init+0x16>
  }
  /* USER CODE BEGIN SUBGHZ_Init 2 */

  /* USER CODE END SUBGHZ_Init 2 */

}
 802c45a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 802c45e:	f7ff bf29 	b.w	802c2b4 <Error_Handler>
}
 802c462:	bd08      	pop	{r3, pc}
 802c464:	200061f0 	.word	0x200061f0

0802c468 <HAL_SUBGHZ_MspInit>:
  * @retval None
  */
__STATIC_INLINE void LL_APB3_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB3ENR, Periphs);
 802c468:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000

void HAL_SUBGHZ_MspInit(SUBGHZ_HandleTypeDef* subghzHandle)
{
 802c46c:	b507      	push	{r0, r1, r2, lr}
 802c46e:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 802c470:	f042 0201 	orr.w	r2, r2, #1
 802c474:	665a      	str	r2, [r3, #100]	; 0x64
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB3ENR, Periphs);
 802c476:	6e5b      	ldr	r3, [r3, #100]	; 0x64
  /* USER CODE END SUBGHZ_MspInit 0 */
    /* SUBGHZ clock enable */
    __HAL_RCC_SUBGHZSPI_CLK_ENABLE();

    /* SUBGHZ interrupt Init */
    HAL_NVIC_SetPriority(SUBGHZ_Radio_IRQn, 0, 0);
 802c478:	2200      	movs	r2, #0
 802c47a:	f003 0301 	and.w	r3, r3, #1
 802c47e:	9301      	str	r3, [sp, #4]
 802c480:	4611      	mov	r1, r2
 802c482:	2032      	movs	r0, #50	; 0x32
  (void)tmpreg;
 802c484:	9b01      	ldr	r3, [sp, #4]
 802c486:	f001 fc6b 	bl	802dd60 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SUBGHZ_Radio_IRQn);
 802c48a:	2032      	movs	r0, #50	; 0x32
  /* USER CODE BEGIN SUBGHZ_MspInit 1 */

  /* USER CODE END SUBGHZ_MspInit 1 */
}
 802c48c:	b003      	add	sp, #12
 802c48e:	f85d eb04 	ldr.w	lr, [sp], #4
    HAL_NVIC_EnableIRQ(SUBGHZ_Radio_IRQn);
 802c492:	f001 bc97 	b.w	802ddc4 <HAL_NVIC_EnableIRQ>
	...

0802c498 <tiny_snprintf_like.constprop.0>:
  /* USER CODE BEGIN UTIL_LPM_SetStopMode_2 */

  /* USER CODE END UTIL_LPM_SetStopMode_2 */
}

static void tiny_snprintf_like(char *buf, uint32_t maxsize, const char *strFormat, ...)
 802c498:	b40c      	push	{r2, r3}
 802c49a:	b507      	push	{r0, r1, r2, lr}
  /* USER CODE BEGIN tiny_snprintf_like_1 */

  /* USER CODE END tiny_snprintf_like_1 */
  va_list vaArgs;
  va_start(vaArgs, strFormat);
  UTIL_ADV_TRACE_VSNPRINTF(buf, maxsize, strFormat, vaArgs);
 802c49c:	4a05      	ldr	r2, [pc, #20]	; (802c4b4 <tiny_snprintf_like.constprop.0+0x1c>)
  va_start(vaArgs, strFormat);
 802c49e:	ab05      	add	r3, sp, #20
  UTIL_ADV_TRACE_VSNPRINTF(buf, maxsize, strFormat, vaArgs);
 802c4a0:	2110      	movs	r1, #16
  va_start(vaArgs, strFormat);
 802c4a2:	9301      	str	r3, [sp, #4]
  UTIL_ADV_TRACE_VSNPRINTF(buf, maxsize, strFormat, vaArgs);
 802c4a4:	f00f f830 	bl	803b508 <tiny_vsnprintf_like>
  va_end(vaArgs);
  /* USER CODE BEGIN tiny_snprintf_like_2 */

  /* USER CODE END tiny_snprintf_like_2 */
}
 802c4a8:	b003      	add	sp, #12
 802c4aa:	f85d eb04 	ldr.w	lr, [sp], #4
 802c4ae:	b002      	add	sp, #8
 802c4b0:	4770      	bx	lr
 802c4b2:	bf00      	nop
 802c4b4:	0803bd93 	.word	0x0803bd93

0802c4b8 <TimestampNow>:
{
 802c4b8:	b530      	push	{r4, r5, lr}
 802c4ba:	b085      	sub	sp, #20
 802c4bc:	4604      	mov	r4, r0
  SysTime_t curtime = SysTimeGet();
 802c4be:	a802      	add	r0, sp, #8
{
 802c4c0:	460d      	mov	r5, r1
  SysTime_t curtime = SysTimeGet();
 802c4c2:	f00e fe4d 	bl	803b160 <SysTimeGet>
  tiny_snprintf_like((char *)buff, MAX_TS_SIZE, "%ds%03d:", curtime.Seconds, curtime.SubSeconds);
 802c4c6:	f9bd 300c 	ldrsh.w	r3, [sp, #12]
 802c4ca:	4a06      	ldr	r2, [pc, #24]	; (802c4e4 <TimestampNow+0x2c>)
 802c4cc:	9300      	str	r3, [sp, #0]
 802c4ce:	2110      	movs	r1, #16
 802c4d0:	9b02      	ldr	r3, [sp, #8]
 802c4d2:	4620      	mov	r0, r4
 802c4d4:	f7ff ffe0 	bl	802c498 <tiny_snprintf_like.constprop.0>
  *size = strlen((char *)buff);
 802c4d8:	4620      	mov	r0, r4
 802c4da:	f7fe ffb1 	bl	802b440 <strlen>
 802c4de:	8028      	strh	r0, [r5, #0]
}
 802c4e0:	b005      	add	sp, #20
 802c4e2:	bd30      	pop	{r4, r5, pc}
 802c4e4:	0803bd93 	.word	0x0803bd93

0802c4e8 <SystemApp_Init>:
  MODIFY_REG(RCC->CFGR, RCC_CFGR_STOPWUCK, Clock);
 802c4e8:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
{
 802c4ec:	b508      	push	{r3, lr}
 802c4ee:	6893      	ldr	r3, [r2, #8]
 802c4f0:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 802c4f4:	6093      	str	r3, [r2, #8]
  UTIL_TIMER_Init();
 802c4f6:	f00e feb9 	bl	803b26c <UTIL_TIMER_Init>
  DBG_Disable();
 802c4fa:	f000 f8be 	bl	802c67a <DBG_Disable>
  DBG_ProbesInit();
 802c4fe:	f000 f8bf 	bl	802c680 <DBG_ProbesInit>
  UTIL_ADV_TRACE_Init();
 802c502:	f00e fb91 	bl	803ac28 <UTIL_ADV_TRACE_Init>
  UTIL_ADV_TRACE_RegisterTimeStampFunction(TimestampNow);
 802c506:	480d      	ldr	r0, [pc, #52]	; (802c53c <SystemApp_Init+0x54>)
 802c508:	f00e fba8 	bl	803ac5c <UTIL_ADV_TRACE_RegisterTimeStampFunction>
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPTVERR);
 802c50c:	4b0c      	ldr	r3, [pc, #48]	; (802c540 <SystemApp_Init+0x58>)
 802c50e:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 802c512:	611a      	str	r2, [r3, #16]
  UTIL_ADV_TRACE_SetVerboseLevel(VERBOSE_LEVEL);
 802c514:	2003      	movs	r0, #3
 802c516:	f00e fba7 	bl	803ac68 <UTIL_ADV_TRACE_SetVerboseLevel>
  SYS_InitMeasurement();
 802c51a:	f7ff fd0f 	bl	802bf3c <SYS_InitMeasurement>
  EnvSensors_Init();
 802c51e:	f000 f8b9 	bl	802c694 <EnvSensors_Init>
  UTIL_LPM_Init();
 802c522:	f00e fc9f 	bl	803ae64 <UTIL_LPM_Init>
  UTIL_LPM_SetOffMode((1 << CFG_LPM_APPLI_Id), UTIL_LPM_DISABLE);
 802c526:	2101      	movs	r1, #1
 802c528:	4608      	mov	r0, r1
 802c52a:	f00e fcb9 	bl	803aea0 <UTIL_LPM_SetOffMode>
  UTIL_LPM_SetStopMode((1 << CFG_LPM_APPLI_Id), UTIL_LPM_DISABLE);
 802c52e:	2101      	movs	r1, #1
}
 802c530:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  UTIL_LPM_SetStopMode((1 << CFG_LPM_APPLI_Id), UTIL_LPM_DISABLE);
 802c534:	4608      	mov	r0, r1
 802c536:	f00e bc9d 	b.w	803ae74 <UTIL_LPM_SetStopMode>
 802c53a:	bf00      	nop
 802c53c:	0802c4b9 	.word	0x0802c4b9
 802c540:	58004000 	.word	0x58004000

0802c544 <UTIL_SEQ_Idle>:
  UTIL_LPM_EnterLowPower();
 802c544:	f00e bcc2 	b.w	803aecc <UTIL_LPM_EnterLowPower>

0802c548 <GetBatteryLevel>:
{
 802c548:	b513      	push	{r0, r1, r4, lr}
  batteryLevelmV = (uint16_t) SYS_GetBatteryLevel();
 802c54a:	f7ff fcff 	bl	802bf4c <SYS_GetBatteryLevel>
  if (batteryLevelmV > VDD_BAT)
 802c54e:	f640 33b8 	movw	r3, #3000	; 0xbb8
 802c552:	4298      	cmp	r0, r3
 802c554:	d815      	bhi.n	802c582 <GetBatteryLevel+0x3a>
  else if (batteryLevelmV < VDD_MIN)
 802c556:	f5b0 6fe1 	cmp.w	r0, #1800	; 0x708
 802c55a:	d314      	bcc.n	802c586 <GetBatteryLevel+0x3e>
    batteryLevel = (((uint32_t)(batteryLevelmV - VDD_MIN) * LORAWAN_MAX_BAT) / (VDD_BAT - VDD_MIN));
 802c55c:	f5a0 60e1 	sub.w	r0, r0, #1800	; 0x708
 802c560:	24fe      	movs	r4, #254	; 0xfe
 802c562:	4344      	muls	r4, r0
 802c564:	f44f 6396 	mov.w	r3, #1200	; 0x4b0
 802c568:	fbb4 f4f3 	udiv	r4, r4, r3
 802c56c:	b2e4      	uxtb	r4, r4
  APP_LOG(TS_ON, VLEVEL_M, "VDDA= %d\r\n", batteryLevel);
 802c56e:	4b07      	ldr	r3, [pc, #28]	; (802c58c <GetBatteryLevel+0x44>)
 802c570:	9400      	str	r4, [sp, #0]
 802c572:	2201      	movs	r2, #1
 802c574:	2100      	movs	r1, #0
 802c576:	2002      	movs	r0, #2
 802c578:	f00e fbbe 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
}
 802c57c:	4620      	mov	r0, r4
 802c57e:	b002      	add	sp, #8
 802c580:	bd10      	pop	{r4, pc}
    batteryLevel = LORAWAN_MAX_BAT;
 802c582:	24fe      	movs	r4, #254	; 0xfe
 802c584:	e7f3      	b.n	802c56e <GetBatteryLevel+0x26>
    batteryLevel = 0;
 802c586:	2400      	movs	r4, #0
 802c588:	e7f1      	b.n	802c56e <GetBatteryLevel+0x26>
 802c58a:	bf00      	nop
 802c58c:	0803bd9c 	.word	0x0803bd9c

0802c590 <GetTemperatureLevel>:
{
 802c590:	b508      	push	{r3, lr}
  temperatureLevel = (uint16_t)(SYS_GetTemperatureLevel() / 256);
 802c592:	f7ff fcf5 	bl	802bf80 <SYS_GetTemperatureLevel>
 802c596:	2800      	cmp	r0, #0
 802c598:	bfb8      	it	lt
 802c59a:	30ff      	addlt	r0, #255	; 0xff
}
 802c59c:	f3c0 200f 	ubfx	r0, r0, #8, #16
 802c5a0:	bd08      	pop	{r3, pc}
	...

0802c5a4 <GetUniqueId>:
{
 802c5a4:	b538      	push	{r3, r4, r5, lr}
  * @brief  Return the Unique Device Number
  * @retval Values between Min_Data=0x00000000 and Max_Data=0xFFFFFFFF
  */
__STATIC_INLINE uint32_t LL_FLASH_GetUDN(void)
{
  return (READ_REG(*((uint32_t *)UID64_BASE)));
 802c5a6:	4b17      	ldr	r3, [pc, #92]	; (802c604 <GetUniqueId+0x60>)
 802c5a8:	681b      	ldr	r3, [r3, #0]
  if (val == 0xFFFFFFFF)  /* Normally this should not happen */
 802c5aa:	1c5a      	adds	r2, r3, #1
{
 802c5ac:	4604      	mov	r4, r0
  if (val == 0xFFFFFFFF)  /* Normally this should not happen */
 802c5ae:	d116      	bne.n	802c5de <GetUniqueId+0x3a>
    uint32_t ID_1_3_val = HAL_GetUIDw0() + HAL_GetUIDw2();
 802c5b0:	f000 ff8a 	bl	802d4c8 <HAL_GetUIDw0>
 802c5b4:	4605      	mov	r5, r0
 802c5b6:	f000 ff93 	bl	802d4e0 <HAL_GetUIDw2>
 802c5ba:	4405      	add	r5, r0
    uint32_t ID_2_val = HAL_GetUIDw1();
 802c5bc:	f000 ff8a 	bl	802d4d4 <HAL_GetUIDw1>
    id[7] = (ID_1_3_val) >> 24;
 802c5c0:	0e2b      	lsrs	r3, r5, #24
 802c5c2:	71e3      	strb	r3, [r4, #7]
    id[6] = (ID_1_3_val) >> 16;
 802c5c4:	0c2b      	lsrs	r3, r5, #16
 802c5c6:	71a3      	strb	r3, [r4, #6]
    id[5] = (ID_1_3_val) >> 8;
 802c5c8:	0a2b      	lsrs	r3, r5, #8
 802c5ca:	7163      	strb	r3, [r4, #5]
    id[3] = (ID_2_val) >> 24;
 802c5cc:	0e03      	lsrs	r3, r0, #24
 802c5ce:	70e3      	strb	r3, [r4, #3]
    id[2] = (ID_2_val) >> 16;
 802c5d0:	0c03      	lsrs	r3, r0, #16
 802c5d2:	70a3      	strb	r3, [r4, #2]
    id[1] = (ID_2_val) >> 8;
 802c5d4:	0a03      	lsrs	r3, r0, #8
    id[4] = (ID_1_3_val);
 802c5d6:	7125      	strb	r5, [r4, #4]
    id[1] = (ID_2_val) >> 8;
 802c5d8:	7063      	strb	r3, [r4, #1]
    id[0] = (ID_2_val);
 802c5da:	7020      	strb	r0, [r4, #0]
}
 802c5dc:	bd38      	pop	{r3, r4, r5, pc}
    id[6] = (val >> 8) & 0xFF;
 802c5de:	0a1a      	lsrs	r2, r3, #8
    id[7] = val & 0xFF;
 802c5e0:	71c3      	strb	r3, [r0, #7]
    id[6] = (val >> 8) & 0xFF;
 802c5e2:	7182      	strb	r2, [r0, #6]
    id[5] = (val >> 16) & 0xFF;
 802c5e4:	0c1a      	lsrs	r2, r3, #16
    id[4] = (val >> 24) & 0xFF;
 802c5e6:	0e1b      	lsrs	r3, r3, #24
 802c5e8:	7103      	strb	r3, [r0, #4]
  *         For STM32WLxxxx devices, the device ID is 0x15
  * @retval Values between Min_Data=0x00 and Max_Data=0xFF (ex: Device ID is 0x15)
  */
__STATIC_INLINE uint32_t LL_FLASH_GetDeviceID(void)
{
  return ((READ_REG(*((uint32_t *)UID64_BASE + 1U))) & 0x000000FFU);
 802c5ea:	4b07      	ldr	r3, [pc, #28]	; (802c608 <GetUniqueId+0x64>)
    id[5] = (val >> 16) & 0xFF;
 802c5ec:	7142      	strb	r2, [r0, #5]
    id[3] = val & 0xFF;
 802c5ee:	681a      	ldr	r2, [r3, #0]
 802c5f0:	70c2      	strb	r2, [r0, #3]
  * @note   For STM32WLxxxx devices, the ST Company ID is 0x0080E1
  * @retval Values between Min_Data=0x00 and Max_Data=0xFFFFFF (ex: ST Company ID is 0x0080E1)
  */
__STATIC_INLINE uint32_t LL_FLASH_GetSTCompanyID(void)
{
  return (((READ_REG(*((uint32_t *)UID64_BASE + 1U))) >> 8U) & 0x00FFFFFFU);
 802c5f2:	681b      	ldr	r3, [r3, #0]
 802c5f4:	0a1a      	lsrs	r2, r3, #8
    id[2] = val & 0xFF;
 802c5f6:	7082      	strb	r2, [r0, #2]
    id[1] = (val >> 8) & 0xFF;
 802c5f8:	0c1a      	lsrs	r2, r3, #16
    id[0] = (val >> 16) & 0xFF;
 802c5fa:	0e1b      	lsrs	r3, r3, #24
    id[1] = (val >> 8) & 0xFF;
 802c5fc:	7042      	strb	r2, [r0, #1]
    id[0] = (val >> 16) & 0xFF;
 802c5fe:	7003      	strb	r3, [r0, #0]
}
 802c600:	e7ec      	b.n	802c5dc <GetUniqueId+0x38>
 802c602:	bf00      	nop
 802c604:	1fff7580 	.word	0x1fff7580
 802c608:	1fff7584 	.word	0x1fff7584

0802c60c <GetDevAddr>:
  return (READ_REG(*((uint32_t *)UID64_BASE)));
 802c60c:	4b07      	ldr	r3, [pc, #28]	; (802c62c <GetDevAddr+0x20>)
 802c60e:	6818      	ldr	r0, [r3, #0]
  if (val == 0xFFFFFFFF)
 802c610:	1c43      	adds	r3, r0, #1
{
 802c612:	b510      	push	{r4, lr}
  if (val == 0xFFFFFFFF)
 802c614:	d108      	bne.n	802c628 <GetDevAddr+0x1c>
    val = ((HAL_GetUIDw0()) ^ (HAL_GetUIDw1()) ^ (HAL_GetUIDw2()));
 802c616:	f000 ff57 	bl	802d4c8 <HAL_GetUIDw0>
 802c61a:	4604      	mov	r4, r0
 802c61c:	f000 ff5a 	bl	802d4d4 <HAL_GetUIDw1>
 802c620:	4044      	eors	r4, r0
 802c622:	f000 ff5d 	bl	802d4e0 <HAL_GetUIDw2>
 802c626:	4060      	eors	r0, r4
}
 802c628:	bd10      	pop	{r4, pc}
 802c62a:	bf00      	nop
 802c62c:	1fff7580 	.word	0x1fff7580

0802c630 <UTIL_ADV_TRACE_PreSendHook>:
  UTIL_LPM_SetStopMode((1 << CFG_LPM_UART_TX_Id), UTIL_LPM_DISABLE);
 802c630:	2101      	movs	r1, #1
 802c632:	2002      	movs	r0, #2
 802c634:	f00e bc1e 	b.w	803ae74 <UTIL_LPM_SetStopMode>

0802c638 <UTIL_ADV_TRACE_PostSendHook>:
  UTIL_LPM_SetStopMode((1 << CFG_LPM_UART_TX_Id), UTIL_LPM_ENABLE);
 802c638:	2100      	movs	r1, #0
 802c63a:	2002      	movs	r0, #2
 802c63c:	f00e bc1a 	b.w	803ae74 <UTIL_LPM_SetStopMode>

0802c640 <HAL_InitTick>:
  /* USER CODE END HAL_InitTick_1 */
  return HAL_OK;
  /* USER CODE BEGIN HAL_InitTick_2 */

  /* USER CODE END HAL_InitTick_2 */
}
 802c640:	2000      	movs	r0, #0
 802c642:	4770      	bx	lr

0802c644 <HAL_GetTick>:
{
  /* TIMER_IF can be based on other counter the SysTick e.g. RTC */
  /* USER CODE BEGIN HAL_GetTick_1 */

  /* USER CODE END HAL_GetTick_1 */
  return TIMER_IF_GetTimerValue();
 802c644:	f000 b844 	b.w	802c6d0 <TIMER_IF_GetTimerValue>

0802c648 <HAL_Delay>:

/**
  * @note This function overwrites the __weak one from HAL
  */
void HAL_Delay(__IO uint32_t Delay)
{
 802c648:	b082      	sub	sp, #8
 802c64a:	9001      	str	r0, [sp, #4]
  /* TIMER_IF can be based on other counter the SysTick e.g. RTC */
  /* USER CODE BEGIN HAL_Delay_1 */

  /* USER CODE END HAL_Delay_1 */
  TIMER_IF_DelayMs(Delay);
 802c64c:	9801      	ldr	r0, [sp, #4]
  /* USER CODE BEGIN HAL_Delay_2 */

  /* USER CODE END HAL_Delay_2 */
}
 802c64e:	b002      	add	sp, #8
  TIMER_IF_DelayMs(Delay);
 802c650:	f000 b8f8 	b.w	802c844 <TIMER_IF_DelayMs>

0802c654 <DBG_ConfigForLpm>:
  enable_dbg = 0;
#elif !defined (DEBUGGER_ENABLED)
#error "DEBUGGER_ENABLED not defined or out of range <0,1>"
#endif /* DEBUGGER_OFF */

  if (enable_dbg == 1)
 802c654:	2801      	cmp	r0, #1
{
 802c656:	b508      	push	{r3, lr}
  if (enable_dbg == 1)
 802c658:	d107      	bne.n	802c66a <DBG_ConfigForLpm+0x16>
  {
    HAL_DBGMCU_EnableDBGSleepMode();
 802c65a:	f000 ff47 	bl	802d4ec <HAL_DBGMCU_EnableDBGSleepMode>
    HAL_DBGMCU_EnableDBGStopMode();
 802c65e:	f000 ff55 	bl	802d50c <HAL_DBGMCU_EnableDBGStopMode>
  }

  /* USER CODE BEGIN DBG_ConfigForLpm_Last */

  /* USER CODE END DBG_ConfigForLpm_Last */
}
 802c662:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    HAL_DBGMCU_EnableDBGStandbyMode();
 802c666:	f000 bf61 	b.w	802d52c <HAL_DBGMCU_EnableDBGStandbyMode>
    HAL_DBGMCU_DisableDBGSleepMode();
 802c66a:	f000 ff47 	bl	802d4fc <HAL_DBGMCU_DisableDBGSleepMode>
    HAL_DBGMCU_DisableDBGStopMode();
 802c66e:	f000 ff55 	bl	802d51c <HAL_DBGMCU_DisableDBGStopMode>
}
 802c672:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    HAL_DBGMCU_DisableDBGStandbyMode();
 802c676:	f000 bf61 	b.w	802d53c <HAL_DBGMCU_DisableDBGStandbyMode>

0802c67a <DBG_Disable>:
  DBG_ConfigForLpm(0);
 802c67a:	2000      	movs	r0, #0
 802c67c:	f7ff bfea 	b.w	802c654 <DBG_ConfigForLpm>

0802c680 <DBG_ProbesInit>:
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_EnableIT_32_63(uint32_t ExtiLine)
{
  SET_BIT(EXTI->IMR2, ExtiLine);
 802c680:	4a03      	ldr	r2, [pc, #12]	; (802c690 <DBG_ProbesInit+0x10>)
 802c682:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 802c686:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 802c68a:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
#endif /* CORE_CM4 */

  /* USER CODE BEGIN DBG_ProbesInit_Last */

  /* USER CODE END DBG_ProbesInit_Last */
}
 802c68e:	4770      	bx	lr
 802c690:	58000800 	.word	0x58000800

0802c694 <EnvSensors_Init>:
#elif !defined (SENSOR_ENABLED)
#error SENSOR_ENABLED not defined
#endif /* SENSOR_ENABLED  */
  return 0;
  /* USER CODE END EnvSensors_Init */
}
 802c694:	2000      	movs	r0, #0
 802c696:	4770      	bx	lr

0802c698 <TIMER_IF_SetTimerContext>:
  * @retval If binary mode is none, Value between Min_Data=0x0 and Max_Data=0x7FFF
  *         else Value between Min_Data=0x0 and Max_Data=0xFFFFFFFF
  */
__STATIC_INLINE uint32_t LL_RTC_TIME_GetSubSecond(RTC_TypeDef *RTCx)
{
  return (uint32_t)(READ_BIT(RTCx->SSR, RTC_SSR_SS));
 802c698:	4b02      	ldr	r3, [pc, #8]	; (802c6a4 <TIMER_IF_SetTimerContext+0xc>)
 802c69a:	6898      	ldr	r0, [r3, #8]
}

uint32_t TIMER_IF_SetTimerContext(void)
{
  /*store time context*/
  RtcTimerContext = GetTimerTicks();
 802c69c:	4b02      	ldr	r3, [pc, #8]	; (802c6a8 <TIMER_IF_SetTimerContext+0x10>)
static inline uint32_t GetTimerTicks(void)
{
  /* USER CODE BEGIN GetTimerTicks */

  /* USER CODE END GetTimerTicks */
  return (UINT32_MAX - LL_RTC_TIME_GetSubSecond(RTC));
 802c69e:	43c0      	mvns	r0, r0
  RtcTimerContext = GetTimerTicks();
 802c6a0:	6018      	str	r0, [r3, #0]
}
 802c6a2:	4770      	bx	lr
 802c6a4:	40002800 	.word	0x40002800
 802c6a8:	200035c8 	.word	0x200035c8

0802c6ac <TIMER_IF_GetTimerContext>:
}
 802c6ac:	4b01      	ldr	r3, [pc, #4]	; (802c6b4 <TIMER_IF_GetTimerContext+0x8>)
 802c6ae:	6818      	ldr	r0, [r3, #0]
 802c6b0:	4770      	bx	lr
 802c6b2:	bf00      	nop
 802c6b4:	200035c8 	.word	0x200035c8

0802c6b8 <TIMER_IF_GetTimerElapsedTime>:
 802c6b8:	4b03      	ldr	r3, [pc, #12]	; (802c6c8 <TIMER_IF_GetTimerElapsedTime+0x10>)
  ret = ((uint32_t)(GetTimerTicks() - RtcTimerContext));
 802c6ba:	4a04      	ldr	r2, [pc, #16]	; (802c6cc <TIMER_IF_GetTimerElapsedTime+0x14>)
 802c6bc:	689b      	ldr	r3, [r3, #8]
 802c6be:	6810      	ldr	r0, [r2, #0]
  return (UINT32_MAX - LL_RTC_TIME_GetSubSecond(RTC));
 802c6c0:	43db      	mvns	r3, r3
}
 802c6c2:	1a18      	subs	r0, r3, r0
 802c6c4:	4770      	bx	lr
 802c6c6:	bf00      	nop
 802c6c8:	40002800 	.word	0x40002800
 802c6cc:	200035c8 	.word	0x200035c8

0802c6d0 <TIMER_IF_GetTimerValue>:
  if (RTC_Initialized == true)
 802c6d0:	4b03      	ldr	r3, [pc, #12]	; (802c6e0 <TIMER_IF_GetTimerValue+0x10>)
 802c6d2:	7918      	ldrb	r0, [r3, #4]
 802c6d4:	b110      	cbz	r0, 802c6dc <TIMER_IF_GetTimerValue+0xc>
 802c6d6:	4b03      	ldr	r3, [pc, #12]	; (802c6e4 <TIMER_IF_GetTimerValue+0x14>)
 802c6d8:	6898      	ldr	r0, [r3, #8]
  return (UINT32_MAX - LL_RTC_TIME_GetSubSecond(RTC));
 802c6da:	43c0      	mvns	r0, r0
}
 802c6dc:	4770      	bx	lr
 802c6de:	bf00      	nop
 802c6e0:	200035c8 	.word	0x200035c8
 802c6e4:	40002800 	.word	0x40002800

0802c6e8 <TIMER_IF_GetMinimumTimeout>:
}
 802c6e8:	2003      	movs	r0, #3
 802c6ea:	4770      	bx	lr

0802c6ec <TIMER_IF_Convert_ms2Tick>:
{
 802c6ec:	b508      	push	{r3, lr}
 802c6ee:	4601      	mov	r1, r0
  ret = ((uint32_t)((((uint64_t) timeMilliSec) << RTC_N_PREDIV_S) / 1000));
 802c6f0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 802c6f4:	2300      	movs	r3, #0
 802c6f6:	0280      	lsls	r0, r0, #10
 802c6f8:	0d89      	lsrs	r1, r1, #22
 802c6fa:	f7ff fa23 	bl	802bb44 <__aeabi_uldivmod>
}
 802c6fe:	bd08      	pop	{r3, pc}

0802c700 <TIMER_IF_Convert_Tick2ms>:
  ret = ((uint32_t)((((uint64_t)(tick)) * 1000) >> RTC_N_PREDIV_S));
 802c700:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 802c704:	fba0 2302 	umull	r2, r3, r0, r2
 802c708:	0a90      	lsrs	r0, r2, #10
}
 802c70a:	ea40 5083 	orr.w	r0, r0, r3, lsl #22
 802c70e:	4770      	bx	lr

0802c710 <TIMER_IF_StopTimer>:
{
 802c710:	b510      	push	{r4, lr}
  __HAL_RTC_ALARM_CLEAR_FLAG(&hrtc, RTC_FLAG_ALRAF);
 802c712:	4b07      	ldr	r3, [pc, #28]	; (802c730 <TIMER_IF_StopTimer+0x20>)
  HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_A);
 802c714:	4c07      	ldr	r4, [pc, #28]	; (802c734 <TIMER_IF_StopTimer+0x24>)
  __HAL_RTC_ALARM_CLEAR_FLAG(&hrtc, RTC_FLAG_ALRAF);
 802c716:	2201      	movs	r2, #1
 802c718:	65da      	str	r2, [r3, #92]	; 0x5c
  HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_A);
 802c71a:	f44f 7180 	mov.w	r1, #256	; 0x100
 802c71e:	4620      	mov	r0, r4
 802c720:	f002 fe38 	bl	802f394 <HAL_RTC_DeactivateAlarm>
  hrtc.IsEnabled.RtcFeatures = UINT32_MAX;
 802c724:	f04f 33ff 	mov.w	r3, #4294967295
 802c728:	6323      	str	r3, [r4, #48]	; 0x30
}
 802c72a:	2000      	movs	r0, #0
 802c72c:	bd10      	pop	{r4, pc}
 802c72e:	bf00      	nop
 802c730:	40002800 	.word	0x40002800
 802c734:	200061b8 	.word	0x200061b8

0802c738 <TIMER_IF_BkUp_Write_Seconds>:
{
 802c738:	4602      	mov	r2, r0
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_SECONDS, Seconds);
 802c73a:	2100      	movs	r1, #0
 802c73c:	4801      	ldr	r0, [pc, #4]	; (802c744 <TIMER_IF_BkUp_Write_Seconds+0xc>)
 802c73e:	f003 b83e 	b.w	802f7be <HAL_RTCEx_BKUPWrite>
 802c742:	bf00      	nop
 802c744:	200061b8 	.word	0x200061b8

0802c748 <TIMER_IF_BkUp_Write_SubSeconds>:
{
 802c748:	4602      	mov	r2, r0
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_SUBSECONDS, SubSeconds);
 802c74a:	2101      	movs	r1, #1
 802c74c:	4801      	ldr	r0, [pc, #4]	; (802c754 <TIMER_IF_BkUp_Write_SubSeconds+0xc>)
 802c74e:	f003 b836 	b.w	802f7be <HAL_RTCEx_BKUPWrite>
 802c752:	bf00      	nop
 802c754:	200061b8 	.word	0x200061b8

0802c758 <TIMER_IF_StartTimer>:
{
 802c758:	b510      	push	{r4, lr}
 802c75a:	b08c      	sub	sp, #48	; 0x30
  RTC_AlarmTypeDef sAlarm = {0};
 802c75c:	222c      	movs	r2, #44	; 0x2c
 802c75e:	2100      	movs	r1, #0
{
 802c760:	4604      	mov	r4, r0
  RTC_AlarmTypeDef sAlarm = {0};
 802c762:	a801      	add	r0, sp, #4
 802c764:	f00f f80e 	bl	803b784 <memset>
  TIMER_IF_StopTimer();
 802c768:	f7ff ffd2 	bl	802c710 <TIMER_IF_StopTimer>
  timeout += RtcTimerContext;
 802c76c:	4b0c      	ldr	r3, [pc, #48]	; (802c7a0 <TIMER_IF_StartTimer+0x48>)
 802c76e:	6818      	ldr	r0, [r3, #0]
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
 802c770:	2300      	movs	r3, #0
  timeout += RtcTimerContext;
 802c772:	4404      	add	r4, r0
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
 802c774:	9308      	str	r3, [sp, #32]
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
 802c776:	9306      	str	r3, [sp, #24]
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDBINMASK_NONE;
 802c778:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
  sAlarm.AlarmTime.SubSeconds = UINT32_MAX - timeout;
 802c77c:	43e4      	mvns	r4, r4
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDBINMASK_NONE;
 802c77e:	9307      	str	r3, [sp, #28]
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 802c780:	4808      	ldr	r0, [pc, #32]	; (802c7a4 <TIMER_IF_StartTimer+0x4c>)
  sAlarm.AlarmTime.SubSeconds = UINT32_MAX - timeout;
 802c782:	9402      	str	r4, [sp, #8]
  sAlarm.Alarm = RTC_ALARM_A;
 802c784:	f44f 7380 	mov.w	r3, #256	; 0x100
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 802c788:	2201      	movs	r2, #1
 802c78a:	a901      	add	r1, sp, #4
  sAlarm.Alarm = RTC_ALARM_A;
 802c78c:	930b      	str	r3, [sp, #44]	; 0x2c
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 802c78e:	f002 ff17 	bl	802f5c0 <HAL_RTC_SetAlarm_IT>
 802c792:	b108      	cbz	r0, 802c798 <TIMER_IF_StartTimer+0x40>
    Error_Handler();
 802c794:	f7ff fd8e 	bl	802c2b4 <Error_Handler>
}
 802c798:	2000      	movs	r0, #0
 802c79a:	b00c      	add	sp, #48	; 0x30
 802c79c:	bd10      	pop	{r4, pc}
 802c79e:	bf00      	nop
 802c7a0:	200035c8 	.word	0x200035c8
 802c7a4:	200061b8 	.word	0x200061b8

0802c7a8 <TIMER_IF_GetTime>:
 802c7a8:	4b0c      	ldr	r3, [pc, #48]	; (802c7dc <TIMER_IF_GetTime+0x34>)
{
 802c7aa:	b570      	push	{r4, r5, r6, lr}
 802c7ac:	689c      	ldr	r4, [r3, #8]
 802c7ae:	4606      	mov	r6, r0
  MSBticks = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_MSBTICKS);
 802c7b0:	2102      	movs	r1, #2
 802c7b2:	480b      	ldr	r0, [pc, #44]	; (802c7e0 <TIMER_IF_GetTime+0x38>)
 802c7b4:	f003 f80a 	bl	802f7cc <HAL_RTCEx_BKUPRead>
  return (UINT32_MAX - LL_RTC_TIME_GetSubSecond(RTC));
 802c7b8:	43e4      	mvns	r4, r4
  ticks = (((uint64_t) timerValueMSB) << 32) + timerValueLsb;
 802c7ba:	2200      	movs	r2, #0
 802c7bc:	1912      	adds	r2, r2, r4
  ticks = (uint32_t) ticks & RTC_PREDIV_S;
 802c7be:	f3c2 0409 	ubfx	r4, r2, #0, #10
  ret = ((uint32_t)((((uint64_t)(tick)) * 1000) >> RTC_N_PREDIV_S));
 802c7c2:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 802c7c6:	fba4 4501 	umull	r4, r5, r4, r1
  ticks = (((uint64_t) timerValueMSB) << 32) + timerValueLsb;
 802c7ca:	f140 0300 	adc.w	r3, r0, #0
  ret = ((uint32_t)((((uint64_t)(tick)) * 1000) >> RTC_N_PREDIV_S));
 802c7ce:	0aa4      	lsrs	r4, r4, #10
  seconds = (uint32_t)(ticks >> RTC_N_PREDIV_S);
 802c7d0:	0a90      	lsrs	r0, r2, #10
  *mSeconds = TIMER_IF_Convert_Tick2ms(ticks);
 802c7d2:	8034      	strh	r4, [r6, #0]
}
 802c7d4:	ea40 5083 	orr.w	r0, r0, r3, lsl #22
 802c7d8:	bd70      	pop	{r4, r5, r6, pc}
 802c7da:	bf00      	nop
 802c7dc:	40002800 	.word	0x40002800
 802c7e0:	200061b8 	.word	0x200061b8

0802c7e4 <TIMER_IF_BkUp_Read_Seconds>:
  ret = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_SECONDS);
 802c7e4:	4801      	ldr	r0, [pc, #4]	; (802c7ec <TIMER_IF_BkUp_Read_Seconds+0x8>)
 802c7e6:	2100      	movs	r1, #0
 802c7e8:	f002 bff0 	b.w	802f7cc <HAL_RTCEx_BKUPRead>
 802c7ec:	200061b8 	.word	0x200061b8

0802c7f0 <TIMER_IF_BkUp_Read_SubSeconds>:
  ret = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_SUBSECONDS);
 802c7f0:	4801      	ldr	r0, [pc, #4]	; (802c7f8 <TIMER_IF_BkUp_Read_SubSeconds+0x8>)
 802c7f2:	2101      	movs	r1, #1
 802c7f4:	f002 bfea 	b.w	802f7cc <HAL_RTCEx_BKUPRead>
 802c7f8:	200061b8 	.word	0x200061b8

0802c7fc <TIMER_IF_Init>:
{
 802c7fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (RTC_Initialized == false)
 802c7fe:	4d0f      	ldr	r5, [pc, #60]	; (802c83c <TIMER_IF_Init+0x40>)
 802c800:	792e      	ldrb	r6, [r5, #4]
 802c802:	b9ce      	cbnz	r6, 802c838 <TIMER_IF_Init+0x3c>
    hrtc.IsEnabled.RtcFeatures = UINT32_MAX;
 802c804:	4c0e      	ldr	r4, [pc, #56]	; (802c840 <TIMER_IF_Init+0x44>)
 802c806:	f04f 37ff 	mov.w	r7, #4294967295
 802c80a:	6327      	str	r7, [r4, #48]	; 0x30
    MX_RTC_Init();
 802c80c:	f7ff fd54 	bl	802c2b8 <MX_RTC_Init>
    TIMER_IF_StopTimer();
 802c810:	f7ff ff7e 	bl	802c710 <TIMER_IF_StopTimer>
    HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_A);
 802c814:	f44f 7180 	mov.w	r1, #256	; 0x100
 802c818:	4620      	mov	r0, r4
 802c81a:	f002 fdbb 	bl	802f394 <HAL_RTC_DeactivateAlarm>
    HAL_RTCEx_EnableBypassShadow(&hrtc);
 802c81e:	4620      	mov	r0, r4
    hrtc.IsEnabled.RtcFeatures = UINT32_MAX;
 802c820:	6327      	str	r7, [r4, #48]	; 0x30
    HAL_RTCEx_EnableBypassShadow(&hrtc);
 802c822:	f002 ff77 	bl	802f714 <HAL_RTCEx_EnableBypassShadow>
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_MSBTICKS, MSBticks);
 802c826:	4632      	mov	r2, r6
 802c828:	2102      	movs	r1, #2
 802c82a:	4620      	mov	r0, r4
 802c82c:	f002 ffc7 	bl	802f7be <HAL_RTCEx_BKUPWrite>
    TIMER_IF_SetTimerContext();
 802c830:	f7ff ff32 	bl	802c698 <TIMER_IF_SetTimerContext>
    RTC_Initialized = true;
 802c834:	2301      	movs	r3, #1
 802c836:	712b      	strb	r3, [r5, #4]
}
 802c838:	2000      	movs	r0, #0
 802c83a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802c83c:	200035c8 	.word	0x200035c8
 802c840:	200061b8 	.word	0x200061b8

0802c844 <TIMER_IF_DelayMs>:
{
 802c844:	4601      	mov	r1, r0
 802c846:	b508      	push	{r3, lr}
  ret = ((uint32_t)((((uint64_t) timeMilliSec) << RTC_N_PREDIV_S) / 1000));
 802c848:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 802c84c:	2300      	movs	r3, #0
 802c84e:	0280      	lsls	r0, r0, #10
 802c850:	0d89      	lsrs	r1, r1, #22
 802c852:	f7ff f977 	bl	802bb44 <__aeabi_uldivmod>
 802c856:	4a05      	ldr	r2, [pc, #20]	; (802c86c <TIMER_IF_DelayMs+0x28>)
 802c858:	6891      	ldr	r1, [r2, #8]
  return (UINT32_MAX - LL_RTC_TIME_GetSubSecond(RTC));
 802c85a:	43c9      	mvns	r1, r1
 802c85c:	6893      	ldr	r3, [r2, #8]
 802c85e:	43db      	mvns	r3, r3
  while (((GetTimerTicks() - timeout)) < delayTicks)
 802c860:	1a5b      	subs	r3, r3, r1
 802c862:	4283      	cmp	r3, r0
 802c864:	d300      	bcc.n	802c868 <TIMER_IF_DelayMs+0x24>
}
 802c866:	bd08      	pop	{r3, pc}
    __NOP();
 802c868:	bf00      	nop
 802c86a:	e7f7      	b.n	802c85c <TIMER_IF_DelayMs+0x18>
 802c86c:	40002800 	.word	0x40002800

0802c870 <HAL_RTC_AlarmAEventCallback>:
  UTIL_TIMER_IRQ_MAP_PROCESS();
 802c870:	f00e be06 	b.w	803b480 <UTIL_TIMER_IRQ_Handler>

0802c874 <HAL_RTCEx_SSRUEventCallback>:
{
 802c874:	b510      	push	{r4, lr}
  MSBticks = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_MSBTICKS);
 802c876:	4c06      	ldr	r4, [pc, #24]	; (802c890 <HAL_RTCEx_SSRUEventCallback+0x1c>)
 802c878:	2102      	movs	r1, #2
 802c87a:	4620      	mov	r0, r4
 802c87c:	f002 ffa6 	bl	802f7cc <HAL_RTCEx_BKUPRead>
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_MSBTICKS, MSBticks);
 802c880:	2102      	movs	r1, #2
 802c882:	1c42      	adds	r2, r0, #1
 802c884:	4620      	mov	r0, r4
}
 802c886:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_MSBTICKS, MSBticks);
 802c88a:	f002 bf98 	b.w	802f7be <HAL_RTCEx_BKUPWrite>
 802c88e:	bf00      	nop
 802c890:	200061b8 	.word	0x200061b8

0802c894 <MX_USART2_UART_Init>:
  /* USER CODE END USART2_Init 0 */

  /* USER CODE BEGIN USART2_Init 1 */

  /* USER CODE END USART2_Init 1 */
  huart2.Instance = USART2;
 802c894:	4816      	ldr	r0, [pc, #88]	; (802c8f0 <MX_USART2_UART_Init+0x5c>)
  huart2.Init.BaudRate = 115200;
 802c896:	4a17      	ldr	r2, [pc, #92]	; (802c8f4 <MX_USART2_UART_Init+0x60>)
{
 802c898:	b508      	push	{r3, lr}
  huart2.Init.BaudRate = 115200;
 802c89a:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
 802c89e:	e9c0 2300 	strd	r2, r3, [r0]
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 802c8a2:	2300      	movs	r3, #0
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
 802c8a4:	220c      	movs	r2, #12
  huart2.Init.StopBits = UART_STOPBITS_1;
 802c8a6:	e9c0 3302 	strd	r3, r3, [r0, #8]
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 802c8aa:	e9c0 2305 	strd	r2, r3, [r0, #20]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 802c8ae:	e9c0 3307 	strd	r3, r3, [r0, #28]
  huart2.Init.ClockPrescaler = UART_PRESCALER_DIV1;
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 802c8b2:	e9c0 3309 	strd	r3, r3, [r0, #36]	; 0x24
  huart2.Init.Parity = UART_PARITY_NONE;
 802c8b6:	6103      	str	r3, [r0, #16]
  if (HAL_UART_Init(&huart2) != HAL_OK)
 802c8b8:	f004 f8a6 	bl	8030a08 <HAL_UART_Init>
 802c8bc:	b108      	cbz	r0, 802c8c2 <MX_USART2_UART_Init+0x2e>
  {
    Error_Handler();
 802c8be:	f7ff fcf9 	bl	802c2b4 <Error_Handler>
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart2, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
 802c8c2:	480b      	ldr	r0, [pc, #44]	; (802c8f0 <MX_USART2_UART_Init+0x5c>)
 802c8c4:	2100      	movs	r1, #0
 802c8c6:	f004 fa26 	bl	8030d16 <HAL_UARTEx_SetTxFifoThreshold>
 802c8ca:	b108      	cbz	r0, 802c8d0 <MX_USART2_UART_Init+0x3c>
  {
    Error_Handler();
 802c8cc:	f7ff fcf2 	bl	802c2b4 <Error_Handler>
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart2, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
 802c8d0:	4807      	ldr	r0, [pc, #28]	; (802c8f0 <MX_USART2_UART_Init+0x5c>)
 802c8d2:	2100      	movs	r1, #0
 802c8d4:	f004 fa43 	bl	8030d5e <HAL_UARTEx_SetRxFifoThreshold>
 802c8d8:	b108      	cbz	r0, 802c8de <MX_USART2_UART_Init+0x4a>
  {
    Error_Handler();
 802c8da:	f7ff fceb 	bl	802c2b4 <Error_Handler>
  }
  if (HAL_UARTEx_EnableFifoMode(&huart2) != HAL_OK)
 802c8de:	4804      	ldr	r0, [pc, #16]	; (802c8f0 <MX_USART2_UART_Init+0x5c>)
 802c8e0:	f004 f9f6 	bl	8030cd0 <HAL_UARTEx_EnableFifoMode>
 802c8e4:	b118      	cbz	r0, 802c8ee <MX_USART2_UART_Init+0x5a>
  }
  /* USER CODE BEGIN USART2_Init 2 */

  /* USER CODE END USART2_Init 2 */

}
 802c8e6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 802c8ea:	f7ff bce3 	b.w	802c2b4 <Error_Handler>
}
 802c8ee:	bd08      	pop	{r3, pc}
 802c8f0:	2000625c 	.word	0x2000625c
 802c8f4:	40004400 	.word	0x40004400

0802c8f8 <HAL_UART_MspInit>:

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
 802c8f8:	b570      	push	{r4, r5, r6, lr}
 802c8fa:	b096      	sub	sp, #88	; 0x58
 802c8fc:	4606      	mov	r6, r0

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 802c8fe:	2214      	movs	r2, #20
 802c900:	2100      	movs	r1, #0
 802c902:	a803      	add	r0, sp, #12
 802c904:	f00e ff3e 	bl	803b784 <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 802c908:	2238      	movs	r2, #56	; 0x38
 802c90a:	2100      	movs	r1, #0
 802c90c:	a808      	add	r0, sp, #32
 802c90e:	f00e ff39 	bl	803b784 <memset>
  if(uartHandle->Instance==USART2)
 802c912:	6832      	ldr	r2, [r6, #0]
 802c914:	4b2b      	ldr	r3, [pc, #172]	; (802c9c4 <HAL_UART_MspInit+0xcc>)
 802c916:	429a      	cmp	r2, r3
 802c918:	d151      	bne.n	802c9be <HAL_UART_MspInit+0xc6>
  /* USER CODE BEGIN USART2_MspInit 0 */

  /* USER CODE END USART2_MspInit 0 */
  /** Initializes the peripherals clocks
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART2;
 802c91a:	2302      	movs	r3, #2
 802c91c:	9308      	str	r3, [sp, #32]
    PeriphClkInitStruct.Usart2ClockSelection = RCC_USART2CLKSOURCE_SYSCLK;
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 802c91e:	a808      	add	r0, sp, #32
    PeriphClkInitStruct.Usart2ClockSelection = RCC_USART2CLKSOURCE_SYSCLK;
 802c920:	4b29      	ldr	r3, [pc, #164]	; (802c9c8 <HAL_UART_MspInit+0xd0>)
 802c922:	930a      	str	r3, [sp, #40]	; 0x28
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 802c924:	f002 fc60 	bl	802f1e8 <HAL_RCCEx_PeriphCLKConfig>
 802c928:	b108      	cbz	r0, 802c92e <HAL_UART_MspInit+0x36>
    {
      Error_Handler();
 802c92a:	f7ff fcc3 	bl	802c2b4 <Error_Handler>
  SET_BIT(RCC->APB1ENR1, Periphs);
 802c92e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
    PA2     ------> USART2_TX
    */
    GPIO_InitStruct.Pin = USARTx_RX_Pin|USARTx_TX_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 802c932:	2500      	movs	r5, #0
 802c934:	6d9a      	ldr	r2, [r3, #88]	; 0x58
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* USART2 DMA Init */
    /* USART2_TX Init */
    hdma_usart2_tx.Instance = DMA1_Channel5;
 802c936:	4c25      	ldr	r4, [pc, #148]	; (802c9cc <HAL_UART_MspInit+0xd4>)
 802c938:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 802c93c:	659a      	str	r2, [r3, #88]	; 0x58
  tmpreg = READ_BIT(RCC->APB1ENR1, Periphs);
 802c93e:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 802c940:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
 802c944:	9202      	str	r2, [sp, #8]
  (void)tmpreg;
 802c946:	9a02      	ldr	r2, [sp, #8]
  SET_BIT(RCC->AHB2ENR, Periphs);
 802c948:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 802c94a:	f042 0201 	orr.w	r2, r2, #1
 802c94e:	64da      	str	r2, [r3, #76]	; 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 802c950:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 802c952:	f003 0301 	and.w	r3, r3, #1
 802c956:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 802c958:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 802c95a:	220c      	movs	r2, #12
 802c95c:	2302      	movs	r3, #2
 802c95e:	e9cd 2303 	strd	r2, r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 802c962:	2303      	movs	r3, #3
 802c964:	e9cd 5305 	strd	r5, r3, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 802c968:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 802c96a:	2307      	movs	r3, #7
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 802c96c:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 802c970:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 802c972:	f001 fda3 	bl	802e4bc <HAL_GPIO_Init>
    hdma_usart2_tx.Init.Request = DMA_REQUEST_USART2_TX;
 802c976:	4916      	ldr	r1, [pc, #88]	; (802c9d0 <HAL_UART_MspInit+0xd8>)
    hdma_usart2_tx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_usart2_tx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_usart2_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_usart2_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_usart2_tx.Init.Mode = DMA_NORMAL;
    hdma_usart2_tx.Init.Priority = DMA_PRIORITY_LOW;
 802c978:	6225      	str	r5, [r4, #32]
    hdma_usart2_tx.Init.Request = DMA_REQUEST_USART2_TX;
 802c97a:	2314      	movs	r3, #20
 802c97c:	e9c4 1300 	strd	r1, r3, [r4]
    hdma_usart2_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 802c980:	2310      	movs	r3, #16
    hdma_usart2_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 802c982:	e9c4 3502 	strd	r3, r5, [r4, #8]
    if (HAL_DMA_Init(&hdma_usart2_tx) != HAL_OK)
 802c986:	4620      	mov	r0, r4
    hdma_usart2_tx.Init.MemInc = DMA_MINC_ENABLE;
 802c988:	2380      	movs	r3, #128	; 0x80
    hdma_usart2_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 802c98a:	e9c4 3504 	strd	r3, r5, [r4, #16]
    hdma_usart2_tx.Init.Mode = DMA_NORMAL;
 802c98e:	e9c4 5506 	strd	r5, r5, [r4, #24]
    if (HAL_DMA_Init(&hdma_usart2_tx) != HAL_OK)
 802c992:	f001 fa79 	bl	802de88 <HAL_DMA_Init>
 802c996:	b108      	cbz	r0, 802c99c <HAL_UART_MspInit+0xa4>
    {
      Error_Handler();
 802c998:	f7ff fc8c 	bl	802c2b4 <Error_Handler>
    }

    if (HAL_DMA_ConfigChannelAttributes(&hdma_usart2_tx, DMA_CHANNEL_NPRIV) != HAL_OK)
 802c99c:	480b      	ldr	r0, [pc, #44]	; (802c9cc <HAL_UART_MspInit+0xd4>)
 802c99e:	2110      	movs	r1, #16
 802c9a0:	f001 fc44 	bl	802e22c <HAL_DMA_ConfigChannelAttributes>
 802c9a4:	b108      	cbz	r0, 802c9aa <HAL_UART_MspInit+0xb2>
    {
      Error_Handler();
 802c9a6:	f7ff fc85 	bl	802c2b4 <Error_Handler>
    }

    __HAL_LINKDMA(uartHandle,hdmatx,hdma_usart2_tx);

    /* USART2 interrupt Init */
    HAL_NVIC_SetPriority(USART2_IRQn, 2, 0);
 802c9aa:	2025      	movs	r0, #37	; 0x25
    __HAL_LINKDMA(uartHandle,hdmatx,hdma_usart2_tx);
 802c9ac:	67b4      	str	r4, [r6, #120]	; 0x78
    HAL_NVIC_SetPriority(USART2_IRQn, 2, 0);
 802c9ae:	2200      	movs	r2, #0
 802c9b0:	2102      	movs	r1, #2
    __HAL_LINKDMA(uartHandle,hdmatx,hdma_usart2_tx);
 802c9b2:	62a6      	str	r6, [r4, #40]	; 0x28
    HAL_NVIC_SetPriority(USART2_IRQn, 2, 0);
 802c9b4:	f001 f9d4 	bl	802dd60 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART2_IRQn);
 802c9b8:	2025      	movs	r0, #37	; 0x25
 802c9ba:	f001 fa03 	bl	802ddc4 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USART2_MspInit 1 */

  /* USER CODE END USART2_MspInit 1 */
  }
}
 802c9be:	b016      	add	sp, #88	; 0x58
 802c9c0:	bd70      	pop	{r4, r5, r6, pc}
 802c9c2:	bf00      	nop
 802c9c4:	40004400 	.word	0x40004400
 802c9c8:	000c0004 	.word	0x000c0004
 802c9cc:	200061fc 	.word	0x200061fc
 802c9d0:	40020058 	.word	0x40020058

0802c9d4 <HAL_UART_MspDeInit>:

void HAL_UART_MspDeInit(UART_HandleTypeDef* uartHandle)
{

  if(uartHandle->Instance==USART2)
 802c9d4:	6802      	ldr	r2, [r0, #0]
 802c9d6:	4b0c      	ldr	r3, [pc, #48]	; (802ca08 <HAL_UART_MspDeInit+0x34>)
 802c9d8:	429a      	cmp	r2, r3
{
 802c9da:	b510      	push	{r4, lr}
 802c9dc:	4604      	mov	r4, r0
  if(uartHandle->Instance==USART2)
 802c9de:	d112      	bne.n	802ca06 <HAL_UART_MspDeInit+0x32>
  CLEAR_BIT(RCC->APB1ENR1, Periphs);
 802c9e0:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000

    /**USART2 GPIO Configuration
    PA3     ------> USART2_RX
    PA2     ------> USART2_TX
    */
    HAL_GPIO_DeInit(GPIOA, USARTx_RX_Pin|USARTx_TX_Pin);
 802c9e4:	210c      	movs	r1, #12
 802c9e6:	6d93      	ldr	r3, [r2, #88]	; 0x58
 802c9e8:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 802c9ec:	6593      	str	r3, [r2, #88]	; 0x58
 802c9ee:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 802c9f2:	f001 fe0f 	bl	802e614 <HAL_GPIO_DeInit>

    /* USART2 DMA DeInit */
    HAL_DMA_DeInit(uartHandle->hdmatx);
 802c9f6:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 802c9f8:	f001 fab8 	bl	802df6c <HAL_DMA_DeInit>
    HAL_NVIC_DisableIRQ(USART2_IRQn);
  /* USER CODE BEGIN USART2_MspDeInit 1 */

  /* USER CODE END USART2_MspDeInit 1 */
  }
}
 802c9fc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    HAL_NVIC_DisableIRQ(USART2_IRQn);
 802ca00:	2025      	movs	r0, #37	; 0x25
 802ca02:	f001 b9ed 	b.w	802dde0 <HAL_NVIC_DisableIRQ>
}
 802ca06:	bd10      	pop	{r4, pc}
 802ca08:	40004400 	.word	0x40004400

0802ca0c <vcom_Trace_DMA>:

  /* USER CODE END vcom_Trace_2 */
}

UTIL_ADV_TRACE_Status_t vcom_Trace_DMA(uint8_t *p_data, uint16_t size)
{
 802ca0c:	b508      	push	{r3, lr}
 802ca0e:	460a      	mov	r2, r1
  /* USER CODE BEGIN vcom_Trace_DMA_1 */

  /* USER CODE END vcom_Trace_DMA_1 */
  HAL_UART_Transmit_DMA(&huart2, p_data, size);
 802ca10:	4601      	mov	r1, r0
 802ca12:	4802      	ldr	r0, [pc, #8]	; (802ca1c <vcom_Trace_DMA+0x10>)
 802ca14:	f003 f9e4 	bl	802fde0 <HAL_UART_Transmit_DMA>
  return UTIL_ADV_TRACE_OK;
  /* USER CODE BEGIN vcom_Trace_DMA_2 */

  /* USER CODE END vcom_Trace_DMA_2 */
}
 802ca18:	2000      	movs	r0, #0
 802ca1a:	bd08      	pop	{r3, pc}
 802ca1c:	2000625c 	.word	0x2000625c

0802ca20 <vcom_ReceiveInit>:

UTIL_ADV_TRACE_Status_t vcom_ReceiveInit(void (*RxCb)(uint8_t *rxChar, uint16_t size, uint8_t error))
{
 802ca20:	b513      	push	{r0, r1, r4, lr}

  /* USER CODE END vcom_ReceiveInit_1 */
  UART_WakeUpTypeDef WakeUpSelection;

  /*record call back*/
  RxCpltCallback = RxCb;
 802ca22:	4b11      	ldr	r3, [pc, #68]	; (802ca68 <vcom_ReceiveInit+0x48>)

  /*Set wakeUp event on start bit*/
  WakeUpSelection.WakeUpEvent = UART_WAKEUP_ON_STARTBIT;

  HAL_UARTEx_StopModeWakeUpSourceConfig(&huart2, WakeUpSelection);
 802ca24:	4c11      	ldr	r4, [pc, #68]	; (802ca6c <vcom_ReceiveInit+0x4c>)
  RxCpltCallback = RxCb;
 802ca26:	6018      	str	r0, [r3, #0]
  WakeUpSelection.WakeUpEvent = UART_WAKEUP_ON_STARTBIT;
 802ca28:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 802ca2c:	9300      	str	r3, [sp, #0]
  HAL_UARTEx_StopModeWakeUpSourceConfig(&huart2, WakeUpSelection);
 802ca2e:	ab02      	add	r3, sp, #8
 802ca30:	e913 0006 	ldmdb	r3, {r1, r2}
 802ca34:	4620      	mov	r0, r4
 802ca36:	f004 f8ee 	bl	8030c16 <HAL_UARTEx_StopModeWakeUpSourceConfig>

  /* Make sure that no UART transfer is on-going */
  while (__HAL_UART_GET_FLAG(&huart2, USART_ISR_BUSY) == SET);
 802ca3a:	6823      	ldr	r3, [r4, #0]
 802ca3c:	69da      	ldr	r2, [r3, #28]
 802ca3e:	03d1      	lsls	r1, r2, #15
 802ca40:	d4fc      	bmi.n	802ca3c <vcom_ReceiveInit+0x1c>

  /* Make sure that UART is ready to receive)   */
  while (__HAL_UART_GET_FLAG(&huart2, USART_ISR_REACK) == RESET);
 802ca42:	69da      	ldr	r2, [r3, #28]
 802ca44:	0252      	lsls	r2, r2, #9
 802ca46:	d5fc      	bpl.n	802ca42 <vcom_ReceiveInit+0x22>

  /* Enable USART interrupt */
  __HAL_UART_ENABLE_IT(&huart2, UART_IT_WUF);
 802ca48:	689a      	ldr	r2, [r3, #8]

  /*Enable wakeup from stop mode*/
  HAL_UARTEx_EnableStopMode(&huart2);
 802ca4a:	4808      	ldr	r0, [pc, #32]	; (802ca6c <vcom_ReceiveInit+0x4c>)
  __HAL_UART_ENABLE_IT(&huart2, UART_IT_WUF);
 802ca4c:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 802ca50:	609a      	str	r2, [r3, #8]
  HAL_UARTEx_EnableStopMode(&huart2);
 802ca52:	f004 f927 	bl	8030ca4 <HAL_UARTEx_EnableStopMode>

  /*Start LPUART receive on IT*/
  HAL_UART_Receive_IT(&huart2, &charRx, 1);
 802ca56:	4906      	ldr	r1, [pc, #24]	; (802ca70 <vcom_ReceiveInit+0x50>)
 802ca58:	4804      	ldr	r0, [pc, #16]	; (802ca6c <vcom_ReceiveInit+0x4c>)
 802ca5a:	2201      	movs	r2, #1
 802ca5c:	f004 f88c 	bl	8030b78 <HAL_UART_Receive_IT>

  return UTIL_ADV_TRACE_OK;
  /* USER CODE BEGIN vcom_ReceiveInit_2 */

  /* USER CODE END vcom_ReceiveInit_2 */
}
 802ca60:	2000      	movs	r0, #0
 802ca62:	b002      	add	sp, #8
 802ca64:	bd10      	pop	{r4, pc}
 802ca66:	bf00      	nop
 802ca68:	200035d0 	.word	0x200035d0
 802ca6c:	2000625c 	.word	0x2000625c
 802ca70:	200062ec 	.word	0x200062ec

0802ca74 <vcom_Init>:
{
 802ca74:	b508      	push	{r3, lr}
  TxCpltCallback = cb;
 802ca76:	4b07      	ldr	r3, [pc, #28]	; (802ca94 <vcom_Init+0x20>)
 802ca78:	6058      	str	r0, [r3, #4]
  MX_DMA_Init();
 802ca7a:	f7ff fabf 	bl	802bffc <MX_DMA_Init>
  MX_USART2_UART_Init();
 802ca7e:	f7ff ff09 	bl	802c894 <MX_USART2_UART_Init>
  SET_BIT(EXTI->IMR1, ExtiLine);
 802ca82:	4a05      	ldr	r2, [pc, #20]	; (802ca98 <vcom_Init+0x24>)
 802ca84:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
 802ca88:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 802ca8c:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
}
 802ca90:	2000      	movs	r0, #0
 802ca92:	bd08      	pop	{r3, pc}
 802ca94:	200035d0 	.word	0x200035d0
 802ca98:	58000800 	.word	0x58000800

0802ca9c <vcom_DeInit>:
{
 802ca9c:	b508      	push	{r3, lr}
  SET_BIT(RCC->APB1RSTR1, Periphs);
 802ca9e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
  HAL_UART_MspDeInit(&huart2);
 802caa2:	4808      	ldr	r0, [pc, #32]	; (802cac4 <vcom_DeInit+0x28>)
 802caa4:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 802caa6:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 802caaa:	639a      	str	r2, [r3, #56]	; 0x38
  CLEAR_BIT(RCC->APB1RSTR1, Periphs);
 802caac:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 802caae:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 802cab2:	639a      	str	r2, [r3, #56]	; 0x38
 802cab4:	f7ff ff8e 	bl	802c9d4 <HAL_UART_MspDeInit>
  HAL_NVIC_DisableIRQ(DMA1_Channel5_IRQn);
 802cab8:	200f      	movs	r0, #15
 802caba:	f001 f991 	bl	802dde0 <HAL_NVIC_DisableIRQ>
}
 802cabe:	2000      	movs	r0, #0
 802cac0:	bd08      	pop	{r3, pc}
 802cac2:	bf00      	nop
 802cac4:	2000625c 	.word	0x2000625c

0802cac8 <vcom_Resume>:

void vcom_Resume(void)
{
 802cac8:	b508      	push	{r3, lr}
  /* USER CODE BEGIN vcom_Resume_1 */

  /* USER CODE END vcom_Resume_1 */
  /*to re-enable lost UART settings*/
  if (HAL_UART_Init(&huart2) != HAL_OK)
 802caca:	4807      	ldr	r0, [pc, #28]	; (802cae8 <vcom_Resume+0x20>)
 802cacc:	f003 ff9c 	bl	8030a08 <HAL_UART_Init>
 802cad0:	b108      	cbz	r0, 802cad6 <vcom_Resume+0xe>
  {
    Error_Handler();
 802cad2:	f7ff fbef 	bl	802c2b4 <Error_Handler>
  }

  /*to re-enable lost DMA settings*/
  if (HAL_DMA_Init(&hdma_usart2_tx) != HAL_OK)
 802cad6:	4805      	ldr	r0, [pc, #20]	; (802caec <vcom_Resume+0x24>)
 802cad8:	f001 f9d6 	bl	802de88 <HAL_DMA_Init>
 802cadc:	b118      	cbz	r0, 802cae6 <vcom_Resume+0x1e>
    Error_Handler();
  }
  /* USER CODE BEGIN vcom_Resume_2 */

  /* USER CODE END vcom_Resume_2 */
}
 802cade:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 802cae2:	f7ff bbe7 	b.w	802c2b4 <Error_Handler>
}
 802cae6:	bd08      	pop	{r3, pc}
 802cae8:	2000625c 	.word	0x2000625c
 802caec:	200061fc 	.word	0x200061fc

0802caf0 <HAL_UART_TxCpltCallback>:
{
  /* USER CODE BEGIN HAL_UART_TxCpltCallback_1 */

  /* USER CODE END HAL_UART_TxCpltCallback_1 */
  /* buffer transmission complete*/
  TxCpltCallback(NULL);
 802caf0:	4b01      	ldr	r3, [pc, #4]	; (802caf8 <HAL_UART_TxCpltCallback+0x8>)
 802caf2:	2000      	movs	r0, #0
 802caf4:	685b      	ldr	r3, [r3, #4]
 802caf6:	4718      	bx	r3
 802caf8:	200035d0 	.word	0x200035d0

0802cafc <HAL_UART_RxCpltCallback>:
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart2)
{
  /* USER CODE BEGIN HAL_UART_RxCpltCallback_1 */

  /* USER CODE END HAL_UART_RxCpltCallback_1 */
  if ((NULL != RxCpltCallback) && (HAL_UART_ERROR_NONE == huart2->ErrorCode))
 802cafc:	4b08      	ldr	r3, [pc, #32]	; (802cb20 <HAL_UART_RxCpltCallback+0x24>)
 802cafe:	681b      	ldr	r3, [r3, #0]
{
 802cb00:	b510      	push	{r4, lr}
 802cb02:	4604      	mov	r4, r0
  if ((NULL != RxCpltCallback) && (HAL_UART_ERROR_NONE == huart2->ErrorCode))
 802cb04:	b12b      	cbz	r3, 802cb12 <HAL_UART_RxCpltCallback+0x16>
 802cb06:	f8d0 208c 	ldr.w	r2, [r0, #140]	; 0x8c
 802cb0a:	b912      	cbnz	r2, 802cb12 <HAL_UART_RxCpltCallback+0x16>
  {
    RxCpltCallback(&charRx, 1, 0);
 802cb0c:	4805      	ldr	r0, [pc, #20]	; (802cb24 <HAL_UART_RxCpltCallback+0x28>)
 802cb0e:	2101      	movs	r1, #1
 802cb10:	4798      	blx	r3
  }
  HAL_UART_Receive_IT(huart2, &charRx, 1);
 802cb12:	4620      	mov	r0, r4
 802cb14:	4903      	ldr	r1, [pc, #12]	; (802cb24 <HAL_UART_RxCpltCallback+0x28>)
  /* USER CODE BEGIN HAL_UART_RxCpltCallback_2 */

  /* USER CODE END HAL_UART_RxCpltCallback_2 */
}
 802cb16:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  HAL_UART_Receive_IT(huart2, &charRx, 1);
 802cb1a:	2201      	movs	r2, #1
 802cb1c:	f004 b82c 	b.w	8030b78 <HAL_UART_Receive_IT>
 802cb20:	200035d0 	.word	0x200035d0
 802cb24:	200062ec 	.word	0x200062ec

0802cb28 <MX_KMS_Init>:
{
/***************************************/
   /**
  */

  C_Initialize(NULL);
 802cb28:	2000      	movs	r0, #0
 802cb2a:	f7dc b861 	b.w	8008bf0 <SE_KMS_Initialize>

0802cb2e <MX_LoRaWAN_Init>:
/* USER CODE END PFP */

/* Exported functions --------------------------------------------------------*/

void MX_LoRaWAN_Init(void)
{
 802cb2e:	b508      	push	{r3, lr}
  /* USER CODE BEGIN MX_LoRaWAN_Init_1 */

  /* USER CODE END MX_LoRaWAN_Init_1 */
  SystemApp_Init();
 802cb30:	f7ff fcda 	bl	802c4e8 <SystemApp_Init>
  /* USER CODE END MX_LoRaWAN_Init_2 */
  LoRaWAN_Init();
  /* USER CODE BEGIN MX_LoRaWAN_Init_3 */

  /* USER CODE END MX_LoRaWAN_Init_3 */
}
 802cb34:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  LoRaWAN_Init();
 802cb38:	f000 b988 	b.w	802ce4c <LoRaWAN_Init>

0802cb3c <MX_LoRaWAN_Process>:
void MX_LoRaWAN_Process(void)
{
  /* USER CODE BEGIN MX_LoRaWAN_Process_1 */

  /* USER CODE END MX_LoRaWAN_Process_1 */
  UTIL_SEQ_Run(UTIL_SEQ_DEFAULT);
 802cb3c:	f04f 30ff 	mov.w	r0, #4294967295
 802cb40:	f00e ba2a 	b.w	803af98 <UTIL_SEQ_Run>

0802cb44 <FwUpdateAgent_Run>:
/* USER CODE END PFP */

/* Exported functions --------------------------------------------------------*/
#if (INTEROP_TEST_MODE == 0)
void FwUpdateAgent_Run(void)
{
 802cb44:	b530      	push	{r4, r5, lr}
  /* USER CODE BEGIN FwUpdateAgent_Run_1 */

  /* USER CODE END FwUpdateAgent_Run_1 */
  int32_t status = FLASH_OK;
  uint8_t fw_header_dwl_slot[SE_FW_HEADER_TOT_LEN];
  uint32_t first_page = PAGE(FRAG_DECODER_SWAP_REGION_START);
 802cb46:	4b1d      	ldr	r3, [pc, #116]	; (802cbbc <FwUpdateAgent_Run+0x78>)
  uint32_t nb_pages = PAGE(FRAG_DECODER_SWAP_REGION_START + SFU_IMG_IMAGE_OFFSET - 1) - first_page + 1U;

  /* Read header in slot 1 */
  UTIL_MEM_cpy_8(fw_header_dwl_slot, (void *)FRAG_DECODER_DWL_REGION_START, SE_FW_HEADER_TOT_LEN);
 802cb48:	491d      	ldr	r1, [pc, #116]	; (802cbc0 <FwUpdateAgent_Run+0x7c>)
  uint32_t first_page = PAGE(FRAG_DECODER_SWAP_REGION_START);
 802cb4a:	681c      	ldr	r4, [r3, #0]
{
 802cb4c:	b0d1      	sub	sp, #324	; 0x144
  UTIL_MEM_cpy_8(fw_header_dwl_slot, (void *)FRAG_DECODER_DWL_REGION_START, SE_FW_HEADER_TOT_LEN);
 802cb4e:	f44f 72a0 	mov.w	r2, #320	; 0x140
 802cb52:	4668      	mov	r0, sp
 802cb54:	f00e f9d8 	bl	803af08 <UTIL_MEM_cpy_8>

  /* Ask for installation at next reset */
  if (HAL_FLASH_Unlock() == HAL_OK)
 802cb58:	f001 fb9e 	bl	802e298 <HAL_FLASH_Unlock>
 802cb5c:	4602      	mov	r2, r0
 802cb5e:	bb58      	cbnz	r0, 802cbb8 <FwUpdateAgent_Run+0x74>
  uint32_t first_page = PAGE(FRAG_DECODER_SWAP_REGION_START);
 802cb60:	4d18      	ldr	r5, [pc, #96]	; (802cbc4 <FwUpdateAgent_Run+0x80>)
 802cb62:	4b19      	ldr	r3, [pc, #100]	; (802cbc8 <FwUpdateAgent_Run+0x84>)
  uint32_t nb_pages = PAGE(FRAG_DECODER_SWAP_REGION_START + SFU_IMG_IMAGE_OFFSET - 1) - first_page + 1U;
 802cb64:	f205 10ff 	addw	r0, r5, #511	; 0x1ff
  uint32_t first_page = PAGE(FRAG_DECODER_SWAP_REGION_START);
 802cb68:	ea03 2384 	and.w	r3, r3, r4, lsl #10
  uint32_t nb_pages = PAGE(FRAG_DECODER_SWAP_REGION_START + SFU_IMG_IMAGE_OFFSET - 1) - first_page + 1U;
 802cb6c:	fbb0 f1f3 	udiv	r1, r0, r3
 802cb70:	fb03 0111 	mls	r1, r3, r1, r0
 802cb74:	0ac9      	lsrs	r1, r1, #11
  uint32_t first_page = PAGE(FRAG_DECODER_SWAP_REGION_START);
 802cb76:	fbb5 f4f3 	udiv	r4, r5, r3
  uint32_t nb_pages = PAGE(FRAG_DECODER_SWAP_REGION_START + SFU_IMG_IMAGE_OFFSET - 1) - first_page + 1U;
 802cb7a:	3101      	adds	r1, #1
  uint32_t first_page = PAGE(FRAG_DECODER_SWAP_REGION_START);
 802cb7c:	fb03 5414 	mls	r4, r3, r4, r5
  uint32_t nb_pages = PAGE(FRAG_DECODER_SWAP_REGION_START + SFU_IMG_IMAGE_OFFSET - 1) - first_page + 1U;
 802cb80:	eba1 21d4 	sub.w	r1, r1, r4, lsr #11
  {
    status = FLASH_IF_EraseByPages(first_page, nb_pages, 0U);
 802cb84:	0ae0      	lsrs	r0, r4, #11
 802cb86:	b289      	uxth	r1, r1
 802cb88:	f7ff fa95 	bl	802c0b6 <FLASH_IF_EraseByPages>

    if (status == FLASH_OK)
 802cb8c:	4604      	mov	r4, r0
 802cb8e:	b940      	cbnz	r0, 802cba2 <FwUpdateAgent_Run+0x5e>
    {
      status = FLASH_IF_Write(FRAG_DECODER_SWAP_REGION_START, fw_header_dwl_slot, SE_FW_HEADER_TOT_LEN, NULL);
 802cb90:	4603      	mov	r3, r0
 802cb92:	f44f 72a0 	mov.w	r2, #320	; 0x140
 802cb96:	4669      	mov	r1, sp
 802cb98:	f105 6000 	add.w	r0, r5, #134217728	; 0x8000000
 802cb9c:	f7ff faa2 	bl	802c0e4 <FLASH_IF_Write>
 802cba0:	4604      	mov	r4, r0
    }
    HAL_FLASH_Lock();
 802cba2:	f001 fb8b 	bl	802e2bc <HAL_FLASH_Lock>
  else
  {
    status = FLASH_LOCK_ERROR;
  }

  if (status == FLASH_OK)
 802cba6:	b93c      	cbnz	r4, 802cbb8 <FwUpdateAgent_Run+0x74>
  {
    /* System Reboot*/
    // NVIC_SystemReset();
    APP_LOG(TS_OFF, VLEVEL_M, "Ready to install the new image at next reset\r\n");
 802cba8:	4b08      	ldr	r3, [pc, #32]	; (802cbcc <FwUpdateAgent_Run+0x88>)
  }
  else
  {
    APP_LOG(TS_OFF, VLEVEL_M, "FW Update Agent Run Failed\r\n");
 802cbaa:	2200      	movs	r2, #0
 802cbac:	4611      	mov	r1, r2
 802cbae:	2002      	movs	r0, #2
 802cbb0:	f00e f8a2 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
  }
  /* USER CODE BEGIN FwUpdateAgent_Run_2 */

  /* USER CODE END FwUpdateAgent_Run_2 */
}
 802cbb4:	b051      	add	sp, #324	; 0x144
 802cbb6:	bd30      	pop	{r4, r5, pc}
    APP_LOG(TS_OFF, VLEVEL_M, "FW Update Agent Run Failed\r\n");
 802cbb8:	4b05      	ldr	r3, [pc, #20]	; (802cbd0 <FwUpdateAgent_Run+0x8c>)
 802cbba:	e7f6      	b.n	802cbaa <FwUpdateAgent_Run+0x66>
 802cbbc:	1fff75e0 	.word	0x1fff75e0
 802cbc0:	08016000 	.word	0x08016000
 802cbc4:	00015000 	.word	0x00015000
 802cbc8:	03fffc00 	.word	0x03fffc00
 802cbcc:	0803bda7 	.word	0x0803bda7
 802cbd0:	0803bdd6 	.word	0x0803bdd6

0802cbd4 <OnMacProcessNotify>:
static void OnMacProcessNotify(void)
{
  /* USER CODE BEGIN OnMacProcessNotify_1 */

  /* USER CODE END OnMacProcessNotify_1 */
  UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_LmHandlerProcess), CFG_SEQ_Prio_0);
 802cbd4:	2100      	movs	r1, #0
 802cbd6:	2001      	movs	r0, #1
 802cbd8:	f00e b9a8 	b.w	803af2c <UTIL_SEQ_SetTask>

0802cbdc <OnClassChange>:
  if (deviceClass == CLASS_C)
 802cbdc:	2802      	cmp	r0, #2
    UTIL_TIMER_Stop(&TxTimer);
 802cbde:	4803      	ldr	r0, [pc, #12]	; (802cbec <OnClassChange+0x10>)
  if (deviceClass == CLASS_C)
 802cbe0:	d101      	bne.n	802cbe6 <OnClassChange+0xa>
    UTIL_TIMER_Stop(&TxTimer);
 802cbe2:	f00e bbab 	b.w	803b33c <UTIL_TIMER_Stop>
    UTIL_TIMER_Start(&TxTimer);
 802cbe6:	f00e bbf9 	b.w	803b3dc <UTIL_TIMER_Start>
 802cbea:	bf00      	nop
 802cbec:	200035d8 	.word	0x200035d8

0802cbf0 <OnRxData>:
{
 802cbf0:	b530      	push	{r4, r5, lr}
 802cbf2:	460d      	mov	r5, r1
 802cbf4:	b087      	sub	sp, #28
  if ((appData != NULL) || (params != NULL))
 802cbf6:	4604      	mov	r4, r0
 802cbf8:	b908      	cbnz	r0, 802cbfe <OnRxData+0xe>
 802cbfa:	2900      	cmp	r1, #0
 802cbfc:	d057      	beq.n	802ccae <OnRxData+0xbe>
    BSP_LED_On(LED_BLUE) ;
 802cbfe:	2000      	movs	r0, #0
 802cc00:	f000 fb1e 	bl	802d240 <BSP_LED_On>
    UTIL_TIMER_Start(&RxLedTimer);
 802cc04:	482b      	ldr	r0, [pc, #172]	; (802ccb4 <OnRxData+0xc4>)
 802cc06:	f00e fbe9 	bl	803b3dc <UTIL_TIMER_Start>
    APP_LOG(TS_OFF, VLEVEL_M, "\r\n###### ========== MCPS-Indication ==========\r\n");
 802cc0a:	2200      	movs	r2, #0
 802cc0c:	4611      	mov	r1, r2
 802cc0e:	4b2a      	ldr	r3, [pc, #168]	; (802ccb8 <OnRxData+0xc8>)
 802cc10:	2002      	movs	r0, #2
 802cc12:	f00e f871 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
    APP_LOG(TS_OFF, VLEVEL_H, "###### D/L FRAME:%04d | SLOT:%s | PORT:%d | DR:%d | RSSI:%d | SNR:%d\r\n",
 802cc16:	f995 3004 	ldrsb.w	r3, [r5, #4]
 802cc1a:	9305      	str	r3, [sp, #20]
 802cc1c:	f995 3003 	ldrsb.w	r3, [r5, #3]
 802cc20:	9304      	str	r3, [sp, #16]
 802cc22:	f995 3002 	ldrsb.w	r3, [r5, #2]
 802cc26:	9303      	str	r3, [sp, #12]
 802cc28:	7823      	ldrb	r3, [r4, #0]
 802cc2a:	9302      	str	r3, [sp, #8]
 802cc2c:	f995 200c 	ldrsb.w	r2, [r5, #12]
 802cc30:	4b22      	ldr	r3, [pc, #136]	; (802ccbc <OnRxData+0xcc>)
 802cc32:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 802cc36:	9301      	str	r3, [sp, #4]
 802cc38:	68ab      	ldr	r3, [r5, #8]
 802cc3a:	9300      	str	r3, [sp, #0]
 802cc3c:	2200      	movs	r2, #0
 802cc3e:	4b20      	ldr	r3, [pc, #128]	; (802ccc0 <OnRxData+0xd0>)
 802cc40:	4611      	mov	r1, r2
 802cc42:	2003      	movs	r0, #3
 802cc44:	f00e f858 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
    switch (appData->Port)
 802cc48:	7825      	ldrb	r5, [r4, #0]
 802cc4a:	2d02      	cmp	r5, #2
 802cc4c:	d010      	beq.n	802cc70 <OnRxData+0x80>
 802cc4e:	2d03      	cmp	r5, #3
 802cc50:	d12d      	bne.n	802ccae <OnRxData+0xbe>
        if (appData->BufferSize == 1)
 802cc52:	7863      	ldrb	r3, [r4, #1]
 802cc54:	2b01      	cmp	r3, #1
 802cc56:	d12a      	bne.n	802ccae <OnRxData+0xbe>
          switch (appData->Buffer[0])
 802cc58:	6863      	ldr	r3, [r4, #4]
 802cc5a:	7818      	ldrb	r0, [r3, #0]
 802cc5c:	2801      	cmp	r0, #1
 802cc5e:	d002      	beq.n	802cc66 <OnRxData+0x76>
 802cc60:	2802      	cmp	r0, #2
 802cc62:	d000      	beq.n	802cc66 <OnRxData+0x76>
 802cc64:	bb18      	cbnz	r0, 802ccae <OnRxData+0xbe>
}
 802cc66:	b007      	add	sp, #28
 802cc68:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
              LmHandlerRequestClass(CLASS_C);
 802cc6c:	f004 bcb4 	b.w	80315d8 <LmHandlerRequestClass>
        if (appData->BufferSize == 1)
 802cc70:	7863      	ldrb	r3, [r4, #1]
 802cc72:	2b01      	cmp	r3, #1
 802cc74:	d11b      	bne.n	802ccae <OnRxData+0xbe>
          AppLedStateOn = appData->Buffer[0] & 0x01;
 802cc76:	6863      	ldr	r3, [r4, #4]
 802cc78:	781a      	ldrb	r2, [r3, #0]
          if (AppLedStateOn == RESET)
 802cc7a:	f012 0201 	ands.w	r2, r2, #1
 802cc7e:	d10a      	bne.n	802cc96 <OnRxData+0xa6>
            APP_LOG(TS_OFF, VLEVEL_H,   "LED OFF\r\n");
 802cc80:	4b10      	ldr	r3, [pc, #64]	; (802ccc4 <OnRxData+0xd4>)
 802cc82:	4611      	mov	r1, r2
 802cc84:	2003      	movs	r0, #3
 802cc86:	f00e f837 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
            BSP_LED_Off(LED_RED) ;
 802cc8a:	4628      	mov	r0, r5
}
 802cc8c:	b007      	add	sp, #28
 802cc8e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
            BSP_LED_Off(LED_RED) ;
 802cc92:	f000 bae3 	b.w	802d25c <BSP_LED_Off>
            APP_LOG(TS_OFF, VLEVEL_H, "LED ON\r\n");
 802cc96:	2200      	movs	r2, #0
 802cc98:	4b0b      	ldr	r3, [pc, #44]	; (802ccc8 <OnRxData+0xd8>)
 802cc9a:	4611      	mov	r1, r2
 802cc9c:	2003      	movs	r0, #3
 802cc9e:	f00e f82b 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
            BSP_LED_On(LED_RED) ;
 802cca2:	4628      	mov	r0, r5
}
 802cca4:	b007      	add	sp, #28
 802cca6:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
            BSP_LED_On(LED_RED) ;
 802ccaa:	f000 bac9 	b.w	802d240 <BSP_LED_On>
}
 802ccae:	b007      	add	sp, #28
 802ccb0:	bd30      	pop	{r4, r5, pc}
 802ccb2:	bf00      	nop
 802ccb4:	200035f0 	.word	0x200035f0
 802ccb8:	0803bdf3 	.word	0x0803bdf3
 802ccbc:	0803b948 	.word	0x0803b948
 802ccc0:	0803be24 	.word	0x0803be24
 802ccc4:	0803be6b 	.word	0x0803be6b
 802ccc8:	0803be75 	.word	0x0803be75

0802cccc <OnRxTimerLedEvent>:
  BSP_LED_Off(LED_BLUE) ;
 802cccc:	2000      	movs	r0, #0
 802ccce:	f000 bac5 	b.w	802d25c <BSP_LED_Off>

0802ccd2 <OnTxTimerLedEvent>:
  BSP_LED_Off(LED_GREEN) ;
 802ccd2:	2001      	movs	r0, #1
 802ccd4:	f000 bac2 	b.w	802d25c <BSP_LED_Off>

0802ccd8 <OnJoinTimerLedEvent>:
  BSP_LED_Toggle(LED_RED) ;
 802ccd8:	2002      	movs	r0, #2
 802ccda:	f000 bacd 	b.w	802d278 <BSP_LED_Toggle>
	...

0802cce0 <OnTxData>:
{
 802cce0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  if ((params != NULL))
 802cce2:	4604      	mov	r4, r0
 802cce4:	2800      	cmp	r0, #0
 802cce6:	d034      	beq.n	802cd52 <OnTxData+0x72>
    if (params->IsMcpsConfirm != 0)
 802cce8:	7803      	ldrb	r3, [r0, #0]
 802ccea:	2b00      	cmp	r3, #0
 802ccec:	d031      	beq.n	802cd52 <OnTxData+0x72>
      BSP_LED_On(LED_GREEN) ;
 802ccee:	2001      	movs	r0, #1
 802ccf0:	f000 faa6 	bl	802d240 <BSP_LED_On>
      UTIL_TIMER_Start(&TxLedTimer);
 802ccf4:	481c      	ldr	r0, [pc, #112]	; (802cd68 <OnTxData+0x88>)
 802ccf6:	f00e fb71 	bl	803b3dc <UTIL_TIMER_Start>
      APP_LOG(TS_OFF, VLEVEL_M, "\r\n###### ========== MCPS-Confirm =============\r\n");
 802ccfa:	2200      	movs	r2, #0
 802ccfc:	4611      	mov	r1, r2
 802ccfe:	4b1b      	ldr	r3, [pc, #108]	; (802cd6c <OnTxData+0x8c>)
 802cd00:	2002      	movs	r0, #2
 802cd02:	f00d fff9 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
      APP_LOG(TS_OFF, VLEVEL_H, "###### U/L FRAME:%04d | PORT:%d | DR:%d | PWR:%d", params->UplinkCounter,
 802cd06:	f994 3014 	ldrsb.w	r3, [r4, #20]
 802cd0a:	9303      	str	r3, [sp, #12]
 802cd0c:	f994 3004 	ldrsb.w	r3, [r4, #4]
 802cd10:	9302      	str	r3, [sp, #8]
 802cd12:	7b23      	ldrb	r3, [r4, #12]
 802cd14:	9301      	str	r3, [sp, #4]
 802cd16:	68a3      	ldr	r3, [r4, #8]
 802cd18:	9300      	str	r3, [sp, #0]
 802cd1a:	2200      	movs	r2, #0
 802cd1c:	4611      	mov	r1, r2
 802cd1e:	4b14      	ldr	r3, [pc, #80]	; (802cd70 <OnTxData+0x90>)
 802cd20:	2003      	movs	r0, #3
 802cd22:	f00d ffe9 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
      APP_LOG(TS_OFF, VLEVEL_H, " | MSG TYPE:");
 802cd26:	2200      	movs	r2, #0
 802cd28:	4b12      	ldr	r3, [pc, #72]	; (802cd74 <OnTxData+0x94>)
 802cd2a:	4611      	mov	r1, r2
 802cd2c:	2003      	movs	r0, #3
 802cd2e:	f00d ffe3 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
      if (params->MsgType == LORAMAC_HANDLER_CONFIRMED_MSG)
 802cd32:	78a3      	ldrb	r3, [r4, #2]
 802cd34:	2b01      	cmp	r3, #1
 802cd36:	d10e      	bne.n	802cd56 <OnTxData+0x76>
        APP_LOG(TS_OFF, VLEVEL_H, "CONFIRMED [%s]\r\n", (params->AckReceived != 0) ? "ACK" : "NACK");
 802cd38:	78e1      	ldrb	r1, [r4, #3]
 802cd3a:	4a0f      	ldr	r2, [pc, #60]	; (802cd78 <OnTxData+0x98>)
 802cd3c:	4b0f      	ldr	r3, [pc, #60]	; (802cd7c <OnTxData+0x9c>)
 802cd3e:	2900      	cmp	r1, #0
 802cd40:	bf08      	it	eq
 802cd42:	4613      	moveq	r3, r2
 802cd44:	2200      	movs	r2, #0
 802cd46:	9300      	str	r3, [sp, #0]
 802cd48:	4611      	mov	r1, r2
 802cd4a:	4b0d      	ldr	r3, [pc, #52]	; (802cd80 <OnTxData+0xa0>)
 802cd4c:	2003      	movs	r0, #3
 802cd4e:	f00d ffd3 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
}
 802cd52:	b004      	add	sp, #16
 802cd54:	bd10      	pop	{r4, pc}
        APP_LOG(TS_OFF, VLEVEL_H, "UNCONFIRMED\r\n");
 802cd56:	2200      	movs	r2, #0
 802cd58:	4b0a      	ldr	r3, [pc, #40]	; (802cd84 <OnTxData+0xa4>)
 802cd5a:	4611      	mov	r1, r2
 802cd5c:	2003      	movs	r0, #3
}
 802cd5e:	b004      	add	sp, #16
 802cd60:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        APP_LOG(TS_OFF, VLEVEL_H, "UNCONFIRMED\r\n");
 802cd64:	f00d bfc8 	b.w	803acf8 <UTIL_ADV_TRACE_COND_FSend>
 802cd68:	20003608 	.word	0x20003608
 802cd6c:	0803be83 	.word	0x0803be83
 802cd70:	0803beb4 	.word	0x0803beb4
 802cd74:	0803bee5 	.word	0x0803bee5
 802cd78:	0803be7e 	.word	0x0803be7e
 802cd7c:	0803be7f 	.word	0x0803be7f
 802cd80:	0803bef2 	.word	0x0803bef2
 802cd84:	0803bf03 	.word	0x0803bf03

0802cd88 <OnJoinRequest>:
{
 802cd88:	b570      	push	{r4, r5, r6, lr}
  if (joinParams != NULL)
 802cd8a:	4605      	mov	r5, r0
 802cd8c:	b320      	cbz	r0, 802cdd8 <OnJoinRequest+0x50>
    if (joinParams->Status == LORAMAC_HANDLER_SUCCESS)
 802cd8e:	f990 4001 	ldrsb.w	r4, [r0, #1]
 802cd92:	b9cc      	cbnz	r4, 802cdc8 <OnJoinRequest+0x40>
      UTIL_TIMER_Stop(&JoinLedTimer);
 802cd94:	4811      	ldr	r0, [pc, #68]	; (802cddc <OnJoinRequest+0x54>)
 802cd96:	f00e fad1 	bl	803b33c <UTIL_TIMER_Stop>
      BSP_LED_Off(LED_RED) ;
 802cd9a:	2002      	movs	r0, #2
 802cd9c:	f000 fa5e 	bl	802d25c <BSP_LED_Off>
      APP_LOG(TS_OFF, VLEVEL_M, "\r\n###### = JOINED = ");
 802cda0:	4622      	mov	r2, r4
 802cda2:	4621      	mov	r1, r4
 802cda4:	4b0e      	ldr	r3, [pc, #56]	; (802cde0 <OnJoinRequest+0x58>)
 802cda6:	2002      	movs	r0, #2
 802cda8:	f00d ffa6 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
      if (joinParams->Mode == ACTIVATION_TYPE_ABP)
 802cdac:	78ab      	ldrb	r3, [r5, #2]
 802cdae:	2b01      	cmp	r3, #1
        APP_LOG(TS_OFF, VLEVEL_M, "OTAA =====================\r\n");
 802cdb0:	4622      	mov	r2, r4
 802cdb2:	4621      	mov	r1, r4
        APP_LOG(TS_OFF, VLEVEL_M, "ABP ======================\r\n");
 802cdb4:	bf0c      	ite	eq
 802cdb6:	4b0b      	ldreq	r3, [pc, #44]	; (802cde4 <OnJoinRequest+0x5c>)
        APP_LOG(TS_OFF, VLEVEL_M, "OTAA =====================\r\n");
 802cdb8:	4b0b      	ldrne	r3, [pc, #44]	; (802cde8 <OnJoinRequest+0x60>)
 802cdba:	2002      	movs	r0, #2
 802cdbc:	f00d ff9c 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
}
 802cdc0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      LmHandlerDeviceTimeReq();
 802cdc4:	f004 baca 	b.w	803135c <LmHandlerDeviceTimeReq>
      APP_LOG(TS_OFF, VLEVEL_M, "\r\n###### = JOIN FAILED\r\n");
 802cdc8:	2200      	movs	r2, #0
}
 802cdca:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      APP_LOG(TS_OFF, VLEVEL_M, "\r\n###### = JOIN FAILED\r\n");
 802cdce:	4b07      	ldr	r3, [pc, #28]	; (802cdec <OnJoinRequest+0x64>)
 802cdd0:	4611      	mov	r1, r2
 802cdd2:	2002      	movs	r0, #2
 802cdd4:	f00d bf90 	b.w	803acf8 <UTIL_ADV_TRACE_COND_FSend>
}
 802cdd8:	bd70      	pop	{r4, r5, r6, pc}
 802cdda:	bf00      	nop
 802cddc:	20003620 	.word	0x20003620
 802cde0:	0803bf11 	.word	0x0803bf11
 802cde4:	0803bf26 	.word	0x0803bf26
 802cde8:	0803bf43 	.word	0x0803bf43
 802cdec:	0803bf60 	.word	0x0803bf60

0802cdf0 <SendTxData>:
{
 802cdf0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  AppData.Port = 2;
 802cdf2:	4813      	ldr	r0, [pc, #76]	; (802ce40 <SendTxData+0x50>)
  AppData.Buffer[j++] = 0;
 802cdf4:	6842      	ldr	r2, [r0, #4]
  UTIL_TIMER_Time_t nextTxIn = 0;
 802cdf6:	2400      	movs	r4, #0
  AppData.Port = 2;
 802cdf8:	2302      	movs	r3, #2
  UTIL_TIMER_Time_t nextTxIn = 0;
 802cdfa:	9403      	str	r4, [sp, #12]
  AppData.Port = 2;
 802cdfc:	7003      	strb	r3, [r0, #0]
  AppData.Buffer[j++] = 0;
 802cdfe:	7014      	strb	r4, [r2, #0]
  AppData.Buffer[j++] = 2;
 802ce00:	6842      	ldr	r2, [r0, #4]
  if (LORAMAC_HANDLER_SUCCESS == LmHandlerSend(&AppData, LORAWAN_DEFAULT_CONFIRMED_MSG_STATE, &nextTxIn, false))
 802ce02:	4621      	mov	r1, r4
  AppData.Buffer[j++] = 2;
 802ce04:	7053      	strb	r3, [r2, #1]
  AppData.BufferSize = j;
 802ce06:	7043      	strb	r3, [r0, #1]
  if (LORAMAC_HANDLER_SUCCESS == LmHandlerSend(&AppData, LORAWAN_DEFAULT_CONFIRMED_MSG_STATE, &nextTxIn, false))
 802ce08:	aa03      	add	r2, sp, #12
 802ce0a:	4623      	mov	r3, r4
 802ce0c:	f004 fca4 	bl	8031758 <LmHandlerSend>
 802ce10:	4601      	mov	r1, r0
 802ce12:	b930      	cbnz	r0, 802ce22 <SendTxData+0x32>
    APP_LOG(TS_ON, VLEVEL_L, "SEND REQUEST\r\n");
 802ce14:	2201      	movs	r2, #1
 802ce16:	4b0b      	ldr	r3, [pc, #44]	; (802ce44 <SendTxData+0x54>)
 802ce18:	4610      	mov	r0, r2
 802ce1a:	f00d ff6d 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
}
 802ce1e:	b004      	add	sp, #16
 802ce20:	bd10      	pop	{r4, pc}
  else if (nextTxIn > 0)
 802ce22:	9b03      	ldr	r3, [sp, #12]
 802ce24:	2b00      	cmp	r3, #0
 802ce26:	d0fa      	beq.n	802ce1e <SendTxData+0x2e>
    APP_LOG(TS_ON, VLEVEL_L, "Next Tx in  : ~%d second(s)\r\n", (nextTxIn / 1000));
 802ce28:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 802ce2c:	fbb3 f3f2 	udiv	r3, r3, r2
 802ce30:	2201      	movs	r2, #1
 802ce32:	9300      	str	r3, [sp, #0]
 802ce34:	4621      	mov	r1, r4
 802ce36:	4b04      	ldr	r3, [pc, #16]	; (802ce48 <SendTxData+0x58>)
 802ce38:	4610      	mov	r0, r2
 802ce3a:	f00d ff5d 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
}
 802ce3e:	e7ee      	b.n	802ce1e <SendTxData+0x2e>
 802ce40:	20003400 	.word	0x20003400
 802ce44:	0803bf79 	.word	0x0803bf79
 802ce48:	0803bf88 	.word	0x0803bf88

0802ce4c <LoRaWAN_Init>:
{
 802ce4c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  BSP_LED_Init(LED_BLUE);
 802ce50:	2000      	movs	r0, #0
{
 802ce52:	b085      	sub	sp, #20
  BSP_LED_Init(LED_BLUE);
 802ce54:	f000 f9ce 	bl	802d1f4 <BSP_LED_Init>
  BSP_LED_Init(LED_GREEN);
 802ce58:	2001      	movs	r0, #1
 802ce5a:	f000 f9cb 	bl	802d1f4 <BSP_LED_Init>
  BSP_LED_Init(LED_RED);
 802ce5e:	2002      	movs	r0, #2
 802ce60:	f000 f9c8 	bl	802d1f4 <BSP_LED_Init>
  BSP_PB_Init(BUTTON_SW2, BUTTON_MODE_EXTI);
 802ce64:	2101      	movs	r1, #1
 802ce66:	4608      	mov	r0, r1
 802ce68:	f000 fa14 	bl	802d294 <BSP_PB_Init>
  APP_LOG(TS_OFF, VLEVEL_M, "APP_VERSION:        V%X.%X.%X\r\n",
 802ce6c:	2501      	movs	r5, #1
 802ce6e:	2602      	movs	r6, #2
 802ce70:	2200      	movs	r2, #0
 802ce72:	4611      	mov	r1, r2
 802ce74:	e9cd 5601 	strd	r5, r6, [sp, #4]
 802ce78:	4b34      	ldr	r3, [pc, #208]	; (802cf4c <LoRaWAN_Init+0x100>)
 802ce7a:	9500      	str	r5, [sp, #0]
 802ce7c:	4630      	mov	r0, r6
  APP_LOG(TS_OFF, VLEVEL_M, "MW_LORAWAN_VERSION: V%X.%X.%X\r\n",
 802ce7e:	2400      	movs	r4, #0
  APP_LOG(TS_OFF, VLEVEL_M, "APP_VERSION:        V%X.%X.%X\r\n",
 802ce80:	f00d ff3a 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
  UTIL_TIMER_Create(&TxLedTimer, 0xFFFFFFFFU, UTIL_TIMER_ONESHOT, OnTxTimerLedEvent, NULL);
 802ce84:	4f32      	ldr	r7, [pc, #200]	; (802cf50 <LoRaWAN_Init+0x104>)
  APP_LOG(TS_OFF, VLEVEL_M, "MW_LORAWAN_VERSION: V%X.%X.%X\r\n",
 802ce86:	9600      	str	r6, [sp, #0]
 802ce88:	2303      	movs	r3, #3
 802ce8a:	e9cd 3401 	strd	r3, r4, [sp, #4]
 802ce8e:	4622      	mov	r2, r4
 802ce90:	4621      	mov	r1, r4
 802ce92:	4b30      	ldr	r3, [pc, #192]	; (802cf54 <LoRaWAN_Init+0x108>)
 802ce94:	4630      	mov	r0, r6
 802ce96:	f00d ff2f 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
  UTIL_TIMER_Create(&TxLedTimer, 0xFFFFFFFFU, UTIL_TIMER_ONESHOT, OnTxTimerLedEvent, NULL);
 802ce9a:	f107 0930 	add.w	r9, r7, #48	; 0x30
  APP_LOG(TS_OFF, VLEVEL_M, "MW_RADIO_VERSION:   V%X.%X.%X\r\n",
 802ce9e:	4622      	mov	r2, r4
 802cea0:	4621      	mov	r1, r4
 802cea2:	e9cd 5401 	strd	r5, r4, [sp, #4]
 802cea6:	4b2c      	ldr	r3, [pc, #176]	; (802cf58 <LoRaWAN_Init+0x10c>)
 802cea8:	9500      	str	r5, [sp, #0]
 802ceaa:	4630      	mov	r0, r6
 802ceac:	f00d ff24 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
  UTIL_TIMER_Create(&RxLedTimer, 0xFFFFFFFFU, UTIL_TIMER_ONESHOT, OnRxTimerLedEvent, NULL);
 802ceb0:	f107 0818 	add.w	r8, r7, #24
  UTIL_TIMER_Create(&TxLedTimer, 0xFFFFFFFFU, UTIL_TIMER_ONESHOT, OnTxTimerLedEvent, NULL);
 802ceb4:	4622      	mov	r2, r4
 802ceb6:	4b29      	ldr	r3, [pc, #164]	; (802cf5c <LoRaWAN_Init+0x110>)
 802ceb8:	9400      	str	r4, [sp, #0]
 802ceba:	f04f 31ff 	mov.w	r1, #4294967295
 802cebe:	4648      	mov	r0, r9
 802cec0:	f00e f9de 	bl	803b280 <UTIL_TIMER_Create>
  UTIL_TIMER_Create(&JoinLedTimer, 0xFFFFFFFFU, UTIL_TIMER_PERIODIC, OnJoinTimerLedEvent, NULL);
 802cec4:	3748      	adds	r7, #72	; 0x48
  UTIL_TIMER_Create(&RxLedTimer, 0xFFFFFFFFU, UTIL_TIMER_ONESHOT, OnRxTimerLedEvent, NULL);
 802cec6:	4622      	mov	r2, r4
 802cec8:	4b25      	ldr	r3, [pc, #148]	; (802cf60 <LoRaWAN_Init+0x114>)
 802ceca:	9400      	str	r4, [sp, #0]
 802cecc:	f04f 31ff 	mov.w	r1, #4294967295
 802ced0:	4640      	mov	r0, r8
 802ced2:	f00e f9d5 	bl	803b280 <UTIL_TIMER_Create>
  UTIL_TIMER_Create(&JoinLedTimer, 0xFFFFFFFFU, UTIL_TIMER_PERIODIC, OnJoinTimerLedEvent, NULL);
 802ced6:	4b23      	ldr	r3, [pc, #140]	; (802cf64 <LoRaWAN_Init+0x118>)
 802ced8:	9400      	str	r4, [sp, #0]
 802ceda:	462a      	mov	r2, r5
 802cedc:	f04f 31ff 	mov.w	r1, #4294967295
 802cee0:	4638      	mov	r0, r7
 802cee2:	f00e f9cd 	bl	803b280 <UTIL_TIMER_Create>
  UTIL_TIMER_SetPeriod(&TxLedTimer, 500);
 802cee6:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 802ceea:	4648      	mov	r0, r9
 802ceec:	f00e fab0 	bl	803b450 <UTIL_TIMER_SetPeriod>
  UTIL_TIMER_SetPeriod(&RxLedTimer, 500);
 802cef0:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 802cef4:	4640      	mov	r0, r8
 802cef6:	f00e faab 	bl	803b450 <UTIL_TIMER_SetPeriod>
  UTIL_TIMER_SetPeriod(&JoinLedTimer, 500);
 802cefa:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 802cefe:	4638      	mov	r0, r7
 802cf00:	f00e faa6 	bl	803b450 <UTIL_TIMER_SetPeriod>
  LmHandlerInit(&LmHandlerCallbacks);
 802cf04:	f8df 8068 	ldr.w	r8, [pc, #104]	; 802cf70 <LoRaWAN_Init+0x124>
  UTIL_SEQ_RegTask((1 << CFG_SEQ_Task_LmHandlerProcess), UTIL_SEQ_RFU, LmHandlerProcess);
 802cf08:	4a17      	ldr	r2, [pc, #92]	; (802cf68 <LoRaWAN_Init+0x11c>)
 802cf0a:	4621      	mov	r1, r4
 802cf0c:	4628      	mov	r0, r5
 802cf0e:	f00e f8b7 	bl	803b080 <UTIL_SEQ_RegTask>
  UTIL_SEQ_RegTask((1 << CFG_SEQ_Task_LoRaSendOnTxTimerOrButtonEvent), UTIL_SEQ_RFU, SendTxData);
 802cf12:	4621      	mov	r1, r4
 802cf14:	4a15      	ldr	r2, [pc, #84]	; (802cf6c <LoRaWAN_Init+0x120>)
 802cf16:	4630      	mov	r0, r6
 802cf18:	f00e f8b2 	bl	803b080 <UTIL_SEQ_RegTask>
  LoraInfo_Init();
 802cf1c:	f000 f864 	bl	802cfe8 <LoraInfo_Init>
  LmHandlerInit(&LmHandlerCallbacks);
 802cf20:	f108 0008 	add.w	r0, r8, #8
 802cf24:	f004 fdca 	bl	8031abc <LmHandlerInit>
  LmHandlerConfigure(&LmHandlerParams);
 802cf28:	f108 003c 	add.w	r0, r8, #60	; 0x3c
 802cf2c:	f004 fa4a 	bl	80313c4 <LmHandlerConfigure>
  UTIL_TIMER_Start(&JoinLedTimer);
 802cf30:	4638      	mov	r0, r7
 802cf32:	f00e fa53 	bl	803b3dc <UTIL_TIMER_Start>
  LmHandlerJoin(ActivationType);
 802cf36:	4630      	mov	r0, r6
 802cf38:	f004 fbac 	bl	8031694 <LmHandlerJoin>
    BSP_PB_Init(BUTTON_SW1, BUTTON_MODE_EXTI);
 802cf3c:	4629      	mov	r1, r5
 802cf3e:	4620      	mov	r0, r4
}
 802cf40:	b005      	add	sp, #20
 802cf42:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    BSP_PB_Init(BUTTON_SW1, BUTTON_MODE_EXTI);
 802cf46:	f000 b9a5 	b.w	802d294 <BSP_PB_Init>
 802cf4a:	bf00      	nop
 802cf4c:	0803bfa6 	.word	0x0803bfa6
 802cf50:	200035d8 	.word	0x200035d8
 802cf54:	0803bfc6 	.word	0x0803bfc6
 802cf58:	0803bfe6 	.word	0x0803bfe6
 802cf5c:	0802ccd3 	.word	0x0802ccd3
 802cf60:	0802cccd 	.word	0x0802cccd
 802cf64:	0802ccd9 	.word	0x0802ccd9
 802cf68:	08031575 	.word	0x08031575
 802cf6c:	0802cdf1 	.word	0x0802cdf1
 802cf70:	20003400 	.word	0x20003400

0802cf74 <HAL_GPIO_EXTI_Callback>:
  switch (GPIO_Pin)
 802cf74:	2801      	cmp	r0, #1
 802cf76:	d103      	bne.n	802cf80 <HAL_GPIO_EXTI_Callback+0xc>
      UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_LoRaSendOnTxTimerOrButtonEvent), CFG_SEQ_Prio_0);
 802cf78:	2100      	movs	r1, #0
 802cf7a:	2002      	movs	r0, #2
 802cf7c:	f00d bfd6 	b.w	803af2c <UTIL_SEQ_SetTask>
}
 802cf80:	4770      	bx	lr
	...

0802cf84 <SendTXStopFrag>:
void SendTXStopFrag(void){
 802cf84:	b530      	push	{r4, r5, lr}
	AppData.Port = 186;
 802cf86:	4815      	ldr	r0, [pc, #84]	; (802cfdc <SendTXStopFrag+0x58>)
 802cf88:	23ba      	movs	r3, #186	; 0xba
void SendTXStopFrag(void){
 802cf8a:	b085      	sub	sp, #20
	AppData.Port = 186;
 802cf8c:	7003      	strb	r3, [r0, #0]
	AppData.Buffer[i++] = 0;
 802cf8e:	6843      	ldr	r3, [r0, #4]
	UTIL_TIMER_Time_t nextTxIn = 0;
 802cf90:	2400      	movs	r4, #0
 802cf92:	9403      	str	r4, [sp, #12]
	AppData.Buffer[i++] = 0;
 802cf94:	701c      	strb	r4, [r3, #0]
	AppData.Buffer[i++] = 1;
 802cf96:	6843      	ldr	r3, [r0, #4]
 802cf98:	2501      	movs	r5, #1
 802cf9a:	705d      	strb	r5, [r3, #1]
	AppData.BufferSize = i;
 802cf9c:	2302      	movs	r3, #2
 802cf9e:	7043      	strb	r3, [r0, #1]
	if (LORAMAC_HANDLER_SUCCESS == LmHandlerSend(&AppData, LORAWAN_DEFAULT_CONFIRMED_MSG_STATE, &nextTxIn, false))
 802cfa0:	aa03      	add	r2, sp, #12
 802cfa2:	4623      	mov	r3, r4
 802cfa4:	4621      	mov	r1, r4
 802cfa6:	f004 fbd7 	bl	8031758 <LmHandlerSend>
 802cfaa:	4602      	mov	r2, r0
 802cfac:	b930      	cbnz	r0, 802cfbc <SendTXStopFrag+0x38>
		APP_LOG(TS_OFF, VLEVEL_L, "\r\nFRAME SENT (added function to stop the fragmentation process)\r\n");
 802cfae:	4601      	mov	r1, r0
 802cfb0:	4b0b      	ldr	r3, [pc, #44]	; (802cfe0 <SendTXStopFrag+0x5c>)
 802cfb2:	4628      	mov	r0, r5
 802cfb4:	f00d fea0 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
}
 802cfb8:	b005      	add	sp, #20
 802cfba:	bd30      	pop	{r4, r5, pc}
	  else if (nextTxIn > 0)
 802cfbc:	9b03      	ldr	r3, [sp, #12]
 802cfbe:	2b00      	cmp	r3, #0
 802cfc0:	d0fa      	beq.n	802cfb8 <SendTXStopFrag+0x34>
	    APP_LOG(TS_ON, VLEVEL_L, "Next Tx in  : ~%d second(s)\r\n", (nextTxIn / 1000));
 802cfc2:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 802cfc6:	4621      	mov	r1, r4
 802cfc8:	fbb3 f3f2 	udiv	r3, r3, r2
 802cfcc:	4628      	mov	r0, r5
 802cfce:	9300      	str	r3, [sp, #0]
 802cfd0:	462a      	mov	r2, r5
 802cfd2:	4b04      	ldr	r3, [pc, #16]	; (802cfe4 <SendTXStopFrag+0x60>)
 802cfd4:	f00d fe90 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
}
 802cfd8:	e7ee      	b.n	802cfb8 <SendTXStopFrag+0x34>
 802cfda:	bf00      	nop
 802cfdc:	20003400 	.word	0x20003400
 802cfe0:	0803c006 	.word	0x0803c006
 802cfe4:	0803bf88 	.word	0x0803bf88

0802cfe8 <LoraInfo_Init>:
/* Exported functions --------------------------------------------------------*/
void LoraInfo_Init(void)
{
  loraInfo.ActivationMode = 0;
  loraInfo.Region = 0;
  loraInfo.ClassB = 0;
 802cfe8:	4b05      	ldr	r3, [pc, #20]	; (802d000 <LoraInfo_Init+0x18>)
#endif /* REGION_KR920 */
#ifdef  REGION_IN865
  loraInfo.Region |= (1 << LORAMAC_REGION_IN865) ;
#endif /* REGION_IN865 */
#ifdef  REGION_US915
  loraInfo.Region |= (1 << LORAMAC_REGION_US915) ;
 802cfea:	f44f 7290 	mov.w	r2, #288	; 0x120
 802cfee:	2100      	movs	r1, #0
 802cff0:	e9c3 2101 	strd	r2, r1, [r3, #4]

#if (!defined (LORAWAN_KMS) || (LORAWAN_KMS == 0))
  loraInfo.Kms = 0;
  loraInfo.ActivationMode = 3;
#else /* LORAWAN_KMS == 1 */
  loraInfo.Kms = 1;
 802cff4:	2201      	movs	r2, #1
 802cff6:	60da      	str	r2, [r3, #12]
  loraInfo.ActivationMode = ACTIVATION_BY_PERSONALIZATION + (OVER_THE_AIR_ACTIVATION << 1);
 802cff8:	2203      	movs	r2, #3
 802cffa:	601a      	str	r2, [r3, #0]
#endif /* LORAWAN_KMS */
  /* USER CODE BEGIN LoraInfo_Init_2 */

  /* USER CODE END LoraInfo_Init_2 */
}
 802cffc:	4770      	bx	lr
 802cffe:	bf00      	nop
 802d000:	2000372c 	.word	0x2000372c

0802d004 <LoraInfo_GetPtr>:
{
  /* USER CODE BEGIN LoraInfo_GetPtr */

  /* USER CODE END LoraInfo_GetPtr */
  return &loraInfo;
}
 802d004:	4800      	ldr	r0, [pc, #0]	; (802d008 <LoraInfo_GetPtr+0x4>)
 802d006:	4770      	bx	lr
 802d008:	2000372c 	.word	0x2000372c

0802d00c <FRAG_DECODER_IF_Erase>:

/* USER CODE END PFP */

/* Exported functions --------------------------------------------------------*/
int32_t FRAG_DECODER_IF_Erase(void)
{
 802d00c:	b538      	push	{r3, r4, r5, lr}
  /* USER CODE END FRAG_DECODER_IF_Erase_1 */
  int32_t status = FLASH_OK;
#if (INTEROP_TEST_MODE == 1)
  UTIL_MEM_set_8(UnfragmentedData, 0xFF, UNFRAGMENTED_DATA_SIZE);
#else /* INTEROP_TEST_MODE == 0 */
  uint32_t first_page = PAGE(FRAG_DECODER_DWL_REGION_START);
 802d00e:	4b16      	ldr	r3, [pc, #88]	; (802d068 <FRAG_DECODER_IF_Erase+0x5c>)
 802d010:	4c16      	ldr	r4, [pc, #88]	; (802d06c <FRAG_DECODER_IF_Erase+0x60>)
 802d012:	681b      	ldr	r3, [r3, #0]
 802d014:	4a16      	ldr	r2, [pc, #88]	; (802d070 <FRAG_DECODER_IF_Erase+0x64>)
 802d016:	ea04 2383 	and.w	r3, r4, r3, lsl #10
 802d01a:	6894      	ldr	r4, [r2, #8]
  uint32_t nb_pages = PAGE(FRAG_DECODER_DWL_REGION_START + FRAG_DECODER_DWL_REGION_SIZE - 1) - first_page + 1U;
 802d01c:	4a15      	ldr	r2, [pc, #84]	; (802d074 <FRAG_DECODER_IF_Erase+0x68>)
  uint32_t first_page = PAGE(FRAG_DECODER_DWL_REGION_START);
 802d01e:	f104 4478 	add.w	r4, r4, #4160749568	; 0xf8000000
 802d022:	fbb4 f1f3 	udiv	r1, r4, r3
 802d026:	fb03 4111 	mls	r1, r3, r1, r4
  uint32_t nb_pages = PAGE(FRAG_DECODER_DWL_REGION_START + FRAG_DECODER_DWL_REGION_SIZE - 1) - first_page + 1U;
 802d02a:	6894      	ldr	r4, [r2, #8]
 802d02c:	f104 4278 	add.w	r2, r4, #4160749568	; 0xf8000000
 802d030:	fbb2 f4f3 	udiv	r4, r2, r3
 802d034:	fb03 2414 	mls	r4, r3, r4, r2
 802d038:	0ae4      	lsrs	r4, r4, #11
 802d03a:	3401      	adds	r4, #1
  uint32_t first_page = PAGE(FRAG_DECODER_DWL_REGION_START);
 802d03c:	0acd      	lsrs	r5, r1, #11
  uint32_t nb_pages = PAGE(FRAG_DECODER_DWL_REGION_START + FRAG_DECODER_DWL_REGION_SIZE - 1) - first_page + 1U;
 802d03e:	eba4 24d1 	sub.w	r4, r4, r1, lsr #11

  if (HAL_FLASH_Unlock() == HAL_OK)
 802d042:	f001 f929 	bl	802e298 <HAL_FLASH_Unlock>
 802d046:	4602      	mov	r2, r0
 802d048:	b958      	cbnz	r0, 802d062 <FRAG_DECODER_IF_Erase+0x56>
  {
    status = FLASH_IF_EraseByPages(first_page, nb_pages, 0U);
 802d04a:	b2a1      	uxth	r1, r4
 802d04c:	4628      	mov	r0, r5
 802d04e:	f7ff f832 	bl	802c0b6 <FLASH_IF_EraseByPages>
 802d052:	4604      	mov	r4, r0
    /* Lock the Flash to disable the flash control register access (recommended
    to protect the FLASH memory against possible unwanted operation) *********/
    HAL_FLASH_Lock();
 802d054:	f001 f932 	bl	802e2bc <HAL_FLASH_Lock>
  {
    status = FLASH_LOCK_ERROR;
  }

#endif /* INTEROP_TEST_MODE */
  if (status != FLASH_OK)
 802d058:	1e20      	subs	r0, r4, #0
 802d05a:	bf18      	it	ne
 802d05c:	2001      	movne	r0, #1
 802d05e:	4240      	negs	r0, r0
  }
  return status;
  /* USER CODE BEGIN FRAG_DECODER_IF_Erase_2 */

  /* USER CODE END FRAG_DECODER_IF_Erase_2 */
}
 802d060:	bd38      	pop	{r3, r4, r5, pc}
    status = FLASH_ERROR;
 802d062:	f04f 30ff 	mov.w	r0, #4294967295
  return status;
 802d066:	e7fb      	b.n	802d060 <FRAG_DECODER_IF_Erase+0x54>
 802d068:	1fff75e0 	.word	0x1fff75e0
 802d06c:	03fffc00 	.word	0x03fffc00
 802d070:	0803b928 	.word	0x0803b928
 802d074:	0803b918 	.word	0x0803b918

0802d078 <FRAG_DECODER_IF_Write>:

int32_t FRAG_DECODER_IF_Write(uint32_t addr, uint8_t *data, uint32_t size)
{
 802d078:	b573      	push	{r0, r1, r4, r5, r6, lr}
 802d07a:	4604      	mov	r4, r0
 802d07c:	460d      	mov	r5, r1
 802d07e:	4616      	mov	r6, r2

#if (INTEROP_TEST_MODE == 1)  /*write fragment in RAM - Caching mode*/
  UTIL_MEM_cpy_8(&UnfragmentedData[addr], data, size);
#else /* INTEROP_TEST_MODE == 0 */

  if (HAL_FLASH_Unlock() == HAL_OK)
 802d080:	f001 f90a 	bl	802e298 <HAL_FLASH_Unlock>
 802d084:	b9b8      	cbnz	r0, 802d0b6 <FRAG_DECODER_IF_Write+0x3e>
  {
    status = FLASH_IF_Write(FRAG_DECODER_DWL_REGION_START + addr, data, size, FRAG_DECODER_IF_RAM_buffer);
 802d086:	480d      	ldr	r0, [pc, #52]	; (802d0bc <FRAG_DECODER_IF_Write+0x44>)
 802d088:	4b0d      	ldr	r3, [pc, #52]	; (802d0c0 <FRAG_DECODER_IF_Write+0x48>)
 802d08a:	6880      	ldr	r0, [r0, #8]
 802d08c:	4632      	mov	r2, r6
 802d08e:	4420      	add	r0, r4
 802d090:	4629      	mov	r1, r5
 802d092:	f7ff f827 	bl	802c0e4 <FLASH_IF_Write>
 802d096:	4604      	mov	r4, r0
    HAL_FLASH_Lock();
 802d098:	f001 f910 	bl	802e2bc <HAL_FLASH_Lock>
  else
  {
    status = FLASH_LOCK_ERROR;
  }

  if (status != FLASH_OK)
 802d09c:	b144      	cbz	r4, 802d0b0 <FRAG_DECODER_IF_Write+0x38>
  {
    APP_LOG(TS_OFF, VLEVEL_M, "\r\n....... !! FLASH_IF_WRITE_ERROR: %d !! .......\r\n", status);
 802d09e:	2200      	movs	r2, #0
 802d0a0:	9400      	str	r4, [sp, #0]
 802d0a2:	4b08      	ldr	r3, [pc, #32]	; (802d0c4 <FRAG_DECODER_IF_Write+0x4c>)
 802d0a4:	4611      	mov	r1, r2
 802d0a6:	2002      	movs	r0, #2
 802d0a8:	f00d fe26 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
  }
#endif /* INTEROP_TEST_MODE */
  if (status != FLASH_OK)
  {
    status = FLASH_ERROR;
 802d0ac:	f04f 34ff 	mov.w	r4, #4294967295
  }
  return status;
  /* USER CODE BEGIN FRAG_DECODER_IF_Write_2 */

  /* USER CODE END FRAG_DECODER_IF_Write_2 */
}
 802d0b0:	4620      	mov	r0, r4
 802d0b2:	b002      	add	sp, #8
 802d0b4:	bd70      	pop	{r4, r5, r6, pc}
    status = FLASH_LOCK_ERROR;
 802d0b6:	f06f 0403 	mvn.w	r4, #3
 802d0ba:	e7f0      	b.n	802d09e <FRAG_DECODER_IF_Write+0x26>
 802d0bc:	0803b928 	.word	0x0803b928
 802d0c0:	2000373c 	.word	0x2000373c
 802d0c4:	0803c07a 	.word	0x0803c07a

0802d0c8 <FRAG_DECODER_IF_OnProgress>:

  /* USER CODE END FRAG_DECODER_IF_Read_2 */
}

void FRAG_DECODER_IF_OnProgress(uint16_t fragCounter, uint16_t fragNb, uint8_t fragSize, uint16_t fragNbLost)
{
 802d0c8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 802d0ca:	4614      	mov	r4, r2
  /* USER CODE BEGIN FRAG_DECODER_IF_OnProgress_1 */

  /* USER CODE END FRAG_DECODER_IF_OnProgress_1 */
  APP_LOG(TS_OFF, VLEVEL_M, "\r\n....... FRAG_DECODER in Progress .......\r\n");
 802d0cc:	2200      	movs	r2, #0
{
 802d0ce:	4606      	mov	r6, r0
 802d0d0:	460d      	mov	r5, r1
 802d0d2:	461f      	mov	r7, r3
  APP_LOG(TS_OFF, VLEVEL_M, "\r\n....... FRAG_DECODER in Progress .......\r\n");
 802d0d4:	4611      	mov	r1, r2
 802d0d6:	4b0f      	ldr	r3, [pc, #60]	; (802d114 <FRAG_DECODER_IF_OnProgress+0x4c>)
 802d0d8:	2002      	movs	r0, #2
 802d0da:	f00d fe0d 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
  APP_LOG(TS_OFF, VLEVEL_M, "RECEIVED    : %5d / %5d Fragments\r\n", fragCounter, fragNb);
 802d0de:	2200      	movs	r2, #0
 802d0e0:	e9cd 6500 	strd	r6, r5, [sp]
 802d0e4:	4611      	mov	r1, r2
 802d0e6:	4b0c      	ldr	r3, [pc, #48]	; (802d118 <FRAG_DECODER_IF_OnProgress+0x50>)
 802d0e8:	2002      	movs	r0, #2
 802d0ea:	f00d fe05 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
  APP_LOG(TS_OFF, VLEVEL_M, "              %5d / %5d Bytes\r\n", fragCounter * fragSize, fragNb * fragSize);
 802d0ee:	4365      	muls	r5, r4
 802d0f0:	2200      	movs	r2, #0
 802d0f2:	4374      	muls	r4, r6
 802d0f4:	4611      	mov	r1, r2
 802d0f6:	4b09      	ldr	r3, [pc, #36]	; (802d11c <FRAG_DECODER_IF_OnProgress+0x54>)
 802d0f8:	9501      	str	r5, [sp, #4]
 802d0fa:	9400      	str	r4, [sp, #0]
 802d0fc:	2002      	movs	r0, #2
 802d0fe:	f00d fdfb 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
  APP_LOG(TS_OFF, VLEVEL_M, "LOST        :       %7d Fragments\r\n\r\n", fragNbLost);
 802d102:	2200      	movs	r2, #0
 802d104:	4b06      	ldr	r3, [pc, #24]	; (802d120 <FRAG_DECODER_IF_OnProgress+0x58>)
 802d106:	9700      	str	r7, [sp, #0]
 802d108:	4611      	mov	r1, r2
 802d10a:	2002      	movs	r0, #2
 802d10c:	f00d fdf4 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
  BSP_LED_Toggle(LED_BLUE);
#endif /* INTEROP_TEST_MODE == 1 */
  /* USER CODE BEGIN FRAG_DECODER_IF_OnProgress_2 */

  /* USER CODE END FRAG_DECODER_IF_OnProgress_2 */
}
 802d110:	b003      	add	sp, #12
 802d112:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802d114:	0803c0ad 	.word	0x0803c0ad
 802d118:	0803c0da 	.word	0x0803c0da
 802d11c:	0803c0fe 	.word	0x0803c0fe
 802d120:	0803c11e 	.word	0x0803c11e

0802d124 <FRAG_DECODER_IF_Read>:
{
 802d124:	b508      	push	{r3, lr}
 802d126:	460b      	mov	r3, r1
  UTIL_MEM_cpy_8(data, (void *)(FRAG_DECODER_DWL_REGION_START + addr), size);
 802d128:	4904      	ldr	r1, [pc, #16]	; (802d13c <FRAG_DECODER_IF_Read+0x18>)
 802d12a:	6889      	ldr	r1, [r1, #8]
 802d12c:	b292      	uxth	r2, r2
 802d12e:	4401      	add	r1, r0
 802d130:	4618      	mov	r0, r3
 802d132:	f00d fee9 	bl	803af08 <UTIL_MEM_cpy_8>
}
 802d136:	2000      	movs	r0, #0
 802d138:	bd08      	pop	{r3, pc}
 802d13a:	bf00      	nop
 802d13c:	0803b928 	.word	0x0803b928

0802d140 <FRAG_DECODER_IF_OnDone>:

void FRAG_DECODER_IF_OnDone(int32_t status, uint32_t size)
{
 802d140:	b513      	push	{r0, r1, r4, lr}
  /* USER CODE BEGIN FRAG_DECODER_IF_OnDone_1 */

  /* USER CODE END FRAG_DECODER_IF_OnDone_1 */
  APP_LOG(TS_OFF, VLEVEL_M, "\r\n....... FRAG_DECODER Finished .......\r\n");
 802d142:	2200      	movs	r2, #0
{
 802d144:	4604      	mov	r4, r0
  APP_LOG(TS_OFF, VLEVEL_M, "\r\n....... FRAG_DECODER Finished .......\r\n");
 802d146:	4611      	mov	r1, r2
 802d148:	4b08      	ldr	r3, [pc, #32]	; (802d16c <FRAG_DECODER_IF_OnDone+0x2c>)
 802d14a:	2002      	movs	r0, #2
 802d14c:	f00d fdd4 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
  APP_LOG(TS_OFF, VLEVEL_M, "STATUS      : %d\r\n", status);
 802d150:	2200      	movs	r2, #0
 802d152:	4b07      	ldr	r3, [pc, #28]	; (802d170 <FRAG_DECODER_IF_OnDone+0x30>)
 802d154:	9400      	str	r4, [sp, #0]
 802d156:	4611      	mov	r1, r2
 802d158:	2002      	movs	r0, #2
 802d15a:	f00d fdcd 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>

#if (INTEROP_TEST_MODE == 0)
  /* Send a frame to signal the AS that the end-device has already rebuilt the whole data block */
  SendTXStopFrag();
 802d15e:	f7ff ff11 	bl	802cf84 <SendTXStopFrag>
  BSP_LED_Off(LED_BLUE);
#endif /* INTEROP_TEST_MODE == 1 */
  /* USER CODE BEGIN FRAG_DECODER_IF_OnDone_2 */

  /* USER CODE END FRAG_DECODER_IF_OnDone_2 */
}
 802d162:	b002      	add	sp, #8
 802d164:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  FwUpdateAgent_Run();
 802d168:	f7ff bcec 	b.w	802cb44 <FwUpdateAgent_Run>
 802d16c:	0803c144 	.word	0x0803c144
 802d170:	0803c16e 	.word	0x0803c16e

0802d174 <RBI_Init>:
   *       or at https://github.com/STMicroelectronics/STM32CubeWL/tree/main/Drivers/BSP/STM32WLxx_Nucleo/
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration */
  return BSP_RADIO_Init();
 802d174:	f000 b8e6 	b.w	802d344 <BSP_RADIO_Init>

0802d178 <RBI_ConfigRFSwitch>:
   *       or at https://github.com/STMicroelectronics/STM32CubeWL/tree/main/Drivers/BSP/STM32WLxx_Nucleo/
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration */
  return BSP_RADIO_ConfigRFSwitch((BSP_RADIO_Switch_TypeDef) Config);
 802d178:	f000 b924 	b.w	802d3c4 <BSP_RADIO_ConfigRFSwitch>

0802d17c <RBI_GetTxConfig>:
   *       or at https://github.com/STMicroelectronics/STM32CubeWL/tree/main/Drivers/BSP/STM32WLxx_Nucleo/
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration */
  return BSP_RADIO_GetTxConfig();
 802d17c:	f000 b956 	b.w	802d42c <BSP_RADIO_GetTxConfig>

0802d180 <RBI_IsTCXO>:
   *       or at https://github.com/STMicroelectronics/STM32CubeWL/tree/main/Drivers/BSP/STM32WLxx_Nucleo/
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration */
  return BSP_RADIO_IsTCXO();
 802d180:	f000 b956 	b.w	802d430 <BSP_RADIO_IsTCXO>

0802d184 <RBI_IsDCDC>:
   *       or at https://github.com/STMicroelectronics/STM32CubeWL/tree/main/Drivers/BSP/STM32WLxx_Nucleo/
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration */
  return BSP_RADIO_IsDCDC();
 802d184:	f000 b956 	b.w	802d434 <BSP_RADIO_IsDCDC>

0802d188 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 802d188:	480d      	ldr	r0, [pc, #52]	; (802d1c0 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 802d18a:	4685      	mov	sp, r0

/* Call the clock system initialization function.*/
  bl  SystemInit
 802d18c:	f000 f954 	bl	802d438 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 802d190:	480c      	ldr	r0, [pc, #48]	; (802d1c4 <LoopForever+0x6>)
  ldr r1, =_edata
 802d192:	490d      	ldr	r1, [pc, #52]	; (802d1c8 <LoopForever+0xa>)
  ldr r2, =_sidata
 802d194:	4a0d      	ldr	r2, [pc, #52]	; (802d1cc <LoopForever+0xe>)
  movs r3, #0
 802d196:	2300      	movs	r3, #0
  b LoopCopyDataInit
 802d198:	e002      	b.n	802d1a0 <LoopCopyDataInit>

0802d19a <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 802d19a:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 802d19c:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 802d19e:	3304      	adds	r3, #4

0802d1a0 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 802d1a0:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 802d1a2:	428c      	cmp	r4, r1
  bcc CopyDataInit
 802d1a4:	d3f9      	bcc.n	802d19a <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 802d1a6:	4a0a      	ldr	r2, [pc, #40]	; (802d1d0 <LoopForever+0x12>)
  ldr r4, =_ebss
 802d1a8:	4c0a      	ldr	r4, [pc, #40]	; (802d1d4 <LoopForever+0x16>)
  movs r3, #0
 802d1aa:	2300      	movs	r3, #0
  b LoopFillZerobss
 802d1ac:	e001      	b.n	802d1b2 <LoopFillZerobss>

0802d1ae <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 802d1ae:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 802d1b0:	3204      	adds	r2, #4

0802d1b2 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 802d1b2:	42a2      	cmp	r2, r4
  bcc FillZerobss
 802d1b4:	d3fb      	bcc.n	802d1ae <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 802d1b6:	f00e fac1 	bl	803b73c <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 802d1ba:	f7ff f86f 	bl	802c29c <main>

0802d1be <LoopForever>:

LoopForever:
    b LoopForever
 802d1be:	e7fe      	b.n	802d1be <LoopForever>
  ldr   r0, =_estack
 802d1c0:	20008000 	.word	0x20008000
  ldr r0, =_sdata
 802d1c4:	20003400 	.word	0x20003400
  ldr r1, =_edata
 802d1c8:	200035ac 	.word	0x200035ac
  ldr r2, =_sidata
 802d1cc:	0803c620 	.word	0x0803c620
  ldr r2, =_sbss
 802d1d0:	200035ac 	.word	0x200035ac
  ldr r4, =_ebss
 802d1d4:	200063ac 	.word	0x200063ac

0802d1d8 <ADC_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 802d1d8:	e7fe      	b.n	802d1d8 <ADC_IRQHandler>

0802d1da <LL_AHB2_GRP1_EnableClock>:
  SET_BIT(RCC->AHB2ENR, Periphs);
 802d1da:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
{
 802d1de:	b082      	sub	sp, #8
  SET_BIT(RCC->AHB2ENR, Periphs);
 802d1e0:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 802d1e2:	4302      	orrs	r2, r0
 802d1e4:	64da      	str	r2, [r3, #76]	; 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 802d1e6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 802d1e8:	4018      	ands	r0, r3
 802d1ea:	9001      	str	r0, [sp, #4]
  (void)tmpreg;
 802d1ec:	9b01      	ldr	r3, [sp, #4]
}
 802d1ee:	b002      	add	sp, #8
 802d1f0:	4770      	bx	lr
	...

0802d1f4 <BSP_LED_Init>:
  *            @arg LED2
  *            @arg LED3
  * @retval BSP status
  */
int32_t BSP_LED_Init(Led_TypeDef Led)
{
 802d1f4:	b570      	push	{r4, r5, r6, lr}
 802d1f6:	b086      	sub	sp, #24
 802d1f8:	4604      	mov	r4, r0
  GPIO_InitTypeDef  gpio_init_structure = {0};
 802d1fa:	2214      	movs	r2, #20
 802d1fc:	2100      	movs	r1, #0
 802d1fe:	a801      	add	r0, sp, #4
 802d200:	f00e fac0 	bl	803b784 <memset>
  
  /* Enable the GPIO_LED Clock */
  LEDx_GPIO_CLK_ENABLE(Led);
 802d204:	2002      	movs	r0, #2
 802d206:	f7ff ffe8 	bl	802d1da <LL_AHB2_GRP1_EnableClock>

  /* Configure the GPIO_LED pin */
  gpio_init_structure.Pin = LED_PIN[Led];
 802d20a:	4b0c      	ldr	r3, [pc, #48]	; (802d23c <BSP_LED_Init+0x48>)
 802d20c:	f833 6014 	ldrh.w	r6, [r3, r4, lsl #1]
 802d210:	9601      	str	r6, [sp, #4]
  gpio_init_structure.Mode = GPIO_MODE_OUTPUT_PP;
  gpio_init_structure.Pull = GPIO_NOPULL;
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;
  
  HAL_GPIO_Init(LED_PORT[Led], &gpio_init_structure);
 802d212:	eb03 0384 	add.w	r3, r3, r4, lsl #2
  gpio_init_structure.Pull = GPIO_NOPULL;
 802d216:	2500      	movs	r5, #0
  HAL_GPIO_Init(LED_PORT[Led], &gpio_init_structure);
 802d218:	689c      	ldr	r4, [r3, #8]
  gpio_init_structure.Pull = GPIO_NOPULL;
 802d21a:	2201      	movs	r2, #1
 802d21c:	e9cd 2502 	strd	r2, r5, [sp, #8]
  HAL_GPIO_Init(LED_PORT[Led], &gpio_init_structure);
 802d220:	a901      	add	r1, sp, #4
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;
 802d222:	2202      	movs	r2, #2
  HAL_GPIO_Init(LED_PORT[Led], &gpio_init_structure);
 802d224:	4620      	mov	r0, r4
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;
 802d226:	9204      	str	r2, [sp, #16]
  HAL_GPIO_Init(LED_PORT[Led], &gpio_init_structure);
 802d228:	f001 f948 	bl	802e4bc <HAL_GPIO_Init>
  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_RESET);
 802d22c:	4620      	mov	r0, r4
 802d22e:	462a      	mov	r2, r5
 802d230:	4631      	mov	r1, r6
 802d232:	f001 fa63 	bl	802e6fc <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
}
 802d236:	4628      	mov	r0, r5
 802d238:	b006      	add	sp, #24
 802d23a:	bd70      	pop	{r4, r5, r6, pc}
 802d23c:	0803b974 	.word	0x0803b974

0802d240 <BSP_LED_On>:
  *            @arg LED3
  * @retval BSP status
  */
int32_t BSP_LED_On(Led_TypeDef Led)
{
  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_SET); 
 802d240:	4b05      	ldr	r3, [pc, #20]	; (802d258 <BSP_LED_On+0x18>)
{
 802d242:	b510      	push	{r4, lr}
  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_SET); 
 802d244:	eb03 0480 	add.w	r4, r3, r0, lsl #2
 802d248:	f833 1010 	ldrh.w	r1, [r3, r0, lsl #1]
 802d24c:	68a0      	ldr	r0, [r4, #8]
 802d24e:	2201      	movs	r2, #1
 802d250:	f001 fa54 	bl	802e6fc <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
}
 802d254:	2000      	movs	r0, #0
 802d256:	bd10      	pop	{r4, pc}
 802d258:	0803b974 	.word	0x0803b974

0802d25c <BSP_LED_Off>:
  *            @arg LED3
  * @retval BSP status
  */
int32_t BSP_LED_Off(Led_TypeDef Led)
{
  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_RESET); 
 802d25c:	4b05      	ldr	r3, [pc, #20]	; (802d274 <BSP_LED_Off+0x18>)
{
 802d25e:	b510      	push	{r4, lr}
  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_RESET); 
 802d260:	eb03 0480 	add.w	r4, r3, r0, lsl #2
 802d264:	f833 1010 	ldrh.w	r1, [r3, r0, lsl #1]
 802d268:	68a0      	ldr	r0, [r4, #8]
 802d26a:	2200      	movs	r2, #0
 802d26c:	f001 fa46 	bl	802e6fc <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
}
 802d270:	2000      	movs	r0, #0
 802d272:	bd10      	pop	{r4, pc}
 802d274:	0803b974 	.word	0x0803b974

0802d278 <BSP_LED_Toggle>:
  *            @arg LED2
  *            @arg LED3
  * @retval BSP status
  */
int32_t BSP_LED_Toggle(Led_TypeDef Led)
{
 802d278:	b508      	push	{r3, lr}
  HAL_GPIO_TogglePin(LED_PORT[Led], LED_PIN[Led]);
 802d27a:	4b05      	ldr	r3, [pc, #20]	; (802d290 <BSP_LED_Toggle+0x18>)
 802d27c:	eb03 0280 	add.w	r2, r3, r0, lsl #2
 802d280:	f833 1010 	ldrh.w	r1, [r3, r0, lsl #1]
 802d284:	6890      	ldr	r0, [r2, #8]
 802d286:	f001 fa3e 	bl	802e706 <HAL_GPIO_TogglePin>

  return BSP_ERROR_NONE;
}
 802d28a:	2000      	movs	r0, #0
 802d28c:	bd08      	pop	{r3, pc}
 802d28e:	bf00      	nop
 802d290:	0803b974 	.word	0x0803b974

0802d294 <BSP_PB_Init>:
  *     @arg BUTTON_MODE_EXTI: Button will be connected to EXTI line with interrupt
  *                            generation capability  
  * @retval BSP status
  */
int32_t BSP_PB_Init(Button_TypeDef Button, ButtonMode_TypeDef ButtonMode)
{
 802d294:	b5f0      	push	{r4, r5, r6, r7, lr}
 802d296:	b087      	sub	sp, #28
 802d298:	4604      	mov	r4, r0
 802d29a:	460f      	mov	r7, r1
  GPIO_InitTypeDef gpio_init_structure = {0};
 802d29c:	2214      	movs	r2, #20
 802d29e:	2100      	movs	r1, #0
 802d2a0:	a801      	add	r0, sp, #4
 802d2a2:	f00e fa6f 	bl	803b784 <memset>
  static BSP_EXTI_LineCallback button_callback[BUTTONn] = {BUTTON_SW1_EXTI_Callback, BUTTON_SW2_EXTI_Callback, BUTTON_SW3_EXTI_Callback};
  static uint32_t button_interrupt_priority[BUTTONn] = {BSP_BUTTON_SWx_IT_PRIORITY, BSP_BUTTON_SWx_IT_PRIORITY, BSP_BUTTON_SWx_IT_PRIORITY};
  static const uint32_t button_exti_line[BUTTONn] = {BUTTON_SW1_EXTI_LINE, BUTTON_SW2_EXTI_LINE, BUTTON_SW3_EXTI_LINE};

  /* Enable the BUTTON Clock */
  BUTTONx_GPIO_CLK_ENABLE(Button);
 802d2a6:	2c01      	cmp	r4, #1
 802d2a8:	d816      	bhi.n	802d2d8 <BSP_PB_Init+0x44>
 802d2aa:	2001      	movs	r0, #1
 802d2ac:	f7ff ff95 	bl	802d1da <LL_AHB2_GRP1_EnableClock>
  
  gpio_init_structure.Pin = BUTTON_PIN[Button];
 802d2b0:	4d1a      	ldr	r5, [pc, #104]	; (802d31c <BSP_PB_Init+0x88>)
 802d2b2:	eb05 0344 	add.w	r3, r5, r4, lsl #1
 802d2b6:	eb05 0684 	add.w	r6, r5, r4, lsl #2
 802d2ba:	8a9b      	ldrh	r3, [r3, #20]
 802d2bc:	9301      	str	r3, [sp, #4]
  gpio_init_structure.Pull = GPIO_PULLUP;
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;
 802d2be:	2201      	movs	r2, #1
 802d2c0:	2302      	movs	r3, #2
 802d2c2:	e9cd 2303 	strd	r2, r3, [sp, #12]

  if(ButtonMode == BUTTON_MODE_GPIO)
 802d2c6:	69f0      	ldr	r0, [r6, #28]
 802d2c8:	b957      	cbnz	r7, 802d2e0 <BSP_PB_Init+0x4c>
  {
    /* Configure Button pin as input */
    gpio_init_structure.Mode = GPIO_MODE_INPUT;
    HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
 802d2ca:	a901      	add	r1, sp, #4
    gpio_init_structure.Mode = GPIO_MODE_INPUT;
 802d2cc:	9702      	str	r7, [sp, #8]
    HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
 802d2ce:	f001 f8f5 	bl	802e4bc <HAL_GPIO_Init>
    HAL_NVIC_SetPriority((BUTTON_IRQn[Button]), button_interrupt_priority[Button], 0x00);
    HAL_NVIC_EnableIRQ((BUTTON_IRQn[Button]));
  }

  return BSP_ERROR_NONE;
}
 802d2d2:	2000      	movs	r0, #0
 802d2d4:	b007      	add	sp, #28
 802d2d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  BUTTONx_GPIO_CLK_ENABLE(Button);
 802d2d8:	2c02      	cmp	r4, #2
 802d2da:	d1e9      	bne.n	802d2b0 <BSP_PB_Init+0x1c>
 802d2dc:	2004      	movs	r0, #4
 802d2de:	e7e5      	b.n	802d2ac <BSP_PB_Init+0x18>
    (void)HAL_EXTI_GetHandle(&hpb_exti[Button], button_exti_line[Button]);
 802d2e0:	4f0f      	ldr	r7, [pc, #60]	; (802d320 <BSP_PB_Init+0x8c>)
    gpio_init_structure.Mode = GPIO_MODE_IT_FALLING;
 802d2e2:	f44f 1304 	mov.w	r3, #2162688	; 0x210000
    (void)HAL_EXTI_GetHandle(&hpb_exti[Button], button_exti_line[Button]);
 802d2e6:	eb07 07c4 	add.w	r7, r7, r4, lsl #3
    HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
 802d2ea:	a901      	add	r1, sp, #4
    gpio_init_structure.Mode = GPIO_MODE_IT_FALLING;
 802d2ec:	9302      	str	r3, [sp, #8]
    HAL_NVIC_SetPriority((BUTTON_IRQn[Button]), button_interrupt_priority[Button], 0x00);
 802d2ee:	442c      	add	r4, r5
    HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
 802d2f0:	f001 f8e4 	bl	802e4bc <HAL_GPIO_Init>
    (void)HAL_EXTI_GetHandle(&hpb_exti[Button], button_exti_line[Button]);
 802d2f4:	6ab1      	ldr	r1, [r6, #40]	; 0x28
 802d2f6:	4638      	mov	r0, r7
 802d2f8:	f000 ffaf 	bl	802e25a <HAL_EXTI_GetHandle>
    (void)HAL_EXTI_RegisterCallback(&hpb_exti[Button],  HAL_EXTI_COMMON_CB_ID, button_callback[Button]);
 802d2fc:	6b72      	ldr	r2, [r6, #52]	; 0x34
 802d2fe:	2100      	movs	r1, #0
 802d300:	4638      	mov	r0, r7
 802d302:	f000 ffa3 	bl	802e24c <HAL_EXTI_RegisterCallback>
    HAL_NVIC_SetPriority((BUTTON_IRQn[Button]), button_interrupt_priority[Button], 0x00);
 802d306:	f994 4040 	ldrsb.w	r4, [r4, #64]	; 0x40
 802d30a:	6c71      	ldr	r1, [r6, #68]	; 0x44
 802d30c:	4620      	mov	r0, r4
 802d30e:	2200      	movs	r2, #0
 802d310:	f000 fd26 	bl	802dd60 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ((BUTTON_IRQn[Button]));
 802d314:	4620      	mov	r0, r4
 802d316:	f000 fd55 	bl	802ddc4 <HAL_NVIC_EnableIRQ>
 802d31a:	e7da      	b.n	802d2d2 <BSP_PB_Init+0x3e>
 802d31c:	0803b974 	.word	0x0803b974
 802d320:	200062f0 	.word	0x200062f0

0802d324 <BSP_PB_Callback>:
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Button);

  /* This function should be implemented by the user application.
     It is called into this driver when an event on Button is triggered. */
}
 802d324:	4770      	bx	lr

0802d326 <BUTTON_SW3_EXTI_Callback>:
/**
  * @brief  Button SW3 EXTI line detection callback.
  * @retval None
  */
static void BUTTON_SW3_EXTI_Callback(void)
{
 802d326:	b508      	push	{r3, lr}
  BSP_PB_Callback(BUTTON_SW3);
 802d328:	2002      	movs	r0, #2
 802d32a:	f7ff fffb 	bl	802d324 <BSP_PB_Callback>
}
 802d32e:	bd08      	pop	{r3, pc}

0802d330 <BUTTON_SW2_EXTI_Callback>:
{
 802d330:	b508      	push	{r3, lr}
  BSP_PB_Callback(BUTTON_SW2);
 802d332:	2001      	movs	r0, #1
 802d334:	f7ff fff6 	bl	802d324 <BSP_PB_Callback>
}
 802d338:	bd08      	pop	{r3, pc}

0802d33a <BUTTON_SW1_EXTI_Callback>:
{
 802d33a:	b508      	push	{r3, lr}
  BSP_PB_Callback(BUTTON_SW1);
 802d33c:	2000      	movs	r0, #0
 802d33e:	f7ff fff1 	bl	802d324 <BSP_PB_Callback>
}
 802d342:	bd08      	pop	{r3, pc}

0802d344 <BSP_RADIO_Init>:
/**
  * @brief  Init Radio Switch 
  * @retval BSP status
  */
int32_t BSP_RADIO_Init(void)
{
 802d344:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802d348:	b086      	sub	sp, #24
  GPIO_InitTypeDef  gpio_init_structure = {0};
 802d34a:	2400      	movs	r4, #0
  SET_BIT(RCC->AHB2ENR, Periphs);
 802d34c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802d350:	9405      	str	r4, [sp, #20]
 802d352:	6cda      	ldr	r2, [r3, #76]	; 0x4c
  gpio_init_structure.Pin   = RF_SW_CTRL1_PIN;
  gpio_init_structure.Mode  = GPIO_MODE_OUTPUT_PP;
  gpio_init_structure.Pull  = GPIO_NOPULL;
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  
  HAL_GPIO_Init(RF_SW_CTRL1_GPIO_PORT, &gpio_init_structure);
 802d354:	4d1a      	ldr	r5, [pc, #104]	; (802d3c0 <BSP_RADIO_Init+0x7c>)
 802d356:	f042 0204 	orr.w	r2, r2, #4
 802d35a:	64da      	str	r2, [r3, #76]	; 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 802d35c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  gpio_init_structure.Pull  = GPIO_NOPULL;
 802d35e:	9403      	str	r4, [sp, #12]
 802d360:	f003 0304 	and.w	r3, r3, #4
 802d364:	9300      	str	r3, [sp, #0]
  (void)tmpreg;
 802d366:	9b00      	ldr	r3, [sp, #0]
  gpio_init_structure.Mode  = GPIO_MODE_OUTPUT_PP;
 802d368:	2710      	movs	r7, #16
 802d36a:	2301      	movs	r3, #1
 802d36c:	e9cd 7301 	strd	r7, r3, [sp, #4]
  HAL_GPIO_Init(RF_SW_CTRL1_GPIO_PORT, &gpio_init_structure);
 802d370:	a901      	add	r1, sp, #4
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 802d372:	2303      	movs	r3, #3
  HAL_GPIO_Init(RF_SW_CTRL1_GPIO_PORT, &gpio_init_structure);
 802d374:	4628      	mov	r0, r5
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 802d376:	9304      	str	r3, [sp, #16]
  
  gpio_init_structure.Pin = RF_SW_CTRL2_PIN;
 802d378:	f04f 0820 	mov.w	r8, #32
  HAL_GPIO_Init(RF_SW_CTRL1_GPIO_PORT, &gpio_init_structure);
 802d37c:	f001 f89e 	bl	802e4bc <HAL_GPIO_Init>
  HAL_GPIO_Init(RF_SW_CTRL2_GPIO_PORT, &gpio_init_structure);
 802d380:	a901      	add	r1, sp, #4
 802d382:	4628      	mov	r0, r5
  
  gpio_init_structure.Pin = RF_SW_CTRL3_PIN;
 802d384:	2608      	movs	r6, #8
  gpio_init_structure.Pin = RF_SW_CTRL2_PIN;
 802d386:	f8cd 8004 	str.w	r8, [sp, #4]
  HAL_GPIO_Init(RF_SW_CTRL2_GPIO_PORT, &gpio_init_structure);
 802d38a:	f001 f897 	bl	802e4bc <HAL_GPIO_Init>
  HAL_GPIO_Init(RF_SW_CTRL3_GPIO_PORT, &gpio_init_structure);
 802d38e:	a901      	add	r1, sp, #4
 802d390:	4628      	mov	r0, r5
  gpio_init_structure.Pin = RF_SW_CTRL3_PIN;
 802d392:	9601      	str	r6, [sp, #4]
  HAL_GPIO_Init(RF_SW_CTRL3_GPIO_PORT, &gpio_init_structure);
 802d394:	f001 f892 	bl	802e4bc <HAL_GPIO_Init>

  HAL_GPIO_WritePin(RF_SW_CTRL2_GPIO_PORT, RF_SW_CTRL2_PIN, GPIO_PIN_RESET); 
 802d398:	4622      	mov	r2, r4
 802d39a:	4641      	mov	r1, r8
 802d39c:	4628      	mov	r0, r5
 802d39e:	f001 f9ad 	bl	802e6fc <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_RESET); 
 802d3a2:	4622      	mov	r2, r4
 802d3a4:	4639      	mov	r1, r7
 802d3a6:	4628      	mov	r0, r5
 802d3a8:	f001 f9a8 	bl	802e6fc <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_RESET); 
 802d3ac:	4628      	mov	r0, r5
 802d3ae:	4622      	mov	r2, r4
 802d3b0:	4631      	mov	r1, r6
 802d3b2:	f001 f9a3 	bl	802e6fc <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
}
 802d3b6:	4620      	mov	r0, r4
 802d3b8:	b006      	add	sp, #24
 802d3ba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802d3be:	bf00      	nop
 802d3c0:	48000800 	.word	0x48000800

0802d3c4 <BSP_RADIO_ConfigRFSwitch>:
  *           @arg RADIO_SWITCH_RFO_LP
  *           @arg RADIO_SWITCH_RFO_HP
  * @retval BSP status
  */
int32_t BSP_RADIO_ConfigRFSwitch(BSP_RADIO_Switch_TypeDef Config)
{
 802d3c4:	b508      	push	{r3, lr}
 802d3c6:	2803      	cmp	r0, #3
 802d3c8:	d812      	bhi.n	802d3f0 <BSP_RADIO_ConfigRFSwitch+0x2c>
 802d3ca:	e8df f000 	tbb	[pc, r0]
 802d3ce:	1302      	.short	0x1302
 802d3d0:	261a      	.short	0x261a
  switch (Config)
  {
    case RADIO_SWITCH_OFF:
    {
      /* Turn off switch */
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_RESET);
 802d3d2:	2200      	movs	r2, #0
 802d3d4:	4814      	ldr	r0, [pc, #80]	; (802d428 <BSP_RADIO_ConfigRFSwitch+0x64>)
 802d3d6:	2108      	movs	r1, #8
 802d3d8:	f001 f990 	bl	802e6fc <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_RESET);
 802d3dc:	2200      	movs	r2, #0
    }
    case RADIO_SWITCH_RX:
    {
      /*Turns On in Rx Mode the RF Switch */
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_SET);
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_SET); 
 802d3de:	4812      	ldr	r0, [pc, #72]	; (802d428 <BSP_RADIO_ConfigRFSwitch+0x64>)
 802d3e0:	2110      	movs	r1, #16
 802d3e2:	f001 f98b 	bl	802e6fc <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL2_GPIO_PORT, RF_SW_CTRL2_PIN, GPIO_PIN_RESET); 
 802d3e6:	2200      	movs	r2, #0
    case RADIO_SWITCH_RFO_HP:
    {
      /*Turns On in Tx High Power the RF Switch */
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_SET);
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_RESET); 
      HAL_GPIO_WritePin(RF_SW_CTRL2_GPIO_PORT, RF_SW_CTRL2_PIN, GPIO_PIN_SET); 
 802d3e8:	480f      	ldr	r0, [pc, #60]	; (802d428 <BSP_RADIO_ConfigRFSwitch+0x64>)
 802d3ea:	2120      	movs	r1, #32
 802d3ec:	f001 f986 	bl	802e6fc <HAL_GPIO_WritePin>
    default:
      break;    
  }  

  return BSP_ERROR_NONE;
}
 802d3f0:	2000      	movs	r0, #0
 802d3f2:	bd08      	pop	{r3, pc}
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_SET);
 802d3f4:	2201      	movs	r2, #1
 802d3f6:	480c      	ldr	r0, [pc, #48]	; (802d428 <BSP_RADIO_ConfigRFSwitch+0x64>)
 802d3f8:	2108      	movs	r1, #8
 802d3fa:	f001 f97f 	bl	802e6fc <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_SET); 
 802d3fe:	2201      	movs	r2, #1
 802d400:	e7ed      	b.n	802d3de <BSP_RADIO_ConfigRFSwitch+0x1a>
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_SET);
 802d402:	2201      	movs	r2, #1
 802d404:	4808      	ldr	r0, [pc, #32]	; (802d428 <BSP_RADIO_ConfigRFSwitch+0x64>)
 802d406:	2108      	movs	r1, #8
 802d408:	f001 f978 	bl	802e6fc <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_SET); 
 802d40c:	2201      	movs	r2, #1
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_RESET); 
 802d40e:	4806      	ldr	r0, [pc, #24]	; (802d428 <BSP_RADIO_ConfigRFSwitch+0x64>)
 802d410:	2110      	movs	r1, #16
 802d412:	f001 f973 	bl	802e6fc <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL2_GPIO_PORT, RF_SW_CTRL2_PIN, GPIO_PIN_SET); 
 802d416:	2201      	movs	r2, #1
 802d418:	e7e6      	b.n	802d3e8 <BSP_RADIO_ConfigRFSwitch+0x24>
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_SET);
 802d41a:	2201      	movs	r2, #1
 802d41c:	4802      	ldr	r0, [pc, #8]	; (802d428 <BSP_RADIO_ConfigRFSwitch+0x64>)
 802d41e:	2108      	movs	r1, #8
 802d420:	f001 f96c 	bl	802e6fc <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_RESET); 
 802d424:	2200      	movs	r2, #0
 802d426:	e7f2      	b.n	802d40e <BSP_RADIO_ConfigRFSwitch+0x4a>
 802d428:	48000800 	.word	0x48000800

0802d42c <BSP_RADIO_GetTxConfig>:
  *  RADIO_CONF_RFO_HP
  */
int32_t BSP_RADIO_GetTxConfig(void)
{
  return RADIO_CONF_RFO_LP_HP;
}
 802d42c:	2000      	movs	r0, #0
 802d42e:	4770      	bx	lr

0802d430 <BSP_RADIO_IsTCXO>:
  *  RADIO_CONF_TCXO_SUPPORTED
  */
int32_t BSP_RADIO_IsTCXO(void)
{
  return RADIO_CONF_TCXO_SUPPORTED;
}
 802d430:	2001      	movs	r0, #1
 802d432:	4770      	bx	lr

0802d434 <BSP_RADIO_IsDCDC>:
 802d434:	2001      	movs	r0, #1
 802d436:	4770      	bx	lr

0802d438 <SystemInit>:
  * @retval None
  */
void SystemInit(void)
{
  /* Configure the Vector Table location  ------------------*/
  SCB->VTOR = INTVECT_START;
 802d438:	4b0c      	ldr	r3, [pc, #48]	; (802d46c <SystemInit+0x34>)
 802d43a:	4a0d      	ldr	r2, [pc, #52]	; (802d470 <SystemInit+0x38>)
 802d43c:	609a      	str	r2, [r3, #8]
  SCB->CPACR |= ((3UL << (10UL*2UL))|(3UL << (11UL*2UL)));  /* set CP10 and CP11 Full Access */
#endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 802d43e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802d442:	681a      	ldr	r2, [r3, #0]
 802d444:	f042 0201 	orr.w	r2, r2, #1
 802d448:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00070000U;
 802d44a:	f44f 22e0 	mov.w	r2, #458752	; 0x70000
 802d44e:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON , HSION, and PLLON bits */
  /* RCC->CR &= 0xEAF6FFFFU; */
  RCC->CR &= 0x2321EFF;
 802d450:	6819      	ldr	r1, [r3, #0]
 802d452:	4a08      	ldr	r2, [pc, #32]	; (802d474 <SystemInit+0x3c>)
 802d454:	400a      	ands	r2, r1
 802d456:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x22040100;
 802d458:	4a07      	ldr	r2, [pc, #28]	; (802d478 <SystemInit+0x40>)
 802d45a:	60da      	str	r2, [r3, #12]

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFDFFFFFFU;
 802d45c:	681a      	ldr	r2, [r3, #0]
 802d45e:	f022 7200 	bic.w	r2, r2, #33554432	; 0x2000000
 802d462:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000U;
 802d464:	2200      	movs	r2, #0
 802d466:	619a      	str	r2, [r3, #24]
}
 802d468:	4770      	bx	lr
 802d46a:	bf00      	nop
 802d46c:	e000ed00 	.word	0xe000ed00
 802d470:	0802b200 	.word	0x0802b200
 802d474:	02321eff 	.word	0x02321eff
 802d478:	22040100 	.word	0x22040100

0802d47c <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 802d47c:	b510      	push	{r4, lr}
#endif /* PREFETCH_ENABLE */

#ifdef CORE_CM0PLUS
#else
  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 802d47e:	2003      	movs	r0, #3
 802d480:	f000 fc5c 	bl	802dd3c <HAL_NVIC_SetPriorityGrouping>

  /* Update the SystemCoreClock global variable */
#if defined(DUAL_CORE) && defined(CORE_CM0PLUS)
  SystemCoreClock = HAL_RCC_GetHCLK2Freq();
#else
  SystemCoreClock = HAL_RCC_GetHCLKFreq();
 802d484:	f001 fac4 	bl	802ea10 <HAL_RCC_GetHCLKFreq>
 802d488:	4b06      	ldr	r3, [pc, #24]	; (802d4a4 <HAL_Init+0x28>)
 802d48a:	6018      	str	r0, [r3, #0]
#endif

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 802d48c:	200f      	movs	r0, #15
 802d48e:	f7ff f8d7 	bl	802c640 <HAL_InitTick>
 802d492:	4604      	mov	r4, r0
 802d494:	b918      	cbnz	r0, 802d49e <HAL_Init+0x22>
    status = HAL_ERROR;
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
 802d496:	f7fe ffaa 	bl	802c3ee <HAL_MspInit>
  }

  /* Return function status */
  return status;
}
 802d49a:	4620      	mov	r0, r4
 802d49c:	bd10      	pop	{r4, pc}
    status = HAL_ERROR;
 802d49e:	2401      	movs	r4, #1
 802d4a0:	e7fb      	b.n	802d49a <HAL_Init+0x1e>
 802d4a2:	bf00      	nop
 802d4a4:	2000344c 	.word	0x2000344c

0802d4a8 <HAL_SuspendTick>:
  * @retval None
  */
__weak void HAL_SuspendTick(void)
{
  /* Disable SysTick Interrupt */
  CLEAR_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
 802d4a8:	4a02      	ldr	r2, [pc, #8]	; (802d4b4 <HAL_SuspendTick+0xc>)
 802d4aa:	6813      	ldr	r3, [r2, #0]
 802d4ac:	f023 0302 	bic.w	r3, r3, #2
 802d4b0:	6013      	str	r3, [r2, #0]
}
 802d4b2:	4770      	bx	lr
 802d4b4:	e000e010 	.word	0xe000e010

0802d4b8 <HAL_ResumeTick>:
  * @retval None
  */
__weak void HAL_ResumeTick(void)
{
  /* Enable SysTick Interrupt */
  SET_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
 802d4b8:	4a02      	ldr	r2, [pc, #8]	; (802d4c4 <HAL_ResumeTick+0xc>)
 802d4ba:	6813      	ldr	r3, [r2, #0]
 802d4bc:	f043 0302 	orr.w	r3, r3, #2
 802d4c0:	6013      	str	r3, [r2, #0]
}
 802d4c2:	4770      	bx	lr
 802d4c4:	e000e010 	.word	0xe000e010

0802d4c8 <HAL_GetUIDw0>:
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw0(void)
{
  return (READ_REG(*((uint32_t *)UID_BASE)));
}
 802d4c8:	4b01      	ldr	r3, [pc, #4]	; (802d4d0 <HAL_GetUIDw0+0x8>)
 802d4ca:	6818      	ldr	r0, [r3, #0]
 802d4cc:	4770      	bx	lr
 802d4ce:	bf00      	nop
 802d4d0:	1fff7590 	.word	0x1fff7590

0802d4d4 <HAL_GetUIDw1>:
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw1(void)
{
  return (READ_REG(*((uint32_t *)(UID_BASE + 4U))));
}
 802d4d4:	4b01      	ldr	r3, [pc, #4]	; (802d4dc <HAL_GetUIDw1+0x8>)
 802d4d6:	6818      	ldr	r0, [r3, #0]
 802d4d8:	4770      	bx	lr
 802d4da:	bf00      	nop
 802d4dc:	1fff7594 	.word	0x1fff7594

0802d4e0 <HAL_GetUIDw2>:
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw2(void)
{
  return (READ_REG(*((uint32_t *)(UID_BASE + 8U))));
}
 802d4e0:	4b01      	ldr	r3, [pc, #4]	; (802d4e8 <HAL_GetUIDw2+0x8>)
 802d4e2:	6818      	ldr	r0, [r3, #0]
 802d4e4:	4770      	bx	lr
 802d4e6:	bf00      	nop
 802d4e8:	1fff7598 	.word	0x1fff7598

0802d4ec <HAL_DBGMCU_EnableDBGSleepMode>:
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
 802d4ec:	4a02      	ldr	r2, [pc, #8]	; (802d4f8 <HAL_DBGMCU_EnableDBGSleepMode+0xc>)
 802d4ee:	6853      	ldr	r3, [r2, #4]
 802d4f0:	f043 0301 	orr.w	r3, r3, #1
 802d4f4:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_EnableDBGSleepMode(void)
{
  LL_DBGMCU_EnableDBGSleepMode();
}
 802d4f6:	4770      	bx	lr
 802d4f8:	e0042000 	.word	0xe0042000

0802d4fc <HAL_DBGMCU_DisableDBGSleepMode>:
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
 802d4fc:	4a02      	ldr	r2, [pc, #8]	; (802d508 <HAL_DBGMCU_DisableDBGSleepMode+0xc>)
 802d4fe:	6853      	ldr	r3, [r2, #4]
 802d500:	f023 0301 	bic.w	r3, r3, #1
 802d504:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_DisableDBGSleepMode(void)
{
  LL_DBGMCU_DisableDBGSleepMode();
}
 802d506:	4770      	bx	lr
 802d508:	e0042000 	.word	0xe0042000

0802d50c <HAL_DBGMCU_EnableDBGStopMode>:
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
 802d50c:	4a02      	ldr	r2, [pc, #8]	; (802d518 <HAL_DBGMCU_EnableDBGStopMode+0xc>)
 802d50e:	6853      	ldr	r3, [r2, #4]
 802d510:	f043 0302 	orr.w	r3, r3, #2
 802d514:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_EnableDBGStopMode(void)
{
  LL_DBGMCU_EnableDBGStopMode();
}
 802d516:	4770      	bx	lr
 802d518:	e0042000 	.word	0xe0042000

0802d51c <HAL_DBGMCU_DisableDBGStopMode>:
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
 802d51c:	4a02      	ldr	r2, [pc, #8]	; (802d528 <HAL_DBGMCU_DisableDBGStopMode+0xc>)
 802d51e:	6853      	ldr	r3, [r2, #4]
 802d520:	f023 0302 	bic.w	r3, r3, #2
 802d524:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_DisableDBGStopMode(void)
{
  LL_DBGMCU_DisableDBGStopMode();
}
 802d526:	4770      	bx	lr
 802d528:	e0042000 	.word	0xe0042000

0802d52c <HAL_DBGMCU_EnableDBGStandbyMode>:
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
 802d52c:	4a02      	ldr	r2, [pc, #8]	; (802d538 <HAL_DBGMCU_EnableDBGStandbyMode+0xc>)
 802d52e:	6853      	ldr	r3, [r2, #4]
 802d530:	f043 0304 	orr.w	r3, r3, #4
 802d534:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_EnableDBGStandbyMode(void)
{
  LL_DBGMCU_EnableDBGStandbyMode();
}
 802d536:	4770      	bx	lr
 802d538:	e0042000 	.word	0xe0042000

0802d53c <HAL_DBGMCU_DisableDBGStandbyMode>:
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
 802d53c:	4a02      	ldr	r2, [pc, #8]	; (802d548 <HAL_DBGMCU_DisableDBGStandbyMode+0xc>)
 802d53e:	6853      	ldr	r3, [r2, #4]
 802d540:	f023 0304 	bic.w	r3, r3, #4
 802d544:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_DisableDBGStandbyMode(void)
{
  LL_DBGMCU_DisableDBGStandbyMode();
}
 802d546:	4770      	bx	lr
 802d548:	e0042000 	.word	0xe0042000

0802d54c <LL_ADC_REG_IsConversionOngoing>:
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group regular.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsConversionOngoing(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 802d54c:	6880      	ldr	r0, [r0, #8]
}
 802d54e:	f3c0 0080 	ubfx	r0, r0, #2, #1
 802d552:	4770      	bx	lr

0802d554 <HAL_ADC_Init>:
  *         of structure "ADC_InitTypeDef".
  * @param hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef *hadc)
{
 802d554:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  uint32_t tmpCFGR1 = 0UL;
  uint32_t tmpCFGR2 = 0UL;
  uint32_t tmp_adc_reg_is_conversion_on_going;
  __IO uint32_t wait_loop_index = 0UL;
 802d558:	2300      	movs	r3, #0
 802d55a:	9301      	str	r3, [sp, #4]

  /* Check ADC handle */
  if (hadc == NULL)
 802d55c:	4604      	mov	r4, r0
 802d55e:	2800      	cmp	r0, #0
 802d560:	f000 810a 	beq.w	802d778 <HAL_ADC_Init+0x224>
  /* continuous mode is disabled.                                             */
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));

  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  if (hadc->State == HAL_ADC_STATE_RESET)
 802d564:	6d85      	ldr	r5, [r0, #88]	; 0x58
 802d566:	b925      	cbnz	r5, 802d572 <HAL_ADC_Init+0x1e>

    /* Init the low level hardware */
    hadc->MspInitCallback(hadc);
#else
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
 802d568:	f7fe fc92 	bl	802be90 <HAL_ADC_MspInit>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Set ADC error code to none */
    ADC_CLEAR_ERRORCODE(hadc);
 802d56c:	65e5      	str	r5, [r4, #92]	; 0x5c

    /* Initialize Lock */
    hadc->Lock = HAL_UNLOCKED;
 802d56e:	f884 5054 	strb.w	r5, [r4, #84]	; 0x54
  }

  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
 802d572:	6820      	ldr	r0, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 802d574:	6883      	ldr	r3, [r0, #8]
 802d576:	00d9      	lsls	r1, r3, #3
 802d578:	f140 80b3 	bpl.w	802d6e2 <HAL_ADC_Init+0x18e>
 802d57c:	6883      	ldr	r3, [r0, #8]
 802d57e:	00da      	lsls	r2, r3, #3
 802d580:	f100 80c6 	bmi.w	802d710 <HAL_ADC_Init+0x1bc>
  /* or not ADC is coming from state reset (if any potential problem of       */
  /* clocking, voltage regulator would not be enabled).                       */
  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 802d584:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802d586:	f043 0310 	orr.w	r3, r3, #16
 802d58a:	65a3      	str	r3, [r4, #88]	; 0x58

    /* Set ADC error code to ADC peripheral internal error */
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 802d58c:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 802d58e:	f043 0301 	orr.w	r3, r3, #1
 802d592:	65e3      	str	r3, [r4, #92]	; 0x5c

    tmp_hal_status = HAL_ERROR;
 802d594:	2101      	movs	r1, #1

  /* Configuration of ADC parameters if previous preliminary actions are      */
  /* correctly completed and if there is no conversion on going on regular    */
  /* group (ADC may already be enabled at this point if HAL_ADC_Init() is     */
  /* called to update a parameter on the fly).                                */
  tmp_adc_reg_is_conversion_on_going = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 802d596:	f7ff ffd9 	bl	802d54c <LL_ADC_REG_IsConversionOngoing>

  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 802d59a:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802d59c:	f003 0310 	and.w	r3, r3, #16
 802d5a0:	4318      	orrs	r0, r3
      && (tmp_adc_reg_is_conversion_on_going == 0UL)
     )
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 802d5a2:	6da3      	ldr	r3, [r4, #88]	; 0x58
  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 802d5a4:	f040 80ea 	bne.w	802d77c <HAL_ADC_Init+0x228>
    ADC_STATE_CLR_SET(hadc->State,
 802d5a8:	f423 7381 	bic.w	r3, r3, #258	; 0x102
 802d5ac:	f043 0302 	orr.w	r3, r3, #2
    /*  - Oversampling                                                        */
    /*  - Trigger frequency mode                                              */
    /* Note: If low power mode AutoPowerOff is enabled, ADC enable            */
    /*       and disable phases are performed automatically by hardware       */
    /*       (in this case, flag ADC_FLAG_RDY is not set).                    */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 802d5b0:	6822      	ldr	r2, [r4, #0]
    ADC_STATE_CLR_SET(hadc->State,
 802d5b2:	65a3      	str	r3, [r4, #88]	; 0x58
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 802d5b4:	6893      	ldr	r3, [r2, #8]
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 802d5b6:	07db      	lsls	r3, r3, #31
 802d5b8:	f100 80ac 	bmi.w	802d714 <HAL_ADC_Init+0x1c0>
      /* parameters):                                                         */
      /*   - internal measurement paths (VrefInt, ...)                        */
      /*     (set into HAL_ADC_ConfigChannel() )                              */

      /* Configuration of ADC resolution                                      */
      MODIFY_REG(hadc->Instance->CFGR1,
 802d5bc:	68d3      	ldr	r3, [r2, #12]
 802d5be:	68a5      	ldr	r5, [r4, #8]
                 ADC_CFGR1_RES,
                 hadc->Init.Resolution);

      tmpCFGR2 |= ((hadc->Init.ClockPrescaler & ADC_CFGR2_CKMODE) |
 802d5c0:	6866      	ldr	r6, [r4, #4]
      MODIFY_REG(hadc->Instance->CFGR1,
 802d5c2:	f023 0318 	bic.w	r3, r3, #24
 802d5c6:	432b      	orrs	r3, r5
 802d5c8:	60d3      	str	r3, [r2, #12]
      tmpCFGR2 |= ((hadc->Init.ClockPrescaler & ADC_CFGR2_CKMODE) |
 802d5ca:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 802d5cc:	f006 4c40 	and.w	ip, r6, #3221225472	; 0xc0000000
 802d5d0:	ea4c 0503 	orr.w	r5, ip, r3
                   hadc->Init.TriggerFrequencyMode
                  );

      if (hadc->Init.OversamplingMode == ENABLE)
 802d5d4:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
 802d5d8:	2b01      	cmp	r3, #1
 802d5da:	d109      	bne.n	802d5f0 <HAL_ADC_Init+0x9c>
      {
        tmpCFGR2 |= (ADC_CFGR2_OVSE |
 802d5dc:	e9d4 3710 	ldrd	r3, r7, [r4, #64]	; 0x40
 802d5e0:	433b      	orrs	r3, r7
 802d5e2:	432b      	orrs	r3, r5
 802d5e4:	6ca5      	ldr	r5, [r4, #72]	; 0x48
 802d5e6:	432b      	orrs	r3, r5
 802d5e8:	ea43 030c 	orr.w	r3, r3, ip
 802d5ec:	f043 0501 	orr.w	r5, r3, #1
                     hadc->Init.Oversampling.RightBitShift |
                     hadc->Init.Oversampling.TriggeredMode
                    );
      }

      MODIFY_REG(hadc->Instance->CFGR2,
 802d5f0:	6917      	ldr	r7, [r2, #16]
 802d5f2:	4b64      	ldr	r3, [pc, #400]	; (802d784 <HAL_ADC_Init+0x230>)
 802d5f4:	403b      	ands	r3, r7
 802d5f6:	432b      	orrs	r3, r5
 802d5f8:	6113      	str	r3, [r2, #16]
                 ADC_CFGR2_TOVS,
                 tmpCFGR2);

      /* Configuration of ADC clock mode: asynchronous clock source           */
      /* with selectable prescaler.                                           */
      if (((hadc->Init.ClockPrescaler) != ADC_CLOCK_SYNC_PCLK_DIV1) &&
 802d5fa:	f026 4300 	bic.w	r3, r6, #2147483648	; 0x80000000
 802d5fe:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 802d602:	d00a      	beq.n	802d61a <HAL_ADC_Init+0xc6>
          ((hadc->Init.ClockPrescaler) != ADC_CLOCK_SYNC_PCLK_DIV2) &&
 802d604:	f1b6 4f00 	cmp.w	r6, #2147483648	; 0x80000000
 802d608:	d007      	beq.n	802d61a <HAL_ADC_Init+0xc6>
          ((hadc->Init.ClockPrescaler) != ADC_CLOCK_SYNC_PCLK_DIV4))
      {
        MODIFY_REG(ADC_COMMON->CCR,
 802d60a:	4f5f      	ldr	r7, [pc, #380]	; (802d788 <HAL_ADC_Init+0x234>)
 802d60c:	683b      	ldr	r3, [r7, #0]
 802d60e:	f406 1670 	and.w	r6, r6, #3932160	; 0x3c0000
 802d612:	f423 1370 	bic.w	r3, r3, #3932160	; 0x3c0000
 802d616:	431e      	orrs	r6, r3
 802d618:	603e      	str	r6, [r7, #0]
    /*  - data alignment                                                      */
    /*  - resolution                                                          */
    /*  - scan direction                                                      */
    /*  - DMA continuous request                                              */
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)      |
                 ADC_CFGR1_AUTOOFF((uint32_t)hadc->Init.LowPowerAutoPowerOff)   |
 802d61a:	7e63      	ldrb	r3, [r4, #25]
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)      |
 802d61c:	7e26      	ldrb	r6, [r4, #24]
 802d61e:	68e7      	ldr	r7, [r4, #12]
                 ADC_CFGR1_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)  |
                 ADC_CFGR1_OVERRUN(hadc->Init.Overrun)                          |
 802d620:	f8d4 c030 	ldr.w	ip, [r4, #48]	; 0x30
                 hadc->Init.DataAlign                                           |
                 ADC_SCAN_SEQ_MODE(hadc->Init.ScanConvMode)                     |
                 ADC_CFGR1_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests));
 802d624:	f894 802c 	ldrb.w	r8, [r4, #44]	; 0x2c
                 ADC_CFGR1_AUTOOFF((uint32_t)hadc->Init.LowPowerAutoPowerOff)   |
 802d628:	03db      	lsls	r3, r3, #15
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)      |
 802d62a:	ea43 3386 	orr.w	r3, r3, r6, lsl #14
                 ADC_CFGR1_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)  |
 802d62e:	7ea6      	ldrb	r6, [r4, #26]
 802d630:	433b      	orrs	r3, r7
                 ADC_CFGR1_OVERRUN(hadc->Init.Overrun)                          |
 802d632:	f1bc 0f00 	cmp.w	ip, #0
 802d636:	ea43 3346 	orr.w	r3, r3, r6, lsl #13
 802d63a:	bf18      	it	ne
 802d63c:	f44f 5c80 	movne.w	ip, #4096	; 0x1000
                 ADC_SCAN_SEQ_MODE(hadc->Init.ScanConvMode)                     |
 802d640:	6927      	ldr	r7, [r4, #16]
 802d642:	ea43 0348 	orr.w	r3, r3, r8, lsl #1
 802d646:	ea43 030c 	orr.w	r3, r3, ip

    /* Update setting of discontinuous mode only if continuous mode is disabled */
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 802d64a:	f894 c020 	ldrb.w	ip, [r4, #32]
                 ADC_SCAN_SEQ_MODE(hadc->Init.ScanConvMode)                     |
 802d64e:	2f00      	cmp	r7, #0
 802d650:	bfb4      	ite	lt
 802d652:	f027 4e00 	biclt.w	lr, r7, #2147483648	; 0x80000000
 802d656:	f44f 1e00 	movge.w	lr, #2097152	; 0x200000
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 802d65a:	f1bc 0f01 	cmp.w	ip, #1
                 ADC_SCAN_SEQ_MODE(hadc->Init.ScanConvMode)                     |
 802d65e:	ea43 0e0e 	orr.w	lr, r3, lr
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 802d662:	d103      	bne.n	802d66c <HAL_ADC_Init+0x118>
    {
      if (hadc->Init.ContinuousConvMode == DISABLE)
 802d664:	2e00      	cmp	r6, #0
 802d666:	d157      	bne.n	802d718 <HAL_ADC_Init+0x1c4>
      {
        /* Enable the selected ADC group regular discontinuous mode */
        tmpCFGR1 |= ADC_CFGR1_DISCEN;
 802d668:	f44e 3e80 	orr.w	lr, lr, #65536	; 0x10000
    /* Enable external trigger if trigger selection is different of software  */
    /* start.                                                                 */
    /* Note: This configuration keeps the hardware feature of parameter       */
    /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
    /*       software start.                                                  */
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 802d66c:	6a66      	ldr	r6, [r4, #36]	; 0x24
 802d66e:	b12e      	cbz	r6, 802d67c <HAL_ADC_Init+0x128>
    {
      tmpCFGR1 |= ((hadc->Init.ExternalTrigConv & ADC_CFGR1_EXTSEL) |
 802d670:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 802d672:	f406 76e0 	and.w	r6, r6, #448	; 0x1c0
 802d676:	431e      	orrs	r6, r3
 802d678:	ea4e 0e06 	orr.w	lr, lr, r6
                   hadc->Init.ExternalTrigConvEdge);
    }

    /* Update ADC configuration register with previous settings */
    MODIFY_REG(hadc->Instance->CFGR1,
 802d67c:	68d6      	ldr	r6, [r2, #12]
 802d67e:	f426 36fe 	bic.w	r6, r6, #130048	; 0x1fc00
 802d682:	f426 76f3 	bic.w	r6, r6, #486	; 0x1e6
 802d686:	ea46 060e 	orr.w	r6, r6, lr
 802d68a:	60d6      	str	r6, [r2, #12]
               ADC_CFGR1_ALIGN   |
               ADC_CFGR1_SCANDIR |
               ADC_CFGR1_DMACFG,
               tmpCFGR1);

    MODIFY_REG(hadc->Instance->CFGR2,
 802d68c:	f8d2 c010 	ldr.w	ip, [r2, #16]
 802d690:	4e3e      	ldr	r6, [pc, #248]	; (802d78c <HAL_ADC_Init+0x238>)
 802d692:	ea0c 0606 	and.w	r6, ip, r6
 802d696:	4335      	orrs	r5, r6
 802d698:	6115      	str	r5, [r2, #16]
  MODIFY_REG(ADCx->SMPR,
 802d69a:	6955      	ldr	r5, [r2, #20]
 802d69c:	6b66      	ldr	r6, [r4, #52]	; 0x34
 802d69e:	f025 0507 	bic.w	r5, r5, #7
 802d6a2:	4335      	orrs	r5, r6
 802d6a4:	6155      	str	r5, [r2, #20]
 802d6a6:	6955      	ldr	r5, [r2, #20]
 802d6a8:	6ba6      	ldr	r6, [r4, #56]	; 0x38
 802d6aa:	f025 0570 	bic.w	r5, r5, #112	; 0x70
 802d6ae:	ea45 1506 	orr.w	r5, r5, r6, lsl #4
 802d6b2:	6155      	str	r5, [r2, #20]
    /*   emulated by software for alignment over all STM32 devices.           */
    /* - if scan mode is enabled, regular channels sequence length is set to  */
    /*   parameter "NbrOfConversion".                                         */
    /*   Channels must be configured into each rank using function            */
    /*   "HAL_ADC_ConfigChannel()".                                           */
    if (hadc->Init.ScanConvMode == ADC_SCAN_DISABLE)
 802d6b4:	2f00      	cmp	r7, #0
 802d6b6:	d138      	bne.n	802d72a <HAL_ADC_Init+0x1d6>
      if (ADCGroupRegularSequencerRanksCount == 1UL)
      {
        /* Set ADC group regular sequencer:                                   */
        /* Set sequencer scan length by clearing ranks above rank 1           */
        /* and do not modify rank 1 value.                                    */
        SET_BIT(hadc->Instance->CHSELR,
 802d6b8:	6a90      	ldr	r0, [r2, #40]	; 0x28
 802d6ba:	f060 000f 	orn	r0, r0, #15
        /*          therefore after the first call of "HAL_ADC_Init()",       */
        /*          each rank corresponding to parameter "NbrOfConversion"    */
        /*          must be set using "HAL_ADC_ConfigChannel()".              */
        /*  - Set sequencer scan length by clearing ranks above maximum rank  */
        /*    and do not modify other ranks value.                            */
        MODIFY_REG(hadc->Instance->CHSELR,
 802d6be:	6290      	str	r0, [r2, #40]	; 0x28
    /* Check back that ADC registers have effectively been configured to      */
    /* ensure of no potential problem of ADC core peripheral clocking.        */
    /* Check through register CFGR1 (excluding analog watchdog configuration: */
    /* set into separate dedicated function, and bits of ADC resolution set   */
    /* out of temporary variable 'tmpCFGR1').                                 */
    if ((hadc->Instance->CFGR1 & ~(ADC_CFGR1_AWD1CH | ADC_CFGR1_AWD1EN | ADC_CFGR1_AWD1SGL | ADC_CFGR1_RES))
 802d6c0:	68d0      	ldr	r0, [r2, #12]
 802d6c2:	4a33      	ldr	r2, [pc, #204]	; (802d790 <HAL_ADC_Init+0x23c>)
 802d6c4:	4002      	ands	r2, r0
 802d6c6:	4572      	cmp	r2, lr
 802d6c8:	d14c      	bne.n	802d764 <HAL_ADC_Init+0x210>
        == tmpCFGR1)
    {
      /* Set ADC error code to none */
      ADC_CLEAR_ERRORCODE(hadc);
 802d6ca:	2300      	movs	r3, #0
 802d6cc:	65e3      	str	r3, [r4, #92]	; 0x5c

      /* Set the ADC state */
      ADC_STATE_CLR_SET(hadc->State,
 802d6ce:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802d6d0:	f023 0303 	bic.w	r3, r3, #3
 802d6d4:	f043 0301 	orr.w	r3, r3, #1
 802d6d8:	65a3      	str	r3, [r4, #88]	; 0x58

    tmp_hal_status = HAL_ERROR;
  }

  return tmp_hal_status;
}
 802d6da:	4608      	mov	r0, r1
 802d6dc:	b002      	add	sp, #8
 802d6de:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  MODIFY_REG(ADCx->CR,
 802d6e2:	6883      	ldr	r3, [r0, #8]
    wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 802d6e4:	4a2b      	ldr	r2, [pc, #172]	; (802d794 <HAL_ADC_Init+0x240>)
 802d6e6:	f023 4310 	bic.w	r3, r3, #2415919104	; 0x90000000
 802d6ea:	f023 0317 	bic.w	r3, r3, #23
 802d6ee:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 802d6f2:	6083      	str	r3, [r0, #8]
 802d6f4:	4b28      	ldr	r3, [pc, #160]	; (802d798 <HAL_ADC_Init+0x244>)
 802d6f6:	681b      	ldr	r3, [r3, #0]
 802d6f8:	fbb3 f3f2 	udiv	r3, r3, r2
 802d6fc:	3301      	adds	r3, #1
 802d6fe:	005b      	lsls	r3, r3, #1
      wait_loop_index--;
 802d700:	9301      	str	r3, [sp, #4]
    while (wait_loop_index != 0UL)
 802d702:	9b01      	ldr	r3, [sp, #4]
 802d704:	2b00      	cmp	r3, #0
 802d706:	f43f af39 	beq.w	802d57c <HAL_ADC_Init+0x28>
      wait_loop_index--;
 802d70a:	9b01      	ldr	r3, [sp, #4]
 802d70c:	3b01      	subs	r3, #1
 802d70e:	e7f7      	b.n	802d700 <HAL_ADC_Init+0x1ac>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 802d710:	2100      	movs	r1, #0
 802d712:	e740      	b.n	802d596 <HAL_ADC_Init+0x42>
  uint32_t tmpCFGR2 = 0UL;
 802d714:	4605      	mov	r5, r0
 802d716:	e780      	b.n	802d61a <HAL_ADC_Init+0xc6>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 802d718:	6da6      	ldr	r6, [r4, #88]	; 0x58
 802d71a:	f046 0620 	orr.w	r6, r6, #32
 802d71e:	65a6      	str	r6, [r4, #88]	; 0x58
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 802d720:	6de6      	ldr	r6, [r4, #92]	; 0x5c
 802d722:	f046 0601 	orr.w	r6, r6, #1
 802d726:	65e6      	str	r6, [r4, #92]	; 0x5c
 802d728:	e7a0      	b.n	802d66c <HAL_ADC_Init+0x118>
    else if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
 802d72a:	f5b7 1f00 	cmp.w	r7, #2097152	; 0x200000
 802d72e:	d1c7      	bne.n	802d6c0 <HAL_ADC_Init+0x16c>
        if (((hadc->ADCGroupRegularSequencerRanks >> (ADCGroupRegularSequencerRanksCount * 4UL)) & ADC_CHSELR_SQ1) ==
 802d730:	6e26      	ldr	r6, [r4, #96]	; 0x60
 802d732:	0085      	lsls	r5, r0, #2
 802d734:	fa26 f505 	lsr.w	r5, r6, r5
 802d738:	f005 050f 	and.w	r5, r5, #15
 802d73c:	2d0f      	cmp	r5, #15
 802d73e:	d00e      	beq.n	802d75e <HAL_ADC_Init+0x20a>
      for (ADCGroupRegularSequencerRanksCount = 0UL; ADCGroupRegularSequencerRanksCount < (8UL); ADCGroupRegularSequencerRanksCount++)
 802d740:	3001      	adds	r0, #1
 802d742:	2808      	cmp	r0, #8
 802d744:	d1f5      	bne.n	802d732 <HAL_ADC_Init+0x1de>
        MODIFY_REG(hadc->Instance->CHSELR,
 802d746:	6a90      	ldr	r0, [r2, #40]	; 0x28
 802d748:	69e0      	ldr	r0, [r4, #28]
 802d74a:	3801      	subs	r0, #1
 802d74c:	0080      	lsls	r0, r0, #2
 802d74e:	f000 001c 	and.w	r0, r0, #28
 802d752:	f06f 050f 	mvn.w	r5, #15
 802d756:	fa05 f000 	lsl.w	r0, r5, r0
 802d75a:	4330      	orrs	r0, r6
 802d75c:	e7af      	b.n	802d6be <HAL_ADC_Init+0x16a>
      if (ADCGroupRegularSequencerRanksCount == 1UL)
 802d75e:	2801      	cmp	r0, #1
 802d760:	d0aa      	beq.n	802d6b8 <HAL_ADC_Init+0x164>
 802d762:	e7f0      	b.n	802d746 <HAL_ADC_Init+0x1f2>
      ADC_STATE_CLR_SET(hadc->State,
 802d764:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802d766:	f023 0312 	bic.w	r3, r3, #18
 802d76a:	f043 0310 	orr.w	r3, r3, #16
 802d76e:	65a3      	str	r3, [r4, #88]	; 0x58
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 802d770:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 802d772:	f043 0301 	orr.w	r3, r3, #1
 802d776:	65e3      	str	r3, [r4, #92]	; 0x5c
    return HAL_ERROR;
 802d778:	2101      	movs	r1, #1
 802d77a:	e7ae      	b.n	802d6da <HAL_ADC_Init+0x186>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 802d77c:	f043 0310 	orr.w	r3, r3, #16
 802d780:	65a3      	str	r3, [r4, #88]	; 0x58
    tmp_hal_status = HAL_ERROR;
 802d782:	e7f9      	b.n	802d778 <HAL_ADC_Init+0x224>
 802d784:	1ffffc02 	.word	0x1ffffc02
 802d788:	40012708 	.word	0x40012708
 802d78c:	dffffc02 	.word	0xdffffc02
 802d790:	833fffe7 	.word	0x833fffe7
 802d794:	00030d40 	.word	0x00030d40
 802d798:	2000344c 	.word	0x2000344c

0802d79c <HAL_ADC_PollForConversion>:
  * @param hadc ADC handle
  * @param Timeout Timeout value in millisecond.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef *hadc, uint32_t Timeout)
{
 802d79c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  /* If end of conversion selected to end of sequence conversions */
  if (hadc->Init.EOCSelection == ADC_EOC_SEQ_CONV)
 802d79e:	6945      	ldr	r5, [r0, #20]
 802d7a0:	2d08      	cmp	r5, #8
{
 802d7a2:	4604      	mov	r4, r0
 802d7a4:	460e      	mov	r6, r1
  if (hadc->Init.EOCSelection == ADC_EOC_SEQ_CONV)
 802d7a6:	d00a      	beq.n	802d7be <HAL_ADC_PollForConversion+0x22>
    /* each conversion:                                                       */
    /* Particular case is ADC configured in DMA mode and ADC sequencer with   */
    /* several ranks and polling for end of each conversion.                  */
    /* For code simplicity sake, this particular case is generalized to       */
    /* ADC configured in DMA mode and and polling for end of each conversion. */
    if ((hadc->Instance->CFGR1 & ADC_CFGR1_DMAEN) != 0UL)
 802d7a8:	6803      	ldr	r3, [r0, #0]
 802d7aa:	68db      	ldr	r3, [r3, #12]
 802d7ac:	07d9      	lsls	r1, r3, #31
 802d7ae:	d505      	bpl.n	802d7bc <HAL_ADC_PollForConversion+0x20>
    {
      /* Update ADC state machine to error */
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 802d7b0:	6d83      	ldr	r3, [r0, #88]	; 0x58
 802d7b2:	f043 0320 	orr.w	r3, r3, #32
 802d7b6:	6583      	str	r3, [r0, #88]	; 0x58

      return HAL_ERROR;
 802d7b8:	2001      	movs	r0, #1
    __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS));
  }

  /* Return function status */
  return HAL_OK;
}
 802d7ba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      tmp_flag_end = (ADC_FLAG_EOC);
 802d7bc:	2504      	movs	r5, #4
  tickstart = HAL_GetTick();
 802d7be:	f7fe ff41 	bl	802c644 <HAL_GetTick>
 802d7c2:	4607      	mov	r7, r0
  while ((hadc->Instance->ISR & tmp_flag_end) == 0UL)
 802d7c4:	6820      	ldr	r0, [r4, #0]
 802d7c6:	6803      	ldr	r3, [r0, #0]
 802d7c8:	422b      	tst	r3, r5
 802d7ca:	d022      	beq.n	802d812 <HAL_ADC_PollForConversion+0x76>
  SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
 802d7cc:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802d7ce:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 802d7d2:	65a3      	str	r3, [r4, #88]	; 0x58
  return ((READ_BIT(ADCx->CFGR1, ADC_CFGR1_EXTEN) == (LL_ADC_REG_TRIG_SOFTWARE & ADC_CFGR1_EXTEN)) ? 1UL : 0UL);
 802d7d4:	68c3      	ldr	r3, [r0, #12]
 802d7d6:	f413 6f40 	tst.w	r3, #3072	; 0xc00
 802d7da:	d114      	bne.n	802d806 <HAL_ADC_PollForConversion+0x6a>
      && (hadc->Init.ContinuousConvMode == DISABLE)
 802d7dc:	7ea3      	ldrb	r3, [r4, #26]
 802d7de:	b993      	cbnz	r3, 802d806 <HAL_ADC_PollForConversion+0x6a>
    if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS))
 802d7e0:	6803      	ldr	r3, [r0, #0]
 802d7e2:	071b      	lsls	r3, r3, #28
 802d7e4:	d50f      	bpl.n	802d806 <HAL_ADC_PollForConversion+0x6a>
      if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 802d7e6:	f7ff feb1 	bl	802d54c <LL_ADC_REG_IsConversionOngoing>
 802d7ea:	bb38      	cbnz	r0, 802d83c <HAL_ADC_PollForConversion+0xa0>
        __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC | ADC_IT_EOS);
 802d7ec:	6822      	ldr	r2, [r4, #0]
 802d7ee:	6853      	ldr	r3, [r2, #4]
 802d7f0:	f023 030c 	bic.w	r3, r3, #12
 802d7f4:	6053      	str	r3, [r2, #4]
        ADC_STATE_CLR_SET(hadc->State,
 802d7f6:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802d7f8:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 802d7fc:	f023 0301 	bic.w	r3, r3, #1
 802d800:	f043 0301 	orr.w	r3, r3, #1
 802d804:	65a3      	str	r3, [r4, #88]	; 0x58
  if (hadc->Init.LowPowerAutoWait == DISABLE)
 802d806:	7e20      	ldrb	r0, [r4, #24]
 802d808:	bb08      	cbnz	r0, 802d84e <HAL_ADC_PollForConversion+0xb2>
    __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS));
 802d80a:	6823      	ldr	r3, [r4, #0]
 802d80c:	220c      	movs	r2, #12
 802d80e:	601a      	str	r2, [r3, #0]
 802d810:	e7d3      	b.n	802d7ba <HAL_ADC_PollForConversion+0x1e>
    if (Timeout != HAL_MAX_DELAY)
 802d812:	1c72      	adds	r2, r6, #1
 802d814:	d0d7      	beq.n	802d7c6 <HAL_ADC_PollForConversion+0x2a>
      if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0UL))
 802d816:	f7fe ff15 	bl	802c644 <HAL_GetTick>
 802d81a:	1bc0      	subs	r0, r0, r7
 802d81c:	42b0      	cmp	r0, r6
 802d81e:	d801      	bhi.n	802d824 <HAL_ADC_PollForConversion+0x88>
 802d820:	2e00      	cmp	r6, #0
 802d822:	d1cf      	bne.n	802d7c4 <HAL_ADC_PollForConversion+0x28>
        if ((hadc->Instance->ISR & tmp_flag_end) == 0UL)
 802d824:	6823      	ldr	r3, [r4, #0]
 802d826:	681b      	ldr	r3, [r3, #0]
 802d828:	402b      	ands	r3, r5
 802d82a:	d1cb      	bne.n	802d7c4 <HAL_ADC_PollForConversion+0x28>
          SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 802d82c:	6da2      	ldr	r2, [r4, #88]	; 0x58
          __HAL_UNLOCK(hadc);
 802d82e:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54
          SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 802d832:	f042 0204 	orr.w	r2, r2, #4
 802d836:	65a2      	str	r2, [r4, #88]	; 0x58
          return HAL_TIMEOUT;
 802d838:	2003      	movs	r0, #3
 802d83a:	e7be      	b.n	802d7ba <HAL_ADC_PollForConversion+0x1e>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 802d83c:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802d83e:	f043 0320 	orr.w	r3, r3, #32
 802d842:	65a3      	str	r3, [r4, #88]	; 0x58
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 802d844:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 802d846:	f043 0301 	orr.w	r3, r3, #1
 802d84a:	65e3      	str	r3, [r4, #92]	; 0x5c
 802d84c:	e7db      	b.n	802d806 <HAL_ADC_PollForConversion+0x6a>
  return HAL_OK;
 802d84e:	2000      	movs	r0, #0
 802d850:	e7b3      	b.n	802d7ba <HAL_ADC_PollForConversion+0x1e>

0802d852 <HAL_ADC_GetValue>:

  /* Note: EOC flag is not cleared here by software because automatically     */
  /*       cleared by hardware when reading register DR.                      */

  /* Return ADC converted value */
  return hadc->Instance->DR;
 802d852:	6803      	ldr	r3, [r0, #0]
 802d854:	6c18      	ldr	r0, [r3, #64]	; 0x40
}
 802d856:	4770      	bx	lr

0802d858 <HAL_ADC_ConfigChannel>:
  * @param hadc ADC handle
  * @param pConfig Structure of ADC channel assigned to ADC group regular.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef *hadc, ADC_ChannelConfTypeDef *pConfig)
{
 802d858:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  uint32_t tmp_config_internal_channel;
  __IO uint32_t wait_loop_index = 0UL;
 802d85a:	2300      	movs	r3, #0
 802d85c:	9301      	str	r3, [sp, #4]
    assert_param(IS_ADC_REGULAR_NB_CONV(hadc->Init.NbrOfConversion));

    assert_param(IS_ADC_REGULAR_RANK(pConfig->Rank));
  }

  __HAL_LOCK(hadc);
 802d85e:	f890 3054 	ldrb.w	r3, [r0, #84]	; 0x54
 802d862:	2b01      	cmp	r3, #1
{
 802d864:	4604      	mov	r4, r0
  __HAL_LOCK(hadc);
 802d866:	f000 80bb 	beq.w	802d9e0 <HAL_ADC_ConfigChannel+0x188>
 802d86a:	2301      	movs	r3, #1
 802d86c:	f880 3054 	strb.w	r3, [r0, #84]	; 0x54
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Channel number                                                        */
  /*  - Channel sampling time                                                 */
  /*  - Management of internal measurement channels: VrefInt/TempSensor/Vbat  */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 802d870:	6800      	ldr	r0, [r0, #0]
 802d872:	f7ff fe6b 	bl	802d54c <LL_ADC_REG_IsConversionOngoing>
 802d876:	2800      	cmp	r0, #0
 802d878:	f040 80ac 	bne.w	802d9d4 <HAL_ADC_ConfigChannel+0x17c>
    /* If sequencer set to not fully configurable with channel rank set to    */
    /* none, remove the channel from the sequencer.                           */
    /* Otherwise (sequencer set to fully configurable or to to not fully      */
    /* configurable with channel rank to be set), configure the selected      */
    /* channel.                                                               */
    if (pConfig->Rank != ADC_RANK_NONE)
 802d87c:	6848      	ldr	r0, [r1, #4]
 802d87e:	6923      	ldr	r3, [r4, #16]
 802d880:	680a      	ldr	r2, [r1, #0]
 802d882:	2802      	cmp	r0, #2
 802d884:	f023 0304 	bic.w	r3, r3, #4
 802d888:	d07c      	beq.n	802d984 <HAL_ADC_ConfigChannel+0x12c>
      /* Note: ADC channel configuration requires few ADC clock cycles        */
      /*       to be ready. Processing of ADC settings in this function       */
      /*       induce that a specific wait time is not necessary.             */
      /*       For more details on ADC channel configuration ready,           */
      /*       refer to function "LL_ADC_IsActiveFlag_CCRDY()".               */
      if ((hadc->Init.ScanConvMode == ADC_SCAN_SEQ_FIXED)       ||
 802d88a:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 802d88e:	6825      	ldr	r5, [r4, #0]
 802d890:	f3c2 0e11 	ubfx	lr, r2, #0, #18
 802d894:	d113      	bne.n	802d8be <HAL_ADC_ConfigChannel+0x66>
  SET_BIT(ADCx->CHSELR, (Channel & ADC_CHANNEL_ID_BITFIELD_MASK));
 802d896:	6aab      	ldr	r3, [r5, #40]	; 0x28
 802d898:	ea43 030e 	orr.w	r3, r3, lr
  MODIFY_REG(ADCx->CHSELR,
 802d89c:	62ab      	str	r3, [r5, #40]	; 0x28
  MODIFY_REG(ADCx->SMPR,
 802d89e:	688b      	ldr	r3, [r1, #8]
 802d8a0:	6968      	ldr	r0, [r5, #20]
 802d8a2:	ea03 2302 	and.w	r3, r3, r2, lsl #8
 802d8a6:	f023 437c 	bic.w	r3, r3, #4227858432	; 0xfc000000
 802d8aa:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 802d8ae:	ea20 2102 	bic.w	r1, r0, r2, lsl #8
 802d8b2:	430b      	orrs	r3, r1
      /* internal measurement paths enable: If internal channel selected,     */
      /* enable dedicated internal buffers and path.                          */
      /* Note: these internal measurement paths can be disabled using         */
      /*       HAL_ADC_DeInit() or removing the channel from sequencer with   */
      /*       channel configuration parameter "Rank".                        */
      if (__LL_ADC_IS_CHANNEL_INTERNAL(pConfig->Channel))
 802d8b4:	2a00      	cmp	r2, #0
 802d8b6:	616b      	str	r3, [r5, #20]
 802d8b8:	db26      	blt.n	802d908 <HAL_ADC_ConfigChannel+0xb0>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 802d8ba:	2000      	movs	r0, #0
}
 802d8bc:	e050      	b.n	802d960 <HAL_ADC_ConfigChannel+0x108>
        MODIFY_REG(hadc->ADCGroupRegularSequencerRanks,
 802d8be:	6e23      	ldr	r3, [r4, #96]	; 0x60
 802d8c0:	f000 071f 	and.w	r7, r0, #31
 802d8c4:	f04f 0c0f 	mov.w	ip, #15
 802d8c8:	fa0c fc07 	lsl.w	ip, ip, r7
 802d8cc:	ea6f 060c 	mvn.w	r6, ip
 802d8d0:	ea23 0c0c 	bic.w	ip, r3, ip
 802d8d4:	f1be 0f00 	cmp.w	lr, #0
 802d8d8:	d111      	bne.n	802d8fe <HAL_ADC_ConfigChannel+0xa6>
 802d8da:	f3c2 6384 	ubfx	r3, r2, #26, #5
 802d8de:	40bb      	lsls	r3, r7
 802d8e0:	ea43 030c 	orr.w	r3, r3, ip
 802d8e4:	6623      	str	r3, [r4, #96]	; 0x60
        if (((pConfig->Rank >> 2UL) + 1UL) <= hadc->Init.NbrOfConversion)
 802d8e6:	0880      	lsrs	r0, r0, #2
 802d8e8:	69e3      	ldr	r3, [r4, #28]
 802d8ea:	3001      	adds	r0, #1
 802d8ec:	4298      	cmp	r0, r3
 802d8ee:	d8d6      	bhi.n	802d89e <HAL_ADC_ConfigChannel+0x46>
  MODIFY_REG(ADCx->CHSELR,
 802d8f0:	6aa8      	ldr	r0, [r5, #40]	; 0x28
 802d8f2:	f3c2 6383 	ubfx	r3, r2, #26, #4
 802d8f6:	40bb      	lsls	r3, r7
 802d8f8:	4006      	ands	r6, r0
 802d8fa:	4333      	orrs	r3, r6
 802d8fc:	e7ce      	b.n	802d89c <HAL_ADC_ConfigChannel+0x44>
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 802d8fe:	fa92 f3a2 	rbit	r3, r2
   */
  if (value == 0U)
  {
    return 32U;
  }
  return __builtin_clz(value);
 802d902:	fab3 f383 	clz	r3, r3
 802d906:	e7ea      	b.n	802d8de <HAL_ADC_ConfigChannel+0x86>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 802d908:	4936      	ldr	r1, [pc, #216]	; (802d9e4 <HAL_ADC_ConfigChannel+0x18c>)
      {
        tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));

        /* If the requested internal measurement path has already been enabled,   */
        /* bypass the configuration processing.                                   */
        if ((pConfig->Channel == ADC_CHANNEL_TEMPSENSOR) &&
 802d90a:	4837      	ldr	r0, [pc, #220]	; (802d9e8 <HAL_ADC_ConfigChannel+0x190>)
 802d90c:	680b      	ldr	r3, [r1, #0]
 802d90e:	4282      	cmp	r2, r0
 802d910:	f003 75e0 	and.w	r5, r3, #29360128	; 0x1c00000
 802d914:	d117      	bne.n	802d946 <HAL_ADC_ConfigChannel+0xee>
 802d916:	021b      	lsls	r3, r3, #8
 802d918:	d4cf      	bmi.n	802d8ba <HAL_ADC_ConfigChannel+0x62>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 802d91a:	680b      	ldr	r3, [r1, #0]
          /* Delay for temperature sensor stabilization time */
          /* Wait loop initialization and execution */
          /* Note: Variable divided by 2 to compensate partially              */
          /*       CPU processing cycles, scaling in us split to not          */
          /*       exceed 32 bits register capacity and handle low frequency. */
          wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 802d91c:	4a33      	ldr	r2, [pc, #204]	; (802d9ec <HAL_ADC_ConfigChannel+0x194>)
 802d91e:	f023 73e0 	bic.w	r3, r3, #29360128	; 0x1c00000
 802d922:	432b      	orrs	r3, r5
 802d924:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 802d928:	600b      	str	r3, [r1, #0]
 802d92a:	4b31      	ldr	r3, [pc, #196]	; (802d9f0 <HAL_ADC_ConfigChannel+0x198>)
 802d92c:	681b      	ldr	r3, [r3, #0]
 802d92e:	fbb3 f2f2 	udiv	r2, r3, r2
 802d932:	230c      	movs	r3, #12
 802d934:	fb02 3303 	mla	r3, r2, r3, r3
          while (wait_loop_index != 0UL)
          {
            wait_loop_index--;
 802d938:	9301      	str	r3, [sp, #4]
          while (wait_loop_index != 0UL)
 802d93a:	9b01      	ldr	r3, [sp, #4]
 802d93c:	2b00      	cmp	r3, #0
 802d93e:	d0bc      	beq.n	802d8ba <HAL_ADC_ConfigChannel+0x62>
            wait_loop_index--;
 802d940:	9b01      	ldr	r3, [sp, #4]
 802d942:	3b01      	subs	r3, #1
 802d944:	e7f8      	b.n	802d938 <HAL_ADC_ConfigChannel+0xe0>
          }
        }
        else if ((pConfig->Channel == ADC_CHANNEL_VBAT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
 802d946:	482b      	ldr	r0, [pc, #172]	; (802d9f4 <HAL_ADC_ConfigChannel+0x19c>)
 802d948:	4282      	cmp	r2, r0
 802d94a:	d10e      	bne.n	802d96a <HAL_ADC_ConfigChannel+0x112>
 802d94c:	f013 7080 	ands.w	r0, r3, #16777216	; 0x1000000
 802d950:	d1b3      	bne.n	802d8ba <HAL_ADC_ConfigChannel+0x62>
 802d952:	680b      	ldr	r3, [r1, #0]
 802d954:	f023 73e0 	bic.w	r3, r3, #29360128	; 0x1c00000
 802d958:	432b      	orrs	r3, r5
 802d95a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 802d95e:	600b      	str	r3, [r1, #0]
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);

    tmp_hal_status = HAL_ERROR;
  }

  __HAL_UNLOCK(hadc);
 802d960:	2300      	movs	r3, #0
 802d962:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54

  return tmp_hal_status;
}
 802d966:	b003      	add	sp, #12
 802d968:	bdf0      	pop	{r4, r5, r6, r7, pc}
        else if ((pConfig->Channel == ADC_CHANNEL_VREFINT) &&
 802d96a:	4823      	ldr	r0, [pc, #140]	; (802d9f8 <HAL_ADC_ConfigChannel+0x1a0>)
 802d96c:	4282      	cmp	r2, r0
 802d96e:	d1a4      	bne.n	802d8ba <HAL_ADC_ConfigChannel+0x62>
 802d970:	f413 0080 	ands.w	r0, r3, #4194304	; 0x400000
 802d974:	d1a1      	bne.n	802d8ba <HAL_ADC_ConfigChannel+0x62>
 802d976:	680b      	ldr	r3, [r1, #0]
 802d978:	f023 73e0 	bic.w	r3, r3, #29360128	; 0x1c00000
 802d97c:	432b      	orrs	r3, r5
 802d97e:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 802d982:	e7ec      	b.n	802d95e <HAL_ADC_ConfigChannel+0x106>
      if ((hadc->Init.ScanConvMode == ADC_SCAN_SEQ_FIXED)       ||
 802d984:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 802d988:	d106      	bne.n	802d998 <HAL_ADC_ConfigChannel+0x140>
        LL_ADC_REG_SetSequencerChRem(hadc->Instance, pConfig->Channel);
 802d98a:	6821      	ldr	r1, [r4, #0]
  CLEAR_BIT(ADCx->CHSELR, (Channel & ADC_CHANNEL_ID_BITFIELD_MASK));
 802d98c:	6a8b      	ldr	r3, [r1, #40]	; 0x28
 802d98e:	f3c2 0011 	ubfx	r0, r2, #0, #18
 802d992:	ea23 0300 	bic.w	r3, r3, r0
 802d996:	628b      	str	r3, [r1, #40]	; 0x28
      if (__LL_ADC_IS_CHANNEL_INTERNAL(pConfig->Channel))
 802d998:	2a00      	cmp	r2, #0
 802d99a:	da8e      	bge.n	802d8ba <HAL_ADC_ConfigChannel+0x62>
        if (pConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 802d99c:	4812      	ldr	r0, [pc, #72]	; (802d9e8 <HAL_ADC_ConfigChannel+0x190>)
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 802d99e:	4911      	ldr	r1, [pc, #68]	; (802d9e4 <HAL_ADC_ConfigChannel+0x18c>)
 802d9a0:	4282      	cmp	r2, r0
 802d9a2:	680b      	ldr	r3, [r1, #0]
 802d9a4:	d107      	bne.n	802d9b6 <HAL_ADC_ConfigChannel+0x15e>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 802d9a6:	680a      	ldr	r2, [r1, #0]
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 802d9a8:	f003 73a0 	and.w	r3, r3, #20971520	; 0x1400000
 802d9ac:	f022 72e0 	bic.w	r2, r2, #29360128	; 0x1c00000
 802d9b0:	4313      	orrs	r3, r2
 802d9b2:	600b      	str	r3, [r1, #0]
 802d9b4:	e781      	b.n	802d8ba <HAL_ADC_ConfigChannel+0x62>
        else if (pConfig->Channel == ADC_CHANNEL_VBAT)
 802d9b6:	480f      	ldr	r0, [pc, #60]	; (802d9f4 <HAL_ADC_ConfigChannel+0x19c>)
 802d9b8:	4282      	cmp	r2, r0
 802d9ba:	d103      	bne.n	802d9c4 <HAL_ADC_ConfigChannel+0x16c>
 802d9bc:	680a      	ldr	r2, [r1, #0]
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 802d9be:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
 802d9c2:	e7f3      	b.n	802d9ac <HAL_ADC_ConfigChannel+0x154>
        else if (pConfig->Channel == ADC_CHANNEL_VREFINT)
 802d9c4:	480c      	ldr	r0, [pc, #48]	; (802d9f8 <HAL_ADC_ConfigChannel+0x1a0>)
 802d9c6:	4282      	cmp	r2, r0
 802d9c8:	f47f af77 	bne.w	802d8ba <HAL_ADC_ConfigChannel+0x62>
 802d9cc:	680a      	ldr	r2, [r1, #0]
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 802d9ce:	f003 73c0 	and.w	r3, r3, #25165824	; 0x1800000
 802d9d2:	e7eb      	b.n	802d9ac <HAL_ADC_ConfigChannel+0x154>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 802d9d4:	6da2      	ldr	r2, [r4, #88]	; 0x58
 802d9d6:	f042 0220 	orr.w	r2, r2, #32
 802d9da:	65a2      	str	r2, [r4, #88]	; 0x58
    tmp_hal_status = HAL_ERROR;
 802d9dc:	4618      	mov	r0, r3
 802d9de:	e7bf      	b.n	802d960 <HAL_ADC_ConfigChannel+0x108>
  __HAL_LOCK(hadc);
 802d9e0:	2002      	movs	r0, #2
 802d9e2:	e7c0      	b.n	802d966 <HAL_ADC_ConfigChannel+0x10e>
 802d9e4:	40012708 	.word	0x40012708
 802d9e8:	b0001000 	.word	0xb0001000
 802d9ec:	00030d40 	.word	0x00030d40
 802d9f0:	2000344c 	.word	0x2000344c
 802d9f4:	b8004000 	.word	0xb8004000
 802d9f8:	b4002000 	.word	0xb4002000

0802d9fc <ADC_ConversionStop>:
  *         stopped to disable the ADC.
  * @param  hadc ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_ConversionStop(ADC_HandleTypeDef *hadc)
{
 802d9fc:	b538      	push	{r3, r4, r5, lr}
 802d9fe:	4604      	mov	r4, r0
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  /* Verification if ADC is not already stopped on regular group to bypass    */
  /* this function if not needed.                                             */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) != 0UL)
 802da00:	6800      	ldr	r0, [r0, #0]
 802da02:	f7ff fda3 	bl	802d54c <LL_ADC_REG_IsConversionOngoing>
 802da06:	b908      	cbnz	r0, 802da0c <ADC_ConversionStop+0x10>
    }

  }

  /* Return HAL status */
  return HAL_OK;
 802da08:	2000      	movs	r0, #0
}
 802da0a:	bd38      	pop	{r3, r4, r5, pc}
    if (LL_ADC_IsDisableOngoing(hadc->Instance) == 0UL)
 802da0c:	6822      	ldr	r2, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADDIS) == (ADC_CR_ADDIS)) ? 1UL : 0UL);
 802da0e:	6893      	ldr	r3, [r2, #8]
 802da10:	0799      	lsls	r1, r3, #30
 802da12:	d407      	bmi.n	802da24 <ADC_ConversionStop+0x28>
  MODIFY_REG(ADCx->CR,
 802da14:	6893      	ldr	r3, [r2, #8]
 802da16:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802da1a:	f023 0317 	bic.w	r3, r3, #23
 802da1e:	f043 0310 	orr.w	r3, r3, #16
 802da22:	6093      	str	r3, [r2, #8]
    tickstart = HAL_GetTick();
 802da24:	f7fe fe0e 	bl	802c644 <HAL_GetTick>
 802da28:	4605      	mov	r5, r0
    while ((hadc->Instance->CR & ADC_CR_ADSTART) != 0UL)
 802da2a:	6823      	ldr	r3, [r4, #0]
 802da2c:	689b      	ldr	r3, [r3, #8]
 802da2e:	075b      	lsls	r3, r3, #29
 802da30:	d5ea      	bpl.n	802da08 <ADC_ConversionStop+0xc>
      if ((HAL_GetTick() - tickstart) > ADC_STOP_CONVERSION_TIMEOUT)
 802da32:	f7fe fe07 	bl	802c644 <HAL_GetTick>
 802da36:	1b40      	subs	r0, r0, r5
 802da38:	2802      	cmp	r0, #2
 802da3a:	d9f6      	bls.n	802da2a <ADC_ConversionStop+0x2e>
        if ((hadc->Instance->CR & ADC_CR_ADSTART) != 0UL)
 802da3c:	6823      	ldr	r3, [r4, #0]
 802da3e:	689b      	ldr	r3, [r3, #8]
 802da40:	075a      	lsls	r2, r3, #29
 802da42:	d5f2      	bpl.n	802da2a <ADC_ConversionStop+0x2e>
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 802da44:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802da46:	f043 0310 	orr.w	r3, r3, #16
 802da4a:	65a3      	str	r3, [r4, #88]	; 0x58
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 802da4c:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 802da4e:	f043 0301 	orr.w	r3, r3, #1
 802da52:	65e3      	str	r3, [r4, #92]	; 0x5c
 802da54:	2001      	movs	r0, #1
 802da56:	e7d8      	b.n	802da0a <ADC_ConversionStop+0xe>

0802da58 <ADC_Enable>:
  *         and voltage regulator must be enabled (done into HAL_ADC_Init()).
  * @param hadc ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_Enable(ADC_HandleTypeDef *hadc)
{
 802da58:	b573      	push	{r0, r1, r4, r5, r6, lr}
  uint32_t tickstart;
  __IO uint32_t wait_loop_index = 0UL;
 802da5a:	2300      	movs	r3, #0

  /* ADC enable and wait for ADC ready (in case of ADC is disabled or         */
  /* enabling phase not yet completed: flag ADC ready not yet set).           */
  /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
  /* causes: ADC clock not running, ...).                                     */
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 802da5c:	6802      	ldr	r2, [r0, #0]
  __IO uint32_t wait_loop_index = 0UL;
 802da5e:	9301      	str	r3, [sp, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 802da60:	6893      	ldr	r3, [r2, #8]
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 802da62:	07dd      	lsls	r5, r3, #31
{
 802da64:	4604      	mov	r4, r0
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 802da66:	d502      	bpl.n	802da6e <ADC_Enable+0x16>
      }
    }
  }

  /* Return HAL status */
  return HAL_OK;
 802da68:	2000      	movs	r0, #0
}
 802da6a:	b002      	add	sp, #8
 802da6c:	bd70      	pop	{r4, r5, r6, pc}
    if ((hadc->Instance->CR & (ADC_CR_ADCAL | ADC_CR_ADSTP | ADC_CR_ADSTART | ADC_CR_ADDIS | ADC_CR_ADEN)) != 0UL)
 802da6e:	6891      	ldr	r1, [r2, #8]
 802da70:	4b21      	ldr	r3, [pc, #132]	; (802daf8 <ADC_Enable+0xa0>)
 802da72:	4219      	tst	r1, r3
 802da74:	d009      	beq.n	802da8a <ADC_Enable+0x32>
            SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 802da76:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802da78:	f043 0310 	orr.w	r3, r3, #16
 802da7c:	65a3      	str	r3, [r4, #88]	; 0x58
            SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 802da7e:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 802da80:	f043 0301 	orr.w	r3, r3, #1
 802da84:	65e3      	str	r3, [r4, #92]	; 0x5c
            return HAL_ERROR;
 802da86:	2001      	movs	r0, #1
 802da88:	e7ef      	b.n	802da6a <ADC_Enable+0x12>
  MODIFY_REG(ADCx->CR,
 802da8a:	6893      	ldr	r3, [r2, #8]
 802da8c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802da90:	f023 0317 	bic.w	r3, r3, #23
 802da94:	f043 0301 	orr.w	r3, r3, #1
 802da98:	6093      	str	r3, [r2, #8]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 802da9a:	4b18      	ldr	r3, [pc, #96]	; (802dafc <ADC_Enable+0xa4>)
 802da9c:	681b      	ldr	r3, [r3, #0]
    if ((LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) & LL_ADC_PATH_INTERNAL_TEMPSENSOR) != 0UL)
 802da9e:	0218      	lsls	r0, r3, #8
 802daa0:	d41c      	bmi.n	802dadc <ADC_Enable+0x84>
    if (hadc->Init.LowPowerAutoPowerOff != ENABLE)
 802daa2:	7e63      	ldrb	r3, [r4, #25]
 802daa4:	2b01      	cmp	r3, #1
 802daa6:	d0df      	beq.n	802da68 <ADC_Enable+0x10>
      tickstart = HAL_GetTick();
 802daa8:	f7fe fdcc 	bl	802c644 <HAL_GetTick>
  MODIFY_REG(ADCx->CR,
 802daac:	4e14      	ldr	r6, [pc, #80]	; (802db00 <ADC_Enable+0xa8>)
 802daae:	4605      	mov	r5, r0
      while (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
 802dab0:	6822      	ldr	r2, [r4, #0]
 802dab2:	6813      	ldr	r3, [r2, #0]
 802dab4:	07db      	lsls	r3, r3, #31
 802dab6:	d4d7      	bmi.n	802da68 <ADC_Enable+0x10>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 802dab8:	6893      	ldr	r3, [r2, #8]
        if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 802daba:	07d9      	lsls	r1, r3, #31
  MODIFY_REG(ADCx->CR,
 802dabc:	bf5f      	itttt	pl
 802dabe:	6893      	ldrpl	r3, [r2, #8]
 802dac0:	4033      	andpl	r3, r6
 802dac2:	f043 0301 	orrpl.w	r3, r3, #1
 802dac6:	6093      	strpl	r3, [r2, #8]
        if ((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
 802dac8:	f7fe fdbc 	bl	802c644 <HAL_GetTick>
 802dacc:	1b40      	subs	r0, r0, r5
 802dace:	2802      	cmp	r0, #2
 802dad0:	d9ee      	bls.n	802dab0 <ADC_Enable+0x58>
          if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
 802dad2:	6823      	ldr	r3, [r4, #0]
 802dad4:	681b      	ldr	r3, [r3, #0]
 802dad6:	07da      	lsls	r2, r3, #31
 802dad8:	d4ea      	bmi.n	802dab0 <ADC_Enable+0x58>
 802dada:	e7cc      	b.n	802da76 <ADC_Enable+0x1e>
      wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_BUFFER_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 802dadc:	4b09      	ldr	r3, [pc, #36]	; (802db04 <ADC_Enable+0xac>)
 802dade:	4a0a      	ldr	r2, [pc, #40]	; (802db08 <ADC_Enable+0xb0>)
 802dae0:	681b      	ldr	r3, [r3, #0]
 802dae2:	fbb3 f3f2 	udiv	r3, r3, r2
 802dae6:	3301      	adds	r3, #1
        wait_loop_index--;
 802dae8:	9301      	str	r3, [sp, #4]
      while (wait_loop_index != 0UL)
 802daea:	9b01      	ldr	r3, [sp, #4]
 802daec:	2b00      	cmp	r3, #0
 802daee:	d0d8      	beq.n	802daa2 <ADC_Enable+0x4a>
        wait_loop_index--;
 802daf0:	9b01      	ldr	r3, [sp, #4]
 802daf2:	3b01      	subs	r3, #1
 802daf4:	e7f8      	b.n	802dae8 <ADC_Enable+0x90>
 802daf6:	bf00      	nop
 802daf8:	80000017 	.word	0x80000017
 802dafc:	40012708 	.word	0x40012708
 802db00:	7fffffe8 	.word	0x7fffffe8
 802db04:	2000344c 	.word	0x2000344c
 802db08:	00030d40 	.word	0x00030d40

0802db0c <HAL_ADC_Start>:
{
 802db0c:	b538      	push	{r3, r4, r5, lr}
 802db0e:	4604      	mov	r4, r0
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 802db10:	6800      	ldr	r0, [r0, #0]
 802db12:	f7ff fd1b 	bl	802d54c <LL_ADC_REG_IsConversionOngoing>
 802db16:	4605      	mov	r5, r0
 802db18:	bb20      	cbnz	r0, 802db64 <HAL_ADC_Start+0x58>
    __HAL_LOCK(hadc);
 802db1a:	f894 3054 	ldrb.w	r3, [r4, #84]	; 0x54
 802db1e:	2b01      	cmp	r3, #1
 802db20:	d020      	beq.n	802db64 <HAL_ADC_Start+0x58>
 802db22:	2301      	movs	r3, #1
 802db24:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54
    tmp_hal_status = ADC_Enable(hadc);
 802db28:	4620      	mov	r0, r4
 802db2a:	f7ff ff95 	bl	802da58 <ADC_Enable>
    if (tmp_hal_status == HAL_OK)
 802db2e:	b9b0      	cbnz	r0, 802db5e <HAL_ADC_Start+0x52>
      ADC_STATE_CLR_SET(hadc->State,
 802db30:	6da3      	ldr	r3, [r4, #88]	; 0x58
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 802db32:	6822      	ldr	r2, [r4, #0]
      ADC_STATE_CLR_SET(hadc->State,
 802db34:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 802db38:	f023 0301 	bic.w	r3, r3, #1
 802db3c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 802db40:	65a3      	str	r3, [r4, #88]	; 0x58
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 802db42:	231c      	movs	r3, #28
      ADC_CLEAR_ERRORCODE(hadc);
 802db44:	65e0      	str	r0, [r4, #92]	; 0x5c
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 802db46:	6013      	str	r3, [r2, #0]
      __HAL_UNLOCK(hadc);
 802db48:	f884 0054 	strb.w	r0, [r4, #84]	; 0x54
  MODIFY_REG(ADCx->CR,
 802db4c:	6893      	ldr	r3, [r2, #8]
 802db4e:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802db52:	f023 0317 	bic.w	r3, r3, #23
 802db56:	f043 0304 	orr.w	r3, r3, #4
 802db5a:	6093      	str	r3, [r2, #8]
}
 802db5c:	bd38      	pop	{r3, r4, r5, pc}
      __HAL_UNLOCK(hadc);
 802db5e:	f884 5054 	strb.w	r5, [r4, #84]	; 0x54
 802db62:	e7fb      	b.n	802db5c <HAL_ADC_Start+0x50>
    tmp_hal_status = HAL_BUSY;
 802db64:	2002      	movs	r0, #2
 802db66:	e7f9      	b.n	802db5c <HAL_ADC_Start+0x50>

0802db68 <ADC_Disable>:
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_Disable(ADC_HandleTypeDef *hadc)
{
  uint32_t tickstart;
  const uint32_t tmp_adc_is_disable_on_going = LL_ADC_IsDisableOngoing(hadc->Instance);
 802db68:	6802      	ldr	r2, [r0, #0]
{
 802db6a:	b538      	push	{r3, r4, r5, lr}
  return ((READ_BIT(ADCx->CR, ADC_CR_ADDIS) == (ADC_CR_ADDIS)) ? 1UL : 0UL);
 802db6c:	6893      	ldr	r3, [r2, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 802db6e:	6891      	ldr	r1, [r2, #8]
 802db70:	4604      	mov	r4, r0

  /* Verification if ADC is not already disabled:                             */
  /* Note: forbidden to disable ADC (set bit ADC_CR_ADDIS) if ADC is already  */
  /*       disabled.                                                          */
  if ((LL_ADC_IsEnabled(hadc->Instance) != 0UL)
 802db72:	07c8      	lsls	r0, r1, #31
 802db74:	d401      	bmi.n	802db7a <ADC_Disable+0x12>
      }
    }
  }

  /* Return HAL status */
  return HAL_OK;
 802db76:	2000      	movs	r0, #0
}
 802db78:	bd38      	pop	{r3, r4, r5, pc}
      && (tmp_adc_is_disable_on_going == 0UL)
 802db7a:	0799      	lsls	r1, r3, #30
 802db7c:	d4fb      	bmi.n	802db76 <ADC_Disable+0xe>
    if ((hadc->Instance->CR & (ADC_CR_ADSTART | ADC_CR_ADEN)) == ADC_CR_ADEN)
 802db7e:	6893      	ldr	r3, [r2, #8]
 802db80:	f003 0305 	and.w	r3, r3, #5
 802db84:	2b01      	cmp	r3, #1
 802db86:	d119      	bne.n	802dbbc <ADC_Disable+0x54>
  MODIFY_REG(ADCx->CR,
 802db88:	6893      	ldr	r3, [r2, #8]
 802db8a:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802db8e:	f023 0317 	bic.w	r3, r3, #23
 802db92:	f043 0302 	orr.w	r3, r3, #2
 802db96:	6093      	str	r3, [r2, #8]
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOSMP | ADC_FLAG_RDY));
 802db98:	2303      	movs	r3, #3
 802db9a:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 802db9c:	f7fe fd52 	bl	802c644 <HAL_GetTick>
 802dba0:	4605      	mov	r5, r0
    while ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
 802dba2:	6823      	ldr	r3, [r4, #0]
 802dba4:	689b      	ldr	r3, [r3, #8]
 802dba6:	07db      	lsls	r3, r3, #31
 802dba8:	d5e5      	bpl.n	802db76 <ADC_Disable+0xe>
      if ((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
 802dbaa:	f7fe fd4b 	bl	802c644 <HAL_GetTick>
 802dbae:	1b40      	subs	r0, r0, r5
 802dbb0:	2802      	cmp	r0, #2
 802dbb2:	d9f6      	bls.n	802dba2 <ADC_Disable+0x3a>
        if ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
 802dbb4:	6823      	ldr	r3, [r4, #0]
 802dbb6:	689b      	ldr	r3, [r3, #8]
 802dbb8:	07da      	lsls	r2, r3, #31
 802dbba:	d5f2      	bpl.n	802dba2 <ADC_Disable+0x3a>
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 802dbbc:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802dbbe:	f043 0310 	orr.w	r3, r3, #16
 802dbc2:	65a3      	str	r3, [r4, #88]	; 0x58
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 802dbc4:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 802dbc6:	f043 0301 	orr.w	r3, r3, #1
 802dbca:	65e3      	str	r3, [r4, #92]	; 0x5c
          return HAL_ERROR;
 802dbcc:	2001      	movs	r0, #1
 802dbce:	e7d3      	b.n	802db78 <ADC_Disable+0x10>

0802dbd0 <HAL_ADC_DeInit>:
{
 802dbd0:	b570      	push	{r4, r5, r6, lr}
  if (hadc == NULL)
 802dbd2:	4604      	mov	r4, r0
 802dbd4:	2800      	cmp	r0, #0
 802dbd6:	d041      	beq.n	802dc5c <HAL_ADC_DeInit+0x8c>
  SET_BIT(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL);
 802dbd8:	6d83      	ldr	r3, [r0, #88]	; 0x58
 802dbda:	f043 0302 	orr.w	r3, r3, #2
 802dbde:	6583      	str	r3, [r0, #88]	; 0x58
  tmp_hal_status = ADC_ConversionStop(hadc);
 802dbe0:	f7ff ff0c 	bl	802d9fc <ADC_ConversionStop>
  if (tmp_hal_status == HAL_OK)
 802dbe4:	4605      	mov	r5, r0
 802dbe6:	b968      	cbnz	r0, 802dc04 <HAL_ADC_DeInit+0x34>
    tmp_hal_status = ADC_Disable(hadc);
 802dbe8:	4620      	mov	r0, r4
 802dbea:	f7ff ffbd 	bl	802db68 <ADC_Disable>
    if (tmp_hal_status == HAL_OK)
 802dbee:	4605      	mov	r5, r0
 802dbf0:	b908      	cbnz	r0, 802dbf6 <HAL_ADC_DeInit+0x26>
      hadc->State = HAL_ADC_STATE_READY;
 802dbf2:	2301      	movs	r3, #1
 802dbf4:	65a3      	str	r3, [r4, #88]	; 0x58
    LL_ADC_DisableInternalRegulator(hadc->Instance);
 802dbf6:	6822      	ldr	r2, [r4, #0]
  CLEAR_BIT(ADCx->CR, (ADC_CR_ADVREGEN | ADC_CR_BITS_PROPERTY_RS));
 802dbf8:	6893      	ldr	r3, [r2, #8]
 802dbfa:	f023 4310 	bic.w	r3, r3, #2415919104	; 0x90000000
 802dbfe:	f023 0317 	bic.w	r3, r3, #23
 802dc02:	6093      	str	r3, [r2, #8]
  __HAL_ADC_DISABLE_IT(hadc, (ADC_IT_AWD3  | ADC_IT_AWD2 |
 802dc04:	6823      	ldr	r3, [r4, #0]
 802dc06:	685a      	ldr	r2, [r3, #4]
 802dc08:	f422 7267 	bic.w	r2, r2, #924	; 0x39c
 802dc0c:	f022 0203 	bic.w	r2, r2, #3
 802dc10:	605a      	str	r2, [r3, #4]
  __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_AWD3  | ADC_FLAG_AWD2 |
 802dc12:	f240 329f 	movw	r2, #927	; 0x39f
 802dc16:	601a      	str	r2, [r3, #0]
  hadc->Instance->CFGR1 &= ~(ADC_CFGR1_AWD1CH   | ADC_CFGR1_AWD1EN  | ADC_CFGR1_AWD1SGL | ADC_CFGR1_DISCEN |
 802dc18:	68d9      	ldr	r1, [r3, #12]
 802dc1a:	4a11      	ldr	r2, [pc, #68]	; (802dc60 <HAL_ADC_DeInit+0x90>)
 802dc1c:	400a      	ands	r2, r1
 802dc1e:	60da      	str	r2, [r3, #12]
  hadc->Instance->CFGR2 &= ~ADC_CFGR2_CKMODE;
 802dc20:	691a      	ldr	r2, [r3, #16]
 802dc22:	f022 4240 	bic.w	r2, r2, #3221225472	; 0xc0000000
 802dc26:	611a      	str	r2, [r3, #16]
  hadc->Instance->SMPR &= ~ADC_SMPR_SMP1;
 802dc28:	695a      	ldr	r2, [r3, #20]
 802dc2a:	f022 0207 	bic.w	r2, r2, #7
 802dc2e:	615a      	str	r2, [r3, #20]
  hadc->Instance->TR1 &= ~(ADC_TR1_HT1 | ADC_TR1_LT1);
 802dc30:	6a1a      	ldr	r2, [r3, #32]
 802dc32:	f002 22f0 	and.w	r2, r2, #4026593280	; 0xf000f000
 802dc36:	621a      	str	r2, [r3, #32]
  hadc->Instance->CHSELR &= ~(ADC_CHSELR_SQ_ALL);
 802dc38:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  ADC_COMMON->CCR &= ~(ADC_CCR_VBATEN | ADC_CCR_TSEN | ADC_CCR_VREFEN | ADC_CCR_PRESC);
 802dc3a:	4a0a      	ldr	r2, [pc, #40]	; (802dc64 <HAL_ADC_DeInit+0x94>)
  hadc->Instance->CHSELR &= ~(ADC_CHSELR_SQ_ALL);
 802dc3c:	2600      	movs	r6, #0
 802dc3e:	629e      	str	r6, [r3, #40]	; 0x28
  ADC_COMMON->CCR &= ~(ADC_CCR_VBATEN | ADC_CCR_TSEN | ADC_CCR_VREFEN | ADC_CCR_PRESC);
 802dc40:	6813      	ldr	r3, [r2, #0]
 802dc42:	f023 73fe 	bic.w	r3, r3, #33292288	; 0x1fc0000
 802dc46:	6013      	str	r3, [r2, #0]
  HAL_ADC_MspDeInit(hadc);
 802dc48:	4620      	mov	r0, r4
 802dc4a:	f7fe f935 	bl	802beb8 <HAL_ADC_MspDeInit>
  ADC_CLEAR_ERRORCODE(hadc);
 802dc4e:	65e6      	str	r6, [r4, #92]	; 0x5c
  hadc->ADCGroupRegularSequencerRanks = 0x00000000UL;
 802dc50:	6626      	str	r6, [r4, #96]	; 0x60
  hadc->State = HAL_ADC_STATE_RESET;
 802dc52:	65a6      	str	r6, [r4, #88]	; 0x58
  __HAL_UNLOCK(hadc);
 802dc54:	f884 6054 	strb.w	r6, [r4, #84]	; 0x54
}
 802dc58:	4628      	mov	r0, r5
 802dc5a:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
 802dc5c:	2501      	movs	r5, #1
 802dc5e:	e7fb      	b.n	802dc58 <HAL_ADC_DeInit+0x88>
 802dc60:	833e0200 	.word	0x833e0200
 802dc64:	40012708 	.word	0x40012708

0802dc68 <HAL_ADC_Stop>:
{
 802dc68:	b510      	push	{r4, lr}
  __HAL_LOCK(hadc);
 802dc6a:	f890 3054 	ldrb.w	r3, [r0, #84]	; 0x54
 802dc6e:	2b01      	cmp	r3, #1
{
 802dc70:	4604      	mov	r4, r0
  __HAL_LOCK(hadc);
 802dc72:	d015      	beq.n	802dca0 <HAL_ADC_Stop+0x38>
 802dc74:	2301      	movs	r3, #1
 802dc76:	f880 3054 	strb.w	r3, [r0, #84]	; 0x54
  tmp_hal_status = ADC_ConversionStop(hadc);
 802dc7a:	f7ff febf 	bl	802d9fc <ADC_ConversionStop>
  if (tmp_hal_status == HAL_OK)
 802dc7e:	b958      	cbnz	r0, 802dc98 <HAL_ADC_Stop+0x30>
    tmp_hal_status = ADC_Disable(hadc);
 802dc80:	4620      	mov	r0, r4
 802dc82:	f7ff ff71 	bl	802db68 <ADC_Disable>
    if (tmp_hal_status == HAL_OK)
 802dc86:	b938      	cbnz	r0, 802dc98 <HAL_ADC_Stop+0x30>
      ADC_STATE_CLR_SET(hadc->State,
 802dc88:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802dc8a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 802dc8e:	f023 0301 	bic.w	r3, r3, #1
 802dc92:	f043 0301 	orr.w	r3, r3, #1
 802dc96:	65a3      	str	r3, [r4, #88]	; 0x58
  __HAL_UNLOCK(hadc);
 802dc98:	2300      	movs	r3, #0
 802dc9a:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54
}
 802dc9e:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hadc);
 802dca0:	2002      	movs	r0, #2
 802dca2:	e7fc      	b.n	802dc9e <HAL_ADC_Stop+0x36>

0802dca4 <HAL_ADCEx_Calibration_Start>:
  *         HAL_ADC_GetValue() (value on 7 bits: from DR[6;0]).
  * @param  hadc       ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef *hadc)
{
 802dca4:	b513      	push	{r0, r1, r4, lr}
  HAL_StatusTypeDef tmp_hal_status;
  __IO uint32_t wait_loop_index = 0UL;
 802dca6:	2300      	movs	r3, #0
 802dca8:	9301      	str	r3, [sp, #4]
  uint32_t backup_setting_adc_dma_transfer; /* Note: Variable not declared as volatile because register read is already declared as volatile */

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  __HAL_LOCK(hadc);
 802dcaa:	f890 3054 	ldrb.w	r3, [r0, #84]	; 0x54
 802dcae:	2b01      	cmp	r3, #1
{
 802dcb0:	4604      	mov	r4, r0
  __HAL_LOCK(hadc);
 802dcb2:	d040      	beq.n	802dd36 <HAL_ADCEx_Calibration_Start+0x92>
 802dcb4:	2301      	movs	r3, #1
 802dcb6:	f880 3054 	strb.w	r3, [r0, #84]	; 0x54

  /* Calibration prerequisite: ADC must be disabled. */

  /* Disable the ADC (if not already disabled) */
  tmp_hal_status = ADC_Disable(hadc);
 802dcba:	f7ff ff55 	bl	802db68 <ADC_Disable>

  /* Check if ADC is effectively disabled */
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 802dcbe:	6823      	ldr	r3, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 802dcc0:	689a      	ldr	r2, [r3, #8]
 802dcc2:	07d2      	lsls	r2, r2, #31
 802dcc4:	d433      	bmi.n	802dd2e <HAL_ADCEx_Calibration_Start+0x8a>
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 802dcc6:	6da2      	ldr	r2, [r4, #88]	; 0x58
 802dcc8:	f422 7281 	bic.w	r2, r2, #258	; 0x102
 802dccc:	f042 0202 	orr.w	r2, r2, #2
 802dcd0:	65a2      	str	r2, [r4, #88]	; 0x58
    /* Note: Specificity of this STM32 series: Calibration factor is          */
    /*       available in data register and also transferred by DMA.          */
    /*       To not insert ADC calibration factor among ADC conversion data   */
    /*       in array variable, DMA transfer must be disabled during          */
    /*       calibration.                                                     */
    backup_setting_adc_dma_transfer = READ_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 802dcd2:	68d9      	ldr	r1, [r3, #12]
    CLEAR_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 802dcd4:	68da      	ldr	r2, [r3, #12]
 802dcd6:	f022 0203 	bic.w	r2, r2, #3
 802dcda:	60da      	str	r2, [r3, #12]

    /* Start ADC calibration */
    SET_BIT(hadc->Instance->CR, ADC_CR_ADCAL);
 802dcdc:	689a      	ldr	r2, [r3, #8]
 802dcde:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
    backup_setting_adc_dma_transfer = READ_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 802dce2:	f001 0103 	and.w	r1, r1, #3
    SET_BIT(hadc->Instance->CR, ADC_CR_ADCAL);
 802dce6:	609a      	str	r2, [r3, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADCAL) == (ADC_CR_ADCAL)) ? 1UL : 0UL);
 802dce8:	689a      	ldr	r2, [r3, #8]
 802dcea:	2a00      	cmp	r2, #0
 802dcec:	da12      	bge.n	802dd14 <HAL_ADCEx_Calibration_Start+0x70>

    /* Wait for calibration completion */
    while (LL_ADC_IsCalibrationOnGoing(hadc->Instance) != 0UL)
    {
      wait_loop_index++;
 802dcee:	9a01      	ldr	r2, [sp, #4]
 802dcf0:	3201      	adds	r2, #1
 802dcf2:	9201      	str	r2, [sp, #4]
      if (wait_loop_index >= ADC_CALIBRATION_TIMEOUT)
 802dcf4:	9a01      	ldr	r2, [sp, #4]
 802dcf6:	f5b2 3f2e 	cmp.w	r2, #178176	; 0x2b800
 802dcfa:	d3f5      	bcc.n	802dce8 <HAL_ADCEx_Calibration_Start+0x44>
      {
        /* Update ADC state machine to error */
        ADC_STATE_CLR_SET(hadc->State,
 802dcfc:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802dcfe:	f023 0312 	bic.w	r3, r3, #18
 802dd02:	f043 0310 	orr.w	r3, r3, #16
 802dd06:	65a3      	str	r3, [r4, #88]	; 0x58
                          HAL_ADC_STATE_BUSY_INTERNAL,
                          HAL_ADC_STATE_ERROR_INTERNAL);

        __HAL_UNLOCK(hadc);
 802dd08:	2300      	movs	r3, #0
 802dd0a:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54

        return HAL_ERROR;
 802dd0e:	2001      	movs	r0, #1
  }

  __HAL_UNLOCK(hadc);

  return tmp_hal_status;
}
 802dd10:	b002      	add	sp, #8
 802dd12:	bd10      	pop	{r4, pc}
    SET_BIT(hadc->Instance->CFGR1, backup_setting_adc_dma_transfer);
 802dd14:	68da      	ldr	r2, [r3, #12]
 802dd16:	430a      	orrs	r2, r1
 802dd18:	60da      	str	r2, [r3, #12]
    ADC_STATE_CLR_SET(hadc->State,
 802dd1a:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802dd1c:	f023 0303 	bic.w	r3, r3, #3
 802dd20:	f043 0301 	orr.w	r3, r3, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 802dd24:	65a3      	str	r3, [r4, #88]	; 0x58
  __HAL_UNLOCK(hadc);
 802dd26:	2300      	movs	r3, #0
 802dd28:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54
  return tmp_hal_status;
 802dd2c:	e7f0      	b.n	802dd10 <HAL_ADCEx_Calibration_Start+0x6c>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 802dd2e:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802dd30:	f043 0310 	orr.w	r3, r3, #16
 802dd34:	e7f6      	b.n	802dd24 <HAL_ADCEx_Calibration_Start+0x80>
  __HAL_LOCK(hadc);
 802dd36:	2002      	movs	r0, #2
 802dd38:	e7ea      	b.n	802dd10 <HAL_ADCEx_Calibration_Start+0x6c>
	...

0802dd3c <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 802dd3c:	4907      	ldr	r1, [pc, #28]	; (802dd5c <HAL_NVIC_SetPriorityGrouping+0x20>)
 802dd3e:	68ca      	ldr	r2, [r1, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 802dd40:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 802dd44:	0203      	lsls	r3, r0, #8
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 802dd46:	0412      	lsls	r2, r2, #16
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 802dd48:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 802dd4c:	0c12      	lsrs	r2, r2, #16
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 802dd4e:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 802dd50:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 802dd54:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  SCB->AIRCR =  reg_value;
 802dd58:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 802dd5a:	4770      	bx	lr
 802dd5c:	e000ed00 	.word	0xe000ed00

0802dd60 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 802dd60:	4b16      	ldr	r3, [pc, #88]	; (802ddbc <HAL_NVIC_SetPriority+0x5c>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 802dd62:	b530      	push	{r4, r5, lr}
 802dd64:	68dc      	ldr	r4, [r3, #12]
 802dd66:	f3c4 2402 	ubfx	r4, r4, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 802dd6a:	f1c4 0307 	rsb	r3, r4, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 802dd6e:	1d25      	adds	r5, r4, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 802dd70:	2b04      	cmp	r3, #4
 802dd72:	bf28      	it	cs
 802dd74:	2304      	movcs	r3, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 802dd76:	2d06      	cmp	r5, #6

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 802dd78:	f04f 35ff 	mov.w	r5, #4294967295
 802dd7c:	fa05 f303 	lsl.w	r3, r5, r3
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 802dd80:	bf8c      	ite	hi
 802dd82:	3c03      	subhi	r4, #3
 802dd84:	2400      	movls	r4, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 802dd86:	ea21 0303 	bic.w	r3, r1, r3
 802dd8a:	40a3      	lsls	r3, r4
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 802dd8c:	fa05 f404 	lsl.w	r4, r5, r4
 802dd90:	ea22 0204 	bic.w	r2, r2, r4
  if ((int32_t)(IRQn) >= 0)
 802dd94:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 802dd96:	ea43 0302 	orr.w	r3, r3, r2
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802dd9a:	bfac      	ite	ge
 802dd9c:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802dda0:	4a07      	ldrlt	r2, [pc, #28]	; (802ddc0 <HAL_NVIC_SetPriority+0x60>)
 802dda2:	ea4f 1303 	mov.w	r3, r3, lsl #4
 802dda6:	bfb8      	it	lt
 802dda8:	f000 000f 	andlt.w	r0, r0, #15
 802ddac:	b2db      	uxtb	r3, r3
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802ddae:	bfaa      	itet	ge
 802ddb0:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802ddb4:	5413      	strblt	r3, [r2, r0]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802ddb6:	f880 3300 	strbge.w	r3, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 802ddba:	bd30      	pop	{r4, r5, pc}
 802ddbc:	e000ed00 	.word	0xe000ed00
 802ddc0:	e000ed14 	.word	0xe000ed14

0802ddc4 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 802ddc4:	2800      	cmp	r0, #0
 802ddc6:	db08      	blt.n	802ddda <HAL_NVIC_EnableIRQ+0x16>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 802ddc8:	2301      	movs	r3, #1
 802ddca:	0942      	lsrs	r2, r0, #5
 802ddcc:	f000 001f 	and.w	r0, r0, #31
 802ddd0:	fa03 f000 	lsl.w	r0, r3, r0
 802ddd4:	4b01      	ldr	r3, [pc, #4]	; (802dddc <HAL_NVIC_EnableIRQ+0x18>)
 802ddd6:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 802ddda:	4770      	bx	lr
 802dddc:	e000e100 	.word	0xe000e100

0802dde0 <HAL_NVIC_DisableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 802dde0:	2800      	cmp	r0, #0
 802dde2:	db0d      	blt.n	802de00 <HAL_NVIC_DisableIRQ+0x20>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 802dde4:	0943      	lsrs	r3, r0, #5
 802dde6:	2201      	movs	r2, #1
 802dde8:	f000 001f 	and.w	r0, r0, #31
 802ddec:	fa02 f000 	lsl.w	r0, r2, r0
 802ddf0:	3320      	adds	r3, #32
 802ddf2:	4a04      	ldr	r2, [pc, #16]	; (802de04 <HAL_NVIC_DisableIRQ+0x24>)
 802ddf4:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
 802ddf8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 802ddfc:	f3bf 8f6f 	isb	sy
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
}
 802de00:	4770      	bx	lr
 802de02:	bf00      	nop
 802de04:	e000e100 	.word	0xe000e100

0802de08 <DMA_SetConfig>:
  * @param DstAddress The destination memory Buffer address
  * @param DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 802de08:	b570      	push	{r4, r5, r6, lr}
  /* Clear the DMAMUX synchro overrun flag */
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 802de0a:	e9d0 4513 	ldrd	r4, r5, [r0, #76]	; 0x4c
 802de0e:	6065      	str	r5, [r4, #4]

  if (hdma->DMAmuxRequestGen != 0U)
 802de10:	6d44      	ldr	r4, [r0, #84]	; 0x54
 802de12:	b114      	cbz	r4, 802de1a <DMA_SetConfig+0x12>
  {
    /* Clear the DMAMUX request generator overrun flag */
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 802de14:	e9d0 4516 	ldrd	r4, r5, [r0, #88]	; 0x58
 802de18:	6065      	str	r5, [r4, #4]
  }

  /* Clear all flags */
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 802de1a:	e9d0 5410 	ldrd	r5, r4, [r0, #64]	; 0x40
 802de1e:	f004 061c 	and.w	r6, r4, #28
 802de22:	2401      	movs	r4, #1
 802de24:	40b4      	lsls	r4, r6
 802de26:	606c      	str	r4, [r5, #4]

  /* Configure DMA Channel data length */
  hdma->Instance->CNDTR = DataLength;
 802de28:	6804      	ldr	r4, [r0, #0]
 802de2a:	6063      	str	r3, [r4, #4]

  /* Memory to Peripheral */
  if ((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 802de2c:	6883      	ldr	r3, [r0, #8]
 802de2e:	2b10      	cmp	r3, #16
  {
    /* Configure DMA Channel destination address */
    hdma->Instance->CPAR = DstAddress;
 802de30:	bf0b      	itete	eq
 802de32:	60a2      	streq	r2, [r4, #8]
  }
  /* Peripheral to Memory */
  else
  {
    /* Configure DMA Channel source address */
    hdma->Instance->CPAR = SrcAddress;
 802de34:	60a1      	strne	r1, [r4, #8]
    hdma->Instance->CMAR = SrcAddress;
 802de36:	60e1      	streq	r1, [r4, #12]

    /* Configure DMA Channel destination address */
    hdma->Instance->CMAR = DstAddress;
 802de38:	60e2      	strne	r2, [r4, #12]
  }
}
 802de3a:	bd70      	pop	{r4, r5, r6, pc}

0802de3c <DMA_CalcDMAMUXChannelBaseAndMask>:
static void DMA_CalcDMAMUXChannelBaseAndMask(DMA_HandleTypeDef *hdma)
{
  uint32_t channel_number;

  /* check if instance is not outside the DMA channel range */
  if ((uint32_t)hdma->Instance < (uint32_t)DMA2_Channel1)
 802de3c:	6802      	ldr	r2, [r0, #0]
 802de3e:	6c41      	ldr	r1, [r0, #68]	; 0x44
 802de40:	b2d3      	uxtb	r3, r2
{
 802de42:	b510      	push	{r4, lr}
 802de44:	3b08      	subs	r3, #8
 802de46:	2414      	movs	r4, #20
 802de48:	fbb3 f3f4 	udiv	r3, r3, r4
  if ((uint32_t)hdma->Instance < (uint32_t)DMA2_Channel1)
 802de4c:	4c0b      	ldr	r4, [pc, #44]	; (802de7c <DMA_CalcDMAMUXChannelBaseAndMask+0x40>)
 802de4e:	42a2      	cmp	r2, r4
  }
  else
  {
    /* DMA2 */
    /* Associate a DMA Channel to a DMAMUX channel */
    hdma->DMAmuxChannel = (DMAMUX1_Channel7 + (hdma->ChannelIndex >> 2U));
 802de50:	bf88      	it	hi
 802de52:	4a0b      	ldrhi	r2, [pc, #44]	; (802de80 <DMA_CalcDMAMUXChannelBaseAndMask+0x44>)
 802de54:	f021 0103 	bic.w	r1, r1, #3
    hdma->DMAmuxChannel = (DMAMUX1_Channel0 + (hdma->ChannelIndex >> 2U));
 802de58:	bf99      	ittee	ls
 802de5a:	f101 4280 	addls.w	r2, r1, #1073741824	; 0x40000000
 802de5e:	f502 3202 	addls.w	r2, r2, #133120	; 0x20800
    hdma->DMAmuxChannel = (DMAMUX1_Channel7 + (hdma->ChannelIndex >> 2U));
 802de62:	1852      	addhi	r2, r2, r1

    /* Prepare channel_number used for DMAmuxChannelStatusMask computation */
    channel_number = (((((uint32_t)hdma->Instance & 0xFFU) - 8U) / 20U) + 7U);
 802de64:	3307      	addhi	r3, #7
 802de66:	6482      	str	r2, [r0, #72]	; 0x48
  }

  /* Initialize the field DMAmuxChannelStatus to DMAMUX1_ChannelStatus base */
  hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
 802de68:	4a06      	ldr	r2, [pc, #24]	; (802de84 <DMA_CalcDMAMUXChannelBaseAndMask+0x48>)
 802de6a:	64c2      	str	r2, [r0, #76]	; 0x4c

  /* Initialize the field DMAmuxChannelStatusMask with the corresponding index of the DMAMUX channel selected for the current ChannelIndex */
  hdma->DMAmuxChannelStatusMask = 1UL << (channel_number & 0x1FU);
 802de6c:	f003 031f 	and.w	r3, r3, #31
 802de70:	2201      	movs	r2, #1
 802de72:	fa02 f303 	lsl.w	r3, r2, r3
 802de76:	6503      	str	r3, [r0, #80]	; 0x50
}
 802de78:	bd10      	pop	{r4, pc}
 802de7a:	bf00      	nop
 802de7c:	40020407 	.word	0x40020407
 802de80:	4002081c 	.word	0x4002081c
 802de84:	40020880 	.word	0x40020880

0802de88 <HAL_DMA_Init>:
{
 802de88:	b510      	push	{r4, lr}
  if (hdma == NULL)
 802de8a:	2800      	cmp	r0, #0
 802de8c:	d060      	beq.n	802df50 <HAL_DMA_Init+0xc8>
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 802de8e:	6802      	ldr	r2, [r0, #0]
 802de90:	4b30      	ldr	r3, [pc, #192]	; (802df54 <HAL_DMA_Init+0xcc>)
 802de92:	429a      	cmp	r2, r3
 802de94:	f04f 0414 	mov.w	r4, #20
 802de98:	d84d      	bhi.n	802df36 <HAL_DMA_Init+0xae>
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 802de9a:	492f      	ldr	r1, [pc, #188]	; (802df58 <HAL_DMA_Init+0xd0>)
 802de9c:	4411      	add	r1, r2
 802de9e:	fbb1 f1f4 	udiv	r1, r1, r4
 802dea2:	0089      	lsls	r1, r1, #2
 802dea4:	6441      	str	r1, [r0, #68]	; 0x44
    hdma->DmaBaseAddress = DMA1;
 802dea6:	f2a3 4307 	subw	r3, r3, #1031	; 0x407
    hdma->DmaBaseAddress = DMA2;
 802deaa:	6403      	str	r3, [r0, #64]	; 0x40
  hdma->State = HAL_DMA_STATE_BUSY;
 802deac:	2302      	movs	r3, #2
 802deae:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
  CLEAR_BIT(hdma->Instance->CCR, (DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 802deb2:	6813      	ldr	r3, [r2, #0]
 802deb4:	f423 43ff 	bic.w	r3, r3, #32640	; 0x7f80
 802deb8:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 802debc:	6013      	str	r3, [r2, #0]
  SET_BIT(hdma->Instance->CCR, (hdma->Init.Direction           |                               \
 802debe:	e9d0 3402 	ldrd	r3, r4, [r0, #8]
 802dec2:	4323      	orrs	r3, r4
 802dec4:	6904      	ldr	r4, [r0, #16]
 802dec6:	6811      	ldr	r1, [r2, #0]
 802dec8:	4323      	orrs	r3, r4
 802deca:	6944      	ldr	r4, [r0, #20]
 802decc:	4323      	orrs	r3, r4
 802dece:	6984      	ldr	r4, [r0, #24]
 802ded0:	4323      	orrs	r3, r4
 802ded2:	69c4      	ldr	r4, [r0, #28]
 802ded4:	4323      	orrs	r3, r4
 802ded6:	6a04      	ldr	r4, [r0, #32]
 802ded8:	4323      	orrs	r3, r4
 802deda:	430b      	orrs	r3, r1
 802dedc:	6013      	str	r3, [r2, #0]
  DMA_CalcDMAMUXChannelBaseAndMask(hdma);
 802dede:	f7ff ffad 	bl	802de3c <DMA_CalcDMAMUXChannelBaseAndMask>
  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 802dee2:	6883      	ldr	r3, [r0, #8]
  hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 802dee4:	6c81      	ldr	r1, [r0, #72]	; 0x48
  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 802dee6:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
    hdma->Init.Request = DMA_REQUEST_MEM2MEM;
 802deea:	bf04      	itt	eq
 802deec:	2300      	moveq	r3, #0
 802deee:	6043      	streq	r3, [r0, #4]
  hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 802def0:	6842      	ldr	r2, [r0, #4]
 802def2:	f002 037f 	and.w	r3, r2, #127	; 0x7f
 802def6:	600b      	str	r3, [r1, #0]
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 802def8:	e9d0 1413 	ldrd	r1, r4, [r0, #76]	; 0x4c
  if (((hdma->Init.Request >  0UL) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 802defc:	3a01      	subs	r2, #1
 802defe:	2a03      	cmp	r2, #3
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 802df00:	604c      	str	r4, [r1, #4]
  if (((hdma->Init.Request >  0UL) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 802df02:	d820      	bhi.n	802df46 <HAL_DMA_Init+0xbe>
static void DMA_CalcDMAMUXRequestGenBaseAndMask(DMA_HandleTypeDef *hdma)
{
  uint32_t request =  hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID;

  /* DMA Channels are connected to DMAMUX1 request generator blocks*/
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 802df04:	4a15      	ldr	r2, [pc, #84]	; (802df5c <HAL_DMA_Init+0xd4>)

  hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
 802df06:	4c16      	ldr	r4, [pc, #88]	; (802df60 <HAL_DMA_Init+0xd8>)
 802df08:	6584      	str	r4, [r0, #88]	; 0x58
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 802df0a:	441a      	add	r2, r3

  /* here "Request" is either DMA_REQUEST_GENERATOR0 to DMA_REQUEST_GENERATOR3, i.e. <= 4*/
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x3U);
 802df0c:	3b01      	subs	r3, #1
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 802df0e:	0092      	lsls	r2, r2, #2
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x3U);
 802df10:	2101      	movs	r1, #1
 802df12:	f003 0303 	and.w	r3, r3, #3
 802df16:	fa01 f303 	lsl.w	r3, r1, r3
    hdma->DMAmuxRequestGen->RGCR = 0U;
 802df1a:	2100      	movs	r1, #0
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 802df1c:	6542      	str	r2, [r0, #84]	; 0x54
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x3U);
 802df1e:	65c3      	str	r3, [r0, #92]	; 0x5c
    hdma->DMAmuxRequestGen->RGCR = 0U;
 802df20:	6011      	str	r1, [r2, #0]
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 802df22:	6063      	str	r3, [r4, #4]
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 802df24:	2300      	movs	r3, #0
  hdma->State = HAL_DMA_STATE_READY;
 802df26:	2201      	movs	r2, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 802df28:	63c3      	str	r3, [r0, #60]	; 0x3c
  __HAL_UNLOCK(hdma);
 802df2a:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
  hdma->State = HAL_DMA_STATE_READY;
 802df2e:	f880 2025 	strb.w	r2, [r0, #37]	; 0x25
  return HAL_OK;
 802df32:	4618      	mov	r0, r3
}
 802df34:	bd10      	pop	{r4, pc}
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2U;
 802df36:	4b0b      	ldr	r3, [pc, #44]	; (802df64 <HAL_DMA_Init+0xdc>)
 802df38:	4413      	add	r3, r2
 802df3a:	fbb3 f3f4 	udiv	r3, r3, r4
 802df3e:	009b      	lsls	r3, r3, #2
 802df40:	6443      	str	r3, [r0, #68]	; 0x44
    hdma->DmaBaseAddress = DMA2;
 802df42:	4b09      	ldr	r3, [pc, #36]	; (802df68 <HAL_DMA_Init+0xe0>)
 802df44:	e7b1      	b.n	802deaa <HAL_DMA_Init+0x22>
    hdma->DMAmuxRequestGen = 0U;
 802df46:	2300      	movs	r3, #0
    hdma->DMAmuxRequestGenStatus = 0U;
 802df48:	e9c0 3315 	strd	r3, r3, [r0, #84]	; 0x54
    hdma->DMAmuxRequestGenStatusMask = 0U;
 802df4c:	65c3      	str	r3, [r0, #92]	; 0x5c
 802df4e:	e7e9      	b.n	802df24 <HAL_DMA_Init+0x9c>
    return HAL_ERROR;
 802df50:	2001      	movs	r0, #1
 802df52:	e7ef      	b.n	802df34 <HAL_DMA_Init+0xac>
 802df54:	40020407 	.word	0x40020407
 802df58:	bffdfff8 	.word	0xbffdfff8
 802df5c:	1000823f 	.word	0x1000823f
 802df60:	40020940 	.word	0x40020940
 802df64:	bffdfbf8 	.word	0xbffdfbf8
 802df68:	40020400 	.word	0x40020400

0802df6c <HAL_DMA_DeInit>:
{
 802df6c:	b538      	push	{r3, r4, r5, lr}
  if (NULL == hdma)
 802df6e:	2800      	cmp	r0, #0
 802df70:	d045      	beq.n	802dffe <HAL_DMA_DeInit+0x92>
  __HAL_DMA_DISABLE(hdma);
 802df72:	6801      	ldr	r1, [r0, #0]
 802df74:	680b      	ldr	r3, [r1, #0]
 802df76:	f023 0301 	bic.w	r3, r3, #1
 802df7a:	600b      	str	r3, [r1, #0]
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 802df7c:	4b21      	ldr	r3, [pc, #132]	; (802e004 <HAL_DMA_DeInit+0x98>)
 802df7e:	4299      	cmp	r1, r3
 802df80:	f04f 0414 	mov.w	r4, #20
 802df84:	d833      	bhi.n	802dfee <HAL_DMA_DeInit+0x82>
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 802df86:	4a20      	ldr	r2, [pc, #128]	; (802e008 <HAL_DMA_DeInit+0x9c>)
 802df88:	440a      	add	r2, r1
 802df8a:	fbb2 f2f4 	udiv	r2, r2, r4
 802df8e:	0092      	lsls	r2, r2, #2
 802df90:	6442      	str	r2, [r0, #68]	; 0x44
    hdma->DmaBaseAddress = DMA1;
 802df92:	f2a3 4307 	subw	r3, r3, #1031	; 0x407
    hdma->DmaBaseAddress = DMA2;
 802df96:	6403      	str	r3, [r0, #64]	; 0x40
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 802df98:	e9d0 2310 	ldrd	r2, r3, [r0, #64]	; 0x40
 802df9c:	2401      	movs	r4, #1
 802df9e:	f003 031c 	and.w	r3, r3, #28
 802dfa2:	fa04 f303 	lsl.w	r3, r4, r3
  hdma->Instance->CCR = 0U;
 802dfa6:	2500      	movs	r5, #0
 802dfa8:	600d      	str	r5, [r1, #0]
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 802dfaa:	6053      	str	r3, [r2, #4]
  DMA_CalcDMAMUXChannelBaseAndMask(hdma);
 802dfac:	f7ff ff46 	bl	802de3c <DMA_CalcDMAMUXChannelBaseAndMask>
  hdma->DMAmuxChannel->CCR = 0U;
 802dfb0:	6c83      	ldr	r3, [r0, #72]	; 0x48
  if (((hdma->Init.Request >  0UL) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 802dfb2:	6841      	ldr	r1, [r0, #4]
  hdma->DMAmuxChannel->CCR = 0U;
 802dfb4:	601d      	str	r5, [r3, #0]
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 802dfb6:	e9d0 3213 	ldrd	r3, r2, [r0, #76]	; 0x4c
 802dfba:	605a      	str	r2, [r3, #4]
  if (((hdma->Init.Request >  0UL) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 802dfbc:	1e4a      	subs	r2, r1, #1
 802dfbe:	2a03      	cmp	r2, #3
 802dfc0:	d806      	bhi.n	802dfd0 <HAL_DMA_DeInit+0x64>
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 802dfc2:	4b12      	ldr	r3, [pc, #72]	; (802e00c <HAL_DMA_DeInit+0xa0>)
 802dfc4:	440b      	add	r3, r1
 802dfc6:	009b      	lsls	r3, r3, #2
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x3U);
 802dfc8:	4094      	lsls	r4, r2
    hdma->DMAmuxRequestGen->RGCR = 0U;
 802dfca:	601d      	str	r5, [r3, #0]
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 802dfcc:	4b10      	ldr	r3, [pc, #64]	; (802e010 <HAL_DMA_DeInit+0xa4>)
 802dfce:	605c      	str	r4, [r3, #4]
  hdma->DMAmuxRequestGen = 0U;
 802dfd0:	2300      	movs	r3, #0
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 802dfd2:	63c3      	str	r3, [r0, #60]	; 0x3c
  hdma->DMAmuxRequestGenStatus = 0U;
 802dfd4:	e9c0 3315 	strd	r3, r3, [r0, #84]	; 0x54
  hdma->XferHalfCpltCallback = NULL;
 802dfd8:	e9c0 330b 	strd	r3, r3, [r0, #44]	; 0x2c
  hdma->XferAbortCallback = NULL;
 802dfdc:	e9c0 330d 	strd	r3, r3, [r0, #52]	; 0x34
  hdma->DMAmuxRequestGenStatusMask = 0U;
 802dfe0:	65c3      	str	r3, [r0, #92]	; 0x5c
  hdma->State = HAL_DMA_STATE_RESET;
 802dfe2:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
  __HAL_UNLOCK(hdma);
 802dfe6:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
  return HAL_OK;
 802dfea:	4618      	mov	r0, r3
}
 802dfec:	bd38      	pop	{r3, r4, r5, pc}
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2U;
 802dfee:	4b09      	ldr	r3, [pc, #36]	; (802e014 <HAL_DMA_DeInit+0xa8>)
 802dff0:	440b      	add	r3, r1
 802dff2:	fbb3 f3f4 	udiv	r3, r3, r4
 802dff6:	009b      	lsls	r3, r3, #2
 802dff8:	6443      	str	r3, [r0, #68]	; 0x44
    hdma->DmaBaseAddress = DMA2;
 802dffa:	4b07      	ldr	r3, [pc, #28]	; (802e018 <HAL_DMA_DeInit+0xac>)
 802dffc:	e7cb      	b.n	802df96 <HAL_DMA_DeInit+0x2a>
    return HAL_ERROR;
 802dffe:	2001      	movs	r0, #1
 802e000:	e7f4      	b.n	802dfec <HAL_DMA_DeInit+0x80>
 802e002:	bf00      	nop
 802e004:	40020407 	.word	0x40020407
 802e008:	bffdfff8 	.word	0xbffdfff8
 802e00c:	1000823f 	.word	0x1000823f
 802e010:	40020940 	.word	0x40020940
 802e014:	bffdfbf8 	.word	0xbffdfbf8
 802e018:	40020400 	.word	0x40020400

0802e01c <HAL_DMA_Start_IT>:
{
 802e01c:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(hdma);
 802e01e:	f890 5024 	ldrb.w	r5, [r0, #36]	; 0x24
 802e022:	2d01      	cmp	r5, #1
{
 802e024:	4604      	mov	r4, r0
  __HAL_LOCK(hdma);
 802e026:	d03c      	beq.n	802e0a2 <HAL_DMA_Start_IT+0x86>
  if (hdma->State == HAL_DMA_STATE_READY)
 802e028:	f890 6025 	ldrb.w	r6, [r0, #37]	; 0x25
  __HAL_LOCK(hdma);
 802e02c:	2501      	movs	r5, #1
  if (hdma->State == HAL_DMA_STATE_READY)
 802e02e:	42ae      	cmp	r6, r5
  __HAL_LOCK(hdma);
 802e030:	f880 5024 	strb.w	r5, [r0, #36]	; 0x24
  if (hdma->State == HAL_DMA_STATE_READY)
 802e034:	f04f 0600 	mov.w	r6, #0
 802e038:	d12d      	bne.n	802e096 <HAL_DMA_Start_IT+0x7a>
    hdma->State = HAL_DMA_STATE_BUSY;
 802e03a:	2502      	movs	r5, #2
 802e03c:	f880 5025 	strb.w	r5, [r0, #37]	; 0x25
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 802e040:	63c6      	str	r6, [r0, #60]	; 0x3c
    __HAL_DMA_DISABLE(hdma);
 802e042:	6806      	ldr	r6, [r0, #0]
 802e044:	6835      	ldr	r5, [r6, #0]
 802e046:	f025 0501 	bic.w	r5, r5, #1
 802e04a:	6035      	str	r5, [r6, #0]
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
 802e04c:	f7ff fedc 	bl	802de08 <DMA_SetConfig>
    if (NULL != hdma->XferHalfCpltCallback)
 802e050:	6b02      	ldr	r2, [r0, #48]	; 0x30
 802e052:	6803      	ldr	r3, [r0, #0]
 802e054:	b1ba      	cbz	r2, 802e086 <HAL_DMA_Start_IT+0x6a>
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 802e056:	681a      	ldr	r2, [r3, #0]
 802e058:	f042 020e 	orr.w	r2, r2, #14
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_TE));
 802e05c:	601a      	str	r2, [r3, #0]
    if ((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)
 802e05e:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 802e060:	6811      	ldr	r1, [r2, #0]
 802e062:	03c9      	lsls	r1, r1, #15
      hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;
 802e064:	bf42      	ittt	mi
 802e066:	6811      	ldrmi	r1, [r2, #0]
 802e068:	f441 7180 	orrmi.w	r1, r1, #256	; 0x100
 802e06c:	6011      	strmi	r1, [r2, #0]
    if (hdma->DMAmuxRequestGen != 0U)
 802e06e:	6d62      	ldr	r2, [r4, #84]	; 0x54
 802e070:	b11a      	cbz	r2, 802e07a <HAL_DMA_Start_IT+0x5e>
      hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
 802e072:	6811      	ldr	r1, [r2, #0]
 802e074:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 802e078:	6011      	str	r1, [r2, #0]
    __HAL_DMA_ENABLE(hdma);
 802e07a:	681a      	ldr	r2, [r3, #0]
 802e07c:	f042 0201 	orr.w	r2, r2, #1
 802e080:	601a      	str	r2, [r3, #0]
  HAL_StatusTypeDef status = HAL_OK;
 802e082:	2000      	movs	r0, #0
}
 802e084:	bd70      	pop	{r4, r5, r6, pc}
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 802e086:	681a      	ldr	r2, [r3, #0]
 802e088:	f022 0204 	bic.w	r2, r2, #4
 802e08c:	601a      	str	r2, [r3, #0]
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_TE));
 802e08e:	681a      	ldr	r2, [r3, #0]
 802e090:	f042 020a 	orr.w	r2, r2, #10
 802e094:	e7e2      	b.n	802e05c <HAL_DMA_Start_IT+0x40>
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
 802e096:	2380      	movs	r3, #128	; 0x80
 802e098:	63c3      	str	r3, [r0, #60]	; 0x3c
    __HAL_UNLOCK(hdma);
 802e09a:	f880 6024 	strb.w	r6, [r0, #36]	; 0x24
    status = HAL_ERROR;
 802e09e:	4628      	mov	r0, r5
 802e0a0:	e7f0      	b.n	802e084 <HAL_DMA_Start_IT+0x68>
  __HAL_LOCK(hdma);
 802e0a2:	2002      	movs	r0, #2
 802e0a4:	e7ee      	b.n	802e084 <HAL_DMA_Start_IT+0x68>

0802e0a6 <HAL_DMA_Abort>:
  if (NULL == hdma)
 802e0a6:	b140      	cbz	r0, 802e0ba <HAL_DMA_Abort+0x14>
  if (hdma->State != HAL_DMA_STATE_BUSY)
 802e0a8:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
 802e0ac:	2b02      	cmp	r3, #2
 802e0ae:	d006      	beq.n	802e0be <HAL_DMA_Abort+0x18>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 802e0b0:	2304      	movs	r3, #4
 802e0b2:	63c3      	str	r3, [r0, #60]	; 0x3c
    __HAL_UNLOCK(hdma);
 802e0b4:	2300      	movs	r3, #0
 802e0b6:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
    return HAL_ERROR;
 802e0ba:	2001      	movs	r0, #1
}
 802e0bc:	4770      	bx	lr
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 802e0be:	6803      	ldr	r3, [r0, #0]
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 802e0c0:	6c81      	ldr	r1, [r0, #72]	; 0x48
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 802e0c2:	681a      	ldr	r2, [r3, #0]
 802e0c4:	f022 020e 	bic.w	r2, r2, #14
 802e0c8:	601a      	str	r2, [r3, #0]
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 802e0ca:	680a      	ldr	r2, [r1, #0]
 802e0cc:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 802e0d0:	600a      	str	r2, [r1, #0]
    __HAL_DMA_DISABLE(hdma);
 802e0d2:	681a      	ldr	r2, [r3, #0]
 802e0d4:	f022 0201 	bic.w	r2, r2, #1
 802e0d8:	601a      	str	r2, [r3, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 802e0da:	e9d0 1310 	ldrd	r1, r3, [r0, #64]	; 0x40
 802e0de:	f003 021c 	and.w	r2, r3, #28
 802e0e2:	2301      	movs	r3, #1
 802e0e4:	4093      	lsls	r3, r2
 802e0e6:	604b      	str	r3, [r1, #4]
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 802e0e8:	e9d0 3213 	ldrd	r3, r2, [r0, #76]	; 0x4c
 802e0ec:	605a      	str	r2, [r3, #4]
    if (hdma->DMAmuxRequestGen != 0U)
 802e0ee:	6d43      	ldr	r3, [r0, #84]	; 0x54
 802e0f0:	b133      	cbz	r3, 802e100 <HAL_DMA_Abort+0x5a>
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 802e0f2:	681a      	ldr	r2, [r3, #0]
 802e0f4:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 802e0f8:	601a      	str	r2, [r3, #0]
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 802e0fa:	e9d0 3216 	ldrd	r3, r2, [r0, #88]	; 0x58
 802e0fe:	605a      	str	r2, [r3, #4]
    hdma->State = HAL_DMA_STATE_READY;
 802e100:	2301      	movs	r3, #1
 802e102:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
    __HAL_UNLOCK(hdma);
 802e106:	2300      	movs	r3, #0
 802e108:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
  return HAL_OK;
 802e10c:	4618      	mov	r0, r3
 802e10e:	4770      	bx	lr

0802e110 <HAL_DMA_Abort_IT>:
{
 802e110:	b510      	push	{r4, lr}
  if (hdma->State != HAL_DMA_STATE_BUSY)
 802e112:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
 802e116:	2b02      	cmp	r3, #2
 802e118:	d003      	beq.n	802e122 <HAL_DMA_Abort_IT+0x12>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 802e11a:	2304      	movs	r3, #4
 802e11c:	63c3      	str	r3, [r0, #60]	; 0x3c
    status = HAL_ERROR;
 802e11e:	2001      	movs	r0, #1
}
 802e120:	bd10      	pop	{r4, pc}
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 802e122:	6803      	ldr	r3, [r0, #0]
 802e124:	681a      	ldr	r2, [r3, #0]
 802e126:	f022 020e 	bic.w	r2, r2, #14
 802e12a:	601a      	str	r2, [r3, #0]
    __HAL_DMA_DISABLE(hdma);
 802e12c:	681a      	ldr	r2, [r3, #0]
 802e12e:	f022 0201 	bic.w	r2, r2, #1
 802e132:	601a      	str	r2, [r3, #0]
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 802e134:	6c82      	ldr	r2, [r0, #72]	; 0x48
 802e136:	6813      	ldr	r3, [r2, #0]
 802e138:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 802e13c:	6013      	str	r3, [r2, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 802e13e:	e9d0 1310 	ldrd	r1, r3, [r0, #64]	; 0x40
 802e142:	f003 021c 	and.w	r2, r3, #28
 802e146:	2301      	movs	r3, #1
 802e148:	4093      	lsls	r3, r2
 802e14a:	604b      	str	r3, [r1, #4]
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 802e14c:	e9d0 3213 	ldrd	r3, r2, [r0, #76]	; 0x4c
 802e150:	605a      	str	r2, [r3, #4]
    if (hdma->DMAmuxRequestGen != 0U)
 802e152:	6d43      	ldr	r3, [r0, #84]	; 0x54
 802e154:	b133      	cbz	r3, 802e164 <HAL_DMA_Abort_IT+0x54>
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 802e156:	681a      	ldr	r2, [r3, #0]
 802e158:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 802e15c:	601a      	str	r2, [r3, #0]
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 802e15e:	e9d0 3216 	ldrd	r3, r2, [r0, #88]	; 0x58
 802e162:	605a      	str	r2, [r3, #4]
    hdma->State = HAL_DMA_STATE_READY;
 802e164:	2301      	movs	r3, #1
 802e166:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
    if (hdma->XferAbortCallback != NULL)
 802e16a:	6b83      	ldr	r3, [r0, #56]	; 0x38
    __HAL_UNLOCK(hdma);
 802e16c:	2400      	movs	r4, #0
 802e16e:	f880 4024 	strb.w	r4, [r0, #36]	; 0x24
    if (hdma->XferAbortCallback != NULL)
 802e172:	b113      	cbz	r3, 802e17a <HAL_DMA_Abort_IT+0x6a>
      hdma->XferAbortCallback(hdma);
 802e174:	4798      	blx	r3
  HAL_StatusTypeDef status = HAL_OK;
 802e176:	4620      	mov	r0, r4
 802e178:	e7d2      	b.n	802e120 <HAL_DMA_Abort_IT+0x10>
 802e17a:	4618      	mov	r0, r3
 802e17c:	e7d0      	b.n	802e120 <HAL_DMA_Abort_IT+0x10>
	...

0802e180 <HAL_DMA_IRQHandler>:
{
 802e180:	b470      	push	{r4, r5, r6}
  if (((flag_it & (DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1CU))) != 0U) && ((source_it & DMA_IT_HT) != 0U))
 802e182:	6c42      	ldr	r2, [r0, #68]	; 0x44
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 802e184:	6c04      	ldr	r4, [r0, #64]	; 0x40
  uint32_t source_it = hdma->Instance->CCR;
 802e186:	6803      	ldr	r3, [r0, #0]
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 802e188:	6826      	ldr	r6, [r4, #0]
  uint32_t source_it = hdma->Instance->CCR;
 802e18a:	681d      	ldr	r5, [r3, #0]
  if (((flag_it & (DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1CU))) != 0U) && ((source_it & DMA_IT_HT) != 0U))
 802e18c:	f002 021c 	and.w	r2, r2, #28
 802e190:	2104      	movs	r1, #4
 802e192:	4091      	lsls	r1, r2
 802e194:	4231      	tst	r1, r6
 802e196:	d00f      	beq.n	802e1b8 <HAL_DMA_IRQHandler+0x38>
 802e198:	f015 0f04 	tst.w	r5, #4
 802e19c:	d00c      	beq.n	802e1b8 <HAL_DMA_IRQHandler+0x38>
      if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 802e19e:	681a      	ldr	r2, [r3, #0]
 802e1a0:	0692      	lsls	r2, r2, #26
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 802e1a2:	bf5e      	ittt	pl
 802e1a4:	681a      	ldrpl	r2, [r3, #0]
 802e1a6:	f022 0204 	bicpl.w	r2, r2, #4
 802e1aa:	601a      	strpl	r2, [r3, #0]
      if (hdma->XferHalfCpltCallback != NULL)
 802e1ac:	6b03      	ldr	r3, [r0, #48]	; 0x30
      hdma->DmaBaseAddress->IFCR = DMA_ISR_HTIF1 << (hdma->ChannelIndex & 0x1CU);
 802e1ae:	6061      	str	r1, [r4, #4]
    if (hdma->XferErrorCallback != NULL)
 802e1b0:	2b00      	cmp	r3, #0
 802e1b2:	d033      	beq.n	802e21c <HAL_DMA_IRQHandler+0x9c>
}
 802e1b4:	bc70      	pop	{r4, r5, r6}
      hdma->XferErrorCallback(hdma);
 802e1b6:	4718      	bx	r3
  else if ((0U != (flag_it & (DMA_FLAG_TC1 << (hdma->ChannelIndex & 0x1CU)))) && (0U != (source_it & DMA_IT_TC)))
 802e1b8:	2102      	movs	r1, #2
 802e1ba:	4091      	lsls	r1, r2
 802e1bc:	4231      	tst	r1, r6
 802e1be:	d017      	beq.n	802e1f0 <HAL_DMA_IRQHandler+0x70>
 802e1c0:	f015 0f02 	tst.w	r5, #2
 802e1c4:	d014      	beq.n	802e1f0 <HAL_DMA_IRQHandler+0x70>
      if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 802e1c6:	681a      	ldr	r2, [r3, #0]
 802e1c8:	0694      	lsls	r4, r2, #26
 802e1ca:	d406      	bmi.n	802e1da <HAL_DMA_IRQHandler+0x5a>
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
 802e1cc:	681a      	ldr	r2, [r3, #0]
 802e1ce:	f022 020a 	bic.w	r2, r2, #10
 802e1d2:	601a      	str	r2, [r3, #0]
        hdma->State = HAL_DMA_STATE_READY;
 802e1d4:	2201      	movs	r2, #1
 802e1d6:	f880 2025 	strb.w	r2, [r0, #37]	; 0x25
      __HAL_DMA_CLEAR_FLAG(hdma, (DMA_FLAG_TC1 << (hdma->ChannelIndex & 0x1CU)));
 802e1da:	4a11      	ldr	r2, [pc, #68]	; (802e220 <HAL_DMA_IRQHandler+0xa0>)
 802e1dc:	4293      	cmp	r3, r2
 802e1de:	bf8c      	ite	hi
 802e1e0:	4b10      	ldrhi	r3, [pc, #64]	; (802e224 <HAL_DMA_IRQHandler+0xa4>)
 802e1e2:	4b11      	ldrls	r3, [pc, #68]	; (802e228 <HAL_DMA_IRQHandler+0xa8>)
 802e1e4:	6059      	str	r1, [r3, #4]
      __HAL_UNLOCK(hdma);
 802e1e6:	2300      	movs	r3, #0
 802e1e8:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
      if (hdma->XferCpltCallback != NULL)
 802e1ec:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 802e1ee:	e7df      	b.n	802e1b0 <HAL_DMA_IRQHandler+0x30>
  else if (((flag_it & (DMA_FLAG_TE1 << (hdma->ChannelIndex & 0x1CU))) != 0U) && ((source_it & DMA_IT_TE) != 0U))
 802e1f0:	2108      	movs	r1, #8
 802e1f2:	4091      	lsls	r1, r2
 802e1f4:	4231      	tst	r1, r6
 802e1f6:	d011      	beq.n	802e21c <HAL_DMA_IRQHandler+0x9c>
 802e1f8:	0729      	lsls	r1, r5, #28
 802e1fa:	d50f      	bpl.n	802e21c <HAL_DMA_IRQHandler+0x9c>
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 802e1fc:	6819      	ldr	r1, [r3, #0]
 802e1fe:	f021 010e 	bic.w	r1, r1, #14
 802e202:	6019      	str	r1, [r3, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 802e204:	2301      	movs	r3, #1
 802e206:	fa03 f202 	lsl.w	r2, r3, r2
 802e20a:	6062      	str	r2, [r4, #4]
    hdma->ErrorCode = HAL_DMA_ERROR_TE;
 802e20c:	63c3      	str	r3, [r0, #60]	; 0x3c
    hdma->State = HAL_DMA_STATE_READY;
 802e20e:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
    __HAL_UNLOCK(hdma);
 802e212:	2300      	movs	r3, #0
 802e214:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
    if (hdma->XferErrorCallback != NULL)
 802e218:	6b43      	ldr	r3, [r0, #52]	; 0x34
 802e21a:	e7c9      	b.n	802e1b0 <HAL_DMA_IRQHandler+0x30>
}
 802e21c:	bc70      	pop	{r4, r5, r6}
 802e21e:	4770      	bx	lr
 802e220:	40020080 	.word	0x40020080
 802e224:	40020400 	.word	0x40020400
 802e228:	40020000 	.word	0x40020000

0802e22c <HAL_DMA_ConfigChannelAttributes>:
  if (hdma == NULL)
 802e22c:	b160      	cbz	r0, 802e248 <HAL_DMA_ConfigChannelAttributes+0x1c>
  ccr = READ_REG(hdma->Instance->CCR);
 802e22e:	6802      	ldr	r2, [r0, #0]
  if ((ChannelAttributes & DMA_CHANNEL_ATTR_PRIV_MASK) != 0U)
 802e230:	06c8      	lsls	r0, r1, #27
  ccr = READ_REG(hdma->Instance->CCR);
 802e232:	6813      	ldr	r3, [r2, #0]
  if ((ChannelAttributes & DMA_CHANNEL_ATTR_PRIV_MASK) != 0U)
 802e234:	d505      	bpl.n	802e242 <HAL_DMA_ConfigChannelAttributes+0x16>
    if ((ChannelAttributes & DMA_CCR_PRIV) != 0U)
 802e236:	02c9      	lsls	r1, r1, #11
      SET_BIT(ccr, DMA_CCR_PRIV);
 802e238:	bf4c      	ite	mi
 802e23a:	f443 1380 	orrmi.w	r3, r3, #1048576	; 0x100000
      CLEAR_BIT(ccr, DMA_CCR_PRIV);
 802e23e:	f423 1380 	bicpl.w	r3, r3, #1048576	; 0x100000
  WRITE_REG(hdma->Instance->CCR, ccr);
 802e242:	6013      	str	r3, [r2, #0]
  return status;
 802e244:	2000      	movs	r0, #0
 802e246:	4770      	bx	lr
    return status;
 802e248:	2001      	movs	r0, #1
}
 802e24a:	4770      	bx	lr

0802e24c <HAL_EXTI_RegisterCallback>:
  *         This parameter can be one of @arg @ref EXTI_CallbackIDTypeDef values.
  * @param  pPendingCbfn function pointer to be stored as callback.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_RegisterCallback(EXTI_HandleTypeDef *hexti, EXTI_CallbackIDTypeDef CallbackID, void (*pPendingCbfn)(void))
{
 802e24c:	4603      	mov	r3, r0
  HAL_StatusTypeDef status = HAL_OK;

  switch (CallbackID)
 802e24e:	4608      	mov	r0, r1
 802e250:	b909      	cbnz	r1, 802e256 <HAL_EXTI_RegisterCallback+0xa>
  {
    case  HAL_EXTI_COMMON_CB_ID:
      hexti->PendingCallback = pPendingCbfn;
 802e252:	605a      	str	r2, [r3, #4]
      break;
 802e254:	4770      	bx	lr

    default:
      status = HAL_ERROR;
 802e256:	2001      	movs	r0, #1
      break;
  }

  return status;
}
 802e258:	4770      	bx	lr

0802e25a <HAL_EXTI_GetHandle>:
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(ExtiLine));

  /* Check null pointer */
  if (hexti == NULL)
 802e25a:	b110      	cbz	r0, 802e262 <HAL_EXTI_GetHandle+0x8>
    return HAL_ERROR;
  }
  else
  {
    /* Store line number as handle private field */
    hexti->Line = ExtiLine;
 802e25c:	6001      	str	r1, [r0, #0]

    return HAL_OK;
 802e25e:	2000      	movs	r0, #0
 802e260:	4770      	bx	lr
    return HAL_ERROR;
 802e262:	2001      	movs	r0, #1
  }
}
 802e264:	4770      	bx	lr
	...

0802e268 <FLASH_Program_Fast>:

  /* Set FSTPG bit */
#ifdef CORE_CM0PLUS
  SET_BIT(FLASH->C2CR, FLASH_CR_FSTPG);
#else
  SET_BIT(FLASH->CR, FLASH_CR_FSTPG);
 802e268:	4b0a      	ldr	r3, [pc, #40]	; (802e294 <FLASH_Program_Fast+0x2c>)
 802e26a:	695a      	ldr	r2, [r3, #20]
 802e26c:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
{
 802e270:	b530      	push	{r4, r5, lr}
  SET_BIT(FLASH->CR, FLASH_CR_FSTPG);
 802e272:	615a      	str	r2, [r3, #20]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 802e274:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 802e278:	b672      	cpsid	i
}
 802e27a:	2200      	movs	r2, #0
  __disable_irq();

  /* Program the double word of the row */
  do
  {
    *dest_addr = *src_addr;
 802e27c:	588d      	ldr	r5, [r1, r2]
 802e27e:	5085      	str	r5, [r0, r2]
    dest_addr++;
    src_addr++;
    row_index--;
  }
  while (row_index != 0U);
 802e280:	3204      	adds	r2, #4
 802e282:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 802e286:	d1f9      	bne.n	802e27c <FLASH_Program_Fast+0x14>

  /* wait for BSY in order to be sure that flash operation is ended before
     allowing prefetch in flash. Timeout does not return status, as it will
     be anyway done later */
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != 0U)
 802e288:	691a      	ldr	r2, [r3, #16]
 802e28a:	03d2      	lsls	r2, r2, #15
 802e28c:	d4fc      	bmi.n	802e288 <FLASH_Program_Fast+0x20>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 802e28e:	f384 8810 	msr	PRIMASK, r4
  {
  }

  /* Exit critical section: restore previous priority mask */
  __set_PRIMASK(primask_bit);
}
 802e292:	bd30      	pop	{r4, r5, pc}
 802e294:	58004000 	.word	0x58004000

0802e298 <HAL_FLASH_Unlock>:
  if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0U)
 802e298:	4b06      	ldr	r3, [pc, #24]	; (802e2b4 <HAL_FLASH_Unlock+0x1c>)
 802e29a:	695a      	ldr	r2, [r3, #20]
 802e29c:	2a00      	cmp	r2, #0
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 802e29e:	bfbf      	itttt	lt
 802e2a0:	4a05      	ldrlt	r2, [pc, #20]	; (802e2b8 <HAL_FLASH_Unlock+0x20>)
 802e2a2:	609a      	strlt	r2, [r3, #8]
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 802e2a4:	f102 3288 	addlt.w	r2, r2, #2290649224	; 0x88888888
 802e2a8:	609a      	strlt	r2, [r3, #8]
    if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0U)
 802e2aa:	bfba      	itte	lt
 802e2ac:	6958      	ldrlt	r0, [r3, #20]
  HAL_StatusTypeDef status = HAL_OK;
 802e2ae:	0fc0      	lsrlt	r0, r0, #31
 802e2b0:	2000      	movge	r0, #0
}
 802e2b2:	4770      	bx	lr
 802e2b4:	58004000 	.word	0x58004000
 802e2b8:	45670123 	.word	0x45670123

0802e2bc <HAL_FLASH_Lock>:
  SET_BIT(FLASH->CR, FLASH_CR_LOCK);
 802e2bc:	4b04      	ldr	r3, [pc, #16]	; (802e2d0 <HAL_FLASH_Lock+0x14>)
 802e2be:	695a      	ldr	r2, [r3, #20]
 802e2c0:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 802e2c4:	615a      	str	r2, [r3, #20]
  if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) == 0U)
 802e2c6:	6958      	ldr	r0, [r3, #20]
}
 802e2c8:	43c0      	mvns	r0, r0
 802e2ca:	0fc0      	lsrs	r0, r0, #31
 802e2cc:	4770      	bx	lr
 802e2ce:	bf00      	nop
 802e2d0:	58004000 	.word	0x58004000

0802e2d4 <FLASH_WaitForLastOperation>:
{
 802e2d4:	b570      	push	{r4, r5, r6, lr}
 802e2d6:	4605      	mov	r5, r0
  uint32_t tickstart = HAL_GetTick();
 802e2d8:	f7fe f9b4 	bl	802c644 <HAL_GetTick>
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 802e2dc:	4e12      	ldr	r6, [pc, #72]	; (802e328 <FLASH_WaitForLastOperation+0x54>)
  uint32_t tickstart = HAL_GetTick();
 802e2de:	4604      	mov	r4, r0
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 802e2e0:	6933      	ldr	r3, [r6, #16]
 802e2e2:	03d9      	lsls	r1, r3, #15
 802e2e4:	d413      	bmi.n	802e30e <FLASH_WaitForLastOperation+0x3a>
  error = FLASH->SR;
 802e2e6:	6933      	ldr	r3, [r6, #16]
  if ((error & FLASH_FLAG_EOP) != 0U)
 802e2e8:	07da      	lsls	r2, r3, #31
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 802e2ea:	bf44      	itt	mi
 802e2ec:	2201      	movmi	r2, #1
 802e2ee:	6132      	strmi	r2, [r6, #16]
  error &= FLASH_FLAG_SR_ERRORS;
 802e2f0:	f24c 32fa 	movw	r2, #50170	; 0xc3fa
  __HAL_FLASH_CLEAR_FLAG(error);
 802e2f4:	4013      	ands	r3, r2
 802e2f6:	d111      	bne.n	802e31c <FLASH_WaitForLastOperation+0x48>
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_CFGBSY))
 802e2f8:	4e0b      	ldr	r6, [pc, #44]	; (802e328 <FLASH_WaitForLastOperation+0x54>)
 802e2fa:	6930      	ldr	r0, [r6, #16]
 802e2fc:	f410 2080 	ands.w	r0, r0, #262144	; 0x40000
 802e300:	d00b      	beq.n	802e31a <FLASH_WaitForLastOperation+0x46>
    if ((HAL_GetTick() - tickstart) >= Timeout)
 802e302:	f7fe f99f 	bl	802c644 <HAL_GetTick>
 802e306:	1b00      	subs	r0, r0, r4
 802e308:	42a8      	cmp	r0, r5
 802e30a:	d3f6      	bcc.n	802e2fa <FLASH_WaitForLastOperation+0x26>
 802e30c:	e004      	b.n	802e318 <FLASH_WaitForLastOperation+0x44>
    if ((HAL_GetTick() - tickstart) >= Timeout)
 802e30e:	f7fe f999 	bl	802c644 <HAL_GetTick>
 802e312:	1b00      	subs	r0, r0, r4
 802e314:	42a8      	cmp	r0, r5
 802e316:	d3e3      	bcc.n	802e2e0 <FLASH_WaitForLastOperation+0xc>
      return HAL_TIMEOUT;
 802e318:	2003      	movs	r0, #3
}
 802e31a:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_FLASH_CLEAR_FLAG(error);
 802e31c:	4a02      	ldr	r2, [pc, #8]	; (802e328 <FLASH_WaitForLastOperation+0x54>)
 802e31e:	6113      	str	r3, [r2, #16]
    pFlash.ErrorCode = error;
 802e320:	4a02      	ldr	r2, [pc, #8]	; (802e32c <FLASH_WaitForLastOperation+0x58>)
    return HAL_ERROR;
 802e322:	2001      	movs	r0, #1
    pFlash.ErrorCode = error;
 802e324:	6053      	str	r3, [r2, #4]
    return HAL_ERROR;
 802e326:	e7f8      	b.n	802e31a <FLASH_WaitForLastOperation+0x46>
 802e328:	58004000 	.word	0x58004000
 802e32c:	20003f3c 	.word	0x20003f3c

0802e330 <HAL_FLASH_Program>:
{
 802e330:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __HAL_LOCK(&pFlash);
 802e334:	4c18      	ldr	r4, [pc, #96]	; (802e398 <HAL_FLASH_Program+0x68>)
{
 802e336:	4698      	mov	r8, r3
  __HAL_LOCK(&pFlash);
 802e338:	7823      	ldrb	r3, [r4, #0]
 802e33a:	2b01      	cmp	r3, #1
{
 802e33c:	4606      	mov	r6, r0
 802e33e:	460d      	mov	r5, r1
 802e340:	4617      	mov	r7, r2
  __HAL_LOCK(&pFlash);
 802e342:	d026      	beq.n	802e392 <HAL_FLASH_Program+0x62>
 802e344:	2301      	movs	r3, #1
 802e346:	7023      	strb	r3, [r4, #0]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e348:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 802e34c:	2300      	movs	r3, #0
 802e34e:	6063      	str	r3, [r4, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e350:	f7ff ffc0 	bl	802e2d4 <FLASH_WaitForLastOperation>
  if (status == HAL_OK)
 802e354:	b9a0      	cbnz	r0, 802e380 <HAL_FLASH_Program+0x50>
    if (TypeProgram == FLASH_TYPEPROGRAM_DOUBLEWORD)
 802e356:	2e01      	cmp	r6, #1
 802e358:	d116      	bne.n	802e388 <HAL_FLASH_Program+0x58>
  SET_BIT(FLASH->CR, FLASH_CR_PG);
 802e35a:	4a10      	ldr	r2, [pc, #64]	; (802e39c <HAL_FLASH_Program+0x6c>)
 802e35c:	6953      	ldr	r3, [r2, #20]
 802e35e:	f043 0301 	orr.w	r3, r3, #1
 802e362:	6153      	str	r3, [r2, #20]
  *(uint32_t *)Address = (uint32_t)Data;
 802e364:	602f      	str	r7, [r5, #0]
  __ASM volatile ("isb 0xF":::"memory");
 802e366:	f3bf 8f6f 	isb	sy
  *(uint32_t *)(Address + 4U) = (uint32_t)(Data >> 32U);
 802e36a:	f8c5 8004 	str.w	r8, [r5, #4]
    status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e36e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 802e372:	f7ff ffaf 	bl	802e2d4 <FLASH_WaitForLastOperation>
    CLEAR_BIT(FLASH->CR, TypeProgram);
 802e376:	4a09      	ldr	r2, [pc, #36]	; (802e39c <HAL_FLASH_Program+0x6c>)
 802e378:	6953      	ldr	r3, [r2, #20]
 802e37a:	ea23 0606 	bic.w	r6, r3, r6
 802e37e:	6156      	str	r6, [r2, #20]
  __HAL_UNLOCK(&pFlash);
 802e380:	2300      	movs	r3, #0
 802e382:	7023      	strb	r3, [r4, #0]
}
 802e384:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      FLASH_Program_Fast(Address, (uint32_t)Data);
 802e388:	4639      	mov	r1, r7
 802e38a:	4628      	mov	r0, r5
 802e38c:	f7ff ff6c 	bl	802e268 <FLASH_Program_Fast>
 802e390:	e7ed      	b.n	802e36e <HAL_FLASH_Program+0x3e>
  __HAL_LOCK(&pFlash);
 802e392:	2002      	movs	r0, #2
 802e394:	e7f6      	b.n	802e384 <HAL_FLASH_Program+0x54>
 802e396:	bf00      	nop
 802e398:	20003f3c 	.word	0x20003f3c
 802e39c:	58004000 	.word	0x58004000

0802e3a0 <FLASH_PageErase>:

  /* Proceed to erase the page */
#ifdef CORE_CM0PLUS
  MODIFY_REG(FLASH->C2CR, FLASH_CR_PNB, ((Page << FLASH_CR_PNB_Pos) | FLASH_CR_PER | FLASH_CR_STRT));
#else
  MODIFY_REG(FLASH->CR, FLASH_CR_PNB, ((Page << FLASH_CR_PNB_Pos) | FLASH_CR_PER | FLASH_CR_STRT));
 802e3a0:	4a05      	ldr	r2, [pc, #20]	; (802e3b8 <FLASH_PageErase+0x18>)
 802e3a2:	6953      	ldr	r3, [r2, #20]
 802e3a4:	f423 737e 	bic.w	r3, r3, #1016	; 0x3f8
 802e3a8:	ea43 00c0 	orr.w	r0, r3, r0, lsl #3
 802e3ac:	f440 3080 	orr.w	r0, r0, #65536	; 0x10000
 802e3b0:	f040 0002 	orr.w	r0, r0, #2
 802e3b4:	6150      	str	r0, [r2, #20]
#endif
}
 802e3b6:	4770      	bx	lr
 802e3b8:	58004000 	.word	0x58004000

0802e3bc <HAL_FLASHEx_Erase>:
{
 802e3bc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __HAL_LOCK(&pFlash);
 802e3c0:	4d23      	ldr	r5, [pc, #140]	; (802e450 <HAL_FLASHEx_Erase+0x94>)
 802e3c2:	782b      	ldrb	r3, [r5, #0]
 802e3c4:	2b01      	cmp	r3, #1
{
 802e3c6:	4606      	mov	r6, r0
 802e3c8:	4688      	mov	r8, r1
  __HAL_LOCK(&pFlash);
 802e3ca:	d03f      	beq.n	802e44c <HAL_FLASHEx_Erase+0x90>
 802e3cc:	2301      	movs	r3, #1
 802e3ce:	702b      	strb	r3, [r5, #0]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e3d0:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 802e3d4:	2300      	movs	r3, #0
 802e3d6:	606b      	str	r3, [r5, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e3d8:	f7ff ff7c 	bl	802e2d4 <FLASH_WaitForLastOperation>
  if (status == HAL_OK)
 802e3dc:	4604      	mov	r4, r0
 802e3de:	b988      	cbnz	r0, 802e404 <HAL_FLASHEx_Erase+0x48>
    if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 802e3e0:	6833      	ldr	r3, [r6, #0]
 802e3e2:	2b04      	cmp	r3, #4
 802e3e4:	d113      	bne.n	802e40e <HAL_FLASHEx_Erase+0x52>
  SET_BIT(FLASH->CR, (FLASH_CR_MER | FLASH_CR_STRT));
 802e3e6:	4a1b      	ldr	r2, [pc, #108]	; (802e454 <HAL_FLASHEx_Erase+0x98>)
 802e3e8:	6953      	ldr	r3, [r2, #20]
 802e3ea:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 802e3ee:	f043 0304 	orr.w	r3, r3, #4
 802e3f2:	6153      	str	r3, [r2, #20]
      status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e3f4:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 802e3f8:	f7ff ff6c 	bl	802e2d4 <FLASH_WaitForLastOperation>
 802e3fc:	4604      	mov	r4, r0
  * @retval None
  */
void FLASH_FlushCaches(void)
{
  /* Flush instruction cache  */
  if (READ_BIT(FLASH->ACR, FLASH_ACR_ICEN) == 1U)
 802e3fe:	4b15      	ldr	r3, [pc, #84]	; (802e454 <HAL_FLASHEx_Erase+0x98>)
 802e400:	681a      	ldr	r2, [r3, #0]
  }

#ifdef CORE_CM0PLUS
#else
  /* Flush data cache */
  if (READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) == 1U)
 802e402:	681b      	ldr	r3, [r3, #0]
  __HAL_UNLOCK(&pFlash);
 802e404:	2300      	movs	r3, #0
 802e406:	702b      	strb	r3, [r5, #0]
}
 802e408:	4620      	mov	r0, r4
 802e40a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      *PageError = 0xFFFFFFFFU;
 802e40e:	f04f 33ff 	mov.w	r3, #4294967295
 802e412:	f8c8 3000 	str.w	r3, [r8]
      for (index = pEraseInit->Page; index < (pEraseInit->Page + pEraseInit->NbPages); index++)
 802e416:	6877      	ldr	r7, [r6, #4]
 802e418:	e9d6 3201 	ldrd	r3, r2, [r6, #4]
 802e41c:	4413      	add	r3, r2
 802e41e:	42bb      	cmp	r3, r7
 802e420:	d90a      	bls.n	802e438 <HAL_FLASHEx_Erase+0x7c>
        FLASH_PageErase(index);
 802e422:	4638      	mov	r0, r7
 802e424:	f7ff ffbc 	bl	802e3a0 <FLASH_PageErase>
        status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e428:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 802e42c:	f7ff ff52 	bl	802e2d4 <FLASH_WaitForLastOperation>
        if (status != HAL_OK)
 802e430:	b150      	cbz	r0, 802e448 <HAL_FLASHEx_Erase+0x8c>
          *PageError = index;
 802e432:	f8c8 7000 	str.w	r7, [r8]
        status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e436:	4604      	mov	r4, r0
static void FLASH_AcknowledgePageErase(void)
{
#ifdef CORE_CM0PLUS
  CLEAR_BIT(FLASH->C2CR, (FLASH_CR_PER | FLASH_CR_PNB));
#else
  CLEAR_BIT(FLASH->CR, (FLASH_CR_PER | FLASH_CR_PNB));
 802e438:	4a06      	ldr	r2, [pc, #24]	; (802e454 <HAL_FLASHEx_Erase+0x98>)
 802e43a:	6953      	ldr	r3, [r2, #20]
 802e43c:	f423 737e 	bic.w	r3, r3, #1016	; 0x3f8
 802e440:	f023 0302 	bic.w	r3, r3, #2
 802e444:	6153      	str	r3, [r2, #20]
#endif
}
 802e446:	e7da      	b.n	802e3fe <HAL_FLASHEx_Erase+0x42>
      for (index = pEraseInit->Page; index < (pEraseInit->Page + pEraseInit->NbPages); index++)
 802e448:	3701      	adds	r7, #1
 802e44a:	e7e5      	b.n	802e418 <HAL_FLASHEx_Erase+0x5c>
  __HAL_LOCK(&pFlash);
 802e44c:	2402      	movs	r4, #2
 802e44e:	e7db      	b.n	802e408 <HAL_FLASHEx_Erase+0x4c>
 802e450:	20003f3c 	.word	0x20003f3c
 802e454:	58004000 	.word	0x58004000

0802e458 <HAL_FLASHEx_Erase_IT>:
{
 802e458:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(&pFlash);
 802e45a:	4c16      	ldr	r4, [pc, #88]	; (802e4b4 <HAL_FLASHEx_Erase_IT+0x5c>)
 802e45c:	7823      	ldrb	r3, [r4, #0]
 802e45e:	2b01      	cmp	r3, #1
{
 802e460:	4605      	mov	r5, r0
  __HAL_LOCK(&pFlash);
 802e462:	d025      	beq.n	802e4b0 <HAL_FLASHEx_Erase_IT+0x58>
 802e464:	2301      	movs	r3, #1
 802e466:	7023      	strb	r3, [r4, #0]
  pFlash.ProcedureOnGoing = pEraseInit->TypeErase;
 802e468:	6803      	ldr	r3, [r0, #0]
 802e46a:	60a3      	str	r3, [r4, #8]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 802e46c:	2600      	movs	r6, #0
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e46e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 802e472:	6066      	str	r6, [r4, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e474:	f7ff ff2e 	bl	802e2d4 <FLASH_WaitForLastOperation>
  if (status != HAL_OK)
 802e478:	4601      	mov	r1, r0
 802e47a:	b110      	cbz	r0, 802e482 <HAL_FLASHEx_Erase_IT+0x2a>
    __HAL_UNLOCK(&pFlash);
 802e47c:	7026      	strb	r6, [r4, #0]
}
 802e47e:	4608      	mov	r0, r1
 802e480:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP | FLASH_IT_OPERR);
 802e482:	4a0d      	ldr	r2, [pc, #52]	; (802e4b8 <HAL_FLASHEx_Erase_IT+0x60>)
 802e484:	6953      	ldr	r3, [r2, #20]
 802e486:	f043 7340 	orr.w	r3, r3, #50331648	; 0x3000000
 802e48a:	6153      	str	r3, [r2, #20]
    if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 802e48c:	682b      	ldr	r3, [r5, #0]
 802e48e:	2b04      	cmp	r3, #4
 802e490:	d107      	bne.n	802e4a2 <HAL_FLASHEx_Erase_IT+0x4a>
      pFlash.Page = 0;
 802e492:	6120      	str	r0, [r4, #16]
  SET_BIT(FLASH->CR, (FLASH_CR_MER | FLASH_CR_STRT));
 802e494:	6953      	ldr	r3, [r2, #20]
 802e496:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 802e49a:	f043 0304 	orr.w	r3, r3, #4
 802e49e:	6153      	str	r3, [r2, #20]
}
 802e4a0:	e7ed      	b.n	802e47e <HAL_FLASHEx_Erase_IT+0x26>
      pFlash.NbPagesToErase = pEraseInit->NbPages;
 802e4a2:	68ab      	ldr	r3, [r5, #8]
      pFlash.Page = pEraseInit->Page;
 802e4a4:	6868      	ldr	r0, [r5, #4]
      pFlash.NbPagesToErase = pEraseInit->NbPages;
 802e4a6:	6163      	str	r3, [r4, #20]
      pFlash.Page = pEraseInit->Page;
 802e4a8:	6120      	str	r0, [r4, #16]
      FLASH_PageErase(pEraseInit->Page);
 802e4aa:	f7ff ff79 	bl	802e3a0 <FLASH_PageErase>
 802e4ae:	e7e6      	b.n	802e47e <HAL_FLASHEx_Erase_IT+0x26>
  __HAL_LOCK(&pFlash);
 802e4b0:	2102      	movs	r1, #2
 802e4b2:	e7e4      	b.n	802e47e <HAL_FLASHEx_Erase_IT+0x26>
 802e4b4:	20003f3c 	.word	0x20003f3c
 802e4b8:	58004000 	.word	0x58004000

0802e4bc <HAL_GPIO_Init>:
  * @param GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 802e4bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

        /* Clear EXTI line configuration */
#ifdef CORE_CM0PLUS
        temp = EXTI->C2IMR1;
#else
        temp = EXTI->IMR1;
 802e4c0:	4c52      	ldr	r4, [pc, #328]	; (802e60c <HAL_GPIO_Init+0x150>)
  uint32_t position = 0x00u;
 802e4c2:	2300      	movs	r3, #0
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 802e4c4:	f04f 090f 	mov.w	r9, #15
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 802e4c8:	680a      	ldr	r2, [r1, #0]
 802e4ca:	fa32 f503 	lsrs.w	r5, r2, r3
 802e4ce:	d101      	bne.n	802e4d4 <HAL_GPIO_Init+0x18>
      }
    }

    position++;
  }
}
 802e4d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 802e4d4:	2501      	movs	r5, #1
 802e4d6:	fa05 f803 	lsl.w	r8, r5, r3
    if (iocurrent != 0x00u)
 802e4da:	ea18 0202 	ands.w	r2, r8, r2
 802e4de:	f000 808f 	beq.w	802e600 <HAL_GPIO_Init+0x144>
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 802e4e2:	684e      	ldr	r6, [r1, #4]
 802e4e4:	2703      	movs	r7, #3
 802e4e6:	f006 0503 	and.w	r5, r6, #3
 802e4ea:	ea4f 0e43 	mov.w	lr, r3, lsl #1
 802e4ee:	fa07 fc0e 	lsl.w	ip, r7, lr
 802e4f2:	1e6f      	subs	r7, r5, #1
 802e4f4:	2f01      	cmp	r7, #1
 802e4f6:	ea6f 0c0c 	mvn.w	ip, ip
 802e4fa:	d832      	bhi.n	802e562 <HAL_GPIO_Init+0xa6>
        temp = GPIOx->OSPEEDR;
 802e4fc:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 802e4fe:	ea07 0a0c 	and.w	sl, r7, ip
        temp |= (GPIO_Init->Speed << (position * 2U));
 802e502:	68cf      	ldr	r7, [r1, #12]
 802e504:	fa07 f70e 	lsl.w	r7, r7, lr
 802e508:	ea47 070a 	orr.w	r7, r7, sl
        GPIOx->OSPEEDR = temp;
 802e50c:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 802e50e:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 802e510:	ea27 0808 	bic.w	r8, r7, r8
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 802e514:	f3c6 1700 	ubfx	r7, r6, #4, #1
 802e518:	409f      	lsls	r7, r3
 802e51a:	ea47 0708 	orr.w	r7, r7, r8
        GPIOx->OTYPER = temp;
 802e51e:	6047      	str	r7, [r0, #4]
        temp = GPIOx->PUPDR;
 802e520:	68c7      	ldr	r7, [r0, #12]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 802e522:	ea07 080c 	and.w	r8, r7, ip
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 802e526:	688f      	ldr	r7, [r1, #8]
 802e528:	fa07 f70e 	lsl.w	r7, r7, lr
 802e52c:	ea47 0708 	orr.w	r7, r7, r8
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 802e530:	2d02      	cmp	r5, #2
        GPIOx->PUPDR = temp;
 802e532:	60c7      	str	r7, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 802e534:	d117      	bne.n	802e566 <HAL_GPIO_Init+0xaa>
        temp = GPIOx->AFR[position >> 3U];
 802e536:	ea4f 08d3 	mov.w	r8, r3, lsr #3
 802e53a:	eb00 0888 	add.w	r8, r0, r8, lsl #2
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 802e53e:	f003 0a07 	and.w	sl, r3, #7
        temp = GPIOx->AFR[position >> 3U];
 802e542:	f8d8 7020 	ldr.w	r7, [r8, #32]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 802e546:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 802e54a:	fa09 fb0a 	lsl.w	fp, r9, sl
 802e54e:	ea27 0b0b 	bic.w	fp, r7, fp
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 802e552:	690f      	ldr	r7, [r1, #16]
 802e554:	fa07 f70a 	lsl.w	r7, r7, sl
 802e558:	ea47 070b 	orr.w	r7, r7, fp
        GPIOx->AFR[position >> 3u] = temp;
 802e55c:	f8c8 7020 	str.w	r7, [r8, #32]
 802e560:	e001      	b.n	802e566 <HAL_GPIO_Init+0xaa>
      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 802e562:	2d03      	cmp	r5, #3
 802e564:	d1dc      	bne.n	802e520 <HAL_GPIO_Init+0x64>
      temp = GPIOx->MODER;
 802e566:	6807      	ldr	r7, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 802e568:	ea07 0c0c 	and.w	ip, r7, ip
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 802e56c:	fa05 f70e 	lsl.w	r7, r5, lr
 802e570:	ea47 070c 	orr.w	r7, r7, ip
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 802e574:	f416 3f40 	tst.w	r6, #196608	; 0x30000
      GPIOx->MODER = temp;
 802e578:	6007      	str	r7, [r0, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 802e57a:	d041      	beq.n	802e600 <HAL_GPIO_Init+0x144>
        temp = SYSCFG->EXTICR[position >> 2u];
 802e57c:	f023 0703 	bic.w	r7, r3, #3
 802e580:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
 802e584:	f507 3780 	add.w	r7, r7, #65536	; 0x10000
        temp &= ~(0x07uL << (4U * (position & 0x03U)));
 802e588:	f003 0c03 	and.w	ip, r3, #3
        temp = SYSCFG->EXTICR[position >> 2u];
 802e58c:	68bd      	ldr	r5, [r7, #8]
        temp &= ~(0x07uL << (4U * (position & 0x03U)));
 802e58e:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 802e592:	f04f 0e07 	mov.w	lr, #7
 802e596:	fa0e fe0c 	lsl.w	lr, lr, ip
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 802e59a:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
        temp &= ~(0x07uL << (4U * (position & 0x03U)));
 802e59e:	ea25 0e0e 	bic.w	lr, r5, lr
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 802e5a2:	d02f      	beq.n	802e604 <HAL_GPIO_Init+0x148>
 802e5a4:	4d1a      	ldr	r5, [pc, #104]	; (802e610 <HAL_GPIO_Init+0x154>)
 802e5a6:	42a8      	cmp	r0, r5
 802e5a8:	d02e      	beq.n	802e608 <HAL_GPIO_Init+0x14c>
 802e5aa:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 802e5ae:	42a8      	cmp	r0, r5
 802e5b0:	bf0c      	ite	eq
 802e5b2:	2502      	moveq	r5, #2
 802e5b4:	2507      	movne	r5, #7
 802e5b6:	fa05 f50c 	lsl.w	r5, r5, ip
 802e5ba:	ea45 050e 	orr.w	r5, r5, lr
        SYSCFG->EXTICR[position >> 2u] = temp;
 802e5be:	60bd      	str	r5, [r7, #8]
        temp = EXTI->IMR1;
 802e5c0:	f8d4 5080 	ldr.w	r5, [r4, #128]	; 0x80
        temp &= ~(iocurrent);
 802e5c4:	43d7      	mvns	r7, r2
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00u)
 802e5c6:	f416 3f80 	tst.w	r6, #65536	; 0x10000
        temp &= ~(iocurrent);
 802e5ca:	bf0c      	ite	eq
 802e5cc:	403d      	andeq	r5, r7
          temp |= iocurrent;
 802e5ce:	4315      	orrne	r5, r2
        EXTI->IMR1 = temp;
 802e5d0:	f8c4 5080 	str.w	r5, [r4, #128]	; 0x80
        temp = EXTI->EMR1;
 802e5d4:	f8d4 5084 	ldr.w	r5, [r4, #132]	; 0x84
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
 802e5d8:	f416 3f00 	tst.w	r6, #131072	; 0x20000
        temp &= ~(iocurrent);
 802e5dc:	bf0c      	ite	eq
 802e5de:	403d      	andeq	r5, r7
          temp |= iocurrent;
 802e5e0:	4315      	orrne	r5, r2
        EXTI->EMR1 = temp;
 802e5e2:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
        temp = EXTI->RTSR1;
 802e5e6:	6825      	ldr	r5, [r4, #0]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
 802e5e8:	f416 1f80 	tst.w	r6, #1048576	; 0x100000
        temp &= ~(iocurrent);
 802e5ec:	bf0c      	ite	eq
 802e5ee:	403d      	andeq	r5, r7
          temp |= iocurrent;
 802e5f0:	4315      	orrne	r5, r2
        EXTI->RTSR1 = temp;
 802e5f2:	6025      	str	r5, [r4, #0]
        temp = EXTI->FTSR1;
 802e5f4:	6865      	ldr	r5, [r4, #4]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
 802e5f6:	02b6      	lsls	r6, r6, #10
        temp &= ~(iocurrent);
 802e5f8:	bf54      	ite	pl
 802e5fa:	403d      	andpl	r5, r7
          temp |= iocurrent;
 802e5fc:	4315      	orrmi	r5, r2
        EXTI->FTSR1 = temp;
 802e5fe:	6065      	str	r5, [r4, #4]
    position++;
 802e600:	3301      	adds	r3, #1
 802e602:	e761      	b.n	802e4c8 <HAL_GPIO_Init+0xc>
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 802e604:	2500      	movs	r5, #0
 802e606:	e7d6      	b.n	802e5b6 <HAL_GPIO_Init+0xfa>
 802e608:	2501      	movs	r5, #1
 802e60a:	e7d4      	b.n	802e5b6 <HAL_GPIO_Init+0xfa>
 802e60c:	58000800 	.word	0x58000800
 802e610:	48000400 	.word	0x48000400

0802e614 <HAL_GPIO_DeInit>:
        /* Clear EXTI line configuration */
#ifdef CORE_CM0PLUS
        EXTI->C2IMR1 &= ~(iocurrent);
        EXTI->C2EMR1 &= ~(iocurrent);
#else
        EXTI->IMR1 &= ~(iocurrent);
 802e614:	4a37      	ldr	r2, [pc, #220]	; (802e6f4 <HAL_GPIO_DeInit+0xe0>)
{
 802e616:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t position = 0x00u;
 802e61a:	2300      	movs	r3, #0
    iocurrent = (GPIO_Pin) & (1uL << position);
 802e61c:	f04f 0a01 	mov.w	sl, #1
      tmp &= (0x07uL << (4U * (position & 0x03U)));
 802e620:	f04f 0b07 	mov.w	fp, #7
      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
 802e624:	f04f 090f 	mov.w	r9, #15
  while ((GPIO_Pin >> position) != 0x00u)
 802e628:	fa31 f403 	lsrs.w	r4, r1, r3
 802e62c:	d101      	bne.n	802e632 <HAL_GPIO_DeInit+0x1e>
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
    }

    position++;
  }
}
 802e62e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Pin) & (1uL << position);
 802e632:	fa0a fc03 	lsl.w	ip, sl, r3
    if (iocurrent != 0x00u)
 802e636:	ea1c 0601 	ands.w	r6, ip, r1
 802e63a:	d054      	beq.n	802e6e6 <HAL_GPIO_DeInit+0xd2>
      tmp = SYSCFG->EXTICR[position >> 2u];
 802e63c:	f023 0403 	bic.w	r4, r3, #3
 802e640:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 802e644:	f504 3480 	add.w	r4, r4, #65536	; 0x10000
      tmp &= (0x07uL << (4U * (position & 0x03U)));
 802e648:	f003 0703 	and.w	r7, r3, #3
      tmp = SYSCFG->EXTICR[position >> 2u];
 802e64c:	68a5      	ldr	r5, [r4, #8]
      tmp &= (0x07uL << (4U * (position & 0x03U)));
 802e64e:	00bf      	lsls	r7, r7, #2
 802e650:	fa0b f807 	lsl.w	r8, fp, r7
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 802e654:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
      tmp &= (0x07uL << (4U * (position & 0x03U)));
 802e658:	ea08 0e05 	and.w	lr, r8, r5
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 802e65c:	d045      	beq.n	802e6ea <HAL_GPIO_DeInit+0xd6>
 802e65e:	4d26      	ldr	r5, [pc, #152]	; (802e6f8 <HAL_GPIO_DeInit+0xe4>)
 802e660:	42a8      	cmp	r0, r5
 802e662:	d044      	beq.n	802e6ee <HAL_GPIO_DeInit+0xda>
 802e664:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 802e668:	42a8      	cmp	r0, r5
 802e66a:	bf0c      	ite	eq
 802e66c:	2502      	moveq	r5, #2
 802e66e:	2507      	movne	r5, #7
 802e670:	40bd      	lsls	r5, r7
 802e672:	4575      	cmp	r5, lr
 802e674:	d117      	bne.n	802e6a6 <HAL_GPIO_DeInit+0x92>
        EXTI->IMR1 &= ~(iocurrent);
 802e676:	f8d2 5080 	ldr.w	r5, [r2, #128]	; 0x80
 802e67a:	ea25 0506 	bic.w	r5, r5, r6
 802e67e:	f8c2 5080 	str.w	r5, [r2, #128]	; 0x80
        EXTI->EMR1 &= ~(iocurrent);
 802e682:	f8d2 5084 	ldr.w	r5, [r2, #132]	; 0x84
 802e686:	ea25 0506 	bic.w	r5, r5, r6
 802e68a:	f8c2 5084 	str.w	r5, [r2, #132]	; 0x84
        EXTI->RTSR1 &= ~(iocurrent);
 802e68e:	6815      	ldr	r5, [r2, #0]
 802e690:	ea25 0506 	bic.w	r5, r5, r6
 802e694:	6015      	str	r5, [r2, #0]
        EXTI->FTSR1 &= ~(iocurrent);
 802e696:	6855      	ldr	r5, [r2, #4]
 802e698:	ea25 0606 	bic.w	r6, r5, r6
 802e69c:	6056      	str	r6, [r2, #4]
        SYSCFG->EXTICR[position >> 2u] &= ~tmp;
 802e69e:	68a5      	ldr	r5, [r4, #8]
 802e6a0:	ea25 0508 	bic.w	r5, r5, r8
 802e6a4:	60a5      	str	r5, [r4, #8]
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
 802e6a6:	6805      	ldr	r5, [r0, #0]
 802e6a8:	2603      	movs	r6, #3
 802e6aa:	005c      	lsls	r4, r3, #1
 802e6ac:	fa06 f404 	lsl.w	r4, r6, r4
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
 802e6b0:	fa23 f606 	lsr.w	r6, r3, r6
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
 802e6b4:	4325      	orrs	r5, r4
 802e6b6:	eb00 0686 	add.w	r6, r0, r6, lsl #2
 802e6ba:	6005      	str	r5, [r0, #0]
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
 802e6bc:	f003 0507 	and.w	r5, r3, #7
 802e6c0:	6a37      	ldr	r7, [r6, #32]
 802e6c2:	00ad      	lsls	r5, r5, #2
 802e6c4:	fa09 f505 	lsl.w	r5, r9, r5
 802e6c8:	ea27 0505 	bic.w	r5, r7, r5
 802e6cc:	6235      	str	r5, [r6, #32]
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 802e6ce:	6885      	ldr	r5, [r0, #8]
 802e6d0:	ea25 0504 	bic.w	r5, r5, r4
 802e6d4:	6085      	str	r5, [r0, #8]
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
 802e6d6:	6845      	ldr	r5, [r0, #4]
 802e6d8:	ea25 050c 	bic.w	r5, r5, ip
 802e6dc:	6045      	str	r5, [r0, #4]
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 802e6de:	68c5      	ldr	r5, [r0, #12]
 802e6e0:	ea25 0404 	bic.w	r4, r5, r4
 802e6e4:	60c4      	str	r4, [r0, #12]
    position++;
 802e6e6:	3301      	adds	r3, #1
 802e6e8:	e79e      	b.n	802e628 <HAL_GPIO_DeInit+0x14>
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 802e6ea:	2500      	movs	r5, #0
 802e6ec:	e7c0      	b.n	802e670 <HAL_GPIO_DeInit+0x5c>
 802e6ee:	2501      	movs	r5, #1
 802e6f0:	e7be      	b.n	802e670 <HAL_GPIO_DeInit+0x5c>
 802e6f2:	bf00      	nop
 802e6f4:	58000800 	.word	0x58000800
 802e6f8:	48000400 	.word	0x48000400

0802e6fc <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 802e6fc:	b10a      	cbz	r2, 802e702 <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 802e6fe:	6181      	str	r1, [r0, #24]
 802e700:	4770      	bx	lr
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 802e702:	6281      	str	r1, [r0, #40]	; 0x28
  }
}
 802e704:	4770      	bx	lr

0802e706 <HAL_GPIO_TogglePin>:

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
 802e706:	6943      	ldr	r3, [r0, #20]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
 802e708:	ea01 0203 	and.w	r2, r1, r3
 802e70c:	ea21 0103 	bic.w	r1, r1, r3
 802e710:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 802e714:	6181      	str	r1, [r0, #24]
}
 802e716:	4770      	bx	lr

0802e718 <HAL_GPIO_EXTI_IRQHandler>:
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
  /* EXTI line interrupt detected */
  if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)
 802e718:	4a04      	ldr	r2, [pc, #16]	; (802e72c <HAL_GPIO_EXTI_IRQHandler+0x14>)
 802e71a:	68d1      	ldr	r1, [r2, #12]
 802e71c:	4201      	tst	r1, r0
{
 802e71e:	b508      	push	{r3, lr}
  if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)
 802e720:	d002      	beq.n	802e728 <HAL_GPIO_EXTI_IRQHandler+0x10>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 802e722:	60d0      	str	r0, [r2, #12]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 802e724:	f7fe fc26 	bl	802cf74 <HAL_GPIO_EXTI_Callback>
  }
}
 802e728:	bd08      	pop	{r3, pc}
 802e72a:	bf00      	nop
 802e72c:	58000800 	.word	0x58000800

0802e730 <HAL_PWR_EnableBkUpAccess>:
  *         backup domain.
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
 802e730:	4a02      	ldr	r2, [pc, #8]	; (802e73c <HAL_PWR_EnableBkUpAccess+0xc>)
 802e732:	6813      	ldr	r3, [r2, #0]
 802e734:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 802e738:	6013      	str	r3, [r2, #0]
}
 802e73a:	4770      	bx	lr
 802e73c:	58000400 	.word	0x58000400

0802e740 <HAL_PWR_EnterSLEEPMode>:
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR(Regulator));
  assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));

  /* Set Regulator parameter */
  if (Regulator == PWR_MAINREGULATOR_ON)
 802e740:	4b0d      	ldr	r3, [pc, #52]	; (802e778 <HAL_PWR_EnterSLEEPMode+0x38>)
{
 802e742:	b510      	push	{r4, lr}
  {
    /* If in low-power run mode at this point, exit it */
    if (HAL_IS_BIT_SET(PWR->SR2, (PWR_SR2_REGLPF)))
 802e744:	695b      	ldr	r3, [r3, #20]
{
 802e746:	460c      	mov	r4, r1
  if (Regulator == PWR_MAINREGULATOR_ON)
 802e748:	b928      	cbnz	r0, 802e756 <HAL_PWR_EnterSLEEPMode+0x16>
    if (HAL_IS_BIT_SET(PWR->SR2, (PWR_SR2_REGLPF)))
 802e74a:	059a      	lsls	r2, r3, #22
 802e74c:	d507      	bpl.n	802e75e <HAL_PWR_EnterSLEEPMode+0x1e>
    {
      if (HAL_PWREx_DisableLowPowerRunMode() != HAL_OK)
 802e74e:	f000 f827 	bl	802e7a0 <HAL_PWREx_DisableLowPowerRunMode>
 802e752:	b120      	cbz	r0, 802e75e <HAL_PWR_EnterSLEEPMode+0x1e>
    /* Request Wait For Event */
    __SEV();
    __WFE();
    __WFE();
  }
}
 802e754:	bd10      	pop	{r4, pc}
    if (HAL_IS_BIT_CLR(PWR->SR2, (PWR_SR2_REGLPF)))
 802e756:	059b      	lsls	r3, r3, #22
 802e758:	d401      	bmi.n	802e75e <HAL_PWR_EnterSLEEPMode+0x1e>
      HAL_PWREx_EnableLowPowerRunMode();
 802e75a:	f000 f819 	bl	802e790 <HAL_PWREx_EnableLowPowerRunMode>
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 802e75e:	4a07      	ldr	r2, [pc, #28]	; (802e77c <HAL_PWR_EnterSLEEPMode+0x3c>)
 802e760:	6913      	ldr	r3, [r2, #16]
  if (SLEEPEntry == PWR_SLEEPENTRY_WFI)
 802e762:	2c01      	cmp	r4, #1
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 802e764:	f023 0304 	bic.w	r3, r3, #4
 802e768:	6113      	str	r3, [r2, #16]
  if (SLEEPEntry == PWR_SLEEPENTRY_WFI)
 802e76a:	d101      	bne.n	802e770 <HAL_PWR_EnterSLEEPMode+0x30>
    __WFI();
 802e76c:	bf30      	wfi
 802e76e:	e7f1      	b.n	802e754 <HAL_PWR_EnterSLEEPMode+0x14>
    __SEV();
 802e770:	bf40      	sev
    __WFE();
 802e772:	bf20      	wfe
    __WFE();
 802e774:	bf20      	wfe
 802e776:	e7ed      	b.n	802e754 <HAL_PWR_EnterSLEEPMode+0x14>
 802e778:	58000400 	.word	0x58000400
 802e77c:	e000ed00 	.word	0xe000ed00

0802e780 <HAL_PWREx_GetVoltageRange>:
  * @brief Return Voltage Scaling Range.
  * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_SCALE1 or PWPWR_REGULATOR_VOLTAGE_SCALE2)
  */
uint32_t HAL_PWREx_GetVoltageRange(void)
{
  return (PWR->CR1 & PWR_CR1_VOS);
 802e780:	4b02      	ldr	r3, [pc, #8]	; (802e78c <HAL_PWREx_GetVoltageRange+0xc>)
 802e782:	6818      	ldr	r0, [r3, #0]
}
 802e784:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
 802e788:	4770      	bx	lr
 802e78a:	bf00      	nop
 802e78c:	58000400 	.word	0x58000400

0802e790 <HAL_PWREx_EnableLowPowerRunMode>:
  * @retval None
  */
void HAL_PWREx_EnableLowPowerRunMode(void)
{
  /* Set Regulator parameter */
  SET_BIT(PWR->CR1, PWR_CR1_LPR);
 802e790:	4a02      	ldr	r2, [pc, #8]	; (802e79c <HAL_PWREx_EnableLowPowerRunMode+0xc>)
 802e792:	6813      	ldr	r3, [r2, #0]
 802e794:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 802e798:	6013      	str	r3, [r2, #0]
}
 802e79a:	4770      	bx	lr
 802e79c:	58000400 	.word	0x58000400

0802e7a0 <HAL_PWREx_DisableLowPowerRunMode>:
HAL_StatusTypeDef HAL_PWREx_DisableLowPowerRunMode(void)
{
  uint32_t wait_loop_index;

  /* Clear LPR bit */
  CLEAR_BIT(PWR->CR1, PWR_CR1_LPR);
 802e7a0:	4a0d      	ldr	r2, [pc, #52]	; (802e7d8 <HAL_PWREx_DisableLowPowerRunMode+0x38>)
 802e7a2:	6813      	ldr	r3, [r2, #0]
 802e7a4:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 802e7a8:	6013      	str	r3, [r2, #0]

  /* Wait until REGLPF is reset */
  wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000UL);
 802e7aa:	4b0c      	ldr	r3, [pc, #48]	; (802e7dc <HAL_PWREx_DisableLowPowerRunMode+0x3c>)
 802e7ac:	6819      	ldr	r1, [r3, #0]
 802e7ae:	2332      	movs	r3, #50	; 0x32
 802e7b0:	434b      	muls	r3, r1
 802e7b2:	490b      	ldr	r1, [pc, #44]	; (802e7e0 <HAL_PWREx_DisableLowPowerRunMode+0x40>)
 802e7b4:	fbb3 f3f1 	udiv	r3, r3, r1
  while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF)) && (wait_loop_index != 0U))
 802e7b8:	4611      	mov	r1, r2
 802e7ba:	6950      	ldr	r0, [r2, #20]
 802e7bc:	f410 7f00 	tst.w	r0, #512	; 0x200
 802e7c0:	d000      	beq.n	802e7c4 <HAL_PWREx_DisableLowPowerRunMode+0x24>
 802e7c2:	b933      	cbnz	r3, 802e7d2 <HAL_PWREx_DisableLowPowerRunMode+0x32>
  {
    wait_loop_index--;
  }
  if (HAL_IS_BIT_SET(PWR->SR2, (PWR_SR2_REGLPF)))
 802e7c4:	694b      	ldr	r3, [r1, #20]
  {
    return HAL_TIMEOUT;
 802e7c6:	f413 7f00 	tst.w	r3, #512	; 0x200
  }

  return HAL_OK;
}
 802e7ca:	bf14      	ite	ne
 802e7cc:	2003      	movne	r0, #3
 802e7ce:	2000      	moveq	r0, #0
 802e7d0:	4770      	bx	lr
    wait_loop_index--;
 802e7d2:	3b01      	subs	r3, #1
 802e7d4:	e7f1      	b.n	802e7ba <HAL_PWREx_DisableLowPowerRunMode+0x1a>
 802e7d6:	bf00      	nop
 802e7d8:	58000400 	.word	0x58000400
 802e7dc:	2000344c 	.word	0x2000344c
 802e7e0:	000f4240 	.word	0x000f4240

0802e7e4 <HAL_PWREx_EnterSTOP2Mode>:
#ifdef CORE_CM0PLUS
  /* Set Stop mode 2 */
  MODIFY_REG(PWR->C2CR1, PWR_C2CR1_LPMS, PWR_LOWPOWERMODE_STOP2);
#else
  /* Set Stop mode 2 */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_LOWPOWERMODE_STOP2);
 802e7e4:	4a0b      	ldr	r2, [pc, #44]	; (802e814 <HAL_PWREx_EnterSTOP2Mode+0x30>)
 802e7e6:	6813      	ldr	r3, [r2, #0]
 802e7e8:	f023 0307 	bic.w	r3, r3, #7
 802e7ec:	f043 0302 	orr.w	r3, r3, #2
 802e7f0:	6013      	str	r3, [r2, #0]
#endif

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 802e7f2:	4b09      	ldr	r3, [pc, #36]	; (802e818 <HAL_PWREx_EnterSTOP2Mode+0x34>)
 802e7f4:	691a      	ldr	r2, [r3, #16]

  /* Select Stop mode entry --------------------------------------------------*/
  if (STOPEntry == PWR_STOPENTRY_WFI)
 802e7f6:	2801      	cmp	r0, #1
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 802e7f8:	f042 0204 	orr.w	r2, r2, #4
 802e7fc:	611a      	str	r2, [r3, #16]
  if (STOPEntry == PWR_STOPENTRY_WFI)
 802e7fe:	d105      	bne.n	802e80c <HAL_PWREx_EnterSTOP2Mode+0x28>
  {
    /* Request Wait For Interrupt */
    __WFI();
 802e800:	bf30      	wfi
    __WFE();
    __WFE();
  }

  /* Reset SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 802e802:	691a      	ldr	r2, [r3, #16]
 802e804:	f022 0204 	bic.w	r2, r2, #4
 802e808:	611a      	str	r2, [r3, #16]
}
 802e80a:	4770      	bx	lr
    __SEV();
 802e80c:	bf40      	sev
    __WFE();
 802e80e:	bf20      	wfe
    __WFE();
 802e810:	bf20      	wfe
 802e812:	e7f6      	b.n	802e802 <HAL_PWREx_EnterSTOP2Mode+0x1e>
 802e814:	58000400 	.word	0x58000400
 802e818:	e000ed00 	.word	0xe000ed00

0802e81c <LL_RCC_HSE_IsReady>:
  return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
 802e81c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802e820:	6818      	ldr	r0, [r3, #0]
}
 802e822:	f3c0 4040 	ubfx	r0, r0, #17, #1
 802e826:	4770      	bx	lr

0802e828 <LL_RCC_HSI_IsReady>:
  return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
 802e828:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802e82c:	6818      	ldr	r0, [r3, #0]
}
 802e82e:	f3c0 2080 	ubfx	r0, r0, #10, #1
 802e832:	4770      	bx	lr

0802e834 <LL_RCC_MSI_IsReady>:
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRDY) == (RCC_CR_MSIRDY)) ? 1UL : 0UL);
 802e834:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802e838:	6818      	ldr	r0, [r3, #0]
}
 802e83a:	f3c0 0040 	ubfx	r0, r0, #1, #1
 802e83e:	4770      	bx	lr

0802e840 <LL_RCC_MSI_SetCalibTrimming>:
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_MSITRIM, Value << RCC_ICSCR_MSITRIM_Pos);
 802e840:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 802e844:	6853      	ldr	r3, [r2, #4]
 802e846:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 802e84a:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 802e84e:	6053      	str	r3, [r2, #4]
}
 802e850:	4770      	bx	lr

0802e852 <LL_RCC_PLL_IsReady>:
  * @rmtoll CR           PLLRDY        LL_RCC_PLL_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_IsReady(void)
{
  return ((READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY)) ? 1UL : 0UL);
 802e852:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802e856:	6818      	ldr	r0, [r3, #0]
}
 802e858:	f3c0 6040 	ubfx	r0, r0, #25, #1
 802e85c:	4770      	bx	lr
	...

0802e860 <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  MSI_Range  MSI range value from @ref RCC_MSIRANGE_0 to @ref RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t MSI_Range)
{
 802e860:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  return (uint32_t)(READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPRE) << 4);
 802e862:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
  uint32_t flash_clksrcfreq;
  uint32_t msifreq;

  /* MSI frequency range in Hz */
  msifreq           = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSIRANGESEL_RUN, MSI_Range);
  flash_clksrcfreq  = __LL_RCC_CALC_HCLK3_FREQ(msifreq, LL_RCC_GetAHB3Prescaler());
 802e866:	4a2c      	ldr	r2, [pc, #176]	; (802e918 <RCC_SetFlashLatencyFromMSIRange+0xb8>)
 802e868:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
  msifreq           = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSIRANGESEL_RUN, MSI_Range);
 802e86c:	f3c0 1003 	ubfx	r0, r0, #4, #4
  flash_clksrcfreq  = __LL_RCC_CALC_HCLK3_FREQ(msifreq, LL_RCC_GetAHB3Prescaler());
 802e870:	f003 030f 	and.w	r3, r3, #15
 802e874:	f852 4020 	ldr.w	r4, [r2, r0, lsl #2]
 802e878:	4a28      	ldr	r2, [pc, #160]	; (802e91c <RCC_SetFlashLatencyFromMSIRange+0xbc>)
 802e87a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 802e87e:	fbb4 f4f3 	udiv	r4, r4, r3

  return RCC_SetFlashLatency((flash_clksrcfreq / MEGA_HZ), HAL_PWREx_GetVoltageRange());
 802e882:	f7ff ff7d 	bl	802e780 <HAL_PWREx_GetVoltageRange>

  /* Flash Clock source (HCLK3) range in MHz for VCORE range2 */
  const uint16_t FLASH_CLK_SRC_RANGE_VOS2[] = {6, 12, 16};

  /* Flash Latency range */
  const uint32_t FLASH_LATENCY_RANGE[] = {FLASH_LATENCY_0, FLASH_LATENCY_1, FLASH_LATENCY_2};
 802e886:	4b26      	ldr	r3, [pc, #152]	; (802e920 <RCC_SetFlashLatencyFromMSIRange+0xc0>)
  return RCC_SetFlashLatency((flash_clksrcfreq / MEGA_HZ), HAL_PWREx_GetVoltageRange());
 802e888:	4605      	mov	r5, r0
  const uint32_t FLASH_LATENCY_RANGE[] = {FLASH_LATENCY_0, FLASH_LATENCY_1, FLASH_LATENCY_2};
 802e88a:	e893 0007 	ldmia.w	r3, {r0, r1, r2}

  uint32_t latency   = FLASH_LATENCY_0;  /* default value 0WS */
  uint32_t tickstart;

  if (VCORE_Voltage == PWR_REGULATOR_VOLTAGE_SCALE1)
 802e88e:	f5b5 7f00 	cmp.w	r5, #512	; 0x200
  const uint32_t FLASH_LATENCY_RANGE[] = {FLASH_LATENCY_0, FLASH_LATENCY_1, FLASH_LATENCY_2};
 802e892:	ab04      	add	r3, sp, #16
 802e894:	e903 0007 	stmdb	r3, {r0, r1, r2}
  if (VCORE_Voltage == PWR_REGULATOR_VOLTAGE_SCALE1)
 802e898:	d010      	beq.n	802e8bc <RCC_SetFlashLatencyFromMSIRange+0x5c>
  }
  else  /* PWR_REGULATOR_VOLTAGE_SCALE2 */
  {
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
    {
      if (Flash_ClkSrcFreq <= FLASH_CLK_SRC_RANGE_VOS2[index])
 802e89a:	4b22      	ldr	r3, [pc, #136]	; (802e924 <RCC_SetFlashLatencyFromMSIRange+0xc4>)
 802e89c:	429c      	cmp	r4, r3
 802e89e:	d318      	bcc.n	802e8d2 <RCC_SetFlashLatencyFromMSIRange+0x72>
 802e8a0:	f503 03b7 	add.w	r3, r3, #5996544	; 0x5b8000
 802e8a4:	f603 537f 	addw	r3, r3, #3455	; 0xd7f
 802e8a8:	429c      	cmp	r4, r3
 802e8aa:	d929      	bls.n	802e900 <RCC_SetFlashLatencyFromMSIRange+0xa0>
 802e8ac:	f503 1374 	add.w	r3, r3, #3997696	; 0x3d0000
 802e8b0:	f503 6310 	add.w	r3, r3, #2304	; 0x900
      if (Flash_ClkSrcFreq <= FLASH_CLK_SRC_RANGE_VOS1[index])
 802e8b4:	429c      	cmp	r4, r3
 802e8b6:	d825      	bhi.n	802e904 <RCC_SetFlashLatencyFromMSIRange+0xa4>
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
 802e8b8:	2302      	movs	r3, #2
 802e8ba:	e00b      	b.n	802e8d4 <RCC_SetFlashLatencyFromMSIRange+0x74>
      if (Flash_ClkSrcFreq <= FLASH_CLK_SRC_RANGE_VOS1[index])
 802e8bc:	4b1a      	ldr	r3, [pc, #104]	; (802e928 <RCC_SetFlashLatencyFromMSIRange+0xc8>)
 802e8be:	429c      	cmp	r4, r3
 802e8c0:	d907      	bls.n	802e8d2 <RCC_SetFlashLatencyFromMSIRange+0x72>
 802e8c2:	4b1a      	ldr	r3, [pc, #104]	; (802e92c <RCC_SetFlashLatencyFromMSIRange+0xcc>)
 802e8c4:	429c      	cmp	r4, r3
 802e8c6:	d91b      	bls.n	802e900 <RCC_SetFlashLatencyFromMSIRange+0xa0>
 802e8c8:	f503 0337 	add.w	r3, r3, #11993088	; 0xb70000
 802e8cc:	f503 53d8 	add.w	r3, r3, #6912	; 0x1b00
 802e8d0:	e7f0      	b.n	802e8b4 <RCC_SetFlashLatencyFromMSIRange+0x54>
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
 802e8d2:	2300      	movs	r3, #0
      {
        latency = FLASH_LATENCY_RANGE[index];
 802e8d4:	aa04      	add	r2, sp, #16
 802e8d6:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 802e8da:	f853 4c0c 	ldr.w	r4, [r3, #-12]
        break;
      }
    }
  }

  __HAL_FLASH_SET_LATENCY(latency);
 802e8de:	4d14      	ldr	r5, [pc, #80]	; (802e930 <RCC_SetFlashLatencyFromMSIRange+0xd0>)
 802e8e0:	682b      	ldr	r3, [r5, #0]
 802e8e2:	f023 0307 	bic.w	r3, r3, #7
 802e8e6:	4323      	orrs	r3, r4
 802e8e8:	602b      	str	r3, [r5, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 802e8ea:	f7fd feab 	bl	802c644 <HAL_GetTick>
 802e8ee:	4606      	mov	r6, r0

  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  while (__HAL_FLASH_GET_LATENCY() != latency)
 802e8f0:	682b      	ldr	r3, [r5, #0]
 802e8f2:	f003 0307 	and.w	r3, r3, #7
 802e8f6:	429c      	cmp	r4, r3
 802e8f8:	d106      	bne.n	802e908 <RCC_SetFlashLatencyFromMSIRange+0xa8>
    if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
    {
      return HAL_TIMEOUT;
    }
  }
  return HAL_OK;
 802e8fa:	2000      	movs	r0, #0
}
 802e8fc:	b004      	add	sp, #16
 802e8fe:	bd70      	pop	{r4, r5, r6, pc}
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
 802e900:	2301      	movs	r3, #1
 802e902:	e7e7      	b.n	802e8d4 <RCC_SetFlashLatencyFromMSIRange+0x74>
  uint32_t latency   = FLASH_LATENCY_0;  /* default value 0WS */
 802e904:	2400      	movs	r4, #0
 802e906:	e7ea      	b.n	802e8de <RCC_SetFlashLatencyFromMSIRange+0x7e>
    if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 802e908:	f7fd fe9c 	bl	802c644 <HAL_GetTick>
 802e90c:	1b80      	subs	r0, r0, r6
 802e90e:	2802      	cmp	r0, #2
 802e910:	d9ee      	bls.n	802e8f0 <RCC_SetFlashLatencyFromMSIRange+0x90>
      return HAL_TIMEOUT;
 802e912:	2003      	movs	r0, #3
 802e914:	e7f2      	b.n	802e8fc <RCC_SetFlashLatencyFromMSIRange+0x9c>
 802e916:	bf00      	nop
 802e918:	0803b9c4 	.word	0x0803b9c4
 802e91c:	0803ba04 	.word	0x0803ba04
 802e920:	0803ba64 	.word	0x0803ba64
 802e924:	006acfc0 	.word	0x006acfc0
 802e928:	0121eabf 	.word	0x0121eabf
 802e92c:	0234933f 	.word	0x0234933f
 802e930:	58004000 	.word	0x58004000

0802e934 <HAL_RCC_GetSysClockFreq>:
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 802e934:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
{
 802e938:	b510      	push	{r4, lr}
 802e93a:	689a      	ldr	r2, [r3, #8]
  *         @arg @ref LL_RCC_PLLSOURCE_HSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetMainSource(void)
{
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 802e93c:	68d9      	ldr	r1, [r3, #12]
  if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 802e93e:	f012 020c 	ands.w	r2, r2, #12
 802e942:	d005      	beq.n	802e950 <HAL_RCC_GetSysClockFreq+0x1c>
 802e944:	2a0c      	cmp	r2, #12
 802e946:	d14a      	bne.n	802e9de <HAL_RCC_GetSysClockFreq+0xaa>
 802e948:	f001 0303 	and.w	r3, r1, #3
      ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pllsource == RCC_PLLSOURCE_MSI)))
 802e94c:	2b01      	cmp	r3, #1
 802e94e:	d150      	bne.n	802e9f2 <HAL_RCC_GetSysClockFreq+0xbe>
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == (RCC_CR_MSIRGSEL)) ? 1UL : 0UL);
 802e950:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 802e954:	482b      	ldr	r0, [pc, #172]	; (802ea04 <HAL_RCC_GetSysClockFreq+0xd0>)
 802e956:	680b      	ldr	r3, [r1, #0]
 802e958:	f013 0308 	ands.w	r3, r3, #8
 802e95c:	d006      	beq.n	802e96c <HAL_RCC_GetSysClockFreq+0x38>
 802e95e:	680b      	ldr	r3, [r1, #0]
 802e960:	f013 0308 	ands.w	r3, r3, #8
 802e964:	d137      	bne.n	802e9d6 <HAL_RCC_GetSysClockFreq+0xa2>
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 802e966:	f8d1 1094 	ldr.w	r1, [r1, #148]	; 0x94
 802e96a:	e007      	b.n	802e97c <HAL_RCC_GetSysClockFreq+0x48>
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == (RCC_CR_MSIRGSEL)) ? 1UL : 0UL);
 802e96c:	680c      	ldr	r4, [r1, #0]
 802e96e:	0724      	lsls	r4, r4, #28
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 802e970:	bf56      	itet	pl
 802e972:	f8d1 3094 	ldrpl.w	r3, [r1, #148]	; 0x94
  return (uint32_t)(READ_BIT(RCC->CR, RCC_CR_MSIRANGE));
 802e976:	6809      	ldrmi	r1, [r1, #0]
    msifreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
 802e978:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 802e97c:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
      sysclockfreq = msifreq;
 802e980:	2a00      	cmp	r2, #0
 802e982:	bf0c      	ite	eq
 802e984:	4618      	moveq	r0, r3
 802e986:	2000      	movne	r0, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 802e988:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 802e98c:	688a      	ldr	r2, [r1, #8]
 802e98e:	f002 020c 	and.w	r2, r2, #12
  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 802e992:	2a0c      	cmp	r2, #12
 802e994:	d11e      	bne.n	802e9d4 <HAL_RCC_GetSysClockFreq+0xa0>
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 802e996:	68ca      	ldr	r2, [r1, #12]
 802e998:	f002 0203 	and.w	r2, r2, #3
    switch (pllsource)
 802e99c:	2a02      	cmp	r2, #2
 802e99e:	d02e      	beq.n	802e9fe <HAL_RCC_GetSysClockFreq+0xca>
 802e9a0:	2a03      	cmp	r2, #3
 802e9a2:	d106      	bne.n	802e9b2 <HAL_RCC_GetSysClockFreq+0x7e>
  return ((READ_BIT(RCC->CR, RCC_CR_HSEPRE) == (RCC_CR_HSEPRE)) ? 1UL : 0UL);
 802e9a4:	680b      	ldr	r3, [r1, #0]
          pllinputfreq = HSE_VALUE / 2U;
 802e9a6:	4818      	ldr	r0, [pc, #96]	; (802ea08 <HAL_RCC_GetSysClockFreq+0xd4>)
 802e9a8:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 802e9ac:	4b17      	ldr	r3, [pc, #92]	; (802ea0c <HAL_RCC_GetSysClockFreq+0xd8>)
 802e9ae:	bf18      	it	ne
 802e9b0:	4603      	movne	r3, r0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 802e9b2:	f04f 40b0 	mov.w	r0, #1476395008	; 0x58000000
 802e9b6:	68c1      	ldr	r1, [r0, #12]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM));
 802e9b8:	68c2      	ldr	r2, [r0, #12]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR));
 802e9ba:	68c0      	ldr	r0, [r0, #12]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 802e9bc:	f3c1 2106 	ubfx	r1, r1, #8, #7
    sysclockfreq = __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
 802e9c0:	f3c2 1202 	ubfx	r2, r2, #4, #3
 802e9c4:	0f40      	lsrs	r0, r0, #29
 802e9c6:	434b      	muls	r3, r1
 802e9c8:	3201      	adds	r2, #1
 802e9ca:	3001      	adds	r0, #1
 802e9cc:	fbb3 f3f2 	udiv	r3, r3, r2
 802e9d0:	fbb3 f0f0 	udiv	r0, r3, r0
}
 802e9d4:	bd10      	pop	{r4, pc}
  return (uint32_t)(READ_BIT(RCC->CR, RCC_CR_MSIRANGE));
 802e9d6:	680b      	ldr	r3, [r1, #0]
    msifreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
 802e9d8:	f3c3 1303 	ubfx	r3, r3, #4, #4
 802e9dc:	e7ce      	b.n	802e97c <HAL_RCC_GetSysClockFreq+0x48>
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI)
 802e9de:	2a04      	cmp	r2, #4
 802e9e0:	d00a      	beq.n	802e9f8 <HAL_RCC_GetSysClockFreq+0xc4>
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 802e9e2:	2a08      	cmp	r2, #8
 802e9e4:	d105      	bne.n	802e9f2 <HAL_RCC_GetSysClockFreq+0xbe>
  return ((READ_BIT(RCC->CR, RCC_CR_HSEPRE) == (RCC_CR_HSEPRE)) ? 1UL : 0UL);
 802e9e6:	681b      	ldr	r3, [r3, #0]
 802e9e8:	f413 1380 	ands.w	r3, r3, #1048576	; 0x100000
 802e9ec:	d104      	bne.n	802e9f8 <HAL_RCC_GetSysClockFreq+0xc4>
      sysclockfreq = HSE_VALUE;
 802e9ee:	4807      	ldr	r0, [pc, #28]	; (802ea0c <HAL_RCC_GetSysClockFreq+0xd8>)
 802e9f0:	e7ca      	b.n	802e988 <HAL_RCC_GetSysClockFreq+0x54>
  uint32_t msifreq = 0U;
 802e9f2:	2300      	movs	r3, #0
  uint32_t sysclockfreq = 0U;
 802e9f4:	4618      	mov	r0, r3
 802e9f6:	e7c7      	b.n	802e988 <HAL_RCC_GetSysClockFreq+0x54>
      sysclockfreq = HSE_VALUE / 2U;
 802e9f8:	4803      	ldr	r0, [pc, #12]	; (802ea08 <HAL_RCC_GetSysClockFreq+0xd4>)
  uint32_t msifreq = 0U;
 802e9fa:	2300      	movs	r3, #0
 802e9fc:	e7c4      	b.n	802e988 <HAL_RCC_GetSysClockFreq+0x54>
        pllinputfreq = HSI_VALUE;
 802e9fe:	4b02      	ldr	r3, [pc, #8]	; (802ea08 <HAL_RCC_GetSysClockFreq+0xd4>)
 802ea00:	e7d7      	b.n	802e9b2 <HAL_RCC_GetSysClockFreq+0x7e>
 802ea02:	bf00      	nop
 802ea04:	0803b9c4 	.word	0x0803b9c4
 802ea08:	00f42400 	.word	0x00f42400
 802ea0c:	01e84800 	.word	0x01e84800

0802ea10 <HAL_RCC_GetHCLKFreq>:
{
 802ea10:	b508      	push	{r3, lr}
  return ((uint32_t)(__LL_RCC_CALC_HCLK1_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler())));
 802ea12:	f7ff ff8f 	bl	802e934 <HAL_RCC_GetSysClockFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
 802ea16:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802ea1a:	4a04      	ldr	r2, [pc, #16]	; (802ea2c <HAL_RCC_GetHCLKFreq+0x1c>)
 802ea1c:	689b      	ldr	r3, [r3, #8]
 802ea1e:	f3c3 1303 	ubfx	r3, r3, #4, #4
 802ea22:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
}
 802ea26:	fbb0 f0f3 	udiv	r0, r0, r3
 802ea2a:	bd08      	pop	{r3, pc}
 802ea2c:	0803ba04 	.word	0x0803ba04

0802ea30 <HAL_RCC_OscConfig>:
{
 802ea30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (RCC_OscInitStruct == NULL)
 802ea34:	4604      	mov	r4, r0
 802ea36:	2800      	cmp	r0, #0
 802ea38:	d055      	beq.n	802eae6 <HAL_RCC_OscConfig+0xb6>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 802ea3a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802ea3e:	689e      	ldr	r6, [r3, #8]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 802ea40:	68dd      	ldr	r5, [r3, #12]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 802ea42:	6803      	ldr	r3, [r0, #0]
 802ea44:	0699      	lsls	r1, r3, #26
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 802ea46:	f006 060c 	and.w	r6, r6, #12
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 802ea4a:	f005 0503 	and.w	r5, r5, #3
 802ea4e:	d56b      	bpl.n	802eb28 <HAL_RCC_OscConfig+0xf8>
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 802ea50:	b11e      	cbz	r6, 802ea5a <HAL_RCC_OscConfig+0x2a>
 802ea52:	2e0c      	cmp	r6, #12
 802ea54:	d149      	bne.n	802eaea <HAL_RCC_OscConfig+0xba>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_MSI)))
 802ea56:	2d01      	cmp	r5, #1
 802ea58:	d147      	bne.n	802eaea <HAL_RCC_OscConfig+0xba>
      if ((LL_RCC_MSI_IsReady() != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 802ea5a:	f7ff feeb 	bl	802e834 <LL_RCC_MSI_IsReady>
 802ea5e:	b110      	cbz	r0, 802ea66 <HAL_RCC_OscConfig+0x36>
 802ea60:	6a23      	ldr	r3, [r4, #32]
 802ea62:	2b00      	cmp	r3, #0
 802ea64:	d03f      	beq.n	802eae6 <HAL_RCC_OscConfig+0xb6>
        if (RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 802ea66:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802ea6a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 802ea6c:	681a      	ldr	r2, [r3, #0]
 802ea6e:	0712      	lsls	r2, r2, #28
 802ea70:	bf56      	itet	pl
 802ea72:	f8d3 3094 	ldrpl.w	r3, [r3, #148]	; 0x94
 802ea76:	681b      	ldrmi	r3, [r3, #0]
 802ea78:	091b      	lsrpl	r3, r3, #4
 802ea7a:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 802ea7e:	4298      	cmp	r0, r3
 802ea80:	d91e      	bls.n	802eac0 <HAL_RCC_OscConfig+0x90>
          if (RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 802ea82:	f7ff feed 	bl	802e860 <RCC_SetFlashLatencyFromMSIRange>
 802ea86:	2800      	cmp	r0, #0
 802ea88:	d12d      	bne.n	802eae6 <HAL_RCC_OscConfig+0xb6>
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 802ea8a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 802ea8e:	6813      	ldr	r3, [r2, #0]
 802ea90:	f043 0308 	orr.w	r3, r3, #8
 802ea94:	6013      	str	r3, [r2, #0]
 802ea96:	6813      	ldr	r3, [r2, #0]
 802ea98:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 802ea9a:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 802ea9e:	430b      	orrs	r3, r1
 802eaa0:	6013      	str	r3, [r2, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 802eaa2:	6a60      	ldr	r0, [r4, #36]	; 0x24
 802eaa4:	f7ff fecc 	bl	802e840 <LL_RCC_MSI_SetCalibTrimming>
        SystemCoreClock = HAL_RCC_GetHCLKFreq();
 802eaa8:	f7ff ffb2 	bl	802ea10 <HAL_RCC_GetHCLKFreq>
 802eaac:	4bac      	ldr	r3, [pc, #688]	; (802ed60 <HAL_RCC_OscConfig+0x330>)
 802eaae:	6018      	str	r0, [r3, #0]
        status = HAL_InitTick(uwTickPrio);
 802eab0:	4bac      	ldr	r3, [pc, #688]	; (802ed64 <HAL_RCC_OscConfig+0x334>)
 802eab2:	6818      	ldr	r0, [r3, #0]
 802eab4:	f7fd fdc4 	bl	802c640 <HAL_InitTick>
        if (status != HAL_OK)
 802eab8:	2800      	cmp	r0, #0
 802eaba:	d035      	beq.n	802eb28 <HAL_RCC_OscConfig+0xf8>
}
 802eabc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 802eac0:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 802eac4:	6813      	ldr	r3, [r2, #0]
 802eac6:	f043 0308 	orr.w	r3, r3, #8
 802eaca:	6013      	str	r3, [r2, #0]
 802eacc:	6813      	ldr	r3, [r2, #0]
 802eace:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 802ead2:	4303      	orrs	r3, r0
 802ead4:	6013      	str	r3, [r2, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 802ead6:	6a60      	ldr	r0, [r4, #36]	; 0x24
 802ead8:	f7ff feb2 	bl	802e840 <LL_RCC_MSI_SetCalibTrimming>
          if (RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 802eadc:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 802eade:	f7ff febf 	bl	802e860 <RCC_SetFlashLatencyFromMSIRange>
 802eae2:	2800      	cmp	r0, #0
 802eae4:	d0e0      	beq.n	802eaa8 <HAL_RCC_OscConfig+0x78>
          return HAL_ERROR;
 802eae6:	2001      	movs	r0, #1
 802eae8:	e7e8      	b.n	802eabc <HAL_RCC_OscConfig+0x8c>
      if (RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 802eaea:	6a22      	ldr	r2, [r4, #32]
 802eaec:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802eaf0:	2a00      	cmp	r2, #0
 802eaf2:	d054      	beq.n	802eb9e <HAL_RCC_OscConfig+0x16e>
  SET_BIT(RCC->CR, RCC_CR_MSION);
 802eaf4:	681a      	ldr	r2, [r3, #0]
 802eaf6:	f042 0201 	orr.w	r2, r2, #1
 802eafa:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 802eafc:	f7fd fda2 	bl	802c644 <HAL_GetTick>
 802eb00:	4607      	mov	r7, r0
        while (LL_RCC_MSI_IsReady() == 0U)
 802eb02:	f7ff fe97 	bl	802e834 <LL_RCC_MSI_IsReady>
 802eb06:	2800      	cmp	r0, #0
 802eb08:	d042      	beq.n	802eb90 <HAL_RCC_OscConfig+0x160>
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 802eb0a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 802eb0e:	6813      	ldr	r3, [r2, #0]
 802eb10:	f043 0308 	orr.w	r3, r3, #8
 802eb14:	6013      	str	r3, [r2, #0]
 802eb16:	6813      	ldr	r3, [r2, #0]
 802eb18:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 802eb1a:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 802eb1e:	430b      	orrs	r3, r1
 802eb20:	6013      	str	r3, [r2, #0]
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 802eb22:	6a60      	ldr	r0, [r4, #36]	; 0x24
 802eb24:	f7ff fe8c 	bl	802e840 <LL_RCC_MSI_SetCalibTrimming>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 802eb28:	6823      	ldr	r3, [r4, #0]
 802eb2a:	07db      	lsls	r3, r3, #31
 802eb2c:	d448      	bmi.n	802ebc0 <HAL_RCC_OscConfig+0x190>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 802eb2e:	6823      	ldr	r3, [r4, #0]
 802eb30:	079f      	lsls	r7, r3, #30
 802eb32:	f100 8090 	bmi.w	802ec56 <HAL_RCC_OscConfig+0x226>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 802eb36:	6823      	ldr	r3, [r4, #0]
 802eb38:	071d      	lsls	r5, r3, #28
 802eb3a:	f140 80fc 	bpl.w	802ed36 <HAL_RCC_OscConfig+0x306>
    if (RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 802eb3e:	69a3      	ldr	r3, [r4, #24]
 802eb40:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
 802eb44:	2b00      	cmp	r3, #0
 802eb46:	f000 80e3 	beq.w	802ed10 <HAL_RCC_OscConfig+0x2e0>
      uint32_t csr_temp = RCC->CSR;
 802eb4a:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
      if (RCC_OscInitStruct->LSIDiv != (csr_temp & RCC_CSR_LSIPRE))
 802eb4e:	69e1      	ldr	r1, [r4, #28]
 802eb50:	f003 0210 	and.w	r2, r3, #16
 802eb54:	4291      	cmp	r1, r2
 802eb56:	f000 80c6 	beq.w	802ece6 <HAL_RCC_OscConfig+0x2b6>
        if (((csr_temp & RCC_CSR_LSIRDY) == RCC_CSR_LSIRDY) && \
 802eb5a:	f003 0203 	and.w	r2, r3, #3
 802eb5e:	2a02      	cmp	r2, #2
 802eb60:	d0c1      	beq.n	802eae6 <HAL_RCC_OscConfig+0xb6>
        if ((csr_temp & RCC_CSR_LSION) == RCC_CSR_LSION)
 802eb62:	07d8      	lsls	r0, r3, #31
 802eb64:	f140 80b5 	bpl.w	802ecd2 <HAL_RCC_OscConfig+0x2a2>
  CLEAR_BIT(RCC->CSR, RCC_CSR_LSION);
 802eb68:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 802eb6c:	f023 0301 	bic.w	r3, r3, #1
 802eb70:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94
          tickstart = HAL_GetTick();
 802eb74:	f7fd fd66 	bl	802c644 <HAL_GetTick>
 802eb78:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == (RCC_CSR_LSIRDY)) ? 1UL : 0UL);
 802eb7a:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 802eb7e:	0799      	lsls	r1, r3, #30
 802eb80:	f140 80a7 	bpl.w	802ecd2 <HAL_RCC_OscConfig+0x2a2>
            if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 802eb84:	f7fd fd5e 	bl	802c644 <HAL_GetTick>
 802eb88:	1bc3      	subs	r3, r0, r7
 802eb8a:	2b11      	cmp	r3, #17
 802eb8c:	d9f5      	bls.n	802eb7a <HAL_RCC_OscConfig+0x14a>
 802eb8e:	e004      	b.n	802eb9a <HAL_RCC_OscConfig+0x16a>
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 802eb90:	f7fd fd58 	bl	802c644 <HAL_GetTick>
 802eb94:	1bc0      	subs	r0, r0, r7
 802eb96:	2802      	cmp	r0, #2
 802eb98:	d9b3      	bls.n	802eb02 <HAL_RCC_OscConfig+0xd2>
            return HAL_TIMEOUT;
 802eb9a:	2003      	movs	r0, #3
 802eb9c:	e78e      	b.n	802eabc <HAL_RCC_OscConfig+0x8c>
  CLEAR_BIT(RCC->CR, RCC_CR_MSION);
 802eb9e:	681a      	ldr	r2, [r3, #0]
 802eba0:	f022 0201 	bic.w	r2, r2, #1
 802eba4:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 802eba6:	f7fd fd4d 	bl	802c644 <HAL_GetTick>
 802ebaa:	4607      	mov	r7, r0
        while (LL_RCC_MSI_IsReady() != 0U)
 802ebac:	f7ff fe42 	bl	802e834 <LL_RCC_MSI_IsReady>
 802ebb0:	2800      	cmp	r0, #0
 802ebb2:	d0b9      	beq.n	802eb28 <HAL_RCC_OscConfig+0xf8>
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 802ebb4:	f7fd fd46 	bl	802c644 <HAL_GetTick>
 802ebb8:	1bc0      	subs	r0, r0, r7
 802ebba:	2802      	cmp	r0, #2
 802ebbc:	d9f6      	bls.n	802ebac <HAL_RCC_OscConfig+0x17c>
 802ebbe:	e7ec      	b.n	802eb9a <HAL_RCC_OscConfig+0x16a>
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE) ||
 802ebc0:	2e08      	cmp	r6, #8
 802ebc2:	d003      	beq.n	802ebcc <HAL_RCC_OscConfig+0x19c>
 802ebc4:	2e0c      	cmp	r6, #12
 802ebc6:	d109      	bne.n	802ebdc <HAL_RCC_OscConfig+0x1ac>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSE)))
 802ebc8:	2d03      	cmp	r5, #3
 802ebca:	d107      	bne.n	802ebdc <HAL_RCC_OscConfig+0x1ac>
      if ((LL_RCC_HSE_IsReady() != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 802ebcc:	f7ff fe26 	bl	802e81c <LL_RCC_HSE_IsReady>
 802ebd0:	2800      	cmp	r0, #0
 802ebd2:	d0ac      	beq.n	802eb2e <HAL_RCC_OscConfig+0xfe>
 802ebd4:	6863      	ldr	r3, [r4, #4]
 802ebd6:	2b00      	cmp	r3, #0
 802ebd8:	d1a9      	bne.n	802eb2e <HAL_RCC_OscConfig+0xfe>
 802ebda:	e784      	b.n	802eae6 <HAL_RCC_OscConfig+0xb6>
      MODIFY_REG(RCC->CR, RCC_CR_HSEPRE, RCC_OscInitStruct->HSEDiv);
 802ebdc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802ebe0:	68a1      	ldr	r1, [r4, #8]
 802ebe2:	681a      	ldr	r2, [r3, #0]
 802ebe4:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 802ebe8:	430a      	orrs	r2, r1
 802ebea:	601a      	str	r2, [r3, #0]
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 802ebec:	6862      	ldr	r2, [r4, #4]
 802ebee:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 802ebf2:	d110      	bne.n	802ec16 <HAL_RCC_OscConfig+0x1e6>
  SET_BIT(RCC->CR, RCC_CR_HSEON);
 802ebf4:	681a      	ldr	r2, [r3, #0]
 802ebf6:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 802ebfa:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 802ebfc:	f7fd fd22 	bl	802c644 <HAL_GetTick>
 802ec00:	4607      	mov	r7, r0
        while (LL_RCC_HSE_IsReady() == 0U)
 802ec02:	f7ff fe0b 	bl	802e81c <LL_RCC_HSE_IsReady>
 802ec06:	2800      	cmp	r0, #0
 802ec08:	d191      	bne.n	802eb2e <HAL_RCC_OscConfig+0xfe>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 802ec0a:	f7fd fd1b 	bl	802c644 <HAL_GetTick>
 802ec0e:	1bc0      	subs	r0, r0, r7
 802ec10:	2864      	cmp	r0, #100	; 0x64
 802ec12:	d9f6      	bls.n	802ec02 <HAL_RCC_OscConfig+0x1d2>
 802ec14:	e7c1      	b.n	802eb9a <HAL_RCC_OscConfig+0x16a>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 802ec16:	f5b2 1f04 	cmp.w	r2, #2162688	; 0x210000
 802ec1a:	d104      	bne.n	802ec26 <HAL_RCC_OscConfig+0x1f6>
  SET_BIT(RCC->CR, RCC_CR_HSEBYPPWR);
 802ec1c:	681a      	ldr	r2, [r3, #0]
 802ec1e:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 802ec22:	601a      	str	r2, [r3, #0]
 802ec24:	e7e6      	b.n	802ebf4 <HAL_RCC_OscConfig+0x1c4>
  CLEAR_BIT(RCC->CR, RCC_CR_HSEON);
 802ec26:	6819      	ldr	r1, [r3, #0]
 802ec28:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 802ec2c:	6019      	str	r1, [r3, #0]
  CLEAR_BIT(RCC->CR, RCC_CR_HSEBYPPWR);
 802ec2e:	6819      	ldr	r1, [r3, #0]
 802ec30:	f421 1100 	bic.w	r1, r1, #2097152	; 0x200000
 802ec34:	6019      	str	r1, [r3, #0]
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 802ec36:	2a00      	cmp	r2, #0
 802ec38:	d1e0      	bne.n	802ebfc <HAL_RCC_OscConfig+0x1cc>
        tickstart = HAL_GetTick();
 802ec3a:	f7fd fd03 	bl	802c644 <HAL_GetTick>
 802ec3e:	4607      	mov	r7, r0
        while (LL_RCC_HSE_IsReady() != 0U)
 802ec40:	f7ff fdec 	bl	802e81c <LL_RCC_HSE_IsReady>
 802ec44:	2800      	cmp	r0, #0
 802ec46:	f43f af72 	beq.w	802eb2e <HAL_RCC_OscConfig+0xfe>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 802ec4a:	f7fd fcfb 	bl	802c644 <HAL_GetTick>
 802ec4e:	1bc0      	subs	r0, r0, r7
 802ec50:	2864      	cmp	r0, #100	; 0x64
 802ec52:	d9f5      	bls.n	802ec40 <HAL_RCC_OscConfig+0x210>
 802ec54:	e7a1      	b.n	802eb9a <HAL_RCC_OscConfig+0x16a>
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI) ||
 802ec56:	2e04      	cmp	r6, #4
 802ec58:	d003      	beq.n	802ec62 <HAL_RCC_OscConfig+0x232>
 802ec5a:	2e0c      	cmp	r6, #12
 802ec5c:	d112      	bne.n	802ec84 <HAL_RCC_OscConfig+0x254>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSI)))
 802ec5e:	2d02      	cmp	r5, #2
 802ec60:	d110      	bne.n	802ec84 <HAL_RCC_OscConfig+0x254>
      if ((LL_RCC_HSI_IsReady() != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 802ec62:	f7ff fde1 	bl	802e828 <LL_RCC_HSI_IsReady>
 802ec66:	b118      	cbz	r0, 802ec70 <HAL_RCC_OscConfig+0x240>
 802ec68:	6923      	ldr	r3, [r4, #16]
 802ec6a:	2b00      	cmp	r3, #0
 802ec6c:	f43f af3b 	beq.w	802eae6 <HAL_RCC_OscConfig+0xb6>
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_HSITRIM, Value << RCC_ICSCR_HSITRIM_Pos);
 802ec70:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 802ec74:	6961      	ldr	r1, [r4, #20]
 802ec76:	6853      	ldr	r3, [r2, #4]
 802ec78:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 802ec7c:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 802ec80:	6053      	str	r3, [r2, #4]
}
 802ec82:	e758      	b.n	802eb36 <HAL_RCC_OscConfig+0x106>
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 802ec84:	6922      	ldr	r2, [r4, #16]
 802ec86:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802ec8a:	b182      	cbz	r2, 802ecae <HAL_RCC_OscConfig+0x27e>
  SET_BIT(RCC->CR, RCC_CR_HSION);
 802ec8c:	681a      	ldr	r2, [r3, #0]
 802ec8e:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 802ec92:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 802ec94:	f7fd fcd6 	bl	802c644 <HAL_GetTick>
 802ec98:	4605      	mov	r5, r0
        while (LL_RCC_HSI_IsReady() == 0U)
 802ec9a:	f7ff fdc5 	bl	802e828 <LL_RCC_HSI_IsReady>
 802ec9e:	2800      	cmp	r0, #0
 802eca0:	d1e6      	bne.n	802ec70 <HAL_RCC_OscConfig+0x240>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 802eca2:	f7fd fccf 	bl	802c644 <HAL_GetTick>
 802eca6:	1b40      	subs	r0, r0, r5
 802eca8:	2802      	cmp	r0, #2
 802ecaa:	d9f6      	bls.n	802ec9a <HAL_RCC_OscConfig+0x26a>
 802ecac:	e775      	b.n	802eb9a <HAL_RCC_OscConfig+0x16a>
  CLEAR_BIT(RCC->CR, RCC_CR_HSION);
 802ecae:	681a      	ldr	r2, [r3, #0]
 802ecb0:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 802ecb4:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 802ecb6:	f7fd fcc5 	bl	802c644 <HAL_GetTick>
 802ecba:	4605      	mov	r5, r0
        while (LL_RCC_HSI_IsReady() != 0U)
 802ecbc:	f7ff fdb4 	bl	802e828 <LL_RCC_HSI_IsReady>
 802ecc0:	2800      	cmp	r0, #0
 802ecc2:	f43f af38 	beq.w	802eb36 <HAL_RCC_OscConfig+0x106>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 802ecc6:	f7fd fcbd 	bl	802c644 <HAL_GetTick>
 802ecca:	1b40      	subs	r0, r0, r5
 802eccc:	2802      	cmp	r0, #2
 802ecce:	d9f5      	bls.n	802ecbc <HAL_RCC_OscConfig+0x28c>
 802ecd0:	e763      	b.n	802eb9a <HAL_RCC_OscConfig+0x16a>
        MODIFY_REG(RCC->CSR, RCC_CSR_LSIPRE, RCC_OscInitStruct->LSIDiv);
 802ecd2:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 802ecd6:	69e1      	ldr	r1, [r4, #28]
 802ecd8:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
 802ecdc:	f023 0310 	bic.w	r3, r3, #16
 802ece0:	430b      	orrs	r3, r1
 802ece2:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
  SET_BIT(RCC->CSR, RCC_CSR_LSION);
 802ece6:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
 802ecea:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 802ecee:	f043 0301 	orr.w	r3, r3, #1
 802ecf2:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94
      tickstart = HAL_GetTick();
 802ecf6:	f7fd fca5 	bl	802c644 <HAL_GetTick>
 802ecfa:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == (RCC_CSR_LSIRDY)) ? 1UL : 0UL);
 802ecfc:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 802ed00:	079a      	lsls	r2, r3, #30
 802ed02:	d418      	bmi.n	802ed36 <HAL_RCC_OscConfig+0x306>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 802ed04:	f7fd fc9e 	bl	802c644 <HAL_GetTick>
 802ed08:	1bc3      	subs	r3, r0, r7
 802ed0a:	2b11      	cmp	r3, #17
 802ed0c:	d9f6      	bls.n	802ecfc <HAL_RCC_OscConfig+0x2cc>
 802ed0e:	e744      	b.n	802eb9a <HAL_RCC_OscConfig+0x16a>
  CLEAR_BIT(RCC->CSR, RCC_CSR_LSION);
 802ed10:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 802ed14:	f023 0301 	bic.w	r3, r3, #1
 802ed18:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94
      tickstart = HAL_GetTick();
 802ed1c:	f7fd fc92 	bl	802c644 <HAL_GetTick>
 802ed20:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == (RCC_CSR_LSIRDY)) ? 1UL : 0UL);
 802ed22:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 802ed26:	079b      	lsls	r3, r3, #30
 802ed28:	d505      	bpl.n	802ed36 <HAL_RCC_OscConfig+0x306>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 802ed2a:	f7fd fc8b 	bl	802c644 <HAL_GetTick>
 802ed2e:	1bc3      	subs	r3, r0, r7
 802ed30:	2b11      	cmp	r3, #17
 802ed32:	d9f6      	bls.n	802ed22 <HAL_RCC_OscConfig+0x2f2>
 802ed34:	e731      	b.n	802eb9a <HAL_RCC_OscConfig+0x16a>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 802ed36:	6823      	ldr	r3, [r4, #0]
 802ed38:	0758      	lsls	r0, r3, #29
 802ed3a:	d553      	bpl.n	802ede4 <HAL_RCC_OscConfig+0x3b4>
  return ((READ_BIT(PWR->CR1, PWR_CR1_DBP) == (PWR_CR1_DBP)) ? 1UL : 0UL);
 802ed3c:	4d0a      	ldr	r5, [pc, #40]	; (802ed68 <HAL_RCC_OscConfig+0x338>)
 802ed3e:	682b      	ldr	r3, [r5, #0]
 802ed40:	05d9      	lsls	r1, r3, #23
 802ed42:	d413      	bmi.n	802ed6c <HAL_RCC_OscConfig+0x33c>
      HAL_PWR_EnableBkUpAccess();
 802ed44:	f7ff fcf4 	bl	802e730 <HAL_PWR_EnableBkUpAccess>
      tickstart = HAL_GetTick();
 802ed48:	f7fd fc7c 	bl	802c644 <HAL_GetTick>
 802ed4c:	4607      	mov	r7, r0
 802ed4e:	682b      	ldr	r3, [r5, #0]
 802ed50:	05da      	lsls	r2, r3, #23
 802ed52:	d40b      	bmi.n	802ed6c <HAL_RCC_OscConfig+0x33c>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 802ed54:	f7fd fc76 	bl	802c644 <HAL_GetTick>
 802ed58:	1bc3      	subs	r3, r0, r7
 802ed5a:	2b02      	cmp	r3, #2
 802ed5c:	d9f7      	bls.n	802ed4e <HAL_RCC_OscConfig+0x31e>
 802ed5e:	e71c      	b.n	802eb9a <HAL_RCC_OscConfig+0x16a>
 802ed60:	2000344c 	.word	0x2000344c
 802ed64:	20003454 	.word	0x20003454
 802ed68:	58000400 	.word	0x58000400
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 802ed6c:	68e3      	ldr	r3, [r4, #12]
 802ed6e:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
 802ed72:	2b00      	cmp	r3, #0
 802ed74:	d058      	beq.n	802ee28 <HAL_RCC_OscConfig+0x3f8>
          || (RCC_OscInitStruct->LSEState == RCC_LSE_BYPASS_RTC_ONLY))
 802ed76:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 802ed7a:	2b05      	cmp	r3, #5
        SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
 802ed7c:	bf02      	ittt	eq
 802ed7e:	f8d5 3090 	ldreq.w	r3, [r5, #144]	; 0x90
 802ed82:	f043 0304 	orreq.w	r3, r3, #4
 802ed86:	f8c5 3090 	streq.w	r3, [r5, #144]	; 0x90
      SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 802ed8a:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
      tickstart = HAL_GetTick();
 802ed8e:	f7fd fc59 	bl	802c644 <HAL_GetTick>
      SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 802ed92:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802ed96:	f043 0301 	orr.w	r3, r3, #1
      tickstart = HAL_GetTick();
 802ed9a:	4607      	mov	r7, r0
      SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 802ed9c:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802eda0:	f241 3888 	movw	r8, #5000	; 0x1388
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? 1UL : 0UL);
 802eda4:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802eda8:	079b      	lsls	r3, r3, #30
 802edaa:	d405      	bmi.n	802edb8 <HAL_RCC_OscConfig+0x388>
 802edac:	f7fd fc4a 	bl	802c644 <HAL_GetTick>
 802edb0:	1bc3      	subs	r3, r0, r7
 802edb2:	4543      	cmp	r3, r8
 802edb4:	d9f6      	bls.n	802eda4 <HAL_RCC_OscConfig+0x374>
 802edb6:	e6f0      	b.n	802eb9a <HAL_RCC_OscConfig+0x16a>
      if ((RCC_OscInitStruct->LSEState == RCC_LSE_ON)
 802edb8:	68e3      	ldr	r3, [r4, #12]
 802edba:	f023 0304 	bic.w	r3, r3, #4
 802edbe:	2b81      	cmp	r3, #129	; 0x81
 802edc0:	d11b      	bne.n	802edfa <HAL_RCC_OscConfig+0x3ca>
        tickstart = HAL_GetTick();
 802edc2:	f7fd fc3f 	bl	802c644 <HAL_GetTick>
        SET_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 802edc6:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802edca:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 802edce:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        tickstart = HAL_GetTick();
 802edd2:	4607      	mov	r7, r0
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) == 0U)
 802edd4:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802edd8:	f241 3888 	movw	r8, #5000	; 0x1388
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) == 0U)
 802eddc:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802ede0:	0518      	lsls	r0, r3, #20
 802ede2:	d504      	bpl.n	802edee <HAL_RCC_OscConfig+0x3be>
  if (RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 802ede4:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 802ede6:	2800      	cmp	r0, #0
 802ede8:	d14a      	bne.n	802ee80 <HAL_RCC_OscConfig+0x450>
  return HAL_OK;
 802edea:	2000      	movs	r0, #0
 802edec:	e666      	b.n	802eabc <HAL_RCC_OscConfig+0x8c>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802edee:	f7fd fc29 	bl	802c644 <HAL_GetTick>
 802edf2:	1bc0      	subs	r0, r0, r7
 802edf4:	4540      	cmp	r0, r8
 802edf6:	d9f1      	bls.n	802eddc <HAL_RCC_OscConfig+0x3ac>
 802edf8:	e6cf      	b.n	802eb9a <HAL_RCC_OscConfig+0x16a>
        tickstart = HAL_GetTick();
 802edfa:	f7fd fc23 	bl	802c644 <HAL_GetTick>
        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 802edfe:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802ee02:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 802ee06:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        tickstart = HAL_GetTick();
 802ee0a:	4607      	mov	r7, r0
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 802ee0c:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802ee10:	f241 3888 	movw	r8, #5000	; 0x1388
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 802ee14:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802ee18:	0519      	lsls	r1, r3, #20
 802ee1a:	d5e3      	bpl.n	802ede4 <HAL_RCC_OscConfig+0x3b4>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802ee1c:	f7fd fc12 	bl	802c644 <HAL_GetTick>
 802ee20:	1bc0      	subs	r0, r0, r7
 802ee22:	4540      	cmp	r0, r8
 802ee24:	d9f6      	bls.n	802ee14 <HAL_RCC_OscConfig+0x3e4>
 802ee26:	e6b8      	b.n	802eb9a <HAL_RCC_OscConfig+0x16a>
      tickstart = HAL_GetTick();
 802ee28:	f7fd fc0c 	bl	802c644 <HAL_GetTick>
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 802ee2c:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802ee30:	f023 0380 	bic.w	r3, r3, #128	; 0x80
      tickstart = HAL_GetTick();
 802ee34:	4607      	mov	r7, r0
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 802ee36:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802ee3a:	f241 3888 	movw	r8, #5000	; 0x1388
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 802ee3e:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802ee42:	051a      	lsls	r2, r3, #20
 802ee44:	d416      	bmi.n	802ee74 <HAL_RCC_OscConfig+0x444>
      tickstart = HAL_GetTick();
 802ee46:	f7fd fbfd 	bl	802c644 <HAL_GetTick>
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 802ee4a:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802ee4e:	f023 0301 	bic.w	r3, r3, #1
 802ee52:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
      tickstart = HAL_GetTick();
 802ee56:	4607      	mov	r7, r0
 802ee58:	f04f 48b0 	mov.w	r8, #1476395008	; 0x58000000
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802ee5c:	f241 3588 	movw	r5, #5000	; 0x1388
 802ee60:	f8d8 3090 	ldr.w	r3, [r8, #144]	; 0x90
 802ee64:	079b      	lsls	r3, r3, #30
 802ee66:	d5bd      	bpl.n	802ede4 <HAL_RCC_OscConfig+0x3b4>
 802ee68:	f7fd fbec 	bl	802c644 <HAL_GetTick>
 802ee6c:	1bc3      	subs	r3, r0, r7
 802ee6e:	42ab      	cmp	r3, r5
 802ee70:	d9f6      	bls.n	802ee60 <HAL_RCC_OscConfig+0x430>
 802ee72:	e692      	b.n	802eb9a <HAL_RCC_OscConfig+0x16a>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802ee74:	f7fd fbe6 	bl	802c644 <HAL_GetTick>
 802ee78:	1bc0      	subs	r0, r0, r7
 802ee7a:	4540      	cmp	r0, r8
 802ee7c:	d9df      	bls.n	802ee3e <HAL_RCC_OscConfig+0x40e>
 802ee7e:	e68c      	b.n	802eb9a <HAL_RCC_OscConfig+0x16a>
    if (sysclk_source != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 802ee80:	2e0c      	cmp	r6, #12
 802ee82:	d053      	beq.n	802ef2c <HAL_RCC_OscConfig+0x4fc>
      if (RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 802ee84:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802ee88:	2802      	cmp	r0, #2
  CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
 802ee8a:	681a      	ldr	r2, [r3, #0]
 802ee8c:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 802ee90:	601a      	str	r2, [r3, #0]
 802ee92:	d133      	bne.n	802eefc <HAL_RCC_OscConfig+0x4cc>
        tickstart = HAL_GetTick();
 802ee94:	f7fd fbd6 	bl	802c644 <HAL_GetTick>
 802ee98:	4605      	mov	r5, r0
        while (LL_RCC_PLL_IsReady() != 0U)
 802ee9a:	f7ff fcda 	bl	802e852 <LL_RCC_PLL_IsReady>
 802ee9e:	bb38      	cbnz	r0, 802eef0 <HAL_RCC_OscConfig+0x4c0>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 802eea0:	e9d4 310c 	ldrd	r3, r1, [r4, #48]	; 0x30
 802eea4:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 802eea8:	430b      	orrs	r3, r1
 802eeaa:	68d0      	ldr	r0, [r2, #12]
 802eeac:	492f      	ldr	r1, [pc, #188]	; (802ef6c <HAL_RCC_OscConfig+0x53c>)
 802eeae:	4001      	ands	r1, r0
 802eeb0:	430b      	orrs	r3, r1
 802eeb2:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 802eeb4:	430b      	orrs	r3, r1
 802eeb6:	6c21      	ldr	r1, [r4, #64]	; 0x40
 802eeb8:	430b      	orrs	r3, r1
 802eeba:	6c61      	ldr	r1, [r4, #68]	; 0x44
 802eebc:	430b      	orrs	r3, r1
 802eebe:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 802eec0:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 802eec4:	60d3      	str	r3, [r2, #12]
  SET_BIT(RCC->CR, RCC_CR_PLLON);
 802eec6:	6813      	ldr	r3, [r2, #0]
 802eec8:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 802eecc:	6013      	str	r3, [r2, #0]
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 802eece:	68d3      	ldr	r3, [r2, #12]
 802eed0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 802eed4:	60d3      	str	r3, [r2, #12]
        tickstart = HAL_GetTick();
 802eed6:	f7fd fbb5 	bl	802c644 <HAL_GetTick>
 802eeda:	4604      	mov	r4, r0
        while (LL_RCC_PLL_IsReady() == 0U)
 802eedc:	f7ff fcb9 	bl	802e852 <LL_RCC_PLL_IsReady>
 802eee0:	2800      	cmp	r0, #0
 802eee2:	d182      	bne.n	802edea <HAL_RCC_OscConfig+0x3ba>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 802eee4:	f7fd fbae 	bl	802c644 <HAL_GetTick>
 802eee8:	1b00      	subs	r0, r0, r4
 802eeea:	280a      	cmp	r0, #10
 802eeec:	d9f6      	bls.n	802eedc <HAL_RCC_OscConfig+0x4ac>
 802eeee:	e654      	b.n	802eb9a <HAL_RCC_OscConfig+0x16a>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 802eef0:	f7fd fba8 	bl	802c644 <HAL_GetTick>
 802eef4:	1b40      	subs	r0, r0, r5
 802eef6:	280a      	cmp	r0, #10
 802eef8:	d9cf      	bls.n	802ee9a <HAL_RCC_OscConfig+0x46a>
 802eefa:	e64e      	b.n	802eb9a <HAL_RCC_OscConfig+0x16a>
        MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PLLSOURCE_NONE);
 802eefc:	68da      	ldr	r2, [r3, #12]
 802eefe:	f022 0203 	bic.w	r2, r2, #3
 802ef02:	60da      	str	r2, [r3, #12]
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_RNGCLK | RCC_PLL_ADCCLK);
 802ef04:	68da      	ldr	r2, [r3, #12]
 802ef06:	f022 5288 	bic.w	r2, r2, #285212672	; 0x11000000
 802ef0a:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 802ef0e:	60da      	str	r2, [r3, #12]
        tickstart = HAL_GetTick();
 802ef10:	f7fd fb98 	bl	802c644 <HAL_GetTick>
 802ef14:	4604      	mov	r4, r0
        while (LL_RCC_PLL_IsReady() != 0U)
 802ef16:	f7ff fc9c 	bl	802e852 <LL_RCC_PLL_IsReady>
 802ef1a:	2800      	cmp	r0, #0
 802ef1c:	f43f af65 	beq.w	802edea <HAL_RCC_OscConfig+0x3ba>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 802ef20:	f7fd fb90 	bl	802c644 <HAL_GetTick>
 802ef24:	1b00      	subs	r0, r0, r4
 802ef26:	280a      	cmp	r0, #10
 802ef28:	d9f5      	bls.n	802ef16 <HAL_RCC_OscConfig+0x4e6>
 802ef2a:	e636      	b.n	802eb9a <HAL_RCC_OscConfig+0x16a>
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 802ef2c:	2801      	cmp	r0, #1
 802ef2e:	f43f adc5 	beq.w	802eabc <HAL_RCC_OscConfig+0x8c>
        pll_config = RCC->PLLCFGR;
 802ef32:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
        if ((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource)
 802ef36:	6b22      	ldr	r2, [r4, #48]	; 0x30
        pll_config = RCC->PLLCFGR;
 802ef38:	68db      	ldr	r3, [r3, #12]
        if ((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource)
 802ef3a:	f003 0103 	and.w	r1, r3, #3
 802ef3e:	4291      	cmp	r1, r2
 802ef40:	f47f add1 	bne.w	802eae6 <HAL_RCC_OscConfig+0xb6>
            || (READ_BIT(pll_config, RCC_PLLCFGR_PLLM)   != RCC_OscInitStruct->PLL.PLLM)
 802ef44:	6b61      	ldr	r1, [r4, #52]	; 0x34
 802ef46:	f003 0270 	and.w	r2, r3, #112	; 0x70
 802ef4a:	428a      	cmp	r2, r1
 802ef4c:	f47f adcb 	bne.w	802eae6 <HAL_RCC_OscConfig+0xb6>
            || (READ_BIT(pll_config, RCC_PLLCFGR_PLLN)   != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos))
 802ef50:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 802ef52:	f403 42fe 	and.w	r2, r3, #32512	; 0x7f00
 802ef56:	ebb2 2f01 	cmp.w	r2, r1, lsl #8
 802ef5a:	f47f adc4 	bne.w	802eae6 <HAL_RCC_OscConfig+0xb6>
            || (READ_BIT(pll_config, RCC_PLLCFGR_PLLR)   != RCC_OscInitStruct->PLL.PLLR))
 802ef5e:	6c62      	ldr	r2, [r4, #68]	; 0x44
 802ef60:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
 802ef64:	4293      	cmp	r3, r2
 802ef66:	f43f af40 	beq.w	802edea <HAL_RCC_OscConfig+0x3ba>
 802ef6a:	e5bc      	b.n	802eae6 <HAL_RCC_OscConfig+0xb6>
 802ef6c:	11c1808c 	.word	0x11c1808c

0802ef70 <HAL_RCC_ClockConfig>:
{
 802ef70:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802ef74:	460d      	mov	r5, r1
  if (RCC_ClkInitStruct == NULL)
 802ef76:	4604      	mov	r4, r0
 802ef78:	b910      	cbnz	r0, 802ef80 <HAL_RCC_ClockConfig+0x10>
    return HAL_ERROR;
 802ef7a:	2001      	movs	r0, #1
}
 802ef7c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 802ef80:	4e74      	ldr	r6, [pc, #464]	; (802f154 <HAL_RCC_ClockConfig+0x1e4>)
 802ef82:	6833      	ldr	r3, [r6, #0]
 802ef84:	f003 0307 	and.w	r3, r3, #7
 802ef88:	428b      	cmp	r3, r1
 802ef8a:	d316      	bcc.n	802efba <HAL_RCC_ClockConfig+0x4a>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 802ef8c:	6823      	ldr	r3, [r4, #0]
 802ef8e:	079a      	lsls	r2, r3, #30
 802ef90:	d527      	bpl.n	802efe2 <HAL_RCC_ClockConfig+0x72>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
 802ef92:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
 802ef96:	68a2      	ldr	r2, [r4, #8]
 802ef98:	68b3      	ldr	r3, [r6, #8]
 802ef9a:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 802ef9e:	4313      	orrs	r3, r2
 802efa0:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 802efa2:	f7fd fb4f 	bl	802c644 <HAL_GetTick>
 802efa6:	4607      	mov	r7, r0
  * @rmtoll CFGR         HPREF       LL_RCC_IsActiveFlag_HPRE
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_HPRE(void)
{
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_HPREF) == (RCC_CFGR_HPREF)) ? 1UL : 0UL);
 802efa8:	68b3      	ldr	r3, [r6, #8]
 802efaa:	03db      	lsls	r3, r3, #15
 802efac:	d419      	bmi.n	802efe2 <HAL_RCC_ClockConfig+0x72>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 802efae:	f7fd fb49 	bl	802c644 <HAL_GetTick>
 802efb2:	1bc3      	subs	r3, r0, r7
 802efb4:	2b02      	cmp	r3, #2
 802efb6:	d9f7      	bls.n	802efa8 <HAL_RCC_ClockConfig+0x38>
 802efb8:	e011      	b.n	802efde <HAL_RCC_ClockConfig+0x6e>
    __HAL_FLASH_SET_LATENCY(FLatency);
 802efba:	6833      	ldr	r3, [r6, #0]
 802efbc:	f023 0307 	bic.w	r3, r3, #7
 802efc0:	430b      	orrs	r3, r1
 802efc2:	6033      	str	r3, [r6, #0]
    tickstart = HAL_GetTick();
 802efc4:	f7fd fb3e 	bl	802c644 <HAL_GetTick>
 802efc8:	4607      	mov	r7, r0
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 802efca:	6833      	ldr	r3, [r6, #0]
 802efcc:	f003 0307 	and.w	r3, r3, #7
 802efd0:	42ab      	cmp	r3, r5
 802efd2:	d0db      	beq.n	802ef8c <HAL_RCC_ClockConfig+0x1c>
      if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 802efd4:	f7fd fb36 	bl	802c644 <HAL_GetTick>
 802efd8:	1bc0      	subs	r0, r0, r7
 802efda:	2802      	cmp	r0, #2
 802efdc:	d9f5      	bls.n	802efca <HAL_RCC_ClockConfig+0x5a>
        return HAL_TIMEOUT;
 802efde:	2003      	movs	r0, #3
 802efe0:	e7cc      	b.n	802ef7c <HAL_RCC_ClockConfig+0xc>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK2) == RCC_CLOCKTYPE_HCLK2)
 802efe2:	6823      	ldr	r3, [r4, #0]
 802efe4:	0698      	lsls	r0, r3, #26
 802efe6:	d516      	bpl.n	802f016 <HAL_RCC_ClockConfig+0xa6>
  MODIFY_REG(RCC->EXTCFGR, RCC_EXTCFGR_C2HPRE, Prescaler);
 802efe8:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
 802efec:	6962      	ldr	r2, [r4, #20]
 802efee:	f8d6 3108 	ldr.w	r3, [r6, #264]	; 0x108
 802eff2:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 802eff6:	4313      	orrs	r3, r2
 802eff8:	f8c6 3108 	str.w	r3, [r6, #264]	; 0x108
    tickstart = HAL_GetTick();
 802effc:	f7fd fb22 	bl	802c644 <HAL_GetTick>
 802f000:	4607      	mov	r7, r0
  * @rmtoll EXTCFGR         C2HPREF       LL_RCC_IsActiveFlag_C2HPRE
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_C2HPRE(void)
{
  return ((READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_C2HPREF) == (RCC_EXTCFGR_C2HPREF)) ? 1UL : 0UL);
 802f002:	f8d6 3108 	ldr.w	r3, [r6, #264]	; 0x108
 802f006:	0399      	lsls	r1, r3, #14
 802f008:	d405      	bmi.n	802f016 <HAL_RCC_ClockConfig+0xa6>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 802f00a:	f7fd fb1b 	bl	802c644 <HAL_GetTick>
 802f00e:	1bc3      	subs	r3, r0, r7
 802f010:	2b02      	cmp	r3, #2
 802f012:	d9f6      	bls.n	802f002 <HAL_RCC_ClockConfig+0x92>
 802f014:	e7e3      	b.n	802efde <HAL_RCC_ClockConfig+0x6e>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK3) == RCC_CLOCKTYPE_HCLK3)
 802f016:	6823      	ldr	r3, [r4, #0]
 802f018:	065a      	lsls	r2, r3, #25
 802f01a:	d517      	bpl.n	802f04c <HAL_RCC_ClockConfig+0xdc>
  MODIFY_REG(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPRE, Prescaler >> 4);
 802f01c:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
 802f020:	69a2      	ldr	r2, [r4, #24]
 802f022:	f8d6 3108 	ldr.w	r3, [r6, #264]	; 0x108
 802f026:	f023 030f 	bic.w	r3, r3, #15
 802f02a:	ea43 1312 	orr.w	r3, r3, r2, lsr #4
 802f02e:	f8c6 3108 	str.w	r3, [r6, #264]	; 0x108
    tickstart = HAL_GetTick();
 802f032:	f7fd fb07 	bl	802c644 <HAL_GetTick>
 802f036:	4607      	mov	r7, r0
  * @rmtoll EXTCFGR         SHDHPREF       LL_RCC_IsActiveFlag_SHDHPRE
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_SHDHPRE(void)
{
  return ((READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPREF) == (RCC_EXTCFGR_SHDHPREF)) ? 1UL : 0UL);
 802f038:	f8d6 3108 	ldr.w	r3, [r6, #264]	; 0x108
 802f03c:	03db      	lsls	r3, r3, #15
 802f03e:	d405      	bmi.n	802f04c <HAL_RCC_ClockConfig+0xdc>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 802f040:	f7fd fb00 	bl	802c644 <HAL_GetTick>
 802f044:	1bc3      	subs	r3, r0, r7
 802f046:	2b02      	cmp	r3, #2
 802f048:	d9f6      	bls.n	802f038 <HAL_RCC_ClockConfig+0xc8>
 802f04a:	e7c8      	b.n	802efde <HAL_RCC_ClockConfig+0x6e>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 802f04c:	6823      	ldr	r3, [r4, #0]
 802f04e:	075e      	lsls	r6, r3, #29
 802f050:	d513      	bpl.n	802f07a <HAL_RCC_ClockConfig+0x10a>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, Prescaler);
 802f052:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
 802f056:	68e2      	ldr	r2, [r4, #12]
 802f058:	68b3      	ldr	r3, [r6, #8]
 802f05a:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 802f05e:	4313      	orrs	r3, r2
 802f060:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 802f062:	f7fd faef 	bl	802c644 <HAL_GetTick>
 802f066:	4607      	mov	r7, r0
  * @rmtoll CFGR         PPRE1F       LL_RCC_IsActiveFlag_PPRE1
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_PPRE1(void)
{
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1F) == (RCC_CFGR_PPRE1F)) ? 1UL : 0UL);
 802f068:	68b3      	ldr	r3, [r6, #8]
 802f06a:	0398      	lsls	r0, r3, #14
 802f06c:	d405      	bmi.n	802f07a <HAL_RCC_ClockConfig+0x10a>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 802f06e:	f7fd fae9 	bl	802c644 <HAL_GetTick>
 802f072:	1bc3      	subs	r3, r0, r7
 802f074:	2b02      	cmp	r3, #2
 802f076:	d9f7      	bls.n	802f068 <HAL_RCC_ClockConfig+0xf8>
 802f078:	e7b1      	b.n	802efde <HAL_RCC_ClockConfig+0x6e>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 802f07a:	6823      	ldr	r3, [r4, #0]
 802f07c:	0719      	lsls	r1, r3, #28
 802f07e:	d514      	bpl.n	802f0aa <HAL_RCC_ClockConfig+0x13a>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, Prescaler);
 802f080:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
    LL_RCC_SetAPB2Prescaler((RCC_ClkInitStruct->APB2CLKDivider) << 3U);
 802f084:	6922      	ldr	r2, [r4, #16]
 802f086:	68b3      	ldr	r3, [r6, #8]
 802f088:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 802f08c:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 802f090:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 802f092:	f7fd fad7 	bl	802c644 <HAL_GetTick>
 802f096:	4607      	mov	r7, r0
  * @rmtoll CFGR         PPRE2F       LL_RCC_IsActiveFlag_PPRE2
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_PPRE2(void)
{
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2F) == (RCC_CFGR_PPRE2F)) ? 1UL : 0UL);
 802f098:	68b3      	ldr	r3, [r6, #8]
 802f09a:	035a      	lsls	r2, r3, #13
 802f09c:	d405      	bmi.n	802f0aa <HAL_RCC_ClockConfig+0x13a>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 802f09e:	f7fd fad1 	bl	802c644 <HAL_GetTick>
 802f0a2:	1bc3      	subs	r3, r0, r7
 802f0a4:	2b02      	cmp	r3, #2
 802f0a6:	d9f7      	bls.n	802f098 <HAL_RCC_ClockConfig+0x128>
 802f0a8:	e799      	b.n	802efde <HAL_RCC_ClockConfig+0x6e>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 802f0aa:	6823      	ldr	r3, [r4, #0]
 802f0ac:	07db      	lsls	r3, r3, #31
 802f0ae:	d40f      	bmi.n	802f0d0 <HAL_RCC_ClockConfig+0x160>
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 802f0b0:	4c28      	ldr	r4, [pc, #160]	; (802f154 <HAL_RCC_ClockConfig+0x1e4>)
 802f0b2:	6823      	ldr	r3, [r4, #0]
 802f0b4:	f003 0307 	and.w	r3, r3, #7
 802f0b8:	42ab      	cmp	r3, r5
 802f0ba:	d837      	bhi.n	802f12c <HAL_RCC_ClockConfig+0x1bc>
  SystemCoreClock = HAL_RCC_GetHCLKFreq();
 802f0bc:	f7ff fca8 	bl	802ea10 <HAL_RCC_GetHCLKFreq>
 802f0c0:	4b25      	ldr	r3, [pc, #148]	; (802f158 <HAL_RCC_ClockConfig+0x1e8>)
 802f0c2:	6018      	str	r0, [r3, #0]
  return HAL_InitTick(uwTickPrio);
 802f0c4:	4b25      	ldr	r3, [pc, #148]	; (802f15c <HAL_RCC_ClockConfig+0x1ec>)
}
 802f0c6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  return HAL_InitTick(uwTickPrio);
 802f0ca:	6818      	ldr	r0, [r3, #0]
 802f0cc:	f7fd bab8 	b.w	802c640 <HAL_InitTick>
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 802f0d0:	6863      	ldr	r3, [r4, #4]
 802f0d2:	2b02      	cmp	r3, #2
 802f0d4:	d11e      	bne.n	802f114 <HAL_RCC_ClockConfig+0x1a4>
      if (LL_RCC_HSE_IsReady() == 0U)
 802f0d6:	f7ff fba1 	bl	802e81c <LL_RCC_HSE_IsReady>
      if (LL_RCC_HSI_IsReady() == 0U)
 802f0da:	2800      	cmp	r0, #0
 802f0dc:	f43f af4d 	beq.w	802ef7a <HAL_RCC_ClockConfig+0xa>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
 802f0e0:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
 802f0e4:	6862      	ldr	r2, [r4, #4]
 802f0e6:	68b3      	ldr	r3, [r6, #8]
 802f0e8:	f023 0303 	bic.w	r3, r3, #3
 802f0ec:	4313      	orrs	r3, r2
 802f0ee:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 802f0f0:	f7fd faa8 	bl	802c644 <HAL_GetTick>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 802f0f4:	f241 3888 	movw	r8, #5000	; 0x1388
    tickstart = HAL_GetTick();
 802f0f8:	4607      	mov	r7, r0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 802f0fa:	68b3      	ldr	r3, [r6, #8]
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 802f0fc:	6862      	ldr	r2, [r4, #4]
 802f0fe:	f003 030c 	and.w	r3, r3, #12
 802f102:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 802f106:	d0d3      	beq.n	802f0b0 <HAL_RCC_ClockConfig+0x140>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 802f108:	f7fd fa9c 	bl	802c644 <HAL_GetTick>
 802f10c:	1bc0      	subs	r0, r0, r7
 802f10e:	4540      	cmp	r0, r8
 802f110:	d9f3      	bls.n	802f0fa <HAL_RCC_ClockConfig+0x18a>
 802f112:	e764      	b.n	802efde <HAL_RCC_ClockConfig+0x6e>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 802f114:	2b03      	cmp	r3, #3
 802f116:	d102      	bne.n	802f11e <HAL_RCC_ClockConfig+0x1ae>
      if (LL_RCC_PLL_IsReady() == 0U)
 802f118:	f7ff fb9b 	bl	802e852 <LL_RCC_PLL_IsReady>
 802f11c:	e7dd      	b.n	802f0da <HAL_RCC_ClockConfig+0x16a>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 802f11e:	b913      	cbnz	r3, 802f126 <HAL_RCC_ClockConfig+0x1b6>
      if (LL_RCC_MSI_IsReady() == 0U)
 802f120:	f7ff fb88 	bl	802e834 <LL_RCC_MSI_IsReady>
 802f124:	e7d9      	b.n	802f0da <HAL_RCC_ClockConfig+0x16a>
      if (LL_RCC_HSI_IsReady() == 0U)
 802f126:	f7ff fb7f 	bl	802e828 <LL_RCC_HSI_IsReady>
 802f12a:	e7d6      	b.n	802f0da <HAL_RCC_ClockConfig+0x16a>
    __HAL_FLASH_SET_LATENCY(FLatency);
 802f12c:	6823      	ldr	r3, [r4, #0]
 802f12e:	f023 0307 	bic.w	r3, r3, #7
 802f132:	432b      	orrs	r3, r5
 802f134:	6023      	str	r3, [r4, #0]
    tickstart = HAL_GetTick();
 802f136:	f7fd fa85 	bl	802c644 <HAL_GetTick>
 802f13a:	4606      	mov	r6, r0
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 802f13c:	6823      	ldr	r3, [r4, #0]
 802f13e:	f003 0307 	and.w	r3, r3, #7
 802f142:	42ab      	cmp	r3, r5
 802f144:	d0ba      	beq.n	802f0bc <HAL_RCC_ClockConfig+0x14c>
      if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 802f146:	f7fd fa7d 	bl	802c644 <HAL_GetTick>
 802f14a:	1b80      	subs	r0, r0, r6
 802f14c:	2802      	cmp	r0, #2
 802f14e:	d9f5      	bls.n	802f13c <HAL_RCC_ClockConfig+0x1cc>
 802f150:	e745      	b.n	802efde <HAL_RCC_ClockConfig+0x6e>
 802f152:	bf00      	nop
 802f154:	58004000 	.word	0x58004000
 802f158:	2000344c 	.word	0x2000344c
 802f15c:	20003454 	.word	0x20003454

0802f160 <HAL_RCC_GetPCLK1Freq>:
{
 802f160:	b508      	push	{r3, lr}
  return ((uint32_t)(__LL_RCC_CALC_PCLK1_FREQ(HAL_RCC_GetHCLKFreq(), LL_RCC_GetAPB1Prescaler())));
 802f162:	f7ff fc55 	bl	802ea10 <HAL_RCC_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1));
 802f166:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802f16a:	4a04      	ldr	r2, [pc, #16]	; (802f17c <HAL_RCC_GetPCLK1Freq+0x1c>)
 802f16c:	689b      	ldr	r3, [r3, #8]
 802f16e:	f3c3 2302 	ubfx	r3, r3, #8, #3
 802f172:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
}
 802f176:	40d8      	lsrs	r0, r3
 802f178:	bd08      	pop	{r3, pc}
 802f17a:	bf00      	nop
 802f17c:	0803ba44 	.word	0x0803ba44

0802f180 <HAL_RCC_GetPCLK2Freq>:
{
 802f180:	b508      	push	{r3, lr}
  return ((uint32_t)(__LL_RCC_CALC_PCLK2_FREQ(HAL_RCC_GetHCLKFreq(), LL_RCC_GetAPB2Prescaler())));
 802f182:	f7ff fc45 	bl	802ea10 <HAL_RCC_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2));
 802f186:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802f18a:	4a04      	ldr	r2, [pc, #16]	; (802f19c <HAL_RCC_GetPCLK2Freq+0x1c>)
 802f18c:	689b      	ldr	r3, [r3, #8]
 802f18e:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 802f192:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
}
 802f196:	40d8      	lsrs	r0, r3
 802f198:	bd08      	pop	{r3, pc}
 802f19a:	bf00      	nop
 802f19c:	0803ba44 	.word	0x0803ba44

0802f1a0 <LL_RCC_LSE_IsReady>:
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? 1UL : 0UL);
 802f1a0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802f1a4:	f8d3 0090 	ldr.w	r0, [r3, #144]	; 0x90
}
 802f1a8:	f3c0 0040 	ubfx	r0, r0, #1, #1
 802f1ac:	4770      	bx	lr

0802f1ae <LL_RCC_SetI2CClockSource>:
  MODIFY_REG(RCC->CCIPR, ((I2CxSource >> 4) & 0x000FF000U), ((I2CxSource << 4) & 0x000FF000U));
 802f1ae:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 802f1b2:	0902      	lsrs	r2, r0, #4
 802f1b4:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 802f1b8:	f402 227f 	and.w	r2, r2, #1044480	; 0xff000
 802f1bc:	0100      	lsls	r0, r0, #4
 802f1be:	ea23 0302 	bic.w	r3, r3, r2
 802f1c2:	f400 207f 	and.w	r0, r0, #1044480	; 0xff000
 802f1c6:	4318      	orrs	r0, r3
 802f1c8:	f8c1 0088 	str.w	r0, [r1, #136]	; 0x88
}
 802f1cc:	4770      	bx	lr

0802f1ce <LL_RCC_SetLPTIMClockSource>:
  MODIFY_REG(RCC->CCIPR, (LPTIMxSource & 0xFFFF0000U), (LPTIMxSource << 16));
 802f1ce:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 802f1d2:	0c02      	lsrs	r2, r0, #16
 802f1d4:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 802f1d8:	0412      	lsls	r2, r2, #16
 802f1da:	ea23 0302 	bic.w	r3, r3, r2
 802f1de:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 802f1e2:	f8c1 0088 	str.w	r0, [r1, #136]	; 0x88
}
 802f1e6:	4770      	bx	lr

0802f1e8 <HAL_RCCEx_PeriphCLKConfig>:
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 802f1e8:	b570      	push	{r4, r5, r6, lr}

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*-------------------------- RTC clock source configuration ----------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 802f1ea:	6805      	ldr	r5, [r0, #0]
 802f1ec:	f415 3580 	ands.w	r5, r5, #65536	; 0x10000
{
 802f1f0:	4604      	mov	r4, r0
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 802f1f2:	d038      	beq.n	802f266 <HAL_RCCEx_PeriphCLKConfig+0x7e>
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));


    /* Enable write access to Backup domain */
    HAL_PWR_EnableBkUpAccess();
 802f1f4:	f7ff fa9c 	bl	802e730 <HAL_PWR_EnableBkUpAccess>

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 802f1f8:	f7fd fa24 	bl	802c644 <HAL_GetTick>

    while (!(READ_BIT(PWR->CR1, PWR_CR1_DBP) == (PWR_CR1_DBP)))
 802f1fc:	4e64      	ldr	r6, [pc, #400]	; (802f390 <HAL_RCCEx_PeriphCLKConfig+0x1a8>)
    tickstart = HAL_GetTick();
 802f1fe:	4605      	mov	r5, r0
    while (!(READ_BIT(PWR->CR1, PWR_CR1_DBP) == (PWR_CR1_DBP)))
 802f200:	6833      	ldr	r3, [r6, #0]
 802f202:	05db      	lsls	r3, r3, #23
 802f204:	d529      	bpl.n	802f25a <HAL_RCCEx_PeriphCLKConfig+0x72>
  return (uint32_t)(READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL));
 802f206:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
    }

    if (ret == HAL_OK)
    {
      /* Reset the Backup domain only if the RTC Clock source selection is modified */
      if (LL_RCC_GetRTCClockSource() != PeriphClkInit->RTCClockSelection)
 802f20a:	6b61      	ldr	r1, [r4, #52]	; 0x34
 802f20c:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 802f210:	f402 7240 	and.w	r2, r2, #768	; 0x300
 802f214:	4291      	cmp	r1, r2
 802f216:	d014      	beq.n	802f242 <HAL_RCCEx_PeriphCLKConfig+0x5a>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 802f218:	f8d3 1090 	ldr.w	r1, [r3, #144]	; 0x90
  SET_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 802f21c:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 802f220:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 802f224:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 802f228:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 802f22c:	f421 7040 	bic.w	r0, r1, #768	; 0x300
 802f230:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpregister;
      }

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSERDY))
 802f234:	078d      	lsls	r5, r1, #30
 802f236:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
        RCC->BDCR = tmpregister;
 802f23a:	f8c3 0090 	str.w	r0, [r3, #144]	; 0x90
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSERDY))
 802f23e:	f100 8096 	bmi.w	802f36e <HAL_RCCEx_PeriphCLKConfig+0x186>
  MODIFY_REG(RCC->BDCR, RCC_BDCR_RTCSEL, Source);
 802f242:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 802f246:	6b61      	ldr	r1, [r4, #52]	; 0x34
 802f248:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 802f24c:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 802f250:	430b      	orrs	r3, r1
 802f252:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  HAL_StatusTypeDef status  = HAL_OK;   /* Final status */
 802f256:	2500      	movs	r5, #0
}
 802f258:	e005      	b.n	802f266 <HAL_RCCEx_PeriphCLKConfig+0x7e>
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 802f25a:	f7fd f9f3 	bl	802c644 <HAL_GetTick>
 802f25e:	1b40      	subs	r0, r0, r5
 802f260:	2802      	cmp	r0, #2
 802f262:	d9cd      	bls.n	802f200 <HAL_RCCEx_PeriphCLKConfig+0x18>
        ret = HAL_TIMEOUT;
 802f264:	2503      	movs	r5, #3
    }

  }

  /*-------------------- USART1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 802f266:	6822      	ldr	r2, [r4, #0]
 802f268:	07d0      	lsls	r0, r2, #31
 802f26a:	d50a      	bpl.n	802f282 <HAL_RCCEx_PeriphCLKConfig+0x9a>
  MODIFY_REG(RCC->CCIPR, (USARTxSource >> 16), (USARTxSource & 0x0000FFFFU));
 802f26c:	f04f 40b0 	mov.w	r0, #1476395008	; 0x58000000
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 802f270:	6861      	ldr	r1, [r4, #4]
 802f272:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
 802f276:	ea23 4311 	bic.w	r3, r3, r1, lsr #16
 802f27a:	b289      	uxth	r1, r1
 802f27c:	430b      	orrs	r3, r1
 802f27e:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
  }

  /*-------------------- USART2 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 802f282:	0791      	lsls	r1, r2, #30
 802f284:	d50a      	bpl.n	802f29c <HAL_RCCEx_PeriphCLKConfig+0xb4>
 802f286:	f04f 40b0 	mov.w	r0, #1476395008	; 0x58000000
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 802f28a:	68a1      	ldr	r1, [r4, #8]
 802f28c:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
 802f290:	ea23 4311 	bic.w	r3, r3, r1, lsr #16
 802f294:	b289      	uxth	r1, r1
 802f296:	430b      	orrs	r3, r1
 802f298:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
  }

  /*-------------------- LPUART1 clock source configuration ------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 802f29c:	0693      	lsls	r3, r2, #26
 802f29e:	d509      	bpl.n	802f2b4 <HAL_RCCEx_PeriphCLKConfig+0xcc>
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_LPUART1SEL, LPUARTxSource);
 802f2a0:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 802f2a4:	6920      	ldr	r0, [r4, #16]
 802f2a6:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 802f2aa:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 802f2ae:	4303      	orrs	r3, r0
 802f2b0:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
  }

  /*-------------------- LPTIM1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 802f2b4:	0596      	lsls	r6, r2, #22
 802f2b6:	d502      	bpl.n	802f2be <HAL_RCCEx_PeriphCLKConfig+0xd6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));

    /* Configure the LPTIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 802f2b8:	6a20      	ldr	r0, [r4, #32]
 802f2ba:	f7ff ff88 	bl	802f1ce <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------- LPTIM2 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 802f2be:	6823      	ldr	r3, [r4, #0]
 802f2c0:	0558      	lsls	r0, r3, #21
 802f2c2:	d502      	bpl.n	802f2ca <HAL_RCCEx_PeriphCLKConfig+0xe2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM2CLKSOURCE(PeriphClkInit->Lptim2ClockSelection));

    /* Configure the LPTIM2 clock source */
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 802f2c4:	6a60      	ldr	r0, [r4, #36]	; 0x24
 802f2c6:	f7ff ff82 	bl	802f1ce <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------- LPTIM3 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM3) == (RCC_PERIPHCLK_LPTIM3))
 802f2ca:	6823      	ldr	r3, [r4, #0]
 802f2cc:	0519      	lsls	r1, r3, #20
 802f2ce:	d502      	bpl.n	802f2d6 <HAL_RCCEx_PeriphCLKConfig+0xee>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM3CLKSOURCE(PeriphClkInit->Lptim3ClockSelection));

    /* Configure the LPTIM3 clock source */
    __HAL_RCC_LPTIM3_CONFIG(PeriphClkInit->Lptim3ClockSelection);
 802f2d0:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 802f2d2:	f7ff ff7c 	bl	802f1ce <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------- I2C1 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 802f2d6:	6823      	ldr	r3, [r4, #0]
 802f2d8:	065a      	lsls	r2, r3, #25
 802f2da:	d502      	bpl.n	802f2e2 <HAL_RCCEx_PeriphCLKConfig+0xfa>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 802f2dc:	6960      	ldr	r0, [r4, #20]
 802f2de:	f7ff ff66 	bl	802f1ae <LL_RCC_SetI2CClockSource>
  }

  /*-------------------- I2C2 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 802f2e2:	6823      	ldr	r3, [r4, #0]
 802f2e4:	061b      	lsls	r3, r3, #24
 802f2e6:	d502      	bpl.n	802f2ee <HAL_RCCEx_PeriphCLKConfig+0x106>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 802f2e8:	69a0      	ldr	r0, [r4, #24]
 802f2ea:	f7ff ff60 	bl	802f1ae <LL_RCC_SetI2CClockSource>
  }

  /*-------------------- I2C3 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 802f2ee:	6823      	ldr	r3, [r4, #0]
 802f2f0:	05de      	lsls	r6, r3, #23
 802f2f2:	d502      	bpl.n	802f2fa <HAL_RCCEx_PeriphCLKConfig+0x112>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 802f2f4:	69e0      	ldr	r0, [r4, #28]
 802f2f6:	f7ff ff5a 	bl	802f1ae <LL_RCC_SetI2CClockSource>
  }

  /*-------------------- I2S2 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S2) == (RCC_PERIPHCLK_I2S2))
 802f2fa:	6821      	ldr	r1, [r4, #0]
 802f2fc:	06c8      	lsls	r0, r1, #27
 802f2fe:	d510      	bpl.n	802f322 <HAL_RCCEx_PeriphCLKConfig+0x13a>
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_I2S2SEL, I2SxSource);
 802f300:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2S2CLKSOURCE(PeriphClkInit->I2s2ClockSelection));

    /* Configure the I2S2 clock source */
    __HAL_RCC_I2S2_CONFIG(PeriphClkInit->I2s2ClockSelection);
 802f304:	68e0      	ldr	r0, [r4, #12]
 802f306:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 802f30a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 802f30e:	4303      	orrs	r3, r0
 802f310:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

    if (PeriphClkInit->I2s2ClockSelection == RCC_I2S2CLKSOURCE_PLL)
 802f314:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
    {
      /* Enable RCC_PLL_I2S2CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_I2S2CLK);
 802f318:	bf02      	ittt	eq
 802f31a:	68d3      	ldreq	r3, [r2, #12]
 802f31c:	f043 7380 	orreq.w	r3, r3, #16777216	; 0x1000000
 802f320:	60d3      	streq	r3, [r2, #12]
    }
  }

  /*-------------------- RNG clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 802f322:	040a      	lsls	r2, r1, #16
 802f324:	d50e      	bpl.n	802f344 <HAL_RCCEx_PeriphCLKConfig+0x15c>
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_RNGSEL, RNGxSource);
 802f326:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
  {
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 802f32a:	6b20      	ldr	r0, [r4, #48]	; 0x30
 802f32c:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 802f330:	f023 4340 	bic.w	r3, r3, #3221225472	; 0xc0000000
 802f334:	4303      	orrs	r3, r0
 802f336:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

    if (PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 802f33a:	b918      	cbnz	r0, 802f344 <HAL_RCCEx_PeriphCLKConfig+0x15c>
    {
      /* Enable RCC_PLL_RNGCLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_RNGCLK);
 802f33c:	68d3      	ldr	r3, [r2, #12]
 802f33e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 802f342:	60d3      	str	r3, [r2, #12]
    }
  }

  /*-------------------- ADC clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 802f344:	044b      	lsls	r3, r1, #17
 802f346:	d510      	bpl.n	802f36a <HAL_RCCEx_PeriphCLKConfig+0x182>
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_ADCSEL, ADCxSource);
 802f348:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));

    /* Configure the ADC interface clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 802f34c:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 802f34e:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 802f352:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 802f356:	430b      	orrs	r3, r1

    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLL)
 802f358:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
 802f35c:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
 802f360:	d103      	bne.n	802f36a <HAL_RCCEx_PeriphCLKConfig+0x182>
    {
      /* Enable RCC_PLL_RNGCLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_ADCCLK);
 802f362:	68d3      	ldr	r3, [r2, #12]
 802f364:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 802f368:	60d3      	str	r3, [r2, #12]
    }
  }

  return status;
}
 802f36a:	4628      	mov	r0, r5
 802f36c:	bd70      	pop	{r4, r5, r6, pc}
        tickstart = HAL_GetTick();
 802f36e:	f7fd f969 	bl	802c644 <HAL_GetTick>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802f372:	f241 3688 	movw	r6, #5000	; 0x1388
        tickstart = HAL_GetTick();
 802f376:	4605      	mov	r5, r0
        while (LL_RCC_LSE_IsReady() != 1U)
 802f378:	f7ff ff12 	bl	802f1a0 <LL_RCC_LSE_IsReady>
 802f37c:	2801      	cmp	r0, #1
 802f37e:	f43f af60 	beq.w	802f242 <HAL_RCCEx_PeriphCLKConfig+0x5a>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802f382:	f7fd f95f 	bl	802c644 <HAL_GetTick>
 802f386:	1b40      	subs	r0, r0, r5
 802f388:	42b0      	cmp	r0, r6
 802f38a:	d9f5      	bls.n	802f378 <HAL_RCCEx_PeriphCLKConfig+0x190>
 802f38c:	e76a      	b.n	802f264 <HAL_RCCEx_PeriphCLKConfig+0x7c>
 802f38e:	bf00      	nop
 802f390:	58000400 	.word	0x58000400

0802f394 <HAL_RTC_DeactivateAlarm>:
  *            @arg RTC_ALARM_A:  AlarmA
  *            @arg RTC_ALARM_B:  AlarmB
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_DeactivateAlarm(RTC_HandleTypeDef *hrtc, uint32_t Alarm)
{
 802f394:	b530      	push	{r4, r5, lr}
  /* Check the parameters */
  assert_param(IS_RTC_ALARM(Alarm));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 802f396:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 802f39a:	2b01      	cmp	r3, #1
 802f39c:	f04f 0202 	mov.w	r2, #2
 802f3a0:	d022      	beq.n	802f3e8 <HAL_RTC_DeactivateAlarm+0x54>

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f3a2:	4b19      	ldr	r3, [pc, #100]	; (802f408 <HAL_RTC_DeactivateAlarm+0x74>)
  hrtc->State = HAL_RTC_STATE_BUSY;
 802f3a4:	f880 202d 	strb.w	r2, [r0, #45]	; 0x2d
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f3a8:	24ca      	movs	r4, #202	; 0xca
  __HAL_LOCK(hrtc);
 802f3aa:	2501      	movs	r5, #1
 802f3ac:	f880 502c 	strb.w	r5, [r0, #44]	; 0x2c
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f3b0:	625c      	str	r4, [r3, #36]	; 0x24
 802f3b2:	2453      	movs	r4, #83	; 0x53
 802f3b4:	625c      	str	r4, [r3, #36]	; 0x24

  if (Alarm == RTC_ALARM_A)
 802f3b6:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 802f3ba:	6b04      	ldr	r4, [r0, #48]	; 0x30
 802f3bc:	d116      	bne.n	802f3ec <HAL_RTC_DeactivateAlarm+0x58>
  {
    /* AlarmA, In case of interrupt mode is used, the interrupt source must disabled */
    CLEAR_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 802f3be:	699a      	ldr	r2, [r3, #24]
 802f3c0:	f422 5288 	bic.w	r2, r2, #4352	; 0x1100
 802f3c4:	619a      	str	r2, [r3, #24]

    /* AlarmA, Clear SSCLR */
    CLEAR_BIT(RTC->ALRMASSR, RTC_ALRMASSR_SSCLR);
 802f3c6:	6c5a      	ldr	r2, [r3, #68]	; 0x44

    /* Store in the handle the Alarm A disabled */
    CLEAR_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRAMF);
 802f3c8:	f024 0401 	bic.w	r4, r4, #1
    CLEAR_BIT(RTC->ALRMASSR, RTC_ALRMASSR_SSCLR);
 802f3cc:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 802f3d0:	645a      	str	r2, [r3, #68]	; 0x44
    CLEAR_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRAMF);
 802f3d2:	6304      	str	r4, [r0, #48]	; 0x30

    /* Clear AlarmA flag */
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
 802f3d4:	65dd      	str	r5, [r3, #92]	; 0x5c
    /* Clear AlarmB flag */
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 802f3d6:	4b0c      	ldr	r3, [pc, #48]	; (802f408 <HAL_RTC_DeactivateAlarm+0x74>)
 802f3d8:	22ff      	movs	r2, #255	; 0xff
 802f3da:	625a      	str	r2, [r3, #36]	; 0x24

  hrtc->State = HAL_RTC_STATE_READY;
 802f3dc:	2301      	movs	r3, #1

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 802f3de:	2200      	movs	r2, #0
  hrtc->State = HAL_RTC_STATE_READY;
 802f3e0:	f880 302d 	strb.w	r3, [r0, #45]	; 0x2d
  __HAL_UNLOCK(hrtc);
 802f3e4:	f880 202c 	strb.w	r2, [r0, #44]	; 0x2c
  __HAL_LOCK(hrtc);
 802f3e8:	4610      	mov	r0, r2

  return HAL_OK;
}
 802f3ea:	bd30      	pop	{r4, r5, pc}
    CLEAR_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 802f3ec:	6999      	ldr	r1, [r3, #24]
 802f3ee:	f421 5108 	bic.w	r1, r1, #8704	; 0x2200
 802f3f2:	6199      	str	r1, [r3, #24]
    CLEAR_BIT(RTC->ALRMBSSR, RTC_ALRMBSSR_SSCLR);
 802f3f4:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
    CLEAR_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRBMF);
 802f3f6:	f024 0402 	bic.w	r4, r4, #2
    CLEAR_BIT(RTC->ALRMBSSR, RTC_ALRMBSSR_SSCLR);
 802f3fa:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 802f3fe:	64d9      	str	r1, [r3, #76]	; 0x4c
    CLEAR_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRBMF);
 802f400:	6304      	str	r4, [r0, #48]	; 0x30
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
 802f402:	65da      	str	r2, [r3, #92]	; 0x5c
 802f404:	e7e7      	b.n	802f3d6 <HAL_RTC_DeactivateAlarm+0x42>
 802f406:	bf00      	nop
 802f408:	40002800 	.word	0x40002800

0802f40c <HAL_RTC_AlarmIRQHandler>:
  * @brief  Handle Alarm interrupt request.
  * @param  hrtc RTC handle
  * @retval None
  */
void HAL_RTC_AlarmIRQHandler(RTC_HandleTypeDef *hrtc)
{
 802f40c:	b570      	push	{r4, r5, r6, lr}
  uint32_t tmp = READ_REG(RTC->MISR) & READ_REG(hrtc->IsEnabled.RtcFeatures);
 802f40e:	4d0b      	ldr	r5, [pc, #44]	; (802f43c <HAL_RTC_AlarmIRQHandler+0x30>)
 802f410:	6b03      	ldr	r3, [r0, #48]	; 0x30
 802f412:	6d6e      	ldr	r6, [r5, #84]	; 0x54
 802f414:	401e      	ands	r6, r3

  if ((tmp & RTC_MISR_ALRAMF) != 0U)
 802f416:	07f2      	lsls	r2, r6, #31
{
 802f418:	4604      	mov	r4, r0
  if ((tmp & RTC_MISR_ALRAMF) != 0U)
 802f41a:	d503      	bpl.n	802f424 <HAL_RTC_AlarmIRQHandler+0x18>
  {
    /* Clear the AlarmA interrupt pending bit */
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
 802f41c:	2301      	movs	r3, #1
 802f41e:	65eb      	str	r3, [r5, #92]	; 0x5c

#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
    /* Call Compare Match registered Callback */
    hrtc->AlarmAEventCallback(hrtc);
#else
    HAL_RTC_AlarmAEventCallback(hrtc);
 802f420:	f7fd fa26 	bl	802c870 <HAL_RTC_AlarmAEventCallback>
#endif
  }

  if ((tmp & RTC_MISR_ALRBMF) != 0U)
 802f424:	07b3      	lsls	r3, r6, #30
 802f426:	d504      	bpl.n	802f432 <HAL_RTC_AlarmIRQHandler+0x26>
  {
    /* Clear the AlarmB interrupt pending bit */
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
 802f428:	2302      	movs	r3, #2
 802f42a:	65eb      	str	r3, [r5, #92]	; 0x5c

#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
    /* Call Compare Match registered Callback */
    hrtc->AlarmBEventCallback(hrtc);
#else
    HAL_RTCEx_AlarmBEventCallback(hrtc);
 802f42c:	4620      	mov	r0, r4
 802f42e:	f000 f9c5 	bl	802f7bc <HAL_RTCEx_AlarmBEventCallback>
#endif
  }

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 802f432:	2301      	movs	r3, #1
 802f434:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
}
 802f438:	bd70      	pop	{r4, r5, r6, pc}
 802f43a:	bf00      	nop
 802f43c:	40002800 	.word	0x40002800

0802f440 <HAL_RTC_WaitForSynchro>:
  *         correctly copied into the RTC_TR and RTC_DR shadow registers.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef *hrtc)
{
 802f440:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart;

  UNUSED(hrtc);
  /* Clear RSF flag */
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_RSF);
 802f442:	4c0a      	ldr	r4, [pc, #40]	; (802f46c <HAL_RTC_WaitForSynchro+0x2c>)
 802f444:	68e3      	ldr	r3, [r4, #12]
 802f446:	f023 0320 	bic.w	r3, r3, #32
 802f44a:	60e3      	str	r3, [r4, #12]

  tickstart = HAL_GetTick();
 802f44c:	f7fd f8fa 	bl	802c644 <HAL_GetTick>
 802f450:	4605      	mov	r5, r0

  /* Wait the registers to be synchronised */
  while (READ_BIT(RTC->ICSR, RTC_ICSR_RSF) == 0U)
 802f452:	68e3      	ldr	r3, [r4, #12]
 802f454:	069b      	lsls	r3, r3, #26
 802f456:	d501      	bpl.n	802f45c <HAL_RTC_WaitForSynchro+0x1c>
    {
      return HAL_TIMEOUT;
    }
  }

  return HAL_OK;
 802f458:	2000      	movs	r0, #0
}
 802f45a:	bd38      	pop	{r3, r4, r5, pc}
    if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 802f45c:	f7fd f8f2 	bl	802c644 <HAL_GetTick>
 802f460:	1b40      	subs	r0, r0, r5
 802f462:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 802f466:	d9f4      	bls.n	802f452 <HAL_RTC_WaitForSynchro+0x12>
      return HAL_TIMEOUT;
 802f468:	2003      	movs	r0, #3
 802f46a:	e7f6      	b.n	802f45a <HAL_RTC_WaitForSynchro+0x1a>
 802f46c:	40002800 	.word	0x40002800

0802f470 <RTC_EnterInitMode>:
  *         __HAL_RTC_WRITEPROTECTION_DISABLE() before calling this function.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef *hrtc)
{
 802f470:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;

  UNUSED(hrtc);
  /* Check if the Initialization mode is set */
  if (READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U)
 802f474:	4d11      	ldr	r5, [pc, #68]	; (802f4bc <RTC_EnterInitMode+0x4c>)
 802f476:	68ec      	ldr	r4, [r5, #12]
 802f478:	f014 0440 	ands.w	r4, r4, #64	; 0x40
{
 802f47c:	4607      	mov	r7, r0
  if (READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U)
 802f47e:	d11a      	bne.n	802f4b6 <RTC_EnterInitMode+0x46>
  {
    /* Set the Initialization mode */
    SET_BIT(RTC->ICSR, RTC_ICSR_INIT);
 802f480:	68eb      	ldr	r3, [r5, #12]
 802f482:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 802f486:	60eb      	str	r3, [r5, #12]

    tickstart = HAL_GetTick();
 802f488:	f7fd f8dc 	bl	802c644 <HAL_GetTick>
    while ((READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U) && (status != HAL_TIMEOUT))
    {
      if ((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
      {
        status = HAL_TIMEOUT;
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 802f48c:	f04f 0803 	mov.w	r8, #3
    tickstart = HAL_GetTick();
 802f490:	4606      	mov	r6, r0
    while ((READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U) && (status != HAL_TIMEOUT))
 802f492:	68eb      	ldr	r3, [r5, #12]
 802f494:	065b      	lsls	r3, r3, #25
 802f496:	d401      	bmi.n	802f49c <RTC_EnterInitMode+0x2c>
 802f498:	2c03      	cmp	r4, #3
 802f49a:	d102      	bne.n	802f4a2 <RTC_EnterInitMode+0x32>
      }
    }
  }

  return status;
}
 802f49c:	4620      	mov	r0, r4
 802f49e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if ((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
 802f4a2:	f7fd f8cf 	bl	802c644 <HAL_GetTick>
 802f4a6:	1b80      	subs	r0, r0, r6
 802f4a8:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 802f4ac:	bf84      	itt	hi
 802f4ae:	f887 802d 	strbhi.w	r8, [r7, #45]	; 0x2d
        status = HAL_TIMEOUT;
 802f4b2:	2403      	movhi	r4, #3
 802f4b4:	e7ed      	b.n	802f492 <RTC_EnterInitMode+0x22>
  HAL_StatusTypeDef status = HAL_OK;
 802f4b6:	2400      	movs	r4, #0
 802f4b8:	e7f0      	b.n	802f49c <RTC_EnterInitMode+0x2c>
 802f4ba:	bf00      	nop
 802f4bc:	40002800 	.word	0x40002800

0802f4c0 <RTC_ExitInitMode>:
HAL_StatusTypeDef RTC_ExitInitMode(RTC_HandleTypeDef *hrtc)
{
  HAL_StatusTypeDef status = HAL_OK;

  /* Exit Initialization mode */
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_INIT);
 802f4c0:	4b10      	ldr	r3, [pc, #64]	; (802f504 <RTC_ExitInitMode+0x44>)
 802f4c2:	68da      	ldr	r2, [r3, #12]
 802f4c4:	f022 0280 	bic.w	r2, r2, #128	; 0x80
{
 802f4c8:	b510      	push	{r4, lr}
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_INIT);
 802f4ca:	60da      	str	r2, [r3, #12]

  /* If CR_BYPSHAD bit = 0, wait for synchro */
  if (READ_BIT(RTC->CR, RTC_CR_BYPSHAD) == 0U)
 802f4cc:	699a      	ldr	r2, [r3, #24]
 802f4ce:	0692      	lsls	r2, r2, #26
{
 802f4d0:	4604      	mov	r4, r0
  if (READ_BIT(RTC->CR, RTC_CR_BYPSHAD) == 0U)
 802f4d2:	d406      	bmi.n	802f4e2 <RTC_ExitInitMode+0x22>
  {
    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 802f4d4:	f7ff ffb4 	bl	802f440 <HAL_RTC_WaitForSynchro>
 802f4d8:	b110      	cbz	r0, 802f4e0 <RTC_ExitInitMode+0x20>
    {
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 802f4da:	2003      	movs	r0, #3
 802f4dc:	f884 002d 	strb.w	r0, [r4, #45]	; 0x2d
    /* Restore BYPSHAD bit */
    SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
  }

  return status;
}
 802f4e0:	bd10      	pop	{r4, pc}
    CLEAR_BIT(RTC->CR, RTC_CR_BYPSHAD);
 802f4e2:	699a      	ldr	r2, [r3, #24]
 802f4e4:	f022 0220 	bic.w	r2, r2, #32
 802f4e8:	619a      	str	r2, [r3, #24]
    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 802f4ea:	f7ff ffa9 	bl	802f440 <HAL_RTC_WaitForSynchro>
 802f4ee:	b110      	cbz	r0, 802f4f6 <RTC_ExitInitMode+0x36>
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 802f4f0:	2003      	movs	r0, #3
 802f4f2:	f884 002d 	strb.w	r0, [r4, #45]	; 0x2d
    SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
 802f4f6:	4a03      	ldr	r2, [pc, #12]	; (802f504 <RTC_ExitInitMode+0x44>)
 802f4f8:	6993      	ldr	r3, [r2, #24]
 802f4fa:	f043 0320 	orr.w	r3, r3, #32
 802f4fe:	6193      	str	r3, [r2, #24]
  return status;
 802f500:	e7ee      	b.n	802f4e0 <RTC_ExitInitMode+0x20>
 802f502:	bf00      	nop
 802f504:	40002800 	.word	0x40002800

0802f508 <HAL_RTC_Init>:
{
 802f508:	b538      	push	{r3, r4, r5, lr}
  if (hrtc != NULL)
 802f50a:	4604      	mov	r4, r0
 802f50c:	2800      	cmp	r0, #0
 802f50e:	d047      	beq.n	802f5a0 <HAL_RTC_Init+0x98>
    if (hrtc->State == HAL_RTC_STATE_RESET)
 802f510:	f890 302d 	ldrb.w	r3, [r0, #45]	; 0x2d
 802f514:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 802f518:	b91b      	cbnz	r3, 802f522 <HAL_RTC_Init+0x1a>
      hrtc->Lock = HAL_UNLOCKED;
 802f51a:	f880 202c 	strb.w	r2, [r0, #44]	; 0x2c
      HAL_RTC_MspInit(hrtc);
 802f51e:	f7fc ff05 	bl	802c32c <HAL_RTC_MspInit>
    __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f522:	4d20      	ldr	r5, [pc, #128]	; (802f5a4 <HAL_RTC_Init+0x9c>)
    hrtc->State = HAL_RTC_STATE_BUSY;
 802f524:	2302      	movs	r3, #2
 802f526:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
    __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f52a:	23ca      	movs	r3, #202	; 0xca
 802f52c:	626b      	str	r3, [r5, #36]	; 0x24
 802f52e:	2353      	movs	r3, #83	; 0x53
 802f530:	626b      	str	r3, [r5, #36]	; 0x24
    status = RTC_EnterInitMode(hrtc);
 802f532:	4620      	mov	r0, r4
 802f534:	f7ff ff9c 	bl	802f470 <RTC_EnterInitMode>
    if (status == HAL_OK)
 802f538:	bb70      	cbnz	r0, 802f598 <HAL_RTC_Init+0x90>
      CLEAR_BIT(RTC->CR, (RTC_CR_FMT | RTC_CR_POL | RTC_CR_OSEL | RTC_CR_TAMPOE));
 802f53a:	69ab      	ldr	r3, [r5, #24]
 802f53c:	f023 638e 	bic.w	r3, r3, #74448896	; 0x4700000
 802f540:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 802f544:	61ab      	str	r3, [r5, #24]
      SET_BIT(RTC->CR, (hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity));
 802f546:	6921      	ldr	r1, [r4, #16]
 802f548:	6863      	ldr	r3, [r4, #4]
 802f54a:	69aa      	ldr	r2, [r5, #24]
 802f54c:	430b      	orrs	r3, r1
 802f54e:	4313      	orrs	r3, r2
 802f550:	69a2      	ldr	r2, [r4, #24]
 802f552:	4313      	orrs	r3, r2
 802f554:	61ab      	str	r3, [r5, #24]
      WRITE_REG(RTC->PRER, ((hrtc->Init.SynchPrediv) | (hrtc->Init.AsynchPrediv << RTC_PRER_PREDIV_A_Pos)));
 802f556:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 802f55a:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 802f55e:	612b      	str	r3, [r5, #16]
      MODIFY_REG(RTC->ICSR, RTC_ICSR_BIN | RTC_ICSR_BCDU, hrtc->Init.BinMode | hrtc->Init.BinMixBcdU);
 802f560:	e9d4 3109 	ldrd	r3, r1, [r4, #36]	; 0x24
 802f564:	68ea      	ldr	r2, [r5, #12]
 802f566:	430b      	orrs	r3, r1
 802f568:	f422 52f8 	bic.w	r2, r2, #7936	; 0x1f00
 802f56c:	4313      	orrs	r3, r2
 802f56e:	60eb      	str	r3, [r5, #12]
      status = RTC_ExitInitMode(hrtc);
 802f570:	4620      	mov	r0, r4
 802f572:	f7ff ffa5 	bl	802f4c0 <RTC_ExitInitMode>
      if (status == HAL_OK)
 802f576:	b978      	cbnz	r0, 802f598 <HAL_RTC_Init+0x90>
        MODIFY_REG(RTC->CR, \
 802f578:	e9d4 1307 	ldrd	r1, r3, [r4, #28]
 802f57c:	69aa      	ldr	r2, [r5, #24]
 802f57e:	430b      	orrs	r3, r1
 802f580:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
 802f584:	4313      	orrs	r3, r2
 802f586:	6962      	ldr	r2, [r4, #20]
 802f588:	4313      	orrs	r3, r2
 802f58a:	61ab      	str	r3, [r5, #24]
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 802f58c:	23ff      	movs	r3, #255	; 0xff
 802f58e:	626b      	str	r3, [r5, #36]	; 0x24
      hrtc->State = HAL_RTC_STATE_READY;
 802f590:	2301      	movs	r3, #1
 802f592:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
}
 802f596:	bd38      	pop	{r3, r4, r5, pc}
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 802f598:	4b02      	ldr	r3, [pc, #8]	; (802f5a4 <HAL_RTC_Init+0x9c>)
 802f59a:	22ff      	movs	r2, #255	; 0xff
 802f59c:	625a      	str	r2, [r3, #36]	; 0x24
    if (status == HAL_OK)
 802f59e:	e7fa      	b.n	802f596 <HAL_RTC_Init+0x8e>
  HAL_StatusTypeDef status = HAL_ERROR;
 802f5a0:	2001      	movs	r0, #1
 802f5a2:	e7f8      	b.n	802f596 <HAL_RTC_Init+0x8e>
 802f5a4:	40002800 	.word	0x40002800

0802f5a8 <RTC_ByteToBcd2>:
  * @param  Value Byte to be converted
  * @retval Converted byte
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0U;
 802f5a8:	2300      	movs	r3, #0
  uint8_t tmp_Value = Value;

  while (tmp_Value >= 10U)
 802f5aa:	2809      	cmp	r0, #9
 802f5ac:	d803      	bhi.n	802f5b6 <RTC_ByteToBcd2+0xe>
  {
    bcdhigh++;
    tmp_Value -= 10U;
  }

  return ((uint8_t)(bcdhigh << 4U) | tmp_Value);
 802f5ae:	ea40 1003 	orr.w	r0, r0, r3, lsl #4
}
 802f5b2:	b2c0      	uxtb	r0, r0
 802f5b4:	4770      	bx	lr
    tmp_Value -= 10U;
 802f5b6:	380a      	subs	r0, #10
    bcdhigh++;
 802f5b8:	3301      	adds	r3, #1
    tmp_Value -= 10U;
 802f5ba:	b2c0      	uxtb	r0, r0
 802f5bc:	e7f5      	b.n	802f5aa <RTC_ByteToBcd2+0x2>
	...

0802f5c0 <HAL_RTC_SetAlarm_IT>:
{
 802f5c0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  __HAL_LOCK(hrtc);
 802f5c4:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 802f5c8:	2b01      	cmp	r3, #1
{
 802f5ca:	4605      	mov	r5, r0
 802f5cc:	f04f 0002 	mov.w	r0, #2
  __HAL_LOCK(hrtc);
 802f5d0:	d067      	beq.n	802f6a2 <HAL_RTC_SetAlarm_IT+0xe2>
 802f5d2:	2301      	movs	r3, #1
 802f5d4:	f885 302c 	strb.w	r3, [r5, #44]	; 0x2c
  binaryMode = READ_BIT(RTC->ICSR, RTC_ICSR_BIN);
 802f5d8:	4b4c      	ldr	r3, [pc, #304]	; (802f70c <HAL_RTC_SetAlarm_IT+0x14c>)
  hrtc->State = HAL_RTC_STATE_BUSY;
 802f5da:	f885 002d 	strb.w	r0, [r5, #45]	; 0x2d
  binaryMode = READ_BIT(RTC->ICSR, RTC_ICSR_BIN);
 802f5de:	68de      	ldr	r6, [r3, #12]
 802f5e0:	f406 7640 	and.w	r6, r6, #768	; 0x300
  if (binaryMode != RTC_BINARY_ONLY)
 802f5e4:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
 802f5e8:	d076      	beq.n	802f6d8 <HAL_RTC_SetAlarm_IT+0x118>
    if (Format == RTC_FORMAT_BIN)
 802f5ea:	694c      	ldr	r4, [r1, #20]
 802f5ec:	7808      	ldrb	r0, [r1, #0]
 802f5ee:	f891 8001 	ldrb.w	r8, [r1, #1]
 802f5f2:	f891 a002 	ldrb.w	sl, [r1, #2]
 802f5f6:	f891 7024 	ldrb.w	r7, [r1, #36]	; 0x24
 802f5fa:	2a00      	cmp	r2, #0
 802f5fc:	d153      	bne.n	802f6a6 <HAL_RTC_SetAlarm_IT+0xe6>
      if (READ_BIT(RTC->CR, RTC_CR_FMT) != 0U)
 802f5fe:	699a      	ldr	r2, [r3, #24]
 802f600:	f012 0240 	ands.w	r2, r2, #64	; 0x40
        sAlarm->AlarmTime.TimeFormat = 0x00U;
 802f604:	bf08      	it	eq
 802f606:	70ca      	strbeq	r2, [r1, #3]
      tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 802f608:	f7ff ffce 	bl	802f5a8 <RTC_ByteToBcd2>
 802f60c:	4681      	mov	r9, r0
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
 802f60e:	4640      	mov	r0, r8
 802f610:	f7ff ffca 	bl	802f5a8 <RTC_ByteToBcd2>
 802f614:	4680      	mov	r8, r0
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds) << RTC_ALRMAR_SU_Pos) | \
 802f616:	4650      	mov	r0, sl
 802f618:	f7ff ffc6 	bl	802f5a8 <RTC_ByteToBcd2>
 802f61c:	4682      	mov	sl, r0
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << RTC_ALRMAR_DU_Pos) | \
 802f61e:	4638      	mov	r0, r7
 802f620:	f7ff ffc2 	bl	802f5a8 <RTC_ByteToBcd2>
      tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 802f624:	6a0a      	ldr	r2, [r1, #32]
                ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
 802f626:	78cb      	ldrb	r3, [r1, #3]
      tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 802f628:	4314      	orrs	r4, r2
 802f62a:	ea44 5483 	orr.w	r4, r4, r3, lsl #22
 802f62e:	ea44 030a 	orr.w	r3, r4, sl
 802f632:	ea43 4309 	orr.w	r3, r3, r9, lsl #16
 802f636:	ea43 2308 	orr.w	r3, r3, r8, lsl #8
 802f63a:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f63e:	4a33      	ldr	r2, [pc, #204]	; (802f70c <HAL_RTC_SetAlarm_IT+0x14c>)
 802f640:	20ca      	movs	r0, #202	; 0xca
 802f642:	6250      	str	r0, [r2, #36]	; 0x24
 802f644:	2053      	movs	r0, #83	; 0x53
 802f646:	6250      	str	r0, [r2, #36]	; 0x24
  if (sAlarm->Alarm == RTC_ALARM_A)
 802f648:	6a8c      	ldr	r4, [r1, #40]	; 0x28
 802f64a:	6988      	ldr	r0, [r1, #24]
 802f64c:	f5b4 7f80 	cmp.w	r4, #256	; 0x100
    CLEAR_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 802f650:	6994      	ldr	r4, [r2, #24]
  if (sAlarm->Alarm == RTC_ALARM_A)
 802f652:	d143      	bne.n	802f6dc <HAL_RTC_SetAlarm_IT+0x11c>
    CLEAR_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 802f654:	f424 5488 	bic.w	r4, r4, #4352	; 0x1100
 802f658:	6194      	str	r4, [r2, #24]
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
 802f65a:	2401      	movs	r4, #1
 802f65c:	65d4      	str	r4, [r2, #92]	; 0x5c
    if (binaryMode == RTC_BINARY_ONLY)
 802f65e:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
      RTC->ALRMASSR = sAlarm->AlarmSubSecondMask | sAlarm->BinaryAutoClr;
 802f662:	bf0a      	itet	eq
 802f664:	69cb      	ldreq	r3, [r1, #28]
      WRITE_REG(RTC->ALRMAR, tmpreg);
 802f666:	6413      	strne	r3, [r2, #64]	; 0x40
      RTC->ALRMASSR = sAlarm->AlarmSubSecondMask | sAlarm->BinaryAutoClr;
 802f668:	4318      	orreq	r0, r3
      WRITE_REG(RTC->ALRMASSR, sAlarm->AlarmSubSecondMask);
 802f66a:	6450      	str	r0, [r2, #68]	; 0x44
    WRITE_REG(RTC->ALRABINR, sAlarm->AlarmTime.SubSeconds);
 802f66c:	4b27      	ldr	r3, [pc, #156]	; (802f70c <HAL_RTC_SetAlarm_IT+0x14c>)
 802f66e:	684a      	ldr	r2, [r1, #4]
 802f670:	671a      	str	r2, [r3, #112]	; 0x70
    SET_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRAMF);
 802f672:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 802f674:	f042 0201 	orr.w	r2, r2, #1
 802f678:	632a      	str	r2, [r5, #48]	; 0x30
    SET_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 802f67a:	699a      	ldr	r2, [r3, #24]
 802f67c:	f442 5288 	orr.w	r2, r2, #4352	; 0x1100
    SET_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 802f680:	619a      	str	r2, [r3, #24]
  __HAL_RTC_ALARM_EXTI_ENABLE_IT();
 802f682:	4a23      	ldr	r2, [pc, #140]	; (802f710 <HAL_RTC_SetAlarm_IT+0x150>)
 802f684:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
 802f688:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 802f68c:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 802f690:	4b1e      	ldr	r3, [pc, #120]	; (802f70c <HAL_RTC_SetAlarm_IT+0x14c>)
 802f692:	22ff      	movs	r2, #255	; 0xff
 802f694:	625a      	str	r2, [r3, #36]	; 0x24
  __HAL_UNLOCK(hrtc);
 802f696:	2000      	movs	r0, #0
  hrtc->State = HAL_RTC_STATE_READY;
 802f698:	2301      	movs	r3, #1
 802f69a:	f885 302d 	strb.w	r3, [r5, #45]	; 0x2d
  __HAL_UNLOCK(hrtc);
 802f69e:	f885 002c 	strb.w	r0, [r5, #44]	; 0x2c
}
 802f6a2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      if( sAlarm->AlarmMask != RTC_ALARMMASK_ALL )
 802f6a6:	f1b4 3f80 	cmp.w	r4, #2155905152	; 0x80808080
 802f6aa:	d007      	beq.n	802f6bc <HAL_RTC_SetAlarm_IT+0xfc>
        if( sAlarm->AlarmMask != RTC_ALARMMASK_HOURS )
 802f6ac:	f5b4 0f00 	cmp.w	r4, #8388608	; 0x800000
 802f6b0:	d004      	beq.n	802f6bc <HAL_RTC_SetAlarm_IT+0xfc>
          if (READ_BIT(RTC->CR, RTC_CR_FMT) != 0U)
 802f6b2:	699a      	ldr	r2, [r3, #24]
 802f6b4:	f012 0240 	ands.w	r2, r2, #64	; 0x40
            sAlarm->AlarmTime.TimeFormat = 0x00U;
 802f6b8:	bf08      	it	eq
 802f6ba:	70ca      	strbeq	r2, [r1, #3]
      tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 802f6bc:	6a0a      	ldr	r2, [r1, #32]
 802f6be:	4314      	orrs	r4, r2
 802f6c0:	ea44 040a 	orr.w	r4, r4, sl
 802f6c4:	ea44 4300 	orr.w	r3, r4, r0, lsl #16
                ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
 802f6c8:	78c8      	ldrb	r0, [r1, #3]
      tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 802f6ca:	ea43 2308 	orr.w	r3, r3, r8, lsl #8
 802f6ce:	ea43 5380 	orr.w	r3, r3, r0, lsl #22
 802f6d2:	ea43 6307 	orr.w	r3, r3, r7, lsl #24
 802f6d6:	e7b2      	b.n	802f63e <HAL_RTC_SetAlarm_IT+0x7e>
  uint32_t tmpreg = 0;
 802f6d8:	2300      	movs	r3, #0
 802f6da:	e7b0      	b.n	802f63e <HAL_RTC_SetAlarm_IT+0x7e>
    CLEAR_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 802f6dc:	f424 5408 	bic.w	r4, r4, #8704	; 0x2200
 802f6e0:	6194      	str	r4, [r2, #24]
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
 802f6e2:	2402      	movs	r4, #2
 802f6e4:	65d4      	str	r4, [r2, #92]	; 0x5c
    if (binaryMode == RTC_BINARY_ONLY)
 802f6e6:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
      WRITE_REG(RTC->ALRMBSSR, sAlarm->AlarmSubSecondMask | sAlarm->BinaryAutoClr);
 802f6ea:	bf0a      	itet	eq
 802f6ec:	69cb      	ldreq	r3, [r1, #28]
      WRITE_REG(RTC->ALRMBR, tmpreg);
 802f6ee:	6493      	strne	r3, [r2, #72]	; 0x48
      WRITE_REG(RTC->ALRMBSSR, sAlarm->AlarmSubSecondMask | sAlarm->BinaryAutoClr);
 802f6f0:	4318      	orreq	r0, r3
      WRITE_REG(RTC->ALRMBSSR, sAlarm->AlarmSubSecondMask);
 802f6f2:	64d0      	str	r0, [r2, #76]	; 0x4c
    WRITE_REG(RTC->ALRBBINR, sAlarm->AlarmTime.SubSeconds);
 802f6f4:	4b05      	ldr	r3, [pc, #20]	; (802f70c <HAL_RTC_SetAlarm_IT+0x14c>)
 802f6f6:	684a      	ldr	r2, [r1, #4]
 802f6f8:	675a      	str	r2, [r3, #116]	; 0x74
    SET_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRBMF);
 802f6fa:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 802f6fc:	f042 0202 	orr.w	r2, r2, #2
 802f700:	632a      	str	r2, [r5, #48]	; 0x30
    SET_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 802f702:	699a      	ldr	r2, [r3, #24]
 802f704:	f442 5208 	orr.w	r2, r2, #8704	; 0x2200
 802f708:	e7ba      	b.n	802f680 <HAL_RTC_SetAlarm_IT+0xc0>
 802f70a:	bf00      	nop
 802f70c:	40002800 	.word	0x40002800
 802f710:	58000800 	.word	0x58000800

0802f714 <HAL_RTCEx_EnableBypassShadow>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_EnableBypassShadow(RTC_HandleTypeDef *hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);
 802f714:	f890 202c 	ldrb.w	r2, [r0, #44]	; 0x2c
 802f718:	2a01      	cmp	r2, #1
{
 802f71a:	4603      	mov	r3, r0
 802f71c:	f04f 0002 	mov.w	r0, #2
  __HAL_LOCK(hrtc);
 802f720:	d012      	beq.n	802f748 <HAL_RTCEx_EnableBypassShadow+0x34>

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f722:	4a0a      	ldr	r2, [pc, #40]	; (802f74c <HAL_RTCEx_EnableBypassShadow+0x38>)
  hrtc->State = HAL_RTC_STATE_BUSY;
 802f724:	f883 002d 	strb.w	r0, [r3, #45]	; 0x2d
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f728:	21ca      	movs	r1, #202	; 0xca
 802f72a:	6251      	str	r1, [r2, #36]	; 0x24
 802f72c:	2153      	movs	r1, #83	; 0x53
 802f72e:	6251      	str	r1, [r2, #36]	; 0x24

  /* Set the BYPSHAD bit */
  SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
 802f730:	6991      	ldr	r1, [r2, #24]
 802f732:	f041 0120 	orr.w	r1, r1, #32
 802f736:	6191      	str	r1, [r2, #24]

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 802f738:	21ff      	movs	r1, #255	; 0xff
 802f73a:	6251      	str	r1, [r2, #36]	; 0x24

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 802f73c:	2000      	movs	r0, #0
  hrtc->State = HAL_RTC_STATE_READY;
 802f73e:	2201      	movs	r2, #1
 802f740:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
  __HAL_UNLOCK(hrtc);
 802f744:	f883 002c 	strb.w	r0, [r3, #44]	; 0x2c

  return HAL_OK;
}
 802f748:	4770      	bx	lr
 802f74a:	bf00      	nop
 802f74c:	40002800 	.word	0x40002800

0802f750 <HAL_RTCEx_SetSSRU_IT>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetSSRU_IT(RTC_HandleTypeDef *hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);
 802f750:	f890 202c 	ldrb.w	r2, [r0, #44]	; 0x2c
 802f754:	2a01      	cmp	r2, #1
{
 802f756:	4603      	mov	r3, r0
 802f758:	f04f 0002 	mov.w	r0, #2
  __HAL_LOCK(hrtc);
 802f75c:	d019      	beq.n	802f792 <HAL_RTCEx_SetSSRU_IT+0x42>

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f75e:	4a0d      	ldr	r2, [pc, #52]	; (802f794 <HAL_RTCEx_SetSSRU_IT+0x44>)
  hrtc->State = HAL_RTC_STATE_BUSY;
 802f760:	f883 002d 	strb.w	r0, [r3, #45]	; 0x2d
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f764:	21ca      	movs	r1, #202	; 0xca
 802f766:	6251      	str	r1, [r2, #36]	; 0x24
 802f768:	2153      	movs	r1, #83	; 0x53
 802f76a:	6251      	str	r1, [r2, #36]	; 0x24

  /* Enable IT SSRU */
  __HAL_RTC_SSRU_ENABLE_IT(hrtc, RTC_IT_SSRU);
 802f76c:	6991      	ldr	r1, [r2, #24]

  /* RTC SSRU Interrupt Configuration: EXTI configuration */
  __HAL_RTC_SSRU_EXTI_ENABLE_IT();
 802f76e:	480a      	ldr	r0, [pc, #40]	; (802f798 <HAL_RTCEx_SetSSRU_IT+0x48>)
  __HAL_RTC_SSRU_ENABLE_IT(hrtc, RTC_IT_SSRU);
 802f770:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 802f774:	6191      	str	r1, [r2, #24]
  __HAL_RTC_SSRU_EXTI_ENABLE_IT();
 802f776:	f8d0 1080 	ldr.w	r1, [r0, #128]	; 0x80
 802f77a:	f441 2180 	orr.w	r1, r1, #262144	; 0x40000
 802f77e:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 802f782:	21ff      	movs	r1, #255	; 0xff
 802f784:	6251      	str	r1, [r2, #36]	; 0x24

  hrtc->State = HAL_RTC_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 802f786:	2000      	movs	r0, #0
  hrtc->State = HAL_RTC_STATE_READY;
 802f788:	2201      	movs	r2, #1
 802f78a:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
  __HAL_UNLOCK(hrtc);
 802f78e:	f883 002c 	strb.w	r0, [r3, #44]	; 0x2c

  return HAL_OK;
}
 802f792:	4770      	bx	lr
 802f794:	40002800 	.word	0x40002800
 802f798:	58000800 	.word	0x58000800

0802f79c <HAL_RTCEx_SSRUIRQHandler>:
  * @param  hrtc RTC handle
  * @retval None
  */
void HAL_RTCEx_SSRUIRQHandler(RTC_HandleTypeDef *hrtc)
{
  if ((RTC->MISR & RTC_MISR_SSRUMF) != 0u)
 802f79c:	4b06      	ldr	r3, [pc, #24]	; (802f7b8 <HAL_RTCEx_SSRUIRQHandler+0x1c>)
 802f79e:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 802f7a0:	0652      	lsls	r2, r2, #25
{
 802f7a2:	b510      	push	{r4, lr}
 802f7a4:	4604      	mov	r4, r0
  if ((RTC->MISR & RTC_MISR_SSRUMF) != 0u)
 802f7a6:	d503      	bpl.n	802f7b0 <HAL_RTCEx_SSRUIRQHandler+0x14>
  {
    /* Immediately clear flags */
    RTC->SCR = RTC_SCR_CSSRUF;
 802f7a8:	2240      	movs	r2, #64	; 0x40
 802f7aa:	65da      	str	r2, [r3, #92]	; 0x5c
    /* SSRU callback */
#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
    /* Call SSRUEvent registered Callback */
    hrtc->SSRUEventCallback(hrtc);
#else
    HAL_RTCEx_SSRUEventCallback(hrtc);
 802f7ac:	f7fd f862 	bl	802c874 <HAL_RTCEx_SSRUEventCallback>
#endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
  }

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 802f7b0:	2301      	movs	r3, #1
 802f7b2:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
}
 802f7b6:	bd10      	pop	{r4, pc}
 802f7b8:	40002800 	.word	0x40002800

0802f7bc <HAL_RTCEx_AlarmBEventCallback>:
 802f7bc:	4770      	bx	lr

0802f7be <HAL_RTCEx_BKUPWrite>:
  UNUSED(hrtc);
  /* Check the parameters */
  assert_param(IS_RTC_BKP(BackupRegister));

  tmp = (uint32_t) & (TAMP->BKP0R);
  tmp += (BackupRegister * 4U);
 802f7be:	0089      	lsls	r1, r1, #2
 802f7c0:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 802f7c4:	f501 4131 	add.w	r1, r1, #45312	; 0xb100

  /* Write the specified register */
  *(__IO uint32_t *)tmp = (uint32_t)Data;
 802f7c8:	600a      	str	r2, [r1, #0]
}
 802f7ca:	4770      	bx	lr

0802f7cc <HAL_RTCEx_BKUPRead>:
  UNUSED(hrtc);
  /* Check the parameters */
  assert_param(IS_RTC_BKP(BackupRegister));

  tmp = (uint32_t) & (TAMP->BKP0R);
  tmp += (BackupRegister * 4U);
 802f7cc:	0089      	lsls	r1, r1, #2
 802f7ce:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 802f7d2:	f501 4131 	add.w	r1, r1, #45312	; 0xb100

  /* Read the specified register */
  return (*(__IO uint32_t *)tmp);
 802f7d6:	6808      	ldr	r0, [r1, #0]
}
 802f7d8:	4770      	bx	lr
	...

0802f7dc <LL_PWR_UnselectSUBGHZSPI_NSS>:
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 802f7dc:	4a03      	ldr	r2, [pc, #12]	; (802f7ec <LL_PWR_UnselectSUBGHZSPI_NSS+0x10>)
 802f7de:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 802f7e2:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 802f7e6:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 802f7ea:	4770      	bx	lr
 802f7ec:	58000400 	.word	0x58000400

0802f7f0 <LL_PWR_SelectSUBGHZSPI_NSS>:
  CLEAR_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 802f7f0:	4a03      	ldr	r2, [pc, #12]	; (802f800 <LL_PWR_SelectSUBGHZSPI_NSS+0x10>)
 802f7f2:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 802f7f6:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 802f7fa:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 802f7fe:	4770      	bx	lr
 802f800:	58000400 	.word	0x58000400

0802f804 <SUBGHZSPI_Init>:
{
  /* Check the parameters */
  assert_param(IS_SUBGHZ_ALL_INSTANCE(SUBGHZSPI));

  /* Disable SUBGHZSPI Peripheral */
  CLEAR_BIT(SUBGHZSPI->CR1, SPI_CR1_SPE);
 802f804:	4b07      	ldr	r3, [pc, #28]	; (802f824 <SUBGHZSPI_Init+0x20>)
 802f806:	681a      	ldr	r2, [r3, #0]
 802f808:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 802f80c:	601a      	str	r2, [r3, #0]
   *       NSS management: Internal (Done with External bit inside PWR        *
   *  Communication speed: BaudratePrescaler                             *
   *            First bit: MSB                                                *
   *      CRC calculation: Disable                                            *
   *--------------------------------------------------------------------------*/
  WRITE_REG(SUBGHZSPI->CR1, (SPI_CR1_MSTR | SPI_CR1_SSI | BaudratePrescaler | SPI_CR1_SSM));
 802f80e:	f440 7041 	orr.w	r0, r0, #772	; 0x304
   *            Data Size: 8bits                                              *
   *              TI Mode: Disable                                            *
   *            NSS Pulse: Disable                                            *
   *    Rx FIFO Threshold: 8bits                                              *
   *--------------------------------------------------------------------------*/
  WRITE_REG(SUBGHZSPI->CR2, (SPI_CR2_FRXTH |  SPI_CR2_DS_0 | SPI_CR2_DS_1 | SPI_CR2_DS_2));
 802f812:	f44f 52b8 	mov.w	r2, #5888	; 0x1700
  WRITE_REG(SUBGHZSPI->CR1, (SPI_CR1_MSTR | SPI_CR1_SSI | BaudratePrescaler | SPI_CR1_SSM));
 802f816:	6018      	str	r0, [r3, #0]
  WRITE_REG(SUBGHZSPI->CR2, (SPI_CR2_FRXTH |  SPI_CR2_DS_0 | SPI_CR2_DS_1 | SPI_CR2_DS_2));
 802f818:	605a      	str	r2, [r3, #4]

  /* Enable SUBGHZSPI Peripheral */
  SET_BIT(SUBGHZSPI->CR1, SPI_CR1_SPE);
 802f81a:	681a      	ldr	r2, [r3, #0]
 802f81c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 802f820:	601a      	str	r2, [r3, #0]
}
 802f822:	4770      	bx	lr
 802f824:	58010000 	.word	0x58010000

0802f828 <HAL_SUBGHZ_Init>:
{
 802f828:	b513      	push	{r0, r1, r4, lr}
  if (hsubghz == NULL)
 802f82a:	4604      	mov	r4, r0
 802f82c:	2800      	cmp	r0, #0
 802f82e:	d042      	beq.n	802f8b6 <HAL_SUBGHZ_Init+0x8e>
  if (hsubghz->State == HAL_SUBGHZ_STATE_RESET)
 802f830:	7983      	ldrb	r3, [r0, #6]
 802f832:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 802f836:	b913      	cbnz	r3, 802f83e <HAL_SUBGHZ_Init+0x16>
    hsubghz->Lock = HAL_UNLOCKED;
 802f838:	7142      	strb	r2, [r0, #5]
    HAL_SUBGHZ_MspInit(hsubghz);
 802f83a:	f7fc fe15 	bl	802c468 <HAL_SUBGHZ_MspInit>
  hsubghz->State = HAL_SUBGHZ_STATE_BUSY;
 802f83e:	2302      	movs	r3, #2
 802f840:	71a3      	strb	r3, [r4, #6]
  CLEAR_BIT(RCC->CSR, RCC_CSR_RFRST);
 802f842:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802f846:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 802f84a:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 802f84e:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f852:	4a1a      	ldr	r2, [pc, #104]	; (802f8bc <HAL_SUBGHZ_Init+0x94>)
 802f854:	6811      	ldr	r1, [r2, #0]
 802f856:	221c      	movs	r2, #28
 802f858:	434a      	muls	r2, r1
 802f85a:	0cd2      	lsrs	r2, r2, #19
 802f85c:	2164      	movs	r1, #100	; 0x64
 802f85e:	434a      	muls	r2, r1
 802f860:	9201      	str	r2, [sp, #4]
    if (count == 0U)
 802f862:	9a01      	ldr	r2, [sp, #4]
 802f864:	b9f2      	cbnz	r2, 802f8a4 <HAL_SUBGHZ_Init+0x7c>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 802f866:	2101      	movs	r1, #1
 802f868:	60a1      	str	r1, [r4, #8]
  LL_PWR_UnselectSUBGHZSPI_NSS();
 802f86a:	f7ff ffb7 	bl	802f7dc <LL_PWR_UnselectSUBGHZSPI_NSS>
  SET_BIT(EXTI->IMR2, ExtiLine);
 802f86e:	4a14      	ldr	r2, [pc, #80]	; (802f8c0 <HAL_SUBGHZ_Init+0x98>)
 802f870:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 802f874:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 802f878:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  MODIFY_REG(PWR->CR3, PWR_CR3_EWRFBUSY, RadioBusyTrigger);
 802f87c:	4b11      	ldr	r3, [pc, #68]	; (802f8c4 <HAL_SUBGHZ_Init+0x9c>)
 802f87e:	689a      	ldr	r2, [r3, #8]
 802f880:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 802f884:	609a      	str	r2, [r3, #8]
  WRITE_REG(PWR->SCR, PWR_SCR_CWRFBUSYF);
 802f886:	f44f 6200 	mov.w	r2, #2048	; 0x800
 802f88a:	619a      	str	r2, [r3, #24]
  if (status == HAL_OK)
 802f88c:	b929      	cbnz	r1, 802f89a <HAL_SUBGHZ_Init+0x72>
    SUBGHZSPI_Init(hsubghz->Init.BaudratePrescaler);
 802f88e:	6820      	ldr	r0, [r4, #0]
 802f890:	f7ff ffb8 	bl	802f804 <SUBGHZSPI_Init>
    hsubghz->DeepSleep = SUBGHZ_DEEP_SLEEP_ENABLE;
 802f894:	2301      	movs	r3, #1
 802f896:	7123      	strb	r3, [r4, #4]
    hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_NONE;
 802f898:	60a1      	str	r1, [r4, #8]
  hsubghz->State     = HAL_SUBGHZ_STATE_READY;
 802f89a:	2301      	movs	r3, #1
 802f89c:	71a3      	strb	r3, [r4, #6]
}
 802f89e:	4608      	mov	r0, r1
 802f8a0:	b002      	add	sp, #8
 802f8a2:	bd10      	pop	{r4, pc}
    count--;
 802f8a4:	9a01      	ldr	r2, [sp, #4]
 802f8a6:	3a01      	subs	r2, #1
 802f8a8:	9201      	str	r2, [sp, #4]
  return ((READ_BIT(RCC->CSR, RCC_CSR_RFRSTF) == (RCC_CSR_RFRSTF)) ? 1UL : 0UL);
 802f8aa:	f8d3 1094 	ldr.w	r1, [r3, #148]	; 0x94
 802f8ae:	f411 4180 	ands.w	r1, r1, #16384	; 0x4000
 802f8b2:	d1d6      	bne.n	802f862 <HAL_SUBGHZ_Init+0x3a>
 802f8b4:	e7d9      	b.n	802f86a <HAL_SUBGHZ_Init+0x42>
    return status;
 802f8b6:	2101      	movs	r1, #1
 802f8b8:	e7f1      	b.n	802f89e <HAL_SUBGHZ_Init+0x76>
 802f8ba:	bf00      	nop
 802f8bc:	2000344c 	.word	0x2000344c
 802f8c0:	58000800 	.word	0x58000800
 802f8c4:	58000400 	.word	0x58000400

0802f8c8 <SUBGHZSPI_Transmit>:
  * @param  Data  data to transmit
  * @retval HAL status
  */
HAL_StatusTypeDef SUBGHZSPI_Transmit(SUBGHZ_HandleTypeDef *hsubghz,
                                     uint8_t Data)
{
 802f8c8:	b513      	push	{r0, r1, r4, lr}
 802f8ca:	4602      	mov	r2, r0
  HAL_StatusTypeDef status = HAL_OK;
  __IO uint32_t count;

  /* Handle Tx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f8cc:	4817      	ldr	r0, [pc, #92]	; (802f92c <SUBGHZSPI_Transmit+0x64>)
 802f8ce:	6804      	ldr	r4, [r0, #0]
 802f8d0:	231c      	movs	r3, #28
 802f8d2:	4363      	muls	r3, r4
 802f8d4:	0cdb      	lsrs	r3, r3, #19
 802f8d6:	2464      	movs	r4, #100	; 0x64
 802f8d8:	4363      	muls	r3, r4
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_TXE) != (SPI_SR_TXE));
 802f8da:	4c15      	ldr	r4, [pc, #84]	; (802f930 <SUBGHZSPI_Transmit+0x68>)
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f8dc:	9301      	str	r3, [sp, #4]
 802f8de:	4603      	mov	r3, r0
    if (count == 0U)
 802f8e0:	9801      	ldr	r0, [sp, #4]
 802f8e2:	b998      	cbnz	r0, 802f90c <SUBGHZSPI_Transmit+0x44>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 802f8e4:	2001      	movs	r0, #1
 802f8e6:	6090      	str	r0, [r2, #8]

  /* Transmit Data*/
#if defined (__GNUC__)
  __IO uint8_t *spidr = ((__IO uint8_t *)&SUBGHZSPI->DR);
  *spidr = Data;
 802f8e8:	4c12      	ldr	r4, [pc, #72]	; (802f934 <SUBGHZSPI_Transmit+0x6c>)
 802f8ea:	7021      	strb	r1, [r4, #0]
  *((__IO uint8_t *)&SUBGHZSPI->DR) = Data;
#endif /* __GNUC__ */

  /* Handle Rx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f8ec:	6819      	ldr	r1, [r3, #0]
 802f8ee:	231c      	movs	r3, #28
 802f8f0:	434b      	muls	r3, r1
 802f8f2:	0cdb      	lsrs	r3, r3, #19
 802f8f4:	2164      	movs	r1, #100	; 0x64
 802f8f6:	434b      	muls	r3, r1
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_RXNE) != (SPI_SR_RXNE));
 802f8f8:	490d      	ldr	r1, [pc, #52]	; (802f930 <SUBGHZSPI_Transmit+0x68>)
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f8fa:	9301      	str	r3, [sp, #4]
    if (count == 0U)
 802f8fc:	9b01      	ldr	r3, [sp, #4]
 802f8fe:	b96b      	cbnz	r3, 802f91c <SUBGHZSPI_Transmit+0x54>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 802f900:	2001      	movs	r0, #1
 802f902:	6090      	str	r0, [r2, #8]

  /* Flush Rx data */
  READ_REG(SUBGHZSPI->DR);
 802f904:	4b0a      	ldr	r3, [pc, #40]	; (802f930 <SUBGHZSPI_Transmit+0x68>)
 802f906:	68db      	ldr	r3, [r3, #12]

  return status;
}
 802f908:	b002      	add	sp, #8
 802f90a:	bd10      	pop	{r4, pc}
    count--;
 802f90c:	9801      	ldr	r0, [sp, #4]
 802f90e:	3801      	subs	r0, #1
 802f910:	9001      	str	r0, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_TXE) != (SPI_SR_TXE));
 802f912:	68a0      	ldr	r0, [r4, #8]
 802f914:	0780      	lsls	r0, r0, #30
 802f916:	d5e3      	bpl.n	802f8e0 <SUBGHZSPI_Transmit+0x18>
  HAL_StatusTypeDef status = HAL_OK;
 802f918:	2000      	movs	r0, #0
 802f91a:	e7e5      	b.n	802f8e8 <SUBGHZSPI_Transmit+0x20>
    count--;
 802f91c:	9b01      	ldr	r3, [sp, #4]
 802f91e:	3b01      	subs	r3, #1
 802f920:	9301      	str	r3, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_RXNE) != (SPI_SR_RXNE));
 802f922:	688b      	ldr	r3, [r1, #8]
 802f924:	07db      	lsls	r3, r3, #31
 802f926:	d5e9      	bpl.n	802f8fc <SUBGHZSPI_Transmit+0x34>
 802f928:	e7ec      	b.n	802f904 <SUBGHZSPI_Transmit+0x3c>
 802f92a:	bf00      	nop
 802f92c:	2000344c 	.word	0x2000344c
 802f930:	58010000 	.word	0x58010000
 802f934:	5801000c 	.word	0x5801000c

0802f938 <SUBGHZSPI_Receive>:
  * @param  pData  pointer on data to receive
  * @retval HAL status
  */
HAL_StatusTypeDef SUBGHZSPI_Receive(SUBGHZ_HandleTypeDef *hsubghz,
                                    uint8_t *pData)
{
 802f938:	b537      	push	{r0, r1, r2, r4, r5, lr}
 802f93a:	4602      	mov	r2, r0
  HAL_StatusTypeDef status = HAL_OK;
  __IO uint32_t count;

  /* Handle Tx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f93c:	4818      	ldr	r0, [pc, #96]	; (802f9a0 <SUBGHZSPI_Receive+0x68>)
 802f93e:	6804      	ldr	r4, [r0, #0]
 802f940:	231c      	movs	r3, #28
 802f942:	4363      	muls	r3, r4
 802f944:	0cdb      	lsrs	r3, r3, #19
 802f946:	2464      	movs	r4, #100	; 0x64
 802f948:	4363      	muls	r3, r4
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_TXE) != (SPI_SR_TXE));
 802f94a:	4c16      	ldr	r4, [pc, #88]	; (802f9a4 <SUBGHZSPI_Receive+0x6c>)
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f94c:	9301      	str	r3, [sp, #4]
 802f94e:	4603      	mov	r3, r0
    if (count == 0U)
 802f950:	9801      	ldr	r0, [sp, #4]
 802f952:	b9a8      	cbnz	r0, 802f980 <SUBGHZSPI_Receive+0x48>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 802f954:	2001      	movs	r0, #1
 802f956:	6090      	str	r0, [r2, #8]

  /* Transmit Data*/
#if defined (__GNUC__)
  __IO uint8_t *spidr = ((__IO uint8_t *)&SUBGHZSPI->DR);
  *spidr = SUBGHZ_DUMMY_DATA;
 802f958:	4c13      	ldr	r4, [pc, #76]	; (802f9a8 <SUBGHZSPI_Receive+0x70>)
 802f95a:	25ff      	movs	r5, #255	; 0xff
 802f95c:	7025      	strb	r5, [r4, #0]
  *((__IO uint8_t *)&SUBGHZSPI->DR) = SUBGHZ_DUMMY_DATA;
#endif /* __GNUC__ */

  /* Handle Rx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f95e:	681c      	ldr	r4, [r3, #0]
 802f960:	231c      	movs	r3, #28
 802f962:	4363      	muls	r3, r4
 802f964:	0cdb      	lsrs	r3, r3, #19
 802f966:	2464      	movs	r4, #100	; 0x64
 802f968:	4363      	muls	r3, r4
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_RXNE) != (SPI_SR_RXNE));
 802f96a:	4c0e      	ldr	r4, [pc, #56]	; (802f9a4 <SUBGHZSPI_Receive+0x6c>)
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f96c:	9301      	str	r3, [sp, #4]
    if (count == 0U)
 802f96e:	9b01      	ldr	r3, [sp, #4]
 802f970:	b973      	cbnz	r3, 802f990 <SUBGHZSPI_Receive+0x58>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 802f972:	2001      	movs	r0, #1
 802f974:	6090      	str	r0, [r2, #8]

  /* Retrieve pData */
  *pData = (uint8_t)(READ_REG(SUBGHZSPI->DR));
 802f976:	4b0b      	ldr	r3, [pc, #44]	; (802f9a4 <SUBGHZSPI_Receive+0x6c>)
 802f978:	68db      	ldr	r3, [r3, #12]
 802f97a:	700b      	strb	r3, [r1, #0]

  return status;
}
 802f97c:	b003      	add	sp, #12
 802f97e:	bd30      	pop	{r4, r5, pc}
    count--;
 802f980:	9801      	ldr	r0, [sp, #4]
 802f982:	3801      	subs	r0, #1
 802f984:	9001      	str	r0, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_TXE) != (SPI_SR_TXE));
 802f986:	68a0      	ldr	r0, [r4, #8]
 802f988:	0780      	lsls	r0, r0, #30
 802f98a:	d5e1      	bpl.n	802f950 <SUBGHZSPI_Receive+0x18>
  HAL_StatusTypeDef status = HAL_OK;
 802f98c:	2000      	movs	r0, #0
 802f98e:	e7e3      	b.n	802f958 <SUBGHZSPI_Receive+0x20>
    count--;
 802f990:	9b01      	ldr	r3, [sp, #4]
 802f992:	3b01      	subs	r3, #1
 802f994:	9301      	str	r3, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_RXNE) != (SPI_SR_RXNE));
 802f996:	68a3      	ldr	r3, [r4, #8]
 802f998:	07db      	lsls	r3, r3, #31
 802f99a:	d5e8      	bpl.n	802f96e <SUBGHZSPI_Receive+0x36>
 802f99c:	e7eb      	b.n	802f976 <SUBGHZSPI_Receive+0x3e>
 802f99e:	bf00      	nop
 802f9a0:	2000344c 	.word	0x2000344c
 802f9a4:	58010000 	.word	0x58010000
 802f9a8:	5801000c 	.word	0x5801000c

0802f9ac <SUBGHZ_WaitOnBusy>:
  HAL_StatusTypeDef status;
  __IO uint32_t count;
  uint32_t mask;

  status = HAL_OK;
  count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_RFBUSY_LOOP_TIME;
 802f9ac:	4b0f      	ldr	r3, [pc, #60]	; (802f9ec <SUBGHZ_WaitOnBusy+0x40>)
{
 802f9ae:	b513      	push	{r0, r1, r4, lr}
  count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_RFBUSY_LOOP_TIME;
 802f9b0:	681a      	ldr	r2, [r3, #0]
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYMS) == (PWR_SR2_RFBUSYMS)) ? 1UL : 0UL);
 802f9b2:	4c0f      	ldr	r4, [pc, #60]	; (802f9f0 <SUBGHZ_WaitOnBusy+0x44>)
 802f9b4:	2318      	movs	r3, #24
 802f9b6:	4353      	muls	r3, r2
 802f9b8:	0d1b      	lsrs	r3, r3, #20
 802f9ba:	2264      	movs	r2, #100	; 0x64
 802f9bc:	4353      	muls	r3, r2
{
 802f9be:	4601      	mov	r1, r0
  count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_RFBUSY_LOOP_TIME;
 802f9c0:	9301      	str	r3, [sp, #4]
 802f9c2:	6962      	ldr	r2, [r4, #20]
  /* Wait until Busy signal is set */
  do
  {
    mask = LL_PWR_IsActiveFlag_RFBUSYMS();

    if (count == 0U)
 802f9c4:	9b01      	ldr	r3, [sp, #4]
 802f9c6:	f002 0204 	and.w	r2, r2, #4
 802f9ca:	b923      	cbnz	r3, 802f9d6 <SUBGHZ_WaitOnBusy+0x2a>
    {
      status  = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_RF_BUSY;
 802f9cc:	2302      	movs	r3, #2
 802f9ce:	608b      	str	r3, [r1, #8]
      status  = HAL_ERROR;
 802f9d0:	2001      	movs	r0, #1
    }
    count--;
  } while ((LL_PWR_IsActiveFlag_RFBUSYS()& mask) == 1UL);

  return status;
}
 802f9d2:	b002      	add	sp, #8
 802f9d4:	bd10      	pop	{r4, pc}
    count--;
 802f9d6:	9b01      	ldr	r3, [sp, #4]
 802f9d8:	3b01      	subs	r3, #1
 802f9da:	9301      	str	r3, [sp, #4]
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYS) == (PWR_SR2_RFBUSYS)) ? 1UL : 0UL);
 802f9dc:	6960      	ldr	r0, [r4, #20]
 802f9de:	f010 0002 	ands.w	r0, r0, #2
 802f9e2:	d0f6      	beq.n	802f9d2 <SUBGHZ_WaitOnBusy+0x26>
  } while ((LL_PWR_IsActiveFlag_RFBUSYS()& mask) == 1UL);
 802f9e4:	2a00      	cmp	r2, #0
 802f9e6:	d1ec      	bne.n	802f9c2 <SUBGHZ_WaitOnBusy+0x16>
  status = HAL_OK;
 802f9e8:	4610      	mov	r0, r2
 802f9ea:	e7f2      	b.n	802f9d2 <SUBGHZ_WaitOnBusy+0x26>
 802f9ec:	2000344c 	.word	0x2000344c
 802f9f0:	58000400 	.word	0x58000400

0802f9f4 <SUBGHZ_CheckDeviceReady>:
{
 802f9f4:	b507      	push	{r0, r1, r2, lr}
  if (hsubghz->DeepSleep == SUBGHZ_DEEP_SLEEP_ENABLE)
 802f9f6:	7903      	ldrb	r3, [r0, #4]
 802f9f8:	2b01      	cmp	r3, #1
 802f9fa:	d10f      	bne.n	802fa1c <SUBGHZ_CheckDeviceReady+0x28>
    count  = SUBGHZ_NSS_LOOP_TIME;
 802f9fc:	4b0a      	ldr	r3, [pc, #40]	; (802fa28 <SUBGHZ_CheckDeviceReady+0x34>)
 802f9fe:	681a      	ldr	r2, [r3, #0]
 802fa00:	2318      	movs	r3, #24
 802fa02:	4353      	muls	r3, r2
 802fa04:	0c1b      	lsrs	r3, r3, #16
 802fa06:	9301      	str	r3, [sp, #4]
    LL_PWR_SelectSUBGHZSPI_NSS();
 802fa08:	f7ff fef2 	bl	802f7f0 <LL_PWR_SelectSUBGHZSPI_NSS>
      count--;
 802fa0c:	9b01      	ldr	r3, [sp, #4]
 802fa0e:	3b01      	subs	r3, #1
 802fa10:	9301      	str	r3, [sp, #4]
    } while (count != 0UL);
 802fa12:	9b01      	ldr	r3, [sp, #4]
 802fa14:	2b00      	cmp	r3, #0
 802fa16:	d1f9      	bne.n	802fa0c <SUBGHZ_CheckDeviceReady+0x18>
    LL_PWR_UnselectSUBGHZSPI_NSS();
 802fa18:	f7ff fee0 	bl	802f7dc <LL_PWR_UnselectSUBGHZSPI_NSS>
}
 802fa1c:	b003      	add	sp, #12
 802fa1e:	f85d eb04 	ldr.w	lr, [sp], #4
  return (SUBGHZ_WaitOnBusy(hsubghz));
 802fa22:	f7ff bfc3 	b.w	802f9ac <SUBGHZ_WaitOnBusy>
 802fa26:	bf00      	nop
 802fa28:	2000344c 	.word	0x2000344c

0802fa2c <HAL_SUBGHZ_WriteRegisters>:
{
 802fa2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802fa2e:	461e      	mov	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fa30:	7983      	ldrb	r3, [r0, #6]
 802fa32:	2b01      	cmp	r3, #1
{
 802fa34:	4615      	mov	r5, r2
 802fa36:	4604      	mov	r4, r0
 802fa38:	460f      	mov	r7, r1
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fa3a:	b2da      	uxtb	r2, r3
 802fa3c:	d12d      	bne.n	802fa9a <HAL_SUBGHZ_WriteRegisters+0x6e>
    __HAL_LOCK(hsubghz);
 802fa3e:	7943      	ldrb	r3, [r0, #5]
 802fa40:	2b01      	cmp	r3, #1
 802fa42:	d02a      	beq.n	802fa9a <HAL_SUBGHZ_WriteRegisters+0x6e>
    hsubghz->State = HAL_SUBGHZ_STATE_BUSY;
 802fa44:	2302      	movs	r3, #2
    __HAL_LOCK(hsubghz);
 802fa46:	7142      	strb	r2, [r0, #5]
    hsubghz->State = HAL_SUBGHZ_STATE_BUSY;
 802fa48:	7183      	strb	r3, [r0, #6]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 802fa4a:	f7ff ffd3 	bl	802f9f4 <SUBGHZ_CheckDeviceReady>
    LL_PWR_SelectSUBGHZSPI_NSS();
 802fa4e:	f7ff fecf 	bl	802f7f0 <LL_PWR_SelectSUBGHZSPI_NSS>
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_WRITE_REGISTER);
 802fa52:	210d      	movs	r1, #13
 802fa54:	4620      	mov	r0, r4
 802fa56:	f7ff ff37 	bl	802f8c8 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)((Address & 0xFF00U) >> 8U));
 802fa5a:	0a39      	lsrs	r1, r7, #8
 802fa5c:	4620      	mov	r0, r4
 802fa5e:	f7ff ff33 	bl	802f8c8 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)(Address & 0x00FFU));
 802fa62:	b2f9      	uxtb	r1, r7
 802fa64:	4620      	mov	r0, r4
 802fa66:	f7ff ff2f 	bl	802f8c8 <SUBGHZSPI_Transmit>
HAL_StatusTypeDef HAL_SUBGHZ_WriteRegisters(SUBGHZ_HandleTypeDef *hsubghz,
 802fa6a:	442e      	add	r6, r5
    for (uint16_t i = 0U; i < Size; i++)
 802fa6c:	42b5      	cmp	r5, r6
 802fa6e:	d10e      	bne.n	802fa8e <HAL_SUBGHZ_WriteRegisters+0x62>
    LL_PWR_UnselectSUBGHZSPI_NSS();
 802fa70:	f7ff feb4 	bl	802f7dc <LL_PWR_UnselectSUBGHZSPI_NSS>
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 802fa74:	4620      	mov	r0, r4
 802fa76:	f7ff ff99 	bl	802f9ac <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 802fa7a:	68a0      	ldr	r0, [r4, #8]
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fa7c:	2301      	movs	r3, #1
      status = HAL_ERROR;
 802fa7e:	3800      	subs	r0, #0
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fa80:	71a3      	strb	r3, [r4, #6]
    __HAL_UNLOCK(hsubghz);
 802fa82:	f04f 0300 	mov.w	r3, #0
      status = HAL_ERROR;
 802fa86:	bf18      	it	ne
 802fa88:	2001      	movne	r0, #1
    __HAL_UNLOCK(hsubghz);
 802fa8a:	7163      	strb	r3, [r4, #5]
}
 802fa8c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void)SUBGHZSPI_Transmit(hsubghz, pBuffer[i]);
 802fa8e:	f815 1b01 	ldrb.w	r1, [r5], #1
 802fa92:	4620      	mov	r0, r4
 802fa94:	f7ff ff18 	bl	802f8c8 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 802fa98:	e7e8      	b.n	802fa6c <HAL_SUBGHZ_WriteRegisters+0x40>
    return HAL_BUSY;
 802fa9a:	2002      	movs	r0, #2
 802fa9c:	e7f6      	b.n	802fa8c <HAL_SUBGHZ_WriteRegisters+0x60>

0802fa9e <HAL_SUBGHZ_ReadRegisters>:
{
 802fa9e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802faa0:	461e      	mov	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802faa2:	7983      	ldrb	r3, [r0, #6]
 802faa4:	2b01      	cmp	r3, #1
{
 802faa6:	4615      	mov	r5, r2
 802faa8:	4604      	mov	r4, r0
 802faaa:	460f      	mov	r7, r1
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802faac:	b2da      	uxtb	r2, r3
 802faae:	d12f      	bne.n	802fb10 <HAL_SUBGHZ_ReadRegisters+0x72>
    __HAL_LOCK(hsubghz);
 802fab0:	7943      	ldrb	r3, [r0, #5]
 802fab2:	2b01      	cmp	r3, #1
 802fab4:	d02c      	beq.n	802fb10 <HAL_SUBGHZ_ReadRegisters+0x72>
 802fab6:	7142      	strb	r2, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 802fab8:	f7ff ff9c 	bl	802f9f4 <SUBGHZ_CheckDeviceReady>
    LL_PWR_SelectSUBGHZSPI_NSS();
 802fabc:	f7ff fe98 	bl	802f7f0 <LL_PWR_SelectSUBGHZSPI_NSS>
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_READ_REGISTER);
 802fac0:	211d      	movs	r1, #29
 802fac2:	4620      	mov	r0, r4
 802fac4:	f7ff ff00 	bl	802f8c8 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)((Address & 0xFF00U) >> 8U));
 802fac8:	0a39      	lsrs	r1, r7, #8
 802faca:	4620      	mov	r0, r4
 802facc:	f7ff fefc 	bl	802f8c8 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)(Address & 0x00FFU));
 802fad0:	b2f9      	uxtb	r1, r7
 802fad2:	4620      	mov	r0, r4
 802fad4:	f7ff fef8 	bl	802f8c8 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, 0U);
 802fad8:	2100      	movs	r1, #0
 802fada:	4620      	mov	r0, r4
 802fadc:	f7ff fef4 	bl	802f8c8 <SUBGHZSPI_Transmit>
HAL_StatusTypeDef HAL_SUBGHZ_ReadRegisters(SUBGHZ_HandleTypeDef *hsubghz,
 802fae0:	442e      	add	r6, r5
    for (uint16_t i = 0U; i < Size; i++)
 802fae2:	42b5      	cmp	r5, r6
 802fae4:	d10e      	bne.n	802fb04 <HAL_SUBGHZ_ReadRegisters+0x66>
    LL_PWR_UnselectSUBGHZSPI_NSS();
 802fae6:	f7ff fe79 	bl	802f7dc <LL_PWR_UnselectSUBGHZSPI_NSS>
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 802faea:	4620      	mov	r0, r4
 802faec:	f7ff ff5e 	bl	802f9ac <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 802faf0:	68a0      	ldr	r0, [r4, #8]
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802faf2:	2301      	movs	r3, #1
      status = HAL_ERROR;
 802faf4:	3800      	subs	r0, #0
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802faf6:	71a3      	strb	r3, [r4, #6]
    __HAL_UNLOCK(hsubghz);
 802faf8:	f04f 0300 	mov.w	r3, #0
      status = HAL_ERROR;
 802fafc:	bf18      	it	ne
 802fafe:	2001      	movne	r0, #1
    __HAL_UNLOCK(hsubghz);
 802fb00:	7163      	strb	r3, [r4, #5]
}
 802fb02:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void)SUBGHZSPI_Receive(hsubghz, (pData));
 802fb04:	4629      	mov	r1, r5
 802fb06:	4620      	mov	r0, r4
 802fb08:	f7ff ff16 	bl	802f938 <SUBGHZSPI_Receive>
      pData++;
 802fb0c:	3501      	adds	r5, #1
    for (uint16_t i = 0U; i < Size; i++)
 802fb0e:	e7e8      	b.n	802fae2 <HAL_SUBGHZ_ReadRegisters+0x44>
    return HAL_BUSY;
 802fb10:	2002      	movs	r0, #2
 802fb12:	e7f6      	b.n	802fb02 <HAL_SUBGHZ_ReadRegisters+0x64>

0802fb14 <HAL_SUBGHZ_ExecSetCmd>:
{
 802fb14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802fb16:	461f      	mov	r7, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fb18:	7983      	ldrb	r3, [r0, #6]
 802fb1a:	2b01      	cmp	r3, #1
{
 802fb1c:	4615      	mov	r5, r2
 802fb1e:	4604      	mov	r4, r0
 802fb20:	460e      	mov	r6, r1
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fb22:	b2da      	uxtb	r2, r3
 802fb24:	d12c      	bne.n	802fb80 <HAL_SUBGHZ_ExecSetCmd+0x6c>
    __HAL_LOCK(hsubghz);
 802fb26:	7943      	ldrb	r3, [r0, #5]
 802fb28:	2b01      	cmp	r3, #1
 802fb2a:	d029      	beq.n	802fb80 <HAL_SUBGHZ_ExecSetCmd+0x6c>
 802fb2c:	7142      	strb	r2, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 802fb2e:	f7ff ff61 	bl	802f9f4 <SUBGHZ_CheckDeviceReady>
    if ((Command == RADIO_SET_SLEEP) || (Command == RADIO_SET_RXDUTYCYCLE))
 802fb32:	f006 03ef 	and.w	r3, r6, #239	; 0xef
 802fb36:	f1a3 0284 	sub.w	r2, r3, #132	; 0x84
 802fb3a:	4253      	negs	r3, r2
 802fb3c:	4153      	adcs	r3, r2
 802fb3e:	7123      	strb	r3, [r4, #4]
    LL_PWR_SelectSUBGHZSPI_NSS();
 802fb40:	f7ff fe56 	bl	802f7f0 <LL_PWR_SelectSUBGHZSPI_NSS>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)Command);
 802fb44:	4631      	mov	r1, r6
 802fb46:	4620      	mov	r0, r4
 802fb48:	f7ff febe 	bl	802f8c8 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 802fb4c:	442f      	add	r7, r5
 802fb4e:	42af      	cmp	r7, r5
 802fb50:	d110      	bne.n	802fb74 <HAL_SUBGHZ_ExecSetCmd+0x60>
    LL_PWR_UnselectSUBGHZSPI_NSS();
 802fb52:	f7ff fe43 	bl	802f7dc <LL_PWR_UnselectSUBGHZSPI_NSS>
    if (Command != RADIO_SET_SLEEP)
 802fb56:	2e84      	cmp	r6, #132	; 0x84
 802fb58:	d002      	beq.n	802fb60 <HAL_SUBGHZ_ExecSetCmd+0x4c>
      (void)SUBGHZ_WaitOnBusy(hsubghz);
 802fb5a:	4620      	mov	r0, r4
 802fb5c:	f7ff ff26 	bl	802f9ac <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 802fb60:	68a0      	ldr	r0, [r4, #8]
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fb62:	2301      	movs	r3, #1
      status = HAL_ERROR;
 802fb64:	3800      	subs	r0, #0
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fb66:	71a3      	strb	r3, [r4, #6]
    __HAL_UNLOCK(hsubghz);
 802fb68:	f04f 0300 	mov.w	r3, #0
      status = HAL_ERROR;
 802fb6c:	bf18      	it	ne
 802fb6e:	2001      	movne	r0, #1
    __HAL_UNLOCK(hsubghz);
 802fb70:	7163      	strb	r3, [r4, #5]
}
 802fb72:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void)SUBGHZSPI_Transmit(hsubghz, pBuffer[i]);
 802fb74:	f815 1b01 	ldrb.w	r1, [r5], #1
 802fb78:	4620      	mov	r0, r4
 802fb7a:	f7ff fea5 	bl	802f8c8 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 802fb7e:	e7e6      	b.n	802fb4e <HAL_SUBGHZ_ExecSetCmd+0x3a>
    return HAL_BUSY;
 802fb80:	2002      	movs	r0, #2
 802fb82:	e7f6      	b.n	802fb72 <HAL_SUBGHZ_ExecSetCmd+0x5e>

0802fb84 <HAL_SUBGHZ_WriteBuffer>:
{
 802fb84:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802fb86:	461e      	mov	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fb88:	7983      	ldrb	r3, [r0, #6]
 802fb8a:	2b01      	cmp	r3, #1
{
 802fb8c:	4615      	mov	r5, r2
 802fb8e:	4604      	mov	r4, r0
 802fb90:	460f      	mov	r7, r1
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fb92:	b2da      	uxtb	r2, r3
 802fb94:	d127      	bne.n	802fbe6 <HAL_SUBGHZ_WriteBuffer+0x62>
    __HAL_LOCK(hsubghz);
 802fb96:	7943      	ldrb	r3, [r0, #5]
 802fb98:	2b01      	cmp	r3, #1
 802fb9a:	d024      	beq.n	802fbe6 <HAL_SUBGHZ_WriteBuffer+0x62>
 802fb9c:	7142      	strb	r2, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 802fb9e:	f7ff ff29 	bl	802f9f4 <SUBGHZ_CheckDeviceReady>
    LL_PWR_SelectSUBGHZSPI_NSS();
 802fba2:	f7ff fe25 	bl	802f7f0 <LL_PWR_SelectSUBGHZSPI_NSS>
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_WRITE_BUFFER);
 802fba6:	210e      	movs	r1, #14
 802fba8:	4620      	mov	r0, r4
 802fbaa:	f7ff fe8d 	bl	802f8c8 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, Offset);
 802fbae:	4639      	mov	r1, r7
 802fbb0:	4620      	mov	r0, r4
 802fbb2:	f7ff fe89 	bl	802f8c8 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 802fbb6:	442e      	add	r6, r5
 802fbb8:	42b5      	cmp	r5, r6
 802fbba:	d10e      	bne.n	802fbda <HAL_SUBGHZ_WriteBuffer+0x56>
    LL_PWR_UnselectSUBGHZSPI_NSS();
 802fbbc:	f7ff fe0e 	bl	802f7dc <LL_PWR_UnselectSUBGHZSPI_NSS>
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 802fbc0:	4620      	mov	r0, r4
 802fbc2:	f7ff fef3 	bl	802f9ac <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 802fbc6:	68a0      	ldr	r0, [r4, #8]
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fbc8:	2301      	movs	r3, #1
      status = HAL_ERROR;
 802fbca:	3800      	subs	r0, #0
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fbcc:	71a3      	strb	r3, [r4, #6]
    __HAL_UNLOCK(hsubghz);
 802fbce:	f04f 0300 	mov.w	r3, #0
      status = HAL_ERROR;
 802fbd2:	bf18      	it	ne
 802fbd4:	2001      	movne	r0, #1
    __HAL_UNLOCK(hsubghz);
 802fbd6:	7163      	strb	r3, [r4, #5]
}
 802fbd8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void)SUBGHZSPI_Transmit(hsubghz, pBuffer[i]);
 802fbda:	f815 1b01 	ldrb.w	r1, [r5], #1
 802fbde:	4620      	mov	r0, r4
 802fbe0:	f7ff fe72 	bl	802f8c8 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 802fbe4:	e7e8      	b.n	802fbb8 <HAL_SUBGHZ_WriteBuffer+0x34>
    return HAL_BUSY;
 802fbe6:	2002      	movs	r0, #2
 802fbe8:	e7f6      	b.n	802fbd8 <HAL_SUBGHZ_WriteBuffer+0x54>

0802fbea <HAL_SUBGHZ_ReadBuffer>:
{
 802fbea:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802fbec:	461e      	mov	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fbee:	7983      	ldrb	r3, [r0, #6]
 802fbf0:	2b01      	cmp	r3, #1
{
 802fbf2:	4615      	mov	r5, r2
 802fbf4:	4604      	mov	r4, r0
 802fbf6:	460f      	mov	r7, r1
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fbf8:	b2da      	uxtb	r2, r3
 802fbfa:	d12b      	bne.n	802fc54 <HAL_SUBGHZ_ReadBuffer+0x6a>
    __HAL_LOCK(hsubghz);
 802fbfc:	7943      	ldrb	r3, [r0, #5]
 802fbfe:	2b01      	cmp	r3, #1
 802fc00:	d028      	beq.n	802fc54 <HAL_SUBGHZ_ReadBuffer+0x6a>
 802fc02:	7142      	strb	r2, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 802fc04:	f7ff fef6 	bl	802f9f4 <SUBGHZ_CheckDeviceReady>
    LL_PWR_SelectSUBGHZSPI_NSS();
 802fc08:	f7ff fdf2 	bl	802f7f0 <LL_PWR_SelectSUBGHZSPI_NSS>
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_READ_BUFFER);
 802fc0c:	211e      	movs	r1, #30
 802fc0e:	4620      	mov	r0, r4
 802fc10:	f7ff fe5a 	bl	802f8c8 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, Offset);
 802fc14:	4639      	mov	r1, r7
 802fc16:	4620      	mov	r0, r4
 802fc18:	f7ff fe56 	bl	802f8c8 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, 0x00U);
 802fc1c:	2100      	movs	r1, #0
 802fc1e:	4620      	mov	r0, r4
 802fc20:	f7ff fe52 	bl	802f8c8 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 802fc24:	442e      	add	r6, r5
 802fc26:	42b5      	cmp	r5, r6
 802fc28:	d10e      	bne.n	802fc48 <HAL_SUBGHZ_ReadBuffer+0x5e>
    LL_PWR_UnselectSUBGHZSPI_NSS();
 802fc2a:	f7ff fdd7 	bl	802f7dc <LL_PWR_UnselectSUBGHZSPI_NSS>
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 802fc2e:	4620      	mov	r0, r4
 802fc30:	f7ff febc 	bl	802f9ac <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 802fc34:	68a0      	ldr	r0, [r4, #8]
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fc36:	2301      	movs	r3, #1
      status = HAL_ERROR;
 802fc38:	3800      	subs	r0, #0
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fc3a:	71a3      	strb	r3, [r4, #6]
    __HAL_UNLOCK(hsubghz);
 802fc3c:	f04f 0300 	mov.w	r3, #0
      status = HAL_ERROR;
 802fc40:	bf18      	it	ne
 802fc42:	2001      	movne	r0, #1
    __HAL_UNLOCK(hsubghz);
 802fc44:	7163      	strb	r3, [r4, #5]
}
 802fc46:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void)SUBGHZSPI_Receive(hsubghz, (pData));
 802fc48:	4629      	mov	r1, r5
 802fc4a:	4620      	mov	r0, r4
 802fc4c:	f7ff fe74 	bl	802f938 <SUBGHZSPI_Receive>
      pData++;
 802fc50:	3501      	adds	r5, #1
    for (uint16_t i = 0U; i < Size; i++)
 802fc52:	e7e8      	b.n	802fc26 <HAL_SUBGHZ_ReadBuffer+0x3c>
    return HAL_BUSY;
 802fc54:	2002      	movs	r0, #2
 802fc56:	e7f6      	b.n	802fc46 <HAL_SUBGHZ_ReadBuffer+0x5c>

0802fc58 <HAL_SUBGHZ_ExecGetCmd>:
{
 802fc58:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802fc5a:	461e      	mov	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fc5c:	7983      	ldrb	r3, [r0, #6]
 802fc5e:	2b01      	cmp	r3, #1
{
 802fc60:	4615      	mov	r5, r2
 802fc62:	4604      	mov	r4, r0
 802fc64:	460f      	mov	r7, r1
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fc66:	b2da      	uxtb	r2, r3
 802fc68:	d127      	bne.n	802fcba <HAL_SUBGHZ_ExecGetCmd+0x62>
    __HAL_LOCK(hsubghz);
 802fc6a:	7943      	ldrb	r3, [r0, #5]
 802fc6c:	2b01      	cmp	r3, #1
 802fc6e:	d024      	beq.n	802fcba <HAL_SUBGHZ_ExecGetCmd+0x62>
 802fc70:	7142      	strb	r2, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 802fc72:	f7ff febf 	bl	802f9f4 <SUBGHZ_CheckDeviceReady>
    LL_PWR_SelectSUBGHZSPI_NSS();
 802fc76:	f7ff fdbb 	bl	802f7f0 <LL_PWR_SelectSUBGHZSPI_NSS>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)Command);
 802fc7a:	4639      	mov	r1, r7
 802fc7c:	4620      	mov	r0, r4
 802fc7e:	f7ff fe23 	bl	802f8c8 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, 0x00U);
 802fc82:	2100      	movs	r1, #0
 802fc84:	4620      	mov	r0, r4
 802fc86:	f7ff fe1f 	bl	802f8c8 <SUBGHZSPI_Transmit>
HAL_StatusTypeDef HAL_SUBGHZ_ReadRegisters(SUBGHZ_HandleTypeDef *hsubghz,
 802fc8a:	442e      	add	r6, r5
    for (uint16_t i = 0U; i < Size; i++)
 802fc8c:	42b5      	cmp	r5, r6
 802fc8e:	d10e      	bne.n	802fcae <HAL_SUBGHZ_ExecGetCmd+0x56>
    LL_PWR_UnselectSUBGHZSPI_NSS();
 802fc90:	f7ff fda4 	bl	802f7dc <LL_PWR_UnselectSUBGHZSPI_NSS>
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 802fc94:	4620      	mov	r0, r4
 802fc96:	f7ff fe89 	bl	802f9ac <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 802fc9a:	68a0      	ldr	r0, [r4, #8]
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fc9c:	2301      	movs	r3, #1
      status = HAL_ERROR;
 802fc9e:	3800      	subs	r0, #0
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fca0:	71a3      	strb	r3, [r4, #6]
    __HAL_UNLOCK(hsubghz);
 802fca2:	f04f 0300 	mov.w	r3, #0
      status = HAL_ERROR;
 802fca6:	bf18      	it	ne
 802fca8:	2001      	movne	r0, #1
    __HAL_UNLOCK(hsubghz);
 802fcaa:	7163      	strb	r3, [r4, #5]
}
 802fcac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void)SUBGHZSPI_Receive(hsubghz, (pData));
 802fcae:	4629      	mov	r1, r5
 802fcb0:	4620      	mov	r0, r4
 802fcb2:	f7ff fe41 	bl	802f938 <SUBGHZSPI_Receive>
      pData++;
 802fcb6:	3501      	adds	r5, #1
    for (uint16_t i = 0U; i < Size; i++)
 802fcb8:	e7e8      	b.n	802fc8c <HAL_SUBGHZ_ExecGetCmd+0x34>
    return HAL_BUSY;
 802fcba:	2002      	movs	r0, #2
 802fcbc:	e7f6      	b.n	802fcac <HAL_SUBGHZ_ExecGetCmd+0x54>

0802fcbe <HAL_SUBGHZ_IRQHandler>:
{
 802fcbe:	b537      	push	{r0, r1, r2, r4, r5, lr}
  uint8_t tmpisr[2] = {0};
 802fcc0:	2300      	movs	r3, #0
 802fcc2:	f8ad 3004 	strh.w	r3, [sp, #4]
  (void)HAL_SUBGHZ_ExecGetCmd(hsubghz, RADIO_GET_IRQSTATUS, tmpisr, 2);
 802fcc6:	aa01      	add	r2, sp, #4
 802fcc8:	2302      	movs	r3, #2
 802fcca:	2112      	movs	r1, #18
{
 802fccc:	4604      	mov	r4, r0
  (void)HAL_SUBGHZ_ExecGetCmd(hsubghz, RADIO_GET_IRQSTATUS, tmpisr, 2);
 802fcce:	f7ff ffc3 	bl	802fc58 <HAL_SUBGHZ_ExecGetCmd>
  itsource = (itsource << 8) | tmpisr[1];
 802fcd2:	f89d 3005 	ldrb.w	r3, [sp, #5]
 802fcd6:	f89d 5004 	ldrb.w	r5, [sp, #4]
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_TX_CPLT) != RESET)
 802fcda:	07da      	lsls	r2, r3, #31
  itsource = (itsource << 8) | tmpisr[1];
 802fcdc:	ea43 2505 	orr.w	r5, r3, r5, lsl #8
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_TX_CPLT) != RESET)
 802fce0:	d502      	bpl.n	802fce8 <HAL_SUBGHZ_IRQHandler+0x2a>
    HAL_SUBGHZ_TxCpltCallback(hsubghz);
 802fce2:	4620      	mov	r0, r4
 802fce4:	f00a fea8 	bl	803aa38 <HAL_SUBGHZ_TxCpltCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_RX_CPLT) != RESET)
 802fce8:	07ab      	lsls	r3, r5, #30
 802fcea:	d502      	bpl.n	802fcf2 <HAL_SUBGHZ_IRQHandler+0x34>
    HAL_SUBGHZ_RxCpltCallback(hsubghz);
 802fcec:	4620      	mov	r0, r4
 802fcee:	f00a fea9 	bl	803aa44 <HAL_SUBGHZ_RxCpltCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_PREAMBLE_DETECTED) != RESET)
 802fcf2:	0768      	lsls	r0, r5, #29
 802fcf4:	d502      	bpl.n	802fcfc <HAL_SUBGHZ_IRQHandler+0x3e>
    HAL_SUBGHZ_PreambleDetectedCallback(hsubghz);
 802fcf6:	4620      	mov	r0, r4
 802fcf8:	f00a fece 	bl	803aa98 <HAL_SUBGHZ_PreambleDetectedCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_SYNCWORD_VALID) != RESET)
 802fcfc:	0729      	lsls	r1, r5, #28
 802fcfe:	d502      	bpl.n	802fd06 <HAL_SUBGHZ_IRQHandler+0x48>
    HAL_SUBGHZ_SyncWordValidCallback(hsubghz);
 802fd00:	4620      	mov	r0, r4
 802fd02:	f00a fecf 	bl	803aaa4 <HAL_SUBGHZ_SyncWordValidCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_HEADER_VALID) != RESET)
 802fd06:	06ea      	lsls	r2, r5, #27
 802fd08:	d502      	bpl.n	802fd10 <HAL_SUBGHZ_IRQHandler+0x52>
    HAL_SUBGHZ_HeaderValidCallback(hsubghz);
 802fd0a:	4620      	mov	r0, r4
 802fd0c:	f00a fed0 	bl	803aab0 <HAL_SUBGHZ_HeaderValidCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_HEADER_ERROR) != RESET)
 802fd10:	06ab      	lsls	r3, r5, #26
 802fd12:	d502      	bpl.n	802fd1a <HAL_SUBGHZ_IRQHandler+0x5c>
    HAL_SUBGHZ_HeaderErrorCallback(hsubghz);
 802fd14:	4620      	mov	r0, r4
 802fd16:	f00a feb9 	bl	803aa8c <HAL_SUBGHZ_HeaderErrorCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_CRC_ERROR) != RESET)
 802fd1a:	0668      	lsls	r0, r5, #25
 802fd1c:	d502      	bpl.n	802fd24 <HAL_SUBGHZ_IRQHandler+0x66>
    HAL_SUBGHZ_CRCErrorCallback(hsubghz);
 802fd1e:	4620      	mov	r0, r4
 802fd20:	f00a fe96 	bl	803aa50 <HAL_SUBGHZ_CRCErrorCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_CAD_DONE) != RESET)
 802fd24:	0629      	lsls	r1, r5, #24
 802fd26:	d507      	bpl.n	802fd38 <HAL_SUBGHZ_IRQHandler+0x7a>
    if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_CAD_ACTIVITY_DETECTED) != RESET)
 802fd28:	05ea      	lsls	r2, r5, #23
 802fd2a:	f3c5 2100 	ubfx	r1, r5, #8, #1
      HAL_SUBGHZ_CADStatusCallback(hsubghz, HAL_SUBGHZ_CAD_CLEAR);
 802fd2e:	4620      	mov	r0, r4
      HAL_SUBGHZ_CADStatusCallback(hsubghz, HAL_SUBGHZ_CAD_DETECTED);
 802fd30:	bf48      	it	mi
 802fd32:	2101      	movmi	r1, #1
      HAL_SUBGHZ_CADStatusCallback(hsubghz, HAL_SUBGHZ_CAD_CLEAR);
 802fd34:	f00a fe92 	bl	803aa5c <HAL_SUBGHZ_CADStatusCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_RX_TX_TIMEOUT) != RESET)
 802fd38:	05ab      	lsls	r3, r5, #22
 802fd3a:	d502      	bpl.n	802fd42 <HAL_SUBGHZ_IRQHandler+0x84>
    HAL_SUBGHZ_RxTxTimeoutCallback(hsubghz);
 802fd3c:	4620      	mov	r0, r4
 802fd3e:	f00a fe9d 	bl	803aa7c <HAL_SUBGHZ_RxTxTimeoutCallback>
  (void)HAL_SUBGHZ_ExecSetCmd(hsubghz, RADIO_CLR_IRQSTATUS, tmpisr, 2);
 802fd42:	2302      	movs	r3, #2
 802fd44:	aa01      	add	r2, sp, #4
 802fd46:	4619      	mov	r1, r3
 802fd48:	4620      	mov	r0, r4
 802fd4a:	f7ff fee3 	bl	802fb14 <HAL_SUBGHZ_ExecSetCmd>
}
 802fd4e:	b003      	add	sp, #12
 802fd50:	bd30      	pop	{r4, r5, pc}

0802fd52 <UART_EndTxTransfer>:
  * @retval None
  */
static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable TXEIE, TCIE, TXFT interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE | USART_CR1_TCIE));
 802fd52:	6802      	ldr	r2, [r0, #0]
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802fd54:	e852 3f00 	ldrex	r3, [r2]
 802fd58:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802fd5c:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 802fd60:	6802      	ldr	r2, [r0, #0]
 802fd62:	2900      	cmp	r1, #0
 802fd64:	d1f5      	bne.n	802fd52 <UART_EndTxTransfer>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802fd66:	f102 0308 	add.w	r3, r2, #8
 802fd6a:	e853 3f00 	ldrex	r3, [r3]
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_TXFTIE));
 802fd6e:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802fd72:	f102 0c08 	add.w	ip, r2, #8
 802fd76:	e84c 3100 	strex	r1, r3, [ip]
 802fd7a:	2900      	cmp	r1, #0
 802fd7c:	d1f3      	bne.n	802fd66 <UART_EndTxTransfer+0x14>

  /* At end of Tx process, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 802fd7e:	2320      	movs	r3, #32
 802fd80:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
}
 802fd84:	4770      	bx	lr
	...

0802fd88 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
 802fd88:	b510      	push	{r4, lr}
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 802fd8a:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802fd8c:	e852 3f00 	ldrex	r3, [r2]
 802fd90:	f423 7390 	bic.w	r3, r3, #288	; 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802fd94:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 802fd98:	6802      	ldr	r2, [r0, #0]
 802fd9a:	2900      	cmp	r1, #0
 802fd9c:	d1f5      	bne.n	802fd8a <UART_EndRxTransfer+0x2>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 802fd9e:	4c0f      	ldr	r4, [pc, #60]	; (802fddc <UART_EndRxTransfer+0x54>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802fda0:	f102 0308 	add.w	r3, r2, #8
 802fda4:	e853 3f00 	ldrex	r3, [r3]
 802fda8:	4023      	ands	r3, r4
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802fdaa:	f102 0c08 	add.w	ip, r2, #8
 802fdae:	e84c 3100 	strex	r1, r3, [ip]
 802fdb2:	2900      	cmp	r1, #0
 802fdb4:	d1f4      	bne.n	802fda0 <UART_EndRxTransfer+0x18>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 802fdb6:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 802fdb8:	2b01      	cmp	r3, #1
 802fdba:	d107      	bne.n	802fdcc <UART_EndRxTransfer+0x44>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802fdbc:	e852 3f00 	ldrex	r3, [r2]
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 802fdc0:	f023 0310 	bic.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802fdc4:	e842 3100 	strex	r1, r3, [r2]
 802fdc8:	2900      	cmp	r1, #0
 802fdca:	d1f7      	bne.n	802fdbc <UART_EndRxTransfer+0x34>
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 802fdcc:	2320      	movs	r3, #32
 802fdce:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 802fdd2:	2300      	movs	r3, #0
 802fdd4:	66c3      	str	r3, [r0, #108]	; 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 802fdd6:	6703      	str	r3, [r0, #112]	; 0x70
}
 802fdd8:	bd10      	pop	{r4, pc}
 802fdda:	bf00      	nop
 802fddc:	effffffe 	.word	0xeffffffe

0802fde0 <HAL_UART_Transmit_DMA>:
{
 802fde0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802fde2:	4604      	mov	r4, r0
 802fde4:	4613      	mov	r3, r2
  if (huart->gState == HAL_UART_STATE_READY)
 802fde6:	f8d4 7084 	ldr.w	r7, [r4, #132]	; 0x84
 802fdea:	2f20      	cmp	r7, #32
 802fdec:	d143      	bne.n	802fe76 <HAL_UART_Transmit_DMA+0x96>
    if ((pData == NULL) || (Size == 0U))
 802fdee:	b361      	cbz	r1, 802fe4a <HAL_UART_Transmit_DMA+0x6a>
 802fdf0:	b35a      	cbz	r2, 802fe4a <HAL_UART_Transmit_DMA+0x6a>
    __HAL_LOCK(huart);
 802fdf2:	f894 2080 	ldrb.w	r2, [r4, #128]	; 0x80
 802fdf6:	2a01      	cmp	r2, #1
 802fdf8:	d03d      	beq.n	802fe76 <HAL_UART_Transmit_DMA+0x96>
    if (huart->hdmatx != NULL)
 802fdfa:	6fa0      	ldr	r0, [r4, #120]	; 0x78
    huart->TxXferCount = Size;
 802fdfc:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
    __HAL_LOCK(huart);
 802fe00:	2501      	movs	r5, #1
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 802fe02:	2600      	movs	r6, #0
    huart->gState = HAL_UART_STATE_BUSY_TX;
 802fe04:	2221      	movs	r2, #33	; 0x21
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 802fe06:	f8c4 608c 	str.w	r6, [r4, #140]	; 0x8c
    __HAL_LOCK(huart);
 802fe0a:	f884 5080 	strb.w	r5, [r4, #128]	; 0x80
    huart->pTxBuffPtr  = pData;
 802fe0e:	6521      	str	r1, [r4, #80]	; 0x50
    huart->TxXferSize  = Size;
 802fe10:	f8a4 3054 	strh.w	r3, [r4, #84]	; 0x54
    huart->gState = HAL_UART_STATE_BUSY_TX;
 802fe14:	f8c4 2084 	str.w	r2, [r4, #132]	; 0x84
    if (huart->hdmatx != NULL)
 802fe18:	b1c8      	cbz	r0, 802fe4e <HAL_UART_Transmit_DMA+0x6e>
      huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
 802fe1a:	f8df c060 	ldr.w	ip, [pc, #96]	; 802fe7c <HAL_UART_Transmit_DMA+0x9c>
 802fe1e:	6822      	ldr	r2, [r4, #0]
 802fe20:	f8c0 c02c 	str.w	ip, [r0, #44]	; 0x2c
      huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
 802fe24:	f8df c058 	ldr.w	ip, [pc, #88]	; 802fe80 <HAL_UART_Transmit_DMA+0xa0>
 802fe28:	f8c0 c030 	str.w	ip, [r0, #48]	; 0x30
      huart->hdmatx->XferErrorCallback = UART_DMAError;
 802fe2c:	f8df c054 	ldr.w	ip, [pc, #84]	; 802fe84 <HAL_UART_Transmit_DMA+0xa4>
      if (HAL_DMA_Start_IT(huart->hdmatx, (uint32_t)huart->pTxBuffPtr, (uint32_t)&huart->Instance->TDR, Size) != HAL_OK)
 802fe30:	3228      	adds	r2, #40	; 0x28
      huart->hdmatx->XferAbortCallback = NULL;
 802fe32:	e9c0 c60d 	strd	ip, r6, [r0, #52]	; 0x34
      if (HAL_DMA_Start_IT(huart->hdmatx, (uint32_t)huart->pTxBuffPtr, (uint32_t)&huart->Instance->TDR, Size) != HAL_OK)
 802fe36:	f7fe f8f1 	bl	802e01c <HAL_DMA_Start_IT>
 802fe3a:	b140      	cbz	r0, 802fe4e <HAL_UART_Transmit_DMA+0x6e>
        huart->ErrorCode = HAL_UART_ERROR_DMA;
 802fe3c:	2310      	movs	r3, #16
 802fe3e:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
        __HAL_UNLOCK(huart);
 802fe42:	f884 6080 	strb.w	r6, [r4, #128]	; 0x80
        huart->gState = HAL_UART_STATE_READY;
 802fe46:	f8c4 7084 	str.w	r7, [r4, #132]	; 0x84
      return HAL_ERROR;
 802fe4a:	2001      	movs	r0, #1
 802fe4c:	e012      	b.n	802fe74 <HAL_UART_Transmit_DMA+0x94>
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_TCF);
 802fe4e:	6823      	ldr	r3, [r4, #0]
 802fe50:	2240      	movs	r2, #64	; 0x40
 802fe52:	621a      	str	r2, [r3, #32]
    __HAL_UNLOCK(huart);
 802fe54:	2300      	movs	r3, #0
 802fe56:	6822      	ldr	r2, [r4, #0]
 802fe58:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802fe5c:	f102 0308 	add.w	r3, r2, #8
 802fe60:	e853 3f00 	ldrex	r3, [r3]
    ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 802fe64:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802fe68:	f102 0108 	add.w	r1, r2, #8
 802fe6c:	e841 3000 	strex	r0, r3, [r1]
 802fe70:	2800      	cmp	r0, #0
 802fe72:	d1f3      	bne.n	802fe5c <HAL_UART_Transmit_DMA+0x7c>
}
 802fe74:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_BUSY;
 802fe76:	2002      	movs	r0, #2
 802fe78:	e7fc      	b.n	802fe74 <HAL_UART_Transmit_DMA+0x94>
 802fe7a:	bf00      	nop
 802fe7c:	0802fe89 	.word	0x0802fe89
 802fe80:	0802fed1 	.word	0x0802fed1
 802fe84:	0802fedd 	.word	0x0802fedd

0802fe88 <UART_DMATransmitCplt>:
  * @brief DMA UART transmit process complete callback.
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
{
 802fe88:	b508      	push	{r3, lr}
 802fe8a:	4603      	mov	r3, r0
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 802fe8c:	6a80      	ldr	r0, [r0, #40]	; 0x28

  /* DMA Normal mode */
  if (HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC))
 802fe8e:	681b      	ldr	r3, [r3, #0]
 802fe90:	681b      	ldr	r3, [r3, #0]
 802fe92:	f013 0320 	ands.w	r3, r3, #32
 802fe96:	d117      	bne.n	802fec8 <UART_DMATransmitCplt+0x40>
  {
    huart->TxXferCount = 0U;
 802fe98:	f8a0 3056 	strh.w	r3, [r0, #86]	; 0x56

    /* Disable the DMA transfer for transmit request by resetting the DMAT bit
       in the UART CR3 register */
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 802fe9c:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802fe9e:	f102 0308 	add.w	r3, r2, #8
 802fea2:	e853 3f00 	ldrex	r3, [r3]
 802fea6:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802feaa:	3208      	adds	r2, #8
 802feac:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 802feb0:	6802      	ldr	r2, [r0, #0]
 802feb2:	2900      	cmp	r1, #0
 802feb4:	d1f2      	bne.n	802fe9c <UART_DMATransmitCplt+0x14>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802feb6:	e852 3f00 	ldrex	r3, [r2]

    /* Enable the UART Transmit Complete Interrupt */
    ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 802feba:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802febe:	e842 3100 	strex	r1, r3, [r2]
 802fec2:	2900      	cmp	r1, #0
 802fec4:	d1f7      	bne.n	802feb6 <UART_DMATransmitCplt+0x2e>
#else
    /*Call legacy weak Tx complete callback*/
    HAL_UART_TxCpltCallback(huart);
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
  }
}
 802fec6:	bd08      	pop	{r3, pc}
    HAL_UART_TxCpltCallback(huart);
 802fec8:	f7fc fe12 	bl	802caf0 <HAL_UART_TxCpltCallback>
}
 802fecc:	e7fb      	b.n	802fec6 <UART_DMATransmitCplt+0x3e>

0802fece <HAL_UART_TxHalfCpltCallback>:
 802fece:	4770      	bx	lr

0802fed0 <UART_DMATxHalfCplt>:
  * @brief DMA UART transmit process half complete callback.
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
{
 802fed0:	b508      	push	{r3, lr}
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx Half complete callback*/
  huart->TxHalfCpltCallback(huart);
#else
  /*Call legacy weak Tx Half complete callback*/
  HAL_UART_TxHalfCpltCallback(huart);
 802fed2:	6a80      	ldr	r0, [r0, #40]	; 0x28
 802fed4:	f7ff fffb 	bl	802fece <HAL_UART_TxHalfCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 802fed8:	bd08      	pop	{r3, pc}

0802feda <HAL_UART_ErrorCallback>:
 802feda:	4770      	bx	lr

0802fedc <UART_DMAError>:
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMAError(DMA_HandleTypeDef *hdma)
{
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 802fedc:	6a80      	ldr	r0, [r0, #40]	; 0x28

  const HAL_UART_StateTypeDef gstate = huart->gState;
  const HAL_UART_StateTypeDef rxstate = huart->RxState;

  /* Stop UART DMA Tx request if ongoing */
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
 802fede:	6802      	ldr	r2, [r0, #0]
  const HAL_UART_StateTypeDef gstate = huart->gState;
 802fee0:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
{
 802fee4:	b510      	push	{r4, lr}
  const HAL_UART_StateTypeDef rxstate = huart->RxState;
 802fee6:	f8d0 4088 	ldr.w	r4, [r0, #136]	; 0x88
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
 802feea:	6892      	ldr	r2, [r2, #8]
 802feec:	0612      	lsls	r2, r2, #24
 802feee:	d506      	bpl.n	802fefe <UART_DMAError+0x22>
 802fef0:	2b21      	cmp	r3, #33	; 0x21
 802fef2:	d104      	bne.n	802fefe <UART_DMAError+0x22>
      (gstate == HAL_UART_STATE_BUSY_TX))
  {
    huart->TxXferCount = 0U;
 802fef4:	2300      	movs	r3, #0
 802fef6:	f8a0 3056 	strh.w	r3, [r0, #86]	; 0x56
    UART_EndTxTransfer(huart);
 802fefa:	f7ff ff2a 	bl	802fd52 <UART_EndTxTransfer>
  }

  /* Stop UART DMA Rx request if ongoing */
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) &&
 802fefe:	6803      	ldr	r3, [r0, #0]
 802ff00:	689b      	ldr	r3, [r3, #8]
 802ff02:	065b      	lsls	r3, r3, #25
 802ff04:	d506      	bpl.n	802ff14 <UART_DMAError+0x38>
 802ff06:	2c22      	cmp	r4, #34	; 0x22
 802ff08:	d104      	bne.n	802ff14 <UART_DMAError+0x38>
      (rxstate == HAL_UART_STATE_BUSY_RX))
  {
    huart->RxXferCount = 0U;
 802ff0a:	2300      	movs	r3, #0
 802ff0c:	f8a0 305e 	strh.w	r3, [r0, #94]	; 0x5e
    UART_EndRxTransfer(huart);
 802ff10:	f7ff ff3a 	bl	802fd88 <UART_EndRxTransfer>
  }

  huart->ErrorCode |= HAL_UART_ERROR_DMA;
 802ff14:	f8d0 308c 	ldr.w	r3, [r0, #140]	; 0x8c
 802ff18:	f043 0310 	orr.w	r3, r3, #16
 802ff1c:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 802ff20:	f7ff ffdb 	bl	802feda <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 802ff24:	bd10      	pop	{r4, pc}

0802ff26 <UART_DMAAbortOnError>:
  *         (To be called at end of DMA Abort procedure following error occurrence).
  * @param  hdma DMA handle.
  * @retval None
  */
static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
 802ff26:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 802ff28:	6a80      	ldr	r0, [r0, #40]	; 0x28
  huart->RxXferCount = 0U;
 802ff2a:	2300      	movs	r3, #0
 802ff2c:	f8a0 305e 	strh.w	r3, [r0, #94]	; 0x5e
  huart->TxXferCount = 0U;
 802ff30:	f8a0 3056 	strh.w	r3, [r0, #86]	; 0x56
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 802ff34:	f7ff ffd1 	bl	802feda <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 802ff38:	bd08      	pop	{r3, pc}

0802ff3a <HAL_UARTEx_RxEventCallback>:
}
 802ff3a:	4770      	bx	lr

0802ff3c <HAL_UART_IRQHandler>:
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
 802ff3c:	6803      	ldr	r3, [r0, #0]
 802ff3e:	69da      	ldr	r2, [r3, #28]
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 802ff40:	6819      	ldr	r1, [r3, #0]
{
 802ff42:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (errorflags == 0U)
 802ff46:	f640 060f 	movw	r6, #2063	; 0x80f
 802ff4a:	4232      	tst	r2, r6
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 802ff4c:	689d      	ldr	r5, [r3, #8]
{
 802ff4e:	4604      	mov	r4, r0
  if (errorflags == 0U)
 802ff50:	d110      	bne.n	802ff74 <HAL_UART_IRQHandler+0x38>
    if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)
 802ff52:	0696      	lsls	r6, r2, #26
 802ff54:	f140 8096 	bpl.w	8030084 <HAL_UART_IRQHandler+0x148>
        && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)
 802ff58:	f001 0620 	and.w	r6, r1, #32
            || ((cr3its & USART_CR3_RXFTIE) != 0U)))
 802ff5c:	f005 5780 	and.w	r7, r5, #268435456	; 0x10000000
 802ff60:	433e      	orrs	r6, r7
 802ff62:	f000 808f 	beq.w	8030084 <HAL_UART_IRQHandler+0x148>
      if (huart->RxISR != NULL)
 802ff66:	6f03      	ldr	r3, [r0, #112]	; 0x70
 802ff68:	2b00      	cmp	r3, #0
 802ff6a:	f000 8084 	beq.w	8030076 <HAL_UART_IRQHandler+0x13a>
}
 802ff6e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 802ff72:	4718      	bx	r3
      && ((((cr3its & (USART_CR3_RXFTIE | USART_CR3_EIE)) != 0U)
 802ff74:	4ea7      	ldr	r6, [pc, #668]	; (8030214 <HAL_UART_IRQHandler+0x2d8>)
           || ((cr1its & (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_RTOIE)) != 0U))))
 802ff76:	48a8      	ldr	r0, [pc, #672]	; (8030218 <HAL_UART_IRQHandler+0x2dc>)
      && ((((cr3its & (USART_CR3_RXFTIE | USART_CR3_EIE)) != 0U)
 802ff78:	402e      	ands	r6, r5
           || ((cr1its & (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_RTOIE)) != 0U))))
 802ff7a:	4008      	ands	r0, r1
 802ff7c:	4330      	orrs	r0, r6
 802ff7e:	f000 8081 	beq.w	8030084 <HAL_UART_IRQHandler+0x148>
    if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 802ff82:	07d7      	lsls	r7, r2, #31
 802ff84:	d509      	bpl.n	802ff9a <HAL_UART_IRQHandler+0x5e>
 802ff86:	05c8      	lsls	r0, r1, #23
 802ff88:	d507      	bpl.n	802ff9a <HAL_UART_IRQHandler+0x5e>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 802ff8a:	2001      	movs	r0, #1
 802ff8c:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 802ff8e:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 802ff92:	f040 0001 	orr.w	r0, r0, #1
 802ff96:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 802ff9a:	0797      	lsls	r7, r2, #30
 802ff9c:	d509      	bpl.n	802ffb2 <HAL_UART_IRQHandler+0x76>
 802ff9e:	07e8      	lsls	r0, r5, #31
 802ffa0:	d507      	bpl.n	802ffb2 <HAL_UART_IRQHandler+0x76>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 802ffa2:	2002      	movs	r0, #2
 802ffa4:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 802ffa6:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 802ffaa:	f040 0004 	orr.w	r0, r0, #4
 802ffae:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 802ffb2:	0757      	lsls	r7, r2, #29
 802ffb4:	d509      	bpl.n	802ffca <HAL_UART_IRQHandler+0x8e>
 802ffb6:	07e8      	lsls	r0, r5, #31
 802ffb8:	d507      	bpl.n	802ffca <HAL_UART_IRQHandler+0x8e>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 802ffba:	2004      	movs	r0, #4
 802ffbc:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 802ffbe:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 802ffc2:	f040 0002 	orr.w	r0, r0, #2
 802ffc6:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    if (((isrflags & USART_ISR_ORE) != 0U)
 802ffca:	0717      	lsls	r7, r2, #28
 802ffcc:	d50b      	bpl.n	802ffe6 <HAL_UART_IRQHandler+0xaa>
        && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U) ||
 802ffce:	f001 0020 	and.w	r0, r1, #32
 802ffd2:	4330      	orrs	r0, r6
 802ffd4:	d007      	beq.n	802ffe6 <HAL_UART_IRQHandler+0xaa>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 802ffd6:	2008      	movs	r0, #8
 802ffd8:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 802ffda:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 802ffde:	f040 0008 	orr.w	r0, r0, #8
 802ffe2:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    if (((isrflags & USART_ISR_RTOF) != 0U) && ((cr1its & USART_CR1_RTOIE) != 0U))
 802ffe6:	0516      	lsls	r6, r2, #20
 802ffe8:	d50a      	bpl.n	8030000 <HAL_UART_IRQHandler+0xc4>
 802ffea:	0148      	lsls	r0, r1, #5
 802ffec:	d508      	bpl.n	8030000 <HAL_UART_IRQHandler+0xc4>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 802ffee:	f44f 6000 	mov.w	r0, #2048	; 0x800
 802fff2:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_RTO;
 802fff4:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 802fff8:	f043 0320 	orr.w	r3, r3, #32
 802fffc:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 8030000:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 8030004:	2b00      	cmp	r3, #0
 8030006:	d036      	beq.n	8030076 <HAL_UART_IRQHandler+0x13a>
      if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)
 8030008:	0693      	lsls	r3, r2, #26
 803000a:	d50a      	bpl.n	8030022 <HAL_UART_IRQHandler+0xe6>
          && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)
 803000c:	f001 0120 	and.w	r1, r1, #32
              || ((cr3its & USART_CR3_RXFTIE) != 0U)))
 8030010:	f005 5580 	and.w	r5, r5, #268435456	; 0x10000000
 8030014:	ea51 0305 	orrs.w	r3, r1, r5
 8030018:	d003      	beq.n	8030022 <HAL_UART_IRQHandler+0xe6>
        if (huart->RxISR != NULL)
 803001a:	6f23      	ldr	r3, [r4, #112]	; 0x70
 803001c:	b10b      	cbz	r3, 8030022 <HAL_UART_IRQHandler+0xe6>
          huart->RxISR(huart);
 803001e:	4620      	mov	r0, r4
 8030020:	4798      	blx	r3
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 8030022:	6823      	ldr	r3, [r4, #0]
      errorcode = huart->ErrorCode;
 8030024:	f8d4 508c 	ldr.w	r5, [r4, #140]	; 0x8c
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 8030028:	689b      	ldr	r3, [r3, #8]
          ((errorcode & (HAL_UART_ERROR_RTO | HAL_UART_ERROR_ORE)) != 0U))
 803002a:	f005 0528 	and.w	r5, r5, #40	; 0x28
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 803002e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8030032:	431d      	orrs	r5, r3
        UART_EndRxTransfer(huart);
 8030034:	4620      	mov	r0, r4
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 8030036:	d020      	beq.n	803007a <HAL_UART_IRQHandler+0x13e>
        UART_EndRxTransfer(huart);
 8030038:	f7ff fea6 	bl	802fd88 <UART_EndRxTransfer>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 803003c:	6822      	ldr	r2, [r4, #0]
 803003e:	6893      	ldr	r3, [r2, #8]
 8030040:	065f      	lsls	r7, r3, #25
 8030042:	d515      	bpl.n	8030070 <HAL_UART_IRQHandler+0x134>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030044:	f102 0308 	add.w	r3, r2, #8
 8030048:	e853 3f00 	ldrex	r3, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 803004c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030050:	f102 0008 	add.w	r0, r2, #8
 8030054:	e840 3100 	strex	r1, r3, [r0]
 8030058:	2900      	cmp	r1, #0
 803005a:	d1f3      	bne.n	8030044 <HAL_UART_IRQHandler+0x108>
          if (huart->hdmarx != NULL)
 803005c:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 803005e:	b138      	cbz	r0, 8030070 <HAL_UART_IRQHandler+0x134>
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 8030060:	4b6e      	ldr	r3, [pc, #440]	; (803021c <HAL_UART_IRQHandler+0x2e0>)
 8030062:	6383      	str	r3, [r0, #56]	; 0x38
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 8030064:	f7fe f854 	bl	802e110 <HAL_DMA_Abort_IT>
 8030068:	b128      	cbz	r0, 8030076 <HAL_UART_IRQHandler+0x13a>
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 803006a:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 803006c:	6b83      	ldr	r3, [r0, #56]	; 0x38
 803006e:	e77e      	b.n	802ff6e <HAL_UART_IRQHandler+0x32>
            HAL_UART_ErrorCallback(huart);
 8030070:	4620      	mov	r0, r4
 8030072:	f7ff ff32 	bl	802feda <HAL_UART_ErrorCallback>
}
 8030076:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        HAL_UART_ErrorCallback(huart);
 803007a:	f7ff ff2e 	bl	802feda <HAL_UART_ErrorCallback>
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 803007e:	f8c4 508c 	str.w	r5, [r4, #140]	; 0x8c
 8030082:	e7f8      	b.n	8030076 <HAL_UART_IRQHandler+0x13a>
  if (  (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8030084:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8030086:	2801      	cmp	r0, #1
 8030088:	f040 8081 	bne.w	803018e <HAL_UART_IRQHandler+0x252>
      &&((isrflags & USART_ISR_IDLE) != 0U)
 803008c:	06d6      	lsls	r6, r2, #27
 803008e:	d57e      	bpl.n	803018e <HAL_UART_IRQHandler+0x252>
      &&((cr1its & USART_ISR_IDLE) != 0U))
 8030090:	06c8      	lsls	r0, r1, #27
 8030092:	d57c      	bpl.n	803018e <HAL_UART_IRQHandler+0x252>
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 8030094:	2210      	movs	r2, #16
 8030096:	621a      	str	r2, [r3, #32]
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8030098:	689a      	ldr	r2, [r3, #8]
 803009a:	0651      	lsls	r1, r2, #25
 803009c:	d547      	bpl.n	803012e <HAL_UART_IRQHandler+0x1f2>
      uint16_t nb_remaining_rx_data = (uint16_t) __HAL_DMA_GET_COUNTER(huart->hdmarx);
 803009e:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
 80300a0:	6811      	ldr	r1, [r2, #0]
 80300a2:	684a      	ldr	r2, [r1, #4]
 80300a4:	b292      	uxth	r2, r2
      if (  (nb_remaining_rx_data > 0U)
 80300a6:	2a00      	cmp	r2, #0
 80300a8:	d0e5      	beq.n	8030076 <HAL_UART_IRQHandler+0x13a>
          &&(nb_remaining_rx_data < huart->RxXferSize))
 80300aa:	f8b4 005c 	ldrh.w	r0, [r4, #92]	; 0x5c
 80300ae:	4290      	cmp	r0, r2
 80300b0:	d9e1      	bls.n	8030076 <HAL_UART_IRQHandler+0x13a>
        huart->RxXferCount = nb_remaining_rx_data;
 80300b2:	f8a4 205e 	strh.w	r2, [r4, #94]	; 0x5e
        if (HAL_IS_BIT_CLR(huart->hdmarx->Instance->CCR, DMA_CCR_CIRC))
 80300b6:	680a      	ldr	r2, [r1, #0]
 80300b8:	0692      	lsls	r2, r2, #26
 80300ba:	d42e      	bmi.n	803011a <HAL_UART_IRQHandler+0x1de>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80300bc:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 80300c0:	f422 7280 	bic.w	r2, r2, #256	; 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80300c4:	e843 2100 	strex	r1, r2, [r3]
 80300c8:	2900      	cmp	r1, #0
 80300ca:	d1f7      	bne.n	80300bc <HAL_UART_IRQHandler+0x180>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80300cc:	f103 0208 	add.w	r2, r3, #8
 80300d0:	e852 2f00 	ldrex	r2, [r2]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80300d4:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80300d8:	f103 0008 	add.w	r0, r3, #8
 80300dc:	e840 2100 	strex	r1, r2, [r0]
 80300e0:	2900      	cmp	r1, #0
 80300e2:	d1f3      	bne.n	80300cc <HAL_UART_IRQHandler+0x190>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80300e4:	f103 0208 	add.w	r2, r3, #8
 80300e8:	e852 2f00 	ldrex	r2, [r2]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 80300ec:	f022 0240 	bic.w	r2, r2, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80300f0:	f103 0008 	add.w	r0, r3, #8
 80300f4:	e840 2100 	strex	r1, r2, [r0]
 80300f8:	2900      	cmp	r1, #0
 80300fa:	d1f3      	bne.n	80300e4 <HAL_UART_IRQHandler+0x1a8>
          huart->RxState = HAL_UART_STATE_READY;
 80300fc:	2220      	movs	r2, #32
 80300fe:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8030102:	66e1      	str	r1, [r4, #108]	; 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030104:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8030108:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 803010c:	e843 2100 	strex	r1, r2, [r3]
 8030110:	2900      	cmp	r1, #0
 8030112:	d1f7      	bne.n	8030104 <HAL_UART_IRQHandler+0x1c8>
          (void)HAL_DMA_Abort(huart->hdmarx);
 8030114:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 8030116:	f7fd ffc6 	bl	802e0a6 <HAL_DMA_Abort>
        HAL_UARTEx_RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
 803011a:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 803011e:	f8b4 105c 	ldrh.w	r1, [r4, #92]	; 0x5c
 8030122:	1ac9      	subs	r1, r1, r3
 8030124:	b289      	uxth	r1, r1
        HAL_UARTEx_RxEventCallback(huart, nb_rx_data);
 8030126:	4620      	mov	r0, r4
 8030128:	f7ff ff07 	bl	802ff3a <HAL_UARTEx_RxEventCallback>
 803012c:	e7a3      	b.n	8030076 <HAL_UART_IRQHandler+0x13a>
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 803012e:	f8b4 105e 	ldrh.w	r1, [r4, #94]	; 0x5e
 8030132:	b28a      	uxth	r2, r1
      if (  (huart->RxXferCount > 0U)
 8030134:	f8b4 105e 	ldrh.w	r1, [r4, #94]	; 0x5e
 8030138:	b289      	uxth	r1, r1
 803013a:	2900      	cmp	r1, #0
 803013c:	d09b      	beq.n	8030076 <HAL_UART_IRQHandler+0x13a>
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 803013e:	f8b4 105c 	ldrh.w	r1, [r4, #92]	; 0x5c
 8030142:	1a89      	subs	r1, r1, r2
 8030144:	b289      	uxth	r1, r1
          &&(nb_rx_data > 0U) )
 8030146:	2900      	cmp	r1, #0
 8030148:	d095      	beq.n	8030076 <HAL_UART_IRQHandler+0x13a>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 803014a:	e853 2f00 	ldrex	r2, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 803014e:	f422 7290 	bic.w	r2, r2, #288	; 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030152:	e843 2000 	strex	r0, r2, [r3]
 8030156:	2800      	cmp	r0, #0
 8030158:	d1f7      	bne.n	803014a <HAL_UART_IRQHandler+0x20e>
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 803015a:	4d31      	ldr	r5, [pc, #196]	; (8030220 <HAL_UART_IRQHandler+0x2e4>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 803015c:	f103 0208 	add.w	r2, r3, #8
 8030160:	e852 2f00 	ldrex	r2, [r2]
 8030164:	402a      	ands	r2, r5
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030166:	f103 0608 	add.w	r6, r3, #8
 803016a:	e846 2000 	strex	r0, r2, [r6]
 803016e:	2800      	cmp	r0, #0
 8030170:	d1f4      	bne.n	803015c <HAL_UART_IRQHandler+0x220>
        huart->RxState = HAL_UART_STATE_READY;
 8030172:	2220      	movs	r2, #32
 8030174:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
        huart->RxISR = NULL;
 8030178:	6720      	str	r0, [r4, #112]	; 0x70
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 803017a:	66e0      	str	r0, [r4, #108]	; 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 803017c:	e853 2f00 	ldrex	r2, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8030180:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030184:	e843 2000 	strex	r0, r2, [r3]
 8030188:	2800      	cmp	r0, #0
 803018a:	d1f7      	bne.n	803017c <HAL_UART_IRQHandler+0x240>
 803018c:	e7cb      	b.n	8030126 <HAL_UART_IRQHandler+0x1ea>
  if (((isrflags & USART_ISR_WUF) != 0U) && ((cr3its & USART_CR3_WUFIE) != 0U))
 803018e:	02d7      	lsls	r7, r2, #11
 8030190:	d509      	bpl.n	80301a6 <HAL_UART_IRQHandler+0x26a>
 8030192:	026e      	lsls	r6, r5, #9
 8030194:	d507      	bpl.n	80301a6 <HAL_UART_IRQHandler+0x26a>
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);
 8030196:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    HAL_UARTEx_WakeupCallback(huart);
 803019a:	4620      	mov	r0, r4
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);
 803019c:	621a      	str	r2, [r3, #32]
}
 803019e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    HAL_UARTEx_WakeupCallback(huart);
 80301a2:	f000 bd35 	b.w	8030c10 <HAL_UARTEx_WakeupCallback>
  if (((isrflags & USART_ISR_TXE_TXFNF) != 0U)
 80301a6:	0610      	lsls	r0, r2, #24
 80301a8:	d50b      	bpl.n	80301c2 <HAL_UART_IRQHandler+0x286>
      && (((cr1its & USART_CR1_TXEIE_TXFNFIE) != 0U)
 80301aa:	f001 0080 	and.w	r0, r1, #128	; 0x80
          || ((cr3its & USART_CR3_TXFTIE) != 0U)))
 80301ae:	f405 0500 	and.w	r5, r5, #8388608	; 0x800000
 80301b2:	4328      	orrs	r0, r5
 80301b4:	d005      	beq.n	80301c2 <HAL_UART_IRQHandler+0x286>
    if (huart->TxISR != NULL)
 80301b6:	6f63      	ldr	r3, [r4, #116]	; 0x74
 80301b8:	2b00      	cmp	r3, #0
 80301ba:	f43f af5c 	beq.w	8030076 <HAL_UART_IRQHandler+0x13a>
      huart->TxISR(huart);
 80301be:	4620      	mov	r0, r4
 80301c0:	e6d5      	b.n	802ff6e <HAL_UART_IRQHandler+0x32>
  if (((isrflags & USART_ISR_TC) != 0U) && ((cr1its & USART_CR1_TCIE) != 0U))
 80301c2:	0657      	lsls	r7, r2, #25
 80301c4:	d511      	bpl.n	80301ea <HAL_UART_IRQHandler+0x2ae>
 80301c6:	064e      	lsls	r6, r1, #25
 80301c8:	d50f      	bpl.n	80301ea <HAL_UART_IRQHandler+0x2ae>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80301ca:	e853 2f00 	ldrex	r2, [r3]
  * @retval None
  */
static void UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
  /* Disable the UART Transmit Complete Interrupt */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 80301ce:	f022 0240 	bic.w	r2, r2, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80301d2:	e843 2100 	strex	r1, r2, [r3]
 80301d6:	2900      	cmp	r1, #0
 80301d8:	d1f7      	bne.n	80301ca <HAL_UART_IRQHandler+0x28e>

  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 80301da:	2320      	movs	r3, #32
 80301dc:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84

  /* Cleat TxISR function pointer */
  huart->TxISR = NULL;
 80301e0:	6761      	str	r1, [r4, #116]	; 0x74
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx complete callback*/
  huart->TxCpltCallback(huart);
#else
  /*Call legacy weak Tx complete callback*/
  HAL_UART_TxCpltCallback(huart);
 80301e2:	4620      	mov	r0, r4
 80301e4:	f7fc fc84 	bl	802caf0 <HAL_UART_TxCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 80301e8:	e745      	b.n	8030076 <HAL_UART_IRQHandler+0x13a>
  if (((isrflags & USART_ISR_TXFE) != 0U) && ((cr1its & USART_CR1_TXFEIE) != 0U))
 80301ea:	0215      	lsls	r5, r2, #8
 80301ec:	d506      	bpl.n	80301fc <HAL_UART_IRQHandler+0x2c0>
 80301ee:	0048      	lsls	r0, r1, #1
 80301f0:	d504      	bpl.n	80301fc <HAL_UART_IRQHandler+0x2c0>
    HAL_UARTEx_TxFifoEmptyCallback(huart);
 80301f2:	4620      	mov	r0, r4
}
 80301f4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    HAL_UARTEx_TxFifoEmptyCallback(huart);
 80301f8:	f000 bd0c 	b.w	8030c14 <HAL_UARTEx_TxFifoEmptyCallback>
  if (((isrflags & USART_ISR_RXFF) != 0U) && ((cr1its & USART_CR1_RXFFIE) != 0U))
 80301fc:	01d3      	lsls	r3, r2, #7
 80301fe:	f57f af3a 	bpl.w	8030076 <HAL_UART_IRQHandler+0x13a>
 8030202:	2900      	cmp	r1, #0
 8030204:	f6bf af37 	bge.w	8030076 <HAL_UART_IRQHandler+0x13a>
    HAL_UARTEx_RxFifoFullCallback(huart);
 8030208:	4620      	mov	r0, r4
}
 803020a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    HAL_UARTEx_RxFifoFullCallback(huart);
 803020e:	f000 bd00 	b.w	8030c12 <HAL_UARTEx_RxFifoFullCallback>
 8030212:	bf00      	nop
 8030214:	10000001 	.word	0x10000001
 8030218:	04000120 	.word	0x04000120
 803021c:	0802ff27 	.word	0x0802ff27
 8030220:	effffffe 	.word	0xeffffffe

08030224 <UART_RxISR_16BIT.part.0>:
/**
  * @brief RX interrupt handler for 7 or 8 bits data word length .
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_8BIT(UART_HandleTypeDef *huart)
 8030224:	b508      	push	{r3, lr}
    huart->RxXferCount--;

    if (huart->RxXferCount == 0U)
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupts */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 8030226:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030228:	e852 3f00 	ldrex	r3, [r2]
 803022c:	f423 7390 	bic.w	r3, r3, #288	; 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030230:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 8030234:	6803      	ldr	r3, [r0, #0]
 8030236:	2900      	cmp	r1, #0
 8030238:	d1f5      	bne.n	8030226 <UART_RxISR_16BIT.part.0+0x2>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 803023a:	f103 0208 	add.w	r2, r3, #8
 803023e:	e852 2f00 	ldrex	r2, [r2]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8030242:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030246:	f103 0c08 	add.w	ip, r3, #8
 803024a:	e84c 2100 	strex	r1, r2, [ip]
 803024e:	2900      	cmp	r1, #0
 8030250:	d1f3      	bne.n	803023a <UART_RxISR_16BIT.part.0+0x16>

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 8030252:	2220      	movs	r2, #32
 8030254:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
      /* Clear RxISR function pointer */
      huart->RxISR = NULL;

      /* Check current reception Mode :
         If Reception till IDLE event has been selected : */
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8030258:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
      huart->RxISR = NULL;
 803025a:	6701      	str	r1, [r0, #112]	; 0x70
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 803025c:	2a01      	cmp	r2, #1
 803025e:	d112      	bne.n	8030286 <UART_RxISR_16BIT.part.0+0x62>
      {
        /* Set reception type to Standard */
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8030260:	66c1      	str	r1, [r0, #108]	; 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030262:	e853 2f00 	ldrex	r2, [r3]

        /* Disable IDLE interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8030266:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 803026a:	e843 2100 	strex	r1, r2, [r3]
 803026e:	2900      	cmp	r1, #0
 8030270:	d1f7      	bne.n	8030262 <UART_RxISR_16BIT.part.0+0x3e>

        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 8030272:	69da      	ldr	r2, [r3, #28]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, huart->RxXferSize);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8030274:	f8b0 105c 	ldrh.w	r1, [r0, #92]	; 0x5c
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 8030278:	06d2      	lsls	r2, r2, #27
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 803027a:	bf44      	itt	mi
 803027c:	2210      	movmi	r2, #16
 803027e:	621a      	strmi	r2, [r3, #32]
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8030280:	f7ff fe5b 	bl	802ff3a <HAL_UARTEx_RxEventCallback>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 8030284:	bd08      	pop	{r3, pc}
        HAL_UART_RxCpltCallback(huart);
 8030286:	f7fc fc39 	bl	802cafc <HAL_UART_RxCpltCallback>
}
 803028a:	e7fb      	b.n	8030284 <UART_RxISR_16BIT.part.0+0x60>

0803028c <UART_RxISR_16BIT>:
  uint16_t *tmp;
  uint16_t uhMask = huart->Mask;
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 803028c:	f8d0 1088 	ldr.w	r1, [r0, #136]	; 0x88
 8030290:	6802      	ldr	r2, [r0, #0]
 8030292:	2922      	cmp	r1, #34	; 0x22
 8030294:	d113      	bne.n	80302be <UART_RxISR_16BIT+0x32>
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8030296:	6a51      	ldr	r1, [r2, #36]	; 0x24
    tmp = (uint16_t *) huart->pRxBuffPtr ;
    *tmp = (uint16_t)(uhdata & uhMask);
 8030298:	f8b0 2060 	ldrh.w	r2, [r0, #96]	; 0x60
 803029c:	4011      	ands	r1, r2
 803029e:	6d82      	ldr	r2, [r0, #88]	; 0x58
 80302a0:	f822 1b02 	strh.w	r1, [r2], #2
    huart->pRxBuffPtr += 2U;
 80302a4:	6582      	str	r2, [r0, #88]	; 0x58
    huart->RxXferCount--;
 80302a6:	f8b0 205e 	ldrh.w	r2, [r0, #94]	; 0x5e
 80302aa:	3a01      	subs	r2, #1
 80302ac:	b292      	uxth	r2, r2
 80302ae:	f8a0 205e 	strh.w	r2, [r0, #94]	; 0x5e

    if (huart->RxXferCount == 0U)
 80302b2:	f8b0 305e 	ldrh.w	r3, [r0, #94]	; 0x5e
 80302b6:	b29b      	uxth	r3, r3
 80302b8:	b92b      	cbnz	r3, 80302c6 <UART_RxISR_16BIT+0x3a>
 80302ba:	f7ff bfb3 	b.w	8030224 <UART_RxISR_16BIT.part.0>
    }
  }
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 80302be:	6993      	ldr	r3, [r2, #24]
 80302c0:	f043 0308 	orr.w	r3, r3, #8
 80302c4:	6193      	str	r3, [r2, #24]
  }
}
 80302c6:	4770      	bx	lr

080302c8 <UART_RxISR_8BIT>:
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 80302c8:	f8d0 1088 	ldr.w	r1, [r0, #136]	; 0x88
 80302cc:	6802      	ldr	r2, [r0, #0]
 80302ce:	2922      	cmp	r1, #34	; 0x22
{
 80302d0:	b410      	push	{r4}
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 80302d2:	d115      	bne.n	8030300 <UART_RxISR_8BIT+0x38>
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 80302d4:	6a52      	ldr	r2, [r2, #36]	; 0x24
    *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 80302d6:	f890 4060 	ldrb.w	r4, [r0, #96]	; 0x60
 80302da:	6d81      	ldr	r1, [r0, #88]	; 0x58
 80302dc:	4022      	ands	r2, r4
 80302de:	700a      	strb	r2, [r1, #0]
    huart->pRxBuffPtr++;
 80302e0:	6d82      	ldr	r2, [r0, #88]	; 0x58
 80302e2:	3201      	adds	r2, #1
 80302e4:	6582      	str	r2, [r0, #88]	; 0x58
    huart->RxXferCount--;
 80302e6:	f8b0 205e 	ldrh.w	r2, [r0, #94]	; 0x5e
 80302ea:	3a01      	subs	r2, #1
 80302ec:	b292      	uxth	r2, r2
 80302ee:	f8a0 205e 	strh.w	r2, [r0, #94]	; 0x5e
    if (huart->RxXferCount == 0U)
 80302f2:	f8b0 305e 	ldrh.w	r3, [r0, #94]	; 0x5e
 80302f6:	b29b      	uxth	r3, r3
 80302f8:	b933      	cbnz	r3, 8030308 <UART_RxISR_8BIT+0x40>
}
 80302fa:	bc10      	pop	{r4}
 80302fc:	f7ff bf92 	b.w	8030224 <UART_RxISR_16BIT.part.0>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 8030300:	6993      	ldr	r3, [r2, #24]
 8030302:	f043 0308 	orr.w	r3, r3, #8
 8030306:	6193      	str	r3, [r2, #24]
}
 8030308:	bc10      	pop	{r4}
 803030a:	4770      	bx	lr

0803030c <UART_RxISR_8BIT_FIFOEN>:
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_8BIT_FIFOEN(UART_HandleTypeDef *huart)
{
 803030c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint16_t  uhMask = huart->Mask;
  uint16_t  uhdata;
  uint16_t  nb_rx_data;
  uint16_t  rxdatacount;
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
 8030310:	6803      	ldr	r3, [r0, #0]
 8030312:	69dd      	ldr	r5, [r3, #28]
  uint32_t  cr1its   = READ_REG(huart->Instance->CR1);
 8030314:	f8d3 8000 	ldr.w	r8, [r3]
  uint32_t  cr3its   = READ_REG(huart->Instance->CR3);
 8030318:	689e      	ldr	r6, [r3, #8]

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 803031a:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 803031e:	2a22      	cmp	r2, #34	; 0x22
{
 8030320:	4604      	mov	r4, r0
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8030322:	f040 80a7 	bne.w	8030474 <UART_RxISR_8BIT_FIFOEN+0x168>
  uint16_t  uhMask = huart->Mask;
 8030326:	f8b0 7060 	ldrh.w	r7, [r0, #96]	; 0x60
  {
    nb_rx_data = huart->NbRxDataToProcess;
 803032a:	f8b0 9068 	ldrh.w	r9, [r0, #104]	; 0x68
        /* Disable the UART Parity Error Interrupt and RXFT interrupt*/
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);

        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error)
           and RX FIFO Threshold interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 803032e:	f8df b154 	ldr.w	fp, [pc, #340]	; 8030484 <UART_RxISR_8BIT_FIFOEN+0x178>
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 8030332:	f04f 0a00 	mov.w	sl, #0
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8030336:	f006 0601 	and.w	r6, r6, #1
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 803033a:	f1b9 0f00 	cmp.w	r9, #0
 803033e:	d001      	beq.n	8030344 <UART_RxISR_8BIT_FIFOEN+0x38>
 8030340:	06ab      	lsls	r3, r5, #26
 8030342:	d420      	bmi.n	8030386 <UART_RxISR_8BIT_FIFOEN+0x7a>

    /* When remaining number of bytes to receive is less than the RX FIFO
    threshold, next incoming frames are processed as if FIFO mode was
    disabled (i.e. one interrupt per received frame).
    */
    rxdatacount = huart->RxXferCount;
 8030344:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 8030348:	b29b      	uxth	r3, r3
    if ((rxdatacount != 0U) && (rxdatacount < huart->NbRxDataToProcess))
 803034a:	b1d3      	cbz	r3, 8030382 <UART_RxISR_8BIT_FIFOEN+0x76>
 803034c:	f8b4 2068 	ldrh.w	r2, [r4, #104]	; 0x68
 8030350:	429a      	cmp	r2, r3
 8030352:	d916      	bls.n	8030382 <UART_RxISR_8BIT_FIFOEN+0x76>
    {
      /* Disable the UART RXFT interrupt*/
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 8030354:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030356:	f102 0308 	add.w	r3, r2, #8
 803035a:	e853 3f00 	ldrex	r3, [r3]
 803035e:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030362:	3208      	adds	r2, #8
 8030364:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 8030368:	6822      	ldr	r2, [r4, #0]
 803036a:	2900      	cmp	r1, #0
 803036c:	d1f2      	bne.n	8030354 <UART_RxISR_8BIT_FIFOEN+0x48>

      /* Update the RxISR function pointer */
      huart->RxISR = UART_RxISR_8BIT;
 803036e:	4b44      	ldr	r3, [pc, #272]	; (8030480 <UART_RxISR_8BIT_FIFOEN+0x174>)
 8030370:	6723      	str	r3, [r4, #112]	; 0x70
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030372:	e852 3f00 	ldrex	r3, [r2]

      /* Enable the UART Data Register Not Empty interrupt */
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
 8030376:	f043 0320 	orr.w	r3, r3, #32
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 803037a:	e842 3100 	strex	r1, r3, [r2]
 803037e:	2900      	cmp	r1, #0
 8030380:	d1f7      	bne.n	8030372 <UART_RxISR_8BIT_FIFOEN+0x66>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 8030382:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8030386:	6823      	ldr	r3, [r4, #0]
      *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 8030388:	6da2      	ldr	r2, [r4, #88]	; 0x58
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 803038a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
      *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 803038c:	403b      	ands	r3, r7
 803038e:	7013      	strb	r3, [r2, #0]
      huart->pRxBuffPtr++;
 8030390:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8030392:	3301      	adds	r3, #1
 8030394:	65a3      	str	r3, [r4, #88]	; 0x58
      huart->RxXferCount--;
 8030396:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 803039a:	3b01      	subs	r3, #1
 803039c:	b29b      	uxth	r3, r3
 803039e:	f8a4 305e 	strh.w	r3, [r4, #94]	; 0x5e
      isrflags = READ_REG(huart->Instance->ISR);
 80303a2:	6823      	ldr	r3, [r4, #0]
 80303a4:	69dd      	ldr	r5, [r3, #28]
      if ((isrflags & (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE)) != 0U)
 80303a6:	0769      	lsls	r1, r5, #29
 80303a8:	d02a      	beq.n	8030400 <UART_RxISR_8BIT_FIFOEN+0xf4>
        if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 80303aa:	07ea      	lsls	r2, r5, #31
 80303ac:	d50a      	bpl.n	80303c4 <UART_RxISR_8BIT_FIFOEN+0xb8>
 80303ae:	f418 7f80 	tst.w	r8, #256	; 0x100
 80303b2:	d007      	beq.n	80303c4 <UART_RxISR_8BIT_FIFOEN+0xb8>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 80303b4:	2201      	movs	r2, #1
 80303b6:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_PE;
 80303b8:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 80303bc:	f042 0201 	orr.w	r2, r2, #1
 80303c0:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
        if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 80303c4:	07a8      	lsls	r0, r5, #30
 80303c6:	d508      	bpl.n	80303da <UART_RxISR_8BIT_FIFOEN+0xce>
 80303c8:	b13e      	cbz	r6, 80303da <UART_RxISR_8BIT_FIFOEN+0xce>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 80303ca:	2202      	movs	r2, #2
 80303cc:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_FE;
 80303ce:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 80303d2:	f042 0204 	orr.w	r2, r2, #4
 80303d6:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 80303da:	0769      	lsls	r1, r5, #29
 80303dc:	d508      	bpl.n	80303f0 <UART_RxISR_8BIT_FIFOEN+0xe4>
 80303de:	b13e      	cbz	r6, 80303f0 <UART_RxISR_8BIT_FIFOEN+0xe4>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 80303e0:	2204      	movs	r2, #4
 80303e2:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_NE;
 80303e4:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 80303e8:	f043 0302 	orr.w	r3, r3, #2
 80303ec:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
        if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 80303f0:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 80303f4:	b123      	cbz	r3, 8030400 <UART_RxISR_8BIT_FIFOEN+0xf4>
          HAL_UART_ErrorCallback(huart);
 80303f6:	4620      	mov	r0, r4
 80303f8:	f7ff fd6f 	bl	802feda <HAL_UART_ErrorCallback>
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 80303fc:	f8c4 a08c 	str.w	sl, [r4, #140]	; 0x8c
      if (huart->RxXferCount == 0U)
 8030400:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 8030404:	b29b      	uxth	r3, r3
 8030406:	2b00      	cmp	r3, #0
 8030408:	d197      	bne.n	803033a <UART_RxISR_8BIT_FIFOEN+0x2e>
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 803040a:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 803040c:	e852 3f00 	ldrex	r3, [r2]
 8030410:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030414:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 8030418:	6823      	ldr	r3, [r4, #0]
 803041a:	2900      	cmp	r1, #0
 803041c:	d1f5      	bne.n	803040a <UART_RxISR_8BIT_FIFOEN+0xfe>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 803041e:	f103 0208 	add.w	r2, r3, #8
 8030422:	e852 2f00 	ldrex	r2, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 8030426:	ea02 020b 	and.w	r2, r2, fp
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 803042a:	f103 0008 	add.w	r0, r3, #8
 803042e:	e840 2100 	strex	r1, r2, [r0]
 8030432:	2900      	cmp	r1, #0
 8030434:	d1f3      	bne.n	803041e <UART_RxISR_8BIT_FIFOEN+0x112>
        huart->RxState = HAL_UART_STATE_READY;
 8030436:	2220      	movs	r2, #32
 8030438:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 803043c:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
        huart->RxISR = NULL;
 803043e:	6721      	str	r1, [r4, #112]	; 0x70
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8030440:	2a01      	cmp	r2, #1
 8030442:	d113      	bne.n	803046c <UART_RxISR_8BIT_FIFOEN+0x160>
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8030444:	66e1      	str	r1, [r4, #108]	; 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030446:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 803044a:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 803044e:	e843 2100 	strex	r1, r2, [r3]
 8030452:	2900      	cmp	r1, #0
 8030454:	d1f7      	bne.n	8030446 <UART_RxISR_8BIT_FIFOEN+0x13a>
          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 8030456:	69da      	ldr	r2, [r3, #28]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8030458:	f8b4 105c 	ldrh.w	r1, [r4, #92]	; 0x5c
          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 803045c:	06d2      	lsls	r2, r2, #27
            __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 803045e:	bf44      	itt	mi
 8030460:	2210      	movmi	r2, #16
 8030462:	621a      	strmi	r2, [r3, #32]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8030464:	4620      	mov	r0, r4
 8030466:	f7ff fd68 	bl	802ff3a <HAL_UARTEx_RxEventCallback>
 803046a:	e766      	b.n	803033a <UART_RxISR_8BIT_FIFOEN+0x2e>
          HAL_UART_RxCpltCallback(huart);
 803046c:	4620      	mov	r0, r4
 803046e:	f7fc fb45 	bl	802cafc <HAL_UART_RxCpltCallback>
 8030472:	e762      	b.n	803033a <UART_RxISR_8BIT_FIFOEN+0x2e>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 8030474:	699a      	ldr	r2, [r3, #24]
 8030476:	f042 0208 	orr.w	r2, r2, #8
 803047a:	619a      	str	r2, [r3, #24]
}
 803047c:	e781      	b.n	8030382 <UART_RxISR_8BIT_FIFOEN+0x76>
 803047e:	bf00      	nop
 8030480:	080302c9 	.word	0x080302c9
 8030484:	effffffe 	.word	0xeffffffe

08030488 <UART_RxISR_16BIT_FIFOEN>:
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_16BIT_FIFOEN(UART_HandleTypeDef *huart)
{
 8030488:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint16_t *tmp;
  uint16_t  uhMask = huart->Mask;
  uint16_t  uhdata;
  uint16_t  nb_rx_data;
  uint16_t  rxdatacount;
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
 803048c:	6803      	ldr	r3, [r0, #0]
 803048e:	69dd      	ldr	r5, [r3, #28]
  uint32_t  cr1its   = READ_REG(huart->Instance->CR1);
 8030490:	f8d3 8000 	ldr.w	r8, [r3]
  uint32_t  cr3its   = READ_REG(huart->Instance->CR3);
 8030494:	689e      	ldr	r6, [r3, #8]

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8030496:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 803049a:	2a22      	cmp	r2, #34	; 0x22
{
 803049c:	4604      	mov	r4, r0
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 803049e:	f040 80a5 	bne.w	80305ec <UART_RxISR_16BIT_FIFOEN+0x164>
  uint16_t  uhMask = huart->Mask;
 80304a2:	f8b0 7060 	ldrh.w	r7, [r0, #96]	; 0x60
  {
    nb_rx_data = huart->NbRxDataToProcess;
 80304a6:	f8b0 9068 	ldrh.w	r9, [r0, #104]	; 0x68
        /* Disable the UART Parity Error Interrupt and RXFT interrupt*/
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);

        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error)
           and RX FIFO Threshold interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 80304aa:	f8df b150 	ldr.w	fp, [pc, #336]	; 80305fc <UART_RxISR_16BIT_FIFOEN+0x174>
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 80304ae:	f04f 0a00 	mov.w	sl, #0
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 80304b2:	f006 0601 	and.w	r6, r6, #1
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 80304b6:	f1b9 0f00 	cmp.w	r9, #0
 80304ba:	d001      	beq.n	80304c0 <UART_RxISR_16BIT_FIFOEN+0x38>
 80304bc:	06ab      	lsls	r3, r5, #26
 80304be:	d420      	bmi.n	8030502 <UART_RxISR_16BIT_FIFOEN+0x7a>

    /* When remaining number of bytes to receive is less than the RX FIFO
    threshold, next incoming frames are processed as if FIFO mode was
    disabled (i.e. one interrupt per received frame).
    */
    rxdatacount = huart->RxXferCount;
 80304c0:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 80304c4:	b29b      	uxth	r3, r3
    if ((rxdatacount != 0U) && (rxdatacount < huart->NbRxDataToProcess))
 80304c6:	b1d3      	cbz	r3, 80304fe <UART_RxISR_16BIT_FIFOEN+0x76>
 80304c8:	f8b4 2068 	ldrh.w	r2, [r4, #104]	; 0x68
 80304cc:	429a      	cmp	r2, r3
 80304ce:	d916      	bls.n	80304fe <UART_RxISR_16BIT_FIFOEN+0x76>
    {
      /* Disable the UART RXFT interrupt*/
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 80304d0:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80304d2:	f102 0308 	add.w	r3, r2, #8
 80304d6:	e853 3f00 	ldrex	r3, [r3]
 80304da:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80304de:	3208      	adds	r2, #8
 80304e0:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 80304e4:	6822      	ldr	r2, [r4, #0]
 80304e6:	2900      	cmp	r1, #0
 80304e8:	d1f2      	bne.n	80304d0 <UART_RxISR_16BIT_FIFOEN+0x48>

      /* Update the RxISR function pointer */
      huart->RxISR = UART_RxISR_16BIT;
 80304ea:	4b43      	ldr	r3, [pc, #268]	; (80305f8 <UART_RxISR_16BIT_FIFOEN+0x170>)
 80304ec:	6723      	str	r3, [r4, #112]	; 0x70
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80304ee:	e852 3f00 	ldrex	r3, [r2]

      /* Enable the UART Data Register Not Empty interrupt */
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
 80304f2:	f043 0320 	orr.w	r3, r3, #32
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80304f6:	e842 3100 	strex	r1, r3, [r2]
 80304fa:	2900      	cmp	r1, #0
 80304fc:	d1f7      	bne.n	80304ee <UART_RxISR_16BIT_FIFOEN+0x66>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 80304fe:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8030502:	6823      	ldr	r3, [r4, #0]
      *tmp = (uint16_t)(uhdata & uhMask);
 8030504:	6da2      	ldr	r2, [r4, #88]	; 0x58
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8030506:	6a59      	ldr	r1, [r3, #36]	; 0x24
      *tmp = (uint16_t)(uhdata & uhMask);
 8030508:	4039      	ands	r1, r7
 803050a:	f822 1b02 	strh.w	r1, [r2], #2
      huart->pRxBuffPtr += 2U;
 803050e:	65a2      	str	r2, [r4, #88]	; 0x58
      huart->RxXferCount--;
 8030510:	f8b4 205e 	ldrh.w	r2, [r4, #94]	; 0x5e
 8030514:	3a01      	subs	r2, #1
 8030516:	b292      	uxth	r2, r2
 8030518:	f8a4 205e 	strh.w	r2, [r4, #94]	; 0x5e
      isrflags = READ_REG(huart->Instance->ISR);
 803051c:	69dd      	ldr	r5, [r3, #28]
      if ((isrflags & (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE)) != 0U)
 803051e:	0769      	lsls	r1, r5, #29
 8030520:	d02a      	beq.n	8030578 <UART_RxISR_16BIT_FIFOEN+0xf0>
        if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 8030522:	07ea      	lsls	r2, r5, #31
 8030524:	d50a      	bpl.n	803053c <UART_RxISR_16BIT_FIFOEN+0xb4>
 8030526:	f418 7f80 	tst.w	r8, #256	; 0x100
 803052a:	d007      	beq.n	803053c <UART_RxISR_16BIT_FIFOEN+0xb4>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 803052c:	2201      	movs	r2, #1
 803052e:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_PE;
 8030530:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 8030534:	f042 0201 	orr.w	r2, r2, #1
 8030538:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
        if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 803053c:	07a8      	lsls	r0, r5, #30
 803053e:	d508      	bpl.n	8030552 <UART_RxISR_16BIT_FIFOEN+0xca>
 8030540:	b13e      	cbz	r6, 8030552 <UART_RxISR_16BIT_FIFOEN+0xca>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 8030542:	2202      	movs	r2, #2
 8030544:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_FE;
 8030546:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 803054a:	f042 0204 	orr.w	r2, r2, #4
 803054e:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8030552:	0769      	lsls	r1, r5, #29
 8030554:	d508      	bpl.n	8030568 <UART_RxISR_16BIT_FIFOEN+0xe0>
 8030556:	b13e      	cbz	r6, 8030568 <UART_RxISR_16BIT_FIFOEN+0xe0>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 8030558:	2204      	movs	r2, #4
 803055a:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_NE;
 803055c:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 8030560:	f043 0302 	orr.w	r3, r3, #2
 8030564:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
        if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 8030568:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 803056c:	b123      	cbz	r3, 8030578 <UART_RxISR_16BIT_FIFOEN+0xf0>
          HAL_UART_ErrorCallback(huart);
 803056e:	4620      	mov	r0, r4
 8030570:	f7ff fcb3 	bl	802feda <HAL_UART_ErrorCallback>
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 8030574:	f8c4 a08c 	str.w	sl, [r4, #140]	; 0x8c
      if (huart->RxXferCount == 0U)
 8030578:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 803057c:	b29b      	uxth	r3, r3
 803057e:	2b00      	cmp	r3, #0
 8030580:	d199      	bne.n	80304b6 <UART_RxISR_16BIT_FIFOEN+0x2e>
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8030582:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030584:	e852 3f00 	ldrex	r3, [r2]
 8030588:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 803058c:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 8030590:	6823      	ldr	r3, [r4, #0]
 8030592:	2900      	cmp	r1, #0
 8030594:	d1f5      	bne.n	8030582 <UART_RxISR_16BIT_FIFOEN+0xfa>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030596:	f103 0208 	add.w	r2, r3, #8
 803059a:	e852 2f00 	ldrex	r2, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 803059e:	ea02 020b 	and.w	r2, r2, fp
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80305a2:	f103 0008 	add.w	r0, r3, #8
 80305a6:	e840 2100 	strex	r1, r2, [r0]
 80305aa:	2900      	cmp	r1, #0
 80305ac:	d1f3      	bne.n	8030596 <UART_RxISR_16BIT_FIFOEN+0x10e>
        huart->RxState = HAL_UART_STATE_READY;
 80305ae:	2220      	movs	r2, #32
 80305b0:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 80305b4:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
        huart->RxISR = NULL;
 80305b6:	6721      	str	r1, [r4, #112]	; 0x70
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 80305b8:	2a01      	cmp	r2, #1
 80305ba:	d113      	bne.n	80305e4 <UART_RxISR_16BIT_FIFOEN+0x15c>
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80305bc:	66e1      	str	r1, [r4, #108]	; 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80305be:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 80305c2:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80305c6:	e843 2100 	strex	r1, r2, [r3]
 80305ca:	2900      	cmp	r1, #0
 80305cc:	d1f7      	bne.n	80305be <UART_RxISR_16BIT_FIFOEN+0x136>
          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 80305ce:	69da      	ldr	r2, [r3, #28]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 80305d0:	f8b4 105c 	ldrh.w	r1, [r4, #92]	; 0x5c
          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 80305d4:	06d2      	lsls	r2, r2, #27
            __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 80305d6:	bf44      	itt	mi
 80305d8:	2210      	movmi	r2, #16
 80305da:	621a      	strmi	r2, [r3, #32]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 80305dc:	4620      	mov	r0, r4
 80305de:	f7ff fcac 	bl	802ff3a <HAL_UARTEx_RxEventCallback>
 80305e2:	e768      	b.n	80304b6 <UART_RxISR_16BIT_FIFOEN+0x2e>
          HAL_UART_RxCpltCallback(huart);
 80305e4:	4620      	mov	r0, r4
 80305e6:	f7fc fa89 	bl	802cafc <HAL_UART_RxCpltCallback>
 80305ea:	e764      	b.n	80304b6 <UART_RxISR_16BIT_FIFOEN+0x2e>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 80305ec:	699a      	ldr	r2, [r3, #24]
 80305ee:	f042 0208 	orr.w	r2, r2, #8
 80305f2:	619a      	str	r2, [r3, #24]
}
 80305f4:	e783      	b.n	80304fe <UART_RxISR_16BIT_FIFOEN+0x76>
 80305f6:	bf00      	nop
 80305f8:	0803028d 	.word	0x0803028d
 80305fc:	effffffe 	.word	0xeffffffe

08030600 <UART_SetConfig>:
{
 8030600:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8030602:	4604      	mov	r4, r0
  if (UART_INSTANCE_LOWPOWER(huart))
 8030604:	6803      	ldr	r3, [r0, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8030606:	6921      	ldr	r1, [r4, #16]
 8030608:	68a2      	ldr	r2, [r4, #8]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 803060a:	681d      	ldr	r5, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 803060c:	69c0      	ldr	r0, [r0, #28]
 803060e:	430a      	orrs	r2, r1
 8030610:	6961      	ldr	r1, [r4, #20]
 8030612:	430a      	orrs	r2, r1
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8030614:	497f      	ldr	r1, [pc, #508]	; (8030814 <UART_SetConfig+0x214>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8030616:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8030618:	4029      	ands	r1, r5
 803061a:	430a      	orrs	r2, r1
 803061c:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 803061e:	685a      	ldr	r2, [r3, #4]
 8030620:	68e1      	ldr	r1, [r4, #12]
 8030622:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 8030626:	430a      	orrs	r2, r1
 8030628:	605a      	str	r2, [r3, #4]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 803062a:	4a7b      	ldr	r2, [pc, #492]	; (8030818 <UART_SetConfig+0x218>)
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 803062c:	69a1      	ldr	r1, [r4, #24]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 803062e:	4293      	cmp	r3, r2
    tmpreg |= huart->Init.OneBitSampling;
 8030630:	bf1c      	itt	ne
 8030632:	6a22      	ldrne	r2, [r4, #32]
 8030634:	4311      	orrne	r1, r2
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 8030636:	689a      	ldr	r2, [r3, #8]
 8030638:	f022 426e 	bic.w	r2, r2, #3992977408	; 0xee000000
 803063c:	f422 6230 	bic.w	r2, r2, #2816	; 0xb00
 8030640:	430a      	orrs	r2, r1
 8030642:	609a      	str	r2, [r3, #8]
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 8030644:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8030646:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8030648:	f022 020f 	bic.w	r2, r2, #15
 803064c:	430a      	orrs	r2, r1
 803064e:	62da      	str	r2, [r3, #44]	; 0x2c
  UART_GETCLOCKSOURCE(huart, clocksource);
 8030650:	4a72      	ldr	r2, [pc, #456]	; (803081c <UART_SetConfig+0x21c>)
 8030652:	4293      	cmp	r3, r2
 8030654:	d11c      	bne.n	8030690 <UART_SetConfig+0x90>
  return (uint32_t)(READ_BIT(RCC->CCIPR, USARTx) | (USARTx << 16));
 8030656:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 803065a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 803065e:	f003 0303 	and.w	r3, r3, #3
 8030662:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
 8030666:	f5a3 3340 	sub.w	r3, r3, #196608	; 0x30000
 803066a:	3b01      	subs	r3, #1
 803066c:	2b02      	cmp	r3, #2
 803066e:	f200 80cb 	bhi.w	8030808 <UART_SetConfig+0x208>
 8030672:	4a6b      	ldr	r2, [pc, #428]	; (8030820 <UART_SetConfig+0x220>)
 8030674:	5c9b      	ldrb	r3, [r3, r2]
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8030676:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 803067a:	f040 808c 	bne.w	8030796 <UART_SetConfig+0x196>
    switch (clocksource)
 803067e:	2b08      	cmp	r3, #8
 8030680:	d824      	bhi.n	80306cc <UART_SetConfig+0xcc>
 8030682:	e8df f003 	tbb	[pc, r3]
 8030686:	c462      	.short	0xc462
 8030688:	23832386 	.word	0x23832386
 803068c:	2323      	.short	0x2323
 803068e:	66          	.byte	0x66
 803068f:	00          	.byte	0x00
  UART_GETCLOCKSOURCE(huart, clocksource);
 8030690:	4a64      	ldr	r2, [pc, #400]	; (8030824 <UART_SetConfig+0x224>)
 8030692:	4293      	cmp	r3, r2
 8030694:	d109      	bne.n	80306aa <UART_SetConfig+0xaa>
 8030696:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 803069a:	4a63      	ldr	r2, [pc, #396]	; (8030828 <UART_SetConfig+0x228>)
 803069c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80306a0:	f003 030c 	and.w	r3, r3, #12
 80306a4:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
 80306a8:	e7e4      	b.n	8030674 <UART_SetConfig+0x74>
 80306aa:	4a5b      	ldr	r2, [pc, #364]	; (8030818 <UART_SetConfig+0x218>)
 80306ac:	4293      	cmp	r3, r2
 80306ae:	d10d      	bne.n	80306cc <UART_SetConfig+0xcc>
  return (uint32_t)(READ_BIT(RCC->CCIPR, LPUARTx));
 80306b0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80306b4:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80306b8:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
 80306bc:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 80306c0:	d01a      	beq.n	80306f8 <UART_SetConfig+0xf8>
 80306c2:	d805      	bhi.n	80306d0 <UART_SetConfig+0xd0>
 80306c4:	b153      	cbz	r3, 80306dc <UART_SetConfig+0xdc>
 80306c6:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80306ca:	d012      	beq.n	80306f2 <UART_SetConfig+0xf2>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80306cc:	2001      	movs	r0, #1
 80306ce:	e009      	b.n	80306e4 <UART_SetConfig+0xe4>
  UART_GETCLOCKSOURCE(huart, clocksource);
 80306d0:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 80306d4:	d1fa      	bne.n	80306cc <UART_SetConfig+0xcc>
        pclk = (uint32_t) LSE_VALUE;
 80306d6:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 80306da:	e00e      	b.n	80306fa <UART_SetConfig+0xfa>
        pclk = HAL_RCC_GetPCLK1Freq();
 80306dc:	f7fe fd40 	bl	802f160 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 80306e0:	b958      	cbnz	r0, 80306fa <UART_SetConfig+0xfa>
 80306e2:	2000      	movs	r0, #0
  huart->NbRxDataToProcess = 1;
 80306e4:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 80306e8:	66a3      	str	r3, [r4, #104]	; 0x68
  huart->RxISR = NULL;
 80306ea:	2300      	movs	r3, #0
  huart->TxISR = NULL;
 80306ec:	e9c4 331c 	strd	r3, r3, [r4, #112]	; 0x70
}
 80306f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        pclk = HAL_RCC_GetSysClockFreq();
 80306f2:	f7fe f91f 	bl	802e934 <HAL_RCC_GetSysClockFreq>
        break;
 80306f6:	e7f3      	b.n	80306e0 <UART_SetConfig+0xe0>
  UART_GETCLOCKSOURCE(huart, clocksource);
 80306f8:	484c      	ldr	r0, [pc, #304]	; (803082c <UART_SetConfig+0x22c>)
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 80306fa:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80306fc:	4b48      	ldr	r3, [pc, #288]	; (8030820 <UART_SetConfig+0x220>)
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 80306fe:	6865      	ldr	r5, [r4, #4]
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 8030700:	eb03 0342 	add.w	r3, r3, r2, lsl #1
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 8030704:	eb05 0145 	add.w	r1, r5, r5, lsl #1
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 8030708:	8a1a      	ldrh	r2, [r3, #16]
 803070a:	fbb0 f3f2 	udiv	r3, r0, r2
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 803070e:	4299      	cmp	r1, r3
 8030710:	d8dc      	bhi.n	80306cc <UART_SetConfig+0xcc>
 8030712:	ebb3 3f05 	cmp.w	r3, r5, lsl #12
 8030716:	d8d9      	bhi.n	80306cc <UART_SetConfig+0xcc>
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8030718:	2300      	movs	r3, #0
 803071a:	2100      	movs	r1, #0
 803071c:	f7fb fa12 	bl	802bb44 <__aeabi_uldivmod>
 8030720:	020f      	lsls	r7, r1, #8
 8030722:	ea47 6710 	orr.w	r7, r7, r0, lsr #24
 8030726:	0206      	lsls	r6, r0, #8
 8030728:	0868      	lsrs	r0, r5, #1
 803072a:	1830      	adds	r0, r6, r0
 803072c:	462a      	mov	r2, r5
 803072e:	f04f 0300 	mov.w	r3, #0
 8030732:	f147 0100 	adc.w	r1, r7, #0
 8030736:	f7fb fa05 	bl	802bb44 <__aeabi_uldivmod>
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 803073a:	4b3d      	ldr	r3, [pc, #244]	; (8030830 <UART_SetConfig+0x230>)
 803073c:	f5a0 7240 	sub.w	r2, r0, #768	; 0x300
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8030740:	429a      	cmp	r2, r3
 8030742:	d8c3      	bhi.n	80306cc <UART_SetConfig+0xcc>
        huart->Instance->BRR = usartdiv;
 8030744:	6823      	ldr	r3, [r4, #0]
 8030746:	60d8      	str	r0, [r3, #12]
 8030748:	e7cb      	b.n	80306e2 <UART_SetConfig+0xe2>
        pclk = HAL_RCC_GetPCLK1Freq();
 803074a:	f7fe fd09 	bl	802f160 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 803074e:	2800      	cmp	r0, #0
 8030750:	d0c7      	beq.n	80306e2 <UART_SetConfig+0xe2>
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8030752:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8030754:	4b32      	ldr	r3, [pc, #200]	; (8030820 <UART_SetConfig+0x220>)
 8030756:	6862      	ldr	r2, [r4, #4]
 8030758:	eb03 0341 	add.w	r3, r3, r1, lsl #1
 803075c:	8a1b      	ldrh	r3, [r3, #16]
 803075e:	fbb0 f3f3 	udiv	r3, r0, r3
 8030762:	0850      	lsrs	r0, r2, #1
 8030764:	eb00 0043 	add.w	r0, r0, r3, lsl #1
 8030768:	fbb0 f0f2 	udiv	r0, r0, r2
 803076c:	b283      	uxth	r3, r0
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 803076e:	f1a3 0110 	sub.w	r1, r3, #16
 8030772:	f64f 72ef 	movw	r2, #65519	; 0xffef
 8030776:	4291      	cmp	r1, r2
 8030778:	d8a8      	bhi.n	80306cc <UART_SetConfig+0xcc>
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 803077a:	f020 000f 	bic.w	r0, r0, #15
        huart->Instance->BRR = brrtemp;
 803077e:	6822      	ldr	r2, [r4, #0]
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 8030780:	b280      	uxth	r0, r0
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 8030782:	f3c3 0342 	ubfx	r3, r3, #1, #3
        huart->Instance->BRR = brrtemp;
 8030786:	4318      	orrs	r0, r3
 8030788:	60d0      	str	r0, [r2, #12]
 803078a:	e7aa      	b.n	80306e2 <UART_SetConfig+0xe2>
        pclk = HAL_RCC_GetSysClockFreq();
 803078c:	f7fe f8d2 	bl	802e934 <HAL_RCC_GetSysClockFreq>
        break;
 8030790:	e7dd      	b.n	803074e <UART_SetConfig+0x14e>
        pclk = (uint32_t) HSI_VALUE;
 8030792:	4826      	ldr	r0, [pc, #152]	; (803082c <UART_SetConfig+0x22c>)
 8030794:	e7dd      	b.n	8030752 <UART_SetConfig+0x152>
    switch (clocksource)
 8030796:	2b08      	cmp	r3, #8
 8030798:	d898      	bhi.n	80306cc <UART_SetConfig+0xcc>
 803079a:	a201      	add	r2, pc, #4	; (adr r2, 80307a0 <UART_SetConfig+0x1a0>)
 803079c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80307a0:	080307ed 	.word	0x080307ed
 80307a4:	080307f9 	.word	0x080307f9
 80307a8:	08030805 	.word	0x08030805
 80307ac:	080306cd 	.word	0x080306cd
 80307b0:	080307ff 	.word	0x080307ff
 80307b4:	080306cd 	.word	0x080306cd
 80307b8:	080306cd 	.word	0x080306cd
 80307bc:	080306cd 	.word	0x080306cd
 80307c0:	080307c5 	.word	0x080307c5
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80307c4:	f44f 4000 	mov.w	r0, #32768	; 0x8000
      usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 80307c8:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80307ca:	4b15      	ldr	r3, [pc, #84]	; (8030820 <UART_SetConfig+0x220>)
 80307cc:	6862      	ldr	r2, [r4, #4]
 80307ce:	eb03 0341 	add.w	r3, r3, r1, lsl #1
 80307d2:	8a1b      	ldrh	r3, [r3, #16]
 80307d4:	fbb0 f0f3 	udiv	r0, r0, r3
 80307d8:	eb00 0052 	add.w	r0, r0, r2, lsr #1
 80307dc:	fbb0 f0f2 	udiv	r0, r0, r2
 80307e0:	b280      	uxth	r0, r0
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 80307e2:	f1a0 0210 	sub.w	r2, r0, #16
 80307e6:	f64f 73ef 	movw	r3, #65519	; 0xffef
 80307ea:	e7a9      	b.n	8030740 <UART_SetConfig+0x140>
        pclk = HAL_RCC_GetPCLK1Freq();
 80307ec:	f7fe fcb8 	bl	802f160 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 80307f0:	2800      	cmp	r0, #0
 80307f2:	f43f af76 	beq.w	80306e2 <UART_SetConfig+0xe2>
 80307f6:	e7e7      	b.n	80307c8 <UART_SetConfig+0x1c8>
        pclk = HAL_RCC_GetPCLK2Freq();
 80307f8:	f7fe fcc2 	bl	802f180 <HAL_RCC_GetPCLK2Freq>
        break;
 80307fc:	e7f8      	b.n	80307f0 <UART_SetConfig+0x1f0>
        pclk = HAL_RCC_GetSysClockFreq();
 80307fe:	f7fe f899 	bl	802e934 <HAL_RCC_GetSysClockFreq>
        break;
 8030802:	e7f5      	b.n	80307f0 <UART_SetConfig+0x1f0>
        pclk = (uint32_t) HSI_VALUE;
 8030804:	4809      	ldr	r0, [pc, #36]	; (803082c <UART_SetConfig+0x22c>)
 8030806:	e7df      	b.n	80307c8 <UART_SetConfig+0x1c8>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8030808:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 803080c:	d1f4      	bne.n	80307f8 <UART_SetConfig+0x1f8>
        pclk = HAL_RCC_GetPCLK2Freq();
 803080e:	f7fe fcb7 	bl	802f180 <HAL_RCC_GetPCLK2Freq>
        break;
 8030812:	e79c      	b.n	803074e <UART_SetConfig+0x14e>
 8030814:	cfff69f3 	.word	0xcfff69f3
 8030818:	40008000 	.word	0x40008000
 803081c:	40013800 	.word	0x40013800
 8030820:	0803ba70 	.word	0x0803ba70
 8030824:	40004400 	.word	0x40004400
 8030828:	07f7ba73 	.word	0x07f7ba73
 803082c:	00f42400 	.word	0x00f42400
 8030830:	000ffcff 	.word	0x000ffcff

08030834 <UART_AdvFeatureConfig>:
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 8030834:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8030836:	07da      	lsls	r2, r3, #31
{
 8030838:	b510      	push	{r4, lr}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 803083a:	d506      	bpl.n	803084a <UART_AdvFeatureConfig+0x16>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 803083c:	6801      	ldr	r1, [r0, #0]
 803083e:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 8030840:	684a      	ldr	r2, [r1, #4]
 8030842:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 8030846:	4322      	orrs	r2, r4
 8030848:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 803084a:	079c      	lsls	r4, r3, #30
 803084c:	d506      	bpl.n	803085c <UART_AdvFeatureConfig+0x28>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 803084e:	6801      	ldr	r1, [r0, #0]
 8030850:	6b04      	ldr	r4, [r0, #48]	; 0x30
 8030852:	684a      	ldr	r2, [r1, #4]
 8030854:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8030858:	4322      	orrs	r2, r4
 803085a:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 803085c:	0759      	lsls	r1, r3, #29
 803085e:	d506      	bpl.n	803086e <UART_AdvFeatureConfig+0x3a>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 8030860:	6801      	ldr	r1, [r0, #0]
 8030862:	6b44      	ldr	r4, [r0, #52]	; 0x34
 8030864:	684a      	ldr	r2, [r1, #4]
 8030866:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 803086a:	4322      	orrs	r2, r4
 803086c:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 803086e:	071a      	lsls	r2, r3, #28
 8030870:	d506      	bpl.n	8030880 <UART_AdvFeatureConfig+0x4c>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 8030872:	6801      	ldr	r1, [r0, #0]
 8030874:	6b84      	ldr	r4, [r0, #56]	; 0x38
 8030876:	684a      	ldr	r2, [r1, #4]
 8030878:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 803087c:	4322      	orrs	r2, r4
 803087e:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 8030880:	06dc      	lsls	r4, r3, #27
 8030882:	d506      	bpl.n	8030892 <UART_AdvFeatureConfig+0x5e>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 8030884:	6801      	ldr	r1, [r0, #0]
 8030886:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 8030888:	688a      	ldr	r2, [r1, #8]
 803088a:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 803088e:	4322      	orrs	r2, r4
 8030890:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 8030892:	0699      	lsls	r1, r3, #26
 8030894:	d506      	bpl.n	80308a4 <UART_AdvFeatureConfig+0x70>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 8030896:	6801      	ldr	r1, [r0, #0]
 8030898:	6c04      	ldr	r4, [r0, #64]	; 0x40
 803089a:	688a      	ldr	r2, [r1, #8]
 803089c:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 80308a0:	4322      	orrs	r2, r4
 80308a2:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 80308a4:	065a      	lsls	r2, r3, #25
 80308a6:	d50f      	bpl.n	80308c8 <UART_AdvFeatureConfig+0x94>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 80308a8:	6801      	ldr	r1, [r0, #0]
 80308aa:	6c44      	ldr	r4, [r0, #68]	; 0x44
 80308ac:	684a      	ldr	r2, [r1, #4]
 80308ae:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 80308b2:	4322      	orrs	r2, r4
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 80308b4:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 80308b8:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 80308ba:	d105      	bne.n	80308c8 <UART_AdvFeatureConfig+0x94>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 80308bc:	684a      	ldr	r2, [r1, #4]
 80308be:	6c84      	ldr	r4, [r0, #72]	; 0x48
 80308c0:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
 80308c4:	4322      	orrs	r2, r4
 80308c6:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 80308c8:	061b      	lsls	r3, r3, #24
 80308ca:	d506      	bpl.n	80308da <UART_AdvFeatureConfig+0xa6>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 80308cc:	6802      	ldr	r2, [r0, #0]
 80308ce:	6cc1      	ldr	r1, [r0, #76]	; 0x4c
 80308d0:	6853      	ldr	r3, [r2, #4]
 80308d2:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 80308d6:	430b      	orrs	r3, r1
 80308d8:	6053      	str	r3, [r2, #4]
}
 80308da:	bd10      	pop	{r4, pc}

080308dc <UART_WaitOnFlagUntilTimeout>:
{
 80308dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80308e0:	f8dd 8018 	ldr.w	r8, [sp, #24]
 80308e4:	4604      	mov	r4, r0
 80308e6:	460e      	mov	r6, r1
 80308e8:	4615      	mov	r5, r2
 80308ea:	461f      	mov	r7, r3
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 80308ec:	6822      	ldr	r2, [r4, #0]
 80308ee:	69d3      	ldr	r3, [r2, #28]
 80308f0:	ea36 0303 	bics.w	r3, r6, r3
 80308f4:	bf0c      	ite	eq
 80308f6:	2301      	moveq	r3, #1
 80308f8:	2300      	movne	r3, #0
 80308fa:	42ab      	cmp	r3, r5
 80308fc:	d001      	beq.n	8030902 <UART_WaitOnFlagUntilTimeout+0x26>
  return HAL_OK;
 80308fe:	2000      	movs	r0, #0
 8030900:	e027      	b.n	8030952 <UART_WaitOnFlagUntilTimeout+0x76>
    if (Timeout != HAL_MAX_DELAY)
 8030902:	f1b8 3fff 	cmp.w	r8, #4294967295
 8030906:	d0f2      	beq.n	80308ee <UART_WaitOnFlagUntilTimeout+0x12>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8030908:	f7fb fe9c 	bl	802c644 <HAL_GetTick>
 803090c:	1bc0      	subs	r0, r0, r7
 803090e:	4540      	cmp	r0, r8
 8030910:	6820      	ldr	r0, [r4, #0]
 8030912:	d802      	bhi.n	803091a <UART_WaitOnFlagUntilTimeout+0x3e>
 8030914:	f1b8 0f00 	cmp.w	r8, #0
 8030918:	d11d      	bne.n	8030956 <UART_WaitOnFlagUntilTimeout+0x7a>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 803091a:	e850 3f00 	ldrex	r3, [r0]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |
 803091e:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030922:	e840 3200 	strex	r2, r3, [r0]
 8030926:	2a00      	cmp	r2, #0
 8030928:	d1f7      	bne.n	803091a <UART_WaitOnFlagUntilTimeout+0x3e>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 803092a:	f100 0308 	add.w	r3, r0, #8
 803092e:	e853 3f00 	ldrex	r3, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8030932:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030936:	f100 0108 	add.w	r1, r0, #8
 803093a:	e841 3200 	strex	r2, r3, [r1]
 803093e:	2a00      	cmp	r2, #0
 8030940:	d1f3      	bne.n	803092a <UART_WaitOnFlagUntilTimeout+0x4e>
        huart->gState = HAL_UART_STATE_READY;
 8030942:	2320      	movs	r3, #32
 8030944:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
        huart->RxState = HAL_UART_STATE_READY;
 8030948:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
          __HAL_UNLOCK(huart);
 803094c:	f884 2080 	strb.w	r2, [r4, #128]	; 0x80
          return HAL_TIMEOUT;
 8030950:	2003      	movs	r0, #3
}
 8030952:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 8030956:	6803      	ldr	r3, [r0, #0]
 8030958:	075a      	lsls	r2, r3, #29
 803095a:	d5c7      	bpl.n	80308ec <UART_WaitOnFlagUntilTimeout+0x10>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 803095c:	69c3      	ldr	r3, [r0, #28]
 803095e:	051b      	lsls	r3, r3, #20
 8030960:	d5c4      	bpl.n	80308ec <UART_WaitOnFlagUntilTimeout+0x10>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 8030962:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8030966:	6203      	str	r3, [r0, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030968:	e850 3f00 	ldrex	r3, [r0]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |
 803096c:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030970:	e840 3200 	strex	r2, r3, [r0]
 8030974:	2a00      	cmp	r2, #0
 8030976:	d1f7      	bne.n	8030968 <UART_WaitOnFlagUntilTimeout+0x8c>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030978:	f100 0308 	add.w	r3, r0, #8
 803097c:	e853 3f00 	ldrex	r3, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8030980:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030984:	f100 0108 	add.w	r1, r0, #8
 8030988:	e841 3200 	strex	r2, r3, [r1]
 803098c:	2a00      	cmp	r2, #0
 803098e:	d1f3      	bne.n	8030978 <UART_WaitOnFlagUntilTimeout+0x9c>
          huart->gState = HAL_UART_STATE_READY;
 8030990:	2320      	movs	r3, #32
 8030992:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
          huart->RxState = HAL_UART_STATE_READY;
 8030996:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 803099a:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
 803099e:	e7d5      	b.n	803094c <UART_WaitOnFlagUntilTimeout+0x70>

080309a0 <UART_CheckIdleState>:
{
 80309a0:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80309a2:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 80309a4:	2600      	movs	r6, #0
 80309a6:	f8c0 608c 	str.w	r6, [r0, #140]	; 0x8c
  tickstart = HAL_GetTick();
 80309aa:	f7fb fe4b 	bl	802c644 <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 80309ae:	6823      	ldr	r3, [r4, #0]
 80309b0:	681b      	ldr	r3, [r3, #0]
 80309b2:	071a      	lsls	r2, r3, #28
  tickstart = HAL_GetTick();
 80309b4:	4605      	mov	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 80309b6:	d418      	bmi.n	80309ea <UART_CheckIdleState+0x4a>
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 80309b8:	6823      	ldr	r3, [r4, #0]
 80309ba:	681b      	ldr	r3, [r3, #0]
 80309bc:	075b      	lsls	r3, r3, #29
 80309be:	d50a      	bpl.n	80309d6 <UART_CheckIdleState+0x36>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 80309c0:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 80309c4:	9300      	str	r3, [sp, #0]
 80309c6:	2200      	movs	r2, #0
 80309c8:	462b      	mov	r3, r5
 80309ca:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 80309ce:	4620      	mov	r0, r4
 80309d0:	f7ff ff84 	bl	80308dc <UART_WaitOnFlagUntilTimeout>
 80309d4:	b9a8      	cbnz	r0, 8030a02 <UART_CheckIdleState+0x62>
  huart->gState = HAL_UART_STATE_READY;
 80309d6:	2320      	movs	r3, #32
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80309d8:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
 80309da:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  __HAL_UNLOCK(huart);
 80309de:	f884 0080 	strb.w	r0, [r4, #128]	; 0x80
  huart->RxState = HAL_UART_STATE_READY;
 80309e2:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80309e6:	66e0      	str	r0, [r4, #108]	; 0x6c
  return HAL_OK;
 80309e8:	e00c      	b.n	8030a04 <UART_CheckIdleState+0x64>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 80309ea:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 80309ee:	9300      	str	r3, [sp, #0]
 80309f0:	4632      	mov	r2, r6
 80309f2:	4603      	mov	r3, r0
 80309f4:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 80309f8:	4620      	mov	r0, r4
 80309fa:	f7ff ff6f 	bl	80308dc <UART_WaitOnFlagUntilTimeout>
 80309fe:	2800      	cmp	r0, #0
 8030a00:	d0da      	beq.n	80309b8 <UART_CheckIdleState+0x18>
      return HAL_TIMEOUT;
 8030a02:	2003      	movs	r0, #3
}
 8030a04:	b002      	add	sp, #8
 8030a06:	bd70      	pop	{r4, r5, r6, pc}

08030a08 <HAL_UART_Init>:
{
 8030a08:	b510      	push	{r4, lr}
  if (huart == NULL)
 8030a0a:	4604      	mov	r4, r0
 8030a0c:	b350      	cbz	r0, 8030a64 <HAL_UART_Init+0x5c>
  if (huart->gState == HAL_UART_STATE_RESET)
 8030a0e:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
 8030a12:	b91b      	cbnz	r3, 8030a1c <HAL_UART_Init+0x14>
    huart->Lock = HAL_UNLOCKED;
 8030a14:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
    HAL_UART_MspInit(huart);
 8030a18:	f7fb ff6e 	bl	802c8f8 <HAL_UART_MspInit>
  __HAL_UART_DISABLE(huart);
 8030a1c:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 8030a1e:	2324      	movs	r3, #36	; 0x24
 8030a20:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  __HAL_UART_DISABLE(huart);
 8030a24:	6813      	ldr	r3, [r2, #0]
 8030a26:	f023 0301 	bic.w	r3, r3, #1
 8030a2a:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 8030a2c:	4620      	mov	r0, r4
 8030a2e:	f7ff fde7 	bl	8030600 <UART_SetConfig>
 8030a32:	2801      	cmp	r0, #1
 8030a34:	d016      	beq.n	8030a64 <HAL_UART_Init+0x5c>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 8030a36:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8030a38:	b113      	cbz	r3, 8030a40 <HAL_UART_Init+0x38>
    UART_AdvFeatureConfig(huart);
 8030a3a:	4620      	mov	r0, r4
 8030a3c:	f7ff fefa 	bl	8030834 <UART_AdvFeatureConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8030a40:	6823      	ldr	r3, [r4, #0]
 8030a42:	685a      	ldr	r2, [r3, #4]
 8030a44:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 8030a48:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8030a4a:	689a      	ldr	r2, [r3, #8]
 8030a4c:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 8030a50:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 8030a52:	681a      	ldr	r2, [r3, #0]
 8030a54:	f042 0201 	orr.w	r2, r2, #1
  return (UART_CheckIdleState(huart));
 8030a58:	4620      	mov	r0, r4
  __HAL_UART_ENABLE(huart);
 8030a5a:	601a      	str	r2, [r3, #0]
}
 8030a5c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return (UART_CheckIdleState(huart));
 8030a60:	f7ff bf9e 	b.w	80309a0 <UART_CheckIdleState>
}
 8030a64:	2001      	movs	r0, #1
 8030a66:	bd10      	pop	{r4, pc}

08030a68 <UART_Start_Receive_IT>:
  UART_MASK_COMPUTATION(huart);
 8030a68:	6883      	ldr	r3, [r0, #8]
{
 8030a6a:	b510      	push	{r4, lr}
  UART_MASK_COMPUTATION(huart);
 8030a6c:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
  huart->pRxBuffPtr  = pData;
 8030a70:	6581      	str	r1, [r0, #88]	; 0x58
  huart->RxISR       = NULL;
 8030a72:	f04f 0100 	mov.w	r1, #0
  huart->RxXferSize  = Size;
 8030a76:	f8a0 205c 	strh.w	r2, [r0, #92]	; 0x5c
  huart->RxXferCount = Size;
 8030a7a:	f8a0 205e 	strh.w	r2, [r0, #94]	; 0x5e
  huart->RxISR       = NULL;
 8030a7e:	6701      	str	r1, [r0, #112]	; 0x70
  UART_MASK_COMPUTATION(huart);
 8030a80:	d147      	bne.n	8030b12 <UART_Start_Receive_IT+0xaa>
 8030a82:	6903      	ldr	r3, [r0, #16]
 8030a84:	2b00      	cmp	r3, #0
 8030a86:	d142      	bne.n	8030b0e <UART_Start_Receive_IT+0xa6>
 8030a88:	f240 13ff 	movw	r3, #511	; 0x1ff
 8030a8c:	f8a0 3060 	strh.w	r3, [r0, #96]	; 0x60
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8030a90:	2300      	movs	r3, #0
 8030a92:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
  huart->RxState = HAL_UART_STATE_BUSY_RX;
 8030a96:	2322      	movs	r3, #34	; 0x22
 8030a98:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
  ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8030a9c:	6801      	ldr	r1, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030a9e:	f101 0308 	add.w	r3, r1, #8
 8030aa2:	e853 3f00 	ldrex	r3, [r3]
 8030aa6:	f043 0301 	orr.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030aaa:	3108      	adds	r1, #8
 8030aac:	e841 3400 	strex	r4, r3, [r1]
   return(result);
 8030ab0:	6803      	ldr	r3, [r0, #0]
 8030ab2:	2c00      	cmp	r4, #0
 8030ab4:	d1f2      	bne.n	8030a9c <UART_Start_Receive_IT+0x34>
  if ((huart->FifoMode == UART_FIFOMODE_ENABLE) && (Size >= huart->NbRxDataToProcess))
 8030ab6:	6e44      	ldr	r4, [r0, #100]	; 0x64
 8030ab8:	6881      	ldr	r1, [r0, #8]
 8030aba:	f1b4 5f00 	cmp.w	r4, #536870912	; 0x20000000
 8030abe:	d13b      	bne.n	8030b38 <UART_Start_Receive_IT+0xd0>
 8030ac0:	f8b0 4068 	ldrh.w	r4, [r0, #104]	; 0x68
 8030ac4:	4294      	cmp	r4, r2
 8030ac6:	d837      	bhi.n	8030b38 <UART_Start_Receive_IT+0xd0>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8030ac8:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 8030acc:	d132      	bne.n	8030b34 <UART_Start_Receive_IT+0xcc>
 8030ace:	6904      	ldr	r4, [r0, #16]
      huart->RxISR = UART_RxISR_16BIT_FIFOEN;
 8030ad0:	4a25      	ldr	r2, [pc, #148]	; (8030b68 <UART_Start_Receive_IT+0x100>)
 8030ad2:	4926      	ldr	r1, [pc, #152]	; (8030b6c <UART_Start_Receive_IT+0x104>)
 8030ad4:	2c00      	cmp	r4, #0
 8030ad6:	bf08      	it	eq
 8030ad8:	460a      	moveq	r2, r1
 8030ada:	6702      	str	r2, [r0, #112]	; 0x70
    __HAL_UNLOCK(huart);
 8030adc:	2200      	movs	r2, #0
 8030ade:	f880 2080 	strb.w	r2, [r0, #128]	; 0x80
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030ae2:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8030ae6:	f442 7280 	orr.w	r2, r2, #256	; 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030aea:	e843 2100 	strex	r1, r2, [r3]
 8030aee:	2900      	cmp	r1, #0
 8030af0:	d1f7      	bne.n	8030ae2 <UART_Start_Receive_IT+0x7a>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030af2:	f103 0208 	add.w	r2, r3, #8
 8030af6:	e852 2f00 	ldrex	r2, [r2]
    ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 8030afa:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030afe:	f103 0008 	add.w	r0, r3, #8
 8030b02:	e840 2100 	strex	r1, r2, [r0]
 8030b06:	2900      	cmp	r1, #0
 8030b08:	d1f3      	bne.n	8030af2 <UART_Start_Receive_IT+0x8a>
}
 8030b0a:	2000      	movs	r0, #0
 8030b0c:	bd10      	pop	{r4, pc}
  UART_MASK_COMPUTATION(huart);
 8030b0e:	23ff      	movs	r3, #255	; 0xff
 8030b10:	e7bc      	b.n	8030a8c <UART_Start_Receive_IT+0x24>
 8030b12:	b923      	cbnz	r3, 8030b1e <UART_Start_Receive_IT+0xb6>
 8030b14:	6903      	ldr	r3, [r0, #16]
 8030b16:	2b00      	cmp	r3, #0
 8030b18:	d0f9      	beq.n	8030b0e <UART_Start_Receive_IT+0xa6>
 8030b1a:	237f      	movs	r3, #127	; 0x7f
 8030b1c:	e7b6      	b.n	8030a8c <UART_Start_Receive_IT+0x24>
 8030b1e:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8030b22:	d104      	bne.n	8030b2e <UART_Start_Receive_IT+0xc6>
 8030b24:	6903      	ldr	r3, [r0, #16]
 8030b26:	2b00      	cmp	r3, #0
 8030b28:	d0f7      	beq.n	8030b1a <UART_Start_Receive_IT+0xb2>
 8030b2a:	233f      	movs	r3, #63	; 0x3f
 8030b2c:	e7ae      	b.n	8030a8c <UART_Start_Receive_IT+0x24>
 8030b2e:	f8a0 1060 	strh.w	r1, [r0, #96]	; 0x60
 8030b32:	e7ad      	b.n	8030a90 <UART_Start_Receive_IT+0x28>
      huart->RxISR = UART_RxISR_8BIT_FIFOEN;
 8030b34:	4a0c      	ldr	r2, [pc, #48]	; (8030b68 <UART_Start_Receive_IT+0x100>)
 8030b36:	e7d0      	b.n	8030ada <UART_Start_Receive_IT+0x72>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8030b38:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 8030b3c:	d112      	bne.n	8030b64 <UART_Start_Receive_IT+0xfc>
 8030b3e:	6904      	ldr	r4, [r0, #16]
      huart->RxISR = UART_RxISR_16BIT;
 8030b40:	4a0b      	ldr	r2, [pc, #44]	; (8030b70 <UART_Start_Receive_IT+0x108>)
 8030b42:	490c      	ldr	r1, [pc, #48]	; (8030b74 <UART_Start_Receive_IT+0x10c>)
 8030b44:	2c00      	cmp	r4, #0
 8030b46:	bf08      	it	eq
 8030b48:	460a      	moveq	r2, r1
 8030b4a:	6702      	str	r2, [r0, #112]	; 0x70
    __HAL_UNLOCK(huart);
 8030b4c:	2200      	movs	r2, #0
 8030b4e:	f880 2080 	strb.w	r2, [r0, #128]	; 0x80
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030b52:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE);
 8030b56:	f442 7290 	orr.w	r2, r2, #288	; 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030b5a:	e843 2100 	strex	r1, r2, [r3]
 8030b5e:	2900      	cmp	r1, #0
 8030b60:	d1f7      	bne.n	8030b52 <UART_Start_Receive_IT+0xea>
 8030b62:	e7d2      	b.n	8030b0a <UART_Start_Receive_IT+0xa2>
      huart->RxISR = UART_RxISR_8BIT;
 8030b64:	4a02      	ldr	r2, [pc, #8]	; (8030b70 <UART_Start_Receive_IT+0x108>)
 8030b66:	e7f0      	b.n	8030b4a <UART_Start_Receive_IT+0xe2>
 8030b68:	0803030d 	.word	0x0803030d
 8030b6c:	08030489 	.word	0x08030489
 8030b70:	080302c9 	.word	0x080302c9
 8030b74:	0803028d 	.word	0x0803028d

08030b78 <HAL_UART_Receive_IT>:
  if (huart->RxState == HAL_UART_STATE_READY)
 8030b78:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
 8030b7c:	2b20      	cmp	r3, #32
{
 8030b7e:	b430      	push	{r4, r5}
  if (huart->RxState == HAL_UART_STATE_READY)
 8030b80:	d11f      	bne.n	8030bc2 <HAL_UART_Receive_IT+0x4a>
    if ((pData == NULL) || (Size == 0U))
 8030b82:	b1d9      	cbz	r1, 8030bbc <HAL_UART_Receive_IT+0x44>
 8030b84:	b1d2      	cbz	r2, 8030bbc <HAL_UART_Receive_IT+0x44>
    __HAL_LOCK(huart);
 8030b86:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 8030b8a:	2b01      	cmp	r3, #1
 8030b8c:	d019      	beq.n	8030bc2 <HAL_UART_Receive_IT+0x4a>
 8030b8e:	2301      	movs	r3, #1
 8030b90:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8030b94:	2300      	movs	r3, #0
    if (!(IS_LPUART_INSTANCE(huart->Instance)))
 8030b96:	6804      	ldr	r4, [r0, #0]
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8030b98:	66c3      	str	r3, [r0, #108]	; 0x6c
    if (!(IS_LPUART_INSTANCE(huart->Instance)))
 8030b9a:	4b0b      	ldr	r3, [pc, #44]	; (8030bc8 <HAL_UART_Receive_IT+0x50>)
 8030b9c:	429c      	cmp	r4, r3
 8030b9e:	d00a      	beq.n	8030bb6 <HAL_UART_Receive_IT+0x3e>
      if(READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 8030ba0:	6863      	ldr	r3, [r4, #4]
 8030ba2:	021b      	lsls	r3, r3, #8
 8030ba4:	d507      	bpl.n	8030bb6 <HAL_UART_Receive_IT+0x3e>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030ba6:	e854 3f00 	ldrex	r3, [r4]
        ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 8030baa:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030bae:	e844 3500 	strex	r5, r3, [r4]
 8030bb2:	2d00      	cmp	r5, #0
 8030bb4:	d1f7      	bne.n	8030ba6 <HAL_UART_Receive_IT+0x2e>
}
 8030bb6:	bc30      	pop	{r4, r5}
    return(UART_Start_Receive_IT(huart, pData, Size));
 8030bb8:	f7ff bf56 	b.w	8030a68 <UART_Start_Receive_IT>
      return HAL_ERROR;
 8030bbc:	2001      	movs	r0, #1
}
 8030bbe:	bc30      	pop	{r4, r5}
 8030bc0:	4770      	bx	lr
    return HAL_BUSY;
 8030bc2:	2002      	movs	r0, #2
 8030bc4:	e7fb      	b.n	8030bbe <HAL_UART_Receive_IT+0x46>
 8030bc6:	bf00      	nop
 8030bc8:	40008000 	.word	0x40008000

08030bcc <UARTEx_SetNbDataToProcess>:
  uint8_t rx_fifo_threshold;
  uint8_t tx_fifo_threshold;
  static const uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
  static const uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};

  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 8030bcc:	6e43      	ldr	r3, [r0, #100]	; 0x64
{
 8030bce:	b510      	push	{r4, lr}
  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 8030bd0:	b91b      	cbnz	r3, 8030bda <UARTEx_SetNbDataToProcess+0xe>
  {
    huart->NbTxDataToProcess = 1U;
    huart->NbRxDataToProcess = 1U;
 8030bd2:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 8030bd6:	6683      	str	r3, [r0, #104]	; 0x68
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
                               (uint16_t)denominator[tx_fifo_threshold];
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
                               (uint16_t)denominator[rx_fifo_threshold];
  }
}
 8030bd8:	bd10      	pop	{r4, pc}
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
 8030bda:	6803      	ldr	r3, [r0, #0]
 8030bdc:	689c      	ldr	r4, [r3, #8]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 8030bde:	689a      	ldr	r2, [r3, #8]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8030be0:	4b0a      	ldr	r3, [pc, #40]	; (8030c0c <UARTEx_SetNbDataToProcess+0x40>)
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 8030be2:	0f52      	lsrs	r2, r2, #29
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8030be4:	5c99      	ldrb	r1, [r3, r2]
                               (uint16_t)denominator[tx_fifo_threshold];
 8030be6:	441a      	add	r2, r3
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8030be8:	00c9      	lsls	r1, r1, #3
                               (uint16_t)denominator[tx_fifo_threshold];
 8030bea:	7a12      	ldrb	r2, [r2, #8]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8030bec:	fbb1 f2f2 	udiv	r2, r1, r2
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8030bf0:	f3c4 6142 	ubfx	r1, r4, #25, #3
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8030bf4:	f8a0 206a 	strh.w	r2, [r0, #106]	; 0x6a
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8030bf8:	5c5a      	ldrb	r2, [r3, r1]
                               (uint16_t)denominator[rx_fifo_threshold];
 8030bfa:	440b      	add	r3, r1
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8030bfc:	00d2      	lsls	r2, r2, #3
                               (uint16_t)denominator[rx_fifo_threshold];
 8030bfe:	7a1b      	ldrb	r3, [r3, #8]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8030c00:	fbb2 f3f3 	udiv	r3, r2, r3
 8030c04:	f8a0 3068 	strh.w	r3, [r0, #104]	; 0x68
}
 8030c08:	e7e6      	b.n	8030bd8 <UARTEx_SetNbDataToProcess+0xc>
 8030c0a:	bf00      	nop
 8030c0c:	0803ba98 	.word	0x0803ba98

08030c10 <HAL_UARTEx_WakeupCallback>:
}
 8030c10:	4770      	bx	lr

08030c12 <HAL_UARTEx_RxFifoFullCallback>:
 8030c12:	4770      	bx	lr

08030c14 <HAL_UARTEx_TxFifoEmptyCallback>:
 8030c14:	4770      	bx	lr

08030c16 <HAL_UARTEx_StopModeWakeUpSourceConfig>:
{
 8030c16:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8030c18:	ab04      	add	r3, sp, #16
 8030c1a:	e903 0006 	stmdb	r3, {r1, r2}
  __HAL_LOCK(huart);
 8030c1e:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 8030c22:	9902      	ldr	r1, [sp, #8]
 8030c24:	2b01      	cmp	r3, #1
{
 8030c26:	4604      	mov	r4, r0
  __HAL_LOCK(huart);
 8030c28:	d03a      	beq.n	8030ca0 <HAL_UARTEx_StopModeWakeUpSourceConfig+0x8a>
 8030c2a:	2301      	movs	r3, #1
 8030c2c:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
  huart->gState = HAL_UART_STATE_BUSY;
 8030c30:	2324      	movs	r3, #36	; 0x24
 8030c32:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  __HAL_UART_DISABLE(huart);
 8030c36:	6803      	ldr	r3, [r0, #0]
 8030c38:	681a      	ldr	r2, [r3, #0]
 8030c3a:	f022 0201 	bic.w	r2, r2, #1
 8030c3e:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_WUS, WakeUpSelection.WakeUpEvent);
 8030c40:	689a      	ldr	r2, [r3, #8]
 8030c42:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8030c46:	430a      	orrs	r2, r1
 8030c48:	609a      	str	r2, [r3, #8]
  if (WakeUpSelection.WakeUpEvent == UART_WAKEUP_ON_ADDRESS)
 8030c4a:	b971      	cbnz	r1, 8030c6a <HAL_UARTEx_StopModeWakeUpSourceConfig+0x54>
  MODIFY_REG(huart->Instance->CR2, USART_CR2_ADDM7, WakeUpSelection.AddressLength);
 8030c4c:	6859      	ldr	r1, [r3, #4]
 8030c4e:	f8bd 200c 	ldrh.w	r2, [sp, #12]
    UARTEx_Wakeup_AddressConfig(huart, WakeUpSelection);
 8030c52:	f89d 000e 	ldrb.w	r0, [sp, #14]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_ADDM7, WakeUpSelection.AddressLength);
 8030c56:	f021 0110 	bic.w	r1, r1, #16
 8030c5a:	4311      	orrs	r1, r2
 8030c5c:	6059      	str	r1, [r3, #4]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, ((uint32_t)WakeUpSelection.Address << UART_CR2_ADDRESS_LSB_POS));
 8030c5e:	685a      	ldr	r2, [r3, #4]
 8030c60:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 8030c64:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
 8030c68:	605a      	str	r2, [r3, #4]
  __HAL_UART_ENABLE(huart);
 8030c6a:	681a      	ldr	r2, [r3, #0]
 8030c6c:	f042 0201 	orr.w	r2, r2, #1
 8030c70:	601a      	str	r2, [r3, #0]
  tickstart = HAL_GetTick();
 8030c72:	f7fb fce7 	bl	802c644 <HAL_GetTick>
  if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8030c76:	f06f 427e 	mvn.w	r2, #4261412864	; 0xfe000000
  tickstart = HAL_GetTick();
 8030c7a:	4603      	mov	r3, r0
  if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8030c7c:	9200      	str	r2, [sp, #0]
 8030c7e:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 8030c82:	2200      	movs	r2, #0
 8030c84:	4620      	mov	r0, r4
 8030c86:	f7ff fe29 	bl	80308dc <UART_WaitOnFlagUntilTimeout>
 8030c8a:	b938      	cbnz	r0, 8030c9c <HAL_UARTEx_StopModeWakeUpSourceConfig+0x86>
    huart->gState = HAL_UART_STATE_READY;
 8030c8c:	2320      	movs	r3, #32
 8030c8e:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  __HAL_UNLOCK(huart);
 8030c92:	2300      	movs	r3, #0
 8030c94:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
}
 8030c98:	b004      	add	sp, #16
 8030c9a:	bd10      	pop	{r4, pc}
    status = HAL_TIMEOUT;
 8030c9c:	2003      	movs	r0, #3
 8030c9e:	e7f8      	b.n	8030c92 <HAL_UARTEx_StopModeWakeUpSourceConfig+0x7c>
  __HAL_LOCK(huart);
 8030ca0:	2002      	movs	r0, #2
 8030ca2:	e7f9      	b.n	8030c98 <HAL_UARTEx_StopModeWakeUpSourceConfig+0x82>

08030ca4 <HAL_UARTEx_EnableStopMode>:
  __HAL_LOCK(huart);
 8030ca4:	f890 2080 	ldrb.w	r2, [r0, #128]	; 0x80
 8030ca8:	2a01      	cmp	r2, #1
{
 8030caa:	4603      	mov	r3, r0
  __HAL_LOCK(huart);
 8030cac:	d00e      	beq.n	8030ccc <HAL_UARTEx_EnableStopMode+0x28>
 8030cae:	2201      	movs	r2, #1
 8030cb0:	f880 2080 	strb.w	r2, [r0, #128]	; 0x80
  ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_UESM);
 8030cb4:	6819      	ldr	r1, [r3, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030cb6:	e851 2f00 	ldrex	r2, [r1]
 8030cba:	f042 0202 	orr.w	r2, r2, #2
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030cbe:	e841 2000 	strex	r0, r2, [r1]
 8030cc2:	2800      	cmp	r0, #0
 8030cc4:	d1f6      	bne.n	8030cb4 <HAL_UARTEx_EnableStopMode+0x10>
  __HAL_UNLOCK(huart);
 8030cc6:	f883 0080 	strb.w	r0, [r3, #128]	; 0x80
  return HAL_OK;
 8030cca:	4770      	bx	lr
  __HAL_LOCK(huart);
 8030ccc:	2002      	movs	r0, #2
}
 8030cce:	4770      	bx	lr

08030cd0 <HAL_UARTEx_EnableFifoMode>:
{
 8030cd0:	b510      	push	{r4, lr}
  __HAL_LOCK(huart);
 8030cd2:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 8030cd6:	2b01      	cmp	r3, #1
{
 8030cd8:	4604      	mov	r4, r0
  __HAL_LOCK(huart);
 8030cda:	d01a      	beq.n	8030d12 <HAL_UARTEx_EnableFifoMode+0x42>
 8030cdc:	2301      	movs	r3, #1
 8030cde:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
  huart->gState = HAL_UART_STATE_BUSY;
 8030ce2:	2324      	movs	r3, #36	; 0x24
 8030ce4:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8030ce8:	6803      	ldr	r3, [r0, #0]
 8030cea:	681a      	ldr	r2, [r3, #0]
  __HAL_UART_DISABLE(huart);
 8030cec:	6819      	ldr	r1, [r3, #0]
 8030cee:	f021 0101 	bic.w	r1, r1, #1
 8030cf2:	6019      	str	r1, [r3, #0]
  SET_BIT(tmpcr1, USART_CR1_FIFOEN);
 8030cf4:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
  huart->FifoMode = UART_FIFOMODE_ENABLE;
 8030cf8:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
 8030cfc:	6641      	str	r1, [r0, #100]	; 0x64
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8030cfe:	601a      	str	r2, [r3, #0]
  UARTEx_SetNbDataToProcess(huart);
 8030d00:	f7ff ff64 	bl	8030bcc <UARTEx_SetNbDataToProcess>
  huart->gState = HAL_UART_STATE_READY;
 8030d04:	2320      	movs	r3, #32
 8030d06:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  __HAL_UNLOCK(huart);
 8030d0a:	2000      	movs	r0, #0
 8030d0c:	f884 0080 	strb.w	r0, [r4, #128]	; 0x80
}
 8030d10:	bd10      	pop	{r4, pc}
  __HAL_LOCK(huart);
 8030d12:	2002      	movs	r0, #2
 8030d14:	e7fc      	b.n	8030d10 <HAL_UARTEx_EnableFifoMode+0x40>

08030d16 <HAL_UARTEx_SetTxFifoThreshold>:
{
 8030d16:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(huart);
 8030d18:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 8030d1c:	2b01      	cmp	r3, #1
{
 8030d1e:	4604      	mov	r4, r0
  __HAL_LOCK(huart);
 8030d20:	d01b      	beq.n	8030d5a <HAL_UARTEx_SetTxFifoThreshold+0x44>
 8030d22:	2301      	movs	r3, #1
 8030d24:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
  huart->gState = HAL_UART_STATE_BUSY;
 8030d28:	2324      	movs	r3, #36	; 0x24
 8030d2a:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8030d2e:	6803      	ldr	r3, [r0, #0]
 8030d30:	681d      	ldr	r5, [r3, #0]
  __HAL_UART_DISABLE(huart);
 8030d32:	681a      	ldr	r2, [r3, #0]
 8030d34:	f022 0201 	bic.w	r2, r2, #1
 8030d38:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
 8030d3a:	689a      	ldr	r2, [r3, #8]
 8030d3c:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
 8030d40:	4311      	orrs	r1, r2
 8030d42:	6099      	str	r1, [r3, #8]
  UARTEx_SetNbDataToProcess(huart);
 8030d44:	f7ff ff42 	bl	8030bcc <UARTEx_SetNbDataToProcess>
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8030d48:	6803      	ldr	r3, [r0, #0]
 8030d4a:	601d      	str	r5, [r3, #0]
  huart->gState = HAL_UART_STATE_READY;
 8030d4c:	2320      	movs	r3, #32
 8030d4e:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  __HAL_UNLOCK(huart);
 8030d52:	2000      	movs	r0, #0
 8030d54:	f884 0080 	strb.w	r0, [r4, #128]	; 0x80
}
 8030d58:	bd38      	pop	{r3, r4, r5, pc}
  __HAL_LOCK(huart);
 8030d5a:	2002      	movs	r0, #2
 8030d5c:	e7fc      	b.n	8030d58 <HAL_UARTEx_SetTxFifoThreshold+0x42>

08030d5e <HAL_UARTEx_SetRxFifoThreshold>:
{
 8030d5e:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(huart);
 8030d60:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 8030d64:	2b01      	cmp	r3, #1
{
 8030d66:	4604      	mov	r4, r0
  __HAL_LOCK(huart);
 8030d68:	d01b      	beq.n	8030da2 <HAL_UARTEx_SetRxFifoThreshold+0x44>
 8030d6a:	2301      	movs	r3, #1
 8030d6c:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
  huart->gState = HAL_UART_STATE_BUSY;
 8030d70:	2324      	movs	r3, #36	; 0x24
 8030d72:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8030d76:	6803      	ldr	r3, [r0, #0]
 8030d78:	681d      	ldr	r5, [r3, #0]
  __HAL_UART_DISABLE(huart);
 8030d7a:	681a      	ldr	r2, [r3, #0]
 8030d7c:	f022 0201 	bic.w	r2, r2, #1
 8030d80:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
 8030d82:	689a      	ldr	r2, [r3, #8]
 8030d84:	f022 6260 	bic.w	r2, r2, #234881024	; 0xe000000
 8030d88:	4311      	orrs	r1, r2
 8030d8a:	6099      	str	r1, [r3, #8]
  UARTEx_SetNbDataToProcess(huart);
 8030d8c:	f7ff ff1e 	bl	8030bcc <UARTEx_SetNbDataToProcess>
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8030d90:	6803      	ldr	r3, [r0, #0]
 8030d92:	601d      	str	r5, [r3, #0]
  huart->gState = HAL_UART_STATE_READY;
 8030d94:	2320      	movs	r3, #32
 8030d96:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  __HAL_UNLOCK(huart);
 8030d9a:	2000      	movs	r0, #0
 8030d9c:	f884 0080 	strb.w	r0, [r4, #128]	; 0x80
}
 8030da0:	bd38      	pop	{r3, r4, r5, pc}
  __HAL_LOCK(huart);
 8030da2:	2002      	movs	r0, #2
 8030da4:	e7fc      	b.n	8030da0 <HAL_UARTEx_SetRxFifoThreshold+0x42>
	...

08030da8 <SetRow>:
 * Fragmentation decoder algorithm utilities
 *=============================================================================
 */

static void SetRow( uint8_t *src, uint16_t row, uint16_t size )
{
 8030da8:	460b      	mov	r3, r1
    if( ( FragDecoder.Callbacks != NULL ) && ( FragDecoder.Callbacks->FragDecoderWrite != NULL ) )
 8030daa:	4907      	ldr	r1, [pc, #28]	; (8030dc8 <SetRow+0x20>)
 8030dac:	6809      	ldr	r1, [r1, #0]
{
 8030dae:	b430      	push	{r4, r5}
    if( ( FragDecoder.Callbacks != NULL ) && ( FragDecoder.Callbacks->FragDecoderWrite != NULL ) )
 8030db0:	b139      	cbz	r1, 8030dc2 <SetRow+0x1a>
 8030db2:	684d      	ldr	r5, [r1, #4]
 8030db4:	b12d      	cbz	r5, 8030dc2 <SetRow+0x1a>
    {
        FragDecoder.Callbacks->FragDecoderWrite( row * size, src, size );
 8030db6:	4601      	mov	r1, r0
 8030db8:	fb02 f003 	mul.w	r0, r2, r3
 8030dbc:	462b      	mov	r3, r5
    }
}
 8030dbe:	bc30      	pop	{r4, r5}
        FragDecoder.Callbacks->FragDecoderWrite( row * size, src, size );
 8030dc0:	4718      	bx	r3
}
 8030dc2:	bc30      	pop	{r4, r5}
 8030dc4:	4770      	bx	lr
 8030dc6:	bf00      	nop
 8030dc8:	20003f54 	.word	0x20003f54

08030dcc <GetRow>:

static void GetRow( uint8_t *dst, uint16_t row, uint16_t size )
{
 8030dcc:	460b      	mov	r3, r1
    if( ( FragDecoder.Callbacks != NULL ) && ( FragDecoder.Callbacks->FragDecoderRead != NULL ) )
 8030dce:	4907      	ldr	r1, [pc, #28]	; (8030dec <GetRow+0x20>)
 8030dd0:	6809      	ldr	r1, [r1, #0]
{
 8030dd2:	b430      	push	{r4, r5}
    if( ( FragDecoder.Callbacks != NULL ) && ( FragDecoder.Callbacks->FragDecoderRead != NULL ) )
 8030dd4:	b139      	cbz	r1, 8030de6 <GetRow+0x1a>
 8030dd6:	688d      	ldr	r5, [r1, #8]
 8030dd8:	b12d      	cbz	r5, 8030de6 <GetRow+0x1a>
    {
        FragDecoder.Callbacks->FragDecoderRead( row * size, dst, size );
 8030dda:	4601      	mov	r1, r0
 8030ddc:	fb02 f003 	mul.w	r0, r2, r3
 8030de0:	462b      	mov	r3, r5
    }
}
 8030de2:	bc30      	pop	{r4, r5}
        FragDecoder.Callbacks->FragDecoderRead( row * size, dst, size );
 8030de4:	4718      	bx	r3
}
 8030de6:	bc30      	pop	{r4, r5}
 8030de8:	4770      	bx	lr
 8030dea:	bf00      	nop
 8030dec:	20003f54 	.word	0x20003f54

08030df0 <GetParity>:

static uint8_t GetParity( uint16_t index, uint8_t *matrixRow  )
{
    uint8_t parity;
    parity = matrixRow[index >> 3];
 8030df0:	08c3      	lsrs	r3, r0, #3
    parity = ( parity >> ( 7 - ( index % 8 ) ) ) & 0x01;
 8030df2:	43c0      	mvns	r0, r0
 8030df4:	5ccb      	ldrb	r3, [r1, r3]
 8030df6:	f000 0007 	and.w	r0, r0, #7
 8030dfa:	fa43 f000 	asr.w	r0, r3, r0
    return parity;
}
 8030dfe:	f000 0001 	and.w	r0, r0, #1
 8030e02:	4770      	bx	lr

08030e04 <SetParity>:

static void SetParity( uint16_t index, uint8_t *matrixRow, uint8_t parity )
{
    uint8_t mask = 0xFF - ( 1 << ( 7 - ( index % 8 ) ) );
 8030e04:	43c3      	mvns	r3, r0
 8030e06:	f003 0307 	and.w	r3, r3, #7
    parity = parity << ( 7 - ( index % 8 ) );
    matrixRow[index >> 3] = ( matrixRow[index >> 3] & mask ) + parity;
 8030e0a:	08c0      	lsrs	r0, r0, #3
{
 8030e0c:	b510      	push	{r4, lr}
    parity = parity << ( 7 - ( index % 8 ) );
 8030e0e:	fa02 f403 	lsl.w	r4, r2, r3
    uint8_t mask = 0xFF - ( 1 << ( 7 - ( index % 8 ) ) );
 8030e12:	2201      	movs	r2, #1
 8030e14:	fa02 f303 	lsl.w	r3, r2, r3
    matrixRow[index >> 3] = ( matrixRow[index >> 3] & mask ) + parity;
 8030e18:	5c0a      	ldrb	r2, [r1, r0]
 8030e1a:	ea22 0203 	bic.w	r2, r2, r3
 8030e1e:	4422      	add	r2, r4
 8030e20:	540a      	strb	r2, [r1, r0]
}
 8030e22:	bd10      	pop	{r4, pc}

08030e24 <XorDataLine>:
    }
    return false;
}

static void XorDataLine( uint8_t *line1, uint8_t *line2, int32_t size )
{
 8030e24:	b530      	push	{r4, r5, lr}
 8030e26:	3801      	subs	r0, #1
    for( int32_t i = 0; i < size; i++ )
 8030e28:	2300      	movs	r3, #0
 8030e2a:	4293      	cmp	r3, r2
 8030e2c:	d100      	bne.n	8030e30 <XorDataLine+0xc>
    {
        line1[i] = line1[i] ^ line2[i];
    }
}
 8030e2e:	bd30      	pop	{r4, r5, pc}
        line1[i] = line1[i] ^ line2[i];
 8030e30:	5ccd      	ldrb	r5, [r1, r3]
 8030e32:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 8030e36:	406c      	eors	r4, r5
 8030e38:	7004      	strb	r4, [r0, #0]
    for( int32_t i = 0; i < size; i++ )
 8030e3a:	3301      	adds	r3, #1
 8030e3c:	e7f5      	b.n	8030e2a <XorDataLine+0x6>

08030e3e <XorParityLine>:

static void XorParityLine( uint8_t* line1, uint8_t* line2, int32_t size )
{
 8030e3e:	e92d 41d8 	stmdb	sp!, {r3, r4, r6, r7, r8, lr}
 8030e42:	4606      	mov	r6, r0
 8030e44:	4688      	mov	r8, r1
 8030e46:	b297      	uxth	r7, r2
    for( int32_t i = 0; i < size; i++ )
 8030e48:	2400      	movs	r4, #0
 8030e4a:	42bc      	cmp	r4, r7
 8030e4c:	d101      	bne.n	8030e52 <XorParityLine+0x14>
    {
        SetParity( i, line1, ( GetParity( i, line1 ) ^ GetParity( i, line2 ) ) );
    }
}
 8030e4e:	e8bd 81d8 	ldmia.w	sp!, {r3, r4, r6, r7, r8, pc}
        SetParity( i, line1, ( GetParity( i, line1 ) ^ GetParity( i, line2 ) ) );
 8030e52:	4631      	mov	r1, r6
 8030e54:	4620      	mov	r0, r4
 8030e56:	f7ff ffcb 	bl	8030df0 <GetParity>
 8030e5a:	4641      	mov	r1, r8
 8030e5c:	4602      	mov	r2, r0
 8030e5e:	4620      	mov	r0, r4
 8030e60:	f7ff ffc6 	bl	8030df0 <GetParity>
 8030e64:	4042      	eors	r2, r0
 8030e66:	b2d2      	uxtb	r2, r2
 8030e68:	4620      	mov	r0, r4
 8030e6a:	4631      	mov	r1, r6
 8030e6c:	3401      	adds	r4, #1
 8030e6e:	f7ff ffc9 	bl	8030e04 <SetParity>
    for( int32_t i = 0; i < size; i++ )
 8030e72:	b2a4      	uxth	r4, r4
 8030e74:	e7e9      	b.n	8030e4a <XorParityLine+0xc>
	...

08030e78 <FragFindMissingFrags>:
 * \param [OUT] FragDecoder.FragNbMissingIndex[] array is updated in place
 */
static void FragFindMissingFrags( uint16_t counter )
{
    int32_t i;
    for( i = FragDecoder.Status.FragNbLastRx; i < ( counter - 1 ); i++ )
 8030e78:	4b13      	ldr	r3, [pc, #76]	; (8030ec8 <FragFindMissingFrags+0x50>)
{
 8030e7a:	b5f0      	push	{r4, r5, r6, r7, lr}
    for( i = FragDecoder.Status.FragNbLastRx; i < ( counter - 1 ); i++ )
 8030e7c:	f8b3 6882 	ldrh.w	r6, [r3, #2178]	; 0x882
    {
        if( i < FragDecoder.FragNb )
 8030e80:	889c      	ldrh	r4, [r3, #4]
 8030e82:	f8b3 1880 	ldrh.w	r1, [r3, #2176]	; 0x880
    for( i = FragDecoder.Status.FragNbLastRx; i < ( counter - 1 ); i++ )
 8030e86:	4635      	mov	r5, r6
 8030e88:	2700      	movs	r7, #0
 8030e8a:	1e42      	subs	r2, r0, #1
 8030e8c:	42aa      	cmp	r2, r5
 8030e8e:	dc0f      	bgt.n	8030eb0 <FragFindMissingFrags+0x38>
 8030e90:	43f2      	mvns	r2, r6
 8030e92:	4402      	add	r2, r0
 8030e94:	4286      	cmp	r6, r0
 8030e96:	bf28      	it	cs
 8030e98:	2200      	movcs	r2, #0
 8030e9a:	4432      	add	r2, r6
 8030e9c:	b10f      	cbz	r7, 8030ea2 <FragFindMissingFrags+0x2a>
 8030e9e:	f8a3 1880 	strh.w	r1, [r3, #2176]	; 0x880
        {
            FragDecoder.Status.FragNbLost++;
            FragDecoder.FragNbMissingIndex[i] = FragDecoder.Status.FragNbLost;
        }
    }
    if( i < FragDecoder.FragNb )
 8030ea2:	4294      	cmp	r4, r2
    {
        FragDecoder.Status.FragNbLastRx = counter;
    }
    else
    {
        FragDecoder.Status.FragNbLastRx = FragDecoder.FragNb + 1;
 8030ea4:	bfdc      	itt	le
 8030ea6:	1c60      	addle	r0, r4, #1
 8030ea8:	b280      	uxthle	r0, r0
 8030eaa:	f8a3 0882 	strh.w	r0, [r3, #2178]	; 0x882
    }
}
 8030eae:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if( i < FragDecoder.FragNb )
 8030eb0:	42ac      	cmp	r4, r5
 8030eb2:	dd06      	ble.n	8030ec2 <FragFindMissingFrags+0x4a>
            FragDecoder.FragNbMissingIndex[i] = FragDecoder.Status.FragNbLost;
 8030eb4:	eb03 0745 	add.w	r7, r3, r5, lsl #1
            FragDecoder.Status.FragNbLost++;
 8030eb8:	3101      	adds	r1, #1
 8030eba:	b289      	uxth	r1, r1
            FragDecoder.FragNbMissingIndex[i] = FragDecoder.Status.FragNbLost;
 8030ebc:	f8a7 12dc 	strh.w	r1, [r7, #732]	; 0x2dc
 8030ec0:	2701      	movs	r7, #1
    for( i = FragDecoder.Status.FragNbLastRx; i < ( counter - 1 ); i++ )
 8030ec2:	3501      	adds	r5, #1
 8030ec4:	e7e2      	b.n	8030e8c <FragFindMissingFrags+0x14>
 8030ec6:	bf00      	nop
 8030ec8:	20003f54 	.word	0x20003f54

08030ecc <FragFindMissingIndex>:
 *
 * \retval counter The counter value associated to the x th missing frag
 */
static uint16_t FragFindMissingIndex( uint16_t x )
{
    for( uint16_t i = 0; i < FragDecoder.FragNb; i++ )
 8030ecc:	4b09      	ldr	r3, [pc, #36]	; (8030ef4 <FragFindMissingIndex+0x28>)
{
 8030ece:	b530      	push	{r4, r5, lr}
    for( uint16_t i = 0; i < FragDecoder.FragNb; i++ )
 8030ed0:	2200      	movs	r2, #0
 8030ed2:	889c      	ldrh	r4, [r3, #4]
    {
        if( FragDecoder.FragNbMissingIndex[i] == ( x + 1 ) )
 8030ed4:	1c41      	adds	r1, r0, #1
 8030ed6:	f503 7337 	add.w	r3, r3, #732	; 0x2dc
 8030eda:	b290      	uxth	r0, r2
    for( uint16_t i = 0; i < FragDecoder.FragNb; i++ )
 8030edc:	4284      	cmp	r4, r0
 8030ede:	d801      	bhi.n	8030ee4 <FragFindMissingIndex+0x18>
        {
            return i;
        }
    }
    return 0;
 8030ee0:	2000      	movs	r0, #0
 8030ee2:	e005      	b.n	8030ef0 <FragFindMissingIndex+0x24>
        if( FragDecoder.FragNbMissingIndex[i] == ( x + 1 ) )
 8030ee4:	f833 5b02 	ldrh.w	r5, [r3], #2
 8030ee8:	428d      	cmp	r5, r1
 8030eea:	f102 0201 	add.w	r2, r2, #1
 8030eee:	d1f4      	bne.n	8030eda <FragFindMissingIndex+0xe>
}
 8030ef0:	bd30      	pop	{r4, r5, pc}
 8030ef2:	bf00      	nop
 8030ef4:	20003f54 	.word	0x20003f54

08030ef8 <FragExtractLineFromBinaryMatrix>:
 * \param [IN] bitArray  Pointer to the bit array
 * \param [IN] rowIndex  Matrix row index
 * \param [IN] bitsInRow Number of bits in one row
 */
static void FragExtractLineFromBinaryMatrix( uint8_t* bitArray, uint16_t rowIndex, uint16_t bitsInRow )
{
 8030ef8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8030efc:	4680      	mov	r8, r0
 8030efe:	4616      	mov	r6, r2
    uint32_t findByte = 0;
    uint32_t findBitInByte = 0;

    if( rowIndex > 0 )
 8030f00:	460d      	mov	r5, r1
 8030f02:	b309      	cbz	r1, 8030f48 <FragExtractLineFromBinaryMatrix+0x50>
    {
        findByte      = ( rowIndex * bitsInRow - ( ( rowIndex * ( rowIndex - 1 ) ) >> 1 ) ) >> 3;
 8030f04:	1e4b      	subs	r3, r1, #1
 8030f06:	434b      	muls	r3, r1
 8030f08:	fb01 f402 	mul.w	r4, r1, r2
 8030f0c:	eba4 0463 	sub.w	r4, r4, r3, asr #1
        findBitInByte = ( rowIndex * bitsInRow - ( ( rowIndex * ( rowIndex - 1 ) ) >> 1 ) ) % 8;
 8030f10:	4263      	negs	r3, r4
 8030f12:	f003 0307 	and.w	r3, r3, #7
        findByte      = ( rowIndex * bitsInRow - ( ( rowIndex * ( rowIndex - 1 ) ) >> 1 ) ) >> 3;
 8030f16:	ea4f 07e4 	mov.w	r7, r4, asr #3
        findBitInByte = ( rowIndex * bitsInRow - ( ( rowIndex * ( rowIndex - 1 ) ) >> 1 ) ) % 8;
 8030f1a:	f04f 0900 	mov.w	r9, #0
 8030f1e:	f004 0407 	and.w	r4, r4, #7
 8030f22:	bf58      	it	pl
 8030f24:	425c      	negpl	r4, r3
    }
    if( rowIndex > 0 )
    {
        for( uint16_t i = 0; i < rowIndex; i++ )
 8030f26:	45a9      	cmp	r9, r5
 8030f28:	fa1f f089 	uxth.w	r0, r9
 8030f2c:	d105      	bne.n	8030f3a <FragExtractLineFromBinaryMatrix+0x42>
    }
    for( uint16_t i = rowIndex; i < bitsInRow; i++ )
    {
        SetParity( i,
                   bitArray, 
                   ( FragDecoder.MatrixM2B[findByte] >> ( 7 - findBitInByte ) ) & 0x01 );
 8030f2e:	f8df 9048 	ldr.w	r9, [pc, #72]	; 8030f78 <FragExtractLineFromBinaryMatrix+0x80>
    for( uint16_t i = rowIndex; i < bitsInRow; i++ )
 8030f32:	42b5      	cmp	r5, r6
 8030f34:	d30b      	bcc.n	8030f4e <FragExtractLineFromBinaryMatrix+0x56>
        {
            findBitInByte = 0;
            findByte++;
        }
    }
}
 8030f36:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            SetParity( i, bitArray, 0 );
 8030f3a:	2200      	movs	r2, #0
 8030f3c:	4641      	mov	r1, r8
 8030f3e:	f7ff ff61 	bl	8030e04 <SetParity>
        for( uint16_t i = 0; i < rowIndex; i++ )
 8030f42:	f109 0901 	add.w	r9, r9, #1
 8030f46:	e7ee      	b.n	8030f26 <FragExtractLineFromBinaryMatrix+0x2e>
    uint32_t findBitInByte = 0;
 8030f48:	460c      	mov	r4, r1
    uint32_t findByte = 0;
 8030f4a:	460f      	mov	r7, r1
 8030f4c:	e7ef      	b.n	8030f2e <FragExtractLineFromBinaryMatrix+0x36>
                   ( FragDecoder.MatrixM2B[findByte] >> ( 7 - findBitInByte ) ) & 0x01 );
 8030f4e:	eb09 0307 	add.w	r3, r9, r7
        SetParity( i,
 8030f52:	4628      	mov	r0, r5
                   ( FragDecoder.MatrixM2B[findByte] >> ( 7 - findBitInByte ) ) & 0x01 );
 8030f54:	7b1a      	ldrb	r2, [r3, #12]
 8030f56:	f1c4 0307 	rsb	r3, r4, #7
 8030f5a:	411a      	asrs	r2, r3
        findBitInByte++;
 8030f5c:	3401      	adds	r4, #1
        SetParity( i,
 8030f5e:	f002 0201 	and.w	r2, r2, #1
 8030f62:	4641      	mov	r1, r8
 8030f64:	f7ff ff4e 	bl	8030e04 <SetParity>
    for( uint16_t i = rowIndex; i < bitsInRow; i++ )
 8030f68:	3501      	adds	r5, #1
        if( findBitInByte == 8 )
 8030f6a:	2c08      	cmp	r4, #8
            findByte++;
 8030f6c:	bf04      	itt	eq
 8030f6e:	3701      	addeq	r7, #1
            findBitInByte = 0;
 8030f70:	2400      	moveq	r4, #0
    for( uint16_t i = rowIndex; i < bitsInRow; i++ )
 8030f72:	b2ad      	uxth	r5, r5
 8030f74:	e7dd      	b.n	8030f32 <FragExtractLineFromBinaryMatrix+0x3a>
 8030f76:	bf00      	nop
 8030f78:	20003f54 	.word	0x20003f54

08030f7c <FragDecoderInit>:
{
 8030f7c:	b510      	push	{r4, lr}
    FragDecoder.Callbacks = callbacks;
 8030f7e:	4c15      	ldr	r4, [pc, #84]	; (8030fd4 <FragDecoderInit+0x58>)
    FragDecoder.Status.FragNbLost = 0;
 8030f80:	2300      	movs	r3, #0
    FragDecoder.FragNb = fragNb;                                // FragNb = FRAG_MAX_SIZE
 8030f82:	80a0      	strh	r0, [r4, #4]
    FragDecoder.FragSize = fragSize;                            // number of byte on a row
 8030f84:	71a1      	strb	r1, [r4, #6]
    FragDecoder.Status.FragNbLost = 0;
 8030f86:	f8c4 3880 	str.w	r3, [r4, #2176]	; 0x880
    FragDecoder.M2BLine = 0;
 8030f8a:	60a3      	str	r3, [r4, #8]
    FragDecoder.Callbacks = callbacks;
 8030f8c:	6022      	str	r2, [r4, #0]
    for( uint16_t i = 0; i < FRAG_MAX_NB; i++ )
 8030f8e:	f504 7137 	add.w	r1, r4, #732	; 0x2dc
    FragDecoder.M2BLine = 0;
 8030f92:	f44f 7333 	mov.w	r3, #716	; 0x2cc
        FragDecoder.FragNbMissingIndex[i] = 1;
 8030f96:	2001      	movs	r0, #1
 8030f98:	3b01      	subs	r3, #1
 8030f9a:	b29b      	uxth	r3, r3
 8030f9c:	f821 0b02 	strh.w	r0, [r1], #2
    for( uint16_t i = 0; i < FRAG_MAX_NB; i++ )
 8030fa0:	2b00      	cmp	r3, #0
 8030fa2:	d1f9      	bne.n	8030f98 <FragDecoderInit+0x1c>
 8030fa4:	490c      	ldr	r1, [pc, #48]	; (8030fd8 <FragDecoderInit+0x5c>)
        FragDecoder.S[i] = 0;
 8030fa6:	4618      	mov	r0, r3
    for( uint32_t i = 0; i < ( ( FRAG_MAX_REDUNDANCY >> 3 ) + 1 ); i++ )
 8030fa8:	3301      	adds	r3, #1
 8030faa:	2b0a      	cmp	r3, #10
        FragDecoder.S[i] = 0;
 8030fac:	f801 0b01 	strb.w	r0, [r1], #1
    for( uint32_t i = 0; i < ( ( FRAG_MAX_REDUNDANCY >> 3 ) + 1 ); i++ )
 8030fb0:	d1fa      	bne.n	8030fa8 <FragDecoderInit+0x2c>
 8030fb2:	490a      	ldr	r1, [pc, #40]	; (8030fdc <FragDecoderInit+0x60>)
    for( uint32_t i = 0; i < ( ( ( FRAG_MAX_REDUNDANCY >> 3 ) + 1 ) * FRAG_MAX_REDUNDANCY ); i++ )
 8030fb4:	2300      	movs	r3, #0
       FragDecoder.MatrixM2B[i] = 0xFF;
 8030fb6:	20ff      	movs	r0, #255	; 0xff
    for( uint32_t i = 0; i < ( ( ( FRAG_MAX_REDUNDANCY >> 3 ) + 1 ) * FRAG_MAX_REDUNDANCY ); i++ )
 8030fb8:	3301      	adds	r3, #1
 8030fba:	f5b3 7f34 	cmp.w	r3, #720	; 0x2d0
       FragDecoder.MatrixM2B[i] = 0xFF;
 8030fbe:	f801 0b01 	strb.w	r0, [r1], #1
    for( uint32_t i = 0; i < ( ( ( FRAG_MAX_REDUNDANCY >> 3 ) + 1 ) * FRAG_MAX_REDUNDANCY ); i++ )
 8030fc2:	d1f9      	bne.n	8030fb8 <FragDecoderInit+0x3c>
    if (FragDecoder.Callbacks->FragDecoderErase != NULL)
 8030fc4:	6813      	ldr	r3, [r2, #0]
 8030fc6:	b103      	cbz	r3, 8030fca <FragDecoderInit+0x4e>
        FragDecoder.Callbacks->FragDecoderErase();
 8030fc8:	4798      	blx	r3
    FragDecoder.Status.FragNbLost = 0;
 8030fca:	2300      	movs	r3, #0
 8030fcc:	f8c4 3880 	str.w	r3, [r4, #2176]	; 0x880
}
 8030fd0:	bd10      	pop	{r4, pc}
 8030fd2:	bf00      	nop
 8030fd4:	20003f54 	.word	0x20003f54
 8030fd8:	200047c8 	.word	0x200047c8
 8030fdc:	20003f60 	.word	0x20003f60

08030fe0 <FragDecoderGetMaxFileSize>:
}
 8030fe0:	4800      	ldr	r0, [pc, #0]	; (8030fe4 <FragDecoderGetMaxFileSize+0x4>)
 8030fe2:	4770      	bx	lr
 8030fe4:	00014fa0 	.word	0x00014fa0

08030fe8 <FragDecoderProcess>:
{
 8030fe8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8030fec:	b0bd      	sub	sp, #244	; 0xf4
 8030fee:	4604      	mov	r4, r0
    UTIL_MEM_set_8(matrixRow, 0, (FRAG_MAX_NB >> 3) + 1);
 8030ff0:	225a      	movs	r2, #90	; 0x5a
 8030ff2:	a807      	add	r0, sp, #28
{
 8030ff4:	460f      	mov	r7, r1
    UTIL_MEM_set_8(matrixRow, 0, (FRAG_MAX_NB >> 3) + 1);
 8030ff6:	2100      	movs	r1, #0
 8030ff8:	f009 ff90 	bl	803af1c <UTIL_MEM_set_8>
    UTIL_MEM_set_8(matrixDataTemp, 0, FRAG_MAX_SIZE);
 8030ffc:	2278      	movs	r2, #120	; 0x78
 8030ffe:	eb0d 0002 	add.w	r0, sp, r2
 8031002:	2100      	movs	r1, #0
 8031004:	f009 ff8a 	bl	803af1c <UTIL_MEM_set_8>
    FragDecoder.Status.FragNbRx = fragCounter;
 8031008:	4eba      	ldr	r6, [pc, #744]	; (80312f4 <FragDecoderProcess+0x30c>)
    UTIL_MEM_set_8(dataTempVector, 0, (FRAG_MAX_REDUNDANCY >> 3) + 1);
 803100a:	220a      	movs	r2, #10
 803100c:	2100      	movs	r1, #0
 803100e:	a801      	add	r0, sp, #4
 8031010:	f009 ff84 	bl	803af1c <UTIL_MEM_set_8>
    UTIL_MEM_set_8(dataTempVector2, 0, (FRAG_MAX_REDUNDANCY >> 3) + 1);
 8031014:	220a      	movs	r2, #10
 8031016:	2100      	movs	r1, #0
 8031018:	a804      	add	r0, sp, #16
 803101a:	f009 ff7f 	bl	803af1c <UTIL_MEM_set_8>
    if( fragCounter < FragDecoder.Status.FragNbLastRx )
 803101e:	f8b6 3882 	ldrh.w	r3, [r6, #2178]	; 0x882
    FragDecoder.Status.FragNbRx = fragCounter;
 8031022:	f8a6 487e 	strh.w	r4, [r6, #2174]	; 0x87e
    if( fragCounter < FragDecoder.Status.FragNbLastRx )
 8031026:	42a3      	cmp	r3, r4
 8031028:	4635      	mov	r5, r6
 803102a:	d904      	bls.n	8031036 <FragDecoderProcess+0x4e>
        return FRAG_SESSION_ONGOING;  // Drop frame out of order
 803102c:	f04f 30ff 	mov.w	r0, #4294967295
}
 8031030:	b03d      	add	sp, #244	; 0xf4
 8031032:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( fragCounter < ( FragDecoder.FragNb + 1 ) )
 8031036:	88b3      	ldrh	r3, [r6, #4]
 8031038:	42a3      	cmp	r3, r4
 803103a:	d318      	bcc.n	803106e <FragDecoderProcess+0x86>
        SetRow( rawData, fragCounter - 1, FragDecoder.FragSize );
 803103c:	1e61      	subs	r1, r4, #1
 803103e:	79b2      	ldrb	r2, [r6, #6]
 8031040:	b289      	uxth	r1, r1
 8031042:	4638      	mov	r0, r7
 8031044:	f7ff feb0 	bl	8030da8 <SetRow>
        FragDecoder.FragNbMissingIndex[fragCounter - 1] = 0;
 8031048:	f204 136b 	addw	r3, r4, #363	; 0x16b
 803104c:	eb06 0343 	add.w	r3, r6, r3, lsl #1
 8031050:	2200      	movs	r2, #0
        FragFindMissingFrags( fragCounter );
 8031052:	4620      	mov	r0, r4
        FragDecoder.FragNbMissingIndex[fragCounter - 1] = 0;
 8031054:	809a      	strh	r2, [r3, #4]
        FragFindMissingFrags( fragCounter );
 8031056:	f7ff ff0f 	bl	8030e78 <FragFindMissingFrags>
        if ((fragCounter == FragDecoder.FragNb) && (FragDecoder.Status.FragNbLost == 0U))
 803105a:	88b3      	ldrh	r3, [r6, #4]
 803105c:	42a3      	cmp	r3, r4
 803105e:	d1e5      	bne.n	803102c <FragDecoderProcess+0x44>
 8031060:	f8b6 0880 	ldrh.w	r0, [r6, #2176]	; 0x880
 8031064:	3800      	subs	r0, #0
 8031066:	bf18      	it	ne
 8031068:	2001      	movne	r0, #1
 803106a:	4240      	negs	r0, r0
 803106c:	e7e0      	b.n	8031030 <FragDecoderProcess+0x48>
        if( FragDecoder.Status.FragNbLost > FRAG_MAX_REDUNDANCY )
 803106e:	f8b6 3880 	ldrh.w	r3, [r6, #2176]	; 0x880
 8031072:	2b48      	cmp	r3, #72	; 0x48
 8031074:	d904      	bls.n	8031080 <FragDecoderProcess+0x98>
           FragDecoder.Status.MatrixError = 1;
 8031076:	2301      	movs	r3, #1
 8031078:	f886 3884 	strb.w	r3, [r6, #2180]	; 0x884
           return FRAG_SESSION_FINISHED;
 803107c:	2000      	movs	r0, #0
 803107e:	e7d7      	b.n	8031030 <FragDecoderProcess+0x48>
        FragFindMissingFrags( fragCounter );
 8031080:	4620      	mov	r0, r4
 8031082:	f7ff fef9 	bl	8030e78 <FragFindMissingFrags>
        if( FragDecoder.Status.FragNbLost == 0 )
 8031086:	f8b6 0880 	ldrh.w	r0, [r6, #2176]	; 0x880
 803108a:	2800      	cmp	r0, #0
 803108c:	d0d0      	beq.n	8031030 <FragDecoderProcess+0x48>
        FragGetParityMatrixRow( fragCounter - FragDecoder.FragNb, FragDecoder.FragNb, matrixRow );
 803108e:	f8b6 9004 	ldrh.w	r9, [r6, #4]
    if( IsPowerOfTwo( m ) != false )
 8031092:	2300      	movs	r3, #0
        FragGetParityMatrixRow( fragCounter - FragDecoder.FragNb, FragDecoder.FragNb, matrixRow );
 8031094:	eba4 0409 	sub.w	r4, r4, r9
    uint8_t sumBit = 0;
 8031098:	461e      	mov	r6, r3
        sumBit += ( x & ( 1 << i ) ) >> i;
 803109a:	2101      	movs	r1, #1
 803109c:	fa01 f203 	lsl.w	r2, r1, r3
 80310a0:	ea02 0209 	and.w	r2, r2, r9
 80310a4:	40da      	lsrs	r2, r3
 80310a6:	3301      	adds	r3, #1
 80310a8:	4416      	add	r6, r2
    for( uint8_t i = 0; i < 32; i++ )
 80310aa:	2b20      	cmp	r3, #32
        sumBit += ( x & ( 1 << i ) ) >> i;
 80310ac:	b2f6      	uxtb	r6, r6
    for( uint8_t i = 0; i < 32; i++ )
 80310ae:	d1f5      	bne.n	803109c <FragDecoderProcess+0xb4>
    if( sumBit == 1 )
 80310b0:	1e73      	subs	r3, r6, #1
 80310b2:	425e      	negs	r6, r3
    x = 1 + ( 1001 * n );
 80310b4:	f240 30e9 	movw	r0, #1001	; 0x3e9
 80310b8:	fb00 f404 	mul.w	r4, r0, r4
    if( sumBit == 1 )
 80310bc:	415e      	adcs	r6, r3
    for( uint8_t i = 0; i < ( ( m >> 3 ) + 1 ); i++ )
 80310be:	2300      	movs	r3, #0
    x = 1 + ( 1001 * n );
 80310c0:	3401      	adds	r4, #1
    for( uint8_t i = 0; i < ( ( m >> 3 ) + 1 ); i++ )
 80310c2:	ea4f 02e9 	mov.w	r2, r9, asr #3
        matrixRow[i] = 0;
 80310c6:	4618      	mov	r0, r3
 80310c8:	a93c      	add	r1, sp, #240	; 0xf0
 80310ca:	4419      	add	r1, r3
    for( uint8_t i = 0; i < ( ( m >> 3 ) + 1 ); i++ )
 80310cc:	3301      	adds	r3, #1
 80310ce:	b2db      	uxtb	r3, r3
 80310d0:	429a      	cmp	r2, r3
        matrixRow[i] = 0;
 80310d2:	f801 0cd4 	strb.w	r0, [r1, #-212]
    for( uint8_t i = 0; i < ( ( m >> 3 ) + 1 ); i++ )
 80310d6:	daf7      	bge.n	80310c8 <FragDecoderProcess+0xe0>
    while( nbCoeff < ( m >> 1 ) )
 80310d8:	ea4f 0b69 	mov.w	fp, r9, asr #1
    int32_t nbCoeff = 0;
 80310dc:	f04f 0a00 	mov.w	sl, #0
            r = x % ( m + mTemp );
 80310e0:	444e      	add	r6, r9
    while( nbCoeff < ( m >> 1 ) )
 80310e2:	45da      	cmp	sl, fp
 80310e4:	db0c      	blt.n	8031100 <FragDecoderProcess+0x118>
        for( int32_t i = 0; i < FragDecoder.FragNb; i++ )
 80310e6:	2600      	movs	r6, #0
    int32_t first = 0;
 80310e8:	46b0      	mov	r8, r6
        for( int32_t i = 0; i < FragDecoder.FragNb; i++ )
 80310ea:	88ab      	ldrh	r3, [r5, #4]
 80310ec:	42b3      	cmp	r3, r6
 80310ee:	dc28      	bgt.n	8031142 <FragDecoderProcess+0x15a>
        firstOneInRow = BitArrayFindFirstOne( dataTempVector, FragDecoder.Status.FragNbLost );
 80310f0:	f8b5 6880 	ldrh.w	r6, [r5, #2176]	; 0x880
    for( uint16_t i = 0; i < size; i++)
 80310f4:	2200      	movs	r2, #0
 80310f6:	b294      	uxth	r4, r2
 80310f8:	42a6      	cmp	r6, r4
 80310fa:	d848      	bhi.n	803118e <FragDecoderProcess+0x1a6>
    return 0;
 80310fc:	2400      	movs	r4, #0
 80310fe:	e04e      	b.n	803119e <FragDecoderProcess+0x1b6>
    return ( value >> 1 ) + ( ( b0 ^ b1 ) << 22 );
 8031100:	ea84 1364 	eor.w	r3, r4, r4, asr #5
 8031104:	059b      	lsls	r3, r3, #22
 8031106:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 803110a:	eb03 0464 	add.w	r4, r3, r4, asr #1
            r = x % ( m + mTemp );
 803110e:	fb94 f8f6 	sdiv	r8, r4, r6
 8031112:	fb06 4818 	mls	r8, r6, r8, r4
        while( r >= m )
 8031116:	45c1      	cmp	r9, r8
 8031118:	ddf2      	ble.n	8031100 <FragDecoderProcess+0x118>
        if ((GetParity(r, matrixRow) == 0) || (LmhpFragmentationGetPackageVersion() == 1U))
 803111a:	fa1f f888 	uxth.w	r8, r8
 803111e:	a907      	add	r1, sp, #28
 8031120:	4640      	mov	r0, r8
 8031122:	f7ff fe65 	bl	8030df0 <GetParity>
 8031126:	b938      	cbnz	r0, 8031138 <FragDecoderProcess+0x150>
            SetParity(r, matrixRow, 1);
 8031128:	2201      	movs	r2, #1
 803112a:	a907      	add	r1, sp, #28
 803112c:	4640      	mov	r0, r8
 803112e:	f7ff fe69 	bl	8030e04 <SetParity>
            nbCoeff += 1;
 8031132:	f10a 0a01 	add.w	sl, sl, #1
 8031136:	e7d4      	b.n	80310e2 <FragDecoderProcess+0xfa>
        if ((GetParity(r, matrixRow) == 0) || (LmhpFragmentationGetPackageVersion() == 1U))
 8031138:	f001 fbbc 	bl	80328b4 <LmhpFragmentationGetPackageVersion>
 803113c:	2801      	cmp	r0, #1
 803113e:	d1d0      	bne.n	80310e2 <FragDecoderProcess+0xfa>
 8031140:	e7f2      	b.n	8031128 <FragDecoderProcess+0x140>
            if( GetParity( i , matrixRow ) == 1 )
 8031142:	fa1f f986 	uxth.w	r9, r6
 8031146:	a907      	add	r1, sp, #28
 8031148:	4648      	mov	r0, r9
 803114a:	f7ff fe51 	bl	8030df0 <GetParity>
 803114e:	2801      	cmp	r0, #1
 8031150:	4604      	mov	r4, r0
 8031152:	d112      	bne.n	803117a <FragDecoderProcess+0x192>
                if( FragDecoder.FragNbMissingIndex[i] == 0 )
 8031154:	eb05 0346 	add.w	r3, r5, r6, lsl #1
 8031158:	f8b3 22dc 	ldrh.w	r2, [r3, #732]	; 0x2dc
 803115c:	b97a      	cbnz	r2, 803117e <FragDecoderProcess+0x196>
                    SetParity( i, matrixRow, 0 );
 803115e:	a907      	add	r1, sp, #28
 8031160:	4648      	mov	r0, r9
 8031162:	f7ff fe4f 	bl	8030e04 <SetParity>
                    GetRow( matrixDataTemp, i, FragDecoder.FragSize );
 8031166:	79aa      	ldrb	r2, [r5, #6]
 8031168:	4649      	mov	r1, r9
 803116a:	a81e      	add	r0, sp, #120	; 0x78
 803116c:	f7ff fe2e 	bl	8030dcc <GetRow>
                    XorDataLine( rawData, matrixDataTemp, FragDecoder.FragSize );
 8031170:	79aa      	ldrb	r2, [r5, #6]
 8031172:	a91e      	add	r1, sp, #120	; 0x78
 8031174:	4638      	mov	r0, r7
 8031176:	f7ff fe55 	bl	8030e24 <XorDataLine>
        for( int32_t i = 0; i < FragDecoder.FragNb; i++ )
 803117a:	3601      	adds	r6, #1
 803117c:	e7b5      	b.n	80310ea <FragDecoderProcess+0x102>
                    SetParity( FragDecoder.FragNbMissingIndex[i] - 1, dataTempVector, 1 );
 803117e:	1e50      	subs	r0, r2, #1
 8031180:	a901      	add	r1, sp, #4
 8031182:	4622      	mov	r2, r4
 8031184:	b280      	uxth	r0, r0
 8031186:	f7ff fe3d 	bl	8030e04 <SetParity>
                        first = 1;
 803118a:	46a0      	mov	r8, r4
 803118c:	e7f5      	b.n	803117a <FragDecoderProcess+0x192>
        if ( GetParity( i, bitArray ) == 1 )
 803118e:	a901      	add	r1, sp, #4
 8031190:	4620      	mov	r0, r4
 8031192:	f7ff fe2d 	bl	8030df0 <GetParity>
 8031196:	2801      	cmp	r0, #1
 8031198:	f102 0201 	add.w	r2, r2, #1
 803119c:	d1ab      	bne.n	80310f6 <FragDecoderProcess+0x10e>
        if( first > 0 )
 803119e:	f1b8 0f00 	cmp.w	r8, #0
 80311a2:	f43f af43 	beq.w	803102c <FragDecoderProcess+0x44>
            while( GetParity( firstOneInRow, FragDecoder.S ) == 1 )
 80311a6:	f8df 8150 	ldr.w	r8, [pc, #336]	; 80312f8 <FragDecoderProcess+0x310>
 80311aa:	4641      	mov	r1, r8
 80311ac:	4620      	mov	r0, r4
 80311ae:	f7ff fe1f 	bl	8030df0 <GetParity>
 80311b2:	2801      	cmp	r0, #1
 80311b4:	f8b5 2880 	ldrh.w	r2, [r5, #2176]	; 0x880
 80311b8:	d004      	beq.n	80311c4 <FragDecoderProcess+0x1dc>
static void FragPushLineToBinaryMatrix( uint8_t *bitArray, uint16_t rowIndex, uint16_t bitsInRow )
{
    uint32_t findByte = 0;
    uint32_t findBitInByte = 0;

    if ( rowIndex > 0) {
 80311ba:	2c00      	cmp	r4, #0
 80311bc:	d15b      	bne.n	8031276 <FragDecoderProcess+0x28e>
    uint32_t findBitInByte = 0;
 80311be:	4626      	mov	r6, r4
    uint32_t findByte = 0;
 80311c0:	46a1      	mov	r9, r4
 80311c2:	e067      	b.n	8031294 <FragDecoderProcess+0x2ac>
                FragExtractLineFromBinaryMatrix( dataTempVector2, firstOneInRow, FragDecoder.Status.FragNbLost );
 80311c4:	4621      	mov	r1, r4
 80311c6:	a804      	add	r0, sp, #16
 80311c8:	f7ff fe96 	bl	8030ef8 <FragExtractLineFromBinaryMatrix>
                XorParityLine( dataTempVector, dataTempVector2, FragDecoder.Status.FragNbLost );
 80311cc:	f8b5 2880 	ldrh.w	r2, [r5, #2176]	; 0x880
 80311d0:	a904      	add	r1, sp, #16
 80311d2:	a801      	add	r0, sp, #4
 80311d4:	f7ff fe33 	bl	8030e3e <XorParityLine>
                li = FragFindMissingIndex( firstOneInRow );
 80311d8:	4620      	mov	r0, r4
 80311da:	f7ff fe77 	bl	8030ecc <FragFindMissingIndex>
                GetRow( matrixDataTemp, li, FragDecoder.FragSize );
 80311de:	79aa      	ldrb	r2, [r5, #6]
                li = FragFindMissingIndex( firstOneInRow );
 80311e0:	4601      	mov	r1, r0
                GetRow( matrixDataTemp, li, FragDecoder.FragSize );
 80311e2:	a81e      	add	r0, sp, #120	; 0x78
 80311e4:	f7ff fdf2 	bl	8030dcc <GetRow>
                XorDataLine( rawData, matrixDataTemp, FragDecoder.FragSize );
 80311e8:	79aa      	ldrb	r2, [r5, #6]
 80311ea:	a91e      	add	r1, sp, #120	; 0x78
 80311ec:	4638      	mov	r0, r7
 80311ee:	f7ff fe19 	bl	8030e24 <XorDataLine>
                if( BitArrayIsAllZeros( dataTempVector, FragDecoder.Status.FragNbLost ) )
 80311f2:	f8b5 6880 	ldrh.w	r6, [r5, #2176]	; 0x880
    for( uint16_t i = 0; i < size; i++ )
 80311f6:	2200      	movs	r2, #0
 80311f8:	b290      	uxth	r0, r2
 80311fa:	4286      	cmp	r6, r0
 80311fc:	d825      	bhi.n	803124a <FragDecoderProcess+0x262>
            if( FragDecoder.M2BLine == FragDecoder.Status.FragNbLost )
 80311fe:	f8b5 3880 	ldrh.w	r3, [r5, #2176]	; 0x880
 8031202:	68ac      	ldr	r4, [r5, #8]
 8031204:	429c      	cmp	r4, r3
 8031206:	f47f af11 	bne.w	803102c <FragDecoderProcess+0x44>
                if( FragDecoder.Status.FragNbLost > 1 )
 803120a:	2c01      	cmp	r4, #1
 803120c:	4620      	mov	r0, r4
 803120e:	f67f af0f 	bls.w	8031030 <FragDecoderProcess+0x48>
                        GetRow( matrixDataTemp, li, FragDecoder.FragSize );
 8031212:	4d38      	ldr	r5, [pc, #224]	; (80312f4 <FragDecoderProcess+0x30c>)
                    for( i = ( FragDecoder.Status.FragNbLost - 2 ); i >= 0 ; i-- )
 8031214:	3c02      	subs	r4, #2
                        li = FragFindMissingIndex( i );
 8031216:	fa1f fa84 	uxth.w	sl, r4
 803121a:	4650      	mov	r0, sl
 803121c:	f7ff fe56 	bl	8030ecc <FragFindMissingIndex>
                        GetRow( matrixDataTemp, li, FragDecoder.FragSize );
 8031220:	79aa      	ldrb	r2, [r5, #6]
 8031222:	4601      	mov	r1, r0
                        li = FragFindMissingIndex( i );
 8031224:	4680      	mov	r8, r0
                        GetRow( matrixDataTemp, li, FragDecoder.FragSize );
 8031226:	a81e      	add	r0, sp, #120	; 0x78
 8031228:	f7ff fdd0 	bl	8030dcc <GetRow>
                        for( j = ( FragDecoder.Status.FragNbLost - 1 ); j > i; j--)
 803122c:	f8b5 6880 	ldrh.w	r6, [r5, #2176]	; 0x880
 8031230:	3e01      	subs	r6, #1
 8031232:	42a6      	cmp	r6, r4
 8031234:	dc62      	bgt.n	80312fc <FragDecoderProcess+0x314>
                        SetRow( matrixDataTemp, li, FragDecoder.FragSize );
 8031236:	79aa      	ldrb	r2, [r5, #6]
 8031238:	4641      	mov	r1, r8
 803123a:	a81e      	add	r0, sp, #120	; 0x78
 803123c:	f7ff fdb4 	bl	8030da8 <SetRow>
                    for( i = ( FragDecoder.Status.FragNbLost - 2 ); i >= 0 ; i-- )
 8031240:	3c01      	subs	r4, #1
 8031242:	d2e8      	bcs.n	8031216 <FragDecoderProcess+0x22e>
                    return FragDecoder.Status.FragNbLost;
 8031244:	f8b5 0880 	ldrh.w	r0, [r5, #2176]	; 0x880
 8031248:	e6f2      	b.n	8031030 <FragDecoderProcess+0x48>
        if( GetParity( i, bitArray ) == 1 )
 803124a:	a901      	add	r1, sp, #4
 803124c:	f7ff fdd0 	bl	8030df0 <GetParity>
 8031250:	2801      	cmp	r0, #1
 8031252:	f102 0201 	add.w	r2, r2, #1
 8031256:	d1cf      	bne.n	80311f8 <FragDecoderProcess+0x210>
 8031258:	2200      	movs	r2, #0
 803125a:	e007      	b.n	803126c <FragDecoderProcess+0x284>
        if ( GetParity( i, bitArray ) == 1 )
 803125c:	a901      	add	r1, sp, #4
 803125e:	4620      	mov	r0, r4
 8031260:	f7ff fdc6 	bl	8030df0 <GetParity>
 8031264:	2801      	cmp	r0, #1
 8031266:	f102 0201 	add.w	r2, r2, #1
 803126a:	d09e      	beq.n	80311aa <FragDecoderProcess+0x1c2>
 803126c:	b294      	uxth	r4, r2
    for( uint16_t i = 0; i < size; i++)
 803126e:	42a6      	cmp	r6, r4
 8031270:	d8f4      	bhi.n	803125c <FragDecoderProcess+0x274>
    return 0;
 8031272:	2400      	movs	r4, #0
 8031274:	e799      	b.n	80311aa <FragDecoderProcess+0x1c2>
        findByte      = ( rowIndex * bitsInRow - ( ( rowIndex * ( rowIndex - 1 ) ) >> 1 ) ) >> 3;
 8031276:	1e63      	subs	r3, r4, #1
 8031278:	4363      	muls	r3, r4
 803127a:	fb04 f602 	mul.w	r6, r4, r2
 803127e:	eba6 0663 	sub.w	r6, r6, r3, asr #1
        findBitInByte = ( rowIndex * bitsInRow - ( ( rowIndex * ( rowIndex - 1 ) ) >> 1 ) ) % 8;
 8031282:	4273      	negs	r3, r6
 8031284:	f003 0307 	and.w	r3, r3, #7
        findByte      = ( rowIndex * bitsInRow - ( ( rowIndex * ( rowIndex - 1 ) ) >> 1 ) ) >> 3;
 8031288:	ea4f 09e6 	mov.w	r9, r6, asr #3
        findBitInByte = ( rowIndex * bitsInRow - ( ( rowIndex * ( rowIndex - 1 ) ) >> 1 ) ) % 8;
 803128c:	f006 0607 	and.w	r6, r6, #7
 8031290:	bf58      	it	pl
 8031292:	425e      	negpl	r6, r3
    uint32_t findByte = 0;
 8031294:	46a0      	mov	r8, r4
    }
    for( uint16_t i = rowIndex; i < bitsInRow; i++ )
    {
        if( GetParity( i, bitArray ) == 0 )
        {
            FragDecoder.MatrixM2B[findByte] = FragDecoder.MatrixM2B[findByte] & ( 0xFF - ( 1 << ( 7 - findBitInByte ) ) );
 8031296:	f04f 0a01 	mov.w	sl, #1
 803129a:	e018      	b.n	80312ce <FragDecoderProcess+0x2e6>
        if( GetParity( i, bitArray ) == 0 )
 803129c:	a901      	add	r1, sp, #4
 803129e:	4640      	mov	r0, r8
 80312a0:	f7ff fda6 	bl	8030df0 <GetParity>
 80312a4:	b948      	cbnz	r0, 80312ba <FragDecoderProcess+0x2d2>
            FragDecoder.MatrixM2B[findByte] = FragDecoder.MatrixM2B[findByte] & ( 0xFF - ( 1 << ( 7 - findBitInByte ) ) );
 80312a6:	eb05 0309 	add.w	r3, r5, r9
 80312aa:	f1c6 0107 	rsb	r1, r6, #7
 80312ae:	fa0a f001 	lsl.w	r0, sl, r1
 80312b2:	7b19      	ldrb	r1, [r3, #12]
 80312b4:	ea21 0100 	bic.w	r1, r1, r0
 80312b8:	7319      	strb	r1, [r3, #12]
        }
        findBitInByte++;
 80312ba:	3601      	adds	r6, #1
        if( findBitInByte == 8 )
 80312bc:	2e08      	cmp	r6, #8
    for( uint16_t i = rowIndex; i < bitsInRow; i++ )
 80312be:	f108 0801 	add.w	r8, r8, #1
        {
            findBitInByte = 0;
            findByte++;
 80312c2:	bf04      	itt	eq
 80312c4:	f109 0901 	addeq.w	r9, r9, #1
            findBitInByte = 0;
 80312c8:	2600      	moveq	r6, #0
    for( uint16_t i = rowIndex; i < bitsInRow; i++ )
 80312ca:	fa1f f888 	uxth.w	r8, r8
 80312ce:	4542      	cmp	r2, r8
 80312d0:	d8e4      	bhi.n	803129c <FragDecoderProcess+0x2b4>
                li = FragFindMissingIndex( firstOneInRow );
 80312d2:	4620      	mov	r0, r4
 80312d4:	f7ff fdfa 	bl	8030ecc <FragFindMissingIndex>
                SetRow( rawData, li, FragDecoder.FragSize );
 80312d8:	79aa      	ldrb	r2, [r5, #6]
                li = FragFindMissingIndex( firstOneInRow );
 80312da:	4601      	mov	r1, r0
                SetRow( rawData, li, FragDecoder.FragSize );
 80312dc:	4638      	mov	r0, r7
 80312de:	f7ff fd63 	bl	8030da8 <SetRow>
                SetParity( firstOneInRow, FragDecoder.S, 1 );
 80312e2:	4905      	ldr	r1, [pc, #20]	; (80312f8 <FragDecoderProcess+0x310>)
 80312e4:	2201      	movs	r2, #1
 80312e6:	4620      	mov	r0, r4
 80312e8:	f7ff fd8c 	bl	8030e04 <SetParity>
                FragDecoder.M2BLine++;
 80312ec:	68ab      	ldr	r3, [r5, #8]
 80312ee:	3301      	adds	r3, #1
 80312f0:	60ab      	str	r3, [r5, #8]
 80312f2:	e784      	b.n	80311fe <FragDecoderProcess+0x216>
 80312f4:	20003f54 	.word	0x20003f54
 80312f8:	200047c8 	.word	0x200047c8
                            FragExtractLineFromBinaryMatrix( dataTempVector2, i, FragDecoder.Status.FragNbLost );
 80312fc:	f8b5 2880 	ldrh.w	r2, [r5, #2176]	; 0x880
 8031300:	4651      	mov	r1, sl
 8031302:	a804      	add	r0, sp, #16
 8031304:	fa1f f986 	uxth.w	r9, r6
 8031308:	f7ff fdf6 	bl	8030ef8 <FragExtractLineFromBinaryMatrix>
                            FragExtractLineFromBinaryMatrix( dataTempVector, j, FragDecoder.Status.FragNbLost );
 803130c:	f8b5 2880 	ldrh.w	r2, [r5, #2176]	; 0x880
 8031310:	4649      	mov	r1, r9
 8031312:	a801      	add	r0, sp, #4
 8031314:	f7ff fdf0 	bl	8030ef8 <FragExtractLineFromBinaryMatrix>
                            if( GetParity( j, dataTempVector2 ) == 1 )
 8031318:	a904      	add	r1, sp, #16
 803131a:	4648      	mov	r0, r9
 803131c:	f7ff fd68 	bl	8030df0 <GetParity>
 8031320:	2801      	cmp	r0, #1
 8031322:	d185      	bne.n	8031230 <FragDecoderProcess+0x248>
                                XorParityLine( dataTempVector2, dataTempVector, FragDecoder.Status.FragNbLost );
 8031324:	f8b5 2880 	ldrh.w	r2, [r5, #2176]	; 0x880
 8031328:	a901      	add	r1, sp, #4
 803132a:	a804      	add	r0, sp, #16
 803132c:	f7ff fd87 	bl	8030e3e <XorParityLine>
                                lj = FragFindMissingIndex( j );
 8031330:	4648      	mov	r0, r9
 8031332:	f7ff fdcb 	bl	8030ecc <FragFindMissingIndex>
                                GetRow( rawData, lj, FragDecoder.FragSize );
 8031336:	79aa      	ldrb	r2, [r5, #6]
                                lj = FragFindMissingIndex( j );
 8031338:	4601      	mov	r1, r0
                                GetRow( rawData, lj, FragDecoder.FragSize );
 803133a:	4638      	mov	r0, r7
 803133c:	f7ff fd46 	bl	8030dcc <GetRow>
                                XorDataLine( matrixDataTemp , rawData , FragDecoder.FragSize );
 8031340:	79aa      	ldrb	r2, [r5, #6]
 8031342:	4639      	mov	r1, r7
 8031344:	a81e      	add	r0, sp, #120	; 0x78
 8031346:	f7ff fd6d 	bl	8030e24 <XorDataLine>
 803134a:	e771      	b.n	8031230 <FragDecoderProcess+0x248>

0803134c <FragDecoderGetStatus>:
    return FragDecoder.Status;
 803134c:	4902      	ldr	r1, [pc, #8]	; (8031358 <FragDecoderGetStatus+0xc>)
 803134e:	680a      	ldr	r2, [r1, #0]
 8031350:	6002      	str	r2, [r0, #0]
 8031352:	684a      	ldr	r2, [r1, #4]
 8031354:	6042      	str	r2, [r0, #4]
}
 8031356:	4770      	bx	lr
 8031358:	200047d2 	.word	0x200047d2

0803135c <LmHandlerDeviceTimeReq>:
        return LORAMAC_HANDLER_ERROR;
    }
}

LmHandlerErrorStatus_t LmHandlerDeviceTimeReq( void )
{
 803135c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    LoRaMacStatus_t status;
    MlmeReq_t mlmeReq;

    mlmeReq.Type = MLME_DEVICE_TIME;
 803135e:	230a      	movs	r3, #10

    status = LoRaMacMlmeRequest( &mlmeReq );
 8031360:	a801      	add	r0, sp, #4
    mlmeReq.Type = MLME_DEVICE_TIME;
 8031362:	f88d 3004 	strb.w	r3, [sp, #4]
    status = LoRaMacMlmeRequest( &mlmeReq );
 8031366:	f004 f81f 	bl	80353a8 <LoRaMacMlmeRequest>

    if( status == LORAMAC_STATUS_OK )
 803136a:	3800      	subs	r0, #0
 803136c:	bf18      	it	ne
 803136e:	2001      	movne	r0, #1
    }
    else
    {
        return LORAMAC_HANDLER_ERROR;
    }
}
 8031370:	4240      	negs	r0, r0
 8031372:	b007      	add	sp, #28
 8031374:	f85d fb04 	ldr.w	pc, [sp], #4

08031378 <McpsConfirm>:
 * LORAMAC NOTIFICATIONS HANDLING
 *=============================================================================
 */

static void McpsConfirm( McpsConfirm_t *mcpsConfirm )
{
 8031378:	b570      	push	{r4, r5, r6, lr}
    TxParams.IsMcpsConfirm = 1;
 803137a:	4c11      	ldr	r4, [pc, #68]	; (80313c0 <McpsConfirm+0x48>)
 803137c:	2301      	movs	r3, #1
 803137e:	7023      	strb	r3, [r4, #0]
    TxParams.Status = mcpsConfirm->Status;
 8031380:	7843      	ldrb	r3, [r0, #1]
 8031382:	7063      	strb	r3, [r4, #1]
    TxParams.Datarate = mcpsConfirm->Datarate;
 8031384:	7883      	ldrb	r3, [r0, #2]
 8031386:	7123      	strb	r3, [r4, #4]
    TxParams.UplinkCounter = mcpsConfirm->UpLinkCounter;
 8031388:	68c3      	ldr	r3, [r0, #12]
 803138a:	60a3      	str	r3, [r4, #8]
    TxParams.TxPower = mcpsConfirm->TxPower;
 803138c:	78c3      	ldrb	r3, [r0, #3]
 803138e:	7523      	strb	r3, [r4, #20]
    TxParams.Channel = mcpsConfirm->Channel;
 8031390:	6903      	ldr	r3, [r0, #16]
 8031392:	7563      	strb	r3, [r4, #21]
    TxParams.AckReceived = mcpsConfirm->AckReceived;
 8031394:	7903      	ldrb	r3, [r0, #4]
 8031396:	70e3      	strb	r3, [r4, #3]

    LmHandlerCallbacks->OnTxData( &TxParams );
 8031398:	69a3      	ldr	r3, [r4, #24]
{
 803139a:	4605      	mov	r5, r0
    LmHandlerCallbacks->OnTxData( &TxParams );
 803139c:	6a1b      	ldr	r3, [r3, #32]
 803139e:	4620      	mov	r0, r4
 80313a0:	4798      	blx	r3
    }
}

static void LmHandlerPackagesNotify( PackageNotifyTypes_t notifyType, void *params )
{
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 80313a2:	341c      	adds	r4, #28
 80313a4:	2600      	movs	r6, #0
    {
        if( LmHandlerPackages[i] != NULL )
 80313a6:	f854 3b04 	ldr.w	r3, [r4], #4
 80313aa:	b11b      	cbz	r3, 80313b4 <McpsConfirm+0x3c>
        {
            switch( notifyType )
            {
                case PACKAGE_MCPS_CONFIRM:
                {
                    if( LmHandlerPackages[i]->OnMcpsConfirmProcess != NULL )
 80313ac:	699b      	ldr	r3, [r3, #24]
 80313ae:	b10b      	cbz	r3, 80313b4 <McpsConfirm+0x3c>
                    {
                        LmHandlerPackages[i]->OnMcpsConfirmProcess( ( McpsConfirm_t* ) params );
 80313b0:	4628      	mov	r0, r5
 80313b2:	4798      	blx	r3
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 80313b4:	3601      	adds	r6, #1
 80313b6:	b2f3      	uxtb	r3, r6
 80313b8:	2b05      	cmp	r3, #5
 80313ba:	b276      	sxtb	r6, r6
 80313bc:	d1f3      	bne.n	80313a6 <McpsConfirm+0x2e>
}
 80313be:	bd70      	pop	{r4, r5, r6, pc}
 80313c0:	200047dc 	.word	0x200047dc

080313c4 <LmHandlerConfigure>:
{
 80313c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    UTIL_MEM_cpy_8((void *)&LmHandlerParams, (const void *)handlerParams, sizeof(LmHandlerParams_t));
 80313c8:	4e63      	ldr	r6, [pc, #396]	; (8031558 <LmHandlerConfigure+0x194>)
{
 80313ca:	4601      	mov	r1, r0
    UTIL_MEM_cpy_8((void *)&LmHandlerParams, (const void *)handlerParams, sizeof(LmHandlerParams_t));
 80313cc:	2210      	movs	r2, #16
{
 80313ce:	b09e      	sub	sp, #120	; 0x78
    UTIL_MEM_cpy_8((void *)&LmHandlerParams, (const void *)handlerParams, sizeof(LmHandlerParams_t));
 80313d0:	f106 0030 	add.w	r0, r6, #48	; 0x30
 80313d4:	f009 fd98 	bl	803af08 <UTIL_MEM_cpy_8>
    loraInfo = LoraInfo_GetPtr();
 80313d8:	f7fb fe14 	bl	802d004 <LoraInfo_GetPtr>
    if (0U != ((1 << (LmHandlerParams.ActiveRegion)) & (loraInfo->Region)))
 80313dc:	f896 2030 	ldrb.w	r2, [r6, #48]	; 0x30
 80313e0:	6843      	ldr	r3, [r0, #4]
 80313e2:	2701      	movs	r7, #1
 80313e4:	fa07 f102 	lsl.w	r1, r7, r2
 80313e8:	4019      	ands	r1, r3
 80313ea:	d00a      	beq.n	8031402 <LmHandlerConfigure+0x3e>
        if (LoRaMacInitialization(&LoRaMacPrimitives, &LoRaMacCallbacks, LmHandlerParams.ActiveRegion) != LORAMAC_STATUS_OK)
 80313ec:	f106 0140 	add.w	r1, r6, #64	; 0x40
 80313f0:	f106 0054 	add.w	r0, r6, #84	; 0x54
 80313f4:	f003 fa10 	bl	8034818 <LoRaMacInitialization>
 80313f8:	4605      	mov	r5, r0
 80313fa:	b140      	cbz	r0, 803140e <LmHandlerConfigure+0x4a>
            return LORAMAC_HANDLER_ERROR;
 80313fc:	f04f 30ff 	mov.w	r0, #4294967295
 8031400:	e0a6      	b.n	8031550 <LmHandlerConfigure+0x18c>
        MW_LOG(TS_ON, VLEVEL_ALWAYS, "error: Region is not defined in the MW: set lorawan_conf.h accordingly\r\n");
 8031402:	4b56      	ldr	r3, [pc, #344]	; (803155c <LmHandlerConfigure+0x198>)
 8031404:	463a      	mov	r2, r7
 8031406:	4608      	mov	r0, r1
 8031408:	f009 fc76 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
        while (1) {}  /* error: Region is not defined in the MW */
 803140c:	e7fe      	b.n	803140c <LmHandlerConfigure+0x48>
    nbNvmData = NvmDataMgmtRestore( );
 803140e:	f005 f97b 	bl	8036708 <NvmDataMgmtRestore>
    if( nbNvmData > 0 )
 8031412:	3800      	subs	r0, #0
    memcpy1( CommissioningParams.DevEui, mibReq.Param.DevEui, 8 );
 8031414:	4c52      	ldr	r4, [pc, #328]	; (8031560 <LmHandlerConfigure+0x19c>)
    if( nbNvmData > 0 )
 8031416:	bf18      	it	ne
 8031418:	2001      	movne	r0, #1
    mibReq.Type = MIB_DEV_EUI;
 803141a:	f04f 0802 	mov.w	r8, #2
    if( nbNvmData > 0 )
 803141e:	f886 0064 	strb.w	r0, [r6, #100]	; 0x64
    LoRaMacMibGetRequestConfirm( &mibReq );
 8031422:	a80c      	add	r0, sp, #48	; 0x30
    mibReq.Type = MIB_DEV_EUI;
 8031424:	f88d 8030 	strb.w	r8, [sp, #48]	; 0x30
    LoRaMacMibGetRequestConfirm( &mibReq );
 8031428:	f003 fc16 	bl	8034c58 <LoRaMacMibGetRequestConfirm>
    memcpy1( CommissioningParams.DevEui, mibReq.Param.DevEui, 8 );
 803142c:	990d      	ldr	r1, [sp, #52]	; 0x34
 803142e:	2208      	movs	r2, #8
 8031430:	4620      	mov	r0, r4
 8031432:	f007 fd7b 	bl	8038f2c <memcpy1>
    mibReq.Type = MIB_JOIN_EUI;
 8031436:	2303      	movs	r3, #3
    LoRaMacMibGetRequestConfirm( &mibReq );
 8031438:	a80c      	add	r0, sp, #48	; 0x30
    mibReq.Type = MIB_JOIN_EUI;
 803143a:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
    LoRaMacMibGetRequestConfirm( &mibReq );
 803143e:	f003 fc0b 	bl	8034c58 <LoRaMacMibGetRequestConfirm>
    memcpy1( CommissioningParams.JoinEui, mibReq.Param.JoinEui, 8 );
 8031442:	2208      	movs	r2, #8
 8031444:	18a0      	adds	r0, r4, r2
 8031446:	990d      	ldr	r1, [sp, #52]	; 0x34
 8031448:	f007 fd70 	bl	8038f2c <memcpy1>
    mibReq.Type = MIB_DEV_ADDR;
 803144c:	2306      	movs	r3, #6
 803144e:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
    LoRaMacMibSetRequestConfirm(&mibReq);
 8031452:	a80c      	add	r0, sp, #48	; 0x30
    mibReq.Param.DevAddr = CommissioningParams.DevAddr;
 8031454:	6963      	ldr	r3, [r4, #20]
 8031456:	930d      	str	r3, [sp, #52]	; 0x34
    LoRaMacMibSetRequestConfirm(&mibReq);
 8031458:	f003 fcba 	bl	8034dd0 <LoRaMacMibSetRequestConfirm>
    MW_LOG(TS_OFF, VLEVEL_M, "###### DevEui:  %02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\r\n",
 803145c:	79e3      	ldrb	r3, [r4, #7]
 803145e:	9307      	str	r3, [sp, #28]
 8031460:	79a3      	ldrb	r3, [r4, #6]
 8031462:	9306      	str	r3, [sp, #24]
 8031464:	7963      	ldrb	r3, [r4, #5]
 8031466:	9305      	str	r3, [sp, #20]
 8031468:	7923      	ldrb	r3, [r4, #4]
 803146a:	9304      	str	r3, [sp, #16]
 803146c:	78e3      	ldrb	r3, [r4, #3]
 803146e:	9303      	str	r3, [sp, #12]
 8031470:	78a3      	ldrb	r3, [r4, #2]
 8031472:	9302      	str	r3, [sp, #8]
 8031474:	7863      	ldrb	r3, [r4, #1]
 8031476:	9301      	str	r3, [sp, #4]
 8031478:	7823      	ldrb	r3, [r4, #0]
 803147a:	9300      	str	r3, [sp, #0]
 803147c:	462a      	mov	r2, r5
 803147e:	4b39      	ldr	r3, [pc, #228]	; (8031564 <LmHandlerConfigure+0x1a0>)
 8031480:	4629      	mov	r1, r5
 8031482:	4640      	mov	r0, r8
 8031484:	f009 fc38 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
    MW_LOG(TS_OFF, VLEVEL_M, "###### AppEui:  %02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\r\n",
 8031488:	7be3      	ldrb	r3, [r4, #15]
 803148a:	9307      	str	r3, [sp, #28]
 803148c:	7ba3      	ldrb	r3, [r4, #14]
 803148e:	9306      	str	r3, [sp, #24]
 8031490:	7b63      	ldrb	r3, [r4, #13]
 8031492:	9305      	str	r3, [sp, #20]
 8031494:	7b23      	ldrb	r3, [r4, #12]
 8031496:	9304      	str	r3, [sp, #16]
 8031498:	7ae3      	ldrb	r3, [r4, #11]
 803149a:	9303      	str	r3, [sp, #12]
 803149c:	7aa3      	ldrb	r3, [r4, #10]
 803149e:	9302      	str	r3, [sp, #8]
 80314a0:	7a63      	ldrb	r3, [r4, #9]
 80314a2:	9301      	str	r3, [sp, #4]
 80314a4:	7a23      	ldrb	r3, [r4, #8]
 80314a6:	9300      	str	r3, [sp, #0]
 80314a8:	462a      	mov	r2, r5
 80314aa:	4b2f      	ldr	r3, [pc, #188]	; (8031568 <LmHandlerConfigure+0x1a4>)
 80314ac:	4629      	mov	r1, r5
 80314ae:	4640      	mov	r0, r8
 80314b0:	f009 fc22 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
    MW_LOG(TS_OFF, VLEVEL_M, "###### DevAddr: %02X:%02X:%02X:%02X\r\n",
 80314b4:	7d23      	ldrb	r3, [r4, #20]
 80314b6:	9303      	str	r3, [sp, #12]
 80314b8:	7d63      	ldrb	r3, [r4, #21]
 80314ba:	9302      	str	r3, [sp, #8]
 80314bc:	7da3      	ldrb	r3, [r4, #22]
 80314be:	9301      	str	r3, [sp, #4]
 80314c0:	7de3      	ldrb	r3, [r4, #23]
 80314c2:	9300      	str	r3, [sp, #0]
 80314c4:	462a      	mov	r2, r5
 80314c6:	4b29      	ldr	r3, [pc, #164]	; (803156c <LmHandlerConfigure+0x1a8>)
 80314c8:	4629      	mov	r1, r5
 80314ca:	4640      	mov	r0, r8
 80314cc:	f009 fc14 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
    MW_LOG(TS_OFF, VLEVEL_L, "###### KMS ENABLED \r\n");
 80314d0:	462a      	mov	r2, r5
 80314d2:	4629      	mov	r1, r5
 80314d4:	4b26      	ldr	r3, [pc, #152]	; (8031570 <LmHandlerConfigure+0x1ac>)
 80314d6:	4638      	mov	r0, r7
 80314d8:	f009 fc0e 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
    mibReq.Type = MIB_PUBLIC_NETWORK;
 80314dc:	240f      	movs	r4, #15
    LoRaMacMibSetRequestConfirm(&mibReq);
 80314de:	a80c      	add	r0, sp, #48	; 0x30
    mibReq.Type = MIB_PUBLIC_NETWORK;
 80314e0:	f88d 4030 	strb.w	r4, [sp, #48]	; 0x30
    mibReq.Param.EnablePublicNetwork = LORAWAN_PUBLIC_NETWORK;
 80314e4:	f88d 7034 	strb.w	r7, [sp, #52]	; 0x34
    LoRaMacMibSetRequestConfirm(&mibReq);
 80314e8:	f003 fc72 	bl	8034dd0 <LoRaMacMibSetRequestConfirm>
    mibReq.Type = MIB_NET_ID;
 80314ec:	2305      	movs	r3, #5
    LoRaMacMibSetRequestConfirm(&mibReq);
 80314ee:	a80c      	add	r0, sp, #48	; 0x30
    mibReq.Type = MIB_NET_ID;
 80314f0:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
    mibReq.Param.NetID = LORAWAN_NETWORK_ID;
 80314f4:	950d      	str	r5, [sp, #52]	; 0x34
    LoRaMacMibSetRequestConfirm(&mibReq);
 80314f6:	f003 fc6b 	bl	8034dd0 <LoRaMacMibSetRequestConfirm>
    mibReq.Type = MIB_REPEATER_SUPPORT;
 80314fa:	2310      	movs	r3, #16
    LoRaMacMibSetRequestConfirm( &mibReq );
 80314fc:	a80c      	add	r0, sp, #48	; 0x30
    mibReq.Type = MIB_REPEATER_SUPPORT;
 80314fe:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
    mibReq.Param.EnableRepeaterSupport = LORAWAN_REPEATER_SUPPORT;
 8031502:	f88d 5034 	strb.w	r5, [sp, #52]	; 0x34
    LoRaMacMibSetRequestConfirm( &mibReq );
 8031506:	f003 fc63 	bl	8034dd0 <LoRaMacMibSetRequestConfirm>
    mibReq.Type = MIB_ADR;
 803150a:	2304      	movs	r3, #4
 803150c:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
    LoRaMacMibSetRequestConfirm( &mibReq );
 8031510:	a80c      	add	r0, sp, #48	; 0x30
    mibReq.Param.AdrEnable = LmHandlerParams.AdrEnable;
 8031512:	f896 3032 	ldrb.w	r3, [r6, #50]	; 0x32
 8031516:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
    LoRaMacMibSetRequestConfirm( &mibReq );
 803151a:	f003 fc59 	bl	8034dd0 <LoRaMacMibSetRequestConfirm>
    phyParam = RegionGetPhyParam( LmHandlerParams.ActiveRegion, &getPhy );
 803151e:	a90a      	add	r1, sp, #40	; 0x28
 8031520:	f896 0030 	ldrb.w	r0, [r6, #48]	; 0x30
    getPhy.Attribute = PHY_DUTY_CYCLE;
 8031524:	f88d 4028 	strb.w	r4, [sp, #40]	; 0x28
    phyParam = RegionGetPhyParam( LmHandlerParams.ActiveRegion, &getPhy );
 8031528:	f005 f8f9 	bl	803671e <RegionGetPhyParam>
    LmHandlerParams.DutyCycleEnabled = (bool) phyParam.Value;
 803152c:	3800      	subs	r0, #0
 803152e:	bf18      	it	ne
 8031530:	2001      	movne	r0, #1
    mibReq.Type = MIB_SYSTEM_MAX_RX_ERROR;
 8031532:	2322      	movs	r3, #34	; 0x22
    LmHandlerParams.DutyCycleEnabled = (bool) phyParam.Value;
 8031534:	f886 0035 	strb.w	r0, [r6, #53]	; 0x35
    mibReq.Type = MIB_SYSTEM_MAX_RX_ERROR;
 8031538:	f88d 3054 	strb.w	r3, [sp, #84]	; 0x54
    if( LoRaMacMibSetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 803153c:	a815      	add	r0, sp, #84	; 0x54
    mibReq.Param.SystemMaxRxError = maxErrorInMs;
 803153e:	2314      	movs	r3, #20
 8031540:	9316      	str	r3, [sp, #88]	; 0x58
    if( LoRaMacMibSetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 8031542:	f003 fc45 	bl	8034dd0 <LoRaMacMibSetRequestConfirm>
    LoRaMacTestSetDutyCycleOn( LmHandlerParams.DutyCycleEnabled );
 8031546:	f896 0035 	ldrb.w	r0, [r6, #53]	; 0x35
 803154a:	f004 f9a5 	bl	8035898 <LoRaMacTestSetDutyCycleOn>
    return LORAMAC_HANDLER_SUCCESS;
 803154e:	4628      	mov	r0, r5
}
 8031550:	b01e      	add	sp, #120	; 0x78
 8031552:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8031556:	bf00      	nop
 8031558:	200047dc 	.word	0x200047dc
 803155c:	0803c181 	.word	0x0803c181
 8031560:	20003458 	.word	0x20003458
 8031564:	0803c1ca 	.word	0x0803c1ca
 8031568:	0803c204 	.word	0x0803c204
 803156c:	0803c23e 	.word	0x0803c23e
 8031570:	0803c264 	.word	0x0803c264

08031574 <LmHandlerProcess>:
{
 8031574:	b538      	push	{r3, r4, r5, lr}
    LoRaMacProcess( );
 8031576:	f002 fc8d 	bl	8033e94 <LoRaMacProcess>
    }
}

static void LmHandlerPackagesProcess( void )
{
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 803157a:	4d0c      	ldr	r5, [pc, #48]	; (80315ac <LmHandlerProcess+0x38>)
    LoRaMacProcess( );
 803157c:	2405      	movs	r4, #5
    {
        if( ( LmHandlerPackages[i] != NULL ) &&
 803157e:	f855 3b04 	ldr.w	r3, [r5], #4
 8031582:	b15b      	cbz	r3, 803159c <LmHandlerProcess+0x28>
 8031584:	691b      	ldr	r3, [r3, #16]
 8031586:	b14b      	cbz	r3, 803159c <LmHandlerProcess+0x28>
    if (( id < PKG_MAX_NUMBER ) && ( LmHandlerPackages[id]->IsInitialized != NULL ))
 8031588:	f855 3c04 	ldr.w	r3, [r5, #-4]
 803158c:	689b      	ldr	r3, [r3, #8]
 803158e:	b12b      	cbz	r3, 803159c <LmHandlerProcess+0x28>
        return LmHandlerPackages[id]->IsInitialized( );
 8031590:	4798      	blx	r3
            ( LmHandlerPackages[i]->Process != NULL ) &&
 8031592:	b118      	cbz	r0, 803159c <LmHandlerProcess+0x28>
            ( LmHandlerPackageIsInitialized( i ) != false ) )
        {
            LmHandlerPackages[i]->Process( );
 8031594:	f855 3c04 	ldr.w	r3, [r5, #-4]
 8031598:	691b      	ldr	r3, [r3, #16]
 803159a:	4798      	blx	r3
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 803159c:	3c01      	subs	r4, #1
 803159e:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
 80315a2:	d1ec      	bne.n	803157e <LmHandlerProcess+0xa>
}
 80315a4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    NvmDataMgmtStore( );
 80315a8:	f005 b8ac 	b.w	8036704 <NvmDataMgmtStore>
 80315ac:	200047f8 	.word	0x200047f8

080315b0 <LmHandlerJoinStatus>:
{
 80315b0:	b500      	push	{lr}
 80315b2:	b08b      	sub	sp, #44	; 0x2c
    mibReq.Type = MIB_NETWORK_ACTIVATION;
 80315b4:	2301      	movs	r3, #1
    status = LoRaMacMibGetRequestConfirm( &mibReq );
 80315b6:	a801      	add	r0, sp, #4
    mibReq.Type = MIB_NETWORK_ACTIVATION;
 80315b8:	f88d 3004 	strb.w	r3, [sp, #4]
    status = LoRaMacMibGetRequestConfirm( &mibReq );
 80315bc:	f003 fb4c 	bl	8034c58 <LoRaMacMibGetRequestConfirm>
    if( status == LORAMAC_STATUS_OK )
 80315c0:	b938      	cbnz	r0, 80315d2 <LmHandlerJoinStatus+0x22>
        if( mibReq.Param.NetworkActivation == ACTIVATION_TYPE_NONE )
 80315c2:	f89d 0008 	ldrb.w	r0, [sp, #8]
            return LORAMAC_HANDLER_RESET;
 80315c6:	3800      	subs	r0, #0
 80315c8:	bf18      	it	ne
 80315ca:	2001      	movne	r0, #1
}
 80315cc:	b00b      	add	sp, #44	; 0x2c
 80315ce:	f85d fb04 	ldr.w	pc, [sp], #4
        return LORAMAC_HANDLER_RESET;
 80315d2:	2000      	movs	r0, #0
 80315d4:	e7fa      	b.n	80315cc <LmHandlerJoinStatus+0x1c>
	...

080315d8 <LmHandlerRequestClass>:
{
 80315d8:	b530      	push	{r4, r5, lr}
 80315da:	b08d      	sub	sp, #52	; 0x34
 80315dc:	4605      	mov	r5, r0
    if (LoRaMacIsBusy() == true)
 80315de:	f002 fc4b 	bl	8033e78 <LoRaMacIsBusy>
 80315e2:	4604      	mov	r4, r0
 80315e4:	2800      	cmp	r0, #0
 80315e6:	d14a      	bne.n	803167e <LmHandlerRequestClass+0xa6>
    if (LmHandlerJoinStatus() != LORAMAC_HANDLER_SET)
 80315e8:	f7ff ffe2 	bl	80315b0 <LmHandlerJoinStatus>
 80315ec:	2801      	cmp	r0, #1
 80315ee:	d149      	bne.n	8031684 <LmHandlerRequestClass+0xac>
    if ( LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 80315f0:	a803      	add	r0, sp, #12
    mibReq.Type = MIB_DEVICE_CLASS;
 80315f2:	f88d 400c 	strb.w	r4, [sp, #12]
    if ( LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 80315f6:	f003 fb2f 	bl	8034c58 <LoRaMacMibGetRequestConfirm>
 80315fa:	b110      	cbz	r0, 8031602 <LmHandlerRequestClass+0x2a>
        switch( newClass )
 80315fc:	f04f 30ff 	mov.w	r0, #4294967295
 8031600:	e004      	b.n	803160c <LmHandlerRequestClass+0x34>
    currentClass = mibReq.Param.Class;
 8031602:	f89d 3010 	ldrb.w	r3, [sp, #16]
    if( currentClass != newClass )
 8031606:	42ab      	cmp	r3, r5
 8031608:	d102      	bne.n	8031610 <LmHandlerRequestClass+0x38>
    LmHandlerErrorStatus_t errorStatus = LORAMAC_HANDLER_SUCCESS;
 803160a:	2000      	movs	r0, #0
}
 803160c:	b00d      	add	sp, #52	; 0x34
 803160e:	bd30      	pop	{r4, r5, pc}
        switch( newClass )
 8031610:	2d01      	cmp	r5, #1
 8031612:	d0f3      	beq.n	80315fc <LmHandlerRequestClass+0x24>
 8031614:	2d02      	cmp	r5, #2
 8031616:	d01a      	beq.n	803164e <LmHandlerRequestClass+0x76>
 8031618:	2d00      	cmp	r5, #0
 803161a:	d1f7      	bne.n	803160c <LmHandlerRequestClass+0x34>
                if( currentClass != CLASS_A )
 803161c:	2b00      	cmp	r3, #0
 803161e:	d0f4      	beq.n	803160a <LmHandlerRequestClass+0x32>
                    if( LoRaMacMibSetRequestConfirm( &mibReq ) == LORAMAC_STATUS_OK )
 8031620:	a803      	add	r0, sp, #12
                    mibReq.Param.Class = newClass;
 8031622:	f88d 5010 	strb.w	r5, [sp, #16]
                    if( LoRaMacMibSetRequestConfirm( &mibReq ) == LORAMAC_STATUS_OK )
 8031626:	f003 fbd3 	bl	8034dd0 <LoRaMacMibSetRequestConfirm>
 803162a:	4602      	mov	r2, r0
 803162c:	2800      	cmp	r0, #0
 803162e:	d1e5      	bne.n	80315fc <LmHandlerRequestClass+0x24>
    }
}

static void DisplayClassUpdate(DeviceClass_t deviceClass)
{
    MW_LOG(TS_OFF, VLEVEL_M, "Switch to Class %c done\r\n", "ABC"[deviceClass]);
 8031630:	2341      	movs	r3, #65	; 0x41
 8031632:	9300      	str	r3, [sp, #0]
 8031634:	4601      	mov	r1, r0
 8031636:	4b15      	ldr	r3, [pc, #84]	; (803168c <LmHandlerRequestClass+0xb4>)
 8031638:	2002      	movs	r0, #2
 803163a:	f009 fb5d 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
                        if (LmHandlerCallbacks->OnClassChange != NULL)
 803163e:	4b14      	ldr	r3, [pc, #80]	; (8031690 <LmHandlerRequestClass+0xb8>)
 8031640:	699b      	ldr	r3, [r3, #24]
 8031642:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8031644:	2b00      	cmp	r3, #0
 8031646:	d0e0      	beq.n	803160a <LmHandlerRequestClass+0x32>
                            LmHandlerCallbacks->OnClassChange( newClass );
 8031648:	2000      	movs	r0, #0
 803164a:	4798      	blx	r3
 803164c:	e7dd      	b.n	803160a <LmHandlerRequestClass+0x32>
                if( currentClass != CLASS_A )
 803164e:	2b00      	cmp	r3, #0
 8031650:	d1d4      	bne.n	80315fc <LmHandlerRequestClass+0x24>
                    if (LoRaMacMibSetRequestConfirm( &mibReq ) == LORAMAC_STATUS_OK)
 8031652:	a803      	add	r0, sp, #12
                    mibReq.Param.Class = newClass;
 8031654:	f88d 5010 	strb.w	r5, [sp, #16]
                    if (LoRaMacMibSetRequestConfirm( &mibReq ) == LORAMAC_STATUS_OK)
 8031658:	f003 fbba 	bl	8034dd0 <LoRaMacMibSetRequestConfirm>
 803165c:	2800      	cmp	r0, #0
 803165e:	d1cd      	bne.n	80315fc <LmHandlerRequestClass+0x24>
    MW_LOG(TS_OFF, VLEVEL_M, "Switch to Class %c done\r\n", "ABC"[deviceClass]);
 8031660:	2343      	movs	r3, #67	; 0x43
 8031662:	9300      	str	r3, [sp, #0]
 8031664:	4602      	mov	r2, r0
 8031666:	4b09      	ldr	r3, [pc, #36]	; (803168c <LmHandlerRequestClass+0xb4>)
 8031668:	4601      	mov	r1, r0
 803166a:	4628      	mov	r0, r5
 803166c:	f009 fb44 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
                        if (LmHandlerCallbacks->OnClassChange != NULL)
 8031670:	4b07      	ldr	r3, [pc, #28]	; (8031690 <LmHandlerRequestClass+0xb8>)
 8031672:	699b      	ldr	r3, [r3, #24]
 8031674:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8031676:	2b00      	cmp	r3, #0
 8031678:	d0c7      	beq.n	803160a <LmHandlerRequestClass+0x32>
                            LmHandlerCallbacks->OnClassChange( newClass );
 803167a:	4628      	mov	r0, r5
 803167c:	e7e5      	b.n	803164a <LmHandlerRequestClass+0x72>
        return LORAMAC_HANDLER_BUSY_ERROR;
 803167e:	f06f 0001 	mvn.w	r0, #1
 8031682:	e7c3      	b.n	803160c <LmHandlerRequestClass+0x34>
        return LORAMAC_HANDLER_NO_NETWORK_JOINED;
 8031684:	f06f 0002 	mvn.w	r0, #2
 8031688:	e7c0      	b.n	803160c <LmHandlerRequestClass+0x34>
 803168a:	bf00      	nop
 803168c:	0803c27a 	.word	0x0803c27a
 8031690:	200047dc 	.word	0x200047dc

08031694 <LmHandlerJoin>:
{
 8031694:	b530      	push	{r4, r5, lr}
    if ( mode == ACTIVATION_TYPE_OTAA )
 8031696:	2802      	cmp	r0, #2
 8031698:	4b1f      	ldr	r3, [pc, #124]	; (8031718 <LmHandlerJoin+0x84>)
 803169a:	4c20      	ldr	r4, [pc, #128]	; (803171c <LmHandlerJoin+0x88>)
{
 803169c:	b08b      	sub	sp, #44	; 0x2c
 803169e:	f04f 0501 	mov.w	r5, #1
    if ( mode == ACTIVATION_TYPE_OTAA )
 80316a2:	d10d      	bne.n	80316c0 <LmHandlerJoin+0x2c>
        JoinParams.Mode = ACTIVATION_TYPE_OTAA;
 80316a4:	7698      	strb	r0, [r3, #26]
        LoRaMacStart();
 80316a6:	f003 fa77 	bl	8034b98 <LoRaMacStart>
        mlmeReq.Req.Join.Datarate = LmHandlerParams.TxDatarate;
 80316aa:	f894 3033 	ldrb.w	r3, [r4, #51]	; 0x33
        mlmeReq.Type = MLME_JOIN;
 80316ae:	f88d 5004 	strb.w	r5, [sp, #4]
        LoRaMacMlmeRequest( &mlmeReq );
 80316b2:	a801      	add	r0, sp, #4
        mlmeReq.Req.Join.Datarate = LmHandlerParams.TxDatarate;
 80316b4:	f88d 3008 	strb.w	r3, [sp, #8]
        LoRaMacMlmeRequest( &mlmeReq );
 80316b8:	f003 fe76 	bl	80353a8 <LoRaMacMlmeRequest>
}
 80316bc:	b00b      	add	sp, #44	; 0x2c
 80316be:	bd30      	pop	{r4, r5, pc}
        JoinParams.Datarate = LmHandlerParams.TxDatarate;
 80316c0:	f894 2033 	ldrb.w	r2, [r4, #51]	; 0x33
 80316c4:	761a      	strb	r2, [r3, #24]
        JoinParams.Status = LORAMAC_HANDLER_SUCCESS;
 80316c6:	2200      	movs	r2, #0
        JoinParams.Mode = ACTIVATION_TYPE_ABP;
 80316c8:	769d      	strb	r5, [r3, #26]
        JoinParams.Status = LORAMAC_HANDLER_SUCCESS;
 80316ca:	765a      	strb	r2, [r3, #25]
        if (CtxRestoreDone == false)
 80316cc:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
 80316d0:	b97b      	cbnz	r3, 80316f2 <LmHandlerJoin+0x5e>
            mibReq.Type = MIB_ABP_LORAWAN_VERSION;
 80316d2:	2327      	movs	r3, #39	; 0x27
 80316d4:	f88d 3004 	strb.w	r3, [sp, #4]
            LoRaMacMibSetRequestConfirm(&mibReq);
 80316d8:	a801      	add	r0, sp, #4
            mibReq.Param.AbpLrWanVersion.Value = ABP_ACTIVATION_LRWAN_VERSION;
 80316da:	4b11      	ldr	r3, [pc, #68]	; (8031720 <LmHandlerJoin+0x8c>)
 80316dc:	9302      	str	r3, [sp, #8]
            LoRaMacMibSetRequestConfirm(&mibReq);
 80316de:	f003 fb77 	bl	8034dd0 <LoRaMacMibSetRequestConfirm>
            SecureElementSetObjHandler(NWK_S_KEY, KMS_NWK_S_KEY_OBJECT_HANDLE);
 80316e2:	2110      	movs	r1, #16
 80316e4:	2002      	movs	r0, #2
 80316e6:	f007 f8e7 	bl	80388b8 <SecureElementSetObjHandler>
            SecureElementSetObjHandler(APP_S_KEY, KMS_APP_S_KEY_OBJECT_HANDLE);
 80316ea:	2111      	movs	r1, #17
 80316ec:	2003      	movs	r0, #3
 80316ee:	f007 f8e3 	bl	80388b8 <SecureElementSetObjHandler>
        LoRaMacStart();
 80316f2:	f003 fa51 	bl	8034b98 <LoRaMacStart>
        mibReq.Type = MIB_NETWORK_ACTIVATION;
 80316f6:	2301      	movs	r3, #1
        LoRaMacMibSetRequestConfirm( &mibReq );
 80316f8:	a801      	add	r0, sp, #4
        mibReq.Type = MIB_NETWORK_ACTIVATION;
 80316fa:	f88d 3004 	strb.w	r3, [sp, #4]
        mibReq.Param.NetworkActivation = ACTIVATION_TYPE_ABP;
 80316fe:	f88d 3008 	strb.w	r3, [sp, #8]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8031702:	f003 fb65 	bl	8034dd0 <LoRaMacMibSetRequestConfirm>
        LmHandlerCallbacks->OnJoinRequest( &JoinParams );
 8031706:	69a3      	ldr	r3, [r4, #24]
 8031708:	4806      	ldr	r0, [pc, #24]	; (8031724 <LmHandlerJoin+0x90>)
 803170a:	69db      	ldr	r3, [r3, #28]
 803170c:	4798      	blx	r3
        LmHandlerRequestClass(LmHandlerParams.DefaultClass);
 803170e:	f894 0031 	ldrb.w	r0, [r4, #49]	; 0x31
 8031712:	f7ff ff61 	bl	80315d8 <LmHandlerRequestClass>
}
 8031716:	e7d1      	b.n	80316bc <LmHandlerJoin+0x28>
 8031718:	20003458 	.word	0x20003458
 803171c:	200047dc 	.word	0x200047dc
 8031720:	01000300 	.word	0x01000300
 8031724:	20003470 	.word	0x20003470

08031728 <LmHandlerIsBusy>:
{
 8031728:	b510      	push	{r4, lr}
    if( LoRaMacIsBusy( ) == true )
 803172a:	f002 fba5 	bl	8033e78 <LoRaMacIsBusy>
 803172e:	b940      	cbnz	r0, 8031742 <LmHandlerIsBusy+0x1a>
    if( LmHandlerJoinStatus( ) != LORAMAC_HANDLER_SET )
 8031730:	f7ff ff3e 	bl	80315b0 <LmHandlerJoinStatus>
 8031734:	2801      	cmp	r0, #1
 8031736:	d005      	beq.n	8031744 <LmHandlerIsBusy+0x1c>
        LmHandlerJoin( JoinParams.Mode );
 8031738:	4b05      	ldr	r3, [pc, #20]	; (8031750 <LmHandlerIsBusy+0x28>)
 803173a:	7e98      	ldrb	r0, [r3, #26]
 803173c:	f7ff ffaa 	bl	8031694 <LmHandlerJoin>
        return true;
 8031740:	2001      	movs	r0, #1
}
 8031742:	bd10      	pop	{r4, pc}
    if( LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->IsRunning( ) == true )
 8031744:	4b03      	ldr	r3, [pc, #12]	; (8031754 <LmHandlerIsBusy+0x2c>)
 8031746:	69db      	ldr	r3, [r3, #28]
}
 8031748:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    if( LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->IsRunning( ) == true )
 803174c:	68db      	ldr	r3, [r3, #12]
 803174e:	4718      	bx	r3
 8031750:	20003458 	.word	0x20003458
 8031754:	200047dc 	.word	0x200047dc

08031758 <LmHandlerSend>:
{
 8031758:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 803175c:	b087      	sub	sp, #28
 803175e:	4604      	mov	r4, r0
 8031760:	460e      	mov	r6, r1
 8031762:	4617      	mov	r7, r2
 8031764:	4698      	mov	r8, r3
    if (LoRaMacIsBusy() == true)
 8031766:	f002 fb87 	bl	8033e78 <LoRaMacIsBusy>
 803176a:	2800      	cmp	r0, #0
 803176c:	d154      	bne.n	8031818 <LmHandlerSend+0xc0>
    if( LmHandlerJoinStatus( ) != LORAMAC_HANDLER_SET )
 803176e:	f7ff ff1f 	bl	80315b0 <LmHandlerJoinStatus>
 8031772:	2801      	cmp	r0, #1
 8031774:	d008      	beq.n	8031788 <LmHandlerSend+0x30>
        LmHandlerJoin(JoinParams.Mode);
 8031776:	4b2d      	ldr	r3, [pc, #180]	; (803182c <LmHandlerSend+0xd4>)
 8031778:	7e98      	ldrb	r0, [r3, #26]
 803177a:	f7ff ff8b 	bl	8031694 <LmHandlerJoin>
        return LORAMAC_HANDLER_NO_NETWORK_JOINED;
 803177e:	f06f 0002 	mvn.w	r0, #2
}
 8031782:	b007      	add	sp, #28
 8031784:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if( ( LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->IsRunning( ) == true ) && ( appData->Port != LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->Port ) && ( appData->Port != 0 ) )
 8031788:	f8df 90ac 	ldr.w	r9, [pc, #172]	; 8031838 <LmHandlerSend+0xe0>
 803178c:	f8d9 301c 	ldr.w	r3, [r9, #28]
 8031790:	68db      	ldr	r3, [r3, #12]
 8031792:	4798      	blx	r3
 8031794:	464d      	mov	r5, r9
 8031796:	b138      	cbz	r0, 80317a8 <LmHandlerSend+0x50>
 8031798:	f8d9 201c 	ldr.w	r2, [r9, #28]
 803179c:	7823      	ldrb	r3, [r4, #0]
 803179e:	7812      	ldrb	r2, [r2, #0]
 80317a0:	429a      	cmp	r2, r3
 80317a2:	d001      	beq.n	80317a8 <LmHandlerSend+0x50>
 80317a4:	2b00      	cmp	r3, #0
 80317a6:	d13a      	bne.n	803181e <LmHandlerSend+0xc6>
    mcpsReq.Req.Unconfirmed.Datarate = LmHandlerParams.TxDatarate;
 80317a8:	f895 3033 	ldrb.w	r3, [r5, #51]	; 0x33
    if( LoRaMacQueryTxPossible( appData->BufferSize, &txInfo ) != LORAMAC_STATUS_OK )
 80317ac:	7860      	ldrb	r0, [r4, #1]
    mcpsReq.Req.Unconfirmed.Datarate = LmHandlerParams.TxDatarate;
 80317ae:	f88d 3012 	strb.w	r3, [sp, #18]
    if( LoRaMacQueryTxPossible( appData->BufferSize, &txInfo ) != LORAMAC_STATUS_OK )
 80317b2:	4669      	mov	r1, sp
 80317b4:	f003 f9f8 	bl	8034ba8 <LoRaMacQueryTxPossible>
 80317b8:	b1d0      	cbz	r0, 80317f0 <LmHandlerSend+0x98>
        TxParams.MsgType = LORAMAC_HANDLER_UNCONFIRMED_MSG;
 80317ba:	2200      	movs	r2, #0
 80317bc:	70aa      	strb	r2, [r5, #2]
        mcpsReq.Type = MCPS_UNCONFIRMED;
 80317be:	f88d 2004 	strb.w	r2, [sp, #4]
        mcpsReq.Req.Unconfirmed.fBuffer = NULL;
 80317c2:	9203      	str	r2, [sp, #12]
        mcpsReq.Req.Unconfirmed.fBufferSize = 0;
 80317c4:	f8ad 2010 	strh.w	r2, [sp, #16]
    TxParams.AppData = *appData;
 80317c8:	e894 0003 	ldmia.w	r4, {r0, r1}
 80317cc:	4b18      	ldr	r3, [pc, #96]	; (8031830 <LmHandlerSend+0xd8>)
 80317ce:	e883 0003 	stmia.w	r3, {r0, r1}
    TxParams.Datarate = LmHandlerParams.TxDatarate;
 80317d2:	f895 3033 	ldrb.w	r3, [r5, #51]	; 0x33
 80317d6:	712b      	strb	r3, [r5, #4]
    status = LoRaMacMcpsRequest(&mcpsReq, allowDelayedTx);
 80317d8:	4641      	mov	r1, r8
 80317da:	a801      	add	r0, sp, #4
 80317dc:	f003 fed6 	bl	803558c <LoRaMacMcpsRequest>
    if (nextTxIn != NULL)
 80317e0:	b10f      	cbz	r7, 80317e6 <LmHandlerSend+0x8e>
        *nextTxIn = mcpsReq.ReqReturn.DutyCycleWaitTime;
 80317e2:	9b05      	ldr	r3, [sp, #20]
 80317e4:	603b      	str	r3, [r7, #0]
    switch (status)
 80317e6:	2811      	cmp	r0, #17
 80317e8:	d81c      	bhi.n	8031824 <LmHandlerSend+0xcc>
 80317ea:	4b12      	ldr	r3, [pc, #72]	; (8031834 <LmHandlerSend+0xdc>)
 80317ec:	5618      	ldrsb	r0, [r3, r0]
 80317ee:	e7c8      	b.n	8031782 <LmHandlerSend+0x2a>
        TxParams.MsgType = isTxConfirmed;
 80317f0:	70ae      	strb	r6, [r5, #2]
        mcpsReq.Req.Unconfirmed.fPort = appData->Port;
 80317f2:	7823      	ldrb	r3, [r4, #0]
 80317f4:	f88d 3008 	strb.w	r3, [sp, #8]
        mcpsReq.Req.Unconfirmed.fBufferSize = appData->BufferSize;
 80317f8:	7863      	ldrb	r3, [r4, #1]
 80317fa:	f8ad 3010 	strh.w	r3, [sp, #16]
        mcpsReq.Req.Unconfirmed.fBuffer = appData->Buffer;
 80317fe:	6863      	ldr	r3, [r4, #4]
 8031800:	9303      	str	r3, [sp, #12]
        if( isTxConfirmed == LORAMAC_HANDLER_UNCONFIRMED_MSG )
 8031802:	b916      	cbnz	r6, 803180a <LmHandlerSend+0xb2>
            mcpsReq.Type = MCPS_UNCONFIRMED;
 8031804:	f88d 6004 	strb.w	r6, [sp, #4]
 8031808:	e7de      	b.n	80317c8 <LmHandlerSend+0x70>
            mcpsReq.Type = MCPS_CONFIRMED;
 803180a:	2301      	movs	r3, #1
 803180c:	f88d 3004 	strb.w	r3, [sp, #4]
            mcpsReq.Req.Confirmed.NbTrials = 8;
 8031810:	2308      	movs	r3, #8
 8031812:	f88d 3013 	strb.w	r3, [sp, #19]
 8031816:	e7d7      	b.n	80317c8 <LmHandlerSend+0x70>
        return LORAMAC_HANDLER_BUSY_ERROR;
 8031818:	f06f 0001 	mvn.w	r0, #1
 803181c:	e7b1      	b.n	8031782 <LmHandlerSend+0x2a>
        return LORAMAC_HANDLER_COMPLIANCE_RUNNING;
 803181e:	f06f 0003 	mvn.w	r0, #3
 8031822:	e7ae      	b.n	8031782 <LmHandlerSend+0x2a>
 8031824:	f04f 30ff 	mov.w	r0, #4294967295
 8031828:	e7ab      	b.n	8031782 <LmHandlerSend+0x2a>
 803182a:	bf00      	nop
 803182c:	20003458 	.word	0x20003458
 8031830:	200047e8 	.word	0x200047e8
 8031834:	0803baa8 	.word	0x0803baa8
 8031838:	200047dc 	.word	0x200047dc

0803183c <MlmeIndication>:
{
 803183c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 803183e:	4604      	mov	r4, r0
    RxParams.IsMcpsIndication = 0;
 8031840:	4b14      	ldr	r3, [pc, #80]	; (8031894 <MlmeIndication+0x58>)
    RxParams.Status = mlmeIndication->Status;
 8031842:	7862      	ldrb	r2, [r4, #1]
 8031844:	775a      	strb	r2, [r3, #29]
    RxParams.IsMcpsIndication = 0;
 8031846:	2000      	movs	r0, #0
 8031848:	7718      	strb	r0, [r3, #28]
    RxParams.Rssi = RxStatus->Rssi;
 803184a:	880d      	ldrh	r5, [r1, #0]
 803184c:	77dd      	strb	r5, [r3, #31]
    RxParams.Snr = RxStatus->Snr;
 803184e:	788d      	ldrb	r5, [r1, #2]
 8031850:	f883 5020 	strb.w	r5, [r3, #32]
    RxParams.RxSlot = RxStatus->RxSlot;
 8031854:	78c9      	ldrb	r1, [r1, #3]
 8031856:	f883 1028 	strb.w	r1, [r3, #40]	; 0x28
    if( RxParams.Status != LORAMAC_EVENT_INFO_STATUS_BEACON_LOCKED )
 803185a:	2a0e      	cmp	r2, #14
 803185c:	d005      	beq.n	803186a <MlmeIndication+0x2e>
        LmHandlerCallbacks->OnRxData( NULL, &RxParams );
 803185e:	4a0e      	ldr	r2, [pc, #56]	; (8031898 <MlmeIndication+0x5c>)
 8031860:	6992      	ldr	r2, [r2, #24]
 8031862:	f103 011c 	add.w	r1, r3, #28
 8031866:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8031868:	4790      	blx	r2
    switch( mlmeIndication->MlmeIndication )
 803186a:	7823      	ldrb	r3, [r4, #0]
 803186c:	2b07      	cmp	r3, #7
 803186e:	d10e      	bne.n	803188e <MlmeIndication+0x52>
            LmHandlerAppData_t appData =
 8031870:	2300      	movs	r3, #0
 8031872:	f8ad 3000 	strh.w	r3, [sp]
 8031876:	9301      	str	r3, [sp, #4]
            if( LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->IsRunning( ) == false )
 8031878:	4b07      	ldr	r3, [pc, #28]	; (8031898 <MlmeIndication+0x5c>)
 803187a:	69db      	ldr	r3, [r3, #28]
 803187c:	68db      	ldr	r3, [r3, #12]
 803187e:	4798      	blx	r3
 8031880:	4602      	mov	r2, r0
 8031882:	b920      	cbnz	r0, 803188e <MlmeIndication+0x52>
                LmHandlerSend( &appData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true );
 8031884:	4601      	mov	r1, r0
 8031886:	2301      	movs	r3, #1
 8031888:	4668      	mov	r0, sp
 803188a:	f7ff ff65 	bl	8031758 <LmHandlerSend>
}
 803188e:	b003      	add	sp, #12
 8031890:	bd30      	pop	{r4, r5, pc}
 8031892:	bf00      	nop
 8031894:	20003458 	.word	0x20003458
 8031898:	200047dc 	.word	0x200047dc

0803189c <LmHandlerGetCurrentClass>:
{
 803189c:	b510      	push	{r4, lr}
    if (deviceClass == NULL)
 803189e:	4604      	mov	r4, r0
{
 80318a0:	b08a      	sub	sp, #40	; 0x28
    if (deviceClass == NULL)
 80318a2:	b918      	cbnz	r0, 80318ac <LmHandlerGetCurrentClass+0x10>
        return LORAMAC_HANDLER_ERROR;
 80318a4:	f04f 30ff 	mov.w	r0, #4294967295
}
 80318a8:	b00a      	add	sp, #40	; 0x28
 80318aa:	bd10      	pop	{r4, pc}
    mibReq.Type = MIB_DEVICE_CLASS;
 80318ac:	2300      	movs	r3, #0
    if (LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK)
 80318ae:	a801      	add	r0, sp, #4
    mibReq.Type = MIB_DEVICE_CLASS;
 80318b0:	f88d 3004 	strb.w	r3, [sp, #4]
    if (LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK)
 80318b4:	f003 f9d0 	bl	8034c58 <LoRaMacMibGetRequestConfirm>
 80318b8:	2800      	cmp	r0, #0
 80318ba:	d1f3      	bne.n	80318a4 <LmHandlerGetCurrentClass+0x8>
    *deviceClass = mibReq.Param.Class;
 80318bc:	f89d 3008 	ldrb.w	r3, [sp, #8]
 80318c0:	7023      	strb	r3, [r4, #0]
    return LORAMAC_HANDLER_SUCCESS;
 80318c2:	e7f1      	b.n	80318a8 <LmHandlerGetCurrentClass+0xc>

080318c4 <McpsIndication>:
{
 80318c4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80318c6:	b087      	sub	sp, #28
    DeviceClass_t deviceClass = CLASS_A;
 80318c8:	2300      	movs	r3, #0
 80318ca:	f88d 3007 	strb.w	r3, [sp, #7]
    RxParams.IsMcpsIndication = 1;
 80318ce:	4b2c      	ldr	r3, [pc, #176]	; (8031980 <McpsIndication+0xbc>)
 80318d0:	2201      	movs	r2, #1
 80318d2:	771a      	strb	r2, [r3, #28]
    RxParams.Status = mcpsIndication->Status;
 80318d4:	7842      	ldrb	r2, [r0, #1]
 80318d6:	775a      	strb	r2, [r3, #29]
{
 80318d8:	4604      	mov	r4, r0
    if( RxParams.Status != LORAMAC_EVENT_INFO_STATUS_OK )
 80318da:	2a00      	cmp	r2, #0
 80318dc:	d146      	bne.n	803196c <McpsIndication+0xa8>
    RxParams.Datarate = mcpsIndication->RxDatarate;
 80318de:	7902      	ldrb	r2, [r0, #4]
 80318e0:	779a      	strb	r2, [r3, #30]
    RxParams.Rssi = RxStatus->Rssi;
 80318e2:	880a      	ldrh	r2, [r1, #0]
 80318e4:	77da      	strb	r2, [r3, #31]
    RxParams.Snr = RxStatus->Snr;
 80318e6:	788a      	ldrb	r2, [r1, #2]
 80318e8:	f883 2020 	strb.w	r2, [r3, #32]
    RxParams.RxSlot = RxStatus->RxSlot;
 80318ec:	78ca      	ldrb	r2, [r1, #3]
 80318ee:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
    RxParams.DownlinkCounter = mcpsIndication->DownLinkCounter;
 80318f2:	6902      	ldr	r2, [r0, #16]
 80318f4:	625a      	str	r2, [r3, #36]	; 0x24
    appData.Port = mcpsIndication->Port;
 80318f6:	78c2      	ldrb	r2, [r0, #3]
    LmHandlerCallbacks->OnRxData(&appData, &RxParams);
 80318f8:	4e22      	ldr	r6, [pc, #136]	; (8031984 <McpsIndication+0xc0>)
    appData.Port = mcpsIndication->Port;
 80318fa:	f88d 2008 	strb.w	r2, [sp, #8]
    appData.BufferSize = mcpsIndication->BufferSize;
 80318fe:	7b02      	ldrb	r2, [r0, #12]
 8031900:	f88d 2009 	strb.w	r2, [sp, #9]
    appData.Buffer = mcpsIndication->Buffer;
 8031904:	6882      	ldr	r2, [r0, #8]
 8031906:	9203      	str	r2, [sp, #12]
    LmHandlerCallbacks->OnRxData(&appData, &RxParams);
 8031908:	69b2      	ldr	r2, [r6, #24]
 803190a:	f103 011c 	add.w	r1, r3, #28
 803190e:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8031910:	a802      	add	r0, sp, #8
 8031912:	4790      	blx	r2
    if ((LmHandlerCallbacks->OnSysTimeUpdate != NULL) && (mcpsIndication->DeviceTimeAnsReceived == true))
 8031914:	69b3      	ldr	r3, [r6, #24]
 8031916:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8031918:	b113      	cbz	r3, 8031920 <McpsIndication+0x5c>
 803191a:	7e22      	ldrb	r2, [r4, #24]
 803191c:	b102      	cbz	r2, 8031920 <McpsIndication+0x5c>
        LmHandlerCallbacks->OnSysTimeUpdate( );
 803191e:	4798      	blx	r3
 8031920:	4f19      	ldr	r7, [pc, #100]	; (8031988 <McpsIndication+0xc4>)
{
 8031922:	2500      	movs	r5, #0
        if( LmHandlerPackages[i] != NULL )
 8031924:	f857 3b04 	ldr.w	r3, [r7], #4
 8031928:	b153      	cbz	r3, 8031940 <McpsIndication+0x7c>
                    if( ( LmHandlerPackages[i]->OnMcpsIndicationProcess != NULL ) &&
 803192a:	69da      	ldr	r2, [r3, #28]
 803192c:	b142      	cbz	r2, 8031940 <McpsIndication+0x7c>
 803192e:	781a      	ldrb	r2, [r3, #0]
 8031930:	78e3      	ldrb	r3, [r4, #3]
 8031932:	429a      	cmp	r2, r3
 8031934:	d11c      	bne.n	8031970 <McpsIndication+0xac>
                        LmHandlerPackages[i]->OnMcpsIndicationProcess( ( McpsIndication_t* )params );
 8031936:	f857 3c04 	ldr.w	r3, [r7, #-4]
 803193a:	4620      	mov	r0, r4
 803193c:	69db      	ldr	r3, [r3, #28]
 803193e:	4798      	blx	r3
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 8031940:	1c6b      	adds	r3, r5, #1
 8031942:	b2da      	uxtb	r2, r3
 8031944:	2a05      	cmp	r2, #5
 8031946:	b25d      	sxtb	r5, r3
 8031948:	d1ec      	bne.n	8031924 <McpsIndication+0x60>
    LmHandlerGetCurrentClass(&deviceClass);
 803194a:	f10d 0007 	add.w	r0, sp, #7
 803194e:	f7ff ffa5 	bl	803189c <LmHandlerGetCurrentClass>
    if ((mcpsIndication->FramePending == true) && (deviceClass == CLASS_A))
 8031952:	7963      	ldrb	r3, [r4, #5]
 8031954:	2b01      	cmp	r3, #1
 8031956:	d109      	bne.n	803196c <McpsIndication+0xa8>
 8031958:	f89d 2007 	ldrb.w	r2, [sp, #7]
 803195c:	b932      	cbnz	r2, 803196c <McpsIndication+0xa8>
        LmHandlerSend(&appData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true);
 803195e:	4611      	mov	r1, r2
 8031960:	a804      	add	r0, sp, #16
        LmHandlerAppData_t appData =
 8031962:	f8ad 2010 	strh.w	r2, [sp, #16]
 8031966:	9205      	str	r2, [sp, #20]
        LmHandlerSend(&appData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true);
 8031968:	f7ff fef6 	bl	8031758 <LmHandlerSend>
}
 803196c:	b007      	add	sp, #28
 803196e:	bdf0      	pop	{r4, r5, r6, r7, pc}
                        ( ( LmHandlerPackages[i]->Port == ((McpsIndication_t* )params)->Port ) ||
 8031970:	2d00      	cmp	r5, #0
 8031972:	d1e5      	bne.n	8031940 <McpsIndication+0x7c>
                          ( ( i == PACKAGE_ID_COMPLIANCE ) && ( LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->IsRunning() ))))
 8031974:	69f3      	ldr	r3, [r6, #28]
 8031976:	68db      	ldr	r3, [r3, #12]
 8031978:	4798      	blx	r3
 803197a:	2800      	cmp	r0, #0
 803197c:	d1db      	bne.n	8031936 <McpsIndication+0x72>
 803197e:	e7df      	b.n	8031940 <McpsIndication+0x7c>
 8031980:	20003458 	.word	0x20003458
 8031984:	200047dc 	.word	0x200047dc
 8031988:	200047f8 	.word	0x200047f8

0803198c <LmHandlerGetTxDatarate>:
{
 803198c:	b510      	push	{r4, lr}
    if (txDatarate == NULL)
 803198e:	4604      	mov	r4, r0
{
 8031990:	b08a      	sub	sp, #40	; 0x28
    if (txDatarate == NULL)
 8031992:	b918      	cbnz	r0, 803199c <LmHandlerGetTxDatarate+0x10>
        return LORAMAC_HANDLER_ERROR;
 8031994:	f04f 30ff 	mov.w	r0, #4294967295
}
 8031998:	b00a      	add	sp, #40	; 0x28
 803199a:	bd10      	pop	{r4, pc}
    mibGet.Type = MIB_CHANNELS_DATARATE;
 803199c:	231f      	movs	r3, #31
    if (LoRaMacMibGetRequestConfirm( &mibGet ) != LORAMAC_STATUS_OK)
 803199e:	a801      	add	r0, sp, #4
    mibGet.Type = MIB_CHANNELS_DATARATE;
 80319a0:	f88d 3004 	strb.w	r3, [sp, #4]
    if (LoRaMacMibGetRequestConfirm( &mibGet ) != LORAMAC_STATUS_OK)
 80319a4:	f003 f958 	bl	8034c58 <LoRaMacMibGetRequestConfirm>
 80319a8:	2800      	cmp	r0, #0
 80319aa:	d1f3      	bne.n	8031994 <LmHandlerGetTxDatarate+0x8>
    LmHandlerParams.TxDatarate = *txDatarate;
 80319ac:	4a03      	ldr	r2, [pc, #12]	; (80319bc <LmHandlerGetTxDatarate+0x30>)
    *txDatarate = mibGet.Param.ChannelsDatarate;
 80319ae:	f99d 3008 	ldrsb.w	r3, [sp, #8]
 80319b2:	7023      	strb	r3, [r4, #0]
    LmHandlerParams.TxDatarate = *txDatarate;
 80319b4:	f882 3033 	strb.w	r3, [r2, #51]	; 0x33
    return LORAMAC_HANDLER_SUCCESS;
 80319b8:	e7ee      	b.n	8031998 <LmHandlerGetTxDatarate+0xc>
 80319ba:	bf00      	nop
 80319bc:	200047dc 	.word	0x200047dc

080319c0 <MlmeConfirm>:
{
 80319c0:	b5f0      	push	{r4, r5, r6, r7, lr}
    TxParams.IsMcpsConfirm = 0;
 80319c2:	4e23      	ldr	r6, [pc, #140]	; (8031a50 <MlmeConfirm+0x90>)
    TxParams.Status = mlmeConfirm->Status;
 80319c4:	7843      	ldrb	r3, [r0, #1]
 80319c6:	7073      	strb	r3, [r6, #1]
    LmHandlerCallbacks->OnTxData( &TxParams );
 80319c8:	69b3      	ldr	r3, [r6, #24]
    TxParams.IsMcpsConfirm = 0;
 80319ca:	2500      	movs	r5, #0
    LmHandlerCallbacks->OnTxData( &TxParams );
 80319cc:	6a1b      	ldr	r3, [r3, #32]
    TxParams.IsMcpsConfirm = 0;
 80319ce:	7035      	strb	r5, [r6, #0]
{
 80319d0:	b08b      	sub	sp, #44	; 0x2c
 80319d2:	4604      	mov	r4, r0
    LmHandlerCallbacks->OnTxData( &TxParams );
 80319d4:	4630      	mov	r0, r6
 80319d6:	4798      	blx	r3
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 80319d8:	f106 071c 	add.w	r7, r6, #28
        if( LmHandlerPackages[i] != NULL )
 80319dc:	f857 3b04 	ldr.w	r3, [r7], #4
 80319e0:	b11b      	cbz	r3, 80319ea <MlmeConfirm+0x2a>
                    if( LmHandlerPackages[i]->OnMlmeConfirmProcess != NULL )
 80319e2:	6a1b      	ldr	r3, [r3, #32]
 80319e4:	b10b      	cbz	r3, 80319ea <MlmeConfirm+0x2a>
                        LmHandlerPackages[i]->OnMlmeConfirmProcess( ( MlmeConfirm_t* )params );
 80319e6:	4620      	mov	r0, r4
 80319e8:	4798      	blx	r3
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 80319ea:	3501      	adds	r5, #1
 80319ec:	b2eb      	uxtb	r3, r5
 80319ee:	2b05      	cmp	r3, #5
 80319f0:	b26d      	sxtb	r5, r5
 80319f2:	d1f3      	bne.n	80319dc <MlmeConfirm+0x1c>
    switch( mlmeConfirm->MlmeRequest )
 80319f4:	7823      	ldrb	r3, [r4, #0]
 80319f6:	2b01      	cmp	r3, #1
 80319f8:	d003      	beq.n	8031a02 <MlmeConfirm+0x42>
 80319fa:	2b04      	cmp	r3, #4
 80319fc:	d01d      	beq.n	8031a3a <MlmeConfirm+0x7a>
}
 80319fe:	b00b      	add	sp, #44	; 0x2c
 8031a00:	bdf0      	pop	{r4, r5, r6, r7, pc}
            CommissioningParams.DevAddr = mibReq.Param.DevAddr;
 8031a02:	4d14      	ldr	r5, [pc, #80]	; (8031a54 <MlmeConfirm+0x94>)
            mibReq.Type = MIB_DEV_ADDR;
 8031a04:	2306      	movs	r3, #6
            LoRaMacMibGetRequestConfirm( &mibReq );
 8031a06:	a801      	add	r0, sp, #4
            mibReq.Type = MIB_DEV_ADDR;
 8031a08:	f88d 3004 	strb.w	r3, [sp, #4]
            LoRaMacMibGetRequestConfirm( &mibReq );
 8031a0c:	f003 f924 	bl	8034c58 <LoRaMacMibGetRequestConfirm>
            CommissioningParams.DevAddr = mibReq.Param.DevAddr;
 8031a10:	9b02      	ldr	r3, [sp, #8]
 8031a12:	616b      	str	r3, [r5, #20]
            LmHandlerGetTxDatarate( &JoinParams.Datarate );
 8031a14:	f105 0018 	add.w	r0, r5, #24
 8031a18:	f7ff ffb8 	bl	803198c <LmHandlerGetTxDatarate>
            if( mlmeConfirm->Status == LORAMAC_EVENT_INFO_STATUS_OK )
 8031a1c:	7863      	ldrb	r3, [r4, #1]
 8031a1e:	b94b      	cbnz	r3, 8031a34 <MlmeConfirm+0x74>
                LmHandlerRequestClass(LmHandlerParams.DefaultClass);
 8031a20:	f896 0031 	ldrb.w	r0, [r6, #49]	; 0x31
                JoinParams.Status = LORAMAC_HANDLER_SUCCESS;
 8031a24:	766b      	strb	r3, [r5, #25]
                LmHandlerRequestClass(LmHandlerParams.DefaultClass);
 8031a26:	f7ff fdd7 	bl	80315d8 <LmHandlerRequestClass>
            LmHandlerCallbacks->OnJoinRequest( &JoinParams );
 8031a2a:	69b3      	ldr	r3, [r6, #24]
 8031a2c:	480a      	ldr	r0, [pc, #40]	; (8031a58 <MlmeConfirm+0x98>)
 8031a2e:	69db      	ldr	r3, [r3, #28]
 8031a30:	4798      	blx	r3
}
 8031a32:	e7e4      	b.n	80319fe <MlmeConfirm+0x3e>
                JoinParams.Status = LORAMAC_HANDLER_ERROR;
 8031a34:	23ff      	movs	r3, #255	; 0xff
 8031a36:	766b      	strb	r3, [r5, #25]
 8031a38:	e7f7      	b.n	8031a2a <MlmeConfirm+0x6a>
            RxParams.LinkCheck = true;
 8031a3a:	4b06      	ldr	r3, [pc, #24]	; (8031a54 <MlmeConfirm+0x94>)
 8031a3c:	2201      	movs	r2, #1
 8031a3e:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
            RxParams.DemodMargin = mlmeConfirm->DemodMargin;
 8031a42:	7a22      	ldrb	r2, [r4, #8]
 8031a44:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
            RxParams.NbGateways = mlmeConfirm->NbGateways;
 8031a48:	7a62      	ldrb	r2, [r4, #9]
 8031a4a:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
}
 8031a4e:	e7d6      	b.n	80319fe <MlmeConfirm+0x3e>
 8031a50:	200047dc 	.word	0x200047dc
 8031a54:	20003458 	.word	0x20003458
 8031a58:	20003470 	.word	0x20003470

08031a5c <LmHandlerPackageRegister>:
{
 8031a5c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    LmhPackage_t *package = NULL;
 8031a5e:	2300      	movs	r3, #0
{
 8031a60:	460d      	mov	r5, r1
    LmhPackage_t *package = NULL;
 8031a62:	9301      	str	r3, [sp, #4]
    switch( id )
 8031a64:	4604      	mov	r4, r0
 8031a66:	b9c8      	cbnz	r0, 8031a9c <LmHandlerPackageRegister+0x40>
            package = LmhpCompliancePackageFactory( );
 8031a68:	f000 fb94 	bl	8032194 <LmhpCompliancePackageFactory>
 8031a6c:	9001      	str	r0, [sp, #4]
    if( package != NULL )
 8031a6e:	9b01      	ldr	r3, [sp, #4]
 8031a70:	b1c3      	cbz	r3, 8031aa4 <LmHandlerPackageRegister+0x48>
        LmHandlerPackages[id]->OnJoinRequest = LmHandlerJoin;
 8031a72:	4a0e      	ldr	r2, [pc, #56]	; (8031aac <LmHandlerPackageRegister+0x50>)
        LmHandlerPackages[id] = package;
 8031a74:	490e      	ldr	r1, [pc, #56]	; (8031ab0 <LmHandlerPackageRegister+0x54>)
        LmHandlerPackages[id]->OnJoinRequest = LmHandlerJoin;
 8031a76:	625a      	str	r2, [r3, #36]	; 0x24
        LmHandlerPackages[id]->OnSendRequest = LmHandlerSend;
 8031a78:	4a0e      	ldr	r2, [pc, #56]	; (8031ab4 <LmHandlerPackageRegister+0x58>)
 8031a7a:	629a      	str	r2, [r3, #40]	; 0x28
        LmHandlerPackages[id]->OnDeviceTimeRequest = LmHandlerDeviceTimeReq;
 8031a7c:	4a0e      	ldr	r2, [pc, #56]	; (8031ab8 <LmHandlerPackageRegister+0x5c>)
 8031a7e:	62da      	str	r2, [r3, #44]	; 0x2c
        LmHandlerPackages[id]->OnPackageProcessEvent = LmHandlerCallbacks->OnMacProcess;
 8031a80:	698a      	ldr	r2, [r1, #24]
        LmHandlerPackages[id] = package;
 8031a82:	eb01 0484 	add.w	r4, r1, r4, lsl #2
        LmHandlerPackages[id]->OnPackageProcessEvent = LmHandlerCallbacks->OnMacProcess;
 8031a86:	6912      	ldr	r2, [r2, #16]
 8031a88:	615a      	str	r2, [r3, #20]
        LmHandlerPackages[id] = package;
 8031a8a:	61e3      	str	r3, [r4, #28]
        LmHandlerPackages[id]->Init( params, AppData.Buffer, AppData.BufferSize );
 8031a8c:	4628      	mov	r0, r5
 8031a8e:	685b      	ldr	r3, [r3, #4]
 8031a90:	22f2      	movs	r2, #242	; 0xf2
 8031a92:	3165      	adds	r1, #101	; 0x65
 8031a94:	4798      	blx	r3
        return LORAMAC_HANDLER_SUCCESS;
 8031a96:	2000      	movs	r0, #0
}
 8031a98:	b003      	add	sp, #12
 8031a9a:	bd30      	pop	{r4, r5, pc}
            LmhpPackagesRegister(id, &package);
 8031a9c:	a901      	add	r1, sp, #4
 8031a9e:	f000 ff2b 	bl	80328f8 <LmhpPackagesRegister>
            break;
 8031aa2:	e7e4      	b.n	8031a6e <LmHandlerPackageRegister+0x12>
        return LORAMAC_HANDLER_ERROR;
 8031aa4:	f04f 30ff 	mov.w	r0, #4294967295
 8031aa8:	e7f6      	b.n	8031a98 <LmHandlerPackageRegister+0x3c>
 8031aaa:	bf00      	nop
 8031aac:	08031695 	.word	0x08031695
 8031ab0:	200047dc 	.word	0x200047dc
 8031ab4:	08031759 	.word	0x08031759
 8031ab8:	0803135d 	.word	0x0803135d

08031abc <LmHandlerInit>:
{
 8031abc:	b508      	push	{r3, lr}
    LmHandlerCallbacks = handlerCallbacks;
 8031abe:	4b11      	ldr	r3, [pc, #68]	; (8031b04 <LmHandlerInit+0x48>)
    LoRaMacPrimitives.MacMcpsConfirm = McpsConfirm;
 8031ac0:	4a11      	ldr	r2, [pc, #68]	; (8031b08 <LmHandlerInit+0x4c>)
 8031ac2:	655a      	str	r2, [r3, #84]	; 0x54
    LoRaMacPrimitives.MacMcpsIndication = McpsIndication;
 8031ac4:	4a11      	ldr	r2, [pc, #68]	; (8031b0c <LmHandlerInit+0x50>)
 8031ac6:	659a      	str	r2, [r3, #88]	; 0x58
    LoRaMacPrimitives.MacMlmeConfirm = MlmeConfirm;
 8031ac8:	4a11      	ldr	r2, [pc, #68]	; (8031b10 <LmHandlerInit+0x54>)
 8031aca:	65da      	str	r2, [r3, #92]	; 0x5c
    LoRaMacPrimitives.MacMlmeIndication = MlmeIndication;
 8031acc:	4a11      	ldr	r2, [pc, #68]	; (8031b14 <LmHandlerInit+0x58>)
 8031ace:	661a      	str	r2, [r3, #96]	; 0x60
    LoRaMacCallbacks.GetBatteryLevel = LmHandlerCallbacks->GetBatteryLevel;
 8031ad0:	6802      	ldr	r2, [r0, #0]
 8031ad2:	641a      	str	r2, [r3, #64]	; 0x40
    LoRaMacCallbacks.GetTemperatureLevel = LmHandlerCallbacks->GetTemperature;
 8031ad4:	6842      	ldr	r2, [r0, #4]
 8031ad6:	645a      	str	r2, [r3, #68]	; 0x44
    LoRaMacCallbacks.GetUniqueId = LmHandlerCallbacks->GetUniqueId;
 8031ad8:	6882      	ldr	r2, [r0, #8]
 8031ada:	649a      	str	r2, [r3, #72]	; 0x48
    LoRaMacCallbacks.NvmDataChange  = NvmDataMgmtEvent;
 8031adc:	4a0e      	ldr	r2, [pc, #56]	; (8031b18 <LmHandlerInit+0x5c>)
    LmHandlerCallbacks = handlerCallbacks;
 8031ade:	6198      	str	r0, [r3, #24]
    LoRaMacCallbacks.NvmDataChange  = NvmDataMgmtEvent;
 8031ae0:	64da      	str	r2, [r3, #76]	; 0x4c
    if (LmHandlerPackageRegister(PACKAGE_ID_COMPLIANCE, &LmhpComplianceParams) != LORAMAC_HANDLER_SUCCESS)
 8031ae2:	490e      	ldr	r1, [pc, #56]	; (8031b1c <LmHandlerInit+0x60>)
    LoRaMacCallbacks.MacProcessNotify = LmHandlerCallbacks->OnMacProcess;
 8031ae4:	6902      	ldr	r2, [r0, #16]
 8031ae6:	651a      	str	r2, [r3, #80]	; 0x50
    if (LmHandlerPackageRegister(PACKAGE_ID_COMPLIANCE, &LmhpComplianceParams) != LORAMAC_HANDLER_SUCCESS)
 8031ae8:	2000      	movs	r0, #0
 8031aea:	f7ff ffb7 	bl	8031a5c <LmHandlerPackageRegister>
 8031aee:	b930      	cbnz	r0, 8031afe <LmHandlerInit+0x42>
    if (LmhpPackagesRegistrationInit() != LORAMAC_HANDLER_SUCCESS)
 8031af0:	f000 fee2 	bl	80328b8 <LmhpPackagesRegistrationInit>
 8031af4:	3800      	subs	r0, #0
 8031af6:	bf18      	it	ne
 8031af8:	2001      	movne	r0, #1
 8031afa:	4240      	negs	r0, r0
}
 8031afc:	bd08      	pop	{r3, pc}
        return LORAMAC_HANDLER_ERROR;
 8031afe:	f04f 30ff 	mov.w	r0, #4294967295
 8031b02:	e7fb      	b.n	8031afc <LmHandlerInit+0x40>
 8031b04:	200047dc 	.word	0x200047dc
 8031b08:	08031379 	.word	0x08031379
 8031b0c:	080318c5 	.word	0x080318c5
 8031b10:	080319c1 	.word	0x080319c1
 8031b14:	0803183d 	.word	0x0803183d
 8031b18:	08036703 	.word	0x08036703
 8031b1c:	20003484 	.word	0x20003484

08031b20 <LmHandlerGetDutyCycleEnable>:
    if (dutyCycleEnable == NULL)
 8031b20:	b128      	cbz	r0, 8031b2e <LmHandlerGetDutyCycleEnable+0xe>
    *dutyCycleEnable = LmHandlerParams.DutyCycleEnabled;
 8031b22:	4b04      	ldr	r3, [pc, #16]	; (8031b34 <LmHandlerGetDutyCycleEnable+0x14>)
 8031b24:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8031b28:	7003      	strb	r3, [r0, #0]
    return LORAMAC_HANDLER_SUCCESS;
 8031b2a:	2000      	movs	r0, #0
 8031b2c:	4770      	bx	lr
        return LORAMAC_HANDLER_ERROR;
 8031b2e:	f04f 30ff 	mov.w	r0, #4294967295
}
 8031b32:	4770      	bx	lr
 8031b34:	200047dc 	.word	0x200047dc

08031b38 <LmHandlerSetDutyCycleEnable>:
{
 8031b38:	b508      	push	{r3, lr}
    LmHandlerParams.DutyCycleEnabled = dutyCycleEnable;
 8031b3a:	4b03      	ldr	r3, [pc, #12]	; (8031b48 <LmHandlerSetDutyCycleEnable+0x10>)
 8031b3c:	f883 0035 	strb.w	r0, [r3, #53]	; 0x35
    LoRaMacTestSetDutyCycleOn(dutyCycleEnable);
 8031b40:	f003 feaa 	bl	8035898 <LoRaMacTestSetDutyCycleOn>
}
 8031b44:	2000      	movs	r0, #0
 8031b46:	bd08      	pop	{r3, pc}
 8031b48:	200047dc 	.word	0x200047dc

08031b4c <LmhpClockSyncIsInitialized>:
}

static bool LmhpClockSyncIsInitialized( void )
{
    return LmhpClockSyncState.Initialized;
}
 8031b4c:	4b01      	ldr	r3, [pc, #4]	; (8031b54 <LmhpClockSyncIsInitialized+0x8>)
 8031b4e:	7818      	ldrb	r0, [r3, #0]
 8031b50:	4770      	bx	lr
 8031b52:	bf00      	nop
 8031b54:	20004934 	.word	0x20004934

08031b58 <LmhpClockSyncIsRunning>:

static bool LmhpClockSyncIsRunning( void )
{
    if( LmhpClockSyncState.Initialized == false )
 8031b58:	4b02      	ldr	r3, [pc, #8]	; (8031b64 <LmhpClockSyncIsRunning+0xc>)
 8031b5a:	7818      	ldrb	r0, [r3, #0]
 8031b5c:	b100      	cbz	r0, 8031b60 <LmhpClockSyncIsRunning+0x8>
    {
        return false;
    }

    return LmhpClockSyncState.IsRunning;
 8031b5e:	7858      	ldrb	r0, [r3, #1]
}
 8031b60:	4770      	bx	lr
 8031b62:	bf00      	nop
 8031b64:	20004934 	.word	0x20004934

08031b68 <OnPeriodicTimeStartTimer>:

    return status;
}

static void OnPeriodicTimeStartTimer(void *context)
{
 8031b68:	b510      	push	{r4, lr}
  LmhpClockSyncState.NbTransmissions = 1;
 8031b6a:	4805      	ldr	r0, [pc, #20]	; (8031b80 <OnPeriodicTimeStartTimer+0x18>)
 8031b6c:	2301      	movs	r3, #1
 8031b6e:	7343      	strb	r3, [r0, #13]
  TimerStart(&PeriodicTimeStartTimer);
 8031b70:	3010      	adds	r0, #16
 8031b72:	f009 fc33 	bl	803b3dc <UTIL_TIMER_Start>
  LmhpClockSyncPackage.OnPackageProcessEvent();
 8031b76:	4b03      	ldr	r3, [pc, #12]	; (8031b84 <OnPeriodicTimeStartTimer+0x1c>)
}
 8031b78:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  LmhpClockSyncPackage.OnPackageProcessEvent();
 8031b7c:	695b      	ldr	r3, [r3, #20]
 8031b7e:	4718      	bx	r3
 8031b80:	20004934 	.word	0x20004934
 8031b84:	20003490 	.word	0x20003490

08031b88 <LmhpClockSyncOnMcpsIndication>:
{
 8031b88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if( mcpsIndication->Port != CLOCK_SYNC_PORT )
 8031b8c:	78c3      	ldrb	r3, [r0, #3]
 8031b8e:	2bca      	cmp	r3, #202	; 0xca
{
 8031b90:	b085      	sub	sp, #20
 8031b92:	4680      	mov	r8, r0
    if( mcpsIndication->Port != CLOCK_SYNC_PORT )
 8031b94:	f000 80ba 	beq.w	8031d0c <LmhpClockSyncOnMcpsIndication+0x184>
}
 8031b98:	b005      	add	sp, #20
 8031b9a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        switch( mcpsIndication->Buffer[cmdIndex++] )
 8031b9e:	f8d8 1008 	ldr.w	r1, [r8, #8]
 8031ba2:	5cc8      	ldrb	r0, [r1, r3]
 8031ba4:	1c5a      	adds	r2, r3, #1
 8031ba6:	b2d2      	uxtb	r2, r2
 8031ba8:	2803      	cmp	r0, #3
 8031baa:	d80f      	bhi.n	8031bcc <LmhpClockSyncOnMcpsIndication+0x44>
 8031bac:	e8df f000 	tbb	[pc, r0]
 8031bb0:	a76e1002 	.word	0xa76e1002
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = CLOCK_SYNC_PKG_VERSION_ANS;
 8031bb4:	6871      	ldr	r1, [r6, #4]
 8031bb6:	2300      	movs	r3, #0
 8031bb8:	550b      	strb	r3, [r1, r4]
 8031bba:	1c60      	adds	r0, r4, #1
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = CLOCK_SYNC_ID;
 8031bbc:	1ca3      	adds	r3, r4, #2
 8031bbe:	b2db      	uxtb	r3, r3
 8031bc0:	b2c0      	uxtb	r0, r0
 8031bc2:	2501      	movs	r5, #1
 8031bc4:	540d      	strb	r5, [r1, r0]
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = CLOCK_SYNC_VERSION;
 8031bc6:	3403      	adds	r4, #3
 8031bc8:	54cd      	strb	r5, [r1, r3]
 8031bca:	b2e4      	uxtb	r4, r4
        switch( mcpsIndication->Buffer[cmdIndex++] )
 8031bcc:	4617      	mov	r7, r2
 8031bce:	e03b      	b.n	8031c48 <LmhpClockSyncOnMcpsIndication+0xc0>
                LmhpClockSyncState.NbTransmissions = 0;
 8031bd0:	2000      	movs	r0, #0
 8031bd2:	7370      	strb	r0, [r6, #13]
                if( mcpsIndication->DeviceTimeAnsReceived == true )
 8031bd4:	f898 0018 	ldrb.w	r0, [r8, #24]
 8031bd8:	1d9f      	adds	r7, r3, #6
 8031bda:	b2ff      	uxtb	r7, r7
 8031bdc:	2800      	cmp	r0, #0
 8031bde:	d133      	bne.n	8031c48 <LmhpClockSyncOnMcpsIndication+0xc0>
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8031be0:	1d58      	adds	r0, r3, #5
                if( ( mcpsIndication->Buffer[cmdIndex++] & 0x0F ) == LmhpClockSyncState.TimeReqParam.Fields.TokenReq )
 8031be2:	b2c0      	uxtb	r0, r0
 8031be4:	7a35      	ldrb	r5, [r6, #8]
 8031be6:	5c08      	ldrb	r0, [r1, r0]
 8031be8:	f005 050f 	and.w	r5, r5, #15
 8031bec:	f000 000f 	and.w	r0, r0, #15
 8031bf0:	4285      	cmp	r5, r0
 8031bf2:	d129      	bne.n	8031c48 <LmhpClockSyncOnMcpsIndication+0xc0>
                timeCorrection  = ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8031bf4:	5c8d      	ldrb	r5, [r1, r2]
 8031bf6:	1c9a      	adds	r2, r3, #2
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8031bf8:	b2d2      	uxtb	r2, r2
                    curTime = SysTimeGet( );
 8031bfa:	f10d 0b08 	add.w	fp, sp, #8
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8031bfe:	5c8a      	ldrb	r2, [r1, r2]
 8031c00:	eb05 2502 	add.w	r5, r5, r2, lsl #8
 8031c04:	1cda      	adds	r2, r3, #3
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8031c06:	b2d2      	uxtb	r2, r2
 8031c08:	3304      	adds	r3, #4
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8031c0a:	b2db      	uxtb	r3, r3
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8031c0c:	5c8a      	ldrb	r2, [r1, r2]
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8031c0e:	5ccb      	ldrb	r3, [r1, r3]
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8031c10:	eb05 4502 	add.w	r5, r5, r2, lsl #16
                    curTime = SysTimeGet( );
 8031c14:	4658      	mov	r0, fp
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8031c16:	eb05 6503 	add.w	r5, r5, r3, lsl #24
                    curTime = SysTimeGet( );
 8031c1a:	f009 faa1 	bl	803b160 <SysTimeGet>
                    curTime.Seconds += timeCorrection;
 8031c1e:	9b02      	ldr	r3, [sp, #8]
 8031c20:	442b      	add	r3, r5
                    SysTimeSet( curTime );
 8031c22:	9302      	str	r3, [sp, #8]
 8031c24:	e89b 0003 	ldmia.w	fp, {r0, r1}
 8031c28:	f009 fa72 	bl	803b110 <SysTimeSet>
                    LmhpClockSyncState.TimeReqParam.Fields.TokenReq = ( LmhpClockSyncState.TimeReqParam.Fields.TokenReq + 1 ) & 0x0F;
 8031c2c:	7a33      	ldrb	r3, [r6, #8]
 8031c2e:	f3c3 0203 	ubfx	r2, r3, #0, #4
 8031c32:	3201      	adds	r2, #1
 8031c34:	f362 0303 	bfi	r3, r2, #0, #4
 8031c38:	7233      	strb	r3, [r6, #8]
                    if( LmhpClockSyncPackage.OnSysTimeUpdate != NULL )
 8031c3a:	4b38      	ldr	r3, [pc, #224]	; (8031d1c <LmhpClockSyncOnMcpsIndication+0x194>)
 8031c3c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8031c3e:	b11b      	cbz	r3, 8031c48 <LmhpClockSyncOnMcpsIndication+0xc0>
                        if( ( timeCorrection >= -1 ) && ( timeCorrection <= 1 ) )
 8031c40:	3501      	adds	r5, #1
 8031c42:	2d02      	cmp	r5, #2
 8031c44:	d800      	bhi.n	8031c48 <LmhpClockSyncOnMcpsIndication+0xc0>
                            LmhpClockSyncPackage.OnSysTimeUpdate( );
 8031c46:	4798      	blx	r3
        switch( mcpsIndication->Buffer[cmdIndex++] )
 8031c48:	463b      	mov	r3, r7
    while( cmdIndex < mcpsIndication->BufferSize )
 8031c4a:	f898 200c 	ldrb.w	r2, [r8, #12]
 8031c4e:	429a      	cmp	r2, r3
 8031c50:	d8a5      	bhi.n	8031b9e <LmhpClockSyncOnMcpsIndication+0x16>
    if( dataBufferIndex != 0 )
 8031c52:	2c00      	cmp	r4, #0
 8031c54:	d0a0      	beq.n	8031b98 <LmhpClockSyncOnMcpsIndication+0x10>
        LmHandlerAppData_t appData =
 8031c56:	23ca      	movs	r3, #202	; 0xca
 8031c58:	f88d 3008 	strb.w	r3, [sp, #8]
            .Buffer = LmhpClockSyncState.DataBuffer,
 8031c5c:	4b30      	ldr	r3, [pc, #192]	; (8031d20 <LmhpClockSyncOnMcpsIndication+0x198>)
        LmHandlerAppData_t appData =
 8031c5e:	f88d 4009 	strb.w	r4, [sp, #9]
 8031c62:	685b      	ldr	r3, [r3, #4]
 8031c64:	9303      	str	r3, [sp, #12]
        LmHandlerGetDutyCycleEnable(&current_dutycycle);
 8031c66:	f10d 0007 	add.w	r0, sp, #7
 8031c6a:	f7ff ff59 	bl	8031b20 <LmHandlerGetDutyCycleEnable>
        LmHandlerSetDutyCycleEnable(false);
 8031c6e:	2000      	movs	r0, #0
 8031c70:	f7ff ff62 	bl	8031b38 <LmHandlerSetDutyCycleEnable>
        LmhpClockSyncPackage.OnSendRequest(&appData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true);
 8031c74:	4b29      	ldr	r3, [pc, #164]	; (8031d1c <LmhpClockSyncOnMcpsIndication+0x194>)
 8031c76:	2200      	movs	r2, #0
 8031c78:	6a9c      	ldr	r4, [r3, #40]	; 0x28
 8031c7a:	4611      	mov	r1, r2
 8031c7c:	2301      	movs	r3, #1
 8031c7e:	a802      	add	r0, sp, #8
 8031c80:	47a0      	blx	r4
        LmHandlerSetDutyCycleEnable(current_dutycycle);
 8031c82:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8031c86:	f7ff ff57 	bl	8031b38 <LmHandlerSetDutyCycleEnable>
 8031c8a:	e785      	b.n	8031b98 <LmhpClockSyncOnMcpsIndication+0x10>
                uint32_t periodTime = mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8031c8c:	1cdf      	adds	r7, r3, #3
                cmdIndex++;
 8031c8e:	3302      	adds	r3, #2
                uint32_t periodTime = mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8031c90:	b2db      	uxtb	r3, r3
                periodTime = (128 << periodTime) + randr(0, 30);
 8031c92:	2000      	movs	r0, #0
                uint32_t periodTime = mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8031c94:	5ccd      	ldrb	r5, [r1, r3]
 8031c96:	f005 010f 	and.w	r1, r5, #15
                periodTime = (128 << periodTime) + randr(0, 30);
 8031c9a:	2580      	movs	r5, #128	; 0x80
 8031c9c:	408d      	lsls	r5, r1
 8031c9e:	211e      	movs	r1, #30
 8031ca0:	f007 f928 	bl	8038ef4 <randr>
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = CLOCK_SYNC_APP_TIME_PERIOD_ANS;
 8031ca4:	6872      	ldr	r2, [r6, #4]
 8031ca6:	2302      	movs	r3, #2
 8031ca8:	5513      	strb	r3, [r2, r4]
 8031caa:	1c63      	adds	r3, r4, #1
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = 0x00;
 8031cac:	b2db      	uxtb	r3, r3
 8031cae:	2100      	movs	r1, #0
 8031cb0:	54d1      	strb	r1, [r2, r3]
                periodTime = (128 << periodTime) + randr(0, 30);
 8031cb2:	4683      	mov	fp, r0
                SysTime_t curTime = SysTimeGet( );
 8031cb4:	a802      	add	r0, sp, #8
 8031cb6:	f009 fa53 	bl	803b160 <SysTimeGet>
                curTime.Seconds -= UNIX_GPS_EPOCH_OFFSET;
 8031cba:	9b02      	ldr	r3, [sp, #8]
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 0  ) & 0xFF;
 8031cbc:	6872      	ldr	r2, [r6, #4]
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = 0x00;
 8031cbe:	1ca1      	adds	r1, r4, #2
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 0  ) & 0xFF;
 8031cc0:	b2c9      	uxtb	r1, r1
                curTime.Seconds -= UNIX_GPS_EPOCH_OFFSET;
 8031cc2:	4453      	add	r3, sl
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 0  ) & 0xFF;
 8031cc4:	5453      	strb	r3, [r2, r1]
 8031cc6:	1ce1      	adds	r1, r4, #3
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 8  ) & 0xFF;
 8031cc8:	b2c9      	uxtb	r1, r1
 8031cca:	0a18      	lsrs	r0, r3, #8
 8031ccc:	5450      	strb	r0, [r2, r1]
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 16 ) & 0xFF;
 8031cce:	1d61      	adds	r1, r4, #5
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 8  ) & 0xFF;
 8031cd0:	1d20      	adds	r0, r4, #4
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 16 ) & 0xFF;
 8031cd2:	b2c9      	uxtb	r1, r1
 8031cd4:	b2c0      	uxtb	r0, r0
 8031cd6:	ea4f 4c13 	mov.w	ip, r3, lsr #16
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 24 ) & 0xFF;
 8031cda:	0e1b      	lsrs	r3, r3, #24
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 16 ) & 0xFF;
 8031cdc:	f802 c000 	strb.w	ip, [r2, r0]
                periodTime = (128 << periodTime) + randr(0, 30);
 8031ce0:	445d      	add	r5, fp
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 24 ) & 0xFF;
 8031ce2:	5453      	strb	r3, [r2, r1]
                TimerSetValue(&PeriodicTimeStartTimer, periodTime * 1000);
 8031ce4:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8031ce8:	4369      	muls	r1, r5
 8031cea:	4648      	mov	r0, r9
 8031cec:	f009 fbb0 	bl	803b450 <UTIL_TIMER_SetPeriod>
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 24 ) & 0xFF;
 8031cf0:	3406      	adds	r4, #6
                TimerStart(&PeriodicTimeStartTimer);
 8031cf2:	4648      	mov	r0, r9
                uint32_t periodTime = mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8031cf4:	b2ff      	uxtb	r7, r7
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 24 ) & 0xFF;
 8031cf6:	b2e4      	uxtb	r4, r4
                TimerStart(&PeriodicTimeStartTimer);
 8031cf8:	f009 fb70 	bl	803b3dc <UTIL_TIMER_Start>
                break;
 8031cfc:	e7a4      	b.n	8031c48 <LmhpClockSyncOnMcpsIndication+0xc0>
                LmhpClockSyncState.NbTransmissions = mcpsIndication->Buffer[cmdIndex++] & 0X07;
 8031cfe:	3302      	adds	r3, #2
 8031d00:	b2df      	uxtb	r7, r3
 8031d02:	5c8b      	ldrb	r3, [r1, r2]
 8031d04:	f003 0307 	and.w	r3, r3, #7
 8031d08:	7373      	strb	r3, [r6, #13]
                break;
 8031d0a:	e79d      	b.n	8031c48 <LmhpClockSyncOnMcpsIndication+0xc0>
                LmhpClockSyncState.NbTransmissions = mcpsIndication->Buffer[cmdIndex++] & 0X07;
 8031d0c:	4e04      	ldr	r6, [pc, #16]	; (8031d20 <LmhpClockSyncOnMcpsIndication+0x198>)
                curTime.Seconds -= UNIX_GPS_EPOCH_OFFSET;
 8031d0e:	f8df a014 	ldr.w	sl, [pc, #20]	; 8031d24 <LmhpClockSyncOnMcpsIndication+0x19c>
    uint8_t dataBufferIndex = 0;
 8031d12:	2400      	movs	r4, #0
    uint8_t cmdIndex = 0;
 8031d14:	4623      	mov	r3, r4
                TimerSetValue(&PeriodicTimeStartTimer, periodTime * 1000);
 8031d16:	f106 0910 	add.w	r9, r6, #16
 8031d1a:	e796      	b.n	8031c4a <LmhpClockSyncOnMcpsIndication+0xc2>
 8031d1c:	20003490 	.word	0x20003490
 8031d20:	20004934 	.word	0x20004934
 8031d24:	ed2ac280 	.word	0xed2ac280

08031d28 <LmhpClockSyncOnMcpsConfirm>:
{
 8031d28:	b510      	push	{r4, lr}
    if( LmhpClockSyncState.AppTimeReqPending == true )
 8031d2a:	4c11      	ldr	r4, [pc, #68]	; (8031d70 <LmhpClockSyncOnMcpsConfirm+0x48>)
 8031d2c:	7a63      	ldrb	r3, [r4, #9]
{
 8031d2e:	b08a      	sub	sp, #40	; 0x28
    if( LmhpClockSyncState.AppTimeReqPending == true )
 8031d30:	b1e3      	cbz	r3, 8031d6c <LmhpClockSyncOnMcpsConfirm+0x44>
        mibReq.Type = MIB_ADR;
 8031d32:	2304      	movs	r3, #4
 8031d34:	f88d 3004 	strb.w	r3, [sp, #4]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8031d38:	a801      	add	r0, sp, #4
        mibReq.Param.AdrEnable = LmhpClockSyncState.AdrEnabledPrev;
 8031d3a:	7aa3      	ldrb	r3, [r4, #10]
 8031d3c:	f88d 3008 	strb.w	r3, [sp, #8]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8031d40:	f003 f846 	bl	8034dd0 <LoRaMacMibSetRequestConfirm>
        mibReq.Type = MIB_CHANNELS_NB_TRANS;
 8031d44:	2318      	movs	r3, #24
 8031d46:	f88d 3004 	strb.w	r3, [sp, #4]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8031d4a:	a801      	add	r0, sp, #4
        mibReq.Param.ChannelsNbTrans = LmhpClockSyncState.NbTransPrev;
 8031d4c:	7ae3      	ldrb	r3, [r4, #11]
 8031d4e:	f88d 3008 	strb.w	r3, [sp, #8]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8031d52:	f003 f83d 	bl	8034dd0 <LoRaMacMibSetRequestConfirm>
        mibReq.Type = MIB_CHANNELS_DATARATE;
 8031d56:	231f      	movs	r3, #31
 8031d58:	f88d 3004 	strb.w	r3, [sp, #4]
        LoRaMacMibSetRequestConfirm( &mibReq );        
 8031d5c:	a801      	add	r0, sp, #4
        mibReq.Param.ChannelsDatarate = LmhpClockSyncState.DataratePrev;
 8031d5e:	7b23      	ldrb	r3, [r4, #12]
 8031d60:	f88d 3008 	strb.w	r3, [sp, #8]
        LoRaMacMibSetRequestConfirm( &mibReq );        
 8031d64:	f003 f834 	bl	8034dd0 <LoRaMacMibSetRequestConfirm>
        LmhpClockSyncState.AppTimeReqPending = false;
 8031d68:	2300      	movs	r3, #0
 8031d6a:	7263      	strb	r3, [r4, #9]
}
 8031d6c:	b00a      	add	sp, #40	; 0x28
 8031d6e:	bd10      	pop	{r4, pc}
 8031d70:	20004934 	.word	0x20004934

08031d74 <LmhpClockSyncInit>:
{
 8031d74:	b507      	push	{r0, r1, r2, lr}
 8031d76:	480a      	ldr	r0, [pc, #40]	; (8031da0 <LmhpClockSyncInit+0x2c>)
    if( dataBuffer != NULL )
 8031d78:	b179      	cbz	r1, 8031d9a <LmhpClockSyncInit+0x26>
        LmhpClockSyncState.DataBufferMaxSize = dataBufferMaxSize;
 8031d7a:	7082      	strb	r2, [r0, #2]
        LmhpClockSyncState.Initialized = true;
 8031d7c:	f240 1301 	movw	r3, #257	; 0x101
        TimerInit(&PeriodicTimeStartTimer, OnPeriodicTimeStartTimer);
 8031d80:	2200      	movs	r2, #0
        LmhpClockSyncState.DataBuffer = dataBuffer;
 8031d82:	6041      	str	r1, [r0, #4]
        LmhpClockSyncState.Initialized = true;
 8031d84:	f820 3b10 	strh.w	r3, [r0], #16
        TimerInit(&PeriodicTimeStartTimer, OnPeriodicTimeStartTimer);
 8031d88:	f04f 31ff 	mov.w	r1, #4294967295
 8031d8c:	4b05      	ldr	r3, [pc, #20]	; (8031da4 <LmhpClockSyncInit+0x30>)
 8031d8e:	9200      	str	r2, [sp, #0]
 8031d90:	f009 fa76 	bl	803b280 <UTIL_TIMER_Create>
}
 8031d94:	b003      	add	sp, #12
 8031d96:	f85d fb04 	ldr.w	pc, [sp], #4
        LmhpClockSyncState.Initialized = false;
 8031d9a:	8001      	strh	r1, [r0, #0]
}
 8031d9c:	e7fa      	b.n	8031d94 <LmhpClockSyncInit+0x20>
 8031d9e:	bf00      	nop
 8031da0:	20004934 	.word	0x20004934
 8031da4:	08031b69 	.word	0x08031b69

08031da8 <LmhpClockSyncPackageFactory>:
}
 8031da8:	4800      	ldr	r0, [pc, #0]	; (8031dac <LmhpClockSyncPackageFactory+0x4>)
 8031daa:	4770      	bx	lr
 8031dac:	20003490 	.word	0x20003490

08031db0 <LmhpClockSyncAppTimeReq>:
{
 8031db0:	b570      	push	{r4, r5, r6, lr}
 8031db2:	b08c      	sub	sp, #48	; 0x30
    if( LmHandlerIsBusy( ) == true )
 8031db4:	f7ff fcb8 	bl	8031728 <LmHandlerIsBusy>
 8031db8:	2800      	cmp	r0, #0
 8031dba:	d15b      	bne.n	8031e74 <LmhpClockSyncAppTimeReq+0xc4>
    if( LmhpClockSyncState.AppTimeReqPending == false )
 8031dbc:	4c2f      	ldr	r4, [pc, #188]	; (8031e7c <LmhpClockSyncAppTimeReq+0xcc>)
 8031dbe:	4e30      	ldr	r6, [pc, #192]	; (8031e80 <LmhpClockSyncAppTimeReq+0xd0>)
 8031dc0:	7a65      	ldrb	r5, [r4, #9]
 8031dc2:	bb3d      	cbnz	r5, 8031e14 <LmhpClockSyncAppTimeReq+0x64>
        mibReq.Type = MIB_ADR;
 8031dc4:	2304      	movs	r3, #4
        LoRaMacMibGetRequestConfirm( &mibReq );
 8031dc6:	a803      	add	r0, sp, #12
        mibReq.Type = MIB_ADR;
 8031dc8:	f88d 300c 	strb.w	r3, [sp, #12]
        LoRaMacMibGetRequestConfirm( &mibReq );
 8031dcc:	f002 ff44 	bl	8034c58 <LoRaMacMibGetRequestConfirm>
        LmhpClockSyncState.AdrEnabledPrev = mibReq.Param.AdrEnable;
 8031dd0:	f89d 3010 	ldrb.w	r3, [sp, #16]
 8031dd4:	72a3      	strb	r3, [r4, #10]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8031dd6:	a803      	add	r0, sp, #12
        mibReq.Param.AdrEnable = false;
 8031dd8:	f88d 5010 	strb.w	r5, [sp, #16]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8031ddc:	f002 fff8 	bl	8034dd0 <LoRaMacMibSetRequestConfirm>
        mibReq.Type = MIB_CHANNELS_NB_TRANS;
 8031de0:	2318      	movs	r3, #24
        LoRaMacMibGetRequestConfirm( &mibReq );
 8031de2:	a803      	add	r0, sp, #12
        mibReq.Type = MIB_CHANNELS_NB_TRANS;
 8031de4:	f88d 300c 	strb.w	r3, [sp, #12]
        LoRaMacMibGetRequestConfirm( &mibReq );
 8031de8:	f002 ff36 	bl	8034c58 <LoRaMacMibGetRequestConfirm>
        LmhpClockSyncState.NbTransPrev = mibReq.Param.ChannelsNbTrans;
 8031dec:	f89d 3010 	ldrb.w	r3, [sp, #16]
 8031df0:	72e3      	strb	r3, [r4, #11]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8031df2:	a803      	add	r0, sp, #12
        mibReq.Param.ChannelsNbTrans = 1;
 8031df4:	2301      	movs	r3, #1
 8031df6:	f88d 3010 	strb.w	r3, [sp, #16]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8031dfa:	f002 ffe9 	bl	8034dd0 <LoRaMacMibSetRequestConfirm>
        mibReq.Type = MIB_CHANNELS_DATARATE;
 8031dfe:	231f      	movs	r3, #31
        LoRaMacMibGetRequestConfirm( &mibReq );  
 8031e00:	a803      	add	r0, sp, #12
        mibReq.Type = MIB_CHANNELS_DATARATE;
 8031e02:	f88d 300c 	strb.w	r3, [sp, #12]
        LoRaMacMibGetRequestConfirm( &mibReq );  
 8031e06:	f002 ff27 	bl	8034c58 <LoRaMacMibGetRequestConfirm>
        LmhpClockSyncState.DataratePrev = mibReq.Param.ChannelsDatarate;
 8031e0a:	f89d 3010 	ldrb.w	r3, [sp, #16]
 8031e0e:	7323      	strb	r3, [r4, #12]
        LmhpClockSyncPackage.OnDeviceTimeRequest( );
 8031e10:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8031e12:	4798      	blx	r3
    SysTime_t curTime = SysTimeGet( );
 8031e14:	a801      	add	r0, sp, #4
 8031e16:	f009 f9a3 	bl	803b160 <SysTimeGet>
    curTime.Seconds -= UNIX_GPS_EPOCH_OFFSET;
 8031e1a:	9b01      	ldr	r3, [sp, #4]
 8031e1c:	4a19      	ldr	r2, [pc, #100]	; (8031e84 <LmhpClockSyncAppTimeReq+0xd4>)
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = CLOCK_SYNC_APP_TIME_REQ;
 8031e1e:	6861      	ldr	r1, [r4, #4]
    curTime.Seconds -= UNIX_GPS_EPOCH_OFFSET;
 8031e20:	441a      	add	r2, r3
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 8  ) & 0xFF;
 8031e22:	0a13      	lsrs	r3, r2, #8
 8031e24:	708b      	strb	r3, [r1, #2]
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 16 ) & 0xFF;
 8031e26:	0c13      	lsrs	r3, r2, #16
 8031e28:	70cb      	strb	r3, [r1, #3]
    LmhpClockSyncState.TimeReqParam.Fields.AnsRequired = 0;
 8031e2a:	7a23      	ldrb	r3, [r4, #8]
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 0  ) & 0xFF;
 8031e2c:	704a      	strb	r2, [r1, #1]
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = CLOCK_SYNC_APP_TIME_REQ;
 8031e2e:	2501      	movs	r5, #1
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 24 ) & 0xFF;
 8031e30:	0e12      	lsrs	r2, r2, #24
    LmhpClockSyncState.TimeReqParam.Fields.AnsRequired = 0;
 8031e32:	f36f 1304 	bfc	r3, #4, #1
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 24 ) & 0xFF;
 8031e36:	710a      	strb	r2, [r1, #4]
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = LmhpClockSyncState.TimeReqParam.Value;
 8031e38:	714b      	strb	r3, [r1, #5]
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = CLOCK_SYNC_APP_TIME_REQ;
 8031e3a:	700d      	strb	r5, [r1, #0]
    LmhpClockSyncState.TimeReqParam.Fields.AnsRequired = 0;
 8031e3c:	7223      	strb	r3, [r4, #8]
    LmHandlerGetDutyCycleEnable(&current_dutycycle);
 8031e3e:	f10d 0003 	add.w	r0, sp, #3
    LmHandlerAppData_t appData =
 8031e42:	f240 63ca 	movw	r3, #1738	; 0x6ca
 8031e46:	f8ad 300c 	strh.w	r3, [sp, #12]
 8031e4a:	9104      	str	r1, [sp, #16]
    LmhpClockSyncState.AppTimeReqPending = true;
 8031e4c:	7265      	strb	r5, [r4, #9]
    LmHandlerGetDutyCycleEnable(&current_dutycycle);
 8031e4e:	f7ff fe67 	bl	8031b20 <LmHandlerGetDutyCycleEnable>
    LmHandlerSetDutyCycleEnable(false);
 8031e52:	2000      	movs	r0, #0
 8031e54:	f7ff fe70 	bl	8031b38 <LmHandlerSetDutyCycleEnable>
    LmHandlerErrorStatus_t status = LmhpClockSyncPackage.OnSendRequest(&appData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true);
 8031e58:	2200      	movs	r2, #0
 8031e5a:	6ab4      	ldr	r4, [r6, #40]	; 0x28
 8031e5c:	462b      	mov	r3, r5
 8031e5e:	4611      	mov	r1, r2
 8031e60:	a803      	add	r0, sp, #12
 8031e62:	47a0      	blx	r4
 8031e64:	4604      	mov	r4, r0
    LmHandlerSetDutyCycleEnable(current_dutycycle);
 8031e66:	f89d 0003 	ldrb.w	r0, [sp, #3]
 8031e6a:	f7ff fe65 	bl	8031b38 <LmHandlerSetDutyCycleEnable>
}
 8031e6e:	4620      	mov	r0, r4
 8031e70:	b00c      	add	sp, #48	; 0x30
 8031e72:	bd70      	pop	{r4, r5, r6, pc}
        return LORAMAC_HANDLER_ERROR;
 8031e74:	f04f 34ff 	mov.w	r4, #4294967295
 8031e78:	e7f9      	b.n	8031e6e <LmhpClockSyncAppTimeReq+0xbe>
 8031e7a:	bf00      	nop
 8031e7c:	20004934 	.word	0x20004934
 8031e80:	20003490 	.word	0x20003490
 8031e84:	ed2ac280 	.word	0xed2ac280

08031e88 <LmhpClockSyncProcess>:
{
 8031e88:	b510      	push	{r4, lr}
    if( LmhpClockSyncState.NbTransmissions > 0 )
 8031e8a:	4c05      	ldr	r4, [pc, #20]	; (8031ea0 <LmhpClockSyncProcess+0x18>)
 8031e8c:	7b63      	ldrb	r3, [r4, #13]
 8031e8e:	b12b      	cbz	r3, 8031e9c <LmhpClockSyncProcess+0x14>
        if( LmhpClockSyncAppTimeReq( ) == LORAMAC_HANDLER_SUCCESS )
 8031e90:	f7ff ff8e 	bl	8031db0 <LmhpClockSyncAppTimeReq>
 8031e94:	b910      	cbnz	r0, 8031e9c <LmhpClockSyncProcess+0x14>
            LmhpClockSyncState.NbTransmissions--;
 8031e96:	7b63      	ldrb	r3, [r4, #13]
 8031e98:	3b01      	subs	r3, #1
 8031e9a:	7363      	strb	r3, [r4, #13]
}
 8031e9c:	bd10      	pop	{r4, pc}
 8031e9e:	bf00      	nop
 8031ea0:	20004934 	.word	0x20004934

08031ea4 <LmhpComplianceInit>:
    return &LmhpCompliancePackage;
}

static void LmhpComplianceInit( void *params, uint8_t *dataBuffer, uint8_t dataBufferMaxSize )
{
    if( ( params != NULL ) && ( dataBuffer != NULL ) )
 8031ea4:	4b05      	ldr	r3, [pc, #20]	; (8031ebc <LmhpComplianceInit+0x18>)
 8031ea6:	b130      	cbz	r0, 8031eb6 <LmhpComplianceInit+0x12>
 8031ea8:	b129      	cbz	r1, 8031eb6 <LmhpComplianceInit+0x12>
    {
        LmhpComplianceParams = ( LmhpComplianceParams_t* )params;
        ComplianceTestState.DataBuffer = dataBuffer;
        ComplianceTestState.DataBufferMaxSize = dataBufferMaxSize;
 8031eaa:	725a      	strb	r2, [r3, #9]
        LmhpComplianceParams = ( LmhpComplianceParams_t* )params;
 8031eac:	6018      	str	r0, [r3, #0]
        ComplianceTestState.DataBuffer = dataBuffer;
 8031eae:	60d9      	str	r1, [r3, #12]
        ComplianceTestState.Initialized = true;
 8031eb0:	2201      	movs	r2, #1
    }
    else
    {
        LmhpComplianceParams = NULL;
        ComplianceTestState.Initialized = false;
 8031eb2:	711a      	strb	r2, [r3, #4]
    }
}
 8031eb4:	4770      	bx	lr
        LmhpComplianceParams = NULL;
 8031eb6:	2200      	movs	r2, #0
 8031eb8:	601a      	str	r2, [r3, #0]
 8031eba:	e7fa      	b.n	8031eb2 <LmhpComplianceInit+0xe>
 8031ebc:	2000495c 	.word	0x2000495c

08031ec0 <LmhpComplianceIsInitialized>:

static bool LmhpComplianceIsInitialized( void )
{
    return ComplianceTestState.Initialized;
}
 8031ec0:	4b01      	ldr	r3, [pc, #4]	; (8031ec8 <LmhpComplianceIsInitialized+0x8>)
 8031ec2:	7918      	ldrb	r0, [r3, #4]
 8031ec4:	4770      	bx	lr
 8031ec6:	bf00      	nop
 8031ec8:	2000495c 	.word	0x2000495c

08031ecc <LmhpComplianceIsRunning>:

static bool LmhpComplianceIsRunning( void )
{
    if( ComplianceTestState.Initialized == false )
 8031ecc:	4b02      	ldr	r3, [pc, #8]	; (8031ed8 <LmhpComplianceIsRunning+0xc>)
 8031ece:	7918      	ldrb	r0, [r3, #4]
 8031ed0:	b100      	cbz	r0, 8031ed4 <LmhpComplianceIsRunning+0x8>
    {
        return false;
    }

    return ComplianceTestState.IsRunning;
 8031ed2:	7958      	ldrb	r0, [r3, #5]
}
 8031ed4:	4770      	bx	lr
 8031ed6:	bf00      	nop
 8031ed8:	2000495c 	.word	0x2000495c

08031edc <LmhpComplianceProcess>:
}

static void LmhpComplianceProcess( void )
{
    /* Nothing to process */
}
 8031edc:	4770      	bx	lr
	...

08031ee0 <LmhpComplianceOnMcpsConfirm>:
    if (ComplianceTestState.Initialized == false)
 8031ee0:	4b06      	ldr	r3, [pc, #24]	; (8031efc <LmhpComplianceOnMcpsConfirm+0x1c>)
 8031ee2:	791a      	ldrb	r2, [r3, #4]
 8031ee4:	b14a      	cbz	r2, 8031efa <LmhpComplianceOnMcpsConfirm+0x1a>
    if ((ComplianceTestState.IsRunning == true) &&
 8031ee6:	795a      	ldrb	r2, [r3, #5]
 8031ee8:	b13a      	cbz	r2, 8031efa <LmhpComplianceOnMcpsConfirm+0x1a>
 8031eea:	7802      	ldrb	r2, [r0, #0]
 8031eec:	2a01      	cmp	r2, #1
 8031eee:	d104      	bne.n	8031efa <LmhpComplianceOnMcpsConfirm+0x1a>
        (mcpsConfirm->McpsRequest == MCPS_CONFIRMED) &&
 8031ef0:	7902      	ldrb	r2, [r0, #4]
 8031ef2:	b112      	cbz	r2, 8031efa <LmhpComplianceOnMcpsConfirm+0x1a>
        ComplianceTestState.DownLinkCounter++;
 8031ef4:	8a1a      	ldrh	r2, [r3, #16]
 8031ef6:	3201      	adds	r2, #1
 8031ef8:	821a      	strh	r2, [r3, #16]
}
 8031efa:	4770      	bx	lr
 8031efc:	2000495c 	.word	0x2000495c

08031f00 <LmhpComplianceOnMlmeConfirm>:
    if( ComplianceTestState.Initialized == false )
 8031f00:	4b07      	ldr	r3, [pc, #28]	; (8031f20 <LmhpComplianceOnMlmeConfirm+0x20>)
 8031f02:	791a      	ldrb	r2, [r3, #4]
 8031f04:	b152      	cbz	r2, 8031f1c <LmhpComplianceOnMlmeConfirm+0x1c>
    if( ComplianceTestState.IsRunning == false )
 8031f06:	795a      	ldrb	r2, [r3, #5]
 8031f08:	b142      	cbz	r2, 8031f1c <LmhpComplianceOnMlmeConfirm+0x1c>
    if( mlmeConfirm->MlmeRequest == MLME_LINK_CHECK )
 8031f0a:	7802      	ldrb	r2, [r0, #0]
 8031f0c:	2a04      	cmp	r2, #4
 8031f0e:	d105      	bne.n	8031f1c <LmhpComplianceOnMlmeConfirm+0x1c>
        ComplianceTestState.LinkCheck = true;
 8031f10:	2201      	movs	r2, #1
 8031f12:	749a      	strb	r2, [r3, #18]
        ComplianceTestState.DemodMargin = mlmeConfirm->DemodMargin;
 8031f14:	7a02      	ldrb	r2, [r0, #8]
 8031f16:	74da      	strb	r2, [r3, #19]
        ComplianceTestState.NbGateways = mlmeConfirm->NbGateways;
 8031f18:	7a42      	ldrb	r2, [r0, #9]
 8031f1a:	751a      	strb	r2, [r3, #20]
}
 8031f1c:	4770      	bx	lr
 8031f1e:	bf00      	nop
 8031f20:	2000495c 	.word	0x2000495c

08031f24 <LmhpComplianceTxProcess>:
{
 8031f24:	b537      	push	{r0, r1, r2, r4, r5, lr}
    if( ComplianceTestState.Initialized == false )
 8031f26:	4c1b      	ldr	r4, [pc, #108]	; (8031f94 <LmhpComplianceTxProcess+0x70>)
 8031f28:	7923      	ldrb	r3, [r4, #4]
 8031f2a:	b383      	cbz	r3, 8031f8e <LmhpComplianceTxProcess+0x6a>
    if( ComplianceTestState.IsRunning == false )
 8031f2c:	7960      	ldrb	r0, [r4, #5]
 8031f2e:	b328      	cbz	r0, 8031f7c <LmhpComplianceTxProcess+0x58>
    if( ComplianceTestState.LinkCheck == true )
 8031f30:	7ca2      	ldrb	r2, [r4, #18]
 8031f32:	68e3      	ldr	r3, [r4, #12]
 8031f34:	b162      	cbz	r2, 8031f50 <LmhpComplianceTxProcess+0x2c>
        ComplianceTestState.LinkCheck = false;
 8031f36:	2200      	movs	r2, #0
 8031f38:	74a2      	strb	r2, [r4, #18]
        ComplianceTestState.DataBufferSize = 3;
 8031f3a:	2203      	movs	r2, #3
 8031f3c:	72a2      	strb	r2, [r4, #10]
        ComplianceTestState.DataBuffer[0] = 5;
 8031f3e:	2205      	movs	r2, #5
 8031f40:	701a      	strb	r2, [r3, #0]
        ComplianceTestState.DataBuffer[1] = ComplianceTestState.DemodMargin;
 8031f42:	7ce2      	ldrb	r2, [r4, #19]
 8031f44:	705a      	strb	r2, [r3, #1]
        ComplianceTestState.DataBuffer[2] = ComplianceTestState.NbGateways;
 8031f46:	7d22      	ldrb	r2, [r4, #20]
 8031f48:	709a      	strb	r2, [r3, #2]
            ComplianceTestState.State = 1;
 8031f4a:	2201      	movs	r2, #1
 8031f4c:	71a2      	strb	r2, [r4, #6]
            break;
 8031f4e:	e004      	b.n	8031f5a <LmhpComplianceTxProcess+0x36>
        switch( ComplianceTestState.State )
 8031f50:	79a2      	ldrb	r2, [r4, #6]
 8031f52:	2a01      	cmp	r2, #1
 8031f54:	d014      	beq.n	8031f80 <LmhpComplianceTxProcess+0x5c>
 8031f56:	2a04      	cmp	r2, #4
 8031f58:	d0f7      	beq.n	8031f4a <LmhpComplianceTxProcess+0x26>
    LmHandlerAppData_t appData =
 8031f5a:	22e0      	movs	r2, #224	; 0xe0
 8031f5c:	f88d 2000 	strb.w	r2, [sp]
    TimerStart( &ComplianceTxNextPacketTimer );
 8031f60:	480d      	ldr	r0, [pc, #52]	; (8031f98 <LmhpComplianceTxProcess+0x74>)
    LmHandlerAppData_t appData =
 8031f62:	7aa2      	ldrb	r2, [r4, #10]
 8031f64:	f88d 2001 	strb.w	r2, [sp, #1]
 8031f68:	9301      	str	r3, [sp, #4]
    TimerStart( &ComplianceTxNextPacketTimer );
 8031f6a:	f009 fa37 	bl	803b3dc <UTIL_TIMER_Start>
    return LmhpCompliancePackage.OnSendRequest( &appData, ( LmHandlerMsgTypes_t )ComplianceTestState.IsTxConfirmed, NULL, true );
 8031f6e:	4b0b      	ldr	r3, [pc, #44]	; (8031f9c <LmhpComplianceTxProcess+0x78>)
 8031f70:	79e1      	ldrb	r1, [r4, #7]
 8031f72:	6a9d      	ldr	r5, [r3, #40]	; 0x28
 8031f74:	2200      	movs	r2, #0
 8031f76:	2301      	movs	r3, #1
 8031f78:	4668      	mov	r0, sp
 8031f7a:	47a8      	blx	r5
}
 8031f7c:	b003      	add	sp, #12
 8031f7e:	bd30      	pop	{r4, r5, pc}
            ComplianceTestState.DataBufferSize = 2;
 8031f80:	2202      	movs	r2, #2
 8031f82:	72a2      	strb	r2, [r4, #10]
            ComplianceTestState.DataBuffer[0] = ComplianceTestState.DownLinkCounter >> 8;
 8031f84:	8a22      	ldrh	r2, [r4, #16]
            ComplianceTestState.DataBuffer[1] = ComplianceTestState.DownLinkCounter;
 8031f86:	705a      	strb	r2, [r3, #1]
            ComplianceTestState.DataBuffer[0] = ComplianceTestState.DownLinkCounter >> 8;
 8031f88:	0a11      	lsrs	r1, r2, #8
 8031f8a:	7019      	strb	r1, [r3, #0]
            break;
 8031f8c:	e7e5      	b.n	8031f5a <LmhpComplianceTxProcess+0x36>
        return LORAMAC_HANDLER_ERROR;
 8031f8e:	f04f 30ff 	mov.w	r0, #4294967295
 8031f92:	e7f3      	b.n	8031f7c <LmhpComplianceTxProcess+0x58>
 8031f94:	2000495c 	.word	0x2000495c
 8031f98:	20004974 	.word	0x20004974
 8031f9c:	200034c4 	.word	0x200034c4

08031fa0 <OnComplianceTxNextPacketTimerEvent>:

static void OnComplianceTxNextPacketTimerEvent( void* context )
{
    LmhpComplianceTxProcess( );
 8031fa0:	f7ff bfc0 	b.w	8031f24 <LmhpComplianceTxProcess>

08031fa4 <LmhpComplianceOnMcpsIndication>:
{
 8031fa4:	b530      	push	{r4, r5, lr}
    if( ComplianceTestState.Initialized == false )
 8031fa6:	4c77      	ldr	r4, [pc, #476]	; (8032184 <LmhpComplianceOnMcpsIndication+0x1e0>)
 8031fa8:	7923      	ldrb	r3, [r4, #4]
{
 8031faa:	b08d      	sub	sp, #52	; 0x34
    if( ComplianceTestState.Initialized == false )
 8031fac:	2b00      	cmp	r3, #0
 8031fae:	d042      	beq.n	8032036 <LmhpComplianceOnMcpsIndication+0x92>
    if( mcpsIndication->RxData == false )
 8031fb0:	7b43      	ldrb	r3, [r0, #13]
 8031fb2:	2b00      	cmp	r3, #0
 8031fb4:	d03f      	beq.n	8032036 <LmhpComplianceOnMcpsIndication+0x92>
    if ((ComplianceTestState.IsRunning == true) &&
 8031fb6:	7965      	ldrb	r5, [r4, #5]
 8031fb8:	b125      	cbz	r5, 8031fc4 <LmhpComplianceOnMcpsIndication+0x20>
 8031fba:	7b83      	ldrb	r3, [r0, #14]
 8031fbc:	b913      	cbnz	r3, 8031fc4 <LmhpComplianceOnMcpsIndication+0x20>
        ComplianceTestState.DownLinkCounter++;
 8031fbe:	8a23      	ldrh	r3, [r4, #16]
 8031fc0:	3301      	adds	r3, #1
 8031fc2:	8223      	strh	r3, [r4, #16]
    if( mcpsIndication->Port != COMPLIANCE_PORT )
 8031fc4:	78c1      	ldrb	r1, [r0, #3]
 8031fc6:	29e0      	cmp	r1, #224	; 0xe0
 8031fc8:	d135      	bne.n	8032036 <LmhpComplianceOnMcpsIndication+0x92>
    if( ComplianceTestState.IsRunning == false )
 8031fca:	2d00      	cmp	r5, #0
 8031fcc:	d135      	bne.n	803203a <LmhpComplianceOnMcpsIndication+0x96>
        if( ( mcpsIndication->BufferSize == 4 ) &&
 8031fce:	7b02      	ldrb	r2, [r0, #12]
 8031fd0:	2a04      	cmp	r2, #4
 8031fd2:	d130      	bne.n	8032036 <LmhpComplianceOnMcpsIndication+0x92>
            ( mcpsIndication->Buffer[0] == 0x01 ) &&
 8031fd4:	6883      	ldr	r3, [r0, #8]
        if( ( mcpsIndication->BufferSize == 4 ) &&
 8031fd6:	7818      	ldrb	r0, [r3, #0]
 8031fd8:	2801      	cmp	r0, #1
 8031fda:	d12c      	bne.n	8032036 <LmhpComplianceOnMcpsIndication+0x92>
            ( mcpsIndication->Buffer[0] == 0x01 ) &&
 8031fdc:	7858      	ldrb	r0, [r3, #1]
 8031fde:	2801      	cmp	r0, #1
 8031fe0:	d129      	bne.n	8032036 <LmhpComplianceOnMcpsIndication+0x92>
            ( mcpsIndication->Buffer[1] == 0x01 ) &&
 8031fe2:	7898      	ldrb	r0, [r3, #2]
 8031fe4:	2801      	cmp	r0, #1
 8031fe6:	d126      	bne.n	8032036 <LmhpComplianceOnMcpsIndication+0x92>
            ( mcpsIndication->Buffer[2] == 0x01 ) &&
 8031fe8:	78db      	ldrb	r3, [r3, #3]
 8031fea:	2b01      	cmp	r3, #1
 8031fec:	d123      	bne.n	8032036 <LmhpComplianceOnMcpsIndication+0x92>
            ComplianceTestState.DataBufferSize = 2;
 8031fee:	2002      	movs	r0, #2
 8031ff0:	72a0      	strb	r0, [r4, #10]
            LoRaMacMibSetRequestConfirm( &mibReq );
 8031ff2:	a803      	add	r0, sp, #12
            ComplianceTestState.IsRunning = true;
 8031ff4:	7163      	strb	r3, [r4, #5]
            ComplianceTestState.State = 1;
 8031ff6:	80e3      	strh	r3, [r4, #6]
            mibReq.Param.AdrEnable = true;
 8031ff8:	f88d 3010 	strb.w	r3, [sp, #16]
            ComplianceTestState.Port = 224;
 8031ffc:	7221      	strb	r1, [r4, #8]
            mibReq.Type = MIB_ADR;
 8031ffe:	f88d 200c 	strb.w	r2, [sp, #12]
            ComplianceTestState.DownLinkCounter = 0;
 8032002:	6125      	str	r5, [r4, #16]
            ComplianceTestState.NbGateways = 0;
 8032004:	7525      	strb	r5, [r4, #20]
            LoRaMacMibSetRequestConfirm( &mibReq );
 8032006:	f002 fee3 	bl	8034dd0 <LoRaMacMibSetRequestConfirm>
            LoRaMacTestSetDutyCycleOn( false );
 803200a:	4628      	mov	r0, r5
 803200c:	f003 fc44 	bl	8035898 <LoRaMacTestSetDutyCycleOn>
            if( LmhpComplianceParams->StopPeripherals != NULL )
 8032010:	6823      	ldr	r3, [r4, #0]
 8032012:	685b      	ldr	r3, [r3, #4]
 8032014:	b103      	cbz	r3, 8032018 <LmhpComplianceOnMcpsIndication+0x74>
                LmhpComplianceParams->StopPeripherals( );
 8032016:	4798      	blx	r3
            TimerInit( &ComplianceTxNextPacketTimer, OnComplianceTxNextPacketTimerEvent );
 8032018:	2200      	movs	r2, #0
 803201a:	4b5b      	ldr	r3, [pc, #364]	; (8032188 <LmhpComplianceOnMcpsIndication+0x1e4>)
 803201c:	9200      	str	r2, [sp, #0]
 803201e:	f04f 31ff 	mov.w	r1, #4294967295
 8032022:	485a      	ldr	r0, [pc, #360]	; (803218c <LmhpComplianceOnMcpsIndication+0x1e8>)
 8032024:	f009 f92c 	bl	803b280 <UTIL_TIMER_Create>
            TimerSetValue( &ComplianceTxNextPacketTimer, COMPLIANCE_TX_DUTYCYCLE );
 8032028:	f241 3188 	movw	r1, #5000	; 0x1388
 803202c:	4857      	ldr	r0, [pc, #348]	; (803218c <LmhpComplianceOnMcpsIndication+0x1e8>)
 803202e:	f009 fa0f 	bl	803b450 <UTIL_TIMER_SetPeriod>
            LmhpComplianceTxProcess( );
 8032032:	f7ff ff77 	bl	8031f24 <LmhpComplianceTxProcess>
}
 8032036:	b00d      	add	sp, #52	; 0x34
 8032038:	bd30      	pop	{r4, r5, pc}
        ComplianceTestState.State = mcpsIndication->Buffer[0];
 803203a:	6883      	ldr	r3, [r0, #8]
 803203c:	781a      	ldrb	r2, [r3, #0]
 803203e:	71a2      	strb	r2, [r4, #6]
        switch( ComplianceTestState.State )
 8032040:	2a0a      	cmp	r2, #10
 8032042:	d8f8      	bhi.n	8032036 <LmhpComplianceOnMcpsIndication+0x92>
 8032044:	e8df f002 	tbb	[pc, r2]
 8032048:	27232006 	.word	0x27232006
 803204c:	60433c29 	.word	0x60433c29
 8032050:	8d8b      	.short	0x8d8b
 8032052:	97          	.byte	0x97
 8032053:	00          	.byte	0x00
                TimerStop( &ComplianceTxNextPacketTimer );
 8032054:	484d      	ldr	r0, [pc, #308]	; (803218c <LmhpComplianceOnMcpsIndication+0x1e8>)
 8032056:	f009 f971 	bl	803b33c <UTIL_TIMER_Stop>
                ComplianceTestState.DownLinkCounter = 0;
 803205a:	2300      	movs	r3, #0
 803205c:	8223      	strh	r3, [r4, #16]
                ComplianceTestState.IsRunning = false;
 803205e:	7163      	strb	r3, [r4, #5]
                mibReq.Type = MIB_ADR;
 8032060:	2304      	movs	r3, #4
 8032062:	f88d 300c 	strb.w	r3, [sp, #12]
                mibReq.Param.AdrEnable = LmhpComplianceParams->AdrEnabled;
 8032066:	6823      	ldr	r3, [r4, #0]
                LoRaMacMibSetRequestConfirm( &mibReq );
 8032068:	a803      	add	r0, sp, #12
                mibReq.Param.AdrEnable = LmhpComplianceParams->AdrEnabled;
 803206a:	781b      	ldrb	r3, [r3, #0]
 803206c:	f88d 3010 	strb.w	r3, [sp, #16]
                LoRaMacMibSetRequestConfirm( &mibReq );
 8032070:	f002 feae 	bl	8034dd0 <LoRaMacMibSetRequestConfirm>
                LoRaMacTestSetDutyCycleOn( LmhpComplianceParams->DutyCycleEnabled );
 8032074:	6823      	ldr	r3, [r4, #0]
 8032076:	7858      	ldrb	r0, [r3, #1]
 8032078:	f003 fc0e 	bl	8035898 <LoRaMacTestSetDutyCycleOn>
                if( LmhpComplianceParams->StartPeripherals != NULL )
 803207c:	6823      	ldr	r3, [r4, #0]
 803207e:	689b      	ldr	r3, [r3, #8]
 8032080:	2b00      	cmp	r3, #0
 8032082:	d0d8      	beq.n	8032036 <LmhpComplianceOnMcpsIndication+0x92>
                    LmhpComplianceParams->StartPeripherals( );
 8032084:	4798      	blx	r3
            break;
 8032086:	e7d6      	b.n	8032036 <LmhpComplianceOnMcpsIndication+0x92>
            ComplianceTestState.DataBufferSize = 2;
 8032088:	2302      	movs	r3, #2
 803208a:	72a3      	strb	r3, [r4, #10]
            break;
 803208c:	e7d3      	b.n	8032036 <LmhpComplianceOnMcpsIndication+0x92>
            ComplianceTestState.State = 1;
 803208e:	f240 1301 	movw	r3, #257	; 0x101
            ComplianceTestState.State = 1;
 8032092:	80e3      	strh	r3, [r4, #6]
            break;
 8032094:	e7cf      	b.n	8032036 <LmhpComplianceOnMcpsIndication+0x92>
            ComplianceTestState.State = 1;
 8032096:	2301      	movs	r3, #1
 8032098:	e7fb      	b.n	8032092 <LmhpComplianceOnMcpsIndication+0xee>
            ComplianceTestState.DataBuffer[0] = 4;
 803209a:	68e5      	ldr	r5, [r4, #12]
            ComplianceTestState.DataBufferSize = mcpsIndication->BufferSize;
 803209c:	7b03      	ldrb	r3, [r0, #12]
 803209e:	72a3      	strb	r3, [r4, #10]
            ComplianceTestState.DataBuffer[0] = 4;
 80320a0:	2204      	movs	r2, #4
 80320a2:	702a      	strb	r2, [r5, #0]
            for( uint8_t i = 1; i < MIN( ComplianceTestState.DataBufferSize, ComplianceTestState.DataBufferMaxSize ); i++ )
 80320a4:	7a62      	ldrb	r2, [r4, #9]
 80320a6:	429a      	cmp	r2, r3
 80320a8:	bf28      	it	cs
 80320aa:	461a      	movcs	r2, r3
 80320ac:	2300      	movs	r3, #0
 80320ae:	3301      	adds	r3, #1
 80320b0:	b2d9      	uxtb	r1, r3
 80320b2:	428a      	cmp	r2, r1
 80320b4:	d9bf      	bls.n	8032036 <LmhpComplianceOnMcpsIndication+0x92>
                ComplianceTestState.DataBuffer[i] = mcpsIndication->Buffer[i] + 1;
 80320b6:	6881      	ldr	r1, [r0, #8]
 80320b8:	5cc9      	ldrb	r1, [r1, r3]
 80320ba:	3101      	adds	r1, #1
 80320bc:	54e9      	strb	r1, [r5, r3]
            for( uint8_t i = 1; i < MIN( ComplianceTestState.DataBufferSize, ComplianceTestState.DataBufferMaxSize ); i++ )
 80320be:	e7f6      	b.n	80320ae <LmhpComplianceOnMcpsIndication+0x10a>
                mlmeReq.Type = MLME_LINK_CHECK;
 80320c0:	2304      	movs	r3, #4
                mlmeReq.Type = MLME_DEVICE_TIME;
 80320c2:	f88d 300c 	strb.w	r3, [sp, #12]
                LoRaMacMlmeRequest( &mlmeReq );
 80320c6:	a803      	add	r0, sp, #12
 80320c8:	f003 f96e 	bl	80353a8 <LoRaMacMlmeRequest>
            break;
 80320cc:	e7b3      	b.n	8032036 <LmhpComplianceOnMcpsIndication+0x92>
                TimerStop(&ComplianceTxNextPacketTimer);
 80320ce:	482f      	ldr	r0, [pc, #188]	; (803218c <LmhpComplianceOnMcpsIndication+0x1e8>)
 80320d0:	f009 f934 	bl	803b33c <UTIL_TIMER_Stop>
                ComplianceTestState.DownLinkCounter = 0;
 80320d4:	2300      	movs	r3, #0
 80320d6:	8223      	strh	r3, [r4, #16]
                ComplianceTestState.IsRunning = false;
 80320d8:	7163      	strb	r3, [r4, #5]
                mibReq.Type = MIB_ADR;
 80320da:	2304      	movs	r3, #4
 80320dc:	f88d 300c 	strb.w	r3, [sp, #12]
                mibReq.Param.AdrEnable = LmhpComplianceParams->AdrEnabled;
 80320e0:	6823      	ldr	r3, [r4, #0]
                LoRaMacMibSetRequestConfirm( &mibReq );
 80320e2:	a803      	add	r0, sp, #12
                mibReq.Param.AdrEnable = LmhpComplianceParams->AdrEnabled;
 80320e4:	781b      	ldrb	r3, [r3, #0]
 80320e6:	f88d 3010 	strb.w	r3, [sp, #16]
                LoRaMacMibSetRequestConfirm( &mibReq );
 80320ea:	f002 fe71 	bl	8034dd0 <LoRaMacMibSetRequestConfirm>
                LoRaMacTestSetDutyCycleOn( LmhpComplianceParams->DutyCycleEnabled );
 80320ee:	6823      	ldr	r3, [r4, #0]
 80320f0:	7858      	ldrb	r0, [r3, #1]
 80320f2:	f003 fbd1 	bl	8035898 <LoRaMacTestSetDutyCycleOn>
                if( LmhpComplianceParams->StartPeripherals != NULL )
 80320f6:	6823      	ldr	r3, [r4, #0]
 80320f8:	689b      	ldr	r3, [r3, #8]
 80320fa:	b103      	cbz	r3, 80320fe <LmhpComplianceOnMcpsIndication+0x15a>
                    LmhpComplianceParams->StartPeripherals( );
 80320fc:	4798      	blx	r3
                LmhpCompliancePackage.OnJoinRequest( ACTIVATION_TYPE_OTAA );
 80320fe:	4b24      	ldr	r3, [pc, #144]	; (8032190 <LmhpComplianceOnMcpsIndication+0x1ec>)
 8032100:	2002      	movs	r0, #2
 8032102:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8032104:	4798      	blx	r3
            break;
 8032106:	e796      	b.n	8032036 <LmhpComplianceOnMcpsIndication+0x92>
                if( mcpsIndication->BufferSize == 3 )
 8032108:	7b02      	ldrb	r2, [r0, #12]
 803210a:	2a03      	cmp	r2, #3
 803210c:	d10e      	bne.n	803212c <LmhpComplianceOnMcpsIndication+0x188>
                    mlmeReq.Type = MLME_TXCW;
 803210e:	2205      	movs	r2, #5
 8032110:	f88d 200c 	strb.w	r2, [sp, #12]
                    mlmeReq.Req.TxCw.Timeout = ( uint16_t )( ( mcpsIndication->Buffer[1] << 8 ) | mcpsIndication->Buffer[2] );
 8032114:	785a      	ldrb	r2, [r3, #1]
 8032116:	789b      	ldrb	r3, [r3, #2]
 8032118:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 803211c:	f8ad 3010 	strh.w	r3, [sp, #16]
                LoRaMacMlmeRequest( &mlmeReq );
 8032120:	a803      	add	r0, sp, #12
 8032122:	f003 f941 	bl	80353a8 <LoRaMacMlmeRequest>
                ComplianceTestState.State = 1;
 8032126:	2301      	movs	r3, #1
 8032128:	71a3      	strb	r3, [r4, #6]
            break;
 803212a:	e784      	b.n	8032036 <LmhpComplianceOnMcpsIndication+0x92>
                else if( mcpsIndication->BufferSize == 7 )
 803212c:	2a07      	cmp	r2, #7
 803212e:	d1f7      	bne.n	8032120 <LmhpComplianceOnMcpsIndication+0x17c>
                    mlmeReq.Type = MLME_TXCW_1;
 8032130:	2206      	movs	r2, #6
 8032132:	f88d 200c 	strb.w	r2, [sp, #12]
                    mlmeReq.Req.TxCw.Timeout = ( uint16_t )( ( mcpsIndication->Buffer[1] << 8 ) | mcpsIndication->Buffer[2] );
 8032136:	7859      	ldrb	r1, [r3, #1]
 8032138:	789a      	ldrb	r2, [r3, #2]
 803213a:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 803213e:	f8ad 2010 	strh.w	r2, [sp, #16]
                    mlmeReq.Req.TxCw.Frequency = ( uint32_t )( ( mcpsIndication->Buffer[3] << 16 ) | ( mcpsIndication->Buffer[4] << 8 ) | mcpsIndication->Buffer[5] ) * 100;
 8032142:	791a      	ldrb	r2, [r3, #4]
 8032144:	78d9      	ldrb	r1, [r3, #3]
 8032146:	0212      	lsls	r2, r2, #8
 8032148:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 803214c:	7959      	ldrb	r1, [r3, #5]
 803214e:	430a      	orrs	r2, r1
 8032150:	2164      	movs	r1, #100	; 0x64
 8032152:	434a      	muls	r2, r1
 8032154:	9205      	str	r2, [sp, #20]
                    mlmeReq.Req.TxCw.Power = mcpsIndication->Buffer[6];
 8032156:	799b      	ldrb	r3, [r3, #6]
 8032158:	f88d 3018 	strb.w	r3, [sp, #24]
 803215c:	e7e0      	b.n	8032120 <LmhpComplianceOnMcpsIndication+0x17c>
                mlmeReq.Type = MLME_DEVICE_TIME;
 803215e:	230a      	movs	r3, #10
 8032160:	e7af      	b.n	80320c2 <LmhpComplianceOnMcpsIndication+0x11e>
                mibReq.Type = MIB_DEVICE_CLASS;
 8032162:	2200      	movs	r2, #0
 8032164:	f88d 200c 	strb.w	r2, [sp, #12]
                mibReq.Param.Class = ( DeviceClass_t )mcpsIndication->Buffer[1];;
 8032168:	785b      	ldrb	r3, [r3, #1]
 803216a:	f88d 3010 	strb.w	r3, [sp, #16]
                LoRaMacMibSetRequestConfirm( &mibReq );
 803216e:	a803      	add	r0, sp, #12
 8032170:	f002 fe2e 	bl	8034dd0 <LoRaMacMibSetRequestConfirm>
            break;
 8032174:	e75f      	b.n	8032036 <LmhpComplianceOnMcpsIndication+0x92>
                mlmeReq.Type = MLME_PING_SLOT_INFO;
 8032176:	220d      	movs	r2, #13
 8032178:	f88d 200c 	strb.w	r2, [sp, #12]
                mlmeReq.Req.PingSlotInfo.PingSlot.Value = mcpsIndication->Buffer[1];
 803217c:	785b      	ldrb	r3, [r3, #1]
 803217e:	f88d 3010 	strb.w	r3, [sp, #16]
 8032182:	e7a0      	b.n	80320c6 <LmhpComplianceOnMcpsIndication+0x122>
 8032184:	2000495c 	.word	0x2000495c
 8032188:	08031fa1 	.word	0x08031fa1
 803218c:	20004974 	.word	0x20004974
 8032190:	200034c4 	.word	0x200034c4

08032194 <LmhpCompliancePackageFactory>:
}
 8032194:	4800      	ldr	r0, [pc, #0]	; (8032198 <LmhpCompliancePackageFactory+0x4>)
 8032196:	4770      	bx	lr
 8032198:	200034c4 	.word	0x200034c4

0803219c <__NVIC_SystemReset>:
  __ASM volatile ("dsb 0xF":::"memory");
 803219c:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 80321a0:	4905      	ldr	r1, [pc, #20]	; (80321b8 <__NVIC_SystemReset+0x1c>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 80321a2:	4b06      	ldr	r3, [pc, #24]	; (80321bc <__NVIC_SystemReset+0x20>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 80321a4:	68ca      	ldr	r2, [r1, #12]
 80321a6:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 80321aa:	4313      	orrs	r3, r2
 80321ac:	60cb      	str	r3, [r1, #12]
 80321ae:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 80321b2:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 80321b4:	e7fd      	b.n	80321b2 <__NVIC_SystemReset+0x16>
 80321b6:	bf00      	nop
 80321b8:	e000ed00 	.word	0xe000ed00
 80321bc:	05fa0004 	.word	0x05fa0004

080321c0 <LmhpFirmwareManagementIsInitialized>:
}

static bool LmhpFirmwareManagementIsInitialized(void)
{
  return LmhpFirmwareManagementState.Initialized;
}
 80321c0:	4b01      	ldr	r3, [pc, #4]	; (80321c8 <LmhpFirmwareManagementIsInitialized+0x8>)
 80321c2:	7818      	ldrb	r0, [r3, #0]
 80321c4:	4770      	bx	lr
 80321c6:	bf00      	nop
 80321c8:	2000498c 	.word	0x2000498c

080321cc <LmhpFirmwareManagementIsRunning>:

static bool LmhpFirmwareManagementIsRunning(void)
{
  if (LmhpFirmwareManagementState.Initialized == false)
 80321cc:	4b02      	ldr	r3, [pc, #8]	; (80321d8 <LmhpFirmwareManagementIsRunning+0xc>)
 80321ce:	7818      	ldrb	r0, [r3, #0]
 80321d0:	b100      	cbz	r0, 80321d4 <LmhpFirmwareManagementIsRunning+0x8>
  {
    return false;
  }

  return LmhpFirmwareManagementState.IsRunning;
 80321d2:	7858      	ldrb	r0, [r3, #1]
}
 80321d4:	4770      	bx	lr
 80321d6:	bf00      	nop
 80321d8:	2000498c 	.word	0x2000498c

080321dc <LmhpFirmwareManagementProcess>:

static void LmhpFirmwareManagementProcess(void)
{
  /* Not yet implemented */
}
 80321dc:	4770      	bx	lr

080321de <OnRebootTimer>:
    LmHandlerSetDutyCycleEnable(current_dutycycle);
  }
}

static void OnRebootTimer(void *context)
{
 80321de:	b508      	push	{r3, lr}
  NVIC_SystemReset();
 80321e0:	f7ff ffdc 	bl	803219c <__NVIC_SystemReset>

080321e4 <LmhpFirmwareManagementOnMcpsIndication>:
{
 80321e4:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_DELETE_IMAGE_ANS;
 80321e8:	f8df a1d8 	ldr.w	sl, [pc, #472]	; 80323c4 <LmhpFirmwareManagementOnMcpsIndication+0x1e0>
          rebootTimeAns = rebootTimeReq - (curTime.Seconds - UNIX_GPS_EPOCH_OFFSET);
 80321ec:	f8df 91dc 	ldr.w	r9, [pc, #476]	; 80323cc <LmhpFirmwareManagementOnMcpsIndication+0x1e8>
  uint8_t dataBufferIndex = 0;
 80321f0:	2400      	movs	r4, #0
{
 80321f2:	4680      	mov	r8, r0
  uint8_t cmdIndex = 0;
 80321f4:	4623      	mov	r3, r4
            TimerSetValue(&RebootTimer, rebootCountdown * 1000);
 80321f6:	f10a 0708 	add.w	r7, sl, #8
  while (cmdIndex < mcpsIndication->BufferSize)
 80321fa:	f898 200c 	ldrb.w	r2, [r8, #12]
 80321fe:	429a      	cmp	r2, r3
 8032200:	d81d      	bhi.n	803223e <LmhpFirmwareManagementOnMcpsIndication+0x5a>
  if (dataBufferIndex != 0)
 8032202:	b1cc      	cbz	r4, 8032238 <LmhpFirmwareManagementOnMcpsIndication+0x54>
    LmHandlerAppData_t appData =
 8032204:	23cb      	movs	r3, #203	; 0xcb
 8032206:	f88d 3008 	strb.w	r3, [sp, #8]
      .Buffer = LmhpFirmwareManagementState.DataBuffer,
 803220a:	4b6e      	ldr	r3, [pc, #440]	; (80323c4 <LmhpFirmwareManagementOnMcpsIndication+0x1e0>)
    LmHandlerAppData_t appData =
 803220c:	f88d 4009 	strb.w	r4, [sp, #9]
 8032210:	685b      	ldr	r3, [r3, #4]
 8032212:	9303      	str	r3, [sp, #12]
    LmHandlerGetDutyCycleEnable(&current_dutycycle);
 8032214:	f10d 0007 	add.w	r0, sp, #7
 8032218:	f7ff fc82 	bl	8031b20 <LmHandlerGetDutyCycleEnable>
    LmHandlerSetDutyCycleEnable(false);
 803221c:	2000      	movs	r0, #0
 803221e:	f7ff fc8b 	bl	8031b38 <LmHandlerSetDutyCycleEnable>
    LmhpFirmwareManagementPackage.OnSendRequest(&appData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true);
 8032222:	4b69      	ldr	r3, [pc, #420]	; (80323c8 <LmhpFirmwareManagementOnMcpsIndication+0x1e4>)
 8032224:	2200      	movs	r2, #0
 8032226:	6a9c      	ldr	r4, [r3, #40]	; 0x28
 8032228:	4611      	mov	r1, r2
 803222a:	2301      	movs	r3, #1
 803222c:	a802      	add	r0, sp, #8
 803222e:	47a0      	blx	r4
    LmHandlerSetDutyCycleEnable(current_dutycycle);
 8032230:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8032234:	f7ff fc80 	bl	8031b38 <LmHandlerSetDutyCycleEnable>
}
 8032238:	b004      	add	sp, #16
 803223a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    switch (mcpsIndication->Buffer[cmdIndex++])
 803223e:	f8d8 2008 	ldr.w	r2, [r8, #8]
 8032242:	5cd1      	ldrb	r1, [r2, r3]
 8032244:	1c5e      	adds	r6, r3, #1
 8032246:	b2f6      	uxtb	r6, r6
 8032248:	2905      	cmp	r1, #5
 803224a:	d832      	bhi.n	80322b2 <LmhpFirmwareManagementOnMcpsIndication+0xce>
 803224c:	e8df f001 	tbb	[pc, r1]
 8032250:	75331103 	.word	0x75331103
 8032254:	b0a5      	.short	0xb0a5
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_PKG_VERSION_ANS;
 8032256:	1c61      	adds	r1, r4, #1
 8032258:	f8da 2004 	ldr.w	r2, [sl, #4]
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_ID;
 803225c:	b2c9      	uxtb	r1, r1
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_PKG_VERSION_ANS;
 803225e:	2300      	movs	r3, #0
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_ID;
 8032260:	2004      	movs	r0, #4
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_PKG_VERSION_ANS;
 8032262:	5513      	strb	r3, [r2, r4]
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_ID;
 8032264:	1ca3      	adds	r3, r4, #2
 8032266:	5450      	strb	r0, [r2, r1]
 8032268:	b2db      	uxtb	r3, r3
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_VERSION;
 803226a:	3403      	adds	r4, #3
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = 0x01;
 803226c:	b2e4      	uxtb	r4, r4
 803226e:	2101      	movs	r1, #1
 8032270:	e09c      	b.n	80323ac <LmhpFirmwareManagementOnMcpsIndication+0x1c8>
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_VERSION_ANS;
 8032272:	2201      	movs	r2, #1
 8032274:	f8da 3004 	ldr.w	r3, [sl, #4]
 8032278:	18a1      	adds	r1, r4, r2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (FW_VERSION >> 0) & 0xFF;
 803227a:	b2c9      	uxtb	r1, r1
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_VERSION_ANS;
 803227c:	551a      	strb	r2, [r3, r4]
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (FW_VERSION >> 0) & 0xFF;
 803227e:	2200      	movs	r2, #0
 8032280:	545a      	strb	r2, [r3, r1]
 8032282:	1ca1      	adds	r1, r4, #2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (FW_VERSION >> 8) & 0xFF;
 8032284:	b2c9      	uxtb	r1, r1
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (HW_VERSION >> 8) & 0xFF;
 8032286:	1de0      	adds	r0, r4, #7
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (FW_VERSION >> 8) & 0xFF;
 8032288:	545a      	strb	r2, [r3, r1]
 803228a:	1ce1      	adds	r1, r4, #3
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (FW_VERSION >> 16) & 0xFF;
 803228c:	b2c9      	uxtb	r1, r1
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (HW_VERSION >> 16) & 0xFF;
 803228e:	b2c0      	uxtb	r0, r0
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (FW_VERSION >> 16) & 0xFF;
 8032290:	545a      	strb	r2, [r3, r1]
 8032292:	1d21      	adds	r1, r4, #4
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (FW_VERSION >> 24) & 0xFF;
 8032294:	b2c9      	uxtb	r1, r1
 8032296:	545a      	strb	r2, [r3, r1]
 8032298:	1d61      	adds	r1, r4, #5
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (HW_VERSION >> 0) & 0xFF;
 803229a:	b2c9      	uxtb	r1, r1
 803229c:	545a      	strb	r2, [r3, r1]
 803229e:	1da1      	adds	r1, r4, #6
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (HW_VERSION >> 8) & 0xFF;
 80322a0:	b2c9      	uxtb	r1, r1
 80322a2:	545a      	strb	r2, [r3, r1]
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (HW_VERSION >> 16) & 0xFF;
 80322a4:	f104 0108 	add.w	r1, r4, #8
 80322a8:	b2c9      	uxtb	r1, r1
 80322aa:	541a      	strb	r2, [r3, r0]
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (HW_VERSION >> 24) & 0xFF;
 80322ac:	3409      	adds	r4, #9
 80322ae:	545a      	strb	r2, [r3, r1]
 80322b0:	b2e4      	uxtb	r4, r4
{
 80322b2:	4633      	mov	r3, r6
 80322b4:	e7a1      	b.n	80321fa <LmhpFirmwareManagementOnMcpsIndication+0x16>
        rebootTimeReq  = (mcpsIndication->Buffer[cmdIndex++] << 0) & 0x000000FF;
 80322b6:	1c99      	adds	r1, r3, #2
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 8) & 0x0000FF00;
 80322b8:	b2c9      	uxtb	r1, r1
        rebootTimeReq  = (mcpsIndication->Buffer[cmdIndex++] << 0) & 0x000000FF;
 80322ba:	5d90      	ldrb	r0, [r2, r6]
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 8) & 0x0000FF00;
 80322bc:	5c56      	ldrb	r6, [r2, r1]
 80322be:	1cd9      	adds	r1, r3, #3
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 16) & 0x00FF0000;
 80322c0:	b2c9      	uxtb	r1, r1
 80322c2:	5c55      	ldrb	r5, [r2, r1]
 80322c4:	042d      	lsls	r5, r5, #16
 80322c6:	eb05 2506 	add.w	r5, r5, r6, lsl #8
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 24) & 0xFF000000;
 80322ca:	1d5e      	adds	r6, r3, #5
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 16) & 0x00FF0000;
 80322cc:	3304      	adds	r3, #4
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 24) & 0xFF000000;
 80322ce:	b2db      	uxtb	r3, r3
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 16) & 0x00FF0000;
 80322d0:	4405      	add	r5, r0
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 24) & 0xFF000000;
 80322d2:	5cd3      	ldrb	r3, [r2, r3]
        if (rebootTimeReq == 0)
 80322d4:	eb15 6503 	adds.w	r5, r5, r3, lsl #24
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 24) & 0xFF000000;
 80322d8:	b2f6      	uxtb	r6, r6
        if (rebootTimeReq == 0)
 80322da:	d101      	bne.n	80322e0 <LmhpFirmwareManagementOnMcpsIndication+0xfc>
          NVIC_SystemReset();
 80322dc:	f7ff ff5e 	bl	803219c <__NVIC_SystemReset>
        else if (rebootTimeReq == 0xFFFFFFFF)
 80322e0:	1c6b      	adds	r3, r5, #1
 80322e2:	d118      	bne.n	8032316 <LmhpFirmwareManagementOnMcpsIndication+0x132>
          TimerStop(&RebootTimer);
 80322e4:	4638      	mov	r0, r7
 80322e6:	f009 f829 	bl	803b33c <UTIL_TIMER_Stop>
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_REBOOT_TIME_ANS;
 80322ea:	f8da 3004 	ldr.w	r3, [sl, #4]
 80322ee:	2202      	movs	r2, #2
 80322f0:	551a      	strb	r2, [r3, r4]
 80322f2:	1c62      	adds	r2, r4, #1
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 0) & 0xFF;
 80322f4:	b2d2      	uxtb	r2, r2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 8) & 0xFF;
 80322f6:	0a29      	lsrs	r1, r5, #8
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 0) & 0xFF;
 80322f8:	549d      	strb	r5, [r3, r2]
 80322fa:	1ca2      	adds	r2, r4, #2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 8) & 0xFF;
 80322fc:	b2d2      	uxtb	r2, r2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 16) & 0xFF;
 80322fe:	0c28      	lsrs	r0, r5, #16
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 8) & 0xFF;
 8032300:	5499      	strb	r1, [r3, r2]
 8032302:	1ce1      	adds	r1, r4, #3
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 16) & 0xFF;
 8032304:	b2c9      	uxtb	r1, r1
 8032306:	1d22      	adds	r2, r4, #4
 8032308:	5458      	strb	r0, [r3, r1]
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 24) & 0xFF;
 803230a:	3405      	adds	r4, #5
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 16) & 0xFF;
 803230c:	b2d2      	uxtb	r2, r2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 24) & 0xFF;
 803230e:	b2e4      	uxtb	r4, r4
 8032310:	0e2d      	lsrs	r5, r5, #24
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootCountdown >> 16) & 0xFF;
 8032312:	549d      	strb	r5, [r3, r2]
        break;
 8032314:	e7cd      	b.n	80322b2 <LmhpFirmwareManagementOnMcpsIndication+0xce>
          curTime = SysTimeGet();
 8032316:	a802      	add	r0, sp, #8
 8032318:	f008 ff22 	bl	803b160 <SysTimeGet>
          rebootTimeAns = rebootTimeReq - (curTime.Seconds - UNIX_GPS_EPOCH_OFFSET);
 803231c:	9b02      	ldr	r3, [sp, #8]
 803231e:	eba9 0303 	sub.w	r3, r9, r3
          if (rebootTimeAns > 0)
 8032322:	18ed      	adds	r5, r5, r3
 8032324:	d0e1      	beq.n	80322ea <LmhpFirmwareManagementOnMcpsIndication+0x106>
            TimerSetValue(&RebootTimer, rebootTimeAns * 1000);
 8032326:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 803232a:	4369      	muls	r1, r5
 803232c:	4638      	mov	r0, r7
 803232e:	f009 f88f 	bl	803b450 <UTIL_TIMER_SetPeriod>
            TimerStart(&RebootTimer);
 8032332:	4638      	mov	r0, r7
 8032334:	f009 f852 	bl	803b3dc <UTIL_TIMER_Start>
 8032338:	e7d7      	b.n	80322ea <LmhpFirmwareManagementOnMcpsIndication+0x106>
        rebootCountdown  = (mcpsIndication->Buffer[cmdIndex++] << 0) & 0x000000FF;
 803233a:	5d91      	ldrb	r1, [r2, r6]
 803233c:	1c98      	adds	r0, r3, #2
        rebootCountdown += (mcpsIndication->Buffer[cmdIndex++] << 16) & 0x00FF0000;
 803233e:	1d1e      	adds	r6, r3, #4
        rebootCountdown += (mcpsIndication->Buffer[cmdIndex++] << 8) & 0x0000FF00;
 8032340:	3303      	adds	r3, #3
        rebootCountdown += (mcpsIndication->Buffer[cmdIndex++] << 16) & 0x00FF0000;
 8032342:	b2db      	uxtb	r3, r3
        rebootCountdown += (mcpsIndication->Buffer[cmdIndex++] << 8) & 0x0000FF00;
 8032344:	b2c0      	uxtb	r0, r0
        rebootCountdown += (mcpsIndication->Buffer[cmdIndex++] << 16) & 0x00FF0000;
 8032346:	5cd5      	ldrb	r5, [r2, r3]
        rebootCountdown += (mcpsIndication->Buffer[cmdIndex++] << 8) & 0x0000FF00;
 8032348:	5c10      	ldrb	r0, [r2, r0]
        rebootCountdown += (mcpsIndication->Buffer[cmdIndex++] << 16) & 0x00FF0000;
 803234a:	042d      	lsls	r5, r5, #16
 803234c:	eb05 2500 	add.w	r5, r5, r0, lsl #8
        if (rebootCountdown == 0)
 8032350:	186d      	adds	r5, r5, r1
        rebootCountdown += (mcpsIndication->Buffer[cmdIndex++] << 16) & 0x00FF0000;
 8032352:	b2f6      	uxtb	r6, r6
        if (rebootCountdown == 0)
 8032354:	d0c2      	beq.n	80322dc <LmhpFirmwareManagementOnMcpsIndication+0xf8>
        else if (rebootCountdown == 0xFFFFFF)
 8032356:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 803235a:	429d      	cmp	r5, r3
 803235c:	d113      	bne.n	8032386 <LmhpFirmwareManagementOnMcpsIndication+0x1a2>
          TimerStop(&RebootTimer);
 803235e:	4638      	mov	r0, r7
 8032360:	f008 ffec 	bl	803b33c <UTIL_TIMER_Stop>
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_REBOOT_COUNTDOWN_ANS;
 8032364:	f8da 3004 	ldr.w	r3, [sl, #4]
 8032368:	2203      	movs	r2, #3
 803236a:	551a      	strb	r2, [r3, r4]
 803236c:	1c62      	adds	r2, r4, #1
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootCountdown >> 0) & 0xFF;
 803236e:	b2d2      	uxtb	r2, r2
 8032370:	1ca1      	adds	r1, r4, #2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootCountdown >> 8) & 0xFF;
 8032372:	b2c9      	uxtb	r1, r1
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootCountdown >> 0) & 0xFF;
 8032374:	549d      	strb	r5, [r3, r2]
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootCountdown >> 8) & 0xFF;
 8032376:	0a28      	lsrs	r0, r5, #8
 8032378:	1ce2      	adds	r2, r4, #3
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootCountdown >> 16) & 0xFF;
 803237a:	3404      	adds	r4, #4
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootCountdown >> 8) & 0xFF;
 803237c:	5458      	strb	r0, [r3, r1]
 803237e:	b2d2      	uxtb	r2, r2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootCountdown >> 16) & 0xFF;
 8032380:	b2e4      	uxtb	r4, r4
 8032382:	0c2d      	lsrs	r5, r5, #16
 8032384:	e7c5      	b.n	8032312 <LmhpFirmwareManagementOnMcpsIndication+0x12e>
            TimerSetValue(&RebootTimer, rebootCountdown * 1000);
 8032386:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 803238a:	4369      	muls	r1, r5
 803238c:	4638      	mov	r0, r7
 803238e:	f009 f85f 	bl	803b450 <UTIL_TIMER_SetPeriod>
            TimerStart(&RebootTimer);
 8032392:	4638      	mov	r0, r7
 8032394:	f009 f822 	bl	803b3dc <UTIL_TIMER_Start>
 8032398:	e7e4      	b.n	8032364 <LmhpFirmwareManagementOnMcpsIndication+0x180>
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_UPGRADE_IMAGE_ANS;
 803239a:	f8da 2004 	ldr.w	r2, [sl, #4]
 803239e:	2104      	movs	r1, #4
 80323a0:	5511      	strb	r1, [r2, r4]
 80323a2:	1c63      	adds	r3, r4, #1
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = imageStatus & 0x03;
 80323a4:	3402      	adds	r4, #2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_UPGRADE_IMAGE_ANS;
 80323a6:	b2db      	uxtb	r3, r3
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = imageStatus & 0x03;
 80323a8:	b2e4      	uxtb	r4, r4
 80323aa:	2100      	movs	r1, #0
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = 0x01;
 80323ac:	54d1      	strb	r1, [r2, r3]
        break;
 80323ae:	e780      	b.n	80322b2 <LmhpFirmwareManagementOnMcpsIndication+0xce>
        firmwareVersion += (mcpsIndication->Buffer[cmdIndex++] << 24) & 0xFF000000;
 80323b0:	3305      	adds	r3, #5
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_DELETE_IMAGE_ANS;
 80323b2:	f8da 2004 	ldr.w	r2, [sl, #4]
        firmwareVersion += (mcpsIndication->Buffer[cmdIndex++] << 24) & 0xFF000000;
 80323b6:	b2de      	uxtb	r6, r3
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_DELETE_IMAGE_ANS;
 80323b8:	2105      	movs	r1, #5
 80323ba:	1c63      	adds	r3, r4, #1
 80323bc:	5511      	strb	r1, [r2, r4]
 80323be:	b2db      	uxtb	r3, r3
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = 0x01;
 80323c0:	3402      	adds	r4, #2
 80323c2:	e753      	b.n	803226c <LmhpFirmwareManagementOnMcpsIndication+0x88>
 80323c4:	2000498c 	.word	0x2000498c
 80323c8:	200034f8 	.word	0x200034f8
 80323cc:	12d53d80 	.word	0x12d53d80

080323d0 <LmhpFirmwareManagementInit>:
{
 80323d0:	b507      	push	{r0, r1, r2, lr}
 80323d2:	480a      	ldr	r0, [pc, #40]	; (80323fc <LmhpFirmwareManagementInit+0x2c>)
  if (dataBuffer != NULL)
 80323d4:	b179      	cbz	r1, 80323f6 <LmhpFirmwareManagementInit+0x26>
    LmhpFirmwareManagementState.DataBufferMaxSize = dataBufferMaxSize;
 80323d6:	7082      	strb	r2, [r0, #2]
    LmhpFirmwareManagementState.Initialized = true;
 80323d8:	f240 1301 	movw	r3, #257	; 0x101
    TimerInit(&RebootTimer, OnRebootTimer);
 80323dc:	2200      	movs	r2, #0
    LmhpFirmwareManagementState.DataBuffer = dataBuffer;
 80323de:	6041      	str	r1, [r0, #4]
    LmhpFirmwareManagementState.Initialized = true;
 80323e0:	f820 3b08 	strh.w	r3, [r0], #8
    TimerInit(&RebootTimer, OnRebootTimer);
 80323e4:	f04f 31ff 	mov.w	r1, #4294967295
 80323e8:	4b05      	ldr	r3, [pc, #20]	; (8032400 <LmhpFirmwareManagementInit+0x30>)
 80323ea:	9200      	str	r2, [sp, #0]
 80323ec:	f008 ff48 	bl	803b280 <UTIL_TIMER_Create>
}
 80323f0:	b003      	add	sp, #12
 80323f2:	f85d fb04 	ldr.w	pc, [sp], #4
    LmhpFirmwareManagementState.Initialized = false;
 80323f6:	8001      	strh	r1, [r0, #0]
}
 80323f8:	e7fa      	b.n	80323f0 <LmhpFirmwareManagementInit+0x20>
 80323fa:	bf00      	nop
 80323fc:	2000498c 	.word	0x2000498c
 8032400:	080321df 	.word	0x080321df

08032404 <LmhpFirmwareManagementPackageFactory>:
}
 8032404:	4800      	ldr	r0, [pc, #0]	; (8032408 <LmhpFirmwareManagementPackageFactory+0x4>)
 8032406:	4770      	bx	lr
 8032408:	200034f8 	.word	0x200034f8

0803240c <LmhpFragmentationIsInitialized>:
}

static bool LmhpFragmentationIsInitialized( void )
{
    return LmhpFragmentationState.Initialized;
}
 803240c:	4b01      	ldr	r3, [pc, #4]	; (8032414 <LmhpFragmentationIsInitialized+0x8>)
 803240e:	7818      	ldrb	r0, [r3, #0]
 8032410:	4770      	bx	lr
 8032412:	bf00      	nop
 8032414:	200049ac 	.word	0x200049ac

08032418 <LmhpFragmentationIsRunning>:

static bool LmhpFragmentationIsRunning( void )
{
    if( LmhpFragmentationState.Initialized == false )
 8032418:	4b02      	ldr	r3, [pc, #8]	; (8032424 <LmhpFragmentationIsRunning+0xc>)
 803241a:	7818      	ldrb	r0, [r3, #0]
 803241c:	b100      	cbz	r0, 8032420 <LmhpFragmentationIsRunning+0x8>
    {
        return false;
    }

    return LmhpFragmentationState.IsRunning;
 803241e:	7858      	ldrb	r0, [r3, #1]
}
 8032420:	4770      	bx	lr
 8032422:	bf00      	nop
 8032424:	200049ac 	.word	0x200049ac

08032428 <LmhpFragmentationInit>:
{
 8032428:	b513      	push	{r0, r1, r4, lr}
 803242a:	4c0f      	ldr	r4, [pc, #60]	; (8032468 <LmhpFragmentationInit+0x40>)
    if( ( params != NULL ) && ( dataBuffer != NULL ) )
 803242c:	b1c0      	cbz	r0, 8032460 <LmhpFragmentationInit+0x38>
 803242e:	b1b9      	cbz	r1, 8032460 <LmhpFragmentationInit+0x38>
        LmhpFragmentationState.Initialized = true;
 8032430:	f240 1301 	movw	r3, #257	; 0x101
        LmhpFragmentationState.DataBufferMaxSize = dataBufferMaxSize;
 8032434:	70e2      	strb	r2, [r4, #3]
        TxDelayTime = 0;
 8032436:	2200      	movs	r2, #0
        LmhpFragmentationParams = ( LmhpFragmentationParams_t* )params;
 8032438:	60e0      	str	r0, [r4, #12]
        LmhpFragmentationState.DataBuffer = dataBuffer;
 803243a:	6061      	str	r1, [r4, #4]
        LmhpFragmentationState.Initialized = true;
 803243c:	8023      	strh	r3, [r4, #0]
        TimerInit( &FragmentTxDelayTimer, OnFragmentTxDelay );
 803243e:	9200      	str	r2, [sp, #0]
 8032440:	4b0a      	ldr	r3, [pc, #40]	; (803246c <LmhpFragmentationInit+0x44>)
        TxDelayTime = 0;
 8032442:	6122      	str	r2, [r4, #16]
        TimerInit( &FragmentTxDelayTimer, OnFragmentTxDelay );
 8032444:	f04f 31ff 	mov.w	r1, #4294967295
 8032448:	f104 0014 	add.w	r0, r4, #20
 803244c:	f008 ff18 	bl	803b280 <UTIL_TIMER_Create>
    UTIL_MEM_set_8( FragSessionData, 0, sizeof(FragSessionData) );
 8032450:	4807      	ldr	r0, [pc, #28]	; (8032470 <LmhpFragmentationInit+0x48>)
 8032452:	2260      	movs	r2, #96	; 0x60
 8032454:	2100      	movs	r1, #0
}
 8032456:	b002      	add	sp, #8
 8032458:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    UTIL_MEM_set_8( FragSessionData, 0, sizeof(FragSessionData) );
 803245c:	f008 bd5e 	b.w	803af1c <UTIL_MEM_set_8>
        LmhpFragmentationParams = NULL;
 8032460:	2300      	movs	r3, #0
 8032462:	60e3      	str	r3, [r4, #12]
        LmhpFragmentationState.Initialized = false;
 8032464:	8023      	strh	r3, [r4, #0]
 8032466:	e7f3      	b.n	8032450 <LmhpFragmentationInit+0x28>
 8032468:	200049ac 	.word	0x200049ac
 803246c:	08032475 	.word	0x08032475
 8032470:	200049d8 	.word	0x200049d8

08032474 <OnFragmentTxDelay>:
{
 8032474:	b510      	push	{r4, lr}
    TimerStop( &FragmentTxDelayTimer );
 8032476:	4c06      	ldr	r4, [pc, #24]	; (8032490 <OnFragmentTxDelay+0x1c>)
 8032478:	f104 0014 	add.w	r0, r4, #20
 803247c:	f008 ff5e 	bl	803b33c <UTIL_TIMER_Stop>
    LmhpFragmentationState.TxDelayState = FRAGMENTATION_TX_DELAY_STATE_PENDING;
 8032480:	2302      	movs	r3, #2
 8032482:	70a3      	strb	r3, [r4, #2]
    LmhpFragmentationPackage.OnPackageProcessEvent();
 8032484:	4b03      	ldr	r3, [pc, #12]	; (8032494 <OnFragmentTxDelay+0x20>)
}
 8032486:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    LmhpFragmentationPackage.OnPackageProcessEvent();
 803248a:	695b      	ldr	r3, [r3, #20]
 803248c:	4718      	bx	r3
 803248e:	bf00      	nop
 8032490:	200049ac 	.word	0x200049ac
 8032494:	2000352c 	.word	0x2000352c

08032498 <LmhpFragmentationOnMcpsIndication>:
            break;
    }
}

static void LmhpFragmentationOnMcpsIndication( McpsIndication_t *mcpsIndication )
{
 8032498:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    // Answer struct for the commands.
    LmHandlerAppData_t cmdReplyAppData;
    // Co-efficient used to calculate delay.
    uint8_t blockAckDelay = 0;

    if( mcpsIndication->Port != FRAGMENTATION_PORT )
 803249c:	78c3      	ldrb	r3, [r0, #3]
 803249e:	2bc9      	cmp	r3, #201	; 0xc9
{
 80324a0:	b093      	sub	sp, #76	; 0x4c
 80324a2:	4607      	mov	r7, r0
    if( mcpsIndication->Port != FRAGMENTATION_PORT )
 80324a4:	d12a      	bne.n	80324fc <LmhpFragmentationOnMcpsIndication+0x64>
    uint8_t blockAckDelay = 0;
 80324a6:	2300      	movs	r3, #0
                fragCounter = ( mcpsIndication->Buffer[cmdIndex++] << 0 ) & 0x00FF;
                fragCounter |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;

                fragIndex = ( fragCounter >> 14 ) & 0x03;
                fragCounter &= 0x3FFF;
                if (FragSessionData[fragIndex].FragGroupData.IsActive == false)
 80324a8:	4eb8      	ldr	r6, [pc, #736]	; (803278c <LmhpFragmentationOnMcpsIndication+0x2f4>)
    uint8_t blockAckDelay = 0;
 80324aa:	9301      	str	r3, [sp, #4]
    bool isAnswerDelayed = false;
 80324ac:	4699      	mov	r9, r3
    uint8_t dataBufferIndex = 0;
 80324ae:	461c      	mov	r4, r3
    uint8_t cmdIndex = 0;
 80324b0:	469b      	mov	fp, r3
    while( cmdIndex < mcpsIndication->BufferSize )
 80324b2:	7b39      	ldrb	r1, [r7, #12]
 80324b4:	458b      	cmp	fp, r1
 80324b6:	d324      	bcc.n	8032502 <LmhpFragmentationOnMcpsIndication+0x6a>

    // After processing the commands, if the end-node has to reply back then a flag is checked if the
    // reply is to be sent immediately or with a delay.
    // In some scenarios it is not desired that multiple end-notes send uplinks at the same time to
    // the same server. (Example: Fragment status during a multicast FUOTA)
    if( dataBufferIndex != 0 )
 80324b8:	b304      	cbz	r4, 80324fc <LmhpFragmentationOnMcpsIndication+0x64>
    {
        // Prepare Answer that is to be transmitted
        cmdReplyAppData.Buffer = LmhpFragmentationState.DataBuffer;
 80324ba:	4db4      	ldr	r5, [pc, #720]	; (803278c <LmhpFragmentationOnMcpsIndication+0x2f4>)
        cmdReplyAppData.BufferSize = dataBufferIndex;
 80324bc:	f88d 4031 	strb.w	r4, [sp, #49]	; 0x31
        cmdReplyAppData.Buffer = LmhpFragmentationState.DataBuffer;
 80324c0:	686b      	ldr	r3, [r5, #4]
 80324c2:	930d      	str	r3, [sp, #52]	; 0x34
        cmdReplyAppData.Port = FRAGMENTATION_PORT;
 80324c4:	23c9      	movs	r3, #201	; 0xc9
 80324c6:	4eb2      	ldr	r6, [pc, #712]	; (8032790 <LmhpFragmentationOnMcpsIndication+0x2f8>)
 80324c8:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30

        if( isAnswerDelayed == true )
 80324cc:	ac0c      	add	r4, sp, #48	; 0x30
 80324ce:	f1b9 0f00 	cmp.w	r9, #0
 80324d2:	f000 81ae 	beq.w	8032832 <LmhpFragmentationOnMcpsIndication+0x39a>
            // Delay = Pseudo Random Delay * 1000 milli seconds.
            // Eg: blockAckDelay = 7
            //     Pseudo Random Delay = rand(0:1) * 2^11
            //     rand(0:1) seconds = rand(0:1000) milliseconds
            //     Delay = rand(0:1000) * 2048 => 2048000ms = 34 minutes
            TxDelayTime = randr( 0, 1000 ) * ( 1 << ( blockAckDelay + 4 ) );
 80324d6:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 80324da:	2000      	movs	r0, #0
 80324dc:	f006 fd0a 	bl	8038ef4 <randr>
 80324e0:	9b01      	ldr	r3, [sp, #4]
 80324e2:	3304      	adds	r3, #4
 80324e4:	fa00 f303 	lsl.w	r3, r0, r3
            DelayedReplyAppData = cmdReplyAppData;
 80324e8:	e894 0003 	ldmia.w	r4, {r0, r1}
            TxDelayTime = randr( 0, 1000 ) * ( 1 << ( blockAckDelay + 4 ) );
 80324ec:	612b      	str	r3, [r5, #16]
            DelayedReplyAppData = cmdReplyAppData;
 80324ee:	4ba9      	ldr	r3, [pc, #676]	; (8032794 <LmhpFragmentationOnMcpsIndication+0x2fc>)
 80324f0:	e883 0003 	stmia.w	r3, {r0, r1}
            LmhpFragmentationState.TxDelayState = FRAGMENTATION_TX_DELAY_STATE_START;
 80324f4:	2301      	movs	r3, #1
 80324f6:	70ab      	strb	r3, [r5, #2]
            LmhpFragmentationPackage.OnPackageProcessEvent();
 80324f8:	6973      	ldr	r3, [r6, #20]
 80324fa:	4798      	blx	r3

            /* restore initial Duty Cycle */
            LmHandlerSetDutyCycleEnable( current_dutycycle );
        }
    }
}
 80324fc:	b013      	add	sp, #76	; 0x4c
 80324fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        switch( mcpsIndication->Buffer[cmdIndex++] )
 8032502:	68bb      	ldr	r3, [r7, #8]
 8032504:	f813 200b 	ldrb.w	r2, [r3, fp]
 8032508:	f10b 0a01 	add.w	sl, fp, #1
 803250c:	fa5f fa8a 	uxtb.w	sl, sl
 8032510:	2a08      	cmp	r2, #8
 8032512:	d81a      	bhi.n	803254a <LmhpFragmentationOnMcpsIndication+0xb2>
 8032514:	e8df f012 	tbh	[pc, r2, lsl #1]
 8032518:	001b0009 	.word	0x001b0009
 803251c:	00ef005d 	.word	0x00ef005d
 8032520:	00190019 	.word	0x00190019
 8032524:	00190019 	.word	0x00190019
 8032528:	0111      	.short	0x0111
                if( mcpsIndication->Multicast == 1 )
 803252a:	78bb      	ldrb	r3, [r7, #2]
 803252c:	2b01      	cmp	r3, #1
 803252e:	d00c      	beq.n	803254a <LmhpFragmentationOnMcpsIndication+0xb2>
                LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FRAGMENTATION_PKG_VERSION_ANS;
 8032530:	6872      	ldr	r2, [r6, #4]
 8032532:	2300      	movs	r3, #0
 8032534:	1c61      	adds	r1, r4, #1
 8032536:	5513      	strb	r3, [r2, r4]
                LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FRAGMENTATION_ID;
 8032538:	b2c9      	uxtb	r1, r1
 803253a:	1ca3      	adds	r3, r4, #2
 803253c:	2003      	movs	r0, #3
 803253e:	b2db      	uxtb	r3, r3
 8032540:	5450      	strb	r0, [r2, r1]
                LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FRAGMENTATION_VERSION;
 8032542:	2101      	movs	r1, #1
 8032544:	4404      	add	r4, r0
 8032546:	54d1      	strb	r1, [r2, r3]
 8032548:	b2e4      	uxtb	r4, r4
                break;
 803254a:	46d3      	mov	fp, sl
 803254c:	e7b1      	b.n	80324b2 <LmhpFragmentationOnMcpsIndication+0x1a>
                uint8_t fragIndex = mcpsIndication->Buffer[cmdIndex++];
 803254e:	f813 a00a 	ldrb.w	sl, [r3, sl]
                FragSessionData[fragIndex].FragDecoderStatus = FragDecoderGetStatus( );
 8032552:	a808      	add	r0, sp, #32
 8032554:	2318      	movs	r3, #24
 8032556:	f3ca 0541 	ubfx	r5, sl, #1, #2
 803255a:	fb03 6805 	mla	r8, r3, r5, r6
 803255e:	f7fe fef5 	bl	803134c <FragDecoderGetStatus>
 8032562:	9808      	ldr	r0, [sp, #32]
 8032564:	9909      	ldr	r1, [sp, #36]	; 0x24
                uint8_t fragIndex = mcpsIndication->Buffer[cmdIndex++];
 8032566:	f10b 0b02 	add.w	fp, fp, #2
                FragSessionData[fragIndex].FragDecoderStatus = FragDecoderGetStatus( );
 803256a:	f108 0338 	add.w	r3, r8, #56	; 0x38
                if( ( participants == 1 ) ||
 803256e:	f01a 0f01 	tst.w	sl, #1
                FragSessionData[fragIndex].FragDecoderStatus = FragDecoderGetStatus( );
 8032572:	c303      	stmia	r3!, {r0, r1}
                uint8_t fragIndex = mcpsIndication->Buffer[cmdIndex++];
 8032574:	fa5f fb8b 	uxtb.w	fp, fp
                if( ( participants == 1 ) ||
 8032578:	d102      	bne.n	8032580 <LmhpFragmentationOnMcpsIndication+0xe8>
                    ( ( participants == 0 ) && ( FragSessionData[fragIndex].FragDecoderStatus.FragNbLost > 0 ) ) )
 803257a:	f8b8 303a 	ldrh.w	r3, [r8, #58]	; 0x3a
 803257e:	b333      	cbz	r3, 80325ce <LmhpFragmentationOnMcpsIndication+0x136>
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FRAGMENTATION_FRAG_STATUS_ANS;
 8032580:	6872      	ldr	r2, [r6, #4]
 8032582:	f04f 0901 	mov.w	r9, #1
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.FragNbRx & 0xFF;
 8032586:	2318      	movs	r3, #24
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FRAGMENTATION_FRAG_STATUS_ANS;
 8032588:	f802 9004 	strb.w	r9, [r2, r4]
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.FragNbRx & 0xFF;
 803258c:	fb03 6305 	mla	r3, r3, r5, r6
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FRAGMENTATION_FRAG_STATUS_ANS;
 8032590:	eb04 0109 	add.w	r1, r4, r9
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.FragNbRx & 0xFF;
 8032594:	b2c9      	uxtb	r1, r1
 8032596:	8f18      	ldrh	r0, [r3, #56]	; 0x38
 8032598:	5450      	strb	r0, [r2, r1]
                                                                           ( ( FragSessionData[fragIndex].FragDecoderStatus.FragNbRx >> 8 ) & 0x3F );
 803259a:	8f19      	ldrh	r1, [r3, #56]	; 0x38
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.FragNbRx & 0xFF;
 803259c:	1ca0      	adds	r0, r4, #2
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = ( fragIndex << 6 ) |
 803259e:	b2c0      	uxtb	r0, r0
                                                                           ( ( FragSessionData[fragIndex].FragDecoderStatus.FragNbRx >> 8 ) & 0x3F );
 80325a0:	f3c1 2105 	ubfx	r1, r1, #8, #6
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = ( fragIndex << 6 ) |
 80325a4:	ea41 1185 	orr.w	r1, r1, r5, lsl #6
 80325a8:	5411      	strb	r1, [r2, r0]
 80325aa:	1ce0      	adds	r0, r4, #3
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.FragNbLost;
 80325ac:	b2c0      	uxtb	r0, r0
 80325ae:	8f5d      	ldrh	r5, [r3, #58]	; 0x3a
 80325b0:	5415      	strb	r5, [r2, r0]
 80325b2:	1d21      	adds	r1, r4, #4
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.MatrixError & 0x01;
 80325b4:	f893 003e 	ldrb.w	r0, [r3, #62]	; 0x3e
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.FragNbLost;
 80325b8:	b2c9      	uxtb	r1, r1
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.MatrixError & 0x01;
 80325ba:	ea00 0009 	and.w	r0, r0, r9
 80325be:	5450      	strb	r0, [r2, r1]
                    blockAckDelay = FragSessionData[fragIndex].FragGroupData.Control.Fields.BlockAckDelay;
 80325c0:	f893 0031 	ldrb.w	r0, [r3, #49]	; 0x31
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.MatrixError & 0x01;
 80325c4:	3405      	adds	r4, #5
                    blockAckDelay = FragSessionData[fragIndex].FragGroupData.Control.Fields.BlockAckDelay;
 80325c6:	f000 0307 	and.w	r3, r0, #7
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.MatrixError & 0x01;
 80325ca:	b2e4      	uxtb	r4, r4
                    blockAckDelay = FragSessionData[fragIndex].FragGroupData.Control.Fields.BlockAckDelay;
 80325cc:	9301      	str	r3, [sp, #4]
                uint8_t fragIndex = mcpsIndication->Buffer[cmdIndex++];
 80325ce:	46da      	mov	sl, fp
 80325d0:	e7bb      	b.n	803254a <LmhpFragmentationOnMcpsIndication+0xb2>
                if( mcpsIndication->Multicast == 1 )
 80325d2:	78ba      	ldrb	r2, [r7, #2]
 80325d4:	2a01      	cmp	r2, #1
 80325d6:	d0b8      	beq.n	803254a <LmhpFragmentationOnMcpsIndication+0xb2>
                fragSessionData.FragGroupData.FragSession.Value = mcpsIndication->Buffer[cmdIndex++];
 80325d8:	f813 200a 	ldrb.w	r2, [r3, sl]
 80325dc:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
                fragSessionData.FragGroupData.FragNb =  ( mcpsIndication->Buffer[cmdIndex++] << 0 ) & 0x00FF;
 80325e0:	f10b 0203 	add.w	r2, fp, #3
                fragSessionData.FragGroupData.FragNb |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 80325e4:	b2d2      	uxtb	r2, r2
                fragSessionData.FragGroupData.Padding = mcpsIndication->Buffer[cmdIndex++];
 80325e6:	f10b 0007 	add.w	r0, fp, #7
                fragSessionData.FragGroupData.FragNb |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 80325ea:	5c99      	ldrb	r1, [r3, r2]
                fragSessionData.FragGroupData.FragSession.Value = mcpsIndication->Buffer[cmdIndex++];
 80325ec:	f10b 0202 	add.w	r2, fp, #2
                fragSessionData.FragGroupData.FragNb =  ( mcpsIndication->Buffer[cmdIndex++] << 0 ) & 0x00FF;
 80325f0:	b2d2      	uxtb	r2, r2
                fragSessionData.FragGroupData.Descriptor =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 80325f2:	b2c0      	uxtb	r0, r0
                fragSessionData.FragGroupData.FragNb |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 80325f4:	f813 8002 	ldrb.w	r8, [r3, r2]
                fragSessionData.FragGroupData.Descriptor =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 80325f8:	5c18      	ldrb	r0, [r3, r0]
 80325fa:	9002      	str	r0, [sp, #8]
                fragSessionData.FragGroupData.FragNb |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 80325fc:	f10b 0204 	add.w	r2, fp, #4
                fragSessionData.FragGroupData.FragSize = mcpsIndication->Buffer[cmdIndex++];
 8032600:	b2d2      	uxtb	r2, r2
                fragSessionData.FragGroupData.Descriptor =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032602:	f10b 0008 	add.w	r0, fp, #8
                fragSessionData.FragGroupData.FragSize = mcpsIndication->Buffer[cmdIndex++];
 8032606:	f813 9002 	ldrb.w	r9, [r3, r2]
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 803260a:	b2c0      	uxtb	r0, r0
                fragSessionData.FragGroupData.FragSize = mcpsIndication->Buffer[cmdIndex++];
 803260c:	f10b 0205 	add.w	r2, fp, #5
                fragSessionData.FragGroupData.Control.Value = mcpsIndication->Buffer[cmdIndex++];
 8032610:	b2d2      	uxtb	r2, r2
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032612:	5c18      	ldrb	r0, [r3, r0]
                fragSessionData.FragGroupData.Control.Value = mcpsIndication->Buffer[cmdIndex++];
 8032614:	5c9a      	ldrb	r2, [r3, r2]
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032616:	9003      	str	r0, [sp, #12]
                fragSessionData.FragGroupData.FragNb |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 8032618:	ea48 2801 	orr.w	r8, r8, r1, lsl #8
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 803261c:	f10b 0009 	add.w	r0, fp, #9
                fragSessionData.FragGroupData.Control.Value = mcpsIndication->Buffer[cmdIndex++];
 8032620:	f10b 0106 	add.w	r1, fp, #6
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032624:	f10b 0a0b 	add.w	sl, fp, #11
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032628:	f10b 0b0a 	add.w	fp, fp, #10
                fragSessionData.FragGroupData.Padding = mcpsIndication->Buffer[cmdIndex++];
 803262c:	b2c9      	uxtb	r1, r1
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 803262e:	b2c0      	uxtb	r0, r0
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032630:	fa5f fb8b 	uxtb.w	fp, fp
                if( fragSessionData.FragGroupData.Control.Fields.FragAlgo > 0 )
 8032634:	f012 0f38 	tst.w	r2, #56	; 0x38
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032638:	5c18      	ldrb	r0, [r3, r0]
                fragSessionData.FragGroupData.Padding = mcpsIndication->Buffer[cmdIndex++];
 803263a:	5c59      	ldrb	r1, [r3, r1]
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 803263c:	f813 b00b 	ldrb.w	fp, [r3, fp]
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032640:	9004      	str	r0, [sp, #16]
                    status |= 0x01; // Encoding unsupported
 8032642:	bf14      	ite	ne
 8032644:	2301      	movne	r3, #1
 8032646:	2300      	moveq	r3, #0
                if( ( fragSessionData.FragGroupData.FragNb > FRAG_MAX_NB ) || 
 8032648:	f5b8 7f33 	cmp.w	r8, #716	; 0x2cc
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 803264c:	fa5f fa8a 	uxtb.w	sl, sl
                if( ( fragSessionData.FragGroupData.FragNb > FRAG_MAX_NB ) || 
 8032650:	d941      	bls.n	80326d6 <LmhpFragmentationOnMcpsIndication+0x23e>
                    status |= 0x02; // Not enough Memory
 8032652:	f043 0302 	orr.w	r3, r3, #2
                status |= ( fragSessionData.FragGroupData.FragSession.Fields.FragIndex << 6 ) & 0xC0;
 8032656:	f89d c031 	ldrb.w	ip, [sp, #49]	; 0x31
 803265a:	f3cc 1c01 	ubfx	ip, ip, #4, #2
 803265e:	ea43 158c 	orr.w	r5, r3, ip, lsl #6
                if( ( status & 0x0F ) == 0 )
 8032662:	071b      	lsls	r3, r3, #28
 8032664:	d12c      	bne.n	80326c0 <LmhpFragmentationOnMcpsIndication+0x228>
                    FragSessionData[fragSessionData.FragGroupData.FragSession.Fields.FragIndex] = fragSessionData;
 8032666:	2301      	movs	r3, #1
 8032668:	f88d 2035 	strb.w	r2, [sp, #53]	; 0x35
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 803266c:	9a04      	ldr	r2, [sp, #16]
                    FragSessionData[fragSessionData.FragGroupData.FragSession.Fields.FragIndex] = fragSessionData;
 803266e:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032672:	ea4f 630b 	mov.w	r3, fp, lsl #24
 8032676:	eb03 4302 	add.w	r3, r3, r2, lsl #16
 803267a:	9a02      	ldr	r2, [sp, #8]
                    FragSessionData[fragSessionData.FragGroupData.FragSession.Fields.FragIndex] = fragSessionData;
 803267c:	f8ad 8032 	strh.w	r8, [sp, #50]	; 0x32
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032680:	4413      	add	r3, r2
 8032682:	9a03      	ldr	r2, [sp, #12]
                    FragSessionData[fragSessionData.FragGroupData.FragSession.Fields.FragIndex] = fragSessionData;
 8032684:	f88d 9034 	strb.w	r9, [sp, #52]	; 0x34
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032688:	eb03 2302 	add.w	r3, r3, r2, lsl #8
                    FragSessionData[fragSessionData.FragGroupData.FragSession.Fields.FragIndex] = fragSessionData;
 803268c:	930e      	str	r3, [sp, #56]	; 0x38
 803268e:	f04f 33ff 	mov.w	r3, #4294967295
 8032692:	9311      	str	r3, [sp, #68]	; 0x44
 8032694:	f88d 1036 	strb.w	r1, [sp, #54]	; 0x36
 8032698:	2318      	movs	r3, #24
 803269a:	f10d 0e30 	add.w	lr, sp, #48	; 0x30
 803269e:	fb03 6c0c 	mla	ip, r3, ip, r6
 80326a2:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 80326a6:	f10c 0c2c 	add.w	ip, ip, #44	; 0x2c
 80326aa:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 80326ae:	e89e 0003 	ldmia.w	lr, {r0, r1}
                    FragDecoderInit( fragSessionData.FragGroupData.FragNb,
 80326b2:	68f2      	ldr	r2, [r6, #12]
                    FragSessionData[fragSessionData.FragGroupData.FragSession.Fields.FragIndex] = fragSessionData;
 80326b4:	e88c 0003 	stmia.w	ip, {r0, r1}
                    FragDecoderInit( fragSessionData.FragGroupData.FragNb,
 80326b8:	4649      	mov	r1, r9
 80326ba:	4640      	mov	r0, r8
 80326bc:	f7fe fc5e 	bl	8030f7c <FragDecoderInit>
                LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FRAGMENTATION_FRAG_SESSION_SETUP_ANS;
 80326c0:	1c63      	adds	r3, r4, #1
 80326c2:	6872      	ldr	r2, [r6, #4]
 80326c4:	b2db      	uxtb	r3, r3
 80326c6:	2102      	movs	r1, #2
 80326c8:	5511      	strb	r1, [r2, r4]
                LmhpFragmentationState.DataBuffer[dataBufferIndex++] = status;
 80326ca:	440c      	add	r4, r1
 80326cc:	54d5      	strb	r5, [r2, r3]
 80326ce:	b2e4      	uxtb	r4, r4
                isAnswerDelayed = false;
 80326d0:	f04f 0900 	mov.w	r9, #0
                break;
 80326d4:	e739      	b.n	803254a <LmhpFragmentationOnMcpsIndication+0xb2>
                if( ( fragSessionData.FragGroupData.FragNb > FRAG_MAX_NB ) || 
 80326d6:	f1b9 0f78 	cmp.w	r9, #120	; 0x78
 80326da:	d8ba      	bhi.n	8032652 <LmhpFragmentationOnMcpsIndication+0x1ba>
 80326dc:	e9cd 1306 	strd	r1, r3, [sp, #24]
 80326e0:	9205      	str	r2, [sp, #20]
                    ( ( fragSessionData.FragGroupData.FragNb * fragSessionData.FragGroupData.FragSize ) > FragDecoderGetMaxFileSize( ) ) )
 80326e2:	f7fe fc7d 	bl	8030fe0 <FragDecoderGetMaxFileSize>
 80326e6:	fb09 f508 	mul.w	r5, r9, r8
                    ( fragSessionData.FragGroupData.FragSize > FRAG_MAX_SIZE ) ||
 80326ea:	4285      	cmp	r5, r0
 80326ec:	e9dd 2105 	ldrd	r2, r1, [sp, #20]
 80326f0:	9b07      	ldr	r3, [sp, #28]
 80326f2:	d8ae      	bhi.n	8032652 <LmhpFragmentationOnMcpsIndication+0x1ba>
 80326f4:	e7af      	b.n	8032656 <LmhpFragmentationOnMcpsIndication+0x1be>
                if( mcpsIndication->Multicast == 1 )
 80326f6:	78ba      	ldrb	r2, [r7, #2]
 80326f8:	2a01      	cmp	r2, #1
 80326fa:	f43f af26 	beq.w	803254a <LmhpFragmentationOnMcpsIndication+0xb2>
                uint8_t id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 80326fe:	f813 300a 	ldrb.w	r3, [r3, sl]
                if( ( id >= FRAGMENTATION_MAX_SESSIONS ) || ( FragSessionData[id].FragGroupData.IsActive == false ) )
 8032702:	2218      	movs	r2, #24
                uint8_t id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032704:	f003 0303 	and.w	r3, r3, #3
                if( ( id >= FRAGMENTATION_MAX_SESSIONS ) || ( FragSessionData[id].FragGroupData.IsActive == false ) )
 8032708:	fb02 6203 	mla	r2, r2, r3, r6
                uint8_t id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 803270c:	f10b 0b02 	add.w	fp, fp, #2
                if( ( id >= FRAGMENTATION_MAX_SESSIONS ) || ( FragSessionData[id].FragGroupData.IsActive == false ) )
 8032710:	f892 102c 	ldrb.w	r1, [r2, #44]	; 0x2c
                uint8_t id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032714:	fa5f fb8b 	uxtb.w	fp, fp
                if( ( id >= FRAGMENTATION_MAX_SESSIONS ) || ( FragSessionData[id].FragGroupData.IsActive == false ) )
 8032718:	b959      	cbnz	r1, 8032732 <LmhpFragmentationOnMcpsIndication+0x29a>
                    status |= 0x04; // Session does not exist
 803271a:	f043 0304 	orr.w	r3, r3, #4
                LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FRAGMENTATION_FRAG_SESSION_DELETE_ANS;
 803271e:	6871      	ldr	r1, [r6, #4]
 8032720:	1c62      	adds	r2, r4, #1
 8032722:	b2d2      	uxtb	r2, r2
 8032724:	2003      	movs	r0, #3
 8032726:	5508      	strb	r0, [r1, r4]
                LmhpFragmentationState.DataBuffer[dataBufferIndex++] = status;
 8032728:	3402      	adds	r4, #2
 803272a:	548b      	strb	r3, [r1, r2]
 803272c:	b2e4      	uxtb	r4, r4
                uint8_t id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 803272e:	46da      	mov	sl, fp
 8032730:	e7ce      	b.n	80326d0 <LmhpFragmentationOnMcpsIndication+0x238>
                    FragSessionData[id].FragGroupData.IsActive = false;
 8032732:	2100      	movs	r1, #0
 8032734:	f882 102c 	strb.w	r1, [r2, #44]	; 0x2c
 8032738:	e7f1      	b.n	803271e <LmhpFragmentationOnMcpsIndication+0x286>
                fragCounter = ( mcpsIndication->Buffer[cmdIndex++] << 0 ) & 0x00FF;
 803273a:	f10b 0202 	add.w	r2, fp, #2
                fragCounter |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 803273e:	b2d2      	uxtb	r2, r2
 8032740:	f813 8002 	ldrb.w	r8, [r3, r2]
 8032744:	f813 300a 	ldrb.w	r3, [r3, sl]
                if (FragSessionData[fragIndex].FragGroupData.IsActive == false)
 8032748:	2218      	movs	r2, #24
                fragCounter |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 803274a:	ea43 2308 	orr.w	r3, r3, r8, lsl #8
                if (FragSessionData[fragIndex].FragGroupData.IsActive == false)
 803274e:	ea4f 1898 	mov.w	r8, r8, lsr #6
 8032752:	fb02 6208 	mla	r2, r2, r8, r6
 8032756:	f102 052c 	add.w	r5, r2, #44	; 0x2c
 803275a:	f892 202c 	ldrb.w	r2, [r2, #44]	; 0x2c
 803275e:	2a00      	cmp	r2, #0
 8032760:	d065      	beq.n	803282e <LmhpFragmentationOnMcpsIndication+0x396>
                if( mcpsIndication->Multicast == 1 )
 8032762:	78ba      	ldrb	r2, [r7, #2]
 8032764:	2a01      	cmp	r2, #1
 8032766:	d117      	bne.n	8032798 <LmhpFragmentationOnMcpsIndication+0x300>
                    uint8_t groupId = LoRaMacMcChannelGetGroupId( mcpsIndication->DevAddress );
 8032768:	6978      	ldr	r0, [r7, #20]
 803276a:	9302      	str	r3, [sp, #8]
 803276c:	f002 fdc0 	bl	80352f0 <LoRaMacMcChannelGetGroupId>
                    if( ( groupId == 0xFF ) ||
 8032770:	28ff      	cmp	r0, #255	; 0xff
 8032772:	d008      	beq.n	8032786 <LmhpFragmentationOnMcpsIndication+0x2ee>
                        ( ( FragSessionData[fragIndex].FragGroupData.FragSession.Fields.McGroupBitMask & ( 1 << groupId ) ) == 0 ) )
 8032774:	786a      	ldrb	r2, [r5, #1]
                    if( ( groupId == 0xFF ) ||
 8032776:	9b02      	ldr	r3, [sp, #8]
                        ( ( FragSessionData[fragIndex].FragGroupData.FragSession.Fields.McGroupBitMask & ( 1 << groupId ) ) == 0 ) )
 8032778:	f002 020f 	and.w	r2, r2, #15
 803277c:	fa42 f000 	asr.w	r0, r2, r0
                    if( ( groupId == 0xFF ) ||
 8032780:	f010 0f01 	tst.w	r0, #1
 8032784:	d108      	bne.n	8032798 <LmhpFragmentationOnMcpsIndication+0x300>
                        cmdIndex = mcpsIndication->BufferSize;
 8032786:	f897 a00c 	ldrb.w	sl, [r7, #12]
                        break;
 803278a:	e6de      	b.n	803254a <LmhpFragmentationOnMcpsIndication+0xb2>
 803278c:	200049ac 	.word	0x200049ac
 8032790:	2000352c 	.word	0x2000352c
 8032794:	20006308 	.word	0x20006308
                if (FragSessionData[fragIndex].FragDecoderProcessStatus == FRAG_SESSION_ONGOING)
 8032798:	2218      	movs	r2, #24
 803279a:	fb02 6a08 	mla	sl, r2, r8, r6
                fragCounter |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 803279e:	f10b 0503 	add.w	r5, fp, #3
                if (FragSessionData[fragIndex].FragDecoderProcessStatus == FRAG_SESSION_ONGOING)
 80327a2:	f8da 2040 	ldr.w	r2, [sl, #64]	; 0x40
 80327a6:	3201      	adds	r2, #1
                fragCounter |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 80327a8:	b2ed      	uxtb	r5, r5
                if (FragSessionData[fragIndex].FragDecoderProcessStatus == FRAG_SESSION_ONGOING)
 80327aa:	d137      	bne.n	803281c <LmhpFragmentationOnMcpsIndication+0x384>
                    FragSessionData[fragIndex].FragDecoderProcessStatus = FragDecoderProcess( fragCounter, &mcpsIndication->Buffer[cmdIndex] );
 80327ac:	68b9      	ldr	r1, [r7, #8]
 80327ae:	f3c3 000d 	ubfx	r0, r3, #0, #14
 80327b2:	4429      	add	r1, r5
 80327b4:	f7fe fc18 	bl	8030fe8 <FragDecoderProcess>
 80327b8:	f8ca 0040 	str.w	r0, [sl, #64]	; 0x40
                    FragSessionData[fragIndex].FragDecoderStatus = FragDecoderGetStatus( );
 80327bc:	a808      	add	r0, sp, #32
 80327be:	f7fe fdc5 	bl	803134c <FragDecoderGetStatus>
 80327c2:	9808      	ldr	r0, [sp, #32]
 80327c4:	9909      	ldr	r1, [sp, #36]	; 0x24
 80327c6:	f10a 0338 	add.w	r3, sl, #56	; 0x38
 80327ca:	c303      	stmia	r3!, {r0, r1}
                    if( LmhpFragmentationParams->OnProgress != NULL )
 80327cc:	68f3      	ldr	r3, [r6, #12]
 80327ce:	f8d3 b00c 	ldr.w	fp, [r3, #12]
 80327d2:	f1bb 0f00 	cmp.w	fp, #0
 80327d6:	d008      	beq.n	80327ea <LmhpFragmentationOnMcpsIndication+0x352>
                        LmhpFragmentationParams->OnProgress( FragSessionData[fragIndex].FragDecoderStatus.FragNbRx,
 80327d8:	f8ba 303a 	ldrh.w	r3, [sl, #58]	; 0x3a
 80327dc:	f89a 2030 	ldrb.w	r2, [sl, #48]	; 0x30
 80327e0:	f8ba 102e 	ldrh.w	r1, [sl, #46]	; 0x2e
 80327e4:	f8ba 0038 	ldrh.w	r0, [sl, #56]	; 0x38
 80327e8:	47d8      	blx	fp
                    if( FragSessionData[fragIndex].FragDecoderProcessStatus >= 0 )
 80327ea:	2318      	movs	r3, #24
 80327ec:	fb03 6308 	mla	r3, r3, r8, r6
 80327f0:	6c18      	ldr	r0, [r3, #64]	; 0x40
 80327f2:	2800      	cmp	r0, #0
 80327f4:	db12      	blt.n	803281c <LmhpFragmentationOnMcpsIndication+0x384>
                        if( LmhpFragmentationParams->OnDone != NULL )
 80327f6:	68f2      	ldr	r2, [r6, #12]
 80327f8:	6912      	ldr	r2, [r2, #16]
 80327fa:	b14a      	cbz	r2, 8032810 <LmhpFragmentationOnMcpsIndication+0x378>
                                                            ( FragSessionData[fragIndex].FragGroupData.FragNb * FragSessionData[fragIndex].FragGroupData.FragSize ) - FragSessionData[fragIndex].FragGroupData.Padding );
 80327fc:	f8b3 c02e 	ldrh.w	ip, [r3, #46]	; 0x2e
 8032800:	f893 1030 	ldrb.w	r1, [r3, #48]	; 0x30
 8032804:	f893 3032 	ldrb.w	r3, [r3, #50]	; 0x32
 8032808:	fb01 f10c 	mul.w	r1, r1, ip
                            LmhpFragmentationParams->OnDone( FragSessionData[fragIndex].FragDecoderProcessStatus,
 803280c:	1ac9      	subs	r1, r1, r3
 803280e:	4790      	blx	r2
                        FragSessionData[fragIndex].FragDecoderProcessStatus = FRAG_SESSION_NOT_STARTED;
 8032810:	2318      	movs	r3, #24
 8032812:	fb03 6308 	mla	r3, r3, r8, r6
 8032816:	f06f 0201 	mvn.w	r2, #1
 803281a:	641a      	str	r2, [r3, #64]	; 0x40
                cmdIndex += FragSessionData[fragIndex].FragGroupData.FragSize;
 803281c:	2318      	movs	r3, #24
 803281e:	fb03 6808 	mla	r8, r3, r8, r6
 8032822:	f898 a030 	ldrb.w	sl, [r8, #48]	; 0x30
 8032826:	4455      	add	r5, sl
 8032828:	fa5f fa85 	uxtb.w	sl, r5
                break;
 803282c:	e68d      	b.n	803254a <LmhpFragmentationOnMcpsIndication+0xb2>
 803282e:	468a      	mov	sl, r1
 8032830:	e68b      	b.n	803254a <LmhpFragmentationOnMcpsIndication+0xb2>
            LmHandlerGetDutyCycleEnable( &current_dutycycle );
 8032832:	f10d 002f 	add.w	r0, sp, #47	; 0x2f
 8032836:	f7ff f973 	bl	8031b20 <LmHandlerGetDutyCycleEnable>
            LmHandlerSetDutyCycleEnable( false );
 803283a:	4648      	mov	r0, r9
 803283c:	f7ff f97c 	bl	8031b38 <LmHandlerSetDutyCycleEnable>
            LmhpFragmentationPackage.OnSendRequest( &cmdReplyAppData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true );
 8032840:	6ab5      	ldr	r5, [r6, #40]	; 0x28
 8032842:	2301      	movs	r3, #1
 8032844:	464a      	mov	r2, r9
 8032846:	4649      	mov	r1, r9
 8032848:	4620      	mov	r0, r4
 803284a:	47a8      	blx	r5
            LmHandlerSetDutyCycleEnable( current_dutycycle );
 803284c:	f89d 002f 	ldrb.w	r0, [sp, #47]	; 0x2f
 8032850:	f7ff f972 	bl	8031b38 <LmHandlerSetDutyCycleEnable>
 8032854:	e652      	b.n	80324fc <LmhpFragmentationOnMcpsIndication+0x64>
 8032856:	bf00      	nop

08032858 <LmhpFragmentationProcess>:
{
 8032858:	b538      	push	{r3, r4, r5, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803285a:	f3ef 8210 	mrs	r2, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803285e:	b672      	cpsid	i
    delayTimerState = LmhpFragmentationState.TxDelayState;
 8032860:	4c0f      	ldr	r4, [pc, #60]	; (80328a0 <LmhpFragmentationProcess+0x48>)
 8032862:	78a3      	ldrb	r3, [r4, #2]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8032864:	f382 8810 	msr	PRIMASK, r2
    switch( delayTimerState )
 8032868:	2b01      	cmp	r3, #1
 803286a:	d002      	beq.n	8032872 <LmhpFragmentationProcess+0x1a>
 803286c:	2b02      	cmp	r3, #2
 803286e:	d00b      	beq.n	8032888 <LmhpFragmentationProcess+0x30>
}
 8032870:	bd38      	pop	{r3, r4, r5, pc}
            TimerSetValue( &FragmentTxDelayTimer, TxDelayTime );
 8032872:	6921      	ldr	r1, [r4, #16]
 8032874:	f104 0014 	add.w	r0, r4, #20
 8032878:	f008 fdea 	bl	803b450 <UTIL_TIMER_SetPeriod>
            TimerStart( &FragmentTxDelayTimer );
 803287c:	f104 0014 	add.w	r0, r4, #20
}
 8032880:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
            TimerStart( &FragmentTxDelayTimer );
 8032884:	f008 bdaa 	b.w	803b3dc <UTIL_TIMER_Start>
            if (LORAMAC_HANDLER_SUCCESS == LmhpFragmentationPackage.OnSendRequest( &DelayedReplyAppData,
 8032888:	4b06      	ldr	r3, [pc, #24]	; (80328a4 <LmhpFragmentationProcess+0x4c>)
 803288a:	4807      	ldr	r0, [pc, #28]	; (80328a8 <LmhpFragmentationProcess+0x50>)
 803288c:	6a9d      	ldr	r5, [r3, #40]	; 0x28
 803288e:	2200      	movs	r2, #0
 8032890:	2301      	movs	r3, #1
 8032892:	4611      	mov	r1, r2
 8032894:	47a8      	blx	r5
 8032896:	2800      	cmp	r0, #0
 8032898:	d1ea      	bne.n	8032870 <LmhpFragmentationProcess+0x18>
                LmhpFragmentationState.TxDelayState = FRAGMENTATION_TX_DELAY_STATE_IDLE;
 803289a:	70a0      	strb	r0, [r4, #2]
}
 803289c:	e7e8      	b.n	8032870 <LmhpFragmentationProcess+0x18>
 803289e:	bf00      	nop
 80328a0:	200049ac 	.word	0x200049ac
 80328a4:	2000352c 	.word	0x2000352c
 80328a8:	20006308 	.word	0x20006308

080328ac <LmhpFragmentationPackageFactory>:
}
 80328ac:	4800      	ldr	r0, [pc, #0]	; (80328b0 <LmhpFragmentationPackageFactory+0x4>)
 80328ae:	4770      	bx	lr
 80328b0:	2000352c 	.word	0x2000352c

080328b4 <LmhpFragmentationGetPackageVersion>:
}
 80328b4:	2001      	movs	r0, #1
 80328b6:	4770      	bx	lr

080328b8 <LmhpPackagesRegistrationInit>:
/* Private variables ---------------------------------------------------------*/

/* Exported functions ---------------------------------------------------------*/
LmHandlerErrorStatus_t LmhpPackagesRegistrationInit(void)
{
  if (LmHandlerPackageRegister(PACKAGE_ID_CLOCK_SYNC, NULL) != LORAMAC_HANDLER_SUCCESS)
 80328b8:	2100      	movs	r1, #0
{
 80328ba:	b508      	push	{r3, lr}
  if (LmHandlerPackageRegister(PACKAGE_ID_CLOCK_SYNC, NULL) != LORAMAC_HANDLER_SUCCESS)
 80328bc:	2001      	movs	r0, #1
 80328be:	f7ff f8cd 	bl	8031a5c <LmHandlerPackageRegister>
 80328c2:	4601      	mov	r1, r0
 80328c4:	b110      	cbz	r0, 80328cc <LmhpPackagesRegistrationInit+0x14>
  {
    return LORAMAC_HANDLER_ERROR;
 80328c6:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return LORAMAC_HANDLER_ERROR;
  }

  return LORAMAC_HANDLER_SUCCESS;
}
 80328ca:	bd08      	pop	{r3, pc}
  else if (LmHandlerPackageRegister(PACKAGE_ID_REMOTE_MCAST_SETUP, NULL) != LORAMAC_HANDLER_SUCCESS)
 80328cc:	2002      	movs	r0, #2
 80328ce:	f7ff f8c5 	bl	8031a5c <LmHandlerPackageRegister>
 80328d2:	2800      	cmp	r0, #0
 80328d4:	d1f7      	bne.n	80328c6 <LmhpPackagesRegistrationInit+0xe>
  else if (LmHandlerPackageRegister(PACKAGE_ID_FRAGMENTATION, (LmhpFragmentationParams_t *)&FRAG_DECODER_IF_FragmentationParams) != LORAMAC_HANDLER_SUCCESS)
 80328d6:	4907      	ldr	r1, [pc, #28]	; (80328f4 <LmhpPackagesRegistrationInit+0x3c>)
 80328d8:	2003      	movs	r0, #3
 80328da:	f7ff f8bf 	bl	8031a5c <LmHandlerPackageRegister>
 80328de:	4601      	mov	r1, r0
 80328e0:	2800      	cmp	r0, #0
 80328e2:	d1f0      	bne.n	80328c6 <LmhpPackagesRegistrationInit+0xe>
  else if (LmHandlerPackageRegister(PACKAGE_ID_FIRMWARE_MANAGEMENT, NULL) != LORAMAC_HANDLER_SUCCESS)
 80328e4:	2004      	movs	r0, #4
 80328e6:	f7ff f8b9 	bl	8031a5c <LmHandlerPackageRegister>
 80328ea:	3800      	subs	r0, #0
 80328ec:	bf18      	it	ne
 80328ee:	2001      	movne	r0, #1
 80328f0:	4240      	negs	r0, r0
 80328f2:	e7ea      	b.n	80328ca <LmhpPackagesRegistrationInit+0x12>
 80328f4:	0803b960 	.word	0x0803b960

080328f8 <LmhpPackagesRegister>:

LmHandlerErrorStatus_t LmhpPackagesRegister(uint8_t id, LmhPackage_t **package)
{
 80328f8:	b510      	push	{r4, lr}
  if (package == NULL)
 80328fa:	460c      	mov	r4, r1
 80328fc:	b1a1      	cbz	r1, 8032928 <LmhpPackagesRegister+0x30>
  {
    return LORAMAC_HANDLER_ERROR;
  }
  switch (id)
 80328fe:	3801      	subs	r0, #1
 8032900:	2803      	cmp	r0, #3
 8032902:	d806      	bhi.n	8032912 <LmhpPackagesRegister+0x1a>
 8032904:	e8df f000 	tbb	[pc, r0]
 8032908:	0d0a0702 	.word	0x0d0a0702
  {
    case PACKAGE_ID_CLOCK_SYNC:
    {
      *package = LmhpClockSyncPackageFactory();
 803290c:	f7ff fa4c 	bl	8031da8 <LmhpClockSyncPackageFactory>
      *package = LmhpFragmentationPackageFactory();
      break;
    }
    case PACKAGE_ID_FIRMWARE_MANAGEMENT:
    {
      *package = LmhpFirmwareManagementPackageFactory();
 8032910:	6020      	str	r0, [r4, #0]
  if (package == NULL)
 8032912:	2000      	movs	r0, #0
 8032914:	e00a      	b.n	803292c <LmhpPackagesRegister+0x34>
      *package = LmhpRemoteMcastSetupPackageFactory();
 8032916:	f000 fb45 	bl	8032fa4 <LmhpRemoteMcastSetupPackageFactory>
 803291a:	e7f9      	b.n	8032910 <LmhpPackagesRegister+0x18>
      *package = LmhpFragmentationPackageFactory();
 803291c:	f7ff ffc6 	bl	80328ac <LmhpFragmentationPackageFactory>
 8032920:	e7f6      	b.n	8032910 <LmhpPackagesRegister+0x18>
      *package = LmhpFirmwareManagementPackageFactory();
 8032922:	f7ff fd6f 	bl	8032404 <LmhpFirmwareManagementPackageFactory>
 8032926:	e7f3      	b.n	8032910 <LmhpPackagesRegister+0x18>
    return LORAMAC_HANDLER_ERROR;
 8032928:	f04f 30ff 	mov.w	r0, #4294967295
      break;
    }
  }

  return LORAMAC_HANDLER_SUCCESS;
}
 803292c:	bd10      	pop	{r4, pc}
	...

08032930 <LmhpRemoteMcastSetupIsInitialized>:
}

static bool LmhpRemoteMcastSetupIsInitialized( void )
{
    return LmhpRemoteMcastSetupState.Initialized;
}
 8032930:	4b01      	ldr	r3, [pc, #4]	; (8032938 <LmhpRemoteMcastSetupIsInitialized+0x8>)
 8032932:	7818      	ldrb	r0, [r3, #0]
 8032934:	4770      	bx	lr
 8032936:	bf00      	nop
 8032938:	20004a38 	.word	0x20004a38

0803293c <LmhpRemoteMcastSetupIsRunning>:

static bool LmhpRemoteMcastSetupIsRunning( void )
{
    if( LmhpRemoteMcastSetupState.Initialized == false )
 803293c:	4b02      	ldr	r3, [pc, #8]	; (8032948 <LmhpRemoteMcastSetupIsRunning+0xc>)
 803293e:	7818      	ldrb	r0, [r3, #0]
 8032940:	b100      	cbz	r0, 8032944 <LmhpRemoteMcastSetupIsRunning+0x8>
    {
        return false;
    }

    return LmhpRemoteMcastSetupState.IsRunning;
 8032942:	7858      	ldrb	r0, [r3, #1]
}
 8032944:	4770      	bx	lr
 8032946:	bf00      	nop
 8032948:	20004a38 	.word	0x20004a38

0803294c <LmhpRemoteMcastSetupInit>:
{
 803294c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 803294e:	4c10      	ldr	r4, [pc, #64]	; (8032990 <LmhpRemoteMcastSetupInit+0x44>)
    if( dataBuffer != NULL )
 8032950:	b1e1      	cbz	r1, 803298c <LmhpRemoteMcastSetupInit+0x40>
        LmhpRemoteMcastSetupState.Initialized = true;
 8032952:	4620      	mov	r0, r4
        TimerInit( &SessionStartTimer, OnSessionStartTimer );
 8032954:	2500      	movs	r5, #0
        LmhpRemoteMcastSetupState.Initialized = true;
 8032956:	f240 1301 	movw	r3, #257	; 0x101
 803295a:	f820 3b08 	strh.w	r3, [r0], #8
        LmhpRemoteMcastSetupState.DataBuffer = dataBuffer;
 803295e:	6061      	str	r1, [r4, #4]
        TimerInit( &SessionStartTimer, OnSessionStartTimer );
 8032960:	4b0c      	ldr	r3, [pc, #48]	; (8032994 <LmhpRemoteMcastSetupInit+0x48>)
        LmhpRemoteMcastSetupState.DataBufferMaxSize = dataBufferMaxSize;
 8032962:	70e2      	strb	r2, [r4, #3]
        TimerInit( &SessionStartTimer, OnSessionStartTimer );
 8032964:	f04f 31ff 	mov.w	r1, #4294967295
 8032968:	462a      	mov	r2, r5
 803296a:	9500      	str	r5, [sp, #0]
 803296c:	f008 fc88 	bl	803b280 <UTIL_TIMER_Create>
        TimerInit( &SessionStopTimer, OnSessionStopTimer );
 8032970:	4b09      	ldr	r3, [pc, #36]	; (8032998 <LmhpRemoteMcastSetupInit+0x4c>)
 8032972:	9500      	str	r5, [sp, #0]
 8032974:	462a      	mov	r2, r5
 8032976:	f04f 31ff 	mov.w	r1, #4294967295
 803297a:	f104 0020 	add.w	r0, r4, #32
 803297e:	f008 fc7f 	bl	803b280 <UTIL_TIMER_Create>
        McSessionData[id].McGroupData.McGroupEnabled = false;
 8032982:	2300      	movs	r3, #0
 8032984:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
}
 8032988:	b003      	add	sp, #12
 803298a:	bd30      	pop	{r4, r5, pc}
        LmhpRemoteMcastSetupState.Initialized = false;
 803298c:	8021      	strh	r1, [r4, #0]
 803298e:	e7f8      	b.n	8032982 <LmhpRemoteMcastSetupInit+0x36>
 8032990:	20004a38 	.word	0x20004a38
 8032994:	080329c1 	.word	0x080329c1
 8032998:	0803299d 	.word	0x0803299d

0803299c <OnSessionStopTimer>:
    LmhpRemoteMcastSetupState.SessionState = REMOTE_MCAST_SETUP_SESSION_STATE_START;
    LmhpRemoteMcastSetupPackage.OnPackageProcessEvent();
}

static void OnSessionStopTimer( void *context )
{
 803299c:	b510      	push	{r4, lr}
    TimerStop( &SessionStopTimer );
 803299e:	4c06      	ldr	r4, [pc, #24]	; (80329b8 <OnSessionStopTimer+0x1c>)
 80329a0:	f104 0020 	add.w	r0, r4, #32
 80329a4:	f008 fcca 	bl	803b33c <UTIL_TIMER_Stop>
    LmhpRemoteMcastSetupState.SessionState = REMOTE_MCAST_SETUP_SESSION_STATE_STOP;
 80329a8:	2302      	movs	r3, #2
 80329aa:	70a3      	strb	r3, [r4, #2]
    LmhpRemoteMcastSetupPackage.OnPackageProcessEvent();
 80329ac:	4b03      	ldr	r3, [pc, #12]	; (80329bc <OnSessionStopTimer+0x20>)
}
 80329ae:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    LmhpRemoteMcastSetupPackage.OnPackageProcessEvent();
 80329b2:	695b      	ldr	r3, [r3, #20]
 80329b4:	4718      	bx	r3
 80329b6:	bf00      	nop
 80329b8:	20004a38 	.word	0x20004a38
 80329bc:	20003560 	.word	0x20003560

080329c0 <OnSessionStartTimer>:
{
 80329c0:	b510      	push	{r4, lr}
    TimerStop( &SessionStartTimer );
 80329c2:	4c06      	ldr	r4, [pc, #24]	; (80329dc <OnSessionStartTimer+0x1c>)
 80329c4:	f104 0008 	add.w	r0, r4, #8
 80329c8:	f008 fcb8 	bl	803b33c <UTIL_TIMER_Stop>
    LmhpRemoteMcastSetupState.SessionState = REMOTE_MCAST_SETUP_SESSION_STATE_START;
 80329cc:	2301      	movs	r3, #1
 80329ce:	70a3      	strb	r3, [r4, #2]
    LmhpRemoteMcastSetupPackage.OnPackageProcessEvent();
 80329d0:	4b03      	ldr	r3, [pc, #12]	; (80329e0 <OnSessionStartTimer+0x20>)
}
 80329d2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    LmhpRemoteMcastSetupPackage.OnPackageProcessEvent();
 80329d6:	695b      	ldr	r3, [r3, #20]
 80329d8:	4718      	bx	r3
 80329da:	bf00      	nop
 80329dc:	20004a38 	.word	0x20004a38
 80329e0:	20003560 	.word	0x20003560

080329e4 <LmhpRemoteMcastSetupOnMcpsIndication>:
{
 80329e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if( mcpsIndication->Port != REMOTE_MCAST_SETUP_PORT )
 80329e8:	78c3      	ldrb	r3, [r0, #3]
 80329ea:	2bc8      	cmp	r3, #200	; 0xc8
{
 80329ec:	b091      	sub	sp, #68	; 0x44
 80329ee:	4682      	mov	sl, r0
    if( mcpsIndication->Port != REMOTE_MCAST_SETUP_PORT )
 80329f0:	f000 8293 	beq.w	8032f1a <LmhpRemoteMcastSetupOnMcpsIndication+0x536>
}
 80329f4:	b011      	add	sp, #68	; 0x44
 80329f6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        switch( mcpsIndication->Buffer[cmdIndex++] )
 80329fa:	f8da 0008 	ldr.w	r0, [sl, #8]
 80329fe:	5c81      	ldrb	r1, [r0, r2]
 8032a00:	1c57      	adds	r7, r2, #1
 8032a02:	b2ff      	uxtb	r7, r7
 8032a04:	2904      	cmp	r1, #4
 8032a06:	d813      	bhi.n	8032a30 <LmhpRemoteMcastSetupOnMcpsIndication+0x4c>
 8032a08:	e8df f011 	tbh	[pc, r1, lsl #1]
 8032a0c:	009c0005 	.word	0x009c0005
 8032a10:	01a800dd 	.word	0x01a800dd
 8032a14:	01d8      	.short	0x01d8
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_PKG_VERSION_ANS;
 8032a16:	6872      	ldr	r2, [r6, #4]
 8032a18:	2300      	movs	r3, #0
 8032a1a:	1c61      	adds	r1, r4, #1
 8032a1c:	5513      	strb	r3, [r2, r4]
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_ID;
 8032a1e:	b2c9      	uxtb	r1, r1
 8032a20:	1ca3      	adds	r3, r4, #2
 8032a22:	b2db      	uxtb	r3, r3
 8032a24:	2002      	movs	r0, #2
 8032a26:	5450      	strb	r0, [r2, r1]
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_VERSION;
 8032a28:	2101      	movs	r1, #1
 8032a2a:	3403      	adds	r4, #3
 8032a2c:	54d1      	strb	r1, [r2, r3]
 8032a2e:	b2e4      	uxtb	r4, r4
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032a30:	463a      	mov	r2, r7
    while( cmdIndex < mcpsIndication->BufferSize )
 8032a32:	f89a 300c 	ldrb.w	r3, [sl, #12]
 8032a36:	4293      	cmp	r3, r2
 8032a38:	d8df      	bhi.n	80329fa <LmhpRemoteMcastSetupOnMcpsIndication+0x16>
    if( dataBufferIndex != 0 )
 8032a3a:	2c00      	cmp	r4, #0
 8032a3c:	d0da      	beq.n	80329f4 <LmhpRemoteMcastSetupOnMcpsIndication+0x10>
        LmHandlerAppData_t appData =
 8032a3e:	f88d 4021 	strb.w	r4, [sp, #33]	; 0x21
            .Buffer = LmhpRemoteMcastSetupState.DataBuffer,
 8032a42:	4cb9      	ldr	r4, [pc, #740]	; (8032d28 <LmhpRemoteMcastSetupOnMcpsIndication+0x344>)
        LmHandlerAppData_t appData =
 8032a44:	23c8      	movs	r3, #200	; 0xc8
 8032a46:	f88d 3020 	strb.w	r3, [sp, #32]
        LmHandlerGetDutyCycleEnable( &current_dutycycle );
 8032a4a:	f10d 001f 	add.w	r0, sp, #31
        LmHandlerAppData_t appData =
 8032a4e:	6863      	ldr	r3, [r4, #4]
 8032a50:	9309      	str	r3, [sp, #36]	; 0x24
        LmHandlerGetDutyCycleEnable( &current_dutycycle );
 8032a52:	f7ff f865 	bl	8031b20 <LmHandlerGetDutyCycleEnable>
        LmHandlerSetDutyCycleEnable( false );
 8032a56:	2000      	movs	r0, #0
 8032a58:	f7ff f86e 	bl	8031b38 <LmHandlerSetDutyCycleEnable>
        LmhpRemoteMcastSetupPackage.OnSendRequest( &appData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true );
 8032a5c:	4bb3      	ldr	r3, [pc, #716]	; (8032d2c <LmhpRemoteMcastSetupOnMcpsIndication+0x348>)
 8032a5e:	2200      	movs	r2, #0
 8032a60:	6a9e      	ldr	r6, [r3, #40]	; 0x28
 8032a62:	4611      	mov	r1, r2
 8032a64:	2301      	movs	r3, #1
 8032a66:	a808      	add	r0, sp, #32
 8032a68:	47b0      	blx	r6
        LmHandlerSetDutyCycleEnable( current_dutycycle );
 8032a6a:	f89d 001f 	ldrb.w	r0, [sp, #31]
 8032a6e:	f7ff f863 	bl	8031b38 <LmHandlerSetDutyCycleEnable>
        if (id != 0xFF && id < LORAMAC_MAX_MC_CTX)
 8032a72:	2d00      	cmp	r5, #0
 8032a74:	d1be      	bne.n	80329f4 <LmhpRemoteMcastSetupOnMcpsIndication+0x10>
            MW_LOG(TS_OFF, VLEVEL_M, "ID          : %d\r\n", McSessionData[id].McGroupData.IdHeader.Fields.McGroupId);
 8032a76:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
                MW_LOG(TS_OFF, VLEVEL_M, "-%02X",  McSessionData[id].McGroupData.McKeyEncrypted[i]);
 8032a7a:	4fad      	ldr	r7, [pc, #692]	; (8032d30 <LmhpRemoteMcastSetupOnMcpsIndication+0x34c>)
            MW_LOG(TS_OFF, VLEVEL_M, "ID          : %d\r\n", McSessionData[id].McGroupData.IdHeader.Fields.McGroupId);
 8032a7c:	f003 0303 	and.w	r3, r3, #3
 8032a80:	462a      	mov	r2, r5
 8032a82:	4629      	mov	r1, r5
 8032a84:	9300      	str	r3, [sp, #0]
 8032a86:	2002      	movs	r0, #2
 8032a88:	4baa      	ldr	r3, [pc, #680]	; (8032d34 <LmhpRemoteMcastSetupOnMcpsIndication+0x350>)
 8032a8a:	f008 f935 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
            MW_LOG(TS_OFF, VLEVEL_M, "McAddr      : %08X\r\n", McSessionData[id].McGroupData.McAddr);
 8032a8e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8032a90:	9300      	str	r3, [sp, #0]
 8032a92:	462a      	mov	r2, r5
 8032a94:	4629      	mov	r1, r5
 8032a96:	4ba8      	ldr	r3, [pc, #672]	; (8032d38 <LmhpRemoteMcastSetupOnMcpsIndication+0x354>)
 8032a98:	2002      	movs	r0, #2
 8032a9a:	f008 f92d 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
            MW_LOG(TS_OFF, VLEVEL_M, "McKey       : %02X", McSessionData[id].McGroupData.McKeyEncrypted[0]);
 8032a9e:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8032aa2:	9300      	str	r3, [sp, #0]
 8032aa4:	462a      	mov	r2, r5
 8032aa6:	4629      	mov	r1, r5
 8032aa8:	4ba4      	ldr	r3, [pc, #656]	; (8032d3c <LmhpRemoteMcastSetupOnMcpsIndication+0x358>)
 8032aaa:	2002      	movs	r0, #2
 8032aac:	f008 f924 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
            for ( int i = 1; i < 16; i++ )
 8032ab0:	f104 0641 	add.w	r6, r4, #65	; 0x41
 8032ab4:	2501      	movs	r5, #1
                MW_LOG(TS_OFF, VLEVEL_M, "-%02X",  McSessionData[id].McGroupData.McKeyEncrypted[i]);
 8032ab6:	f816 3b01 	ldrb.w	r3, [r6], #1
 8032aba:	9300      	str	r3, [sp, #0]
 8032abc:	2200      	movs	r2, #0
 8032abe:	463b      	mov	r3, r7
 8032ac0:	4611      	mov	r1, r2
 8032ac2:	2002      	movs	r0, #2
            for ( int i = 1; i < 16; i++ )
 8032ac4:	3501      	adds	r5, #1
                MW_LOG(TS_OFF, VLEVEL_M, "-%02X",  McSessionData[id].McGroupData.McKeyEncrypted[i]);
 8032ac6:	f008 f917 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
            for ( int i = 1; i < 16; i++ )
 8032aca:	2d10      	cmp	r5, #16
 8032acc:	d1f3      	bne.n	8032ab6 <LmhpRemoteMcastSetupOnMcpsIndication+0xd2>
            MW_LOG(TS_OFF, VLEVEL_M, "\r\n");
 8032ace:	2200      	movs	r2, #0
 8032ad0:	4611      	mov	r1, r2
 8032ad2:	4b9b      	ldr	r3, [pc, #620]	; (8032d40 <LmhpRemoteMcastSetupOnMcpsIndication+0x35c>)
 8032ad4:	2002      	movs	r0, #2
 8032ad6:	f008 f90f 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
            MW_LOG(TS_OFF, VLEVEL_M, "McFCountMin : %u\r\n",  McSessionData[id].McGroupData.McFCountMin);
 8032ada:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8032adc:	9300      	str	r3, [sp, #0]
 8032ade:	2200      	movs	r2, #0
 8032ae0:	4611      	mov	r1, r2
 8032ae2:	4b98      	ldr	r3, [pc, #608]	; (8032d44 <LmhpRemoteMcastSetupOnMcpsIndication+0x360>)
 8032ae4:	2002      	movs	r0, #2
 8032ae6:	f008 f907 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
            MW_LOG(TS_OFF, VLEVEL_M, "McFCountMax : %u\r\n",  McSessionData[id].McGroupData.McFCountMax);
 8032aea:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8032aec:	9300      	str	r3, [sp, #0]
 8032aee:	2200      	movs	r2, #0
 8032af0:	4611      	mov	r1, r2
 8032af2:	4b95      	ldr	r3, [pc, #596]	; (8032d48 <LmhpRemoteMcastSetupOnMcpsIndication+0x364>)
 8032af4:	2002      	movs	r0, #2
 8032af6:	f008 f8ff 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
            MW_LOG(TS_OFF, VLEVEL_M, "SessionTime : %u\r\n",  McSessionData[id].SessionTime);
 8032afa:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8032afc:	9300      	str	r3, [sp, #0]
 8032afe:	2200      	movs	r2, #0
 8032b00:	4611      	mov	r1, r2
 8032b02:	4b92      	ldr	r3, [pc, #584]	; (8032d4c <LmhpRemoteMcastSetupOnMcpsIndication+0x368>)
 8032b04:	2002      	movs	r0, #2
 8032b06:	f008 f8f7 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
            MW_LOG(TS_OFF, VLEVEL_M, "SessionTimeT: %d s\r\n", (1 << McSessionData[id].SessionTimeout));
 8032b0a:	f894 2060 	ldrb.w	r2, [r4, #96]	; 0x60
 8032b0e:	2301      	movs	r3, #1
 8032b10:	4093      	lsls	r3, r2
 8032b12:	2200      	movs	r2, #0
 8032b14:	9300      	str	r3, [sp, #0]
 8032b16:	4611      	mov	r1, r2
 8032b18:	4b8d      	ldr	r3, [pc, #564]	; (8032d50 <LmhpRemoteMcastSetupOnMcpsIndication+0x36c>)
 8032b1a:	2002      	movs	r0, #2
 8032b1c:	f008 f8ec 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
            MW_LOG(TS_OFF, VLEVEL_M, "Rx Freq     : %u\r\n", McSessionData[id].RxParams.ClassC.Frequency);
 8032b20:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8032b22:	9300      	str	r3, [sp, #0]
 8032b24:	2200      	movs	r2, #0
 8032b26:	4611      	mov	r1, r2
 8032b28:	4b8a      	ldr	r3, [pc, #552]	; (8032d54 <LmhpRemoteMcastSetupOnMcpsIndication+0x370>)
 8032b2a:	2002      	movs	r0, #2
 8032b2c:	f008 f8e4 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
            MW_LOG(TS_OFF, VLEVEL_M, "Rx DR       : DR_%d\r\n", McSessionData[id].RxParams.ClassC.Datarate);
 8032b30:	f994 3068 	ldrsb.w	r3, [r4, #104]	; 0x68
 8032b34:	9300      	str	r3, [sp, #0]
 8032b36:	2200      	movs	r2, #0
 8032b38:	4b87      	ldr	r3, [pc, #540]	; (8032d58 <LmhpRemoteMcastSetupOnMcpsIndication+0x374>)
 8032b3a:	4611      	mov	r1, r2
 8032b3c:	2002      	movs	r0, #2
 8032b3e:	f008 f8db 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
 8032b42:	e757      	b.n	80329f4 <LmhpRemoteMcastSetupOnMcpsIndication+0x10>
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_STATUS_ANS;
 8032b44:	6875      	ldr	r5, [r6, #4]
                uint8_t reqGroupMask = mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8032b46:	5dc7      	ldrb	r7, [r0, r7]
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_STATUS_ANS;
 8032b48:	2301      	movs	r3, #1
 8032b4a:	552b      	strb	r3, [r5, r4]
                uint8_t reqGroupMask = mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8032b4c:	3202      	adds	r2, #2
                for (id = 0; id < LORAMAC_MAX_MC_CTX; id++)
 8032b4e:	2300      	movs	r3, #0
                dataBufferIndex++;
 8032b50:	3402      	adds	r4, #2
                uint8_t reqGroupMask = mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8032b52:	b2d2      	uxtb	r2, r2
                dataBufferIndex++;
 8032b54:	b2e4      	uxtb	r4, r4
                uint8_t AnsGroupMask = 0x00;
 8032b56:	469c      	mov	ip, r3
                for (id = 0; id < LORAMAC_MAX_MC_CTX; id++)
 8032b58:	4618      	mov	r0, r3
 8032b5a:	f007 0701 	and.w	r7, r7, #1
                    if( McSessionData[id].McGroupData.McGroupEnabled )
 8032b5e:	f896 e038 	ldrb.w	lr, [r6, #56]	; 0x38
                for (id = 0; id < LORAMAC_MAX_MC_CTX; id++)
 8032b62:	b140      	cbz	r0, 8032b76 <LmhpRemoteMcastSetupOnMcpsIndication+0x192>
                LmhpRemoteMcastSetupState.DataBuffer[1] = (nbAvailableGroups & 0x07) << 4 | (AnsGroupMask & 0x0F);
 8032b64:	011b      	lsls	r3, r3, #4
 8032b66:	f003 0370 	and.w	r3, r3, #112	; 0x70
 8032b6a:	ea43 030c 	orr.w	r3, r3, ip
 8032b6e:	706b      	strb	r3, [r5, #1]
                uint8_t reqGroupMask = mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8032b70:	4617      	mov	r7, r2
                break;
 8032b72:	460d      	mov	r5, r1
 8032b74:	e75c      	b.n	8032a30 <LmhpRemoteMcastSetupOnMcpsIndication+0x4c>
                    if( McSessionData[id].McGroupData.McGroupEnabled )
 8032b76:	f1be 0f00 	cmp.w	lr, #0
 8032b7a:	d0f3      	beq.n	8032b64 <LmhpRemoteMcastSetupOnMcpsIndication+0x180>
                        if( ( reqGroupMask & ( 1 << id ) ) != 0 )
 8032b7c:	b307      	cbz	r7, 8032bc0 <LmhpRemoteMcastSetupOnMcpsIndication+0x1dc>
                            LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = id;
 8032b7e:	5528      	strb	r0, [r5, r4]
 8032b80:	f104 0c01 	add.w	ip, r4, #1
                            LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (McSessionData[id].McGroupData.McAddr >> 0) & 0xFF;
 8032b84:	fa5f fc8c 	uxtb.w	ip, ip
 8032b88:	6bf0      	ldr	r0, [r6, #60]	; 0x3c
 8032b8a:	f805 000c 	strb.w	r0, [r5, ip]
 8032b8e:	f104 0c02 	add.w	ip, r4, #2
                            LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (McSessionData[id].McGroupData.McAddr >> 8) & 0xFF;
 8032b92:	6bf0      	ldr	r0, [r6, #60]	; 0x3c
 8032b94:	fa5f fc8c 	uxtb.w	ip, ip
 8032b98:	0a00      	lsrs	r0, r0, #8
 8032b9a:	f805 000c 	strb.w	r0, [r5, ip]
 8032b9e:	f104 0c03 	add.w	ip, r4, #3
                            LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (McSessionData[id].McGroupData.McAddr >> 16) & 0xFF;
 8032ba2:	fa5f fc8c 	uxtb.w	ip, ip
 8032ba6:	f8b6 e03e 	ldrh.w	lr, [r6, #62]	; 0x3e
 8032baa:	f805 e00c 	strb.w	lr, [r5, ip]
 8032bae:	1d20      	adds	r0, r4, #4
 8032bb0:	b2c0      	uxtb	r0, r0
                            LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (McSessionData[id].McGroupData.McAddr >> 24) & 0xFF;
 8032bb2:	f896 c03f 	ldrb.w	ip, [r6, #63]	; 0x3f
 8032bb6:	f805 c000 	strb.w	ip, [r5, r0]
 8032bba:	3405      	adds	r4, #5
 8032bbc:	b2e4      	uxtb	r4, r4
                            AnsGroupMask |= (1 << id);
 8032bbe:	46bc      	mov	ip, r7
 8032bc0:	3301      	adds	r3, #1
 8032bc2:	4608      	mov	r0, r1
 8032bc4:	e7cb      	b.n	8032b5e <LmhpRemoteMcastSetupOnMcpsIndication+0x17a>
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032bc6:	5dc5      	ldrb	r5, [r0, r7]
                McSessionData[id].McGroupData.IdHeader.Value = id;
 8032bc8:	f04f 0c34 	mov.w	ip, #52	; 0x34
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032bcc:	f005 0503 	and.w	r5, r5, #3
                McSessionData[id].McGroupData.IdHeader.Value = id;
 8032bd0:	fb0c 6705 	mla	r7, ip, r5, r6
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032bd4:	1c93      	adds	r3, r2, #2
                McSessionData[id].McGroupData.McAddr =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032bd6:	b2db      	uxtb	r3, r3
                McSessionData[id].McGroupData.IdHeader.Value = id;
 8032bd8:	f887 5039 	strb.w	r5, [r7, #57]	; 0x39
                McSessionData[id].McGroupData.McAddr =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032bdc:	5cc1      	ldrb	r1, [r0, r3]
 8032bde:	63f9      	str	r1, [r7, #60]	; 0x3c
 8032be0:	1cd3      	adds	r3, r2, #3
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032be2:	b2db      	uxtb	r3, r3
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032be4:	f102 0e05 	add.w	lr, r2, #5
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032be8:	5cc3      	ldrb	r3, [r0, r3]
 8032bea:	eb01 2103 	add.w	r1, r1, r3, lsl #8
 8032bee:	1d13      	adds	r3, r2, #4
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032bf0:	b2db      	uxtb	r3, r3
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032bf2:	63f9      	str	r1, [r7, #60]	; 0x3c
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032bf4:	5cc3      	ldrb	r3, [r0, r3]
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032bf6:	fa5f fe8e 	uxtb.w	lr, lr
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032bfa:	eb01 4103 	add.w	r1, r1, r3, lsl #16
 8032bfe:	63f9      	str	r1, [r7, #60]	; 0x3c
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032c00:	f810 e00e 	ldrb.w	lr, [r0, lr]
 8032c04:	fb0c bc05 	mla	ip, ip, r5, fp
 8032c08:	eb01 610e 	add.w	r1, r1, lr, lsl #24
 8032c0c:	63f9      	str	r1, [r7, #60]	; 0x3c
 8032c0e:	9103      	str	r1, [sp, #12]
 8032c10:	f10c 0108 	add.w	r1, ip, #8
 8032c14:	1d93      	adds	r3, r2, #6
 8032c16:	9104      	str	r1, [sp, #16]
 8032c18:	460f      	mov	r7, r1
 8032c1a:	f102 0116 	add.w	r1, r2, #22
 8032c1e:	b2db      	uxtb	r3, r3
                for( int8_t i = 0; i < 16; i++ )
 8032c20:	fa5f fe81 	uxtb.w	lr, r1
                    McSessionData[id].McGroupData.McKeyEncrypted[i] = mcpsIndication->Buffer[cmdIndex++];
 8032c24:	469c      	mov	ip, r3
 8032c26:	3301      	adds	r3, #1
 8032c28:	b2db      	uxtb	r3, r3
 8032c2a:	f810 c00c 	ldrb.w	ip, [r0, ip]
 8032c2e:	f807 cb01 	strb.w	ip, [r7], #1
                for( int8_t i = 0; i < 16; i++ )
 8032c32:	4573      	cmp	r3, lr
 8032c34:	d1f6      	bne.n	8032c24 <LmhpRemoteMcastSetupOnMcpsIndication+0x240>
                McSessionData[id].McGroupData.McFCountMin =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032c36:	b2c9      	uxtb	r1, r1
 8032c38:	f04f 0834 	mov.w	r8, #52	; 0x34
 8032c3c:	5c43      	ldrb	r3, [r0, r1]
 8032c3e:	fb08 6805 	mla	r8, r8, r5, r6
 8032c42:	f102 0117 	add.w	r1, r2, #23
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032c46:	b2c9      	uxtb	r1, r1
                McSessionData[id].McGroupData.McFCountMin =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032c48:	f8c8 3050 	str.w	r3, [r8, #80]	; 0x50
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032c4c:	5c41      	ldrb	r1, [r0, r1]
 8032c4e:	eb03 2301 	add.w	r3, r3, r1, lsl #8
 8032c52:	f102 0118 	add.w	r1, r2, #24
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032c56:	b2c9      	uxtb	r1, r1
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032c58:	f8c8 3050 	str.w	r3, [r8, #80]	; 0x50
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032c5c:	5c41      	ldrb	r1, [r0, r1]
 8032c5e:	eb03 4301 	add.w	r3, r3, r1, lsl #16
 8032c62:	f102 0119 	add.w	r1, r2, #25
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032c66:	b2c9      	uxtb	r1, r1
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032c68:	f8c8 3050 	str.w	r3, [r8, #80]	; 0x50
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032c6c:	5c41      	ldrb	r1, [r0, r1]
 8032c6e:	eb03 6301 	add.w	r3, r3, r1, lsl #24
 8032c72:	f102 011a 	add.w	r1, r2, #26
                McSessionData[id].McGroupData.McFCountMax =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032c76:	b2c9      	uxtb	r1, r1
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032c78:	f8c8 3050 	str.w	r3, [r8, #80]	; 0x50
                McSessionData[id].McGroupData.McFCountMax =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032c7c:	f102 071b 	add.w	r7, r2, #27
 8032c80:	5c41      	ldrb	r1, [r0, r1]
 8032c82:	f8c8 1054 	str.w	r1, [r8, #84]	; 0x54
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032c86:	b2ff      	uxtb	r7, r7
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032c88:	9305      	str	r3, [sp, #20]
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032c8a:	f810 9007 	ldrb.w	r9, [r0, r7]
 8032c8e:	f102 071c 	add.w	r7, r2, #28
 8032c92:	eb01 2109 	add.w	r1, r1, r9, lsl #8
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032c96:	b2ff      	uxtb	r7, r7
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032c98:	f8c8 1054 	str.w	r1, [r8, #84]	; 0x54
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032c9c:	f810 9007 	ldrb.w	r9, [r0, r7]
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032ca0:	f102 071e 	add.w	r7, r2, #30
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032ca4:	321d      	adds	r2, #29
 8032ca6:	eb01 4109 	add.w	r1, r1, r9, lsl #16
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032caa:	b2d2      	uxtb	r2, r2
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032cac:	f8c8 1054 	str.w	r1, [r8, #84]	; 0x54
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032cb0:	f810 9002 	ldrb.w	r9, [r0, r2]
 8032cb4:	eb01 6909 	add.w	r9, r1, r9, lsl #24
                McChannelParams_t channel =
 8032cb8:	2214      	movs	r2, #20
 8032cba:	2100      	movs	r1, #0
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032cbc:	f8c8 9054 	str.w	r9, [r8, #84]	; 0x54
                McChannelParams_t channel =
 8032cc0:	a80b      	add	r0, sp, #44	; 0x2c
 8032cc2:	f008 fd5f 	bl	803b784 <memset>
 8032cc6:	f240 2201 	movw	r2, #513	; 0x201
 8032cca:	f8ad 2020 	strh.w	r2, [sp, #32]
 8032cce:	2201      	movs	r2, #1
 8032cd0:	9b03      	ldr	r3, [sp, #12]
 8032cd2:	f88d 2022 	strb.w	r2, [sp, #34]	; 0x22
                    .GroupID = ( AddressIdentifier_t )McSessionData[id].McGroupData.IdHeader.Fields.McGroupId,
 8032cd6:	f898 1039 	ldrb.w	r1, [r8, #57]	; 0x39
                McChannelParams_t channel =
 8032cda:	9309      	str	r3, [sp, #36]	; 0x24
 8032cdc:	9b04      	ldr	r3, [sp, #16]
 8032cde:	930a      	str	r3, [sp, #40]	; 0x28
 8032ce0:	9b05      	ldr	r3, [sp, #20]
                    .GroupID = ( AddressIdentifier_t )McSessionData[id].McGroupData.IdHeader.Fields.McGroupId,
 8032ce2:	f3c1 0101 	ubfx	r1, r1, #0, #2
                if( LoRaMacMcChannelSetup( &channel ) == LORAMAC_STATUS_OK )
 8032ce6:	a808      	add	r0, sp, #32
                McChannelParams_t channel =
 8032ce8:	e9cd 390c 	strd	r3, r9, [sp, #48]	; 0x30
 8032cec:	f88d 1023 	strb.w	r1, [sp, #35]	; 0x23
                if( LoRaMacMcChannelSetup( &channel ) == LORAMAC_STATUS_OK )
 8032cf0:	f002 fa8c 	bl	803520c <LoRaMacMcChannelSetup>
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032cf4:	b2ff      	uxtb	r7, r7
                if( LoRaMacMcChannelSetup( &channel ) == LORAMAC_STATUS_OK )
 8032cf6:	2201      	movs	r2, #1
 8032cf8:	b998      	cbnz	r0, 8032d22 <LmhpRemoteMcastSetupOnMcpsIndication+0x33e>
                    McSessionData[id].McGroupData.McGroupEnabled = true;
 8032cfa:	f888 2038 	strb.w	r2, [r8, #56]	; 0x38
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_SETUP_ANS;
 8032cfe:	6871      	ldr	r1, [r6, #4]
 8032d00:	2302      	movs	r3, #2
 8032d02:	550b      	strb	r3, [r1, r4]
 8032d04:	1c62      	adds	r2, r4, #1
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = ( idError << 2 ) | McSessionData[id].McGroupData.IdHeader.Fields.McGroupId;
 8032d06:	441c      	add	r4, r3
 8032d08:	2334      	movs	r3, #52	; 0x34
 8032d0a:	fb03 6305 	mla	r3, r3, r5, r6
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_SETUP_ANS;
 8032d0e:	b2d2      	uxtb	r2, r2
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = ( idError << 2 ) | McSessionData[id].McGroupData.IdHeader.Fields.McGroupId;
 8032d10:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 8032d14:	f3c3 0301 	ubfx	r3, r3, #0, #2
 8032d18:	ea43 0080 	orr.w	r0, r3, r0, lsl #2
 8032d1c:	5488      	strb	r0, [r1, r2]
 8032d1e:	b2e4      	uxtb	r4, r4
                break;
 8032d20:	e686      	b.n	8032a30 <LmhpRemoteMcastSetupOnMcpsIndication+0x4c>
                uint8_t idError = 0x01; // One bit value
 8032d22:	4610      	mov	r0, r2
 8032d24:	e7eb      	b.n	8032cfe <LmhpRemoteMcastSetupOnMcpsIndication+0x31a>
 8032d26:	bf00      	nop
 8032d28:	20004a38 	.word	0x20004a38
 8032d2c:	20003560 	.word	0x20003560
 8032d30:	0803c2ea 	.word	0x0803c2ea
 8032d34:	0803c2af 	.word	0x0803c2af
 8032d38:	0803c2c2 	.word	0x0803c2c2
 8032d3c:	0803c2d7 	.word	0x0803c2d7
 8032d40:	0803c141 	.word	0x0803c141
 8032d44:	0803c2f0 	.word	0x0803c2f0
 8032d48:	0803c303 	.word	0x0803c303
 8032d4c:	0803c316 	.word	0x0803c316
 8032d50:	0803c329 	.word	0x0803c329
 8032d54:	0803c33e 	.word	0x0803c33e
 8032d58:	0803c351 	.word	0x0803c351
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032d5c:	5dc5      	ldrb	r5, [r0, r7]
                McSessionData[id].McGroupData.IdHeader.Value = 0;
 8032d5e:	2034      	movs	r0, #52	; 0x34
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032d60:	f005 0503 	and.w	r5, r5, #3
                McSessionData[id].McGroupData.IdHeader.Value = 0;
 8032d64:	fb00 6705 	mla	r7, r0, r5, r6
 8032d68:	f04f 0900 	mov.w	r9, #0
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032d6c:	3202      	adds	r2, #2
                UTIL_MEM_set_8( McSessionData[id].McGroupData.McKeyEncrypted, 0x00, 16 );
 8032d6e:	fb00 b005 	mla	r0, r0, r5, fp
                McSessionData[id].McGroupData.IdHeader.Value = 0;
 8032d72:	f887 9039 	strb.w	r9, [r7, #57]	; 0x39
                McSessionData[id].McGroupData.McAddr = 0;
 8032d76:	f8c7 903c 	str.w	r9, [r7, #60]	; 0x3c
                UTIL_MEM_set_8( McSessionData[id].McGroupData.McKeyEncrypted, 0x00, 16 );
 8032d7a:	4649      	mov	r1, r9
 8032d7c:	3008      	adds	r0, #8
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032d7e:	fa5f f882 	uxtb.w	r8, r2
                UTIL_MEM_set_8( McSessionData[id].McGroupData.McKeyEncrypted, 0x00, 16 );
 8032d82:	2210      	movs	r2, #16
 8032d84:	f008 f8ca 	bl	803af1c <UTIL_MEM_set_8>
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_DELETE_ANS;
 8032d88:	6873      	ldr	r3, [r6, #4]
 8032d8a:	2203      	movs	r2, #3
                McSessionData[id].McGroupData.McFCountMax = 0;
 8032d8c:	e9c7 9914 	strd	r9, r9, [r7, #80]	; 0x50
                if( LoRaMacMcChannelDelete( ( AddressIdentifier_t )id ) != LORAMAC_STATUS_OK )
 8032d90:	4628      	mov	r0, r5
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_DELETE_ANS;
 8032d92:	f104 0901 	add.w	r9, r4, #1
 8032d96:	551a      	strb	r2, [r3, r4]
 8032d98:	fa5f f989 	uxtb.w	r9, r9
                if( LoRaMacMcChannelDelete( ( AddressIdentifier_t )id ) != LORAMAC_STATUS_OK )
 8032d9c:	f002 fa84 	bl	80352a8 <LoRaMacMcChannelDelete>
 8032da0:	b140      	cbz	r0, 8032db4 <LmhpRemoteMcastSetupOnMcpsIndication+0x3d0>
                    status |= 0x04; // McGroupUndefined bit set
 8032da2:	f045 0304 	orr.w	r3, r5, #4
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = status;
 8032da6:	6872      	ldr	r2, [r6, #4]
 8032da8:	3402      	adds	r4, #2
 8032daa:	f802 3009 	strb.w	r3, [r2, r9]
 8032dae:	b2e4      	uxtb	r4, r4
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032db0:	4647      	mov	r7, r8
                break;
 8032db2:	e63d      	b.n	8032a30 <LmhpRemoteMcastSetupOnMcpsIndication+0x4c>
                    McSessionData[id].McGroupData.McGroupEnabled = false;
 8032db4:	f887 0038 	strb.w	r0, [r7, #56]	; 0x38
                status = id;
 8032db8:	462b      	mov	r3, r5
 8032dba:	e7f4      	b.n	8032da6 <LmhpRemoteMcastSetupOnMcpsIndication+0x3c2>
                uint8_t status = 0x00;
 8032dbc:	f04f 0300 	mov.w	r3, #0
 8032dc0:	f88d 301f 	strb.w	r3, [sp, #31]
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032dc4:	5dc5      	ldrb	r5, [r0, r7]
 8032dc6:	1c93      	adds	r3, r2, #2
 8032dc8:	f005 0503 	and.w	r5, r5, #3
                McSessionData[id].SessionTime =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032dcc:	b2db      	uxtb	r3, r3
 8032dce:	2134      	movs	r1, #52	; 0x34
 8032dd0:	fb01 6805 	mla	r8, r1, r5, r6
 8032dd4:	f102 0c03 	add.w	ip, r2, #3
 8032dd8:	5cc7      	ldrb	r7, [r0, r3]
 8032dda:	f8c8 705c 	str.w	r7, [r8, #92]	; 0x5c
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032dde:	fa5f fc8c 	uxtb.w	ip, ip
                McSessionData[id].SessionTime += UNIX_GPS_EPOCH_OFFSET;
 8032de2:	4b51      	ldr	r3, [pc, #324]	; (8032f28 <LmhpRemoteMcastSetupOnMcpsIndication+0x544>)
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032de4:	f810 c00c 	ldrb.w	ip, [r0, ip]
 8032de8:	eb07 270c 	add.w	r7, r7, ip, lsl #8
 8032dec:	f102 0c04 	add.w	ip, r2, #4
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032df0:	fa5f fc8c 	uxtb.w	ip, ip
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032df4:	f8c8 705c 	str.w	r7, [r8, #92]	; 0x5c
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032df8:	f810 c00c 	ldrb.w	ip, [r0, ip]
 8032dfc:	eb07 470c 	add.w	r7, r7, ip, lsl #16
 8032e00:	f102 0c05 	add.w	ip, r2, #5
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032e04:	fa5f fc8c 	uxtb.w	ip, ip
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032e08:	f8c8 705c 	str.w	r7, [r8, #92]	; 0x5c
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032e0c:	f810 c00c 	ldrb.w	ip, [r0, ip]
                McSessionData[id].SessionTime += UNIX_GPS_EPOCH_OFFSET;
 8032e10:	eb03 6c0c 	add.w	ip, r3, ip, lsl #24
 8032e14:	4467      	add	r7, ip
 8032e16:	f8c8 705c 	str.w	r7, [r8, #92]	; 0x5c
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032e1a:	1d97      	adds	r7, r2, #6
                McSessionData[id].SessionTimeout =  mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8032e1c:	b2ff      	uxtb	r7, r7
                McSessionData[id].RxParams.ClassC.Frequency =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032e1e:	f102 0c08 	add.w	ip, r2, #8
                McSessionData[id].SessionTimeout =  mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8032e22:	5dc7      	ldrb	r7, [r0, r7]
 8032e24:	f007 070f 	and.w	r7, r7, #15
 8032e28:	f888 7060 	strb.w	r7, [r8, #96]	; 0x60
 8032e2c:	1dd7      	adds	r7, r2, #7
                McSessionData[id].RxParams.ClassC.Frequency =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032e2e:	b2ff      	uxtb	r7, r7
                McSessionData[id].RxParams.ClassC.Frequency |= ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032e30:	fa5f fc8c 	uxtb.w	ip, ip
                McSessionData[id].RxParams.ClassC.Frequency =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032e34:	5dc7      	ldrb	r7, [r0, r7]
 8032e36:	f8c8 7064 	str.w	r7, [r8, #100]	; 0x64
                McSessionData[id].RxParams.ClassC.Frequency |= ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032e3a:	f810 c00c 	ldrb.w	ip, [r0, ip]
 8032e3e:	ea47 270c 	orr.w	r7, r7, ip, lsl #8
 8032e42:	f102 0c09 	add.w	ip, r2, #9
                McSessionData[id].RxParams.ClassC.Frequency |= ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032e46:	fa5f fc8c 	uxtb.w	ip, ip
                McSessionData[id].RxParams.ClassC.Frequency |= ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032e4a:	f8c8 7064 	str.w	r7, [r8, #100]	; 0x64
                McSessionData[id].RxParams.ClassC.Frequency |= ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032e4e:	f810 c00c 	ldrb.w	ip, [r0, ip]
 8032e52:	ea47 470c 	orr.w	r7, r7, ip, lsl #16
                McSessionData[id].RxParams.ClassC.Frequency *= 100;
 8032e56:	f04f 0c64 	mov.w	ip, #100	; 0x64
 8032e5a:	fb0c f707 	mul.w	r7, ip, r7
 8032e5e:	f8c8 7064 	str.w	r7, [r8, #100]	; 0x64
                McSessionData[id].RxParams.ClassC.Datarate = mcpsIndication->Buffer[cmdIndex++];
 8032e62:	f102 070b 	add.w	r7, r2, #11
                McSessionData[id].RxParams.ClassC.Frequency |= ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032e66:	320a      	adds	r2, #10
                McSessionData[id].RxParams.ClassC.Datarate = mcpsIndication->Buffer[cmdIndex++];
 8032e68:	b2d2      	uxtb	r2, r2
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_CLASS_C_SESSION_ANS;
 8032e6a:	f104 0901 	add.w	r9, r4, #1
                McSessionData[id].RxParams.ClassC.Datarate = mcpsIndication->Buffer[cmdIndex++];
 8032e6e:	5c82      	ldrb	r2, [r0, r2]
 8032e70:	f888 2068 	strb.w	r2, [r8, #104]	; 0x68
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_CLASS_C_SESSION_ANS;
 8032e74:	6872      	ldr	r2, [r6, #4]
 8032e76:	2004      	movs	r0, #4
                if( LoRaMacMcChannelSetupRxParams( ( AddressIdentifier_t )id, &McSessionData[id].RxParams, &status ) == LORAMAC_STATUS_OK )
 8032e78:	fb01 b105 	mla	r1, r1, r5, fp
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_CLASS_C_SESSION_ANS;
 8032e7c:	5510      	strb	r0, [r2, r4]
 8032e7e:	fa5f f389 	uxtb.w	r3, r9
                if( LoRaMacMcChannelSetupRxParams( ( AddressIdentifier_t )id, &McSessionData[id].RxParams, &status ) == LORAMAC_STATUS_OK )
 8032e82:	f10d 021f 	add.w	r2, sp, #31
 8032e86:	312c      	adds	r1, #44	; 0x2c
 8032e88:	4628      	mov	r0, r5
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_CLASS_C_SESSION_ANS;
 8032e8a:	9303      	str	r3, [sp, #12]
                if( LoRaMacMcChannelSetupRxParams( ( AddressIdentifier_t )id, &McSessionData[id].RxParams, &status ) == LORAMAC_STATUS_OK )
 8032e8c:	f002 fa3a 	bl	8035304 <LoRaMacMcChannelSetupRxParams>
                McSessionData[id].RxParams.ClassC.Datarate = mcpsIndication->Buffer[cmdIndex++];
 8032e90:	b2ff      	uxtb	r7, r7
                if( LoRaMacMcChannelSetupRxParams( ( AddressIdentifier_t )id, &McSessionData[id].RxParams, &status ) == LORAMAC_STATUS_OK )
 8032e92:	4681      	mov	r9, r0
 8032e94:	2800      	cmp	r0, #0
 8032e96:	d13d      	bne.n	8032f14 <LmhpRemoteMcastSetupOnMcpsIndication+0x530>
                    curTime = SysTimeGet( );
 8032e98:	a808      	add	r0, sp, #32
 8032e9a:	f008 f961 	bl	803b160 <SysTimeGet>
                    timeToSessionStart = McSessionData[id].SessionTime - curTime.Seconds;
 8032e9e:	f8d8 105c 	ldr.w	r1, [r8, #92]	; 0x5c
 8032ea2:	9b08      	ldr	r3, [sp, #32]
 8032ea4:	eba1 0803 	sub.w	r8, r1, r3
                    if( timeToSessionStart > 0 )
 8032ea8:	f1b8 0f00 	cmp.w	r8, #0
 8032eac:	dd2b      	ble.n	8032f06 <LmhpRemoteMcastSetupOnMcpsIndication+0x522>
                        TimerSetValue( &SessionStartTimer, timeToSessionStart * 1000 );
 8032eae:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8032eb2:	fb01 f108 	mul.w	r1, r1, r8
 8032eb6:	481d      	ldr	r0, [pc, #116]	; (8032f2c <LmhpRemoteMcastSetupOnMcpsIndication+0x548>)
 8032eb8:	9104      	str	r1, [sp, #16]
 8032eba:	f008 fac9 	bl	803b450 <UTIL_TIMER_SetPeriod>
                        TimerStart( &SessionStartTimer );
 8032ebe:	481b      	ldr	r0, [pc, #108]	; (8032f2c <LmhpRemoteMcastSetupOnMcpsIndication+0x548>)
 8032ec0:	f008 fa8c 	bl	803b3dc <UTIL_TIMER_Start>
                        MW_LOG(TS_OFF, VLEVEL_M, "Time2SessionStart: %d ms\r\n", timeToSessionStart * 1000);
 8032ec4:	9904      	ldr	r1, [sp, #16]
 8032ec6:	9100      	str	r1, [sp, #0]
 8032ec8:	4b19      	ldr	r3, [pc, #100]	; (8032f30 <LmhpRemoteMcastSetupOnMcpsIndication+0x54c>)
 8032eca:	464a      	mov	r2, r9
 8032ecc:	4649      	mov	r1, r9
 8032ece:	2002      	movs	r0, #2
 8032ed0:	f007 ff12 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = status;
 8032ed4:	6872      	ldr	r2, [r6, #4]
 8032ed6:	f89d 101f 	ldrb.w	r1, [sp, #31]
 8032eda:	9803      	ldr	r0, [sp, #12]
 8032edc:	1ca3      	adds	r3, r4, #2
 8032ede:	5411      	strb	r1, [r2, r0]
 8032ee0:	b2db      	uxtb	r3, r3
                if( status == 0x00 )
 8032ee2:	b971      	cbnz	r1, 8032f02 <LmhpRemoteMcastSetupOnMcpsIndication+0x51e>
                    LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (timeToSessionStart >> 0) & 0xFF;
 8032ee4:	f802 8003 	strb.w	r8, [r2, r3]
 8032ee8:	1ce3      	adds	r3, r4, #3
                    LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (timeToSessionStart >> 8) & 0xFF;
 8032eea:	b2db      	uxtb	r3, r3
 8032eec:	ea4f 2128 	mov.w	r1, r8, asr #8
 8032ef0:	54d1      	strb	r1, [r2, r3]
                    LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (timeToSessionStart >> 16) & 0xFF;
 8032ef2:	1d63      	adds	r3, r4, #5
                    LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (timeToSessionStart >> 8) & 0xFF;
 8032ef4:	3404      	adds	r4, #4
                    LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (timeToSessionStart >> 16) & 0xFF;
 8032ef6:	b2e4      	uxtb	r4, r4
 8032ef8:	ea4f 4828 	mov.w	r8, r8, asr #16
 8032efc:	f802 8004 	strb.w	r8, [r2, r4]
 8032f00:	b2db      	uxtb	r3, r3
                break;
 8032f02:	461c      	mov	r4, r3
 8032f04:	e594      	b.n	8032a30 <LmhpRemoteMcastSetupOnMcpsIndication+0x4c>
                        status |= 0x10;
 8032f06:	f89d 301f 	ldrb.w	r3, [sp, #31]
 8032f0a:	f043 0310 	orr.w	r3, r3, #16
 8032f0e:	f88d 301f 	strb.w	r3, [sp, #31]
 8032f12:	e7df      	b.n	8032ed4 <LmhpRemoteMcastSetupOnMcpsIndication+0x4f0>
                int32_t timeToSessionStart = 0;
 8032f14:	f04f 0800 	mov.w	r8, #0
 8032f18:	e7dc      	b.n	8032ed4 <LmhpRemoteMcastSetupOnMcpsIndication+0x4f0>
                McSessionData[id].SessionTime =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032f1a:	4e06      	ldr	r6, [pc, #24]	; (8032f34 <LmhpRemoteMcastSetupOnMcpsIndication+0x550>)
    uint8_t dataBufferIndex = 0;
 8032f1c:	2400      	movs	r4, #0
    uint8_t id = 0xFF;
 8032f1e:	25ff      	movs	r5, #255	; 0xff
    uint8_t cmdIndex = 0;
 8032f20:	4622      	mov	r2, r4
                if( LoRaMacMcChannelSetupRxParams( ( AddressIdentifier_t )id, &McSessionData[id].RxParams, &status ) == LORAMAC_STATUS_OK )
 8032f22:	f106 0b38 	add.w	fp, r6, #56	; 0x38
 8032f26:	e584      	b.n	8032a32 <LmhpRemoteMcastSetupOnMcpsIndication+0x4e>
 8032f28:	12d53d80 	.word	0x12d53d80
 8032f2c:	20004a40 	.word	0x20004a40
 8032f30:	0803c294 	.word	0x0803c294
 8032f34:	20004a38 	.word	0x20004a38

08032f38 <LmhpRemoteMcastSetupProcess>:
{
 8032f38:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8032f3a:	f3ef 8210 	mrs	r2, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8032f3e:	b672      	cpsid	i
    state = LmhpRemoteMcastSetupState.SessionState;
 8032f40:	4c17      	ldr	r4, [pc, #92]	; (8032fa0 <LmhpRemoteMcastSetupProcess+0x68>)
 8032f42:	78a3      	ldrb	r3, [r4, #2]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8032f44:	f382 8810 	msr	PRIMASK, r2
    switch( state )
 8032f48:	2b01      	cmp	r3, #1
 8032f4a:	d002      	beq.n	8032f52 <LmhpRemoteMcastSetupProcess+0x1a>
 8032f4c:	2b02      	cmp	r3, #2
 8032f4e:	d01d      	beq.n	8032f8c <LmhpRemoteMcastSetupProcess+0x54>
}
 8032f50:	bd10      	pop	{r4, pc}
            if ( LmHandlerRequestClass( CLASS_C ) == LORAMAC_HANDLER_SUCCESS )
 8032f52:	2002      	movs	r0, #2
 8032f54:	f7fe fb40 	bl	80315d8 <LmHandlerRequestClass>
 8032f58:	b960      	cbnz	r0, 8032f74 <LmhpRemoteMcastSetupProcess+0x3c>
                TimerSetValue( &SessionStopTimer, ( 1 << McSessionData[0].SessionTimeout ) * 1000 );
 8032f5a:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
                LmhpRemoteMcastSetupState.SessionState = REMOTE_MCAST_SETUP_SESSION_STATE_IDLE;
 8032f5e:	70a0      	strb	r0, [r4, #2]
                TimerSetValue( &SessionStopTimer, ( 1 << McSessionData[0].SessionTimeout ) * 1000 );
 8032f60:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8032f64:	4099      	lsls	r1, r3
                TimerSetValue( &SessionStopTimer, 1000 );
 8032f66:	f104 0020 	add.w	r0, r4, #32
 8032f6a:	f008 fa71 	bl	803b450 <UTIL_TIMER_SetPeriod>
                TimerStart(&SessionStopTimer);
 8032f6e:	f104 0020 	add.w	r0, r4, #32
 8032f72:	e007      	b.n	8032f84 <LmhpRemoteMcastSetupProcess+0x4c>
                TimerSetValue( &SessionStartTimer, 1000 );
 8032f74:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8032f78:	f104 0008 	add.w	r0, r4, #8
 8032f7c:	f008 fa68 	bl	803b450 <UTIL_TIMER_SetPeriod>
                TimerStart(&SessionStartTimer);
 8032f80:	f104 0008 	add.w	r0, r4, #8
}
 8032f84:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
                TimerStart(&SessionStopTimer);
 8032f88:	f008 ba28 	b.w	803b3dc <UTIL_TIMER_Start>
            if ( LmHandlerRequestClass( CLASS_A ) == LORAMAC_HANDLER_SUCCESS )
 8032f8c:	2000      	movs	r0, #0
 8032f8e:	f7fe fb23 	bl	80315d8 <LmHandlerRequestClass>
 8032f92:	b908      	cbnz	r0, 8032f98 <LmhpRemoteMcastSetupProcess+0x60>
                LmhpRemoteMcastSetupState.SessionState = REMOTE_MCAST_SETUP_SESSION_STATE_IDLE;
 8032f94:	70a0      	strb	r0, [r4, #2]
 8032f96:	e7db      	b.n	8032f50 <LmhpRemoteMcastSetupProcess+0x18>
                TimerSetValue( &SessionStopTimer, 1000 );
 8032f98:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8032f9c:	e7e3      	b.n	8032f66 <LmhpRemoteMcastSetupProcess+0x2e>
 8032f9e:	bf00      	nop
 8032fa0:	20004a38 	.word	0x20004a38

08032fa4 <LmhpRemoteMcastSetupPackageFactory>:
}
 8032fa4:	4800      	ldr	r0, [pc, #0]	; (8032fa8 <LmhpRemoteMcastSetupPackageFactory+0x4>)
 8032fa6:	4770      	bx	lr
 8032fa8:	20003560 	.word	0x20003560

08032fac <OnRadioRxError>:
    MW_LOG(TS_ON, VLEVEL_M, "MAC txTimeOut\r\n" );
}

static void OnRadioRxError( void )
{
    LoRaMacRadioEvents.Events.RxError = 1;
 8032fac:	4b05      	ldr	r3, [pc, #20]	; (8032fc4 <OnRadioRxError+0x18>)
 8032fae:	781a      	ldrb	r2, [r3, #0]
 8032fb0:	f042 0202 	orr.w	r2, r2, #2
 8032fb4:	701a      	strb	r2, [r3, #0]

    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 8032fb6:	f8d3 334c 	ldr.w	r3, [r3, #844]	; 0x34c
 8032fba:	b113      	cbz	r3, 8032fc2 <OnRadioRxError+0x16>
 8032fbc:	691b      	ldr	r3, [r3, #16]
 8032fbe:	b103      	cbz	r3, 8032fc2 <OnRadioRxError+0x16>
    {
        MacCtx.MacCallbacks->MacProcessNotify( );
 8032fc0:	4718      	bx	r3
    }
}
 8032fc2:	4770      	bx	lr
 8032fc4:	20004aa4 	.word	0x20004aa4

08032fc8 <UpdateRxSlotIdleState>:
    MW_LOG(TS_ON, VLEVEL_M, "MAC rxTimeOut\r\n" );
}

static void UpdateRxSlotIdleState( void )
{
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 8032fc8:	4a04      	ldr	r2, [pc, #16]	; (8032fdc <UpdateRxSlotIdleState+0x14>)
 8032fca:	f892 3608 	ldrb.w	r3, [r2, #1544]	; 0x608
 8032fce:	2b02      	cmp	r3, #2
    {
        MacCtx.RxSlot = RX_SLOT_NONE;
 8032fd0:	bf18      	it	ne
 8032fd2:	2306      	movne	r3, #6
 8032fd4:	f882 3484 	strb.w	r3, [r2, #1156]	; 0x484
    }
    else
    {
        MacCtx.RxSlot = RX_SLOT_WIN_CLASS_C;
    }
}
 8032fd8:	4770      	bx	lr
 8032fda:	bf00      	nop
 8032fdc:	20004aa4 	.word	0x20004aa4

08032fe0 <StopRetransmission>:
    return false;
}

static bool StopRetransmission( void )
{
    if( ( MacCtx.MacFlags.Bits.McpsInd == 0 ) ||
 8032fe0:	4b0f      	ldr	r3, [pc, #60]	; (8033020 <StopRetransmission+0x40>)
 8032fe2:	f893 2485 	ldrb.w	r2, [r3, #1157]	; 0x485
 8032fe6:	0792      	lsls	r2, r2, #30
 8032fe8:	d503      	bpl.n	8032ff2 <StopRetransmission+0x12>
 8032fea:	f893 2483 	ldrb.w	r2, [r3, #1155]	; 0x483
 8032fee:	2a01      	cmp	r2, #1
 8032ff0:	d907      	bls.n	8033002 <StopRetransmission+0x22>
        ( ( MacCtx.RxStatus.RxSlot != RX_SLOT_WIN_1 ) &&
          ( MacCtx.RxStatus.RxSlot != RX_SLOT_WIN_2 ) ) )
    {   // Maximum repetitions without downlink. Increase ADR Ack counter.
        // Only process the case when the MAC did not receive a downlink.
        if( Nvm.MacGroup2.AdrCtrlOn == true )
 8032ff2:	f893 260a 	ldrb.w	r2, [r3, #1546]	; 0x60a
 8032ff6:	b122      	cbz	r2, 8033002 <StopRetransmission+0x22>
        {
            Nvm.MacGroup1.AdrAckCounter++;
 8032ff8:	f8d3 2534 	ldr.w	r2, [r3, #1332]	; 0x534
 8032ffc:	3201      	adds	r2, #1
 8032ffe:	f8c3 2534 	str.w	r2, [r3, #1332]	; 0x534
        }
    }

    MacCtx.ChannelsNbTransCounter = 0;
 8033002:	2200      	movs	r2, #0
 8033004:	f883 2414 	strb.w	r2, [r3, #1044]	; 0x414
    MacCtx.NodeAckRequested = false;
 8033008:	f883 2418 	strb.w	r2, [r3, #1048]	; 0x418
    MacCtx.AckTimeoutRetry = false;
 803300c:	f883 2417 	strb.w	r2, [r3, #1047]	; 0x417
    MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 8033010:	f8d3 2344 	ldr.w	r2, [r3, #836]	; 0x344
 8033014:	f022 0202 	bic.w	r2, r2, #2
 8033018:	f8c3 2344 	str.w	r2, [r3, #836]	; 0x344

    return true;
}
 803301c:	2001      	movs	r0, #1
 803301e:	4770      	bx	lr
 8033020:	20004aa4 	.word	0x20004aa4

08033024 <GetMaxAppPayloadWithoutFOptsLength>:
{
 8033024:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8033026:	4b0c      	ldr	r3, [pc, #48]	; (8033058 <GetMaxAppPayloadWithoutFOptsLength+0x34>)
    getPhy.Datarate = datarate;
 8033028:	f88d 0009 	strb.w	r0, [sp, #9]
    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 803302c:	f893 2580 	ldrb.w	r2, [r3, #1408]	; 0x580
 8033030:	f88d 200a 	strb.w	r2, [sp, #10]
    getPhy.Attribute = PHY_MAX_PAYLOAD;
 8033034:	220d      	movs	r2, #13
 8033036:	f88d 2008 	strb.w	r2, [sp, #8]
    if( Nvm.MacGroup2.MacParams.RepeaterSupport == true )
 803303a:	f893 258c 	ldrb.w	r2, [r3, #1420]	; 0x58c
 803303e:	b112      	cbz	r2, 8033046 <GetMaxAppPayloadWithoutFOptsLength+0x22>
        getPhy.Attribute = PHY_MAX_PAYLOAD_REPEATER;
 8033040:	220e      	movs	r2, #14
 8033042:	f88d 2008 	strb.w	r2, [sp, #8]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8033046:	f893 054c 	ldrb.w	r0, [r3, #1356]	; 0x54c
 803304a:	a902      	add	r1, sp, #8
 803304c:	f003 fb67 	bl	803671e <RegionGetPhyParam>
}
 8033050:	b2c0      	uxtb	r0, r0
 8033052:	b005      	add	sp, #20
 8033054:	f85d fb04 	ldr.w	pc, [sp], #4
 8033058:	20004aa4 	.word	0x20004aa4

0803305c <OnAckTimeoutTimerEvent>:
{
 803305c:	b510      	push	{r4, lr}
    TimerStop( &MacCtx.AckTimeoutTimer );
 803305e:	4c0f      	ldr	r4, [pc, #60]	; (803309c <OnAckTimeoutTimerEvent+0x40>)
 8033060:	f504 707f 	add.w	r0, r4, #1020	; 0x3fc
 8033064:	f008 f96a 	bl	803b33c <UTIL_TIMER_Stop>
    if( MacCtx.NodeAckRequested == true )
 8033068:	f894 2418 	ldrb.w	r2, [r4, #1048]	; 0x418
 803306c:	4623      	mov	r3, r4
 803306e:	b112      	cbz	r2, 8033076 <OnAckTimeoutTimerEvent+0x1a>
        MacCtx.AckTimeoutRetry = true;
 8033070:	2201      	movs	r2, #1
 8033072:	f884 2417 	strb.w	r2, [r4, #1047]	; 0x417
    if( Nvm.MacGroup2.DeviceClass == CLASS_C )
 8033076:	f893 2608 	ldrb.w	r2, [r3, #1544]	; 0x608
 803307a:	2a02      	cmp	r2, #2
        MacCtx.MacFlags.Bits.MacDone = 1;
 803307c:	bf02      	ittt	eq
 803307e:	f893 2485 	ldrbeq.w	r2, [r3, #1157]	; 0x485
 8033082:	f042 0220 	orreq.w	r2, r2, #32
 8033086:	f883 2485 	strbeq.w	r2, [r3, #1157]	; 0x485
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 803308a:	f8d3 334c 	ldr.w	r3, [r3, #844]	; 0x34c
 803308e:	b123      	cbz	r3, 803309a <OnAckTimeoutTimerEvent+0x3e>
 8033090:	691b      	ldr	r3, [r3, #16]
 8033092:	b113      	cbz	r3, 803309a <OnAckTimeoutTimerEvent+0x3e>
}
 8033094:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        MacCtx.MacCallbacks->MacProcessNotify( );
 8033098:	4718      	bx	r3
}
 803309a:	bd10      	pop	{r4, pc}
 803309c:	20004aa4 	.word	0x20004aa4

080330a0 <PrepareRxDoneAbort>:
{
 80330a0:	b510      	push	{r4, lr}
    MacCtx.MacState |= LORAMAC_RX_ABORT;
 80330a2:	4c0c      	ldr	r4, [pc, #48]	; (80330d4 <PrepareRxDoneAbort+0x34>)
 80330a4:	f8d4 2344 	ldr.w	r2, [r4, #836]	; 0x344
 80330a8:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80330ac:	f8c4 2344 	str.w	r2, [r4, #836]	; 0x344
    if( MacCtx.NodeAckRequested == true )
 80330b0:	f894 2418 	ldrb.w	r2, [r4, #1048]	; 0x418
 80330b4:	b112      	cbz	r2, 80330bc <PrepareRxDoneAbort+0x1c>
        OnAckTimeoutTimerEvent( NULL );
 80330b6:	2000      	movs	r0, #0
 80330b8:	f7ff ffd0 	bl	803305c <OnAckTimeoutTimerEvent>
    MacCtx.MacFlags.Bits.McpsInd = 1;
 80330bc:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 80330c0:	f023 0322 	bic.w	r3, r3, #34	; 0x22
 80330c4:	f043 0322 	orr.w	r3, r3, #34	; 0x22
 80330c8:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
}
 80330cc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    UpdateRxSlotIdleState( );
 80330d0:	f7ff bf7a 	b.w	8032fc8 <UpdateRxSlotIdleState>
 80330d4:	20004aa4 	.word	0x20004aa4

080330d8 <HandleRadioRxErrorTimeout>:
{
 80330d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 80330dc:	4c2c      	ldr	r4, [pc, #176]	; (8033190 <HandleRadioRxErrorTimeout+0xb8>)
 80330de:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 80330e2:	2b02      	cmp	r3, #2
{
 80330e4:	4607      	mov	r7, r0
 80330e6:	460e      	mov	r6, r1
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 80330e8:	d002      	beq.n	80330f0 <HandleRadioRxErrorTimeout+0x18>
        Radio.Sleep( );
 80330ea:	4b2a      	ldr	r3, [pc, #168]	; (8033194 <HandleRadioRxErrorTimeout+0xbc>)
 80330ec:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80330ee:	4798      	blx	r3
    if( LoRaMacClassBIsBeaconExpected( ) == true )
 80330f0:	f002 fc5d 	bl	80359ae <LoRaMacClassBIsBeaconExpected>
 80330f4:	4605      	mov	r5, r0
 80330f6:	b128      	cbz	r0, 8033104 <HandleRadioRxErrorTimeout+0x2c>
        LoRaMacClassBSetBeaconState( BEACON_STATE_TIMEOUT );
 80330f8:	2002      	movs	r0, #2
 80330fa:	f002 fc4e 	bl	803599a <LoRaMacClassBSetBeaconState>
        LoRaMacClassBBeaconTimerEvent( NULL );
 80330fe:	2000      	movs	r0, #0
 8033100:	f002 fc50 	bl	80359a4 <LoRaMacClassBBeaconTimerEvent>
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 8033104:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 8033108:	2b01      	cmp	r3, #1
 803310a:	d117      	bne.n	803313c <HandleRadioRxErrorTimeout+0x64>
        if( LoRaMacClassBIsPingExpected( ) == true )
 803310c:	f002 fc51 	bl	80359b2 <LoRaMacClassBIsPingExpected>
 8033110:	4680      	mov	r8, r0
 8033112:	b130      	cbz	r0, 8033122 <HandleRadioRxErrorTimeout+0x4a>
            LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 8033114:	2000      	movs	r0, #0
 8033116:	f002 fc41 	bl	803599c <LoRaMacClassBSetPingSlotState>
            LoRaMacClassBPingSlotTimerEvent( NULL );
 803311a:	2000      	movs	r0, #0
 803311c:	f002 fc43 	bl	80359a6 <LoRaMacClassBPingSlotTimerEvent>
            classBRx = true;
 8033120:	4645      	mov	r5, r8
        if( LoRaMacClassBIsMulticastExpected( ) == true )
 8033122:	f002 fc48 	bl	80359b6 <LoRaMacClassBIsMulticastExpected>
 8033126:	b148      	cbz	r0, 803313c <HandleRadioRxErrorTimeout+0x64>
            LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 8033128:	2000      	movs	r0, #0
 803312a:	f002 fc38 	bl	803599e <LoRaMacClassBSetMulticastSlotState>
            LoRaMacClassBMulticastSlotTimerEvent( NULL );
 803312e:	2000      	movs	r0, #0
 8033130:	f002 fc3a 	bl	80359a8 <LoRaMacClassBMulticastSlotTimerEvent>
}
 8033134:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    UpdateRxSlotIdleState( );
 8033138:	f7ff bf46 	b.w	8032fc8 <UpdateRxSlotIdleState>
    if( classBRx == false )
 803313c:	2d00      	cmp	r5, #0
 803313e:	d1f9      	bne.n	8033134 <HandleRadioRxErrorTimeout+0x5c>
        if( MacCtx.RxSlot == RX_SLOT_WIN_1 )
 8033140:	f894 2484 	ldrb.w	r2, [r4, #1156]	; 0x484
 8033144:	f894 3418 	ldrb.w	r3, [r4, #1048]	; 0x418
 8033148:	b9ba      	cbnz	r2, 803317a <HandleRadioRxErrorTimeout+0xa2>
            if( MacCtx.NodeAckRequested == true )
 803314a:	b10b      	cbz	r3, 8033150 <HandleRadioRxErrorTimeout+0x78>
                MacCtx.McpsConfirm.Status = rx1EventInfoStatus;
 803314c:	f884 743d 	strb.w	r7, [r4, #1085]	; 0x43d
            LoRaMacConfirmQueueSetStatusCmn( rx1EventInfoStatus );
 8033150:	4638      	mov	r0, r7
 8033152:	f002 fdd9 	bl	8035d08 <LoRaMacConfirmQueueSetStatusCmn>
            if( TimerGetElapsedTime( Nvm.MacGroup1.LastTxDoneTime ) >= MacCtx.RxWindow2Delay )
 8033156:	f8d4 0538 	ldr.w	r0, [r4, #1336]	; 0x538
 803315a:	f008 f8b5 	bl	803b2c8 <UTIL_TIMER_GetElapsedTime>
 803315e:	f8d4 33b8 	ldr.w	r3, [r4, #952]	; 0x3b8
 8033162:	4298      	cmp	r0, r3
 8033164:	d3e6      	bcc.n	8033134 <HandleRadioRxErrorTimeout+0x5c>
                TimerStop( &MacCtx.RxWindowTimer2 );
 8033166:	480c      	ldr	r0, [pc, #48]	; (8033198 <HandleRadioRxErrorTimeout+0xc0>)
 8033168:	f008 f8e8 	bl	803b33c <UTIL_TIMER_Stop>
                MacCtx.MacFlags.Bits.MacDone = 1;
 803316c:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 8033170:	f043 0320 	orr.w	r3, r3, #32
 8033174:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
 8033178:	e7dc      	b.n	8033134 <HandleRadioRxErrorTimeout+0x5c>
            if( MacCtx.NodeAckRequested == true )
 803317a:	b10b      	cbz	r3, 8033180 <HandleRadioRxErrorTimeout+0xa8>
                MacCtx.McpsConfirm.Status = rx2EventInfoStatus;
 803317c:	f884 643d 	strb.w	r6, [r4, #1085]	; 0x43d
            LoRaMacConfirmQueueSetStatusCmn( rx2EventInfoStatus );
 8033180:	4630      	mov	r0, r6
 8033182:	f002 fdc1 	bl	8035d08 <LoRaMacConfirmQueueSetStatusCmn>
            if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 8033186:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 803318a:	2b02      	cmp	r3, #2
 803318c:	d1ee      	bne.n	803316c <HandleRadioRxErrorTimeout+0x94>
 803318e:	e7d1      	b.n	8033134 <HandleRadioRxErrorTimeout+0x5c>
 8033190:	20004aa4 	.word	0x20004aa4
 8033194:	0803bc30 	.word	0x0803bc30
 8033198:	20004e40 	.word	0x20004e40

0803319c <OnRadioRxTimeout>:
    LoRaMacRadioEvents.Events.RxTimeout = 1;
 803319c:	4b09      	ldr	r3, [pc, #36]	; (80331c4 <OnRadioRxTimeout+0x28>)
 803319e:	781a      	ldrb	r2, [r3, #0]
 80331a0:	f042 0201 	orr.w	r2, r2, #1
{
 80331a4:	b510      	push	{r4, lr}
    LoRaMacRadioEvents.Events.RxTimeout = 1;
 80331a6:	701a      	strb	r2, [r3, #0]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 80331a8:	f8d3 334c 	ldr.w	r3, [r3, #844]	; 0x34c
 80331ac:	b113      	cbz	r3, 80331b4 <OnRadioRxTimeout+0x18>
 80331ae:	691b      	ldr	r3, [r3, #16]
 80331b0:	b103      	cbz	r3, 80331b4 <OnRadioRxTimeout+0x18>
        MacCtx.MacCallbacks->MacProcessNotify( );
 80331b2:	4798      	blx	r3
}
 80331b4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    MW_LOG(TS_ON, VLEVEL_M, "MAC rxTimeOut\r\n" );
 80331b8:	4b03      	ldr	r3, [pc, #12]	; (80331c8 <OnRadioRxTimeout+0x2c>)
 80331ba:	2201      	movs	r2, #1
 80331bc:	2100      	movs	r1, #0
 80331be:	2002      	movs	r0, #2
 80331c0:	f007 bd9a 	b.w	803acf8 <UTIL_ADV_TRACE_COND_FSend>
 80331c4:	20004aa4 	.word	0x20004aa4
 80331c8:	0803c367 	.word	0x0803c367

080331cc <OnRadioTxTimeout>:
    LoRaMacRadioEvents.Events.TxTimeout = 1;
 80331cc:	4b09      	ldr	r3, [pc, #36]	; (80331f4 <OnRadioTxTimeout+0x28>)
 80331ce:	781a      	ldrb	r2, [r3, #0]
 80331d0:	f042 0204 	orr.w	r2, r2, #4
{
 80331d4:	b510      	push	{r4, lr}
    LoRaMacRadioEvents.Events.TxTimeout = 1;
 80331d6:	701a      	strb	r2, [r3, #0]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 80331d8:	f8d3 334c 	ldr.w	r3, [r3, #844]	; 0x34c
 80331dc:	b113      	cbz	r3, 80331e4 <OnRadioTxTimeout+0x18>
 80331de:	691b      	ldr	r3, [r3, #16]
 80331e0:	b103      	cbz	r3, 80331e4 <OnRadioTxTimeout+0x18>
        MacCtx.MacCallbacks->MacProcessNotify( );
 80331e2:	4798      	blx	r3
}
 80331e4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    MW_LOG(TS_ON, VLEVEL_M, "MAC txTimeOut\r\n" );
 80331e8:	4b03      	ldr	r3, [pc, #12]	; (80331f8 <OnRadioTxTimeout+0x2c>)
 80331ea:	2201      	movs	r2, #1
 80331ec:	2100      	movs	r1, #0
 80331ee:	2002      	movs	r0, #2
 80331f0:	f007 bd82 	b.w	803acf8 <UTIL_ADV_TRACE_COND_FSend>
 80331f4:	20004aa4 	.word	0x20004aa4
 80331f8:	0803c377 	.word	0x0803c377

080331fc <OnRadioRxDone>:
{
 80331fc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8033200:	4616      	mov	r6, r2
 8033202:	461d      	mov	r5, r3
 8033204:	4680      	mov	r8, r0
 8033206:	460f      	mov	r7, r1
    RxDoneParams.LastRxDone = TimerGetCurrentTime( );
 8033208:	f008 f854 	bl	803b2b4 <UTIL_TIMER_GetCurrentTime>
    LoRaMacRadioEvents.Events.RxDone = 1;
 803320c:	4b0c      	ldr	r3, [pc, #48]	; (8033240 <OnRadioRxDone+0x44>)
    RxDoneParams.LastRxDone = TimerGetCurrentTime( );
 803320e:	4c0d      	ldr	r4, [pc, #52]	; (8033244 <OnRadioRxDone+0x48>)
    LoRaMacRadioEvents.Events.RxDone = 1;
 8033210:	781a      	ldrb	r2, [r3, #0]
    RxDoneParams.Size = size;
 8033212:	8127      	strh	r7, [r4, #8]
    LoRaMacRadioEvents.Events.RxDone = 1;
 8033214:	f042 0208 	orr.w	r2, r2, #8
 8033218:	701a      	strb	r2, [r3, #0]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 803321a:	f8d3 334c 	ldr.w	r3, [r3, #844]	; 0x34c
    RxDoneParams.Rssi = rssi;
 803321e:	8166      	strh	r6, [r4, #10]
    RxDoneParams.Payload = payload;
 8033220:	e9c4 0800 	strd	r0, r8, [r4]
    RxDoneParams.Snr = snr;
 8033224:	7325      	strb	r5, [r4, #12]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 8033226:	b113      	cbz	r3, 803322e <OnRadioRxDone+0x32>
 8033228:	691b      	ldr	r3, [r3, #16]
 803322a:	b103      	cbz	r3, 803322e <OnRadioRxDone+0x32>
        MacCtx.MacCallbacks->MacProcessNotify( );
 803322c:	4798      	blx	r3
}
 803322e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    MW_LOG(TS_ON, VLEVEL_M, "MAC rxDone\r\n" );
 8033232:	4b05      	ldr	r3, [pc, #20]	; (8033248 <OnRadioRxDone+0x4c>)
 8033234:	2201      	movs	r2, #1
 8033236:	2100      	movs	r1, #0
 8033238:	2002      	movs	r0, #2
 803323a:	f007 bd5d 	b.w	803acf8 <UTIL_ADV_TRACE_COND_FSend>
 803323e:	bf00      	nop
 8033240:	20004aa4 	.word	0x20004aa4
 8033244:	20006314 	.word	0x20006314
 8033248:	0803c387 	.word	0x0803c387

0803324c <OnRadioTxDone>:
{
 803324c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    TxDoneParams.CurTime = TimerGetCurrentTime( );
 803324e:	f008 f831 	bl	803b2b4 <UTIL_TIMER_GetCurrentTime>
 8033252:	4b10      	ldr	r3, [pc, #64]	; (8033294 <OnRadioTxDone+0x48>)
    MacCtx.LastTxSysTime = SysTimeGet( );
 8033254:	4c10      	ldr	r4, [pc, #64]	; (8033298 <OnRadioTxDone+0x4c>)
    TxDoneParams.CurTime = TimerGetCurrentTime( );
 8033256:	6018      	str	r0, [r3, #0]
    MacCtx.LastTxSysTime = SysTimeGet( );
 8033258:	466d      	mov	r5, sp
 803325a:	4628      	mov	r0, r5
 803325c:	f007 ff80 	bl	803b160 <SysTimeGet>
 8033260:	e895 0003 	ldmia.w	r5, {r0, r1}
 8033264:	f504 734f 	add.w	r3, r4, #828	; 0x33c
 8033268:	e883 0003 	stmia.w	r3, {r0, r1}
    LoRaMacRadioEvents.Events.TxDone = 1;
 803326c:	7823      	ldrb	r3, [r4, #0]
 803326e:	f043 0310 	orr.w	r3, r3, #16
 8033272:	7023      	strb	r3, [r4, #0]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 8033274:	f8d4 334c 	ldr.w	r3, [r4, #844]	; 0x34c
 8033278:	b113      	cbz	r3, 8033280 <OnRadioTxDone+0x34>
 803327a:	691b      	ldr	r3, [r3, #16]
 803327c:	b103      	cbz	r3, 8033280 <OnRadioTxDone+0x34>
        MacCtx.MacCallbacks->MacProcessNotify( );
 803327e:	4798      	blx	r3
    MW_LOG(TS_ON, VLEVEL_M, "MAC txDone\r\n" );
 8033280:	4b06      	ldr	r3, [pc, #24]	; (803329c <OnRadioTxDone+0x50>)
 8033282:	2201      	movs	r2, #1
 8033284:	2100      	movs	r1, #0
 8033286:	2002      	movs	r0, #2
}
 8033288:	b003      	add	sp, #12
 803328a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    MW_LOG(TS_ON, VLEVEL_M, "MAC txDone\r\n" );
 803328e:	f007 bd33 	b.w	803acf8 <UTIL_ADV_TRACE_COND_FSend>
 8033292:	bf00      	nop
 8033294:	20006310 	.word	0x20006310
 8033298:	20004aa4 	.word	0x20004aa4
 803329c:	0803c394 	.word	0x0803c394

080332a0 <ResetMacParameters>:
{
 80332a0:	b5f0      	push	{r4, r5, r6, r7, lr}
    Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_NONE;
 80332a2:	4c46      	ldr	r4, [pc, #280]	; (80333bc <ResetMacParameters+0x11c>)
    Nvm.MacGroup1.ChannelsTxPower = Nvm.MacGroup2.ChannelsTxPowerDefault;
 80332a4:	f8b4 25d0 	ldrh.w	r2, [r4, #1488]	; 0x5d0
    Nvm.MacGroup2.MacParams.Rx2Channel = Nvm.MacGroup2.MacParamsDefaults.Rx2Channel;
 80332a8:	f8d4 15b4 	ldr.w	r1, [r4, #1460]	; 0x5b4
 80332ac:	f8d4 05b0 	ldr.w	r0, [r4, #1456]	; 0x5b0
    Nvm.MacGroup1.ChannelsTxPower = Nvm.MacGroup2.ChannelsTxPowerDefault;
 80332b0:	f8a4 2544 	strh.w	r2, [r4, #1348]	; 0x544
    Nvm.MacGroup2.MacParams.Rx1DrOffset = Nvm.MacGroup2.MacParamsDefaults.Rx1DrOffset;
 80332b4:	f894 25ad 	ldrb.w	r2, [r4, #1453]	; 0x5ad
 80332b8:	f884 256d 	strb.w	r2, [r4, #1389]	; 0x56d
    Nvm.MacGroup2.MacParams.Rx2Channel = Nvm.MacGroup2.MacParamsDefaults.Rx2Channel;
 80332bc:	f504 62ae 	add.w	r2, r4, #1392	; 0x570
 80332c0:	e882 0003 	stmia.w	r2, {r0, r1}
    Nvm.MacGroup2.MacParams.RxCChannel = Nvm.MacGroup2.MacParamsDefaults.RxCChannel;
 80332c4:	f8d4 15bc 	ldr.w	r1, [r4, #1468]	; 0x5bc
 80332c8:	f8d4 05b8 	ldr.w	r0, [r4, #1464]	; 0x5b8
 80332cc:	f504 62af 	add.w	r2, r4, #1400	; 0x578
{
 80332d0:	b08f      	sub	sp, #60	; 0x3c
    Nvm.MacGroup2.MacParams.RxCChannel = Nvm.MacGroup2.MacParamsDefaults.RxCChannel;
 80332d2:	e882 0003 	stmia.w	r2, {r0, r1}
    Nvm.MacGroup2.MacParams.UplinkDwellTime = Nvm.MacGroup2.MacParamsDefaults.UplinkDwellTime;
 80332d6:	f8b4 25c0 	ldrh.w	r2, [r4, #1472]	; 0x5c0
 80332da:	f8a4 2580 	strh.w	r2, [r4, #1408]	; 0x580
    Nvm.MacGroup2.AggregatedDCycle = 1;
 80332de:	2301      	movs	r3, #1
    Nvm.MacGroup2.MacParams.MaxEirp = Nvm.MacGroup2.MacParamsDefaults.MaxEirp;
 80332e0:	f8d4 25c4 	ldr.w	r2, [r4, #1476]	; 0x5c4
    Nvm.MacGroup2.AggregatedDCycle = 1;
 80332e4:	f8a4 360e 	strh.w	r3, [r4, #1550]	; 0x60e
    Nvm.MacGroup2.MacParams.MaxEirp = Nvm.MacGroup2.MacParamsDefaults.MaxEirp;
 80332e8:	f8c4 2584 	str.w	r2, [r4, #1412]	; 0x584
    params.Type = INIT_TYPE_RESET_TO_DEFAULT_CHANNELS;
 80332ec:	f88d 3014 	strb.w	r3, [sp, #20]
    Nvm.MacGroup2.MacParams.AntennaGain = Nvm.MacGroup2.MacParamsDefaults.AntennaGain;
 80332f0:	f8d4 25c8 	ldr.w	r2, [r4, #1480]	; 0x5c8
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 80332f4:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    Nvm.MacGroup2.MacParams.AntennaGain = Nvm.MacGroup2.MacParamsDefaults.AntennaGain;
 80332f8:	f8c4 2588 	str.w	r2, [r4, #1416]	; 0x588
    params.NvmGroup1 = &Nvm.RegionGroup1;
 80332fc:	f504 63e5 	add.w	r3, r4, #1832	; 0x728
    Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_NONE;
 8033300:	2500      	movs	r5, #0
    MacCtx.ChannelsNbTransCounter = 0;
 8033302:	4a2f      	ldr	r2, [pc, #188]	; (80333c0 <ResetMacParameters+0x120>)
    params.NvmGroup1 = &Nvm.RegionGroup1;
 8033304:	9303      	str	r3, [sp, #12]
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 8033306:	a903      	add	r1, sp, #12
    params.NvmGroup2 = &Nvm.RegionGroup2;
 8033308:	f204 73cc 	addw	r3, r4, #1996	; 0x7cc
    MacCtx.ChannelsNbTransCounter = 0;
 803330c:	f8c4 2414 	str.w	r2, [r4, #1044]	; 0x414
    params.NvmGroup2 = &Nvm.RegionGroup2;
 8033310:	9304      	str	r3, [sp, #16]
    Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_NONE;
 8033312:	f884 561c 	strb.w	r5, [r4, #1564]	; 0x61c
    Nvm.MacGroup1.AdrAckCounter = 0;
 8033316:	f8c4 5534 	str.w	r5, [r4, #1332]	; 0x534
    Nvm.MacGroup2.MaxDCycle = 0;
 803331a:	f884 560b 	strb.w	r5, [r4, #1547]	; 0x60b
    MacCtx.NodeAckRequested = false;
 803331e:	f884 5418 	strb.w	r5, [r4, #1048]	; 0x418
    Nvm.MacGroup1.SrvAckRequested = false;
 8033322:	f884 5546 	strb.w	r5, [r4, #1350]	; 0x546
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 8033326:	f003 fa15 	bl	8036754 <RegionInitDefaults>
    MacCtx.RxWindow2Config.Frequency = Nvm.MacGroup2.MacParams.Rx2Channel.Frequency;
 803332a:	f8d4 3570 	ldr.w	r3, [r4, #1392]	; 0x570
 803332e:	f8c4 33d4 	str.w	r3, [r4, #980]	; 0x3d4
    MacCtx.RxWindow2Config.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 8033332:	f894 3581 	ldrb.w	r3, [r4, #1409]	; 0x581
 8033336:	f884 33e0 	strb.w	r3, [r4, #992]	; 0x3e0
    MacCtx.RxWindow2Config.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport; /* ST_WORKAROUND: Keep repeater feature */
 803333a:	f894 358c 	ldrb.w	r3, [r4, #1420]	; 0x58c
 803333e:	f884 33e1 	strb.w	r3, [r4, #993]	; 0x3e1
    MacCtx.RxWindow2Config.RxContinuous = false;
 8033342:	f44f 7380 	mov.w	r3, #256	; 0x100
 8033346:	f8a4 33e2 	strh.w	r3, [r4, #994]	; 0x3e2
    MacCtx.RxWindow2Config.Channel = MacCtx.Channel;
 803334a:	f884 53d0 	strb.w	r5, [r4, #976]	; 0x3d0
    MacCtx.RxWindowCConfig = MacCtx.RxWindow2Config;
 803334e:	f504 7774 	add.w	r7, r4, #976	; 0x3d0
 8033352:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8033354:	f504 7679 	add.w	r6, r4, #996	; 0x3e4
 8033358:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 803335a:	683b      	ldr	r3, [r7, #0]
 803335c:	6033      	str	r3, [r6, #0]
    MacCtx.RxWindowCConfig.RxContinuous = true;
 803335e:	f240 2301 	movw	r3, #513	; 0x201
 8033362:	f8a4 33f6 	strh.w	r3, [r4, #1014]	; 0x3f6
    if( MacCtx.MacCallbacks != NULL )
 8033366:	f8d4 334c 	ldr.w	r3, [r4, #844]	; 0x34c
    MacCtx.Channel = 0;
 803336a:	f884 5419 	strb.w	r5, [r4, #1049]	; 0x419
    classBCallbacks.MacProcessNotify = NULL;
 803336e:	e9cd 5501 	strd	r5, r5, [sp, #4]
    if( MacCtx.MacCallbacks != NULL )
 8033372:	b11b      	cbz	r3, 803337c <ResetMacParameters+0xdc>
        classBCallbacks.GetTemperatureLevel = MacCtx.MacCallbacks->GetTemperatureLevel;
 8033374:	685a      	ldr	r2, [r3, #4]
        classBCallbacks.MacProcessNotify = MacCtx.MacCallbacks->MacProcessNotify;
 8033376:	691b      	ldr	r3, [r3, #16]
        classBCallbacks.GetTemperatureLevel = MacCtx.MacCallbacks->GetTemperatureLevel;
 8033378:	9201      	str	r2, [sp, #4]
        classBCallbacks.MacProcessNotify = MacCtx.MacCallbacks->MacProcessNotify;
 803337a:	9302      	str	r3, [sp, #8]
    classBParams.MlmeIndication = &MacCtx.MlmeIndication;
 803337c:	4a11      	ldr	r2, [pc, #68]	; (80333c4 <ResetMacParameters+0x124>)
 803337e:	9206      	str	r2, [sp, #24]
    classBParams.McpsIndication = &MacCtx.McpsIndication;
 8033380:	f1a2 0344 	sub.w	r3, r2, #68	; 0x44
 8033384:	9307      	str	r3, [sp, #28]
    classBParams.MlmeConfirm = &MacCtx.MlmeConfirm;
 8033386:	f1a2 0314 	sub.w	r3, r2, #20
 803338a:	9308      	str	r3, [sp, #32]
    classBParams.LoRaMacFlags = &MacCtx.MacFlags;
 803338c:	f102 0321 	add.w	r3, r2, #33	; 0x21
 8033390:	9309      	str	r3, [sp, #36]	; 0x24
    classBParams.LoRaMacDevAddr = &Nvm.MacGroup2.DevAddr;
 8033392:	f502 73ba 	add.w	r3, r2, #372	; 0x174
 8033396:	930a      	str	r3, [sp, #40]	; 0x28
    classBParams.LoRaMacRegion = &Nvm.MacGroup2.Region;
 8033398:	f102 03e8 	add.w	r3, r2, #232	; 0xe8
 803339c:	930b      	str	r3, [sp, #44]	; 0x2c
    classBParams.LoRaMacParams = &Nvm.MacGroup2.MacParams;
 803339e:	f102 03ec 	add.w	r3, r2, #236	; 0xec
 80333a2:	930c      	str	r3, [sp, #48]	; 0x30
    LoRaMacClassBInit( &classBParams, &classBCallbacks, &Nvm.ClassB );
 80333a4:	a901      	add	r1, sp, #4
    classBParams.MulticastChannels = &Nvm.MacGroup2.MulticastChannelList[0];
 80333a6:	f502 73bc 	add.w	r3, r2, #376	; 0x178
    LoRaMacClassBInit( &classBParams, &classBCallbacks, &Nvm.ClassB );
 80333aa:	a806      	add	r0, sp, #24
 80333ac:	f202 62e4 	addw	r2, r2, #1764	; 0x6e4
    classBParams.MulticastChannels = &Nvm.MacGroup2.MulticastChannelList[0];
 80333b0:	930d      	str	r3, [sp, #52]	; 0x34
    LoRaMacClassBInit( &classBParams, &classBCallbacks, &Nvm.ClassB );
 80333b2:	f002 faf1 	bl	8035998 <LoRaMacClassBInit>
}
 80333b6:	b00f      	add	sp, #60	; 0x3c
 80333b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80333ba:	bf00      	nop
 80333bc:	20004aa4 	.word	0x20004aa4
 80333c0:	00010100 	.word	0x00010100
 80333c4:	20004f08 	.word	0x20004f08

080333c8 <ScheduleTx>:
{
 80333c8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80333ca:	b093      	sub	sp, #76	; 0x4c
 80333cc:	4607      	mov	r7, r0
    if( LoRaMacClassBIsBeaconExpected( ) == true )
 80333ce:	f002 faee 	bl	80359ae <LoRaMacClassBIsBeaconExpected>
 80333d2:	2800      	cmp	r0, #0
 80333d4:	f040 8163 	bne.w	803369e <ScheduleTx+0x2d6>
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 80333d8:	4cb2      	ldr	r4, [pc, #712]	; (80336a4 <ScheduleTx+0x2dc>)
 80333da:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 80333de:	2b01      	cmp	r3, #1
 80333e0:	d009      	beq.n	80333f6 <ScheduleTx+0x2e>
    if( Nvm.MacGroup1.AggregatedTimeOff == 0 )
 80333e2:	f8d4 353c 	ldr.w	r3, [r4, #1340]	; 0x53c
 80333e6:	b193      	cbz	r3, 803340e <ScheduleTx+0x46>
    switch( MacCtx.TxMsg.Type )
 80333e8:	f894 3108 	ldrb.w	r3, [r4, #264]	; 0x108
 80333ec:	b1c3      	cbz	r3, 8033420 <ScheduleTx+0x58>
 80333ee:	2b04      	cmp	r3, #4
 80333f0:	d076      	beq.n	80334e0 <ScheduleTx+0x118>
            return LORAMAC_STATUS_PARAMETER_INVALID;
 80333f2:	2503      	movs	r5, #3
 80333f4:	e003      	b.n	80333fe <ScheduleTx+0x36>
        if( LoRaMacClassBIsPingExpected( ) == true )
 80333f6:	f002 fadc 	bl	80359b2 <LoRaMacClassBIsPingExpected>
 80333fa:	b118      	cbz	r0, 8033404 <ScheduleTx+0x3c>
            return LORAMAC_STATUS_BUSY_PING_SLOT_WINDOW_TIME;
 80333fc:	250f      	movs	r5, #15
}
 80333fe:	4628      	mov	r0, r5
 8033400:	b013      	add	sp, #76	; 0x4c
 8033402:	bdf0      	pop	{r4, r5, r6, r7, pc}
        else if( LoRaMacClassBIsMulticastExpected( ) == true )
 8033404:	f002 fad7 	bl	80359b6 <LoRaMacClassBIsMulticastExpected>
 8033408:	2800      	cmp	r0, #0
 803340a:	d0ea      	beq.n	80333e2 <ScheduleTx+0x1a>
 803340c:	e7f6      	b.n	80333fc <ScheduleTx+0x34>
        Nvm.MacGroup1.AggregatedTimeOff = ( MacCtx.TxTimeOnAir * Nvm.MacGroup2.AggregatedDCycle - MacCtx.TxTimeOnAir );
 803340e:	f8b4 360e 	ldrh.w	r3, [r4, #1550]	; 0x60e
 8033412:	1e5a      	subs	r2, r3, #1
 8033414:	f8d4 341c 	ldr.w	r3, [r4, #1052]	; 0x41c
 8033418:	4353      	muls	r3, r2
 803341a:	f8c4 353c 	str.w	r3, [r4, #1340]	; 0x53c
 803341e:	e7e3      	b.n	80333e8 <ScheduleTx+0x20>
            serializeStatus = LoRaMacSerializerJoinRequest( &MacCtx.TxMsg.Message.JoinReq );
 8033420:	48a1      	ldr	r0, [pc, #644]	; (80336a8 <ScheduleTx+0x2e0>)
 8033422:	f003 f8ce 	bl	80365c2 <LoRaMacSerializerJoinRequest>
            if( LORAMAC_SERIALIZER_SUCCESS != serializeStatus )
 8033426:	2800      	cmp	r0, #0
 8033428:	f040 8135 	bne.w	8033696 <ScheduleTx+0x2ce>
            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.Data.BufSize;
 803342c:	f894 3110 	ldrb.w	r3, [r4, #272]	; 0x110
 8033430:	80a3      	strh	r3, [r4, #4]
    nextChan.AggrTimeOff = Nvm.MacGroup1.AggregatedTimeOff;
 8033432:	f8d4 353c 	ldr.w	r3, [r4, #1340]	; 0x53c
 8033436:	930c      	str	r3, [sp, #48]	; 0x30
    nextChan.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );
 8033438:	ae06      	add	r6, sp, #24
    nextChan.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 803343a:	f894 3545 	ldrb.w	r3, [r4, #1349]	; 0x545
 803343e:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
    nextChan.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );
 8033442:	4630      	mov	r0, r6
    nextChan.DutyCycleEnabled = Nvm.MacGroup2.DutyCycleOn;
 8033444:	f894 360c 	ldrb.w	r3, [r4, #1548]	; 0x60c
 8033448:	f88d 303a 	strb.w	r3, [sp, #58]	; 0x3a
    nextChan.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );
 803344c:	f007 feae 	bl	803b1ac <SysTimeGetMcuTime>
 8033450:	f8d4 3614 	ldr.w	r3, [r4, #1556]	; 0x614
 8033454:	9300      	str	r3, [sp, #0]
 8033456:	ad02      	add	r5, sp, #8
 8033458:	e896 0006 	ldmia.w	r6, {r1, r2}
 803345c:	f8d4 3610 	ldr.w	r3, [r4, #1552]	; 0x610
 8033460:	4628      	mov	r0, r5
 8033462:	f007 fe39 	bl	803b0d8 <SysTimeSub>
 8033466:	e895 0003 	ldmia.w	r5, {r0, r1}
 803346a:	ab0f      	add	r3, sp, #60	; 0x3c
 803346c:	e883 0003 	stmia.w	r3, {r0, r1}
    nextChan.LastAggrTx = Nvm.MacGroup1.LastTxDoneTime;
 8033470:	f8d4 3538 	ldr.w	r3, [r4, #1336]	; 0x538
 8033474:	930d      	str	r3, [sp, #52]	; 0x34
    nextChan.LastTxIsJoinRequest = false;
 8033476:	2300      	movs	r3, #0
 8033478:	f88d 3044 	strb.w	r3, [sp, #68]	; 0x44
    nextChan.PktLen = MacCtx.PktBufferLen;
 803347c:	88a3      	ldrh	r3, [r4, #4]
 803347e:	f8ad 3046 	strh.w	r3, [sp, #70]	; 0x46
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 8033482:	f894 361c 	ldrb.w	r3, [r4, #1564]	; 0x61c
    nextChan.Joined = true;
 8033486:	2201      	movs	r2, #1
 8033488:	f88d 2039 	strb.w	r2, [sp, #57]	; 0x39
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 803348c:	b91b      	cbnz	r3, 8033496 <ScheduleTx+0xce>
        nextChan.LastTxIsJoinRequest = true;
 803348e:	f88d 2044 	strb.w	r2, [sp, #68]	; 0x44
        nextChan.Joined = false;
 8033492:	f88d 3039 	strb.w	r3, [sp, #57]	; 0x39
    status = RegionNextChannel( Nvm.MacGroup2.Region, &nextChan, &MacCtx.Channel, &MacCtx.DutyCycleWaitTime, &Nvm.MacGroup1.AggregatedTimeOff );
 8033496:	4e85      	ldr	r6, [pc, #532]	; (80336ac <ScheduleTx+0x2e4>)
 8033498:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
 803349c:	9600      	str	r6, [sp, #0]
 803349e:	f46f 7291 	mvn.w	r2, #290	; 0x122
 80334a2:	f1a6 03b4 	sub.w	r3, r6, #180	; 0xb4
 80334a6:	18b2      	adds	r2, r6, r2
 80334a8:	a90c      	add	r1, sp, #48	; 0x30
 80334aa:	f003 fa06 	bl	80368ba <RegionNextChannel>
    if( status != LORAMAC_STATUS_OK )
 80334ae:	4605      	mov	r5, r0
 80334b0:	b1d0      	cbz	r0, 80334e8 <ScheduleTx+0x120>
        if( ( status == LORAMAC_STATUS_DUTYCYCLE_RESTRICTED ) &&
 80334b2:	280b      	cmp	r0, #11
 80334b4:	d1a3      	bne.n	80333fe <ScheduleTx+0x36>
 80334b6:	2f00      	cmp	r7, #0
 80334b8:	d0a1      	beq.n	80333fe <ScheduleTx+0x36>
            if( MacCtx.DutyCycleWaitTime != 0 )
 80334ba:	f8d4 1488 	ldr.w	r1, [r4, #1160]	; 0x488
 80334be:	b169      	cbz	r1, 80334dc <ScheduleTx+0x114>
                MacCtx.MacState |= LORAMAC_TX_DELAYED;
 80334c0:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
                TimerSetValue( &MacCtx.TxDelayedTimer, MacCtx.DutyCycleWaitTime );
 80334c4:	f5a6 70e8 	sub.w	r0, r6, #464	; 0x1d0
                MacCtx.MacState |= LORAMAC_TX_DELAYED;
 80334c8:	f043 0320 	orr.w	r3, r3, #32
 80334cc:	f8c4 3344 	str.w	r3, [r4, #836]	; 0x344
                TimerSetValue( &MacCtx.TxDelayedTimer, MacCtx.DutyCycleWaitTime );
 80334d0:	f007 ffbe 	bl	803b450 <UTIL_TIMER_SetPeriod>
                TimerStart( &MacCtx.TxDelayedTimer );
 80334d4:	f5a6 70e8 	sub.w	r0, r6, #464	; 0x1d0
 80334d8:	f007 ff80 	bl	803b3dc <UTIL_TIMER_Start>
            return LORAMAC_STATUS_OK;
 80334dc:	2500      	movs	r5, #0
 80334de:	e78e      	b.n	80333fe <ScheduleTx+0x36>
            serializeStatus = LoRaMacSerializerData( &MacCtx.TxMsg.Message.Data );
 80334e0:	4871      	ldr	r0, [pc, #452]	; (80336a8 <ScheduleTx+0x2e0>)
 80334e2:	f003 f8a2 	bl	803662a <LoRaMacSerializerData>
 80334e6:	e79e      	b.n	8033426 <ScheduleTx+0x5e>
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 80334e8:	f894 754c 	ldrb.w	r7, [r4, #1356]	; 0x54c
                                     RegionApplyDrOffset( Nvm.MacGroup2.Region,
 80334ec:	f994 356d 	ldrsb.w	r3, [r4, #1389]	; 0x56d
 80334f0:	f994 2545 	ldrsb.w	r2, [r4, #1349]	; 0x545
 80334f4:	f894 1581 	ldrb.w	r1, [r4, #1409]	; 0x581
 80334f8:	4638      	mov	r0, r7
 80334fa:	f003 f9fc 	bl	80368f6 <RegionApplyDrOffset>
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 80334fe:	f5a6 73c0 	sub.w	r3, r6, #384	; 0x180
 8033502:	b241      	sxtb	r1, r0
 8033504:	f894 2554 	ldrb.w	r2, [r4, #1364]	; 0x554
 8033508:	9300      	str	r3, [sp, #0]
 803350a:	4638      	mov	r0, r7
 803350c:	f8d4 3550 	ldr.w	r3, [r4, #1360]	; 0x550
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 8033510:	f5a6 76b6 	sub.w	r6, r6, #364	; 0x16c
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 8033514:	f003 f94d 	bl	80367b2 <RegionComputeRxWindowParameters>
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 8033518:	f8d4 3550 	ldr.w	r3, [r4, #1360]	; 0x550
 803351c:	f994 1574 	ldrsb.w	r1, [r4, #1396]	; 0x574
 8033520:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
 8033524:	9600      	str	r6, [sp, #0]
 8033526:	f894 2554 	ldrb.w	r2, [r4, #1364]	; 0x554
 803352a:	f003 f942 	bl	80367b2 <RegionComputeRxWindowParameters>
    MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.ReceiveDelay2 + MacCtx.RxWindow2Config.WindowOffset;
 803352e:	f8d4 03dc 	ldr.w	r0, [r4, #988]	; 0x3dc
 8033532:	f8d4 1560 	ldr.w	r1, [r4, #1376]	; 0x560
    MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.ReceiveDelay1 + MacCtx.RxWindow1Config.WindowOffset;
 8033536:	f8d4 63c8 	ldr.w	r6, [r4, #968]	; 0x3c8
 803353a:	f8d4 355c 	ldr.w	r3, [r4, #1372]	; 0x55c
    MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.ReceiveDelay2 + MacCtx.RxWindow2Config.WindowOffset;
 803353e:	4401      	add	r1, r0
 8033540:	f8c4 13b8 	str.w	r1, [r4, #952]	; 0x3b8
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 8033544:	f894 161c 	ldrb.w	r1, [r4, #1564]	; 0x61c
    MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.ReceiveDelay1 + MacCtx.RxWindow1Config.WindowOffset;
 8033548:	4433      	add	r3, r6
 803354a:	f8c4 33b4 	str.w	r3, [r4, #948]	; 0x3b4
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 803354e:	b949      	cbnz	r1, 8033564 <ScheduleTx+0x19c>
        MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay1 + MacCtx.RxWindow1Config.WindowOffset;
 8033550:	f8d4 2564 	ldr.w	r2, [r4, #1380]	; 0x564
        MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay2 + MacCtx.RxWindow2Config.WindowOffset;
 8033554:	f8d4 3568 	ldr.w	r3, [r4, #1384]	; 0x568
        MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay1 + MacCtx.RxWindow1Config.WindowOffset;
 8033558:	4432      	add	r2, r6
        MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay2 + MacCtx.RxWindow2Config.WindowOffset;
 803355a:	4403      	add	r3, r0
        MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay1 + MacCtx.RxWindow1Config.WindowOffset;
 803355c:	f8c4 23b4 	str.w	r2, [r4, #948]	; 0x3b4
        MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay2 + MacCtx.RxWindow2Config.WindowOffset;
 8033560:	f8c4 33b8 	str.w	r3, [r4, #952]	; 0x3b8
    size_t macCmdsSize = 0;
 8033564:	2300      	movs	r3, #0
 8033566:	9308      	str	r3, [sp, #32]
    if( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE )
 8033568:	b181      	cbz	r1, 803358c <ScheduleTx+0x1c4>
        if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )
 803356a:	a808      	add	r0, sp, #32
 803356c:	f002 fae4 	bl	8035b38 <LoRaMacCommandsGetSizeSerializedCmds>
 8033570:	2800      	cmp	r0, #0
 8033572:	d14a      	bne.n	803360a <ScheduleTx+0x242>
    maxN = GetMaxAppPayloadWithoutFOptsLength( datarate );
 8033574:	f994 0545 	ldrsb.w	r0, [r4, #1349]	; 0x545
        if( ValidatePayloadLength( MacCtx.AppDataSize, Nvm.MacGroup1.ChannelsDatarate, macCmdsSize ) == false )
 8033578:	f894 623b 	ldrb.w	r6, [r4, #571]	; 0x23b
 803357c:	f89d 7020 	ldrb.w	r7, [sp, #32]
    maxN = GetMaxAppPayloadWithoutFOptsLength( datarate );
 8033580:	f7ff fd50 	bl	8033024 <GetMaxAppPayloadWithoutFOptsLength>
    if( ( payloadSize <= maxN ) && ( payloadSize <= LORAMAC_PHY_MAXPAYLOAD ) )
 8033584:	443e      	add	r6, r7
 8033586:	b280      	uxth	r0, r0
 8033588:	42b0      	cmp	r0, r6
 803358a:	d33c      	bcc.n	8033606 <ScheduleTx+0x23e>
    int8_t txPower = 0;
 803358c:	2300      	movs	r3, #0
 803358e:	f88d 3013 	strb.w	r3, [sp, #19]
    txConfig.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 8033592:	f894 3545 	ldrb.w	r3, [r4, #1349]	; 0x545
 8033596:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
    txConfig.TxPower = Nvm.MacGroup1.ChannelsTxPower;
 803359a:	f894 3544 	ldrb.w	r3, [r4, #1348]	; 0x544
 803359e:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    txConfig.MaxEirp = Nvm.MacGroup2.MacParams.MaxEirp;
 80335a2:	f8d4 3584 	ldr.w	r3, [r4, #1412]	; 0x584
 80335a6:	9309      	str	r3, [sp, #36]	; 0x24
    txConfig.AntennaGain = Nvm.MacGroup2.MacParams.AntennaGain;
 80335a8:	f8d4 3588 	ldr.w	r3, [r4, #1416]	; 0x588
 80335ac:	930a      	str	r3, [sp, #40]	; 0x28
    txConfig.PktLen = MacCtx.PktBufferLen;
 80335ae:	88a3      	ldrh	r3, [r4, #4]
    return SendFrameOnChannel( MacCtx.Channel );
 80335b0:	f894 6419 	ldrb.w	r6, [r4, #1049]	; 0x419
    txConfig.PktLen = MacCtx.PktBufferLen;
 80335b4:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
    RegionTxConfig( Nvm.MacGroup2.Region, &txConfig, &txPower, &MacCtx.TxTimeOnAir );
 80335b8:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
 80335bc:	4b3c      	ldr	r3, [pc, #240]	; (80336b0 <ScheduleTx+0x2e8>)
    txConfig.Channel = channel;
 80335be:	f88d 6020 	strb.w	r6, [sp, #32]
    RegionTxConfig( Nvm.MacGroup2.Region, &txConfig, &txPower, &MacCtx.TxTimeOnAir );
 80335c2:	f10d 0213 	add.w	r2, sp, #19
 80335c6:	a908      	add	r1, sp, #32
 80335c8:	f003 f912 	bl	80367f0 <RegionTxConfig>
    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 80335cc:	2301      	movs	r3, #1
 80335ce:	f884 343d 	strb.w	r3, [r4, #1085]	; 0x43d
    MacCtx.McpsConfirm.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 80335d2:	f894 3545 	ldrb.w	r3, [r4, #1349]	; 0x545
 80335d6:	f884 343e 	strb.w	r3, [r4, #1086]	; 0x43e
    MacCtx.McpsConfirm.TxPower = txPower;
 80335da:	f89d 3013 	ldrb.w	r3, [sp, #19]
 80335de:	f884 343f 	strb.w	r3, [r4, #1087]	; 0x43f
    MacCtx.McpsConfirm.TxTimeOnAir = MacCtx.TxTimeOnAir;
 80335e2:	f8d4 341c 	ldr.w	r3, [r4, #1052]	; 0x41c
    MacCtx.McpsConfirm.Channel = channel;
 80335e6:	f8c4 644c 	str.w	r6, [r4, #1100]	; 0x44c
    MacCtx.McpsConfirm.TxTimeOnAir = MacCtx.TxTimeOnAir;
 80335ea:	f8c4 3444 	str.w	r3, [r4, #1092]	; 0x444
    MacCtx.MlmeConfirm.TxTimeOnAir = MacCtx.TxTimeOnAir;
 80335ee:	f8c4 3454 	str.w	r3, [r4, #1108]	; 0x454
    if( LoRaMacClassBIsBeaconModeActive( ) == true )
 80335f2:	f002 f9e2 	bl	80359ba <LoRaMacClassBIsBeaconModeActive>
 80335f6:	b150      	cbz	r0, 803360e <ScheduleTx+0x246>
        TimerTime_t collisionTime = LoRaMacClassBIsUplinkCollision( MacCtx.TxTimeOnAir );
 80335f8:	f8d4 041c 	ldr.w	r0, [r4, #1052]	; 0x41c
 80335fc:	f002 f9ef 	bl	80359de <LoRaMacClassBIsUplinkCollision>
        if( collisionTime > 0 )
 8033600:	b128      	cbz	r0, 803360e <ScheduleTx+0x246>
            return LORAMAC_STATUS_BUSY_UPLINK_COLLISION;
 8033602:	2510      	movs	r5, #16
    return SendFrameOnChannel( MacCtx.Channel );
 8033604:	e6fb      	b.n	80333fe <ScheduleTx+0x36>
            return LORAMAC_STATUS_LENGTH_ERROR;
 8033606:	2508      	movs	r5, #8
 8033608:	e6f9      	b.n	80333fe <ScheduleTx+0x36>
            return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 803360a:	2513      	movs	r5, #19
 803360c:	e6f7      	b.n	80333fe <ScheduleTx+0x36>
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 803360e:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 8033612:	2b01      	cmp	r3, #1
 8033614:	d101      	bne.n	803361a <ScheduleTx+0x252>
        LoRaMacClassBStopRxSlots( );
 8033616:	f002 f9e4 	bl	80359e2 <LoRaMacClassBStopRxSlots>
    LoRaMacClassBHaltBeaconing( );
 803361a:	f002 f9d1 	bl	80359c0 <LoRaMacClassBHaltBeaconing>
    uint32_t fCntUp = 0;
 803361e:	2300      	movs	r3, #0
 8033620:	9305      	str	r3, [sp, #20]
    switch( MacCtx.TxMsg.Type )
 8033622:	f894 3108 	ldrb.w	r3, [r4, #264]	; 0x108
    status = SecureFrame( Nvm.MacGroup1.ChannelsDatarate, MacCtx.Channel );
 8033626:	f994 6545 	ldrsb.w	r6, [r4, #1349]	; 0x545
 803362a:	f894 7419 	ldrb.w	r7, [r4, #1049]	; 0x419
    switch( MacCtx.TxMsg.Type )
 803362e:	b1bb      	cbz	r3, 8033660 <ScheduleTx+0x298>
 8033630:	2b04      	cmp	r3, #4
 8033632:	f47f aede 	bne.w	80333f2 <ScheduleTx+0x2a>
            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetFCntUp( &fCntUp ) )
 8033636:	a805      	add	r0, sp, #20
 8033638:	f002 fce2 	bl	8036000 <LoRaMacCryptoGetFCntUp>
 803363c:	bb68      	cbnz	r0, 803369a <ScheduleTx+0x2d2>
            if( ( MacCtx.ChannelsNbTransCounter >= 1 ) || ( MacCtx.AckTimeoutRetriesCounter > 1 ) )
 803363e:	f894 3414 	ldrb.w	r3, [r4, #1044]	; 0x414
 8033642:	b91b      	cbnz	r3, 803364c <ScheduleTx+0x284>
 8033644:	f894 3416 	ldrb.w	r3, [r4, #1046]	; 0x416
 8033648:	2b01      	cmp	r3, #1
 803364a:	d902      	bls.n	8033652 <ScheduleTx+0x28a>
                fCntUp -= 1;
 803364c:	9b05      	ldr	r3, [sp, #20]
 803364e:	3b01      	subs	r3, #1
 8033650:	9305      	str	r3, [sp, #20]
            macCryptoStatus = LoRaMacCryptoSecureMessage( fCntUp, txDr, txCh, &MacCtx.TxMsg.Message.Data );
 8033652:	4b15      	ldr	r3, [pc, #84]	; (80336a8 <ScheduleTx+0x2e0>)
 8033654:	9805      	ldr	r0, [sp, #20]
 8033656:	463a      	mov	r2, r7
 8033658:	b2f1      	uxtb	r1, r6
 803365a:	f002 fd47 	bl	80360ec <LoRaMacCryptoSecureMessage>
 803365e:	e002      	b.n	8033666 <ScheduleTx+0x29e>
            macCryptoStatus = LoRaMacCryptoPrepareJoinRequest( &MacCtx.TxMsg.Message.JoinReq );
 8033660:	4811      	ldr	r0, [pc, #68]	; (80336a8 <ScheduleTx+0x2e0>)
 8033662:	f002 fd1b 	bl	803609c <LoRaMacCryptoPrepareJoinRequest>
            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )
 8033666:	b9b0      	cbnz	r0, 8033696 <ScheduleTx+0x2ce>
            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.Data.BufSize;
 8033668:	f894 3110 	ldrb.w	r3, [r4, #272]	; 0x110
 803366c:	80a3      	strh	r3, [r4, #4]
    MacCtx.MacState |= LORAMAC_TX_RUNNING;
 803366e:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 8033672:	f043 0302 	orr.w	r3, r3, #2
 8033676:	f8c4 3344 	str.w	r3, [r4, #836]	; 0x344
    if( MacCtx.NodeAckRequested == false )
 803367a:	f894 3418 	ldrb.w	r3, [r4, #1048]	; 0x418
 803367e:	b923      	cbnz	r3, 803368a <ScheduleTx+0x2c2>
        MacCtx.ChannelsNbTransCounter++;
 8033680:	f894 3414 	ldrb.w	r3, [r4, #1044]	; 0x414
 8033684:	3301      	adds	r3, #1
 8033686:	f884 3414 	strb.w	r3, [r4, #1044]	; 0x414
    Radio.Send( MacCtx.PktBuffer, MacCtx.PktBufferLen );
 803368a:	4b0a      	ldr	r3, [pc, #40]	; (80336b4 <ScheduleTx+0x2ec>)
 803368c:	7921      	ldrb	r1, [r4, #4]
 803368e:	480a      	ldr	r0, [pc, #40]	; (80336b8 <ScheduleTx+0x2f0>)
 8033690:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8033692:	4798      	blx	r3
    return LORAMAC_STATUS_OK;
 8033694:	e6b3      	b.n	80333fe <ScheduleTx+0x36>
                return LORAMAC_STATUS_CRYPTO_ERROR;
 8033696:	2511      	movs	r5, #17
 8033698:	e6b1      	b.n	80333fe <ScheduleTx+0x36>
                return LORAMAC_STATUS_FCNT_HANDLER_ERROR;
 803369a:	2512      	movs	r5, #18
 803369c:	e6af      	b.n	80333fe <ScheduleTx+0x36>
        return LORAMAC_STATUS_BUSY_BEACON_RESERVED_TIME;
 803369e:	250e      	movs	r5, #14
 80336a0:	e6ad      	b.n	80333fe <ScheduleTx+0x36>
 80336a2:	bf00      	nop
 80336a4:	20004aa4 	.word	0x20004aa4
 80336a8:	20004bb0 	.word	0x20004bb0
 80336ac:	20004fe0 	.word	0x20004fe0
 80336b0:	20004ec0 	.word	0x20004ec0
 80336b4:	0803bc30 	.word	0x0803bc30
 80336b8:	20004aaa 	.word	0x20004aaa

080336bc <OnTxDelayedTimerEvent>:
{
 80336bc:	b510      	push	{r4, lr}
    TimerStop( &MacCtx.TxDelayedTimer );
 80336be:	4c11      	ldr	r4, [pc, #68]	; (8033704 <OnTxDelayedTimerEvent+0x48>)
 80336c0:	f504 705b 	add.w	r0, r4, #876	; 0x36c
 80336c4:	f007 fe3a 	bl	803b33c <UTIL_TIMER_Stop>
    MacCtx.MacState &= ~LORAMAC_TX_DELAYED;
 80336c8:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
    switch( ScheduleTx( true ) )
 80336cc:	2001      	movs	r0, #1
    MacCtx.MacState &= ~LORAMAC_TX_DELAYED;
 80336ce:	f023 0320 	bic.w	r3, r3, #32
 80336d2:	f8c4 3344 	str.w	r3, [r4, #836]	; 0x344
    switch( ScheduleTx( true ) )
 80336d6:	f7ff fe77 	bl	80333c8 <ScheduleTx>
 80336da:	b190      	cbz	r0, 8033702 <OnTxDelayedTimerEvent+0x46>
 80336dc:	280b      	cmp	r0, #11
 80336de:	d010      	beq.n	8033702 <OnTxDelayedTimerEvent+0x46>
            MacCtx.McpsConfirm.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 80336e0:	f894 3545 	ldrb.w	r3, [r4, #1349]	; 0x545
 80336e4:	f884 343e 	strb.w	r3, [r4, #1086]	; 0x43e
            MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR;
 80336e8:	2009      	movs	r0, #9
            MacCtx.McpsConfirm.NbRetries = MacCtx.AckTimeoutRetriesCounter;
 80336ea:	f894 3416 	ldrb.w	r3, [r4, #1046]	; 0x416
 80336ee:	f884 3441 	strb.w	r3, [r4, #1089]	; 0x441
            MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR;
 80336f2:	f884 043d 	strb.w	r0, [r4, #1085]	; 0x43d
            LoRaMacConfirmQueueSetStatusCmn( LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR );
 80336f6:	f002 fb07 	bl	8035d08 <LoRaMacConfirmQueueSetStatusCmn>
}
 80336fa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            StopRetransmission( );
 80336fe:	f7ff bc6f 	b.w	8032fe0 <StopRetransmission>
}
 8033702:	bd10      	pop	{r4, pc}
 8033704:	20004aa4 	.word	0x20004aa4

08033708 <OpenContinuousRxCWindow>:
{
 8033708:	b537      	push	{r0, r1, r2, r4, r5, lr}
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 803370a:	4c12      	ldr	r4, [pc, #72]	; (8033754 <OpenContinuousRxCWindow+0x4c>)
 803370c:	f504 7579 	add.w	r5, r4, #996	; 0x3e4
 8033710:	f8d4 3550 	ldr.w	r3, [r4, #1360]	; 0x550
 8033714:	f894 2554 	ldrb.w	r2, [r4, #1364]	; 0x554
 8033718:	f994 157c 	ldrsb.w	r1, [r4, #1404]	; 0x57c
 803371c:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
 8033720:	9500      	str	r5, [sp, #0]
 8033722:	f003 f846 	bl	80367b2 <RegionComputeRxWindowParameters>
    MacCtx.RxWindowCConfig.RxContinuous = true;
 8033726:	f240 2301 	movw	r3, #513	; 0x201
    if( RegionRxConfig( Nvm.MacGroup2.Region, &MacCtx.RxWindowCConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )
 803372a:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    MacCtx.RxWindowCConfig.RxContinuous = true;
 803372e:	f8a4 33f6 	strh.w	r3, [r4, #1014]	; 0x3f6
    if( RegionRxConfig( Nvm.MacGroup2.Region, &MacCtx.RxWindowCConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )
 8033732:	f204 4224 	addw	r2, r4, #1060	; 0x424
 8033736:	4629      	mov	r1, r5
 8033738:	f003 f84d 	bl	80367d6 <RegionRxConfig>
 803373c:	b138      	cbz	r0, 803374e <OpenContinuousRxCWindow+0x46>
        Radio.Rx( 0 ); // Continuous mode
 803373e:	4b06      	ldr	r3, [pc, #24]	; (8033758 <OpenContinuousRxCWindow+0x50>)
 8033740:	2000      	movs	r0, #0
 8033742:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8033744:	4798      	blx	r3
        MacCtx.RxSlot = MacCtx.RxWindowCConfig.RxSlot;
 8033746:	f894 33f7 	ldrb.w	r3, [r4, #1015]	; 0x3f7
 803374a:	f884 3484 	strb.w	r3, [r4, #1156]	; 0x484
}
 803374e:	b003      	add	sp, #12
 8033750:	bd30      	pop	{r4, r5, pc}
 8033752:	bf00      	nop
 8033754:	20004aa4 	.word	0x20004aa4
 8033758:	0803bc30 	.word	0x0803bc30

0803375c <SwitchClass>:
{
 803375c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    switch( Nvm.MacGroup2.DeviceClass )
 803375e:	4f2f      	ldr	r7, [pc, #188]	; (803381c <SwitchClass+0xc0>)
 8033760:	f897 5608 	ldrb.w	r5, [r7, #1544]	; 0x608
 8033764:	2d01      	cmp	r5, #1
{
 8033766:	4606      	mov	r6, r0
 8033768:	463c      	mov	r4, r7
    switch( Nvm.MacGroup2.DeviceClass )
 803376a:	d046      	beq.n	80337fa <SwitchClass+0x9e>
 803376c:	2d02      	cmp	r5, #2
 803376e:	d04c      	beq.n	803380a <SwitchClass+0xae>
 8033770:	b945      	cbnz	r5, 8033784 <SwitchClass+0x28>
            if( deviceClass == CLASS_A )
 8033772:	b948      	cbnz	r0, 8033788 <SwitchClass+0x2c>
                Nvm.MacGroup2.MacParams.RxCChannel = Nvm.MacGroup2.MacParams.Rx2Channel;
 8033774:	f8d7 1574 	ldr.w	r1, [r7, #1396]	; 0x574
 8033778:	f8d7 0570 	ldr.w	r0, [r7, #1392]	; 0x570
 803377c:	f507 63af 	add.w	r3, r7, #1400	; 0x578
 8033780:	e883 0003 	stmia.w	r3, {r0, r1}
    LoRaMacStatus_t status = LORAMAC_STATUS_PARAMETER_INVALID;
 8033784:	2503      	movs	r5, #3
 8033786:	e036      	b.n	80337f6 <SwitchClass+0x9a>
            if( deviceClass == CLASS_B )
 8033788:	2801      	cmp	r0, #1
 803378a:	d036      	beq.n	80337fa <SwitchClass+0x9e>
            if( deviceClass == CLASS_C )
 803378c:	2802      	cmp	r0, #2
 803378e:	d1f9      	bne.n	8033784 <SwitchClass+0x28>
                MacCtx.RxWindowCConfig = MacCtx.RxWindow2Config;
 8033790:	f504 7c74 	add.w	ip, r4, #976	; 0x3d0
                Nvm.MacGroup2.DeviceClass = deviceClass;
 8033794:	f884 0608 	strb.w	r0, [r4, #1544]	; 0x608
                MacCtx.RxWindowCConfig = MacCtx.RxWindow2Config;
 8033798:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 803379c:	f507 7779 	add.w	r7, r7, #996	; 0x3e4
 80337a0:	c70f      	stmia	r7!, {r0, r1, r2, r3}
 80337a2:	f8dc 3000 	ldr.w	r3, [ip]
 80337a6:	603b      	str	r3, [r7, #0]
                    if( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.IsEnabled == true )
 80337a8:	f894 35de 	ldrb.w	r3, [r4, #1502]	; 0x5de
                MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C;
 80337ac:	f884 63f7 	strb.w	r6, [r4, #1015]	; 0x3f7
                    if( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.IsEnabled == true )
 80337b0:	b1cb      	cbz	r3, 80337e6 <SwitchClass+0x8a>
                        Nvm.MacGroup2.MacParams.RxCChannel.Frequency = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.RxParams.ClassC.Frequency;
 80337b2:	f8d4 35f4 	ldr.w	r3, [r4, #1524]	; 0x5f4
 80337b6:	f8c4 3578 	str.w	r3, [r4, #1400]	; 0x578
                        MacCtx.RxWindowCConfig.Frequency = Nvm.MacGroup2.MacParams.RxCChannel.Frequency;
 80337ba:	f8c4 33e8 	str.w	r3, [r4, #1000]	; 0x3e8
                        MacCtx.RxWindowCConfig.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 80337be:	f894 3581 	ldrb.w	r3, [r4, #1409]	; 0x581
                        Nvm.MacGroup2.MacParams.RxCChannel.Datarate = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.RxParams.ClassC.Datarate;
 80337c2:	f894 25f8 	ldrb.w	r2, [r4, #1528]	; 0x5f8
                        MacCtx.RxWindowCConfig.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 80337c6:	f884 33f4 	strb.w	r3, [r4, #1012]	; 0x3f4
                        MacCtx.RxWindowCConfig.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport; /* ST_WORKAROUND: Keep repeater feature */
 80337ca:	f894 358c 	ldrb.w	r3, [r4, #1420]	; 0x58c
                        Nvm.MacGroup2.MacParams.RxCChannel.Datarate = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.RxParams.ClassC.Datarate;
 80337ce:	f884 257c 	strb.w	r2, [r4, #1404]	; 0x57c
                        MacCtx.RxWindowCConfig.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport; /* ST_WORKAROUND: Keep repeater feature */
 80337d2:	f884 33f5 	strb.w	r3, [r4, #1013]	; 0x3f5
                        MacCtx.RxWindowCConfig.Channel = MacCtx.Channel;
 80337d6:	f894 2419 	ldrb.w	r2, [r4, #1049]	; 0x419
 80337da:	f884 23e4 	strb.w	r2, [r4, #996]	; 0x3e4
                        MacCtx.RxWindowCConfig.RxContinuous = true;
 80337de:	f240 3301 	movw	r3, #769	; 0x301
 80337e2:	f8a4 33f6 	strh.w	r3, [r4, #1014]	; 0x3f6
                MacCtx.NodeAckRequested = false;
 80337e6:	2300      	movs	r3, #0
 80337e8:	f884 3418 	strb.w	r3, [r4, #1048]	; 0x418
                Radio.Sleep( );
 80337ec:	4b0c      	ldr	r3, [pc, #48]	; (8033820 <SwitchClass+0xc4>)
 80337ee:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80337f0:	4798      	blx	r3
                OpenContinuousRxCWindow( );
 80337f2:	f7ff ff89 	bl	8033708 <OpenContinuousRxCWindow>
}
 80337f6:	4628      	mov	r0, r5
 80337f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            status = LoRaMacClassBSwitchClass( deviceClass );
 80337fa:	f002 f8e3 	bl	80359c4 <LoRaMacClassBSwitchClass>
            if( status == LORAMAC_STATUS_OK )
 80337fe:	4605      	mov	r5, r0
 8033800:	2800      	cmp	r0, #0
 8033802:	d1f8      	bne.n	80337f6 <SwitchClass+0x9a>
                Nvm.MacGroup2.DeviceClass = deviceClass;
 8033804:	f887 6608 	strb.w	r6, [r7, #1544]	; 0x608
 8033808:	e7f5      	b.n	80337f6 <SwitchClass+0x9a>
            if( deviceClass == CLASS_A )
 803380a:	2800      	cmp	r0, #0
 803380c:	d1ba      	bne.n	8033784 <SwitchClass+0x28>
                Radio.Sleep( );
 803380e:	4b04      	ldr	r3, [pc, #16]	; (8033820 <SwitchClass+0xc4>)
                Nvm.MacGroup2.DeviceClass = deviceClass;
 8033810:	f887 0608 	strb.w	r0, [r7, #1544]	; 0x608
                Radio.Sleep( );
 8033814:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8033816:	4798      	blx	r3
                status = LORAMAC_STATUS_OK;
 8033818:	4635      	mov	r5, r6
 803381a:	e7ec      	b.n	80337f6 <SwitchClass+0x9a>
 803381c:	20004aa4 	.word	0x20004aa4
 8033820:	0803bc30 	.word	0x0803bc30

08033824 <RxWindowSetup.constprop.0>:
static void RxWindowSetup( TimerEvent_t* rxTimer, RxConfigParams_t* rxConfig )
 8033824:	b570      	push	{r4, r5, r6, lr}
    Radio.Standby( );
 8033826:	4e0b      	ldr	r6, [pc, #44]	; (8033854 <RxWindowSetup.constprop.0+0x30>)
    if( RegionRxConfig( Nvm.MacGroup2.Region, rxConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )
 8033828:	4c0b      	ldr	r4, [pc, #44]	; (8033858 <RxWindowSetup.constprop.0+0x34>)
static void RxWindowSetup( TimerEvent_t* rxTimer, RxConfigParams_t* rxConfig )
 803382a:	460d      	mov	r5, r1
    TimerStop( rxTimer );
 803382c:	f007 fd86 	bl	803b33c <UTIL_TIMER_Stop>
    Radio.Standby( );
 8033830:	6b33      	ldr	r3, [r6, #48]	; 0x30
 8033832:	4798      	blx	r3
    if( RegionRxConfig( Nvm.MacGroup2.Region, rxConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )
 8033834:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
 8033838:	f204 4224 	addw	r2, r4, #1060	; 0x424
 803383c:	4629      	mov	r1, r5
 803383e:	f002 ffca 	bl	80367d6 <RegionRxConfig>
 8033842:	b130      	cbz	r0, 8033852 <RxWindowSetup.constprop.0+0x2e>
        Radio.Rx( Nvm.MacGroup2.MacParams.MaxRxWindow );
 8033844:	6b73      	ldr	r3, [r6, #52]	; 0x34
 8033846:	f8d4 0558 	ldr.w	r0, [r4, #1368]	; 0x558
 803384a:	4798      	blx	r3
        MacCtx.RxSlot = rxConfig->RxSlot;
 803384c:	7ceb      	ldrb	r3, [r5, #19]
 803384e:	f884 3484 	strb.w	r3, [r4, #1156]	; 0x484
}
 8033852:	bd70      	pop	{r4, r5, r6, pc}
 8033854:	0803bc30 	.word	0x0803bc30
 8033858:	20004aa4 	.word	0x20004aa4

0803385c <OnRxWindow1TimerEvent>:
    MacCtx.RxWindow1Config.Channel = MacCtx.Channel;
 803385c:	480c      	ldr	r0, [pc, #48]	; (8033890 <OnRxWindow1TimerEvent+0x34>)
 803385e:	f890 3419 	ldrb.w	r3, [r0, #1049]	; 0x419
 8033862:	f880 33bc 	strb.w	r3, [r0, #956]	; 0x3bc
    MacCtx.RxWindow1Config.DrOffset = Nvm.MacGroup2.MacParams.Rx1DrOffset;
 8033866:	f890 356d 	ldrb.w	r3, [r0, #1389]	; 0x56d
 803386a:	f880 33bf 	strb.w	r3, [r0, #959]	; 0x3bf
    MacCtx.RxWindow1Config.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 803386e:	f890 3581 	ldrb.w	r3, [r0, #1409]	; 0x581
 8033872:	f880 33cc 	strb.w	r3, [r0, #972]	; 0x3cc
    MacCtx.RxWindow1Config.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport; /* ST_WORKAROUND: Keep repeater feature */
 8033876:	f890 358c 	ldrb.w	r3, [r0, #1420]	; 0x58c
 803387a:	f880 33cd 	strb.w	r3, [r0, #973]	; 0x3cd
    MacCtx.RxWindow1Config.RxContinuous = false;
 803387e:	2300      	movs	r3, #0
 8033880:	f8a0 33ce 	strh.w	r3, [r0, #974]	; 0x3ce
    RxWindowSetup( &MacCtx.RxWindowTimer1, &MacCtx.RxWindow1Config );
 8033884:	f500 716f 	add.w	r1, r0, #956	; 0x3bc
 8033888:	f500 7061 	add.w	r0, r0, #900	; 0x384
 803388c:	f7ff bfca 	b.w	8033824 <RxWindowSetup.constprop.0>
 8033890:	20004aa4 	.word	0x20004aa4

08033894 <OnRxWindow2TimerEvent>:
    if( MacCtx.RxSlot == RX_SLOT_WIN_1 )
 8033894:	480f      	ldr	r0, [pc, #60]	; (80338d4 <OnRxWindow2TimerEvent+0x40>)
 8033896:	f890 3484 	ldrb.w	r3, [r0, #1156]	; 0x484
 803389a:	b1cb      	cbz	r3, 80338d0 <OnRxWindow2TimerEvent+0x3c>
    MacCtx.RxWindow2Config.Channel = MacCtx.Channel;
 803389c:	f890 3419 	ldrb.w	r3, [r0, #1049]	; 0x419
 80338a0:	f880 33d0 	strb.w	r3, [r0, #976]	; 0x3d0
    MacCtx.RxWindow2Config.Frequency = Nvm.MacGroup2.MacParams.Rx2Channel.Frequency;
 80338a4:	f8d0 3570 	ldr.w	r3, [r0, #1392]	; 0x570
 80338a8:	f8c0 33d4 	str.w	r3, [r0, #980]	; 0x3d4
    MacCtx.RxWindow2Config.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 80338ac:	f890 3581 	ldrb.w	r3, [r0, #1409]	; 0x581
 80338b0:	f880 33e0 	strb.w	r3, [r0, #992]	; 0x3e0
    MacCtx.RxWindow2Config.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport; /* ST_WORKAROUND: Keep repeater feature */
 80338b4:	f890 358c 	ldrb.w	r3, [r0, #1420]	; 0x58c
 80338b8:	f880 33e1 	strb.w	r3, [r0, #993]	; 0x3e1
    MacCtx.RxWindow2Config.RxContinuous = false;
 80338bc:	f44f 7380 	mov.w	r3, #256	; 0x100
 80338c0:	f8a0 33e2 	strh.w	r3, [r0, #994]	; 0x3e2
    RxWindowSetup( &MacCtx.RxWindowTimer2, &MacCtx.RxWindow2Config );
 80338c4:	f500 7174 	add.w	r1, r0, #976	; 0x3d0
 80338c8:	f500 7067 	add.w	r0, r0, #924	; 0x39c
 80338cc:	f7ff bfaa 	b.w	8033824 <RxWindowSetup.constprop.0>
}
 80338d0:	4770      	bx	lr
 80338d2:	bf00      	nop
 80338d4:	20004aa4 	.word	0x20004aa4

080338d8 <ProcessMacCommands.isra.0.constprop.0>:
static void ProcessMacCommands( uint8_t *payload, uint8_t macIndex, uint8_t commandsSize, int8_t snr, LoRaMacRxSlot_t rxSlot )
 80338d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80338dc:	b091      	sub	sp, #68	; 0x44
    uint8_t status = 0;
 80338de:	2700      	movs	r7, #0
                    if( ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_PING_SLOT ) && ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT ) )
 80338e0:	4dc3      	ldr	r5, [pc, #780]	; (8033bf0 <ProcessMacCommands.isra.0.constprop.0+0x318>)
    uint8_t status = 0;
 80338e2:	f88d 7015 	strb.w	r7, [sp, #21]
static void ProcessMacCommands( uint8_t *payload, uint8_t macIndex, uint8_t commandsSize, int8_t snr, LoRaMacRxSlot_t rxSlot )
 80338e6:	4606      	mov	r6, r0
 80338e8:	4688      	mov	r8, r1
 80338ea:	4693      	mov	fp, r2
    uint8_t macCmdPayload[2] = { 0x00, 0x00 };
 80338ec:	f8ad 7018 	strh.w	r7, [sp, #24]
    while( macIndex < commandsSize )
 80338f0:	46b9      	mov	r9, r7
 80338f2:	45c1      	cmp	r9, r8
 80338f4:	d302      	bcc.n	80338fc <ProcessMacCommands.isra.0.constprop.0+0x24>
}
 80338f6:	b011      	add	sp, #68	; 0x44
 80338f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if( ( LoRaMacCommandsGetCmdSize( payload[macIndex] ) + macIndex ) > commandsSize )
 80338fc:	f816 0009 	ldrb.w	r0, [r6, r9]
 8033900:	f002 f96c 	bl	8035bdc <LoRaMacCommandsGetCmdSize>
 8033904:	4448      	add	r0, r9
 8033906:	4540      	cmp	r0, r8
 8033908:	dcf5      	bgt.n	80338f6 <ProcessMacCommands.isra.0.constprop.0+0x1e>
        switch( payload[macIndex++] )
 803390a:	f816 3009 	ldrb.w	r3, [r6, r9]
 803390e:	f109 0401 	add.w	r4, r9, #1
 8033912:	3b02      	subs	r3, #2
 8033914:	b2e4      	uxtb	r4, r4
 8033916:	2b11      	cmp	r3, #17
 8033918:	d8ed      	bhi.n	80338f6 <ProcessMacCommands.isra.0.constprop.0+0x1e>
 803391a:	a201      	add	r2, pc, #4	; (adr r2, 8033920 <ProcessMacCommands.isra.0.constprop.0+0x48>)
 803391c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8033920:	08033969 	.word	0x08033969
 8033924:	08033999 	.word	0x08033999
 8033928:	08033a55 	.word	0x08033a55
 803392c:	08033a7d 	.word	0x08033a7d
 8033930:	08033b15 	.word	0x08033b15
 8033934:	08033b3d 	.word	0x08033b3d
 8033938:	08033baf 	.word	0x08033baf
 803393c:	08033bf5 	.word	0x08033bf5
 8033940:	08033c7d 	.word	0x08033c7d
 8033944:	080338f7 	.word	0x080338f7
 8033948:	080338f7 	.word	0x080338f7
 803394c:	08033cdb 	.word	0x08033cdb
 8033950:	080338f7 	.word	0x080338f7
 8033954:	080338f7 	.word	0x080338f7
 8033958:	08033d91 	.word	0x08033d91
 803395c:	08033db7 	.word	0x08033db7
 8033960:	08033dfb 	.word	0x08033dfb
 8033964:	08033e39 	.word	0x08033e39
                if( LoRaMacConfirmQueueIsCmdActive( MLME_LINK_CHECK ) == true )
 8033968:	2004      	movs	r0, #4
 803396a:	f002 f9e7 	bl	8035d3c <LoRaMacConfirmQueueIsCmdActive>
 803396e:	b188      	cbz	r0, 8033994 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_LINK_CHECK );
 8033970:	2104      	movs	r1, #4
 8033972:	2000      	movs	r0, #0
 8033974:	f002 f9a6 	bl	8035cc4 <LoRaMacConfirmQueueSetStatus>
                    MacCtx.MlmeConfirm.DemodMargin = payload[macIndex++];
 8033978:	5d33      	ldrb	r3, [r6, r4]
 803397a:	f885 3458 	strb.w	r3, [r5, #1112]	; 0x458
                    MacCtx.MlmeConfirm.NbGateways = payload[macIndex++];
 803397e:	f109 0403 	add.w	r4, r9, #3
                    MacCtx.MlmeConfirm.DemodMargin = payload[macIndex++];
 8033982:	f109 0902 	add.w	r9, r9, #2
                    MacCtx.MlmeConfirm.NbGateways = payload[macIndex++];
 8033986:	fa5f f989 	uxtb.w	r9, r9
 803398a:	b2e4      	uxtb	r4, r4
 803398c:	f816 3009 	ldrb.w	r3, [r6, r9]
 8033990:	f885 3459 	strb.w	r3, [r5, #1113]	; 0x459
                uint8_t eirpDwellTime = payload[macIndex++];
 8033994:	46a1      	mov	r9, r4
 8033996:	e7ac      	b.n	80338f2 <ProcessMacCommands.isra.0.constprop.0+0x1a>
                int8_t linkAdrDatarate = DR_0;
 8033998:	2300      	movs	r3, #0
 803399a:	f88d 3016 	strb.w	r3, [sp, #22]
                int8_t linkAdrTxPower = TX_POWER_0;
 803399e:	f88d 3017 	strb.w	r3, [sp, #23]
                uint8_t linkAdrNbRep = 0;
 80339a2:	f88d 301c 	strb.w	r3, [sp, #28]
                uint8_t linkAdrNbBytesParsed = 0;
 80339a6:	f88d 3020 	strb.w	r3, [sp, #32]
                if( adrBlockFound == false )
 80339aa:	2f00      	cmp	r7, #0
 80339ac:	d150      	bne.n	8033a50 <ProcessMacCommands.isra.0.constprop.0+0x178>
                    linkAdrReq.PayloadSize = commandsSize - ( macIndex - 1 );
 80339ae:	eba8 0309 	sub.w	r3, r8, r9
 80339b2:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
                    linkAdrReq.AdrEnabled = Nvm.MacGroup2.AdrCtrlOn;
 80339b6:	f895 360a 	ldrb.w	r3, [r5, #1546]	; 0x60a
 80339ba:	f88d 303a 	strb.w	r3, [sp, #58]	; 0x3a
                    linkAdrReq.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 80339be:	f895 3580 	ldrb.w	r3, [r5, #1408]	; 0x580
 80339c2:	f88d 3039 	strb.w	r3, [sp, #57]	; 0x39
                    linkAdrReq.CurrentDatarate = Nvm.MacGroup1.ChannelsDatarate;
 80339c6:	f895 3545 	ldrb.w	r3, [r5, #1349]	; 0x545
 80339ca:	f88d 303b 	strb.w	r3, [sp, #59]	; 0x3b
                    linkAdrReq.CurrentTxPower = Nvm.MacGroup1.ChannelsTxPower;
 80339ce:	f895 3544 	ldrb.w	r3, [r5, #1348]	; 0x544
 80339d2:	f88d 303c 	strb.w	r3, [sp, #60]	; 0x3c
                    linkAdrReq.CurrentNbRep = Nvm.MacGroup2.MacParams.ChannelsNbTrans;
 80339d6:	f895 356c 	ldrb.w	r3, [r5, #1388]	; 0x56c
 80339da:	f88d 303d 	strb.w	r3, [sp, #61]	; 0x3d
                    linkAdrReq.Version = Nvm.MacGroup2.Version;
 80339de:	f8d5 3618 	ldr.w	r3, [r5, #1560]	; 0x618
 80339e2:	930c      	str	r3, [sp, #48]	; 0x30
                    status = RegionLinkAdrReq( Nvm.MacGroup2.Region, &linkAdrReq, &linkAdrDatarate,
 80339e4:	ab08      	add	r3, sp, #32
 80339e6:	9301      	str	r3, [sp, #4]
                    linkAdrReq.Payload = &payload[macIndex - 1];
 80339e8:	3c01      	subs	r4, #1
                    status = RegionLinkAdrReq( Nvm.MacGroup2.Region, &linkAdrReq, &linkAdrDatarate,
 80339ea:	ab07      	add	r3, sp, #28
 80339ec:	9300      	str	r3, [sp, #0]
 80339ee:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
                    linkAdrReq.Payload = &payload[macIndex - 1];
 80339f2:	4434      	add	r4, r6
                    status = RegionLinkAdrReq( Nvm.MacGroup2.Region, &linkAdrReq, &linkAdrDatarate,
 80339f4:	f10d 0317 	add.w	r3, sp, #23
 80339f8:	f10d 0216 	add.w	r2, sp, #22
 80339fc:	a90c      	add	r1, sp, #48	; 0x30
                    linkAdrReq.Payload = &payload[macIndex - 1];
 80339fe:	940d      	str	r4, [sp, #52]	; 0x34
                    status = RegionLinkAdrReq( Nvm.MacGroup2.Region, &linkAdrReq, &linkAdrDatarate,
 8033a00:	f002 ff08 	bl	8036814 <RegionLinkAdrReq>
 8033a04:	f88d 0015 	strb.w	r0, [sp, #21]
                    if( ( status & 0x07 ) == 0x07 )
 8033a08:	f000 0007 	and.w	r0, r0, #7
 8033a0c:	2807      	cmp	r0, #7
 8033a0e:	d10b      	bne.n	8033a28 <ProcessMacCommands.isra.0.constprop.0+0x150>
                        Nvm.MacGroup1.ChannelsDatarate = linkAdrDatarate;
 8033a10:	f89d 3016 	ldrb.w	r3, [sp, #22]
 8033a14:	f885 3545 	strb.w	r3, [r5, #1349]	; 0x545
                        Nvm.MacGroup1.ChannelsTxPower = linkAdrTxPower;
 8033a18:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8033a1c:	f885 3544 	strb.w	r3, [r5, #1348]	; 0x544
                        Nvm.MacGroup2.MacParams.ChannelsNbTrans = linkAdrNbRep;
 8033a20:	f89d 301c 	ldrb.w	r3, [sp, #28]
 8033a24:	f885 356c 	strb.w	r3, [r5, #1388]	; 0x56c
static void ProcessMacCommands( uint8_t *payload, uint8_t macIndex, uint8_t commandsSize, int8_t snr, LoRaMacRxSlot_t rxSlot )
 8033a28:	2700      	movs	r7, #0
                    for( uint8_t i = 0; i < ( linkAdrNbBytesParsed / 5 ); i++ )
 8033a2a:	f04f 0a05 	mov.w	sl, #5
 8033a2e:	e006      	b.n	8033a3e <ProcessMacCommands.isra.0.constprop.0+0x166>
                        LoRaMacCommandsAddCmd( MOTE_MAC_LINK_ADR_ANS, &status, 1 );
 8033a30:	2201      	movs	r2, #1
 8033a32:	f10d 0115 	add.w	r1, sp, #21
 8033a36:	2003      	movs	r0, #3
 8033a38:	f001 ffe4 	bl	8035a04 <LoRaMacCommandsAddCmd>
                    for( uint8_t i = 0; i < ( linkAdrNbBytesParsed / 5 ); i++ )
 8033a3c:	3701      	adds	r7, #1
 8033a3e:	b2fb      	uxtb	r3, r7
 8033a40:	f89d 4020 	ldrb.w	r4, [sp, #32]
 8033a44:	fbb4 f2fa 	udiv	r2, r4, sl
 8033a48:	429a      	cmp	r2, r3
 8033a4a:	d8f1      	bhi.n	8033a30 <ProcessMacCommands.isra.0.constprop.0+0x158>
                    macIndex += linkAdrNbBytesParsed - 1;
 8033a4c:	444c      	add	r4, r9
 8033a4e:	b2e4      	uxtb	r4, r4
                break;
 8033a50:	2701      	movs	r7, #1
 8033a52:	e79f      	b.n	8033994 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                Nvm.MacGroup2.MaxDCycle = payload[macIndex++] & 0x0F;
 8033a54:	5d33      	ldrb	r3, [r6, r4]
                Nvm.MacGroup2.AggregatedDCycle = 1 << Nvm.MacGroup2.MaxDCycle;
 8033a56:	2201      	movs	r2, #1
                Nvm.MacGroup2.MaxDCycle = payload[macIndex++] & 0x0F;
 8033a58:	f003 030f 	and.w	r3, r3, #15
 8033a5c:	f109 0902 	add.w	r9, r9, #2
 8033a60:	f885 360b 	strb.w	r3, [r5, #1547]	; 0x60b
                Nvm.MacGroup2.AggregatedDCycle = 1 << Nvm.MacGroup2.MaxDCycle;
 8033a64:	fa02 f303 	lsl.w	r3, r2, r3
                Nvm.MacGroup2.MaxDCycle = payload[macIndex++] & 0x0F;
 8033a68:	fa5f f989 	uxtb.w	r9, r9
                Nvm.MacGroup2.AggregatedDCycle = 1 << Nvm.MacGroup2.MaxDCycle;
 8033a6c:	f8a5 360e 	strh.w	r3, [r5, #1550]	; 0x60e
                LoRaMacCommandsAddCmd( MOTE_MAC_DUTY_CYCLE_ANS, macCmdPayload, 0 );
 8033a70:	2200      	movs	r2, #0
 8033a72:	a906      	add	r1, sp, #24
 8033a74:	2004      	movs	r0, #4
                    LoRaMacCommandsAddCmd( MOTE_MAC_TX_PARAM_SETUP_ANS, macCmdPayload, 0 );
 8033a76:	f001 ffc5 	bl	8035a04 <LoRaMacCommandsAddCmd>
                break;
 8033a7a:	e0b7      	b.n	8033bec <ProcessMacCommands.isra.0.constprop.0+0x314>
                status = 0x07;
 8033a7c:	2307      	movs	r3, #7
 8033a7e:	f88d 3015 	strb.w	r3, [sp, #21]
                rxParamSetupReq.DrOffset = ( payload[macIndex] >> 4 ) & 0x07;
 8033a82:	5d33      	ldrb	r3, [r6, r4]
                status = RegionRxParamSetupReq( Nvm.MacGroup2.Region, &rxParamSetupReq );
 8033a84:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
                rxParamSetupReq.DrOffset = ( payload[macIndex] >> 4 ) & 0x07;
 8033a88:	f3c3 1202 	ubfx	r2, r3, #4, #3
                rxParamSetupReq.Datarate = payload[macIndex] & 0x0F;
 8033a8c:	f003 030f 	and.w	r3, r3, #15
                rxParamSetupReq.DrOffset = ( payload[macIndex] >> 4 ) & 0x07;
 8033a90:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
                rxParamSetupReq.Datarate = payload[macIndex] & 0x0F;
 8033a94:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033a98:	f109 0204 	add.w	r2, r9, #4
                rxParamSetupReq.Frequency = ( uint32_t ) payload[macIndex++];
 8033a9c:	f109 0303 	add.w	r3, r9, #3
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033aa0:	b2db      	uxtb	r3, r3
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033aa2:	b2d2      	uxtb	r2, r2
 8033aa4:	f109 0405 	add.w	r4, r9, #5
                macIndex++;
 8033aa8:	f109 0902 	add.w	r9, r9, #2
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033aac:	5cf1      	ldrb	r1, [r6, r3]
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033aae:	5cb3      	ldrb	r3, [r6, r2]
                rxParamSetupReq.Frequency = ( uint32_t ) payload[macIndex++];
 8033ab0:	fa5f f989 	uxtb.w	r9, r9
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033ab4:	041b      	lsls	r3, r3, #16
                rxParamSetupReq.Frequency = ( uint32_t ) payload[macIndex++];
 8033ab6:	f816 2009 	ldrb.w	r2, [r6, r9]
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033aba:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8033abe:	4313      	orrs	r3, r2
                rxParamSetupReq.Frequency *= 100;
 8033ac0:	2264      	movs	r2, #100	; 0x64
 8033ac2:	4353      	muls	r3, r2
                status = RegionRxParamSetupReq( Nvm.MacGroup2.Region, &rxParamSetupReq );
 8033ac4:	a90c      	add	r1, sp, #48	; 0x30
                rxParamSetupReq.Frequency *= 100;
 8033ac6:	930d      	str	r3, [sp, #52]	; 0x34
                status = RegionRxParamSetupReq( Nvm.MacGroup2.Region, &rxParamSetupReq );
 8033ac8:	f002 feba 	bl	8036840 <RegionRxParamSetupReq>
                if( ( status & 0x07 ) == 0x07 )
 8033acc:	f000 0307 	and.w	r3, r0, #7
 8033ad0:	2b07      	cmp	r3, #7
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033ad2:	b2e4      	uxtb	r4, r4
                status = RegionRxParamSetupReq( Nvm.MacGroup2.Region, &rxParamSetupReq );
 8033ad4:	f88d 0015 	strb.w	r0, [sp, #21]
                if( ( status & 0x07 ) == 0x07 )
 8033ad8:	d10e      	bne.n	8033af8 <ProcessMacCommands.isra.0.constprop.0+0x220>
                    Nvm.MacGroup2.MacParams.Rx2Channel.Datarate = rxParamSetupReq.Datarate;
 8033ada:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
 8033ade:	f885 3574 	strb.w	r3, [r5, #1396]	; 0x574
                    Nvm.MacGroup2.MacParams.RxCChannel.Datarate = rxParamSetupReq.Datarate;
 8033ae2:	f885 357c 	strb.w	r3, [r5, #1404]	; 0x57c
                    Nvm.MacGroup2.MacParams.Rx2Channel.Frequency = rxParamSetupReq.Frequency;
 8033ae6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8033ae8:	f8c5 3570 	str.w	r3, [r5, #1392]	; 0x570
                    Nvm.MacGroup2.MacParams.RxCChannel.Frequency = rxParamSetupReq.Frequency;
 8033aec:	f8c5 3578 	str.w	r3, [r5, #1400]	; 0x578
                    Nvm.MacGroup2.MacParams.Rx1DrOffset = rxParamSetupReq.DrOffset;
 8033af0:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
 8033af4:	f885 356d 	strb.w	r3, [r5, #1389]	; 0x56d
                macCmdPayload[0] = status;
 8033af8:	f88d 0018 	strb.w	r0, [sp, #24]
                LoRaMacCommandsAddCmd( MOTE_MAC_RX_PARAM_SETUP_ANS, macCmdPayload, 1 );
 8033afc:	2201      	movs	r2, #1
 8033afe:	a906      	add	r1, sp, #24
 8033b00:	2005      	movs	r0, #5
                    LoRaMacCommandsAddCmd( MOTE_MAC_DL_CHANNEL_ANS, macCmdPayload, 1 );
 8033b02:	f001 ff7f 	bl	8035a04 <LoRaMacCommandsAddCmd>
    MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 1;
 8033b06:	f895 3485 	ldrb.w	r3, [r5, #1157]	; 0x485
 8033b0a:	f043 0310 	orr.w	r3, r3, #16
 8033b0e:	f885 3485 	strb.w	r3, [r5, #1157]	; 0x485
}
 8033b12:	e73f      	b.n	8033994 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->GetBatteryLevel != NULL ) )
 8033b14:	f8d5 334c 	ldr.w	r3, [r5, #844]	; 0x34c
 8033b18:	b173      	cbz	r3, 8033b38 <ProcessMacCommands.isra.0.constprop.0+0x260>
 8033b1a:	681b      	ldr	r3, [r3, #0]
 8033b1c:	b163      	cbz	r3, 8033b38 <ProcessMacCommands.isra.0.constprop.0+0x260>
                    batteryLevel = MacCtx.MacCallbacks->GetBatteryLevel( );
 8033b1e:	4798      	blx	r3
                macCmdPayload[1] = ( uint8_t )( snr & 0x3F );
 8033b20:	f00b 033f 	and.w	r3, fp, #63	; 0x3f
                macCmdPayload[0] = batteryLevel;
 8033b24:	f88d 0018 	strb.w	r0, [sp, #24]
                macCmdPayload[1] = ( uint8_t )( snr & 0x3F );
 8033b28:	f88d 3019 	strb.w	r3, [sp, #25]
                LoRaMacCommandsAddCmd( MOTE_MAC_DEV_STATUS_ANS, macCmdPayload, 2 );
 8033b2c:	2202      	movs	r2, #2
 8033b2e:	a906      	add	r1, sp, #24
 8033b30:	2006      	movs	r0, #6
                    LoRaMacCommandsAddCmd( MOTE_MAC_BEACON_FREQ_ANS, macCmdPayload, 1 );
 8033b32:	f001 ff67 	bl	8035a04 <LoRaMacCommandsAddCmd>
                break;
 8033b36:	e72d      	b.n	8033994 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                uint8_t batteryLevel = BAT_LEVEL_NO_MEASURE;
 8033b38:	20ff      	movs	r0, #255	; 0xff
 8033b3a:	e7f1      	b.n	8033b20 <ProcessMacCommands.isra.0.constprop.0+0x248>
                status = 0x03;
 8033b3c:	2303      	movs	r3, #3
 8033b3e:	f88d 3015 	strb.w	r3, [sp, #21]
                newChannelReq.ChannelId = payload[macIndex++];
 8033b42:	5d33      	ldrb	r3, [r6, r4]
 8033b44:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
                newChannelReq.NewChannel = &chParam;
 8033b48:	ab0c      	add	r3, sp, #48	; 0x30
 8033b4a:	9308      	str	r3, [sp, #32]
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033b4c:	f109 0204 	add.w	r2, r9, #4
                chParam.Frequency = ( uint32_t ) payload[macIndex++];
 8033b50:	f109 0303 	add.w	r3, r9, #3
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033b54:	b2db      	uxtb	r3, r3
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033b56:	b2d2      	uxtb	r2, r2
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033b58:	5cf1      	ldrb	r1, [r6, r3]
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033b5a:	5cb3      	ldrb	r3, [r6, r2]
                status = ( uint8_t )RegionNewChannelReq( Nvm.MacGroup2.Region, &newChannelReq );
 8033b5c:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
                newChannelReq.ChannelId = payload[macIndex++];
 8033b60:	f109 0202 	add.w	r2, r9, #2
                chParam.Frequency = ( uint32_t ) payload[macIndex++];
 8033b64:	b2d2      	uxtb	r2, r2
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033b66:	041b      	lsls	r3, r3, #16
                chParam.Frequency = ( uint32_t ) payload[macIndex++];
 8033b68:	5cb2      	ldrb	r2, [r6, r2]
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033b6a:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8033b6e:	4313      	orrs	r3, r2
                chParam.DrRange.Value = payload[macIndex++];
 8033b70:	f109 0406 	add.w	r4, r9, #6
                chParam.Frequency *= 100;
 8033b74:	2264      	movs	r2, #100	; 0x64
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033b76:	f109 0905 	add.w	r9, r9, #5
                chParam.Frequency *= 100;
 8033b7a:	4353      	muls	r3, r2
                chParam.DrRange.Value = payload[macIndex++];
 8033b7c:	fa5f f989 	uxtb.w	r9, r9
                chParam.Frequency *= 100;
 8033b80:	930c      	str	r3, [sp, #48]	; 0x30
                chParam.Rx1Frequency = 0;
 8033b82:	2300      	movs	r3, #0
 8033b84:	930d      	str	r3, [sp, #52]	; 0x34
                status = ( uint8_t )RegionNewChannelReq( Nvm.MacGroup2.Region, &newChannelReq );
 8033b86:	a908      	add	r1, sp, #32
                chParam.DrRange.Value = payload[macIndex++];
 8033b88:	f816 3009 	ldrb.w	r3, [r6, r9]
 8033b8c:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
                status = ( uint8_t )RegionNewChannelReq( Nvm.MacGroup2.Region, &newChannelReq );
 8033b90:	f002 fe62 	bl	8036858 <RegionNewChannelReq>
 8033b94:	b2c3      	uxtb	r3, r0
                if( ( int8_t )status >= 0 )
 8033b96:	2800      	cmp	r0, #0
                chParam.DrRange.Value = payload[macIndex++];
 8033b98:	b2e4      	uxtb	r4, r4
                status = ( uint8_t )RegionNewChannelReq( Nvm.MacGroup2.Region, &newChannelReq );
 8033b9a:	f88d 3015 	strb.w	r3, [sp, #21]
                if( ( int8_t )status >= 0 )
 8033b9e:	f6ff aef9 	blt.w	8033994 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                    macCmdPayload[0] = status;
 8033ba2:	f88d 3018 	strb.w	r3, [sp, #24]
                    LoRaMacCommandsAddCmd( MOTE_MAC_NEW_CHANNEL_ANS, macCmdPayload, 1 );
 8033ba6:	2201      	movs	r2, #1
 8033ba8:	a906      	add	r1, sp, #24
 8033baa:	2007      	movs	r0, #7
 8033bac:	e7c1      	b.n	8033b32 <ProcessMacCommands.isra.0.constprop.0+0x25a>
                uint8_t delay = payload[macIndex++] & 0x0F;
 8033bae:	5d33      	ldrb	r3, [r6, r4]
 8033bb0:	f003 030f 	and.w	r3, r3, #15
                Nvm.MacGroup2.MacParams.ReceiveDelay1 = delay * 1000;
 8033bb4:	2b01      	cmp	r3, #1
 8033bb6:	bf38      	it	cc
 8033bb8:	2301      	movcc	r3, #1
 8033bba:	461a      	mov	r2, r3
 8033bbc:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8033bc0:	4353      	muls	r3, r2
 8033bc2:	f8c5 355c 	str.w	r3, [r5, #1372]	; 0x55c
                LoRaMacCommandsAddCmd( MOTE_MAC_RX_TIMING_SETUP_ANS, macCmdPayload, 0 );
 8033bc6:	2200      	movs	r2, #0
                Nvm.MacGroup2.MacParams.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay1 + 1000;
 8033bc8:	f503 737a 	add.w	r3, r3, #1000	; 0x3e8
                LoRaMacCommandsAddCmd( MOTE_MAC_RX_TIMING_SETUP_ANS, macCmdPayload, 0 );
 8033bcc:	a906      	add	r1, sp, #24
 8033bce:	2008      	movs	r0, #8
                Nvm.MacGroup2.MacParams.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay1 + 1000;
 8033bd0:	f8c5 3560 	str.w	r3, [r5, #1376]	; 0x560
                LoRaMacCommandsAddCmd( MOTE_MAC_RX_TIMING_SETUP_ANS, macCmdPayload, 0 );
 8033bd4:	f001 ff16 	bl	8035a04 <LoRaMacCommandsAddCmd>
    MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 1;
 8033bd8:	f895 3485 	ldrb.w	r3, [r5, #1157]	; 0x485
                uint8_t delay = payload[macIndex++] & 0x0F;
 8033bdc:	f109 0902 	add.w	r9, r9, #2
    MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 1;
 8033be0:	f043 0310 	orr.w	r3, r3, #16
                uint8_t delay = payload[macIndex++] & 0x0F;
 8033be4:	fa5f f989 	uxtb.w	r9, r9
    MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 1;
 8033be8:	f885 3485 	strb.w	r3, [r5, #1157]	; 0x485
                uint8_t delay = payload[macIndex++] & 0x0F;
 8033bec:	464c      	mov	r4, r9
}
 8033bee:	e6d1      	b.n	8033994 <ProcessMacCommands.isra.0.constprop.0+0xbc>
 8033bf0:	20004aa4 	.word	0x20004aa4
                uint8_t eirpDwellTime = payload[macIndex++];
 8033bf4:	5d33      	ldrb	r3, [r6, r4]
                if( RegionTxParamSetupReq( Nvm.MacGroup2.Region, &txParamSetupReq ) != -1 )
 8033bf6:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
                txParamSetupReq.UplinkDwellTime = 0;
 8033bfa:	2200      	movs	r2, #0
 8033bfc:	f88d 201c 	strb.w	r2, [sp, #28]
                if( ( eirpDwellTime & 0x20 ) == 0x20 )
 8033c00:	f013 0220 	ands.w	r2, r3, #32
                    txParamSetupReq.DownlinkDwellTime = 1;
 8033c04:	bf18      	it	ne
 8033c06:	2201      	movne	r2, #1
 8033c08:	f88d 201d 	strb.w	r2, [sp, #29]
                if( ( eirpDwellTime & 0x10 ) == 0x10 )
 8033c0c:	06da      	lsls	r2, r3, #27
                    txParamSetupReq.UplinkDwellTime = 1;
 8033c0e:	bf48      	it	mi
 8033c10:	2201      	movmi	r2, #1
                txParamSetupReq.MaxEirp = eirpDwellTime & 0x0F;
 8033c12:	f003 030f 	and.w	r3, r3, #15
                if( RegionTxParamSetupReq( Nvm.MacGroup2.Region, &txParamSetupReq ) != -1 )
 8033c16:	a907      	add	r1, sp, #28
                    txParamSetupReq.UplinkDwellTime = 1;
 8033c18:	bf48      	it	mi
 8033c1a:	f88d 201c 	strbmi.w	r2, [sp, #28]
                txParamSetupReq.MaxEirp = eirpDwellTime & 0x0F;
 8033c1e:	f88d 301e 	strb.w	r3, [sp, #30]
                if( RegionTxParamSetupReq( Nvm.MacGroup2.Region, &txParamSetupReq ) != -1 )
 8033c22:	f002 fe25 	bl	8036870 <RegionTxParamSetupReq>
                uint8_t eirpDwellTime = payload[macIndex++];
 8033c26:	f109 0902 	add.w	r9, r9, #2
                if( RegionTxParamSetupReq( Nvm.MacGroup2.Region, &txParamSetupReq ) != -1 )
 8033c2a:	3001      	adds	r0, #1
                uint8_t eirpDwellTime = payload[macIndex++];
 8033c2c:	fa5f f989 	uxtb.w	r9, r9
                if( RegionTxParamSetupReq( Nvm.MacGroup2.Region, &txParamSetupReq ) != -1 )
 8033c30:	d0dc      	beq.n	8033bec <ProcessMacCommands.isra.0.constprop.0+0x314>
                    Nvm.MacGroup2.MacParams.UplinkDwellTime = txParamSetupReq.UplinkDwellTime;
 8033c32:	f8bd 301c 	ldrh.w	r3, [sp, #28]
                    Nvm.MacGroup2.MacParams.MaxEirp = LoRaMacMaxEirpTable[txParamSetupReq.MaxEirp];
 8033c36:	4a8e      	ldr	r2, [pc, #568]	; (8033e70 <ProcessMacCommands.isra.0.constprop.0+0x598>)
                    Nvm.MacGroup2.MacParams.UplinkDwellTime = txParamSetupReq.UplinkDwellTime;
 8033c38:	f8a5 3580 	strh.w	r3, [r5, #1408]	; 0x580
                    Nvm.MacGroup2.MacParams.MaxEirp = LoRaMacMaxEirpTable[txParamSetupReq.MaxEirp];
 8033c3c:	f89d 301e 	ldrb.w	r3, [sp, #30]
                    Nvm.MacGroup2.MacParams.UplinkDwellTime = txParamSetupReq.UplinkDwellTime;
 8033c40:	f89d 401c 	ldrb.w	r4, [sp, #28]
                    Nvm.MacGroup2.MacParams.MaxEirp = LoRaMacMaxEirpTable[txParamSetupReq.MaxEirp];
 8033c44:	5cd0      	ldrb	r0, [r2, r3]
 8033c46:	f7f7 ff25 	bl	802ba94 <__aeabi_ui2f>
                    getPhy.Attribute = PHY_MIN_TX_DR;
 8033c4a:	2302      	movs	r3, #2
                    Nvm.MacGroup2.MacParams.MaxEirp = LoRaMacMaxEirpTable[txParamSetupReq.MaxEirp];
 8033c4c:	f8c5 0584 	str.w	r0, [r5, #1412]	; 0x584
                    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8033c50:	a90c      	add	r1, sp, #48	; 0x30
 8033c52:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
                    getPhy.Attribute = PHY_MIN_TX_DR;
 8033c56:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
                    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8033c5a:	f88d 4032 	strb.w	r4, [sp, #50]	; 0x32
                    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8033c5e:	f002 fd5e 	bl	803671e <RegionGetPhyParam>
                    Nvm.MacGroup1.ChannelsDatarate = MAX( Nvm.MacGroup1.ChannelsDatarate, ( int8_t )phyParam.Value );
 8033c62:	f995 3545 	ldrsb.w	r3, [r5, #1349]	; 0x545
                    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8033c66:	9008      	str	r0, [sp, #32]
                    Nvm.MacGroup1.ChannelsDatarate = MAX( Nvm.MacGroup1.ChannelsDatarate, ( int8_t )phyParam.Value );
 8033c68:	b240      	sxtb	r0, r0
 8033c6a:	4298      	cmp	r0, r3
 8033c6c:	bfb8      	it	lt
 8033c6e:	4618      	movlt	r0, r3
 8033c70:	f885 0545 	strb.w	r0, [r5, #1349]	; 0x545
                    LoRaMacCommandsAddCmd( MOTE_MAC_TX_PARAM_SETUP_ANS, macCmdPayload, 0 );
 8033c74:	2200      	movs	r2, #0
 8033c76:	a906      	add	r1, sp, #24
 8033c78:	2009      	movs	r0, #9
 8033c7a:	e6fc      	b.n	8033a76 <ProcessMacCommands.isra.0.constprop.0+0x19e>
                status = 0x03;
 8033c7c:	2303      	movs	r3, #3
 8033c7e:	f88d 3015 	strb.w	r3, [sp, #21]
                dlChannelReq.ChannelId = payload[macIndex++];
 8033c82:	5d33      	ldrb	r3, [r6, r4]
 8033c84:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033c88:	f109 0204 	add.w	r2, r9, #4
                dlChannelReq.Rx1Frequency = ( uint32_t ) payload[macIndex++];
 8033c8c:	f109 0303 	add.w	r3, r9, #3
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033c90:	b2db      	uxtb	r3, r3
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033c92:	b2d2      	uxtb	r2, r2
 8033c94:	f109 0405 	add.w	r4, r9, #5
                dlChannelReq.ChannelId = payload[macIndex++];
 8033c98:	f109 0902 	add.w	r9, r9, #2
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033c9c:	5cf1      	ldrb	r1, [r6, r3]
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033c9e:	5cb3      	ldrb	r3, [r6, r2]
                status = ( uint8_t )RegionDlChannelReq( Nvm.MacGroup2.Region, &dlChannelReq );
 8033ca0:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
                dlChannelReq.Rx1Frequency = ( uint32_t ) payload[macIndex++];
 8033ca4:	fa5f f989 	uxtb.w	r9, r9
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033ca8:	041b      	lsls	r3, r3, #16
                dlChannelReq.Rx1Frequency = ( uint32_t ) payload[macIndex++];
 8033caa:	f816 2009 	ldrb.w	r2, [r6, r9]
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033cae:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8033cb2:	4313      	orrs	r3, r2
                dlChannelReq.Rx1Frequency *= 100;
 8033cb4:	2264      	movs	r2, #100	; 0x64
 8033cb6:	4353      	muls	r3, r2
                status = ( uint8_t )RegionDlChannelReq( Nvm.MacGroup2.Region, &dlChannelReq );
 8033cb8:	a90c      	add	r1, sp, #48	; 0x30
                dlChannelReq.Rx1Frequency *= 100;
 8033cba:	930d      	str	r3, [sp, #52]	; 0x34
                status = ( uint8_t )RegionDlChannelReq( Nvm.MacGroup2.Region, &dlChannelReq );
 8033cbc:	f002 fde4 	bl	8036888 <RegionDlChannelReq>
 8033cc0:	b2c3      	uxtb	r3, r0
                if( ( int8_t )status >= 0 )
 8033cc2:	2800      	cmp	r0, #0
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033cc4:	b2e4      	uxtb	r4, r4
                status = ( uint8_t )RegionDlChannelReq( Nvm.MacGroup2.Region, &dlChannelReq );
 8033cc6:	f88d 3015 	strb.w	r3, [sp, #21]
                if( ( int8_t )status >= 0 )
 8033cca:	f6ff ae63 	blt.w	8033994 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                    macCmdPayload[0] = status;
 8033cce:	f88d 3018 	strb.w	r3, [sp, #24]
                    LoRaMacCommandsAddCmd( MOTE_MAC_DL_CHANNEL_ANS, macCmdPayload, 1 );
 8033cd2:	2201      	movs	r2, #1
 8033cd4:	a906      	add	r1, sp, #24
 8033cd6:	200a      	movs	r0, #10
 8033cd8:	e713      	b.n	8033b02 <ProcessMacCommands.isra.0.constprop.0+0x22a>
                if( LoRaMacConfirmQueueIsCmdActive( MLME_DEVICE_TIME ) == true )
 8033cda:	200a      	movs	r0, #10
 8033cdc:	f002 f82e 	bl	8035d3c <LoRaMacConfirmQueueIsCmdActive>
 8033ce0:	2800      	cmp	r0, #0
 8033ce2:	f43f ae57 	beq.w	8033994 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_DEVICE_TIME );
 8033ce6:	210a      	movs	r1, #10
 8033ce8:	2000      	movs	r0, #0
 8033cea:	f001 ffeb 	bl	8035cc4 <LoRaMacConfirmQueueSetStatus>
                    SysTime_t sysTime = { 0 };
 8033cee:	2300      	movs	r3, #0
 8033cf0:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 8;
 8033cf4:	f109 0203 	add.w	r2, r9, #3
                    gpsEpochTime.Seconds = ( uint32_t )payload[macIndex++];
 8033cf8:	f109 0302 	add.w	r3, r9, #2
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 8;
 8033cfc:	b2db      	uxtb	r3, r3
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 16;
 8033cfe:	b2d2      	uxtb	r2, r2
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 8;
 8033d00:	5cf1      	ldrb	r1, [r6, r3]
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 16;
 8033d02:	5cb3      	ldrb	r3, [r6, r2]
                    gpsEpochTime.Seconds = ( uint32_t )payload[macIndex++];
 8033d04:	5d32      	ldrb	r2, [r6, r4]
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 16;
 8033d06:	041b      	lsls	r3, r3, #16
 8033d08:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8033d0c:	4313      	orrs	r3, r2
 8033d0e:	f109 0204 	add.w	r2, r9, #4
                    gpsEpochTime.SubSeconds = payload[macIndex++];
 8033d12:	f109 0406 	add.w	r4, r9, #6
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 24;
 8033d16:	b2d2      	uxtb	r2, r2
 8033d18:	f109 0905 	add.w	r9, r9, #5
                    gpsEpochTime.SubSeconds = payload[macIndex++];
 8033d1c:	fa5f f989 	uxtb.w	r9, r9
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 24;
 8033d20:	5cb2      	ldrb	r2, [r6, r2]
                    gpsEpochTime.SubSeconds = ( int16_t )( ( ( int32_t )gpsEpochTime.SubSeconds * 1000 ) >> 8 );
 8033d22:	f816 1009 	ldrb.w	r1, [r6, r9]
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 24;
 8033d26:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
                    gpsEpochTime.SubSeconds = ( int16_t )( ( ( int32_t )gpsEpochTime.SubSeconds * 1000 ) >> 8 );
 8033d2a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8033d2e:	434a      	muls	r2, r1
                    sysTimeCurrent = SysTimeGet( );
 8033d30:	f10d 0a30 	add.w	sl, sp, #48	; 0x30
                    gpsEpochTime.SubSeconds = ( int16_t )( ( ( int32_t )gpsEpochTime.SubSeconds * 1000 ) >> 8 );
 8033d34:	1212      	asrs	r2, r2, #8
                    sysTimeCurrent = SysTimeGet( );
 8033d36:	4650      	mov	r0, sl
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 24;
 8033d38:	9303      	str	r3, [sp, #12]
                    gpsEpochTime.SubSeconds = ( int16_t )( ( ( int32_t )gpsEpochTime.SubSeconds * 1000 ) >> 8 );
 8033d3a:	f8ad 2024 	strh.w	r2, [sp, #36]	; 0x24
                    sysTimeCurrent = SysTimeGet( );
 8033d3e:	f007 fa0f 	bl	803b160 <SysTimeGet>
                    sysTime.Seconds += UNIX_GPS_EPOCH_OFFSET;
 8033d42:	9b03      	ldr	r3, [sp, #12]
 8033d44:	f103 5396 	add.w	r3, r3, #314572800	; 0x12c00000
 8033d48:	f503 13a9 	add.w	r3, r3, #1384448	; 0x152000
 8033d4c:	f503 53ec 	add.w	r3, r3, #7552	; 0x1d80
                    sysTime = SysTimeAdd( sysTimeCurrent, SysTimeSub( sysTime, MacCtx.LastTxSysTime ) );
 8033d50:	9308      	str	r3, [sp, #32]
 8033d52:	f8d5 3340 	ldr.w	r3, [r5, #832]	; 0x340
 8033d56:	9300      	str	r3, [sp, #0]
 8033d58:	f10d 0920 	add.w	r9, sp, #32
 8033d5c:	e899 0006 	ldmia.w	r9, {r1, r2}
 8033d60:	f8d5 333c 	ldr.w	r3, [r5, #828]	; 0x33c
 8033d64:	a80a      	add	r0, sp, #40	; 0x28
 8033d66:	f007 f9b7 	bl	803b0d8 <SysTimeSub>
 8033d6a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8033d6c:	9300      	str	r3, [sp, #0]
 8033d6e:	e89a 0006 	ldmia.w	sl, {r1, r2}
 8033d72:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8033d74:	4648      	mov	r0, r9
 8033d76:	f007 f993 	bl	803b0a0 <SysTimeAdd>
                    SysTimeSet( sysTime );
 8033d7a:	e899 0003 	ldmia.w	r9, {r0, r1}
 8033d7e:	f007 f9c7 	bl	803b110 <SysTimeSet>
                    LoRaMacClassBDeviceTimeAns( );
 8033d82:	f001 fe29 	bl	80359d8 <LoRaMacClassBDeviceTimeAns>
                    MacCtx.McpsIndication.DeviceTimeAnsReceived = true;
 8033d86:	2301      	movs	r3, #1
                    gpsEpochTime.SubSeconds = payload[macIndex++];
 8033d88:	b2e4      	uxtb	r4, r4
                    MacCtx.McpsIndication.DeviceTimeAnsReceived = true;
 8033d8a:	f885 3438 	strb.w	r3, [r5, #1080]	; 0x438
 8033d8e:	e601      	b.n	8033994 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                if( LoRaMacConfirmQueueIsCmdActive( MLME_PING_SLOT_INFO ) == true )
 8033d90:	200d      	movs	r0, #13
 8033d92:	f001 ffd3 	bl	8035d3c <LoRaMacConfirmQueueIsCmdActive>
 8033d96:	2800      	cmp	r0, #0
 8033d98:	f43f adfc 	beq.w	8033994 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_PING_SLOT_INFO );
 8033d9c:	210d      	movs	r1, #13
 8033d9e:	2000      	movs	r0, #0
 8033da0:	f001 ff90 	bl	8035cc4 <LoRaMacConfirmQueueSetStatus>
                    if( ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_PING_SLOT ) && ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT ) )
 8033da4:	f895 3484 	ldrb.w	r3, [r5, #1156]	; 0x484
 8033da8:	3b04      	subs	r3, #4
 8033daa:	2b01      	cmp	r3, #1
 8033dac:	f67f adf2 	bls.w	8033994 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                        LoRaMacClassBPingSlotInfoAns( );
 8033db0:	f001 fe0e 	bl	80359d0 <LoRaMacClassBPingSlotInfoAns>
 8033db4:	e5ee      	b.n	8033994 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                frequency = ( uint32_t )payload[macIndex++];
 8033db6:	f109 0202 	add.w	r2, r9, #2
                frequency |= ( uint32_t )payload[macIndex++] << 8;
 8033dba:	b2d2      	uxtb	r2, r2
                frequency = ( uint32_t )payload[macIndex++];
 8033dbc:	5d31      	ldrb	r1, [r6, r4]
                frequency |= ( uint32_t )payload[macIndex++] << 8;
 8033dbe:	5cb0      	ldrb	r0, [r6, r2]
 8033dc0:	f109 0203 	add.w	r2, r9, #3
                frequency |= ( uint32_t )payload[macIndex++] << 16;
 8033dc4:	b2d2      	uxtb	r2, r2
                datarate = payload[macIndex++] & 0x0F;
 8033dc6:	f109 0405 	add.w	r4, r9, #5
                frequency |= ( uint32_t )payload[macIndex++] << 16;
 8033dca:	5cb3      	ldrb	r3, [r6, r2]
 8033dcc:	f109 0904 	add.w	r9, r9, #4
                datarate = payload[macIndex++] & 0x0F;
 8033dd0:	fa5f f989 	uxtb.w	r9, r9
                frequency |= ( uint32_t )payload[macIndex++] << 16;
 8033dd4:	041b      	lsls	r3, r3, #16
 8033dd6:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
                datarate = payload[macIndex++] & 0x0F;
 8033dda:	f816 0009 	ldrb.w	r0, [r6, r9]
                frequency |= ( uint32_t )payload[macIndex++] << 16;
 8033dde:	430b      	orrs	r3, r1
                status = LoRaMacClassBPingSlotChannelReq( datarate, frequency );
 8033de0:	2164      	movs	r1, #100	; 0x64
 8033de2:	4359      	muls	r1, r3
 8033de4:	f000 000f 	and.w	r0, r0, #15
 8033de8:	f001 fdf3 	bl	80359d2 <LoRaMacClassBPingSlotChannelReq>
                datarate = payload[macIndex++] & 0x0F;
 8033dec:	b2e4      	uxtb	r4, r4
                macCmdPayload[0] = status;
 8033dee:	f88d 0018 	strb.w	r0, [sp, #24]
                LoRaMacCommandsAddCmd( MOTE_MAC_PING_SLOT_FREQ_ANS, macCmdPayload, 1 );
 8033df2:	2201      	movs	r2, #1
 8033df4:	a906      	add	r1, sp, #24
 8033df6:	2011      	movs	r0, #17
 8033df8:	e69b      	b.n	8033b32 <ProcessMacCommands.isra.0.constprop.0+0x25a>
                if( LoRaMacConfirmQueueIsCmdActive( MLME_BEACON_TIMING ) == true )
 8033dfa:	200e      	movs	r0, #14
 8033dfc:	f001 ff9e 	bl	8035d3c <LoRaMacConfirmQueueIsCmdActive>
 8033e00:	2800      	cmp	r0, #0
 8033e02:	f43f adc7 	beq.w	8033994 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_BEACON_TIMING );
 8033e06:	210e      	movs	r1, #14
 8033e08:	2000      	movs	r0, #0
 8033e0a:	f001 ff5b 	bl	8035cc4 <LoRaMacConfirmQueueSetStatus>
                    beaconTimingDelay = ( uint16_t )payload[macIndex++];
 8033e0e:	f109 0302 	add.w	r3, r9, #2
                    beaconTimingDelay |= ( uint16_t )payload[macIndex++] << 8;
 8033e12:	b2db      	uxtb	r3, r3
                    LoRaMacClassBBeaconTimingAns( beaconTimingDelay, beaconTimingChannel, RxDoneParams.LastRxDone );
 8033e14:	4a17      	ldr	r2, [pc, #92]	; (8033e74 <ProcessMacCommands.isra.0.constprop.0+0x59c>)
                    beaconTimingDelay |= ( uint16_t )payload[macIndex++] << 8;
 8033e16:	5cf0      	ldrb	r0, [r6, r3]
 8033e18:	5d33      	ldrb	r3, [r6, r4]
                    LoRaMacClassBBeaconTimingAns( beaconTimingDelay, beaconTimingChannel, RxDoneParams.LastRxDone );
 8033e1a:	6812      	ldr	r2, [r2, #0]
                    beaconTimingChannel = payload[macIndex++];
 8033e1c:	f109 0404 	add.w	r4, r9, #4
                    beaconTimingDelay |= ( uint16_t )payload[macIndex++] << 8;
 8033e20:	f109 0903 	add.w	r9, r9, #3
                    beaconTimingChannel = payload[macIndex++];
 8033e24:	fa5f f989 	uxtb.w	r9, r9
                    LoRaMacClassBBeaconTimingAns( beaconTimingDelay, beaconTimingChannel, RxDoneParams.LastRxDone );
 8033e28:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 8033e2c:	f816 1009 	ldrb.w	r1, [r6, r9]
                    beaconTimingChannel = payload[macIndex++];
 8033e30:	b2e4      	uxtb	r4, r4
                    LoRaMacClassBBeaconTimingAns( beaconTimingDelay, beaconTimingChannel, RxDoneParams.LastRxDone );
 8033e32:	f001 fdd0 	bl	80359d6 <LoRaMacClassBBeaconTimingAns>
 8033e36:	e5ad      	b.n	8033994 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                    frequency = ( uint32_t )payload[macIndex++];
 8033e38:	5d30      	ldrb	r0, [r6, r4]
 8033e3a:	f109 0302 	add.w	r3, r9, #2
                    frequency |= ( uint32_t )payload[macIndex++] << 16;
 8033e3e:	f109 0404 	add.w	r4, r9, #4
                    frequency |= ( uint32_t )payload[macIndex++] << 8;
 8033e42:	f109 0903 	add.w	r9, r9, #3
 8033e46:	b2db      	uxtb	r3, r3
                    frequency |= ( uint32_t )payload[macIndex++] << 16;
 8033e48:	fa5f f989 	uxtb.w	r9, r9
                    frequency |= ( uint32_t )payload[macIndex++] << 8;
 8033e4c:	5cf2      	ldrb	r2, [r6, r3]
                    frequency |= ( uint32_t )payload[macIndex++] << 16;
 8033e4e:	f816 3009 	ldrb.w	r3, [r6, r9]
 8033e52:	041b      	lsls	r3, r3, #16
 8033e54:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8033e58:	4303      	orrs	r3, r0
                    if( LoRaMacClassBBeaconFreqReq( frequency ) == true )
 8033e5a:	2064      	movs	r0, #100	; 0x64
 8033e5c:	4358      	muls	r0, r3
 8033e5e:	f001 fdbc 	bl	80359da <LoRaMacClassBBeaconFreqReq>
                    frequency |= ( uint32_t )payload[macIndex++] << 16;
 8033e62:	b2e4      	uxtb	r4, r4
                    if( LoRaMacClassBBeaconFreqReq( frequency ) == true )
 8033e64:	f88d 0018 	strb.w	r0, [sp, #24]
                    LoRaMacCommandsAddCmd( MOTE_MAC_BEACON_FREQ_ANS, macCmdPayload, 1 );
 8033e68:	2201      	movs	r2, #1
 8033e6a:	a906      	add	r1, sp, #24
 8033e6c:	2013      	movs	r0, #19
 8033e6e:	e660      	b.n	8033b32 <ProcessMacCommands.isra.0.constprop.0+0x25a>
 8033e70:	0803baba 	.word	0x0803baba
 8033e74:	20006314 	.word	0x20006314

08033e78 <LoRaMacIsBusy>:
    if( ( MacCtx.MacState == LORAMAC_IDLE ) &&
 8033e78:	4b05      	ldr	r3, [pc, #20]	; (8033e90 <LoRaMacIsBusy+0x18>)
 8033e7a:	f8d3 2344 	ldr.w	r2, [r3, #836]	; 0x344
 8033e7e:	b92a      	cbnz	r2, 8033e8c <LoRaMacIsBusy+0x14>
 8033e80:	f893 0486 	ldrb.w	r0, [r3, #1158]	; 0x486
 8033e84:	3801      	subs	r0, #1
 8033e86:	bf18      	it	ne
 8033e88:	2001      	movne	r0, #1
 8033e8a:	4770      	bx	lr
    return true;
 8033e8c:	2001      	movs	r0, #1
}
 8033e8e:	4770      	bx	lr
 8033e90:	20004aa4 	.word	0x20004aa4

08033e94 <LoRaMacProcess>:
{
 8033e94:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8033e98:	b0a5      	sub	sp, #148	; 0x94
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8033e9a:	f3ef 8210 	mrs	r2, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8033e9e:	b672      	cpsid	i
    events = LoRaMacRadioEvents;
 8033ea0:	4ccf      	ldr	r4, [pc, #828]	; (80341e0 <LoRaMacProcess+0x34c>)
    LoRaMacRadioEvents.Value = 0;
 8033ea2:	2100      	movs	r1, #0
    events = LoRaMacRadioEvents;
 8033ea4:	6823      	ldr	r3, [r4, #0]
    LoRaMacRadioEvents.Value = 0;
 8033ea6:	6021      	str	r1, [r4, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8033ea8:	f382 8810 	msr	PRIMASK, r2
    if( events.Value != 0 )
 8033eac:	2b00      	cmp	r3, #0
 8033eae:	f000 80cd 	beq.w	803404c <LoRaMacProcess+0x1b8>
        if( events.Events.TxDone == 1 )
 8033eb2:	06da      	lsls	r2, r3, #27
 8033eb4:	fa5f fa83 	uxtb.w	sl, r3
 8033eb8:	d560      	bpl.n	8033f7c <LoRaMacProcess+0xe8>
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 8033eba:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 8033ebe:	2b02      	cmp	r3, #2
 8033ec0:	d002      	beq.n	8033ec8 <LoRaMacProcess+0x34>
        Radio.Sleep( );
 8033ec2:	4bc8      	ldr	r3, [pc, #800]	; (80341e4 <LoRaMacProcess+0x350>)
 8033ec4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8033ec6:	4798      	blx	r3
    TimerSetValue( &MacCtx.RxWindowTimer1, MacCtx.RxWindow1Delay );
 8033ec8:	f8d4 13b4 	ldr.w	r1, [r4, #948]	; 0x3b4
 8033ecc:	48c6      	ldr	r0, [pc, #792]	; (80341e8 <LoRaMacProcess+0x354>)
 8033ece:	f007 fabf 	bl	803b450 <UTIL_TIMER_SetPeriod>
    TimerStart( &MacCtx.RxWindowTimer1 );
 8033ed2:	48c5      	ldr	r0, [pc, #788]	; (80341e8 <LoRaMacProcess+0x354>)
 8033ed4:	f007 fa82 	bl	803b3dc <UTIL_TIMER_Start>
    TimerSetValue( &MacCtx.RxWindowTimer2, MacCtx.RxWindow2Delay );
 8033ed8:	f8d4 13b8 	ldr.w	r1, [r4, #952]	; 0x3b8
 8033edc:	48c3      	ldr	r0, [pc, #780]	; (80341ec <LoRaMacProcess+0x358>)
 8033ede:	f007 fab7 	bl	803b450 <UTIL_TIMER_SetPeriod>
    TimerStart( &MacCtx.RxWindowTimer2 );
 8033ee2:	48c2      	ldr	r0, [pc, #776]	; (80341ec <LoRaMacProcess+0x358>)
 8033ee4:	f007 fa7a 	bl	803b3dc <UTIL_TIMER_Start>
    if( ( Nvm.MacGroup2.DeviceClass == CLASS_C ) || ( MacCtx.NodeAckRequested == true ) )
 8033ee8:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 8033eec:	2b02      	cmp	r3, #2
 8033eee:	d002      	beq.n	8033ef6 <LoRaMacProcess+0x62>
 8033ef0:	f894 3418 	ldrb.w	r3, [r4, #1048]	; 0x418
 8033ef4:	b18b      	cbz	r3, 8033f1a <LoRaMacProcess+0x86>
        getPhy.Attribute = PHY_ACK_TIMEOUT;
 8033ef6:	2316      	movs	r3, #22
        phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8033ef8:	a90e      	add	r1, sp, #56	; 0x38
 8033efa:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
        getPhy.Attribute = PHY_ACK_TIMEOUT;
 8033efe:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
        phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8033f02:	f002 fc0c 	bl	803671e <RegionGetPhyParam>
        TimerSetValue( &MacCtx.AckTimeoutTimer, MacCtx.RxWindow2Delay + phyParam.Value );
 8033f06:	f8d4 13b8 	ldr.w	r1, [r4, #952]	; 0x3b8
        phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8033f0a:	900c      	str	r0, [sp, #48]	; 0x30
        TimerSetValue( &MacCtx.AckTimeoutTimer, MacCtx.RxWindow2Delay + phyParam.Value );
 8033f0c:	4401      	add	r1, r0
 8033f0e:	48b8      	ldr	r0, [pc, #736]	; (80341f0 <LoRaMacProcess+0x35c>)
 8033f10:	f007 fa9e 	bl	803b450 <UTIL_TIMER_SetPeriod>
        TimerStart( &MacCtx.AckTimeoutTimer );
 8033f14:	48b6      	ldr	r0, [pc, #728]	; (80341f0 <LoRaMacProcess+0x35c>)
 8033f16:	f007 fa61 	bl	803b3dc <UTIL_TIMER_Start>
    Nvm.MacGroup1.LastTxDoneTime = TxDoneParams.CurTime;
 8033f1a:	4bb6      	ldr	r3, [pc, #728]	; (80341f4 <LoRaMacProcess+0x360>)
    txDone.Channel = MacCtx.Channel;
 8033f1c:	f894 2419 	ldrb.w	r2, [r4, #1049]	; 0x419
    Nvm.MacGroup1.LastTxDoneTime = TxDoneParams.CurTime;
 8033f20:	681b      	ldr	r3, [r3, #0]
 8033f22:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    txDone.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );
 8033f26:	ae0a      	add	r6, sp, #40	; 0x28
 8033f28:	4630      	mov	r0, r6
    txDone.Channel = MacCtx.Channel;
 8033f2a:	f88d 2060 	strb.w	r2, [sp, #96]	; 0x60
    txDone.LastTxDoneTime = TxDoneParams.CurTime;
 8033f2e:	9319      	str	r3, [sp, #100]	; 0x64
    txDone.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );
 8033f30:	f007 f93c 	bl	803b1ac <SysTimeGetMcuTime>
 8033f34:	f8d4 3614 	ldr.w	r3, [r4, #1556]	; 0x614
 8033f38:	9300      	str	r3, [sp, #0]
 8033f3a:	ad04      	add	r5, sp, #16
 8033f3c:	e896 0006 	ldmia.w	r6, {r1, r2}
 8033f40:	f8d4 3610 	ldr.w	r3, [r4, #1552]	; 0x610
 8033f44:	4628      	mov	r0, r5
 8033f46:	f007 f8c7 	bl	803b0d8 <SysTimeSub>
 8033f4a:	e895 0003 	ldmia.w	r5, {r0, r1}
 8033f4e:	ab1b      	add	r3, sp, #108	; 0x6c
 8033f50:	e883 0003 	stmia.w	r3, {r0, r1}
    txDone.LastTxAirTime = MacCtx.TxTimeOnAir;
 8033f54:	f8d4 341c 	ldr.w	r3, [r4, #1052]	; 0x41c
 8033f58:	931a      	str	r3, [sp, #104]	; 0x68
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 8033f5a:	f894 361c 	ldrb.w	r3, [r4, #1564]	; 0x61c
    RegionSetBandTxDone( Nvm.MacGroup2.Region, &txDone );
 8033f5e:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
        txDone.Joined  = false;
 8033f62:	2b00      	cmp	r3, #0
 8033f64:	bf18      	it	ne
 8033f66:	2301      	movne	r3, #1
    RegionSetBandTxDone( Nvm.MacGroup2.Region, &txDone );
 8033f68:	a918      	add	r1, sp, #96	; 0x60
        txDone.Joined  = false;
 8033f6a:	f88d 3061 	strb.w	r3, [sp, #97]	; 0x61
    RegionSetBandTxDone( Nvm.MacGroup2.Region, &txDone );
 8033f6e:	f002 fbe6 	bl	803673e <RegionSetBandTxDone>
    if( MacCtx.NodeAckRequested == false )
 8033f72:	f894 3418 	ldrb.w	r3, [r4, #1048]	; 0x418
 8033f76:	b90b      	cbnz	r3, 8033f7c <LoRaMacProcess+0xe8>
        MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;
 8033f78:	f884 343d 	strb.w	r3, [r4, #1085]	; 0x43d
        if( events.Events.RxDone == 1 )
 8033f7c:	f01a 0f08 	tst.w	sl, #8
 8033f80:	d039      	beq.n	8033ff6 <LoRaMacProcess+0x162>
    uint8_t *payload = RxDoneParams.Payload;
 8033f82:	4b9d      	ldr	r3, [pc, #628]	; (80341f8 <LoRaMacProcess+0x364>)
    uint32_t address = Nvm.MacGroup2.DevAddr;
 8033f84:	f8d4 25d8 	ldr.w	r2, [r4, #1496]	; 0x5d8
    uint8_t *payload = RxDoneParams.Payload;
 8033f88:	685e      	ldr	r6, [r3, #4]
    uint16_t size = RxDoneParams.Size;
 8033f8a:	891d      	ldrh	r5, [r3, #8]
    int16_t rssi = RxDoneParams.Rssi;
 8033f8c:	f9b3 700a 	ldrsh.w	r7, [r3, #10]
    int8_t snr = RxDoneParams.Snr;
 8033f90:	f993 900c 	ldrsb.w	r9, [r3, #12]
    uint32_t address = Nvm.MacGroup2.DevAddr;
 8033f94:	9203      	str	r2, [sp, #12]
    uint32_t downLinkCounter = 0;
 8033f96:	2300      	movs	r3, #0
 8033f98:	9307      	str	r3, [sp, #28]
    MacCtx.McpsConfirm.AckReceived = false;
 8033f9a:	f884 3440 	strb.w	r3, [r4, #1088]	; 0x440
    MacCtx.McpsIndication.Multicast = 0;
 8033f9e:	f8a4 3422 	strh.w	r3, [r4, #1058]	; 0x422
    MacCtx.McpsIndication.FramePending = 0;
 8033fa2:	f884 3425 	strb.w	r3, [r4, #1061]	; 0x425
    MacCtx.McpsIndication.Buffer = NULL;
 8033fa6:	f8c4 3428 	str.w	r3, [r4, #1064]	; 0x428
    MacCtx.McpsIndication.BufferSize = 0;
 8033faa:	f8a4 342c 	strh.w	r3, [r4, #1068]	; 0x42c
    MacCtx.McpsIndication.AckReceived = false;
 8033fae:	f884 342e 	strb.w	r3, [r4, #1070]	; 0x42e
    MacCtx.McpsIndication.DownLinkCounter = 0;
 8033fb2:	f8c4 3430 	str.w	r3, [r4, #1072]	; 0x430
    MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED;
 8033fb6:	f884 3420 	strb.w	r3, [r4, #1056]	; 0x420
    MacCtx.McpsIndication.DevAddress = 0;
 8033fba:	f8c4 3434 	str.w	r3, [r4, #1076]	; 0x434
    MacCtx.McpsIndication.DeviceTimeAnsReceived = false;
 8033fbe:	f884 3438 	strb.w	r3, [r4, #1080]	; 0x438
    Radio.Sleep( );
 8033fc2:	4b88      	ldr	r3, [pc, #544]	; (80341e4 <LoRaMacProcess+0x350>)
    MacCtx.RxStatus.RxSlot = MacCtx.RxSlot;
 8033fc4:	f894 2484 	ldrb.w	r2, [r4, #1156]	; 0x484
    Radio.Sleep( );
 8033fc8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    MacCtx.RxStatus.RxSlot = MacCtx.RxSlot;
 8033fca:	f884 2483 	strb.w	r2, [r4, #1155]	; 0x483
    MacCtx.RxStatus.Rssi = rssi;
 8033fce:	f8a4 7480 	strh.w	r7, [r4, #1152]	; 0x480
    MacCtx.RxStatus.Snr = snr;
 8033fd2:	f884 9482 	strb.w	r9, [r4, #1154]	; 0x482
    Radio.Sleep( );
 8033fd6:	4798      	blx	r3
    TimerStop( &MacCtx.RxWindowTimer2 );
 8033fd8:	4884      	ldr	r0, [pc, #528]	; (80341ec <LoRaMacProcess+0x358>)
 8033fda:	f007 f9af 	bl	803b33c <UTIL_TIMER_Stop>
    if( LoRaMacClassBRxBeacon( payload, size ) == true )
 8033fde:	4629      	mov	r1, r5
 8033fe0:	4630      	mov	r0, r6
 8033fe2:	f001 fce2 	bl	80359aa <LoRaMacClassBRxBeacon>
 8033fe6:	4680      	mov	r8, r0
 8033fe8:	2800      	cmp	r0, #0
 8033fea:	f000 8169 	beq.w	80342c0 <LoRaMacProcess+0x42c>
        MacCtx.MlmeIndication.BeaconInfo.Rssi = rssi;
 8033fee:	f8a4 7476 	strh.w	r7, [r4, #1142]	; 0x476
        MacCtx.MlmeIndication.BeaconInfo.Snr = snr;
 8033ff2:	f884 9478 	strb.w	r9, [r4, #1144]	; 0x478
        if( events.Events.TxTimeout == 1 )
 8033ff6:	f01a 0f04 	tst.w	sl, #4
 8033ffa:	d019      	beq.n	8034030 <LoRaMacProcess+0x19c>
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 8033ffc:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 8034000:	2b02      	cmp	r3, #2
 8034002:	d002      	beq.n	803400a <LoRaMacProcess+0x176>
        Radio.Sleep( );
 8034004:	4b77      	ldr	r3, [pc, #476]	; (80341e4 <LoRaMacProcess+0x350>)
 8034006:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8034008:	4798      	blx	r3
    UpdateRxSlotIdleState( );
 803400a:	f7fe ffdd 	bl	8032fc8 <UpdateRxSlotIdleState>
    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT;
 803400e:	2002      	movs	r0, #2
 8034010:	f884 043d 	strb.w	r0, [r4, #1085]	; 0x43d
    LoRaMacConfirmQueueSetStatusCmn( LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT );
 8034014:	f001 fe78 	bl	8035d08 <LoRaMacConfirmQueueSetStatusCmn>
    if( MacCtx.NodeAckRequested == true )
 8034018:	f894 3418 	ldrb.w	r3, [r4, #1048]	; 0x418
 803401c:	b113      	cbz	r3, 8034024 <LoRaMacProcess+0x190>
        MacCtx.AckTimeoutRetry = true;
 803401e:	2301      	movs	r3, #1
 8034020:	f884 3417 	strb.w	r3, [r4, #1047]	; 0x417
    MacCtx.MacFlags.Bits.MacDone = 1;
 8034024:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 8034028:	f043 0320 	orr.w	r3, r3, #32
 803402c:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
        if( events.Events.RxError == 1 )
 8034030:	f01a 0f02 	tst.w	sl, #2
 8034034:	d003      	beq.n	803403e <LoRaMacProcess+0x1aa>
    HandleRadioRxErrorTimeout( LORAMAC_EVENT_INFO_STATUS_RX1_ERROR, LORAMAC_EVENT_INFO_STATUS_RX2_ERROR );
 8034036:	2106      	movs	r1, #6
 8034038:	2005      	movs	r0, #5
 803403a:	f7ff f84d 	bl	80330d8 <HandleRadioRxErrorTimeout>
        if( events.Events.RxTimeout == 1 )
 803403e:	f01a 0f01 	tst.w	sl, #1
 8034042:	d003      	beq.n	803404c <LoRaMacProcess+0x1b8>
    HandleRadioRxErrorTimeout( LORAMAC_EVENT_INFO_STATUS_RX1_TIMEOUT, LORAMAC_EVENT_INFO_STATUS_RX2_TIMEOUT );
 8034044:	2104      	movs	r1, #4
 8034046:	2003      	movs	r0, #3
 8034048:	f7ff f846 	bl	80330d8 <HandleRadioRxErrorTimeout>
    LoRaMacClassBProcess( );
 803404c:	f001 fccb 	bl	80359e6 <LoRaMacClassBProcess>
    if( MacCtx.MacFlags.Bits.MacDone == 1 )
 8034050:	f894 2485 	ldrb.w	r2, [r4, #1157]	; 0x485
 8034054:	0697      	lsls	r7, r2, #26
 8034056:	f140 80f9 	bpl.w	803424c <LoRaMacProcess+0x3b8>
    MacCtx.AllowRequests = requestState;
 803405a:	2300      	movs	r3, #0
 803405c:	f884 3486 	strb.w	r3, [r4, #1158]	; 0x486
    if( ( MacCtx.MacState & LORAMAC_RX_ABORT ) == LORAMAC_RX_ABORT )
 8034060:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 8034064:	061e      	lsls	r6, r3, #24
        MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 8034066:	bf44      	itt	mi
 8034068:	f023 0382 	bicmi.w	r3, r3, #130	; 0x82
 803406c:	f8c4 3344 	strmi.w	r3, [r4, #836]	; 0x344
    MacCtx.McpsConfirm.NbRetries = MacCtx.AckTimeoutRetriesCounter;
}

static uint8_t IsRequestPending( void )
{
    if( ( MacCtx.MacFlags.Bits.MlmeReq == 1 ) ||
 8034070:	f012 0f05 	tst.w	r2, #5
 8034074:	f000 832c 	beq.w	80346d0 <LoRaMacProcess+0x83c>
    if( ( LoRaMacConfirmQueueIsCmdActive( MLME_BEACON_ACQUISITION ) == true ) &&
 8034078:	200c      	movs	r0, #12
 803407a:	f001 fe5f 	bl	8035d3c <LoRaMacConfirmQueueIsCmdActive>
 803407e:	2800      	cmp	r0, #0
 8034080:	f000 8326 	beq.w	80346d0 <LoRaMacProcess+0x83c>
        ( MacCtx.MacFlags.Bits.McpsReq == 0 ) )
 8034084:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
    if( ( LoRaMacConfirmQueueIsCmdActive( MLME_BEACON_ACQUISITION ) == true ) &&
 8034088:	07dd      	lsls	r5, r3, #31
 803408a:	f100 8321 	bmi.w	80346d0 <LoRaMacProcess+0x83c>
        if( MacCtx.MacFlags.Bits.MlmeReq == 1 )
 803408e:	0758      	lsls	r0, r3, #29
 8034090:	f140 8332 	bpl.w	80346f8 <LoRaMacProcess+0x864>
            MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 8034094:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 8034098:	f023 0302 	bic.w	r3, r3, #2
 803409c:	f8c4 3344 	str.w	r3, [r4, #836]	; 0x344
    if( MacCtx.MacState == LORAMAC_IDLE )
 80340a0:	f8d4 2344 	ldr.w	r2, [r4, #836]	; 0x344
 80340a4:	2a00      	cmp	r2, #0
 80340a6:	f040 80ce 	bne.w	8034246 <LoRaMacProcess+0x3b2>
 80340aa:	f894 5485 	ldrb.w	r5, [r4, #1157]	; 0x485
        if( MacCtx.MacFlags.Bits.McpsReq == 1 )
 80340ae:	f015 0101 	ands.w	r1, r5, #1
            MacCtx.MacFlags.Bits.McpsReq = 0;
 80340b2:	bf1e      	ittt	ne
 80340b4:	462b      	movne	r3, r5
 80340b6:	f362 0300 	bfine	r3, r2, #0, #1
 80340ba:	f884 3485 	strbne.w	r3, [r4, #1157]	; 0x485
        if( MacCtx.MacFlags.Bits.MlmeReq == 1 )
 80340be:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 80340c2:	075e      	lsls	r6, r3, #29
            MacCtx.MacFlags.Bits.MlmeReq = 0;
 80340c4:	bf44      	itt	mi
 80340c6:	f36f 0382 	bfcmi	r3, #2, #1
 80340ca:	f884 3485 	strbmi.w	r3, [r4, #1157]	; 0x485
    MacCtx.AllowRequests = requestState;
 80340ce:	2301      	movs	r3, #1
 80340d0:	f884 3486 	strb.w	r3, [r4, #1158]	; 0x486
        if( reqEvents.Bits.McpsReq == 1 )
 80340d4:	b121      	cbz	r1, 80340e0 <LoRaMacProcess+0x24c>
            MacCtx.MacPrimitives->MacMcpsConfirm( &MacCtx.McpsConfirm );
 80340d6:	f8d4 3348 	ldr.w	r3, [r4, #840]	; 0x348
 80340da:	4848      	ldr	r0, [pc, #288]	; (80341fc <LoRaMacProcess+0x368>)
 80340dc:	681b      	ldr	r3, [r3, #0]
 80340de:	4798      	blx	r3
        if( reqEvents.Bits.MlmeReq == 1 )
 80340e0:	076d      	lsls	r5, r5, #29
 80340e2:	d50b      	bpl.n	80340fc <LoRaMacProcess+0x268>
            LoRaMacConfirmQueueHandleCb( &MacCtx.MlmeConfirm );
 80340e4:	4846      	ldr	r0, [pc, #280]	; (8034200 <LoRaMacProcess+0x36c>)
 80340e6:	f001 fe35 	bl	8035d54 <LoRaMacConfirmQueueHandleCb>
            if( LoRaMacConfirmQueueGetCnt( ) > 0 )
 80340ea:	f001 fe5d 	bl	8035da8 <LoRaMacConfirmQueueGetCnt>
 80340ee:	b128      	cbz	r0, 80340fc <LoRaMacProcess+0x268>
                MacCtx.MacFlags.Bits.MlmeReq = 1;
 80340f0:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 80340f4:	f043 0304 	orr.w	r3, r3, #4
 80340f8:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
        LoRaMacClassBResumeBeaconing( );
 80340fc:	f001 fc61 	bl	80359c2 <LoRaMacClassBResumeBeaconing>
        MacCtx.MacFlags.Bits.MacDone = 0;
 8034100:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 8034104:	f36f 1345 	bfc	r3, #5, #1
 8034108:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
    if( MacCtx.MacState == LORAMAC_IDLE )
 803410c:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 8034110:	2b00      	cmp	r3, #0
 8034112:	f040 8098 	bne.w	8034246 <LoRaMacProcess+0x3b2>
        LoRaMacCommandsStickyCmdsPending( &isStickyMacCommandPending );
 8034116:	a818      	add	r0, sp, #96	; 0x60
        bool isStickyMacCommandPending = false;
 8034118:	f88d 3060 	strb.w	r3, [sp, #96]	; 0x60
        LoRaMacCommandsStickyCmdsPending( &isStickyMacCommandPending );
 803411c:	f001 fd4a 	bl	8035bb4 <LoRaMacCommandsStickyCmdsPending>
        if( isStickyMacCommandPending == true )
 8034120:	f89d 3060 	ldrb.w	r3, [sp, #96]	; 0x60
 8034124:	b12b      	cbz	r3, 8034132 <LoRaMacProcess+0x29e>
    MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 1;
 8034126:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 803412a:	f043 0310 	orr.w	r3, r3, #16
 803412e:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
    if( MacCtx.MacState != LORAMAC_IDLE )
 8034132:	f8d4 5344 	ldr.w	r5, [r4, #836]	; 0x344
 8034136:	2d00      	cmp	r5, #0
 8034138:	f040 8085 	bne.w	8034246 <LoRaMacProcess+0x3b2>
    crc = Crc32( ( uint8_t* ) &nvmData->Crypto, sizeof( nvmData->Crypto ) -
 803413c:	2124      	movs	r1, #36	; 0x24
 803413e:	4831      	ldr	r0, [pc, #196]	; (8034204 <LoRaMacProcess+0x370>)
 8034140:	f004 ff10 	bl	8038f64 <Crc32>
    if( crc != nvmData->Crypto.Crc32 )
 8034144:	f8d4 3530 	ldr.w	r3, [r4, #1328]	; 0x530
 8034148:	4298      	cmp	r0, r3
        nvmData->Crypto.Crc32 = crc;
 803414a:	bf18      	it	ne
 803414c:	f8c4 0530 	strne.w	r0, [r4, #1328]	; 0x530
    crc = Crc32( ( uint8_t* ) &nvmData->MacGroup1, sizeof( nvmData->MacGroup1 ) -
 8034150:	f04f 0114 	mov.w	r1, #20
 8034154:	482c      	ldr	r0, [pc, #176]	; (8034208 <LoRaMacProcess+0x374>)
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_CRYPTO;
 8034156:	bf18      	it	ne
 8034158:	2501      	movne	r5, #1
    crc = Crc32( ( uint8_t* ) &nvmData->MacGroup1, sizeof( nvmData->MacGroup1 ) -
 803415a:	f004 ff03 	bl	8038f64 <Crc32>
    if( crc != nvmData->MacGroup1.Crc32 )
 803415e:	f8d4 3548 	ldr.w	r3, [r4, #1352]	; 0x548
 8034162:	4298      	cmp	r0, r3
        nvmData->MacGroup1.Crc32 = crc;
 8034164:	bf18      	it	ne
 8034166:	f8c4 0548 	strne.w	r0, [r4, #1352]	; 0x548
    crc = Crc32( ( uint8_t* ) &nvmData->MacGroup2, sizeof( nvmData->MacGroup2 ) -
 803416a:	f04f 01d4 	mov.w	r1, #212	; 0xd4
 803416e:	4827      	ldr	r0, [pc, #156]	; (803420c <LoRaMacProcess+0x378>)
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_MAC_GROUP1;
 8034170:	bf18      	it	ne
 8034172:	f045 0502 	orrne.w	r5, r5, #2
    crc = Crc32( ( uint8_t* ) &nvmData->MacGroup2, sizeof( nvmData->MacGroup2 ) -
 8034176:	f004 fef5 	bl	8038f64 <Crc32>
    if( crc != nvmData->MacGroup2.Crc32 )
 803417a:	f8d4 3620 	ldr.w	r3, [r4, #1568]	; 0x620
 803417e:	4298      	cmp	r0, r3
        nvmData->MacGroup2.Crc32 = crc;
 8034180:	bf18      	it	ne
 8034182:	f8c4 0620 	strne.w	r0, [r4, #1568]	; 0x620
    crc = Crc32( ( uint8_t* ) &nvmData->SecureElement, sizeof( nvmData->SecureElement ) -
 8034186:	f44f 7180 	mov.w	r1, #256	; 0x100
 803418a:	4821      	ldr	r0, [pc, #132]	; (8034210 <LoRaMacProcess+0x37c>)
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_MAC_GROUP2;
 803418c:	bf18      	it	ne
 803418e:	f045 0504 	orrne.w	r5, r5, #4
    crc = Crc32( ( uint8_t* ) &nvmData->SecureElement, sizeof( nvmData->SecureElement ) -
 8034192:	f004 fee7 	bl	8038f64 <Crc32>
    if( crc != nvmData->SecureElement.Crc32 )
 8034196:	f8d4 3724 	ldr.w	r3, [r4, #1828]	; 0x724
 803419a:	4298      	cmp	r0, r3
        nvmData->SecureElement.Crc32 = crc;
 803419c:	bf18      	it	ne
 803419e:	f8c4 0724 	strne.w	r0, [r4, #1828]	; 0x724
    crc = Crc32( ( uint8_t* ) &nvmData->RegionGroup1, sizeof( nvmData->RegionGroup1 ) -
 80341a2:	f04f 01a0 	mov.w	r1, #160	; 0xa0
 80341a6:	481b      	ldr	r0, [pc, #108]	; (8034214 <LoRaMacProcess+0x380>)
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_SECURE_ELEMENT;
 80341a8:	bf18      	it	ne
 80341aa:	f045 0508 	orrne.w	r5, r5, #8
    crc = Crc32( ( uint8_t* ) &nvmData->RegionGroup1, sizeof( nvmData->RegionGroup1 ) -
 80341ae:	f004 fed9 	bl	8038f64 <Crc32>
    if( crc != nvmData->RegionGroup1.Crc32 )
 80341b2:	f8d4 37c8 	ldr.w	r3, [r4, #1992]	; 0x7c8
 80341b6:	4298      	cmp	r0, r3
        nvmData->RegionGroup1.Crc32 = crc;
 80341b8:	bf18      	it	ne
 80341ba:	f8c4 07c8 	strne.w	r0, [r4, #1992]	; 0x7c8
    crc = Crc32( ( uint8_t* ) &nvmData->RegionGroup2, sizeof( nvmData->RegionGroup2 ) -
 80341be:	f44f 715e 	mov.w	r1, #888	; 0x378
 80341c2:	4815      	ldr	r0, [pc, #84]	; (8034218 <LoRaMacProcess+0x384>)
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_REGION_GROUP1;
 80341c4:	bf18      	it	ne
 80341c6:	f045 0510 	orrne.w	r5, r5, #16
    crc = Crc32( ( uint8_t* ) &nvmData->RegionGroup2, sizeof( nvmData->RegionGroup2 ) -
 80341ca:	f004 fecb 	bl	8038f64 <Crc32>
    if( crc != nvmData->RegionGroup2.Crc32 )
 80341ce:	f8d4 3b44 	ldr.w	r3, [r4, #2884]	; 0xb44
 80341d2:	4298      	cmp	r0, r3
        nvmData->RegionGroup2.Crc32 = crc;
 80341d4:	bf18      	it	ne
 80341d6:	f8c4 0b44 	strne.w	r0, [r4, #2884]	; 0xb44
    crc = Crc32( ( uint8_t* ) &nvmData->ClassB, sizeof( nvmData->ClassB ) -
 80341da:	f04f 0114 	mov.w	r1, #20
 80341de:	e01d      	b.n	803421c <LoRaMacProcess+0x388>
 80341e0:	20004aa4 	.word	0x20004aa4
 80341e4:	0803bc30 	.word	0x0803bc30
 80341e8:	20004e28 	.word	0x20004e28
 80341ec:	20004e40 	.word	0x20004e40
 80341f0:	20004ea0 	.word	0x20004ea0
 80341f4:	20006310 	.word	0x20006310
 80341f8:	20006314 	.word	0x20006314
 80341fc:	20004ee0 	.word	0x20004ee0
 8034200:	20004ef4 	.word	0x20004ef4
 8034204:	20004fb0 	.word	0x20004fb0
 8034208:	20004fd8 	.word	0x20004fd8
 803420c:	20004ff0 	.word	0x20004ff0
 8034210:	200050c8 	.word	0x200050c8
 8034214:	200051cc 	.word	0x200051cc
 8034218:	20005270 	.word	0x20005270
 803421c:	487f      	ldr	r0, [pc, #508]	; (803441c <LoRaMacProcess+0x588>)
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_REGION_GROUP2;
 803421e:	bf18      	it	ne
 8034220:	f045 0520 	orrne.w	r5, r5, #32
    crc = Crc32( ( uint8_t* ) &nvmData->ClassB, sizeof( nvmData->ClassB ) -
 8034224:	f004 fe9e 	bl	8038f64 <Crc32>
    if( crc != nvmData->ClassB.Crc32 )
 8034228:	f8d4 3b5c 	ldr.w	r3, [r4, #2908]	; 0xb5c
 803422c:	4298      	cmp	r0, r3
    if( ( MacCtx.MacCallbacks != NULL ) &&
 803422e:	f8d4 334c 	ldr.w	r3, [r4, #844]	; 0x34c
        nvmData->ClassB.Crc32 = crc;
 8034232:	bf1c      	itt	ne
 8034234:	f8c4 0b5c 	strne.w	r0, [r4, #2908]	; 0xb5c
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_CLASS_B;
 8034238:	f045 0540 	orrne.w	r5, r5, #64	; 0x40
    if( ( MacCtx.MacCallbacks != NULL ) &&
 803423c:	b11b      	cbz	r3, 8034246 <LoRaMacProcess+0x3b2>
        ( MacCtx.MacCallbacks->NvmDataChange  != NULL ) )
 803423e:	68db      	ldr	r3, [r3, #12]
    if( ( MacCtx.MacCallbacks != NULL ) &&
 8034240:	b10b      	cbz	r3, 8034246 <LoRaMacProcess+0x3b2>
        MacCtx.MacCallbacks->NvmDataChange ( notifyFlags );
 8034242:	4628      	mov	r0, r5
 8034244:	4798      	blx	r3
    MacCtx.AllowRequests = requestState;
 8034246:	2301      	movs	r3, #1
 8034248:	f884 3486 	strb.w	r3, [r4, #1158]	; 0x486
    if( MacCtx.MacFlags.Bits.MlmeInd == 1 )
 803424c:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 8034250:	0718      	lsls	r0, r3, #28
 8034252:	d50a      	bpl.n	803426a <LoRaMacProcess+0x3d6>
        MacCtx.MacFlags.Bits.MlmeInd = 0;
 8034254:	f36f 03c3 	bfc	r3, #3, #1
        MacCtx.MacPrimitives->MacMlmeIndication( &MacCtx.MlmeIndication, &MacCtx.RxStatus );
 8034258:	4971      	ldr	r1, [pc, #452]	; (8034420 <LoRaMacProcess+0x58c>)
        MacCtx.MacFlags.Bits.MlmeInd = 0;
 803425a:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
        MacCtx.MacPrimitives->MacMlmeIndication( &MacCtx.MlmeIndication, &MacCtx.RxStatus );
 803425e:	f8d4 3348 	ldr.w	r3, [r4, #840]	; 0x348
 8034262:	f1a1 001c 	sub.w	r0, r1, #28
 8034266:	68db      	ldr	r3, [r3, #12]
 8034268:	4798      	blx	r3
    if( MacCtx.MacFlags.Bits.MlmeSchedUplinkInd == 1 )
 803426a:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 803426e:	06d9      	lsls	r1, r3, #27
 8034270:	d50e      	bpl.n	8034290 <LoRaMacProcess+0x3fc>
        schduleUplinkIndication.MlmeIndication = MLME_SCHEDULE_UPLINK;
 8034272:	2307      	movs	r3, #7
 8034274:	f8ad 3060 	strh.w	r3, [sp, #96]	; 0x60
        MacCtx.MacPrimitives->MacMlmeIndication( &schduleUplinkIndication, &MacCtx.RxStatus );
 8034278:	f8d4 3348 	ldr.w	r3, [r4, #840]	; 0x348
 803427c:	4968      	ldr	r1, [pc, #416]	; (8034420 <LoRaMacProcess+0x58c>)
 803427e:	68db      	ldr	r3, [r3, #12]
 8034280:	a818      	add	r0, sp, #96	; 0x60
 8034282:	4798      	blx	r3
        MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 0;
 8034284:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 8034288:	f36f 1304 	bfc	r3, #4, #1
 803428c:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
    if( MacCtx.MacFlags.Bits.McpsInd == 1 )
 8034290:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 8034294:	079a      	lsls	r2, r3, #30
 8034296:	d50a      	bpl.n	80342ae <LoRaMacProcess+0x41a>
        MacCtx.MacFlags.Bits.McpsInd = 0;
 8034298:	f36f 0341 	bfc	r3, #1, #1
        MacCtx.MacPrimitives->MacMcpsIndication( &MacCtx.McpsIndication, &MacCtx.RxStatus );
 803429c:	4960      	ldr	r1, [pc, #384]	; (8034420 <LoRaMacProcess+0x58c>)
        MacCtx.MacFlags.Bits.McpsInd = 0;
 803429e:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
        MacCtx.MacPrimitives->MacMcpsIndication( &MacCtx.McpsIndication, &MacCtx.RxStatus );
 80342a2:	f8d4 3348 	ldr.w	r3, [r4, #840]	; 0x348
 80342a6:	f1a1 0060 	sub.w	r0, r1, #96	; 0x60
 80342aa:	685b      	ldr	r3, [r3, #4]
 80342ac:	4798      	blx	r3
    if( MacCtx.RxSlot == RX_SLOT_WIN_CLASS_C )
 80342ae:	f894 3484 	ldrb.w	r3, [r4, #1156]	; 0x484
 80342b2:	2b02      	cmp	r3, #2
 80342b4:	d101      	bne.n	80342ba <LoRaMacProcess+0x426>
        OpenContinuousRxCWindow( );
 80342b6:	f7ff fa27 	bl	8033708 <OpenContinuousRxCWindow>
}
 80342ba:	b025      	add	sp, #148	; 0x94
 80342bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 80342c0:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 80342c4:	2b01      	cmp	r3, #1
 80342c6:	d10c      	bne.n	80342e2 <LoRaMacProcess+0x44e>
        if( LoRaMacClassBIsPingExpected( ) == true )
 80342c8:	f001 fb73 	bl	80359b2 <LoRaMacClassBIsPingExpected>
 80342cc:	4607      	mov	r7, r0
 80342ce:	b1c8      	cbz	r0, 8034304 <LoRaMacProcess+0x470>
            LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 80342d0:	4640      	mov	r0, r8
 80342d2:	f001 fb63 	bl	803599c <LoRaMacClassBSetPingSlotState>
            LoRaMacClassBPingSlotTimerEvent( NULL );
 80342d6:	4640      	mov	r0, r8
 80342d8:	f001 fb65 	bl	80359a6 <LoRaMacClassBPingSlotTimerEvent>
            MacCtx.RxStatus.RxSlot = RX_SLOT_WIN_CLASS_B_PING_SLOT;
 80342dc:	2304      	movs	r3, #4
            MacCtx.RxStatus.RxSlot = RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT;
 80342de:	f884 3483 	strb.w	r3, [r4, #1155]	; 0x483
    macHdr.Value = payload[pktHeaderLen++];
 80342e2:	f896 b000 	ldrb.w	fp, [r6]
    switch( macHdr.Bits.MType )
 80342e6:	ea4f 135b 	mov.w	r3, fp, lsr #5
 80342ea:	3b01      	subs	r3, #1
 80342ec:	2b06      	cmp	r3, #6
 80342ee:	f200 81e3 	bhi.w	80346b8 <LoRaMacProcess+0x824>
 80342f2:	e8df f013 	tbh	[pc, r3, lsl #1]
 80342f6:	0013      	.short	0x0013
 80342f8:	009a01e1 	.word	0x009a01e1
 80342fc:	009701e1 	.word	0x009701e1
 8034300:	01d201e1 	.word	0x01d201e1
        else if( LoRaMacClassBIsMulticastExpected( ) == true )
 8034304:	f001 fb57 	bl	80359b6 <LoRaMacClassBIsMulticastExpected>
 8034308:	2800      	cmp	r0, #0
 803430a:	d0ea      	beq.n	80342e2 <LoRaMacProcess+0x44e>
            LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 803430c:	4638      	mov	r0, r7
 803430e:	f001 fb46 	bl	803599e <LoRaMacClassBSetMulticastSlotState>
            LoRaMacClassBMulticastSlotTimerEvent( NULL );
 8034312:	4638      	mov	r0, r7
 8034314:	f001 fb48 	bl	80359a8 <LoRaMacClassBMulticastSlotTimerEvent>
            MacCtx.RxStatus.RxSlot = RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT;
 8034318:	2305      	movs	r3, #5
 803431a:	e7e0      	b.n	80342de <LoRaMacProcess+0x44a>
            if( size < LORAMAC_JOIN_ACCEPT_FRAME_MIN_SIZE )
 803431c:	2d10      	cmp	r5, #16
 803431e:	d803      	bhi.n	8034328 <LoRaMacProcess+0x494>
                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 8034320:	2301      	movs	r3, #1
 8034322:	f884 3421 	strb.w	r3, [r4, #1057]	; 0x421
 8034326:	e123      	b.n	8034570 <LoRaMacProcess+0x6dc>
            if( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE )
 8034328:	f894 361c 	ldrb.w	r3, [r4, #1564]	; 0x61c
            macMsgJoinAccept.Buffer = payload;
 803432c:	960e      	str	r6, [sp, #56]	; 0x38
            macMsgJoinAccept.BufSize = size;
 803432e:	b2ed      	uxtb	r5, r5
 8034330:	f88d 503c 	strb.w	r5, [sp, #60]	; 0x3c
            if( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE )
 8034334:	2b00      	cmp	r3, #0
 8034336:	d1f3      	bne.n	8034320 <LoRaMacProcess+0x48c>
            macCryptoStatus = LoRaMacCryptoHandleJoinAccept( JOIN_REQ, SecureElementGetJoinEui( ), &macMsgJoinAccept );
 8034338:	f004 fdd0 	bl	8038edc <SecureElementGetJoinEui>
 803433c:	aa0e      	add	r2, sp, #56	; 0x38
 803433e:	4601      	mov	r1, r0
 8034340:	20ff      	movs	r0, #255	; 0xff
 8034342:	f001 ffdb 	bl	80362fc <LoRaMacCryptoHandleJoinAccept>
            if( LORAMAC_CRYPTO_SUCCESS == macCryptoStatus )
 8034346:	2800      	cmp	r0, #0
 8034348:	d160      	bne.n	803440c <LoRaMacProcess+0x578>
                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[2] << 16 );
 803434a:	f89d 3043 	ldrb.w	r3, [sp, #67]	; 0x43
                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[1] << 8 );
 803434e:	f89d 2042 	ldrb.w	r2, [sp, #66]	; 0x42
                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[2] << 16 );
 8034352:	041b      	lsls	r3, r3, #16
 8034354:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
                Nvm.MacGroup2.NetID = ( uint32_t ) macMsgJoinAccept.NetID[0];
 8034358:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[2] << 16 );
 803435c:	4313      	orrs	r3, r2
 803435e:	f8c4 35d4 	str.w	r3, [r4, #1492]	; 0x5d4
                Nvm.MacGroup2.DevAddr = macMsgJoinAccept.DevAddr;
 8034362:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8034364:	f8c4 35d8 	str.w	r3, [r4, #1496]	; 0x5d8
                Nvm.MacGroup2.MacParams.Rx1DrOffset = macMsgJoinAccept.DLSettings.Bits.RX1DRoffset;
 8034368:	f89d 3048 	ldrb.w	r3, [sp, #72]	; 0x48
 803436c:	f3c3 1202 	ubfx	r2, r3, #4, #3
                Nvm.MacGroup2.MacParams.Rx2Channel.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;
 8034370:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8034374:	f884 3574 	strb.w	r3, [r4, #1396]	; 0x574
                Nvm.MacGroup2.MacParams.RxCChannel.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;
 8034378:	f884 357c 	strb.w	r3, [r4, #1404]	; 0x57c
                Nvm.MacGroup2.MacParams.ReceiveDelay1 = macMsgJoinAccept.RxDelay;
 803437c:	f89d 3049 	ldrb.w	r3, [sp, #73]	; 0x49
                Nvm.MacGroup2.MacParams.Rx1DrOffset = macMsgJoinAccept.DLSettings.Bits.RX1DRoffset;
 8034380:	f884 256d 	strb.w	r2, [r4, #1389]	; 0x56d
                if( Nvm.MacGroup2.MacParams.ReceiveDelay1 == 0 )
 8034384:	2b00      	cmp	r3, #0
 8034386:	d03f      	beq.n	8034408 <LoRaMacProcess+0x574>
                    Nvm.MacGroup2.MacParams.ReceiveDelay1 = 1;
 8034388:	f8c4 355c 	str.w	r3, [r4, #1372]	; 0x55c
                Nvm.MacGroup2.MacParams.ReceiveDelay1 *= 1000;
 803438c:	f8d4 255c 	ldr.w	r2, [r4, #1372]	; 0x55c
                RegionApplyCFList( Nvm.MacGroup2.Region, &applyCFList );
 8034390:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
                Nvm.MacGroup2.MacParams.ReceiveDelay1 *= 1000;
 8034394:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8034398:	4353      	muls	r3, r2
 803439a:	f8c4 355c 	str.w	r3, [r4, #1372]	; 0x55c
                Nvm.MacGroup2.MacParams.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay1 + 1000;
 803439e:	f503 737a 	add.w	r3, r3, #1000	; 0x3e8
 80343a2:	f8c4 3560 	str.w	r3, [r4, #1376]	; 0x560
                Nvm.MacGroup2.Version.Fields.Minor = 0;
 80343a6:	2600      	movs	r6, #0
                applyCFList.Payload = macMsgJoinAccept.CFList;
 80343a8:	f10d 034a 	add.w	r3, sp, #74	; 0x4a
                applyCFList.Size = size - 17;
 80343ac:	3d11      	subs	r5, #17
                RegionApplyCFList( Nvm.MacGroup2.Region, &applyCFList );
 80343ae:	a90c      	add	r1, sp, #48	; 0x30
                applyCFList.Payload = macMsgJoinAccept.CFList;
 80343b0:	930c      	str	r3, [sp, #48]	; 0x30
                Nvm.MacGroup2.Version.Fields.Minor = 0;
 80343b2:	f884 661a 	strb.w	r6, [r4, #1562]	; 0x61a
                applyCFList.Size = size - 17;
 80343b6:	f88d 5034 	strb.w	r5, [sp, #52]	; 0x34
                RegionApplyCFList( Nvm.MacGroup2.Region, &applyCFList );
 80343ba:	f002 f9e3 	bl	8036784 <RegionApplyCFList>
                Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_OTAA;
 80343be:	2302      	movs	r3, #2
                if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )
 80343c0:	2001      	movs	r0, #1
                Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_OTAA;
 80343c2:	f884 361c 	strb.w	r3, [r4, #1564]	; 0x61c
                if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )
 80343c6:	f001 fcb9 	bl	8035d3c <LoRaMacConfirmQueueIsCmdActive>
 80343ca:	b118      	cbz	r0, 80343d4 <LoRaMacProcess+0x540>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_JOIN );
 80343cc:	2101      	movs	r1, #1
 80343ce:	4630      	mov	r0, r6
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL, MLME_JOIN );
 80343d0:	f001 fc78 	bl	8035cc4 <LoRaMacConfirmQueueSetStatus>
            MacCtx.MacFlags.Bits.MlmeInd = 1;
 80343d4:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 80343d8:	f043 0308 	orr.w	r3, r3, #8
            MacCtx.MacFlags.Bits.McpsInd = 1;
 80343dc:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
    if( MacCtx.NodeAckRequested == true )
 80343e0:	f894 3418 	ldrb.w	r3, [r4, #1048]	; 0x418
 80343e4:	2b00      	cmp	r3, #0
 80343e6:	f000 816d 	beq.w	80346c4 <LoRaMacProcess+0x830>
        if( MacCtx.McpsConfirm.AckReceived == true )
 80343ea:	f894 3440 	ldrb.w	r3, [r4, #1088]	; 0x440
 80343ee:	b113      	cbz	r3, 80343f6 <LoRaMacProcess+0x562>
            OnAckTimeoutTimerEvent( NULL );
 80343f0:	2000      	movs	r0, #0
 80343f2:	f7fe fe33 	bl	803305c <OnAckTimeoutTimerEvent>
    MacCtx.MacFlags.Bits.MacDone = 1;
 80343f6:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 80343fa:	f043 0320 	orr.w	r3, r3, #32
 80343fe:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
    UpdateRxSlotIdleState( );
 8034402:	f7fe fde1 	bl	8032fc8 <UpdateRxSlotIdleState>
 8034406:	e5f6      	b.n	8033ff6 <LoRaMacProcess+0x162>
                    Nvm.MacGroup2.MacParams.ReceiveDelay1 = 1;
 8034408:	2301      	movs	r3, #1
 803440a:	e7bd      	b.n	8034388 <LoRaMacProcess+0x4f4>
                if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )
 803440c:	2001      	movs	r0, #1
 803440e:	f001 fc95 	bl	8035d3c <LoRaMacConfirmQueueIsCmdActive>
 8034412:	2800      	cmp	r0, #0
 8034414:	d0de      	beq.n	80343d4 <LoRaMacProcess+0x540>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL, MLME_JOIN );
 8034416:	2101      	movs	r1, #1
 8034418:	2007      	movs	r0, #7
 803441a:	e7d9      	b.n	80343d0 <LoRaMacProcess+0x53c>
 803441c:	200055ec 	.word	0x200055ec
 8034420:	20004f24 	.word	0x20004f24
            MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED;
 8034424:	2301      	movs	r3, #1
 8034426:	f884 3420 	strb.w	r3, [r4, #1056]	; 0x420
            getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 803442a:	f894 3581 	ldrb.w	r3, [r4, #1409]	; 0x581
 803442e:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
            getPhy.Datarate = MacCtx.McpsIndication.RxDatarate;
 8034432:	f894 3424 	ldrb.w	r3, [r4, #1060]	; 0x424
 8034436:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
            getPhy.Attribute = PHY_MAX_PAYLOAD;
 803443a:	230d      	movs	r3, #13
 803443c:	f88d 3020 	strb.w	r3, [sp, #32]
            if( Nvm.MacGroup2.MacParams.RepeaterSupport == true )
 8034440:	f894 358c 	ldrb.w	r3, [r4, #1420]	; 0x58c
 8034444:	b113      	cbz	r3, 803444c <LoRaMacProcess+0x5b8>
                getPhy.Attribute = PHY_MAX_PAYLOAD_REPEATER;
 8034446:	230e      	movs	r3, #14
 8034448:	f88d 3020 	strb.w	r3, [sp, #32]
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803444c:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
 8034450:	a908      	add	r1, sp, #32
 8034452:	f002 f964 	bl	803671e <RegionGetPhyParam>
            if( ( MAX( 0, ( int16_t )( ( int16_t ) size - ( int16_t ) LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE ) ) > ( int16_t )phyParam.Value ) ||
 8034456:	f1a5 030d 	sub.w	r3, r5, #13
 803445a:	b21b      	sxth	r3, r3
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803445c:	9006      	str	r0, [sp, #24]
            if( ( MAX( 0, ( int16_t )( ( int16_t ) size - ( int16_t ) LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE ) ) > ( int16_t )phyParam.Value ) ||
 803445e:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8034462:	b200      	sxth	r0, r0
 8034464:	4283      	cmp	r3, r0
 8034466:	f73f af5b 	bgt.w	8034320 <LoRaMacProcess+0x48c>
 803446a:	2d0b      	cmp	r5, #11
 803446c:	f67f af58 	bls.w	8034320 <LoRaMacProcess+0x48c>
            macMsgData.FRMPayload = MacCtx.RxPayload;
 8034470:	4bb9      	ldr	r3, [pc, #740]	; (8034758 <LoRaMacProcess+0x8c4>)
 8034472:	9321      	str	r3, [sp, #132]	; 0x84
            if( LORAMAC_PARSER_SUCCESS != LoRaMacParserData( &macMsgData ) )
 8034474:	a818      	add	r0, sp, #96	; 0x60
            macMsgData.FRMPayloadSize = LORAMAC_PHY_MAXPAYLOAD;
 8034476:	23ff      	movs	r3, #255	; 0xff
            macMsgData.Buffer = payload;
 8034478:	9618      	str	r6, [sp, #96]	; 0x60
            macMsgData.BufSize = size;
 803447a:	f88d 5064 	strb.w	r5, [sp, #100]	; 0x64
            macMsgData.FRMPayloadSize = LORAMAC_PHY_MAXPAYLOAD;
 803447e:	f88d 3088 	strb.w	r3, [sp, #136]	; 0x88
            if( LORAMAC_PARSER_SUCCESS != LoRaMacParserData( &macMsgData ) )
 8034482:	f002 f843 	bl	803650c <LoRaMacParserData>
 8034486:	4606      	mov	r6, r0
 8034488:	2800      	cmp	r0, #0
 803448a:	f47f af49 	bne.w	8034320 <LoRaMacProcess+0x48c>
    if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen > 0 ) && ( macMsg->FPort > 0 ) )
 803448e:	f89d 306c 	ldrb.w	r3, [sp, #108]	; 0x6c
            MacCtx.McpsIndication.DevAddress = macMsgData.FHDR.DevAddr;
 8034492:	991a      	ldr	r1, [sp, #104]	; 0x68
 8034494:	f8c4 1434 	str.w	r1, [r4, #1076]	; 0x434
    if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen > 0 ) && ( macMsg->FPort > 0 ) )
 8034498:	f013 020f 	ands.w	r2, r3, #15
 803449c:	d003      	beq.n	80344a6 <LoRaMacProcess+0x612>
 803449e:	f89d 0080 	ldrb.w	r0, [sp, #128]	; 0x80
 80344a2:	2800      	cmp	r0, #0
 80344a4:	d167      	bne.n	8034576 <LoRaMacProcess+0x6e2>
    else if( macMsg->FRMPayloadSize == 0 )
 80344a6:	f89d 0088 	ldrb.w	r0, [sp, #136]	; 0x88
 80344aa:	2800      	cmp	r0, #0
 80344ac:	d065      	beq.n	803457a <LoRaMacProcess+0x6e6>
    else if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen == 0 ) && ( macMsg->FPort == 0 ) )
 80344ae:	2a00      	cmp	r2, #0
 80344b0:	f47f af36 	bne.w	8034320 <LoRaMacProcess+0x48c>
 80344b4:	f89d 2080 	ldrb.w	r2, [sp, #128]	; 0x80
        *fType = FRAME_TYPE_D;
 80344b8:	2a00      	cmp	r2, #0
 80344ba:	bf0c      	ite	eq
 80344bc:	2502      	moveq	r5, #2
 80344be:	2503      	movne	r5, #3
            downLinkCounter = 0;
 80344c0:	2200      	movs	r2, #0
 80344c2:	9207      	str	r2, [sp, #28]
                if( ( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.Address == macMsgData.FHDR.DevAddr ) &&
 80344c4:	f8d4 25e0 	ldr.w	r2, [r4, #1504]	; 0x5e0
 80344c8:	4291      	cmp	r1, r2
 80344ca:	d158      	bne.n	803457e <LoRaMacProcess+0x6ea>
 80344cc:	f894 15de 	ldrb.w	r1, [r4, #1502]	; 0x5de
 80344d0:	2900      	cmp	r1, #0
 80344d2:	d054      	beq.n	803457e <LoRaMacProcess+0x6ea>
                    downLinkCounter = *( Nvm.MacGroup2.MulticastChannelList[i].DownLinkCounter );
 80344d4:	f8d4 15fc 	ldr.w	r1, [r4, #1532]	; 0x5fc
                    addrID = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.GroupID;
 80344d8:	f894 85df 	ldrb.w	r8, [r4, #1503]	; 0x5df
                    downLinkCounter = *( Nvm.MacGroup2.MulticastChannelList[i].DownLinkCounter );
 80344dc:	6809      	ldr	r1, [r1, #0]
 80344de:	9107      	str	r1, [sp, #28]
                    if( Nvm.MacGroup2.DeviceClass == CLASS_C )
 80344e0:	f894 1608 	ldrb.w	r1, [r4, #1544]	; 0x608
 80344e4:	2902      	cmp	r1, #2
 80344e6:	d102      	bne.n	80344ee <LoRaMacProcess+0x65a>
                        MacCtx.RxStatus.RxSlot = RX_SLOT_WIN_CLASS_C_MULTICAST;
 80344e8:	2103      	movs	r1, #3
 80344ea:	f884 1483 	strb.w	r1, [r4, #1155]	; 0x483
            if( ( multicast == 1 ) && ( ( fType != FRAME_TYPE_D ) ||
 80344ee:	2d03      	cmp	r5, #3
 80344f0:	f47f af16 	bne.w	8034320 <LoRaMacProcess+0x48c>
                                        ( macMsgData.FHDR.FCtrl.Bits.Ack != 0 ) ||
 80344f4:	f013 0f60 	tst.w	r3, #96	; 0x60
 80344f8:	f47f af12 	bne.w	8034320 <LoRaMacProcess+0x48c>
 80344fc:	9203      	str	r2, [sp, #12]
 80344fe:	2601      	movs	r6, #1
            getPhy.Attribute = PHY_MAX_FCNT_GAP;
 8034500:	2315      	movs	r3, #21
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034502:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
            getPhy.Attribute = PHY_MAX_FCNT_GAP;
 8034506:	f88d 3020 	strb.w	r3, [sp, #32]
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803450a:	a908      	add	r1, sp, #32
 803450c:	f002 f907 	bl	803671e <RegionGetPhyParam>
            macCryptoStatus = GetFCntDown( addrID, fType, &macMsgData, Nvm.MacGroup2.Version, phyParam.Value, &fCntID, &downLinkCounter );
 8034510:	f894 761a 	ldrb.w	r7, [r4, #1562]	; 0x61a
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034514:	9006      	str	r0, [sp, #24]
    switch( addrID )
 8034516:	f1b8 0f00 	cmp.w	r8, #0
 803451a:	d033      	beq.n	8034584 <LoRaMacProcess+0x6f0>
 803451c:	f1b8 0f01 	cmp.w	r8, #1
 8034520:	d13c      	bne.n	803459c <LoRaMacProcess+0x708>
            if( lrWanVersion.Fields.Minor == 1 )
 8034522:	2f01      	cmp	r7, #1
 8034524:	d130      	bne.n	8034588 <LoRaMacProcess+0x6f4>
                if( ( fType == FRAME_TYPE_A ) || ( fType == FRAME_TYPE_D ) )
 8034526:	b38d      	cbz	r5, 803458c <LoRaMacProcess+0x6f8>
                    *fCntID = A_FCNT_DOWN;
 8034528:	2d03      	cmp	r5, #3
 803452a:	bf14      	ite	ne
 803452c:	4647      	movne	r7, r8
 803452e:	2702      	moveq	r7, #2
    return LoRaMacCryptoGetFCntDown( *fCntID, maxFCntGap, macMsg->FHDR.FCnt, currentDown );
 8034530:	f8bd 206e 	ldrh.w	r2, [sp, #110]	; 0x6e
 8034534:	f8bd 1018 	ldrh.w	r1, [sp, #24]
 8034538:	ab07      	add	r3, sp, #28
 803453a:	4638      	mov	r0, r7
 803453c:	f001 fd6c 	bl	8036018 <LoRaMacCryptoGetFCntDown>
            if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS )
 8034540:	b370      	cbz	r0, 80345a0 <LoRaMacProcess+0x70c>
                if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_FCNT_DUPLICATED )
 8034542:	2807      	cmp	r0, #7
 8034544:	d124      	bne.n	8034590 <LoRaMacProcess+0x6fc>
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_REPEATED;
 8034546:	2308      	movs	r3, #8
 8034548:	f884 3421 	strb.w	r3, [r4, #1057]	; 0x421
                    if( ( Nvm.MacGroup2.Version.Fields.Minor == 0 ) && ( macHdr.Bits.MType == FRAME_TYPE_DATA_CONFIRMED_DOWN ) && ( Nvm.MacGroup1.LastRxMic == macMsgData.MIC ) )
 803454c:	f894 361a 	ldrb.w	r3, [r4, #1562]	; 0x61a
 8034550:	b95b      	cbnz	r3, 803456a <LoRaMacProcess+0x6d6>
 8034552:	f00b 03e0 	and.w	r3, fp, #224	; 0xe0
 8034556:	2ba0      	cmp	r3, #160	; 0xa0
 8034558:	d107      	bne.n	803456a <LoRaMacProcess+0x6d6>
 803455a:	f8d4 2540 	ldr.w	r2, [r4, #1344]	; 0x540
 803455e:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8034560:	429a      	cmp	r2, r3
 8034562:	d102      	bne.n	803456a <LoRaMacProcess+0x6d6>
                        Nvm.MacGroup1.SrvAckRequested = true;
 8034564:	2301      	movs	r3, #1
 8034566:	f884 3546 	strb.w	r3, [r4, #1350]	; 0x546
                MacCtx.McpsIndication.DownLinkCounter = downLinkCounter;
 803456a:	9b07      	ldr	r3, [sp, #28]
 803456c:	f8c4 3430 	str.w	r3, [r4, #1072]	; 0x430
                PrepareRxDoneAbort( );
 8034570:	f7fe fd96 	bl	80330a0 <PrepareRxDoneAbort>
                return;
 8034574:	e53f      	b.n	8033ff6 <LoRaMacProcess+0x162>
        *fType = FRAME_TYPE_A;
 8034576:	4635      	mov	r5, r6
 8034578:	e7a2      	b.n	80344c0 <LoRaMacProcess+0x62c>
        *fType = FRAME_TYPE_B;
 803457a:	2501      	movs	r5, #1
 803457c:	e7a0      	b.n	80344c0 <LoRaMacProcess+0x62c>
 803457e:	f04f 0801 	mov.w	r8, #1
 8034582:	e7bd      	b.n	8034500 <LoRaMacProcess+0x66c>
    switch( addrID )
 8034584:	2704      	movs	r7, #4
 8034586:	e7d3      	b.n	8034530 <LoRaMacProcess+0x69c>
                *fCntID = FCNT_DOWN;
 8034588:	2703      	movs	r7, #3
 803458a:	e7d1      	b.n	8034530 <LoRaMacProcess+0x69c>
                    *fCntID = A_FCNT_DOWN;
 803458c:	2702      	movs	r7, #2
 803458e:	e7cf      	b.n	8034530 <LoRaMacProcess+0x69c>
                else if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_MAX_GAP_FCNT )
 8034590:	2808      	cmp	r0, #8
 8034592:	d103      	bne.n	803459c <LoRaMacProcess+0x708>
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_TOO_MANY_FRAMES_LOSS;
 8034594:	230a      	movs	r3, #10
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 8034596:	f884 3421 	strb.w	r3, [r4, #1057]	; 0x421
 803459a:	e7e6      	b.n	803456a <LoRaMacProcess+0x6d6>
 803459c:	2301      	movs	r3, #1
 803459e:	e7fa      	b.n	8034596 <LoRaMacProcess+0x702>
            macCryptoStatus = LoRaMacCryptoUnsecureMessage( addrID, address, fCntID, downLinkCounter, &macMsgData );
 80345a0:	ab18      	add	r3, sp, #96	; 0x60
 80345a2:	9300      	str	r3, [sp, #0]
 80345a4:	9903      	ldr	r1, [sp, #12]
 80345a6:	9b07      	ldr	r3, [sp, #28]
 80345a8:	463a      	mov	r2, r7
 80345aa:	4640      	mov	r0, r8
 80345ac:	f001 fe04 	bl	80361b8 <LoRaMacCryptoUnsecureMessage>
            if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS )
 80345b0:	b120      	cbz	r0, 80345bc <LoRaMacProcess+0x728>
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_MIC_FAIL;
 80345b2:	2802      	cmp	r0, #2
 80345b4:	bf0c      	ite	eq
 80345b6:	230b      	moveq	r3, #11
 80345b8:	230c      	movne	r3, #12
 80345ba:	e6b2      	b.n	8034322 <LoRaMacProcess+0x48e>
            MacCtx.McpsIndication.FramePending = macMsgData.FHDR.FCtrl.Bits.FPending;
 80345bc:	f89d 306c 	ldrb.w	r3, [sp, #108]	; 0x6c
            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK;
 80345c0:	f884 0421 	strb.w	r0, [r4, #1057]	; 0x421
            MacCtx.McpsIndication.FramePending = macMsgData.FHDR.FCtrl.Bits.FPending;
 80345c4:	f3c3 1200 	ubfx	r2, r3, #4, #1
 80345c8:	f884 2425 	strb.w	r2, [r4, #1061]	; 0x425
            MacCtx.McpsIndication.DownLinkCounter = downLinkCounter;
 80345cc:	9a07      	ldr	r2, [sp, #28]
 80345ce:	f8c4 2430 	str.w	r2, [r4, #1072]	; 0x430
            if( ( MacCtx.RxStatus.RxSlot == RX_SLOT_WIN_1 ) ||
 80345d2:	f894 2483 	ldrb.w	r2, [r4, #1155]	; 0x483
            MacCtx.McpsIndication.Multicast = multicast;
 80345d6:	f884 6422 	strb.w	r6, [r4, #1058]	; 0x422
            if( ( MacCtx.RxStatus.RxSlot == RX_SLOT_WIN_1 ) ||
 80345da:	2a01      	cmp	r2, #1
            MacCtx.McpsIndication.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;
 80345dc:	f3c3 1340 	ubfx	r3, r3, #5, #1
                Nvm.MacGroup1.AdrAckCounter = 0;
 80345e0:	bf98      	it	ls
 80345e2:	f8c4 0534 	strls.w	r0, [r4, #1332]	; 0x534
            if( multicast == 1 )
 80345e6:	2e01      	cmp	r6, #1
            MacCtx.McpsIndication.Buffer = NULL;
 80345e8:	f8c4 0428 	str.w	r0, [r4, #1064]	; 0x428
            MacCtx.McpsIndication.BufferSize = 0;
 80345ec:	f884 042c 	strb.w	r0, [r4, #1068]	; 0x42c
            MacCtx.McpsIndication.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;
 80345f0:	f884 342e 	strb.w	r3, [r4, #1070]	; 0x42e
            MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;
 80345f4:	f884 043d 	strb.w	r0, [r4, #1085]	; 0x43d
            MacCtx.McpsConfirm.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;
 80345f8:	f884 3440 	strb.w	r3, [r4, #1088]	; 0x440
            if( multicast == 1 )
 80345fc:	d12b      	bne.n	8034656 <LoRaMacProcess+0x7c2>
                MacCtx.McpsIndication.McpsIndication = MCPS_MULTICAST;
 80345fe:	2302      	movs	r3, #2
    if( rxSlot == RX_SLOT_WIN_1 || rxSlot == RX_SLOT_WIN_2  )
 8034600:	2a01      	cmp	r2, #1
                    MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED;
 8034602:	f884 3420 	strb.w	r3, [r4, #1056]	; 0x420
            RemoveMacCommands( MacCtx.RxStatus.RxSlot, macMsgData.FHDR.FCtrl, MacCtx.McpsConfirm.McpsRequest );
 8034606:	f894 143c 	ldrb.w	r1, [r4, #1084]	; 0x43c
 803460a:	f89d 306c 	ldrb.w	r3, [sp, #108]	; 0x6c
    if( rxSlot == RX_SLOT_WIN_1 || rxSlot == RX_SLOT_WIN_2  )
 803460e:	d805      	bhi.n	803461c <LoRaMacProcess+0x788>
        if( request == MCPS_CONFIRMED )
 8034610:	2901      	cmp	r1, #1
 8034612:	d101      	bne.n	8034618 <LoRaMacProcess+0x784>
            if( fCtrl.Bits.Ack == 1 )
 8034614:	069b      	lsls	r3, r3, #26
 8034616:	d501      	bpl.n	803461c <LoRaMacProcess+0x788>
                LoRaMacCommandsRemoveStickyAnsCmds( );
 8034618:	f001 fa7c 	bl	8035b14 <LoRaMacCommandsRemoveStickyAnsCmds>
            switch( fType )
 803461c:	2d02      	cmp	r5, #2
 803461e:	d02d      	beq.n	803467c <LoRaMacProcess+0x7e8>
 8034620:	2d03      	cmp	r5, #3
 8034622:	d009      	beq.n	8034638 <LoRaMacProcess+0x7a4>
 8034624:	f89d 106c 	ldrb.w	r1, [sp, #108]	; 0x6c
 8034628:	2d01      	cmp	r5, #1
                    ProcessMacCommands( macMsgData.FHDR.FOpts, 0, macMsgData.FHDR.FCtrl.Bits.FOptsLen, snr, MacCtx.RxStatus.RxSlot );
 803462a:	464a      	mov	r2, r9
 803462c:	f001 010f 	and.w	r1, r1, #15
 8034630:	a81c      	add	r0, sp, #112	; 0x70
 8034632:	d027      	beq.n	8034684 <LoRaMacProcess+0x7f0>
 8034634:	f7ff f950 	bl	80338d8 <ProcessMacCommands.isra.0.constprop.0>
                    MacCtx.McpsIndication.Port = macMsgData.FPort;
 8034638:	f89d 3080 	ldrb.w	r3, [sp, #128]	; 0x80
 803463c:	f884 3423 	strb.w	r3, [r4, #1059]	; 0x423
                    MacCtx.McpsIndication.Buffer = macMsgData.FRMPayload;
 8034640:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8034642:	f8c4 3428 	str.w	r3, [r4, #1064]	; 0x428
                    MacCtx.McpsIndication.BufferSize = macMsgData.FRMPayloadSize;
 8034646:	f89d 3088 	ldrb.w	r3, [sp, #136]	; 0x88
 803464a:	f884 342c 	strb.w	r3, [r4, #1068]	; 0x42c
                    MacCtx.McpsIndication.RxData = true;
 803464e:	2301      	movs	r3, #1
 8034650:	f884 342d 	strb.w	r3, [r4, #1069]	; 0x42d
                    break;
 8034654:	e01c      	b.n	8034690 <LoRaMacProcess+0x7fc>
                if( macHdr.Bits.MType == FRAME_TYPE_DATA_CONFIRMED_DOWN )
 8034656:	f00b 03e0 	and.w	r3, fp, #224	; 0xe0
 803465a:	2ba0      	cmp	r3, #160	; 0xa0
 803465c:	d10a      	bne.n	8034674 <LoRaMacProcess+0x7e0>
                    if( Nvm.MacGroup2.Version.Fields.Minor == 0 )
 803465e:	f894 161a 	ldrb.w	r1, [r4, #1562]	; 0x61a
                    Nvm.MacGroup1.SrvAckRequested = true;
 8034662:	2301      	movs	r3, #1
 8034664:	f884 3546 	strb.w	r3, [r4, #1350]	; 0x546
                    if( Nvm.MacGroup2.Version.Fields.Minor == 0 )
 8034668:	2900      	cmp	r1, #0
 803466a:	d1c9      	bne.n	8034600 <LoRaMacProcess+0x76c>
                        Nvm.MacGroup1.LastRxMic = macMsgData.MIC;
 803466c:	9923      	ldr	r1, [sp, #140]	; 0x8c
 803466e:	f8c4 1540 	str.w	r1, [r4, #1344]	; 0x540
                    MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED;
 8034672:	e7c5      	b.n	8034600 <LoRaMacProcess+0x76c>
                    Nvm.MacGroup1.SrvAckRequested = false;
 8034674:	2300      	movs	r3, #0
 8034676:	f884 3546 	strb.w	r3, [r4, #1350]	; 0x546
 803467a:	e7c1      	b.n	8034600 <LoRaMacProcess+0x76c>
                    ProcessMacCommands( macMsgData.FRMPayload, 0, macMsgData.FRMPayloadSize, snr, MacCtx.RxStatus.RxSlot );
 803467c:	f89d 1088 	ldrb.w	r1, [sp, #136]	; 0x88
 8034680:	9821      	ldr	r0, [sp, #132]	; 0x84
 8034682:	464a      	mov	r2, r9
 8034684:	f7ff f928 	bl	80338d8 <ProcessMacCommands.isra.0.constprop.0>
                    MacCtx.McpsIndication.Port = macMsgData.FPort;
 8034688:	f89d 3080 	ldrb.w	r3, [sp, #128]	; 0x80
 803468c:	f884 3423 	strb.w	r3, [r4, #1059]	; 0x423
            MacCtx.MacFlags.Bits.McpsInd = 1;
 8034690:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 8034694:	f043 0302 	orr.w	r3, r3, #2
 8034698:	e6a0      	b.n	80343dc <LoRaMacProcess+0x548>
            memcpy1( MacCtx.RxPayload, &payload[pktHeaderLen], size - pktHeaderLen );
 803469a:	4f2f      	ldr	r7, [pc, #188]	; (8034758 <LoRaMacProcess+0x8c4>)
 803469c:	3d01      	subs	r5, #1
 803469e:	b2aa      	uxth	r2, r5
 80346a0:	1c71      	adds	r1, r6, #1
 80346a2:	4638      	mov	r0, r7
 80346a4:	f004 fc42 	bl	8038f2c <memcpy1>
            MacCtx.McpsIndication.McpsIndication = MCPS_PROPRIETARY;
 80346a8:	2303      	movs	r3, #3
 80346aa:	f8a4 3420 	strh.w	r3, [r4, #1056]	; 0x420
            MacCtx.McpsIndication.Buffer = MacCtx.RxPayload;
 80346ae:	f8c4 7428 	str.w	r7, [r4, #1064]	; 0x428
            MacCtx.McpsIndication.BufferSize = size - pktHeaderLen;
 80346b2:	f884 542c 	strb.w	r5, [r4, #1068]	; 0x42c
            MacCtx.MacFlags.Bits.McpsInd = 1;
 80346b6:	e7eb      	b.n	8034690 <LoRaMacProcess+0x7fc>
            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 80346b8:	2301      	movs	r3, #1
 80346ba:	f884 3421 	strb.w	r3, [r4, #1057]	; 0x421
            PrepareRxDoneAbort( );
 80346be:	f7fe fcef 	bl	80330a0 <PrepareRxDoneAbort>
            break;
 80346c2:	e68d      	b.n	80343e0 <LoRaMacProcess+0x54c>
        if( Nvm.MacGroup2.DeviceClass == CLASS_C )
 80346c4:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 80346c8:	2b02      	cmp	r3, #2
 80346ca:	f47f ae94 	bne.w	80343f6 <LoRaMacProcess+0x562>
 80346ce:	e68f      	b.n	80343f0 <LoRaMacProcess+0x55c>
    if( MacCtx.MacFlags.Bits.MlmeReq == 1 )
 80346d0:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 80346d4:	0759      	lsls	r1, r3, #29
 80346d6:	d50f      	bpl.n	80346f8 <LoRaMacProcess+0x864>
        if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )
 80346d8:	2001      	movs	r0, #1
 80346da:	f001 fb2f 	bl	8035d3c <LoRaMacConfirmQueueIsCmdActive>
 80346de:	b380      	cbz	r0, 8034742 <LoRaMacProcess+0x8ae>
            if( LoRaMacConfirmQueueGetStatus( MLME_JOIN ) == LORAMAC_EVENT_INFO_STATUS_OK )
 80346e0:	2001      	movs	r0, #1
 80346e2:	f001 fb01 	bl	8035ce8 <LoRaMacConfirmQueueGetStatus>
 80346e6:	b908      	cbnz	r0, 80346ec <LoRaMacProcess+0x858>
                MacCtx.ChannelsNbTransCounter = 0;
 80346e8:	f884 0414 	strb.w	r0, [r4, #1044]	; 0x414
            MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 80346ec:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 80346f0:	f023 0302 	bic.w	r3, r3, #2
 80346f4:	f8c4 3344 	str.w	r3, [r4, #836]	; 0x344
    if( MacCtx.MacFlags.Bits.McpsReq == 1 )
 80346f8:	f894 1485 	ldrb.w	r1, [r4, #1157]	; 0x485
 80346fc:	07ca      	lsls	r2, r1, #31
 80346fe:	f57f accf 	bpl.w	80340a0 <LoRaMacProcess+0x20c>
        if( ( MacCtx.McpsConfirm.McpsRequest == MCPS_UNCONFIRMED ) ||
 8034702:	f894 343c 	ldrb.w	r3, [r4, #1084]	; 0x43c
 8034706:	b10b      	cbz	r3, 803470c <LoRaMacProcess+0x878>
 8034708:	2b03      	cmp	r3, #3
 803470a:	d129      	bne.n	8034760 <LoRaMacProcess+0x8cc>
    if( MacCtx.ChannelsNbTransCounter >=
 803470c:	f894 2414 	ldrb.w	r2, [r4, #1044]	; 0x414
 8034710:	f894 356c 	ldrb.w	r3, [r4, #1388]	; 0x56c
 8034714:	429a      	cmp	r2, r3
 8034716:	d208      	bcs.n	803472a <LoRaMacProcess+0x896>
    else if( MacCtx.MacFlags.Bits.McpsInd == 1 )
 8034718:	078b      	lsls	r3, r1, #30
 803471a:	d553      	bpl.n	80347c4 <LoRaMacProcess+0x930>
        if( Nvm.MacGroup2.DeviceClass == CLASS_A )
 803471c:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 8034720:	b11b      	cbz	r3, 803472a <LoRaMacProcess+0x896>
            if( MacCtx.RxStatus.RxSlot == RX_SLOT_WIN_1 )
 8034722:	f894 3483 	ldrb.w	r3, [r4, #1155]	; 0x483
 8034726:	2b00      	cmp	r3, #0
 8034728:	d14c      	bne.n	80347c4 <LoRaMacProcess+0x930>
            TimerStop( &MacCtx.TxDelayedTimer );
 803472a:	480c      	ldr	r0, [pc, #48]	; (803475c <LoRaMacProcess+0x8c8>)
 803472c:	f006 fe06 	bl	803b33c <UTIL_TIMER_Stop>
            MacCtx.MacState &= ~LORAMAC_TX_DELAYED;
 8034730:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 8034734:	f023 0320 	bic.w	r3, r3, #32
 8034738:	f8c4 3344 	str.w	r3, [r4, #836]	; 0x344
            StopRetransmission( );
 803473c:	f7fe fc50 	bl	8032fe0 <StopRetransmission>
 8034740:	e4ae      	b.n	80340a0 <LoRaMacProcess+0x20c>
        else if( ( LoRaMacConfirmQueueIsCmdActive( MLME_TXCW ) == true ) ||
 8034742:	2005      	movs	r0, #5
 8034744:	f001 fafa 	bl	8035d3c <LoRaMacConfirmQueueIsCmdActive>
 8034748:	2800      	cmp	r0, #0
 803474a:	d1cf      	bne.n	80346ec <LoRaMacProcess+0x858>
                 ( LoRaMacConfirmQueueIsCmdActive( MLME_TXCW_1 ) == true ) )
 803474c:	2006      	movs	r0, #6
 803474e:	f001 faf5 	bl	8035d3c <LoRaMacConfirmQueueIsCmdActive>
        else if( ( LoRaMacConfirmQueueIsCmdActive( MLME_TXCW ) == true ) ||
 8034752:	2800      	cmp	r0, #0
 8034754:	d1ca      	bne.n	80346ec <LoRaMacProcess+0x858>
 8034756:	e7cf      	b.n	80346f8 <LoRaMacProcess+0x864>
 8034758:	20004ce0 	.word	0x20004ce0
 803475c:	20004e10 	.word	0x20004e10
        else if( MacCtx.McpsConfirm.McpsRequest == MCPS_CONFIRMED )
 8034760:	2b01      	cmp	r3, #1
 8034762:	d12f      	bne.n	80347c4 <LoRaMacProcess+0x930>
            if( MacCtx.AckTimeoutRetry == true )
 8034764:	f894 2417 	ldrb.w	r2, [r4, #1047]	; 0x417
 8034768:	2a00      	cmp	r2, #0
 803476a:	f43f ac99 	beq.w	80340a0 <LoRaMacProcess+0x20c>
    if( MacCtx.AckTimeoutRetriesCounter >=
 803476e:	f894 3416 	ldrb.w	r3, [r4, #1046]	; 0x416
        MacCtx.AckTimeoutRetries )
 8034772:	f894 0415 	ldrb.w	r0, [r4, #1045]	; 0x415
    if( MacCtx.AckTimeoutRetriesCounter >=
 8034776:	4283      	cmp	r3, r0
 8034778:	d204      	bcs.n	8034784 <LoRaMacProcess+0x8f0>
    else if( MacCtx.MacFlags.Bits.McpsInd == 1 )
 803477a:	f011 0202 	ands.w	r2, r1, #2
        if( MacCtx.McpsConfirm.AckReceived == true )
 803477e:	bf18      	it	ne
 8034780:	f894 2440 	ldrbne.w	r2, [r4, #1088]	; 0x440
                if( Nvm.MacGroup2.Version.Fields.Minor == 0 )
 8034784:	f894 161a 	ldrb.w	r1, [r4, #1562]	; 0x61a
 8034788:	2900      	cmp	r1, #0
 803478a:	d13f      	bne.n	803480c <LoRaMacProcess+0x978>
                    if( stopRetransmission == false )
 803478c:	bb32      	cbnz	r2, 80347dc <LoRaMacProcess+0x948>
    if( MacCtx.AckTimeoutRetriesCounter < MacCtx.AckTimeoutRetries )
 803478e:	4283      	cmp	r3, r0
 8034790:	d218      	bcs.n	80347c4 <LoRaMacProcess+0x930>
        MacCtx.AckTimeoutRetriesCounter++;
 8034792:	3301      	adds	r3, #1
 8034794:	b2db      	uxtb	r3, r3
        if( ( MacCtx.AckTimeoutRetriesCounter % 2 ) == 1 )
 8034796:	07df      	lsls	r7, r3, #31
        MacCtx.AckTimeoutRetriesCounter++;
 8034798:	f884 3416 	strb.w	r3, [r4, #1046]	; 0x416
        if( ( MacCtx.AckTimeoutRetriesCounter % 2 ) == 1 )
 803479c:	d512      	bpl.n	80347c4 <LoRaMacProcess+0x930>
            getPhy.Attribute = PHY_NEXT_LOWER_TX_DR;
 803479e:	2322      	movs	r3, #34	; 0x22
 80347a0:	f88d 3060 	strb.w	r3, [sp, #96]	; 0x60
            getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 80347a4:	f894 3580 	ldrb.w	r3, [r4, #1408]	; 0x580
 80347a8:	f88d 3062 	strb.w	r3, [sp, #98]	; 0x62
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80347ac:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
            getPhy.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 80347b0:	f894 3545 	ldrb.w	r3, [r4, #1349]	; 0x545
 80347b4:	f88d 3061 	strb.w	r3, [sp, #97]	; 0x61
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80347b8:	a918      	add	r1, sp, #96	; 0x60
 80347ba:	f001 ffb0 	bl	803671e <RegionGetPhyParam>
 80347be:	900e      	str	r0, [sp, #56]	; 0x38
            Nvm.MacGroup1.ChannelsDatarate = phyParam.Value;
 80347c0:	f884 0545 	strb.w	r0, [r4, #1349]	; 0x545
            MacCtx.MacFlags.Bits.MacDone = 0;
 80347c4:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
            MacCtx.AckTimeoutRetry = false;
 80347c8:	2000      	movs	r0, #0
            MacCtx.MacFlags.Bits.MacDone = 0;
 80347ca:	f36f 1345 	bfc	r3, #5, #1
 80347ce:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
            MacCtx.AckTimeoutRetry = false;
 80347d2:	f884 0417 	strb.w	r0, [r4, #1047]	; 0x417
            OnTxDelayedTimerEvent( NULL );
 80347d6:	f7fe ff71 	bl	80336bc <OnTxDelayedTimerEvent>
 80347da:	e461      	b.n	80340a0 <LoRaMacProcess+0x20c>
    if( MacCtx.McpsConfirm.AckReceived == false )
 80347dc:	f894 5440 	ldrb.w	r5, [r4, #1088]	; 0x440
 80347e0:	b97d      	cbnz	r5, 8034802 <LoRaMacProcess+0x96e>
        params.Type = INIT_TYPE_ACTIVATE_DEFAULT_CHANNELS;
 80347e2:	2302      	movs	r3, #2
 80347e4:	f88d 3068 	strb.w	r3, [sp, #104]	; 0x68
        params.NvmGroup1 = &Nvm.RegionGroup1;
 80347e8:	4b0a      	ldr	r3, [pc, #40]	; (8034814 <LoRaMacProcess+0x980>)
 80347ea:	9318      	str	r3, [sp, #96]	; 0x60
        RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 80347ec:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
        params.NvmGroup2 = &Nvm.RegionGroup2;
 80347f0:	33a4      	adds	r3, #164	; 0xa4
        RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 80347f2:	a918      	add	r1, sp, #96	; 0x60
        params.NvmGroup2 = &Nvm.RegionGroup2;
 80347f4:	9319      	str	r3, [sp, #100]	; 0x64
        RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 80347f6:	f001 ffad 	bl	8036754 <RegionInitDefaults>
        MacCtx.NodeAckRequested = false;
 80347fa:	f884 5418 	strb.w	r5, [r4, #1048]	; 0x418
        MacCtx.McpsConfirm.AckReceived = false;
 80347fe:	f884 5440 	strb.w	r5, [r4, #1088]	; 0x440
    MacCtx.McpsConfirm.NbRetries = MacCtx.AckTimeoutRetriesCounter;
 8034802:	f894 3416 	ldrb.w	r3, [r4, #1046]	; 0x416
 8034806:	f884 3441 	strb.w	r3, [r4, #1089]	; 0x441
        if( stopRetransmission == true )
 803480a:	e78e      	b.n	803472a <LoRaMacProcess+0x896>
 803480c:	2a00      	cmp	r2, #0
 803480e:	d0d9      	beq.n	80347c4 <LoRaMacProcess+0x930>
 8034810:	e78b      	b.n	803472a <LoRaMacProcess+0x896>
 8034812:	bf00      	nop
 8034814:	200051cc 	.word	0x200051cc

08034818 <LoRaMacInitialization>:
    return 0;
}


LoRaMacStatus_t LoRaMacInitialization( LoRaMacPrimitives_t* primitives, LoRaMacCallback_t* callbacks, LoRaMacRegion_t region )
{
 8034818:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 803481c:	4688      	mov	r8, r1
 803481e:	b08a      	sub	sp, #40	; 0x28
 8034820:	4691      	mov	r9, r2
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;

    if( ( primitives == NULL ) ||
 8034822:	4606      	mov	r6, r0
 8034824:	2800      	cmp	r0, #0
 8034826:	f000 8197 	beq.w	8034b58 <LoRaMacInitialization+0x340>
 803482a:	2900      	cmp	r1, #0
 803482c:	f000 8194 	beq.w	8034b58 <LoRaMacInitialization+0x340>
        ( callbacks == NULL ) )
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }

    if( ( primitives->MacMcpsConfirm == NULL ) ||
 8034830:	6803      	ldr	r3, [r0, #0]
 8034832:	2b00      	cmp	r3, #0
 8034834:	f000 8190 	beq.w	8034b58 <LoRaMacInitialization+0x340>
 8034838:	6843      	ldr	r3, [r0, #4]
 803483a:	2b00      	cmp	r3, #0
 803483c:	f000 818c 	beq.w	8034b58 <LoRaMacInitialization+0x340>
        ( primitives->MacMcpsIndication == NULL ) ||
 8034840:	6883      	ldr	r3, [r0, #8]
 8034842:	2b00      	cmp	r3, #0
 8034844:	f000 8188 	beq.w	8034b58 <LoRaMacInitialization+0x340>
        ( primitives->MacMlmeConfirm == NULL ) ||
 8034848:	68c3      	ldr	r3, [r0, #12]
 803484a:	2b00      	cmp	r3, #0
 803484c:	f000 8184 	beq.w	8034b58 <LoRaMacInitialization+0x340>
        ( primitives->MacMlmeIndication == NULL ) )
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }
    // Verify if the region is supported
    if( RegionIsActive( region ) == false )
 8034850:	4610      	mov	r0, r2
 8034852:	f001 ff5b 	bl	803670c <RegionIsActive>
 8034856:	2800      	cmp	r0, #0
 8034858:	f000 8180 	beq.w	8034b5c <LoRaMacInitialization+0x344>

    // Confirm queue reset
    LoRaMacConfirmQueueInit( primitives );

    // Initialize the module context with zeros
    memset1( ( uint8_t* ) &Nvm, 0x00, sizeof( LoRaMacNvmData_t ) );
 803485c:	4cc1      	ldr	r4, [pc, #772]	; (8034b64 <LoRaMacInitialization+0x34c>)
    LoRaMacConfirmQueueInit( primitives );
 803485e:	4630      	mov	r0, r6
 8034860:	f001 f9e4 	bl	8035c2c <LoRaMacConfirmQueueInit>
    memset1( ( uint8_t* ) &Nvm, 0x00, sizeof( LoRaMacNvmData_t ) );
 8034864:	f240 6254 	movw	r2, #1620	; 0x654
 8034868:	2100      	movs	r1, #0
 803486a:	f204 500c 	addw	r0, r4, #1292	; 0x50c
 803486e:	f004 fb71 	bl	8038f54 <memset1>
    memset1( ( uint8_t* ) &MacCtx, 0x00, sizeof( LoRaMacCtx_t ) );
 8034872:	f44f 62a1 	mov.w	r2, #1288	; 0x508
 8034876:	2100      	movs	r1, #0
 8034878:	1d20      	adds	r0, r4, #4
 803487a:	f004 fb6b 	bl	8038f54 <memset1>
    Nvm.MacGroup2.Region = region;
    Nvm.MacGroup2.DeviceClass = CLASS_A;
    Nvm.MacGroup2.MacParams.RepeaterSupport = false; /* ST_WORKAROUND: Keep repeater feature */

    // Setup version
    Nvm.MacGroup2.Version.Value = LORAMAC_VERSION;
 803487e:	4bba      	ldr	r3, [pc, #744]	; (8034b68 <LoRaMacInitialization+0x350>)
 8034880:	f8c4 3618 	str.w	r3, [r4, #1560]	; 0x618
    Nvm.MacGroup2.DeviceClass = CLASS_A;
 8034884:	2500      	movs	r5, #0
    MacCtx.AckTimeoutRetriesCounter = 1;
 8034886:	2701      	movs	r7, #1

    // Reset to defaults
    getPhy.Attribute = PHY_DUTY_CYCLE;
 8034888:	230f      	movs	r3, #15
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803488a:	a905      	add	r1, sp, #20
 803488c:	4648      	mov	r0, r9
    getPhy.Attribute = PHY_DUTY_CYCLE;
 803488e:	f88d 3014 	strb.w	r3, [sp, #20]
    Nvm.MacGroup2.Region = region;
 8034892:	f884 954c 	strb.w	r9, [r4, #1356]	; 0x54c
    Nvm.MacGroup2.DeviceClass = CLASS_A;
 8034896:	f884 5608 	strb.w	r5, [r4, #1544]	; 0x608
    Nvm.MacGroup2.MacParams.RepeaterSupport = false; /* ST_WORKAROUND: Keep repeater feature */
 803489a:	f884 558c 	strb.w	r5, [r4, #1420]	; 0x58c
    MacCtx.AckTimeoutRetriesCounter = 1;
 803489e:	f884 7416 	strb.w	r7, [r4, #1046]	; 0x416
    MacCtx.AckTimeoutRetries = 1;
 80348a2:	f884 7415 	strb.w	r7, [r4, #1045]	; 0x415
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348a6:	f001 ff3a 	bl	803671e <RegionGetPhyParam>
    Nvm.MacGroup2.DutyCycleOn = ( bool ) phyParam.Value;
 80348aa:	1b40      	subs	r0, r0, r5
 80348ac:	bf18      	it	ne
 80348ae:	2001      	movne	r0, #1

    getPhy.Attribute = PHY_DEF_TX_POWER;
 80348b0:	f04f 0a0a 	mov.w	sl, #10
    Nvm.MacGroup2.DutyCycleOn = ( bool ) phyParam.Value;
 80348b4:	f884 060c 	strb.w	r0, [r4, #1548]	; 0x60c
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348b8:	a905      	add	r1, sp, #20
 80348ba:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_TX_POWER;
 80348be:	f88d a014 	strb.w	sl, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348c2:	f001 ff2c 	bl	803671e <RegionGetPhyParam>
    Nvm.MacGroup2.ChannelsTxPowerDefault = phyParam.Value;

    getPhy.Attribute = PHY_DEF_TX_DR;
 80348c6:	f04f 0906 	mov.w	r9, #6
    Nvm.MacGroup2.ChannelsTxPowerDefault = phyParam.Value;
 80348ca:	f884 05d0 	strb.w	r0, [r4, #1488]	; 0x5d0
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348ce:	a905      	add	r1, sp, #20
 80348d0:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_TX_DR;
 80348d4:	f88d 9014 	strb.w	r9, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348d8:	f001 ff21 	bl	803671e <RegionGetPhyParam>
    Nvm.MacGroup2.ChannelsDatarateDefault = phyParam.Value;

    getPhy.Attribute = PHY_MAX_RX_WINDOW;
 80348dc:	2310      	movs	r3, #16
    Nvm.MacGroup2.ChannelsDatarateDefault = phyParam.Value;
 80348de:	f884 05d1 	strb.w	r0, [r4, #1489]	; 0x5d1
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348e2:	a905      	add	r1, sp, #20
 80348e4:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_MAX_RX_WINDOW;
 80348e8:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348ec:	f001 ff17 	bl	803671e <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.MaxRxWindow = phyParam.Value;

    getPhy.Attribute = PHY_RECEIVE_DELAY1;
 80348f0:	2311      	movs	r3, #17
    Nvm.MacGroup2.MacParamsDefaults.MaxRxWindow = phyParam.Value;
 80348f2:	f8c4 0598 	str.w	r0, [r4, #1432]	; 0x598
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348f6:	a905      	add	r1, sp, #20
 80348f8:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_RECEIVE_DELAY1;
 80348fc:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034900:	f001 ff0d 	bl	803671e <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay1 = phyParam.Value;

    getPhy.Attribute = PHY_RECEIVE_DELAY2;
 8034904:	2312      	movs	r3, #18
    Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay1 = phyParam.Value;
 8034906:	f8c4 059c 	str.w	r0, [r4, #1436]	; 0x59c
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803490a:	a905      	add	r1, sp, #20
 803490c:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_RECEIVE_DELAY2;
 8034910:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034914:	f001 ff03 	bl	803671e <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay2 = phyParam.Value;

    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY1;
 8034918:	2313      	movs	r3, #19
    Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay2 = phyParam.Value;
 803491a:	f8c4 05a0 	str.w	r0, [r4, #1440]	; 0x5a0
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803491e:	a905      	add	r1, sp, #20
 8034920:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY1;
 8034924:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034928:	f001 fef9 	bl	803671e <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay1 = phyParam.Value;

    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY2;
 803492c:	2314      	movs	r3, #20
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803492e:	eb0d 0103 	add.w	r1, sp, r3
    Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay1 = phyParam.Value;
 8034932:	f8c4 05a4 	str.w	r0, [r4, #1444]	; 0x5a4
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034936:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY2;
 803493a:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803493e:	f001 feee 	bl	803671e <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay2 = phyParam.Value;

    getPhy.Attribute = PHY_DEF_DR1_OFFSET;
 8034942:	2317      	movs	r3, #23
    Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay2 = phyParam.Value;
 8034944:	f8c4 05a8 	str.w	r0, [r4, #1448]	; 0x5a8
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034948:	a905      	add	r1, sp, #20
 803494a:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_DR1_OFFSET;
 803494e:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034952:	f001 fee4 	bl	803671e <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.Rx1DrOffset = phyParam.Value;

    getPhy.Attribute = PHY_DEF_RX2_FREQUENCY;
 8034956:	2318      	movs	r3, #24
    Nvm.MacGroup2.MacParamsDefaults.Rx1DrOffset = phyParam.Value;
 8034958:	f884 05ad 	strb.w	r0, [r4, #1453]	; 0x5ad
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803495c:	a905      	add	r1, sp, #20
 803495e:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_RX2_FREQUENCY;
 8034962:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034966:	f001 feda 	bl	803671e <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.Rx2Channel.Frequency = phyParam.Value;
    Nvm.MacGroup2.MacParamsDefaults.RxCChannel.Frequency = phyParam.Value;

    getPhy.Attribute = PHY_DEF_RX2_DR;
 803496a:	2319      	movs	r3, #25
    Nvm.MacGroup2.MacParamsDefaults.Rx2Channel.Frequency = phyParam.Value;
 803496c:	f8c4 05b0 	str.w	r0, [r4, #1456]	; 0x5b0
    Nvm.MacGroup2.MacParamsDefaults.RxCChannel.Frequency = phyParam.Value;
 8034970:	f8c4 05b8 	str.w	r0, [r4, #1464]	; 0x5b8
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034974:	a905      	add	r1, sp, #20
 8034976:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_RX2_DR;
 803497a:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803497e:	f001 fece 	bl	803671e <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.Rx2Channel.Datarate = phyParam.Value;
 8034982:	b2c0      	uxtb	r0, r0
    Nvm.MacGroup2.MacParamsDefaults.RxCChannel.Datarate = phyParam.Value;

    getPhy.Attribute = PHY_DEF_UPLINK_DWELL_TIME;
 8034984:	231e      	movs	r3, #30
    Nvm.MacGroup2.MacParamsDefaults.Rx2Channel.Datarate = phyParam.Value;
 8034986:	f884 05b4 	strb.w	r0, [r4, #1460]	; 0x5b4
    Nvm.MacGroup2.MacParamsDefaults.RxCChannel.Datarate = phyParam.Value;
 803498a:	f884 05bc 	strb.w	r0, [r4, #1468]	; 0x5bc
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803498e:	a905      	add	r1, sp, #20
 8034990:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_UPLINK_DWELL_TIME;
 8034994:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034998:	f001 fec1 	bl	803671e <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.UplinkDwellTime = phyParam.Value;

    getPhy.Attribute = PHY_DEF_DOWNLINK_DWELL_TIME;
 803499c:	231f      	movs	r3, #31
    Nvm.MacGroup2.MacParamsDefaults.UplinkDwellTime = phyParam.Value;
 803499e:	f884 05c0 	strb.w	r0, [r4, #1472]	; 0x5c0
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80349a2:	a905      	add	r1, sp, #20
 80349a4:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_DOWNLINK_DWELL_TIME;
 80349a8:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80349ac:	f001 feb7 	bl	803671e <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.DownlinkDwellTime = phyParam.Value;

    getPhy.Attribute = PHY_DEF_MAX_EIRP;
 80349b0:	2320      	movs	r3, #32
    Nvm.MacGroup2.MacParamsDefaults.DownlinkDwellTime = phyParam.Value;
 80349b2:	f884 05c1 	strb.w	r0, [r4, #1473]	; 0x5c1
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80349b6:	a905      	add	r1, sp, #20
 80349b8:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_MAX_EIRP;
 80349bc:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80349c0:	f001 fead 	bl	803671e <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.MaxEirp = phyParam.fValue;

    getPhy.Attribute = PHY_DEF_ANTENNA_GAIN;
 80349c4:	2321      	movs	r3, #33	; 0x21
    Nvm.MacGroup2.MacParamsDefaults.MaxEirp = phyParam.fValue;
 80349c6:	f8c4 05c4 	str.w	r0, [r4, #1476]	; 0x5c4
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80349ca:	a905      	add	r1, sp, #20
 80349cc:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_ANTENNA_GAIN;
 80349d0:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80349d4:	f001 fea3 	bl	803671e <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.AntennaGain = phyParam.fValue;

    getPhy.Attribute = PHY_DEF_ADR_ACK_LIMIT;
 80349d8:	230b      	movs	r3, #11
    Nvm.MacGroup2.MacParamsDefaults.AntennaGain = phyParam.fValue;
 80349da:	f8c4 05c8 	str.w	r0, [r4, #1480]	; 0x5c8
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80349de:	a905      	add	r1, sp, #20
 80349e0:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_ADR_ACK_LIMIT;
 80349e4:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80349e8:	f001 fe99 	bl	803671e <RegionGetPhyParam>
    MacCtx.AdrAckLimit = phyParam.Value;

    getPhy.Attribute = PHY_DEF_ADR_ACK_DELAY;
 80349ec:	230c      	movs	r3, #12
    MacCtx.AdrAckLimit = phyParam.Value;
 80349ee:	f8a4 03f8 	strh.w	r0, [r4, #1016]	; 0x3f8
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80349f2:	a905      	add	r1, sp, #20
 80349f4:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_ADR_ACK_DELAY;
 80349f8:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80349fc:	f001 fe8f 	bl	803671e <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError = 10;
    Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols = 6;

    Nvm.MacGroup2.MacParams.SystemMaxRxError = Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError;
    Nvm.MacGroup2.MacParams.MinRxSymbols = Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols;
    Nvm.MacGroup2.MacParams.MaxRxWindow = Nvm.MacGroup2.MacParamsDefaults.MaxRxWindow;
 8034a00:	f8d4 3598 	ldr.w	r3, [r4, #1432]	; 0x598
 8034a04:	f8c4 3558 	str.w	r3, [r4, #1368]	; 0x558
    Nvm.MacGroup2.MacParams.ReceiveDelay1 = Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay1;
 8034a08:	f8d4 359c 	ldr.w	r3, [r4, #1436]	; 0x59c
 8034a0c:	f8c4 355c 	str.w	r3, [r4, #1372]	; 0x55c
    Nvm.MacGroup2.MacParams.ReceiveDelay2 = Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay2;
 8034a10:	f8d4 35a0 	ldr.w	r3, [r4, #1440]	; 0x5a0
 8034a14:	f8c4 3560 	str.w	r3, [r4, #1376]	; 0x560
    Nvm.MacGroup2.MacParams.JoinAcceptDelay1 = Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay1;
 8034a18:	f8d4 35a4 	ldr.w	r3, [r4, #1444]	; 0x5a4
 8034a1c:	f8c4 3564 	str.w	r3, [r4, #1380]	; 0x564
    Nvm.MacGroup2.MacParams.JoinAcceptDelay2 = Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay2;
 8034a20:	f8d4 35a8 	ldr.w	r3, [r4, #1448]	; 0x5a8
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034a24:	9004      	str	r0, [sp, #16]

    InitDefaultsParams_t params;
    params.Type = INIT_TYPE_DEFAULTS;
    params.NvmGroup1 = &Nvm.RegionGroup1;
    params.NvmGroup2 = &Nvm.RegionGroup2;
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 8034a26:	a907      	add	r1, sp, #28
    MacCtx.AdrAckDelay = phyParam.Value;
 8034a28:	f8a4 03fa 	strh.w	r0, [r4, #1018]	; 0x3fa
    Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols = 6;
 8034a2c:	f884 9594 	strb.w	r9, [r4, #1428]	; 0x594
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 8034a30:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    Nvm.MacGroup2.MacParams.MinRxSymbols = Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols;
 8034a34:	f884 9554 	strb.w	r9, [r4, #1364]	; 0x554
    Nvm.MacGroup2.MacParams.JoinAcceptDelay2 = Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay2;
 8034a38:	f8c4 3568 	str.w	r3, [r4, #1384]	; 0x568
    params.NvmGroup1 = &Nvm.RegionGroup1;
 8034a3c:	f504 69e5 	add.w	r9, r4, #1832	; 0x728
    params.NvmGroup2 = &Nvm.RegionGroup2;
 8034a40:	f204 73cc 	addw	r3, r4, #1996	; 0x7cc
 8034a44:	9308      	str	r3, [sp, #32]
    params.Type = INIT_TYPE_DEFAULTS;
 8034a46:	f88d 5024 	strb.w	r5, [sp, #36]	; 0x24
    Nvm.MacGroup2.MacParamsDefaults.ChannelsNbTrans = 1;
 8034a4a:	f884 75ac 	strb.w	r7, [r4, #1452]	; 0x5ac
    Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError = 10;
 8034a4e:	f8c4 a590 	str.w	sl, [r4, #1424]	; 0x590
    Nvm.MacGroup2.MacParams.SystemMaxRxError = Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError;
 8034a52:	f8c4 a550 	str.w	sl, [r4, #1360]	; 0x550
    Nvm.MacGroup2.MacParams.ChannelsNbTrans = Nvm.MacGroup2.MacParamsDefaults.ChannelsNbTrans;
 8034a56:	f884 756c 	strb.w	r7, [r4, #1388]	; 0x56c
    params.NvmGroup1 = &Nvm.RegionGroup1;
 8034a5a:	f8cd 901c 	str.w	r9, [sp, #28]
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 8034a5e:	f001 fe79 	bl	8036754 <RegionInitDefaults>

    MacCtx.MacCallbacks = callbacks;
 8034a62:	f8c4 834c 	str.w	r8, [r4, #844]	; 0x34c
    ResetMacParameters( );
 8034a66:	f7fe fc1b 	bl	80332a0 <ResetMacParameters>
    // Reset duty cycle times
    Nvm.MacGroup1.LastTxDoneTime = 0;
    Nvm.MacGroup1.AggregatedTimeOff = 0;

    // Initialize timers
    TimerInit( &MacCtx.TxDelayedTimer, OnTxDelayedTimerEvent );
 8034a6a:	462a      	mov	r2, r5
 8034a6c:	4b3f      	ldr	r3, [pc, #252]	; (8034b6c <LoRaMacInitialization+0x354>)
 8034a6e:	9500      	str	r5, [sp, #0]
 8034a70:	f04f 31ff 	mov.w	r1, #4294967295
 8034a74:	f504 705b 	add.w	r0, r4, #876	; 0x36c
    MacCtx.MacPrimitives = primitives;
 8034a78:	f8c4 6348 	str.w	r6, [r4, #840]	; 0x348
    MacCtx.MacFlags.Value = 0;
 8034a7c:	f884 5485 	strb.w	r5, [r4, #1157]	; 0x485
    Nvm.MacGroup1.LastTxDoneTime = 0;
 8034a80:	f8c4 5538 	str.w	r5, [r4, #1336]	; 0x538
    Nvm.MacGroup1.AggregatedTimeOff = 0;
 8034a84:	f8c4 553c 	str.w	r5, [r4, #1340]	; 0x53c
    Nvm.MacGroup2.PublicNetwork = true;
 8034a88:	f884 7609 	strb.w	r7, [r4, #1545]	; 0x609
    MacCtx.MacState = LORAMAC_STOPPED;
 8034a8c:	f8c4 7344 	str.w	r7, [r4, #836]	; 0x344
    TimerInit( &MacCtx.TxDelayedTimer, OnTxDelayedTimerEvent );
 8034a90:	f006 fbf6 	bl	803b280 <UTIL_TIMER_Create>
    TimerInit( &MacCtx.RxWindowTimer1, OnRxWindow1TimerEvent );
 8034a94:	462a      	mov	r2, r5
 8034a96:	4b36      	ldr	r3, [pc, #216]	; (8034b70 <LoRaMacInitialization+0x358>)
 8034a98:	9500      	str	r5, [sp, #0]
 8034a9a:	f04f 31ff 	mov.w	r1, #4294967295
 8034a9e:	f504 7061 	add.w	r0, r4, #900	; 0x384
 8034aa2:	f006 fbed 	bl	803b280 <UTIL_TIMER_Create>
    TimerInit( &MacCtx.RxWindowTimer2, OnRxWindow2TimerEvent );
 8034aa6:	462a      	mov	r2, r5
 8034aa8:	4b32      	ldr	r3, [pc, #200]	; (8034b74 <LoRaMacInitialization+0x35c>)
 8034aaa:	9500      	str	r5, [sp, #0]
 8034aac:	f04f 31ff 	mov.w	r1, #4294967295
 8034ab0:	f504 7067 	add.w	r0, r4, #924	; 0x39c
 8034ab4:	f006 fbe4 	bl	803b280 <UTIL_TIMER_Create>
    TimerInit( &MacCtx.AckTimeoutTimer, OnAckTimeoutTimerEvent );
 8034ab8:	462a      	mov	r2, r5
 8034aba:	4b2f      	ldr	r3, [pc, #188]	; (8034b78 <LoRaMacInitialization+0x360>)
 8034abc:	9500      	str	r5, [sp, #0]
 8034abe:	f04f 31ff 	mov.w	r1, #4294967295

    // Store the current initialization time
    Nvm.MacGroup2.InitializationTime = SysTimeGetMcuTime( );
 8034ac2:	ad02      	add	r5, sp, #8
    TimerInit( &MacCtx.AckTimeoutTimer, OnAckTimeoutTimerEvent );
 8034ac4:	f504 707f 	add.w	r0, r4, #1020	; 0x3fc
 8034ac8:	f006 fbda 	bl	803b280 <UTIL_TIMER_Create>
    Nvm.MacGroup2.InitializationTime = SysTimeGetMcuTime( );
 8034acc:	4628      	mov	r0, r5
 8034ace:	f006 fb6d 	bl	803b1ac <SysTimeGetMcuTime>
 8034ad2:	e895 0003 	ldmia.w	r5, {r0, r1}
 8034ad6:	f504 63c2 	add.w	r3, r4, #1552	; 0x610
 8034ada:	e883 0003 	stmia.w	r3, {r0, r1}

    // Initialize Radio driver
    MacCtx.RadioEvents.TxDone = OnRadioTxDone;
 8034ade:	4b27      	ldr	r3, [pc, #156]	; (8034b7c <LoRaMacInitialization+0x364>)
 8034ae0:	f8c4 3350 	str.w	r3, [r4, #848]	; 0x350
    MacCtx.RadioEvents.RxDone = OnRadioRxDone;
 8034ae4:	4b26      	ldr	r3, [pc, #152]	; (8034b80 <LoRaMacInitialization+0x368>)
 8034ae6:	f8c4 3358 	str.w	r3, [r4, #856]	; 0x358
    MacCtx.RadioEvents.RxError = OnRadioRxError;
 8034aea:	4b26      	ldr	r3, [pc, #152]	; (8034b84 <LoRaMacInitialization+0x36c>)
 8034aec:	f8c4 3360 	str.w	r3, [r4, #864]	; 0x360
    MacCtx.RadioEvents.TxTimeout = OnRadioTxTimeout;
    MacCtx.RadioEvents.RxTimeout = OnRadioRxTimeout;
    Radio.Init( &MacCtx.RadioEvents );
 8034af0:	4e25      	ldr	r6, [pc, #148]	; (8034b88 <LoRaMacInitialization+0x370>)
    MacCtx.RadioEvents.TxTimeout = OnRadioTxTimeout;
 8034af2:	4b26      	ldr	r3, [pc, #152]	; (8034b8c <LoRaMacInitialization+0x374>)
 8034af4:	f8c4 3354 	str.w	r3, [r4, #852]	; 0x354
    MacCtx.RadioEvents.RxTimeout = OnRadioRxTimeout;
 8034af8:	4b25      	ldr	r3, [pc, #148]	; (8034b90 <LoRaMacInitialization+0x378>)
 8034afa:	f8c4 335c 	str.w	r3, [r4, #860]	; 0x35c
    Radio.Init( &MacCtx.RadioEvents );
 8034afe:	f504 7054 	add.w	r0, r4, #848	; 0x350
 8034b02:	6833      	ldr	r3, [r6, #0]
 8034b04:	4798      	blx	r3

    // Initialize the Secure Element driver
    if( SecureElementInit( &Nvm.SecureElement, callbacks->GetUniqueId ) != SECURE_ELEMENT_SUCCESS ) /* ST_WORKAROUND: Add unique ID callback as input parameter */
 8034b06:	f8d8 1008 	ldr.w	r1, [r8, #8]
 8034b0a:	f204 6024 	addw	r0, r4, #1572	; 0x624
 8034b0e:	f003 feeb 	bl	80388e8 <SecureElementInit>
 8034b12:	b120      	cbz	r0, 8034b1e <LoRaMacInitialization+0x306>
    {
        return LORAMAC_STATUS_CRYPTO_ERROR;
 8034b14:	2511      	movs	r5, #17
    Radio.Sleep( );

    LoRaMacEnableRequests( LORAMAC_REQUEST_HANDLING_ON );

    return LORAMAC_STATUS_OK;
}
 8034b16:	4628      	mov	r0, r5
 8034b18:	b00a      	add	sp, #40	; 0x28
 8034b1a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if( LoRaMacCryptoInit( &Nvm.Crypto ) != LORAMAC_CRYPTO_SUCCESS )
 8034b1e:	f5a9 7007 	sub.w	r0, r9, #540	; 0x21c
 8034b22:	f001 fa49 	bl	8035fb8 <LoRaMacCryptoInit>
 8034b26:	2800      	cmp	r0, #0
 8034b28:	d1f4      	bne.n	8034b14 <LoRaMacInitialization+0x2fc>
    if( LoRaMacCommandsInit( ) != LORAMAC_COMMANDS_SUCCESS )
 8034b2a:	f000 ff5d 	bl	80359e8 <LoRaMacCommandsInit>
 8034b2e:	b9b8      	cbnz	r0, 8034b60 <LoRaMacInitialization+0x348>
    if( LoRaMacCryptoSetMulticastReference( Nvm.MacGroup2.MulticastChannelList ) != LORAMAC_CRYPTO_SUCCESS )
 8034b30:	4818      	ldr	r0, [pc, #96]	; (8034b94 <LoRaMacInitialization+0x37c>)
 8034b32:	f001 faa7 	bl	8036084 <LoRaMacCryptoSetMulticastReference>
 8034b36:	4605      	mov	r5, r0
 8034b38:	2800      	cmp	r0, #0
 8034b3a:	d1eb      	bne.n	8034b14 <LoRaMacInitialization+0x2fc>
    srand1( Radio.Random( ) );
 8034b3c:	6973      	ldr	r3, [r6, #20]
 8034b3e:	4798      	blx	r3
 8034b40:	f004 f9d2 	bl	8038ee8 <srand1>
    Radio.SetPublicNetwork( Nvm.MacGroup2.PublicNetwork );
 8034b44:	6db3      	ldr	r3, [r6, #88]	; 0x58
 8034b46:	f894 0609 	ldrb.w	r0, [r4, #1545]	; 0x609
 8034b4a:	4798      	blx	r3
    Radio.Sleep( );
 8034b4c:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8034b4e:	4798      	blx	r3
    MacCtx.AllowRequests = requestState;
 8034b50:	2301      	movs	r3, #1
 8034b52:	f884 3486 	strb.w	r3, [r4, #1158]	; 0x486
    return LORAMAC_STATUS_OK;
 8034b56:	e7de      	b.n	8034b16 <LoRaMacInitialization+0x2fe>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 8034b58:	2503      	movs	r5, #3
 8034b5a:	e7dc      	b.n	8034b16 <LoRaMacInitialization+0x2fe>
        return LORAMAC_STATUS_REGION_NOT_SUPPORTED;
 8034b5c:	2509      	movs	r5, #9
 8034b5e:	e7da      	b.n	8034b16 <LoRaMacInitialization+0x2fe>
        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 8034b60:	2513      	movs	r5, #19
 8034b62:	e7d8      	b.n	8034b16 <LoRaMacInitialization+0x2fe>
 8034b64:	20004aa4 	.word	0x20004aa4
 8034b68:	01000300 	.word	0x01000300
 8034b6c:	080336bd 	.word	0x080336bd
 8034b70:	0803385d 	.word	0x0803385d
 8034b74:	08033895 	.word	0x08033895
 8034b78:	0803305d 	.word	0x0803305d
 8034b7c:	0803324d 	.word	0x0803324d
 8034b80:	080331fd 	.word	0x080331fd
 8034b84:	08032fad 	.word	0x08032fad
 8034b88:	0803bc30 	.word	0x0803bc30
 8034b8c:	080331cd 	.word	0x080331cd
 8034b90:	0803319d 	.word	0x0803319d
 8034b94:	20005080 	.word	0x20005080

08034b98 <LoRaMacStart>:

LoRaMacStatus_t LoRaMacStart( void )
{
    MacCtx.MacState = LORAMAC_IDLE;
 8034b98:	4b02      	ldr	r3, [pc, #8]	; (8034ba4 <LoRaMacStart+0xc>)
 8034b9a:	2000      	movs	r0, #0
 8034b9c:	f8c3 0344 	str.w	r0, [r3, #836]	; 0x344
    return LORAMAC_STATUS_OK;
}
 8034ba0:	4770      	bx	lr
 8034ba2:	bf00      	nop
 8034ba4:	20004aa4 	.word	0x20004aa4

08034ba8 <LoRaMacQueryTxPossible>:
    }
    return LORAMAC_STATUS_BUSY;
}

LoRaMacStatus_t LoRaMacQueryTxPossible( uint8_t size, LoRaMacTxInfo_t* txInfo )
{
 8034ba8:	b530      	push	{r4, r5, lr}
    CalcNextAdrParams_t adrNext;
    uint32_t adrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 8034baa:	4b2a      	ldr	r3, [pc, #168]	; (8034c54 <LoRaMacQueryTxPossible+0xac>)
{
 8034bac:	b089      	sub	sp, #36	; 0x24
 8034bae:	4605      	mov	r5, r0
    int8_t datarate = Nvm.MacGroup2.ChannelsDatarateDefault;
 8034bb0:	f893 05d1 	ldrb.w	r0, [r3, #1489]	; 0x5d1
 8034bb4:	f88d 0002 	strb.w	r0, [sp, #2]
    int8_t txPower = Nvm.MacGroup2.ChannelsTxPowerDefault;
 8034bb8:	f893 05d0 	ldrb.w	r0, [r3, #1488]	; 0x5d0
    uint32_t adrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 8034bbc:	f8d3 2534 	ldr.w	r2, [r3, #1332]	; 0x534
    int8_t txPower = Nvm.MacGroup2.ChannelsTxPowerDefault;
 8034bc0:	f88d 0003 	strb.w	r0, [sp, #3]
    size_t macCmdsSize = 0;
 8034bc4:	2000      	movs	r0, #0
    uint32_t adrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 8034bc6:	9201      	str	r2, [sp, #4]
    size_t macCmdsSize = 0;
 8034bc8:	9002      	str	r0, [sp, #8]

    if( txInfo == NULL )
 8034bca:	460c      	mov	r4, r1
 8034bcc:	2900      	cmp	r1, #0
 8034bce:	d03c      	beq.n	8034c4a <LoRaMacQueryTxPossible+0xa2>

    // Setup ADR request
    adrNext.Version = Nvm.MacGroup2.Version;
    adrNext.UpdateChanMask = false;
    adrNext.AdrEnabled = Nvm.MacGroup2.AdrCtrlOn;
    adrNext.AdrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 8034bd0:	9205      	str	r2, [sp, #20]
    adrNext.AdrAckLimit = MacCtx.AdrAckLimit;
 8034bd2:	f8d3 23f8 	ldr.w	r2, [r3, #1016]	; 0x3f8
 8034bd6:	9206      	str	r2, [sp, #24]
    adrNext.AdrAckDelay = MacCtx.AdrAckDelay;
    adrNext.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 8034bd8:	f8b3 2544 	ldrh.w	r2, [r3, #1348]	; 0x544
    adrNext.Version = Nvm.MacGroup2.Version;
 8034bdc:	f8d3 1618 	ldr.w	r1, [r3, #1560]	; 0x618
 8034be0:	9103      	str	r1, [sp, #12]
    adrNext.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 8034be2:	ba52      	rev16	r2, r2
    adrNext.AdrEnabled = Nvm.MacGroup2.AdrCtrlOn;
 8034be4:	f893 160a 	ldrb.w	r1, [r3, #1546]	; 0x60a
    adrNext.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 8034be8:	f8ad 201c 	strh.w	r2, [sp, #28]
    adrNext.TxPower = Nvm.MacGroup1.ChannelsTxPower;
    adrNext.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8034bec:	f893 2580 	ldrb.w	r2, [r3, #1408]	; 0x580
    adrNext.Region = Nvm.MacGroup2.Region;
 8034bf0:	f893 354c 	ldrb.w	r3, [r3, #1356]	; 0x54c
    adrNext.UpdateChanMask = false;
 8034bf4:	f88d 0010 	strb.w	r0, [sp, #16]
    adrNext.AdrEnabled = Nvm.MacGroup2.AdrCtrlOn;
 8034bf8:	f88d 1011 	strb.w	r1, [sp, #17]
    adrNext.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8034bfc:	f88d 201e 	strb.w	r2, [sp, #30]
    adrNext.Region = Nvm.MacGroup2.Region;
 8034c00:	f88d 301f 	strb.w	r3, [sp, #31]

    // We call the function for information purposes only. We don't want to
    // apply the datarate, the tx power and the ADR ack counter.
    LoRaMacAdrCalcNext( &adrNext, &datarate, &txPower, &adrAckCounter );
 8034c04:	f10d 0203 	add.w	r2, sp, #3
 8034c08:	ab01      	add	r3, sp, #4
 8034c0a:	f10d 0102 	add.w	r1, sp, #2
 8034c0e:	a803      	add	r0, sp, #12
 8034c10:	f000 fe54 	bl	80358bc <LoRaMacAdrCalcNext>

    txInfo->CurrentPossiblePayloadSize = GetMaxAppPayloadWithoutFOptsLength( datarate );
 8034c14:	f99d 0002 	ldrsb.w	r0, [sp, #2]
 8034c18:	f7fe fa04 	bl	8033024 <GetMaxAppPayloadWithoutFOptsLength>
 8034c1c:	7060      	strb	r0, [r4, #1]

    if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )
 8034c1e:	a802      	add	r0, sp, #8
 8034c20:	f000 ff8a 	bl	8035b38 <LoRaMacCommandsGetSizeSerializedCmds>
 8034c24:	b998      	cbnz	r0, 8034c4e <LoRaMacQueryTxPossible+0xa6>
    {
        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
    }

    // Verify if the MAC commands fit into the FOpts and into the maximum payload.
    if( ( LORA_MAC_COMMAND_MAX_FOPTS_LENGTH >= macCmdsSize ) && ( txInfo->CurrentPossiblePayloadSize >= macCmdsSize ) )
 8034c26:	9b02      	ldr	r3, [sp, #8]
 8034c28:	2b0f      	cmp	r3, #15
 8034c2a:	d80a      	bhi.n	8034c42 <LoRaMacQueryTxPossible+0x9a>
 8034c2c:	7862      	ldrb	r2, [r4, #1]
 8034c2e:	4293      	cmp	r3, r2
 8034c30:	d807      	bhi.n	8034c42 <LoRaMacQueryTxPossible+0x9a>
    {
        txInfo->MaxPossibleApplicationDataSize = txInfo->CurrentPossiblePayloadSize - macCmdsSize;
 8034c32:	1ad1      	subs	r1, r2, r3

        // Verify if the application data together with MAC command fit into the maximum payload.
        if( txInfo->CurrentPossiblePayloadSize >= ( macCmdsSize + size ) )
 8034c34:	441d      	add	r5, r3
        txInfo->MaxPossibleApplicationDataSize = txInfo->CurrentPossiblePayloadSize - macCmdsSize;
 8034c36:	7021      	strb	r1, [r4, #0]
        {
            return LORAMAC_STATUS_OK;
        }
        else
        {
           return LORAMAC_STATUS_LENGTH_ERROR;
 8034c38:	42aa      	cmp	r2, r5
 8034c3a:	bf38      	it	cc
 8034c3c:	2008      	movcc	r0, #8
    else
    {
        txInfo->MaxPossibleApplicationDataSize = 0;
        return LORAMAC_STATUS_LENGTH_ERROR;
    }
}
 8034c3e:	b009      	add	sp, #36	; 0x24
 8034c40:	bd30      	pop	{r4, r5, pc}
        txInfo->MaxPossibleApplicationDataSize = 0;
 8034c42:	2300      	movs	r3, #0
 8034c44:	7023      	strb	r3, [r4, #0]
        return LORAMAC_STATUS_LENGTH_ERROR;
 8034c46:	2008      	movs	r0, #8
 8034c48:	e7f9      	b.n	8034c3e <LoRaMacQueryTxPossible+0x96>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 8034c4a:	2003      	movs	r0, #3
 8034c4c:	e7f7      	b.n	8034c3e <LoRaMacQueryTxPossible+0x96>
        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 8034c4e:	2013      	movs	r0, #19
 8034c50:	e7f5      	b.n	8034c3e <LoRaMacQueryTxPossible+0x96>
 8034c52:	bf00      	nop
 8034c54:	20004aa4 	.word	0x20004aa4

08034c58 <LoRaMacMibGetRequestConfirm>:

LoRaMacStatus_t LoRaMacMibGetRequestConfirm( MibRequestConfirm_t* mibGet )
{
 8034c58:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;

    if( mibGet == NULL )
 8034c5a:	4604      	mov	r4, r0
 8034c5c:	2800      	cmp	r0, #0
 8034c5e:	f000 80a8 	beq.w	8034db2 <LoRaMacMibGetRequestConfirm+0x15a>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }

    switch( mibGet->Type )
 8034c62:	7800      	ldrb	r0, [r0, #0]
 8034c64:	2828      	cmp	r0, #40	; 0x28
 8034c66:	f200 80a0 	bhi.w	8034daa <LoRaMacMibGetRequestConfirm+0x152>
 8034c6a:	e8df f000 	tbb	[pc, r0]
 8034c6e:	1b15      	.short	0x1b15
 8034c70:	2c282520 	.word	0x2c282520
 8034c74:	9e9e9e31 	.word	0x9e9e9e31
 8034c78:	9e9e9e9e 	.word	0x9e9e9e9e
 8034c7c:	3d39359e 	.word	0x3d39359e
 8034c80:	54514e47 	.word	0x54514e47
 8034c84:	5f5b5759 	.word	0x5f5b5759
 8034c88:	6f6b6763 	.word	0x6f6b6763
 8034c8c:	7b7f7773 	.word	0x7b7f7773
 8034c90:	928b8783 	.word	0x928b8783
 8034c94:	9e90      	.short	0x9e90
 8034c96:	96          	.byte	0x96
 8034c97:	00          	.byte	0x00
    {
        case MIB_DEVICE_CLASS:
        {
            mibGet->Param.Class = Nvm.MacGroup2.DeviceClass;
 8034c98:	4b47      	ldr	r3, [pc, #284]	; (8034db8 <LoRaMacMibGetRequestConfirm+0x160>)
 8034c9a:	f893 3608 	ldrb.w	r3, [r3, #1544]	; 0x608
 8034c9e:	7123      	strb	r3, [r4, #4]
            status = LoRaMacClassBMibGetRequestConfirm( mibGet );
            break;
        }
    }
    return status;
}
 8034ca0:	b004      	add	sp, #16
 8034ca2:	bd10      	pop	{r4, pc}
            mibGet->Param.NetworkActivation = Nvm.MacGroup2.NetworkActivation;
 8034ca4:	4b44      	ldr	r3, [pc, #272]	; (8034db8 <LoRaMacMibGetRequestConfirm+0x160>)
 8034ca6:	f893 361c 	ldrb.w	r3, [r3, #1564]	; 0x61c
            mibGet->Param.AdrEnable = Nvm.MacGroup2.AdrCtrlOn;
 8034caa:	7123      	strb	r3, [r4, #4]
            break;
 8034cac:	e002      	b.n	8034cb4 <LoRaMacMibGetRequestConfirm+0x5c>
            mibGet->Param.DevEui = SecureElementGetDevEui( );
 8034cae:	f004 f8ff 	bl	8038eb0 <SecureElementGetDevEui>
            mibGet->Param.JoinEui = SecureElementGetJoinEui( );
 8034cb2:	6060      	str	r0, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 8034cb4:	2000      	movs	r0, #0
            break;
 8034cb6:	e7f3      	b.n	8034ca0 <LoRaMacMibGetRequestConfirm+0x48>
            mibGet->Param.JoinEui = SecureElementGetJoinEui( );
 8034cb8:	f004 f910 	bl	8038edc <SecureElementGetJoinEui>
 8034cbc:	e7f9      	b.n	8034cb2 <LoRaMacMibGetRequestConfirm+0x5a>
            mibGet->Param.AdrEnable = Nvm.MacGroup2.AdrCtrlOn;
 8034cbe:	4b3e      	ldr	r3, [pc, #248]	; (8034db8 <LoRaMacMibGetRequestConfirm+0x160>)
 8034cc0:	f893 360a 	ldrb.w	r3, [r3, #1546]	; 0x60a
 8034cc4:	e7f1      	b.n	8034caa <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.NetID = Nvm.MacGroup2.NetID;
 8034cc6:	4b3c      	ldr	r3, [pc, #240]	; (8034db8 <LoRaMacMibGetRequestConfirm+0x160>)
 8034cc8:	f8d3 35d4 	ldr.w	r3, [r3, #1492]	; 0x5d4
            mibGet->Param.Contexts = GetNvmData( );
 8034ccc:	6063      	str	r3, [r4, #4]
            break;
 8034cce:	e7f1      	b.n	8034cb4 <LoRaMacMibGetRequestConfirm+0x5c>
            mibGet->Param.DevAddr = Nvm.MacGroup2.DevAddr;
 8034cd0:	4b39      	ldr	r3, [pc, #228]	; (8034db8 <LoRaMacMibGetRequestConfirm+0x160>)
 8034cd2:	f8d3 35d8 	ldr.w	r3, [r3, #1496]	; 0x5d8
 8034cd6:	e7f9      	b.n	8034ccc <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.EnablePublicNetwork = Nvm.MacGroup2.PublicNetwork;
 8034cd8:	4b37      	ldr	r3, [pc, #220]	; (8034db8 <LoRaMacMibGetRequestConfirm+0x160>)
 8034cda:	f893 3609 	ldrb.w	r3, [r3, #1545]	; 0x609
 8034cde:	e7e4      	b.n	8034caa <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.EnableRepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport;
 8034ce0:	4b35      	ldr	r3, [pc, #212]	; (8034db8 <LoRaMacMibGetRequestConfirm+0x160>)
 8034ce2:	f893 358c 	ldrb.w	r3, [r3, #1420]	; 0x58c
 8034ce6:	e7e0      	b.n	8034caa <LoRaMacMibGetRequestConfirm+0x52>
            getPhy.Attribute = PHY_CHANNELS;
 8034ce8:	231d      	movs	r3, #29
            getPhy.Attribute = PHY_CHANNELS_MASK;
 8034cea:	f88d 3008 	strb.w	r3, [sp, #8]
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034cee:	4b32      	ldr	r3, [pc, #200]	; (8034db8 <LoRaMacMibGetRequestConfirm+0x160>)
 8034cf0:	a902      	add	r1, sp, #8
 8034cf2:	f893 054c 	ldrb.w	r0, [r3, #1356]	; 0x54c
 8034cf6:	f001 fd12 	bl	803671e <RegionGetPhyParam>
 8034cfa:	e7da      	b.n	8034cb2 <LoRaMacMibGetRequestConfirm+0x5a>
            mibGet->Param.Rx2Channel = Nvm.MacGroup2.MacParams.Rx2Channel;
 8034cfc:	4b2f      	ldr	r3, [pc, #188]	; (8034dbc <LoRaMacMibGetRequestConfirm+0x164>)
 8034cfe:	3404      	adds	r4, #4
            mibGet->Param.RxCChannel = Nvm.MacGroup2.MacParamsDefaults.RxCChannel;
 8034d00:	e893 0003 	ldmia.w	r3, {r0, r1}
 8034d04:	e884 0003 	stmia.w	r4, {r0, r1}
            break;
 8034d08:	e7d4      	b.n	8034cb4 <LoRaMacMibGetRequestConfirm+0x5c>
            mibGet->Param.Rx2Channel = Nvm.MacGroup2.MacParamsDefaults.Rx2Channel;
 8034d0a:	4b2d      	ldr	r3, [pc, #180]	; (8034dc0 <LoRaMacMibGetRequestConfirm+0x168>)
 8034d0c:	3404      	adds	r4, #4
 8034d0e:	e7f7      	b.n	8034d00 <LoRaMacMibGetRequestConfirm+0xa8>
            mibGet->Param.RxCChannel = Nvm.MacGroup2.MacParams.RxCChannel;
 8034d10:	4b2c      	ldr	r3, [pc, #176]	; (8034dc4 <LoRaMacMibGetRequestConfirm+0x16c>)
 8034d12:	3404      	adds	r4, #4
 8034d14:	e7f4      	b.n	8034d00 <LoRaMacMibGetRequestConfirm+0xa8>
            mibGet->Param.RxCChannel = Nvm.MacGroup2.MacParamsDefaults.RxCChannel;
 8034d16:	4b2c      	ldr	r3, [pc, #176]	; (8034dc8 <LoRaMacMibGetRequestConfirm+0x170>)
 8034d18:	3404      	adds	r4, #4
 8034d1a:	e7f1      	b.n	8034d00 <LoRaMacMibGetRequestConfirm+0xa8>
            getPhy.Attribute = PHY_CHANNELS_DEFAULT_MASK;
 8034d1c:	231b      	movs	r3, #27
 8034d1e:	e7e4      	b.n	8034cea <LoRaMacMibGetRequestConfirm+0x92>
            getPhy.Attribute = PHY_CHANNELS_MASK;
 8034d20:	231a      	movs	r3, #26
 8034d22:	e7e2      	b.n	8034cea <LoRaMacMibGetRequestConfirm+0x92>
            mibGet->Param.ChannelsNbTrans = Nvm.MacGroup2.MacParams.ChannelsNbTrans;
 8034d24:	4b24      	ldr	r3, [pc, #144]	; (8034db8 <LoRaMacMibGetRequestConfirm+0x160>)
 8034d26:	f893 356c 	ldrb.w	r3, [r3, #1388]	; 0x56c
 8034d2a:	e7be      	b.n	8034caa <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.MaxRxWindow = Nvm.MacGroup2.MacParams.MaxRxWindow;
 8034d2c:	4b22      	ldr	r3, [pc, #136]	; (8034db8 <LoRaMacMibGetRequestConfirm+0x160>)
 8034d2e:	f8d3 3558 	ldr.w	r3, [r3, #1368]	; 0x558
 8034d32:	e7cb      	b.n	8034ccc <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.ReceiveDelay1 = Nvm.MacGroup2.MacParams.ReceiveDelay1;
 8034d34:	4b20      	ldr	r3, [pc, #128]	; (8034db8 <LoRaMacMibGetRequestConfirm+0x160>)
 8034d36:	f8d3 355c 	ldr.w	r3, [r3, #1372]	; 0x55c
 8034d3a:	e7c7      	b.n	8034ccc <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay2;
 8034d3c:	4b1e      	ldr	r3, [pc, #120]	; (8034db8 <LoRaMacMibGetRequestConfirm+0x160>)
 8034d3e:	f8d3 3560 	ldr.w	r3, [r3, #1376]	; 0x560
 8034d42:	e7c3      	b.n	8034ccc <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.JoinAcceptDelay1 = Nvm.MacGroup2.MacParams.JoinAcceptDelay1;
 8034d44:	4b1c      	ldr	r3, [pc, #112]	; (8034db8 <LoRaMacMibGetRequestConfirm+0x160>)
 8034d46:	f8d3 3564 	ldr.w	r3, [r3, #1380]	; 0x564
 8034d4a:	e7bf      	b.n	8034ccc <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.JoinAcceptDelay2 = Nvm.MacGroup2.MacParams.JoinAcceptDelay2;
 8034d4c:	4b1a      	ldr	r3, [pc, #104]	; (8034db8 <LoRaMacMibGetRequestConfirm+0x160>)
 8034d4e:	f8d3 3568 	ldr.w	r3, [r3, #1384]	; 0x568
 8034d52:	e7bb      	b.n	8034ccc <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.ChannelsDefaultDatarate = Nvm.MacGroup2.ChannelsDatarateDefault;
 8034d54:	4b18      	ldr	r3, [pc, #96]	; (8034db8 <LoRaMacMibGetRequestConfirm+0x160>)
 8034d56:	f893 35d1 	ldrb.w	r3, [r3, #1489]	; 0x5d1
 8034d5a:	e7a6      	b.n	8034caa <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.ChannelsDatarate = Nvm.MacGroup1.ChannelsDatarate;
 8034d5c:	4b16      	ldr	r3, [pc, #88]	; (8034db8 <LoRaMacMibGetRequestConfirm+0x160>)
 8034d5e:	f893 3545 	ldrb.w	r3, [r3, #1349]	; 0x545
 8034d62:	e7a2      	b.n	8034caa <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.ChannelsDefaultTxPower = Nvm.MacGroup2.ChannelsTxPowerDefault;
 8034d64:	4b14      	ldr	r3, [pc, #80]	; (8034db8 <LoRaMacMibGetRequestConfirm+0x160>)
 8034d66:	f893 35d0 	ldrb.w	r3, [r3, #1488]	; 0x5d0
 8034d6a:	e79e      	b.n	8034caa <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.ChannelsTxPower = Nvm.MacGroup1.ChannelsTxPower;
 8034d6c:	4b12      	ldr	r3, [pc, #72]	; (8034db8 <LoRaMacMibGetRequestConfirm+0x160>)
 8034d6e:	f893 3544 	ldrb.w	r3, [r3, #1348]	; 0x544
 8034d72:	e79a      	b.n	8034caa <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.SystemMaxRxError = Nvm.MacGroup2.MacParams.SystemMaxRxError;
 8034d74:	4b10      	ldr	r3, [pc, #64]	; (8034db8 <LoRaMacMibGetRequestConfirm+0x160>)
 8034d76:	f8d3 3550 	ldr.w	r3, [r3, #1360]	; 0x550
 8034d7a:	e7a7      	b.n	8034ccc <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.MinRxSymbols = Nvm.MacGroup2.MacParams.MinRxSymbols;
 8034d7c:	4b0e      	ldr	r3, [pc, #56]	; (8034db8 <LoRaMacMibGetRequestConfirm+0x160>)
 8034d7e:	f893 3554 	ldrb.w	r3, [r3, #1364]	; 0x554
 8034d82:	e792      	b.n	8034caa <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.AntennaGain = Nvm.MacGroup2.MacParams.AntennaGain;
 8034d84:	4b0c      	ldr	r3, [pc, #48]	; (8034db8 <LoRaMacMibGetRequestConfirm+0x160>)
 8034d86:	f8d3 3588 	ldr.w	r3, [r3, #1416]	; 0x588
            mibGet->Param.DefaultAntennaGain = Nvm.MacGroup2.MacParamsDefaults.AntennaGain;
 8034d8a:	6063      	str	r3, [r4, #4]
            break;
 8034d8c:	e792      	b.n	8034cb4 <LoRaMacMibGetRequestConfirm+0x5c>
            mibGet->Param.Contexts = GetNvmData( );
 8034d8e:	4b0f      	ldr	r3, [pc, #60]	; (8034dcc <LoRaMacMibGetRequestConfirm+0x174>)
 8034d90:	e79c      	b.n	8034ccc <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.DefaultAntennaGain = Nvm.MacGroup2.MacParamsDefaults.AntennaGain;
 8034d92:	4b09      	ldr	r3, [pc, #36]	; (8034db8 <LoRaMacMibGetRequestConfirm+0x160>)
 8034d94:	f8d3 35c8 	ldr.w	r3, [r3, #1480]	; 0x5c8
 8034d98:	e7f7      	b.n	8034d8a <LoRaMacMibGetRequestConfirm+0x132>
            mibGet->Param.LrWanVersion.LoRaWan = Nvm.MacGroup2.Version;
 8034d9a:	4b07      	ldr	r3, [pc, #28]	; (8034db8 <LoRaMacMibGetRequestConfirm+0x160>)
 8034d9c:	f8d3 3618 	ldr.w	r3, [r3, #1560]	; 0x618
 8034da0:	6063      	str	r3, [r4, #4]
            mibGet->Param.LrWanVersion.LoRaWanRegion = RegionGetVersion( );
 8034da2:	f001 fdbb 	bl	803691c <RegionGetVersion>
 8034da6:	60a0      	str	r0, [r4, #8]
 8034da8:	e784      	b.n	8034cb4 <LoRaMacMibGetRequestConfirm+0x5c>
            status = LoRaMacClassBMibGetRequestConfirm( mibGet );
 8034daa:	4620      	mov	r0, r4
 8034dac:	f000 fe0c 	bl	80359c8 <LoRaMacClassBMibGetRequestConfirm>
            break;
 8034db0:	e776      	b.n	8034ca0 <LoRaMacMibGetRequestConfirm+0x48>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 8034db2:	2003      	movs	r0, #3
 8034db4:	e774      	b.n	8034ca0 <LoRaMacMibGetRequestConfirm+0x48>
 8034db6:	bf00      	nop
 8034db8:	20004aa4 	.word	0x20004aa4
 8034dbc:	20005014 	.word	0x20005014
 8034dc0:	20005054 	.word	0x20005054
 8034dc4:	2000501c 	.word	0x2000501c
 8034dc8:	2000505c 	.word	0x2000505c
 8034dcc:	20004fb0 	.word	0x20004fb0

08034dd0 <LoRaMacMibSetRequestConfirm>:

LoRaMacStatus_t LoRaMacMibSetRequestConfirm( MibRequestConfirm_t* mibSet )
{
 8034dd0:	b573      	push	{r0, r1, r4, r5, r6, lr}
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
    ChanMaskSetParams_t chanMaskSet;
    VerifyParams_t verify;

    if( mibSet == NULL )
 8034dd2:	4604      	mov	r4, r0
 8034dd4:	2800      	cmp	r0, #0
 8034dd6:	d044      	beq.n	8034e62 <LoRaMacMibSetRequestConfirm+0x92>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }
    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 8034dd8:	4da5      	ldr	r5, [pc, #660]	; (8035070 <LoRaMacMibSetRequestConfirm+0x2a0>)
 8034dda:	f8d5 3344 	ldr.w	r3, [r5, #836]	; 0x344
 8034dde:	079a      	lsls	r2, r3, #30
 8034de0:	f100 8206 	bmi.w	80351f0 <LoRaMacMibSetRequestConfirm+0x420>
    {
        return LORAMAC_STATUS_BUSY;
    }

    switch( mibSet->Type )
 8034de4:	7802      	ldrb	r2, [r0, #0]
 8034de6:	2a27      	cmp	r2, #39	; 0x27
 8034de8:	f200 81ff 	bhi.w	80351ea <LoRaMacMibSetRequestConfirm+0x41a>
 8034dec:	e8df f012 	tbh	[pc, r2, lsl #1]
 8034df0:	002d0028 	.word	0x002d0028
 8034df4:	003b0034 	.word	0x003b0034
 8034df8:	0043003f 	.word	0x0043003f
 8034dfc:	004b0047 	.word	0x004b0047
 8034e00:	005a0055 	.word	0x005a0055
 8034e04:	0064005f 	.word	0x0064005f
 8034e08:	006e0069 	.word	0x006e0069
 8034e0c:	00780073 	.word	0x00780073
 8034e10:	01fd0081 	.word	0x01fd0081
 8034e14:	00a40085 	.word	0x00a40085
 8034e18:	00da00b5 	.word	0x00da00b5
 8034e1c:	00ec00fa 	.word	0x00ec00fa
 8034e20:	010600fe 	.word	0x010600fe
 8034e24:	010e010a 	.word	0x010e010a
 8034e28:	01160112 	.word	0x01160112
 8034e2c:	012b011a 	.word	0x012b011a
 8034e30:	014c015d 	.word	0x014c015d
 8034e34:	0174016e 	.word	0x0174016e
 8034e38:	017e017a 	.word	0x017e017a
 8034e3c:	01f20182 	.word	0x01f20182
    {
        case MIB_DEVICE_CLASS:
        {
            status = SwitchClass( mibSet->Param.Class );
 8034e40:	7900      	ldrb	r0, [r0, #4]
 8034e42:	f7fe fc8b 	bl	803375c <SwitchClass>
            status = LoRaMacMibClassBSetRequestConfirm( mibSet );
            break;
        }
    }
    return status;
}
 8034e46:	b002      	add	sp, #8
 8034e48:	bd70      	pop	{r4, r5, r6, pc}
            if( mibSet->Param.NetworkActivation != ACTIVATION_TYPE_OTAA  )
 8034e4a:	7903      	ldrb	r3, [r0, #4]
 8034e4c:	2b02      	cmp	r3, #2
 8034e4e:	d008      	beq.n	8034e62 <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup2.NetworkActivation = mibSet->Param.NetworkActivation;
 8034e50:	f885 361c 	strb.w	r3, [r5, #1564]	; 0x61c
    return LORAMAC_STATUS_OK;
 8034e54:	2000      	movs	r0, #0
 8034e56:	e7f6      	b.n	8034e46 <LoRaMacMibSetRequestConfirm+0x76>
            if( SecureElementSetDevEui( mibSet->Param.DevEui ) != SECURE_ELEMENT_SUCCESS )
 8034e58:	6840      	ldr	r0, [r0, #4]
 8034e5a:	f004 f81b 	bl	8038e94 <SecureElementSetDevEui>
 8034e5e:	2800      	cmp	r0, #0
 8034e60:	d0f8      	beq.n	8034e54 <LoRaMacMibSetRequestConfirm+0x84>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 8034e62:	2003      	movs	r0, #3
 8034e64:	e7ef      	b.n	8034e46 <LoRaMacMibSetRequestConfirm+0x76>
            if( SecureElementSetJoinEui( mibSet->Param.JoinEui ) != SECURE_ELEMENT_SUCCESS )
 8034e66:	6840      	ldr	r0, [r0, #4]
 8034e68:	f004 f828 	bl	8038ebc <SecureElementSetJoinEui>
 8034e6c:	e7f7      	b.n	8034e5e <LoRaMacMibSetRequestConfirm+0x8e>
            Nvm.MacGroup2.AdrCtrlOn = mibSet->Param.AdrEnable;
 8034e6e:	7903      	ldrb	r3, [r0, #4]
 8034e70:	f885 360a 	strb.w	r3, [r5, #1546]	; 0x60a
            break;
 8034e74:	e7ee      	b.n	8034e54 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.NetID = mibSet->Param.NetID;
 8034e76:	6843      	ldr	r3, [r0, #4]
 8034e78:	f8c5 35d4 	str.w	r3, [r5, #1492]	; 0x5d4
            break;
 8034e7c:	e7ea      	b.n	8034e54 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.DevAddr = mibSet->Param.DevAddr;
 8034e7e:	6843      	ldr	r3, [r0, #4]
 8034e80:	f8c5 35d8 	str.w	r3, [r5, #1496]	; 0x5d8
            break;
 8034e84:	e7e6      	b.n	8034e54 <LoRaMacMibSetRequestConfirm+0x84>
            if( mibSet->Param.AppKey != NULL )
 8034e86:	6841      	ldr	r1, [r0, #4]
 8034e88:	2900      	cmp	r1, #0
 8034e8a:	d0ea      	beq.n	8034e62 <LoRaMacMibSetRequestConfirm+0x92>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( APP_KEY, mibSet->Param.AppKey ) )
 8034e8c:	2000      	movs	r0, #0
 8034e8e:	f001 fa1f 	bl	80362d0 <LoRaMacCryptoSetKey>
 8034e92:	2800      	cmp	r0, #0
 8034e94:	d0de      	beq.n	8034e54 <LoRaMacMibSetRequestConfirm+0x84>
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 8034e96:	2011      	movs	r0, #17
 8034e98:	e7d5      	b.n	8034e46 <LoRaMacMibSetRequestConfirm+0x76>
            if( mibSet->Param.NwkKey != NULL )
 8034e9a:	6841      	ldr	r1, [r0, #4]
 8034e9c:	2900      	cmp	r1, #0
 8034e9e:	d0e0      	beq.n	8034e62 <LoRaMacMibSetRequestConfirm+0x92>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( NWK_KEY, mibSet->Param.NwkKey ) )
 8034ea0:	2001      	movs	r0, #1
 8034ea2:	e7f4      	b.n	8034e8e <LoRaMacMibSetRequestConfirm+0xbe>
            if( mibSet->Param.NwkSKey != NULL )
 8034ea4:	6841      	ldr	r1, [r0, #4]
 8034ea6:	2900      	cmp	r1, #0
 8034ea8:	d0db      	beq.n	8034e62 <LoRaMacMibSetRequestConfirm+0x92>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( NWK_S_KEY, mibSet->Param.NwkSKey ) )
 8034eaa:	2002      	movs	r0, #2
 8034eac:	e7ef      	b.n	8034e8e <LoRaMacMibSetRequestConfirm+0xbe>
            if( mibSet->Param.AppSKey != NULL )
 8034eae:	6841      	ldr	r1, [r0, #4]
 8034eb0:	2900      	cmp	r1, #0
 8034eb2:	d0d6      	beq.n	8034e62 <LoRaMacMibSetRequestConfirm+0x92>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( APP_S_KEY, mibSet->Param.AppSKey ) )
 8034eb4:	2003      	movs	r0, #3
 8034eb6:	e7ea      	b.n	8034e8e <LoRaMacMibSetRequestConfirm+0xbe>
            if( mibSet->Param.McKEKey != NULL )
 8034eb8:	6841      	ldr	r1, [r0, #4]
 8034eba:	2900      	cmp	r1, #0
 8034ebc:	d0d1      	beq.n	8034e62 <LoRaMacMibSetRequestConfirm+0x92>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KE_KEY, mibSet->Param.McKEKey ) )
 8034ebe:	207f      	movs	r0, #127	; 0x7f
 8034ec0:	e7e5      	b.n	8034e8e <LoRaMacMibSetRequestConfirm+0xbe>
            if( mibSet->Param.McKey0 != NULL )
 8034ec2:	6841      	ldr	r1, [r0, #4]
 8034ec4:	2900      	cmp	r1, #0
 8034ec6:	d0cc      	beq.n	8034e62 <LoRaMacMibSetRequestConfirm+0x92>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KEY_0, mibSet->Param.McKey0 ) )
 8034ec8:	2080      	movs	r0, #128	; 0x80
 8034eca:	e7e0      	b.n	8034e8e <LoRaMacMibSetRequestConfirm+0xbe>
            if( mibSet->Param.McAppSKey0 != NULL )
 8034ecc:	6841      	ldr	r1, [r0, #4]
 8034ece:	2900      	cmp	r1, #0
 8034ed0:	d0c7      	beq.n	8034e62 <LoRaMacMibSetRequestConfirm+0x92>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_APP_S_KEY_0, mibSet->Param.McAppSKey0 ) )
 8034ed2:	2081      	movs	r0, #129	; 0x81
 8034ed4:	e7db      	b.n	8034e8e <LoRaMacMibSetRequestConfirm+0xbe>
            if( mibSet->Param.McNwkSKey0 != NULL )
 8034ed6:	6841      	ldr	r1, [r0, #4]
 8034ed8:	2900      	cmp	r1, #0
 8034eda:	d0c2      	beq.n	8034e62 <LoRaMacMibSetRequestConfirm+0x92>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_NWK_S_KEY_0, mibSet->Param.McNwkSKey0 ) )
 8034edc:	2082      	movs	r0, #130	; 0x82
 8034ede:	e7d6      	b.n	8034e8e <LoRaMacMibSetRequestConfirm+0xbe>
            Radio.SetPublicNetwork( Nvm.MacGroup2.PublicNetwork );
 8034ee0:	4c64      	ldr	r4, [pc, #400]	; (8035074 <LoRaMacMibSetRequestConfirm+0x2a4>)
            Nvm.MacGroup2.PublicNetwork = mibSet->Param.EnablePublicNetwork;
 8034ee2:	7900      	ldrb	r0, [r0, #4]
            Radio.SetPublicNetwork( Nvm.MacGroup2.PublicNetwork );
 8034ee4:	6da3      	ldr	r3, [r4, #88]	; 0x58
            Nvm.MacGroup2.PublicNetwork = mibSet->Param.EnablePublicNetwork;
 8034ee6:	f885 0609 	strb.w	r0, [r5, #1545]	; 0x609
            Radio.SetPublicNetwork( Nvm.MacGroup2.PublicNetwork );
 8034eea:	4798      	blx	r3
            Radio.Sleep( );
 8034eec:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8034eee:	4798      	blx	r3
            break;
 8034ef0:	e7b0      	b.n	8034e54 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.RepeaterSupport = mibSet->Param.EnableRepeaterSupport;
 8034ef2:	7903      	ldrb	r3, [r0, #4]
 8034ef4:	f885 358c 	strb.w	r3, [r5, #1420]	; 0x58c
            break;
 8034ef8:	e7ac      	b.n	8034e54 <LoRaMacMibSetRequestConfirm+0x84>
            verify.DatarateParams.Datarate = mibSet->Param.Rx2Channel.Datarate;
 8034efa:	7a03      	ldrb	r3, [r0, #8]
 8034efc:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) != true )
 8034f00:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 8034f04:	f895 3581 	ldrb.w	r3, [r5, #1409]	; 0x581
 8034f08:	f88d 3001 	strb.w	r3, [sp, #1]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) != true )
 8034f0c:	2207      	movs	r2, #7
 8034f0e:	4669      	mov	r1, sp
 8034f10:	f001 fc2b 	bl	803676a <RegionVerify>
 8034f14:	2800      	cmp	r0, #0
 8034f16:	d0a4      	beq.n	8034e62 <LoRaMacMibSetRequestConfirm+0x92>
                verify.Frequency = mibSet->Param.Rx2Channel.Frequency;
 8034f18:	6863      	ldr	r3, [r4, #4]
                if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_FREQUENCY ) != true )
 8034f1a:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
                verify.Frequency = mibSet->Param.Rx2Channel.Frequency;
 8034f1e:	9300      	str	r3, [sp, #0]
                if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_FREQUENCY ) != true )
 8034f20:	2200      	movs	r2, #0
 8034f22:	4669      	mov	r1, sp
 8034f24:	f001 fc21 	bl	803676a <RegionVerify>
 8034f28:	2800      	cmp	r0, #0
 8034f2a:	d09a      	beq.n	8034e62 <LoRaMacMibSetRequestConfirm+0x92>
                    Nvm.MacGroup2.MacParams.Rx2Channel = mibSet->Param.Rx2Channel;
 8034f2c:	4b52      	ldr	r3, [pc, #328]	; (8035078 <LoRaMacMibSetRequestConfirm+0x2a8>)
                Nvm.MacGroup2.MacParamsDefaults.Rx2Channel = mibSet->Param.Rx2DefaultChannel;
 8034f2e:	e9d4 0101 	ldrd	r0, r1, [r4, #4]
 8034f32:	e883 0003 	stmia.w	r3, {r0, r1}
 8034f36:	e78d      	b.n	8034e54 <LoRaMacMibSetRequestConfirm+0x84>
            verify.DatarateParams.Datarate = mibSet->Param.Rx2Channel.Datarate;
 8034f38:	7a03      	ldrb	r3, [r0, #8]
 8034f3a:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 8034f3e:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 8034f42:	f895 3581 	ldrb.w	r3, [r5, #1409]	; 0x581
 8034f46:	f88d 3001 	strb.w	r3, [sp, #1]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 8034f4a:	2207      	movs	r2, #7
 8034f4c:	4669      	mov	r1, sp
 8034f4e:	f001 fc0c 	bl	803676a <RegionVerify>
 8034f52:	2800      	cmp	r0, #0
 8034f54:	d085      	beq.n	8034e62 <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup2.MacParamsDefaults.Rx2Channel = mibSet->Param.Rx2DefaultChannel;
 8034f56:	4b49      	ldr	r3, [pc, #292]	; (803507c <LoRaMacMibSetRequestConfirm+0x2ac>)
 8034f58:	e7e9      	b.n	8034f2e <LoRaMacMibSetRequestConfirm+0x15e>
            verify.DatarateParams.Datarate = mibSet->Param.RxCChannel.Datarate;
 8034f5a:	7a03      	ldrb	r3, [r0, #8]
 8034f5c:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 8034f60:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 8034f64:	f895 3581 	ldrb.w	r3, [r5, #1409]	; 0x581
 8034f68:	f88d 3001 	strb.w	r3, [sp, #1]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 8034f6c:	2207      	movs	r2, #7
 8034f6e:	4669      	mov	r1, sp
 8034f70:	f001 fbfb 	bl	803676a <RegionVerify>
 8034f74:	2800      	cmp	r0, #0
 8034f76:	f43f af74 	beq.w	8034e62 <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup2.MacParams.RxCChannel = mibSet->Param.RxCChannel;
 8034f7a:	e9d4 0101 	ldrd	r0, r1, [r4, #4]
 8034f7e:	4b40      	ldr	r3, [pc, #256]	; (8035080 <LoRaMacMibSetRequestConfirm+0x2b0>)
 8034f80:	e883 0003 	stmia.w	r3, {r0, r1}
                if( ( Nvm.MacGroup2.DeviceClass == CLASS_C ) && ( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE ) )
 8034f84:	f895 3608 	ldrb.w	r3, [r5, #1544]	; 0x608
 8034f88:	2b02      	cmp	r3, #2
 8034f8a:	f47f af63 	bne.w	8034e54 <LoRaMacMibSetRequestConfirm+0x84>
 8034f8e:	f895 361c 	ldrb.w	r3, [r5, #1564]	; 0x61c
 8034f92:	2b00      	cmp	r3, #0
 8034f94:	f43f af5e 	beq.w	8034e54 <LoRaMacMibSetRequestConfirm+0x84>
                    Radio.Sleep( );
 8034f98:	4b36      	ldr	r3, [pc, #216]	; (8035074 <LoRaMacMibSetRequestConfirm+0x2a4>)
 8034f9a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8034f9c:	4798      	blx	r3
                    OpenContinuousRxCWindow( );
 8034f9e:	f7fe fbb3 	bl	8033708 <OpenContinuousRxCWindow>
 8034fa2:	e757      	b.n	8034e54 <LoRaMacMibSetRequestConfirm+0x84>
            verify.DatarateParams.Datarate = mibSet->Param.RxCChannel.Datarate;
 8034fa4:	7a03      	ldrb	r3, [r0, #8]
 8034fa6:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 8034faa:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 8034fae:	f895 3581 	ldrb.w	r3, [r5, #1409]	; 0x581
 8034fb2:	f88d 3001 	strb.w	r3, [sp, #1]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 8034fb6:	2207      	movs	r2, #7
 8034fb8:	4669      	mov	r1, sp
 8034fba:	f001 fbd6 	bl	803676a <RegionVerify>
 8034fbe:	2800      	cmp	r0, #0
 8034fc0:	f43f af4f 	beq.w	8034e62 <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup2.MacParamsDefaults.RxCChannel = mibSet->Param.RxCDefaultChannel;
 8034fc4:	4b2f      	ldr	r3, [pc, #188]	; (8035084 <LoRaMacMibSetRequestConfirm+0x2b4>)
 8034fc6:	e7b2      	b.n	8034f2e <LoRaMacMibSetRequestConfirm+0x15e>
            chanMaskSet.ChannelsMaskIn = mibSet->Param.ChannelsDefaultMask;
 8034fc8:	6843      	ldr	r3, [r0, #4]
 8034fca:	9300      	str	r3, [sp, #0]
            chanMaskSet.ChannelsMaskType = CHANNELS_DEFAULT_MASK;
 8034fcc:	2301      	movs	r3, #1
            if( RegionChanMaskSet( Nvm.MacGroup2.Region, &chanMaskSet ) == false )
 8034fce:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            chanMaskSet.ChannelsMaskType = CHANNELS_MASK;
 8034fd2:	f88d 3004 	strb.w	r3, [sp, #4]
            if( RegionChanMaskSet( Nvm.MacGroup2.Region, &chanMaskSet ) == false )
 8034fd6:	4669      	mov	r1, sp
 8034fd8:	f001 fbdf 	bl	803679a <RegionChanMaskSet>
 8034fdc:	2800      	cmp	r0, #0
 8034fde:	f47f af39 	bne.w	8034e54 <LoRaMacMibSetRequestConfirm+0x84>
 8034fe2:	e73e      	b.n	8034e62 <LoRaMacMibSetRequestConfirm+0x92>
            chanMaskSet.ChannelsMaskIn = mibSet->Param.ChannelsMask;
 8034fe4:	6843      	ldr	r3, [r0, #4]
 8034fe6:	9300      	str	r3, [sp, #0]
            chanMaskSet.ChannelsMaskType = CHANNELS_MASK;
 8034fe8:	2300      	movs	r3, #0
 8034fea:	e7f0      	b.n	8034fce <LoRaMacMibSetRequestConfirm+0x1fe>
            if( ( mibSet->Param.ChannelsNbTrans >= 1 ) &&
 8034fec:	7903      	ldrb	r3, [r0, #4]
 8034fee:	1e5a      	subs	r2, r3, #1
 8034ff0:	2a0e      	cmp	r2, #14
 8034ff2:	f63f af36 	bhi.w	8034e62 <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup2.MacParams.ChannelsNbTrans = mibSet->Param.ChannelsNbTrans;
 8034ff6:	f885 356c 	strb.w	r3, [r5, #1388]	; 0x56c
 8034ffa:	e72b      	b.n	8034e54 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.MaxRxWindow = mibSet->Param.MaxRxWindow;
 8034ffc:	6843      	ldr	r3, [r0, #4]
 8034ffe:	f8c5 3558 	str.w	r3, [r5, #1368]	; 0x558
            break;
 8035002:	e727      	b.n	8034e54 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.ReceiveDelay1 = mibSet->Param.ReceiveDelay1;
 8035004:	6843      	ldr	r3, [r0, #4]
 8035006:	f8c5 355c 	str.w	r3, [r5, #1372]	; 0x55c
            break;
 803500a:	e723      	b.n	8034e54 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.ReceiveDelay2 = mibSet->Param.ReceiveDelay2;
 803500c:	6843      	ldr	r3, [r0, #4]
 803500e:	f8c5 3560 	str.w	r3, [r5, #1376]	; 0x560
            break;
 8035012:	e71f      	b.n	8034e54 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.JoinAcceptDelay1 = mibSet->Param.JoinAcceptDelay1;
 8035014:	6843      	ldr	r3, [r0, #4]
 8035016:	f8c5 3564 	str.w	r3, [r5, #1380]	; 0x564
            break;
 803501a:	e71b      	b.n	8034e54 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.JoinAcceptDelay2 = mibSet->Param.JoinAcceptDelay2;
 803501c:	6843      	ldr	r3, [r0, #4]
 803501e:	f8c5 3568 	str.w	r3, [r5, #1384]	; 0x568
            break;
 8035022:	e717      	b.n	8034e54 <LoRaMacMibSetRequestConfirm+0x84>
            verify.DatarateParams.Datarate = mibSet->Param.ChannelsDefaultDatarate;
 8035024:	7903      	ldrb	r3, [r0, #4]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_DR ) == true )
 8035026:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            verify.DatarateParams.Datarate = mibSet->Param.ChannelsDefaultDatarate;
 803502a:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_DR ) == true )
 803502e:	2206      	movs	r2, #6
 8035030:	4669      	mov	r1, sp
 8035032:	f001 fb9a 	bl	803676a <RegionVerify>
 8035036:	2800      	cmp	r0, #0
 8035038:	f43f af13 	beq.w	8034e62 <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup2.ChannelsDatarateDefault = verify.DatarateParams.Datarate;
 803503c:	f89d 3000 	ldrb.w	r3, [sp]
 8035040:	f885 35d1 	strb.w	r3, [r5, #1489]	; 0x5d1
 8035044:	e706      	b.n	8034e54 <LoRaMacMibSetRequestConfirm+0x84>
            verify.DatarateParams.Datarate = mibSet->Param.ChannelsDatarate;
 8035046:	7903      	ldrb	r3, [r0, #4]
 8035048:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_DR ) == true )
 803504c:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            verify.DatarateParams.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8035050:	f895 3580 	ldrb.w	r3, [r5, #1408]	; 0x580
 8035054:	f88d 3002 	strb.w	r3, [sp, #2]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_DR ) == true )
 8035058:	2205      	movs	r2, #5
 803505a:	4669      	mov	r1, sp
 803505c:	f001 fb85 	bl	803676a <RegionVerify>
 8035060:	2800      	cmp	r0, #0
 8035062:	f43f aefe 	beq.w	8034e62 <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup1.ChannelsDatarate = verify.DatarateParams.Datarate;
 8035066:	f89d 3000 	ldrb.w	r3, [sp]
 803506a:	f885 3545 	strb.w	r3, [r5, #1349]	; 0x545
 803506e:	e6f1      	b.n	8034e54 <LoRaMacMibSetRequestConfirm+0x84>
 8035070:	20004aa4 	.word	0x20004aa4
 8035074:	0803bc30 	.word	0x0803bc30
 8035078:	20005014 	.word	0x20005014
 803507c:	20005054 	.word	0x20005054
 8035080:	2000501c 	.word	0x2000501c
 8035084:	2000505c 	.word	0x2000505c
            verify.TxPower = mibSet->Param.ChannelsDefaultTxPower;
 8035088:	7903      	ldrb	r3, [r0, #4]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_POWER ) == true )
 803508a:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            verify.TxPower = mibSet->Param.ChannelsDefaultTxPower;
 803508e:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_POWER ) == true )
 8035092:	220a      	movs	r2, #10
 8035094:	4669      	mov	r1, sp
 8035096:	f001 fb68 	bl	803676a <RegionVerify>
 803509a:	2800      	cmp	r0, #0
 803509c:	f43f aee1 	beq.w	8034e62 <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup2.ChannelsTxPowerDefault = verify.TxPower;
 80350a0:	f89d 3000 	ldrb.w	r3, [sp]
 80350a4:	f885 35d0 	strb.w	r3, [r5, #1488]	; 0x5d0
 80350a8:	e6d4      	b.n	8034e54 <LoRaMacMibSetRequestConfirm+0x84>
            verify.TxPower = mibSet->Param.ChannelsTxPower;
 80350aa:	7903      	ldrb	r3, [r0, #4]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_POWER ) == true )
 80350ac:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            verify.TxPower = mibSet->Param.ChannelsTxPower;
 80350b0:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_POWER ) == true )
 80350b4:	2209      	movs	r2, #9
 80350b6:	4669      	mov	r1, sp
 80350b8:	f001 fb57 	bl	803676a <RegionVerify>
 80350bc:	2800      	cmp	r0, #0
 80350be:	f43f aed0 	beq.w	8034e62 <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup1.ChannelsTxPower = verify.TxPower;
 80350c2:	f89d 3000 	ldrb.w	r3, [sp]
 80350c6:	f885 3544 	strb.w	r3, [r5, #1348]	; 0x544
 80350ca:	e6c3      	b.n	8034e54 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.SystemMaxRxError = Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError = mibSet->Param.SystemMaxRxError;
 80350cc:	6843      	ldr	r3, [r0, #4]
 80350ce:	f8c5 3590 	str.w	r3, [r5, #1424]	; 0x590
 80350d2:	f8c5 3550 	str.w	r3, [r5, #1360]	; 0x550
            break;
 80350d6:	e6bd      	b.n	8034e54 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.MinRxSymbols = Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols = mibSet->Param.MinRxSymbols;
 80350d8:	7903      	ldrb	r3, [r0, #4]
 80350da:	f885 3594 	strb.w	r3, [r5, #1428]	; 0x594
 80350de:	f885 3554 	strb.w	r3, [r5, #1364]	; 0x554
            break;
 80350e2:	e6b7      	b.n	8034e54 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.AntennaGain = mibSet->Param.AntennaGain;
 80350e4:	6843      	ldr	r3, [r0, #4]
 80350e6:	f8c5 3588 	str.w	r3, [r5, #1416]	; 0x588
            break;
 80350ea:	e6b3      	b.n	8034e54 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParamsDefaults.AntennaGain = mibSet->Param.DefaultAntennaGain;
 80350ec:	6843      	ldr	r3, [r0, #4]
 80350ee:	f8c5 35c8 	str.w	r3, [r5, #1480]	; 0x5c8
            break;
 80350f2:	e6af      	b.n	8034e54 <LoRaMacMibSetRequestConfirm+0x84>
            if( mibSet->Param.Contexts != 0 )
 80350f4:	6844      	ldr	r4, [r0, #4]
 80350f6:	2c00      	cmp	r4, #0
 80350f8:	f43f aeb3 	beq.w	8034e62 <LoRaMacMibSetRequestConfirm+0x92>
    if( MacCtx.MacState != LORAMAC_STOPPED )
 80350fc:	2b01      	cmp	r3, #1
 80350fe:	d177      	bne.n	80351f0 <LoRaMacMibSetRequestConfirm+0x420>
    crc = Crc32( ( uint8_t* ) &nvm->Crypto, sizeof( nvm->Crypto ) -
 8035100:	2124      	movs	r1, #36	; 0x24
 8035102:	4620      	mov	r0, r4
 8035104:	f003 ff2e 	bl	8038f64 <Crc32>
    if( crc == nvm->Crypto.Crc32 )
 8035108:	6a63      	ldr	r3, [r4, #36]	; 0x24
 803510a:	4298      	cmp	r0, r3
 803510c:	d104      	bne.n	8035118 <LoRaMacMibSetRequestConfirm+0x348>
        memcpy1( ( uint8_t* ) &Nvm.Crypto, ( uint8_t* ) &nvm->Crypto,
 803510e:	4839      	ldr	r0, [pc, #228]	; (80351f4 <LoRaMacMibSetRequestConfirm+0x424>)
 8035110:	2228      	movs	r2, #40	; 0x28
 8035112:	4621      	mov	r1, r4
 8035114:	f003 ff0a 	bl	8038f2c <memcpy1>
    crc = Crc32( ( uint8_t* ) &nvm->MacGroup1, sizeof( nvm->MacGroup1 ) -
 8035118:	f104 0628 	add.w	r6, r4, #40	; 0x28
 803511c:	2114      	movs	r1, #20
 803511e:	4630      	mov	r0, r6
 8035120:	f003 ff20 	bl	8038f64 <Crc32>
    if( crc == nvm->MacGroup1.Crc32 )
 8035124:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8035126:	4298      	cmp	r0, r3
 8035128:	d104      	bne.n	8035134 <LoRaMacMibSetRequestConfirm+0x364>
        memcpy1( ( uint8_t* ) &Nvm.MacGroup1, ( uint8_t* ) &nvm->MacGroup1,
 803512a:	4833      	ldr	r0, [pc, #204]	; (80351f8 <LoRaMacMibSetRequestConfirm+0x428>)
 803512c:	2218      	movs	r2, #24
 803512e:	4631      	mov	r1, r6
 8035130:	f003 fefc 	bl	8038f2c <memcpy1>
    crc = Crc32( ( uint8_t* ) &nvm->MacGroup2, sizeof( nvm->MacGroup2 ) -
 8035134:	f104 0640 	add.w	r6, r4, #64	; 0x40
 8035138:	21d4      	movs	r1, #212	; 0xd4
 803513a:	4630      	mov	r0, r6
 803513c:	f003 ff12 	bl	8038f64 <Crc32>
    if( crc == nvm->MacGroup2.Crc32 )
 8035140:	f8d4 3114 	ldr.w	r3, [r4, #276]	; 0x114
 8035144:	4298      	cmp	r0, r3
 8035146:	d114      	bne.n	8035172 <LoRaMacMibSetRequestConfirm+0x3a2>
        memcpy1( ( uint8_t* ) &Nvm.MacGroup2, ( uint8_t* ) &nvm->MacGroup2,
 8035148:	482c      	ldr	r0, [pc, #176]	; (80351fc <LoRaMacMibSetRequestConfirm+0x42c>)
 803514a:	22d8      	movs	r2, #216	; 0xd8
 803514c:	4631      	mov	r1, r6
 803514e:	f003 feed 	bl	8038f2c <memcpy1>
        MacCtx.RxWindowCConfig.Channel = MacCtx.Channel;
 8035152:	f895 3419 	ldrb.w	r3, [r5, #1049]	; 0x419
 8035156:	f885 33e4 	strb.w	r3, [r5, #996]	; 0x3e4
        MacCtx.RxWindowCConfig.Frequency = Nvm.MacGroup2.MacParams.RxCChannel.Frequency;
 803515a:	f8d5 3578 	ldr.w	r3, [r5, #1400]	; 0x578
 803515e:	f8c5 33e8 	str.w	r3, [r5, #1000]	; 0x3e8
        MacCtx.RxWindowCConfig.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 8035162:	f895 3581 	ldrb.w	r3, [r5, #1409]	; 0x581
 8035166:	f885 33f4 	strb.w	r3, [r5, #1012]	; 0x3f4
        MacCtx.RxWindowCConfig.RxContinuous = true;
 803516a:	f240 2301 	movw	r3, #513	; 0x201
 803516e:	f8a5 33f6 	strh.w	r3, [r5, #1014]	; 0x3f6
    crc = Crc32( ( uint8_t* ) &nvm->SecureElement, sizeof( nvm->SecureElement ) -
 8035172:	f504 758c 	add.w	r5, r4, #280	; 0x118
 8035176:	f44f 7180 	mov.w	r1, #256	; 0x100
 803517a:	4628      	mov	r0, r5
 803517c:	f003 fef2 	bl	8038f64 <Crc32>
    if( crc == nvm->SecureElement.Crc32 )
 8035180:	f8d4 3218 	ldr.w	r3, [r4, #536]	; 0x218
 8035184:	4298      	cmp	r0, r3
 8035186:	d105      	bne.n	8035194 <LoRaMacMibSetRequestConfirm+0x3c4>
        memcpy1( ( uint8_t* ) &Nvm.SecureElement,( uint8_t* ) &nvm->SecureElement,
 8035188:	481d      	ldr	r0, [pc, #116]	; (8035200 <LoRaMacMibSetRequestConfirm+0x430>)
 803518a:	f44f 7282 	mov.w	r2, #260	; 0x104
 803518e:	4629      	mov	r1, r5
 8035190:	f003 fecc 	bl	8038f2c <memcpy1>
    crc = Crc32( ( uint8_t* ) &nvm->RegionGroup1, sizeof( nvm->RegionGroup1 ) -
 8035194:	f504 7507 	add.w	r5, r4, #540	; 0x21c
 8035198:	21a0      	movs	r1, #160	; 0xa0
 803519a:	4628      	mov	r0, r5
 803519c:	f003 fee2 	bl	8038f64 <Crc32>
    if( crc == nvm->RegionGroup1.Crc32 )
 80351a0:	f8d4 32bc 	ldr.w	r3, [r4, #700]	; 0x2bc
 80351a4:	4298      	cmp	r0, r3
 80351a6:	d104      	bne.n	80351b2 <LoRaMacMibSetRequestConfirm+0x3e2>
        memcpy1( ( uint8_t* ) &Nvm.RegionGroup1,( uint8_t* ) &nvm->RegionGroup1,
 80351a8:	4816      	ldr	r0, [pc, #88]	; (8035204 <LoRaMacMibSetRequestConfirm+0x434>)
 80351aa:	22a4      	movs	r2, #164	; 0xa4
 80351ac:	4629      	mov	r1, r5
 80351ae:	f003 febd 	bl	8038f2c <memcpy1>
    crc = Crc32( ( uint8_t* ) &nvm->ClassB, sizeof( nvm->ClassB ) -
 80351b2:	f204 653c 	addw	r5, r4, #1596	; 0x63c
 80351b6:	2114      	movs	r1, #20
 80351b8:	4628      	mov	r0, r5
 80351ba:	f003 fed3 	bl	8038f64 <Crc32>
    if( crc == nvm->ClassB.Crc32 )
 80351be:	f8d4 3650 	ldr.w	r3, [r4, #1616]	; 0x650
 80351c2:	4298      	cmp	r0, r3
 80351c4:	f47f ae46 	bne.w	8034e54 <LoRaMacMibSetRequestConfirm+0x84>
        memcpy1( ( uint8_t* ) &Nvm.ClassB,( uint8_t* ) &nvm->ClassB,
 80351c8:	480f      	ldr	r0, [pc, #60]	; (8035208 <LoRaMacMibSetRequestConfirm+0x438>)
 80351ca:	2218      	movs	r2, #24
 80351cc:	4629      	mov	r1, r5
 80351ce:	f003 fead 	bl	8038f2c <memcpy1>
 80351d2:	e63f      	b.n	8034e54 <LoRaMacMibSetRequestConfirm+0x84>
            if( mibSet->Param.AbpLrWanVersion.Fields.Minor <= 1 )
 80351d4:	7983      	ldrb	r3, [r0, #6]
 80351d6:	2b01      	cmp	r3, #1
 80351d8:	f63f ae43 	bhi.w	8034e62 <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup2.Version = mibSet->Param.AbpLrWanVersion;
 80351dc:	6843      	ldr	r3, [r0, #4]
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetLrWanVersion( mibSet->Param.AbpLrWanVersion ) )
 80351de:	6840      	ldr	r0, [r0, #4]
                Nvm.MacGroup2.Version = mibSet->Param.AbpLrWanVersion;
 80351e0:	f8c5 3618 	str.w	r3, [r5, #1560]	; 0x618
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetLrWanVersion( mibSet->Param.AbpLrWanVersion ) )
 80351e4:	f000 ff04 	bl	8035ff0 <LoRaMacCryptoSetLrWanVersion>
 80351e8:	e653      	b.n	8034e92 <LoRaMacMibSetRequestConfirm+0xc2>
            status = LoRaMacMibClassBSetRequestConfirm( mibSet );
 80351ea:	f000 fbef 	bl	80359cc <LoRaMacMibClassBSetRequestConfirm>
            break;
 80351ee:	e62a      	b.n	8034e46 <LoRaMacMibSetRequestConfirm+0x76>
        return LORAMAC_STATUS_BUSY;
 80351f0:	2001      	movs	r0, #1
 80351f2:	e628      	b.n	8034e46 <LoRaMacMibSetRequestConfirm+0x76>
 80351f4:	20004fb0 	.word	0x20004fb0
 80351f8:	20004fd8 	.word	0x20004fd8
 80351fc:	20004ff0 	.word	0x20004ff0
 8035200:	200050c8 	.word	0x200050c8
 8035204:	200051cc 	.word	0x200051cc
 8035208:	200055ec 	.word	0x200055ec

0803520c <LoRaMacMcChannelSetup>:
    return LORAMAC_STATUS_OK;
}

LoRaMacStatus_t LoRaMacMcChannelSetup( McChannelParams_t *channel )
{
    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 803520c:	4b24      	ldr	r3, [pc, #144]	; (80352a0 <LoRaMacMcChannelSetup+0x94>)
 803520e:	f8d3 2344 	ldr.w	r2, [r3, #836]	; 0x344
 8035212:	f012 0f02 	tst.w	r2, #2
{
 8035216:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 803521a:	4604      	mov	r4, r0
 803521c:	4698      	mov	r8, r3
    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 803521e:	d13b      	bne.n	8035298 <LoRaMacMcChannelSetup+0x8c>
    {
        return LORAMAC_STATUS_BUSY;
    }

    if( channel->GroupID >= LORAMAC_MAX_MC_CTX )
 8035220:	78c7      	ldrb	r7, [r0, #3]
 8035222:	2f00      	cmp	r7, #0
 8035224:	d13a      	bne.n	803529c <LoRaMacMcChannelSetup+0x90>
    {
        return LORAMAC_STATUS_MC_GROUP_UNDEFINED;
    }

    Nvm.MacGroup2.MulticastChannelList[channel->GroupID].ChannelParams = *channel;
 8035226:	4606      	mov	r6, r0
 8035228:	f203 55dc 	addw	r5, r3, #1500	; 0x5dc
 803522c:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 803522e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8035230:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
 8035234:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}

    if( channel->IsRemotelySetup == true )
 8035238:	7823      	ldrb	r3, [r4, #0]
#if ( LORAMAC_MAX_MC_CTX > 3 )
            , MC_KEY_3
#endif /* LORAMAC_MAX_MC_CTX > 3 */
        };
        /* ST_WORKAROUND_END */
        if( LoRaMacCryptoSetKey( mcKeys[channel->GroupID], channel->McKeys.McKeyE ) != LORAMAC_CRYPTO_SUCCESS )
 803523a:	68a1      	ldr	r1, [r4, #8]
    if( channel->IsRemotelySetup == true )
 803523c:	b313      	cbz	r3, 8035284 <LoRaMacMcChannelSetup+0x78>
        if( LoRaMacCryptoSetKey( mcKeys[channel->GroupID], channel->McKeys.McKeyE ) != LORAMAC_CRYPTO_SUCCESS )
 803523e:	2080      	movs	r0, #128	; 0x80
 8035240:	f001 f846 	bl	80362d0 <LoRaMacCryptoSetKey>
 8035244:	b118      	cbz	r0, 803524e <LoRaMacMcChannelSetup+0x42>
{
 8035246:	2711      	movs	r7, #17
    }

    // Reset multicast channel downlink counter to initial value.
    *Nvm.MacGroup2.MulticastChannelList[channel->GroupID].DownLinkCounter = FCNT_DOWN_INITAL_VALUE;
    return LORAMAC_STATUS_OK;
}
 8035248:	4638      	mov	r0, r7
 803524a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if( LoRaMacCryptoDeriveMcSessionKeyPair( channel->GroupID, channel->Address ) != LORAMAC_CRYPTO_SUCCESS )
 803524e:	6861      	ldr	r1, [r4, #4]
 8035250:	78e0      	ldrb	r0, [r4, #3]
 8035252:	f001 f8c5 	bl	80363e0 <LoRaMacCryptoDeriveMcSessionKeyPair>
        if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( mcNwkSKeys[channel->GroupID], channel->McKeys.Session.McNwkSKey ) )
 8035256:	2800      	cmp	r0, #0
 8035258:	d1f5      	bne.n	8035246 <LoRaMacMcChannelSetup+0x3a>
    if( channel->Class == CLASS_B )
 803525a:	7863      	ldrb	r3, [r4, #1]
 803525c:	2b01      	cmp	r3, #1
 803525e:	d107      	bne.n	8035270 <LoRaMacMcChannelSetup+0x64>
        LoRaMacClassBSetMulticastPeriodicity( &Nvm.MacGroup2.MulticastChannelList[channel->GroupID] );
 8035260:	78e0      	ldrb	r0, [r4, #3]
 8035262:	4b10      	ldr	r3, [pc, #64]	; (80352a4 <LoRaMacMcChannelSetup+0x98>)
 8035264:	222c      	movs	r2, #44	; 0x2c
 8035266:	fb02 3000 	mla	r0, r2, r0, r3
 803526a:	30d0      	adds	r0, #208	; 0xd0
 803526c:	f000 fbba 	bl	80359e4 <LoRaMacClassBSetMulticastPeriodicity>
    *Nvm.MacGroup2.MulticastChannelList[channel->GroupID].DownLinkCounter = FCNT_DOWN_INITAL_VALUE;
 8035270:	78e3      	ldrb	r3, [r4, #3]
 8035272:	222c      	movs	r2, #44	; 0x2c
 8035274:	fb02 8803 	mla	r8, r2, r3, r8
 8035278:	f04f 32ff 	mov.w	r2, #4294967295
 803527c:	f8d8 35fc 	ldr.w	r3, [r8, #1532]	; 0x5fc
 8035280:	601a      	str	r2, [r3, #0]
    return LORAMAC_STATUS_OK;
 8035282:	e7e1      	b.n	8035248 <LoRaMacMcChannelSetup+0x3c>
        if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( mcAppSKeys[channel->GroupID], channel->McKeys.Session.McAppSKey ) )
 8035284:	2081      	movs	r0, #129	; 0x81
 8035286:	f001 f823 	bl	80362d0 <LoRaMacCryptoSetKey>
 803528a:	2800      	cmp	r0, #0
 803528c:	d1db      	bne.n	8035246 <LoRaMacMcChannelSetup+0x3a>
        if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( mcNwkSKeys[channel->GroupID], channel->McKeys.Session.McNwkSKey ) )
 803528e:	68e1      	ldr	r1, [r4, #12]
 8035290:	2082      	movs	r0, #130	; 0x82
 8035292:	f001 f81d 	bl	80362d0 <LoRaMacCryptoSetKey>
 8035296:	e7de      	b.n	8035256 <LoRaMacMcChannelSetup+0x4a>
        return LORAMAC_STATUS_BUSY;
 8035298:	2701      	movs	r7, #1
 803529a:	e7d5      	b.n	8035248 <LoRaMacMcChannelSetup+0x3c>
        return LORAMAC_STATUS_MC_GROUP_UNDEFINED;
 803529c:	2716      	movs	r7, #22
 803529e:	e7d3      	b.n	8035248 <LoRaMacMcChannelSetup+0x3c>
 80352a0:	20004aa4 	.word	0x20004aa4
 80352a4:	20004fb0 	.word	0x20004fb0

080352a8 <LoRaMacMcChannelDelete>:

LoRaMacStatus_t LoRaMacMcChannelDelete( AddressIdentifier_t groupID )
{
 80352a8:	b570      	push	{r4, r5, r6, lr}
    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 80352aa:	4c10      	ldr	r4, [pc, #64]	; (80352ec <LoRaMacMcChannelDelete+0x44>)
 80352ac:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 80352b0:	079b      	lsls	r3, r3, #30
{
 80352b2:	b088      	sub	sp, #32
 80352b4:	4606      	mov	r6, r0
    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 80352b6:	d414      	bmi.n	80352e2 <LoRaMacMcChannelDelete+0x3a>
    {
        return LORAMAC_STATUS_BUSY;
    }

    if( ( groupID >= LORAMAC_MAX_MC_CTX ) ||
 80352b8:	b9a8      	cbnz	r0, 80352e6 <LoRaMacMcChannelDelete+0x3e>
 80352ba:	f894 35de 	ldrb.w	r3, [r4, #1502]	; 0x5de
 80352be:	b193      	cbz	r3, 80352e6 <LoRaMacMcChannelDelete+0x3e>
    }

    McChannelParams_t channel;

    // Set all channel fields with 0
    memset1( ( uint8_t* )&channel, 0, sizeof( McChannelParams_t ) );
 80352c0:	4601      	mov	r1, r0
 80352c2:	2220      	movs	r2, #32
 80352c4:	4668      	mov	r0, sp

    Nvm.MacGroup2.MulticastChannelList[groupID].ChannelParams = channel;
 80352c6:	466d      	mov	r5, sp
    memset1( ( uint8_t* )&channel, 0, sizeof( McChannelParams_t ) );
 80352c8:	f003 fe44 	bl	8038f54 <memset1>
    Nvm.MacGroup2.MulticastChannelList[groupID].ChannelParams = channel;
 80352cc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80352ce:	f204 54dc 	addw	r4, r4, #1500	; 0x5dc
 80352d2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80352d4:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 80352d8:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    return LORAMAC_STATUS_OK;
}
 80352dc:	4630      	mov	r0, r6
 80352de:	b008      	add	sp, #32
 80352e0:	bd70      	pop	{r4, r5, r6, pc}
        return LORAMAC_STATUS_BUSY;
 80352e2:	2601      	movs	r6, #1
 80352e4:	e7fa      	b.n	80352dc <LoRaMacMcChannelDelete+0x34>
        return LORAMAC_STATUS_MC_GROUP_UNDEFINED;
 80352e6:	2616      	movs	r6, #22
 80352e8:	e7f8      	b.n	80352dc <LoRaMacMcChannelDelete+0x34>
 80352ea:	bf00      	nop
 80352ec:	20004aa4 	.word	0x20004aa4

080352f0 <LoRaMacMcChannelGetGroupId>:

uint8_t LoRaMacMcChannelGetGroupId( uint32_t mcAddress )
{
    for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
    {
        if( mcAddress == Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.Address )
 80352f0:	4b03      	ldr	r3, [pc, #12]	; (8035300 <LoRaMacMcChannelGetGroupId+0x10>)
 80352f2:	f8d3 35e0 	ldr.w	r3, [r3, #1504]	; 0x5e0
        {
            return i;
        }
    }
    return 0xFF;
}
 80352f6:	4283      	cmp	r3, r0
 80352f8:	bf14      	ite	ne
 80352fa:	20ff      	movne	r0, #255	; 0xff
 80352fc:	2000      	moveq	r0, #0
 80352fe:	4770      	bx	lr
 8035300:	20004aa4 	.word	0x20004aa4

08035304 <LoRaMacMcChannelSetupRxParams>:

LoRaMacStatus_t LoRaMacMcChannelSetupRxParams( AddressIdentifier_t groupID, McRxParams_t *rxParams, uint8_t *status )
{
   *status = 0x1C + ( groupID & 0x03 );
 8035304:	f000 0303 	and.w	r3, r0, #3
{
 8035308:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   *status = 0x1C + ( groupID & 0x03 );
 803530a:	331c      	adds	r3, #28

    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 803530c:	4e24      	ldr	r6, [pc, #144]	; (80353a0 <LoRaMacMcChannelSetupRxParams+0x9c>)
   *status = 0x1C + ( groupID & 0x03 );
 803530e:	7013      	strb	r3, [r2, #0]
{
 8035310:	4615      	mov	r5, r2
    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 8035312:	f8d6 2344 	ldr.w	r2, [r6, #836]	; 0x344
 8035316:	0792      	lsls	r2, r2, #30
{
 8035318:	4604      	mov	r4, r0
 803531a:	460f      	mov	r7, r1
    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 803531c:	d439      	bmi.n	8035392 <LoRaMacMcChannelSetupRxParams+0x8e>
    {
        return LORAMAC_STATUS_BUSY;
    }

    DeviceClass_t devClass = Nvm.MacGroup2.MulticastChannelList[groupID].ChannelParams.Class;
 803531e:	222c      	movs	r2, #44	; 0x2c
 8035320:	fb02 6200 	mla	r2, r2, r0, r6
 8035324:	f892 25dd 	ldrb.w	r2, [r2, #1501]	; 0x5dd
    if( ( devClass == CLASS_A ) || ( devClass > CLASS_C ) )
 8035328:	1e51      	subs	r1, r2, #1
 803532a:	2901      	cmp	r1, #1
 803532c:	d833      	bhi.n	8035396 <LoRaMacMcChannelSetupRxParams+0x92>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }

    if( ( groupID >= LORAMAC_MAX_MC_CTX ) ||
 803532e:	bba0      	cbnz	r0, 803539a <LoRaMacMcChannelSetupRxParams+0x96>
 8035330:	f896 15de 	ldrb.w	r1, [r6, #1502]	; 0x5de
 8035334:	b389      	cbz	r1, 803539a <LoRaMacMcChannelSetupRxParams+0x96>
        ( Nvm.MacGroup2.MulticastChannelList[groupID].ChannelParams.IsEnabled == false ) )
    {
        return LORAMAC_STATUS_MC_GROUP_UNDEFINED;
    }
    *status &= 0x0F; // groupID OK
 8035336:	f003 030f 	and.w	r3, r3, #15
 803533a:	702b      	strb	r3, [r5, #0]

    VerifyParams_t verify;
    // Check datarate
    if( devClass == CLASS_B )
    {
        verify.DatarateParams.Datarate = rxParams->ClassB.Datarate;
 803533c:	f997 3004 	ldrsb.w	r3, [r7, #4]
 8035340:	f88d 3004 	strb.w	r3, [sp, #4]
    {
        verify.DatarateParams.Datarate = rxParams->ClassC.Datarate;
    }
    verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;

    if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 8035344:	f896 054c 	ldrb.w	r0, [r6, #1356]	; 0x54c
    verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 8035348:	f896 3581 	ldrb.w	r3, [r6, #1409]	; 0x581
 803534c:	f88d 3005 	strb.w	r3, [sp, #5]
    if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 8035350:	2207      	movs	r2, #7
 8035352:	a901      	add	r1, sp, #4
 8035354:	f001 fa09 	bl	803676a <RegionVerify>
 8035358:	b118      	cbz	r0, 8035362 <LoRaMacMcChannelSetupRxParams+0x5e>
    {
        *status &= 0xFB; // datarate OK
 803535a:	782b      	ldrb	r3, [r5, #0]
 803535c:	f023 0304 	bic.w	r3, r3, #4
 8035360:	702b      	strb	r3, [r5, #0]
    }

    // Check frequency
    if( devClass == CLASS_B )
 8035362:	683b      	ldr	r3, [r7, #0]
    }
    else
    {
        verify.Frequency = rxParams->ClassC.Frequency;
    }
    if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_FREQUENCY ) == true )
 8035364:	f896 054c 	ldrb.w	r0, [r6, #1356]	; 0x54c
 8035368:	9301      	str	r3, [sp, #4]
 803536a:	2200      	movs	r2, #0
 803536c:	a901      	add	r1, sp, #4
 803536e:	f001 f9fc 	bl	803676a <RegionVerify>
 8035372:	b118      	cbz	r0, 803537c <LoRaMacMcChannelSetupRxParams+0x78>
    {
        *status &= 0xF7; // frequency OK
 8035374:	782b      	ldrb	r3, [r5, #0]
 8035376:	f023 0308 	bic.w	r3, r3, #8
 803537a:	702b      	strb	r3, [r5, #0]
    }

    if( *status == ( groupID & 0x03 ) )
 803537c:	782b      	ldrb	r3, [r5, #0]
 803537e:	b92b      	cbnz	r3, 803538c <LoRaMacMcChannelSetupRxParams+0x88>
    {
        // Apply parameters
        Nvm.MacGroup2.MulticastChannelList[groupID].ChannelParams.RxParams = *rxParams;
 8035380:	e897 0003 	ldmia.w	r7, {r0, r1}
 8035384:	4a07      	ldr	r2, [pc, #28]	; (80353a4 <LoRaMacMcChannelSetupRxParams+0xa0>)
 8035386:	e882 0003 	stmia.w	r2, {r0, r1}
    }
    return LORAMAC_STATUS_OK;
 803538a:	461c      	mov	r4, r3
}
 803538c:	4620      	mov	r0, r4
 803538e:	b003      	add	sp, #12
 8035390:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return LORAMAC_STATUS_BUSY;
 8035392:	2401      	movs	r4, #1
 8035394:	e7fa      	b.n	803538c <LoRaMacMcChannelSetupRxParams+0x88>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 8035396:	2403      	movs	r4, #3
 8035398:	e7f8      	b.n	803538c <LoRaMacMcChannelSetupRxParams+0x88>
        return LORAMAC_STATUS_MC_GROUP_UNDEFINED;
 803539a:	2416      	movs	r4, #22
 803539c:	e7f6      	b.n	803538c <LoRaMacMcChannelSetupRxParams+0x88>
 803539e:	bf00      	nop
 80353a0:	20004aa4 	.word	0x20004aa4
 80353a4:	20005098 	.word	0x20005098

080353a8 <LoRaMacMlmeRequest>:

LoRaMacStatus_t LoRaMacMlmeRequest( MlmeReq_t* mlmeRequest )
{
 80353a8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80353aa:	b087      	sub	sp, #28
    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;
    MlmeConfirmQueue_t queueElement;
    uint8_t macCmdPayload[2] = { 0x00, 0x00 };
 80353ac:	2300      	movs	r3, #0
 80353ae:	f8ad 3000 	strh.w	r3, [sp]

    if( mlmeRequest == NULL )
 80353b2:	4606      	mov	r6, r0
 80353b4:	2800      	cmp	r0, #0
 80353b6:	f000 80df 	beq.w	8035578 <LoRaMacMlmeRequest+0x1d0>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }
    if( LoRaMacIsBusy( ) == true )
 80353ba:	f7fe fd5d 	bl	8033e78 <LoRaMacIsBusy>
 80353be:	b118      	cbz	r0, 80353c8 <LoRaMacMlmeRequest+0x20>
    {
        return LORAMAC_STATUS_BUSY;
 80353c0:	2501      	movs	r5, #1
    else
    {
        LoRaMacConfirmQueueAdd( &queueElement );
    }
    return status;
}
 80353c2:	4628      	mov	r0, r5
 80353c4:	b007      	add	sp, #28
 80353c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if( LoRaMacConfirmQueueIsFull( ) == true )
 80353c8:	f000 fcf4 	bl	8035db4 <LoRaMacConfirmQueueIsFull>
 80353cc:	2800      	cmp	r0, #0
 80353ce:	d1f7      	bne.n	80353c0 <LoRaMacMlmeRequest+0x18>
    if( LoRaMacConfirmQueueGetCnt( ) == 0 )
 80353d0:	f000 fcea 	bl	8035da8 <LoRaMacConfirmQueueGetCnt>
 80353d4:	4601      	mov	r1, r0
 80353d6:	b918      	cbnz	r0, 80353e0 <LoRaMacMlmeRequest+0x38>
        memset1( ( uint8_t* ) &MacCtx.MlmeConfirm, 0, sizeof( MacCtx.MlmeConfirm ) );
 80353d8:	4868      	ldr	r0, [pc, #416]	; (803557c <LoRaMacMlmeRequest+0x1d4>)
 80353da:	2214      	movs	r2, #20
 80353dc:	f003 fdba 	bl	8038f54 <memset1>
    MacCtx.MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 80353e0:	4c67      	ldr	r4, [pc, #412]	; (8035580 <LoRaMacMlmeRequest+0x1d8>)
    MacCtx.MacFlags.Bits.MlmeReq = 1;
 80353e2:	f894 2485 	ldrb.w	r2, [r4, #1157]	; 0x485
    MacCtx.MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 80353e6:	2301      	movs	r3, #1
    MacCtx.MacFlags.Bits.MlmeReq = 1;
 80353e8:	f042 0204 	orr.w	r2, r2, #4
    MacCtx.MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 80353ec:	f884 3451 	strb.w	r3, [r4, #1105]	; 0x451
    MacCtx.MacFlags.Bits.MlmeReq = 1;
 80353f0:	f884 2485 	strb.w	r2, [r4, #1157]	; 0x485
    queueElement.Request = mlmeRequest->Type;
 80353f4:	7832      	ldrb	r2, [r6, #0]
 80353f6:	f88d 2004 	strb.w	r2, [sp, #4]
    queueElement.RestrictCommonReadyToHandle = false;
 80353fa:	2100      	movs	r1, #0
 80353fc:	3a01      	subs	r2, #1
    queueElement.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 80353fe:	f88d 3005 	strb.w	r3, [sp, #5]
    queueElement.RestrictCommonReadyToHandle = false;
 8035402:	f88d 1007 	strb.w	r1, [sp, #7]
    switch( mlmeRequest->Type )
 8035406:	2a0d      	cmp	r2, #13
 8035408:	f200 80ae 	bhi.w	8035568 <LoRaMacMlmeRequest+0x1c0>
 803540c:	e8df f002 	tbb	[pc, r2]
 8035410:	57acac07 	.word	0x57acac07
 8035414:	acac8261 	.word	0xacac8261
 8035418:	a0ac8aac 	.word	0xa0ac8aac
 803541c:	9c8e      	.short	0x9c8e
            if( ( MacCtx.MacState & LORAMAC_TX_DELAYED ) == LORAMAC_TX_DELAYED )
 803541e:	f8d4 5344 	ldr.w	r5, [r4, #836]	; 0x344
 8035422:	f015 0520 	ands.w	r5, r5, #32
 8035426:	d1cb      	bne.n	80353c0 <LoRaMacMlmeRequest+0x18>
            ResetMacParameters( );
 8035428:	f7fd ff3a 	bl	80332a0 <ResetMacParameters>
            Nvm.MacGroup1.ChannelsDatarate = RegionAlternateDr( Nvm.MacGroup2.Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR );
 803542c:	462a      	mov	r2, r5
 803542e:	f996 1004 	ldrsb.w	r1, [r6, #4]
 8035432:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
            MacCtx.TxMsg.Message.JoinReq.Buffer = MacCtx.PktBuffer;
 8035436:	4f53      	ldr	r7, [pc, #332]	; (8035584 <LoRaMacMlmeRequest+0x1dc>)
            Nvm.MacGroup1.ChannelsDatarate = RegionAlternateDr( Nvm.MacGroup2.Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR );
 8035438:	f001 fa32 	bl	80368a0 <RegionAlternateDr>
            queueElement.Status = LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL;
 803543c:	2307      	movs	r3, #7
            Nvm.MacGroup1.ChannelsDatarate = RegionAlternateDr( Nvm.MacGroup2.Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR );
 803543e:	f884 0545 	strb.w	r0, [r4, #1349]	; 0x545
            SwitchClass( CLASS_A );
 8035442:	4628      	mov	r0, r5
            queueElement.Status = LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL;
 8035444:	f88d 3005 	strb.w	r3, [sp, #5]
            SwitchClass( CLASS_A );
 8035448:	f7fe f988 	bl	803375c <SwitchClass>
            MacCtx.TxMsg.Message.JoinReq.BufSize = LORAMAC_PHY_MAXPAYLOAD;
 803544c:	23ff      	movs	r3, #255	; 0xff
 803544e:	f884 3110 	strb.w	r3, [r4, #272]	; 0x110
            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_JOIN_REQUEST;
 8035452:	f884 5108 	strb.w	r5, [r4, #264]	; 0x108
            MacCtx.TxMsg.Message.JoinReq.MHDR.Value = macHdr.Value;
 8035456:	f884 5111 	strb.w	r5, [r4, #273]	; 0x111
            MacCtx.TxMsg.Message.JoinReq.Buffer = MacCtx.PktBuffer;
 803545a:	f8c4 710c 	str.w	r7, [r4, #268]	; 0x10c
            memcpy1( MacCtx.TxMsg.Message.JoinReq.JoinEUI, SecureElementGetJoinEui( ), LORAMAC_JOIN_EUI_FIELD_SIZE );
 803545e:	f003 fd3d 	bl	8038edc <SecureElementGetJoinEui>
 8035462:	2208      	movs	r2, #8
 8035464:	4601      	mov	r1, r0
 8035466:	f507 7086 	add.w	r0, r7, #268	; 0x10c
 803546a:	f003 fd5f 	bl	8038f2c <memcpy1>
            memcpy1( MacCtx.TxMsg.Message.JoinReq.DevEUI, SecureElementGetDevEui( ), LORAMAC_DEV_EUI_FIELD_SIZE );
 803546e:	f003 fd1f 	bl	8038eb0 <SecureElementGetDevEui>
 8035472:	2208      	movs	r2, #8
 8035474:	4601      	mov	r1, r0
 8035476:	f507 708a 	add.w	r0, r7, #276	; 0x114
 803547a:	f003 fd57 	bl	8038f2c <memcpy1>
    status = ScheduleTx( allowDelayedTx );
 803547e:	4628      	mov	r0, r5
 8035480:	f7fd ffa2 	bl	80333c8 <ScheduleTx>
            if( status != LORAMAC_STATUS_OK )
 8035484:	4605      	mov	r5, r0
 8035486:	b140      	cbz	r0, 803549a <LoRaMacMlmeRequest+0xf2>
                Nvm.MacGroup1.ChannelsDatarate = RegionAlternateDr( Nvm.MacGroup2.Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR_RESTORE );
 8035488:	f996 1004 	ldrsb.w	r1, [r6, #4]
 803548c:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
 8035490:	2201      	movs	r2, #1
 8035492:	f001 fa05 	bl	80368a0 <RegionAlternateDr>
 8035496:	f884 0545 	strb.w	r0, [r4, #1349]	; 0x545
    mlmeRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;
 803549a:	f8d4 3488 	ldr.w	r3, [r4, #1160]	; 0x488
 803549e:	6133      	str	r3, [r6, #16]
    if( status != LORAMAC_STATUS_OK )
 80354a0:	2d00      	cmp	r5, #0
 80354a2:	d065      	beq.n	8035570 <LoRaMacMlmeRequest+0x1c8>
        if( LoRaMacConfirmQueueGetCnt( ) == 0 )
 80354a4:	f000 fc80 	bl	8035da8 <LoRaMacConfirmQueueGetCnt>
 80354a8:	2800      	cmp	r0, #0
 80354aa:	d18a      	bne.n	80353c2 <LoRaMacMlmeRequest+0x1a>
            MacCtx.MacFlags.Bits.MlmeReq = 0;
 80354ac:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
            MacCtx.NodeAckRequested = false;
 80354b0:	f884 0418 	strb.w	r0, [r4, #1048]	; 0x418
            MacCtx.MacFlags.Bits.MlmeReq = 0;
 80354b4:	f360 0382 	bfi	r3, r0, #2, #1
 80354b8:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
 80354bc:	e781      	b.n	80353c2 <LoRaMacMlmeRequest+0x1a>
            if( LoRaMacCommandsAddCmd( MOTE_MAC_LINK_CHECK_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )
 80354be:	2200      	movs	r2, #0
 80354c0:	4669      	mov	r1, sp
 80354c2:	2002      	movs	r0, #2
 80354c4:	f000 fa9e 	bl	8035a04 <LoRaMacCommandsAddCmd>
 80354c8:	b908      	cbnz	r0, 80354ce <LoRaMacMlmeRequest+0x126>
            status = SetTxContinuousWave( mlmeRequest->Req.TxCw.Timeout );
 80354ca:	2500      	movs	r5, #0
            break;
 80354cc:	e7e5      	b.n	803549a <LoRaMacMlmeRequest+0xf2>
                status = LORAMAC_STATUS_MAC_COMMAD_ERROR;
 80354ce:	2513      	movs	r5, #19
 80354d0:	e7e3      	b.n	803549a <LoRaMacMlmeRequest+0xf2>
    continuousWave.Channel = MacCtx.Channel;
 80354d2:	f894 2419 	ldrb.w	r2, [r4, #1049]	; 0x419
 80354d6:	f88d 2008 	strb.w	r2, [sp, #8]
    continuousWave.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 80354da:	f894 2545 	ldrb.w	r2, [r4, #1349]	; 0x545
 80354de:	f88d 2009 	strb.w	r2, [sp, #9]
    continuousWave.TxPower = Nvm.MacGroup1.ChannelsTxPower;
 80354e2:	f894 2544 	ldrb.w	r2, [r4, #1348]	; 0x544
 80354e6:	f88d 200a 	strb.w	r2, [sp, #10]
    continuousWave.MaxEirp = Nvm.MacGroup2.MacParams.MaxEirp;
 80354ea:	f8d4 2584 	ldr.w	r2, [r4, #1412]	; 0x584
            status = SetTxContinuousWave( mlmeRequest->Req.TxCw.Timeout );
 80354ee:	88b3      	ldrh	r3, [r6, #4]
    continuousWave.MaxEirp = Nvm.MacGroup2.MacParams.MaxEirp;
 80354f0:	9203      	str	r2, [sp, #12]
    RegionSetContinuousWave( Nvm.MacGroup2.Region, &continuousWave );
 80354f2:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    continuousWave.AntennaGain = Nvm.MacGroup2.MacParams.AntennaGain;
 80354f6:	f8d4 2588 	ldr.w	r2, [r4, #1416]	; 0x588
 80354fa:	9204      	str	r2, [sp, #16]
    RegionSetContinuousWave( Nvm.MacGroup2.Region, &continuousWave );
 80354fc:	a902      	add	r1, sp, #8
    continuousWave.Timeout = timeout;
 80354fe:	f8ad 3014 	strh.w	r3, [sp, #20]
    RegionSetContinuousWave( Nvm.MacGroup2.Region, &continuousWave );
 8035502:	f001 f9ed 	bl	80368e0 <RegionSetContinuousWave>
    MacCtx.MacState |= LORAMAC_TX_RUNNING;
 8035506:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 803550a:	f043 0302 	orr.w	r3, r3, #2
 803550e:	f8c4 3344 	str.w	r3, [r4, #836]	; 0x344
 8035512:	e7da      	b.n	80354ca <LoRaMacMlmeRequest+0x122>
    Radio.SetTxContinuousWave( frequency, power, timeout );
 8035514:	4b1c      	ldr	r3, [pc, #112]	; (8035588 <LoRaMacMlmeRequest+0x1e0>)
 8035516:	88b2      	ldrh	r2, [r6, #4]
 8035518:	f996 100c 	ldrsb.w	r1, [r6, #12]
 803551c:	68b0      	ldr	r0, [r6, #8]
 803551e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8035520:	4798      	blx	r3
    MacCtx.MacState |= LORAMAC_TX_RUNNING;
 8035522:	e7f0      	b.n	8035506 <LoRaMacMlmeRequest+0x15e>
            if( LoRaMacCommandsAddCmd( MOTE_MAC_DEVICE_TIME_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )
 8035524:	2200      	movs	r2, #0
 8035526:	4669      	mov	r1, sp
 8035528:	200d      	movs	r0, #13
 803552a:	e7cb      	b.n	80354c4 <LoRaMacMlmeRequest+0x11c>
            if( Nvm.MacGroup2.DeviceClass == CLASS_A )
 803552c:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 8035530:	b9d3      	cbnz	r3, 8035568 <LoRaMacMlmeRequest+0x1c0>
                uint8_t value = mlmeRequest->Req.PingSlotInfo.PingSlot.Value;
 8035532:	7935      	ldrb	r5, [r6, #4]
                LoRaMacClassBSetPingSlotInfo( mlmeRequest->Req.PingSlotInfo.PingSlot.Fields.Periodicity );
 8035534:	f005 0007 	and.w	r0, r5, #7
 8035538:	f000 fa41 	bl	80359be <LoRaMacClassBSetPingSlotInfo>
                macCmdPayload[0] = value;
 803553c:	f88d 5000 	strb.w	r5, [sp]
                if( LoRaMacCommandsAddCmd( MOTE_MAC_PING_SLOT_INFO_REQ, macCmdPayload, 1 ) != LORAMAC_COMMANDS_SUCCESS )
 8035540:	2201      	movs	r2, #1
 8035542:	4669      	mov	r1, sp
 8035544:	2010      	movs	r0, #16
 8035546:	e7bd      	b.n	80354c4 <LoRaMacMlmeRequest+0x11c>
            if( LoRaMacCommandsAddCmd( MOTE_MAC_BEACON_TIMING_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )
 8035548:	2200      	movs	r2, #0
 803554a:	4669      	mov	r1, sp
 803554c:	2012      	movs	r0, #18
 803554e:	e7b9      	b.n	80354c4 <LoRaMacMlmeRequest+0x11c>
            queueElement.RestrictCommonReadyToHandle = true;
 8035550:	f88d 3007 	strb.w	r3, [sp, #7]
            if( LoRaMacClassBIsAcquisitionInProgress( ) == false )
 8035554:	f000 fa24 	bl	80359a0 <LoRaMacClassBIsAcquisitionInProgress>
 8035558:	4605      	mov	r5, r0
 803555a:	b938      	cbnz	r0, 803556c <LoRaMacMlmeRequest+0x1c4>
                LoRaMacClassBSetBeaconState( BEACON_STATE_ACQUISITION );
 803555c:	f000 fa1d 	bl	803599a <LoRaMacClassBSetBeaconState>
                LoRaMacClassBBeaconTimerEvent( NULL );
 8035560:	4628      	mov	r0, r5
 8035562:	f000 fa1f 	bl	80359a4 <LoRaMacClassBBeaconTimerEvent>
                status = LORAMAC_STATUS_OK;
 8035566:	e798      	b.n	803549a <LoRaMacMlmeRequest+0xf2>
    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;
 8035568:	2502      	movs	r5, #2
 803556a:	e796      	b.n	803549a <LoRaMacMlmeRequest+0xf2>
                status = LORAMAC_STATUS_BUSY;
 803556c:	2501      	movs	r5, #1
 803556e:	e794      	b.n	803549a <LoRaMacMlmeRequest+0xf2>
        LoRaMacConfirmQueueAdd( &queueElement );
 8035570:	a801      	add	r0, sp, #4
 8035572:	f000 fb6f 	bl	8035c54 <LoRaMacConfirmQueueAdd>
 8035576:	e724      	b.n	80353c2 <LoRaMacMlmeRequest+0x1a>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 8035578:	2503      	movs	r5, #3
 803557a:	e722      	b.n	80353c2 <LoRaMacMlmeRequest+0x1a>
 803557c:	20004ef4 	.word	0x20004ef4
 8035580:	20004aa4 	.word	0x20004aa4
 8035584:	20004aaa 	.word	0x20004aaa
 8035588:	0803bc30 	.word	0x0803bc30

0803558c <LoRaMacMcpsRequest>:

/* ST_WORKAROUND_BEGIN: Update MCPS request with new input parameter to allow delayed tx */
LoRaMacStatus_t LoRaMacMcpsRequest( McpsReq_t* mcpsRequest, bool allowDelayedTx )
{
 803558c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8035590:	b08f      	sub	sp, #60	; 0x3c
 8035592:	2600      	movs	r6, #0
 8035594:	9101      	str	r1, [sp, #4]
    /* ST_WORKAROUND_END */
    uint16_t fBufferSize;
    int8_t datarate = DR_0;
    bool readyToSend = false;

    if( mcpsRequest == NULL )
 8035596:	4605      	mov	r5, r0
 8035598:	b918      	cbnz	r0, 80355a2 <LoRaMacMcpsRequest+0x16>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
 803559a:	2003      	movs	r0, #3

    // Fill return structure
    mcpsRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;

    return status;
}
 803559c:	b00f      	add	sp, #60	; 0x3c
 803559e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( LoRaMacIsBusy( ) == true )
 80355a2:	f7fe fc69 	bl	8033e78 <LoRaMacIsBusy>
 80355a6:	4680      	mov	r8, r0
 80355a8:	2800      	cmp	r0, #0
 80355aa:	f040 815f 	bne.w	803586c <LoRaMacMcpsRequest+0x2e0>
    memset1( ( uint8_t* ) &MacCtx.McpsConfirm, 0, sizeof( MacCtx.McpsConfirm ) );
 80355ae:	4cb5      	ldr	r4, [pc, #724]	; (8035884 <LoRaMacMcpsRequest+0x2f8>)
 80355b0:	4601      	mov	r1, r0
    macHdr.Value = 0;
 80355b2:	4607      	mov	r7, r0
    memset1( ( uint8_t* ) &MacCtx.McpsConfirm, 0, sizeof( MacCtx.McpsConfirm ) );
 80355b4:	2214      	movs	r2, #20
 80355b6:	f204 403c 	addw	r0, r4, #1084	; 0x43c
 80355ba:	f003 fccb 	bl	8038f54 <memset1>
    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 80355be:	2101      	movs	r1, #1
 80355c0:	f884 143d 	strb.w	r1, [r4, #1085]	; 0x43d
    MacCtx.AckTimeoutRetriesCounter = 1;
 80355c4:	f884 1416 	strb.w	r1, [r4, #1046]	; 0x416
    switch( mcpsRequest->Type )
 80355c8:	7828      	ldrb	r0, [r5, #0]
 80355ca:	4288      	cmp	r0, r1
 80355cc:	f000 80ac 	beq.w	8035728 <LoRaMacMcpsRequest+0x19c>
 80355d0:	2803      	cmp	r0, #3
 80355d2:	f000 80bb 	beq.w	803574c <LoRaMacMcpsRequest+0x1c0>
 80355d6:	2800      	cmp	r0, #0
 80355d8:	f040 80c5 	bne.w	8035766 <LoRaMacMcpsRequest+0x1da>
            MacCtx.AckTimeoutRetries = 1;
 80355dc:	f884 1415 	strb.w	r1, [r4, #1045]	; 0x415
            macHdr.Bits.MType = FRAME_TYPE_DATA_UNCONFIRMED_UP;
 80355e0:	2302      	movs	r3, #2
            fPort = mcpsRequest->Req.Unconfirmed.fPort;
 80355e2:	f895 a004 	ldrb.w	sl, [r5, #4]
            fBuffer = mcpsRequest->Req.Unconfirmed.fBuffer;
 80355e6:	f8d5 9008 	ldr.w	r9, [r5, #8]
            fBufferSize = mcpsRequest->Req.Unconfirmed.fBufferSize;
 80355ea:	89ae      	ldrh	r6, [r5, #12]
            datarate = mcpsRequest->Req.Unconfirmed.Datarate;
 80355ec:	f995 b00e 	ldrsb.w	fp, [r5, #14]
            macHdr.Bits.MType = FRAME_TYPE_DATA_UNCONFIRMED_UP;
 80355f0:	f363 1747 	bfi	r7, r3, #5, #3
            readyToSend = true;
 80355f4:	4688      	mov	r8, r1
    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 80355f6:	f894 1580 	ldrb.w	r1, [r4, #1408]	; 0x580
 80355fa:	f88d 101e 	strb.w	r1, [sp, #30]
    getPhy.Attribute = PHY_MIN_TX_DR;
 80355fe:	2302      	movs	r3, #2
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8035600:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_MIN_TX_DR;
 8035604:	f88d 301c 	strb.w	r3, [sp, #28]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8035608:	a907      	add	r1, sp, #28
 803560a:	f001 f888 	bl	803671e <RegionGetPhyParam>
    if( readyToSend == true )
 803560e:	2302      	movs	r3, #2
 8035610:	f1b8 0f00 	cmp.w	r8, #0
 8035614:	f000 8128 	beq.w	8035868 <LoRaMacMcpsRequest+0x2dc>
        if( Nvm.MacGroup2.AdrCtrlOn == false )
 8035618:	f894 360a 	ldrb.w	r3, [r4, #1546]	; 0x60a
 803561c:	b9ab      	cbnz	r3, 803564a <LoRaMacMcpsRequest+0xbe>
    datarate = MAX( datarate, ( int8_t )phyParam.Value );
 803561e:	b240      	sxtb	r0, r0
 8035620:	4558      	cmp	r0, fp
 8035622:	bfb8      	it	lt
 8035624:	4658      	movlt	r0, fp
            verify.DatarateParams.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8035626:	f894 3580 	ldrb.w	r3, [r4, #1408]	; 0x580
            verify.DatarateParams.Datarate = datarate;
 803562a:	f88d 000c 	strb.w	r0, [sp, #12]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_DR ) == true )
 803562e:	2205      	movs	r2, #5
 8035630:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
            verify.DatarateParams.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8035634:	f88d 300e 	strb.w	r3, [sp, #14]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_DR ) == true )
 8035638:	a903      	add	r1, sp, #12
 803563a:	f001 f896 	bl	803676a <RegionVerify>
 803563e:	2800      	cmp	r0, #0
 8035640:	d0ab      	beq.n	803559a <LoRaMacMcpsRequest+0xe>
                Nvm.MacGroup1.ChannelsDatarate = verify.DatarateParams.Datarate;
 8035642:	f89d 300c 	ldrb.w	r3, [sp, #12]
 8035646:	f884 3545 	strb.w	r3, [r4, #1349]	; 0x545
    int8_t txPower = Nvm.MacGroup1.ChannelsTxPower;
 803564a:	f8b4 2544 	ldrh.w	r2, [r4, #1348]	; 0x544
 803564e:	f8b4 3544 	ldrh.w	r3, [r4, #1348]	; 0x544
 8035652:	9200      	str	r2, [sp, #0]
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 8035654:	f894 261c 	ldrb.w	r2, [r4, #1564]	; 0x61c
    uint32_t adrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 8035658:	f8d4 1534 	ldr.w	r1, [r4, #1332]	; 0x534
 803565c:	9104      	str	r1, [sp, #16]
 803565e:	ba5b      	rev16	r3, r3
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 8035660:	2a00      	cmp	r2, #0
 8035662:	f000 80ff 	beq.w	8035864 <LoRaMacMcpsRequest+0x2d8>
    if( Nvm.MacGroup2.MaxDCycle == 0 )
 8035666:	f894 260b 	ldrb.w	r2, [r4, #1547]	; 0x60b
 803566a:	b90a      	cbnz	r2, 8035670 <LoRaMacMcpsRequest+0xe4>
        Nvm.MacGroup1.AggregatedTimeOff = 0;
 803566c:	f8c4 253c 	str.w	r2, [r4, #1340]	; 0x53c
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 8035670:	f894 2608 	ldrb.w	r2, [r4, #1544]	; 0x608
    fCtrl.Bits.Adr           = Nvm.MacGroup2.AdrCtrlOn;
 8035674:	f894 060a 	ldrb.w	r0, [r4, #1546]	; 0x60a
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 8035678:	f102 3cff 	add.w	ip, r2, #4294967295
    fCtrl.Value = 0;
 803567c:	f04f 0800 	mov.w	r8, #0
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 8035680:	f1dc 0200 	rsbs	r2, ip, #0
 8035684:	eb42 020c 	adc.w	r2, r2, ip
    fCtrl.Bits.Adr           = Nvm.MacGroup2.AdrCtrlOn;
 8035688:	f360 18c7 	bfi	r8, r0, #7, #1
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 803568c:	f362 1804 	bfi	r8, r2, #4, #1
    if( Nvm.MacGroup1.SrvAckRequested == true )
 8035690:	f894 2546 	ldrb.w	r2, [r4, #1350]	; 0x546
 8035694:	b10a      	cbz	r2, 803569a <LoRaMacMcpsRequest+0x10e>
        fCtrl.Bits.Ack = 1;
 8035696:	f048 0820 	orr.w	r8, r8, #32
    adrNext.Version = Nvm.MacGroup2.Version;
 803569a:	f8d4 2618 	ldr.w	r2, [r4, #1560]	; 0x618
 803569e:	9209      	str	r2, [sp, #36]	; 0x24
    adrNext.AdrAckLimit = MacCtx.AdrAckLimit;
 80356a0:	f8d4 23f8 	ldr.w	r2, [r4, #1016]	; 0x3f8
 80356a4:	920c      	str	r2, [sp, #48]	; 0x30
    adrNext.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 80356a6:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
    fCtrl.Bits.AdrAckReq = LoRaMacAdrCalcNext( &adrNext, &Nvm.MacGroup1.ChannelsDatarate,
 80356aa:	4a77      	ldr	r2, [pc, #476]	; (8035888 <LoRaMacMcpsRequest+0x2fc>)
    adrNext.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 80356ac:	f894 3580 	ldrb.w	r3, [r4, #1408]	; 0x580
 80356b0:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    adrNext.UpdateChanMask = true;
 80356b4:	f04f 0b01 	mov.w	fp, #1
    adrNext.Region = Nvm.MacGroup2.Region;
 80356b8:	f894 354c 	ldrb.w	r3, [r4, #1356]	; 0x54c
    adrNext.AdrEnabled = fCtrl.Bits.Adr;
 80356bc:	f88d 0029 	strb.w	r0, [sp, #41]	; 0x29
    adrNext.AdrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 80356c0:	910b      	str	r1, [sp, #44]	; 0x2c
    adrNext.Region = Nvm.MacGroup2.Region;
 80356c2:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    fCtrl.Bits.AdrAckReq = LoRaMacAdrCalcNext( &adrNext, &Nvm.MacGroup1.ChannelsDatarate,
 80356c6:	eb02 010b 	add.w	r1, r2, fp
 80356ca:	ab04      	add	r3, sp, #16
 80356cc:	a809      	add	r0, sp, #36	; 0x24
    adrNext.UpdateChanMask = true;
 80356ce:	f88d b028 	strb.w	fp, [sp, #40]	; 0x28
    fCtrl.Bits.AdrAckReq = LoRaMacAdrCalcNext( &adrNext, &Nvm.MacGroup1.ChannelsDatarate,
 80356d2:	f000 f8f3 	bl	80358bc <LoRaMacAdrCalcNext>
    MacCtx.PktBufferLen = 0;
 80356d6:	2300      	movs	r3, #0
        fBufferSize = 0;
 80356d8:	4599      	cmp	r9, r3
 80356da:	bf08      	it	eq
 80356dc:	461e      	moveq	r6, r3
    memcpy1( MacCtx.AppData, ( uint8_t* ) fBuffer, fBufferSize );
 80356de:	4632      	mov	r2, r6
    fCtrl.Bits.AdrAckReq = LoRaMacAdrCalcNext( &adrNext, &Nvm.MacGroup1.ChannelsDatarate,
 80356e0:	f360 1886 	bfi	r8, r0, #6, #1
    memcpy1( MacCtx.AppData, ( uint8_t* ) fBuffer, fBufferSize );
 80356e4:	4649      	mov	r1, r9
 80356e6:	4869      	ldr	r0, [pc, #420]	; (803588c <LoRaMacMcpsRequest+0x300>)
    MacCtx.PktBufferLen = 0;
 80356e8:	80a3      	strh	r3, [r4, #4]
    size_t macCmdsSize = 0;
 80356ea:	e9cd 3305 	strd	r3, r3, [sp, #20]
    MacCtx.NodeAckRequested = false;
 80356ee:	f884 3418 	strb.w	r3, [r4, #1048]	; 0x418
    memcpy1( MacCtx.AppData, ( uint8_t* ) fBuffer, fBufferSize );
 80356f2:	f003 fc1b 	bl	8038f2c <memcpy1>
    MacCtx.PktBuffer[0] = macHdr->Value;
 80356f6:	b2fb      	uxtb	r3, r7
 80356f8:	71a7      	strb	r7, [r4, #6]
    switch( macHdr->Bits.MType )
 80356fa:	f3c7 1742 	ubfx	r7, r7, #5, #3
    MacCtx.AppDataSize = fBufferSize;
 80356fe:	b2f2      	uxtb	r2, r6
    switch( macHdr->Bits.MType )
 8035700:	2f04      	cmp	r7, #4
    MacCtx.AppDataSize = fBufferSize;
 8035702:	f884 223b 	strb.w	r2, [r4, #571]	; 0x23b
    switch( macHdr->Bits.MType )
 8035706:	d032      	beq.n	803576e <LoRaMacMcpsRequest+0x1e2>
 8035708:	2f07      	cmp	r7, #7
 803570a:	f000 809b 	beq.w	8035844 <LoRaMacMcpsRequest+0x2b8>
 803570e:	2f02      	cmp	r7, #2
 8035710:	d02f      	beq.n	8035772 <LoRaMacMcpsRequest+0x1e6>
            return LORAMAC_STATUS_SERVICE_UNKNOWN;
 8035712:	2002      	movs	r0, #2
        Nvm.MacGroup1.ChannelsTxPower = txPower;
 8035714:	9b00      	ldr	r3, [sp, #0]
 8035716:	f8a4 3544 	strh.w	r3, [r4, #1348]	; 0x544
            MacCtx.NodeAckRequested = false;
 803571a:	2300      	movs	r3, #0
 803571c:	f884 3418 	strb.w	r3, [r4, #1048]	; 0x418
    mcpsRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;
 8035720:	f8d4 3488 	ldr.w	r3, [r4, #1160]	; 0x488
 8035724:	612b      	str	r3, [r5, #16]
    return status;
 8035726:	e739      	b.n	803559c <LoRaMacMcpsRequest+0x10>
            MacCtx.AckTimeoutRetries = MIN( mcpsRequest->Req.Confirmed.NbTrials, MAX_ACK_RETRIES );
 8035728:	7beb      	ldrb	r3, [r5, #15]
 803572a:	2b08      	cmp	r3, #8
 803572c:	bf28      	it	cs
 803572e:	2308      	movcs	r3, #8
 8035730:	f884 3415 	strb.w	r3, [r4, #1045]	; 0x415
            macHdr.Bits.MType = FRAME_TYPE_DATA_CONFIRMED_UP;
 8035734:	2304      	movs	r3, #4
            fPort = mcpsRequest->Req.Confirmed.fPort;
 8035736:	f895 a004 	ldrb.w	sl, [r5, #4]
            fBuffer = mcpsRequest->Req.Confirmed.fBuffer;
 803573a:	f8d5 9008 	ldr.w	r9, [r5, #8]
            fBufferSize = mcpsRequest->Req.Confirmed.fBufferSize;
 803573e:	89ae      	ldrh	r6, [r5, #12]
            datarate = mcpsRequest->Req.Confirmed.Datarate;
 8035740:	f995 b00e 	ldrsb.w	fp, [r5, #14]
            macHdr.Bits.MType = FRAME_TYPE_DATA_CONFIRMED_UP;
 8035744:	f363 1747 	bfi	r7, r3, #5, #3
            readyToSend = true;
 8035748:	4680      	mov	r8, r0
            break;
 803574a:	e754      	b.n	80355f6 <LoRaMacMcpsRequest+0x6a>
            MacCtx.AckTimeoutRetries = 1;
 803574c:	f884 1415 	strb.w	r1, [r4, #1045]	; 0x415
            fBuffer = mcpsRequest->Req.Proprietary.fBuffer;
 8035750:	f8d5 9004 	ldr.w	r9, [r5, #4]
            fBufferSize = mcpsRequest->Req.Proprietary.fBufferSize;
 8035754:	892e      	ldrh	r6, [r5, #8]
            datarate = mcpsRequest->Req.Proprietary.Datarate;
 8035756:	f995 b00a 	ldrsb.w	fp, [r5, #10]
            macHdr.Bits.MType = FRAME_TYPE_PROPRIETARY;
 803575a:	f067 071f 	orn	r7, r7, #31
            readyToSend = true;
 803575e:	4688      	mov	r8, r1
    uint8_t fPort = 0;
 8035760:	f04f 0a00 	mov.w	sl, #0
            break;
 8035764:	e747      	b.n	80355f6 <LoRaMacMcpsRequest+0x6a>
    switch( mcpsRequest->Type )
 8035766:	46c3      	mov	fp, r8
 8035768:	46c1      	mov	r9, r8
 803576a:	46c2      	mov	sl, r8
 803576c:	e743      	b.n	80355f6 <LoRaMacMcpsRequest+0x6a>
            MacCtx.NodeAckRequested = true;
 803576e:	f884 b418 	strb.w	fp, [r4, #1048]	; 0x418
            MacCtx.TxMsg.Message.Data.Buffer = MacCtx.PktBuffer;
 8035772:	4f47      	ldr	r7, [pc, #284]	; (8035890 <LoRaMacMcpsRequest+0x304>)
            MacCtx.TxMsg.Message.Data.MHDR.Value = macHdr->Value;
 8035774:	f884 3111 	strb.w	r3, [r4, #273]	; 0x111
            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_DATA;
 8035778:	2104      	movs	r1, #4
            MacCtx.TxMsg.Message.Data.FHDR.DevAddr = Nvm.MacGroup2.DevAddr;
 803577a:	f8d4 35d8 	ldr.w	r3, [r4, #1496]	; 0x5d8
            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_DATA;
 803577e:	f884 1108 	strb.w	r1, [r4, #264]	; 0x108
            MacCtx.TxMsg.Message.Data.FHDR.DevAddr = Nvm.MacGroup2.DevAddr;
 8035782:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
            MacCtx.TxMsg.Message.Data.BufSize = LORAMAC_PHY_MAXPAYLOAD;
 8035786:	21ff      	movs	r1, #255	; 0xff
            MacCtx.TxMsg.Message.Data.FRMPayload = MacCtx.AppData;
 8035788:	f507 739b 	add.w	r3, r7, #310	; 0x136
            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetFCntUp( &fCntUp ) )
 803578c:	a805      	add	r0, sp, #20
            MacCtx.TxMsg.Message.Data.Buffer = MacCtx.PktBuffer;
 803578e:	f8c4 710c 	str.w	r7, [r4, #268]	; 0x10c
            MacCtx.TxMsg.Message.Data.BufSize = LORAMAC_PHY_MAXPAYLOAD;
 8035792:	f884 1110 	strb.w	r1, [r4, #272]	; 0x110
            MacCtx.TxMsg.Message.Data.FPort = fPort;
 8035796:	f884 a12c 	strb.w	sl, [r4, #300]	; 0x12c
            MacCtx.TxMsg.Message.Data.FHDR.FCtrl.Value = fCtrl->Value;
 803579a:	f884 8118 	strb.w	r8, [r4, #280]	; 0x118
            MacCtx.TxMsg.Message.Data.FRMPayloadSize = MacCtx.AppDataSize;
 803579e:	f884 2134 	strb.w	r2, [r4, #308]	; 0x134
            MacCtx.TxMsg.Message.Data.FRMPayload = MacCtx.AppData;
 80357a2:	f8c4 3130 	str.w	r3, [r4, #304]	; 0x130
            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetFCntUp( &fCntUp ) )
 80357a6:	f000 fc2b 	bl	8036000 <LoRaMacCryptoGetFCntUp>
 80357aa:	2800      	cmp	r0, #0
 80357ac:	d158      	bne.n	8035860 <LoRaMacMcpsRequest+0x2d4>
            MacCtx.TxMsg.Message.Data.FHDR.FCnt = ( uint16_t )fCntUp;
 80357ae:	9b05      	ldr	r3, [sp, #20]
            MacCtx.McpsConfirm.AckReceived = false;
 80357b0:	f8a4 0440 	strh.w	r0, [r4, #1088]	; 0x440
            if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )
 80357b4:	a806      	add	r0, sp, #24
            MacCtx.TxMsg.Message.Data.FHDR.FCnt = ( uint16_t )fCntUp;
 80357b6:	f8a4 311a 	strh.w	r3, [r4, #282]	; 0x11a
            MacCtx.McpsConfirm.UpLinkCounter = fCntUp;
 80357ba:	f8c4 3448 	str.w	r3, [r4, #1096]	; 0x448
            if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )
 80357be:	f000 f9bb 	bl	8035b38 <LoRaMacCommandsGetSizeSerializedCmds>
 80357c2:	bb68      	cbnz	r0, 8035820 <LoRaMacMcpsRequest+0x294>
            if( macCmdsSize > 0 )
 80357c4:	9b06      	ldr	r3, [sp, #24]
 80357c6:	b1ab      	cbz	r3, 80357f4 <LoRaMacMcpsRequest+0x268>
                availableSize = GetMaxAppPayloadWithoutFOptsLength( Nvm.MacGroup1.ChannelsDatarate );
 80357c8:	f994 0545 	ldrsb.w	r0, [r4, #1349]	; 0x545
 80357cc:	f7fd fc2a 	bl	8033024 <GetMaxAppPayloadWithoutFOptsLength>
                if( ( MacCtx.AppDataSize > 0 ) && ( macCmdsSize <= LORA_MAC_COMMAND_MAX_FOPTS_LENGTH ) )
 80357d0:	f894 323b 	ldrb.w	r3, [r4, #571]	; 0x23b
 80357d4:	b333      	cbz	r3, 8035824 <LoRaMacMcpsRequest+0x298>
 80357d6:	9b06      	ldr	r3, [sp, #24]
 80357d8:	2b0f      	cmp	r3, #15
 80357da:	d81a      	bhi.n	8035812 <LoRaMacMcpsRequest+0x286>
                    if( LoRaMacCommandsSerializeCmds( LORA_MAC_COMMAND_MAX_FOPTS_LENGTH, &macCmdsSize, MacCtx.TxMsg.Message.Data.FHDR.FOpts ) != LORAMAC_COMMANDS_SUCCESS )
 80357dc:	f507 728b 	add.w	r2, r7, #278	; 0x116
 80357e0:	a906      	add	r1, sp, #24
 80357e2:	200f      	movs	r0, #15
 80357e4:	f000 f9b4 	bl	8035b50 <LoRaMacCommandsSerializeCmds>
 80357e8:	b9d0      	cbnz	r0, 8035820 <LoRaMacMcpsRequest+0x294>
                    fCtrl->Bits.FOptsLen = macCmdsSize;
 80357ea:	9b06      	ldr	r3, [sp, #24]
 80357ec:	f363 0803 	bfi	r8, r3, #0, #4
                    MacCtx.TxMsg.Message.Data.FHDR.FCtrl.Value = fCtrl->Value;
 80357f0:	f884 8118 	strb.w	r8, [r4, #280]	; 0x118
        status = ScheduleTx( allowDelayedTx ); /* ST_WORKAROUND: Update Send request with new input parameter to allow delayed tx */
 80357f4:	9801      	ldr	r0, [sp, #4]
 80357f6:	f7fd fde7 	bl	80333c8 <ScheduleTx>
    if( status != LORAMAC_STATUS_OK )
 80357fa:	2800      	cmp	r0, #0
 80357fc:	d18a      	bne.n	8035714 <LoRaMacMcpsRequest+0x188>
        Nvm.MacGroup1.AdrAckCounter = adrAckCounter;
 80357fe:	9b04      	ldr	r3, [sp, #16]
        Nvm.MacGroup1.SrvAckRequested = false;
 8035800:	f884 0546 	strb.w	r0, [r4, #1350]	; 0x546
        Nvm.MacGroup1.AdrAckCounter = adrAckCounter;
 8035804:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
        if( LoRaMacCommandsRemoveNoneStickyCmds( ) != LORAMAC_COMMANDS_SUCCESS )
 8035808:	f000 f976 	bl	8035af8 <LoRaMacCommandsRemoveNoneStickyCmds>
 803580c:	b380      	cbz	r0, 8035870 <LoRaMacMcpsRequest+0x2e4>
            return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 803580e:	2013      	movs	r0, #19
 8035810:	e783      	b.n	803571a <LoRaMacMcpsRequest+0x18e>
                    if( LoRaMacCommandsSerializeCmds( availableSize, &macCmdsSize, MacCtx.MacCommandsBuffer ) != LORAMAC_COMMANDS_SUCCESS )
 8035812:	f207 4286 	addw	r2, r7, #1158	; 0x486
 8035816:	a906      	add	r1, sp, #24
 8035818:	f000 f99a 	bl	8035b50 <LoRaMacCommandsSerializeCmds>
 803581c:	2800      	cmp	r0, #0
 803581e:	d0e9      	beq.n	80357f4 <LoRaMacMcpsRequest+0x268>
                        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 8035820:	2013      	movs	r0, #19
 8035822:	e777      	b.n	8035714 <LoRaMacMcpsRequest+0x188>
                    if( LoRaMacCommandsSerializeCmds( availableSize, &macCmdsSize, MacCtx.MacCommandsBuffer ) != LORAMAC_COMMANDS_SUCCESS )
 8035824:	f207 4786 	addw	r7, r7, #1158	; 0x486
 8035828:	463a      	mov	r2, r7
 803582a:	a906      	add	r1, sp, #24
 803582c:	f000 f990 	bl	8035b50 <LoRaMacCommandsSerializeCmds>
 8035830:	2800      	cmp	r0, #0
 8035832:	d1f5      	bne.n	8035820 <LoRaMacMcpsRequest+0x294>
                    MacCtx.TxMsg.Message.Data.FRMPayloadSize = macCmdsSize;
 8035834:	9b06      	ldr	r3, [sp, #24]
                    MacCtx.TxMsg.Message.Data.FPort = 0;
 8035836:	f884 012c 	strb.w	r0, [r4, #300]	; 0x12c
                    MacCtx.TxMsg.Message.Data.FRMPayload = MacCtx.MacCommandsBuffer;
 803583a:	f8c4 7130 	str.w	r7, [r4, #304]	; 0x130
                    MacCtx.TxMsg.Message.Data.FRMPayloadSize = macCmdsSize;
 803583e:	f884 3134 	strb.w	r3, [r4, #308]	; 0x134
    if( ( status == LORAMAC_STATUS_OK ) || ( status == LORAMAC_STATUS_SKIPPED_APP_DATA ) )
 8035842:	e7d7      	b.n	80357f4 <LoRaMacMcpsRequest+0x268>
            if( ( fBuffer != NULL ) && ( MacCtx.AppDataSize > 0 ) )
 8035844:	f1b9 0f00 	cmp.w	r9, #0
 8035848:	d0d4      	beq.n	80357f4 <LoRaMacMcpsRequest+0x268>
 803584a:	2a00      	cmp	r2, #0
 803584c:	d0d2      	beq.n	80357f4 <LoRaMacMcpsRequest+0x268>
                memcpy1( MacCtx.PktBuffer + LORAMAC_MHDR_FIELD_SIZE, ( uint8_t* ) fBuffer, MacCtx.AppDataSize );
 803584e:	4811      	ldr	r0, [pc, #68]	; (8035894 <LoRaMacMcpsRequest+0x308>)
 8035850:	4649      	mov	r1, r9
 8035852:	f003 fb6b 	bl	8038f2c <memcpy1>
                MacCtx.PktBufferLen = LORAMAC_MHDR_FIELD_SIZE + MacCtx.AppDataSize;
 8035856:	f894 323b 	ldrb.w	r3, [r4, #571]	; 0x23b
 803585a:	3301      	adds	r3, #1
 803585c:	80a3      	strh	r3, [r4, #4]
    if( ( status == LORAMAC_STATUS_OK ) || ( status == LORAMAC_STATUS_SKIPPED_APP_DATA ) )
 803585e:	e7c9      	b.n	80357f4 <LoRaMacMcpsRequest+0x268>
                return LORAMAC_STATUS_FCNT_HANDLER_ERROR;
 8035860:	2012      	movs	r0, #18
 8035862:	e757      	b.n	8035714 <LoRaMacMcpsRequest+0x188>
        return LORAMAC_STATUS_NO_NETWORK_JOINED;
 8035864:	2007      	movs	r0, #7
 8035866:	e758      	b.n	803571a <LoRaMacMcpsRequest+0x18e>
    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;
 8035868:	4618      	mov	r0, r3
 803586a:	e759      	b.n	8035720 <LoRaMacMcpsRequest+0x194>
        return LORAMAC_STATUS_BUSY;
 803586c:	2001      	movs	r0, #1
 803586e:	e695      	b.n	803559c <LoRaMacMcpsRequest+0x10>
            MacCtx.McpsConfirm.McpsRequest = mcpsRequest->Type;
 8035870:	782b      	ldrb	r3, [r5, #0]
 8035872:	f884 343c 	strb.w	r3, [r4, #1084]	; 0x43c
            MacCtx.MacFlags.Bits.McpsReq = 1;
 8035876:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 803587a:	f043 0301 	orr.w	r3, r3, #1
 803587e:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
 8035882:	e74d      	b.n	8035720 <LoRaMacMcpsRequest+0x194>
 8035884:	20004aa4 	.word	0x20004aa4
 8035888:	20004fe8 	.word	0x20004fe8
 803588c:	20004be0 	.word	0x20004be0
 8035890:	20004aaa 	.word	0x20004aaa
 8035894:	20004aab 	.word	0x20004aab

08035898 <LoRaMacTestSetDutyCycleOn>:
/* ST_WORKAROUND_END */

void LoRaMacTestSetDutyCycleOn( bool enable )
{
 8035898:	b537      	push	{r0, r1, r2, r4, r5, lr}
    VerifyParams_t verify;

    verify.DutyCycle = enable;

    if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DUTY_CYCLE ) == true )
 803589a:	4d07      	ldr	r5, [pc, #28]	; (80358b8 <LoRaMacTestSetDutyCycleOn+0x20>)
    verify.DutyCycle = enable;
 803589c:	f88d 0004 	strb.w	r0, [sp, #4]
{
 80358a0:	4604      	mov	r4, r0
    if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DUTY_CYCLE ) == true )
 80358a2:	220f      	movs	r2, #15
 80358a4:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
 80358a8:	a901      	add	r1, sp, #4
 80358aa:	f000 ff5e 	bl	803676a <RegionVerify>
 80358ae:	b108      	cbz	r0, 80358b4 <LoRaMacTestSetDutyCycleOn+0x1c>
    {
        Nvm.MacGroup2.DutyCycleOn = enable;
 80358b0:	f885 460c 	strb.w	r4, [r5, #1548]	; 0x60c
    }
}
 80358b4:	b003      	add	sp, #12
 80358b6:	bd30      	pop	{r4, r5, pc}
 80358b8:	20004aa4 	.word	0x20004aa4

080358bc <LoRaMacAdrCalcNext>:
 * \param [OUT] adrAckCounter The calculated ADR acknowledgement counter.
 *
 * \retval Returns true, if an ADR request should be performed.
 */
bool LoRaMacAdrCalcNext( CalcNextAdrParams_t* adrNext, int8_t* drOut, int8_t* txPowOut, uint32_t* adrAckCounter )
{
 80358bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if( adrNext->Version.Fields.Minor == 0 )
 80358c0:	f890 9002 	ldrb.w	r9, [r0, #2]
{
 80358c4:	b08b      	sub	sp, #44	; 0x2c
 80358c6:	4604      	mov	r4, r0
 80358c8:	468a      	mov	sl, r1
 80358ca:	9201      	str	r2, [sp, #4]
    if( adrNext->Version.Fields.Minor == 0 )
 80358cc:	f1b9 0f00 	cmp.w	r9, #0
 80358d0:	d160      	bne.n	8035994 <LoRaMacAdrCalcNext+0xd8>
    if( adrNext->AdrEnabled == true )
 80358d2:	7945      	ldrb	r5, [r0, #5]
    *adrAckCounter = adrNext->AdrAckCounter;
 80358d4:	6881      	ldr	r1, [r0, #8]
    int8_t datarate = adrNext->Datarate;
 80358d6:	f990 2010 	ldrsb.w	r2, [r0, #16]
    int8_t txPower = adrNext->TxPower;
 80358da:	f990 8011 	ldrsb.w	r8, [r0, #17]
    *adrAckCounter = adrNext->AdrAckCounter;
 80358de:	6019      	str	r1, [r3, #0]
    if( adrNext->AdrEnabled == true )
 80358e0:	2d00      	cmp	r5, #0
 80358e2:	d055      	beq.n	8035990 <LoRaMacAdrCalcNext+0xd4>
        getPhy.UplinkDwellTime = adrNext->UplinkDwellTime;
 80358e4:	7c81      	ldrb	r1, [r0, #18]
 80358e6:	f88d 1016 	strb.w	r1, [sp, #22]
        phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 80358ea:	7cc0      	ldrb	r0, [r0, #19]
        getPhy.Attribute = PHY_MIN_TX_DR;
 80358ec:	f04f 0b02 	mov.w	fp, #2
        phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 80358f0:	a905      	add	r1, sp, #20
 80358f2:	e9cd 2302 	strd	r2, r3, [sp, #8]
        getPhy.Attribute = PHY_MIN_TX_DR;
 80358f6:	f88d b014 	strb.w	fp, [sp, #20]
        phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 80358fa:	f000 ff10 	bl	803671e <RegionGetPhyParam>
        datarate = MAX( datarate, minTxDatarate );
 80358fe:	9a02      	ldr	r2, [sp, #8]
        minTxDatarate = phyParam.Value;
 8035900:	b247      	sxtb	r7, r0
        datarate = MAX( datarate, minTxDatarate );
 8035902:	42ba      	cmp	r2, r7
 8035904:	4616      	mov	r6, r2
 8035906:	bfb8      	it	lt
 8035908:	463e      	movlt	r6, r7
        if( datarate == minTxDatarate )
 803590a:	42ba      	cmp	r2, r7
 803590c:	dc0c      	bgt.n	8035928 <LoRaMacAdrCalcNext+0x6c>
            *adrAckCounter = 0;
 803590e:	9b03      	ldr	r3, [sp, #12]
 8035910:	f8c3 9000 	str.w	r9, [r3]
                        adrAckReq = false;
 8035914:	464d      	mov	r5, r9
    *txPowOut = txPower;
 8035916:	9b01      	ldr	r3, [sp, #4]
    *drOut = datarate;
 8035918:	f88a 6000 	strb.w	r6, [sl]
    *txPowOut = txPower;
 803591c:	f883 8000 	strb.w	r8, [r3]
    {
        return CalcNextV10X( adrNext, drOut, txPowOut, adrAckCounter );
    }
    return false;
}
 8035920:	4628      	mov	r0, r5
 8035922:	b00b      	add	sp, #44	; 0x2c
 8035924:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            if( adrNext->AdrAckCounter >=  adrNext->AdrAckLimit )
 8035928:	68a2      	ldr	r2, [r4, #8]
 803592a:	89a1      	ldrh	r1, [r4, #12]
            if( adrNext->AdrAckCounter >= ( adrNext->AdrAckLimit + adrNext->AdrAckDelay ) )
 803592c:	89e3      	ldrh	r3, [r4, #14]
            if( adrNext->AdrAckCounter >=  adrNext->AdrAckLimit )
 803592e:	428a      	cmp	r2, r1
            if( adrNext->AdrAckCounter >= ( adrNext->AdrAckLimit + adrNext->AdrAckDelay ) )
 8035930:	440b      	add	r3, r1
            if( adrNext->AdrAckCounter >=  adrNext->AdrAckLimit )
 8035932:	bf34      	ite	cc
 8035934:	2500      	movcc	r5, #0
 8035936:	2501      	movcs	r5, #1
            if( adrNext->AdrAckCounter >= ( adrNext->AdrAckLimit + adrNext->AdrAckDelay ) )
 8035938:	429a      	cmp	r2, r3
 803593a:	d3ec      	bcc.n	8035916 <LoRaMacAdrCalcNext+0x5a>
                getPhy.Attribute = PHY_MAX_TX_POWER;
 803593c:	2308      	movs	r3, #8
                phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 803593e:	a905      	add	r1, sp, #20
 8035940:	7ce0      	ldrb	r0, [r4, #19]
                getPhy.Attribute = PHY_MAX_TX_POWER;
 8035942:	f88d 3014 	strb.w	r3, [sp, #20]
                phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 8035946:	f000 feea 	bl	803671e <RegionGetPhyParam>
                if( ( adrNext->AdrAckCounter % adrNext->AdrAckDelay ) == 1 )
 803594a:	89e2      	ldrh	r2, [r4, #14]
 803594c:	68a1      	ldr	r1, [r4, #8]
 803594e:	fbb1 f3f2 	udiv	r3, r1, r2
 8035952:	fb02 1313 	mls	r3, r2, r3, r1
 8035956:	2b01      	cmp	r3, #1
                txPower = phyParam.Value;
 8035958:	fa4f f880 	sxtb.w	r8, r0
                if( ( adrNext->AdrAckCounter % adrNext->AdrAckDelay ) == 1 )
 803595c:	d1db      	bne.n	8035916 <LoRaMacAdrCalcNext+0x5a>
                    getPhy.Attribute = PHY_NEXT_LOWER_TX_DR;
 803595e:	2322      	movs	r3, #34	; 0x22
 8035960:	f88d 3014 	strb.w	r3, [sp, #20]
                    phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 8035964:	7ce0      	ldrb	r0, [r4, #19]
                    getPhy.UplinkDwellTime = adrNext->UplinkDwellTime;
 8035966:	7ca3      	ldrb	r3, [r4, #18]
                    getPhy.Datarate = datarate;
 8035968:	f88d 6015 	strb.w	r6, [sp, #21]
                    phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 803596c:	a905      	add	r1, sp, #20
                    getPhy.UplinkDwellTime = adrNext->UplinkDwellTime;
 803596e:	f88d 3016 	strb.w	r3, [sp, #22]
                    phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 8035972:	f000 fed4 	bl	803671e <RegionGetPhyParam>
                    datarate = phyParam.Value;
 8035976:	b246      	sxtb	r6, r0
                    if( datarate == minTxDatarate )
 8035978:	42b7      	cmp	r7, r6
 803597a:	d1cc      	bne.n	8035916 <LoRaMacAdrCalcNext+0x5a>
                        if( adrNext->UpdateChanMask == true )
 803597c:	7925      	ldrb	r5, [r4, #4]
 803597e:	2d00      	cmp	r5, #0
 8035980:	d0c9      	beq.n	8035916 <LoRaMacAdrCalcNext+0x5a>
                            RegionInitDefaults( adrNext->Region, &params );
 8035982:	7ce0      	ldrb	r0, [r4, #19]
                            params.Type = INIT_TYPE_ACTIVATE_DEFAULT_CHANNELS;
 8035984:	f88d b024 	strb.w	fp, [sp, #36]	; 0x24
                            RegionInitDefaults( adrNext->Region, &params );
 8035988:	a907      	add	r1, sp, #28
 803598a:	f000 fee3 	bl	8036754 <RegionInitDefaults>
 803598e:	e7c1      	b.n	8035914 <LoRaMacAdrCalcNext+0x58>
    int8_t datarate = adrNext->Datarate;
 8035990:	4616      	mov	r6, r2
 8035992:	e7c0      	b.n	8035916 <LoRaMacAdrCalcNext+0x5a>
    return false;
 8035994:	2500      	movs	r5, #0
 8035996:	e7c3      	b.n	8035920 <LoRaMacAdrCalcNext+0x64>

08035998 <LoRaMacClassBInit>:
    TimerInit( &Ctx.PingSlotTimer, LoRaMacClassBPingSlotTimerEvent );
    TimerInit( &Ctx.MulticastSlotTimer, LoRaMacClassBMulticastSlotTimerEvent );

    InitClassB( );
#endif /* LORAMAC_CLASSB_ENABLED */
}
 8035998:	4770      	bx	lr

0803599a <LoRaMacClassBSetBeaconState>:
        {
            Ctx.BeaconState = beaconState;
        }
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 803599a:	4770      	bx	lr

0803599c <LoRaMacClassBSetPingSlotState>:
 803599c:	4770      	bx	lr

0803599e <LoRaMacClassBSetMulticastSlotState>:
 803599e:	4770      	bx	lr

080359a0 <LoRaMacClassBIsAcquisitionInProgress>:
    }
    return false;
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 80359a0:	2000      	movs	r0, #0
 80359a2:	4770      	bx	lr

080359a4 <LoRaMacClassBBeaconTimerEvent>:
    if( Ctx.LoRaMacClassBCallbacks.MacProcessNotify != NULL )
    {
        Ctx.LoRaMacClassBCallbacks.MacProcessNotify( );
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 80359a4:	4770      	bx	lr

080359a6 <LoRaMacClassBPingSlotTimerEvent>:
 80359a6:	4770      	bx	lr

080359a8 <LoRaMacClassBMulticastSlotTimerEvent>:
 80359a8:	4770      	bx	lr

080359aa <LoRaMacClassBRxBeacon>:
    }
    return beaconProcessed;
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 80359aa:	2000      	movs	r0, #0
 80359ac:	4770      	bx	lr

080359ae <LoRaMacClassBIsBeaconExpected>:
 80359ae:	2000      	movs	r0, #0
 80359b0:	4770      	bx	lr

080359b2 <LoRaMacClassBIsPingExpected>:
 80359b2:	2000      	movs	r0, #0
 80359b4:	4770      	bx	lr

080359b6 <LoRaMacClassBIsMulticastExpected>:
 80359b6:	2000      	movs	r0, #0
 80359b8:	4770      	bx	lr

080359ba <LoRaMacClassBIsBeaconModeActive>:
 80359ba:	2000      	movs	r0, #0
 80359bc:	4770      	bx	lr

080359be <LoRaMacClassBSetPingSlotInfo>:
 80359be:	4770      	bx	lr

080359c0 <LoRaMacClassBHaltBeaconing>:

        // Halt ping and multicast slot state machines
        LoRaMacClassBStopRxSlots( );
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 80359c0:	4770      	bx	lr

080359c2 <LoRaMacClassBResumeBeaconing>:
 80359c2:	4770      	bx	lr

080359c4 <LoRaMacClassBSwitchClass>:
    }
    return LORAMAC_STATUS_SERVICE_UNKNOWN;
#else
    return LORAMAC_STATUS_SERVICE_UNKNOWN;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 80359c4:	2002      	movs	r0, #2
 80359c6:	4770      	bx	lr

080359c8 <LoRaMacClassBMibGetRequestConfirm>:
    }
    return status;
#else
    return LORAMAC_STATUS_SERVICE_UNKNOWN;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 80359c8:	2002      	movs	r0, #2
 80359ca:	4770      	bx	lr

080359cc <LoRaMacMibClassBSetRequestConfirm>:
 80359cc:	2002      	movs	r0, #2
 80359ce:	4770      	bx	lr

080359d0 <LoRaMacClassBPingSlotInfoAns>:
 80359d0:	4770      	bx	lr

080359d2 <LoRaMacClassBPingSlotChannelReq>:

    return status;
#else
    return 0;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 80359d2:	2000      	movs	r0, #0
 80359d4:	4770      	bx	lr

080359d6 <LoRaMacClassBBeaconTimingAns>:

        Ctx.LoRaMacClassBParams.MlmeConfirm->BeaconTimingDelay = Ctx.BeaconCtx.BeaconTimingDelay;
        Ctx.LoRaMacClassBParams.MlmeConfirm->BeaconTimingChannel = Ctx.BeaconCtx.BeaconTimingChannel;
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 80359d6:	4770      	bx	lr

080359d8 <LoRaMacClassBDeviceTimeAns>:
 80359d8:	4770      	bx	lr

080359da <LoRaMacClassBBeaconFreqReq>:
    }
    return false;
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 80359da:	2000      	movs	r0, #0
 80359dc:	4770      	bx	lr

080359de <LoRaMacClassBIsUplinkCollision>:
    }
    return 0;
#else
    return 0;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 80359de:	2000      	movs	r0, #0
 80359e0:	4770      	bx	lr

080359e2 <LoRaMacClassBStopRxSlots>:
 80359e2:	4770      	bx	lr

080359e4 <LoRaMacClassBSetMulticastPeriodicity>:
 80359e4:	4770      	bx	lr

080359e6 <LoRaMacClassBProcess>:
 80359e6:	4770      	bx	lr

080359e8 <LoRaMacCommandsInit>:
            return false;
    }
}

LoRaMacCommandStatus_t LoRaMacCommandsInit( void )
{
 80359e8:	b510      	push	{r4, lr}
    // Initialize with default
    memset1( ( uint8_t* )&CommandsCtx, 0, sizeof( CommandsCtx ) );
 80359ea:	4c05      	ldr	r4, [pc, #20]	; (8035a00 <LoRaMacCommandsInit+0x18>)
 80359ec:	22fc      	movs	r2, #252	; 0xfc
 80359ee:	4620      	mov	r0, r4
 80359f0:	2100      	movs	r1, #0
 80359f2:	f003 faaf 	bl	8038f54 <memset1>
    list->First = NULL;
 80359f6:	2000      	movs	r0, #0
    list->Last = NULL;
 80359f8:	e9c4 0000 	strd	r0, r0, [r4]

    LinkedListInit( &CommandsCtx.MacCommandList );

    return LORAMAC_COMMANDS_SUCCESS;
}
 80359fc:	bd10      	pop	{r4, pc}
 80359fe:	bf00      	nop
 8035a00:	20005604 	.word	0x20005604

08035a04 <LoRaMacCommandsAddCmd>:

LoRaMacCommandStatus_t LoRaMacCommandsAddCmd( uint8_t cid, uint8_t* payload, size_t payloadSize )
{
 8035a04:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8035a08:	4680      	mov	r8, r0
 8035a0a:	4616      	mov	r6, r2
    if( payload == NULL )
 8035a0c:	2900      	cmp	r1, #0
 8035a0e:	d03d      	beq.n	8035a8c <LoRaMacCommandsAddCmd+0x88>
 8035a10:	4c22      	ldr	r4, [pc, #136]	; (8035a9c <LoRaMacCommandsAddCmd+0x98>)
 8035a12:	2300      	movs	r3, #0
    while( IsSlotFree( ( const MacCommand_t* )&CommandsCtx.MacCommandSlots[itr] ) == false )
 8035a14:	1c65      	adds	r5, r4, #1
 8035a16:	4622      	mov	r2, r4
 8035a18:	0118      	lsls	r0, r3, #4
 8035a1a:	3410      	adds	r4, #16
        if( mem[size] != 0x00 )
 8035a1c:	f812 7f01 	ldrb.w	r7, [r2, #1]!
 8035a20:	bbb7      	cbnz	r7, 8035a90 <LoRaMacCommandsAddCmd+0x8c>
    for( uint16_t size = 0; size < sizeof( MacCommand_t ); size++ )
 8035a22:	42a2      	cmp	r2, r4
 8035a24:	d1fa      	bne.n	8035a1c <LoRaMacCommandsAddCmd+0x18>
    if( list->First == NULL )
 8035a26:	4c1e      	ldr	r4, [pc, #120]	; (8035aa0 <LoRaMacCommandsAddCmd+0x9c>)
 8035a28:	6822      	ldr	r2, [r4, #0]
 8035a2a:	b902      	cbnz	r2, 8035a2e <LoRaMacCommandsAddCmd+0x2a>
        list->First = element;
 8035a2c:	6025      	str	r5, [r4, #0]
    if( list->Last )
 8035a2e:	6862      	ldr	r2, [r4, #4]
 8035a30:	b102      	cbz	r2, 8035a34 <LoRaMacCommandsAddCmd+0x30>
        list->Last->Next = element;
 8035a32:	6015      	str	r5, [r2, #0]
    list->Last = element;
 8035a34:	6065      	str	r5, [r4, #4]
        return LORAMAC_COMMANDS_ERROR;
    }

    // Set Values
    newCmd->CID = cid;
    newCmd->PayloadSize = payloadSize;
 8035a36:	1c5d      	adds	r5, r3, #1
    element->Next = NULL;
 8035a38:	1822      	adds	r2, r4, r0
    newCmd->PayloadSize = payloadSize;
 8035a3a:	012b      	lsls	r3, r5, #4
    element->Next = NULL;
 8035a3c:	f04f 0c00 	mov.w	ip, #0
    memcpy1( ( uint8_t* )newCmd->Payload, payload, payloadSize );
 8035a40:	300d      	adds	r0, #13
    element->Next = NULL;
 8035a42:	f8c2 c008 	str.w	ip, [r2, #8]
    newCmd->CID = cid;
 8035a46:	f882 800c 	strb.w	r8, [r2, #12]
    newCmd->PayloadSize = payloadSize;
 8035a4a:	50e6      	str	r6, [r4, r3]
    memcpy1( ( uint8_t* )newCmd->Payload, payload, payloadSize );
 8035a4c:	b2b2      	uxth	r2, r6
 8035a4e:	4420      	add	r0, r4
 8035a50:	f003 fa6c 	bl	8038f2c <memcpy1>
    switch( cid )
 8035a54:	f1b8 0f05 	cmp.w	r8, #5
 8035a58:	d015      	beq.n	8035a86 <LoRaMacCommandsAddCmd+0x82>
 8035a5a:	f1a8 0808 	sub.w	r8, r8, #8
 8035a5e:	f1b8 0f02 	cmp.w	r8, #2
 8035a62:	bf8c      	ite	hi
 8035a64:	f04f 0800 	movhi.w	r8, #0
 8035a68:	f04f 0801 	movls.w	r8, #1
    newCmd->IsSticky = IsSticky( cid );
 8035a6c:	eb04 1305 	add.w	r3, r4, r5, lsl #4
 8035a70:	f883 8004 	strb.w	r8, [r3, #4]

    CommandsCtx.SerializedCmdsSize += ( CID_FIELD_SIZE + payloadSize );
 8035a74:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
 8035a78:	3301      	adds	r3, #1
 8035a7a:	4433      	add	r3, r6
 8035a7c:	f8c4 30f8 	str.w	r3, [r4, #248]	; 0xf8

    return LORAMAC_COMMANDS_SUCCESS;
}
 8035a80:	4638      	mov	r0, r7
 8035a82:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            return true;
 8035a86:	f04f 0801 	mov.w	r8, #1
 8035a8a:	e7ef      	b.n	8035a6c <LoRaMacCommandsAddCmd+0x68>
        return LORAMAC_COMMANDS_ERROR_NPE;
 8035a8c:	2701      	movs	r7, #1
 8035a8e:	e7f7      	b.n	8035a80 <LoRaMacCommandsAddCmd+0x7c>
        if( itr == NUM_OF_MAC_COMMANDS )
 8035a90:	3301      	adds	r3, #1
 8035a92:	2b0f      	cmp	r3, #15
 8035a94:	d1be      	bne.n	8035a14 <LoRaMacCommandsAddCmd+0x10>
        return LORAMAC_COMMANDS_ERROR_MEMORY;
 8035a96:	2702      	movs	r7, #2
 8035a98:	e7f2      	b.n	8035a80 <LoRaMacCommandsAddCmd+0x7c>
 8035a9a:	bf00      	nop
 8035a9c:	2000560b 	.word	0x2000560b
 8035aa0:	20005604 	.word	0x20005604

08035aa4 <LoRaMacCommandsRemoveCmd>:

LoRaMacCommandStatus_t LoRaMacCommandsRemoveCmd( MacCommand_t* macCmd )
{
 8035aa4:	b510      	push	{r4, lr}
    if( macCmd == NULL )
 8035aa6:	b310      	cbz	r0, 8035aee <LoRaMacCommandsRemoveCmd+0x4a>
    curElement = list->First;
 8035aa8:	4b12      	ldr	r3, [pc, #72]	; (8035af4 <LoRaMacCommandsRemoveCmd+0x50>)
 8035aaa:	681a      	ldr	r2, [r3, #0]
    if( element != curElement )
 8035aac:	4290      	cmp	r0, r2
 8035aae:	d104      	bne.n	8035aba <LoRaMacCommandsRemoveCmd+0x16>
        list->First = element->Next;
 8035ab0:	6802      	ldr	r2, [r0, #0]
 8035ab2:	601a      	str	r2, [r3, #0]
 8035ab4:	2200      	movs	r2, #0
 8035ab6:	e004      	b.n	8035ac2 <LoRaMacCommandsRemoveCmd+0x1e>
 8035ab8:	460a      	mov	r2, r1
        while( ( curElement != NULL ) && ( curElement->Next != element ) )
 8035aba:	b112      	cbz	r2, 8035ac2 <LoRaMacCommandsRemoveCmd+0x1e>
 8035abc:	6811      	ldr	r1, [r2, #0]
 8035abe:	4288      	cmp	r0, r1
 8035ac0:	d1fa      	bne.n	8035ab8 <LoRaMacCommandsRemoveCmd+0x14>
    if( list->Last == element )
 8035ac2:	6859      	ldr	r1, [r3, #4]
 8035ac4:	4288      	cmp	r0, r1
        list->Last = PrevElement;
 8035ac6:	bf08      	it	eq
 8035ac8:	605a      	streq	r2, [r3, #4]
    if( PrevElement != NULL )
 8035aca:	b10a      	cbz	r2, 8035ad0 <LoRaMacCommandsRemoveCmd+0x2c>
        PrevElement->Next = element->Next;
 8035acc:	6801      	ldr	r1, [r0, #0]
 8035ace:	6011      	str	r1, [r2, #0]
    if( LinkedListRemove( &CommandsCtx.MacCommandList, macCmd ) == false )
    {
        return LORAMAC_COMMANDS_ERROR_CMD_NOT_FOUND;
    }

    CommandsCtx.SerializedCmdsSize -= ( CID_FIELD_SIZE + macCmd->PayloadSize );
 8035ad0:	f8d3 20f8 	ldr.w	r2, [r3, #248]	; 0xf8
 8035ad4:	6881      	ldr	r1, [r0, #8]
 8035ad6:	3a01      	subs	r2, #1
    element->Next = NULL;
 8035ad8:	2400      	movs	r4, #0
    CommandsCtx.SerializedCmdsSize -= ( CID_FIELD_SIZE + macCmd->PayloadSize );
 8035ada:	1a52      	subs	r2, r2, r1
    element->Next = NULL;
 8035adc:	6004      	str	r4, [r0, #0]
    memset1( ( uint8_t* )slot, 0x00, sizeof( MacCommand_t ) );
 8035ade:	4621      	mov	r1, r4
    CommandsCtx.SerializedCmdsSize -= ( CID_FIELD_SIZE + macCmd->PayloadSize );
 8035ae0:	f8c3 20f8 	str.w	r2, [r3, #248]	; 0xf8
    memset1( ( uint8_t* )slot, 0x00, sizeof( MacCommand_t ) );
 8035ae4:	2210      	movs	r2, #16
 8035ae6:	f003 fa35 	bl	8038f54 <memset1>
    return true;
 8035aea:	4620      	mov	r0, r4
    {
        return LORAMAC_COMMANDS_ERROR;
    }

    return LORAMAC_COMMANDS_SUCCESS;
}
 8035aec:	bd10      	pop	{r4, pc}
        return LORAMAC_COMMANDS_ERROR_NPE;
 8035aee:	2001      	movs	r0, #1
 8035af0:	e7fc      	b.n	8035aec <LoRaMacCommandsRemoveCmd+0x48>
 8035af2:	bf00      	nop
 8035af4:	20005604 	.word	0x20005604

08035af8 <LoRaMacCommandsRemoveNoneStickyCmds>:
    }
    return LORAMAC_COMMANDS_SUCCESS;
}

LoRaMacCommandStatus_t LoRaMacCommandsRemoveNoneStickyCmds( void )
{
 8035af8:	b510      	push	{r4, lr}
    MacCommand_t* curElement;
    MacCommand_t* nexElement;

    // Start at the head of the list
    curElement = CommandsCtx.MacCommandList.First;
 8035afa:	4b05      	ldr	r3, [pc, #20]	; (8035b10 <LoRaMacCommandsRemoveNoneStickyCmds+0x18>)
 8035afc:	6818      	ldr	r0, [r3, #0]

    // Loop through all elements
    while( curElement != NULL )
 8035afe:	b900      	cbnz	r0, 8035b02 <LoRaMacCommandsRemoveNoneStickyCmds+0xa>
            curElement = curElement->Next;
        }
    }

    return LORAMAC_COMMANDS_SUCCESS;
}
 8035b00:	bd10      	pop	{r4, pc}
        if( curElement->IsSticky == false )
 8035b02:	7b03      	ldrb	r3, [r0, #12]
 8035b04:	6804      	ldr	r4, [r0, #0]
 8035b06:	b90b      	cbnz	r3, 8035b0c <LoRaMacCommandsRemoveNoneStickyCmds+0x14>
            LoRaMacCommandsRemoveCmd( curElement );
 8035b08:	f7ff ffcc 	bl	8035aa4 <LoRaMacCommandsRemoveCmd>
{
 8035b0c:	4620      	mov	r0, r4
 8035b0e:	e7f6      	b.n	8035afe <LoRaMacCommandsRemoveNoneStickyCmds+0x6>
 8035b10:	20005604 	.word	0x20005604

08035b14 <LoRaMacCommandsRemoveStickyAnsCmds>:

LoRaMacCommandStatus_t LoRaMacCommandsRemoveStickyAnsCmds( void )
{
 8035b14:	b510      	push	{r4, lr}
    MacCommand_t* curElement;
    MacCommand_t* nexElement;

    // Start at the head of the list
    curElement = CommandsCtx.MacCommandList.First;
 8035b16:	4b07      	ldr	r3, [pc, #28]	; (8035b34 <LoRaMacCommandsRemoveStickyAnsCmds+0x20>)
 8035b18:	6818      	ldr	r0, [r3, #0]

    // Loop through all elements
    while( curElement != NULL )
 8035b1a:	b900      	cbnz	r0, 8035b1e <LoRaMacCommandsRemoveStickyAnsCmds+0xa>
        }
        curElement = nexElement;
    }

    return LORAMAC_COMMANDS_SUCCESS;
}
 8035b1c:	bd10      	pop	{r4, pc}
        if( IsSticky( curElement->CID ) == true )
 8035b1e:	7903      	ldrb	r3, [r0, #4]
        nexElement = curElement->Next;
 8035b20:	6804      	ldr	r4, [r0, #0]
    switch( cid )
 8035b22:	2b05      	cmp	r3, #5
 8035b24:	d002      	beq.n	8035b2c <LoRaMacCommandsRemoveStickyAnsCmds+0x18>
 8035b26:	3b08      	subs	r3, #8
 8035b28:	2b02      	cmp	r3, #2
 8035b2a:	d801      	bhi.n	8035b30 <LoRaMacCommandsRemoveStickyAnsCmds+0x1c>
            LoRaMacCommandsRemoveCmd( curElement );
 8035b2c:	f7ff ffba 	bl	8035aa4 <LoRaMacCommandsRemoveCmd>
{
 8035b30:	4620      	mov	r0, r4
 8035b32:	e7f2      	b.n	8035b1a <LoRaMacCommandsRemoveStickyAnsCmds+0x6>
 8035b34:	20005604 	.word	0x20005604

08035b38 <LoRaMacCommandsGetSizeSerializedCmds>:

LoRaMacCommandStatus_t LoRaMacCommandsGetSizeSerializedCmds( size_t* size )
{
    if( size == NULL )
 8035b38:	b128      	cbz	r0, 8035b46 <LoRaMacCommandsGetSizeSerializedCmds+0xe>
    {
        return LORAMAC_COMMANDS_ERROR_NPE;
    }
    *size = CommandsCtx.SerializedCmdsSize;
 8035b3a:	4b04      	ldr	r3, [pc, #16]	; (8035b4c <LoRaMacCommandsGetSizeSerializedCmds+0x14>)
 8035b3c:	f8d3 30f8 	ldr.w	r3, [r3, #248]	; 0xf8
 8035b40:	6003      	str	r3, [r0, #0]
    return LORAMAC_COMMANDS_SUCCESS;
 8035b42:	2000      	movs	r0, #0
 8035b44:	4770      	bx	lr
        return LORAMAC_COMMANDS_ERROR_NPE;
 8035b46:	2001      	movs	r0, #1
}
 8035b48:	4770      	bx	lr
 8035b4a:	bf00      	nop
 8035b4c:	20005604 	.word	0x20005604

08035b50 <LoRaMacCommandsSerializeCmds>:

LoRaMacCommandStatus_t LoRaMacCommandsSerializeCmds( size_t availableSize, size_t* effectiveSize, uint8_t* buffer )
{
 8035b50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8035b54:	4607      	mov	r7, r0
 8035b56:	460e      	mov	r6, r1
    MacCommand_t* curElement = CommandsCtx.MacCommandList.First;
    MacCommand_t* nextElement;
    uint8_t itr = 0;

    if( ( buffer == NULL ) || ( effectiveSize == NULL ) )
 8035b58:	4615      	mov	r5, r2
 8035b5a:	b332      	cbz	r2, 8035baa <LoRaMacCommandsSerializeCmds+0x5a>
 8035b5c:	b329      	cbz	r1, 8035baa <LoRaMacCommandsSerializeCmds+0x5a>
    MacCommand_t* curElement = CommandsCtx.MacCommandList.First;
 8035b5e:	4b14      	ldr	r3, [pc, #80]	; (8035bb0 <LoRaMacCommandsSerializeCmds+0x60>)
 8035b60:	681c      	ldr	r4, [r3, #0]
    uint8_t itr = 0;
 8035b62:	2300      	movs	r3, #0
    {
        return LORAMAC_COMMANDS_ERROR_NPE;
    }

    // Loop through all elements which fits into the buffer
    while( curElement != NULL )
 8035b64:	b92c      	cbnz	r4, 8035b72 <LoRaMacCommandsSerializeCmds+0x22>
        LoRaMacCommandsRemoveCmd( curElement );
        curElement = nextElement;
    }

    // Fetch the effective size of the mac commands
    LoRaMacCommandsGetSizeSerializedCmds( effectiveSize );
 8035b66:	4630      	mov	r0, r6
 8035b68:	f7ff ffe6 	bl	8035b38 <LoRaMacCommandsGetSizeSerializedCmds>

    return LORAMAC_COMMANDS_SUCCESS;
 8035b6c:	2000      	movs	r0, #0
}
 8035b6e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if( ( availableSize - itr ) >= ( CID_FIELD_SIZE + curElement->PayloadSize ) )
 8035b72:	68a2      	ldr	r2, [r4, #8]
 8035b74:	1af9      	subs	r1, r7, r3
 8035b76:	3201      	adds	r2, #1
 8035b78:	4291      	cmp	r1, r2
 8035b7a:	d30f      	bcc.n	8035b9c <LoRaMacCommandsSerializeCmds+0x4c>
            buffer[itr++] = curElement->CID;
 8035b7c:	7922      	ldrb	r2, [r4, #4]
 8035b7e:	54ea      	strb	r2, [r5, r3]
 8035b80:	1c58      	adds	r0, r3, #1
            memcpy1( &buffer[itr], curElement->Payload, curElement->PayloadSize );
 8035b82:	8922      	ldrh	r2, [r4, #8]
            buffer[itr++] = curElement->CID;
 8035b84:	fa5f f880 	uxtb.w	r8, r0
            memcpy1( &buffer[itr], curElement->Payload, curElement->PayloadSize );
 8035b88:	1d61      	adds	r1, r4, #5
 8035b8a:	fa55 f080 	uxtab	r0, r5, r0
 8035b8e:	f003 f9cd 	bl	8038f2c <memcpy1>
            itr += curElement->PayloadSize;
 8035b92:	68a3      	ldr	r3, [r4, #8]
        curElement = curElement->Next;
 8035b94:	6824      	ldr	r4, [r4, #0]
            itr += curElement->PayloadSize;
 8035b96:	4443      	add	r3, r8
 8035b98:	b2db      	uxtb	r3, r3
        curElement = curElement->Next;
 8035b9a:	e7e3      	b.n	8035b64 <LoRaMacCommandsSerializeCmds+0x14>
        nextElement = curElement->Next;
 8035b9c:	4620      	mov	r0, r4
 8035b9e:	6824      	ldr	r4, [r4, #0]
        LoRaMacCommandsRemoveCmd( curElement );
 8035ba0:	f7ff ff80 	bl	8035aa4 <LoRaMacCommandsRemoveCmd>
    while( curElement != NULL )
 8035ba4:	2c00      	cmp	r4, #0
 8035ba6:	d1f9      	bne.n	8035b9c <LoRaMacCommandsSerializeCmds+0x4c>
 8035ba8:	e7dd      	b.n	8035b66 <LoRaMacCommandsSerializeCmds+0x16>
        return LORAMAC_COMMANDS_ERROR_NPE;
 8035baa:	2001      	movs	r0, #1
 8035bac:	e7df      	b.n	8035b6e <LoRaMacCommandsSerializeCmds+0x1e>
 8035bae:	bf00      	nop
 8035bb0:	20005604 	.word	0x20005604

08035bb4 <LoRaMacCommandsStickyCmdsPending>:

LoRaMacCommandStatus_t LoRaMacCommandsStickyCmdsPending( bool* cmdsPending )
{
    if( cmdsPending == NULL )
 8035bb4:	4603      	mov	r3, r0
 8035bb6:	b168      	cbz	r0, 8035bd4 <LoRaMacCommandsStickyCmdsPending+0x20>
    {
        return LORAMAC_COMMANDS_ERROR_NPE;
    }
    MacCommand_t* curElement;
    curElement = CommandsCtx.MacCommandList.First;
 8035bb8:	4a07      	ldr	r2, [pc, #28]	; (8035bd8 <LoRaMacCommandsStickyCmdsPending+0x24>)
 8035bba:	6810      	ldr	r0, [r2, #0]

    *cmdsPending = false;
 8035bbc:	2200      	movs	r2, #0
 8035bbe:	701a      	strb	r2, [r3, #0]

    // Loop through all elements
    while( curElement != NULL )
 8035bc0:	b900      	cbnz	r0, 8035bc4 <LoRaMacCommandsStickyCmdsPending+0x10>
 8035bc2:	4770      	bx	lr
    {
        if( curElement->IsSticky == true )
 8035bc4:	7b02      	ldrb	r2, [r0, #12]
 8035bc6:	b11a      	cbz	r2, 8035bd0 <LoRaMacCommandsStickyCmdsPending+0x1c>
        {
            // Found one sticky MAC command
            *cmdsPending = true;
 8035bc8:	2201      	movs	r2, #1
 8035bca:	701a      	strb	r2, [r3, #0]
            return LORAMAC_COMMANDS_SUCCESS;
 8035bcc:	2000      	movs	r0, #0
 8035bce:	4770      	bx	lr
        }
        curElement = curElement->Next;
 8035bd0:	6800      	ldr	r0, [r0, #0]
 8035bd2:	e7f5      	b.n	8035bc0 <LoRaMacCommandsStickyCmdsPending+0xc>
        return LORAMAC_COMMANDS_ERROR_NPE;
 8035bd4:	2001      	movs	r0, #1
    }

    return LORAMAC_COMMANDS_SUCCESS;
}
 8035bd6:	4770      	bx	lr
 8035bd8:	20005604 	.word	0x20005604

08035bdc <LoRaMacCommandsGetCmdSize>:
uint8_t LoRaMacCommandsGetCmdSize( uint8_t cid )
{
    uint8_t cidSize = 0;

    // Decode Frame MAC commands
    switch( cid )
 8035bdc:	3802      	subs	r0, #2
 8035bde:	b2c0      	uxtb	r0, r0
 8035be0:	2811      	cmp	r0, #17
 8035be2:	bf9a      	itte	ls
 8035be4:	4b01      	ldrls	r3, [pc, #4]	; (8035bec <LoRaMacCommandsGetCmdSize+0x10>)
 8035be6:	5c18      	ldrbls	r0, [r3, r0]
{
 8035be8:	2000      	movhi	r0, #0
            // Unknown command. ABORT MAC commands processing
            break;
        }
    }
    return cidSize;
}
 8035bea:	4770      	bx	lr
 8035bec:	0803baca 	.word	0x0803baca

08035bf0 <GetElement.isra.0>:
        return true;
    }
    return false;
}

static MlmeConfirmQueue_t* GetElement( Mlme_t request, MlmeConfirmQueue_t* bufferStart, MlmeConfirmQueue_t* bufferEnd )
 8035bf0:	b530      	push	{r4, r5, lr}
{
    MlmeConfirmQueue_t* element = bufferStart;

    if( IsListEmpty( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == true )
 8035bf2:	4b0c      	ldr	r3, [pc, #48]	; (8035c24 <GetElement.isra.0+0x34>)
 8035bf4:	f893 2020 	ldrb.w	r2, [r3, #32]
static MlmeConfirmQueue_t* GetElement( Mlme_t request, MlmeConfirmQueue_t* bufferStart, MlmeConfirmQueue_t* bufferEnd )
 8035bf8:	4604      	mov	r4, r0
 8035bfa:	4608      	mov	r0, r1
    if( count == 0 )
 8035bfc:	b17a      	cbz	r2, 8035c1e <GetElement.isra.0+0x2e>
 8035bfe:	2100      	movs	r1, #0
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 8035c00:	331c      	adds	r3, #28
    {
        return NULL;
    }

    for( uint8_t elementCnt = 0; elementCnt < ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt; elementCnt++ )
 8035c02:	b2cd      	uxtb	r5, r1
 8035c04:	42aa      	cmp	r2, r5
 8035c06:	d801      	bhi.n	8035c0c <GetElement.isra.0+0x1c>
        return NULL;
 8035c08:	2000      	movs	r0, #0
        }
        element = IncreaseBufferPointer( element );
    }

    return NULL;
}
 8035c0a:	bd30      	pop	{r4, r5, pc}
        if( element->Request == request )
 8035c0c:	7805      	ldrb	r5, [r0, #0]
 8035c0e:	42a5      	cmp	r5, r4
 8035c10:	d0fb      	beq.n	8035c0a <GetElement.isra.0+0x1a>
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 8035c12:	4298      	cmp	r0, r3
        bufferPointer = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 8035c14:	bf0c      	ite	eq
 8035c16:	4804      	ldreq	r0, [pc, #16]	; (8035c28 <GetElement.isra.0+0x38>)
        bufferPointer++;
 8035c18:	3004      	addne	r0, #4
    for( uint8_t elementCnt = 0; elementCnt < ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt; elementCnt++ )
 8035c1a:	3101      	adds	r1, #1
 8035c1c:	e7f1      	b.n	8035c02 <GetElement.isra.0+0x12>
        return NULL;
 8035c1e:	4610      	mov	r0, r2
 8035c20:	e7f3      	b.n	8035c0a <GetElement.isra.0+0x1a>
 8035c22:	bf00      	nop
 8035c24:	20005700 	.word	0x20005700
 8035c28:	2000570c 	.word	0x2000570c

08035c2c <LoRaMacConfirmQueueInit>:

void LoRaMacConfirmQueueInit( LoRaMacPrimitives_t* primitives )
{
 8035c2c:	b510      	push	{r4, lr}
    ConfirmQueueCtx.Primitives = primitives;
 8035c2e:	4c08      	ldr	r4, [pc, #32]	; (8035c50 <LoRaMacConfirmQueueInit+0x24>)

    // Init counter
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt = 0;
 8035c30:	2300      	movs	r3, #0
    ConfirmQueueCtx.Primitives = primitives;
 8035c32:	6020      	str	r0, [r4, #0]

    // Init buffer
    ConfirmQueueCtx.BufferStart = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
    ConfirmQueueCtx.BufferEnd = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;

    memset1( ( uint8_t* )ConfirmQueueCtx.Nvm.MlmeConfirmQueue, 0xFF, sizeof( ConfirmQueueCtx.Nvm.MlmeConfirmQueue ) );
 8035c34:	2214      	movs	r2, #20
    ConfirmQueueCtx.BufferStart = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 8035c36:	f104 000c 	add.w	r0, r4, #12
    memset1( ( uint8_t* )ConfirmQueueCtx.Nvm.MlmeConfirmQueue, 0xFF, sizeof( ConfirmQueueCtx.Nvm.MlmeConfirmQueue ) );
 8035c3a:	21ff      	movs	r1, #255	; 0xff
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt = 0;
 8035c3c:	f884 3020 	strb.w	r3, [r4, #32]
    ConfirmQueueCtx.BufferEnd = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 8035c40:	e9c4 0001 	strd	r0, r0, [r4, #4]
    memset1( ( uint8_t* )ConfirmQueueCtx.Nvm.MlmeConfirmQueue, 0xFF, sizeof( ConfirmQueueCtx.Nvm.MlmeConfirmQueue ) );
 8035c44:	f003 f986 	bl	8038f54 <memset1>

    // Common status
    ConfirmQueueCtx.Nvm.CommonStatus = LORAMAC_EVENT_INFO_STATUS_ERROR;
 8035c48:	2301      	movs	r3, #1
 8035c4a:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
}
 8035c4e:	bd10      	pop	{r4, pc}
 8035c50:	20005700 	.word	0x20005700

08035c54 <LoRaMacConfirmQueueAdd>:

bool LoRaMacConfirmQueueAdd( MlmeConfirmQueue_t* mlmeConfirm )
{
    if( IsListFull( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == true )
 8035c54:	4b0f      	ldr	r3, [pc, #60]	; (8035c94 <LoRaMacConfirmQueueAdd+0x40>)
    if( count >= LORA_MAC_MLME_CONFIRM_QUEUE_LEN )
 8035c56:	f893 2020 	ldrb.w	r2, [r3, #32]
 8035c5a:	2a04      	cmp	r2, #4
 8035c5c:	d817      	bhi.n	8035c8e <LoRaMacConfirmQueueAdd+0x3a>
        // Protect the buffer against overwrites
        return false;
    }

    // Add the element to the ring buffer
    ConfirmQueueCtx.BufferEnd->Request = mlmeConfirm->Request;
 8035c5e:	689a      	ldr	r2, [r3, #8]
 8035c60:	7801      	ldrb	r1, [r0, #0]
 8035c62:	7011      	strb	r1, [r2, #0]
    ConfirmQueueCtx.BufferEnd->Status = mlmeConfirm->Status;
 8035c64:	7841      	ldrb	r1, [r0, #1]
 8035c66:	7051      	strb	r1, [r2, #1]
    ConfirmQueueCtx.BufferEnd->RestrictCommonReadyToHandle = mlmeConfirm->RestrictCommonReadyToHandle;
 8035c68:	78c1      	ldrb	r1, [r0, #3]
 8035c6a:	70d1      	strb	r1, [r2, #3]
    ConfirmQueueCtx.BufferEnd->ReadyToHandle = false;
 8035c6c:	2100      	movs	r1, #0
 8035c6e:	7091      	strb	r1, [r2, #2]
    // Increase counter
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt++;
 8035c70:	f893 1020 	ldrb.w	r1, [r3, #32]
 8035c74:	3101      	adds	r1, #1
 8035c76:	f883 1020 	strb.w	r1, [r3, #32]
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 8035c7a:	f103 011c 	add.w	r1, r3, #28
 8035c7e:	428a      	cmp	r2, r1
        bufferPointer++;
 8035c80:	bf14      	ite	ne
 8035c82:	3204      	addne	r2, #4
        bufferPointer = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 8035c84:	f103 020c 	addeq.w	r2, r3, #12
    // Update end pointer
    ConfirmQueueCtx.BufferEnd = IncreaseBufferPointer( ConfirmQueueCtx.BufferEnd );
 8035c88:	609a      	str	r2, [r3, #8]
 8035c8a:	2001      	movs	r0, #1
 8035c8c:	4770      	bx	lr
        return false;
 8035c8e:	2000      	movs	r0, #0

    return true;
}
 8035c90:	4770      	bx	lr
 8035c92:	bf00      	nop
 8035c94:	20005700 	.word	0x20005700

08035c98 <LoRaMacConfirmQueueRemoveFirst>:
    return true;
}

bool LoRaMacConfirmQueueRemoveFirst( void )
{
    if( IsListEmpty( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == true )
 8035c98:	4b09      	ldr	r3, [pc, #36]	; (8035cc0 <LoRaMacConfirmQueueRemoveFirst+0x28>)
 8035c9a:	f893 0020 	ldrb.w	r0, [r3, #32]
    if( count == 0 )
 8035c9e:	b168      	cbz	r0, 8035cbc <LoRaMacConfirmQueueRemoveFirst+0x24>
    }

    // Increase counter
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt--;
    // Update start pointer
    ConfirmQueueCtx.BufferStart = IncreaseBufferPointer( ConfirmQueueCtx.BufferStart );
 8035ca0:	685a      	ldr	r2, [r3, #4]
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 8035ca2:	f103 011c 	add.w	r1, r3, #28
 8035ca6:	428a      	cmp	r2, r1
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt--;
 8035ca8:	f100 30ff 	add.w	r0, r0, #4294967295
        bufferPointer++;
 8035cac:	bf14      	ite	ne
 8035cae:	3204      	addne	r2, #4
        bufferPointer = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 8035cb0:	f103 020c 	addeq.w	r2, r3, #12
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt--;
 8035cb4:	f883 0020 	strb.w	r0, [r3, #32]
    ConfirmQueueCtx.BufferStart = IncreaseBufferPointer( ConfirmQueueCtx.BufferStart );
 8035cb8:	605a      	str	r2, [r3, #4]

    return true;
 8035cba:	2001      	movs	r0, #1
}
 8035cbc:	4770      	bx	lr
 8035cbe:	bf00      	nop
 8035cc0:	20005700 	.word	0x20005700

08035cc4 <LoRaMacConfirmQueueSetStatus>:

void LoRaMacConfirmQueueSetStatus( LoRaMacEventInfoStatus_t status, Mlme_t request )
{
 8035cc4:	b510      	push	{r4, lr}
    MlmeConfirmQueue_t* element = NULL;

    if( IsListEmpty( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == false )
 8035cc6:	4b07      	ldr	r3, [pc, #28]	; (8035ce4 <LoRaMacConfirmQueueSetStatus+0x20>)
    if( count == 0 )
 8035cc8:	f893 2020 	ldrb.w	r2, [r3, #32]
{
 8035ccc:	4604      	mov	r4, r0
 8035cce:	4608      	mov	r0, r1
    if( count == 0 )
 8035cd0:	b132      	cbz	r2, 8035ce0 <LoRaMacConfirmQueueSetStatus+0x1c>
    {
        element = GetElement( request, ConfirmQueueCtx.BufferStart, ConfirmQueueCtx.BufferEnd );
 8035cd2:	6859      	ldr	r1, [r3, #4]
 8035cd4:	f7ff ff8c 	bl	8035bf0 <GetElement.isra.0>
        if( element != NULL )
 8035cd8:	b110      	cbz	r0, 8035ce0 <LoRaMacConfirmQueueSetStatus+0x1c>
        {
            element->Status = status;
            element->ReadyToHandle = true;
 8035cda:	2301      	movs	r3, #1
            element->Status = status;
 8035cdc:	7044      	strb	r4, [r0, #1]
            element->ReadyToHandle = true;
 8035cde:	7083      	strb	r3, [r0, #2]
        }
    }
}
 8035ce0:	bd10      	pop	{r4, pc}
 8035ce2:	bf00      	nop
 8035ce4:	20005700 	.word	0x20005700

08035ce8 <LoRaMacConfirmQueueGetStatus>:

LoRaMacEventInfoStatus_t LoRaMacConfirmQueueGetStatus( Mlme_t request )
{
 8035ce8:	b508      	push	{r3, lr}
    MlmeConfirmQueue_t* element = NULL;

    if( IsListEmpty( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == false )
 8035cea:	4b06      	ldr	r3, [pc, #24]	; (8035d04 <LoRaMacConfirmQueueGetStatus+0x1c>)
    if( count == 0 )
 8035cec:	f893 2020 	ldrb.w	r2, [r3, #32]
 8035cf0:	b12a      	cbz	r2, 8035cfe <LoRaMacConfirmQueueGetStatus+0x16>
    {
        element = GetElement( request, ConfirmQueueCtx.BufferStart, ConfirmQueueCtx.BufferEnd );
 8035cf2:	6859      	ldr	r1, [r3, #4]
 8035cf4:	f7ff ff7c 	bl	8035bf0 <GetElement.isra.0>
        if( element != NULL )
 8035cf8:	b108      	cbz	r0, 8035cfe <LoRaMacConfirmQueueGetStatus+0x16>
        {
            return element->Status;
 8035cfa:	7840      	ldrb	r0, [r0, #1]
        }
    }
    return LORAMAC_EVENT_INFO_STATUS_ERROR;
}
 8035cfc:	bd08      	pop	{r3, pc}
    return LORAMAC_EVENT_INFO_STATUS_ERROR;
 8035cfe:	2001      	movs	r0, #1
 8035d00:	e7fc      	b.n	8035cfc <LoRaMacConfirmQueueGetStatus+0x14>
 8035d02:	bf00      	nop
 8035d04:	20005700 	.word	0x20005700

08035d08 <LoRaMacConfirmQueueSetStatusCmn>:

void LoRaMacConfirmQueueSetStatusCmn( LoRaMacEventInfoStatus_t status )
{
 8035d08:	b530      	push	{r4, r5, lr}
    MlmeConfirmQueue_t* element = ConfirmQueueCtx.BufferStart;
 8035d0a:	4a0a      	ldr	r2, [pc, #40]	; (8035d34 <LoRaMacConfirmQueueSetStatusCmn+0x2c>)
    if( count == 0 )
 8035d0c:	f892 1020 	ldrb.w	r1, [r2, #32]
    MlmeConfirmQueue_t* element = ConfirmQueueCtx.BufferStart;
 8035d10:	6853      	ldr	r3, [r2, #4]

    ConfirmQueueCtx.Nvm.CommonStatus = status;
 8035d12:	f882 0021 	strb.w	r0, [r2, #33]	; 0x21
    if( count == 0 )
 8035d16:	b161      	cbz	r1, 8035d32 <LoRaMacConfirmQueueSetStatusCmn+0x2a>
            if( element->RestrictCommonReadyToHandle == false )
            {
                element->ReadyToHandle = true;
            }
            element = IncreaseBufferPointer( element );
        }while( element != ConfirmQueueCtx.BufferEnd );
 8035d18:	6891      	ldr	r1, [r2, #8]
                element->ReadyToHandle = true;
 8035d1a:	2401      	movs	r4, #1
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 8035d1c:	321c      	adds	r2, #28
            if( element->RestrictCommonReadyToHandle == false )
 8035d1e:	78dd      	ldrb	r5, [r3, #3]
            element->Status = status;
 8035d20:	7058      	strb	r0, [r3, #1]
            if( element->RestrictCommonReadyToHandle == false )
 8035d22:	b905      	cbnz	r5, 8035d26 <LoRaMacConfirmQueueSetStatusCmn+0x1e>
                element->ReadyToHandle = true;
 8035d24:	709c      	strb	r4, [r3, #2]
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 8035d26:	4293      	cmp	r3, r2
        bufferPointer = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 8035d28:	bf0c      	ite	eq
 8035d2a:	4b03      	ldreq	r3, [pc, #12]	; (8035d38 <LoRaMacConfirmQueueSetStatusCmn+0x30>)
        bufferPointer++;
 8035d2c:	3304      	addne	r3, #4
        }while( element != ConfirmQueueCtx.BufferEnd );
 8035d2e:	4299      	cmp	r1, r3
 8035d30:	d1f5      	bne.n	8035d1e <LoRaMacConfirmQueueSetStatusCmn+0x16>
    }
}
 8035d32:	bd30      	pop	{r4, r5, pc}
 8035d34:	20005700 	.word	0x20005700
 8035d38:	2000570c 	.word	0x2000570c

08035d3c <LoRaMacConfirmQueueIsCmdActive>:
{
    return ConfirmQueueCtx.Nvm.CommonStatus;
}

bool LoRaMacConfirmQueueIsCmdActive( Mlme_t request )
{
 8035d3c:	b508      	push	{r3, lr}
    if( GetElement( request, ConfirmQueueCtx.BufferStart, ConfirmQueueCtx.BufferEnd ) != NULL )
 8035d3e:	4b04      	ldr	r3, [pc, #16]	; (8035d50 <LoRaMacConfirmQueueIsCmdActive+0x14>)
 8035d40:	6859      	ldr	r1, [r3, #4]
 8035d42:	f7ff ff55 	bl	8035bf0 <GetElement.isra.0>
    {
        return true;
    }
    return false;
}
 8035d46:	3800      	subs	r0, #0
 8035d48:	bf18      	it	ne
 8035d4a:	2001      	movne	r0, #1
 8035d4c:	bd08      	pop	{r3, pc}
 8035d4e:	bf00      	nop
 8035d50:	20005700 	.word	0x20005700

08035d54 <LoRaMacConfirmQueueHandleCb>:

void LoRaMacConfirmQueueHandleCb( MlmeConfirm_t* mlmeConfirm )
{
 8035d54:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    uint8_t nbElements = ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt;
 8035d58:	4d12      	ldr	r5, [pc, #72]	; (8035da4 <LoRaMacConfirmQueueHandleCb+0x50>)
 8035d5a:	f895 8020 	ldrb.w	r8, [r5, #32]
{
 8035d5e:	4604      	mov	r4, r0
    bool readyToHandle = false;
    MlmeConfirmQueue_t mlmeConfirmToStore;

    for( uint8_t i = 0; i < nbElements; i++ )
 8035d60:	2600      	movs	r6, #0
 8035d62:	b2f3      	uxtb	r3, r6
 8035d64:	4598      	cmp	r8, r3
 8035d66:	d802      	bhi.n	8035d6e <LoRaMacConfirmQueueHandleCb+0x1a>
        {
            // Add a request which has not been finished again to the queue
            LoRaMacConfirmQueueAdd( &mlmeConfirmToStore );
        }
    }
}
 8035d68:	b002      	add	sp, #8
 8035d6a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        mlmeConfirm->MlmeRequest = ConfirmQueueCtx.BufferStart->Request;
 8035d6e:	686b      	ldr	r3, [r5, #4]
 8035d70:	7819      	ldrb	r1, [r3, #0]
 8035d72:	7021      	strb	r1, [r4, #0]
        mlmeConfirm->Status = ConfirmQueueCtx.BufferStart->Status;
 8035d74:	785a      	ldrb	r2, [r3, #1]
 8035d76:	7062      	strb	r2, [r4, #1]
        readyToHandle = ConfirmQueueCtx.BufferStart->ReadyToHandle;
 8035d78:	789f      	ldrb	r7, [r3, #2]
        if( readyToHandle == true )
 8035d7a:	b15f      	cbz	r7, 8035d94 <LoRaMacConfirmQueueHandleCb+0x40>
            ConfirmQueueCtx.Primitives->MacMlmeConfirm( mlmeConfirm );
 8035d7c:	682b      	ldr	r3, [r5, #0]
 8035d7e:	4620      	mov	r0, r4
 8035d80:	689b      	ldr	r3, [r3, #8]
 8035d82:	4798      	blx	r3
        LoRaMacConfirmQueueRemoveFirst( );
 8035d84:	f7ff ff88 	bl	8035c98 <LoRaMacConfirmQueueRemoveFirst>
        if( readyToHandle == false )
 8035d88:	b917      	cbnz	r7, 8035d90 <LoRaMacConfirmQueueHandleCb+0x3c>
            LoRaMacConfirmQueueAdd( &mlmeConfirmToStore );
 8035d8a:	a801      	add	r0, sp, #4
 8035d8c:	f7ff ff62 	bl	8035c54 <LoRaMacConfirmQueueAdd>
    for( uint8_t i = 0; i < nbElements; i++ )
 8035d90:	3601      	adds	r6, #1
 8035d92:	e7e6      	b.n	8035d62 <LoRaMacConfirmQueueHandleCb+0xe>
            mlmeConfirmToStore.RestrictCommonReadyToHandle = ConfirmQueueCtx.BufferStart->RestrictCommonReadyToHandle;
 8035d94:	78db      	ldrb	r3, [r3, #3]
            mlmeConfirmToStore.Request = ConfirmQueueCtx.BufferStart->Request;
 8035d96:	f88d 1004 	strb.w	r1, [sp, #4]
            mlmeConfirmToStore.Status = ConfirmQueueCtx.BufferStart->Status;
 8035d9a:	f88d 2005 	strb.w	r2, [sp, #5]
            mlmeConfirmToStore.RestrictCommonReadyToHandle = ConfirmQueueCtx.BufferStart->RestrictCommonReadyToHandle;
 8035d9e:	f88d 3007 	strb.w	r3, [sp, #7]
 8035da2:	e7ef      	b.n	8035d84 <LoRaMacConfirmQueueHandleCb+0x30>
 8035da4:	20005700 	.word	0x20005700

08035da8 <LoRaMacConfirmQueueGetCnt>:

uint8_t LoRaMacConfirmQueueGetCnt( void )
{
    return ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt;
}
 8035da8:	4b01      	ldr	r3, [pc, #4]	; (8035db0 <LoRaMacConfirmQueueGetCnt+0x8>)
 8035daa:	f893 0020 	ldrb.w	r0, [r3, #32]
 8035dae:	4770      	bx	lr
 8035db0:	20005700 	.word	0x20005700

08035db4 <LoRaMacConfirmQueueIsFull>:

bool LoRaMacConfirmQueueIsFull( void )
{
    if( IsListFull( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == true )
 8035db4:	4b03      	ldr	r3, [pc, #12]	; (8035dc4 <LoRaMacConfirmQueueIsFull+0x10>)
    if( count >= LORA_MAC_MLME_CONFIRM_QUEUE_LEN )
 8035db6:	f893 0020 	ldrb.w	r0, [r3, #32]
    }
    else
    {
        return false;
    }
}
 8035dba:	2804      	cmp	r0, #4
 8035dbc:	bf94      	ite	ls
 8035dbe:	2000      	movls	r0, #0
 8035dc0:	2001      	movhi	r0, #1
 8035dc2:	4770      	bx	lr
 8035dc4:	20005700 	.word	0x20005700

08035dc8 <DeriveSessionKey10x>:
 * \param[IN]  netID          - Network Identifier
 * \param[IN]  deviceNonce    - Device nonce
 * \retval                    - Status of the operation
 */
static LoRaMacCryptoStatus_t DeriveSessionKey10x( KeyIdentifier_t keyID, uint32_t joinNonce, uint32_t netID, uint16_t devNonce )
{
 8035dc8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    uint8_t compBase[16] = { 0 };
 8035dca:	2400      	movs	r4, #0
 8035dcc:	e9cd 4402 	strd	r4, r4, [sp, #8]

    /* ST_WORKAROUND_BEGIN: integrate 1.1.x keys only if required */
    switch( keyID )
 8035dd0:	1e44      	subs	r4, r0, #1
 8035dd2:	f88d 4000 	strb.w	r4, [sp]
        default:
            return LORAMAC_CRYPTO_ERROR_INVALID_KEY_ID;
    }
   /* ST_WORKAROUND_END */

    compBase[1] = ( uint8_t )( ( joinNonce >> 0 ) & 0xFF );
 8035dd6:	f88d 1001 	strb.w	r1, [sp, #1]
    compBase[2] = ( uint8_t )( ( joinNonce >> 8 ) & 0xFF );
 8035dda:	0a0c      	lsrs	r4, r1, #8
    compBase[3] = ( uint8_t )( ( joinNonce >> 16 ) & 0xFF );

    compBase[4] = ( uint8_t )( ( netID >> 0 ) & 0xFF );
 8035ddc:	f8ad 2004 	strh.w	r2, [sp, #4]
    compBase[3] = ( uint8_t )( ( joinNonce >> 16 ) & 0xFF );
 8035de0:	0c09      	lsrs	r1, r1, #16
    compBase[5] = ( uint8_t )( ( netID >> 8 ) & 0xFF );
    compBase[6] = ( uint8_t )( ( netID >> 16 ) & 0xFF );
 8035de2:	0c12      	lsrs	r2, r2, #16
    compBase[3] = ( uint8_t )( ( joinNonce >> 16 ) & 0xFF );
 8035de4:	f88d 1003 	strb.w	r1, [sp, #3]
    compBase[6] = ( uint8_t )( ( netID >> 16 ) & 0xFF );
 8035de8:	f88d 2006 	strb.w	r2, [sp, #6]

    compBase[7] = ( uint8_t )( ( devNonce >> 0 ) & 0xFF );
 8035dec:	f88d 3007 	strb.w	r3, [sp, #7]
    compBase[8] = ( uint8_t )( ( devNonce >> 8 ) & 0xFF );

    if( SecureElementDeriveAndStoreKey( compBase, NWK_KEY, keyID ) != SECURE_ELEMENT_SUCCESS )
 8035df0:	4602      	mov	r2, r0
    compBase[8] = ( uint8_t )( ( devNonce >> 8 ) & 0xFF );
 8035df2:	0a1b      	lsrs	r3, r3, #8
    if( SecureElementDeriveAndStoreKey( compBase, NWK_KEY, keyID ) != SECURE_ELEMENT_SUCCESS )
 8035df4:	2101      	movs	r1, #1
 8035df6:	4668      	mov	r0, sp
    compBase[2] = ( uint8_t )( ( joinNonce >> 8 ) & 0xFF );
 8035df8:	f88d 4002 	strb.w	r4, [sp, #2]
    compBase[8] = ( uint8_t )( ( devNonce >> 8 ) & 0xFF );
 8035dfc:	f88d 3008 	strb.w	r3, [sp, #8]
    if( SecureElementDeriveAndStoreKey( compBase, NWK_KEY, keyID ) != SECURE_ELEMENT_SUCCESS )
 8035e00:	f002 ffa0 	bl	8038d44 <SecureElementDeriveAndStoreKey>
 8035e04:	2800      	cmp	r0, #0
    {
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
    }

    return LORAMAC_CRYPTO_SUCCESS;
}
 8035e06:	bf18      	it	ne
 8035e08:	200f      	movne	r0, #15
 8035e0a:	b004      	add	sp, #16
 8035e0c:	bd10      	pop	{r4, pc}

08035e0e <PayloadEncrypt>:
{
 8035e0e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8035e12:	b088      	sub	sp, #32
 8035e14:	4617      	mov	r7, r2
 8035e16:	460d      	mov	r5, r1
 8035e18:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    if( buffer == 0 )
 8035e1a:	4606      	mov	r6, r0
 8035e1c:	2800      	cmp	r0, #0
 8035e1e:	d04d      	beq.n	8035ebc <PayloadEncrypt+0xae>
    uint8_t sBlock[16] = { 0 };
 8035e20:	2400      	movs	r4, #0
    aBlock[0] = 0x01;
 8035e22:	2101      	movs	r1, #1
    uint8_t aBlock[16] = { 0 };
 8035e24:	e9cd 4404 	strd	r4, r4, [sp, #16]
    aBlock[0] = 0x01;
 8035e28:	f88d 1010 	strb.w	r1, [sp, #16]
    aBlock[5] = dir;
 8035e2c:	f89d 1038 	ldrb.w	r1, [sp, #56]	; 0x38
 8035e30:	f88d 1015 	strb.w	r1, [sp, #21]
    aBlock[6] = address & 0xFF;
 8035e34:	f8ad 3016 	strh.w	r3, [sp, #22]
    aBlock[8] = ( address >> 16 ) & 0xFF;
 8035e38:	0c19      	lsrs	r1, r3, #16
    uint8_t sBlock[16] = { 0 };
 8035e3a:	e9cd 4400 	strd	r4, r4, [sp]
    aBlock[9] = ( address >> 24 ) & 0xFF;
 8035e3e:	0e1b      	lsrs	r3, r3, #24
    uint8_t sBlock[16] = { 0 };
 8035e40:	e9cd 4402 	strd	r4, r4, [sp, #8]
    aBlock[9] = ( address >> 24 ) & 0xFF;
 8035e44:	f88d 3019 	strb.w	r3, [sp, #25]
    aBlock[10] = frameCounter & 0xFF;
 8035e48:	f8ad 201a 	strh.w	r2, [sp, #26]
    aBlock[12] = ( frameCounter >> 16 ) & 0xFF;
 8035e4c:	0c13      	lsrs	r3, r2, #16
    aBlock[13] = ( frameCounter >> 24 ) & 0xFF;
 8035e4e:	0e12      	lsrs	r2, r2, #24
    uint8_t aBlock[16] = { 0 };
 8035e50:	9407      	str	r4, [sp, #28]
    aBlock[8] = ( address >> 16 ) & 0xFF;
 8035e52:	f88d 1018 	strb.w	r1, [sp, #24]
    aBlock[12] = ( frameCounter >> 16 ) & 0xFF;
 8035e56:	f88d 301c 	strb.w	r3, [sp, #28]
    aBlock[13] = ( frameCounter >> 24 ) & 0xFF;
 8035e5a:	f88d 201d 	strb.w	r2, [sp, #29]
    while( size > 0 )
 8035e5e:	b2e3      	uxtb	r3, r4
 8035e60:	ea4f 1803 	mov.w	r8, r3, lsl #4
 8035e64:	2d00      	cmp	r5, #0
 8035e66:	fa5f f888 	uxtb.w	r8, r8
 8035e6a:	dc03      	bgt.n	8035e74 <PayloadEncrypt+0x66>
    return LORAMAC_CRYPTO_SUCCESS;
 8035e6c:	2000      	movs	r0, #0
}
 8035e6e:	b008      	add	sp, #32
 8035e70:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        aBlock[15] = ctr & 0xFF;
 8035e74:	3301      	adds	r3, #1
        if( SecureElementAesEncrypt( aBlock, 16, keyID, sBlock ) != SECURE_ELEMENT_SUCCESS )
 8035e76:	2110      	movs	r1, #16
        aBlock[15] = ctr & 0xFF;
 8035e78:	f88d 301f 	strb.w	r3, [sp, #31]
        if( SecureElementAesEncrypt( aBlock, 16, keyID, sBlock ) != SECURE_ELEMENT_SUCCESS )
 8035e7c:	463a      	mov	r2, r7
 8035e7e:	466b      	mov	r3, sp
 8035e80:	eb0d 0001 	add.w	r0, sp, r1
 8035e84:	f002 fe76 	bl	8038b74 <SecureElementAesEncrypt>
 8035e88:	4603      	mov	r3, r0
 8035e8a:	b9c8      	cbnz	r0, 8035ec0 <PayloadEncrypt+0xb2>
        for( uint8_t i = 0; i < ( ( size > 16 ) ? 16 : size ); i++ )
 8035e8c:	2d10      	cmp	r5, #16
 8035e8e:	46ac      	mov	ip, r5
 8035e90:	bfa8      	it	ge
 8035e92:	f04f 0c10 	movge.w	ip, #16
 8035e96:	b2da      	uxtb	r2, r3
 8035e98:	4562      	cmp	r2, ip
 8035e9a:	f103 0301 	add.w	r3, r3, #1
 8035e9e:	db03      	blt.n	8035ea8 <PayloadEncrypt+0x9a>
        size -= 16;
 8035ea0:	3d10      	subs	r5, #16
 8035ea2:	b22d      	sxth	r5, r5
        bufferIndex += 16;
 8035ea4:	3401      	adds	r4, #1
 8035ea6:	e7da      	b.n	8035e5e <PayloadEncrypt+0x50>
            buffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i];
 8035ea8:	a908      	add	r1, sp, #32
 8035eaa:	eb08 0002 	add.w	r0, r8, r2
 8035eae:	440a      	add	r2, r1
 8035eb0:	5c31      	ldrb	r1, [r6, r0]
 8035eb2:	f812 2c20 	ldrb.w	r2, [r2, #-32]
 8035eb6:	404a      	eors	r2, r1
 8035eb8:	5432      	strb	r2, [r6, r0]
        for( uint8_t i = 0; i < ( ( size > 16 ) ? 16 : size ); i++ )
 8035eba:	e7ec      	b.n	8035e96 <PayloadEncrypt+0x88>
        return LORAMAC_CRYPTO_ERROR_NPE;
 8035ebc:	200a      	movs	r0, #10
 8035ebe:	e7d6      	b.n	8035e6e <PayloadEncrypt+0x60>
            return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 8035ec0:	200f      	movs	r0, #15
 8035ec2:	e7d4      	b.n	8035e6e <PayloadEncrypt+0x60>

08035ec4 <GetLastFcntDown>:
{
    if( lastDown == NULL )
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
    }
    switch( fCntID )
 8035ec4:	3801      	subs	r0, #1
 8035ec6:	2803      	cmp	r0, #3
 8035ec8:	d81c      	bhi.n	8035f04 <GetLastFcntDown+0x40>
 8035eca:	e8df f000 	tbb	[pc, r0]
 8035ece:	0a02      	.short	0x0a02
 8035ed0:	1610      	.short	0x1610
    {
        case N_FCNT_DOWN:
            *lastDown = CryptoNvm->FCntList.NFCntDown;
 8035ed2:	4b0d      	ldr	r3, [pc, #52]	; (8035f08 <GetLastFcntDown+0x44>)
 8035ed4:	681b      	ldr	r3, [r3, #0]
 8035ed6:	691a      	ldr	r2, [r3, #16]
 8035ed8:	600a      	str	r2, [r1, #0]
            CryptoNvm->LastDownFCnt = CryptoNvm->FCntList.NFCntDown;
 8035eda:	691a      	ldr	r2, [r3, #16]
            break;
        case A_FCNT_DOWN:
            *lastDown = CryptoNvm->FCntList.AFCntDown;
            CryptoNvm->LastDownFCnt = CryptoNvm->FCntList.AFCntDown;
 8035edc:	621a      	str	r2, [r3, #32]
            break;
#endif /* LORAMAC_MAX_MC_CTX > 3 */
        default:
            return LORAMAC_CRYPTO_FAIL_FCNT_ID;
    }
    return LORAMAC_CRYPTO_SUCCESS;
 8035ede:	2000      	movs	r0, #0
            break;
 8035ee0:	4770      	bx	lr
            *lastDown = CryptoNvm->FCntList.AFCntDown;
 8035ee2:	4b09      	ldr	r3, [pc, #36]	; (8035f08 <GetLastFcntDown+0x44>)
 8035ee4:	681b      	ldr	r3, [r3, #0]
 8035ee6:	695a      	ldr	r2, [r3, #20]
 8035ee8:	600a      	str	r2, [r1, #0]
            CryptoNvm->LastDownFCnt = CryptoNvm->FCntList.AFCntDown;
 8035eea:	695a      	ldr	r2, [r3, #20]
 8035eec:	e7f6      	b.n	8035edc <GetLastFcntDown+0x18>
            *lastDown = CryptoNvm->FCntList.FCntDown;
 8035eee:	4b06      	ldr	r3, [pc, #24]	; (8035f08 <GetLastFcntDown+0x44>)
 8035ef0:	681b      	ldr	r3, [r3, #0]
 8035ef2:	699a      	ldr	r2, [r3, #24]
 8035ef4:	600a      	str	r2, [r1, #0]
            CryptoNvm->LastDownFCnt = CryptoNvm->FCntList.FCntDown;
 8035ef6:	699a      	ldr	r2, [r3, #24]
 8035ef8:	e7f0      	b.n	8035edc <GetLastFcntDown+0x18>
            *lastDown = CryptoNvm->FCntList.McFCntDown[0];
 8035efa:	4b03      	ldr	r3, [pc, #12]	; (8035f08 <GetLastFcntDown+0x44>)
 8035efc:	681b      	ldr	r3, [r3, #0]
 8035efe:	69db      	ldr	r3, [r3, #28]
 8035f00:	600b      	str	r3, [r1, #0]
            break;
 8035f02:	e7ec      	b.n	8035ede <GetLastFcntDown+0x1a>
            CryptoNvm->LastDownFCnt = CryptoNvm->FCntList.NFCntDown;
 8035f04:	2005      	movs	r0, #5
}
 8035f06:	4770      	bx	lr
 8035f08:	20005724 	.word	0x20005724

08035f0c <LoRaMacCryptoDeriveMcKEKey.part.0>:
    }

    return LORAMAC_CRYPTO_SUCCESS;
}

LoRaMacCryptoStatus_t LoRaMacCryptoDeriveMcKEKey( KeyIdentifier_t keyID )
 8035f0c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    // Prevent other keys than McRootKey
    if( keyID != MC_ROOT_KEY )
    {
        return LORAMAC_CRYPTO_ERROR_INVALID_KEY_ID;
    }
    uint8_t compBase[16] = { 0 };
 8035f0e:	2300      	movs	r3, #0

    if( SecureElementDeriveAndStoreKey( compBase, keyID, MC_KE_KEY ) != SECURE_ELEMENT_SUCCESS )
 8035f10:	227f      	movs	r2, #127	; 0x7f
 8035f12:	2104      	movs	r1, #4
 8035f14:	4668      	mov	r0, sp
    uint8_t compBase[16] = { 0 };
 8035f16:	e9cd 3300 	strd	r3, r3, [sp]
 8035f1a:	e9cd 3302 	strd	r3, r3, [sp, #8]
    if( SecureElementDeriveAndStoreKey( compBase, keyID, MC_KE_KEY ) != SECURE_ELEMENT_SUCCESS )
 8035f1e:	f002 ff11 	bl	8038d44 <SecureElementDeriveAndStoreKey>
 8035f22:	2800      	cmp	r0, #0
    {
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
    }

    return LORAMAC_CRYPTO_SUCCESS;
}
 8035f24:	bf18      	it	ne
 8035f26:	200f      	movne	r0, #15
 8035f28:	b005      	add	sp, #20
 8035f2a:	f85d fb04 	ldr.w	pc, [sp], #4

08035f2e <VerifyCmacB0.isra.0.constprop.0>:
static LoRaMacCryptoStatus_t VerifyCmacB0( uint8_t* msg, uint16_t len, KeyIdentifier_t keyID, bool isAck, uint8_t dir, uint32_t devAddr, uint32_t fCnt, uint32_t expectedCmac )
 8035f2e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8035f32:	b0c4      	sub	sp, #272	; 0x110
 8035f34:	460c      	mov	r4, r1
 8035f36:	9e4a      	ldr	r6, [sp, #296]	; 0x128
 8035f38:	4617      	mov	r7, r2
 8035f3a:	461d      	mov	r5, r3
    if( msg == 0 )
 8035f3c:	4680      	mov	r8, r0
 8035f3e:	b3b8      	cbz	r0, 8035fb0 <VerifyCmacB0.isra.0.constprop.0+0x82>
    if( len > CRYPTO_MAXMESSAGE_SIZE )
 8035f40:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 8035f44:	d836      	bhi.n	8035fb4 <VerifyCmacB0.isra.0.constprop.0+0x86>
    memset1( micBuff, 0, CRYPTO_BUFFER_SIZE );
 8035f46:	f44f 7288 	mov.w	r2, #272	; 0x110
 8035f4a:	2100      	movs	r1, #0
 8035f4c:	4668      	mov	r0, sp
 8035f4e:	f003 f801 	bl	8038f54 <memset1>
    b0[0] = 0x49;
 8035f52:	2349      	movs	r3, #73	; 0x49
 8035f54:	9300      	str	r3, [sp, #0]
    b0[4] = 0x00;
 8035f56:	f44f 7380 	mov.w	r3, #256	; 0x100
 8035f5a:	f8ad 3004 	strh.w	r3, [sp, #4]
    b0[8] = ( devAddr >> 16 ) & 0xFF;
 8035f5e:	0c2b      	lsrs	r3, r5, #16
 8035f60:	f88d 3008 	strb.w	r3, [sp, #8]
    b0[12] = ( fCnt >> 16 ) & 0xFF;
 8035f64:	0c33      	lsrs	r3, r6, #16
    b0[6] = devAddr & 0xFF;
 8035f66:	f8ad 5006 	strh.w	r5, [sp, #6]
    b0[10] = fCnt & 0xFF;
 8035f6a:	f8ad 600a 	strh.w	r6, [sp, #10]
    b0[12] = ( fCnt >> 16 ) & 0xFF;
 8035f6e:	f88d 300c 	strb.w	r3, [sp, #12]
    memcpy1( ( micBuff + MIC_BLOCK_BX_SIZE ), msg, len );
 8035f72:	4622      	mov	r2, r4
    b0[14] = 0x00;
 8035f74:	2300      	movs	r3, #0
    memcpy1( ( micBuff + MIC_BLOCK_BX_SIZE ), msg, len );
 8035f76:	4641      	mov	r1, r8
 8035f78:	a804      	add	r0, sp, #16
    b0[9] = ( devAddr >> 24 ) & 0xFF;
 8035f7a:	0e2d      	lsrs	r5, r5, #24
    b0[13] = ( fCnt >> 24 ) & 0xFF;
 8035f7c:	0e36      	lsrs	r6, r6, #24
    b0[14] = 0x00;
 8035f7e:	f88d 300e 	strb.w	r3, [sp, #14]
    b0[9] = ( devAddr >> 24 ) & 0xFF;
 8035f82:	f88d 5009 	strb.w	r5, [sp, #9]
    b0[13] = ( fCnt >> 24 ) & 0xFF;
 8035f86:	f88d 600d 	strb.w	r6, [sp, #13]
    b0[15] = msgLen & 0xFF;
 8035f8a:	f88d 400f 	strb.w	r4, [sp, #15]
    memcpy1( ( micBuff + MIC_BLOCK_BX_SIZE ), msg, len );
 8035f8e:	f002 ffcd 	bl	8038f2c <memcpy1>
    retval = SecureElementVerifyAesCmac( micBuff, ( len + MIC_BLOCK_BX_SIZE ), expectedCmac, keyID );
 8035f92:	f104 0110 	add.w	r1, r4, #16
 8035f96:	9a4b      	ldr	r2, [sp, #300]	; 0x12c
 8035f98:	463b      	mov	r3, r7
 8035f9a:	b289      	uxth	r1, r1
 8035f9c:	4668      	mov	r0, sp
 8035f9e:	f002 fdab 	bl	8038af8 <SecureElementVerifyAesCmac>
    if( retval == SECURE_ELEMENT_SUCCESS )
 8035fa2:	b110      	cbz	r0, 8035faa <VerifyCmacB0.isra.0.constprop.0+0x7c>
    return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 8035fa4:	2801      	cmp	r0, #1
 8035fa6:	bf18      	it	ne
 8035fa8:	200f      	movne	r0, #15
}
 8035faa:	b044      	add	sp, #272	; 0x110
 8035fac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return LORAMAC_CRYPTO_ERROR_NPE;
 8035fb0:	200a      	movs	r0, #10
 8035fb2:	e7fa      	b.n	8035faa <VerifyCmacB0.isra.0.constprop.0+0x7c>
        return LORAMAC_CRYPTO_ERROR_BUF_SIZE;
 8035fb4:	200e      	movs	r0, #14
 8035fb6:	e7f8      	b.n	8035faa <VerifyCmacB0.isra.0.constprop.0+0x7c>

08035fb8 <LoRaMacCryptoInit>:
{
 8035fb8:	b510      	push	{r4, lr}
    if( nvm == NULL )
 8035fba:	b190      	cbz	r0, 8035fe2 <LoRaMacCryptoInit+0x2a>
    CryptoNvm = nvm;
 8035fbc:	4c0a      	ldr	r4, [pc, #40]	; (8035fe8 <LoRaMacCryptoInit+0x30>)
    memset1( ( uint8_t* )CryptoNvm, 0, sizeof( LoRaMacCryptoNvmData_t ) );
 8035fbe:	2228      	movs	r2, #40	; 0x28
 8035fc0:	2100      	movs	r1, #0
    CryptoNvm = nvm;
 8035fc2:	6020      	str	r0, [r4, #0]
    memset1( ( uint8_t* )CryptoNvm, 0, sizeof( LoRaMacCryptoNvmData_t ) );
 8035fc4:	f002 ffc6 	bl	8038f54 <memset1>
    CryptoNvm->LrWanVersion.Fields.Major = 1;
 8035fc8:	6823      	ldr	r3, [r4, #0]
    CryptoNvm->LrWanVersion.Fields.Revision = 0;
 8035fca:	4a08      	ldr	r2, [pc, #32]	; (8035fec <LoRaMacCryptoInit+0x34>)
 8035fcc:	601a      	str	r2, [r3, #0]
    CryptoNvm->FCntList.NFCntDown = FCNT_DOWN_INITAL_VALUE;
 8035fce:	2000      	movs	r0, #0
 8035fd0:	f04f 32ff 	mov.w	r2, #4294967295
 8035fd4:	e9c3 0203 	strd	r0, r2, [r3, #12]
    CryptoNvm->FCntList.FCntDown = FCNT_DOWN_INITAL_VALUE;
 8035fd8:	e9c3 2205 	strd	r2, r2, [r3, #20]
        CryptoNvm->FCntList.McFCntDown[i] = FCNT_DOWN_INITAL_VALUE;
 8035fdc:	e9c3 2207 	strd	r2, r2, [r3, #28]
}
 8035fe0:	bd10      	pop	{r4, pc}
        return LORAMAC_CRYPTO_FAIL_PARAM;
 8035fe2:	2009      	movs	r0, #9
 8035fe4:	e7fc      	b.n	8035fe0 <LoRaMacCryptoInit+0x28>
 8035fe6:	bf00      	nop
 8035fe8:	20005724 	.word	0x20005724
 8035fec:	01010100 	.word	0x01010100

08035ff0 <LoRaMacCryptoSetLrWanVersion>:
    CryptoNvm->LrWanVersion = version;
 8035ff0:	4b02      	ldr	r3, [pc, #8]	; (8035ffc <LoRaMacCryptoSetLrWanVersion+0xc>)
 8035ff2:	681b      	ldr	r3, [r3, #0]
 8035ff4:	6018      	str	r0, [r3, #0]
}
 8035ff6:	2000      	movs	r0, #0
 8035ff8:	4770      	bx	lr
 8035ffa:	bf00      	nop
 8035ffc:	20005724 	.word	0x20005724

08036000 <LoRaMacCryptoGetFCntUp>:
    if( currentUp == NULL )
 8036000:	b130      	cbz	r0, 8036010 <LoRaMacCryptoGetFCntUp+0x10>
    *currentUp = CryptoNvm->FCntList.FCntUp + 1;
 8036002:	4b04      	ldr	r3, [pc, #16]	; (8036014 <LoRaMacCryptoGetFCntUp+0x14>)
 8036004:	681b      	ldr	r3, [r3, #0]
 8036006:	68db      	ldr	r3, [r3, #12]
 8036008:	3301      	adds	r3, #1
 803600a:	6003      	str	r3, [r0, #0]
    return LORAMAC_CRYPTO_SUCCESS;
 803600c:	2000      	movs	r0, #0
 803600e:	4770      	bx	lr
        return LORAMAC_CRYPTO_ERROR_NPE;
 8036010:	200a      	movs	r0, #10
}
 8036012:	4770      	bx	lr
 8036014:	20005724 	.word	0x20005724

08036018 <LoRaMacCryptoGetFCntDown>:
{
 8036018:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 803601a:	4617      	mov	r7, r2
    uint32_t lastDown = 0;
 803601c:	2200      	movs	r2, #0
{
 803601e:	460e      	mov	r6, r1
    uint32_t lastDown = 0;
 8036020:	9201      	str	r2, [sp, #4]
    if( currentDown == NULL )
 8036022:	461c      	mov	r4, r3
 8036024:	b353      	cbz	r3, 803607c <LoRaMacCryptoGetFCntDown+0x64>
    cryptoStatus = GetLastFcntDown( fCntID, &lastDown );
 8036026:	a901      	add	r1, sp, #4
 8036028:	f7ff ff4c 	bl	8035ec4 <GetLastFcntDown>
    if( cryptoStatus != LORAMAC_CRYPTO_SUCCESS )
 803602c:	b9e8      	cbnz	r0, 803606a <LoRaMacCryptoGetFCntDown+0x52>
    if( lastDown == FCNT_DOWN_INITAL_VALUE )
 803602e:	9d01      	ldr	r5, [sp, #4]
 8036030:	1c6b      	adds	r3, r5, #1
 8036032:	d110      	bne.n	8036056 <LoRaMacCryptoGetFCntDown+0x3e>
        *currentDown = frameFcnt;
 8036034:	6027      	str	r7, [r4, #0]
    if( CryptoNvm->LrWanVersion.Fields.Minor == 0 )
 8036036:	4b12      	ldr	r3, [pc, #72]	; (8036080 <LoRaMacCryptoGetFCntDown+0x68>)
 8036038:	681b      	ldr	r3, [r3, #0]
 803603a:	789b      	ldrb	r3, [r3, #2]
 803603c:	b9ab      	cbnz	r3, 803606a <LoRaMacCryptoGetFCntDown+0x52>
        if( ( ( int64_t )*currentDown - ( int64_t )lastDown ) >= maxFCntGap )
 803603e:	6822      	ldr	r2, [r4, #0]
 8036040:	b2b6      	uxth	r6, r6
 8036042:	1b52      	subs	r2, r2, r5
 8036044:	eb62 0302 	sbc.w	r3, r2, r2
 8036048:	2700      	movs	r7, #0
 803604a:	42b2      	cmp	r2, r6
 803604c:	41bb      	sbcs	r3, r7
            return LORAMAC_CRYPTO_FAIL_MAX_GAP_FCNT;
 803604e:	bfb4      	ite	lt
 8036050:	2000      	movlt	r0, #0
 8036052:	2008      	movge	r0, #8
 8036054:	e009      	b.n	803606a <LoRaMacCryptoGetFCntDown+0x52>
        fCntDiff = ( int32_t )( ( int64_t )frameFcnt - ( int64_t )( lastDown & 0x0000FFFF ) );
 8036056:	b2a9      	uxth	r1, r5
 8036058:	1a79      	subs	r1, r7, r1
        if( fCntDiff > 0 )
 803605a:	2900      	cmp	r1, #0
 803605c:	dd02      	ble.n	8036064 <LoRaMacCryptoGetFCntDown+0x4c>
            *currentDown = lastDown + fCntDiff;
 803605e:	4429      	add	r1, r5
 8036060:	6021      	str	r1, [r4, #0]
 8036062:	e7e8      	b.n	8036036 <LoRaMacCryptoGetFCntDown+0x1e>
        else if( fCntDiff == 0 )
 8036064:	d103      	bne.n	803606e <LoRaMacCryptoGetFCntDown+0x56>
            *currentDown = lastDown;
 8036066:	6025      	str	r5, [r4, #0]
            return LORAMAC_CRYPTO_FAIL_FCNT_DUPLICATED;
 8036068:	2007      	movs	r0, #7
}
 803606a:	b003      	add	sp, #12
 803606c:	bdf0      	pop	{r4, r5, r6, r7, pc}
            *currentDown = ( lastDown & 0xFFFF0000 ) + 0x10000 + frameFcnt;
 803606e:	0c2b      	lsrs	r3, r5, #16
 8036070:	041b      	lsls	r3, r3, #16
 8036072:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 8036076:	443b      	add	r3, r7
 8036078:	6023      	str	r3, [r4, #0]
 803607a:	e7dc      	b.n	8036036 <LoRaMacCryptoGetFCntDown+0x1e>
        return LORAMAC_CRYPTO_ERROR_NPE;
 803607c:	200a      	movs	r0, #10
 803607e:	e7f4      	b.n	803606a <LoRaMacCryptoGetFCntDown+0x52>
 8036080:	20005724 	.word	0x20005724

08036084 <LoRaMacCryptoSetMulticastReference>:
    if( multicastList == NULL )
 8036084:	b128      	cbz	r0, 8036092 <LoRaMacCryptoSetMulticastReference+0xe>
        multicastList[i].DownLinkCounter = &CryptoNvm->FCntList.McFCntDown[i];
 8036086:	4b04      	ldr	r3, [pc, #16]	; (8036098 <LoRaMacCryptoSetMulticastReference+0x14>)
 8036088:	681b      	ldr	r3, [r3, #0]
 803608a:	331c      	adds	r3, #28
 803608c:	6203      	str	r3, [r0, #32]
    return LORAMAC_CRYPTO_SUCCESS;
 803608e:	2000      	movs	r0, #0
 8036090:	4770      	bx	lr
        return LORAMAC_CRYPTO_ERROR_NPE;
 8036092:	200a      	movs	r0, #10
}
 8036094:	4770      	bx	lr
 8036096:	bf00      	nop
 8036098:	20005724 	.word	0x20005724

0803609c <LoRaMacCryptoPrepareJoinRequest>:
{
 803609c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    if( macMsg == 0 )
 803609e:	4604      	mov	r4, r0
 80360a0:	b1f0      	cbz	r0, 80360e0 <LoRaMacCryptoPrepareJoinRequest+0x44>
    uint32_t devNonce = 0;
 80360a2:	2300      	movs	r3, #0
    SecureElementRandomNumber( &devNonce );
 80360a4:	a803      	add	r0, sp, #12
    uint32_t devNonce = 0;
 80360a6:	9303      	str	r3, [sp, #12]
    SecureElementRandomNumber( &devNonce );
 80360a8:	f002 fee6 	bl	8038e78 <SecureElementRandomNumber>
    CryptoNvm->DevNonce = devNonce;
 80360ac:	4a0e      	ldr	r2, [pc, #56]	; (80360e8 <LoRaMacCryptoPrepareJoinRequest+0x4c>)
 80360ae:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 80360b2:	6812      	ldr	r2, [r2, #0]
    if( LoRaMacSerializerJoinRequest( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 80360b4:	4620      	mov	r0, r4
    CryptoNvm->DevNonce = devNonce;
 80360b6:	8093      	strh	r3, [r2, #4]
    macMsg->DevNonce = CryptoNvm->DevNonce;
 80360b8:	82e3      	strh	r3, [r4, #22]
    if( LoRaMacSerializerJoinRequest( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 80360ba:	f000 fa82 	bl	80365c2 <LoRaMacSerializerJoinRequest>
 80360be:	b960      	cbnz	r0, 80360da <LoRaMacCryptoPrepareJoinRequest+0x3e>
    if( SecureElementComputeAesCmac( NULL, macMsg->Buffer, ( LORAMAC_JOIN_REQ_MSG_SIZE - LORAMAC_MIC_FIELD_SIZE ), micComputationKeyID, &macMsg->MIC ) != SECURE_ELEMENT_SUCCESS )
 80360c0:	f104 0318 	add.w	r3, r4, #24
 80360c4:	9300      	str	r3, [sp, #0]
 80360c6:	6821      	ldr	r1, [r4, #0]
 80360c8:	2301      	movs	r3, #1
 80360ca:	2213      	movs	r2, #19
 80360cc:	f002 fcae 	bl	8038a2c <SecureElementComputeAesCmac>
 80360d0:	b940      	cbnz	r0, 80360e4 <LoRaMacCryptoPrepareJoinRequest+0x48>
    if( LoRaMacSerializerJoinRequest( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 80360d2:	4620      	mov	r0, r4
 80360d4:	f000 fa75 	bl	80365c2 <LoRaMacSerializerJoinRequest>
 80360d8:	b100      	cbz	r0, 80360dc <LoRaMacCryptoPrepareJoinRequest+0x40>
        return LORAMAC_CRYPTO_ERROR_SERIALIZER;
 80360da:	2011      	movs	r0, #17
}
 80360dc:	b004      	add	sp, #16
 80360de:	bd10      	pop	{r4, pc}
        return LORAMAC_CRYPTO_ERROR_NPE;
 80360e0:	200a      	movs	r0, #10
 80360e2:	e7fb      	b.n	80360dc <LoRaMacCryptoPrepareJoinRequest+0x40>
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 80360e4:	200f      	movs	r0, #15
 80360e6:	e7f9      	b.n	80360dc <LoRaMacCryptoPrepareJoinRequest+0x40>
 80360e8:	20005724 	.word	0x20005724

080360ec <LoRaMacCryptoSecureMessage>:
{
 80360ec:	b5f0      	push	{r4, r5, r6, r7, lr}
 80360ee:	4605      	mov	r5, r0
 80360f0:	b087      	sub	sp, #28
    if( macMsg == NULL )
 80360f2:	461c      	mov	r4, r3
 80360f4:	b323      	cbz	r3, 8036140 <LoRaMacCryptoSecureMessage+0x54>
    if( fCntUp < CryptoNvm->FCntList.FCntUp )
 80360f6:	4e2f      	ldr	r6, [pc, #188]	; (80361b4 <LoRaMacCryptoSecureMessage+0xc8>)
 80360f8:	6833      	ldr	r3, [r6, #0]
 80360fa:	68db      	ldr	r3, [r3, #12]
 80360fc:	4283      	cmp	r3, r0
 80360fe:	d856      	bhi.n	80361ae <LoRaMacCryptoSecureMessage+0xc2>
    if( macMsg->FPort == 0 )
 8036100:	f894 2020 	ldrb.w	r2, [r4, #32]
        payloadDecryptionKeyID = NWK_S_KEY;
 8036104:	2a00      	cmp	r2, #0
 8036106:	bf14      	ite	ne
 8036108:	2203      	movne	r2, #3
 803610a:	2202      	moveq	r2, #2
    if( fCntUp > CryptoNvm->FCntList.FCntUp )
 803610c:	4283      	cmp	r3, r0
 803610e:	d305      	bcc.n	803611c <LoRaMacCryptoSecureMessage+0x30>
    if( LoRaMacSerializerData( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 8036110:	4620      	mov	r0, r4
 8036112:	f000 fa8a 	bl	803662a <LoRaMacSerializerData>
 8036116:	b170      	cbz	r0, 8036136 <LoRaMacCryptoSecureMessage+0x4a>
        return LORAMAC_CRYPTO_ERROR_SERIALIZER;
 8036118:	2011      	movs	r0, #17
 803611a:	e00a      	b.n	8036132 <LoRaMacCryptoSecureMessage+0x46>
        retval = PayloadEncrypt( macMsg->FRMPayload, macMsg->FRMPayloadSize, payloadDecryptionKeyID, macMsg->FHDR.DevAddr, UPLINK, fCntUp );
 803611c:	2300      	movs	r3, #0
 803611e:	9001      	str	r0, [sp, #4]
 8036120:	9300      	str	r3, [sp, #0]
 8036122:	68a3      	ldr	r3, [r4, #8]
 8036124:	f894 1028 	ldrb.w	r1, [r4, #40]	; 0x28
 8036128:	6a60      	ldr	r0, [r4, #36]	; 0x24
 803612a:	f7ff fe70 	bl	8035e0e <PayloadEncrypt>
        if( retval != LORAMAC_CRYPTO_SUCCESS )
 803612e:	2800      	cmp	r0, #0
 8036130:	d0ee      	beq.n	8036110 <LoRaMacCryptoSecureMessage+0x24>
}
 8036132:	b007      	add	sp, #28
 8036134:	bdf0      	pop	{r4, r5, r6, r7, pc}
        retval = ComputeCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), payloadDecryptionKeyID, false, UPLINK, macMsg->FHDR.DevAddr, fCntUp, &macMsg->MIC );
 8036136:	7923      	ldrb	r3, [r4, #4]
 8036138:	6821      	ldr	r1, [r4, #0]
 803613a:	3b04      	subs	r3, #4
 803613c:	b29a      	uxth	r2, r3
    if( ( msg == 0 ) || ( cmac == 0 ) )
 803613e:	b909      	cbnz	r1, 8036144 <LoRaMacCryptoSecureMessage+0x58>
        return LORAMAC_CRYPTO_ERROR_NPE;
 8036140:	200a      	movs	r0, #10
 8036142:	e7f6      	b.n	8036132 <LoRaMacCryptoSecureMessage+0x46>
    if( len > CRYPTO_MAXMESSAGE_SIZE )
 8036144:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 8036148:	d82f      	bhi.n	80361aa <LoRaMacCryptoSecureMessage+0xbe>
        retval = ComputeCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), payloadDecryptionKeyID, false, UPLINK, macMsg->FHDR.DevAddr, fCntUp, &macMsg->MIC );
 803614a:	68a7      	ldr	r7, [r4, #8]
    b0[5] = dir;
 803614c:	f8b4 c008 	ldrh.w	ip, [r4, #8]
    b0[6] = devAddr & 0xFF;
 8036150:	f8ad c00e 	strh.w	ip, [sp, #14]
    b0[8] = ( devAddr >> 16 ) & 0xFF;
 8036154:	ea4f 4c17 	mov.w	ip, r7, lsr #16
    b0[9] = ( devAddr >> 24 ) & 0xFF;
 8036158:	0e3f      	lsrs	r7, r7, #24
 803615a:	f88d 7011 	strb.w	r7, [sp, #17]
    b0[15] = msgLen & 0xFF;
 803615e:	f88d 3017 	strb.w	r3, [sp, #23]
    b0[12] = ( fCnt >> 16 ) & 0xFF;
 8036162:	0c2f      	lsrs	r7, r5, #16
        retval = ComputeCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), payloadDecryptionKeyID, false, UPLINK, macMsg->FHDR.DevAddr, fCntUp, &macMsg->MIC );
 8036164:	f104 032c 	add.w	r3, r4, #44	; 0x2c
    b0[0] = 0x49;
 8036168:	f04f 0e49 	mov.w	lr, #73	; 0x49
    b0[4] = 0x00;
 803616c:	f8ad 000c 	strh.w	r0, [sp, #12]
    b0[12] = ( fCnt >> 16 ) & 0xFF;
 8036170:	f88d 7014 	strb.w	r7, [sp, #20]
    b0[14] = 0x00;
 8036174:	f88d 0016 	strb.w	r0, [sp, #22]
    b0[13] = ( fCnt >> 24 ) & 0xFF;
 8036178:	0e2f      	lsrs	r7, r5, #24
    if( SecureElementComputeAesCmac( micBuff, msg, len, keyID, cmac ) != SECURE_ELEMENT_SUCCESS )
 803617a:	9300      	str	r3, [sp, #0]
 803617c:	a802      	add	r0, sp, #8
 803617e:	2302      	movs	r3, #2
    b0[0] = 0x49;
 8036180:	f8cd e008 	str.w	lr, [sp, #8]
    b0[8] = ( devAddr >> 16 ) & 0xFF;
 8036184:	f88d c010 	strb.w	ip, [sp, #16]
    b0[10] = fCnt & 0xFF;
 8036188:	f8ad 5012 	strh.w	r5, [sp, #18]
    b0[13] = ( fCnt >> 24 ) & 0xFF;
 803618c:	f88d 7015 	strb.w	r7, [sp, #21]
    if( SecureElementComputeAesCmac( micBuff, msg, len, keyID, cmac ) != SECURE_ELEMENT_SUCCESS )
 8036190:	f002 fc4c 	bl	8038a2c <SecureElementComputeAesCmac>
 8036194:	b108      	cbz	r0, 803619a <LoRaMacCryptoSecureMessage+0xae>
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 8036196:	200f      	movs	r0, #15
 8036198:	e7cb      	b.n	8036132 <LoRaMacCryptoSecureMessage+0x46>
    if( LoRaMacSerializerData( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 803619a:	4620      	mov	r0, r4
 803619c:	f000 fa45 	bl	803662a <LoRaMacSerializerData>
 80361a0:	2800      	cmp	r0, #0
 80361a2:	d1b9      	bne.n	8036118 <LoRaMacCryptoSecureMessage+0x2c>
    CryptoNvm->FCntList.FCntUp = fCntUp;
 80361a4:	6833      	ldr	r3, [r6, #0]
 80361a6:	60dd      	str	r5, [r3, #12]
    return LORAMAC_CRYPTO_SUCCESS;
 80361a8:	e7c3      	b.n	8036132 <LoRaMacCryptoSecureMessage+0x46>
        return LORAMAC_CRYPTO_ERROR_BUF_SIZE;
 80361aa:	200e      	movs	r0, #14
 80361ac:	e7c1      	b.n	8036132 <LoRaMacCryptoSecureMessage+0x46>
        return LORAMAC_CRYPTO_FAIL_FCNT_SMALLER;
 80361ae:	2006      	movs	r0, #6
 80361b0:	e7bf      	b.n	8036132 <LoRaMacCryptoSecureMessage+0x46>
 80361b2:	bf00      	nop
 80361b4:	20005724 	.word	0x20005724

080361b8 <LoRaMacCryptoUnsecureMessage>:
{
 80361b8:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 80361bc:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 80361be:	4680      	mov	r8, r0
 80361c0:	460f      	mov	r7, r1
 80361c2:	4616      	mov	r6, r2
 80361c4:	461c      	mov	r4, r3
    if( macMsg == 0 )
 80361c6:	2d00      	cmp	r5, #0
 80361c8:	d059      	beq.n	803627e <LoRaMacCryptoUnsecureMessage+0xc6>
    uint32_t lastDown = 0;
 80361ca:	2300      	movs	r3, #0
    if( GetLastFcntDown( fCntID, &lastDown ) != LORAMAC_CRYPTO_SUCCESS )
 80361cc:	a903      	add	r1, sp, #12
 80361ce:	4610      	mov	r0, r2
    uint32_t lastDown = 0;
 80361d0:	9303      	str	r3, [sp, #12]
    if( GetLastFcntDown( fCntID, &lastDown ) != LORAMAC_CRYPTO_SUCCESS )
 80361d2:	f7ff fe77 	bl	8035ec4 <GetLastFcntDown>
 80361d6:	b118      	cbz	r0, 80361e0 <LoRaMacCryptoUnsecureMessage+0x28>
        return LORAMAC_CRYPTO_FAIL_FCNT_SMALLER;
 80361d8:	2006      	movs	r0, #6
}
 80361da:	b004      	add	sp, #16
 80361dc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if( ( currentDown > lastDown ) ||
 80361e0:	9b03      	ldr	r3, [sp, #12]
 80361e2:	429c      	cmp	r4, r3
 80361e4:	d801      	bhi.n	80361ea <LoRaMacCryptoUnsecureMessage+0x32>
 80361e6:	3301      	adds	r3, #1
 80361e8:	d1f6      	bne.n	80361d8 <LoRaMacCryptoUnsecureMessage+0x20>
    if( LoRaMacParserData( macMsg ) != LORAMAC_PARSER_SUCCESS )
 80361ea:	4628      	mov	r0, r5
 80361ec:	f000 f98e 	bl	803650c <LoRaMacParserData>
 80361f0:	2800      	cmp	r0, #0
 80361f2:	d146      	bne.n	8036282 <LoRaMacCryptoUnsecureMessage+0xca>
        if( KeyAddrList[i].AddrID == addrID )
 80361f4:	4b26      	ldr	r3, [pc, #152]	; (8036290 <LoRaMacCryptoUnsecureMessage+0xd8>)
 80361f6:	781a      	ldrb	r2, [r3, #0]
 80361f8:	4542      	cmp	r2, r8
 80361fa:	d003      	beq.n	8036204 <LoRaMacCryptoUnsecureMessage+0x4c>
 80361fc:	791a      	ldrb	r2, [r3, #4]
 80361fe:	4542      	cmp	r2, r8
 8036200:	d141      	bne.n	8036286 <LoRaMacCryptoUnsecureMessage+0xce>
 8036202:	2001      	movs	r0, #1
    if( address != macMsg->FHDR.DevAddr )
 8036204:	68aa      	ldr	r2, [r5, #8]
 8036206:	42ba      	cmp	r2, r7
 8036208:	d13f      	bne.n	803628a <LoRaMacCryptoUnsecureMessage+0xd2>
    payloadDecryptionKeyID = curItem->AppSkey;
 803620a:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    retval = VerifyCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), micComputationKeyID, isAck, DOWNLINK, address, fCntDown, macMsg->MIC );
 803620e:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    payloadDecryptionKeyID = curItem->AppSkey;
 8036210:	f890 8001 	ldrb.w	r8, [r0, #1]
    retval = VerifyCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), micComputationKeyID, isAck, DOWNLINK, address, fCntDown, macMsg->MIC );
 8036214:	7929      	ldrb	r1, [r5, #4]
 8036216:	e9cd 4300 	strd	r4, r3, [sp]
 803621a:	3904      	subs	r1, #4
 803621c:	7882      	ldrb	r2, [r0, #2]
 803621e:	6828      	ldr	r0, [r5, #0]
 8036220:	463b      	mov	r3, r7
 8036222:	b289      	uxth	r1, r1
 8036224:	f7ff fe83 	bl	8035f2e <VerifyCmacB0.isra.0.constprop.0>
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 8036228:	2800      	cmp	r0, #0
 803622a:	d1d6      	bne.n	80361da <LoRaMacCryptoUnsecureMessage+0x22>
    if( macMsg->FPort == 0 )
 803622c:	f895 3020 	ldrb.w	r3, [r5, #32]
    retval = PayloadEncrypt( macMsg->FRMPayload, macMsg->FRMPayloadSize, payloadDecryptionKeyID, address, DOWNLINK, fCntDown );
 8036230:	9401      	str	r4, [sp, #4]
        payloadDecryptionKeyID = NWK_S_KEY;
 8036232:	2b00      	cmp	r3, #0
    retval = PayloadEncrypt( macMsg->FRMPayload, macMsg->FRMPayloadSize, payloadDecryptionKeyID, address, DOWNLINK, fCntDown );
 8036234:	f04f 0301 	mov.w	r3, #1
 8036238:	9300      	str	r3, [sp, #0]
 803623a:	bf14      	ite	ne
 803623c:	4642      	movne	r2, r8
 803623e:	2202      	moveq	r2, #2
 8036240:	f895 1028 	ldrb.w	r1, [r5, #40]	; 0x28
 8036244:	6a68      	ldr	r0, [r5, #36]	; 0x24
 8036246:	463b      	mov	r3, r7
 8036248:	f7ff fde1 	bl	8035e0e <PayloadEncrypt>
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 803624c:	2800      	cmp	r0, #0
 803624e:	d1c4      	bne.n	80361da <LoRaMacCryptoUnsecureMessage+0x22>
    switch( fCntID )
 8036250:	3e01      	subs	r6, #1
 8036252:	2e03      	cmp	r6, #3
 8036254:	d8c1      	bhi.n	80361da <LoRaMacCryptoUnsecureMessage+0x22>
 8036256:	e8df f006 	tbb	[pc, r6]
 803625a:	0602      	.short	0x0602
 803625c:	0e0a      	.short	0x0e0a
            CryptoNvm->FCntList.NFCntDown = currentDown;
 803625e:	4b0d      	ldr	r3, [pc, #52]	; (8036294 <LoRaMacCryptoUnsecureMessage+0xdc>)
 8036260:	681b      	ldr	r3, [r3, #0]
 8036262:	611c      	str	r4, [r3, #16]
            break;
 8036264:	e7b9      	b.n	80361da <LoRaMacCryptoUnsecureMessage+0x22>
            CryptoNvm->FCntList.AFCntDown = currentDown;
 8036266:	4b0b      	ldr	r3, [pc, #44]	; (8036294 <LoRaMacCryptoUnsecureMessage+0xdc>)
 8036268:	681b      	ldr	r3, [r3, #0]
 803626a:	615c      	str	r4, [r3, #20]
            break;
 803626c:	e7b5      	b.n	80361da <LoRaMacCryptoUnsecureMessage+0x22>
            CryptoNvm->FCntList.FCntDown = currentDown;
 803626e:	4b09      	ldr	r3, [pc, #36]	; (8036294 <LoRaMacCryptoUnsecureMessage+0xdc>)
 8036270:	681b      	ldr	r3, [r3, #0]
 8036272:	619c      	str	r4, [r3, #24]
            break;
 8036274:	e7b1      	b.n	80361da <LoRaMacCryptoUnsecureMessage+0x22>
            CryptoNvm->FCntList.McFCntDown[0] = currentDown;
 8036276:	4b07      	ldr	r3, [pc, #28]	; (8036294 <LoRaMacCryptoUnsecureMessage+0xdc>)
 8036278:	681b      	ldr	r3, [r3, #0]
 803627a:	61dc      	str	r4, [r3, #28]
            break;
 803627c:	e7ad      	b.n	80361da <LoRaMacCryptoUnsecureMessage+0x22>
        return LORAMAC_CRYPTO_ERROR_NPE;
 803627e:	200a      	movs	r0, #10
 8036280:	e7ab      	b.n	80361da <LoRaMacCryptoUnsecureMessage+0x22>
        return LORAMAC_CRYPTO_ERROR_PARSER;
 8036282:	2010      	movs	r0, #16
 8036284:	e7a9      	b.n	80361da <LoRaMacCryptoUnsecureMessage+0x22>
    return LORAMAC_CRYPTO_ERROR_INVALID_ADDR_ID;
 8036286:	200c      	movs	r0, #12
 8036288:	e7a7      	b.n	80361da <LoRaMacCryptoUnsecureMessage+0x22>
        return LORAMAC_CRYPTO_FAIL_ADDRESS;
 803628a:	2002      	movs	r0, #2
 803628c:	e7a5      	b.n	80361da <LoRaMacCryptoUnsecureMessage+0x22>
 803628e:	bf00      	nop
 8036290:	20003594 	.word	0x20003594
 8036294:	20005724 	.word	0x20005724

08036298 <LoRaMacCryptoDeriveMcRootKey>:
{
 8036298:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    if( keyID != APP_KEY )
 803629a:	b9b1      	cbnz	r1, 80362ca <LoRaMacCryptoDeriveMcRootKey+0x32>
    if( versionMinor == 1 )
 803629c:	2801      	cmp	r0, #1
    uint8_t compBase[16] = { 0 };
 803629e:	e9cd 1100 	strd	r1, r1, [sp]
        compBase[0] = 0x20;
 80362a2:	bf08      	it	eq
 80362a4:	2320      	moveq	r3, #32
    uint8_t compBase[16] = { 0 };
 80362a6:	e9cd 1102 	strd	r1, r1, [sp, #8]
    if( SecureElementDeriveAndStoreKey( compBase, keyID, MC_ROOT_KEY ) != SECURE_ELEMENT_SUCCESS )
 80362aa:	f04f 0204 	mov.w	r2, #4
 80362ae:	f04f 0100 	mov.w	r1, #0
 80362b2:	4668      	mov	r0, sp
        compBase[0] = 0x20;
 80362b4:	bf08      	it	eq
 80362b6:	f88d 3000 	strbeq.w	r3, [sp]
    if( SecureElementDeriveAndStoreKey( compBase, keyID, MC_ROOT_KEY ) != SECURE_ELEMENT_SUCCESS )
 80362ba:	f002 fd43 	bl	8038d44 <SecureElementDeriveAndStoreKey>
 80362be:	2800      	cmp	r0, #0
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 80362c0:	bf18      	it	ne
 80362c2:	200f      	movne	r0, #15
}
 80362c4:	b005      	add	sp, #20
 80362c6:	f85d fb04 	ldr.w	pc, [sp], #4
        return LORAMAC_CRYPTO_ERROR_INVALID_KEY_ID;
 80362ca:	200b      	movs	r0, #11
 80362cc:	e7fa      	b.n	80362c4 <LoRaMacCryptoDeriveMcRootKey+0x2c>
	...

080362d0 <LoRaMacCryptoSetKey>:
{
 80362d0:	b538      	push	{r3, r4, r5, lr}
 80362d2:	4605      	mov	r5, r0
    if( SecureElementSetKey( keyID, key ) != SECURE_ELEMENT_SUCCESS )
 80362d4:	f002 fcb0 	bl	8038c38 <SecureElementSetKey>
 80362d8:	4604      	mov	r4, r0
 80362da:	b950      	cbnz	r0, 80362f2 <LoRaMacCryptoSetKey+0x22>
    if( keyID == APP_KEY )
 80362dc:	b955      	cbnz	r5, 80362f4 <LoRaMacCryptoSetKey+0x24>
        if( LoRaMacCryptoDeriveMcRootKey( CryptoNvm->LrWanVersion.Fields.Minor, keyID ) != LORAMAC_CRYPTO_SUCCESS )
 80362de:	4b06      	ldr	r3, [pc, #24]	; (80362f8 <LoRaMacCryptoSetKey+0x28>)
 80362e0:	681b      	ldr	r3, [r3, #0]
 80362e2:	4601      	mov	r1, r0
 80362e4:	7898      	ldrb	r0, [r3, #2]
 80362e6:	f7ff ffd7 	bl	8036298 <LoRaMacCryptoDeriveMcRootKey>
 80362ea:	b910      	cbnz	r0, 80362f2 <LoRaMacCryptoSetKey+0x22>
    if( keyID != MC_ROOT_KEY )
 80362ec:	f7ff fe0e 	bl	8035f0c <LoRaMacCryptoDeriveMcKEKey.part.0>
        if( LoRaMacCryptoDeriveMcKEKey( MC_ROOT_KEY ) != LORAMAC_CRYPTO_SUCCESS )
 80362f0:	b100      	cbz	r0, 80362f4 <LoRaMacCryptoSetKey+0x24>
            return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 80362f2:	240f      	movs	r4, #15
}
 80362f4:	4620      	mov	r0, r4
 80362f6:	bd38      	pop	{r3, r4, r5, pc}
 80362f8:	20005724 	.word	0x20005724

080362fc <LoRaMacCryptoHandleJoinAccept>:
{
 80362fc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8036300:	4680      	mov	r8, r0
 8036302:	b08f      	sub	sp, #60	; 0x3c
 8036304:	460d      	mov	r5, r1
    if( ( macMsg == 0 ) || ( joinEUI == 0 ) )
 8036306:	4614      	mov	r4, r2
 8036308:	2a00      	cmp	r2, #0
 803630a:	d05f      	beq.n	80363cc <LoRaMacCryptoHandleJoinAccept+0xd0>
 803630c:	2900      	cmp	r1, #0
 803630e:	d05d      	beq.n	80363cc <LoRaMacCryptoHandleJoinAccept+0xd0>
    uint8_t decJoinAccept[LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE] = { 0 };
 8036310:	2600      	movs	r6, #0
 8036312:	4631      	mov	r1, r6
 8036314:	221d      	movs	r2, #29
 8036316:	a806      	add	r0, sp, #24
 8036318:	9605      	str	r6, [sp, #20]
 803631a:	f005 fa33 	bl	803b784 <memset>
    uint8_t versionMinor         = 0;
 803631e:	f88d 6013 	strb.w	r6, [sp, #19]
    uint16_t nonce               = CryptoNvm->DevNonce;
 8036322:	4e2e      	ldr	r6, [pc, #184]	; (80363dc <LoRaMacCryptoHandleJoinAccept+0xe0>)
 8036324:	6833      	ldr	r3, [r6, #0]
    if( SecureElementProcessJoinAccept( joinReqType, joinEUI, nonce, macMsg->Buffer,
 8036326:	f10d 0914 	add.w	r9, sp, #20
    uint16_t nonce               = CryptoNvm->DevNonce;
 803632a:	889f      	ldrh	r7, [r3, #4]
    if( SecureElementProcessJoinAccept( joinReqType, joinEUI, nonce, macMsg->Buffer,
 803632c:	f8cd 9004 	str.w	r9, [sp, #4]
 8036330:	f10d 0313 	add.w	r3, sp, #19
 8036334:	9302      	str	r3, [sp, #8]
 8036336:	7923      	ldrb	r3, [r4, #4]
 8036338:	9300      	str	r3, [sp, #0]
 803633a:	6823      	ldr	r3, [r4, #0]
 803633c:	463a      	mov	r2, r7
 803633e:	4629      	mov	r1, r5
 8036340:	4640      	mov	r0, r8
 8036342:	f002 fd55 	bl	8038df0 <SecureElementProcessJoinAccept>
 8036346:	2800      	cmp	r0, #0
 8036348:	d142      	bne.n	80363d0 <LoRaMacCryptoHandleJoinAccept+0xd4>
    memcpy1( macMsg->Buffer, decJoinAccept, macMsg->BufSize );
 803634a:	4649      	mov	r1, r9
 803634c:	7922      	ldrb	r2, [r4, #4]
 803634e:	6820      	ldr	r0, [r4, #0]
 8036350:	f002 fdec 	bl	8038f2c <memcpy1>
    if( LoRaMacParserJoinAccept( macMsg ) != LORAMAC_PARSER_SUCCESS )
 8036354:	4620      	mov	r0, r4
 8036356:	f000 f88b 	bl	8036470 <LoRaMacParserJoinAccept>
 803635a:	4601      	mov	r1, r0
 803635c:	2800      	cmp	r0, #0
 803635e:	d139      	bne.n	80363d4 <LoRaMacCryptoHandleJoinAccept+0xd8>
    currentJoinNonce |= ( ( uint32_t )macMsg->JoinNonce[2] << 16 );
 8036360:	7a25      	ldrb	r5, [r4, #8]
    currentJoinNonce |= ( ( uint32_t )macMsg->JoinNonce[1] << 8 );
 8036362:	79e2      	ldrb	r2, [r4, #7]
    currentJoinNonce = ( uint32_t )macMsg->JoinNonce[0];
 8036364:	79a3      	ldrb	r3, [r4, #6]
    currentJoinNonce |= ( ( uint32_t )macMsg->JoinNonce[2] << 16 );
 8036366:	042d      	lsls	r5, r5, #16
 8036368:	ea45 2502 	orr.w	r5, r5, r2, lsl #8
 803636c:	431d      	orrs	r5, r3
    if( currentJoinNonce != CryptoNvm->JoinNonce )
 803636e:	6833      	ldr	r3, [r6, #0]
 8036370:	689a      	ldr	r2, [r3, #8]
 8036372:	42aa      	cmp	r2, r5
 8036374:	d030      	beq.n	80363d8 <LoRaMacCryptoHandleJoinAccept+0xdc>
    retval = LoRaMacCryptoDeriveMcRootKey( versionMinor, APP_KEY );
 8036376:	f89d 0013 	ldrb.w	r0, [sp, #19]
        CryptoNvm->JoinNonce = currentJoinNonce;
 803637a:	609d      	str	r5, [r3, #8]
    retval = LoRaMacCryptoDeriveMcRootKey( versionMinor, APP_KEY );
 803637c:	f7ff ff8c 	bl	8036298 <LoRaMacCryptoDeriveMcRootKey>
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 8036380:	bb08      	cbnz	r0, 80363c6 <LoRaMacCryptoHandleJoinAccept+0xca>
    if( keyID != MC_ROOT_KEY )
 8036382:	f7ff fdc3 	bl	8035f0c <LoRaMacCryptoDeriveMcKEKey.part.0>
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 8036386:	b9f0      	cbnz	r0, 80363c6 <LoRaMacCryptoHandleJoinAccept+0xca>
        netID = ( uint32_t )macMsg->NetID[0];
 8036388:	7a62      	ldrb	r2, [r4, #9]
        netID |= ( ( uint32_t )macMsg->NetID[1] << 8 );
 803638a:	7aa3      	ldrb	r3, [r4, #10]
        netID |= ( ( uint32_t )macMsg->NetID[2] << 16 );
 803638c:	7ae4      	ldrb	r4, [r4, #11]
 803638e:	0424      	lsls	r4, r4, #16
 8036390:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
 8036394:	4314      	orrs	r4, r2
        retval = DeriveSessionKey10x( APP_S_KEY, currentJoinNonce, netID, nonce );
 8036396:	463b      	mov	r3, r7
 8036398:	4622      	mov	r2, r4
 803639a:	4629      	mov	r1, r5
 803639c:	2003      	movs	r0, #3
 803639e:	f7ff fd13 	bl	8035dc8 <DeriveSessionKey10x>
        if( retval != LORAMAC_CRYPTO_SUCCESS )
 80363a2:	b980      	cbnz	r0, 80363c6 <LoRaMacCryptoHandleJoinAccept+0xca>
        retval = DeriveSessionKey10x( NWK_S_KEY, currentJoinNonce, netID, nonce );
 80363a4:	463b      	mov	r3, r7
 80363a6:	4622      	mov	r2, r4
 80363a8:	4629      	mov	r1, r5
 80363aa:	2002      	movs	r0, #2
 80363ac:	f7ff fd0c 	bl	8035dc8 <DeriveSessionKey10x>
        if( retval != LORAMAC_CRYPTO_SUCCESS )
 80363b0:	b948      	cbnz	r0, 80363c6 <LoRaMacCryptoHandleJoinAccept+0xca>
    CryptoNvm->LrWanVersion.Fields.Minor = versionMinor;
 80363b2:	6833      	ldr	r3, [r6, #0]
 80363b4:	f89d 2013 	ldrb.w	r2, [sp, #19]
 80363b8:	709a      	strb	r2, [r3, #2]
    CryptoNvm->FCntList.FCntDown = FCNT_DOWN_INITAL_VALUE;
 80363ba:	f04f 32ff 	mov.w	r2, #4294967295
    CryptoNvm->FCntList.AFCntDown = FCNT_DOWN_INITAL_VALUE;
 80363be:	e9c3 2204 	strd	r2, r2, [r3, #16]
    CryptoNvm->FCntList.FCntUp = 0;
 80363c2:	60d8      	str	r0, [r3, #12]
    CryptoNvm->FCntList.FCntDown = FCNT_DOWN_INITAL_VALUE;
 80363c4:	619a      	str	r2, [r3, #24]
}
 80363c6:	b00f      	add	sp, #60	; 0x3c
 80363c8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        return LORAMAC_CRYPTO_ERROR_NPE;
 80363cc:	200a      	movs	r0, #10
 80363ce:	e7fa      	b.n	80363c6 <LoRaMacCryptoHandleJoinAccept+0xca>
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 80363d0:	200f      	movs	r0, #15
 80363d2:	e7f8      	b.n	80363c6 <LoRaMacCryptoHandleJoinAccept+0xca>
        return LORAMAC_CRYPTO_ERROR_PARSER;
 80363d4:	2010      	movs	r0, #16
 80363d6:	e7f6      	b.n	80363c6 <LoRaMacCryptoHandleJoinAccept+0xca>
        return LORAMAC_CRYPTO_FAIL_JOIN_NONCE;
 80363d8:	2003      	movs	r0, #3
 80363da:	e7f4      	b.n	80363c6 <LoRaMacCryptoHandleJoinAccept+0xca>
 80363dc:	20005724 	.word	0x20005724

080363e0 <LoRaMacCryptoDeriveMcSessionKeyPair>:

LoRaMacCryptoStatus_t LoRaMacCryptoDeriveMcSessionKeyPair( AddressIdentifier_t addrID, uint32_t mcAddr )
{
 80363e0:	b570      	push	{r4, r5, r6, lr}
 80363e2:	b088      	sub	sp, #32
    if( mcAddr == 0 )
 80363e4:	2900      	cmp	r1, #0
 80363e6:	d03d      	beq.n	8036464 <LoRaMacCryptoDeriveMcSessionKeyPair+0x84>
        if( KeyAddrList[i].AddrID == addrID )
 80363e8:	4c20      	ldr	r4, [pc, #128]	; (803646c <LoRaMacCryptoDeriveMcSessionKeyPair+0x8c>)
 80363ea:	7823      	ldrb	r3, [r4, #0]
 80363ec:	4283      	cmp	r3, r0
 80363ee:	d037      	beq.n	8036460 <LoRaMacCryptoDeriveMcSessionKeyPair+0x80>
 80363f0:	7923      	ldrb	r3, [r4, #4]
 80363f2:	4283      	cmp	r3, r0
 80363f4:	d138      	bne.n	8036468 <LoRaMacCryptoDeriveMcSessionKeyPair+0x88>
 80363f6:	2201      	movs	r2, #1
    }

    // McAppSKey = aes128_encrypt(McKey, 0x01 | McAddr | pad16)
    // McNwkSKey = aes128_encrypt(McKey, 0x02 | McAddr | pad16)

    uint8_t compBaseAppS[16] = { 0 };
 80363f8:	2300      	movs	r3, #0
 80363fa:	e9cd 3301 	strd	r3, r3, [sp, #4]
    uint8_t compBaseNwkS[16] = { 0 };
 80363fe:	e9cd 3305 	strd	r3, r3, [sp, #20]
    compBaseNwkS[1] = mcAddr & 0xFF;
    compBaseNwkS[2] = ( mcAddr >> 8 ) & 0xFF;
    compBaseNwkS[3] = ( mcAddr >> 16 ) & 0xFF;
    compBaseNwkS[4] = ( mcAddr >> 24 ) & 0xFF;

    if( SecureElementDeriveAndStoreKey( compBaseAppS, curItem->RootKey, curItem->AppSkey ) != SECURE_ELEMENT_SUCCESS )
 8036402:	eb04 0482 	add.w	r4, r4, r2, lsl #2
    uint8_t compBaseAppS[16] = { 0 };
 8036406:	9303      	str	r3, [sp, #12]
    uint8_t compBaseNwkS[16] = { 0 };
 8036408:	9307      	str	r3, [sp, #28]
    compBaseAppS[0] = 0x01;
 803640a:	2301      	movs	r3, #1
    compBaseAppS[2] = ( mcAddr >> 8 ) & 0xFF;
 803640c:	f3c1 2007 	ubfx	r0, r1, #8, #8
    compBaseAppS[1] = mcAddr & 0xFF;
 8036410:	b2cd      	uxtb	r5, r1
    compBaseAppS[0] = 0x01;
 8036412:	f88d 3000 	strb.w	r3, [sp]
    compBaseAppS[3] = ( mcAddr >> 16 ) & 0xFF;
 8036416:	f3c1 4307 	ubfx	r3, r1, #16, #8
    compBaseAppS[4] = ( mcAddr >> 24 ) & 0xFF;
 803641a:	0e09      	lsrs	r1, r1, #24
    compBaseAppS[2] = ( mcAddr >> 8 ) & 0xFF;
 803641c:	f88d 0002 	strb.w	r0, [sp, #2]
    compBaseAppS[4] = ( mcAddr >> 24 ) & 0xFF;
 8036420:	f88d 1004 	strb.w	r1, [sp, #4]
    compBaseNwkS[0] = 0x02;
 8036424:	2602      	movs	r6, #2
    compBaseNwkS[2] = ( mcAddr >> 8 ) & 0xFF;
 8036426:	f88d 0012 	strb.w	r0, [sp, #18]
    compBaseNwkS[4] = ( mcAddr >> 24 ) & 0xFF;
 803642a:	f88d 1014 	strb.w	r1, [sp, #20]
    if( SecureElementDeriveAndStoreKey( compBaseAppS, curItem->RootKey, curItem->AppSkey ) != SECURE_ELEMENT_SUCCESS )
 803642e:	7862      	ldrb	r2, [r4, #1]
 8036430:	78e1      	ldrb	r1, [r4, #3]
    compBaseAppS[1] = mcAddr & 0xFF;
 8036432:	f88d 5001 	strb.w	r5, [sp, #1]
    if( SecureElementDeriveAndStoreKey( compBaseAppS, curItem->RootKey, curItem->AppSkey ) != SECURE_ELEMENT_SUCCESS )
 8036436:	4668      	mov	r0, sp
    compBaseAppS[3] = ( mcAddr >> 16 ) & 0xFF;
 8036438:	f88d 3003 	strb.w	r3, [sp, #3]
    compBaseNwkS[0] = 0x02;
 803643c:	f88d 6010 	strb.w	r6, [sp, #16]
    compBaseNwkS[1] = mcAddr & 0xFF;
 8036440:	f88d 5011 	strb.w	r5, [sp, #17]
    compBaseNwkS[3] = ( mcAddr >> 16 ) & 0xFF;
 8036444:	f88d 3013 	strb.w	r3, [sp, #19]
    if( SecureElementDeriveAndStoreKey( compBaseAppS, curItem->RootKey, curItem->AppSkey ) != SECURE_ELEMENT_SUCCESS )
 8036448:	f002 fc7c 	bl	8038d44 <SecureElementDeriveAndStoreKey>
 803644c:	b928      	cbnz	r0, 803645a <LoRaMacCryptoDeriveMcSessionKeyPair+0x7a>
    {
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
    }

    if( SecureElementDeriveAndStoreKey( compBaseNwkS, curItem->RootKey, curItem->NwkSkey ) != SECURE_ELEMENT_SUCCESS )
 803644e:	78a2      	ldrb	r2, [r4, #2]
 8036450:	78e1      	ldrb	r1, [r4, #3]
 8036452:	a804      	add	r0, sp, #16
 8036454:	f002 fc76 	bl	8038d44 <SecureElementDeriveAndStoreKey>
 8036458:	b100      	cbz	r0, 803645c <LoRaMacCryptoDeriveMcSessionKeyPair+0x7c>
    {
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 803645a:	200f      	movs	r0, #15
    }

    return LORAMAC_CRYPTO_SUCCESS;
}
 803645c:	b008      	add	sp, #32
 803645e:	bd70      	pop	{r4, r5, r6, pc}
        if( KeyAddrList[i].AddrID == addrID )
 8036460:	2200      	movs	r2, #0
 8036462:	e7c9      	b.n	80363f8 <LoRaMacCryptoDeriveMcSessionKeyPair+0x18>
        return LORAMAC_CRYPTO_ERROR_NPE;
 8036464:	200a      	movs	r0, #10
 8036466:	e7f9      	b.n	803645c <LoRaMacCryptoDeriveMcSessionKeyPair+0x7c>
    return LORAMAC_CRYPTO_ERROR_INVALID_ADDR_ID;
 8036468:	200c      	movs	r0, #12
 803646a:	e7f7      	b.n	803645c <LoRaMacCryptoDeriveMcSessionKeyPair+0x7c>
 803646c:	20003594 	.word	0x20003594

08036470 <LoRaMacParserJoinAccept>:
 */
#include "LoRaMacParser.h"
#include "utilities.h"

LoRaMacParserStatus_t LoRaMacParserJoinAccept( LoRaMacMessageJoinAccept_t* macMsg )
{
 8036470:	b510      	push	{r4, lr}
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 8036472:	4604      	mov	r4, r0
 8036474:	2800      	cmp	r0, #0
 8036476:	d045      	beq.n	8036504 <LoRaMacParserJoinAccept+0x94>
 8036478:	6801      	ldr	r1, [r0, #0]
 803647a:	2900      	cmp	r1, #0
 803647c:	d042      	beq.n	8036504 <LoRaMacParserJoinAccept+0x94>
        return LORAMAC_PARSER_ERROR_NPE;
    }

    uint16_t bufItr = 0;

    macMsg->MHDR.Value = macMsg->Buffer[bufItr++];
 803647e:	f811 3b01 	ldrb.w	r3, [r1], #1
 8036482:	7143      	strb	r3, [r0, #5]

    memcpy1( macMsg->JoinNonce, &macMsg->Buffer[bufItr], 3 );
 8036484:	2203      	movs	r2, #3
 8036486:	3006      	adds	r0, #6
 8036488:	f002 fd50 	bl	8038f2c <memcpy1>
    bufItr = bufItr + 3;

    memcpy1( macMsg->NetID, &macMsg->Buffer[bufItr], 3 );
 803648c:	4620      	mov	r0, r4
 803648e:	2203      	movs	r2, #3
 8036490:	f850 1b09 	ldr.w	r1, [r0], #9
 8036494:	3104      	adds	r1, #4
 8036496:	f002 fd49 	bl	8038f2c <memcpy1>
    bufItr = bufItr + 3;

    macMsg->DevAddr = ( uint32_t ) macMsg->Buffer[bufItr++];
 803649a:	6821      	ldr	r1, [r4, #0]
 803649c:	79cb      	ldrb	r3, [r1, #7]
 803649e:	60e3      	str	r3, [r4, #12]
    macMsg->DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 80364a0:	7a0a      	ldrb	r2, [r1, #8]
 80364a2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80364a6:	60e3      	str	r3, [r4, #12]
    macMsg->DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 80364a8:	7a4a      	ldrb	r2, [r1, #9]
 80364aa:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80364ae:	60e3      	str	r3, [r4, #12]
    macMsg->DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 24 );
 80364b0:	7a8a      	ldrb	r2, [r1, #10]
 80364b2:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80364b6:	60e3      	str	r3, [r4, #12]

    macMsg->DLSettings.Value = macMsg->Buffer[bufItr++];
 80364b8:	7acb      	ldrb	r3, [r1, #11]
 80364ba:	7423      	strb	r3, [r4, #16]

    macMsg->RxDelay = macMsg->Buffer[bufItr++];
 80364bc:	7b0b      	ldrb	r3, [r1, #12]
 80364be:	7463      	strb	r3, [r4, #17]

    if( ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE - bufItr ) == LORAMAC_CF_LIST_FIELD_SIZE )
 80364c0:	7923      	ldrb	r3, [r4, #4]
 80364c2:	2b21      	cmp	r3, #33	; 0x21
 80364c4:	d11a      	bne.n	80364fc <LoRaMacParserJoinAccept+0x8c>
    {
        memcpy1( macMsg->CFList, &macMsg->Buffer[bufItr], LORAMAC_CF_LIST_FIELD_SIZE );
 80364c6:	2210      	movs	r2, #16
 80364c8:	310d      	adds	r1, #13
 80364ca:	f104 0012 	add.w	r0, r4, #18
 80364ce:	f002 fd2d 	bl	8038f2c <memcpy1>
        bufItr = bufItr + LORAMAC_CF_LIST_FIELD_SIZE;
 80364d2:	221d      	movs	r2, #29
    else if( ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE - bufItr ) > 0 )
    {
        return LORAMAC_PARSER_FAIL;
    }

    macMsg->MIC = ( uint32_t ) macMsg->Buffer[bufItr++];
 80364d4:	6821      	ldr	r1, [r4, #0]
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 80364d6:	1c50      	adds	r0, r2, #1
    macMsg->MIC = ( uint32_t ) macMsg->Buffer[bufItr++];
 80364d8:	5c8b      	ldrb	r3, [r1, r2]
 80364da:	6263      	str	r3, [r4, #36]	; 0x24
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 80364dc:	5c08      	ldrb	r0, [r1, r0]
 80364de:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 80364e2:	1c90      	adds	r0, r2, #2
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 80364e4:	6263      	str	r3, [r4, #36]	; 0x24
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 80364e6:	5c08      	ldrb	r0, [r1, r0]
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 24 );
 80364e8:	3203      	adds	r2, #3
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 80364ea:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
 80364ee:	6263      	str	r3, [r4, #36]	; 0x24
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 24 );
 80364f0:	5c8a      	ldrb	r2, [r1, r2]
 80364f2:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80364f6:	6263      	str	r3, [r4, #36]	; 0x24

    return LORAMAC_PARSER_SUCCESS;
 80364f8:	2000      	movs	r0, #0
}
 80364fa:	bd10      	pop	{r4, pc}
    else if( ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE - bufItr ) > 0 )
 80364fc:	2b11      	cmp	r3, #17
 80364fe:	dc03      	bgt.n	8036508 <LoRaMacParserJoinAccept+0x98>
    macMsg->RxDelay = macMsg->Buffer[bufItr++];
 8036500:	220d      	movs	r2, #13
 8036502:	e7e7      	b.n	80364d4 <LoRaMacParserJoinAccept+0x64>
        return LORAMAC_PARSER_ERROR_NPE;
 8036504:	2002      	movs	r0, #2
 8036506:	e7f8      	b.n	80364fa <LoRaMacParserJoinAccept+0x8a>
        return LORAMAC_PARSER_FAIL;
 8036508:	2001      	movs	r0, #1
 803650a:	e7f6      	b.n	80364fa <LoRaMacParserJoinAccept+0x8a>

0803650c <LoRaMacParserData>:

LoRaMacParserStatus_t LoRaMacParserData( LoRaMacMessageData_t* macMsg )
{
 803650c:	b510      	push	{r4, lr}
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 803650e:	4604      	mov	r4, r0
 8036510:	2800      	cmp	r0, #0
 8036512:	d054      	beq.n	80365be <LoRaMacParserData+0xb2>
 8036514:	6801      	ldr	r1, [r0, #0]
 8036516:	2900      	cmp	r1, #0
 8036518:	d051      	beq.n	80365be <LoRaMacParserData+0xb2>
        return LORAMAC_PARSER_ERROR_NPE;
    }

    uint16_t bufItr = 0;

    macMsg->MHDR.Value = macMsg->Buffer[bufItr++];
 803651a:	780b      	ldrb	r3, [r1, #0]
 803651c:	7143      	strb	r3, [r0, #5]

    macMsg->FHDR.DevAddr = macMsg->Buffer[bufItr++];
 803651e:	784b      	ldrb	r3, [r1, #1]
 8036520:	6083      	str	r3, [r0, #8]
    macMsg->FHDR.DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 8036522:	788a      	ldrb	r2, [r1, #2]
 8036524:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8036528:	6083      	str	r3, [r0, #8]
    macMsg->FHDR.DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 803652a:	78ca      	ldrb	r2, [r1, #3]
 803652c:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8036530:	6083      	str	r3, [r0, #8]
    macMsg->FHDR.DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 24 );
 8036532:	790a      	ldrb	r2, [r1, #4]
 8036534:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8036538:	6083      	str	r3, [r0, #8]

    macMsg->FHDR.FCtrl.Value = macMsg->Buffer[bufItr++];
 803653a:	794b      	ldrb	r3, [r1, #5]
 803653c:	7303      	strb	r3, [r0, #12]

    macMsg->FHDR.FCnt = macMsg->Buffer[bufItr++];
 803653e:	798b      	ldrb	r3, [r1, #6]
 8036540:	81c3      	strh	r3, [r0, #14]
    macMsg->FHDR.FCnt |= macMsg->Buffer[bufItr++] << 8;
 8036542:	79ca      	ldrb	r2, [r1, #7]
 8036544:	ea43 2302 	orr.w	r3, r3, r2, lsl #8

    if( macMsg->FHDR.FCtrl.Bits.FOptsLen <= 15 )
    {
        memcpy1( macMsg->FHDR.FOpts, &macMsg->Buffer[bufItr], macMsg->FHDR.FCtrl.Bits.FOptsLen );
 8036548:	7b02      	ldrb	r2, [r0, #12]
    macMsg->FHDR.FCnt |= macMsg->Buffer[bufItr++] << 8;
 803654a:	81c3      	strh	r3, [r0, #14]
        memcpy1( macMsg->FHDR.FOpts, &macMsg->Buffer[bufItr], macMsg->FHDR.FCtrl.Bits.FOptsLen );
 803654c:	f002 020f 	and.w	r2, r2, #15
 8036550:	3108      	adds	r1, #8
 8036552:	3010      	adds	r0, #16
 8036554:	f002 fcea 	bl	8038f2c <memcpy1>
        bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 8036558:	7b23      	ldrb	r3, [r4, #12]
    {
        return LORAMAC_PARSER_FAIL;
    }

    // Initialize anyway with zero.
    macMsg->FPort = 0;
 803655a:	2200      	movs	r2, #0
        bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 803655c:	f003 030f 	and.w	r3, r3, #15
    macMsg->FPort = 0;
 8036560:	f884 2020 	strb.w	r2, [r4, #32]
    macMsg->FRMPayloadSize = 0;
 8036564:	f884 2028 	strb.w	r2, [r4, #40]	; 0x28

    if( ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE ) > 0 )
 8036568:	7922      	ldrb	r2, [r4, #4]
        bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 803656a:	f103 0008 	add.w	r0, r3, #8
    if( ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE ) > 0 )
 803656e:	1a11      	subs	r1, r2, r0
 8036570:	2904      	cmp	r1, #4
 8036572:	dd0d      	ble.n	8036590 <LoRaMacParserData+0x84>
    {
        macMsg->FPort = macMsg->Buffer[bufItr++];
 8036574:	6821      	ldr	r1, [r4, #0]
 8036576:	3309      	adds	r3, #9

        macMsg->FRMPayloadSize = ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE );
 8036578:	3a04      	subs	r2, #4
 803657a:	1ad2      	subs	r2, r2, r3
        macMsg->FPort = macMsg->Buffer[bufItr++];
 803657c:	5c08      	ldrb	r0, [r1, r0]
 803657e:	f884 0020 	strb.w	r0, [r4, #32]
        macMsg->FRMPayloadSize = ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE );
 8036582:	b2d2      	uxtb	r2, r2
        memcpy1( macMsg->FRMPayload, &macMsg->Buffer[bufItr], macMsg->FRMPayloadSize );
 8036584:	6a60      	ldr	r0, [r4, #36]	; 0x24
        macMsg->FRMPayloadSize = ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE );
 8036586:	f884 2028 	strb.w	r2, [r4, #40]	; 0x28
        memcpy1( macMsg->FRMPayload, &macMsg->Buffer[bufItr], macMsg->FRMPayloadSize );
 803658a:	4419      	add	r1, r3
 803658c:	f002 fcce 	bl	8038f2c <memcpy1>
        bufItr = bufItr + macMsg->FRMPayloadSize;
    }

    macMsg->MIC = ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE )];
 8036590:	7923      	ldrb	r3, [r4, #4]
 8036592:	6822      	ldr	r2, [r4, #0]
 8036594:	441a      	add	r2, r3
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 1] << 8 );
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 2] << 16 );
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 3] << 24 );

    return LORAMAC_PARSER_SUCCESS;
 8036596:	2000      	movs	r0, #0
    macMsg->MIC = ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE )];
 8036598:	f812 3c04 	ldrb.w	r3, [r2, #-4]
 803659c:	62e3      	str	r3, [r4, #44]	; 0x2c
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 1] << 8 );
 803659e:	f812 1c03 	ldrb.w	r1, [r2, #-3]
 80365a2:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 80365a6:	62e3      	str	r3, [r4, #44]	; 0x2c
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 2] << 16 );
 80365a8:	f812 1c02 	ldrb.w	r1, [r2, #-2]
 80365ac:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 80365b0:	62e3      	str	r3, [r4, #44]	; 0x2c
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 3] << 24 );
 80365b2:	f812 2c01 	ldrb.w	r2, [r2, #-1]
 80365b6:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80365ba:	62e3      	str	r3, [r4, #44]	; 0x2c
}
 80365bc:	bd10      	pop	{r4, pc}
        return LORAMAC_PARSER_ERROR_NPE;
 80365be:	2002      	movs	r0, #2
 80365c0:	e7fc      	b.n	80365bc <LoRaMacParserData+0xb0>

080365c2 <LoRaMacSerializerJoinRequest>:
 */
#include "LoRaMacSerializer.h"
#include "utilities.h"

LoRaMacSerializerStatus_t LoRaMacSerializerJoinRequest( LoRaMacMessageJoinRequest_t* macMsg )
{
 80365c2:	b510      	push	{r4, lr}
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 80365c4:	4604      	mov	r4, r0
 80365c6:	b360      	cbz	r0, 8036622 <LoRaMacSerializerJoinRequest+0x60>
 80365c8:	6803      	ldr	r3, [r0, #0]
 80365ca:	b353      	cbz	r3, 8036622 <LoRaMacSerializerJoinRequest+0x60>
    }

    uint16_t bufItr = 0;

    // Check macMsg->BufSize
    if( macMsg->BufSize < LORAMAC_JOIN_REQ_MSG_SIZE )
 80365cc:	7902      	ldrb	r2, [r0, #4]
 80365ce:	2a16      	cmp	r2, #22
 80365d0:	d929      	bls.n	8036626 <LoRaMacSerializerJoinRequest+0x64>
    {
        return LORAMAC_SERIALIZER_ERROR_BUF_SIZE;
    }

    macMsg->Buffer[bufItr++] = macMsg->MHDR.Value;
 80365d2:	7942      	ldrb	r2, [r0, #5]
 80365d4:	701a      	strb	r2, [r3, #0]

    memcpyr( &macMsg->Buffer[bufItr], macMsg->JoinEUI, LORAMAC_JOIN_EUI_FIELD_SIZE );
 80365d6:	4601      	mov	r1, r0
 80365d8:	2208      	movs	r2, #8
 80365da:	f851 0b06 	ldr.w	r0, [r1], #6
 80365de:	3001      	adds	r0, #1
 80365e0:	f002 fcae 	bl	8038f40 <memcpyr>
    bufItr += LORAMAC_JOIN_EUI_FIELD_SIZE;

    memcpyr( &macMsg->Buffer[bufItr], macMsg->DevEUI, LORAMAC_DEV_EUI_FIELD_SIZE );
 80365e4:	4621      	mov	r1, r4
 80365e6:	2208      	movs	r2, #8
 80365e8:	f851 0b0e 	ldr.w	r0, [r1], #14
 80365ec:	3009      	adds	r0, #9
 80365ee:	f002 fca7 	bl	8038f40 <memcpyr>
    bufItr += LORAMAC_DEV_EUI_FIELD_SIZE;

    macMsg->Buffer[bufItr++] = macMsg->DevNonce & 0xFF;
 80365f2:	6823      	ldr	r3, [r4, #0]
 80365f4:	8ae2      	ldrh	r2, [r4, #22]
 80365f6:	745a      	strb	r2, [r3, #17]
    macMsg->Buffer[bufItr++] = ( macMsg->DevNonce >> 8 ) & 0xFF;
 80365f8:	8ae3      	ldrh	r3, [r4, #22]
 80365fa:	6822      	ldr	r2, [r4, #0]
 80365fc:	0a1b      	lsrs	r3, r3, #8
 80365fe:	7493      	strb	r3, [r2, #18]

    macMsg->Buffer[bufItr++] = macMsg->MIC & 0xFF;
 8036600:	6823      	ldr	r3, [r4, #0]
 8036602:	69a2      	ldr	r2, [r4, #24]
 8036604:	74da      	strb	r2, [r3, #19]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 8 ) & 0xFF;
 8036606:	69a3      	ldr	r3, [r4, #24]
 8036608:	6822      	ldr	r2, [r4, #0]
 803660a:	0a1b      	lsrs	r3, r3, #8
 803660c:	7513      	strb	r3, [r2, #20]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 16 ) & 0xFF;
 803660e:	6823      	ldr	r3, [r4, #0]
 8036610:	8b62      	ldrh	r2, [r4, #26]
 8036612:	755a      	strb	r2, [r3, #21]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 24 ) & 0xFF;
 8036614:	6823      	ldr	r3, [r4, #0]
 8036616:	7ee2      	ldrb	r2, [r4, #27]
 8036618:	759a      	strb	r2, [r3, #22]

    macMsg->BufSize = bufItr;
 803661a:	2317      	movs	r3, #23
 803661c:	7123      	strb	r3, [r4, #4]

    return LORAMAC_SERIALIZER_SUCCESS;
 803661e:	2000      	movs	r0, #0
}
 8036620:	bd10      	pop	{r4, pc}
        return LORAMAC_SERIALIZER_ERROR_NPE;
 8036622:	2001      	movs	r0, #1
 8036624:	e7fc      	b.n	8036620 <LoRaMacSerializerJoinRequest+0x5e>
        return LORAMAC_SERIALIZER_ERROR_BUF_SIZE;
 8036626:	2002      	movs	r0, #2
 8036628:	e7fa      	b.n	8036620 <LoRaMacSerializerJoinRequest+0x5e>

0803662a <LoRaMacSerializerData>:

    return LORAMAC_SERIALIZER_SUCCESS;
}

LoRaMacSerializerStatus_t LoRaMacSerializerData( LoRaMacMessageData_t* macMsg )
{
 803662a:	b538      	push	{r3, r4, r5, lr}
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 803662c:	4604      	mov	r4, r0
 803662e:	2800      	cmp	r0, #0
 8036630:	d063      	beq.n	80366fa <LoRaMacSerializerData+0xd0>
 8036632:	6801      	ldr	r1, [r0, #0]
 8036634:	2900      	cmp	r1, #0
 8036636:	d060      	beq.n	80366fa <LoRaMacSerializerData+0xd0>
    uint16_t computedBufSize =   LORAMAC_MHDR_FIELD_SIZE
                               + LORAMAC_FHDR_DEV_ADDR_FIELD_SIZE
                               + LORAMAC_FHDR_F_CTRL_FIELD_SIZE
                               + LORAMAC_FHDR_F_CNT_FIELD_SIZE;

    computedBufSize += macMsg->FHDR.FCtrl.Bits.FOptsLen;
 8036638:	7b03      	ldrb	r3, [r0, #12]

    if( macMsg->FRMPayloadSize > 0 )
 803663a:	f890 2028 	ldrb.w	r2, [r0, #40]	; 0x28
    computedBufSize += macMsg->FHDR.FCtrl.Bits.FOptsLen;
 803663e:	f003 030f 	and.w	r3, r3, #15
    if( macMsg->FRMPayloadSize > 0 )
 8036642:	2a00      	cmp	r2, #0
 8036644:	d157      	bne.n	80366f6 <LoRaMacSerializerData+0xcc>
    computedBufSize += macMsg->FHDR.FCtrl.Bits.FOptsLen;
 8036646:	3308      	adds	r3, #8
    }

    computedBufSize += macMsg->FRMPayloadSize;
    computedBufSize += LORAMAC_MIC_FIELD_SIZE;

    if( macMsg->BufSize < computedBufSize )
 8036648:	7920      	ldrb	r0, [r4, #4]
    computedBufSize += LORAMAC_MIC_FIELD_SIZE;
 803664a:	3204      	adds	r2, #4
    if( macMsg->BufSize < computedBufSize )
 803664c:	4413      	add	r3, r2
 803664e:	4298      	cmp	r0, r3
 8036650:	d355      	bcc.n	80366fe <LoRaMacSerializerData+0xd4>
    {
        return LORAMAC_SERIALIZER_ERROR_BUF_SIZE;
    }

    macMsg->Buffer[bufItr++] = macMsg->MHDR.Value;
 8036652:	7963      	ldrb	r3, [r4, #5]
 8036654:	700b      	strb	r3, [r1, #0]

    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr ) & 0xFF;
 8036656:	6823      	ldr	r3, [r4, #0]
 8036658:	68a2      	ldr	r2, [r4, #8]
 803665a:	705a      	strb	r2, [r3, #1]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr >> 8 ) & 0xFF;
 803665c:	68a3      	ldr	r3, [r4, #8]
 803665e:	6822      	ldr	r2, [r4, #0]
 8036660:	0a1b      	lsrs	r3, r3, #8
 8036662:	7093      	strb	r3, [r2, #2]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr >> 16 ) & 0xFF;
 8036664:	6823      	ldr	r3, [r4, #0]
 8036666:	8962      	ldrh	r2, [r4, #10]
 8036668:	70da      	strb	r2, [r3, #3]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr >> 24 ) & 0xFF;
 803666a:	6823      	ldr	r3, [r4, #0]
 803666c:	7ae2      	ldrb	r2, [r4, #11]
 803666e:	711a      	strb	r2, [r3, #4]

    macMsg->Buffer[bufItr++] = macMsg->FHDR.FCtrl.Value;
 8036670:	6823      	ldr	r3, [r4, #0]
 8036672:	7b22      	ldrb	r2, [r4, #12]
 8036674:	715a      	strb	r2, [r3, #5]

    macMsg->Buffer[bufItr++] = macMsg->FHDR.FCnt & 0xFF;
 8036676:	6823      	ldr	r3, [r4, #0]
 8036678:	89e2      	ldrh	r2, [r4, #14]
 803667a:	719a      	strb	r2, [r3, #6]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.FCnt >> 8 ) & 0xFF;
 803667c:	89e3      	ldrh	r3, [r4, #14]
 803667e:	6822      	ldr	r2, [r4, #0]
 8036680:	0a1b      	lsrs	r3, r3, #8

    memcpy1( &macMsg->Buffer[bufItr], macMsg->FHDR.FOpts, macMsg->FHDR.FCtrl.Bits.FOptsLen );
 8036682:	4621      	mov	r1, r4
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.FCnt >> 8 ) & 0xFF;
 8036684:	71d3      	strb	r3, [r2, #7]
    memcpy1( &macMsg->Buffer[bufItr], macMsg->FHDR.FOpts, macMsg->FHDR.FCtrl.Bits.FOptsLen );
 8036686:	7b22      	ldrb	r2, [r4, #12]
 8036688:	f851 0b10 	ldr.w	r0, [r1], #16
 803668c:	f002 020f 	and.w	r2, r2, #15
 8036690:	3008      	adds	r0, #8
 8036692:	f002 fc4b 	bl	8038f2c <memcpy1>
    bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 8036696:	7b23      	ldrb	r3, [r4, #12]

    if( macMsg->FRMPayloadSize > 0 )
 8036698:	f894 2028 	ldrb.w	r2, [r4, #40]	; 0x28
    bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 803669c:	f003 030f 	and.w	r3, r3, #15
 80366a0:	f103 0508 	add.w	r5, r3, #8
    if( macMsg->FRMPayloadSize > 0 )
 80366a4:	b12a      	cbz	r2, 80366b2 <LoRaMacSerializerData+0x88>
    {
        macMsg->Buffer[bufItr++] = macMsg->FPort;
 80366a6:	6822      	ldr	r2, [r4, #0]
 80366a8:	f894 1020 	ldrb.w	r1, [r4, #32]
 80366ac:	5551      	strb	r1, [r2, r5]
 80366ae:	f103 0509 	add.w	r5, r3, #9
    }

    memcpy1( &macMsg->Buffer[bufItr], macMsg->FRMPayload, macMsg->FRMPayloadSize );
 80366b2:	6820      	ldr	r0, [r4, #0]
 80366b4:	f894 2028 	ldrb.w	r2, [r4, #40]	; 0x28
 80366b8:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80366ba:	4428      	add	r0, r5
 80366bc:	f002 fc36 	bl	8038f2c <memcpy1>
    bufItr = bufItr + macMsg->FRMPayloadSize;
 80366c0:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28

    macMsg->Buffer[bufItr++] = macMsg->MIC & 0xFF;
 80366c4:	6822      	ldr	r2, [r4, #0]
 80366c6:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
    bufItr = bufItr + macMsg->FRMPayloadSize;
 80366c8:	442b      	add	r3, r5
    macMsg->Buffer[bufItr++] = macMsg->MIC & 0xFF;
 80366ca:	54d1      	strb	r1, [r2, r3]
 80366cc:	1c5a      	adds	r2, r3, #1
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 8 ) & 0xFF;
 80366ce:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 80366d0:	6820      	ldr	r0, [r4, #0]
 80366d2:	b292      	uxth	r2, r2
 80366d4:	0a09      	lsrs	r1, r1, #8
 80366d6:	5481      	strb	r1, [r0, r2]
 80366d8:	1c9a      	adds	r2, r3, #2
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 16 ) & 0xFF;
 80366da:	6821      	ldr	r1, [r4, #0]
 80366dc:	8de0      	ldrh	r0, [r4, #46]	; 0x2e
 80366de:	b292      	uxth	r2, r2
 80366e0:	5488      	strb	r0, [r1, r2]
 80366e2:	1cda      	adds	r2, r3, #3
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 24 ) & 0xFF;
 80366e4:	6821      	ldr	r1, [r4, #0]
 80366e6:	f894 002f 	ldrb.w	r0, [r4, #47]	; 0x2f
 80366ea:	b292      	uxth	r2, r2
 80366ec:	3304      	adds	r3, #4
 80366ee:	5488      	strb	r0, [r1, r2]

    macMsg->BufSize = bufItr;
 80366f0:	7123      	strb	r3, [r4, #4]

    return LORAMAC_SERIALIZER_SUCCESS;
 80366f2:	2000      	movs	r0, #0
}
 80366f4:	bd38      	pop	{r3, r4, r5, pc}
        computedBufSize += LORAMAC_F_PORT_FIELD_SIZE;
 80366f6:	3309      	adds	r3, #9
 80366f8:	e7a6      	b.n	8036648 <LoRaMacSerializerData+0x1e>
        return LORAMAC_SERIALIZER_ERROR_NPE;
 80366fa:	2001      	movs	r0, #1
 80366fc:	e7fa      	b.n	80366f4 <LoRaMacSerializerData+0xca>
        return LORAMAC_SERIALIZER_ERROR_BUF_SIZE;
 80366fe:	2002      	movs	r0, #2
 8036700:	e7f8      	b.n	80366f4 <LoRaMacSerializerData+0xca>

08036702 <NvmDataMgmtEvent>:
void NvmDataMgmtEvent( uint16_t notifyFlags )
{
#if( CONTEXT_MANAGEMENT_ENABLED == 1 )
    NvmNotifyFlags = notifyFlags;
#endif /* CONTEXT_MANAGEMENT_ENABLED == 1 */
}
 8036702:	4770      	bx	lr

08036704 <NvmDataMgmtStore>:
    LoRaMacStart( );
    return dataSize;
#else
    return 0;
#endif
}
 8036704:	2000      	movs	r0, #0
 8036706:	4770      	bx	lr

08036708 <NvmDataMgmtRestore>:
 8036708:	2000      	movs	r0, #0
 803670a:	4770      	bx	lr

0803670c <RegionIsActive>:
#define RU864_RX_BEACON_SETUP( )
#endif

bool RegionIsActive( LoRaMacRegion_t region )
{
    switch( region )
 803670c:	2805      	cmp	r0, #5
 803670e:	d004      	beq.n	803671a <RegionIsActive+0xe>
 8036710:	f1a0 0308 	sub.w	r3, r0, #8
 8036714:	4258      	negs	r0, r3
 8036716:	4158      	adcs	r0, r3
 8036718:	4770      	bx	lr
        AS923_IS_ACTIVE( );
        AU915_IS_ACTIVE( );
        CN470_IS_ACTIVE( );
        CN779_IS_ACTIVE( );
        EU433_IS_ACTIVE( );
        EU868_IS_ACTIVE( );
 803671a:	2001      	movs	r0, #1
        default:
        {
            return false;
        }
    }
}
 803671c:	4770      	bx	lr

0803671e <RegionGetPhyParam>:

PhyParam_t RegionGetPhyParam( LoRaMacRegion_t region, GetPhyParams_t* getPhy )
{
 803671e:	4603      	mov	r3, r0
    PhyParam_t phyParam = { 0 };
    switch( region )
 8036720:	2b05      	cmp	r3, #5
{
 8036722:	b082      	sub	sp, #8
 8036724:	4608      	mov	r0, r1
    switch( region )
 8036726:	d004      	beq.n	8036732 <RegionGetPhyParam+0x14>
 8036728:	2b08      	cmp	r3, #8
 803672a:	d005      	beq.n	8036738 <RegionGetPhyParam+0x1a>
        default:
        {
            return phyParam;
        }
    }
}
 803672c:	2000      	movs	r0, #0
 803672e:	b002      	add	sp, #8
 8036730:	4770      	bx	lr
 8036732:	b002      	add	sp, #8
        EU868_GET_PHY_PARAM( );
 8036734:	f000 bcf4 	b.w	8037120 <RegionEU868GetPhyParam>
}
 8036738:	b002      	add	sp, #8
        US915_GET_PHY_PARAM( );
 803673a:	f001 ba35 	b.w	8037ba8 <RegionUS915GetPhyParam>

0803673e <RegionSetBandTxDone>:

void RegionSetBandTxDone( LoRaMacRegion_t region, SetBandTxDoneParams_t* txDone )
{
 803673e:	4603      	mov	r3, r0
    switch( region )
 8036740:	2b05      	cmp	r3, #5
{
 8036742:	4608      	mov	r0, r1
    switch( region )
 8036744:	d002      	beq.n	803674c <RegionSetBandTxDone+0xe>
 8036746:	2b08      	cmp	r3, #8
 8036748:	d002      	beq.n	8036750 <RegionSetBandTxDone+0x12>
 803674a:	4770      	bx	lr
        AS923_SET_BAND_TX_DONE( );
        AU915_SET_BAND_TX_DONE( );
        CN470_SET_BAND_TX_DONE( );
        CN779_SET_BAND_TX_DONE( );
        EU433_SET_BAND_TX_DONE( );
        EU868_SET_BAND_TX_DONE( );
 803674c:	f000 bd88 	b.w	8037260 <RegionEU868SetBandTxDone>
        KR920_SET_BAND_TX_DONE( );
        IN865_SET_BAND_TX_DONE( );
        US915_SET_BAND_TX_DONE( );
 8036750:	f001 bad4 	b.w	8037cfc <RegionUS915SetBandTxDone>

08036754 <RegionInitDefaults>:
        }
    }
}

void RegionInitDefaults( LoRaMacRegion_t region, InitDefaultsParams_t* params )
{
 8036754:	4603      	mov	r3, r0
    switch( region )
 8036756:	2b05      	cmp	r3, #5
{
 8036758:	4608      	mov	r0, r1
    switch( region )
 803675a:	d002      	beq.n	8036762 <RegionInitDefaults+0xe>
 803675c:	2b08      	cmp	r3, #8
 803675e:	d002      	beq.n	8036766 <RegionInitDefaults+0x12>
 8036760:	4770      	bx	lr
        AS923_INIT_DEFAULTS( );
        AU915_INIT_DEFAULTS( );
        CN470_INIT_DEFAULTS( );
        CN779_INIT_DEFAULTS( );
        EU433_INIT_DEFAULTS( );
        EU868_INIT_DEFAULTS( );
 8036762:	f000 bd95 	b.w	8037290 <RegionEU868InitDefaults>
        KR920_INIT_DEFAULTS( );
        IN865_INIT_DEFAULTS( );
        US915_INIT_DEFAULTS( );
 8036766:	f001 bae1 	b.w	8037d2c <RegionUS915InitDefaults>

0803676a <RegionVerify>:
        }
    }
}

bool RegionVerify( LoRaMacRegion_t region, VerifyParams_t* verify, PhyAttribute_t phyAttribute )
{
 803676a:	4603      	mov	r3, r0
    switch( region )
 803676c:	2b05      	cmp	r3, #5
{
 803676e:	4608      	mov	r0, r1
 8036770:	4611      	mov	r1, r2
    switch( region )
 8036772:	d003      	beq.n	803677c <RegionVerify+0x12>
 8036774:	2b08      	cmp	r3, #8
 8036776:	d003      	beq.n	8036780 <RegionVerify+0x16>
        default:
        {
            return false;
        }
    }
}
 8036778:	2000      	movs	r0, #0
 803677a:	4770      	bx	lr
        EU868_VERIFY( );
 803677c:	f000 bdea 	b.w	8037354 <RegionEU868Verify>
        US915_VERIFY( );
 8036780:	f001 bb56 	b.w	8037e30 <RegionUS915Verify>

08036784 <RegionApplyCFList>:

void RegionApplyCFList( LoRaMacRegion_t region, ApplyCFListParams_t* applyCFList )
{
 8036784:	4603      	mov	r3, r0
    switch( region )
 8036786:	2b05      	cmp	r3, #5
{
 8036788:	4608      	mov	r0, r1
    switch( region )
 803678a:	d002      	beq.n	8036792 <RegionApplyCFList+0xe>
 803678c:	2b08      	cmp	r3, #8
 803678e:	d002      	beq.n	8036796 <RegionApplyCFList+0x12>
 8036790:	4770      	bx	lr
        AS923_APPLY_CF_LIST( );
        AU915_APPLY_CF_LIST( );
        CN470_APPLY_CF_LIST( );
        CN779_APPLY_CF_LIST( );
        EU433_APPLY_CF_LIST( );
        EU868_APPLY_CF_LIST( );
 8036792:	f001 b93f 	b.w	8037a14 <RegionEU868ApplyCFList>
        KR920_APPLY_CF_LIST( );
        IN865_APPLY_CF_LIST( );
        US915_APPLY_CF_LIST( );
 8036796:	f001 bb6d 	b.w	8037e74 <RegionUS915ApplyCFList>

0803679a <RegionChanMaskSet>:
        }
    }
}

bool RegionChanMaskSet( LoRaMacRegion_t region, ChanMaskSetParams_t* chanMaskSet )
{
 803679a:	4603      	mov	r3, r0
    switch( region )
 803679c:	2b05      	cmp	r3, #5
{
 803679e:	4608      	mov	r0, r1
    switch( region )
 80367a0:	d003      	beq.n	80367aa <RegionChanMaskSet+0x10>
 80367a2:	2b08      	cmp	r3, #8
 80367a4:	d003      	beq.n	80367ae <RegionChanMaskSet+0x14>
        default:
        {
            return false;
        }
    }
}
 80367a6:	2000      	movs	r0, #0
 80367a8:	4770      	bx	lr
        EU868_CHAN_MASK_SET( );
 80367aa:	f000 bdfb 	b.w	80373a4 <RegionEU868ChanMaskSet>
        US915_CHAN_MASK_SET( );
 80367ae:	f001 bb8b 	b.w	8037ec8 <RegionUS915ChanMaskSet>

080367b2 <RegionComputeRxWindowParameters>:

void RegionComputeRxWindowParameters( LoRaMacRegion_t region, int8_t datarate, uint8_t minRxSymbols, uint32_t rxError, RxConfigParams_t *rxConfigParams )
{
 80367b2:	b410      	push	{r4}
 80367b4:	4604      	mov	r4, r0
    switch( region )
 80367b6:	2c05      	cmp	r4, #5
{
 80367b8:	4608      	mov	r0, r1
 80367ba:	4611      	mov	r1, r2
 80367bc:	461a      	mov	r2, r3
 80367be:	9b01      	ldr	r3, [sp, #4]
    switch( region )
 80367c0:	d003      	beq.n	80367ca <RegionComputeRxWindowParameters+0x18>
 80367c2:	2c08      	cmp	r4, #8
 80367c4:	d004      	beq.n	80367d0 <RegionComputeRxWindowParameters+0x1e>
        default:
        {
            break;
        }
    }
}
 80367c6:	bc10      	pop	{r4}
 80367c8:	4770      	bx	lr
 80367ca:	bc10      	pop	{r4}
        EU868_COMPUTE_RX_WINDOW_PARAMETERS( );
 80367cc:	f000 be08 	b.w	80373e0 <RegionEU868ComputeRxWindowParameters>
}
 80367d0:	bc10      	pop	{r4}
        US915_COMPUTE_RX_WINDOW_PARAMETERS( );
 80367d2:	f001 bbb3 	b.w	8037f3c <RegionUS915ComputeRxWindowParameters>

080367d6 <RegionRxConfig>:

bool RegionRxConfig( LoRaMacRegion_t region, RxConfigParams_t* rxConfig, int8_t* datarate )
{
 80367d6:	4603      	mov	r3, r0
    switch( region )
 80367d8:	2b05      	cmp	r3, #5
{
 80367da:	4608      	mov	r0, r1
 80367dc:	4611      	mov	r1, r2
    switch( region )
 80367de:	d003      	beq.n	80367e8 <RegionRxConfig+0x12>
 80367e0:	2b08      	cmp	r3, #8
 80367e2:	d003      	beq.n	80367ec <RegionRxConfig+0x16>
        default:
        {
            return false;
        }
    }
}
 80367e4:	2000      	movs	r0, #0
 80367e6:	4770      	bx	lr
        EU868_RX_CONFIG( );
 80367e8:	f000 be2c 	b.w	8037444 <RegionEU868RxConfig>
        US915_RX_CONFIG( );
 80367ec:	f001 bbd2 	b.w	8037f94 <RegionUS915RxConfig>

080367f0 <RegionTxConfig>:

bool RegionTxConfig( LoRaMacRegion_t region, TxConfigParams_t* txConfig, int8_t* txPower, TimerTime_t* txTimeOnAir )
{
 80367f0:	b410      	push	{r4}
 80367f2:	4604      	mov	r4, r0
    switch( region )
 80367f4:	2c05      	cmp	r4, #5
{
 80367f6:	4608      	mov	r0, r1
 80367f8:	4611      	mov	r1, r2
 80367fa:	461a      	mov	r2, r3
    switch( region )
 80367fc:	d004      	beq.n	8036808 <RegionTxConfig+0x18>
 80367fe:	2c08      	cmp	r4, #8
 8036800:	d005      	beq.n	803680e <RegionTxConfig+0x1e>
        default:
        {
            return false;
        }
    }
}
 8036802:	2000      	movs	r0, #0
 8036804:	bc10      	pop	{r4}
 8036806:	4770      	bx	lr
 8036808:	bc10      	pop	{r4}
        EU868_TX_CONFIG( );
 803680a:	f000 be99 	b.w	8037540 <RegionEU868TxConfig>
}
 803680e:	bc10      	pop	{r4}
        US915_TX_CONFIG( );
 8036810:	f001 bc14 	b.w	803803c <RegionUS915TxConfig>

08036814 <RegionLinkAdrReq>:

uint8_t RegionLinkAdrReq( LoRaMacRegion_t region, LinkAdrReqParams_t* linkAdrReq, int8_t* drOut, int8_t* txPowOut, uint8_t* nbRepOut, uint8_t* nbBytesParsed )
{
 8036814:	b430      	push	{r4, r5}
 8036816:	4604      	mov	r4, r0
    switch( region )
 8036818:	2c05      	cmp	r4, #5
{
 803681a:	4608      	mov	r0, r1
 803681c:	4611      	mov	r1, r2
 803681e:	461a      	mov	r2, r3
 8036820:	e9dd 3502 	ldrd	r3, r5, [sp, #8]
    switch( region )
 8036824:	d004      	beq.n	8036830 <RegionLinkAdrReq+0x1c>
 8036826:	2c08      	cmp	r4, #8
 8036828:	d006      	beq.n	8036838 <RegionLinkAdrReq+0x24>
        default:
        {
            return 0;
        }
    }
}
 803682a:	2000      	movs	r0, #0
 803682c:	bc30      	pop	{r4, r5}
 803682e:	4770      	bx	lr
        EU868_LINK_ADR_REQ( );
 8036830:	9502      	str	r5, [sp, #8]
}
 8036832:	bc30      	pop	{r4, r5}
        EU868_LINK_ADR_REQ( );
 8036834:	f000 bf08 	b.w	8037648 <RegionEU868LinkAdrReq>
        US915_LINK_ADR_REQ( );
 8036838:	9502      	str	r5, [sp, #8]
}
 803683a:	bc30      	pop	{r4, r5}
        US915_LINK_ADR_REQ( );
 803683c:	f001 bc86 	b.w	803814c <RegionUS915LinkAdrReq>

08036840 <RegionRxParamSetupReq>:

uint8_t RegionRxParamSetupReq( LoRaMacRegion_t region, RxParamSetupReqParams_t* rxParamSetupReq )
{
 8036840:	4603      	mov	r3, r0
    switch( region )
 8036842:	2b05      	cmp	r3, #5
{
 8036844:	4608      	mov	r0, r1
    switch( region )
 8036846:	d003      	beq.n	8036850 <RegionRxParamSetupReq+0x10>
 8036848:	2b08      	cmp	r3, #8
 803684a:	d003      	beq.n	8036854 <RegionRxParamSetupReq+0x14>
        default:
        {
            return 0;
        }
    }
}
 803684c:	2000      	movs	r0, #0
 803684e:	4770      	bx	lr
        EU868_RX_PARAM_SETUP_REQ( );
 8036850:	f000 bfa8 	b.w	80377a4 <RegionEU868RxParamSetupReq>
        US915_RX_PARAM_SETUP_REQ( );
 8036854:	f001 bd90 	b.w	8038378 <RegionUS915RxParamSetupReq>

08036858 <RegionNewChannelReq>:

int8_t RegionNewChannelReq( LoRaMacRegion_t region, NewChannelReqParams_t* newChannelReq )
{
 8036858:	4603      	mov	r3, r0
    switch( region )
 803685a:	2b05      	cmp	r3, #5
{
 803685c:	4608      	mov	r0, r1
    switch( region )
 803685e:	d003      	beq.n	8036868 <RegionNewChannelReq+0x10>
 8036860:	2b08      	cmp	r3, #8
 8036862:	d003      	beq.n	803686c <RegionNewChannelReq+0x14>
        default:
        {
            return 0;
        }
    }
}
 8036864:	2000      	movs	r0, #0
 8036866:	4770      	bx	lr
        EU868_NEW_CHANNEL_REQ( );
 8036868:	f001 b912 	b.w	8037a90 <RegionEU868NewChannelReq>
        US915_NEW_CHANNEL_REQ( );
 803686c:	f001 bdb0 	b.w	80383d0 <RegionUS915NewChannelReq>

08036870 <RegionTxParamSetupReq>:

int8_t RegionTxParamSetupReq( LoRaMacRegion_t region, TxParamSetupReqParams_t* txParamSetupReq )
{
 8036870:	4603      	mov	r3, r0
    switch( region )
 8036872:	2b05      	cmp	r3, #5
{
 8036874:	4608      	mov	r0, r1
    switch( region )
 8036876:	d003      	beq.n	8036880 <RegionTxParamSetupReq+0x10>
 8036878:	2b08      	cmp	r3, #8
 803687a:	d003      	beq.n	8036884 <RegionTxParamSetupReq+0x14>
        default:
        {
            return 0;
        }
    }
}
 803687c:	2000      	movs	r0, #0
 803687e:	4770      	bx	lr
        EU868_TX_PARAM_SETUP_REQ( );
 8036880:	f000 bfb3 	b.w	80377ea <RegionEU868TxParamSetupReq>
        US915_TX_PARAM_SETUP_REQ( );
 8036884:	f001 bda7 	b.w	80383d6 <RegionUS915TxParamSetupReq>

08036888 <RegionDlChannelReq>:

int8_t RegionDlChannelReq( LoRaMacRegion_t region, DlChannelReqParams_t* dlChannelReq )
{
 8036888:	4603      	mov	r3, r0
    switch( region )
 803688a:	2b05      	cmp	r3, #5
{
 803688c:	4608      	mov	r0, r1
    switch( region )
 803688e:	d003      	beq.n	8036898 <RegionDlChannelReq+0x10>
 8036890:	2b08      	cmp	r3, #8
 8036892:	d003      	beq.n	803689c <RegionDlChannelReq+0x14>
        default:
        {
            return 0;
        }
    }
}
 8036894:	2000      	movs	r0, #0
 8036896:	4770      	bx	lr
        EU868_DL_CHANNEL_REQ( );
 8036898:	f000 bfaa 	b.w	80377f0 <RegionEU868DlChannelReq>
        US915_DL_CHANNEL_REQ( );
 803689c:	f001 bd9e 	b.w	80383dc <RegionUS915DlChannelReq>

080368a0 <RegionAlternateDr>:

int8_t RegionAlternateDr( LoRaMacRegion_t region, int8_t currentDr, AlternateDrType_t type )
{
 80368a0:	4603      	mov	r3, r0
    switch( region )
 80368a2:	2b05      	cmp	r3, #5
{
 80368a4:	4608      	mov	r0, r1
 80368a6:	4611      	mov	r1, r2
    switch( region )
 80368a8:	d003      	beq.n	80368b2 <RegionAlternateDr+0x12>
 80368aa:	2b08      	cmp	r3, #8
 80368ac:	d003      	beq.n	80368b6 <RegionAlternateDr+0x16>
        default:
        {
            return 0;
        }
    }
}
 80368ae:	2000      	movs	r0, #0
 80368b0:	4770      	bx	lr
        EU868_ALTERNATE_DR( );
 80368b2:	f000 bfc1 	b.w	8037838 <RegionEU868AlternateDr>
        US915_ALTERNATE_DR( );
 80368b6:	f001 bd95 	b.w	80383e4 <RegionUS915AlternateDr>

080368ba <RegionNextChannel>:

LoRaMacStatus_t RegionNextChannel( LoRaMacRegion_t region, NextChanParams_t* nextChanParams, uint8_t* channel, TimerTime_t* time, TimerTime_t* aggregatedTimeOff )
{
 80368ba:	b410      	push	{r4}
 80368bc:	4604      	mov	r4, r0
    switch( region )
 80368be:	2c05      	cmp	r4, #5
{
 80368c0:	4608      	mov	r0, r1
 80368c2:	4611      	mov	r1, r2
 80368c4:	461a      	mov	r2, r3
 80368c6:	9b01      	ldr	r3, [sp, #4]
    switch( region )
 80368c8:	d004      	beq.n	80368d4 <RegionNextChannel+0x1a>
 80368ca:	2c08      	cmp	r4, #8
 80368cc:	d005      	beq.n	80368da <RegionNextChannel+0x20>
        default:
        {
            return LORAMAC_STATUS_REGION_NOT_SUPPORTED;
        }
    }
}
 80368ce:	2009      	movs	r0, #9
 80368d0:	bc10      	pop	{r4}
 80368d2:	4770      	bx	lr
 80368d4:	bc10      	pop	{r4}
        EU868_NEXT_CHANNEL( );
 80368d6:	f000 bfb1 	b.w	803783c <RegionEU868NextChannel>
}
 80368da:	bc10      	pop	{r4}
        US915_NEXT_CHANNEL( );
 80368dc:	f001 bd9a 	b.w	8038414 <RegionUS915NextChannel>

080368e0 <RegionSetContinuousWave>:
        }
    }
}

void RegionSetContinuousWave( LoRaMacRegion_t region, ContinuousWaveParams_t* continuousWave )
{
 80368e0:	4603      	mov	r3, r0
    switch( region )
 80368e2:	2b05      	cmp	r3, #5
{
 80368e4:	4608      	mov	r0, r1
    switch( region )
 80368e6:	d002      	beq.n	80368ee <RegionSetContinuousWave+0xe>
 80368e8:	2b08      	cmp	r3, #8
 80368ea:	d002      	beq.n	80368f2 <RegionSetContinuousWave+0x12>
 80368ec:	4770      	bx	lr
        AS923_SET_CONTINUOUS_WAVE( );
        AU915_SET_CONTINUOUS_WAVE( );
        CN470_SET_CONTINUOUS_WAVE( );
        CN779_SET_CONTINUOUS_WAVE( );
        EU433_SET_CONTINUOUS_WAVE( );
        EU868_SET_CONTINUOUS_WAVE( );
 80368ee:	f001 b8f1 	b.w	8037ad4 <RegionEU868SetContinuousWave>
        KR920_SET_CONTINUOUS_WAVE( );
        IN865_SET_CONTINUOUS_WAVE( );
        US915_SET_CONTINUOUS_WAVE( );
 80368f2:	f001 be2b 	b.w	803854c <RegionUS915SetContinuousWave>

080368f6 <RegionApplyDrOffset>:
        }
    }
}

uint8_t RegionApplyDrOffset( LoRaMacRegion_t region, uint8_t downlinkDwellTime, int8_t dr, int8_t drOffset )
{
 80368f6:	b410      	push	{r4}
 80368f8:	4604      	mov	r4, r0
    switch( region )
 80368fa:	2c05      	cmp	r4, #5
{
 80368fc:	4608      	mov	r0, r1
 80368fe:	4611      	mov	r1, r2
 8036900:	461a      	mov	r2, r3
    switch( region )
 8036902:	d004      	beq.n	803690e <RegionApplyDrOffset+0x18>
 8036904:	2c08      	cmp	r4, #8
 8036906:	d005      	beq.n	8036914 <RegionApplyDrOffset+0x1e>
        default:
        {
            return dr;
        }
    }
}
 8036908:	b2c8      	uxtb	r0, r1
 803690a:	bc10      	pop	{r4}
 803690c:	4770      	bx	lr
 803690e:	bc10      	pop	{r4}
        EU868_APPLY_DR_OFFSET( );
 8036910:	f001 b908 	b.w	8037b24 <RegionEU868ApplyDrOffset>
}
 8036914:	bc10      	pop	{r4}
        US915_APPLY_DR_OFFSET( );
 8036916:	f001 be61 	b.w	80385dc <RegionUS915ApplyDrOffset>
	...

0803691c <RegionGetVersion>:
    Version_t version;

    version.Value = REGION_VERSION;

    return version;
}
 803691c:	4800      	ldr	r0, [pc, #0]	; (8036920 <RegionGetVersion+0x4>)
 803691e:	4770      	bx	lr
 8036920:	01000300 	.word	0x01000300

08036924 <RegionBaseUSComputeNext125kHzJoinChannel>:
    return LORAMAC_STATUS_OK;
}

LoRaMacStatus_t RegionBaseUSComputeNext125kHzJoinChannel( uint16_t* channelsMaskRemaining,
                                                          uint8_t* groupsCurrentIndex, uint8_t* newChannelIndex )
{
 8036924:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    uint8_t currentChannelMaskLeftIndex;
    uint16_t currentChannelMaskLeft;
    uint8_t findAvailableChannelsIndex[8] = { 0 };
 8036928:	2300      	movs	r3, #0
 803692a:	e9cd 3300 	strd	r3, r3, [sp]
{
 803692e:	460e      	mov	r6, r1
 8036930:	4690      	mov	r8, r2
    uint8_t availableChannels = 0;
    uint8_t startIndex;

    // Null pointer check
    if( channelsMaskRemaining == NULL || groupsCurrentIndex == NULL || newChannelIndex == NULL )
 8036932:	4607      	mov	r7, r0
 8036934:	b918      	cbnz	r0, 803693e <RegionBaseUSComputeNext125kHzJoinChannel+0x1a>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
 8036936:	2003      	movs	r0, #3
        *groupsCurrentIndex = startIndex;
        return LORAMAC_STATUS_OK;
    }

    return LORAMAC_STATUS_PARAMETER_INVALID;
}
 8036938:	b002      	add	sp, #8
 803693a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if( channelsMaskRemaining == NULL || groupsCurrentIndex == NULL || newChannelIndex == NULL )
 803693e:	2900      	cmp	r1, #0
 8036940:	d0f9      	beq.n	8036936 <RegionBaseUSComputeNext125kHzJoinChannel+0x12>
 8036942:	2a00      	cmp	r2, #0
 8036944:	d0f7      	beq.n	8036936 <RegionBaseUSComputeNext125kHzJoinChannel+0x12>
    startIndex = *groupsCurrentIndex;
 8036946:	780c      	ldrb	r4, [r1, #0]
        if( ( startIndex % 2 ) == 0 )
 8036948:	0863      	lsrs	r3, r4, #1
 803694a:	07e0      	lsls	r0, r4, #31
            currentChannelMaskLeft = ( channelsMaskRemaining[currentChannelMaskLeftIndex] & 0x00FF );
 803694c:	f837 1013 	ldrh.w	r1, [r7, r3, lsl #1]
{
 8036950:	f04f 0300 	mov.w	r3, #0
            currentChannelMaskLeft = ( channelsMaskRemaining[currentChannelMaskLeftIndex] & 0x00FF );
 8036954:	bf54      	ite	pl
 8036956:	b2c9      	uxtbpl	r1, r1
            currentChannelMaskLeft = ( ( channelsMaskRemaining[currentChannelMaskLeftIndex] >> 8 ) & 0x00FF );
 8036958:	0a09      	lsrmi	r1, r1, #8
    *availableChannels = 0;
 803695a:	461d      	mov	r5, r3
        if( ( currentChannelMaskLeft & ( 1 << i ) ) != 0 )
 803695c:	fa41 f203 	asr.w	r2, r1, r3
 8036960:	07d2      	lsls	r2, r2, #31
 8036962:	b2d8      	uxtb	r0, r3
 8036964:	d505      	bpl.n	8036972 <RegionBaseUSComputeNext125kHzJoinChannel+0x4e>
            findAvailableChannelsIndex[*availableChannels] = i;
 8036966:	aa02      	add	r2, sp, #8
 8036968:	442a      	add	r2, r5
            ( *availableChannels )++;
 803696a:	3501      	adds	r5, #1
            findAvailableChannelsIndex[*availableChannels] = i;
 803696c:	f802 0c08 	strb.w	r0, [r2, #-8]
            ( *availableChannels )++;
 8036970:	b2ed      	uxtb	r5, r5
    for( uint8_t i = 0; i < 8; i++ )
 8036972:	3301      	adds	r3, #1
 8036974:	2b08      	cmp	r3, #8
 8036976:	d1f1      	bne.n	803695c <RegionBaseUSComputeNext125kHzJoinChannel+0x38>
        if ( availableChannels > 0 )
 8036978:	b15d      	cbz	r5, 8036992 <RegionBaseUSComputeNext125kHzJoinChannel+0x6e>
            *newChannelIndex = ( startIndex * 8 ) + findAvailableChannelsIndex[randr( 0, ( availableChannels - 1 ) )];
 803697a:	1e69      	subs	r1, r5, #1
 803697c:	2000      	movs	r0, #0
 803697e:	f002 fab9 	bl	8038ef4 <randr>
 8036982:	ab02      	add	r3, sp, #8
 8036984:	4418      	add	r0, r3
 8036986:	f810 3c08 	ldrb.w	r3, [r0, #-8]
 803698a:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 803698e:	f888 3000 	strb.w	r3, [r8]
        startIndex++;
 8036992:	3401      	adds	r4, #1
 8036994:	b2e4      	uxtb	r4, r4
            startIndex = 0;
 8036996:	2c08      	cmp	r4, #8
 8036998:	bf28      	it	cs
 803699a:	2400      	movcs	r4, #0
    } while( ( availableChannels == 0 ) && ( startIndex != *groupsCurrentIndex ) );
 803699c:	b91d      	cbnz	r5, 80369a6 <RegionBaseUSComputeNext125kHzJoinChannel+0x82>
 803699e:	7833      	ldrb	r3, [r6, #0]
 80369a0:	42a3      	cmp	r3, r4
 80369a2:	d1d1      	bne.n	8036948 <RegionBaseUSComputeNext125kHzJoinChannel+0x24>
 80369a4:	e7c7      	b.n	8036936 <RegionBaseUSComputeNext125kHzJoinChannel+0x12>
        *groupsCurrentIndex = startIndex;
 80369a6:	7034      	strb	r4, [r6, #0]
        return LORAMAC_STATUS_OK;
 80369a8:	2000      	movs	r0, #0
 80369aa:	e7c5      	b.n	8036938 <RegionBaseUSComputeNext125kHzJoinChannel+0x14>

080369ac <RegionBaseUSCalcDownlinkFrequency>:
uint32_t RegionBaseUSCalcDownlinkFrequency( uint8_t channel, uint32_t frequency,
                                            uint32_t stepwidth )
{
    // Calculate the frequency
    return frequency + ( channel * stepwidth );
}
 80369ac:	fb02 1000 	mla	r0, r2, r0, r1
 80369b0:	4770      	bx	lr

080369b2 <RegionCommonChanVerifyDr>:
    }
    return nbActiveBits;
}

bool RegionCommonChanVerifyDr( uint8_t nbChannels, uint16_t* channelsMask, int8_t dr, int8_t minDr, int8_t maxDr, ChannelParams_t* channels )
{
 80369b2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    return false;
}

uint8_t RegionCommonValueInRange( int8_t value, int8_t min, int8_t max )
{
    if( ( value >= min ) && ( value <= max ) )
 80369b6:	429a      	cmp	r2, r3
{
 80369b8:	9f07      	ldr	r7, [sp, #28]
    if( ( value >= min ) && ( value <= max ) )
 80369ba:	db03      	blt.n	80369c4 <RegionCommonChanVerifyDr+0x12>
 80369bc:	f99d 3018 	ldrsb.w	r3, [sp, #24]
 80369c0:	429a      	cmp	r2, r3
 80369c2:	dd24      	ble.n	8036a0e <RegionCommonChanVerifyDr+0x5c>
        return false;
 80369c4:	2000      	movs	r0, #0
}
 80369c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            if( ( ( channelsMask[k] & ( 1 << j ) ) != 0 ) )
 80369ca:	f831 8014 	ldrh.w	r8, [r1, r4, lsl #1]
 80369ce:	fb1e 7303 	smlabb	r3, lr, r3, r7
 80369d2:	2500      	movs	r5, #0
 80369d4:	fa48 f605 	asr.w	r6, r8, r5
 80369d8:	07f6      	lsls	r6, r6, #31
 80369da:	d50e      	bpl.n	80369fa <RegionCommonChanVerifyDr+0x48>
                if( RegionCommonValueInRange( dr, ( channels[i + j].DrRange.Fields.Min & 0x0F ),
 80369dc:	fb0e 3605 	mla	r6, lr, r5, r3
                                                  ( channels[i + j].DrRange.Fields.Max & 0x0F ) ) == 1 )
 80369e0:	f896 c008 	ldrb.w	ip, [r6, #8]
 80369e4:	f34c 1603 	sbfx	r6, ip, #4, #4
    if( ( value >= min ) && ( value <= max ) )
 80369e8:	f00c 0c0f 	and.w	ip, ip, #15
 80369ec:	4562      	cmp	r2, ip
                                                  ( channels[i + j].DrRange.Fields.Max & 0x0F ) ) == 1 )
 80369ee:	b276      	sxtb	r6, r6
    if( ( value >= min ) && ( value <= max ) )
 80369f0:	db03      	blt.n	80369fa <RegionCommonChanVerifyDr+0x48>
 80369f2:	f006 060f 	and.w	r6, r6, #15
 80369f6:	42b2      	cmp	r2, r6
 80369f8:	dd0d      	ble.n	8036a16 <RegionCommonChanVerifyDr+0x64>
        for( uint8_t j = 0; j < 16; j++ )
 80369fa:	3501      	adds	r5, #1
 80369fc:	2d10      	cmp	r5, #16
 80369fe:	d1e9      	bne.n	80369d4 <RegionCommonChanVerifyDr+0x22>
    for( uint8_t i = 0, k = 0; i < nbChannels; i += 16, k++ )
 8036a00:	3401      	adds	r4, #1
 8036a02:	b2e4      	uxtb	r4, r4
 8036a04:	0123      	lsls	r3, r4, #4
 8036a06:	b2db      	uxtb	r3, r3
 8036a08:	4298      	cmp	r0, r3
 8036a0a:	d8de      	bhi.n	80369ca <RegionCommonChanVerifyDr+0x18>
 8036a0c:	e7da      	b.n	80369c4 <RegionCommonChanVerifyDr+0x12>
 8036a0e:	2400      	movs	r4, #0
 8036a10:	f04f 0e0c 	mov.w	lr, #12
 8036a14:	e7f6      	b.n	8036a04 <RegionCommonChanVerifyDr+0x52>
                    return true;
 8036a16:	2001      	movs	r0, #1
 8036a18:	e7d5      	b.n	80369c6 <RegionCommonChanVerifyDr+0x14>

08036a1a <RegionCommonValueInRange>:
    if( ( value >= min ) && ( value <= max ) )
 8036a1a:	4288      	cmp	r0, r1
 8036a1c:	db04      	blt.n	8036a28 <RegionCommonValueInRange+0xe>
    {
        return 1;
 8036a1e:	4290      	cmp	r0, r2
 8036a20:	bfcc      	ite	gt
 8036a22:	2000      	movgt	r0, #0
 8036a24:	2001      	movle	r0, #1
 8036a26:	4770      	bx	lr
    }
    return 0;
 8036a28:	2000      	movs	r0, #0
}
 8036a2a:	4770      	bx	lr

08036a2c <RegionCommonChanDisable>:

bool RegionCommonChanDisable( uint16_t* channelsMask, uint8_t id, uint8_t maxChannels )
{
 8036a2c:	b510      	push	{r4, lr}
    uint8_t index = id / 16;

    if( ( index > ( maxChannels / 16 ) ) || ( id >= maxChannels ) )
 8036a2e:	0914      	lsrs	r4, r2, #4
 8036a30:	ebb4 1f11 	cmp.w	r4, r1, lsr #4
{
 8036a34:	4603      	mov	r3, r0
    uint8_t index = id / 16;
 8036a36:	ea4f 1011 	mov.w	r0, r1, lsr #4
    if( ( index > ( maxChannels / 16 ) ) || ( id >= maxChannels ) )
 8036a3a:	d30e      	bcc.n	8036a5a <RegionCommonChanDisable+0x2e>
 8036a3c:	4291      	cmp	r1, r2
 8036a3e:	d20c      	bcs.n	8036a5a <RegionCommonChanDisable+0x2e>
    {
        return false;
    }

    // Deactivate channel
    channelsMask[index] &= ~( 1 << ( id % 16 ) );
 8036a40:	b202      	sxth	r2, r0
 8036a42:	f001 010f 	and.w	r1, r1, #15
 8036a46:	f833 4012 	ldrh.w	r4, [r3, r2, lsl #1]
 8036a4a:	2001      	movs	r0, #1
 8036a4c:	fa00 f101 	lsl.w	r1, r0, r1
 8036a50:	ea24 0101 	bic.w	r1, r4, r1
 8036a54:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]

    return true;
}
 8036a58:	bd10      	pop	{r4, pc}
        return false;
 8036a5a:	2000      	movs	r0, #0
 8036a5c:	e7fc      	b.n	8036a58 <RegionCommonChanDisable+0x2c>

08036a5e <RegionCommonCountChannels>:

uint8_t RegionCommonCountChannels( uint16_t* channelsMask, uint8_t startIdx, uint8_t stopIdx )
{
 8036a5e:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint8_t nbChannels = 0;

    if( channelsMask == NULL )
 8036a60:	b128      	cbz	r0, 8036a6e <RegionCommonCountChannels+0x10>
 8036a62:	eb00 0541 	add.w	r5, r0, r1, lsl #1
        if( ( mask & ( 1 << j ) ) == ( 1 << j ) )
 8036a66:	2601      	movs	r6, #1
    uint8_t nbChannels = 0;
 8036a68:	2000      	movs	r0, #0
    {
        return 0;
    }

    for( uint8_t i = startIdx; i < stopIdx; i++ )
 8036a6a:	4291      	cmp	r1, r2
 8036a6c:	d300      	bcc.n	8036a70 <RegionCommonCountChannels+0x12>
    {
        nbChannels += CountChannels( channelsMask[i], 16 );
    }

    return nbChannels;
}
 8036a6e:	bdf0      	pop	{r4, r5, r6, r7, pc}
        nbChannels += CountChannels( channelsMask[i], 16 );
 8036a70:	2400      	movs	r4, #0
 8036a72:	f835 7b02 	ldrh.w	r7, [r5], #2
    uint8_t nbActiveBits = 0;
 8036a76:	4623      	mov	r3, r4
        if( ( mask & ( 1 << j ) ) == ( 1 << j ) )
 8036a78:	fa06 fc04 	lsl.w	ip, r6, r4
 8036a7c:	ea3c 0c07 	bics.w	ip, ip, r7
            nbActiveBits++;
 8036a80:	bf08      	it	eq
 8036a82:	3301      	addeq	r3, #1
 8036a84:	f104 0401 	add.w	r4, r4, #1
 8036a88:	bf08      	it	eq
 8036a8a:	b2db      	uxtbeq	r3, r3
    for( uint8_t j = 0; j < nbBits; j++ )
 8036a8c:	2c10      	cmp	r4, #16
 8036a8e:	d1f3      	bne.n	8036a78 <RegionCommonCountChannels+0x1a>
        nbChannels += CountChannels( channelsMask[i], 16 );
 8036a90:	4418      	add	r0, r3
    for( uint8_t i = startIdx; i < stopIdx; i++ )
 8036a92:	3101      	adds	r1, #1
        nbChannels += CountChannels( channelsMask[i], 16 );
 8036a94:	b2c0      	uxtb	r0, r0
    for( uint8_t i = startIdx; i < stopIdx; i++ )
 8036a96:	b2c9      	uxtb	r1, r1
 8036a98:	e7e7      	b.n	8036a6a <RegionCommonCountChannels+0xc>

08036a9a <RegionCommonChanMaskCopy>:

void RegionCommonChanMaskCopy( uint16_t* channelsMaskDest, uint16_t* channelsMaskSrc, uint8_t len )
{
 8036a9a:	b510      	push	{r4, lr}
    if( ( channelsMaskDest != NULL ) && ( channelsMaskSrc != NULL ) )
 8036a9c:	b100      	cbz	r0, 8036aa0 <RegionCommonChanMaskCopy+0x6>
 8036a9e:	b949      	cbnz	r1, 8036ab4 <RegionCommonChanMaskCopy+0x1a>
        for( uint8_t i = 0; i < len; i++ )
        {
            channelsMaskDest[i] = channelsMaskSrc[i];
        }
    }
}
 8036aa0:	bd10      	pop	{r4, pc}
            channelsMaskDest[i] = channelsMaskSrc[i];
 8036aa2:	f831 4013 	ldrh.w	r4, [r1, r3, lsl #1]
 8036aa6:	f820 4013 	strh.w	r4, [r0, r3, lsl #1]
        for( uint8_t i = 0; i < len; i++ )
 8036aaa:	3301      	adds	r3, #1
 8036aac:	b2dc      	uxtb	r4, r3
 8036aae:	42a2      	cmp	r2, r4
 8036ab0:	d8f7      	bhi.n	8036aa2 <RegionCommonChanMaskCopy+0x8>
 8036ab2:	e7f5      	b.n	8036aa0 <RegionCommonChanMaskCopy+0x6>
 8036ab4:	2300      	movs	r3, #0
 8036ab6:	e7f9      	b.n	8036aac <RegionCommonChanMaskCopy+0x12>

08036ab8 <RegionCommonSetBandTxDone>:

void RegionCommonSetBandTxDone( Band_t* band, TimerTime_t lastTxAirTime, bool joined, SysTime_t elapsedTimeSinceStartup )
{
 8036ab8:	b082      	sub	sp, #8
 8036aba:	b530      	push	{r4, r5, lr}
    // Get the band duty cycle. If not joined, the function either returns the join duty cycle
    // or the band duty cycle, whichever is more restrictive.
    uint16_t dutyCycle = GetDutyCycle( band, joined, elapsedTimeSinceStartup );
 8036abc:	8804      	ldrh	r4, [r0, #0]
{
 8036abe:	9304      	str	r3, [sp, #16]
    if( joined == false )
 8036ac0:	b972      	cbnz	r2, 8036ae0 <RegionCommonSetBandTxDone+0x28>
        if( elapsedTimeSinceStartup.Seconds < BACKOFF_DUTY_CYCLE_1_HOUR_IN_S )
 8036ac2:	f5b3 6f61 	cmp.w	r3, #3600	; 0xe10
 8036ac6:	d319      	bcc.n	8036afc <RegionCommonSetBandTxDone+0x44>
            joinDutyCycle = BACKOFF_DC_24_HOURS;
 8036ac8:	f649 25af 	movw	r5, #39599	; 0x9aaf
 8036acc:	f242 7210 	movw	r2, #10000	; 0x2710
 8036ad0:	42ab      	cmp	r3, r5
 8036ad2:	bf8c      	ite	hi
 8036ad4:	4613      	movhi	r3, r2
 8036ad6:	f44f 737a 	movls.w	r3, #1000	; 0x3e8
        dutyCycle = MAX( dutyCycle, joinDutyCycle );
 8036ada:	429c      	cmp	r4, r3
 8036adc:	bf38      	it	cc
 8036ade:	461c      	movcc	r4, r3

    // Reduce with transmission time
    if( band->TimeCredits > ( lastTxAirTime * dutyCycle ) )
 8036ae0:	2c01      	cmp	r4, #1
 8036ae2:	bf38      	it	cc
 8036ae4:	2401      	movcc	r4, #1
 8036ae6:	4361      	muls	r1, r4
    }
    else
    {
        band->TimeCredits = 0;
    }
}
 8036ae8:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    if( band->TimeCredits > ( lastTxAirTime * dutyCycle ) )
 8036aec:	68c3      	ldr	r3, [r0, #12]
 8036aee:	428b      	cmp	r3, r1
        band->TimeCredits -= ( lastTxAirTime * dutyCycle );
 8036af0:	bf8c      	ite	hi
 8036af2:	1a59      	subhi	r1, r3, r1
        band->TimeCredits = 0;
 8036af4:	2100      	movls	r1, #0
 8036af6:	60c1      	str	r1, [r0, #12]
}
 8036af8:	b002      	add	sp, #8
 8036afa:	4770      	bx	lr
            joinDutyCycle = BACKOFF_DC_1_HOUR;
 8036afc:	2364      	movs	r3, #100	; 0x64
 8036afe:	e7ec      	b.n	8036ada <RegionCommonSetBandTxDone+0x22>

08036b00 <RegionCommonUpdateBandTimeOff>:

TimerTime_t RegionCommonUpdateBandTimeOff( bool joined, Band_t* bands,
                                           uint8_t nbBands, bool dutyCycleEnabled,
                                           bool lastTxIsJoinRequest, SysTime_t elapsedTimeSinceStartup,
                                           TimerTime_t expectedTimeOnAir )
{
 8036b00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8036b04:	b091      	sub	sp, #68	; 0x44
 8036b06:	4615      	mov	r5, r2
 8036b08:	f8dd 806c 	ldr.w	r8, [sp, #108]	; 0x6c
 8036b0c:	9305      	str	r3, [sp, #20]
 8036b0e:	f89d 3068 	ldrb.w	r3, [sp, #104]	; 0x68
 8036b12:	9309      	str	r3, [sp, #36]	; 0x24
 8036b14:	460c      	mov	r4, r1
 8036b16:	4606      	mov	r6, r0
    TimerTime_t minTimeToWait = TIMERTIME_T_MAX;
    TimerTime_t currentTime = TimerGetCurrentTime( );
 8036b18:	f004 fbcc 	bl	803b2b4 <UTIL_TIMER_GetCurrentTime>
                timeDiff.Seconds = ( elapsedTimeSinceStartup.Seconds - BACKOFF_DUTY_CYCLE_24_HOURS_IN_S ) / BACKOFF_24_HOURS_IN_S;
 8036b1c:	4b68      	ldr	r3, [pc, #416]	; (8036cc0 <RegionCommonUpdateBandTimeOff+0x1c0>)
 8036b1e:	f8df b1b8 	ldr.w	fp, [pc, #440]	; 8036cd8 <RegionCommonUpdateBandTimeOff+0x1d8>
    TimerTime_t currentTime = TimerGetCurrentTime( );
 8036b22:	9006      	str	r0, [sp, #24]
                timeDiff.Seconds = ( elapsedTimeSinceStartup.Seconds - BACKOFF_DUTY_CYCLE_24_HOURS_IN_S ) / BACKOFF_24_HOURS_IN_S;
 8036b24:	f5a8 32f6 	sub.w	r2, r8, #125952	; 0x1ec00
 8036b28:	3a30      	subs	r2, #48	; 0x30
 8036b2a:	fbb2 f2f3 	udiv	r2, r2, r3
                timeDiff.Seconds *= BACKOFF_24_HOURS_IN_S;
 8036b2e:	4353      	muls	r3, r2
                timeDiff.Seconds += BACKOFF_DUTY_CYCLE_24_HOURS_IN_S;
 8036b30:	f503 32f6 	add.w	r2, r3, #125952	; 0x1ec00
 8036b34:	3230      	adds	r2, #48	; 0x30
                    backoffTimeRange.Seconds = BACKOFF_DUTY_CYCLE_24_HOURS_IN_S;
                }
                // Calculate the time to wait.
                if( elapsedTimeSinceStartup.Seconds > BACKOFF_DUTY_CYCLE_24_HOURS_IN_S )
                {
                    backoffTimeRange.Seconds += BACKOFF_24_HOURS_IN_S * ( ( ( elapsedTimeSinceStartup.Seconds - BACKOFF_DUTY_CYCLE_24_HOURS_IN_S ) / BACKOFF_24_HOURS_IN_S ) + 1 );
 8036b36:	f503 33a8 	add.w	r3, r3, #86016	; 0x15000
 8036b3a:	f503 73c0 	add.w	r3, r3, #384	; 0x180
                timeDiff.Seconds += BACKOFF_DUTY_CYCLE_24_HOURS_IN_S;
 8036b3e:	9204      	str	r2, [sp, #16]
 8036b40:	2218      	movs	r2, #24
                    backoffTimeRange.Seconds += BACKOFF_24_HOURS_IN_S * ( ( ( elapsedTimeSinceStartup.Seconds - BACKOFF_DUTY_CYCLE_24_HOURS_IN_S ) / BACKOFF_24_HOURS_IN_S ) + 1 );
 8036b42:	9303      	str	r3, [sp, #12]
 8036b44:	fb12 4305 	smlabb	r3, r2, r5, r4
 8036b48:	9307      	str	r3, [sp, #28]
    uint8_t validBands = 0;
 8036b4a:	2500      	movs	r5, #0
    TimerTime_t minTimeToWait = TIMERTIME_T_MAX;
 8036b4c:	f04f 3aff 	mov.w	sl, #4294967295
    for( uint8_t i = 0; i < nbBands; i++ )
 8036b50:	9b07      	ldr	r3, [sp, #28]
 8036b52:	42a3      	cmp	r3, r4
 8036b54:	d107      	bne.n	8036b66 <RegionCommonUpdateBandTimeOff+0x66>

    if( validBands == 0 )
    {
        // There is no valid band available to handle a transmission
        // in the given DUTY_CYCLE_TIME_PERIOD.
        return TIMERTIME_T_MAX;
 8036b56:	2d00      	cmp	r5, #0
    }
    return minTimeToWait;
}
 8036b58:	bf14      	ite	ne
 8036b5a:	4650      	movne	r0, sl
 8036b5c:	f04f 30ff 	moveq.w	r0, #4294967295
 8036b60:	b011      	add	sp, #68	; 0x44
 8036b62:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        dutyCycle = UpdateTimeCredits( &bands[i], joined, dutyCycleEnabled,
 8036b66:	f9bd 3070 	ldrsh.w	r3, [sp, #112]	; 0x70
 8036b6a:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
    TimerTime_t elapsedTime = SysTimeToMs( elapsedTimeSinceStartup );
 8036b6e:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8036b70:	f8cd 806c 	str.w	r8, [sp, #108]	; 0x6c
 8036b74:	4640      	mov	r0, r8
 8036b76:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
 8036b7a:	f004 fb2d 	bl	803b1d8 <SysTimeToMs>
    dutyCycle = GetDutyCycle( band, joined, elapsedTimeSinceStartup );
 8036b7e:	f8b4 9000 	ldrh.w	r9, [r4]
    if( joined == false )
 8036b82:	b96e      	cbnz	r6, 8036ba0 <RegionCommonUpdateBandTimeOff+0xa0>
        if( elapsedTimeSinceStartup.Seconds < BACKOFF_DUTY_CYCLE_1_HOUR_IN_S )
 8036b84:	f5b8 6f61 	cmp.w	r8, #3600	; 0xe10
 8036b88:	d35b      	bcc.n	8036c42 <RegionCommonUpdateBandTimeOff+0x142>
            joinDutyCycle = BACKOFF_DC_24_HOURS;
 8036b8a:	f649 22af 	movw	r2, #39599	; 0x9aaf
 8036b8e:	f242 7310 	movw	r3, #10000	; 0x2710
 8036b92:	4590      	cmp	r8, r2
 8036b94:	bf98      	it	ls
 8036b96:	f44f 737a 	movls.w	r3, #1000	; 0x3e8
        dutyCycle = MAX( dutyCycle, joinDutyCycle );
 8036b9a:	4599      	cmp	r9, r3
 8036b9c:	bf38      	it	cc
 8036b9e:	4699      	movcc	r9, r3
    if( dutyCycle == 0 )
 8036ba0:	464b      	mov	r3, r9
 8036ba2:	2b01      	cmp	r3, #1
 8036ba4:	bf38      	it	cc
 8036ba6:	2301      	movcc	r3, #1
 8036ba8:	9308      	str	r3, [sp, #32]
    if( joined == false )
 8036baa:	2e00      	cmp	r6, #0
 8036bac:	d152      	bne.n	8036c54 <RegionCommonUpdateBandTimeOff+0x154>
        if( dutyCycle == BACKOFF_DC_1_HOUR )
 8036bae:	f1b9 0f64 	cmp.w	r9, #100	; 0x64
 8036bb2:	d148      	bne.n	8036c46 <RegionCommonUpdateBandTimeOff+0x146>
            band->LastMaxCreditAssignTime = elapsedTime;
 8036bb4:	60a0      	str	r0, [r4, #8]
            maxCredits = DUTY_CYCLE_TIME_PERIOD;
 8036bb6:	465f      	mov	r7, fp
        timeDiff = SysTimeSub( elapsedTimeSinceStartup, SysTimeFromMs( band->LastMaxCreditAssignTime ) );
 8036bb8:	68a1      	ldr	r1, [r4, #8]
 8036bba:	a80e      	add	r0, sp, #56	; 0x38
 8036bbc:	f004 fb2c 	bl	803b218 <SysTimeFromMs>
 8036bc0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8036bc2:	9300      	str	r3, [sp, #0]
 8036bc4:	e9dd 120a 	ldrd	r1, r2, [sp, #40]	; 0x28
 8036bc8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8036bca:	a80c      	add	r0, sp, #48	; 0x30
 8036bcc:	f004 fa84 	bl	803b0d8 <SysTimeSub>
        if( ( ( dutyCycleEnabled == false ) && ( lastTxIsJoinRequest == false ) ) ||
 8036bd0:	9b05      	ldr	r3, [sp, #20]
 8036bd2:	b90b      	cbnz	r3, 8036bd8 <RegionCommonUpdateBandTimeOff+0xd8>
 8036bd4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8036bd6:	b133      	cbz	r3, 8036be6 <RegionCommonUpdateBandTimeOff+0xe6>
 8036bd8:	6923      	ldr	r3, [r4, #16]
 8036bda:	42bb      	cmp	r3, r7
 8036bdc:	d103      	bne.n	8036be6 <RegionCommonUpdateBandTimeOff+0xe6>
            ( band->MaxTimeCredits != maxCredits ) ||
 8036bde:	4b39      	ldr	r3, [pc, #228]	; (8036cc4 <RegionCommonUpdateBandTimeOff+0x1c4>)
 8036be0:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8036be2:	429a      	cmp	r2, r3
 8036be4:	d90d      	bls.n	8036c02 <RegionCommonUpdateBandTimeOff+0x102>
            if( elapsedTimeSinceStartup.Seconds >= BACKOFF_DUTY_CYCLE_24_HOURS_IN_S )
 8036be6:	4b38      	ldr	r3, [pc, #224]	; (8036cc8 <RegionCommonUpdateBandTimeOff+0x1c8>)
            band->TimeCredits = maxCredits;
 8036be8:	60e7      	str	r7, [r4, #12]
            if( elapsedTimeSinceStartup.Seconds >= BACKOFF_DUTY_CYCLE_24_HOURS_IN_S )
 8036bea:	4598      	cmp	r8, r3
 8036bec:	d909      	bls.n	8036c02 <RegionCommonUpdateBandTimeOff+0x102>
                timeDiff.SubSeconds = 0;
 8036bee:	2300      	movs	r3, #0
 8036bf0:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
                band->LastMaxCreditAssignTime = SysTimeToMs( timeDiff );
 8036bf4:	9b04      	ldr	r3, [sp, #16]
 8036bf6:	990d      	ldr	r1, [sp, #52]	; 0x34
 8036bf8:	930c      	str	r3, [sp, #48]	; 0x30
 8036bfa:	4618      	mov	r0, r3
 8036bfc:	f004 faec 	bl	803b1d8 <SysTimeToMs>
 8036c00:	60a0      	str	r0, [r4, #8]
    if( band->LastBandUpdateTime == 0 )
 8036c02:	6860      	ldr	r0, [r4, #4]
 8036c04:	b900      	cbnz	r0, 8036c08 <RegionCommonUpdateBandTimeOff+0x108>
        band->TimeCredits = maxCredits;
 8036c06:	60e7      	str	r7, [r4, #12]
    band->MaxTimeCredits = maxCredits;
 8036c08:	6127      	str	r7, [r4, #16]
    if( joined == true )
 8036c0a:	b126      	cbz	r6, 8036c16 <RegionCommonUpdateBandTimeOff+0x116>
        band->TimeCredits += TimerGetElapsedTime( band->LastBandUpdateTime );
 8036c0c:	f004 fb5c 	bl	803b2c8 <UTIL_TIMER_GetElapsedTime>
 8036c10:	68e3      	ldr	r3, [r4, #12]
 8036c12:	4403      	add	r3, r0
 8036c14:	60e3      	str	r3, [r4, #12]
    if( band->TimeCredits > band->MaxTimeCredits )
 8036c16:	e9d4 3203 	ldrd	r3, r2, [r4, #12]
 8036c1a:	4293      	cmp	r3, r2
    band->LastBandUpdateTime = currentTime;
 8036c1c:	9b06      	ldr	r3, [sp, #24]
        creditCosts = expectedTimeOnAir * dutyCycle;
 8036c1e:	991d      	ldr	r1, [sp, #116]	; 0x74
    band->LastBandUpdateTime = currentTime;
 8036c20:	6063      	str	r3, [r4, #4]
        creditCosts = expectedTimeOnAir * dutyCycle;
 8036c22:	9b08      	ldr	r3, [sp, #32]
        band->TimeCredits = band->MaxTimeCredits;
 8036c24:	bf88      	it	hi
 8036c26:	60e2      	strhi	r2, [r4, #12]
        creditCosts = expectedTimeOnAir * dutyCycle;
 8036c28:	434b      	muls	r3, r1
        if( ( bands[i].TimeCredits > creditCosts ) ||
 8036c2a:	68e1      	ldr	r1, [r4, #12]
 8036c2c:	4299      	cmp	r1, r3
 8036c2e:	d802      	bhi.n	8036c36 <RegionCommonUpdateBandTimeOff+0x136>
 8036c30:	9805      	ldr	r0, [sp, #20]
 8036c32:	b9a8      	cbnz	r0, 8036c60 <RegionCommonUpdateBandTimeOff+0x160>
            ( ( dutyCycleEnabled == false ) && ( joined == true ) ) )
 8036c34:	b1a6      	cbz	r6, 8036c60 <RegionCommonUpdateBandTimeOff+0x160>
            bands[i].ReadyForTransmission = true;
 8036c36:	2301      	movs	r3, #1
            validBands++;
 8036c38:	441d      	add	r5, r3
            bands[i].ReadyForTransmission = true;
 8036c3a:	7523      	strb	r3, [r4, #20]
            validBands++;
 8036c3c:	b2ed      	uxtb	r5, r5
    for( uint8_t i = 0; i < nbBands; i++ )
 8036c3e:	3418      	adds	r4, #24
 8036c40:	e786      	b.n	8036b50 <RegionCommonUpdateBandTimeOff+0x50>
            joinDutyCycle = BACKOFF_DC_1_HOUR;
 8036c42:	2364      	movs	r3, #100	; 0x64
 8036c44:	e7a9      	b.n	8036b9a <RegionCommonUpdateBandTimeOff+0x9a>
        else if( dutyCycle == BACKOFF_DC_10_HOURS )
 8036c46:	f5b9 7f7a 	cmp.w	r9, #1000	; 0x3e8
            maxCredits = DUTY_CYCLE_TIME_PERIOD * 10;
 8036c4a:	bf0a      	itet	eq
 8036c4c:	4f1f      	ldreq	r7, [pc, #124]	; (8036ccc <RegionCommonUpdateBandTimeOff+0x1cc>)
            maxCredits = DUTY_CYCLE_TIME_PERIOD * 24;
 8036c4e:	4f20      	ldrne	r7, [pc, #128]	; (8036cd0 <RegionCommonUpdateBandTimeOff+0x1d0>)
            band->LastMaxCreditAssignTime = elapsedTime;
 8036c50:	60a0      	streq	r0, [r4, #8]
 8036c52:	e7b1      	b.n	8036bb8 <RegionCommonUpdateBandTimeOff+0xb8>
        if( dutyCycleEnabled == false )
 8036c54:	9b05      	ldr	r3, [sp, #20]
 8036c56:	b90b      	cbnz	r3, 8036c5c <RegionCommonUpdateBandTimeOff+0x15c>
            band->TimeCredits = maxCredits;
 8036c58:	f8c4 b00c 	str.w	fp, [r4, #12]
    TimerTime_t maxCredits = DUTY_CYCLE_TIME_PERIOD;
 8036c5c:	465f      	mov	r7, fp
 8036c5e:	e7d0      	b.n	8036c02 <RegionCommonUpdateBandTimeOff+0x102>
            bands[i].ReadyForTransmission = false;
 8036c60:	2000      	movs	r0, #0
            if( bands[i].MaxTimeCredits > creditCosts )
 8036c62:	4293      	cmp	r3, r2
            bands[i].ReadyForTransmission = false;
 8036c64:	7520      	strb	r0, [r4, #20]
            if( bands[i].MaxTimeCredits > creditCosts )
 8036c66:	d206      	bcs.n	8036c76 <RegionCommonUpdateBandTimeOff+0x176>
                minTimeToWait = MIN( minTimeToWait, ( creditCosts - bands[i].TimeCredits ) );
 8036c68:	1a5b      	subs	r3, r3, r1
 8036c6a:	459a      	cmp	sl, r3
                validBands++;
 8036c6c:	f105 0501 	add.w	r5, r5, #1
                minTimeToWait = MIN( minTimeToWait, ( creditCosts - bands[i].TimeCredits ) );
 8036c70:	bf28      	it	cs
 8036c72:	469a      	movcs	sl, r3
                validBands++;
 8036c74:	b2ed      	uxtb	r5, r5
            if( joined == false )
 8036c76:	2e00      	cmp	r6, #0
 8036c78:	d1e1      	bne.n	8036c3e <RegionCommonUpdateBandTimeOff+0x13e>
                if( dutyCycle == BACKOFF_DC_1_HOUR )
 8036c7a:	f1b9 0f64 	cmp.w	r9, #100	; 0x64
 8036c7e:	4a15      	ldr	r2, [pc, #84]	; (8036cd4 <RegionCommonUpdateBandTimeOff+0x1d4>)
                SysTime_t backoffTimeRange = {
 8036c80:	f8ad 6034 	strh.w	r6, [sp, #52]	; 0x34
                if( dutyCycle == BACKOFF_DC_1_HOUR )
 8036c84:	d019      	beq.n	8036cba <RegionCommonUpdateBandTimeOff+0x1ba>
                    backoffTimeRange.Seconds = BACKOFF_DUTY_CYCLE_24_HOURS_IN_S;
 8036c86:	f649 23b0 	movw	r3, #39600	; 0x9ab0
 8036c8a:	f5b9 7f7a 	cmp.w	r9, #1000	; 0x3e8
 8036c8e:	bf18      	it	ne
 8036c90:	4613      	movne	r3, r2
                if( elapsedTimeSinceStartup.Seconds > BACKOFF_DUTY_CYCLE_24_HOURS_IN_S )
 8036c92:	4590      	cmp	r8, r2
                    backoffTimeRange.Seconds += BACKOFF_24_HOURS_IN_S * ( ( ( elapsedTimeSinceStartup.Seconds - BACKOFF_DUTY_CYCLE_24_HOURS_IN_S ) / BACKOFF_24_HOURS_IN_S ) + 1 );
 8036c94:	bf84      	itt	hi
 8036c96:	9a03      	ldrhi	r2, [sp, #12]
 8036c98:	189b      	addhi	r3, r3, r2
                backoffTimeRange  = SysTimeSub( backoffTimeRange, elapsedTimeSinceStartup );
 8036c9a:	930c      	str	r3, [sp, #48]	; 0x30
 8036c9c:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8036c9e:	9300      	str	r3, [sp, #0]
 8036ca0:	af0c      	add	r7, sp, #48	; 0x30
 8036ca2:	e897 0006 	ldmia.w	r7, {r1, r2}
 8036ca6:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8036ca8:	4638      	mov	r0, r7
 8036caa:	f004 fa15 	bl	803b0d8 <SysTimeSub>
                minTimeToWait = SysTimeToMs( backoffTimeRange );
 8036cae:	e897 0003 	ldmia.w	r7, {r0, r1}
 8036cb2:	f004 fa91 	bl	803b1d8 <SysTimeToMs>
 8036cb6:	4682      	mov	sl, r0
 8036cb8:	e7c1      	b.n	8036c3e <RegionCommonUpdateBandTimeOff+0x13e>
                    backoffTimeRange.Seconds = BACKOFF_DUTY_CYCLE_1_HOUR_IN_S;
 8036cba:	f44f 6361 	mov.w	r3, #3600	; 0xe10
 8036cbe:	e7e8      	b.n	8036c92 <RegionCommonUpdateBandTimeOff+0x192>
 8036cc0:	00015180 	.word	0x00015180
 8036cc4:	0001517f 	.word	0x0001517f
 8036cc8:	0001ec2f 	.word	0x0001ec2f
 8036ccc:	0112a880 	.word	0x0112a880
 8036cd0:	02932e00 	.word	0x02932e00
 8036cd4:	0001ec30 	.word	0x0001ec30
 8036cd8:	001b7740 	.word	0x001b7740

08036cdc <RegionCommonParseLinkAdrReq>:

uint8_t RegionCommonParseLinkAdrReq( uint8_t* payload, RegionCommonLinkAdrParams_t* linkAdrParams )
{
    uint8_t retIndex = 0;

    if( payload[0] == SRV_MAC_LINK_ADR_REQ )
 8036cdc:	7803      	ldrb	r3, [r0, #0]
 8036cde:	2b03      	cmp	r3, #3
 8036ce0:	d114      	bne.n	8036d0c <RegionCommonParseLinkAdrReq+0x30>
    {
        // Parse datarate and tx power
        linkAdrParams->Datarate = payload[1];
 8036ce2:	7843      	ldrb	r3, [r0, #1]
        linkAdrParams->TxPower = linkAdrParams->Datarate & 0x0F;
 8036ce4:	f003 020f 	and.w	r2, r3, #15
        linkAdrParams->Datarate = ( linkAdrParams->Datarate >> 4 ) & 0x0F;
 8036ce8:	091b      	lsrs	r3, r3, #4
        linkAdrParams->TxPower = linkAdrParams->Datarate & 0x0F;
 8036cea:	708a      	strb	r2, [r1, #2]
        linkAdrParams->Datarate = ( linkAdrParams->Datarate >> 4 ) & 0x0F;
 8036cec:	704b      	strb	r3, [r1, #1]
        // Parse ChMask
        linkAdrParams->ChMask = ( uint16_t )payload[2];
 8036cee:	7883      	ldrb	r3, [r0, #2]
 8036cf0:	808b      	strh	r3, [r1, #4]
        linkAdrParams->ChMask |= ( uint16_t )payload[3] << 8;
 8036cf2:	78c2      	ldrb	r2, [r0, #3]
 8036cf4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8036cf8:	808b      	strh	r3, [r1, #4]
        // Parse ChMaskCtrl and nbRep
        linkAdrParams->NbRep = payload[4];
 8036cfa:	7903      	ldrb	r3, [r0, #4]
        linkAdrParams->ChMaskCtrl = ( linkAdrParams->NbRep >> 4 ) & 0x07;
 8036cfc:	f3c3 1202 	ubfx	r2, r3, #4, #3
        linkAdrParams->NbRep &= 0x0F;
 8036d00:	f003 030f 	and.w	r3, r3, #15
        linkAdrParams->ChMaskCtrl = ( linkAdrParams->NbRep >> 4 ) & 0x07;
 8036d04:	70ca      	strb	r2, [r1, #3]
        linkAdrParams->NbRep &= 0x0F;
 8036d06:	700b      	strb	r3, [r1, #0]

        // LinkAdrReq has 4 bytes length + 1 byte CMD
        retIndex = 5;
 8036d08:	2005      	movs	r0, #5
 8036d0a:	4770      	bx	lr
    uint8_t retIndex = 0;
 8036d0c:	2000      	movs	r0, #0
    }
    return retIndex;
}
 8036d0e:	4770      	bx	lr

08036d10 <RegionCommonLinkAdrReqVerifyParams>:

uint8_t RegionCommonLinkAdrReqVerifyParams( RegionCommonLinkAdrReqVerifyParams_t* verifyParams, int8_t* dr, int8_t* txPow, uint8_t* nbRep )
{
 8036d10:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 8036d14:	4698      	mov	r8, r3
    int8_t datarate = verifyParams->Datarate;
    int8_t txPower = verifyParams->TxPower;
    int8_t nbRepetitions = verifyParams->NbRep;

    // Handle the case when ADR is off.
    if( verifyParams->AdrEnabled == false )
 8036d16:	7943      	ldrb	r3, [r0, #5]
    uint8_t status = verifyParams->Status;
 8036d18:	7905      	ldrb	r5, [r0, #4]
    int8_t txPower = verifyParams->TxPower;
 8036d1a:	f990 7007 	ldrsb.w	r7, [r0, #7]
    int8_t nbRepetitions = verifyParams->NbRep;
 8036d1e:	7a06      	ldrb	r6, [r0, #8]
{
 8036d20:	4691      	mov	r9, r2
 8036d22:	4604      	mov	r4, r0
    int8_t datarate = verifyParams->Datarate;
 8036d24:	f990 2006 	ldrsb.w	r2, [r0, #6]
{
 8036d28:	468a      	mov	sl, r1
    if( verifyParams->AdrEnabled == false )
 8036d2a:	b31b      	cbz	r3, 8036d74 <RegionCommonLinkAdrReqVerifyParams+0x64>
    int8_t nbRepetitions = verifyParams->NbRep;
 8036d2c:	b276      	sxtb	r6, r6
        nbRepetitions = verifyParams->CurrentNbRep;
        datarate =  verifyParams->CurrentDatarate;
        txPower =  verifyParams->CurrentTxPower;
    }

    if( status != 0 )
 8036d2e:	b1bd      	cbz	r5, 8036d60 <RegionCommonLinkAdrReqVerifyParams+0x50>
    {
        // Verify datarate. The variable phyParam. Value contains the minimum allowed datarate.
        if( RegionCommonChanVerifyDr( verifyParams->NbChannels, verifyParams->ChannelsMask, datarate,
 8036d30:	69a3      	ldr	r3, [r4, #24]
 8036d32:	9301      	str	r3, [sp, #4]
 8036d34:	f994 3015 	ldrsb.w	r3, [r4, #21]
 8036d38:	9300      	str	r3, [sp, #0]
 8036d3a:	6921      	ldr	r1, [r4, #16]
 8036d3c:	f994 3014 	ldrsb.w	r3, [r4, #20]
 8036d40:	7b20      	ldrb	r0, [r4, #12]
 8036d42:	f7ff fe36 	bl	80369b2 <RegionCommonChanVerifyDr>
 8036d46:	b908      	cbnz	r0, 8036d4c <RegionCommonLinkAdrReqVerifyParams+0x3c>
                                      verifyParams->MinDatarate, verifyParams->MaxDatarate, verifyParams->Channels  ) == false )
        {
            status &= 0xFD; // Datarate KO
 8036d48:	f005 05fd 	and.w	r5, r5, #253	; 0xfd
        }

        // Verify tx power
        if( RegionCommonValueInRange( txPower, verifyParams->MaxTxPower, verifyParams->MinTxPower ) == 0 )
 8036d4c:	f994 301d 	ldrsb.w	r3, [r4, #29]
 8036d50:	f994 101c 	ldrsb.w	r1, [r4, #28]
    if( ( value >= min ) && ( value <= max ) )
 8036d54:	42bb      	cmp	r3, r7
 8036d56:	dc14      	bgt.n	8036d82 <RegionCommonLinkAdrReqVerifyParams+0x72>
 8036d58:	42b9      	cmp	r1, r7
 8036d5a:	da13      	bge.n	8036d84 <RegionCommonLinkAdrReqVerifyParams+0x74>
            { // Apply maximum TX power. Accept TX power.
                txPower = verifyParams->MaxTxPower;
            }
            else
            {
                status &= 0xFB; // TxPower KO
 8036d5c:	f005 05fb 	and.w	r5, r5, #251	; 0xfb
    *dr = datarate;
    *txPow = txPower;
    *nbRep = nbRepetitions;

    return status;
}
 8036d60:	4628      	mov	r0, r5
    *dr = datarate;
 8036d62:	f88a 2000 	strb.w	r2, [sl]
    *txPow = txPower;
 8036d66:	f889 7000 	strb.w	r7, [r9]
    *nbRep = nbRepetitions;
 8036d6a:	f888 6000 	strb.w	r6, [r8]
}
 8036d6e:	b002      	add	sp, #8
 8036d70:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        nbRepetitions = verifyParams->CurrentNbRep;
 8036d74:	f990 600b 	ldrsb.w	r6, [r0, #11]
        datarate =  verifyParams->CurrentDatarate;
 8036d78:	f990 2009 	ldrsb.w	r2, [r0, #9]
        txPower =  verifyParams->CurrentTxPower;
 8036d7c:	f990 700a 	ldrsb.w	r7, [r0, #10]
 8036d80:	e7d5      	b.n	8036d2e <RegionCommonLinkAdrReqVerifyParams+0x1e>
 8036d82:	461f      	mov	r7, r3
    if( status == 0x07 )
 8036d84:	2d07      	cmp	r5, #7
 8036d86:	d1eb      	bne.n	8036d60 <RegionCommonLinkAdrReqVerifyParams+0x50>
            nbRepetitions = 1;
 8036d88:	2e00      	cmp	r6, #0
 8036d8a:	bf08      	it	eq
 8036d8c:	2601      	moveq	r6, #1
 8036d8e:	e7e7      	b.n	8036d60 <RegionCommonLinkAdrReqVerifyParams+0x50>

08036d90 <RegionCommonComputeSymbolTimeLoRa>:

uint32_t RegionCommonComputeSymbolTimeLoRa( uint8_t phyDr, uint32_t bandwidthInHz )
{
    return ( 1 << phyDr ) * 1000000 / bandwidthInHz;
 8036d90:	4b02      	ldr	r3, [pc, #8]	; (8036d9c <RegionCommonComputeSymbolTimeLoRa+0xc>)
 8036d92:	fa03 f000 	lsl.w	r0, r3, r0
}
 8036d96:	fbb0 f0f1 	udiv	r0, r0, r1
 8036d9a:	4770      	bx	lr
 8036d9c:	000f4240 	.word	0x000f4240

08036da0 <RegionCommonComputeSymbolTimeFsk>:

uint32_t RegionCommonComputeSymbolTimeFsk( uint8_t phyDrInKbps )
{
    return 8000 / ( uint32_t )phyDrInKbps; // 1 symbol equals 1 byte
}
 8036da0:	f44f 53fa 	mov.w	r3, #8000	; 0x1f40
 8036da4:	fbb3 f0f0 	udiv	r0, r3, r0
 8036da8:	4770      	bx	lr

08036daa <RegionCommonComputeRxWindowParameters>:

void RegionCommonComputeRxWindowParameters( uint32_t tSymbolInUs, uint8_t minRxSymbols, uint32_t rxErrorInMs, uint32_t wakeUpTimeInMs, uint32_t* windowTimeoutInSymbols, int32_t* windowOffsetInMs )
{
 8036daa:	b530      	push	{r4, r5, lr}
    *windowTimeoutInSymbols = MAX( DIV_CEIL( ( ( 2 * minRxSymbols - 8 ) * tSymbolInUs + 2 * ( rxErrorInMs * 1000 ) ),  tSymbolInUs ), minRxSymbols ); // Computed number of symbols
 8036dac:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 8036db0:	1f0c      	subs	r4, r1, #4
 8036db2:	436a      	muls	r2, r5
 8036db4:	fb00 2204 	mla	r2, r0, r4, r2
 8036db8:	0052      	lsls	r2, r2, #1
 8036dba:	bf1e      	ittt	ne
 8036dbc:	f100 34ff 	addne.w	r4, r0, #4294967295
 8036dc0:	1912      	addne	r2, r2, r4
 8036dc2:	fbb2 f2f0 	udivne	r2, r2, r0
 8036dc6:	428a      	cmp	r2, r1
 8036dc8:	bf38      	it	cc
 8036dca:	460a      	movcc	r2, r1
 8036dcc:	9903      	ldr	r1, [sp, #12]
 8036dce:	600a      	str	r2, [r1, #0]
    *windowOffsetInMs = ( int32_t )DIV_CEIL( ( int32_t )( 4 * tSymbolInUs ) -
 8036dd0:	0081      	lsls	r1, r0, #2
 8036dd2:	4350      	muls	r0, r2
 8036dd4:	bf1c      	itt	ne
 8036dd6:	3001      	addne	r0, #1
 8036dd8:	0840      	lsrne	r0, r0, #1
 8036dda:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8036dde:	1a08      	subs	r0, r1, r0
 8036de0:	fb02 0313 	mls	r3, r2, r3, r0
 8036de4:	2b00      	cmp	r3, #0
 8036de6:	bfca      	itet	gt
 8036de8:	f203 33e7 	addwgt	r3, r3, #999	; 0x3e7
 8036dec:	fb93 f3f2 	sdivle	r3, r3, r2
 8036df0:	fbb3 f3f2 	udivgt	r3, r3, r2
 8036df4:	9a04      	ldr	r2, [sp, #16]
 8036df6:	6013      	str	r3, [r2, #0]
                                               ( int32_t )DIV_CEIL( ( *windowTimeoutInSymbols * tSymbolInUs ), 2 ) -
                                               ( int32_t )( wakeUpTimeInMs * 1000 ), 1000 );
}
 8036df8:	bd30      	pop	{r4, r5, pc}

08036dfa <RegionCommonComputeTxPower>:

int8_t RegionCommonComputeTxPower( int8_t txPowerIndex, float maxEirp, float antennaGain )
{
 8036dfa:	b538      	push	{r3, r4, r5, lr}
    int8_t phyTxPower = 0;

    phyTxPower = ( int8_t )floor( ( maxEirp - ( txPowerIndex * 2U ) ) - antennaGain );
 8036dfc:	0040      	lsls	r0, r0, #1
{
 8036dfe:	4614      	mov	r4, r2
 8036e00:	460d      	mov	r5, r1
    phyTxPower = ( int8_t )floor( ( maxEirp - ( txPowerIndex * 2U ) ) - antennaGain );
 8036e02:	f7f4 fe47 	bl	802ba94 <__aeabi_ui2f>
 8036e06:	4601      	mov	r1, r0
 8036e08:	4628      	mov	r0, r5
 8036e0a:	f7f4 fd91 	bl	802b930 <__aeabi_fsub>
 8036e0e:	4621      	mov	r1, r4
 8036e10:	f7f4 fd8e 	bl	802b930 <__aeabi_fsub>
 8036e14:	f7f4 fc80 	bl	802b718 <__aeabi_f2d>
 8036e18:	f004 fcbe 	bl	803b798 <floor>
 8036e1c:	f7f4 fd5c 	bl	802b8d8 <__aeabi_d2iz>

    return phyTxPower;
}
 8036e20:	b240      	sxtb	r0, r0
 8036e22:	bd38      	pop	{r3, r4, r5, pc}

08036e24 <RegionCommonCountNbOfEnabledChannels>:
    /* ST_WORKAROUND_END */
}

void RegionCommonCountNbOfEnabledChannels( RegionCommonCountNbOfEnabledChannelsParams_t* countNbOfEnabledChannelsParams,
                                           uint8_t* enabledChannels, uint8_t* nbEnabledChannels, uint8_t* nbRestrictedChannels )
{
 8036e24:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8036e28:	e9cd 2300 	strd	r2, r3, [sp]
    uint8_t nbChannelCount = 0;
    uint8_t nbRestrictedChannelsCount = 0;

    for( uint8_t i = 0, k = 0; i < countNbOfEnabledChannelsParams->MaxNbChannels; i += 16, k++ )
 8036e2c:	2300      	movs	r3, #0
    uint8_t nbRestrictedChannelsCount = 0;
 8036e2e:	461d      	mov	r5, r3
    uint8_t nbChannelCount = 0;
 8036e30:	461e      	mov	r6, r3
    {
        for( uint8_t j = 0; j < 16; j++ )
        {
            if( ( countNbOfEnabledChannelsParams->ChannelsMask[k] & ( 1 << j ) ) != 0 )
            {
                if( countNbOfEnabledChannelsParams->Channels[i + j].Frequency == 0 )
 8036e32:	f04f 090c 	mov.w	r9, #12
 8036e36:	011a      	lsls	r2, r3, #4
    for( uint8_t i = 0, k = 0; i < countNbOfEnabledChannelsParams->MaxNbChannels; i += 16, k++ )
 8036e38:	8a04      	ldrh	r4, [r0, #16]
 8036e3a:	fa5f f882 	uxtb.w	r8, r2
 8036e3e:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 8036e42:	4294      	cmp	r4, r2
 8036e44:	d806      	bhi.n	8036e54 <RegionCommonCountNbOfEnabledChannels+0x30>
                }
                enabledChannels[nbChannelCount++] = i + j;
            }
        }
    }
    *nbEnabledChannels = nbChannelCount;
 8036e46:	9b00      	ldr	r3, [sp, #0]
 8036e48:	701e      	strb	r6, [r3, #0]
    *nbRestrictedChannels = nbRestrictedChannelsCount;
 8036e4a:	9b01      	ldr	r3, [sp, #4]
 8036e4c:	701d      	strb	r5, [r3, #0]
}
 8036e4e:	b003      	add	sp, #12
 8036e50:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            if( ( countNbOfEnabledChannelsParams->ChannelsMask[k] & ( 1 << j ) ) != 0 )
 8036e54:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8036e58:	2200      	movs	r2, #0
 8036e5a:	6844      	ldr	r4, [r0, #4]
 8036e5c:	f834 400c 	ldrh.w	r4, [r4, ip]
 8036e60:	4114      	asrs	r4, r2
 8036e62:	07e7      	lsls	r7, r4, #31
 8036e64:	d52a      	bpl.n	8036ebc <RegionCommonCountNbOfEnabledChannels+0x98>
                if( countNbOfEnabledChannelsParams->Channels[i + j].Frequency == 0 )
 8036e66:	eb02 0e08 	add.w	lr, r2, r8
 8036e6a:	6887      	ldr	r7, [r0, #8]
 8036e6c:	fb09 f40e 	mul.w	r4, r9, lr
 8036e70:	eb07 0a04 	add.w	sl, r7, r4
 8036e74:	593c      	ldr	r4, [r7, r4]
 8036e76:	b30c      	cbz	r4, 8036ebc <RegionCommonCountNbOfEnabledChannels+0x98>
                if( ( countNbOfEnabledChannelsParams->Joined == false ) &&
 8036e78:	7804      	ldrb	r4, [r0, #0]
 8036e7a:	b934      	cbnz	r4, 8036e8a <RegionCommonCountNbOfEnabledChannels+0x66>
                    ( countNbOfEnabledChannelsParams->JoinChannels != NULL ) )
 8036e7c:	6944      	ldr	r4, [r0, #20]
                if( ( countNbOfEnabledChannelsParams->Joined == false ) &&
 8036e7e:	b124      	cbz	r4, 8036e8a <RegionCommonCountNbOfEnabledChannels+0x66>
                    if( ( countNbOfEnabledChannelsParams->JoinChannels[k] & ( 1 << j ) ) == 0 )
 8036e80:	f834 400c 	ldrh.w	r4, [r4, ip]
 8036e84:	4114      	asrs	r4, r2
 8036e86:	07e4      	lsls	r4, r4, #31
 8036e88:	d518      	bpl.n	8036ebc <RegionCommonCountNbOfEnabledChannels+0x98>
                                              countNbOfEnabledChannelsParams->Channels[i + j].DrRange.Fields.Min,
 8036e8a:	f89a 4008 	ldrb.w	r4, [sl, #8]
                if( RegionCommonValueInRange( countNbOfEnabledChannelsParams->Datarate,
 8036e8e:	f990 b001 	ldrsb.w	fp, [r0, #1]
                                              countNbOfEnabledChannelsParams->Channels[i + j].DrRange.Fields.Min,
 8036e92:	f344 0703 	sbfx	r7, r4, #0, #4
    if( ( value >= min ) && ( value <= max ) )
 8036e96:	b27f      	sxtb	r7, r7
 8036e98:	455f      	cmp	r7, fp
 8036e9a:	dc0f      	bgt.n	8036ebc <RegionCommonCountNbOfEnabledChannels+0x98>
                                              countNbOfEnabledChannelsParams->Channels[i + j].DrRange.Fields.Max ) == false )
 8036e9c:	f344 1403 	sbfx	r4, r4, #4, #4
    if( ( value >= min ) && ( value <= max ) )
 8036ea0:	b264      	sxtb	r4, r4
 8036ea2:	455c      	cmp	r4, fp
 8036ea4:	db0a      	blt.n	8036ebc <RegionCommonCountNbOfEnabledChannels+0x98>
                if( countNbOfEnabledChannelsParams->Bands[countNbOfEnabledChannelsParams->Channels[i + j].Band].ReadyForTransmission == false )
 8036ea6:	f89a 4009 	ldrb.w	r4, [sl, #9]
 8036eaa:	eb04 0744 	add.w	r7, r4, r4, lsl #1
 8036eae:	68c4      	ldr	r4, [r0, #12]
 8036eb0:	eb04 04c7 	add.w	r4, r4, r7, lsl #3
 8036eb4:	7d24      	ldrb	r4, [r4, #20]
 8036eb6:	b93c      	cbnz	r4, 8036ec8 <RegionCommonCountNbOfEnabledChannels+0xa4>
                    nbRestrictedChannelsCount++;
 8036eb8:	3501      	adds	r5, #1
 8036eba:	b2ed      	uxtb	r5, r5
        for( uint8_t j = 0; j < 16; j++ )
 8036ebc:	3201      	adds	r2, #1
 8036ebe:	2a10      	cmp	r2, #16
 8036ec0:	d1cb      	bne.n	8036e5a <RegionCommonCountNbOfEnabledChannels+0x36>
    for( uint8_t i = 0, k = 0; i < countNbOfEnabledChannelsParams->MaxNbChannels; i += 16, k++ )
 8036ec2:	3301      	adds	r3, #1
 8036ec4:	b2db      	uxtb	r3, r3
 8036ec6:	e7b6      	b.n	8036e36 <RegionCommonCountNbOfEnabledChannels+0x12>
                enabledChannels[nbChannelCount++] = i + j;
 8036ec8:	1c74      	adds	r4, r6, #1
 8036eca:	f801 e006 	strb.w	lr, [r1, r6]
 8036ece:	b2e6      	uxtb	r6, r4
 8036ed0:	e7f4      	b.n	8036ebc <RegionCommonCountNbOfEnabledChannels+0x98>

08036ed2 <RegionCommonIdentifyChannels>:

LoRaMacStatus_t RegionCommonIdentifyChannels( RegionCommonIdentifyChannelsParam_t* identifyChannelsParam,
                                              TimerTime_t* aggregatedTimeOff, uint8_t* enabledChannels,
                                              uint8_t* nbEnabledChannels, uint8_t* nbRestrictedChannels,
                                              TimerTime_t* nextTxDelay )
{
 8036ed2:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 8036ed6:	4604      	mov	r4, r0
    TimerTime_t elapsed = TimerGetElapsedTime( identifyChannelsParam->LastAggrTx );
 8036ed8:	6840      	ldr	r0, [r0, #4]
{
 8036eda:	e9dd 780c 	ldrd	r7, r8, [sp, #48]	; 0x30
 8036ede:	461e      	mov	r6, r3
 8036ee0:	468a      	mov	sl, r1
 8036ee2:	4691      	mov	r9, r2
    TimerTime_t elapsed = TimerGetElapsedTime( identifyChannelsParam->LastAggrTx );
 8036ee4:	f004 f9f0 	bl	803b2c8 <UTIL_TIMER_GetElapsedTime>
    *nextTxDelay = identifyChannelsParam->AggrTimeOff - elapsed;
 8036ee8:	6823      	ldr	r3, [r4, #0]
 8036eea:	1a1b      	subs	r3, r3, r0
 8036eec:	f8c8 3000 	str.w	r3, [r8]
    *nbRestrictedChannels = 1;
    *nbEnabledChannels = 0;
 8036ef0:	2500      	movs	r5, #0
    *nbRestrictedChannels = 1;
 8036ef2:	2301      	movs	r3, #1
 8036ef4:	703b      	strb	r3, [r7, #0]
    *nbEnabledChannels = 0;
 8036ef6:	7035      	strb	r5, [r6, #0]

    if( ( identifyChannelsParam->LastAggrTx == 0 ) ||
 8036ef8:	6863      	ldr	r3, [r4, #4]
 8036efa:	b113      	cbz	r3, 8036f02 <RegionCommonIdentifyChannels+0x30>
 8036efc:	6823      	ldr	r3, [r4, #0]
 8036efe:	4283      	cmp	r3, r0
 8036f00:	d825      	bhi.n	8036f4e <RegionCommonIdentifyChannels+0x7c>
        ( identifyChannelsParam->AggrTimeOff <= elapsed ) )
    {
        // Reset Aggregated time off
        *aggregatedTimeOff = 0;
 8036f02:	f8ca 5000 	str.w	r5, [sl]

        // Update bands Time OFF
        *nextTxDelay = RegionCommonUpdateBandTimeOff( identifyChannelsParam->CountNbOfEnabledChannelsParam->Joined,
 8036f06:	f8d4 c01c 	ldr.w	ip, [r4, #28]
 8036f0a:	69a3      	ldr	r3, [r4, #24]
 8036f0c:	f89c e000 	ldrb.w	lr, [ip]
 8036f10:	9303      	str	r3, [sp, #12]
 8036f12:	e9d4 0103 	ldrd	r0, r1, [r4, #12]
 8036f16:	ab01      	add	r3, sp, #4
 8036f18:	e883 0003 	stmia.w	r3, {r0, r1}
 8036f1c:	7d23      	ldrb	r3, [r4, #20]
 8036f1e:	9300      	str	r3, [sp, #0]
 8036f20:	f8dc 100c 	ldr.w	r1, [ip, #12]
 8036f24:	7a23      	ldrb	r3, [r4, #8]
 8036f26:	7a62      	ldrb	r2, [r4, #9]
 8036f28:	4670      	mov	r0, lr
 8036f2a:	f7ff fde9 	bl	8036b00 <RegionCommonUpdateBandTimeOff>
                                                      identifyChannelsParam->DutyCycleEnabled,
                                                      identifyChannelsParam->LastTxIsJoinRequest,
                                                      identifyChannelsParam->ElapsedTimeSinceStartUp,
                                                      identifyChannelsParam->ExpectedTimeOnAir );

        RegionCommonCountNbOfEnabledChannels( identifyChannelsParam->CountNbOfEnabledChannelsParam, enabledChannels,
 8036f2e:	463b      	mov	r3, r7
        *nextTxDelay = RegionCommonUpdateBandTimeOff( identifyChannelsParam->CountNbOfEnabledChannelsParam->Joined,
 8036f30:	f8c8 0000 	str.w	r0, [r8]
        RegionCommonCountNbOfEnabledChannels( identifyChannelsParam->CountNbOfEnabledChannelsParam, enabledChannels,
 8036f34:	4632      	mov	r2, r6
 8036f36:	69e0      	ldr	r0, [r4, #28]
 8036f38:	4649      	mov	r1, r9
 8036f3a:	f7ff ff73 	bl	8036e24 <RegionCommonCountNbOfEnabledChannels>
                                              nbEnabledChannels, nbRestrictedChannels );
    }

    if( *nbEnabledChannels > 0 )
 8036f3e:	7833      	ldrb	r3, [r6, #0]
 8036f40:	b12b      	cbz	r3, 8036f4e <RegionCommonIdentifyChannels+0x7c>
    {
        *nextTxDelay = 0;
 8036f42:	f8c8 5000 	str.w	r5, [r8]
        return LORAMAC_STATUS_OK;
 8036f46:	2000      	movs	r0, #0
    }
    else
    {
        return LORAMAC_STATUS_NO_CHANNEL_FOUND;
    }
}
 8036f48:	b004      	add	sp, #16
 8036f4a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    else if( *nbRestrictedChannels > 0 )
 8036f4e:	783b      	ldrb	r3, [r7, #0]
        return LORAMAC_STATUS_NO_CHANNEL_FOUND;
 8036f50:	2b00      	cmp	r3, #0
 8036f52:	bf14      	ite	ne
 8036f54:	200b      	movne	r0, #11
 8036f56:	200c      	moveq	r0, #12
 8036f58:	e7f6      	b.n	8036f48 <RegionCommonIdentifyChannels+0x76>

08036f5a <RegionCommonGetNextLowerTxDr>:

int8_t RegionCommonGetNextLowerTxDr( RegionCommonGetNextLowerTxDrParams_t *params )
{
 8036f5a:	b537      	push	{r0, r1, r2, r4, r5, lr}
    int8_t drLocal = params->CurrentDr;
 8036f5c:	f990 2000 	ldrsb.w	r2, [r0]

    if( params->CurrentDr == params->MinDr )
 8036f60:	f990 5002 	ldrsb.w	r5, [r0, #2]
 8036f64:	4295      	cmp	r5, r2
{
 8036f66:	4604      	mov	r4, r0
    if( params->CurrentDr == params->MinDr )
 8036f68:	d00f      	beq.n	8036f8a <RegionCommonGetNextLowerTxDr+0x30>
    }
    else
    {
        do
        {
            drLocal = ( drLocal - 1 );
 8036f6a:	3a01      	subs	r2, #1
 8036f6c:	b252      	sxtb	r2, r2
        } while( ( drLocal != params->MinDr ) &&
                 ( RegionCommonChanVerifyDr( params->NbChannels, params->ChannelsMask, drLocal, params->MinDr, params->MaxDr, params->Channels  ) == false ) );
 8036f6e:	42aa      	cmp	r2, r5
 8036f70:	d00b      	beq.n	8036f8a <RegionCommonGetNextLowerTxDr+0x30>
 8036f72:	68a3      	ldr	r3, [r4, #8]
 8036f74:	9301      	str	r3, [sp, #4]
 8036f76:	f994 3001 	ldrsb.w	r3, [r4, #1]
 8036f7a:	9300      	str	r3, [sp, #0]
 8036f7c:	6861      	ldr	r1, [r4, #4]
 8036f7e:	78e0      	ldrb	r0, [r4, #3]
 8036f80:	462b      	mov	r3, r5
 8036f82:	f7ff fd16 	bl	80369b2 <RegionCommonChanVerifyDr>
        } while( ( drLocal != params->MinDr ) &&
 8036f86:	2800      	cmp	r0, #0
 8036f88:	d0ef      	beq.n	8036f6a <RegionCommonGetNextLowerTxDr+0x10>

        return drLocal;
    }
}
 8036f8a:	4610      	mov	r0, r2
 8036f8c:	b003      	add	sp, #12
 8036f8e:	bd30      	pop	{r4, r5, pc}

08036f90 <RegionCommonLimitTxPower>:

int8_t RegionCommonLimitTxPower( int8_t txPower, int8_t maxBandTxPower )
{
    // Limit tx power to the band max
    return MAX( txPower, maxBandTxPower );
}
 8036f90:	4288      	cmp	r0, r1
 8036f92:	bfb8      	it	lt
 8036f94:	4608      	movlt	r0, r1
 8036f96:	4770      	bx	lr

08036f98 <RegionCommonGetBandwidth>:

uint32_t RegionCommonGetBandwidth( uint32_t drIndex, const uint32_t* bandwidths )
{
    switch( bandwidths[drIndex] )
 8036f98:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
 8036f9c:	4b05      	ldr	r3, [pc, #20]	; (8036fb4 <RegionCommonGetBandwidth+0x1c>)
 8036f9e:	4298      	cmp	r0, r3
 8036fa0:	d005      	beq.n	8036fae <RegionCommonGetBandwidth+0x16>
        case 125000:
            return 0;
        case 250000:
            return 1;
        case 500000:
            return 2;
 8036fa2:	4b05      	ldr	r3, [pc, #20]	; (8036fb8 <RegionCommonGetBandwidth+0x20>)
 8036fa4:	4298      	cmp	r0, r3
 8036fa6:	bf0c      	ite	eq
 8036fa8:	2002      	moveq	r0, #2
 8036faa:	2000      	movne	r0, #0
 8036fac:	4770      	bx	lr
    switch( bandwidths[drIndex] )
 8036fae:	2001      	movs	r0, #1
    }
}
 8036fb0:	4770      	bx	lr
 8036fb2:	bf00      	nop
 8036fb4:	0003d090 	.word	0x0003d090
 8036fb8:	0007a120 	.word	0x0007a120

08036fbc <RegionCommonRxConfigPrint>:

/* ST_WORKAROUND_BEGIN: Print Tx/Rx config */
void RegionCommonRxConfigPrint(LoRaMacRxSlot_t rxSlot, uint32_t frequency, int8_t dr)
{
 8036fbc:	b5f0      	push	{r4, r5, r6, r7, lr}
    const char *slotStrings[] = { "1", "2", "C", "Multi_C", "P", "Multi_P" };
 8036fbe:	4d13      	ldr	r5, [pc, #76]	; (803700c <RegionCommonRxConfigPrint+0x50>)
{
 8036fc0:	4606      	mov	r6, r0
 8036fc2:	460f      	mov	r7, r1
 8036fc4:	4694      	mov	ip, r2
    const char *slotStrings[] = { "1", "2", "C", "Multi_C", "P", "Multi_P" };
 8036fc6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
{
 8036fc8:	b08b      	sub	sp, #44	; 0x2c
    const char *slotStrings[] = { "1", "2", "C", "Multi_C", "P", "Multi_P" };
 8036fca:	ac04      	add	r4, sp, #16
 8036fcc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8036fce:	e895 0003 	ldmia.w	r5, {r0, r1}

    if ( rxSlot < RX_SLOT_NONE )
 8036fd2:	2e05      	cmp	r6, #5
    const char *slotStrings[] = { "1", "2", "C", "Multi_C", "P", "Multi_P" };
 8036fd4:	e884 0003 	stmia.w	r4, {r0, r1}
    if ( rxSlot < RX_SLOT_NONE )
 8036fd8:	d80f      	bhi.n	8036ffa <RegionCommonRxConfigPrint+0x3e>
    {
        MW_LOG(TS_ON, VLEVEL_M,  "RX_%s on freq %d Hz at DR %d\r\n", slotStrings[rxSlot], frequency, dr );
 8036fda:	ab0a      	add	r3, sp, #40	; 0x28
 8036fdc:	e9cd 7c01 	strd	r7, ip, [sp, #4]
 8036fe0:	eb03 0686 	add.w	r6, r3, r6, lsl #2
 8036fe4:	2201      	movs	r2, #1
 8036fe6:	f856 3c18 	ldr.w	r3, [r6, #-24]
 8036fea:	9300      	str	r3, [sp, #0]
 8036fec:	2100      	movs	r1, #0
 8036fee:	4b08      	ldr	r3, [pc, #32]	; (8037010 <RegionCommonRxConfigPrint+0x54>)
 8036ff0:	2002      	movs	r0, #2
 8036ff2:	f003 fe81 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
    }
    else
    {
        MW_LOG(TS_ON, VLEVEL_M,  "RX on freq %d Hz at DR %d\r\n", frequency, dr );
    }
}
 8036ff6:	b00b      	add	sp, #44	; 0x2c
 8036ff8:	bdf0      	pop	{r4, r5, r6, r7, pc}
        MW_LOG(TS_ON, VLEVEL_M,  "RX on freq %d Hz at DR %d\r\n", frequency, dr );
 8036ffa:	e9cd 7c00 	strd	r7, ip, [sp]
 8036ffe:	4b05      	ldr	r3, [pc, #20]	; (8037014 <RegionCommonRxConfigPrint+0x58>)
 8037000:	2201      	movs	r2, #1
 8037002:	2100      	movs	r1, #0
 8037004:	2002      	movs	r0, #2
 8037006:	f003 fe77 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
}
 803700a:	e7f4      	b.n	8036ff6 <RegionCommonRxConfigPrint+0x3a>
 803700c:	0803badc 	.word	0x0803badc
 8037010:	0803c3d0 	.word	0x0803c3d0
 8037014:	0803c3ef 	.word	0x0803c3ef

08037018 <RegionCommonTxConfigPrint>:

void RegionCommonTxConfigPrint(uint32_t frequency, int8_t dr)
{
 8037018:	b507      	push	{r0, r1, r2, lr}
    MW_LOG(TS_ON, VLEVEL_M,  "TX on freq %d Hz at DR %d\r\n", frequency, dr );
 803701a:	4b05      	ldr	r3, [pc, #20]	; (8037030 <RegionCommonTxConfigPrint+0x18>)
 803701c:	e9cd 0100 	strd	r0, r1, [sp]
 8037020:	2201      	movs	r2, #1
 8037022:	2100      	movs	r1, #0
 8037024:	2002      	movs	r0, #2
 8037026:	f003 fe67 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
}
 803702a:	b003      	add	sp, #12
 803702c:	f85d fb04 	ldr.w	pc, [sp], #4
 8037030:	0803c40b 	.word	0x0803c40b

08037034 <GetTimeOnAir>:
    }
    return true;
}

static TimerTime_t GetTimeOnAir( int8_t datarate, uint16_t pktLen )
{
 8037034:	b5f0      	push	{r4, r5, r6, r7, lr}
 8037036:	460c      	mov	r4, r1
    int8_t phyDr = DataratesEU868[datarate];
 8037038:	4910      	ldr	r1, [pc, #64]	; (803707c <GetTimeOnAir+0x48>)
{
 803703a:	b085      	sub	sp, #20
    int8_t phyDr = DataratesEU868[datarate];
 803703c:	560f      	ldrsb	r7, [r1, r0]
    uint32_t bandwidth = RegionCommonGetBandwidth( datarate, BandwidthsEU868 );
 803703e:	3108      	adds	r1, #8
{
 8037040:	4605      	mov	r5, r0
    uint32_t bandwidth = RegionCommonGetBandwidth( datarate, BandwidthsEU868 );
 8037042:	f7ff ffa9 	bl	8036f98 <RegionCommonGetBandwidth>
 8037046:	4b0e      	ldr	r3, [pc, #56]	; (8037080 <GetTimeOnAir+0x4c>)
 8037048:	b2e4      	uxtb	r4, r4
 803704a:	6a5e      	ldr	r6, [r3, #36]	; 0x24
    TimerTime_t timeOnAir = 0;

    if( datarate == DR_7 )
 803704c:	2d07      	cmp	r5, #7
 803704e:	f04f 0301 	mov.w	r3, #1
    { // High Speed FSK channel
        timeOnAir = Radio.TimeOnAir( MODEM_FSK, bandwidth, phyDr * 1000, 0, 5, false, pktLen, true );
 8037052:	e9cd 4302 	strd	r4, r3, [sp, #8]
    uint32_t bandwidth = RegionCommonGetBandwidth( datarate, BandwidthsEU868 );
 8037056:	4601      	mov	r1, r0
    if( datarate == DR_7 )
 8037058:	d10a      	bne.n	8037070 <GetTimeOnAir+0x3c>
        timeOnAir = Radio.TimeOnAir( MODEM_FSK, bandwidth, phyDr * 1000, 0, 5, false, pktLen, true );
 803705a:	2205      	movs	r2, #5
 803705c:	2300      	movs	r3, #0
 803705e:	e9cd 2300 	strd	r2, r3, [sp]
 8037062:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8037066:	437a      	muls	r2, r7
    }
    else
    {
        timeOnAir = Radio.TimeOnAir( MODEM_LORA, bandwidth, phyDr, 1, 8, false, pktLen, true );
 8037068:	4618      	mov	r0, r3
 803706a:	47b0      	blx	r6
    }
    return timeOnAir;
}
 803706c:	b005      	add	sp, #20
 803706e:	bdf0      	pop	{r4, r5, r6, r7, pc}
        timeOnAir = Radio.TimeOnAir( MODEM_LORA, bandwidth, phyDr, 1, 8, false, pktLen, true );
 8037070:	2208      	movs	r2, #8
 8037072:	2000      	movs	r0, #0
 8037074:	e9cd 2000 	strd	r2, r0, [sp]
 8037078:	463a      	mov	r2, r7
 803707a:	e7f5      	b.n	8037068 <GetTimeOnAir+0x34>
 803707c:	0803baf4 	.word	0x0803baf4
 8037080:	0803bc30 	.word	0x0803bc30

08037084 <VerifyRfFreq>:
{
 8037084:	b538      	push	{r3, r4, r5, lr}
    if( Radio.CheckRfFrequency( freq ) == false )
 8037086:	4b19      	ldr	r3, [pc, #100]	; (80370ec <VerifyRfFreq+0x68>)
 8037088:	6a1b      	ldr	r3, [r3, #32]
{
 803708a:	4605      	mov	r5, r0
 803708c:	460c      	mov	r4, r1
    if( Radio.CheckRfFrequency( freq ) == false )
 803708e:	4798      	blx	r3
 8037090:	b130      	cbz	r0, 80370a0 <VerifyRfFreq+0x1c>
    if( ( freq >= 863000000 ) && ( freq < 865000000 ) )
 8037092:	4b17      	ldr	r3, [pc, #92]	; (80370f0 <VerifyRfFreq+0x6c>)
 8037094:	4a17      	ldr	r2, [pc, #92]	; (80370f4 <VerifyRfFreq+0x70>)
 8037096:	442b      	add	r3, r5
 8037098:	4293      	cmp	r3, r2
 803709a:	d802      	bhi.n	80370a2 <VerifyRfFreq+0x1e>
        *band = 2;
 803709c:	2302      	movs	r3, #2
        *band = 3;
 803709e:	7023      	strb	r3, [r4, #0]
}
 80370a0:	bd38      	pop	{r3, r4, r5, pc}
    else if( ( freq >= 865000000 ) && ( freq <= 868000000 ) )
 80370a2:	4b15      	ldr	r3, [pc, #84]	; (80370f8 <VerifyRfFreq+0x74>)
 80370a4:	4a15      	ldr	r2, [pc, #84]	; (80370fc <VerifyRfFreq+0x78>)
 80370a6:	442b      	add	r3, r5
 80370a8:	4293      	cmp	r3, r2
 80370aa:	d801      	bhi.n	80370b0 <VerifyRfFreq+0x2c>
        *band = 0;
 80370ac:	2300      	movs	r3, #0
 80370ae:	e7f6      	b.n	803709e <VerifyRfFreq+0x1a>
    else if( ( freq > 868000000 ) && ( freq <= 868600000 ) )
 80370b0:	4b13      	ldr	r3, [pc, #76]	; (8037100 <VerifyRfFreq+0x7c>)
 80370b2:	4a14      	ldr	r2, [pc, #80]	; (8037104 <VerifyRfFreq+0x80>)
 80370b4:	442b      	add	r3, r5
 80370b6:	4293      	cmp	r3, r2
 80370b8:	d801      	bhi.n	80370be <VerifyRfFreq+0x3a>
        *band = 1;
 80370ba:	2301      	movs	r3, #1
 80370bc:	e7ef      	b.n	803709e <VerifyRfFreq+0x1a>
    else if( ( freq >= 868700000 ) && ( freq <= 869200000 ) )
 80370be:	4b12      	ldr	r3, [pc, #72]	; (8037108 <VerifyRfFreq+0x84>)
 80370c0:	4a12      	ldr	r2, [pc, #72]	; (803710c <VerifyRfFreq+0x88>)
 80370c2:	442b      	add	r3, r5
 80370c4:	4293      	cmp	r3, r2
 80370c6:	d801      	bhi.n	80370cc <VerifyRfFreq+0x48>
        *band = 5;
 80370c8:	2305      	movs	r3, #5
 80370ca:	e7e8      	b.n	803709e <VerifyRfFreq+0x1a>
    else if( ( freq >= 869400000 ) && ( freq <= 869650000 ) )
 80370cc:	4b10      	ldr	r3, [pc, #64]	; (8037110 <VerifyRfFreq+0x8c>)
 80370ce:	4a11      	ldr	r2, [pc, #68]	; (8037114 <VerifyRfFreq+0x90>)
 80370d0:	442b      	add	r3, r5
 80370d2:	4293      	cmp	r3, r2
 80370d4:	d801      	bhi.n	80370da <VerifyRfFreq+0x56>
        *band = 3;
 80370d6:	2303      	movs	r3, #3
 80370d8:	e7e1      	b.n	803709e <VerifyRfFreq+0x1a>
    else if( ( freq >= 869700000 ) && ( freq <= 870000000 ) )
 80370da:	4b0f      	ldr	r3, [pc, #60]	; (8037118 <VerifyRfFreq+0x94>)
 80370dc:	4a0f      	ldr	r2, [pc, #60]	; (803711c <VerifyRfFreq+0x98>)
 80370de:	442b      	add	r3, r5
 80370e0:	4293      	cmp	r3, r2
 80370e2:	d801      	bhi.n	80370e8 <VerifyRfFreq+0x64>
        *band = 4;
 80370e4:	2304      	movs	r3, #4
 80370e6:	e7da      	b.n	803709e <VerifyRfFreq+0x1a>
        return false;
 80370e8:	2000      	movs	r0, #0
 80370ea:	e7d9      	b.n	80370a0 <VerifyRfFreq+0x1c>
 80370ec:	0803bc30 	.word	0x0803bc30
 80370f0:	cc8faa40 	.word	0xcc8faa40
 80370f4:	001e847f 	.word	0x001e847f
 80370f8:	cc7125c0 	.word	0xcc7125c0
 80370fc:	002dc6c0 	.word	0x002dc6c0
 8037100:	cc435eff 	.word	0xcc435eff
 8037104:	000927bf 	.word	0x000927bf
 8037108:	cc38b0a0 	.word	0xcc38b0a0
 803710c:	0007a120 	.word	0x0007a120
 8037110:	cc2e0240 	.word	0xcc2e0240
 8037114:	0003d090 	.word	0x0003d090
 8037118:	cc296e60 	.word	0xcc296e60
 803711c:	000493e0 	.word	0x000493e0

08037120 <RegionEU868GetPhyParam>:
#endif /* REGION_EU868 */

PhyParam_t RegionEU868GetPhyParam( GetPhyParams_t* getPhy )
{
 8037120:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8037122:	7802      	ldrb	r2, [r0, #0]
    PhyParam_t phyParam = { 0 };
 8037124:	2300      	movs	r3, #0
 8037126:	3a0b      	subs	r2, #11
 8037128:	9300      	str	r3, [sp, #0]

#if defined( REGION_EU868 )
    switch( getPhy->Attribute )
 803712a:	2a2e      	cmp	r2, #46	; 0x2e
 803712c:	d871      	bhi.n	8037212 <RegionEU868GetPhyParam+0xf2>
 803712e:	e8df f002 	tbb	[pc, r2]
 8037132:	302d      	.short	0x302d
 8037134:	42403932 	.word	0x42403932
 8037138:	4e4b4845 	.word	0x4e4b4845
 803713c:	5c705451 	.word	0x5c705451
 8037140:	68635e70 	.word	0x68635e70
 8037144:	6d70706a 	.word	0x6d70706a
 8037148:	70701874 	.word	0x70701874
 803714c:	70707070 	.word	0x70707070
 8037150:	70707070 	.word	0x70707070
 8037154:	5c707070 	.word	0x5c707070
 8037158:	70707d76 	.word	0x70707d76
 803715c:	7f707d5c 	.word	0x7f707d5c
 8037160:	84          	.byte	0x84
 8037161:	00          	.byte	0x00
            phyParam.Value = EU868_DEFAULT_DATARATE;
            break;
        }
        case PHY_NEXT_LOWER_TX_DR:
        {
            RegionCommonGetNextLowerTxDrParams_t nextLowerTxDrParams =
 8037162:	7843      	ldrb	r3, [r0, #1]
 8037164:	f88d 3004 	strb.w	r3, [sp, #4]
 8037168:	2307      	movs	r3, #7
 803716a:	f88d 3005 	strb.w	r3, [sp, #5]
 803716e:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8037172:	f8ad 3006 	strh.w	r3, [sp, #6]
            {
                .CurrentDr = getPhy->Datarate,
                .MaxDr = ( int8_t )EU868_TX_MAX_DATARATE,
                .MinDr = ( int8_t )EU868_TX_MIN_DATARATE,
                .NbChannels = EU868_MAX_NB_CHANNELS,
                .ChannelsMask = RegionNvmGroup2->ChannelsMask,
 8037176:	4b34      	ldr	r3, [pc, #208]	; (8037248 <RegionEU868GetPhyParam+0x128>)
 8037178:	681b      	ldr	r3, [r3, #0]
                .Channels = RegionNvmGroup2->Channels,
            };
            phyParam.Value = RegionCommonGetNextLowerTxDr( &nextLowerTxDrParams );
 803717a:	a801      	add	r0, sp, #4
                .ChannelsMask = RegionNvmGroup2->ChannelsMask,
 803717c:	f503 7258 	add.w	r2, r3, #864	; 0x360
            RegionCommonGetNextLowerTxDrParams_t nextLowerTxDrParams =
 8037180:	e9cd 2302 	strd	r2, r3, [sp, #8]
            phyParam.Value = RegionCommonGetNextLowerTxDr( &nextLowerTxDrParams );
 8037184:	f7ff fee9 	bl	8036f5a <RegionCommonGetNextLowerTxDr>
            phyParam.Value = DataratesEU868[getPhy->Datarate];
            break;
        }
        case PHY_BW_FROM_DR:
        {
            phyParam.Value = RegionCommonGetBandwidth( getPhy->Datarate, BandwidthsEU868 );
 8037188:	9000      	str	r0, [sp, #0]
            break;
 803718a:	e042      	b.n	8037212 <RegionEU868GetPhyParam+0xf2>
            phyParam.Value = REGION_COMMON_DEFAULT_ADR_ACK_LIMIT;
 803718c:	2340      	movs	r3, #64	; 0x40
            phyParam.Value = EU868_BEACON_CHANNEL_DR;
 803718e:	9300      	str	r3, [sp, #0]
            break;
 8037190:	e03f      	b.n	8037212 <RegionEU868GetPhyParam+0xf2>
            phyParam.Value = REGION_COMMON_DEFAULT_ADR_ACK_DELAY;
 8037192:	2320      	movs	r3, #32
 8037194:	e7fb      	b.n	803718e <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = MaxPayloadOfDatarateEU868[getPhy->Datarate];
 8037196:	f990 2001 	ldrsb.w	r2, [r0, #1]
 803719a:	4b2c      	ldr	r3, [pc, #176]	; (803724c <RegionEU868GetPhyParam+0x12c>)
 803719c:	4413      	add	r3, r2
 803719e:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 80371a2:	e7f4      	b.n	803718e <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = MaxPayloadOfDatarateRepeaterEU868[getPhy->Datarate];
 80371a4:	f990 2001 	ldrsb.w	r2, [r0, #1]
 80371a8:	4b28      	ldr	r3, [pc, #160]	; (803724c <RegionEU868GetPhyParam+0x12c>)
 80371aa:	4413      	add	r3, r2
 80371ac:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 80371b0:	e7ed      	b.n	803718e <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = EU868_DUTY_CYCLE_ENABLED;
 80371b2:	2301      	movs	r3, #1
 80371b4:	e7eb      	b.n	803718e <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = EU868_MAX_RX_WINDOW;
 80371b6:	f640 33b8 	movw	r3, #3000	; 0xbb8
 80371ba:	e7e8      	b.n	803718e <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = REGION_COMMON_DEFAULT_RECEIVE_DELAY1;
 80371bc:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80371c0:	e7e5      	b.n	803718e <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = REGION_COMMON_DEFAULT_RECEIVE_DELAY2;
 80371c2:	f44f 63fa 	mov.w	r3, #2000	; 0x7d0
 80371c6:	e7e2      	b.n	803718e <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = REGION_COMMON_DEFAULT_JOIN_ACCEPT_DELAY1;
 80371c8:	f241 3388 	movw	r3, #5000	; 0x1388
 80371cc:	e7df      	b.n	803718e <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = REGION_COMMON_DEFAULT_JOIN_ACCEPT_DELAY2;
 80371ce:	f241 7370 	movw	r3, #6000	; 0x1770
 80371d2:	e7dc      	b.n	803718e <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = REGION_COMMON_DEFAULT_MAX_FCNT_GAP;
 80371d4:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 80371d8:	e7d9      	b.n	803718e <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = ( REGION_COMMON_DEFAULT_ACK_TIMEOUT + randr( -REGION_COMMON_DEFAULT_ACK_TIMEOUT_RND, REGION_COMMON_DEFAULT_ACK_TIMEOUT_RND ) );
 80371da:	481d      	ldr	r0, [pc, #116]	; (8037250 <RegionEU868GetPhyParam+0x130>)
 80371dc:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 80371e0:	f001 fe88 	bl	8038ef4 <randr>
 80371e4:	f500 60fa 	add.w	r0, r0, #2000	; 0x7d0
 80371e8:	e7ce      	b.n	8037188 <RegionEU868GetPhyParam+0x68>
            phyParam.Value = EU868_RX_WND_2_FREQ;
 80371ea:	4b1a      	ldr	r3, [pc, #104]	; (8037254 <RegionEU868GetPhyParam+0x134>)
 80371ec:	e7cf      	b.n	803718e <RegionEU868GetPhyParam+0x6e>
            phyParam.ChannelsMask = RegionNvmGroup2->ChannelsMask;
 80371ee:	4b16      	ldr	r3, [pc, #88]	; (8037248 <RegionEU868GetPhyParam+0x128>)
 80371f0:	681b      	ldr	r3, [r3, #0]
 80371f2:	f503 7358 	add.w	r3, r3, #864	; 0x360
 80371f6:	e7ca      	b.n	803718e <RegionEU868GetPhyParam+0x6e>
            phyParam.ChannelsMask = RegionNvmGroup2->ChannelsDefaultMask;
 80371f8:	4b13      	ldr	r3, [pc, #76]	; (8037248 <RegionEU868GetPhyParam+0x128>)
 80371fa:	681b      	ldr	r3, [r3, #0]
 80371fc:	f503 735b 	add.w	r3, r3, #876	; 0x36c
 8037200:	e7c5      	b.n	803718e <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = EU868_MAX_NB_CHANNELS;
 8037202:	2310      	movs	r3, #16
 8037204:	e7c3      	b.n	803718e <RegionEU868GetPhyParam+0x6e>
            phyParam.Channels = RegionNvmGroup2->Channels;
 8037206:	4b10      	ldr	r3, [pc, #64]	; (8037248 <RegionEU868GetPhyParam+0x128>)
 8037208:	681b      	ldr	r3, [r3, #0]
 803720a:	e7c0      	b.n	803718e <RegionEU868GetPhyParam+0x6e>
            phyParam.fValue = EU868_DEFAULT_MAX_EIRP;
 803720c:	f04f 4383 	mov.w	r3, #1098907648	; 0x41800000
            phyParam.fValue = EU868_DEFAULT_ANTENNA_GAIN;
 8037210:	9300      	str	r3, [sp, #0]
        }
    }

#endif /* REGION_EU868 */
    return phyParam;
}
 8037212:	9800      	ldr	r0, [sp, #0]
 8037214:	b005      	add	sp, #20
 8037216:	f85d fb04 	ldr.w	pc, [sp], #4
            phyParam.fValue = EU868_DEFAULT_ANTENNA_GAIN;
 803721a:	4b0f      	ldr	r3, [pc, #60]	; (8037258 <RegionEU868GetPhyParam+0x138>)
 803721c:	e7f8      	b.n	8037210 <RegionEU868GetPhyParam+0xf0>
            phyParam.BeaconFormat.BeaconSize = EU868_BEACON_SIZE;
 803721e:	f240 2211 	movw	r2, #529	; 0x211
 8037222:	f8ad 2000 	strh.w	r2, [sp]
            phyParam.BeaconFormat.Rfu2Size = EU868_RFU2_SIZE;
 8037226:	f88d 3002 	strb.w	r3, [sp, #2]
            break;
 803722a:	e7f2      	b.n	8037212 <RegionEU868GetPhyParam+0xf2>
            phyParam.Value = EU868_BEACON_CHANNEL_DR;
 803722c:	2303      	movs	r3, #3
 803722e:	e7ae      	b.n	803718e <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = DataratesEU868[getPhy->Datarate];
 8037230:	f990 3001 	ldrsb.w	r3, [r0, #1]
 8037234:	4a05      	ldr	r2, [pc, #20]	; (803724c <RegionEU868GetPhyParam+0x12c>)
 8037236:	5cd3      	ldrb	r3, [r2, r3]
 8037238:	e7a9      	b.n	803718e <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = RegionCommonGetBandwidth( getPhy->Datarate, BandwidthsEU868 );
 803723a:	4908      	ldr	r1, [pc, #32]	; (803725c <RegionEU868GetPhyParam+0x13c>)
 803723c:	f990 0001 	ldrsb.w	r0, [r0, #1]
 8037240:	f7ff feaa 	bl	8036f98 <RegionCommonGetBandwidth>
 8037244:	e7a0      	b.n	8037188 <RegionEU868GetPhyParam+0x68>
 8037246:	bf00      	nop
 8037248:	20005728 	.word	0x20005728
 803724c:	0803baf4 	.word	0x0803baf4
 8037250:	fffffc18 	.word	0xfffffc18
 8037254:	33d3e608 	.word	0x33d3e608
 8037258:	4009999a 	.word	0x4009999a
 803725c:	0803bafc 	.word	0x0803bafc

08037260 <RegionEU868SetBandTxDone>:

void RegionEU868SetBandTxDone( SetBandTxDoneParams_t* txDone )
{
 8037260:	b537      	push	{r0, r1, r2, r4, r5, lr}
#if defined( REGION_EU868 )
    RegionCommonSetBandTxDone( &RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txDone->Channel].Band],
 8037262:	4a0a      	ldr	r2, [pc, #40]	; (803728c <RegionEU868SetBandTxDone+0x2c>)
 8037264:	7803      	ldrb	r3, [r0, #0]
 8037266:	6811      	ldr	r1, [r2, #0]
 8037268:	6855      	ldr	r5, [r2, #4]
 803726a:	240c      	movs	r4, #12
 803726c:	fb04 1303 	mla	r3, r4, r3, r1
 8037270:	7a5b      	ldrb	r3, [r3, #9]
 8037272:	eb03 0443 	add.w	r4, r3, r3, lsl #1
 8037276:	6903      	ldr	r3, [r0, #16]
 8037278:	9300      	str	r3, [sp, #0]
 803727a:	68c3      	ldr	r3, [r0, #12]
 803727c:	7842      	ldrb	r2, [r0, #1]
 803727e:	6881      	ldr	r1, [r0, #8]
 8037280:	eb05 00c4 	add.w	r0, r5, r4, lsl #3
 8037284:	f7ff fc18 	bl	8036ab8 <RegionCommonSetBandTxDone>
                               txDone->LastTxAirTime, txDone->Joined, txDone->ElapsedTimeSinceStartUp );
#endif /* REGION_EU868 */
}
 8037288:	b003      	add	sp, #12
 803728a:	bd30      	pop	{r4, r5, pc}
 803728c:	20005728 	.word	0x20005728

08037290 <RegionEU868InitDefaults>:

void RegionEU868InitDefaults( InitDefaultsParams_t* params )
{
 8037290:	b530      	push	{r4, r5, lr}
 8037292:	b0a5      	sub	sp, #148	; 0x94
 8037294:	4604      	mov	r4, r0
#if defined( REGION_EU868 )
    Band_t bands[EU868_MAX_NB_BANDS] =
 8037296:	2290      	movs	r2, #144	; 0x90
 8037298:	2100      	movs	r1, #0
 803729a:	4668      	mov	r0, sp
 803729c:	f004 fa72 	bl	803b784 <memset>
 80372a0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80372a4:	f8ad 2030 	strh.w	r2, [sp, #48]	; 0x30
 80372a8:	f8ad 2078 	strh.w	r2, [sp, #120]	; 0x78
        EU868_BAND3,
        EU868_BAND4,
        EU868_BAND5,
    };

    switch( params->Type )
 80372ac:	7a22      	ldrb	r2, [r4, #8]
    Band_t bands[EU868_MAX_NB_BANDS] =
 80372ae:	2364      	movs	r3, #100	; 0x64
 80372b0:	210a      	movs	r1, #10
    switch( params->Type )
 80372b2:	2a01      	cmp	r2, #1
    Band_t bands[EU868_MAX_NB_BANDS] =
 80372b4:	f8ad 3000 	strh.w	r3, [sp]
 80372b8:	f8ad 3018 	strh.w	r3, [sp, #24]
 80372bc:	f8ad 1048 	strh.w	r1, [sp, #72]	; 0x48
 80372c0:	f8ad 3060 	strh.w	r3, [sp, #96]	; 0x60
    switch( params->Type )
 80372c4:	d02d      	beq.n	8037322 <RegionEU868InitDefaults+0x92>
 80372c6:	2a02      	cmp	r2, #2
 80372c8:	d036      	beq.n	8037338 <RegionEU868InitDefaults+0xa8>
 80372ca:	bb42      	cbnz	r2, 803731e <RegionEU868InitDefaults+0x8e>
    {
        case INIT_TYPE_DEFAULTS:
        {
            if( ( params->NvmGroup1 == NULL ) || ( params->NvmGroup2 == NULL ) )
 80372cc:	6820      	ldr	r0, [r4, #0]
 80372ce:	b330      	cbz	r0, 803731e <RegionEU868InitDefaults+0x8e>
 80372d0:	6863      	ldr	r3, [r4, #4]
 80372d2:	b323      	cbz	r3, 803731e <RegionEU868InitDefaults+0x8e>
            {
                return;
            }

            RegionNvmGroup1 = (RegionNvmDataGroup1_t*) params->NvmGroup1;
 80372d4:	4c1d      	ldr	r4, [pc, #116]	; (803734c <RegionEU868InitDefaults+0xbc>)
            RegionNvmGroup2 = (RegionNvmDataGroup2_t*) params->NvmGroup2;

            // Default bands
            memcpy1( ( uint8_t* )RegionNvmGroup1->Bands, ( uint8_t* )bands, sizeof( Band_t ) * EU868_MAX_NB_BANDS );
 80372d6:	2290      	movs	r2, #144	; 0x90
 80372d8:	4669      	mov	r1, sp
            RegionNvmGroup2 = (RegionNvmDataGroup2_t*) params->NvmGroup2;
 80372da:	e9c4 3000 	strd	r3, r0, [r4]
            memcpy1( ( uint8_t* )RegionNvmGroup1->Bands, ( uint8_t* )bands, sizeof( Band_t ) * EU868_MAX_NB_BANDS );
 80372de:	f001 fe25 	bl	8038f2c <memcpy1>

            // Default channels
            RegionNvmGroup2->Channels[0] = ( ChannelParams_t ) EU868_LC1;
 80372e2:	4b1b      	ldr	r3, [pc, #108]	; (8037350 <RegionEU868InitDefaults+0xc0>)
 80372e4:	6824      	ldr	r4, [r4, #0]
 80372e6:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 80372ea:	e884 0007 	stmia.w	r4, {r0, r1, r2}
            RegionNvmGroup2->Channels[1] = ( ChannelParams_t ) EU868_LC2;
 80372ee:	f103 020c 	add.w	r2, r3, #12
 80372f2:	ca07      	ldmia	r2, {r0, r1, r2}
 80372f4:	f104 050c 	add.w	r5, r4, #12
            RegionNvmGroup2->Channels[2] = ( ChannelParams_t ) EU868_LC3;
 80372f8:	3318      	adds	r3, #24
            RegionNvmGroup2->Channels[1] = ( ChannelParams_t ) EU868_LC2;
 80372fa:	e885 0007 	stmia.w	r5, {r0, r1, r2}
            RegionNvmGroup2->Channels[2] = ( ChannelParams_t ) EU868_LC3;
 80372fe:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8037302:	f104 0518 	add.w	r5, r4, #24

            // Default ChannelsMask
            RegionNvmGroup2->ChannelsDefaultMask[0] = LC( 1 ) + LC( 2 ) + LC( 3 );
 8037306:	2307      	movs	r3, #7
            RegionNvmGroup2->Channels[2] = ( ChannelParams_t ) EU868_LC3;
 8037308:	e885 0007 	stmia.w	r5, {r0, r1, r2}
            RegionNvmGroup2->ChannelsDefaultMask[0] = LC( 1 ) + LC( 2 ) + LC( 3 );
 803730c:	f8a4 336c 	strh.w	r3, [r4, #876]	; 0x36c

            // Update the channels mask
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
 8037310:	2201      	movs	r2, #1
 8037312:	f504 715b 	add.w	r1, r4, #876	; 0x36c
 8037316:	f504 7058 	add.w	r0, r4, #864	; 0x360
            // Reset Channels Rx1Frequency to default 0
            RegionNvmGroup2->Channels[0].Rx1Frequency = 0;
            RegionNvmGroup2->Channels[1].Rx1Frequency = 0;
            RegionNvmGroup2->Channels[2].Rx1Frequency = 0;
            // Update the channels mask
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
 803731a:	f7ff fbbe 	bl	8036a9a <RegionCommonChanMaskCopy>
        {
            break;
        }
    }
#endif /* REGION_EU868 */
}
 803731e:	b025      	add	sp, #148	; 0x94
 8037320:	bd30      	pop	{r4, r5, pc}
            RegionNvmGroup2->Channels[0].Rx1Frequency = 0;
 8037322:	4b0a      	ldr	r3, [pc, #40]	; (803734c <RegionEU868InitDefaults+0xbc>)
 8037324:	6818      	ldr	r0, [r3, #0]
 8037326:	2300      	movs	r3, #0
 8037328:	6043      	str	r3, [r0, #4]
            RegionNvmGroup2->Channels[1].Rx1Frequency = 0;
 803732a:	6103      	str	r3, [r0, #16]
            RegionNvmGroup2->Channels[2].Rx1Frequency = 0;
 803732c:	61c3      	str	r3, [r0, #28]
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
 803732e:	f500 715b 	add.w	r1, r0, #876	; 0x36c
 8037332:	f500 7058 	add.w	r0, r0, #864	; 0x360
 8037336:	e7f0      	b.n	803731a <RegionEU868InitDefaults+0x8a>
            RegionNvmGroup2->ChannelsMask[0] |= RegionNvmGroup2->ChannelsDefaultMask[0];
 8037338:	4b04      	ldr	r3, [pc, #16]	; (803734c <RegionEU868InitDefaults+0xbc>)
 803733a:	681b      	ldr	r3, [r3, #0]
 803733c:	f8b3 2360 	ldrh.w	r2, [r3, #864]	; 0x360
 8037340:	f8b3 136c 	ldrh.w	r1, [r3, #876]	; 0x36c
 8037344:	430a      	orrs	r2, r1
 8037346:	f8a3 2360 	strh.w	r2, [r3, #864]	; 0x360
            break;
 803734a:	e7e8      	b.n	803731e <RegionEU868InitDefaults+0x8e>
 803734c:	20005728 	.word	0x20005728
 8037350:	0803bb2c 	.word	0x0803bb2c

08037354 <RegionEU868Verify>:

bool RegionEU868Verify( VerifyParams_t* verify, PhyAttribute_t phyAttribute )
{
 8037354:	b507      	push	{r0, r1, r2, lr}
 8037356:	290f      	cmp	r1, #15
 8037358:	d809      	bhi.n	803736e <RegionEU868Verify+0x1a>
 803735a:	e8df f001 	tbb	[pc, r1]
 803735e:	080c      	.short	0x080c
 8037360:	1f080808 	.word	0x1f080808
 8037364:	1f081f15 	.word	0x1f081f15
 8037368:	0808081f 	.word	0x0808081f
 803736c:	2108      	.short	0x2108
            // Remark: switched min and max!
            return RegionCommonValueInRange( verify->TxPower, EU868_MAX_TX_POWER, EU868_MIN_TX_POWER );
        }
        case PHY_DUTY_CYCLE:
        {
            return EU868_DUTY_CYCLE_ENABLED;
 803736e:	2000      	movs	r0, #0
            return false;
    }
#else
    return false;
#endif /* REGION_EU868 */
}
 8037370:	b003      	add	sp, #12
 8037372:	f85d fb04 	ldr.w	pc, [sp], #4
            uint8_t band = 0;
 8037376:	2300      	movs	r3, #0
            return VerifyRfFreq( verify->Frequency, &band );
 8037378:	f10d 0107 	add.w	r1, sp, #7
 803737c:	6800      	ldr	r0, [r0, #0]
            uint8_t band = 0;
 803737e:	f88d 3007 	strb.w	r3, [sp, #7]
            return VerifyRfFreq( verify->Frequency, &band );
 8037382:	f7ff fe7f 	bl	8037084 <VerifyRfFreq>
 8037386:	e7f3      	b.n	8037370 <RegionEU868Verify+0x1c>
            return RegionCommonValueInRange( verify->DatarateParams.Datarate, DR_0, DR_5 );
 8037388:	2205      	movs	r2, #5
 803738a:	f990 0000 	ldrsb.w	r0, [r0]
 803738e:	2100      	movs	r1, #0
 8037390:	f7ff fb43 	bl	8036a1a <RegionCommonValueInRange>
 8037394:	3800      	subs	r0, #0
 8037396:	bf18      	it	ne
 8037398:	2001      	movne	r0, #1
 803739a:	e7e9      	b.n	8037370 <RegionEU868Verify+0x1c>
            return RegionCommonValueInRange( verify->TxPower, EU868_MAX_TX_POWER, EU868_MIN_TX_POWER );
 803739c:	2207      	movs	r2, #7
 803739e:	e7f4      	b.n	803738a <RegionEU868Verify+0x36>
            return EU868_DUTY_CYCLE_ENABLED;
 80373a0:	2001      	movs	r0, #1
 80373a2:	e7e5      	b.n	8037370 <RegionEU868Verify+0x1c>

080373a4 <RegionEU868ChanMaskSet>:
    }
#endif /* REGION_EU868 */
}

bool RegionEU868ChanMaskSet( ChanMaskSetParams_t* chanMaskSet )
{
 80373a4:	b510      	push	{r4, lr}
#if defined( REGION_EU868 )
    switch( chanMaskSet->ChannelsMaskType )
 80373a6:	7904      	ldrb	r4, [r0, #4]
 80373a8:	b11c      	cbz	r4, 80373b2 <RegionEU868ChanMaskSet+0xe>
 80373aa:	2c01      	cmp	r4, #1
 80373ac:	d00b      	beq.n	80373c6 <RegionEU868ChanMaskSet+0x22>
 80373ae:	2000      	movs	r0, #0
    }
    return true;
#else
    return false;
#endif /* REGION_EU868 */
}
 80373b0:	bd10      	pop	{r4, pc}
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, chanMaskSet->ChannelsMaskIn, CHANNELS_MASK_SIZE );
 80373b2:	4b0a      	ldr	r3, [pc, #40]	; (80373dc <RegionEU868ChanMaskSet+0x38>)
 80373b4:	6801      	ldr	r1, [r0, #0]
 80373b6:	681b      	ldr	r3, [r3, #0]
 80373b8:	2201      	movs	r2, #1
 80373ba:	f503 7058 	add.w	r0, r3, #864	; 0x360
 80373be:	f7ff fb6c 	bl	8036a9a <RegionCommonChanMaskCopy>
    return true;
 80373c2:	2001      	movs	r0, #1
            break;
 80373c4:	e7f4      	b.n	80373b0 <RegionEU868ChanMaskSet+0xc>
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsDefaultMask, chanMaskSet->ChannelsMaskIn, CHANNELS_MASK_SIZE );
 80373c6:	4b05      	ldr	r3, [pc, #20]	; (80373dc <RegionEU868ChanMaskSet+0x38>)
 80373c8:	6801      	ldr	r1, [r0, #0]
 80373ca:	681b      	ldr	r3, [r3, #0]
 80373cc:	4622      	mov	r2, r4
 80373ce:	f503 705b 	add.w	r0, r3, #876	; 0x36c
 80373d2:	f7ff fb62 	bl	8036a9a <RegionCommonChanMaskCopy>
    return true;
 80373d6:	4620      	mov	r0, r4
            break;
 80373d8:	e7ea      	b.n	80373b0 <RegionEU868ChanMaskSet+0xc>
 80373da:	bf00      	nop
 80373dc:	20005728 	.word	0x20005728

080373e0 <RegionEU868ComputeRxWindowParameters>:

void RegionEU868ComputeRxWindowParameters( int8_t datarate, uint8_t minRxSymbols, uint32_t rxError, RxConfigParams_t *rxConfigParams )
{
 80373e0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
#if defined( REGION_EU868 )
    uint32_t tSymbolInUs = 0;

    // Get the datarate, perform a boundary check
    rxConfigParams->Datarate = MIN( datarate, EU868_RX_MAX_DATARATE );
 80373e2:	2807      	cmp	r0, #7
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsEU868 );
 80373e4:	4d15      	ldr	r5, [pc, #84]	; (803743c <RegionEU868ComputeRxWindowParameters+0x5c>)
{
 80373e6:	461c      	mov	r4, r3
    rxConfigParams->Datarate = MIN( datarate, EU868_RX_MAX_DATARATE );
 80373e8:	bfa8      	it	ge
 80373ea:	2007      	movge	r0, #7
 80373ec:	7058      	strb	r0, [r3, #1]
{
 80373ee:	460e      	mov	r6, r1
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsEU868 );
 80373f0:	f105 0108 	add.w	r1, r5, #8
{
 80373f4:	4617      	mov	r7, r2
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsEU868 );
 80373f6:	f7ff fdcf 	bl	8036f98 <RegionCommonGetBandwidth>

    if( rxConfigParams->Datarate == DR_7 )
 80373fa:	f994 3001 	ldrsb.w	r3, [r4, #1]
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsEU868 );
 80373fe:	70a0      	strb	r0, [r4, #2]
    if( rxConfigParams->Datarate == DR_7 )
 8037400:	2b07      	cmp	r3, #7
 8037402:	d113      	bne.n	803742c <RegionEU868ComputeRxWindowParameters+0x4c>
    { // FSK
        tSymbolInUs = RegionCommonComputeSymbolTimeFsk( DataratesEU868[rxConfigParams->Datarate] );
 8037404:	2032      	movs	r0, #50	; 0x32
 8037406:	f7ff fccb 	bl	8036da0 <RegionCommonComputeSymbolTimeFsk>
    else
    { // LoRa
        tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesEU868[rxConfigParams->Datarate], BandwidthsEU868[rxConfigParams->Datarate] );
    }

    RegionCommonComputeRxWindowParameters( tSymbolInUs, minRxSymbols, rxError, Radio.GetWakeupTime( ), &rxConfigParams->WindowTimeout, &rxConfigParams->WindowOffset );
 803740a:	4b0d      	ldr	r3, [pc, #52]	; (8037440 <RegionEU868ComputeRxWindowParameters+0x60>)
 803740c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
        tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesEU868[rxConfigParams->Datarate], BandwidthsEU868[rxConfigParams->Datarate] );
 803740e:	4605      	mov	r5, r0
    RegionCommonComputeRxWindowParameters( tSymbolInUs, minRxSymbols, rxError, Radio.GetWakeupTime( ), &rxConfigParams->WindowTimeout, &rxConfigParams->WindowOffset );
 8037410:	4798      	blx	r3
 8037412:	f104 020c 	add.w	r2, r4, #12
 8037416:	3408      	adds	r4, #8
 8037418:	4603      	mov	r3, r0
 803741a:	9201      	str	r2, [sp, #4]
 803741c:	9400      	str	r4, [sp, #0]
 803741e:	463a      	mov	r2, r7
 8037420:	4631      	mov	r1, r6
 8037422:	4628      	mov	r0, r5
 8037424:	f7ff fcc1 	bl	8036daa <RegionCommonComputeRxWindowParameters>
#endif /* REGION_EU868 */
}
 8037428:	b003      	add	sp, #12
 803742a:	bdf0      	pop	{r4, r5, r6, r7, pc}
        tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesEU868[rxConfigParams->Datarate], BandwidthsEU868[rxConfigParams->Datarate] );
 803742c:	eb05 0283 	add.w	r2, r5, r3, lsl #2
 8037430:	5ce8      	ldrb	r0, [r5, r3]
 8037432:	6891      	ldr	r1, [r2, #8]
 8037434:	f7ff fcac 	bl	8036d90 <RegionCommonComputeSymbolTimeLoRa>
 8037438:	e7e7      	b.n	803740a <RegionEU868ComputeRxWindowParameters+0x2a>
 803743a:	bf00      	nop
 803743c:	0803baf4 	.word	0x0803baf4
 8037440:	0803bc30 	.word	0x0803bc30

08037444 <RegionEU868RxConfig>:

bool RegionEU868RxConfig( RxConfigParams_t* rxConfig, int8_t* datarate )
{
 8037444:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int8_t dr = rxConfig->Datarate;
    uint8_t maxPayload = 0;
    int8_t phyDr = 0;
    uint32_t frequency = rxConfig->Frequency;

    if( Radio.GetStatus( ) != RF_IDLE )
 8037448:	4e39      	ldr	r6, [pc, #228]	; (8037530 <RegionEU868RxConfig+0xec>)
    int8_t dr = rxConfig->Datarate;
 803744a:	f990 7001 	ldrsb.w	r7, [r0, #1]
    if( Radio.GetStatus( ) != RF_IDLE )
 803744e:	6873      	ldr	r3, [r6, #4]
    uint32_t frequency = rxConfig->Frequency;
 8037450:	f8d0 9004 	ldr.w	r9, [r0, #4]
{
 8037454:	b08d      	sub	sp, #52	; 0x34
 8037456:	4604      	mov	r4, r0
 8037458:	468a      	mov	sl, r1
    if( Radio.GetStatus( ) != RF_IDLE )
 803745a:	4798      	blx	r3
 803745c:	46b0      	mov	r8, r6
 803745e:	4605      	mov	r5, r0
 8037460:	2800      	cmp	r0, #0
 8037462:	d163      	bne.n	803752c <RegionEU868RxConfig+0xe8>
    {
        return false;
    }

    if( rxConfig->RxSlot == RX_SLOT_WIN_1 )
 8037464:	7ce3      	ldrb	r3, [r4, #19]
 8037466:	b963      	cbnz	r3, 8037482 <RegionEU868RxConfig+0x3e>
    {
        // Apply window 1 frequency
        frequency = RegionNvmGroup2->Channels[rxConfig->Channel].Frequency;
 8037468:	4a32      	ldr	r2, [pc, #200]	; (8037534 <RegionEU868RxConfig+0xf0>)
 803746a:	7823      	ldrb	r3, [r4, #0]
 803746c:	6812      	ldr	r2, [r2, #0]
 803746e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8037472:	eb02 0183 	add.w	r1, r2, r3, lsl #2
 8037476:	f852 9023 	ldr.w	r9, [r2, r3, lsl #2]
        // Apply the alternative RX 1 window frequency, if it is available
        if( RegionNvmGroup2->Channels[rxConfig->Channel].Rx1Frequency != 0 )
 803747a:	684b      	ldr	r3, [r1, #4]
 803747c:	2b00      	cmp	r3, #0
 803747e:	bf18      	it	ne
 8037480:	4699      	movne	r9, r3
            frequency = RegionNvmGroup2->Channels[rxConfig->Channel].Rx1Frequency;
        }
    }

    // Read the physical datarate from the datarates table
    phyDr = DataratesEU868[dr];
 8037482:	4e2d      	ldr	r6, [pc, #180]	; (8037538 <RegionEU868RxConfig+0xf4>)

    Radio.SetChannel( frequency );
 8037484:	f8d8 300c 	ldr.w	r3, [r8, #12]
    phyDr = DataratesEU868[dr];
 8037488:	f916 b007 	ldrsb.w	fp, [r6, r7]
    Radio.SetChannel( frequency );
 803748c:	4648      	mov	r0, r9
 803748e:	4798      	blx	r3

    // Radio configuration
    if( dr == DR_7 )
 8037490:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8037494:	68a0      	ldr	r0, [r4, #8]
 8037496:	960b      	str	r6, [sp, #44]	; 0x2c
 8037498:	469c      	mov	ip, r3
 803749a:	2f07      	cmp	r7, #7
 803749c:	7ca3      	ldrb	r3, [r4, #18]
    {
        modem = MODEM_FSK;
        Radio.SetRxConfig( modem, 50000, phyDr * 1000, 0, 83333, 5, rxConfig->WindowTimeout, false, 0, true, 0, 0, false, rxConfig->RxContinuous );
 803749e:	9309      	str	r3, [sp, #36]	; 0x24
    if( dr == DR_7 )
 80374a0:	d12d      	bne.n	80374fe <RegionEU868RxConfig+0xba>
        Radio.SetRxConfig( modem, 50000, phyDr * 1000, 0, 83333, 5, rxConfig->WindowTimeout, false, 0, true, 0, 0, false, rxConfig->RxContinuous );
 80374a2:	2300      	movs	r3, #0
 80374a4:	2101      	movs	r1, #1
 80374a6:	e9cd 3104 	strd	r3, r1, [sp, #16]
 80374aa:	4924      	ldr	r1, [pc, #144]	; (803753c <RegionEU868RxConfig+0xf8>)
 80374ac:	9306      	str	r3, [sp, #24]
 80374ae:	2205      	movs	r2, #5
 80374b0:	e9cd 3307 	strd	r3, r3, [sp, #28]
 80374b4:	e9cd 1200 	strd	r1, r2, [sp]
 80374b8:	b280      	uxth	r0, r0
 80374ba:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80374be:	9002      	str	r0, [sp, #8]
 80374c0:	9303      	str	r3, [sp, #12]
 80374c2:	fb02 f20b 	mul.w	r2, r2, fp
 80374c6:	f24c 3150 	movw	r1, #50000	; 0xc350
 80374ca:	4618      	mov	r0, r3
    }
    else
    {
        modem = MODEM_LORA;
        Radio.SetRxConfig( modem, rxConfig->Bandwidth, phyDr, 1, 0, 8, rxConfig->WindowTimeout, false, 0, false, 0, 0, true, rxConfig->RxContinuous );
 80374cc:	4666      	mov	r6, ip
 80374ce:	47b0      	blx	r6
    }

    /* ST_WORKAROUND_BEGIN: Keep repeater feature */
    if( rxConfig->RepeaterSupport == true )
 80374d0:	7c63      	ldrb	r3, [r4, #17]
 80374d2:	b333      	cbz	r3, 8037522 <RegionEU868RxConfig+0xde>
    {
        maxPayload = MaxPayloadOfDatarateRepeaterEU868[dr];
 80374d4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80374d6:	443b      	add	r3, r7
 80374d8:	f893 1030 	ldrb.w	r1, [r3, #48]	; 0x30
    else
    {
        maxPayload = MaxPayloadOfDatarateEU868[dr];
    }

    Radio.SetMaxPayloadLength( modem, maxPayload + LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE );
 80374dc:	f8d8 3054 	ldr.w	r3, [r8, #84]	; 0x54
 80374e0:	310d      	adds	r1, #13
 80374e2:	b2c9      	uxtb	r1, r1
 80374e4:	4628      	mov	r0, r5
 80374e6:	4798      	blx	r3
    /* ST_WORKAROUND_END */

    /* ST_WORKAROUND_BEGIN: Print Rx config */
    RegionCommonRxConfigPrint(rxConfig->RxSlot, frequency, dr);
 80374e8:	7ce0      	ldrb	r0, [r4, #19]
 80374ea:	463a      	mov	r2, r7
 80374ec:	4649      	mov	r1, r9
 80374ee:	f7ff fd65 	bl	8036fbc <RegionCommonRxConfigPrint>
    /* ST_WORKAROUND_END */

    *datarate = (uint8_t) dr;
 80374f2:	f88a 7000 	strb.w	r7, [sl]
    return true;
 80374f6:	2001      	movs	r0, #1
#else
    return false;
#endif /* REGION_EU868 */
}
 80374f8:	b00d      	add	sp, #52	; 0x34
 80374fa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        Radio.SetRxConfig( modem, rxConfig->Bandwidth, phyDr, 1, 0, 8, rxConfig->WindowTimeout, false, 0, false, 0, 0, true, rxConfig->RxContinuous );
 80374fe:	2100      	movs	r1, #0
 8037500:	2501      	movs	r5, #1
 8037502:	b280      	uxth	r0, r0
 8037504:	2308      	movs	r3, #8
 8037506:	e9cd 1300 	strd	r1, r3, [sp]
 803750a:	e9cd 1507 	strd	r1, r5, [sp, #28]
 803750e:	e9cd 1105 	strd	r1, r1, [sp, #20]
 8037512:	e9cd 1103 	strd	r1, r1, [sp, #12]
 8037516:	9002      	str	r0, [sp, #8]
 8037518:	78a1      	ldrb	r1, [r4, #2]
 803751a:	462b      	mov	r3, r5
 803751c:	465a      	mov	r2, fp
 803751e:	4628      	mov	r0, r5
 8037520:	e7d4      	b.n	80374cc <RegionEU868RxConfig+0x88>
        maxPayload = MaxPayloadOfDatarateEU868[dr];
 8037522:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8037524:	443b      	add	r3, r7
 8037526:	f893 1028 	ldrb.w	r1, [r3, #40]	; 0x28
 803752a:	e7d7      	b.n	80374dc <RegionEU868RxConfig+0x98>
        return false;
 803752c:	2000      	movs	r0, #0
 803752e:	e7e3      	b.n	80374f8 <RegionEU868RxConfig+0xb4>
 8037530:	0803bc30 	.word	0x0803bc30
 8037534:	20005728 	.word	0x20005728
 8037538:	0803baf4 	.word	0x0803baf4
 803753c:	00014585 	.word	0x00014585

08037540 <RegionEU868TxConfig>:

bool RegionEU868TxConfig( TxConfigParams_t* txConfig, int8_t* txPower, TimerTime_t* txTimeOnAir )
{
 8037540:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if defined( REGION_EU868 )
    RadioModems_t modem;
    int8_t phyDr = DataratesEU868[txConfig->Datarate];
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
 8037544:	4f3d      	ldr	r7, [pc, #244]	; (803763c <RegionEU868TxConfig+0xfc>)
    int8_t phyDr = DataratesEU868[txConfig->Datarate];
 8037546:	f990 3001 	ldrsb.w	r3, [r0, #1]
 803754a:	4e3d      	ldr	r6, [pc, #244]	; (8037640 <RegionEU868TxConfig+0x100>)
{
 803754c:	b08f      	sub	sp, #60	; 0x3c
 803754e:	e9cd 120b 	strd	r1, r2, [sp, #44]	; 0x2c
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
 8037552:	e9d7 1200 	ldrd	r1, r2, [r7]
{
 8037556:	4604      	mov	r4, r0
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
 8037558:	7800      	ldrb	r0, [r0, #0]
    int8_t phyDr = DataratesEU868[txConfig->Datarate];
 803755a:	56f3      	ldrsb	r3, [r6, r3]
 803755c:	930d      	str	r3, [sp, #52]	; 0x34
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
 803755e:	250c      	movs	r5, #12
 8037560:	fb05 1100 	mla	r1, r5, r0, r1
 8037564:	2018      	movs	r0, #24
 8037566:	7a49      	ldrb	r1, [r1, #9]
 8037568:	fb00 2201 	mla	r2, r0, r1, r2
 803756c:	f994 0002 	ldrsb.w	r0, [r4, #2]
 8037570:	f992 1002 	ldrsb.w	r1, [r2, #2]
 8037574:	f7ff fd0c 	bl	8036f90 <RegionCommonLimitTxPower>
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsEU868 );
 8037578:	f106 0108 	add.w	r1, r6, #8
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
 803757c:	4681      	mov	r9, r0
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsEU868 );
 803757e:	f994 0001 	ldrsb.w	r0, [r4, #1]
 8037582:	f7ff fd09 	bl	8036f98 <RegionCommonGetBandwidth>
    int8_t phyTxPower = 0;

    // Calculate physical TX power
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, txConfig->MaxEirp, txConfig->AntennaGain );
 8037586:	68a2      	ldr	r2, [r4, #8]
 8037588:	6861      	ldr	r1, [r4, #4]
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsEU868 );
 803758a:	4683      	mov	fp, r0
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, txConfig->MaxEirp, txConfig->AntennaGain );
 803758c:	4648      	mov	r0, r9
 803758e:	f7ff fc34 	bl	8036dfa <RegionCommonComputeTxPower>
 8037592:	4682      	mov	sl, r0

    // Setup the radio frequency
    Radio.SetChannel( RegionNvmGroup2->Channels[txConfig->Channel].Frequency );
 8037594:	7820      	ldrb	r0, [r4, #0]
 8037596:	6839      	ldr	r1, [r7, #0]
 8037598:	4368      	muls	r0, r5
 803759a:	4d2a      	ldr	r5, [pc, #168]	; (8037644 <RegionEU868TxConfig+0x104>)
 803759c:	5808      	ldr	r0, [r1, r0]
 803759e:	68ea      	ldr	r2, [r5, #12]
 80375a0:	4790      	blx	r2

    if( txConfig->Datarate == DR_7 )
 80375a2:	f994 2001 	ldrsb.w	r2, [r4, #1]
 80375a6:	69eb      	ldr	r3, [r5, #28]
 80375a8:	2a07      	cmp	r2, #7
 80375aa:	46a8      	mov	r8, r5
 80375ac:	f44f 627a 	mov.w	r2, #4000	; 0xfa0
 80375b0:	f04f 0500 	mov.w	r5, #0
 80375b4:	469c      	mov	ip, r3
    { // High Speed FSK channel
        modem = MODEM_FSK;
        Radio.SetTxConfig( modem, phyTxPower, 25000, bandwidth, phyDr * 1000, 0, 5, false, true, 0, 0, false, 4000 );
 80375b6:	e9cd 5207 	strd	r5, r2, [sp, #28]
 80375ba:	e9cd 5505 	strd	r5, r5, [sp, #20]
    if( txConfig->Datarate == DR_7 )
 80375be:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80375c0:	d12c      	bne.n	803761c <RegionEU868TxConfig+0xdc>
        Radio.SetTxConfig( modem, phyTxPower, 25000, bandwidth, phyDr * 1000, 0, 5, false, true, 0, 0, false, 4000 );
 80375c2:	2201      	movs	r2, #1
 80375c4:	e9cd 5203 	strd	r5, r2, [sp, #12]
 80375c8:	2205      	movs	r2, #5
 80375ca:	e9cd 5201 	strd	r5, r2, [sp, #4]
 80375ce:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80375d2:	4353      	muls	r3, r2
 80375d4:	9300      	str	r3, [sp, #0]
 80375d6:	f246 12a8 	movw	r2, #25000	; 0x61a8
 80375da:	465b      	mov	r3, fp
 80375dc:	4651      	mov	r1, sl
 80375de:	4628      	mov	r0, r5
 80375e0:	4666      	mov	r6, ip
 80375e2:	47b0      	blx	r6
    {
        modem = MODEM_LORA;
        Radio.SetTxConfig( modem, phyTxPower, 0, bandwidth, phyDr, 1, 8, false, true, 0, 0, false, 4000 );
    }
    /* ST_WORKAROUND_BEGIN: Print Tx config */
    RegionCommonTxConfigPrint(RegionNvmGroup2->Channels[txConfig->Channel].Frequency, txConfig->Datarate);
 80375e4:	7821      	ldrb	r1, [r4, #0]
 80375e6:	683a      	ldr	r2, [r7, #0]
 80375e8:	230c      	movs	r3, #12
 80375ea:	434b      	muls	r3, r1
 80375ec:	f994 1001 	ldrsb.w	r1, [r4, #1]
 80375f0:	58d0      	ldr	r0, [r2, r3]
 80375f2:	f7ff fd11 	bl	8037018 <RegionCommonTxConfigPrint>
    /* ST_WORKAROUND_END */

    // Update time-on-air
    *txTimeOnAir = GetTimeOnAir( txConfig->Datarate, txConfig->PktLen );
 80375f6:	89a1      	ldrh	r1, [r4, #12]
 80375f8:	f994 0001 	ldrsb.w	r0, [r4, #1]
 80375fc:	f7ff fd1a 	bl	8037034 <GetTimeOnAir>
 8037600:	9b0c      	ldr	r3, [sp, #48]	; 0x30

    // Setup maximum payload length of the radio driver
    Radio.SetMaxPayloadLength( modem, txConfig->PktLen );
 8037602:	7b21      	ldrb	r1, [r4, #12]
    *txTimeOnAir = GetTimeOnAir( txConfig->Datarate, txConfig->PktLen );
 8037604:	6018      	str	r0, [r3, #0]
    Radio.SetMaxPayloadLength( modem, txConfig->PktLen );
 8037606:	f8d8 3054 	ldr.w	r3, [r8, #84]	; 0x54
 803760a:	4628      	mov	r0, r5
 803760c:	4798      	blx	r3

    *txPower = txPowerLimited;
 803760e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    return true;
#else
    return false;
#endif /* REGION_EU868 */
}
 8037610:	2001      	movs	r0, #1
    *txPower = txPowerLimited;
 8037612:	f883 9000 	strb.w	r9, [r3]
}
 8037616:	b00f      	add	sp, #60	; 0x3c
 8037618:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        Radio.SetTxConfig( modem, phyTxPower, 0, bandwidth, phyDr, 1, 8, false, true, 0, 0, false, 4000 );
 803761c:	2601      	movs	r6, #1
 803761e:	2208      	movs	r2, #8
 8037620:	e9cd 5603 	strd	r5, r6, [sp, #12]
 8037624:	e9cd 6201 	strd	r6, r2, [sp, #4]
 8037628:	9300      	str	r3, [sp, #0]
 803762a:	462a      	mov	r2, r5
 803762c:	465b      	mov	r3, fp
 803762e:	4665      	mov	r5, ip
 8037630:	4651      	mov	r1, sl
 8037632:	4630      	mov	r0, r6
 8037634:	47a8      	blx	r5
        modem = MODEM_LORA;
 8037636:	4635      	mov	r5, r6
 8037638:	e7d4      	b.n	80375e4 <RegionEU868TxConfig+0xa4>
 803763a:	bf00      	nop
 803763c:	20005728 	.word	0x20005728
 8037640:	0803baf4 	.word	0x0803baf4
 8037644:	0803bc30 	.word	0x0803bc30

08037648 <RegionEU868LinkAdrReq>:

uint8_t RegionEU868LinkAdrReq( LinkAdrReqParams_t* linkAdrReq, int8_t* drOut, int8_t* txPowOut, uint8_t* nbRepOut, uint8_t* nbBytesParsed )
{
 8037648:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 803764c:	b08d      	sub	sp, #52	; 0x34
    uint8_t status = 0x07;
#if defined( REGION_EU868 )
    RegionCommonLinkAdrParams_t linkAdrParams = { 0 };
 803764e:	2400      	movs	r4, #0
{
 8037650:	4605      	mov	r5, r0
 8037652:	468a      	mov	sl, r1
 8037654:	4691      	mov	r9, r2
 8037656:	4698      	mov	r8, r3
    RegionCommonLinkAdrParams_t linkAdrParams = { 0 };
 8037658:	9402      	str	r4, [sp, #8]
 803765a:	f8ad 400c 	strh.w	r4, [sp, #12]
    uint8_t nextIndex = 0;
    uint8_t bytesProcessed = 0;
    uint16_t chMask = 0;
 803765e:	f8ad 4006 	strh.w	r4, [sp, #6]
    uint8_t status = 0x07;
 8037662:	2607      	movs	r6, #7
            {
                if( linkAdrParams.ChMaskCtrl == 6 )
                {
                    if( RegionNvmGroup2->Channels[i].Frequency != 0 )
                    {
                        chMask |= 1 << i;
 8037664:	f04f 0b01 	mov.w	fp, #1
    while( bytesProcessed < linkAdrReq->PayloadSize )
 8037668:	7a2b      	ldrb	r3, [r5, #8]
 803766a:	42a3      	cmp	r3, r4
 803766c:	d906      	bls.n	803767c <RegionEU868LinkAdrReq+0x34>
        nextIndex = RegionCommonParseLinkAdrReq( &( linkAdrReq->Payload[bytesProcessed] ), &linkAdrParams );
 803766e:	6868      	ldr	r0, [r5, #4]
 8037670:	a902      	add	r1, sp, #8
 8037672:	4420      	add	r0, r4
 8037674:	f7ff fb32 	bl	8036cdc <RegionCommonParseLinkAdrReq>
        if( nextIndex == 0 )
 8037678:	2800      	cmp	r0, #0
 803767a:	d154      	bne.n	8037726 <RegionEU868LinkAdrReq+0xde>
    getPhy.Attribute = PHY_MIN_TX_DR;
    getPhy.UplinkDwellTime = linkAdrReq->UplinkDwellTime;
    phyParam = RegionEU868GetPhyParam( &getPhy );

    linkAdrVerifyParams.Status = status;
    linkAdrVerifyParams.AdrEnabled = linkAdrReq->AdrEnabled;
 803767c:	7aab      	ldrb	r3, [r5, #10]
 803767e:	f88d 3015 	strb.w	r3, [sp, #21]
    linkAdrVerifyParams.Datarate = linkAdrParams.Datarate;
 8037682:	f89d 3009 	ldrb.w	r3, [sp, #9]
 8037686:	f88d 3016 	strb.w	r3, [sp, #22]
    linkAdrVerifyParams.TxPower = linkAdrParams.TxPower;
 803768a:	f89d 300a 	ldrb.w	r3, [sp, #10]
 803768e:	f88d 3017 	strb.w	r3, [sp, #23]
    linkAdrVerifyParams.NbRep = linkAdrParams.NbRep;
 8037692:	f89d 3008 	ldrb.w	r3, [sp, #8]
 8037696:	f88d 3018 	strb.w	r3, [sp, #24]
    linkAdrVerifyParams.CurrentDatarate = linkAdrReq->CurrentDatarate;
 803769a:	7aeb      	ldrb	r3, [r5, #11]
 803769c:	f88d 3019 	strb.w	r3, [sp, #25]
    linkAdrVerifyParams.CurrentTxPower = linkAdrReq->CurrentTxPower;
 80376a0:	7b2b      	ldrb	r3, [r5, #12]
 80376a2:	f88d 301a 	strb.w	r3, [sp, #26]
    linkAdrVerifyParams.CurrentNbRep = linkAdrReq->CurrentNbRep;
 80376a6:	7b6b      	ldrb	r3, [r5, #13]
 80376a8:	f88d 301b 	strb.w	r3, [sp, #27]
    linkAdrVerifyParams.NbChannels = EU868_MAX_NB_CHANNELS;
 80376ac:	2310      	movs	r3, #16
    linkAdrVerifyParams.Status = status;
 80376ae:	f88d 6014 	strb.w	r6, [sp, #20]
    linkAdrVerifyParams.NbChannels = EU868_MAX_NB_CHANNELS;
 80376b2:	f88d 301c 	strb.w	r3, [sp, #28]
    linkAdrVerifyParams.ChannelsMask = &chMask;
    linkAdrVerifyParams.MinDatarate = ( int8_t )phyParam.Value;
    linkAdrVerifyParams.MaxDatarate = EU868_TX_MAX_DATARATE;
    linkAdrVerifyParams.Channels = RegionNvmGroup2->Channels;
 80376b6:	4e3a      	ldr	r6, [pc, #232]	; (80377a0 <RegionEU868LinkAdrReq+0x158>)
    linkAdrVerifyParams.ChannelsMask = &chMask;
 80376b8:	f10d 0306 	add.w	r3, sp, #6
 80376bc:	9308      	str	r3, [sp, #32]
    linkAdrVerifyParams.MinDatarate = ( int8_t )phyParam.Value;
 80376be:	f44f 63e0 	mov.w	r3, #1792	; 0x700
 80376c2:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
    linkAdrVerifyParams.Channels = RegionNvmGroup2->Channels;
 80376c6:	6833      	ldr	r3, [r6, #0]
 80376c8:	930a      	str	r3, [sp, #40]	; 0x28
    linkAdrVerifyParams.MinTxPower = EU868_MIN_TX_POWER;
 80376ca:	2307      	movs	r3, #7
 80376cc:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
    linkAdrVerifyParams.MaxTxPower = EU868_MAX_TX_POWER;
    linkAdrVerifyParams.Version = linkAdrReq->Version;
 80376d0:	682b      	ldr	r3, [r5, #0]
 80376d2:	9304      	str	r3, [sp, #16]

    // Verify the parameters and update, if necessary
    status = RegionCommonLinkAdrReqVerifyParams( &linkAdrVerifyParams, &linkAdrParams.Datarate, &linkAdrParams.TxPower, &linkAdrParams.NbRep );
 80376d4:	f10d 020a 	add.w	r2, sp, #10
 80376d8:	ab02      	add	r3, sp, #8
 80376da:	f10d 0109 	add.w	r1, sp, #9
 80376de:	a804      	add	r0, sp, #16
 80376e0:	f7ff fb16 	bl	8036d10 <RegionCommonLinkAdrReqVerifyParams>

    // Update channelsMask if everything is correct
    if( status == 0x07 )
 80376e4:	2807      	cmp	r0, #7
    status = RegionCommonLinkAdrReqVerifyParams( &linkAdrVerifyParams, &linkAdrParams.Datarate, &linkAdrParams.TxPower, &linkAdrParams.NbRep );
 80376e6:	4605      	mov	r5, r0
    if( status == 0x07 )
 80376e8:	d10b      	bne.n	8037702 <RegionEU868LinkAdrReq+0xba>
    {
        // Set the channels mask to a default value
        memset1( ( uint8_t* ) RegionNvmGroup2->ChannelsMask, 0, sizeof( RegionNvmGroup2->ChannelsMask ) );
 80376ea:	6830      	ldr	r0, [r6, #0]
 80376ec:	220c      	movs	r2, #12
 80376ee:	2100      	movs	r1, #0
 80376f0:	f500 7058 	add.w	r0, r0, #864	; 0x360
 80376f4:	f001 fc2e 	bl	8038f54 <memset1>
        // Update the channels mask
        RegionNvmGroup2->ChannelsMask[0] = chMask;
 80376f8:	6833      	ldr	r3, [r6, #0]
 80376fa:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 80376fe:	f8a3 2360 	strh.w	r2, [r3, #864]	; 0x360
    }

    // Update status variables
    *drOut = linkAdrParams.Datarate;
 8037702:	f89d 3009 	ldrb.w	r3, [sp, #9]
 8037706:	f88a 3000 	strb.w	r3, [sl]
    *txPowOut = linkAdrParams.TxPower;
 803770a:	f89d 300a 	ldrb.w	r3, [sp, #10]
 803770e:	f889 3000 	strb.w	r3, [r9]
    *nbRepOut = linkAdrParams.NbRep;
 8037712:	f89d 3008 	ldrb.w	r3, [sp, #8]
 8037716:	f888 3000 	strb.w	r3, [r8]
    *nbBytesParsed = bytesProcessed;
 803771a:	9b16      	ldr	r3, [sp, #88]	; 0x58

#endif /* REGION_EU868 */
    return status;
}
 803771c:	4628      	mov	r0, r5
    *nbBytesParsed = bytesProcessed;
 803771e:	701c      	strb	r4, [r3, #0]
}
 8037720:	b00d      	add	sp, #52	; 0x34
 8037722:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if( ( linkAdrParams.ChMaskCtrl == 0 ) && ( chMask == 0 ) )
 8037726:	f89d 300b 	ldrb.w	r3, [sp, #11]
        chMask = linkAdrParams.ChMask;
 803772a:	f8bd 700c 	ldrh.w	r7, [sp, #12]
 803772e:	f8ad 7006 	strh.w	r7, [sp, #6]
        bytesProcessed += nextIndex;
 8037732:	4404      	add	r4, r0
 8037734:	b2e4      	uxtb	r4, r4
        if( ( linkAdrParams.ChMaskCtrl == 0 ) && ( chMask == 0 ) )
 8037736:	b9f3      	cbnz	r3, 8037776 <RegionEU868LinkAdrReq+0x12e>
 8037738:	b317      	cbz	r7, 8037780 <RegionEU868LinkAdrReq+0x138>
                        ( RegionNvmGroup2->Channels[i].Frequency == 0 ) )
 803773a:	4a19      	ldr	r2, [pc, #100]	; (80377a0 <RegionEU868LinkAdrReq+0x158>)
 803773c:	2000      	movs	r0, #0
 803773e:	6811      	ldr	r1, [r2, #0]
 8037740:	2607      	movs	r6, #7
 8037742:	4602      	mov	r2, r0
 8037744:	f04f 0c0c 	mov.w	ip, #12
                if( linkAdrParams.ChMaskCtrl == 6 )
 8037748:	2b06      	cmp	r3, #6
 803774a:	d11b      	bne.n	8037784 <RegionEU868LinkAdrReq+0x13c>
                    if( RegionNvmGroup2->Channels[i].Frequency != 0 )
 803774c:	fb0c fe00 	mul.w	lr, ip, r0
 8037750:	f851 e00e 	ldr.w	lr, [r1, lr]
 8037754:	f1be 0f00 	cmp.w	lr, #0
 8037758:	d004      	beq.n	8037764 <RegionEU868LinkAdrReq+0x11c>
                        chMask |= 1 << i;
 803775a:	fa0b f200 	lsl.w	r2, fp, r0
 803775e:	4317      	orrs	r7, r2
 8037760:	b2bf      	uxth	r7, r7
 8037762:	2201      	movs	r2, #1
            for( uint8_t i = 0; i < EU868_MAX_NB_CHANNELS; i++ )
 8037764:	3001      	adds	r0, #1
 8037766:	2810      	cmp	r0, #16
 8037768:	d1ee      	bne.n	8037748 <RegionEU868LinkAdrReq+0x100>
 803776a:	2a00      	cmp	r2, #0
 803776c:	f43f af7c 	beq.w	8037668 <RegionEU868LinkAdrReq+0x20>
 8037770:	f8ad 7006 	strh.w	r7, [sp, #6]
 8037774:	e778      	b.n	8037668 <RegionEU868LinkAdrReq+0x20>
        else if( ( ( linkAdrParams.ChMaskCtrl >= 1 ) && ( linkAdrParams.ChMaskCtrl <= 5 )) ||
 8037776:	1e5a      	subs	r2, r3, #1
 8037778:	2a04      	cmp	r2, #4
 803777a:	d901      	bls.n	8037780 <RegionEU868LinkAdrReq+0x138>
 803777c:	2b06      	cmp	r3, #6
 803777e:	d0dc      	beq.n	803773a <RegionEU868LinkAdrReq+0xf2>
            status &= 0xFE; // Channel mask KO
 8037780:	2606      	movs	r6, #6
 8037782:	e771      	b.n	8037668 <RegionEU868LinkAdrReq+0x20>
                    if( ( ( chMask & ( 1 << i ) ) != 0 ) &&
 8037784:	fa47 fe00 	asr.w	lr, r7, r0
 8037788:	f01e 0f01 	tst.w	lr, #1
 803778c:	d0ea      	beq.n	8037764 <RegionEU868LinkAdrReq+0x11c>
                        ( RegionNvmGroup2->Channels[i].Frequency == 0 ) )
 803778e:	fb0c fe00 	mul.w	lr, ip, r0
                    if( ( ( chMask & ( 1 << i ) ) != 0 ) &&
 8037792:	f851 e00e 	ldr.w	lr, [r1, lr]
                        status &= 0xFE; // Channel mask KO
 8037796:	f1be 0f00 	cmp.w	lr, #0
 803779a:	bf08      	it	eq
 803779c:	2606      	moveq	r6, #6
 803779e:	e7e1      	b.n	8037764 <RegionEU868LinkAdrReq+0x11c>
 80377a0:	20005728 	.word	0x20005728

080377a4 <RegionEU868RxParamSetupReq>:

uint8_t RegionEU868RxParamSetupReq( RxParamSetupReqParams_t* rxParamSetupReq )
{
 80377a4:	b573      	push	{r0, r1, r4, r5, r6, lr}
    uint8_t status = 0x07;
#if defined( REGION_EU868 )
    uint8_t band = 0;
 80377a6:	2600      	movs	r6, #0
{
 80377a8:	4605      	mov	r5, r0

    // Verify radio frequency
    if( VerifyRfFreq( rxParamSetupReq->Frequency, &band ) == false )
 80377aa:	f10d 0107 	add.w	r1, sp, #7
 80377ae:	6840      	ldr	r0, [r0, #4]
    uint8_t band = 0;
 80377b0:	f88d 6007 	strb.w	r6, [sp, #7]
    if( VerifyRfFreq( rxParamSetupReq->Frequency, &band ) == false )
 80377b4:	f7ff fc66 	bl	8037084 <VerifyRfFreq>
    {
        status &= 0xFE; // Channel frequency KO
    }

    // Verify datarate
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, EU868_RX_MIN_DATARATE, EU868_RX_MAX_DATARATE ) == false )
 80377b8:	2207      	movs	r2, #7
    if( VerifyRfFreq( rxParamSetupReq->Frequency, &band ) == false )
 80377ba:	42b0      	cmp	r0, r6
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, EU868_RX_MIN_DATARATE, EU868_RX_MAX_DATARATE ) == false )
 80377bc:	4631      	mov	r1, r6
 80377be:	f995 0000 	ldrsb.w	r0, [r5]
        status &= 0xFE; // Channel frequency KO
 80377c2:	bf14      	ite	ne
 80377c4:	2407      	movne	r4, #7
 80377c6:	2406      	moveq	r4, #6
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, EU868_RX_MIN_DATARATE, EU868_RX_MAX_DATARATE ) == false )
 80377c8:	f7ff f927 	bl	8036a1a <RegionCommonValueInRange>
 80377cc:	b908      	cbnz	r0, 80377d2 <RegionEU868RxParamSetupReq+0x2e>
    {
        status &= 0xFD; // Datarate KO
 80377ce:	f004 0405 	and.w	r4, r4, #5
    }

    // Verify datarate offset
    if( RegionCommonValueInRange( rxParamSetupReq->DrOffset, EU868_MIN_RX1_DR_OFFSET, EU868_MAX_RX1_DR_OFFSET ) == false )
 80377d2:	f995 0001 	ldrsb.w	r0, [r5, #1]
 80377d6:	2205      	movs	r2, #5
 80377d8:	2100      	movs	r1, #0
 80377da:	f7ff f91e 	bl	8036a1a <RegionCommonValueInRange>
 80377de:	b908      	cbnz	r0, 80377e4 <RegionEU868RxParamSetupReq+0x40>
    {
        status &= 0xFB; // Rx1DrOffset range KO
 80377e0:	f004 04fb 	and.w	r4, r4, #251	; 0xfb
    }

#endif /* REGION_EU868 */
    return status;
}
 80377e4:	4620      	mov	r0, r4
 80377e6:	b002      	add	sp, #8
 80377e8:	bd70      	pop	{r4, r5, r6, pc}

080377ea <RegionEU868TxParamSetupReq>:

int8_t RegionEU868TxParamSetupReq( TxParamSetupReqParams_t* txParamSetupReq )
{
    // Do not accept the request
    return -1;
}
 80377ea:	f04f 30ff 	mov.w	r0, #4294967295
 80377ee:	4770      	bx	lr

080377f0 <RegionEU868DlChannelReq>:

int8_t RegionEU868DlChannelReq( DlChannelReqParams_t* dlChannelReq )
{
 80377f0:	b513      	push	{r0, r1, r4, lr}
 80377f2:	4604      	mov	r4, r0
    uint8_t status = 0x03;
#if defined( REGION_EU868 )
    uint8_t band = 0;
 80377f4:	2300      	movs	r3, #0

    // Verify if the frequency is supported
    if( VerifyRfFreq( dlChannelReq->Rx1Frequency, &band ) == false )
 80377f6:	f10d 0107 	add.w	r1, sp, #7
 80377fa:	6840      	ldr	r0, [r0, #4]
    uint8_t band = 0;
 80377fc:	f88d 3007 	strb.w	r3, [sp, #7]
    if( VerifyRfFreq( dlChannelReq->Rx1Frequency, &band ) == false )
 8037800:	f7ff fc40 	bl	8037084 <VerifyRfFreq>
 8037804:	7823      	ldrb	r3, [r4, #0]
 8037806:	4a0b      	ldr	r2, [pc, #44]	; (8037834 <RegionEU868DlChannelReq+0x44>)
 8037808:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 803780c:	6812      	ldr	r2, [r2, #0]
 803780e:	eb02 0183 	add.w	r1, r2, r3, lsl #2
    {
        status &= 0xFE;
    }

    // Verify if an uplink frequency exists
    if( RegionNvmGroup2->Channels[dlChannelReq->ChannelId].Frequency == 0 )
 8037812:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    if( VerifyRfFreq( dlChannelReq->Rx1Frequency, &band ) == false )
 8037816:	2800      	cmp	r0, #0
        status &= 0xFE;
 8037818:	bf14      	ite	ne
 803781a:	2003      	movne	r0, #3
 803781c:	2002      	moveq	r0, #2
    if( RegionNvmGroup2->Channels[dlChannelReq->ChannelId].Frequency == 0 )
 803781e:	b91b      	cbnz	r3, 8037828 <RegionEU868DlChannelReq+0x38>
    {
        status &= 0xFD;
 8037820:	f000 0001 	and.w	r0, r0, #1
        RegionNvmGroup2->Channels[dlChannelReq->ChannelId].Rx1Frequency = dlChannelReq->Rx1Frequency;
    }

#endif /* REGION_EU868 */
    return status;
}
 8037824:	b002      	add	sp, #8
 8037826:	bd10      	pop	{r4, pc}
    if( status == 0x03 )
 8037828:	2803      	cmp	r0, #3
        RegionNvmGroup2->Channels[dlChannelReq->ChannelId].Rx1Frequency = dlChannelReq->Rx1Frequency;
 803782a:	bf06      	itte	eq
 803782c:	6863      	ldreq	r3, [r4, #4]
 803782e:	604b      	streq	r3, [r1, #4]
 8037830:	2002      	movne	r0, #2
 8037832:	e7f7      	b.n	8037824 <RegionEU868DlChannelReq+0x34>
 8037834:	20005728 	.word	0x20005728

08037838 <RegionEU868AlternateDr>:
#if defined( REGION_EU868 )
    return currentDr;
#else
    return -1;
#endif /* REGION_EU868 */
}
 8037838:	4770      	bx	lr
	...

0803783c <RegionEU868NextChannel>:

LoRaMacStatus_t RegionEU868NextChannel( NextChanParams_t* nextChanParams, uint8_t* channel, TimerTime_t* time, TimerTime_t* aggregatedTimeOff )
{
 803783c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    RegionCommonIdentifyChannelsParam_t identifyChannelsParam;
    RegionCommonCountNbOfEnabledChannelsParams_t countChannelsParams;
    LoRaMacStatus_t status = LORAMAC_STATUS_NO_CHANNEL_FOUND;
    uint16_t joinChannels = EU868_JOIN_CHANNELS;

    if( RegionCommonCountChannels( RegionNvmGroup2->ChannelsMask, 0, 1 ) == 0 )
 8037840:	4d38      	ldr	r5, [pc, #224]	; (8037924 <RegionEU868NextChannel+0xe8>)
{
 8037842:	4604      	mov	r4, r0
    if( RegionCommonCountChannels( RegionNvmGroup2->ChannelsMask, 0, 1 ) == 0 )
 8037844:	6828      	ldr	r0, [r5, #0]
{
 8037846:	b096      	sub	sp, #88	; 0x58
 8037848:	460e      	mov	r6, r1
 803784a:	4690      	mov	r8, r2
    uint8_t nbEnabledChannels = 0;
 803784c:	2100      	movs	r1, #0
{
 803784e:	461f      	mov	r7, r3
    if( RegionCommonCountChannels( RegionNvmGroup2->ChannelsMask, 0, 1 ) == 0 )
 8037850:	2201      	movs	r2, #1
    uint16_t joinChannels = EU868_JOIN_CHANNELS;
 8037852:	2307      	movs	r3, #7
    if( RegionCommonCountChannels( RegionNvmGroup2->ChannelsMask, 0, 1 ) == 0 )
 8037854:	f500 7058 	add.w	r0, r0, #864	; 0x360
    uint8_t enabledChannels[EU868_MAX_NB_CHANNELS] = { 0 };
 8037858:	e9cd 1104 	strd	r1, r1, [sp, #16]
 803785c:	e9cd 1106 	strd	r1, r1, [sp, #24]
    uint8_t nbEnabledChannels = 0;
 8037860:	f88d 100c 	strb.w	r1, [sp, #12]
    uint8_t nbRestrictedChannels = 0;
 8037864:	f88d 100d 	strb.w	r1, [sp, #13]
    uint16_t joinChannels = EU868_JOIN_CHANNELS;
 8037868:	f8ad 300e 	strh.w	r3, [sp, #14]
    if( RegionCommonCountChannels( RegionNvmGroup2->ChannelsMask, 0, 1 ) == 0 )
 803786c:	f7ff f8f7 	bl	8036a5e <RegionCommonCountChannels>
 8037870:	b930      	cbnz	r0, 8037880 <RegionEU868NextChannel+0x44>
    { // Reactivate default channels
        RegionNvmGroup2->ChannelsMask[0] |= LC( 1 ) + LC( 2 ) + LC( 3 );
 8037872:	682a      	ldr	r2, [r5, #0]
 8037874:	f8b2 3360 	ldrh.w	r3, [r2, #864]	; 0x360
 8037878:	f043 0307 	orr.w	r3, r3, #7
 803787c:	f8a2 3360 	strh.w	r3, [r2, #864]	; 0x360
    }

    // Search how many channels are enabled
    countChannelsParams.Joined = nextChanParams->Joined;
    countChannelsParams.Datarate = nextChanParams->Datarate;
    countChannelsParams.ChannelsMask = RegionNvmGroup2->ChannelsMask;
 8037880:	682a      	ldr	r2, [r5, #0]
    countChannelsParams.Joined = nextChanParams->Joined;
 8037882:	7a63      	ldrb	r3, [r4, #9]
 8037884:	f88d 3020 	strb.w	r3, [sp, #32]
    countChannelsParams.ChannelsMask = RegionNvmGroup2->ChannelsMask;
 8037888:	f502 7158 	add.w	r1, r2, #864	; 0x360
    countChannelsParams.Channels = RegionNvmGroup2->Channels;
 803788c:	e9cd 1209 	strd	r1, r2, [sp, #36]	; 0x24
    countChannelsParams.Bands = RegionNvmGroup1->Bands;
 8037890:	686a      	ldr	r2, [r5, #4]
 8037892:	920b      	str	r2, [sp, #44]	; 0x2c
    countChannelsParams.MaxNbChannels = EU868_MAX_NB_CHANNELS;
 8037894:	2210      	movs	r2, #16
 8037896:	f8ad 2030 	strh.w	r2, [sp, #48]	; 0x30
    countChannelsParams.JoinChannels = &joinChannels;
 803789a:	f10d 020e 	add.w	r2, sp, #14
 803789e:	920d      	str	r2, [sp, #52]	; 0x34

    identifyChannelsParam.AggrTimeOff = nextChanParams->AggrTimeOff;
 80378a0:	6822      	ldr	r2, [r4, #0]
 80378a2:	920e      	str	r2, [sp, #56]	; 0x38
    identifyChannelsParam.LastAggrTx = nextChanParams->LastAggrTx;
 80378a4:	6862      	ldr	r2, [r4, #4]
 80378a6:	920f      	str	r2, [sp, #60]	; 0x3c
    identifyChannelsParam.DutyCycleEnabled = nextChanParams->DutyCycleEnabled;
    identifyChannelsParam.MaxBands = EU868_MAX_NB_BANDS;

    identifyChannelsParam.ElapsedTimeSinceStartUp = nextChanParams->ElapsedTimeSinceStartUp;
 80378a8:	e9d4 0103 	ldrd	r0, r1, [r4, #12]
    identifyChannelsParam.DutyCycleEnabled = nextChanParams->DutyCycleEnabled;
 80378ac:	7aa2      	ldrb	r2, [r4, #10]
    countChannelsParams.Datarate = nextChanParams->Datarate;
 80378ae:	f994 3008 	ldrsb.w	r3, [r4, #8]
    identifyChannelsParam.DutyCycleEnabled = nextChanParams->DutyCycleEnabled;
 80378b2:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
    identifyChannelsParam.MaxBands = EU868_MAX_NB_BANDS;
 80378b6:	2206      	movs	r2, #6
 80378b8:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
    identifyChannelsParam.ElapsedTimeSinceStartUp = nextChanParams->ElapsedTimeSinceStartUp;
 80378bc:	aa11      	add	r2, sp, #68	; 0x44
 80378be:	e882 0003 	stmia.w	r2, {r0, r1}
    identifyChannelsParam.LastTxIsJoinRequest = nextChanParams->LastTxIsJoinRequest;
 80378c2:	7d22      	ldrb	r2, [r4, #20]
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 80378c4:	8ae1      	ldrh	r1, [r4, #22]
    countChannelsParams.Datarate = nextChanParams->Datarate;
 80378c6:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 80378ca:	4618      	mov	r0, r3
    identifyChannelsParam.LastTxIsJoinRequest = nextChanParams->LastTxIsJoinRequest;
 80378cc:	f88d 204c 	strb.w	r2, [sp, #76]	; 0x4c
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 80378d0:	f7ff fbb0 	bl	8037034 <GetTimeOnAir>

    identifyChannelsParam.CountNbOfEnabledChannelsParam = &countChannelsParams;
 80378d4:	ab08      	add	r3, sp, #32
 80378d6:	9315      	str	r3, [sp, #84]	; 0x54

    status = RegionCommonIdentifyChannels( &identifyChannelsParam, aggregatedTimeOff, enabledChannels,
 80378d8:	f10d 030d 	add.w	r3, sp, #13
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 80378dc:	9014      	str	r0, [sp, #80]	; 0x50
    status = RegionCommonIdentifyChannels( &identifyChannelsParam, aggregatedTimeOff, enabledChannels,
 80378de:	9300      	str	r3, [sp, #0]
 80378e0:	f8cd 8004 	str.w	r8, [sp, #4]
 80378e4:	ab03      	add	r3, sp, #12
 80378e6:	aa04      	add	r2, sp, #16
 80378e8:	4639      	mov	r1, r7
 80378ea:	a80e      	add	r0, sp, #56	; 0x38
 80378ec:	f7ff faf1 	bl	8036ed2 <RegionCommonIdentifyChannels>
                                           &nbEnabledChannels, &nbRestrictedChannels, time );

    if( status == LORAMAC_STATUS_OK )
 80378f0:	4604      	mov	r4, r0
 80378f2:	b968      	cbnz	r0, 8037910 <RegionEU868NextChannel+0xd4>
    {
        // We found a valid channel
        *channel = enabledChannels[randr( 0, nbEnabledChannels - 1 )];
 80378f4:	f89d 100c 	ldrb.w	r1, [sp, #12]
 80378f8:	3901      	subs	r1, #1
 80378fa:	f001 fafb 	bl	8038ef4 <randr>
 80378fe:	ab16      	add	r3, sp, #88	; 0x58
 8037900:	4418      	add	r0, r3
 8037902:	f810 3c48 	ldrb.w	r3, [r0, #-72]
 8037906:	7033      	strb	r3, [r6, #0]
    }
    return status;
#else
    return LORAMAC_STATUS_NO_CHANNEL_FOUND;
#endif /* REGION_EU868 */
}
 8037908:	4620      	mov	r0, r4
 803790a:	b016      	add	sp, #88	; 0x58
 803790c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    else if( status == LORAMAC_STATUS_NO_CHANNEL_FOUND )
 8037910:	280c      	cmp	r0, #12
        RegionNvmGroup2->ChannelsMask[0] |= LC( 1 ) + LC( 2 ) + LC( 3 );
 8037912:	bf01      	itttt	eq
 8037914:	682a      	ldreq	r2, [r5, #0]
 8037916:	f8b2 3360 	ldrheq.w	r3, [r2, #864]	; 0x360
 803791a:	f043 0307 	orreq.w	r3, r3, #7
 803791e:	f8a2 3360 	strheq.w	r3, [r2, #864]	; 0x360
 8037922:	e7f1      	b.n	8037908 <RegionEU868NextChannel+0xcc>
 8037924:	20005728 	.word	0x20005728

08037928 <RegionEU868ChannelAdd>:

LoRaMacStatus_t RegionEU868ChannelAdd( ChannelAddParams_t* channelAdd )
{
 8037928:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
#if defined( REGION_EU868 )
    uint8_t band = 0;
    bool drInvalid = false;
    bool freqInvalid = false;
    uint8_t id = channelAdd->ChannelId;
 803792a:	7906      	ldrb	r6, [r0, #4]
    uint8_t band = 0;
 803792c:	2700      	movs	r7, #0

    if( id < EU868_NUMB_DEFAULT_CHANNELS )
 803792e:	2e02      	cmp	r6, #2
{
 8037930:	4605      	mov	r5, r0
    uint8_t band = 0;
 8037932:	f88d 7007 	strb.w	r7, [sp, #7]
    if( id < EU868_NUMB_DEFAULT_CHANNELS )
 8037936:	d802      	bhi.n	803793e <RegionEU868ChannelAdd+0x16>
    {
        return LORAMAC_STATUS_FREQ_AND_DR_INVALID;
 8037938:	2006      	movs	r0, #6
    RegionNvmGroup2->ChannelsMask[0] |= ( 1 << id );
    return LORAMAC_STATUS_OK;
#else
    return LORAMAC_STATUS_NO_CHANNEL_FOUND;
#endif /* REGION_EU868 */
}
 803793a:	b003      	add	sp, #12
 803793c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if( id >= EU868_MAX_NB_CHANNELS )
 803793e:	2e0f      	cmp	r6, #15
 8037940:	d82d      	bhi.n	803799e <RegionEU868ChannelAdd+0x76>
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Min, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 8037942:	6803      	ldr	r3, [r0, #0]
 8037944:	7a18      	ldrb	r0, [r3, #8]
 8037946:	f340 0003 	sbfx	r0, r0, #0, #4
 803794a:	2207      	movs	r2, #7
 803794c:	4639      	mov	r1, r7
 803794e:	b240      	sxtb	r0, r0
 8037950:	f7ff f863 	bl	8036a1a <RegionCommonValueInRange>
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Max, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 8037954:	682b      	ldr	r3, [r5, #0]
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Min, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 8037956:	4604      	mov	r4, r0
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Max, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 8037958:	7a18      	ldrb	r0, [r3, #8]
 803795a:	f340 1003 	sbfx	r0, r0, #4, #4
 803795e:	2207      	movs	r2, #7
 8037960:	4639      	mov	r1, r7
 8037962:	b240      	sxtb	r0, r0
 8037964:	f7ff f859 	bl	8036a1a <RegionCommonValueInRange>
 8037968:	b1b8      	cbz	r0, 803799a <RegionEU868ChannelAdd+0x72>
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Min, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 803796a:	fab4 f484 	clz	r4, r4
 803796e:	0964      	lsrs	r4, r4, #5
    if( channelAdd->NewChannel->DrRange.Fields.Min > channelAdd->NewChannel->DrRange.Fields.Max )
 8037970:	6828      	ldr	r0, [r5, #0]
 8037972:	7a03      	ldrb	r3, [r0, #8]
        if( VerifyRfFreq( channelAdd->NewChannel->Frequency, &band ) == false )
 8037974:	6800      	ldr	r0, [r0, #0]
    if( channelAdd->NewChannel->DrRange.Fields.Min > channelAdd->NewChannel->DrRange.Fields.Max )
 8037976:	f343 0203 	sbfx	r2, r3, #0, #4
 803797a:	f343 1303 	sbfx	r3, r3, #4, #4
 803797e:	b252      	sxtb	r2, r2
 8037980:	b25b      	sxtb	r3, r3
        if( VerifyRfFreq( channelAdd->NewChannel->Frequency, &band ) == false )
 8037982:	f10d 0107 	add.w	r1, sp, #7
        drInvalid = true;
 8037986:	429a      	cmp	r2, r3
 8037988:	bfc8      	it	gt
 803798a:	2401      	movgt	r4, #1
        if( VerifyRfFreq( channelAdd->NewChannel->Frequency, &band ) == false )
 803798c:	f7ff fb7a 	bl	8037084 <VerifyRfFreq>
 8037990:	b948      	cbnz	r0, 80379a6 <RegionEU868ChannelAdd+0x7e>
    if( ( drInvalid == true ) && ( freqInvalid == true ) )
 8037992:	2c00      	cmp	r4, #0
 8037994:	d1d0      	bne.n	8037938 <RegionEU868ChannelAdd+0x10>
        return LORAMAC_STATUS_FREQUENCY_INVALID;
 8037996:	2004      	movs	r0, #4
 8037998:	e7cf      	b.n	803793a <RegionEU868ChannelAdd+0x12>
        drInvalid = true;
 803799a:	2401      	movs	r4, #1
 803799c:	e7e8      	b.n	8037970 <RegionEU868ChannelAdd+0x48>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 803799e:	2003      	movs	r0, #3
 80379a0:	e7cb      	b.n	803793a <RegionEU868ChannelAdd+0x12>
        return LORAMAC_STATUS_DATARATE_INVALID;
 80379a2:	2005      	movs	r0, #5
 80379a4:	e7c9      	b.n	803793a <RegionEU868ChannelAdd+0x12>
    if( ( drInvalid == true ) && ( freqInvalid == true ) )
 80379a6:	2c00      	cmp	r4, #0
 80379a8:	d1fb      	bne.n	80379a2 <RegionEU868ChannelAdd+0x7a>
    memcpy1( ( uint8_t* ) &(RegionNvmGroup2->Channels[id]), ( uint8_t* ) channelAdd->NewChannel, sizeof( RegionNvmGroup2->Channels[id] ) );
 80379aa:	4f0d      	ldr	r7, [pc, #52]	; (80379e0 <RegionEU868ChannelAdd+0xb8>)
 80379ac:	6829      	ldr	r1, [r5, #0]
 80379ae:	683b      	ldr	r3, [r7, #0]
 80379b0:	eb06 0046 	add.w	r0, r6, r6, lsl #1
 80379b4:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 80379b8:	220c      	movs	r2, #12
 80379ba:	f001 fab7 	bl	8038f2c <memcpy1>
    RegionNvmGroup2->Channels[id].Band = band;
 80379be:	683a      	ldr	r2, [r7, #0]
 80379c0:	f89d 1007 	ldrb.w	r1, [sp, #7]
 80379c4:	230c      	movs	r3, #12
 80379c6:	fb03 2306 	mla	r3, r3, r6, r2
    return LORAMAC_STATUS_OK;
 80379ca:	4620      	mov	r0, r4
    RegionNvmGroup2->Channels[id].Band = band;
 80379cc:	7259      	strb	r1, [r3, #9]
    RegionNvmGroup2->ChannelsMask[0] |= ( 1 << id );
 80379ce:	2301      	movs	r3, #1
 80379d0:	fa03 f606 	lsl.w	r6, r3, r6
 80379d4:	f8b2 3360 	ldrh.w	r3, [r2, #864]	; 0x360
 80379d8:	431e      	orrs	r6, r3
 80379da:	f8a2 6360 	strh.w	r6, [r2, #864]	; 0x360
    return LORAMAC_STATUS_OK;
 80379de:	e7ac      	b.n	803793a <RegionEU868ChannelAdd+0x12>
 80379e0:	20005728 	.word	0x20005728

080379e4 <RegionEU868ChannelsRemove>:

bool RegionEU868ChannelsRemove( ChannelRemoveParams_t* channelRemove  )
{
 80379e4:	b410      	push	{r4}
#if defined( REGION_EU868 )
    uint8_t id = channelRemove->ChannelId;
 80379e6:	7801      	ldrb	r1, [r0, #0]

    if( id < EU868_NUMB_DEFAULT_CHANNELS )
 80379e8:	2902      	cmp	r1, #2
 80379ea:	d90e      	bls.n	8037a0a <RegionEU868ChannelsRemove+0x26>
    {
        return false;
    }

    // Remove the channel from the list of channels
    RegionNvmGroup2->Channels[id] = ( ChannelParams_t ){ 0, 0, { 0 }, 0 };
 80379ec:	4b08      	ldr	r3, [pc, #32]	; (8037a10 <RegionEU868ChannelsRemove+0x2c>)
 80379ee:	6818      	ldr	r0, [r3, #0]
 80379f0:	230c      	movs	r3, #12
 80379f2:	434b      	muls	r3, r1
 80379f4:	18c4      	adds	r4, r0, r3
 80379f6:	2200      	movs	r2, #0
 80379f8:	50c2      	str	r2, [r0, r3]
 80379fa:	e9c4 2201 	strd	r2, r2, [r4, #4]

    return RegionCommonChanDisable( RegionNvmGroup2->ChannelsMask, id, EU868_MAX_NB_CHANNELS );
 80379fe:	f500 7058 	add.w	r0, r0, #864	; 0x360
#else
    return false;
#endif /* REGION_EU868 */
}
 8037a02:	bc10      	pop	{r4}
    return RegionCommonChanDisable( RegionNvmGroup2->ChannelsMask, id, EU868_MAX_NB_CHANNELS );
 8037a04:	2210      	movs	r2, #16
 8037a06:	f7ff b811 	b.w	8036a2c <RegionCommonChanDisable>
}
 8037a0a:	2000      	movs	r0, #0
 8037a0c:	bc10      	pop	{r4}
 8037a0e:	4770      	bx	lr
 8037a10:	20005728 	.word	0x20005728

08037a14 <RegionEU868ApplyCFList>:
{
 8037a14:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8037a18:	b086      	sub	sp, #24
    newChannel.DrRange.Value = ( DR_5 << 4 ) | DR_0;
 8037a1a:	2350      	movs	r3, #80	; 0x50
 8037a1c:	f88d 3014 	strb.w	r3, [sp, #20]
    if( applyCFList->Size != 16 )
 8037a20:	7903      	ldrb	r3, [r0, #4]
 8037a22:	2b10      	cmp	r3, #16
{
 8037a24:	4607      	mov	r7, r0
    if( applyCFList->Size != 16 )
 8037a26:	d130      	bne.n	8037a8a <RegionEU868ApplyCFList+0x76>
    if( applyCFList->Payload[15] != 0 )
 8037a28:	6803      	ldr	r3, [r0, #0]
 8037a2a:	7bdd      	ldrb	r5, [r3, #15]
 8037a2c:	bb6d      	cbnz	r5, 8037a8a <RegionEU868ApplyCFList+0x76>
    for( uint8_t i = 0, chanIdx = EU868_NUMB_DEFAULT_CHANNELS; chanIdx < EU868_MAX_NB_CHANNELS; i+=3, chanIdx++ )
 8037a2e:	2403      	movs	r4, #3
            newChannel.Frequency = 0;
 8037a30:	46a8      	mov	r8, r5
            newChannel.Frequency *= 100;
 8037a32:	2664      	movs	r6, #100	; 0x64
        if( chanIdx < ( EU868_NUMB_CHANNELS_CF_LIST + EU868_NUMB_DEFAULT_CHANNELS ) )
 8037a34:	2c07      	cmp	r4, #7
 8037a36:	d814      	bhi.n	8037a62 <RegionEU868ApplyCFList+0x4e>
            newChannel.Frequency = (uint32_t) applyCFList->Payload[i];
 8037a38:	683a      	ldr	r2, [r7, #0]
 8037a3a:	5d53      	ldrb	r3, [r2, r5]
 8037a3c:	9303      	str	r3, [sp, #12]
            newChannel.Frequency |= ( (uint32_t) applyCFList->Payload[i + 1] << 8 );
 8037a3e:	442a      	add	r2, r5
 8037a40:	7851      	ldrb	r1, [r2, #1]
 8037a42:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8037a46:	9303      	str	r3, [sp, #12]
            newChannel.Frequency |= ( (uint32_t) applyCFList->Payload[i + 2] << 16 );
 8037a48:	7892      	ldrb	r2, [r2, #2]
 8037a4a:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
            newChannel.Frequency *= 100;
 8037a4e:	4373      	muls	r3, r6
            newChannel.Rx1Frequency = 0;
 8037a50:	e9cd 3803 	strd	r3, r8, [sp, #12]
        if( newChannel.Frequency != 0 )
 8037a54:	b963      	cbnz	r3, 8037a70 <RegionEU868ApplyCFList+0x5c>
            RegionEU868ChannelsRemove( &channelRemove );
 8037a56:	4668      	mov	r0, sp
            channelRemove.ChannelId = chanIdx;
 8037a58:	f88d 4000 	strb.w	r4, [sp]
            RegionEU868ChannelsRemove( &channelRemove );
 8037a5c:	f7ff ffc2 	bl	80379e4 <RegionEU868ChannelsRemove>
 8037a60:	e00d      	b.n	8037a7e <RegionEU868ApplyCFList+0x6a>
            newChannel.Frequency = 0;
 8037a62:	f8cd 800c 	str.w	r8, [sp, #12]
            newChannel.DrRange.Value = 0;
 8037a66:	f88d 8014 	strb.w	r8, [sp, #20]
            newChannel.Rx1Frequency = 0;
 8037a6a:	f8cd 8010 	str.w	r8, [sp, #16]
        if( newChannel.Frequency != 0 )
 8037a6e:	e7f2      	b.n	8037a56 <RegionEU868ApplyCFList+0x42>
            channelAdd.NewChannel = &newChannel;
 8037a70:	ab03      	add	r3, sp, #12
            RegionEU868ChannelAdd( &channelAdd );
 8037a72:	a801      	add	r0, sp, #4
            channelAdd.NewChannel = &newChannel;
 8037a74:	9301      	str	r3, [sp, #4]
            channelAdd.ChannelId = chanIdx;
 8037a76:	f88d 4008 	strb.w	r4, [sp, #8]
            RegionEU868ChannelAdd( &channelAdd );
 8037a7a:	f7ff ff55 	bl	8037928 <RegionEU868ChannelAdd>
    for( uint8_t i = 0, chanIdx = EU868_NUMB_DEFAULT_CHANNELS; chanIdx < EU868_MAX_NB_CHANNELS; i+=3, chanIdx++ )
 8037a7e:	3401      	adds	r4, #1
 8037a80:	b2e4      	uxtb	r4, r4
 8037a82:	2c10      	cmp	r4, #16
 8037a84:	f105 0503 	add.w	r5, r5, #3
 8037a88:	d1d4      	bne.n	8037a34 <RegionEU868ApplyCFList+0x20>
}
 8037a8a:	b006      	add	sp, #24
 8037a8c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08037a90 <RegionEU868NewChannelReq>:
{
 8037a90:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    if( newChannelReq->NewChannel->Frequency == 0 )
 8037a92:	6802      	ldr	r2, [r0, #0]
 8037a94:	7903      	ldrb	r3, [r0, #4]
 8037a96:	6811      	ldr	r1, [r2, #0]
 8037a98:	b951      	cbnz	r1, 8037ab0 <RegionEU868NewChannelReq+0x20>
        if( RegionEU868ChannelsRemove( &channelRemove ) == false )
 8037a9a:	a801      	add	r0, sp, #4
        channelRemove.ChannelId = newChannelReq->ChannelId;
 8037a9c:	f88d 3004 	strb.w	r3, [sp, #4]
        if( RegionEU868ChannelsRemove( &channelRemove ) == false )
 8037aa0:	f7ff ffa0 	bl	80379e4 <RegionEU868ChannelsRemove>
 8037aa4:	b988      	cbnz	r0, 8037aca <RegionEU868NewChannelReq+0x3a>
            status &= 0xFC;
 8037aa6:	2000      	movs	r0, #0
}
 8037aa8:	b240      	sxtb	r0, r0
 8037aaa:	b005      	add	sp, #20
 8037aac:	f85d fb04 	ldr.w	pc, [sp], #4
        switch( RegionEU868ChannelAdd( &channelAdd ) )
 8037ab0:	a802      	add	r0, sp, #8
        channelAdd.NewChannel = newChannelReq->NewChannel;
 8037ab2:	9202      	str	r2, [sp, #8]
        channelAdd.ChannelId = newChannelReq->ChannelId;
 8037ab4:	f88d 300c 	strb.w	r3, [sp, #12]
        switch( RegionEU868ChannelAdd( &channelAdd ) )
 8037ab8:	f7ff ff36 	bl	8037928 <RegionEU868ChannelAdd>
 8037abc:	2806      	cmp	r0, #6
 8037abe:	d8f2      	bhi.n	8037aa6 <RegionEU868NewChannelReq+0x16>
 8037ac0:	4b03      	ldr	r3, [pc, #12]	; (8037ad0 <RegionEU868NewChannelReq+0x40>)
 8037ac2:	4418      	add	r0, r3
 8037ac4:	f890 005c 	ldrb.w	r0, [r0, #92]	; 0x5c
 8037ac8:	e7ee      	b.n	8037aa8 <RegionEU868NewChannelReq+0x18>
    uint8_t status = 0x03;
 8037aca:	2003      	movs	r0, #3
 8037acc:	e7ec      	b.n	8037aa8 <RegionEU868NewChannelReq+0x18>
 8037ace:	bf00      	nop
 8037ad0:	0803baf4 	.word	0x0803baf4

08037ad4 <RegionEU868SetContinuousWave>:

void RegionEU868SetContinuousWave( ContinuousWaveParams_t* continuousWave )
{
 8037ad4:	b570      	push	{r4, r5, r6, lr}
#if defined( REGION_EU868 )
    int8_t txPowerLimited = RegionCommonLimitTxPower( continuousWave->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[continuousWave->Channel].Band].TxMaxPower );
 8037ad6:	4e11      	ldr	r6, [pc, #68]	; (8037b1c <RegionEU868SetContinuousWave+0x48>)
 8037ad8:	7802      	ldrb	r2, [r0, #0]
 8037ada:	e9d6 3100 	ldrd	r3, r1, [r6]
 8037ade:	250c      	movs	r5, #12
 8037ae0:	fb05 3202 	mla	r2, r5, r2, r3
{
 8037ae4:	4604      	mov	r4, r0
    int8_t txPowerLimited = RegionCommonLimitTxPower( continuousWave->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[continuousWave->Channel].Band].TxMaxPower );
 8037ae6:	7a53      	ldrb	r3, [r2, #9]
 8037ae8:	f990 0002 	ldrsb.w	r0, [r0, #2]
 8037aec:	2218      	movs	r2, #24
 8037aee:	fb02 1303 	mla	r3, r2, r3, r1
 8037af2:	f993 1002 	ldrsb.w	r1, [r3, #2]
 8037af6:	f7ff fa4b 	bl	8036f90 <RegionCommonLimitTxPower>
    int8_t phyTxPower = 0;
    uint32_t frequency = RegionNvmGroup2->Channels[continuousWave->Channel].Frequency;
 8037afa:	7822      	ldrb	r2, [r4, #0]
 8037afc:	6833      	ldr	r3, [r6, #0]

    // Calculate physical TX power
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, continuousWave->MaxEirp, continuousWave->AntennaGain );
 8037afe:	6861      	ldr	r1, [r4, #4]
    uint32_t frequency = RegionNvmGroup2->Channels[continuousWave->Channel].Frequency;
 8037b00:	4355      	muls	r5, r2
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, continuousWave->MaxEirp, continuousWave->AntennaGain );
 8037b02:	68a2      	ldr	r2, [r4, #8]
    uint32_t frequency = RegionNvmGroup2->Channels[continuousWave->Channel].Frequency;
 8037b04:	595d      	ldr	r5, [r3, r5]
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, continuousWave->MaxEirp, continuousWave->AntennaGain );
 8037b06:	f7ff f978 	bl	8036dfa <RegionCommonComputeTxPower>

    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 8037b0a:	4b05      	ldr	r3, [pc, #20]	; (8037b20 <RegionEU868SetContinuousWave+0x4c>)
 8037b0c:	89a2      	ldrh	r2, [r4, #12]
 8037b0e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, continuousWave->MaxEirp, continuousWave->AntennaGain );
 8037b10:	4601      	mov	r1, r0
    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 8037b12:	4628      	mov	r0, r5
#endif /* REGION_EU868 */
}
 8037b14:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 8037b18:	4718      	bx	r3
 8037b1a:	bf00      	nop
 8037b1c:	20005728 	.word	0x20005728
 8037b20:	0803bc30 	.word	0x0803bc30

08037b24 <RegionEU868ApplyDrOffset>:

uint8_t RegionEU868ApplyDrOffset( uint8_t downlinkDwellTime, int8_t dr, int8_t drOffset )
{
#if defined( REGION_EU868 )
    int8_t datarate = dr - drOffset;
 8037b24:	1a88      	subs	r0, r1, r2
 8037b26:	b240      	sxtb	r0, r0

    if( datarate < 0 )
    {
        datarate = DR_0;
    }
    return datarate;
 8037b28:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
#else
    return 0;
#endif /* REGION_EU868 */
}
 8037b2c:	b2c0      	uxtb	r0, r0
 8037b2e:	4770      	bx	lr

08037b30 <GetTimeOnAir>:
    }
    return true;
}

static TimerTime_t GetTimeOnAir( int8_t datarate, uint16_t pktLen )
{
 8037b30:	b530      	push	{r4, r5, lr}
 8037b32:	460c      	mov	r4, r1
    int8_t phyDr = DataratesUS915[datarate];
 8037b34:	490a      	ldr	r1, [pc, #40]	; (8037b60 <GetTimeOnAir+0x30>)
{
 8037b36:	b085      	sub	sp, #20
    int8_t phyDr = DataratesUS915[datarate];
 8037b38:	560d      	ldrsb	r5, [r1, r0]
    uint32_t bandwidth = RegionCommonGetBandwidth( datarate, BandwidthsUS915 );
 8037b3a:	3110      	adds	r1, #16
 8037b3c:	f7ff fa2c 	bl	8036f98 <RegionCommonGetBandwidth>

    return Radio.TimeOnAir( MODEM_LORA, bandwidth, phyDr, 1, 8, false, pktLen, true );
 8037b40:	2208      	movs	r2, #8
    uint32_t bandwidth = RegionCommonGetBandwidth( datarate, BandwidthsUS915 );
 8037b42:	4601      	mov	r1, r0
    return Radio.TimeOnAir( MODEM_LORA, bandwidth, phyDr, 1, 8, false, pktLen, true );
 8037b44:	2000      	movs	r0, #0
 8037b46:	e9cd 2000 	strd	r2, r0, [sp]
 8037b4a:	4a06      	ldr	r2, [pc, #24]	; (8037b64 <GetTimeOnAir+0x34>)
 8037b4c:	2301      	movs	r3, #1
 8037b4e:	b2e4      	uxtb	r4, r4
 8037b50:	9402      	str	r4, [sp, #8]
 8037b52:	9303      	str	r3, [sp, #12]
 8037b54:	6a54      	ldr	r4, [r2, #36]	; 0x24
 8037b56:	4618      	mov	r0, r3
 8037b58:	462a      	mov	r2, r5
 8037b5a:	47a0      	blx	r4
}
 8037b5c:	b005      	add	sp, #20
 8037b5e:	bd30      	pop	{r4, r5, pc}
 8037b60:	0803bb58 	.word	0x0803bb58
 8037b64:	0803bc30 	.word	0x0803bc30

08037b68 <VerifyRfFreq>:
    if( Radio.CheckRfFrequency( freq ) == false )
 8037b68:	4b0b      	ldr	r3, [pc, #44]	; (8037b98 <VerifyRfFreq+0x30>)
{
 8037b6a:	b510      	push	{r4, lr}
    if( Radio.CheckRfFrequency( freq ) == false )
 8037b6c:	6a1b      	ldr	r3, [r3, #32]
{
 8037b6e:	4604      	mov	r4, r0
    if( Radio.CheckRfFrequency( freq ) == false )
 8037b70:	4798      	blx	r3
 8037b72:	b168      	cbz	r0, 8037b90 <VerifyRfFreq+0x28>
    if( ( freq < US915_FIRST_RX1_CHANNEL ) ||
 8037b74:	4b09      	ldr	r3, [pc, #36]	; (8037b9c <VerifyRfFreq+0x34>)
 8037b76:	4a0a      	ldr	r2, [pc, #40]	; (8037ba0 <VerifyRfFreq+0x38>)
 8037b78:	4423      	add	r3, r4
 8037b7a:	4293      	cmp	r3, r2
 8037b7c:	d809      	bhi.n	8037b92 <VerifyRfFreq+0x2a>
        ( freq > US915_LAST_RX1_CHANNEL ) ||
 8037b7e:	4a09      	ldr	r2, [pc, #36]	; (8037ba4 <VerifyRfFreq+0x3c>)
 8037b80:	4353      	muls	r3, r2
 8037b82:	f641 32f6 	movw	r2, #7158	; 0x1bf6
 8037b86:	ebb2 1fb3 	cmp.w	r2, r3, ror #6
 8037b8a:	bf2c      	ite	cs
 8037b8c:	2001      	movcs	r0, #1
 8037b8e:	2000      	movcc	r0, #0
}
 8037b90:	bd10      	pop	{r4, pc}
        return false;
 8037b92:	2000      	movs	r0, #0
 8037b94:	e7fc      	b.n	8037b90 <VerifyRfFreq+0x28>
 8037b96:	bf00      	nop
 8037b98:	0803bc30 	.word	0x0803bc30
 8037b9c:	c8f78f60 	.word	0xc8f78f60
 8037ba0:	00401640 	.word	0x00401640
 8037ba4:	5943f75f 	.word	0x5943f75f

08037ba8 <RegionUS915GetPhyParam>:
#endif /* REGION_US915 */

PhyParam_t RegionUS915GetPhyParam( GetPhyParams_t* getPhy )
{
 8037ba8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    PhyParam_t phyParam = { 0 };
 8037baa:	2300      	movs	r3, #0
 8037bac:	9300      	str	r3, [sp, #0]

#if defined( REGION_US915 )
    switch( getPhy->Attribute )
 8037bae:	7803      	ldrb	r3, [r0, #0]
 8037bb0:	3b01      	subs	r3, #1
 8037bb2:	2b38      	cmp	r3, #56	; 0x38
 8037bb4:	d875      	bhi.n	8037ca2 <RegionUS915GetPhyParam+0xfa>
 8037bb6:	e8df f003 	tbb	[pc, r3]
 8037bba:	741d      	.short	0x741d
 8037bbc:	74747474 	.word	0x74747474
 8037bc0:	74747474 	.word	0x74747474
 8037bc4:	40393735 	.word	0x40393735
 8037bc8:	4d4a4774 	.word	0x4d4a4774
 8037bcc:	59565350 	.word	0x59565350
 8037bd0:	631d6174 	.word	0x631d6174
 8037bd4:	746f6d68 	.word	0x746f6d68
 8037bd8:	20787274 	.word	0x20787274
 8037bdc:	74747474 	.word	0x74747474
 8037be0:	74747474 	.word	0x74747474
 8037be4:	74747474 	.word	0x74747474
 8037be8:	1d807a74 	.word	0x1d807a74
 8037bec:	1d7a741d 	.word	0x1d7a741d
 8037bf0:	881d      	.short	0x881d
 8037bf2:	8d          	.byte	0x8d
 8037bf3:	00          	.byte	0x00
    {
        case PHY_MIN_RX_DR:
        {
            phyParam.Value = US915_RX_MIN_DATARATE;
 8037bf4:	2308      	movs	r3, #8
            phyParam.Value = US915_BEACON_NB_CHANNELS;
            break;
        }
        case PHY_SF_FROM_DR:
        {
            phyParam.Value = DataratesUS915[getPhy->Datarate];
 8037bf6:	9300      	str	r3, [sp, #0]
            break;
 8037bf8:	e053      	b.n	8037ca2 <RegionUS915GetPhyParam+0xfa>
            RegionCommonGetNextLowerTxDrParams_t nextLowerTxDrParams =
 8037bfa:	7843      	ldrb	r3, [r0, #1]
 8037bfc:	f88d 3004 	strb.w	r3, [sp, #4]
 8037c00:	2304      	movs	r3, #4
 8037c02:	f88d 3005 	strb.w	r3, [sp, #5]
 8037c06:	f44f 4390 	mov.w	r3, #18432	; 0x4800
 8037c0a:	f8ad 3006 	strh.w	r3, [sp, #6]
                .ChannelsMask = RegionNvmGroup2->ChannelsMask,
 8037c0e:	4b34      	ldr	r3, [pc, #208]	; (8037ce0 <RegionUS915GetPhyParam+0x138>)
 8037c10:	681b      	ldr	r3, [r3, #0]
            phyParam.Value = RegionCommonGetNextLowerTxDr( &nextLowerTxDrParams );
 8037c12:	a801      	add	r0, sp, #4
                .ChannelsMask = RegionNvmGroup2->ChannelsMask,
 8037c14:	f503 7258 	add.w	r2, r3, #864	; 0x360
            RegionCommonGetNextLowerTxDrParams_t nextLowerTxDrParams =
 8037c18:	e9cd 2302 	strd	r2, r3, [sp, #8]
            phyParam.Value = RegionCommonGetNextLowerTxDr( &nextLowerTxDrParams );
 8037c1c:	f7ff f99d 	bl	8036f5a <RegionCommonGetNextLowerTxDr>
        }
        case PHY_BW_FROM_DR:
        {
            phyParam.Value = RegionCommonGetBandwidth( getPhy->Datarate, BandwidthsUS915 );
 8037c20:	9000      	str	r0, [sp, #0]
            break;
 8037c22:	e03e      	b.n	8037ca2 <RegionUS915GetPhyParam+0xfa>
            phyParam.Value = REGION_COMMON_DEFAULT_ADR_ACK_LIMIT;
 8037c24:	2340      	movs	r3, #64	; 0x40
 8037c26:	e7e6      	b.n	8037bf6 <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = REGION_COMMON_DEFAULT_ADR_ACK_DELAY;
 8037c28:	2320      	movs	r3, #32
 8037c2a:	e7e4      	b.n	8037bf6 <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = MaxPayloadOfDatarateUS915[getPhy->Datarate];
 8037c2c:	f990 2001 	ldrsb.w	r2, [r0, #1]
 8037c30:	4b2c      	ldr	r3, [pc, #176]	; (8037ce4 <RegionUS915GetPhyParam+0x13c>)
 8037c32:	4413      	add	r3, r2
 8037c34:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 8037c38:	e7dd      	b.n	8037bf6 <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = MaxPayloadOfDatarateRepeaterUS915[getPhy->Datarate];
 8037c3a:	f990 2001 	ldrsb.w	r2, [r0, #1]
 8037c3e:	4b29      	ldr	r3, [pc, #164]	; (8037ce4 <RegionUS915GetPhyParam+0x13c>)
 8037c40:	4413      	add	r3, r2
 8037c42:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8037c46:	e7d6      	b.n	8037bf6 <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = US915_MAX_RX_WINDOW;
 8037c48:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8037c4c:	e7d3      	b.n	8037bf6 <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = REGION_COMMON_DEFAULT_RECEIVE_DELAY1;
 8037c4e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8037c52:	e7d0      	b.n	8037bf6 <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = REGION_COMMON_DEFAULT_RECEIVE_DELAY2;
 8037c54:	f44f 63fa 	mov.w	r3, #2000	; 0x7d0
 8037c58:	e7cd      	b.n	8037bf6 <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = REGION_COMMON_DEFAULT_JOIN_ACCEPT_DELAY1;
 8037c5a:	f241 3388 	movw	r3, #5000	; 0x1388
 8037c5e:	e7ca      	b.n	8037bf6 <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = REGION_COMMON_DEFAULT_JOIN_ACCEPT_DELAY2;
 8037c60:	f241 7370 	movw	r3, #6000	; 0x1770
 8037c64:	e7c7      	b.n	8037bf6 <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = REGION_COMMON_DEFAULT_MAX_FCNT_GAP;
 8037c66:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8037c6a:	e7c4      	b.n	8037bf6 <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = ( REGION_COMMON_DEFAULT_ACK_TIMEOUT + randr( -REGION_COMMON_DEFAULT_ACK_TIMEOUT_RND, REGION_COMMON_DEFAULT_ACK_TIMEOUT_RND ) );
 8037c6c:	481e      	ldr	r0, [pc, #120]	; (8037ce8 <RegionUS915GetPhyParam+0x140>)
 8037c6e:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8037c72:	f001 f93f 	bl	8038ef4 <randr>
 8037c76:	f500 60fa 	add.w	r0, r0, #2000	; 0x7d0
 8037c7a:	e7d1      	b.n	8037c20 <RegionUS915GetPhyParam+0x78>
            phyParam.Value = US915_RX_WND_2_FREQ;
 8037c7c:	4b1b      	ldr	r3, [pc, #108]	; (8037cec <RegionUS915GetPhyParam+0x144>)
 8037c7e:	e7ba      	b.n	8037bf6 <RegionUS915GetPhyParam+0x4e>
            phyParam.ChannelsMask = RegionNvmGroup2->ChannelsMask;
 8037c80:	4b17      	ldr	r3, [pc, #92]	; (8037ce0 <RegionUS915GetPhyParam+0x138>)
 8037c82:	681b      	ldr	r3, [r3, #0]
 8037c84:	f503 7358 	add.w	r3, r3, #864	; 0x360
 8037c88:	e7b5      	b.n	8037bf6 <RegionUS915GetPhyParam+0x4e>
            phyParam.ChannelsMask = RegionNvmGroup2->ChannelsDefaultMask;
 8037c8a:	4b15      	ldr	r3, [pc, #84]	; (8037ce0 <RegionUS915GetPhyParam+0x138>)
 8037c8c:	681b      	ldr	r3, [r3, #0]
 8037c8e:	f503 735b 	add.w	r3, r3, #876	; 0x36c
 8037c92:	e7b0      	b.n	8037bf6 <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = US915_MAX_NB_CHANNELS;
 8037c94:	2348      	movs	r3, #72	; 0x48
 8037c96:	e7ae      	b.n	8037bf6 <RegionUS915GetPhyParam+0x4e>
            phyParam.Channels = RegionNvmGroup2->Channels;
 8037c98:	4b11      	ldr	r3, [pc, #68]	; (8037ce0 <RegionUS915GetPhyParam+0x138>)
 8037c9a:	681b      	ldr	r3, [r3, #0]
 8037c9c:	e7ab      	b.n	8037bf6 <RegionUS915GetPhyParam+0x4e>
            phyParam.fValue = US915_DEFAULT_MAX_ERP + 2.15f;
 8037c9e:	4b14      	ldr	r3, [pc, #80]	; (8037cf0 <RegionUS915GetPhyParam+0x148>)
            phyParam.fValue = 0;
 8037ca0:	9300      	str	r3, [sp, #0]
        }
    }

#endif /* REGION_US915 */
    return phyParam;
}
 8037ca2:	9800      	ldr	r0, [sp, #0]
 8037ca4:	b005      	add	sp, #20
 8037ca6:	f85d fb04 	ldr.w	pc, [sp], #4
            phyParam.fValue = 0;
 8037caa:	2300      	movs	r3, #0
 8037cac:	e7f8      	b.n	8037ca0 <RegionUS915GetPhyParam+0xf8>
            phyParam.Value = RegionBaseUSCalcDownlinkFrequency( getPhy->Channel,
 8037cae:	4a11      	ldr	r2, [pc, #68]	; (8037cf4 <RegionUS915GetPhyParam+0x14c>)
 8037cb0:	490e      	ldr	r1, [pc, #56]	; (8037cec <RegionUS915GetPhyParam+0x144>)
 8037cb2:	7900      	ldrb	r0, [r0, #4]
 8037cb4:	f7fe fe7a 	bl	80369ac <RegionBaseUSCalcDownlinkFrequency>
 8037cb8:	e7b2      	b.n	8037c20 <RegionUS915GetPhyParam+0x78>
            phyParam.BeaconFormat.BeaconSize = US915_BEACON_SIZE;
 8037cba:	f240 5317 	movw	r3, #1303	; 0x517
 8037cbe:	f8ad 3000 	strh.w	r3, [sp]
            phyParam.BeaconFormat.Rfu2Size = US915_RFU2_SIZE;
 8037cc2:	2303      	movs	r3, #3
 8037cc4:	f88d 3002 	strb.w	r3, [sp, #2]
            break;
 8037cc8:	e7eb      	b.n	8037ca2 <RegionUS915GetPhyParam+0xfa>
            phyParam.Value = DataratesUS915[getPhy->Datarate];
 8037cca:	f990 3001 	ldrsb.w	r3, [r0, #1]
 8037cce:	4a05      	ldr	r2, [pc, #20]	; (8037ce4 <RegionUS915GetPhyParam+0x13c>)
 8037cd0:	5cd3      	ldrb	r3, [r2, r3]
 8037cd2:	e790      	b.n	8037bf6 <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = RegionCommonGetBandwidth( getPhy->Datarate, BandwidthsUS915 );
 8037cd4:	4908      	ldr	r1, [pc, #32]	; (8037cf8 <RegionUS915GetPhyParam+0x150>)
 8037cd6:	f990 0001 	ldrsb.w	r0, [r0, #1]
 8037cda:	f7ff f95d 	bl	8036f98 <RegionCommonGetBandwidth>
 8037cde:	e79f      	b.n	8037c20 <RegionUS915GetPhyParam+0x78>
 8037ce0:	20005730 	.word	0x20005730
 8037ce4:	0803bb58 	.word	0x0803bb58
 8037ce8:	fffffc18 	.word	0xfffffc18
 8037cec:	370870a0 	.word	0x370870a0
 8037cf0:	4200999a 	.word	0x4200999a
 8037cf4:	000927c0 	.word	0x000927c0
 8037cf8:	0803bb68 	.word	0x0803bb68

08037cfc <RegionUS915SetBandTxDone>:

void RegionUS915SetBandTxDone( SetBandTxDoneParams_t* txDone )
{
 8037cfc:	b537      	push	{r0, r1, r2, r4, r5, lr}
#if defined( REGION_US915 )
    RegionCommonSetBandTxDone( &RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txDone->Channel].Band],
 8037cfe:	4a0a      	ldr	r2, [pc, #40]	; (8037d28 <RegionUS915SetBandTxDone+0x2c>)
 8037d00:	7803      	ldrb	r3, [r0, #0]
 8037d02:	6811      	ldr	r1, [r2, #0]
 8037d04:	6855      	ldr	r5, [r2, #4]
 8037d06:	240c      	movs	r4, #12
 8037d08:	fb04 1303 	mla	r3, r4, r3, r1
 8037d0c:	7a5b      	ldrb	r3, [r3, #9]
 8037d0e:	eb03 0443 	add.w	r4, r3, r3, lsl #1
 8037d12:	6903      	ldr	r3, [r0, #16]
 8037d14:	9300      	str	r3, [sp, #0]
 8037d16:	68c3      	ldr	r3, [r0, #12]
 8037d18:	7842      	ldrb	r2, [r0, #1]
 8037d1a:	6881      	ldr	r1, [r0, #8]
 8037d1c:	eb05 00c4 	add.w	r0, r5, r4, lsl #3
 8037d20:	f7fe feca 	bl	8036ab8 <RegionCommonSetBandTxDone>
                               txDone->LastTxAirTime, txDone->Joined, txDone->ElapsedTimeSinceStartUp );
#endif /* REGION_US915 */
}
 8037d24:	b003      	add	sp, #12
 8037d26:	bd30      	pop	{r4, r5, pc}
 8037d28:	20005730 	.word	0x20005730

08037d2c <RegionUS915InitDefaults>:

void RegionUS915InitDefaults( InitDefaultsParams_t* params )
{
 8037d2c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8037d2e:	b087      	sub	sp, #28
#if defined( REGION_US915 )
    Band_t bands[US915_MAX_NB_BANDS] =
 8037d30:	2301      	movs	r3, #1
    {
       US915_BAND0
    };

    switch( params->Type )
 8037d32:	7a04      	ldrb	r4, [r0, #8]
    Band_t bands[US915_MAX_NB_BANDS] =
 8037d34:	f8ad 3000 	strh.w	r3, [sp]
 8037d38:	2300      	movs	r3, #0
 8037d3a:	e9cd 3301 	strd	r3, r3, [sp, #4]
 8037d3e:	e9cd 3303 	strd	r3, r3, [sp, #12]
{
 8037d42:	4602      	mov	r2, r0
    Band_t bands[US915_MAX_NB_BANDS] =
 8037d44:	f88d 3002 	strb.w	r3, [sp, #2]
 8037d48:	f88d 3014 	strb.w	r3, [sp, #20]
    switch( params->Type )
 8037d4c:	b124      	cbz	r4, 8037d58 <RegionUS915InitDefaults+0x2c>
 8037d4e:	3c01      	subs	r4, #1
 8037d50:	2c01      	cmp	r4, #1
 8037d52:	d94a      	bls.n	8037dea <RegionUS915InitDefaults+0xbe>
        {
            break;
        }
    }
#endif /* REGION_US915 */
}
 8037d54:	b007      	add	sp, #28
 8037d56:	bdf0      	pop	{r4, r5, r6, r7, pc}
            if( ( params->NvmGroup1 == NULL ) || ( params->NvmGroup2 == NULL ) )
 8037d58:	6800      	ldr	r0, [r0, #0]
 8037d5a:	2800      	cmp	r0, #0
 8037d5c:	d0fa      	beq.n	8037d54 <RegionUS915InitDefaults+0x28>
 8037d5e:	6853      	ldr	r3, [r2, #4]
 8037d60:	2b00      	cmp	r3, #0
 8037d62:	d0f7      	beq.n	8037d54 <RegionUS915InitDefaults+0x28>
            RegionNvmGroup1 = (RegionNvmDataGroup1_t*) params->NvmGroup1;
 8037d64:	4d2d      	ldr	r5, [pc, #180]	; (8037e1c <RegionUS915InitDefaults+0xf0>)
            RegionNvmGroup1->JoinChannelGroupsCurrentIndex = 0;
 8037d66:	f8a0 409c 	strh.w	r4, [r0, #156]	; 0x9c
            memcpy1( ( uint8_t* )RegionNvmGroup1->Bands, ( uint8_t* )bands, sizeof( Band_t ) * US915_MAX_NB_BANDS );
 8037d6a:	2218      	movs	r2, #24
 8037d6c:	4669      	mov	r1, sp
            RegionNvmGroup2 = (RegionNvmDataGroup2_t*) params->NvmGroup2;
 8037d6e:	e9c5 3000 	strd	r3, r0, [r5]
            memcpy1( ( uint8_t* )RegionNvmGroup1->Bands, ( uint8_t* )bands, sizeof( Band_t ) * US915_MAX_NB_BANDS );
 8037d72:	f001 f8db 	bl	8038f2c <memcpy1>
                RegionNvmGroup2->Channels[i].Frequency = 902300000 + i * 200000;
 8037d76:	6828      	ldr	r0, [r5, #0]
 8037d78:	4b29      	ldr	r3, [pc, #164]	; (8037e20 <RegionUS915InitDefaults+0xf4>)
            for( uint8_t i = 0; i < US915_MAX_NB_CHANNELS - 8; i++ )
 8037d7a:	4e2a      	ldr	r6, [pc, #168]	; (8037e24 <RegionUS915InitDefaults+0xf8>)
 8037d7c:	4602      	mov	r2, r0
                RegionNvmGroup2->Channels[i].Frequency = 902300000 + i * 200000;
 8037d7e:	4601      	mov	r1, r0
                RegionNvmGroup2->Channels[i].DrRange.Value = ( DR_3 << 4 ) | DR_0;
 8037d80:	2730      	movs	r7, #48	; 0x30
                RegionNvmGroup2->Channels[i].Frequency = 902300000 + i * 200000;
 8037d82:	600b      	str	r3, [r1, #0]
                RegionNvmGroup2->Channels[i].DrRange.Value = ( DR_3 << 4 ) | DR_0;
 8037d84:	f503 3343 	add.w	r3, r3, #199680	; 0x30c00
 8037d88:	f503 73a0 	add.w	r3, r3, #320	; 0x140
            for( uint8_t i = 0; i < US915_MAX_NB_CHANNELS - 8; i++ )
 8037d8c:	42b3      	cmp	r3, r6
                RegionNvmGroup2->Channels[i].DrRange.Value = ( DR_3 << 4 ) | DR_0;
 8037d8e:	720f      	strb	r7, [r1, #8]
                RegionNvmGroup2->Channels[i].Band = 0;
 8037d90:	724c      	strb	r4, [r1, #9]
            for( uint8_t i = 0; i < US915_MAX_NB_CHANNELS - 8; i++ )
 8037d92:	f101 010c 	add.w	r1, r1, #12
 8037d96:	d1f4      	bne.n	8037d82 <RegionUS915InitDefaults+0x56>
 8037d98:	4b23      	ldr	r3, [pc, #140]	; (8037e28 <RegionUS915InitDefaults+0xfc>)
            for( uint8_t i = US915_MAX_NB_CHANNELS - 8; i < US915_MAX_NB_CHANNELS; i++ )
 8037d9a:	4924      	ldr	r1, [pc, #144]	; (8037e2c <RegionUS915InitDefaults+0x100>)
                RegionNvmGroup2->Channels[i].DrRange.Value = ( DR_4 << 4 ) | DR_4;
 8037d9c:	2644      	movs	r6, #68	; 0x44
                RegionNvmGroup2->Channels[i].Band = 0;
 8037d9e:	2400      	movs	r4, #0
                RegionNvmGroup2->Channels[i].Frequency = 903000000 + ( i - ( US915_MAX_NB_CHANNELS - 8 ) ) * 1600000;
 8037da0:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
                RegionNvmGroup2->Channels[i].DrRange.Value = ( DR_4 << 4 ) | DR_4;
 8037da4:	f503 13c3 	add.w	r3, r3, #1597440	; 0x186000
 8037da8:	f503 6320 	add.w	r3, r3, #2560	; 0xa00
            for( uint8_t i = US915_MAX_NB_CHANNELS - 8; i < US915_MAX_NB_CHANNELS; i++ )
 8037dac:	428b      	cmp	r3, r1
                RegionNvmGroup2->Channels[i].DrRange.Value = ( DR_4 << 4 ) | DR_4;
 8037dae:	f882 6308 	strb.w	r6, [r2, #776]	; 0x308
                RegionNvmGroup2->Channels[i].Band = 0;
 8037db2:	f882 4309 	strb.w	r4, [r2, #777]	; 0x309
            for( uint8_t i = US915_MAX_NB_CHANNELS - 8; i < US915_MAX_NB_CHANNELS; i++ )
 8037db6:	f102 020c 	add.w	r2, r2, #12
 8037dba:	d1f1      	bne.n	8037da0 <RegionUS915InitDefaults+0x74>
            RegionNvmGroup2->ChannelsDefaultMask[0] = 0xFFFF;
 8037dbc:	f04f 33ff 	mov.w	r3, #4294967295
            RegionNvmGroup2->ChannelsDefaultMask[2] = 0xFFFF;
 8037dc0:	e9c0 33db 	strd	r3, r3, [r0, #876]	; 0x36c
            RegionNvmGroup2->ChannelsDefaultMask[4] = 0x00FF;
 8037dc4:	23ff      	movs	r3, #255	; 0xff
 8037dc6:	f8c0 3374 	str.w	r3, [r0, #884]	; 0x374
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
 8037dca:	f500 715b 	add.w	r1, r0, #876	; 0x36c
 8037dce:	2206      	movs	r2, #6
 8037dd0:	f500 7058 	add.w	r0, r0, #864	; 0x360
 8037dd4:	f7fe fe61 	bl	8036a9a <RegionCommonChanMaskCopy>
            RegionCommonChanMaskCopy( RegionNvmGroup1->ChannelsMaskRemaining, RegionNvmGroup2->ChannelsMask, CHANNELS_MASK_SIZE );
 8037dd8:	e9d5 1000 	ldrd	r1, r0, [r5]
 8037ddc:	2206      	movs	r2, #6
 8037dde:	f501 7158 	add.w	r1, r1, #864	; 0x360
 8037de2:	3090      	adds	r0, #144	; 0x90
 8037de4:	f7fe fe59 	bl	8036a9a <RegionCommonChanMaskCopy>
            break;
 8037de8:	e7b4      	b.n	8037d54 <RegionUS915InitDefaults+0x28>
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
 8037dea:	4c0c      	ldr	r4, [pc, #48]	; (8037e1c <RegionUS915InitDefaults+0xf0>)
 8037dec:	6820      	ldr	r0, [r4, #0]
 8037dee:	2206      	movs	r2, #6
 8037df0:	f500 715b 	add.w	r1, r0, #876	; 0x36c
 8037df4:	f500 7058 	add.w	r0, r0, #864	; 0x360
 8037df8:	f7fe fe4f 	bl	8036a9a <RegionCommonChanMaskCopy>
                RegionNvmGroup1->ChannelsMaskRemaining[i] &= RegionNvmGroup2->ChannelsMask[i];
 8037dfc:	6863      	ldr	r3, [r4, #4]
 8037dfe:	6821      	ldr	r1, [r4, #0]
 8037e00:	f103 0290 	add.w	r2, r3, #144	; 0x90
 8037e04:	f501 7158 	add.w	r1, r1, #864	; 0x360
 8037e08:	339c      	adds	r3, #156	; 0x9c
 8037e0a:	8810      	ldrh	r0, [r2, #0]
 8037e0c:	f831 4b02 	ldrh.w	r4, [r1], #2
 8037e10:	4020      	ands	r0, r4
 8037e12:	f822 0b02 	strh.w	r0, [r2], #2
            for( uint8_t i = 0; i < CHANNELS_MASK_SIZE; i++ )
 8037e16:	429a      	cmp	r2, r3
 8037e18:	d1f7      	bne.n	8037e0a <RegionUS915InitDefaults+0xde>
 8037e1a:	e79b      	b.n	8037d54 <RegionUS915InitDefaults+0x28>
 8037e1c:	20005730 	.word	0x20005730
 8037e20:	35c80160 	.word	0x35c80160
 8037e24:	368b5160 	.word	0x368b5160
 8037e28:	35d2afc0 	.word	0x35d2afc0
 8037e2c:	3695ffc0 	.word	0x3695ffc0

08037e30 <RegionUS915Verify>:

bool RegionUS915Verify( VerifyParams_t* verify, PhyAttribute_t phyAttribute )
{
 8037e30:	b508      	push	{r3, lr}
 8037e32:	290a      	cmp	r1, #10
 8037e34:	d81b      	bhi.n	8037e6e <RegionUS915Verify+0x3e>
 8037e36:	e8df f001 	tbb	[pc, r1]
 8037e3a:	1a06      	.short	0x1a06
 8037e3c:	0b1a1a1a 	.word	0x0b1a1a1a
 8037e40:	181a0e0b 	.word	0x181a0e0b
 8037e44:	18          	.byte	0x18
 8037e45:	00          	.byte	0x00
            return false;
    }
#else
    return false;
#endif /* REGION_US915 */
}
 8037e46:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            return VerifyRfFreq( verify->Frequency );
 8037e4a:	6800      	ldr	r0, [r0, #0]
 8037e4c:	f7ff be8c 	b.w	8037b68 <VerifyRfFreq>
            return RegionCommonValueInRange( verify->DatarateParams.Datarate, US915_TX_MIN_DATARATE, US915_TX_MAX_DATARATE );
 8037e50:	2204      	movs	r2, #4
            return RegionCommonValueInRange( verify->TxPower, US915_MAX_TX_POWER, US915_MIN_TX_POWER );
 8037e52:	2100      	movs	r1, #0
 8037e54:	e001      	b.n	8037e5a <RegionUS915Verify+0x2a>
            return RegionCommonValueInRange( verify->DatarateParams.Datarate, US915_RX_MIN_DATARATE, US915_RX_MAX_DATARATE );
 8037e56:	220d      	movs	r2, #13
 8037e58:	2108      	movs	r1, #8
            return RegionCommonValueInRange( verify->TxPower, US915_MAX_TX_POWER, US915_MIN_TX_POWER );
 8037e5a:	f990 0000 	ldrsb.w	r0, [r0]
 8037e5e:	f7fe fddc 	bl	8036a1a <RegionCommonValueInRange>
 8037e62:	3800      	subs	r0, #0
 8037e64:	bf18      	it	ne
 8037e66:	2001      	movne	r0, #1
}
 8037e68:	bd08      	pop	{r3, pc}
            return RegionCommonValueInRange( verify->TxPower, US915_MAX_TX_POWER, US915_MIN_TX_POWER );
 8037e6a:	220e      	movs	r2, #14
 8037e6c:	e7f1      	b.n	8037e52 <RegionUS915Verify+0x22>
{
 8037e6e:	2000      	movs	r0, #0
 8037e70:	e7fa      	b.n	8037e68 <RegionUS915Verify+0x38>
	...

08037e74 <RegionUS915ApplyCFList>:

void RegionUS915ApplyCFList( ApplyCFListParams_t* applyCFList )
{
 8037e74:	b5f0      	push	{r4, r5, r6, r7, lr}
#if defined( REGION_US915 )
    // Size of the optional CF list must be 16 byte
    if( applyCFList->Size != 16 )
 8037e76:	7903      	ldrb	r3, [r0, #4]
 8037e78:	2b10      	cmp	r3, #16
 8037e7a:	d122      	bne.n	8037ec2 <RegionUS915ApplyCFList+0x4e>
    {
        return;
    }

    // Last byte CFListType must be 0x01 to indicate the CFList contains a series of ChMask fields
    if( applyCFList->Payload[15] != 0x01 )
 8037e7c:	6804      	ldr	r4, [r0, #0]
 8037e7e:	7be3      	ldrb	r3, [r4, #15]
 8037e80:	2b01      	cmp	r3, #1
 8037e82:	d11e      	bne.n	8037ec2 <RegionUS915ApplyCFList+0x4e>
    }

    // ChMask0 - ChMask4 must be set (every ChMask has 16 bit)
    for( uint8_t chMaskItr = 0, cntPayload = 0; chMaskItr <= 4; chMaskItr++, cntPayload+=2 )
    {
        RegionNvmGroup2->ChannelsMask[chMaskItr] = (uint16_t) (0x00FF & applyCFList->Payload[cntPayload]);
 8037e84:	4b0f      	ldr	r3, [pc, #60]	; (8037ec4 <RegionUS915ApplyCFList+0x50>)
 8037e86:	681d      	ldr	r5, [r3, #0]
 8037e88:	6859      	ldr	r1, [r3, #4]
 8037e8a:	f505 7058 	add.w	r0, r5, #864	; 0x360
 8037e8e:	3190      	adds	r1, #144	; 0x90
        if( chMaskItr == 4 )
        {
            RegionNvmGroup2->ChannelsMask[chMaskItr] = RegionNvmGroup2->ChannelsMask[chMaskItr] & CHANNELS_MASK_500KHZ_MASK;
        }
        // Set the channel mask to the remaining
        RegionNvmGroup1->ChannelsMaskRemaining[chMaskItr] &= RegionNvmGroup2->ChannelsMask[chMaskItr];
 8037e90:	2200      	movs	r2, #0
        RegionNvmGroup2->ChannelsMask[chMaskItr] |= (uint16_t) (applyCFList->Payload[cntPayload+1] << 8);
 8037e92:	1c67      	adds	r7, r4, #1
        RegionNvmGroup2->ChannelsMask[chMaskItr] = (uint16_t) (0x00FF & applyCFList->Payload[cntPayload]);
 8037e94:	f814 3012 	ldrb.w	r3, [r4, r2, lsl #1]
 8037e98:	8003      	strh	r3, [r0, #0]
        RegionNvmGroup2->ChannelsMask[chMaskItr] |= (uint16_t) (applyCFList->Payload[cntPayload+1] << 8);
 8037e9a:	f817 6012 	ldrb.w	r6, [r7, r2, lsl #1]
        if( chMaskItr == 4 )
 8037e9e:	2a04      	cmp	r2, #4
        RegionNvmGroup2->ChannelsMask[chMaskItr] |= (uint16_t) (applyCFList->Payload[cntPayload+1] << 8);
 8037ea0:	ea43 2306 	orr.w	r3, r3, r6, lsl #8
 8037ea4:	f820 3b02 	strh.w	r3, [r0], #2
            RegionNvmGroup2->ChannelsMask[chMaskItr] = RegionNvmGroup2->ChannelsMask[chMaskItr] & CHANNELS_MASK_500KHZ_MASK;
 8037ea8:	bf04      	itt	eq
 8037eaa:	b2db      	uxtbeq	r3, r3
 8037eac:	f8a5 3368 	strheq.w	r3, [r5, #872]	; 0x368
        RegionNvmGroup1->ChannelsMaskRemaining[chMaskItr] &= RegionNvmGroup2->ChannelsMask[chMaskItr];
 8037eb0:	880b      	ldrh	r3, [r1, #0]
 8037eb2:	f830 6c02 	ldrh.w	r6, [r0, #-2]
 8037eb6:	3201      	adds	r2, #1
 8037eb8:	4033      	ands	r3, r6
    for( uint8_t chMaskItr = 0, cntPayload = 0; chMaskItr <= 4; chMaskItr++, cntPayload+=2 )
 8037eba:	2a05      	cmp	r2, #5
        RegionNvmGroup1->ChannelsMaskRemaining[chMaskItr] &= RegionNvmGroup2->ChannelsMask[chMaskItr];
 8037ebc:	f821 3b02 	strh.w	r3, [r1], #2
    for( uint8_t chMaskItr = 0, cntPayload = 0; chMaskItr <= 4; chMaskItr++, cntPayload+=2 )
 8037ec0:	d1e8      	bne.n	8037e94 <RegionUS915ApplyCFList+0x20>
    }
#endif /* REGION_US915 */
}
 8037ec2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8037ec4:	20005730 	.word	0x20005730

08037ec8 <RegionUS915ChanMaskSet>:

bool RegionUS915ChanMaskSet( ChanMaskSetParams_t* chanMaskSet )
{
 8037ec8:	b570      	push	{r4, r5, r6, lr}
#if defined( REGION_US915 )
    uint8_t nbChannels = RegionCommonCountChannels( chanMaskSet->ChannelsMaskIn, 0, 4 );
 8037eca:	2204      	movs	r2, #4
{
 8037ecc:	4605      	mov	r5, r0
    uint8_t nbChannels = RegionCommonCountChannels( chanMaskSet->ChannelsMaskIn, 0, 4 );
 8037ece:	2100      	movs	r1, #0
 8037ed0:	6800      	ldr	r0, [r0, #0]
 8037ed2:	f7fe fdc4 	bl	8036a5e <RegionCommonCountChannels>

    // Check the number of active channels
    if( ( nbChannels < 2 ) &&
 8037ed6:	2801      	cmp	r0, #1
 8037ed8:	d003      	beq.n	8037ee2 <RegionUS915ChanMaskSet+0x1a>
        ( nbChannels > 0 ) )
    {
        return false;
    }

    switch( chanMaskSet->ChannelsMaskType )
 8037eda:	792c      	ldrb	r4, [r5, #4]
 8037edc:	b11c      	cbz	r4, 8037ee6 <RegionUS915ChanMaskSet+0x1e>
 8037ede:	2c01      	cmp	r4, #1
 8037ee0:	d020      	beq.n	8037f24 <RegionUS915ChanMaskSet+0x5c>
        return false;
 8037ee2:	2000      	movs	r0, #0
 8037ee4:	e01d      	b.n	8037f22 <RegionUS915ChanMaskSet+0x5a>
    {
        case CHANNELS_MASK:
        {
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, chanMaskSet->ChannelsMaskIn, CHANNELS_MASK_SIZE );
 8037ee6:	4e14      	ldr	r6, [pc, #80]	; (8037f38 <RegionUS915ChanMaskSet+0x70>)
 8037ee8:	6829      	ldr	r1, [r5, #0]
 8037eea:	6830      	ldr	r0, [r6, #0]
 8037eec:	2206      	movs	r2, #6
 8037eee:	f500 7058 	add.w	r0, r0, #864	; 0x360
 8037ef2:	f7fe fdd2 	bl	8036a9a <RegionCommonChanMaskCopy>

            RegionNvmGroup2->ChannelsDefaultMask[4] = RegionNvmGroup2->ChannelsDefaultMask[4] & CHANNELS_MASK_500KHZ_MASK;
 8037ef6:	6833      	ldr	r3, [r6, #0]
 8037ef8:	f893 2374 	ldrb.w	r2, [r3, #884]	; 0x374
 8037efc:	f8a3 2374 	strh.w	r2, [r3, #884]	; 0x374
            RegionNvmGroup2->ChannelsDefaultMask[5] = 0x0000;

            for( uint8_t i = 0; i < CHANNELS_MASK_SIZE; i++ )
            { // Copy-And the channels mask
                RegionNvmGroup1->ChannelsMaskRemaining[i] &= RegionNvmGroup2->ChannelsMask[i];
 8037f00:	6872      	ldr	r2, [r6, #4]
            RegionNvmGroup2->ChannelsDefaultMask[5] = 0x0000;
 8037f02:	f8a3 4376 	strh.w	r4, [r3, #886]	; 0x376
            for( uint8_t i = 0; i < CHANNELS_MASK_SIZE; i++ )
 8037f06:	f102 0190 	add.w	r1, r2, #144	; 0x90
 8037f0a:	f503 7358 	add.w	r3, r3, #864	; 0x360
 8037f0e:	329c      	adds	r2, #156	; 0x9c
                RegionNvmGroup1->ChannelsMaskRemaining[i] &= RegionNvmGroup2->ChannelsMask[i];
 8037f10:	8808      	ldrh	r0, [r1, #0]
 8037f12:	f833 4b02 	ldrh.w	r4, [r3], #2
 8037f16:	4020      	ands	r0, r4
 8037f18:	f821 0b02 	strh.w	r0, [r1], #2
            for( uint8_t i = 0; i < CHANNELS_MASK_SIZE; i++ )
 8037f1c:	4291      	cmp	r1, r2
 8037f1e:	d1f7      	bne.n	8037f10 <RegionUS915ChanMaskSet+0x48>
            break;
        }
        default:
            return false;
    }
    return true;
 8037f20:	2001      	movs	r0, #1
#else
    return false;
#endif /* REGION_US915 */
}
 8037f22:	bd70      	pop	{r4, r5, r6, pc}
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsDefaultMask, chanMaskSet->ChannelsMaskIn, CHANNELS_MASK_SIZE );
 8037f24:	4b04      	ldr	r3, [pc, #16]	; (8037f38 <RegionUS915ChanMaskSet+0x70>)
 8037f26:	6829      	ldr	r1, [r5, #0]
 8037f28:	6818      	ldr	r0, [r3, #0]
 8037f2a:	2206      	movs	r2, #6
 8037f2c:	f500 705b 	add.w	r0, r0, #876	; 0x36c
 8037f30:	f7fe fdb3 	bl	8036a9a <RegionCommonChanMaskCopy>
            break;
 8037f34:	e7f4      	b.n	8037f20 <RegionUS915ChanMaskSet+0x58>
 8037f36:	bf00      	nop
 8037f38:	20005730 	.word	0x20005730

08037f3c <RegionUS915ComputeRxWindowParameters>:

void RegionUS915ComputeRxWindowParameters( int8_t datarate, uint8_t minRxSymbols, uint32_t rxError, RxConfigParams_t *rxConfigParams )
{
 8037f3c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
#if defined( REGION_US915 )
    uint32_t tSymbolInUs = 0;

    // Get the datarate, perform a boundary check
    rxConfigParams->Datarate = MIN( datarate, US915_RX_MAX_DATARATE );
 8037f3e:	280d      	cmp	r0, #13
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsUS915 );
 8037f40:	4d12      	ldr	r5, [pc, #72]	; (8037f8c <RegionUS915ComputeRxWindowParameters+0x50>)
    rxConfigParams->Datarate = MIN( datarate, US915_RX_MAX_DATARATE );
 8037f42:	bfa8      	it	ge
 8037f44:	200d      	movge	r0, #13
{
 8037f46:	461c      	mov	r4, r3
 8037f48:	460e      	mov	r6, r1
    rxConfigParams->Datarate = MIN( datarate, US915_RX_MAX_DATARATE );
 8037f4a:	7058      	strb	r0, [r3, #1]
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsUS915 );
 8037f4c:	f105 0110 	add.w	r1, r5, #16
{
 8037f50:	4617      	mov	r7, r2
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsUS915 );
 8037f52:	f7ff f821 	bl	8036f98 <RegionCommonGetBandwidth>

    tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesUS915[rxConfigParams->Datarate], BandwidthsUS915[rxConfigParams->Datarate] );
 8037f56:	f994 3001 	ldrsb.w	r3, [r4, #1]
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsUS915 );
 8037f5a:	70a0      	strb	r0, [r4, #2]
    tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesUS915[rxConfigParams->Datarate], BandwidthsUS915[rxConfigParams->Datarate] );
 8037f5c:	eb05 0283 	add.w	r2, r5, r3, lsl #2
 8037f60:	5ce8      	ldrb	r0, [r5, r3]
 8037f62:	6911      	ldr	r1, [r2, #16]
 8037f64:	f7fe ff14 	bl	8036d90 <RegionCommonComputeSymbolTimeLoRa>

    RegionCommonComputeRxWindowParameters( tSymbolInUs, minRxSymbols, rxError, Radio.GetWakeupTime( ), &rxConfigParams->WindowTimeout, &rxConfigParams->WindowOffset );
 8037f68:	4b09      	ldr	r3, [pc, #36]	; (8037f90 <RegionUS915ComputeRxWindowParameters+0x54>)
 8037f6a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesUS915[rxConfigParams->Datarate], BandwidthsUS915[rxConfigParams->Datarate] );
 8037f6c:	4605      	mov	r5, r0
    RegionCommonComputeRxWindowParameters( tSymbolInUs, minRxSymbols, rxError, Radio.GetWakeupTime( ), &rxConfigParams->WindowTimeout, &rxConfigParams->WindowOffset );
 8037f6e:	4798      	blx	r3
 8037f70:	f104 020c 	add.w	r2, r4, #12
 8037f74:	3408      	adds	r4, #8
 8037f76:	4603      	mov	r3, r0
 8037f78:	9201      	str	r2, [sp, #4]
 8037f7a:	9400      	str	r4, [sp, #0]
 8037f7c:	463a      	mov	r2, r7
 8037f7e:	4631      	mov	r1, r6
 8037f80:	4628      	mov	r0, r5
 8037f82:	f7fe ff12 	bl	8036daa <RegionCommonComputeRxWindowParameters>
#endif /* REGION_US915 */
}
 8037f86:	b003      	add	sp, #12
 8037f88:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8037f8a:	bf00      	nop
 8037f8c:	0803bb58 	.word	0x0803bb58
 8037f90:	0803bc30 	.word	0x0803bc30

08037f94 <RegionUS915RxConfig>:

bool RegionUS915RxConfig( RxConfigParams_t* rxConfig, int8_t* datarate )
{
 8037f94:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int8_t dr = rxConfig->Datarate;
    uint8_t maxPayload = 0;
    int8_t phyDr = 0;
    uint32_t frequency = rxConfig->Frequency;

    if( Radio.GetStatus( ) != RF_IDLE )
 8037f98:	4e24      	ldr	r6, [pc, #144]	; (803802c <RegionUS915RxConfig+0x98>)
    int8_t dr = rxConfig->Datarate;
 8037f9a:	f990 9001 	ldrsb.w	r9, [r0, #1]
    if( Radio.GetStatus( ) != RF_IDLE )
 8037f9e:	6873      	ldr	r3, [r6, #4]
    uint32_t frequency = rxConfig->Frequency;
 8037fa0:	6845      	ldr	r5, [r0, #4]
{
 8037fa2:	b08b      	sub	sp, #44	; 0x2c
 8037fa4:	4604      	mov	r4, r0
 8037fa6:	468a      	mov	sl, r1
    if( Radio.GetStatus( ) != RF_IDLE )
 8037fa8:	4798      	blx	r3
 8037faa:	2800      	cmp	r0, #0
 8037fac:	d13c      	bne.n	8038028 <RegionUS915RxConfig+0x94>
    {
        return false;
    }

    if( rxConfig->RxSlot == RX_SLOT_WIN_1 )
 8037fae:	7ce3      	ldrb	r3, [r4, #19]
 8037fb0:	b933      	cbnz	r3, 8037fc0 <RegionUS915RxConfig+0x2c>
    {
        // Apply window 1 frequency
        frequency = US915_FIRST_RX1_CHANNEL + ( rxConfig->Channel % 8 ) * US915_STEPWIDTH_RX1_CHANNEL;
 8037fb2:	7825      	ldrb	r5, [r4, #0]
 8037fb4:	4a1e      	ldr	r2, [pc, #120]	; (8038030 <RegionUS915RxConfig+0x9c>)
 8037fb6:	4b1f      	ldr	r3, [pc, #124]	; (8038034 <RegionUS915RxConfig+0xa0>)
 8037fb8:	f005 0507 	and.w	r5, r5, #7
 8037fbc:	fb02 3505 	mla	r5, r2, r5, r3
    }

    // Read the physical datarate from the datarates table
    phyDr = DataratesUS915[dr];
 8037fc0:	f8df 8074 	ldr.w	r8, [pc, #116]	; 8038038 <RegionUS915RxConfig+0xa4>

    Radio.SetChannel( frequency );
 8037fc4:	68f3      	ldr	r3, [r6, #12]
    phyDr = DataratesUS915[dr];
 8037fc6:	f918 b009 	ldrsb.w	fp, [r8, r9]
    Radio.SetChannel( frequency );
 8037fca:	4628      	mov	r0, r5
 8037fcc:	4798      	blx	r3

    // Radio configuration
    Radio.SetRxConfig( MODEM_LORA, rxConfig->Bandwidth, phyDr, 1, 0, 8, rxConfig->WindowTimeout, false, 0, false, 0, 0, true, rxConfig->RxContinuous );
 8037fce:	8922      	ldrh	r2, [r4, #8]
 8037fd0:	9202      	str	r2, [sp, #8]
 8037fd2:	2000      	movs	r0, #0
 8037fd4:	2208      	movs	r2, #8
 8037fd6:	e9cd 0200 	strd	r0, r2, [sp]
 8037fda:	7ca3      	ldrb	r3, [r4, #18]
 8037fdc:	69b2      	ldr	r2, [r6, #24]
 8037fde:	9309      	str	r3, [sp, #36]	; 0x24
 8037fe0:	2301      	movs	r3, #1
 8037fe2:	e9cd 0307 	strd	r0, r3, [sp, #28]
 8037fe6:	e9cd 0005 	strd	r0, r0, [sp, #20]
 8037fea:	e9cd 0003 	strd	r0, r0, [sp, #12]
 8037fee:	4617      	mov	r7, r2
 8037ff0:	4618      	mov	r0, r3
 8037ff2:	78a1      	ldrb	r1, [r4, #2]
 8037ff4:	465a      	mov	r2, fp
 8037ff6:	47b8      	blx	r7

    /* ST_WORKAROUND_BEGIN: Keep repeater feature */
    if( rxConfig->RepeaterSupport == true )
 8037ff8:	7c63      	ldrb	r3, [r4, #17]
 8037ffa:	44c8      	add	r8, r9
 8037ffc:	b18b      	cbz	r3, 8038022 <RegionUS915RxConfig+0x8e>
    {
        maxPayload = MaxPayloadOfDatarateRepeaterUS915[dr];
 8037ffe:	f898 1060 	ldrb.w	r1, [r8, #96]	; 0x60
    else
    {
        maxPayload = MaxPayloadOfDatarateUS915[dr];
    }

    Radio.SetMaxPayloadLength( MODEM_LORA, maxPayload + LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE );
 8038002:	6d73      	ldr	r3, [r6, #84]	; 0x54
 8038004:	310d      	adds	r1, #13
 8038006:	b2c9      	uxtb	r1, r1
 8038008:	2001      	movs	r0, #1
 803800a:	4798      	blx	r3
    /* ST_WORKAROUND_END */

    /* ST_WORKAROUND_BEGIN: Print Rx config */
    RegionCommonRxConfigPrint(rxConfig->RxSlot, frequency, dr);
 803800c:	7ce0      	ldrb	r0, [r4, #19]
 803800e:	464a      	mov	r2, r9
 8038010:	4629      	mov	r1, r5
 8038012:	f7fe ffd3 	bl	8036fbc <RegionCommonRxConfigPrint>
    /* ST_WORKAROUND_END */

    *datarate = (uint8_t) dr;
 8038016:	f88a 9000 	strb.w	r9, [sl]
    return true;
 803801a:	2001      	movs	r0, #1
#else
    return false;
#endif /* REGION_US915 */
}
 803801c:	b00b      	add	sp, #44	; 0x2c
 803801e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        maxPayload = MaxPayloadOfDatarateUS915[dr];
 8038022:	f898 1050 	ldrb.w	r1, [r8, #80]	; 0x50
 8038026:	e7ec      	b.n	8038002 <RegionUS915RxConfig+0x6e>
        return false;
 8038028:	2000      	movs	r0, #0
 803802a:	e7f7      	b.n	803801c <RegionUS915RxConfig+0x88>
 803802c:	0803bc30 	.word	0x0803bc30
 8038030:	000927c0 	.word	0x000927c0
 8038034:	370870a0 	.word	0x370870a0
 8038038:	0803bb58 	.word	0x0803bb58

0803803c <RegionUS915TxConfig>:

bool RegionUS915TxConfig( TxConfigParams_t* txConfig, int8_t* txPower, TimerTime_t* txTimeOnAir )
{
 803803c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if defined( REGION_US915 )
    int8_t phyDr = DataratesUS915[txConfig->Datarate];
    int8_t txPowerLimited = LimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower, txConfig->Datarate, RegionNvmGroup2->ChannelsMask );
 8038040:	4e3d      	ldr	r6, [pc, #244]	; (8038138 <RegionUS915TxConfig+0xfc>)
    int8_t phyDr = DataratesUS915[txConfig->Datarate];
 8038042:	f990 b001 	ldrsb.w	fp, [r0, #1]
 8038046:	4b3d      	ldr	r3, [pc, #244]	; (803813c <RegionUS915TxConfig+0x100>)
    int8_t txPowerLimited = LimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower, txConfig->Datarate, RegionNvmGroup2->ChannelsMask );
 8038048:	f990 8002 	ldrsb.w	r8, [r0, #2]
    int8_t phyDr = DataratesUS915[txConfig->Datarate];
 803804c:	f913 700b 	ldrsb.w	r7, [r3, fp]
    int8_t txPowerLimited = LimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower, txConfig->Datarate, RegionNvmGroup2->ChannelsMask );
 8038050:	7803      	ldrb	r3, [r0, #0]
{
 8038052:	b08f      	sub	sp, #60	; 0x3c
 8038054:	4692      	mov	sl, r2
    int8_t txPowerLimited = LimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower, txConfig->Datarate, RegionNvmGroup2->ChannelsMask );
 8038056:	e9d6 9200 	ldrd	r9, r2, [r6]
{
 803805a:	910b      	str	r1, [sp, #44]	; 0x2c
    int8_t txPowerLimited = LimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower, txConfig->Datarate, RegionNvmGroup2->ChannelsMask );
 803805c:	210c      	movs	r1, #12
 803805e:	fb01 9303 	mla	r3, r1, r3, r9
 8038062:	2118      	movs	r1, #24
 8038064:	7a5b      	ldrb	r3, [r3, #9]
 8038066:	fb01 2303 	mla	r3, r1, r3, r2
{
 803806a:	4604      	mov	r4, r0
    txPowerResult =  RegionCommonLimitTxPower( txPower, maxBandTxPower );
 803806c:	f993 1002 	ldrsb.w	r1, [r3, #2]
 8038070:	4640      	mov	r0, r8
 8038072:	f7fe ff8d 	bl	8036f90 <RegionCommonLimitTxPower>
    if( datarate == DR_4 )
 8038076:	f1bb 0f04 	cmp.w	fp, #4
    txPowerResult =  RegionCommonLimitTxPower( txPower, maxBandTxPower );
 803807a:	4605      	mov	r5, r0
    if( datarate == DR_4 )
 803807c:	d14e      	bne.n	803811c <RegionUS915TxConfig+0xe0>
        txPowerResult = MAX( txPower, TX_POWER_2 );
 803807e:	4645      	mov	r5, r8
 8038080:	2d02      	cmp	r5, #2
 8038082:	bfb8      	it	lt
 8038084:	2502      	movlt	r5, #2
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsUS915 );
 8038086:	492e      	ldr	r1, [pc, #184]	; (8038140 <RegionUS915TxConfig+0x104>)
 8038088:	f994 0001 	ldrsb.w	r0, [r4, #1]

    // Calculate physical TX power
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );

    // Setup the radio frequency
    Radio.SetChannel( RegionNvmGroup2->Channels[txConfig->Channel].Frequency );
 803808c:	f8df b0b8 	ldr.w	fp, [pc, #184]	; 8038148 <RegionUS915TxConfig+0x10c>
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsUS915 );
 8038090:	f7fe ff82 	bl	8036f98 <RegionCommonGetBandwidth>
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );
 8038094:	492b      	ldr	r1, [pc, #172]	; (8038144 <RegionUS915TxConfig+0x108>)
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsUS915 );
 8038096:	900d      	str	r0, [sp, #52]	; 0x34
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );
 8038098:	2200      	movs	r2, #0
 803809a:	4628      	mov	r0, r5
 803809c:	f7fe fead 	bl	8036dfa <RegionCommonComputeTxPower>
    Radio.SetChannel( RegionNvmGroup2->Channels[txConfig->Channel].Frequency );
 80380a0:	f894 c000 	ldrb.w	ip, [r4]
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );
 80380a4:	900c      	str	r0, [sp, #48]	; 0x30
    Radio.SetChannel( RegionNvmGroup2->Channels[txConfig->Channel].Frequency );
 80380a6:	f04f 090c 	mov.w	r9, #12
 80380aa:	fb09 fc0c 	mul.w	ip, r9, ip
 80380ae:	6830      	ldr	r0, [r6, #0]
 80380b0:	f8db 200c 	ldr.w	r2, [fp, #12]
 80380b4:	f850 000c 	ldr.w	r0, [r0, ip]
 80380b8:	4790      	blx	r2

    Radio.SetTxConfig( MODEM_LORA, phyTxPower, 0, bandwidth, phyDr, 1, 8, false, true, 0, 0, false, 4000 );
 80380ba:	f04f 0801 	mov.w	r8, #1
 80380be:	2200      	movs	r2, #0
 80380c0:	f44f 637a 	mov.w	r3, #4000	; 0xfa0
 80380c4:	2008      	movs	r0, #8
 80380c6:	e9cd 2307 	strd	r2, r3, [sp, #28]
 80380ca:	e9cd 2205 	strd	r2, r2, [sp, #20]
 80380ce:	e9dd 130c 	ldrd	r1, r3, [sp, #48]	; 0x30
 80380d2:	e9cd 2803 	strd	r2, r8, [sp, #12]
 80380d6:	e9cd 8001 	strd	r8, r0, [sp, #4]
 80380da:	9700      	str	r7, [sp, #0]
 80380dc:	4640      	mov	r0, r8
 80380de:	f8db 701c 	ldr.w	r7, [fp, #28]
 80380e2:	47b8      	blx	r7
    /* ST_WORKAROUND_BEGIN: Print Tx config */
    RegionCommonTxConfigPrint(RegionNvmGroup2->Channels[txConfig->Channel].Frequency, txConfig->Datarate);
 80380e4:	7822      	ldrb	r2, [r4, #0]
 80380e6:	6833      	ldr	r3, [r6, #0]
 80380e8:	f994 1001 	ldrsb.w	r1, [r4, #1]
 80380ec:	fb09 f902 	mul.w	r9, r9, r2
 80380f0:	f853 0009 	ldr.w	r0, [r3, r9]
 80380f4:	f7fe ff90 	bl	8037018 <RegionCommonTxConfigPrint>
    /* ST_WORKAROUND_END */

    // Setup maximum payload length of the radio driver
    Radio.SetMaxPayloadLength( MODEM_LORA, txConfig->PktLen );
 80380f8:	f8db 3054 	ldr.w	r3, [fp, #84]	; 0x54
 80380fc:	7b21      	ldrb	r1, [r4, #12]
 80380fe:	4640      	mov	r0, r8
 8038100:	4798      	blx	r3

    // Update time-on-air
    *txTimeOnAir = GetTimeOnAir( txConfig->Datarate, txConfig->PktLen );
 8038102:	89a1      	ldrh	r1, [r4, #12]
 8038104:	f994 0001 	ldrsb.w	r0, [r4, #1]
 8038108:	f7ff fd12 	bl	8037b30 <GetTimeOnAir>

    *txPower = txPowerLimited;
 803810c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    *txTimeOnAir = GetTimeOnAir( txConfig->Datarate, txConfig->PktLen );
 803810e:	f8ca 0000 	str.w	r0, [sl]
    return true;
#else
    return false;
#endif /* REGION_US915 */
}
 8038112:	4640      	mov	r0, r8
    *txPower = txPowerLimited;
 8038114:	701d      	strb	r5, [r3, #0]
}
 8038116:	b00f      	add	sp, #60	; 0x3c
 8038118:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if( RegionCommonCountChannels( channelsMask, 0, 4 ) < 50 )
 803811c:	2204      	movs	r2, #4
 803811e:	2100      	movs	r1, #0
 8038120:	f509 7058 	add.w	r0, r9, #864	; 0x360
 8038124:	f7fe fc9b 	bl	8036a5e <RegionCommonCountChannels>
 8038128:	2831      	cmp	r0, #49	; 0x31
 803812a:	d8ac      	bhi.n	8038086 <RegionUS915TxConfig+0x4a>
            txPowerResult = MAX( txPower, TX_POWER_5 );
 803812c:	4645      	mov	r5, r8
 803812e:	2d05      	cmp	r5, #5
 8038130:	bfb8      	it	lt
 8038132:	2505      	movlt	r5, #5
 8038134:	e7a7      	b.n	8038086 <RegionUS915TxConfig+0x4a>
 8038136:	bf00      	nop
 8038138:	20005730 	.word	0x20005730
 803813c:	0803bb58 	.word	0x0803bb58
 8038140:	0803bb68 	.word	0x0803bb68
 8038144:	41f00000 	.word	0x41f00000
 8038148:	0803bc30 	.word	0x0803bc30

0803814c <RegionUS915LinkAdrReq>:

uint8_t RegionUS915LinkAdrReq( LinkAdrReqParams_t* linkAdrReq, int8_t* drOut, int8_t* txPowOut, uint8_t* nbRepOut, uint8_t* nbBytesParsed )
{
 803814c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;
    RegionCommonLinkAdrReqVerifyParams_t linkAdrVerifyParams;

    // Initialize local copy of channels mask
    RegionCommonChanMaskCopy( channelsMask, RegionNvmGroup2->ChannelsMask, CHANNELS_MASK_SIZE );
 8038150:	4e88      	ldr	r6, [pc, #544]	; (8038374 <RegionUS915LinkAdrReq+0x228>)
{
 8038152:	b095      	sub	sp, #84	; 0x54
 8038154:	e9cd 1201 	strd	r1, r2, [sp, #4]
    RegionCommonChanMaskCopy( channelsMask, RegionNvmGroup2->ChannelsMask, CHANNELS_MASK_SIZE );
 8038158:	6831      	ldr	r1, [r6, #0]
{
 803815a:	9303      	str	r3, [sp, #12]
    uint16_t channelsMask[CHANNELS_MASK_SIZE] = { 0, 0, 0, 0, 0, 0 };
 803815c:	af09      	add	r7, sp, #36	; 0x24
    RegionCommonLinkAdrParams_t linkAdrParams = { 0 };
 803815e:	2400      	movs	r4, #0
{
 8038160:	4605      	mov	r5, r0
    RegionCommonChanMaskCopy( channelsMask, RegionNvmGroup2->ChannelsMask, CHANNELS_MASK_SIZE );
 8038162:	2206      	movs	r2, #6
 8038164:	f501 7158 	add.w	r1, r1, #864	; 0x360
 8038168:	4638      	mov	r0, r7
    uint16_t channelsMask[CHANNELS_MASK_SIZE] = { 0, 0, 0, 0, 0, 0 };
 803816a:	e9c7 4401 	strd	r4, r4, [r7, #4]
    RegionCommonLinkAdrParams_t linkAdrParams = { 0 };
 803816e:	9407      	str	r4, [sp, #28]
 8038170:	f8ad 4020 	strh.w	r4, [sp, #32]
    uint16_t channelsMask[CHANNELS_MASK_SIZE] = { 0, 0, 0, 0, 0, 0 };
 8038174:	9409      	str	r4, [sp, #36]	; 0x24
    RegionCommonChanMaskCopy( channelsMask, RegionNvmGroup2->ChannelsMask, CHANNELS_MASK_SIZE );
 8038176:	f7fe fc90 	bl	8036a9a <RegionCommonChanMaskCopy>
            channelsMask[4] = linkAdrParams.ChMask & CHANNELS_MASK_500KHZ_MASK;
        }
        else if( linkAdrParams.ChMaskCtrl == 7 )
        {
            // Disable all 125 kHz channels
            channelsMask[0] = 0x0000;
 803817a:	46a0      	mov	r8, r4
            channelsMask[0] = 0xFFFF;
 803817c:	f04f 39ff 	mov.w	r9, #4294967295
    while( bytesProcessed < linkAdrReq->PayloadSize )
 8038180:	7a2b      	ldrb	r3, [r5, #8]
 8038182:	42a3      	cmp	r3, r4
 8038184:	d907      	bls.n	8038196 <RegionUS915LinkAdrReq+0x4a>
        nextIndex = RegionCommonParseLinkAdrReq( &( linkAdrReq->Payload[bytesProcessed] ), &linkAdrParams );
 8038186:	6868      	ldr	r0, [r5, #4]
 8038188:	a907      	add	r1, sp, #28
 803818a:	4420      	add	r0, r4
 803818c:	f7fe fda6 	bl	8036cdc <RegionCommonParseLinkAdrReq>
        if( nextIndex == 0 )
 8038190:	2800      	cmp	r0, #0
 8038192:	f040 808c 	bne.w	80382ae <RegionUS915LinkAdrReq+0x162>
            channelsMask[linkAdrParams.ChMaskCtrl] = linkAdrParams.ChMask;
        }
    }

    // FCC 15.247 paragraph F mandates to hop on at least 2 125 kHz channels
    if( ( linkAdrParams.Datarate < DR_4 ) && ( RegionCommonCountChannels( channelsMask, 0, 4 ) < 2 ) )
 8038196:	f99d 301d 	ldrsb.w	r3, [sp, #29]
 803819a:	2b03      	cmp	r3, #3
 803819c:	dc07      	bgt.n	80381ae <RegionUS915LinkAdrReq+0x62>
 803819e:	2204      	movs	r2, #4
 80381a0:	2100      	movs	r1, #0
 80381a2:	a809      	add	r0, sp, #36	; 0x24
 80381a4:	f7fe fc5b 	bl	8036a5e <RegionCommonCountChannels>
 80381a8:	2801      	cmp	r0, #1
 80381aa:	f240 80df 	bls.w	803836c <RegionUS915LinkAdrReq+0x220>
    uint8_t bytesProcessed = 0;
 80381ae:	f04f 0807 	mov.w	r8, #7
    {
        status &= 0xFE; // Channel mask KO
    }

    // Get the minimum possible datarate
    getPhy.Attribute = PHY_MIN_TX_DR;
 80381b2:	2302      	movs	r3, #2
 80381b4:	f88d 3014 	strb.w	r3, [sp, #20]
    getPhy.UplinkDwellTime = linkAdrReq->UplinkDwellTime;
    phyParam = RegionUS915GetPhyParam( &getPhy );
 80381b8:	a805      	add	r0, sp, #20
    getPhy.UplinkDwellTime = linkAdrReq->UplinkDwellTime;
 80381ba:	7a6b      	ldrb	r3, [r5, #9]
 80381bc:	f88d 3016 	strb.w	r3, [sp, #22]
    phyParam = RegionUS915GetPhyParam( &getPhy );
 80381c0:	f7ff fcf2 	bl	8037ba8 <RegionUS915GetPhyParam>

    linkAdrVerifyParams.Status = status;
    linkAdrVerifyParams.AdrEnabled = linkAdrReq->AdrEnabled;
 80381c4:	7aab      	ldrb	r3, [r5, #10]
 80381c6:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
    linkAdrVerifyParams.Datarate = linkAdrParams.Datarate;
 80381ca:	f89d 301d 	ldrb.w	r3, [sp, #29]
 80381ce:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    linkAdrVerifyParams.TxPower = linkAdrParams.TxPower;
 80381d2:	f89d 301e 	ldrb.w	r3, [sp, #30]
 80381d6:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    linkAdrVerifyParams.NbRep = linkAdrParams.NbRep;
 80381da:	f89d 301c 	ldrb.w	r3, [sp, #28]
 80381de:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
    linkAdrVerifyParams.CurrentDatarate = linkAdrReq->CurrentDatarate;
 80381e2:	7aeb      	ldrb	r3, [r5, #11]
 80381e4:	f88d 3039 	strb.w	r3, [sp, #57]	; 0x39
    linkAdrVerifyParams.CurrentTxPower = linkAdrReq->CurrentTxPower;
 80381e8:	7b2b      	ldrb	r3, [r5, #12]
 80381ea:	f88d 303a 	strb.w	r3, [sp, #58]	; 0x3a
    linkAdrVerifyParams.CurrentNbRep = linkAdrReq->CurrentNbRep;
 80381ee:	7b6b      	ldrb	r3, [r5, #13]
 80381f0:	f88d 303b 	strb.w	r3, [sp, #59]	; 0x3b
    linkAdrVerifyParams.NbChannels = US915_MAX_NB_CHANNELS;
 80381f4:	2348      	movs	r3, #72	; 0x48
 80381f6:	f88d 303c 	strb.w	r3, [sp, #60]	; 0x3c
    linkAdrVerifyParams.ChannelsMask = channelsMask;
    linkAdrVerifyParams.MinDatarate = ( int8_t )phyParam.Value;
    linkAdrVerifyParams.MaxDatarate = US915_TX_MAX_DATARATE;
 80381fa:	2304      	movs	r3, #4
 80381fc:	f88d 3045 	strb.w	r3, [sp, #69]	; 0x45
    linkAdrVerifyParams.Channels = RegionNvmGroup2->Channels;
 8038200:	6833      	ldr	r3, [r6, #0]
 8038202:	9312      	str	r3, [sp, #72]	; 0x48
    linkAdrVerifyParams.MinTxPower = US915_MIN_TX_POWER;
 8038204:	230e      	movs	r3, #14
 8038206:	f8ad 304c 	strh.w	r3, [sp, #76]	; 0x4c
    linkAdrVerifyParams.MaxTxPower = US915_MAX_TX_POWER;
    linkAdrVerifyParams.Version = linkAdrReq->Version;
 803820a:	682b      	ldr	r3, [r5, #0]
    phyParam = RegionUS915GetPhyParam( &getPhy );
 803820c:	9004      	str	r0, [sp, #16]
    linkAdrVerifyParams.MinDatarate = ( int8_t )phyParam.Value;
 803820e:	f88d 0044 	strb.w	r0, [sp, #68]	; 0x44
    linkAdrVerifyParams.Version = linkAdrReq->Version;
 8038212:	930c      	str	r3, [sp, #48]	; 0x30

    // Verify the parameters and update, if necessary
    status = RegionCommonLinkAdrReqVerifyParams( &linkAdrVerifyParams, &linkAdrParams.Datarate, &linkAdrParams.TxPower, &linkAdrParams.NbRep );
 8038214:	f10d 021e 	add.w	r2, sp, #30
 8038218:	ab07      	add	r3, sp, #28
 803821a:	f10d 011d 	add.w	r1, sp, #29
 803821e:	a80c      	add	r0, sp, #48	; 0x30
    linkAdrVerifyParams.Status = status;
 8038220:	f88d 8034 	strb.w	r8, [sp, #52]	; 0x34
    linkAdrVerifyParams.ChannelsMask = channelsMask;
 8038224:	9710      	str	r7, [sp, #64]	; 0x40
    status = RegionCommonLinkAdrReqVerifyParams( &linkAdrVerifyParams, &linkAdrParams.Datarate, &linkAdrParams.TxPower, &linkAdrParams.NbRep );
 8038226:	f7fe fd73 	bl	8036d10 <RegionCommonLinkAdrReqVerifyParams>

    // Update channelsMask if everything is correct
    if( status == 0x07 )
 803822a:	2807      	cmp	r0, #7
    status = RegionCommonLinkAdrReqVerifyParams( &linkAdrVerifyParams, &linkAdrParams.Datarate, &linkAdrParams.TxPower, &linkAdrParams.NbRep );
 803822c:	4605      	mov	r5, r0
    if( status == 0x07 )
 803822e:	d12c      	bne.n	803828a <RegionUS915LinkAdrReq+0x13e>
    {
        // Copy Mask
        RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, channelsMask, 6 );
 8038230:	6830      	ldr	r0, [r6, #0]
 8038232:	2206      	movs	r2, #6
 8038234:	4639      	mov	r1, r7
 8038236:	f500 7058 	add.w	r0, r0, #864	; 0x360
 803823a:	f7fe fc2e 	bl	8036a9a <RegionCommonChanMaskCopy>

        RegionNvmGroup1->ChannelsMaskRemaining[0] &= RegionNvmGroup2->ChannelsMask[0];
 803823e:	e9d6 2300 	ldrd	r2, r3, [r6]
 8038242:	f8b2 0360 	ldrh.w	r0, [r2, #864]	; 0x360
 8038246:	f8b3 1090 	ldrh.w	r1, [r3, #144]	; 0x90
 803824a:	4001      	ands	r1, r0
 803824c:	f8a3 1090 	strh.w	r1, [r3, #144]	; 0x90
        RegionNvmGroup1->ChannelsMaskRemaining[1] &= RegionNvmGroup2->ChannelsMask[1];
 8038250:	f8b2 0362 	ldrh.w	r0, [r2, #866]	; 0x362
 8038254:	f8b3 1092 	ldrh.w	r1, [r3, #146]	; 0x92
 8038258:	4001      	ands	r1, r0
 803825a:	f8a3 1092 	strh.w	r1, [r3, #146]	; 0x92
        RegionNvmGroup1->ChannelsMaskRemaining[2] &= RegionNvmGroup2->ChannelsMask[2];
 803825e:	f8b2 0364 	ldrh.w	r0, [r2, #868]	; 0x364
 8038262:	f8b3 1094 	ldrh.w	r1, [r3, #148]	; 0x94
 8038266:	4001      	ands	r1, r0
 8038268:	f8a3 1094 	strh.w	r1, [r3, #148]	; 0x94
        RegionNvmGroup1->ChannelsMaskRemaining[3] &= RegionNvmGroup2->ChannelsMask[3];
 803826c:	f8b2 0366 	ldrh.w	r0, [r2, #870]	; 0x366
 8038270:	f8b3 1096 	ldrh.w	r1, [r3, #150]	; 0x96
 8038274:	4001      	ands	r1, r0
 8038276:	f8a3 1096 	strh.w	r1, [r3, #150]	; 0x96
        RegionNvmGroup1->ChannelsMaskRemaining[4] = RegionNvmGroup2->ChannelsMask[4];
 803827a:	f8b2 1368 	ldrh.w	r1, [r2, #872]	; 0x368
        RegionNvmGroup1->ChannelsMaskRemaining[5] = RegionNvmGroup2->ChannelsMask[5];
 803827e:	f8b2 236a 	ldrh.w	r2, [r2, #874]	; 0x36a
        RegionNvmGroup1->ChannelsMaskRemaining[4] = RegionNvmGroup2->ChannelsMask[4];
 8038282:	f8a3 1098 	strh.w	r1, [r3, #152]	; 0x98
        RegionNvmGroup1->ChannelsMaskRemaining[5] = RegionNvmGroup2->ChannelsMask[5];
 8038286:	f8a3 209a 	strh.w	r2, [r3, #154]	; 0x9a
    }

    // Update status variables
    *drOut = linkAdrParams.Datarate;
 803828a:	9a01      	ldr	r2, [sp, #4]
 803828c:	f89d 301d 	ldrb.w	r3, [sp, #29]
 8038290:	7013      	strb	r3, [r2, #0]
    *txPowOut = linkAdrParams.TxPower;
 8038292:	9a02      	ldr	r2, [sp, #8]
 8038294:	f89d 301e 	ldrb.w	r3, [sp, #30]
 8038298:	7013      	strb	r3, [r2, #0]
    *nbRepOut = linkAdrParams.NbRep;
 803829a:	9a03      	ldr	r2, [sp, #12]
 803829c:	f89d 301c 	ldrb.w	r3, [sp, #28]
 80382a0:	7013      	strb	r3, [r2, #0]
    *nbBytesParsed = bytesProcessed;
 80382a2:	9b1e      	ldr	r3, [sp, #120]	; 0x78

#endif /* REGION_US915 */
    return status;
}
 80382a4:	4628      	mov	r0, r5
    *nbBytesParsed = bytesProcessed;
 80382a6:	701c      	strb	r4, [r3, #0]
}
 80382a8:	b015      	add	sp, #84	; 0x54
 80382aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if( linkAdrParams.ChMaskCtrl == 6 )
 80382ae:	f89d 301f 	ldrb.w	r3, [sp, #31]
 80382b2:	f8bd 2020 	ldrh.w	r2, [sp, #32]
        bytesProcessed += nextIndex;
 80382b6:	4404      	add	r4, r0
        if( linkAdrParams.ChMaskCtrl == 6 )
 80382b8:	2b06      	cmp	r3, #6
        bytesProcessed += nextIndex;
 80382ba:	b2e4      	uxtb	r4, r4
        if( linkAdrParams.ChMaskCtrl == 6 )
 80382bc:	d105      	bne.n	80382ca <RegionUS915LinkAdrReq+0x17e>
            channelsMask[2] = 0xFFFF;
 80382be:	e9cd 9909 	strd	r9, r9, [sp, #36]	; 0x24
            channelsMask[4] = linkAdrParams.ChMask & CHANNELS_MASK_500KHZ_MASK;
 80382c2:	b2d2      	uxtb	r2, r2
 80382c4:	f8ad 202c 	strh.w	r2, [sp, #44]	; 0x2c
 80382c8:	e75a      	b.n	8038180 <RegionUS915LinkAdrReq+0x34>
        else if( linkAdrParams.ChMaskCtrl == 7 )
 80382ca:	2b07      	cmp	r3, #7
 80382cc:	d102      	bne.n	80382d4 <RegionUS915LinkAdrReq+0x188>
            channelsMask[2] = 0x0000;
 80382ce:	e9cd 8809 	strd	r8, r8, [sp, #36]	; 0x24
 80382d2:	e7f6      	b.n	80382c2 <RegionUS915LinkAdrReq+0x176>
        else if( linkAdrParams.ChMaskCtrl == 5 )
 80382d4:	2b05      	cmp	r3, #5
 80382d6:	d143      	bne.n	8038360 <RegionUS915LinkAdrReq+0x214>
                if( ( ( linkAdrParams.ChMask & 0x00FF ) & ( bitMask << i ) ) != 0 )
 80382d8:	f04f 0c00 	mov.w	ip, #0
 80382dc:	b2d2      	uxtb	r2, r2
            uint8_t cntChannelMask = 0;
 80382de:	4661      	mov	r1, ip
                if( ( ( linkAdrParams.ChMask & 0x00FF ) & ( bitMask << i ) ) != 0 )
 80382e0:	2301      	movs	r3, #1
 80382e2:	fa03 fa0c 	lsl.w	sl, r3, ip
 80382e6:	ea0c 0b03 	and.w	fp, ip, r3
 80382ea:	ab14      	add	r3, sp, #80	; 0x50
 80382ec:	eb03 0e41 	add.w	lr, r3, r1, lsl #1
 80382f0:	ea12 0f0a 	tst.w	r2, sl
 80382f4:	f83e 3c2c 	ldrh.w	r3, [lr, #-44]
 80382f8:	fa0f f08a 	sxth.w	r0, sl
 80382fc:	d01d      	beq.n	803833a <RegionUS915LinkAdrReq+0x1ee>
                    if( ( i % 2 ) == 0 )
 80382fe:	f1bb 0f00 	cmp.w	fp, #0
 8038302:	d10e      	bne.n	8038322 <RegionUS915LinkAdrReq+0x1d6>
                        channelsMask[cntChannelMask] |= 0x00FF;
 8038304:	f043 03ff 	orr.w	r3, r3, #255	; 0xff
 8038308:	f82e 3c2c 	strh.w	r3, [lr, #-44]
                        channelsMask[4] |= ( bitMask << i );
 803830c:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
 8038310:	4318      	orrs	r0, r3
                        channelsMask[4] &= ~( bitMask << i );
 8038312:	f8ad 002c 	strh.w	r0, [sp, #44]	; 0x2c
            for( uint8_t i = 0; i <= 7; i++ )
 8038316:	f10c 0c01 	add.w	ip, ip, #1
 803831a:	f1bc 0f08 	cmp.w	ip, #8
 803831e:	d1df      	bne.n	80382e0 <RegionUS915LinkAdrReq+0x194>
 8038320:	e72e      	b.n	8038180 <RegionUS915LinkAdrReq+0x34>
                        channelsMask[cntChannelMask] |= 0xFF00;
 8038322:	f063 03ff 	orn	r3, r3, #255	; 0xff
 8038326:	f82e 3c2c 	strh.w	r3, [lr, #-44]
                        channelsMask[4] |= ( bitMask << i );
 803832a:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
 803832e:	4318      	orrs	r0, r3
                        cntChannelMask++;
 8038330:	3101      	adds	r1, #1
                        channelsMask[4] &= ~( bitMask << i );
 8038332:	f8ad 002c 	strh.w	r0, [sp, #44]	; 0x2c
                        cntChannelMask++;
 8038336:	b2c9      	uxtb	r1, r1
 8038338:	e7ed      	b.n	8038316 <RegionUS915LinkAdrReq+0x1ca>
                    if( ( i % 2 ) == 0 )
 803833a:	43c0      	mvns	r0, r0
 803833c:	f1bb 0f00 	cmp.w	fp, #0
 8038340:	d107      	bne.n	8038352 <RegionUS915LinkAdrReq+0x206>
                        channelsMask[cntChannelMask] &= 0xFF00;
 8038342:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 8038346:	f82e 3c2c 	strh.w	r3, [lr, #-44]
                        channelsMask[4] &= ~( bitMask << i );
 803834a:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
 803834e:	4018      	ands	r0, r3
 8038350:	e7df      	b.n	8038312 <RegionUS915LinkAdrReq+0x1c6>
                        channelsMask[cntChannelMask] &= 0x00FF;
 8038352:	b2db      	uxtb	r3, r3
 8038354:	f82e 3c2c 	strh.w	r3, [lr, #-44]
                        channelsMask[4] &= ~( bitMask << i );
 8038358:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
 803835c:	4018      	ands	r0, r3
 803835e:	e7e7      	b.n	8038330 <RegionUS915LinkAdrReq+0x1e4>
            channelsMask[linkAdrParams.ChMaskCtrl] = linkAdrParams.ChMask;
 8038360:	a914      	add	r1, sp, #80	; 0x50
 8038362:	eb01 0343 	add.w	r3, r1, r3, lsl #1
 8038366:	f823 2c2c 	strh.w	r2, [r3, #-44]
 803836a:	e709      	b.n	8038180 <RegionUS915LinkAdrReq+0x34>
        status &= 0xFE; // Channel mask KO
 803836c:	f04f 0806 	mov.w	r8, #6
 8038370:	e71f      	b.n	80381b2 <RegionUS915LinkAdrReq+0x66>
 8038372:	bf00      	nop
 8038374:	20005730 	.word	0x20005730

08038378 <RegionUS915RxParamSetupReq>:

uint8_t RegionUS915RxParamSetupReq( RxParamSetupReqParams_t* rxParamSetupReq )
{
 8038378:	b538      	push	{r3, r4, r5, lr}
 803837a:	4605      	mov	r5, r0
    uint8_t status = 0x07;
#if defined( REGION_US915 )

    // Verify radio frequency
    if( VerifyRfFreq( rxParamSetupReq->Frequency ) == false )
 803837c:	6840      	ldr	r0, [r0, #4]
 803837e:	f7ff fbf3 	bl	8037b68 <VerifyRfFreq>
    {
        status &= 0xFE; // Channel frequency KO
    }

    // Verify datarate
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, US915_RX_MIN_DATARATE, US915_RX_MAX_DATARATE ) == false )
 8038382:	220d      	movs	r2, #13
        status &= 0xFE; // Channel frequency KO
 8038384:	2800      	cmp	r0, #0
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, US915_RX_MIN_DATARATE, US915_RX_MAX_DATARATE ) == false )
 8038386:	f04f 0108 	mov.w	r1, #8
 803838a:	f995 0000 	ldrsb.w	r0, [r5]
        status &= 0xFE; // Channel frequency KO
 803838e:	bf14      	ite	ne
 8038390:	2407      	movne	r4, #7
 8038392:	2406      	moveq	r4, #6
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, US915_RX_MIN_DATARATE, US915_RX_MAX_DATARATE ) == false )
 8038394:	f7fe fb41 	bl	8036a1a <RegionCommonValueInRange>
 8038398:	b908      	cbnz	r0, 803839e <RegionUS915RxParamSetupReq+0x26>
    {
        status &= 0xFD; // Datarate KO
 803839a:	f004 0405 	and.w	r4, r4, #5
    }
    if( ( RegionCommonValueInRange( rxParamSetupReq->Datarate, DR_5, DR_7 ) == true ) ||
 803839e:	f995 0000 	ldrsb.w	r0, [r5]
 80383a2:	2207      	movs	r2, #7
 80383a4:	2105      	movs	r1, #5
 80383a6:	f7fe fb38 	bl	8036a1a <RegionCommonValueInRange>
 80383aa:	2801      	cmp	r0, #1
 80383ac:	d003      	beq.n	80383b6 <RegionUS915RxParamSetupReq+0x3e>
 80383ae:	f995 3000 	ldrsb.w	r3, [r5]
 80383b2:	2b0d      	cmp	r3, #13
 80383b4:	dd01      	ble.n	80383ba <RegionUS915RxParamSetupReq+0x42>
        ( rxParamSetupReq->Datarate > DR_13 ) )
    {
        status &= 0xFD; // Datarate KO
 80383b6:	f004 04fd 	and.w	r4, r4, #253	; 0xfd
    }

    // Verify datarate offset
    if( RegionCommonValueInRange( rxParamSetupReq->DrOffset, US915_MIN_RX1_DR_OFFSET, US915_MAX_RX1_DR_OFFSET ) == false )
 80383ba:	f995 0001 	ldrsb.w	r0, [r5, #1]
 80383be:	2203      	movs	r2, #3
 80383c0:	2100      	movs	r1, #0
 80383c2:	f7fe fb2a 	bl	8036a1a <RegionCommonValueInRange>
 80383c6:	b908      	cbnz	r0, 80383cc <RegionUS915RxParamSetupReq+0x54>
    {
        status &= 0xFB; // Rx1DrOffset range KO
 80383c8:	f004 04fb 	and.w	r4, r4, #251	; 0xfb
    }

#endif /* REGION_US915 */
    return status;
}
 80383cc:	4620      	mov	r0, r4
 80383ce:	bd38      	pop	{r3, r4, r5, pc}

080383d0 <RegionUS915NewChannelReq>:

int8_t RegionUS915NewChannelReq( NewChannelReqParams_t* newChannelReq )
{
    // Do not accept the request
    return -1;
}
 80383d0:	f04f 30ff 	mov.w	r0, #4294967295
 80383d4:	4770      	bx	lr

080383d6 <RegionUS915TxParamSetupReq>:
 80383d6:	f04f 30ff 	mov.w	r0, #4294967295
 80383da:	4770      	bx	lr

080383dc <RegionUS915DlChannelReq>:
 80383dc:	f04f 30ff 	mov.w	r0, #4294967295
 80383e0:	4770      	bx	lr
	...

080383e4 <RegionUS915AlternateDr>:
int8_t RegionUS915AlternateDr( int8_t currentDr, AlternateDrType_t type )
{
#if defined( REGION_US915 )
    // Alternates the data rate according to the channel sequence:
    // Eight times a 125kHz DR_0 and then one 500kHz DR_4 channel
    if( type == ALTERNATE_DR )
 80383e4:	4b0a      	ldr	r3, [pc, #40]	; (8038410 <RegionUS915AlternateDr+0x2c>)
 80383e6:	685a      	ldr	r2, [r3, #4]
 80383e8:	f892 309d 	ldrb.w	r3, [r2, #157]	; 0x9d
 80383ec:	b971      	cbnz	r1, 803840c <RegionUS915AlternateDr+0x28>
    {
        RegionNvmGroup1->JoinTrialsCounter++;
 80383ee:	3301      	adds	r3, #1
    }
    else
    {
        RegionNvmGroup1->JoinTrialsCounter--;
 80383f0:	f882 309d 	strb.w	r3, [r2, #157]	; 0x9d
 80383f4:	f892 309d 	ldrb.w	r3, [r2, #157]	; 0x9d
 80383f8:	ebc3 02c3 	rsb	r2, r3, r3, lsl #3
 80383fc:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    }

    if( RegionNvmGroup1->JoinTrialsCounter % 9 == 0 )
 8038400:	b2db      	uxtb	r3, r3
        // Use DR_4 every 9th times.
        currentDr = DR_4;
    }
    else
    {
        currentDr = DR_0;
 8038402:	2b1d      	cmp	r3, #29
    }
    return currentDr;
#else
    return -1;
#endif /* REGION_US915 */
}
 8038404:	bf34      	ite	cc
 8038406:	2004      	movcc	r0, #4
 8038408:	2000      	movcs	r0, #0
 803840a:	4770      	bx	lr
        RegionNvmGroup1->JoinTrialsCounter--;
 803840c:	3b01      	subs	r3, #1
 803840e:	e7ef      	b.n	80383f0 <RegionUS915AlternateDr+0xc>
 8038410:	20005730 	.word	0x20005730

08038414 <RegionUS915NextChannel>:

LoRaMacStatus_t RegionUS915NextChannel( NextChanParams_t* nextChanParams, uint8_t* channel, TimerTime_t* time, TimerTime_t* aggregatedTimeOff )
{
 8038414:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
#if defined( REGION_US915 )
    uint8_t nbEnabledChannels = 0;
 8038418:	2600      	movs	r6, #0
{
 803841a:	b0a5      	sub	sp, #148	; 0x94
    RegionCommonIdentifyChannelsParam_t identifyChannelsParam;
    RegionCommonCountNbOfEnabledChannelsParams_t countChannelsParams;
    LoRaMacStatus_t status = LORAMAC_STATUS_NO_CHANNEL_FOUND;

    // Count 125kHz channels
    if( RegionCommonCountChannels( RegionNvmGroup1->ChannelsMaskRemaining, 0, 4 ) == 0 )
 803841c:	4d4a      	ldr	r5, [pc, #296]	; (8038548 <RegionUS915NextChannel+0x134>)
    uint8_t nbEnabledChannels = 0;
 803841e:	f88d 600e 	strb.w	r6, [sp, #14]
{
 8038422:	4604      	mov	r4, r0
 8038424:	460f      	mov	r7, r1
 8038426:	4691      	mov	r9, r2
    uint8_t enabledChannels[US915_MAX_NB_CHANNELS] = { 0 };
 8038428:	4631      	mov	r1, r6
 803842a:	2244      	movs	r2, #68	; 0x44
 803842c:	a813      	add	r0, sp, #76	; 0x4c
{
 803842e:	4698      	mov	r8, r3
    uint8_t nbRestrictedChannels = 0;
 8038430:	f88d 600f 	strb.w	r6, [sp, #15]
    uint8_t enabledChannels[US915_MAX_NB_CHANNELS] = { 0 };
 8038434:	9612      	str	r6, [sp, #72]	; 0x48
 8038436:	f003 f9a5 	bl	803b784 <memset>
    if( RegionCommonCountChannels( RegionNvmGroup1->ChannelsMaskRemaining, 0, 4 ) == 0 )
 803843a:	6868      	ldr	r0, [r5, #4]
 803843c:	4631      	mov	r1, r6
 803843e:	2204      	movs	r2, #4
 8038440:	3090      	adds	r0, #144	; 0x90
 8038442:	f7fe fb0c 	bl	8036a5e <RegionCommonCountChannels>
 8038446:	4606      	mov	r6, r0
 8038448:	b950      	cbnz	r0, 8038460 <RegionUS915NextChannel+0x4c>
    { // Reactivate default channels
        RegionCommonChanMaskCopy( RegionNvmGroup1->ChannelsMaskRemaining, RegionNvmGroup2->ChannelsMask, 4  );
 803844a:	e9d5 1000 	ldrd	r1, r0, [r5]
 803844e:	2204      	movs	r2, #4
 8038450:	f501 7158 	add.w	r1, r1, #864	; 0x360
 8038454:	3090      	adds	r0, #144	; 0x90
 8038456:	f7fe fb20 	bl	8036a9a <RegionCommonChanMaskCopy>

        RegionNvmGroup1->JoinChannelGroupsCurrentIndex = 0;
 803845a:	686b      	ldr	r3, [r5, #4]
 803845c:	f883 609c 	strb.w	r6, [r3, #156]	; 0x9c
    }
    // Check other channels
    if( nextChanParams->Datarate >= DR_4 )
 8038460:	f994 3008 	ldrsb.w	r3, [r4, #8]
 8038464:	2b03      	cmp	r3, #3
 8038466:	e9d5 2100 	ldrd	r2, r1, [r5]
 803846a:	dd06      	ble.n	803847a <RegionUS915NextChannel+0x66>
    {
        if( ( RegionNvmGroup1->ChannelsMaskRemaining[4] & CHANNELS_MASK_500KHZ_MASK ) == 0 )
 803846c:	f891 0098 	ldrb.w	r0, [r1, #152]	; 0x98
 8038470:	b918      	cbnz	r0, 803847a <RegionUS915NextChannel+0x66>
        {
            RegionNvmGroup1->ChannelsMaskRemaining[4] = RegionNvmGroup2->ChannelsMask[4];
 8038472:	f8b2 0368 	ldrh.w	r0, [r2, #872]	; 0x368
 8038476:	f8a1 0098 	strh.w	r0, [r1, #152]	; 0x98
        }
    }

    // Search how many channels are enabled
    countChannelsParams.Joined = nextChanParams->Joined;
 803847a:	7a60      	ldrb	r0, [r4, #9]
 803847c:	f88d 0010 	strb.w	r0, [sp, #16]
    countChannelsParams.Datarate = nextChanParams->Datarate;
    countChannelsParams.ChannelsMask = RegionNvmGroup1->ChannelsMaskRemaining;
 8038480:	f101 0090 	add.w	r0, r1, #144	; 0x90
    countChannelsParams.Channels = RegionNvmGroup2->Channels;
 8038484:	e9cd 0205 	strd	r0, r2, [sp, #20]
    countChannelsParams.Bands = RegionNvmGroup1->Bands;
    countChannelsParams.MaxNbChannels = US915_MAX_NB_CHANNELS;
 8038488:	2248      	movs	r2, #72	; 0x48
 803848a:	f8ad 2020 	strh.w	r2, [sp, #32]
    countChannelsParams.JoinChannels = NULL;
 803848e:	2200      	movs	r2, #0
 8038490:	9209      	str	r2, [sp, #36]	; 0x24

    identifyChannelsParam.AggrTimeOff = nextChanParams->AggrTimeOff;
 8038492:	6822      	ldr	r2, [r4, #0]
 8038494:	920a      	str	r2, [sp, #40]	; 0x28
    identifyChannelsParam.LastAggrTx = nextChanParams->LastAggrTx;
 8038496:	6862      	ldr	r2, [r4, #4]
    countChannelsParams.Bands = RegionNvmGroup1->Bands;
 8038498:	9107      	str	r1, [sp, #28]
    identifyChannelsParam.LastAggrTx = nextChanParams->LastAggrTx;
 803849a:	920b      	str	r2, [sp, #44]	; 0x2c
    identifyChannelsParam.DutyCycleEnabled = nextChanParams->DutyCycleEnabled;
    identifyChannelsParam.MaxBands = US915_MAX_NB_BANDS;

    identifyChannelsParam.ElapsedTimeSinceStartUp = nextChanParams->ElapsedTimeSinceStartUp;
 803849c:	e9d4 0103 	ldrd	r0, r1, [r4, #12]
    identifyChannelsParam.DutyCycleEnabled = nextChanParams->DutyCycleEnabled;
 80384a0:	7aa2      	ldrb	r2, [r4, #10]
 80384a2:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
    identifyChannelsParam.MaxBands = US915_MAX_NB_BANDS;
 80384a6:	2201      	movs	r2, #1
 80384a8:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
    identifyChannelsParam.ElapsedTimeSinceStartUp = nextChanParams->ElapsedTimeSinceStartUp;
 80384ac:	aa0d      	add	r2, sp, #52	; 0x34
 80384ae:	e882 0003 	stmia.w	r2, {r0, r1}
    identifyChannelsParam.LastTxIsJoinRequest = nextChanParams->LastTxIsJoinRequest;
 80384b2:	7d22      	ldrb	r2, [r4, #20]
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 80384b4:	8ae1      	ldrh	r1, [r4, #22]
    countChannelsParams.Datarate = nextChanParams->Datarate;
 80384b6:	f88d 3011 	strb.w	r3, [sp, #17]
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 80384ba:	4618      	mov	r0, r3
    identifyChannelsParam.LastTxIsJoinRequest = nextChanParams->LastTxIsJoinRequest;
 80384bc:	f88d 203c 	strb.w	r2, [sp, #60]	; 0x3c
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 80384c0:	f7ff fb36 	bl	8037b30 <GetTimeOnAir>

    identifyChannelsParam.CountNbOfEnabledChannelsParam = &countChannelsParams;
 80384c4:	ab04      	add	r3, sp, #16
 80384c6:	9311      	str	r3, [sp, #68]	; 0x44

    status = RegionCommonIdentifyChannels( &identifyChannelsParam, aggregatedTimeOff, enabledChannels,
 80384c8:	f10d 030f 	add.w	r3, sp, #15
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 80384cc:	9010      	str	r0, [sp, #64]	; 0x40
    status = RegionCommonIdentifyChannels( &identifyChannelsParam, aggregatedTimeOff, enabledChannels,
 80384ce:	9300      	str	r3, [sp, #0]
 80384d0:	f8cd 9004 	str.w	r9, [sp, #4]
 80384d4:	f10d 030e 	add.w	r3, sp, #14
 80384d8:	aa12      	add	r2, sp, #72	; 0x48
 80384da:	4641      	mov	r1, r8
 80384dc:	a80a      	add	r0, sp, #40	; 0x28
 80384de:	f7fe fcf8 	bl	8036ed2 <RegionCommonIdentifyChannels>
                                           &nbEnabledChannels, &nbRestrictedChannels, time );

    if( status == LORAMAC_STATUS_OK )
 80384e2:	4606      	mov	r6, r0
 80384e4:	b988      	cbnz	r0, 803850a <RegionUS915NextChannel+0xf6>
    {
        if( nextChanParams->Joined == true )
 80384e6:	7a63      	ldrb	r3, [r4, #9]
 80384e8:	b19b      	cbz	r3, 8038512 <RegionUS915NextChannel+0xfe>
        {
            // Choose randomly on of the remaining channels
            *channel = enabledChannels[randr( 0, nbEnabledChannels - 1 )];
 80384ea:	f89d 100e 	ldrb.w	r1, [sp, #14]
 80384ee:	3901      	subs	r1, #1
 80384f0:	f000 fd00 	bl	8038ef4 <randr>
 80384f4:	ab24      	add	r3, sp, #144	; 0x90
 80384f6:	4418      	add	r0, r3
 80384f8:	f810 3c48 	ldrb.w	r3, [r0, #-72]
                uint8_t i = 0;
                while( ( ( RegionNvmGroup1->ChannelsMaskRemaining[4] & CHANNELS_MASK_500KHZ_MASK ) & ( 1 << i ) ) == 0 )
                {
                    i++;
                }
                *channel = 64 + i;
 80384fc:	703b      	strb	r3, [r7, #0]
            }
        }

        // Disable the channel in the mask
        RegionCommonChanDisable( RegionNvmGroup1->ChannelsMaskRemaining, *channel, US915_MAX_NB_CHANNELS );
 80384fe:	6868      	ldr	r0, [r5, #4]
 8038500:	7839      	ldrb	r1, [r7, #0]
 8038502:	2248      	movs	r2, #72	; 0x48
 8038504:	3090      	adds	r0, #144	; 0x90
 8038506:	f7fe fa91 	bl	8036a2c <RegionCommonChanDisable>
    }
    return status;
#else
    return LORAMAC_STATUS_NO_CHANNEL_FOUND;
#endif /* REGION_US915 */
}
 803850a:	4630      	mov	r0, r6
 803850c:	b025      	add	sp, #148	; 0x94
 803850e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            if( nextChanParams->Datarate == DR_0 )
 8038512:	f994 3008 	ldrsb.w	r3, [r4, #8]
 8038516:	6868      	ldr	r0, [r5, #4]
 8038518:	b15b      	cbz	r3, 8038532 <RegionUS915NextChannel+0x11e>
                while( ( ( RegionNvmGroup1->ChannelsMaskRemaining[4] & CHANNELS_MASK_500KHZ_MASK ) & ( 1 << i ) ) == 0 )
 803851a:	f890 0098 	ldrb.w	r0, [r0, #152]	; 0x98
 803851e:	4632      	mov	r2, r6
 8038520:	b2d3      	uxtb	r3, r2
 8038522:	fa40 f103 	asr.w	r1, r0, r3
 8038526:	07c9      	lsls	r1, r1, #31
 8038528:	f102 0201 	add.w	r2, r2, #1
 803852c:	d5f8      	bpl.n	8038520 <RegionUS915NextChannel+0x10c>
                *channel = 64 + i;
 803852e:	3340      	adds	r3, #64	; 0x40
 8038530:	e7e4      	b.n	80384fc <RegionUS915NextChannel+0xe8>
                if( RegionBaseUSComputeNext125kHzJoinChannel( ( uint16_t* ) RegionNvmGroup1->ChannelsMaskRemaining,
 8038532:	f100 019c 	add.w	r1, r0, #156	; 0x9c
 8038536:	463a      	mov	r2, r7
 8038538:	3090      	adds	r0, #144	; 0x90
 803853a:	f7fe f9f3 	bl	8036924 <RegionBaseUSComputeNext125kHzJoinChannel>
 803853e:	2803      	cmp	r0, #3
 8038540:	d1dd      	bne.n	80384fe <RegionUS915NextChannel+0xea>
                    return LORAMAC_STATUS_PARAMETER_INVALID;
 8038542:	4606      	mov	r6, r0
 8038544:	e7e1      	b.n	803850a <RegionUS915NextChannel+0xf6>
 8038546:	bf00      	nop
 8038548:	20005730 	.word	0x20005730

0803854c <RegionUS915SetContinuousWave>:
{
    return LORAMAC_STATUS_PARAMETER_INVALID;
}

void RegionUS915SetContinuousWave( ContinuousWaveParams_t* continuousWave )
{
 803854c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
#if defined( REGION_US915 )
    int8_t txPowerLimited = LimitTxPower( continuousWave->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[continuousWave->Channel].Band].TxMaxPower, continuousWave->Datarate, RegionNvmGroup2->ChannelsMask );
 8038550:	4e1f      	ldr	r6, [pc, #124]	; (80385d0 <RegionUS915SetContinuousWave+0x84>)
 8038552:	7802      	ldrb	r2, [r0, #0]
 8038554:	f8d6 8000 	ldr.w	r8, [r6]
 8038558:	6871      	ldr	r1, [r6, #4]
 803855a:	f990 7002 	ldrsb.w	r7, [r0, #2]
 803855e:	f990 9001 	ldrsb.w	r9, [r0, #1]
 8038562:	230c      	movs	r3, #12
 8038564:	fb03 8202 	mla	r2, r3, r2, r8
{
 8038568:	4604      	mov	r4, r0
    int8_t txPowerLimited = LimitTxPower( continuousWave->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[continuousWave->Channel].Band].TxMaxPower, continuousWave->Datarate, RegionNvmGroup2->ChannelsMask );
 803856a:	7a53      	ldrb	r3, [r2, #9]
 803856c:	2218      	movs	r2, #24
 803856e:	fb02 1303 	mla	r3, r2, r3, r1
    txPowerResult =  RegionCommonLimitTxPower( txPower, maxBandTxPower );
 8038572:	4638      	mov	r0, r7
 8038574:	f993 1002 	ldrsb.w	r1, [r3, #2]
 8038578:	f7fe fd0a 	bl	8036f90 <RegionCommonLimitTxPower>
    if( datarate == DR_4 )
 803857c:	f1b9 0f04 	cmp.w	r9, #4
    txPowerResult =  RegionCommonLimitTxPower( txPower, maxBandTxPower );
 8038580:	4605      	mov	r5, r0
    if( datarate == DR_4 )
 8038582:	d117      	bne.n	80385b4 <RegionUS915SetContinuousWave+0x68>
        txPowerResult = MAX( txPower, TX_POWER_2 );
 8038584:	2f02      	cmp	r7, #2
 8038586:	463d      	mov	r5, r7
 8038588:	bfb8      	it	lt
 803858a:	2502      	movlt	r5, #2
    int8_t phyTxPower = 0;
    uint32_t frequency = RegionNvmGroup2->Channels[continuousWave->Channel].Frequency;
 803858c:	7821      	ldrb	r1, [r4, #0]
 803858e:	6832      	ldr	r2, [r6, #0]
 8038590:	230c      	movs	r3, #12
 8038592:	434b      	muls	r3, r1

    // Calculate physical TX power
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );
 8038594:	4628      	mov	r0, r5
    uint32_t frequency = RegionNvmGroup2->Channels[continuousWave->Channel].Frequency;
 8038596:	58d6      	ldr	r6, [r2, r3]
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );
 8038598:	490e      	ldr	r1, [pc, #56]	; (80385d4 <RegionUS915SetContinuousWave+0x88>)
 803859a:	2200      	movs	r2, #0
 803859c:	f7fe fc2d 	bl	8036dfa <RegionCommonComputeTxPower>

    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 80385a0:	4b0d      	ldr	r3, [pc, #52]	; (80385d8 <RegionUS915SetContinuousWave+0x8c>)
 80385a2:	89a2      	ldrh	r2, [r4, #12]
 80385a4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80385a6:	9301      	str	r3, [sp, #4]
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );
 80385a8:	4601      	mov	r1, r0
    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 80385aa:	4630      	mov	r0, r6
#endif /* REGION_US915 */
}
 80385ac:	b003      	add	sp, #12
 80385ae:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 80385b2:	4718      	bx	r3
        if( RegionCommonCountChannels( channelsMask, 0, 4 ) < 50 )
 80385b4:	2204      	movs	r2, #4
 80385b6:	2100      	movs	r1, #0
 80385b8:	f508 7058 	add.w	r0, r8, #864	; 0x360
 80385bc:	f7fe fa4f 	bl	8036a5e <RegionCommonCountChannels>
 80385c0:	2831      	cmp	r0, #49	; 0x31
 80385c2:	d8e3      	bhi.n	803858c <RegionUS915SetContinuousWave+0x40>
            txPowerResult = MAX( txPower, TX_POWER_5 );
 80385c4:	2f05      	cmp	r7, #5
 80385c6:	463d      	mov	r5, r7
 80385c8:	bfb8      	it	lt
 80385ca:	2505      	movlt	r5, #5
 80385cc:	e7de      	b.n	803858c <RegionUS915SetContinuousWave+0x40>
 80385ce:	bf00      	nop
 80385d0:	20005730 	.word	0x20005730
 80385d4:	41f00000 	.word	0x41f00000
 80385d8:	0803bc30 	.word	0x0803bc30

080385dc <RegionUS915ApplyDrOffset>:

uint8_t RegionUS915ApplyDrOffset( uint8_t downlinkDwellTime, int8_t dr, int8_t drOffset )
{
#if defined( REGION_US915 )
    int8_t datarate = DatarateOffsetsUS915[dr][drOffset];
 80385dc:	4b04      	ldr	r3, [pc, #16]	; (80385f0 <RegionUS915ApplyDrOffset+0x14>)
 80385de:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 80385e2:	4413      	add	r3, r2
 80385e4:	f993 0070 	ldrsb.w	r0, [r3, #112]	; 0x70

    if( datarate < 0 )
    {
        datarate = DR_0;
    }
    return datarate;
 80385e8:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
#else
    return 0;
#endif /* REGION_US915 */
}
 80385ec:	b2c0      	uxtb	r0, r0
 80385ee:	4770      	bx	lr
 80385f0:	0803bb58 	.word	0x0803bb58

080385f4 <GetKeyIndexByID>:
 */
static SecureElementStatus_t GetKeyIndexByID( KeyIdentifier_t keyID, CK_OBJECT_HANDLE *keyIndex )
{
    for (uint8_t i = 0; i < NUM_OF_KEYS; i++)
    {
        if (SeNvm->KeyList[i].KeyID == keyID)
 80385f4:	4b0a      	ldr	r3, [pc, #40]	; (8038620 <GetKeyIndexByID+0x2c>)
 80385f6:	681a      	ldr	r2, [r3, #0]
{
 80385f8:	b5f0      	push	{r4, r5, r6, r7, lr}
        if (SeNvm->KeyList[i].KeyID == keyID)
 80385fa:	2300      	movs	r3, #0
 80385fc:	f102 0510 	add.w	r5, r2, #16
 8038600:	2618      	movs	r6, #24
 8038602:	fb06 f403 	mul.w	r4, r6, r3
 8038606:	5d2f      	ldrb	r7, [r5, r4]
 8038608:	4287      	cmp	r7, r0
 803860a:	d104      	bne.n	8038616 <GetKeyIndexByID+0x22>
        {
            *keyIndex = SeNvm->KeyList[i].Object_Index;
 803860c:	4422      	add	r2, r4
            return SECURE_ELEMENT_SUCCESS;
 803860e:	2000      	movs	r0, #0
            *keyIndex = SeNvm->KeyList[i].Object_Index;
 8038610:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8038612:	600b      	str	r3, [r1, #0]
        }
    }
    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
}
 8038614:	bdf0      	pop	{r4, r5, r6, r7, pc}
    for (uint8_t i = 0; i < NUM_OF_KEYS; i++)
 8038616:	3301      	adds	r3, #1
 8038618:	2b0a      	cmp	r3, #10
 803861a:	d1f2      	bne.n	8038602 <GetKeyIndexByID+0xe>
    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 803861c:	2003      	movs	r0, #3
 803861e:	e7f9      	b.n	8038614 <GetKeyIndexByID+0x20>
 8038620:	20005738 	.word	0x20005738

08038624 <SecureElementGetKeyByID>:
    return SECURE_ELEMENT_SUCCESS;
}

/* ST_WORKAROUND_BEGIN: Add KMS specific functions */
SecureElementStatus_t SecureElementGetKeyByID( KeyIdentifier_t keyID, Key_t **keyItem )
{
 8038624:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8038628:	b08d      	sub	sp, #52	; 0x34
    CK_SESSION_HANDLE session;
    CK_FLAGS session_flags = CKF_SERIAL_SESSION;  /* Read ONLY session */
    CK_OBJECT_HANDLE key_handle = (CK_OBJECT_HANDLE)(~0UL);
    CK_ULONG derive_key_template_class = CKO_SECRET_KEY;
    uint8_t extractable_key[16] = {0};
    CK_ATTRIBUTE key_attribute_template = {CKA_VALUE, (CK_VOID_PTR) &derive_key_template_class, 16UL};
 803862a:	2211      	movs	r2, #17
    CK_ULONG derive_key_template_class = CKO_SECRET_KEY;
 803862c:	2304      	movs	r3, #4
    uint8_t index_keylist = 0;
    for (index_keylist = 0; index_keylist < NUM_OF_KEYS; index_keylist++)
    {
        if (SeNvm->KeyList[index_keylist].KeyID == keyID)
 803862e:	4e27      	ldr	r6, [pc, #156]	; (80386cc <SecureElementGetKeyByID+0xa8>)
    CK_ATTRIBUTE key_attribute_template = {CKA_VALUE, (CK_VOID_PTR) &derive_key_template_class, 16UL};
 8038630:	9205      	str	r2, [sp, #20]
 8038632:	aa04      	add	r2, sp, #16
    CK_ULONG derive_key_template_class = CKO_SECRET_KEY;
 8038634:	9304      	str	r3, [sp, #16]
    CK_ATTRIBUTE key_attribute_template = {CKA_VALUE, (CK_VOID_PTR) &derive_key_template_class, 16UL};
 8038636:	9206      	str	r2, [sp, #24]
    uint8_t extractable_key[16] = {0};
 8038638:	2300      	movs	r3, #0
    CK_ATTRIBUTE key_attribute_template = {CKA_VALUE, (CK_VOID_PTR) &derive_key_template_class, 16UL};
 803863a:	2210      	movs	r2, #16
 803863c:	9207      	str	r2, [sp, #28]
    uint8_t extractable_key[16] = {0};
 803863e:	e9cd 3308 	strd	r3, r3, [sp, #32]
        if (SeNvm->KeyList[index_keylist].KeyID == keyID)
 8038642:	6832      	ldr	r2, [r6, #0]
    uint8_t extractable_key[16] = {0};
 8038644:	e9cd 330a 	strd	r3, r3, [sp, #40]	; 0x28
{
 8038648:	460f      	mov	r7, r1
        if (SeNvm->KeyList[index_keylist].KeyID == keyID)
 803864a:	2418      	movs	r4, #24
 803864c:	f102 0110 	add.w	r1, r2, #16
 8038650:	fb04 f503 	mul.w	r5, r4, r3
 8038654:	f811 c005 	ldrb.w	ip, [r1, r5]
 8038658:	4584      	cmp	ip, r0
 803865a:	d107      	bne.n	803866c <SecureElementGetKeyByID+0x48>
        {
            key_handle = SeNvm->KeyList[index_keylist].Object_Index;
 803865c:	442a      	add	r2, r5
 803865e:	f8d2 9024 	ldr.w	r9, [r2, #36]	; 0x24
            break;
        }
    }
    if (key_handle == (CK_OBJECT_HANDLE)(~0UL))
 8038662:	f1b9 3fff 	cmp.w	r9, #4294967295
 8038666:	d105      	bne.n	8038674 <SecureElementGetKeyByID+0x50>
    {
        return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 8038668:	2003      	movs	r0, #3
 803866a:	e02c      	b.n	80386c6 <SecureElementGetKeyByID+0xa2>
    for (index_keylist = 0; index_keylist < NUM_OF_KEYS; index_keylist++)
 803866c:	3301      	adds	r3, #1
 803866e:	2b0a      	cmp	r3, #10
 8038670:	d1ee      	bne.n	8038650 <SecureElementGetKeyByID+0x2c>
 8038672:	e7f9      	b.n	8038668 <SecureElementGetKeyByID+0x44>
    }

    /* Open session with KMS */
    rv = C_OpenSession(0, session_flags, NULL, 0, &session);
 8038674:	ab03      	add	r3, sp, #12
 8038676:	9300      	str	r3, [sp, #0]
 8038678:	2300      	movs	r3, #0
 803867a:	461a      	mov	r2, r3
 803867c:	2104      	movs	r1, #4
 803867e:	4618      	mov	r0, r3
 8038680:	f7d0 fb6c 	bl	8008d5c <SE_KMS_OpenSession>

    /* Get key to display */
    if (rv == CKR_OK)
 8038684:	4604      	mov	r4, r0
 8038686:	b9b8      	cbnz	r0, 80386b8 <SecureElementGetKeyByID+0x94>
    {
        key_attribute_template.pValue = extractable_key;
        rv = C_GetAttributeValue(session, key_handle, &key_attribute_template, 1UL);
 8038688:	9803      	ldr	r0, [sp, #12]
        key_attribute_template.pValue = extractable_key;
 803868a:	f10d 0820 	add.w	r8, sp, #32
        rv = C_GetAttributeValue(session, key_handle, &key_attribute_template, 1UL);
 803868e:	2301      	movs	r3, #1
 8038690:	aa05      	add	r2, sp, #20
 8038692:	4649      	mov	r1, r9
        key_attribute_template.pValue = extractable_key;
 8038694:	f8cd 8018 	str.w	r8, [sp, #24]
        rv = C_GetAttributeValue(session, key_handle, &key_attribute_template, 1UL);
 8038698:	f7d0 fbd0 	bl	8008e3c <SE_KMS_GetAttributeValue>
    }
    if (rv == CKR_OK)
 803869c:	4604      	mov	r4, r0
 803869e:	b958      	cbnz	r0, 80386b8 <SecureElementGetKeyByID+0x94>
    {
        memcpy1(SeNvm->KeyList[index_keylist].KeyValue, extractable_key, sizeof(extractable_key));
 80386a0:	6833      	ldr	r3, [r6, #0]
 80386a2:	f105 0011 	add.w	r0, r5, #17
 80386a6:	4418      	add	r0, r3
 80386a8:	2210      	movs	r2, #16
 80386aa:	4641      	mov	r1, r8
 80386ac:	f000 fc3e 	bl	8038f2c <memcpy1>
        *keyItem = &(SeNvm->KeyList[index_keylist]);
 80386b0:	6833      	ldr	r3, [r6, #0]
 80386b2:	3510      	adds	r5, #16
 80386b4:	441d      	add	r5, r3
 80386b6:	603d      	str	r5, [r7, #0]
    }

    /* Close sessions */
    (void)C_CloseSession(session);
 80386b8:	9803      	ldr	r0, [sp, #12]
 80386ba:	f7d0 fb6f 	bl	8008d9c <SE_KMS_CloseSession>

    if (rv != CKR_OK)
    {
        return SECURE_ELEMENT_ERROR;
 80386be:	2c00      	cmp	r4, #0
 80386c0:	bf0c      	ite	eq
 80386c2:	2000      	moveq	r0, #0
 80386c4:	2006      	movne	r0, #6
    }
    return SECURE_ELEMENT_SUCCESS;

#endif /* LORAWAN_KMS == 1 */
}
 80386c6:	b00d      	add	sp, #52	; 0x34
 80386c8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80386cc:	20005738 	.word	0x20005738

080386d0 <PrintKey>:
{
 80386d0:	b510      	push	{r4, lr}
 80386d2:	b092      	sub	sp, #72	; 0x48
    retval = SecureElementGetKeyByID(key, &keyItem);
 80386d4:	a911      	add	r1, sp, #68	; 0x44
{
 80386d6:	4604      	mov	r4, r0
    retval = SecureElementGetKeyByID(key, &keyItem);
 80386d8:	f7ff ffa4 	bl	8038624 <SecureElementGetKeyByID>
    if (retval == SECURE_ELEMENT_SUCCESS)
 80386dc:	4602      	mov	r2, r0
 80386de:	2800      	cmp	r0, #0
 80386e0:	d131      	bne.n	8038746 <PrintKey+0x76>
        if (key == APP_KEY)
 80386e2:	b914      	cbnz	r4, 80386ea <PrintKey+0x1a>
            MW_LOG(TS_OFF, VLEVEL_M, "###### AppKey:      ");
 80386e4:	4b27      	ldr	r3, [pc, #156]	; (8038784 <PrintKey+0xb4>)
            MW_LOG(TS_OFF, VLEVEL_M, "###### MCNwkSKey_0: ");
 80386e6:	2200      	movs	r2, #0
 80386e8:	e002      	b.n	80386f0 <PrintKey+0x20>
        else if (key == NWK_KEY)
 80386ea:	2c01      	cmp	r4, #1
 80386ec:	d12d      	bne.n	803874a <PrintKey+0x7a>
            MW_LOG(TS_OFF, VLEVEL_M, "###### NwkKey:      ");
 80386ee:	4b26      	ldr	r3, [pc, #152]	; (8038788 <PrintKey+0xb8>)
            MW_LOG(TS_OFF, VLEVEL_M, "###### MCNwkSKey_0: ");
 80386f0:	4611      	mov	r1, r2
 80386f2:	2002      	movs	r0, #2
 80386f4:	f002 fb00 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
        MW_LOG(TS_OFF, VLEVEL_M, "%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\r\n",
 80386f8:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80386fa:	7c1a      	ldrb	r2, [r3, #16]
 80386fc:	920f      	str	r2, [sp, #60]	; 0x3c
 80386fe:	7bda      	ldrb	r2, [r3, #15]
 8038700:	920e      	str	r2, [sp, #56]	; 0x38
 8038702:	7b9a      	ldrb	r2, [r3, #14]
 8038704:	920d      	str	r2, [sp, #52]	; 0x34
 8038706:	7b5a      	ldrb	r2, [r3, #13]
 8038708:	920c      	str	r2, [sp, #48]	; 0x30
 803870a:	7b1a      	ldrb	r2, [r3, #12]
 803870c:	920b      	str	r2, [sp, #44]	; 0x2c
 803870e:	7ada      	ldrb	r2, [r3, #11]
 8038710:	920a      	str	r2, [sp, #40]	; 0x28
 8038712:	7a9a      	ldrb	r2, [r3, #10]
 8038714:	9209      	str	r2, [sp, #36]	; 0x24
 8038716:	7a5a      	ldrb	r2, [r3, #9]
 8038718:	9208      	str	r2, [sp, #32]
 803871a:	7a1a      	ldrb	r2, [r3, #8]
 803871c:	9207      	str	r2, [sp, #28]
 803871e:	79da      	ldrb	r2, [r3, #7]
 8038720:	9206      	str	r2, [sp, #24]
 8038722:	799a      	ldrb	r2, [r3, #6]
 8038724:	9205      	str	r2, [sp, #20]
 8038726:	795a      	ldrb	r2, [r3, #5]
 8038728:	9204      	str	r2, [sp, #16]
 803872a:	791a      	ldrb	r2, [r3, #4]
 803872c:	9203      	str	r2, [sp, #12]
 803872e:	78da      	ldrb	r2, [r3, #3]
 8038730:	9202      	str	r2, [sp, #8]
 8038732:	789a      	ldrb	r2, [r3, #2]
 8038734:	9201      	str	r2, [sp, #4]
 8038736:	785b      	ldrb	r3, [r3, #1]
 8038738:	9300      	str	r3, [sp, #0]
 803873a:	2200      	movs	r2, #0
 803873c:	4b13      	ldr	r3, [pc, #76]	; (803878c <PrintKey+0xbc>)
 803873e:	4611      	mov	r1, r2
 8038740:	2002      	movs	r0, #2
 8038742:	f002 fad9 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
}
 8038746:	b012      	add	sp, #72	; 0x48
 8038748:	bd10      	pop	{r4, pc}
        else if (key == APP_S_KEY)
 803874a:	2c03      	cmp	r4, #3
 803874c:	d101      	bne.n	8038752 <PrintKey+0x82>
            MW_LOG(TS_OFF, VLEVEL_M, "###### AppSKey:     ");
 803874e:	4b10      	ldr	r3, [pc, #64]	; (8038790 <PrintKey+0xc0>)
 8038750:	e7ce      	b.n	80386f0 <PrintKey+0x20>
        else if (key == NWK_S_KEY)
 8038752:	2c02      	cmp	r4, #2
 8038754:	d101      	bne.n	803875a <PrintKey+0x8a>
            MW_LOG(TS_OFF, VLEVEL_M, "###### NwkSKey:     ");
 8038756:	4b0f      	ldr	r3, [pc, #60]	; (8038794 <PrintKey+0xc4>)
 8038758:	e7ca      	b.n	80386f0 <PrintKey+0x20>
        else if (key == MC_ROOT_KEY)
 803875a:	2c04      	cmp	r4, #4
 803875c:	d101      	bne.n	8038762 <PrintKey+0x92>
            MW_LOG(TS_OFF, VLEVEL_M, "###### MCRootKey:   ");
 803875e:	4b0e      	ldr	r3, [pc, #56]	; (8038798 <PrintKey+0xc8>)
 8038760:	e7c6      	b.n	80386f0 <PrintKey+0x20>
        else if (key == MC_KE_KEY)
 8038762:	2c7f      	cmp	r4, #127	; 0x7f
 8038764:	d101      	bne.n	803876a <PrintKey+0x9a>
            MW_LOG(TS_OFF, VLEVEL_M, "###### MCKEKey:     ");
 8038766:	4b0d      	ldr	r3, [pc, #52]	; (803879c <PrintKey+0xcc>)
 8038768:	e7c2      	b.n	80386f0 <PrintKey+0x20>
        else if (key == MC_KEY_0)
 803876a:	2c80      	cmp	r4, #128	; 0x80
 803876c:	d101      	bne.n	8038772 <PrintKey+0xa2>
            MW_LOG(TS_OFF, VLEVEL_M, "###### MCKey_0:     ");
 803876e:	4b0c      	ldr	r3, [pc, #48]	; (80387a0 <PrintKey+0xd0>)
 8038770:	e7be      	b.n	80386f0 <PrintKey+0x20>
        else if (key == MC_APP_S_KEY_0)
 8038772:	2c81      	cmp	r4, #129	; 0x81
 8038774:	d101      	bne.n	803877a <PrintKey+0xaa>
            MW_LOG(TS_OFF, VLEVEL_M, "###### MCAppSKey_0: ");
 8038776:	4b0b      	ldr	r3, [pc, #44]	; (80387a4 <PrintKey+0xd4>)
 8038778:	e7ba      	b.n	80386f0 <PrintKey+0x20>
        else if (key == MC_NWK_S_KEY_0)
 803877a:	2c82      	cmp	r4, #130	; 0x82
 803877c:	d1bc      	bne.n	80386f8 <PrintKey+0x28>
            MW_LOG(TS_OFF, VLEVEL_M, "###### MCNwkSKey_0: ");
 803877e:	4b0a      	ldr	r3, [pc, #40]	; (80387a8 <PrintKey+0xd8>)
 8038780:	e7b1      	b.n	80386e6 <PrintKey+0x16>
 8038782:	bf00      	nop
 8038784:	0803c427 	.word	0x0803c427
 8038788:	0803c43c 	.word	0x0803c43c
 803878c:	0803c4e4 	.word	0x0803c4e4
 8038790:	0803c451 	.word	0x0803c451
 8038794:	0803c466 	.word	0x0803c466
 8038798:	0803c47b 	.word	0x0803c47b
 803879c:	0803c490 	.word	0x0803c490
 80387a0:	0803c4a5 	.word	0x0803c4a5
 80387a4:	0803c4ba 	.word	0x0803c4ba
 80387a8:	0803c4cf 	.word	0x0803c4cf

080387ac <SecureElementDeleteDynamicKeys>:

SecureElementStatus_t SecureElementDeleteDynamicKeys( KeyIdentifier_t keyID, uint32_t *key_label )
{
 80387ac:	b530      	push	{r4, r5, lr}
 80387ae:	b095      	sub	sp, #84	; 0x54
#else /* LORAWAN_KMS == 1 */
    CK_RV rv;
    CK_SESSION_HANDLE session;
    CK_FLAGS session_flags = CKF_SERIAL_SESSION;    /* Read ONLY session */
    CK_OBJECT_HANDLE hObject[NUM_OF_KEYS];
    CK_ULONG local_template_label[] = {GlobalTemplateLabel, 0UL};
 80387b0:	4b37      	ldr	r3, [pc, #220]	; (8038890 <SecureElementDeleteDynamicKeys+0xe4>)
 80387b2:	9305      	str	r3, [sp, #20]
    CK_ATTRIBUTE dynamic_key_template = {CKA_LABEL, (CK_VOID_PTR)local_template_label, sizeof(local_template_label)};
 80387b4:	2303      	movs	r3, #3
 80387b6:	9307      	str	r3, [sp, #28]
 80387b8:	ab05      	add	r3, sp, #20
 80387ba:	9308      	str	r3, [sp, #32]
 80387bc:	2308      	movs	r3, #8
 80387be:	9309      	str	r3, [sp, #36]	; 0x24
    switch (keyID)
 80387c0:	2804      	cmp	r0, #4
    uint32_t ulCount = 0;
 80387c2:	f04f 0300 	mov.w	r3, #0
 80387c6:	9304      	str	r3, [sp, #16]
    switch (keyID)
 80387c8:	d90b      	bls.n	80387e2 <SecureElementDeleteDynamicKeys+0x36>
 80387ca:	387f      	subs	r0, #127	; 0x7f
 80387cc:	b2c3      	uxtb	r3, r0
 80387ce:	2b03      	cmp	r3, #3
 80387d0:	d901      	bls.n	80387d6 <SecureElementDeleteDynamicKeys+0x2a>
 80387d2:	2006      	movs	r0, #6
 80387d4:	e038      	b.n	8038848 <SecureElementDeleteDynamicKeys+0x9c>
 80387d6:	2803      	cmp	r0, #3
 80387d8:	d8fb      	bhi.n	80387d2 <SecureElementDeleteDynamicKeys+0x26>
 80387da:	e8df f000 	tbb	[pc, r0]
 80387de:	413f      	.short	0x413f
 80387e0:	4543      	.short	0x4543
 80387e2:	3801      	subs	r0, #1
 80387e4:	2803      	cmp	r0, #3
 80387e6:	d803      	bhi.n	80387f0 <SecureElementDeleteDynamicKeys+0x44>
 80387e8:	e8df f000 	tbb	[pc, r0]
 80387ec:	36343230 	.word	0x36343230
            *specificLabel = 0x5F505041U;
 80387f0:	4b28      	ldr	r3, [pc, #160]	; (8038894 <SecureElementDeleteDynamicKeys+0xe8>)
            *specificLabel = 0x30534E4DU;
 80387f2:	9306      	str	r3, [sp, #24]

    if (SECURE_ELEMENT_SUCCESS != GetSpecificLabelByID(keyID, &local_template_label[1]))
    {
        return SECURE_ELEMENT_ERROR;
    }
    *key_label = local_template_label[1];
 80387f4:	9b06      	ldr	r3, [sp, #24]
 80387f6:	600b      	str	r3, [r1, #0]

    /* Open session with KMS */
    rv = C_OpenSession(0,    session_flags, NULL, 0, &session);
 80387f8:	ab03      	add	r3, sp, #12
 80387fa:	9300      	str	r3, [sp, #0]
 80387fc:	2300      	movs	r3, #0
 80387fe:	461a      	mov	r2, r3
 8038800:	2104      	movs	r1, #4
 8038802:	4618      	mov	r0, r3
 8038804:	f7d0 faaa 	bl	8008d5c <SE_KMS_OpenSession>

    /* Search from Template pattern */
    if (rv == CKR_OK)
 8038808:	4604      	mov	r4, r0
 803880a:	b990      	cbnz	r0, 8038832 <SecureElementDeleteDynamicKeys+0x86>
    {
        rv = C_FindObjectsInit(session, &dynamic_key_template, sizeof(dynamic_key_template) / sizeof(CK_ATTRIBUTE));
 803880c:	9803      	ldr	r0, [sp, #12]
 803880e:	2201      	movs	r2, #1
 8038810:	a907      	add	r1, sp, #28
 8038812:	f7d0 fb4f 	bl	8008eb4 <SE_KMS_FindObjectsInit>
    }

    /* Find all existing keys handle Template pattern */
    if (rv == CKR_OK)
 8038816:	4604      	mov	r4, r0
 8038818:	b958      	cbnz	r0, 8038832 <SecureElementDeleteDynamicKeys+0x86>
    {
        rv = C_FindObjects(session, hObject, NUM_OF_KEYS, (CK_ULONG *) &ulCount);
 803881a:	9803      	ldr	r0, [sp, #12]
 803881c:	ab04      	add	r3, sp, #16
 803881e:	220a      	movs	r2, #10
 8038820:	a90a      	add	r1, sp, #40	; 0x28
 8038822:	f7d0 fb63 	bl	8008eec <SE_KMS_FindObjects>
    }

    if (rv == CKR_OK)
 8038826:	4604      	mov	r4, r0
 8038828:	b918      	cbnz	r0, 8038832 <SecureElementDeleteDynamicKeys+0x86>
    {
        rv = C_FindObjectsFinal(session);
 803882a:	9803      	ldr	r0, [sp, #12]
 803882c:	f7d0 fb7c 	bl	8008f28 <SE_KMS_FindObjectsFinal>
 8038830:	4604      	mov	r4, r0
    }

    if (ulCount <= NUM_OF_KEYS)
 8038832:	9b04      	ldr	r3, [sp, #16]
 8038834:	2b0a      	cmp	r3, #10
 8038836:	d929      	bls.n	803888c <SecureElementDeleteDynamicKeys+0xe0>
            }
        }
    }

    /* Close sessions */
    if (session > 0)
 8038838:	9803      	ldr	r0, [sp, #12]
 803883a:	b108      	cbz	r0, 8038840 <SecureElementDeleteDynamicKeys+0x94>
    {
        (void)C_CloseSession(session);
 803883c:	f7d0 faae 	bl	8008d9c <SE_KMS_CloseSession>
    }

    if (rv != CKR_OK)
    {
        return SECURE_ELEMENT_ERROR;
 8038840:	2c00      	cmp	r4, #0
 8038842:	bf0c      	ite	eq
 8038844:	2000      	moveq	r0, #0
 8038846:	2006      	movne	r0, #6
    }
    return SECURE_ELEMENT_SUCCESS;
#endif /* LORAWAN_KMS == 1 */
}
 8038848:	b015      	add	sp, #84	; 0x54
 803884a:	bd30      	pop	{r4, r5, pc}
            *specificLabel = 0x5F4B574EU;
 803884c:	4b12      	ldr	r3, [pc, #72]	; (8038898 <SecureElementDeleteDynamicKeys+0xec>)
 803884e:	e7d0      	b.n	80387f2 <SecureElementDeleteDynamicKeys+0x46>
            *specificLabel = 0x534B574EU;
 8038850:	4b12      	ldr	r3, [pc, #72]	; (803889c <SecureElementDeleteDynamicKeys+0xf0>)
 8038852:	e7ce      	b.n	80387f2 <SecureElementDeleteDynamicKeys+0x46>
            *specificLabel = 0x53505041U;
 8038854:	4b12      	ldr	r3, [pc, #72]	; (80388a0 <SecureElementDeleteDynamicKeys+0xf4>)
 8038856:	e7cc      	b.n	80387f2 <SecureElementDeleteDynamicKeys+0x46>
            *specificLabel = 0x5452434DU;
 8038858:	4b12      	ldr	r3, [pc, #72]	; (80388a4 <SecureElementDeleteDynamicKeys+0xf8>)
 803885a:	e7ca      	b.n	80387f2 <SecureElementDeleteDynamicKeys+0x46>
            *specificLabel = 0x454B434DU;
 803885c:	4b12      	ldr	r3, [pc, #72]	; (80388a8 <SecureElementDeleteDynamicKeys+0xfc>)
 803885e:	e7c8      	b.n	80387f2 <SecureElementDeleteDynamicKeys+0x46>
            *specificLabel = 0x304B434DU;
 8038860:	4b12      	ldr	r3, [pc, #72]	; (80388ac <SecureElementDeleteDynamicKeys+0x100>)
 8038862:	e7c6      	b.n	80387f2 <SecureElementDeleteDynamicKeys+0x46>
            *specificLabel = 0x3053414DU;
 8038864:	4b12      	ldr	r3, [pc, #72]	; (80388b0 <SecureElementDeleteDynamicKeys+0x104>)
 8038866:	e7c4      	b.n	80387f2 <SecureElementDeleteDynamicKeys+0x46>
            *specificLabel = 0x30534E4DU;
 8038868:	4b12      	ldr	r3, [pc, #72]	; (80388b4 <SecureElementDeleteDynamicKeys+0x108>)
 803886a:	e7c2      	b.n	80387f2 <SecureElementDeleteDynamicKeys+0x46>
            if (rv == CKR_OK)
 803886c:	b944      	cbnz	r4, 8038880 <SecureElementDeleteDynamicKeys+0xd4>
                rv = C_DestroyObject(session, hObject[i]);
 803886e:	aa14      	add	r2, sp, #80	; 0x50
 8038870:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8038874:	9803      	ldr	r0, [sp, #12]
 8038876:	f853 1c28 	ldr.w	r1, [r3, #-40]
 803887a:	f7d0 fac5 	bl	8008e08 <SE_KMS_DestroyObject>
 803887e:	4604      	mov	r4, r0
        for (uint8_t i = 0; i < ulCount; i++)
 8038880:	3501      	adds	r5, #1
 8038882:	9a04      	ldr	r2, [sp, #16]
 8038884:	b2eb      	uxtb	r3, r5
 8038886:	429a      	cmp	r2, r3
 8038888:	d8f0      	bhi.n	803886c <SecureElementDeleteDynamicKeys+0xc0>
 803888a:	e7d5      	b.n	8038838 <SecureElementDeleteDynamicKeys+0x8c>
 803888c:	2500      	movs	r5, #0
 803888e:	e7f8      	b.n	8038882 <SecureElementDeleteDynamicKeys+0xd6>
 8038890:	444e524c 	.word	0x444e524c
 8038894:	5f505041 	.word	0x5f505041
 8038898:	5f4b574e 	.word	0x5f4b574e
 803889c:	534b574e 	.word	0x534b574e
 80388a0:	53505041 	.word	0x53505041
 80388a4:	5452434d 	.word	0x5452434d
 80388a8:	454b434d 	.word	0x454b434d
 80388ac:	304b434d 	.word	0x304b434d
 80388b0:	3053414d 	.word	0x3053414d
 80388b4:	30534e4d 	.word	0x30534e4d

080388b8 <SecureElementSetObjHandler>:
#if (!defined (LORAWAN_KMS) || (LORAWAN_KMS == 0))
    return SECURE_ELEMENT_ERROR;
#else /* LORAWAN_KMS == 1 */
    for (uint8_t i = 0; i < NUM_OF_KEYS; i++)
    {
        if (SeNvm->KeyList[i].KeyID == keyID)
 80388b8:	4b0a      	ldr	r3, [pc, #40]	; (80388e4 <SecureElementSetObjHandler+0x2c>)
 80388ba:	681a      	ldr	r2, [r3, #0]
{
 80388bc:	b5f0      	push	{r4, r5, r6, r7, lr}
        if (SeNvm->KeyList[i].KeyID == keyID)
 80388be:	2300      	movs	r3, #0
 80388c0:	f102 0510 	add.w	r5, r2, #16
 80388c4:	2618      	movs	r6, #24
 80388c6:	fb06 f403 	mul.w	r4, r6, r3
 80388ca:	5d2f      	ldrb	r7, [r5, r4]
 80388cc:	4287      	cmp	r7, r0
 80388ce:	d103      	bne.n	80388d8 <SecureElementSetObjHandler+0x20>
        {
            SeNvm->KeyList[i].Object_Index = (CK_OBJECT_HANDLE) keyIndex;
 80388d0:	4422      	add	r2, r4
            return SECURE_ELEMENT_SUCCESS;
 80388d2:	2000      	movs	r0, #0
            SeNvm->KeyList[i].Object_Index = (CK_OBJECT_HANDLE) keyIndex;
 80388d4:	6251      	str	r1, [r2, #36]	; 0x24
        }
    }
    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
#endif /* LORAWAN_KMS */
}
 80388d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    for (uint8_t i = 0; i < NUM_OF_KEYS; i++)
 80388d8:	3301      	adds	r3, #1
 80388da:	2b0a      	cmp	r3, #10
 80388dc:	d1f3      	bne.n	80388c6 <SecureElementSetObjHandler+0xe>
    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 80388de:	2003      	movs	r0, #3
 80388e0:	e7f9      	b.n	80388d6 <SecureElementSetObjHandler+0x1e>
 80388e2:	bf00      	nop
 80388e4:	20005738 	.word	0x20005738

080388e8 <SecureElementInit>:
{
 80388e8:	b510      	push	{r4, lr}
    uint8_t devEUI[SE_EUI_SIZE] = LORAWAN_DEVICE_EUI;
 80388ea:	4b4c      	ldr	r3, [pc, #304]	; (8038a1c <SecureElementInit+0x134>)
{
 80388ec:	b092      	sub	sp, #72	; 0x48
    uint8_t devEUI[SE_EUI_SIZE] = LORAWAN_DEVICE_EUI;
 80388ee:	6859      	ldr	r1, [r3, #4]
{
 80388f0:	4602      	mov	r2, r0
    uint8_t devEUI[SE_EUI_SIZE] = LORAWAN_DEVICE_EUI;
 80388f2:	6818      	ldr	r0, [r3, #0]
 80388f4:	ac04      	add	r4, sp, #16
 80388f6:	c403      	stmia	r4!, {r0, r1}
    uint8_t joinEUI[SE_EUI_SIZE] = LORAWAN_JOIN_EUI;
 80388f8:	f853 0f08 	ldr.w	r0, [r3, #8]!
 80388fc:	6859      	ldr	r1, [r3, #4]
 80388fe:	ac06      	add	r4, sp, #24
 8038900:	c403      	stmia	r4!, {r0, r1}
    if (nvm == NULL)
 8038902:	4610      	mov	r0, r2
 8038904:	2a00      	cmp	r2, #0
 8038906:	f000 8087 	beq.w	8038a18 <SecureElementInit+0x130>
    SeNvm = nvm;
 803890a:	4c45      	ldr	r4, [pc, #276]	; (8038a20 <SecureElementInit+0x138>)
    memcpy1((uint8_t *)SeNvm->DevEui, devEUI, SE_EUI_SIZE);
 803890c:	a904      	add	r1, sp, #16
    SeNvm = nvm;
 803890e:	6022      	str	r2, [r4, #0]
    memcpy1((uint8_t *)SeNvm->DevEui, devEUI, SE_EUI_SIZE);
 8038910:	2208      	movs	r2, #8
 8038912:	f000 fb0b 	bl	8038f2c <memcpy1>
    memcpy1((uint8_t *)SeNvm->JoinEui, joinEUI, SE_EUI_SIZE);
 8038916:	6820      	ldr	r0, [r4, #0]
 8038918:	2208      	movs	r2, #8
 803891a:	4410      	add	r0, r2
 803891c:	a906      	add	r1, sp, #24
 803891e:	f000 fb05 	bl	8038f2c <memcpy1>
    SeNvm->KeyList[itr++].KeyID = APP_KEY;
 8038922:	6822      	ldr	r2, [r4, #0]
    SeNvm->KeyList[itr++].KeyID = MC_KE_KEY;
 8038924:	207f      	movs	r0, #127	; 0x7f
 8038926:	f882 0088 	strb.w	r0, [r2, #136]	; 0x88
    SeNvm->KeyList[itr++].KeyID = NWK_KEY;
 803892a:	2101      	movs	r1, #1
    SeNvm->KeyList[itr++].KeyID = MC_KEY_0;
 803892c:	2080      	movs	r0, #128	; 0x80
    SeNvm->KeyList[itr++].KeyID = NWK_KEY;
 803892e:	f882 1028 	strb.w	r1, [r2, #40]	; 0x28
    SeNvm->KeyList[itr++].KeyID = MC_KEY_0;
 8038932:	f882 00a0 	strb.w	r0, [r2, #160]	; 0xa0
    SeNvm->KeyList[itr++].KeyID = NWK_S_KEY;
 8038936:	2102      	movs	r1, #2
    SeNvm->KeyList[itr++].KeyID = MC_APP_S_KEY_0;
 8038938:	2081      	movs	r0, #129	; 0x81
    SeNvm->KeyList[itr++].KeyID = NWK_S_KEY;
 803893a:	f882 1040 	strb.w	r1, [r2, #64]	; 0x40
    SeNvm->KeyList[itr++].KeyID = MC_APP_S_KEY_0;
 803893e:	f882 00b8 	strb.w	r0, [r2, #184]	; 0xb8
    SeNvm->KeyList[itr++].KeyID = APP_S_KEY;
 8038942:	2103      	movs	r1, #3
    SeNvm->KeyList[itr++].KeyID = MC_NWK_S_KEY_0;
 8038944:	2082      	movs	r0, #130	; 0x82
    SeNvm->KeyList[itr++].KeyID = APP_KEY;
 8038946:	2300      	movs	r3, #0
    SeNvm->KeyList[itr++].KeyID = APP_S_KEY;
 8038948:	f882 1058 	strb.w	r1, [r2, #88]	; 0x58
    SeNvm->KeyList[itr++].KeyID = MC_NWK_S_KEY_0;
 803894c:	f882 00d0 	strb.w	r0, [r2, #208]	; 0xd0
    SeNvm->KeyList[itr++].KeyID = MC_ROOT_KEY;
 8038950:	2104      	movs	r1, #4
    SeNvm->KeyList[itr].KeyID = SLOT_RAND_ZERO_KEY;
 8038952:	2083      	movs	r0, #131	; 0x83
 8038954:	f882 00e8 	strb.w	r0, [r2, #232]	; 0xe8
    SeNvm->KeyList[itr++].KeyID = APP_KEY;
 8038958:	7413      	strb	r3, [r2, #16]
    SeNvm->KeyList[itr++].KeyID = MC_ROOT_KEY;
 803895a:	f882 1070 	strb.w	r1, [r2, #112]	; 0x70
    rv = C_OpenSession(0,  session_flags, NULL, 0, &session);
 803895e:	aa02      	add	r2, sp, #8
 8038960:	9200      	str	r2, [sp, #0]
 8038962:	4618      	mov	r0, r3
 8038964:	461a      	mov	r2, r3
    uint32_t ulCount = 0;
 8038966:	9303      	str	r3, [sp, #12]
    rv = C_OpenSession(0,  session_flags, NULL, 0, &session);
 8038968:	f7d0 f9f8 	bl	8008d5c <SE_KMS_OpenSession>
    if (rv == CKR_OK)
 803896c:	b978      	cbnz	r0, 803898e <SecureElementInit+0xa6>
        rv = C_FindObjectsInit(session, NULL, 0);
 803896e:	4602      	mov	r2, r0
 8038970:	4601      	mov	r1, r0
 8038972:	9802      	ldr	r0, [sp, #8]
 8038974:	f7d0 fa9e 	bl	8008eb4 <SE_KMS_FindObjectsInit>
    if (rv == CKR_OK)
 8038978:	b948      	cbnz	r0, 803898e <SecureElementInit+0xa6>
        rv = C_FindObjects(session, hObject, NUM_OF_KEYS, (CK_ULONG *) &ulCount);
 803897a:	9802      	ldr	r0, [sp, #8]
 803897c:	ab03      	add	r3, sp, #12
 803897e:	220a      	movs	r2, #10
 8038980:	a908      	add	r1, sp, #32
 8038982:	f7d0 fab3 	bl	8008eec <SE_KMS_FindObjects>
    if (rv == CKR_OK)
 8038986:	b910      	cbnz	r0, 803898e <SecureElementInit+0xa6>
        rv = C_FindObjectsFinal(session);
 8038988:	9802      	ldr	r0, [sp, #8]
 803898a:	f7d0 facd 	bl	8008f28 <SE_KMS_FindObjectsFinal>
    if (ulCount <= NUM_OF_KEYS)
 803898e:	9b03      	ldr	r3, [sp, #12]
 8038990:	2b0a      	cmp	r3, #10
 8038992:	d93f      	bls.n	8038a14 <SecureElementInit+0x12c>
    if (session > 0)
 8038994:	9802      	ldr	r0, [sp, #8]
 8038996:	b108      	cbz	r0, 803899c <SecureElementInit+0xb4>
        (void)C_CloseSession(session);
 8038998:	f7d0 fa00 	bl	8008d9c <SE_KMS_CloseSession>
    SecureElementSetObjHandler(APP_KEY, KMS_APP_KEY_OBJECT_HANDLE);
 803899c:	210e      	movs	r1, #14
 803899e:	2000      	movs	r0, #0
 80389a0:	f7ff ff8a 	bl	80388b8 <SecureElementSetObjHandler>
    SecureElementSetObjHandler(NWK_KEY, KMS_NWK_KEY_OBJECT_HANDLE);
 80389a4:	210f      	movs	r1, #15
 80389a6:	2001      	movs	r0, #1
 80389a8:	f7ff ff86 	bl	80388b8 <SecureElementSetObjHandler>
    SecureElementSetObjHandler(APP_S_KEY, KMS_APP_S_KEY_OBJECT_HANDLE);
 80389ac:	2111      	movs	r1, #17
 80389ae:	2003      	movs	r0, #3
 80389b0:	f7ff ff82 	bl	80388b8 <SecureElementSetObjHandler>
    SecureElementSetObjHandler(NWK_S_KEY, KMS_NWK_S_KEY_OBJECT_HANDLE);
 80389b4:	2110      	movs	r1, #16
 80389b6:	2002      	movs	r0, #2
 80389b8:	f7ff ff7e 	bl	80388b8 <SecureElementSetObjHandler>
    MW_LOG(TS_OFF, VLEVEL_M, "###### OTAA ######\r\n");
 80389bc:	2200      	movs	r2, #0
 80389be:	4611      	mov	r1, r2
 80389c0:	4b18      	ldr	r3, [pc, #96]	; (8038a24 <SecureElementInit+0x13c>)
 80389c2:	2002      	movs	r0, #2
 80389c4:	f002 f998 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
    PrintKey(APP_KEY);
 80389c8:	2000      	movs	r0, #0
 80389ca:	f7ff fe81 	bl	80386d0 <PrintKey>
    PrintKey(NWK_KEY);
 80389ce:	2001      	movs	r0, #1
 80389d0:	f7ff fe7e 	bl	80386d0 <PrintKey>
    MW_LOG(TS_OFF, VLEVEL_M, "###### ABP  ######\r\n");
 80389d4:	2200      	movs	r2, #0
 80389d6:	4b14      	ldr	r3, [pc, #80]	; (8038a28 <SecureElementInit+0x140>)
 80389d8:	4611      	mov	r1, r2
 80389da:	2002      	movs	r0, #2
 80389dc:	f002 f98c 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
    PrintKey(APP_S_KEY);
 80389e0:	2003      	movs	r0, #3
 80389e2:	f7ff fe75 	bl	80386d0 <PrintKey>
    PrintKey(NWK_S_KEY);
 80389e6:	2002      	movs	r0, #2
 80389e8:	f7ff fe72 	bl	80386d0 <PrintKey>
    return SECURE_ELEMENT_SUCCESS;
 80389ec:	2000      	movs	r0, #0
}
 80389ee:	b012      	add	sp, #72	; 0x48
 80389f0:	bd10      	pop	{r4, pc}
            if (hObject[i] > LAST_KMS_KEY_OBJECT_HANDLE)
 80389f2:	aa12      	add	r2, sp, #72	; 0x48
 80389f4:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80389f8:	f853 1c28 	ldr.w	r1, [r3, #-40]
 80389fc:	2912      	cmp	r1, #18
 80389fe:	d903      	bls.n	8038a08 <SecureElementInit+0x120>
                if (rv == CKR_OK)
 8038a00:	b910      	cbnz	r0, 8038a08 <SecureElementInit+0x120>
                    rv = C_DestroyObject(session, hObject[i]);
 8038a02:	9802      	ldr	r0, [sp, #8]
 8038a04:	f7d0 fa00 	bl	8008e08 <SE_KMS_DestroyObject>
        for (uint8_t i = 0; i < ulCount; i++)
 8038a08:	3401      	adds	r4, #1
 8038a0a:	9a03      	ldr	r2, [sp, #12]
 8038a0c:	b2e3      	uxtb	r3, r4
 8038a0e:	4293      	cmp	r3, r2
 8038a10:	d3ef      	bcc.n	80389f2 <SecureElementInit+0x10a>
 8038a12:	e7bf      	b.n	8038994 <SecureElementInit+0xac>
 8038a14:	2400      	movs	r4, #0
 8038a16:	e7f8      	b.n	8038a0a <SecureElementInit+0x122>
        return SECURE_ELEMENT_ERROR_NPE;
 8038a18:	2002      	movs	r0, #2
 8038a1a:	e7e8      	b.n	80389ee <SecureElementInit+0x106>
 8038a1c:	0803bbdc 	.word	0x0803bbdc
 8038a20:	20005738 	.word	0x20005738
 8038a24:	0803c536 	.word	0x0803c536
 8038a28:	0803c54b 	.word	0x0803c54b

08038a2c <SecureElementComputeAesCmac>:
#endif /* LORAWAN_KMS */
}

SecureElementStatus_t SecureElementComputeAesCmac( uint8_t* micBxBuffer, uint8_t* buffer, uint16_t size,
                                                   KeyIdentifier_t keyID, uint32_t* cmac )
{
 8038a2c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8038a30:	b089      	sub	sp, #36	; 0x24
    if( keyID >= LORAMAC_CRYPTO_MULTICAST_KEYS )
 8038a32:	2b7e      	cmp	r3, #126	; 0x7e
{
 8038a34:	4681      	mov	r9, r0
 8038a36:	9f10      	ldr	r7, [sp, #64]	; 0x40
 8038a38:	4688      	mov	r8, r1
 8038a3a:	4616      	mov	r6, r2
 8038a3c:	4618      	mov	r0, r3
    if( keyID >= LORAMAC_CRYPTO_MULTICAST_KEYS )
 8038a3e:	d851      	bhi.n	8038ae4 <SecureElementComputeAesCmac+0xb8>
    if( ( buffer == NULL ) || ( cmac == NULL ) )
 8038a40:	2900      	cmp	r1, #0
 8038a42:	d04d      	beq.n	8038ae0 <SecureElementComputeAesCmac+0xb4>
 8038a44:	2f00      	cmp	r7, #0
 8038a46:	d04b      	beq.n	8038ae0 <SecureElementComputeAesCmac+0xb4>
    uint32_t tag_lenth = 0;
 8038a48:	2300      	movs	r3, #0
    CK_MECHANISM aes_cmac_mechanism = { CKM_AES_CMAC, (CK_VOID_PTR)NULL, 0 };
 8038a4a:	f241 028a 	movw	r2, #4234	; 0x108a
    SecureElementStatus_t retval = GetKeyIndexByID(keyID, &key_handle);
 8038a4e:	a904      	add	r1, sp, #16
    CK_MECHANISM aes_cmac_mechanism = { CKM_AES_CMAC, (CK_VOID_PTR)NULL, 0 };
 8038a50:	e9cd 2305 	strd	r2, r3, [sp, #20]
    uint32_t tag_lenth = 0;
 8038a54:	9303      	str	r3, [sp, #12]
    CK_MECHANISM aes_cmac_mechanism = { CKM_AES_CMAC, (CK_VOID_PTR)NULL, 0 };
 8038a56:	9307      	str	r3, [sp, #28]
    SecureElementStatus_t retval = GetKeyIndexByID(keyID, &key_handle);
 8038a58:	f7ff fdcc 	bl	80385f4 <GetKeyIndexByID>
    if (retval != SECURE_ELEMENT_SUCCESS)
 8038a5c:	4605      	mov	r5, r0
 8038a5e:	2800      	cmp	r0, #0
 8038a60:	d131      	bne.n	8038ac6 <SecureElementComputeAesCmac+0x9a>
    rv = C_OpenSession(0,    session_flags, NULL, 0, &session);
 8038a62:	ab02      	add	r3, sp, #8
 8038a64:	9300      	str	r3, [sp, #0]
 8038a66:	4602      	mov	r2, r0
 8038a68:	4603      	mov	r3, r0
 8038a6a:	2104      	movs	r1, #4
 8038a6c:	f7d0 f976 	bl	8008d5c <SE_KMS_OpenSession>
    if (rv == CKR_OK)
 8038a70:	4604      	mov	r4, r0
 8038a72:	b9f0      	cbnz	r0, 8038ab2 <SecureElementComputeAesCmac+0x86>
        rv = C_SignInit(session, &aes_cmac_mechanism, key_handle);
 8038a74:	9a04      	ldr	r2, [sp, #16]
 8038a76:	9802      	ldr	r0, [sp, #8]
 8038a78:	a905      	add	r1, sp, #20
 8038a7a:	f7d0 fbcf 	bl	800921c <SE_KMS_SignInit>
    if (rv == CKR_OK)
 8038a7e:	4604      	mov	r4, r0
 8038a80:	b9b8      	cbnz	r0, 8038ab2 <SecureElementComputeAesCmac+0x86>
        if (micBxBuffer != NULL)
 8038a82:	ac03      	add	r4, sp, #12
 8038a84:	f1b9 0f00 	cmp.w	r9, #0
 8038a88:	d021      	beq.n	8038ace <SecureElementComputeAesCmac+0xa2>
            memcpy1((uint8_t *) &input_align_combined_buf[0], (uint8_t *) micBxBuffer, SE_KEY_SIZE);
 8038a8a:	4817      	ldr	r0, [pc, #92]	; (8038ae8 <SecureElementComputeAesCmac+0xbc>)
 8038a8c:	2210      	movs	r2, #16
 8038a8e:	4649      	mov	r1, r9
 8038a90:	f000 fa4c 	bl	8038f2c <memcpy1>
            memcpy1((uint8_t *) &input_align_combined_buf[SE_KEY_SIZE], (uint8_t *) buffer, size);
 8038a94:	4632      	mov	r2, r6
 8038a96:	4815      	ldr	r0, [pc, #84]	; (8038aec <SecureElementComputeAesCmac+0xc0>)
 8038a98:	4641      	mov	r1, r8
 8038a9a:	f000 fa47 	bl	8038f2c <memcpy1>
            rv = C_Sign(session, (CK_BYTE_PTR)&input_align_combined_buf[0], size + SE_KEY_SIZE, &tag[0],
 8038a9e:	4b14      	ldr	r3, [pc, #80]	; (8038af0 <SecureElementComputeAesCmac+0xc4>)
 8038aa0:	9400      	str	r4, [sp, #0]
 8038aa2:	f106 0210 	add.w	r2, r6, #16
            rv = C_Sign(session, (CK_BYTE_PTR)&input_align_combined_buf[0], size, &tag[0],
 8038aa6:	9802      	ldr	r0, [sp, #8]
 8038aa8:	f5a3 7190 	sub.w	r1, r3, #288	; 0x120
 8038aac:	f7d0 fbd2 	bl	8009254 <SE_KMS_Sign>
 8038ab0:	4604      	mov	r4, r0
    (void)C_CloseSession(session);
 8038ab2:	9802      	ldr	r0, [sp, #8]
 8038ab4:	f7d0 f972 	bl	8008d9c <SE_KMS_CloseSession>
    *cmac = (uint32_t)((uint32_t) tag[3] << 24 | (uint32_t) tag[2] << 16 | (uint32_t) tag[1] << 8 |
 8038ab8:	4b0e      	ldr	r3, [pc, #56]	; (8038af4 <SecureElementComputeAesCmac+0xc8>)
        retval = SECURE_ELEMENT_ERROR;
 8038aba:	2c00      	cmp	r4, #0
    *cmac = (uint32_t)((uint32_t) tag[3] << 24 | (uint32_t) tag[2] << 16 | (uint32_t) tag[1] << 8 |
 8038abc:	f8d3 3124 	ldr.w	r3, [r3, #292]	; 0x124
 8038ac0:	603b      	str	r3, [r7, #0]
        retval = SECURE_ELEMENT_ERROR;
 8038ac2:	bf18      	it	ne
 8038ac4:	2506      	movne	r5, #6
        // Never accept multicast key identifier for cmac computation
        return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
    }

    return ComputeCmac( micBxBuffer, buffer, size, keyID, cmac );
}
 8038ac6:	4628      	mov	r0, r5
 8038ac8:	b009      	add	sp, #36	; 0x24
 8038aca:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            memcpy1((uint8_t *) &input_align_combined_buf[0], (uint8_t *) buffer, size);
 8038ace:	4632      	mov	r2, r6
 8038ad0:	4805      	ldr	r0, [pc, #20]	; (8038ae8 <SecureElementComputeAesCmac+0xbc>)
 8038ad2:	4641      	mov	r1, r8
 8038ad4:	f000 fa2a 	bl	8038f2c <memcpy1>
            rv = C_Sign(session, (CK_BYTE_PTR)&input_align_combined_buf[0], size, &tag[0],
 8038ad8:	4b05      	ldr	r3, [pc, #20]	; (8038af0 <SecureElementComputeAesCmac+0xc4>)
 8038ada:	9400      	str	r4, [sp, #0]
 8038adc:	4632      	mov	r2, r6
 8038ade:	e7e2      	b.n	8038aa6 <SecureElementComputeAesCmac+0x7a>
        return SECURE_ELEMENT_ERROR_NPE;
 8038ae0:	2502      	movs	r5, #2
    return ComputeCmac( micBxBuffer, buffer, size, keyID, cmac );
 8038ae2:	e7f0      	b.n	8038ac6 <SecureElementComputeAesCmac+0x9a>
        return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 8038ae4:	2503      	movs	r5, #3
 8038ae6:	e7ee      	b.n	8038ac6 <SecureElementComputeAesCmac+0x9a>
 8038ae8:	2000573c 	.word	0x2000573c
 8038aec:	2000574c 	.word	0x2000574c
 8038af0:	2000585c 	.word	0x2000585c
 8038af4:	20005738 	.word	0x20005738

08038af8 <SecureElementVerifyAesCmac>:

SecureElementStatus_t SecureElementVerifyAesCmac( uint8_t* buffer, uint16_t size, uint32_t expectedCmac,
                                                  KeyIdentifier_t keyID )
{
 8038af8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8038afa:	b08b      	sub	sp, #44	; 0x2c
 8038afc:	460e      	mov	r6, r1
 8038afe:	9203      	str	r2, [sp, #12]
    if( buffer == NULL )
 8038b00:	4607      	mov	r7, r0
 8038b02:	2800      	cmp	r0, #0
 8038b04:	d032      	beq.n	8038b6c <SecureElementVerifyAesCmac+0x74>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

    /* AES CMAC Authentication variables */
    CK_MECHANISM aes_cmac_mechanism = { CKM_AES_CMAC, (CK_VOID_PTR)NULL, 0 };
 8038b06:	2200      	movs	r2, #0
 8038b08:	f241 018a 	movw	r1, #4234	; 0x108a
 8038b0c:	e9cd 1207 	strd	r1, r2, [sp, #28]

    retval = GetKeyIndexByID(keyID, &object_handle);
 8038b10:	4618      	mov	r0, r3
 8038b12:	a906      	add	r1, sp, #24
    CK_MECHANISM aes_cmac_mechanism = { CKM_AES_CMAC, (CK_VOID_PTR)NULL, 0 };
 8038b14:	9209      	str	r2, [sp, #36]	; 0x24
    retval = GetKeyIndexByID(keyID, &object_handle);
 8038b16:	f7ff fd6d 	bl	80385f4 <GetKeyIndexByID>
    if (retval != SECURE_ELEMENT_SUCCESS)
 8038b1a:	4605      	mov	r5, r0
 8038b1c:	bb18      	cbnz	r0, 8038b66 <SecureElementVerifyAesCmac+0x6e>
    {
        return retval;
    }

    /* Open session with KMS */
    rv = C_OpenSession(0,    session_flags, NULL, 0, &session);
 8038b1e:	ab05      	add	r3, sp, #20
 8038b20:	9300      	str	r3, [sp, #0]
 8038b22:	4602      	mov	r2, r0
 8038b24:	4603      	mov	r3, r0
 8038b26:	2104      	movs	r1, #4
 8038b28:	f7d0 f918 	bl	8008d5c <SE_KMS_OpenSession>

    /* Configure session to Verify the message in AES CMAC with settings included into the mechanism */
    if (rv == CKR_OK)
 8038b2c:	4604      	mov	r4, r0
 8038b2e:	b9a0      	cbnz	r0, 8038b5a <SecureElementVerifyAesCmac+0x62>
    {
        rv = C_VerifyInit(session, &aes_cmac_mechanism, object_handle);
 8038b30:	9a06      	ldr	r2, [sp, #24]
 8038b32:	9805      	ldr	r0, [sp, #20]
 8038b34:	a907      	add	r1, sp, #28
 8038b36:	f7d0 fbad 	bl	8009294 <SE_KMS_VerifyInit>
    }

    /* Verify the message */
    if (rv == CKR_OK)
 8038b3a:	4604      	mov	r4, r0
 8038b3c:	b968      	cbnz	r0, 8038b5a <SecureElementVerifyAesCmac+0x62>
    {
        memcpy1(input_align_combined_buf, buffer, size);
 8038b3e:	480c      	ldr	r0, [pc, #48]	; (8038b70 <SecureElementVerifyAesCmac+0x78>)
 8038b40:	4632      	mov	r2, r6
 8038b42:	4639      	mov	r1, r7
 8038b44:	f000 f9f2 	bl	8038f2c <memcpy1>
        rv = C_Verify(session, (CK_BYTE_PTR)input_align_combined_buf, size, (CK_BYTE_PTR)&expectedCmac, 4);
 8038b48:	2304      	movs	r3, #4
 8038b4a:	9300      	str	r3, [sp, #0]
 8038b4c:	4908      	ldr	r1, [pc, #32]	; (8038b70 <SecureElementVerifyAesCmac+0x78>)
 8038b4e:	9805      	ldr	r0, [sp, #20]
 8038b50:	ab03      	add	r3, sp, #12
 8038b52:	4632      	mov	r2, r6
 8038b54:	f7d0 fbba 	bl	80092cc <SE_KMS_Verify>
 8038b58:	4604      	mov	r4, r0
    }

    (void)C_CloseSession(session);
 8038b5a:	9805      	ldr	r0, [sp, #20]
 8038b5c:	f7d0 f91e 	bl	8008d9c <SE_KMS_CloseSession>

    if (rv != CKR_OK)
    {
        retval = SECURE_ELEMENT_ERROR;
 8038b60:	2c00      	cmp	r4, #0
 8038b62:	bf18      	it	ne
 8038b64:	2506      	movne	r5, #6
    }

#endif /* LORAWAN_KMS */

    return retval;
}
 8038b66:	4628      	mov	r0, r5
 8038b68:	b00b      	add	sp, #44	; 0x2c
 8038b6a:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 8038b6c:	2502      	movs	r5, #2
 8038b6e:	e7fa      	b.n	8038b66 <SecureElementVerifyAesCmac+0x6e>
 8038b70:	2000573c 	.word	0x2000573c

08038b74 <SecureElementAesEncrypt>:

SecureElementStatus_t SecureElementAesEncrypt( uint8_t* buffer, uint16_t size, KeyIdentifier_t keyID,
                                               uint8_t* encBuffer )
{
 8038b74:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8038b78:	460e      	mov	r6, r1
 8038b7a:	b08e      	sub	sp, #56	; 0x38
 8038b7c:	461f      	mov	r7, r3
    if( buffer == NULL || encBuffer == NULL )
 8038b7e:	4680      	mov	r8, r0
 8038b80:	2800      	cmp	r0, #0
 8038b82:	d050      	beq.n	8038c26 <SecureElementAesEncrypt+0xb2>
 8038b84:	2b00      	cmp	r3, #0
 8038b86:	d04e      	beq.n	8038c26 <SecureElementAesEncrypt+0xb2>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

    // Check if the size is divisible by 16,
    if( ( size % 16 ) != 0 )
 8038b88:	f011 040f 	ands.w	r4, r1, #15
 8038b8c:	d14d      	bne.n	8038c2a <SecureElementAesEncrypt+0xb6>
    uint32_t encrypted_length = 0;
    CK_OBJECT_HANDLE object_handle;
    uint8_t dummy_tag[SE_KEY_SIZE] = {0};
    uint32_t dummy_tag_lenth = 0;

    CK_MECHANISM aes_ecb_mechanism = { CKM_AES_ECB, (CK_VOID_PTR *) NULL, 0 };
 8038b8e:	f241 0381 	movw	r3, #4225	; 0x1081

    SecureElementStatus_t retval = GetKeyIndexByID(keyID, &object_handle);
 8038b92:	a905      	add	r1, sp, #20
 8038b94:	4610      	mov	r0, r2
    uint8_t dummy_tag[SE_KEY_SIZE] = {0};
 8038b96:	e9cd 440a 	strd	r4, r4, [sp, #40]	; 0x28
 8038b9a:	e9cd 440c 	strd	r4, r4, [sp, #48]	; 0x30
    CK_MECHANISM aes_ecb_mechanism = { CKM_AES_ECB, (CK_VOID_PTR *) NULL, 0 };
 8038b9e:	e9cd 3407 	strd	r3, r4, [sp, #28]
    uint32_t encrypted_length = 0;
 8038ba2:	9404      	str	r4, [sp, #16]
    uint32_t dummy_tag_lenth = 0;
 8038ba4:	9406      	str	r4, [sp, #24]
    CK_MECHANISM aes_ecb_mechanism = { CKM_AES_ECB, (CK_VOID_PTR *) NULL, 0 };
 8038ba6:	9409      	str	r4, [sp, #36]	; 0x24
    SecureElementStatus_t retval = GetKeyIndexByID(keyID, &object_handle);
 8038ba8:	f7ff fd24 	bl	80385f4 <GetKeyIndexByID>
    if (retval != SECURE_ELEMENT_SUCCESS)
 8038bac:	4605      	mov	r5, r0
 8038bae:	2800      	cmp	r0, #0
 8038bb0:	d135      	bne.n	8038c1e <SecureElementAesEncrypt+0xaa>
    {
        return retval;
    }

    /* Open session with KMS */
    rv = C_OpenSession(0,    session_flags, NULL, 0, &session);
 8038bb2:	ab03      	add	r3, sp, #12
 8038bb4:	9300      	str	r3, [sp, #0]
 8038bb6:	4602      	mov	r2, r0
 8038bb8:	4603      	mov	r3, r0
 8038bba:	2104      	movs	r1, #4
 8038bbc:	f7d0 f8ce 	bl	8008d5c <SE_KMS_OpenSession>

    /* Configure session to encrypt message in AES ECB with settings included into the mechanism */
    if (rv == CKR_OK)
 8038bc0:	4604      	mov	r4, r0
 8038bc2:	bb30      	cbnz	r0, 8038c12 <SecureElementAesEncrypt+0x9e>
    {
        rv = C_EncryptInit(session, &aes_ecb_mechanism, object_handle);
 8038bc4:	9a05      	ldr	r2, [sp, #20]
 8038bc6:	9803      	ldr	r0, [sp, #12]
 8038bc8:	a907      	add	r1, sp, #28
 8038bca:	f7d0 f9c5 	bl	8008f58 <SE_KMS_EncryptInit>
    }

    /* Encrypt clear message */
    if (rv == CKR_OK)
 8038bce:	4604      	mov	r4, r0
 8038bd0:	b9f8      	cbnz	r0, 8038c12 <SecureElementAesEncrypt+0x9e>
    {
        memcpy1(input_align_combined_buf, buffer, size);
 8038bd2:	4817      	ldr	r0, [pc, #92]	; (8038c30 <SecureElementAesEncrypt+0xbc>)
 8038bd4:	4632      	mov	r2, r6
 8038bd6:	4641      	mov	r1, r8
 8038bd8:	f000 f9a8 	bl	8038f2c <memcpy1>
        encrypted_length = sizeof(output_align);
 8038bdc:	f44f 7387 	mov.w	r3, #270	; 0x10e
 8038be0:	9304      	str	r3, [sp, #16]
        rv = C_EncryptUpdate(session, (CK_BYTE_PTR)input_align_combined_buf, size,
 8038be2:	ab04      	add	r3, sp, #16
 8038be4:	9300      	str	r3, [sp, #0]
 8038be6:	4b13      	ldr	r3, [pc, #76]	; (8038c34 <SecureElementAesEncrypt+0xc0>)
 8038be8:	9803      	ldr	r0, [sp, #12]
 8038bea:	4632      	mov	r2, r6
 8038bec:	f5a3 7198 	sub.w	r1, r3, #304	; 0x130
 8038bf0:	f7d0 f9ee 	bl	8008fd0 <SE_KMS_EncryptUpdate>
                             output_align, (CK_ULONG_PTR)&encrypted_length);
        memcpy1(encBuffer, output_align, size);
 8038bf4:	490f      	ldr	r1, [pc, #60]	; (8038c34 <SecureElementAesEncrypt+0xc0>)
        rv = C_EncryptUpdate(session, (CK_BYTE_PTR)input_align_combined_buf, size,
 8038bf6:	4604      	mov	r4, r0
        memcpy1(encBuffer, output_align, size);
 8038bf8:	4632      	mov	r2, r6
 8038bfa:	4638      	mov	r0, r7
 8038bfc:	f000 f996 	bl	8038f2c <memcpy1>
    }

    /* In this case C_EncryptFinal is just called to Free the Alloc mem */
    if (rv == CKR_OK)
 8038c00:	b93c      	cbnz	r4, 8038c12 <SecureElementAesEncrypt+0x9e>
    {
        dummy_tag_lenth = sizeof(tag);
 8038c02:	2310      	movs	r3, #16
        rv = C_EncryptFinal(session, &dummy_tag[0], (CK_ULONG_PTR)&dummy_tag_lenth);
 8038c04:	9803      	ldr	r0, [sp, #12]
        dummy_tag_lenth = sizeof(tag);
 8038c06:	9306      	str	r3, [sp, #24]
        rv = C_EncryptFinal(session, &dummy_tag[0], (CK_ULONG_PTR)&dummy_tag_lenth);
 8038c08:	aa06      	add	r2, sp, #24
 8038c0a:	a90a      	add	r1, sp, #40	; 0x28
 8038c0c:	f7d0 fa00 	bl	8009010 <SE_KMS_EncryptFinal>
 8038c10:	4604      	mov	r4, r0
    }

    /* Close session with KMS */
    (void)C_CloseSession(session);
 8038c12:	9803      	ldr	r0, [sp, #12]
 8038c14:	f7d0 f8c2 	bl	8008d9c <SE_KMS_CloseSession>

    if (rv != CKR_OK)
    {
        retval = SECURE_ELEMENT_ERROR;
 8038c18:	2c00      	cmp	r4, #0
 8038c1a:	bf18      	it	ne
 8038c1c:	2506      	movne	r5, #6
    }
#endif /* LORAWAN_KMS */

    return retval;
}
 8038c1e:	4628      	mov	r0, r5
 8038c20:	b00e      	add	sp, #56	; 0x38
 8038c22:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 8038c26:	2502      	movs	r5, #2
 8038c28:	e7f9      	b.n	8038c1e <SecureElementAesEncrypt+0xaa>
        return SECURE_ELEMENT_ERROR_BUF_SIZE;
 8038c2a:	2505      	movs	r5, #5
 8038c2c:	e7f7      	b.n	8038c1e <SecureElementAesEncrypt+0xaa>
 8038c2e:	bf00      	nop
 8038c30:	2000573c 	.word	0x2000573c
 8038c34:	2000586c 	.word	0x2000586c

08038c38 <SecureElementSetKey>:
{
 8038c38:	b570      	push	{r4, r5, r6, lr}
 8038c3a:	4606      	mov	r6, r0
 8038c3c:	b0a0      	sub	sp, #128	; 0x80
    if( key == NULL )
 8038c3e:	4608      	mov	r0, r1
 8038c40:	2900      	cmp	r1, #0
 8038c42:	d07a      	beq.n	8038d3a <SecureElementSetKey+0x102>
    CK_ULONG template_type = CKK_AES;
 8038c44:	2204      	movs	r2, #4
 8038c46:	231f      	movs	r3, #31
 8038c48:	e9cd 2304 	strd	r2, r3, [sp, #16]
    CK_ULONG template_true = CK_TRUE;
 8038c4c:	680b      	ldr	r3, [r1, #0]
 8038c4e:	ba1b      	rev	r3, r3
    uint32_t key_ui32[] =
 8038c50:	9309      	str	r3, [sp, #36]	; 0x24
 8038c52:	684b      	ldr	r3, [r1, #4]
 8038c54:	ba1b      	rev	r3, r3
 8038c56:	930a      	str	r3, [sp, #40]	; 0x28
 8038c58:	688b      	ldr	r3, [r1, #8]
 8038c5a:	ba1b      	rev	r3, r3
 8038c5c:	930b      	str	r3, [sp, #44]	; 0x2c
 8038c5e:	68cb      	ldr	r3, [r1, #12]
    uint32_t specific_label[] = {GlobalTemplateLabel, 0UL};
 8038c60:	4937      	ldr	r1, [pc, #220]	; (8038d40 <SecureElementSetKey+0x108>)
 8038c62:	ba1b      	rev	r3, r3
    uint32_t key_ui32[] =
 8038c64:	930c      	str	r3, [sp, #48]	; 0x30
    uint32_t specific_label[] = {GlobalTemplateLabel, 0UL};
 8038c66:	2300      	movs	r3, #0
    CK_ULONG template_true = CK_TRUE;
 8038c68:	2201      	movs	r2, #1
    uint32_t specific_label[] = {GlobalTemplateLabel, 0UL};
 8038c6a:	e9cd 1307 	strd	r1, r3, [sp, #28]
    CK_ATTRIBUTE key_attribute_template[] =
 8038c6e:	a904      	add	r1, sp, #16
 8038c70:	e9cd 1212 	strd	r1, r2, [sp, #72]	; 0x48
 8038c74:	f44f 7180 	mov.w	r1, #256	; 0x100
 8038c78:	9114      	str	r1, [sp, #80]	; 0x50
 8038c7a:	a905      	add	r1, sp, #20
 8038c7c:	e9cd 1215 	strd	r1, r2, [sp, #84]	; 0x54
 8038c80:	2111      	movs	r1, #17
 8038c82:	9117      	str	r1, [sp, #92]	; 0x5c
 8038c84:	a909      	add	r1, sp, #36	; 0x24
 8038c86:	f44f 74b1 	mov.w	r4, #354	; 0x162
 8038c8a:	9118      	str	r1, [sp, #96]	; 0x60
 8038c8c:	2110      	movs	r1, #16
 8038c8e:	e9cd 1419 	strd	r1, r4, [sp, #100]	; 0x64
 8038c92:	ac06      	add	r4, sp, #24
 8038c94:	e9cd 421b 	strd	r4, r2, [sp, #108]	; 0x6c
    CK_ULONG template_true = CK_TRUE;
 8038c98:	9206      	str	r2, [sp, #24]
    CK_ATTRIBUTE key_attribute_template[] =
 8038c9a:	2203      	movs	r2, #3
 8038c9c:	921d      	str	r2, [sp, #116]	; 0x74
 8038c9e:	aa07      	add	r2, sp, #28
 8038ca0:	921e      	str	r2, [sp, #120]	; 0x78
    if ( keyID == MC_KEY_0 )
 8038ca2:	2e80      	cmp	r6, #128	; 0x80
    CK_ATTRIBUTE key_attribute_template[] =
 8038ca4:	f04f 0208 	mov.w	r2, #8
 8038ca8:	9311      	str	r3, [sp, #68]	; 0x44
 8038caa:	921f      	str	r2, [sp, #124]	; 0x7c
    if ( keyID == MC_KEY_0 )
 8038cac:	d118      	bne.n	8038ce0 <SecureElementSetKey+0xa8>
        uint8_t decryptedKey[16] = { 0 };
 8038cae:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
 8038cb2:	e9cd 330f 	strd	r3, r3, [sp, #60]	; 0x3c
        if (SECURE_ELEMENT_SUCCESS != SecureElementAesEncrypt( key, 16, MC_KE_KEY, decryptedKey ))
 8038cb6:	227f      	movs	r2, #127	; 0x7f
 8038cb8:	ab0d      	add	r3, sp, #52	; 0x34
 8038cba:	f7ff ff5b 	bl	8038b74 <SecureElementAesEncrypt>
 8038cbe:	b118      	cbz	r0, 8038cc8 <SecureElementSetKey+0x90>
        return SECURE_ELEMENT_ERROR;
 8038cc0:	2406      	movs	r4, #6
}
 8038cc2:	4620      	mov	r0, r4
 8038cc4:	b020      	add	sp, #128	; 0x80
 8038cc6:	bd70      	pop	{r4, r5, r6, pc}
        key_ui32[0] = decryptedKey[3]  | (decryptedKey[2] << 8)  | (decryptedKey[1] << 16)  | (decryptedKey[0] << 24);
 8038cc8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8038cca:	ba1b      	rev	r3, r3
 8038ccc:	9309      	str	r3, [sp, #36]	; 0x24
        key_ui32[1] = decryptedKey[7]  | (decryptedKey[6] << 8)  | (decryptedKey[5] << 16)  | (decryptedKey[4] << 24);
 8038cce:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8038cd0:	ba1b      	rev	r3, r3
 8038cd2:	930a      	str	r3, [sp, #40]	; 0x28
        key_ui32[2] = decryptedKey[11] | (decryptedKey[10] << 8) | (decryptedKey[9] << 16)  | (decryptedKey[8] << 24);
 8038cd4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8038cd6:	ba1b      	rev	r3, r3
 8038cd8:	930b      	str	r3, [sp, #44]	; 0x2c
        key_ui32[3] = decryptedKey[15] | (decryptedKey[14] << 8) | (decryptedKey[13] << 16) | (decryptedKey[12] << 24);
 8038cda:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8038cdc:	ba1b      	rev	r3, r3
 8038cde:	930c      	str	r3, [sp, #48]	; 0x30
    if (SECURE_ELEMENT_SUCCESS != GetKeyIndexByID(keyID, &key_handle))
 8038ce0:	a90d      	add	r1, sp, #52	; 0x34
 8038ce2:	4630      	mov	r0, r6
 8038ce4:	f7ff fc86 	bl	80385f4 <GetKeyIndexByID>
 8038ce8:	2800      	cmp	r0, #0
 8038cea:	d1e9      	bne.n	8038cc0 <SecureElementSetKey+0x88>
    if (SECURE_ELEMENT_SUCCESS != SecureElementDeleteDynamicKeys(keyID, &specific_label[1]))
 8038cec:	a908      	add	r1, sp, #32
 8038cee:	4630      	mov	r0, r6
 8038cf0:	f7ff fd5c 	bl	80387ac <SecureElementDeleteDynamicKeys>
 8038cf4:	4603      	mov	r3, r0
 8038cf6:	2800      	cmp	r0, #0
 8038cf8:	d1e2      	bne.n	8038cc0 <SecureElementSetKey+0x88>
    rv = C_OpenSession(0, session_flags, NULL, 0, &session);
 8038cfa:	aa03      	add	r2, sp, #12
 8038cfc:	9200      	str	r2, [sp, #0]
 8038cfe:	2104      	movs	r1, #4
 8038d00:	4602      	mov	r2, r0
 8038d02:	f7d0 f82b 	bl	8008d5c <SE_KMS_OpenSession>
    if (rv == CKR_OK)
 8038d06:	4605      	mov	r5, r0
 8038d08:	b9a8      	cbnz	r0, 8038d36 <SecureElementSetKey+0xfe>
        rv = C_CreateObject(session, key_attribute_template, sizeof(key_attribute_template) / sizeof(CK_ATTRIBUTE),
 8038d0a:	9803      	ldr	r0, [sp, #12]
 8038d0c:	ab0d      	add	r3, sp, #52	; 0x34
 8038d0e:	2205      	movs	r2, #5
 8038d10:	a911      	add	r1, sp, #68	; 0x44
 8038d12:	f7d0 f85b 	bl	8008dcc <SE_KMS_CreateObject>
    if (rv == CKR_OK)
 8038d16:	4605      	mov	r5, r0
 8038d18:	b968      	cbnz	r0, 8038d36 <SecureElementSetKey+0xfe>
        retval = SecureElementSetObjHandler(keyID, key_handle);
 8038d1a:	990d      	ldr	r1, [sp, #52]	; 0x34
 8038d1c:	4630      	mov	r0, r6
 8038d1e:	f7ff fdcb 	bl	80388b8 <SecureElementSetObjHandler>
 8038d22:	4604      	mov	r4, r0
    PrintKey(keyID);
 8038d24:	4630      	mov	r0, r6
 8038d26:	f7ff fcd3 	bl	80386d0 <PrintKey>
    (void)C_CloseSession(session);
 8038d2a:	9803      	ldr	r0, [sp, #12]
 8038d2c:	f7d0 f836 	bl	8008d9c <SE_KMS_CloseSession>
    if (rv != CKR_OK)
 8038d30:	2d00      	cmp	r5, #0
 8038d32:	d0c6      	beq.n	8038cc2 <SecureElementSetKey+0x8a>
 8038d34:	e7c4      	b.n	8038cc0 <SecureElementSetKey+0x88>
    SecureElementStatus_t retval = SECURE_ELEMENT_ERROR;
 8038d36:	2406      	movs	r4, #6
 8038d38:	e7f4      	b.n	8038d24 <SecureElementSetKey+0xec>
        return SECURE_ELEMENT_ERROR_NPE;
 8038d3a:	2402      	movs	r4, #2
 8038d3c:	e7c1      	b.n	8038cc2 <SecureElementSetKey+0x8a>
 8038d3e:	bf00      	nop
 8038d40:	444e524c 	.word	0x444e524c

08038d44 <SecureElementDeriveAndStoreKey>:

SecureElementStatus_t SecureElementDeriveAndStoreKey( uint8_t* input, KeyIdentifier_t rootKeyID,
                                                      KeyIdentifier_t targetKeyID )
{
 8038d44:	b570      	push	{r4, r5, r6, lr}
 8038d46:	460b      	mov	r3, r1
 8038d48:	b08e      	sub	sp, #56	; 0x38
 8038d4a:	4616      	mov	r6, r2
    if( input == NULL )
 8038d4c:	2800      	cmp	r0, #0
 8038d4e:	d049      	beq.n	8038de4 <SecureElementDeriveAndStoreKey+0xa0>
    }

    SecureElementStatus_t retval  = SECURE_ELEMENT_ERROR;

    // In case of MC_KE_KEY, only McRootKey can be used as root key
    if( targetKeyID == MC_KE_KEY )
 8038d50:	2a7f      	cmp	r2, #127	; 0x7f
 8038d52:	d101      	bne.n	8038d58 <SecureElementDeriveAndStoreKey+0x14>
    {
        if( rootKeyID != MC_ROOT_KEY )
 8038d54:	2904      	cmp	r1, #4
 8038d56:	d147      	bne.n	8038de8 <SecureElementDeriveAndStoreKey+0xa4>
#else /* LORAWAN_KMS == 1 */
    CK_RV rv;
    CK_SESSION_HANDLE session;
    CK_FLAGS session_flags = CKF_SERIAL_SESSION;    /* Read ONLY session */
    /* Key derivation */
    CK_MECHANISM            mech = {CKM_AES_ECB_ENCRYPT_DATA, input, SE_KEY_SIZE};
 8038d58:	f241 1204 	movw	r2, #4356	; 0x1104
 8038d5c:	e9cd 2008 	strd	r2, r0, [sp, #32]
    CK_OBJECT_HANDLE  derived_object_handle;
    CK_OBJECT_HANDLE    rootkey_object_handle;
    uint32_t specific_label[] = {GlobalTemplateLabel, 0UL};
 8038d60:	4822      	ldr	r0, [pc, #136]	; (8038dec <SecureElementDeriveAndStoreKey+0xa8>)
    CK_MECHANISM            mech = {CKM_AES_ECB_ENCRYPT_DATA, input, SE_KEY_SIZE};
 8038d62:	2210      	movs	r2, #16
 8038d64:	920a      	str	r2, [sp, #40]	; 0x28
    uint32_t specific_label[] = {GlobalTemplateLabel, 0UL};
 8038d66:	2200      	movs	r2, #0
 8038d68:	e9cd 0206 	strd	r0, r2, [sp, #24]
    CK_ATTRIBUTE DeriveKey_template = {CKA_LABEL, (CK_VOID_PTR)specific_label, sizeof(specific_label)};
 8038d6c:	2203      	movs	r2, #3
 8038d6e:	920b      	str	r2, [sp, #44]	; 0x2c
 8038d70:	aa06      	add	r2, sp, #24
 8038d72:	920c      	str	r2, [sp, #48]	; 0x30

    /* Derive key */
    if (SECURE_ELEMENT_SUCCESS != GetKeyIndexByID(rootKeyID, &rootkey_object_handle))
 8038d74:	a905      	add	r1, sp, #20
    CK_ATTRIBUTE DeriveKey_template = {CKA_LABEL, (CK_VOID_PTR)specific_label, sizeof(specific_label)};
 8038d76:	2208      	movs	r2, #8
    if (SECURE_ELEMENT_SUCCESS != GetKeyIndexByID(rootKeyID, &rootkey_object_handle))
 8038d78:	4618      	mov	r0, r3
    CK_ATTRIBUTE DeriveKey_template = {CKA_LABEL, (CK_VOID_PTR)specific_label, sizeof(specific_label)};
 8038d7a:	920d      	str	r2, [sp, #52]	; 0x34
    if (SECURE_ELEMENT_SUCCESS != GetKeyIndexByID(rootKeyID, &rootkey_object_handle))
 8038d7c:	f7ff fc3a 	bl	80385f4 <GetKeyIndexByID>
 8038d80:	bb50      	cbnz	r0, 8038dd8 <SecureElementDeriveAndStoreKey+0x94>
    {
        return SECURE_ELEMENT_ERROR;
    }

    if (SECURE_ELEMENT_SUCCESS != GetKeyIndexByID(targetKeyID, &derived_object_handle))
 8038d82:	ac04      	add	r4, sp, #16
 8038d84:	4621      	mov	r1, r4
 8038d86:	4630      	mov	r0, r6
 8038d88:	f7ff fc34 	bl	80385f4 <GetKeyIndexByID>
 8038d8c:	bb20      	cbnz	r0, 8038dd8 <SecureElementDeriveAndStoreKey+0x94>
    {
        return SECURE_ELEMENT_ERROR;
    }

    if (SECURE_ELEMENT_SUCCESS != SecureElementDeleteDynamicKeys(targetKeyID, &specific_label[1]))
 8038d8e:	a907      	add	r1, sp, #28
 8038d90:	4630      	mov	r0, r6
 8038d92:	f7ff fd0b 	bl	80387ac <SecureElementDeleteDynamicKeys>
 8038d96:	4603      	mov	r3, r0
 8038d98:	b9f0      	cbnz	r0, 8038dd8 <SecureElementDeriveAndStoreKey+0x94>
    {
        return SECURE_ELEMENT_ERROR;
    }

    /* Open session with KMS */
    rv = C_OpenSession(0,    session_flags, NULL, 0, &session);
 8038d9a:	aa03      	add	r2, sp, #12
 8038d9c:	9200      	str	r2, [sp, #0]
 8038d9e:	2104      	movs	r1, #4
 8038da0:	4602      	mov	r2, r0
 8038da2:	f7cf ffdb 	bl	8008d5c <SE_KMS_OpenSession>

    /* Derive key with pass phrase */
    if (rv == CKR_OK)
 8038da6:	4605      	mov	r5, r0
 8038da8:	b9d0      	cbnz	r0, 8038de0 <SecureElementDeriveAndStoreKey+0x9c>
    {
        rv = C_DeriveKey(session, &(mech), rootkey_object_handle,
 8038daa:	2301      	movs	r3, #1
 8038dac:	9300      	str	r3, [sp, #0]
 8038dae:	9a05      	ldr	r2, [sp, #20]
 8038db0:	9803      	ldr	r0, [sp, #12]
 8038db2:	9401      	str	r4, [sp, #4]
 8038db4:	ab0b      	add	r3, sp, #44	; 0x2c
 8038db6:	a908      	add	r1, sp, #32
 8038db8:	f7d0 faa8 	bl	800930c <SE_KMS_DeriveKey>
                         &DeriveKey_template, sizeof(DeriveKey_template) / sizeof(CK_ATTRIBUTE), &derived_object_handle);
    }

    if (rv == CKR_OK)
 8038dbc:	4605      	mov	r5, r0
 8038dbe:	b978      	cbnz	r0, 8038de0 <SecureElementDeriveAndStoreKey+0x9c>
    {
        /* Store Derived Index in table */
        retval = SecureElementSetObjHandler(targetKeyID, derived_object_handle);
 8038dc0:	9904      	ldr	r1, [sp, #16]
 8038dc2:	4630      	mov	r0, r6
 8038dc4:	f7ff fd78 	bl	80388b8 <SecureElementSetObjHandler>
 8038dc8:	4604      	mov	r4, r0
    }

    PrintKey(targetKeyID);
 8038dca:	4630      	mov	r0, r6
 8038dcc:	f7ff fc80 	bl	80386d0 <PrintKey>

    /* Close session with KMS */
    (void)C_CloseSession(session);
 8038dd0:	9803      	ldr	r0, [sp, #12]
 8038dd2:	f7cf ffe3 	bl	8008d9c <SE_KMS_CloseSession>

    if (rv != CKR_OK)
 8038dd6:	b105      	cbz	r5, 8038dda <SecureElementDeriveAndStoreKey+0x96>
    {
        retval = SECURE_ELEMENT_ERROR;
 8038dd8:	2406      	movs	r4, #6
    }
    return retval;
#endif /* LORAWAN_KMS */
}
 8038dda:	4620      	mov	r0, r4
 8038ddc:	b00e      	add	sp, #56	; 0x38
 8038dde:	bd70      	pop	{r4, r5, r6, pc}
    SecureElementStatus_t retval  = SECURE_ELEMENT_ERROR;
 8038de0:	2406      	movs	r4, #6
 8038de2:	e7f2      	b.n	8038dca <SecureElementDeriveAndStoreKey+0x86>
        return SECURE_ELEMENT_ERROR_NPE;
 8038de4:	2402      	movs	r4, #2
 8038de6:	e7f8      	b.n	8038dda <SecureElementDeriveAndStoreKey+0x96>
            return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 8038de8:	2403      	movs	r4, #3
 8038dea:	e7f6      	b.n	8038dda <SecureElementDeriveAndStoreKey+0x96>
 8038dec:	444e524c 	.word	0x444e524c

08038df0 <SecureElementProcessJoinAccept>:

SecureElementStatus_t SecureElementProcessJoinAccept( JoinReqIdentifier_t joinReqType, uint8_t* joinEui,
                                                      uint16_t devNonce, uint8_t* encJoinAccept,
                                                      uint8_t encJoinAcceptSize, uint8_t* decJoinAccept,
                                                      uint8_t* versionMinor )
{
 8038df0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if( ( encJoinAccept == NULL ) || ( decJoinAccept == NULL ) || ( versionMinor == NULL ) )
 8038df4:	461f      	mov	r7, r3
{
 8038df6:	e9dd 5807 	ldrd	r5, r8, [sp, #28]
 8038dfa:	f89d 4018 	ldrb.w	r4, [sp, #24]
    if( ( encJoinAccept == NULL ) || ( decJoinAccept == NULL ) || ( versionMinor == NULL ) )
 8038dfe:	b393      	cbz	r3, 8038e66 <SecureElementProcessJoinAccept+0x76>
 8038e00:	b38d      	cbz	r5, 8038e66 <SecureElementProcessJoinAccept+0x76>
 8038e02:	f1b8 0f00 	cmp.w	r8, #0
 8038e06:	d02e      	beq.n	8038e66 <SecureElementProcessJoinAccept+0x76>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

    // Check that frame size isn't bigger than a JoinAccept with CFList size
    if( encJoinAcceptSize > LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE )
 8038e08:	2c21      	cmp	r4, #33	; 0x21
 8038e0a:	d82e      	bhi.n	8038e6a <SecureElementProcessJoinAccept+0x7a>
    {
        encKeyID = J_S_ENC_KEY;
    }
#endif /* USE_LRWAN_1_1_X_CRYPTO == 1 */

    memcpy1( decJoinAccept, encJoinAccept, encJoinAcceptSize );
 8038e0c:	b2a6      	uxth	r6, r4
 8038e0e:	4619      	mov	r1, r3
 8038e10:	4632      	mov	r2, r6
 8038e12:	4628      	mov	r0, r5
 8038e14:	f000 f88a 	bl	8038f2c <memcpy1>

    // Decrypt JoinAccept, skip MHDR
    if( SecureElementAesEncrypt( encJoinAccept + LORAMAC_MHDR_FIELD_SIZE, encJoinAcceptSize - LORAMAC_MHDR_FIELD_SIZE,
 8038e18:	1e71      	subs	r1, r6, #1
 8038e1a:	2201      	movs	r2, #1
 8038e1c:	1c6b      	adds	r3, r5, #1
 8038e1e:	b289      	uxth	r1, r1
 8038e20:	18b8      	adds	r0, r7, r2
 8038e22:	f7ff fea7 	bl	8038b74 <SecureElementAesEncrypt>
 8038e26:	bb10      	cbnz	r0, 8038e6e <SecureElementProcessJoinAccept+0x7e>
                                 encKeyID, decJoinAccept + LORAMAC_MHDR_FIELD_SIZE ) != SECURE_ELEMENT_SUCCESS )
    {
        return SECURE_ELEMENT_FAIL_ENCRYPT;
    }

    *versionMinor = ( ( decJoinAccept[11] & 0x80 ) == 0x80 ) ? 1 : 0;
 8038e28:	7aeb      	ldrb	r3, [r5, #11]
 8038e2a:	09db      	lsrs	r3, r3, #7
 8038e2c:	f888 3000 	strb.w	r3, [r8]
    //  - Header buffer to be used for MIC computation
    //        - LoRaWAN 1.0.x : micHeader = [MHDR(1)]
    //        - LoRaWAN 1.1.x : micHeader = [JoinReqType(1), JoinEUI(8), DevNonce(2), MHDR(1)]

    // Verify mic
    if( *versionMinor == 0 )
 8038e30:	b9fb      	cbnz	r3, 8038e72 <SecureElementProcessJoinAccept+0x82>
    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 2] << 16 );
 8038e32:	192b      	adds	r3, r5, r4
    {
        // For LoRaWAN 1.0.x
        //   cmac = aes128_cmac(NwkKey, MHDR |  JoinNonce | NetID | DevAddr | DLSettings | RxDelay | CFList |
        //   CFListType)
        if( SecureElementVerifyAesCmac( decJoinAccept, ( encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE ), mic, NWK_KEY ) !=
 8038e34:	1f31      	subs	r1, r6, #4
    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 3] << 24 );
 8038e36:	f813 0c01 	ldrb.w	r0, [r3, #-1]
    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 2] << 16 );
 8038e3a:	f813 2c02 	ldrb.w	r2, [r3, #-2]
    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 3] << 24 );
 8038e3e:	0600      	lsls	r0, r0, #24
 8038e40:	ea40 4002 	orr.w	r0, r0, r2, lsl #16
    mic = ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE] << 0 );
 8038e44:	f813 2c04 	ldrb.w	r2, [r3, #-4]
 8038e48:	4310      	orrs	r0, r2
    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 1] << 8 );
 8038e4a:	f813 2c03 	ldrb.w	r2, [r3, #-3]
        if( SecureElementVerifyAesCmac( decJoinAccept, ( encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE ), mic, NWK_KEY ) !=
 8038e4e:	b289      	uxth	r1, r1
 8038e50:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
 8038e54:	2301      	movs	r3, #1
 8038e56:	4628      	mov	r0, r5
 8038e58:	f7ff fe4e 	bl	8038af8 <SecureElementVerifyAesCmac>
        return SECURE_ELEMENT_ERROR_NPE;
 8038e5c:	3800      	subs	r0, #0
 8038e5e:	bf18      	it	ne
 8038e60:	2001      	movne	r0, #1
    {
        return SECURE_ELEMENT_ERROR_INVALID_LORAWAM_SPEC_VERSION;
    }

    return SECURE_ELEMENT_SUCCESS;
}
 8038e62:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 8038e66:	2002      	movs	r0, #2
 8038e68:	e7fb      	b.n	8038e62 <SecureElementProcessJoinAccept+0x72>
        return SECURE_ELEMENT_ERROR_BUF_SIZE;
 8038e6a:	2005      	movs	r0, #5
 8038e6c:	e7f9      	b.n	8038e62 <SecureElementProcessJoinAccept+0x72>
        return SECURE_ELEMENT_FAIL_ENCRYPT;
 8038e6e:	2007      	movs	r0, #7
 8038e70:	e7f7      	b.n	8038e62 <SecureElementProcessJoinAccept+0x72>
        return SECURE_ELEMENT_ERROR_INVALID_LORAWAM_SPEC_VERSION;
 8038e72:	2004      	movs	r0, #4
 8038e74:	e7f5      	b.n	8038e62 <SecureElementProcessJoinAccept+0x72>
	...

08038e78 <SecureElementRandomNumber>:

SecureElementStatus_t SecureElementRandomNumber( uint32_t* randomNum )
{
 8038e78:	b510      	push	{r4, lr}
    if( randomNum == NULL )
 8038e7a:	4604      	mov	r4, r0
 8038e7c:	b128      	cbz	r0, 8038e8a <SecureElementRandomNumber+0x12>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }
    *randomNum = Radio.Random();
 8038e7e:	4b04      	ldr	r3, [pc, #16]	; (8038e90 <SecureElementRandomNumber+0x18>)
 8038e80:	695b      	ldr	r3, [r3, #20]
 8038e82:	4798      	blx	r3
 8038e84:	6020      	str	r0, [r4, #0]
    return SECURE_ELEMENT_SUCCESS;
 8038e86:	2000      	movs	r0, #0
}
 8038e88:	bd10      	pop	{r4, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 8038e8a:	2002      	movs	r0, #2
 8038e8c:	e7fc      	b.n	8038e88 <SecureElementRandomNumber+0x10>
 8038e8e:	bf00      	nop
 8038e90:	0803bc30 	.word	0x0803bc30

08038e94 <SecureElementSetDevEui>:

SecureElementStatus_t SecureElementSetDevEui( uint8_t* devEui )
{
 8038e94:	b508      	push	{r3, lr}
    if( devEui == NULL )
 8038e96:	4601      	mov	r1, r0
 8038e98:	b130      	cbz	r0, 8038ea8 <SecureElementSetDevEui+0x14>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }
    memcpy1( SeNvm->DevEui, devEui, SE_EUI_SIZE );
 8038e9a:	4b04      	ldr	r3, [pc, #16]	; (8038eac <SecureElementSetDevEui+0x18>)
 8038e9c:	2208      	movs	r2, #8
 8038e9e:	6818      	ldr	r0, [r3, #0]
 8038ea0:	f000 f844 	bl	8038f2c <memcpy1>
    return SECURE_ELEMENT_SUCCESS;
 8038ea4:	2000      	movs	r0, #0
}
 8038ea6:	bd08      	pop	{r3, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 8038ea8:	2002      	movs	r0, #2
 8038eaa:	e7fc      	b.n	8038ea6 <SecureElementSetDevEui+0x12>
 8038eac:	20005738 	.word	0x20005738

08038eb0 <SecureElementGetDevEui>:

uint8_t* SecureElementGetDevEui( void )
{
    return SeNvm->DevEui;
}
 8038eb0:	4b01      	ldr	r3, [pc, #4]	; (8038eb8 <SecureElementGetDevEui+0x8>)
 8038eb2:	6818      	ldr	r0, [r3, #0]
 8038eb4:	4770      	bx	lr
 8038eb6:	bf00      	nop
 8038eb8:	20005738 	.word	0x20005738

08038ebc <SecureElementSetJoinEui>:

SecureElementStatus_t SecureElementSetJoinEui( uint8_t* joinEui )
{
 8038ebc:	b508      	push	{r3, lr}
    if( joinEui == NULL )
 8038ebe:	4601      	mov	r1, r0
 8038ec0:	b138      	cbz	r0, 8038ed2 <SecureElementSetJoinEui+0x16>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }
    memcpy1( SeNvm->JoinEui, joinEui, SE_EUI_SIZE );
 8038ec2:	4b05      	ldr	r3, [pc, #20]	; (8038ed8 <SecureElementSetJoinEui+0x1c>)
 8038ec4:	6818      	ldr	r0, [r3, #0]
 8038ec6:	2208      	movs	r2, #8
 8038ec8:	4410      	add	r0, r2
 8038eca:	f000 f82f 	bl	8038f2c <memcpy1>
    return SECURE_ELEMENT_SUCCESS;
 8038ece:	2000      	movs	r0, #0
}
 8038ed0:	bd08      	pop	{r3, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 8038ed2:	2002      	movs	r0, #2
 8038ed4:	e7fc      	b.n	8038ed0 <SecureElementSetJoinEui+0x14>
 8038ed6:	bf00      	nop
 8038ed8:	20005738 	.word	0x20005738

08038edc <SecureElementGetJoinEui>:

uint8_t* SecureElementGetJoinEui( void )
{
    return SeNvm->JoinEui;
 8038edc:	4b01      	ldr	r3, [pc, #4]	; (8038ee4 <SecureElementGetJoinEui+0x8>)
 8038ede:	6818      	ldr	r0, [r3, #0]
}
 8038ee0:	3008      	adds	r0, #8
 8038ee2:	4770      	bx	lr
 8038ee4:	20005738 	.word	0x20005738

08038ee8 <srand1>:
    return ( ( next = next * 1103515245L + 12345L ) % RAND_LOCAL_MAX );
}

void srand1( uint32_t seed )
{
    next = seed;
 8038ee8:	4b01      	ldr	r3, [pc, #4]	; (8038ef0 <srand1+0x8>)
 8038eea:	6018      	str	r0, [r3, #0]
}
 8038eec:	4770      	bx	lr
 8038eee:	bf00      	nop
 8038ef0:	2000359c 	.word	0x2000359c

08038ef4 <randr>:
    return ( ( next = next * 1103515245L + 12345L ) % RAND_LOCAL_MAX );
 8038ef4:	4a0b      	ldr	r2, [pc, #44]	; (8038f24 <randr+0x30>)
// Standard random functions redefinition end

int32_t randr( int32_t min, int32_t max )
{
 8038ef6:	b530      	push	{r4, r5, lr}
    return ( ( next = next * 1103515245L + 12345L ) % RAND_LOCAL_MAX );
 8038ef8:	6813      	ldr	r3, [r2, #0]
 8038efa:	4d0b      	ldr	r5, [pc, #44]	; (8038f28 <randr+0x34>)
 8038efc:	f243 0439 	movw	r4, #12345	; 0x3039
 8038f00:	fb05 4303 	mla	r3, r5, r3, r4
 8038f04:	6013      	str	r3, [r2, #0]
    return ( int32_t )rand1( ) % ( max - min + 1 ) + min;
 8038f06:	1a09      	subs	r1, r1, r0
    return ( ( next = next * 1103515245L + 12345L ) % RAND_LOCAL_MAX );
 8038f08:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
 8038f0c:	fbb3 f2f2 	udiv	r2, r3, r2
 8038f10:	ebc2 72c2 	rsb	r2, r2, r2, lsl #31
    return ( int32_t )rand1( ) % ( max - min + 1 ) + min;
 8038f14:	3101      	adds	r1, #1
    return ( ( next = next * 1103515245L + 12345L ) % RAND_LOCAL_MAX );
 8038f16:	1a9b      	subs	r3, r3, r2
    return ( int32_t )rand1( ) % ( max - min + 1 ) + min;
 8038f18:	fb93 f2f1 	sdiv	r2, r3, r1
 8038f1c:	fb01 3312 	mls	r3, r1, r2, r3
}
 8038f20:	4418      	add	r0, r3
 8038f22:	bd30      	pop	{r4, r5, pc}
 8038f24:	2000359c 	.word	0x2000359c
 8038f28:	41c64e6d 	.word	0x41c64e6d

08038f2c <memcpy1>:

void memcpy1( uint8_t *dst, const uint8_t *src, uint16_t size )
{
    while( size-- )
 8038f2c:	3801      	subs	r0, #1
 8038f2e:	440a      	add	r2, r1
 8038f30:	4291      	cmp	r1, r2
 8038f32:	d100      	bne.n	8038f36 <memcpy1+0xa>
    {
        *dst++ = *src++;
    }
}
 8038f34:	4770      	bx	lr
        *dst++ = *src++;
 8038f36:	f811 3b01 	ldrb.w	r3, [r1], #1
 8038f3a:	f800 3f01 	strb.w	r3, [r0, #1]!
 8038f3e:	e7f7      	b.n	8038f30 <memcpy1+0x4>

08038f40 <memcpyr>:

void memcpyr( uint8_t *dst, const uint8_t *src, uint16_t size )
{
    dst = dst + ( size - 1 );
    while( size-- )
 8038f40:	4410      	add	r0, r2
 8038f42:	440a      	add	r2, r1
 8038f44:	4291      	cmp	r1, r2
 8038f46:	d100      	bne.n	8038f4a <memcpyr+0xa>
    {
        *dst-- = *src++;
    }
}
 8038f48:	4770      	bx	lr
        *dst-- = *src++;
 8038f4a:	f811 3b01 	ldrb.w	r3, [r1], #1
 8038f4e:	f800 3d01 	strb.w	r3, [r0, #-1]!
 8038f52:	e7f7      	b.n	8038f44 <memcpyr+0x4>

08038f54 <memset1>:

void memset1( uint8_t *dst, uint8_t value, uint16_t size )
{
    while( size-- )
 8038f54:	4402      	add	r2, r0
 8038f56:	4290      	cmp	r0, r2
 8038f58:	d100      	bne.n	8038f5c <memset1+0x8>
    {
        *dst++ = value;
    }
}
 8038f5a:	4770      	bx	lr
        *dst++ = value;
 8038f5c:	f800 1b01 	strb.w	r1, [r0], #1
 8038f60:	e7f9      	b.n	8038f56 <memset1+0x2>
	...

08038f64 <Crc32>:
        return '?';
    }
}

uint32_t Crc32( uint8_t *buffer, uint16_t length )
{
 8038f64:	b530      	push	{r4, r5, lr}
    const uint32_t reversedPolynom = 0xEDB88320;

    // CRC initial value
    uint32_t crc = 0xFFFFFFFF;

    if( buffer == NULL )
 8038f66:	b130      	cbz	r0, 8038f76 <Crc32+0x12>
    for( uint16_t i = 0; i < length; ++i )
    {
        crc ^= ( uint32_t )buffer[i];
        for( uint16_t i = 0; i < 8; i++ )
        {
            crc = ( crc >> 1 ) ^ ( reversedPolynom & ~( ( crc & 0x01 ) - 1 ) );
 8038f68:	4d0a      	ldr	r5, [pc, #40]	; (8038f94 <Crc32+0x30>)
 8038f6a:	4401      	add	r1, r0
    uint32_t crc = 0xFFFFFFFF;
 8038f6c:	f04f 33ff 	mov.w	r3, #4294967295
    for( uint16_t i = 0; i < length; ++i )
 8038f70:	4281      	cmp	r1, r0
 8038f72:	d101      	bne.n	8038f78 <Crc32+0x14>
        }
    }

    return ~crc;
 8038f74:	43d8      	mvns	r0, r3
}
 8038f76:	bd30      	pop	{r4, r5, pc}
        crc ^= ( uint32_t )buffer[i];
 8038f78:	f810 2b01 	ldrb.w	r2, [r0], #1
 8038f7c:	4053      	eors	r3, r2
 8038f7e:	2208      	movs	r2, #8
            crc = ( crc >> 1 ) ^ ( reversedPolynom & ~( ( crc & 0x01 ) - 1 ) );
 8038f80:	f343 0400 	sbfx	r4, r3, #0, #1
 8038f84:	3a01      	subs	r2, #1
 8038f86:	402c      	ands	r4, r5
 8038f88:	b292      	uxth	r2, r2
 8038f8a:	ea84 0353 	eor.w	r3, r4, r3, lsr #1
        for( uint16_t i = 0; i < 8; i++ )
 8038f8e:	2a00      	cmp	r2, #0
 8038f90:	d1f6      	bne.n	8038f80 <Crc32+0x1c>
 8038f92:	e7ed      	b.n	8038f70 <Crc32+0xc>
 8038f94:	edb88320 	.word	0xedb88320

08038f98 <RadioCheckRfFrequency>:
}

static bool RadioCheckRfFrequency( uint32_t frequency )
{
    return true;
}
 8038f98:	2001      	movs	r0, #1
 8038f9a:	4770      	bx	lr

08038f9c <RadioOnTxTimeoutIrq>:
{
    /* ST_WORKAROUND_BEGIN: Reset DBG pin */
    DBG_GPIO_RADIO_TX(RST);
    /* ST_WORKAROUND_END */

    if( ( RadioEvents != NULL ) && ( RadioEvents->TxTimeout != NULL ) )
 8038f9c:	4b03      	ldr	r3, [pc, #12]	; (8038fac <RadioOnTxTimeoutIrq+0x10>)
 8038f9e:	681b      	ldr	r3, [r3, #0]
 8038fa0:	b113      	cbz	r3, 8038fa8 <RadioOnTxTimeoutIrq+0xc>
 8038fa2:	685b      	ldr	r3, [r3, #4]
 8038fa4:	b103      	cbz	r3, 8038fa8 <RadioOnTxTimeoutIrq+0xc>
    {
        RadioEvents->TxTimeout( );
 8038fa6:	4718      	bx	r3
}
 8038fa8:	4770      	bx	lr
 8038faa:	bf00      	nop
 8038fac:	2000597c 	.word	0x2000597c

08038fb0 <RadioOnRxTimeoutIrq>:
{
    /* ST_WORKAROUND_BEGIN: Reset DBG pin */
    DBG_GPIO_RADIO_RX(RST);
    /* ST_WORKAROUND_END */

    if( ( RadioEvents != NULL ) && ( RadioEvents->RxTimeout != NULL ) )
 8038fb0:	4b03      	ldr	r3, [pc, #12]	; (8038fc0 <RadioOnRxTimeoutIrq+0x10>)
 8038fb2:	681b      	ldr	r3, [r3, #0]
 8038fb4:	b113      	cbz	r3, 8038fbc <RadioOnRxTimeoutIrq+0xc>
 8038fb6:	68db      	ldr	r3, [r3, #12]
 8038fb8:	b103      	cbz	r3, 8038fbc <RadioOnRxTimeoutIrq+0xc>
    {
        RadioEvents->RxTimeout( );
 8038fba:	4718      	bx	r3
}
 8038fbc:	4770      	bx	lr
 8038fbe:	bf00      	nop
 8038fc0:	2000597c 	.word	0x2000597c

08038fc4 <RadioRead>:
    return SUBGRF_ReadRegister(addr);
 8038fc4:	f001 baf4 	b.w	803a5b0 <SUBGRF_ReadRegister>

08038fc8 <RadioWrite>:
    SUBGRF_WriteRegister(addr, data );
 8038fc8:	f001 ba2c 	b.w	803a424 <SUBGRF_WriteRegister>

08038fcc <RadioTxCw>:
    SUBGRF_SetTxInfinitePreamble( );
    SUBGRF_SetTx( 0x0fffff );
}

static void RadioTxCw( int8_t power )
{
 8038fcc:	b508      	push	{r3, lr}
    uint8_t paselect = SUBGRF_SetRfTxPower( power );
 8038fce:	f001 fd1c 	bl	803aa0a <SUBGRF_SetRfTxPower>
    SUBGRF_SetSwitch( paselect, RFSWITCH_TX );
 8038fd2:	2101      	movs	r1, #1
 8038fd4:	f001 fd03 	bl	803a9de <SUBGRF_SetSwitch>
    SUBGRF_SetTxContinuousWave( );
}
 8038fd8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    SUBGRF_SetTxContinuousWave( );
 8038fdc:	f001 b90c 	b.w	803a1f8 <SUBGRF_SetTxContinuousWave>

08038fe0 <RadioSetRxDutyCycle>:
{
 8038fe0:	b538      	push	{r3, r4, r5, lr}
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_RX);
 8038fe2:	4b07      	ldr	r3, [pc, #28]	; (8039000 <RadioSetRxDutyCycle+0x20>)
{
 8038fe4:	4604      	mov	r4, r0
 8038fe6:	460d      	mov	r5, r1
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_RX);
 8038fe8:	f893 0056 	ldrb.w	r0, [r3, #86]	; 0x56
 8038fec:	2100      	movs	r1, #0
 8038fee:	f001 fcf6 	bl	803a9de <SUBGRF_SetSwitch>
    SUBGRF_SetRxDutyCycle( rxTime, sleepTime );
 8038ff2:	4629      	mov	r1, r5
 8038ff4:	4620      	mov	r0, r4
}
 8038ff6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    SUBGRF_SetRxDutyCycle( rxTime, sleepTime );
 8038ffa:	f001 b8d5 	b.w	803a1a8 <SUBGRF_SetRxDutyCycle>
 8038ffe:	bf00      	nop
 8039000:	20006324 	.word	0x20006324

08039004 <RadioStandby>:
    SUBGRF_SetStandby( STDBY_RC );
 8039004:	2000      	movs	r0, #0
 8039006:	f001 b88d 	b.w	803a124 <SUBGRF_SetStandby>
	...

0803900c <RadioGetStatus>:
{
 803900c:	b508      	push	{r3, lr}
    switch( SUBGRF_GetOperatingMode( ) )
 803900e:	f001 f883 	bl	803a118 <SUBGRF_GetOperatingMode>
 8039012:	3804      	subs	r0, #4
 8039014:	b2c0      	uxtb	r0, r0
 8039016:	2803      	cmp	r0, #3
 8039018:	bf96      	itet	ls
 803901a:	4b02      	ldrls	r3, [pc, #8]	; (8039024 <RadioGetStatus+0x18>)
 803901c:	2000      	movhi	r0, #0
 803901e:	5c18      	ldrbls	r0, [r3, r0]
}
 8039020:	bd08      	pop	{r3, pc}
 8039022:	bf00      	nop
 8039024:	0803bbec 	.word	0x0803bbec

08039028 <RadioIrqProcess>:
{
 8039028:	b573      	push	{r0, r1, r4, r5, r6, lr}
    switch ( SubgRf.RadioIrq )
 803902a:	4e84      	ldr	r6, [pc, #528]	; (803923c <RadioIrqProcess+0x214>)
 803902c:	f8b6 3054 	ldrh.w	r3, [r6, #84]	; 0x54
    uint8_t size = 0;
 8039030:	2400      	movs	r4, #0
    switch ( SubgRf.RadioIrq )
 8039032:	2b20      	cmp	r3, #32
    uint8_t size = 0;
 8039034:	f88d 4003 	strb.w	r4, [sp, #3]
    int32_t cfo = 0;
 8039038:	9401      	str	r4, [sp, #4]
    switch ( SubgRf.RadioIrq )
 803903a:	4635      	mov	r5, r6
 803903c:	f000 80d9 	beq.w	80391f2 <RadioIrqProcess+0x1ca>
 8039040:	d810      	bhi.n	8039064 <RadioIrqProcess+0x3c>
 8039042:	2b08      	cmp	r3, #8
 8039044:	d809      	bhi.n	803905a <RadioIrqProcess+0x32>
 8039046:	b15b      	cbz	r3, 8039060 <RadioIrqProcess+0x38>
 8039048:	3b01      	subs	r3, #1
 803904a:	2b07      	cmp	r3, #7
 803904c:	d808      	bhi.n	8039060 <RadioIrqProcess+0x38>
 803904e:	e8df f003 	tbb	[pc, r3]
 8039052:	4e39      	.short	0x4e39
 8039054:	0707b907 	.word	0x0707b907
 8039058:	c007      	.short	0xc007
 803905a:	2b10      	cmp	r3, #16
 803905c:	f000 80c7 	beq.w	80391ee <RadioIrqProcess+0x1c6>
}
 8039060:	b002      	add	sp, #8
 8039062:	bd70      	pop	{r4, r5, r6, pc}
    switch ( SubgRf.RadioIrq )
 8039064:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8039068:	f000 808c 	beq.w	8039184 <RadioIrqProcess+0x15c>
 803906c:	d811      	bhi.n	8039092 <RadioIrqProcess+0x6a>
 803906e:	2b40      	cmp	r3, #64	; 0x40
 8039070:	f000 80d2 	beq.w	8039218 <RadioIrqProcess+0x1f0>
 8039074:	2b80      	cmp	r3, #128	; 0x80
 8039076:	d1f3      	bne.n	8039060 <RadioIrqProcess+0x38>
        SUBGRF_SetStandby( STDBY_RC );
 8039078:	4620      	mov	r0, r4
 803907a:	f001 f853 	bl	803a124 <SUBGRF_SetStandby>
        if( ( RadioEvents != NULL ) && ( RadioEvents->CadDone != NULL ) )
 803907e:	4b70      	ldr	r3, [pc, #448]	; (8039240 <RadioIrqProcess+0x218>)
 8039080:	681b      	ldr	r3, [r3, #0]
 8039082:	2b00      	cmp	r3, #0
 8039084:	d0ec      	beq.n	8039060 <RadioIrqProcess+0x38>
 8039086:	699b      	ldr	r3, [r3, #24]
 8039088:	2b00      	cmp	r3, #0
 803908a:	d0e9      	beq.n	8039060 <RadioIrqProcess+0x38>
            RadioEvents->CadDone( false );
 803908c:	4620      	mov	r0, r4
            RadioEvents->CadDone( true );
 803908e:	4798      	blx	r3
 8039090:	e7e6      	b.n	8039060 <RadioIrqProcess+0x38>
    switch ( SubgRf.RadioIrq )
 8039092:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8039096:	d1e3      	bne.n	8039060 <RadioIrqProcess+0x38>
        MW_LOG( TS_ON, VLEVEL_M,  "IRQ_RX_TX_TIMEOUT\r\n" );
 8039098:	4b6a      	ldr	r3, [pc, #424]	; (8039244 <RadioIrqProcess+0x21c>)
 803909a:	2201      	movs	r2, #1
 803909c:	4621      	mov	r1, r4
 803909e:	2002      	movs	r0, #2
 80390a0:	f001 fe2a 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
        if( SUBGRF_GetOperatingMode( ) == MODE_TX )
 80390a4:	f001 f838 	bl	803a118 <SUBGRF_GetOperatingMode>
 80390a8:	2804      	cmp	r0, #4
 80390aa:	d179      	bne.n	80391a0 <RadioIrqProcess+0x178>
            TimerStop( &TxTimeoutTimer );
 80390ac:	4866      	ldr	r0, [pc, #408]	; (8039248 <RadioIrqProcess+0x220>)
 80390ae:	f002 f945 	bl	803b33c <UTIL_TIMER_Stop>
            SUBGRF_SetStandby( STDBY_RC );
 80390b2:	4620      	mov	r0, r4
 80390b4:	f001 f836 	bl	803a124 <SUBGRF_SetStandby>
            if( ( RadioEvents != NULL ) && ( RadioEvents->TxTimeout != NULL ) )
 80390b8:	4b61      	ldr	r3, [pc, #388]	; (8039240 <RadioIrqProcess+0x218>)
 80390ba:	681b      	ldr	r3, [r3, #0]
 80390bc:	2b00      	cmp	r3, #0
 80390be:	d0cf      	beq.n	8039060 <RadioIrqProcess+0x38>
 80390c0:	685b      	ldr	r3, [r3, #4]
 80390c2:	e010      	b.n	80390e6 <RadioIrqProcess+0xbe>
        TimerStop( &TxTimeoutTimer );
 80390c4:	4860      	ldr	r0, [pc, #384]	; (8039248 <RadioIrqProcess+0x220>)
 80390c6:	f002 f939 	bl	803b33c <UTIL_TIMER_Stop>
        SUBGRF_SetStandby( STDBY_RC );
 80390ca:	2000      	movs	r0, #0
 80390cc:	f001 f82a 	bl	803a124 <SUBGRF_SetStandby>
        if ( RFW_Is_LongPacketModeEnabled() == 1 )
 80390d0:	f001 fd56 	bl	803ab80 <RFW_Is_LongPacketModeEnabled>
 80390d4:	2801      	cmp	r0, #1
 80390d6:	d101      	bne.n	80390dc <RadioIrqProcess+0xb4>
            RFW_DeInit_TxLongPacket( );
 80390d8:	f001 fd5b 	bl	803ab92 <RFW_DeInit_TxLongPacket>
        if( ( RadioEvents != NULL ) && ( RadioEvents->TxDone != NULL ) )
 80390dc:	4b58      	ldr	r3, [pc, #352]	; (8039240 <RadioIrqProcess+0x218>)
 80390de:	681b      	ldr	r3, [r3, #0]
 80390e0:	2b00      	cmp	r3, #0
 80390e2:	d0bd      	beq.n	8039060 <RadioIrqProcess+0x38>
 80390e4:	681b      	ldr	r3, [r3, #0]
        if( ( RadioEvents != NULL ) && ( RadioEvents->RxError ) )
 80390e6:	2b00      	cmp	r3, #0
 80390e8:	d0ba      	beq.n	8039060 <RadioIrqProcess+0x38>
            RadioEvents->RxError( );
 80390ea:	4798      	blx	r3
}
 80390ec:	e7b8      	b.n	8039060 <RadioIrqProcess+0x38>
        TimerStop( &RxTimeoutTimer );
 80390ee:	4857      	ldr	r0, [pc, #348]	; (803924c <RadioIrqProcess+0x224>)
 80390f0:	f002 f924 	bl	803b33c <UTIL_TIMER_Stop>
        if( SubgRf.RxContinuous == false )
 80390f4:	7874      	ldrb	r4, [r6, #1]
 80390f6:	b994      	cbnz	r4, 803911e <RadioIrqProcess+0xf6>
            SUBGRF_SetStandby( STDBY_RC );
 80390f8:	4620      	mov	r0, r4
 80390fa:	f001 f813 	bl	803a124 <SUBGRF_SetStandby>
            SUBGRF_WriteRegister( 0x0902, 0x00 );
 80390fe:	4621      	mov	r1, r4
 8039100:	f640 1002 	movw	r0, #2306	; 0x902
 8039104:	f001 f98e 	bl	803a424 <SUBGRF_WriteRegister>
            SUBGRF_WriteRegister( 0x0944, SUBGRF_ReadRegister( 0x0944 ) | ( 1 << 1 ) );
 8039108:	f640 1044 	movw	r0, #2372	; 0x944
 803910c:	f001 fa50 	bl	803a5b0 <SUBGRF_ReadRegister>
 8039110:	f040 0102 	orr.w	r1, r0, #2
 8039114:	b2c9      	uxtb	r1, r1
 8039116:	f640 1044 	movw	r0, #2372	; 0x944
 803911a:	f001 f983 	bl	803a424 <SUBGRF_WriteRegister>
        SUBGRF_GetPayload( RadioBuffer, &size , 255 );
 803911e:	4c48      	ldr	r4, [pc, #288]	; (8039240 <RadioIrqProcess+0x218>)
 8039120:	22ff      	movs	r2, #255	; 0xff
 8039122:	f10d 0103 	add.w	r1, sp, #3
 8039126:	1d20      	adds	r0, r4, #4
 8039128:	f001 fc40 	bl	803a9ac <SUBGRF_GetPayload>
        SUBGRF_GetPacketStatus( &(SubgRf.PacketStatus) );
 803912c:	4848      	ldr	r0, [pc, #288]	; (8039250 <RadioIrqProcess+0x228>)
 803912e:	f001 f93f 	bl	803a3b0 <SUBGRF_GetPacketStatus>
        if( ( RadioEvents != NULL ) && ( RadioEvents->RxDone != NULL ) )
 8039132:	6823      	ldr	r3, [r4, #0]
 8039134:	2b00      	cmp	r3, #0
 8039136:	d093      	beq.n	8039060 <RadioIrqProcess+0x38>
 8039138:	689e      	ldr	r6, [r3, #8]
 803913a:	2e00      	cmp	r6, #0
 803913c:	d090      	beq.n	8039060 <RadioIrqProcess+0x38>
            switch ( SubgRf.PacketStatus.packetType )
 803913e:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
 8039142:	2b01      	cmp	r3, #1
 8039144:	d108      	bne.n	8039158 <RadioIrqProcess+0x130>
                RadioEvents->RxDone( RadioBuffer, size, SubgRf.PacketStatus.Params.LoRa.RssiPkt, SubgRf.PacketStatus.Params.LoRa.SnrPkt );
 8039146:	f995 3031 	ldrsb.w	r3, [r5, #49]	; 0x31
 803914a:	f995 2030 	ldrsb.w	r2, [r5, #48]	; 0x30
 803914e:	f89d 1003 	ldrb.w	r1, [sp, #3]
 8039152:	1d20      	adds	r0, r4, #4
 8039154:	47b0      	blx	r6
                break;
 8039156:	e783      	b.n	8039060 <RadioIrqProcess+0x38>
                SUBGRF_GetCFO( SubgRf.ModulationParams.Params.Gfsk.BitRate, &cfo );
 8039158:	6be8      	ldr	r0, [r5, #60]	; 0x3c
 803915a:	a901      	add	r1, sp, #4
 803915c:	f001 fcc4 	bl	803aae8 <SUBGRF_GetCFO>
                RadioEvents->RxDone( RadioBuffer, size, SubgRf.PacketStatus.Params.Gfsk.RssiAvg, (int8_t) DIVR(cfo, 1000) );
 8039160:	4620      	mov	r0, r4
 8039162:	9b01      	ldr	r3, [sp, #4]
 8039164:	f89d 1003 	ldrb.w	r1, [sp, #3]
 8039168:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 803916c:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
 8039170:	fb93 f3f2 	sdiv	r3, r3, r2
 8039174:	f850 2b04 	ldr.w	r2, [r0], #4
 8039178:	b25b      	sxtb	r3, r3
 803917a:	6894      	ldr	r4, [r2, #8]
 803917c:	f995 2029 	ldrsb.w	r2, [r5, #41]	; 0x29
 8039180:	47a0      	blx	r4
                break;
 8039182:	e76d      	b.n	8039060 <RadioIrqProcess+0x38>
        SUBGRF_SetStandby( STDBY_RC );
 8039184:	4620      	mov	r0, r4
 8039186:	f000 ffcd 	bl	803a124 <SUBGRF_SetStandby>
        if( ( RadioEvents != NULL ) && ( RadioEvents->CadDone != NULL ) )
 803918a:	4b2d      	ldr	r3, [pc, #180]	; (8039240 <RadioIrqProcess+0x218>)
 803918c:	681b      	ldr	r3, [r3, #0]
 803918e:	2b00      	cmp	r3, #0
 8039190:	f43f af66 	beq.w	8039060 <RadioIrqProcess+0x38>
 8039194:	699b      	ldr	r3, [r3, #24]
 8039196:	2b00      	cmp	r3, #0
 8039198:	f43f af62 	beq.w	8039060 <RadioIrqProcess+0x38>
            RadioEvents->CadDone( true );
 803919c:	2001      	movs	r0, #1
 803919e:	e776      	b.n	803908e <RadioIrqProcess+0x66>
        else if( SUBGRF_GetOperatingMode( ) == MODE_RX )
 80391a0:	f000 ffba 	bl	803a118 <SUBGRF_GetOperatingMode>
 80391a4:	2805      	cmp	r0, #5
 80391a6:	f47f af5b 	bne.w	8039060 <RadioIrqProcess+0x38>
            TimerStop( &RxTimeoutTimer );
 80391aa:	4828      	ldr	r0, [pc, #160]	; (803924c <RadioIrqProcess+0x224>)
 80391ac:	f002 f8c6 	bl	803b33c <UTIL_TIMER_Stop>
            SUBGRF_SetStandby( STDBY_RC );
 80391b0:	4620      	mov	r0, r4
 80391b2:	f000 ffb7 	bl	803a124 <SUBGRF_SetStandby>
            if( ( RadioEvents != NULL ) && ( RadioEvents->RxTimeout != NULL ) )
 80391b6:	4b22      	ldr	r3, [pc, #136]	; (8039240 <RadioIrqProcess+0x218>)
 80391b8:	681b      	ldr	r3, [r3, #0]
 80391ba:	2b00      	cmp	r3, #0
 80391bc:	f43f af50 	beq.w	8039060 <RadioIrqProcess+0x38>
 80391c0:	68db      	ldr	r3, [r3, #12]
 80391c2:	e790      	b.n	80390e6 <RadioIrqProcess+0xbe>
        MW_LOG( TS_ON, VLEVEL_M,  "PRE OK\r\n" );
 80391c4:	4b23      	ldr	r3, [pc, #140]	; (8039254 <RadioIrqProcess+0x22c>)
            MW_LOG( TS_ON, VLEVEL_M,  "HDR KO\r\n" );
 80391c6:	2201      	movs	r2, #1
 80391c8:	2100      	movs	r1, #0
 80391ca:	2002      	movs	r0, #2
 80391cc:	f001 fd94 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
 80391d0:	e746      	b.n	8039060 <RadioIrqProcess+0x38>
        MW_LOG( TS_ON, VLEVEL_M,  "SYNC OK\r\n" );
 80391d2:	4b21      	ldr	r3, [pc, #132]	; (8039258 <RadioIrqProcess+0x230>)
 80391d4:	2201      	movs	r2, #1
 80391d6:	2100      	movs	r1, #0
 80391d8:	2002      	movs	r0, #2
 80391da:	f001 fd8d 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
        if ( 1UL == RFW_Is_Init( ) )
 80391de:	f001 fccd 	bl	803ab7c <RFW_Is_Init>
 80391e2:	2801      	cmp	r0, #1
 80391e4:	f47f af3c 	bne.w	8039060 <RadioIrqProcess+0x38>
            RFW_ReceivePayload( );
 80391e8:	f001 fcd4 	bl	803ab94 <RFW_ReceivePayload>
 80391ec:	e738      	b.n	8039060 <RadioIrqProcess+0x38>
        MW_LOG( TS_ON, VLEVEL_M,  "HDR OK\r\n" );
 80391ee:	4b1b      	ldr	r3, [pc, #108]	; (803925c <RadioIrqProcess+0x234>)
 80391f0:	e7e9      	b.n	80391c6 <RadioIrqProcess+0x19e>
        TimerStop( &RxTimeoutTimer );
 80391f2:	4816      	ldr	r0, [pc, #88]	; (803924c <RadioIrqProcess+0x224>)
 80391f4:	f002 f8a2 	bl	803b33c <UTIL_TIMER_Stop>
        if( SubgRf.RxContinuous == false )
 80391f8:	7870      	ldrb	r0, [r6, #1]
 80391fa:	b908      	cbnz	r0, 8039200 <RadioIrqProcess+0x1d8>
            SUBGRF_SetStandby( STDBY_RC );
 80391fc:	f000 ff92 	bl	803a124 <SUBGRF_SetStandby>
        if( ( RadioEvents != NULL ) && ( RadioEvents->RxTimeout != NULL ) )
 8039200:	4b0f      	ldr	r3, [pc, #60]	; (8039240 <RadioIrqProcess+0x218>)
 8039202:	681b      	ldr	r3, [r3, #0]
 8039204:	2b00      	cmp	r3, #0
 8039206:	f43f af2b 	beq.w	8039060 <RadioIrqProcess+0x38>
 803920a:	68db      	ldr	r3, [r3, #12]
 803920c:	2b00      	cmp	r3, #0
 803920e:	f43f af27 	beq.w	8039060 <RadioIrqProcess+0x38>
            RadioEvents->RxTimeout( );
 8039212:	4798      	blx	r3
            MW_LOG( TS_ON, VLEVEL_M,  "HDR KO\r\n" );
 8039214:	4b12      	ldr	r3, [pc, #72]	; (8039260 <RadioIrqProcess+0x238>)
 8039216:	e7d6      	b.n	80391c6 <RadioIrqProcess+0x19e>
        MW_LOG( TS_ON, VLEVEL_M,  "IRQ_CRC_ERROR\r\n" );
 8039218:	4b12      	ldr	r3, [pc, #72]	; (8039264 <RadioIrqProcess+0x23c>)
 803921a:	2201      	movs	r2, #1
 803921c:	4621      	mov	r1, r4
 803921e:	2002      	movs	r0, #2
 8039220:	f001 fd6a 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
        if( SubgRf.RxContinuous == false )
 8039224:	7870      	ldrb	r0, [r6, #1]
 8039226:	b908      	cbnz	r0, 803922c <RadioIrqProcess+0x204>
            SUBGRF_SetStandby( STDBY_RC );
 8039228:	f000 ff7c 	bl	803a124 <SUBGRF_SetStandby>
        if( ( RadioEvents != NULL ) && ( RadioEvents->RxError ) )
 803922c:	4b04      	ldr	r3, [pc, #16]	; (8039240 <RadioIrqProcess+0x218>)
 803922e:	681b      	ldr	r3, [r3, #0]
 8039230:	2b00      	cmp	r3, #0
 8039232:	f43f af15 	beq.w	8039060 <RadioIrqProcess+0x38>
 8039236:	691b      	ldr	r3, [r3, #16]
 8039238:	e755      	b.n	80390e6 <RadioIrqProcess+0xbe>
 803923a:	bf00      	nop
 803923c:	20006324 	.word	0x20006324
 8039240:	2000597c 	.word	0x2000597c
 8039244:	0803c560 	.word	0x0803c560
 8039248:	2000637c 	.word	0x2000637c
 803924c:	20006394 	.word	0x20006394
 8039250:	20006348 	.word	0x20006348
 8039254:	0803c574 	.word	0x0803c574
 8039258:	0803c57d 	.word	0x0803c57d
 803925c:	0803c587 	.word	0x0803c587
 8039260:	0803c590 	.word	0x0803c590
 8039264:	0803c599 	.word	0x0803c599

08039268 <RadioOnDioIrq>:
    SubgRf.RadioIrq = radioIrq;
 8039268:	4b02      	ldr	r3, [pc, #8]	; (8039274 <RadioOnDioIrq+0xc>)
 803926a:	f8a3 0054 	strh.w	r0, [r3, #84]	; 0x54
    RADIO_IRQ_PROCESS();
 803926e:	f7ff bedb 	b.w	8039028 <RadioIrqProcess>
 8039272:	bf00      	nop
 8039274:	20006324 	.word	0x20006324

08039278 <RadioGetWakeupTime>:
{
 8039278:	b508      	push	{r3, lr}
    return SUBGRF_GetRadioWakeUpTime() + RADIO_WAKEUP_TIME;
 803927a:	f001 fbdb 	bl	803aa34 <SUBGRF_GetRadioWakeUpTime>
}
 803927e:	3003      	adds	r0, #3
 8039280:	bd08      	pop	{r3, pc}

08039282 <RadioReadRegisters>:
    SUBGRF_ReadRegisters( addr, buffer, size );
 8039282:	f001 bb21 	b.w	803a8c8 <SUBGRF_ReadRegisters>

08039286 <RadioWriteRegisters>:
    SUBGRF_WriteRegisters( addr, buffer, size );
 8039286:	f001 ba7f 	b.w	803a788 <SUBGRF_WriteRegisters>

0803928a <RadioRssi>:
{
 803928a:	b508      	push	{r3, lr}
    return SUBGRF_GetRssiInst( );
 803928c:	f001 f883 	bl	803a396 <SUBGRF_GetRssiInst>
}
 8039290:	b200      	sxth	r0, r0
 8039292:	bd08      	pop	{r3, pc}

08039294 <RadioSetTxContinuousWave>:
{
 8039294:	b538      	push	{r3, r4, r5, lr}
 8039296:	460d      	mov	r5, r1
 8039298:	4614      	mov	r4, r2
    SUBGRF_SetRfFrequency( freq );
 803929a:	f001 f851 	bl	803a340 <SUBGRF_SetRfFrequency>
    antswitchpow = SUBGRF_SetRfTxPower( power );
 803929e:	4628      	mov	r0, r5
 80392a0:	f001 fbb3 	bl	803aa0a <SUBGRF_SetRfTxPower>
    TimerSetValue( &TxTimeoutTimer, timeout );
 80392a4:	4d08      	ldr	r5, [pc, #32]	; (80392c8 <RadioSetTxContinuousWave+0x34>)
    SUBGRF_SetSwitch(antswitchpow, RFSWITCH_TX);
 80392a6:	2101      	movs	r1, #1
 80392a8:	f001 fb99 	bl	803a9de <SUBGRF_SetSwitch>
    SUBGRF_SetTxContinuousWave( );
 80392ac:	f000 ffa4 	bl	803a1f8 <SUBGRF_SetTxContinuousWave>
    TimerSetValue( &TxTimeoutTimer, timeout );
 80392b0:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 80392b4:	4361      	muls	r1, r4
 80392b6:	4628      	mov	r0, r5
 80392b8:	f002 f8ca 	bl	803b450 <UTIL_TIMER_SetPeriod>
    TimerStart( &TxTimeoutTimer );
 80392bc:	4628      	mov	r0, r5
}
 80392be:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    TimerStart( &TxTimeoutTimer );
 80392c2:	f002 b88b 	b.w	803b3dc <UTIL_TIMER_Start>
 80392c6:	bf00      	nop
 80392c8:	2000637c 	.word	0x2000637c

080392cc <RadioSetChannel>:
    SUBGRF_SetRfFrequency( freq );
 80392cc:	f001 b838 	b.w	803a340 <SUBGRF_SetRfFrequency>

080392d0 <RadioStartCad>:
{
 80392d0:	b508      	push	{r3, lr}
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_RX);
 80392d2:	4b08      	ldr	r3, [pc, #32]	; (80392f4 <RadioStartCad+0x24>)
 80392d4:	2100      	movs	r1, #0
 80392d6:	f893 0056 	ldrb.w	r0, [r3, #86]	; 0x56
 80392da:	f001 fb80 	bl	803a9de <SUBGRF_SetSwitch>
    SUBGRF_SetDioIrqParams( IRQ_CAD_CLEAR | IRQ_CAD_DETECTED,
 80392de:	2300      	movs	r3, #0
 80392e0:	f44f 71c0 	mov.w	r1, #384	; 0x180
 80392e4:	461a      	mov	r2, r3
 80392e6:	4608      	mov	r0, r1
 80392e8:	f001 f800 	bl	803a2ec <SUBGRF_SetDioIrqParams>
}
 80392ec:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    SUBGRF_SetCad( );
 80392f0:	f000 bf76 	b.w	803a1e0 <SUBGRF_SetCad>
 80392f4:	20006324 	.word	0x20006324

080392f8 <RadioSleep>:
{
 80392f8:	b508      	push	{r3, lr}
    SUBGRF_SetSleep( params );
 80392fa:	f04f 0004 	mov.w	r0, #4
 80392fe:	f001 f9ab 	bl	803a658 <SUBGRF_SetSleep>
}
 8039302:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RADIO_DELAY_MS( 2 );
 8039306:	2002      	movs	r0, #2
 8039308:	f7f3 b99e 	b.w	802c648 <HAL_Delay>

0803930c <RadioTimeOnAir>:
{
 803930c:	b5f0      	push	{r4, r5, r6, r7, lr}
 803930e:	f8bd 5014 	ldrh.w	r5, [sp, #20]
 8039312:	f89d e018 	ldrb.w	lr, [sp, #24]
 8039316:	f89d c01c 	ldrb.w	ip, [sp, #28]
 803931a:	f89d 4020 	ldrb.w	r4, [sp, #32]
    switch( modem )
 803931e:	b140      	cbz	r0, 8039332 <RadioTimeOnAir+0x26>
 8039320:	2801      	cmp	r0, #1
 8039322:	d019      	beq.n	8039358 <RadioTimeOnAir+0x4c>
 8039324:	2201      	movs	r2, #1
 8039326:	2300      	movs	r3, #0
    return DIVC(numerator, denominator); /* ST_WORKAROUND : simplified calculation with macro usage */
 8039328:	4413      	add	r3, r2
 803932a:	1e58      	subs	r0, r3, #1
 803932c:	fbb0 f0f2 	udiv	r0, r0, r2
}
 8039330:	bdf0      	pop	{r4, r5, r6, r7, pc}
           ( ( fixLen == false ) ? 8 : 0 ) + 24 +
 8039332:	f1be 0f00 	cmp.w	lr, #0
 8039336:	bf0c      	ite	eq
 8039338:	2308      	moveq	r3, #8
 803933a:	2300      	movne	r3, #0
           ( ( payloadLen + ( ( crcOn == true ) ? 2 : 0 ) ) << 3 );
 803933c:	2c00      	cmp	r4, #0
    return ( preambleLen << 3 ) +
 803933e:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
           ( ( payloadLen + ( ( crcOn == true ) ? 2 : 0 ) ) << 3 );
 8039342:	bf14      	ite	ne
 8039344:	2402      	movne	r4, #2
 8039346:	2400      	moveq	r4, #0
           ( ( fixLen == false ) ? 8 : 0 ) + 24 +
 8039348:	3318      	adds	r3, #24
           ( ( payloadLen + ( ( crcOn == true ) ? 2 : 0 ) ) << 3 );
 803934a:	4464      	add	r4, ip
           ( ( fixLen == false ) ? 8 : 0 ) + 24 +
 803934c:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
            numerator   = 1000U * RadioGetGfskTimeOnAirNumerator( datarate, coderate,
 8039350:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8039354:	4363      	muls	r3, r4
        break;
 8039356:	e7e7      	b.n	8039328 <RadioTimeOnAir+0x1c>
    int32_t crDenom           = coderate + 4;
 8039358:	1d1e      	adds	r6, r3, #4
    if( ( datarate == 5 ) || ( datarate == 6 ) )
 803935a:	1f53      	subs	r3, r2, #5
 803935c:	2b01      	cmp	r3, #1
 803935e:	d802      	bhi.n	8039366 <RadioTimeOnAir+0x5a>
        if( preambleLen < 12 )
 8039360:	2d0c      	cmp	r5, #12
 8039362:	bf38      	it	cc
 8039364:	250c      	movcc	r5, #12
    if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 8039366:	2900      	cmp	r1, #0
 8039368:	d138      	bne.n	80393dc <RadioTimeOnAir+0xd0>
 803936a:	f1a2 070b 	sub.w	r7, r2, #11
 803936e:	2f01      	cmp	r7, #1
 8039370:	bf8c      	ite	hi
 8039372:	2700      	movhi	r7, #0
 8039374:	2701      	movls	r7, #1
                            ( crcOn ? 16 : 0 ) -
 8039376:	2c00      	cmp	r4, #0
 8039378:	bf14      	ite	ne
 803937a:	2410      	movne	r4, #16
 803937c:	2400      	moveq	r4, #0
    int32_t ceilNumerator = ( payloadLen << 3 ) +
 803937e:	eb04 04cc 	add.w	r4, r4, ip, lsl #3
                            ( fixLen ? 0 : 20 );
 8039382:	f1be 0f00 	cmp.w	lr, #0
 8039386:	bf14      	ite	ne
 8039388:	2000      	movne	r0, #0
 803938a:	2014      	moveq	r0, #20
                            ( crcOn ? 16 : 0 ) -
 803938c:	eba4 0482 	sub.w	r4, r4, r2, lsl #2
    if( datarate <= 6 )
 8039390:	2a06      	cmp	r2, #6
                            ( 4 * datarate ) +
 8039392:	4404      	add	r4, r0
 8039394:	ea4f 0382 	mov.w	r3, r2, lsl #2
 8039398:	f1a2 0002 	sub.w	r0, r2, #2
    if( datarate <= 6 )
 803939c:	d902      	bls.n	80393a4 <RadioTimeOnAir+0x98>
        ceilNumerator += 8;
 803939e:	3408      	adds	r4, #8
        if( lowDatareOptimize == true )
 80393a0:	b107      	cbz	r7, 80393a4 <RadioTimeOnAir+0x98>
            ceilDenominator = 4 * ( datarate - 2 );
 80393a2:	0083      	lsls	r3, r0, #2
        ( ( ceilNumerator + ceilDenominator - 1 ) / ceilDenominator ) * crDenom + preambleLen + 12;
 80393a4:	2c00      	cmp	r4, #0
 80393a6:	bfac      	ite	ge
 80393a8:	191c      	addge	r4, r3, r4
 80393aa:	1c1c      	addlt	r4, r3, #0
 80393ac:	3c01      	subs	r4, #1
 80393ae:	fb94 f3f3 	sdiv	r3, r4, r3
            denominator = RadioGetLoRaBandwidthInHz( Bandwidths[bandwidth] );
 80393b2:	4c0f      	ldr	r4, [pc, #60]	; (80393f0 <RadioTimeOnAir+0xe4>)
 80393b4:	4421      	add	r1, r4
    if( datarate <= 6 )
 80393b6:	2a06      	cmp	r2, #6
            denominator = RadioGetLoRaBandwidthInHz( Bandwidths[bandwidth] );
 80393b8:	7909      	ldrb	r1, [r1, #4]
        ( ( ceilNumerator + ceilDenominator - 1 ) / ceilDenominator ) * crDenom + preambleLen + 12;
 80393ba:	fb06 5303 	mla	r3, r6, r3, r5
    int32_t intermediate =
 80393be:	bf8c      	ite	hi
 80393c0:	330c      	addhi	r3, #12
        intermediate += 2;
 80393c2:	330e      	addls	r3, #14
    switch( bw )
 80393c4:	290a      	cmp	r1, #10
 80393c6:	d812      	bhi.n	80393ee <RadioTimeOnAir+0xe2>
    return ( uint32_t )( ( 4 * intermediate + 1 ) * ( 1 << ( datarate - 2 ) ) );
 80393c8:	009b      	lsls	r3, r3, #2
 80393ca:	3301      	adds	r3, #1
 80393cc:	eb04 0481 	add.w	r4, r4, r1, lsl #2
            numerator   = 1000U * RadioGetLoRaTimeOnAirNumerator( bandwidth, datarate,
 80393d0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    return ( uint32_t )( ( 4 * intermediate + 1 ) * ( 1 << ( datarate - 2 ) ) );
 80393d4:	4083      	lsls	r3, r0
            numerator   = 1000U * RadioGetLoRaTimeOnAirNumerator( bandwidth, datarate,
 80393d6:	4353      	muls	r3, r2
 80393d8:	68a2      	ldr	r2, [r4, #8]
 80393da:	e7a5      	b.n	8039328 <RadioTimeOnAir+0x1c>
    if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 80393dc:	2901      	cmp	r1, #1
 80393de:	d104      	bne.n	80393ea <RadioTimeOnAir+0xde>
        ( ( bandwidth == 1 ) && ( datarate == 12 ) ) )
 80393e0:	f1a2 030c 	sub.w	r3, r2, #12
 80393e4:	425f      	negs	r7, r3
 80393e6:	415f      	adcs	r7, r3
 80393e8:	e7c5      	b.n	8039376 <RadioTimeOnAir+0x6a>
    bool    lowDatareOptimize = false;
 80393ea:	2700      	movs	r7, #0
 80393ec:	e7c3      	b.n	8039376 <RadioTimeOnAir+0x6a>
    return DIVC(numerator, denominator); /* ST_WORKAROUND : simplified calculation with macro usage */
 80393ee:	deff      	udf	#255	; 0xff
 80393f0:	0803bbec 	.word	0x0803bbec

080393f4 <RadioSetMaxPayloadLength>:
    if( modem == MODEM_LORA )
 80393f4:	2801      	cmp	r0, #1
 80393f6:	4808      	ldr	r0, [pc, #32]	; (8039418 <RadioSetMaxPayloadLength+0x24>)
 80393f8:	d105      	bne.n	8039406 <RadioSetMaxPayloadLength+0x12>
        SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength = max;
 80393fa:	4b08      	ldr	r3, [pc, #32]	; (803941c <RadioSetMaxPayloadLength+0x28>)
 80393fc:	77c1      	strb	r1, [r0, #31]
 80393fe:	7019      	strb	r1, [r3, #0]
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039400:	300e      	adds	r0, #14
 8039402:	f001 b9ff 	b.w	803a804 <SUBGRF_SetPacketParams>
        if( SubgRf.PacketParams.Params.Gfsk.HeaderType == RADIO_PACKET_VARIABLE_LENGTH )
 8039406:	7d43      	ldrb	r3, [r0, #21]
 8039408:	2b01      	cmp	r3, #1
 803940a:	d103      	bne.n	8039414 <RadioSetMaxPayloadLength+0x20>
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength = max;
 803940c:	4b03      	ldr	r3, [pc, #12]	; (803941c <RadioSetMaxPayloadLength+0x28>)
 803940e:	7581      	strb	r1, [r0, #22]
 8039410:	7019      	strb	r1, [r3, #0]
 8039412:	e7f5      	b.n	8039400 <RadioSetMaxPayloadLength+0xc>
}
 8039414:	4770      	bx	lr
 8039416:	bf00      	nop
 8039418:	20006324 	.word	0x20006324
 803941c:	200035a0 	.word	0x200035a0

08039420 <RadioRxBoosted>:
{
 8039420:	b510      	push	{r4, lr}
 8039422:	4604      	mov	r4, r0
    if (1UL==RFW_Is_Init())
 8039424:	f001 fbaa 	bl	803ab7c <RFW_Is_Init>
 8039428:	2801      	cmp	r0, #1
 803942a:	d117      	bne.n	803945c <RadioRxBoosted+0x3c>
      RFW_ReceiveInit();
 803942c:	f001 fbae 	bl	803ab8c <RFW_ReceiveInit>
    if( timeout != 0 )
 8039430:	b134      	cbz	r4, 8039440 <RadioRxBoosted+0x20>
        TimerSetValue( &RxTimeoutTimer, timeout );
 8039432:	4810      	ldr	r0, [pc, #64]	; (8039474 <RadioRxBoosted+0x54>)
 8039434:	4621      	mov	r1, r4
 8039436:	f002 f80b 	bl	803b450 <UTIL_TIMER_SetPeriod>
        TimerStart( &RxTimeoutTimer );
 803943a:	480e      	ldr	r0, [pc, #56]	; (8039474 <RadioRxBoosted+0x54>)
 803943c:	f001 ffce 	bl	803b3dc <UTIL_TIMER_Start>
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_RX);
 8039440:	4c0d      	ldr	r4, [pc, #52]	; (8039478 <RadioRxBoosted+0x58>)
 8039442:	2100      	movs	r1, #0
 8039444:	f894 0056 	ldrb.w	r0, [r4, #86]	; 0x56
 8039448:	f001 fac9 	bl	803a9de <SUBGRF_SetSwitch>
    if( SubgRf.RxContinuous == true )
 803944c:	7863      	ldrb	r3, [r4, #1]
 803944e:	b16b      	cbz	r3, 803946c <RadioRxBoosted+0x4c>
        SUBGRF_SetRxBoosted( 0xFFFFFF ); // Rx Continuous
 8039450:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
}
 8039454:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        SUBGRF_SetRxBoosted( SubgRf.RxTimeout << 6 );
 8039458:	f000 bff4 	b.w	803a444 <SUBGRF_SetRxBoosted>
      SUBGRF_SetDioIrqParams( IRQ_RX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_CRC_ERROR | IRQ_HEADER_ERROR | IRQ_RX_DBG,
 803945c:	2300      	movs	r3, #0
 803945e:	f240 2162 	movw	r1, #610	; 0x262
 8039462:	461a      	mov	r2, r3
 8039464:	4608      	mov	r0, r1
 8039466:	f000 ff41 	bl	803a2ec <SUBGRF_SetDioIrqParams>
 803946a:	e7e1      	b.n	8039430 <RadioRxBoosted+0x10>
        SUBGRF_SetRxBoosted( SubgRf.RxTimeout << 6 );
 803946c:	68a0      	ldr	r0, [r4, #8]
 803946e:	0180      	lsls	r0, r0, #6
 8039470:	e7f0      	b.n	8039454 <RadioRxBoosted+0x34>
 8039472:	bf00      	nop
 8039474:	20006394 	.word	0x20006394
 8039478:	20006324 	.word	0x20006324

0803947c <RadioRx>:
{
 803947c:	b510      	push	{r4, lr}
 803947e:	4604      	mov	r4, r0
    if ( 1UL == RFW_Is_Init( ) )
 8039480:	f001 fb7c 	bl	803ab7c <RFW_Is_Init>
 8039484:	2801      	cmp	r0, #1
 8039486:	d117      	bne.n	80394b8 <RadioRx+0x3c>
      RFW_ReceiveInit( );
 8039488:	f001 fb80 	bl	803ab8c <RFW_ReceiveInit>
    if( timeout != 0 )
 803948c:	b134      	cbz	r4, 803949c <RadioRx+0x20>
        TimerSetValue( &RxTimeoutTimer, timeout );
 803948e:	4810      	ldr	r0, [pc, #64]	; (80394d0 <RadioRx+0x54>)
 8039490:	4621      	mov	r1, r4
 8039492:	f001 ffdd 	bl	803b450 <UTIL_TIMER_SetPeriod>
        TimerStart( &RxTimeoutTimer );
 8039496:	480e      	ldr	r0, [pc, #56]	; (80394d0 <RadioRx+0x54>)
 8039498:	f001 ffa0 	bl	803b3dc <UTIL_TIMER_Start>
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_RX);
 803949c:	4c0d      	ldr	r4, [pc, #52]	; (80394d4 <RadioRx+0x58>)
 803949e:	2100      	movs	r1, #0
 80394a0:	f894 0056 	ldrb.w	r0, [r4, #86]	; 0x56
 80394a4:	f001 fa9b 	bl	803a9de <SUBGRF_SetSwitch>
    if( SubgRf.RxContinuous == true )
 80394a8:	7863      	ldrb	r3, [r4, #1]
 80394aa:	b16b      	cbz	r3, 80394c8 <RadioRx+0x4c>
        SUBGRF_SetRx( 0xFFFFFF ); // Rx Continuous
 80394ac:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
}
 80394b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        SUBGRF_SetRx( SubgRf.RxTimeout << 6 );
 80394b4:	f000 be62 	b.w	803a17c <SUBGRF_SetRx>
      SUBGRF_SetDioIrqParams( IRQ_RX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_CRC_ERROR | IRQ_HEADER_ERROR | IRQ_RX_DBG,
 80394b8:	2300      	movs	r3, #0
 80394ba:	f240 2162 	movw	r1, #610	; 0x262
 80394be:	461a      	mov	r2, r3
 80394c0:	4608      	mov	r0, r1
 80394c2:	f000 ff13 	bl	803a2ec <SUBGRF_SetDioIrqParams>
 80394c6:	e7e1      	b.n	803948c <RadioRx+0x10>
        SUBGRF_SetRx( SubgRf.RxTimeout << 6 );
 80394c8:	68a0      	ldr	r0, [r4, #8]
 80394ca:	0180      	lsls	r0, r0, #6
 80394cc:	e7f0      	b.n	80394b0 <RadioRx+0x34>
 80394ce:	bf00      	nop
 80394d0:	20006394 	.word	0x20006394
 80394d4:	20006324 	.word	0x20006324

080394d8 <RadioSetPublicNetwork>:
    SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous = enable;
 80394d8:	4b0d      	ldr	r3, [pc, #52]	; (8039510 <RadioSetPublicNetwork+0x38>)
{
 80394da:	b510      	push	{r4, lr}
 80394dc:	4604      	mov	r4, r0
    SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous = enable;
 80394de:	7318      	strb	r0, [r3, #12]
 80394e0:	7358      	strb	r0, [r3, #13]
    RadioSetModem( MODEM_LORA );
 80394e2:	2001      	movs	r0, #1
 80394e4:	f000 f816 	bl	8039514 <RadioSetModem>
    if( enable == true )
 80394e8:	b15c      	cbz	r4, 8039502 <RadioSetPublicNetwork+0x2a>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD, ( LORA_MAC_PUBLIC_SYNCWORD >> 8 ) & 0xFF );
 80394ea:	2134      	movs	r1, #52	; 0x34
 80394ec:	f44f 60e8 	mov.w	r0, #1856	; 0x740
 80394f0:	f000 ff98 	bl	803a424 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PUBLIC_SYNCWORD & 0xFF );
 80394f4:	2144      	movs	r1, #68	; 0x44
}
 80394f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PRIVATE_SYNCWORD & 0xFF );
 80394fa:	f240 7041 	movw	r0, #1857	; 0x741
 80394fe:	f000 bf91 	b.w	803a424 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD, ( LORA_MAC_PRIVATE_SYNCWORD >> 8 ) & 0xFF );
 8039502:	2114      	movs	r1, #20
 8039504:	f44f 60e8 	mov.w	r0, #1856	; 0x740
 8039508:	f000 ff8c 	bl	803a424 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PRIVATE_SYNCWORD & 0xFF );
 803950c:	2124      	movs	r1, #36	; 0x24
 803950e:	e7f2      	b.n	80394f6 <RadioSetPublicNetwork+0x1e>
 8039510:	20006324 	.word	0x20006324

08039514 <RadioSetModem>:
{
 8039514:	b538      	push	{r3, r4, r5, lr}
    SubgRf.Modem = modem;
 8039516:	4d0f      	ldr	r5, [pc, #60]	; (8039554 <RadioSetModem+0x40>)
{
 8039518:	4604      	mov	r4, r0
    SubgRf.Modem = modem;
 803951a:	7028      	strb	r0, [r5, #0]
    RFW_SetRadioModem(modem);
 803951c:	f001 fb3b 	bl	803ab96 <RFW_SetRadioModem>
    switch( modem )
 8039520:	2c01      	cmp	r4, #1
 8039522:	d00a      	beq.n	803953a <RadioSetModem+0x26>
 8039524:	3c02      	subs	r4, #2
 8039526:	2c01      	cmp	r4, #1
 8039528:	f04f 0400 	mov.w	r4, #0
        SUBGRF_SetPacketType( PACKET_TYPE_BPSK );
 803952c:	bf94      	ite	ls
 803952e:	2002      	movls	r0, #2
        SUBGRF_SetPacketType( PACKET_TYPE_GFSK );
 8039530:	4620      	movhi	r0, r4
 8039532:	f000 ffbb 	bl	803a4ac <SUBGRF_SetPacketType>
        SubgRf.PublicNetwork.Current = false;
 8039536:	736c      	strb	r4, [r5, #13]
}
 8039538:	bd38      	pop	{r3, r4, r5, pc}
        SUBGRF_SetPacketType( PACKET_TYPE_LORA );
 803953a:	4620      	mov	r0, r4
 803953c:	f000 ffb6 	bl	803a4ac <SUBGRF_SetPacketType>
        if( SubgRf.PublicNetwork.Current != SubgRf.PublicNetwork.Previous )
 8039540:	7b28      	ldrb	r0, [r5, #12]
 8039542:	7b6b      	ldrb	r3, [r5, #13]
 8039544:	4283      	cmp	r3, r0
 8039546:	d0f7      	beq.n	8039538 <RadioSetModem+0x24>
            SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous;
 8039548:	7368      	strb	r0, [r5, #13]
}
 803954a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
            RadioSetPublicNetwork( SubgRf.PublicNetwork.Current );
 803954e:	f7ff bfc3 	b.w	80394d8 <RadioSetPublicNetwork>
 8039552:	bf00      	nop
 8039554:	20006324 	.word	0x20006324

08039558 <RadioSetTxGenericConfig>:
    }
    return status;
}

static int32_t RadioSetTxGenericConfig( GenericModems_t modem, TxConfigGeneric_t* config, int8_t power, uint32_t timeout )
{
 8039558:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 803955c:	4605      	mov	r5, r0
 803955e:	b087      	sub	sp, #28
    uint8_t syncword[8] = {0};
 8039560:	2700      	movs	r7, #0
 8039562:	e9cd 7701 	strd	r7, r7, [sp, #4]
{
 8039566:	460c      	mov	r4, r1
 8039568:	4691      	mov	r9, r2
 803956a:	4698      	mov	r8, r3
    RFW_DeInit( ); /* switch Off FwPacketDecoding by default */
 803956c:	f001 fb05 	bl	803ab7a <RFW_DeInit>
    switch( modem )
 8039570:	2d01      	cmp	r5, #1
 8039572:	d078      	beq.n	8039666 <RadioSetTxGenericConfig+0x10e>
 8039574:	2d02      	cmp	r5, #2
 8039576:	f000 80c4 	beq.w	8039702 <RadioSetTxGenericConfig+0x1aa>
 803957a:	2d00      	cmp	r5, #0
 803957c:	d15c      	bne.n	8039638 <RadioSetTxGenericConfig+0xe0>
    {
    case GENERIC_FSK:
        if( ( config->fsk.BitRate == 0 ) || ( config->fsk.PreambleLen == 0 ) )
 803957e:	68a3      	ldr	r3, [r4, #8]
 8039580:	2b00      	cmp	r3, #0
 8039582:	f000 80d2 	beq.w	803972a <RadioSetTxGenericConfig+0x1d2>
 8039586:	6922      	ldr	r2, [r4, #16]
 8039588:	2a00      	cmp	r2, #0
 803958a:	f000 80ce 	beq.w	803972a <RadioSetTxGenericConfig+0x1d2>
        {
            return -1;
        }
        if( config->fsk.SyncWordLength > 8 )
 803958e:	7d22      	ldrb	r2, [r4, #20]
 8039590:	2a08      	cmp	r2, #8
 8039592:	f200 80ca 	bhi.w	803972a <RadioSetTxGenericConfig+0x1d2>
        }
        else
        {
            for(int i = 0; i < config->fsk.SyncWordLength; i++)
            {
                syncword[i] = config->fsk.SyncWord[i];
 8039596:	a901      	add	r1, sp, #4
            for(int i = 0; i < config->fsk.SyncWordLength; i++)
 8039598:	42aa      	cmp	r2, r5
 803959a:	dc5b      	bgt.n	8039654 <RadioSetTxGenericConfig+0xfc>
            }
        }
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 803959c:	4d64      	ldr	r5, [pc, #400]	; (8039730 <RadioSetTxGenericConfig+0x1d8>)
 803959e:	2600      	movs	r6, #0
 80395a0:	f885 6038 	strb.w	r6, [r5, #56]	; 0x38
        SubgRf.ModulationParams.Params.Gfsk.BitRate = config->fsk.BitRate;
 80395a4:	63eb      	str	r3, [r5, #60]	; 0x3c
        SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = ( RadioModShapings_t ) config->fsk.ModulationShaping;
 80395a6:	7823      	ldrb	r3, [r4, #0]
 80395a8:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
        SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( config->fsk.Bandwidth );
 80395ac:	6860      	ldr	r0, [r4, #4]
 80395ae:	f001 fa85 	bl	803aabc <SUBGRF_GetFskBandwidthRegValue>
 80395b2:	f885 0045 	strb.w	r0, [r5, #69]	; 0x45
        SubgRf.ModulationParams.Params.Gfsk.Fdev = config->fsk.FrequencyDeviation;
 80395b6:	68e3      	ldr	r3, [r4, #12]
 80395b8:	642b      	str	r3, [r5, #64]	; 0x40
    
        SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
        SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( config->fsk.PreambleLen ) << 3; // convert byte into bit
 80395ba:	6923      	ldr	r3, [r4, #16]
        SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS; // don't care in tx
        SubgRf.PacketParams.Params.Gfsk.SyncWordLength = ( config->fsk.SyncWordLength ) << 3; // convert byte into bit
        SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF; // don't care in tx

        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING ) || ( config->fsk.HeaderType == RADIO_FSK_PACKET_2BYTES_LENGTH ) )
 80395bc:	f894 1024 	ldrb.w	r1, [r4, #36]	; 0x24
        SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 80395c0:	73ae      	strb	r6, [r5, #14]
        SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( config->fsk.PreambleLen ) << 3; // convert byte into bit
 80395c2:	00db      	lsls	r3, r3, #3
 80395c4:	822b      	strh	r3, [r5, #16]
        SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS; // don't care in tx
 80395c6:	2304      	movs	r3, #4
 80395c8:	74ab      	strb	r3, [r5, #18]
        SubgRf.PacketParams.Params.Gfsk.SyncWordLength = ( config->fsk.SyncWordLength ) << 3; // convert byte into bit
 80395ca:	7d23      	ldrb	r3, [r4, #20]
        SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF; // don't care in tx
 80395cc:	752e      	strb	r6, [r5, #20]
        SubgRf.PacketParams.Params.Gfsk.SyncWordLength = ( config->fsk.SyncWordLength ) << 3; // convert byte into bit
 80395ce:	00db      	lsls	r3, r3, #3
        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING ) || ( config->fsk.HeaderType == RADIO_FSK_PACKET_2BYTES_LENGTH ) )
 80395d0:	2902      	cmp	r1, #2
        SubgRf.PacketParams.Params.Gfsk.SyncWordLength = ( config->fsk.SyncWordLength ) << 3; // convert byte into bit
 80395d2:	74eb      	strb	r3, [r5, #19]
        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING ) || ( config->fsk.HeaderType == RADIO_FSK_PACKET_2BYTES_LENGTH ) )
 80395d4:	462e      	mov	r6, r5
 80395d6:	7fe3      	ldrb	r3, [r4, #31]
 80395d8:	d002      	beq.n	80395e0 <RadioSetTxGenericConfig+0x88>
 80395da:	7fa2      	ldrb	r2, [r4, #30]
 80395dc:	2a02      	cmp	r2, #2
 80395de:	d13e      	bne.n	803965e <RadioSetTxGenericConfig+0x106>
        {
            /* Supports only RADIO_FSK_CRC_2_BYTES_IBM or RADIO_FSK_CRC_2_BYTES_CCIT */
            if( ( config->fsk.CrcLength != RADIO_FSK_CRC_2_BYTES_IBM ) && ( config->fsk.CrcLength != RADIO_FSK_CRC_2_BYTES_CCIT ) &&( config->fsk.CrcLength != RADIO_FSK_CRC_OFF ) )
 80395e0:	f103 020f 	add.w	r2, r3, #15
 80395e4:	b2d2      	uxtb	r2, r2
 80395e6:	2a01      	cmp	r2, #1
 80395e8:	d902      	bls.n	80395f0 <RadioSetTxGenericConfig+0x98>
 80395ea:	2b01      	cmp	r3, #1
 80395ec:	f040 809d 	bne.w	803972a <RadioSetTxGenericConfig+0x1d2>
                return -1;
            }
            ConfigGeneric_t ConfigGeneric;
            ConfigGeneric.rtx = CONFIG_TX;
            ConfigGeneric.TxConfig = config;
            if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &TxTimeoutTimer ) )
 80395f0:	4b50      	ldr	r3, [pc, #320]	; (8039734 <RadioSetTxGenericConfig+0x1dc>)
 80395f2:	4a51      	ldr	r2, [pc, #324]	; (8039738 <RadioSetTxGenericConfig+0x1e0>)
 80395f4:	6819      	ldr	r1, [r3, #0]
            ConfigGeneric.TxConfig = config;
 80395f6:	9403      	str	r4, [sp, #12]
            ConfigGeneric.rtx = CONFIG_TX;
 80395f8:	2501      	movs	r5, #1
            if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &TxTimeoutTimer ) )
 80395fa:	a803      	add	r0, sp, #12
            ConfigGeneric.rtx = CONFIG_TX;
 80395fc:	f88d 5014 	strb.w	r5, [sp, #20]
            if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &TxTimeoutTimer ) )
 8039600:	f001 fab8 	bl	803ab74 <RFW_Init>
 8039604:	2800      	cmp	r0, #0
 8039606:	f040 8090 	bne.w	803972a <RadioSetTxGenericConfig+0x1d2>
            {
              return -1;
            }
            /* whitening off, will be processed by FW, switch off built-in radio whitening */
            SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) RADIO_FSK_DC_FREE_OFF;
 803960a:	7630      	strb	r0, [r6, #24]
            /* Crc processed by FW, switch off built-in radio Crc */
            SubgRf.PacketParams.Params.Gfsk.CrcLength = (RadioCrcTypes_t) RADIO_CRC_OFF;
 803960c:	75f5      	strb	r5, [r6, #23]
            /* length contained in Tx, but will be processed by FW after de-whitening */
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) RADIO_PACKET_FIXED_LENGTH;
 803960e:	7570      	strb	r0, [r6, #21]
          SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) config->fsk.CrcLength;
          SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) config->fsk.Whitening;
          SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) config->fsk.HeaderType;
        }

        RadioStandby( );
 8039610:	f7ff fcf8 	bl	8039004 <RadioStandby>
        RadioSetModem( MODEM_FSK );
 8039614:	2000      	movs	r0, #0
 8039616:	f7ff ff7d 	bl	8039514 <RadioSetModem>
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 803961a:	4848      	ldr	r0, [pc, #288]	; (803973c <RadioSetTxGenericConfig+0x1e4>)
 803961c:	f000 ff5c 	bl	803a4d8 <SUBGRF_SetModulationParams>
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039620:	4847      	ldr	r0, [pc, #284]	; (8039740 <RadioSetTxGenericConfig+0x1e8>)
 8039622:	f001 f8ef 	bl	803a804 <SUBGRF_SetPacketParams>
        SUBGRF_SetSyncWord( syncword );
 8039626:	a801      	add	r0, sp, #4
 8039628:	f001 f8be 	bl	803a7a8 <SUBGRF_SetSyncWord>
        SUBGRF_SetWhiteningSeed( config->fsk.whiteSeed );
 803962c:	8ba0      	ldrh	r0, [r4, #28]
 803962e:	f001 f82d 	bl	803a68c <SUBGRF_SetWhiteningSeed>
        SUBGRF_SetCrcPolynomial(config->fsk.CrcPolynomial );
 8039632:	8c20      	ldrh	r0, [r4, #32]
 8039634:	f001 f8d4 	bl	803a7e0 <SUBGRF_SetCrcPolynomial>
        break;
    default:
        break;
    }

    SubgRf.AntSwitchPaSelect = SUBGRF_SetRfTxPower( power );
 8039638:	4648      	mov	r0, r9
 803963a:	f001 f9e6 	bl	803aa0a <SUBGRF_SetRfTxPower>
 803963e:	4c3c      	ldr	r4, [pc, #240]	; (8039730 <RadioSetTxGenericConfig+0x1d8>)
 8039640:	f884 0056 	strb.w	r0, [r4, #86]	; 0x56
    RFW_SetAntSwitch( SubgRf.AntSwitchPaSelect );
 8039644:	f001 fa9e 	bl	803ab84 <RFW_SetAntSwitch>
    SubgRf.TxTimeout = timeout;
 8039648:	f8c4 8004 	str.w	r8, [r4, #4]
    return 0;
 803964c:	2000      	movs	r0, #0
}
 803964e:	b007      	add	sp, #28
 8039650:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
                syncword[i] = config->fsk.SyncWord[i];
 8039654:	69a0      	ldr	r0, [r4, #24]
 8039656:	5d40      	ldrb	r0, [r0, r5]
 8039658:	5468      	strb	r0, [r5, r1]
            for(int i = 0; i < config->fsk.SyncWordLength; i++)
 803965a:	3501      	adds	r5, #1
 803965c:	e79c      	b.n	8039598 <RadioSetTxGenericConfig+0x40>
          SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) config->fsk.CrcLength;
 803965e:	75eb      	strb	r3, [r5, #23]
          SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) config->fsk.Whitening;
 8039660:	7629      	strb	r1, [r5, #24]
          SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) config->fsk.HeaderType;
 8039662:	756a      	strb	r2, [r5, #21]
 8039664:	e7d4      	b.n	8039610 <RadioSetTxGenericConfig+0xb8>
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_LORA;
 8039666:	4e32      	ldr	r6, [pc, #200]	; (8039730 <RadioSetTxGenericConfig+0x1d8>)
 8039668:	f886 5038 	strb.w	r5, [r6, #56]	; 0x38
        SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t ) config->lora.SpreadingFactor;
 803966c:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 8039670:	f886 3050 	strb.w	r3, [r6, #80]	; 0x50
        SubgRf.ModulationParams.Params.LoRa.Bandwidth = ( RadioLoRaBandwidths_t ) config->lora.Bandwidth;
 8039674:	f894 2029 	ldrb.w	r2, [r4, #41]	; 0x29
 8039678:	f886 2051 	strb.w	r2, [r6, #81]	; 0x51
        SubgRf.ModulationParams.Params.LoRa.CodingRate = ( RadioLoRaCodingRates_t ) config->lora.Coderate;
 803967c:	f894 202a 	ldrb.w	r2, [r4, #42]	; 0x2a
 8039680:	f886 2052 	strb.w	r2, [r6, #82]	; 0x52
        switch( config->lora.LowDatarateOptimize )
 8039684:	f894 102b 	ldrb.w	r1, [r4, #43]	; 0x2b
 8039688:	2901      	cmp	r1, #1
 803968a:	d002      	beq.n	8039692 <RadioSetTxGenericConfig+0x13a>
 803968c:	2902      	cmp	r1, #2
 803968e:	d02b      	beq.n	80396e8 <RadioSetTxGenericConfig+0x190>
 8039690:	b909      	cbnz	r1, 8039696 <RadioSetTxGenericConfig+0x13e>
            SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 1;
 8039692:	f886 1053 	strb.w	r1, [r6, #83]	; 0x53
        SubgRf.PacketParams.Params.LoRa.PreambleLength = config->lora.PreambleLen;
 8039696:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 8039698:	83b3      	strh	r3, [r6, #28]
        SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t ) config->lora.LengthMode;
 803969a:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
 803969e:	77b3      	strb	r3, [r6, #30]
        SubgRf.PacketParams.Params.LoRa.CrcMode = ( RadioLoRaCrcModes_t ) config->lora.CrcMode;
 80396a0:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
 80396a4:	f886 3020 	strb.w	r3, [r6, #32]
        SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 80396a8:	2501      	movs	r5, #1
        SubgRf.PacketParams.Params.LoRa.InvertIQ = ( RadioLoRaIQModes_t ) config->lora.IqInverted;
 80396aa:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
 80396ae:	f886 3021 	strb.w	r3, [r6, #33]	; 0x21
        SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 80396b2:	73b5      	strb	r5, [r6, #14]
        RadioStandby( );
 80396b4:	f7ff fca6 	bl	8039004 <RadioStandby>
        RadioSetModem( MODEM_LORA );
 80396b8:	4628      	mov	r0, r5
 80396ba:	f7ff ff2b 	bl	8039514 <RadioSetModem>
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 80396be:	481f      	ldr	r0, [pc, #124]	; (803973c <RadioSetTxGenericConfig+0x1e4>)
 80396c0:	f000 ff0a 	bl	803a4d8 <SUBGRF_SetModulationParams>
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 80396c4:	481e      	ldr	r0, [pc, #120]	; (8039740 <RadioSetTxGenericConfig+0x1e8>)
 80396c6:	f001 f89d 	bl	803a804 <SUBGRF_SetPacketParams>
        if( SubgRf.ModulationParams.Params.LoRa.Bandwidth == LORA_BW_500 )
 80396ca:	f896 3051 	ldrb.w	r3, [r6, #81]	; 0x51
 80396ce:	2b06      	cmp	r3, #6
            SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) & ~( 1 << 2 ) );
 80396d0:	f640 0089 	movw	r0, #2185	; 0x889
        if( SubgRf.ModulationParams.Params.LoRa.Bandwidth == LORA_BW_500 )
 80396d4:	d10f      	bne.n	80396f6 <RadioSetTxGenericConfig+0x19e>
            SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) & ~( 1 << 2 ) );
 80396d6:	f000 ff6b 	bl	803a5b0 <SUBGRF_ReadRegister>
 80396da:	f000 01fb 	and.w	r1, r0, #251	; 0xfb
            SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) | ( 1 << 2 ) );
 80396de:	f640 0089 	movw	r0, #2185	; 0x889
 80396e2:	f000 fe9f 	bl	803a424 <SUBGRF_WriteRegister>
 80396e6:	e7a7      	b.n	8039638 <RadioSetTxGenericConfig+0xe0>
            if( ( config->lora.SpreadingFactor == RADIO_LORA_SF11 ) || ( config->lora.SpreadingFactor == RADIO_LORA_SF12 ) )
 80396e8:	3b0b      	subs	r3, #11
              SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 1;
 80396ea:	2b01      	cmp	r3, #1
 80396ec:	bf88      	it	hi
 80396ee:	463d      	movhi	r5, r7
 80396f0:	f886 5053 	strb.w	r5, [r6, #83]	; 0x53
 80396f4:	e7cf      	b.n	8039696 <RadioSetTxGenericConfig+0x13e>
            SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) | ( 1 << 2 ) );
 80396f6:	f000 ff5b 	bl	803a5b0 <SUBGRF_ReadRegister>
 80396fa:	f040 0104 	orr.w	r1, r0, #4
 80396fe:	b2c9      	uxtb	r1, r1
 8039700:	e7ed      	b.n	80396de <RadioSetTxGenericConfig+0x186>
        if( ( config->bpsk.BitRate == 0 ) || ( config->bpsk.BitRate > 1000 ) )
 8039702:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8039704:	3b01      	subs	r3, #1
 8039706:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 803970a:	d20e      	bcs.n	803972a <RadioSetTxGenericConfig+0x1d2>
        RadioSetModem( MODEM_BPSK );
 803970c:	4628      	mov	r0, r5
 803970e:	f7ff ff01 	bl	8039514 <RadioSetModem>
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_BPSK;
 8039712:	4807      	ldr	r0, [pc, #28]	; (8039730 <RadioSetTxGenericConfig+0x1d8>)
 8039714:	f880 5038 	strb.w	r5, [r0, #56]	; 0x38
        SubgRf.ModulationParams.Params.Bpsk.BitRate = config->bpsk.BitRate;
 8039718:	6b63      	ldr	r3, [r4, #52]	; 0x34
 803971a:	6483      	str	r3, [r0, #72]	; 0x48
        SubgRf.ModulationParams.Params.Bpsk.ModulationShaping = MOD_SHAPING_DBPSK;
 803971c:	2316      	movs	r3, #22
 803971e:	f880 304c 	strb.w	r3, [r0, #76]	; 0x4c
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8039722:	3038      	adds	r0, #56	; 0x38
 8039724:	f000 fed8 	bl	803a4d8 <SUBGRF_SetModulationParams>
        break;
 8039728:	e786      	b.n	8039638 <RadioSetTxGenericConfig+0xe0>
            return -1;
 803972a:	f04f 30ff 	mov.w	r0, #4294967295
 803972e:	e78e      	b.n	803964e <RadioSetTxGenericConfig+0xf6>
 8039730:	20006324 	.word	0x20006324
 8039734:	2000597c 	.word	0x2000597c
 8039738:	2000637c 	.word	0x2000637c
 803973c:	2000635c 	.word	0x2000635c
 8039740:	20006332 	.word	0x20006332

08039744 <RadioSetRxGenericConfig>:
{
 8039744:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uint8_t syncword[8] = {0};
 8039748:	2600      	movs	r6, #0
{
 803974a:	b086      	sub	sp, #24
 803974c:	4698      	mov	r8, r3
 803974e:	4614      	mov	r4, r2
    uint8_t syncword[8] = {0};
 8039750:	e9cd 6601 	strd	r6, r6, [sp, #4]
{
 8039754:	4607      	mov	r7, r0
 8039756:	460d      	mov	r5, r1
    RFW_DeInit( ); /* switch Off FwPacketDecoding by default */
 8039758:	f001 fa0f 	bl	803ab7a <RFW_DeInit>
        symbTimeout = 0;
 803975c:	42b4      	cmp	r4, r6
    SubgRf.RxContinuous = ( rxContinuous == 0 ) ? false : true;
 803975e:	4c77      	ldr	r4, [pc, #476]	; (803993c <RadioSetRxGenericConfig+0x1f8>)
 8039760:	bf16      	itet	ne
 8039762:	2301      	movne	r3, #1
 8039764:	4633      	moveq	r3, r6
        symbTimeout = 0;
 8039766:	46b0      	movne	r8, r6
    SubgRf.RxContinuous = ( rxContinuous == 0 ) ? false : true;
 8039768:	7063      	strb	r3, [r4, #1]
    switch( modem )
 803976a:	b137      	cbz	r7, 803977a <RadioSetRxGenericConfig+0x36>
 803976c:	2f01      	cmp	r7, #1
 803976e:	f000 8082 	beq.w	8039876 <RadioSetRxGenericConfig+0x132>
    return status;
 8039772:	2000      	movs	r0, #0
}
 8039774:	b006      	add	sp, #24
 8039776:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if( ( config->fsk.BitRate == 0 ) || ( config->fsk.PreambleLen == 0 ) )
 803977a:	68eb      	ldr	r3, [r5, #12]
 803977c:	2b00      	cmp	r3, #0
 803977e:	f000 80d9 	beq.w	8039934 <RadioSetRxGenericConfig+0x1f0>
 8039782:	692b      	ldr	r3, [r5, #16]
 8039784:	2b00      	cmp	r3, #0
 8039786:	f000 80d5 	beq.w	8039934 <RadioSetRxGenericConfig+0x1f0>
        if( config->fsk.SyncWordLength > 8 )
 803978a:	7d6b      	ldrb	r3, [r5, #21]
 803978c:	2b08      	cmp	r3, #8
 803978e:	f200 80d1 	bhi.w	8039934 <RadioSetRxGenericConfig+0x1f0>
            for(int i = 0; i < config->fsk.SyncWordLength; i++)
 8039792:	4638      	mov	r0, r7
                syncword[i] = config->fsk.SyncWord[i];
 8039794:	aa01      	add	r2, sp, #4
            for(int i = 0; i < config->fsk.SyncWordLength; i++)
 8039796:	4283      	cmp	r3, r0
 8039798:	dc62      	bgt.n	8039860 <RadioSetRxGenericConfig+0x11c>
        SUBGRF_SetStopRxTimerOnPreambleDetect( ( config->fsk.StopTimerOnPreambleDetect == 0 ) ? false : true );
 803979a:	6828      	ldr	r0, [r5, #0]
 803979c:	3800      	subs	r0, #0
 803979e:	bf18      	it	ne
 80397a0:	2001      	movne	r0, #1
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 80397a2:	2600      	movs	r6, #0
        SUBGRF_SetStopRxTimerOnPreambleDetect( ( config->fsk.StopTimerOnPreambleDetect == 0 ) ? false : true );
 80397a4:	f000 fd32 	bl	803a20c <SUBGRF_SetStopRxTimerOnPreambleDetect>
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 80397a8:	f884 6038 	strb.w	r6, [r4, #56]	; 0x38
        SubgRf.ModulationParams.Params.Gfsk.BitRate = config->fsk.BitRate;
 80397ac:	68eb      	ldr	r3, [r5, #12]
 80397ae:	63e3      	str	r3, [r4, #60]	; 0x3c
        SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = (RadioModShapings_t) config->fsk.ModulationShaping;
 80397b0:	792b      	ldrb	r3, [r5, #4]
 80397b2:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
        SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( config->fsk.Bandwidth );
 80397b6:	68a8      	ldr	r0, [r5, #8]
 80397b8:	f001 f980 	bl	803aabc <SUBGRF_GetFskBandwidthRegValue>
 80397bc:	f884 0045 	strb.w	r0, [r4, #69]	; 0x45
        SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( config->fsk.PreambleLen ) << 3 ; // convert byte into bit
 80397c0:	692b      	ldr	r3, [r5, #16]
        SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 80397c2:	73a6      	strb	r6, [r4, #14]
        SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( config->fsk.PreambleLen ) << 3 ; // convert byte into bit
 80397c4:	00db      	lsls	r3, r3, #3
 80397c6:	8223      	strh	r3, [r4, #16]
        SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = ( RadioPreambleDetection_t ) config->fsk.PreambleMinDetect;
 80397c8:	7d2b      	ldrb	r3, [r5, #20]
 80397ca:	74a3      	strb	r3, [r4, #18]
        SubgRf.PacketParams.Params.Gfsk.SyncWordLength = ( config->fsk.SyncWordLength ) << 3; // convert byte into bit
 80397cc:	7d6b      	ldrb	r3, [r5, #21]
 80397ce:	00db      	lsls	r3, r3, #3
 80397d0:	74e3      	strb	r3, [r4, #19]
        SubgRf.PacketParams.Params.Gfsk.AddrComp = ( RadioAddressComp_t ) config->fsk.AddrComp;
 80397d2:	f895 3022 	ldrb.w	r3, [r5, #34]	; 0x22
 80397d6:	7523      	strb	r3, [r4, #20]
        if( config->fsk.LengthMode == RADIO_FSK_PACKET_FIXED_LENGTH )
 80397d8:	f895 3023 	ldrb.w	r3, [r5, #35]	; 0x23
 80397dc:	2b00      	cmp	r3, #0
 80397de:	d144      	bne.n	803986a <RadioSetRxGenericConfig+0x126>
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = config->fsk.MaxPayloadLength;
 80397e0:	69ea      	ldr	r2, [r5, #28]
        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING ) || ( config->fsk.LengthMode == RADIO_FSK_PACKET_2BYTES_LENGTH ) )
 80397e2:	f895 102a 	ldrb.w	r1, [r5, #42]	; 0x2a
          SubgRf.PacketParams.Params.Gfsk.PayloadLength = 0xFF;
 80397e6:	75a2      	strb	r2, [r4, #22]
        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING ) || ( config->fsk.LengthMode == RADIO_FSK_PACKET_2BYTES_LENGTH ) )
 80397e8:	2902      	cmp	r1, #2
 80397ea:	f895 2024 	ldrb.w	r2, [r5, #36]	; 0x24
 80397ee:	d001      	beq.n	80397f4 <RadioSetRxGenericConfig+0xb0>
 80397f0:	2b02      	cmp	r3, #2
 80397f2:	d13c      	bne.n	803986e <RadioSetRxGenericConfig+0x12a>
          if( ( config->fsk.CrcLength != RADIO_FSK_CRC_2_BYTES_IBM ) && ( config->fsk.CrcLength != RADIO_FSK_CRC_2_BYTES_CCIT ) && ( config->fsk.CrcLength != RADIO_FSK_CRC_OFF ) )
 80397f4:	f102 030f 	add.w	r3, r2, #15
 80397f8:	b2db      	uxtb	r3, r3
 80397fa:	2b01      	cmp	r3, #1
 80397fc:	d902      	bls.n	8039804 <RadioSetRxGenericConfig+0xc0>
 80397fe:	2a01      	cmp	r2, #1
 8039800:	f040 8098 	bne.w	8039934 <RadioSetRxGenericConfig+0x1f0>
          ConfigGeneric.rtx = CONFIG_RX;
 8039804:	2300      	movs	r3, #0
 8039806:	f88d 3014 	strb.w	r3, [sp, #20]
          if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &RxTimeoutTimer ) )
 803980a:	4b4d      	ldr	r3, [pc, #308]	; (8039940 <RadioSetRxGenericConfig+0x1fc>)
 803980c:	4a4d      	ldr	r2, [pc, #308]	; (8039944 <RadioSetRxGenericConfig+0x200>)
 803980e:	6819      	ldr	r1, [r3, #0]
          ConfigGeneric.RxConfig = config;
 8039810:	9504      	str	r5, [sp, #16]
          if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &RxTimeoutTimer ) )
 8039812:	a803      	add	r0, sp, #12
 8039814:	f001 f9ae 	bl	803ab74 <RFW_Init>
 8039818:	2800      	cmp	r0, #0
 803981a:	f040 808b 	bne.w	8039934 <RadioSetRxGenericConfig+0x1f0>
          SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) RADIO_CRC_OFF;
 803981e:	2301      	movs	r3, #1
          SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) RADIO_FSK_DC_FREE_OFF;
 8039820:	7620      	strb	r0, [r4, #24]
          SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) RADIO_CRC_OFF;
 8039822:	75e3      	strb	r3, [r4, #23]
          SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) RADIO_PACKET_FIXED_LENGTH;
 8039824:	7560      	strb	r0, [r4, #21]
        RadioStandby( );
 8039826:	f7ff fbed 	bl	8039004 <RadioStandby>
        RadioSetModem( MODEM_FSK );
 803982a:	2000      	movs	r0, #0
 803982c:	f7ff fe72 	bl	8039514 <RadioSetModem>
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8039830:	4845      	ldr	r0, [pc, #276]	; (8039948 <RadioSetRxGenericConfig+0x204>)
 8039832:	f000 fe51 	bl	803a4d8 <SUBGRF_SetModulationParams>
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039836:	4845      	ldr	r0, [pc, #276]	; (803994c <RadioSetRxGenericConfig+0x208>)
 8039838:	f000 ffe4 	bl	803a804 <SUBGRF_SetPacketParams>
        SUBGRF_SetSyncWord( syncword );
 803983c:	a801      	add	r0, sp, #4
 803983e:	f000 ffb3 	bl	803a7a8 <SUBGRF_SetSyncWord>
        SUBGRF_SetWhiteningSeed( config->fsk.whiteSeed );
 8039842:	8c28      	ldrh	r0, [r5, #32]
 8039844:	f000 ff22 	bl	803a68c <SUBGRF_SetWhiteningSeed>
        SUBGRF_SetCrcPolynomial( config->fsk.CrcPolynomial );
 8039848:	8ce8      	ldrh	r0, [r5, #38]	; 0x26
 803984a:	f000 ffc9 	bl	803a7e0 <SUBGRF_SetCrcPolynomial>
        SubgRf.RxTimeout = ( uint32_t )( ( symbTimeout * 1000 * 8 ) / config->fsk.BitRate );
 803984e:	f44f 53fa 	mov.w	r3, #8000	; 0x1f40
 8039852:	fb03 f808 	mul.w	r8, r3, r8
 8039856:	68eb      	ldr	r3, [r5, #12]
 8039858:	fbb8 f3f3 	udiv	r3, r8, r3
        SubgRf.RxTimeout = 0xFFFF;
 803985c:	60a3      	str	r3, [r4, #8]
 803985e:	e788      	b.n	8039772 <RadioSetRxGenericConfig+0x2e>
                syncword[i] = config->fsk.SyncWord[i];
 8039860:	69a9      	ldr	r1, [r5, #24]
 8039862:	5c09      	ldrb	r1, [r1, r0]
 8039864:	5481      	strb	r1, [r0, r2]
            for(int i = 0; i < config->fsk.SyncWordLength; i++)
 8039866:	3001      	adds	r0, #1
 8039868:	e795      	b.n	8039796 <RadioSetRxGenericConfig+0x52>
          SubgRf.PacketParams.Params.Gfsk.PayloadLength = 0xFF;
 803986a:	22ff      	movs	r2, #255	; 0xff
 803986c:	e7b9      	b.n	80397e2 <RadioSetRxGenericConfig+0x9e>
          SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) config->fsk.CrcLength;
 803986e:	75e2      	strb	r2, [r4, #23]
          SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) config->fsk.Whitening;
 8039870:	7621      	strb	r1, [r4, #24]
          SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) config->fsk.LengthMode;
 8039872:	7563      	strb	r3, [r4, #21]
 8039874:	e7d7      	b.n	8039826 <RadioSetRxGenericConfig+0xe2>
        if( config->lora.PreambleLen == 0 )
 8039876:	8eab      	ldrh	r3, [r5, #52]	; 0x34
 8039878:	2b00      	cmp	r3, #0
 803987a:	d05b      	beq.n	8039934 <RadioSetRxGenericConfig+0x1f0>
        if( config->lora.LengthMode == RADIO_LORA_PACKET_FIXED_LENGTH )
 803987c:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
        SUBGRF_SetStopRxTimerOnPreambleDetect( ( config->lora.StopTimerOnPreambleDetect == 0 ) ? false : true );
 8039880:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
        if( config->lora.LengthMode == RADIO_LORA_PACKET_FIXED_LENGTH )
 8039882:	2b01      	cmp	r3, #1
            MaxPayloadLength = config->fsk.MaxPayloadLength;
 8039884:	bf0c      	ite	eq
 8039886:	7f2f      	ldrbeq	r7, [r5, #28]
            MaxPayloadLength = 0xFF;
 8039888:	27ff      	movne	r7, #255	; 0xff
        SUBGRF_SetStopRxTimerOnPreambleDetect( ( config->lora.StopTimerOnPreambleDetect == 0 ) ? false : true );
 803988a:	3800      	subs	r0, #0
 803988c:	bf18      	it	ne
 803988e:	2001      	movne	r0, #1
 8039890:	f000 fcbc 	bl	803a20c <SUBGRF_SetStopRxTimerOnPreambleDetect>
        SUBGRF_SetLoRaSymbNumTimeout( symbTimeout );
 8039894:	fa5f f088 	uxtb.w	r0, r8
 8039898:	f000 fdf0 	bl	803a47c <SUBGRF_SetLoRaSymbNumTimeout>
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_LORA;
 803989c:	2101      	movs	r1, #1
 803989e:	f884 1038 	strb.w	r1, [r4, #56]	; 0x38
        SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t ) config->lora.SpreadingFactor;
 80398a2:	f895 2030 	ldrb.w	r2, [r5, #48]	; 0x30
 80398a6:	f884 2050 	strb.w	r2, [r4, #80]	; 0x50
        SubgRf.ModulationParams.Params.LoRa.Bandwidth = ( RadioLoRaBandwidths_t ) config->lora.Bandwidth;
 80398aa:	f895 3031 	ldrb.w	r3, [r5, #49]	; 0x31
 80398ae:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
        SubgRf.ModulationParams.Params.LoRa.CodingRate = ( RadioLoRaCodingRates_t ) config->lora.Coderate;
 80398b2:	f895 3032 	ldrb.w	r3, [r5, #50]	; 0x32
 80398b6:	f884 3052 	strb.w	r3, [r4, #82]	; 0x52
        switch( config->lora.LowDatarateOptimize )
 80398ba:	f895 3033 	ldrb.w	r3, [r5, #51]	; 0x33
 80398be:	428b      	cmp	r3, r1
 80398c0:	d002      	beq.n	80398c8 <RadioSetRxGenericConfig+0x184>
 80398c2:	2b02      	cmp	r3, #2
 80398c4:	d003      	beq.n	80398ce <RadioSetRxGenericConfig+0x18a>
 80398c6:	b93b      	cbnz	r3, 80398d8 <RadioSetRxGenericConfig+0x194>
              SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0;
 80398c8:	f884 3053 	strb.w	r3, [r4, #83]	; 0x53
 80398cc:	e004      	b.n	80398d8 <RadioSetRxGenericConfig+0x194>
            if( ( config->lora.SpreadingFactor == RADIO_LORA_SF11 ) || ( config->lora.SpreadingFactor == RADIO_LORA_SF12 ) )
 80398ce:	3a0b      	subs	r2, #11
 80398d0:	2a01      	cmp	r2, #1
 80398d2:	d827      	bhi.n	8039924 <RadioSetRxGenericConfig+0x1e0>
              SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 1;
 80398d4:	f884 1053 	strb.w	r1, [r4, #83]	; 0x53
        SubgRf.PacketParams.Params.LoRa.PreambleLength = config->lora.PreambleLen;
 80398d8:	8eab      	ldrh	r3, [r5, #52]	; 0x34
 80398da:	83a3      	strh	r3, [r4, #28]
        SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t ) config->lora.LengthMode;
 80398dc:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
 80398e0:	77a3      	strb	r3, [r4, #30]
        SubgRf.PacketParams.Params.LoRa.CrcMode = ( RadioLoRaCrcModes_t ) config->lora.CrcMode;
 80398e2:	8f2b      	ldrh	r3, [r5, #56]	; 0x38
 80398e4:	8423      	strh	r3, [r4, #32]
        SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 80398e6:	2601      	movs	r6, #1
 80398e8:	73a6      	strb	r6, [r4, #14]
        SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength;
 80398ea:	77e7      	strb	r7, [r4, #31]
        RadioStandby( );
 80398ec:	f7ff fb8a 	bl	8039004 <RadioStandby>
        RadioSetModem( MODEM_LORA );
 80398f0:	4630      	mov	r0, r6
 80398f2:	f7ff fe0f 	bl	8039514 <RadioSetModem>
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 80398f6:	4814      	ldr	r0, [pc, #80]	; (8039948 <RadioSetRxGenericConfig+0x204>)
 80398f8:	f000 fdee 	bl	803a4d8 <SUBGRF_SetModulationParams>
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 80398fc:	4813      	ldr	r0, [pc, #76]	; (803994c <RadioSetRxGenericConfig+0x208>)
 80398fe:	f000 ff81 	bl	803a804 <SUBGRF_SetPacketParams>
        if( SubgRf.PacketParams.Params.LoRa.InvertIQ == LORA_IQ_INVERTED )
 8039902:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
 8039906:	42b3      	cmp	r3, r6
            SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) & ~( 1 << 2 ) );
 8039908:	f240 7036 	movw	r0, #1846	; 0x736
        if( SubgRf.PacketParams.Params.LoRa.InvertIQ == LORA_IQ_INVERTED )
 803990c:	d10c      	bne.n	8039928 <RadioSetRxGenericConfig+0x1e4>
            SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) & ~( 1 << 2 ) );
 803990e:	f000 fe4f 	bl	803a5b0 <SUBGRF_ReadRegister>
 8039912:	f000 01fb 	and.w	r1, r0, #251	; 0xfb
            SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) | ( 1 << 2 ) );
 8039916:	f240 7036 	movw	r0, #1846	; 0x736
 803991a:	f000 fd83 	bl	803a424 <SUBGRF_WriteRegister>
        SubgRf.RxTimeout = 0xFFFF;
 803991e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8039922:	e79b      	b.n	803985c <RadioSetRxGenericConfig+0x118>
              SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0;
 8039924:	2300      	movs	r3, #0
 8039926:	e7cf      	b.n	80398c8 <RadioSetRxGenericConfig+0x184>
            SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) | ( 1 << 2 ) );
 8039928:	f000 fe42 	bl	803a5b0 <SUBGRF_ReadRegister>
 803992c:	f040 0104 	orr.w	r1, r0, #4
 8039930:	b2c9      	uxtb	r1, r1
 8039932:	e7f0      	b.n	8039916 <RadioSetRxGenericConfig+0x1d2>
            return -1;
 8039934:	f04f 30ff 	mov.w	r0, #4294967295
 8039938:	e71c      	b.n	8039774 <RadioSetRxGenericConfig+0x30>
 803993a:	bf00      	nop
 803993c:	20006324 	.word	0x20006324
 8039940:	2000597c 	.word	0x2000597c
 8039944:	20006394 	.word	0x20006394
 8039948:	2000635c 	.word	0x2000635c
 803994c:	20006332 	.word	0x20006332

08039950 <RadioSetTxConfig>:
{
 8039950:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8039954:	b085      	sub	sp, #20
 8039956:	4682      	mov	sl, r0
 8039958:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 803995a:	f8bd b040 	ldrh.w	fp, [sp, #64]	; 0x40
 803995e:	f89d 7044 	ldrb.w	r7, [sp, #68]	; 0x44
 8039962:	f89d 9048 	ldrb.w	r9, [sp, #72]	; 0x48
 8039966:	9201      	str	r2, [sp, #4]
 8039968:	4688      	mov	r8, r1
 803996a:	461e      	mov	r6, r3
    RFW_DeInit(); /* ST_WORKAROUND: Switch Off FwPacketDecoding by default */
 803996c:	f001 f905 	bl	803ab7a <RFW_DeInit>
    switch( modem )
 8039970:	f1ba 0f01 	cmp.w	sl, #1
 8039974:	4c54      	ldr	r4, [pc, #336]	; (8039ac8 <RadioSetTxConfig+0x178>)
 8039976:	d051      	beq.n	8039a1c <RadioSetTxConfig+0xcc>
 8039978:	f1ba 0f03 	cmp.w	sl, #3
 803997c:	f000 8094 	beq.w	8039aa8 <RadioSetTxConfig+0x158>
 8039980:	f1ba 0f00 	cmp.w	sl, #0
 8039984:	d13e      	bne.n	8039a04 <RadioSetTxConfig+0xb4>
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_1;
 8039986:	220b      	movs	r2, #11
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8039988:	4630      	mov	r0, r6
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_1;
 803998a:	f884 2044 	strb.w	r2, [r4, #68]	; 0x44
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 803998e:	f884 a038 	strb.w	sl, [r4, #56]	; 0x38
            SubgRf.ModulationParams.Params.Gfsk.BitRate = datarate;
 8039992:	63e5      	str	r5, [r4, #60]	; 0x3c
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8039994:	f001 f892 	bl	803aabc <SUBGRF_GetFskBandwidthRegValue>
            SubgRf.ModulationParams.Params.Gfsk.Fdev = fdev;
 8039998:	9b01      	ldr	r3, [sp, #4]
 803999a:	6423      	str	r3, [r4, #64]	; 0x40
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 803999c:	ea4f 03cb 	mov.w	r3, fp, lsl #3
            if( crcOn == true )
 80399a0:	f1b9 0f00 	cmp.w	r9, #0
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 80399a4:	8223      	strh	r3, [r4, #16]
            SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS;
 80399a6:	f641 0304 	movw	r3, #6148	; 0x1804
 80399aa:	8263      	strh	r3, [r4, #18]
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 80399ac:	bf14      	ite	ne
 80399ae:	23f2      	movne	r3, #242	; 0xf2
 80399b0:	2301      	moveq	r3, #1
 80399b2:	75e3      	strb	r3, [r4, #23]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( fixLen == true ) ? RADIO_PACKET_FIXED_LENGTH : RADIO_PACKET_VARIABLE_LENGTH;
 80399b4:	f087 0701 	eor.w	r7, r7, #1
            SubgRf.PacketParams.Params.Gfsk.DcFree = RADIO_DC_FREEWHITENING;
 80399b8:	2301      	movs	r3, #1
 80399ba:	7623      	strb	r3, [r4, #24]
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 80399bc:	f884 0045 	strb.w	r0, [r4, #69]	; 0x45
            SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 80399c0:	f884 a00e 	strb.w	sl, [r4, #14]
            SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF;
 80399c4:	f884 a014 	strb.w	sl, [r4, #20]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( fixLen == true ) ? RADIO_PACKET_FIXED_LENGTH : RADIO_PACKET_VARIABLE_LENGTH;
 80399c8:	7567      	strb	r7, [r4, #21]
            RadioStandby( );
 80399ca:	f7ff fb1b 	bl	8039004 <RadioStandby>
            RadioSetModem( ( SubgRf.ModulationParams.PacketType == PACKET_TYPE_GFSK ) ? MODEM_FSK : MODEM_LORA );
 80399ce:	f894 0038 	ldrb.w	r0, [r4, #56]	; 0x38
 80399d2:	3800      	subs	r0, #0
 80399d4:	bf18      	it	ne
 80399d6:	2001      	movne	r0, #1
 80399d8:	f7ff fd9c 	bl	8039514 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 80399dc:	f104 0038 	add.w	r0, r4, #56	; 0x38
 80399e0:	f000 fd7a 	bl	803a4d8 <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 80399e4:	f104 000e 	add.w	r0, r4, #14
 80399e8:	f000 ff0c 	bl	803a804 <SUBGRF_SetPacketParams>
            SUBGRF_SetSyncWord( ( uint8_t[] ){ 0xC1, 0x94, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00 } );
 80399ec:	4a37      	ldr	r2, [pc, #220]	; (8039acc <RadioSetTxConfig+0x17c>)
 80399ee:	6810      	ldr	r0, [r2, #0]
 80399f0:	6851      	ldr	r1, [r2, #4]
 80399f2:	ab02      	add	r3, sp, #8
 80399f4:	c303      	stmia	r3!, {r0, r1}
 80399f6:	a802      	add	r0, sp, #8
 80399f8:	f000 fed6 	bl	803a7a8 <SUBGRF_SetSyncWord>
            SUBGRF_SetWhiteningSeed( 0x01FF );
 80399fc:	f240 10ff 	movw	r0, #511	; 0x1ff
 8039a00:	f000 fe44 	bl	803a68c <SUBGRF_SetWhiteningSeed>
    SubgRf.AntSwitchPaSelect = SUBGRF_SetRfTxPower( power );
 8039a04:	4640      	mov	r0, r8
 8039a06:	f001 f800 	bl	803aa0a <SUBGRF_SetRfTxPower>
 8039a0a:	f884 0056 	strb.w	r0, [r4, #86]	; 0x56
    RFW_SetAntSwitch( SubgRf.AntSwitchPaSelect ); /* ST_WORKAROUND: ?????? */
 8039a0e:	f001 f8b9 	bl	803ab84 <RFW_SetAntSwitch>
    SubgRf.TxTimeout = timeout;
 8039a12:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8039a14:	6063      	str	r3, [r4, #4]
}
 8039a16:	b005      	add	sp, #20
 8039a18:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            SubgRf.ModulationParams.Params.LoRa.Bandwidth =  Bandwidths[bandwidth];
 8039a1c:	492c      	ldr	r1, [pc, #176]	; (8039ad0 <RadioSetTxConfig+0x180>)
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_LORA;
 8039a1e:	f884 a038 	strb.w	sl, [r4, #56]	; 0x38
            SubgRf.ModulationParams.Params.LoRa.Bandwidth =  Bandwidths[bandwidth];
 8039a22:	4431      	add	r1, r6
            SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t ) datarate;
 8039a24:	b2ea      	uxtb	r2, r5
            SubgRf.ModulationParams.Params.LoRa.Bandwidth =  Bandwidths[bandwidth];
 8039a26:	7909      	ldrb	r1, [r1, #4]
 8039a28:	f884 1051 	strb.w	r1, [r4, #81]	; 0x51
            SubgRf.ModulationParams.Params.LoRa.CodingRate= ( RadioLoRaCodingRates_t )coderate;
 8039a2c:	f89d 103c 	ldrb.w	r1, [sp, #60]	; 0x3c
            SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t ) datarate;
 8039a30:	f884 2050 	strb.w	r2, [r4, #80]	; 0x50
            SubgRf.ModulationParams.Params.LoRa.CodingRate= ( RadioLoRaCodingRates_t )coderate;
 8039a34:	f884 1052 	strb.w	r1, [r4, #82]	; 0x52
            if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 8039a38:	bb56      	cbnz	r6, 8039a90 <RadioSetTxConfig+0x140>
 8039a3a:	3d0b      	subs	r5, #11
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x00;
 8039a3c:	2d01      	cmp	r5, #1
 8039a3e:	bf8c      	ite	hi
 8039a40:	2500      	movhi	r5, #0
 8039a42:	2501      	movls	r5, #1
            SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 8039a44:	2101      	movs	r1, #1
            if( ( SubgRf.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF5 ) ||
 8039a46:	3a05      	subs	r2, #5
 8039a48:	428a      	cmp	r2, r1
 8039a4a:	f884 5053 	strb.w	r5, [r4, #83]	; 0x53
            SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 8039a4e:	73a1      	strb	r1, [r4, #14]
            if( ( SubgRf.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF5 ) ||
 8039a50:	d827      	bhi.n	8039aa2 <RadioSetTxConfig+0x152>
                if( preambleLen < 12 )
 8039a52:	f1bb 0f0b 	cmp.w	fp, #11
 8039a56:	d824      	bhi.n	8039aa2 <RadioSetTxConfig+0x152>
                    SubgRf.PacketParams.Params.LoRa.PreambleLength = 12;
 8039a58:	230c      	movs	r3, #12
 8039a5a:	83a3      	strh	r3, [r4, #28]
            SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength;
 8039a5c:	4b1d      	ldr	r3, [pc, #116]	; (8039ad4 <RadioSetTxConfig+0x184>)
            SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t )fixLen;
 8039a5e:	77a7      	strb	r7, [r4, #30]
            SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength;
 8039a60:	781b      	ldrb	r3, [r3, #0]
 8039a62:	77e3      	strb	r3, [r4, #31]
            SubgRf.PacketParams.Params.LoRa.InvertIQ = ( RadioLoRaIQModes_t )iqInverted;
 8039a64:	f89d 3054 	ldrb.w	r3, [sp, #84]	; 0x54
 8039a68:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
            SubgRf.PacketParams.Params.LoRa.CrcMode = ( RadioLoRaCrcModes_t )crcOn;
 8039a6c:	f884 9020 	strb.w	r9, [r4, #32]
            RadioStandby( );
 8039a70:	f7ff fac8 	bl	8039004 <RadioStandby>
            RadioSetModem( ( SubgRf.ModulationParams.PacketType == PACKET_TYPE_GFSK ) ? MODEM_FSK : MODEM_LORA );
 8039a74:	f894 0038 	ldrb.w	r0, [r4, #56]	; 0x38
 8039a78:	3800      	subs	r0, #0
 8039a7a:	bf18      	it	ne
 8039a7c:	2001      	movne	r0, #1
 8039a7e:	f7ff fd49 	bl	8039514 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8039a82:	4815      	ldr	r0, [pc, #84]	; (8039ad8 <RadioSetTxConfig+0x188>)
 8039a84:	f000 fd28 	bl	803a4d8 <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039a88:	4814      	ldr	r0, [pc, #80]	; (8039adc <RadioSetTxConfig+0x18c>)
 8039a8a:	f000 febb 	bl	803a804 <SUBGRF_SetPacketParams>
            break;
 8039a8e:	e7b9      	b.n	8039a04 <RadioSetTxConfig+0xb4>
            if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 8039a90:	2e01      	cmp	r6, #1
 8039a92:	d104      	bne.n	8039a9e <RadioSetTxConfig+0x14e>
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x00;
 8039a94:	f1a5 030c 	sub.w	r3, r5, #12
 8039a98:	425d      	negs	r5, r3
 8039a9a:	415d      	adcs	r5, r3
 8039a9c:	e7d2      	b.n	8039a44 <RadioSetTxConfig+0xf4>
 8039a9e:	2500      	movs	r5, #0
 8039aa0:	e7d0      	b.n	8039a44 <RadioSetTxConfig+0xf4>
                    SubgRf.PacketParams.Params.LoRa.PreambleLength = preambleLen;
 8039aa2:	f8a4 b01c 	strh.w	fp, [r4, #28]
 8039aa6:	e7d9      	b.n	8039a5c <RadioSetTxConfig+0x10c>
            RadioSetModem(MODEM_SIGFOX_TX);
 8039aa8:	4650      	mov	r0, sl
 8039aaa:	f7ff fd33 	bl	8039514 <RadioSetModem>
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_BPSK;
 8039aae:	2302      	movs	r3, #2
 8039ab0:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8039ab4:	f104 0038 	add.w	r0, r4, #56	; 0x38
            SubgRf.ModulationParams.Params.Bpsk.ModulationShaping = MOD_SHAPING_DBPSK;
 8039ab8:	2316      	movs	r3, #22
            SubgRf.ModulationParams.Params.Bpsk.BitRate           = datarate;
 8039aba:	64a5      	str	r5, [r4, #72]	; 0x48
            SubgRf.ModulationParams.Params.Bpsk.ModulationShaping = MOD_SHAPING_DBPSK;
 8039abc:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8039ac0:	f000 fd0a 	bl	803a4d8 <SUBGRF_SetModulationParams>
            break;
 8039ac4:	e79e      	b.n	8039a04 <RadioSetTxConfig+0xb4>
 8039ac6:	bf00      	nop
 8039ac8:	20006324 	.word	0x20006324
 8039acc:	0803bc20 	.word	0x0803bc20
 8039ad0:	0803bbec 	.word	0x0803bbec
 8039ad4:	200035a0 	.word	0x200035a0
 8039ad8:	2000635c 	.word	0x2000635c
 8039adc:	20006332 	.word	0x20006332

08039ae0 <RadioSetRxConfig>:
{
 8039ae0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8039ae4:	b087      	sub	sp, #28
    SubgRf.RxContinuous = rxContinuous;
 8039ae6:	f8df b2d4 	ldr.w	fp, [pc, #724]	; 8039dbc <RadioSetRxConfig+0x2dc>
{
 8039aea:	9301      	str	r3, [sp, #4]
 8039aec:	4605      	mov	r5, r0
 8039aee:	f89d 3054 	ldrb.w	r3, [sp, #84]	; 0x54
 8039af2:	f89d 0050 	ldrb.w	r0, [sp, #80]	; 0x50
 8039af6:	f8bd 8048 	ldrh.w	r8, [sp, #72]	; 0x48
 8039afa:	f89d 904c 	ldrb.w	r9, [sp, #76]	; 0x4c
 8039afe:	9003      	str	r0, [sp, #12]
 8039b00:	460f      	mov	r7, r1
 8039b02:	f89d 1064 	ldrb.w	r1, [sp, #100]	; 0x64
    SubgRf.RxContinuous = rxContinuous;
 8039b06:	f88b 1001 	strb.w	r1, [fp, #1]
 8039b0a:	9102      	str	r1, [sp, #8]
{
 8039b0c:	f8bd 6044 	ldrh.w	r6, [sp, #68]	; 0x44
 8039b10:	9300      	str	r3, [sp, #0]
 8039b12:	4614      	mov	r4, r2
    RFW_DeInit(); /* ST_WORKAROUND: Switch Off FwPacketDecoding by default */
 8039b14:	f001 f831 	bl	803ab7a <RFW_DeInit>
        symbTimeout = 0;
 8039b18:	9902      	ldr	r1, [sp, #8]
        MaxPayloadLength = 0xFF;
 8039b1a:	9803      	ldr	r0, [sp, #12]
        symbTimeout = 0;
 8039b1c:	2900      	cmp	r1, #0
 8039b1e:	bf18      	it	ne
 8039b20:	f04f 0800 	movne.w	r8, #0
    if( fixLen == true )
 8039b24:	499f      	ldr	r1, [pc, #636]	; (8039da4 <RadioSetRxConfig+0x2c4>)
        MaxPayloadLength = 0xFF;
 8039b26:	f1b9 0f00 	cmp.w	r9, #0
 8039b2a:	bf08      	it	eq
 8039b2c:	20ff      	moveq	r0, #255	; 0xff
    switch( modem )
 8039b2e:	2d01      	cmp	r5, #1
 8039b30:	46da      	mov	sl, fp
 8039b32:	7008      	strb	r0, [r1, #0]
 8039b34:	f000 80cc 	beq.w	8039cd0 <RadioSetRxConfig+0x1f0>
 8039b38:	2d04      	cmp	r5, #4
 8039b3a:	d04c      	beq.n	8039bd6 <RadioSetRxConfig+0xf6>
 8039b3c:	2d00      	cmp	r5, #0
 8039b3e:	f040 80c4 	bne.w	8039cca <RadioSetRxConfig+0x1ea>
            SUBGRF_SetStopRxTimerOnPreambleDetect( false );
 8039b42:	4628      	mov	r0, r5
 8039b44:	f000 fb62 	bl	803a20c <SUBGRF_SetStopRxTimerOnPreambleDetect>
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_1;
 8039b48:	220b      	movs	r2, #11
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8039b4a:	4638      	mov	r0, r7
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_1;
 8039b4c:	f88b 2044 	strb.w	r2, [fp, #68]	; 0x44
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 8039b50:	f88b 5038 	strb.w	r5, [fp, #56]	; 0x38
            SubgRf.ModulationParams.Params.Gfsk.BitRate = datarate;
 8039b54:	f8cb 403c 	str.w	r4, [fp, #60]	; 0x3c
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8039b58:	f000 ffb0 	bl	803aabc <SUBGRF_GetFskBandwidthRegValue>
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 8039b5c:	9b00      	ldr	r3, [sp, #0]
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength;
 8039b5e:	4991      	ldr	r1, [pc, #580]	; (8039da4 <RadioSetRxConfig+0x2c4>)
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8039b60:	f88b 0045 	strb.w	r0, [fp, #69]	; 0x45
            SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS;
 8039b64:	f641 0204 	movw	r2, #6148	; 0x1804
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 8039b68:	2b00      	cmp	r3, #0
            SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS;
 8039b6a:	f8ab 2012 	strh.w	r2, [fp, #18]
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength;
 8039b6e:	780a      	ldrb	r2, [r1, #0]
 8039b70:	f88b 2016 	strb.w	r2, [fp, #22]
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 8039b74:	bf14      	ite	ne
 8039b76:	22f2      	movne	r2, #242	; 0xf2
 8039b78:	2201      	moveq	r2, #1
 8039b7a:	f88b 2017 	strb.w	r2, [fp, #23]
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 8039b7e:	00f6      	lsls	r6, r6, #3
            SubgRf.PacketParams.Params.Gfsk.DcFree = RADIO_DC_FREEWHITENING;
 8039b80:	2201      	movs	r2, #1
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( fixLen == true ) ? RADIO_PACKET_FIXED_LENGTH : RADIO_PACKET_VARIABLE_LENGTH;
 8039b82:	f089 0901 	eor.w	r9, r9, #1
            SubgRf.PacketParams.Params.Gfsk.DcFree = RADIO_DC_FREEWHITENING;
 8039b86:	f88b 2018 	strb.w	r2, [fp, #24]
            SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 8039b8a:	f88b 500e 	strb.w	r5, [fp, #14]
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 8039b8e:	f8ab 6010 	strh.w	r6, [fp, #16]
            SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF;
 8039b92:	f88b 5014 	strb.w	r5, [fp, #20]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( fixLen == true ) ? RADIO_PACKET_FIXED_LENGTH : RADIO_PACKET_VARIABLE_LENGTH;
 8039b96:	f88b 9015 	strb.w	r9, [fp, #21]
            RadioStandby( );
 8039b9a:	f7ff fa33 	bl	8039004 <RadioStandby>
            RadioSetModem( ( SubgRf.ModulationParams.PacketType == PACKET_TYPE_GFSK ) ? MODEM_FSK : MODEM_LORA );
 8039b9e:	f89b 0038 	ldrb.w	r0, [fp, #56]	; 0x38
 8039ba2:	3800      	subs	r0, #0
 8039ba4:	bf18      	it	ne
 8039ba6:	2001      	movne	r0, #1
 8039ba8:	f7ff fcb4 	bl	8039514 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8039bac:	f10b 0038 	add.w	r0, fp, #56	; 0x38
 8039bb0:	f000 fc92 	bl	803a4d8 <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039bb4:	f10b 000e 	add.w	r0, fp, #14
 8039bb8:	f000 fe24 	bl	803a804 <SUBGRF_SetPacketParams>
            SUBGRF_SetSyncWord( ( uint8_t[] ){ 0xC1, 0x94, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00 } );
 8039bbc:	497a      	ldr	r1, [pc, #488]	; (8039da8 <RadioSetRxConfig+0x2c8>)
 8039bbe:	6808      	ldr	r0, [r1, #0]
 8039bc0:	6849      	ldr	r1, [r1, #4]
 8039bc2:	aa04      	add	r2, sp, #16
 8039bc4:	c203      	stmia	r2!, {r0, r1}
 8039bc6:	a804      	add	r0, sp, #16
 8039bc8:	f000 fdee 	bl	803a7a8 <SUBGRF_SetSyncWord>
            SUBGRF_SetWhiteningSeed( 0x01FF );
 8039bcc:	f240 10ff 	movw	r0, #511	; 0x1ff
 8039bd0:	f000 fd5c 	bl	803a68c <SUBGRF_SetWhiteningSeed>
 8039bd4:	e071      	b.n	8039cba <RadioSetRxConfig+0x1da>
            SUBGRF_SetStopRxTimerOnPreambleDetect( true );
 8039bd6:	2001      	movs	r0, #1
 8039bd8:	f000 fb18 	bl	803a20c <SUBGRF_SetStopRxTimerOnPreambleDetect>
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_05;
 8039bdc:	2209      	movs	r2, #9
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 8039bde:	f04f 0900 	mov.w	r9, #0
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_05;
 8039be2:	f88b 2044 	strb.w	r2, [fp, #68]	; 0x44
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8039be6:	4638      	mov	r0, r7
            SubgRf.ModulationParams.Params.Gfsk.Fdev = 800;
 8039be8:	f44f 7248 	mov.w	r2, #800	; 0x320
 8039bec:	f8cb 2040 	str.w	r2, [fp, #64]	; 0x40
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 8039bf0:	f88b 9038 	strb.w	r9, [fp, #56]	; 0x38
            SubgRf.ModulationParams.Params.Gfsk.BitRate = datarate;
 8039bf4:	f8cb 403c 	str.w	r4, [fp, #60]	; 0x3c
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8039bf8:	f000 ff60 	bl	803aabc <SUBGRF_GetFskBandwidthRegValue>
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength;
 8039bfc:	4969      	ldr	r1, [pc, #420]	; (8039da4 <RadioSetRxConfig+0x2c4>)
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8039bfe:	f88b 0045 	strb.w	r0, [fp, #69]	; 0x45
            SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_OFF;
 8039c02:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8039c06:	f8ab 2012 	strh.w	r2, [fp, #18]
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength;
 8039c0a:	780a      	ldrb	r2, [r1, #0]
 8039c0c:	f88b 2016 	strb.w	r2, [fp, #22]
            RadioSetModem( MODEM_SIGFOX_RX );
 8039c10:	4628      	mov	r0, r5
            SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 8039c12:	2201      	movs	r2, #1
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 8039c14:	00f6      	lsls	r6, r6, #3
            SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 8039c16:	f88b 2017 	strb.w	r2, [fp, #23]
            SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 8039c1a:	f88b 900e 	strb.w	r9, [fp, #14]
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 8039c1e:	f8ab 6010 	strh.w	r6, [fp, #16]
            SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF;
 8039c22:	f8ab 9014 	strh.w	r9, [fp, #20]
            SubgRf.PacketParams.Params.Gfsk.DcFree = RADIO_DC_FREE_OFF;
 8039c26:	f88b 9018 	strb.w	r9, [fp, #24]
            RadioSetModem( MODEM_SIGFOX_RX );
 8039c2a:	f7ff fc73 	bl	8039514 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8039c2e:	f10b 0038 	add.w	r0, fp, #56	; 0x38
 8039c32:	f000 fc51 	bl	803a4d8 <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039c36:	f10b 000e 	add.w	r0, fp, #14
 8039c3a:	f000 fde3 	bl	803a804 <SUBGRF_SetPacketParams>
            SUBGRF_SetSyncWord( ( uint8_t[] ){0xB2, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } );
 8039c3e:	495b      	ldr	r1, [pc, #364]	; (8039dac <RadioSetRxConfig+0x2cc>)
 8039c40:	6808      	ldr	r0, [r1, #0]
 8039c42:	6849      	ldr	r1, [r1, #4]
 8039c44:	aa04      	add	r2, sp, #16
 8039c46:	c203      	stmia	r2!, {r0, r1}
 8039c48:	a804      	add	r0, sp, #16
 8039c4a:	f000 fdad 	bl	803a7a8 <SUBGRF_SetSyncWord>
            SUBGRF_SetWhiteningSeed( 0x01FF );
 8039c4e:	f240 10ff 	movw	r0, #511	; 0x1ff
 8039c52:	f000 fd1b 	bl	803a68c <SUBGRF_SetWhiteningSeed>
    return SUBGRF_ReadRegister(addr);
 8039c56:	f640 00b8 	movw	r0, #2232	; 0x8b8
 8039c5a:	f000 fca9 	bl	803a5b0 <SUBGRF_ReadRegister>
    SUBGRF_WriteRegister(addr, data );
 8039c5e:	f000 01ef 	and.w	r1, r0, #239	; 0xef
 8039c62:	f640 00b8 	movw	r0, #2232	; 0x8b8
 8039c66:	f000 fbdd 	bl	803a424 <SUBGRF_WriteRegister>
 8039c6a:	4629      	mov	r1, r5
 8039c6c:	f640 00b9 	movw	r0, #2233	; 0x8b9
 8039c70:	f000 fbd8 	bl	803a424 <SUBGRF_WriteRegister>
    return SUBGRF_ReadRegister(addr);
 8039c74:	f640 009b 	movw	r0, #2203	; 0x89b
 8039c78:	f000 fc9a 	bl	803a5b0 <SUBGRF_ReadRegister>
            RadioWrite(0x89b, (modReg| (0x1<<3) ) );
 8039c7c:	f000 01e3 	and.w	r1, r0, #227	; 0xe3
    SUBGRF_WriteRegister(addr, data );
 8039c80:	f041 0108 	orr.w	r1, r1, #8
 8039c84:	f640 009b 	movw	r0, #2203	; 0x89b
 8039c88:	f000 fbcc 	bl	803a424 <SUBGRF_WriteRegister>
    return SUBGRF_ReadRegister(addr);
 8039c8c:	f240 60d1 	movw	r0, #1745	; 0x6d1
 8039c90:	f000 fc8e 	bl	803a5b0 <SUBGRF_ReadRegister>
            RadioWrite(0x6d1, (modReg| (0x3<<3) ));
 8039c94:	f040 0118 	orr.w	r1, r0, #24
    SUBGRF_WriteRegister(addr, data );
 8039c98:	b2c9      	uxtb	r1, r1
 8039c9a:	f240 60d1 	movw	r0, #1745	; 0x6d1
 8039c9e:	f000 fbc1 	bl	803a424 <SUBGRF_WriteRegister>
    return SUBGRF_ReadRegister(addr);
 8039ca2:	f240 60ac 	movw	r0, #1708	; 0x6ac
 8039ca6:	f000 fc83 	bl	803a5b0 <SUBGRF_ReadRegister>
            RadioWrite(0x6ac, (modReg| (0x5<<4) ));
 8039caa:	f000 018f 	and.w	r1, r0, #143	; 0x8f
    SUBGRF_WriteRegister(addr, data );
 8039cae:	f041 0150 	orr.w	r1, r1, #80	; 0x50
 8039cb2:	f240 60ac 	movw	r0, #1708	; 0x6ac
 8039cb6:	f000 fbb5 	bl	803a424 <SUBGRF_WriteRegister>
            SubgRf.RxTimeout = ( uint32_t )(( symbTimeout * 8 * 1000 ) /datarate);
 8039cba:	f44f 52fa 	mov.w	r2, #8000	; 0x1f40
 8039cbe:	fb02 f808 	mul.w	r8, r2, r8
 8039cc2:	fbb8 f4f4 	udiv	r4, r8, r4
 8039cc6:	f8cb 4008 	str.w	r4, [fp, #8]
}
 8039cca:	b007      	add	sp, #28
 8039ccc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            SUBGRF_SetStopRxTimerOnPreambleDetect( false );
 8039cd0:	2000      	movs	r0, #0
 8039cd2:	f000 fa9b 	bl	803a20c <SUBGRF_SetStopRxTimerOnPreambleDetect>
            SubgRf.ModulationParams.Params.LoRa.Bandwidth = Bandwidths[bandwidth];
 8039cd6:	4936      	ldr	r1, [pc, #216]	; (8039db0 <RadioSetRxConfig+0x2d0>)
            SubgRf.ModulationParams.Params.LoRa.CodingRate = ( RadioLoRaCodingRates_t )coderate;
 8039cd8:	9a01      	ldr	r2, [sp, #4]
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_LORA;
 8039cda:	f88b 5038 	strb.w	r5, [fp, #56]	; 0x38
            SubgRf.ModulationParams.Params.LoRa.Bandwidth = Bandwidths[bandwidth];
 8039cde:	4439      	add	r1, r7
            SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t )datarate;
 8039ce0:	b2e3      	uxtb	r3, r4
            SubgRf.ModulationParams.Params.LoRa.Bandwidth = Bandwidths[bandwidth];
 8039ce2:	7909      	ldrb	r1, [r1, #4]
            SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t )datarate;
 8039ce4:	f88b 3050 	strb.w	r3, [fp, #80]	; 0x50
            SubgRf.ModulationParams.Params.LoRa.Bandwidth = Bandwidths[bandwidth];
 8039ce8:	f88b 1051 	strb.w	r1, [fp, #81]	; 0x51
            SubgRf.ModulationParams.Params.LoRa.CodingRate = ( RadioLoRaCodingRates_t )coderate;
 8039cec:	f88b 2052 	strb.w	r2, [fp, #82]	; 0x52
            if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 8039cf0:	2f00      	cmp	r7, #0
 8039cf2:	d144      	bne.n	8039d7e <RadioSetRxConfig+0x29e>
 8039cf4:	3c0b      	subs	r4, #11
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x00;
 8039cf6:	2c01      	cmp	r4, #1
 8039cf8:	bf8c      	ite	hi
 8039cfa:	2400      	movhi	r4, #0
 8039cfc:	2401      	movls	r4, #1
            SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 8039cfe:	2101      	movs	r1, #1
            if( ( SubgRf.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF5 ) ||
 8039d00:	3b05      	subs	r3, #5
 8039d02:	428b      	cmp	r3, r1
 8039d04:	f88a 4053 	strb.w	r4, [sl, #83]	; 0x53
            SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 8039d08:	f88a 100e 	strb.w	r1, [sl, #14]
            if( ( SubgRf.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF5 ) ||
 8039d0c:	d840      	bhi.n	8039d90 <RadioSetRxConfig+0x2b0>
                if( preambleLen < 12 )
 8039d0e:	2e0b      	cmp	r6, #11
 8039d10:	d83e      	bhi.n	8039d90 <RadioSetRxConfig+0x2b0>
                    SubgRf.PacketParams.Params.LoRa.PreambleLength = 12;
 8039d12:	230c      	movs	r3, #12
 8039d14:	f8aa 301c 	strh.w	r3, [sl, #28]
            SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength;
 8039d18:	4b22      	ldr	r3, [pc, #136]	; (8039da4 <RadioSetRxConfig+0x2c4>)
            SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t )fixLen;
 8039d1a:	f88a 901e 	strb.w	r9, [sl, #30]
            SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength;
 8039d1e:	781b      	ldrb	r3, [r3, #0]
 8039d20:	f88a 301f 	strb.w	r3, [sl, #31]
            SubgRf.PacketParams.Params.LoRa.CrcMode = ( RadioLoRaCrcModes_t )crcOn;
 8039d24:	9b00      	ldr	r3, [sp, #0]
 8039d26:	f88a 3020 	strb.w	r3, [sl, #32]
            SubgRf.PacketParams.Params.LoRa.InvertIQ = ( RadioLoRaIQModes_t )iqInverted;
 8039d2a:	f89d 3060 	ldrb.w	r3, [sp, #96]	; 0x60
 8039d2e:	f88a 3021 	strb.w	r3, [sl, #33]	; 0x21
            RadioStandby( );
 8039d32:	f7ff f967 	bl	8039004 <RadioStandby>
            RadioSetModem( ( SubgRf.ModulationParams.PacketType == PACKET_TYPE_GFSK ) ? MODEM_FSK : MODEM_LORA );
 8039d36:	f89a 0038 	ldrb.w	r0, [sl, #56]	; 0x38
 8039d3a:	3800      	subs	r0, #0
 8039d3c:	bf18      	it	ne
 8039d3e:	2001      	movne	r0, #1
 8039d40:	f7ff fbe8 	bl	8039514 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8039d44:	481b      	ldr	r0, [pc, #108]	; (8039db4 <RadioSetRxConfig+0x2d4>)
 8039d46:	f000 fbc7 	bl	803a4d8 <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039d4a:	481b      	ldr	r0, [pc, #108]	; (8039db8 <RadioSetRxConfig+0x2d8>)
 8039d4c:	f000 fd5a 	bl	803a804 <SUBGRF_SetPacketParams>
            SUBGRF_SetLoRaSymbNumTimeout( symbTimeout );
 8039d50:	fa5f f088 	uxtb.w	r0, r8
 8039d54:	f000 fb92 	bl	803a47c <SUBGRF_SetLoRaSymbNumTimeout>
            if( SubgRf.PacketParams.Params.LoRa.InvertIQ == LORA_IQ_INVERTED )
 8039d58:	f89a 3021 	ldrb.w	r3, [sl, #33]	; 0x21
 8039d5c:	2b01      	cmp	r3, #1
                SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) & ~( 1 << 2 ) );
 8039d5e:	f240 7036 	movw	r0, #1846	; 0x736
            if( SubgRf.PacketParams.Params.LoRa.InvertIQ == LORA_IQ_INVERTED )
 8039d62:	d118      	bne.n	8039d96 <RadioSetRxConfig+0x2b6>
                SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) & ~( 1 << 2 ) );
 8039d64:	f000 fc24 	bl	803a5b0 <SUBGRF_ReadRegister>
 8039d68:	f000 01fb 	and.w	r1, r0, #251	; 0xfb
                SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) | ( 1 << 2 ) );
 8039d6c:	f240 7036 	movw	r0, #1846	; 0x736
 8039d70:	f000 fb58 	bl	803a424 <SUBGRF_WriteRegister>
            SubgRf.RxTimeout = 0xFFFF;
 8039d74:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8039d78:	f8ca 3008 	str.w	r3, [sl, #8]
}
 8039d7c:	e7a5      	b.n	8039cca <RadioSetRxConfig+0x1ea>
            if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 8039d7e:	2f01      	cmp	r7, #1
 8039d80:	d104      	bne.n	8039d8c <RadioSetRxConfig+0x2ac>
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x00;
 8039d82:	f1a4 020c 	sub.w	r2, r4, #12
 8039d86:	4254      	negs	r4, r2
 8039d88:	4154      	adcs	r4, r2
 8039d8a:	e7b8      	b.n	8039cfe <RadioSetRxConfig+0x21e>
 8039d8c:	2400      	movs	r4, #0
 8039d8e:	e7b6      	b.n	8039cfe <RadioSetRxConfig+0x21e>
                    SubgRf.PacketParams.Params.LoRa.PreambleLength = preambleLen;
 8039d90:	f8aa 601c 	strh.w	r6, [sl, #28]
 8039d94:	e7c0      	b.n	8039d18 <RadioSetRxConfig+0x238>
                SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) | ( 1 << 2 ) );
 8039d96:	f000 fc0b 	bl	803a5b0 <SUBGRF_ReadRegister>
 8039d9a:	f040 0104 	orr.w	r1, r0, #4
 8039d9e:	b2c9      	uxtb	r1, r1
 8039da0:	e7e4      	b.n	8039d6c <RadioSetRxConfig+0x28c>
 8039da2:	bf00      	nop
 8039da4:	200035a0 	.word	0x200035a0
 8039da8:	0803bc20 	.word	0x0803bc20
 8039dac:	0803bc28 	.word	0x0803bc28
 8039db0:	0803bbec 	.word	0x0803bbec
 8039db4:	2000635c 	.word	0x2000635c
 8039db8:	20006332 	.word	0x20006332
 8039dbc:	20006324 	.word	0x20006324

08039dc0 <RadioRandom>:
{
 8039dc0:	b508      	push	{r3, lr}
    RadioSetModem( MODEM_LORA );
 8039dc2:	2001      	movs	r0, #1
 8039dc4:	f7ff fba6 	bl	8039514 <RadioSetModem>
    SUBGRF_SetDioIrqParams( IRQ_RADIO_NONE, IRQ_RADIO_NONE, IRQ_RADIO_NONE, IRQ_RADIO_NONE );
 8039dc8:	2300      	movs	r3, #0
 8039dca:	461a      	mov	r2, r3
 8039dcc:	4619      	mov	r1, r3
 8039dce:	4618      	mov	r0, r3
 8039dd0:	f000 fa8c 	bl	803a2ec <SUBGRF_SetDioIrqParams>
}
 8039dd4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    rnd = SUBGRF_GetRandom();
 8039dd8:	f000 bd86 	b.w	803a8e8 <SUBGRF_GetRandom>

08039ddc <RadioIsChannelFree>:
{
 8039ddc:	b5f0      	push	{r4, r5, r6, r7, lr}
 8039dde:	b08b      	sub	sp, #44	; 0x2c
 8039de0:	460d      	mov	r5, r1
 8039de2:	4604      	mov	r4, r0
 8039de4:	4617      	mov	r7, r2
 8039de6:	461e      	mov	r6, r3
    RadioStandby( );
 8039de8:	f7ff f90c 	bl	8039004 <RadioStandby>
    RadioSetModem( MODEM_FSK );
 8039dec:	2000      	movs	r0, #0
 8039dee:	f7ff fb91 	bl	8039514 <RadioSetModem>
    SUBGRF_SetRfFrequency( freq );
 8039df2:	4620      	mov	r0, r4
 8039df4:	f000 faa4 	bl	803a340 <SUBGRF_SetRfFrequency>
    RadioSetRxConfig( MODEM_FSK, rxBandwidth, 600, 0, rxBandwidth, 3, 0, false,
 8039df8:	2400      	movs	r4, #0
 8039dfa:	2301      	movs	r3, #1
 8039dfc:	e9cd 4308 	strd	r4, r3, [sp, #32]
 8039e00:	2303      	movs	r3, #3
 8039e02:	f44f 7216 	mov.w	r2, #600	; 0x258
 8039e06:	4629      	mov	r1, r5
 8039e08:	4620      	mov	r0, r4
 8039e0a:	e9cd 4406 	strd	r4, r4, [sp, #24]
 8039e0e:	e9cd 4404 	strd	r4, r4, [sp, #16]
 8039e12:	e9cd 4402 	strd	r4, r4, [sp, #8]
 8039e16:	e9cd 5300 	strd	r5, r3, [sp]
 8039e1a:	4623      	mov	r3, r4
 8039e1c:	f7ff fe60 	bl	8039ae0 <RadioSetRxConfig>
    RadioRx( 0 );
 8039e20:	4620      	mov	r0, r4
 8039e22:	f7ff fb2b 	bl	803947c <RadioRx>
    RADIO_DELAY_MS( RadioGetWakeupTime( ) );
 8039e26:	f7ff fa27 	bl	8039278 <RadioGetWakeupTime>
 8039e2a:	f7f2 fc0d 	bl	802c648 <HAL_Delay>
    carrierSenseTime = TimerGetCurrentTime( );
 8039e2e:	f001 fa41 	bl	803b2b4 <UTIL_TIMER_GetCurrentTime>
 8039e32:	4604      	mov	r4, r0
    while( TimerGetElapsedTime( carrierSenseTime ) < maxCarrierSenseTime )
 8039e34:	4620      	mov	r0, r4
 8039e36:	f001 fa47 	bl	803b2c8 <UTIL_TIMER_GetElapsedTime>
 8039e3a:	42b0      	cmp	r0, r6
 8039e3c:	d305      	bcc.n	8039e4a <RadioIsChannelFree+0x6e>
    bool status = true;
 8039e3e:	2401      	movs	r4, #1
    RadioStandby( );
 8039e40:	f7ff f8e0 	bl	8039004 <RadioStandby>
}
 8039e44:	4620      	mov	r0, r4
 8039e46:	b00b      	add	sp, #44	; 0x2c
 8039e48:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return SUBGRF_GetRssiInst( );
 8039e4a:	f000 faa4 	bl	803a396 <SUBGRF_GetRssiInst>
        if( rssi > rssiThresh )
 8039e4e:	b200      	sxth	r0, r0
 8039e50:	4287      	cmp	r7, r0
 8039e52:	daef      	bge.n	8039e34 <RadioIsChannelFree+0x58>
            status = false;
 8039e54:	2400      	movs	r4, #0
 8039e56:	e7f3      	b.n	8039e40 <RadioIsChannelFree+0x64>

08039e58 <RadioInit>:
    RadioEvents = events;
 8039e58:	4b1e      	ldr	r3, [pc, #120]	; (8039ed4 <RadioInit+0x7c>)
{
 8039e5a:	b573      	push	{r0, r1, r4, r5, r6, lr}
    RadioEvents = events;
 8039e5c:	6018      	str	r0, [r3, #0]
    SubgRf.RxContinuous = false;
 8039e5e:	4b1e      	ldr	r3, [pc, #120]	; (8039ed8 <RadioInit+0x80>)
    SUBGRF_Init( RadioOnDioIrq );
 8039e60:	481e      	ldr	r0, [pc, #120]	; (8039edc <RadioInit+0x84>)
    TimerInit( &TxTimeoutTimer, RadioOnTxTimeoutIrq );
 8039e62:	4e1f      	ldr	r6, [pc, #124]	; (8039ee0 <RadioInit+0x88>)
    TimerInit( &RxTimeoutTimer, RadioOnRxTimeoutIrq );
 8039e64:	4d1f      	ldr	r5, [pc, #124]	; (8039ee4 <RadioInit+0x8c>)
    SubgRf.RxContinuous = false;
 8039e66:	2400      	movs	r4, #0
    SubgRf.RxTimeout = 0;
 8039e68:	e9c3 4401 	strd	r4, r4, [r3, #4]
    SubgRf.RxContinuous = false;
 8039e6c:	705c      	strb	r4, [r3, #1]
    SUBGRF_Init( RadioOnDioIrq );
 8039e6e:	f000 fbc3 	bl	803a5f8 <SUBGRF_Init>
    RadioSetPublicNetwork( false );
 8039e72:	4620      	mov	r0, r4
 8039e74:	f7ff fb30 	bl	80394d8 <RadioSetPublicNetwork>
    SUBGRF_SetRegulatorMode(  );
 8039e78:	f000 f9d4 	bl	803a224 <SUBGRF_SetRegulatorMode>
    SUBGRF_SetBufferBaseAddress( 0x00, 0x00 );
 8039e7c:	4621      	mov	r1, r4
 8039e7e:	4620      	mov	r0, r4
 8039e80:	f000 fa7c 	bl	803a37c <SUBGRF_SetBufferBaseAddress>
    SUBGRF_SetTxParams(RFO_LP, 0, RADIO_RAMP_200_US);
 8039e84:	4621      	mov	r1, r4
 8039e86:	2204      	movs	r2, #4
 8039e88:	2001      	movs	r0, #1
 8039e8a:	f000 fc1b 	bl	803a6c4 <SUBGRF_SetTxParams>
    SUBGRF_SetDioIrqParams( IRQ_RADIO_ALL, IRQ_RADIO_ALL, IRQ_RADIO_NONE, IRQ_RADIO_NONE );
 8039e8e:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8039e92:	4623      	mov	r3, r4
 8039e94:	4622      	mov	r2, r4
 8039e96:	4608      	mov	r0, r1
 8039e98:	f000 fa28 	bl	803a2ec <SUBGRF_SetDioIrqParams>
    RadioSleep();
 8039e9c:	f7ff fa2c 	bl	80392f8 <RadioSleep>
    TimerInit( &TxTimeoutTimer, RadioOnTxTimeoutIrq );
 8039ea0:	4622      	mov	r2, r4
 8039ea2:	4b11      	ldr	r3, [pc, #68]	; (8039ee8 <RadioInit+0x90>)
 8039ea4:	9400      	str	r4, [sp, #0]
 8039ea6:	f04f 31ff 	mov.w	r1, #4294967295
 8039eaa:	4630      	mov	r0, r6
 8039eac:	f001 f9e8 	bl	803b280 <UTIL_TIMER_Create>
    TimerInit( &RxTimeoutTimer, RadioOnRxTimeoutIrq );
 8039eb0:	4b0e      	ldr	r3, [pc, #56]	; (8039eec <RadioInit+0x94>)
 8039eb2:	9400      	str	r4, [sp, #0]
 8039eb4:	4622      	mov	r2, r4
 8039eb6:	f04f 31ff 	mov.w	r1, #4294967295
 8039eba:	4628      	mov	r0, r5
 8039ebc:	f001 f9e0 	bl	803b280 <UTIL_TIMER_Create>
    TimerStop( &TxTimeoutTimer );
 8039ec0:	4630      	mov	r0, r6
 8039ec2:	f001 fa3b 	bl	803b33c <UTIL_TIMER_Stop>
    TimerStop( &RxTimeoutTimer );
 8039ec6:	4628      	mov	r0, r5
}
 8039ec8:	b002      	add	sp, #8
 8039eca:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    TimerStop( &RxTimeoutTimer );
 8039ece:	f001 ba35 	b.w	803b33c <UTIL_TIMER_Stop>
 8039ed2:	bf00      	nop
 8039ed4:	2000597c 	.word	0x2000597c
 8039ed8:	20006324 	.word	0x20006324
 8039edc:	08039269 	.word	0x08039269
 8039ee0:	2000637c 	.word	0x2000637c
 8039ee4:	20006394 	.word	0x20006394
 8039ee8:	08038f9d 	.word	0x08038f9d
 8039eec:	08038fb1 	.word	0x08038fb1

08039ef0 <RadioSend>:
{
 8039ef0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    SUBGRF_SetDioIrqParams( IRQ_TX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_TX_DBG,
 8039ef2:	2300      	movs	r3, #0
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_TX);
 8039ef4:	4d66      	ldr	r5, [pc, #408]	; (803a090 <RadioSend+0x1a0>)
{
 8039ef6:	460c      	mov	r4, r1
    SUBGRF_SetDioIrqParams( IRQ_TX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_TX_DBG,
 8039ef8:	f240 2101 	movw	r1, #513	; 0x201
 8039efc:	461a      	mov	r2, r3
{
 8039efe:	4606      	mov	r6, r0
    SUBGRF_SetDioIrqParams( IRQ_TX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_TX_DBG,
 8039f00:	4608      	mov	r0, r1
 8039f02:	f000 f9f3 	bl	803a2ec <SUBGRF_SetDioIrqParams>
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_TX);
 8039f06:	f895 0056 	ldrb.w	r0, [r5, #86]	; 0x56
 8039f0a:	2101      	movs	r1, #1
 8039f0c:	f000 fd67 	bl	803a9de <SUBGRF_SetSwitch>
    if((SubgRf.Modem==MODEM_LORA) && (SubgRf.ModulationParams.Params.LoRa.Bandwidth == LORA_BW_500 ))
 8039f10:	782b      	ldrb	r3, [r5, #0]
 8039f12:	2b01      	cmp	r3, #1
        SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) & ~( 1 << 2 ) );
 8039f14:	f640 0089 	movw	r0, #2185	; 0x889
    if((SubgRf.Modem==MODEM_LORA) && (SubgRf.ModulationParams.Params.LoRa.Bandwidth == LORA_BW_500 ))
 8039f18:	d112      	bne.n	8039f40 <RadioSend+0x50>
 8039f1a:	f895 3051 	ldrb.w	r3, [r5, #81]	; 0x51
 8039f1e:	2b06      	cmp	r3, #6
 8039f20:	d10e      	bne.n	8039f40 <RadioSend+0x50>
        SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) & ~( 1 << 2 ) );
 8039f22:	f000 fb45 	bl	803a5b0 <SUBGRF_ReadRegister>
 8039f26:	f000 01fb 	and.w	r1, r0, #251	; 0xfb
        SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) | ( 1 << 2 ) );
 8039f2a:	f640 0089 	movw	r0, #2185	; 0x889
 8039f2e:	f000 fa79 	bl	803a424 <SUBGRF_WriteRegister>
    switch(SubgRf.Modem)
 8039f32:	782b      	ldrb	r3, [r5, #0]
 8039f34:	2b03      	cmp	r3, #3
 8039f36:	d86f      	bhi.n	803a018 <RadioSend+0x128>
 8039f38:	e8df f003 	tbb	[pc, r3]
 8039f3c:	08804e55 	.word	0x08804e55
        SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) | ( 1 << 2 ) );
 8039f40:	f000 fb36 	bl	803a5b0 <SUBGRF_ReadRegister>
 8039f44:	f040 0104 	orr.w	r1, r0, #4
 8039f48:	b2c9      	uxtb	r1, r1
 8039f4a:	e7ee      	b.n	8039f2a <RadioSend+0x3a>
 8039f4c:	4a51      	ldr	r2, [pc, #324]	; (803a094 <RadioSend+0x1a4>)
 8039f4e:	1e73      	subs	r3, r6, #1
 8039f50:	4610      	mov	r0, r2
    for (i = 0; i < size; i++)
 8039f52:	f1c6 0701 	rsb	r7, r6, #1
        outBuffer[i] = 0;
 8039f56:	f04f 0c00 	mov.w	ip, #0
    for (i = 0; i < size; i++)
 8039f5a:	18f9      	adds	r1, r7, r3
 8039f5c:	428c      	cmp	r4, r1
 8039f5e:	dc71      	bgt.n	803a044 <RadioSend+0x154>
    for (i = 0; i < (size * 8); i++)
 8039f60:	2300      	movs	r3, #0
 8039f62:	00e7      	lsls	r7, r4, #3
    uint8_t prevInt = 0;
 8039f64:	4619      	mov	r1, r3
    for (i = 0; i < (size * 8); i++)
 8039f66:	42bb      	cmp	r3, r7
 8039f68:	d173      	bne.n	803a052 <RadioSend+0x162>
    outBuffer[size] = ( prevInt << 7 ) | ( prevInt << 6 ) | ( ( ( !prevInt ) & 0x01 ) << 5 ) ;
 8039f6a:	4a4b      	ldr	r2, [pc, #300]	; (803a098 <RadioSend+0x1a8>)
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039f6c:	484b      	ldr	r0, [pc, #300]	; (803a09c <RadioSend+0x1ac>)
    outBuffer[size] = ( prevInt << 7 ) | ( prevInt << 6 ) | ( ( ( !prevInt ) & 0x01 ) << 5 ) ;
 8039f6e:	2900      	cmp	r1, #0
 8039f70:	ea4f 1381 	mov.w	r3, r1, lsl #6
 8039f74:	ea43 13c1 	orr.w	r3, r3, r1, lsl #7
 8039f78:	4422      	add	r2, r4
 8039f7a:	bf0c      	ite	eq
 8039f7c:	2120      	moveq	r1, #32
 8039f7e:	2100      	movne	r1, #0
 8039f80:	430b      	orrs	r3, r1
            SubgRf.PacketParams.Params.Bpsk.PayloadLength = size + 1;
 8039f82:	1c66      	adds	r6, r4, #1
    outBuffer[size] = ( prevInt << 7 ) | ( prevInt << 6 ) | ( ( ( !prevInt ) & 0x01 ) << 5 ) ;
 8039f84:	7113      	strb	r3, [r2, #4]
            SubgRf.PacketParams.Params.Bpsk.PayloadLength = size + 1;
 8039f86:	b2f6      	uxtb	r6, r6
            SubgRf.PacketParams.PacketType = PACKET_TYPE_BPSK;
 8039f88:	2302      	movs	r3, #2
 8039f8a:	73ab      	strb	r3, [r5, #14]
            SubgRf.PacketParams.Params.Bpsk.PayloadLength = size + 1;
 8039f8c:	76ae      	strb	r6, [r5, #26]
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039f8e:	f000 fc39 	bl	803a804 <SUBGRF_SetPacketParams>
    SUBGRF_WriteRegister(addr, data );
 8039f92:	2100      	movs	r1, #0
 8039f94:	20f1      	movs	r0, #241	; 0xf1
 8039f96:	f000 fa45 	bl	803a424 <SUBGRF_WriteRegister>
 8039f9a:	2100      	movs	r1, #0
 8039f9c:	20f0      	movs	r0, #240	; 0xf0
 8039f9e:	f000 fa41 	bl	803a424 <SUBGRF_WriteRegister>
            if( SubgRf.ModulationParams.Params.Bpsk.BitRate == 100 )
 8039fa2:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8039fa4:	2b64      	cmp	r3, #100	; 0x64
 8039fa6:	d16d      	bne.n	803a084 <RadioSend+0x194>
    SUBGRF_WriteRegister(addr, data );
 8039fa8:	2170      	movs	r1, #112	; 0x70
 8039faa:	20f3      	movs	r0, #243	; 0xf3
 8039fac:	f000 fa3a 	bl	803a424 <SUBGRF_WriteRegister>
 8039fb0:	211d      	movs	r1, #29
 8039fb2:	20f2      	movs	r0, #242	; 0xf2
 8039fb4:	f000 fa36 	bl	803a424 <SUBGRF_WriteRegister>
            uint16_t bitNum = ( size * 8 ) + 2;
 8039fb8:	00e1      	lsls	r1, r4, #3
 8039fba:	1c8c      	adds	r4, r1, #2
    SUBGRF_WriteRegister(addr, data );
 8039fbc:	20f4      	movs	r0, #244	; 0xf4
 8039fbe:	0a09      	lsrs	r1, r1, #8
 8039fc0:	f000 fa30 	bl	803a424 <SUBGRF_WriteRegister>
 8039fc4:	f004 01fe 	and.w	r1, r4, #254	; 0xfe
 8039fc8:	20f5      	movs	r0, #245	; 0xf5
 8039fca:	f000 fa2b 	bl	803a424 <SUBGRF_WriteRegister>
            SUBGRF_SendPayload( RadioBuffer, size+1 , 0xFFFFFF );
 8039fce:	4831      	ldr	r0, [pc, #196]	; (803a094 <RadioSend+0x1a4>)
 8039fd0:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
 8039fd4:	4631      	mov	r1, r6
 8039fd6:	e01d      	b.n	803a014 <RadioSend+0x124>
            SubgRf.PacketParams.Params.LoRa.PayloadLength = size;
 8039fd8:	77ec      	strb	r4, [r5, #31]
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039fda:	4830      	ldr	r0, [pc, #192]	; (803a09c <RadioSend+0x1ac>)
 8039fdc:	f000 fc12 	bl	803a804 <SUBGRF_SetPacketParams>
            SUBGRF_SendPayload( buffer, size, 0 );
 8039fe0:	2200      	movs	r2, #0
 8039fe2:	4621      	mov	r1, r4
 8039fe4:	e015      	b.n	803a012 <RadioSend+0x122>
            if ( 1UL == RFW_Is_Init( ) )
 8039fe6:	f000 fdc9 	bl	803ab7c <RFW_Is_Init>
 8039fea:	2801      	cmp	r0, #1
 8039fec:	4607      	mov	r7, r0
 8039fee:	d123      	bne.n	803a038 <RadioSend+0x148>
              if ( 0UL == RFW_TransmitInit( buffer,size, &outsize ) )
 8039ff0:	4621      	mov	r1, r4
 8039ff2:	f10d 0207 	add.w	r2, sp, #7
 8039ff6:	4630      	mov	r0, r6
 8039ff8:	f000 fdc5 	bl	803ab86 <RFW_TransmitInit>
 8039ffc:	4604      	mov	r4, r0
 8039ffe:	b998      	cbnz	r0, 803a028 <RadioSend+0x138>
                  SubgRf.PacketParams.Params.Gfsk.PayloadLength = outsize;
 803a000:	f89d 3007 	ldrb.w	r3, [sp, #7]
                  SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 803a004:	4825      	ldr	r0, [pc, #148]	; (803a09c <RadioSend+0x1ac>)
                  SubgRf.PacketParams.Params.Gfsk.PayloadLength = outsize;
 803a006:	75ab      	strb	r3, [r5, #22]
                  SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 803a008:	f000 fbfc 	bl	803a804 <SUBGRF_SetPacketParams>
                  SUBGRF_SendPayload( buffer, outsize, 0 );
 803a00c:	f89d 1007 	ldrb.w	r1, [sp, #7]
 803a010:	4622      	mov	r2, r4
            SUBGRF_SendPayload( buffer, size, 0 );
 803a012:	4630      	mov	r0, r6
            SUBGRF_SendPayload( RadioBuffer, size+1 , 0xFFFFFF );
 803a014:	f000 fcb1 	bl	803a97a <SUBGRF_SendPayload>
    TimerSetValue( &TxTimeoutTimer, SubgRf.TxTimeout );
 803a018:	6869      	ldr	r1, [r5, #4]
 803a01a:	4821      	ldr	r0, [pc, #132]	; (803a0a0 <RadioSend+0x1b0>)
 803a01c:	f001 fa18 	bl	803b450 <UTIL_TIMER_SetPeriod>
    TimerStart( &TxTimeoutTimer );
 803a020:	481f      	ldr	r0, [pc, #124]	; (803a0a0 <RadioSend+0x1b0>)
 803a022:	f001 f9db 	bl	803b3dc <UTIL_TIMER_Start>
 803a026:	e005      	b.n	803a034 <RadioSend+0x144>
                MW_LOG( TS_ON, VLEVEL_M, "RadioSend Oversize\r\n");
 803a028:	4b1e      	ldr	r3, [pc, #120]	; (803a0a4 <RadioSend+0x1b4>)
 803a02a:	463a      	mov	r2, r7
 803a02c:	2100      	movs	r1, #0
 803a02e:	2002      	movs	r0, #2
 803a030:	f000 fe62 	bl	803acf8 <UTIL_ADV_TRACE_COND_FSend>
}
 803a034:	b003      	add	sp, #12
 803a036:	bdf0      	pop	{r4, r5, r6, r7, pc}
              SubgRf.PacketParams.Params.Gfsk.PayloadLength = size;
 803a038:	75ac      	strb	r4, [r5, #22]
              SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 803a03a:	e7ce      	b.n	8039fda <RadioSend+0xea>
            SubgRf.PacketParams.PacketType = PACKET_TYPE_BPSK;
 803a03c:	2302      	movs	r3, #2
 803a03e:	73ab      	strb	r3, [r5, #14]
            SubgRf.PacketParams.Params.Bpsk.PayloadLength = size;
 803a040:	76ac      	strb	r4, [r5, #26]
 803a042:	e7ca      	b.n	8039fda <RadioSend+0xea>
        inBuffer[i] = ~inBuffer[i];
 803a044:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 803a048:	43c9      	mvns	r1, r1
 803a04a:	7019      	strb	r1, [r3, #0]
        outBuffer[i] = 0;
 803a04c:	f802 cb01 	strb.w	ip, [r2], #1
    for (i = 0; i < size; i++)
 803a050:	e783      	b.n	8039f5a <RadioSend+0x6a>
        index_bit = 7 - ( i % 8 );
 803a052:	43da      	mvns	r2, r3
 803a054:	f002 0c07 	and.w	ip, r2, #7
        index_byte = i / 8;
 803a058:	10da      	asrs	r2, r3, #3
        index_bit_out = 7 - ( ( i + 1 ) % 8 );
 803a05a:	3301      	adds	r3, #1
        currBit = ( inBuffer[index_byte] >> index_bit ) & 0x01;
 803a05c:	5cb2      	ldrb	r2, [r6, r2]
 803a05e:	fa42 f20c 	asr.w	r2, r2, ip
 803a062:	f002 0201 	and.w	r2, r2, #1
        index_byte_out = ( i + 1 ) / 8;
 803a066:	ea4f 0ce3 	mov.w	ip, r3, asr #3
        prevInt ^= currBit;
 803a06a:	4051      	eors	r1, r2
        index_bit_out = 7 - ( ( i + 1 ) % 8 );
 803a06c:	43da      	mvns	r2, r3
        outBuffer[index_byte_out] |= ( prevInt << index_bit_out );
 803a06e:	f810 e00c 	ldrb.w	lr, [r0, ip]
 803a072:	f002 0207 	and.w	r2, r2, #7
 803a076:	fa01 f202 	lsl.w	r2, r1, r2
 803a07a:	ea42 020e 	orr.w	r2, r2, lr
 803a07e:	f800 200c 	strb.w	r2, [r0, ip]
    for (i = 0; i < (size * 8); i++)
 803a082:	e770      	b.n	8039f66 <RadioSend+0x76>
    SUBGRF_WriteRegister(addr, data );
 803a084:	21e1      	movs	r1, #225	; 0xe1
 803a086:	20f3      	movs	r0, #243	; 0xf3
 803a088:	f000 f9cc 	bl	803a424 <SUBGRF_WriteRegister>
 803a08c:	2104      	movs	r1, #4
 803a08e:	e790      	b.n	8039fb2 <RadioSend+0xc2>
 803a090:	20006324 	.word	0x20006324
 803a094:	20005980 	.word	0x20005980
 803a098:	2000597c 	.word	0x2000597c
 803a09c:	20006332 	.word	0x20006332
 803a0a0:	2000637c 	.word	0x2000637c
 803a0a4:	0803c5a9 	.word	0x0803c5a9

0803a0a8 <RadioTxPrbs>:
{
 803a0a8:	b508      	push	{r3, lr}
    SUBGRF_SetSwitch( SubgRf.AntSwitchPaSelect, RFSWITCH_TX );
 803a0aa:	4b09      	ldr	r3, [pc, #36]	; (803a0d0 <RadioTxPrbs+0x28>)
 803a0ac:	2101      	movs	r1, #1
 803a0ae:	f893 0056 	ldrb.w	r0, [r3, #86]	; 0x56
 803a0b2:	f000 fc94 	bl	803a9de <SUBGRF_SetSwitch>
    SUBGRF_WriteRegister(addr, data );
 803a0b6:	f44f 60d7 	mov.w	r0, #1720	; 0x6b8
 803a0ba:	212d      	movs	r1, #45	; 0x2d
 803a0bc:	f000 f9b2 	bl	803a424 <SUBGRF_WriteRegister>
    SUBGRF_SetTxInfinitePreamble( );
 803a0c0:	f000 f89f 	bl	803a202 <SUBGRF_SetTxInfinitePreamble>
}
 803a0c4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    SUBGRF_SetTx( 0x0fffff );
 803a0c8:	4802      	ldr	r0, [pc, #8]	; (803a0d4 <RadioTxPrbs+0x2c>)
 803a0ca:	f000 b841 	b.w	803a150 <SUBGRF_SetTx>
 803a0ce:	bf00      	nop
 803a0d0:	20006324 	.word	0x20006324
 803a0d4:	000fffff 	.word	0x000fffff

0803a0d8 <SUBGRF_WriteCommand>:
    CRITICAL_SECTION_END();
}

void SUBGRF_WriteCommand( SUBGHZ_RadioSetCmd_t Command, uint8_t *pBuffer,
                                        uint16_t Size )
{
 803a0d8:	b510      	push	{r4, lr}
 803a0da:	4613      	mov	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803a0dc:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803a0e0:	b672      	cpsid	i
    CRITICAL_SECTION_BEGIN();
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 803a0e2:	460a      	mov	r2, r1
 803a0e4:	4601      	mov	r1, r0
 803a0e6:	4803      	ldr	r0, [pc, #12]	; (803a0f4 <SUBGRF_WriteCommand+0x1c>)
 803a0e8:	f7f5 fd14 	bl	802fb14 <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803a0ec:	f384 8810 	msr	PRIMASK, r4
    CRITICAL_SECTION_END();
}
 803a0f0:	bd10      	pop	{r4, pc}
 803a0f2:	bf00      	nop
 803a0f4:	200061f0 	.word	0x200061f0

0803a0f8 <SUBGRF_ReadCommand>:

void SUBGRF_ReadCommand( SUBGHZ_RadioGetCmd_t Command, uint8_t *pBuffer,
                                        uint16_t Size )
{
 803a0f8:	b510      	push	{r4, lr}
 803a0fa:	4613      	mov	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803a0fc:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803a100:	b672      	cpsid	i
    CRITICAL_SECTION_BEGIN();
    HAL_SUBGHZ_ExecGetCmd( &hsubghz, Command, pBuffer, Size );
 803a102:	460a      	mov	r2, r1
 803a104:	4601      	mov	r1, r0
 803a106:	4803      	ldr	r0, [pc, #12]	; (803a114 <SUBGRF_ReadCommand+0x1c>)
 803a108:	f7f5 fda6 	bl	802fc58 <HAL_SUBGHZ_ExecGetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803a10c:	f384 8810 	msr	PRIMASK, r4
    CRITICAL_SECTION_END();
}
 803a110:	bd10      	pop	{r4, pc}
 803a112:	bf00      	nop
 803a114:	200061f0 	.word	0x200061f0

0803a118 <SUBGRF_GetOperatingMode>:
}
 803a118:	4b01      	ldr	r3, [pc, #4]	; (803a120 <SUBGRF_GetOperatingMode+0x8>)
 803a11a:	7818      	ldrb	r0, [r3, #0]
 803a11c:	4770      	bx	lr
 803a11e:	bf00      	nop
 803a120:	20005a80 	.word	0x20005a80

0803a124 <SUBGRF_SetStandby>:
{
 803a124:	b507      	push	{r0, r1, r2, lr}
    SUBGRF_WriteCommand( RADIO_SET_STANDBY, ( uint8_t* )&standbyConfig, 1 );
 803a126:	2201      	movs	r2, #1
{
 803a128:	f88d 0007 	strb.w	r0, [sp, #7]
    SUBGRF_WriteCommand( RADIO_SET_STANDBY, ( uint8_t* )&standbyConfig, 1 );
 803a12c:	f10d 0107 	add.w	r1, sp, #7
 803a130:	2080      	movs	r0, #128	; 0x80
 803a132:	f7ff ffd1 	bl	803a0d8 <SUBGRF_WriteCommand>
    if( standbyConfig == STDBY_RC )
 803a136:	f89d 3007 	ldrb.w	r3, [sp, #7]
 803a13a:	2b00      	cmp	r3, #0
 803a13c:	4b03      	ldr	r3, [pc, #12]	; (803a14c <SUBGRF_SetStandby+0x28>)
        OperatingMode = MODE_STDBY_XOSC;
 803a13e:	bf0c      	ite	eq
 803a140:	2201      	moveq	r2, #1
 803a142:	2202      	movne	r2, #2
 803a144:	701a      	strb	r2, [r3, #0]
}
 803a146:	b003      	add	sp, #12
 803a148:	f85d fb04 	ldr.w	pc, [sp], #4
 803a14c:	20005a80 	.word	0x20005a80

0803a150 <SUBGRF_SetTx>:
{
 803a150:	b507      	push	{r0, r1, r2, lr}
    OperatingMode = MODE_TX;
 803a152:	4b09      	ldr	r3, [pc, #36]	; (803a178 <SUBGRF_SetTx+0x28>)
    buf[2] = ( uint8_t )( timeout & 0xFF );
 803a154:	f88d 0006 	strb.w	r0, [sp, #6]
    OperatingMode = MODE_TX;
 803a158:	2204      	movs	r2, #4
 803a15a:	701a      	strb	r2, [r3, #0]
    buf[0] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 803a15c:	0c03      	lsrs	r3, r0, #16
 803a15e:	f88d 3004 	strb.w	r3, [sp, #4]
    SUBGRF_WriteCommand( RADIO_SET_TX, buf, 3 );
 803a162:	2203      	movs	r2, #3
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 803a164:	0a03      	lsrs	r3, r0, #8
    SUBGRF_WriteCommand( RADIO_SET_TX, buf, 3 );
 803a166:	a901      	add	r1, sp, #4
 803a168:	2083      	movs	r0, #131	; 0x83
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 803a16a:	f88d 3005 	strb.w	r3, [sp, #5]
    SUBGRF_WriteCommand( RADIO_SET_TX, buf, 3 );
 803a16e:	f7ff ffb3 	bl	803a0d8 <SUBGRF_WriteCommand>
}
 803a172:	b003      	add	sp, #12
 803a174:	f85d fb04 	ldr.w	pc, [sp], #4
 803a178:	20005a80 	.word	0x20005a80

0803a17c <SUBGRF_SetRx>:
{
 803a17c:	b507      	push	{r0, r1, r2, lr}
    OperatingMode = MODE_RX;
 803a17e:	4b09      	ldr	r3, [pc, #36]	; (803a1a4 <SUBGRF_SetRx+0x28>)
    buf[2] = ( uint8_t )( timeout & 0xFF );
 803a180:	f88d 0006 	strb.w	r0, [sp, #6]
    OperatingMode = MODE_RX;
 803a184:	2205      	movs	r2, #5
 803a186:	701a      	strb	r2, [r3, #0]
    buf[0] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 803a188:	0c03      	lsrs	r3, r0, #16
 803a18a:	f88d 3004 	strb.w	r3, [sp, #4]
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 803a18e:	2203      	movs	r2, #3
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 803a190:	0a03      	lsrs	r3, r0, #8
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 803a192:	a901      	add	r1, sp, #4
 803a194:	2082      	movs	r0, #130	; 0x82
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 803a196:	f88d 3005 	strb.w	r3, [sp, #5]
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 803a19a:	f7ff ff9d 	bl	803a0d8 <SUBGRF_WriteCommand>
}
 803a19e:	b003      	add	sp, #12
 803a1a0:	f85d fb04 	ldr.w	pc, [sp], #4
 803a1a4:	20005a80 	.word	0x20005a80

0803a1a8 <SUBGRF_SetRxDutyCycle>:
{
 803a1a8:	b507      	push	{r0, r1, r2, lr}
    buf[0] = ( uint8_t )( ( rxTime >> 16 ) & 0xFF );
 803a1aa:	0c03      	lsrs	r3, r0, #16
 803a1ac:	f88d 3000 	strb.w	r3, [sp]
    buf[1] = ( uint8_t )( ( rxTime >> 8 ) & 0xFF );
 803a1b0:	0a03      	lsrs	r3, r0, #8
 803a1b2:	f88d 3001 	strb.w	r3, [sp, #1]
    buf[3] = ( uint8_t )( ( sleepTime >> 16 ) & 0xFF );
 803a1b6:	0c0b      	lsrs	r3, r1, #16
    buf[4] = ( uint8_t )( ( sleepTime >> 8 ) & 0xFF );
 803a1b8:	ba49      	rev16	r1, r1
    buf[2] = ( uint8_t )( rxTime & 0xFF );
 803a1ba:	f88d 0002 	strb.w	r0, [sp, #2]
    buf[4] = ( uint8_t )( ( sleepTime >> 8 ) & 0xFF );
 803a1be:	f8ad 1004 	strh.w	r1, [sp, #4]
    SUBGRF_WriteCommand( RADIO_SET_RXDUTYCYCLE, buf, 6 );
 803a1c2:	2206      	movs	r2, #6
 803a1c4:	4669      	mov	r1, sp
 803a1c6:	2094      	movs	r0, #148	; 0x94
    buf[3] = ( uint8_t )( ( sleepTime >> 16 ) & 0xFF );
 803a1c8:	f88d 3003 	strb.w	r3, [sp, #3]
    SUBGRF_WriteCommand( RADIO_SET_RXDUTYCYCLE, buf, 6 );
 803a1cc:	f7ff ff84 	bl	803a0d8 <SUBGRF_WriteCommand>
    OperatingMode = MODE_RX_DC;
 803a1d0:	4b02      	ldr	r3, [pc, #8]	; (803a1dc <SUBGRF_SetRxDutyCycle+0x34>)
 803a1d2:	2206      	movs	r2, #6
 803a1d4:	701a      	strb	r2, [r3, #0]
}
 803a1d6:	b003      	add	sp, #12
 803a1d8:	f85d fb04 	ldr.w	pc, [sp], #4
 803a1dc:	20005a80 	.word	0x20005a80

0803a1e0 <SUBGRF_SetCad>:
    SUBGRF_WriteCommand( RADIO_SET_CAD, 0, 0 );
 803a1e0:	2200      	movs	r2, #0
{
 803a1e2:	b508      	push	{r3, lr}
    SUBGRF_WriteCommand( RADIO_SET_CAD, 0, 0 );
 803a1e4:	4611      	mov	r1, r2
 803a1e6:	20c5      	movs	r0, #197	; 0xc5
 803a1e8:	f7ff ff76 	bl	803a0d8 <SUBGRF_WriteCommand>
    OperatingMode = MODE_CAD;
 803a1ec:	4b01      	ldr	r3, [pc, #4]	; (803a1f4 <SUBGRF_SetCad+0x14>)
 803a1ee:	2207      	movs	r2, #7
 803a1f0:	701a      	strb	r2, [r3, #0]
}
 803a1f2:	bd08      	pop	{r3, pc}
 803a1f4:	20005a80 	.word	0x20005a80

0803a1f8 <SUBGRF_SetTxContinuousWave>:
    SUBGRF_WriteCommand( RADIO_SET_TXCONTINUOUSWAVE, 0, 0 );
 803a1f8:	2200      	movs	r2, #0
 803a1fa:	4611      	mov	r1, r2
 803a1fc:	20d1      	movs	r0, #209	; 0xd1
 803a1fe:	f7ff bf6b 	b.w	803a0d8 <SUBGRF_WriteCommand>

0803a202 <SUBGRF_SetTxInfinitePreamble>:
    SUBGRF_WriteCommand( RADIO_SET_TXCONTINUOUSPREAMBLE, 0, 0 );
 803a202:	2200      	movs	r2, #0
 803a204:	4611      	mov	r1, r2
 803a206:	20d2      	movs	r0, #210	; 0xd2
 803a208:	f7ff bf66 	b.w	803a0d8 <SUBGRF_WriteCommand>

0803a20c <SUBGRF_SetStopRxTimerOnPreambleDetect>:
{
 803a20c:	b507      	push	{r0, r1, r2, lr}
    SUBGRF_WriteCommand( RADIO_SET_STOPRXTIMERONPREAMBLE, ( uint8_t* )&enable, 1 );
 803a20e:	2201      	movs	r2, #1
{
 803a210:	f88d 0007 	strb.w	r0, [sp, #7]
    SUBGRF_WriteCommand( RADIO_SET_STOPRXTIMERONPREAMBLE, ( uint8_t* )&enable, 1 );
 803a214:	f10d 0107 	add.w	r1, sp, #7
 803a218:	209f      	movs	r0, #159	; 0x9f
 803a21a:	f7ff ff5d 	bl	803a0d8 <SUBGRF_WriteCommand>
}
 803a21e:	b003      	add	sp, #12
 803a220:	f85d fb04 	ldr.w	pc, [sp], #4

0803a224 <SUBGRF_SetRegulatorMode>:
{
 803a224:	b507      	push	{r0, r1, r2, lr}
    if ( ( 1UL == RBI_IsDCDC() ) && ( 1UL == DCDC_ENABLE ) )
 803a226:	f7f2 ffad 	bl	802d184 <RBI_IsDCDC>
 803a22a:	1e43      	subs	r3, r0, #1
 803a22c:	4258      	negs	r0, r3
 803a22e:	4158      	adcs	r0, r3
 803a230:	f88d 0007 	strb.w	r0, [sp, #7]
    SUBGRF_WriteCommand( RADIO_SET_REGULATORMODE, ( uint8_t* )&mode, 1 );
 803a234:	2201      	movs	r2, #1
 803a236:	f10d 0107 	add.w	r1, sp, #7
 803a23a:	2096      	movs	r0, #150	; 0x96
 803a23c:	f7ff ff4c 	bl	803a0d8 <SUBGRF_WriteCommand>
}
 803a240:	b003      	add	sp, #12
 803a242:	f85d fb04 	ldr.w	pc, [sp], #4

0803a246 <SUBGRF_Calibrate>:
{
 803a246:	b507      	push	{r0, r1, r2, lr}
                      ( ( uint8_t )calibParam.Fields.RC13MEnable << 1 ) |
 803a248:	f000 007f 	and.w	r0, r0, #127	; 0x7f
    uint8_t value = ( ( ( uint8_t )calibParam.Fields.ImgEnable << 6 ) |
 803a24c:	f88d 0007 	strb.w	r0, [sp, #7]
    SUBGRF_WriteCommand( RADIO_CALIBRATE, &value, 1 );
 803a250:	2201      	movs	r2, #1
 803a252:	f10d 0107 	add.w	r1, sp, #7
 803a256:	2089      	movs	r0, #137	; 0x89
 803a258:	f7ff ff3e 	bl	803a0d8 <SUBGRF_WriteCommand>
}
 803a25c:	b003      	add	sp, #12
 803a25e:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0803a264 <SUBGRF_CalibrateImage>:
    if( freq > 900000000 )
 803a264:	4b13      	ldr	r3, [pc, #76]	; (803a2b4 <SUBGRF_CalibrateImage+0x50>)
 803a266:	4298      	cmp	r0, r3
{
 803a268:	b507      	push	{r0, r1, r2, lr}
    if( freq > 900000000 )
 803a26a:	d90b      	bls.n	803a284 <SUBGRF_CalibrateImage+0x20>
        calFreq[0] = 0xE1;
 803a26c:	f64e 13e1 	movw	r3, #59873	; 0xe9e1
        calFreq[0] = 0x6B;
 803a270:	f8ad 3004 	strh.w	r3, [sp, #4]
    SUBGRF_WriteCommand( RADIO_CALIBRATEIMAGE, calFreq, 2 );
 803a274:	2202      	movs	r2, #2
 803a276:	a901      	add	r1, sp, #4
 803a278:	2098      	movs	r0, #152	; 0x98
 803a27a:	f7ff ff2d 	bl	803a0d8 <SUBGRF_WriteCommand>
}
 803a27e:	b003      	add	sp, #12
 803a280:	f85d fb04 	ldr.w	pc, [sp], #4
    else if( freq > 850000000 )
 803a284:	4b0c      	ldr	r3, [pc, #48]	; (803a2b8 <SUBGRF_CalibrateImage+0x54>)
 803a286:	4298      	cmp	r0, r3
 803a288:	d902      	bls.n	803a290 <SUBGRF_CalibrateImage+0x2c>
        calFreq[0] = 0xD7;
 803a28a:	f64d 33d7 	movw	r3, #56279	; 0xdbd7
 803a28e:	e7ef      	b.n	803a270 <SUBGRF_CalibrateImage+0xc>
    else if( freq > 770000000 )
 803a290:	4b0a      	ldr	r3, [pc, #40]	; (803a2bc <SUBGRF_CalibrateImage+0x58>)
 803a292:	4298      	cmp	r0, r3
 803a294:	d902      	bls.n	803a29c <SUBGRF_CalibrateImage+0x38>
        calFreq[0] = 0xC1;
 803a296:	f24c 53c1 	movw	r3, #50625	; 0xc5c1
 803a29a:	e7e9      	b.n	803a270 <SUBGRF_CalibrateImage+0xc>
    else if( freq > 460000000 )
 803a29c:	4b08      	ldr	r3, [pc, #32]	; (803a2c0 <SUBGRF_CalibrateImage+0x5c>)
 803a29e:	4298      	cmp	r0, r3
 803a2a0:	d902      	bls.n	803a2a8 <SUBGRF_CalibrateImage+0x44>
        calFreq[0] = 0x75;
 803a2a2:	f248 1375 	movw	r3, #33141	; 0x8175
 803a2a6:	e7e3      	b.n	803a270 <SUBGRF_CalibrateImage+0xc>
    else if( freq > 425000000 )
 803a2a8:	4b06      	ldr	r3, [pc, #24]	; (803a2c4 <SUBGRF_CalibrateImage+0x60>)
 803a2aa:	4298      	cmp	r0, r3
 803a2ac:	d9e2      	bls.n	803a274 <SUBGRF_CalibrateImage+0x10>
        calFreq[0] = 0x6B;
 803a2ae:	f646 736b 	movw	r3, #28523	; 0x6f6b
 803a2b2:	e7dd      	b.n	803a270 <SUBGRF_CalibrateImage+0xc>
 803a2b4:	35a4e900 	.word	0x35a4e900
 803a2b8:	32a9f880 	.word	0x32a9f880
 803a2bc:	2de54480 	.word	0x2de54480
 803a2c0:	1b6b0b00 	.word	0x1b6b0b00
 803a2c4:	1954fc40 	.word	0x1954fc40

0803a2c8 <SUBGRF_SetPaConfig>:
{
 803a2c8:	b507      	push	{r0, r1, r2, lr}
    buf[2] = deviceSel;
 803a2ca:	f88d 2006 	strb.w	r2, [sp, #6]
    SUBGRF_WriteCommand( RADIO_SET_PACONFIG, buf, 4 );
 803a2ce:	2204      	movs	r2, #4
    buf[0] = paDutyCycle;
 803a2d0:	f88d 0004 	strb.w	r0, [sp, #4]
    buf[1] = hpMax;
 803a2d4:	f88d 1005 	strb.w	r1, [sp, #5]
    SUBGRF_WriteCommand( RADIO_SET_PACONFIG, buf, 4 );
 803a2d8:	2095      	movs	r0, #149	; 0x95
 803a2da:	eb0d 0102 	add.w	r1, sp, r2
    buf[3] = paLut;
 803a2de:	f88d 3007 	strb.w	r3, [sp, #7]
    SUBGRF_WriteCommand( RADIO_SET_PACONFIG, buf, 4 );
 803a2e2:	f7ff fef9 	bl	803a0d8 <SUBGRF_WriteCommand>
}
 803a2e6:	b003      	add	sp, #12
 803a2e8:	f85d fb04 	ldr.w	pc, [sp], #4

0803a2ec <SUBGRF_SetDioIrqParams>:
{
 803a2ec:	b507      	push	{r0, r1, r2, lr}
    buf[4] = ( uint8_t )( ( dio2Mask >> 8 ) & 0x00FF );
 803a2ee:	ba52      	rev16	r2, r2
 803a2f0:	f8ad 2004 	strh.w	r2, [sp, #4]
    buf[0] = ( uint8_t )( ( irqMask >> 8 ) & 0x00FF );
 803a2f4:	ba40      	rev16	r0, r0
    SUBGRF_WriteCommand( RADIO_CFG_DIOIRQ, buf, 8 );
 803a2f6:	2208      	movs	r2, #8
    buf[2] = ( uint8_t )( ( dio1Mask >> 8 ) & 0x00FF );
 803a2f8:	ba49      	rev16	r1, r1
    buf[0] = ( uint8_t )( ( irqMask >> 8 ) & 0x00FF );
 803a2fa:	f8ad 0000 	strh.w	r0, [sp]
    buf[2] = ( uint8_t )( ( dio1Mask >> 8 ) & 0x00FF );
 803a2fe:	f8ad 1002 	strh.w	r1, [sp, #2]
    buf[6] = ( uint8_t )( ( dio3Mask >> 8 ) & 0x00FF );
 803a302:	ba5b      	rev16	r3, r3
    SUBGRF_WriteCommand( RADIO_CFG_DIOIRQ, buf, 8 );
 803a304:	4669      	mov	r1, sp
 803a306:	4610      	mov	r0, r2
    buf[6] = ( uint8_t )( ( dio3Mask >> 8 ) & 0x00FF );
 803a308:	f8ad 3006 	strh.w	r3, [sp, #6]
    SUBGRF_WriteCommand( RADIO_CFG_DIOIRQ, buf, 8 );
 803a30c:	f7ff fee4 	bl	803a0d8 <SUBGRF_WriteCommand>
}
 803a310:	b003      	add	sp, #12
 803a312:	f85d fb04 	ldr.w	pc, [sp], #4

0803a316 <SUBGRF_SetTcxoMode>:
{
 803a316:	b507      	push	{r0, r1, r2, lr}
    buf[1] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 803a318:	0c0b      	lsrs	r3, r1, #16
    SUBGRF_WriteCommand( RADIO_SET_TCXOMODE, buf, 4 );
 803a31a:	2204      	movs	r2, #4
    buf[0] = tcxoVoltage & 0x07;
 803a31c:	f000 0007 	and.w	r0, r0, #7
    buf[2] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 803a320:	ba49      	rev16	r1, r1
    buf[0] = tcxoVoltage & 0x07;
 803a322:	f88d 0004 	strb.w	r0, [sp, #4]
    buf[2] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 803a326:	f8ad 1006 	strh.w	r1, [sp, #6]
    SUBGRF_WriteCommand( RADIO_SET_TCXOMODE, buf, 4 );
 803a32a:	2097      	movs	r0, #151	; 0x97
 803a32c:	eb0d 0102 	add.w	r1, sp, r2
    buf[1] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 803a330:	f88d 3005 	strb.w	r3, [sp, #5]
    SUBGRF_WriteCommand( RADIO_SET_TCXOMODE, buf, 4 );
 803a334:	f7ff fed0 	bl	803a0d8 <SUBGRF_WriteCommand>
}
 803a338:	b003      	add	sp, #12
 803a33a:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0803a340 <SUBGRF_SetRfFrequency>:
{
 803a340:	b537      	push	{r0, r1, r2, r4, r5, lr}
    if( ImageCalibrated == false )
 803a342:	4d0c      	ldr	r5, [pc, #48]	; (803a374 <SUBGRF_SetRfFrequency+0x34>)
 803a344:	786b      	ldrb	r3, [r5, #1]
{
 803a346:	4604      	mov	r4, r0
    if( ImageCalibrated == false )
 803a348:	b91b      	cbnz	r3, 803a352 <SUBGRF_SetRfFrequency+0x12>
        SUBGRF_CalibrateImage( frequency );
 803a34a:	f7ff ff8b 	bl	803a264 <SUBGRF_CalibrateImage>
        ImageCalibrated = true;
 803a34e:	2301      	movs	r3, #1
 803a350:	706b      	strb	r3, [r5, #1]
    SX_FREQ_TO_CHANNEL(chan, frequency);   
 803a352:	2300      	movs	r3, #0
 803a354:	4a08      	ldr	r2, [pc, #32]	; (803a378 <SUBGRF_SetRfFrequency+0x38>)
 803a356:	0660      	lsls	r0, r4, #25
 803a358:	09e1      	lsrs	r1, r4, #7
 803a35a:	f7f1 fbf3 	bl	802bb44 <__aeabi_uldivmod>
    SUBGRF_WriteCommand( RADIO_SET_RFFREQUENCY, buf, 4 );
 803a35e:	2204      	movs	r2, #4
 803a360:	ba00      	rev	r0, r0
    buf[0] = ( uint8_t )( ( chan >> 24 ) & 0xFF );
 803a362:	9001      	str	r0, [sp, #4]
    SUBGRF_WriteCommand( RADIO_SET_RFFREQUENCY, buf, 4 );
 803a364:	eb0d 0102 	add.w	r1, sp, r2
 803a368:	2086      	movs	r0, #134	; 0x86
 803a36a:	f7ff feb5 	bl	803a0d8 <SUBGRF_WriteCommand>
}
 803a36e:	b003      	add	sp, #12
 803a370:	bd30      	pop	{r4, r5, pc}
 803a372:	bf00      	nop
 803a374:	20005a80 	.word	0x20005a80
 803a378:	01e84800 	.word	0x01e84800

0803a37c <SUBGRF_SetBufferBaseAddress>:
{
 803a37c:	b507      	push	{r0, r1, r2, lr}
    SUBGRF_WriteCommand( RADIO_SET_BUFFERBASEADDRESS, buf, 2 );
 803a37e:	2202      	movs	r2, #2
    buf[0] = txBaseAddress;
 803a380:	f88d 0004 	strb.w	r0, [sp, #4]
    buf[1] = rxBaseAddress;
 803a384:	f88d 1005 	strb.w	r1, [sp, #5]
    SUBGRF_WriteCommand( RADIO_SET_BUFFERBASEADDRESS, buf, 2 );
 803a388:	208f      	movs	r0, #143	; 0x8f
 803a38a:	a901      	add	r1, sp, #4
 803a38c:	f7ff fea4 	bl	803a0d8 <SUBGRF_WriteCommand>
}
 803a390:	b003      	add	sp, #12
 803a392:	f85d fb04 	ldr.w	pc, [sp], #4

0803a396 <SUBGRF_GetRssiInst>:
{
 803a396:	b507      	push	{r0, r1, r2, lr}
    SUBGRF_ReadCommand( RADIO_GET_RSSIINST, buf, 1 );
 803a398:	2201      	movs	r2, #1
 803a39a:	a901      	add	r1, sp, #4
 803a39c:	2015      	movs	r0, #21
 803a39e:	f7ff feab 	bl	803a0f8 <SUBGRF_ReadCommand>
    rssi = -buf[0] >> 1;
 803a3a2:	f89d 0004 	ldrb.w	r0, [sp, #4]
 803a3a6:	4240      	negs	r0, r0
}
 803a3a8:	1040      	asrs	r0, r0, #1
 803a3aa:	b003      	add	sp, #12
 803a3ac:	f85d fb04 	ldr.w	pc, [sp], #4

0803a3b0 <SUBGRF_GetPacketStatus>:
{
 803a3b0:	b513      	push	{r0, r1, r4, lr}
    SUBGRF_ReadCommand( RADIO_GET_PACKETSTATUS, status, 3 );
 803a3b2:	2203      	movs	r2, #3
{
 803a3b4:	4604      	mov	r4, r0
    SUBGRF_ReadCommand( RADIO_GET_PACKETSTATUS, status, 3 );
 803a3b6:	a901      	add	r1, sp, #4
 803a3b8:	2014      	movs	r0, #20
 803a3ba:	f7ff fe9d 	bl	803a0f8 <SUBGRF_ReadCommand>
    return PacketType;
 803a3be:	4918      	ldr	r1, [pc, #96]	; (803a420 <SUBGRF_GetPacketStatus+0x70>)
 803a3c0:	788a      	ldrb	r2, [r1, #2]
    pktStatus->packetType = SUBGRF_GetPacketType( );
 803a3c2:	7022      	strb	r2, [r4, #0]
    switch( pktStatus->packetType )
 803a3c4:	b14a      	cbz	r2, 803a3da <SUBGRF_GetPacketStatus+0x2a>
 803a3c6:	2a01      	cmp	r2, #1
 803a3c8:	d017      	beq.n	803a3fa <SUBGRF_GetPacketStatus+0x4a>
            RADIO_MEMSET8( pktStatus, 0, sizeof( PacketStatus_t ) );
 803a3ca:	2214      	movs	r2, #20
 803a3cc:	2100      	movs	r1, #0
 803a3ce:	4620      	mov	r0, r4
 803a3d0:	f000 fda4 	bl	803af1c <UTIL_MEM_set_8>
            pktStatus->packetType = PACKET_TYPE_NONE;
 803a3d4:	230f      	movs	r3, #15
 803a3d6:	7023      	strb	r3, [r4, #0]
}
 803a3d8:	e00d      	b.n	803a3f6 <SUBGRF_GetPacketStatus+0x46>
            pktStatus->Params.Gfsk.RxStatus = status[0];
 803a3da:	f89d 3004 	ldrb.w	r3, [sp, #4]
 803a3de:	7123      	strb	r3, [r4, #4]
            pktStatus->Params.Gfsk.RssiSync = -status[1] >> 1;
 803a3e0:	f89d 3005 	ldrb.w	r3, [sp, #5]
            pktStatus->Params.Gfsk.FreqError = 0;
 803a3e4:	60a2      	str	r2, [r4, #8]
            pktStatus->Params.Gfsk.RssiSync = -status[1] >> 1;
 803a3e6:	425b      	negs	r3, r3
 803a3e8:	105b      	asrs	r3, r3, #1
 803a3ea:	71a3      	strb	r3, [r4, #6]
            pktStatus->Params.Gfsk.RssiAvg = -status[2] >> 1;
 803a3ec:	f89d 3006 	ldrb.w	r3, [sp, #6]
 803a3f0:	425b      	negs	r3, r3
 803a3f2:	105b      	asrs	r3, r3, #1
 803a3f4:	7163      	strb	r3, [r4, #5]
}
 803a3f6:	b002      	add	sp, #8
 803a3f8:	bd10      	pop	{r4, pc}
            pktStatus->Params.LoRa.RssiPkt = -status[0] >> 1;
 803a3fa:	f89d 3004 	ldrb.w	r3, [sp, #4]
 803a3fe:	425b      	negs	r3, r3
 803a400:	105b      	asrs	r3, r3, #1
 803a402:	7323      	strb	r3, [r4, #12]
            pktStatus->Params.LoRa.SnrPkt = ( ( ( int8_t )status[1] ) + 2 ) >> 2;
 803a404:	f99d 3005 	ldrsb.w	r3, [sp, #5]
 803a408:	3302      	adds	r3, #2
 803a40a:	109b      	asrs	r3, r3, #2
 803a40c:	7363      	strb	r3, [r4, #13]
            pktStatus->Params.LoRa.SignalRssiPkt = -status[2] >> 1;
 803a40e:	f89d 3006 	ldrb.w	r3, [sp, #6]
 803a412:	425b      	negs	r3, r3
 803a414:	105b      	asrs	r3, r3, #1
 803a416:	73a3      	strb	r3, [r4, #14]
            pktStatus->Params.LoRa.FreqError = FrequencyError;
 803a418:	684b      	ldr	r3, [r1, #4]
 803a41a:	6123      	str	r3, [r4, #16]
            break;
 803a41c:	e7eb      	b.n	803a3f6 <SUBGRF_GetPacketStatus+0x46>
 803a41e:	bf00      	nop
 803a420:	20005a80 	.word	0x20005a80

0803a424 <SUBGRF_WriteRegister>:
{
 803a424:	b507      	push	{r0, r1, r2, lr}
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 803a426:	2301      	movs	r3, #1
{
 803a428:	f88d 1007 	strb.w	r1, [sp, #7]
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 803a42c:	f10d 0207 	add.w	r2, sp, #7
 803a430:	4601      	mov	r1, r0
 803a432:	4803      	ldr	r0, [pc, #12]	; (803a440 <SUBGRF_WriteRegister+0x1c>)
 803a434:	f7f5 fafa 	bl	802fa2c <HAL_SUBGHZ_WriteRegisters>
}
 803a438:	b003      	add	sp, #12
 803a43a:	f85d fb04 	ldr.w	pc, [sp], #4
 803a43e:	bf00      	nop
 803a440:	200061f0 	.word	0x200061f0

0803a444 <SUBGRF_SetRxBoosted>:
{
 803a444:	b513      	push	{r0, r1, r4, lr}
    OperatingMode = MODE_RX;
 803a446:	4b0c      	ldr	r3, [pc, #48]	; (803a478 <SUBGRF_SetRxBoosted+0x34>)
{
 803a448:	4604      	mov	r4, r0
    OperatingMode = MODE_RX;
 803a44a:	2205      	movs	r2, #5
    SUBGRF_WriteRegister( REG_RX_GAIN, 0x97 ); // max LNA gain, increase current by ~2mA for around ~3dB in sensitivity
 803a44c:	2197      	movs	r1, #151	; 0x97
 803a44e:	f640 00ac 	movw	r0, #2220	; 0x8ac
    OperatingMode = MODE_RX;
 803a452:	701a      	strb	r2, [r3, #0]
    SUBGRF_WriteRegister( REG_RX_GAIN, 0x97 ); // max LNA gain, increase current by ~2mA for around ~3dB in sensitivity
 803a454:	f7ff ffe6 	bl	803a424 <SUBGRF_WriteRegister>
    buf[0] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 803a458:	0c23      	lsrs	r3, r4, #16
 803a45a:	f88d 3004 	strb.w	r3, [sp, #4]
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 803a45e:	2203      	movs	r2, #3
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 803a460:	0a23      	lsrs	r3, r4, #8
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 803a462:	a901      	add	r1, sp, #4
 803a464:	2082      	movs	r0, #130	; 0x82
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 803a466:	f88d 3005 	strb.w	r3, [sp, #5]
    buf[2] = ( uint8_t )( timeout & 0xFF );
 803a46a:	f88d 4006 	strb.w	r4, [sp, #6]
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 803a46e:	f7ff fe33 	bl	803a0d8 <SUBGRF_WriteCommand>
}
 803a472:	b002      	add	sp, #8
 803a474:	bd10      	pop	{r4, pc}
 803a476:	bf00      	nop
 803a478:	20005a80 	.word	0x20005a80

0803a47c <SUBGRF_SetLoRaSymbNumTimeout>:
{
 803a47c:	b507      	push	{r0, r1, r2, lr}
    SUBGRF_WriteCommand( RADIO_SET_LORASYMBTIMEOUT, &symbNum, 1 );
 803a47e:	2201      	movs	r2, #1
{
 803a480:	f88d 0007 	strb.w	r0, [sp, #7]
    SUBGRF_WriteCommand( RADIO_SET_LORASYMBTIMEOUT, &symbNum, 1 );
 803a484:	f10d 0107 	add.w	r1, sp, #7
 803a488:	20a0      	movs	r0, #160	; 0xa0
 803a48a:	f7ff fe25 	bl	803a0d8 <SUBGRF_WriteCommand>
    if( symbNum >= 64 )
 803a48e:	f89d 1007 	ldrb.w	r1, [sp, #7]
 803a492:	293f      	cmp	r1, #63	; 0x3f
 803a494:	d907      	bls.n	803a4a6 <SUBGRF_SetLoRaSymbNumTimeout+0x2a>
        reg = exp + ( mant << 3 );
 803a496:	f001 01f8 	and.w	r1, r1, #248	; 0xf8
 803a49a:	3101      	adds	r1, #1
        SUBGRF_WriteRegister( REG_LR_SYNCH_TIMEOUT, reg );
 803a49c:	b2c9      	uxtb	r1, r1
 803a49e:	f240 7006 	movw	r0, #1798	; 0x706
 803a4a2:	f7ff ffbf 	bl	803a424 <SUBGRF_WriteRegister>
}
 803a4a6:	b003      	add	sp, #12
 803a4a8:	f85d fb04 	ldr.w	pc, [sp], #4

0803a4ac <SUBGRF_SetPacketType>:
{
 803a4ac:	b507      	push	{r0, r1, r2, lr}
    PacketType = packetType;
 803a4ae:	4b09      	ldr	r3, [pc, #36]	; (803a4d4 <SUBGRF_SetPacketType+0x28>)
{
 803a4b0:	f88d 0007 	strb.w	r0, [sp, #7]
 803a4b4:	4601      	mov	r1, r0
    PacketType = packetType;
 803a4b6:	7098      	strb	r0, [r3, #2]
    if( packetType == PACKET_TYPE_GFSK )
 803a4b8:	b918      	cbnz	r0, 803a4c2 <SUBGRF_SetPacketType+0x16>
        SUBGRF_WriteRegister( REG_BIT_SYNC, 0x00 );
 803a4ba:	f240 60ac 	movw	r0, #1708	; 0x6ac
 803a4be:	f7ff ffb1 	bl	803a424 <SUBGRF_WriteRegister>
    SUBGRF_WriteCommand( RADIO_SET_PACKETTYPE, ( uint8_t* )&packetType, 1 );
 803a4c2:	2201      	movs	r2, #1
 803a4c4:	f10d 0107 	add.w	r1, sp, #7
 803a4c8:	208a      	movs	r0, #138	; 0x8a
 803a4ca:	f7ff fe05 	bl	803a0d8 <SUBGRF_WriteCommand>
}
 803a4ce:	b003      	add	sp, #12
 803a4d0:	f85d fb04 	ldr.w	pc, [sp], #4
 803a4d4:	20005a80 	.word	0x20005a80

0803a4d8 <SUBGRF_SetModulationParams>:
{
 803a4d8:	b513      	push	{r0, r1, r4, lr}
    uint8_t buf[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 803a4da:	4a31      	ldr	r2, [pc, #196]	; (803a5a0 <SUBGRF_SetModulationParams+0xc8>)
{
 803a4dc:	4604      	mov	r4, r0
    uint8_t buf[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 803a4de:	6851      	ldr	r1, [r2, #4]
 803a4e0:	6810      	ldr	r0, [r2, #0]
 803a4e2:	466b      	mov	r3, sp
 803a4e4:	c303      	stmia	r3!, {r0, r1}
    if( PacketType != modulationParams->PacketType )
 803a4e6:	4b2f      	ldr	r3, [pc, #188]	; (803a5a4 <SUBGRF_SetModulationParams+0xcc>)
 803a4e8:	7820      	ldrb	r0, [r4, #0]
 803a4ea:	789b      	ldrb	r3, [r3, #2]
 803a4ec:	4283      	cmp	r3, r0
 803a4ee:	d001      	beq.n	803a4f4 <SUBGRF_SetModulationParams+0x1c>
        SUBGRF_SetPacketType( modulationParams->PacketType );
 803a4f0:	f7ff ffdc 	bl	803a4ac <SUBGRF_SetPacketType>
    switch( modulationParams->PacketType )
 803a4f4:	7823      	ldrb	r3, [r4, #0]
 803a4f6:	2b03      	cmp	r3, #3
 803a4f8:	d827      	bhi.n	803a54a <SUBGRF_SetModulationParams+0x72>
 803a4fa:	e8df f003 	tbb	[pc, r3]
 803a4fe:	3902      	.short	0x3902
 803a500:	3c28      	.short	0x3c28
        tempVal = ( uint32_t )(( 32 * XTAL_FREQ ) / modulationParams->Params.Gfsk.BitRate );
 803a502:	6862      	ldr	r2, [r4, #4]
 803a504:	4b28      	ldr	r3, [pc, #160]	; (803a5a8 <SUBGRF_SetModulationParams+0xd0>)
 803a506:	fbb3 f3f2 	udiv	r3, r3, r2
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 803a50a:	0c1a      	lsrs	r2, r3, #16
        SX_FREQ_TO_CHANNEL(tempVal, modulationParams->Params.Gfsk.Fdev);
 803a50c:	68a1      	ldr	r1, [r4, #8]
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 803a50e:	f88d 2000 	strb.w	r2, [sp]
        buf[2] = tempVal & 0xFF;
 803a512:	f88d 3002 	strb.w	r3, [sp, #2]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 803a516:	0a1a      	lsrs	r2, r3, #8
        buf[3] = modulationParams->Params.Gfsk.ModulationShaping;
 803a518:	7b23      	ldrb	r3, [r4, #12]
 803a51a:	f88d 3003 	strb.w	r3, [sp, #3]
        buf[4] = modulationParams->Params.Gfsk.Bandwidth;
 803a51e:	7b63      	ldrb	r3, [r4, #13]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 803a520:	f88d 2001 	strb.w	r2, [sp, #1]
        buf[4] = modulationParams->Params.Gfsk.Bandwidth;
 803a524:	f88d 3004 	strb.w	r3, [sp, #4]
        SX_FREQ_TO_CHANNEL(tempVal, modulationParams->Params.Gfsk.Fdev);
 803a528:	4a20      	ldr	r2, [pc, #128]	; (803a5ac <SUBGRF_SetModulationParams+0xd4>)
 803a52a:	2300      	movs	r3, #0
 803a52c:	0648      	lsls	r0, r1, #25
 803a52e:	09c9      	lsrs	r1, r1, #7
 803a530:	f7f1 fb08 	bl	802bb44 <__aeabi_uldivmod>
        buf[5] = ( tempVal >> 16 ) & 0xFF;
 803a534:	0c03      	lsrs	r3, r0, #16
        buf[6] = ( tempVal >> 8 ) & 0xFF;
 803a536:	ba40      	rev16	r0, r0
        buf[5] = ( tempVal >> 16 ) & 0xFF;
 803a538:	f88d 3005 	strb.w	r3, [sp, #5]
        buf[6] = ( tempVal >> 8 ) & 0xFF;
 803a53c:	f8ad 0006 	strh.w	r0, [sp, #6]
        SUBGRF_WriteCommand( RADIO_SET_MODULATIONPARAMS, buf, n );
 803a540:	2208      	movs	r2, #8
        SUBGRF_WriteCommand( RADIO_SET_MODULATIONPARAMS, buf, n );
 803a542:	4669      	mov	r1, sp
 803a544:	208b      	movs	r0, #139	; 0x8b
 803a546:	f7ff fdc7 	bl	803a0d8 <SUBGRF_WriteCommand>
}
 803a54a:	b002      	add	sp, #8
 803a54c:	bd10      	pop	{r4, pc}
        tempVal = ( uint32_t ) (( 32 * XTAL_FREQ) / modulationParams->Params.Bpsk.BitRate );
 803a54e:	6922      	ldr	r2, [r4, #16]
 803a550:	4b15      	ldr	r3, [pc, #84]	; (803a5a8 <SUBGRF_SetModulationParams+0xd0>)
 803a552:	fbb3 f3f2 	udiv	r3, r3, r2
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 803a556:	0c1a      	lsrs	r2, r3, #16
 803a558:	f88d 2000 	strb.w	r2, [sp]
        buf[2] = tempVal & 0xFF;
 803a55c:	f88d 3002 	strb.w	r3, [sp, #2]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 803a560:	0a1a      	lsrs	r2, r3, #8
        buf[3] = modulationParams->Params.Bpsk.ModulationShaping;
 803a562:	7d23      	ldrb	r3, [r4, #20]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 803a564:	f88d 2001 	strb.w	r2, [sp, #1]
        buf[3] = modulationParams->Params.Bpsk.ModulationShaping;
 803a568:	f88d 3003 	strb.w	r3, [sp, #3]
        SUBGRF_WriteCommand( RADIO_SET_MODULATIONPARAMS, buf, n );
 803a56c:	2204      	movs	r2, #4
 803a56e:	e7e8      	b.n	803a542 <SUBGRF_SetModulationParams+0x6a>
        buf[0] = modulationParams->Params.LoRa.SpreadingFactor;
 803a570:	69a3      	ldr	r3, [r4, #24]
 803a572:	9300      	str	r3, [sp, #0]
 803a574:	e7fa      	b.n	803a56c <SUBGRF_SetModulationParams+0x94>
        tempVal = ( uint32_t )(( 32 *XTAL_FREQ) / modulationParams->Params.Gfsk.BitRate );
 803a576:	6862      	ldr	r2, [r4, #4]
 803a578:	4b0b      	ldr	r3, [pc, #44]	; (803a5a8 <SUBGRF_SetModulationParams+0xd0>)
 803a57a:	fbb3 f3f2 	udiv	r3, r3, r2
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 803a57e:	0c1a      	lsrs	r2, r3, #16
 803a580:	f88d 2000 	strb.w	r2, [sp]
        buf[2] = tempVal & 0xFF;
 803a584:	f88d 3002 	strb.w	r3, [sp, #2]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 803a588:	0a1a      	lsrs	r2, r3, #8
        buf[3] = modulationParams->Params.Gfsk.ModulationShaping;
 803a58a:	7b23      	ldrb	r3, [r4, #12]
 803a58c:	f88d 3003 	strb.w	r3, [sp, #3]
        buf[4] = modulationParams->Params.Gfsk.Bandwidth;
 803a590:	7b63      	ldrb	r3, [r4, #13]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 803a592:	f88d 2001 	strb.w	r2, [sp, #1]
        buf[4] = modulationParams->Params.Gfsk.Bandwidth;
 803a596:	f88d 3004 	strb.w	r3, [sp, #4]
        SUBGRF_WriteCommand( RADIO_SET_MODULATIONPARAMS, buf, n );
 803a59a:	2205      	movs	r2, #5
 803a59c:	e7d1      	b.n	803a542 <SUBGRF_SetModulationParams+0x6a>
 803a59e:	bf00      	nop
 803a5a0:	0803bcb4 	.word	0x0803bcb4
 803a5a4:	20005a80 	.word	0x20005a80
 803a5a8:	3d090000 	.word	0x3d090000
 803a5ac:	01e84800 	.word	0x01e84800

0803a5b0 <SUBGRF_ReadRegister>:
{
 803a5b0:	b507      	push	{r0, r1, r2, lr}
    HAL_SUBGHZ_ReadRegisters( &hsubghz, addr, &data, 1 );
 803a5b2:	2301      	movs	r3, #1
{
 803a5b4:	4601      	mov	r1, r0
    HAL_SUBGHZ_ReadRegisters( &hsubghz, addr, &data, 1 );
 803a5b6:	f10d 0207 	add.w	r2, sp, #7
 803a5ba:	4804      	ldr	r0, [pc, #16]	; (803a5cc <SUBGRF_ReadRegister+0x1c>)
 803a5bc:	f7f5 fa6f 	bl	802fa9e <HAL_SUBGHZ_ReadRegisters>
}
 803a5c0:	f89d 0007 	ldrb.w	r0, [sp, #7]
 803a5c4:	b003      	add	sp, #12
 803a5c6:	f85d fb04 	ldr.w	pc, [sp], #4
 803a5ca:	bf00      	nop
 803a5cc:	200061f0 	.word	0x200061f0

0803a5d0 <Radio_SMPS_Set>:
{
    RadioOnDioIrqCb( IRQ_HEADER_VALID );
}

static void Radio_SMPS_Set(uint8_t level)
{
 803a5d0:	b510      	push	{r4, lr}
 803a5d2:	4604      	mov	r4, r0
  if ( 1U == RBI_IsDCDC() )
 803a5d4:	f7f2 fdd6 	bl	802d184 <RBI_IsDCDC>
 803a5d8:	2801      	cmp	r0, #1
 803a5da:	d10c      	bne.n	803a5f6 <Radio_SMPS_Set+0x26>
  {
    uint8_t modReg;
    modReg= SUBGRF_ReadRegister(SUBGHZ_SMPSC2R);
 803a5dc:	f640 1023 	movw	r0, #2339	; 0x923
 803a5e0:	f7ff ffe6 	bl	803a5b0 <SUBGRF_ReadRegister>
    modReg&= (~SMPS_DRV_MASK);
    SUBGRF_WriteRegister(SUBGHZ_SMPSC2R, modReg | level);
 803a5e4:	f000 01f9 	and.w	r1, r0, #249	; 0xf9
 803a5e8:	4321      	orrs	r1, r4
 803a5ea:	f640 1023 	movw	r0, #2339	; 0x923
  }
}
 803a5ee:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    SUBGRF_WriteRegister(SUBGHZ_SMPSC2R, modReg | level);
 803a5f2:	f7ff bf17 	b.w	803a424 <SUBGRF_WriteRegister>
}
 803a5f6:	bd10      	pop	{r4, pc}

0803a5f8 <SUBGRF_Init>:
{
 803a5f8:	b538      	push	{r3, r4, r5, lr}
 803a5fa:	4c16      	ldr	r4, [pc, #88]	; (803a654 <SUBGRF_Init+0x5c>)
    if ( dioIrq != NULL)
 803a5fc:	b100      	cbz	r0, 803a600 <SUBGRF_Init+0x8>
        RadioOnDioIrqCb = dioIrq;
 803a5fe:	60a0      	str	r0, [r4, #8]
    RADIO_INIT();
 803a600:	f7f1 ff24 	bl	802c44c <MX_SUBGHZ_Init>
    ImageCalibrated = false;
 803a604:	2500      	movs	r5, #0
    Radio_SMPS_Set(SMPS_DRIVE_SETTING_DEFAULT);
 803a606:	2002      	movs	r0, #2
 803a608:	f7ff ffe2 	bl	803a5d0 <Radio_SMPS_Set>
    SUBGRF_SetStandby( STDBY_RC );
 803a60c:	4628      	mov	r0, r5
    ImageCalibrated = false;
 803a60e:	7065      	strb	r5, [r4, #1]
    SUBGRF_SetStandby( STDBY_RC );
 803a610:	f7ff fd88 	bl	803a124 <SUBGRF_SetStandby>
    if (1U == RBI_IsTCXO() )
 803a614:	f7f2 fdb4 	bl	802d180 <RBI_IsTCXO>
 803a618:	2801      	cmp	r0, #1
 803a61a:	d110      	bne.n	803a63e <SUBGRF_Init+0x46>
        SUBGRF_SetTcxoMode( TCXO_CTRL_VOLTAGE, RF_WAKEUP_TIME << 6 );// 100 ms
 803a61c:	2140      	movs	r1, #64	; 0x40
 803a61e:	f7ff fe7a 	bl	803a316 <SUBGRF_SetTcxoMode>
        SUBGRF_WriteRegister( REG_XTA_TRIM, 0x00 );
 803a622:	f640 1011 	movw	r0, #2321	; 0x911
 803a626:	4629      	mov	r1, r5
 803a628:	f7ff fefc 	bl	803a424 <SUBGRF_WriteRegister>
        SUBGRF_Calibrate( calibParam );
 803a62c:	f04f 007f 	mov.w	r0, #127	; 0x7f
 803a630:	f7ff fe09 	bl	803a246 <SUBGRF_Calibrate>
    RBI_Init();
 803a634:	f7f2 fd9e 	bl	802d174 <RBI_Init>
    OperatingMode = MODE_STDBY_RC;
 803a638:	2301      	movs	r3, #1
 803a63a:	7023      	strb	r3, [r4, #0]
}
 803a63c:	bd38      	pop	{r3, r4, r5, pc}
        SUBGRF_WriteRegister( REG_XTA_TRIM, XTAL_DEFAULT_CAP_VALUE );
 803a63e:	2120      	movs	r1, #32
 803a640:	f640 1011 	movw	r0, #2321	; 0x911
 803a644:	f7ff feee 	bl	803a424 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_XTB_TRIM, XTAL_DEFAULT_CAP_VALUE );
 803a648:	2120      	movs	r1, #32
 803a64a:	f640 1012 	movw	r0, #2322	; 0x912
 803a64e:	f7ff fee9 	bl	803a424 <SUBGRF_WriteRegister>
 803a652:	e7ef      	b.n	803a634 <SUBGRF_Init+0x3c>
 803a654:	20005a80 	.word	0x20005a80

0803a658 <SUBGRF_SetSleep>:
{
 803a658:	b513      	push	{r0, r1, r4, lr}
 803a65a:	4604      	mov	r4, r0
    RBI_ConfigRFSwitch(RBI_SWITCH_OFF);
 803a65c:	2000      	movs	r0, #0
 803a65e:	f7f2 fd8b 	bl	802d178 <RBI_ConfigRFSwitch>
    Radio_SMPS_Set(SMPS_DRIVE_SETTING_DEFAULT);
 803a662:	2002      	movs	r0, #2
 803a664:	f7ff ffb4 	bl	803a5d0 <Radio_SMPS_Set>
                      ( ( uint8_t )sleepConfig.Fields.Reset << 1 ) |
 803a668:	f004 0407 	and.w	r4, r4, #7
    SUBGRF_WriteCommand( RADIO_SET_SLEEP, &value, 1 );
 803a66c:	2201      	movs	r2, #1
 803a66e:	f10d 0107 	add.w	r1, sp, #7
 803a672:	2084      	movs	r0, #132	; 0x84
    uint8_t value = ( ( ( uint8_t )sleepConfig.Fields.WarmStart << 2 ) |
 803a674:	f88d 4007 	strb.w	r4, [sp, #7]
    SUBGRF_WriteCommand( RADIO_SET_SLEEP, &value, 1 );
 803a678:	f7ff fd2e 	bl	803a0d8 <SUBGRF_WriteCommand>
    OperatingMode = MODE_SLEEP;
 803a67c:	4b02      	ldr	r3, [pc, #8]	; (803a688 <SUBGRF_SetSleep+0x30>)
 803a67e:	2200      	movs	r2, #0
 803a680:	701a      	strb	r2, [r3, #0]
}
 803a682:	b002      	add	sp, #8
 803a684:	bd10      	pop	{r4, pc}
 803a686:	bf00      	nop
 803a688:	20005a80 	.word	0x20005a80

0803a68c <SUBGRF_SetWhiteningSeed>:
{
 803a68c:	b510      	push	{r4, lr}
    return PacketType;
 803a68e:	4b0c      	ldr	r3, [pc, #48]	; (803a6c0 <SUBGRF_SetWhiteningSeed+0x34>)
    switch( SUBGRF_GetPacketType( ) )
 803a690:	789b      	ldrb	r3, [r3, #2]
{
 803a692:	4604      	mov	r4, r0
    switch( SUBGRF_GetPacketType( ) )
 803a694:	b99b      	cbnz	r3, 803a6be <SUBGRF_SetWhiteningSeed+0x32>
            regValue = SUBGRF_ReadRegister( REG_LR_WHITSEEDBASEADDR_MSB ) & 0xFE;
 803a696:	f44f 60d7 	mov.w	r0, #1720	; 0x6b8
 803a69a:	f7ff ff89 	bl	803a5b0 <SUBGRF_ReadRegister>
            regValue = ( ( seed >> 8 ) & 0x01 ) | regValue;
 803a69e:	f3c4 2100 	ubfx	r1, r4, #8, #1
 803a6a2:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
            SUBGRF_WriteRegister( REG_LR_WHITSEEDBASEADDR_MSB, regValue ); // only 1 bit.
 803a6a6:	4301      	orrs	r1, r0
 803a6a8:	f44f 60d7 	mov.w	r0, #1720	; 0x6b8
 803a6ac:	f7ff feba 	bl	803a424 <SUBGRF_WriteRegister>
            SUBGRF_WriteRegister( REG_LR_WHITSEEDBASEADDR_LSB, (uint8_t)seed );
 803a6b0:	b2e1      	uxtb	r1, r4
 803a6b2:	f240 60b9 	movw	r0, #1721	; 0x6b9
}
 803a6b6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            SUBGRF_WriteRegister( REG_LR_WHITSEEDBASEADDR_LSB, (uint8_t)seed );
 803a6ba:	f7ff beb3 	b.w	803a424 <SUBGRF_WriteRegister>
}
 803a6be:	bd10      	pop	{r4, pc}
 803a6c0:	20005a80 	.word	0x20005a80

0803a6c4 <SUBGRF_SetTxParams>:
    if( paSelect == RFO_LP )
 803a6c4:	2801      	cmp	r0, #1
{
 803a6c6:	b537      	push	{r0, r1, r2, r4, r5, lr}
 803a6c8:	4603      	mov	r3, r0
 803a6ca:	460c      	mov	r4, r1
 803a6cc:	4615      	mov	r5, r2
    if( paSelect == RFO_LP )
 803a6ce:	d120      	bne.n	803a712 <SUBGRF_SetTxParams+0x4e>
        if( power == 15 )
 803a6d0:	2c0f      	cmp	r4, #15
            SUBGRF_SetPaConfig( 0x06, 0x00, 0x01, 0x01 );
 803a6d2:	4602      	mov	r2, r0
 803a6d4:	f04f 0100 	mov.w	r1, #0
 803a6d8:	bf0c      	ite	eq
 803a6da:	2006      	moveq	r0, #6
            SUBGRF_SetPaConfig( 0x04, 0x00, 0x01, 0x01 );
 803a6dc:	2004      	movne	r0, #4
 803a6de:	f7ff fdf3 	bl	803a2c8 <SUBGRF_SetPaConfig>
        if( power >= 14 )
 803a6e2:	f06f 0110 	mvn.w	r1, #16
 803a6e6:	428c      	cmp	r4, r1
 803a6e8:	bfb8      	it	lt
 803a6ea:	460c      	movlt	r4, r1
 803a6ec:	2c0e      	cmp	r4, #14
 803a6ee:	bfa8      	it	ge
 803a6f0:	240e      	movge	r4, #14
        SUBGRF_WriteRegister( REG_OCP, 0x18 ); // current max is 80 mA for the whole device
 803a6f2:	2118      	movs	r1, #24
        SUBGRF_WriteRegister( REG_OCP, 0x38 ); // current max 160mA for the whole device
 803a6f4:	f640 00e7 	movw	r0, #2279	; 0x8e7
 803a6f8:	f7ff fe94 	bl	803a424 <SUBGRF_WriteRegister>
    SUBGRF_WriteCommand( RADIO_SET_TXPARAMS, buf, 2 );
 803a6fc:	2202      	movs	r2, #2
 803a6fe:	a901      	add	r1, sp, #4
 803a700:	208e      	movs	r0, #142	; 0x8e
    buf[0] = power;
 803a702:	f88d 4004 	strb.w	r4, [sp, #4]
    buf[1] = ( uint8_t )rampTime;
 803a706:	f88d 5005 	strb.w	r5, [sp, #5]
    SUBGRF_WriteCommand( RADIO_SET_TXPARAMS, buf, 2 );
 803a70a:	f7ff fce5 	bl	803a0d8 <SUBGRF_WriteCommand>
}
 803a70e:	b003      	add	sp, #12
 803a710:	bd30      	pop	{r4, r5, pc}
        SUBGRF_WriteRegister( REG_TX_CLAMP, SUBGRF_ReadRegister( REG_TX_CLAMP ) | ( 0x0F << 1 ) );
 803a712:	f640 00d8 	movw	r0, #2264	; 0x8d8
 803a716:	f7ff ff4b 	bl	803a5b0 <SUBGRF_ReadRegister>
 803a71a:	f040 011e 	orr.w	r1, r0, #30
 803a71e:	b2c9      	uxtb	r1, r1
 803a720:	f640 00d8 	movw	r0, #2264	; 0x8d8
 803a724:	f7ff fe7e 	bl	803a424 <SUBGRF_WriteRegister>
        SUBGRF_SetPaConfig( 0x04, 0x07, 0x00, 0x01 );
 803a728:	2107      	movs	r1, #7
 803a72a:	2301      	movs	r3, #1
 803a72c:	2200      	movs	r2, #0
 803a72e:	2004      	movs	r0, #4
 803a730:	f7ff fdca 	bl	803a2c8 <SUBGRF_SetPaConfig>
        if( power > 22 )
 803a734:	f06f 0108 	mvn.w	r1, #8
 803a738:	428c      	cmp	r4, r1
 803a73a:	bfb8      	it	lt
 803a73c:	460c      	movlt	r4, r1
 803a73e:	2c16      	cmp	r4, #22
 803a740:	bfa8      	it	ge
 803a742:	2416      	movge	r4, #22
        SUBGRF_WriteRegister( REG_OCP, 0x38 ); // current max 160mA for the whole device
 803a744:	2138      	movs	r1, #56	; 0x38
 803a746:	e7d5      	b.n	803a6f4 <SUBGRF_SetTxParams+0x30>

0803a748 <SUBGRF_GetRxBufferStatus>:
{
 803a748:	b537      	push	{r0, r1, r2, r4, r5, lr}
    SUBGRF_ReadCommand( RADIO_GET_RXBUFFERSTATUS, status, 2 );
 803a74a:	2202      	movs	r2, #2
{
 803a74c:	4604      	mov	r4, r0
 803a74e:	460d      	mov	r5, r1
    SUBGRF_ReadCommand( RADIO_GET_RXBUFFERSTATUS, status, 2 );
 803a750:	2013      	movs	r0, #19
 803a752:	a901      	add	r1, sp, #4
 803a754:	f7ff fcd0 	bl	803a0f8 <SUBGRF_ReadCommand>
    return PacketType;
 803a758:	4b0a      	ldr	r3, [pc, #40]	; (803a784 <SUBGRF_GetRxBufferStatus+0x3c>)
    if( ( SUBGRF_GetPacketType( ) == PACKET_TYPE_LORA ) && ( LoRaHeaderType == LORA_PACKET_FIXED_LENGTH ) )
 803a75a:	789a      	ldrb	r2, [r3, #2]
 803a75c:	2a01      	cmp	r2, #1
 803a75e:	d10c      	bne.n	803a77a <SUBGRF_GetRxBufferStatus+0x32>
 803a760:	7b1b      	ldrb	r3, [r3, #12]
 803a762:	2b01      	cmp	r3, #1
 803a764:	d109      	bne.n	803a77a <SUBGRF_GetRxBufferStatus+0x32>
        *payloadLength = SUBGRF_ReadRegister( REG_LR_PAYLOADLENGTH );
 803a766:	f240 7002 	movw	r0, #1794	; 0x702
 803a76a:	f7ff ff21 	bl	803a5b0 <SUBGRF_ReadRegister>
 803a76e:	7020      	strb	r0, [r4, #0]
    *rxStartBufferPointer = status[1];
 803a770:	f89d 3005 	ldrb.w	r3, [sp, #5]
 803a774:	702b      	strb	r3, [r5, #0]
}
 803a776:	b003      	add	sp, #12
 803a778:	bd30      	pop	{r4, r5, pc}
        *payloadLength = status[0];
 803a77a:	f89d 3004 	ldrb.w	r3, [sp, #4]
 803a77e:	7023      	strb	r3, [r4, #0]
 803a780:	e7f6      	b.n	803a770 <SUBGRF_GetRxBufferStatus+0x28>
 803a782:	bf00      	nop
 803a784:	20005a80 	.word	0x20005a80

0803a788 <SUBGRF_WriteRegisters>:
{
 803a788:	b510      	push	{r4, lr}
 803a78a:	4613      	mov	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803a78c:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803a790:	b672      	cpsid	i
    HAL_SUBGHZ_WriteRegisters( &hsubghz, address, buffer, size );
 803a792:	460a      	mov	r2, r1
 803a794:	4601      	mov	r1, r0
 803a796:	4803      	ldr	r0, [pc, #12]	; (803a7a4 <SUBGRF_WriteRegisters+0x1c>)
 803a798:	f7f5 f948 	bl	802fa2c <HAL_SUBGHZ_WriteRegisters>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803a79c:	f384 8810 	msr	PRIMASK, r4
}
 803a7a0:	bd10      	pop	{r4, pc}
 803a7a2:	bf00      	nop
 803a7a4:	200061f0 	.word	0x200061f0

0803a7a8 <SUBGRF_SetSyncWord>:
{
 803a7a8:	b508      	push	{r3, lr}
 803a7aa:	4601      	mov	r1, r0
    SUBGRF_WriteRegisters( REG_LR_SYNCWORDBASEADDRESS, syncWord, 8 );
 803a7ac:	2208      	movs	r2, #8
 803a7ae:	f44f 60d8 	mov.w	r0, #1728	; 0x6c0
 803a7b2:	f7ff ffe9 	bl	803a788 <SUBGRF_WriteRegisters>
}
 803a7b6:	2000      	movs	r0, #0
 803a7b8:	bd08      	pop	{r3, pc}
	...

0803a7bc <SUBGRF_SetCrcSeed>:
{
 803a7bc:	b507      	push	{r0, r1, r2, lr}
    return PacketType;
 803a7be:	4b07      	ldr	r3, [pc, #28]	; (803a7dc <SUBGRF_SetCrcSeed+0x20>)
    switch( SUBGRF_GetPacketType( ) )
 803a7c0:	789b      	ldrb	r3, [r3, #2]
    buf[0] = ( uint8_t )( ( seed >> 8 ) & 0xFF );
 803a7c2:	ba40      	rev16	r0, r0
 803a7c4:	f8ad 0004 	strh.w	r0, [sp, #4]
    switch( SUBGRF_GetPacketType( ) )
 803a7c8:	b92b      	cbnz	r3, 803a7d6 <SUBGRF_SetCrcSeed+0x1a>
            SUBGRF_WriteRegisters( REG_LR_CRCSEEDBASEADDR, buf, 2 );
 803a7ca:	2202      	movs	r2, #2
 803a7cc:	a901      	add	r1, sp, #4
 803a7ce:	f240 60bc 	movw	r0, #1724	; 0x6bc
 803a7d2:	f7ff ffd9 	bl	803a788 <SUBGRF_WriteRegisters>
}
 803a7d6:	b003      	add	sp, #12
 803a7d8:	f85d fb04 	ldr.w	pc, [sp], #4
 803a7dc:	20005a80 	.word	0x20005a80

0803a7e0 <SUBGRF_SetCrcPolynomial>:
{
 803a7e0:	b507      	push	{r0, r1, r2, lr}
    return PacketType;
 803a7e2:	4b07      	ldr	r3, [pc, #28]	; (803a800 <SUBGRF_SetCrcPolynomial+0x20>)
    switch( SUBGRF_GetPacketType( ) )
 803a7e4:	789b      	ldrb	r3, [r3, #2]
    buf[0] = ( uint8_t )( ( polynomial >> 8 ) & 0xFF );
 803a7e6:	ba40      	rev16	r0, r0
 803a7e8:	f8ad 0004 	strh.w	r0, [sp, #4]
    switch( SUBGRF_GetPacketType( ) )
 803a7ec:	b92b      	cbnz	r3, 803a7fa <SUBGRF_SetCrcPolynomial+0x1a>
            SUBGRF_WriteRegisters( REG_LR_CRCPOLYBASEADDR, buf, 2 );
 803a7ee:	2202      	movs	r2, #2
 803a7f0:	a901      	add	r1, sp, #4
 803a7f2:	f240 60be 	movw	r0, #1726	; 0x6be
 803a7f6:	f7ff ffc7 	bl	803a788 <SUBGRF_WriteRegisters>
}
 803a7fa:	b003      	add	sp, #12
 803a7fc:	f85d fb04 	ldr.w	pc, [sp], #4
 803a800:	20005a80 	.word	0x20005a80

0803a804 <SUBGRF_SetPacketParams>:
{
 803a804:	b530      	push	{r4, r5, lr}
    uint8_t buf[9] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 803a806:	4a2e      	ldr	r2, [pc, #184]	; (803a8c0 <SUBGRF_SetPacketParams+0xbc>)
    if( PacketType != packetParams->PacketType )
 803a808:	4d2e      	ldr	r5, [pc, #184]	; (803a8c4 <SUBGRF_SetPacketParams+0xc0>)
    uint8_t buf[9] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 803a80a:	6851      	ldr	r1, [r2, #4]
{
 803a80c:	4604      	mov	r4, r0
 803a80e:	b085      	sub	sp, #20
    uint8_t buf[9] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 803a810:	6810      	ldr	r0, [r2, #0]
 803a812:	7a12      	ldrb	r2, [r2, #8]
 803a814:	ab01      	add	r3, sp, #4
 803a816:	c303      	stmia	r3!, {r0, r1}
    if( PacketType != packetParams->PacketType )
 803a818:	7820      	ldrb	r0, [r4, #0]
    uint8_t buf[9] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 803a81a:	701a      	strb	r2, [r3, #0]
    if( PacketType != packetParams->PacketType )
 803a81c:	78aa      	ldrb	r2, [r5, #2]
 803a81e:	4282      	cmp	r2, r0
 803a820:	d001      	beq.n	803a826 <SUBGRF_SetPacketParams+0x22>
        SUBGRF_SetPacketType( packetParams->PacketType );
 803a822:	f7ff fe43 	bl	803a4ac <SUBGRF_SetPacketType>
    switch( packetParams->PacketType )
 803a826:	7823      	ldrb	r3, [r4, #0]
 803a828:	2b03      	cmp	r3, #3
 803a82a:	d826      	bhi.n	803a87a <SUBGRF_SetPacketParams+0x76>
 803a82c:	e8df f003 	tbb	[pc, r3]
 803a830:	02333802 	.word	0x02333802
        if( packetParams->Params.Gfsk.CrcLength == RADIO_CRC_2_BYTES_IBM )
 803a834:	7a63      	ldrb	r3, [r4, #9]
 803a836:	2bf1      	cmp	r3, #241	; 0xf1
 803a838:	d121      	bne.n	803a87e <SUBGRF_SetPacketParams+0x7a>
            SUBGRF_SetCrcSeed( CRC_IBM_SEED );
 803a83a:	f64f 70ff 	movw	r0, #65535	; 0xffff
 803a83e:	f7ff ffbd 	bl	803a7bc <SUBGRF_SetCrcSeed>
            SUBGRF_SetCrcPolynomial( CRC_POLYNOMIAL_IBM );
 803a842:	f248 0005 	movw	r0, #32773	; 0x8005
 803a846:	f7ff ffcb 	bl	803a7e0 <SUBGRF_SetCrcPolynomial>
            crcVal = RADIO_CRC_2_BYTES;
 803a84a:	2302      	movs	r3, #2
        buf[0] = ( packetParams->Params.Gfsk.PreambleLength >> 8 ) & 0xFF;
 803a84c:	8862      	ldrh	r2, [r4, #2]
        buf[2] = packetParams->Params.Gfsk.PreambleMinDetect;
 803a84e:	88a1      	ldrh	r1, [r4, #4]
 803a850:	f8ad 1006 	strh.w	r1, [sp, #6]
        buf[0] = ( packetParams->Params.Gfsk.PreambleLength >> 8 ) & 0xFF;
 803a854:	ba52      	rev16	r2, r2
        buf[4] = packetParams->Params.Gfsk.AddrComp;
 803a856:	88e1      	ldrh	r1, [r4, #6]
        buf[0] = ( packetParams->Params.Gfsk.PreambleLength >> 8 ) & 0xFF;
 803a858:	f8ad 2004 	strh.w	r2, [sp, #4]
        buf[7] = crcVal;
 803a85c:	f88d 300b 	strb.w	r3, [sp, #11]
        buf[6] = packetParams->Params.Gfsk.PayloadLength;
 803a860:	7a22      	ldrb	r2, [r4, #8]
        buf[8] = packetParams->Params.Gfsk.DcFree;
 803a862:	7aa3      	ldrb	r3, [r4, #10]
        buf[6] = packetParams->Params.Gfsk.PayloadLength;
 803a864:	f88d 200a 	strb.w	r2, [sp, #10]
        buf[4] = packetParams->Params.Gfsk.AddrComp;
 803a868:	f8ad 1008 	strh.w	r1, [sp, #8]
        buf[8] = packetParams->Params.Gfsk.DcFree;
 803a86c:	f88d 300c 	strb.w	r3, [sp, #12]
        n = 9;
 803a870:	2209      	movs	r2, #9
    SUBGRF_WriteCommand( RADIO_SET_PACKETPARAMS, buf, n );
 803a872:	a901      	add	r1, sp, #4
 803a874:	208c      	movs	r0, #140	; 0x8c
 803a876:	f7ff fc2f 	bl	803a0d8 <SUBGRF_WriteCommand>
}
 803a87a:	b005      	add	sp, #20
 803a87c:	bd30      	pop	{r4, r5, pc}
        else if( packetParams->Params.Gfsk.CrcLength == RADIO_CRC_2_BYTES_CCIT )
 803a87e:	2bf2      	cmp	r3, #242	; 0xf2
 803a880:	d1e4      	bne.n	803a84c <SUBGRF_SetPacketParams+0x48>
            SUBGRF_SetCrcSeed( CRC_CCITT_SEED );
 803a882:	f641 500f 	movw	r0, #7439	; 0x1d0f
 803a886:	f7ff ff99 	bl	803a7bc <SUBGRF_SetCrcSeed>
            SUBGRF_SetCrcPolynomial( CRC_POLYNOMIAL_CCITT );
 803a88a:	f241 0021 	movw	r0, #4129	; 0x1021
 803a88e:	f7ff ffa7 	bl	803a7e0 <SUBGRF_SetCrcPolynomial>
            crcVal = RADIO_CRC_2_BYTES_INV;
 803a892:	2306      	movs	r3, #6
 803a894:	e7da      	b.n	803a84c <SUBGRF_SetPacketParams+0x48>
        buf[0] = packetParams->Params.Bpsk.PayloadLength;
 803a896:	7b23      	ldrb	r3, [r4, #12]
 803a898:	f88d 3004 	strb.w	r3, [sp, #4]
        n = 1;
 803a89c:	2201      	movs	r2, #1
        break;
 803a89e:	e7e8      	b.n	803a872 <SUBGRF_SetPacketParams+0x6e>
        buf[0] = ( packetParams->Params.LoRa.PreambleLength >> 8 ) & 0xFF;
 803a8a0:	89e3      	ldrh	r3, [r4, #14]
 803a8a2:	ba5b      	rev16	r3, r3
 803a8a4:	f8ad 3004 	strh.w	r3, [sp, #4]
        buf[2] = LoRaHeaderType = packetParams->Params.LoRa.HeaderType;
 803a8a8:	7c23      	ldrb	r3, [r4, #16]
 803a8aa:	732b      	strb	r3, [r5, #12]
 803a8ac:	f88d 3006 	strb.w	r3, [sp, #6]
        buf[3] = packetParams->Params.LoRa.PayloadLength;
 803a8b0:	7c63      	ldrb	r3, [r4, #17]
 803a8b2:	f88d 3007 	strb.w	r3, [sp, #7]
        buf[4] = packetParams->Params.LoRa.CrcMode;
 803a8b6:	8a63      	ldrh	r3, [r4, #18]
 803a8b8:	f8ad 3008 	strh.w	r3, [sp, #8]
        n = 6;
 803a8bc:	2206      	movs	r2, #6
        break;
 803a8be:	e7d8      	b.n	803a872 <SUBGRF_SetPacketParams+0x6e>
 803a8c0:	0803bcbc 	.word	0x0803bcbc
 803a8c4:	20005a80 	.word	0x20005a80

0803a8c8 <SUBGRF_ReadRegisters>:
{
 803a8c8:	b510      	push	{r4, lr}
 803a8ca:	4613      	mov	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803a8cc:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803a8d0:	b672      	cpsid	i
    HAL_SUBGHZ_ReadRegisters( &hsubghz, address, buffer, size );
 803a8d2:	460a      	mov	r2, r1
 803a8d4:	4601      	mov	r1, r0
 803a8d6:	4803      	ldr	r0, [pc, #12]	; (803a8e4 <SUBGRF_ReadRegisters+0x1c>)
 803a8d8:	f7f5 f8e1 	bl	802fa9e <HAL_SUBGHZ_ReadRegisters>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803a8dc:	f384 8810 	msr	PRIMASK, r4
}
 803a8e0:	bd10      	pop	{r4, pc}
 803a8e2:	bf00      	nop
 803a8e4:	200061f0 	.word	0x200061f0

0803a8e8 <SUBGRF_GetRandom>:
{
 803a8e8:	b573      	push	{r0, r1, r4, r5, r6, lr}
    uint32_t number = 0;
 803a8ea:	2600      	movs	r6, #0
    regAnaLna = SUBGRF_ReadRegister( REG_ANA_LNA );
 803a8ec:	f640 00e2 	movw	r0, #2274	; 0x8e2
    uint32_t number = 0;
 803a8f0:	9601      	str	r6, [sp, #4]
    regAnaLna = SUBGRF_ReadRegister( REG_ANA_LNA );
 803a8f2:	f7ff fe5d 	bl	803a5b0 <SUBGRF_ReadRegister>
    SUBGRF_WriteRegister( REG_ANA_LNA, regAnaLna & ~( 1 << 0 ) );
 803a8f6:	f000 01fe 	and.w	r1, r0, #254	; 0xfe
    regAnaLna = SUBGRF_ReadRegister( REG_ANA_LNA );
 803a8fa:	4605      	mov	r5, r0
    SUBGRF_WriteRegister( REG_ANA_LNA, regAnaLna & ~( 1 << 0 ) );
 803a8fc:	f640 00e2 	movw	r0, #2274	; 0x8e2
 803a900:	f7ff fd90 	bl	803a424 <SUBGRF_WriteRegister>
    regAnaMixer = SUBGRF_ReadRegister( REG_ANA_MIXER );
 803a904:	f640 00e5 	movw	r0, #2277	; 0x8e5
 803a908:	f7ff fe52 	bl	803a5b0 <SUBGRF_ReadRegister>
    SUBGRF_WriteRegister( REG_ANA_MIXER, regAnaMixer & ~( 1 << 7 ) );
 803a90c:	f000 017f 	and.w	r1, r0, #127	; 0x7f
    regAnaMixer = SUBGRF_ReadRegister( REG_ANA_MIXER );
 803a910:	4604      	mov	r4, r0
    SUBGRF_WriteRegister( REG_ANA_MIXER, regAnaMixer & ~( 1 << 7 ) );
 803a912:	f640 00e5 	movw	r0, #2277	; 0x8e5
 803a916:	f7ff fd85 	bl	803a424 <SUBGRF_WriteRegister>
    SUBGRF_SetRx( 0xFFFFFF ); // Rx Continuous
 803a91a:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 803a91e:	f7ff fc2d 	bl	803a17c <SUBGRF_SetRx>
    SUBGRF_ReadRegisters( RANDOM_NUMBER_GENERATORBASEADDR, ( uint8_t* )&number, 4 );
 803a922:	2204      	movs	r2, #4
 803a924:	eb0d 0102 	add.w	r1, sp, r2
 803a928:	f640 0019 	movw	r0, #2073	; 0x819
 803a92c:	f7ff ffcc 	bl	803a8c8 <SUBGRF_ReadRegisters>
    SUBGRF_SetStandby( STDBY_RC );
 803a930:	4630      	mov	r0, r6
 803a932:	f7ff fbf7 	bl	803a124 <SUBGRF_SetStandby>
    SUBGRF_WriteRegister( REG_ANA_LNA, regAnaLna );
 803a936:	4629      	mov	r1, r5
 803a938:	f640 00e2 	movw	r0, #2274	; 0x8e2
 803a93c:	f7ff fd72 	bl	803a424 <SUBGRF_WriteRegister>
    SUBGRF_WriteRegister( REG_ANA_MIXER, regAnaMixer );
 803a940:	4621      	mov	r1, r4
 803a942:	f640 00e5 	movw	r0, #2277	; 0x8e5
 803a946:	f7ff fd6d 	bl	803a424 <SUBGRF_WriteRegister>
}
 803a94a:	9801      	ldr	r0, [sp, #4]
 803a94c:	b002      	add	sp, #8
 803a94e:	bd70      	pop	{r4, r5, r6, pc}

0803a950 <SUBGRF_WriteBuffer>:
{
 803a950:	b510      	push	{r4, lr}
 803a952:	4613      	mov	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803a954:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803a958:	b672      	cpsid	i
    HAL_SUBGHZ_WriteBuffer( &hsubghz, offset, buffer, size );
 803a95a:	460a      	mov	r2, r1
 803a95c:	4601      	mov	r1, r0
 803a95e:	4803      	ldr	r0, [pc, #12]	; (803a96c <SUBGRF_WriteBuffer+0x1c>)
 803a960:	f7f5 f910 	bl	802fb84 <HAL_SUBGHZ_WriteBuffer>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803a964:	f384 8810 	msr	PRIMASK, r4
}
 803a968:	bd10      	pop	{r4, pc}
 803a96a:	bf00      	nop
 803a96c:	200061f0 	.word	0x200061f0

0803a970 <SUBGRF_SetPayload>:
{
 803a970:	460a      	mov	r2, r1
    SUBGRF_WriteBuffer( 0x00, payload, size );
 803a972:	4601      	mov	r1, r0
 803a974:	2000      	movs	r0, #0
 803a976:	f7ff bfeb 	b.w	803a950 <SUBGRF_WriteBuffer>

0803a97a <SUBGRF_SendPayload>:
{
 803a97a:	b510      	push	{r4, lr}
 803a97c:	4614      	mov	r4, r2
    SUBGRF_SetPayload( payload, size );
 803a97e:	f7ff fff7 	bl	803a970 <SUBGRF_SetPayload>
    SUBGRF_SetTx( timeout );
 803a982:	4620      	mov	r0, r4
}
 803a984:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    SUBGRF_SetTx( timeout );
 803a988:	f7ff bbe2 	b.w	803a150 <SUBGRF_SetTx>

0803a98c <SUBGRF_ReadBuffer>:
{
 803a98c:	b510      	push	{r4, lr}
 803a98e:	4613      	mov	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803a990:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803a994:	b672      	cpsid	i
    HAL_SUBGHZ_ReadBuffer( &hsubghz, offset, buffer, size );
 803a996:	460a      	mov	r2, r1
 803a998:	4601      	mov	r1, r0
 803a99a:	4803      	ldr	r0, [pc, #12]	; (803a9a8 <SUBGRF_ReadBuffer+0x1c>)
 803a99c:	f7f5 f925 	bl	802fbea <HAL_SUBGHZ_ReadBuffer>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803a9a0:	f384 8810 	msr	PRIMASK, r4
}
 803a9a4:	bd10      	pop	{r4, pc}
 803a9a6:	bf00      	nop
 803a9a8:	200061f0 	.word	0x200061f0

0803a9ac <SUBGRF_GetPayload>:
{
 803a9ac:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 803a9ae:	460d      	mov	r5, r1
 803a9b0:	4606      	mov	r6, r0
    uint8_t offset = 0;
 803a9b2:	2400      	movs	r4, #0
    SUBGRF_GetRxBufferStatus( size, &offset );
 803a9b4:	f10d 0107 	add.w	r1, sp, #7
 803a9b8:	4628      	mov	r0, r5
{
 803a9ba:	4617      	mov	r7, r2
    uint8_t offset = 0;
 803a9bc:	f88d 4007 	strb.w	r4, [sp, #7]
    SUBGRF_GetRxBufferStatus( size, &offset );
 803a9c0:	f7ff fec2 	bl	803a748 <SUBGRF_GetRxBufferStatus>
    if( *size > maxSize )
 803a9c4:	782a      	ldrb	r2, [r5, #0]
 803a9c6:	42ba      	cmp	r2, r7
 803a9c8:	d807      	bhi.n	803a9da <SUBGRF_GetPayload+0x2e>
    SUBGRF_ReadBuffer( offset, buffer, *size );
 803a9ca:	f89d 0007 	ldrb.w	r0, [sp, #7]
 803a9ce:	4631      	mov	r1, r6
 803a9d0:	f7ff ffdc 	bl	803a98c <SUBGRF_ReadBuffer>
    return 0;
 803a9d4:	4620      	mov	r0, r4
}
 803a9d6:	b003      	add	sp, #12
 803a9d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return 1;
 803a9da:	2001      	movs	r0, #1
 803a9dc:	e7fb      	b.n	803a9d6 <SUBGRF_GetPayload+0x2a>

0803a9de <SUBGRF_SetSwitch>:
    if (rxtx == RFSWITCH_TX)
 803a9de:	2901      	cmp	r1, #1
{
 803a9e0:	b508      	push	{r3, lr}
 803a9e2:	4603      	mov	r3, r0
 803a9e4:	4608      	mov	r0, r1
    if (rxtx == RFSWITCH_TX)
 803a9e6:	d10e      	bne.n	803aa06 <SUBGRF_SetSwitch+0x28>
        if (paSelect == RFO_LP)
 803a9e8:	2b01      	cmp	r3, #1
 803a9ea:	d107      	bne.n	803a9fc <SUBGRF_SetSwitch+0x1e>
            Radio_SMPS_Set(SMPS_DRIVE_SETTING_MAX);
 803a9ec:	2004      	movs	r0, #4
 803a9ee:	f7ff fdef 	bl	803a5d0 <Radio_SMPS_Set>
            state = RBI_SWITCH_RFO_LP;
 803a9f2:	2002      	movs	r0, #2
}
 803a9f4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RBI_ConfigRFSwitch(state);
 803a9f8:	f7f2 bbbe 	b.w	802d178 <RBI_ConfigRFSwitch>
        if (paSelect == RFO_HP)
 803a9fc:	2b02      	cmp	r3, #2
            state = RBI_SWITCH_RFO_HP;
 803a9fe:	bf14      	ite	ne
 803aa00:	4608      	movne	r0, r1
 803aa02:	2003      	moveq	r0, #3
 803aa04:	e7f6      	b.n	803a9f4 <SUBGRF_SetSwitch+0x16>
    RBI_Switch_TypeDef state = RBI_SWITCH_RX;
 803aa06:	2001      	movs	r0, #1
 803aa08:	e7f4      	b.n	803a9f4 <SUBGRF_SetSwitch+0x16>

0803aa0a <SUBGRF_SetRfTxPower>:
{
 803aa0a:	b538      	push	{r3, r4, r5, lr}
 803aa0c:	4604      	mov	r4, r0
    int32_t TxConfig = RBI_GetTxConfig();
 803aa0e:	f7f2 fbb5 	bl	802d17c <RBI_GetTxConfig>
    switch (TxConfig)
 803aa12:	b150      	cbz	r0, 803aa2a <SUBGRF_SetRfTxPower+0x20>
 803aa14:	2802      	cmp	r0, #2
 803aa16:	bf14      	ite	ne
 803aa18:	2501      	movne	r5, #1
 803aa1a:	2502      	moveq	r5, #2
    SUBGRF_SetTxParams( paSelect, power, RADIO_RAMP_40_US );
 803aa1c:	4628      	mov	r0, r5
 803aa1e:	2202      	movs	r2, #2
 803aa20:	4621      	mov	r1, r4
 803aa22:	f7ff fe4f 	bl	803a6c4 <SUBGRF_SetTxParams>
}
 803aa26:	4628      	mov	r0, r5
 803aa28:	bd38      	pop	{r3, r4, r5, pc}
            if (power > 15)
 803aa2a:	2c0f      	cmp	r4, #15
                paSelect = RFO_LP;
 803aa2c:	bfcc      	ite	gt
 803aa2e:	2502      	movgt	r5, #2
 803aa30:	2501      	movle	r5, #1
 803aa32:	e7f3      	b.n	803aa1c <SUBGRF_SetRfTxPower+0x12>

0803aa34 <SUBGRF_GetRadioWakeUpTime>:
}
 803aa34:	2001      	movs	r0, #1
 803aa36:	4770      	bx	lr

0803aa38 <HAL_SUBGHZ_TxCpltCallback>:
    RadioOnDioIrqCb( IRQ_TX_DONE );
 803aa38:	4b01      	ldr	r3, [pc, #4]	; (803aa40 <HAL_SUBGHZ_TxCpltCallback+0x8>)
 803aa3a:	2001      	movs	r0, #1
 803aa3c:	689b      	ldr	r3, [r3, #8]
 803aa3e:	4718      	bx	r3
 803aa40:	20005a80 	.word	0x20005a80

0803aa44 <HAL_SUBGHZ_RxCpltCallback>:
    RadioOnDioIrqCb( IRQ_RX_DONE );
 803aa44:	4b01      	ldr	r3, [pc, #4]	; (803aa4c <HAL_SUBGHZ_RxCpltCallback+0x8>)
 803aa46:	2002      	movs	r0, #2
 803aa48:	689b      	ldr	r3, [r3, #8]
 803aa4a:	4718      	bx	r3
 803aa4c:	20005a80 	.word	0x20005a80

0803aa50 <HAL_SUBGHZ_CRCErrorCallback>:
    RadioOnDioIrqCb( IRQ_CRC_ERROR);
 803aa50:	4b01      	ldr	r3, [pc, #4]	; (803aa58 <HAL_SUBGHZ_CRCErrorCallback+0x8>)
 803aa52:	2040      	movs	r0, #64	; 0x40
 803aa54:	689b      	ldr	r3, [r3, #8]
 803aa56:	4718      	bx	r3
 803aa58:	20005a80 	.word	0x20005a80

0803aa5c <HAL_SUBGHZ_CADStatusCallback>:
    switch (cadstatus)
 803aa5c:	b111      	cbz	r1, 803aa64 <HAL_SUBGHZ_CADStatusCallback+0x8>
 803aa5e:	2901      	cmp	r1, #1
 803aa60:	d004      	beq.n	803aa6c <HAL_SUBGHZ_CADStatusCallback+0x10>
 803aa62:	4770      	bx	lr
            RadioOnDioIrqCb( IRQ_CAD_CLEAR);
 803aa64:	4b04      	ldr	r3, [pc, #16]	; (803aa78 <HAL_SUBGHZ_CADStatusCallback+0x1c>)
 803aa66:	689b      	ldr	r3, [r3, #8]
 803aa68:	2080      	movs	r0, #128	; 0x80
            RadioOnDioIrqCb( IRQ_CAD_DETECTED);
 803aa6a:	4718      	bx	r3
 803aa6c:	4b02      	ldr	r3, [pc, #8]	; (803aa78 <HAL_SUBGHZ_CADStatusCallback+0x1c>)
 803aa6e:	f44f 7080 	mov.w	r0, #256	; 0x100
 803aa72:	689b      	ldr	r3, [r3, #8]
 803aa74:	e7f9      	b.n	803aa6a <HAL_SUBGHZ_CADStatusCallback+0xe>
 803aa76:	bf00      	nop
 803aa78:	20005a80 	.word	0x20005a80

0803aa7c <HAL_SUBGHZ_RxTxTimeoutCallback>:
    RadioOnDioIrqCb( IRQ_RX_TX_TIMEOUT );
 803aa7c:	4b02      	ldr	r3, [pc, #8]	; (803aa88 <HAL_SUBGHZ_RxTxTimeoutCallback+0xc>)
 803aa7e:	f44f 7000 	mov.w	r0, #512	; 0x200
 803aa82:	689b      	ldr	r3, [r3, #8]
 803aa84:	4718      	bx	r3
 803aa86:	bf00      	nop
 803aa88:	20005a80 	.word	0x20005a80

0803aa8c <HAL_SUBGHZ_HeaderErrorCallback>:
    RadioOnDioIrqCb( IRQ_HEADER_ERROR );
 803aa8c:	4b01      	ldr	r3, [pc, #4]	; (803aa94 <HAL_SUBGHZ_HeaderErrorCallback+0x8>)
 803aa8e:	2020      	movs	r0, #32
 803aa90:	689b      	ldr	r3, [r3, #8]
 803aa92:	4718      	bx	r3
 803aa94:	20005a80 	.word	0x20005a80

0803aa98 <HAL_SUBGHZ_PreambleDetectedCallback>:
    RadioOnDioIrqCb( IRQ_PREAMBLE_DETECTED );
 803aa98:	4b01      	ldr	r3, [pc, #4]	; (803aaa0 <HAL_SUBGHZ_PreambleDetectedCallback+0x8>)
 803aa9a:	2004      	movs	r0, #4
 803aa9c:	689b      	ldr	r3, [r3, #8]
 803aa9e:	4718      	bx	r3
 803aaa0:	20005a80 	.word	0x20005a80

0803aaa4 <HAL_SUBGHZ_SyncWordValidCallback>:
    RadioOnDioIrqCb( IRQ_SYNCWORD_VALID );
 803aaa4:	4b01      	ldr	r3, [pc, #4]	; (803aaac <HAL_SUBGHZ_SyncWordValidCallback+0x8>)
 803aaa6:	2008      	movs	r0, #8
 803aaa8:	689b      	ldr	r3, [r3, #8]
 803aaaa:	4718      	bx	r3
 803aaac:	20005a80 	.word	0x20005a80

0803aab0 <HAL_SUBGHZ_HeaderValidCallback>:
    RadioOnDioIrqCb( IRQ_HEADER_VALID );
 803aab0:	4b01      	ldr	r3, [pc, #4]	; (803aab8 <HAL_SUBGHZ_HeaderValidCallback+0x8>)
 803aab2:	2010      	movs	r0, #16
 803aab4:	689b      	ldr	r3, [r3, #8]
 803aab6:	4718      	bx	r3
 803aab8:	20005a80 	.word	0x20005a80

0803aabc <SUBGRF_GetFskBandwidthRegValue>:

uint8_t SUBGRF_GetFskBandwidthRegValue( uint32_t bandwidth )
{
 803aabc:	b510      	push	{r4, lr}
    uint8_t i;

    if( bandwidth == 0 )
 803aabe:	b178      	cbz	r0, 803aae0 <SUBGRF_GetFskBandwidthRegValue+0x24>
    }

    /* ST_WORKAROUND_BEGIN: Simplified loop */
    for( i = 0; i < ( sizeof( FskBandwidths ) / sizeof( FskBandwidth_t ) ); i++ )
    {
        if ( bandwidth < FskBandwidths[i].bandwidth )
 803aac0:	4a08      	ldr	r2, [pc, #32]	; (803aae4 <SUBGRF_GetFskBandwidthRegValue+0x28>)
 803aac2:	2300      	movs	r3, #0
 803aac4:	f102 0114 	add.w	r1, r2, #20
 803aac8:	f851 4033 	ldr.w	r4, [r1, r3, lsl #3]
 803aacc:	4284      	cmp	r4, r0
 803aace:	d903      	bls.n	803aad8 <SUBGRF_GetFskBandwidthRegValue+0x1c>
        {
            return FskBandwidths[i].RegValue;
 803aad0:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 803aad4:	7e18      	ldrb	r0, [r3, #24]
        }
    }
    /* ST_WORKAROUND_END */
    // ERROR: Value not found
    while( 1 );
}
 803aad6:	bd10      	pop	{r4, pc}
    for( i = 0; i < ( sizeof( FskBandwidths ) / sizeof( FskBandwidth_t ) ); i++ )
 803aad8:	3301      	adds	r3, #1
 803aada:	2b16      	cmp	r3, #22
 803aadc:	d1f4      	bne.n	803aac8 <SUBGRF_GetFskBandwidthRegValue+0xc>
    while( 1 );
 803aade:	e7fe      	b.n	803aade <SUBGRF_GetFskBandwidthRegValue+0x22>
        return( 0x1F );
 803aae0:	201f      	movs	r0, #31
 803aae2:	e7f8      	b.n	803aad6 <SUBGRF_GetFskBandwidthRegValue+0x1a>
 803aae4:	0803bcb4 	.word	0x0803bcb4

0803aae8 <SUBGRF_GetCFO>:
void SUBGRF_GetCFO( uint32_t bitRate, int32_t *cfo)
{
 803aae8:	b573      	push	{r0, r1, r4, r5, r6, lr}
  uint8_t BwMant[] = {4, 8, 10, 12};
 803aaea:	4b1d      	ldr	r3, [pc, #116]	; (803ab60 <SUBGRF_GetCFO+0x78>)
 803aaec:	9301      	str	r3, [sp, #4]
{
 803aaee:	4604      	mov	r4, r0
  /* read demod bandwidth: mant bit4:3, exp bits 2:0 */
  uint8_t reg = (SUBGRF_ReadRegister( SUBGHZ_BWSEL ));
 803aaf0:	f640 0007 	movw	r0, #2055	; 0x807
{
 803aaf4:	460d      	mov	r5, r1
  uint8_t reg = (SUBGRF_ReadRegister( SUBGHZ_BWSEL ));
 803aaf6:	f7ff fd5b 	bl	803a5b0 <SUBGRF_ReadRegister>
  uint8_t bandwidth_mant = BwMant[( reg >> 3 ) & 0x3];
 803aafa:	aa02      	add	r2, sp, #8
 803aafc:	f3c0 03c1 	ubfx	r3, r0, #3, #2
 803ab00:	4413      	add	r3, r2
  uint8_t bandwidth_exp = reg & 0x7;
  uint32_t cf_fs = XTAL_FREQ / ( bandwidth_mant * ( 1 << ( bandwidth_exp - 1 )));
 803ab02:	f813 2c04 	ldrb.w	r2, [r3, #-4]
 803ab06:	f000 0307 	and.w	r3, r0, #7
 803ab0a:	3b01      	subs	r3, #1
 803ab0c:	fa02 f003 	lsl.w	r0, r2, r3
 803ab10:	4b14      	ldr	r3, [pc, #80]	; (803ab64 <SUBGRF_GetCFO+0x7c>)
 803ab12:	fbb3 f3f0 	udiv	r3, r3, r0
  uint32_t cf_osr = cf_fs / bitRate;
 803ab16:	fbb3 f0f4 	udiv	r0, r3, r4
  uint8_t interp = 1;
  /* calculate demod interpolation factor */
  if (cf_osr * interp < 8)
 803ab1a:	2807      	cmp	r0, #7
 803ab1c:	d81d      	bhi.n	803ab5a <SUBGRF_GetCFO+0x72>
  {
    interp = 2;
  }
  if (cf_osr * interp < 4)
 803ab1e:	0040      	lsls	r0, r0, #1
  {
    interp = 4;
 803ab20:	2803      	cmp	r0, #3
 803ab22:	bf8c      	ite	hi
 803ab24:	2402      	movhi	r4, #2
 803ab26:	2404      	movls	r4, #4
  }
  /* calculate demod sampling frequency */
  uint32_t fs = cf_fs* interp;
  /* get the cfo registers */
  int32_t cfo_bin = ( SUBGRF_ReadRegister( SUBGHZ_CFO_H ) & 0xF ) << 8;
 803ab28:	f44f 60d6 	mov.w	r0, #1712	; 0x6b0
  uint32_t fs = cf_fs* interp;
 803ab2c:	435c      	muls	r4, r3
  int32_t cfo_bin = ( SUBGRF_ReadRegister( SUBGHZ_CFO_H ) & 0xF ) << 8;
 803ab2e:	f7ff fd3f 	bl	803a5b0 <SUBGRF_ReadRegister>
 803ab32:	0200      	lsls	r0, r0, #8
 803ab34:	f400 6670 	and.w	r6, r0, #3840	; 0xf00
  cfo_bin |= SUBGRF_ReadRegister( SUBGHZ_CFO_L );
 803ab38:	f240 60b1 	movw	r0, #1713	; 0x6b1
 803ab3c:	f7ff fd38 	bl	803a5b0 <SUBGRF_ReadRegister>
 803ab40:	4330      	orrs	r0, r6
  /* negate if 12 bits sign bit is 1 */
  if (( cfo_bin & 0x800 ) == 0x800 )
 803ab42:	0503      	lsls	r3, r0, #20
  {
    cfo_bin |= 0xFFFFF000;
 803ab44:	bf44      	itt	mi
 803ab46:	ea6f 5000 	mvnmi.w	r0, r0, lsl #20
 803ab4a:	ea6f 5010 	mvnmi.w	r0, r0, lsr #20
  }
  /* calculate cfo in Hz */
  /* shift by 5 first to not saturate, cfo_bin on 12bits */
  *cfo = ((int32_t)( cfo_bin * ( fs >> 5 ))) >> ( 12 - 5 );
 803ab4e:	0963      	lsrs	r3, r4, #5
 803ab50:	4358      	muls	r0, r3
 803ab52:	11c0      	asrs	r0, r0, #7
 803ab54:	6028      	str	r0, [r5, #0]
}
 803ab56:	b002      	add	sp, #8
 803ab58:	bd70      	pop	{r4, r5, r6, pc}
  uint8_t interp = 1;
 803ab5a:	2401      	movs	r4, #1
 803ab5c:	e7e4      	b.n	803ab28 <SUBGRF_GetCFO+0x40>
 803ab5e:	bf00      	nop
 803ab60:	0c0a0804 	.word	0x0c0a0804
 803ab64:	01e84800 	.word	0x01e84800

0803ab68 <RFW_TransmitLongPacket>:
  }
#else
  status= -1;
#endif
  return status;
}
 803ab68:	f04f 30ff 	mov.w	r0, #4294967295
 803ab6c:	4770      	bx	lr

0803ab6e <RFW_ReceiveLongPacket>:
  }
#else
  status= -1;
#endif
  return status;
}
 803ab6e:	f04f 30ff 	mov.w	r0, #4294967295
 803ab72:	4770      	bx	lr

0803ab74 <RFW_Init>:
  TimerInit( &RFWPacket.Timer, RFW_GetPayloadTimerEvent );
  return 0;
#else
  return -1;
#endif
}
 803ab74:	f04f 30ff 	mov.w	r0, #4294967295
 803ab78:	4770      	bx	lr

0803ab7a <RFW_DeInit>:
void RFW_DeInit( void)
{
#if (RFW_ENABLE ==1 )
  RFWPacket.Init.Enable=0; /*Disable the RFWPacket decoding*/
#endif
}
 803ab7a:	4770      	bx	lr

0803ab7c <RFW_Is_Init>:
#if (RFW_ENABLE ==1 )
  return RFWPacket.Init.Enable;
#else
  return 0;
#endif
}
 803ab7c:	2000      	movs	r0, #0
 803ab7e:	4770      	bx	lr

0803ab80 <RFW_Is_LongPacketModeEnabled>:
 803ab80:	2000      	movs	r0, #0
 803ab82:	4770      	bx	lr

0803ab84 <RFW_SetAntSwitch>:
 803ab84:	4770      	bx	lr

0803ab86 <RFW_TransmitInit>:
    
    status= 0;
  }
#endif
  return status;
}
 803ab86:	f04f 30ff 	mov.w	r0, #4294967295
 803ab8a:	4770      	bx	lr

0803ab8c <RFW_ReceiveInit>:
  RFWPacket.LongPacketModeEnable=0;
  return 0;
#else
  return -1;
#endif
}
 803ab8c:	f04f 30ff 	mov.w	r0, #4294967295
 803ab90:	4770      	bx	lr

0803ab92 <RFW_DeInit_TxLongPacket>:
 803ab92:	4770      	bx	lr

0803ab94 <RFW_ReceivePayload>:
 803ab94:	4770      	bx	lr

0803ab96 <RFW_SetRadioModem>:
void RFW_SetRadioModem(RadioModems_t Modem)
{
#if (RFW_ENABLE ==1 )
  RFWPacket.Init.Modem= Modem;
#endif
}
 803ab96:	4770      	bx	lr

0803ab98 <TRACE_AllocateBufer>:
 * @param  Size to allocate within fifo
 * @param  Pos position within the fifo
 * @retval write position inside the buffer is -1 no space available.
 */
static int16_t TRACE_AllocateBufer(uint16_t Size, uint16_t *Pos)
{
 803ab98:	b570      	push	{r4, r5, r6, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803ab9a:	f3ef 8610 	mrs	r6, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803ab9e:	b672      	cpsid	i
  uint16_t freesize;
  int16_t ret = -1;

  UTIL_ADV_TRACE_ENTER_CRITICAL_SECTION();

  if(ADV_TRACE_Ctx.TraceWrPtr == ADV_TRACE_Ctx.TraceRdPtr)
 803aba0:	4b14      	ldr	r3, [pc, #80]	; (803abf4 <TRACE_AllocateBufer+0x5c>)
 803aba2:	8a5c      	ldrh	r4, [r3, #18]
 803aba4:	8a1a      	ldrh	r2, [r3, #16]
 803aba6:	4294      	cmp	r4, r2
 803aba8:	d113      	bne.n	803abd2 <TRACE_AllocateBufer+0x3a>
  {
#ifdef UTIL_ADV_TRACE_UNCHUNK_MODE
    freesize = (uint16_t)(UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceWrPtr);
 803abaa:	f5c4 6280 	rsb	r2, r4, #1024	; 0x400
    if((Size >= freesize) && (ADV_TRACE_Ctx.TraceRdPtr > Size))
 803abae:	b292      	uxth	r2, r2
 803abb0:	4290      	cmp	r0, r2
 803abb2:	d306      	bcc.n	803abc2 <TRACE_AllocateBufer+0x2a>
 803abb4:	4284      	cmp	r4, r0
  {
#ifdef UTIL_ADV_TRACE_UNCHUNK_MODE
    if (ADV_TRACE_Ctx.TraceWrPtr > ADV_TRACE_Ctx.TraceRdPtr)
    {
      freesize = (uint16_t)(UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceWrPtr);
      if((Size >= freesize) && (ADV_TRACE_Ctx.TraceRdPtr > Size)) 
 803abb6:	d918      	bls.n	803abea <TRACE_AllocateBufer+0x52>
      {
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_DETECTED;
 803abb8:	2201      	movs	r2, #1
 803abba:	709a      	strb	r2, [r3, #2]
        ADV_TRACE_Ctx.unchunk_enabled = ADV_TRACE_Ctx.TraceWrPtr;
        freesize = ADV_TRACE_Ctx.TraceRdPtr;
        ADV_TRACE_Ctx.TraceWrPtr = 0;
 803abbc:	2200      	movs	r2, #0
        ADV_TRACE_Ctx.unchunk_enabled = ADV_TRACE_Ctx.TraceWrPtr;
 803abbe:	801c      	strh	r4, [r3, #0]
        ADV_TRACE_Ctx.TraceWrPtr = 0;
 803abc0:	825a      	strh	r2, [r3, #18]
#endif
  }

  if(freesize > Size)
  {
    *Pos = ADV_TRACE_Ctx.TraceWrPtr;
 803abc2:	8a5a      	ldrh	r2, [r3, #18]
 803abc4:	800a      	strh	r2, [r1, #0]
    ADV_TRACE_Ctx.TraceWrPtr = (ADV_TRACE_Ctx.TraceWrPtr + Size) % UTIL_ADV_TRACE_FIFO_SIZE;
 803abc6:	4410      	add	r0, r2
 803abc8:	f3c0 0009 	ubfx	r0, r0, #0, #10
 803abcc:	8258      	strh	r0, [r3, #18]
    ret = 0;
 803abce:	2000      	movs	r0, #0
 803abd0:	e00d      	b.n	803abee <TRACE_AllocateBufer+0x56>
    if (ADV_TRACE_Ctx.TraceWrPtr > ADV_TRACE_Ctx.TraceRdPtr)
 803abd2:	d906      	bls.n	803abe2 <TRACE_AllocateBufer+0x4a>
      freesize = (uint16_t)(UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceWrPtr);
 803abd4:	f5c4 6580 	rsb	r5, r4, #1024	; 0x400
      if((Size >= freesize) && (ADV_TRACE_Ctx.TraceRdPtr > Size)) 
 803abd8:	b2ad      	uxth	r5, r5
 803abda:	4285      	cmp	r5, r0
 803abdc:	d8f1      	bhi.n	803abc2 <TRACE_AllocateBufer+0x2a>
 803abde:	4282      	cmp	r2, r0
 803abe0:	e7e9      	b.n	803abb6 <TRACE_AllocateBufer+0x1e>
      freesize = (uint16_t)(ADV_TRACE_Ctx.TraceRdPtr - ADV_TRACE_Ctx.TraceWrPtr);
 803abe2:	1b12      	subs	r2, r2, r4
  if(freesize > Size)
 803abe4:	b292      	uxth	r2, r2
 803abe6:	4282      	cmp	r2, r0
 803abe8:	d8eb      	bhi.n	803abc2 <TRACE_AllocateBufer+0x2a>
  int16_t ret = -1;
 803abea:	f04f 30ff 	mov.w	r0, #4294967295
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803abee:	f386 8810 	msr	PRIMASK, r6
  }
#endif

  UTIL_ADV_TRACE_EXIT_CRITICAL_SECTION();
  return ret;
}
 803abf2:	bd70      	pop	{r4, r5, r6, pc}
 803abf4:	20005a90 	.word	0x20005a90

0803abf8 <TRACE_Lock>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803abf8:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803abfc:	b672      	cpsid	i
 * @retval None.
 */
static void TRACE_Lock(void)
{
  UTIL_ADV_TRACE_ENTER_CRITICAL_SECTION();
  ADV_TRACE_Ctx.TraceLock++;
 803abfe:	4a03      	ldr	r2, [pc, #12]	; (803ac0c <TRACE_Lock+0x14>)
 803ac00:	8ad3      	ldrh	r3, [r2, #22]
 803ac02:	3301      	adds	r3, #1
 803ac04:	82d3      	strh	r3, [r2, #22]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803ac06:	f381 8810 	msr	PRIMASK, r1
  UTIL_ADV_TRACE_EXIT_CRITICAL_SECTION();
}
 803ac0a:	4770      	bx	lr
 803ac0c:	20005a90 	.word	0x20005a90

0803ac10 <TRACE_UnLock>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803ac10:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803ac14:	b672      	cpsid	i
 * @retval None.
 */
static void TRACE_UnLock(void)
{
  UTIL_ADV_TRACE_ENTER_CRITICAL_SECTION();
  ADV_TRACE_Ctx.TraceLock--;
 803ac16:	4a03      	ldr	r2, [pc, #12]	; (803ac24 <TRACE_UnLock+0x14>)
 803ac18:	8ad3      	ldrh	r3, [r2, #22]
 803ac1a:	3b01      	subs	r3, #1
 803ac1c:	82d3      	strh	r3, [r2, #22]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803ac1e:	f381 8810 	msr	PRIMASK, r1
  UTIL_ADV_TRACE_EXIT_CRITICAL_SECTION();
}
 803ac22:	4770      	bx	lr
 803ac24:	20005a90 	.word	0x20005a90

0803ac28 <UTIL_ADV_TRACE_Init>:
{
 803ac28:	b510      	push	{r4, lr}
  (void)UTIL_ADV_TRACE_MEMSET8(&ADV_TRACE_Ctx, 0x0, sizeof(ADV_TRACE_Context));
 803ac2a:	4c09      	ldr	r4, [pc, #36]	; (803ac50 <UTIL_ADV_TRACE_Init+0x28>)
 803ac2c:	2218      	movs	r2, #24
 803ac2e:	4620      	mov	r0, r4
 803ac30:	2100      	movs	r1, #0
 803ac32:	f000 f973 	bl	803af1c <UTIL_MEM_set_8>
  (void)UTIL_ADV_TRACE_MEMSET8(&ADV_TRACE_Buffer, 0x0, sizeof(ADV_TRACE_Buffer));
 803ac36:	f104 0018 	add.w	r0, r4, #24
 803ac3a:	f44f 6280 	mov.w	r2, #1024	; 0x400
 803ac3e:	2100      	movs	r1, #0
 803ac40:	f000 f96c 	bl	803af1c <UTIL_MEM_set_8>
  return UTIL_TraceDriver.Init(TRACE_TxCpltCallback);
 803ac44:	4b03      	ldr	r3, [pc, #12]	; (803ac54 <UTIL_ADV_TRACE_Init+0x2c>)
 803ac46:	4804      	ldr	r0, [pc, #16]	; (803ac58 <UTIL_ADV_TRACE_Init+0x30>)
 803ac48:	681b      	ldr	r3, [r3, #0]
}
 803ac4a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return UTIL_TraceDriver.Init(TRACE_TxCpltCallback);
 803ac4e:	4718      	bx	r3
 803ac50:	20005a90 	.word	0x20005a90
 803ac54:	0803b908 	.word	0x0803b908
 803ac58:	0803adc9 	.word	0x0803adc9

0803ac5c <UTIL_ADV_TRACE_RegisterTimeStampFunction>:
  ADV_TRACE_Ctx.timestamp_func = *cb;
 803ac5c:	4b01      	ldr	r3, [pc, #4]	; (803ac64 <UTIL_ADV_TRACE_RegisterTimeStampFunction+0x8>)
 803ac5e:	6058      	str	r0, [r3, #4]
}
 803ac60:	4770      	bx	lr
 803ac62:	bf00      	nop
 803ac64:	20005a90 	.word	0x20005a90

0803ac68 <UTIL_ADV_TRACE_SetVerboseLevel>:
  ADV_TRACE_Ctx.CurrentVerboseLevel = Level;
 803ac68:	4b01      	ldr	r3, [pc, #4]	; (803ac70 <UTIL_ADV_TRACE_SetVerboseLevel+0x8>)
 803ac6a:	7218      	strb	r0, [r3, #8]
}
 803ac6c:	4770      	bx	lr
 803ac6e:	bf00      	nop
 803ac70:	20005a90 	.word	0x20005a90

0803ac74 <TRACE_Send>:
{
 803ac74:	b573      	push	{r0, r1, r4, r5, r6, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803ac76:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803ac7a:	b672      	cpsid	i
 * @brief  UnLock the trace buffer.
 * @retval None.
 */
static uint32_t TRACE_IsLocked(void)
{
  return (ADV_TRACE_Ctx.TraceLock == 0u? 0u: 1u);
 803ac7c:	4c1b      	ldr	r4, [pc, #108]	; (803acec <TRACE_Send+0x78>)
  if(TRACE_IsLocked() == 0u)
 803ac7e:	8ae0      	ldrh	r0, [r4, #22]
 803ac80:	2800      	cmp	r0, #0
 803ac82:	d12e      	bne.n	803ace2 <TRACE_Send+0x6e>
    TRACE_Lock();
 803ac84:	f7ff ffb8 	bl	803abf8 <TRACE_Lock>
    if(ADV_TRACE_Ctx.TraceRdPtr != ADV_TRACE_Ctx.TraceWrPtr)
 803ac88:	8a26      	ldrh	r6, [r4, #16]
 803ac8a:	8a62      	ldrh	r2, [r4, #18]
 803ac8c:	4296      	cmp	r6, r2
 803ac8e:	d026      	beq.n	803acde <TRACE_Send+0x6a>
      if(TRACE_UNCHUNK_DETECTED == ADV_TRACE_Ctx.unchunk_status)
 803ac90:	78a1      	ldrb	r1, [r4, #2]
 803ac92:	2901      	cmp	r1, #1
 803ac94:	d111      	bne.n	803acba <TRACE_Send+0x46>
        ADV_TRACE_Ctx.TraceSentSize = (uint16_t) (ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr);
 803ac96:	8823      	ldrh	r3, [r4, #0]
        ADV_TRACE_Ctx.unchunk_enabled = 0;
 803ac98:	8020      	strh	r0, [r4, #0]
        ADV_TRACE_Ctx.TraceSentSize = (uint16_t) (ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr);
 803ac9a:	1b9b      	subs	r3, r3, r6
 803ac9c:	b29b      	uxth	r3, r3
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_TRANSFER;
 803ac9e:	2102      	movs	r1, #2
        ADV_TRACE_Ctx.TraceSentSize = (uint16_t) (ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr);
 803aca0:	82a3      	strh	r3, [r4, #20]
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_TRANSFER;
 803aca2:	70a1      	strb	r1, [r4, #2]
        if(0u == ADV_TRACE_Ctx.TraceSentSize)
 803aca4:	b95b      	cbnz	r3, 803acbe <TRACE_Send+0x4a>
          ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_NONE;
 803aca6:	70a3      	strb	r3, [r4, #2]
          ADV_TRACE_Ctx.TraceRdPtr = 0;
 803aca8:	8223      	strh	r3, [r4, #16]
        if(ADV_TRACE_Ctx.TraceWrPtr > ADV_TRACE_Ctx.TraceRdPtr)
 803acaa:	8a23      	ldrh	r3, [r4, #16]
 803acac:	429a      	cmp	r2, r3
          ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.TraceWrPtr - ADV_TRACE_Ctx.TraceRdPtr;
 803acae:	bf8c      	ite	hi
 803acb0:	1ad3      	subhi	r3, r2, r3
          ADV_TRACE_Ctx.TraceSentSize = UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceRdPtr;
 803acb2:	f5c3 6380 	rsbls	r3, r3, #1024	; 0x400
 803acb6:	82a3      	strh	r3, [r4, #20]
 803acb8:	e001      	b.n	803acbe <TRACE_Send+0x4a>
      if(TRACE_UNCHUNK_NONE == ADV_TRACE_Ctx.unchunk_status)
 803acba:	2900      	cmp	r1, #0
 803acbc:	d0f5      	beq.n	803acaa <TRACE_Send+0x36>
      ptr = &ADV_TRACE_Buffer[ADV_TRACE_Ctx.TraceRdPtr];
 803acbe:	8a20      	ldrh	r0, [r4, #16]
 803acc0:	4e0b      	ldr	r6, [pc, #44]	; (803acf0 <TRACE_Send+0x7c>)
 803acc2:	4406      	add	r6, r0
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803acc4:	f385 8810 	msr	PRIMASK, r5
      UTIL_ADV_TRACE_PreSendHook();
 803acc8:	f7f1 fcb2 	bl	802c630 <UTIL_ADV_TRACE_PreSendHook>
      ret = UTIL_TraceDriver.Send(ptr, ADV_TRACE_Ctx.TraceSentSize);
 803accc:	4b09      	ldr	r3, [pc, #36]	; (803acf4 <TRACE_Send+0x80>)
 803acce:	8aa1      	ldrh	r1, [r4, #20]
 803acd0:	68db      	ldr	r3, [r3, #12]
 803acd2:	9301      	str	r3, [sp, #4]
 803acd4:	4630      	mov	r0, r6
}
 803acd6:	b002      	add	sp, #8
 803acd8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      ret = UTIL_TraceDriver.Send(ptr, ADV_TRACE_Ctx.TraceSentSize);
 803acdc:	4718      	bx	r3
      TRACE_UnLock();
 803acde:	f7ff ff97 	bl	803ac10 <TRACE_UnLock>
 803ace2:	f385 8810 	msr	PRIMASK, r5
}
 803ace6:	2000      	movs	r0, #0
 803ace8:	b002      	add	sp, #8
 803acea:	bd70      	pop	{r4, r5, r6, pc}
 803acec:	20005a90 	.word	0x20005a90
 803acf0:	20005aa8 	.word	0x20005aa8
 803acf4:	0803b908 	.word	0x0803b908

0803acf8 <UTIL_ADV_TRACE_COND_FSend>:
{
 803acf8:	b408      	push	{r3}
 803acfa:	b5f0      	push	{r4, r5, r6, r7, lr}
  if(!(ADV_TRACE_Ctx.CurrentVerboseLevel >= VerboseLevel))
 803acfc:	4c2f      	ldr	r4, [pc, #188]	; (803adbc <UTIL_ADV_TRACE_COND_FSend+0xc4>)
{
 803acfe:	b086      	sub	sp, #24
  uint16_t timestamp_size = 0u;
 803ad00:	2300      	movs	r3, #0
 803ad02:	f8ad 3000 	strh.w	r3, [sp]
  if(!(ADV_TRACE_Ctx.CurrentVerboseLevel >= VerboseLevel))
 803ad06:	7a23      	ldrb	r3, [r4, #8]
{
 803ad08:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
  if(!(ADV_TRACE_Ctx.CurrentVerboseLevel >= VerboseLevel))
 803ad0a:	4283      	cmp	r3, r0
 803ad0c:	d34f      	bcc.n	803adae <UTIL_ADV_TRACE_COND_FSend+0xb6>
  if((Region & ADV_TRACE_Ctx.RegionMask) != Region)
 803ad0e:	68e3      	ldr	r3, [r4, #12]
 803ad10:	ea31 0303 	bics.w	r3, r1, r3
 803ad14:	d14e      	bne.n	803adb4 <UTIL_ADV_TRACE_COND_FSend+0xbc>
  if((ADV_TRACE_Ctx.timestamp_func != NULL) && (TimeStampState != 0u))
 803ad16:	6863      	ldr	r3, [r4, #4]
 803ad18:	b11b      	cbz	r3, 803ad22 <UTIL_ADV_TRACE_COND_FSend+0x2a>
 803ad1a:	b112      	cbz	r2, 803ad22 <UTIL_ADV_TRACE_COND_FSend+0x2a>
    ADV_TRACE_Ctx.timestamp_func(buf,&timestamp_size);
 803ad1c:	4669      	mov	r1, sp
 803ad1e:	a802      	add	r0, sp, #8
 803ad20:	4798      	blx	r3
  va_start( vaArgs, strFormat);
 803ad22:	ab0c      	add	r3, sp, #48	; 0x30
  buff_size =(uint16_t)UTIL_ADV_TRACE_VSNPRINTF((char *)sztmp,UTIL_ADV_TRACE_TMP_BUF_SIZE, strFormat, vaArgs);
 803ad24:	462a      	mov	r2, r5
 803ad26:	f44f 7100 	mov.w	r1, #512	; 0x200
 803ad2a:	4825      	ldr	r0, [pc, #148]	; (803adc0 <UTIL_ADV_TRACE_COND_FSend+0xc8>)
  va_start( vaArgs, strFormat);
 803ad2c:	9301      	str	r3, [sp, #4]
  buff_size =(uint16_t)UTIL_ADV_TRACE_VSNPRINTF((char *)sztmp,UTIL_ADV_TRACE_TMP_BUF_SIZE, strFormat, vaArgs);
 803ad2e:	f000 fbeb 	bl	803b508 <tiny_vsnprintf_like>
  TRACE_Lock();
 803ad32:	f7ff ff61 	bl	803abf8 <TRACE_Lock>
  if (TRACE_AllocateBufer((buff_size+timestamp_size),&writepos) != -1)
 803ad36:	f8bd 3000 	ldrh.w	r3, [sp]
 803ad3a:	4418      	add	r0, r3
 803ad3c:	f10d 0102 	add.w	r1, sp, #2
 803ad40:	b280      	uxth	r0, r0
 803ad42:	f7ff ff29 	bl	803ab98 <TRACE_AllocateBufer>
 803ad46:	3001      	adds	r0, #1
 803ad48:	d02c      	beq.n	803ada4 <UTIL_ADV_TRACE_COND_FSend+0xac>
    for (idx = 0u; idx < timestamp_size; idx++)
 803ad4a:	2200      	movs	r2, #0
 803ad4c:	f8bd 3000 	ldrh.w	r3, [sp]
 803ad50:	f8bd 7002 	ldrh.w	r7, [sp, #2]
 803ad54:	4616      	mov	r6, r2
      ADV_TRACE_Buffer[writepos] = buf[idx];
 803ad56:	f10d 0c08 	add.w	ip, sp, #8
 803ad5a:	b290      	uxth	r0, r2
 803ad5c:	fa17 f182 	uxtah	r1, r7, r2
    for (idx = 0u; idx < timestamp_size; idx++)
 803ad60:	4283      	cmp	r3, r0
 803ad62:	b289      	uxth	r1, r1
 803ad64:	d817      	bhi.n	803ad96 <UTIL_ADV_TRACE_COND_FSend+0x9e>
 803ad66:	443b      	add	r3, r7
 803ad68:	b29b      	uxth	r3, r3
 803ad6a:	b10e      	cbz	r6, 803ad70 <UTIL_ADV_TRACE_COND_FSend+0x78>
 803ad6c:	f8ad 3002 	strh.w	r3, [sp, #2]
    (void)UTIL_ADV_TRACE_VSNPRINTF((char *)(&ADV_TRACE_Buffer[writepos]), UTIL_ADV_TRACE_TMP_BUF_SIZE, strFormat, vaArgs);
 803ad70:	f8bd 0002 	ldrh.w	r0, [sp, #2]
 803ad74:	4c13      	ldr	r4, [pc, #76]	; (803adc4 <UTIL_ADV_TRACE_COND_FSend+0xcc>)
 803ad76:	9b01      	ldr	r3, [sp, #4]
 803ad78:	462a      	mov	r2, r5
 803ad7a:	f44f 7100 	mov.w	r1, #512	; 0x200
 803ad7e:	4420      	add	r0, r4
 803ad80:	f000 fbc2 	bl	803b508 <tiny_vsnprintf_like>
    TRACE_UnLock();
 803ad84:	f7ff ff44 	bl	803ac10 <TRACE_UnLock>
    return TRACE_Send();
 803ad88:	f7ff ff74 	bl	803ac74 <TRACE_Send>
}
 803ad8c:	b006      	add	sp, #24
 803ad8e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 803ad92:	b001      	add	sp, #4
 803ad94:	4770      	bx	lr
      ADV_TRACE_Buffer[writepos] = buf[idx];
 803ad96:	4421      	add	r1, r4
 803ad98:	f812 000c 	ldrb.w	r0, [r2, ip]
 803ad9c:	7608      	strb	r0, [r1, #24]
    for (idx = 0u; idx < timestamp_size; idx++)
 803ad9e:	3201      	adds	r2, #1
      ADV_TRACE_Buffer[writepos] = buf[idx];
 803ada0:	2601      	movs	r6, #1
 803ada2:	e7da      	b.n	803ad5a <UTIL_ADV_TRACE_COND_FSend+0x62>
  TRACE_UnLock();
 803ada4:	f7ff ff34 	bl	803ac10 <TRACE_UnLock>
  return UTIL_ADV_TRACE_MEM_FULL;
 803ada8:	f06f 0002 	mvn.w	r0, #2
 803adac:	e7ee      	b.n	803ad8c <UTIL_ADV_TRACE_COND_FSend+0x94>
    return UTIL_ADV_TRACE_GIVEUP;
 803adae:	f06f 0004 	mvn.w	r0, #4
 803adb2:	e7eb      	b.n	803ad8c <UTIL_ADV_TRACE_COND_FSend+0x94>
    return UTIL_ADV_TRACE_REGIONMASKED;
 803adb4:	f06f 0005 	mvn.w	r0, #5
 803adb8:	e7e8      	b.n	803ad8c <UTIL_ADV_TRACE_COND_FSend+0x94>
 803adba:	bf00      	nop
 803adbc:	20005a90 	.word	0x20005a90
 803adc0:	20005ea8 	.word	0x20005ea8
 803adc4:	20005aa8 	.word	0x20005aa8

0803adc8 <TRACE_TxCpltCallback>:
{
 803adc8:	b537      	push	{r0, r1, r2, r4, r5, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803adca:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803adce:	b672      	cpsid	i
  if(TRACE_UNCHUNK_TRANSFER == ADV_TRACE_Ctx.unchunk_status)
 803add0:	4b21      	ldr	r3, [pc, #132]	; (803ae58 <TRACE_TxCpltCallback+0x90>)
 803add2:	789a      	ldrb	r2, [r3, #2]
 803add4:	2a02      	cmp	r2, #2
    ADV_TRACE_Ctx.TraceRdPtr = (ADV_TRACE_Ctx.TraceRdPtr + ADV_TRACE_Ctx.TraceSentSize) % UTIL_ADV_TRACE_FIFO_SIZE;
 803add6:	bf1d      	ittte	ne
 803add8:	8a1a      	ldrhne	r2, [r3, #16]
 803adda:	8a99      	ldrhne	r1, [r3, #20]
 803addc:	1852      	addne	r2, r2, r1
    ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_NONE;
 803adde:	2200      	moveq	r2, #0
    ADV_TRACE_Ctx.TraceRdPtr = (ADV_TRACE_Ctx.TraceRdPtr + ADV_TRACE_Ctx.TraceSentSize) % UTIL_ADV_TRACE_FIFO_SIZE;
 803ade0:	bf18      	it	ne
 803ade2:	f3c2 0209 	ubfxne	r2, r2, #0, #10
 803ade6:	821a      	strh	r2, [r3, #16]
  if((ADV_TRACE_Ctx.TraceRdPtr != ADV_TRACE_Ctx.TraceWrPtr) && (1u == ADV_TRACE_Ctx.TraceLock))
 803ade8:	8a1d      	ldrh	r5, [r3, #16]
 803adea:	8a59      	ldrh	r1, [r3, #18]
    ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_NONE;
 803adec:	bf08      	it	eq
 803adee:	709a      	strbeq	r2, [r3, #2]
  if((ADV_TRACE_Ctx.TraceRdPtr != ADV_TRACE_Ctx.TraceWrPtr) && (1u == ADV_TRACE_Ctx.TraceLock))
 803adf0:	428d      	cmp	r5, r1
 803adf2:	d027      	beq.n	803ae44 <TRACE_TxCpltCallback+0x7c>
 803adf4:	8ada      	ldrh	r2, [r3, #22]
 803adf6:	2a01      	cmp	r2, #1
 803adf8:	d124      	bne.n	803ae44 <TRACE_TxCpltCallback+0x7c>
    if(TRACE_UNCHUNK_DETECTED == ADV_TRACE_Ctx.unchunk_status)
 803adfa:	7898      	ldrb	r0, [r3, #2]
 803adfc:	2801      	cmp	r0, #1
 803adfe:	d112      	bne.n	803ae26 <TRACE_TxCpltCallback+0x5e>
      ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr;
 803ae00:	881a      	ldrh	r2, [r3, #0]
      ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_TRANSFER;
 803ae02:	2002      	movs	r0, #2
      ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr;
 803ae04:	1b52      	subs	r2, r2, r5
 803ae06:	b292      	uxth	r2, r2
      ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_TRANSFER;
 803ae08:	7098      	strb	r0, [r3, #2]
      ADV_TRACE_Ctx.unchunk_enabled = 0;
 803ae0a:	2000      	movs	r0, #0
      ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr;
 803ae0c:	829a      	strh	r2, [r3, #20]
      ADV_TRACE_Ctx.unchunk_enabled = 0;
 803ae0e:	8018      	strh	r0, [r3, #0]
      if(0u == ADV_TRACE_Ctx.TraceSentSize)
 803ae10:	b95a      	cbnz	r2, 803ae2a <TRACE_TxCpltCallback+0x62>
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_NONE;
 803ae12:	709a      	strb	r2, [r3, #2]
        ADV_TRACE_Ctx.TraceRdPtr = 0;
 803ae14:	821a      	strh	r2, [r3, #16]
      if(ADV_TRACE_Ctx.TraceWrPtr > ADV_TRACE_Ctx.TraceRdPtr)
 803ae16:	8a1a      	ldrh	r2, [r3, #16]
 803ae18:	4291      	cmp	r1, r2
        ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.TraceWrPtr - ADV_TRACE_Ctx.TraceRdPtr;
 803ae1a:	bf8c      	ite	hi
 803ae1c:	1a8a      	subhi	r2, r1, r2
        ADV_TRACE_Ctx.TraceSentSize = UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceRdPtr;
 803ae1e:	f5c2 6280 	rsbls	r2, r2, #1024	; 0x400
 803ae22:	829a      	strh	r2, [r3, #20]
 803ae24:	e001      	b.n	803ae2a <TRACE_TxCpltCallback+0x62>
    if(TRACE_UNCHUNK_NONE == ADV_TRACE_Ctx.unchunk_status)
 803ae26:	2800      	cmp	r0, #0
 803ae28:	d0f5      	beq.n	803ae16 <TRACE_TxCpltCallback+0x4e>
    ptr = &ADV_TRACE_Buffer[ADV_TRACE_Ctx.TraceRdPtr];
 803ae2a:	8a1a      	ldrh	r2, [r3, #16]
 803ae2c:	480b      	ldr	r0, [pc, #44]	; (803ae5c <TRACE_TxCpltCallback+0x94>)
 803ae2e:	4410      	add	r0, r2
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803ae30:	f384 8810 	msr	PRIMASK, r4
    UTIL_TraceDriver.Send(ptr, ADV_TRACE_Ctx.TraceSentSize);
 803ae34:	4a0a      	ldr	r2, [pc, #40]	; (803ae60 <TRACE_TxCpltCallback+0x98>)
 803ae36:	8a99      	ldrh	r1, [r3, #20]
 803ae38:	68d3      	ldr	r3, [r2, #12]
 803ae3a:	9301      	str	r3, [sp, #4]
}
 803ae3c:	b003      	add	sp, #12
 803ae3e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    UTIL_TraceDriver.Send(ptr, ADV_TRACE_Ctx.TraceSentSize);
 803ae42:	4718      	bx	r3
 803ae44:	f384 8810 	msr	PRIMASK, r4
    UTIL_ADV_TRACE_PostSendHook();
 803ae48:	f7f1 fbf6 	bl	802c638 <UTIL_ADV_TRACE_PostSendHook>
}
 803ae4c:	b003      	add	sp, #12
 803ae4e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    TRACE_UnLock();
 803ae52:	f7ff bedd 	b.w	803ac10 <TRACE_UnLock>
 803ae56:	bf00      	nop
 803ae58:	20005a90 	.word	0x20005a90
 803ae5c:	20005aa8 	.word	0x20005aa8
 803ae60:	0803b908 	.word	0x0803b908

0803ae64 <UTIL_LPM_Init>:
/** @addtogroup TINY_LPM_Exported_function
  * @{
  */
void UTIL_LPM_Init( void )
{
  StopModeDisable = UTIL_LPM_NO_BIT_SET;
 803ae64:	4b02      	ldr	r3, [pc, #8]	; (803ae70 <UTIL_LPM_Init+0xc>)
 803ae66:	2200      	movs	r2, #0
  OffModeDisable = UTIL_LPM_NO_BIT_SET;
 803ae68:	e9c3 2200 	strd	r2, r2, [r3]
  UTIL_LPM_INIT_CRITICAL_SECTION( );
}
 803ae6c:	4770      	bx	lr
 803ae6e:	bf00      	nop
 803ae70:	200060a8 	.word	0x200060a8

0803ae74 <UTIL_LPM_SetStopMode>:
void UTIL_LPM_DeInit( void )
{
}

void UTIL_LPM_SetStopMode( UTIL_LPM_bm_t lpm_id_bm, UTIL_LPM_State_t state )
{
 803ae74:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803ae76:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803ae7a:	b672      	cpsid	i
  UTIL_LPM_ENTER_CRITICAL_SECTION( );
  
  switch( state )
 803ae7c:	b141      	cbz	r1, 803ae90 <UTIL_LPM_SetStopMode+0x1c>
 803ae7e:	2901      	cmp	r1, #1
 803ae80:	d103      	bne.n	803ae8a <UTIL_LPM_SetStopMode+0x16>
  {
  case UTIL_LPM_DISABLE:
    {
      StopModeDisable |= lpm_id_bm;
 803ae82:	4a06      	ldr	r2, [pc, #24]	; (803ae9c <UTIL_LPM_SetStopMode+0x28>)
 803ae84:	6813      	ldr	r3, [r2, #0]
 803ae86:	4318      	orrs	r0, r3
      break;
    }
  case UTIL_LPM_ENABLE:
    {
      StopModeDisable &= ( ~lpm_id_bm );
 803ae88:	6010      	str	r0, [r2, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803ae8a:	f384 8810 	msr	PRIMASK, r4
      break;
    }
  }
  
  UTIL_LPM_EXIT_CRITICAL_SECTION( );
}
 803ae8e:	bd10      	pop	{r4, pc}
      StopModeDisable &= ( ~lpm_id_bm );
 803ae90:	4a02      	ldr	r2, [pc, #8]	; (803ae9c <UTIL_LPM_SetStopMode+0x28>)
 803ae92:	6813      	ldr	r3, [r2, #0]
 803ae94:	ea23 0000 	bic.w	r0, r3, r0
 803ae98:	e7f6      	b.n	803ae88 <UTIL_LPM_SetStopMode+0x14>
 803ae9a:	bf00      	nop
 803ae9c:	200060a8 	.word	0x200060a8

0803aea0 <UTIL_LPM_SetOffMode>:

void UTIL_LPM_SetOffMode( UTIL_LPM_bm_t lpm_id_bm, UTIL_LPM_State_t state )
{
 803aea0:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803aea2:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803aea6:	b672      	cpsid	i
  UTIL_LPM_ENTER_CRITICAL_SECTION( );
  
  switch(state)
 803aea8:	b141      	cbz	r1, 803aebc <UTIL_LPM_SetOffMode+0x1c>
 803aeaa:	2901      	cmp	r1, #1
 803aeac:	d103      	bne.n	803aeb6 <UTIL_LPM_SetOffMode+0x16>
  {
  case UTIL_LPM_DISABLE:
    {
      OffModeDisable |= lpm_id_bm;
 803aeae:	4a06      	ldr	r2, [pc, #24]	; (803aec8 <UTIL_LPM_SetOffMode+0x28>)
 803aeb0:	6853      	ldr	r3, [r2, #4]
 803aeb2:	4318      	orrs	r0, r3
      break;
    }
  case UTIL_LPM_ENABLE:
    {
      OffModeDisable &= ( ~lpm_id_bm );
 803aeb4:	6050      	str	r0, [r2, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803aeb6:	f384 8810 	msr	PRIMASK, r4
      break;
    }
  }
  
  UTIL_LPM_EXIT_CRITICAL_SECTION( );
}
 803aeba:	bd10      	pop	{r4, pc}
      OffModeDisable &= ( ~lpm_id_bm );
 803aebc:	4a02      	ldr	r2, [pc, #8]	; (803aec8 <UTIL_LPM_SetOffMode+0x28>)
 803aebe:	6853      	ldr	r3, [r2, #4]
 803aec0:	ea23 0000 	bic.w	r0, r3, r0
 803aec4:	e7f6      	b.n	803aeb4 <UTIL_LPM_SetOffMode+0x14>
 803aec6:	bf00      	nop
 803aec8:	200060a8 	.word	0x200060a8

0803aecc <UTIL_LPM_EnterLowPower>:

  return mode_selected;
}

void UTIL_LPM_EnterLowPower( void )
{
 803aecc:	b538      	push	{r3, r4, r5, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803aece:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803aed2:	b672      	cpsid	i
  UTIL_LPM_ENTER_CRITICAL_SECTION_ELP( );

  if( StopModeDisable != UTIL_LPM_NO_BIT_SET )
 803aed4:	4b0a      	ldr	r3, [pc, #40]	; (803af00 <UTIL_LPM_EnterLowPower+0x34>)
 803aed6:	4c0b      	ldr	r4, [pc, #44]	; (803af04 <UTIL_LPM_EnterLowPower+0x38>)
 803aed8:	681a      	ldr	r2, [r3, #0]
 803aeda:	b132      	cbz	r2, 803aeea <UTIL_LPM_EnterLowPower+0x1e>
  {
    /**
     * At least one user disallows Stop Mode
     * SLEEP mode is required
     */
      UTIL_PowerDriver.EnterSleepMode( );
 803aedc:	6823      	ldr	r3, [r4, #0]
 803aede:	4798      	blx	r3
      UTIL_PowerDriver.ExitSleepMode( );
 803aee0:	6863      	ldr	r3, [r4, #4]
    {
      /**
       * OFF mode is required
       */
      UTIL_PowerDriver.EnterOffMode( );
      UTIL_PowerDriver.ExitOffMode( );
 803aee2:	4798      	blx	r3
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803aee4:	f385 8810 	msr	PRIMASK, r5
    }
  }
  
  UTIL_LPM_EXIT_CRITICAL_SECTION_ELP( );
}
 803aee8:	bd38      	pop	{r3, r4, r5, pc}
    if( OffModeDisable != UTIL_LPM_NO_BIT_SET )
 803aeea:	685b      	ldr	r3, [r3, #4]
 803aeec:	b11b      	cbz	r3, 803aef6 <UTIL_LPM_EnterLowPower+0x2a>
        UTIL_PowerDriver.EnterStopMode( );
 803aeee:	68a3      	ldr	r3, [r4, #8]
 803aef0:	4798      	blx	r3
        UTIL_PowerDriver.ExitStopMode( );
 803aef2:	68e3      	ldr	r3, [r4, #12]
 803aef4:	e7f5      	b.n	803aee2 <UTIL_LPM_EnterLowPower+0x16>
      UTIL_PowerDriver.EnterOffMode( );
 803aef6:	6923      	ldr	r3, [r4, #16]
 803aef8:	4798      	blx	r3
      UTIL_PowerDriver.ExitOffMode( );
 803aefa:	6963      	ldr	r3, [r4, #20]
 803aefc:	e7f1      	b.n	803aee2 <UTIL_LPM_EnterLowPower+0x16>
 803aefe:	bf00      	nop
 803af00:	200060a8 	.word	0x200060a8
 803af04:	0803b8b0 	.word	0x0803b8b0

0803af08 <UTIL_MEM_cpy_8>:
void UTIL_MEM_cpy_8( void *dst, const void *src, uint16_t size )
{
  uint8_t* dst8= (uint8_t *) dst;
  uint8_t* src8= (uint8_t *) src;

  while( size-- )
 803af08:	3801      	subs	r0, #1
 803af0a:	440a      	add	r2, r1
 803af0c:	4291      	cmp	r1, r2
 803af0e:	d100      	bne.n	803af12 <UTIL_MEM_cpy_8+0xa>
    {
        *dst8++ = *src8++;
    }
}
 803af10:	4770      	bx	lr
        *dst8++ = *src8++;
 803af12:	f811 3b01 	ldrb.w	r3, [r1], #1
 803af16:	f800 3f01 	strb.w	r3, [r0, #1]!
 803af1a:	e7f7      	b.n	803af0c <UTIL_MEM_cpy_8+0x4>

0803af1c <UTIL_MEM_set_8>:
}

void UTIL_MEM_set_8( void *dst, uint8_t value, uint16_t size )
{
  uint8_t* dst8= (uint8_t *) dst;
  while( size-- )
 803af1c:	4402      	add	r2, r0
 803af1e:	4290      	cmp	r0, r2
 803af20:	d100      	bne.n	803af24 <UTIL_MEM_set_8+0x8>
  {
    *dst8++ = value;
  }
}
 803af22:	4770      	bx	lr
    *dst8++ = value;
 803af24:	f800 1b01 	strb.w	r1, [r0], #1
 803af28:	e7f9      	b.n	803af1e <UTIL_MEM_set_8+0x2>
	...

0803af2c <UTIL_SEQ_SetTask>:

  return;
}

void UTIL_SEQ_SetTask( UTIL_SEQ_bm_t TaskId_bm , uint32_t Task_Prio )
{
 803af2c:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803af2e:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803af32:	b672      	cpsid	i
  UTIL_SEQ_ENTER_CRITICAL_SECTION( );

  TaskSet |= TaskId_bm;
 803af34:	4b06      	ldr	r3, [pc, #24]	; (803af50 <UTIL_SEQ_SetTask+0x24>)
 803af36:	681a      	ldr	r2, [r3, #0]
 803af38:	4302      	orrs	r2, r0
 803af3a:	601a      	str	r2, [r3, #0]
  TaskPrio[Task_Prio].priority |= TaskId_bm;
 803af3c:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 803af40:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 803af44:	4310      	orrs	r0, r2
 803af46:	f8c3 0090 	str.w	r0, [r3, #144]	; 0x90
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803af4a:	f384 8810 	msr	PRIMASK, r4

  UTIL_SEQ_EXIT_CRITICAL_SECTION( );

  return;
}
 803af4e:	bd10      	pop	{r4, pc}
 803af50:	200060b0 	.word	0x200060b0

0803af54 <UTIL_SEQ_PreIdle>:
 803af54:	4770      	bx	lr

0803af56 <UTIL_SEQ_PostIdle>:
 803af56:	4770      	bx	lr

0803af58 <SEQ_BitPosition>:
 */
uint8_t SEQ_BitPosition(uint32_t Value)
{
  uint8_t n = 0U;

  if ((Value & 0xFFFF0000U) == 0U)  { n  = 16U; Value <<= 16U;  }
 803af58:	0c03      	lsrs	r3, r0, #16
 803af5a:	041b      	lsls	r3, r3, #16
 803af5c:	b9c3      	cbnz	r3, 803af90 <SEQ_BitPosition+0x38>
 803af5e:	0400      	lsls	r0, r0, #16
 803af60:	2310      	movs	r3, #16
  if ((Value & 0xFF000000U) == 0U)  { n +=  8U; Value <<=  8U;  }
 803af62:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
 803af66:	bf02      	ittt	eq
 803af68:	3308      	addeq	r3, #8
 803af6a:	0200      	lsleq	r0, r0, #8
 803af6c:	b2db      	uxtbeq	r3, r3
  if ((Value & 0xF0000000U) == 0U)  { n +=  4U; Value <<=  4U;  }
 803af6e:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
 803af72:	bf08      	it	eq
 803af74:	0100      	lsleq	r0, r0, #4

  n += SEQ_clz_table_4bit[Value >> (32-4)];

  return (uint8_t)(31U-n);
 803af76:	4a07      	ldr	r2, [pc, #28]	; (803af94 <SEQ_BitPosition+0x3c>)
  n += SEQ_clz_table_4bit[Value >> (32-4)];
 803af78:	ea4f 7010 	mov.w	r0, r0, lsr #28
  if ((Value & 0xF0000000U) == 0U)  { n +=  4U; Value <<=  4U;  }
 803af7c:	bf08      	it	eq
 803af7e:	3304      	addeq	r3, #4
  return (uint8_t)(31U-n);
 803af80:	5c10      	ldrb	r0, [r2, r0]
  if ((Value & 0xF0000000U) == 0U)  { n +=  4U; Value <<=  4U;  }
 803af82:	bf08      	it	eq
 803af84:	b2db      	uxtbeq	r3, r3
  return (uint8_t)(31U-n);
 803af86:	f1c3 031f 	rsb	r3, r3, #31
 803af8a:	1a18      	subs	r0, r3, r0
}
 803af8c:	b2c0      	uxtb	r0, r0
 803af8e:	4770      	bx	lr
  uint8_t n = 0U;
 803af90:	2300      	movs	r3, #0
 803af92:	e7e6      	b.n	803af62 <SEQ_BitPosition+0xa>
 803af94:	0803bd78 	.word	0x0803bd78

0803af98 <UTIL_SEQ_Run>:
{
 803af98:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  super_mask_backup = SuperMask;
 803af9c:	4d36      	ldr	r5, [pc, #216]	; (803b078 <UTIL_SEQ_Run+0xe0>)
  while(((TaskSet & TaskMask & SuperMask) != 0U) && ((EvtSet & EvtWaited)==0U))
 803af9e:	f8df 80dc 	ldr.w	r8, [pc, #220]	; 803b07c <UTIL_SEQ_Run+0xe4>
  super_mask_backup = SuperMask;
 803afa2:	686e      	ldr	r6, [r5, #4]
  SuperMask &= Mask_bm;
 803afa4:	4030      	ands	r0, r6
 803afa6:	6068      	str	r0, [r5, #4]
  while(((TaskSet & TaskMask & SuperMask) != 0U) && ((EvtSet & EvtWaited)==0U))
 803afa8:	4644      	mov	r4, r8
      counter++;
 803afaa:	2701      	movs	r7, #1
  while(((TaskSet & TaskMask & SuperMask) != 0U) && ((EvtSet & EvtWaited)==0U))
 803afac:	e9d5 2000 	ldrd	r2, r0, [r5]
 803afb0:	f8d8 3000 	ldr.w	r3, [r8]
 803afb4:	4013      	ands	r3, r2
 803afb6:	4203      	tst	r3, r0
 803afb8:	d043      	beq.n	803b042 <UTIL_SEQ_Run+0xaa>
 803afba:	e9d8 3101 	ldrd	r3, r1, [r8, #4]
 803afbe:	400b      	ands	r3, r1
 803afc0:	d13f      	bne.n	803b042 <UTIL_SEQ_Run+0xaa>
    while((TaskPrio[counter].priority & TaskMask & SuperMask)== 0U)
 803afc2:	4002      	ands	r2, r0
 803afc4:	f8d8 0090 	ldr.w	r0, [r8, #144]	; 0x90
 803afc8:	4010      	ands	r0, r2
 803afca:	d103      	bne.n	803afd4 <UTIL_SEQ_Run+0x3c>
 803afcc:	f8d8 0098 	ldr.w	r0, [r8, #152]	; 0x98
      counter++;
 803afd0:	2301      	movs	r3, #1
    while((TaskPrio[counter].priority & TaskMask & SuperMask)== 0U)
 803afd2:	4010      	ands	r0, r2
    if ((TaskPrio[counter].round_robin & current_task_set) == 0U)
 803afd4:	00d9      	lsls	r1, r3, #3
 803afd6:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
    CurrentTaskIdx = (SEQ_BitPosition(current_task_set & TaskPrio[counter].round_robin));
 803afda:	4421      	add	r1, r4
    if ((TaskPrio[counter].round_robin & current_task_set) == 0U)
 803afdc:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 803afe0:	4210      	tst	r0, r2
      TaskPrio[counter].round_robin = UTIL_SEQ_ALL_BIT_SET;
 803afe2:	bf04      	itt	eq
 803afe4:	f04f 32ff 	moveq.w	r2, #4294967295
 803afe8:	f8c3 2094 	streq.w	r2, [r3, #148]	; 0x94
    CurrentTaskIdx = (SEQ_BitPosition(current_task_set & TaskPrio[counter].round_robin));
 803afec:	f8d1 9094 	ldr.w	r9, [r1, #148]	; 0x94
 803aff0:	ea09 0000 	and.w	r0, r9, r0
 803aff4:	f7ff ffb0 	bl	803af58 <SEQ_BitPosition>
 803aff8:	60e0      	str	r0, [r4, #12]
    TaskPrio[counter].round_robin &= ~(1U << CurrentTaskIdx);
 803affa:	fa07 f000 	lsl.w	r0, r7, r0
 803affe:	ea29 0000 	bic.w	r0, r9, r0
 803b002:	f8c1 0094 	str.w	r0, [r1, #148]	; 0x94
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803b006:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803b00a:	b672      	cpsid	i
    TaskSet &= ~(1U << CurrentTaskIdx);
 803b00c:	68e3      	ldr	r3, [r4, #12]
 803b00e:	6822      	ldr	r2, [r4, #0]
 803b010:	fa07 f303 	lsl.w	r3, r7, r3
 803b014:	ea22 0203 	bic.w	r2, r2, r3
 803b018:	6022      	str	r2, [r4, #0]
      TaskPrio[counter - 1U].priority &= ~(1U << CurrentTaskIdx);
 803b01a:	f8d4 2098 	ldr.w	r2, [r4, #152]	; 0x98
 803b01e:	ea22 0203 	bic.w	r2, r2, r3
 803b022:	f8c4 2098 	str.w	r2, [r4, #152]	; 0x98
 803b026:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
 803b02a:	ea22 0303 	bic.w	r3, r2, r3
 803b02e:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803b032:	f381 8810 	msr	PRIMASK, r1
    TaskCb[CurrentTaskIdx]( );
 803b036:	68e3      	ldr	r3, [r4, #12]
 803b038:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 803b03c:	691b      	ldr	r3, [r3, #16]
 803b03e:	4798      	blx	r3
 803b040:	e7b4      	b.n	803afac <UTIL_SEQ_Run+0x14>
  CurrentTaskIdx = UTIL_SEQ_NOTASKRUNNING;
 803b042:	f04f 33ff 	mov.w	r3, #4294967295
 803b046:	60e3      	str	r3, [r4, #12]
  UTIL_SEQ_PreIdle( );
 803b048:	f7ff ff84 	bl	803af54 <UTIL_SEQ_PreIdle>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803b04c:	f3ef 8710 	mrs	r7, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803b050:	b672      	cpsid	i
  if (!(((TaskSet & TaskMask & SuperMask) != 0U) || ((EvtSet & EvtWaited)!= 0U))) 
 803b052:	682a      	ldr	r2, [r5, #0]
 803b054:	6823      	ldr	r3, [r4, #0]
 803b056:	4013      	ands	r3, r2
 803b058:	686a      	ldr	r2, [r5, #4]
 803b05a:	4013      	ands	r3, r2
 803b05c:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 803b060:	400a      	ands	r2, r1
 803b062:	4313      	orrs	r3, r2
 803b064:	d101      	bne.n	803b06a <UTIL_SEQ_Run+0xd2>
	UTIL_SEQ_Idle( );
 803b066:	f7f1 fa6d 	bl	802c544 <UTIL_SEQ_Idle>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803b06a:	f387 8810 	msr	PRIMASK, r7
  UTIL_SEQ_PostIdle( );
 803b06e:	f7ff ff72 	bl	803af56 <UTIL_SEQ_PostIdle>
  SuperMask = super_mask_backup;
 803b072:	606e      	str	r6, [r5, #4]
}
 803b074:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 803b078:	200035a4 	.word	0x200035a4
 803b07c:	200060b0 	.word	0x200060b0

0803b080 <UTIL_SEQ_RegTask>:
{
 803b080:	b510      	push	{r4, lr}
 803b082:	4611      	mov	r1, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803b084:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803b088:	b672      	cpsid	i
  TaskCb[SEQ_BitPosition(TaskId_bm)] = Task;
 803b08a:	f7ff ff65 	bl	803af58 <SEQ_BitPosition>
 803b08e:	4b03      	ldr	r3, [pc, #12]	; (803b09c <UTIL_SEQ_RegTask+0x1c>)
 803b090:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 803b094:	6119      	str	r1, [r3, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803b096:	f384 8810 	msr	PRIMASK, r4
}
 803b09a:	bd10      	pop	{r4, pc}
 803b09c:	200060b0 	.word	0x200060b0

0803b0a0 <SysTimeAdd>:
  * @addtogroup SYSTIME_exported_function
  *  @{
  */

SysTime_t SysTimeAdd( SysTime_t a, SysTime_t b )
{
 803b0a0:	b082      	sub	sp, #8
 803b0a2:	b082      	sub	sp, #8
 803b0a4:	f10d 0c08 	add.w	ip, sp, #8
 803b0a8:	e90c 0006 	stmdb	ip, {r1, r2}
  SysTime_t c =  { .Seconds = 0, .SubSeconds = 0 };

  c.Seconds = a.Seconds + b.Seconds;
 803b0ac:	9a00      	ldr	r2, [sp, #0]
  c.SubSeconds = a.SubSeconds + b.SubSeconds;
 803b0ae:	f8bd 1010 	ldrh.w	r1, [sp, #16]
{
 803b0b2:	9303      	str	r3, [sp, #12]
  c.Seconds = a.Seconds + b.Seconds;
 803b0b4:	4413      	add	r3, r2
  c.SubSeconds = a.SubSeconds + b.SubSeconds;
 803b0b6:	f8bd 2004 	ldrh.w	r2, [sp, #4]
 803b0ba:	440a      	add	r2, r1
 803b0bc:	b291      	uxth	r1, r2
 803b0be:	b212      	sxth	r2, r2
  if( c.SubSeconds >= 1000 )
 803b0c0:	f5b2 7f7a 	cmp.w	r2, #1000	; 0x3e8
  {
    c.Seconds++;
    c.SubSeconds -= 1000;
 803b0c4:	bfa2      	ittt	ge
 803b0c6:	f5a1 727a 	subge.w	r2, r1, #1000	; 0x3e8
    c.Seconds++;
 803b0ca:	3301      	addge	r3, #1
    c.SubSeconds -= 1000;
 803b0cc:	b212      	sxthge	r2, r2
  }
  return c;
 803b0ce:	6003      	str	r3, [r0, #0]
 803b0d0:	8082      	strh	r2, [r0, #4]
}
 803b0d2:	b002      	add	sp, #8
 803b0d4:	b002      	add	sp, #8
 803b0d6:	4770      	bx	lr

0803b0d8 <SysTimeSub>:

SysTime_t SysTimeSub( SysTime_t a, SysTime_t b )
{
 803b0d8:	b082      	sub	sp, #8
 803b0da:	b082      	sub	sp, #8
 803b0dc:	f10d 0c08 	add.w	ip, sp, #8
 803b0e0:	e90c 0006 	stmdb	ip, {r1, r2}
  SysTime_t c = { .Seconds = 0, .SubSeconds = 0 };

  c.Seconds = a.Seconds - b.Seconds;
 803b0e4:	9a00      	ldr	r2, [sp, #0]
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 803b0e6:	f8bd 1010 	ldrh.w	r1, [sp, #16]
{
 803b0ea:	9303      	str	r3, [sp, #12]
  c.Seconds = a.Seconds - b.Seconds;
 803b0ec:	1ad3      	subs	r3, r2, r3
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 803b0ee:	f8bd 2004 	ldrh.w	r2, [sp, #4]
 803b0f2:	1a52      	subs	r2, r2, r1
 803b0f4:	b291      	uxth	r1, r2
 803b0f6:	b212      	sxth	r2, r2
  if( c.SubSeconds < 0 )
 803b0f8:	2a00      	cmp	r2, #0
  {
    c.Seconds--;
    c.SubSeconds += 1000;
 803b0fa:	bfbe      	ittt	lt
 803b0fc:	f501 727a 	addlt.w	r2, r1, #1000	; 0x3e8
    c.Seconds--;
 803b100:	f103 33ff 	addlt.w	r3, r3, #4294967295
    c.SubSeconds += 1000;
 803b104:	b212      	sxthlt	r2, r2
  }
  return c;
 803b106:	6003      	str	r3, [r0, #0]
 803b108:	8082      	strh	r2, [r0, #4]
}
 803b10a:	b002      	add	sp, #8
 803b10c:	b002      	add	sp, #8
 803b10e:	4770      	bx	lr

0803b110 <SysTimeSet>:

void SysTimeSet( SysTime_t sysTime )
{
 803b110:	b530      	push	{r4, r5, lr}
 803b112:	b085      	sub	sp, #20
  SysTime_t DeltaTime;
  
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };

  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 803b114:	4d11      	ldr	r5, [pc, #68]	; (803b15c <SysTimeSet+0x4c>)
{
 803b116:	466b      	mov	r3, sp
 803b118:	e883 0003 	stmia.w	r3, {r0, r1}
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 803b11c:	2300      	movs	r3, #0
 803b11e:	9302      	str	r3, [sp, #8]
 803b120:	f8ad 300c 	strh.w	r3, [sp, #12]
  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 803b124:	a803      	add	r0, sp, #12
 803b126:	692b      	ldr	r3, [r5, #16]
 803b128:	4798      	blx	r3
  c.Seconds = a.Seconds - b.Seconds;
 803b12a:	9b00      	ldr	r3, [sp, #0]
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 803b12c:	f8bd 4004 	ldrh.w	r4, [sp, #4]
  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 803b130:	9002      	str	r0, [sp, #8]
  c.Seconds = a.Seconds - b.Seconds;
 803b132:	1a18      	subs	r0, r3, r0
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 803b134:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 803b138:	1ae4      	subs	r4, r4, r3
 803b13a:	b2a3      	uxth	r3, r4
 803b13c:	b224      	sxth	r4, r4
  if( c.SubSeconds < 0 )
 803b13e:	2c00      	cmp	r4, #0
    c.SubSeconds += 1000;
 803b140:	bfbe      	ittt	lt
 803b142:	f503 747a 	addlt.w	r4, r3, #1000	; 0x3e8
    c.Seconds--;
 803b146:	f100 30ff 	addlt.w	r0, r0, #4294967295
    c.SubSeconds += 1000;
 803b14a:	b224      	sxthlt	r4, r4

  // sysTime is UNIX epoch
  DeltaTime = SysTimeSub( sysTime, calendarTime );

  UTIL_SYSTIMDriver.BKUPWrite_Seconds( DeltaTime.Seconds );
 803b14c:	682b      	ldr	r3, [r5, #0]
 803b14e:	4798      	blx	r3
  UTIL_SYSTIMDriver.BKUPWrite_SubSeconds( ( uint32_t ) DeltaTime.SubSeconds );
 803b150:	68ab      	ldr	r3, [r5, #8]
 803b152:	4620      	mov	r0, r4
 803b154:	4798      	blx	r3
}
 803b156:	b005      	add	sp, #20
 803b158:	bd30      	pop	{r4, r5, pc}
 803b15a:	bf00      	nop
 803b15c:	0803b8c8 	.word	0x0803b8c8

0803b160 <SysTimeGet>:

SysTime_t SysTimeGet( void )
{
 803b160:	b573      	push	{r0, r1, r4, r5, r6, lr}
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
  SysTime_t sysTime = { .Seconds = 0, .SubSeconds = 0 };
  SysTime_t DeltaTime;

  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 803b162:	4e11      	ldr	r6, [pc, #68]	; (803b1a8 <SysTimeGet+0x48>)
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 803b164:	2300      	movs	r3, #0
{
 803b166:	4605      	mov	r5, r0
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 803b168:	9300      	str	r3, [sp, #0]
 803b16a:	f8ad 3004 	strh.w	r3, [sp, #4]
  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 803b16e:	a801      	add	r0, sp, #4
 803b170:	6933      	ldr	r3, [r6, #16]
 803b172:	4798      	blx	r3

  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b174:	68f3      	ldr	r3, [r6, #12]
  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 803b176:	9000      	str	r0, [sp, #0]
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b178:	4798      	blx	r3
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 803b17a:	6873      	ldr	r3, [r6, #4]
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b17c:	4604      	mov	r4, r0
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 803b17e:	4798      	blx	r3
  c.Seconds = a.Seconds + b.Seconds;
 803b180:	9b00      	ldr	r3, [sp, #0]
 803b182:	4418      	add	r0, r3
  c.SubSeconds = a.SubSeconds + b.SubSeconds;
 803b184:	f8bd 3004 	ldrh.w	r3, [sp, #4]
 803b188:	4423      	add	r3, r4
 803b18a:	b29a      	uxth	r2, r3
 803b18c:	b21b      	sxth	r3, r3
  if( c.SubSeconds >= 1000 )
 803b18e:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
    c.Seconds++;
 803b192:	bfa2      	ittt	ge
 803b194:	3001      	addge	r0, #1
    c.SubSeconds -= 1000;
 803b196:	f5a2 737a 	subge.w	r3, r2, #1000	; 0x3e8
 803b19a:	b21b      	sxthge	r3, r3

  sysTime = SysTimeAdd( DeltaTime, calendarTime );

  return sysTime;
 803b19c:	6028      	str	r0, [r5, #0]
}
 803b19e:	4628      	mov	r0, r5
  return sysTime;
 803b1a0:	80ab      	strh	r3, [r5, #4]
}
 803b1a2:	b002      	add	sp, #8
 803b1a4:	bd70      	pop	{r4, r5, r6, pc}
 803b1a6:	bf00      	nop
 803b1a8:	0803b8c8 	.word	0x0803b8c8

0803b1ac <SysTimeGetMcuTime>:


SysTime_t SysTimeGetMcuTime( void )
{
 803b1ac:	b537      	push	{r0, r1, r2, r4, r5, lr}
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 803b1ae:	2300      	movs	r3, #0
 803b1b0:	9300      	str	r3, [sp, #0]
 803b1b2:	f8ad 3004 	strh.w	r3, [sp, #4]

  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 803b1b6:	4b07      	ldr	r3, [pc, #28]	; (803b1d4 <SysTimeGetMcuTime+0x28>)
{
 803b1b8:	4604      	mov	r4, r0
  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 803b1ba:	691b      	ldr	r3, [r3, #16]
 803b1bc:	a801      	add	r0, sp, #4
 803b1be:	4798      	blx	r3
 803b1c0:	466d      	mov	r5, sp
 803b1c2:	9000      	str	r0, [sp, #0]
  
  return calendarTime;
 803b1c4:	e895 0003 	ldmia.w	r5, {r0, r1}
 803b1c8:	e884 0003 	stmia.w	r4, {r0, r1}
}
 803b1cc:	4620      	mov	r0, r4
 803b1ce:	b003      	add	sp, #12
 803b1d0:	bd30      	pop	{r4, r5, pc}
 803b1d2:	bf00      	nop
 803b1d4:	0803b8c8 	.word	0x0803b8c8

0803b1d8 <SysTimeToMs>:

uint32_t SysTimeToMs( SysTime_t sysTime )
{
 803b1d8:	b537      	push	{r0, r1, r2, r4, r5, lr}
  SysTime_t DeltaTime;
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b1da:	4d0e      	ldr	r5, [pc, #56]	; (803b214 <SysTimeToMs+0x3c>)
{
 803b1dc:	ab02      	add	r3, sp, #8
 803b1de:	e903 0003 	stmdb	r3, {r0, r1}
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b1e2:	68eb      	ldr	r3, [r5, #12]
 803b1e4:	4798      	blx	r3
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 803b1e6:	686b      	ldr	r3, [r5, #4]
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b1e8:	4604      	mov	r4, r0
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 803b1ea:	4798      	blx	r3
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 803b1ec:	f8bd 3004 	ldrh.w	r3, [sp, #4]
  c.Seconds = a.Seconds - b.Seconds;
 803b1f0:	9a00      	ldr	r2, [sp, #0]
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 803b1f2:	1b1b      	subs	r3, r3, r4
  c.Seconds = a.Seconds - b.Seconds;
 803b1f4:	1a12      	subs	r2, r2, r0
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 803b1f6:	b298      	uxth	r0, r3
 803b1f8:	b21b      	sxth	r3, r3
  if( c.SubSeconds < 0 )
 803b1fa:	2b00      	cmp	r3, #0
    c.SubSeconds += 1000;
 803b1fc:	bfbe      	ittt	lt
 803b1fe:	f500 707a 	addlt.w	r0, r0, #1000	; 0x3e8
 803b202:	b203      	sxthlt	r3, r0
    c.Seconds--;
 803b204:	f102 32ff 	addlt.w	r2, r2, #4294967295
  
  SysTime_t calendarTime = SysTimeSub( sysTime, DeltaTime );
  return calendarTime.Seconds * 1000 + calendarTime.SubSeconds;
}
 803b208:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 803b20c:	fb00 3002 	mla	r0, r0, r2, r3
 803b210:	b003      	add	sp, #12
 803b212:	bd30      	pop	{r4, r5, pc}
 803b214:	0803b8c8 	.word	0x0803b8c8

0803b218 <SysTimeFromMs>:

SysTime_t SysTimeFromMs( uint32_t timeMs )
{
 803b218:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t seconds = timeMs / 1000;
 803b21c:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 803b220:	fbb1 f5f5 	udiv	r5, r1, r5
  SysTime_t sysTime = { .Seconds = seconds, .SubSeconds =  timeMs - seconds * 1000 };
 803b224:	ebc5 1345 	rsb	r3, r5, r5, lsl #5
  SysTime_t DeltaTime = { 0 };

  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b228:	f8df 803c 	ldr.w	r8, [pc, #60]	; 803b268 <SysTimeFromMs+0x50>
  SysTime_t sysTime = { .Seconds = seconds, .SubSeconds =  timeMs - seconds * 1000 };
 803b22c:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 803b230:	eba1 03c3 	sub.w	r3, r1, r3, lsl #3
 803b234:	b29c      	uxth	r4, r3
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b236:	f8d8 300c 	ldr.w	r3, [r8, #12]
{
 803b23a:	4606      	mov	r6, r0
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b23c:	4798      	blx	r3
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 803b23e:	f8d8 3004 	ldr.w	r3, [r8, #4]
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b242:	4607      	mov	r7, r0
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 803b244:	4798      	blx	r3
  c.SubSeconds = a.SubSeconds + b.SubSeconds;
 803b246:	19e3      	adds	r3, r4, r7
 803b248:	b29a      	uxth	r2, r3
 803b24a:	b21b      	sxth	r3, r3
  if( c.SubSeconds >= 1000 )
 803b24c:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
  c.Seconds = a.Seconds + b.Seconds;
 803b250:	4405      	add	r5, r0
    c.SubSeconds -= 1000;
 803b252:	bfa2      	ittt	ge
 803b254:	f5a2 737a 	subge.w	r3, r2, #1000	; 0x3e8
    c.Seconds++;
 803b258:	3501      	addge	r5, #1
    c.SubSeconds -= 1000;
 803b25a:	b21b      	sxthge	r3, r3
  return c;
 803b25c:	6035      	str	r5, [r6, #0]
 803b25e:	80b3      	strh	r3, [r6, #4]
  return SysTimeAdd( sysTime, DeltaTime );
}
 803b260:	4630      	mov	r0, r6
 803b262:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 803b266:	bf00      	nop
 803b268:	0803b8c8 	.word	0x0803b8c8

0803b26c <UTIL_TIMER_Init>:
  */

UTIL_TIMER_Status_t UTIL_TIMER_Init(void)
{
  UTIL_TIMER_INIT_CRITICAL_SECTION();
  TimerListHead = NULL;
 803b26c:	4b02      	ldr	r3, [pc, #8]	; (803b278 <UTIL_TIMER_Init+0xc>)
 803b26e:	2200      	movs	r2, #0
 803b270:	601a      	str	r2, [r3, #0]
  return UTIL_TimerDriver.InitTimer();
 803b272:	4b02      	ldr	r3, [pc, #8]	; (803b27c <UTIL_TIMER_Init+0x10>)
 803b274:	681b      	ldr	r3, [r3, #0]
 803b276:	4718      	bx	r3
 803b278:	20006150 	.word	0x20006150
 803b27c:	0803b8dc 	.word	0x0803b8dc

0803b280 <UTIL_TIMER_Create>:
{
  return UTIL_TimerDriver.DeInitTimer();
}

UTIL_TIMER_Status_t UTIL_TIMER_Create( UTIL_TIMER_Object_t *TimerObject, uint32_t PeriodValue, UTIL_TIMER_Mode_t Mode, void ( *Callback )( void *), void *Argument)
{
 803b280:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 803b282:	4604      	mov	r4, r0
 803b284:	4617      	mov	r7, r2
 803b286:	4608      	mov	r0, r1
 803b288:	461e      	mov	r6, r3
  if((TimerObject != NULL) && (Callback != NULL))
 803b28a:	b17c      	cbz	r4, 803b2ac <UTIL_TIMER_Create+0x2c>
 803b28c:	b173      	cbz	r3, 803b2ac <UTIL_TIMER_Create+0x2c>
  {
    TimerObject->Timestamp = 0U;
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(PeriodValue);
 803b28e:	4b08      	ldr	r3, [pc, #32]	; (803b2b0 <UTIL_TIMER_Create+0x30>)
    TimerObject->Timestamp = 0U;
 803b290:	2500      	movs	r5, #0
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(PeriodValue);
 803b292:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    TimerObject->Timestamp = 0U;
 803b294:	6025      	str	r5, [r4, #0]
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(PeriodValue);
 803b296:	4798      	blx	r3
    TimerObject->IsPending = 0U;
    TimerObject->IsRunning = 0U;
    TimerObject->IsReloadStopped = 0U;
    TimerObject->Callback = Callback;
    TimerObject->argument = Argument;
 803b298:	9b06      	ldr	r3, [sp, #24]
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(PeriodValue);
 803b29a:	6060      	str	r0, [r4, #4]
    TimerObject->IsPending = 0U;
 803b29c:	8125      	strh	r5, [r4, #8]
    TimerObject->IsReloadStopped = 0U;
 803b29e:	72a5      	strb	r5, [r4, #10]
    TimerObject->Callback = Callback;
 803b2a0:	60e6      	str	r6, [r4, #12]
    TimerObject->argument = Argument;
 803b2a2:	6123      	str	r3, [r4, #16]
    TimerObject->Mode = Mode;
 803b2a4:	72e7      	strb	r7, [r4, #11]
    TimerObject->Next = NULL;
 803b2a6:	6165      	str	r5, [r4, #20]
    return UTIL_TIMER_OK;
 803b2a8:	4628      	mov	r0, r5
  }
  else
  {
    return UTIL_TIMER_INVALID_PARAM;
  }
}
 803b2aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return UTIL_TIMER_INVALID_PARAM;
 803b2ac:	2001      	movs	r0, #1
 803b2ae:	e7fc      	b.n	803b2aa <UTIL_TIMER_Create+0x2a>
 803b2b0:	0803b8dc 	.word	0x0803b8dc

0803b2b4 <UTIL_TIMER_GetCurrentTime>:
  }
  UTIL_TIMER_EXIT_CRITICAL_SECTION();
}

UTIL_TIMER_Time_t UTIL_TIMER_GetCurrentTime(void)
{
 803b2b4:	b510      	push	{r4, lr}
  uint32_t now = UTIL_TimerDriver.GetTimerValue( );
 803b2b6:	4c03      	ldr	r4, [pc, #12]	; (803b2c4 <UTIL_TIMER_GetCurrentTime+0x10>)
 803b2b8:	69e3      	ldr	r3, [r4, #28]
 803b2ba:	4798      	blx	r3
  return  UTIL_TimerDriver.Tick2ms(now);
 803b2bc:	6aa3      	ldr	r3, [r4, #40]	; 0x28
}
 803b2be:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return  UTIL_TimerDriver.Tick2ms(now);
 803b2c2:	4718      	bx	r3
 803b2c4:	0803b8dc 	.word	0x0803b8dc

0803b2c8 <UTIL_TIMER_GetElapsedTime>:

UTIL_TIMER_Time_t UTIL_TIMER_GetElapsedTime(UTIL_TIMER_Time_t past )
{
 803b2c8:	b570      	push	{r4, r5, r6, lr}
  uint32_t nowInTicks = UTIL_TimerDriver.GetTimerValue( );
 803b2ca:	4d06      	ldr	r5, [pc, #24]	; (803b2e4 <UTIL_TIMER_GetElapsedTime+0x1c>)
 803b2cc:	69eb      	ldr	r3, [r5, #28]
{
 803b2ce:	4606      	mov	r6, r0
  uint32_t nowInTicks = UTIL_TimerDriver.GetTimerValue( );
 803b2d0:	4798      	blx	r3
  uint32_t pastInTicks = UTIL_TimerDriver.ms2Tick( past );
 803b2d2:	6a6b      	ldr	r3, [r5, #36]	; 0x24
  uint32_t nowInTicks = UTIL_TimerDriver.GetTimerValue( );
 803b2d4:	4604      	mov	r4, r0
  uint32_t pastInTicks = UTIL_TimerDriver.ms2Tick( past );
 803b2d6:	4630      	mov	r0, r6
 803b2d8:	4798      	blx	r3
  /* intentional wrap around. Works Ok if tick duation below 1ms */
  return UTIL_TimerDriver.Tick2ms( nowInTicks- pastInTicks );
 803b2da:	6aab      	ldr	r3, [r5, #40]	; 0x28
 803b2dc:	1a20      	subs	r0, r4, r0
}
 803b2de:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  return UTIL_TimerDriver.Tick2ms( nowInTicks- pastInTicks );
 803b2e2:	4718      	bx	r3
 803b2e4:	0803b8dc 	.word	0x0803b8dc

0803b2e8 <TimerExists>:
 * @param TimerObject Structure containing the timer object parameters
 * @retval 1 (the object is already in the list) or 0
 */
bool TimerExists( UTIL_TIMER_Object_t *TimerObject )
{
  UTIL_TIMER_Object_t* cur = TimerListHead;
 803b2e8:	4a05      	ldr	r2, [pc, #20]	; (803b300 <TimerExists+0x18>)
{
 803b2ea:	4603      	mov	r3, r0
  UTIL_TIMER_Object_t* cur = TimerListHead;
 803b2ec:	6810      	ldr	r0, [r2, #0]

  while( cur != NULL )
 803b2ee:	b900      	cbnz	r0, 803b2f2 <TimerExists+0xa>
 803b2f0:	4770      	bx	lr
  {
    if( cur == TimerObject )
 803b2f2:	4298      	cmp	r0, r3
 803b2f4:	d001      	beq.n	803b2fa <TimerExists+0x12>
    {
      return true;
    }
    cur = cur->Next;
 803b2f6:	6940      	ldr	r0, [r0, #20]
 803b2f8:	e7f9      	b.n	803b2ee <TimerExists+0x6>
      return true;
 803b2fa:	2001      	movs	r0, #1
  }
  return false;
}
 803b2fc:	4770      	bx	lr
 803b2fe:	bf00      	nop
 803b300:	20006150 	.word	0x20006150

0803b304 <TimerSetTimeout>:
 * @brief Sets a timeout with the duration "timestamp"
 *
 * @param TimerObject Structure containing the timer object parameters
 */
void TimerSetTimeout( UTIL_TIMER_Object_t *TimerObject )
{
 803b304:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  uint32_t minTicks= UTIL_TimerDriver.GetMinimumTimeout( );
 803b308:	4d0b      	ldr	r5, [pc, #44]	; (803b338 <TimerSetTimeout+0x34>)
 803b30a:	6a2b      	ldr	r3, [r5, #32]
{
 803b30c:	4604      	mov	r4, r0
  uint32_t minTicks= UTIL_TimerDriver.GetMinimumTimeout( );
 803b30e:	4798      	blx	r3
  TimerObject->IsPending = 1;
 803b310:	2301      	movs	r3, #1

  /* In case deadline too soon */
  if(TimerObject->Timestamp  < (UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks) )
 803b312:	69af      	ldr	r7, [r5, #24]
  TimerObject->IsPending = 1;
 803b314:	7223      	strb	r3, [r4, #8]
  if(TimerObject->Timestamp  < (UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks) )
 803b316:	f8d4 8000 	ldr.w	r8, [r4]
  uint32_t minTicks= UTIL_TimerDriver.GetMinimumTimeout( );
 803b31a:	4606      	mov	r6, r0
  if(TimerObject->Timestamp  < (UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks) )
 803b31c:	47b8      	blx	r7
 803b31e:	4430      	add	r0, r6
 803b320:	4580      	cmp	r8, r0
 803b322:	d202      	bcs.n	803b32a <TimerSetTimeout+0x26>
  {
	  TimerObject->Timestamp = UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks;
 803b324:	47b8      	blx	r7
 803b326:	4406      	add	r6, r0
 803b328:	6026      	str	r6, [r4, #0]
  }
  UTIL_TimerDriver.StartTimerEvt( TimerObject->Timestamp );
 803b32a:	68ab      	ldr	r3, [r5, #8]
 803b32c:	6820      	ldr	r0, [r4, #0]
 803b32e:	9301      	str	r3, [sp, #4]
}
 803b330:	b002      	add	sp, #8
 803b332:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  UTIL_TimerDriver.StartTimerEvt( TimerObject->Timestamp );
 803b336:	4718      	bx	r3
 803b338:	0803b8dc 	.word	0x0803b8dc

0803b33c <UTIL_TIMER_Stop>:
{
 803b33c:	b570      	push	{r4, r5, r6, lr}
  if (NULL != TimerObject)
 803b33e:	b320      	cbz	r0, 803b38a <UTIL_TIMER_Stop+0x4e>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803b340:	f3ef 8610 	mrs	r6, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803b344:	b672      	cpsid	i
    UTIL_TIMER_Object_t* prev = TimerListHead;
 803b346:	4d12      	ldr	r5, [pc, #72]	; (803b390 <UTIL_TIMER_Stop+0x54>)
 803b348:	682b      	ldr	r3, [r5, #0]
    TimerObject->IsReloadStopped = 1U;
 803b34a:	2201      	movs	r2, #1
 803b34c:	7282      	strb	r2, [r0, #10]
    if(NULL != TimerListHead)
 803b34e:	b153      	cbz	r3, 803b366 <UTIL_TIMER_Stop+0x2a>
      TimerObject->IsRunning = 0U;
 803b350:	2200      	movs	r2, #0
      if( TimerListHead == TimerObject ) /* Stop the Head */
 803b352:	4298      	cmp	r0, r3
      TimerObject->IsRunning = 0U;
 803b354:	7242      	strb	r2, [r0, #9]
      if( TimerListHead == TimerObject ) /* Stop the Head */
 803b356:	d10f      	bne.n	803b378 <UTIL_TIMER_Stop+0x3c>
 803b358:	6944      	ldr	r4, [r0, #20]
          TimerListHead->IsPending = 0;
 803b35a:	7202      	strb	r2, [r0, #8]
          if( TimerListHead->Next != NULL )
 803b35c:	b13c      	cbz	r4, 803b36e <UTIL_TIMER_Stop+0x32>
            TimerSetTimeout( TimerListHead );
 803b35e:	4620      	mov	r0, r4
            TimerListHead = TimerListHead->Next;
 803b360:	602c      	str	r4, [r5, #0]
            TimerSetTimeout( TimerListHead );
 803b362:	f7ff ffcf 	bl	803b304 <TimerSetTimeout>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803b366:	f386 8810 	msr	PRIMASK, r6
}
 803b36a:	2000      	movs	r0, #0
}
 803b36c:	bd70      	pop	{r4, r5, r6, pc}
            UTIL_TimerDriver.StopTimerEvt( );
 803b36e:	4b09      	ldr	r3, [pc, #36]	; (803b394 <UTIL_TIMER_Stop+0x58>)
 803b370:	68db      	ldr	r3, [r3, #12]
 803b372:	4798      	blx	r3
            TimerListHead = NULL;
 803b374:	602c      	str	r4, [r5, #0]
 803b376:	e7f6      	b.n	803b366 <UTIL_TIMER_Stop+0x2a>
            cur = cur->Next;
 803b378:	461a      	mov	r2, r3
 803b37a:	695b      	ldr	r3, [r3, #20]
        while( cur != NULL )
 803b37c:	2b00      	cmp	r3, #0
 803b37e:	d0f2      	beq.n	803b366 <UTIL_TIMER_Stop+0x2a>
          if( cur == TimerObject )
 803b380:	4298      	cmp	r0, r3
 803b382:	d1f9      	bne.n	803b378 <UTIL_TIMER_Stop+0x3c>
            if( cur->Next != NULL )
 803b384:	6943      	ldr	r3, [r0, #20]
              prev->Next = cur;
 803b386:	6153      	str	r3, [r2, #20]
 803b388:	e7ed      	b.n	803b366 <UTIL_TIMER_Stop+0x2a>
    ret = UTIL_TIMER_INVALID_PARAM;
 803b38a:	2001      	movs	r0, #1
 803b38c:	e7ee      	b.n	803b36c <UTIL_TIMER_Stop+0x30>
 803b38e:	bf00      	nop
 803b390:	20006150 	.word	0x20006150
 803b394:	0803b8dc 	.word	0x0803b8dc

0803b398 <TimerInsertTimer>:
 *
 * @param TimerObject Structure containing the timer object parameters
 */
void TimerInsertTimer( UTIL_TIMER_Object_t *TimerObject)
{
  UTIL_TIMER_Object_t* cur = TimerListHead;
 803b398:	4b09      	ldr	r3, [pc, #36]	; (803b3c0 <TimerInsertTimer+0x28>)
{
 803b39a:	b510      	push	{r4, lr}
  UTIL_TIMER_Object_t* cur = TimerListHead;
 803b39c:	681b      	ldr	r3, [r3, #0]
  UTIL_TIMER_Object_t* next = TimerListHead->Next;
 803b39e:	695a      	ldr	r2, [r3, #20]

  while (cur->Next != NULL )
 803b3a0:	6959      	ldr	r1, [r3, #20]
 803b3a2:	b911      	cbnz	r1, 803b3aa <TimerInsertTimer+0x12>
        TimerObject->Next = next;
        return;

    }
  }
  cur->Next = TimerObject;
 803b3a4:	6158      	str	r0, [r3, #20]
  TimerObject->Next = NULL;
 803b3a6:	6141      	str	r1, [r0, #20]
 803b3a8:	e008      	b.n	803b3bc <TimerInsertTimer+0x24>
    if( TimerObject->Timestamp  > next->Timestamp )
 803b3aa:	6804      	ldr	r4, [r0, #0]
 803b3ac:	6811      	ldr	r1, [r2, #0]
 803b3ae:	428c      	cmp	r4, r1
 803b3b0:	d902      	bls.n	803b3b8 <TimerInsertTimer+0x20>
        next = next->Next;
 803b3b2:	4613      	mov	r3, r2
 803b3b4:	6952      	ldr	r2, [r2, #20]
 803b3b6:	e7f3      	b.n	803b3a0 <TimerInsertTimer+0x8>
        cur->Next = TimerObject;
 803b3b8:	6158      	str	r0, [r3, #20]
        TimerObject->Next = next;
 803b3ba:	6142      	str	r2, [r0, #20]
}
 803b3bc:	bd10      	pop	{r4, pc}
 803b3be:	bf00      	nop
 803b3c0:	20006150 	.word	0x20006150

0803b3c4 <TimerInsertNewHeadTimer>:
 * @remark The list is automatically sorted. The list head always contains the
 *         next timer to expire.
 */
void TimerInsertNewHeadTimer( UTIL_TIMER_Object_t *TimerObject )
{
  UTIL_TIMER_Object_t* cur = TimerListHead;
 803b3c4:	4b04      	ldr	r3, [pc, #16]	; (803b3d8 <TimerInsertNewHeadTimer+0x14>)
 803b3c6:	681a      	ldr	r2, [r3, #0]

  if( cur != NULL )
 803b3c8:	b10a      	cbz	r2, 803b3ce <TimerInsertNewHeadTimer+0xa>
  {
    cur->IsPending = 0;
 803b3ca:	2100      	movs	r1, #0
 803b3cc:	7211      	strb	r1, [r2, #8]
  }

  TimerObject->Next = cur;
 803b3ce:	6142      	str	r2, [r0, #20]
  TimerListHead = TimerObject;
 803b3d0:	6018      	str	r0, [r3, #0]
  TimerSetTimeout( TimerListHead );
 803b3d2:	f7ff bf97 	b.w	803b304 <TimerSetTimeout>
 803b3d6:	bf00      	nop
 803b3d8:	20006150 	.word	0x20006150

0803b3dc <UTIL_TIMER_Start>:
{
 803b3dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if(( TimerObject != NULL ) && ( TimerExists( TimerObject ) == false ) && (TimerObject->IsRunning == 0U))
 803b3e0:	4604      	mov	r4, r0
 803b3e2:	2800      	cmp	r0, #0
 803b3e4:	d02d      	beq.n	803b442 <UTIL_TIMER_Start+0x66>
 803b3e6:	f7ff ff7f 	bl	803b2e8 <TimerExists>
 803b3ea:	bb50      	cbnz	r0, 803b442 <UTIL_TIMER_Start+0x66>
 803b3ec:	7a65      	ldrb	r5, [r4, #9]
 803b3ee:	bb45      	cbnz	r5, 803b442 <UTIL_TIMER_Start+0x66>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803b3f0:	f3ef 8810 	mrs	r8, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803b3f4:	b672      	cpsid	i
    minValue = UTIL_TimerDriver.GetMinimumTimeout( );
 803b3f6:	4e14      	ldr	r6, [pc, #80]	; (803b448 <UTIL_TIMER_Start+0x6c>)
    ticks = TimerObject->ReloadValue;
 803b3f8:	6867      	ldr	r7, [r4, #4]
    minValue = UTIL_TimerDriver.GetMinimumTimeout( );
 803b3fa:	6a33      	ldr	r3, [r6, #32]
 803b3fc:	4798      	blx	r3
    TimerObject->Timestamp = ticks;
 803b3fe:	4287      	cmp	r7, r0
 803b400:	bf2c      	ite	cs
 803b402:	6027      	strcs	r7, [r4, #0]
 803b404:	6020      	strcc	r0, [r4, #0]
    if( TimerListHead == NULL )
 803b406:	4f11      	ldr	r7, [pc, #68]	; (803b44c <UTIL_TIMER_Start+0x70>)
    TimerObject->IsReloadStopped = 0U;
 803b408:	72a5      	strb	r5, [r4, #10]
    TimerObject->IsPending = 0U;
 803b40a:	f44f 7380 	mov.w	r3, #256	; 0x100
 803b40e:	8123      	strh	r3, [r4, #8]
    if( TimerListHead == NULL )
 803b410:	683b      	ldr	r3, [r7, #0]
 803b412:	b94b      	cbnz	r3, 803b428 <UTIL_TIMER_Start+0x4c>
      UTIL_TimerDriver.SetTimerContext();
 803b414:	6933      	ldr	r3, [r6, #16]
 803b416:	4798      	blx	r3
      TimerInsertNewHeadTimer( TimerObject ); /* insert a timeout at now+obj->Timestamp */
 803b418:	4620      	mov	r0, r4
        TimerInsertNewHeadTimer( TimerObject);
 803b41a:	f7ff ffd3 	bl	803b3c4 <TimerInsertNewHeadTimer>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803b41e:	f388 8810 	msr	PRIMASK, r8
}
 803b422:	4628      	mov	r0, r5
 803b424:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      elapsedTime = UTIL_TimerDriver.GetTimerElapsedTime( );
 803b428:	69b3      	ldr	r3, [r6, #24]
 803b42a:	4798      	blx	r3
      TimerObject->Timestamp += elapsedTime;
 803b42c:	6823      	ldr	r3, [r4, #0]
 803b42e:	4418      	add	r0, r3
      if( TimerObject->Timestamp < TimerListHead->Timestamp )
 803b430:	683b      	ldr	r3, [r7, #0]
      TimerObject->Timestamp += elapsedTime;
 803b432:	6020      	str	r0, [r4, #0]
      if( TimerObject->Timestamp < TimerListHead->Timestamp )
 803b434:	681b      	ldr	r3, [r3, #0]
 803b436:	4298      	cmp	r0, r3
        TimerInsertNewHeadTimer( TimerObject);
 803b438:	4620      	mov	r0, r4
      if( TimerObject->Timestamp < TimerListHead->Timestamp )
 803b43a:	d3ee      	bcc.n	803b41a <UTIL_TIMER_Start+0x3e>
        TimerInsertTimer( TimerObject);
 803b43c:	f7ff ffac 	bl	803b398 <TimerInsertTimer>
 803b440:	e7ed      	b.n	803b41e <UTIL_TIMER_Start+0x42>
    ret =  UTIL_TIMER_INVALID_PARAM;
 803b442:	2501      	movs	r5, #1
 803b444:	e7ed      	b.n	803b422 <UTIL_TIMER_Start+0x46>
 803b446:	bf00      	nop
 803b448:	0803b8dc 	.word	0x0803b8dc
 803b44c:	20006150 	.word	0x20006150

0803b450 <UTIL_TIMER_SetPeriod>:
{
 803b450:	b510      	push	{r4, lr}
 803b452:	4604      	mov	r4, r0
 803b454:	4608      	mov	r0, r1
  if(NULL == TimerObject)
 803b456:	b17c      	cbz	r4, 803b478 <UTIL_TIMER_SetPeriod+0x28>
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(NewPeriodValue);
 803b458:	4b08      	ldr	r3, [pc, #32]	; (803b47c <UTIL_TIMER_SetPeriod+0x2c>)
 803b45a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 803b45c:	4798      	blx	r3
 803b45e:	6060      	str	r0, [r4, #4]
    if(TimerExists(TimerObject))
 803b460:	4620      	mov	r0, r4
 803b462:	f7ff ff41 	bl	803b2e8 <TimerExists>
 803b466:	b140      	cbz	r0, 803b47a <UTIL_TIMER_SetPeriod+0x2a>
      (void)UTIL_TIMER_Stop(TimerObject);
 803b468:	4620      	mov	r0, r4
 803b46a:	f7ff ff67 	bl	803b33c <UTIL_TIMER_Stop>
      ret = UTIL_TIMER_Start(TimerObject);
 803b46e:	4620      	mov	r0, r4
}
 803b470:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      ret = UTIL_TIMER_Start(TimerObject);
 803b474:	f7ff bfb2 	b.w	803b3dc <UTIL_TIMER_Start>
	  ret = UTIL_TIMER_INVALID_PARAM;
 803b478:	2001      	movs	r0, #1
}
 803b47a:	bd10      	pop	{r4, pc}
 803b47c:	0803b8dc 	.word	0x0803b8dc

0803b480 <UTIL_TIMER_IRQ_Handler>:
{
 803b480:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803b484:	f3ef 8710 	mrs	r7, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803b488:	b672      	cpsid	i
  old  =  UTIL_TimerDriver.GetTimerContext( );
 803b48a:	4e1d      	ldr	r6, [pc, #116]	; (803b500 <UTIL_TIMER_IRQ_Handler+0x80>)
  if ( TimerListHead != NULL )
 803b48c:	4c1d      	ldr	r4, [pc, #116]	; (803b504 <UTIL_TIMER_IRQ_Handler+0x84>)
  old  =  UTIL_TimerDriver.GetTimerContext( );
 803b48e:	6973      	ldr	r3, [r6, #20]
 803b490:	4798      	blx	r3
  now  =  UTIL_TimerDriver.SetTimerContext( );
 803b492:	6933      	ldr	r3, [r6, #16]
  old  =  UTIL_TimerDriver.GetTimerContext( );
 803b494:	4605      	mov	r5, r0
  now  =  UTIL_TimerDriver.SetTimerContext( );
 803b496:	4798      	blx	r3
  if ( TimerListHead != NULL )
 803b498:	6823      	ldr	r3, [r4, #0]
 803b49a:	b94b      	cbnz	r3, 803b4b0 <UTIL_TIMER_IRQ_Handler+0x30>
      cur->IsPending = 0;
 803b49c:	f04f 0800 	mov.w	r8, #0
  while ((TimerListHead != NULL) && ((TimerListHead->Timestamp == 0U) || (TimerListHead->Timestamp < UTIL_TimerDriver.GetTimerElapsedTime(  ))))
 803b4a0:	6823      	ldr	r3, [r4, #0]
 803b4a2:	b98b      	cbnz	r3, 803b4c8 <UTIL_TIMER_IRQ_Handler+0x48>
  if(( TimerListHead != NULL ) && (TimerListHead->IsPending == 0U))
 803b4a4:	6820      	ldr	r0, [r4, #0]
 803b4a6:	bb28      	cbnz	r0, 803b4f4 <UTIL_TIMER_IRQ_Handler+0x74>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803b4a8:	f387 8810 	msr	PRIMASK, r7
}
 803b4ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  DeltaContext = now  - old; /*intentional wrap around */
 803b4b0:	1b41      	subs	r1, r0, r5
        cur->Timestamp -= DeltaContext;
 803b4b2:	1a2d      	subs	r5, r5, r0
      if (cur->Timestamp > DeltaContext)
 803b4b4:	681a      	ldr	r2, [r3, #0]
 803b4b6:	428a      	cmp	r2, r1
        cur->Timestamp -= DeltaContext;
 803b4b8:	bf8c      	ite	hi
 803b4ba:	1952      	addhi	r2, r2, r5
        cur->Timestamp = 0;
 803b4bc:	2200      	movls	r2, #0
 803b4be:	601a      	str	r2, [r3, #0]
      cur = cur->Next;
 803b4c0:	695b      	ldr	r3, [r3, #20]
    } while(cur != NULL);
 803b4c2:	2b00      	cmp	r3, #0
 803b4c4:	d1f6      	bne.n	803b4b4 <UTIL_TIMER_IRQ_Handler+0x34>
 803b4c6:	e7e9      	b.n	803b49c <UTIL_TIMER_IRQ_Handler+0x1c>
  while ((TimerListHead != NULL) && ((TimerListHead->Timestamp == 0U) || (TimerListHead->Timestamp < UTIL_TimerDriver.GetTimerElapsedTime(  ))))
 803b4c8:	681d      	ldr	r5, [r3, #0]
 803b4ca:	b11d      	cbz	r5, 803b4d4 <UTIL_TIMER_IRQ_Handler+0x54>
 803b4cc:	69b3      	ldr	r3, [r6, #24]
 803b4ce:	4798      	blx	r3
 803b4d0:	4285      	cmp	r5, r0
 803b4d2:	d2e7      	bcs.n	803b4a4 <UTIL_TIMER_IRQ_Handler+0x24>
      cur = TimerListHead;
 803b4d4:	6825      	ldr	r5, [r4, #0]
      TimerListHead = TimerListHead->Next;
 803b4d6:	696b      	ldr	r3, [r5, #20]
 803b4d8:	6023      	str	r3, [r4, #0]
      cur->IsPending = 0;
 803b4da:	f8a5 8008 	strh.w	r8, [r5, #8]
      cur->Callback(cur->argument);
 803b4de:	e9d5 3003 	ldrd	r3, r0, [r5, #12]
 803b4e2:	4798      	blx	r3
      if(( cur->Mode == UTIL_TIMER_PERIODIC) && (cur->IsReloadStopped == 0U))
 803b4e4:	896b      	ldrh	r3, [r5, #10]
 803b4e6:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 803b4ea:	d1d9      	bne.n	803b4a0 <UTIL_TIMER_IRQ_Handler+0x20>
        (void)UTIL_TIMER_Start(cur);
 803b4ec:	4628      	mov	r0, r5
 803b4ee:	f7ff ff75 	bl	803b3dc <UTIL_TIMER_Start>
 803b4f2:	e7d5      	b.n	803b4a0 <UTIL_TIMER_IRQ_Handler+0x20>
  if(( TimerListHead != NULL ) && (TimerListHead->IsPending == 0U))
 803b4f4:	7a03      	ldrb	r3, [r0, #8]
 803b4f6:	2b00      	cmp	r3, #0
 803b4f8:	d1d6      	bne.n	803b4a8 <UTIL_TIMER_IRQ_Handler+0x28>
    TimerSetTimeout( TimerListHead );
 803b4fa:	f7ff ff03 	bl	803b304 <TimerSetTimeout>
 803b4fe:	e7d3      	b.n	803b4a8 <UTIL_TIMER_IRQ_Handler+0x28>
 803b500:	0803b8dc 	.word	0x0803b8dc
 803b504:	20006150 	.word	0x20006150

0803b508 <tiny_vsnprintf_like>:

#define CHECK_STR_SIZE(_buf, _str, _size) \
  if ((((_str) - (_buf)) >= ((_size)-1))) { break; }

int tiny_vsnprintf_like(char *buf, const int size, const char *fmt, va_list args)
{
 803b508:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 803b50c:	b099      	sub	sp, #100	; 0x64

  int field_width;      // Width of output field
  int precision;        // Min. # of digits for integers; max number of chars for from string
  int qualifier;        // 'h', 'l', or 'L' for integer fields

  if (size <= 0)
 803b50e:	2900      	cmp	r1, #0
{
 803b510:	4683      	mov	fp, r0
  if (size <= 0)
 803b512:	9105      	str	r1, [sp, #20]
 803b514:	f340 8109 	ble.w	803b72a <tiny_vsnprintf_like+0x222>
  {
    return 0;
  }
  
  for (str = buf; *fmt || ((str - buf) >= size-1); fmt++)
 803b518:	4604      	mov	r4, r0
  if (!(type & (ZEROPAD /* TINY option   | LEFT */))) while (size-- > 0) ASSIGN_STR(' ');
 803b51a:	f04f 0920 	mov.w	r9, #32
  for (str = buf; *fmt || ((str - buf) >= size-1); fmt++)
 803b51e:	9905      	ldr	r1, [sp, #20]
 803b520:	7815      	ldrb	r5, [r2, #0]
 803b522:	eba4 000b 	sub.w	r0, r4, fp
 803b526:	3901      	subs	r1, #1
 803b528:	b925      	cbnz	r5, 803b534 <tiny_vsnprintf_like+0x2c>
      num = va_arg(args, unsigned int);

    str = ee_number(str, ((size - 1) - (str - buf)), num, base, field_width, precision, flags);
  }

  *str = '\0';
 803b52a:	2300      	movs	r3, #0
 803b52c:	7023      	strb	r3, [r4, #0]
  return str - buf;
}
 803b52e:	b019      	add	sp, #100	; 0x64
 803b530:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    CHECK_STR_SIZE(buf, str, size);
 803b534:	4288      	cmp	r0, r1
 803b536:	daf8      	bge.n	803b52a <tiny_vsnprintf_like+0x22>
    if (*fmt != '%')
 803b538:	2d25      	cmp	r5, #37	; 0x25
 803b53a:	d004      	beq.n	803b546 <tiny_vsnprintf_like+0x3e>
      *str++ = *fmt;
 803b53c:	f804 5b01 	strb.w	r5, [r4], #1
      continue;
 803b540:	4616      	mov	r6, r2
  for (str = buf; *fmt || ((str - buf) >= size-1); fmt++)
 803b542:	1c72      	adds	r2, r6, #1
 803b544:	e7eb      	b.n	803b51e <tiny_vsnprintf_like+0x16>
    if (*fmt == '0')
 803b546:	f892 e001 	ldrb.w	lr, [r2, #1]
 803b54a:	1c56      	adds	r6, r2, #1
 803b54c:	f1ae 0230 	sub.w	r2, lr, #48	; 0x30
 803b550:	4250      	negs	r0, r2
 803b552:	4150      	adcs	r0, r2
    if (is_digit(*fmt))
 803b554:	f1ae 0230 	sub.w	r2, lr, #48	; 0x30
 803b558:	2a09      	cmp	r2, #9
 803b55a:	d828      	bhi.n	803b5ae <tiny_vsnprintf_like+0xa6>
 803b55c:	4637      	mov	r7, r6
  int i = 0;
 803b55e:	2500      	movs	r5, #0
 803b560:	463e      	mov	r6, r7
  while (is_digit(**s)) i = i*10 + *((*s)++) - '0';
 803b562:	f817 2b01 	ldrb.w	r2, [r7], #1
 803b566:	f1a2 0c30 	sub.w	ip, r2, #48	; 0x30
 803b56a:	f1bc 0f09 	cmp.w	ip, #9
 803b56e:	d919      	bls.n	803b5a4 <tiny_vsnprintf_like+0x9c>
    switch (*fmt)
 803b570:	7832      	ldrb	r2, [r6, #0]
 803b572:	2a69      	cmp	r2, #105	; 0x69
 803b574:	f000 8097 	beq.w	803b6a6 <tiny_vsnprintf_like+0x19e>
 803b578:	d81c      	bhi.n	803b5b4 <tiny_vsnprintf_like+0xac>
 803b57a:	2a63      	cmp	r2, #99	; 0x63
 803b57c:	d028      	beq.n	803b5d0 <tiny_vsnprintf_like+0xc8>
 803b57e:	2a64      	cmp	r2, #100	; 0x64
 803b580:	f000 8091 	beq.w	803b6a6 <tiny_vsnprintf_like+0x19e>
 803b584:	2a58      	cmp	r2, #88	; 0x58
 803b586:	d059      	beq.n	803b63c <tiny_vsnprintf_like+0x134>
        if (*fmt != '%') *str++ = '%';
 803b588:	2a25      	cmp	r2, #37	; 0x25
 803b58a:	d119      	bne.n	803b5c0 <tiny_vsnprintf_like+0xb8>
        if (*fmt)
 803b58c:	7832      	ldrb	r2, [r6, #0]
 803b58e:	2a00      	cmp	r2, #0
 803b590:	f000 808d 	beq.w	803b6ae <tiny_vsnprintf_like+0x1a6>
          *str++ = *fmt;
 803b594:	f804 2b01 	strb.w	r2, [r4], #1
        CHECK_STR_SIZE(buf, str, size);
 803b598:	eba4 020b 	sub.w	r2, r4, fp
 803b59c:	428a      	cmp	r2, r1
 803b59e:	f280 8084 	bge.w	803b6aa <tiny_vsnprintf_like+0x1a2>
 803b5a2:	e7ce      	b.n	803b542 <tiny_vsnprintf_like+0x3a>
  while (is_digit(**s)) i = i*10 + *((*s)++) - '0';
 803b5a4:	260a      	movs	r6, #10
 803b5a6:	fb06 2505 	mla	r5, r6, r5, r2
 803b5aa:	3d30      	subs	r5, #48	; 0x30
 803b5ac:	e7d8      	b.n	803b560 <tiny_vsnprintf_like+0x58>
    field_width = -1;
 803b5ae:	f04f 35ff 	mov.w	r5, #4294967295
 803b5b2:	e7dd      	b.n	803b570 <tiny_vsnprintf_like+0x68>
    switch (*fmt)
 803b5b4:	2a75      	cmp	r2, #117	; 0x75
 803b5b6:	d078      	beq.n	803b6aa <tiny_vsnprintf_like+0x1a2>
 803b5b8:	2a78      	cmp	r2, #120	; 0x78
 803b5ba:	d041      	beq.n	803b640 <tiny_vsnprintf_like+0x138>
 803b5bc:	2a73      	cmp	r2, #115	; 0x73
 803b5be:	d01c      	beq.n	803b5fa <tiny_vsnprintf_like+0xf2>
        if (*fmt != '%') *str++ = '%';
 803b5c0:	2225      	movs	r2, #37	; 0x25
 803b5c2:	f804 2b01 	strb.w	r2, [r4], #1
        CHECK_STR_SIZE(buf, str, size);
 803b5c6:	eba4 020b 	sub.w	r2, r4, fp
 803b5ca:	428a      	cmp	r2, r1
 803b5cc:	da6d      	bge.n	803b6aa <tiny_vsnprintf_like+0x1a2>
 803b5ce:	e7dd      	b.n	803b58c <tiny_vsnprintf_like+0x84>
 803b5d0:	1e61      	subs	r1, r4, #1
    switch (*fmt)
 803b5d2:	462a      	mov	r2, r5
          while (--field_width > 0) *str++ = ' ';
 803b5d4:	3a01      	subs	r2, #1
 803b5d6:	2a00      	cmp	r2, #0
 803b5d8:	dc0c      	bgt.n	803b5f4 <tiny_vsnprintf_like+0xec>
 803b5da:	2d00      	cmp	r5, #0
 803b5dc:	f105 32ff 	add.w	r2, r5, #4294967295
 803b5e0:	bfd8      	it	le
 803b5e2:	2200      	movle	r2, #0
 803b5e4:	4422      	add	r2, r4
        *str++ = (unsigned char) va_arg(args, int);
 803b5e6:	f853 1b04 	ldr.w	r1, [r3], #4
 803b5ea:	7011      	strb	r1, [r2, #0]
 803b5ec:	bfd8      	it	le
 803b5ee:	2501      	movle	r5, #1
 803b5f0:	442c      	add	r4, r5
        continue;
 803b5f2:	e7a6      	b.n	803b542 <tiny_vsnprintf_like+0x3a>
          while (--field_width > 0) *str++ = ' ';
 803b5f4:	f801 9f01 	strb.w	r9, [r1, #1]!
 803b5f8:	e7ec      	b.n	803b5d4 <tiny_vsnprintf_like+0xcc>
        s = va_arg(args, char *);
 803b5fa:	4698      	mov	r8, r3
        if (!s) s = "<NULL>";
 803b5fc:	4b4c      	ldr	r3, [pc, #304]	; (803b730 <tiny_vsnprintf_like+0x228>)
        s = va_arg(args, char *);
 803b5fe:	f858 7b04 	ldr.w	r7, [r8], #4
        if (!s) s = "<NULL>";
 803b602:	2f00      	cmp	r7, #0
 803b604:	bf08      	it	eq
 803b606:	461f      	moveq	r7, r3
        len = strlen(s);
 803b608:	4638      	mov	r0, r7
 803b60a:	f7ef ff19 	bl	802b440 <strlen>
          while (len < field_width--) *str++ = ' ';
 803b60e:	4623      	mov	r3, r4
 803b610:	1961      	adds	r1, r4, r5
 803b612:	1aca      	subs	r2, r1, r3
 803b614:	4290      	cmp	r0, r2
 803b616:	db0a      	blt.n	803b62e <tiny_vsnprintf_like+0x126>
 803b618:	1a2b      	subs	r3, r5, r0
 803b61a:	4285      	cmp	r5, r0
 803b61c:	bfb8      	it	lt
 803b61e:	2300      	movlt	r3, #0
 803b620:	441c      	add	r4, r3
        for (i = 0; i < len; ++i) *str++ = *s++;
 803b622:	2300      	movs	r3, #0
 803b624:	4283      	cmp	r3, r0
 803b626:	db05      	blt.n	803b634 <tiny_vsnprintf_like+0x12c>
 803b628:	4404      	add	r4, r0
        s = va_arg(args, char *);
 803b62a:	4643      	mov	r3, r8
 803b62c:	e789      	b.n	803b542 <tiny_vsnprintf_like+0x3a>
          while (len < field_width--) *str++ = ' ';
 803b62e:	f803 9b01 	strb.w	r9, [r3], #1
 803b632:	e7ee      	b.n	803b612 <tiny_vsnprintf_like+0x10a>
        for (i = 0; i < len; ++i) *str++ = *s++;
 803b634:	5cfa      	ldrb	r2, [r7, r3]
 803b636:	54e2      	strb	r2, [r4, r3]
 803b638:	3301      	adds	r3, #1
 803b63a:	e7f3      	b.n	803b624 <tiny_vsnprintf_like+0x11c>
        flags |= UPPERCASE;
 803b63c:	f040 0040 	orr.w	r0, r0, #64	; 0x40
    switch (*fmt)
 803b640:	2710      	movs	r7, #16
    str = ee_number(str, ((size - 1) - (str - buf)), num, base, field_width, precision, flags);
 803b642:	eba4 020b 	sub.w	r2, r4, fp
 803b646:	9302      	str	r3, [sp, #8]
 803b648:	1a8b      	subs	r3, r1, r2
 803b64a:	9301      	str	r3, [sp, #4]
 803b64c:	9b02      	ldr	r3, [sp, #8]
  char *dig = lower_digits;
 803b64e:	4a39      	ldr	r2, [pc, #228]	; (803b734 <tiny_vsnprintf_like+0x22c>)
    str = ee_number(str, ((size - 1) - (str - buf)), num, base, field_width, precision, flags);
 803b650:	f853 1b04 	ldr.w	r1, [r3], #4
 803b654:	9302      	str	r3, [sp, #8]
  char *dig = lower_digits;
 803b656:	f010 0f40 	tst.w	r0, #64	; 0x40
 803b65a:	4b37      	ldr	r3, [pc, #220]	; (803b738 <tiny_vsnprintf_like+0x230>)
 803b65c:	bf08      	it	eq
 803b65e:	4613      	moveq	r3, r2
  c = (type & ZEROPAD) ? '0' : ' ';
 803b660:	f1be 0f30 	cmp.w	lr, #48	; 0x30
  char *dig = lower_digits;
 803b664:	9303      	str	r3, [sp, #12]
  c = (type & ZEROPAD) ? '0' : ' ';
 803b666:	bf0c      	ite	eq
 803b668:	2330      	moveq	r3, #48	; 0x30
 803b66a:	2320      	movne	r3, #32
 803b66c:	9304      	str	r3, [sp, #16]
  if (type & SIGN)
 803b66e:	0783      	lsls	r3, r0, #30
 803b670:	d51f      	bpl.n	803b6b2 <tiny_vsnprintf_like+0x1aa>
    if (num < 0)
 803b672:	2900      	cmp	r1, #0
 803b674:	da1d      	bge.n	803b6b2 <tiny_vsnprintf_like+0x1aa>
      num = -num;
 803b676:	4249      	negs	r1, r1
      size--;
 803b678:	3d01      	subs	r5, #1
      sign = '-';
 803b67a:	f04f 0c2d 	mov.w	ip, #45	; 0x2d
    while (num != 0)
 803b67e:	ab07      	add	r3, sp, #28
 803b680:	461a      	mov	r2, r3
  i = 0;
 803b682:	2000      	movs	r0, #0
      tmp[i++] = dig[((unsigned long) num) % (unsigned) base];
 803b684:	4688      	mov	r8, r1
 803b686:	9b03      	ldr	r3, [sp, #12]
 803b688:	fbb1 f1f7 	udiv	r1, r1, r7
 803b68c:	fb07 8a11 	mls	sl, r7, r1, r8
    while (num != 0)
 803b690:	4547      	cmp	r7, r8
      tmp[i++] = dig[((unsigned long) num) % (unsigned) base];
 803b692:	f813 a00a 	ldrb.w	sl, [r3, sl]
 803b696:	4613      	mov	r3, r2
 803b698:	f100 0001 	add.w	r0, r0, #1
 803b69c:	f803 ab01 	strb.w	sl, [r3], #1
 803b6a0:	461a      	mov	r2, r3
    while (num != 0)
 803b6a2:	d9ef      	bls.n	803b684 <tiny_vsnprintf_like+0x17c>
 803b6a4:	e00e      	b.n	803b6c4 <tiny_vsnprintf_like+0x1bc>
        flags |= SIGN;
 803b6a6:	f040 0002 	orr.w	r0, r0, #2
    base = 10;
 803b6aa:	270a      	movs	r7, #10
 803b6ac:	e7c9      	b.n	803b642 <tiny_vsnprintf_like+0x13a>
          --fmt;
 803b6ae:	3e01      	subs	r6, #1
        CHECK_STR_SIZE(buf, str, size);
 803b6b0:	e747      	b.n	803b542 <tiny_vsnprintf_like+0x3a>
  if (num == 0)
 803b6b2:	b111      	cbz	r1, 803b6ba <tiny_vsnprintf_like+0x1b2>
 803b6b4:	f04f 0c00 	mov.w	ip, #0
 803b6b8:	e7e1      	b.n	803b67e <tiny_vsnprintf_like+0x176>
    tmp[i++] = '0';
 803b6ba:	2030      	movs	r0, #48	; 0x30
 803b6bc:	f88d 001c 	strb.w	r0, [sp, #28]
 803b6c0:	468c      	mov	ip, r1
 803b6c2:	2001      	movs	r0, #1
  if (!(type & (ZEROPAD /* TINY option   | LEFT */))) while (size-- > 0) ASSIGN_STR(' ');
 803b6c4:	f1be 0f30 	cmp.w	lr, #48	; 0x30
  size -= precision;
 803b6c8:	eba5 0500 	sub.w	r5, r5, r0
  if (!(type & (ZEROPAD /* TINY option   | LEFT */))) while (size-- > 0) ASSIGN_STR(' ');
 803b6cc:	d110      	bne.n	803b6f0 <tiny_vsnprintf_like+0x1e8>
  if (sign) ASSIGN_STR(sign);
 803b6ce:	f1bc 0f00 	cmp.w	ip, #0
 803b6d2:	d028      	beq.n	803b726 <tiny_vsnprintf_like+0x21e>
 803b6d4:	9b01      	ldr	r3, [sp, #4]
 803b6d6:	f804 cb01 	strb.w	ip, [r4], #1
 803b6da:	3b01      	subs	r3, #1
 803b6dc:	9301      	str	r3, [sp, #4]
 803b6de:	d122      	bne.n	803b726 <tiny_vsnprintf_like+0x21e>
 803b6e0:	9b02      	ldr	r3, [sp, #8]
 803b6e2:	e72e      	b.n	803b542 <tiny_vsnprintf_like+0x3a>
  if (!(type & (ZEROPAD /* TINY option   | LEFT */))) while (size-- > 0) ASSIGN_STR(' ');
 803b6e4:	9b01      	ldr	r3, [sp, #4]
 803b6e6:	f804 9b01 	strb.w	r9, [r4], #1
 803b6ea:	3b01      	subs	r3, #1
 803b6ec:	9301      	str	r3, [sp, #4]
 803b6ee:	d0f7      	beq.n	803b6e0 <tiny_vsnprintf_like+0x1d8>
 803b6f0:	2d00      	cmp	r5, #0
 803b6f2:	f105 35ff 	add.w	r5, r5, #4294967295
 803b6f6:	dcf5      	bgt.n	803b6e4 <tiny_vsnprintf_like+0x1dc>
 803b6f8:	e7e9      	b.n	803b6ce <tiny_vsnprintf_like+0x1c6>
  while (size-- > 0) ASSIGN_STR(c);
 803b6fa:	9b04      	ldr	r3, [sp, #16]
 803b6fc:	f804 3b01 	strb.w	r3, [r4], #1
 803b700:	9b01      	ldr	r3, [sp, #4]
 803b702:	3b01      	subs	r3, #1
 803b704:	9301      	str	r3, [sp, #4]
 803b706:	d0eb      	beq.n	803b6e0 <tiny_vsnprintf_like+0x1d8>
 803b708:	1b29      	subs	r1, r5, r4
 803b70a:	2900      	cmp	r1, #0
 803b70c:	dcf5      	bgt.n	803b6fa <tiny_vsnprintf_like+0x1f2>
  while (i-- > 0) ASSIGN_STR(tmp[i]);
 803b70e:	9b01      	ldr	r3, [sp, #4]
 803b710:	4423      	add	r3, r4
 803b712:	461a      	mov	r2, r3
 803b714:	3801      	subs	r0, #1
 803b716:	d3e3      	bcc.n	803b6e0 <tiny_vsnprintf_like+0x1d8>
 803b718:	ab07      	add	r3, sp, #28
 803b71a:	5c19      	ldrb	r1, [r3, r0]
 803b71c:	f804 1b01 	strb.w	r1, [r4], #1
 803b720:	4294      	cmp	r4, r2
 803b722:	d1f7      	bne.n	803b714 <tiny_vsnprintf_like+0x20c>
 803b724:	e7dc      	b.n	803b6e0 <tiny_vsnprintf_like+0x1d8>
 803b726:	4425      	add	r5, r4
 803b728:	e7ee      	b.n	803b708 <tiny_vsnprintf_like+0x200>
    return 0;
 803b72a:	2000      	movs	r0, #0
 803b72c:	e6ff      	b.n	803b52e <tiny_vsnprintf_like+0x26>
 803b72e:	bf00      	nop
 803b730:	0803c5be 	.word	0x0803c5be
 803b734:	0803c5ea 	.word	0x0803c5ea
 803b738:	0803c5c5 	.word	0x0803c5c5

0803b73c <__libc_init_array>:
 803b73c:	b570      	push	{r4, r5, r6, lr}
 803b73e:	4d0d      	ldr	r5, [pc, #52]	; (803b774 <__libc_init_array+0x38>)
 803b740:	4c0d      	ldr	r4, [pc, #52]	; (803b778 <__libc_init_array+0x3c>)
 803b742:	1b64      	subs	r4, r4, r5
 803b744:	10a4      	asrs	r4, r4, #2
 803b746:	2600      	movs	r6, #0
 803b748:	42a6      	cmp	r6, r4
 803b74a:	d109      	bne.n	803b760 <__libc_init_array+0x24>
 803b74c:	4d0b      	ldr	r5, [pc, #44]	; (803b77c <__libc_init_array+0x40>)
 803b74e:	4c0c      	ldr	r4, [pc, #48]	; (803b780 <__libc_init_array+0x44>)
 803b750:	f000 f8a2 	bl	803b898 <_init>
 803b754:	1b64      	subs	r4, r4, r5
 803b756:	10a4      	asrs	r4, r4, #2
 803b758:	2600      	movs	r6, #0
 803b75a:	42a6      	cmp	r6, r4
 803b75c:	d105      	bne.n	803b76a <__libc_init_array+0x2e>
 803b75e:	bd70      	pop	{r4, r5, r6, pc}
 803b760:	f855 3b04 	ldr.w	r3, [r5], #4
 803b764:	4798      	blx	r3
 803b766:	3601      	adds	r6, #1
 803b768:	e7ee      	b.n	803b748 <__libc_init_array+0xc>
 803b76a:	f855 3b04 	ldr.w	r3, [r5], #4
 803b76e:	4798      	blx	r3
 803b770:	3601      	adds	r6, #1
 803b772:	e7f2      	b.n	803b75a <__libc_init_array+0x1e>
 803b774:	0803c618 	.word	0x0803c618
 803b778:	0803c618 	.word	0x0803c618
 803b77c:	0803c618 	.word	0x0803c618
 803b780:	0803c61c 	.word	0x0803c61c

0803b784 <memset>:
 803b784:	4402      	add	r2, r0
 803b786:	4603      	mov	r3, r0
 803b788:	4293      	cmp	r3, r2
 803b78a:	d100      	bne.n	803b78e <memset+0xa>
 803b78c:	4770      	bx	lr
 803b78e:	f803 1b01 	strb.w	r1, [r3], #1
 803b792:	e7f9      	b.n	803b788 <memset+0x4>
 803b794:	0000      	movs	r0, r0
	...

0803b798 <floor>:
 803b798:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 803b79c:	f3c1 580a 	ubfx	r8, r1, #20, #11
 803b7a0:	f2a8 36ff 	subw	r6, r8, #1023	; 0x3ff
 803b7a4:	2e13      	cmp	r6, #19
 803b7a6:	4602      	mov	r2, r0
 803b7a8:	460b      	mov	r3, r1
 803b7aa:	4607      	mov	r7, r0
 803b7ac:	460c      	mov	r4, r1
 803b7ae:	4605      	mov	r5, r0
 803b7b0:	dc34      	bgt.n	803b81c <floor+0x84>
 803b7b2:	2e00      	cmp	r6, #0
 803b7b4:	da15      	bge.n	803b7e2 <floor+0x4a>
 803b7b6:	a334      	add	r3, pc, #208	; (adr r3, 803b888 <floor+0xf0>)
 803b7b8:	e9d3 2300 	ldrd	r2, r3, [r3]
 803b7bc:	f7ef fe4e 	bl	802b45c <__adddf3>
 803b7c0:	2200      	movs	r2, #0
 803b7c2:	2300      	movs	r3, #0
 803b7c4:	f7f0 f87e 	bl	802b8c4 <__aeabi_dcmpgt>
 803b7c8:	b140      	cbz	r0, 803b7dc <floor+0x44>
 803b7ca:	2c00      	cmp	r4, #0
 803b7cc:	da59      	bge.n	803b882 <floor+0xea>
 803b7ce:	f024 4300 	bic.w	r3, r4, #2147483648	; 0x80000000
 803b7d2:	ea57 0503 	orrs.w	r5, r7, r3
 803b7d6:	d001      	beq.n	803b7dc <floor+0x44>
 803b7d8:	4c2d      	ldr	r4, [pc, #180]	; (803b890 <floor+0xf8>)
 803b7da:	2500      	movs	r5, #0
 803b7dc:	4623      	mov	r3, r4
 803b7de:	462f      	mov	r7, r5
 803b7e0:	e025      	b.n	803b82e <floor+0x96>
 803b7e2:	4a2c      	ldr	r2, [pc, #176]	; (803b894 <floor+0xfc>)
 803b7e4:	fa42 f806 	asr.w	r8, r2, r6
 803b7e8:	ea01 0208 	and.w	r2, r1, r8
 803b7ec:	4302      	orrs	r2, r0
 803b7ee:	d01e      	beq.n	803b82e <floor+0x96>
 803b7f0:	a325      	add	r3, pc, #148	; (adr r3, 803b888 <floor+0xf0>)
 803b7f2:	e9d3 2300 	ldrd	r2, r3, [r3]
 803b7f6:	f7ef fe31 	bl	802b45c <__adddf3>
 803b7fa:	2200      	movs	r2, #0
 803b7fc:	2300      	movs	r3, #0
 803b7fe:	f7f0 f861 	bl	802b8c4 <__aeabi_dcmpgt>
 803b802:	2800      	cmp	r0, #0
 803b804:	d0ea      	beq.n	803b7dc <floor+0x44>
 803b806:	2c00      	cmp	r4, #0
 803b808:	bfbe      	ittt	lt
 803b80a:	f44f 1380 	movlt.w	r3, #1048576	; 0x100000
 803b80e:	fa43 f606 	asrlt.w	r6, r3, r6
 803b812:	19a4      	addlt	r4, r4, r6
 803b814:	ea24 0408 	bic.w	r4, r4, r8
 803b818:	2500      	movs	r5, #0
 803b81a:	e7df      	b.n	803b7dc <floor+0x44>
 803b81c:	2e33      	cmp	r6, #51	; 0x33
 803b81e:	dd0a      	ble.n	803b836 <floor+0x9e>
 803b820:	f5b6 6f80 	cmp.w	r6, #1024	; 0x400
 803b824:	d103      	bne.n	803b82e <floor+0x96>
 803b826:	f7ef fe19 	bl	802b45c <__adddf3>
 803b82a:	4607      	mov	r7, r0
 803b82c:	460b      	mov	r3, r1
 803b82e:	4638      	mov	r0, r7
 803b830:	4619      	mov	r1, r3
 803b832:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 803b836:	f2a8 4813 	subw	r8, r8, #1043	; 0x413
 803b83a:	f04f 32ff 	mov.w	r2, #4294967295
 803b83e:	fa22 f808 	lsr.w	r8, r2, r8
 803b842:	ea18 0f00 	tst.w	r8, r0
 803b846:	d0f2      	beq.n	803b82e <floor+0x96>
 803b848:	a30f      	add	r3, pc, #60	; (adr r3, 803b888 <floor+0xf0>)
 803b84a:	e9d3 2300 	ldrd	r2, r3, [r3]
 803b84e:	f7ef fe05 	bl	802b45c <__adddf3>
 803b852:	2200      	movs	r2, #0
 803b854:	2300      	movs	r3, #0
 803b856:	f7f0 f835 	bl	802b8c4 <__aeabi_dcmpgt>
 803b85a:	2800      	cmp	r0, #0
 803b85c:	d0be      	beq.n	803b7dc <floor+0x44>
 803b85e:	2c00      	cmp	r4, #0
 803b860:	da02      	bge.n	803b868 <floor+0xd0>
 803b862:	2e14      	cmp	r6, #20
 803b864:	d103      	bne.n	803b86e <floor+0xd6>
 803b866:	3401      	adds	r4, #1
 803b868:	ea25 0508 	bic.w	r5, r5, r8
 803b86c:	e7b6      	b.n	803b7dc <floor+0x44>
 803b86e:	2301      	movs	r3, #1
 803b870:	f1c6 0634 	rsb	r6, r6, #52	; 0x34
 803b874:	fa03 f606 	lsl.w	r6, r3, r6
 803b878:	4435      	add	r5, r6
 803b87a:	42bd      	cmp	r5, r7
 803b87c:	bf38      	it	cc
 803b87e:	18e4      	addcc	r4, r4, r3
 803b880:	e7f2      	b.n	803b868 <floor+0xd0>
 803b882:	2500      	movs	r5, #0
 803b884:	462c      	mov	r4, r5
 803b886:	e7a9      	b.n	803b7dc <floor+0x44>
 803b888:	8800759c 	.word	0x8800759c
 803b88c:	7e37e43c 	.word	0x7e37e43c
 803b890:	bff00000 	.word	0xbff00000
 803b894:	000fffff 	.word	0x000fffff

0803b898 <_init>:
 803b898:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 803b89a:	bf00      	nop
 803b89c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 803b89e:	bc08      	pop	{r3}
 803b8a0:	469e      	mov	lr, r3
 803b8a2:	4770      	bx	lr

0803b8a4 <_fini>:
 803b8a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 803b8a6:	bf00      	nop
 803b8a8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 803b8aa:	bc08      	pop	{r3}
 803b8ac:	469e      	mov	lr, r3
 803b8ae:	4770      	bx	lr
