
LoRaWAN_End_Node.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000200  0802b200  0802b200  000000f4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000104b0  0802b400  0802b400  000002f8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000d60  0803b8b0  0803b8b0  000107a8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0803c610  0803c610  000116c8  2**0
                  CONTENTS
  4 .ARM          00000008  0803c610  0803c610  00011508  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  0803c618  0803c618  000116c8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  0803c618  0803c618  00011510  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  0803c61c  0803c61c  00011514  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         000001ac  20003400  0803c620  00011518  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .align16      00000004  0803c7cc  0803c7cc  000116c4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 10 .bss          00002e00  200035ac  200035ac  000116c8  2**2
                  ALLOC
 11 ._user_heap_stack 00000a04  200063ac  200063ac  000116c8  2**0
                  ALLOC
 12 .ARM.attributes 0000002a  00000000  00000000  000116c8  2**0
                  CONTENTS, READONLY
 13 .debug_info   00082a28  00000000  00000000  000116f2  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 00010795  00000000  00000000  0009411a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_loc    00024951  00000000  00000000  000a48af  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_aranges 000028d8  00000000  00000000  000c9200  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_ranges 00004a88  00000000  00000000  000cbad8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_macro  0002f3fc  00000000  00000000  000d0560  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_line   000524ec  00000000  00000000  000ff95c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_str    000e6679  00000000  00000000  00151e48  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .comment      00000053  00000000  00000000  002384c1  2**0
                  CONTENTS, READONLY
 22 .debug_frame  000072c4  00000000  00000000  00238514  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

0802b400 <__do_global_dtors_aux>:
 802b400:	b510      	push	{r4, lr}
 802b402:	4c05      	ldr	r4, [pc, #20]	; (802b418 <__do_global_dtors_aux+0x18>)
 802b404:	7823      	ldrb	r3, [r4, #0]
 802b406:	b933      	cbnz	r3, 802b416 <__do_global_dtors_aux+0x16>
 802b408:	4b04      	ldr	r3, [pc, #16]	; (802b41c <__do_global_dtors_aux+0x1c>)
 802b40a:	b113      	cbz	r3, 802b412 <__do_global_dtors_aux+0x12>
 802b40c:	4804      	ldr	r0, [pc, #16]	; (802b420 <__do_global_dtors_aux+0x20>)
 802b40e:	f3af 8000 	nop.w
 802b412:	2301      	movs	r3, #1
 802b414:	7023      	strb	r3, [r4, #0]
 802b416:	bd10      	pop	{r4, pc}
 802b418:	200035ac 	.word	0x200035ac
 802b41c:	00000000 	.word	0x00000000
 802b420:	0803b898 	.word	0x0803b898

0802b424 <frame_dummy>:
 802b424:	b508      	push	{r3, lr}
 802b426:	4b03      	ldr	r3, [pc, #12]	; (802b434 <frame_dummy+0x10>)
 802b428:	b11b      	cbz	r3, 802b432 <frame_dummy+0xe>
 802b42a:	4903      	ldr	r1, [pc, #12]	; (802b438 <frame_dummy+0x14>)
 802b42c:	4803      	ldr	r0, [pc, #12]	; (802b43c <frame_dummy+0x18>)
 802b42e:	f3af 8000 	nop.w
 802b432:	bd08      	pop	{r3, pc}
 802b434:	00000000 	.word	0x00000000
 802b438:	200035b0 	.word	0x200035b0
 802b43c:	0803b898 	.word	0x0803b898

0802b440 <strlen>:
 802b440:	4603      	mov	r3, r0
 802b442:	f813 2b01 	ldrb.w	r2, [r3], #1
 802b446:	2a00      	cmp	r2, #0
 802b448:	d1fb      	bne.n	802b442 <strlen+0x2>
 802b44a:	1a18      	subs	r0, r3, r0
 802b44c:	3801      	subs	r0, #1
 802b44e:	4770      	bx	lr

0802b450 <__aeabi_drsub>:
 802b450:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 802b454:	e002      	b.n	802b45c <__adddf3>
 802b456:	bf00      	nop

0802b458 <__aeabi_dsub>:
 802b458:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0802b45c <__adddf3>:
 802b45c:	b530      	push	{r4, r5, lr}
 802b45e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 802b462:	ea4f 0543 	mov.w	r5, r3, lsl #1
 802b466:	ea94 0f05 	teq	r4, r5
 802b46a:	bf08      	it	eq
 802b46c:	ea90 0f02 	teqeq	r0, r2
 802b470:	bf1f      	itttt	ne
 802b472:	ea54 0c00 	orrsne.w	ip, r4, r0
 802b476:	ea55 0c02 	orrsne.w	ip, r5, r2
 802b47a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 802b47e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 802b482:	f000 80e2 	beq.w	802b64a <__adddf3+0x1ee>
 802b486:	ea4f 5454 	mov.w	r4, r4, lsr #21
 802b48a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 802b48e:	bfb8      	it	lt
 802b490:	426d      	neglt	r5, r5
 802b492:	dd0c      	ble.n	802b4ae <__adddf3+0x52>
 802b494:	442c      	add	r4, r5
 802b496:	ea80 0202 	eor.w	r2, r0, r2
 802b49a:	ea81 0303 	eor.w	r3, r1, r3
 802b49e:	ea82 0000 	eor.w	r0, r2, r0
 802b4a2:	ea83 0101 	eor.w	r1, r3, r1
 802b4a6:	ea80 0202 	eor.w	r2, r0, r2
 802b4aa:	ea81 0303 	eor.w	r3, r1, r3
 802b4ae:	2d36      	cmp	r5, #54	; 0x36
 802b4b0:	bf88      	it	hi
 802b4b2:	bd30      	pophi	{r4, r5, pc}
 802b4b4:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 802b4b8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 802b4bc:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 802b4c0:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 802b4c4:	d002      	beq.n	802b4cc <__adddf3+0x70>
 802b4c6:	4240      	negs	r0, r0
 802b4c8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 802b4cc:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 802b4d0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 802b4d4:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 802b4d8:	d002      	beq.n	802b4e0 <__adddf3+0x84>
 802b4da:	4252      	negs	r2, r2
 802b4dc:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 802b4e0:	ea94 0f05 	teq	r4, r5
 802b4e4:	f000 80a7 	beq.w	802b636 <__adddf3+0x1da>
 802b4e8:	f1a4 0401 	sub.w	r4, r4, #1
 802b4ec:	f1d5 0e20 	rsbs	lr, r5, #32
 802b4f0:	db0d      	blt.n	802b50e <__adddf3+0xb2>
 802b4f2:	fa02 fc0e 	lsl.w	ip, r2, lr
 802b4f6:	fa22 f205 	lsr.w	r2, r2, r5
 802b4fa:	1880      	adds	r0, r0, r2
 802b4fc:	f141 0100 	adc.w	r1, r1, #0
 802b500:	fa03 f20e 	lsl.w	r2, r3, lr
 802b504:	1880      	adds	r0, r0, r2
 802b506:	fa43 f305 	asr.w	r3, r3, r5
 802b50a:	4159      	adcs	r1, r3
 802b50c:	e00e      	b.n	802b52c <__adddf3+0xd0>
 802b50e:	f1a5 0520 	sub.w	r5, r5, #32
 802b512:	f10e 0e20 	add.w	lr, lr, #32
 802b516:	2a01      	cmp	r2, #1
 802b518:	fa03 fc0e 	lsl.w	ip, r3, lr
 802b51c:	bf28      	it	cs
 802b51e:	f04c 0c02 	orrcs.w	ip, ip, #2
 802b522:	fa43 f305 	asr.w	r3, r3, r5
 802b526:	18c0      	adds	r0, r0, r3
 802b528:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 802b52c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 802b530:	d507      	bpl.n	802b542 <__adddf3+0xe6>
 802b532:	f04f 0e00 	mov.w	lr, #0
 802b536:	f1dc 0c00 	rsbs	ip, ip, #0
 802b53a:	eb7e 0000 	sbcs.w	r0, lr, r0
 802b53e:	eb6e 0101 	sbc.w	r1, lr, r1
 802b542:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 802b546:	d31b      	bcc.n	802b580 <__adddf3+0x124>
 802b548:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 802b54c:	d30c      	bcc.n	802b568 <__adddf3+0x10c>
 802b54e:	0849      	lsrs	r1, r1, #1
 802b550:	ea5f 0030 	movs.w	r0, r0, rrx
 802b554:	ea4f 0c3c 	mov.w	ip, ip, rrx
 802b558:	f104 0401 	add.w	r4, r4, #1
 802b55c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 802b560:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 802b564:	f080 809a 	bcs.w	802b69c <__adddf3+0x240>
 802b568:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 802b56c:	bf08      	it	eq
 802b56e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 802b572:	f150 0000 	adcs.w	r0, r0, #0
 802b576:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 802b57a:	ea41 0105 	orr.w	r1, r1, r5
 802b57e:	bd30      	pop	{r4, r5, pc}
 802b580:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 802b584:	4140      	adcs	r0, r0
 802b586:	eb41 0101 	adc.w	r1, r1, r1
 802b58a:	3c01      	subs	r4, #1
 802b58c:	bf28      	it	cs
 802b58e:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
 802b592:	d2e9      	bcs.n	802b568 <__adddf3+0x10c>
 802b594:	f091 0f00 	teq	r1, #0
 802b598:	bf04      	itt	eq
 802b59a:	4601      	moveq	r1, r0
 802b59c:	2000      	moveq	r0, #0
 802b59e:	fab1 f381 	clz	r3, r1
 802b5a2:	bf08      	it	eq
 802b5a4:	3320      	addeq	r3, #32
 802b5a6:	f1a3 030b 	sub.w	r3, r3, #11
 802b5aa:	f1b3 0220 	subs.w	r2, r3, #32
 802b5ae:	da0c      	bge.n	802b5ca <__adddf3+0x16e>
 802b5b0:	320c      	adds	r2, #12
 802b5b2:	dd08      	ble.n	802b5c6 <__adddf3+0x16a>
 802b5b4:	f102 0c14 	add.w	ip, r2, #20
 802b5b8:	f1c2 020c 	rsb	r2, r2, #12
 802b5bc:	fa01 f00c 	lsl.w	r0, r1, ip
 802b5c0:	fa21 f102 	lsr.w	r1, r1, r2
 802b5c4:	e00c      	b.n	802b5e0 <__adddf3+0x184>
 802b5c6:	f102 0214 	add.w	r2, r2, #20
 802b5ca:	bfd8      	it	le
 802b5cc:	f1c2 0c20 	rsble	ip, r2, #32
 802b5d0:	fa01 f102 	lsl.w	r1, r1, r2
 802b5d4:	fa20 fc0c 	lsr.w	ip, r0, ip
 802b5d8:	bfdc      	itt	le
 802b5da:	ea41 010c 	orrle.w	r1, r1, ip
 802b5de:	4090      	lslle	r0, r2
 802b5e0:	1ae4      	subs	r4, r4, r3
 802b5e2:	bfa2      	ittt	ge
 802b5e4:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 802b5e8:	4329      	orrge	r1, r5
 802b5ea:	bd30      	popge	{r4, r5, pc}
 802b5ec:	ea6f 0404 	mvn.w	r4, r4
 802b5f0:	3c1f      	subs	r4, #31
 802b5f2:	da1c      	bge.n	802b62e <__adddf3+0x1d2>
 802b5f4:	340c      	adds	r4, #12
 802b5f6:	dc0e      	bgt.n	802b616 <__adddf3+0x1ba>
 802b5f8:	f104 0414 	add.w	r4, r4, #20
 802b5fc:	f1c4 0220 	rsb	r2, r4, #32
 802b600:	fa20 f004 	lsr.w	r0, r0, r4
 802b604:	fa01 f302 	lsl.w	r3, r1, r2
 802b608:	ea40 0003 	orr.w	r0, r0, r3
 802b60c:	fa21 f304 	lsr.w	r3, r1, r4
 802b610:	ea45 0103 	orr.w	r1, r5, r3
 802b614:	bd30      	pop	{r4, r5, pc}
 802b616:	f1c4 040c 	rsb	r4, r4, #12
 802b61a:	f1c4 0220 	rsb	r2, r4, #32
 802b61e:	fa20 f002 	lsr.w	r0, r0, r2
 802b622:	fa01 f304 	lsl.w	r3, r1, r4
 802b626:	ea40 0003 	orr.w	r0, r0, r3
 802b62a:	4629      	mov	r1, r5
 802b62c:	bd30      	pop	{r4, r5, pc}
 802b62e:	fa21 f004 	lsr.w	r0, r1, r4
 802b632:	4629      	mov	r1, r5
 802b634:	bd30      	pop	{r4, r5, pc}
 802b636:	f094 0f00 	teq	r4, #0
 802b63a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 802b63e:	bf06      	itte	eq
 802b640:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 802b644:	3401      	addeq	r4, #1
 802b646:	3d01      	subne	r5, #1
 802b648:	e74e      	b.n	802b4e8 <__adddf3+0x8c>
 802b64a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 802b64e:	bf18      	it	ne
 802b650:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 802b654:	d029      	beq.n	802b6aa <__adddf3+0x24e>
 802b656:	ea94 0f05 	teq	r4, r5
 802b65a:	bf08      	it	eq
 802b65c:	ea90 0f02 	teqeq	r0, r2
 802b660:	d005      	beq.n	802b66e <__adddf3+0x212>
 802b662:	ea54 0c00 	orrs.w	ip, r4, r0
 802b666:	bf04      	itt	eq
 802b668:	4619      	moveq	r1, r3
 802b66a:	4610      	moveq	r0, r2
 802b66c:	bd30      	pop	{r4, r5, pc}
 802b66e:	ea91 0f03 	teq	r1, r3
 802b672:	bf1e      	ittt	ne
 802b674:	2100      	movne	r1, #0
 802b676:	2000      	movne	r0, #0
 802b678:	bd30      	popne	{r4, r5, pc}
 802b67a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 802b67e:	d105      	bne.n	802b68c <__adddf3+0x230>
 802b680:	0040      	lsls	r0, r0, #1
 802b682:	4149      	adcs	r1, r1
 802b684:	bf28      	it	cs
 802b686:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 802b68a:	bd30      	pop	{r4, r5, pc}
 802b68c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 802b690:	bf3c      	itt	cc
 802b692:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 802b696:	bd30      	popcc	{r4, r5, pc}
 802b698:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 802b69c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 802b6a0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 802b6a4:	f04f 0000 	mov.w	r0, #0
 802b6a8:	bd30      	pop	{r4, r5, pc}
 802b6aa:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 802b6ae:	bf1a      	itte	ne
 802b6b0:	4619      	movne	r1, r3
 802b6b2:	4610      	movne	r0, r2
 802b6b4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 802b6b8:	bf1c      	itt	ne
 802b6ba:	460b      	movne	r3, r1
 802b6bc:	4602      	movne	r2, r0
 802b6be:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 802b6c2:	bf06      	itte	eq
 802b6c4:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 802b6c8:	ea91 0f03 	teqeq	r1, r3
 802b6cc:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 802b6d0:	bd30      	pop	{r4, r5, pc}
 802b6d2:	bf00      	nop

0802b6d4 <__aeabi_ui2d>:
 802b6d4:	f090 0f00 	teq	r0, #0
 802b6d8:	bf04      	itt	eq
 802b6da:	2100      	moveq	r1, #0
 802b6dc:	4770      	bxeq	lr
 802b6de:	b530      	push	{r4, r5, lr}
 802b6e0:	f44f 6480 	mov.w	r4, #1024	; 0x400
 802b6e4:	f104 0432 	add.w	r4, r4, #50	; 0x32
 802b6e8:	f04f 0500 	mov.w	r5, #0
 802b6ec:	f04f 0100 	mov.w	r1, #0
 802b6f0:	e750      	b.n	802b594 <__adddf3+0x138>
 802b6f2:	bf00      	nop

0802b6f4 <__aeabi_i2d>:
 802b6f4:	f090 0f00 	teq	r0, #0
 802b6f8:	bf04      	itt	eq
 802b6fa:	2100      	moveq	r1, #0
 802b6fc:	4770      	bxeq	lr
 802b6fe:	b530      	push	{r4, r5, lr}
 802b700:	f44f 6480 	mov.w	r4, #1024	; 0x400
 802b704:	f104 0432 	add.w	r4, r4, #50	; 0x32
 802b708:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 802b70c:	bf48      	it	mi
 802b70e:	4240      	negmi	r0, r0
 802b710:	f04f 0100 	mov.w	r1, #0
 802b714:	e73e      	b.n	802b594 <__adddf3+0x138>
 802b716:	bf00      	nop

0802b718 <__aeabi_f2d>:
 802b718:	0042      	lsls	r2, r0, #1
 802b71a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 802b71e:	ea4f 0131 	mov.w	r1, r1, rrx
 802b722:	ea4f 7002 	mov.w	r0, r2, lsl #28
 802b726:	bf1f      	itttt	ne
 802b728:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 802b72c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 802b730:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 802b734:	4770      	bxne	lr
 802b736:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 802b73a:	bf08      	it	eq
 802b73c:	4770      	bxeq	lr
 802b73e:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 802b742:	bf04      	itt	eq
 802b744:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 802b748:	4770      	bxeq	lr
 802b74a:	b530      	push	{r4, r5, lr}
 802b74c:	f44f 7460 	mov.w	r4, #896	; 0x380
 802b750:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 802b754:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 802b758:	e71c      	b.n	802b594 <__adddf3+0x138>
 802b75a:	bf00      	nop

0802b75c <__aeabi_ul2d>:
 802b75c:	ea50 0201 	orrs.w	r2, r0, r1
 802b760:	bf08      	it	eq
 802b762:	4770      	bxeq	lr
 802b764:	b530      	push	{r4, r5, lr}
 802b766:	f04f 0500 	mov.w	r5, #0
 802b76a:	e00a      	b.n	802b782 <__aeabi_l2d+0x16>

0802b76c <__aeabi_l2d>:
 802b76c:	ea50 0201 	orrs.w	r2, r0, r1
 802b770:	bf08      	it	eq
 802b772:	4770      	bxeq	lr
 802b774:	b530      	push	{r4, r5, lr}
 802b776:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 802b77a:	d502      	bpl.n	802b782 <__aeabi_l2d+0x16>
 802b77c:	4240      	negs	r0, r0
 802b77e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 802b782:	f44f 6480 	mov.w	r4, #1024	; 0x400
 802b786:	f104 0432 	add.w	r4, r4, #50	; 0x32
 802b78a:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 802b78e:	f43f aed8 	beq.w	802b542 <__adddf3+0xe6>
 802b792:	f04f 0203 	mov.w	r2, #3
 802b796:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 802b79a:	bf18      	it	ne
 802b79c:	3203      	addne	r2, #3
 802b79e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 802b7a2:	bf18      	it	ne
 802b7a4:	3203      	addne	r2, #3
 802b7a6:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 802b7aa:	f1c2 0320 	rsb	r3, r2, #32
 802b7ae:	fa00 fc03 	lsl.w	ip, r0, r3
 802b7b2:	fa20 f002 	lsr.w	r0, r0, r2
 802b7b6:	fa01 fe03 	lsl.w	lr, r1, r3
 802b7ba:	ea40 000e 	orr.w	r0, r0, lr
 802b7be:	fa21 f102 	lsr.w	r1, r1, r2
 802b7c2:	4414      	add	r4, r2
 802b7c4:	e6bd      	b.n	802b542 <__adddf3+0xe6>
 802b7c6:	bf00      	nop

0802b7c8 <__gedf2>:
 802b7c8:	f04f 3cff 	mov.w	ip, #4294967295
 802b7cc:	e006      	b.n	802b7dc <__cmpdf2+0x4>
 802b7ce:	bf00      	nop

0802b7d0 <__ledf2>:
 802b7d0:	f04f 0c01 	mov.w	ip, #1
 802b7d4:	e002      	b.n	802b7dc <__cmpdf2+0x4>
 802b7d6:	bf00      	nop

0802b7d8 <__cmpdf2>:
 802b7d8:	f04f 0c01 	mov.w	ip, #1
 802b7dc:	f84d cd04 	str.w	ip, [sp, #-4]!
 802b7e0:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 802b7e4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 802b7e8:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 802b7ec:	bf18      	it	ne
 802b7ee:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 802b7f2:	d01b      	beq.n	802b82c <__cmpdf2+0x54>
 802b7f4:	b001      	add	sp, #4
 802b7f6:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 802b7fa:	bf0c      	ite	eq
 802b7fc:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 802b800:	ea91 0f03 	teqne	r1, r3
 802b804:	bf02      	ittt	eq
 802b806:	ea90 0f02 	teqeq	r0, r2
 802b80a:	2000      	moveq	r0, #0
 802b80c:	4770      	bxeq	lr
 802b80e:	f110 0f00 	cmn.w	r0, #0
 802b812:	ea91 0f03 	teq	r1, r3
 802b816:	bf58      	it	pl
 802b818:	4299      	cmppl	r1, r3
 802b81a:	bf08      	it	eq
 802b81c:	4290      	cmpeq	r0, r2
 802b81e:	bf2c      	ite	cs
 802b820:	17d8      	asrcs	r0, r3, #31
 802b822:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 802b826:	f040 0001 	orr.w	r0, r0, #1
 802b82a:	4770      	bx	lr
 802b82c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 802b830:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 802b834:	d102      	bne.n	802b83c <__cmpdf2+0x64>
 802b836:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 802b83a:	d107      	bne.n	802b84c <__cmpdf2+0x74>
 802b83c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 802b840:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 802b844:	d1d6      	bne.n	802b7f4 <__cmpdf2+0x1c>
 802b846:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 802b84a:	d0d3      	beq.n	802b7f4 <__cmpdf2+0x1c>
 802b84c:	f85d 0b04 	ldr.w	r0, [sp], #4
 802b850:	4770      	bx	lr
 802b852:	bf00      	nop

0802b854 <__aeabi_cdrcmple>:
 802b854:	4684      	mov	ip, r0
 802b856:	4610      	mov	r0, r2
 802b858:	4662      	mov	r2, ip
 802b85a:	468c      	mov	ip, r1
 802b85c:	4619      	mov	r1, r3
 802b85e:	4663      	mov	r3, ip
 802b860:	e000      	b.n	802b864 <__aeabi_cdcmpeq>
 802b862:	bf00      	nop

0802b864 <__aeabi_cdcmpeq>:
 802b864:	b501      	push	{r0, lr}
 802b866:	f7ff ffb7 	bl	802b7d8 <__cmpdf2>
 802b86a:	2800      	cmp	r0, #0
 802b86c:	bf48      	it	mi
 802b86e:	f110 0f00 	cmnmi.w	r0, #0
 802b872:	bd01      	pop	{r0, pc}

0802b874 <__aeabi_dcmpeq>:
 802b874:	f84d ed08 	str.w	lr, [sp, #-8]!
 802b878:	f7ff fff4 	bl	802b864 <__aeabi_cdcmpeq>
 802b87c:	bf0c      	ite	eq
 802b87e:	2001      	moveq	r0, #1
 802b880:	2000      	movne	r0, #0
 802b882:	f85d fb08 	ldr.w	pc, [sp], #8
 802b886:	bf00      	nop

0802b888 <__aeabi_dcmplt>:
 802b888:	f84d ed08 	str.w	lr, [sp, #-8]!
 802b88c:	f7ff ffea 	bl	802b864 <__aeabi_cdcmpeq>
 802b890:	bf34      	ite	cc
 802b892:	2001      	movcc	r0, #1
 802b894:	2000      	movcs	r0, #0
 802b896:	f85d fb08 	ldr.w	pc, [sp], #8
 802b89a:	bf00      	nop

0802b89c <__aeabi_dcmple>:
 802b89c:	f84d ed08 	str.w	lr, [sp, #-8]!
 802b8a0:	f7ff ffe0 	bl	802b864 <__aeabi_cdcmpeq>
 802b8a4:	bf94      	ite	ls
 802b8a6:	2001      	movls	r0, #1
 802b8a8:	2000      	movhi	r0, #0
 802b8aa:	f85d fb08 	ldr.w	pc, [sp], #8
 802b8ae:	bf00      	nop

0802b8b0 <__aeabi_dcmpge>:
 802b8b0:	f84d ed08 	str.w	lr, [sp, #-8]!
 802b8b4:	f7ff ffce 	bl	802b854 <__aeabi_cdrcmple>
 802b8b8:	bf94      	ite	ls
 802b8ba:	2001      	movls	r0, #1
 802b8bc:	2000      	movhi	r0, #0
 802b8be:	f85d fb08 	ldr.w	pc, [sp], #8
 802b8c2:	bf00      	nop

0802b8c4 <__aeabi_dcmpgt>:
 802b8c4:	f84d ed08 	str.w	lr, [sp, #-8]!
 802b8c8:	f7ff ffc4 	bl	802b854 <__aeabi_cdrcmple>
 802b8cc:	bf34      	ite	cc
 802b8ce:	2001      	movcc	r0, #1
 802b8d0:	2000      	movcs	r0, #0
 802b8d2:	f85d fb08 	ldr.w	pc, [sp], #8
 802b8d6:	bf00      	nop

0802b8d8 <__aeabi_d2iz>:
 802b8d8:	ea4f 0241 	mov.w	r2, r1, lsl #1
 802b8dc:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 802b8e0:	d215      	bcs.n	802b90e <__aeabi_d2iz+0x36>
 802b8e2:	d511      	bpl.n	802b908 <__aeabi_d2iz+0x30>
 802b8e4:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 802b8e8:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 802b8ec:	d912      	bls.n	802b914 <__aeabi_d2iz+0x3c>
 802b8ee:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 802b8f2:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 802b8f6:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 802b8fa:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 802b8fe:	fa23 f002 	lsr.w	r0, r3, r2
 802b902:	bf18      	it	ne
 802b904:	4240      	negne	r0, r0
 802b906:	4770      	bx	lr
 802b908:	f04f 0000 	mov.w	r0, #0
 802b90c:	4770      	bx	lr
 802b90e:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 802b912:	d105      	bne.n	802b920 <__aeabi_d2iz+0x48>
 802b914:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 802b918:	bf08      	it	eq
 802b91a:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 802b91e:	4770      	bx	lr
 802b920:	f04f 0000 	mov.w	r0, #0
 802b924:	4770      	bx	lr
 802b926:	bf00      	nop

0802b928 <__aeabi_frsub>:
 802b928:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
 802b92c:	e002      	b.n	802b934 <__addsf3>
 802b92e:	bf00      	nop

0802b930 <__aeabi_fsub>:
 802b930:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

0802b934 <__addsf3>:
 802b934:	0042      	lsls	r2, r0, #1
 802b936:	bf1f      	itttt	ne
 802b938:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 802b93c:	ea92 0f03 	teqne	r2, r3
 802b940:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 802b944:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 802b948:	d06a      	beq.n	802ba20 <__addsf3+0xec>
 802b94a:	ea4f 6212 	mov.w	r2, r2, lsr #24
 802b94e:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 802b952:	bfc1      	itttt	gt
 802b954:	18d2      	addgt	r2, r2, r3
 802b956:	4041      	eorgt	r1, r0
 802b958:	4048      	eorgt	r0, r1
 802b95a:	4041      	eorgt	r1, r0
 802b95c:	bfb8      	it	lt
 802b95e:	425b      	neglt	r3, r3
 802b960:	2b19      	cmp	r3, #25
 802b962:	bf88      	it	hi
 802b964:	4770      	bxhi	lr
 802b966:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 802b96a:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 802b96e:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 802b972:	bf18      	it	ne
 802b974:	4240      	negne	r0, r0
 802b976:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 802b97a:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 802b97e:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 802b982:	bf18      	it	ne
 802b984:	4249      	negne	r1, r1
 802b986:	ea92 0f03 	teq	r2, r3
 802b98a:	d03f      	beq.n	802ba0c <__addsf3+0xd8>
 802b98c:	f1a2 0201 	sub.w	r2, r2, #1
 802b990:	fa41 fc03 	asr.w	ip, r1, r3
 802b994:	eb10 000c 	adds.w	r0, r0, ip
 802b998:	f1c3 0320 	rsb	r3, r3, #32
 802b99c:	fa01 f103 	lsl.w	r1, r1, r3
 802b9a0:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 802b9a4:	d502      	bpl.n	802b9ac <__addsf3+0x78>
 802b9a6:	4249      	negs	r1, r1
 802b9a8:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 802b9ac:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 802b9b0:	d313      	bcc.n	802b9da <__addsf3+0xa6>
 802b9b2:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 802b9b6:	d306      	bcc.n	802b9c6 <__addsf3+0x92>
 802b9b8:	0840      	lsrs	r0, r0, #1
 802b9ba:	ea4f 0131 	mov.w	r1, r1, rrx
 802b9be:	f102 0201 	add.w	r2, r2, #1
 802b9c2:	2afe      	cmp	r2, #254	; 0xfe
 802b9c4:	d251      	bcs.n	802ba6a <__addsf3+0x136>
 802b9c6:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 802b9ca:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 802b9ce:	bf08      	it	eq
 802b9d0:	f020 0001 	biceq.w	r0, r0, #1
 802b9d4:	ea40 0003 	orr.w	r0, r0, r3
 802b9d8:	4770      	bx	lr
 802b9da:	0049      	lsls	r1, r1, #1
 802b9dc:	eb40 0000 	adc.w	r0, r0, r0
 802b9e0:	3a01      	subs	r2, #1
 802b9e2:	bf28      	it	cs
 802b9e4:	f5b0 0f00 	cmpcs.w	r0, #8388608	; 0x800000
 802b9e8:	d2ed      	bcs.n	802b9c6 <__addsf3+0x92>
 802b9ea:	fab0 fc80 	clz	ip, r0
 802b9ee:	f1ac 0c08 	sub.w	ip, ip, #8
 802b9f2:	ebb2 020c 	subs.w	r2, r2, ip
 802b9f6:	fa00 f00c 	lsl.w	r0, r0, ip
 802b9fa:	bfaa      	itet	ge
 802b9fc:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 802ba00:	4252      	neglt	r2, r2
 802ba02:	4318      	orrge	r0, r3
 802ba04:	bfbc      	itt	lt
 802ba06:	40d0      	lsrlt	r0, r2
 802ba08:	4318      	orrlt	r0, r3
 802ba0a:	4770      	bx	lr
 802ba0c:	f092 0f00 	teq	r2, #0
 802ba10:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
 802ba14:	bf06      	itte	eq
 802ba16:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
 802ba1a:	3201      	addeq	r2, #1
 802ba1c:	3b01      	subne	r3, #1
 802ba1e:	e7b5      	b.n	802b98c <__addsf3+0x58>
 802ba20:	ea4f 0341 	mov.w	r3, r1, lsl #1
 802ba24:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 802ba28:	bf18      	it	ne
 802ba2a:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 802ba2e:	d021      	beq.n	802ba74 <__addsf3+0x140>
 802ba30:	ea92 0f03 	teq	r2, r3
 802ba34:	d004      	beq.n	802ba40 <__addsf3+0x10c>
 802ba36:	f092 0f00 	teq	r2, #0
 802ba3a:	bf08      	it	eq
 802ba3c:	4608      	moveq	r0, r1
 802ba3e:	4770      	bx	lr
 802ba40:	ea90 0f01 	teq	r0, r1
 802ba44:	bf1c      	itt	ne
 802ba46:	2000      	movne	r0, #0
 802ba48:	4770      	bxne	lr
 802ba4a:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
 802ba4e:	d104      	bne.n	802ba5a <__addsf3+0x126>
 802ba50:	0040      	lsls	r0, r0, #1
 802ba52:	bf28      	it	cs
 802ba54:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
 802ba58:	4770      	bx	lr
 802ba5a:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 802ba5e:	bf3c      	itt	cc
 802ba60:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
 802ba64:	4770      	bxcc	lr
 802ba66:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 802ba6a:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
 802ba6e:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 802ba72:	4770      	bx	lr
 802ba74:	ea7f 6222 	mvns.w	r2, r2, asr #24
 802ba78:	bf16      	itet	ne
 802ba7a:	4608      	movne	r0, r1
 802ba7c:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 802ba80:	4601      	movne	r1, r0
 802ba82:	0242      	lsls	r2, r0, #9
 802ba84:	bf06      	itte	eq
 802ba86:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 802ba8a:	ea90 0f01 	teqeq	r0, r1
 802ba8e:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
 802ba92:	4770      	bx	lr

0802ba94 <__aeabi_ui2f>:
 802ba94:	f04f 0300 	mov.w	r3, #0
 802ba98:	e004      	b.n	802baa4 <__aeabi_i2f+0x8>
 802ba9a:	bf00      	nop

0802ba9c <__aeabi_i2f>:
 802ba9c:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
 802baa0:	bf48      	it	mi
 802baa2:	4240      	negmi	r0, r0
 802baa4:	ea5f 0c00 	movs.w	ip, r0
 802baa8:	bf08      	it	eq
 802baaa:	4770      	bxeq	lr
 802baac:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
 802bab0:	4601      	mov	r1, r0
 802bab2:	f04f 0000 	mov.w	r0, #0
 802bab6:	e01c      	b.n	802baf2 <__aeabi_l2f+0x2a>

0802bab8 <__aeabi_ul2f>:
 802bab8:	ea50 0201 	orrs.w	r2, r0, r1
 802babc:	bf08      	it	eq
 802babe:	4770      	bxeq	lr
 802bac0:	f04f 0300 	mov.w	r3, #0
 802bac4:	e00a      	b.n	802badc <__aeabi_l2f+0x14>
 802bac6:	bf00      	nop

0802bac8 <__aeabi_l2f>:
 802bac8:	ea50 0201 	orrs.w	r2, r0, r1
 802bacc:	bf08      	it	eq
 802bace:	4770      	bxeq	lr
 802bad0:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
 802bad4:	d502      	bpl.n	802badc <__aeabi_l2f+0x14>
 802bad6:	4240      	negs	r0, r0
 802bad8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 802badc:	ea5f 0c01 	movs.w	ip, r1
 802bae0:	bf02      	ittt	eq
 802bae2:	4684      	moveq	ip, r0
 802bae4:	4601      	moveq	r1, r0
 802bae6:	2000      	moveq	r0, #0
 802bae8:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
 802baec:	bf08      	it	eq
 802baee:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
 802baf2:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 802baf6:	fabc f28c 	clz	r2, ip
 802bafa:	3a08      	subs	r2, #8
 802bafc:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 802bb00:	db10      	blt.n	802bb24 <__aeabi_l2f+0x5c>
 802bb02:	fa01 fc02 	lsl.w	ip, r1, r2
 802bb06:	4463      	add	r3, ip
 802bb08:	fa00 fc02 	lsl.w	ip, r0, r2
 802bb0c:	f1c2 0220 	rsb	r2, r2, #32
 802bb10:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 802bb14:	fa20 f202 	lsr.w	r2, r0, r2
 802bb18:	eb43 0002 	adc.w	r0, r3, r2
 802bb1c:	bf08      	it	eq
 802bb1e:	f020 0001 	biceq.w	r0, r0, #1
 802bb22:	4770      	bx	lr
 802bb24:	f102 0220 	add.w	r2, r2, #32
 802bb28:	fa01 fc02 	lsl.w	ip, r1, r2
 802bb2c:	f1c2 0220 	rsb	r2, r2, #32
 802bb30:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 802bb34:	fa21 f202 	lsr.w	r2, r1, r2
 802bb38:	eb43 0002 	adc.w	r0, r3, r2
 802bb3c:	bf08      	it	eq
 802bb3e:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 802bb42:	4770      	bx	lr

0802bb44 <__aeabi_uldivmod>:
 802bb44:	b953      	cbnz	r3, 802bb5c <__aeabi_uldivmod+0x18>
 802bb46:	b94a      	cbnz	r2, 802bb5c <__aeabi_uldivmod+0x18>
 802bb48:	2900      	cmp	r1, #0
 802bb4a:	bf08      	it	eq
 802bb4c:	2800      	cmpeq	r0, #0
 802bb4e:	bf1c      	itt	ne
 802bb50:	f04f 31ff 	movne.w	r1, #4294967295
 802bb54:	f04f 30ff 	movne.w	r0, #4294967295
 802bb58:	f000 b96c 	b.w	802be34 <__aeabi_idiv0>
 802bb5c:	f1ad 0c08 	sub.w	ip, sp, #8
 802bb60:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 802bb64:	f000 f806 	bl	802bb74 <__udivmoddi4>
 802bb68:	f8dd e004 	ldr.w	lr, [sp, #4]
 802bb6c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 802bb70:	b004      	add	sp, #16
 802bb72:	4770      	bx	lr

0802bb74 <__udivmoddi4>:
 802bb74:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 802bb78:	9e08      	ldr	r6, [sp, #32]
 802bb7a:	460d      	mov	r5, r1
 802bb7c:	4604      	mov	r4, r0
 802bb7e:	468e      	mov	lr, r1
 802bb80:	2b00      	cmp	r3, #0
 802bb82:	f040 8082 	bne.w	802bc8a <__udivmoddi4+0x116>
 802bb86:	428a      	cmp	r2, r1
 802bb88:	4617      	mov	r7, r2
 802bb8a:	d946      	bls.n	802bc1a <__udivmoddi4+0xa6>
 802bb8c:	fab2 f282 	clz	r2, r2
 802bb90:	b14a      	cbz	r2, 802bba6 <__udivmoddi4+0x32>
 802bb92:	f1c2 0120 	rsb	r1, r2, #32
 802bb96:	fa05 f302 	lsl.w	r3, r5, r2
 802bb9a:	fa20 f101 	lsr.w	r1, r0, r1
 802bb9e:	4097      	lsls	r7, r2
 802bba0:	ea41 0e03 	orr.w	lr, r1, r3
 802bba4:	4094      	lsls	r4, r2
 802bba6:	ea4f 4817 	mov.w	r8, r7, lsr #16
 802bbaa:	0c23      	lsrs	r3, r4, #16
 802bbac:	fbbe fcf8 	udiv	ip, lr, r8
 802bbb0:	b2b9      	uxth	r1, r7
 802bbb2:	fb08 ee1c 	mls	lr, r8, ip, lr
 802bbb6:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
 802bbba:	fb0c f001 	mul.w	r0, ip, r1
 802bbbe:	4298      	cmp	r0, r3
 802bbc0:	d90a      	bls.n	802bbd8 <__udivmoddi4+0x64>
 802bbc2:	18fb      	adds	r3, r7, r3
 802bbc4:	f10c 35ff 	add.w	r5, ip, #4294967295
 802bbc8:	f080 8116 	bcs.w	802bdf8 <__udivmoddi4+0x284>
 802bbcc:	4298      	cmp	r0, r3
 802bbce:	f240 8113 	bls.w	802bdf8 <__udivmoddi4+0x284>
 802bbd2:	f1ac 0c02 	sub.w	ip, ip, #2
 802bbd6:	443b      	add	r3, r7
 802bbd8:	1a1b      	subs	r3, r3, r0
 802bbda:	b2a4      	uxth	r4, r4
 802bbdc:	fbb3 f0f8 	udiv	r0, r3, r8
 802bbe0:	fb08 3310 	mls	r3, r8, r0, r3
 802bbe4:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 802bbe8:	fb00 f101 	mul.w	r1, r0, r1
 802bbec:	42a1      	cmp	r1, r4
 802bbee:	d909      	bls.n	802bc04 <__udivmoddi4+0x90>
 802bbf0:	193c      	adds	r4, r7, r4
 802bbf2:	f100 33ff 	add.w	r3, r0, #4294967295
 802bbf6:	f080 8101 	bcs.w	802bdfc <__udivmoddi4+0x288>
 802bbfa:	42a1      	cmp	r1, r4
 802bbfc:	f240 80fe 	bls.w	802bdfc <__udivmoddi4+0x288>
 802bc00:	3802      	subs	r0, #2
 802bc02:	443c      	add	r4, r7
 802bc04:	1a64      	subs	r4, r4, r1
 802bc06:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 802bc0a:	2100      	movs	r1, #0
 802bc0c:	b11e      	cbz	r6, 802bc16 <__udivmoddi4+0xa2>
 802bc0e:	40d4      	lsrs	r4, r2
 802bc10:	2300      	movs	r3, #0
 802bc12:	e9c6 4300 	strd	r4, r3, [r6]
 802bc16:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802bc1a:	b902      	cbnz	r2, 802bc1e <__udivmoddi4+0xaa>
 802bc1c:	deff      	udf	#255	; 0xff
 802bc1e:	fab2 f282 	clz	r2, r2
 802bc22:	2a00      	cmp	r2, #0
 802bc24:	d14f      	bne.n	802bcc6 <__udivmoddi4+0x152>
 802bc26:	1bcb      	subs	r3, r1, r7
 802bc28:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 802bc2c:	fa1f f887 	uxth.w	r8, r7
 802bc30:	2101      	movs	r1, #1
 802bc32:	fbb3 fcfe 	udiv	ip, r3, lr
 802bc36:	0c25      	lsrs	r5, r4, #16
 802bc38:	fb0e 331c 	mls	r3, lr, ip, r3
 802bc3c:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 802bc40:	fb08 f30c 	mul.w	r3, r8, ip
 802bc44:	42ab      	cmp	r3, r5
 802bc46:	d907      	bls.n	802bc58 <__udivmoddi4+0xe4>
 802bc48:	197d      	adds	r5, r7, r5
 802bc4a:	f10c 30ff 	add.w	r0, ip, #4294967295
 802bc4e:	d202      	bcs.n	802bc56 <__udivmoddi4+0xe2>
 802bc50:	42ab      	cmp	r3, r5
 802bc52:	f200 80e7 	bhi.w	802be24 <__udivmoddi4+0x2b0>
 802bc56:	4684      	mov	ip, r0
 802bc58:	1aed      	subs	r5, r5, r3
 802bc5a:	b2a3      	uxth	r3, r4
 802bc5c:	fbb5 f0fe 	udiv	r0, r5, lr
 802bc60:	fb0e 5510 	mls	r5, lr, r0, r5
 802bc64:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
 802bc68:	fb08 f800 	mul.w	r8, r8, r0
 802bc6c:	45a0      	cmp	r8, r4
 802bc6e:	d907      	bls.n	802bc80 <__udivmoddi4+0x10c>
 802bc70:	193c      	adds	r4, r7, r4
 802bc72:	f100 33ff 	add.w	r3, r0, #4294967295
 802bc76:	d202      	bcs.n	802bc7e <__udivmoddi4+0x10a>
 802bc78:	45a0      	cmp	r8, r4
 802bc7a:	f200 80d7 	bhi.w	802be2c <__udivmoddi4+0x2b8>
 802bc7e:	4618      	mov	r0, r3
 802bc80:	eba4 0408 	sub.w	r4, r4, r8
 802bc84:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 802bc88:	e7c0      	b.n	802bc0c <__udivmoddi4+0x98>
 802bc8a:	428b      	cmp	r3, r1
 802bc8c:	d908      	bls.n	802bca0 <__udivmoddi4+0x12c>
 802bc8e:	2e00      	cmp	r6, #0
 802bc90:	f000 80af 	beq.w	802bdf2 <__udivmoddi4+0x27e>
 802bc94:	2100      	movs	r1, #0
 802bc96:	e9c6 0500 	strd	r0, r5, [r6]
 802bc9a:	4608      	mov	r0, r1
 802bc9c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802bca0:	fab3 f183 	clz	r1, r3
 802bca4:	2900      	cmp	r1, #0
 802bca6:	d14b      	bne.n	802bd40 <__udivmoddi4+0x1cc>
 802bca8:	42ab      	cmp	r3, r5
 802bcaa:	d302      	bcc.n	802bcb2 <__udivmoddi4+0x13e>
 802bcac:	4282      	cmp	r2, r0
 802bcae:	f200 80b7 	bhi.w	802be20 <__udivmoddi4+0x2ac>
 802bcb2:	1a84      	subs	r4, r0, r2
 802bcb4:	eb65 0303 	sbc.w	r3, r5, r3
 802bcb8:	2001      	movs	r0, #1
 802bcba:	469e      	mov	lr, r3
 802bcbc:	2e00      	cmp	r6, #0
 802bcbe:	d0aa      	beq.n	802bc16 <__udivmoddi4+0xa2>
 802bcc0:	e9c6 4e00 	strd	r4, lr, [r6]
 802bcc4:	e7a7      	b.n	802bc16 <__udivmoddi4+0xa2>
 802bcc6:	f1c2 0c20 	rsb	ip, r2, #32
 802bcca:	fa01 f302 	lsl.w	r3, r1, r2
 802bcce:	4097      	lsls	r7, r2
 802bcd0:	fa20 f00c 	lsr.w	r0, r0, ip
 802bcd4:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 802bcd8:	fa21 fc0c 	lsr.w	ip, r1, ip
 802bcdc:	4318      	orrs	r0, r3
 802bcde:	fbbc f1fe 	udiv	r1, ip, lr
 802bce2:	0c05      	lsrs	r5, r0, #16
 802bce4:	fb0e cc11 	mls	ip, lr, r1, ip
 802bce8:	fa1f f887 	uxth.w	r8, r7
 802bcec:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
 802bcf0:	fb01 f308 	mul.w	r3, r1, r8
 802bcf4:	42ab      	cmp	r3, r5
 802bcf6:	fa04 f402 	lsl.w	r4, r4, r2
 802bcfa:	d909      	bls.n	802bd10 <__udivmoddi4+0x19c>
 802bcfc:	197d      	adds	r5, r7, r5
 802bcfe:	f101 3cff 	add.w	ip, r1, #4294967295
 802bd02:	f080 808b 	bcs.w	802be1c <__udivmoddi4+0x2a8>
 802bd06:	42ab      	cmp	r3, r5
 802bd08:	f240 8088 	bls.w	802be1c <__udivmoddi4+0x2a8>
 802bd0c:	3902      	subs	r1, #2
 802bd0e:	443d      	add	r5, r7
 802bd10:	1aeb      	subs	r3, r5, r3
 802bd12:	b285      	uxth	r5, r0
 802bd14:	fbb3 f0fe 	udiv	r0, r3, lr
 802bd18:	fb0e 3310 	mls	r3, lr, r0, r3
 802bd1c:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 802bd20:	fb00 f308 	mul.w	r3, r0, r8
 802bd24:	42ab      	cmp	r3, r5
 802bd26:	d907      	bls.n	802bd38 <__udivmoddi4+0x1c4>
 802bd28:	197d      	adds	r5, r7, r5
 802bd2a:	f100 3cff 	add.w	ip, r0, #4294967295
 802bd2e:	d271      	bcs.n	802be14 <__udivmoddi4+0x2a0>
 802bd30:	42ab      	cmp	r3, r5
 802bd32:	d96f      	bls.n	802be14 <__udivmoddi4+0x2a0>
 802bd34:	3802      	subs	r0, #2
 802bd36:	443d      	add	r5, r7
 802bd38:	1aeb      	subs	r3, r5, r3
 802bd3a:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 802bd3e:	e778      	b.n	802bc32 <__udivmoddi4+0xbe>
 802bd40:	f1c1 0c20 	rsb	ip, r1, #32
 802bd44:	408b      	lsls	r3, r1
 802bd46:	fa22 f70c 	lsr.w	r7, r2, ip
 802bd4a:	431f      	orrs	r7, r3
 802bd4c:	fa20 f40c 	lsr.w	r4, r0, ip
 802bd50:	fa05 f301 	lsl.w	r3, r5, r1
 802bd54:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 802bd58:	fa25 f50c 	lsr.w	r5, r5, ip
 802bd5c:	431c      	orrs	r4, r3
 802bd5e:	0c23      	lsrs	r3, r4, #16
 802bd60:	fbb5 f9fe 	udiv	r9, r5, lr
 802bd64:	fa1f f887 	uxth.w	r8, r7
 802bd68:	fb0e 5519 	mls	r5, lr, r9, r5
 802bd6c:	ea43 4505 	orr.w	r5, r3, r5, lsl #16
 802bd70:	fb09 fa08 	mul.w	sl, r9, r8
 802bd74:	45aa      	cmp	sl, r5
 802bd76:	fa02 f201 	lsl.w	r2, r2, r1
 802bd7a:	fa00 f301 	lsl.w	r3, r0, r1
 802bd7e:	d908      	bls.n	802bd92 <__udivmoddi4+0x21e>
 802bd80:	197d      	adds	r5, r7, r5
 802bd82:	f109 30ff 	add.w	r0, r9, #4294967295
 802bd86:	d247      	bcs.n	802be18 <__udivmoddi4+0x2a4>
 802bd88:	45aa      	cmp	sl, r5
 802bd8a:	d945      	bls.n	802be18 <__udivmoddi4+0x2a4>
 802bd8c:	f1a9 0902 	sub.w	r9, r9, #2
 802bd90:	443d      	add	r5, r7
 802bd92:	eba5 050a 	sub.w	r5, r5, sl
 802bd96:	b2a4      	uxth	r4, r4
 802bd98:	fbb5 f0fe 	udiv	r0, r5, lr
 802bd9c:	fb0e 5510 	mls	r5, lr, r0, r5
 802bda0:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 802bda4:	fb00 f808 	mul.w	r8, r0, r8
 802bda8:	45a0      	cmp	r8, r4
 802bdaa:	d907      	bls.n	802bdbc <__udivmoddi4+0x248>
 802bdac:	193c      	adds	r4, r7, r4
 802bdae:	f100 35ff 	add.w	r5, r0, #4294967295
 802bdb2:	d22d      	bcs.n	802be10 <__udivmoddi4+0x29c>
 802bdb4:	45a0      	cmp	r8, r4
 802bdb6:	d92b      	bls.n	802be10 <__udivmoddi4+0x29c>
 802bdb8:	3802      	subs	r0, #2
 802bdba:	443c      	add	r4, r7
 802bdbc:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 802bdc0:	eba4 0408 	sub.w	r4, r4, r8
 802bdc4:	fba0 8902 	umull	r8, r9, r0, r2
 802bdc8:	454c      	cmp	r4, r9
 802bdca:	46c6      	mov	lr, r8
 802bdcc:	464d      	mov	r5, r9
 802bdce:	d319      	bcc.n	802be04 <__udivmoddi4+0x290>
 802bdd0:	d016      	beq.n	802be00 <__udivmoddi4+0x28c>
 802bdd2:	b15e      	cbz	r6, 802bdec <__udivmoddi4+0x278>
 802bdd4:	ebb3 020e 	subs.w	r2, r3, lr
 802bdd8:	eb64 0405 	sbc.w	r4, r4, r5
 802bddc:	fa04 fc0c 	lsl.w	ip, r4, ip
 802bde0:	40ca      	lsrs	r2, r1
 802bde2:	ea4c 0202 	orr.w	r2, ip, r2
 802bde6:	40cc      	lsrs	r4, r1
 802bde8:	e9c6 2400 	strd	r2, r4, [r6]
 802bdec:	2100      	movs	r1, #0
 802bdee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802bdf2:	4631      	mov	r1, r6
 802bdf4:	4630      	mov	r0, r6
 802bdf6:	e70e      	b.n	802bc16 <__udivmoddi4+0xa2>
 802bdf8:	46ac      	mov	ip, r5
 802bdfa:	e6ed      	b.n	802bbd8 <__udivmoddi4+0x64>
 802bdfc:	4618      	mov	r0, r3
 802bdfe:	e701      	b.n	802bc04 <__udivmoddi4+0x90>
 802be00:	4543      	cmp	r3, r8
 802be02:	d2e6      	bcs.n	802bdd2 <__udivmoddi4+0x25e>
 802be04:	ebb8 0e02 	subs.w	lr, r8, r2
 802be08:	eb69 0507 	sbc.w	r5, r9, r7
 802be0c:	3801      	subs	r0, #1
 802be0e:	e7e0      	b.n	802bdd2 <__udivmoddi4+0x25e>
 802be10:	4628      	mov	r0, r5
 802be12:	e7d3      	b.n	802bdbc <__udivmoddi4+0x248>
 802be14:	4660      	mov	r0, ip
 802be16:	e78f      	b.n	802bd38 <__udivmoddi4+0x1c4>
 802be18:	4681      	mov	r9, r0
 802be1a:	e7ba      	b.n	802bd92 <__udivmoddi4+0x21e>
 802be1c:	4661      	mov	r1, ip
 802be1e:	e777      	b.n	802bd10 <__udivmoddi4+0x19c>
 802be20:	4608      	mov	r0, r1
 802be22:	e74b      	b.n	802bcbc <__udivmoddi4+0x148>
 802be24:	f1ac 0c02 	sub.w	ip, ip, #2
 802be28:	443d      	add	r5, r7
 802be2a:	e715      	b.n	802bc58 <__udivmoddi4+0xe4>
 802be2c:	3802      	subs	r0, #2
 802be2e:	443c      	add	r4, r7
 802be30:	e726      	b.n	802bc80 <__udivmoddi4+0x10c>
 802be32:	bf00      	nop

0802be34 <__aeabi_idiv0>:
 802be34:	4770      	bx	lr
 802be36:	bf00      	nop

0802be38 <MX_ADC_Init>:
  /* USER CODE BEGIN ADC_Init 1 */

  /* USER CODE END ADC_Init 1 */
  /** Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion)
  */
  hadc.Instance = ADC;
 802be38:	4813      	ldr	r0, [pc, #76]	; (802be88 <MX_ADC_Init+0x50>)
  hadc.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
 802be3a:	4a14      	ldr	r2, [pc, #80]	; (802be8c <MX_ADC_Init+0x54>)
{
 802be3c:	b508      	push	{r3, lr}
  hadc.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
 802be3e:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 802be42:	e9c0 2300 	strd	r2, r3, [r0]
  hadc.Init.Resolution = ADC_RESOLUTION_12B;
  hadc.Init.DataAlign = ADC_DATAALIGN_RIGHT;
  hadc.Init.ScanConvMode = ADC_SCAN_DISABLE;
  hadc.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 802be46:	2204      	movs	r2, #4
  hadc.Init.Resolution = ADC_RESOLUTION_12B;
 802be48:	2300      	movs	r3, #0
  hadc.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 802be4a:	6142      	str	r2, [r0, #20]
  hadc.Init.LowPowerAutoWait = DISABLE;
  hadc.Init.LowPowerAutoPowerOff = DISABLE;
  hadc.Init.ContinuousConvMode = DISABLE;
  hadc.Init.NbrOfConversion = 1;
 802be4c:	2201      	movs	r2, #1
 802be4e:	61c2      	str	r2, [r0, #28]
  hadc.Init.DiscontinuousConvMode = DISABLE;
  hadc.Init.ExternalTrigConv = ADC_SOFTWARE_START;
  hadc.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
  hadc.Init.DMAContinuousRequests = DISABLE;
  hadc.Init.Overrun = ADC_OVR_DATA_OVERWRITTEN;
  hadc.Init.SamplingTimeCommon1 = ADC_SAMPLETIME_160CYCLES_5;
 802be50:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 802be54:	2207      	movs	r2, #7
  hadc.Init.LowPowerAutoWait = DISABLE;
 802be56:	8303      	strh	r3, [r0, #24]
  hadc.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 802be58:	e9c0 3302 	strd	r3, r3, [r0, #8]
  hadc.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 802be5c:	e9c0 3309 	strd	r3, r3, [r0, #36]	; 0x24
  hadc.Init.SamplingTimeCommon1 = ADC_SAMPLETIME_160CYCLES_5;
 802be60:	e9c0 120c 	strd	r1, r2, [r0, #48]	; 0x30
  hadc.Init.ScanConvMode = ADC_SCAN_DISABLE;
 802be64:	6103      	str	r3, [r0, #16]
  hadc.Init.ContinuousConvMode = DISABLE;
 802be66:	7683      	strb	r3, [r0, #26]
  hadc.Init.DiscontinuousConvMode = DISABLE;
 802be68:	f880 3020 	strb.w	r3, [r0, #32]
  hadc.Init.DMAContinuousRequests = DISABLE;
 802be6c:	f880 302c 	strb.w	r3, [r0, #44]	; 0x2c
  hadc.Init.SamplingTimeCommon2 = ADC_SAMPLETIME_160CYCLES_5;
 802be70:	6382      	str	r2, [r0, #56]	; 0x38
  hadc.Init.OversamplingMode = DISABLE;
 802be72:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  hadc.Init.TriggerFrequencyMode = ADC_TRIGGER_FREQ_HIGH;
 802be76:	64c3      	str	r3, [r0, #76]	; 0x4c
  if (HAL_ADC_Init(&hadc) != HAL_OK)
 802be78:	f001 fb6e 	bl	802d558 <HAL_ADC_Init>
 802be7c:	b118      	cbz	r0, 802be86 <MX_ADC_Init+0x4e>
  }
  /* USER CODE BEGIN ADC_Init 2 */

  /* USER CODE END ADC_Init 2 */

}
 802be7e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 802be82:	f000 ba17 	b.w	802c2b4 <Error_Handler>
}
 802be86:	bd08      	pop	{r3, pc}
 802be88:	20006154 	.word	0x20006154
 802be8c:	40012400 	.word	0x40012400

0802be90 <HAL_ADC_MspInit>:

void HAL_ADC_MspInit(ADC_HandleTypeDef* adcHandle)
{

  if(adcHandle->Instance==ADC)
 802be90:	6802      	ldr	r2, [r0, #0]
 802be92:	4b08      	ldr	r3, [pc, #32]	; (802beb4 <HAL_ADC_MspInit+0x24>)
 802be94:	429a      	cmp	r2, r3
{
 802be96:	b082      	sub	sp, #8
  if(adcHandle->Instance==ADC)
 802be98:	d10a      	bne.n	802beb0 <HAL_ADC_MspInit+0x20>
  * @retval None
  */
__STATIC_INLINE void LL_APB2_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB2ENR, Periphs);
 802be9a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802be9e:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 802bea0:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 802bea4:	661a      	str	r2, [r3, #96]	; 0x60
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
 802bea6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 802bea8:	f403 7300 	and.w	r3, r3, #512	; 0x200
 802beac:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 802beae:	9b01      	ldr	r3, [sp, #4]
    __HAL_RCC_ADC_CLK_ENABLE();
  /* USER CODE BEGIN ADC_MspInit 1 */

  /* USER CODE END ADC_MspInit 1 */
  }
}
 802beb0:	b002      	add	sp, #8
 802beb2:	4770      	bx	lr
 802beb4:	40012400 	.word	0x40012400

0802beb8 <HAL_ADC_MspDeInit>:

void HAL_ADC_MspDeInit(ADC_HandleTypeDef* adcHandle)
{

  if(adcHandle->Instance==ADC)
 802beb8:	6802      	ldr	r2, [r0, #0]
 802beba:	4b05      	ldr	r3, [pc, #20]	; (802bed0 <HAL_ADC_MspDeInit+0x18>)
 802bebc:	429a      	cmp	r2, r3
  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM17
  * @retval None
  */
__STATIC_INLINE void LL_APB2_GRP1_DisableClock(uint32_t Periphs)
{
  CLEAR_BIT(RCC->APB2ENR, Periphs);
 802bebe:	bf01      	itttt	eq
 802bec0:	f04f 42b0 	moveq.w	r2, #1476395008	; 0x58000000
 802bec4:	6e13      	ldreq	r3, [r2, #96]	; 0x60
 802bec6:	f423 7300 	biceq.w	r3, r3, #512	; 0x200
 802beca:	6613      	streq	r3, [r2, #96]	; 0x60
    __HAL_RCC_ADC_CLK_DISABLE();
  /* USER CODE BEGIN ADC_MspDeInit 1 */

  /* USER CODE END ADC_MspDeInit 1 */
  }
}
 802becc:	4770      	bx	lr
 802bece:	bf00      	nop
 802bed0:	40012400 	.word	0x40012400

0802bed4 <ADC_ReadChannels>:
/* USER CODE BEGIN PrFD */

/* USER CODE END PrFD */

static uint32_t ADC_ReadChannels(uint32_t channel)
{
 802bed4:	b530      	push	{r4, r5, lr}
 802bed6:	b085      	sub	sp, #20
  /* USER CODE BEGIN ADC_ReadChannels_1 */

  /* USER CODE END ADC_ReadChannels_1 */
  uint32_t ADCxConvertedValues = 0;
  ADC_ChannelConfTypeDef sConfig = {0};
 802bed8:	2400      	movs	r4, #0
{
 802beda:	4605      	mov	r5, r0
  ADC_ChannelConfTypeDef sConfig = {0};
 802bedc:	e9cd 4401 	strd	r4, r4, [sp, #4]
 802bee0:	9403      	str	r4, [sp, #12]

  MX_ADC_Init();
 802bee2:	f7ff ffa9 	bl	802be38 <MX_ADC_Init>

  /* Start Calibration */
  if (HAL_ADCEx_Calibration_Start(&hadc) != HAL_OK)
 802bee6:	4814      	ldr	r0, [pc, #80]	; (802bf38 <ADC_ReadChannels+0x64>)
 802bee8:	f001 fede 	bl	802dca8 <HAL_ADCEx_Calibration_Start>
 802beec:	b108      	cbz	r0, 802bef2 <ADC_ReadChannels+0x1e>
  {
    Error_Handler();
 802beee:	f000 f9e1 	bl	802c2b4 <Error_Handler>

  /* Configure Regular Channel */
  sConfig.Channel = channel;
  sConfig.Rank = ADC_REGULAR_RANK_1;
  sConfig.SamplingTime = ADC_SAMPLINGTIME_COMMON_1;
  if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 802bef2:	4811      	ldr	r0, [pc, #68]	; (802bf38 <ADC_ReadChannels+0x64>)
  sConfig.SamplingTime = ADC_SAMPLINGTIME_COMMON_1;
 802bef4:	9403      	str	r4, [sp, #12]
  if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 802bef6:	a901      	add	r1, sp, #4
  sConfig.Rank = ADC_REGULAR_RANK_1;
 802bef8:	e9cd 5401 	strd	r5, r4, [sp, #4]
  if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 802befc:	f001 fcae 	bl	802d85c <HAL_ADC_ConfigChannel>
 802bf00:	b108      	cbz	r0, 802bf06 <ADC_ReadChannels+0x32>
  {
    Error_Handler();
 802bf02:	f000 f9d7 	bl	802c2b4 <Error_Handler>
  }

  if (HAL_ADC_Start(&hadc) != HAL_OK)
 802bf06:	480c      	ldr	r0, [pc, #48]	; (802bf38 <ADC_ReadChannels+0x64>)
 802bf08:	f001 fe02 	bl	802db10 <HAL_ADC_Start>
 802bf0c:	b108      	cbz	r0, 802bf12 <ADC_ReadChannels+0x3e>
  {
    /* Start Error */
    Error_Handler();
 802bf0e:	f000 f9d1 	bl	802c2b4 <Error_Handler>
  }
  /** Wait for end of conversion */
  HAL_ADC_PollForConversion(&hadc, HAL_MAX_DELAY);
 802bf12:	f04f 31ff 	mov.w	r1, #4294967295
 802bf16:	4808      	ldr	r0, [pc, #32]	; (802bf38 <ADC_ReadChannels+0x64>)
 802bf18:	f001 fc42 	bl	802d7a0 <HAL_ADC_PollForConversion>

  /** Wait for end of conversion */
  HAL_ADC_Stop(&hadc) ;   /* it calls also ADC_Disable() */
 802bf1c:	4806      	ldr	r0, [pc, #24]	; (802bf38 <ADC_ReadChannels+0x64>)
 802bf1e:	f001 fea5 	bl	802dc6c <HAL_ADC_Stop>

  ADCxConvertedValues = HAL_ADC_GetValue(&hadc);
 802bf22:	4805      	ldr	r0, [pc, #20]	; (802bf38 <ADC_ReadChannels+0x64>)
 802bf24:	f001 fc97 	bl	802d856 <HAL_ADC_GetValue>
 802bf28:	4604      	mov	r4, r0

  HAL_ADC_DeInit(&hadc);
 802bf2a:	4803      	ldr	r0, [pc, #12]	; (802bf38 <ADC_ReadChannels+0x64>)
 802bf2c:	f001 fe52 	bl	802dbd4 <HAL_ADC_DeInit>

  return ADCxConvertedValues;
  /* USER CODE BEGIN ADC_ReadChannels_2 */

  /* USER CODE END ADC_ReadChannels_2 */
}
 802bf30:	4620      	mov	r0, r4
 802bf32:	b005      	add	sp, #20
 802bf34:	bd30      	pop	{r4, r5, pc}
 802bf36:	bf00      	nop
 802bf38:	20006154 	.word	0x20006154

0802bf3c <SYS_InitMeasurement>:
  hadc.Instance = ADC;
 802bf3c:	4b01      	ldr	r3, [pc, #4]	; (802bf44 <SYS_InitMeasurement+0x8>)
 802bf3e:	4a02      	ldr	r2, [pc, #8]	; (802bf48 <SYS_InitMeasurement+0xc>)
 802bf40:	601a      	str	r2, [r3, #0]
}
 802bf42:	4770      	bx	lr
 802bf44:	20006154 	.word	0x20006154
 802bf48:	40012400 	.word	0x40012400

0802bf4c <SYS_GetBatteryLevel>:
{
 802bf4c:	b508      	push	{r3, lr}
  measuredLevel = ADC_ReadChannels(ADC_CHANNEL_VREFINT);
 802bf4e:	4809      	ldr	r0, [pc, #36]	; (802bf74 <SYS_GetBatteryLevel+0x28>)
 802bf50:	f7ff ffc0 	bl	802bed4 <ADC_ReadChannels>
  if (measuredLevel == 0)
 802bf54:	b160      	cbz	r0, 802bf70 <SYS_GetBatteryLevel+0x24>
    if ((uint32_t)*VREFINT_CAL_ADDR != (uint32_t)0xFFFFU)
 802bf56:	4b08      	ldr	r3, [pc, #32]	; (802bf78 <SYS_GetBatteryLevel+0x2c>)
 802bf58:	881a      	ldrh	r2, [r3, #0]
 802bf5a:	f64f 73ff 	movw	r3, #65535	; 0xffff
 802bf5e:	429a      	cmp	r2, r3
      batteryLevelmV = __LL_ADC_CALC_VREFANALOG_VOLTAGE(measuredLevel,
 802bf60:	bf16      	itet	ne
 802bf62:	f640 43e4 	movwne	r3, #3300	; 0xce4
      batteryLevelmV = (VREFINT_CAL_VREF * 1510) / measuredLevel;
 802bf66:	4b05      	ldreq	r3, [pc, #20]	; (802bf7c <SYS_GetBatteryLevel+0x30>)
      batteryLevelmV = __LL_ADC_CALC_VREFANALOG_VOLTAGE(measuredLevel,
 802bf68:	4353      	mulne	r3, r2
      batteryLevelmV = (VREFINT_CAL_VREF * 1510) / measuredLevel;
 802bf6a:	fbb3 f0f0 	udiv	r0, r3, r0
 802bf6e:	b280      	uxth	r0, r0
}
 802bf70:	bd08      	pop	{r3, pc}
 802bf72:	bf00      	nop
 802bf74:	b4002000 	.word	0xb4002000
 802bf78:	1fff75aa 	.word	0x1fff75aa
 802bf7c:	004c08d8 	.word	0x004c08d8

0802bf80 <SYS_GetTemperatureLevel>:
{
 802bf80:	b513      	push	{r0, r1, r4, lr}
  uint16_t batteryLevelmV = SYS_GetBatteryLevel();
 802bf82:	f7ff ffe3 	bl	802bf4c <SYS_GetBatteryLevel>
 802bf86:	4604      	mov	r4, r0
  measuredLevel = ADC_ReadChannels(ADC_CHANNEL_TEMPSENSOR);
 802bf88:	4818      	ldr	r0, [pc, #96]	; (802bfec <SYS_GetTemperatureLevel+0x6c>)
 802bf8a:	f7ff ffa3 	bl	802bed4 <ADC_ReadChannels>
  if (((int32_t)*TEMPSENSOR_CAL2_ADDR - (int32_t)*TEMPSENSOR_CAL1_ADDR) != 0)
 802bf8e:	4b18      	ldr	r3, [pc, #96]	; (802bff0 <SYS_GetTemperatureLevel+0x70>)
 802bf90:	4a18      	ldr	r2, [pc, #96]	; (802bff4 <SYS_GetTemperatureLevel+0x74>)
 802bf92:	881b      	ldrh	r3, [r3, #0]
 802bf94:	8812      	ldrh	r2, [r2, #0]
 802bf96:	4293      	cmp	r3, r2
 802bf98:	fb00 f004 	mul.w	r0, r0, r4
 802bf9c:	d016      	beq.n	802bfcc <SYS_GetTemperatureLevel+0x4c>
    temperatureDegreeC = __LL_ADC_CALC_TEMPERATURE(batteryLevelmV,
 802bf9e:	f640 44e4 	movw	r4, #3300	; 0xce4
 802bfa2:	fbb0 f0f4 	udiv	r0, r0, r4
 802bfa6:	2464      	movs	r4, #100	; 0x64
 802bfa8:	1a80      	subs	r0, r0, r2
 802bfaa:	4344      	muls	r4, r0
 802bfac:	1a9b      	subs	r3, r3, r2
 802bfae:	fb94 f4f3 	sdiv	r4, r4, r3
    temperatureDegreeC = __LL_ADC_CALC_TEMPERATURE_TYP_PARAMS(TEMPSENSOR_TYP_AVGSLOPE,
 802bfb2:	341e      	adds	r4, #30
 802bfb4:	b224      	sxth	r4, r4
  APP_LOG(TS_ON, VLEVEL_L, "temp= %d\n\r", temperatureDegreeC);
 802bfb6:	2201      	movs	r2, #1
 802bfb8:	4b0f      	ldr	r3, [pc, #60]	; (802bff8 <SYS_GetTemperatureLevel+0x78>)
 802bfba:	9400      	str	r4, [sp, #0]
 802bfbc:	2100      	movs	r1, #0
 802bfbe:	4610      	mov	r0, r2
 802bfc0:	f00e fe9c 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
  temperatureDegreeC <<= 8;
 802bfc4:	0220      	lsls	r0, r4, #8
}
 802bfc6:	b200      	sxth	r0, r0
 802bfc8:	b002      	add	sp, #8
 802bfca:	bd10      	pop	{r4, pc}
    temperatureDegreeC = __LL_ADC_CALC_TEMPERATURE_TYP_PARAMS(TEMPSENSOR_TYP_AVGSLOPE,
 802bfcc:	f640 74ff 	movw	r4, #4095	; 0xfff
 802bfd0:	fbb0 f0f4 	udiv	r0, r0, r4
 802bfd4:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 802bfd8:	4344      	muls	r4, r0
 802bfda:	f5a4 2439 	sub.w	r4, r4, #757760	; 0xb9000
 802bfde:	f5a4 640c 	sub.w	r4, r4, #2240	; 0x8c0
 802bfe2:	f640 10c4 	movw	r0, #2500	; 0x9c4
 802bfe6:	fb94 f4f0 	sdiv	r4, r4, r0
 802bfea:	e7e2      	b.n	802bfb2 <SYS_GetTemperatureLevel+0x32>
 802bfec:	b0001000 	.word	0xb0001000
 802bff0:	1fff75c8 	.word	0x1fff75c8
 802bff4:	1fff75a8 	.word	0x1fff75a8
 802bff8:	0803bd88 	.word	0x0803bd88

0802bffc <MX_DMA_Init>:
  SET_BIT(RCC->AHB1ENR, Periphs);
 802bffc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000

/**
  * Enable DMA controller clock
  */
void MX_DMA_Init(void)
{
 802c000:	b507      	push	{r0, r1, r2, lr}
 802c002:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 802c004:	f042 0204 	orr.w	r2, r2, #4
 802c008:	649a      	str	r2, [r3, #72]	; 0x48
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 802c00a:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 802c00c:	f002 0204 	and.w	r2, r2, #4
 802c010:	9201      	str	r2, [sp, #4]
  (void)tmpreg;
 802c012:	9a01      	ldr	r2, [sp, #4]
  SET_BIT(RCC->AHB1ENR, Periphs);
 802c014:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 802c016:	f042 0201 	orr.w	r2, r2, #1
 802c01a:	649a      	str	r2, [r3, #72]	; 0x48
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 802c01c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 802c01e:	f003 0301 	and.w	r3, r3, #1
 802c022:	9300      	str	r3, [sp, #0]
  __HAL_RCC_DMAMUX1_CLK_ENABLE();
  __HAL_RCC_DMA1_CLK_ENABLE();

  /* DMA interrupt init */
  /* DMA1_Channel5_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Channel5_IRQn, 2, 0);
 802c024:	2200      	movs	r2, #0
 802c026:	2102      	movs	r1, #2
 802c028:	200f      	movs	r0, #15
  (void)tmpreg;
 802c02a:	9b00      	ldr	r3, [sp, #0]
 802c02c:	f001 fe9a 	bl	802dd64 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel5_IRQn);
 802c030:	200f      	movs	r0, #15

}
 802c032:	b003      	add	sp, #12
 802c034:	f85d eb04 	ldr.w	lr, [sp], #4
  HAL_NVIC_EnableIRQ(DMA1_Channel5_IRQn);
 802c038:	f001 bec6 	b.w	802ddc8 <HAL_NVIC_EnableIRQ>

0802c03c <FLASH_IF_Write64>:

  /* USER CODE END FLASH_IF_Write_2 */
}

int32_t FLASH_IF_Write64(uint32_t address, uint64_t data)
{
 802c03c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
__STATIC_INLINE uint32_t LL_FLASH_IsActiveFlag_OperationSuspended(void)
{
#if defined(CORE_CM0PLUS)
  return ((READ_BIT(FLASH->C2SR, FLASH_C2SR_PESD) == (FLASH_C2SR_PESD)) ? 1UL : 0UL);
#else
  return ((READ_BIT(FLASH->SR, FLASH_SR_PESD) == (FLASH_SR_PESD)) ? 1UL : 0UL);
 802c03e:	4f0b      	ldr	r7, [pc, #44]	; (802c06c <FLASH_IF_Write64+0x30>)
 802c040:	4606      	mov	r6, r0
 802c042:	4614      	mov	r4, r2
 802c044:	461d      	mov	r5, r3
  /* USER CODE BEGIN FLASH_IF_Write64_1 */

  /* USER CODE END FLASH_IF_Write64_1 */
  while (*(uint64_t *)address != data)
 802c046:	e9d6 2300 	ldrd	r2, r3, [r6]
 802c04a:	42ab      	cmp	r3, r5
 802c04c:	bf08      	it	eq
 802c04e:	42a2      	cmpeq	r2, r4
 802c050:	d101      	bne.n	802c056 <FLASH_IF_Write64+0x1a>

  return FLASH_OK;
  /* USER CODE BEGIN HW_FLASH_Write_2 */

  /* USER CODE END HW_FLASH_Write_2 */
}
 802c052:	2000      	movs	r0, #0
 802c054:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802c056:	693b      	ldr	r3, [r7, #16]
 802c058:	031b      	lsls	r3, r3, #12
 802c05a:	d4fc      	bmi.n	802c056 <FLASH_IF_Write64+0x1a>
    HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, address, data);
 802c05c:	4622      	mov	r2, r4
 802c05e:	462b      	mov	r3, r5
 802c060:	4631      	mov	r1, r6
 802c062:	2001      	movs	r0, #1
 802c064:	f002 f966 	bl	802e334 <HAL_FLASH_Program>
 802c068:	e7ed      	b.n	802c046 <FLASH_IF_Write64+0xa>
 802c06a:	bf00      	nop
 802c06c:	58004000 	.word	0x58004000

0802c070 <FLASH_IF_Write_Buffer>:

/* USER CODE END EF */

/* Private Functions Definition -----------------------------------------------*/
static int32_t FLASH_IF_Write_Buffer(uint32_t pDestination, uint8_t *pSource, uint32_t uLength)
{
 802c070:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 802c072:	f022 0507 	bic.w	r5, r2, #7
 802c076:	4604      	mov	r4, r0
 802c078:	4405      	add	r5, r0
 802c07a:	1a0e      	subs	r6, r1, r0
  /* USER CODE END FLASH_IF_Write_Buffer_1 */
  uint8_t *pSrc = pSource;
  uint64_t src_value;
  int32_t status = FLASH_OK;

  for (uint32_t i = 0; i < (uLength / sizeof(uint64_t)); i++)
 802c07c:	42ac      	cmp	r4, r5
 802c07e:	eb06 0104 	add.w	r1, r6, r4
 802c082:	d101      	bne.n	802c088 <FLASH_IF_Write_Buffer+0x18>
 802c084:	2000      	movs	r0, #0
      /* exit the for loop*/
      break;
    }
  }

  return status;
 802c086:	e014      	b.n	802c0b2 <FLASH_IF_Write_Buffer+0x42>
    UTIL_MEM_cpy_8(&src_value, pSrc, sizeof(uint64_t));
 802c088:	2208      	movs	r2, #8
 802c08a:	4668      	mov	r0, sp
 802c08c:	f00e ff3e 	bl	803af0c <UTIL_MEM_cpy_8>
    if (src_value != UINT64_MAX)
 802c090:	e9dd 2300 	ldrd	r2, r3, [sp]
 802c094:	1c59      	adds	r1, r3, #1
 802c096:	bf08      	it	eq
 802c098:	f1b2 3fff 	cmpeq.w	r2, #4294967295
 802c09c:	f104 0708 	add.w	r7, r4, #8
 802c0a0:	d101      	bne.n	802c0a6 <FLASH_IF_Write_Buffer+0x36>
    pDestination += sizeof(uint64_t);
 802c0a2:	463c      	mov	r4, r7
    if (status != FLASH_OK)
 802c0a4:	e7ea      	b.n	802c07c <FLASH_IF_Write_Buffer+0xc>
      status = FLASH_IF_Write64(pDestination, src_value);
 802c0a6:	4620      	mov	r0, r4
 802c0a8:	f7ff ffc8 	bl	802c03c <FLASH_IF_Write64>
    pDestination += sizeof(uint64_t);
 802c0ac:	463c      	mov	r4, r7
    if (status != FLASH_OK)
 802c0ae:	2800      	cmp	r0, #0
 802c0b0:	d0e4      	beq.n	802c07c <FLASH_IF_Write_Buffer+0xc>
  /* USER CODE BEGIN FLASH_IF_Write_Buffer_2 */

  /* USER CODE END FLASH_IF_Write_Buffer_2 */
}
 802c0b2:	b003      	add	sp, #12
 802c0b4:	bdf0      	pop	{r4, r5, r6, r7, pc}

0802c0b6 <FLASH_IF_EraseByPages>:
{
 802c0b6:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  erase_str.TypeErase = FLASH_TYPEERASE_PAGES;
 802c0b8:	2302      	movs	r3, #2
  erase_str.Page = page;
 802c0ba:	e9cd 3001 	strd	r3, r0, [sp, #4]
  erase_str.NbPages = n;
 802c0be:	9103      	str	r1, [sp, #12]
  if (interrupt)
 802c0c0:	b15a      	cbz	r2, 802c0da <FLASH_IF_EraseByPages+0x24>
    hal_status = HAL_FLASHEx_Erase_IT(&erase_str);
 802c0c2:	a801      	add	r0, sp, #4
 802c0c4:	f002 f9ca 	bl	802e45c <HAL_FLASHEx_Erase_IT>
  return ((hal_status == HAL_OK) ? FLASH_OK : ((hal_status == HAL_BUSY) ? FLASH_BUSY : FLASH_ERASE_ERROR));
 802c0c8:	b120      	cbz	r0, 802c0d4 <FLASH_IF_EraseByPages+0x1e>
 802c0ca:	2802      	cmp	r0, #2
 802c0cc:	bf0c      	ite	eq
 802c0ce:	2001      	moveq	r0, #1
 802c0d0:	f06f 0001 	mvnne.w	r0, #1
}
 802c0d4:	b005      	add	sp, #20
 802c0d6:	f85d fb04 	ldr.w	pc, [sp], #4
    hal_status = HAL_FLASHEx_Erase(&erase_str, &page_error);
 802c0da:	4669      	mov	r1, sp
 802c0dc:	a801      	add	r0, sp, #4
 802c0de:	f002 f96f 	bl	802e3c0 <HAL_FLASHEx_Erase>
 802c0e2:	e7f1      	b.n	802c0c8 <FLASH_IF_EraseByPages+0x12>

0802c0e4 <FLASH_IF_Write>:
{
 802c0e4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802c0e8:	469a      	mov	sl, r3
  uint32_t page_start_index = PAGE(address);
 802c0ea:	4b46      	ldr	r3, [pc, #280]	; (802c204 <FLASH_IF_Write+0x120>)
{
 802c0ec:	4691      	mov	r9, r2
  uint32_t page_end_index = PAGE(address + size - 1);
 802c0ee:	f109 4878 	add.w	r8, r9, #4160749568	; 0xf8000000
  uint32_t page_start_index = PAGE(address);
 802c0f2:	681a      	ldr	r2, [r3, #0]
 802c0f4:	4b44      	ldr	r3, [pc, #272]	; (802c208 <FLASH_IF_Write+0x124>)
  uint32_t page_end_index = PAGE(address + size - 1);
 802c0f6:	f108 38ff 	add.w	r8, r8, #4294967295
  uint32_t page_start_index = PAGE(address);
 802c0fa:	ea03 2382 	and.w	r3, r3, r2, lsl #10
  uint32_t page_end_index = PAGE(address + size - 1);
 802c0fe:	4480      	add	r8, r0
  uint32_t page_start_index = PAGE(address);
 802c100:	f100 4278 	add.w	r2, r0, #4160749568	; 0xf8000000
 802c104:	fbb2 f6f3 	udiv	r6, r2, r3
 802c108:	fb03 2616 	mls	r6, r3, r6, r2
  uint32_t page_end_index = PAGE(address + size - 1);
 802c10c:	fbb8 f2f3 	udiv	r2, r8, r3
 802c110:	fb03 8812 	mls	r8, r3, r2, r8
{
 802c114:	4605      	mov	r5, r0
  uint32_t page_start_index = PAGE(address);
 802c116:	0af6      	lsrs	r6, r6, #11
  uint32_t page_end_index = PAGE(address + size - 1);
 802c118:	ea4f 28d8 	mov.w	r8, r8, lsr #11
  if ((data == NULL) || ((size % sizeof(uint64_t)) != 0) || ((address % sizeof(uint64_t)) != 0))
 802c11c:	460f      	mov	r7, r1
 802c11e:	b921      	cbnz	r1, 802c12a <FLASH_IF_Write+0x46>
    return FLASH_PARAM_ERROR;
 802c120:	f06f 0004 	mvn.w	r0, #4
}
 802c124:	b003      	add	sp, #12
 802c126:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if ((data == NULL) || ((size % sizeof(uint64_t)) != 0) || ((address % sizeof(uint64_t)) != 0))
 802c12a:	ea40 0309 	orr.w	r3, r0, r9
 802c12e:	075b      	lsls	r3, r3, #29
 802c130:	d1f6      	bne.n	802c120 <FLASH_IF_Write+0x3c>
  if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0U)
 802c132:	4b36      	ldr	r3, [pc, #216]	; (802c20c <FLASH_IF_Write+0x128>)
 802c134:	695b      	ldr	r3, [r3, #20]
 802c136:	2b00      	cmp	r3, #0
 802c138:	db5e      	blt.n	802c1f8 <FLASH_IF_Write+0x114>
  if (page_start_index != page_end_index)
 802c13a:	4546      	cmp	r6, r8
    curr_size = FLASH_PAGE_SIZE - (address % FLASH_PAGE_SIZE);
 802c13c:	bf1a      	itte	ne
 802c13e:	f3c0 030a 	ubfxne	r3, r0, #0, #11
 802c142:	f5c3 6b00 	rsbne	fp, r3, #2048	; 0x800
 802c146:	46cb      	moveq	fp, r9
  for (uint32_t idx = page_start_index; idx <= page_end_index; idx++)
 802c148:	4546      	cmp	r6, r8
 802c14a:	d901      	bls.n	802c150 <FLASH_IF_Write+0x6c>
  int32_t status = FLASH_OK;
 802c14c:	2000      	movs	r0, #0
 802c14e:	e7e9      	b.n	802c124 <FLASH_IF_Write+0x40>
    if (FLASH_IF_IsEmpty((uint8_t *)curr_dest_addr, curr_size) != FLASH_EMPTY)
 802c150:	eb0b 0305 	add.w	r3, fp, r5
 802c154:	462c      	mov	r4, r5
  /* USER CODE END FLASH_IF_IsEmpty_1 */
  uint64_t *addr64;
  uint32_t i;

  /* start memory NOT 64bits aligned */
  while ((((uint32_t)addr) % sizeof(uint64_t)) != 0)
 802c156:	9301      	str	r3, [sp, #4]
 802c158:	9b01      	ldr	r3, [sp, #4]
 802c15a:	f014 0c07 	ands.w	ip, r4, #7
 802c15e:	eba3 0204 	sub.w	r2, r3, r4
 802c162:	d10c      	bne.n	802c17e <FLASH_IF_Write+0x9a>
    size--;
  }

  /* addr64 is 64 bits aligned */
  addr64 = (uint64_t *)addr;
  for (i = 0; i < (size / sizeof(uint64_t)); i++)
 802c164:	ea4f 0ed2 	mov.w	lr, r2, lsr #3
 802c168:	45f4      	cmp	ip, lr
 802c16a:	d130      	bne.n	802c1ce <FLASH_IF_Write+0xea>
    if (*addr64++ != UINT64_MAX)
    {
      return FLASH_NOT_EMPTY;
    }
  }
  size -= sizeof(uint64_t) * i;
 802c16c:	eba2 02cc 	sub.w	r2, r2, ip, lsl #3
 802c170:	4422      	add	r2, r4

  /* end memory NOT 64 bits aligned */
  addr = (uint8_t *)addr64;
  while (size != 0)
 802c172:	42a2      	cmp	r2, r4
 802c174:	d135      	bne.n	802c1e2 <FLASH_IF_Write+0xfe>
      if (FLASH_IF_Write_Buffer(curr_dest_addr, (uint8_t *)curr_src_addr, curr_size) != FLASH_OK)
 802c176:	465a      	mov	r2, fp
 802c178:	4639      	mov	r1, r7
 802c17a:	4628      	mov	r0, r5
 802c17c:	e021      	b.n	802c1c2 <FLASH_IF_Write+0xde>
    if (*addr++ != UINT8_MAX)
 802c17e:	f814 2b01 	ldrb.w	r2, [r4], #1
 802c182:	2aff      	cmp	r2, #255	; 0xff
 802c184:	d0e8      	beq.n	802c158 <FLASH_IF_Write+0x74>
      if (dataTempPage == NULL)
 802c186:	f1ba 0f00 	cmp.w	sl, #0
 802c18a:	d0c9      	beq.n	802c120 <FLASH_IF_Write+0x3c>
      UTIL_MEM_cpy_8(dataTempPage, (uint8_t *)(idx * FLASH_PAGE_SIZE + FLASH_BASE), FLASH_PAGE_SIZE);
 802c18c:	02f4      	lsls	r4, r6, #11
 802c18e:	f104 6400 	add.w	r4, r4, #134217728	; 0x8000000
 802c192:	f44f 6200 	mov.w	r2, #2048	; 0x800
 802c196:	4621      	mov	r1, r4
 802c198:	4650      	mov	r0, sl
 802c19a:	f00e feb7 	bl	803af0c <UTIL_MEM_cpy_8>
      UTIL_MEM_cpy_8(&dataTempPage[((uint32_t)curr_dest_addr) % FLASH_PAGE_SIZE], (uint8_t *)curr_src_addr, curr_size);
 802c19e:	f3c5 000a 	ubfx	r0, r5, #0, #11
 802c1a2:	fa1f f28b 	uxth.w	r2, fp
 802c1a6:	4639      	mov	r1, r7
 802c1a8:	4450      	add	r0, sl
 802c1aa:	f00e feaf 	bl	803af0c <UTIL_MEM_cpy_8>
      if (FLASH_IF_EraseByPages(idx, 1, 0) != FLASH_OK)
 802c1ae:	2200      	movs	r2, #0
 802c1b0:	2101      	movs	r1, #1
 802c1b2:	4630      	mov	r0, r6
 802c1b4:	f7ff ff7f 	bl	802c0b6 <FLASH_IF_EraseByPages>
 802c1b8:	bb08      	cbnz	r0, 802c1fe <FLASH_IF_Write+0x11a>
        if (FLASH_IF_Write_Buffer(idx * FLASH_PAGE_SIZE + FLASH_BASE, dataTempPage, FLASH_PAGE_SIZE) != FLASH_OK)
 802c1ba:	f44f 6200 	mov.w	r2, #2048	; 0x800
 802c1be:	4651      	mov	r1, sl
 802c1c0:	4620      	mov	r0, r4
 802c1c2:	f7ff ff55 	bl	802c070 <FLASH_IF_Write_Buffer>
 802c1c6:	b188      	cbz	r0, 802c1ec <FLASH_IF_Write+0x108>
          status = FLASH_WRITE_ERROR;
 802c1c8:	f06f 0002 	mvn.w	r0, #2
 802c1cc:	e7aa      	b.n	802c124 <FLASH_IF_Write+0x40>
    if (*addr64++ != UINT64_MAX)
 802c1ce:	e8f4 0102 	ldrd	r0, r1, [r4], #8
 802c1d2:	3101      	adds	r1, #1
 802c1d4:	bf08      	it	eq
 802c1d6:	f1b0 3fff 	cmpeq.w	r0, #4294967295
 802c1da:	d1d4      	bne.n	802c186 <FLASH_IF_Write+0xa2>
  for (i = 0; i < (size / sizeof(uint64_t)); i++)
 802c1dc:	f10c 0c01 	add.w	ip, ip, #1
 802c1e0:	e7c2      	b.n	802c168 <FLASH_IF_Write+0x84>
  {
    if (*addr++ != UINT8_MAX)
 802c1e2:	f814 1b01 	ldrb.w	r1, [r4], #1
 802c1e6:	29ff      	cmp	r1, #255	; 0xff
 802c1e8:	d0c3      	beq.n	802c172 <FLASH_IF_Write+0x8e>
 802c1ea:	e7cc      	b.n	802c186 <FLASH_IF_Write+0xa2>
    curr_src_addr += curr_size;
 802c1ec:	445f      	add	r7, fp
  for (uint32_t idx = page_start_index; idx <= page_end_index; idx++)
 802c1ee:	9d01      	ldr	r5, [sp, #4]
    curr_size = size - curr_size;
 802c1f0:	eba9 0b0b 	sub.w	fp, r9, fp
  for (uint32_t idx = page_start_index; idx <= page_end_index; idx++)
 802c1f4:	3601      	adds	r6, #1
 802c1f6:	e7a7      	b.n	802c148 <FLASH_IF_Write+0x64>
    return FLASH_LOCK_ERROR;
 802c1f8:	f06f 0003 	mvn.w	r0, #3
 802c1fc:	e792      	b.n	802c124 <FLASH_IF_Write+0x40>
        status = FLASH_ERASE_ERROR;
 802c1fe:	f06f 0001 	mvn.w	r0, #1
 802c202:	e78f      	b.n	802c124 <FLASH_IF_Write+0x40>
 802c204:	1fff75e0 	.word	0x1fff75e0
 802c208:	03fffc00 	.word	0x03fffc00
 802c20c:	58004000 	.word	0x58004000

0802c210 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 802c210:	b500      	push	{lr}
 802c212:	b09b      	sub	sp, #108	; 0x6c
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 802c214:	2248      	movs	r2, #72	; 0x48
 802c216:	2100      	movs	r1, #0
 802c218:	a808      	add	r0, sp, #32
 802c21a:	f00f fab5 	bl	803b788 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 802c21e:	221c      	movs	r2, #28
 802c220:	2100      	movs	r1, #0
 802c222:	a801      	add	r0, sp, #4
 802c224:	f00f fab0 	bl	803b788 <memset>

  /** Configure LSE Drive Capability
  */
  HAL_PWR_EnableBkUpAccess();
 802c228:	f002 fa84 	bl	802e734 <HAL_PWR_EnableBkUpAccess>
  *         @arg @ref LL_RCC_LSEDRIVE_HIGH
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSE_SetDriveCapability(uint32_t LSEDrive)
{
  MODIFY_REG(RCC->BDCR, RCC_BDCR_LSEDRV, LSEDrive);
 802c22c:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
  /** Initializes the CPU, AHB and APB busses clocks
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSE|RCC_OSCILLATORTYPE_MSI;
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
  RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
 802c230:	2001      	movs	r0, #1
 802c232:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 802c236:	f023 0318 	bic.w	r3, r3, #24
 802c23a:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 802c23e:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
 802c242:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 802c246:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 802c24a:	f8c2 3400 	str.w	r3, [r2, #1024]	; 0x400
 802c24e:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
 802c252:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 802c256:	9300      	str	r3, [sp, #0]
 802c258:	9b00      	ldr	r3, [sp, #0]
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSE|RCC_OSCILLATORTYPE_MSI;
 802c25a:	2324      	movs	r3, #36	; 0x24
 802c25c:	9308      	str	r3, [sp, #32]
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 802c25e:	2381      	movs	r3, #129	; 0x81
 802c260:	930b      	str	r3, [sp, #44]	; 0x2c
  RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
 802c262:	2300      	movs	r3, #0
 802c264:	e9cd 0310 	strd	r0, r3, [sp, #64]	; 0x40
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_11;
 802c268:	22b0      	movs	r2, #176	; 0xb0
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 802c26a:	a808      	add	r0, sp, #32
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 802c26c:	e9cd 2312 	strd	r2, r3, [sp, #72]	; 0x48
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 802c270:	f002 fbe0 	bl	802ea34 <HAL_RCC_OscConfig>
 802c274:	b108      	cbz	r0, 802c27a <SystemClock_Config+0x6a>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 802c276:	b672      	cpsid	i
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 802c278:	e7fe      	b.n	802c278 <SystemClock_Config+0x68>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK3|RCC_CLOCKTYPE_HCLK
 802c27a:	234f      	movs	r3, #79	; 0x4f
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
 802c27c:	e9cd 3001 	strd	r3, r0, [sp, #4]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 802c280:	e9cd 0003 	strd	r0, r0, [sp, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 802c284:	9005      	str	r0, [sp, #20]
  RCC_ClkInitStruct.AHBCLK3Divider = RCC_SYSCLK_DIV1;
 802c286:	9007      	str	r0, [sp, #28]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
 802c288:	2102      	movs	r1, #2
 802c28a:	a801      	add	r0, sp, #4
 802c28c:	f002 fe72 	bl	802ef74 <HAL_RCC_ClockConfig>
 802c290:	b108      	cbz	r0, 802c296 <SystemClock_Config+0x86>
 802c292:	b672      	cpsid	i
  while (1)
 802c294:	e7fe      	b.n	802c294 <SystemClock_Config+0x84>
}
 802c296:	b01b      	add	sp, #108	; 0x6c
 802c298:	f85d fb04 	ldr.w	pc, [sp], #4

0802c29c <main>:
{
 802c29c:	b508      	push	{r3, lr}
  HAL_Init();
 802c29e:	f001 f8ef 	bl	802d480 <HAL_Init>
  SystemClock_Config();
 802c2a2:	f7ff ffb5 	bl	802c210 <SystemClock_Config>
  MX_KMS_Init();
 802c2a6:	f000 fc3f 	bl	802cb28 <MX_KMS_Init>
  MX_LoRaWAN_Init();
 802c2aa:	f000 fc40 	bl	802cb2e <MX_LoRaWAN_Init>
    MX_LoRaWAN_Process();
 802c2ae:	f000 fc45 	bl	802cb3c <MX_LoRaWAN_Process>
  while (1)
 802c2b2:	e7fc      	b.n	802c2ae <main+0x12>

0802c2b4 <Error_Handler>:
 802c2b4:	b672      	cpsid	i
  while (1)
 802c2b6:	e7fe      	b.n	802c2b6 <Error_Handler+0x2>

0802c2b8 <MX_RTC_Init>:

RTC_HandleTypeDef hrtc;

/* RTC init function */
void MX_RTC_Init(void)
{
 802c2b8:	b500      	push	{lr}
 802c2ba:	b08d      	sub	sp, #52	; 0x34

  /* USER CODE BEGIN RTC_Init 0 */

  /* USER CODE END RTC_Init 0 */

  RTC_AlarmTypeDef sAlarm = {0};
 802c2bc:	222c      	movs	r2, #44	; 0x2c
 802c2be:	2100      	movs	r1, #0
 802c2c0:	a801      	add	r0, sp, #4
 802c2c2:	f00f fa61 	bl	803b788 <memset>
  /* USER CODE BEGIN RTC_Init 1 */

  /* USER CODE END RTC_Init 1 */
  /** Initialize RTC Only
  */
  hrtc.Instance = RTC;
 802c2c6:	4817      	ldr	r0, [pc, #92]	; (802c324 <MX_RTC_Init+0x6c>)
 802c2c8:	4b17      	ldr	r3, [pc, #92]	; (802c328 <MX_RTC_Init+0x70>)
 802c2ca:	6003      	str	r3, [r0, #0]
  hrtc.Init.AsynchPrediv = RTC_PREDIV_A;
 802c2cc:	231f      	movs	r3, #31
 802c2ce:	6083      	str	r3, [r0, #8]
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
  hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
 802c2d0:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
 802c2d4:	2300      	movs	r3, #0
  hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
 802c2d6:	e9c0 3304 	strd	r3, r3, [r0, #16]
  hrtc.Init.OutPutPullUp = RTC_OUTPUT_PULLUP_NONE;
 802c2da:	e9c0 2307 	strd	r2, r3, [r0, #28]
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
 802c2de:	6183      	str	r3, [r0, #24]
  hrtc.Init.BinMode = RTC_BINARY_ONLY;
 802c2e0:	f44f 7380 	mov.w	r3, #256	; 0x100
 802c2e4:	6243      	str	r3, [r0, #36]	; 0x24
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
 802c2e6:	f003 f911 	bl	802f50c <HAL_RTC_Init>
 802c2ea:	b108      	cbz	r0, 802c2f0 <MX_RTC_Init+0x38>
  {
    Error_Handler();
 802c2ec:	f7ff ffe2 	bl	802c2b4 <Error_Handler>

  /* USER CODE END Check_RTC_BKUP */

  /** Initialize RTC and set the Time and Date
  */
  if (HAL_RTCEx_SetSSRU_IT(&hrtc) != HAL_OK)
 802c2f0:	480c      	ldr	r0, [pc, #48]	; (802c324 <MX_RTC_Init+0x6c>)
 802c2f2:	f003 fa2f 	bl	802f754 <HAL_RTCEx_SetSSRU_IT>
 802c2f6:	b108      	cbz	r0, 802c2fc <MX_RTC_Init+0x44>
  {
    Error_Handler();
 802c2f8:	f7ff ffdc 	bl	802c2b4 <Error_Handler>
  /** Enable the Alarm A
  */
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
  sAlarm.AlarmTime.SubSeconds = 0x0;
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDBINMASK_NONE;
 802c2fc:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
 802c300:	2200      	movs	r2, #0
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDBINMASK_NONE;
 802c302:	9307      	str	r3, [sp, #28]
  sAlarm.Alarm = RTC_ALARM_A;
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, 0) != HAL_OK)
 802c304:	4807      	ldr	r0, [pc, #28]	; (802c324 <MX_RTC_Init+0x6c>)
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
 802c306:	9208      	str	r2, [sp, #32]
  sAlarm.Alarm = RTC_ALARM_A;
 802c308:	f44f 7380 	mov.w	r3, #256	; 0x100
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, 0) != HAL_OK)
 802c30c:	a901      	add	r1, sp, #4
  sAlarm.AlarmTime.SubSeconds = 0x0;
 802c30e:	9202      	str	r2, [sp, #8]
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
 802c310:	9206      	str	r2, [sp, #24]
  sAlarm.Alarm = RTC_ALARM_A;
 802c312:	930b      	str	r3, [sp, #44]	; 0x2c
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, 0) != HAL_OK)
 802c314:	f003 f956 	bl	802f5c4 <HAL_RTC_SetAlarm_IT>
 802c318:	b108      	cbz	r0, 802c31e <MX_RTC_Init+0x66>
  {
    Error_Handler();
 802c31a:	f7ff ffcb 	bl	802c2b4 <Error_Handler>
  }
  /* USER CODE BEGIN RTC_Init 2 */

  /* USER CODE END RTC_Init 2 */

}
 802c31e:	b00d      	add	sp, #52	; 0x34
 802c320:	f85d fb04 	ldr.w	pc, [sp], #4
 802c324:	200061b8 	.word	0x200061b8
 802c328:	40002800 	.word	0x40002800

0802c32c <HAL_RTC_MspInit>:

void HAL_RTC_MspInit(RTC_HandleTypeDef* rtcHandle)
{
 802c32c:	b510      	push	{r4, lr}
 802c32e:	4604      	mov	r4, r0
 802c330:	b090      	sub	sp, #64	; 0x40

  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 802c332:	2238      	movs	r2, #56	; 0x38
 802c334:	2100      	movs	r1, #0
 802c336:	a802      	add	r0, sp, #8
 802c338:	f00f fa26 	bl	803b788 <memset>
  if(rtcHandle->Instance==RTC)
 802c33c:	6822      	ldr	r2, [r4, #0]
 802c33e:	4b19      	ldr	r3, [pc, #100]	; (802c3a4 <HAL_RTC_MspInit+0x78>)
 802c340:	429a      	cmp	r2, r3
 802c342:	d12c      	bne.n	802c39e <HAL_RTC_MspInit+0x72>
  /* USER CODE BEGIN RTC_MspInit 0 */

  /* USER CODE END RTC_MspInit 0 */
  /** Initializes the peripherals clocks
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 802c344:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 802c348:	9302      	str	r3, [sp, #8]
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;

    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 802c34a:	a802      	add	r0, sp, #8
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
 802c34c:	f44f 7380 	mov.w	r3, #256	; 0x100
 802c350:	930f      	str	r3, [sp, #60]	; 0x3c
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 802c352:	f002 ff4b 	bl	802f1ec <HAL_RCCEx_PeriphCLKConfig>
 802c356:	b108      	cbz	r0, 802c35c <HAL_RTC_MspInit+0x30>
    {
      Error_Handler();
 802c358:	f7ff ffac 	bl	802c2b4 <Error_Handler>
  * @rmtoll BDCR         RTCEN         LL_RCC_EnableRTC
  * @retval None
  */
__STATIC_INLINE void LL_RCC_EnableRTC(void)
{
  SET_BIT(RCC->BDCR, RCC_BDCR_RTCEN);
 802c35c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
    /* RTC clock enable */
    __HAL_RCC_RTC_ENABLE();
    __HAL_RCC_RTCAPB_CLK_ENABLE();

    /* RTC interrupt Init */
    HAL_NVIC_SetPriority(TAMP_STAMP_LSECSS_SSRU_IRQn, 0, 0);
 802c360:	2002      	movs	r0, #2
 802c362:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 802c366:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 802c36a:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  SET_BIT(RCC->APB1ENR1, Periphs);
 802c36e:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 802c370:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 802c374:	659a      	str	r2, [r3, #88]	; 0x58
  tmpreg = READ_BIT(RCC->APB1ENR1, Periphs);
 802c376:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 802c378:	2200      	movs	r2, #0
 802c37a:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 802c37e:	4611      	mov	r1, r2
 802c380:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 802c382:	9b01      	ldr	r3, [sp, #4]
 802c384:	f001 fcee 	bl	802dd64 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TAMP_STAMP_LSECSS_SSRU_IRQn);
 802c388:	2002      	movs	r0, #2
 802c38a:	f001 fd1d 	bl	802ddc8 <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(RTC_Alarm_IRQn, 0, 0);
 802c38e:	2200      	movs	r2, #0
 802c390:	202a      	movs	r0, #42	; 0x2a
 802c392:	4611      	mov	r1, r2
 802c394:	f001 fce6 	bl	802dd64 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(RTC_Alarm_IRQn);
 802c398:	202a      	movs	r0, #42	; 0x2a
 802c39a:	f001 fd15 	bl	802ddc8 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN RTC_MspInit 1 */

  /* USER CODE END RTC_MspInit 1 */
  }
}
 802c39e:	b010      	add	sp, #64	; 0x40
 802c3a0:	bd10      	pop	{r4, pc}
 802c3a2:	bf00      	nop
 802c3a4:	40002800 	.word	0x40002800

0802c3a8 <PWR_EnterOffMode>:
void PWR_EnterOffMode(void)
{
  /* USER CODE BEGIN EnterOffMode_1 */

  /* USER CODE END EnterOffMode_1 */
}
 802c3a8:	4770      	bx	lr
	...

0802c3ac <PWR_EnterStopMode>:

  /* USER CODE END ExitOffMode_1 */
}

void PWR_EnterStopMode(void)
{
 802c3ac:	b508      	push	{r3, lr}
  /* USER CODE BEGIN EnterStopMode_1 */

  /* USER CODE END EnterStopMode_1 */
  HAL_SuspendTick();
 802c3ae:	f001 f87d 	bl	802d4ac <HAL_SuspendTick>
  * @rmtoll EXTSCR       C1CSSF        LL_PWR_ClearFlag_C1STOP_C1STB
  * @retval None
  */
__STATIC_INLINE void LL_PWR_ClearFlag_C1STOP_C1STB(void)
{
  WRITE_REG(PWR->EXTSCR, PWR_EXTSCR_C1CSSF);
 802c3b2:	4b04      	ldr	r3, [pc, #16]	; (802c3c4 <PWR_EnterStopMode+0x18>)
 802c3b4:	2001      	movs	r0, #1
 802c3b6:	f8c3 0088 	str.w	r0, [r3, #136]	; 0x88
  /* USER CODE END EnterStopMode_2 */
  HAL_PWREx_EnterSTOP2Mode(PWR_STOPENTRY_WFI);
  /* USER CODE BEGIN EnterStopMode_3 */

  /* USER CODE END EnterStopMode_3 */
}
 802c3ba:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_PWREx_EnterSTOP2Mode(PWR_STOPENTRY_WFI);
 802c3be:	f002 ba13 	b.w	802e7e8 <HAL_PWREx_EnterSTOP2Mode>
 802c3c2:	bf00      	nop
 802c3c4:	58000400 	.word	0x58000400

0802c3c8 <PWR_ExitSleepMode>:
{
  /* USER CODE BEGIN ExitSleepMode_1 */

  /* USER CODE END ExitSleepMode_1 */
  /* Suspend sysTick */
  HAL_ResumeTick();
 802c3c8:	f001 b878 	b.w	802d4bc <HAL_ResumeTick>

0802c3cc <PWR_ExitStopMode>:
{
 802c3cc:	b508      	push	{r3, lr}
  HAL_ResumeTick();
 802c3ce:	f001 f875 	bl	802d4bc <HAL_ResumeTick>
}
 802c3d2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  vcom_Resume();
 802c3d6:	f000 bb77 	b.w	802cac8 <vcom_Resume>

0802c3da <PWR_EnterSleepMode>:
{
 802c3da:	b508      	push	{r3, lr}
  HAL_SuspendTick();
 802c3dc:	f001 f866 	bl	802d4ac <HAL_SuspendTick>
}
 802c3e0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_SLEEPENTRY_WFI);
 802c3e4:	2101      	movs	r1, #1
 802c3e6:	2000      	movs	r0, #0
 802c3e8:	f002 b9ac 	b.w	802e744 <HAL_PWR_EnterSLEEPMode>

0802c3ec <PWR_ExitOffMode>:
 802c3ec:	4770      	bx	lr

0802c3ee <HAL_MspInit>:
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 802c3ee:	4770      	bx	lr

0802c3f0 <NMI_Handler>:
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 802c3f0:	e7fe      	b.n	802c3f0 <NMI_Handler>

0802c3f2 <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 802c3f2:	e7fe      	b.n	802c3f2 <HardFault_Handler>

0802c3f4 <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 802c3f4:	e7fe      	b.n	802c3f4 <MemManage_Handler>

0802c3f6 <BusFault_Handler>:
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 802c3f6:	e7fe      	b.n	802c3f6 <BusFault_Handler>

0802c3f8 <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 802c3f8:	e7fe      	b.n	802c3f8 <UsageFault_Handler>

0802c3fa <SVC_Handler>:

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 802c3fa:	4770      	bx	lr

0802c3fc <DebugMon_Handler>:
 802c3fc:	4770      	bx	lr

0802c3fe <PendSV_Handler>:
 802c3fe:	4770      	bx	lr

0802c400 <SysTick_Handler>:
 802c400:	4770      	bx	lr
	...

0802c404 <TAMP_STAMP_LSECSS_SSRU_IRQHandler>:
void TAMP_STAMP_LSECSS_SSRU_IRQHandler(void)
{
  /* USER CODE BEGIN TAMP_STAMP_LSECSS_SSRU_IRQn 0 */

  /* USER CODE END TAMP_STAMP_LSECSS_SSRU_IRQn 0 */
  HAL_RTCEx_SSRUIRQHandler(&hrtc);
 802c404:	4801      	ldr	r0, [pc, #4]	; (802c40c <TAMP_STAMP_LSECSS_SSRU_IRQHandler+0x8>)
 802c406:	f003 b9cb 	b.w	802f7a0 <HAL_RTCEx_SSRUIRQHandler>
 802c40a:	bf00      	nop
 802c40c:	200061b8 	.word	0x200061b8

0802c410 <EXTI0_IRQHandler>:
void EXTI0_IRQHandler(void)
{
  /* USER CODE BEGIN EXTI0_IRQn 0 */

  /* USER CODE END EXTI0_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_0);
 802c410:	2001      	movs	r0, #1
 802c412:	f002 b983 	b.w	802e71c <HAL_GPIO_EXTI_IRQHandler>

0802c416 <EXTI1_IRQHandler>:
void EXTI1_IRQHandler(void)
{
  /* USER CODE BEGIN EXTI1_IRQn 0 */

  /* USER CODE END EXTI1_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_1);
 802c416:	2002      	movs	r0, #2
 802c418:	f002 b980 	b.w	802e71c <HAL_GPIO_EXTI_IRQHandler>

0802c41c <DMA1_Channel5_IRQHandler>:
void DMA1_Channel5_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Channel5_IRQn 0 */

  /* USER CODE END DMA1_Channel5_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_usart2_tx);
 802c41c:	4801      	ldr	r0, [pc, #4]	; (802c424 <DMA1_Channel5_IRQHandler+0x8>)
 802c41e:	f001 beb1 	b.w	802e184 <HAL_DMA_IRQHandler>
 802c422:	bf00      	nop
 802c424:	200061fc 	.word	0x200061fc

0802c428 <USART2_IRQHandler>:
void USART2_IRQHandler(void)
{
  /* USER CODE BEGIN USART2_IRQn 0 */

  /* USER CODE END USART2_IRQn 0 */
  HAL_UART_IRQHandler(&huart2);
 802c428:	4801      	ldr	r0, [pc, #4]	; (802c430 <USART2_IRQHandler+0x8>)
 802c42a:	f003 bd89 	b.w	802ff40 <HAL_UART_IRQHandler>
 802c42e:	bf00      	nop
 802c430:	2000625c 	.word	0x2000625c

0802c434 <RTC_Alarm_IRQHandler>:
void RTC_Alarm_IRQHandler(void)
{
  /* USER CODE BEGIN RTC_Alarm_IRQn 0 */

  /* USER CODE END RTC_Alarm_IRQn 0 */
  HAL_RTC_AlarmIRQHandler(&hrtc);
 802c434:	4801      	ldr	r0, [pc, #4]	; (802c43c <RTC_Alarm_IRQHandler+0x8>)
 802c436:	f002 bfeb 	b.w	802f410 <HAL_RTC_AlarmIRQHandler>
 802c43a:	bf00      	nop
 802c43c:	200061b8 	.word	0x200061b8

0802c440 <SUBGHZ_Radio_IRQHandler>:
void SUBGHZ_Radio_IRQHandler(void)
{
  /* USER CODE BEGIN SUBGHZ_Radio_IRQn 0 */

  /* USER CODE END SUBGHZ_Radio_IRQn 0 */
  HAL_SUBGHZ_IRQHandler(&hsubghz);
 802c440:	4801      	ldr	r0, [pc, #4]	; (802c448 <SUBGHZ_Radio_IRQHandler+0x8>)
 802c442:	f003 bc3e 	b.w	802fcc2 <HAL_SUBGHZ_IRQHandler>
 802c446:	bf00      	nop
 802c448:	200061f0 	.word	0x200061f0

0802c44c <MX_SUBGHZ_Init>:
  /* USER CODE END SUBGHZ_Init 0 */

  /* USER CODE BEGIN SUBGHZ_Init 1 */

  /* USER CODE END SUBGHZ_Init 1 */
  hsubghz.Init.BaudratePrescaler = SUBGHZSPI_BAUDRATEPRESCALER_4;
 802c44c:	4805      	ldr	r0, [pc, #20]	; (802c464 <MX_SUBGHZ_Init+0x18>)
{
 802c44e:	b508      	push	{r3, lr}
  hsubghz.Init.BaudratePrescaler = SUBGHZSPI_BAUDRATEPRESCALER_4;
 802c450:	2308      	movs	r3, #8
 802c452:	6003      	str	r3, [r0, #0]
  if (HAL_SUBGHZ_Init(&hsubghz) != HAL_OK)
 802c454:	f003 f9ea 	bl	802f82c <HAL_SUBGHZ_Init>
 802c458:	b118      	cbz	r0, 802c462 <MX_SUBGHZ_Init+0x16>
  }
  /* USER CODE BEGIN SUBGHZ_Init 2 */

  /* USER CODE END SUBGHZ_Init 2 */

}
 802c45a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 802c45e:	f7ff bf29 	b.w	802c2b4 <Error_Handler>
}
 802c462:	bd08      	pop	{r3, pc}
 802c464:	200061f0 	.word	0x200061f0

0802c468 <HAL_SUBGHZ_MspInit>:
  * @retval None
  */
__STATIC_INLINE void LL_APB3_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB3ENR, Periphs);
 802c468:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000

void HAL_SUBGHZ_MspInit(SUBGHZ_HandleTypeDef* subghzHandle)
{
 802c46c:	b507      	push	{r0, r1, r2, lr}
 802c46e:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 802c470:	f042 0201 	orr.w	r2, r2, #1
 802c474:	665a      	str	r2, [r3, #100]	; 0x64
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB3ENR, Periphs);
 802c476:	6e5b      	ldr	r3, [r3, #100]	; 0x64
  /* USER CODE END SUBGHZ_MspInit 0 */
    /* SUBGHZ clock enable */
    __HAL_RCC_SUBGHZSPI_CLK_ENABLE();

    /* SUBGHZ interrupt Init */
    HAL_NVIC_SetPriority(SUBGHZ_Radio_IRQn, 0, 0);
 802c478:	2200      	movs	r2, #0
 802c47a:	f003 0301 	and.w	r3, r3, #1
 802c47e:	9301      	str	r3, [sp, #4]
 802c480:	4611      	mov	r1, r2
 802c482:	2032      	movs	r0, #50	; 0x32
  (void)tmpreg;
 802c484:	9b01      	ldr	r3, [sp, #4]
 802c486:	f001 fc6d 	bl	802dd64 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SUBGHZ_Radio_IRQn);
 802c48a:	2032      	movs	r0, #50	; 0x32
  /* USER CODE BEGIN SUBGHZ_MspInit 1 */

  /* USER CODE END SUBGHZ_MspInit 1 */
}
 802c48c:	b003      	add	sp, #12
 802c48e:	f85d eb04 	ldr.w	lr, [sp], #4
    HAL_NVIC_EnableIRQ(SUBGHZ_Radio_IRQn);
 802c492:	f001 bc99 	b.w	802ddc8 <HAL_NVIC_EnableIRQ>
	...

0802c498 <tiny_snprintf_like.constprop.0>:
  /* USER CODE BEGIN UTIL_LPM_SetStopMode_2 */

  /* USER CODE END UTIL_LPM_SetStopMode_2 */
}

static void tiny_snprintf_like(char *buf, uint32_t maxsize, const char *strFormat, ...)
 802c498:	b40c      	push	{r2, r3}
 802c49a:	b507      	push	{r0, r1, r2, lr}
  /* USER CODE BEGIN tiny_snprintf_like_1 */

  /* USER CODE END tiny_snprintf_like_1 */
  va_list vaArgs;
  va_start(vaArgs, strFormat);
  UTIL_ADV_TRACE_VSNPRINTF(buf, maxsize, strFormat, vaArgs);
 802c49c:	4a05      	ldr	r2, [pc, #20]	; (802c4b4 <tiny_snprintf_like.constprop.0+0x1c>)
  va_start(vaArgs, strFormat);
 802c49e:	ab05      	add	r3, sp, #20
  UTIL_ADV_TRACE_VSNPRINTF(buf, maxsize, strFormat, vaArgs);
 802c4a0:	2110      	movs	r1, #16
  va_start(vaArgs, strFormat);
 802c4a2:	9301      	str	r3, [sp, #4]
  UTIL_ADV_TRACE_VSNPRINTF(buf, maxsize, strFormat, vaArgs);
 802c4a4:	f00f f832 	bl	803b50c <tiny_vsnprintf_like>
  va_end(vaArgs);
  /* USER CODE BEGIN tiny_snprintf_like_2 */

  /* USER CODE END tiny_snprintf_like_2 */
}
 802c4a8:	b003      	add	sp, #12
 802c4aa:	f85d eb04 	ldr.w	lr, [sp], #4
 802c4ae:	b002      	add	sp, #8
 802c4b0:	4770      	bx	lr
 802c4b2:	bf00      	nop
 802c4b4:	0803bd93 	.word	0x0803bd93

0802c4b8 <TimestampNow>:
{
 802c4b8:	b530      	push	{r4, r5, lr}
 802c4ba:	b085      	sub	sp, #20
 802c4bc:	4604      	mov	r4, r0
  SysTime_t curtime = SysTimeGet();
 802c4be:	a802      	add	r0, sp, #8
{
 802c4c0:	460d      	mov	r5, r1
  SysTime_t curtime = SysTimeGet();
 802c4c2:	f00e fe4f 	bl	803b164 <SysTimeGet>
  tiny_snprintf_like((char *)buff, MAX_TS_SIZE, "%ds%03d:", curtime.Seconds, curtime.SubSeconds);
 802c4c6:	f9bd 300c 	ldrsh.w	r3, [sp, #12]
 802c4ca:	4a06      	ldr	r2, [pc, #24]	; (802c4e4 <TimestampNow+0x2c>)
 802c4cc:	9300      	str	r3, [sp, #0]
 802c4ce:	2110      	movs	r1, #16
 802c4d0:	9b02      	ldr	r3, [sp, #8]
 802c4d2:	4620      	mov	r0, r4
 802c4d4:	f7ff ffe0 	bl	802c498 <tiny_snprintf_like.constprop.0>
  *size = strlen((char *)buff);
 802c4d8:	4620      	mov	r0, r4
 802c4da:	f7fe ffb1 	bl	802b440 <strlen>
 802c4de:	8028      	strh	r0, [r5, #0]
}
 802c4e0:	b005      	add	sp, #20
 802c4e2:	bd30      	pop	{r4, r5, pc}
 802c4e4:	0803bd93 	.word	0x0803bd93

0802c4e8 <SystemApp_Init>:
  MODIFY_REG(RCC->CFGR, RCC_CFGR_STOPWUCK, Clock);
 802c4e8:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
{
 802c4ec:	b508      	push	{r3, lr}
 802c4ee:	6893      	ldr	r3, [r2, #8]
 802c4f0:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 802c4f4:	6093      	str	r3, [r2, #8]
  UTIL_TIMER_Init();
 802c4f6:	f00e febb 	bl	803b270 <UTIL_TIMER_Init>
  DBG_Disable();
 802c4fa:	f000 f8be 	bl	802c67a <DBG_Disable>
  DBG_ProbesInit();
 802c4fe:	f000 f8bf 	bl	802c680 <DBG_ProbesInit>
  UTIL_ADV_TRACE_Init();
 802c502:	f00e fb93 	bl	803ac2c <UTIL_ADV_TRACE_Init>
  UTIL_ADV_TRACE_RegisterTimeStampFunction(TimestampNow);
 802c506:	480d      	ldr	r0, [pc, #52]	; (802c53c <SystemApp_Init+0x54>)
 802c508:	f00e fbaa 	bl	803ac60 <UTIL_ADV_TRACE_RegisterTimeStampFunction>
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPTVERR);
 802c50c:	4b0c      	ldr	r3, [pc, #48]	; (802c540 <SystemApp_Init+0x58>)
 802c50e:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 802c512:	611a      	str	r2, [r3, #16]
  UTIL_ADV_TRACE_SetVerboseLevel(VERBOSE_LEVEL);
 802c514:	2003      	movs	r0, #3
 802c516:	f00e fba9 	bl	803ac6c <UTIL_ADV_TRACE_SetVerboseLevel>
  SYS_InitMeasurement();
 802c51a:	f7ff fd0f 	bl	802bf3c <SYS_InitMeasurement>
  EnvSensors_Init();
 802c51e:	f000 f8b9 	bl	802c694 <EnvSensors_Init>
  UTIL_LPM_Init();
 802c522:	f00e fca1 	bl	803ae68 <UTIL_LPM_Init>
  UTIL_LPM_SetOffMode((1 << CFG_LPM_APPLI_Id), UTIL_LPM_DISABLE);
 802c526:	2101      	movs	r1, #1
 802c528:	4608      	mov	r0, r1
 802c52a:	f00e fcbb 	bl	803aea4 <UTIL_LPM_SetOffMode>
  UTIL_LPM_SetStopMode((1 << CFG_LPM_APPLI_Id), UTIL_LPM_DISABLE);
 802c52e:	2101      	movs	r1, #1
}
 802c530:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  UTIL_LPM_SetStopMode((1 << CFG_LPM_APPLI_Id), UTIL_LPM_DISABLE);
 802c534:	4608      	mov	r0, r1
 802c536:	f00e bc9f 	b.w	803ae78 <UTIL_LPM_SetStopMode>
 802c53a:	bf00      	nop
 802c53c:	0802c4b9 	.word	0x0802c4b9
 802c540:	58004000 	.word	0x58004000

0802c544 <UTIL_SEQ_Idle>:
  UTIL_LPM_EnterLowPower();
 802c544:	f00e bcc4 	b.w	803aed0 <UTIL_LPM_EnterLowPower>

0802c548 <GetBatteryLevel>:
{
 802c548:	b513      	push	{r0, r1, r4, lr}
  batteryLevelmV = (uint16_t) SYS_GetBatteryLevel();
 802c54a:	f7ff fcff 	bl	802bf4c <SYS_GetBatteryLevel>
  if (batteryLevelmV > VDD_BAT)
 802c54e:	f640 33b8 	movw	r3, #3000	; 0xbb8
 802c552:	4298      	cmp	r0, r3
 802c554:	d815      	bhi.n	802c582 <GetBatteryLevel+0x3a>
  else if (batteryLevelmV < VDD_MIN)
 802c556:	f5b0 6fe1 	cmp.w	r0, #1800	; 0x708
 802c55a:	d314      	bcc.n	802c586 <GetBatteryLevel+0x3e>
    batteryLevel = (((uint32_t)(batteryLevelmV - VDD_MIN) * LORAWAN_MAX_BAT) / (VDD_BAT - VDD_MIN));
 802c55c:	f5a0 60e1 	sub.w	r0, r0, #1800	; 0x708
 802c560:	24fe      	movs	r4, #254	; 0xfe
 802c562:	4344      	muls	r4, r0
 802c564:	f44f 6396 	mov.w	r3, #1200	; 0x4b0
 802c568:	fbb4 f4f3 	udiv	r4, r4, r3
 802c56c:	b2e4      	uxtb	r4, r4
  APP_LOG(TS_ON, VLEVEL_M, "VDDA= %d\r\n", batteryLevel);
 802c56e:	4b07      	ldr	r3, [pc, #28]	; (802c58c <GetBatteryLevel+0x44>)
 802c570:	9400      	str	r4, [sp, #0]
 802c572:	2201      	movs	r2, #1
 802c574:	2100      	movs	r1, #0
 802c576:	2002      	movs	r0, #2
 802c578:	f00e fbc0 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
}
 802c57c:	4620      	mov	r0, r4
 802c57e:	b002      	add	sp, #8
 802c580:	bd10      	pop	{r4, pc}
    batteryLevel = LORAWAN_MAX_BAT;
 802c582:	24fe      	movs	r4, #254	; 0xfe
 802c584:	e7f3      	b.n	802c56e <GetBatteryLevel+0x26>
    batteryLevel = 0;
 802c586:	2400      	movs	r4, #0
 802c588:	e7f1      	b.n	802c56e <GetBatteryLevel+0x26>
 802c58a:	bf00      	nop
 802c58c:	0803bd9c 	.word	0x0803bd9c

0802c590 <GetTemperatureLevel>:
{
 802c590:	b508      	push	{r3, lr}
  temperatureLevel = (uint16_t)(SYS_GetTemperatureLevel() / 256);
 802c592:	f7ff fcf5 	bl	802bf80 <SYS_GetTemperatureLevel>
 802c596:	2800      	cmp	r0, #0
 802c598:	bfb8      	it	lt
 802c59a:	30ff      	addlt	r0, #255	; 0xff
}
 802c59c:	f3c0 200f 	ubfx	r0, r0, #8, #16
 802c5a0:	bd08      	pop	{r3, pc}
	...

0802c5a4 <GetUniqueId>:
{
 802c5a4:	b538      	push	{r3, r4, r5, lr}
  * @brief  Return the Unique Device Number
  * @retval Values between Min_Data=0x00000000 and Max_Data=0xFFFFFFFF
  */
__STATIC_INLINE uint32_t LL_FLASH_GetUDN(void)
{
  return (READ_REG(*((uint32_t *)UID64_BASE)));
 802c5a6:	4b17      	ldr	r3, [pc, #92]	; (802c604 <GetUniqueId+0x60>)
 802c5a8:	681b      	ldr	r3, [r3, #0]
  if (val == 0xFFFFFFFF)  /* Normally this should not happen */
 802c5aa:	1c5a      	adds	r2, r3, #1
{
 802c5ac:	4604      	mov	r4, r0
  if (val == 0xFFFFFFFF)  /* Normally this should not happen */
 802c5ae:	d116      	bne.n	802c5de <GetUniqueId+0x3a>
    uint32_t ID_1_3_val = HAL_GetUIDw0() + HAL_GetUIDw2();
 802c5b0:	f000 ff8c 	bl	802d4cc <HAL_GetUIDw0>
 802c5b4:	4605      	mov	r5, r0
 802c5b6:	f000 ff95 	bl	802d4e4 <HAL_GetUIDw2>
 802c5ba:	4405      	add	r5, r0
    uint32_t ID_2_val = HAL_GetUIDw1();
 802c5bc:	f000 ff8c 	bl	802d4d8 <HAL_GetUIDw1>
    id[7] = (ID_1_3_val) >> 24;
 802c5c0:	0e2b      	lsrs	r3, r5, #24
 802c5c2:	71e3      	strb	r3, [r4, #7]
    id[6] = (ID_1_3_val) >> 16;
 802c5c4:	0c2b      	lsrs	r3, r5, #16
 802c5c6:	71a3      	strb	r3, [r4, #6]
    id[5] = (ID_1_3_val) >> 8;
 802c5c8:	0a2b      	lsrs	r3, r5, #8
 802c5ca:	7163      	strb	r3, [r4, #5]
    id[3] = (ID_2_val) >> 24;
 802c5cc:	0e03      	lsrs	r3, r0, #24
 802c5ce:	70e3      	strb	r3, [r4, #3]
    id[2] = (ID_2_val) >> 16;
 802c5d0:	0c03      	lsrs	r3, r0, #16
 802c5d2:	70a3      	strb	r3, [r4, #2]
    id[1] = (ID_2_val) >> 8;
 802c5d4:	0a03      	lsrs	r3, r0, #8
    id[4] = (ID_1_3_val);
 802c5d6:	7125      	strb	r5, [r4, #4]
    id[1] = (ID_2_val) >> 8;
 802c5d8:	7063      	strb	r3, [r4, #1]
    id[0] = (ID_2_val);
 802c5da:	7020      	strb	r0, [r4, #0]
}
 802c5dc:	bd38      	pop	{r3, r4, r5, pc}
    id[6] = (val >> 8) & 0xFF;
 802c5de:	0a1a      	lsrs	r2, r3, #8
    id[7] = val & 0xFF;
 802c5e0:	71c3      	strb	r3, [r0, #7]
    id[6] = (val >> 8) & 0xFF;
 802c5e2:	7182      	strb	r2, [r0, #6]
    id[5] = (val >> 16) & 0xFF;
 802c5e4:	0c1a      	lsrs	r2, r3, #16
    id[4] = (val >> 24) & 0xFF;
 802c5e6:	0e1b      	lsrs	r3, r3, #24
 802c5e8:	7103      	strb	r3, [r0, #4]
  *         For STM32WLxxxx devices, the device ID is 0x15
  * @retval Values between Min_Data=0x00 and Max_Data=0xFF (ex: Device ID is 0x15)
  */
__STATIC_INLINE uint32_t LL_FLASH_GetDeviceID(void)
{
  return ((READ_REG(*((uint32_t *)UID64_BASE + 1U))) & 0x000000FFU);
 802c5ea:	4b07      	ldr	r3, [pc, #28]	; (802c608 <GetUniqueId+0x64>)
    id[5] = (val >> 16) & 0xFF;
 802c5ec:	7142      	strb	r2, [r0, #5]
    id[3] = val & 0xFF;
 802c5ee:	681a      	ldr	r2, [r3, #0]
 802c5f0:	70c2      	strb	r2, [r0, #3]
  * @note   For STM32WLxxxx devices, the ST Company ID is 0x0080E1
  * @retval Values between Min_Data=0x00 and Max_Data=0xFFFFFF (ex: ST Company ID is 0x0080E1)
  */
__STATIC_INLINE uint32_t LL_FLASH_GetSTCompanyID(void)
{
  return (((READ_REG(*((uint32_t *)UID64_BASE + 1U))) >> 8U) & 0x00FFFFFFU);
 802c5f2:	681b      	ldr	r3, [r3, #0]
 802c5f4:	0a1a      	lsrs	r2, r3, #8
    id[2] = val & 0xFF;
 802c5f6:	7082      	strb	r2, [r0, #2]
    id[1] = (val >> 8) & 0xFF;
 802c5f8:	0c1a      	lsrs	r2, r3, #16
    id[0] = (val >> 16) & 0xFF;
 802c5fa:	0e1b      	lsrs	r3, r3, #24
    id[1] = (val >> 8) & 0xFF;
 802c5fc:	7042      	strb	r2, [r0, #1]
    id[0] = (val >> 16) & 0xFF;
 802c5fe:	7003      	strb	r3, [r0, #0]
}
 802c600:	e7ec      	b.n	802c5dc <GetUniqueId+0x38>
 802c602:	bf00      	nop
 802c604:	1fff7580 	.word	0x1fff7580
 802c608:	1fff7584 	.word	0x1fff7584

0802c60c <GetDevAddr>:
  return (READ_REG(*((uint32_t *)UID64_BASE)));
 802c60c:	4b07      	ldr	r3, [pc, #28]	; (802c62c <GetDevAddr+0x20>)
 802c60e:	6818      	ldr	r0, [r3, #0]
  if (val == 0xFFFFFFFF)
 802c610:	1c43      	adds	r3, r0, #1
{
 802c612:	b510      	push	{r4, lr}
  if (val == 0xFFFFFFFF)
 802c614:	d108      	bne.n	802c628 <GetDevAddr+0x1c>
    val = ((HAL_GetUIDw0()) ^ (HAL_GetUIDw1()) ^ (HAL_GetUIDw2()));
 802c616:	f000 ff59 	bl	802d4cc <HAL_GetUIDw0>
 802c61a:	4604      	mov	r4, r0
 802c61c:	f000 ff5c 	bl	802d4d8 <HAL_GetUIDw1>
 802c620:	4044      	eors	r4, r0
 802c622:	f000 ff5f 	bl	802d4e4 <HAL_GetUIDw2>
 802c626:	4060      	eors	r0, r4
}
 802c628:	bd10      	pop	{r4, pc}
 802c62a:	bf00      	nop
 802c62c:	1fff7580 	.word	0x1fff7580

0802c630 <UTIL_ADV_TRACE_PreSendHook>:
  UTIL_LPM_SetStopMode((1 << CFG_LPM_UART_TX_Id), UTIL_LPM_DISABLE);
 802c630:	2101      	movs	r1, #1
 802c632:	2002      	movs	r0, #2
 802c634:	f00e bc20 	b.w	803ae78 <UTIL_LPM_SetStopMode>

0802c638 <UTIL_ADV_TRACE_PostSendHook>:
  UTIL_LPM_SetStopMode((1 << CFG_LPM_UART_TX_Id), UTIL_LPM_ENABLE);
 802c638:	2100      	movs	r1, #0
 802c63a:	2002      	movs	r0, #2
 802c63c:	f00e bc1c 	b.w	803ae78 <UTIL_LPM_SetStopMode>

0802c640 <HAL_InitTick>:
  /* USER CODE END HAL_InitTick_1 */
  return HAL_OK;
  /* USER CODE BEGIN HAL_InitTick_2 */

  /* USER CODE END HAL_InitTick_2 */
}
 802c640:	2000      	movs	r0, #0
 802c642:	4770      	bx	lr

0802c644 <HAL_GetTick>:
{
  /* TIMER_IF can be based on other counter the SysTick e.g. RTC */
  /* USER CODE BEGIN HAL_GetTick_1 */

  /* USER CODE END HAL_GetTick_1 */
  return TIMER_IF_GetTimerValue();
 802c644:	f000 b844 	b.w	802c6d0 <TIMER_IF_GetTimerValue>

0802c648 <HAL_Delay>:

/**
  * @note This function overwrites the __weak one from HAL
  */
void HAL_Delay(__IO uint32_t Delay)
{
 802c648:	b082      	sub	sp, #8
 802c64a:	9001      	str	r0, [sp, #4]
  /* TIMER_IF can be based on other counter the SysTick e.g. RTC */
  /* USER CODE BEGIN HAL_Delay_1 */

  /* USER CODE END HAL_Delay_1 */
  TIMER_IF_DelayMs(Delay);
 802c64c:	9801      	ldr	r0, [sp, #4]
  /* USER CODE BEGIN HAL_Delay_2 */

  /* USER CODE END HAL_Delay_2 */
}
 802c64e:	b002      	add	sp, #8
  TIMER_IF_DelayMs(Delay);
 802c650:	f000 b8f8 	b.w	802c844 <TIMER_IF_DelayMs>

0802c654 <DBG_ConfigForLpm>:
  enable_dbg = 0;
#elif !defined (DEBUGGER_ENABLED)
#error "DEBUGGER_ENABLED not defined or out of range <0,1>"
#endif /* DEBUGGER_OFF */

  if (enable_dbg == 1)
 802c654:	2801      	cmp	r0, #1
{
 802c656:	b508      	push	{r3, lr}
  if (enable_dbg == 1)
 802c658:	d107      	bne.n	802c66a <DBG_ConfigForLpm+0x16>
  {
    HAL_DBGMCU_EnableDBGSleepMode();
 802c65a:	f000 ff49 	bl	802d4f0 <HAL_DBGMCU_EnableDBGSleepMode>
    HAL_DBGMCU_EnableDBGStopMode();
 802c65e:	f000 ff57 	bl	802d510 <HAL_DBGMCU_EnableDBGStopMode>
  }

  /* USER CODE BEGIN DBG_ConfigForLpm_Last */

  /* USER CODE END DBG_ConfigForLpm_Last */
}
 802c662:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    HAL_DBGMCU_EnableDBGStandbyMode();
 802c666:	f000 bf63 	b.w	802d530 <HAL_DBGMCU_EnableDBGStandbyMode>
    HAL_DBGMCU_DisableDBGSleepMode();
 802c66a:	f000 ff49 	bl	802d500 <HAL_DBGMCU_DisableDBGSleepMode>
    HAL_DBGMCU_DisableDBGStopMode();
 802c66e:	f000 ff57 	bl	802d520 <HAL_DBGMCU_DisableDBGStopMode>
}
 802c672:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    HAL_DBGMCU_DisableDBGStandbyMode();
 802c676:	f000 bf63 	b.w	802d540 <HAL_DBGMCU_DisableDBGStandbyMode>

0802c67a <DBG_Disable>:
  DBG_ConfigForLpm(0);
 802c67a:	2000      	movs	r0, #0
 802c67c:	f7ff bfea 	b.w	802c654 <DBG_ConfigForLpm>

0802c680 <DBG_ProbesInit>:
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_EnableIT_32_63(uint32_t ExtiLine)
{
  SET_BIT(EXTI->IMR2, ExtiLine);
 802c680:	4a03      	ldr	r2, [pc, #12]	; (802c690 <DBG_ProbesInit+0x10>)
 802c682:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 802c686:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 802c68a:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
#endif /* CORE_CM4 */

  /* USER CODE BEGIN DBG_ProbesInit_Last */

  /* USER CODE END DBG_ProbesInit_Last */
}
 802c68e:	4770      	bx	lr
 802c690:	58000800 	.word	0x58000800

0802c694 <EnvSensors_Init>:
#elif !defined (SENSOR_ENABLED)
#error SENSOR_ENABLED not defined
#endif /* SENSOR_ENABLED  */
  return 0;
  /* USER CODE END EnvSensors_Init */
}
 802c694:	2000      	movs	r0, #0
 802c696:	4770      	bx	lr

0802c698 <TIMER_IF_SetTimerContext>:
  * @retval If binary mode is none, Value between Min_Data=0x0 and Max_Data=0x7FFF
  *         else Value between Min_Data=0x0 and Max_Data=0xFFFFFFFF
  */
__STATIC_INLINE uint32_t LL_RTC_TIME_GetSubSecond(RTC_TypeDef *RTCx)
{
  return (uint32_t)(READ_BIT(RTCx->SSR, RTC_SSR_SS));
 802c698:	4b02      	ldr	r3, [pc, #8]	; (802c6a4 <TIMER_IF_SetTimerContext+0xc>)
 802c69a:	6898      	ldr	r0, [r3, #8]
}

uint32_t TIMER_IF_SetTimerContext(void)
{
  /*store time context*/
  RtcTimerContext = GetTimerTicks();
 802c69c:	4b02      	ldr	r3, [pc, #8]	; (802c6a8 <TIMER_IF_SetTimerContext+0x10>)
static inline uint32_t GetTimerTicks(void)
{
  /* USER CODE BEGIN GetTimerTicks */

  /* USER CODE END GetTimerTicks */
  return (UINT32_MAX - LL_RTC_TIME_GetSubSecond(RTC));
 802c69e:	43c0      	mvns	r0, r0
  RtcTimerContext = GetTimerTicks();
 802c6a0:	6018      	str	r0, [r3, #0]
}
 802c6a2:	4770      	bx	lr
 802c6a4:	40002800 	.word	0x40002800
 802c6a8:	200035c8 	.word	0x200035c8

0802c6ac <TIMER_IF_GetTimerContext>:
}
 802c6ac:	4b01      	ldr	r3, [pc, #4]	; (802c6b4 <TIMER_IF_GetTimerContext+0x8>)
 802c6ae:	6818      	ldr	r0, [r3, #0]
 802c6b0:	4770      	bx	lr
 802c6b2:	bf00      	nop
 802c6b4:	200035c8 	.word	0x200035c8

0802c6b8 <TIMER_IF_GetTimerElapsedTime>:
 802c6b8:	4b03      	ldr	r3, [pc, #12]	; (802c6c8 <TIMER_IF_GetTimerElapsedTime+0x10>)
  ret = ((uint32_t)(GetTimerTicks() - RtcTimerContext));
 802c6ba:	4a04      	ldr	r2, [pc, #16]	; (802c6cc <TIMER_IF_GetTimerElapsedTime+0x14>)
 802c6bc:	689b      	ldr	r3, [r3, #8]
 802c6be:	6810      	ldr	r0, [r2, #0]
  return (UINT32_MAX - LL_RTC_TIME_GetSubSecond(RTC));
 802c6c0:	43db      	mvns	r3, r3
}
 802c6c2:	1a18      	subs	r0, r3, r0
 802c6c4:	4770      	bx	lr
 802c6c6:	bf00      	nop
 802c6c8:	40002800 	.word	0x40002800
 802c6cc:	200035c8 	.word	0x200035c8

0802c6d0 <TIMER_IF_GetTimerValue>:
  if (RTC_Initialized == true)
 802c6d0:	4b03      	ldr	r3, [pc, #12]	; (802c6e0 <TIMER_IF_GetTimerValue+0x10>)
 802c6d2:	7918      	ldrb	r0, [r3, #4]
 802c6d4:	b110      	cbz	r0, 802c6dc <TIMER_IF_GetTimerValue+0xc>
 802c6d6:	4b03      	ldr	r3, [pc, #12]	; (802c6e4 <TIMER_IF_GetTimerValue+0x14>)
 802c6d8:	6898      	ldr	r0, [r3, #8]
  return (UINT32_MAX - LL_RTC_TIME_GetSubSecond(RTC));
 802c6da:	43c0      	mvns	r0, r0
}
 802c6dc:	4770      	bx	lr
 802c6de:	bf00      	nop
 802c6e0:	200035c8 	.word	0x200035c8
 802c6e4:	40002800 	.word	0x40002800

0802c6e8 <TIMER_IF_GetMinimumTimeout>:
}
 802c6e8:	2003      	movs	r0, #3
 802c6ea:	4770      	bx	lr

0802c6ec <TIMER_IF_Convert_ms2Tick>:
{
 802c6ec:	b508      	push	{r3, lr}
 802c6ee:	4601      	mov	r1, r0
  ret = ((uint32_t)((((uint64_t) timeMilliSec) << RTC_N_PREDIV_S) / 1000));
 802c6f0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 802c6f4:	2300      	movs	r3, #0
 802c6f6:	0280      	lsls	r0, r0, #10
 802c6f8:	0d89      	lsrs	r1, r1, #22
 802c6fa:	f7ff fa23 	bl	802bb44 <__aeabi_uldivmod>
}
 802c6fe:	bd08      	pop	{r3, pc}

0802c700 <TIMER_IF_Convert_Tick2ms>:
  ret = ((uint32_t)((((uint64_t)(tick)) * 1000) >> RTC_N_PREDIV_S));
 802c700:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 802c704:	fba0 2302 	umull	r2, r3, r0, r2
 802c708:	0a90      	lsrs	r0, r2, #10
}
 802c70a:	ea40 5083 	orr.w	r0, r0, r3, lsl #22
 802c70e:	4770      	bx	lr

0802c710 <TIMER_IF_StopTimer>:
{
 802c710:	b510      	push	{r4, lr}
  __HAL_RTC_ALARM_CLEAR_FLAG(&hrtc, RTC_FLAG_ALRAF);
 802c712:	4b07      	ldr	r3, [pc, #28]	; (802c730 <TIMER_IF_StopTimer+0x20>)
  HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_A);
 802c714:	4c07      	ldr	r4, [pc, #28]	; (802c734 <TIMER_IF_StopTimer+0x24>)
  __HAL_RTC_ALARM_CLEAR_FLAG(&hrtc, RTC_FLAG_ALRAF);
 802c716:	2201      	movs	r2, #1
 802c718:	65da      	str	r2, [r3, #92]	; 0x5c
  HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_A);
 802c71a:	f44f 7180 	mov.w	r1, #256	; 0x100
 802c71e:	4620      	mov	r0, r4
 802c720:	f002 fe3a 	bl	802f398 <HAL_RTC_DeactivateAlarm>
  hrtc.IsEnabled.RtcFeatures = UINT32_MAX;
 802c724:	f04f 33ff 	mov.w	r3, #4294967295
 802c728:	6323      	str	r3, [r4, #48]	; 0x30
}
 802c72a:	2000      	movs	r0, #0
 802c72c:	bd10      	pop	{r4, pc}
 802c72e:	bf00      	nop
 802c730:	40002800 	.word	0x40002800
 802c734:	200061b8 	.word	0x200061b8

0802c738 <TIMER_IF_BkUp_Write_Seconds>:
{
 802c738:	4602      	mov	r2, r0
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_SECONDS, Seconds);
 802c73a:	2100      	movs	r1, #0
 802c73c:	4801      	ldr	r0, [pc, #4]	; (802c744 <TIMER_IF_BkUp_Write_Seconds+0xc>)
 802c73e:	f003 b840 	b.w	802f7c2 <HAL_RTCEx_BKUPWrite>
 802c742:	bf00      	nop
 802c744:	200061b8 	.word	0x200061b8

0802c748 <TIMER_IF_BkUp_Write_SubSeconds>:
{
 802c748:	4602      	mov	r2, r0
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_SUBSECONDS, SubSeconds);
 802c74a:	2101      	movs	r1, #1
 802c74c:	4801      	ldr	r0, [pc, #4]	; (802c754 <TIMER_IF_BkUp_Write_SubSeconds+0xc>)
 802c74e:	f003 b838 	b.w	802f7c2 <HAL_RTCEx_BKUPWrite>
 802c752:	bf00      	nop
 802c754:	200061b8 	.word	0x200061b8

0802c758 <TIMER_IF_StartTimer>:
{
 802c758:	b510      	push	{r4, lr}
 802c75a:	b08c      	sub	sp, #48	; 0x30
  RTC_AlarmTypeDef sAlarm = {0};
 802c75c:	222c      	movs	r2, #44	; 0x2c
 802c75e:	2100      	movs	r1, #0
{
 802c760:	4604      	mov	r4, r0
  RTC_AlarmTypeDef sAlarm = {0};
 802c762:	a801      	add	r0, sp, #4
 802c764:	f00f f810 	bl	803b788 <memset>
  TIMER_IF_StopTimer();
 802c768:	f7ff ffd2 	bl	802c710 <TIMER_IF_StopTimer>
  timeout += RtcTimerContext;
 802c76c:	4b0c      	ldr	r3, [pc, #48]	; (802c7a0 <TIMER_IF_StartTimer+0x48>)
 802c76e:	6818      	ldr	r0, [r3, #0]
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
 802c770:	2300      	movs	r3, #0
  timeout += RtcTimerContext;
 802c772:	4404      	add	r4, r0
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
 802c774:	9308      	str	r3, [sp, #32]
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
 802c776:	9306      	str	r3, [sp, #24]
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDBINMASK_NONE;
 802c778:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
  sAlarm.AlarmTime.SubSeconds = UINT32_MAX - timeout;
 802c77c:	43e4      	mvns	r4, r4
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDBINMASK_NONE;
 802c77e:	9307      	str	r3, [sp, #28]
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 802c780:	4808      	ldr	r0, [pc, #32]	; (802c7a4 <TIMER_IF_StartTimer+0x4c>)
  sAlarm.AlarmTime.SubSeconds = UINT32_MAX - timeout;
 802c782:	9402      	str	r4, [sp, #8]
  sAlarm.Alarm = RTC_ALARM_A;
 802c784:	f44f 7380 	mov.w	r3, #256	; 0x100
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 802c788:	2201      	movs	r2, #1
 802c78a:	a901      	add	r1, sp, #4
  sAlarm.Alarm = RTC_ALARM_A;
 802c78c:	930b      	str	r3, [sp, #44]	; 0x2c
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 802c78e:	f002 ff19 	bl	802f5c4 <HAL_RTC_SetAlarm_IT>
 802c792:	b108      	cbz	r0, 802c798 <TIMER_IF_StartTimer+0x40>
    Error_Handler();
 802c794:	f7ff fd8e 	bl	802c2b4 <Error_Handler>
}
 802c798:	2000      	movs	r0, #0
 802c79a:	b00c      	add	sp, #48	; 0x30
 802c79c:	bd10      	pop	{r4, pc}
 802c79e:	bf00      	nop
 802c7a0:	200035c8 	.word	0x200035c8
 802c7a4:	200061b8 	.word	0x200061b8

0802c7a8 <TIMER_IF_GetTime>:
 802c7a8:	4b0c      	ldr	r3, [pc, #48]	; (802c7dc <TIMER_IF_GetTime+0x34>)
{
 802c7aa:	b570      	push	{r4, r5, r6, lr}
 802c7ac:	689c      	ldr	r4, [r3, #8]
 802c7ae:	4606      	mov	r6, r0
  MSBticks = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_MSBTICKS);
 802c7b0:	2102      	movs	r1, #2
 802c7b2:	480b      	ldr	r0, [pc, #44]	; (802c7e0 <TIMER_IF_GetTime+0x38>)
 802c7b4:	f003 f80c 	bl	802f7d0 <HAL_RTCEx_BKUPRead>
  return (UINT32_MAX - LL_RTC_TIME_GetSubSecond(RTC));
 802c7b8:	43e4      	mvns	r4, r4
  ticks = (((uint64_t) timerValueMSB) << 32) + timerValueLsb;
 802c7ba:	2200      	movs	r2, #0
 802c7bc:	1912      	adds	r2, r2, r4
  ticks = (uint32_t) ticks & RTC_PREDIV_S;
 802c7be:	f3c2 0409 	ubfx	r4, r2, #0, #10
  ret = ((uint32_t)((((uint64_t)(tick)) * 1000) >> RTC_N_PREDIV_S));
 802c7c2:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 802c7c6:	fba4 4501 	umull	r4, r5, r4, r1
  ticks = (((uint64_t) timerValueMSB) << 32) + timerValueLsb;
 802c7ca:	f140 0300 	adc.w	r3, r0, #0
  ret = ((uint32_t)((((uint64_t)(tick)) * 1000) >> RTC_N_PREDIV_S));
 802c7ce:	0aa4      	lsrs	r4, r4, #10
  seconds = (uint32_t)(ticks >> RTC_N_PREDIV_S);
 802c7d0:	0a90      	lsrs	r0, r2, #10
  *mSeconds = TIMER_IF_Convert_Tick2ms(ticks);
 802c7d2:	8034      	strh	r4, [r6, #0]
}
 802c7d4:	ea40 5083 	orr.w	r0, r0, r3, lsl #22
 802c7d8:	bd70      	pop	{r4, r5, r6, pc}
 802c7da:	bf00      	nop
 802c7dc:	40002800 	.word	0x40002800
 802c7e0:	200061b8 	.word	0x200061b8

0802c7e4 <TIMER_IF_BkUp_Read_Seconds>:
  ret = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_SECONDS);
 802c7e4:	4801      	ldr	r0, [pc, #4]	; (802c7ec <TIMER_IF_BkUp_Read_Seconds+0x8>)
 802c7e6:	2100      	movs	r1, #0
 802c7e8:	f002 bff2 	b.w	802f7d0 <HAL_RTCEx_BKUPRead>
 802c7ec:	200061b8 	.word	0x200061b8

0802c7f0 <TIMER_IF_BkUp_Read_SubSeconds>:
  ret = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_SUBSECONDS);
 802c7f0:	4801      	ldr	r0, [pc, #4]	; (802c7f8 <TIMER_IF_BkUp_Read_SubSeconds+0x8>)
 802c7f2:	2101      	movs	r1, #1
 802c7f4:	f002 bfec 	b.w	802f7d0 <HAL_RTCEx_BKUPRead>
 802c7f8:	200061b8 	.word	0x200061b8

0802c7fc <TIMER_IF_Init>:
{
 802c7fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (RTC_Initialized == false)
 802c7fe:	4d0f      	ldr	r5, [pc, #60]	; (802c83c <TIMER_IF_Init+0x40>)
 802c800:	792e      	ldrb	r6, [r5, #4]
 802c802:	b9ce      	cbnz	r6, 802c838 <TIMER_IF_Init+0x3c>
    hrtc.IsEnabled.RtcFeatures = UINT32_MAX;
 802c804:	4c0e      	ldr	r4, [pc, #56]	; (802c840 <TIMER_IF_Init+0x44>)
 802c806:	f04f 37ff 	mov.w	r7, #4294967295
 802c80a:	6327      	str	r7, [r4, #48]	; 0x30
    MX_RTC_Init();
 802c80c:	f7ff fd54 	bl	802c2b8 <MX_RTC_Init>
    TIMER_IF_StopTimer();
 802c810:	f7ff ff7e 	bl	802c710 <TIMER_IF_StopTimer>
    HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_A);
 802c814:	f44f 7180 	mov.w	r1, #256	; 0x100
 802c818:	4620      	mov	r0, r4
 802c81a:	f002 fdbd 	bl	802f398 <HAL_RTC_DeactivateAlarm>
    HAL_RTCEx_EnableBypassShadow(&hrtc);
 802c81e:	4620      	mov	r0, r4
    hrtc.IsEnabled.RtcFeatures = UINT32_MAX;
 802c820:	6327      	str	r7, [r4, #48]	; 0x30
    HAL_RTCEx_EnableBypassShadow(&hrtc);
 802c822:	f002 ff79 	bl	802f718 <HAL_RTCEx_EnableBypassShadow>
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_MSBTICKS, MSBticks);
 802c826:	4632      	mov	r2, r6
 802c828:	2102      	movs	r1, #2
 802c82a:	4620      	mov	r0, r4
 802c82c:	f002 ffc9 	bl	802f7c2 <HAL_RTCEx_BKUPWrite>
    TIMER_IF_SetTimerContext();
 802c830:	f7ff ff32 	bl	802c698 <TIMER_IF_SetTimerContext>
    RTC_Initialized = true;
 802c834:	2301      	movs	r3, #1
 802c836:	712b      	strb	r3, [r5, #4]
}
 802c838:	2000      	movs	r0, #0
 802c83a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802c83c:	200035c8 	.word	0x200035c8
 802c840:	200061b8 	.word	0x200061b8

0802c844 <TIMER_IF_DelayMs>:
{
 802c844:	4601      	mov	r1, r0
 802c846:	b508      	push	{r3, lr}
  ret = ((uint32_t)((((uint64_t) timeMilliSec) << RTC_N_PREDIV_S) / 1000));
 802c848:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 802c84c:	2300      	movs	r3, #0
 802c84e:	0280      	lsls	r0, r0, #10
 802c850:	0d89      	lsrs	r1, r1, #22
 802c852:	f7ff f977 	bl	802bb44 <__aeabi_uldivmod>
 802c856:	4a05      	ldr	r2, [pc, #20]	; (802c86c <TIMER_IF_DelayMs+0x28>)
 802c858:	6891      	ldr	r1, [r2, #8]
  return (UINT32_MAX - LL_RTC_TIME_GetSubSecond(RTC));
 802c85a:	43c9      	mvns	r1, r1
 802c85c:	6893      	ldr	r3, [r2, #8]
 802c85e:	43db      	mvns	r3, r3
  while (((GetTimerTicks() - timeout)) < delayTicks)
 802c860:	1a5b      	subs	r3, r3, r1
 802c862:	4283      	cmp	r3, r0
 802c864:	d300      	bcc.n	802c868 <TIMER_IF_DelayMs+0x24>
}
 802c866:	bd08      	pop	{r3, pc}
    __NOP();
 802c868:	bf00      	nop
 802c86a:	e7f7      	b.n	802c85c <TIMER_IF_DelayMs+0x18>
 802c86c:	40002800 	.word	0x40002800

0802c870 <HAL_RTC_AlarmAEventCallback>:
  UTIL_TIMER_IRQ_MAP_PROCESS();
 802c870:	f00e be08 	b.w	803b484 <UTIL_TIMER_IRQ_Handler>

0802c874 <HAL_RTCEx_SSRUEventCallback>:
{
 802c874:	b510      	push	{r4, lr}
  MSBticks = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_MSBTICKS);
 802c876:	4c06      	ldr	r4, [pc, #24]	; (802c890 <HAL_RTCEx_SSRUEventCallback+0x1c>)
 802c878:	2102      	movs	r1, #2
 802c87a:	4620      	mov	r0, r4
 802c87c:	f002 ffa8 	bl	802f7d0 <HAL_RTCEx_BKUPRead>
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_MSBTICKS, MSBticks);
 802c880:	2102      	movs	r1, #2
 802c882:	1c42      	adds	r2, r0, #1
 802c884:	4620      	mov	r0, r4
}
 802c886:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_MSBTICKS, MSBticks);
 802c88a:	f002 bf9a 	b.w	802f7c2 <HAL_RTCEx_BKUPWrite>
 802c88e:	bf00      	nop
 802c890:	200061b8 	.word	0x200061b8

0802c894 <MX_USART2_UART_Init>:
  /* USER CODE END USART2_Init 0 */

  /* USER CODE BEGIN USART2_Init 1 */

  /* USER CODE END USART2_Init 1 */
  huart2.Instance = USART2;
 802c894:	4816      	ldr	r0, [pc, #88]	; (802c8f0 <MX_USART2_UART_Init+0x5c>)
  huart2.Init.BaudRate = 115200;
 802c896:	4a17      	ldr	r2, [pc, #92]	; (802c8f4 <MX_USART2_UART_Init+0x60>)
{
 802c898:	b508      	push	{r3, lr}
  huart2.Init.BaudRate = 115200;
 802c89a:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
 802c89e:	e9c0 2300 	strd	r2, r3, [r0]
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 802c8a2:	2300      	movs	r3, #0
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
 802c8a4:	220c      	movs	r2, #12
  huart2.Init.StopBits = UART_STOPBITS_1;
 802c8a6:	e9c0 3302 	strd	r3, r3, [r0, #8]
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 802c8aa:	e9c0 2305 	strd	r2, r3, [r0, #20]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 802c8ae:	e9c0 3307 	strd	r3, r3, [r0, #28]
  huart2.Init.ClockPrescaler = UART_PRESCALER_DIV1;
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 802c8b2:	e9c0 3309 	strd	r3, r3, [r0, #36]	; 0x24
  huart2.Init.Parity = UART_PARITY_NONE;
 802c8b6:	6103      	str	r3, [r0, #16]
  if (HAL_UART_Init(&huart2) != HAL_OK)
 802c8b8:	f004 f8a8 	bl	8030a0c <HAL_UART_Init>
 802c8bc:	b108      	cbz	r0, 802c8c2 <MX_USART2_UART_Init+0x2e>
  {
    Error_Handler();
 802c8be:	f7ff fcf9 	bl	802c2b4 <Error_Handler>
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart2, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
 802c8c2:	480b      	ldr	r0, [pc, #44]	; (802c8f0 <MX_USART2_UART_Init+0x5c>)
 802c8c4:	2100      	movs	r1, #0
 802c8c6:	f004 fa28 	bl	8030d1a <HAL_UARTEx_SetTxFifoThreshold>
 802c8ca:	b108      	cbz	r0, 802c8d0 <MX_USART2_UART_Init+0x3c>
  {
    Error_Handler();
 802c8cc:	f7ff fcf2 	bl	802c2b4 <Error_Handler>
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart2, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
 802c8d0:	4807      	ldr	r0, [pc, #28]	; (802c8f0 <MX_USART2_UART_Init+0x5c>)
 802c8d2:	2100      	movs	r1, #0
 802c8d4:	f004 fa45 	bl	8030d62 <HAL_UARTEx_SetRxFifoThreshold>
 802c8d8:	b108      	cbz	r0, 802c8de <MX_USART2_UART_Init+0x4a>
  {
    Error_Handler();
 802c8da:	f7ff fceb 	bl	802c2b4 <Error_Handler>
  }
  if (HAL_UARTEx_EnableFifoMode(&huart2) != HAL_OK)
 802c8de:	4804      	ldr	r0, [pc, #16]	; (802c8f0 <MX_USART2_UART_Init+0x5c>)
 802c8e0:	f004 f9f8 	bl	8030cd4 <HAL_UARTEx_EnableFifoMode>
 802c8e4:	b118      	cbz	r0, 802c8ee <MX_USART2_UART_Init+0x5a>
  }
  /* USER CODE BEGIN USART2_Init 2 */

  /* USER CODE END USART2_Init 2 */

}
 802c8e6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 802c8ea:	f7ff bce3 	b.w	802c2b4 <Error_Handler>
}
 802c8ee:	bd08      	pop	{r3, pc}
 802c8f0:	2000625c 	.word	0x2000625c
 802c8f4:	40004400 	.word	0x40004400

0802c8f8 <HAL_UART_MspInit>:

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
 802c8f8:	b570      	push	{r4, r5, r6, lr}
 802c8fa:	b096      	sub	sp, #88	; 0x58
 802c8fc:	4606      	mov	r6, r0

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 802c8fe:	2214      	movs	r2, #20
 802c900:	2100      	movs	r1, #0
 802c902:	a803      	add	r0, sp, #12
 802c904:	f00e ff40 	bl	803b788 <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 802c908:	2238      	movs	r2, #56	; 0x38
 802c90a:	2100      	movs	r1, #0
 802c90c:	a808      	add	r0, sp, #32
 802c90e:	f00e ff3b 	bl	803b788 <memset>
  if(uartHandle->Instance==USART2)
 802c912:	6832      	ldr	r2, [r6, #0]
 802c914:	4b2b      	ldr	r3, [pc, #172]	; (802c9c4 <HAL_UART_MspInit+0xcc>)
 802c916:	429a      	cmp	r2, r3
 802c918:	d151      	bne.n	802c9be <HAL_UART_MspInit+0xc6>
  /* USER CODE BEGIN USART2_MspInit 0 */

  /* USER CODE END USART2_MspInit 0 */
  /** Initializes the peripherals clocks
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART2;
 802c91a:	2302      	movs	r3, #2
 802c91c:	9308      	str	r3, [sp, #32]
    PeriphClkInitStruct.Usart2ClockSelection = RCC_USART2CLKSOURCE_SYSCLK;
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 802c91e:	a808      	add	r0, sp, #32
    PeriphClkInitStruct.Usart2ClockSelection = RCC_USART2CLKSOURCE_SYSCLK;
 802c920:	4b29      	ldr	r3, [pc, #164]	; (802c9c8 <HAL_UART_MspInit+0xd0>)
 802c922:	930a      	str	r3, [sp, #40]	; 0x28
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 802c924:	f002 fc62 	bl	802f1ec <HAL_RCCEx_PeriphCLKConfig>
 802c928:	b108      	cbz	r0, 802c92e <HAL_UART_MspInit+0x36>
    {
      Error_Handler();
 802c92a:	f7ff fcc3 	bl	802c2b4 <Error_Handler>
  SET_BIT(RCC->APB1ENR1, Periphs);
 802c92e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
    PA2     ------> USART2_TX
    */
    GPIO_InitStruct.Pin = USARTx_RX_Pin|USARTx_TX_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 802c932:	2500      	movs	r5, #0
 802c934:	6d9a      	ldr	r2, [r3, #88]	; 0x58
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* USART2 DMA Init */
    /* USART2_TX Init */
    hdma_usart2_tx.Instance = DMA1_Channel5;
 802c936:	4c25      	ldr	r4, [pc, #148]	; (802c9cc <HAL_UART_MspInit+0xd4>)
 802c938:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 802c93c:	659a      	str	r2, [r3, #88]	; 0x58
  tmpreg = READ_BIT(RCC->APB1ENR1, Periphs);
 802c93e:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 802c940:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
 802c944:	9202      	str	r2, [sp, #8]
  (void)tmpreg;
 802c946:	9a02      	ldr	r2, [sp, #8]
  SET_BIT(RCC->AHB2ENR, Periphs);
 802c948:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 802c94a:	f042 0201 	orr.w	r2, r2, #1
 802c94e:	64da      	str	r2, [r3, #76]	; 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 802c950:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 802c952:	f003 0301 	and.w	r3, r3, #1
 802c956:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 802c958:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 802c95a:	220c      	movs	r2, #12
 802c95c:	2302      	movs	r3, #2
 802c95e:	e9cd 2303 	strd	r2, r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 802c962:	2303      	movs	r3, #3
 802c964:	e9cd 5305 	strd	r5, r3, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 802c968:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 802c96a:	2307      	movs	r3, #7
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 802c96c:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 802c970:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 802c972:	f001 fda5 	bl	802e4c0 <HAL_GPIO_Init>
    hdma_usart2_tx.Init.Request = DMA_REQUEST_USART2_TX;
 802c976:	4916      	ldr	r1, [pc, #88]	; (802c9d0 <HAL_UART_MspInit+0xd8>)
    hdma_usart2_tx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_usart2_tx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_usart2_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_usart2_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_usart2_tx.Init.Mode = DMA_NORMAL;
    hdma_usart2_tx.Init.Priority = DMA_PRIORITY_LOW;
 802c978:	6225      	str	r5, [r4, #32]
    hdma_usart2_tx.Init.Request = DMA_REQUEST_USART2_TX;
 802c97a:	2314      	movs	r3, #20
 802c97c:	e9c4 1300 	strd	r1, r3, [r4]
    hdma_usart2_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 802c980:	2310      	movs	r3, #16
    hdma_usart2_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 802c982:	e9c4 3502 	strd	r3, r5, [r4, #8]
    if (HAL_DMA_Init(&hdma_usart2_tx) != HAL_OK)
 802c986:	4620      	mov	r0, r4
    hdma_usart2_tx.Init.MemInc = DMA_MINC_ENABLE;
 802c988:	2380      	movs	r3, #128	; 0x80
    hdma_usart2_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 802c98a:	e9c4 3504 	strd	r3, r5, [r4, #16]
    hdma_usart2_tx.Init.Mode = DMA_NORMAL;
 802c98e:	e9c4 5506 	strd	r5, r5, [r4, #24]
    if (HAL_DMA_Init(&hdma_usart2_tx) != HAL_OK)
 802c992:	f001 fa7b 	bl	802de8c <HAL_DMA_Init>
 802c996:	b108      	cbz	r0, 802c99c <HAL_UART_MspInit+0xa4>
    {
      Error_Handler();
 802c998:	f7ff fc8c 	bl	802c2b4 <Error_Handler>
    }

    if (HAL_DMA_ConfigChannelAttributes(&hdma_usart2_tx, DMA_CHANNEL_NPRIV) != HAL_OK)
 802c99c:	480b      	ldr	r0, [pc, #44]	; (802c9cc <HAL_UART_MspInit+0xd4>)
 802c99e:	2110      	movs	r1, #16
 802c9a0:	f001 fc46 	bl	802e230 <HAL_DMA_ConfigChannelAttributes>
 802c9a4:	b108      	cbz	r0, 802c9aa <HAL_UART_MspInit+0xb2>
    {
      Error_Handler();
 802c9a6:	f7ff fc85 	bl	802c2b4 <Error_Handler>
    }

    __HAL_LINKDMA(uartHandle,hdmatx,hdma_usart2_tx);

    /* USART2 interrupt Init */
    HAL_NVIC_SetPriority(USART2_IRQn, 2, 0);
 802c9aa:	2025      	movs	r0, #37	; 0x25
    __HAL_LINKDMA(uartHandle,hdmatx,hdma_usart2_tx);
 802c9ac:	67b4      	str	r4, [r6, #120]	; 0x78
    HAL_NVIC_SetPriority(USART2_IRQn, 2, 0);
 802c9ae:	2200      	movs	r2, #0
 802c9b0:	2102      	movs	r1, #2
    __HAL_LINKDMA(uartHandle,hdmatx,hdma_usart2_tx);
 802c9b2:	62a6      	str	r6, [r4, #40]	; 0x28
    HAL_NVIC_SetPriority(USART2_IRQn, 2, 0);
 802c9b4:	f001 f9d6 	bl	802dd64 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART2_IRQn);
 802c9b8:	2025      	movs	r0, #37	; 0x25
 802c9ba:	f001 fa05 	bl	802ddc8 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USART2_MspInit 1 */

  /* USER CODE END USART2_MspInit 1 */
  }
}
 802c9be:	b016      	add	sp, #88	; 0x58
 802c9c0:	bd70      	pop	{r4, r5, r6, pc}
 802c9c2:	bf00      	nop
 802c9c4:	40004400 	.word	0x40004400
 802c9c8:	000c0004 	.word	0x000c0004
 802c9cc:	200061fc 	.word	0x200061fc
 802c9d0:	40020058 	.word	0x40020058

0802c9d4 <HAL_UART_MspDeInit>:

void HAL_UART_MspDeInit(UART_HandleTypeDef* uartHandle)
{

  if(uartHandle->Instance==USART2)
 802c9d4:	6802      	ldr	r2, [r0, #0]
 802c9d6:	4b0c      	ldr	r3, [pc, #48]	; (802ca08 <HAL_UART_MspDeInit+0x34>)
 802c9d8:	429a      	cmp	r2, r3
{
 802c9da:	b510      	push	{r4, lr}
 802c9dc:	4604      	mov	r4, r0
  if(uartHandle->Instance==USART2)
 802c9de:	d112      	bne.n	802ca06 <HAL_UART_MspDeInit+0x32>
  CLEAR_BIT(RCC->APB1ENR1, Periphs);
 802c9e0:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000

    /**USART2 GPIO Configuration
    PA3     ------> USART2_RX
    PA2     ------> USART2_TX
    */
    HAL_GPIO_DeInit(GPIOA, USARTx_RX_Pin|USARTx_TX_Pin);
 802c9e4:	210c      	movs	r1, #12
 802c9e6:	6d93      	ldr	r3, [r2, #88]	; 0x58
 802c9e8:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 802c9ec:	6593      	str	r3, [r2, #88]	; 0x58
 802c9ee:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 802c9f2:	f001 fe11 	bl	802e618 <HAL_GPIO_DeInit>

    /* USART2 DMA DeInit */
    HAL_DMA_DeInit(uartHandle->hdmatx);
 802c9f6:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 802c9f8:	f001 faba 	bl	802df70 <HAL_DMA_DeInit>
    HAL_NVIC_DisableIRQ(USART2_IRQn);
  /* USER CODE BEGIN USART2_MspDeInit 1 */

  /* USER CODE END USART2_MspDeInit 1 */
  }
}
 802c9fc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    HAL_NVIC_DisableIRQ(USART2_IRQn);
 802ca00:	2025      	movs	r0, #37	; 0x25
 802ca02:	f001 b9ef 	b.w	802dde4 <HAL_NVIC_DisableIRQ>
}
 802ca06:	bd10      	pop	{r4, pc}
 802ca08:	40004400 	.word	0x40004400

0802ca0c <vcom_Trace_DMA>:

  /* USER CODE END vcom_Trace_2 */
}

UTIL_ADV_TRACE_Status_t vcom_Trace_DMA(uint8_t *p_data, uint16_t size)
{
 802ca0c:	b508      	push	{r3, lr}
 802ca0e:	460a      	mov	r2, r1
  /* USER CODE BEGIN vcom_Trace_DMA_1 */

  /* USER CODE END vcom_Trace_DMA_1 */
  HAL_UART_Transmit_DMA(&huart2, p_data, size);
 802ca10:	4601      	mov	r1, r0
 802ca12:	4802      	ldr	r0, [pc, #8]	; (802ca1c <vcom_Trace_DMA+0x10>)
 802ca14:	f003 f9e6 	bl	802fde4 <HAL_UART_Transmit_DMA>
  return UTIL_ADV_TRACE_OK;
  /* USER CODE BEGIN vcom_Trace_DMA_2 */

  /* USER CODE END vcom_Trace_DMA_2 */
}
 802ca18:	2000      	movs	r0, #0
 802ca1a:	bd08      	pop	{r3, pc}
 802ca1c:	2000625c 	.word	0x2000625c

0802ca20 <vcom_ReceiveInit>:

UTIL_ADV_TRACE_Status_t vcom_ReceiveInit(void (*RxCb)(uint8_t *rxChar, uint16_t size, uint8_t error))
{
 802ca20:	b513      	push	{r0, r1, r4, lr}

  /* USER CODE END vcom_ReceiveInit_1 */
  UART_WakeUpTypeDef WakeUpSelection;

  /*record call back*/
  RxCpltCallback = RxCb;
 802ca22:	4b11      	ldr	r3, [pc, #68]	; (802ca68 <vcom_ReceiveInit+0x48>)

  /*Set wakeUp event on start bit*/
  WakeUpSelection.WakeUpEvent = UART_WAKEUP_ON_STARTBIT;

  HAL_UARTEx_StopModeWakeUpSourceConfig(&huart2, WakeUpSelection);
 802ca24:	4c11      	ldr	r4, [pc, #68]	; (802ca6c <vcom_ReceiveInit+0x4c>)
  RxCpltCallback = RxCb;
 802ca26:	6018      	str	r0, [r3, #0]
  WakeUpSelection.WakeUpEvent = UART_WAKEUP_ON_STARTBIT;
 802ca28:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 802ca2c:	9300      	str	r3, [sp, #0]
  HAL_UARTEx_StopModeWakeUpSourceConfig(&huart2, WakeUpSelection);
 802ca2e:	ab02      	add	r3, sp, #8
 802ca30:	e913 0006 	ldmdb	r3, {r1, r2}
 802ca34:	4620      	mov	r0, r4
 802ca36:	f004 f8f0 	bl	8030c1a <HAL_UARTEx_StopModeWakeUpSourceConfig>

  /* Make sure that no UART transfer is on-going */
  while (__HAL_UART_GET_FLAG(&huart2, USART_ISR_BUSY) == SET);
 802ca3a:	6823      	ldr	r3, [r4, #0]
 802ca3c:	69da      	ldr	r2, [r3, #28]
 802ca3e:	03d1      	lsls	r1, r2, #15
 802ca40:	d4fc      	bmi.n	802ca3c <vcom_ReceiveInit+0x1c>

  /* Make sure that UART is ready to receive)   */
  while (__HAL_UART_GET_FLAG(&huart2, USART_ISR_REACK) == RESET);
 802ca42:	69da      	ldr	r2, [r3, #28]
 802ca44:	0252      	lsls	r2, r2, #9
 802ca46:	d5fc      	bpl.n	802ca42 <vcom_ReceiveInit+0x22>

  /* Enable USART interrupt */
  __HAL_UART_ENABLE_IT(&huart2, UART_IT_WUF);
 802ca48:	689a      	ldr	r2, [r3, #8]

  /*Enable wakeup from stop mode*/
  HAL_UARTEx_EnableStopMode(&huart2);
 802ca4a:	4808      	ldr	r0, [pc, #32]	; (802ca6c <vcom_ReceiveInit+0x4c>)
  __HAL_UART_ENABLE_IT(&huart2, UART_IT_WUF);
 802ca4c:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 802ca50:	609a      	str	r2, [r3, #8]
  HAL_UARTEx_EnableStopMode(&huart2);
 802ca52:	f004 f929 	bl	8030ca8 <HAL_UARTEx_EnableStopMode>

  /*Start LPUART receive on IT*/
  HAL_UART_Receive_IT(&huart2, &charRx, 1);
 802ca56:	4906      	ldr	r1, [pc, #24]	; (802ca70 <vcom_ReceiveInit+0x50>)
 802ca58:	4804      	ldr	r0, [pc, #16]	; (802ca6c <vcom_ReceiveInit+0x4c>)
 802ca5a:	2201      	movs	r2, #1
 802ca5c:	f004 f88e 	bl	8030b7c <HAL_UART_Receive_IT>

  return UTIL_ADV_TRACE_OK;
  /* USER CODE BEGIN vcom_ReceiveInit_2 */

  /* USER CODE END vcom_ReceiveInit_2 */
}
 802ca60:	2000      	movs	r0, #0
 802ca62:	b002      	add	sp, #8
 802ca64:	bd10      	pop	{r4, pc}
 802ca66:	bf00      	nop
 802ca68:	200035d0 	.word	0x200035d0
 802ca6c:	2000625c 	.word	0x2000625c
 802ca70:	200062ec 	.word	0x200062ec

0802ca74 <vcom_Init>:
{
 802ca74:	b508      	push	{r3, lr}
  TxCpltCallback = cb;
 802ca76:	4b07      	ldr	r3, [pc, #28]	; (802ca94 <vcom_Init+0x20>)
 802ca78:	6058      	str	r0, [r3, #4]
  MX_DMA_Init();
 802ca7a:	f7ff fabf 	bl	802bffc <MX_DMA_Init>
  MX_USART2_UART_Init();
 802ca7e:	f7ff ff09 	bl	802c894 <MX_USART2_UART_Init>
  SET_BIT(EXTI->IMR1, ExtiLine);
 802ca82:	4a05      	ldr	r2, [pc, #20]	; (802ca98 <vcom_Init+0x24>)
 802ca84:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
 802ca88:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 802ca8c:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
}
 802ca90:	2000      	movs	r0, #0
 802ca92:	bd08      	pop	{r3, pc}
 802ca94:	200035d0 	.word	0x200035d0
 802ca98:	58000800 	.word	0x58000800

0802ca9c <vcom_DeInit>:
{
 802ca9c:	b508      	push	{r3, lr}
  SET_BIT(RCC->APB1RSTR1, Periphs);
 802ca9e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
  HAL_UART_MspDeInit(&huart2);
 802caa2:	4808      	ldr	r0, [pc, #32]	; (802cac4 <vcom_DeInit+0x28>)
 802caa4:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 802caa6:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 802caaa:	639a      	str	r2, [r3, #56]	; 0x38
  CLEAR_BIT(RCC->APB1RSTR1, Periphs);
 802caac:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 802caae:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 802cab2:	639a      	str	r2, [r3, #56]	; 0x38
 802cab4:	f7ff ff8e 	bl	802c9d4 <HAL_UART_MspDeInit>
  HAL_NVIC_DisableIRQ(DMA1_Channel5_IRQn);
 802cab8:	200f      	movs	r0, #15
 802caba:	f001 f993 	bl	802dde4 <HAL_NVIC_DisableIRQ>
}
 802cabe:	2000      	movs	r0, #0
 802cac0:	bd08      	pop	{r3, pc}
 802cac2:	bf00      	nop
 802cac4:	2000625c 	.word	0x2000625c

0802cac8 <vcom_Resume>:

void vcom_Resume(void)
{
 802cac8:	b508      	push	{r3, lr}
  /* USER CODE BEGIN vcom_Resume_1 */

  /* USER CODE END vcom_Resume_1 */
  /*to re-enable lost UART settings*/
  if (HAL_UART_Init(&huart2) != HAL_OK)
 802caca:	4807      	ldr	r0, [pc, #28]	; (802cae8 <vcom_Resume+0x20>)
 802cacc:	f003 ff9e 	bl	8030a0c <HAL_UART_Init>
 802cad0:	b108      	cbz	r0, 802cad6 <vcom_Resume+0xe>
  {
    Error_Handler();
 802cad2:	f7ff fbef 	bl	802c2b4 <Error_Handler>
  }

  /*to re-enable lost DMA settings*/
  if (HAL_DMA_Init(&hdma_usart2_tx) != HAL_OK)
 802cad6:	4805      	ldr	r0, [pc, #20]	; (802caec <vcom_Resume+0x24>)
 802cad8:	f001 f9d8 	bl	802de8c <HAL_DMA_Init>
 802cadc:	b118      	cbz	r0, 802cae6 <vcom_Resume+0x1e>
    Error_Handler();
  }
  /* USER CODE BEGIN vcom_Resume_2 */

  /* USER CODE END vcom_Resume_2 */
}
 802cade:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 802cae2:	f7ff bbe7 	b.w	802c2b4 <Error_Handler>
}
 802cae6:	bd08      	pop	{r3, pc}
 802cae8:	2000625c 	.word	0x2000625c
 802caec:	200061fc 	.word	0x200061fc

0802caf0 <HAL_UART_TxCpltCallback>:
{
  /* USER CODE BEGIN HAL_UART_TxCpltCallback_1 */

  /* USER CODE END HAL_UART_TxCpltCallback_1 */
  /* buffer transmission complete*/
  TxCpltCallback(NULL);
 802caf0:	4b01      	ldr	r3, [pc, #4]	; (802caf8 <HAL_UART_TxCpltCallback+0x8>)
 802caf2:	2000      	movs	r0, #0
 802caf4:	685b      	ldr	r3, [r3, #4]
 802caf6:	4718      	bx	r3
 802caf8:	200035d0 	.word	0x200035d0

0802cafc <HAL_UART_RxCpltCallback>:
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart2)
{
  /* USER CODE BEGIN HAL_UART_RxCpltCallback_1 */

  /* USER CODE END HAL_UART_RxCpltCallback_1 */
  if ((NULL != RxCpltCallback) && (HAL_UART_ERROR_NONE == huart2->ErrorCode))
 802cafc:	4b08      	ldr	r3, [pc, #32]	; (802cb20 <HAL_UART_RxCpltCallback+0x24>)
 802cafe:	681b      	ldr	r3, [r3, #0]
{
 802cb00:	b510      	push	{r4, lr}
 802cb02:	4604      	mov	r4, r0
  if ((NULL != RxCpltCallback) && (HAL_UART_ERROR_NONE == huart2->ErrorCode))
 802cb04:	b12b      	cbz	r3, 802cb12 <HAL_UART_RxCpltCallback+0x16>
 802cb06:	f8d0 208c 	ldr.w	r2, [r0, #140]	; 0x8c
 802cb0a:	b912      	cbnz	r2, 802cb12 <HAL_UART_RxCpltCallback+0x16>
  {
    RxCpltCallback(&charRx, 1, 0);
 802cb0c:	4805      	ldr	r0, [pc, #20]	; (802cb24 <HAL_UART_RxCpltCallback+0x28>)
 802cb0e:	2101      	movs	r1, #1
 802cb10:	4798      	blx	r3
  }
  HAL_UART_Receive_IT(huart2, &charRx, 1);
 802cb12:	4620      	mov	r0, r4
 802cb14:	4903      	ldr	r1, [pc, #12]	; (802cb24 <HAL_UART_RxCpltCallback+0x28>)
  /* USER CODE BEGIN HAL_UART_RxCpltCallback_2 */

  /* USER CODE END HAL_UART_RxCpltCallback_2 */
}
 802cb16:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  HAL_UART_Receive_IT(huart2, &charRx, 1);
 802cb1a:	2201      	movs	r2, #1
 802cb1c:	f004 b82e 	b.w	8030b7c <HAL_UART_Receive_IT>
 802cb20:	200035d0 	.word	0x200035d0
 802cb24:	200062ec 	.word	0x200062ec

0802cb28 <MX_KMS_Init>:
{
/***************************************/
   /**
  */

  C_Initialize(NULL);
 802cb28:	2000      	movs	r0, #0
 802cb2a:	f7dc b861 	b.w	8008bf0 <SE_KMS_Initialize>

0802cb2e <MX_LoRaWAN_Init>:
/* USER CODE END PFP */

/* Exported functions --------------------------------------------------------*/

void MX_LoRaWAN_Init(void)
{
 802cb2e:	b508      	push	{r3, lr}
  /* USER CODE BEGIN MX_LoRaWAN_Init_1 */

  /* USER CODE END MX_LoRaWAN_Init_1 */
  SystemApp_Init();
 802cb30:	f7ff fcda 	bl	802c4e8 <SystemApp_Init>
  /* USER CODE END MX_LoRaWAN_Init_2 */
  LoRaWAN_Init();
  /* USER CODE BEGIN MX_LoRaWAN_Init_3 */

  /* USER CODE END MX_LoRaWAN_Init_3 */
}
 802cb34:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  LoRaWAN_Init();
 802cb38:	f000 b98a 	b.w	802ce50 <LoRaWAN_Init>

0802cb3c <MX_LoRaWAN_Process>:
void MX_LoRaWAN_Process(void)
{
  /* USER CODE BEGIN MX_LoRaWAN_Process_1 */

  /* USER CODE END MX_LoRaWAN_Process_1 */
  UTIL_SEQ_Run(UTIL_SEQ_DEFAULT);
 802cb3c:	f04f 30ff 	mov.w	r0, #4294967295
 802cb40:	f00e ba2c 	b.w	803af9c <UTIL_SEQ_Run>

0802cb44 <FwUpdateAgent_Run>:
/* USER CODE END PFP */

/* Exported functions --------------------------------------------------------*/
#if (INTEROP_TEST_MODE == 0)
void FwUpdateAgent_Run(void)
{
 802cb44:	b530      	push	{r4, r5, lr}
  /* USER CODE BEGIN FwUpdateAgent_Run_1 */

  /* USER CODE END FwUpdateAgent_Run_1 */
  int32_t status = FLASH_OK;
  uint8_t fw_header_dwl_slot[SE_FW_HEADER_TOT_LEN];
  uint32_t first_page = PAGE(FRAG_DECODER_SWAP_REGION_START);
 802cb46:	4b1d      	ldr	r3, [pc, #116]	; (802cbbc <FwUpdateAgent_Run+0x78>)
  uint32_t nb_pages = PAGE(FRAG_DECODER_SWAP_REGION_START + SFU_IMG_IMAGE_OFFSET - 1) - first_page + 1U;

  /* Read header in slot 1 */
  UTIL_MEM_cpy_8(fw_header_dwl_slot, (void *)FRAG_DECODER_DWL_REGION_START, SE_FW_HEADER_TOT_LEN);
 802cb48:	491d      	ldr	r1, [pc, #116]	; (802cbc0 <FwUpdateAgent_Run+0x7c>)
  uint32_t first_page = PAGE(FRAG_DECODER_SWAP_REGION_START);
 802cb4a:	681c      	ldr	r4, [r3, #0]
{
 802cb4c:	b0d1      	sub	sp, #324	; 0x144
  UTIL_MEM_cpy_8(fw_header_dwl_slot, (void *)FRAG_DECODER_DWL_REGION_START, SE_FW_HEADER_TOT_LEN);
 802cb4e:	f44f 72a0 	mov.w	r2, #320	; 0x140
 802cb52:	4668      	mov	r0, sp
 802cb54:	f00e f9da 	bl	803af0c <UTIL_MEM_cpy_8>

  /* Ask for installation at next reset */
  if (HAL_FLASH_Unlock() == HAL_OK)
 802cb58:	f001 fba0 	bl	802e29c <HAL_FLASH_Unlock>
 802cb5c:	4602      	mov	r2, r0
 802cb5e:	bb58      	cbnz	r0, 802cbb8 <FwUpdateAgent_Run+0x74>
  uint32_t first_page = PAGE(FRAG_DECODER_SWAP_REGION_START);
 802cb60:	4d18      	ldr	r5, [pc, #96]	; (802cbc4 <FwUpdateAgent_Run+0x80>)
 802cb62:	4b19      	ldr	r3, [pc, #100]	; (802cbc8 <FwUpdateAgent_Run+0x84>)
  uint32_t nb_pages = PAGE(FRAG_DECODER_SWAP_REGION_START + SFU_IMG_IMAGE_OFFSET - 1) - first_page + 1U;
 802cb64:	f205 10ff 	addw	r0, r5, #511	; 0x1ff
  uint32_t first_page = PAGE(FRAG_DECODER_SWAP_REGION_START);
 802cb68:	ea03 2384 	and.w	r3, r3, r4, lsl #10
  uint32_t nb_pages = PAGE(FRAG_DECODER_SWAP_REGION_START + SFU_IMG_IMAGE_OFFSET - 1) - first_page + 1U;
 802cb6c:	fbb0 f1f3 	udiv	r1, r0, r3
 802cb70:	fb03 0111 	mls	r1, r3, r1, r0
 802cb74:	0ac9      	lsrs	r1, r1, #11
  uint32_t first_page = PAGE(FRAG_DECODER_SWAP_REGION_START);
 802cb76:	fbb5 f4f3 	udiv	r4, r5, r3
  uint32_t nb_pages = PAGE(FRAG_DECODER_SWAP_REGION_START + SFU_IMG_IMAGE_OFFSET - 1) - first_page + 1U;
 802cb7a:	3101      	adds	r1, #1
  uint32_t first_page = PAGE(FRAG_DECODER_SWAP_REGION_START);
 802cb7c:	fb03 5414 	mls	r4, r3, r4, r5
  uint32_t nb_pages = PAGE(FRAG_DECODER_SWAP_REGION_START + SFU_IMG_IMAGE_OFFSET - 1) - first_page + 1U;
 802cb80:	eba1 21d4 	sub.w	r1, r1, r4, lsr #11
  {
    status = FLASH_IF_EraseByPages(first_page, nb_pages, 0U);
 802cb84:	0ae0      	lsrs	r0, r4, #11
 802cb86:	b289      	uxth	r1, r1
 802cb88:	f7ff fa95 	bl	802c0b6 <FLASH_IF_EraseByPages>

    if (status == FLASH_OK)
 802cb8c:	4604      	mov	r4, r0
 802cb8e:	b940      	cbnz	r0, 802cba2 <FwUpdateAgent_Run+0x5e>
    {
      status = FLASH_IF_Write(FRAG_DECODER_SWAP_REGION_START, fw_header_dwl_slot, SE_FW_HEADER_TOT_LEN, NULL);
 802cb90:	4603      	mov	r3, r0
 802cb92:	f44f 72a0 	mov.w	r2, #320	; 0x140
 802cb96:	4669      	mov	r1, sp
 802cb98:	f105 6000 	add.w	r0, r5, #134217728	; 0x8000000
 802cb9c:	f7ff faa2 	bl	802c0e4 <FLASH_IF_Write>
 802cba0:	4604      	mov	r4, r0
    }
    HAL_FLASH_Lock();
 802cba2:	f001 fb8d 	bl	802e2c0 <HAL_FLASH_Lock>
  else
  {
    status = FLASH_LOCK_ERROR;
  }

  if (status == FLASH_OK)
 802cba6:	b93c      	cbnz	r4, 802cbb8 <FwUpdateAgent_Run+0x74>
  {
    /* System Reboot*/
    // NVIC_SystemReset();
    APP_LOG(TS_OFF, VLEVEL_M, "Ready to install the new image at next reset\r\n");
 802cba8:	4b08      	ldr	r3, [pc, #32]	; (802cbcc <FwUpdateAgent_Run+0x88>)
  }
  else
  {
    APP_LOG(TS_OFF, VLEVEL_M, "FW Update Agent Run Failed\r\n");
 802cbaa:	2200      	movs	r2, #0
 802cbac:	4611      	mov	r1, r2
 802cbae:	2002      	movs	r0, #2
 802cbb0:	f00e f8a4 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
  }
  /* USER CODE BEGIN FwUpdateAgent_Run_2 */

  /* USER CODE END FwUpdateAgent_Run_2 */
}
 802cbb4:	b051      	add	sp, #324	; 0x144
 802cbb6:	bd30      	pop	{r4, r5, pc}
    APP_LOG(TS_OFF, VLEVEL_M, "FW Update Agent Run Failed\r\n");
 802cbb8:	4b05      	ldr	r3, [pc, #20]	; (802cbd0 <FwUpdateAgent_Run+0x8c>)
 802cbba:	e7f6      	b.n	802cbaa <FwUpdateAgent_Run+0x66>
 802cbbc:	1fff75e0 	.word	0x1fff75e0
 802cbc0:	08016000 	.word	0x08016000
 802cbc4:	00015000 	.word	0x00015000
 802cbc8:	03fffc00 	.word	0x03fffc00
 802cbcc:	0803bda7 	.word	0x0803bda7
 802cbd0:	0803bdd6 	.word	0x0803bdd6

0802cbd4 <OnMacProcessNotify>:
static void OnMacProcessNotify(void)
{
  /* USER CODE BEGIN OnMacProcessNotify_1 */

  /* USER CODE END OnMacProcessNotify_1 */
  UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_LmHandlerProcess), CFG_SEQ_Prio_0);
 802cbd4:	2100      	movs	r1, #0
 802cbd6:	2001      	movs	r0, #1
 802cbd8:	f00e b9aa 	b.w	803af30 <UTIL_SEQ_SetTask>

0802cbdc <OnClassChange>:
  if (deviceClass == CLASS_C)
 802cbdc:	2802      	cmp	r0, #2
    UTIL_TIMER_Stop(&TxTimer);
 802cbde:	4803      	ldr	r0, [pc, #12]	; (802cbec <OnClassChange+0x10>)
  if (deviceClass == CLASS_C)
 802cbe0:	d101      	bne.n	802cbe6 <OnClassChange+0xa>
    UTIL_TIMER_Stop(&TxTimer);
 802cbe2:	f00e bbad 	b.w	803b340 <UTIL_TIMER_Stop>
    UTIL_TIMER_Start(&TxTimer);
 802cbe6:	f00e bbfb 	b.w	803b3e0 <UTIL_TIMER_Start>
 802cbea:	bf00      	nop
 802cbec:	200035d8 	.word	0x200035d8

0802cbf0 <OnRxData>:
{
 802cbf0:	b530      	push	{r4, r5, lr}
 802cbf2:	460d      	mov	r5, r1
 802cbf4:	b087      	sub	sp, #28
  if ((appData != NULL) || (params != NULL))
 802cbf6:	4604      	mov	r4, r0
 802cbf8:	b908      	cbnz	r0, 802cbfe <OnRxData+0xe>
 802cbfa:	2900      	cmp	r1, #0
 802cbfc:	d057      	beq.n	802ccae <OnRxData+0xbe>
    BSP_LED_On(LED_BLUE) ;
 802cbfe:	2000      	movs	r0, #0
 802cc00:	f000 fb20 	bl	802d244 <BSP_LED_On>
    UTIL_TIMER_Start(&RxLedTimer);
 802cc04:	482b      	ldr	r0, [pc, #172]	; (802ccb4 <OnRxData+0xc4>)
 802cc06:	f00e fbeb 	bl	803b3e0 <UTIL_TIMER_Start>
    APP_LOG(TS_OFF, VLEVEL_M, "\r\n###### ========== MCPS-Indication ==========\r\n");
 802cc0a:	2200      	movs	r2, #0
 802cc0c:	4611      	mov	r1, r2
 802cc0e:	4b2a      	ldr	r3, [pc, #168]	; (802ccb8 <OnRxData+0xc8>)
 802cc10:	2002      	movs	r0, #2
 802cc12:	f00e f873 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
    APP_LOG(TS_OFF, VLEVEL_H, "###### D/L FRAME:%04d | SLOT:%s | PORT:%d | DR:%d | RSSI:%d | SNR:%d\r\n",
 802cc16:	f995 3004 	ldrsb.w	r3, [r5, #4]
 802cc1a:	9305      	str	r3, [sp, #20]
 802cc1c:	f995 3003 	ldrsb.w	r3, [r5, #3]
 802cc20:	9304      	str	r3, [sp, #16]
 802cc22:	f995 3002 	ldrsb.w	r3, [r5, #2]
 802cc26:	9303      	str	r3, [sp, #12]
 802cc28:	7823      	ldrb	r3, [r4, #0]
 802cc2a:	9302      	str	r3, [sp, #8]
 802cc2c:	f995 200c 	ldrsb.w	r2, [r5, #12]
 802cc30:	4b22      	ldr	r3, [pc, #136]	; (802ccbc <OnRxData+0xcc>)
 802cc32:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 802cc36:	9301      	str	r3, [sp, #4]
 802cc38:	68ab      	ldr	r3, [r5, #8]
 802cc3a:	9300      	str	r3, [sp, #0]
 802cc3c:	2200      	movs	r2, #0
 802cc3e:	4b20      	ldr	r3, [pc, #128]	; (802ccc0 <OnRxData+0xd0>)
 802cc40:	4611      	mov	r1, r2
 802cc42:	2003      	movs	r0, #3
 802cc44:	f00e f85a 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
    switch (appData->Port)
 802cc48:	7825      	ldrb	r5, [r4, #0]
 802cc4a:	2d02      	cmp	r5, #2
 802cc4c:	d010      	beq.n	802cc70 <OnRxData+0x80>
 802cc4e:	2d03      	cmp	r5, #3
 802cc50:	d12d      	bne.n	802ccae <OnRxData+0xbe>
        if (appData->BufferSize == 1)
 802cc52:	7863      	ldrb	r3, [r4, #1]
 802cc54:	2b01      	cmp	r3, #1
 802cc56:	d12a      	bne.n	802ccae <OnRxData+0xbe>
          switch (appData->Buffer[0])
 802cc58:	6863      	ldr	r3, [r4, #4]
 802cc5a:	7818      	ldrb	r0, [r3, #0]
 802cc5c:	2801      	cmp	r0, #1
 802cc5e:	d002      	beq.n	802cc66 <OnRxData+0x76>
 802cc60:	2802      	cmp	r0, #2
 802cc62:	d000      	beq.n	802cc66 <OnRxData+0x76>
 802cc64:	bb18      	cbnz	r0, 802ccae <OnRxData+0xbe>
}
 802cc66:	b007      	add	sp, #28
 802cc68:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
              LmHandlerRequestClass(CLASS_C);
 802cc6c:	f004 bcb6 	b.w	80315dc <LmHandlerRequestClass>
        if (appData->BufferSize == 1)
 802cc70:	7863      	ldrb	r3, [r4, #1]
 802cc72:	2b01      	cmp	r3, #1
 802cc74:	d11b      	bne.n	802ccae <OnRxData+0xbe>
          AppLedStateOn = appData->Buffer[0] & 0x01;
 802cc76:	6863      	ldr	r3, [r4, #4]
 802cc78:	781a      	ldrb	r2, [r3, #0]
          if (AppLedStateOn == RESET)
 802cc7a:	f012 0201 	ands.w	r2, r2, #1
 802cc7e:	d10a      	bne.n	802cc96 <OnRxData+0xa6>
            APP_LOG(TS_OFF, VLEVEL_H,   "LED OFF\r\n");
 802cc80:	4b10      	ldr	r3, [pc, #64]	; (802ccc4 <OnRxData+0xd4>)
 802cc82:	4611      	mov	r1, r2
 802cc84:	2003      	movs	r0, #3
 802cc86:	f00e f839 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
            BSP_LED_Off(LED_RED) ;
 802cc8a:	4628      	mov	r0, r5
}
 802cc8c:	b007      	add	sp, #28
 802cc8e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
            BSP_LED_Off(LED_RED) ;
 802cc92:	f000 bae5 	b.w	802d260 <BSP_LED_Off>
            APP_LOG(TS_OFF, VLEVEL_H, "LED ON\r\n");
 802cc96:	2200      	movs	r2, #0
 802cc98:	4b0b      	ldr	r3, [pc, #44]	; (802ccc8 <OnRxData+0xd8>)
 802cc9a:	4611      	mov	r1, r2
 802cc9c:	2003      	movs	r0, #3
 802cc9e:	f00e f82d 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
            BSP_LED_On(LED_RED) ;
 802cca2:	4628      	mov	r0, r5
}
 802cca4:	b007      	add	sp, #28
 802cca6:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
            BSP_LED_On(LED_RED) ;
 802ccaa:	f000 bacb 	b.w	802d244 <BSP_LED_On>
}
 802ccae:	b007      	add	sp, #28
 802ccb0:	bd30      	pop	{r4, r5, pc}
 802ccb2:	bf00      	nop
 802ccb4:	200035f0 	.word	0x200035f0
 802ccb8:	0803bdf3 	.word	0x0803bdf3
 802ccbc:	0803b948 	.word	0x0803b948
 802ccc0:	0803be24 	.word	0x0803be24
 802ccc4:	0803be6b 	.word	0x0803be6b
 802ccc8:	0803be75 	.word	0x0803be75

0802cccc <OnRxTimerLedEvent>:
  BSP_LED_Off(LED_BLUE) ;
 802cccc:	2000      	movs	r0, #0
 802ccce:	f000 bac7 	b.w	802d260 <BSP_LED_Off>

0802ccd2 <OnTxTimerLedEvent>:
  BSP_LED_Off(LED_GREEN) ;
 802ccd2:	2001      	movs	r0, #1
 802ccd4:	f000 bac4 	b.w	802d260 <BSP_LED_Off>

0802ccd8 <OnJoinTimerLedEvent>:
  BSP_LED_Toggle(LED_RED) ;
 802ccd8:	2002      	movs	r0, #2
 802ccda:	f000 bacf 	b.w	802d27c <BSP_LED_Toggle>
	...

0802cce0 <OnTxData>:
{
 802cce0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  if ((params != NULL))
 802cce2:	4604      	mov	r4, r0
 802cce4:	2800      	cmp	r0, #0
 802cce6:	d034      	beq.n	802cd52 <OnTxData+0x72>
    if (params->IsMcpsConfirm != 0)
 802cce8:	7803      	ldrb	r3, [r0, #0]
 802ccea:	2b00      	cmp	r3, #0
 802ccec:	d031      	beq.n	802cd52 <OnTxData+0x72>
      BSP_LED_On(LED_GREEN) ;
 802ccee:	2001      	movs	r0, #1
 802ccf0:	f000 faa8 	bl	802d244 <BSP_LED_On>
      UTIL_TIMER_Start(&TxLedTimer);
 802ccf4:	481c      	ldr	r0, [pc, #112]	; (802cd68 <OnTxData+0x88>)
 802ccf6:	f00e fb73 	bl	803b3e0 <UTIL_TIMER_Start>
      APP_LOG(TS_OFF, VLEVEL_M, "\r\n###### ========== MCPS-Confirm =============\r\n");
 802ccfa:	2200      	movs	r2, #0
 802ccfc:	4611      	mov	r1, r2
 802ccfe:	4b1b      	ldr	r3, [pc, #108]	; (802cd6c <OnTxData+0x8c>)
 802cd00:	2002      	movs	r0, #2
 802cd02:	f00d fffb 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
      APP_LOG(TS_OFF, VLEVEL_H, "###### U/L FRAME:%04d | PORT:%d | DR:%d | PWR:%d", params->UplinkCounter,
 802cd06:	f994 3014 	ldrsb.w	r3, [r4, #20]
 802cd0a:	9303      	str	r3, [sp, #12]
 802cd0c:	f994 3004 	ldrsb.w	r3, [r4, #4]
 802cd10:	9302      	str	r3, [sp, #8]
 802cd12:	7b23      	ldrb	r3, [r4, #12]
 802cd14:	9301      	str	r3, [sp, #4]
 802cd16:	68a3      	ldr	r3, [r4, #8]
 802cd18:	9300      	str	r3, [sp, #0]
 802cd1a:	2200      	movs	r2, #0
 802cd1c:	4611      	mov	r1, r2
 802cd1e:	4b14      	ldr	r3, [pc, #80]	; (802cd70 <OnTxData+0x90>)
 802cd20:	2003      	movs	r0, #3
 802cd22:	f00d ffeb 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
      APP_LOG(TS_OFF, VLEVEL_H, " | MSG TYPE:");
 802cd26:	2200      	movs	r2, #0
 802cd28:	4b12      	ldr	r3, [pc, #72]	; (802cd74 <OnTxData+0x94>)
 802cd2a:	4611      	mov	r1, r2
 802cd2c:	2003      	movs	r0, #3
 802cd2e:	f00d ffe5 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
      if (params->MsgType == LORAMAC_HANDLER_CONFIRMED_MSG)
 802cd32:	78a3      	ldrb	r3, [r4, #2]
 802cd34:	2b01      	cmp	r3, #1
 802cd36:	d10e      	bne.n	802cd56 <OnTxData+0x76>
        APP_LOG(TS_OFF, VLEVEL_H, "CONFIRMED [%s]\r\n", (params->AckReceived != 0) ? "ACK" : "NACK");
 802cd38:	78e1      	ldrb	r1, [r4, #3]
 802cd3a:	4a0f      	ldr	r2, [pc, #60]	; (802cd78 <OnTxData+0x98>)
 802cd3c:	4b0f      	ldr	r3, [pc, #60]	; (802cd7c <OnTxData+0x9c>)
 802cd3e:	2900      	cmp	r1, #0
 802cd40:	bf08      	it	eq
 802cd42:	4613      	moveq	r3, r2
 802cd44:	2200      	movs	r2, #0
 802cd46:	9300      	str	r3, [sp, #0]
 802cd48:	4611      	mov	r1, r2
 802cd4a:	4b0d      	ldr	r3, [pc, #52]	; (802cd80 <OnTxData+0xa0>)
 802cd4c:	2003      	movs	r0, #3
 802cd4e:	f00d ffd5 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
}
 802cd52:	b004      	add	sp, #16
 802cd54:	bd10      	pop	{r4, pc}
        APP_LOG(TS_OFF, VLEVEL_H, "UNCONFIRMED\r\n");
 802cd56:	2200      	movs	r2, #0
 802cd58:	4b0a      	ldr	r3, [pc, #40]	; (802cd84 <OnTxData+0xa4>)
 802cd5a:	4611      	mov	r1, r2
 802cd5c:	2003      	movs	r0, #3
}
 802cd5e:	b004      	add	sp, #16
 802cd60:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        APP_LOG(TS_OFF, VLEVEL_H, "UNCONFIRMED\r\n");
 802cd64:	f00d bfca 	b.w	803acfc <UTIL_ADV_TRACE_COND_FSend>
 802cd68:	20003608 	.word	0x20003608
 802cd6c:	0803be83 	.word	0x0803be83
 802cd70:	0803beb4 	.word	0x0803beb4
 802cd74:	0803bee5 	.word	0x0803bee5
 802cd78:	0803be7e 	.word	0x0803be7e
 802cd7c:	0803be7f 	.word	0x0803be7f
 802cd80:	0803bef2 	.word	0x0803bef2
 802cd84:	0803bf03 	.word	0x0803bf03

0802cd88 <OnJoinRequest>:
{
 802cd88:	b570      	push	{r4, r5, r6, lr}
  if (joinParams != NULL)
 802cd8a:	4605      	mov	r5, r0
 802cd8c:	b320      	cbz	r0, 802cdd8 <OnJoinRequest+0x50>
    if (joinParams->Status == LORAMAC_HANDLER_SUCCESS)
 802cd8e:	f990 4001 	ldrsb.w	r4, [r0, #1]
 802cd92:	b9cc      	cbnz	r4, 802cdc8 <OnJoinRequest+0x40>
      UTIL_TIMER_Stop(&JoinLedTimer);
 802cd94:	4811      	ldr	r0, [pc, #68]	; (802cddc <OnJoinRequest+0x54>)
 802cd96:	f00e fad3 	bl	803b340 <UTIL_TIMER_Stop>
      BSP_LED_Off(LED_RED) ;
 802cd9a:	2002      	movs	r0, #2
 802cd9c:	f000 fa60 	bl	802d260 <BSP_LED_Off>
      APP_LOG(TS_OFF, VLEVEL_M, "\r\n###### = JOINED = ");
 802cda0:	4622      	mov	r2, r4
 802cda2:	4621      	mov	r1, r4
 802cda4:	4b0e      	ldr	r3, [pc, #56]	; (802cde0 <OnJoinRequest+0x58>)
 802cda6:	2002      	movs	r0, #2
 802cda8:	f00d ffa8 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
      if (joinParams->Mode == ACTIVATION_TYPE_ABP)
 802cdac:	78ab      	ldrb	r3, [r5, #2]
 802cdae:	2b01      	cmp	r3, #1
        APP_LOG(TS_OFF, VLEVEL_M, "OTAA =====================\r\n");
 802cdb0:	4622      	mov	r2, r4
 802cdb2:	4621      	mov	r1, r4
        APP_LOG(TS_OFF, VLEVEL_M, "ABP ======================\r\n");
 802cdb4:	bf0c      	ite	eq
 802cdb6:	4b0b      	ldreq	r3, [pc, #44]	; (802cde4 <OnJoinRequest+0x5c>)
        APP_LOG(TS_OFF, VLEVEL_M, "OTAA =====================\r\n");
 802cdb8:	4b0b      	ldrne	r3, [pc, #44]	; (802cde8 <OnJoinRequest+0x60>)
 802cdba:	2002      	movs	r0, #2
 802cdbc:	f00d ff9e 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
}
 802cdc0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      LmHandlerDeviceTimeReq();
 802cdc4:	f004 bacc 	b.w	8031360 <LmHandlerDeviceTimeReq>
      APP_LOG(TS_OFF, VLEVEL_M, "\r\n###### = JOIN FAILED\r\n");
 802cdc8:	2200      	movs	r2, #0
}
 802cdca:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      APP_LOG(TS_OFF, VLEVEL_M, "\r\n###### = JOIN FAILED\r\n");
 802cdce:	4b07      	ldr	r3, [pc, #28]	; (802cdec <OnJoinRequest+0x64>)
 802cdd0:	4611      	mov	r1, r2
 802cdd2:	2002      	movs	r0, #2
 802cdd4:	f00d bf92 	b.w	803acfc <UTIL_ADV_TRACE_COND_FSend>
}
 802cdd8:	bd70      	pop	{r4, r5, r6, pc}
 802cdda:	bf00      	nop
 802cddc:	20003620 	.word	0x20003620
 802cde0:	0803bf11 	.word	0x0803bf11
 802cde4:	0803bf26 	.word	0x0803bf26
 802cde8:	0803bf43 	.word	0x0803bf43
 802cdec:	0803bf60 	.word	0x0803bf60

0802cdf0 <SendTxData>:
{
 802cdf0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  AppData.Port = LORAWAN_USER_APP_PORT;
 802cdf2:	4814      	ldr	r0, [pc, #80]	; (802ce44 <SendTxData+0x54>)
  AppData.Buffer[j++] = 0;
 802cdf4:	6842      	ldr	r2, [r0, #4]
  UTIL_TIMER_Time_t nextTxIn = 0;
 802cdf6:	2400      	movs	r4, #0
  AppData.Port = LORAWAN_USER_APP_PORT;
 802cdf8:	2302      	movs	r3, #2
  UTIL_TIMER_Time_t nextTxIn = 0;
 802cdfa:	9403      	str	r4, [sp, #12]
  AppData.Port = LORAWAN_USER_APP_PORT;
 802cdfc:	7003      	strb	r3, [r0, #0]
  AppData.Buffer[j++] = 0;
 802cdfe:	7014      	strb	r4, [r2, #0]
  AppData.Buffer[j++] = 4;
 802ce00:	6842      	ldr	r2, [r0, #4]
 802ce02:	2104      	movs	r1, #4
 802ce04:	7051      	strb	r1, [r2, #1]
  AppData.BufferSize = j;
 802ce06:	7043      	strb	r3, [r0, #1]
  if (LORAMAC_HANDLER_SUCCESS == LmHandlerSend(&AppData, LORAWAN_DEFAULT_CONFIRMED_MSG_STATE, &nextTxIn, false))
 802ce08:	4621      	mov	r1, r4
 802ce0a:	4623      	mov	r3, r4
 802ce0c:	aa03      	add	r2, sp, #12
 802ce0e:	f004 fca5 	bl	803175c <LmHandlerSend>
 802ce12:	4601      	mov	r1, r0
 802ce14:	b930      	cbnz	r0, 802ce24 <SendTxData+0x34>
    APP_LOG(TS_ON, VLEVEL_L, "SEND REQUEST\r\n");
 802ce16:	2201      	movs	r2, #1
 802ce18:	4b0b      	ldr	r3, [pc, #44]	; (802ce48 <SendTxData+0x58>)
 802ce1a:	4610      	mov	r0, r2
 802ce1c:	f00d ff6e 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
}
 802ce20:	b004      	add	sp, #16
 802ce22:	bd10      	pop	{r4, pc}
  else if (nextTxIn > 0)
 802ce24:	9b03      	ldr	r3, [sp, #12]
 802ce26:	2b00      	cmp	r3, #0
 802ce28:	d0fa      	beq.n	802ce20 <SendTxData+0x30>
    APP_LOG(TS_ON, VLEVEL_L, "Next Tx in  : ~%d second(s)\r\n", (nextTxIn / 1000));
 802ce2a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 802ce2e:	fbb3 f3f2 	udiv	r3, r3, r2
 802ce32:	2201      	movs	r2, #1
 802ce34:	9300      	str	r3, [sp, #0]
 802ce36:	4621      	mov	r1, r4
 802ce38:	4b04      	ldr	r3, [pc, #16]	; (802ce4c <SendTxData+0x5c>)
 802ce3a:	4610      	mov	r0, r2
 802ce3c:	f00d ff5e 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
}
 802ce40:	e7ee      	b.n	802ce20 <SendTxData+0x30>
 802ce42:	bf00      	nop
 802ce44:	20003400 	.word	0x20003400
 802ce48:	0803bf79 	.word	0x0803bf79
 802ce4c:	0803bf88 	.word	0x0803bf88

0802ce50 <LoRaWAN_Init>:
{
 802ce50:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  BSP_LED_Init(LED_BLUE);
 802ce54:	2000      	movs	r0, #0
{
 802ce56:	b085      	sub	sp, #20
  BSP_LED_Init(LED_BLUE);
 802ce58:	f000 f9ce 	bl	802d1f8 <BSP_LED_Init>
  BSP_LED_Init(LED_GREEN);
 802ce5c:	2001      	movs	r0, #1
 802ce5e:	f000 f9cb 	bl	802d1f8 <BSP_LED_Init>
  BSP_LED_Init(LED_RED);
 802ce62:	2002      	movs	r0, #2
 802ce64:	f000 f9c8 	bl	802d1f8 <BSP_LED_Init>
  BSP_PB_Init(BUTTON_SW2, BUTTON_MODE_EXTI);
 802ce68:	2101      	movs	r1, #1
 802ce6a:	4608      	mov	r0, r1
 802ce6c:	f000 fa14 	bl	802d298 <BSP_PB_Init>
  APP_LOG(TS_OFF, VLEVEL_M, "APP_VERSION:        V%X.%X.%X\r\n",
 802ce70:	2501      	movs	r5, #1
 802ce72:	2200      	movs	r2, #0
 802ce74:	2304      	movs	r3, #4
 802ce76:	e9cd 5301 	strd	r5, r3, [sp, #4]
 802ce7a:	4611      	mov	r1, r2
 802ce7c:	4b34      	ldr	r3, [pc, #208]	; (802cf50 <LoRaWAN_Init+0x100>)
 802ce7e:	9500      	str	r5, [sp, #0]
 802ce80:	2002      	movs	r0, #2
  APP_LOG(TS_OFF, VLEVEL_M, "MW_LORAWAN_VERSION: V%X.%X.%X\r\n",
 802ce82:	2400      	movs	r4, #0
  APP_LOG(TS_OFF, VLEVEL_M, "APP_VERSION:        V%X.%X.%X\r\n",
 802ce84:	f00d ff3a 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
  APP_LOG(TS_OFF, VLEVEL_M, "MW_LORAWAN_VERSION: V%X.%X.%X\r\n",
 802ce88:	2702      	movs	r7, #2
  UTIL_TIMER_Create(&TxLedTimer, 0xFFFFFFFFU, UTIL_TIMER_ONESHOT, OnTxTimerLedEvent, NULL);
 802ce8a:	4e32      	ldr	r6, [pc, #200]	; (802cf54 <LoRaWAN_Init+0x104>)
  APP_LOG(TS_OFF, VLEVEL_M, "MW_LORAWAN_VERSION: V%X.%X.%X\r\n",
 802ce8c:	9700      	str	r7, [sp, #0]
 802ce8e:	2303      	movs	r3, #3
 802ce90:	e9cd 3401 	strd	r3, r4, [sp, #4]
 802ce94:	4622      	mov	r2, r4
 802ce96:	4621      	mov	r1, r4
 802ce98:	4b2f      	ldr	r3, [pc, #188]	; (802cf58 <LoRaWAN_Init+0x108>)
 802ce9a:	4638      	mov	r0, r7
 802ce9c:	f00d ff2e 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
  UTIL_TIMER_Create(&TxLedTimer, 0xFFFFFFFFU, UTIL_TIMER_ONESHOT, OnTxTimerLedEvent, NULL);
 802cea0:	f106 0930 	add.w	r9, r6, #48	; 0x30
  APP_LOG(TS_OFF, VLEVEL_M, "MW_RADIO_VERSION:   V%X.%X.%X\r\n",
 802cea4:	4622      	mov	r2, r4
 802cea6:	4621      	mov	r1, r4
 802cea8:	e9cd 5401 	strd	r5, r4, [sp, #4]
 802ceac:	4b2b      	ldr	r3, [pc, #172]	; (802cf5c <LoRaWAN_Init+0x10c>)
 802ceae:	9500      	str	r5, [sp, #0]
 802ceb0:	4638      	mov	r0, r7
 802ceb2:	f00d ff23 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
  UTIL_TIMER_Create(&RxLedTimer, 0xFFFFFFFFU, UTIL_TIMER_ONESHOT, OnRxTimerLedEvent, NULL);
 802ceb6:	f106 0818 	add.w	r8, r6, #24
  UTIL_TIMER_Create(&TxLedTimer, 0xFFFFFFFFU, UTIL_TIMER_ONESHOT, OnTxTimerLedEvent, NULL);
 802ceba:	4622      	mov	r2, r4
 802cebc:	4b28      	ldr	r3, [pc, #160]	; (802cf60 <LoRaWAN_Init+0x110>)
 802cebe:	9400      	str	r4, [sp, #0]
 802cec0:	f04f 31ff 	mov.w	r1, #4294967295
 802cec4:	4648      	mov	r0, r9
 802cec6:	f00e f9dd 	bl	803b284 <UTIL_TIMER_Create>
  UTIL_TIMER_Create(&JoinLedTimer, 0xFFFFFFFFU, UTIL_TIMER_PERIODIC, OnJoinTimerLedEvent, NULL);
 802ceca:	3648      	adds	r6, #72	; 0x48
  UTIL_TIMER_Create(&RxLedTimer, 0xFFFFFFFFU, UTIL_TIMER_ONESHOT, OnRxTimerLedEvent, NULL);
 802cecc:	4622      	mov	r2, r4
 802cece:	4b25      	ldr	r3, [pc, #148]	; (802cf64 <LoRaWAN_Init+0x114>)
 802ced0:	9400      	str	r4, [sp, #0]
 802ced2:	f04f 31ff 	mov.w	r1, #4294967295
 802ced6:	4640      	mov	r0, r8
 802ced8:	f00e f9d4 	bl	803b284 <UTIL_TIMER_Create>
  UTIL_TIMER_Create(&JoinLedTimer, 0xFFFFFFFFU, UTIL_TIMER_PERIODIC, OnJoinTimerLedEvent, NULL);
 802cedc:	4b22      	ldr	r3, [pc, #136]	; (802cf68 <LoRaWAN_Init+0x118>)
 802cede:	9400      	str	r4, [sp, #0]
 802cee0:	462a      	mov	r2, r5
 802cee2:	f04f 31ff 	mov.w	r1, #4294967295
 802cee6:	4630      	mov	r0, r6
 802cee8:	f00e f9cc 	bl	803b284 <UTIL_TIMER_Create>
  UTIL_TIMER_SetPeriod(&TxLedTimer, 500);
 802ceec:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 802cef0:	4648      	mov	r0, r9
 802cef2:	f00e faaf 	bl	803b454 <UTIL_TIMER_SetPeriod>
  UTIL_TIMER_SetPeriod(&RxLedTimer, 500);
 802cef6:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 802cefa:	4640      	mov	r0, r8
 802cefc:	f00e faaa 	bl	803b454 <UTIL_TIMER_SetPeriod>
  UTIL_TIMER_SetPeriod(&JoinLedTimer, 500);
 802cf00:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 802cf04:	4630      	mov	r0, r6
 802cf06:	f00e faa5 	bl	803b454 <UTIL_TIMER_SetPeriod>
  LmHandlerInit(&LmHandlerCallbacks);
 802cf0a:	f8df 8068 	ldr.w	r8, [pc, #104]	; 802cf74 <LoRaWAN_Init+0x124>
  UTIL_SEQ_RegTask((1 << CFG_SEQ_Task_LmHandlerProcess), UTIL_SEQ_RFU, LmHandlerProcess);
 802cf0e:	4a17      	ldr	r2, [pc, #92]	; (802cf6c <LoRaWAN_Init+0x11c>)
 802cf10:	4621      	mov	r1, r4
 802cf12:	4628      	mov	r0, r5
 802cf14:	f00e f8b6 	bl	803b084 <UTIL_SEQ_RegTask>
  UTIL_SEQ_RegTask((1 << CFG_SEQ_Task_LoRaSendOnTxTimerOrButtonEvent), UTIL_SEQ_RFU, SendTxData);
 802cf18:	4621      	mov	r1, r4
 802cf1a:	4a15      	ldr	r2, [pc, #84]	; (802cf70 <LoRaWAN_Init+0x120>)
 802cf1c:	4638      	mov	r0, r7
 802cf1e:	f00e f8b1 	bl	803b084 <UTIL_SEQ_RegTask>
  LoraInfo_Init();
 802cf22:	f000 f863 	bl	802cfec <LoraInfo_Init>
  LmHandlerInit(&LmHandlerCallbacks);
 802cf26:	f108 0008 	add.w	r0, r8, #8
 802cf2a:	f004 fdc9 	bl	8031ac0 <LmHandlerInit>
  LmHandlerConfigure(&LmHandlerParams);
 802cf2e:	f108 003c 	add.w	r0, r8, #60	; 0x3c
 802cf32:	f004 fa49 	bl	80313c8 <LmHandlerConfigure>
  UTIL_TIMER_Start(&JoinLedTimer);
 802cf36:	4630      	mov	r0, r6
 802cf38:	f00e fa52 	bl	803b3e0 <UTIL_TIMER_Start>
  LmHandlerJoin(ActivationType);
 802cf3c:	4638      	mov	r0, r7
 802cf3e:	f004 fbab 	bl	8031698 <LmHandlerJoin>
    BSP_PB_Init(BUTTON_SW1, BUTTON_MODE_EXTI);
 802cf42:	4629      	mov	r1, r5
 802cf44:	4620      	mov	r0, r4
}
 802cf46:	b005      	add	sp, #20
 802cf48:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    BSP_PB_Init(BUTTON_SW1, BUTTON_MODE_EXTI);
 802cf4c:	f000 b9a4 	b.w	802d298 <BSP_PB_Init>
 802cf50:	0803bfa6 	.word	0x0803bfa6
 802cf54:	200035d8 	.word	0x200035d8
 802cf58:	0803bfc6 	.word	0x0803bfc6
 802cf5c:	0803bfe6 	.word	0x0803bfe6
 802cf60:	0802ccd3 	.word	0x0802ccd3
 802cf64:	0802cccd 	.word	0x0802cccd
 802cf68:	0802ccd9 	.word	0x0802ccd9
 802cf6c:	08031579 	.word	0x08031579
 802cf70:	0802cdf1 	.word	0x0802cdf1
 802cf74:	20003400 	.word	0x20003400

0802cf78 <HAL_GPIO_EXTI_Callback>:
  switch (GPIO_Pin)
 802cf78:	2801      	cmp	r0, #1
 802cf7a:	d103      	bne.n	802cf84 <HAL_GPIO_EXTI_Callback+0xc>
      UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_LoRaSendOnTxTimerOrButtonEvent), CFG_SEQ_Prio_0);
 802cf7c:	2100      	movs	r1, #0
 802cf7e:	2002      	movs	r0, #2
 802cf80:	f00d bfd6 	b.w	803af30 <UTIL_SEQ_SetTask>
}
 802cf84:	4770      	bx	lr
	...

0802cf88 <SendTXStopFrag>:
void SendTXStopFrag(void){
 802cf88:	b530      	push	{r4, r5, lr}
	AppData.Port = 186;
 802cf8a:	4815      	ldr	r0, [pc, #84]	; (802cfe0 <SendTXStopFrag+0x58>)
 802cf8c:	23ba      	movs	r3, #186	; 0xba
void SendTXStopFrag(void){
 802cf8e:	b085      	sub	sp, #20
	AppData.Port = 186;
 802cf90:	7003      	strb	r3, [r0, #0]
	AppData.Buffer[i++] = 0;
 802cf92:	6843      	ldr	r3, [r0, #4]
	UTIL_TIMER_Time_t nextTxIn = 0;
 802cf94:	2400      	movs	r4, #0
 802cf96:	9403      	str	r4, [sp, #12]
	AppData.Buffer[i++] = 0;
 802cf98:	701c      	strb	r4, [r3, #0]
	AppData.Buffer[i++] = 1;
 802cf9a:	6843      	ldr	r3, [r0, #4]
 802cf9c:	2501      	movs	r5, #1
 802cf9e:	705d      	strb	r5, [r3, #1]
	AppData.BufferSize = i;
 802cfa0:	2302      	movs	r3, #2
 802cfa2:	7043      	strb	r3, [r0, #1]
	if (LORAMAC_HANDLER_SUCCESS == LmHandlerSend(&AppData, LORAWAN_DEFAULT_CONFIRMED_MSG_STATE, &nextTxIn, false))
 802cfa4:	aa03      	add	r2, sp, #12
 802cfa6:	4623      	mov	r3, r4
 802cfa8:	4621      	mov	r1, r4
 802cfaa:	f004 fbd7 	bl	803175c <LmHandlerSend>
 802cfae:	4602      	mov	r2, r0
 802cfb0:	b930      	cbnz	r0, 802cfc0 <SendTXStopFrag+0x38>
		APP_LOG(TS_OFF, VLEVEL_L, "\r\nFRAME SENT (added function to stop the fragmentation process)\r\n");
 802cfb2:	4601      	mov	r1, r0
 802cfb4:	4b0b      	ldr	r3, [pc, #44]	; (802cfe4 <SendTXStopFrag+0x5c>)
 802cfb6:	4628      	mov	r0, r5
 802cfb8:	f00d fea0 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
}
 802cfbc:	b005      	add	sp, #20
 802cfbe:	bd30      	pop	{r4, r5, pc}
	  else if (nextTxIn > 0)
 802cfc0:	9b03      	ldr	r3, [sp, #12]
 802cfc2:	2b00      	cmp	r3, #0
 802cfc4:	d0fa      	beq.n	802cfbc <SendTXStopFrag+0x34>
	    APP_LOG(TS_ON, VLEVEL_L, "Next Tx in  : ~%d second(s)\r\n", (nextTxIn / 1000));
 802cfc6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 802cfca:	4621      	mov	r1, r4
 802cfcc:	fbb3 f3f2 	udiv	r3, r3, r2
 802cfd0:	4628      	mov	r0, r5
 802cfd2:	9300      	str	r3, [sp, #0]
 802cfd4:	462a      	mov	r2, r5
 802cfd6:	4b04      	ldr	r3, [pc, #16]	; (802cfe8 <SendTXStopFrag+0x60>)
 802cfd8:	f00d fe90 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
}
 802cfdc:	e7ee      	b.n	802cfbc <SendTXStopFrag+0x34>
 802cfde:	bf00      	nop
 802cfe0:	20003400 	.word	0x20003400
 802cfe4:	0803c006 	.word	0x0803c006
 802cfe8:	0803bf88 	.word	0x0803bf88

0802cfec <LoraInfo_Init>:
/* Exported functions --------------------------------------------------------*/
void LoraInfo_Init(void)
{
  loraInfo.ActivationMode = 0;
  loraInfo.Region = 0;
  loraInfo.ClassB = 0;
 802cfec:	4b05      	ldr	r3, [pc, #20]	; (802d004 <LoraInfo_Init+0x18>)
#endif /* REGION_KR920 */
#ifdef  REGION_IN865
  loraInfo.Region |= (1 << LORAMAC_REGION_IN865) ;
#endif /* REGION_IN865 */
#ifdef  REGION_US915
  loraInfo.Region |= (1 << LORAMAC_REGION_US915) ;
 802cfee:	f44f 7290 	mov.w	r2, #288	; 0x120
 802cff2:	2100      	movs	r1, #0
 802cff4:	e9c3 2101 	strd	r2, r1, [r3, #4]

#if (!defined (LORAWAN_KMS) || (LORAWAN_KMS == 0))
  loraInfo.Kms = 0;
  loraInfo.ActivationMode = 3;
#else /* LORAWAN_KMS == 1 */
  loraInfo.Kms = 1;
 802cff8:	2201      	movs	r2, #1
 802cffa:	60da      	str	r2, [r3, #12]
  loraInfo.ActivationMode = ACTIVATION_BY_PERSONALIZATION + (OVER_THE_AIR_ACTIVATION << 1);
 802cffc:	2203      	movs	r2, #3
 802cffe:	601a      	str	r2, [r3, #0]
#endif /* LORAWAN_KMS */
  /* USER CODE BEGIN LoraInfo_Init_2 */

  /* USER CODE END LoraInfo_Init_2 */
}
 802d000:	4770      	bx	lr
 802d002:	bf00      	nop
 802d004:	2000372c 	.word	0x2000372c

0802d008 <LoraInfo_GetPtr>:
{
  /* USER CODE BEGIN LoraInfo_GetPtr */

  /* USER CODE END LoraInfo_GetPtr */
  return &loraInfo;
}
 802d008:	4800      	ldr	r0, [pc, #0]	; (802d00c <LoraInfo_GetPtr+0x4>)
 802d00a:	4770      	bx	lr
 802d00c:	2000372c 	.word	0x2000372c

0802d010 <FRAG_DECODER_IF_Erase>:

/* USER CODE END PFP */

/* Exported functions --------------------------------------------------------*/
int32_t FRAG_DECODER_IF_Erase(void)
{
 802d010:	b538      	push	{r3, r4, r5, lr}
  /* USER CODE END FRAG_DECODER_IF_Erase_1 */
  int32_t status = FLASH_OK;
#if (INTEROP_TEST_MODE == 1)
  UTIL_MEM_set_8(UnfragmentedData, 0xFF, UNFRAGMENTED_DATA_SIZE);
#else /* INTEROP_TEST_MODE == 0 */
  uint32_t first_page = PAGE(FRAG_DECODER_DWL_REGION_START);
 802d012:	4b16      	ldr	r3, [pc, #88]	; (802d06c <FRAG_DECODER_IF_Erase+0x5c>)
 802d014:	4c16      	ldr	r4, [pc, #88]	; (802d070 <FRAG_DECODER_IF_Erase+0x60>)
 802d016:	681b      	ldr	r3, [r3, #0]
 802d018:	4a16      	ldr	r2, [pc, #88]	; (802d074 <FRAG_DECODER_IF_Erase+0x64>)
 802d01a:	ea04 2383 	and.w	r3, r4, r3, lsl #10
 802d01e:	6894      	ldr	r4, [r2, #8]
  uint32_t nb_pages = PAGE(FRAG_DECODER_DWL_REGION_START + FRAG_DECODER_DWL_REGION_SIZE - 1) - first_page + 1U;
 802d020:	4a15      	ldr	r2, [pc, #84]	; (802d078 <FRAG_DECODER_IF_Erase+0x68>)
  uint32_t first_page = PAGE(FRAG_DECODER_DWL_REGION_START);
 802d022:	f104 4478 	add.w	r4, r4, #4160749568	; 0xf8000000
 802d026:	fbb4 f1f3 	udiv	r1, r4, r3
 802d02a:	fb03 4111 	mls	r1, r3, r1, r4
  uint32_t nb_pages = PAGE(FRAG_DECODER_DWL_REGION_START + FRAG_DECODER_DWL_REGION_SIZE - 1) - first_page + 1U;
 802d02e:	6894      	ldr	r4, [r2, #8]
 802d030:	f104 4278 	add.w	r2, r4, #4160749568	; 0xf8000000
 802d034:	fbb2 f4f3 	udiv	r4, r2, r3
 802d038:	fb03 2414 	mls	r4, r3, r4, r2
 802d03c:	0ae4      	lsrs	r4, r4, #11
 802d03e:	3401      	adds	r4, #1
  uint32_t first_page = PAGE(FRAG_DECODER_DWL_REGION_START);
 802d040:	0acd      	lsrs	r5, r1, #11
  uint32_t nb_pages = PAGE(FRAG_DECODER_DWL_REGION_START + FRAG_DECODER_DWL_REGION_SIZE - 1) - first_page + 1U;
 802d042:	eba4 24d1 	sub.w	r4, r4, r1, lsr #11

  if (HAL_FLASH_Unlock() == HAL_OK)
 802d046:	f001 f929 	bl	802e29c <HAL_FLASH_Unlock>
 802d04a:	4602      	mov	r2, r0
 802d04c:	b958      	cbnz	r0, 802d066 <FRAG_DECODER_IF_Erase+0x56>
  {
    status = FLASH_IF_EraseByPages(first_page, nb_pages, 0U);
 802d04e:	b2a1      	uxth	r1, r4
 802d050:	4628      	mov	r0, r5
 802d052:	f7ff f830 	bl	802c0b6 <FLASH_IF_EraseByPages>
 802d056:	4604      	mov	r4, r0
    /* Lock the Flash to disable the flash control register access (recommended
    to protect the FLASH memory against possible unwanted operation) *********/
    HAL_FLASH_Lock();
 802d058:	f001 f932 	bl	802e2c0 <HAL_FLASH_Lock>
  {
    status = FLASH_LOCK_ERROR;
  }

#endif /* INTEROP_TEST_MODE */
  if (status != FLASH_OK)
 802d05c:	1e20      	subs	r0, r4, #0
 802d05e:	bf18      	it	ne
 802d060:	2001      	movne	r0, #1
 802d062:	4240      	negs	r0, r0
  }
  return status;
  /* USER CODE BEGIN FRAG_DECODER_IF_Erase_2 */

  /* USER CODE END FRAG_DECODER_IF_Erase_2 */
}
 802d064:	bd38      	pop	{r3, r4, r5, pc}
    status = FLASH_ERROR;
 802d066:	f04f 30ff 	mov.w	r0, #4294967295
  return status;
 802d06a:	e7fb      	b.n	802d064 <FRAG_DECODER_IF_Erase+0x54>
 802d06c:	1fff75e0 	.word	0x1fff75e0
 802d070:	03fffc00 	.word	0x03fffc00
 802d074:	0803b928 	.word	0x0803b928
 802d078:	0803b918 	.word	0x0803b918

0802d07c <FRAG_DECODER_IF_Write>:

int32_t FRAG_DECODER_IF_Write(uint32_t addr, uint8_t *data, uint32_t size)
{
 802d07c:	b573      	push	{r0, r1, r4, r5, r6, lr}
 802d07e:	4604      	mov	r4, r0
 802d080:	460d      	mov	r5, r1
 802d082:	4616      	mov	r6, r2

#if (INTEROP_TEST_MODE == 1)  /*write fragment in RAM - Caching mode*/
  UTIL_MEM_cpy_8(&UnfragmentedData[addr], data, size);
#else /* INTEROP_TEST_MODE == 0 */

  if (HAL_FLASH_Unlock() == HAL_OK)
 802d084:	f001 f90a 	bl	802e29c <HAL_FLASH_Unlock>
 802d088:	b9b8      	cbnz	r0, 802d0ba <FRAG_DECODER_IF_Write+0x3e>
  {
    status = FLASH_IF_Write(FRAG_DECODER_DWL_REGION_START + addr, data, size, FRAG_DECODER_IF_RAM_buffer);
 802d08a:	480d      	ldr	r0, [pc, #52]	; (802d0c0 <FRAG_DECODER_IF_Write+0x44>)
 802d08c:	4b0d      	ldr	r3, [pc, #52]	; (802d0c4 <FRAG_DECODER_IF_Write+0x48>)
 802d08e:	6880      	ldr	r0, [r0, #8]
 802d090:	4632      	mov	r2, r6
 802d092:	4420      	add	r0, r4
 802d094:	4629      	mov	r1, r5
 802d096:	f7ff f825 	bl	802c0e4 <FLASH_IF_Write>
 802d09a:	4604      	mov	r4, r0
    HAL_FLASH_Lock();
 802d09c:	f001 f910 	bl	802e2c0 <HAL_FLASH_Lock>
  else
  {
    status = FLASH_LOCK_ERROR;
  }

  if (status != FLASH_OK)
 802d0a0:	b144      	cbz	r4, 802d0b4 <FRAG_DECODER_IF_Write+0x38>
  {
    APP_LOG(TS_OFF, VLEVEL_M, "\r\n....... !! FLASH_IF_WRITE_ERROR: %d !! .......\r\n", status);
 802d0a2:	2200      	movs	r2, #0
 802d0a4:	9400      	str	r4, [sp, #0]
 802d0a6:	4b08      	ldr	r3, [pc, #32]	; (802d0c8 <FRAG_DECODER_IF_Write+0x4c>)
 802d0a8:	4611      	mov	r1, r2
 802d0aa:	2002      	movs	r0, #2
 802d0ac:	f00d fe26 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
  }
#endif /* INTEROP_TEST_MODE */
  if (status != FLASH_OK)
  {
    status = FLASH_ERROR;
 802d0b0:	f04f 34ff 	mov.w	r4, #4294967295
  }
  return status;
  /* USER CODE BEGIN FRAG_DECODER_IF_Write_2 */

  /* USER CODE END FRAG_DECODER_IF_Write_2 */
}
 802d0b4:	4620      	mov	r0, r4
 802d0b6:	b002      	add	sp, #8
 802d0b8:	bd70      	pop	{r4, r5, r6, pc}
    status = FLASH_LOCK_ERROR;
 802d0ba:	f06f 0403 	mvn.w	r4, #3
 802d0be:	e7f0      	b.n	802d0a2 <FRAG_DECODER_IF_Write+0x26>
 802d0c0:	0803b928 	.word	0x0803b928
 802d0c4:	2000373c 	.word	0x2000373c
 802d0c8:	0803c07a 	.word	0x0803c07a

0802d0cc <FRAG_DECODER_IF_OnProgress>:

  /* USER CODE END FRAG_DECODER_IF_Read_2 */
}

void FRAG_DECODER_IF_OnProgress(uint16_t fragCounter, uint16_t fragNb, uint8_t fragSize, uint16_t fragNbLost)
{
 802d0cc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 802d0ce:	4614      	mov	r4, r2
  /* USER CODE BEGIN FRAG_DECODER_IF_OnProgress_1 */

  /* USER CODE END FRAG_DECODER_IF_OnProgress_1 */
  APP_LOG(TS_OFF, VLEVEL_M, "\r\n....... FRAG_DECODER in Progress .......\r\n");
 802d0d0:	2200      	movs	r2, #0
{
 802d0d2:	4606      	mov	r6, r0
 802d0d4:	460d      	mov	r5, r1
 802d0d6:	461f      	mov	r7, r3
  APP_LOG(TS_OFF, VLEVEL_M, "\r\n....... FRAG_DECODER in Progress .......\r\n");
 802d0d8:	4611      	mov	r1, r2
 802d0da:	4b0f      	ldr	r3, [pc, #60]	; (802d118 <FRAG_DECODER_IF_OnProgress+0x4c>)
 802d0dc:	2002      	movs	r0, #2
 802d0de:	f00d fe0d 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
  APP_LOG(TS_OFF, VLEVEL_M, "RECEIVED    : %5d / %5d Fragments\r\n", fragCounter, fragNb);
 802d0e2:	2200      	movs	r2, #0
 802d0e4:	e9cd 6500 	strd	r6, r5, [sp]
 802d0e8:	4611      	mov	r1, r2
 802d0ea:	4b0c      	ldr	r3, [pc, #48]	; (802d11c <FRAG_DECODER_IF_OnProgress+0x50>)
 802d0ec:	2002      	movs	r0, #2
 802d0ee:	f00d fe05 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
  APP_LOG(TS_OFF, VLEVEL_M, "              %5d / %5d Bytes\r\n", fragCounter * fragSize, fragNb * fragSize);
 802d0f2:	4365      	muls	r5, r4
 802d0f4:	2200      	movs	r2, #0
 802d0f6:	4374      	muls	r4, r6
 802d0f8:	4611      	mov	r1, r2
 802d0fa:	4b09      	ldr	r3, [pc, #36]	; (802d120 <FRAG_DECODER_IF_OnProgress+0x54>)
 802d0fc:	9501      	str	r5, [sp, #4]
 802d0fe:	9400      	str	r4, [sp, #0]
 802d100:	2002      	movs	r0, #2
 802d102:	f00d fdfb 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
  APP_LOG(TS_OFF, VLEVEL_M, "LOST        :       %7d Fragments\r\n\r\n", fragNbLost);
 802d106:	2200      	movs	r2, #0
 802d108:	4b06      	ldr	r3, [pc, #24]	; (802d124 <FRAG_DECODER_IF_OnProgress+0x58>)
 802d10a:	9700      	str	r7, [sp, #0]
 802d10c:	4611      	mov	r1, r2
 802d10e:	2002      	movs	r0, #2
 802d110:	f00d fdf4 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
  BSP_LED_Toggle(LED_BLUE);
#endif /* INTEROP_TEST_MODE == 1 */
  /* USER CODE BEGIN FRAG_DECODER_IF_OnProgress_2 */

  /* USER CODE END FRAG_DECODER_IF_OnProgress_2 */
}
 802d114:	b003      	add	sp, #12
 802d116:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802d118:	0803c0ad 	.word	0x0803c0ad
 802d11c:	0803c0da 	.word	0x0803c0da
 802d120:	0803c0fe 	.word	0x0803c0fe
 802d124:	0803c11e 	.word	0x0803c11e

0802d128 <FRAG_DECODER_IF_Read>:
{
 802d128:	b508      	push	{r3, lr}
 802d12a:	460b      	mov	r3, r1
  UTIL_MEM_cpy_8(data, (void *)(FRAG_DECODER_DWL_REGION_START + addr), size);
 802d12c:	4904      	ldr	r1, [pc, #16]	; (802d140 <FRAG_DECODER_IF_Read+0x18>)
 802d12e:	6889      	ldr	r1, [r1, #8]
 802d130:	b292      	uxth	r2, r2
 802d132:	4401      	add	r1, r0
 802d134:	4618      	mov	r0, r3
 802d136:	f00d fee9 	bl	803af0c <UTIL_MEM_cpy_8>
}
 802d13a:	2000      	movs	r0, #0
 802d13c:	bd08      	pop	{r3, pc}
 802d13e:	bf00      	nop
 802d140:	0803b928 	.word	0x0803b928

0802d144 <FRAG_DECODER_IF_OnDone>:

void FRAG_DECODER_IF_OnDone(int32_t status, uint32_t size)
{
 802d144:	b513      	push	{r0, r1, r4, lr}
  /* USER CODE BEGIN FRAG_DECODER_IF_OnDone_1 */

  /* USER CODE END FRAG_DECODER_IF_OnDone_1 */
  APP_LOG(TS_OFF, VLEVEL_M, "\r\n....... FRAG_DECODER Finished .......\r\n");
 802d146:	2200      	movs	r2, #0
{
 802d148:	4604      	mov	r4, r0
  APP_LOG(TS_OFF, VLEVEL_M, "\r\n....... FRAG_DECODER Finished .......\r\n");
 802d14a:	4611      	mov	r1, r2
 802d14c:	4b08      	ldr	r3, [pc, #32]	; (802d170 <FRAG_DECODER_IF_OnDone+0x2c>)
 802d14e:	2002      	movs	r0, #2
 802d150:	f00d fdd4 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
  APP_LOG(TS_OFF, VLEVEL_M, "STATUS      : %d\r\n", status);
 802d154:	2200      	movs	r2, #0
 802d156:	4b07      	ldr	r3, [pc, #28]	; (802d174 <FRAG_DECODER_IF_OnDone+0x30>)
 802d158:	9400      	str	r4, [sp, #0]
 802d15a:	4611      	mov	r1, r2
 802d15c:	2002      	movs	r0, #2
 802d15e:	f00d fdcd 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>

#if (INTEROP_TEST_MODE == 0)
  /* Send a frame to signal the AS that the end-device has already rebuilt the whole data block */
  SendTXStopFrag();
 802d162:	f7ff ff11 	bl	802cf88 <SendTXStopFrag>
  BSP_LED_Off(LED_BLUE);
#endif /* INTEROP_TEST_MODE == 1 */
  /* USER CODE BEGIN FRAG_DECODER_IF_OnDone_2 */

  /* USER CODE END FRAG_DECODER_IF_OnDone_2 */
}
 802d166:	b002      	add	sp, #8
 802d168:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  FwUpdateAgent_Run();
 802d16c:	f7ff bcea 	b.w	802cb44 <FwUpdateAgent_Run>
 802d170:	0803c144 	.word	0x0803c144
 802d174:	0803c16e 	.word	0x0803c16e

0802d178 <RBI_Init>:
   *       or at https://github.com/STMicroelectronics/STM32CubeWL/tree/main/Drivers/BSP/STM32WLxx_Nucleo/
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration */
  return BSP_RADIO_Init();
 802d178:	f000 b8e6 	b.w	802d348 <BSP_RADIO_Init>

0802d17c <RBI_ConfigRFSwitch>:
   *       or at https://github.com/STMicroelectronics/STM32CubeWL/tree/main/Drivers/BSP/STM32WLxx_Nucleo/
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration */
  return BSP_RADIO_ConfigRFSwitch((BSP_RADIO_Switch_TypeDef) Config);
 802d17c:	f000 b924 	b.w	802d3c8 <BSP_RADIO_ConfigRFSwitch>

0802d180 <RBI_GetTxConfig>:
   *       or at https://github.com/STMicroelectronics/STM32CubeWL/tree/main/Drivers/BSP/STM32WLxx_Nucleo/
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration */
  return BSP_RADIO_GetTxConfig();
 802d180:	f000 b956 	b.w	802d430 <BSP_RADIO_GetTxConfig>

0802d184 <RBI_IsTCXO>:
   *       or at https://github.com/STMicroelectronics/STM32CubeWL/tree/main/Drivers/BSP/STM32WLxx_Nucleo/
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration */
  return BSP_RADIO_IsTCXO();
 802d184:	f000 b956 	b.w	802d434 <BSP_RADIO_IsTCXO>

0802d188 <RBI_IsDCDC>:
   *       or at https://github.com/STMicroelectronics/STM32CubeWL/tree/main/Drivers/BSP/STM32WLxx_Nucleo/
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration */
  return BSP_RADIO_IsDCDC();
 802d188:	f000 b956 	b.w	802d438 <BSP_RADIO_IsDCDC>

0802d18c <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 802d18c:	480d      	ldr	r0, [pc, #52]	; (802d1c4 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 802d18e:	4685      	mov	sp, r0

/* Call the clock system initialization function.*/
  bl  SystemInit
 802d190:	f000 f954 	bl	802d43c <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 802d194:	480c      	ldr	r0, [pc, #48]	; (802d1c8 <LoopForever+0x6>)
  ldr r1, =_edata
 802d196:	490d      	ldr	r1, [pc, #52]	; (802d1cc <LoopForever+0xa>)
  ldr r2, =_sidata
 802d198:	4a0d      	ldr	r2, [pc, #52]	; (802d1d0 <LoopForever+0xe>)
  movs r3, #0
 802d19a:	2300      	movs	r3, #0
  b LoopCopyDataInit
 802d19c:	e002      	b.n	802d1a4 <LoopCopyDataInit>

0802d19e <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 802d19e:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 802d1a0:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 802d1a2:	3304      	adds	r3, #4

0802d1a4 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 802d1a4:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 802d1a6:	428c      	cmp	r4, r1
  bcc CopyDataInit
 802d1a8:	d3f9      	bcc.n	802d19e <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 802d1aa:	4a0a      	ldr	r2, [pc, #40]	; (802d1d4 <LoopForever+0x12>)
  ldr r4, =_ebss
 802d1ac:	4c0a      	ldr	r4, [pc, #40]	; (802d1d8 <LoopForever+0x16>)
  movs r3, #0
 802d1ae:	2300      	movs	r3, #0
  b LoopFillZerobss
 802d1b0:	e001      	b.n	802d1b6 <LoopFillZerobss>

0802d1b2 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 802d1b2:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 802d1b4:	3204      	adds	r2, #4

0802d1b6 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 802d1b6:	42a2      	cmp	r2, r4
  bcc FillZerobss
 802d1b8:	d3fb      	bcc.n	802d1b2 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 802d1ba:	f00e fac1 	bl	803b740 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 802d1be:	f7ff f86d 	bl	802c29c <main>

0802d1c2 <LoopForever>:

LoopForever:
    b LoopForever
 802d1c2:	e7fe      	b.n	802d1c2 <LoopForever>
  ldr   r0, =_estack
 802d1c4:	20008000 	.word	0x20008000
  ldr r0, =_sdata
 802d1c8:	20003400 	.word	0x20003400
  ldr r1, =_edata
 802d1cc:	200035ac 	.word	0x200035ac
  ldr r2, =_sidata
 802d1d0:	0803c620 	.word	0x0803c620
  ldr r2, =_sbss
 802d1d4:	200035ac 	.word	0x200035ac
  ldr r4, =_ebss
 802d1d8:	200063ac 	.word	0x200063ac

0802d1dc <ADC_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 802d1dc:	e7fe      	b.n	802d1dc <ADC_IRQHandler>

0802d1de <LL_AHB2_GRP1_EnableClock>:
  SET_BIT(RCC->AHB2ENR, Periphs);
 802d1de:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
{
 802d1e2:	b082      	sub	sp, #8
  SET_BIT(RCC->AHB2ENR, Periphs);
 802d1e4:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 802d1e6:	4302      	orrs	r2, r0
 802d1e8:	64da      	str	r2, [r3, #76]	; 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 802d1ea:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 802d1ec:	4018      	ands	r0, r3
 802d1ee:	9001      	str	r0, [sp, #4]
  (void)tmpreg;
 802d1f0:	9b01      	ldr	r3, [sp, #4]
}
 802d1f2:	b002      	add	sp, #8
 802d1f4:	4770      	bx	lr
	...

0802d1f8 <BSP_LED_Init>:
  *            @arg LED2
  *            @arg LED3
  * @retval BSP status
  */
int32_t BSP_LED_Init(Led_TypeDef Led)
{
 802d1f8:	b570      	push	{r4, r5, r6, lr}
 802d1fa:	b086      	sub	sp, #24
 802d1fc:	4604      	mov	r4, r0
  GPIO_InitTypeDef  gpio_init_structure = {0};
 802d1fe:	2214      	movs	r2, #20
 802d200:	2100      	movs	r1, #0
 802d202:	a801      	add	r0, sp, #4
 802d204:	f00e fac0 	bl	803b788 <memset>
  
  /* Enable the GPIO_LED Clock */
  LEDx_GPIO_CLK_ENABLE(Led);
 802d208:	2002      	movs	r0, #2
 802d20a:	f7ff ffe8 	bl	802d1de <LL_AHB2_GRP1_EnableClock>

  /* Configure the GPIO_LED pin */
  gpio_init_structure.Pin = LED_PIN[Led];
 802d20e:	4b0c      	ldr	r3, [pc, #48]	; (802d240 <BSP_LED_Init+0x48>)
 802d210:	f833 6014 	ldrh.w	r6, [r3, r4, lsl #1]
 802d214:	9601      	str	r6, [sp, #4]
  gpio_init_structure.Mode = GPIO_MODE_OUTPUT_PP;
  gpio_init_structure.Pull = GPIO_NOPULL;
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;
  
  HAL_GPIO_Init(LED_PORT[Led], &gpio_init_structure);
 802d216:	eb03 0384 	add.w	r3, r3, r4, lsl #2
  gpio_init_structure.Pull = GPIO_NOPULL;
 802d21a:	2500      	movs	r5, #0
  HAL_GPIO_Init(LED_PORT[Led], &gpio_init_structure);
 802d21c:	689c      	ldr	r4, [r3, #8]
  gpio_init_structure.Pull = GPIO_NOPULL;
 802d21e:	2201      	movs	r2, #1
 802d220:	e9cd 2502 	strd	r2, r5, [sp, #8]
  HAL_GPIO_Init(LED_PORT[Led], &gpio_init_structure);
 802d224:	a901      	add	r1, sp, #4
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;
 802d226:	2202      	movs	r2, #2
  HAL_GPIO_Init(LED_PORT[Led], &gpio_init_structure);
 802d228:	4620      	mov	r0, r4
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;
 802d22a:	9204      	str	r2, [sp, #16]
  HAL_GPIO_Init(LED_PORT[Led], &gpio_init_structure);
 802d22c:	f001 f948 	bl	802e4c0 <HAL_GPIO_Init>
  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_RESET);
 802d230:	4620      	mov	r0, r4
 802d232:	462a      	mov	r2, r5
 802d234:	4631      	mov	r1, r6
 802d236:	f001 fa63 	bl	802e700 <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
}
 802d23a:	4628      	mov	r0, r5
 802d23c:	b006      	add	sp, #24
 802d23e:	bd70      	pop	{r4, r5, r6, pc}
 802d240:	0803b974 	.word	0x0803b974

0802d244 <BSP_LED_On>:
  *            @arg LED3
  * @retval BSP status
  */
int32_t BSP_LED_On(Led_TypeDef Led)
{
  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_SET); 
 802d244:	4b05      	ldr	r3, [pc, #20]	; (802d25c <BSP_LED_On+0x18>)
{
 802d246:	b510      	push	{r4, lr}
  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_SET); 
 802d248:	eb03 0480 	add.w	r4, r3, r0, lsl #2
 802d24c:	f833 1010 	ldrh.w	r1, [r3, r0, lsl #1]
 802d250:	68a0      	ldr	r0, [r4, #8]
 802d252:	2201      	movs	r2, #1
 802d254:	f001 fa54 	bl	802e700 <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
}
 802d258:	2000      	movs	r0, #0
 802d25a:	bd10      	pop	{r4, pc}
 802d25c:	0803b974 	.word	0x0803b974

0802d260 <BSP_LED_Off>:
  *            @arg LED3
  * @retval BSP status
  */
int32_t BSP_LED_Off(Led_TypeDef Led)
{
  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_RESET); 
 802d260:	4b05      	ldr	r3, [pc, #20]	; (802d278 <BSP_LED_Off+0x18>)
{
 802d262:	b510      	push	{r4, lr}
  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_RESET); 
 802d264:	eb03 0480 	add.w	r4, r3, r0, lsl #2
 802d268:	f833 1010 	ldrh.w	r1, [r3, r0, lsl #1]
 802d26c:	68a0      	ldr	r0, [r4, #8]
 802d26e:	2200      	movs	r2, #0
 802d270:	f001 fa46 	bl	802e700 <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
}
 802d274:	2000      	movs	r0, #0
 802d276:	bd10      	pop	{r4, pc}
 802d278:	0803b974 	.word	0x0803b974

0802d27c <BSP_LED_Toggle>:
  *            @arg LED2
  *            @arg LED3
  * @retval BSP status
  */
int32_t BSP_LED_Toggle(Led_TypeDef Led)
{
 802d27c:	b508      	push	{r3, lr}
  HAL_GPIO_TogglePin(LED_PORT[Led], LED_PIN[Led]);
 802d27e:	4b05      	ldr	r3, [pc, #20]	; (802d294 <BSP_LED_Toggle+0x18>)
 802d280:	eb03 0280 	add.w	r2, r3, r0, lsl #2
 802d284:	f833 1010 	ldrh.w	r1, [r3, r0, lsl #1]
 802d288:	6890      	ldr	r0, [r2, #8]
 802d28a:	f001 fa3e 	bl	802e70a <HAL_GPIO_TogglePin>

  return BSP_ERROR_NONE;
}
 802d28e:	2000      	movs	r0, #0
 802d290:	bd08      	pop	{r3, pc}
 802d292:	bf00      	nop
 802d294:	0803b974 	.word	0x0803b974

0802d298 <BSP_PB_Init>:
  *     @arg BUTTON_MODE_EXTI: Button will be connected to EXTI line with interrupt
  *                            generation capability  
  * @retval BSP status
  */
int32_t BSP_PB_Init(Button_TypeDef Button, ButtonMode_TypeDef ButtonMode)
{
 802d298:	b5f0      	push	{r4, r5, r6, r7, lr}
 802d29a:	b087      	sub	sp, #28
 802d29c:	4604      	mov	r4, r0
 802d29e:	460f      	mov	r7, r1
  GPIO_InitTypeDef gpio_init_structure = {0};
 802d2a0:	2214      	movs	r2, #20
 802d2a2:	2100      	movs	r1, #0
 802d2a4:	a801      	add	r0, sp, #4
 802d2a6:	f00e fa6f 	bl	803b788 <memset>
  static BSP_EXTI_LineCallback button_callback[BUTTONn] = {BUTTON_SW1_EXTI_Callback, BUTTON_SW2_EXTI_Callback, BUTTON_SW3_EXTI_Callback};
  static uint32_t button_interrupt_priority[BUTTONn] = {BSP_BUTTON_SWx_IT_PRIORITY, BSP_BUTTON_SWx_IT_PRIORITY, BSP_BUTTON_SWx_IT_PRIORITY};
  static const uint32_t button_exti_line[BUTTONn] = {BUTTON_SW1_EXTI_LINE, BUTTON_SW2_EXTI_LINE, BUTTON_SW3_EXTI_LINE};

  /* Enable the BUTTON Clock */
  BUTTONx_GPIO_CLK_ENABLE(Button);
 802d2aa:	2c01      	cmp	r4, #1
 802d2ac:	d816      	bhi.n	802d2dc <BSP_PB_Init+0x44>
 802d2ae:	2001      	movs	r0, #1
 802d2b0:	f7ff ff95 	bl	802d1de <LL_AHB2_GRP1_EnableClock>
  
  gpio_init_structure.Pin = BUTTON_PIN[Button];
 802d2b4:	4d1a      	ldr	r5, [pc, #104]	; (802d320 <BSP_PB_Init+0x88>)
 802d2b6:	eb05 0344 	add.w	r3, r5, r4, lsl #1
 802d2ba:	eb05 0684 	add.w	r6, r5, r4, lsl #2
 802d2be:	8a9b      	ldrh	r3, [r3, #20]
 802d2c0:	9301      	str	r3, [sp, #4]
  gpio_init_structure.Pull = GPIO_PULLUP;
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;
 802d2c2:	2201      	movs	r2, #1
 802d2c4:	2302      	movs	r3, #2
 802d2c6:	e9cd 2303 	strd	r2, r3, [sp, #12]

  if(ButtonMode == BUTTON_MODE_GPIO)
 802d2ca:	69f0      	ldr	r0, [r6, #28]
 802d2cc:	b957      	cbnz	r7, 802d2e4 <BSP_PB_Init+0x4c>
  {
    /* Configure Button pin as input */
    gpio_init_structure.Mode = GPIO_MODE_INPUT;
    HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
 802d2ce:	a901      	add	r1, sp, #4
    gpio_init_structure.Mode = GPIO_MODE_INPUT;
 802d2d0:	9702      	str	r7, [sp, #8]
    HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
 802d2d2:	f001 f8f5 	bl	802e4c0 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority((BUTTON_IRQn[Button]), button_interrupt_priority[Button], 0x00);
    HAL_NVIC_EnableIRQ((BUTTON_IRQn[Button]));
  }

  return BSP_ERROR_NONE;
}
 802d2d6:	2000      	movs	r0, #0
 802d2d8:	b007      	add	sp, #28
 802d2da:	bdf0      	pop	{r4, r5, r6, r7, pc}
  BUTTONx_GPIO_CLK_ENABLE(Button);
 802d2dc:	2c02      	cmp	r4, #2
 802d2de:	d1e9      	bne.n	802d2b4 <BSP_PB_Init+0x1c>
 802d2e0:	2004      	movs	r0, #4
 802d2e2:	e7e5      	b.n	802d2b0 <BSP_PB_Init+0x18>
    (void)HAL_EXTI_GetHandle(&hpb_exti[Button], button_exti_line[Button]);
 802d2e4:	4f0f      	ldr	r7, [pc, #60]	; (802d324 <BSP_PB_Init+0x8c>)
    gpio_init_structure.Mode = GPIO_MODE_IT_FALLING;
 802d2e6:	f44f 1304 	mov.w	r3, #2162688	; 0x210000
    (void)HAL_EXTI_GetHandle(&hpb_exti[Button], button_exti_line[Button]);
 802d2ea:	eb07 07c4 	add.w	r7, r7, r4, lsl #3
    HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
 802d2ee:	a901      	add	r1, sp, #4
    gpio_init_structure.Mode = GPIO_MODE_IT_FALLING;
 802d2f0:	9302      	str	r3, [sp, #8]
    HAL_NVIC_SetPriority((BUTTON_IRQn[Button]), button_interrupt_priority[Button], 0x00);
 802d2f2:	442c      	add	r4, r5
    HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
 802d2f4:	f001 f8e4 	bl	802e4c0 <HAL_GPIO_Init>
    (void)HAL_EXTI_GetHandle(&hpb_exti[Button], button_exti_line[Button]);
 802d2f8:	6ab1      	ldr	r1, [r6, #40]	; 0x28
 802d2fa:	4638      	mov	r0, r7
 802d2fc:	f000 ffaf 	bl	802e25e <HAL_EXTI_GetHandle>
    (void)HAL_EXTI_RegisterCallback(&hpb_exti[Button],  HAL_EXTI_COMMON_CB_ID, button_callback[Button]);
 802d300:	6b72      	ldr	r2, [r6, #52]	; 0x34
 802d302:	2100      	movs	r1, #0
 802d304:	4638      	mov	r0, r7
 802d306:	f000 ffa3 	bl	802e250 <HAL_EXTI_RegisterCallback>
    HAL_NVIC_SetPriority((BUTTON_IRQn[Button]), button_interrupt_priority[Button], 0x00);
 802d30a:	f994 4040 	ldrsb.w	r4, [r4, #64]	; 0x40
 802d30e:	6c71      	ldr	r1, [r6, #68]	; 0x44
 802d310:	4620      	mov	r0, r4
 802d312:	2200      	movs	r2, #0
 802d314:	f000 fd26 	bl	802dd64 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ((BUTTON_IRQn[Button]));
 802d318:	4620      	mov	r0, r4
 802d31a:	f000 fd55 	bl	802ddc8 <HAL_NVIC_EnableIRQ>
 802d31e:	e7da      	b.n	802d2d6 <BSP_PB_Init+0x3e>
 802d320:	0803b974 	.word	0x0803b974
 802d324:	200062f0 	.word	0x200062f0

0802d328 <BSP_PB_Callback>:
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Button);

  /* This function should be implemented by the user application.
     It is called into this driver when an event on Button is triggered. */
}
 802d328:	4770      	bx	lr

0802d32a <BUTTON_SW3_EXTI_Callback>:
/**
  * @brief  Button SW3 EXTI line detection callback.
  * @retval None
  */
static void BUTTON_SW3_EXTI_Callback(void)
{
 802d32a:	b508      	push	{r3, lr}
  BSP_PB_Callback(BUTTON_SW3);
 802d32c:	2002      	movs	r0, #2
 802d32e:	f7ff fffb 	bl	802d328 <BSP_PB_Callback>
}
 802d332:	bd08      	pop	{r3, pc}

0802d334 <BUTTON_SW2_EXTI_Callback>:
{
 802d334:	b508      	push	{r3, lr}
  BSP_PB_Callback(BUTTON_SW2);
 802d336:	2001      	movs	r0, #1
 802d338:	f7ff fff6 	bl	802d328 <BSP_PB_Callback>
}
 802d33c:	bd08      	pop	{r3, pc}

0802d33e <BUTTON_SW1_EXTI_Callback>:
{
 802d33e:	b508      	push	{r3, lr}
  BSP_PB_Callback(BUTTON_SW1);
 802d340:	2000      	movs	r0, #0
 802d342:	f7ff fff1 	bl	802d328 <BSP_PB_Callback>
}
 802d346:	bd08      	pop	{r3, pc}

0802d348 <BSP_RADIO_Init>:
/**
  * @brief  Init Radio Switch 
  * @retval BSP status
  */
int32_t BSP_RADIO_Init(void)
{
 802d348:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802d34c:	b086      	sub	sp, #24
  GPIO_InitTypeDef  gpio_init_structure = {0};
 802d34e:	2400      	movs	r4, #0
  SET_BIT(RCC->AHB2ENR, Periphs);
 802d350:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802d354:	9405      	str	r4, [sp, #20]
 802d356:	6cda      	ldr	r2, [r3, #76]	; 0x4c
  gpio_init_structure.Pin   = RF_SW_CTRL1_PIN;
  gpio_init_structure.Mode  = GPIO_MODE_OUTPUT_PP;
  gpio_init_structure.Pull  = GPIO_NOPULL;
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  
  HAL_GPIO_Init(RF_SW_CTRL1_GPIO_PORT, &gpio_init_structure);
 802d358:	4d1a      	ldr	r5, [pc, #104]	; (802d3c4 <BSP_RADIO_Init+0x7c>)
 802d35a:	f042 0204 	orr.w	r2, r2, #4
 802d35e:	64da      	str	r2, [r3, #76]	; 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 802d360:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  gpio_init_structure.Pull  = GPIO_NOPULL;
 802d362:	9403      	str	r4, [sp, #12]
 802d364:	f003 0304 	and.w	r3, r3, #4
 802d368:	9300      	str	r3, [sp, #0]
  (void)tmpreg;
 802d36a:	9b00      	ldr	r3, [sp, #0]
  gpio_init_structure.Mode  = GPIO_MODE_OUTPUT_PP;
 802d36c:	2710      	movs	r7, #16
 802d36e:	2301      	movs	r3, #1
 802d370:	e9cd 7301 	strd	r7, r3, [sp, #4]
  HAL_GPIO_Init(RF_SW_CTRL1_GPIO_PORT, &gpio_init_structure);
 802d374:	a901      	add	r1, sp, #4
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 802d376:	2303      	movs	r3, #3
  HAL_GPIO_Init(RF_SW_CTRL1_GPIO_PORT, &gpio_init_structure);
 802d378:	4628      	mov	r0, r5
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 802d37a:	9304      	str	r3, [sp, #16]
  
  gpio_init_structure.Pin = RF_SW_CTRL2_PIN;
 802d37c:	f04f 0820 	mov.w	r8, #32
  HAL_GPIO_Init(RF_SW_CTRL1_GPIO_PORT, &gpio_init_structure);
 802d380:	f001 f89e 	bl	802e4c0 <HAL_GPIO_Init>
  HAL_GPIO_Init(RF_SW_CTRL2_GPIO_PORT, &gpio_init_structure);
 802d384:	a901      	add	r1, sp, #4
 802d386:	4628      	mov	r0, r5
  
  gpio_init_structure.Pin = RF_SW_CTRL3_PIN;
 802d388:	2608      	movs	r6, #8
  gpio_init_structure.Pin = RF_SW_CTRL2_PIN;
 802d38a:	f8cd 8004 	str.w	r8, [sp, #4]
  HAL_GPIO_Init(RF_SW_CTRL2_GPIO_PORT, &gpio_init_structure);
 802d38e:	f001 f897 	bl	802e4c0 <HAL_GPIO_Init>
  HAL_GPIO_Init(RF_SW_CTRL3_GPIO_PORT, &gpio_init_structure);
 802d392:	a901      	add	r1, sp, #4
 802d394:	4628      	mov	r0, r5
  gpio_init_structure.Pin = RF_SW_CTRL3_PIN;
 802d396:	9601      	str	r6, [sp, #4]
  HAL_GPIO_Init(RF_SW_CTRL3_GPIO_PORT, &gpio_init_structure);
 802d398:	f001 f892 	bl	802e4c0 <HAL_GPIO_Init>

  HAL_GPIO_WritePin(RF_SW_CTRL2_GPIO_PORT, RF_SW_CTRL2_PIN, GPIO_PIN_RESET); 
 802d39c:	4622      	mov	r2, r4
 802d39e:	4641      	mov	r1, r8
 802d3a0:	4628      	mov	r0, r5
 802d3a2:	f001 f9ad 	bl	802e700 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_RESET); 
 802d3a6:	4622      	mov	r2, r4
 802d3a8:	4639      	mov	r1, r7
 802d3aa:	4628      	mov	r0, r5
 802d3ac:	f001 f9a8 	bl	802e700 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_RESET); 
 802d3b0:	4628      	mov	r0, r5
 802d3b2:	4622      	mov	r2, r4
 802d3b4:	4631      	mov	r1, r6
 802d3b6:	f001 f9a3 	bl	802e700 <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
}
 802d3ba:	4620      	mov	r0, r4
 802d3bc:	b006      	add	sp, #24
 802d3be:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802d3c2:	bf00      	nop
 802d3c4:	48000800 	.word	0x48000800

0802d3c8 <BSP_RADIO_ConfigRFSwitch>:
  *           @arg RADIO_SWITCH_RFO_LP
  *           @arg RADIO_SWITCH_RFO_HP
  * @retval BSP status
  */
int32_t BSP_RADIO_ConfigRFSwitch(BSP_RADIO_Switch_TypeDef Config)
{
 802d3c8:	b508      	push	{r3, lr}
 802d3ca:	2803      	cmp	r0, #3
 802d3cc:	d812      	bhi.n	802d3f4 <BSP_RADIO_ConfigRFSwitch+0x2c>
 802d3ce:	e8df f000 	tbb	[pc, r0]
 802d3d2:	1302      	.short	0x1302
 802d3d4:	261a      	.short	0x261a
  switch (Config)
  {
    case RADIO_SWITCH_OFF:
    {
      /* Turn off switch */
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_RESET);
 802d3d6:	2200      	movs	r2, #0
 802d3d8:	4814      	ldr	r0, [pc, #80]	; (802d42c <BSP_RADIO_ConfigRFSwitch+0x64>)
 802d3da:	2108      	movs	r1, #8
 802d3dc:	f001 f990 	bl	802e700 <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_RESET);
 802d3e0:	2200      	movs	r2, #0
    }
    case RADIO_SWITCH_RX:
    {
      /*Turns On in Rx Mode the RF Switch */
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_SET);
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_SET); 
 802d3e2:	4812      	ldr	r0, [pc, #72]	; (802d42c <BSP_RADIO_ConfigRFSwitch+0x64>)
 802d3e4:	2110      	movs	r1, #16
 802d3e6:	f001 f98b 	bl	802e700 <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL2_GPIO_PORT, RF_SW_CTRL2_PIN, GPIO_PIN_RESET); 
 802d3ea:	2200      	movs	r2, #0
    case RADIO_SWITCH_RFO_HP:
    {
      /*Turns On in Tx High Power the RF Switch */
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_SET);
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_RESET); 
      HAL_GPIO_WritePin(RF_SW_CTRL2_GPIO_PORT, RF_SW_CTRL2_PIN, GPIO_PIN_SET); 
 802d3ec:	480f      	ldr	r0, [pc, #60]	; (802d42c <BSP_RADIO_ConfigRFSwitch+0x64>)
 802d3ee:	2120      	movs	r1, #32
 802d3f0:	f001 f986 	bl	802e700 <HAL_GPIO_WritePin>
    default:
      break;    
  }  

  return BSP_ERROR_NONE;
}
 802d3f4:	2000      	movs	r0, #0
 802d3f6:	bd08      	pop	{r3, pc}
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_SET);
 802d3f8:	2201      	movs	r2, #1
 802d3fa:	480c      	ldr	r0, [pc, #48]	; (802d42c <BSP_RADIO_ConfigRFSwitch+0x64>)
 802d3fc:	2108      	movs	r1, #8
 802d3fe:	f001 f97f 	bl	802e700 <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_SET); 
 802d402:	2201      	movs	r2, #1
 802d404:	e7ed      	b.n	802d3e2 <BSP_RADIO_ConfigRFSwitch+0x1a>
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_SET);
 802d406:	2201      	movs	r2, #1
 802d408:	4808      	ldr	r0, [pc, #32]	; (802d42c <BSP_RADIO_ConfigRFSwitch+0x64>)
 802d40a:	2108      	movs	r1, #8
 802d40c:	f001 f978 	bl	802e700 <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_SET); 
 802d410:	2201      	movs	r2, #1
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_RESET); 
 802d412:	4806      	ldr	r0, [pc, #24]	; (802d42c <BSP_RADIO_ConfigRFSwitch+0x64>)
 802d414:	2110      	movs	r1, #16
 802d416:	f001 f973 	bl	802e700 <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL2_GPIO_PORT, RF_SW_CTRL2_PIN, GPIO_PIN_SET); 
 802d41a:	2201      	movs	r2, #1
 802d41c:	e7e6      	b.n	802d3ec <BSP_RADIO_ConfigRFSwitch+0x24>
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_SET);
 802d41e:	2201      	movs	r2, #1
 802d420:	4802      	ldr	r0, [pc, #8]	; (802d42c <BSP_RADIO_ConfigRFSwitch+0x64>)
 802d422:	2108      	movs	r1, #8
 802d424:	f001 f96c 	bl	802e700 <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_RESET); 
 802d428:	2200      	movs	r2, #0
 802d42a:	e7f2      	b.n	802d412 <BSP_RADIO_ConfigRFSwitch+0x4a>
 802d42c:	48000800 	.word	0x48000800

0802d430 <BSP_RADIO_GetTxConfig>:
  *  RADIO_CONF_RFO_HP
  */
int32_t BSP_RADIO_GetTxConfig(void)
{
  return RADIO_CONF_RFO_LP_HP;
}
 802d430:	2000      	movs	r0, #0
 802d432:	4770      	bx	lr

0802d434 <BSP_RADIO_IsTCXO>:
  *  RADIO_CONF_TCXO_SUPPORTED
  */
int32_t BSP_RADIO_IsTCXO(void)
{
  return RADIO_CONF_TCXO_SUPPORTED;
}
 802d434:	2001      	movs	r0, #1
 802d436:	4770      	bx	lr

0802d438 <BSP_RADIO_IsDCDC>:
 802d438:	2001      	movs	r0, #1
 802d43a:	4770      	bx	lr

0802d43c <SystemInit>:
  * @retval None
  */
void SystemInit(void)
{
  /* Configure the Vector Table location  ------------------*/
  SCB->VTOR = INTVECT_START;
 802d43c:	4b0c      	ldr	r3, [pc, #48]	; (802d470 <SystemInit+0x34>)
 802d43e:	4a0d      	ldr	r2, [pc, #52]	; (802d474 <SystemInit+0x38>)
 802d440:	609a      	str	r2, [r3, #8]
  SCB->CPACR |= ((3UL << (10UL*2UL))|(3UL << (11UL*2UL)));  /* set CP10 and CP11 Full Access */
#endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 802d442:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802d446:	681a      	ldr	r2, [r3, #0]
 802d448:	f042 0201 	orr.w	r2, r2, #1
 802d44c:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00070000U;
 802d44e:	f44f 22e0 	mov.w	r2, #458752	; 0x70000
 802d452:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON , HSION, and PLLON bits */
  /* RCC->CR &= 0xEAF6FFFFU; */
  RCC->CR &= 0x2321EFF;
 802d454:	6819      	ldr	r1, [r3, #0]
 802d456:	4a08      	ldr	r2, [pc, #32]	; (802d478 <SystemInit+0x3c>)
 802d458:	400a      	ands	r2, r1
 802d45a:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x22040100;
 802d45c:	4a07      	ldr	r2, [pc, #28]	; (802d47c <SystemInit+0x40>)
 802d45e:	60da      	str	r2, [r3, #12]

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFDFFFFFFU;
 802d460:	681a      	ldr	r2, [r3, #0]
 802d462:	f022 7200 	bic.w	r2, r2, #33554432	; 0x2000000
 802d466:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000U;
 802d468:	2200      	movs	r2, #0
 802d46a:	619a      	str	r2, [r3, #24]
}
 802d46c:	4770      	bx	lr
 802d46e:	bf00      	nop
 802d470:	e000ed00 	.word	0xe000ed00
 802d474:	0802b200 	.word	0x0802b200
 802d478:	02321eff 	.word	0x02321eff
 802d47c:	22040100 	.word	0x22040100

0802d480 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 802d480:	b510      	push	{r4, lr}
#endif /* PREFETCH_ENABLE */

#ifdef CORE_CM0PLUS
#else
  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 802d482:	2003      	movs	r0, #3
 802d484:	f000 fc5c 	bl	802dd40 <HAL_NVIC_SetPriorityGrouping>

  /* Update the SystemCoreClock global variable */
#if defined(DUAL_CORE) && defined(CORE_CM0PLUS)
  SystemCoreClock = HAL_RCC_GetHCLK2Freq();
#else
  SystemCoreClock = HAL_RCC_GetHCLKFreq();
 802d488:	f001 fac4 	bl	802ea14 <HAL_RCC_GetHCLKFreq>
 802d48c:	4b06      	ldr	r3, [pc, #24]	; (802d4a8 <HAL_Init+0x28>)
 802d48e:	6018      	str	r0, [r3, #0]
#endif

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 802d490:	200f      	movs	r0, #15
 802d492:	f7ff f8d5 	bl	802c640 <HAL_InitTick>
 802d496:	4604      	mov	r4, r0
 802d498:	b918      	cbnz	r0, 802d4a2 <HAL_Init+0x22>
    status = HAL_ERROR;
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
 802d49a:	f7fe ffa8 	bl	802c3ee <HAL_MspInit>
  }

  /* Return function status */
  return status;
}
 802d49e:	4620      	mov	r0, r4
 802d4a0:	bd10      	pop	{r4, pc}
    status = HAL_ERROR;
 802d4a2:	2401      	movs	r4, #1
 802d4a4:	e7fb      	b.n	802d49e <HAL_Init+0x1e>
 802d4a6:	bf00      	nop
 802d4a8:	2000344c 	.word	0x2000344c

0802d4ac <HAL_SuspendTick>:
  * @retval None
  */
__weak void HAL_SuspendTick(void)
{
  /* Disable SysTick Interrupt */
  CLEAR_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
 802d4ac:	4a02      	ldr	r2, [pc, #8]	; (802d4b8 <HAL_SuspendTick+0xc>)
 802d4ae:	6813      	ldr	r3, [r2, #0]
 802d4b0:	f023 0302 	bic.w	r3, r3, #2
 802d4b4:	6013      	str	r3, [r2, #0]
}
 802d4b6:	4770      	bx	lr
 802d4b8:	e000e010 	.word	0xe000e010

0802d4bc <HAL_ResumeTick>:
  * @retval None
  */
__weak void HAL_ResumeTick(void)
{
  /* Enable SysTick Interrupt */
  SET_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
 802d4bc:	4a02      	ldr	r2, [pc, #8]	; (802d4c8 <HAL_ResumeTick+0xc>)
 802d4be:	6813      	ldr	r3, [r2, #0]
 802d4c0:	f043 0302 	orr.w	r3, r3, #2
 802d4c4:	6013      	str	r3, [r2, #0]
}
 802d4c6:	4770      	bx	lr
 802d4c8:	e000e010 	.word	0xe000e010

0802d4cc <HAL_GetUIDw0>:
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw0(void)
{
  return (READ_REG(*((uint32_t *)UID_BASE)));
}
 802d4cc:	4b01      	ldr	r3, [pc, #4]	; (802d4d4 <HAL_GetUIDw0+0x8>)
 802d4ce:	6818      	ldr	r0, [r3, #0]
 802d4d0:	4770      	bx	lr
 802d4d2:	bf00      	nop
 802d4d4:	1fff7590 	.word	0x1fff7590

0802d4d8 <HAL_GetUIDw1>:
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw1(void)
{
  return (READ_REG(*((uint32_t *)(UID_BASE + 4U))));
}
 802d4d8:	4b01      	ldr	r3, [pc, #4]	; (802d4e0 <HAL_GetUIDw1+0x8>)
 802d4da:	6818      	ldr	r0, [r3, #0]
 802d4dc:	4770      	bx	lr
 802d4de:	bf00      	nop
 802d4e0:	1fff7594 	.word	0x1fff7594

0802d4e4 <HAL_GetUIDw2>:
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw2(void)
{
  return (READ_REG(*((uint32_t *)(UID_BASE + 8U))));
}
 802d4e4:	4b01      	ldr	r3, [pc, #4]	; (802d4ec <HAL_GetUIDw2+0x8>)
 802d4e6:	6818      	ldr	r0, [r3, #0]
 802d4e8:	4770      	bx	lr
 802d4ea:	bf00      	nop
 802d4ec:	1fff7598 	.word	0x1fff7598

0802d4f0 <HAL_DBGMCU_EnableDBGSleepMode>:
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
 802d4f0:	4a02      	ldr	r2, [pc, #8]	; (802d4fc <HAL_DBGMCU_EnableDBGSleepMode+0xc>)
 802d4f2:	6853      	ldr	r3, [r2, #4]
 802d4f4:	f043 0301 	orr.w	r3, r3, #1
 802d4f8:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_EnableDBGSleepMode(void)
{
  LL_DBGMCU_EnableDBGSleepMode();
}
 802d4fa:	4770      	bx	lr
 802d4fc:	e0042000 	.word	0xe0042000

0802d500 <HAL_DBGMCU_DisableDBGSleepMode>:
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
 802d500:	4a02      	ldr	r2, [pc, #8]	; (802d50c <HAL_DBGMCU_DisableDBGSleepMode+0xc>)
 802d502:	6853      	ldr	r3, [r2, #4]
 802d504:	f023 0301 	bic.w	r3, r3, #1
 802d508:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_DisableDBGSleepMode(void)
{
  LL_DBGMCU_DisableDBGSleepMode();
}
 802d50a:	4770      	bx	lr
 802d50c:	e0042000 	.word	0xe0042000

0802d510 <HAL_DBGMCU_EnableDBGStopMode>:
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
 802d510:	4a02      	ldr	r2, [pc, #8]	; (802d51c <HAL_DBGMCU_EnableDBGStopMode+0xc>)
 802d512:	6853      	ldr	r3, [r2, #4]
 802d514:	f043 0302 	orr.w	r3, r3, #2
 802d518:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_EnableDBGStopMode(void)
{
  LL_DBGMCU_EnableDBGStopMode();
}
 802d51a:	4770      	bx	lr
 802d51c:	e0042000 	.word	0xe0042000

0802d520 <HAL_DBGMCU_DisableDBGStopMode>:
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
 802d520:	4a02      	ldr	r2, [pc, #8]	; (802d52c <HAL_DBGMCU_DisableDBGStopMode+0xc>)
 802d522:	6853      	ldr	r3, [r2, #4]
 802d524:	f023 0302 	bic.w	r3, r3, #2
 802d528:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_DisableDBGStopMode(void)
{
  LL_DBGMCU_DisableDBGStopMode();
}
 802d52a:	4770      	bx	lr
 802d52c:	e0042000 	.word	0xe0042000

0802d530 <HAL_DBGMCU_EnableDBGStandbyMode>:
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
 802d530:	4a02      	ldr	r2, [pc, #8]	; (802d53c <HAL_DBGMCU_EnableDBGStandbyMode+0xc>)
 802d532:	6853      	ldr	r3, [r2, #4]
 802d534:	f043 0304 	orr.w	r3, r3, #4
 802d538:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_EnableDBGStandbyMode(void)
{
  LL_DBGMCU_EnableDBGStandbyMode();
}
 802d53a:	4770      	bx	lr
 802d53c:	e0042000 	.word	0xe0042000

0802d540 <HAL_DBGMCU_DisableDBGStandbyMode>:
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
 802d540:	4a02      	ldr	r2, [pc, #8]	; (802d54c <HAL_DBGMCU_DisableDBGStandbyMode+0xc>)
 802d542:	6853      	ldr	r3, [r2, #4]
 802d544:	f023 0304 	bic.w	r3, r3, #4
 802d548:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_DisableDBGStandbyMode(void)
{
  LL_DBGMCU_DisableDBGStandbyMode();
}
 802d54a:	4770      	bx	lr
 802d54c:	e0042000 	.word	0xe0042000

0802d550 <LL_ADC_REG_IsConversionOngoing>:
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group regular.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsConversionOngoing(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 802d550:	6880      	ldr	r0, [r0, #8]
}
 802d552:	f3c0 0080 	ubfx	r0, r0, #2, #1
 802d556:	4770      	bx	lr

0802d558 <HAL_ADC_Init>:
  *         of structure "ADC_InitTypeDef".
  * @param hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef *hadc)
{
 802d558:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  uint32_t tmpCFGR1 = 0UL;
  uint32_t tmpCFGR2 = 0UL;
  uint32_t tmp_adc_reg_is_conversion_on_going;
  __IO uint32_t wait_loop_index = 0UL;
 802d55c:	2300      	movs	r3, #0
 802d55e:	9301      	str	r3, [sp, #4]

  /* Check ADC handle */
  if (hadc == NULL)
 802d560:	4604      	mov	r4, r0
 802d562:	2800      	cmp	r0, #0
 802d564:	f000 810a 	beq.w	802d77c <HAL_ADC_Init+0x224>
  /* continuous mode is disabled.                                             */
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));

  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  if (hadc->State == HAL_ADC_STATE_RESET)
 802d568:	6d85      	ldr	r5, [r0, #88]	; 0x58
 802d56a:	b925      	cbnz	r5, 802d576 <HAL_ADC_Init+0x1e>

    /* Init the low level hardware */
    hadc->MspInitCallback(hadc);
#else
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
 802d56c:	f7fe fc90 	bl	802be90 <HAL_ADC_MspInit>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Set ADC error code to none */
    ADC_CLEAR_ERRORCODE(hadc);
 802d570:	65e5      	str	r5, [r4, #92]	; 0x5c

    /* Initialize Lock */
    hadc->Lock = HAL_UNLOCKED;
 802d572:	f884 5054 	strb.w	r5, [r4, #84]	; 0x54
  }

  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
 802d576:	6820      	ldr	r0, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 802d578:	6883      	ldr	r3, [r0, #8]
 802d57a:	00d9      	lsls	r1, r3, #3
 802d57c:	f140 80b3 	bpl.w	802d6e6 <HAL_ADC_Init+0x18e>
 802d580:	6883      	ldr	r3, [r0, #8]
 802d582:	00da      	lsls	r2, r3, #3
 802d584:	f100 80c6 	bmi.w	802d714 <HAL_ADC_Init+0x1bc>
  /* or not ADC is coming from state reset (if any potential problem of       */
  /* clocking, voltage regulator would not be enabled).                       */
  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 802d588:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802d58a:	f043 0310 	orr.w	r3, r3, #16
 802d58e:	65a3      	str	r3, [r4, #88]	; 0x58

    /* Set ADC error code to ADC peripheral internal error */
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 802d590:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 802d592:	f043 0301 	orr.w	r3, r3, #1
 802d596:	65e3      	str	r3, [r4, #92]	; 0x5c

    tmp_hal_status = HAL_ERROR;
 802d598:	2101      	movs	r1, #1

  /* Configuration of ADC parameters if previous preliminary actions are      */
  /* correctly completed and if there is no conversion on going on regular    */
  /* group (ADC may already be enabled at this point if HAL_ADC_Init() is     */
  /* called to update a parameter on the fly).                                */
  tmp_adc_reg_is_conversion_on_going = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 802d59a:	f7ff ffd9 	bl	802d550 <LL_ADC_REG_IsConversionOngoing>

  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 802d59e:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802d5a0:	f003 0310 	and.w	r3, r3, #16
 802d5a4:	4318      	orrs	r0, r3
      && (tmp_adc_reg_is_conversion_on_going == 0UL)
     )
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 802d5a6:	6da3      	ldr	r3, [r4, #88]	; 0x58
  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 802d5a8:	f040 80ea 	bne.w	802d780 <HAL_ADC_Init+0x228>
    ADC_STATE_CLR_SET(hadc->State,
 802d5ac:	f423 7381 	bic.w	r3, r3, #258	; 0x102
 802d5b0:	f043 0302 	orr.w	r3, r3, #2
    /*  - Oversampling                                                        */
    /*  - Trigger frequency mode                                              */
    /* Note: If low power mode AutoPowerOff is enabled, ADC enable            */
    /*       and disable phases are performed automatically by hardware       */
    /*       (in this case, flag ADC_FLAG_RDY is not set).                    */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 802d5b4:	6822      	ldr	r2, [r4, #0]
    ADC_STATE_CLR_SET(hadc->State,
 802d5b6:	65a3      	str	r3, [r4, #88]	; 0x58
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 802d5b8:	6893      	ldr	r3, [r2, #8]
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 802d5ba:	07db      	lsls	r3, r3, #31
 802d5bc:	f100 80ac 	bmi.w	802d718 <HAL_ADC_Init+0x1c0>
      /* parameters):                                                         */
      /*   - internal measurement paths (VrefInt, ...)                        */
      /*     (set into HAL_ADC_ConfigChannel() )                              */

      /* Configuration of ADC resolution                                      */
      MODIFY_REG(hadc->Instance->CFGR1,
 802d5c0:	68d3      	ldr	r3, [r2, #12]
 802d5c2:	68a5      	ldr	r5, [r4, #8]
                 ADC_CFGR1_RES,
                 hadc->Init.Resolution);

      tmpCFGR2 |= ((hadc->Init.ClockPrescaler & ADC_CFGR2_CKMODE) |
 802d5c4:	6866      	ldr	r6, [r4, #4]
      MODIFY_REG(hadc->Instance->CFGR1,
 802d5c6:	f023 0318 	bic.w	r3, r3, #24
 802d5ca:	432b      	orrs	r3, r5
 802d5cc:	60d3      	str	r3, [r2, #12]
      tmpCFGR2 |= ((hadc->Init.ClockPrescaler & ADC_CFGR2_CKMODE) |
 802d5ce:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 802d5d0:	f006 4c40 	and.w	ip, r6, #3221225472	; 0xc0000000
 802d5d4:	ea4c 0503 	orr.w	r5, ip, r3
                   hadc->Init.TriggerFrequencyMode
                  );

      if (hadc->Init.OversamplingMode == ENABLE)
 802d5d8:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
 802d5dc:	2b01      	cmp	r3, #1
 802d5de:	d109      	bne.n	802d5f4 <HAL_ADC_Init+0x9c>
      {
        tmpCFGR2 |= (ADC_CFGR2_OVSE |
 802d5e0:	e9d4 3710 	ldrd	r3, r7, [r4, #64]	; 0x40
 802d5e4:	433b      	orrs	r3, r7
 802d5e6:	432b      	orrs	r3, r5
 802d5e8:	6ca5      	ldr	r5, [r4, #72]	; 0x48
 802d5ea:	432b      	orrs	r3, r5
 802d5ec:	ea43 030c 	orr.w	r3, r3, ip
 802d5f0:	f043 0501 	orr.w	r5, r3, #1
                     hadc->Init.Oversampling.RightBitShift |
                     hadc->Init.Oversampling.TriggeredMode
                    );
      }

      MODIFY_REG(hadc->Instance->CFGR2,
 802d5f4:	6917      	ldr	r7, [r2, #16]
 802d5f6:	4b64      	ldr	r3, [pc, #400]	; (802d788 <HAL_ADC_Init+0x230>)
 802d5f8:	403b      	ands	r3, r7
 802d5fa:	432b      	orrs	r3, r5
 802d5fc:	6113      	str	r3, [r2, #16]
                 ADC_CFGR2_TOVS,
                 tmpCFGR2);

      /* Configuration of ADC clock mode: asynchronous clock source           */
      /* with selectable prescaler.                                           */
      if (((hadc->Init.ClockPrescaler) != ADC_CLOCK_SYNC_PCLK_DIV1) &&
 802d5fe:	f026 4300 	bic.w	r3, r6, #2147483648	; 0x80000000
 802d602:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 802d606:	d00a      	beq.n	802d61e <HAL_ADC_Init+0xc6>
          ((hadc->Init.ClockPrescaler) != ADC_CLOCK_SYNC_PCLK_DIV2) &&
 802d608:	f1b6 4f00 	cmp.w	r6, #2147483648	; 0x80000000
 802d60c:	d007      	beq.n	802d61e <HAL_ADC_Init+0xc6>
          ((hadc->Init.ClockPrescaler) != ADC_CLOCK_SYNC_PCLK_DIV4))
      {
        MODIFY_REG(ADC_COMMON->CCR,
 802d60e:	4f5f      	ldr	r7, [pc, #380]	; (802d78c <HAL_ADC_Init+0x234>)
 802d610:	683b      	ldr	r3, [r7, #0]
 802d612:	f406 1670 	and.w	r6, r6, #3932160	; 0x3c0000
 802d616:	f423 1370 	bic.w	r3, r3, #3932160	; 0x3c0000
 802d61a:	431e      	orrs	r6, r3
 802d61c:	603e      	str	r6, [r7, #0]
    /*  - data alignment                                                      */
    /*  - resolution                                                          */
    /*  - scan direction                                                      */
    /*  - DMA continuous request                                              */
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)      |
                 ADC_CFGR1_AUTOOFF((uint32_t)hadc->Init.LowPowerAutoPowerOff)   |
 802d61e:	7e63      	ldrb	r3, [r4, #25]
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)      |
 802d620:	7e26      	ldrb	r6, [r4, #24]
 802d622:	68e7      	ldr	r7, [r4, #12]
                 ADC_CFGR1_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)  |
                 ADC_CFGR1_OVERRUN(hadc->Init.Overrun)                          |
 802d624:	f8d4 c030 	ldr.w	ip, [r4, #48]	; 0x30
                 hadc->Init.DataAlign                                           |
                 ADC_SCAN_SEQ_MODE(hadc->Init.ScanConvMode)                     |
                 ADC_CFGR1_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests));
 802d628:	f894 802c 	ldrb.w	r8, [r4, #44]	; 0x2c
                 ADC_CFGR1_AUTOOFF((uint32_t)hadc->Init.LowPowerAutoPowerOff)   |
 802d62c:	03db      	lsls	r3, r3, #15
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)      |
 802d62e:	ea43 3386 	orr.w	r3, r3, r6, lsl #14
                 ADC_CFGR1_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)  |
 802d632:	7ea6      	ldrb	r6, [r4, #26]
 802d634:	433b      	orrs	r3, r7
                 ADC_CFGR1_OVERRUN(hadc->Init.Overrun)                          |
 802d636:	f1bc 0f00 	cmp.w	ip, #0
 802d63a:	ea43 3346 	orr.w	r3, r3, r6, lsl #13
 802d63e:	bf18      	it	ne
 802d640:	f44f 5c80 	movne.w	ip, #4096	; 0x1000
                 ADC_SCAN_SEQ_MODE(hadc->Init.ScanConvMode)                     |
 802d644:	6927      	ldr	r7, [r4, #16]
 802d646:	ea43 0348 	orr.w	r3, r3, r8, lsl #1
 802d64a:	ea43 030c 	orr.w	r3, r3, ip

    /* Update setting of discontinuous mode only if continuous mode is disabled */
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 802d64e:	f894 c020 	ldrb.w	ip, [r4, #32]
                 ADC_SCAN_SEQ_MODE(hadc->Init.ScanConvMode)                     |
 802d652:	2f00      	cmp	r7, #0
 802d654:	bfb4      	ite	lt
 802d656:	f027 4e00 	biclt.w	lr, r7, #2147483648	; 0x80000000
 802d65a:	f44f 1e00 	movge.w	lr, #2097152	; 0x200000
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 802d65e:	f1bc 0f01 	cmp.w	ip, #1
                 ADC_SCAN_SEQ_MODE(hadc->Init.ScanConvMode)                     |
 802d662:	ea43 0e0e 	orr.w	lr, r3, lr
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 802d666:	d103      	bne.n	802d670 <HAL_ADC_Init+0x118>
    {
      if (hadc->Init.ContinuousConvMode == DISABLE)
 802d668:	2e00      	cmp	r6, #0
 802d66a:	d157      	bne.n	802d71c <HAL_ADC_Init+0x1c4>
      {
        /* Enable the selected ADC group regular discontinuous mode */
        tmpCFGR1 |= ADC_CFGR1_DISCEN;
 802d66c:	f44e 3e80 	orr.w	lr, lr, #65536	; 0x10000
    /* Enable external trigger if trigger selection is different of software  */
    /* start.                                                                 */
    /* Note: This configuration keeps the hardware feature of parameter       */
    /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
    /*       software start.                                                  */
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 802d670:	6a66      	ldr	r6, [r4, #36]	; 0x24
 802d672:	b12e      	cbz	r6, 802d680 <HAL_ADC_Init+0x128>
    {
      tmpCFGR1 |= ((hadc->Init.ExternalTrigConv & ADC_CFGR1_EXTSEL) |
 802d674:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 802d676:	f406 76e0 	and.w	r6, r6, #448	; 0x1c0
 802d67a:	431e      	orrs	r6, r3
 802d67c:	ea4e 0e06 	orr.w	lr, lr, r6
                   hadc->Init.ExternalTrigConvEdge);
    }

    /* Update ADC configuration register with previous settings */
    MODIFY_REG(hadc->Instance->CFGR1,
 802d680:	68d6      	ldr	r6, [r2, #12]
 802d682:	f426 36fe 	bic.w	r6, r6, #130048	; 0x1fc00
 802d686:	f426 76f3 	bic.w	r6, r6, #486	; 0x1e6
 802d68a:	ea46 060e 	orr.w	r6, r6, lr
 802d68e:	60d6      	str	r6, [r2, #12]
               ADC_CFGR1_ALIGN   |
               ADC_CFGR1_SCANDIR |
               ADC_CFGR1_DMACFG,
               tmpCFGR1);

    MODIFY_REG(hadc->Instance->CFGR2,
 802d690:	f8d2 c010 	ldr.w	ip, [r2, #16]
 802d694:	4e3e      	ldr	r6, [pc, #248]	; (802d790 <HAL_ADC_Init+0x238>)
 802d696:	ea0c 0606 	and.w	r6, ip, r6
 802d69a:	4335      	orrs	r5, r6
 802d69c:	6115      	str	r5, [r2, #16]
  MODIFY_REG(ADCx->SMPR,
 802d69e:	6955      	ldr	r5, [r2, #20]
 802d6a0:	6b66      	ldr	r6, [r4, #52]	; 0x34
 802d6a2:	f025 0507 	bic.w	r5, r5, #7
 802d6a6:	4335      	orrs	r5, r6
 802d6a8:	6155      	str	r5, [r2, #20]
 802d6aa:	6955      	ldr	r5, [r2, #20]
 802d6ac:	6ba6      	ldr	r6, [r4, #56]	; 0x38
 802d6ae:	f025 0570 	bic.w	r5, r5, #112	; 0x70
 802d6b2:	ea45 1506 	orr.w	r5, r5, r6, lsl #4
 802d6b6:	6155      	str	r5, [r2, #20]
    /*   emulated by software for alignment over all STM32 devices.           */
    /* - if scan mode is enabled, regular channels sequence length is set to  */
    /*   parameter "NbrOfConversion".                                         */
    /*   Channels must be configured into each rank using function            */
    /*   "HAL_ADC_ConfigChannel()".                                           */
    if (hadc->Init.ScanConvMode == ADC_SCAN_DISABLE)
 802d6b8:	2f00      	cmp	r7, #0
 802d6ba:	d138      	bne.n	802d72e <HAL_ADC_Init+0x1d6>
      if (ADCGroupRegularSequencerRanksCount == 1UL)
      {
        /* Set ADC group regular sequencer:                                   */
        /* Set sequencer scan length by clearing ranks above rank 1           */
        /* and do not modify rank 1 value.                                    */
        SET_BIT(hadc->Instance->CHSELR,
 802d6bc:	6a90      	ldr	r0, [r2, #40]	; 0x28
 802d6be:	f060 000f 	orn	r0, r0, #15
        /*          therefore after the first call of "HAL_ADC_Init()",       */
        /*          each rank corresponding to parameter "NbrOfConversion"    */
        /*          must be set using "HAL_ADC_ConfigChannel()".              */
        /*  - Set sequencer scan length by clearing ranks above maximum rank  */
        /*    and do not modify other ranks value.                            */
        MODIFY_REG(hadc->Instance->CHSELR,
 802d6c2:	6290      	str	r0, [r2, #40]	; 0x28
    /* Check back that ADC registers have effectively been configured to      */
    /* ensure of no potential problem of ADC core peripheral clocking.        */
    /* Check through register CFGR1 (excluding analog watchdog configuration: */
    /* set into separate dedicated function, and bits of ADC resolution set   */
    /* out of temporary variable 'tmpCFGR1').                                 */
    if ((hadc->Instance->CFGR1 & ~(ADC_CFGR1_AWD1CH | ADC_CFGR1_AWD1EN | ADC_CFGR1_AWD1SGL | ADC_CFGR1_RES))
 802d6c4:	68d0      	ldr	r0, [r2, #12]
 802d6c6:	4a33      	ldr	r2, [pc, #204]	; (802d794 <HAL_ADC_Init+0x23c>)
 802d6c8:	4002      	ands	r2, r0
 802d6ca:	4572      	cmp	r2, lr
 802d6cc:	d14c      	bne.n	802d768 <HAL_ADC_Init+0x210>
        == tmpCFGR1)
    {
      /* Set ADC error code to none */
      ADC_CLEAR_ERRORCODE(hadc);
 802d6ce:	2300      	movs	r3, #0
 802d6d0:	65e3      	str	r3, [r4, #92]	; 0x5c

      /* Set the ADC state */
      ADC_STATE_CLR_SET(hadc->State,
 802d6d2:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802d6d4:	f023 0303 	bic.w	r3, r3, #3
 802d6d8:	f043 0301 	orr.w	r3, r3, #1
 802d6dc:	65a3      	str	r3, [r4, #88]	; 0x58

    tmp_hal_status = HAL_ERROR;
  }

  return tmp_hal_status;
}
 802d6de:	4608      	mov	r0, r1
 802d6e0:	b002      	add	sp, #8
 802d6e2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  MODIFY_REG(ADCx->CR,
 802d6e6:	6883      	ldr	r3, [r0, #8]
    wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 802d6e8:	4a2b      	ldr	r2, [pc, #172]	; (802d798 <HAL_ADC_Init+0x240>)
 802d6ea:	f023 4310 	bic.w	r3, r3, #2415919104	; 0x90000000
 802d6ee:	f023 0317 	bic.w	r3, r3, #23
 802d6f2:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 802d6f6:	6083      	str	r3, [r0, #8]
 802d6f8:	4b28      	ldr	r3, [pc, #160]	; (802d79c <HAL_ADC_Init+0x244>)
 802d6fa:	681b      	ldr	r3, [r3, #0]
 802d6fc:	fbb3 f3f2 	udiv	r3, r3, r2
 802d700:	3301      	adds	r3, #1
 802d702:	005b      	lsls	r3, r3, #1
      wait_loop_index--;
 802d704:	9301      	str	r3, [sp, #4]
    while (wait_loop_index != 0UL)
 802d706:	9b01      	ldr	r3, [sp, #4]
 802d708:	2b00      	cmp	r3, #0
 802d70a:	f43f af39 	beq.w	802d580 <HAL_ADC_Init+0x28>
      wait_loop_index--;
 802d70e:	9b01      	ldr	r3, [sp, #4]
 802d710:	3b01      	subs	r3, #1
 802d712:	e7f7      	b.n	802d704 <HAL_ADC_Init+0x1ac>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 802d714:	2100      	movs	r1, #0
 802d716:	e740      	b.n	802d59a <HAL_ADC_Init+0x42>
  uint32_t tmpCFGR2 = 0UL;
 802d718:	4605      	mov	r5, r0
 802d71a:	e780      	b.n	802d61e <HAL_ADC_Init+0xc6>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 802d71c:	6da6      	ldr	r6, [r4, #88]	; 0x58
 802d71e:	f046 0620 	orr.w	r6, r6, #32
 802d722:	65a6      	str	r6, [r4, #88]	; 0x58
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 802d724:	6de6      	ldr	r6, [r4, #92]	; 0x5c
 802d726:	f046 0601 	orr.w	r6, r6, #1
 802d72a:	65e6      	str	r6, [r4, #92]	; 0x5c
 802d72c:	e7a0      	b.n	802d670 <HAL_ADC_Init+0x118>
    else if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
 802d72e:	f5b7 1f00 	cmp.w	r7, #2097152	; 0x200000
 802d732:	d1c7      	bne.n	802d6c4 <HAL_ADC_Init+0x16c>
        if (((hadc->ADCGroupRegularSequencerRanks >> (ADCGroupRegularSequencerRanksCount * 4UL)) & ADC_CHSELR_SQ1) ==
 802d734:	6e26      	ldr	r6, [r4, #96]	; 0x60
 802d736:	0085      	lsls	r5, r0, #2
 802d738:	fa26 f505 	lsr.w	r5, r6, r5
 802d73c:	f005 050f 	and.w	r5, r5, #15
 802d740:	2d0f      	cmp	r5, #15
 802d742:	d00e      	beq.n	802d762 <HAL_ADC_Init+0x20a>
      for (ADCGroupRegularSequencerRanksCount = 0UL; ADCGroupRegularSequencerRanksCount < (8UL); ADCGroupRegularSequencerRanksCount++)
 802d744:	3001      	adds	r0, #1
 802d746:	2808      	cmp	r0, #8
 802d748:	d1f5      	bne.n	802d736 <HAL_ADC_Init+0x1de>
        MODIFY_REG(hadc->Instance->CHSELR,
 802d74a:	6a90      	ldr	r0, [r2, #40]	; 0x28
 802d74c:	69e0      	ldr	r0, [r4, #28]
 802d74e:	3801      	subs	r0, #1
 802d750:	0080      	lsls	r0, r0, #2
 802d752:	f000 001c 	and.w	r0, r0, #28
 802d756:	f06f 050f 	mvn.w	r5, #15
 802d75a:	fa05 f000 	lsl.w	r0, r5, r0
 802d75e:	4330      	orrs	r0, r6
 802d760:	e7af      	b.n	802d6c2 <HAL_ADC_Init+0x16a>
      if (ADCGroupRegularSequencerRanksCount == 1UL)
 802d762:	2801      	cmp	r0, #1
 802d764:	d0aa      	beq.n	802d6bc <HAL_ADC_Init+0x164>
 802d766:	e7f0      	b.n	802d74a <HAL_ADC_Init+0x1f2>
      ADC_STATE_CLR_SET(hadc->State,
 802d768:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802d76a:	f023 0312 	bic.w	r3, r3, #18
 802d76e:	f043 0310 	orr.w	r3, r3, #16
 802d772:	65a3      	str	r3, [r4, #88]	; 0x58
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 802d774:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 802d776:	f043 0301 	orr.w	r3, r3, #1
 802d77a:	65e3      	str	r3, [r4, #92]	; 0x5c
    return HAL_ERROR;
 802d77c:	2101      	movs	r1, #1
 802d77e:	e7ae      	b.n	802d6de <HAL_ADC_Init+0x186>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 802d780:	f043 0310 	orr.w	r3, r3, #16
 802d784:	65a3      	str	r3, [r4, #88]	; 0x58
    tmp_hal_status = HAL_ERROR;
 802d786:	e7f9      	b.n	802d77c <HAL_ADC_Init+0x224>
 802d788:	1ffffc02 	.word	0x1ffffc02
 802d78c:	40012708 	.word	0x40012708
 802d790:	dffffc02 	.word	0xdffffc02
 802d794:	833fffe7 	.word	0x833fffe7
 802d798:	00030d40 	.word	0x00030d40
 802d79c:	2000344c 	.word	0x2000344c

0802d7a0 <HAL_ADC_PollForConversion>:
  * @param hadc ADC handle
  * @param Timeout Timeout value in millisecond.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef *hadc, uint32_t Timeout)
{
 802d7a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  /* If end of conversion selected to end of sequence conversions */
  if (hadc->Init.EOCSelection == ADC_EOC_SEQ_CONV)
 802d7a2:	6945      	ldr	r5, [r0, #20]
 802d7a4:	2d08      	cmp	r5, #8
{
 802d7a6:	4604      	mov	r4, r0
 802d7a8:	460e      	mov	r6, r1
  if (hadc->Init.EOCSelection == ADC_EOC_SEQ_CONV)
 802d7aa:	d00a      	beq.n	802d7c2 <HAL_ADC_PollForConversion+0x22>
    /* each conversion:                                                       */
    /* Particular case is ADC configured in DMA mode and ADC sequencer with   */
    /* several ranks and polling for end of each conversion.                  */
    /* For code simplicity sake, this particular case is generalized to       */
    /* ADC configured in DMA mode and and polling for end of each conversion. */
    if ((hadc->Instance->CFGR1 & ADC_CFGR1_DMAEN) != 0UL)
 802d7ac:	6803      	ldr	r3, [r0, #0]
 802d7ae:	68db      	ldr	r3, [r3, #12]
 802d7b0:	07d9      	lsls	r1, r3, #31
 802d7b2:	d505      	bpl.n	802d7c0 <HAL_ADC_PollForConversion+0x20>
    {
      /* Update ADC state machine to error */
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 802d7b4:	6d83      	ldr	r3, [r0, #88]	; 0x58
 802d7b6:	f043 0320 	orr.w	r3, r3, #32
 802d7ba:	6583      	str	r3, [r0, #88]	; 0x58

      return HAL_ERROR;
 802d7bc:	2001      	movs	r0, #1
    __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS));
  }

  /* Return function status */
  return HAL_OK;
}
 802d7be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      tmp_flag_end = (ADC_FLAG_EOC);
 802d7c0:	2504      	movs	r5, #4
  tickstart = HAL_GetTick();
 802d7c2:	f7fe ff3f 	bl	802c644 <HAL_GetTick>
 802d7c6:	4607      	mov	r7, r0
  while ((hadc->Instance->ISR & tmp_flag_end) == 0UL)
 802d7c8:	6820      	ldr	r0, [r4, #0]
 802d7ca:	6803      	ldr	r3, [r0, #0]
 802d7cc:	422b      	tst	r3, r5
 802d7ce:	d022      	beq.n	802d816 <HAL_ADC_PollForConversion+0x76>
  SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
 802d7d0:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802d7d2:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 802d7d6:	65a3      	str	r3, [r4, #88]	; 0x58
  return ((READ_BIT(ADCx->CFGR1, ADC_CFGR1_EXTEN) == (LL_ADC_REG_TRIG_SOFTWARE & ADC_CFGR1_EXTEN)) ? 1UL : 0UL);
 802d7d8:	68c3      	ldr	r3, [r0, #12]
 802d7da:	f413 6f40 	tst.w	r3, #3072	; 0xc00
 802d7de:	d114      	bne.n	802d80a <HAL_ADC_PollForConversion+0x6a>
      && (hadc->Init.ContinuousConvMode == DISABLE)
 802d7e0:	7ea3      	ldrb	r3, [r4, #26]
 802d7e2:	b993      	cbnz	r3, 802d80a <HAL_ADC_PollForConversion+0x6a>
    if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS))
 802d7e4:	6803      	ldr	r3, [r0, #0]
 802d7e6:	071b      	lsls	r3, r3, #28
 802d7e8:	d50f      	bpl.n	802d80a <HAL_ADC_PollForConversion+0x6a>
      if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 802d7ea:	f7ff feb1 	bl	802d550 <LL_ADC_REG_IsConversionOngoing>
 802d7ee:	bb38      	cbnz	r0, 802d840 <HAL_ADC_PollForConversion+0xa0>
        __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC | ADC_IT_EOS);
 802d7f0:	6822      	ldr	r2, [r4, #0]
 802d7f2:	6853      	ldr	r3, [r2, #4]
 802d7f4:	f023 030c 	bic.w	r3, r3, #12
 802d7f8:	6053      	str	r3, [r2, #4]
        ADC_STATE_CLR_SET(hadc->State,
 802d7fa:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802d7fc:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 802d800:	f023 0301 	bic.w	r3, r3, #1
 802d804:	f043 0301 	orr.w	r3, r3, #1
 802d808:	65a3      	str	r3, [r4, #88]	; 0x58
  if (hadc->Init.LowPowerAutoWait == DISABLE)
 802d80a:	7e20      	ldrb	r0, [r4, #24]
 802d80c:	bb08      	cbnz	r0, 802d852 <HAL_ADC_PollForConversion+0xb2>
    __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS));
 802d80e:	6823      	ldr	r3, [r4, #0]
 802d810:	220c      	movs	r2, #12
 802d812:	601a      	str	r2, [r3, #0]
 802d814:	e7d3      	b.n	802d7be <HAL_ADC_PollForConversion+0x1e>
    if (Timeout != HAL_MAX_DELAY)
 802d816:	1c72      	adds	r2, r6, #1
 802d818:	d0d7      	beq.n	802d7ca <HAL_ADC_PollForConversion+0x2a>
      if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0UL))
 802d81a:	f7fe ff13 	bl	802c644 <HAL_GetTick>
 802d81e:	1bc0      	subs	r0, r0, r7
 802d820:	42b0      	cmp	r0, r6
 802d822:	d801      	bhi.n	802d828 <HAL_ADC_PollForConversion+0x88>
 802d824:	2e00      	cmp	r6, #0
 802d826:	d1cf      	bne.n	802d7c8 <HAL_ADC_PollForConversion+0x28>
        if ((hadc->Instance->ISR & tmp_flag_end) == 0UL)
 802d828:	6823      	ldr	r3, [r4, #0]
 802d82a:	681b      	ldr	r3, [r3, #0]
 802d82c:	402b      	ands	r3, r5
 802d82e:	d1cb      	bne.n	802d7c8 <HAL_ADC_PollForConversion+0x28>
          SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 802d830:	6da2      	ldr	r2, [r4, #88]	; 0x58
          __HAL_UNLOCK(hadc);
 802d832:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54
          SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 802d836:	f042 0204 	orr.w	r2, r2, #4
 802d83a:	65a2      	str	r2, [r4, #88]	; 0x58
          return HAL_TIMEOUT;
 802d83c:	2003      	movs	r0, #3
 802d83e:	e7be      	b.n	802d7be <HAL_ADC_PollForConversion+0x1e>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 802d840:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802d842:	f043 0320 	orr.w	r3, r3, #32
 802d846:	65a3      	str	r3, [r4, #88]	; 0x58
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 802d848:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 802d84a:	f043 0301 	orr.w	r3, r3, #1
 802d84e:	65e3      	str	r3, [r4, #92]	; 0x5c
 802d850:	e7db      	b.n	802d80a <HAL_ADC_PollForConversion+0x6a>
  return HAL_OK;
 802d852:	2000      	movs	r0, #0
 802d854:	e7b3      	b.n	802d7be <HAL_ADC_PollForConversion+0x1e>

0802d856 <HAL_ADC_GetValue>:

  /* Note: EOC flag is not cleared here by software because automatically     */
  /*       cleared by hardware when reading register DR.                      */

  /* Return ADC converted value */
  return hadc->Instance->DR;
 802d856:	6803      	ldr	r3, [r0, #0]
 802d858:	6c18      	ldr	r0, [r3, #64]	; 0x40
}
 802d85a:	4770      	bx	lr

0802d85c <HAL_ADC_ConfigChannel>:
  * @param hadc ADC handle
  * @param pConfig Structure of ADC channel assigned to ADC group regular.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef *hadc, ADC_ChannelConfTypeDef *pConfig)
{
 802d85c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  uint32_t tmp_config_internal_channel;
  __IO uint32_t wait_loop_index = 0UL;
 802d85e:	2300      	movs	r3, #0
 802d860:	9301      	str	r3, [sp, #4]
    assert_param(IS_ADC_REGULAR_NB_CONV(hadc->Init.NbrOfConversion));

    assert_param(IS_ADC_REGULAR_RANK(pConfig->Rank));
  }

  __HAL_LOCK(hadc);
 802d862:	f890 3054 	ldrb.w	r3, [r0, #84]	; 0x54
 802d866:	2b01      	cmp	r3, #1
{
 802d868:	4604      	mov	r4, r0
  __HAL_LOCK(hadc);
 802d86a:	f000 80bb 	beq.w	802d9e4 <HAL_ADC_ConfigChannel+0x188>
 802d86e:	2301      	movs	r3, #1
 802d870:	f880 3054 	strb.w	r3, [r0, #84]	; 0x54
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Channel number                                                        */
  /*  - Channel sampling time                                                 */
  /*  - Management of internal measurement channels: VrefInt/TempSensor/Vbat  */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 802d874:	6800      	ldr	r0, [r0, #0]
 802d876:	f7ff fe6b 	bl	802d550 <LL_ADC_REG_IsConversionOngoing>
 802d87a:	2800      	cmp	r0, #0
 802d87c:	f040 80ac 	bne.w	802d9d8 <HAL_ADC_ConfigChannel+0x17c>
    /* If sequencer set to not fully configurable with channel rank set to    */
    /* none, remove the channel from the sequencer.                           */
    /* Otherwise (sequencer set to fully configurable or to to not fully      */
    /* configurable with channel rank to be set), configure the selected      */
    /* channel.                                                               */
    if (pConfig->Rank != ADC_RANK_NONE)
 802d880:	6848      	ldr	r0, [r1, #4]
 802d882:	6923      	ldr	r3, [r4, #16]
 802d884:	680a      	ldr	r2, [r1, #0]
 802d886:	2802      	cmp	r0, #2
 802d888:	f023 0304 	bic.w	r3, r3, #4
 802d88c:	d07c      	beq.n	802d988 <HAL_ADC_ConfigChannel+0x12c>
      /* Note: ADC channel configuration requires few ADC clock cycles        */
      /*       to be ready. Processing of ADC settings in this function       */
      /*       induce that a specific wait time is not necessary.             */
      /*       For more details on ADC channel configuration ready,           */
      /*       refer to function "LL_ADC_IsActiveFlag_CCRDY()".               */
      if ((hadc->Init.ScanConvMode == ADC_SCAN_SEQ_FIXED)       ||
 802d88e:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 802d892:	6825      	ldr	r5, [r4, #0]
 802d894:	f3c2 0e11 	ubfx	lr, r2, #0, #18
 802d898:	d113      	bne.n	802d8c2 <HAL_ADC_ConfigChannel+0x66>
  SET_BIT(ADCx->CHSELR, (Channel & ADC_CHANNEL_ID_BITFIELD_MASK));
 802d89a:	6aab      	ldr	r3, [r5, #40]	; 0x28
 802d89c:	ea43 030e 	orr.w	r3, r3, lr
  MODIFY_REG(ADCx->CHSELR,
 802d8a0:	62ab      	str	r3, [r5, #40]	; 0x28
  MODIFY_REG(ADCx->SMPR,
 802d8a2:	688b      	ldr	r3, [r1, #8]
 802d8a4:	6968      	ldr	r0, [r5, #20]
 802d8a6:	ea03 2302 	and.w	r3, r3, r2, lsl #8
 802d8aa:	f023 437c 	bic.w	r3, r3, #4227858432	; 0xfc000000
 802d8ae:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 802d8b2:	ea20 2102 	bic.w	r1, r0, r2, lsl #8
 802d8b6:	430b      	orrs	r3, r1
      /* internal measurement paths enable: If internal channel selected,     */
      /* enable dedicated internal buffers and path.                          */
      /* Note: these internal measurement paths can be disabled using         */
      /*       HAL_ADC_DeInit() or removing the channel from sequencer with   */
      /*       channel configuration parameter "Rank".                        */
      if (__LL_ADC_IS_CHANNEL_INTERNAL(pConfig->Channel))
 802d8b8:	2a00      	cmp	r2, #0
 802d8ba:	616b      	str	r3, [r5, #20]
 802d8bc:	db26      	blt.n	802d90c <HAL_ADC_ConfigChannel+0xb0>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 802d8be:	2000      	movs	r0, #0
}
 802d8c0:	e050      	b.n	802d964 <HAL_ADC_ConfigChannel+0x108>
        MODIFY_REG(hadc->ADCGroupRegularSequencerRanks,
 802d8c2:	6e23      	ldr	r3, [r4, #96]	; 0x60
 802d8c4:	f000 071f 	and.w	r7, r0, #31
 802d8c8:	f04f 0c0f 	mov.w	ip, #15
 802d8cc:	fa0c fc07 	lsl.w	ip, ip, r7
 802d8d0:	ea6f 060c 	mvn.w	r6, ip
 802d8d4:	ea23 0c0c 	bic.w	ip, r3, ip
 802d8d8:	f1be 0f00 	cmp.w	lr, #0
 802d8dc:	d111      	bne.n	802d902 <HAL_ADC_ConfigChannel+0xa6>
 802d8de:	f3c2 6384 	ubfx	r3, r2, #26, #5
 802d8e2:	40bb      	lsls	r3, r7
 802d8e4:	ea43 030c 	orr.w	r3, r3, ip
 802d8e8:	6623      	str	r3, [r4, #96]	; 0x60
        if (((pConfig->Rank >> 2UL) + 1UL) <= hadc->Init.NbrOfConversion)
 802d8ea:	0880      	lsrs	r0, r0, #2
 802d8ec:	69e3      	ldr	r3, [r4, #28]
 802d8ee:	3001      	adds	r0, #1
 802d8f0:	4298      	cmp	r0, r3
 802d8f2:	d8d6      	bhi.n	802d8a2 <HAL_ADC_ConfigChannel+0x46>
  MODIFY_REG(ADCx->CHSELR,
 802d8f4:	6aa8      	ldr	r0, [r5, #40]	; 0x28
 802d8f6:	f3c2 6383 	ubfx	r3, r2, #26, #4
 802d8fa:	40bb      	lsls	r3, r7
 802d8fc:	4006      	ands	r6, r0
 802d8fe:	4333      	orrs	r3, r6
 802d900:	e7ce      	b.n	802d8a0 <HAL_ADC_ConfigChannel+0x44>
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 802d902:	fa92 f3a2 	rbit	r3, r2
   */
  if (value == 0U)
  {
    return 32U;
  }
  return __builtin_clz(value);
 802d906:	fab3 f383 	clz	r3, r3
 802d90a:	e7ea      	b.n	802d8e2 <HAL_ADC_ConfigChannel+0x86>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 802d90c:	4936      	ldr	r1, [pc, #216]	; (802d9e8 <HAL_ADC_ConfigChannel+0x18c>)
      {
        tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));

        /* If the requested internal measurement path has already been enabled,   */
        /* bypass the configuration processing.                                   */
        if ((pConfig->Channel == ADC_CHANNEL_TEMPSENSOR) &&
 802d90e:	4837      	ldr	r0, [pc, #220]	; (802d9ec <HAL_ADC_ConfigChannel+0x190>)
 802d910:	680b      	ldr	r3, [r1, #0]
 802d912:	4282      	cmp	r2, r0
 802d914:	f003 75e0 	and.w	r5, r3, #29360128	; 0x1c00000
 802d918:	d117      	bne.n	802d94a <HAL_ADC_ConfigChannel+0xee>
 802d91a:	021b      	lsls	r3, r3, #8
 802d91c:	d4cf      	bmi.n	802d8be <HAL_ADC_ConfigChannel+0x62>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 802d91e:	680b      	ldr	r3, [r1, #0]
          /* Delay for temperature sensor stabilization time */
          /* Wait loop initialization and execution */
          /* Note: Variable divided by 2 to compensate partially              */
          /*       CPU processing cycles, scaling in us split to not          */
          /*       exceed 32 bits register capacity and handle low frequency. */
          wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 802d920:	4a33      	ldr	r2, [pc, #204]	; (802d9f0 <HAL_ADC_ConfigChannel+0x194>)
 802d922:	f023 73e0 	bic.w	r3, r3, #29360128	; 0x1c00000
 802d926:	432b      	orrs	r3, r5
 802d928:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 802d92c:	600b      	str	r3, [r1, #0]
 802d92e:	4b31      	ldr	r3, [pc, #196]	; (802d9f4 <HAL_ADC_ConfigChannel+0x198>)
 802d930:	681b      	ldr	r3, [r3, #0]
 802d932:	fbb3 f2f2 	udiv	r2, r3, r2
 802d936:	230c      	movs	r3, #12
 802d938:	fb02 3303 	mla	r3, r2, r3, r3
          while (wait_loop_index != 0UL)
          {
            wait_loop_index--;
 802d93c:	9301      	str	r3, [sp, #4]
          while (wait_loop_index != 0UL)
 802d93e:	9b01      	ldr	r3, [sp, #4]
 802d940:	2b00      	cmp	r3, #0
 802d942:	d0bc      	beq.n	802d8be <HAL_ADC_ConfigChannel+0x62>
            wait_loop_index--;
 802d944:	9b01      	ldr	r3, [sp, #4]
 802d946:	3b01      	subs	r3, #1
 802d948:	e7f8      	b.n	802d93c <HAL_ADC_ConfigChannel+0xe0>
          }
        }
        else if ((pConfig->Channel == ADC_CHANNEL_VBAT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
 802d94a:	482b      	ldr	r0, [pc, #172]	; (802d9f8 <HAL_ADC_ConfigChannel+0x19c>)
 802d94c:	4282      	cmp	r2, r0
 802d94e:	d10e      	bne.n	802d96e <HAL_ADC_ConfigChannel+0x112>
 802d950:	f013 7080 	ands.w	r0, r3, #16777216	; 0x1000000
 802d954:	d1b3      	bne.n	802d8be <HAL_ADC_ConfigChannel+0x62>
 802d956:	680b      	ldr	r3, [r1, #0]
 802d958:	f023 73e0 	bic.w	r3, r3, #29360128	; 0x1c00000
 802d95c:	432b      	orrs	r3, r5
 802d95e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 802d962:	600b      	str	r3, [r1, #0]
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);

    tmp_hal_status = HAL_ERROR;
  }

  __HAL_UNLOCK(hadc);
 802d964:	2300      	movs	r3, #0
 802d966:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54

  return tmp_hal_status;
}
 802d96a:	b003      	add	sp, #12
 802d96c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        else if ((pConfig->Channel == ADC_CHANNEL_VREFINT) &&
 802d96e:	4823      	ldr	r0, [pc, #140]	; (802d9fc <HAL_ADC_ConfigChannel+0x1a0>)
 802d970:	4282      	cmp	r2, r0
 802d972:	d1a4      	bne.n	802d8be <HAL_ADC_ConfigChannel+0x62>
 802d974:	f413 0080 	ands.w	r0, r3, #4194304	; 0x400000
 802d978:	d1a1      	bne.n	802d8be <HAL_ADC_ConfigChannel+0x62>
 802d97a:	680b      	ldr	r3, [r1, #0]
 802d97c:	f023 73e0 	bic.w	r3, r3, #29360128	; 0x1c00000
 802d980:	432b      	orrs	r3, r5
 802d982:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 802d986:	e7ec      	b.n	802d962 <HAL_ADC_ConfigChannel+0x106>
      if ((hadc->Init.ScanConvMode == ADC_SCAN_SEQ_FIXED)       ||
 802d988:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 802d98c:	d106      	bne.n	802d99c <HAL_ADC_ConfigChannel+0x140>
        LL_ADC_REG_SetSequencerChRem(hadc->Instance, pConfig->Channel);
 802d98e:	6821      	ldr	r1, [r4, #0]
  CLEAR_BIT(ADCx->CHSELR, (Channel & ADC_CHANNEL_ID_BITFIELD_MASK));
 802d990:	6a8b      	ldr	r3, [r1, #40]	; 0x28
 802d992:	f3c2 0011 	ubfx	r0, r2, #0, #18
 802d996:	ea23 0300 	bic.w	r3, r3, r0
 802d99a:	628b      	str	r3, [r1, #40]	; 0x28
      if (__LL_ADC_IS_CHANNEL_INTERNAL(pConfig->Channel))
 802d99c:	2a00      	cmp	r2, #0
 802d99e:	da8e      	bge.n	802d8be <HAL_ADC_ConfigChannel+0x62>
        if (pConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 802d9a0:	4812      	ldr	r0, [pc, #72]	; (802d9ec <HAL_ADC_ConfigChannel+0x190>)
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 802d9a2:	4911      	ldr	r1, [pc, #68]	; (802d9e8 <HAL_ADC_ConfigChannel+0x18c>)
 802d9a4:	4282      	cmp	r2, r0
 802d9a6:	680b      	ldr	r3, [r1, #0]
 802d9a8:	d107      	bne.n	802d9ba <HAL_ADC_ConfigChannel+0x15e>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 802d9aa:	680a      	ldr	r2, [r1, #0]
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 802d9ac:	f003 73a0 	and.w	r3, r3, #20971520	; 0x1400000
 802d9b0:	f022 72e0 	bic.w	r2, r2, #29360128	; 0x1c00000
 802d9b4:	4313      	orrs	r3, r2
 802d9b6:	600b      	str	r3, [r1, #0]
 802d9b8:	e781      	b.n	802d8be <HAL_ADC_ConfigChannel+0x62>
        else if (pConfig->Channel == ADC_CHANNEL_VBAT)
 802d9ba:	480f      	ldr	r0, [pc, #60]	; (802d9f8 <HAL_ADC_ConfigChannel+0x19c>)
 802d9bc:	4282      	cmp	r2, r0
 802d9be:	d103      	bne.n	802d9c8 <HAL_ADC_ConfigChannel+0x16c>
 802d9c0:	680a      	ldr	r2, [r1, #0]
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 802d9c2:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
 802d9c6:	e7f3      	b.n	802d9b0 <HAL_ADC_ConfigChannel+0x154>
        else if (pConfig->Channel == ADC_CHANNEL_VREFINT)
 802d9c8:	480c      	ldr	r0, [pc, #48]	; (802d9fc <HAL_ADC_ConfigChannel+0x1a0>)
 802d9ca:	4282      	cmp	r2, r0
 802d9cc:	f47f af77 	bne.w	802d8be <HAL_ADC_ConfigChannel+0x62>
 802d9d0:	680a      	ldr	r2, [r1, #0]
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 802d9d2:	f003 73c0 	and.w	r3, r3, #25165824	; 0x1800000
 802d9d6:	e7eb      	b.n	802d9b0 <HAL_ADC_ConfigChannel+0x154>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 802d9d8:	6da2      	ldr	r2, [r4, #88]	; 0x58
 802d9da:	f042 0220 	orr.w	r2, r2, #32
 802d9de:	65a2      	str	r2, [r4, #88]	; 0x58
    tmp_hal_status = HAL_ERROR;
 802d9e0:	4618      	mov	r0, r3
 802d9e2:	e7bf      	b.n	802d964 <HAL_ADC_ConfigChannel+0x108>
  __HAL_LOCK(hadc);
 802d9e4:	2002      	movs	r0, #2
 802d9e6:	e7c0      	b.n	802d96a <HAL_ADC_ConfigChannel+0x10e>
 802d9e8:	40012708 	.word	0x40012708
 802d9ec:	b0001000 	.word	0xb0001000
 802d9f0:	00030d40 	.word	0x00030d40
 802d9f4:	2000344c 	.word	0x2000344c
 802d9f8:	b8004000 	.word	0xb8004000
 802d9fc:	b4002000 	.word	0xb4002000

0802da00 <ADC_ConversionStop>:
  *         stopped to disable the ADC.
  * @param  hadc ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_ConversionStop(ADC_HandleTypeDef *hadc)
{
 802da00:	b538      	push	{r3, r4, r5, lr}
 802da02:	4604      	mov	r4, r0
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  /* Verification if ADC is not already stopped on regular group to bypass    */
  /* this function if not needed.                                             */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) != 0UL)
 802da04:	6800      	ldr	r0, [r0, #0]
 802da06:	f7ff fda3 	bl	802d550 <LL_ADC_REG_IsConversionOngoing>
 802da0a:	b908      	cbnz	r0, 802da10 <ADC_ConversionStop+0x10>
    }

  }

  /* Return HAL status */
  return HAL_OK;
 802da0c:	2000      	movs	r0, #0
}
 802da0e:	bd38      	pop	{r3, r4, r5, pc}
    if (LL_ADC_IsDisableOngoing(hadc->Instance) == 0UL)
 802da10:	6822      	ldr	r2, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADDIS) == (ADC_CR_ADDIS)) ? 1UL : 0UL);
 802da12:	6893      	ldr	r3, [r2, #8]
 802da14:	0799      	lsls	r1, r3, #30
 802da16:	d407      	bmi.n	802da28 <ADC_ConversionStop+0x28>
  MODIFY_REG(ADCx->CR,
 802da18:	6893      	ldr	r3, [r2, #8]
 802da1a:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802da1e:	f023 0317 	bic.w	r3, r3, #23
 802da22:	f043 0310 	orr.w	r3, r3, #16
 802da26:	6093      	str	r3, [r2, #8]
    tickstart = HAL_GetTick();
 802da28:	f7fe fe0c 	bl	802c644 <HAL_GetTick>
 802da2c:	4605      	mov	r5, r0
    while ((hadc->Instance->CR & ADC_CR_ADSTART) != 0UL)
 802da2e:	6823      	ldr	r3, [r4, #0]
 802da30:	689b      	ldr	r3, [r3, #8]
 802da32:	075b      	lsls	r3, r3, #29
 802da34:	d5ea      	bpl.n	802da0c <ADC_ConversionStop+0xc>
      if ((HAL_GetTick() - tickstart) > ADC_STOP_CONVERSION_TIMEOUT)
 802da36:	f7fe fe05 	bl	802c644 <HAL_GetTick>
 802da3a:	1b40      	subs	r0, r0, r5
 802da3c:	2802      	cmp	r0, #2
 802da3e:	d9f6      	bls.n	802da2e <ADC_ConversionStop+0x2e>
        if ((hadc->Instance->CR & ADC_CR_ADSTART) != 0UL)
 802da40:	6823      	ldr	r3, [r4, #0]
 802da42:	689b      	ldr	r3, [r3, #8]
 802da44:	075a      	lsls	r2, r3, #29
 802da46:	d5f2      	bpl.n	802da2e <ADC_ConversionStop+0x2e>
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 802da48:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802da4a:	f043 0310 	orr.w	r3, r3, #16
 802da4e:	65a3      	str	r3, [r4, #88]	; 0x58
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 802da50:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 802da52:	f043 0301 	orr.w	r3, r3, #1
 802da56:	65e3      	str	r3, [r4, #92]	; 0x5c
 802da58:	2001      	movs	r0, #1
 802da5a:	e7d8      	b.n	802da0e <ADC_ConversionStop+0xe>

0802da5c <ADC_Enable>:
  *         and voltage regulator must be enabled (done into HAL_ADC_Init()).
  * @param hadc ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_Enable(ADC_HandleTypeDef *hadc)
{
 802da5c:	b573      	push	{r0, r1, r4, r5, r6, lr}
  uint32_t tickstart;
  __IO uint32_t wait_loop_index = 0UL;
 802da5e:	2300      	movs	r3, #0

  /* ADC enable and wait for ADC ready (in case of ADC is disabled or         */
  /* enabling phase not yet completed: flag ADC ready not yet set).           */
  /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
  /* causes: ADC clock not running, ...).                                     */
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 802da60:	6802      	ldr	r2, [r0, #0]
  __IO uint32_t wait_loop_index = 0UL;
 802da62:	9301      	str	r3, [sp, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 802da64:	6893      	ldr	r3, [r2, #8]
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 802da66:	07dd      	lsls	r5, r3, #31
{
 802da68:	4604      	mov	r4, r0
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 802da6a:	d502      	bpl.n	802da72 <ADC_Enable+0x16>
      }
    }
  }

  /* Return HAL status */
  return HAL_OK;
 802da6c:	2000      	movs	r0, #0
}
 802da6e:	b002      	add	sp, #8
 802da70:	bd70      	pop	{r4, r5, r6, pc}
    if ((hadc->Instance->CR & (ADC_CR_ADCAL | ADC_CR_ADSTP | ADC_CR_ADSTART | ADC_CR_ADDIS | ADC_CR_ADEN)) != 0UL)
 802da72:	6891      	ldr	r1, [r2, #8]
 802da74:	4b21      	ldr	r3, [pc, #132]	; (802dafc <ADC_Enable+0xa0>)
 802da76:	4219      	tst	r1, r3
 802da78:	d009      	beq.n	802da8e <ADC_Enable+0x32>
            SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 802da7a:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802da7c:	f043 0310 	orr.w	r3, r3, #16
 802da80:	65a3      	str	r3, [r4, #88]	; 0x58
            SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 802da82:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 802da84:	f043 0301 	orr.w	r3, r3, #1
 802da88:	65e3      	str	r3, [r4, #92]	; 0x5c
            return HAL_ERROR;
 802da8a:	2001      	movs	r0, #1
 802da8c:	e7ef      	b.n	802da6e <ADC_Enable+0x12>
  MODIFY_REG(ADCx->CR,
 802da8e:	6893      	ldr	r3, [r2, #8]
 802da90:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802da94:	f023 0317 	bic.w	r3, r3, #23
 802da98:	f043 0301 	orr.w	r3, r3, #1
 802da9c:	6093      	str	r3, [r2, #8]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 802da9e:	4b18      	ldr	r3, [pc, #96]	; (802db00 <ADC_Enable+0xa4>)
 802daa0:	681b      	ldr	r3, [r3, #0]
    if ((LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) & LL_ADC_PATH_INTERNAL_TEMPSENSOR) != 0UL)
 802daa2:	0218      	lsls	r0, r3, #8
 802daa4:	d41c      	bmi.n	802dae0 <ADC_Enable+0x84>
    if (hadc->Init.LowPowerAutoPowerOff != ENABLE)
 802daa6:	7e63      	ldrb	r3, [r4, #25]
 802daa8:	2b01      	cmp	r3, #1
 802daaa:	d0df      	beq.n	802da6c <ADC_Enable+0x10>
      tickstart = HAL_GetTick();
 802daac:	f7fe fdca 	bl	802c644 <HAL_GetTick>
  MODIFY_REG(ADCx->CR,
 802dab0:	4e14      	ldr	r6, [pc, #80]	; (802db04 <ADC_Enable+0xa8>)
 802dab2:	4605      	mov	r5, r0
      while (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
 802dab4:	6822      	ldr	r2, [r4, #0]
 802dab6:	6813      	ldr	r3, [r2, #0]
 802dab8:	07db      	lsls	r3, r3, #31
 802daba:	d4d7      	bmi.n	802da6c <ADC_Enable+0x10>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 802dabc:	6893      	ldr	r3, [r2, #8]
        if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 802dabe:	07d9      	lsls	r1, r3, #31
  MODIFY_REG(ADCx->CR,
 802dac0:	bf5f      	itttt	pl
 802dac2:	6893      	ldrpl	r3, [r2, #8]
 802dac4:	4033      	andpl	r3, r6
 802dac6:	f043 0301 	orrpl.w	r3, r3, #1
 802daca:	6093      	strpl	r3, [r2, #8]
        if ((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
 802dacc:	f7fe fdba 	bl	802c644 <HAL_GetTick>
 802dad0:	1b40      	subs	r0, r0, r5
 802dad2:	2802      	cmp	r0, #2
 802dad4:	d9ee      	bls.n	802dab4 <ADC_Enable+0x58>
          if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
 802dad6:	6823      	ldr	r3, [r4, #0]
 802dad8:	681b      	ldr	r3, [r3, #0]
 802dada:	07da      	lsls	r2, r3, #31
 802dadc:	d4ea      	bmi.n	802dab4 <ADC_Enable+0x58>
 802dade:	e7cc      	b.n	802da7a <ADC_Enable+0x1e>
      wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_BUFFER_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 802dae0:	4b09      	ldr	r3, [pc, #36]	; (802db08 <ADC_Enable+0xac>)
 802dae2:	4a0a      	ldr	r2, [pc, #40]	; (802db0c <ADC_Enable+0xb0>)
 802dae4:	681b      	ldr	r3, [r3, #0]
 802dae6:	fbb3 f3f2 	udiv	r3, r3, r2
 802daea:	3301      	adds	r3, #1
        wait_loop_index--;
 802daec:	9301      	str	r3, [sp, #4]
      while (wait_loop_index != 0UL)
 802daee:	9b01      	ldr	r3, [sp, #4]
 802daf0:	2b00      	cmp	r3, #0
 802daf2:	d0d8      	beq.n	802daa6 <ADC_Enable+0x4a>
        wait_loop_index--;
 802daf4:	9b01      	ldr	r3, [sp, #4]
 802daf6:	3b01      	subs	r3, #1
 802daf8:	e7f8      	b.n	802daec <ADC_Enable+0x90>
 802dafa:	bf00      	nop
 802dafc:	80000017 	.word	0x80000017
 802db00:	40012708 	.word	0x40012708
 802db04:	7fffffe8 	.word	0x7fffffe8
 802db08:	2000344c 	.word	0x2000344c
 802db0c:	00030d40 	.word	0x00030d40

0802db10 <HAL_ADC_Start>:
{
 802db10:	b538      	push	{r3, r4, r5, lr}
 802db12:	4604      	mov	r4, r0
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 802db14:	6800      	ldr	r0, [r0, #0]
 802db16:	f7ff fd1b 	bl	802d550 <LL_ADC_REG_IsConversionOngoing>
 802db1a:	4605      	mov	r5, r0
 802db1c:	bb20      	cbnz	r0, 802db68 <HAL_ADC_Start+0x58>
    __HAL_LOCK(hadc);
 802db1e:	f894 3054 	ldrb.w	r3, [r4, #84]	; 0x54
 802db22:	2b01      	cmp	r3, #1
 802db24:	d020      	beq.n	802db68 <HAL_ADC_Start+0x58>
 802db26:	2301      	movs	r3, #1
 802db28:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54
    tmp_hal_status = ADC_Enable(hadc);
 802db2c:	4620      	mov	r0, r4
 802db2e:	f7ff ff95 	bl	802da5c <ADC_Enable>
    if (tmp_hal_status == HAL_OK)
 802db32:	b9b0      	cbnz	r0, 802db62 <HAL_ADC_Start+0x52>
      ADC_STATE_CLR_SET(hadc->State,
 802db34:	6da3      	ldr	r3, [r4, #88]	; 0x58
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 802db36:	6822      	ldr	r2, [r4, #0]
      ADC_STATE_CLR_SET(hadc->State,
 802db38:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 802db3c:	f023 0301 	bic.w	r3, r3, #1
 802db40:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 802db44:	65a3      	str	r3, [r4, #88]	; 0x58
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 802db46:	231c      	movs	r3, #28
      ADC_CLEAR_ERRORCODE(hadc);
 802db48:	65e0      	str	r0, [r4, #92]	; 0x5c
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 802db4a:	6013      	str	r3, [r2, #0]
      __HAL_UNLOCK(hadc);
 802db4c:	f884 0054 	strb.w	r0, [r4, #84]	; 0x54
  MODIFY_REG(ADCx->CR,
 802db50:	6893      	ldr	r3, [r2, #8]
 802db52:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802db56:	f023 0317 	bic.w	r3, r3, #23
 802db5a:	f043 0304 	orr.w	r3, r3, #4
 802db5e:	6093      	str	r3, [r2, #8]
}
 802db60:	bd38      	pop	{r3, r4, r5, pc}
      __HAL_UNLOCK(hadc);
 802db62:	f884 5054 	strb.w	r5, [r4, #84]	; 0x54
 802db66:	e7fb      	b.n	802db60 <HAL_ADC_Start+0x50>
    tmp_hal_status = HAL_BUSY;
 802db68:	2002      	movs	r0, #2
 802db6a:	e7f9      	b.n	802db60 <HAL_ADC_Start+0x50>

0802db6c <ADC_Disable>:
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_Disable(ADC_HandleTypeDef *hadc)
{
  uint32_t tickstart;
  const uint32_t tmp_adc_is_disable_on_going = LL_ADC_IsDisableOngoing(hadc->Instance);
 802db6c:	6802      	ldr	r2, [r0, #0]
{
 802db6e:	b538      	push	{r3, r4, r5, lr}
  return ((READ_BIT(ADCx->CR, ADC_CR_ADDIS) == (ADC_CR_ADDIS)) ? 1UL : 0UL);
 802db70:	6893      	ldr	r3, [r2, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 802db72:	6891      	ldr	r1, [r2, #8]
 802db74:	4604      	mov	r4, r0

  /* Verification if ADC is not already disabled:                             */
  /* Note: forbidden to disable ADC (set bit ADC_CR_ADDIS) if ADC is already  */
  /*       disabled.                                                          */
  if ((LL_ADC_IsEnabled(hadc->Instance) != 0UL)
 802db76:	07c8      	lsls	r0, r1, #31
 802db78:	d401      	bmi.n	802db7e <ADC_Disable+0x12>
      }
    }
  }

  /* Return HAL status */
  return HAL_OK;
 802db7a:	2000      	movs	r0, #0
}
 802db7c:	bd38      	pop	{r3, r4, r5, pc}
      && (tmp_adc_is_disable_on_going == 0UL)
 802db7e:	0799      	lsls	r1, r3, #30
 802db80:	d4fb      	bmi.n	802db7a <ADC_Disable+0xe>
    if ((hadc->Instance->CR & (ADC_CR_ADSTART | ADC_CR_ADEN)) == ADC_CR_ADEN)
 802db82:	6893      	ldr	r3, [r2, #8]
 802db84:	f003 0305 	and.w	r3, r3, #5
 802db88:	2b01      	cmp	r3, #1
 802db8a:	d119      	bne.n	802dbc0 <ADC_Disable+0x54>
  MODIFY_REG(ADCx->CR,
 802db8c:	6893      	ldr	r3, [r2, #8]
 802db8e:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802db92:	f023 0317 	bic.w	r3, r3, #23
 802db96:	f043 0302 	orr.w	r3, r3, #2
 802db9a:	6093      	str	r3, [r2, #8]
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOSMP | ADC_FLAG_RDY));
 802db9c:	2303      	movs	r3, #3
 802db9e:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 802dba0:	f7fe fd50 	bl	802c644 <HAL_GetTick>
 802dba4:	4605      	mov	r5, r0
    while ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
 802dba6:	6823      	ldr	r3, [r4, #0]
 802dba8:	689b      	ldr	r3, [r3, #8]
 802dbaa:	07db      	lsls	r3, r3, #31
 802dbac:	d5e5      	bpl.n	802db7a <ADC_Disable+0xe>
      if ((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
 802dbae:	f7fe fd49 	bl	802c644 <HAL_GetTick>
 802dbb2:	1b40      	subs	r0, r0, r5
 802dbb4:	2802      	cmp	r0, #2
 802dbb6:	d9f6      	bls.n	802dba6 <ADC_Disable+0x3a>
        if ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
 802dbb8:	6823      	ldr	r3, [r4, #0]
 802dbba:	689b      	ldr	r3, [r3, #8]
 802dbbc:	07da      	lsls	r2, r3, #31
 802dbbe:	d5f2      	bpl.n	802dba6 <ADC_Disable+0x3a>
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 802dbc0:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802dbc2:	f043 0310 	orr.w	r3, r3, #16
 802dbc6:	65a3      	str	r3, [r4, #88]	; 0x58
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 802dbc8:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 802dbca:	f043 0301 	orr.w	r3, r3, #1
 802dbce:	65e3      	str	r3, [r4, #92]	; 0x5c
          return HAL_ERROR;
 802dbd0:	2001      	movs	r0, #1
 802dbd2:	e7d3      	b.n	802db7c <ADC_Disable+0x10>

0802dbd4 <HAL_ADC_DeInit>:
{
 802dbd4:	b570      	push	{r4, r5, r6, lr}
  if (hadc == NULL)
 802dbd6:	4604      	mov	r4, r0
 802dbd8:	2800      	cmp	r0, #0
 802dbda:	d041      	beq.n	802dc60 <HAL_ADC_DeInit+0x8c>
  SET_BIT(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL);
 802dbdc:	6d83      	ldr	r3, [r0, #88]	; 0x58
 802dbde:	f043 0302 	orr.w	r3, r3, #2
 802dbe2:	6583      	str	r3, [r0, #88]	; 0x58
  tmp_hal_status = ADC_ConversionStop(hadc);
 802dbe4:	f7ff ff0c 	bl	802da00 <ADC_ConversionStop>
  if (tmp_hal_status == HAL_OK)
 802dbe8:	4605      	mov	r5, r0
 802dbea:	b968      	cbnz	r0, 802dc08 <HAL_ADC_DeInit+0x34>
    tmp_hal_status = ADC_Disable(hadc);
 802dbec:	4620      	mov	r0, r4
 802dbee:	f7ff ffbd 	bl	802db6c <ADC_Disable>
    if (tmp_hal_status == HAL_OK)
 802dbf2:	4605      	mov	r5, r0
 802dbf4:	b908      	cbnz	r0, 802dbfa <HAL_ADC_DeInit+0x26>
      hadc->State = HAL_ADC_STATE_READY;
 802dbf6:	2301      	movs	r3, #1
 802dbf8:	65a3      	str	r3, [r4, #88]	; 0x58
    LL_ADC_DisableInternalRegulator(hadc->Instance);
 802dbfa:	6822      	ldr	r2, [r4, #0]
  CLEAR_BIT(ADCx->CR, (ADC_CR_ADVREGEN | ADC_CR_BITS_PROPERTY_RS));
 802dbfc:	6893      	ldr	r3, [r2, #8]
 802dbfe:	f023 4310 	bic.w	r3, r3, #2415919104	; 0x90000000
 802dc02:	f023 0317 	bic.w	r3, r3, #23
 802dc06:	6093      	str	r3, [r2, #8]
  __HAL_ADC_DISABLE_IT(hadc, (ADC_IT_AWD3  | ADC_IT_AWD2 |
 802dc08:	6823      	ldr	r3, [r4, #0]
 802dc0a:	685a      	ldr	r2, [r3, #4]
 802dc0c:	f422 7267 	bic.w	r2, r2, #924	; 0x39c
 802dc10:	f022 0203 	bic.w	r2, r2, #3
 802dc14:	605a      	str	r2, [r3, #4]
  __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_AWD3  | ADC_FLAG_AWD2 |
 802dc16:	f240 329f 	movw	r2, #927	; 0x39f
 802dc1a:	601a      	str	r2, [r3, #0]
  hadc->Instance->CFGR1 &= ~(ADC_CFGR1_AWD1CH   | ADC_CFGR1_AWD1EN  | ADC_CFGR1_AWD1SGL | ADC_CFGR1_DISCEN |
 802dc1c:	68d9      	ldr	r1, [r3, #12]
 802dc1e:	4a11      	ldr	r2, [pc, #68]	; (802dc64 <HAL_ADC_DeInit+0x90>)
 802dc20:	400a      	ands	r2, r1
 802dc22:	60da      	str	r2, [r3, #12]
  hadc->Instance->CFGR2 &= ~ADC_CFGR2_CKMODE;
 802dc24:	691a      	ldr	r2, [r3, #16]
 802dc26:	f022 4240 	bic.w	r2, r2, #3221225472	; 0xc0000000
 802dc2a:	611a      	str	r2, [r3, #16]
  hadc->Instance->SMPR &= ~ADC_SMPR_SMP1;
 802dc2c:	695a      	ldr	r2, [r3, #20]
 802dc2e:	f022 0207 	bic.w	r2, r2, #7
 802dc32:	615a      	str	r2, [r3, #20]
  hadc->Instance->TR1 &= ~(ADC_TR1_HT1 | ADC_TR1_LT1);
 802dc34:	6a1a      	ldr	r2, [r3, #32]
 802dc36:	f002 22f0 	and.w	r2, r2, #4026593280	; 0xf000f000
 802dc3a:	621a      	str	r2, [r3, #32]
  hadc->Instance->CHSELR &= ~(ADC_CHSELR_SQ_ALL);
 802dc3c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  ADC_COMMON->CCR &= ~(ADC_CCR_VBATEN | ADC_CCR_TSEN | ADC_CCR_VREFEN | ADC_CCR_PRESC);
 802dc3e:	4a0a      	ldr	r2, [pc, #40]	; (802dc68 <HAL_ADC_DeInit+0x94>)
  hadc->Instance->CHSELR &= ~(ADC_CHSELR_SQ_ALL);
 802dc40:	2600      	movs	r6, #0
 802dc42:	629e      	str	r6, [r3, #40]	; 0x28
  ADC_COMMON->CCR &= ~(ADC_CCR_VBATEN | ADC_CCR_TSEN | ADC_CCR_VREFEN | ADC_CCR_PRESC);
 802dc44:	6813      	ldr	r3, [r2, #0]
 802dc46:	f023 73fe 	bic.w	r3, r3, #33292288	; 0x1fc0000
 802dc4a:	6013      	str	r3, [r2, #0]
  HAL_ADC_MspDeInit(hadc);
 802dc4c:	4620      	mov	r0, r4
 802dc4e:	f7fe f933 	bl	802beb8 <HAL_ADC_MspDeInit>
  ADC_CLEAR_ERRORCODE(hadc);
 802dc52:	65e6      	str	r6, [r4, #92]	; 0x5c
  hadc->ADCGroupRegularSequencerRanks = 0x00000000UL;
 802dc54:	6626      	str	r6, [r4, #96]	; 0x60
  hadc->State = HAL_ADC_STATE_RESET;
 802dc56:	65a6      	str	r6, [r4, #88]	; 0x58
  __HAL_UNLOCK(hadc);
 802dc58:	f884 6054 	strb.w	r6, [r4, #84]	; 0x54
}
 802dc5c:	4628      	mov	r0, r5
 802dc5e:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
 802dc60:	2501      	movs	r5, #1
 802dc62:	e7fb      	b.n	802dc5c <HAL_ADC_DeInit+0x88>
 802dc64:	833e0200 	.word	0x833e0200
 802dc68:	40012708 	.word	0x40012708

0802dc6c <HAL_ADC_Stop>:
{
 802dc6c:	b510      	push	{r4, lr}
  __HAL_LOCK(hadc);
 802dc6e:	f890 3054 	ldrb.w	r3, [r0, #84]	; 0x54
 802dc72:	2b01      	cmp	r3, #1
{
 802dc74:	4604      	mov	r4, r0
  __HAL_LOCK(hadc);
 802dc76:	d015      	beq.n	802dca4 <HAL_ADC_Stop+0x38>
 802dc78:	2301      	movs	r3, #1
 802dc7a:	f880 3054 	strb.w	r3, [r0, #84]	; 0x54
  tmp_hal_status = ADC_ConversionStop(hadc);
 802dc7e:	f7ff febf 	bl	802da00 <ADC_ConversionStop>
  if (tmp_hal_status == HAL_OK)
 802dc82:	b958      	cbnz	r0, 802dc9c <HAL_ADC_Stop+0x30>
    tmp_hal_status = ADC_Disable(hadc);
 802dc84:	4620      	mov	r0, r4
 802dc86:	f7ff ff71 	bl	802db6c <ADC_Disable>
    if (tmp_hal_status == HAL_OK)
 802dc8a:	b938      	cbnz	r0, 802dc9c <HAL_ADC_Stop+0x30>
      ADC_STATE_CLR_SET(hadc->State,
 802dc8c:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802dc8e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 802dc92:	f023 0301 	bic.w	r3, r3, #1
 802dc96:	f043 0301 	orr.w	r3, r3, #1
 802dc9a:	65a3      	str	r3, [r4, #88]	; 0x58
  __HAL_UNLOCK(hadc);
 802dc9c:	2300      	movs	r3, #0
 802dc9e:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54
}
 802dca2:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hadc);
 802dca4:	2002      	movs	r0, #2
 802dca6:	e7fc      	b.n	802dca2 <HAL_ADC_Stop+0x36>

0802dca8 <HAL_ADCEx_Calibration_Start>:
  *         HAL_ADC_GetValue() (value on 7 bits: from DR[6;0]).
  * @param  hadc       ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef *hadc)
{
 802dca8:	b513      	push	{r0, r1, r4, lr}
  HAL_StatusTypeDef tmp_hal_status;
  __IO uint32_t wait_loop_index = 0UL;
 802dcaa:	2300      	movs	r3, #0
 802dcac:	9301      	str	r3, [sp, #4]
  uint32_t backup_setting_adc_dma_transfer; /* Note: Variable not declared as volatile because register read is already declared as volatile */

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  __HAL_LOCK(hadc);
 802dcae:	f890 3054 	ldrb.w	r3, [r0, #84]	; 0x54
 802dcb2:	2b01      	cmp	r3, #1
{
 802dcb4:	4604      	mov	r4, r0
  __HAL_LOCK(hadc);
 802dcb6:	d040      	beq.n	802dd3a <HAL_ADCEx_Calibration_Start+0x92>
 802dcb8:	2301      	movs	r3, #1
 802dcba:	f880 3054 	strb.w	r3, [r0, #84]	; 0x54

  /* Calibration prerequisite: ADC must be disabled. */

  /* Disable the ADC (if not already disabled) */
  tmp_hal_status = ADC_Disable(hadc);
 802dcbe:	f7ff ff55 	bl	802db6c <ADC_Disable>

  /* Check if ADC is effectively disabled */
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 802dcc2:	6823      	ldr	r3, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 802dcc4:	689a      	ldr	r2, [r3, #8]
 802dcc6:	07d2      	lsls	r2, r2, #31
 802dcc8:	d433      	bmi.n	802dd32 <HAL_ADCEx_Calibration_Start+0x8a>
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 802dcca:	6da2      	ldr	r2, [r4, #88]	; 0x58
 802dccc:	f422 7281 	bic.w	r2, r2, #258	; 0x102
 802dcd0:	f042 0202 	orr.w	r2, r2, #2
 802dcd4:	65a2      	str	r2, [r4, #88]	; 0x58
    /* Note: Specificity of this STM32 series: Calibration factor is          */
    /*       available in data register and also transferred by DMA.          */
    /*       To not insert ADC calibration factor among ADC conversion data   */
    /*       in array variable, DMA transfer must be disabled during          */
    /*       calibration.                                                     */
    backup_setting_adc_dma_transfer = READ_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 802dcd6:	68d9      	ldr	r1, [r3, #12]
    CLEAR_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 802dcd8:	68da      	ldr	r2, [r3, #12]
 802dcda:	f022 0203 	bic.w	r2, r2, #3
 802dcde:	60da      	str	r2, [r3, #12]

    /* Start ADC calibration */
    SET_BIT(hadc->Instance->CR, ADC_CR_ADCAL);
 802dce0:	689a      	ldr	r2, [r3, #8]
 802dce2:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
    backup_setting_adc_dma_transfer = READ_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 802dce6:	f001 0103 	and.w	r1, r1, #3
    SET_BIT(hadc->Instance->CR, ADC_CR_ADCAL);
 802dcea:	609a      	str	r2, [r3, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADCAL) == (ADC_CR_ADCAL)) ? 1UL : 0UL);
 802dcec:	689a      	ldr	r2, [r3, #8]
 802dcee:	2a00      	cmp	r2, #0
 802dcf0:	da12      	bge.n	802dd18 <HAL_ADCEx_Calibration_Start+0x70>

    /* Wait for calibration completion */
    while (LL_ADC_IsCalibrationOnGoing(hadc->Instance) != 0UL)
    {
      wait_loop_index++;
 802dcf2:	9a01      	ldr	r2, [sp, #4]
 802dcf4:	3201      	adds	r2, #1
 802dcf6:	9201      	str	r2, [sp, #4]
      if (wait_loop_index >= ADC_CALIBRATION_TIMEOUT)
 802dcf8:	9a01      	ldr	r2, [sp, #4]
 802dcfa:	f5b2 3f2e 	cmp.w	r2, #178176	; 0x2b800
 802dcfe:	d3f5      	bcc.n	802dcec <HAL_ADCEx_Calibration_Start+0x44>
      {
        /* Update ADC state machine to error */
        ADC_STATE_CLR_SET(hadc->State,
 802dd00:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802dd02:	f023 0312 	bic.w	r3, r3, #18
 802dd06:	f043 0310 	orr.w	r3, r3, #16
 802dd0a:	65a3      	str	r3, [r4, #88]	; 0x58
                          HAL_ADC_STATE_BUSY_INTERNAL,
                          HAL_ADC_STATE_ERROR_INTERNAL);

        __HAL_UNLOCK(hadc);
 802dd0c:	2300      	movs	r3, #0
 802dd0e:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54

        return HAL_ERROR;
 802dd12:	2001      	movs	r0, #1
  }

  __HAL_UNLOCK(hadc);

  return tmp_hal_status;
}
 802dd14:	b002      	add	sp, #8
 802dd16:	bd10      	pop	{r4, pc}
    SET_BIT(hadc->Instance->CFGR1, backup_setting_adc_dma_transfer);
 802dd18:	68da      	ldr	r2, [r3, #12]
 802dd1a:	430a      	orrs	r2, r1
 802dd1c:	60da      	str	r2, [r3, #12]
    ADC_STATE_CLR_SET(hadc->State,
 802dd1e:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802dd20:	f023 0303 	bic.w	r3, r3, #3
 802dd24:	f043 0301 	orr.w	r3, r3, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 802dd28:	65a3      	str	r3, [r4, #88]	; 0x58
  __HAL_UNLOCK(hadc);
 802dd2a:	2300      	movs	r3, #0
 802dd2c:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54
  return tmp_hal_status;
 802dd30:	e7f0      	b.n	802dd14 <HAL_ADCEx_Calibration_Start+0x6c>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 802dd32:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802dd34:	f043 0310 	orr.w	r3, r3, #16
 802dd38:	e7f6      	b.n	802dd28 <HAL_ADCEx_Calibration_Start+0x80>
  __HAL_LOCK(hadc);
 802dd3a:	2002      	movs	r0, #2
 802dd3c:	e7ea      	b.n	802dd14 <HAL_ADCEx_Calibration_Start+0x6c>
	...

0802dd40 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 802dd40:	4907      	ldr	r1, [pc, #28]	; (802dd60 <HAL_NVIC_SetPriorityGrouping+0x20>)
 802dd42:	68ca      	ldr	r2, [r1, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 802dd44:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 802dd48:	0203      	lsls	r3, r0, #8
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 802dd4a:	0412      	lsls	r2, r2, #16
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 802dd4c:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 802dd50:	0c12      	lsrs	r2, r2, #16
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 802dd52:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 802dd54:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 802dd58:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  SCB->AIRCR =  reg_value;
 802dd5c:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 802dd5e:	4770      	bx	lr
 802dd60:	e000ed00 	.word	0xe000ed00

0802dd64 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 802dd64:	4b16      	ldr	r3, [pc, #88]	; (802ddc0 <HAL_NVIC_SetPriority+0x5c>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 802dd66:	b530      	push	{r4, r5, lr}
 802dd68:	68dc      	ldr	r4, [r3, #12]
 802dd6a:	f3c4 2402 	ubfx	r4, r4, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 802dd6e:	f1c4 0307 	rsb	r3, r4, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 802dd72:	1d25      	adds	r5, r4, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 802dd74:	2b04      	cmp	r3, #4
 802dd76:	bf28      	it	cs
 802dd78:	2304      	movcs	r3, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 802dd7a:	2d06      	cmp	r5, #6

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 802dd7c:	f04f 35ff 	mov.w	r5, #4294967295
 802dd80:	fa05 f303 	lsl.w	r3, r5, r3
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 802dd84:	bf8c      	ite	hi
 802dd86:	3c03      	subhi	r4, #3
 802dd88:	2400      	movls	r4, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 802dd8a:	ea21 0303 	bic.w	r3, r1, r3
 802dd8e:	40a3      	lsls	r3, r4
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 802dd90:	fa05 f404 	lsl.w	r4, r5, r4
 802dd94:	ea22 0204 	bic.w	r2, r2, r4
  if ((int32_t)(IRQn) >= 0)
 802dd98:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 802dd9a:	ea43 0302 	orr.w	r3, r3, r2
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802dd9e:	bfac      	ite	ge
 802dda0:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802dda4:	4a07      	ldrlt	r2, [pc, #28]	; (802ddc4 <HAL_NVIC_SetPriority+0x60>)
 802dda6:	ea4f 1303 	mov.w	r3, r3, lsl #4
 802ddaa:	bfb8      	it	lt
 802ddac:	f000 000f 	andlt.w	r0, r0, #15
 802ddb0:	b2db      	uxtb	r3, r3
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802ddb2:	bfaa      	itet	ge
 802ddb4:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802ddb8:	5413      	strblt	r3, [r2, r0]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802ddba:	f880 3300 	strbge.w	r3, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 802ddbe:	bd30      	pop	{r4, r5, pc}
 802ddc0:	e000ed00 	.word	0xe000ed00
 802ddc4:	e000ed14 	.word	0xe000ed14

0802ddc8 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 802ddc8:	2800      	cmp	r0, #0
 802ddca:	db08      	blt.n	802ddde <HAL_NVIC_EnableIRQ+0x16>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 802ddcc:	2301      	movs	r3, #1
 802ddce:	0942      	lsrs	r2, r0, #5
 802ddd0:	f000 001f 	and.w	r0, r0, #31
 802ddd4:	fa03 f000 	lsl.w	r0, r3, r0
 802ddd8:	4b01      	ldr	r3, [pc, #4]	; (802dde0 <HAL_NVIC_EnableIRQ+0x18>)
 802ddda:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 802ddde:	4770      	bx	lr
 802dde0:	e000e100 	.word	0xe000e100

0802dde4 <HAL_NVIC_DisableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 802dde4:	2800      	cmp	r0, #0
 802dde6:	db0d      	blt.n	802de04 <HAL_NVIC_DisableIRQ+0x20>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 802dde8:	0943      	lsrs	r3, r0, #5
 802ddea:	2201      	movs	r2, #1
 802ddec:	f000 001f 	and.w	r0, r0, #31
 802ddf0:	fa02 f000 	lsl.w	r0, r2, r0
 802ddf4:	3320      	adds	r3, #32
 802ddf6:	4a04      	ldr	r2, [pc, #16]	; (802de08 <HAL_NVIC_DisableIRQ+0x24>)
 802ddf8:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
 802ddfc:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 802de00:	f3bf 8f6f 	isb	sy
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
}
 802de04:	4770      	bx	lr
 802de06:	bf00      	nop
 802de08:	e000e100 	.word	0xe000e100

0802de0c <DMA_SetConfig>:
  * @param DstAddress The destination memory Buffer address
  * @param DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 802de0c:	b570      	push	{r4, r5, r6, lr}
  /* Clear the DMAMUX synchro overrun flag */
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 802de0e:	e9d0 4513 	ldrd	r4, r5, [r0, #76]	; 0x4c
 802de12:	6065      	str	r5, [r4, #4]

  if (hdma->DMAmuxRequestGen != 0U)
 802de14:	6d44      	ldr	r4, [r0, #84]	; 0x54
 802de16:	b114      	cbz	r4, 802de1e <DMA_SetConfig+0x12>
  {
    /* Clear the DMAMUX request generator overrun flag */
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 802de18:	e9d0 4516 	ldrd	r4, r5, [r0, #88]	; 0x58
 802de1c:	6065      	str	r5, [r4, #4]
  }

  /* Clear all flags */
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 802de1e:	e9d0 5410 	ldrd	r5, r4, [r0, #64]	; 0x40
 802de22:	f004 061c 	and.w	r6, r4, #28
 802de26:	2401      	movs	r4, #1
 802de28:	40b4      	lsls	r4, r6
 802de2a:	606c      	str	r4, [r5, #4]

  /* Configure DMA Channel data length */
  hdma->Instance->CNDTR = DataLength;
 802de2c:	6804      	ldr	r4, [r0, #0]
 802de2e:	6063      	str	r3, [r4, #4]

  /* Memory to Peripheral */
  if ((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 802de30:	6883      	ldr	r3, [r0, #8]
 802de32:	2b10      	cmp	r3, #16
  {
    /* Configure DMA Channel destination address */
    hdma->Instance->CPAR = DstAddress;
 802de34:	bf0b      	itete	eq
 802de36:	60a2      	streq	r2, [r4, #8]
  }
  /* Peripheral to Memory */
  else
  {
    /* Configure DMA Channel source address */
    hdma->Instance->CPAR = SrcAddress;
 802de38:	60a1      	strne	r1, [r4, #8]
    hdma->Instance->CMAR = SrcAddress;
 802de3a:	60e1      	streq	r1, [r4, #12]

    /* Configure DMA Channel destination address */
    hdma->Instance->CMAR = DstAddress;
 802de3c:	60e2      	strne	r2, [r4, #12]
  }
}
 802de3e:	bd70      	pop	{r4, r5, r6, pc}

0802de40 <DMA_CalcDMAMUXChannelBaseAndMask>:
static void DMA_CalcDMAMUXChannelBaseAndMask(DMA_HandleTypeDef *hdma)
{
  uint32_t channel_number;

  /* check if instance is not outside the DMA channel range */
  if ((uint32_t)hdma->Instance < (uint32_t)DMA2_Channel1)
 802de40:	6802      	ldr	r2, [r0, #0]
 802de42:	6c41      	ldr	r1, [r0, #68]	; 0x44
 802de44:	b2d3      	uxtb	r3, r2
{
 802de46:	b510      	push	{r4, lr}
 802de48:	3b08      	subs	r3, #8
 802de4a:	2414      	movs	r4, #20
 802de4c:	fbb3 f3f4 	udiv	r3, r3, r4
  if ((uint32_t)hdma->Instance < (uint32_t)DMA2_Channel1)
 802de50:	4c0b      	ldr	r4, [pc, #44]	; (802de80 <DMA_CalcDMAMUXChannelBaseAndMask+0x40>)
 802de52:	42a2      	cmp	r2, r4
  }
  else
  {
    /* DMA2 */
    /* Associate a DMA Channel to a DMAMUX channel */
    hdma->DMAmuxChannel = (DMAMUX1_Channel7 + (hdma->ChannelIndex >> 2U));
 802de54:	bf88      	it	hi
 802de56:	4a0b      	ldrhi	r2, [pc, #44]	; (802de84 <DMA_CalcDMAMUXChannelBaseAndMask+0x44>)
 802de58:	f021 0103 	bic.w	r1, r1, #3
    hdma->DMAmuxChannel = (DMAMUX1_Channel0 + (hdma->ChannelIndex >> 2U));
 802de5c:	bf99      	ittee	ls
 802de5e:	f101 4280 	addls.w	r2, r1, #1073741824	; 0x40000000
 802de62:	f502 3202 	addls.w	r2, r2, #133120	; 0x20800
    hdma->DMAmuxChannel = (DMAMUX1_Channel7 + (hdma->ChannelIndex >> 2U));
 802de66:	1852      	addhi	r2, r2, r1

    /* Prepare channel_number used for DMAmuxChannelStatusMask computation */
    channel_number = (((((uint32_t)hdma->Instance & 0xFFU) - 8U) / 20U) + 7U);
 802de68:	3307      	addhi	r3, #7
 802de6a:	6482      	str	r2, [r0, #72]	; 0x48
  }

  /* Initialize the field DMAmuxChannelStatus to DMAMUX1_ChannelStatus base */
  hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
 802de6c:	4a06      	ldr	r2, [pc, #24]	; (802de88 <DMA_CalcDMAMUXChannelBaseAndMask+0x48>)
 802de6e:	64c2      	str	r2, [r0, #76]	; 0x4c

  /* Initialize the field DMAmuxChannelStatusMask with the corresponding index of the DMAMUX channel selected for the current ChannelIndex */
  hdma->DMAmuxChannelStatusMask = 1UL << (channel_number & 0x1FU);
 802de70:	f003 031f 	and.w	r3, r3, #31
 802de74:	2201      	movs	r2, #1
 802de76:	fa02 f303 	lsl.w	r3, r2, r3
 802de7a:	6503      	str	r3, [r0, #80]	; 0x50
}
 802de7c:	bd10      	pop	{r4, pc}
 802de7e:	bf00      	nop
 802de80:	40020407 	.word	0x40020407
 802de84:	4002081c 	.word	0x4002081c
 802de88:	40020880 	.word	0x40020880

0802de8c <HAL_DMA_Init>:
{
 802de8c:	b510      	push	{r4, lr}
  if (hdma == NULL)
 802de8e:	2800      	cmp	r0, #0
 802de90:	d060      	beq.n	802df54 <HAL_DMA_Init+0xc8>
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 802de92:	6802      	ldr	r2, [r0, #0]
 802de94:	4b30      	ldr	r3, [pc, #192]	; (802df58 <HAL_DMA_Init+0xcc>)
 802de96:	429a      	cmp	r2, r3
 802de98:	f04f 0414 	mov.w	r4, #20
 802de9c:	d84d      	bhi.n	802df3a <HAL_DMA_Init+0xae>
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 802de9e:	492f      	ldr	r1, [pc, #188]	; (802df5c <HAL_DMA_Init+0xd0>)
 802dea0:	4411      	add	r1, r2
 802dea2:	fbb1 f1f4 	udiv	r1, r1, r4
 802dea6:	0089      	lsls	r1, r1, #2
 802dea8:	6441      	str	r1, [r0, #68]	; 0x44
    hdma->DmaBaseAddress = DMA1;
 802deaa:	f2a3 4307 	subw	r3, r3, #1031	; 0x407
    hdma->DmaBaseAddress = DMA2;
 802deae:	6403      	str	r3, [r0, #64]	; 0x40
  hdma->State = HAL_DMA_STATE_BUSY;
 802deb0:	2302      	movs	r3, #2
 802deb2:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
  CLEAR_BIT(hdma->Instance->CCR, (DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 802deb6:	6813      	ldr	r3, [r2, #0]
 802deb8:	f423 43ff 	bic.w	r3, r3, #32640	; 0x7f80
 802debc:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 802dec0:	6013      	str	r3, [r2, #0]
  SET_BIT(hdma->Instance->CCR, (hdma->Init.Direction           |                               \
 802dec2:	e9d0 3402 	ldrd	r3, r4, [r0, #8]
 802dec6:	4323      	orrs	r3, r4
 802dec8:	6904      	ldr	r4, [r0, #16]
 802deca:	6811      	ldr	r1, [r2, #0]
 802decc:	4323      	orrs	r3, r4
 802dece:	6944      	ldr	r4, [r0, #20]
 802ded0:	4323      	orrs	r3, r4
 802ded2:	6984      	ldr	r4, [r0, #24]
 802ded4:	4323      	orrs	r3, r4
 802ded6:	69c4      	ldr	r4, [r0, #28]
 802ded8:	4323      	orrs	r3, r4
 802deda:	6a04      	ldr	r4, [r0, #32]
 802dedc:	4323      	orrs	r3, r4
 802dede:	430b      	orrs	r3, r1
 802dee0:	6013      	str	r3, [r2, #0]
  DMA_CalcDMAMUXChannelBaseAndMask(hdma);
 802dee2:	f7ff ffad 	bl	802de40 <DMA_CalcDMAMUXChannelBaseAndMask>
  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 802dee6:	6883      	ldr	r3, [r0, #8]
  hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 802dee8:	6c81      	ldr	r1, [r0, #72]	; 0x48
  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 802deea:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
    hdma->Init.Request = DMA_REQUEST_MEM2MEM;
 802deee:	bf04      	itt	eq
 802def0:	2300      	moveq	r3, #0
 802def2:	6043      	streq	r3, [r0, #4]
  hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 802def4:	6842      	ldr	r2, [r0, #4]
 802def6:	f002 037f 	and.w	r3, r2, #127	; 0x7f
 802defa:	600b      	str	r3, [r1, #0]
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 802defc:	e9d0 1413 	ldrd	r1, r4, [r0, #76]	; 0x4c
  if (((hdma->Init.Request >  0UL) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 802df00:	3a01      	subs	r2, #1
 802df02:	2a03      	cmp	r2, #3
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 802df04:	604c      	str	r4, [r1, #4]
  if (((hdma->Init.Request >  0UL) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 802df06:	d820      	bhi.n	802df4a <HAL_DMA_Init+0xbe>
static void DMA_CalcDMAMUXRequestGenBaseAndMask(DMA_HandleTypeDef *hdma)
{
  uint32_t request =  hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID;

  /* DMA Channels are connected to DMAMUX1 request generator blocks*/
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 802df08:	4a15      	ldr	r2, [pc, #84]	; (802df60 <HAL_DMA_Init+0xd4>)

  hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
 802df0a:	4c16      	ldr	r4, [pc, #88]	; (802df64 <HAL_DMA_Init+0xd8>)
 802df0c:	6584      	str	r4, [r0, #88]	; 0x58
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 802df0e:	441a      	add	r2, r3

  /* here "Request" is either DMA_REQUEST_GENERATOR0 to DMA_REQUEST_GENERATOR3, i.e. <= 4*/
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x3U);
 802df10:	3b01      	subs	r3, #1
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 802df12:	0092      	lsls	r2, r2, #2
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x3U);
 802df14:	2101      	movs	r1, #1
 802df16:	f003 0303 	and.w	r3, r3, #3
 802df1a:	fa01 f303 	lsl.w	r3, r1, r3
    hdma->DMAmuxRequestGen->RGCR = 0U;
 802df1e:	2100      	movs	r1, #0
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 802df20:	6542      	str	r2, [r0, #84]	; 0x54
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x3U);
 802df22:	65c3      	str	r3, [r0, #92]	; 0x5c
    hdma->DMAmuxRequestGen->RGCR = 0U;
 802df24:	6011      	str	r1, [r2, #0]
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 802df26:	6063      	str	r3, [r4, #4]
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 802df28:	2300      	movs	r3, #0
  hdma->State = HAL_DMA_STATE_READY;
 802df2a:	2201      	movs	r2, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 802df2c:	63c3      	str	r3, [r0, #60]	; 0x3c
  __HAL_UNLOCK(hdma);
 802df2e:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
  hdma->State = HAL_DMA_STATE_READY;
 802df32:	f880 2025 	strb.w	r2, [r0, #37]	; 0x25
  return HAL_OK;
 802df36:	4618      	mov	r0, r3
}
 802df38:	bd10      	pop	{r4, pc}
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2U;
 802df3a:	4b0b      	ldr	r3, [pc, #44]	; (802df68 <HAL_DMA_Init+0xdc>)
 802df3c:	4413      	add	r3, r2
 802df3e:	fbb3 f3f4 	udiv	r3, r3, r4
 802df42:	009b      	lsls	r3, r3, #2
 802df44:	6443      	str	r3, [r0, #68]	; 0x44
    hdma->DmaBaseAddress = DMA2;
 802df46:	4b09      	ldr	r3, [pc, #36]	; (802df6c <HAL_DMA_Init+0xe0>)
 802df48:	e7b1      	b.n	802deae <HAL_DMA_Init+0x22>
    hdma->DMAmuxRequestGen = 0U;
 802df4a:	2300      	movs	r3, #0
    hdma->DMAmuxRequestGenStatus = 0U;
 802df4c:	e9c0 3315 	strd	r3, r3, [r0, #84]	; 0x54
    hdma->DMAmuxRequestGenStatusMask = 0U;
 802df50:	65c3      	str	r3, [r0, #92]	; 0x5c
 802df52:	e7e9      	b.n	802df28 <HAL_DMA_Init+0x9c>
    return HAL_ERROR;
 802df54:	2001      	movs	r0, #1
 802df56:	e7ef      	b.n	802df38 <HAL_DMA_Init+0xac>
 802df58:	40020407 	.word	0x40020407
 802df5c:	bffdfff8 	.word	0xbffdfff8
 802df60:	1000823f 	.word	0x1000823f
 802df64:	40020940 	.word	0x40020940
 802df68:	bffdfbf8 	.word	0xbffdfbf8
 802df6c:	40020400 	.word	0x40020400

0802df70 <HAL_DMA_DeInit>:
{
 802df70:	b538      	push	{r3, r4, r5, lr}
  if (NULL == hdma)
 802df72:	2800      	cmp	r0, #0
 802df74:	d045      	beq.n	802e002 <HAL_DMA_DeInit+0x92>
  __HAL_DMA_DISABLE(hdma);
 802df76:	6801      	ldr	r1, [r0, #0]
 802df78:	680b      	ldr	r3, [r1, #0]
 802df7a:	f023 0301 	bic.w	r3, r3, #1
 802df7e:	600b      	str	r3, [r1, #0]
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 802df80:	4b21      	ldr	r3, [pc, #132]	; (802e008 <HAL_DMA_DeInit+0x98>)
 802df82:	4299      	cmp	r1, r3
 802df84:	f04f 0414 	mov.w	r4, #20
 802df88:	d833      	bhi.n	802dff2 <HAL_DMA_DeInit+0x82>
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 802df8a:	4a20      	ldr	r2, [pc, #128]	; (802e00c <HAL_DMA_DeInit+0x9c>)
 802df8c:	440a      	add	r2, r1
 802df8e:	fbb2 f2f4 	udiv	r2, r2, r4
 802df92:	0092      	lsls	r2, r2, #2
 802df94:	6442      	str	r2, [r0, #68]	; 0x44
    hdma->DmaBaseAddress = DMA1;
 802df96:	f2a3 4307 	subw	r3, r3, #1031	; 0x407
    hdma->DmaBaseAddress = DMA2;
 802df9a:	6403      	str	r3, [r0, #64]	; 0x40
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 802df9c:	e9d0 2310 	ldrd	r2, r3, [r0, #64]	; 0x40
 802dfa0:	2401      	movs	r4, #1
 802dfa2:	f003 031c 	and.w	r3, r3, #28
 802dfa6:	fa04 f303 	lsl.w	r3, r4, r3
  hdma->Instance->CCR = 0U;
 802dfaa:	2500      	movs	r5, #0
 802dfac:	600d      	str	r5, [r1, #0]
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 802dfae:	6053      	str	r3, [r2, #4]
  DMA_CalcDMAMUXChannelBaseAndMask(hdma);
 802dfb0:	f7ff ff46 	bl	802de40 <DMA_CalcDMAMUXChannelBaseAndMask>
  hdma->DMAmuxChannel->CCR = 0U;
 802dfb4:	6c83      	ldr	r3, [r0, #72]	; 0x48
  if (((hdma->Init.Request >  0UL) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 802dfb6:	6841      	ldr	r1, [r0, #4]
  hdma->DMAmuxChannel->CCR = 0U;
 802dfb8:	601d      	str	r5, [r3, #0]
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 802dfba:	e9d0 3213 	ldrd	r3, r2, [r0, #76]	; 0x4c
 802dfbe:	605a      	str	r2, [r3, #4]
  if (((hdma->Init.Request >  0UL) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 802dfc0:	1e4a      	subs	r2, r1, #1
 802dfc2:	2a03      	cmp	r2, #3
 802dfc4:	d806      	bhi.n	802dfd4 <HAL_DMA_DeInit+0x64>
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 802dfc6:	4b12      	ldr	r3, [pc, #72]	; (802e010 <HAL_DMA_DeInit+0xa0>)
 802dfc8:	440b      	add	r3, r1
 802dfca:	009b      	lsls	r3, r3, #2
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x3U);
 802dfcc:	4094      	lsls	r4, r2
    hdma->DMAmuxRequestGen->RGCR = 0U;
 802dfce:	601d      	str	r5, [r3, #0]
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 802dfd0:	4b10      	ldr	r3, [pc, #64]	; (802e014 <HAL_DMA_DeInit+0xa4>)
 802dfd2:	605c      	str	r4, [r3, #4]
  hdma->DMAmuxRequestGen = 0U;
 802dfd4:	2300      	movs	r3, #0
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 802dfd6:	63c3      	str	r3, [r0, #60]	; 0x3c
  hdma->DMAmuxRequestGenStatus = 0U;
 802dfd8:	e9c0 3315 	strd	r3, r3, [r0, #84]	; 0x54
  hdma->XferHalfCpltCallback = NULL;
 802dfdc:	e9c0 330b 	strd	r3, r3, [r0, #44]	; 0x2c
  hdma->XferAbortCallback = NULL;
 802dfe0:	e9c0 330d 	strd	r3, r3, [r0, #52]	; 0x34
  hdma->DMAmuxRequestGenStatusMask = 0U;
 802dfe4:	65c3      	str	r3, [r0, #92]	; 0x5c
  hdma->State = HAL_DMA_STATE_RESET;
 802dfe6:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
  __HAL_UNLOCK(hdma);
 802dfea:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
  return HAL_OK;
 802dfee:	4618      	mov	r0, r3
}
 802dff0:	bd38      	pop	{r3, r4, r5, pc}
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2U;
 802dff2:	4b09      	ldr	r3, [pc, #36]	; (802e018 <HAL_DMA_DeInit+0xa8>)
 802dff4:	440b      	add	r3, r1
 802dff6:	fbb3 f3f4 	udiv	r3, r3, r4
 802dffa:	009b      	lsls	r3, r3, #2
 802dffc:	6443      	str	r3, [r0, #68]	; 0x44
    hdma->DmaBaseAddress = DMA2;
 802dffe:	4b07      	ldr	r3, [pc, #28]	; (802e01c <HAL_DMA_DeInit+0xac>)
 802e000:	e7cb      	b.n	802df9a <HAL_DMA_DeInit+0x2a>
    return HAL_ERROR;
 802e002:	2001      	movs	r0, #1
 802e004:	e7f4      	b.n	802dff0 <HAL_DMA_DeInit+0x80>
 802e006:	bf00      	nop
 802e008:	40020407 	.word	0x40020407
 802e00c:	bffdfff8 	.word	0xbffdfff8
 802e010:	1000823f 	.word	0x1000823f
 802e014:	40020940 	.word	0x40020940
 802e018:	bffdfbf8 	.word	0xbffdfbf8
 802e01c:	40020400 	.word	0x40020400

0802e020 <HAL_DMA_Start_IT>:
{
 802e020:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(hdma);
 802e022:	f890 5024 	ldrb.w	r5, [r0, #36]	; 0x24
 802e026:	2d01      	cmp	r5, #1
{
 802e028:	4604      	mov	r4, r0
  __HAL_LOCK(hdma);
 802e02a:	d03c      	beq.n	802e0a6 <HAL_DMA_Start_IT+0x86>
  if (hdma->State == HAL_DMA_STATE_READY)
 802e02c:	f890 6025 	ldrb.w	r6, [r0, #37]	; 0x25
  __HAL_LOCK(hdma);
 802e030:	2501      	movs	r5, #1
  if (hdma->State == HAL_DMA_STATE_READY)
 802e032:	42ae      	cmp	r6, r5
  __HAL_LOCK(hdma);
 802e034:	f880 5024 	strb.w	r5, [r0, #36]	; 0x24
  if (hdma->State == HAL_DMA_STATE_READY)
 802e038:	f04f 0600 	mov.w	r6, #0
 802e03c:	d12d      	bne.n	802e09a <HAL_DMA_Start_IT+0x7a>
    hdma->State = HAL_DMA_STATE_BUSY;
 802e03e:	2502      	movs	r5, #2
 802e040:	f880 5025 	strb.w	r5, [r0, #37]	; 0x25
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 802e044:	63c6      	str	r6, [r0, #60]	; 0x3c
    __HAL_DMA_DISABLE(hdma);
 802e046:	6806      	ldr	r6, [r0, #0]
 802e048:	6835      	ldr	r5, [r6, #0]
 802e04a:	f025 0501 	bic.w	r5, r5, #1
 802e04e:	6035      	str	r5, [r6, #0]
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
 802e050:	f7ff fedc 	bl	802de0c <DMA_SetConfig>
    if (NULL != hdma->XferHalfCpltCallback)
 802e054:	6b02      	ldr	r2, [r0, #48]	; 0x30
 802e056:	6803      	ldr	r3, [r0, #0]
 802e058:	b1ba      	cbz	r2, 802e08a <HAL_DMA_Start_IT+0x6a>
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 802e05a:	681a      	ldr	r2, [r3, #0]
 802e05c:	f042 020e 	orr.w	r2, r2, #14
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_TE));
 802e060:	601a      	str	r2, [r3, #0]
    if ((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)
 802e062:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 802e064:	6811      	ldr	r1, [r2, #0]
 802e066:	03c9      	lsls	r1, r1, #15
      hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;
 802e068:	bf42      	ittt	mi
 802e06a:	6811      	ldrmi	r1, [r2, #0]
 802e06c:	f441 7180 	orrmi.w	r1, r1, #256	; 0x100
 802e070:	6011      	strmi	r1, [r2, #0]
    if (hdma->DMAmuxRequestGen != 0U)
 802e072:	6d62      	ldr	r2, [r4, #84]	; 0x54
 802e074:	b11a      	cbz	r2, 802e07e <HAL_DMA_Start_IT+0x5e>
      hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
 802e076:	6811      	ldr	r1, [r2, #0]
 802e078:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 802e07c:	6011      	str	r1, [r2, #0]
    __HAL_DMA_ENABLE(hdma);
 802e07e:	681a      	ldr	r2, [r3, #0]
 802e080:	f042 0201 	orr.w	r2, r2, #1
 802e084:	601a      	str	r2, [r3, #0]
  HAL_StatusTypeDef status = HAL_OK;
 802e086:	2000      	movs	r0, #0
}
 802e088:	bd70      	pop	{r4, r5, r6, pc}
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 802e08a:	681a      	ldr	r2, [r3, #0]
 802e08c:	f022 0204 	bic.w	r2, r2, #4
 802e090:	601a      	str	r2, [r3, #0]
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_TE));
 802e092:	681a      	ldr	r2, [r3, #0]
 802e094:	f042 020a 	orr.w	r2, r2, #10
 802e098:	e7e2      	b.n	802e060 <HAL_DMA_Start_IT+0x40>
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
 802e09a:	2380      	movs	r3, #128	; 0x80
 802e09c:	63c3      	str	r3, [r0, #60]	; 0x3c
    __HAL_UNLOCK(hdma);
 802e09e:	f880 6024 	strb.w	r6, [r0, #36]	; 0x24
    status = HAL_ERROR;
 802e0a2:	4628      	mov	r0, r5
 802e0a4:	e7f0      	b.n	802e088 <HAL_DMA_Start_IT+0x68>
  __HAL_LOCK(hdma);
 802e0a6:	2002      	movs	r0, #2
 802e0a8:	e7ee      	b.n	802e088 <HAL_DMA_Start_IT+0x68>

0802e0aa <HAL_DMA_Abort>:
  if (NULL == hdma)
 802e0aa:	b140      	cbz	r0, 802e0be <HAL_DMA_Abort+0x14>
  if (hdma->State != HAL_DMA_STATE_BUSY)
 802e0ac:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
 802e0b0:	2b02      	cmp	r3, #2
 802e0b2:	d006      	beq.n	802e0c2 <HAL_DMA_Abort+0x18>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 802e0b4:	2304      	movs	r3, #4
 802e0b6:	63c3      	str	r3, [r0, #60]	; 0x3c
    __HAL_UNLOCK(hdma);
 802e0b8:	2300      	movs	r3, #0
 802e0ba:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
    return HAL_ERROR;
 802e0be:	2001      	movs	r0, #1
}
 802e0c0:	4770      	bx	lr
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 802e0c2:	6803      	ldr	r3, [r0, #0]
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 802e0c4:	6c81      	ldr	r1, [r0, #72]	; 0x48
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 802e0c6:	681a      	ldr	r2, [r3, #0]
 802e0c8:	f022 020e 	bic.w	r2, r2, #14
 802e0cc:	601a      	str	r2, [r3, #0]
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 802e0ce:	680a      	ldr	r2, [r1, #0]
 802e0d0:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 802e0d4:	600a      	str	r2, [r1, #0]
    __HAL_DMA_DISABLE(hdma);
 802e0d6:	681a      	ldr	r2, [r3, #0]
 802e0d8:	f022 0201 	bic.w	r2, r2, #1
 802e0dc:	601a      	str	r2, [r3, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 802e0de:	e9d0 1310 	ldrd	r1, r3, [r0, #64]	; 0x40
 802e0e2:	f003 021c 	and.w	r2, r3, #28
 802e0e6:	2301      	movs	r3, #1
 802e0e8:	4093      	lsls	r3, r2
 802e0ea:	604b      	str	r3, [r1, #4]
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 802e0ec:	e9d0 3213 	ldrd	r3, r2, [r0, #76]	; 0x4c
 802e0f0:	605a      	str	r2, [r3, #4]
    if (hdma->DMAmuxRequestGen != 0U)
 802e0f2:	6d43      	ldr	r3, [r0, #84]	; 0x54
 802e0f4:	b133      	cbz	r3, 802e104 <HAL_DMA_Abort+0x5a>
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 802e0f6:	681a      	ldr	r2, [r3, #0]
 802e0f8:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 802e0fc:	601a      	str	r2, [r3, #0]
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 802e0fe:	e9d0 3216 	ldrd	r3, r2, [r0, #88]	; 0x58
 802e102:	605a      	str	r2, [r3, #4]
    hdma->State = HAL_DMA_STATE_READY;
 802e104:	2301      	movs	r3, #1
 802e106:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
    __HAL_UNLOCK(hdma);
 802e10a:	2300      	movs	r3, #0
 802e10c:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
  return HAL_OK;
 802e110:	4618      	mov	r0, r3
 802e112:	4770      	bx	lr

0802e114 <HAL_DMA_Abort_IT>:
{
 802e114:	b510      	push	{r4, lr}
  if (hdma->State != HAL_DMA_STATE_BUSY)
 802e116:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
 802e11a:	2b02      	cmp	r3, #2
 802e11c:	d003      	beq.n	802e126 <HAL_DMA_Abort_IT+0x12>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 802e11e:	2304      	movs	r3, #4
 802e120:	63c3      	str	r3, [r0, #60]	; 0x3c
    status = HAL_ERROR;
 802e122:	2001      	movs	r0, #1
}
 802e124:	bd10      	pop	{r4, pc}
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 802e126:	6803      	ldr	r3, [r0, #0]
 802e128:	681a      	ldr	r2, [r3, #0]
 802e12a:	f022 020e 	bic.w	r2, r2, #14
 802e12e:	601a      	str	r2, [r3, #0]
    __HAL_DMA_DISABLE(hdma);
 802e130:	681a      	ldr	r2, [r3, #0]
 802e132:	f022 0201 	bic.w	r2, r2, #1
 802e136:	601a      	str	r2, [r3, #0]
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 802e138:	6c82      	ldr	r2, [r0, #72]	; 0x48
 802e13a:	6813      	ldr	r3, [r2, #0]
 802e13c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 802e140:	6013      	str	r3, [r2, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 802e142:	e9d0 1310 	ldrd	r1, r3, [r0, #64]	; 0x40
 802e146:	f003 021c 	and.w	r2, r3, #28
 802e14a:	2301      	movs	r3, #1
 802e14c:	4093      	lsls	r3, r2
 802e14e:	604b      	str	r3, [r1, #4]
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 802e150:	e9d0 3213 	ldrd	r3, r2, [r0, #76]	; 0x4c
 802e154:	605a      	str	r2, [r3, #4]
    if (hdma->DMAmuxRequestGen != 0U)
 802e156:	6d43      	ldr	r3, [r0, #84]	; 0x54
 802e158:	b133      	cbz	r3, 802e168 <HAL_DMA_Abort_IT+0x54>
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 802e15a:	681a      	ldr	r2, [r3, #0]
 802e15c:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 802e160:	601a      	str	r2, [r3, #0]
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 802e162:	e9d0 3216 	ldrd	r3, r2, [r0, #88]	; 0x58
 802e166:	605a      	str	r2, [r3, #4]
    hdma->State = HAL_DMA_STATE_READY;
 802e168:	2301      	movs	r3, #1
 802e16a:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
    if (hdma->XferAbortCallback != NULL)
 802e16e:	6b83      	ldr	r3, [r0, #56]	; 0x38
    __HAL_UNLOCK(hdma);
 802e170:	2400      	movs	r4, #0
 802e172:	f880 4024 	strb.w	r4, [r0, #36]	; 0x24
    if (hdma->XferAbortCallback != NULL)
 802e176:	b113      	cbz	r3, 802e17e <HAL_DMA_Abort_IT+0x6a>
      hdma->XferAbortCallback(hdma);
 802e178:	4798      	blx	r3
  HAL_StatusTypeDef status = HAL_OK;
 802e17a:	4620      	mov	r0, r4
 802e17c:	e7d2      	b.n	802e124 <HAL_DMA_Abort_IT+0x10>
 802e17e:	4618      	mov	r0, r3
 802e180:	e7d0      	b.n	802e124 <HAL_DMA_Abort_IT+0x10>
	...

0802e184 <HAL_DMA_IRQHandler>:
{
 802e184:	b470      	push	{r4, r5, r6}
  if (((flag_it & (DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1CU))) != 0U) && ((source_it & DMA_IT_HT) != 0U))
 802e186:	6c42      	ldr	r2, [r0, #68]	; 0x44
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 802e188:	6c04      	ldr	r4, [r0, #64]	; 0x40
  uint32_t source_it = hdma->Instance->CCR;
 802e18a:	6803      	ldr	r3, [r0, #0]
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 802e18c:	6826      	ldr	r6, [r4, #0]
  uint32_t source_it = hdma->Instance->CCR;
 802e18e:	681d      	ldr	r5, [r3, #0]
  if (((flag_it & (DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1CU))) != 0U) && ((source_it & DMA_IT_HT) != 0U))
 802e190:	f002 021c 	and.w	r2, r2, #28
 802e194:	2104      	movs	r1, #4
 802e196:	4091      	lsls	r1, r2
 802e198:	4231      	tst	r1, r6
 802e19a:	d00f      	beq.n	802e1bc <HAL_DMA_IRQHandler+0x38>
 802e19c:	f015 0f04 	tst.w	r5, #4
 802e1a0:	d00c      	beq.n	802e1bc <HAL_DMA_IRQHandler+0x38>
      if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 802e1a2:	681a      	ldr	r2, [r3, #0]
 802e1a4:	0692      	lsls	r2, r2, #26
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 802e1a6:	bf5e      	ittt	pl
 802e1a8:	681a      	ldrpl	r2, [r3, #0]
 802e1aa:	f022 0204 	bicpl.w	r2, r2, #4
 802e1ae:	601a      	strpl	r2, [r3, #0]
      if (hdma->XferHalfCpltCallback != NULL)
 802e1b0:	6b03      	ldr	r3, [r0, #48]	; 0x30
      hdma->DmaBaseAddress->IFCR = DMA_ISR_HTIF1 << (hdma->ChannelIndex & 0x1CU);
 802e1b2:	6061      	str	r1, [r4, #4]
    if (hdma->XferErrorCallback != NULL)
 802e1b4:	2b00      	cmp	r3, #0
 802e1b6:	d033      	beq.n	802e220 <HAL_DMA_IRQHandler+0x9c>
}
 802e1b8:	bc70      	pop	{r4, r5, r6}
      hdma->XferErrorCallback(hdma);
 802e1ba:	4718      	bx	r3
  else if ((0U != (flag_it & (DMA_FLAG_TC1 << (hdma->ChannelIndex & 0x1CU)))) && (0U != (source_it & DMA_IT_TC)))
 802e1bc:	2102      	movs	r1, #2
 802e1be:	4091      	lsls	r1, r2
 802e1c0:	4231      	tst	r1, r6
 802e1c2:	d017      	beq.n	802e1f4 <HAL_DMA_IRQHandler+0x70>
 802e1c4:	f015 0f02 	tst.w	r5, #2
 802e1c8:	d014      	beq.n	802e1f4 <HAL_DMA_IRQHandler+0x70>
      if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 802e1ca:	681a      	ldr	r2, [r3, #0]
 802e1cc:	0694      	lsls	r4, r2, #26
 802e1ce:	d406      	bmi.n	802e1de <HAL_DMA_IRQHandler+0x5a>
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
 802e1d0:	681a      	ldr	r2, [r3, #0]
 802e1d2:	f022 020a 	bic.w	r2, r2, #10
 802e1d6:	601a      	str	r2, [r3, #0]
        hdma->State = HAL_DMA_STATE_READY;
 802e1d8:	2201      	movs	r2, #1
 802e1da:	f880 2025 	strb.w	r2, [r0, #37]	; 0x25
      __HAL_DMA_CLEAR_FLAG(hdma, (DMA_FLAG_TC1 << (hdma->ChannelIndex & 0x1CU)));
 802e1de:	4a11      	ldr	r2, [pc, #68]	; (802e224 <HAL_DMA_IRQHandler+0xa0>)
 802e1e0:	4293      	cmp	r3, r2
 802e1e2:	bf8c      	ite	hi
 802e1e4:	4b10      	ldrhi	r3, [pc, #64]	; (802e228 <HAL_DMA_IRQHandler+0xa4>)
 802e1e6:	4b11      	ldrls	r3, [pc, #68]	; (802e22c <HAL_DMA_IRQHandler+0xa8>)
 802e1e8:	6059      	str	r1, [r3, #4]
      __HAL_UNLOCK(hdma);
 802e1ea:	2300      	movs	r3, #0
 802e1ec:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
      if (hdma->XferCpltCallback != NULL)
 802e1f0:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 802e1f2:	e7df      	b.n	802e1b4 <HAL_DMA_IRQHandler+0x30>
  else if (((flag_it & (DMA_FLAG_TE1 << (hdma->ChannelIndex & 0x1CU))) != 0U) && ((source_it & DMA_IT_TE) != 0U))
 802e1f4:	2108      	movs	r1, #8
 802e1f6:	4091      	lsls	r1, r2
 802e1f8:	4231      	tst	r1, r6
 802e1fa:	d011      	beq.n	802e220 <HAL_DMA_IRQHandler+0x9c>
 802e1fc:	0729      	lsls	r1, r5, #28
 802e1fe:	d50f      	bpl.n	802e220 <HAL_DMA_IRQHandler+0x9c>
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 802e200:	6819      	ldr	r1, [r3, #0]
 802e202:	f021 010e 	bic.w	r1, r1, #14
 802e206:	6019      	str	r1, [r3, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 802e208:	2301      	movs	r3, #1
 802e20a:	fa03 f202 	lsl.w	r2, r3, r2
 802e20e:	6062      	str	r2, [r4, #4]
    hdma->ErrorCode = HAL_DMA_ERROR_TE;
 802e210:	63c3      	str	r3, [r0, #60]	; 0x3c
    hdma->State = HAL_DMA_STATE_READY;
 802e212:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
    __HAL_UNLOCK(hdma);
 802e216:	2300      	movs	r3, #0
 802e218:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
    if (hdma->XferErrorCallback != NULL)
 802e21c:	6b43      	ldr	r3, [r0, #52]	; 0x34
 802e21e:	e7c9      	b.n	802e1b4 <HAL_DMA_IRQHandler+0x30>
}
 802e220:	bc70      	pop	{r4, r5, r6}
 802e222:	4770      	bx	lr
 802e224:	40020080 	.word	0x40020080
 802e228:	40020400 	.word	0x40020400
 802e22c:	40020000 	.word	0x40020000

0802e230 <HAL_DMA_ConfigChannelAttributes>:
  if (hdma == NULL)
 802e230:	b160      	cbz	r0, 802e24c <HAL_DMA_ConfigChannelAttributes+0x1c>
  ccr = READ_REG(hdma->Instance->CCR);
 802e232:	6802      	ldr	r2, [r0, #0]
  if ((ChannelAttributes & DMA_CHANNEL_ATTR_PRIV_MASK) != 0U)
 802e234:	06c8      	lsls	r0, r1, #27
  ccr = READ_REG(hdma->Instance->CCR);
 802e236:	6813      	ldr	r3, [r2, #0]
  if ((ChannelAttributes & DMA_CHANNEL_ATTR_PRIV_MASK) != 0U)
 802e238:	d505      	bpl.n	802e246 <HAL_DMA_ConfigChannelAttributes+0x16>
    if ((ChannelAttributes & DMA_CCR_PRIV) != 0U)
 802e23a:	02c9      	lsls	r1, r1, #11
      SET_BIT(ccr, DMA_CCR_PRIV);
 802e23c:	bf4c      	ite	mi
 802e23e:	f443 1380 	orrmi.w	r3, r3, #1048576	; 0x100000
      CLEAR_BIT(ccr, DMA_CCR_PRIV);
 802e242:	f423 1380 	bicpl.w	r3, r3, #1048576	; 0x100000
  WRITE_REG(hdma->Instance->CCR, ccr);
 802e246:	6013      	str	r3, [r2, #0]
  return status;
 802e248:	2000      	movs	r0, #0
 802e24a:	4770      	bx	lr
    return status;
 802e24c:	2001      	movs	r0, #1
}
 802e24e:	4770      	bx	lr

0802e250 <HAL_EXTI_RegisterCallback>:
  *         This parameter can be one of @arg @ref EXTI_CallbackIDTypeDef values.
  * @param  pPendingCbfn function pointer to be stored as callback.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_RegisterCallback(EXTI_HandleTypeDef *hexti, EXTI_CallbackIDTypeDef CallbackID, void (*pPendingCbfn)(void))
{
 802e250:	4603      	mov	r3, r0
  HAL_StatusTypeDef status = HAL_OK;

  switch (CallbackID)
 802e252:	4608      	mov	r0, r1
 802e254:	b909      	cbnz	r1, 802e25a <HAL_EXTI_RegisterCallback+0xa>
  {
    case  HAL_EXTI_COMMON_CB_ID:
      hexti->PendingCallback = pPendingCbfn;
 802e256:	605a      	str	r2, [r3, #4]
      break;
 802e258:	4770      	bx	lr

    default:
      status = HAL_ERROR;
 802e25a:	2001      	movs	r0, #1
      break;
  }

  return status;
}
 802e25c:	4770      	bx	lr

0802e25e <HAL_EXTI_GetHandle>:
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(ExtiLine));

  /* Check null pointer */
  if (hexti == NULL)
 802e25e:	b110      	cbz	r0, 802e266 <HAL_EXTI_GetHandle+0x8>
    return HAL_ERROR;
  }
  else
  {
    /* Store line number as handle private field */
    hexti->Line = ExtiLine;
 802e260:	6001      	str	r1, [r0, #0]

    return HAL_OK;
 802e262:	2000      	movs	r0, #0
 802e264:	4770      	bx	lr
    return HAL_ERROR;
 802e266:	2001      	movs	r0, #1
  }
}
 802e268:	4770      	bx	lr
	...

0802e26c <FLASH_Program_Fast>:

  /* Set FSTPG bit */
#ifdef CORE_CM0PLUS
  SET_BIT(FLASH->C2CR, FLASH_CR_FSTPG);
#else
  SET_BIT(FLASH->CR, FLASH_CR_FSTPG);
 802e26c:	4b0a      	ldr	r3, [pc, #40]	; (802e298 <FLASH_Program_Fast+0x2c>)
 802e26e:	695a      	ldr	r2, [r3, #20]
 802e270:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
{
 802e274:	b530      	push	{r4, r5, lr}
  SET_BIT(FLASH->CR, FLASH_CR_FSTPG);
 802e276:	615a      	str	r2, [r3, #20]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 802e278:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 802e27c:	b672      	cpsid	i
}
 802e27e:	2200      	movs	r2, #0
  __disable_irq();

  /* Program the double word of the row */
  do
  {
    *dest_addr = *src_addr;
 802e280:	588d      	ldr	r5, [r1, r2]
 802e282:	5085      	str	r5, [r0, r2]
    dest_addr++;
    src_addr++;
    row_index--;
  }
  while (row_index != 0U);
 802e284:	3204      	adds	r2, #4
 802e286:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 802e28a:	d1f9      	bne.n	802e280 <FLASH_Program_Fast+0x14>

  /* wait for BSY in order to be sure that flash operation is ended before
     allowing prefetch in flash. Timeout does not return status, as it will
     be anyway done later */
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != 0U)
 802e28c:	691a      	ldr	r2, [r3, #16]
 802e28e:	03d2      	lsls	r2, r2, #15
 802e290:	d4fc      	bmi.n	802e28c <FLASH_Program_Fast+0x20>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 802e292:	f384 8810 	msr	PRIMASK, r4
  {
  }

  /* Exit critical section: restore previous priority mask */
  __set_PRIMASK(primask_bit);
}
 802e296:	bd30      	pop	{r4, r5, pc}
 802e298:	58004000 	.word	0x58004000

0802e29c <HAL_FLASH_Unlock>:
  if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0U)
 802e29c:	4b06      	ldr	r3, [pc, #24]	; (802e2b8 <HAL_FLASH_Unlock+0x1c>)
 802e29e:	695a      	ldr	r2, [r3, #20]
 802e2a0:	2a00      	cmp	r2, #0
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 802e2a2:	bfbf      	itttt	lt
 802e2a4:	4a05      	ldrlt	r2, [pc, #20]	; (802e2bc <HAL_FLASH_Unlock+0x20>)
 802e2a6:	609a      	strlt	r2, [r3, #8]
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 802e2a8:	f102 3288 	addlt.w	r2, r2, #2290649224	; 0x88888888
 802e2ac:	609a      	strlt	r2, [r3, #8]
    if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0U)
 802e2ae:	bfba      	itte	lt
 802e2b0:	6958      	ldrlt	r0, [r3, #20]
  HAL_StatusTypeDef status = HAL_OK;
 802e2b2:	0fc0      	lsrlt	r0, r0, #31
 802e2b4:	2000      	movge	r0, #0
}
 802e2b6:	4770      	bx	lr
 802e2b8:	58004000 	.word	0x58004000
 802e2bc:	45670123 	.word	0x45670123

0802e2c0 <HAL_FLASH_Lock>:
  SET_BIT(FLASH->CR, FLASH_CR_LOCK);
 802e2c0:	4b04      	ldr	r3, [pc, #16]	; (802e2d4 <HAL_FLASH_Lock+0x14>)
 802e2c2:	695a      	ldr	r2, [r3, #20]
 802e2c4:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 802e2c8:	615a      	str	r2, [r3, #20]
  if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) == 0U)
 802e2ca:	6958      	ldr	r0, [r3, #20]
}
 802e2cc:	43c0      	mvns	r0, r0
 802e2ce:	0fc0      	lsrs	r0, r0, #31
 802e2d0:	4770      	bx	lr
 802e2d2:	bf00      	nop
 802e2d4:	58004000 	.word	0x58004000

0802e2d8 <FLASH_WaitForLastOperation>:
{
 802e2d8:	b570      	push	{r4, r5, r6, lr}
 802e2da:	4605      	mov	r5, r0
  uint32_t tickstart = HAL_GetTick();
 802e2dc:	f7fe f9b2 	bl	802c644 <HAL_GetTick>
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 802e2e0:	4e12      	ldr	r6, [pc, #72]	; (802e32c <FLASH_WaitForLastOperation+0x54>)
  uint32_t tickstart = HAL_GetTick();
 802e2e2:	4604      	mov	r4, r0
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 802e2e4:	6933      	ldr	r3, [r6, #16]
 802e2e6:	03d9      	lsls	r1, r3, #15
 802e2e8:	d413      	bmi.n	802e312 <FLASH_WaitForLastOperation+0x3a>
  error = FLASH->SR;
 802e2ea:	6933      	ldr	r3, [r6, #16]
  if ((error & FLASH_FLAG_EOP) != 0U)
 802e2ec:	07da      	lsls	r2, r3, #31
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 802e2ee:	bf44      	itt	mi
 802e2f0:	2201      	movmi	r2, #1
 802e2f2:	6132      	strmi	r2, [r6, #16]
  error &= FLASH_FLAG_SR_ERRORS;
 802e2f4:	f24c 32fa 	movw	r2, #50170	; 0xc3fa
  __HAL_FLASH_CLEAR_FLAG(error);
 802e2f8:	4013      	ands	r3, r2
 802e2fa:	d111      	bne.n	802e320 <FLASH_WaitForLastOperation+0x48>
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_CFGBSY))
 802e2fc:	4e0b      	ldr	r6, [pc, #44]	; (802e32c <FLASH_WaitForLastOperation+0x54>)
 802e2fe:	6930      	ldr	r0, [r6, #16]
 802e300:	f410 2080 	ands.w	r0, r0, #262144	; 0x40000
 802e304:	d00b      	beq.n	802e31e <FLASH_WaitForLastOperation+0x46>
    if ((HAL_GetTick() - tickstart) >= Timeout)
 802e306:	f7fe f99d 	bl	802c644 <HAL_GetTick>
 802e30a:	1b00      	subs	r0, r0, r4
 802e30c:	42a8      	cmp	r0, r5
 802e30e:	d3f6      	bcc.n	802e2fe <FLASH_WaitForLastOperation+0x26>
 802e310:	e004      	b.n	802e31c <FLASH_WaitForLastOperation+0x44>
    if ((HAL_GetTick() - tickstart) >= Timeout)
 802e312:	f7fe f997 	bl	802c644 <HAL_GetTick>
 802e316:	1b00      	subs	r0, r0, r4
 802e318:	42a8      	cmp	r0, r5
 802e31a:	d3e3      	bcc.n	802e2e4 <FLASH_WaitForLastOperation+0xc>
      return HAL_TIMEOUT;
 802e31c:	2003      	movs	r0, #3
}
 802e31e:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_FLASH_CLEAR_FLAG(error);
 802e320:	4a02      	ldr	r2, [pc, #8]	; (802e32c <FLASH_WaitForLastOperation+0x54>)
 802e322:	6113      	str	r3, [r2, #16]
    pFlash.ErrorCode = error;
 802e324:	4a02      	ldr	r2, [pc, #8]	; (802e330 <FLASH_WaitForLastOperation+0x58>)
    return HAL_ERROR;
 802e326:	2001      	movs	r0, #1
    pFlash.ErrorCode = error;
 802e328:	6053      	str	r3, [r2, #4]
    return HAL_ERROR;
 802e32a:	e7f8      	b.n	802e31e <FLASH_WaitForLastOperation+0x46>
 802e32c:	58004000 	.word	0x58004000
 802e330:	20003f3c 	.word	0x20003f3c

0802e334 <HAL_FLASH_Program>:
{
 802e334:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __HAL_LOCK(&pFlash);
 802e338:	4c18      	ldr	r4, [pc, #96]	; (802e39c <HAL_FLASH_Program+0x68>)
{
 802e33a:	4698      	mov	r8, r3
  __HAL_LOCK(&pFlash);
 802e33c:	7823      	ldrb	r3, [r4, #0]
 802e33e:	2b01      	cmp	r3, #1
{
 802e340:	4606      	mov	r6, r0
 802e342:	460d      	mov	r5, r1
 802e344:	4617      	mov	r7, r2
  __HAL_LOCK(&pFlash);
 802e346:	d026      	beq.n	802e396 <HAL_FLASH_Program+0x62>
 802e348:	2301      	movs	r3, #1
 802e34a:	7023      	strb	r3, [r4, #0]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e34c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 802e350:	2300      	movs	r3, #0
 802e352:	6063      	str	r3, [r4, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e354:	f7ff ffc0 	bl	802e2d8 <FLASH_WaitForLastOperation>
  if (status == HAL_OK)
 802e358:	b9a0      	cbnz	r0, 802e384 <HAL_FLASH_Program+0x50>
    if (TypeProgram == FLASH_TYPEPROGRAM_DOUBLEWORD)
 802e35a:	2e01      	cmp	r6, #1
 802e35c:	d116      	bne.n	802e38c <HAL_FLASH_Program+0x58>
  SET_BIT(FLASH->CR, FLASH_CR_PG);
 802e35e:	4a10      	ldr	r2, [pc, #64]	; (802e3a0 <HAL_FLASH_Program+0x6c>)
 802e360:	6953      	ldr	r3, [r2, #20]
 802e362:	f043 0301 	orr.w	r3, r3, #1
 802e366:	6153      	str	r3, [r2, #20]
  *(uint32_t *)Address = (uint32_t)Data;
 802e368:	602f      	str	r7, [r5, #0]
  __ASM volatile ("isb 0xF":::"memory");
 802e36a:	f3bf 8f6f 	isb	sy
  *(uint32_t *)(Address + 4U) = (uint32_t)(Data >> 32U);
 802e36e:	f8c5 8004 	str.w	r8, [r5, #4]
    status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e372:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 802e376:	f7ff ffaf 	bl	802e2d8 <FLASH_WaitForLastOperation>
    CLEAR_BIT(FLASH->CR, TypeProgram);
 802e37a:	4a09      	ldr	r2, [pc, #36]	; (802e3a0 <HAL_FLASH_Program+0x6c>)
 802e37c:	6953      	ldr	r3, [r2, #20]
 802e37e:	ea23 0606 	bic.w	r6, r3, r6
 802e382:	6156      	str	r6, [r2, #20]
  __HAL_UNLOCK(&pFlash);
 802e384:	2300      	movs	r3, #0
 802e386:	7023      	strb	r3, [r4, #0]
}
 802e388:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      FLASH_Program_Fast(Address, (uint32_t)Data);
 802e38c:	4639      	mov	r1, r7
 802e38e:	4628      	mov	r0, r5
 802e390:	f7ff ff6c 	bl	802e26c <FLASH_Program_Fast>
 802e394:	e7ed      	b.n	802e372 <HAL_FLASH_Program+0x3e>
  __HAL_LOCK(&pFlash);
 802e396:	2002      	movs	r0, #2
 802e398:	e7f6      	b.n	802e388 <HAL_FLASH_Program+0x54>
 802e39a:	bf00      	nop
 802e39c:	20003f3c 	.word	0x20003f3c
 802e3a0:	58004000 	.word	0x58004000

0802e3a4 <FLASH_PageErase>:

  /* Proceed to erase the page */
#ifdef CORE_CM0PLUS
  MODIFY_REG(FLASH->C2CR, FLASH_CR_PNB, ((Page << FLASH_CR_PNB_Pos) | FLASH_CR_PER | FLASH_CR_STRT));
#else
  MODIFY_REG(FLASH->CR, FLASH_CR_PNB, ((Page << FLASH_CR_PNB_Pos) | FLASH_CR_PER | FLASH_CR_STRT));
 802e3a4:	4a05      	ldr	r2, [pc, #20]	; (802e3bc <FLASH_PageErase+0x18>)
 802e3a6:	6953      	ldr	r3, [r2, #20]
 802e3a8:	f423 737e 	bic.w	r3, r3, #1016	; 0x3f8
 802e3ac:	ea43 00c0 	orr.w	r0, r3, r0, lsl #3
 802e3b0:	f440 3080 	orr.w	r0, r0, #65536	; 0x10000
 802e3b4:	f040 0002 	orr.w	r0, r0, #2
 802e3b8:	6150      	str	r0, [r2, #20]
#endif
}
 802e3ba:	4770      	bx	lr
 802e3bc:	58004000 	.word	0x58004000

0802e3c0 <HAL_FLASHEx_Erase>:
{
 802e3c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __HAL_LOCK(&pFlash);
 802e3c4:	4d23      	ldr	r5, [pc, #140]	; (802e454 <HAL_FLASHEx_Erase+0x94>)
 802e3c6:	782b      	ldrb	r3, [r5, #0]
 802e3c8:	2b01      	cmp	r3, #1
{
 802e3ca:	4606      	mov	r6, r0
 802e3cc:	4688      	mov	r8, r1
  __HAL_LOCK(&pFlash);
 802e3ce:	d03f      	beq.n	802e450 <HAL_FLASHEx_Erase+0x90>
 802e3d0:	2301      	movs	r3, #1
 802e3d2:	702b      	strb	r3, [r5, #0]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e3d4:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 802e3d8:	2300      	movs	r3, #0
 802e3da:	606b      	str	r3, [r5, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e3dc:	f7ff ff7c 	bl	802e2d8 <FLASH_WaitForLastOperation>
  if (status == HAL_OK)
 802e3e0:	4604      	mov	r4, r0
 802e3e2:	b988      	cbnz	r0, 802e408 <HAL_FLASHEx_Erase+0x48>
    if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 802e3e4:	6833      	ldr	r3, [r6, #0]
 802e3e6:	2b04      	cmp	r3, #4
 802e3e8:	d113      	bne.n	802e412 <HAL_FLASHEx_Erase+0x52>
  SET_BIT(FLASH->CR, (FLASH_CR_MER | FLASH_CR_STRT));
 802e3ea:	4a1b      	ldr	r2, [pc, #108]	; (802e458 <HAL_FLASHEx_Erase+0x98>)
 802e3ec:	6953      	ldr	r3, [r2, #20]
 802e3ee:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 802e3f2:	f043 0304 	orr.w	r3, r3, #4
 802e3f6:	6153      	str	r3, [r2, #20]
      status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e3f8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 802e3fc:	f7ff ff6c 	bl	802e2d8 <FLASH_WaitForLastOperation>
 802e400:	4604      	mov	r4, r0
  * @retval None
  */
void FLASH_FlushCaches(void)
{
  /* Flush instruction cache  */
  if (READ_BIT(FLASH->ACR, FLASH_ACR_ICEN) == 1U)
 802e402:	4b15      	ldr	r3, [pc, #84]	; (802e458 <HAL_FLASHEx_Erase+0x98>)
 802e404:	681a      	ldr	r2, [r3, #0]
  }

#ifdef CORE_CM0PLUS
#else
  /* Flush data cache */
  if (READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) == 1U)
 802e406:	681b      	ldr	r3, [r3, #0]
  __HAL_UNLOCK(&pFlash);
 802e408:	2300      	movs	r3, #0
 802e40a:	702b      	strb	r3, [r5, #0]
}
 802e40c:	4620      	mov	r0, r4
 802e40e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      *PageError = 0xFFFFFFFFU;
 802e412:	f04f 33ff 	mov.w	r3, #4294967295
 802e416:	f8c8 3000 	str.w	r3, [r8]
      for (index = pEraseInit->Page; index < (pEraseInit->Page + pEraseInit->NbPages); index++)
 802e41a:	6877      	ldr	r7, [r6, #4]
 802e41c:	e9d6 3201 	ldrd	r3, r2, [r6, #4]
 802e420:	4413      	add	r3, r2
 802e422:	42bb      	cmp	r3, r7
 802e424:	d90a      	bls.n	802e43c <HAL_FLASHEx_Erase+0x7c>
        FLASH_PageErase(index);
 802e426:	4638      	mov	r0, r7
 802e428:	f7ff ffbc 	bl	802e3a4 <FLASH_PageErase>
        status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e42c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 802e430:	f7ff ff52 	bl	802e2d8 <FLASH_WaitForLastOperation>
        if (status != HAL_OK)
 802e434:	b150      	cbz	r0, 802e44c <HAL_FLASHEx_Erase+0x8c>
          *PageError = index;
 802e436:	f8c8 7000 	str.w	r7, [r8]
        status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e43a:	4604      	mov	r4, r0
static void FLASH_AcknowledgePageErase(void)
{
#ifdef CORE_CM0PLUS
  CLEAR_BIT(FLASH->C2CR, (FLASH_CR_PER | FLASH_CR_PNB));
#else
  CLEAR_BIT(FLASH->CR, (FLASH_CR_PER | FLASH_CR_PNB));
 802e43c:	4a06      	ldr	r2, [pc, #24]	; (802e458 <HAL_FLASHEx_Erase+0x98>)
 802e43e:	6953      	ldr	r3, [r2, #20]
 802e440:	f423 737e 	bic.w	r3, r3, #1016	; 0x3f8
 802e444:	f023 0302 	bic.w	r3, r3, #2
 802e448:	6153      	str	r3, [r2, #20]
#endif
}
 802e44a:	e7da      	b.n	802e402 <HAL_FLASHEx_Erase+0x42>
      for (index = pEraseInit->Page; index < (pEraseInit->Page + pEraseInit->NbPages); index++)
 802e44c:	3701      	adds	r7, #1
 802e44e:	e7e5      	b.n	802e41c <HAL_FLASHEx_Erase+0x5c>
  __HAL_LOCK(&pFlash);
 802e450:	2402      	movs	r4, #2
 802e452:	e7db      	b.n	802e40c <HAL_FLASHEx_Erase+0x4c>
 802e454:	20003f3c 	.word	0x20003f3c
 802e458:	58004000 	.word	0x58004000

0802e45c <HAL_FLASHEx_Erase_IT>:
{
 802e45c:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(&pFlash);
 802e45e:	4c16      	ldr	r4, [pc, #88]	; (802e4b8 <HAL_FLASHEx_Erase_IT+0x5c>)
 802e460:	7823      	ldrb	r3, [r4, #0]
 802e462:	2b01      	cmp	r3, #1
{
 802e464:	4605      	mov	r5, r0
  __HAL_LOCK(&pFlash);
 802e466:	d025      	beq.n	802e4b4 <HAL_FLASHEx_Erase_IT+0x58>
 802e468:	2301      	movs	r3, #1
 802e46a:	7023      	strb	r3, [r4, #0]
  pFlash.ProcedureOnGoing = pEraseInit->TypeErase;
 802e46c:	6803      	ldr	r3, [r0, #0]
 802e46e:	60a3      	str	r3, [r4, #8]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 802e470:	2600      	movs	r6, #0
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e472:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 802e476:	6066      	str	r6, [r4, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e478:	f7ff ff2e 	bl	802e2d8 <FLASH_WaitForLastOperation>
  if (status != HAL_OK)
 802e47c:	4601      	mov	r1, r0
 802e47e:	b110      	cbz	r0, 802e486 <HAL_FLASHEx_Erase_IT+0x2a>
    __HAL_UNLOCK(&pFlash);
 802e480:	7026      	strb	r6, [r4, #0]
}
 802e482:	4608      	mov	r0, r1
 802e484:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP | FLASH_IT_OPERR);
 802e486:	4a0d      	ldr	r2, [pc, #52]	; (802e4bc <HAL_FLASHEx_Erase_IT+0x60>)
 802e488:	6953      	ldr	r3, [r2, #20]
 802e48a:	f043 7340 	orr.w	r3, r3, #50331648	; 0x3000000
 802e48e:	6153      	str	r3, [r2, #20]
    if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 802e490:	682b      	ldr	r3, [r5, #0]
 802e492:	2b04      	cmp	r3, #4
 802e494:	d107      	bne.n	802e4a6 <HAL_FLASHEx_Erase_IT+0x4a>
      pFlash.Page = 0;
 802e496:	6120      	str	r0, [r4, #16]
  SET_BIT(FLASH->CR, (FLASH_CR_MER | FLASH_CR_STRT));
 802e498:	6953      	ldr	r3, [r2, #20]
 802e49a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 802e49e:	f043 0304 	orr.w	r3, r3, #4
 802e4a2:	6153      	str	r3, [r2, #20]
}
 802e4a4:	e7ed      	b.n	802e482 <HAL_FLASHEx_Erase_IT+0x26>
      pFlash.NbPagesToErase = pEraseInit->NbPages;
 802e4a6:	68ab      	ldr	r3, [r5, #8]
      pFlash.Page = pEraseInit->Page;
 802e4a8:	6868      	ldr	r0, [r5, #4]
      pFlash.NbPagesToErase = pEraseInit->NbPages;
 802e4aa:	6163      	str	r3, [r4, #20]
      pFlash.Page = pEraseInit->Page;
 802e4ac:	6120      	str	r0, [r4, #16]
      FLASH_PageErase(pEraseInit->Page);
 802e4ae:	f7ff ff79 	bl	802e3a4 <FLASH_PageErase>
 802e4b2:	e7e6      	b.n	802e482 <HAL_FLASHEx_Erase_IT+0x26>
  __HAL_LOCK(&pFlash);
 802e4b4:	2102      	movs	r1, #2
 802e4b6:	e7e4      	b.n	802e482 <HAL_FLASHEx_Erase_IT+0x26>
 802e4b8:	20003f3c 	.word	0x20003f3c
 802e4bc:	58004000 	.word	0x58004000

0802e4c0 <HAL_GPIO_Init>:
  * @param GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 802e4c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

        /* Clear EXTI line configuration */
#ifdef CORE_CM0PLUS
        temp = EXTI->C2IMR1;
#else
        temp = EXTI->IMR1;
 802e4c4:	4c52      	ldr	r4, [pc, #328]	; (802e610 <HAL_GPIO_Init+0x150>)
  uint32_t position = 0x00u;
 802e4c6:	2300      	movs	r3, #0
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 802e4c8:	f04f 090f 	mov.w	r9, #15
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 802e4cc:	680a      	ldr	r2, [r1, #0]
 802e4ce:	fa32 f503 	lsrs.w	r5, r2, r3
 802e4d2:	d101      	bne.n	802e4d8 <HAL_GPIO_Init+0x18>
      }
    }

    position++;
  }
}
 802e4d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 802e4d8:	2501      	movs	r5, #1
 802e4da:	fa05 f803 	lsl.w	r8, r5, r3
    if (iocurrent != 0x00u)
 802e4de:	ea18 0202 	ands.w	r2, r8, r2
 802e4e2:	f000 808f 	beq.w	802e604 <HAL_GPIO_Init+0x144>
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 802e4e6:	684e      	ldr	r6, [r1, #4]
 802e4e8:	2703      	movs	r7, #3
 802e4ea:	f006 0503 	and.w	r5, r6, #3
 802e4ee:	ea4f 0e43 	mov.w	lr, r3, lsl #1
 802e4f2:	fa07 fc0e 	lsl.w	ip, r7, lr
 802e4f6:	1e6f      	subs	r7, r5, #1
 802e4f8:	2f01      	cmp	r7, #1
 802e4fa:	ea6f 0c0c 	mvn.w	ip, ip
 802e4fe:	d832      	bhi.n	802e566 <HAL_GPIO_Init+0xa6>
        temp = GPIOx->OSPEEDR;
 802e500:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 802e502:	ea07 0a0c 	and.w	sl, r7, ip
        temp |= (GPIO_Init->Speed << (position * 2U));
 802e506:	68cf      	ldr	r7, [r1, #12]
 802e508:	fa07 f70e 	lsl.w	r7, r7, lr
 802e50c:	ea47 070a 	orr.w	r7, r7, sl
        GPIOx->OSPEEDR = temp;
 802e510:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 802e512:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 802e514:	ea27 0808 	bic.w	r8, r7, r8
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 802e518:	f3c6 1700 	ubfx	r7, r6, #4, #1
 802e51c:	409f      	lsls	r7, r3
 802e51e:	ea47 0708 	orr.w	r7, r7, r8
        GPIOx->OTYPER = temp;
 802e522:	6047      	str	r7, [r0, #4]
        temp = GPIOx->PUPDR;
 802e524:	68c7      	ldr	r7, [r0, #12]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 802e526:	ea07 080c 	and.w	r8, r7, ip
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 802e52a:	688f      	ldr	r7, [r1, #8]
 802e52c:	fa07 f70e 	lsl.w	r7, r7, lr
 802e530:	ea47 0708 	orr.w	r7, r7, r8
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 802e534:	2d02      	cmp	r5, #2
        GPIOx->PUPDR = temp;
 802e536:	60c7      	str	r7, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 802e538:	d117      	bne.n	802e56a <HAL_GPIO_Init+0xaa>
        temp = GPIOx->AFR[position >> 3U];
 802e53a:	ea4f 08d3 	mov.w	r8, r3, lsr #3
 802e53e:	eb00 0888 	add.w	r8, r0, r8, lsl #2
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 802e542:	f003 0a07 	and.w	sl, r3, #7
        temp = GPIOx->AFR[position >> 3U];
 802e546:	f8d8 7020 	ldr.w	r7, [r8, #32]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 802e54a:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 802e54e:	fa09 fb0a 	lsl.w	fp, r9, sl
 802e552:	ea27 0b0b 	bic.w	fp, r7, fp
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 802e556:	690f      	ldr	r7, [r1, #16]
 802e558:	fa07 f70a 	lsl.w	r7, r7, sl
 802e55c:	ea47 070b 	orr.w	r7, r7, fp
        GPIOx->AFR[position >> 3u] = temp;
 802e560:	f8c8 7020 	str.w	r7, [r8, #32]
 802e564:	e001      	b.n	802e56a <HAL_GPIO_Init+0xaa>
      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 802e566:	2d03      	cmp	r5, #3
 802e568:	d1dc      	bne.n	802e524 <HAL_GPIO_Init+0x64>
      temp = GPIOx->MODER;
 802e56a:	6807      	ldr	r7, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 802e56c:	ea07 0c0c 	and.w	ip, r7, ip
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 802e570:	fa05 f70e 	lsl.w	r7, r5, lr
 802e574:	ea47 070c 	orr.w	r7, r7, ip
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 802e578:	f416 3f40 	tst.w	r6, #196608	; 0x30000
      GPIOx->MODER = temp;
 802e57c:	6007      	str	r7, [r0, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 802e57e:	d041      	beq.n	802e604 <HAL_GPIO_Init+0x144>
        temp = SYSCFG->EXTICR[position >> 2u];
 802e580:	f023 0703 	bic.w	r7, r3, #3
 802e584:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
 802e588:	f507 3780 	add.w	r7, r7, #65536	; 0x10000
        temp &= ~(0x07uL << (4U * (position & 0x03U)));
 802e58c:	f003 0c03 	and.w	ip, r3, #3
        temp = SYSCFG->EXTICR[position >> 2u];
 802e590:	68bd      	ldr	r5, [r7, #8]
        temp &= ~(0x07uL << (4U * (position & 0x03U)));
 802e592:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 802e596:	f04f 0e07 	mov.w	lr, #7
 802e59a:	fa0e fe0c 	lsl.w	lr, lr, ip
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 802e59e:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
        temp &= ~(0x07uL << (4U * (position & 0x03U)));
 802e5a2:	ea25 0e0e 	bic.w	lr, r5, lr
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 802e5a6:	d02f      	beq.n	802e608 <HAL_GPIO_Init+0x148>
 802e5a8:	4d1a      	ldr	r5, [pc, #104]	; (802e614 <HAL_GPIO_Init+0x154>)
 802e5aa:	42a8      	cmp	r0, r5
 802e5ac:	d02e      	beq.n	802e60c <HAL_GPIO_Init+0x14c>
 802e5ae:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 802e5b2:	42a8      	cmp	r0, r5
 802e5b4:	bf0c      	ite	eq
 802e5b6:	2502      	moveq	r5, #2
 802e5b8:	2507      	movne	r5, #7
 802e5ba:	fa05 f50c 	lsl.w	r5, r5, ip
 802e5be:	ea45 050e 	orr.w	r5, r5, lr
        SYSCFG->EXTICR[position >> 2u] = temp;
 802e5c2:	60bd      	str	r5, [r7, #8]
        temp = EXTI->IMR1;
 802e5c4:	f8d4 5080 	ldr.w	r5, [r4, #128]	; 0x80
        temp &= ~(iocurrent);
 802e5c8:	43d7      	mvns	r7, r2
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00u)
 802e5ca:	f416 3f80 	tst.w	r6, #65536	; 0x10000
        temp &= ~(iocurrent);
 802e5ce:	bf0c      	ite	eq
 802e5d0:	403d      	andeq	r5, r7
          temp |= iocurrent;
 802e5d2:	4315      	orrne	r5, r2
        EXTI->IMR1 = temp;
 802e5d4:	f8c4 5080 	str.w	r5, [r4, #128]	; 0x80
        temp = EXTI->EMR1;
 802e5d8:	f8d4 5084 	ldr.w	r5, [r4, #132]	; 0x84
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
 802e5dc:	f416 3f00 	tst.w	r6, #131072	; 0x20000
        temp &= ~(iocurrent);
 802e5e0:	bf0c      	ite	eq
 802e5e2:	403d      	andeq	r5, r7
          temp |= iocurrent;
 802e5e4:	4315      	orrne	r5, r2
        EXTI->EMR1 = temp;
 802e5e6:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
        temp = EXTI->RTSR1;
 802e5ea:	6825      	ldr	r5, [r4, #0]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
 802e5ec:	f416 1f80 	tst.w	r6, #1048576	; 0x100000
        temp &= ~(iocurrent);
 802e5f0:	bf0c      	ite	eq
 802e5f2:	403d      	andeq	r5, r7
          temp |= iocurrent;
 802e5f4:	4315      	orrne	r5, r2
        EXTI->RTSR1 = temp;
 802e5f6:	6025      	str	r5, [r4, #0]
        temp = EXTI->FTSR1;
 802e5f8:	6865      	ldr	r5, [r4, #4]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
 802e5fa:	02b6      	lsls	r6, r6, #10
        temp &= ~(iocurrent);
 802e5fc:	bf54      	ite	pl
 802e5fe:	403d      	andpl	r5, r7
          temp |= iocurrent;
 802e600:	4315      	orrmi	r5, r2
        EXTI->FTSR1 = temp;
 802e602:	6065      	str	r5, [r4, #4]
    position++;
 802e604:	3301      	adds	r3, #1
 802e606:	e761      	b.n	802e4cc <HAL_GPIO_Init+0xc>
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 802e608:	2500      	movs	r5, #0
 802e60a:	e7d6      	b.n	802e5ba <HAL_GPIO_Init+0xfa>
 802e60c:	2501      	movs	r5, #1
 802e60e:	e7d4      	b.n	802e5ba <HAL_GPIO_Init+0xfa>
 802e610:	58000800 	.word	0x58000800
 802e614:	48000400 	.word	0x48000400

0802e618 <HAL_GPIO_DeInit>:
        /* Clear EXTI line configuration */
#ifdef CORE_CM0PLUS
        EXTI->C2IMR1 &= ~(iocurrent);
        EXTI->C2EMR1 &= ~(iocurrent);
#else
        EXTI->IMR1 &= ~(iocurrent);
 802e618:	4a37      	ldr	r2, [pc, #220]	; (802e6f8 <HAL_GPIO_DeInit+0xe0>)
{
 802e61a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t position = 0x00u;
 802e61e:	2300      	movs	r3, #0
    iocurrent = (GPIO_Pin) & (1uL << position);
 802e620:	f04f 0a01 	mov.w	sl, #1
      tmp &= (0x07uL << (4U * (position & 0x03U)));
 802e624:	f04f 0b07 	mov.w	fp, #7
      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
 802e628:	f04f 090f 	mov.w	r9, #15
  while ((GPIO_Pin >> position) != 0x00u)
 802e62c:	fa31 f403 	lsrs.w	r4, r1, r3
 802e630:	d101      	bne.n	802e636 <HAL_GPIO_DeInit+0x1e>
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
    }

    position++;
  }
}
 802e632:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Pin) & (1uL << position);
 802e636:	fa0a fc03 	lsl.w	ip, sl, r3
    if (iocurrent != 0x00u)
 802e63a:	ea1c 0601 	ands.w	r6, ip, r1
 802e63e:	d054      	beq.n	802e6ea <HAL_GPIO_DeInit+0xd2>
      tmp = SYSCFG->EXTICR[position >> 2u];
 802e640:	f023 0403 	bic.w	r4, r3, #3
 802e644:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 802e648:	f504 3480 	add.w	r4, r4, #65536	; 0x10000
      tmp &= (0x07uL << (4U * (position & 0x03U)));
 802e64c:	f003 0703 	and.w	r7, r3, #3
      tmp = SYSCFG->EXTICR[position >> 2u];
 802e650:	68a5      	ldr	r5, [r4, #8]
      tmp &= (0x07uL << (4U * (position & 0x03U)));
 802e652:	00bf      	lsls	r7, r7, #2
 802e654:	fa0b f807 	lsl.w	r8, fp, r7
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 802e658:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
      tmp &= (0x07uL << (4U * (position & 0x03U)));
 802e65c:	ea08 0e05 	and.w	lr, r8, r5
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 802e660:	d045      	beq.n	802e6ee <HAL_GPIO_DeInit+0xd6>
 802e662:	4d26      	ldr	r5, [pc, #152]	; (802e6fc <HAL_GPIO_DeInit+0xe4>)
 802e664:	42a8      	cmp	r0, r5
 802e666:	d044      	beq.n	802e6f2 <HAL_GPIO_DeInit+0xda>
 802e668:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 802e66c:	42a8      	cmp	r0, r5
 802e66e:	bf0c      	ite	eq
 802e670:	2502      	moveq	r5, #2
 802e672:	2507      	movne	r5, #7
 802e674:	40bd      	lsls	r5, r7
 802e676:	4575      	cmp	r5, lr
 802e678:	d117      	bne.n	802e6aa <HAL_GPIO_DeInit+0x92>
        EXTI->IMR1 &= ~(iocurrent);
 802e67a:	f8d2 5080 	ldr.w	r5, [r2, #128]	; 0x80
 802e67e:	ea25 0506 	bic.w	r5, r5, r6
 802e682:	f8c2 5080 	str.w	r5, [r2, #128]	; 0x80
        EXTI->EMR1 &= ~(iocurrent);
 802e686:	f8d2 5084 	ldr.w	r5, [r2, #132]	; 0x84
 802e68a:	ea25 0506 	bic.w	r5, r5, r6
 802e68e:	f8c2 5084 	str.w	r5, [r2, #132]	; 0x84
        EXTI->RTSR1 &= ~(iocurrent);
 802e692:	6815      	ldr	r5, [r2, #0]
 802e694:	ea25 0506 	bic.w	r5, r5, r6
 802e698:	6015      	str	r5, [r2, #0]
        EXTI->FTSR1 &= ~(iocurrent);
 802e69a:	6855      	ldr	r5, [r2, #4]
 802e69c:	ea25 0606 	bic.w	r6, r5, r6
 802e6a0:	6056      	str	r6, [r2, #4]
        SYSCFG->EXTICR[position >> 2u] &= ~tmp;
 802e6a2:	68a5      	ldr	r5, [r4, #8]
 802e6a4:	ea25 0508 	bic.w	r5, r5, r8
 802e6a8:	60a5      	str	r5, [r4, #8]
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
 802e6aa:	6805      	ldr	r5, [r0, #0]
 802e6ac:	2603      	movs	r6, #3
 802e6ae:	005c      	lsls	r4, r3, #1
 802e6b0:	fa06 f404 	lsl.w	r4, r6, r4
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
 802e6b4:	fa23 f606 	lsr.w	r6, r3, r6
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
 802e6b8:	4325      	orrs	r5, r4
 802e6ba:	eb00 0686 	add.w	r6, r0, r6, lsl #2
 802e6be:	6005      	str	r5, [r0, #0]
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
 802e6c0:	f003 0507 	and.w	r5, r3, #7
 802e6c4:	6a37      	ldr	r7, [r6, #32]
 802e6c6:	00ad      	lsls	r5, r5, #2
 802e6c8:	fa09 f505 	lsl.w	r5, r9, r5
 802e6cc:	ea27 0505 	bic.w	r5, r7, r5
 802e6d0:	6235      	str	r5, [r6, #32]
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 802e6d2:	6885      	ldr	r5, [r0, #8]
 802e6d4:	ea25 0504 	bic.w	r5, r5, r4
 802e6d8:	6085      	str	r5, [r0, #8]
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
 802e6da:	6845      	ldr	r5, [r0, #4]
 802e6dc:	ea25 050c 	bic.w	r5, r5, ip
 802e6e0:	6045      	str	r5, [r0, #4]
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 802e6e2:	68c5      	ldr	r5, [r0, #12]
 802e6e4:	ea25 0404 	bic.w	r4, r5, r4
 802e6e8:	60c4      	str	r4, [r0, #12]
    position++;
 802e6ea:	3301      	adds	r3, #1
 802e6ec:	e79e      	b.n	802e62c <HAL_GPIO_DeInit+0x14>
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 802e6ee:	2500      	movs	r5, #0
 802e6f0:	e7c0      	b.n	802e674 <HAL_GPIO_DeInit+0x5c>
 802e6f2:	2501      	movs	r5, #1
 802e6f4:	e7be      	b.n	802e674 <HAL_GPIO_DeInit+0x5c>
 802e6f6:	bf00      	nop
 802e6f8:	58000800 	.word	0x58000800
 802e6fc:	48000400 	.word	0x48000400

0802e700 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 802e700:	b10a      	cbz	r2, 802e706 <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 802e702:	6181      	str	r1, [r0, #24]
 802e704:	4770      	bx	lr
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 802e706:	6281      	str	r1, [r0, #40]	; 0x28
  }
}
 802e708:	4770      	bx	lr

0802e70a <HAL_GPIO_TogglePin>:

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
 802e70a:	6943      	ldr	r3, [r0, #20]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
 802e70c:	ea01 0203 	and.w	r2, r1, r3
 802e710:	ea21 0103 	bic.w	r1, r1, r3
 802e714:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 802e718:	6181      	str	r1, [r0, #24]
}
 802e71a:	4770      	bx	lr

0802e71c <HAL_GPIO_EXTI_IRQHandler>:
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
  /* EXTI line interrupt detected */
  if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)
 802e71c:	4a04      	ldr	r2, [pc, #16]	; (802e730 <HAL_GPIO_EXTI_IRQHandler+0x14>)
 802e71e:	68d1      	ldr	r1, [r2, #12]
 802e720:	4201      	tst	r1, r0
{
 802e722:	b508      	push	{r3, lr}
  if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)
 802e724:	d002      	beq.n	802e72c <HAL_GPIO_EXTI_IRQHandler+0x10>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 802e726:	60d0      	str	r0, [r2, #12]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 802e728:	f7fe fc26 	bl	802cf78 <HAL_GPIO_EXTI_Callback>
  }
}
 802e72c:	bd08      	pop	{r3, pc}
 802e72e:	bf00      	nop
 802e730:	58000800 	.word	0x58000800

0802e734 <HAL_PWR_EnableBkUpAccess>:
  *         backup domain.
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
 802e734:	4a02      	ldr	r2, [pc, #8]	; (802e740 <HAL_PWR_EnableBkUpAccess+0xc>)
 802e736:	6813      	ldr	r3, [r2, #0]
 802e738:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 802e73c:	6013      	str	r3, [r2, #0]
}
 802e73e:	4770      	bx	lr
 802e740:	58000400 	.word	0x58000400

0802e744 <HAL_PWR_EnterSLEEPMode>:
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR(Regulator));
  assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));

  /* Set Regulator parameter */
  if (Regulator == PWR_MAINREGULATOR_ON)
 802e744:	4b0d      	ldr	r3, [pc, #52]	; (802e77c <HAL_PWR_EnterSLEEPMode+0x38>)
{
 802e746:	b510      	push	{r4, lr}
  {
    /* If in low-power run mode at this point, exit it */
    if (HAL_IS_BIT_SET(PWR->SR2, (PWR_SR2_REGLPF)))
 802e748:	695b      	ldr	r3, [r3, #20]
{
 802e74a:	460c      	mov	r4, r1
  if (Regulator == PWR_MAINREGULATOR_ON)
 802e74c:	b928      	cbnz	r0, 802e75a <HAL_PWR_EnterSLEEPMode+0x16>
    if (HAL_IS_BIT_SET(PWR->SR2, (PWR_SR2_REGLPF)))
 802e74e:	059a      	lsls	r2, r3, #22
 802e750:	d507      	bpl.n	802e762 <HAL_PWR_EnterSLEEPMode+0x1e>
    {
      if (HAL_PWREx_DisableLowPowerRunMode() != HAL_OK)
 802e752:	f000 f827 	bl	802e7a4 <HAL_PWREx_DisableLowPowerRunMode>
 802e756:	b120      	cbz	r0, 802e762 <HAL_PWR_EnterSLEEPMode+0x1e>
    /* Request Wait For Event */
    __SEV();
    __WFE();
    __WFE();
  }
}
 802e758:	bd10      	pop	{r4, pc}
    if (HAL_IS_BIT_CLR(PWR->SR2, (PWR_SR2_REGLPF)))
 802e75a:	059b      	lsls	r3, r3, #22
 802e75c:	d401      	bmi.n	802e762 <HAL_PWR_EnterSLEEPMode+0x1e>
      HAL_PWREx_EnableLowPowerRunMode();
 802e75e:	f000 f819 	bl	802e794 <HAL_PWREx_EnableLowPowerRunMode>
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 802e762:	4a07      	ldr	r2, [pc, #28]	; (802e780 <HAL_PWR_EnterSLEEPMode+0x3c>)
 802e764:	6913      	ldr	r3, [r2, #16]
  if (SLEEPEntry == PWR_SLEEPENTRY_WFI)
 802e766:	2c01      	cmp	r4, #1
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 802e768:	f023 0304 	bic.w	r3, r3, #4
 802e76c:	6113      	str	r3, [r2, #16]
  if (SLEEPEntry == PWR_SLEEPENTRY_WFI)
 802e76e:	d101      	bne.n	802e774 <HAL_PWR_EnterSLEEPMode+0x30>
    __WFI();
 802e770:	bf30      	wfi
 802e772:	e7f1      	b.n	802e758 <HAL_PWR_EnterSLEEPMode+0x14>
    __SEV();
 802e774:	bf40      	sev
    __WFE();
 802e776:	bf20      	wfe
    __WFE();
 802e778:	bf20      	wfe
 802e77a:	e7ed      	b.n	802e758 <HAL_PWR_EnterSLEEPMode+0x14>
 802e77c:	58000400 	.word	0x58000400
 802e780:	e000ed00 	.word	0xe000ed00

0802e784 <HAL_PWREx_GetVoltageRange>:
  * @brief Return Voltage Scaling Range.
  * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_SCALE1 or PWPWR_REGULATOR_VOLTAGE_SCALE2)
  */
uint32_t HAL_PWREx_GetVoltageRange(void)
{
  return (PWR->CR1 & PWR_CR1_VOS);
 802e784:	4b02      	ldr	r3, [pc, #8]	; (802e790 <HAL_PWREx_GetVoltageRange+0xc>)
 802e786:	6818      	ldr	r0, [r3, #0]
}
 802e788:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
 802e78c:	4770      	bx	lr
 802e78e:	bf00      	nop
 802e790:	58000400 	.word	0x58000400

0802e794 <HAL_PWREx_EnableLowPowerRunMode>:
  * @retval None
  */
void HAL_PWREx_EnableLowPowerRunMode(void)
{
  /* Set Regulator parameter */
  SET_BIT(PWR->CR1, PWR_CR1_LPR);
 802e794:	4a02      	ldr	r2, [pc, #8]	; (802e7a0 <HAL_PWREx_EnableLowPowerRunMode+0xc>)
 802e796:	6813      	ldr	r3, [r2, #0]
 802e798:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 802e79c:	6013      	str	r3, [r2, #0]
}
 802e79e:	4770      	bx	lr
 802e7a0:	58000400 	.word	0x58000400

0802e7a4 <HAL_PWREx_DisableLowPowerRunMode>:
HAL_StatusTypeDef HAL_PWREx_DisableLowPowerRunMode(void)
{
  uint32_t wait_loop_index;

  /* Clear LPR bit */
  CLEAR_BIT(PWR->CR1, PWR_CR1_LPR);
 802e7a4:	4a0d      	ldr	r2, [pc, #52]	; (802e7dc <HAL_PWREx_DisableLowPowerRunMode+0x38>)
 802e7a6:	6813      	ldr	r3, [r2, #0]
 802e7a8:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 802e7ac:	6013      	str	r3, [r2, #0]

  /* Wait until REGLPF is reset */
  wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000UL);
 802e7ae:	4b0c      	ldr	r3, [pc, #48]	; (802e7e0 <HAL_PWREx_DisableLowPowerRunMode+0x3c>)
 802e7b0:	6819      	ldr	r1, [r3, #0]
 802e7b2:	2332      	movs	r3, #50	; 0x32
 802e7b4:	434b      	muls	r3, r1
 802e7b6:	490b      	ldr	r1, [pc, #44]	; (802e7e4 <HAL_PWREx_DisableLowPowerRunMode+0x40>)
 802e7b8:	fbb3 f3f1 	udiv	r3, r3, r1
  while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF)) && (wait_loop_index != 0U))
 802e7bc:	4611      	mov	r1, r2
 802e7be:	6950      	ldr	r0, [r2, #20]
 802e7c0:	f410 7f00 	tst.w	r0, #512	; 0x200
 802e7c4:	d000      	beq.n	802e7c8 <HAL_PWREx_DisableLowPowerRunMode+0x24>
 802e7c6:	b933      	cbnz	r3, 802e7d6 <HAL_PWREx_DisableLowPowerRunMode+0x32>
  {
    wait_loop_index--;
  }
  if (HAL_IS_BIT_SET(PWR->SR2, (PWR_SR2_REGLPF)))
 802e7c8:	694b      	ldr	r3, [r1, #20]
  {
    return HAL_TIMEOUT;
 802e7ca:	f413 7f00 	tst.w	r3, #512	; 0x200
  }

  return HAL_OK;
}
 802e7ce:	bf14      	ite	ne
 802e7d0:	2003      	movne	r0, #3
 802e7d2:	2000      	moveq	r0, #0
 802e7d4:	4770      	bx	lr
    wait_loop_index--;
 802e7d6:	3b01      	subs	r3, #1
 802e7d8:	e7f1      	b.n	802e7be <HAL_PWREx_DisableLowPowerRunMode+0x1a>
 802e7da:	bf00      	nop
 802e7dc:	58000400 	.word	0x58000400
 802e7e0:	2000344c 	.word	0x2000344c
 802e7e4:	000f4240 	.word	0x000f4240

0802e7e8 <HAL_PWREx_EnterSTOP2Mode>:
#ifdef CORE_CM0PLUS
  /* Set Stop mode 2 */
  MODIFY_REG(PWR->C2CR1, PWR_C2CR1_LPMS, PWR_LOWPOWERMODE_STOP2);
#else
  /* Set Stop mode 2 */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_LOWPOWERMODE_STOP2);
 802e7e8:	4a0b      	ldr	r2, [pc, #44]	; (802e818 <HAL_PWREx_EnterSTOP2Mode+0x30>)
 802e7ea:	6813      	ldr	r3, [r2, #0]
 802e7ec:	f023 0307 	bic.w	r3, r3, #7
 802e7f0:	f043 0302 	orr.w	r3, r3, #2
 802e7f4:	6013      	str	r3, [r2, #0]
#endif

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 802e7f6:	4b09      	ldr	r3, [pc, #36]	; (802e81c <HAL_PWREx_EnterSTOP2Mode+0x34>)
 802e7f8:	691a      	ldr	r2, [r3, #16]

  /* Select Stop mode entry --------------------------------------------------*/
  if (STOPEntry == PWR_STOPENTRY_WFI)
 802e7fa:	2801      	cmp	r0, #1
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 802e7fc:	f042 0204 	orr.w	r2, r2, #4
 802e800:	611a      	str	r2, [r3, #16]
  if (STOPEntry == PWR_STOPENTRY_WFI)
 802e802:	d105      	bne.n	802e810 <HAL_PWREx_EnterSTOP2Mode+0x28>
  {
    /* Request Wait For Interrupt */
    __WFI();
 802e804:	bf30      	wfi
    __WFE();
    __WFE();
  }

  /* Reset SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 802e806:	691a      	ldr	r2, [r3, #16]
 802e808:	f022 0204 	bic.w	r2, r2, #4
 802e80c:	611a      	str	r2, [r3, #16]
}
 802e80e:	4770      	bx	lr
    __SEV();
 802e810:	bf40      	sev
    __WFE();
 802e812:	bf20      	wfe
    __WFE();
 802e814:	bf20      	wfe
 802e816:	e7f6      	b.n	802e806 <HAL_PWREx_EnterSTOP2Mode+0x1e>
 802e818:	58000400 	.word	0x58000400
 802e81c:	e000ed00 	.word	0xe000ed00

0802e820 <LL_RCC_HSE_IsReady>:
  return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
 802e820:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802e824:	6818      	ldr	r0, [r3, #0]
}
 802e826:	f3c0 4040 	ubfx	r0, r0, #17, #1
 802e82a:	4770      	bx	lr

0802e82c <LL_RCC_HSI_IsReady>:
  return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
 802e82c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802e830:	6818      	ldr	r0, [r3, #0]
}
 802e832:	f3c0 2080 	ubfx	r0, r0, #10, #1
 802e836:	4770      	bx	lr

0802e838 <LL_RCC_MSI_IsReady>:
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRDY) == (RCC_CR_MSIRDY)) ? 1UL : 0UL);
 802e838:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802e83c:	6818      	ldr	r0, [r3, #0]
}
 802e83e:	f3c0 0040 	ubfx	r0, r0, #1, #1
 802e842:	4770      	bx	lr

0802e844 <LL_RCC_MSI_SetCalibTrimming>:
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_MSITRIM, Value << RCC_ICSCR_MSITRIM_Pos);
 802e844:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 802e848:	6853      	ldr	r3, [r2, #4]
 802e84a:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 802e84e:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 802e852:	6053      	str	r3, [r2, #4]
}
 802e854:	4770      	bx	lr

0802e856 <LL_RCC_PLL_IsReady>:
  * @rmtoll CR           PLLRDY        LL_RCC_PLL_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_IsReady(void)
{
  return ((READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY)) ? 1UL : 0UL);
 802e856:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802e85a:	6818      	ldr	r0, [r3, #0]
}
 802e85c:	f3c0 6040 	ubfx	r0, r0, #25, #1
 802e860:	4770      	bx	lr
	...

0802e864 <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  MSI_Range  MSI range value from @ref RCC_MSIRANGE_0 to @ref RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t MSI_Range)
{
 802e864:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  return (uint32_t)(READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPRE) << 4);
 802e866:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
  uint32_t flash_clksrcfreq;
  uint32_t msifreq;

  /* MSI frequency range in Hz */
  msifreq           = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSIRANGESEL_RUN, MSI_Range);
  flash_clksrcfreq  = __LL_RCC_CALC_HCLK3_FREQ(msifreq, LL_RCC_GetAHB3Prescaler());
 802e86a:	4a2c      	ldr	r2, [pc, #176]	; (802e91c <RCC_SetFlashLatencyFromMSIRange+0xb8>)
 802e86c:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
  msifreq           = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSIRANGESEL_RUN, MSI_Range);
 802e870:	f3c0 1003 	ubfx	r0, r0, #4, #4
  flash_clksrcfreq  = __LL_RCC_CALC_HCLK3_FREQ(msifreq, LL_RCC_GetAHB3Prescaler());
 802e874:	f003 030f 	and.w	r3, r3, #15
 802e878:	f852 4020 	ldr.w	r4, [r2, r0, lsl #2]
 802e87c:	4a28      	ldr	r2, [pc, #160]	; (802e920 <RCC_SetFlashLatencyFromMSIRange+0xbc>)
 802e87e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 802e882:	fbb4 f4f3 	udiv	r4, r4, r3

  return RCC_SetFlashLatency((flash_clksrcfreq / MEGA_HZ), HAL_PWREx_GetVoltageRange());
 802e886:	f7ff ff7d 	bl	802e784 <HAL_PWREx_GetVoltageRange>

  /* Flash Clock source (HCLK3) range in MHz for VCORE range2 */
  const uint16_t FLASH_CLK_SRC_RANGE_VOS2[] = {6, 12, 16};

  /* Flash Latency range */
  const uint32_t FLASH_LATENCY_RANGE[] = {FLASH_LATENCY_0, FLASH_LATENCY_1, FLASH_LATENCY_2};
 802e88a:	4b26      	ldr	r3, [pc, #152]	; (802e924 <RCC_SetFlashLatencyFromMSIRange+0xc0>)
  return RCC_SetFlashLatency((flash_clksrcfreq / MEGA_HZ), HAL_PWREx_GetVoltageRange());
 802e88c:	4605      	mov	r5, r0
  const uint32_t FLASH_LATENCY_RANGE[] = {FLASH_LATENCY_0, FLASH_LATENCY_1, FLASH_LATENCY_2};
 802e88e:	e893 0007 	ldmia.w	r3, {r0, r1, r2}

  uint32_t latency   = FLASH_LATENCY_0;  /* default value 0WS */
  uint32_t tickstart;

  if (VCORE_Voltage == PWR_REGULATOR_VOLTAGE_SCALE1)
 802e892:	f5b5 7f00 	cmp.w	r5, #512	; 0x200
  const uint32_t FLASH_LATENCY_RANGE[] = {FLASH_LATENCY_0, FLASH_LATENCY_1, FLASH_LATENCY_2};
 802e896:	ab04      	add	r3, sp, #16
 802e898:	e903 0007 	stmdb	r3, {r0, r1, r2}
  if (VCORE_Voltage == PWR_REGULATOR_VOLTAGE_SCALE1)
 802e89c:	d010      	beq.n	802e8c0 <RCC_SetFlashLatencyFromMSIRange+0x5c>
  }
  else  /* PWR_REGULATOR_VOLTAGE_SCALE2 */
  {
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
    {
      if (Flash_ClkSrcFreq <= FLASH_CLK_SRC_RANGE_VOS2[index])
 802e89e:	4b22      	ldr	r3, [pc, #136]	; (802e928 <RCC_SetFlashLatencyFromMSIRange+0xc4>)
 802e8a0:	429c      	cmp	r4, r3
 802e8a2:	d318      	bcc.n	802e8d6 <RCC_SetFlashLatencyFromMSIRange+0x72>
 802e8a4:	f503 03b7 	add.w	r3, r3, #5996544	; 0x5b8000
 802e8a8:	f603 537f 	addw	r3, r3, #3455	; 0xd7f
 802e8ac:	429c      	cmp	r4, r3
 802e8ae:	d929      	bls.n	802e904 <RCC_SetFlashLatencyFromMSIRange+0xa0>
 802e8b0:	f503 1374 	add.w	r3, r3, #3997696	; 0x3d0000
 802e8b4:	f503 6310 	add.w	r3, r3, #2304	; 0x900
      if (Flash_ClkSrcFreq <= FLASH_CLK_SRC_RANGE_VOS1[index])
 802e8b8:	429c      	cmp	r4, r3
 802e8ba:	d825      	bhi.n	802e908 <RCC_SetFlashLatencyFromMSIRange+0xa4>
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
 802e8bc:	2302      	movs	r3, #2
 802e8be:	e00b      	b.n	802e8d8 <RCC_SetFlashLatencyFromMSIRange+0x74>
      if (Flash_ClkSrcFreq <= FLASH_CLK_SRC_RANGE_VOS1[index])
 802e8c0:	4b1a      	ldr	r3, [pc, #104]	; (802e92c <RCC_SetFlashLatencyFromMSIRange+0xc8>)
 802e8c2:	429c      	cmp	r4, r3
 802e8c4:	d907      	bls.n	802e8d6 <RCC_SetFlashLatencyFromMSIRange+0x72>
 802e8c6:	4b1a      	ldr	r3, [pc, #104]	; (802e930 <RCC_SetFlashLatencyFromMSIRange+0xcc>)
 802e8c8:	429c      	cmp	r4, r3
 802e8ca:	d91b      	bls.n	802e904 <RCC_SetFlashLatencyFromMSIRange+0xa0>
 802e8cc:	f503 0337 	add.w	r3, r3, #11993088	; 0xb70000
 802e8d0:	f503 53d8 	add.w	r3, r3, #6912	; 0x1b00
 802e8d4:	e7f0      	b.n	802e8b8 <RCC_SetFlashLatencyFromMSIRange+0x54>
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
 802e8d6:	2300      	movs	r3, #0
      {
        latency = FLASH_LATENCY_RANGE[index];
 802e8d8:	aa04      	add	r2, sp, #16
 802e8da:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 802e8de:	f853 4c0c 	ldr.w	r4, [r3, #-12]
        break;
      }
    }
  }

  __HAL_FLASH_SET_LATENCY(latency);
 802e8e2:	4d14      	ldr	r5, [pc, #80]	; (802e934 <RCC_SetFlashLatencyFromMSIRange+0xd0>)
 802e8e4:	682b      	ldr	r3, [r5, #0]
 802e8e6:	f023 0307 	bic.w	r3, r3, #7
 802e8ea:	4323      	orrs	r3, r4
 802e8ec:	602b      	str	r3, [r5, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 802e8ee:	f7fd fea9 	bl	802c644 <HAL_GetTick>
 802e8f2:	4606      	mov	r6, r0

  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  while (__HAL_FLASH_GET_LATENCY() != latency)
 802e8f4:	682b      	ldr	r3, [r5, #0]
 802e8f6:	f003 0307 	and.w	r3, r3, #7
 802e8fa:	429c      	cmp	r4, r3
 802e8fc:	d106      	bne.n	802e90c <RCC_SetFlashLatencyFromMSIRange+0xa8>
    if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
    {
      return HAL_TIMEOUT;
    }
  }
  return HAL_OK;
 802e8fe:	2000      	movs	r0, #0
}
 802e900:	b004      	add	sp, #16
 802e902:	bd70      	pop	{r4, r5, r6, pc}
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
 802e904:	2301      	movs	r3, #1
 802e906:	e7e7      	b.n	802e8d8 <RCC_SetFlashLatencyFromMSIRange+0x74>
  uint32_t latency   = FLASH_LATENCY_0;  /* default value 0WS */
 802e908:	2400      	movs	r4, #0
 802e90a:	e7ea      	b.n	802e8e2 <RCC_SetFlashLatencyFromMSIRange+0x7e>
    if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 802e90c:	f7fd fe9a 	bl	802c644 <HAL_GetTick>
 802e910:	1b80      	subs	r0, r0, r6
 802e912:	2802      	cmp	r0, #2
 802e914:	d9ee      	bls.n	802e8f4 <RCC_SetFlashLatencyFromMSIRange+0x90>
      return HAL_TIMEOUT;
 802e916:	2003      	movs	r0, #3
 802e918:	e7f2      	b.n	802e900 <RCC_SetFlashLatencyFromMSIRange+0x9c>
 802e91a:	bf00      	nop
 802e91c:	0803b9c4 	.word	0x0803b9c4
 802e920:	0803ba04 	.word	0x0803ba04
 802e924:	0803ba64 	.word	0x0803ba64
 802e928:	006acfc0 	.word	0x006acfc0
 802e92c:	0121eabf 	.word	0x0121eabf
 802e930:	0234933f 	.word	0x0234933f
 802e934:	58004000 	.word	0x58004000

0802e938 <HAL_RCC_GetSysClockFreq>:
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 802e938:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
{
 802e93c:	b510      	push	{r4, lr}
 802e93e:	689a      	ldr	r2, [r3, #8]
  *         @arg @ref LL_RCC_PLLSOURCE_HSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetMainSource(void)
{
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 802e940:	68d9      	ldr	r1, [r3, #12]
  if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 802e942:	f012 020c 	ands.w	r2, r2, #12
 802e946:	d005      	beq.n	802e954 <HAL_RCC_GetSysClockFreq+0x1c>
 802e948:	2a0c      	cmp	r2, #12
 802e94a:	d14a      	bne.n	802e9e2 <HAL_RCC_GetSysClockFreq+0xaa>
 802e94c:	f001 0303 	and.w	r3, r1, #3
      ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pllsource == RCC_PLLSOURCE_MSI)))
 802e950:	2b01      	cmp	r3, #1
 802e952:	d150      	bne.n	802e9f6 <HAL_RCC_GetSysClockFreq+0xbe>
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == (RCC_CR_MSIRGSEL)) ? 1UL : 0UL);
 802e954:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 802e958:	482b      	ldr	r0, [pc, #172]	; (802ea08 <HAL_RCC_GetSysClockFreq+0xd0>)
 802e95a:	680b      	ldr	r3, [r1, #0]
 802e95c:	f013 0308 	ands.w	r3, r3, #8
 802e960:	d006      	beq.n	802e970 <HAL_RCC_GetSysClockFreq+0x38>
 802e962:	680b      	ldr	r3, [r1, #0]
 802e964:	f013 0308 	ands.w	r3, r3, #8
 802e968:	d137      	bne.n	802e9da <HAL_RCC_GetSysClockFreq+0xa2>
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 802e96a:	f8d1 1094 	ldr.w	r1, [r1, #148]	; 0x94
 802e96e:	e007      	b.n	802e980 <HAL_RCC_GetSysClockFreq+0x48>
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == (RCC_CR_MSIRGSEL)) ? 1UL : 0UL);
 802e970:	680c      	ldr	r4, [r1, #0]
 802e972:	0724      	lsls	r4, r4, #28
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 802e974:	bf56      	itet	pl
 802e976:	f8d1 3094 	ldrpl.w	r3, [r1, #148]	; 0x94
  return (uint32_t)(READ_BIT(RCC->CR, RCC_CR_MSIRANGE));
 802e97a:	6809      	ldrmi	r1, [r1, #0]
    msifreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
 802e97c:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 802e980:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
      sysclockfreq = msifreq;
 802e984:	2a00      	cmp	r2, #0
 802e986:	bf0c      	ite	eq
 802e988:	4618      	moveq	r0, r3
 802e98a:	2000      	movne	r0, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 802e98c:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 802e990:	688a      	ldr	r2, [r1, #8]
 802e992:	f002 020c 	and.w	r2, r2, #12
  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 802e996:	2a0c      	cmp	r2, #12
 802e998:	d11e      	bne.n	802e9d8 <HAL_RCC_GetSysClockFreq+0xa0>
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 802e99a:	68ca      	ldr	r2, [r1, #12]
 802e99c:	f002 0203 	and.w	r2, r2, #3
    switch (pllsource)
 802e9a0:	2a02      	cmp	r2, #2
 802e9a2:	d02e      	beq.n	802ea02 <HAL_RCC_GetSysClockFreq+0xca>
 802e9a4:	2a03      	cmp	r2, #3
 802e9a6:	d106      	bne.n	802e9b6 <HAL_RCC_GetSysClockFreq+0x7e>
  return ((READ_BIT(RCC->CR, RCC_CR_HSEPRE) == (RCC_CR_HSEPRE)) ? 1UL : 0UL);
 802e9a8:	680b      	ldr	r3, [r1, #0]
          pllinputfreq = HSE_VALUE / 2U;
 802e9aa:	4818      	ldr	r0, [pc, #96]	; (802ea0c <HAL_RCC_GetSysClockFreq+0xd4>)
 802e9ac:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 802e9b0:	4b17      	ldr	r3, [pc, #92]	; (802ea10 <HAL_RCC_GetSysClockFreq+0xd8>)
 802e9b2:	bf18      	it	ne
 802e9b4:	4603      	movne	r3, r0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 802e9b6:	f04f 40b0 	mov.w	r0, #1476395008	; 0x58000000
 802e9ba:	68c1      	ldr	r1, [r0, #12]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM));
 802e9bc:	68c2      	ldr	r2, [r0, #12]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR));
 802e9be:	68c0      	ldr	r0, [r0, #12]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 802e9c0:	f3c1 2106 	ubfx	r1, r1, #8, #7
    sysclockfreq = __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
 802e9c4:	f3c2 1202 	ubfx	r2, r2, #4, #3
 802e9c8:	0f40      	lsrs	r0, r0, #29
 802e9ca:	434b      	muls	r3, r1
 802e9cc:	3201      	adds	r2, #1
 802e9ce:	3001      	adds	r0, #1
 802e9d0:	fbb3 f3f2 	udiv	r3, r3, r2
 802e9d4:	fbb3 f0f0 	udiv	r0, r3, r0
}
 802e9d8:	bd10      	pop	{r4, pc}
  return (uint32_t)(READ_BIT(RCC->CR, RCC_CR_MSIRANGE));
 802e9da:	680b      	ldr	r3, [r1, #0]
    msifreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
 802e9dc:	f3c3 1303 	ubfx	r3, r3, #4, #4
 802e9e0:	e7ce      	b.n	802e980 <HAL_RCC_GetSysClockFreq+0x48>
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI)
 802e9e2:	2a04      	cmp	r2, #4
 802e9e4:	d00a      	beq.n	802e9fc <HAL_RCC_GetSysClockFreq+0xc4>
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 802e9e6:	2a08      	cmp	r2, #8
 802e9e8:	d105      	bne.n	802e9f6 <HAL_RCC_GetSysClockFreq+0xbe>
  return ((READ_BIT(RCC->CR, RCC_CR_HSEPRE) == (RCC_CR_HSEPRE)) ? 1UL : 0UL);
 802e9ea:	681b      	ldr	r3, [r3, #0]
 802e9ec:	f413 1380 	ands.w	r3, r3, #1048576	; 0x100000
 802e9f0:	d104      	bne.n	802e9fc <HAL_RCC_GetSysClockFreq+0xc4>
      sysclockfreq = HSE_VALUE;
 802e9f2:	4807      	ldr	r0, [pc, #28]	; (802ea10 <HAL_RCC_GetSysClockFreq+0xd8>)
 802e9f4:	e7ca      	b.n	802e98c <HAL_RCC_GetSysClockFreq+0x54>
  uint32_t msifreq = 0U;
 802e9f6:	2300      	movs	r3, #0
  uint32_t sysclockfreq = 0U;
 802e9f8:	4618      	mov	r0, r3
 802e9fa:	e7c7      	b.n	802e98c <HAL_RCC_GetSysClockFreq+0x54>
      sysclockfreq = HSE_VALUE / 2U;
 802e9fc:	4803      	ldr	r0, [pc, #12]	; (802ea0c <HAL_RCC_GetSysClockFreq+0xd4>)
  uint32_t msifreq = 0U;
 802e9fe:	2300      	movs	r3, #0
 802ea00:	e7c4      	b.n	802e98c <HAL_RCC_GetSysClockFreq+0x54>
        pllinputfreq = HSI_VALUE;
 802ea02:	4b02      	ldr	r3, [pc, #8]	; (802ea0c <HAL_RCC_GetSysClockFreq+0xd4>)
 802ea04:	e7d7      	b.n	802e9b6 <HAL_RCC_GetSysClockFreq+0x7e>
 802ea06:	bf00      	nop
 802ea08:	0803b9c4 	.word	0x0803b9c4
 802ea0c:	00f42400 	.word	0x00f42400
 802ea10:	01e84800 	.word	0x01e84800

0802ea14 <HAL_RCC_GetHCLKFreq>:
{
 802ea14:	b508      	push	{r3, lr}
  return ((uint32_t)(__LL_RCC_CALC_HCLK1_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler())));
 802ea16:	f7ff ff8f 	bl	802e938 <HAL_RCC_GetSysClockFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
 802ea1a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802ea1e:	4a04      	ldr	r2, [pc, #16]	; (802ea30 <HAL_RCC_GetHCLKFreq+0x1c>)
 802ea20:	689b      	ldr	r3, [r3, #8]
 802ea22:	f3c3 1303 	ubfx	r3, r3, #4, #4
 802ea26:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
}
 802ea2a:	fbb0 f0f3 	udiv	r0, r0, r3
 802ea2e:	bd08      	pop	{r3, pc}
 802ea30:	0803ba04 	.word	0x0803ba04

0802ea34 <HAL_RCC_OscConfig>:
{
 802ea34:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (RCC_OscInitStruct == NULL)
 802ea38:	4604      	mov	r4, r0
 802ea3a:	2800      	cmp	r0, #0
 802ea3c:	d055      	beq.n	802eaea <HAL_RCC_OscConfig+0xb6>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 802ea3e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802ea42:	689e      	ldr	r6, [r3, #8]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 802ea44:	68dd      	ldr	r5, [r3, #12]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 802ea46:	6803      	ldr	r3, [r0, #0]
 802ea48:	0699      	lsls	r1, r3, #26
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 802ea4a:	f006 060c 	and.w	r6, r6, #12
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 802ea4e:	f005 0503 	and.w	r5, r5, #3
 802ea52:	d56b      	bpl.n	802eb2c <HAL_RCC_OscConfig+0xf8>
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 802ea54:	b11e      	cbz	r6, 802ea5e <HAL_RCC_OscConfig+0x2a>
 802ea56:	2e0c      	cmp	r6, #12
 802ea58:	d149      	bne.n	802eaee <HAL_RCC_OscConfig+0xba>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_MSI)))
 802ea5a:	2d01      	cmp	r5, #1
 802ea5c:	d147      	bne.n	802eaee <HAL_RCC_OscConfig+0xba>
      if ((LL_RCC_MSI_IsReady() != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 802ea5e:	f7ff feeb 	bl	802e838 <LL_RCC_MSI_IsReady>
 802ea62:	b110      	cbz	r0, 802ea6a <HAL_RCC_OscConfig+0x36>
 802ea64:	6a23      	ldr	r3, [r4, #32]
 802ea66:	2b00      	cmp	r3, #0
 802ea68:	d03f      	beq.n	802eaea <HAL_RCC_OscConfig+0xb6>
        if (RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 802ea6a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802ea6e:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 802ea70:	681a      	ldr	r2, [r3, #0]
 802ea72:	0712      	lsls	r2, r2, #28
 802ea74:	bf56      	itet	pl
 802ea76:	f8d3 3094 	ldrpl.w	r3, [r3, #148]	; 0x94
 802ea7a:	681b      	ldrmi	r3, [r3, #0]
 802ea7c:	091b      	lsrpl	r3, r3, #4
 802ea7e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 802ea82:	4298      	cmp	r0, r3
 802ea84:	d91e      	bls.n	802eac4 <HAL_RCC_OscConfig+0x90>
          if (RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 802ea86:	f7ff feed 	bl	802e864 <RCC_SetFlashLatencyFromMSIRange>
 802ea8a:	2800      	cmp	r0, #0
 802ea8c:	d12d      	bne.n	802eaea <HAL_RCC_OscConfig+0xb6>
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 802ea8e:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 802ea92:	6813      	ldr	r3, [r2, #0]
 802ea94:	f043 0308 	orr.w	r3, r3, #8
 802ea98:	6013      	str	r3, [r2, #0]
 802ea9a:	6813      	ldr	r3, [r2, #0]
 802ea9c:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 802ea9e:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 802eaa2:	430b      	orrs	r3, r1
 802eaa4:	6013      	str	r3, [r2, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 802eaa6:	6a60      	ldr	r0, [r4, #36]	; 0x24
 802eaa8:	f7ff fecc 	bl	802e844 <LL_RCC_MSI_SetCalibTrimming>
        SystemCoreClock = HAL_RCC_GetHCLKFreq();
 802eaac:	f7ff ffb2 	bl	802ea14 <HAL_RCC_GetHCLKFreq>
 802eab0:	4bac      	ldr	r3, [pc, #688]	; (802ed64 <HAL_RCC_OscConfig+0x330>)
 802eab2:	6018      	str	r0, [r3, #0]
        status = HAL_InitTick(uwTickPrio);
 802eab4:	4bac      	ldr	r3, [pc, #688]	; (802ed68 <HAL_RCC_OscConfig+0x334>)
 802eab6:	6818      	ldr	r0, [r3, #0]
 802eab8:	f7fd fdc2 	bl	802c640 <HAL_InitTick>
        if (status != HAL_OK)
 802eabc:	2800      	cmp	r0, #0
 802eabe:	d035      	beq.n	802eb2c <HAL_RCC_OscConfig+0xf8>
}
 802eac0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 802eac4:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 802eac8:	6813      	ldr	r3, [r2, #0]
 802eaca:	f043 0308 	orr.w	r3, r3, #8
 802eace:	6013      	str	r3, [r2, #0]
 802ead0:	6813      	ldr	r3, [r2, #0]
 802ead2:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 802ead6:	4303      	orrs	r3, r0
 802ead8:	6013      	str	r3, [r2, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 802eada:	6a60      	ldr	r0, [r4, #36]	; 0x24
 802eadc:	f7ff feb2 	bl	802e844 <LL_RCC_MSI_SetCalibTrimming>
          if (RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 802eae0:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 802eae2:	f7ff febf 	bl	802e864 <RCC_SetFlashLatencyFromMSIRange>
 802eae6:	2800      	cmp	r0, #0
 802eae8:	d0e0      	beq.n	802eaac <HAL_RCC_OscConfig+0x78>
          return HAL_ERROR;
 802eaea:	2001      	movs	r0, #1
 802eaec:	e7e8      	b.n	802eac0 <HAL_RCC_OscConfig+0x8c>
      if (RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 802eaee:	6a22      	ldr	r2, [r4, #32]
 802eaf0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802eaf4:	2a00      	cmp	r2, #0
 802eaf6:	d054      	beq.n	802eba2 <HAL_RCC_OscConfig+0x16e>
  SET_BIT(RCC->CR, RCC_CR_MSION);
 802eaf8:	681a      	ldr	r2, [r3, #0]
 802eafa:	f042 0201 	orr.w	r2, r2, #1
 802eafe:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 802eb00:	f7fd fda0 	bl	802c644 <HAL_GetTick>
 802eb04:	4607      	mov	r7, r0
        while (LL_RCC_MSI_IsReady() == 0U)
 802eb06:	f7ff fe97 	bl	802e838 <LL_RCC_MSI_IsReady>
 802eb0a:	2800      	cmp	r0, #0
 802eb0c:	d042      	beq.n	802eb94 <HAL_RCC_OscConfig+0x160>
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 802eb0e:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 802eb12:	6813      	ldr	r3, [r2, #0]
 802eb14:	f043 0308 	orr.w	r3, r3, #8
 802eb18:	6013      	str	r3, [r2, #0]
 802eb1a:	6813      	ldr	r3, [r2, #0]
 802eb1c:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 802eb1e:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 802eb22:	430b      	orrs	r3, r1
 802eb24:	6013      	str	r3, [r2, #0]
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 802eb26:	6a60      	ldr	r0, [r4, #36]	; 0x24
 802eb28:	f7ff fe8c 	bl	802e844 <LL_RCC_MSI_SetCalibTrimming>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 802eb2c:	6823      	ldr	r3, [r4, #0]
 802eb2e:	07db      	lsls	r3, r3, #31
 802eb30:	d448      	bmi.n	802ebc4 <HAL_RCC_OscConfig+0x190>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 802eb32:	6823      	ldr	r3, [r4, #0]
 802eb34:	079f      	lsls	r7, r3, #30
 802eb36:	f100 8090 	bmi.w	802ec5a <HAL_RCC_OscConfig+0x226>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 802eb3a:	6823      	ldr	r3, [r4, #0]
 802eb3c:	071d      	lsls	r5, r3, #28
 802eb3e:	f140 80fc 	bpl.w	802ed3a <HAL_RCC_OscConfig+0x306>
    if (RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 802eb42:	69a3      	ldr	r3, [r4, #24]
 802eb44:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
 802eb48:	2b00      	cmp	r3, #0
 802eb4a:	f000 80e3 	beq.w	802ed14 <HAL_RCC_OscConfig+0x2e0>
      uint32_t csr_temp = RCC->CSR;
 802eb4e:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
      if (RCC_OscInitStruct->LSIDiv != (csr_temp & RCC_CSR_LSIPRE))
 802eb52:	69e1      	ldr	r1, [r4, #28]
 802eb54:	f003 0210 	and.w	r2, r3, #16
 802eb58:	4291      	cmp	r1, r2
 802eb5a:	f000 80c6 	beq.w	802ecea <HAL_RCC_OscConfig+0x2b6>
        if (((csr_temp & RCC_CSR_LSIRDY) == RCC_CSR_LSIRDY) && \
 802eb5e:	f003 0203 	and.w	r2, r3, #3
 802eb62:	2a02      	cmp	r2, #2
 802eb64:	d0c1      	beq.n	802eaea <HAL_RCC_OscConfig+0xb6>
        if ((csr_temp & RCC_CSR_LSION) == RCC_CSR_LSION)
 802eb66:	07d8      	lsls	r0, r3, #31
 802eb68:	f140 80b5 	bpl.w	802ecd6 <HAL_RCC_OscConfig+0x2a2>
  CLEAR_BIT(RCC->CSR, RCC_CSR_LSION);
 802eb6c:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 802eb70:	f023 0301 	bic.w	r3, r3, #1
 802eb74:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94
          tickstart = HAL_GetTick();
 802eb78:	f7fd fd64 	bl	802c644 <HAL_GetTick>
 802eb7c:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == (RCC_CSR_LSIRDY)) ? 1UL : 0UL);
 802eb7e:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 802eb82:	0799      	lsls	r1, r3, #30
 802eb84:	f140 80a7 	bpl.w	802ecd6 <HAL_RCC_OscConfig+0x2a2>
            if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 802eb88:	f7fd fd5c 	bl	802c644 <HAL_GetTick>
 802eb8c:	1bc3      	subs	r3, r0, r7
 802eb8e:	2b11      	cmp	r3, #17
 802eb90:	d9f5      	bls.n	802eb7e <HAL_RCC_OscConfig+0x14a>
 802eb92:	e004      	b.n	802eb9e <HAL_RCC_OscConfig+0x16a>
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 802eb94:	f7fd fd56 	bl	802c644 <HAL_GetTick>
 802eb98:	1bc0      	subs	r0, r0, r7
 802eb9a:	2802      	cmp	r0, #2
 802eb9c:	d9b3      	bls.n	802eb06 <HAL_RCC_OscConfig+0xd2>
            return HAL_TIMEOUT;
 802eb9e:	2003      	movs	r0, #3
 802eba0:	e78e      	b.n	802eac0 <HAL_RCC_OscConfig+0x8c>
  CLEAR_BIT(RCC->CR, RCC_CR_MSION);
 802eba2:	681a      	ldr	r2, [r3, #0]
 802eba4:	f022 0201 	bic.w	r2, r2, #1
 802eba8:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 802ebaa:	f7fd fd4b 	bl	802c644 <HAL_GetTick>
 802ebae:	4607      	mov	r7, r0
        while (LL_RCC_MSI_IsReady() != 0U)
 802ebb0:	f7ff fe42 	bl	802e838 <LL_RCC_MSI_IsReady>
 802ebb4:	2800      	cmp	r0, #0
 802ebb6:	d0b9      	beq.n	802eb2c <HAL_RCC_OscConfig+0xf8>
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 802ebb8:	f7fd fd44 	bl	802c644 <HAL_GetTick>
 802ebbc:	1bc0      	subs	r0, r0, r7
 802ebbe:	2802      	cmp	r0, #2
 802ebc0:	d9f6      	bls.n	802ebb0 <HAL_RCC_OscConfig+0x17c>
 802ebc2:	e7ec      	b.n	802eb9e <HAL_RCC_OscConfig+0x16a>
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE) ||
 802ebc4:	2e08      	cmp	r6, #8
 802ebc6:	d003      	beq.n	802ebd0 <HAL_RCC_OscConfig+0x19c>
 802ebc8:	2e0c      	cmp	r6, #12
 802ebca:	d109      	bne.n	802ebe0 <HAL_RCC_OscConfig+0x1ac>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSE)))
 802ebcc:	2d03      	cmp	r5, #3
 802ebce:	d107      	bne.n	802ebe0 <HAL_RCC_OscConfig+0x1ac>
      if ((LL_RCC_HSE_IsReady() != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 802ebd0:	f7ff fe26 	bl	802e820 <LL_RCC_HSE_IsReady>
 802ebd4:	2800      	cmp	r0, #0
 802ebd6:	d0ac      	beq.n	802eb32 <HAL_RCC_OscConfig+0xfe>
 802ebd8:	6863      	ldr	r3, [r4, #4]
 802ebda:	2b00      	cmp	r3, #0
 802ebdc:	d1a9      	bne.n	802eb32 <HAL_RCC_OscConfig+0xfe>
 802ebde:	e784      	b.n	802eaea <HAL_RCC_OscConfig+0xb6>
      MODIFY_REG(RCC->CR, RCC_CR_HSEPRE, RCC_OscInitStruct->HSEDiv);
 802ebe0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802ebe4:	68a1      	ldr	r1, [r4, #8]
 802ebe6:	681a      	ldr	r2, [r3, #0]
 802ebe8:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 802ebec:	430a      	orrs	r2, r1
 802ebee:	601a      	str	r2, [r3, #0]
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 802ebf0:	6862      	ldr	r2, [r4, #4]
 802ebf2:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 802ebf6:	d110      	bne.n	802ec1a <HAL_RCC_OscConfig+0x1e6>
  SET_BIT(RCC->CR, RCC_CR_HSEON);
 802ebf8:	681a      	ldr	r2, [r3, #0]
 802ebfa:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 802ebfe:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 802ec00:	f7fd fd20 	bl	802c644 <HAL_GetTick>
 802ec04:	4607      	mov	r7, r0
        while (LL_RCC_HSE_IsReady() == 0U)
 802ec06:	f7ff fe0b 	bl	802e820 <LL_RCC_HSE_IsReady>
 802ec0a:	2800      	cmp	r0, #0
 802ec0c:	d191      	bne.n	802eb32 <HAL_RCC_OscConfig+0xfe>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 802ec0e:	f7fd fd19 	bl	802c644 <HAL_GetTick>
 802ec12:	1bc0      	subs	r0, r0, r7
 802ec14:	2864      	cmp	r0, #100	; 0x64
 802ec16:	d9f6      	bls.n	802ec06 <HAL_RCC_OscConfig+0x1d2>
 802ec18:	e7c1      	b.n	802eb9e <HAL_RCC_OscConfig+0x16a>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 802ec1a:	f5b2 1f04 	cmp.w	r2, #2162688	; 0x210000
 802ec1e:	d104      	bne.n	802ec2a <HAL_RCC_OscConfig+0x1f6>
  SET_BIT(RCC->CR, RCC_CR_HSEBYPPWR);
 802ec20:	681a      	ldr	r2, [r3, #0]
 802ec22:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 802ec26:	601a      	str	r2, [r3, #0]
 802ec28:	e7e6      	b.n	802ebf8 <HAL_RCC_OscConfig+0x1c4>
  CLEAR_BIT(RCC->CR, RCC_CR_HSEON);
 802ec2a:	6819      	ldr	r1, [r3, #0]
 802ec2c:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 802ec30:	6019      	str	r1, [r3, #0]
  CLEAR_BIT(RCC->CR, RCC_CR_HSEBYPPWR);
 802ec32:	6819      	ldr	r1, [r3, #0]
 802ec34:	f421 1100 	bic.w	r1, r1, #2097152	; 0x200000
 802ec38:	6019      	str	r1, [r3, #0]
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 802ec3a:	2a00      	cmp	r2, #0
 802ec3c:	d1e0      	bne.n	802ec00 <HAL_RCC_OscConfig+0x1cc>
        tickstart = HAL_GetTick();
 802ec3e:	f7fd fd01 	bl	802c644 <HAL_GetTick>
 802ec42:	4607      	mov	r7, r0
        while (LL_RCC_HSE_IsReady() != 0U)
 802ec44:	f7ff fdec 	bl	802e820 <LL_RCC_HSE_IsReady>
 802ec48:	2800      	cmp	r0, #0
 802ec4a:	f43f af72 	beq.w	802eb32 <HAL_RCC_OscConfig+0xfe>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 802ec4e:	f7fd fcf9 	bl	802c644 <HAL_GetTick>
 802ec52:	1bc0      	subs	r0, r0, r7
 802ec54:	2864      	cmp	r0, #100	; 0x64
 802ec56:	d9f5      	bls.n	802ec44 <HAL_RCC_OscConfig+0x210>
 802ec58:	e7a1      	b.n	802eb9e <HAL_RCC_OscConfig+0x16a>
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI) ||
 802ec5a:	2e04      	cmp	r6, #4
 802ec5c:	d003      	beq.n	802ec66 <HAL_RCC_OscConfig+0x232>
 802ec5e:	2e0c      	cmp	r6, #12
 802ec60:	d112      	bne.n	802ec88 <HAL_RCC_OscConfig+0x254>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSI)))
 802ec62:	2d02      	cmp	r5, #2
 802ec64:	d110      	bne.n	802ec88 <HAL_RCC_OscConfig+0x254>
      if ((LL_RCC_HSI_IsReady() != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 802ec66:	f7ff fde1 	bl	802e82c <LL_RCC_HSI_IsReady>
 802ec6a:	b118      	cbz	r0, 802ec74 <HAL_RCC_OscConfig+0x240>
 802ec6c:	6923      	ldr	r3, [r4, #16]
 802ec6e:	2b00      	cmp	r3, #0
 802ec70:	f43f af3b 	beq.w	802eaea <HAL_RCC_OscConfig+0xb6>
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_HSITRIM, Value << RCC_ICSCR_HSITRIM_Pos);
 802ec74:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 802ec78:	6961      	ldr	r1, [r4, #20]
 802ec7a:	6853      	ldr	r3, [r2, #4]
 802ec7c:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 802ec80:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 802ec84:	6053      	str	r3, [r2, #4]
}
 802ec86:	e758      	b.n	802eb3a <HAL_RCC_OscConfig+0x106>
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 802ec88:	6922      	ldr	r2, [r4, #16]
 802ec8a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802ec8e:	b182      	cbz	r2, 802ecb2 <HAL_RCC_OscConfig+0x27e>
  SET_BIT(RCC->CR, RCC_CR_HSION);
 802ec90:	681a      	ldr	r2, [r3, #0]
 802ec92:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 802ec96:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 802ec98:	f7fd fcd4 	bl	802c644 <HAL_GetTick>
 802ec9c:	4605      	mov	r5, r0
        while (LL_RCC_HSI_IsReady() == 0U)
 802ec9e:	f7ff fdc5 	bl	802e82c <LL_RCC_HSI_IsReady>
 802eca2:	2800      	cmp	r0, #0
 802eca4:	d1e6      	bne.n	802ec74 <HAL_RCC_OscConfig+0x240>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 802eca6:	f7fd fccd 	bl	802c644 <HAL_GetTick>
 802ecaa:	1b40      	subs	r0, r0, r5
 802ecac:	2802      	cmp	r0, #2
 802ecae:	d9f6      	bls.n	802ec9e <HAL_RCC_OscConfig+0x26a>
 802ecb0:	e775      	b.n	802eb9e <HAL_RCC_OscConfig+0x16a>
  CLEAR_BIT(RCC->CR, RCC_CR_HSION);
 802ecb2:	681a      	ldr	r2, [r3, #0]
 802ecb4:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 802ecb8:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 802ecba:	f7fd fcc3 	bl	802c644 <HAL_GetTick>
 802ecbe:	4605      	mov	r5, r0
        while (LL_RCC_HSI_IsReady() != 0U)
 802ecc0:	f7ff fdb4 	bl	802e82c <LL_RCC_HSI_IsReady>
 802ecc4:	2800      	cmp	r0, #0
 802ecc6:	f43f af38 	beq.w	802eb3a <HAL_RCC_OscConfig+0x106>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 802ecca:	f7fd fcbb 	bl	802c644 <HAL_GetTick>
 802ecce:	1b40      	subs	r0, r0, r5
 802ecd0:	2802      	cmp	r0, #2
 802ecd2:	d9f5      	bls.n	802ecc0 <HAL_RCC_OscConfig+0x28c>
 802ecd4:	e763      	b.n	802eb9e <HAL_RCC_OscConfig+0x16a>
        MODIFY_REG(RCC->CSR, RCC_CSR_LSIPRE, RCC_OscInitStruct->LSIDiv);
 802ecd6:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 802ecda:	69e1      	ldr	r1, [r4, #28]
 802ecdc:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
 802ece0:	f023 0310 	bic.w	r3, r3, #16
 802ece4:	430b      	orrs	r3, r1
 802ece6:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
  SET_BIT(RCC->CSR, RCC_CSR_LSION);
 802ecea:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
 802ecee:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 802ecf2:	f043 0301 	orr.w	r3, r3, #1
 802ecf6:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94
      tickstart = HAL_GetTick();
 802ecfa:	f7fd fca3 	bl	802c644 <HAL_GetTick>
 802ecfe:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == (RCC_CSR_LSIRDY)) ? 1UL : 0UL);
 802ed00:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 802ed04:	079a      	lsls	r2, r3, #30
 802ed06:	d418      	bmi.n	802ed3a <HAL_RCC_OscConfig+0x306>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 802ed08:	f7fd fc9c 	bl	802c644 <HAL_GetTick>
 802ed0c:	1bc3      	subs	r3, r0, r7
 802ed0e:	2b11      	cmp	r3, #17
 802ed10:	d9f6      	bls.n	802ed00 <HAL_RCC_OscConfig+0x2cc>
 802ed12:	e744      	b.n	802eb9e <HAL_RCC_OscConfig+0x16a>
  CLEAR_BIT(RCC->CSR, RCC_CSR_LSION);
 802ed14:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 802ed18:	f023 0301 	bic.w	r3, r3, #1
 802ed1c:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94
      tickstart = HAL_GetTick();
 802ed20:	f7fd fc90 	bl	802c644 <HAL_GetTick>
 802ed24:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == (RCC_CSR_LSIRDY)) ? 1UL : 0UL);
 802ed26:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 802ed2a:	079b      	lsls	r3, r3, #30
 802ed2c:	d505      	bpl.n	802ed3a <HAL_RCC_OscConfig+0x306>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 802ed2e:	f7fd fc89 	bl	802c644 <HAL_GetTick>
 802ed32:	1bc3      	subs	r3, r0, r7
 802ed34:	2b11      	cmp	r3, #17
 802ed36:	d9f6      	bls.n	802ed26 <HAL_RCC_OscConfig+0x2f2>
 802ed38:	e731      	b.n	802eb9e <HAL_RCC_OscConfig+0x16a>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 802ed3a:	6823      	ldr	r3, [r4, #0]
 802ed3c:	0758      	lsls	r0, r3, #29
 802ed3e:	d553      	bpl.n	802ede8 <HAL_RCC_OscConfig+0x3b4>
  return ((READ_BIT(PWR->CR1, PWR_CR1_DBP) == (PWR_CR1_DBP)) ? 1UL : 0UL);
 802ed40:	4d0a      	ldr	r5, [pc, #40]	; (802ed6c <HAL_RCC_OscConfig+0x338>)
 802ed42:	682b      	ldr	r3, [r5, #0]
 802ed44:	05d9      	lsls	r1, r3, #23
 802ed46:	d413      	bmi.n	802ed70 <HAL_RCC_OscConfig+0x33c>
      HAL_PWR_EnableBkUpAccess();
 802ed48:	f7ff fcf4 	bl	802e734 <HAL_PWR_EnableBkUpAccess>
      tickstart = HAL_GetTick();
 802ed4c:	f7fd fc7a 	bl	802c644 <HAL_GetTick>
 802ed50:	4607      	mov	r7, r0
 802ed52:	682b      	ldr	r3, [r5, #0]
 802ed54:	05da      	lsls	r2, r3, #23
 802ed56:	d40b      	bmi.n	802ed70 <HAL_RCC_OscConfig+0x33c>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 802ed58:	f7fd fc74 	bl	802c644 <HAL_GetTick>
 802ed5c:	1bc3      	subs	r3, r0, r7
 802ed5e:	2b02      	cmp	r3, #2
 802ed60:	d9f7      	bls.n	802ed52 <HAL_RCC_OscConfig+0x31e>
 802ed62:	e71c      	b.n	802eb9e <HAL_RCC_OscConfig+0x16a>
 802ed64:	2000344c 	.word	0x2000344c
 802ed68:	20003454 	.word	0x20003454
 802ed6c:	58000400 	.word	0x58000400
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 802ed70:	68e3      	ldr	r3, [r4, #12]
 802ed72:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
 802ed76:	2b00      	cmp	r3, #0
 802ed78:	d058      	beq.n	802ee2c <HAL_RCC_OscConfig+0x3f8>
          || (RCC_OscInitStruct->LSEState == RCC_LSE_BYPASS_RTC_ONLY))
 802ed7a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 802ed7e:	2b05      	cmp	r3, #5
        SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
 802ed80:	bf02      	ittt	eq
 802ed82:	f8d5 3090 	ldreq.w	r3, [r5, #144]	; 0x90
 802ed86:	f043 0304 	orreq.w	r3, r3, #4
 802ed8a:	f8c5 3090 	streq.w	r3, [r5, #144]	; 0x90
      SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 802ed8e:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
      tickstart = HAL_GetTick();
 802ed92:	f7fd fc57 	bl	802c644 <HAL_GetTick>
      SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 802ed96:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802ed9a:	f043 0301 	orr.w	r3, r3, #1
      tickstart = HAL_GetTick();
 802ed9e:	4607      	mov	r7, r0
      SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 802eda0:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802eda4:	f241 3888 	movw	r8, #5000	; 0x1388
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? 1UL : 0UL);
 802eda8:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802edac:	079b      	lsls	r3, r3, #30
 802edae:	d405      	bmi.n	802edbc <HAL_RCC_OscConfig+0x388>
 802edb0:	f7fd fc48 	bl	802c644 <HAL_GetTick>
 802edb4:	1bc3      	subs	r3, r0, r7
 802edb6:	4543      	cmp	r3, r8
 802edb8:	d9f6      	bls.n	802eda8 <HAL_RCC_OscConfig+0x374>
 802edba:	e6f0      	b.n	802eb9e <HAL_RCC_OscConfig+0x16a>
      if ((RCC_OscInitStruct->LSEState == RCC_LSE_ON)
 802edbc:	68e3      	ldr	r3, [r4, #12]
 802edbe:	f023 0304 	bic.w	r3, r3, #4
 802edc2:	2b81      	cmp	r3, #129	; 0x81
 802edc4:	d11b      	bne.n	802edfe <HAL_RCC_OscConfig+0x3ca>
        tickstart = HAL_GetTick();
 802edc6:	f7fd fc3d 	bl	802c644 <HAL_GetTick>
        SET_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 802edca:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802edce:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 802edd2:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        tickstart = HAL_GetTick();
 802edd6:	4607      	mov	r7, r0
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) == 0U)
 802edd8:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802eddc:	f241 3888 	movw	r8, #5000	; 0x1388
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) == 0U)
 802ede0:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802ede4:	0518      	lsls	r0, r3, #20
 802ede6:	d504      	bpl.n	802edf2 <HAL_RCC_OscConfig+0x3be>
  if (RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 802ede8:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 802edea:	2800      	cmp	r0, #0
 802edec:	d14a      	bne.n	802ee84 <HAL_RCC_OscConfig+0x450>
  return HAL_OK;
 802edee:	2000      	movs	r0, #0
 802edf0:	e666      	b.n	802eac0 <HAL_RCC_OscConfig+0x8c>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802edf2:	f7fd fc27 	bl	802c644 <HAL_GetTick>
 802edf6:	1bc0      	subs	r0, r0, r7
 802edf8:	4540      	cmp	r0, r8
 802edfa:	d9f1      	bls.n	802ede0 <HAL_RCC_OscConfig+0x3ac>
 802edfc:	e6cf      	b.n	802eb9e <HAL_RCC_OscConfig+0x16a>
        tickstart = HAL_GetTick();
 802edfe:	f7fd fc21 	bl	802c644 <HAL_GetTick>
        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 802ee02:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802ee06:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 802ee0a:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        tickstart = HAL_GetTick();
 802ee0e:	4607      	mov	r7, r0
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 802ee10:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802ee14:	f241 3888 	movw	r8, #5000	; 0x1388
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 802ee18:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802ee1c:	0519      	lsls	r1, r3, #20
 802ee1e:	d5e3      	bpl.n	802ede8 <HAL_RCC_OscConfig+0x3b4>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802ee20:	f7fd fc10 	bl	802c644 <HAL_GetTick>
 802ee24:	1bc0      	subs	r0, r0, r7
 802ee26:	4540      	cmp	r0, r8
 802ee28:	d9f6      	bls.n	802ee18 <HAL_RCC_OscConfig+0x3e4>
 802ee2a:	e6b8      	b.n	802eb9e <HAL_RCC_OscConfig+0x16a>
      tickstart = HAL_GetTick();
 802ee2c:	f7fd fc0a 	bl	802c644 <HAL_GetTick>
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 802ee30:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802ee34:	f023 0380 	bic.w	r3, r3, #128	; 0x80
      tickstart = HAL_GetTick();
 802ee38:	4607      	mov	r7, r0
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 802ee3a:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802ee3e:	f241 3888 	movw	r8, #5000	; 0x1388
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 802ee42:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802ee46:	051a      	lsls	r2, r3, #20
 802ee48:	d416      	bmi.n	802ee78 <HAL_RCC_OscConfig+0x444>
      tickstart = HAL_GetTick();
 802ee4a:	f7fd fbfb 	bl	802c644 <HAL_GetTick>
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 802ee4e:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802ee52:	f023 0301 	bic.w	r3, r3, #1
 802ee56:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
      tickstart = HAL_GetTick();
 802ee5a:	4607      	mov	r7, r0
 802ee5c:	f04f 48b0 	mov.w	r8, #1476395008	; 0x58000000
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802ee60:	f241 3588 	movw	r5, #5000	; 0x1388
 802ee64:	f8d8 3090 	ldr.w	r3, [r8, #144]	; 0x90
 802ee68:	079b      	lsls	r3, r3, #30
 802ee6a:	d5bd      	bpl.n	802ede8 <HAL_RCC_OscConfig+0x3b4>
 802ee6c:	f7fd fbea 	bl	802c644 <HAL_GetTick>
 802ee70:	1bc3      	subs	r3, r0, r7
 802ee72:	42ab      	cmp	r3, r5
 802ee74:	d9f6      	bls.n	802ee64 <HAL_RCC_OscConfig+0x430>
 802ee76:	e692      	b.n	802eb9e <HAL_RCC_OscConfig+0x16a>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802ee78:	f7fd fbe4 	bl	802c644 <HAL_GetTick>
 802ee7c:	1bc0      	subs	r0, r0, r7
 802ee7e:	4540      	cmp	r0, r8
 802ee80:	d9df      	bls.n	802ee42 <HAL_RCC_OscConfig+0x40e>
 802ee82:	e68c      	b.n	802eb9e <HAL_RCC_OscConfig+0x16a>
    if (sysclk_source != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 802ee84:	2e0c      	cmp	r6, #12
 802ee86:	d053      	beq.n	802ef30 <HAL_RCC_OscConfig+0x4fc>
      if (RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 802ee88:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802ee8c:	2802      	cmp	r0, #2
  CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
 802ee8e:	681a      	ldr	r2, [r3, #0]
 802ee90:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 802ee94:	601a      	str	r2, [r3, #0]
 802ee96:	d133      	bne.n	802ef00 <HAL_RCC_OscConfig+0x4cc>
        tickstart = HAL_GetTick();
 802ee98:	f7fd fbd4 	bl	802c644 <HAL_GetTick>
 802ee9c:	4605      	mov	r5, r0
        while (LL_RCC_PLL_IsReady() != 0U)
 802ee9e:	f7ff fcda 	bl	802e856 <LL_RCC_PLL_IsReady>
 802eea2:	bb38      	cbnz	r0, 802eef4 <HAL_RCC_OscConfig+0x4c0>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 802eea4:	e9d4 310c 	ldrd	r3, r1, [r4, #48]	; 0x30
 802eea8:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 802eeac:	430b      	orrs	r3, r1
 802eeae:	68d0      	ldr	r0, [r2, #12]
 802eeb0:	492f      	ldr	r1, [pc, #188]	; (802ef70 <HAL_RCC_OscConfig+0x53c>)
 802eeb2:	4001      	ands	r1, r0
 802eeb4:	430b      	orrs	r3, r1
 802eeb6:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 802eeb8:	430b      	orrs	r3, r1
 802eeba:	6c21      	ldr	r1, [r4, #64]	; 0x40
 802eebc:	430b      	orrs	r3, r1
 802eebe:	6c61      	ldr	r1, [r4, #68]	; 0x44
 802eec0:	430b      	orrs	r3, r1
 802eec2:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 802eec4:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 802eec8:	60d3      	str	r3, [r2, #12]
  SET_BIT(RCC->CR, RCC_CR_PLLON);
 802eeca:	6813      	ldr	r3, [r2, #0]
 802eecc:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 802eed0:	6013      	str	r3, [r2, #0]
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 802eed2:	68d3      	ldr	r3, [r2, #12]
 802eed4:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 802eed8:	60d3      	str	r3, [r2, #12]
        tickstart = HAL_GetTick();
 802eeda:	f7fd fbb3 	bl	802c644 <HAL_GetTick>
 802eede:	4604      	mov	r4, r0
        while (LL_RCC_PLL_IsReady() == 0U)
 802eee0:	f7ff fcb9 	bl	802e856 <LL_RCC_PLL_IsReady>
 802eee4:	2800      	cmp	r0, #0
 802eee6:	d182      	bne.n	802edee <HAL_RCC_OscConfig+0x3ba>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 802eee8:	f7fd fbac 	bl	802c644 <HAL_GetTick>
 802eeec:	1b00      	subs	r0, r0, r4
 802eeee:	280a      	cmp	r0, #10
 802eef0:	d9f6      	bls.n	802eee0 <HAL_RCC_OscConfig+0x4ac>
 802eef2:	e654      	b.n	802eb9e <HAL_RCC_OscConfig+0x16a>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 802eef4:	f7fd fba6 	bl	802c644 <HAL_GetTick>
 802eef8:	1b40      	subs	r0, r0, r5
 802eefa:	280a      	cmp	r0, #10
 802eefc:	d9cf      	bls.n	802ee9e <HAL_RCC_OscConfig+0x46a>
 802eefe:	e64e      	b.n	802eb9e <HAL_RCC_OscConfig+0x16a>
        MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PLLSOURCE_NONE);
 802ef00:	68da      	ldr	r2, [r3, #12]
 802ef02:	f022 0203 	bic.w	r2, r2, #3
 802ef06:	60da      	str	r2, [r3, #12]
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_RNGCLK | RCC_PLL_ADCCLK);
 802ef08:	68da      	ldr	r2, [r3, #12]
 802ef0a:	f022 5288 	bic.w	r2, r2, #285212672	; 0x11000000
 802ef0e:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 802ef12:	60da      	str	r2, [r3, #12]
        tickstart = HAL_GetTick();
 802ef14:	f7fd fb96 	bl	802c644 <HAL_GetTick>
 802ef18:	4604      	mov	r4, r0
        while (LL_RCC_PLL_IsReady() != 0U)
 802ef1a:	f7ff fc9c 	bl	802e856 <LL_RCC_PLL_IsReady>
 802ef1e:	2800      	cmp	r0, #0
 802ef20:	f43f af65 	beq.w	802edee <HAL_RCC_OscConfig+0x3ba>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 802ef24:	f7fd fb8e 	bl	802c644 <HAL_GetTick>
 802ef28:	1b00      	subs	r0, r0, r4
 802ef2a:	280a      	cmp	r0, #10
 802ef2c:	d9f5      	bls.n	802ef1a <HAL_RCC_OscConfig+0x4e6>
 802ef2e:	e636      	b.n	802eb9e <HAL_RCC_OscConfig+0x16a>
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 802ef30:	2801      	cmp	r0, #1
 802ef32:	f43f adc5 	beq.w	802eac0 <HAL_RCC_OscConfig+0x8c>
        pll_config = RCC->PLLCFGR;
 802ef36:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
        if ((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource)
 802ef3a:	6b22      	ldr	r2, [r4, #48]	; 0x30
        pll_config = RCC->PLLCFGR;
 802ef3c:	68db      	ldr	r3, [r3, #12]
        if ((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource)
 802ef3e:	f003 0103 	and.w	r1, r3, #3
 802ef42:	4291      	cmp	r1, r2
 802ef44:	f47f add1 	bne.w	802eaea <HAL_RCC_OscConfig+0xb6>
            || (READ_BIT(pll_config, RCC_PLLCFGR_PLLM)   != RCC_OscInitStruct->PLL.PLLM)
 802ef48:	6b61      	ldr	r1, [r4, #52]	; 0x34
 802ef4a:	f003 0270 	and.w	r2, r3, #112	; 0x70
 802ef4e:	428a      	cmp	r2, r1
 802ef50:	f47f adcb 	bne.w	802eaea <HAL_RCC_OscConfig+0xb6>
            || (READ_BIT(pll_config, RCC_PLLCFGR_PLLN)   != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos))
 802ef54:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 802ef56:	f403 42fe 	and.w	r2, r3, #32512	; 0x7f00
 802ef5a:	ebb2 2f01 	cmp.w	r2, r1, lsl #8
 802ef5e:	f47f adc4 	bne.w	802eaea <HAL_RCC_OscConfig+0xb6>
            || (READ_BIT(pll_config, RCC_PLLCFGR_PLLR)   != RCC_OscInitStruct->PLL.PLLR))
 802ef62:	6c62      	ldr	r2, [r4, #68]	; 0x44
 802ef64:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
 802ef68:	4293      	cmp	r3, r2
 802ef6a:	f43f af40 	beq.w	802edee <HAL_RCC_OscConfig+0x3ba>
 802ef6e:	e5bc      	b.n	802eaea <HAL_RCC_OscConfig+0xb6>
 802ef70:	11c1808c 	.word	0x11c1808c

0802ef74 <HAL_RCC_ClockConfig>:
{
 802ef74:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802ef78:	460d      	mov	r5, r1
  if (RCC_ClkInitStruct == NULL)
 802ef7a:	4604      	mov	r4, r0
 802ef7c:	b910      	cbnz	r0, 802ef84 <HAL_RCC_ClockConfig+0x10>
    return HAL_ERROR;
 802ef7e:	2001      	movs	r0, #1
}
 802ef80:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 802ef84:	4e74      	ldr	r6, [pc, #464]	; (802f158 <HAL_RCC_ClockConfig+0x1e4>)
 802ef86:	6833      	ldr	r3, [r6, #0]
 802ef88:	f003 0307 	and.w	r3, r3, #7
 802ef8c:	428b      	cmp	r3, r1
 802ef8e:	d316      	bcc.n	802efbe <HAL_RCC_ClockConfig+0x4a>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 802ef90:	6823      	ldr	r3, [r4, #0]
 802ef92:	079a      	lsls	r2, r3, #30
 802ef94:	d527      	bpl.n	802efe6 <HAL_RCC_ClockConfig+0x72>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
 802ef96:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
 802ef9a:	68a2      	ldr	r2, [r4, #8]
 802ef9c:	68b3      	ldr	r3, [r6, #8]
 802ef9e:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 802efa2:	4313      	orrs	r3, r2
 802efa4:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 802efa6:	f7fd fb4d 	bl	802c644 <HAL_GetTick>
 802efaa:	4607      	mov	r7, r0
  * @rmtoll CFGR         HPREF       LL_RCC_IsActiveFlag_HPRE
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_HPRE(void)
{
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_HPREF) == (RCC_CFGR_HPREF)) ? 1UL : 0UL);
 802efac:	68b3      	ldr	r3, [r6, #8]
 802efae:	03db      	lsls	r3, r3, #15
 802efb0:	d419      	bmi.n	802efe6 <HAL_RCC_ClockConfig+0x72>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 802efb2:	f7fd fb47 	bl	802c644 <HAL_GetTick>
 802efb6:	1bc3      	subs	r3, r0, r7
 802efb8:	2b02      	cmp	r3, #2
 802efba:	d9f7      	bls.n	802efac <HAL_RCC_ClockConfig+0x38>
 802efbc:	e011      	b.n	802efe2 <HAL_RCC_ClockConfig+0x6e>
    __HAL_FLASH_SET_LATENCY(FLatency);
 802efbe:	6833      	ldr	r3, [r6, #0]
 802efc0:	f023 0307 	bic.w	r3, r3, #7
 802efc4:	430b      	orrs	r3, r1
 802efc6:	6033      	str	r3, [r6, #0]
    tickstart = HAL_GetTick();
 802efc8:	f7fd fb3c 	bl	802c644 <HAL_GetTick>
 802efcc:	4607      	mov	r7, r0
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 802efce:	6833      	ldr	r3, [r6, #0]
 802efd0:	f003 0307 	and.w	r3, r3, #7
 802efd4:	42ab      	cmp	r3, r5
 802efd6:	d0db      	beq.n	802ef90 <HAL_RCC_ClockConfig+0x1c>
      if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 802efd8:	f7fd fb34 	bl	802c644 <HAL_GetTick>
 802efdc:	1bc0      	subs	r0, r0, r7
 802efde:	2802      	cmp	r0, #2
 802efe0:	d9f5      	bls.n	802efce <HAL_RCC_ClockConfig+0x5a>
        return HAL_TIMEOUT;
 802efe2:	2003      	movs	r0, #3
 802efe4:	e7cc      	b.n	802ef80 <HAL_RCC_ClockConfig+0xc>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK2) == RCC_CLOCKTYPE_HCLK2)
 802efe6:	6823      	ldr	r3, [r4, #0]
 802efe8:	0698      	lsls	r0, r3, #26
 802efea:	d516      	bpl.n	802f01a <HAL_RCC_ClockConfig+0xa6>
  MODIFY_REG(RCC->EXTCFGR, RCC_EXTCFGR_C2HPRE, Prescaler);
 802efec:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
 802eff0:	6962      	ldr	r2, [r4, #20]
 802eff2:	f8d6 3108 	ldr.w	r3, [r6, #264]	; 0x108
 802eff6:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 802effa:	4313      	orrs	r3, r2
 802effc:	f8c6 3108 	str.w	r3, [r6, #264]	; 0x108
    tickstart = HAL_GetTick();
 802f000:	f7fd fb20 	bl	802c644 <HAL_GetTick>
 802f004:	4607      	mov	r7, r0
  * @rmtoll EXTCFGR         C2HPREF       LL_RCC_IsActiveFlag_C2HPRE
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_C2HPRE(void)
{
  return ((READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_C2HPREF) == (RCC_EXTCFGR_C2HPREF)) ? 1UL : 0UL);
 802f006:	f8d6 3108 	ldr.w	r3, [r6, #264]	; 0x108
 802f00a:	0399      	lsls	r1, r3, #14
 802f00c:	d405      	bmi.n	802f01a <HAL_RCC_ClockConfig+0xa6>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 802f00e:	f7fd fb19 	bl	802c644 <HAL_GetTick>
 802f012:	1bc3      	subs	r3, r0, r7
 802f014:	2b02      	cmp	r3, #2
 802f016:	d9f6      	bls.n	802f006 <HAL_RCC_ClockConfig+0x92>
 802f018:	e7e3      	b.n	802efe2 <HAL_RCC_ClockConfig+0x6e>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK3) == RCC_CLOCKTYPE_HCLK3)
 802f01a:	6823      	ldr	r3, [r4, #0]
 802f01c:	065a      	lsls	r2, r3, #25
 802f01e:	d517      	bpl.n	802f050 <HAL_RCC_ClockConfig+0xdc>
  MODIFY_REG(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPRE, Prescaler >> 4);
 802f020:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
 802f024:	69a2      	ldr	r2, [r4, #24]
 802f026:	f8d6 3108 	ldr.w	r3, [r6, #264]	; 0x108
 802f02a:	f023 030f 	bic.w	r3, r3, #15
 802f02e:	ea43 1312 	orr.w	r3, r3, r2, lsr #4
 802f032:	f8c6 3108 	str.w	r3, [r6, #264]	; 0x108
    tickstart = HAL_GetTick();
 802f036:	f7fd fb05 	bl	802c644 <HAL_GetTick>
 802f03a:	4607      	mov	r7, r0
  * @rmtoll EXTCFGR         SHDHPREF       LL_RCC_IsActiveFlag_SHDHPRE
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_SHDHPRE(void)
{
  return ((READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPREF) == (RCC_EXTCFGR_SHDHPREF)) ? 1UL : 0UL);
 802f03c:	f8d6 3108 	ldr.w	r3, [r6, #264]	; 0x108
 802f040:	03db      	lsls	r3, r3, #15
 802f042:	d405      	bmi.n	802f050 <HAL_RCC_ClockConfig+0xdc>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 802f044:	f7fd fafe 	bl	802c644 <HAL_GetTick>
 802f048:	1bc3      	subs	r3, r0, r7
 802f04a:	2b02      	cmp	r3, #2
 802f04c:	d9f6      	bls.n	802f03c <HAL_RCC_ClockConfig+0xc8>
 802f04e:	e7c8      	b.n	802efe2 <HAL_RCC_ClockConfig+0x6e>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 802f050:	6823      	ldr	r3, [r4, #0]
 802f052:	075e      	lsls	r6, r3, #29
 802f054:	d513      	bpl.n	802f07e <HAL_RCC_ClockConfig+0x10a>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, Prescaler);
 802f056:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
 802f05a:	68e2      	ldr	r2, [r4, #12]
 802f05c:	68b3      	ldr	r3, [r6, #8]
 802f05e:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 802f062:	4313      	orrs	r3, r2
 802f064:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 802f066:	f7fd faed 	bl	802c644 <HAL_GetTick>
 802f06a:	4607      	mov	r7, r0
  * @rmtoll CFGR         PPRE1F       LL_RCC_IsActiveFlag_PPRE1
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_PPRE1(void)
{
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1F) == (RCC_CFGR_PPRE1F)) ? 1UL : 0UL);
 802f06c:	68b3      	ldr	r3, [r6, #8]
 802f06e:	0398      	lsls	r0, r3, #14
 802f070:	d405      	bmi.n	802f07e <HAL_RCC_ClockConfig+0x10a>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 802f072:	f7fd fae7 	bl	802c644 <HAL_GetTick>
 802f076:	1bc3      	subs	r3, r0, r7
 802f078:	2b02      	cmp	r3, #2
 802f07a:	d9f7      	bls.n	802f06c <HAL_RCC_ClockConfig+0xf8>
 802f07c:	e7b1      	b.n	802efe2 <HAL_RCC_ClockConfig+0x6e>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 802f07e:	6823      	ldr	r3, [r4, #0]
 802f080:	0719      	lsls	r1, r3, #28
 802f082:	d514      	bpl.n	802f0ae <HAL_RCC_ClockConfig+0x13a>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, Prescaler);
 802f084:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
    LL_RCC_SetAPB2Prescaler((RCC_ClkInitStruct->APB2CLKDivider) << 3U);
 802f088:	6922      	ldr	r2, [r4, #16]
 802f08a:	68b3      	ldr	r3, [r6, #8]
 802f08c:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 802f090:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 802f094:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 802f096:	f7fd fad5 	bl	802c644 <HAL_GetTick>
 802f09a:	4607      	mov	r7, r0
  * @rmtoll CFGR         PPRE2F       LL_RCC_IsActiveFlag_PPRE2
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_PPRE2(void)
{
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2F) == (RCC_CFGR_PPRE2F)) ? 1UL : 0UL);
 802f09c:	68b3      	ldr	r3, [r6, #8]
 802f09e:	035a      	lsls	r2, r3, #13
 802f0a0:	d405      	bmi.n	802f0ae <HAL_RCC_ClockConfig+0x13a>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 802f0a2:	f7fd facf 	bl	802c644 <HAL_GetTick>
 802f0a6:	1bc3      	subs	r3, r0, r7
 802f0a8:	2b02      	cmp	r3, #2
 802f0aa:	d9f7      	bls.n	802f09c <HAL_RCC_ClockConfig+0x128>
 802f0ac:	e799      	b.n	802efe2 <HAL_RCC_ClockConfig+0x6e>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 802f0ae:	6823      	ldr	r3, [r4, #0]
 802f0b0:	07db      	lsls	r3, r3, #31
 802f0b2:	d40f      	bmi.n	802f0d4 <HAL_RCC_ClockConfig+0x160>
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 802f0b4:	4c28      	ldr	r4, [pc, #160]	; (802f158 <HAL_RCC_ClockConfig+0x1e4>)
 802f0b6:	6823      	ldr	r3, [r4, #0]
 802f0b8:	f003 0307 	and.w	r3, r3, #7
 802f0bc:	42ab      	cmp	r3, r5
 802f0be:	d837      	bhi.n	802f130 <HAL_RCC_ClockConfig+0x1bc>
  SystemCoreClock = HAL_RCC_GetHCLKFreq();
 802f0c0:	f7ff fca8 	bl	802ea14 <HAL_RCC_GetHCLKFreq>
 802f0c4:	4b25      	ldr	r3, [pc, #148]	; (802f15c <HAL_RCC_ClockConfig+0x1e8>)
 802f0c6:	6018      	str	r0, [r3, #0]
  return HAL_InitTick(uwTickPrio);
 802f0c8:	4b25      	ldr	r3, [pc, #148]	; (802f160 <HAL_RCC_ClockConfig+0x1ec>)
}
 802f0ca:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  return HAL_InitTick(uwTickPrio);
 802f0ce:	6818      	ldr	r0, [r3, #0]
 802f0d0:	f7fd bab6 	b.w	802c640 <HAL_InitTick>
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 802f0d4:	6863      	ldr	r3, [r4, #4]
 802f0d6:	2b02      	cmp	r3, #2
 802f0d8:	d11e      	bne.n	802f118 <HAL_RCC_ClockConfig+0x1a4>
      if (LL_RCC_HSE_IsReady() == 0U)
 802f0da:	f7ff fba1 	bl	802e820 <LL_RCC_HSE_IsReady>
      if (LL_RCC_HSI_IsReady() == 0U)
 802f0de:	2800      	cmp	r0, #0
 802f0e0:	f43f af4d 	beq.w	802ef7e <HAL_RCC_ClockConfig+0xa>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
 802f0e4:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
 802f0e8:	6862      	ldr	r2, [r4, #4]
 802f0ea:	68b3      	ldr	r3, [r6, #8]
 802f0ec:	f023 0303 	bic.w	r3, r3, #3
 802f0f0:	4313      	orrs	r3, r2
 802f0f2:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 802f0f4:	f7fd faa6 	bl	802c644 <HAL_GetTick>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 802f0f8:	f241 3888 	movw	r8, #5000	; 0x1388
    tickstart = HAL_GetTick();
 802f0fc:	4607      	mov	r7, r0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 802f0fe:	68b3      	ldr	r3, [r6, #8]
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 802f100:	6862      	ldr	r2, [r4, #4]
 802f102:	f003 030c 	and.w	r3, r3, #12
 802f106:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 802f10a:	d0d3      	beq.n	802f0b4 <HAL_RCC_ClockConfig+0x140>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 802f10c:	f7fd fa9a 	bl	802c644 <HAL_GetTick>
 802f110:	1bc0      	subs	r0, r0, r7
 802f112:	4540      	cmp	r0, r8
 802f114:	d9f3      	bls.n	802f0fe <HAL_RCC_ClockConfig+0x18a>
 802f116:	e764      	b.n	802efe2 <HAL_RCC_ClockConfig+0x6e>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 802f118:	2b03      	cmp	r3, #3
 802f11a:	d102      	bne.n	802f122 <HAL_RCC_ClockConfig+0x1ae>
      if (LL_RCC_PLL_IsReady() == 0U)
 802f11c:	f7ff fb9b 	bl	802e856 <LL_RCC_PLL_IsReady>
 802f120:	e7dd      	b.n	802f0de <HAL_RCC_ClockConfig+0x16a>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 802f122:	b913      	cbnz	r3, 802f12a <HAL_RCC_ClockConfig+0x1b6>
      if (LL_RCC_MSI_IsReady() == 0U)
 802f124:	f7ff fb88 	bl	802e838 <LL_RCC_MSI_IsReady>
 802f128:	e7d9      	b.n	802f0de <HAL_RCC_ClockConfig+0x16a>
      if (LL_RCC_HSI_IsReady() == 0U)
 802f12a:	f7ff fb7f 	bl	802e82c <LL_RCC_HSI_IsReady>
 802f12e:	e7d6      	b.n	802f0de <HAL_RCC_ClockConfig+0x16a>
    __HAL_FLASH_SET_LATENCY(FLatency);
 802f130:	6823      	ldr	r3, [r4, #0]
 802f132:	f023 0307 	bic.w	r3, r3, #7
 802f136:	432b      	orrs	r3, r5
 802f138:	6023      	str	r3, [r4, #0]
    tickstart = HAL_GetTick();
 802f13a:	f7fd fa83 	bl	802c644 <HAL_GetTick>
 802f13e:	4606      	mov	r6, r0
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 802f140:	6823      	ldr	r3, [r4, #0]
 802f142:	f003 0307 	and.w	r3, r3, #7
 802f146:	42ab      	cmp	r3, r5
 802f148:	d0ba      	beq.n	802f0c0 <HAL_RCC_ClockConfig+0x14c>
      if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 802f14a:	f7fd fa7b 	bl	802c644 <HAL_GetTick>
 802f14e:	1b80      	subs	r0, r0, r6
 802f150:	2802      	cmp	r0, #2
 802f152:	d9f5      	bls.n	802f140 <HAL_RCC_ClockConfig+0x1cc>
 802f154:	e745      	b.n	802efe2 <HAL_RCC_ClockConfig+0x6e>
 802f156:	bf00      	nop
 802f158:	58004000 	.word	0x58004000
 802f15c:	2000344c 	.word	0x2000344c
 802f160:	20003454 	.word	0x20003454

0802f164 <HAL_RCC_GetPCLK1Freq>:
{
 802f164:	b508      	push	{r3, lr}
  return ((uint32_t)(__LL_RCC_CALC_PCLK1_FREQ(HAL_RCC_GetHCLKFreq(), LL_RCC_GetAPB1Prescaler())));
 802f166:	f7ff fc55 	bl	802ea14 <HAL_RCC_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1));
 802f16a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802f16e:	4a04      	ldr	r2, [pc, #16]	; (802f180 <HAL_RCC_GetPCLK1Freq+0x1c>)
 802f170:	689b      	ldr	r3, [r3, #8]
 802f172:	f3c3 2302 	ubfx	r3, r3, #8, #3
 802f176:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
}
 802f17a:	40d8      	lsrs	r0, r3
 802f17c:	bd08      	pop	{r3, pc}
 802f17e:	bf00      	nop
 802f180:	0803ba44 	.word	0x0803ba44

0802f184 <HAL_RCC_GetPCLK2Freq>:
{
 802f184:	b508      	push	{r3, lr}
  return ((uint32_t)(__LL_RCC_CALC_PCLK2_FREQ(HAL_RCC_GetHCLKFreq(), LL_RCC_GetAPB2Prescaler())));
 802f186:	f7ff fc45 	bl	802ea14 <HAL_RCC_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2));
 802f18a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802f18e:	4a04      	ldr	r2, [pc, #16]	; (802f1a0 <HAL_RCC_GetPCLK2Freq+0x1c>)
 802f190:	689b      	ldr	r3, [r3, #8]
 802f192:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 802f196:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
}
 802f19a:	40d8      	lsrs	r0, r3
 802f19c:	bd08      	pop	{r3, pc}
 802f19e:	bf00      	nop
 802f1a0:	0803ba44 	.word	0x0803ba44

0802f1a4 <LL_RCC_LSE_IsReady>:
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? 1UL : 0UL);
 802f1a4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802f1a8:	f8d3 0090 	ldr.w	r0, [r3, #144]	; 0x90
}
 802f1ac:	f3c0 0040 	ubfx	r0, r0, #1, #1
 802f1b0:	4770      	bx	lr

0802f1b2 <LL_RCC_SetI2CClockSource>:
  MODIFY_REG(RCC->CCIPR, ((I2CxSource >> 4) & 0x000FF000U), ((I2CxSource << 4) & 0x000FF000U));
 802f1b2:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 802f1b6:	0902      	lsrs	r2, r0, #4
 802f1b8:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 802f1bc:	f402 227f 	and.w	r2, r2, #1044480	; 0xff000
 802f1c0:	0100      	lsls	r0, r0, #4
 802f1c2:	ea23 0302 	bic.w	r3, r3, r2
 802f1c6:	f400 207f 	and.w	r0, r0, #1044480	; 0xff000
 802f1ca:	4318      	orrs	r0, r3
 802f1cc:	f8c1 0088 	str.w	r0, [r1, #136]	; 0x88
}
 802f1d0:	4770      	bx	lr

0802f1d2 <LL_RCC_SetLPTIMClockSource>:
  MODIFY_REG(RCC->CCIPR, (LPTIMxSource & 0xFFFF0000U), (LPTIMxSource << 16));
 802f1d2:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 802f1d6:	0c02      	lsrs	r2, r0, #16
 802f1d8:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 802f1dc:	0412      	lsls	r2, r2, #16
 802f1de:	ea23 0302 	bic.w	r3, r3, r2
 802f1e2:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 802f1e6:	f8c1 0088 	str.w	r0, [r1, #136]	; 0x88
}
 802f1ea:	4770      	bx	lr

0802f1ec <HAL_RCCEx_PeriphCLKConfig>:
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 802f1ec:	b570      	push	{r4, r5, r6, lr}

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*-------------------------- RTC clock source configuration ----------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 802f1ee:	6805      	ldr	r5, [r0, #0]
 802f1f0:	f415 3580 	ands.w	r5, r5, #65536	; 0x10000
{
 802f1f4:	4604      	mov	r4, r0
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 802f1f6:	d038      	beq.n	802f26a <HAL_RCCEx_PeriphCLKConfig+0x7e>
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));


    /* Enable write access to Backup domain */
    HAL_PWR_EnableBkUpAccess();
 802f1f8:	f7ff fa9c 	bl	802e734 <HAL_PWR_EnableBkUpAccess>

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 802f1fc:	f7fd fa22 	bl	802c644 <HAL_GetTick>

    while (!(READ_BIT(PWR->CR1, PWR_CR1_DBP) == (PWR_CR1_DBP)))
 802f200:	4e64      	ldr	r6, [pc, #400]	; (802f394 <HAL_RCCEx_PeriphCLKConfig+0x1a8>)
    tickstart = HAL_GetTick();
 802f202:	4605      	mov	r5, r0
    while (!(READ_BIT(PWR->CR1, PWR_CR1_DBP) == (PWR_CR1_DBP)))
 802f204:	6833      	ldr	r3, [r6, #0]
 802f206:	05db      	lsls	r3, r3, #23
 802f208:	d529      	bpl.n	802f25e <HAL_RCCEx_PeriphCLKConfig+0x72>
  return (uint32_t)(READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL));
 802f20a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
    }

    if (ret == HAL_OK)
    {
      /* Reset the Backup domain only if the RTC Clock source selection is modified */
      if (LL_RCC_GetRTCClockSource() != PeriphClkInit->RTCClockSelection)
 802f20e:	6b61      	ldr	r1, [r4, #52]	; 0x34
 802f210:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 802f214:	f402 7240 	and.w	r2, r2, #768	; 0x300
 802f218:	4291      	cmp	r1, r2
 802f21a:	d014      	beq.n	802f246 <HAL_RCCEx_PeriphCLKConfig+0x5a>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 802f21c:	f8d3 1090 	ldr.w	r1, [r3, #144]	; 0x90
  SET_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 802f220:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 802f224:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 802f228:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 802f22c:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 802f230:	f421 7040 	bic.w	r0, r1, #768	; 0x300
 802f234:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpregister;
      }

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSERDY))
 802f238:	078d      	lsls	r5, r1, #30
 802f23a:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
        RCC->BDCR = tmpregister;
 802f23e:	f8c3 0090 	str.w	r0, [r3, #144]	; 0x90
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSERDY))
 802f242:	f100 8096 	bmi.w	802f372 <HAL_RCCEx_PeriphCLKConfig+0x186>
  MODIFY_REG(RCC->BDCR, RCC_BDCR_RTCSEL, Source);
 802f246:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 802f24a:	6b61      	ldr	r1, [r4, #52]	; 0x34
 802f24c:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 802f250:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 802f254:	430b      	orrs	r3, r1
 802f256:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  HAL_StatusTypeDef status  = HAL_OK;   /* Final status */
 802f25a:	2500      	movs	r5, #0
}
 802f25c:	e005      	b.n	802f26a <HAL_RCCEx_PeriphCLKConfig+0x7e>
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 802f25e:	f7fd f9f1 	bl	802c644 <HAL_GetTick>
 802f262:	1b40      	subs	r0, r0, r5
 802f264:	2802      	cmp	r0, #2
 802f266:	d9cd      	bls.n	802f204 <HAL_RCCEx_PeriphCLKConfig+0x18>
        ret = HAL_TIMEOUT;
 802f268:	2503      	movs	r5, #3
    }

  }

  /*-------------------- USART1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 802f26a:	6822      	ldr	r2, [r4, #0]
 802f26c:	07d0      	lsls	r0, r2, #31
 802f26e:	d50a      	bpl.n	802f286 <HAL_RCCEx_PeriphCLKConfig+0x9a>
  MODIFY_REG(RCC->CCIPR, (USARTxSource >> 16), (USARTxSource & 0x0000FFFFU));
 802f270:	f04f 40b0 	mov.w	r0, #1476395008	; 0x58000000
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 802f274:	6861      	ldr	r1, [r4, #4]
 802f276:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
 802f27a:	ea23 4311 	bic.w	r3, r3, r1, lsr #16
 802f27e:	b289      	uxth	r1, r1
 802f280:	430b      	orrs	r3, r1
 802f282:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
  }

  /*-------------------- USART2 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 802f286:	0791      	lsls	r1, r2, #30
 802f288:	d50a      	bpl.n	802f2a0 <HAL_RCCEx_PeriphCLKConfig+0xb4>
 802f28a:	f04f 40b0 	mov.w	r0, #1476395008	; 0x58000000
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 802f28e:	68a1      	ldr	r1, [r4, #8]
 802f290:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
 802f294:	ea23 4311 	bic.w	r3, r3, r1, lsr #16
 802f298:	b289      	uxth	r1, r1
 802f29a:	430b      	orrs	r3, r1
 802f29c:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
  }

  /*-------------------- LPUART1 clock source configuration ------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 802f2a0:	0693      	lsls	r3, r2, #26
 802f2a2:	d509      	bpl.n	802f2b8 <HAL_RCCEx_PeriphCLKConfig+0xcc>
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_LPUART1SEL, LPUARTxSource);
 802f2a4:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 802f2a8:	6920      	ldr	r0, [r4, #16]
 802f2aa:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 802f2ae:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 802f2b2:	4303      	orrs	r3, r0
 802f2b4:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
  }

  /*-------------------- LPTIM1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 802f2b8:	0596      	lsls	r6, r2, #22
 802f2ba:	d502      	bpl.n	802f2c2 <HAL_RCCEx_PeriphCLKConfig+0xd6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));

    /* Configure the LPTIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 802f2bc:	6a20      	ldr	r0, [r4, #32]
 802f2be:	f7ff ff88 	bl	802f1d2 <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------- LPTIM2 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 802f2c2:	6823      	ldr	r3, [r4, #0]
 802f2c4:	0558      	lsls	r0, r3, #21
 802f2c6:	d502      	bpl.n	802f2ce <HAL_RCCEx_PeriphCLKConfig+0xe2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM2CLKSOURCE(PeriphClkInit->Lptim2ClockSelection));

    /* Configure the LPTIM2 clock source */
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 802f2c8:	6a60      	ldr	r0, [r4, #36]	; 0x24
 802f2ca:	f7ff ff82 	bl	802f1d2 <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------- LPTIM3 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM3) == (RCC_PERIPHCLK_LPTIM3))
 802f2ce:	6823      	ldr	r3, [r4, #0]
 802f2d0:	0519      	lsls	r1, r3, #20
 802f2d2:	d502      	bpl.n	802f2da <HAL_RCCEx_PeriphCLKConfig+0xee>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM3CLKSOURCE(PeriphClkInit->Lptim3ClockSelection));

    /* Configure the LPTIM3 clock source */
    __HAL_RCC_LPTIM3_CONFIG(PeriphClkInit->Lptim3ClockSelection);
 802f2d4:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 802f2d6:	f7ff ff7c 	bl	802f1d2 <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------- I2C1 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 802f2da:	6823      	ldr	r3, [r4, #0]
 802f2dc:	065a      	lsls	r2, r3, #25
 802f2de:	d502      	bpl.n	802f2e6 <HAL_RCCEx_PeriphCLKConfig+0xfa>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 802f2e0:	6960      	ldr	r0, [r4, #20]
 802f2e2:	f7ff ff66 	bl	802f1b2 <LL_RCC_SetI2CClockSource>
  }

  /*-------------------- I2C2 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 802f2e6:	6823      	ldr	r3, [r4, #0]
 802f2e8:	061b      	lsls	r3, r3, #24
 802f2ea:	d502      	bpl.n	802f2f2 <HAL_RCCEx_PeriphCLKConfig+0x106>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 802f2ec:	69a0      	ldr	r0, [r4, #24]
 802f2ee:	f7ff ff60 	bl	802f1b2 <LL_RCC_SetI2CClockSource>
  }

  /*-------------------- I2C3 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 802f2f2:	6823      	ldr	r3, [r4, #0]
 802f2f4:	05de      	lsls	r6, r3, #23
 802f2f6:	d502      	bpl.n	802f2fe <HAL_RCCEx_PeriphCLKConfig+0x112>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 802f2f8:	69e0      	ldr	r0, [r4, #28]
 802f2fa:	f7ff ff5a 	bl	802f1b2 <LL_RCC_SetI2CClockSource>
  }

  /*-------------------- I2S2 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S2) == (RCC_PERIPHCLK_I2S2))
 802f2fe:	6821      	ldr	r1, [r4, #0]
 802f300:	06c8      	lsls	r0, r1, #27
 802f302:	d510      	bpl.n	802f326 <HAL_RCCEx_PeriphCLKConfig+0x13a>
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_I2S2SEL, I2SxSource);
 802f304:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2S2CLKSOURCE(PeriphClkInit->I2s2ClockSelection));

    /* Configure the I2S2 clock source */
    __HAL_RCC_I2S2_CONFIG(PeriphClkInit->I2s2ClockSelection);
 802f308:	68e0      	ldr	r0, [r4, #12]
 802f30a:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 802f30e:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 802f312:	4303      	orrs	r3, r0
 802f314:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

    if (PeriphClkInit->I2s2ClockSelection == RCC_I2S2CLKSOURCE_PLL)
 802f318:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
    {
      /* Enable RCC_PLL_I2S2CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_I2S2CLK);
 802f31c:	bf02      	ittt	eq
 802f31e:	68d3      	ldreq	r3, [r2, #12]
 802f320:	f043 7380 	orreq.w	r3, r3, #16777216	; 0x1000000
 802f324:	60d3      	streq	r3, [r2, #12]
    }
  }

  /*-------------------- RNG clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 802f326:	040a      	lsls	r2, r1, #16
 802f328:	d50e      	bpl.n	802f348 <HAL_RCCEx_PeriphCLKConfig+0x15c>
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_RNGSEL, RNGxSource);
 802f32a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
  {
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 802f32e:	6b20      	ldr	r0, [r4, #48]	; 0x30
 802f330:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 802f334:	f023 4340 	bic.w	r3, r3, #3221225472	; 0xc0000000
 802f338:	4303      	orrs	r3, r0
 802f33a:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

    if (PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 802f33e:	b918      	cbnz	r0, 802f348 <HAL_RCCEx_PeriphCLKConfig+0x15c>
    {
      /* Enable RCC_PLL_RNGCLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_RNGCLK);
 802f340:	68d3      	ldr	r3, [r2, #12]
 802f342:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 802f346:	60d3      	str	r3, [r2, #12]
    }
  }

  /*-------------------- ADC clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 802f348:	044b      	lsls	r3, r1, #17
 802f34a:	d510      	bpl.n	802f36e <HAL_RCCEx_PeriphCLKConfig+0x182>
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_ADCSEL, ADCxSource);
 802f34c:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));

    /* Configure the ADC interface clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 802f350:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 802f352:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 802f356:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 802f35a:	430b      	orrs	r3, r1

    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLL)
 802f35c:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
 802f360:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
 802f364:	d103      	bne.n	802f36e <HAL_RCCEx_PeriphCLKConfig+0x182>
    {
      /* Enable RCC_PLL_RNGCLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_ADCCLK);
 802f366:	68d3      	ldr	r3, [r2, #12]
 802f368:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 802f36c:	60d3      	str	r3, [r2, #12]
    }
  }

  return status;
}
 802f36e:	4628      	mov	r0, r5
 802f370:	bd70      	pop	{r4, r5, r6, pc}
        tickstart = HAL_GetTick();
 802f372:	f7fd f967 	bl	802c644 <HAL_GetTick>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802f376:	f241 3688 	movw	r6, #5000	; 0x1388
        tickstart = HAL_GetTick();
 802f37a:	4605      	mov	r5, r0
        while (LL_RCC_LSE_IsReady() != 1U)
 802f37c:	f7ff ff12 	bl	802f1a4 <LL_RCC_LSE_IsReady>
 802f380:	2801      	cmp	r0, #1
 802f382:	f43f af60 	beq.w	802f246 <HAL_RCCEx_PeriphCLKConfig+0x5a>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802f386:	f7fd f95d 	bl	802c644 <HAL_GetTick>
 802f38a:	1b40      	subs	r0, r0, r5
 802f38c:	42b0      	cmp	r0, r6
 802f38e:	d9f5      	bls.n	802f37c <HAL_RCCEx_PeriphCLKConfig+0x190>
 802f390:	e76a      	b.n	802f268 <HAL_RCCEx_PeriphCLKConfig+0x7c>
 802f392:	bf00      	nop
 802f394:	58000400 	.word	0x58000400

0802f398 <HAL_RTC_DeactivateAlarm>:
  *            @arg RTC_ALARM_A:  AlarmA
  *            @arg RTC_ALARM_B:  AlarmB
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_DeactivateAlarm(RTC_HandleTypeDef *hrtc, uint32_t Alarm)
{
 802f398:	b530      	push	{r4, r5, lr}
  /* Check the parameters */
  assert_param(IS_RTC_ALARM(Alarm));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 802f39a:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 802f39e:	2b01      	cmp	r3, #1
 802f3a0:	f04f 0202 	mov.w	r2, #2
 802f3a4:	d022      	beq.n	802f3ec <HAL_RTC_DeactivateAlarm+0x54>

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f3a6:	4b19      	ldr	r3, [pc, #100]	; (802f40c <HAL_RTC_DeactivateAlarm+0x74>)
  hrtc->State = HAL_RTC_STATE_BUSY;
 802f3a8:	f880 202d 	strb.w	r2, [r0, #45]	; 0x2d
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f3ac:	24ca      	movs	r4, #202	; 0xca
  __HAL_LOCK(hrtc);
 802f3ae:	2501      	movs	r5, #1
 802f3b0:	f880 502c 	strb.w	r5, [r0, #44]	; 0x2c
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f3b4:	625c      	str	r4, [r3, #36]	; 0x24
 802f3b6:	2453      	movs	r4, #83	; 0x53
 802f3b8:	625c      	str	r4, [r3, #36]	; 0x24

  if (Alarm == RTC_ALARM_A)
 802f3ba:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 802f3be:	6b04      	ldr	r4, [r0, #48]	; 0x30
 802f3c0:	d116      	bne.n	802f3f0 <HAL_RTC_DeactivateAlarm+0x58>
  {
    /* AlarmA, In case of interrupt mode is used, the interrupt source must disabled */
    CLEAR_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 802f3c2:	699a      	ldr	r2, [r3, #24]
 802f3c4:	f422 5288 	bic.w	r2, r2, #4352	; 0x1100
 802f3c8:	619a      	str	r2, [r3, #24]

    /* AlarmA, Clear SSCLR */
    CLEAR_BIT(RTC->ALRMASSR, RTC_ALRMASSR_SSCLR);
 802f3ca:	6c5a      	ldr	r2, [r3, #68]	; 0x44

    /* Store in the handle the Alarm A disabled */
    CLEAR_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRAMF);
 802f3cc:	f024 0401 	bic.w	r4, r4, #1
    CLEAR_BIT(RTC->ALRMASSR, RTC_ALRMASSR_SSCLR);
 802f3d0:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 802f3d4:	645a      	str	r2, [r3, #68]	; 0x44
    CLEAR_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRAMF);
 802f3d6:	6304      	str	r4, [r0, #48]	; 0x30

    /* Clear AlarmA flag */
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
 802f3d8:	65dd      	str	r5, [r3, #92]	; 0x5c
    /* Clear AlarmB flag */
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 802f3da:	4b0c      	ldr	r3, [pc, #48]	; (802f40c <HAL_RTC_DeactivateAlarm+0x74>)
 802f3dc:	22ff      	movs	r2, #255	; 0xff
 802f3de:	625a      	str	r2, [r3, #36]	; 0x24

  hrtc->State = HAL_RTC_STATE_READY;
 802f3e0:	2301      	movs	r3, #1

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 802f3e2:	2200      	movs	r2, #0
  hrtc->State = HAL_RTC_STATE_READY;
 802f3e4:	f880 302d 	strb.w	r3, [r0, #45]	; 0x2d
  __HAL_UNLOCK(hrtc);
 802f3e8:	f880 202c 	strb.w	r2, [r0, #44]	; 0x2c
  __HAL_LOCK(hrtc);
 802f3ec:	4610      	mov	r0, r2

  return HAL_OK;
}
 802f3ee:	bd30      	pop	{r4, r5, pc}
    CLEAR_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 802f3f0:	6999      	ldr	r1, [r3, #24]
 802f3f2:	f421 5108 	bic.w	r1, r1, #8704	; 0x2200
 802f3f6:	6199      	str	r1, [r3, #24]
    CLEAR_BIT(RTC->ALRMBSSR, RTC_ALRMBSSR_SSCLR);
 802f3f8:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
    CLEAR_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRBMF);
 802f3fa:	f024 0402 	bic.w	r4, r4, #2
    CLEAR_BIT(RTC->ALRMBSSR, RTC_ALRMBSSR_SSCLR);
 802f3fe:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 802f402:	64d9      	str	r1, [r3, #76]	; 0x4c
    CLEAR_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRBMF);
 802f404:	6304      	str	r4, [r0, #48]	; 0x30
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
 802f406:	65da      	str	r2, [r3, #92]	; 0x5c
 802f408:	e7e7      	b.n	802f3da <HAL_RTC_DeactivateAlarm+0x42>
 802f40a:	bf00      	nop
 802f40c:	40002800 	.word	0x40002800

0802f410 <HAL_RTC_AlarmIRQHandler>:
  * @brief  Handle Alarm interrupt request.
  * @param  hrtc RTC handle
  * @retval None
  */
void HAL_RTC_AlarmIRQHandler(RTC_HandleTypeDef *hrtc)
{
 802f410:	b570      	push	{r4, r5, r6, lr}
  uint32_t tmp = READ_REG(RTC->MISR) & READ_REG(hrtc->IsEnabled.RtcFeatures);
 802f412:	4d0b      	ldr	r5, [pc, #44]	; (802f440 <HAL_RTC_AlarmIRQHandler+0x30>)
 802f414:	6b03      	ldr	r3, [r0, #48]	; 0x30
 802f416:	6d6e      	ldr	r6, [r5, #84]	; 0x54
 802f418:	401e      	ands	r6, r3

  if ((tmp & RTC_MISR_ALRAMF) != 0U)
 802f41a:	07f2      	lsls	r2, r6, #31
{
 802f41c:	4604      	mov	r4, r0
  if ((tmp & RTC_MISR_ALRAMF) != 0U)
 802f41e:	d503      	bpl.n	802f428 <HAL_RTC_AlarmIRQHandler+0x18>
  {
    /* Clear the AlarmA interrupt pending bit */
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
 802f420:	2301      	movs	r3, #1
 802f422:	65eb      	str	r3, [r5, #92]	; 0x5c

#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
    /* Call Compare Match registered Callback */
    hrtc->AlarmAEventCallback(hrtc);
#else
    HAL_RTC_AlarmAEventCallback(hrtc);
 802f424:	f7fd fa24 	bl	802c870 <HAL_RTC_AlarmAEventCallback>
#endif
  }

  if ((tmp & RTC_MISR_ALRBMF) != 0U)
 802f428:	07b3      	lsls	r3, r6, #30
 802f42a:	d504      	bpl.n	802f436 <HAL_RTC_AlarmIRQHandler+0x26>
  {
    /* Clear the AlarmB interrupt pending bit */
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
 802f42c:	2302      	movs	r3, #2
 802f42e:	65eb      	str	r3, [r5, #92]	; 0x5c

#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
    /* Call Compare Match registered Callback */
    hrtc->AlarmBEventCallback(hrtc);
#else
    HAL_RTCEx_AlarmBEventCallback(hrtc);
 802f430:	4620      	mov	r0, r4
 802f432:	f000 f9c5 	bl	802f7c0 <HAL_RTCEx_AlarmBEventCallback>
#endif
  }

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 802f436:	2301      	movs	r3, #1
 802f438:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
}
 802f43c:	bd70      	pop	{r4, r5, r6, pc}
 802f43e:	bf00      	nop
 802f440:	40002800 	.word	0x40002800

0802f444 <HAL_RTC_WaitForSynchro>:
  *         correctly copied into the RTC_TR and RTC_DR shadow registers.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef *hrtc)
{
 802f444:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart;

  UNUSED(hrtc);
  /* Clear RSF flag */
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_RSF);
 802f446:	4c0a      	ldr	r4, [pc, #40]	; (802f470 <HAL_RTC_WaitForSynchro+0x2c>)
 802f448:	68e3      	ldr	r3, [r4, #12]
 802f44a:	f023 0320 	bic.w	r3, r3, #32
 802f44e:	60e3      	str	r3, [r4, #12]

  tickstart = HAL_GetTick();
 802f450:	f7fd f8f8 	bl	802c644 <HAL_GetTick>
 802f454:	4605      	mov	r5, r0

  /* Wait the registers to be synchronised */
  while (READ_BIT(RTC->ICSR, RTC_ICSR_RSF) == 0U)
 802f456:	68e3      	ldr	r3, [r4, #12]
 802f458:	069b      	lsls	r3, r3, #26
 802f45a:	d501      	bpl.n	802f460 <HAL_RTC_WaitForSynchro+0x1c>
    {
      return HAL_TIMEOUT;
    }
  }

  return HAL_OK;
 802f45c:	2000      	movs	r0, #0
}
 802f45e:	bd38      	pop	{r3, r4, r5, pc}
    if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 802f460:	f7fd f8f0 	bl	802c644 <HAL_GetTick>
 802f464:	1b40      	subs	r0, r0, r5
 802f466:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 802f46a:	d9f4      	bls.n	802f456 <HAL_RTC_WaitForSynchro+0x12>
      return HAL_TIMEOUT;
 802f46c:	2003      	movs	r0, #3
 802f46e:	e7f6      	b.n	802f45e <HAL_RTC_WaitForSynchro+0x1a>
 802f470:	40002800 	.word	0x40002800

0802f474 <RTC_EnterInitMode>:
  *         __HAL_RTC_WRITEPROTECTION_DISABLE() before calling this function.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef *hrtc)
{
 802f474:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;

  UNUSED(hrtc);
  /* Check if the Initialization mode is set */
  if (READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U)
 802f478:	4d11      	ldr	r5, [pc, #68]	; (802f4c0 <RTC_EnterInitMode+0x4c>)
 802f47a:	68ec      	ldr	r4, [r5, #12]
 802f47c:	f014 0440 	ands.w	r4, r4, #64	; 0x40
{
 802f480:	4607      	mov	r7, r0
  if (READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U)
 802f482:	d11a      	bne.n	802f4ba <RTC_EnterInitMode+0x46>
  {
    /* Set the Initialization mode */
    SET_BIT(RTC->ICSR, RTC_ICSR_INIT);
 802f484:	68eb      	ldr	r3, [r5, #12]
 802f486:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 802f48a:	60eb      	str	r3, [r5, #12]

    tickstart = HAL_GetTick();
 802f48c:	f7fd f8da 	bl	802c644 <HAL_GetTick>
    while ((READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U) && (status != HAL_TIMEOUT))
    {
      if ((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
      {
        status = HAL_TIMEOUT;
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 802f490:	f04f 0803 	mov.w	r8, #3
    tickstart = HAL_GetTick();
 802f494:	4606      	mov	r6, r0
    while ((READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U) && (status != HAL_TIMEOUT))
 802f496:	68eb      	ldr	r3, [r5, #12]
 802f498:	065b      	lsls	r3, r3, #25
 802f49a:	d401      	bmi.n	802f4a0 <RTC_EnterInitMode+0x2c>
 802f49c:	2c03      	cmp	r4, #3
 802f49e:	d102      	bne.n	802f4a6 <RTC_EnterInitMode+0x32>
      }
    }
  }

  return status;
}
 802f4a0:	4620      	mov	r0, r4
 802f4a2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if ((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
 802f4a6:	f7fd f8cd 	bl	802c644 <HAL_GetTick>
 802f4aa:	1b80      	subs	r0, r0, r6
 802f4ac:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 802f4b0:	bf84      	itt	hi
 802f4b2:	f887 802d 	strbhi.w	r8, [r7, #45]	; 0x2d
        status = HAL_TIMEOUT;
 802f4b6:	2403      	movhi	r4, #3
 802f4b8:	e7ed      	b.n	802f496 <RTC_EnterInitMode+0x22>
  HAL_StatusTypeDef status = HAL_OK;
 802f4ba:	2400      	movs	r4, #0
 802f4bc:	e7f0      	b.n	802f4a0 <RTC_EnterInitMode+0x2c>
 802f4be:	bf00      	nop
 802f4c0:	40002800 	.word	0x40002800

0802f4c4 <RTC_ExitInitMode>:
HAL_StatusTypeDef RTC_ExitInitMode(RTC_HandleTypeDef *hrtc)
{
  HAL_StatusTypeDef status = HAL_OK;

  /* Exit Initialization mode */
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_INIT);
 802f4c4:	4b10      	ldr	r3, [pc, #64]	; (802f508 <RTC_ExitInitMode+0x44>)
 802f4c6:	68da      	ldr	r2, [r3, #12]
 802f4c8:	f022 0280 	bic.w	r2, r2, #128	; 0x80
{
 802f4cc:	b510      	push	{r4, lr}
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_INIT);
 802f4ce:	60da      	str	r2, [r3, #12]

  /* If CR_BYPSHAD bit = 0, wait for synchro */
  if (READ_BIT(RTC->CR, RTC_CR_BYPSHAD) == 0U)
 802f4d0:	699a      	ldr	r2, [r3, #24]
 802f4d2:	0692      	lsls	r2, r2, #26
{
 802f4d4:	4604      	mov	r4, r0
  if (READ_BIT(RTC->CR, RTC_CR_BYPSHAD) == 0U)
 802f4d6:	d406      	bmi.n	802f4e6 <RTC_ExitInitMode+0x22>
  {
    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 802f4d8:	f7ff ffb4 	bl	802f444 <HAL_RTC_WaitForSynchro>
 802f4dc:	b110      	cbz	r0, 802f4e4 <RTC_ExitInitMode+0x20>
    {
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 802f4de:	2003      	movs	r0, #3
 802f4e0:	f884 002d 	strb.w	r0, [r4, #45]	; 0x2d
    /* Restore BYPSHAD bit */
    SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
  }

  return status;
}
 802f4e4:	bd10      	pop	{r4, pc}
    CLEAR_BIT(RTC->CR, RTC_CR_BYPSHAD);
 802f4e6:	699a      	ldr	r2, [r3, #24]
 802f4e8:	f022 0220 	bic.w	r2, r2, #32
 802f4ec:	619a      	str	r2, [r3, #24]
    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 802f4ee:	f7ff ffa9 	bl	802f444 <HAL_RTC_WaitForSynchro>
 802f4f2:	b110      	cbz	r0, 802f4fa <RTC_ExitInitMode+0x36>
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 802f4f4:	2003      	movs	r0, #3
 802f4f6:	f884 002d 	strb.w	r0, [r4, #45]	; 0x2d
    SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
 802f4fa:	4a03      	ldr	r2, [pc, #12]	; (802f508 <RTC_ExitInitMode+0x44>)
 802f4fc:	6993      	ldr	r3, [r2, #24]
 802f4fe:	f043 0320 	orr.w	r3, r3, #32
 802f502:	6193      	str	r3, [r2, #24]
  return status;
 802f504:	e7ee      	b.n	802f4e4 <RTC_ExitInitMode+0x20>
 802f506:	bf00      	nop
 802f508:	40002800 	.word	0x40002800

0802f50c <HAL_RTC_Init>:
{
 802f50c:	b538      	push	{r3, r4, r5, lr}
  if (hrtc != NULL)
 802f50e:	4604      	mov	r4, r0
 802f510:	2800      	cmp	r0, #0
 802f512:	d047      	beq.n	802f5a4 <HAL_RTC_Init+0x98>
    if (hrtc->State == HAL_RTC_STATE_RESET)
 802f514:	f890 302d 	ldrb.w	r3, [r0, #45]	; 0x2d
 802f518:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 802f51c:	b91b      	cbnz	r3, 802f526 <HAL_RTC_Init+0x1a>
      hrtc->Lock = HAL_UNLOCKED;
 802f51e:	f880 202c 	strb.w	r2, [r0, #44]	; 0x2c
      HAL_RTC_MspInit(hrtc);
 802f522:	f7fc ff03 	bl	802c32c <HAL_RTC_MspInit>
    __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f526:	4d20      	ldr	r5, [pc, #128]	; (802f5a8 <HAL_RTC_Init+0x9c>)
    hrtc->State = HAL_RTC_STATE_BUSY;
 802f528:	2302      	movs	r3, #2
 802f52a:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
    __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f52e:	23ca      	movs	r3, #202	; 0xca
 802f530:	626b      	str	r3, [r5, #36]	; 0x24
 802f532:	2353      	movs	r3, #83	; 0x53
 802f534:	626b      	str	r3, [r5, #36]	; 0x24
    status = RTC_EnterInitMode(hrtc);
 802f536:	4620      	mov	r0, r4
 802f538:	f7ff ff9c 	bl	802f474 <RTC_EnterInitMode>
    if (status == HAL_OK)
 802f53c:	bb70      	cbnz	r0, 802f59c <HAL_RTC_Init+0x90>
      CLEAR_BIT(RTC->CR, (RTC_CR_FMT | RTC_CR_POL | RTC_CR_OSEL | RTC_CR_TAMPOE));
 802f53e:	69ab      	ldr	r3, [r5, #24]
 802f540:	f023 638e 	bic.w	r3, r3, #74448896	; 0x4700000
 802f544:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 802f548:	61ab      	str	r3, [r5, #24]
      SET_BIT(RTC->CR, (hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity));
 802f54a:	6921      	ldr	r1, [r4, #16]
 802f54c:	6863      	ldr	r3, [r4, #4]
 802f54e:	69aa      	ldr	r2, [r5, #24]
 802f550:	430b      	orrs	r3, r1
 802f552:	4313      	orrs	r3, r2
 802f554:	69a2      	ldr	r2, [r4, #24]
 802f556:	4313      	orrs	r3, r2
 802f558:	61ab      	str	r3, [r5, #24]
      WRITE_REG(RTC->PRER, ((hrtc->Init.SynchPrediv) | (hrtc->Init.AsynchPrediv << RTC_PRER_PREDIV_A_Pos)));
 802f55a:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 802f55e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 802f562:	612b      	str	r3, [r5, #16]
      MODIFY_REG(RTC->ICSR, RTC_ICSR_BIN | RTC_ICSR_BCDU, hrtc->Init.BinMode | hrtc->Init.BinMixBcdU);
 802f564:	e9d4 3109 	ldrd	r3, r1, [r4, #36]	; 0x24
 802f568:	68ea      	ldr	r2, [r5, #12]
 802f56a:	430b      	orrs	r3, r1
 802f56c:	f422 52f8 	bic.w	r2, r2, #7936	; 0x1f00
 802f570:	4313      	orrs	r3, r2
 802f572:	60eb      	str	r3, [r5, #12]
      status = RTC_ExitInitMode(hrtc);
 802f574:	4620      	mov	r0, r4
 802f576:	f7ff ffa5 	bl	802f4c4 <RTC_ExitInitMode>
      if (status == HAL_OK)
 802f57a:	b978      	cbnz	r0, 802f59c <HAL_RTC_Init+0x90>
        MODIFY_REG(RTC->CR, \
 802f57c:	e9d4 1307 	ldrd	r1, r3, [r4, #28]
 802f580:	69aa      	ldr	r2, [r5, #24]
 802f582:	430b      	orrs	r3, r1
 802f584:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
 802f588:	4313      	orrs	r3, r2
 802f58a:	6962      	ldr	r2, [r4, #20]
 802f58c:	4313      	orrs	r3, r2
 802f58e:	61ab      	str	r3, [r5, #24]
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 802f590:	23ff      	movs	r3, #255	; 0xff
 802f592:	626b      	str	r3, [r5, #36]	; 0x24
      hrtc->State = HAL_RTC_STATE_READY;
 802f594:	2301      	movs	r3, #1
 802f596:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
}
 802f59a:	bd38      	pop	{r3, r4, r5, pc}
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 802f59c:	4b02      	ldr	r3, [pc, #8]	; (802f5a8 <HAL_RTC_Init+0x9c>)
 802f59e:	22ff      	movs	r2, #255	; 0xff
 802f5a0:	625a      	str	r2, [r3, #36]	; 0x24
    if (status == HAL_OK)
 802f5a2:	e7fa      	b.n	802f59a <HAL_RTC_Init+0x8e>
  HAL_StatusTypeDef status = HAL_ERROR;
 802f5a4:	2001      	movs	r0, #1
 802f5a6:	e7f8      	b.n	802f59a <HAL_RTC_Init+0x8e>
 802f5a8:	40002800 	.word	0x40002800

0802f5ac <RTC_ByteToBcd2>:
  * @param  Value Byte to be converted
  * @retval Converted byte
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0U;
 802f5ac:	2300      	movs	r3, #0
  uint8_t tmp_Value = Value;

  while (tmp_Value >= 10U)
 802f5ae:	2809      	cmp	r0, #9
 802f5b0:	d803      	bhi.n	802f5ba <RTC_ByteToBcd2+0xe>
  {
    bcdhigh++;
    tmp_Value -= 10U;
  }

  return ((uint8_t)(bcdhigh << 4U) | tmp_Value);
 802f5b2:	ea40 1003 	orr.w	r0, r0, r3, lsl #4
}
 802f5b6:	b2c0      	uxtb	r0, r0
 802f5b8:	4770      	bx	lr
    tmp_Value -= 10U;
 802f5ba:	380a      	subs	r0, #10
    bcdhigh++;
 802f5bc:	3301      	adds	r3, #1
    tmp_Value -= 10U;
 802f5be:	b2c0      	uxtb	r0, r0
 802f5c0:	e7f5      	b.n	802f5ae <RTC_ByteToBcd2+0x2>
	...

0802f5c4 <HAL_RTC_SetAlarm_IT>:
{
 802f5c4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  __HAL_LOCK(hrtc);
 802f5c8:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 802f5cc:	2b01      	cmp	r3, #1
{
 802f5ce:	4605      	mov	r5, r0
 802f5d0:	f04f 0002 	mov.w	r0, #2
  __HAL_LOCK(hrtc);
 802f5d4:	d067      	beq.n	802f6a6 <HAL_RTC_SetAlarm_IT+0xe2>
 802f5d6:	2301      	movs	r3, #1
 802f5d8:	f885 302c 	strb.w	r3, [r5, #44]	; 0x2c
  binaryMode = READ_BIT(RTC->ICSR, RTC_ICSR_BIN);
 802f5dc:	4b4c      	ldr	r3, [pc, #304]	; (802f710 <HAL_RTC_SetAlarm_IT+0x14c>)
  hrtc->State = HAL_RTC_STATE_BUSY;
 802f5de:	f885 002d 	strb.w	r0, [r5, #45]	; 0x2d
  binaryMode = READ_BIT(RTC->ICSR, RTC_ICSR_BIN);
 802f5e2:	68de      	ldr	r6, [r3, #12]
 802f5e4:	f406 7640 	and.w	r6, r6, #768	; 0x300
  if (binaryMode != RTC_BINARY_ONLY)
 802f5e8:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
 802f5ec:	d076      	beq.n	802f6dc <HAL_RTC_SetAlarm_IT+0x118>
    if (Format == RTC_FORMAT_BIN)
 802f5ee:	694c      	ldr	r4, [r1, #20]
 802f5f0:	7808      	ldrb	r0, [r1, #0]
 802f5f2:	f891 8001 	ldrb.w	r8, [r1, #1]
 802f5f6:	f891 a002 	ldrb.w	sl, [r1, #2]
 802f5fa:	f891 7024 	ldrb.w	r7, [r1, #36]	; 0x24
 802f5fe:	2a00      	cmp	r2, #0
 802f600:	d153      	bne.n	802f6aa <HAL_RTC_SetAlarm_IT+0xe6>
      if (READ_BIT(RTC->CR, RTC_CR_FMT) != 0U)
 802f602:	699a      	ldr	r2, [r3, #24]
 802f604:	f012 0240 	ands.w	r2, r2, #64	; 0x40
        sAlarm->AlarmTime.TimeFormat = 0x00U;
 802f608:	bf08      	it	eq
 802f60a:	70ca      	strbeq	r2, [r1, #3]
      tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 802f60c:	f7ff ffce 	bl	802f5ac <RTC_ByteToBcd2>
 802f610:	4681      	mov	r9, r0
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
 802f612:	4640      	mov	r0, r8
 802f614:	f7ff ffca 	bl	802f5ac <RTC_ByteToBcd2>
 802f618:	4680      	mov	r8, r0
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds) << RTC_ALRMAR_SU_Pos) | \
 802f61a:	4650      	mov	r0, sl
 802f61c:	f7ff ffc6 	bl	802f5ac <RTC_ByteToBcd2>
 802f620:	4682      	mov	sl, r0
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << RTC_ALRMAR_DU_Pos) | \
 802f622:	4638      	mov	r0, r7
 802f624:	f7ff ffc2 	bl	802f5ac <RTC_ByteToBcd2>
      tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 802f628:	6a0a      	ldr	r2, [r1, #32]
                ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
 802f62a:	78cb      	ldrb	r3, [r1, #3]
      tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 802f62c:	4314      	orrs	r4, r2
 802f62e:	ea44 5483 	orr.w	r4, r4, r3, lsl #22
 802f632:	ea44 030a 	orr.w	r3, r4, sl
 802f636:	ea43 4309 	orr.w	r3, r3, r9, lsl #16
 802f63a:	ea43 2308 	orr.w	r3, r3, r8, lsl #8
 802f63e:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f642:	4a33      	ldr	r2, [pc, #204]	; (802f710 <HAL_RTC_SetAlarm_IT+0x14c>)
 802f644:	20ca      	movs	r0, #202	; 0xca
 802f646:	6250      	str	r0, [r2, #36]	; 0x24
 802f648:	2053      	movs	r0, #83	; 0x53
 802f64a:	6250      	str	r0, [r2, #36]	; 0x24
  if (sAlarm->Alarm == RTC_ALARM_A)
 802f64c:	6a8c      	ldr	r4, [r1, #40]	; 0x28
 802f64e:	6988      	ldr	r0, [r1, #24]
 802f650:	f5b4 7f80 	cmp.w	r4, #256	; 0x100
    CLEAR_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 802f654:	6994      	ldr	r4, [r2, #24]
  if (sAlarm->Alarm == RTC_ALARM_A)
 802f656:	d143      	bne.n	802f6e0 <HAL_RTC_SetAlarm_IT+0x11c>
    CLEAR_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 802f658:	f424 5488 	bic.w	r4, r4, #4352	; 0x1100
 802f65c:	6194      	str	r4, [r2, #24]
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
 802f65e:	2401      	movs	r4, #1
 802f660:	65d4      	str	r4, [r2, #92]	; 0x5c
    if (binaryMode == RTC_BINARY_ONLY)
 802f662:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
      RTC->ALRMASSR = sAlarm->AlarmSubSecondMask | sAlarm->BinaryAutoClr;
 802f666:	bf0a      	itet	eq
 802f668:	69cb      	ldreq	r3, [r1, #28]
      WRITE_REG(RTC->ALRMAR, tmpreg);
 802f66a:	6413      	strne	r3, [r2, #64]	; 0x40
      RTC->ALRMASSR = sAlarm->AlarmSubSecondMask | sAlarm->BinaryAutoClr;
 802f66c:	4318      	orreq	r0, r3
      WRITE_REG(RTC->ALRMASSR, sAlarm->AlarmSubSecondMask);
 802f66e:	6450      	str	r0, [r2, #68]	; 0x44
    WRITE_REG(RTC->ALRABINR, sAlarm->AlarmTime.SubSeconds);
 802f670:	4b27      	ldr	r3, [pc, #156]	; (802f710 <HAL_RTC_SetAlarm_IT+0x14c>)
 802f672:	684a      	ldr	r2, [r1, #4]
 802f674:	671a      	str	r2, [r3, #112]	; 0x70
    SET_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRAMF);
 802f676:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 802f678:	f042 0201 	orr.w	r2, r2, #1
 802f67c:	632a      	str	r2, [r5, #48]	; 0x30
    SET_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 802f67e:	699a      	ldr	r2, [r3, #24]
 802f680:	f442 5288 	orr.w	r2, r2, #4352	; 0x1100
    SET_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 802f684:	619a      	str	r2, [r3, #24]
  __HAL_RTC_ALARM_EXTI_ENABLE_IT();
 802f686:	4a23      	ldr	r2, [pc, #140]	; (802f714 <HAL_RTC_SetAlarm_IT+0x150>)
 802f688:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
 802f68c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 802f690:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 802f694:	4b1e      	ldr	r3, [pc, #120]	; (802f710 <HAL_RTC_SetAlarm_IT+0x14c>)
 802f696:	22ff      	movs	r2, #255	; 0xff
 802f698:	625a      	str	r2, [r3, #36]	; 0x24
  __HAL_UNLOCK(hrtc);
 802f69a:	2000      	movs	r0, #0
  hrtc->State = HAL_RTC_STATE_READY;
 802f69c:	2301      	movs	r3, #1
 802f69e:	f885 302d 	strb.w	r3, [r5, #45]	; 0x2d
  __HAL_UNLOCK(hrtc);
 802f6a2:	f885 002c 	strb.w	r0, [r5, #44]	; 0x2c
}
 802f6a6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      if( sAlarm->AlarmMask != RTC_ALARMMASK_ALL )
 802f6aa:	f1b4 3f80 	cmp.w	r4, #2155905152	; 0x80808080
 802f6ae:	d007      	beq.n	802f6c0 <HAL_RTC_SetAlarm_IT+0xfc>
        if( sAlarm->AlarmMask != RTC_ALARMMASK_HOURS )
 802f6b0:	f5b4 0f00 	cmp.w	r4, #8388608	; 0x800000
 802f6b4:	d004      	beq.n	802f6c0 <HAL_RTC_SetAlarm_IT+0xfc>
          if (READ_BIT(RTC->CR, RTC_CR_FMT) != 0U)
 802f6b6:	699a      	ldr	r2, [r3, #24]
 802f6b8:	f012 0240 	ands.w	r2, r2, #64	; 0x40
            sAlarm->AlarmTime.TimeFormat = 0x00U;
 802f6bc:	bf08      	it	eq
 802f6be:	70ca      	strbeq	r2, [r1, #3]
      tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 802f6c0:	6a0a      	ldr	r2, [r1, #32]
 802f6c2:	4314      	orrs	r4, r2
 802f6c4:	ea44 040a 	orr.w	r4, r4, sl
 802f6c8:	ea44 4300 	orr.w	r3, r4, r0, lsl #16
                ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
 802f6cc:	78c8      	ldrb	r0, [r1, #3]
      tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 802f6ce:	ea43 2308 	orr.w	r3, r3, r8, lsl #8
 802f6d2:	ea43 5380 	orr.w	r3, r3, r0, lsl #22
 802f6d6:	ea43 6307 	orr.w	r3, r3, r7, lsl #24
 802f6da:	e7b2      	b.n	802f642 <HAL_RTC_SetAlarm_IT+0x7e>
  uint32_t tmpreg = 0;
 802f6dc:	2300      	movs	r3, #0
 802f6de:	e7b0      	b.n	802f642 <HAL_RTC_SetAlarm_IT+0x7e>
    CLEAR_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 802f6e0:	f424 5408 	bic.w	r4, r4, #8704	; 0x2200
 802f6e4:	6194      	str	r4, [r2, #24]
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
 802f6e6:	2402      	movs	r4, #2
 802f6e8:	65d4      	str	r4, [r2, #92]	; 0x5c
    if (binaryMode == RTC_BINARY_ONLY)
 802f6ea:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
      WRITE_REG(RTC->ALRMBSSR, sAlarm->AlarmSubSecondMask | sAlarm->BinaryAutoClr);
 802f6ee:	bf0a      	itet	eq
 802f6f0:	69cb      	ldreq	r3, [r1, #28]
      WRITE_REG(RTC->ALRMBR, tmpreg);
 802f6f2:	6493      	strne	r3, [r2, #72]	; 0x48
      WRITE_REG(RTC->ALRMBSSR, sAlarm->AlarmSubSecondMask | sAlarm->BinaryAutoClr);
 802f6f4:	4318      	orreq	r0, r3
      WRITE_REG(RTC->ALRMBSSR, sAlarm->AlarmSubSecondMask);
 802f6f6:	64d0      	str	r0, [r2, #76]	; 0x4c
    WRITE_REG(RTC->ALRBBINR, sAlarm->AlarmTime.SubSeconds);
 802f6f8:	4b05      	ldr	r3, [pc, #20]	; (802f710 <HAL_RTC_SetAlarm_IT+0x14c>)
 802f6fa:	684a      	ldr	r2, [r1, #4]
 802f6fc:	675a      	str	r2, [r3, #116]	; 0x74
    SET_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRBMF);
 802f6fe:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 802f700:	f042 0202 	orr.w	r2, r2, #2
 802f704:	632a      	str	r2, [r5, #48]	; 0x30
    SET_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 802f706:	699a      	ldr	r2, [r3, #24]
 802f708:	f442 5208 	orr.w	r2, r2, #8704	; 0x2200
 802f70c:	e7ba      	b.n	802f684 <HAL_RTC_SetAlarm_IT+0xc0>
 802f70e:	bf00      	nop
 802f710:	40002800 	.word	0x40002800
 802f714:	58000800 	.word	0x58000800

0802f718 <HAL_RTCEx_EnableBypassShadow>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_EnableBypassShadow(RTC_HandleTypeDef *hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);
 802f718:	f890 202c 	ldrb.w	r2, [r0, #44]	; 0x2c
 802f71c:	2a01      	cmp	r2, #1
{
 802f71e:	4603      	mov	r3, r0
 802f720:	f04f 0002 	mov.w	r0, #2
  __HAL_LOCK(hrtc);
 802f724:	d012      	beq.n	802f74c <HAL_RTCEx_EnableBypassShadow+0x34>

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f726:	4a0a      	ldr	r2, [pc, #40]	; (802f750 <HAL_RTCEx_EnableBypassShadow+0x38>)
  hrtc->State = HAL_RTC_STATE_BUSY;
 802f728:	f883 002d 	strb.w	r0, [r3, #45]	; 0x2d
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f72c:	21ca      	movs	r1, #202	; 0xca
 802f72e:	6251      	str	r1, [r2, #36]	; 0x24
 802f730:	2153      	movs	r1, #83	; 0x53
 802f732:	6251      	str	r1, [r2, #36]	; 0x24

  /* Set the BYPSHAD bit */
  SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
 802f734:	6991      	ldr	r1, [r2, #24]
 802f736:	f041 0120 	orr.w	r1, r1, #32
 802f73a:	6191      	str	r1, [r2, #24]

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 802f73c:	21ff      	movs	r1, #255	; 0xff
 802f73e:	6251      	str	r1, [r2, #36]	; 0x24

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 802f740:	2000      	movs	r0, #0
  hrtc->State = HAL_RTC_STATE_READY;
 802f742:	2201      	movs	r2, #1
 802f744:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
  __HAL_UNLOCK(hrtc);
 802f748:	f883 002c 	strb.w	r0, [r3, #44]	; 0x2c

  return HAL_OK;
}
 802f74c:	4770      	bx	lr
 802f74e:	bf00      	nop
 802f750:	40002800 	.word	0x40002800

0802f754 <HAL_RTCEx_SetSSRU_IT>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetSSRU_IT(RTC_HandleTypeDef *hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);
 802f754:	f890 202c 	ldrb.w	r2, [r0, #44]	; 0x2c
 802f758:	2a01      	cmp	r2, #1
{
 802f75a:	4603      	mov	r3, r0
 802f75c:	f04f 0002 	mov.w	r0, #2
  __HAL_LOCK(hrtc);
 802f760:	d019      	beq.n	802f796 <HAL_RTCEx_SetSSRU_IT+0x42>

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f762:	4a0d      	ldr	r2, [pc, #52]	; (802f798 <HAL_RTCEx_SetSSRU_IT+0x44>)
  hrtc->State = HAL_RTC_STATE_BUSY;
 802f764:	f883 002d 	strb.w	r0, [r3, #45]	; 0x2d
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f768:	21ca      	movs	r1, #202	; 0xca
 802f76a:	6251      	str	r1, [r2, #36]	; 0x24
 802f76c:	2153      	movs	r1, #83	; 0x53
 802f76e:	6251      	str	r1, [r2, #36]	; 0x24

  /* Enable IT SSRU */
  __HAL_RTC_SSRU_ENABLE_IT(hrtc, RTC_IT_SSRU);
 802f770:	6991      	ldr	r1, [r2, #24]

  /* RTC SSRU Interrupt Configuration: EXTI configuration */
  __HAL_RTC_SSRU_EXTI_ENABLE_IT();
 802f772:	480a      	ldr	r0, [pc, #40]	; (802f79c <HAL_RTCEx_SetSSRU_IT+0x48>)
  __HAL_RTC_SSRU_ENABLE_IT(hrtc, RTC_IT_SSRU);
 802f774:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 802f778:	6191      	str	r1, [r2, #24]
  __HAL_RTC_SSRU_EXTI_ENABLE_IT();
 802f77a:	f8d0 1080 	ldr.w	r1, [r0, #128]	; 0x80
 802f77e:	f441 2180 	orr.w	r1, r1, #262144	; 0x40000
 802f782:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 802f786:	21ff      	movs	r1, #255	; 0xff
 802f788:	6251      	str	r1, [r2, #36]	; 0x24

  hrtc->State = HAL_RTC_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 802f78a:	2000      	movs	r0, #0
  hrtc->State = HAL_RTC_STATE_READY;
 802f78c:	2201      	movs	r2, #1
 802f78e:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
  __HAL_UNLOCK(hrtc);
 802f792:	f883 002c 	strb.w	r0, [r3, #44]	; 0x2c

  return HAL_OK;
}
 802f796:	4770      	bx	lr
 802f798:	40002800 	.word	0x40002800
 802f79c:	58000800 	.word	0x58000800

0802f7a0 <HAL_RTCEx_SSRUIRQHandler>:
  * @param  hrtc RTC handle
  * @retval None
  */
void HAL_RTCEx_SSRUIRQHandler(RTC_HandleTypeDef *hrtc)
{
  if ((RTC->MISR & RTC_MISR_SSRUMF) != 0u)
 802f7a0:	4b06      	ldr	r3, [pc, #24]	; (802f7bc <HAL_RTCEx_SSRUIRQHandler+0x1c>)
 802f7a2:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 802f7a4:	0652      	lsls	r2, r2, #25
{
 802f7a6:	b510      	push	{r4, lr}
 802f7a8:	4604      	mov	r4, r0
  if ((RTC->MISR & RTC_MISR_SSRUMF) != 0u)
 802f7aa:	d503      	bpl.n	802f7b4 <HAL_RTCEx_SSRUIRQHandler+0x14>
  {
    /* Immediately clear flags */
    RTC->SCR = RTC_SCR_CSSRUF;
 802f7ac:	2240      	movs	r2, #64	; 0x40
 802f7ae:	65da      	str	r2, [r3, #92]	; 0x5c
    /* SSRU callback */
#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
    /* Call SSRUEvent registered Callback */
    hrtc->SSRUEventCallback(hrtc);
#else
    HAL_RTCEx_SSRUEventCallback(hrtc);
 802f7b0:	f7fd f860 	bl	802c874 <HAL_RTCEx_SSRUEventCallback>
#endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
  }

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 802f7b4:	2301      	movs	r3, #1
 802f7b6:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
}
 802f7ba:	bd10      	pop	{r4, pc}
 802f7bc:	40002800 	.word	0x40002800

0802f7c0 <HAL_RTCEx_AlarmBEventCallback>:
 802f7c0:	4770      	bx	lr

0802f7c2 <HAL_RTCEx_BKUPWrite>:
  UNUSED(hrtc);
  /* Check the parameters */
  assert_param(IS_RTC_BKP(BackupRegister));

  tmp = (uint32_t) & (TAMP->BKP0R);
  tmp += (BackupRegister * 4U);
 802f7c2:	0089      	lsls	r1, r1, #2
 802f7c4:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 802f7c8:	f501 4131 	add.w	r1, r1, #45312	; 0xb100

  /* Write the specified register */
  *(__IO uint32_t *)tmp = (uint32_t)Data;
 802f7cc:	600a      	str	r2, [r1, #0]
}
 802f7ce:	4770      	bx	lr

0802f7d0 <HAL_RTCEx_BKUPRead>:
  UNUSED(hrtc);
  /* Check the parameters */
  assert_param(IS_RTC_BKP(BackupRegister));

  tmp = (uint32_t) & (TAMP->BKP0R);
  tmp += (BackupRegister * 4U);
 802f7d0:	0089      	lsls	r1, r1, #2
 802f7d2:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 802f7d6:	f501 4131 	add.w	r1, r1, #45312	; 0xb100

  /* Read the specified register */
  return (*(__IO uint32_t *)tmp);
 802f7da:	6808      	ldr	r0, [r1, #0]
}
 802f7dc:	4770      	bx	lr
	...

0802f7e0 <LL_PWR_UnselectSUBGHZSPI_NSS>:
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 802f7e0:	4a03      	ldr	r2, [pc, #12]	; (802f7f0 <LL_PWR_UnselectSUBGHZSPI_NSS+0x10>)
 802f7e2:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 802f7e6:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 802f7ea:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 802f7ee:	4770      	bx	lr
 802f7f0:	58000400 	.word	0x58000400

0802f7f4 <LL_PWR_SelectSUBGHZSPI_NSS>:
  CLEAR_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 802f7f4:	4a03      	ldr	r2, [pc, #12]	; (802f804 <LL_PWR_SelectSUBGHZSPI_NSS+0x10>)
 802f7f6:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 802f7fa:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 802f7fe:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 802f802:	4770      	bx	lr
 802f804:	58000400 	.word	0x58000400

0802f808 <SUBGHZSPI_Init>:
{
  /* Check the parameters */
  assert_param(IS_SUBGHZ_ALL_INSTANCE(SUBGHZSPI));

  /* Disable SUBGHZSPI Peripheral */
  CLEAR_BIT(SUBGHZSPI->CR1, SPI_CR1_SPE);
 802f808:	4b07      	ldr	r3, [pc, #28]	; (802f828 <SUBGHZSPI_Init+0x20>)
 802f80a:	681a      	ldr	r2, [r3, #0]
 802f80c:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 802f810:	601a      	str	r2, [r3, #0]
   *       NSS management: Internal (Done with External bit inside PWR        *
   *  Communication speed: BaudratePrescaler                             *
   *            First bit: MSB                                                *
   *      CRC calculation: Disable                                            *
   *--------------------------------------------------------------------------*/
  WRITE_REG(SUBGHZSPI->CR1, (SPI_CR1_MSTR | SPI_CR1_SSI | BaudratePrescaler | SPI_CR1_SSM));
 802f812:	f440 7041 	orr.w	r0, r0, #772	; 0x304
   *            Data Size: 8bits                                              *
   *              TI Mode: Disable                                            *
   *            NSS Pulse: Disable                                            *
   *    Rx FIFO Threshold: 8bits                                              *
   *--------------------------------------------------------------------------*/
  WRITE_REG(SUBGHZSPI->CR2, (SPI_CR2_FRXTH |  SPI_CR2_DS_0 | SPI_CR2_DS_1 | SPI_CR2_DS_2));
 802f816:	f44f 52b8 	mov.w	r2, #5888	; 0x1700
  WRITE_REG(SUBGHZSPI->CR1, (SPI_CR1_MSTR | SPI_CR1_SSI | BaudratePrescaler | SPI_CR1_SSM));
 802f81a:	6018      	str	r0, [r3, #0]
  WRITE_REG(SUBGHZSPI->CR2, (SPI_CR2_FRXTH |  SPI_CR2_DS_0 | SPI_CR2_DS_1 | SPI_CR2_DS_2));
 802f81c:	605a      	str	r2, [r3, #4]

  /* Enable SUBGHZSPI Peripheral */
  SET_BIT(SUBGHZSPI->CR1, SPI_CR1_SPE);
 802f81e:	681a      	ldr	r2, [r3, #0]
 802f820:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 802f824:	601a      	str	r2, [r3, #0]
}
 802f826:	4770      	bx	lr
 802f828:	58010000 	.word	0x58010000

0802f82c <HAL_SUBGHZ_Init>:
{
 802f82c:	b513      	push	{r0, r1, r4, lr}
  if (hsubghz == NULL)
 802f82e:	4604      	mov	r4, r0
 802f830:	2800      	cmp	r0, #0
 802f832:	d042      	beq.n	802f8ba <HAL_SUBGHZ_Init+0x8e>
  if (hsubghz->State == HAL_SUBGHZ_STATE_RESET)
 802f834:	7983      	ldrb	r3, [r0, #6]
 802f836:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 802f83a:	b913      	cbnz	r3, 802f842 <HAL_SUBGHZ_Init+0x16>
    hsubghz->Lock = HAL_UNLOCKED;
 802f83c:	7142      	strb	r2, [r0, #5]
    HAL_SUBGHZ_MspInit(hsubghz);
 802f83e:	f7fc fe13 	bl	802c468 <HAL_SUBGHZ_MspInit>
  hsubghz->State = HAL_SUBGHZ_STATE_BUSY;
 802f842:	2302      	movs	r3, #2
 802f844:	71a3      	strb	r3, [r4, #6]
  CLEAR_BIT(RCC->CSR, RCC_CSR_RFRST);
 802f846:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802f84a:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 802f84e:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 802f852:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f856:	4a1a      	ldr	r2, [pc, #104]	; (802f8c0 <HAL_SUBGHZ_Init+0x94>)
 802f858:	6811      	ldr	r1, [r2, #0]
 802f85a:	221c      	movs	r2, #28
 802f85c:	434a      	muls	r2, r1
 802f85e:	0cd2      	lsrs	r2, r2, #19
 802f860:	2164      	movs	r1, #100	; 0x64
 802f862:	434a      	muls	r2, r1
 802f864:	9201      	str	r2, [sp, #4]
    if (count == 0U)
 802f866:	9a01      	ldr	r2, [sp, #4]
 802f868:	b9f2      	cbnz	r2, 802f8a8 <HAL_SUBGHZ_Init+0x7c>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 802f86a:	2101      	movs	r1, #1
 802f86c:	60a1      	str	r1, [r4, #8]
  LL_PWR_UnselectSUBGHZSPI_NSS();
 802f86e:	f7ff ffb7 	bl	802f7e0 <LL_PWR_UnselectSUBGHZSPI_NSS>
  SET_BIT(EXTI->IMR2, ExtiLine);
 802f872:	4a14      	ldr	r2, [pc, #80]	; (802f8c4 <HAL_SUBGHZ_Init+0x98>)
 802f874:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 802f878:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 802f87c:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  MODIFY_REG(PWR->CR3, PWR_CR3_EWRFBUSY, RadioBusyTrigger);
 802f880:	4b11      	ldr	r3, [pc, #68]	; (802f8c8 <HAL_SUBGHZ_Init+0x9c>)
 802f882:	689a      	ldr	r2, [r3, #8]
 802f884:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 802f888:	609a      	str	r2, [r3, #8]
  WRITE_REG(PWR->SCR, PWR_SCR_CWRFBUSYF);
 802f88a:	f44f 6200 	mov.w	r2, #2048	; 0x800
 802f88e:	619a      	str	r2, [r3, #24]
  if (status == HAL_OK)
 802f890:	b929      	cbnz	r1, 802f89e <HAL_SUBGHZ_Init+0x72>
    SUBGHZSPI_Init(hsubghz->Init.BaudratePrescaler);
 802f892:	6820      	ldr	r0, [r4, #0]
 802f894:	f7ff ffb8 	bl	802f808 <SUBGHZSPI_Init>
    hsubghz->DeepSleep = SUBGHZ_DEEP_SLEEP_ENABLE;
 802f898:	2301      	movs	r3, #1
 802f89a:	7123      	strb	r3, [r4, #4]
    hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_NONE;
 802f89c:	60a1      	str	r1, [r4, #8]
  hsubghz->State     = HAL_SUBGHZ_STATE_READY;
 802f89e:	2301      	movs	r3, #1
 802f8a0:	71a3      	strb	r3, [r4, #6]
}
 802f8a2:	4608      	mov	r0, r1
 802f8a4:	b002      	add	sp, #8
 802f8a6:	bd10      	pop	{r4, pc}
    count--;
 802f8a8:	9a01      	ldr	r2, [sp, #4]
 802f8aa:	3a01      	subs	r2, #1
 802f8ac:	9201      	str	r2, [sp, #4]
  return ((READ_BIT(RCC->CSR, RCC_CSR_RFRSTF) == (RCC_CSR_RFRSTF)) ? 1UL : 0UL);
 802f8ae:	f8d3 1094 	ldr.w	r1, [r3, #148]	; 0x94
 802f8b2:	f411 4180 	ands.w	r1, r1, #16384	; 0x4000
 802f8b6:	d1d6      	bne.n	802f866 <HAL_SUBGHZ_Init+0x3a>
 802f8b8:	e7d9      	b.n	802f86e <HAL_SUBGHZ_Init+0x42>
    return status;
 802f8ba:	2101      	movs	r1, #1
 802f8bc:	e7f1      	b.n	802f8a2 <HAL_SUBGHZ_Init+0x76>
 802f8be:	bf00      	nop
 802f8c0:	2000344c 	.word	0x2000344c
 802f8c4:	58000800 	.word	0x58000800
 802f8c8:	58000400 	.word	0x58000400

0802f8cc <SUBGHZSPI_Transmit>:
  * @param  Data  data to transmit
  * @retval HAL status
  */
HAL_StatusTypeDef SUBGHZSPI_Transmit(SUBGHZ_HandleTypeDef *hsubghz,
                                     uint8_t Data)
{
 802f8cc:	b513      	push	{r0, r1, r4, lr}
 802f8ce:	4602      	mov	r2, r0
  HAL_StatusTypeDef status = HAL_OK;
  __IO uint32_t count;

  /* Handle Tx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f8d0:	4817      	ldr	r0, [pc, #92]	; (802f930 <SUBGHZSPI_Transmit+0x64>)
 802f8d2:	6804      	ldr	r4, [r0, #0]
 802f8d4:	231c      	movs	r3, #28
 802f8d6:	4363      	muls	r3, r4
 802f8d8:	0cdb      	lsrs	r3, r3, #19
 802f8da:	2464      	movs	r4, #100	; 0x64
 802f8dc:	4363      	muls	r3, r4
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_TXE) != (SPI_SR_TXE));
 802f8de:	4c15      	ldr	r4, [pc, #84]	; (802f934 <SUBGHZSPI_Transmit+0x68>)
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f8e0:	9301      	str	r3, [sp, #4]
 802f8e2:	4603      	mov	r3, r0
    if (count == 0U)
 802f8e4:	9801      	ldr	r0, [sp, #4]
 802f8e6:	b998      	cbnz	r0, 802f910 <SUBGHZSPI_Transmit+0x44>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 802f8e8:	2001      	movs	r0, #1
 802f8ea:	6090      	str	r0, [r2, #8]

  /* Transmit Data*/
#if defined (__GNUC__)
  __IO uint8_t *spidr = ((__IO uint8_t *)&SUBGHZSPI->DR);
  *spidr = Data;
 802f8ec:	4c12      	ldr	r4, [pc, #72]	; (802f938 <SUBGHZSPI_Transmit+0x6c>)
 802f8ee:	7021      	strb	r1, [r4, #0]
  *((__IO uint8_t *)&SUBGHZSPI->DR) = Data;
#endif /* __GNUC__ */

  /* Handle Rx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f8f0:	6819      	ldr	r1, [r3, #0]
 802f8f2:	231c      	movs	r3, #28
 802f8f4:	434b      	muls	r3, r1
 802f8f6:	0cdb      	lsrs	r3, r3, #19
 802f8f8:	2164      	movs	r1, #100	; 0x64
 802f8fa:	434b      	muls	r3, r1
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_RXNE) != (SPI_SR_RXNE));
 802f8fc:	490d      	ldr	r1, [pc, #52]	; (802f934 <SUBGHZSPI_Transmit+0x68>)
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f8fe:	9301      	str	r3, [sp, #4]
    if (count == 0U)
 802f900:	9b01      	ldr	r3, [sp, #4]
 802f902:	b96b      	cbnz	r3, 802f920 <SUBGHZSPI_Transmit+0x54>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 802f904:	2001      	movs	r0, #1
 802f906:	6090      	str	r0, [r2, #8]

  /* Flush Rx data */
  READ_REG(SUBGHZSPI->DR);
 802f908:	4b0a      	ldr	r3, [pc, #40]	; (802f934 <SUBGHZSPI_Transmit+0x68>)
 802f90a:	68db      	ldr	r3, [r3, #12]

  return status;
}
 802f90c:	b002      	add	sp, #8
 802f90e:	bd10      	pop	{r4, pc}
    count--;
 802f910:	9801      	ldr	r0, [sp, #4]
 802f912:	3801      	subs	r0, #1
 802f914:	9001      	str	r0, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_TXE) != (SPI_SR_TXE));
 802f916:	68a0      	ldr	r0, [r4, #8]
 802f918:	0780      	lsls	r0, r0, #30
 802f91a:	d5e3      	bpl.n	802f8e4 <SUBGHZSPI_Transmit+0x18>
  HAL_StatusTypeDef status = HAL_OK;
 802f91c:	2000      	movs	r0, #0
 802f91e:	e7e5      	b.n	802f8ec <SUBGHZSPI_Transmit+0x20>
    count--;
 802f920:	9b01      	ldr	r3, [sp, #4]
 802f922:	3b01      	subs	r3, #1
 802f924:	9301      	str	r3, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_RXNE) != (SPI_SR_RXNE));
 802f926:	688b      	ldr	r3, [r1, #8]
 802f928:	07db      	lsls	r3, r3, #31
 802f92a:	d5e9      	bpl.n	802f900 <SUBGHZSPI_Transmit+0x34>
 802f92c:	e7ec      	b.n	802f908 <SUBGHZSPI_Transmit+0x3c>
 802f92e:	bf00      	nop
 802f930:	2000344c 	.word	0x2000344c
 802f934:	58010000 	.word	0x58010000
 802f938:	5801000c 	.word	0x5801000c

0802f93c <SUBGHZSPI_Receive>:
  * @param  pData  pointer on data to receive
  * @retval HAL status
  */
HAL_StatusTypeDef SUBGHZSPI_Receive(SUBGHZ_HandleTypeDef *hsubghz,
                                    uint8_t *pData)
{
 802f93c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 802f93e:	4602      	mov	r2, r0
  HAL_StatusTypeDef status = HAL_OK;
  __IO uint32_t count;

  /* Handle Tx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f940:	4818      	ldr	r0, [pc, #96]	; (802f9a4 <SUBGHZSPI_Receive+0x68>)
 802f942:	6804      	ldr	r4, [r0, #0]
 802f944:	231c      	movs	r3, #28
 802f946:	4363      	muls	r3, r4
 802f948:	0cdb      	lsrs	r3, r3, #19
 802f94a:	2464      	movs	r4, #100	; 0x64
 802f94c:	4363      	muls	r3, r4
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_TXE) != (SPI_SR_TXE));
 802f94e:	4c16      	ldr	r4, [pc, #88]	; (802f9a8 <SUBGHZSPI_Receive+0x6c>)
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f950:	9301      	str	r3, [sp, #4]
 802f952:	4603      	mov	r3, r0
    if (count == 0U)
 802f954:	9801      	ldr	r0, [sp, #4]
 802f956:	b9a8      	cbnz	r0, 802f984 <SUBGHZSPI_Receive+0x48>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 802f958:	2001      	movs	r0, #1
 802f95a:	6090      	str	r0, [r2, #8]

  /* Transmit Data*/
#if defined (__GNUC__)
  __IO uint8_t *spidr = ((__IO uint8_t *)&SUBGHZSPI->DR);
  *spidr = SUBGHZ_DUMMY_DATA;
 802f95c:	4c13      	ldr	r4, [pc, #76]	; (802f9ac <SUBGHZSPI_Receive+0x70>)
 802f95e:	25ff      	movs	r5, #255	; 0xff
 802f960:	7025      	strb	r5, [r4, #0]
  *((__IO uint8_t *)&SUBGHZSPI->DR) = SUBGHZ_DUMMY_DATA;
#endif /* __GNUC__ */

  /* Handle Rx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f962:	681c      	ldr	r4, [r3, #0]
 802f964:	231c      	movs	r3, #28
 802f966:	4363      	muls	r3, r4
 802f968:	0cdb      	lsrs	r3, r3, #19
 802f96a:	2464      	movs	r4, #100	; 0x64
 802f96c:	4363      	muls	r3, r4
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_RXNE) != (SPI_SR_RXNE));
 802f96e:	4c0e      	ldr	r4, [pc, #56]	; (802f9a8 <SUBGHZSPI_Receive+0x6c>)
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f970:	9301      	str	r3, [sp, #4]
    if (count == 0U)
 802f972:	9b01      	ldr	r3, [sp, #4]
 802f974:	b973      	cbnz	r3, 802f994 <SUBGHZSPI_Receive+0x58>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 802f976:	2001      	movs	r0, #1
 802f978:	6090      	str	r0, [r2, #8]

  /* Retrieve pData */
  *pData = (uint8_t)(READ_REG(SUBGHZSPI->DR));
 802f97a:	4b0b      	ldr	r3, [pc, #44]	; (802f9a8 <SUBGHZSPI_Receive+0x6c>)
 802f97c:	68db      	ldr	r3, [r3, #12]
 802f97e:	700b      	strb	r3, [r1, #0]

  return status;
}
 802f980:	b003      	add	sp, #12
 802f982:	bd30      	pop	{r4, r5, pc}
    count--;
 802f984:	9801      	ldr	r0, [sp, #4]
 802f986:	3801      	subs	r0, #1
 802f988:	9001      	str	r0, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_TXE) != (SPI_SR_TXE));
 802f98a:	68a0      	ldr	r0, [r4, #8]
 802f98c:	0780      	lsls	r0, r0, #30
 802f98e:	d5e1      	bpl.n	802f954 <SUBGHZSPI_Receive+0x18>
  HAL_StatusTypeDef status = HAL_OK;
 802f990:	2000      	movs	r0, #0
 802f992:	e7e3      	b.n	802f95c <SUBGHZSPI_Receive+0x20>
    count--;
 802f994:	9b01      	ldr	r3, [sp, #4]
 802f996:	3b01      	subs	r3, #1
 802f998:	9301      	str	r3, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_RXNE) != (SPI_SR_RXNE));
 802f99a:	68a3      	ldr	r3, [r4, #8]
 802f99c:	07db      	lsls	r3, r3, #31
 802f99e:	d5e8      	bpl.n	802f972 <SUBGHZSPI_Receive+0x36>
 802f9a0:	e7eb      	b.n	802f97a <SUBGHZSPI_Receive+0x3e>
 802f9a2:	bf00      	nop
 802f9a4:	2000344c 	.word	0x2000344c
 802f9a8:	58010000 	.word	0x58010000
 802f9ac:	5801000c 	.word	0x5801000c

0802f9b0 <SUBGHZ_WaitOnBusy>:
  HAL_StatusTypeDef status;
  __IO uint32_t count;
  uint32_t mask;

  status = HAL_OK;
  count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_RFBUSY_LOOP_TIME;
 802f9b0:	4b0f      	ldr	r3, [pc, #60]	; (802f9f0 <SUBGHZ_WaitOnBusy+0x40>)
{
 802f9b2:	b513      	push	{r0, r1, r4, lr}
  count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_RFBUSY_LOOP_TIME;
 802f9b4:	681a      	ldr	r2, [r3, #0]
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYMS) == (PWR_SR2_RFBUSYMS)) ? 1UL : 0UL);
 802f9b6:	4c0f      	ldr	r4, [pc, #60]	; (802f9f4 <SUBGHZ_WaitOnBusy+0x44>)
 802f9b8:	2318      	movs	r3, #24
 802f9ba:	4353      	muls	r3, r2
 802f9bc:	0d1b      	lsrs	r3, r3, #20
 802f9be:	2264      	movs	r2, #100	; 0x64
 802f9c0:	4353      	muls	r3, r2
{
 802f9c2:	4601      	mov	r1, r0
  count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_RFBUSY_LOOP_TIME;
 802f9c4:	9301      	str	r3, [sp, #4]
 802f9c6:	6962      	ldr	r2, [r4, #20]
  /* Wait until Busy signal is set */
  do
  {
    mask = LL_PWR_IsActiveFlag_RFBUSYMS();

    if (count == 0U)
 802f9c8:	9b01      	ldr	r3, [sp, #4]
 802f9ca:	f002 0204 	and.w	r2, r2, #4
 802f9ce:	b923      	cbnz	r3, 802f9da <SUBGHZ_WaitOnBusy+0x2a>
    {
      status  = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_RF_BUSY;
 802f9d0:	2302      	movs	r3, #2
 802f9d2:	608b      	str	r3, [r1, #8]
      status  = HAL_ERROR;
 802f9d4:	2001      	movs	r0, #1
    }
    count--;
  } while ((LL_PWR_IsActiveFlag_RFBUSYS()& mask) == 1UL);

  return status;
}
 802f9d6:	b002      	add	sp, #8
 802f9d8:	bd10      	pop	{r4, pc}
    count--;
 802f9da:	9b01      	ldr	r3, [sp, #4]
 802f9dc:	3b01      	subs	r3, #1
 802f9de:	9301      	str	r3, [sp, #4]
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYS) == (PWR_SR2_RFBUSYS)) ? 1UL : 0UL);
 802f9e0:	6960      	ldr	r0, [r4, #20]
 802f9e2:	f010 0002 	ands.w	r0, r0, #2
 802f9e6:	d0f6      	beq.n	802f9d6 <SUBGHZ_WaitOnBusy+0x26>
  } while ((LL_PWR_IsActiveFlag_RFBUSYS()& mask) == 1UL);
 802f9e8:	2a00      	cmp	r2, #0
 802f9ea:	d1ec      	bne.n	802f9c6 <SUBGHZ_WaitOnBusy+0x16>
  status = HAL_OK;
 802f9ec:	4610      	mov	r0, r2
 802f9ee:	e7f2      	b.n	802f9d6 <SUBGHZ_WaitOnBusy+0x26>
 802f9f0:	2000344c 	.word	0x2000344c
 802f9f4:	58000400 	.word	0x58000400

0802f9f8 <SUBGHZ_CheckDeviceReady>:
{
 802f9f8:	b507      	push	{r0, r1, r2, lr}
  if (hsubghz->DeepSleep == SUBGHZ_DEEP_SLEEP_ENABLE)
 802f9fa:	7903      	ldrb	r3, [r0, #4]
 802f9fc:	2b01      	cmp	r3, #1
 802f9fe:	d10f      	bne.n	802fa20 <SUBGHZ_CheckDeviceReady+0x28>
    count  = SUBGHZ_NSS_LOOP_TIME;
 802fa00:	4b0a      	ldr	r3, [pc, #40]	; (802fa2c <SUBGHZ_CheckDeviceReady+0x34>)
 802fa02:	681a      	ldr	r2, [r3, #0]
 802fa04:	2318      	movs	r3, #24
 802fa06:	4353      	muls	r3, r2
 802fa08:	0c1b      	lsrs	r3, r3, #16
 802fa0a:	9301      	str	r3, [sp, #4]
    LL_PWR_SelectSUBGHZSPI_NSS();
 802fa0c:	f7ff fef2 	bl	802f7f4 <LL_PWR_SelectSUBGHZSPI_NSS>
      count--;
 802fa10:	9b01      	ldr	r3, [sp, #4]
 802fa12:	3b01      	subs	r3, #1
 802fa14:	9301      	str	r3, [sp, #4]
    } while (count != 0UL);
 802fa16:	9b01      	ldr	r3, [sp, #4]
 802fa18:	2b00      	cmp	r3, #0
 802fa1a:	d1f9      	bne.n	802fa10 <SUBGHZ_CheckDeviceReady+0x18>
    LL_PWR_UnselectSUBGHZSPI_NSS();
 802fa1c:	f7ff fee0 	bl	802f7e0 <LL_PWR_UnselectSUBGHZSPI_NSS>
}
 802fa20:	b003      	add	sp, #12
 802fa22:	f85d eb04 	ldr.w	lr, [sp], #4
  return (SUBGHZ_WaitOnBusy(hsubghz));
 802fa26:	f7ff bfc3 	b.w	802f9b0 <SUBGHZ_WaitOnBusy>
 802fa2a:	bf00      	nop
 802fa2c:	2000344c 	.word	0x2000344c

0802fa30 <HAL_SUBGHZ_WriteRegisters>:
{
 802fa30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802fa32:	461e      	mov	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fa34:	7983      	ldrb	r3, [r0, #6]
 802fa36:	2b01      	cmp	r3, #1
{
 802fa38:	4615      	mov	r5, r2
 802fa3a:	4604      	mov	r4, r0
 802fa3c:	460f      	mov	r7, r1
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fa3e:	b2da      	uxtb	r2, r3
 802fa40:	d12d      	bne.n	802fa9e <HAL_SUBGHZ_WriteRegisters+0x6e>
    __HAL_LOCK(hsubghz);
 802fa42:	7943      	ldrb	r3, [r0, #5]
 802fa44:	2b01      	cmp	r3, #1
 802fa46:	d02a      	beq.n	802fa9e <HAL_SUBGHZ_WriteRegisters+0x6e>
    hsubghz->State = HAL_SUBGHZ_STATE_BUSY;
 802fa48:	2302      	movs	r3, #2
    __HAL_LOCK(hsubghz);
 802fa4a:	7142      	strb	r2, [r0, #5]
    hsubghz->State = HAL_SUBGHZ_STATE_BUSY;
 802fa4c:	7183      	strb	r3, [r0, #6]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 802fa4e:	f7ff ffd3 	bl	802f9f8 <SUBGHZ_CheckDeviceReady>
    LL_PWR_SelectSUBGHZSPI_NSS();
 802fa52:	f7ff fecf 	bl	802f7f4 <LL_PWR_SelectSUBGHZSPI_NSS>
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_WRITE_REGISTER);
 802fa56:	210d      	movs	r1, #13
 802fa58:	4620      	mov	r0, r4
 802fa5a:	f7ff ff37 	bl	802f8cc <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)((Address & 0xFF00U) >> 8U));
 802fa5e:	0a39      	lsrs	r1, r7, #8
 802fa60:	4620      	mov	r0, r4
 802fa62:	f7ff ff33 	bl	802f8cc <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)(Address & 0x00FFU));
 802fa66:	b2f9      	uxtb	r1, r7
 802fa68:	4620      	mov	r0, r4
 802fa6a:	f7ff ff2f 	bl	802f8cc <SUBGHZSPI_Transmit>
HAL_StatusTypeDef HAL_SUBGHZ_WriteRegisters(SUBGHZ_HandleTypeDef *hsubghz,
 802fa6e:	442e      	add	r6, r5
    for (uint16_t i = 0U; i < Size; i++)
 802fa70:	42b5      	cmp	r5, r6
 802fa72:	d10e      	bne.n	802fa92 <HAL_SUBGHZ_WriteRegisters+0x62>
    LL_PWR_UnselectSUBGHZSPI_NSS();
 802fa74:	f7ff feb4 	bl	802f7e0 <LL_PWR_UnselectSUBGHZSPI_NSS>
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 802fa78:	4620      	mov	r0, r4
 802fa7a:	f7ff ff99 	bl	802f9b0 <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 802fa7e:	68a0      	ldr	r0, [r4, #8]
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fa80:	2301      	movs	r3, #1
      status = HAL_ERROR;
 802fa82:	3800      	subs	r0, #0
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fa84:	71a3      	strb	r3, [r4, #6]
    __HAL_UNLOCK(hsubghz);
 802fa86:	f04f 0300 	mov.w	r3, #0
      status = HAL_ERROR;
 802fa8a:	bf18      	it	ne
 802fa8c:	2001      	movne	r0, #1
    __HAL_UNLOCK(hsubghz);
 802fa8e:	7163      	strb	r3, [r4, #5]
}
 802fa90:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void)SUBGHZSPI_Transmit(hsubghz, pBuffer[i]);
 802fa92:	f815 1b01 	ldrb.w	r1, [r5], #1
 802fa96:	4620      	mov	r0, r4
 802fa98:	f7ff ff18 	bl	802f8cc <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 802fa9c:	e7e8      	b.n	802fa70 <HAL_SUBGHZ_WriteRegisters+0x40>
    return HAL_BUSY;
 802fa9e:	2002      	movs	r0, #2
 802faa0:	e7f6      	b.n	802fa90 <HAL_SUBGHZ_WriteRegisters+0x60>

0802faa2 <HAL_SUBGHZ_ReadRegisters>:
{
 802faa2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802faa4:	461e      	mov	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802faa6:	7983      	ldrb	r3, [r0, #6]
 802faa8:	2b01      	cmp	r3, #1
{
 802faaa:	4615      	mov	r5, r2
 802faac:	4604      	mov	r4, r0
 802faae:	460f      	mov	r7, r1
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fab0:	b2da      	uxtb	r2, r3
 802fab2:	d12f      	bne.n	802fb14 <HAL_SUBGHZ_ReadRegisters+0x72>
    __HAL_LOCK(hsubghz);
 802fab4:	7943      	ldrb	r3, [r0, #5]
 802fab6:	2b01      	cmp	r3, #1
 802fab8:	d02c      	beq.n	802fb14 <HAL_SUBGHZ_ReadRegisters+0x72>
 802faba:	7142      	strb	r2, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 802fabc:	f7ff ff9c 	bl	802f9f8 <SUBGHZ_CheckDeviceReady>
    LL_PWR_SelectSUBGHZSPI_NSS();
 802fac0:	f7ff fe98 	bl	802f7f4 <LL_PWR_SelectSUBGHZSPI_NSS>
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_READ_REGISTER);
 802fac4:	211d      	movs	r1, #29
 802fac6:	4620      	mov	r0, r4
 802fac8:	f7ff ff00 	bl	802f8cc <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)((Address & 0xFF00U) >> 8U));
 802facc:	0a39      	lsrs	r1, r7, #8
 802face:	4620      	mov	r0, r4
 802fad0:	f7ff fefc 	bl	802f8cc <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)(Address & 0x00FFU));
 802fad4:	b2f9      	uxtb	r1, r7
 802fad6:	4620      	mov	r0, r4
 802fad8:	f7ff fef8 	bl	802f8cc <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, 0U);
 802fadc:	2100      	movs	r1, #0
 802fade:	4620      	mov	r0, r4
 802fae0:	f7ff fef4 	bl	802f8cc <SUBGHZSPI_Transmit>
HAL_StatusTypeDef HAL_SUBGHZ_ReadRegisters(SUBGHZ_HandleTypeDef *hsubghz,
 802fae4:	442e      	add	r6, r5
    for (uint16_t i = 0U; i < Size; i++)
 802fae6:	42b5      	cmp	r5, r6
 802fae8:	d10e      	bne.n	802fb08 <HAL_SUBGHZ_ReadRegisters+0x66>
    LL_PWR_UnselectSUBGHZSPI_NSS();
 802faea:	f7ff fe79 	bl	802f7e0 <LL_PWR_UnselectSUBGHZSPI_NSS>
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 802faee:	4620      	mov	r0, r4
 802faf0:	f7ff ff5e 	bl	802f9b0 <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 802faf4:	68a0      	ldr	r0, [r4, #8]
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802faf6:	2301      	movs	r3, #1
      status = HAL_ERROR;
 802faf8:	3800      	subs	r0, #0
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fafa:	71a3      	strb	r3, [r4, #6]
    __HAL_UNLOCK(hsubghz);
 802fafc:	f04f 0300 	mov.w	r3, #0
      status = HAL_ERROR;
 802fb00:	bf18      	it	ne
 802fb02:	2001      	movne	r0, #1
    __HAL_UNLOCK(hsubghz);
 802fb04:	7163      	strb	r3, [r4, #5]
}
 802fb06:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void)SUBGHZSPI_Receive(hsubghz, (pData));
 802fb08:	4629      	mov	r1, r5
 802fb0a:	4620      	mov	r0, r4
 802fb0c:	f7ff ff16 	bl	802f93c <SUBGHZSPI_Receive>
      pData++;
 802fb10:	3501      	adds	r5, #1
    for (uint16_t i = 0U; i < Size; i++)
 802fb12:	e7e8      	b.n	802fae6 <HAL_SUBGHZ_ReadRegisters+0x44>
    return HAL_BUSY;
 802fb14:	2002      	movs	r0, #2
 802fb16:	e7f6      	b.n	802fb06 <HAL_SUBGHZ_ReadRegisters+0x64>

0802fb18 <HAL_SUBGHZ_ExecSetCmd>:
{
 802fb18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802fb1a:	461f      	mov	r7, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fb1c:	7983      	ldrb	r3, [r0, #6]
 802fb1e:	2b01      	cmp	r3, #1
{
 802fb20:	4615      	mov	r5, r2
 802fb22:	4604      	mov	r4, r0
 802fb24:	460e      	mov	r6, r1
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fb26:	b2da      	uxtb	r2, r3
 802fb28:	d12c      	bne.n	802fb84 <HAL_SUBGHZ_ExecSetCmd+0x6c>
    __HAL_LOCK(hsubghz);
 802fb2a:	7943      	ldrb	r3, [r0, #5]
 802fb2c:	2b01      	cmp	r3, #1
 802fb2e:	d029      	beq.n	802fb84 <HAL_SUBGHZ_ExecSetCmd+0x6c>
 802fb30:	7142      	strb	r2, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 802fb32:	f7ff ff61 	bl	802f9f8 <SUBGHZ_CheckDeviceReady>
    if ((Command == RADIO_SET_SLEEP) || (Command == RADIO_SET_RXDUTYCYCLE))
 802fb36:	f006 03ef 	and.w	r3, r6, #239	; 0xef
 802fb3a:	f1a3 0284 	sub.w	r2, r3, #132	; 0x84
 802fb3e:	4253      	negs	r3, r2
 802fb40:	4153      	adcs	r3, r2
 802fb42:	7123      	strb	r3, [r4, #4]
    LL_PWR_SelectSUBGHZSPI_NSS();
 802fb44:	f7ff fe56 	bl	802f7f4 <LL_PWR_SelectSUBGHZSPI_NSS>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)Command);
 802fb48:	4631      	mov	r1, r6
 802fb4a:	4620      	mov	r0, r4
 802fb4c:	f7ff febe 	bl	802f8cc <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 802fb50:	442f      	add	r7, r5
 802fb52:	42af      	cmp	r7, r5
 802fb54:	d110      	bne.n	802fb78 <HAL_SUBGHZ_ExecSetCmd+0x60>
    LL_PWR_UnselectSUBGHZSPI_NSS();
 802fb56:	f7ff fe43 	bl	802f7e0 <LL_PWR_UnselectSUBGHZSPI_NSS>
    if (Command != RADIO_SET_SLEEP)
 802fb5a:	2e84      	cmp	r6, #132	; 0x84
 802fb5c:	d002      	beq.n	802fb64 <HAL_SUBGHZ_ExecSetCmd+0x4c>
      (void)SUBGHZ_WaitOnBusy(hsubghz);
 802fb5e:	4620      	mov	r0, r4
 802fb60:	f7ff ff26 	bl	802f9b0 <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 802fb64:	68a0      	ldr	r0, [r4, #8]
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fb66:	2301      	movs	r3, #1
      status = HAL_ERROR;
 802fb68:	3800      	subs	r0, #0
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fb6a:	71a3      	strb	r3, [r4, #6]
    __HAL_UNLOCK(hsubghz);
 802fb6c:	f04f 0300 	mov.w	r3, #0
      status = HAL_ERROR;
 802fb70:	bf18      	it	ne
 802fb72:	2001      	movne	r0, #1
    __HAL_UNLOCK(hsubghz);
 802fb74:	7163      	strb	r3, [r4, #5]
}
 802fb76:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void)SUBGHZSPI_Transmit(hsubghz, pBuffer[i]);
 802fb78:	f815 1b01 	ldrb.w	r1, [r5], #1
 802fb7c:	4620      	mov	r0, r4
 802fb7e:	f7ff fea5 	bl	802f8cc <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 802fb82:	e7e6      	b.n	802fb52 <HAL_SUBGHZ_ExecSetCmd+0x3a>
    return HAL_BUSY;
 802fb84:	2002      	movs	r0, #2
 802fb86:	e7f6      	b.n	802fb76 <HAL_SUBGHZ_ExecSetCmd+0x5e>

0802fb88 <HAL_SUBGHZ_WriteBuffer>:
{
 802fb88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802fb8a:	461e      	mov	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fb8c:	7983      	ldrb	r3, [r0, #6]
 802fb8e:	2b01      	cmp	r3, #1
{
 802fb90:	4615      	mov	r5, r2
 802fb92:	4604      	mov	r4, r0
 802fb94:	460f      	mov	r7, r1
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fb96:	b2da      	uxtb	r2, r3
 802fb98:	d127      	bne.n	802fbea <HAL_SUBGHZ_WriteBuffer+0x62>
    __HAL_LOCK(hsubghz);
 802fb9a:	7943      	ldrb	r3, [r0, #5]
 802fb9c:	2b01      	cmp	r3, #1
 802fb9e:	d024      	beq.n	802fbea <HAL_SUBGHZ_WriteBuffer+0x62>
 802fba0:	7142      	strb	r2, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 802fba2:	f7ff ff29 	bl	802f9f8 <SUBGHZ_CheckDeviceReady>
    LL_PWR_SelectSUBGHZSPI_NSS();
 802fba6:	f7ff fe25 	bl	802f7f4 <LL_PWR_SelectSUBGHZSPI_NSS>
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_WRITE_BUFFER);
 802fbaa:	210e      	movs	r1, #14
 802fbac:	4620      	mov	r0, r4
 802fbae:	f7ff fe8d 	bl	802f8cc <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, Offset);
 802fbb2:	4639      	mov	r1, r7
 802fbb4:	4620      	mov	r0, r4
 802fbb6:	f7ff fe89 	bl	802f8cc <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 802fbba:	442e      	add	r6, r5
 802fbbc:	42b5      	cmp	r5, r6
 802fbbe:	d10e      	bne.n	802fbde <HAL_SUBGHZ_WriteBuffer+0x56>
    LL_PWR_UnselectSUBGHZSPI_NSS();
 802fbc0:	f7ff fe0e 	bl	802f7e0 <LL_PWR_UnselectSUBGHZSPI_NSS>
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 802fbc4:	4620      	mov	r0, r4
 802fbc6:	f7ff fef3 	bl	802f9b0 <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 802fbca:	68a0      	ldr	r0, [r4, #8]
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fbcc:	2301      	movs	r3, #1
      status = HAL_ERROR;
 802fbce:	3800      	subs	r0, #0
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fbd0:	71a3      	strb	r3, [r4, #6]
    __HAL_UNLOCK(hsubghz);
 802fbd2:	f04f 0300 	mov.w	r3, #0
      status = HAL_ERROR;
 802fbd6:	bf18      	it	ne
 802fbd8:	2001      	movne	r0, #1
    __HAL_UNLOCK(hsubghz);
 802fbda:	7163      	strb	r3, [r4, #5]
}
 802fbdc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void)SUBGHZSPI_Transmit(hsubghz, pBuffer[i]);
 802fbde:	f815 1b01 	ldrb.w	r1, [r5], #1
 802fbe2:	4620      	mov	r0, r4
 802fbe4:	f7ff fe72 	bl	802f8cc <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 802fbe8:	e7e8      	b.n	802fbbc <HAL_SUBGHZ_WriteBuffer+0x34>
    return HAL_BUSY;
 802fbea:	2002      	movs	r0, #2
 802fbec:	e7f6      	b.n	802fbdc <HAL_SUBGHZ_WriteBuffer+0x54>

0802fbee <HAL_SUBGHZ_ReadBuffer>:
{
 802fbee:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802fbf0:	461e      	mov	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fbf2:	7983      	ldrb	r3, [r0, #6]
 802fbf4:	2b01      	cmp	r3, #1
{
 802fbf6:	4615      	mov	r5, r2
 802fbf8:	4604      	mov	r4, r0
 802fbfa:	460f      	mov	r7, r1
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fbfc:	b2da      	uxtb	r2, r3
 802fbfe:	d12b      	bne.n	802fc58 <HAL_SUBGHZ_ReadBuffer+0x6a>
    __HAL_LOCK(hsubghz);
 802fc00:	7943      	ldrb	r3, [r0, #5]
 802fc02:	2b01      	cmp	r3, #1
 802fc04:	d028      	beq.n	802fc58 <HAL_SUBGHZ_ReadBuffer+0x6a>
 802fc06:	7142      	strb	r2, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 802fc08:	f7ff fef6 	bl	802f9f8 <SUBGHZ_CheckDeviceReady>
    LL_PWR_SelectSUBGHZSPI_NSS();
 802fc0c:	f7ff fdf2 	bl	802f7f4 <LL_PWR_SelectSUBGHZSPI_NSS>
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_READ_BUFFER);
 802fc10:	211e      	movs	r1, #30
 802fc12:	4620      	mov	r0, r4
 802fc14:	f7ff fe5a 	bl	802f8cc <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, Offset);
 802fc18:	4639      	mov	r1, r7
 802fc1a:	4620      	mov	r0, r4
 802fc1c:	f7ff fe56 	bl	802f8cc <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, 0x00U);
 802fc20:	2100      	movs	r1, #0
 802fc22:	4620      	mov	r0, r4
 802fc24:	f7ff fe52 	bl	802f8cc <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 802fc28:	442e      	add	r6, r5
 802fc2a:	42b5      	cmp	r5, r6
 802fc2c:	d10e      	bne.n	802fc4c <HAL_SUBGHZ_ReadBuffer+0x5e>
    LL_PWR_UnselectSUBGHZSPI_NSS();
 802fc2e:	f7ff fdd7 	bl	802f7e0 <LL_PWR_UnselectSUBGHZSPI_NSS>
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 802fc32:	4620      	mov	r0, r4
 802fc34:	f7ff febc 	bl	802f9b0 <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 802fc38:	68a0      	ldr	r0, [r4, #8]
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fc3a:	2301      	movs	r3, #1
      status = HAL_ERROR;
 802fc3c:	3800      	subs	r0, #0
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fc3e:	71a3      	strb	r3, [r4, #6]
    __HAL_UNLOCK(hsubghz);
 802fc40:	f04f 0300 	mov.w	r3, #0
      status = HAL_ERROR;
 802fc44:	bf18      	it	ne
 802fc46:	2001      	movne	r0, #1
    __HAL_UNLOCK(hsubghz);
 802fc48:	7163      	strb	r3, [r4, #5]
}
 802fc4a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void)SUBGHZSPI_Receive(hsubghz, (pData));
 802fc4c:	4629      	mov	r1, r5
 802fc4e:	4620      	mov	r0, r4
 802fc50:	f7ff fe74 	bl	802f93c <SUBGHZSPI_Receive>
      pData++;
 802fc54:	3501      	adds	r5, #1
    for (uint16_t i = 0U; i < Size; i++)
 802fc56:	e7e8      	b.n	802fc2a <HAL_SUBGHZ_ReadBuffer+0x3c>
    return HAL_BUSY;
 802fc58:	2002      	movs	r0, #2
 802fc5a:	e7f6      	b.n	802fc4a <HAL_SUBGHZ_ReadBuffer+0x5c>

0802fc5c <HAL_SUBGHZ_ExecGetCmd>:
{
 802fc5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802fc5e:	461e      	mov	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fc60:	7983      	ldrb	r3, [r0, #6]
 802fc62:	2b01      	cmp	r3, #1
{
 802fc64:	4615      	mov	r5, r2
 802fc66:	4604      	mov	r4, r0
 802fc68:	460f      	mov	r7, r1
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fc6a:	b2da      	uxtb	r2, r3
 802fc6c:	d127      	bne.n	802fcbe <HAL_SUBGHZ_ExecGetCmd+0x62>
    __HAL_LOCK(hsubghz);
 802fc6e:	7943      	ldrb	r3, [r0, #5]
 802fc70:	2b01      	cmp	r3, #1
 802fc72:	d024      	beq.n	802fcbe <HAL_SUBGHZ_ExecGetCmd+0x62>
 802fc74:	7142      	strb	r2, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 802fc76:	f7ff febf 	bl	802f9f8 <SUBGHZ_CheckDeviceReady>
    LL_PWR_SelectSUBGHZSPI_NSS();
 802fc7a:	f7ff fdbb 	bl	802f7f4 <LL_PWR_SelectSUBGHZSPI_NSS>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)Command);
 802fc7e:	4639      	mov	r1, r7
 802fc80:	4620      	mov	r0, r4
 802fc82:	f7ff fe23 	bl	802f8cc <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, 0x00U);
 802fc86:	2100      	movs	r1, #0
 802fc88:	4620      	mov	r0, r4
 802fc8a:	f7ff fe1f 	bl	802f8cc <SUBGHZSPI_Transmit>
HAL_StatusTypeDef HAL_SUBGHZ_ReadRegisters(SUBGHZ_HandleTypeDef *hsubghz,
 802fc8e:	442e      	add	r6, r5
    for (uint16_t i = 0U; i < Size; i++)
 802fc90:	42b5      	cmp	r5, r6
 802fc92:	d10e      	bne.n	802fcb2 <HAL_SUBGHZ_ExecGetCmd+0x56>
    LL_PWR_UnselectSUBGHZSPI_NSS();
 802fc94:	f7ff fda4 	bl	802f7e0 <LL_PWR_UnselectSUBGHZSPI_NSS>
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 802fc98:	4620      	mov	r0, r4
 802fc9a:	f7ff fe89 	bl	802f9b0 <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 802fc9e:	68a0      	ldr	r0, [r4, #8]
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fca0:	2301      	movs	r3, #1
      status = HAL_ERROR;
 802fca2:	3800      	subs	r0, #0
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fca4:	71a3      	strb	r3, [r4, #6]
    __HAL_UNLOCK(hsubghz);
 802fca6:	f04f 0300 	mov.w	r3, #0
      status = HAL_ERROR;
 802fcaa:	bf18      	it	ne
 802fcac:	2001      	movne	r0, #1
    __HAL_UNLOCK(hsubghz);
 802fcae:	7163      	strb	r3, [r4, #5]
}
 802fcb0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void)SUBGHZSPI_Receive(hsubghz, (pData));
 802fcb2:	4629      	mov	r1, r5
 802fcb4:	4620      	mov	r0, r4
 802fcb6:	f7ff fe41 	bl	802f93c <SUBGHZSPI_Receive>
      pData++;
 802fcba:	3501      	adds	r5, #1
    for (uint16_t i = 0U; i < Size; i++)
 802fcbc:	e7e8      	b.n	802fc90 <HAL_SUBGHZ_ExecGetCmd+0x34>
    return HAL_BUSY;
 802fcbe:	2002      	movs	r0, #2
 802fcc0:	e7f6      	b.n	802fcb0 <HAL_SUBGHZ_ExecGetCmd+0x54>

0802fcc2 <HAL_SUBGHZ_IRQHandler>:
{
 802fcc2:	b537      	push	{r0, r1, r2, r4, r5, lr}
  uint8_t tmpisr[2] = {0};
 802fcc4:	2300      	movs	r3, #0
 802fcc6:	f8ad 3004 	strh.w	r3, [sp, #4]
  (void)HAL_SUBGHZ_ExecGetCmd(hsubghz, RADIO_GET_IRQSTATUS, tmpisr, 2);
 802fcca:	aa01      	add	r2, sp, #4
 802fccc:	2302      	movs	r3, #2
 802fcce:	2112      	movs	r1, #18
{
 802fcd0:	4604      	mov	r4, r0
  (void)HAL_SUBGHZ_ExecGetCmd(hsubghz, RADIO_GET_IRQSTATUS, tmpisr, 2);
 802fcd2:	f7ff ffc3 	bl	802fc5c <HAL_SUBGHZ_ExecGetCmd>
  itsource = (itsource << 8) | tmpisr[1];
 802fcd6:	f89d 3005 	ldrb.w	r3, [sp, #5]
 802fcda:	f89d 5004 	ldrb.w	r5, [sp, #4]
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_TX_CPLT) != RESET)
 802fcde:	07da      	lsls	r2, r3, #31
  itsource = (itsource << 8) | tmpisr[1];
 802fce0:	ea43 2505 	orr.w	r5, r3, r5, lsl #8
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_TX_CPLT) != RESET)
 802fce4:	d502      	bpl.n	802fcec <HAL_SUBGHZ_IRQHandler+0x2a>
    HAL_SUBGHZ_TxCpltCallback(hsubghz);
 802fce6:	4620      	mov	r0, r4
 802fce8:	f00a fea8 	bl	803aa3c <HAL_SUBGHZ_TxCpltCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_RX_CPLT) != RESET)
 802fcec:	07ab      	lsls	r3, r5, #30
 802fcee:	d502      	bpl.n	802fcf6 <HAL_SUBGHZ_IRQHandler+0x34>
    HAL_SUBGHZ_RxCpltCallback(hsubghz);
 802fcf0:	4620      	mov	r0, r4
 802fcf2:	f00a fea9 	bl	803aa48 <HAL_SUBGHZ_RxCpltCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_PREAMBLE_DETECTED) != RESET)
 802fcf6:	0768      	lsls	r0, r5, #29
 802fcf8:	d502      	bpl.n	802fd00 <HAL_SUBGHZ_IRQHandler+0x3e>
    HAL_SUBGHZ_PreambleDetectedCallback(hsubghz);
 802fcfa:	4620      	mov	r0, r4
 802fcfc:	f00a fece 	bl	803aa9c <HAL_SUBGHZ_PreambleDetectedCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_SYNCWORD_VALID) != RESET)
 802fd00:	0729      	lsls	r1, r5, #28
 802fd02:	d502      	bpl.n	802fd0a <HAL_SUBGHZ_IRQHandler+0x48>
    HAL_SUBGHZ_SyncWordValidCallback(hsubghz);
 802fd04:	4620      	mov	r0, r4
 802fd06:	f00a fecf 	bl	803aaa8 <HAL_SUBGHZ_SyncWordValidCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_HEADER_VALID) != RESET)
 802fd0a:	06ea      	lsls	r2, r5, #27
 802fd0c:	d502      	bpl.n	802fd14 <HAL_SUBGHZ_IRQHandler+0x52>
    HAL_SUBGHZ_HeaderValidCallback(hsubghz);
 802fd0e:	4620      	mov	r0, r4
 802fd10:	f00a fed0 	bl	803aab4 <HAL_SUBGHZ_HeaderValidCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_HEADER_ERROR) != RESET)
 802fd14:	06ab      	lsls	r3, r5, #26
 802fd16:	d502      	bpl.n	802fd1e <HAL_SUBGHZ_IRQHandler+0x5c>
    HAL_SUBGHZ_HeaderErrorCallback(hsubghz);
 802fd18:	4620      	mov	r0, r4
 802fd1a:	f00a feb9 	bl	803aa90 <HAL_SUBGHZ_HeaderErrorCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_CRC_ERROR) != RESET)
 802fd1e:	0668      	lsls	r0, r5, #25
 802fd20:	d502      	bpl.n	802fd28 <HAL_SUBGHZ_IRQHandler+0x66>
    HAL_SUBGHZ_CRCErrorCallback(hsubghz);
 802fd22:	4620      	mov	r0, r4
 802fd24:	f00a fe96 	bl	803aa54 <HAL_SUBGHZ_CRCErrorCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_CAD_DONE) != RESET)
 802fd28:	0629      	lsls	r1, r5, #24
 802fd2a:	d507      	bpl.n	802fd3c <HAL_SUBGHZ_IRQHandler+0x7a>
    if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_CAD_ACTIVITY_DETECTED) != RESET)
 802fd2c:	05ea      	lsls	r2, r5, #23
 802fd2e:	f3c5 2100 	ubfx	r1, r5, #8, #1
      HAL_SUBGHZ_CADStatusCallback(hsubghz, HAL_SUBGHZ_CAD_CLEAR);
 802fd32:	4620      	mov	r0, r4
      HAL_SUBGHZ_CADStatusCallback(hsubghz, HAL_SUBGHZ_CAD_DETECTED);
 802fd34:	bf48      	it	mi
 802fd36:	2101      	movmi	r1, #1
      HAL_SUBGHZ_CADStatusCallback(hsubghz, HAL_SUBGHZ_CAD_CLEAR);
 802fd38:	f00a fe92 	bl	803aa60 <HAL_SUBGHZ_CADStatusCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_RX_TX_TIMEOUT) != RESET)
 802fd3c:	05ab      	lsls	r3, r5, #22
 802fd3e:	d502      	bpl.n	802fd46 <HAL_SUBGHZ_IRQHandler+0x84>
    HAL_SUBGHZ_RxTxTimeoutCallback(hsubghz);
 802fd40:	4620      	mov	r0, r4
 802fd42:	f00a fe9d 	bl	803aa80 <HAL_SUBGHZ_RxTxTimeoutCallback>
  (void)HAL_SUBGHZ_ExecSetCmd(hsubghz, RADIO_CLR_IRQSTATUS, tmpisr, 2);
 802fd46:	2302      	movs	r3, #2
 802fd48:	aa01      	add	r2, sp, #4
 802fd4a:	4619      	mov	r1, r3
 802fd4c:	4620      	mov	r0, r4
 802fd4e:	f7ff fee3 	bl	802fb18 <HAL_SUBGHZ_ExecSetCmd>
}
 802fd52:	b003      	add	sp, #12
 802fd54:	bd30      	pop	{r4, r5, pc}

0802fd56 <UART_EndTxTransfer>:
  * @retval None
  */
static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable TXEIE, TCIE, TXFT interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE | USART_CR1_TCIE));
 802fd56:	6802      	ldr	r2, [r0, #0]
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802fd58:	e852 3f00 	ldrex	r3, [r2]
 802fd5c:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802fd60:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 802fd64:	6802      	ldr	r2, [r0, #0]
 802fd66:	2900      	cmp	r1, #0
 802fd68:	d1f5      	bne.n	802fd56 <UART_EndTxTransfer>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802fd6a:	f102 0308 	add.w	r3, r2, #8
 802fd6e:	e853 3f00 	ldrex	r3, [r3]
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_TXFTIE));
 802fd72:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802fd76:	f102 0c08 	add.w	ip, r2, #8
 802fd7a:	e84c 3100 	strex	r1, r3, [ip]
 802fd7e:	2900      	cmp	r1, #0
 802fd80:	d1f3      	bne.n	802fd6a <UART_EndTxTransfer+0x14>

  /* At end of Tx process, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 802fd82:	2320      	movs	r3, #32
 802fd84:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
}
 802fd88:	4770      	bx	lr
	...

0802fd8c <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
 802fd8c:	b510      	push	{r4, lr}
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 802fd8e:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802fd90:	e852 3f00 	ldrex	r3, [r2]
 802fd94:	f423 7390 	bic.w	r3, r3, #288	; 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802fd98:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 802fd9c:	6802      	ldr	r2, [r0, #0]
 802fd9e:	2900      	cmp	r1, #0
 802fda0:	d1f5      	bne.n	802fd8e <UART_EndRxTransfer+0x2>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 802fda2:	4c0f      	ldr	r4, [pc, #60]	; (802fde0 <UART_EndRxTransfer+0x54>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802fda4:	f102 0308 	add.w	r3, r2, #8
 802fda8:	e853 3f00 	ldrex	r3, [r3]
 802fdac:	4023      	ands	r3, r4
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802fdae:	f102 0c08 	add.w	ip, r2, #8
 802fdb2:	e84c 3100 	strex	r1, r3, [ip]
 802fdb6:	2900      	cmp	r1, #0
 802fdb8:	d1f4      	bne.n	802fda4 <UART_EndRxTransfer+0x18>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 802fdba:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 802fdbc:	2b01      	cmp	r3, #1
 802fdbe:	d107      	bne.n	802fdd0 <UART_EndRxTransfer+0x44>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802fdc0:	e852 3f00 	ldrex	r3, [r2]
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 802fdc4:	f023 0310 	bic.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802fdc8:	e842 3100 	strex	r1, r3, [r2]
 802fdcc:	2900      	cmp	r1, #0
 802fdce:	d1f7      	bne.n	802fdc0 <UART_EndRxTransfer+0x34>
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 802fdd0:	2320      	movs	r3, #32
 802fdd2:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 802fdd6:	2300      	movs	r3, #0
 802fdd8:	66c3      	str	r3, [r0, #108]	; 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 802fdda:	6703      	str	r3, [r0, #112]	; 0x70
}
 802fddc:	bd10      	pop	{r4, pc}
 802fdde:	bf00      	nop
 802fde0:	effffffe 	.word	0xeffffffe

0802fde4 <HAL_UART_Transmit_DMA>:
{
 802fde4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802fde6:	4604      	mov	r4, r0
 802fde8:	4613      	mov	r3, r2
  if (huart->gState == HAL_UART_STATE_READY)
 802fdea:	f8d4 7084 	ldr.w	r7, [r4, #132]	; 0x84
 802fdee:	2f20      	cmp	r7, #32
 802fdf0:	d143      	bne.n	802fe7a <HAL_UART_Transmit_DMA+0x96>
    if ((pData == NULL) || (Size == 0U))
 802fdf2:	b361      	cbz	r1, 802fe4e <HAL_UART_Transmit_DMA+0x6a>
 802fdf4:	b35a      	cbz	r2, 802fe4e <HAL_UART_Transmit_DMA+0x6a>
    __HAL_LOCK(huart);
 802fdf6:	f894 2080 	ldrb.w	r2, [r4, #128]	; 0x80
 802fdfa:	2a01      	cmp	r2, #1
 802fdfc:	d03d      	beq.n	802fe7a <HAL_UART_Transmit_DMA+0x96>
    if (huart->hdmatx != NULL)
 802fdfe:	6fa0      	ldr	r0, [r4, #120]	; 0x78
    huart->TxXferCount = Size;
 802fe00:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
    __HAL_LOCK(huart);
 802fe04:	2501      	movs	r5, #1
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 802fe06:	2600      	movs	r6, #0
    huart->gState = HAL_UART_STATE_BUSY_TX;
 802fe08:	2221      	movs	r2, #33	; 0x21
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 802fe0a:	f8c4 608c 	str.w	r6, [r4, #140]	; 0x8c
    __HAL_LOCK(huart);
 802fe0e:	f884 5080 	strb.w	r5, [r4, #128]	; 0x80
    huart->pTxBuffPtr  = pData;
 802fe12:	6521      	str	r1, [r4, #80]	; 0x50
    huart->TxXferSize  = Size;
 802fe14:	f8a4 3054 	strh.w	r3, [r4, #84]	; 0x54
    huart->gState = HAL_UART_STATE_BUSY_TX;
 802fe18:	f8c4 2084 	str.w	r2, [r4, #132]	; 0x84
    if (huart->hdmatx != NULL)
 802fe1c:	b1c8      	cbz	r0, 802fe52 <HAL_UART_Transmit_DMA+0x6e>
      huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
 802fe1e:	f8df c060 	ldr.w	ip, [pc, #96]	; 802fe80 <HAL_UART_Transmit_DMA+0x9c>
 802fe22:	6822      	ldr	r2, [r4, #0]
 802fe24:	f8c0 c02c 	str.w	ip, [r0, #44]	; 0x2c
      huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
 802fe28:	f8df c058 	ldr.w	ip, [pc, #88]	; 802fe84 <HAL_UART_Transmit_DMA+0xa0>
 802fe2c:	f8c0 c030 	str.w	ip, [r0, #48]	; 0x30
      huart->hdmatx->XferErrorCallback = UART_DMAError;
 802fe30:	f8df c054 	ldr.w	ip, [pc, #84]	; 802fe88 <HAL_UART_Transmit_DMA+0xa4>
      if (HAL_DMA_Start_IT(huart->hdmatx, (uint32_t)huart->pTxBuffPtr, (uint32_t)&huart->Instance->TDR, Size) != HAL_OK)
 802fe34:	3228      	adds	r2, #40	; 0x28
      huart->hdmatx->XferAbortCallback = NULL;
 802fe36:	e9c0 c60d 	strd	ip, r6, [r0, #52]	; 0x34
      if (HAL_DMA_Start_IT(huart->hdmatx, (uint32_t)huart->pTxBuffPtr, (uint32_t)&huart->Instance->TDR, Size) != HAL_OK)
 802fe3a:	f7fe f8f1 	bl	802e020 <HAL_DMA_Start_IT>
 802fe3e:	b140      	cbz	r0, 802fe52 <HAL_UART_Transmit_DMA+0x6e>
        huart->ErrorCode = HAL_UART_ERROR_DMA;
 802fe40:	2310      	movs	r3, #16
 802fe42:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
        __HAL_UNLOCK(huart);
 802fe46:	f884 6080 	strb.w	r6, [r4, #128]	; 0x80
        huart->gState = HAL_UART_STATE_READY;
 802fe4a:	f8c4 7084 	str.w	r7, [r4, #132]	; 0x84
      return HAL_ERROR;
 802fe4e:	2001      	movs	r0, #1
 802fe50:	e012      	b.n	802fe78 <HAL_UART_Transmit_DMA+0x94>
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_TCF);
 802fe52:	6823      	ldr	r3, [r4, #0]
 802fe54:	2240      	movs	r2, #64	; 0x40
 802fe56:	621a      	str	r2, [r3, #32]
    __HAL_UNLOCK(huart);
 802fe58:	2300      	movs	r3, #0
 802fe5a:	6822      	ldr	r2, [r4, #0]
 802fe5c:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802fe60:	f102 0308 	add.w	r3, r2, #8
 802fe64:	e853 3f00 	ldrex	r3, [r3]
    ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 802fe68:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802fe6c:	f102 0108 	add.w	r1, r2, #8
 802fe70:	e841 3000 	strex	r0, r3, [r1]
 802fe74:	2800      	cmp	r0, #0
 802fe76:	d1f3      	bne.n	802fe60 <HAL_UART_Transmit_DMA+0x7c>
}
 802fe78:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_BUSY;
 802fe7a:	2002      	movs	r0, #2
 802fe7c:	e7fc      	b.n	802fe78 <HAL_UART_Transmit_DMA+0x94>
 802fe7e:	bf00      	nop
 802fe80:	0802fe8d 	.word	0x0802fe8d
 802fe84:	0802fed5 	.word	0x0802fed5
 802fe88:	0802fee1 	.word	0x0802fee1

0802fe8c <UART_DMATransmitCplt>:
  * @brief DMA UART transmit process complete callback.
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
{
 802fe8c:	b508      	push	{r3, lr}
 802fe8e:	4603      	mov	r3, r0
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 802fe90:	6a80      	ldr	r0, [r0, #40]	; 0x28

  /* DMA Normal mode */
  if (HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC))
 802fe92:	681b      	ldr	r3, [r3, #0]
 802fe94:	681b      	ldr	r3, [r3, #0]
 802fe96:	f013 0320 	ands.w	r3, r3, #32
 802fe9a:	d117      	bne.n	802fecc <UART_DMATransmitCplt+0x40>
  {
    huart->TxXferCount = 0U;
 802fe9c:	f8a0 3056 	strh.w	r3, [r0, #86]	; 0x56

    /* Disable the DMA transfer for transmit request by resetting the DMAT bit
       in the UART CR3 register */
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 802fea0:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802fea2:	f102 0308 	add.w	r3, r2, #8
 802fea6:	e853 3f00 	ldrex	r3, [r3]
 802feaa:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802feae:	3208      	adds	r2, #8
 802feb0:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 802feb4:	6802      	ldr	r2, [r0, #0]
 802feb6:	2900      	cmp	r1, #0
 802feb8:	d1f2      	bne.n	802fea0 <UART_DMATransmitCplt+0x14>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802feba:	e852 3f00 	ldrex	r3, [r2]

    /* Enable the UART Transmit Complete Interrupt */
    ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 802febe:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802fec2:	e842 3100 	strex	r1, r3, [r2]
 802fec6:	2900      	cmp	r1, #0
 802fec8:	d1f7      	bne.n	802feba <UART_DMATransmitCplt+0x2e>
#else
    /*Call legacy weak Tx complete callback*/
    HAL_UART_TxCpltCallback(huart);
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
  }
}
 802feca:	bd08      	pop	{r3, pc}
    HAL_UART_TxCpltCallback(huart);
 802fecc:	f7fc fe10 	bl	802caf0 <HAL_UART_TxCpltCallback>
}
 802fed0:	e7fb      	b.n	802feca <UART_DMATransmitCplt+0x3e>

0802fed2 <HAL_UART_TxHalfCpltCallback>:
 802fed2:	4770      	bx	lr

0802fed4 <UART_DMATxHalfCplt>:
  * @brief DMA UART transmit process half complete callback.
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
{
 802fed4:	b508      	push	{r3, lr}
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx Half complete callback*/
  huart->TxHalfCpltCallback(huart);
#else
  /*Call legacy weak Tx Half complete callback*/
  HAL_UART_TxHalfCpltCallback(huart);
 802fed6:	6a80      	ldr	r0, [r0, #40]	; 0x28
 802fed8:	f7ff fffb 	bl	802fed2 <HAL_UART_TxHalfCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 802fedc:	bd08      	pop	{r3, pc}

0802fede <HAL_UART_ErrorCallback>:
 802fede:	4770      	bx	lr

0802fee0 <UART_DMAError>:
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMAError(DMA_HandleTypeDef *hdma)
{
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 802fee0:	6a80      	ldr	r0, [r0, #40]	; 0x28

  const HAL_UART_StateTypeDef gstate = huart->gState;
  const HAL_UART_StateTypeDef rxstate = huart->RxState;

  /* Stop UART DMA Tx request if ongoing */
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
 802fee2:	6802      	ldr	r2, [r0, #0]
  const HAL_UART_StateTypeDef gstate = huart->gState;
 802fee4:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
{
 802fee8:	b510      	push	{r4, lr}
  const HAL_UART_StateTypeDef rxstate = huart->RxState;
 802feea:	f8d0 4088 	ldr.w	r4, [r0, #136]	; 0x88
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
 802feee:	6892      	ldr	r2, [r2, #8]
 802fef0:	0612      	lsls	r2, r2, #24
 802fef2:	d506      	bpl.n	802ff02 <UART_DMAError+0x22>
 802fef4:	2b21      	cmp	r3, #33	; 0x21
 802fef6:	d104      	bne.n	802ff02 <UART_DMAError+0x22>
      (gstate == HAL_UART_STATE_BUSY_TX))
  {
    huart->TxXferCount = 0U;
 802fef8:	2300      	movs	r3, #0
 802fefa:	f8a0 3056 	strh.w	r3, [r0, #86]	; 0x56
    UART_EndTxTransfer(huart);
 802fefe:	f7ff ff2a 	bl	802fd56 <UART_EndTxTransfer>
  }

  /* Stop UART DMA Rx request if ongoing */
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) &&
 802ff02:	6803      	ldr	r3, [r0, #0]
 802ff04:	689b      	ldr	r3, [r3, #8]
 802ff06:	065b      	lsls	r3, r3, #25
 802ff08:	d506      	bpl.n	802ff18 <UART_DMAError+0x38>
 802ff0a:	2c22      	cmp	r4, #34	; 0x22
 802ff0c:	d104      	bne.n	802ff18 <UART_DMAError+0x38>
      (rxstate == HAL_UART_STATE_BUSY_RX))
  {
    huart->RxXferCount = 0U;
 802ff0e:	2300      	movs	r3, #0
 802ff10:	f8a0 305e 	strh.w	r3, [r0, #94]	; 0x5e
    UART_EndRxTransfer(huart);
 802ff14:	f7ff ff3a 	bl	802fd8c <UART_EndRxTransfer>
  }

  huart->ErrorCode |= HAL_UART_ERROR_DMA;
 802ff18:	f8d0 308c 	ldr.w	r3, [r0, #140]	; 0x8c
 802ff1c:	f043 0310 	orr.w	r3, r3, #16
 802ff20:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 802ff24:	f7ff ffdb 	bl	802fede <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 802ff28:	bd10      	pop	{r4, pc}

0802ff2a <UART_DMAAbortOnError>:
  *         (To be called at end of DMA Abort procedure following error occurrence).
  * @param  hdma DMA handle.
  * @retval None
  */
static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
 802ff2a:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 802ff2c:	6a80      	ldr	r0, [r0, #40]	; 0x28
  huart->RxXferCount = 0U;
 802ff2e:	2300      	movs	r3, #0
 802ff30:	f8a0 305e 	strh.w	r3, [r0, #94]	; 0x5e
  huart->TxXferCount = 0U;
 802ff34:	f8a0 3056 	strh.w	r3, [r0, #86]	; 0x56
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 802ff38:	f7ff ffd1 	bl	802fede <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 802ff3c:	bd08      	pop	{r3, pc}

0802ff3e <HAL_UARTEx_RxEventCallback>:
}
 802ff3e:	4770      	bx	lr

0802ff40 <HAL_UART_IRQHandler>:
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
 802ff40:	6803      	ldr	r3, [r0, #0]
 802ff42:	69da      	ldr	r2, [r3, #28]
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 802ff44:	6819      	ldr	r1, [r3, #0]
{
 802ff46:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (errorflags == 0U)
 802ff4a:	f640 060f 	movw	r6, #2063	; 0x80f
 802ff4e:	4232      	tst	r2, r6
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 802ff50:	689d      	ldr	r5, [r3, #8]
{
 802ff52:	4604      	mov	r4, r0
  if (errorflags == 0U)
 802ff54:	d110      	bne.n	802ff78 <HAL_UART_IRQHandler+0x38>
    if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)
 802ff56:	0696      	lsls	r6, r2, #26
 802ff58:	f140 8096 	bpl.w	8030088 <HAL_UART_IRQHandler+0x148>
        && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)
 802ff5c:	f001 0620 	and.w	r6, r1, #32
            || ((cr3its & USART_CR3_RXFTIE) != 0U)))
 802ff60:	f005 5780 	and.w	r7, r5, #268435456	; 0x10000000
 802ff64:	433e      	orrs	r6, r7
 802ff66:	f000 808f 	beq.w	8030088 <HAL_UART_IRQHandler+0x148>
      if (huart->RxISR != NULL)
 802ff6a:	6f03      	ldr	r3, [r0, #112]	; 0x70
 802ff6c:	2b00      	cmp	r3, #0
 802ff6e:	f000 8084 	beq.w	803007a <HAL_UART_IRQHandler+0x13a>
}
 802ff72:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 802ff76:	4718      	bx	r3
      && ((((cr3its & (USART_CR3_RXFTIE | USART_CR3_EIE)) != 0U)
 802ff78:	4ea7      	ldr	r6, [pc, #668]	; (8030218 <HAL_UART_IRQHandler+0x2d8>)
           || ((cr1its & (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_RTOIE)) != 0U))))
 802ff7a:	48a8      	ldr	r0, [pc, #672]	; (803021c <HAL_UART_IRQHandler+0x2dc>)
      && ((((cr3its & (USART_CR3_RXFTIE | USART_CR3_EIE)) != 0U)
 802ff7c:	402e      	ands	r6, r5
           || ((cr1its & (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_RTOIE)) != 0U))))
 802ff7e:	4008      	ands	r0, r1
 802ff80:	4330      	orrs	r0, r6
 802ff82:	f000 8081 	beq.w	8030088 <HAL_UART_IRQHandler+0x148>
    if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 802ff86:	07d7      	lsls	r7, r2, #31
 802ff88:	d509      	bpl.n	802ff9e <HAL_UART_IRQHandler+0x5e>
 802ff8a:	05c8      	lsls	r0, r1, #23
 802ff8c:	d507      	bpl.n	802ff9e <HAL_UART_IRQHandler+0x5e>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 802ff8e:	2001      	movs	r0, #1
 802ff90:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 802ff92:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 802ff96:	f040 0001 	orr.w	r0, r0, #1
 802ff9a:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 802ff9e:	0797      	lsls	r7, r2, #30
 802ffa0:	d509      	bpl.n	802ffb6 <HAL_UART_IRQHandler+0x76>
 802ffa2:	07e8      	lsls	r0, r5, #31
 802ffa4:	d507      	bpl.n	802ffb6 <HAL_UART_IRQHandler+0x76>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 802ffa6:	2002      	movs	r0, #2
 802ffa8:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 802ffaa:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 802ffae:	f040 0004 	orr.w	r0, r0, #4
 802ffb2:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 802ffb6:	0757      	lsls	r7, r2, #29
 802ffb8:	d509      	bpl.n	802ffce <HAL_UART_IRQHandler+0x8e>
 802ffba:	07e8      	lsls	r0, r5, #31
 802ffbc:	d507      	bpl.n	802ffce <HAL_UART_IRQHandler+0x8e>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 802ffbe:	2004      	movs	r0, #4
 802ffc0:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 802ffc2:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 802ffc6:	f040 0002 	orr.w	r0, r0, #2
 802ffca:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    if (((isrflags & USART_ISR_ORE) != 0U)
 802ffce:	0717      	lsls	r7, r2, #28
 802ffd0:	d50b      	bpl.n	802ffea <HAL_UART_IRQHandler+0xaa>
        && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U) ||
 802ffd2:	f001 0020 	and.w	r0, r1, #32
 802ffd6:	4330      	orrs	r0, r6
 802ffd8:	d007      	beq.n	802ffea <HAL_UART_IRQHandler+0xaa>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 802ffda:	2008      	movs	r0, #8
 802ffdc:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 802ffde:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 802ffe2:	f040 0008 	orr.w	r0, r0, #8
 802ffe6:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    if (((isrflags & USART_ISR_RTOF) != 0U) && ((cr1its & USART_CR1_RTOIE) != 0U))
 802ffea:	0516      	lsls	r6, r2, #20
 802ffec:	d50a      	bpl.n	8030004 <HAL_UART_IRQHandler+0xc4>
 802ffee:	0148      	lsls	r0, r1, #5
 802fff0:	d508      	bpl.n	8030004 <HAL_UART_IRQHandler+0xc4>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 802fff2:	f44f 6000 	mov.w	r0, #2048	; 0x800
 802fff6:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_RTO;
 802fff8:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 802fffc:	f043 0320 	orr.w	r3, r3, #32
 8030000:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 8030004:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 8030008:	2b00      	cmp	r3, #0
 803000a:	d036      	beq.n	803007a <HAL_UART_IRQHandler+0x13a>
      if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)
 803000c:	0693      	lsls	r3, r2, #26
 803000e:	d50a      	bpl.n	8030026 <HAL_UART_IRQHandler+0xe6>
          && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)
 8030010:	f001 0120 	and.w	r1, r1, #32
              || ((cr3its & USART_CR3_RXFTIE) != 0U)))
 8030014:	f005 5580 	and.w	r5, r5, #268435456	; 0x10000000
 8030018:	ea51 0305 	orrs.w	r3, r1, r5
 803001c:	d003      	beq.n	8030026 <HAL_UART_IRQHandler+0xe6>
        if (huart->RxISR != NULL)
 803001e:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8030020:	b10b      	cbz	r3, 8030026 <HAL_UART_IRQHandler+0xe6>
          huart->RxISR(huart);
 8030022:	4620      	mov	r0, r4
 8030024:	4798      	blx	r3
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 8030026:	6823      	ldr	r3, [r4, #0]
      errorcode = huart->ErrorCode;
 8030028:	f8d4 508c 	ldr.w	r5, [r4, #140]	; 0x8c
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 803002c:	689b      	ldr	r3, [r3, #8]
          ((errorcode & (HAL_UART_ERROR_RTO | HAL_UART_ERROR_ORE)) != 0U))
 803002e:	f005 0528 	and.w	r5, r5, #40	; 0x28
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 8030032:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8030036:	431d      	orrs	r5, r3
        UART_EndRxTransfer(huart);
 8030038:	4620      	mov	r0, r4
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 803003a:	d020      	beq.n	803007e <HAL_UART_IRQHandler+0x13e>
        UART_EndRxTransfer(huart);
 803003c:	f7ff fea6 	bl	802fd8c <UART_EndRxTransfer>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8030040:	6822      	ldr	r2, [r4, #0]
 8030042:	6893      	ldr	r3, [r2, #8]
 8030044:	065f      	lsls	r7, r3, #25
 8030046:	d515      	bpl.n	8030074 <HAL_UART_IRQHandler+0x134>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030048:	f102 0308 	add.w	r3, r2, #8
 803004c:	e853 3f00 	ldrex	r3, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8030050:	f023 0340 	bic.w	r3, r3, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030054:	f102 0008 	add.w	r0, r2, #8
 8030058:	e840 3100 	strex	r1, r3, [r0]
 803005c:	2900      	cmp	r1, #0
 803005e:	d1f3      	bne.n	8030048 <HAL_UART_IRQHandler+0x108>
          if (huart->hdmarx != NULL)
 8030060:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 8030062:	b138      	cbz	r0, 8030074 <HAL_UART_IRQHandler+0x134>
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 8030064:	4b6e      	ldr	r3, [pc, #440]	; (8030220 <HAL_UART_IRQHandler+0x2e0>)
 8030066:	6383      	str	r3, [r0, #56]	; 0x38
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 8030068:	f7fe f854 	bl	802e114 <HAL_DMA_Abort_IT>
 803006c:	b128      	cbz	r0, 803007a <HAL_UART_IRQHandler+0x13a>
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 803006e:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 8030070:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8030072:	e77e      	b.n	802ff72 <HAL_UART_IRQHandler+0x32>
            HAL_UART_ErrorCallback(huart);
 8030074:	4620      	mov	r0, r4
 8030076:	f7ff ff32 	bl	802fede <HAL_UART_ErrorCallback>
}
 803007a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        HAL_UART_ErrorCallback(huart);
 803007e:	f7ff ff2e 	bl	802fede <HAL_UART_ErrorCallback>
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 8030082:	f8c4 508c 	str.w	r5, [r4, #140]	; 0x8c
 8030086:	e7f8      	b.n	803007a <HAL_UART_IRQHandler+0x13a>
  if (  (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8030088:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 803008a:	2801      	cmp	r0, #1
 803008c:	f040 8081 	bne.w	8030192 <HAL_UART_IRQHandler+0x252>
      &&((isrflags & USART_ISR_IDLE) != 0U)
 8030090:	06d6      	lsls	r6, r2, #27
 8030092:	d57e      	bpl.n	8030192 <HAL_UART_IRQHandler+0x252>
      &&((cr1its & USART_ISR_IDLE) != 0U))
 8030094:	06c8      	lsls	r0, r1, #27
 8030096:	d57c      	bpl.n	8030192 <HAL_UART_IRQHandler+0x252>
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 8030098:	2210      	movs	r2, #16
 803009a:	621a      	str	r2, [r3, #32]
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 803009c:	689a      	ldr	r2, [r3, #8]
 803009e:	0651      	lsls	r1, r2, #25
 80300a0:	d547      	bpl.n	8030132 <HAL_UART_IRQHandler+0x1f2>
      uint16_t nb_remaining_rx_data = (uint16_t) __HAL_DMA_GET_COUNTER(huart->hdmarx);
 80300a2:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
 80300a4:	6811      	ldr	r1, [r2, #0]
 80300a6:	684a      	ldr	r2, [r1, #4]
 80300a8:	b292      	uxth	r2, r2
      if (  (nb_remaining_rx_data > 0U)
 80300aa:	2a00      	cmp	r2, #0
 80300ac:	d0e5      	beq.n	803007a <HAL_UART_IRQHandler+0x13a>
          &&(nb_remaining_rx_data < huart->RxXferSize))
 80300ae:	f8b4 005c 	ldrh.w	r0, [r4, #92]	; 0x5c
 80300b2:	4290      	cmp	r0, r2
 80300b4:	d9e1      	bls.n	803007a <HAL_UART_IRQHandler+0x13a>
        huart->RxXferCount = nb_remaining_rx_data;
 80300b6:	f8a4 205e 	strh.w	r2, [r4, #94]	; 0x5e
        if (HAL_IS_BIT_CLR(huart->hdmarx->Instance->CCR, DMA_CCR_CIRC))
 80300ba:	680a      	ldr	r2, [r1, #0]
 80300bc:	0692      	lsls	r2, r2, #26
 80300be:	d42e      	bmi.n	803011e <HAL_UART_IRQHandler+0x1de>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80300c0:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 80300c4:	f422 7280 	bic.w	r2, r2, #256	; 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80300c8:	e843 2100 	strex	r1, r2, [r3]
 80300cc:	2900      	cmp	r1, #0
 80300ce:	d1f7      	bne.n	80300c0 <HAL_UART_IRQHandler+0x180>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80300d0:	f103 0208 	add.w	r2, r3, #8
 80300d4:	e852 2f00 	ldrex	r2, [r2]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80300d8:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80300dc:	f103 0008 	add.w	r0, r3, #8
 80300e0:	e840 2100 	strex	r1, r2, [r0]
 80300e4:	2900      	cmp	r1, #0
 80300e6:	d1f3      	bne.n	80300d0 <HAL_UART_IRQHandler+0x190>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80300e8:	f103 0208 	add.w	r2, r3, #8
 80300ec:	e852 2f00 	ldrex	r2, [r2]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 80300f0:	f022 0240 	bic.w	r2, r2, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80300f4:	f103 0008 	add.w	r0, r3, #8
 80300f8:	e840 2100 	strex	r1, r2, [r0]
 80300fc:	2900      	cmp	r1, #0
 80300fe:	d1f3      	bne.n	80300e8 <HAL_UART_IRQHandler+0x1a8>
          huart->RxState = HAL_UART_STATE_READY;
 8030100:	2220      	movs	r2, #32
 8030102:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8030106:	66e1      	str	r1, [r4, #108]	; 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030108:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 803010c:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030110:	e843 2100 	strex	r1, r2, [r3]
 8030114:	2900      	cmp	r1, #0
 8030116:	d1f7      	bne.n	8030108 <HAL_UART_IRQHandler+0x1c8>
          (void)HAL_DMA_Abort(huart->hdmarx);
 8030118:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 803011a:	f7fd ffc6 	bl	802e0aa <HAL_DMA_Abort>
        HAL_UARTEx_RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
 803011e:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 8030122:	f8b4 105c 	ldrh.w	r1, [r4, #92]	; 0x5c
 8030126:	1ac9      	subs	r1, r1, r3
 8030128:	b289      	uxth	r1, r1
        HAL_UARTEx_RxEventCallback(huart, nb_rx_data);
 803012a:	4620      	mov	r0, r4
 803012c:	f7ff ff07 	bl	802ff3e <HAL_UARTEx_RxEventCallback>
 8030130:	e7a3      	b.n	803007a <HAL_UART_IRQHandler+0x13a>
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 8030132:	f8b4 105e 	ldrh.w	r1, [r4, #94]	; 0x5e
 8030136:	b28a      	uxth	r2, r1
      if (  (huart->RxXferCount > 0U)
 8030138:	f8b4 105e 	ldrh.w	r1, [r4, #94]	; 0x5e
 803013c:	b289      	uxth	r1, r1
 803013e:	2900      	cmp	r1, #0
 8030140:	d09b      	beq.n	803007a <HAL_UART_IRQHandler+0x13a>
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 8030142:	f8b4 105c 	ldrh.w	r1, [r4, #92]	; 0x5c
 8030146:	1a89      	subs	r1, r1, r2
 8030148:	b289      	uxth	r1, r1
          &&(nb_rx_data > 0U) )
 803014a:	2900      	cmp	r1, #0
 803014c:	d095      	beq.n	803007a <HAL_UART_IRQHandler+0x13a>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 803014e:	e853 2f00 	ldrex	r2, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 8030152:	f422 7290 	bic.w	r2, r2, #288	; 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030156:	e843 2000 	strex	r0, r2, [r3]
 803015a:	2800      	cmp	r0, #0
 803015c:	d1f7      	bne.n	803014e <HAL_UART_IRQHandler+0x20e>
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 803015e:	4d31      	ldr	r5, [pc, #196]	; (8030224 <HAL_UART_IRQHandler+0x2e4>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030160:	f103 0208 	add.w	r2, r3, #8
 8030164:	e852 2f00 	ldrex	r2, [r2]
 8030168:	402a      	ands	r2, r5
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 803016a:	f103 0608 	add.w	r6, r3, #8
 803016e:	e846 2000 	strex	r0, r2, [r6]
 8030172:	2800      	cmp	r0, #0
 8030174:	d1f4      	bne.n	8030160 <HAL_UART_IRQHandler+0x220>
        huart->RxState = HAL_UART_STATE_READY;
 8030176:	2220      	movs	r2, #32
 8030178:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
        huart->RxISR = NULL;
 803017c:	6720      	str	r0, [r4, #112]	; 0x70
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 803017e:	66e0      	str	r0, [r4, #108]	; 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030180:	e853 2f00 	ldrex	r2, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8030184:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030188:	e843 2000 	strex	r0, r2, [r3]
 803018c:	2800      	cmp	r0, #0
 803018e:	d1f7      	bne.n	8030180 <HAL_UART_IRQHandler+0x240>
 8030190:	e7cb      	b.n	803012a <HAL_UART_IRQHandler+0x1ea>
  if (((isrflags & USART_ISR_WUF) != 0U) && ((cr3its & USART_CR3_WUFIE) != 0U))
 8030192:	02d7      	lsls	r7, r2, #11
 8030194:	d509      	bpl.n	80301aa <HAL_UART_IRQHandler+0x26a>
 8030196:	026e      	lsls	r6, r5, #9
 8030198:	d507      	bpl.n	80301aa <HAL_UART_IRQHandler+0x26a>
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);
 803019a:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    HAL_UARTEx_WakeupCallback(huart);
 803019e:	4620      	mov	r0, r4
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);
 80301a0:	621a      	str	r2, [r3, #32]
}
 80301a2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    HAL_UARTEx_WakeupCallback(huart);
 80301a6:	f000 bd35 	b.w	8030c14 <HAL_UARTEx_WakeupCallback>
  if (((isrflags & USART_ISR_TXE_TXFNF) != 0U)
 80301aa:	0610      	lsls	r0, r2, #24
 80301ac:	d50b      	bpl.n	80301c6 <HAL_UART_IRQHandler+0x286>
      && (((cr1its & USART_CR1_TXEIE_TXFNFIE) != 0U)
 80301ae:	f001 0080 	and.w	r0, r1, #128	; 0x80
          || ((cr3its & USART_CR3_TXFTIE) != 0U)))
 80301b2:	f405 0500 	and.w	r5, r5, #8388608	; 0x800000
 80301b6:	4328      	orrs	r0, r5
 80301b8:	d005      	beq.n	80301c6 <HAL_UART_IRQHandler+0x286>
    if (huart->TxISR != NULL)
 80301ba:	6f63      	ldr	r3, [r4, #116]	; 0x74
 80301bc:	2b00      	cmp	r3, #0
 80301be:	f43f af5c 	beq.w	803007a <HAL_UART_IRQHandler+0x13a>
      huart->TxISR(huart);
 80301c2:	4620      	mov	r0, r4
 80301c4:	e6d5      	b.n	802ff72 <HAL_UART_IRQHandler+0x32>
  if (((isrflags & USART_ISR_TC) != 0U) && ((cr1its & USART_CR1_TCIE) != 0U))
 80301c6:	0657      	lsls	r7, r2, #25
 80301c8:	d511      	bpl.n	80301ee <HAL_UART_IRQHandler+0x2ae>
 80301ca:	064e      	lsls	r6, r1, #25
 80301cc:	d50f      	bpl.n	80301ee <HAL_UART_IRQHandler+0x2ae>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80301ce:	e853 2f00 	ldrex	r2, [r3]
  * @retval None
  */
static void UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
  /* Disable the UART Transmit Complete Interrupt */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 80301d2:	f022 0240 	bic.w	r2, r2, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80301d6:	e843 2100 	strex	r1, r2, [r3]
 80301da:	2900      	cmp	r1, #0
 80301dc:	d1f7      	bne.n	80301ce <HAL_UART_IRQHandler+0x28e>

  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 80301de:	2320      	movs	r3, #32
 80301e0:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84

  /* Cleat TxISR function pointer */
  huart->TxISR = NULL;
 80301e4:	6761      	str	r1, [r4, #116]	; 0x74
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx complete callback*/
  huart->TxCpltCallback(huart);
#else
  /*Call legacy weak Tx complete callback*/
  HAL_UART_TxCpltCallback(huart);
 80301e6:	4620      	mov	r0, r4
 80301e8:	f7fc fc82 	bl	802caf0 <HAL_UART_TxCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 80301ec:	e745      	b.n	803007a <HAL_UART_IRQHandler+0x13a>
  if (((isrflags & USART_ISR_TXFE) != 0U) && ((cr1its & USART_CR1_TXFEIE) != 0U))
 80301ee:	0215      	lsls	r5, r2, #8
 80301f0:	d506      	bpl.n	8030200 <HAL_UART_IRQHandler+0x2c0>
 80301f2:	0048      	lsls	r0, r1, #1
 80301f4:	d504      	bpl.n	8030200 <HAL_UART_IRQHandler+0x2c0>
    HAL_UARTEx_TxFifoEmptyCallback(huart);
 80301f6:	4620      	mov	r0, r4
}
 80301f8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    HAL_UARTEx_TxFifoEmptyCallback(huart);
 80301fc:	f000 bd0c 	b.w	8030c18 <HAL_UARTEx_TxFifoEmptyCallback>
  if (((isrflags & USART_ISR_RXFF) != 0U) && ((cr1its & USART_CR1_RXFFIE) != 0U))
 8030200:	01d3      	lsls	r3, r2, #7
 8030202:	f57f af3a 	bpl.w	803007a <HAL_UART_IRQHandler+0x13a>
 8030206:	2900      	cmp	r1, #0
 8030208:	f6bf af37 	bge.w	803007a <HAL_UART_IRQHandler+0x13a>
    HAL_UARTEx_RxFifoFullCallback(huart);
 803020c:	4620      	mov	r0, r4
}
 803020e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    HAL_UARTEx_RxFifoFullCallback(huart);
 8030212:	f000 bd00 	b.w	8030c16 <HAL_UARTEx_RxFifoFullCallback>
 8030216:	bf00      	nop
 8030218:	10000001 	.word	0x10000001
 803021c:	04000120 	.word	0x04000120
 8030220:	0802ff2b 	.word	0x0802ff2b
 8030224:	effffffe 	.word	0xeffffffe

08030228 <UART_RxISR_16BIT.part.0>:
/**
  * @brief RX interrupt handler for 7 or 8 bits data word length .
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_8BIT(UART_HandleTypeDef *huart)
 8030228:	b508      	push	{r3, lr}
    huart->RxXferCount--;

    if (huart->RxXferCount == 0U)
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupts */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 803022a:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 803022c:	e852 3f00 	ldrex	r3, [r2]
 8030230:	f423 7390 	bic.w	r3, r3, #288	; 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030234:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 8030238:	6803      	ldr	r3, [r0, #0]
 803023a:	2900      	cmp	r1, #0
 803023c:	d1f5      	bne.n	803022a <UART_RxISR_16BIT.part.0+0x2>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 803023e:	f103 0208 	add.w	r2, r3, #8
 8030242:	e852 2f00 	ldrex	r2, [r2]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8030246:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 803024a:	f103 0c08 	add.w	ip, r3, #8
 803024e:	e84c 2100 	strex	r1, r2, [ip]
 8030252:	2900      	cmp	r1, #0
 8030254:	d1f3      	bne.n	803023e <UART_RxISR_16BIT.part.0+0x16>

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 8030256:	2220      	movs	r2, #32
 8030258:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
      /* Clear RxISR function pointer */
      huart->RxISR = NULL;

      /* Check current reception Mode :
         If Reception till IDLE event has been selected : */
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 803025c:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
      huart->RxISR = NULL;
 803025e:	6701      	str	r1, [r0, #112]	; 0x70
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8030260:	2a01      	cmp	r2, #1
 8030262:	d112      	bne.n	803028a <UART_RxISR_16BIT.part.0+0x62>
      {
        /* Set reception type to Standard */
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8030264:	66c1      	str	r1, [r0, #108]	; 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030266:	e853 2f00 	ldrex	r2, [r3]

        /* Disable IDLE interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 803026a:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 803026e:	e843 2100 	strex	r1, r2, [r3]
 8030272:	2900      	cmp	r1, #0
 8030274:	d1f7      	bne.n	8030266 <UART_RxISR_16BIT.part.0+0x3e>

        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 8030276:	69da      	ldr	r2, [r3, #28]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, huart->RxXferSize);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8030278:	f8b0 105c 	ldrh.w	r1, [r0, #92]	; 0x5c
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 803027c:	06d2      	lsls	r2, r2, #27
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 803027e:	bf44      	itt	mi
 8030280:	2210      	movmi	r2, #16
 8030282:	621a      	strmi	r2, [r3, #32]
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8030284:	f7ff fe5b 	bl	802ff3e <HAL_UARTEx_RxEventCallback>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 8030288:	bd08      	pop	{r3, pc}
        HAL_UART_RxCpltCallback(huart);
 803028a:	f7fc fc37 	bl	802cafc <HAL_UART_RxCpltCallback>
}
 803028e:	e7fb      	b.n	8030288 <UART_RxISR_16BIT.part.0+0x60>

08030290 <UART_RxISR_16BIT>:
  uint16_t *tmp;
  uint16_t uhMask = huart->Mask;
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8030290:	f8d0 1088 	ldr.w	r1, [r0, #136]	; 0x88
 8030294:	6802      	ldr	r2, [r0, #0]
 8030296:	2922      	cmp	r1, #34	; 0x22
 8030298:	d113      	bne.n	80302c2 <UART_RxISR_16BIT+0x32>
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 803029a:	6a51      	ldr	r1, [r2, #36]	; 0x24
    tmp = (uint16_t *) huart->pRxBuffPtr ;
    *tmp = (uint16_t)(uhdata & uhMask);
 803029c:	f8b0 2060 	ldrh.w	r2, [r0, #96]	; 0x60
 80302a0:	4011      	ands	r1, r2
 80302a2:	6d82      	ldr	r2, [r0, #88]	; 0x58
 80302a4:	f822 1b02 	strh.w	r1, [r2], #2
    huart->pRxBuffPtr += 2U;
 80302a8:	6582      	str	r2, [r0, #88]	; 0x58
    huart->RxXferCount--;
 80302aa:	f8b0 205e 	ldrh.w	r2, [r0, #94]	; 0x5e
 80302ae:	3a01      	subs	r2, #1
 80302b0:	b292      	uxth	r2, r2
 80302b2:	f8a0 205e 	strh.w	r2, [r0, #94]	; 0x5e

    if (huart->RxXferCount == 0U)
 80302b6:	f8b0 305e 	ldrh.w	r3, [r0, #94]	; 0x5e
 80302ba:	b29b      	uxth	r3, r3
 80302bc:	b92b      	cbnz	r3, 80302ca <UART_RxISR_16BIT+0x3a>
 80302be:	f7ff bfb3 	b.w	8030228 <UART_RxISR_16BIT.part.0>
    }
  }
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 80302c2:	6993      	ldr	r3, [r2, #24]
 80302c4:	f043 0308 	orr.w	r3, r3, #8
 80302c8:	6193      	str	r3, [r2, #24]
  }
}
 80302ca:	4770      	bx	lr

080302cc <UART_RxISR_8BIT>:
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 80302cc:	f8d0 1088 	ldr.w	r1, [r0, #136]	; 0x88
 80302d0:	6802      	ldr	r2, [r0, #0]
 80302d2:	2922      	cmp	r1, #34	; 0x22
{
 80302d4:	b410      	push	{r4}
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 80302d6:	d115      	bne.n	8030304 <UART_RxISR_8BIT+0x38>
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 80302d8:	6a52      	ldr	r2, [r2, #36]	; 0x24
    *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 80302da:	f890 4060 	ldrb.w	r4, [r0, #96]	; 0x60
 80302de:	6d81      	ldr	r1, [r0, #88]	; 0x58
 80302e0:	4022      	ands	r2, r4
 80302e2:	700a      	strb	r2, [r1, #0]
    huart->pRxBuffPtr++;
 80302e4:	6d82      	ldr	r2, [r0, #88]	; 0x58
 80302e6:	3201      	adds	r2, #1
 80302e8:	6582      	str	r2, [r0, #88]	; 0x58
    huart->RxXferCount--;
 80302ea:	f8b0 205e 	ldrh.w	r2, [r0, #94]	; 0x5e
 80302ee:	3a01      	subs	r2, #1
 80302f0:	b292      	uxth	r2, r2
 80302f2:	f8a0 205e 	strh.w	r2, [r0, #94]	; 0x5e
    if (huart->RxXferCount == 0U)
 80302f6:	f8b0 305e 	ldrh.w	r3, [r0, #94]	; 0x5e
 80302fa:	b29b      	uxth	r3, r3
 80302fc:	b933      	cbnz	r3, 803030c <UART_RxISR_8BIT+0x40>
}
 80302fe:	bc10      	pop	{r4}
 8030300:	f7ff bf92 	b.w	8030228 <UART_RxISR_16BIT.part.0>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 8030304:	6993      	ldr	r3, [r2, #24]
 8030306:	f043 0308 	orr.w	r3, r3, #8
 803030a:	6193      	str	r3, [r2, #24]
}
 803030c:	bc10      	pop	{r4}
 803030e:	4770      	bx	lr

08030310 <UART_RxISR_8BIT_FIFOEN>:
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_8BIT_FIFOEN(UART_HandleTypeDef *huart)
{
 8030310:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint16_t  uhMask = huart->Mask;
  uint16_t  uhdata;
  uint16_t  nb_rx_data;
  uint16_t  rxdatacount;
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
 8030314:	6803      	ldr	r3, [r0, #0]
 8030316:	69dd      	ldr	r5, [r3, #28]
  uint32_t  cr1its   = READ_REG(huart->Instance->CR1);
 8030318:	f8d3 8000 	ldr.w	r8, [r3]
  uint32_t  cr3its   = READ_REG(huart->Instance->CR3);
 803031c:	689e      	ldr	r6, [r3, #8]

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 803031e:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8030322:	2a22      	cmp	r2, #34	; 0x22
{
 8030324:	4604      	mov	r4, r0
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8030326:	f040 80a7 	bne.w	8030478 <UART_RxISR_8BIT_FIFOEN+0x168>
  uint16_t  uhMask = huart->Mask;
 803032a:	f8b0 7060 	ldrh.w	r7, [r0, #96]	; 0x60
  {
    nb_rx_data = huart->NbRxDataToProcess;
 803032e:	f8b0 9068 	ldrh.w	r9, [r0, #104]	; 0x68
        /* Disable the UART Parity Error Interrupt and RXFT interrupt*/
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);

        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error)
           and RX FIFO Threshold interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 8030332:	f8df b154 	ldr.w	fp, [pc, #340]	; 8030488 <UART_RxISR_8BIT_FIFOEN+0x178>
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 8030336:	f04f 0a00 	mov.w	sl, #0
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 803033a:	f006 0601 	and.w	r6, r6, #1
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 803033e:	f1b9 0f00 	cmp.w	r9, #0
 8030342:	d001      	beq.n	8030348 <UART_RxISR_8BIT_FIFOEN+0x38>
 8030344:	06ab      	lsls	r3, r5, #26
 8030346:	d420      	bmi.n	803038a <UART_RxISR_8BIT_FIFOEN+0x7a>

    /* When remaining number of bytes to receive is less than the RX FIFO
    threshold, next incoming frames are processed as if FIFO mode was
    disabled (i.e. one interrupt per received frame).
    */
    rxdatacount = huart->RxXferCount;
 8030348:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 803034c:	b29b      	uxth	r3, r3
    if ((rxdatacount != 0U) && (rxdatacount < huart->NbRxDataToProcess))
 803034e:	b1d3      	cbz	r3, 8030386 <UART_RxISR_8BIT_FIFOEN+0x76>
 8030350:	f8b4 2068 	ldrh.w	r2, [r4, #104]	; 0x68
 8030354:	429a      	cmp	r2, r3
 8030356:	d916      	bls.n	8030386 <UART_RxISR_8BIT_FIFOEN+0x76>
    {
      /* Disable the UART RXFT interrupt*/
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 8030358:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 803035a:	f102 0308 	add.w	r3, r2, #8
 803035e:	e853 3f00 	ldrex	r3, [r3]
 8030362:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030366:	3208      	adds	r2, #8
 8030368:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 803036c:	6822      	ldr	r2, [r4, #0]
 803036e:	2900      	cmp	r1, #0
 8030370:	d1f2      	bne.n	8030358 <UART_RxISR_8BIT_FIFOEN+0x48>

      /* Update the RxISR function pointer */
      huart->RxISR = UART_RxISR_8BIT;
 8030372:	4b44      	ldr	r3, [pc, #272]	; (8030484 <UART_RxISR_8BIT_FIFOEN+0x174>)
 8030374:	6723      	str	r3, [r4, #112]	; 0x70
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030376:	e852 3f00 	ldrex	r3, [r2]

      /* Enable the UART Data Register Not Empty interrupt */
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
 803037a:	f043 0320 	orr.w	r3, r3, #32
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 803037e:	e842 3100 	strex	r1, r3, [r2]
 8030382:	2900      	cmp	r1, #0
 8030384:	d1f7      	bne.n	8030376 <UART_RxISR_8BIT_FIFOEN+0x66>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 8030386:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 803038a:	6823      	ldr	r3, [r4, #0]
      *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 803038c:	6da2      	ldr	r2, [r4, #88]	; 0x58
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 803038e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
      *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 8030390:	403b      	ands	r3, r7
 8030392:	7013      	strb	r3, [r2, #0]
      huart->pRxBuffPtr++;
 8030394:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8030396:	3301      	adds	r3, #1
 8030398:	65a3      	str	r3, [r4, #88]	; 0x58
      huart->RxXferCount--;
 803039a:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 803039e:	3b01      	subs	r3, #1
 80303a0:	b29b      	uxth	r3, r3
 80303a2:	f8a4 305e 	strh.w	r3, [r4, #94]	; 0x5e
      isrflags = READ_REG(huart->Instance->ISR);
 80303a6:	6823      	ldr	r3, [r4, #0]
 80303a8:	69dd      	ldr	r5, [r3, #28]
      if ((isrflags & (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE)) != 0U)
 80303aa:	0769      	lsls	r1, r5, #29
 80303ac:	d02a      	beq.n	8030404 <UART_RxISR_8BIT_FIFOEN+0xf4>
        if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 80303ae:	07ea      	lsls	r2, r5, #31
 80303b0:	d50a      	bpl.n	80303c8 <UART_RxISR_8BIT_FIFOEN+0xb8>
 80303b2:	f418 7f80 	tst.w	r8, #256	; 0x100
 80303b6:	d007      	beq.n	80303c8 <UART_RxISR_8BIT_FIFOEN+0xb8>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 80303b8:	2201      	movs	r2, #1
 80303ba:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_PE;
 80303bc:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 80303c0:	f042 0201 	orr.w	r2, r2, #1
 80303c4:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
        if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 80303c8:	07a8      	lsls	r0, r5, #30
 80303ca:	d508      	bpl.n	80303de <UART_RxISR_8BIT_FIFOEN+0xce>
 80303cc:	b13e      	cbz	r6, 80303de <UART_RxISR_8BIT_FIFOEN+0xce>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 80303ce:	2202      	movs	r2, #2
 80303d0:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_FE;
 80303d2:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 80303d6:	f042 0204 	orr.w	r2, r2, #4
 80303da:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 80303de:	0769      	lsls	r1, r5, #29
 80303e0:	d508      	bpl.n	80303f4 <UART_RxISR_8BIT_FIFOEN+0xe4>
 80303e2:	b13e      	cbz	r6, 80303f4 <UART_RxISR_8BIT_FIFOEN+0xe4>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 80303e4:	2204      	movs	r2, #4
 80303e6:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_NE;
 80303e8:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 80303ec:	f043 0302 	orr.w	r3, r3, #2
 80303f0:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
        if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 80303f4:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 80303f8:	b123      	cbz	r3, 8030404 <UART_RxISR_8BIT_FIFOEN+0xf4>
          HAL_UART_ErrorCallback(huart);
 80303fa:	4620      	mov	r0, r4
 80303fc:	f7ff fd6f 	bl	802fede <HAL_UART_ErrorCallback>
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 8030400:	f8c4 a08c 	str.w	sl, [r4, #140]	; 0x8c
      if (huart->RxXferCount == 0U)
 8030404:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 8030408:	b29b      	uxth	r3, r3
 803040a:	2b00      	cmp	r3, #0
 803040c:	d197      	bne.n	803033e <UART_RxISR_8BIT_FIFOEN+0x2e>
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 803040e:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030410:	e852 3f00 	ldrex	r3, [r2]
 8030414:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030418:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 803041c:	6823      	ldr	r3, [r4, #0]
 803041e:	2900      	cmp	r1, #0
 8030420:	d1f5      	bne.n	803040e <UART_RxISR_8BIT_FIFOEN+0xfe>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030422:	f103 0208 	add.w	r2, r3, #8
 8030426:	e852 2f00 	ldrex	r2, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 803042a:	ea02 020b 	and.w	r2, r2, fp
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 803042e:	f103 0008 	add.w	r0, r3, #8
 8030432:	e840 2100 	strex	r1, r2, [r0]
 8030436:	2900      	cmp	r1, #0
 8030438:	d1f3      	bne.n	8030422 <UART_RxISR_8BIT_FIFOEN+0x112>
        huart->RxState = HAL_UART_STATE_READY;
 803043a:	2220      	movs	r2, #32
 803043c:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8030440:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
        huart->RxISR = NULL;
 8030442:	6721      	str	r1, [r4, #112]	; 0x70
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8030444:	2a01      	cmp	r2, #1
 8030446:	d113      	bne.n	8030470 <UART_RxISR_8BIT_FIFOEN+0x160>
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8030448:	66e1      	str	r1, [r4, #108]	; 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 803044a:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 803044e:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030452:	e843 2100 	strex	r1, r2, [r3]
 8030456:	2900      	cmp	r1, #0
 8030458:	d1f7      	bne.n	803044a <UART_RxISR_8BIT_FIFOEN+0x13a>
          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 803045a:	69da      	ldr	r2, [r3, #28]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 803045c:	f8b4 105c 	ldrh.w	r1, [r4, #92]	; 0x5c
          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 8030460:	06d2      	lsls	r2, r2, #27
            __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 8030462:	bf44      	itt	mi
 8030464:	2210      	movmi	r2, #16
 8030466:	621a      	strmi	r2, [r3, #32]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8030468:	4620      	mov	r0, r4
 803046a:	f7ff fd68 	bl	802ff3e <HAL_UARTEx_RxEventCallback>
 803046e:	e766      	b.n	803033e <UART_RxISR_8BIT_FIFOEN+0x2e>
          HAL_UART_RxCpltCallback(huart);
 8030470:	4620      	mov	r0, r4
 8030472:	f7fc fb43 	bl	802cafc <HAL_UART_RxCpltCallback>
 8030476:	e762      	b.n	803033e <UART_RxISR_8BIT_FIFOEN+0x2e>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 8030478:	699a      	ldr	r2, [r3, #24]
 803047a:	f042 0208 	orr.w	r2, r2, #8
 803047e:	619a      	str	r2, [r3, #24]
}
 8030480:	e781      	b.n	8030386 <UART_RxISR_8BIT_FIFOEN+0x76>
 8030482:	bf00      	nop
 8030484:	080302cd 	.word	0x080302cd
 8030488:	effffffe 	.word	0xeffffffe

0803048c <UART_RxISR_16BIT_FIFOEN>:
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_16BIT_FIFOEN(UART_HandleTypeDef *huart)
{
 803048c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint16_t *tmp;
  uint16_t  uhMask = huart->Mask;
  uint16_t  uhdata;
  uint16_t  nb_rx_data;
  uint16_t  rxdatacount;
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
 8030490:	6803      	ldr	r3, [r0, #0]
 8030492:	69dd      	ldr	r5, [r3, #28]
  uint32_t  cr1its   = READ_REG(huart->Instance->CR1);
 8030494:	f8d3 8000 	ldr.w	r8, [r3]
  uint32_t  cr3its   = READ_REG(huart->Instance->CR3);
 8030498:	689e      	ldr	r6, [r3, #8]

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 803049a:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 803049e:	2a22      	cmp	r2, #34	; 0x22
{
 80304a0:	4604      	mov	r4, r0
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 80304a2:	f040 80a5 	bne.w	80305f0 <UART_RxISR_16BIT_FIFOEN+0x164>
  uint16_t  uhMask = huart->Mask;
 80304a6:	f8b0 7060 	ldrh.w	r7, [r0, #96]	; 0x60
  {
    nb_rx_data = huart->NbRxDataToProcess;
 80304aa:	f8b0 9068 	ldrh.w	r9, [r0, #104]	; 0x68
        /* Disable the UART Parity Error Interrupt and RXFT interrupt*/
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);

        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error)
           and RX FIFO Threshold interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 80304ae:	f8df b150 	ldr.w	fp, [pc, #336]	; 8030600 <UART_RxISR_16BIT_FIFOEN+0x174>
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 80304b2:	f04f 0a00 	mov.w	sl, #0
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 80304b6:	f006 0601 	and.w	r6, r6, #1
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 80304ba:	f1b9 0f00 	cmp.w	r9, #0
 80304be:	d001      	beq.n	80304c4 <UART_RxISR_16BIT_FIFOEN+0x38>
 80304c0:	06ab      	lsls	r3, r5, #26
 80304c2:	d420      	bmi.n	8030506 <UART_RxISR_16BIT_FIFOEN+0x7a>

    /* When remaining number of bytes to receive is less than the RX FIFO
    threshold, next incoming frames are processed as if FIFO mode was
    disabled (i.e. one interrupt per received frame).
    */
    rxdatacount = huart->RxXferCount;
 80304c4:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 80304c8:	b29b      	uxth	r3, r3
    if ((rxdatacount != 0U) && (rxdatacount < huart->NbRxDataToProcess))
 80304ca:	b1d3      	cbz	r3, 8030502 <UART_RxISR_16BIT_FIFOEN+0x76>
 80304cc:	f8b4 2068 	ldrh.w	r2, [r4, #104]	; 0x68
 80304d0:	429a      	cmp	r2, r3
 80304d2:	d916      	bls.n	8030502 <UART_RxISR_16BIT_FIFOEN+0x76>
    {
      /* Disable the UART RXFT interrupt*/
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 80304d4:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80304d6:	f102 0308 	add.w	r3, r2, #8
 80304da:	e853 3f00 	ldrex	r3, [r3]
 80304de:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80304e2:	3208      	adds	r2, #8
 80304e4:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 80304e8:	6822      	ldr	r2, [r4, #0]
 80304ea:	2900      	cmp	r1, #0
 80304ec:	d1f2      	bne.n	80304d4 <UART_RxISR_16BIT_FIFOEN+0x48>

      /* Update the RxISR function pointer */
      huart->RxISR = UART_RxISR_16BIT;
 80304ee:	4b43      	ldr	r3, [pc, #268]	; (80305fc <UART_RxISR_16BIT_FIFOEN+0x170>)
 80304f0:	6723      	str	r3, [r4, #112]	; 0x70
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80304f2:	e852 3f00 	ldrex	r3, [r2]

      /* Enable the UART Data Register Not Empty interrupt */
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
 80304f6:	f043 0320 	orr.w	r3, r3, #32
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80304fa:	e842 3100 	strex	r1, r3, [r2]
 80304fe:	2900      	cmp	r1, #0
 8030500:	d1f7      	bne.n	80304f2 <UART_RxISR_16BIT_FIFOEN+0x66>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 8030502:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8030506:	6823      	ldr	r3, [r4, #0]
      *tmp = (uint16_t)(uhdata & uhMask);
 8030508:	6da2      	ldr	r2, [r4, #88]	; 0x58
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 803050a:	6a59      	ldr	r1, [r3, #36]	; 0x24
      *tmp = (uint16_t)(uhdata & uhMask);
 803050c:	4039      	ands	r1, r7
 803050e:	f822 1b02 	strh.w	r1, [r2], #2
      huart->pRxBuffPtr += 2U;
 8030512:	65a2      	str	r2, [r4, #88]	; 0x58
      huart->RxXferCount--;
 8030514:	f8b4 205e 	ldrh.w	r2, [r4, #94]	; 0x5e
 8030518:	3a01      	subs	r2, #1
 803051a:	b292      	uxth	r2, r2
 803051c:	f8a4 205e 	strh.w	r2, [r4, #94]	; 0x5e
      isrflags = READ_REG(huart->Instance->ISR);
 8030520:	69dd      	ldr	r5, [r3, #28]
      if ((isrflags & (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE)) != 0U)
 8030522:	0769      	lsls	r1, r5, #29
 8030524:	d02a      	beq.n	803057c <UART_RxISR_16BIT_FIFOEN+0xf0>
        if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 8030526:	07ea      	lsls	r2, r5, #31
 8030528:	d50a      	bpl.n	8030540 <UART_RxISR_16BIT_FIFOEN+0xb4>
 803052a:	f418 7f80 	tst.w	r8, #256	; 0x100
 803052e:	d007      	beq.n	8030540 <UART_RxISR_16BIT_FIFOEN+0xb4>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 8030530:	2201      	movs	r2, #1
 8030532:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_PE;
 8030534:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 8030538:	f042 0201 	orr.w	r2, r2, #1
 803053c:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
        if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8030540:	07a8      	lsls	r0, r5, #30
 8030542:	d508      	bpl.n	8030556 <UART_RxISR_16BIT_FIFOEN+0xca>
 8030544:	b13e      	cbz	r6, 8030556 <UART_RxISR_16BIT_FIFOEN+0xca>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 8030546:	2202      	movs	r2, #2
 8030548:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_FE;
 803054a:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 803054e:	f042 0204 	orr.w	r2, r2, #4
 8030552:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8030556:	0769      	lsls	r1, r5, #29
 8030558:	d508      	bpl.n	803056c <UART_RxISR_16BIT_FIFOEN+0xe0>
 803055a:	b13e      	cbz	r6, 803056c <UART_RxISR_16BIT_FIFOEN+0xe0>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 803055c:	2204      	movs	r2, #4
 803055e:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_NE;
 8030560:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 8030564:	f043 0302 	orr.w	r3, r3, #2
 8030568:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
        if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 803056c:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 8030570:	b123      	cbz	r3, 803057c <UART_RxISR_16BIT_FIFOEN+0xf0>
          HAL_UART_ErrorCallback(huart);
 8030572:	4620      	mov	r0, r4
 8030574:	f7ff fcb3 	bl	802fede <HAL_UART_ErrorCallback>
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 8030578:	f8c4 a08c 	str.w	sl, [r4, #140]	; 0x8c
      if (huart->RxXferCount == 0U)
 803057c:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 8030580:	b29b      	uxth	r3, r3
 8030582:	2b00      	cmp	r3, #0
 8030584:	d199      	bne.n	80304ba <UART_RxISR_16BIT_FIFOEN+0x2e>
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8030586:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030588:	e852 3f00 	ldrex	r3, [r2]
 803058c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030590:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 8030594:	6823      	ldr	r3, [r4, #0]
 8030596:	2900      	cmp	r1, #0
 8030598:	d1f5      	bne.n	8030586 <UART_RxISR_16BIT_FIFOEN+0xfa>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 803059a:	f103 0208 	add.w	r2, r3, #8
 803059e:	e852 2f00 	ldrex	r2, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 80305a2:	ea02 020b 	and.w	r2, r2, fp
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80305a6:	f103 0008 	add.w	r0, r3, #8
 80305aa:	e840 2100 	strex	r1, r2, [r0]
 80305ae:	2900      	cmp	r1, #0
 80305b0:	d1f3      	bne.n	803059a <UART_RxISR_16BIT_FIFOEN+0x10e>
        huart->RxState = HAL_UART_STATE_READY;
 80305b2:	2220      	movs	r2, #32
 80305b4:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 80305b8:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
        huart->RxISR = NULL;
 80305ba:	6721      	str	r1, [r4, #112]	; 0x70
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 80305bc:	2a01      	cmp	r2, #1
 80305be:	d113      	bne.n	80305e8 <UART_RxISR_16BIT_FIFOEN+0x15c>
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80305c0:	66e1      	str	r1, [r4, #108]	; 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80305c2:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 80305c6:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80305ca:	e843 2100 	strex	r1, r2, [r3]
 80305ce:	2900      	cmp	r1, #0
 80305d0:	d1f7      	bne.n	80305c2 <UART_RxISR_16BIT_FIFOEN+0x136>
          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 80305d2:	69da      	ldr	r2, [r3, #28]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 80305d4:	f8b4 105c 	ldrh.w	r1, [r4, #92]	; 0x5c
          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 80305d8:	06d2      	lsls	r2, r2, #27
            __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 80305da:	bf44      	itt	mi
 80305dc:	2210      	movmi	r2, #16
 80305de:	621a      	strmi	r2, [r3, #32]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 80305e0:	4620      	mov	r0, r4
 80305e2:	f7ff fcac 	bl	802ff3e <HAL_UARTEx_RxEventCallback>
 80305e6:	e768      	b.n	80304ba <UART_RxISR_16BIT_FIFOEN+0x2e>
          HAL_UART_RxCpltCallback(huart);
 80305e8:	4620      	mov	r0, r4
 80305ea:	f7fc fa87 	bl	802cafc <HAL_UART_RxCpltCallback>
 80305ee:	e764      	b.n	80304ba <UART_RxISR_16BIT_FIFOEN+0x2e>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 80305f0:	699a      	ldr	r2, [r3, #24]
 80305f2:	f042 0208 	orr.w	r2, r2, #8
 80305f6:	619a      	str	r2, [r3, #24]
}
 80305f8:	e783      	b.n	8030502 <UART_RxISR_16BIT_FIFOEN+0x76>
 80305fa:	bf00      	nop
 80305fc:	08030291 	.word	0x08030291
 8030600:	effffffe 	.word	0xeffffffe

08030604 <UART_SetConfig>:
{
 8030604:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8030606:	4604      	mov	r4, r0
  if (UART_INSTANCE_LOWPOWER(huart))
 8030608:	6803      	ldr	r3, [r0, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 803060a:	6921      	ldr	r1, [r4, #16]
 803060c:	68a2      	ldr	r2, [r4, #8]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 803060e:	681d      	ldr	r5, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8030610:	69c0      	ldr	r0, [r0, #28]
 8030612:	430a      	orrs	r2, r1
 8030614:	6961      	ldr	r1, [r4, #20]
 8030616:	430a      	orrs	r2, r1
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8030618:	497f      	ldr	r1, [pc, #508]	; (8030818 <UART_SetConfig+0x214>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 803061a:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 803061c:	4029      	ands	r1, r5
 803061e:	430a      	orrs	r2, r1
 8030620:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8030622:	685a      	ldr	r2, [r3, #4]
 8030624:	68e1      	ldr	r1, [r4, #12]
 8030626:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 803062a:	430a      	orrs	r2, r1
 803062c:	605a      	str	r2, [r3, #4]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 803062e:	4a7b      	ldr	r2, [pc, #492]	; (803081c <UART_SetConfig+0x218>)
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 8030630:	69a1      	ldr	r1, [r4, #24]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 8030632:	4293      	cmp	r3, r2
    tmpreg |= huart->Init.OneBitSampling;
 8030634:	bf1c      	itt	ne
 8030636:	6a22      	ldrne	r2, [r4, #32]
 8030638:	4311      	orrne	r1, r2
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 803063a:	689a      	ldr	r2, [r3, #8]
 803063c:	f022 426e 	bic.w	r2, r2, #3992977408	; 0xee000000
 8030640:	f422 6230 	bic.w	r2, r2, #2816	; 0xb00
 8030644:	430a      	orrs	r2, r1
 8030646:	609a      	str	r2, [r3, #8]
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 8030648:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 803064a:	6a61      	ldr	r1, [r4, #36]	; 0x24
 803064c:	f022 020f 	bic.w	r2, r2, #15
 8030650:	430a      	orrs	r2, r1
 8030652:	62da      	str	r2, [r3, #44]	; 0x2c
  UART_GETCLOCKSOURCE(huart, clocksource);
 8030654:	4a72      	ldr	r2, [pc, #456]	; (8030820 <UART_SetConfig+0x21c>)
 8030656:	4293      	cmp	r3, r2
 8030658:	d11c      	bne.n	8030694 <UART_SetConfig+0x90>
  return (uint32_t)(READ_BIT(RCC->CCIPR, USARTx) | (USARTx << 16));
 803065a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 803065e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8030662:	f003 0303 	and.w	r3, r3, #3
 8030666:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
 803066a:	f5a3 3340 	sub.w	r3, r3, #196608	; 0x30000
 803066e:	3b01      	subs	r3, #1
 8030670:	2b02      	cmp	r3, #2
 8030672:	f200 80cb 	bhi.w	803080c <UART_SetConfig+0x208>
 8030676:	4a6b      	ldr	r2, [pc, #428]	; (8030824 <UART_SetConfig+0x220>)
 8030678:	5c9b      	ldrb	r3, [r3, r2]
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 803067a:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 803067e:	f040 808c 	bne.w	803079a <UART_SetConfig+0x196>
    switch (clocksource)
 8030682:	2b08      	cmp	r3, #8
 8030684:	d824      	bhi.n	80306d0 <UART_SetConfig+0xcc>
 8030686:	e8df f003 	tbb	[pc, r3]
 803068a:	c462      	.short	0xc462
 803068c:	23832386 	.word	0x23832386
 8030690:	2323      	.short	0x2323
 8030692:	66          	.byte	0x66
 8030693:	00          	.byte	0x00
  UART_GETCLOCKSOURCE(huart, clocksource);
 8030694:	4a64      	ldr	r2, [pc, #400]	; (8030828 <UART_SetConfig+0x224>)
 8030696:	4293      	cmp	r3, r2
 8030698:	d109      	bne.n	80306ae <UART_SetConfig+0xaa>
 803069a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 803069e:	4a63      	ldr	r2, [pc, #396]	; (803082c <UART_SetConfig+0x228>)
 80306a0:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80306a4:	f003 030c 	and.w	r3, r3, #12
 80306a8:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
 80306ac:	e7e4      	b.n	8030678 <UART_SetConfig+0x74>
 80306ae:	4a5b      	ldr	r2, [pc, #364]	; (803081c <UART_SetConfig+0x218>)
 80306b0:	4293      	cmp	r3, r2
 80306b2:	d10d      	bne.n	80306d0 <UART_SetConfig+0xcc>
  return (uint32_t)(READ_BIT(RCC->CCIPR, LPUARTx));
 80306b4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80306b8:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80306bc:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
 80306c0:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 80306c4:	d01a      	beq.n	80306fc <UART_SetConfig+0xf8>
 80306c6:	d805      	bhi.n	80306d4 <UART_SetConfig+0xd0>
 80306c8:	b153      	cbz	r3, 80306e0 <UART_SetConfig+0xdc>
 80306ca:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80306ce:	d012      	beq.n	80306f6 <UART_SetConfig+0xf2>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80306d0:	2001      	movs	r0, #1
 80306d2:	e009      	b.n	80306e8 <UART_SetConfig+0xe4>
  UART_GETCLOCKSOURCE(huart, clocksource);
 80306d4:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 80306d8:	d1fa      	bne.n	80306d0 <UART_SetConfig+0xcc>
        pclk = (uint32_t) LSE_VALUE;
 80306da:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 80306de:	e00e      	b.n	80306fe <UART_SetConfig+0xfa>
        pclk = HAL_RCC_GetPCLK1Freq();
 80306e0:	f7fe fd40 	bl	802f164 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 80306e4:	b958      	cbnz	r0, 80306fe <UART_SetConfig+0xfa>
 80306e6:	2000      	movs	r0, #0
  huart->NbRxDataToProcess = 1;
 80306e8:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 80306ec:	66a3      	str	r3, [r4, #104]	; 0x68
  huart->RxISR = NULL;
 80306ee:	2300      	movs	r3, #0
  huart->TxISR = NULL;
 80306f0:	e9c4 331c 	strd	r3, r3, [r4, #112]	; 0x70
}
 80306f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        pclk = HAL_RCC_GetSysClockFreq();
 80306f6:	f7fe f91f 	bl	802e938 <HAL_RCC_GetSysClockFreq>
        break;
 80306fa:	e7f3      	b.n	80306e4 <UART_SetConfig+0xe0>
  UART_GETCLOCKSOURCE(huart, clocksource);
 80306fc:	484c      	ldr	r0, [pc, #304]	; (8030830 <UART_SetConfig+0x22c>)
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 80306fe:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8030700:	4b48      	ldr	r3, [pc, #288]	; (8030824 <UART_SetConfig+0x220>)
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 8030702:	6865      	ldr	r5, [r4, #4]
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 8030704:	eb03 0342 	add.w	r3, r3, r2, lsl #1
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 8030708:	eb05 0145 	add.w	r1, r5, r5, lsl #1
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 803070c:	8a1a      	ldrh	r2, [r3, #16]
 803070e:	fbb0 f3f2 	udiv	r3, r0, r2
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 8030712:	4299      	cmp	r1, r3
 8030714:	d8dc      	bhi.n	80306d0 <UART_SetConfig+0xcc>
 8030716:	ebb3 3f05 	cmp.w	r3, r5, lsl #12
 803071a:	d8d9      	bhi.n	80306d0 <UART_SetConfig+0xcc>
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803071c:	2300      	movs	r3, #0
 803071e:	2100      	movs	r1, #0
 8030720:	f7fb fa10 	bl	802bb44 <__aeabi_uldivmod>
 8030724:	020f      	lsls	r7, r1, #8
 8030726:	ea47 6710 	orr.w	r7, r7, r0, lsr #24
 803072a:	0206      	lsls	r6, r0, #8
 803072c:	0868      	lsrs	r0, r5, #1
 803072e:	1830      	adds	r0, r6, r0
 8030730:	462a      	mov	r2, r5
 8030732:	f04f 0300 	mov.w	r3, #0
 8030736:	f147 0100 	adc.w	r1, r7, #0
 803073a:	f7fb fa03 	bl	802bb44 <__aeabi_uldivmod>
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 803073e:	4b3d      	ldr	r3, [pc, #244]	; (8030834 <UART_SetConfig+0x230>)
 8030740:	f5a0 7240 	sub.w	r2, r0, #768	; 0x300
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8030744:	429a      	cmp	r2, r3
 8030746:	d8c3      	bhi.n	80306d0 <UART_SetConfig+0xcc>
        huart->Instance->BRR = usartdiv;
 8030748:	6823      	ldr	r3, [r4, #0]
 803074a:	60d8      	str	r0, [r3, #12]
 803074c:	e7cb      	b.n	80306e6 <UART_SetConfig+0xe2>
        pclk = HAL_RCC_GetPCLK1Freq();
 803074e:	f7fe fd09 	bl	802f164 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 8030752:	2800      	cmp	r0, #0
 8030754:	d0c7      	beq.n	80306e6 <UART_SetConfig+0xe2>
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8030756:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8030758:	4b32      	ldr	r3, [pc, #200]	; (8030824 <UART_SetConfig+0x220>)
 803075a:	6862      	ldr	r2, [r4, #4]
 803075c:	eb03 0341 	add.w	r3, r3, r1, lsl #1
 8030760:	8a1b      	ldrh	r3, [r3, #16]
 8030762:	fbb0 f3f3 	udiv	r3, r0, r3
 8030766:	0850      	lsrs	r0, r2, #1
 8030768:	eb00 0043 	add.w	r0, r0, r3, lsl #1
 803076c:	fbb0 f0f2 	udiv	r0, r0, r2
 8030770:	b283      	uxth	r3, r0
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8030772:	f1a3 0110 	sub.w	r1, r3, #16
 8030776:	f64f 72ef 	movw	r2, #65519	; 0xffef
 803077a:	4291      	cmp	r1, r2
 803077c:	d8a8      	bhi.n	80306d0 <UART_SetConfig+0xcc>
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 803077e:	f020 000f 	bic.w	r0, r0, #15
        huart->Instance->BRR = brrtemp;
 8030782:	6822      	ldr	r2, [r4, #0]
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 8030784:	b280      	uxth	r0, r0
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 8030786:	f3c3 0342 	ubfx	r3, r3, #1, #3
        huart->Instance->BRR = brrtemp;
 803078a:	4318      	orrs	r0, r3
 803078c:	60d0      	str	r0, [r2, #12]
 803078e:	e7aa      	b.n	80306e6 <UART_SetConfig+0xe2>
        pclk = HAL_RCC_GetSysClockFreq();
 8030790:	f7fe f8d2 	bl	802e938 <HAL_RCC_GetSysClockFreq>
        break;
 8030794:	e7dd      	b.n	8030752 <UART_SetConfig+0x14e>
        pclk = (uint32_t) HSI_VALUE;
 8030796:	4826      	ldr	r0, [pc, #152]	; (8030830 <UART_SetConfig+0x22c>)
 8030798:	e7dd      	b.n	8030756 <UART_SetConfig+0x152>
    switch (clocksource)
 803079a:	2b08      	cmp	r3, #8
 803079c:	d898      	bhi.n	80306d0 <UART_SetConfig+0xcc>
 803079e:	a201      	add	r2, pc, #4	; (adr r2, 80307a4 <UART_SetConfig+0x1a0>)
 80307a0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80307a4:	080307f1 	.word	0x080307f1
 80307a8:	080307fd 	.word	0x080307fd
 80307ac:	08030809 	.word	0x08030809
 80307b0:	080306d1 	.word	0x080306d1
 80307b4:	08030803 	.word	0x08030803
 80307b8:	080306d1 	.word	0x080306d1
 80307bc:	080306d1 	.word	0x080306d1
 80307c0:	080306d1 	.word	0x080306d1
 80307c4:	080307c9 	.word	0x080307c9
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80307c8:	f44f 4000 	mov.w	r0, #32768	; 0x8000
      usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 80307cc:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80307ce:	4b15      	ldr	r3, [pc, #84]	; (8030824 <UART_SetConfig+0x220>)
 80307d0:	6862      	ldr	r2, [r4, #4]
 80307d2:	eb03 0341 	add.w	r3, r3, r1, lsl #1
 80307d6:	8a1b      	ldrh	r3, [r3, #16]
 80307d8:	fbb0 f0f3 	udiv	r0, r0, r3
 80307dc:	eb00 0052 	add.w	r0, r0, r2, lsr #1
 80307e0:	fbb0 f0f2 	udiv	r0, r0, r2
 80307e4:	b280      	uxth	r0, r0
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 80307e6:	f1a0 0210 	sub.w	r2, r0, #16
 80307ea:	f64f 73ef 	movw	r3, #65519	; 0xffef
 80307ee:	e7a9      	b.n	8030744 <UART_SetConfig+0x140>
        pclk = HAL_RCC_GetPCLK1Freq();
 80307f0:	f7fe fcb8 	bl	802f164 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 80307f4:	2800      	cmp	r0, #0
 80307f6:	f43f af76 	beq.w	80306e6 <UART_SetConfig+0xe2>
 80307fa:	e7e7      	b.n	80307cc <UART_SetConfig+0x1c8>
        pclk = HAL_RCC_GetPCLK2Freq();
 80307fc:	f7fe fcc2 	bl	802f184 <HAL_RCC_GetPCLK2Freq>
        break;
 8030800:	e7f8      	b.n	80307f4 <UART_SetConfig+0x1f0>
        pclk = HAL_RCC_GetSysClockFreq();
 8030802:	f7fe f899 	bl	802e938 <HAL_RCC_GetSysClockFreq>
        break;
 8030806:	e7f5      	b.n	80307f4 <UART_SetConfig+0x1f0>
        pclk = (uint32_t) HSI_VALUE;
 8030808:	4809      	ldr	r0, [pc, #36]	; (8030830 <UART_SetConfig+0x22c>)
 803080a:	e7df      	b.n	80307cc <UART_SetConfig+0x1c8>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 803080c:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 8030810:	d1f4      	bne.n	80307fc <UART_SetConfig+0x1f8>
        pclk = HAL_RCC_GetPCLK2Freq();
 8030812:	f7fe fcb7 	bl	802f184 <HAL_RCC_GetPCLK2Freq>
        break;
 8030816:	e79c      	b.n	8030752 <UART_SetConfig+0x14e>
 8030818:	cfff69f3 	.word	0xcfff69f3
 803081c:	40008000 	.word	0x40008000
 8030820:	40013800 	.word	0x40013800
 8030824:	0803ba70 	.word	0x0803ba70
 8030828:	40004400 	.word	0x40004400
 803082c:	07f7ba73 	.word	0x07f7ba73
 8030830:	00f42400 	.word	0x00f42400
 8030834:	000ffcff 	.word	0x000ffcff

08030838 <UART_AdvFeatureConfig>:
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 8030838:	6a83      	ldr	r3, [r0, #40]	; 0x28
 803083a:	07da      	lsls	r2, r3, #31
{
 803083c:	b510      	push	{r4, lr}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 803083e:	d506      	bpl.n	803084e <UART_AdvFeatureConfig+0x16>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 8030840:	6801      	ldr	r1, [r0, #0]
 8030842:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 8030844:	684a      	ldr	r2, [r1, #4]
 8030846:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 803084a:	4322      	orrs	r2, r4
 803084c:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 803084e:	079c      	lsls	r4, r3, #30
 8030850:	d506      	bpl.n	8030860 <UART_AdvFeatureConfig+0x28>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 8030852:	6801      	ldr	r1, [r0, #0]
 8030854:	6b04      	ldr	r4, [r0, #48]	; 0x30
 8030856:	684a      	ldr	r2, [r1, #4]
 8030858:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 803085c:	4322      	orrs	r2, r4
 803085e:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 8030860:	0759      	lsls	r1, r3, #29
 8030862:	d506      	bpl.n	8030872 <UART_AdvFeatureConfig+0x3a>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 8030864:	6801      	ldr	r1, [r0, #0]
 8030866:	6b44      	ldr	r4, [r0, #52]	; 0x34
 8030868:	684a      	ldr	r2, [r1, #4]
 803086a:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 803086e:	4322      	orrs	r2, r4
 8030870:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 8030872:	071a      	lsls	r2, r3, #28
 8030874:	d506      	bpl.n	8030884 <UART_AdvFeatureConfig+0x4c>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 8030876:	6801      	ldr	r1, [r0, #0]
 8030878:	6b84      	ldr	r4, [r0, #56]	; 0x38
 803087a:	684a      	ldr	r2, [r1, #4]
 803087c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8030880:	4322      	orrs	r2, r4
 8030882:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 8030884:	06dc      	lsls	r4, r3, #27
 8030886:	d506      	bpl.n	8030896 <UART_AdvFeatureConfig+0x5e>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 8030888:	6801      	ldr	r1, [r0, #0]
 803088a:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 803088c:	688a      	ldr	r2, [r1, #8]
 803088e:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8030892:	4322      	orrs	r2, r4
 8030894:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 8030896:	0699      	lsls	r1, r3, #26
 8030898:	d506      	bpl.n	80308a8 <UART_AdvFeatureConfig+0x70>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 803089a:	6801      	ldr	r1, [r0, #0]
 803089c:	6c04      	ldr	r4, [r0, #64]	; 0x40
 803089e:	688a      	ldr	r2, [r1, #8]
 80308a0:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 80308a4:	4322      	orrs	r2, r4
 80308a6:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 80308a8:	065a      	lsls	r2, r3, #25
 80308aa:	d50f      	bpl.n	80308cc <UART_AdvFeatureConfig+0x94>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 80308ac:	6801      	ldr	r1, [r0, #0]
 80308ae:	6c44      	ldr	r4, [r0, #68]	; 0x44
 80308b0:	684a      	ldr	r2, [r1, #4]
 80308b2:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 80308b6:	4322      	orrs	r2, r4
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 80308b8:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 80308bc:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 80308be:	d105      	bne.n	80308cc <UART_AdvFeatureConfig+0x94>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 80308c0:	684a      	ldr	r2, [r1, #4]
 80308c2:	6c84      	ldr	r4, [r0, #72]	; 0x48
 80308c4:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
 80308c8:	4322      	orrs	r2, r4
 80308ca:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 80308cc:	061b      	lsls	r3, r3, #24
 80308ce:	d506      	bpl.n	80308de <UART_AdvFeatureConfig+0xa6>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 80308d0:	6802      	ldr	r2, [r0, #0]
 80308d2:	6cc1      	ldr	r1, [r0, #76]	; 0x4c
 80308d4:	6853      	ldr	r3, [r2, #4]
 80308d6:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 80308da:	430b      	orrs	r3, r1
 80308dc:	6053      	str	r3, [r2, #4]
}
 80308de:	bd10      	pop	{r4, pc}

080308e0 <UART_WaitOnFlagUntilTimeout>:
{
 80308e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80308e4:	f8dd 8018 	ldr.w	r8, [sp, #24]
 80308e8:	4604      	mov	r4, r0
 80308ea:	460e      	mov	r6, r1
 80308ec:	4615      	mov	r5, r2
 80308ee:	461f      	mov	r7, r3
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 80308f0:	6822      	ldr	r2, [r4, #0]
 80308f2:	69d3      	ldr	r3, [r2, #28]
 80308f4:	ea36 0303 	bics.w	r3, r6, r3
 80308f8:	bf0c      	ite	eq
 80308fa:	2301      	moveq	r3, #1
 80308fc:	2300      	movne	r3, #0
 80308fe:	42ab      	cmp	r3, r5
 8030900:	d001      	beq.n	8030906 <UART_WaitOnFlagUntilTimeout+0x26>
  return HAL_OK;
 8030902:	2000      	movs	r0, #0
 8030904:	e027      	b.n	8030956 <UART_WaitOnFlagUntilTimeout+0x76>
    if (Timeout != HAL_MAX_DELAY)
 8030906:	f1b8 3fff 	cmp.w	r8, #4294967295
 803090a:	d0f2      	beq.n	80308f2 <UART_WaitOnFlagUntilTimeout+0x12>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 803090c:	f7fb fe9a 	bl	802c644 <HAL_GetTick>
 8030910:	1bc0      	subs	r0, r0, r7
 8030912:	4540      	cmp	r0, r8
 8030914:	6820      	ldr	r0, [r4, #0]
 8030916:	d802      	bhi.n	803091e <UART_WaitOnFlagUntilTimeout+0x3e>
 8030918:	f1b8 0f00 	cmp.w	r8, #0
 803091c:	d11d      	bne.n	803095a <UART_WaitOnFlagUntilTimeout+0x7a>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 803091e:	e850 3f00 	ldrex	r3, [r0]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |
 8030922:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030926:	e840 3200 	strex	r2, r3, [r0]
 803092a:	2a00      	cmp	r2, #0
 803092c:	d1f7      	bne.n	803091e <UART_WaitOnFlagUntilTimeout+0x3e>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 803092e:	f100 0308 	add.w	r3, r0, #8
 8030932:	e853 3f00 	ldrex	r3, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8030936:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 803093a:	f100 0108 	add.w	r1, r0, #8
 803093e:	e841 3200 	strex	r2, r3, [r1]
 8030942:	2a00      	cmp	r2, #0
 8030944:	d1f3      	bne.n	803092e <UART_WaitOnFlagUntilTimeout+0x4e>
        huart->gState = HAL_UART_STATE_READY;
 8030946:	2320      	movs	r3, #32
 8030948:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
        huart->RxState = HAL_UART_STATE_READY;
 803094c:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
          __HAL_UNLOCK(huart);
 8030950:	f884 2080 	strb.w	r2, [r4, #128]	; 0x80
          return HAL_TIMEOUT;
 8030954:	2003      	movs	r0, #3
}
 8030956:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 803095a:	6803      	ldr	r3, [r0, #0]
 803095c:	075a      	lsls	r2, r3, #29
 803095e:	d5c7      	bpl.n	80308f0 <UART_WaitOnFlagUntilTimeout+0x10>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 8030960:	69c3      	ldr	r3, [r0, #28]
 8030962:	051b      	lsls	r3, r3, #20
 8030964:	d5c4      	bpl.n	80308f0 <UART_WaitOnFlagUntilTimeout+0x10>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 8030966:	f44f 6300 	mov.w	r3, #2048	; 0x800
 803096a:	6203      	str	r3, [r0, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 803096c:	e850 3f00 	ldrex	r3, [r0]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |
 8030970:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030974:	e840 3200 	strex	r2, r3, [r0]
 8030978:	2a00      	cmp	r2, #0
 803097a:	d1f7      	bne.n	803096c <UART_WaitOnFlagUntilTimeout+0x8c>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 803097c:	f100 0308 	add.w	r3, r0, #8
 8030980:	e853 3f00 	ldrex	r3, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8030984:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030988:	f100 0108 	add.w	r1, r0, #8
 803098c:	e841 3200 	strex	r2, r3, [r1]
 8030990:	2a00      	cmp	r2, #0
 8030992:	d1f3      	bne.n	803097c <UART_WaitOnFlagUntilTimeout+0x9c>
          huart->gState = HAL_UART_STATE_READY;
 8030994:	2320      	movs	r3, #32
 8030996:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
          huart->RxState = HAL_UART_STATE_READY;
 803099a:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 803099e:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
 80309a2:	e7d5      	b.n	8030950 <UART_WaitOnFlagUntilTimeout+0x70>

080309a4 <UART_CheckIdleState>:
{
 80309a4:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80309a6:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 80309a8:	2600      	movs	r6, #0
 80309aa:	f8c0 608c 	str.w	r6, [r0, #140]	; 0x8c
  tickstart = HAL_GetTick();
 80309ae:	f7fb fe49 	bl	802c644 <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 80309b2:	6823      	ldr	r3, [r4, #0]
 80309b4:	681b      	ldr	r3, [r3, #0]
 80309b6:	071a      	lsls	r2, r3, #28
  tickstart = HAL_GetTick();
 80309b8:	4605      	mov	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 80309ba:	d418      	bmi.n	80309ee <UART_CheckIdleState+0x4a>
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 80309bc:	6823      	ldr	r3, [r4, #0]
 80309be:	681b      	ldr	r3, [r3, #0]
 80309c0:	075b      	lsls	r3, r3, #29
 80309c2:	d50a      	bpl.n	80309da <UART_CheckIdleState+0x36>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 80309c4:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 80309c8:	9300      	str	r3, [sp, #0]
 80309ca:	2200      	movs	r2, #0
 80309cc:	462b      	mov	r3, r5
 80309ce:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 80309d2:	4620      	mov	r0, r4
 80309d4:	f7ff ff84 	bl	80308e0 <UART_WaitOnFlagUntilTimeout>
 80309d8:	b9a8      	cbnz	r0, 8030a06 <UART_CheckIdleState+0x62>
  huart->gState = HAL_UART_STATE_READY;
 80309da:	2320      	movs	r3, #32
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80309dc:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
 80309de:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  __HAL_UNLOCK(huart);
 80309e2:	f884 0080 	strb.w	r0, [r4, #128]	; 0x80
  huart->RxState = HAL_UART_STATE_READY;
 80309e6:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80309ea:	66e0      	str	r0, [r4, #108]	; 0x6c
  return HAL_OK;
 80309ec:	e00c      	b.n	8030a08 <UART_CheckIdleState+0x64>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 80309ee:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 80309f2:	9300      	str	r3, [sp, #0]
 80309f4:	4632      	mov	r2, r6
 80309f6:	4603      	mov	r3, r0
 80309f8:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 80309fc:	4620      	mov	r0, r4
 80309fe:	f7ff ff6f 	bl	80308e0 <UART_WaitOnFlagUntilTimeout>
 8030a02:	2800      	cmp	r0, #0
 8030a04:	d0da      	beq.n	80309bc <UART_CheckIdleState+0x18>
      return HAL_TIMEOUT;
 8030a06:	2003      	movs	r0, #3
}
 8030a08:	b002      	add	sp, #8
 8030a0a:	bd70      	pop	{r4, r5, r6, pc}

08030a0c <HAL_UART_Init>:
{
 8030a0c:	b510      	push	{r4, lr}
  if (huart == NULL)
 8030a0e:	4604      	mov	r4, r0
 8030a10:	b350      	cbz	r0, 8030a68 <HAL_UART_Init+0x5c>
  if (huart->gState == HAL_UART_STATE_RESET)
 8030a12:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
 8030a16:	b91b      	cbnz	r3, 8030a20 <HAL_UART_Init+0x14>
    huart->Lock = HAL_UNLOCKED;
 8030a18:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
    HAL_UART_MspInit(huart);
 8030a1c:	f7fb ff6c 	bl	802c8f8 <HAL_UART_MspInit>
  __HAL_UART_DISABLE(huart);
 8030a20:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 8030a22:	2324      	movs	r3, #36	; 0x24
 8030a24:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  __HAL_UART_DISABLE(huart);
 8030a28:	6813      	ldr	r3, [r2, #0]
 8030a2a:	f023 0301 	bic.w	r3, r3, #1
 8030a2e:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 8030a30:	4620      	mov	r0, r4
 8030a32:	f7ff fde7 	bl	8030604 <UART_SetConfig>
 8030a36:	2801      	cmp	r0, #1
 8030a38:	d016      	beq.n	8030a68 <HAL_UART_Init+0x5c>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 8030a3a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8030a3c:	b113      	cbz	r3, 8030a44 <HAL_UART_Init+0x38>
    UART_AdvFeatureConfig(huart);
 8030a3e:	4620      	mov	r0, r4
 8030a40:	f7ff fefa 	bl	8030838 <UART_AdvFeatureConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8030a44:	6823      	ldr	r3, [r4, #0]
 8030a46:	685a      	ldr	r2, [r3, #4]
 8030a48:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 8030a4c:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8030a4e:	689a      	ldr	r2, [r3, #8]
 8030a50:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 8030a54:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 8030a56:	681a      	ldr	r2, [r3, #0]
 8030a58:	f042 0201 	orr.w	r2, r2, #1
  return (UART_CheckIdleState(huart));
 8030a5c:	4620      	mov	r0, r4
  __HAL_UART_ENABLE(huart);
 8030a5e:	601a      	str	r2, [r3, #0]
}
 8030a60:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return (UART_CheckIdleState(huart));
 8030a64:	f7ff bf9e 	b.w	80309a4 <UART_CheckIdleState>
}
 8030a68:	2001      	movs	r0, #1
 8030a6a:	bd10      	pop	{r4, pc}

08030a6c <UART_Start_Receive_IT>:
  UART_MASK_COMPUTATION(huart);
 8030a6c:	6883      	ldr	r3, [r0, #8]
{
 8030a6e:	b510      	push	{r4, lr}
  UART_MASK_COMPUTATION(huart);
 8030a70:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
  huart->pRxBuffPtr  = pData;
 8030a74:	6581      	str	r1, [r0, #88]	; 0x58
  huart->RxISR       = NULL;
 8030a76:	f04f 0100 	mov.w	r1, #0
  huart->RxXferSize  = Size;
 8030a7a:	f8a0 205c 	strh.w	r2, [r0, #92]	; 0x5c
  huart->RxXferCount = Size;
 8030a7e:	f8a0 205e 	strh.w	r2, [r0, #94]	; 0x5e
  huart->RxISR       = NULL;
 8030a82:	6701      	str	r1, [r0, #112]	; 0x70
  UART_MASK_COMPUTATION(huart);
 8030a84:	d147      	bne.n	8030b16 <UART_Start_Receive_IT+0xaa>
 8030a86:	6903      	ldr	r3, [r0, #16]
 8030a88:	2b00      	cmp	r3, #0
 8030a8a:	d142      	bne.n	8030b12 <UART_Start_Receive_IT+0xa6>
 8030a8c:	f240 13ff 	movw	r3, #511	; 0x1ff
 8030a90:	f8a0 3060 	strh.w	r3, [r0, #96]	; 0x60
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8030a94:	2300      	movs	r3, #0
 8030a96:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
  huart->RxState = HAL_UART_STATE_BUSY_RX;
 8030a9a:	2322      	movs	r3, #34	; 0x22
 8030a9c:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
  ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8030aa0:	6801      	ldr	r1, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030aa2:	f101 0308 	add.w	r3, r1, #8
 8030aa6:	e853 3f00 	ldrex	r3, [r3]
 8030aaa:	f043 0301 	orr.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030aae:	3108      	adds	r1, #8
 8030ab0:	e841 3400 	strex	r4, r3, [r1]
   return(result);
 8030ab4:	6803      	ldr	r3, [r0, #0]
 8030ab6:	2c00      	cmp	r4, #0
 8030ab8:	d1f2      	bne.n	8030aa0 <UART_Start_Receive_IT+0x34>
  if ((huart->FifoMode == UART_FIFOMODE_ENABLE) && (Size >= huart->NbRxDataToProcess))
 8030aba:	6e44      	ldr	r4, [r0, #100]	; 0x64
 8030abc:	6881      	ldr	r1, [r0, #8]
 8030abe:	f1b4 5f00 	cmp.w	r4, #536870912	; 0x20000000
 8030ac2:	d13b      	bne.n	8030b3c <UART_Start_Receive_IT+0xd0>
 8030ac4:	f8b0 4068 	ldrh.w	r4, [r0, #104]	; 0x68
 8030ac8:	4294      	cmp	r4, r2
 8030aca:	d837      	bhi.n	8030b3c <UART_Start_Receive_IT+0xd0>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8030acc:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 8030ad0:	d132      	bne.n	8030b38 <UART_Start_Receive_IT+0xcc>
 8030ad2:	6904      	ldr	r4, [r0, #16]
      huart->RxISR = UART_RxISR_16BIT_FIFOEN;
 8030ad4:	4a25      	ldr	r2, [pc, #148]	; (8030b6c <UART_Start_Receive_IT+0x100>)
 8030ad6:	4926      	ldr	r1, [pc, #152]	; (8030b70 <UART_Start_Receive_IT+0x104>)
 8030ad8:	2c00      	cmp	r4, #0
 8030ada:	bf08      	it	eq
 8030adc:	460a      	moveq	r2, r1
 8030ade:	6702      	str	r2, [r0, #112]	; 0x70
    __HAL_UNLOCK(huart);
 8030ae0:	2200      	movs	r2, #0
 8030ae2:	f880 2080 	strb.w	r2, [r0, #128]	; 0x80
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030ae6:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8030aea:	f442 7280 	orr.w	r2, r2, #256	; 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030aee:	e843 2100 	strex	r1, r2, [r3]
 8030af2:	2900      	cmp	r1, #0
 8030af4:	d1f7      	bne.n	8030ae6 <UART_Start_Receive_IT+0x7a>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030af6:	f103 0208 	add.w	r2, r3, #8
 8030afa:	e852 2f00 	ldrex	r2, [r2]
    ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 8030afe:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030b02:	f103 0008 	add.w	r0, r3, #8
 8030b06:	e840 2100 	strex	r1, r2, [r0]
 8030b0a:	2900      	cmp	r1, #0
 8030b0c:	d1f3      	bne.n	8030af6 <UART_Start_Receive_IT+0x8a>
}
 8030b0e:	2000      	movs	r0, #0
 8030b10:	bd10      	pop	{r4, pc}
  UART_MASK_COMPUTATION(huart);
 8030b12:	23ff      	movs	r3, #255	; 0xff
 8030b14:	e7bc      	b.n	8030a90 <UART_Start_Receive_IT+0x24>
 8030b16:	b923      	cbnz	r3, 8030b22 <UART_Start_Receive_IT+0xb6>
 8030b18:	6903      	ldr	r3, [r0, #16]
 8030b1a:	2b00      	cmp	r3, #0
 8030b1c:	d0f9      	beq.n	8030b12 <UART_Start_Receive_IT+0xa6>
 8030b1e:	237f      	movs	r3, #127	; 0x7f
 8030b20:	e7b6      	b.n	8030a90 <UART_Start_Receive_IT+0x24>
 8030b22:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8030b26:	d104      	bne.n	8030b32 <UART_Start_Receive_IT+0xc6>
 8030b28:	6903      	ldr	r3, [r0, #16]
 8030b2a:	2b00      	cmp	r3, #0
 8030b2c:	d0f7      	beq.n	8030b1e <UART_Start_Receive_IT+0xb2>
 8030b2e:	233f      	movs	r3, #63	; 0x3f
 8030b30:	e7ae      	b.n	8030a90 <UART_Start_Receive_IT+0x24>
 8030b32:	f8a0 1060 	strh.w	r1, [r0, #96]	; 0x60
 8030b36:	e7ad      	b.n	8030a94 <UART_Start_Receive_IT+0x28>
      huart->RxISR = UART_RxISR_8BIT_FIFOEN;
 8030b38:	4a0c      	ldr	r2, [pc, #48]	; (8030b6c <UART_Start_Receive_IT+0x100>)
 8030b3a:	e7d0      	b.n	8030ade <UART_Start_Receive_IT+0x72>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8030b3c:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 8030b40:	d112      	bne.n	8030b68 <UART_Start_Receive_IT+0xfc>
 8030b42:	6904      	ldr	r4, [r0, #16]
      huart->RxISR = UART_RxISR_16BIT;
 8030b44:	4a0b      	ldr	r2, [pc, #44]	; (8030b74 <UART_Start_Receive_IT+0x108>)
 8030b46:	490c      	ldr	r1, [pc, #48]	; (8030b78 <UART_Start_Receive_IT+0x10c>)
 8030b48:	2c00      	cmp	r4, #0
 8030b4a:	bf08      	it	eq
 8030b4c:	460a      	moveq	r2, r1
 8030b4e:	6702      	str	r2, [r0, #112]	; 0x70
    __HAL_UNLOCK(huart);
 8030b50:	2200      	movs	r2, #0
 8030b52:	f880 2080 	strb.w	r2, [r0, #128]	; 0x80
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030b56:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE);
 8030b5a:	f442 7290 	orr.w	r2, r2, #288	; 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030b5e:	e843 2100 	strex	r1, r2, [r3]
 8030b62:	2900      	cmp	r1, #0
 8030b64:	d1f7      	bne.n	8030b56 <UART_Start_Receive_IT+0xea>
 8030b66:	e7d2      	b.n	8030b0e <UART_Start_Receive_IT+0xa2>
      huart->RxISR = UART_RxISR_8BIT;
 8030b68:	4a02      	ldr	r2, [pc, #8]	; (8030b74 <UART_Start_Receive_IT+0x108>)
 8030b6a:	e7f0      	b.n	8030b4e <UART_Start_Receive_IT+0xe2>
 8030b6c:	08030311 	.word	0x08030311
 8030b70:	0803048d 	.word	0x0803048d
 8030b74:	080302cd 	.word	0x080302cd
 8030b78:	08030291 	.word	0x08030291

08030b7c <HAL_UART_Receive_IT>:
  if (huart->RxState == HAL_UART_STATE_READY)
 8030b7c:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
 8030b80:	2b20      	cmp	r3, #32
{
 8030b82:	b430      	push	{r4, r5}
  if (huart->RxState == HAL_UART_STATE_READY)
 8030b84:	d11f      	bne.n	8030bc6 <HAL_UART_Receive_IT+0x4a>
    if ((pData == NULL) || (Size == 0U))
 8030b86:	b1d9      	cbz	r1, 8030bc0 <HAL_UART_Receive_IT+0x44>
 8030b88:	b1d2      	cbz	r2, 8030bc0 <HAL_UART_Receive_IT+0x44>
    __HAL_LOCK(huart);
 8030b8a:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 8030b8e:	2b01      	cmp	r3, #1
 8030b90:	d019      	beq.n	8030bc6 <HAL_UART_Receive_IT+0x4a>
 8030b92:	2301      	movs	r3, #1
 8030b94:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8030b98:	2300      	movs	r3, #0
    if (!(IS_LPUART_INSTANCE(huart->Instance)))
 8030b9a:	6804      	ldr	r4, [r0, #0]
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8030b9c:	66c3      	str	r3, [r0, #108]	; 0x6c
    if (!(IS_LPUART_INSTANCE(huart->Instance)))
 8030b9e:	4b0b      	ldr	r3, [pc, #44]	; (8030bcc <HAL_UART_Receive_IT+0x50>)
 8030ba0:	429c      	cmp	r4, r3
 8030ba2:	d00a      	beq.n	8030bba <HAL_UART_Receive_IT+0x3e>
      if(READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 8030ba4:	6863      	ldr	r3, [r4, #4]
 8030ba6:	021b      	lsls	r3, r3, #8
 8030ba8:	d507      	bpl.n	8030bba <HAL_UART_Receive_IT+0x3e>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030baa:	e854 3f00 	ldrex	r3, [r4]
        ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 8030bae:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030bb2:	e844 3500 	strex	r5, r3, [r4]
 8030bb6:	2d00      	cmp	r5, #0
 8030bb8:	d1f7      	bne.n	8030baa <HAL_UART_Receive_IT+0x2e>
}
 8030bba:	bc30      	pop	{r4, r5}
    return(UART_Start_Receive_IT(huart, pData, Size));
 8030bbc:	f7ff bf56 	b.w	8030a6c <UART_Start_Receive_IT>
      return HAL_ERROR;
 8030bc0:	2001      	movs	r0, #1
}
 8030bc2:	bc30      	pop	{r4, r5}
 8030bc4:	4770      	bx	lr
    return HAL_BUSY;
 8030bc6:	2002      	movs	r0, #2
 8030bc8:	e7fb      	b.n	8030bc2 <HAL_UART_Receive_IT+0x46>
 8030bca:	bf00      	nop
 8030bcc:	40008000 	.word	0x40008000

08030bd0 <UARTEx_SetNbDataToProcess>:
  uint8_t rx_fifo_threshold;
  uint8_t tx_fifo_threshold;
  static const uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
  static const uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};

  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 8030bd0:	6e43      	ldr	r3, [r0, #100]	; 0x64
{
 8030bd2:	b510      	push	{r4, lr}
  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 8030bd4:	b91b      	cbnz	r3, 8030bde <UARTEx_SetNbDataToProcess+0xe>
  {
    huart->NbTxDataToProcess = 1U;
    huart->NbRxDataToProcess = 1U;
 8030bd6:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 8030bda:	6683      	str	r3, [r0, #104]	; 0x68
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
                               (uint16_t)denominator[tx_fifo_threshold];
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
                               (uint16_t)denominator[rx_fifo_threshold];
  }
}
 8030bdc:	bd10      	pop	{r4, pc}
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
 8030bde:	6803      	ldr	r3, [r0, #0]
 8030be0:	689c      	ldr	r4, [r3, #8]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 8030be2:	689a      	ldr	r2, [r3, #8]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8030be4:	4b0a      	ldr	r3, [pc, #40]	; (8030c10 <UARTEx_SetNbDataToProcess+0x40>)
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 8030be6:	0f52      	lsrs	r2, r2, #29
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8030be8:	5c99      	ldrb	r1, [r3, r2]
                               (uint16_t)denominator[tx_fifo_threshold];
 8030bea:	441a      	add	r2, r3
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8030bec:	00c9      	lsls	r1, r1, #3
                               (uint16_t)denominator[tx_fifo_threshold];
 8030bee:	7a12      	ldrb	r2, [r2, #8]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8030bf0:	fbb1 f2f2 	udiv	r2, r1, r2
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8030bf4:	f3c4 6142 	ubfx	r1, r4, #25, #3
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8030bf8:	f8a0 206a 	strh.w	r2, [r0, #106]	; 0x6a
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8030bfc:	5c5a      	ldrb	r2, [r3, r1]
                               (uint16_t)denominator[rx_fifo_threshold];
 8030bfe:	440b      	add	r3, r1
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8030c00:	00d2      	lsls	r2, r2, #3
                               (uint16_t)denominator[rx_fifo_threshold];
 8030c02:	7a1b      	ldrb	r3, [r3, #8]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8030c04:	fbb2 f3f3 	udiv	r3, r2, r3
 8030c08:	f8a0 3068 	strh.w	r3, [r0, #104]	; 0x68
}
 8030c0c:	e7e6      	b.n	8030bdc <UARTEx_SetNbDataToProcess+0xc>
 8030c0e:	bf00      	nop
 8030c10:	0803ba98 	.word	0x0803ba98

08030c14 <HAL_UARTEx_WakeupCallback>:
}
 8030c14:	4770      	bx	lr

08030c16 <HAL_UARTEx_RxFifoFullCallback>:
 8030c16:	4770      	bx	lr

08030c18 <HAL_UARTEx_TxFifoEmptyCallback>:
 8030c18:	4770      	bx	lr

08030c1a <HAL_UARTEx_StopModeWakeUpSourceConfig>:
{
 8030c1a:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8030c1c:	ab04      	add	r3, sp, #16
 8030c1e:	e903 0006 	stmdb	r3, {r1, r2}
  __HAL_LOCK(huart);
 8030c22:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 8030c26:	9902      	ldr	r1, [sp, #8]
 8030c28:	2b01      	cmp	r3, #1
{
 8030c2a:	4604      	mov	r4, r0
  __HAL_LOCK(huart);
 8030c2c:	d03a      	beq.n	8030ca4 <HAL_UARTEx_StopModeWakeUpSourceConfig+0x8a>
 8030c2e:	2301      	movs	r3, #1
 8030c30:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
  huart->gState = HAL_UART_STATE_BUSY;
 8030c34:	2324      	movs	r3, #36	; 0x24
 8030c36:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  __HAL_UART_DISABLE(huart);
 8030c3a:	6803      	ldr	r3, [r0, #0]
 8030c3c:	681a      	ldr	r2, [r3, #0]
 8030c3e:	f022 0201 	bic.w	r2, r2, #1
 8030c42:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_WUS, WakeUpSelection.WakeUpEvent);
 8030c44:	689a      	ldr	r2, [r3, #8]
 8030c46:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8030c4a:	430a      	orrs	r2, r1
 8030c4c:	609a      	str	r2, [r3, #8]
  if (WakeUpSelection.WakeUpEvent == UART_WAKEUP_ON_ADDRESS)
 8030c4e:	b971      	cbnz	r1, 8030c6e <HAL_UARTEx_StopModeWakeUpSourceConfig+0x54>
  MODIFY_REG(huart->Instance->CR2, USART_CR2_ADDM7, WakeUpSelection.AddressLength);
 8030c50:	6859      	ldr	r1, [r3, #4]
 8030c52:	f8bd 200c 	ldrh.w	r2, [sp, #12]
    UARTEx_Wakeup_AddressConfig(huart, WakeUpSelection);
 8030c56:	f89d 000e 	ldrb.w	r0, [sp, #14]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_ADDM7, WakeUpSelection.AddressLength);
 8030c5a:	f021 0110 	bic.w	r1, r1, #16
 8030c5e:	4311      	orrs	r1, r2
 8030c60:	6059      	str	r1, [r3, #4]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, ((uint32_t)WakeUpSelection.Address << UART_CR2_ADDRESS_LSB_POS));
 8030c62:	685a      	ldr	r2, [r3, #4]
 8030c64:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 8030c68:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
 8030c6c:	605a      	str	r2, [r3, #4]
  __HAL_UART_ENABLE(huart);
 8030c6e:	681a      	ldr	r2, [r3, #0]
 8030c70:	f042 0201 	orr.w	r2, r2, #1
 8030c74:	601a      	str	r2, [r3, #0]
  tickstart = HAL_GetTick();
 8030c76:	f7fb fce5 	bl	802c644 <HAL_GetTick>
  if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8030c7a:	f06f 427e 	mvn.w	r2, #4261412864	; 0xfe000000
  tickstart = HAL_GetTick();
 8030c7e:	4603      	mov	r3, r0
  if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8030c80:	9200      	str	r2, [sp, #0]
 8030c82:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 8030c86:	2200      	movs	r2, #0
 8030c88:	4620      	mov	r0, r4
 8030c8a:	f7ff fe29 	bl	80308e0 <UART_WaitOnFlagUntilTimeout>
 8030c8e:	b938      	cbnz	r0, 8030ca0 <HAL_UARTEx_StopModeWakeUpSourceConfig+0x86>
    huart->gState = HAL_UART_STATE_READY;
 8030c90:	2320      	movs	r3, #32
 8030c92:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  __HAL_UNLOCK(huart);
 8030c96:	2300      	movs	r3, #0
 8030c98:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
}
 8030c9c:	b004      	add	sp, #16
 8030c9e:	bd10      	pop	{r4, pc}
    status = HAL_TIMEOUT;
 8030ca0:	2003      	movs	r0, #3
 8030ca2:	e7f8      	b.n	8030c96 <HAL_UARTEx_StopModeWakeUpSourceConfig+0x7c>
  __HAL_LOCK(huart);
 8030ca4:	2002      	movs	r0, #2
 8030ca6:	e7f9      	b.n	8030c9c <HAL_UARTEx_StopModeWakeUpSourceConfig+0x82>

08030ca8 <HAL_UARTEx_EnableStopMode>:
  __HAL_LOCK(huart);
 8030ca8:	f890 2080 	ldrb.w	r2, [r0, #128]	; 0x80
 8030cac:	2a01      	cmp	r2, #1
{
 8030cae:	4603      	mov	r3, r0
  __HAL_LOCK(huart);
 8030cb0:	d00e      	beq.n	8030cd0 <HAL_UARTEx_EnableStopMode+0x28>
 8030cb2:	2201      	movs	r2, #1
 8030cb4:	f880 2080 	strb.w	r2, [r0, #128]	; 0x80
  ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_UESM);
 8030cb8:	6819      	ldr	r1, [r3, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030cba:	e851 2f00 	ldrex	r2, [r1]
 8030cbe:	f042 0202 	orr.w	r2, r2, #2
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030cc2:	e841 2000 	strex	r0, r2, [r1]
 8030cc6:	2800      	cmp	r0, #0
 8030cc8:	d1f6      	bne.n	8030cb8 <HAL_UARTEx_EnableStopMode+0x10>
  __HAL_UNLOCK(huart);
 8030cca:	f883 0080 	strb.w	r0, [r3, #128]	; 0x80
  return HAL_OK;
 8030cce:	4770      	bx	lr
  __HAL_LOCK(huart);
 8030cd0:	2002      	movs	r0, #2
}
 8030cd2:	4770      	bx	lr

08030cd4 <HAL_UARTEx_EnableFifoMode>:
{
 8030cd4:	b510      	push	{r4, lr}
  __HAL_LOCK(huart);
 8030cd6:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 8030cda:	2b01      	cmp	r3, #1
{
 8030cdc:	4604      	mov	r4, r0
  __HAL_LOCK(huart);
 8030cde:	d01a      	beq.n	8030d16 <HAL_UARTEx_EnableFifoMode+0x42>
 8030ce0:	2301      	movs	r3, #1
 8030ce2:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
  huart->gState = HAL_UART_STATE_BUSY;
 8030ce6:	2324      	movs	r3, #36	; 0x24
 8030ce8:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8030cec:	6803      	ldr	r3, [r0, #0]
 8030cee:	681a      	ldr	r2, [r3, #0]
  __HAL_UART_DISABLE(huart);
 8030cf0:	6819      	ldr	r1, [r3, #0]
 8030cf2:	f021 0101 	bic.w	r1, r1, #1
 8030cf6:	6019      	str	r1, [r3, #0]
  SET_BIT(tmpcr1, USART_CR1_FIFOEN);
 8030cf8:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
  huart->FifoMode = UART_FIFOMODE_ENABLE;
 8030cfc:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
 8030d00:	6641      	str	r1, [r0, #100]	; 0x64
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8030d02:	601a      	str	r2, [r3, #0]
  UARTEx_SetNbDataToProcess(huart);
 8030d04:	f7ff ff64 	bl	8030bd0 <UARTEx_SetNbDataToProcess>
  huart->gState = HAL_UART_STATE_READY;
 8030d08:	2320      	movs	r3, #32
 8030d0a:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  __HAL_UNLOCK(huart);
 8030d0e:	2000      	movs	r0, #0
 8030d10:	f884 0080 	strb.w	r0, [r4, #128]	; 0x80
}
 8030d14:	bd10      	pop	{r4, pc}
  __HAL_LOCK(huart);
 8030d16:	2002      	movs	r0, #2
 8030d18:	e7fc      	b.n	8030d14 <HAL_UARTEx_EnableFifoMode+0x40>

08030d1a <HAL_UARTEx_SetTxFifoThreshold>:
{
 8030d1a:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(huart);
 8030d1c:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 8030d20:	2b01      	cmp	r3, #1
{
 8030d22:	4604      	mov	r4, r0
  __HAL_LOCK(huart);
 8030d24:	d01b      	beq.n	8030d5e <HAL_UARTEx_SetTxFifoThreshold+0x44>
 8030d26:	2301      	movs	r3, #1
 8030d28:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
  huart->gState = HAL_UART_STATE_BUSY;
 8030d2c:	2324      	movs	r3, #36	; 0x24
 8030d2e:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8030d32:	6803      	ldr	r3, [r0, #0]
 8030d34:	681d      	ldr	r5, [r3, #0]
  __HAL_UART_DISABLE(huart);
 8030d36:	681a      	ldr	r2, [r3, #0]
 8030d38:	f022 0201 	bic.w	r2, r2, #1
 8030d3c:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
 8030d3e:	689a      	ldr	r2, [r3, #8]
 8030d40:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
 8030d44:	4311      	orrs	r1, r2
 8030d46:	6099      	str	r1, [r3, #8]
  UARTEx_SetNbDataToProcess(huart);
 8030d48:	f7ff ff42 	bl	8030bd0 <UARTEx_SetNbDataToProcess>
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8030d4c:	6803      	ldr	r3, [r0, #0]
 8030d4e:	601d      	str	r5, [r3, #0]
  huart->gState = HAL_UART_STATE_READY;
 8030d50:	2320      	movs	r3, #32
 8030d52:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  __HAL_UNLOCK(huart);
 8030d56:	2000      	movs	r0, #0
 8030d58:	f884 0080 	strb.w	r0, [r4, #128]	; 0x80
}
 8030d5c:	bd38      	pop	{r3, r4, r5, pc}
  __HAL_LOCK(huart);
 8030d5e:	2002      	movs	r0, #2
 8030d60:	e7fc      	b.n	8030d5c <HAL_UARTEx_SetTxFifoThreshold+0x42>

08030d62 <HAL_UARTEx_SetRxFifoThreshold>:
{
 8030d62:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(huart);
 8030d64:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 8030d68:	2b01      	cmp	r3, #1
{
 8030d6a:	4604      	mov	r4, r0
  __HAL_LOCK(huart);
 8030d6c:	d01b      	beq.n	8030da6 <HAL_UARTEx_SetRxFifoThreshold+0x44>
 8030d6e:	2301      	movs	r3, #1
 8030d70:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
  huart->gState = HAL_UART_STATE_BUSY;
 8030d74:	2324      	movs	r3, #36	; 0x24
 8030d76:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8030d7a:	6803      	ldr	r3, [r0, #0]
 8030d7c:	681d      	ldr	r5, [r3, #0]
  __HAL_UART_DISABLE(huart);
 8030d7e:	681a      	ldr	r2, [r3, #0]
 8030d80:	f022 0201 	bic.w	r2, r2, #1
 8030d84:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
 8030d86:	689a      	ldr	r2, [r3, #8]
 8030d88:	f022 6260 	bic.w	r2, r2, #234881024	; 0xe000000
 8030d8c:	4311      	orrs	r1, r2
 8030d8e:	6099      	str	r1, [r3, #8]
  UARTEx_SetNbDataToProcess(huart);
 8030d90:	f7ff ff1e 	bl	8030bd0 <UARTEx_SetNbDataToProcess>
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8030d94:	6803      	ldr	r3, [r0, #0]
 8030d96:	601d      	str	r5, [r3, #0]
  huart->gState = HAL_UART_STATE_READY;
 8030d98:	2320      	movs	r3, #32
 8030d9a:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  __HAL_UNLOCK(huart);
 8030d9e:	2000      	movs	r0, #0
 8030da0:	f884 0080 	strb.w	r0, [r4, #128]	; 0x80
}
 8030da4:	bd38      	pop	{r3, r4, r5, pc}
  __HAL_LOCK(huart);
 8030da6:	2002      	movs	r0, #2
 8030da8:	e7fc      	b.n	8030da4 <HAL_UARTEx_SetRxFifoThreshold+0x42>
	...

08030dac <SetRow>:
 * Fragmentation decoder algorithm utilities
 *=============================================================================
 */

static void SetRow( uint8_t *src, uint16_t row, uint16_t size )
{
 8030dac:	460b      	mov	r3, r1
    if( ( FragDecoder.Callbacks != NULL ) && ( FragDecoder.Callbacks->FragDecoderWrite != NULL ) )
 8030dae:	4907      	ldr	r1, [pc, #28]	; (8030dcc <SetRow+0x20>)
 8030db0:	6809      	ldr	r1, [r1, #0]
{
 8030db2:	b430      	push	{r4, r5}
    if( ( FragDecoder.Callbacks != NULL ) && ( FragDecoder.Callbacks->FragDecoderWrite != NULL ) )
 8030db4:	b139      	cbz	r1, 8030dc6 <SetRow+0x1a>
 8030db6:	684d      	ldr	r5, [r1, #4]
 8030db8:	b12d      	cbz	r5, 8030dc6 <SetRow+0x1a>
    {
        FragDecoder.Callbacks->FragDecoderWrite( row * size, src, size );
 8030dba:	4601      	mov	r1, r0
 8030dbc:	fb02 f003 	mul.w	r0, r2, r3
 8030dc0:	462b      	mov	r3, r5
    }
}
 8030dc2:	bc30      	pop	{r4, r5}
        FragDecoder.Callbacks->FragDecoderWrite( row * size, src, size );
 8030dc4:	4718      	bx	r3
}
 8030dc6:	bc30      	pop	{r4, r5}
 8030dc8:	4770      	bx	lr
 8030dca:	bf00      	nop
 8030dcc:	20003f54 	.word	0x20003f54

08030dd0 <GetRow>:

static void GetRow( uint8_t *dst, uint16_t row, uint16_t size )
{
 8030dd0:	460b      	mov	r3, r1
    if( ( FragDecoder.Callbacks != NULL ) && ( FragDecoder.Callbacks->FragDecoderRead != NULL ) )
 8030dd2:	4907      	ldr	r1, [pc, #28]	; (8030df0 <GetRow+0x20>)
 8030dd4:	6809      	ldr	r1, [r1, #0]
{
 8030dd6:	b430      	push	{r4, r5}
    if( ( FragDecoder.Callbacks != NULL ) && ( FragDecoder.Callbacks->FragDecoderRead != NULL ) )
 8030dd8:	b139      	cbz	r1, 8030dea <GetRow+0x1a>
 8030dda:	688d      	ldr	r5, [r1, #8]
 8030ddc:	b12d      	cbz	r5, 8030dea <GetRow+0x1a>
    {
        FragDecoder.Callbacks->FragDecoderRead( row * size, dst, size );
 8030dde:	4601      	mov	r1, r0
 8030de0:	fb02 f003 	mul.w	r0, r2, r3
 8030de4:	462b      	mov	r3, r5
    }
}
 8030de6:	bc30      	pop	{r4, r5}
        FragDecoder.Callbacks->FragDecoderRead( row * size, dst, size );
 8030de8:	4718      	bx	r3
}
 8030dea:	bc30      	pop	{r4, r5}
 8030dec:	4770      	bx	lr
 8030dee:	bf00      	nop
 8030df0:	20003f54 	.word	0x20003f54

08030df4 <GetParity>:

static uint8_t GetParity( uint16_t index, uint8_t *matrixRow  )
{
    uint8_t parity;
    parity = matrixRow[index >> 3];
 8030df4:	08c3      	lsrs	r3, r0, #3
    parity = ( parity >> ( 7 - ( index % 8 ) ) ) & 0x01;
 8030df6:	43c0      	mvns	r0, r0
 8030df8:	5ccb      	ldrb	r3, [r1, r3]
 8030dfa:	f000 0007 	and.w	r0, r0, #7
 8030dfe:	fa43 f000 	asr.w	r0, r3, r0
    return parity;
}
 8030e02:	f000 0001 	and.w	r0, r0, #1
 8030e06:	4770      	bx	lr

08030e08 <SetParity>:

static void SetParity( uint16_t index, uint8_t *matrixRow, uint8_t parity )
{
    uint8_t mask = 0xFF - ( 1 << ( 7 - ( index % 8 ) ) );
 8030e08:	43c3      	mvns	r3, r0
 8030e0a:	f003 0307 	and.w	r3, r3, #7
    parity = parity << ( 7 - ( index % 8 ) );
    matrixRow[index >> 3] = ( matrixRow[index >> 3] & mask ) + parity;
 8030e0e:	08c0      	lsrs	r0, r0, #3
{
 8030e10:	b510      	push	{r4, lr}
    parity = parity << ( 7 - ( index % 8 ) );
 8030e12:	fa02 f403 	lsl.w	r4, r2, r3
    uint8_t mask = 0xFF - ( 1 << ( 7 - ( index % 8 ) ) );
 8030e16:	2201      	movs	r2, #1
 8030e18:	fa02 f303 	lsl.w	r3, r2, r3
    matrixRow[index >> 3] = ( matrixRow[index >> 3] & mask ) + parity;
 8030e1c:	5c0a      	ldrb	r2, [r1, r0]
 8030e1e:	ea22 0203 	bic.w	r2, r2, r3
 8030e22:	4422      	add	r2, r4
 8030e24:	540a      	strb	r2, [r1, r0]
}
 8030e26:	bd10      	pop	{r4, pc}

08030e28 <XorDataLine>:
    }
    return false;
}

static void XorDataLine( uint8_t *line1, uint8_t *line2, int32_t size )
{
 8030e28:	b530      	push	{r4, r5, lr}
 8030e2a:	3801      	subs	r0, #1
    for( int32_t i = 0; i < size; i++ )
 8030e2c:	2300      	movs	r3, #0
 8030e2e:	4293      	cmp	r3, r2
 8030e30:	d100      	bne.n	8030e34 <XorDataLine+0xc>
    {
        line1[i] = line1[i] ^ line2[i];
    }
}
 8030e32:	bd30      	pop	{r4, r5, pc}
        line1[i] = line1[i] ^ line2[i];
 8030e34:	5ccd      	ldrb	r5, [r1, r3]
 8030e36:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 8030e3a:	406c      	eors	r4, r5
 8030e3c:	7004      	strb	r4, [r0, #0]
    for( int32_t i = 0; i < size; i++ )
 8030e3e:	3301      	adds	r3, #1
 8030e40:	e7f5      	b.n	8030e2e <XorDataLine+0x6>

08030e42 <XorParityLine>:

static void XorParityLine( uint8_t* line1, uint8_t* line2, int32_t size )
{
 8030e42:	e92d 41d8 	stmdb	sp!, {r3, r4, r6, r7, r8, lr}
 8030e46:	4606      	mov	r6, r0
 8030e48:	4688      	mov	r8, r1
 8030e4a:	b297      	uxth	r7, r2
    for( int32_t i = 0; i < size; i++ )
 8030e4c:	2400      	movs	r4, #0
 8030e4e:	42bc      	cmp	r4, r7
 8030e50:	d101      	bne.n	8030e56 <XorParityLine+0x14>
    {
        SetParity( i, line1, ( GetParity( i, line1 ) ^ GetParity( i, line2 ) ) );
    }
}
 8030e52:	e8bd 81d8 	ldmia.w	sp!, {r3, r4, r6, r7, r8, pc}
        SetParity( i, line1, ( GetParity( i, line1 ) ^ GetParity( i, line2 ) ) );
 8030e56:	4631      	mov	r1, r6
 8030e58:	4620      	mov	r0, r4
 8030e5a:	f7ff ffcb 	bl	8030df4 <GetParity>
 8030e5e:	4641      	mov	r1, r8
 8030e60:	4602      	mov	r2, r0
 8030e62:	4620      	mov	r0, r4
 8030e64:	f7ff ffc6 	bl	8030df4 <GetParity>
 8030e68:	4042      	eors	r2, r0
 8030e6a:	b2d2      	uxtb	r2, r2
 8030e6c:	4620      	mov	r0, r4
 8030e6e:	4631      	mov	r1, r6
 8030e70:	3401      	adds	r4, #1
 8030e72:	f7ff ffc9 	bl	8030e08 <SetParity>
    for( int32_t i = 0; i < size; i++ )
 8030e76:	b2a4      	uxth	r4, r4
 8030e78:	e7e9      	b.n	8030e4e <XorParityLine+0xc>
	...

08030e7c <FragFindMissingFrags>:
 * \param [OUT] FragDecoder.FragNbMissingIndex[] array is updated in place
 */
static void FragFindMissingFrags( uint16_t counter )
{
    int32_t i;
    for( i = FragDecoder.Status.FragNbLastRx; i < ( counter - 1 ); i++ )
 8030e7c:	4b13      	ldr	r3, [pc, #76]	; (8030ecc <FragFindMissingFrags+0x50>)
{
 8030e7e:	b5f0      	push	{r4, r5, r6, r7, lr}
    for( i = FragDecoder.Status.FragNbLastRx; i < ( counter - 1 ); i++ )
 8030e80:	f8b3 6882 	ldrh.w	r6, [r3, #2178]	; 0x882
    {
        if( i < FragDecoder.FragNb )
 8030e84:	889c      	ldrh	r4, [r3, #4]
 8030e86:	f8b3 1880 	ldrh.w	r1, [r3, #2176]	; 0x880
    for( i = FragDecoder.Status.FragNbLastRx; i < ( counter - 1 ); i++ )
 8030e8a:	4635      	mov	r5, r6
 8030e8c:	2700      	movs	r7, #0
 8030e8e:	1e42      	subs	r2, r0, #1
 8030e90:	42aa      	cmp	r2, r5
 8030e92:	dc0f      	bgt.n	8030eb4 <FragFindMissingFrags+0x38>
 8030e94:	43f2      	mvns	r2, r6
 8030e96:	4402      	add	r2, r0
 8030e98:	4286      	cmp	r6, r0
 8030e9a:	bf28      	it	cs
 8030e9c:	2200      	movcs	r2, #0
 8030e9e:	4432      	add	r2, r6
 8030ea0:	b10f      	cbz	r7, 8030ea6 <FragFindMissingFrags+0x2a>
 8030ea2:	f8a3 1880 	strh.w	r1, [r3, #2176]	; 0x880
        {
            FragDecoder.Status.FragNbLost++;
            FragDecoder.FragNbMissingIndex[i] = FragDecoder.Status.FragNbLost;
        }
    }
    if( i < FragDecoder.FragNb )
 8030ea6:	4294      	cmp	r4, r2
    {
        FragDecoder.Status.FragNbLastRx = counter;
    }
    else
    {
        FragDecoder.Status.FragNbLastRx = FragDecoder.FragNb + 1;
 8030ea8:	bfdc      	itt	le
 8030eaa:	1c60      	addle	r0, r4, #1
 8030eac:	b280      	uxthle	r0, r0
 8030eae:	f8a3 0882 	strh.w	r0, [r3, #2178]	; 0x882
    }
}
 8030eb2:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if( i < FragDecoder.FragNb )
 8030eb4:	42ac      	cmp	r4, r5
 8030eb6:	dd06      	ble.n	8030ec6 <FragFindMissingFrags+0x4a>
            FragDecoder.FragNbMissingIndex[i] = FragDecoder.Status.FragNbLost;
 8030eb8:	eb03 0745 	add.w	r7, r3, r5, lsl #1
            FragDecoder.Status.FragNbLost++;
 8030ebc:	3101      	adds	r1, #1
 8030ebe:	b289      	uxth	r1, r1
            FragDecoder.FragNbMissingIndex[i] = FragDecoder.Status.FragNbLost;
 8030ec0:	f8a7 12dc 	strh.w	r1, [r7, #732]	; 0x2dc
 8030ec4:	2701      	movs	r7, #1
    for( i = FragDecoder.Status.FragNbLastRx; i < ( counter - 1 ); i++ )
 8030ec6:	3501      	adds	r5, #1
 8030ec8:	e7e2      	b.n	8030e90 <FragFindMissingFrags+0x14>
 8030eca:	bf00      	nop
 8030ecc:	20003f54 	.word	0x20003f54

08030ed0 <FragFindMissingIndex>:
 *
 * \retval counter The counter value associated to the x th missing frag
 */
static uint16_t FragFindMissingIndex( uint16_t x )
{
    for( uint16_t i = 0; i < FragDecoder.FragNb; i++ )
 8030ed0:	4b09      	ldr	r3, [pc, #36]	; (8030ef8 <FragFindMissingIndex+0x28>)
{
 8030ed2:	b530      	push	{r4, r5, lr}
    for( uint16_t i = 0; i < FragDecoder.FragNb; i++ )
 8030ed4:	2200      	movs	r2, #0
 8030ed6:	889c      	ldrh	r4, [r3, #4]
    {
        if( FragDecoder.FragNbMissingIndex[i] == ( x + 1 ) )
 8030ed8:	1c41      	adds	r1, r0, #1
 8030eda:	f503 7337 	add.w	r3, r3, #732	; 0x2dc
 8030ede:	b290      	uxth	r0, r2
    for( uint16_t i = 0; i < FragDecoder.FragNb; i++ )
 8030ee0:	4284      	cmp	r4, r0
 8030ee2:	d801      	bhi.n	8030ee8 <FragFindMissingIndex+0x18>
        {
            return i;
        }
    }
    return 0;
 8030ee4:	2000      	movs	r0, #0
 8030ee6:	e005      	b.n	8030ef4 <FragFindMissingIndex+0x24>
        if( FragDecoder.FragNbMissingIndex[i] == ( x + 1 ) )
 8030ee8:	f833 5b02 	ldrh.w	r5, [r3], #2
 8030eec:	428d      	cmp	r5, r1
 8030eee:	f102 0201 	add.w	r2, r2, #1
 8030ef2:	d1f4      	bne.n	8030ede <FragFindMissingIndex+0xe>
}
 8030ef4:	bd30      	pop	{r4, r5, pc}
 8030ef6:	bf00      	nop
 8030ef8:	20003f54 	.word	0x20003f54

08030efc <FragExtractLineFromBinaryMatrix>:
 * \param [IN] bitArray  Pointer to the bit array
 * \param [IN] rowIndex  Matrix row index
 * \param [IN] bitsInRow Number of bits in one row
 */
static void FragExtractLineFromBinaryMatrix( uint8_t* bitArray, uint16_t rowIndex, uint16_t bitsInRow )
{
 8030efc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8030f00:	4680      	mov	r8, r0
 8030f02:	4616      	mov	r6, r2
    uint32_t findByte = 0;
    uint32_t findBitInByte = 0;

    if( rowIndex > 0 )
 8030f04:	460d      	mov	r5, r1
 8030f06:	b309      	cbz	r1, 8030f4c <FragExtractLineFromBinaryMatrix+0x50>
    {
        findByte      = ( rowIndex * bitsInRow - ( ( rowIndex * ( rowIndex - 1 ) ) >> 1 ) ) >> 3;
 8030f08:	1e4b      	subs	r3, r1, #1
 8030f0a:	434b      	muls	r3, r1
 8030f0c:	fb01 f402 	mul.w	r4, r1, r2
 8030f10:	eba4 0463 	sub.w	r4, r4, r3, asr #1
        findBitInByte = ( rowIndex * bitsInRow - ( ( rowIndex * ( rowIndex - 1 ) ) >> 1 ) ) % 8;
 8030f14:	4263      	negs	r3, r4
 8030f16:	f003 0307 	and.w	r3, r3, #7
        findByte      = ( rowIndex * bitsInRow - ( ( rowIndex * ( rowIndex - 1 ) ) >> 1 ) ) >> 3;
 8030f1a:	ea4f 07e4 	mov.w	r7, r4, asr #3
        findBitInByte = ( rowIndex * bitsInRow - ( ( rowIndex * ( rowIndex - 1 ) ) >> 1 ) ) % 8;
 8030f1e:	f04f 0900 	mov.w	r9, #0
 8030f22:	f004 0407 	and.w	r4, r4, #7
 8030f26:	bf58      	it	pl
 8030f28:	425c      	negpl	r4, r3
    }
    if( rowIndex > 0 )
    {
        for( uint16_t i = 0; i < rowIndex; i++ )
 8030f2a:	45a9      	cmp	r9, r5
 8030f2c:	fa1f f089 	uxth.w	r0, r9
 8030f30:	d105      	bne.n	8030f3e <FragExtractLineFromBinaryMatrix+0x42>
    }
    for( uint16_t i = rowIndex; i < bitsInRow; i++ )
    {
        SetParity( i,
                   bitArray, 
                   ( FragDecoder.MatrixM2B[findByte] >> ( 7 - findBitInByte ) ) & 0x01 );
 8030f32:	f8df 9048 	ldr.w	r9, [pc, #72]	; 8030f7c <FragExtractLineFromBinaryMatrix+0x80>
    for( uint16_t i = rowIndex; i < bitsInRow; i++ )
 8030f36:	42b5      	cmp	r5, r6
 8030f38:	d30b      	bcc.n	8030f52 <FragExtractLineFromBinaryMatrix+0x56>
        {
            findBitInByte = 0;
            findByte++;
        }
    }
}
 8030f3a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            SetParity( i, bitArray, 0 );
 8030f3e:	2200      	movs	r2, #0
 8030f40:	4641      	mov	r1, r8
 8030f42:	f7ff ff61 	bl	8030e08 <SetParity>
        for( uint16_t i = 0; i < rowIndex; i++ )
 8030f46:	f109 0901 	add.w	r9, r9, #1
 8030f4a:	e7ee      	b.n	8030f2a <FragExtractLineFromBinaryMatrix+0x2e>
    uint32_t findBitInByte = 0;
 8030f4c:	460c      	mov	r4, r1
    uint32_t findByte = 0;
 8030f4e:	460f      	mov	r7, r1
 8030f50:	e7ef      	b.n	8030f32 <FragExtractLineFromBinaryMatrix+0x36>
                   ( FragDecoder.MatrixM2B[findByte] >> ( 7 - findBitInByte ) ) & 0x01 );
 8030f52:	eb09 0307 	add.w	r3, r9, r7
        SetParity( i,
 8030f56:	4628      	mov	r0, r5
                   ( FragDecoder.MatrixM2B[findByte] >> ( 7 - findBitInByte ) ) & 0x01 );
 8030f58:	7b1a      	ldrb	r2, [r3, #12]
 8030f5a:	f1c4 0307 	rsb	r3, r4, #7
 8030f5e:	411a      	asrs	r2, r3
        findBitInByte++;
 8030f60:	3401      	adds	r4, #1
        SetParity( i,
 8030f62:	f002 0201 	and.w	r2, r2, #1
 8030f66:	4641      	mov	r1, r8
 8030f68:	f7ff ff4e 	bl	8030e08 <SetParity>
    for( uint16_t i = rowIndex; i < bitsInRow; i++ )
 8030f6c:	3501      	adds	r5, #1
        if( findBitInByte == 8 )
 8030f6e:	2c08      	cmp	r4, #8
            findByte++;
 8030f70:	bf04      	itt	eq
 8030f72:	3701      	addeq	r7, #1
            findBitInByte = 0;
 8030f74:	2400      	moveq	r4, #0
    for( uint16_t i = rowIndex; i < bitsInRow; i++ )
 8030f76:	b2ad      	uxth	r5, r5
 8030f78:	e7dd      	b.n	8030f36 <FragExtractLineFromBinaryMatrix+0x3a>
 8030f7a:	bf00      	nop
 8030f7c:	20003f54 	.word	0x20003f54

08030f80 <FragDecoderInit>:
{
 8030f80:	b510      	push	{r4, lr}
    FragDecoder.Callbacks = callbacks;
 8030f82:	4c15      	ldr	r4, [pc, #84]	; (8030fd8 <FragDecoderInit+0x58>)
    FragDecoder.Status.FragNbLost = 0;
 8030f84:	2300      	movs	r3, #0
    FragDecoder.FragNb = fragNb;                                // FragNb = FRAG_MAX_SIZE
 8030f86:	80a0      	strh	r0, [r4, #4]
    FragDecoder.FragSize = fragSize;                            // number of byte on a row
 8030f88:	71a1      	strb	r1, [r4, #6]
    FragDecoder.Status.FragNbLost = 0;
 8030f8a:	f8c4 3880 	str.w	r3, [r4, #2176]	; 0x880
    FragDecoder.M2BLine = 0;
 8030f8e:	60a3      	str	r3, [r4, #8]
    FragDecoder.Callbacks = callbacks;
 8030f90:	6022      	str	r2, [r4, #0]
    for( uint16_t i = 0; i < FRAG_MAX_NB; i++ )
 8030f92:	f504 7137 	add.w	r1, r4, #732	; 0x2dc
    FragDecoder.M2BLine = 0;
 8030f96:	f44f 7333 	mov.w	r3, #716	; 0x2cc
        FragDecoder.FragNbMissingIndex[i] = 1;
 8030f9a:	2001      	movs	r0, #1
 8030f9c:	3b01      	subs	r3, #1
 8030f9e:	b29b      	uxth	r3, r3
 8030fa0:	f821 0b02 	strh.w	r0, [r1], #2
    for( uint16_t i = 0; i < FRAG_MAX_NB; i++ )
 8030fa4:	2b00      	cmp	r3, #0
 8030fa6:	d1f9      	bne.n	8030f9c <FragDecoderInit+0x1c>
 8030fa8:	490c      	ldr	r1, [pc, #48]	; (8030fdc <FragDecoderInit+0x5c>)
        FragDecoder.S[i] = 0;
 8030faa:	4618      	mov	r0, r3
    for( uint32_t i = 0; i < ( ( FRAG_MAX_REDUNDANCY >> 3 ) + 1 ); i++ )
 8030fac:	3301      	adds	r3, #1
 8030fae:	2b0a      	cmp	r3, #10
        FragDecoder.S[i] = 0;
 8030fb0:	f801 0b01 	strb.w	r0, [r1], #1
    for( uint32_t i = 0; i < ( ( FRAG_MAX_REDUNDANCY >> 3 ) + 1 ); i++ )
 8030fb4:	d1fa      	bne.n	8030fac <FragDecoderInit+0x2c>
 8030fb6:	490a      	ldr	r1, [pc, #40]	; (8030fe0 <FragDecoderInit+0x60>)
    for( uint32_t i = 0; i < ( ( ( FRAG_MAX_REDUNDANCY >> 3 ) + 1 ) * FRAG_MAX_REDUNDANCY ); i++ )
 8030fb8:	2300      	movs	r3, #0
       FragDecoder.MatrixM2B[i] = 0xFF;
 8030fba:	20ff      	movs	r0, #255	; 0xff
    for( uint32_t i = 0; i < ( ( ( FRAG_MAX_REDUNDANCY >> 3 ) + 1 ) * FRAG_MAX_REDUNDANCY ); i++ )
 8030fbc:	3301      	adds	r3, #1
 8030fbe:	f5b3 7f34 	cmp.w	r3, #720	; 0x2d0
       FragDecoder.MatrixM2B[i] = 0xFF;
 8030fc2:	f801 0b01 	strb.w	r0, [r1], #1
    for( uint32_t i = 0; i < ( ( ( FRAG_MAX_REDUNDANCY >> 3 ) + 1 ) * FRAG_MAX_REDUNDANCY ); i++ )
 8030fc6:	d1f9      	bne.n	8030fbc <FragDecoderInit+0x3c>
    if (FragDecoder.Callbacks->FragDecoderErase != NULL)
 8030fc8:	6813      	ldr	r3, [r2, #0]
 8030fca:	b103      	cbz	r3, 8030fce <FragDecoderInit+0x4e>
        FragDecoder.Callbacks->FragDecoderErase();
 8030fcc:	4798      	blx	r3
    FragDecoder.Status.FragNbLost = 0;
 8030fce:	2300      	movs	r3, #0
 8030fd0:	f8c4 3880 	str.w	r3, [r4, #2176]	; 0x880
}
 8030fd4:	bd10      	pop	{r4, pc}
 8030fd6:	bf00      	nop
 8030fd8:	20003f54 	.word	0x20003f54
 8030fdc:	200047c8 	.word	0x200047c8
 8030fe0:	20003f60 	.word	0x20003f60

08030fe4 <FragDecoderGetMaxFileSize>:
}
 8030fe4:	4800      	ldr	r0, [pc, #0]	; (8030fe8 <FragDecoderGetMaxFileSize+0x4>)
 8030fe6:	4770      	bx	lr
 8030fe8:	00014fa0 	.word	0x00014fa0

08030fec <FragDecoderProcess>:
{
 8030fec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8030ff0:	b0bd      	sub	sp, #244	; 0xf4
 8030ff2:	4604      	mov	r4, r0
    UTIL_MEM_set_8(matrixRow, 0, (FRAG_MAX_NB >> 3) + 1);
 8030ff4:	225a      	movs	r2, #90	; 0x5a
 8030ff6:	a807      	add	r0, sp, #28
{
 8030ff8:	460f      	mov	r7, r1
    UTIL_MEM_set_8(matrixRow, 0, (FRAG_MAX_NB >> 3) + 1);
 8030ffa:	2100      	movs	r1, #0
 8030ffc:	f009 ff90 	bl	803af20 <UTIL_MEM_set_8>
    UTIL_MEM_set_8(matrixDataTemp, 0, FRAG_MAX_SIZE);
 8031000:	2278      	movs	r2, #120	; 0x78
 8031002:	eb0d 0002 	add.w	r0, sp, r2
 8031006:	2100      	movs	r1, #0
 8031008:	f009 ff8a 	bl	803af20 <UTIL_MEM_set_8>
    FragDecoder.Status.FragNbRx = fragCounter;
 803100c:	4eba      	ldr	r6, [pc, #744]	; (80312f8 <FragDecoderProcess+0x30c>)
    UTIL_MEM_set_8(dataTempVector, 0, (FRAG_MAX_REDUNDANCY >> 3) + 1);
 803100e:	220a      	movs	r2, #10
 8031010:	2100      	movs	r1, #0
 8031012:	a801      	add	r0, sp, #4
 8031014:	f009 ff84 	bl	803af20 <UTIL_MEM_set_8>
    UTIL_MEM_set_8(dataTempVector2, 0, (FRAG_MAX_REDUNDANCY >> 3) + 1);
 8031018:	220a      	movs	r2, #10
 803101a:	2100      	movs	r1, #0
 803101c:	a804      	add	r0, sp, #16
 803101e:	f009 ff7f 	bl	803af20 <UTIL_MEM_set_8>
    if( fragCounter < FragDecoder.Status.FragNbLastRx )
 8031022:	f8b6 3882 	ldrh.w	r3, [r6, #2178]	; 0x882
    FragDecoder.Status.FragNbRx = fragCounter;
 8031026:	f8a6 487e 	strh.w	r4, [r6, #2174]	; 0x87e
    if( fragCounter < FragDecoder.Status.FragNbLastRx )
 803102a:	42a3      	cmp	r3, r4
 803102c:	4635      	mov	r5, r6
 803102e:	d904      	bls.n	803103a <FragDecoderProcess+0x4e>
        return FRAG_SESSION_ONGOING;  // Drop frame out of order
 8031030:	f04f 30ff 	mov.w	r0, #4294967295
}
 8031034:	b03d      	add	sp, #244	; 0xf4
 8031036:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( fragCounter < ( FragDecoder.FragNb + 1 ) )
 803103a:	88b3      	ldrh	r3, [r6, #4]
 803103c:	42a3      	cmp	r3, r4
 803103e:	d318      	bcc.n	8031072 <FragDecoderProcess+0x86>
        SetRow( rawData, fragCounter - 1, FragDecoder.FragSize );
 8031040:	1e61      	subs	r1, r4, #1
 8031042:	79b2      	ldrb	r2, [r6, #6]
 8031044:	b289      	uxth	r1, r1
 8031046:	4638      	mov	r0, r7
 8031048:	f7ff feb0 	bl	8030dac <SetRow>
        FragDecoder.FragNbMissingIndex[fragCounter - 1] = 0;
 803104c:	f204 136b 	addw	r3, r4, #363	; 0x16b
 8031050:	eb06 0343 	add.w	r3, r6, r3, lsl #1
 8031054:	2200      	movs	r2, #0
        FragFindMissingFrags( fragCounter );
 8031056:	4620      	mov	r0, r4
        FragDecoder.FragNbMissingIndex[fragCounter - 1] = 0;
 8031058:	809a      	strh	r2, [r3, #4]
        FragFindMissingFrags( fragCounter );
 803105a:	f7ff ff0f 	bl	8030e7c <FragFindMissingFrags>
        if ((fragCounter == FragDecoder.FragNb) && (FragDecoder.Status.FragNbLost == 0U))
 803105e:	88b3      	ldrh	r3, [r6, #4]
 8031060:	42a3      	cmp	r3, r4
 8031062:	d1e5      	bne.n	8031030 <FragDecoderProcess+0x44>
 8031064:	f8b6 0880 	ldrh.w	r0, [r6, #2176]	; 0x880
 8031068:	3800      	subs	r0, #0
 803106a:	bf18      	it	ne
 803106c:	2001      	movne	r0, #1
 803106e:	4240      	negs	r0, r0
 8031070:	e7e0      	b.n	8031034 <FragDecoderProcess+0x48>
        if( FragDecoder.Status.FragNbLost > FRAG_MAX_REDUNDANCY )
 8031072:	f8b6 3880 	ldrh.w	r3, [r6, #2176]	; 0x880
 8031076:	2b48      	cmp	r3, #72	; 0x48
 8031078:	d904      	bls.n	8031084 <FragDecoderProcess+0x98>
           FragDecoder.Status.MatrixError = 1;
 803107a:	2301      	movs	r3, #1
 803107c:	f886 3884 	strb.w	r3, [r6, #2180]	; 0x884
           return FRAG_SESSION_FINISHED;
 8031080:	2000      	movs	r0, #0
 8031082:	e7d7      	b.n	8031034 <FragDecoderProcess+0x48>
        FragFindMissingFrags( fragCounter );
 8031084:	4620      	mov	r0, r4
 8031086:	f7ff fef9 	bl	8030e7c <FragFindMissingFrags>
        if( FragDecoder.Status.FragNbLost == 0 )
 803108a:	f8b6 0880 	ldrh.w	r0, [r6, #2176]	; 0x880
 803108e:	2800      	cmp	r0, #0
 8031090:	d0d0      	beq.n	8031034 <FragDecoderProcess+0x48>
        FragGetParityMatrixRow( fragCounter - FragDecoder.FragNb, FragDecoder.FragNb, matrixRow );
 8031092:	f8b6 9004 	ldrh.w	r9, [r6, #4]
    if( IsPowerOfTwo( m ) != false )
 8031096:	2300      	movs	r3, #0
        FragGetParityMatrixRow( fragCounter - FragDecoder.FragNb, FragDecoder.FragNb, matrixRow );
 8031098:	eba4 0409 	sub.w	r4, r4, r9
    uint8_t sumBit = 0;
 803109c:	461e      	mov	r6, r3
        sumBit += ( x & ( 1 << i ) ) >> i;
 803109e:	2101      	movs	r1, #1
 80310a0:	fa01 f203 	lsl.w	r2, r1, r3
 80310a4:	ea02 0209 	and.w	r2, r2, r9
 80310a8:	40da      	lsrs	r2, r3
 80310aa:	3301      	adds	r3, #1
 80310ac:	4416      	add	r6, r2
    for( uint8_t i = 0; i < 32; i++ )
 80310ae:	2b20      	cmp	r3, #32
        sumBit += ( x & ( 1 << i ) ) >> i;
 80310b0:	b2f6      	uxtb	r6, r6
    for( uint8_t i = 0; i < 32; i++ )
 80310b2:	d1f5      	bne.n	80310a0 <FragDecoderProcess+0xb4>
    if( sumBit == 1 )
 80310b4:	1e73      	subs	r3, r6, #1
 80310b6:	425e      	negs	r6, r3
    x = 1 + ( 1001 * n );
 80310b8:	f240 30e9 	movw	r0, #1001	; 0x3e9
 80310bc:	fb00 f404 	mul.w	r4, r0, r4
    if( sumBit == 1 )
 80310c0:	415e      	adcs	r6, r3
    for( uint8_t i = 0; i < ( ( m >> 3 ) + 1 ); i++ )
 80310c2:	2300      	movs	r3, #0
    x = 1 + ( 1001 * n );
 80310c4:	3401      	adds	r4, #1
    for( uint8_t i = 0; i < ( ( m >> 3 ) + 1 ); i++ )
 80310c6:	ea4f 02e9 	mov.w	r2, r9, asr #3
        matrixRow[i] = 0;
 80310ca:	4618      	mov	r0, r3
 80310cc:	a93c      	add	r1, sp, #240	; 0xf0
 80310ce:	4419      	add	r1, r3
    for( uint8_t i = 0; i < ( ( m >> 3 ) + 1 ); i++ )
 80310d0:	3301      	adds	r3, #1
 80310d2:	b2db      	uxtb	r3, r3
 80310d4:	429a      	cmp	r2, r3
        matrixRow[i] = 0;
 80310d6:	f801 0cd4 	strb.w	r0, [r1, #-212]
    for( uint8_t i = 0; i < ( ( m >> 3 ) + 1 ); i++ )
 80310da:	daf7      	bge.n	80310cc <FragDecoderProcess+0xe0>
    while( nbCoeff < ( m >> 1 ) )
 80310dc:	ea4f 0b69 	mov.w	fp, r9, asr #1
    int32_t nbCoeff = 0;
 80310e0:	f04f 0a00 	mov.w	sl, #0
            r = x % ( m + mTemp );
 80310e4:	444e      	add	r6, r9
    while( nbCoeff < ( m >> 1 ) )
 80310e6:	45da      	cmp	sl, fp
 80310e8:	db0c      	blt.n	8031104 <FragDecoderProcess+0x118>
        for( int32_t i = 0; i < FragDecoder.FragNb; i++ )
 80310ea:	2600      	movs	r6, #0
    int32_t first = 0;
 80310ec:	46b0      	mov	r8, r6
        for( int32_t i = 0; i < FragDecoder.FragNb; i++ )
 80310ee:	88ab      	ldrh	r3, [r5, #4]
 80310f0:	42b3      	cmp	r3, r6
 80310f2:	dc28      	bgt.n	8031146 <FragDecoderProcess+0x15a>
        firstOneInRow = BitArrayFindFirstOne( dataTempVector, FragDecoder.Status.FragNbLost );
 80310f4:	f8b5 6880 	ldrh.w	r6, [r5, #2176]	; 0x880
    for( uint16_t i = 0; i < size; i++)
 80310f8:	2200      	movs	r2, #0
 80310fa:	b294      	uxth	r4, r2
 80310fc:	42a6      	cmp	r6, r4
 80310fe:	d848      	bhi.n	8031192 <FragDecoderProcess+0x1a6>
    return 0;
 8031100:	2400      	movs	r4, #0
 8031102:	e04e      	b.n	80311a2 <FragDecoderProcess+0x1b6>
    return ( value >> 1 ) + ( ( b0 ^ b1 ) << 22 );
 8031104:	ea84 1364 	eor.w	r3, r4, r4, asr #5
 8031108:	059b      	lsls	r3, r3, #22
 803110a:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 803110e:	eb03 0464 	add.w	r4, r3, r4, asr #1
            r = x % ( m + mTemp );
 8031112:	fb94 f8f6 	sdiv	r8, r4, r6
 8031116:	fb06 4818 	mls	r8, r6, r8, r4
        while( r >= m )
 803111a:	45c1      	cmp	r9, r8
 803111c:	ddf2      	ble.n	8031104 <FragDecoderProcess+0x118>
        if ((GetParity(r, matrixRow) == 0) || (LmhpFragmentationGetPackageVersion() == 1U))
 803111e:	fa1f f888 	uxth.w	r8, r8
 8031122:	a907      	add	r1, sp, #28
 8031124:	4640      	mov	r0, r8
 8031126:	f7ff fe65 	bl	8030df4 <GetParity>
 803112a:	b938      	cbnz	r0, 803113c <FragDecoderProcess+0x150>
            SetParity(r, matrixRow, 1);
 803112c:	2201      	movs	r2, #1
 803112e:	a907      	add	r1, sp, #28
 8031130:	4640      	mov	r0, r8
 8031132:	f7ff fe69 	bl	8030e08 <SetParity>
            nbCoeff += 1;
 8031136:	f10a 0a01 	add.w	sl, sl, #1
 803113a:	e7d4      	b.n	80310e6 <FragDecoderProcess+0xfa>
        if ((GetParity(r, matrixRow) == 0) || (LmhpFragmentationGetPackageVersion() == 1U))
 803113c:	f001 fbbc 	bl	80328b8 <LmhpFragmentationGetPackageVersion>
 8031140:	2801      	cmp	r0, #1
 8031142:	d1d0      	bne.n	80310e6 <FragDecoderProcess+0xfa>
 8031144:	e7f2      	b.n	803112c <FragDecoderProcess+0x140>
            if( GetParity( i , matrixRow ) == 1 )
 8031146:	fa1f f986 	uxth.w	r9, r6
 803114a:	a907      	add	r1, sp, #28
 803114c:	4648      	mov	r0, r9
 803114e:	f7ff fe51 	bl	8030df4 <GetParity>
 8031152:	2801      	cmp	r0, #1
 8031154:	4604      	mov	r4, r0
 8031156:	d112      	bne.n	803117e <FragDecoderProcess+0x192>
                if( FragDecoder.FragNbMissingIndex[i] == 0 )
 8031158:	eb05 0346 	add.w	r3, r5, r6, lsl #1
 803115c:	f8b3 22dc 	ldrh.w	r2, [r3, #732]	; 0x2dc
 8031160:	b97a      	cbnz	r2, 8031182 <FragDecoderProcess+0x196>
                    SetParity( i, matrixRow, 0 );
 8031162:	a907      	add	r1, sp, #28
 8031164:	4648      	mov	r0, r9
 8031166:	f7ff fe4f 	bl	8030e08 <SetParity>
                    GetRow( matrixDataTemp, i, FragDecoder.FragSize );
 803116a:	79aa      	ldrb	r2, [r5, #6]
 803116c:	4649      	mov	r1, r9
 803116e:	a81e      	add	r0, sp, #120	; 0x78
 8031170:	f7ff fe2e 	bl	8030dd0 <GetRow>
                    XorDataLine( rawData, matrixDataTemp, FragDecoder.FragSize );
 8031174:	79aa      	ldrb	r2, [r5, #6]
 8031176:	a91e      	add	r1, sp, #120	; 0x78
 8031178:	4638      	mov	r0, r7
 803117a:	f7ff fe55 	bl	8030e28 <XorDataLine>
        for( int32_t i = 0; i < FragDecoder.FragNb; i++ )
 803117e:	3601      	adds	r6, #1
 8031180:	e7b5      	b.n	80310ee <FragDecoderProcess+0x102>
                    SetParity( FragDecoder.FragNbMissingIndex[i] - 1, dataTempVector, 1 );
 8031182:	1e50      	subs	r0, r2, #1
 8031184:	a901      	add	r1, sp, #4
 8031186:	4622      	mov	r2, r4
 8031188:	b280      	uxth	r0, r0
 803118a:	f7ff fe3d 	bl	8030e08 <SetParity>
                        first = 1;
 803118e:	46a0      	mov	r8, r4
 8031190:	e7f5      	b.n	803117e <FragDecoderProcess+0x192>
        if ( GetParity( i, bitArray ) == 1 )
 8031192:	a901      	add	r1, sp, #4
 8031194:	4620      	mov	r0, r4
 8031196:	f7ff fe2d 	bl	8030df4 <GetParity>
 803119a:	2801      	cmp	r0, #1
 803119c:	f102 0201 	add.w	r2, r2, #1
 80311a0:	d1ab      	bne.n	80310fa <FragDecoderProcess+0x10e>
        if( first > 0 )
 80311a2:	f1b8 0f00 	cmp.w	r8, #0
 80311a6:	f43f af43 	beq.w	8031030 <FragDecoderProcess+0x44>
            while( GetParity( firstOneInRow, FragDecoder.S ) == 1 )
 80311aa:	f8df 8150 	ldr.w	r8, [pc, #336]	; 80312fc <FragDecoderProcess+0x310>
 80311ae:	4641      	mov	r1, r8
 80311b0:	4620      	mov	r0, r4
 80311b2:	f7ff fe1f 	bl	8030df4 <GetParity>
 80311b6:	2801      	cmp	r0, #1
 80311b8:	f8b5 2880 	ldrh.w	r2, [r5, #2176]	; 0x880
 80311bc:	d004      	beq.n	80311c8 <FragDecoderProcess+0x1dc>
static void FragPushLineToBinaryMatrix( uint8_t *bitArray, uint16_t rowIndex, uint16_t bitsInRow )
{
    uint32_t findByte = 0;
    uint32_t findBitInByte = 0;

    if ( rowIndex > 0) {
 80311be:	2c00      	cmp	r4, #0
 80311c0:	d15b      	bne.n	803127a <FragDecoderProcess+0x28e>
    uint32_t findBitInByte = 0;
 80311c2:	4626      	mov	r6, r4
    uint32_t findByte = 0;
 80311c4:	46a1      	mov	r9, r4
 80311c6:	e067      	b.n	8031298 <FragDecoderProcess+0x2ac>
                FragExtractLineFromBinaryMatrix( dataTempVector2, firstOneInRow, FragDecoder.Status.FragNbLost );
 80311c8:	4621      	mov	r1, r4
 80311ca:	a804      	add	r0, sp, #16
 80311cc:	f7ff fe96 	bl	8030efc <FragExtractLineFromBinaryMatrix>
                XorParityLine( dataTempVector, dataTempVector2, FragDecoder.Status.FragNbLost );
 80311d0:	f8b5 2880 	ldrh.w	r2, [r5, #2176]	; 0x880
 80311d4:	a904      	add	r1, sp, #16
 80311d6:	a801      	add	r0, sp, #4
 80311d8:	f7ff fe33 	bl	8030e42 <XorParityLine>
                li = FragFindMissingIndex( firstOneInRow );
 80311dc:	4620      	mov	r0, r4
 80311de:	f7ff fe77 	bl	8030ed0 <FragFindMissingIndex>
                GetRow( matrixDataTemp, li, FragDecoder.FragSize );
 80311e2:	79aa      	ldrb	r2, [r5, #6]
                li = FragFindMissingIndex( firstOneInRow );
 80311e4:	4601      	mov	r1, r0
                GetRow( matrixDataTemp, li, FragDecoder.FragSize );
 80311e6:	a81e      	add	r0, sp, #120	; 0x78
 80311e8:	f7ff fdf2 	bl	8030dd0 <GetRow>
                XorDataLine( rawData, matrixDataTemp, FragDecoder.FragSize );
 80311ec:	79aa      	ldrb	r2, [r5, #6]
 80311ee:	a91e      	add	r1, sp, #120	; 0x78
 80311f0:	4638      	mov	r0, r7
 80311f2:	f7ff fe19 	bl	8030e28 <XorDataLine>
                if( BitArrayIsAllZeros( dataTempVector, FragDecoder.Status.FragNbLost ) )
 80311f6:	f8b5 6880 	ldrh.w	r6, [r5, #2176]	; 0x880
    for( uint16_t i = 0; i < size; i++ )
 80311fa:	2200      	movs	r2, #0
 80311fc:	b290      	uxth	r0, r2
 80311fe:	4286      	cmp	r6, r0
 8031200:	d825      	bhi.n	803124e <FragDecoderProcess+0x262>
            if( FragDecoder.M2BLine == FragDecoder.Status.FragNbLost )
 8031202:	f8b5 3880 	ldrh.w	r3, [r5, #2176]	; 0x880
 8031206:	68ac      	ldr	r4, [r5, #8]
 8031208:	429c      	cmp	r4, r3
 803120a:	f47f af11 	bne.w	8031030 <FragDecoderProcess+0x44>
                if( FragDecoder.Status.FragNbLost > 1 )
 803120e:	2c01      	cmp	r4, #1
 8031210:	4620      	mov	r0, r4
 8031212:	f67f af0f 	bls.w	8031034 <FragDecoderProcess+0x48>
                        GetRow( matrixDataTemp, li, FragDecoder.FragSize );
 8031216:	4d38      	ldr	r5, [pc, #224]	; (80312f8 <FragDecoderProcess+0x30c>)
                    for( i = ( FragDecoder.Status.FragNbLost - 2 ); i >= 0 ; i-- )
 8031218:	3c02      	subs	r4, #2
                        li = FragFindMissingIndex( i );
 803121a:	fa1f fa84 	uxth.w	sl, r4
 803121e:	4650      	mov	r0, sl
 8031220:	f7ff fe56 	bl	8030ed0 <FragFindMissingIndex>
                        GetRow( matrixDataTemp, li, FragDecoder.FragSize );
 8031224:	79aa      	ldrb	r2, [r5, #6]
 8031226:	4601      	mov	r1, r0
                        li = FragFindMissingIndex( i );
 8031228:	4680      	mov	r8, r0
                        GetRow( matrixDataTemp, li, FragDecoder.FragSize );
 803122a:	a81e      	add	r0, sp, #120	; 0x78
 803122c:	f7ff fdd0 	bl	8030dd0 <GetRow>
                        for( j = ( FragDecoder.Status.FragNbLost - 1 ); j > i; j--)
 8031230:	f8b5 6880 	ldrh.w	r6, [r5, #2176]	; 0x880
 8031234:	3e01      	subs	r6, #1
 8031236:	42a6      	cmp	r6, r4
 8031238:	dc62      	bgt.n	8031300 <FragDecoderProcess+0x314>
                        SetRow( matrixDataTemp, li, FragDecoder.FragSize );
 803123a:	79aa      	ldrb	r2, [r5, #6]
 803123c:	4641      	mov	r1, r8
 803123e:	a81e      	add	r0, sp, #120	; 0x78
 8031240:	f7ff fdb4 	bl	8030dac <SetRow>
                    for( i = ( FragDecoder.Status.FragNbLost - 2 ); i >= 0 ; i-- )
 8031244:	3c01      	subs	r4, #1
 8031246:	d2e8      	bcs.n	803121a <FragDecoderProcess+0x22e>
                    return FragDecoder.Status.FragNbLost;
 8031248:	f8b5 0880 	ldrh.w	r0, [r5, #2176]	; 0x880
 803124c:	e6f2      	b.n	8031034 <FragDecoderProcess+0x48>
        if( GetParity( i, bitArray ) == 1 )
 803124e:	a901      	add	r1, sp, #4
 8031250:	f7ff fdd0 	bl	8030df4 <GetParity>
 8031254:	2801      	cmp	r0, #1
 8031256:	f102 0201 	add.w	r2, r2, #1
 803125a:	d1cf      	bne.n	80311fc <FragDecoderProcess+0x210>
 803125c:	2200      	movs	r2, #0
 803125e:	e007      	b.n	8031270 <FragDecoderProcess+0x284>
        if ( GetParity( i, bitArray ) == 1 )
 8031260:	a901      	add	r1, sp, #4
 8031262:	4620      	mov	r0, r4
 8031264:	f7ff fdc6 	bl	8030df4 <GetParity>
 8031268:	2801      	cmp	r0, #1
 803126a:	f102 0201 	add.w	r2, r2, #1
 803126e:	d09e      	beq.n	80311ae <FragDecoderProcess+0x1c2>
 8031270:	b294      	uxth	r4, r2
    for( uint16_t i = 0; i < size; i++)
 8031272:	42a6      	cmp	r6, r4
 8031274:	d8f4      	bhi.n	8031260 <FragDecoderProcess+0x274>
    return 0;
 8031276:	2400      	movs	r4, #0
 8031278:	e799      	b.n	80311ae <FragDecoderProcess+0x1c2>
        findByte      = ( rowIndex * bitsInRow - ( ( rowIndex * ( rowIndex - 1 ) ) >> 1 ) ) >> 3;
 803127a:	1e63      	subs	r3, r4, #1
 803127c:	4363      	muls	r3, r4
 803127e:	fb04 f602 	mul.w	r6, r4, r2
 8031282:	eba6 0663 	sub.w	r6, r6, r3, asr #1
        findBitInByte = ( rowIndex * bitsInRow - ( ( rowIndex * ( rowIndex - 1 ) ) >> 1 ) ) % 8;
 8031286:	4273      	negs	r3, r6
 8031288:	f003 0307 	and.w	r3, r3, #7
        findByte      = ( rowIndex * bitsInRow - ( ( rowIndex * ( rowIndex - 1 ) ) >> 1 ) ) >> 3;
 803128c:	ea4f 09e6 	mov.w	r9, r6, asr #3
        findBitInByte = ( rowIndex * bitsInRow - ( ( rowIndex * ( rowIndex - 1 ) ) >> 1 ) ) % 8;
 8031290:	f006 0607 	and.w	r6, r6, #7
 8031294:	bf58      	it	pl
 8031296:	425e      	negpl	r6, r3
    uint32_t findByte = 0;
 8031298:	46a0      	mov	r8, r4
    }
    for( uint16_t i = rowIndex; i < bitsInRow; i++ )
    {
        if( GetParity( i, bitArray ) == 0 )
        {
            FragDecoder.MatrixM2B[findByte] = FragDecoder.MatrixM2B[findByte] & ( 0xFF - ( 1 << ( 7 - findBitInByte ) ) );
 803129a:	f04f 0a01 	mov.w	sl, #1
 803129e:	e018      	b.n	80312d2 <FragDecoderProcess+0x2e6>
        if( GetParity( i, bitArray ) == 0 )
 80312a0:	a901      	add	r1, sp, #4
 80312a2:	4640      	mov	r0, r8
 80312a4:	f7ff fda6 	bl	8030df4 <GetParity>
 80312a8:	b948      	cbnz	r0, 80312be <FragDecoderProcess+0x2d2>
            FragDecoder.MatrixM2B[findByte] = FragDecoder.MatrixM2B[findByte] & ( 0xFF - ( 1 << ( 7 - findBitInByte ) ) );
 80312aa:	eb05 0309 	add.w	r3, r5, r9
 80312ae:	f1c6 0107 	rsb	r1, r6, #7
 80312b2:	fa0a f001 	lsl.w	r0, sl, r1
 80312b6:	7b19      	ldrb	r1, [r3, #12]
 80312b8:	ea21 0100 	bic.w	r1, r1, r0
 80312bc:	7319      	strb	r1, [r3, #12]
        }
        findBitInByte++;
 80312be:	3601      	adds	r6, #1
        if( findBitInByte == 8 )
 80312c0:	2e08      	cmp	r6, #8
    for( uint16_t i = rowIndex; i < bitsInRow; i++ )
 80312c2:	f108 0801 	add.w	r8, r8, #1
        {
            findBitInByte = 0;
            findByte++;
 80312c6:	bf04      	itt	eq
 80312c8:	f109 0901 	addeq.w	r9, r9, #1
            findBitInByte = 0;
 80312cc:	2600      	moveq	r6, #0
    for( uint16_t i = rowIndex; i < bitsInRow; i++ )
 80312ce:	fa1f f888 	uxth.w	r8, r8
 80312d2:	4542      	cmp	r2, r8
 80312d4:	d8e4      	bhi.n	80312a0 <FragDecoderProcess+0x2b4>
                li = FragFindMissingIndex( firstOneInRow );
 80312d6:	4620      	mov	r0, r4
 80312d8:	f7ff fdfa 	bl	8030ed0 <FragFindMissingIndex>
                SetRow( rawData, li, FragDecoder.FragSize );
 80312dc:	79aa      	ldrb	r2, [r5, #6]
                li = FragFindMissingIndex( firstOneInRow );
 80312de:	4601      	mov	r1, r0
                SetRow( rawData, li, FragDecoder.FragSize );
 80312e0:	4638      	mov	r0, r7
 80312e2:	f7ff fd63 	bl	8030dac <SetRow>
                SetParity( firstOneInRow, FragDecoder.S, 1 );
 80312e6:	4905      	ldr	r1, [pc, #20]	; (80312fc <FragDecoderProcess+0x310>)
 80312e8:	2201      	movs	r2, #1
 80312ea:	4620      	mov	r0, r4
 80312ec:	f7ff fd8c 	bl	8030e08 <SetParity>
                FragDecoder.M2BLine++;
 80312f0:	68ab      	ldr	r3, [r5, #8]
 80312f2:	3301      	adds	r3, #1
 80312f4:	60ab      	str	r3, [r5, #8]
 80312f6:	e784      	b.n	8031202 <FragDecoderProcess+0x216>
 80312f8:	20003f54 	.word	0x20003f54
 80312fc:	200047c8 	.word	0x200047c8
                            FragExtractLineFromBinaryMatrix( dataTempVector2, i, FragDecoder.Status.FragNbLost );
 8031300:	f8b5 2880 	ldrh.w	r2, [r5, #2176]	; 0x880
 8031304:	4651      	mov	r1, sl
 8031306:	a804      	add	r0, sp, #16
 8031308:	fa1f f986 	uxth.w	r9, r6
 803130c:	f7ff fdf6 	bl	8030efc <FragExtractLineFromBinaryMatrix>
                            FragExtractLineFromBinaryMatrix( dataTempVector, j, FragDecoder.Status.FragNbLost );
 8031310:	f8b5 2880 	ldrh.w	r2, [r5, #2176]	; 0x880
 8031314:	4649      	mov	r1, r9
 8031316:	a801      	add	r0, sp, #4
 8031318:	f7ff fdf0 	bl	8030efc <FragExtractLineFromBinaryMatrix>
                            if( GetParity( j, dataTempVector2 ) == 1 )
 803131c:	a904      	add	r1, sp, #16
 803131e:	4648      	mov	r0, r9
 8031320:	f7ff fd68 	bl	8030df4 <GetParity>
 8031324:	2801      	cmp	r0, #1
 8031326:	d185      	bne.n	8031234 <FragDecoderProcess+0x248>
                                XorParityLine( dataTempVector2, dataTempVector, FragDecoder.Status.FragNbLost );
 8031328:	f8b5 2880 	ldrh.w	r2, [r5, #2176]	; 0x880
 803132c:	a901      	add	r1, sp, #4
 803132e:	a804      	add	r0, sp, #16
 8031330:	f7ff fd87 	bl	8030e42 <XorParityLine>
                                lj = FragFindMissingIndex( j );
 8031334:	4648      	mov	r0, r9
 8031336:	f7ff fdcb 	bl	8030ed0 <FragFindMissingIndex>
                                GetRow( rawData, lj, FragDecoder.FragSize );
 803133a:	79aa      	ldrb	r2, [r5, #6]
                                lj = FragFindMissingIndex( j );
 803133c:	4601      	mov	r1, r0
                                GetRow( rawData, lj, FragDecoder.FragSize );
 803133e:	4638      	mov	r0, r7
 8031340:	f7ff fd46 	bl	8030dd0 <GetRow>
                                XorDataLine( matrixDataTemp , rawData , FragDecoder.FragSize );
 8031344:	79aa      	ldrb	r2, [r5, #6]
 8031346:	4639      	mov	r1, r7
 8031348:	a81e      	add	r0, sp, #120	; 0x78
 803134a:	f7ff fd6d 	bl	8030e28 <XorDataLine>
 803134e:	e771      	b.n	8031234 <FragDecoderProcess+0x248>

08031350 <FragDecoderGetStatus>:
    return FragDecoder.Status;
 8031350:	4902      	ldr	r1, [pc, #8]	; (803135c <FragDecoderGetStatus+0xc>)
 8031352:	680a      	ldr	r2, [r1, #0]
 8031354:	6002      	str	r2, [r0, #0]
 8031356:	684a      	ldr	r2, [r1, #4]
 8031358:	6042      	str	r2, [r0, #4]
}
 803135a:	4770      	bx	lr
 803135c:	200047d2 	.word	0x200047d2

08031360 <LmHandlerDeviceTimeReq>:
        return LORAMAC_HANDLER_ERROR;
    }
}

LmHandlerErrorStatus_t LmHandlerDeviceTimeReq( void )
{
 8031360:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    LoRaMacStatus_t status;
    MlmeReq_t mlmeReq;

    mlmeReq.Type = MLME_DEVICE_TIME;
 8031362:	230a      	movs	r3, #10

    status = LoRaMacMlmeRequest( &mlmeReq );
 8031364:	a801      	add	r0, sp, #4
    mlmeReq.Type = MLME_DEVICE_TIME;
 8031366:	f88d 3004 	strb.w	r3, [sp, #4]
    status = LoRaMacMlmeRequest( &mlmeReq );
 803136a:	f004 f81f 	bl	80353ac <LoRaMacMlmeRequest>

    if( status == LORAMAC_STATUS_OK )
 803136e:	3800      	subs	r0, #0
 8031370:	bf18      	it	ne
 8031372:	2001      	movne	r0, #1
    }
    else
    {
        return LORAMAC_HANDLER_ERROR;
    }
}
 8031374:	4240      	negs	r0, r0
 8031376:	b007      	add	sp, #28
 8031378:	f85d fb04 	ldr.w	pc, [sp], #4

0803137c <McpsConfirm>:
 * LORAMAC NOTIFICATIONS HANDLING
 *=============================================================================
 */

static void McpsConfirm( McpsConfirm_t *mcpsConfirm )
{
 803137c:	b570      	push	{r4, r5, r6, lr}
    TxParams.IsMcpsConfirm = 1;
 803137e:	4c11      	ldr	r4, [pc, #68]	; (80313c4 <McpsConfirm+0x48>)
 8031380:	2301      	movs	r3, #1
 8031382:	7023      	strb	r3, [r4, #0]
    TxParams.Status = mcpsConfirm->Status;
 8031384:	7843      	ldrb	r3, [r0, #1]
 8031386:	7063      	strb	r3, [r4, #1]
    TxParams.Datarate = mcpsConfirm->Datarate;
 8031388:	7883      	ldrb	r3, [r0, #2]
 803138a:	7123      	strb	r3, [r4, #4]
    TxParams.UplinkCounter = mcpsConfirm->UpLinkCounter;
 803138c:	68c3      	ldr	r3, [r0, #12]
 803138e:	60a3      	str	r3, [r4, #8]
    TxParams.TxPower = mcpsConfirm->TxPower;
 8031390:	78c3      	ldrb	r3, [r0, #3]
 8031392:	7523      	strb	r3, [r4, #20]
    TxParams.Channel = mcpsConfirm->Channel;
 8031394:	6903      	ldr	r3, [r0, #16]
 8031396:	7563      	strb	r3, [r4, #21]
    TxParams.AckReceived = mcpsConfirm->AckReceived;
 8031398:	7903      	ldrb	r3, [r0, #4]
 803139a:	70e3      	strb	r3, [r4, #3]

    LmHandlerCallbacks->OnTxData( &TxParams );
 803139c:	69a3      	ldr	r3, [r4, #24]
{
 803139e:	4605      	mov	r5, r0
    LmHandlerCallbacks->OnTxData( &TxParams );
 80313a0:	6a1b      	ldr	r3, [r3, #32]
 80313a2:	4620      	mov	r0, r4
 80313a4:	4798      	blx	r3
    }
}

static void LmHandlerPackagesNotify( PackageNotifyTypes_t notifyType, void *params )
{
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 80313a6:	341c      	adds	r4, #28
 80313a8:	2600      	movs	r6, #0
    {
        if( LmHandlerPackages[i] != NULL )
 80313aa:	f854 3b04 	ldr.w	r3, [r4], #4
 80313ae:	b11b      	cbz	r3, 80313b8 <McpsConfirm+0x3c>
        {
            switch( notifyType )
            {
                case PACKAGE_MCPS_CONFIRM:
                {
                    if( LmHandlerPackages[i]->OnMcpsConfirmProcess != NULL )
 80313b0:	699b      	ldr	r3, [r3, #24]
 80313b2:	b10b      	cbz	r3, 80313b8 <McpsConfirm+0x3c>
                    {
                        LmHandlerPackages[i]->OnMcpsConfirmProcess( ( McpsConfirm_t* ) params );
 80313b4:	4628      	mov	r0, r5
 80313b6:	4798      	blx	r3
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 80313b8:	3601      	adds	r6, #1
 80313ba:	b2f3      	uxtb	r3, r6
 80313bc:	2b05      	cmp	r3, #5
 80313be:	b276      	sxtb	r6, r6
 80313c0:	d1f3      	bne.n	80313aa <McpsConfirm+0x2e>
}
 80313c2:	bd70      	pop	{r4, r5, r6, pc}
 80313c4:	200047dc 	.word	0x200047dc

080313c8 <LmHandlerConfigure>:
{
 80313c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    UTIL_MEM_cpy_8((void *)&LmHandlerParams, (const void *)handlerParams, sizeof(LmHandlerParams_t));
 80313cc:	4e63      	ldr	r6, [pc, #396]	; (803155c <LmHandlerConfigure+0x194>)
{
 80313ce:	4601      	mov	r1, r0
    UTIL_MEM_cpy_8((void *)&LmHandlerParams, (const void *)handlerParams, sizeof(LmHandlerParams_t));
 80313d0:	2210      	movs	r2, #16
{
 80313d2:	b09e      	sub	sp, #120	; 0x78
    UTIL_MEM_cpy_8((void *)&LmHandlerParams, (const void *)handlerParams, sizeof(LmHandlerParams_t));
 80313d4:	f106 0030 	add.w	r0, r6, #48	; 0x30
 80313d8:	f009 fd98 	bl	803af0c <UTIL_MEM_cpy_8>
    loraInfo = LoraInfo_GetPtr();
 80313dc:	f7fb fe14 	bl	802d008 <LoraInfo_GetPtr>
    if (0U != ((1 << (LmHandlerParams.ActiveRegion)) & (loraInfo->Region)))
 80313e0:	f896 2030 	ldrb.w	r2, [r6, #48]	; 0x30
 80313e4:	6843      	ldr	r3, [r0, #4]
 80313e6:	2701      	movs	r7, #1
 80313e8:	fa07 f102 	lsl.w	r1, r7, r2
 80313ec:	4019      	ands	r1, r3
 80313ee:	d00a      	beq.n	8031406 <LmHandlerConfigure+0x3e>
        if (LoRaMacInitialization(&LoRaMacPrimitives, &LoRaMacCallbacks, LmHandlerParams.ActiveRegion) != LORAMAC_STATUS_OK)
 80313f0:	f106 0140 	add.w	r1, r6, #64	; 0x40
 80313f4:	f106 0054 	add.w	r0, r6, #84	; 0x54
 80313f8:	f003 fa10 	bl	803481c <LoRaMacInitialization>
 80313fc:	4605      	mov	r5, r0
 80313fe:	b140      	cbz	r0, 8031412 <LmHandlerConfigure+0x4a>
            return LORAMAC_HANDLER_ERROR;
 8031400:	f04f 30ff 	mov.w	r0, #4294967295
 8031404:	e0a6      	b.n	8031554 <LmHandlerConfigure+0x18c>
        MW_LOG(TS_ON, VLEVEL_ALWAYS, "error: Region is not defined in the MW: set lorawan_conf.h accordingly\r\n");
 8031406:	4b56      	ldr	r3, [pc, #344]	; (8031560 <LmHandlerConfigure+0x198>)
 8031408:	463a      	mov	r2, r7
 803140a:	4608      	mov	r0, r1
 803140c:	f009 fc76 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
        while (1) {}  /* error: Region is not defined in the MW */
 8031410:	e7fe      	b.n	8031410 <LmHandlerConfigure+0x48>
    nbNvmData = NvmDataMgmtRestore( );
 8031412:	f005 f97b 	bl	803670c <NvmDataMgmtRestore>
    if( nbNvmData > 0 )
 8031416:	3800      	subs	r0, #0
    memcpy1( CommissioningParams.DevEui, mibReq.Param.DevEui, 8 );
 8031418:	4c52      	ldr	r4, [pc, #328]	; (8031564 <LmHandlerConfigure+0x19c>)
    if( nbNvmData > 0 )
 803141a:	bf18      	it	ne
 803141c:	2001      	movne	r0, #1
    mibReq.Type = MIB_DEV_EUI;
 803141e:	f04f 0802 	mov.w	r8, #2
    if( nbNvmData > 0 )
 8031422:	f886 0064 	strb.w	r0, [r6, #100]	; 0x64
    LoRaMacMibGetRequestConfirm( &mibReq );
 8031426:	a80c      	add	r0, sp, #48	; 0x30
    mibReq.Type = MIB_DEV_EUI;
 8031428:	f88d 8030 	strb.w	r8, [sp, #48]	; 0x30
    LoRaMacMibGetRequestConfirm( &mibReq );
 803142c:	f003 fc16 	bl	8034c5c <LoRaMacMibGetRequestConfirm>
    memcpy1( CommissioningParams.DevEui, mibReq.Param.DevEui, 8 );
 8031430:	990d      	ldr	r1, [sp, #52]	; 0x34
 8031432:	2208      	movs	r2, #8
 8031434:	4620      	mov	r0, r4
 8031436:	f007 fd7b 	bl	8038f30 <memcpy1>
    mibReq.Type = MIB_JOIN_EUI;
 803143a:	2303      	movs	r3, #3
    LoRaMacMibGetRequestConfirm( &mibReq );
 803143c:	a80c      	add	r0, sp, #48	; 0x30
    mibReq.Type = MIB_JOIN_EUI;
 803143e:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
    LoRaMacMibGetRequestConfirm( &mibReq );
 8031442:	f003 fc0b 	bl	8034c5c <LoRaMacMibGetRequestConfirm>
    memcpy1( CommissioningParams.JoinEui, mibReq.Param.JoinEui, 8 );
 8031446:	2208      	movs	r2, #8
 8031448:	18a0      	adds	r0, r4, r2
 803144a:	990d      	ldr	r1, [sp, #52]	; 0x34
 803144c:	f007 fd70 	bl	8038f30 <memcpy1>
    mibReq.Type = MIB_DEV_ADDR;
 8031450:	2306      	movs	r3, #6
 8031452:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
    LoRaMacMibSetRequestConfirm(&mibReq);
 8031456:	a80c      	add	r0, sp, #48	; 0x30
    mibReq.Param.DevAddr = CommissioningParams.DevAddr;
 8031458:	6963      	ldr	r3, [r4, #20]
 803145a:	930d      	str	r3, [sp, #52]	; 0x34
    LoRaMacMibSetRequestConfirm(&mibReq);
 803145c:	f003 fcba 	bl	8034dd4 <LoRaMacMibSetRequestConfirm>
    MW_LOG(TS_OFF, VLEVEL_M, "###### DevEui:  %02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\r\n",
 8031460:	79e3      	ldrb	r3, [r4, #7]
 8031462:	9307      	str	r3, [sp, #28]
 8031464:	79a3      	ldrb	r3, [r4, #6]
 8031466:	9306      	str	r3, [sp, #24]
 8031468:	7963      	ldrb	r3, [r4, #5]
 803146a:	9305      	str	r3, [sp, #20]
 803146c:	7923      	ldrb	r3, [r4, #4]
 803146e:	9304      	str	r3, [sp, #16]
 8031470:	78e3      	ldrb	r3, [r4, #3]
 8031472:	9303      	str	r3, [sp, #12]
 8031474:	78a3      	ldrb	r3, [r4, #2]
 8031476:	9302      	str	r3, [sp, #8]
 8031478:	7863      	ldrb	r3, [r4, #1]
 803147a:	9301      	str	r3, [sp, #4]
 803147c:	7823      	ldrb	r3, [r4, #0]
 803147e:	9300      	str	r3, [sp, #0]
 8031480:	462a      	mov	r2, r5
 8031482:	4b39      	ldr	r3, [pc, #228]	; (8031568 <LmHandlerConfigure+0x1a0>)
 8031484:	4629      	mov	r1, r5
 8031486:	4640      	mov	r0, r8
 8031488:	f009 fc38 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
    MW_LOG(TS_OFF, VLEVEL_M, "###### AppEui:  %02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\r\n",
 803148c:	7be3      	ldrb	r3, [r4, #15]
 803148e:	9307      	str	r3, [sp, #28]
 8031490:	7ba3      	ldrb	r3, [r4, #14]
 8031492:	9306      	str	r3, [sp, #24]
 8031494:	7b63      	ldrb	r3, [r4, #13]
 8031496:	9305      	str	r3, [sp, #20]
 8031498:	7b23      	ldrb	r3, [r4, #12]
 803149a:	9304      	str	r3, [sp, #16]
 803149c:	7ae3      	ldrb	r3, [r4, #11]
 803149e:	9303      	str	r3, [sp, #12]
 80314a0:	7aa3      	ldrb	r3, [r4, #10]
 80314a2:	9302      	str	r3, [sp, #8]
 80314a4:	7a63      	ldrb	r3, [r4, #9]
 80314a6:	9301      	str	r3, [sp, #4]
 80314a8:	7a23      	ldrb	r3, [r4, #8]
 80314aa:	9300      	str	r3, [sp, #0]
 80314ac:	462a      	mov	r2, r5
 80314ae:	4b2f      	ldr	r3, [pc, #188]	; (803156c <LmHandlerConfigure+0x1a4>)
 80314b0:	4629      	mov	r1, r5
 80314b2:	4640      	mov	r0, r8
 80314b4:	f009 fc22 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
    MW_LOG(TS_OFF, VLEVEL_M, "###### DevAddr: %02X:%02X:%02X:%02X\r\n",
 80314b8:	7d23      	ldrb	r3, [r4, #20]
 80314ba:	9303      	str	r3, [sp, #12]
 80314bc:	7d63      	ldrb	r3, [r4, #21]
 80314be:	9302      	str	r3, [sp, #8]
 80314c0:	7da3      	ldrb	r3, [r4, #22]
 80314c2:	9301      	str	r3, [sp, #4]
 80314c4:	7de3      	ldrb	r3, [r4, #23]
 80314c6:	9300      	str	r3, [sp, #0]
 80314c8:	462a      	mov	r2, r5
 80314ca:	4b29      	ldr	r3, [pc, #164]	; (8031570 <LmHandlerConfigure+0x1a8>)
 80314cc:	4629      	mov	r1, r5
 80314ce:	4640      	mov	r0, r8
 80314d0:	f009 fc14 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
    MW_LOG(TS_OFF, VLEVEL_L, "###### KMS ENABLED \r\n");
 80314d4:	462a      	mov	r2, r5
 80314d6:	4629      	mov	r1, r5
 80314d8:	4b26      	ldr	r3, [pc, #152]	; (8031574 <LmHandlerConfigure+0x1ac>)
 80314da:	4638      	mov	r0, r7
 80314dc:	f009 fc0e 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
    mibReq.Type = MIB_PUBLIC_NETWORK;
 80314e0:	240f      	movs	r4, #15
    LoRaMacMibSetRequestConfirm(&mibReq);
 80314e2:	a80c      	add	r0, sp, #48	; 0x30
    mibReq.Type = MIB_PUBLIC_NETWORK;
 80314e4:	f88d 4030 	strb.w	r4, [sp, #48]	; 0x30
    mibReq.Param.EnablePublicNetwork = LORAWAN_PUBLIC_NETWORK;
 80314e8:	f88d 7034 	strb.w	r7, [sp, #52]	; 0x34
    LoRaMacMibSetRequestConfirm(&mibReq);
 80314ec:	f003 fc72 	bl	8034dd4 <LoRaMacMibSetRequestConfirm>
    mibReq.Type = MIB_NET_ID;
 80314f0:	2305      	movs	r3, #5
    LoRaMacMibSetRequestConfirm(&mibReq);
 80314f2:	a80c      	add	r0, sp, #48	; 0x30
    mibReq.Type = MIB_NET_ID;
 80314f4:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
    mibReq.Param.NetID = LORAWAN_NETWORK_ID;
 80314f8:	950d      	str	r5, [sp, #52]	; 0x34
    LoRaMacMibSetRequestConfirm(&mibReq);
 80314fa:	f003 fc6b 	bl	8034dd4 <LoRaMacMibSetRequestConfirm>
    mibReq.Type = MIB_REPEATER_SUPPORT;
 80314fe:	2310      	movs	r3, #16
    LoRaMacMibSetRequestConfirm( &mibReq );
 8031500:	a80c      	add	r0, sp, #48	; 0x30
    mibReq.Type = MIB_REPEATER_SUPPORT;
 8031502:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
    mibReq.Param.EnableRepeaterSupport = LORAWAN_REPEATER_SUPPORT;
 8031506:	f88d 5034 	strb.w	r5, [sp, #52]	; 0x34
    LoRaMacMibSetRequestConfirm( &mibReq );
 803150a:	f003 fc63 	bl	8034dd4 <LoRaMacMibSetRequestConfirm>
    mibReq.Type = MIB_ADR;
 803150e:	2304      	movs	r3, #4
 8031510:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
    LoRaMacMibSetRequestConfirm( &mibReq );
 8031514:	a80c      	add	r0, sp, #48	; 0x30
    mibReq.Param.AdrEnable = LmHandlerParams.AdrEnable;
 8031516:	f896 3032 	ldrb.w	r3, [r6, #50]	; 0x32
 803151a:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
    LoRaMacMibSetRequestConfirm( &mibReq );
 803151e:	f003 fc59 	bl	8034dd4 <LoRaMacMibSetRequestConfirm>
    phyParam = RegionGetPhyParam( LmHandlerParams.ActiveRegion, &getPhy );
 8031522:	a90a      	add	r1, sp, #40	; 0x28
 8031524:	f896 0030 	ldrb.w	r0, [r6, #48]	; 0x30
    getPhy.Attribute = PHY_DUTY_CYCLE;
 8031528:	f88d 4028 	strb.w	r4, [sp, #40]	; 0x28
    phyParam = RegionGetPhyParam( LmHandlerParams.ActiveRegion, &getPhy );
 803152c:	f005 f8f9 	bl	8036722 <RegionGetPhyParam>
    LmHandlerParams.DutyCycleEnabled = (bool) phyParam.Value;
 8031530:	3800      	subs	r0, #0
 8031532:	bf18      	it	ne
 8031534:	2001      	movne	r0, #1
    mibReq.Type = MIB_SYSTEM_MAX_RX_ERROR;
 8031536:	2322      	movs	r3, #34	; 0x22
    LmHandlerParams.DutyCycleEnabled = (bool) phyParam.Value;
 8031538:	f886 0035 	strb.w	r0, [r6, #53]	; 0x35
    mibReq.Type = MIB_SYSTEM_MAX_RX_ERROR;
 803153c:	f88d 3054 	strb.w	r3, [sp, #84]	; 0x54
    if( LoRaMacMibSetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 8031540:	a815      	add	r0, sp, #84	; 0x54
    mibReq.Param.SystemMaxRxError = maxErrorInMs;
 8031542:	2314      	movs	r3, #20
 8031544:	9316      	str	r3, [sp, #88]	; 0x58
    if( LoRaMacMibSetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 8031546:	f003 fc45 	bl	8034dd4 <LoRaMacMibSetRequestConfirm>
    LoRaMacTestSetDutyCycleOn( LmHandlerParams.DutyCycleEnabled );
 803154a:	f896 0035 	ldrb.w	r0, [r6, #53]	; 0x35
 803154e:	f004 f9a5 	bl	803589c <LoRaMacTestSetDutyCycleOn>
    return LORAMAC_HANDLER_SUCCESS;
 8031552:	4628      	mov	r0, r5
}
 8031554:	b01e      	add	sp, #120	; 0x78
 8031556:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 803155a:	bf00      	nop
 803155c:	200047dc 	.word	0x200047dc
 8031560:	0803c181 	.word	0x0803c181
 8031564:	20003458 	.word	0x20003458
 8031568:	0803c1ca 	.word	0x0803c1ca
 803156c:	0803c204 	.word	0x0803c204
 8031570:	0803c23e 	.word	0x0803c23e
 8031574:	0803c264 	.word	0x0803c264

08031578 <LmHandlerProcess>:
{
 8031578:	b538      	push	{r3, r4, r5, lr}
    LoRaMacProcess( );
 803157a:	f002 fc8d 	bl	8033e98 <LoRaMacProcess>
    }
}

static void LmHandlerPackagesProcess( void )
{
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 803157e:	4d0c      	ldr	r5, [pc, #48]	; (80315b0 <LmHandlerProcess+0x38>)
    LoRaMacProcess( );
 8031580:	2405      	movs	r4, #5
    {
        if( ( LmHandlerPackages[i] != NULL ) &&
 8031582:	f855 3b04 	ldr.w	r3, [r5], #4
 8031586:	b15b      	cbz	r3, 80315a0 <LmHandlerProcess+0x28>
 8031588:	691b      	ldr	r3, [r3, #16]
 803158a:	b14b      	cbz	r3, 80315a0 <LmHandlerProcess+0x28>
    if (( id < PKG_MAX_NUMBER ) && ( LmHandlerPackages[id]->IsInitialized != NULL ))
 803158c:	f855 3c04 	ldr.w	r3, [r5, #-4]
 8031590:	689b      	ldr	r3, [r3, #8]
 8031592:	b12b      	cbz	r3, 80315a0 <LmHandlerProcess+0x28>
        return LmHandlerPackages[id]->IsInitialized( );
 8031594:	4798      	blx	r3
            ( LmHandlerPackages[i]->Process != NULL ) &&
 8031596:	b118      	cbz	r0, 80315a0 <LmHandlerProcess+0x28>
            ( LmHandlerPackageIsInitialized( i ) != false ) )
        {
            LmHandlerPackages[i]->Process( );
 8031598:	f855 3c04 	ldr.w	r3, [r5, #-4]
 803159c:	691b      	ldr	r3, [r3, #16]
 803159e:	4798      	blx	r3
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 80315a0:	3c01      	subs	r4, #1
 80315a2:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
 80315a6:	d1ec      	bne.n	8031582 <LmHandlerProcess+0xa>
}
 80315a8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    NvmDataMgmtStore( );
 80315ac:	f005 b8ac 	b.w	8036708 <NvmDataMgmtStore>
 80315b0:	200047f8 	.word	0x200047f8

080315b4 <LmHandlerJoinStatus>:
{
 80315b4:	b500      	push	{lr}
 80315b6:	b08b      	sub	sp, #44	; 0x2c
    mibReq.Type = MIB_NETWORK_ACTIVATION;
 80315b8:	2301      	movs	r3, #1
    status = LoRaMacMibGetRequestConfirm( &mibReq );
 80315ba:	a801      	add	r0, sp, #4
    mibReq.Type = MIB_NETWORK_ACTIVATION;
 80315bc:	f88d 3004 	strb.w	r3, [sp, #4]
    status = LoRaMacMibGetRequestConfirm( &mibReq );
 80315c0:	f003 fb4c 	bl	8034c5c <LoRaMacMibGetRequestConfirm>
    if( status == LORAMAC_STATUS_OK )
 80315c4:	b938      	cbnz	r0, 80315d6 <LmHandlerJoinStatus+0x22>
        if( mibReq.Param.NetworkActivation == ACTIVATION_TYPE_NONE )
 80315c6:	f89d 0008 	ldrb.w	r0, [sp, #8]
            return LORAMAC_HANDLER_RESET;
 80315ca:	3800      	subs	r0, #0
 80315cc:	bf18      	it	ne
 80315ce:	2001      	movne	r0, #1
}
 80315d0:	b00b      	add	sp, #44	; 0x2c
 80315d2:	f85d fb04 	ldr.w	pc, [sp], #4
        return LORAMAC_HANDLER_RESET;
 80315d6:	2000      	movs	r0, #0
 80315d8:	e7fa      	b.n	80315d0 <LmHandlerJoinStatus+0x1c>
	...

080315dc <LmHandlerRequestClass>:
{
 80315dc:	b530      	push	{r4, r5, lr}
 80315de:	b08d      	sub	sp, #52	; 0x34
 80315e0:	4605      	mov	r5, r0
    if (LoRaMacIsBusy() == true)
 80315e2:	f002 fc4b 	bl	8033e7c <LoRaMacIsBusy>
 80315e6:	4604      	mov	r4, r0
 80315e8:	2800      	cmp	r0, #0
 80315ea:	d14a      	bne.n	8031682 <LmHandlerRequestClass+0xa6>
    if (LmHandlerJoinStatus() != LORAMAC_HANDLER_SET)
 80315ec:	f7ff ffe2 	bl	80315b4 <LmHandlerJoinStatus>
 80315f0:	2801      	cmp	r0, #1
 80315f2:	d149      	bne.n	8031688 <LmHandlerRequestClass+0xac>
    if ( LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 80315f4:	a803      	add	r0, sp, #12
    mibReq.Type = MIB_DEVICE_CLASS;
 80315f6:	f88d 400c 	strb.w	r4, [sp, #12]
    if ( LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 80315fa:	f003 fb2f 	bl	8034c5c <LoRaMacMibGetRequestConfirm>
 80315fe:	b110      	cbz	r0, 8031606 <LmHandlerRequestClass+0x2a>
        switch( newClass )
 8031600:	f04f 30ff 	mov.w	r0, #4294967295
 8031604:	e004      	b.n	8031610 <LmHandlerRequestClass+0x34>
    currentClass = mibReq.Param.Class;
 8031606:	f89d 3010 	ldrb.w	r3, [sp, #16]
    if( currentClass != newClass )
 803160a:	42ab      	cmp	r3, r5
 803160c:	d102      	bne.n	8031614 <LmHandlerRequestClass+0x38>
    LmHandlerErrorStatus_t errorStatus = LORAMAC_HANDLER_SUCCESS;
 803160e:	2000      	movs	r0, #0
}
 8031610:	b00d      	add	sp, #52	; 0x34
 8031612:	bd30      	pop	{r4, r5, pc}
        switch( newClass )
 8031614:	2d01      	cmp	r5, #1
 8031616:	d0f3      	beq.n	8031600 <LmHandlerRequestClass+0x24>
 8031618:	2d02      	cmp	r5, #2
 803161a:	d01a      	beq.n	8031652 <LmHandlerRequestClass+0x76>
 803161c:	2d00      	cmp	r5, #0
 803161e:	d1f7      	bne.n	8031610 <LmHandlerRequestClass+0x34>
                if( currentClass != CLASS_A )
 8031620:	2b00      	cmp	r3, #0
 8031622:	d0f4      	beq.n	803160e <LmHandlerRequestClass+0x32>
                    if( LoRaMacMibSetRequestConfirm( &mibReq ) == LORAMAC_STATUS_OK )
 8031624:	a803      	add	r0, sp, #12
                    mibReq.Param.Class = newClass;
 8031626:	f88d 5010 	strb.w	r5, [sp, #16]
                    if( LoRaMacMibSetRequestConfirm( &mibReq ) == LORAMAC_STATUS_OK )
 803162a:	f003 fbd3 	bl	8034dd4 <LoRaMacMibSetRequestConfirm>
 803162e:	4602      	mov	r2, r0
 8031630:	2800      	cmp	r0, #0
 8031632:	d1e5      	bne.n	8031600 <LmHandlerRequestClass+0x24>
    }
}

static void DisplayClassUpdate(DeviceClass_t deviceClass)
{
    MW_LOG(TS_OFF, VLEVEL_M, "Switch to Class %c done\r\n", "ABC"[deviceClass]);
 8031634:	2341      	movs	r3, #65	; 0x41
 8031636:	9300      	str	r3, [sp, #0]
 8031638:	4601      	mov	r1, r0
 803163a:	4b15      	ldr	r3, [pc, #84]	; (8031690 <LmHandlerRequestClass+0xb4>)
 803163c:	2002      	movs	r0, #2
 803163e:	f009 fb5d 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
                        if (LmHandlerCallbacks->OnClassChange != NULL)
 8031642:	4b14      	ldr	r3, [pc, #80]	; (8031694 <LmHandlerRequestClass+0xb8>)
 8031644:	699b      	ldr	r3, [r3, #24]
 8031646:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8031648:	2b00      	cmp	r3, #0
 803164a:	d0e0      	beq.n	803160e <LmHandlerRequestClass+0x32>
                            LmHandlerCallbacks->OnClassChange( newClass );
 803164c:	2000      	movs	r0, #0
 803164e:	4798      	blx	r3
 8031650:	e7dd      	b.n	803160e <LmHandlerRequestClass+0x32>
                if( currentClass != CLASS_A )
 8031652:	2b00      	cmp	r3, #0
 8031654:	d1d4      	bne.n	8031600 <LmHandlerRequestClass+0x24>
                    if (LoRaMacMibSetRequestConfirm( &mibReq ) == LORAMAC_STATUS_OK)
 8031656:	a803      	add	r0, sp, #12
                    mibReq.Param.Class = newClass;
 8031658:	f88d 5010 	strb.w	r5, [sp, #16]
                    if (LoRaMacMibSetRequestConfirm( &mibReq ) == LORAMAC_STATUS_OK)
 803165c:	f003 fbba 	bl	8034dd4 <LoRaMacMibSetRequestConfirm>
 8031660:	2800      	cmp	r0, #0
 8031662:	d1cd      	bne.n	8031600 <LmHandlerRequestClass+0x24>
    MW_LOG(TS_OFF, VLEVEL_M, "Switch to Class %c done\r\n", "ABC"[deviceClass]);
 8031664:	2343      	movs	r3, #67	; 0x43
 8031666:	9300      	str	r3, [sp, #0]
 8031668:	4602      	mov	r2, r0
 803166a:	4b09      	ldr	r3, [pc, #36]	; (8031690 <LmHandlerRequestClass+0xb4>)
 803166c:	4601      	mov	r1, r0
 803166e:	4628      	mov	r0, r5
 8031670:	f009 fb44 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
                        if (LmHandlerCallbacks->OnClassChange != NULL)
 8031674:	4b07      	ldr	r3, [pc, #28]	; (8031694 <LmHandlerRequestClass+0xb8>)
 8031676:	699b      	ldr	r3, [r3, #24]
 8031678:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 803167a:	2b00      	cmp	r3, #0
 803167c:	d0c7      	beq.n	803160e <LmHandlerRequestClass+0x32>
                            LmHandlerCallbacks->OnClassChange( newClass );
 803167e:	4628      	mov	r0, r5
 8031680:	e7e5      	b.n	803164e <LmHandlerRequestClass+0x72>
        return LORAMAC_HANDLER_BUSY_ERROR;
 8031682:	f06f 0001 	mvn.w	r0, #1
 8031686:	e7c3      	b.n	8031610 <LmHandlerRequestClass+0x34>
        return LORAMAC_HANDLER_NO_NETWORK_JOINED;
 8031688:	f06f 0002 	mvn.w	r0, #2
 803168c:	e7c0      	b.n	8031610 <LmHandlerRequestClass+0x34>
 803168e:	bf00      	nop
 8031690:	0803c27a 	.word	0x0803c27a
 8031694:	200047dc 	.word	0x200047dc

08031698 <LmHandlerJoin>:
{
 8031698:	b530      	push	{r4, r5, lr}
    if ( mode == ACTIVATION_TYPE_OTAA )
 803169a:	2802      	cmp	r0, #2
 803169c:	4b1f      	ldr	r3, [pc, #124]	; (803171c <LmHandlerJoin+0x84>)
 803169e:	4c20      	ldr	r4, [pc, #128]	; (8031720 <LmHandlerJoin+0x88>)
{
 80316a0:	b08b      	sub	sp, #44	; 0x2c
 80316a2:	f04f 0501 	mov.w	r5, #1
    if ( mode == ACTIVATION_TYPE_OTAA )
 80316a6:	d10d      	bne.n	80316c4 <LmHandlerJoin+0x2c>
        JoinParams.Mode = ACTIVATION_TYPE_OTAA;
 80316a8:	7698      	strb	r0, [r3, #26]
        LoRaMacStart();
 80316aa:	f003 fa77 	bl	8034b9c <LoRaMacStart>
        mlmeReq.Req.Join.Datarate = LmHandlerParams.TxDatarate;
 80316ae:	f894 3033 	ldrb.w	r3, [r4, #51]	; 0x33
        mlmeReq.Type = MLME_JOIN;
 80316b2:	f88d 5004 	strb.w	r5, [sp, #4]
        LoRaMacMlmeRequest( &mlmeReq );
 80316b6:	a801      	add	r0, sp, #4
        mlmeReq.Req.Join.Datarate = LmHandlerParams.TxDatarate;
 80316b8:	f88d 3008 	strb.w	r3, [sp, #8]
        LoRaMacMlmeRequest( &mlmeReq );
 80316bc:	f003 fe76 	bl	80353ac <LoRaMacMlmeRequest>
}
 80316c0:	b00b      	add	sp, #44	; 0x2c
 80316c2:	bd30      	pop	{r4, r5, pc}
        JoinParams.Datarate = LmHandlerParams.TxDatarate;
 80316c4:	f894 2033 	ldrb.w	r2, [r4, #51]	; 0x33
 80316c8:	761a      	strb	r2, [r3, #24]
        JoinParams.Status = LORAMAC_HANDLER_SUCCESS;
 80316ca:	2200      	movs	r2, #0
        JoinParams.Mode = ACTIVATION_TYPE_ABP;
 80316cc:	769d      	strb	r5, [r3, #26]
        JoinParams.Status = LORAMAC_HANDLER_SUCCESS;
 80316ce:	765a      	strb	r2, [r3, #25]
        if (CtxRestoreDone == false)
 80316d0:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
 80316d4:	b97b      	cbnz	r3, 80316f6 <LmHandlerJoin+0x5e>
            mibReq.Type = MIB_ABP_LORAWAN_VERSION;
 80316d6:	2327      	movs	r3, #39	; 0x27
 80316d8:	f88d 3004 	strb.w	r3, [sp, #4]
            LoRaMacMibSetRequestConfirm(&mibReq);
 80316dc:	a801      	add	r0, sp, #4
            mibReq.Param.AbpLrWanVersion.Value = ABP_ACTIVATION_LRWAN_VERSION;
 80316de:	4b11      	ldr	r3, [pc, #68]	; (8031724 <LmHandlerJoin+0x8c>)
 80316e0:	9302      	str	r3, [sp, #8]
            LoRaMacMibSetRequestConfirm(&mibReq);
 80316e2:	f003 fb77 	bl	8034dd4 <LoRaMacMibSetRequestConfirm>
            SecureElementSetObjHandler(NWK_S_KEY, KMS_NWK_S_KEY_OBJECT_HANDLE);
 80316e6:	2110      	movs	r1, #16
 80316e8:	2002      	movs	r0, #2
 80316ea:	f007 f8e7 	bl	80388bc <SecureElementSetObjHandler>
            SecureElementSetObjHandler(APP_S_KEY, KMS_APP_S_KEY_OBJECT_HANDLE);
 80316ee:	2111      	movs	r1, #17
 80316f0:	2003      	movs	r0, #3
 80316f2:	f007 f8e3 	bl	80388bc <SecureElementSetObjHandler>
        LoRaMacStart();
 80316f6:	f003 fa51 	bl	8034b9c <LoRaMacStart>
        mibReq.Type = MIB_NETWORK_ACTIVATION;
 80316fa:	2301      	movs	r3, #1
        LoRaMacMibSetRequestConfirm( &mibReq );
 80316fc:	a801      	add	r0, sp, #4
        mibReq.Type = MIB_NETWORK_ACTIVATION;
 80316fe:	f88d 3004 	strb.w	r3, [sp, #4]
        mibReq.Param.NetworkActivation = ACTIVATION_TYPE_ABP;
 8031702:	f88d 3008 	strb.w	r3, [sp, #8]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8031706:	f003 fb65 	bl	8034dd4 <LoRaMacMibSetRequestConfirm>
        LmHandlerCallbacks->OnJoinRequest( &JoinParams );
 803170a:	69a3      	ldr	r3, [r4, #24]
 803170c:	4806      	ldr	r0, [pc, #24]	; (8031728 <LmHandlerJoin+0x90>)
 803170e:	69db      	ldr	r3, [r3, #28]
 8031710:	4798      	blx	r3
        LmHandlerRequestClass(LmHandlerParams.DefaultClass);
 8031712:	f894 0031 	ldrb.w	r0, [r4, #49]	; 0x31
 8031716:	f7ff ff61 	bl	80315dc <LmHandlerRequestClass>
}
 803171a:	e7d1      	b.n	80316c0 <LmHandlerJoin+0x28>
 803171c:	20003458 	.word	0x20003458
 8031720:	200047dc 	.word	0x200047dc
 8031724:	01000300 	.word	0x01000300
 8031728:	20003470 	.word	0x20003470

0803172c <LmHandlerIsBusy>:
{
 803172c:	b510      	push	{r4, lr}
    if( LoRaMacIsBusy( ) == true )
 803172e:	f002 fba5 	bl	8033e7c <LoRaMacIsBusy>
 8031732:	b940      	cbnz	r0, 8031746 <LmHandlerIsBusy+0x1a>
    if( LmHandlerJoinStatus( ) != LORAMAC_HANDLER_SET )
 8031734:	f7ff ff3e 	bl	80315b4 <LmHandlerJoinStatus>
 8031738:	2801      	cmp	r0, #1
 803173a:	d005      	beq.n	8031748 <LmHandlerIsBusy+0x1c>
        LmHandlerJoin( JoinParams.Mode );
 803173c:	4b05      	ldr	r3, [pc, #20]	; (8031754 <LmHandlerIsBusy+0x28>)
 803173e:	7e98      	ldrb	r0, [r3, #26]
 8031740:	f7ff ffaa 	bl	8031698 <LmHandlerJoin>
        return true;
 8031744:	2001      	movs	r0, #1
}
 8031746:	bd10      	pop	{r4, pc}
    if( LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->IsRunning( ) == true )
 8031748:	4b03      	ldr	r3, [pc, #12]	; (8031758 <LmHandlerIsBusy+0x2c>)
 803174a:	69db      	ldr	r3, [r3, #28]
}
 803174c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    if( LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->IsRunning( ) == true )
 8031750:	68db      	ldr	r3, [r3, #12]
 8031752:	4718      	bx	r3
 8031754:	20003458 	.word	0x20003458
 8031758:	200047dc 	.word	0x200047dc

0803175c <LmHandlerSend>:
{
 803175c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8031760:	b087      	sub	sp, #28
 8031762:	4604      	mov	r4, r0
 8031764:	460e      	mov	r6, r1
 8031766:	4617      	mov	r7, r2
 8031768:	4698      	mov	r8, r3
    if (LoRaMacIsBusy() == true)
 803176a:	f002 fb87 	bl	8033e7c <LoRaMacIsBusy>
 803176e:	2800      	cmp	r0, #0
 8031770:	d154      	bne.n	803181c <LmHandlerSend+0xc0>
    if( LmHandlerJoinStatus( ) != LORAMAC_HANDLER_SET )
 8031772:	f7ff ff1f 	bl	80315b4 <LmHandlerJoinStatus>
 8031776:	2801      	cmp	r0, #1
 8031778:	d008      	beq.n	803178c <LmHandlerSend+0x30>
        LmHandlerJoin(JoinParams.Mode);
 803177a:	4b2d      	ldr	r3, [pc, #180]	; (8031830 <LmHandlerSend+0xd4>)
 803177c:	7e98      	ldrb	r0, [r3, #26]
 803177e:	f7ff ff8b 	bl	8031698 <LmHandlerJoin>
        return LORAMAC_HANDLER_NO_NETWORK_JOINED;
 8031782:	f06f 0002 	mvn.w	r0, #2
}
 8031786:	b007      	add	sp, #28
 8031788:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if( ( LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->IsRunning( ) == true ) && ( appData->Port != LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->Port ) && ( appData->Port != 0 ) )
 803178c:	f8df 90ac 	ldr.w	r9, [pc, #172]	; 803183c <LmHandlerSend+0xe0>
 8031790:	f8d9 301c 	ldr.w	r3, [r9, #28]
 8031794:	68db      	ldr	r3, [r3, #12]
 8031796:	4798      	blx	r3
 8031798:	464d      	mov	r5, r9
 803179a:	b138      	cbz	r0, 80317ac <LmHandlerSend+0x50>
 803179c:	f8d9 201c 	ldr.w	r2, [r9, #28]
 80317a0:	7823      	ldrb	r3, [r4, #0]
 80317a2:	7812      	ldrb	r2, [r2, #0]
 80317a4:	429a      	cmp	r2, r3
 80317a6:	d001      	beq.n	80317ac <LmHandlerSend+0x50>
 80317a8:	2b00      	cmp	r3, #0
 80317aa:	d13a      	bne.n	8031822 <LmHandlerSend+0xc6>
    mcpsReq.Req.Unconfirmed.Datarate = LmHandlerParams.TxDatarate;
 80317ac:	f895 3033 	ldrb.w	r3, [r5, #51]	; 0x33
    if( LoRaMacQueryTxPossible( appData->BufferSize, &txInfo ) != LORAMAC_STATUS_OK )
 80317b0:	7860      	ldrb	r0, [r4, #1]
    mcpsReq.Req.Unconfirmed.Datarate = LmHandlerParams.TxDatarate;
 80317b2:	f88d 3012 	strb.w	r3, [sp, #18]
    if( LoRaMacQueryTxPossible( appData->BufferSize, &txInfo ) != LORAMAC_STATUS_OK )
 80317b6:	4669      	mov	r1, sp
 80317b8:	f003 f9f8 	bl	8034bac <LoRaMacQueryTxPossible>
 80317bc:	b1d0      	cbz	r0, 80317f4 <LmHandlerSend+0x98>
        TxParams.MsgType = LORAMAC_HANDLER_UNCONFIRMED_MSG;
 80317be:	2200      	movs	r2, #0
 80317c0:	70aa      	strb	r2, [r5, #2]
        mcpsReq.Type = MCPS_UNCONFIRMED;
 80317c2:	f88d 2004 	strb.w	r2, [sp, #4]
        mcpsReq.Req.Unconfirmed.fBuffer = NULL;
 80317c6:	9203      	str	r2, [sp, #12]
        mcpsReq.Req.Unconfirmed.fBufferSize = 0;
 80317c8:	f8ad 2010 	strh.w	r2, [sp, #16]
    TxParams.AppData = *appData;
 80317cc:	e894 0003 	ldmia.w	r4, {r0, r1}
 80317d0:	4b18      	ldr	r3, [pc, #96]	; (8031834 <LmHandlerSend+0xd8>)
 80317d2:	e883 0003 	stmia.w	r3, {r0, r1}
    TxParams.Datarate = LmHandlerParams.TxDatarate;
 80317d6:	f895 3033 	ldrb.w	r3, [r5, #51]	; 0x33
 80317da:	712b      	strb	r3, [r5, #4]
    status = LoRaMacMcpsRequest(&mcpsReq, allowDelayedTx);
 80317dc:	4641      	mov	r1, r8
 80317de:	a801      	add	r0, sp, #4
 80317e0:	f003 fed6 	bl	8035590 <LoRaMacMcpsRequest>
    if (nextTxIn != NULL)
 80317e4:	b10f      	cbz	r7, 80317ea <LmHandlerSend+0x8e>
        *nextTxIn = mcpsReq.ReqReturn.DutyCycleWaitTime;
 80317e6:	9b05      	ldr	r3, [sp, #20]
 80317e8:	603b      	str	r3, [r7, #0]
    switch (status)
 80317ea:	2811      	cmp	r0, #17
 80317ec:	d81c      	bhi.n	8031828 <LmHandlerSend+0xcc>
 80317ee:	4b12      	ldr	r3, [pc, #72]	; (8031838 <LmHandlerSend+0xdc>)
 80317f0:	5618      	ldrsb	r0, [r3, r0]
 80317f2:	e7c8      	b.n	8031786 <LmHandlerSend+0x2a>
        TxParams.MsgType = isTxConfirmed;
 80317f4:	70ae      	strb	r6, [r5, #2]
        mcpsReq.Req.Unconfirmed.fPort = appData->Port;
 80317f6:	7823      	ldrb	r3, [r4, #0]
 80317f8:	f88d 3008 	strb.w	r3, [sp, #8]
        mcpsReq.Req.Unconfirmed.fBufferSize = appData->BufferSize;
 80317fc:	7863      	ldrb	r3, [r4, #1]
 80317fe:	f8ad 3010 	strh.w	r3, [sp, #16]
        mcpsReq.Req.Unconfirmed.fBuffer = appData->Buffer;
 8031802:	6863      	ldr	r3, [r4, #4]
 8031804:	9303      	str	r3, [sp, #12]
        if( isTxConfirmed == LORAMAC_HANDLER_UNCONFIRMED_MSG )
 8031806:	b916      	cbnz	r6, 803180e <LmHandlerSend+0xb2>
            mcpsReq.Type = MCPS_UNCONFIRMED;
 8031808:	f88d 6004 	strb.w	r6, [sp, #4]
 803180c:	e7de      	b.n	80317cc <LmHandlerSend+0x70>
            mcpsReq.Type = MCPS_CONFIRMED;
 803180e:	2301      	movs	r3, #1
 8031810:	f88d 3004 	strb.w	r3, [sp, #4]
            mcpsReq.Req.Confirmed.NbTrials = 8;
 8031814:	2308      	movs	r3, #8
 8031816:	f88d 3013 	strb.w	r3, [sp, #19]
 803181a:	e7d7      	b.n	80317cc <LmHandlerSend+0x70>
        return LORAMAC_HANDLER_BUSY_ERROR;
 803181c:	f06f 0001 	mvn.w	r0, #1
 8031820:	e7b1      	b.n	8031786 <LmHandlerSend+0x2a>
        return LORAMAC_HANDLER_COMPLIANCE_RUNNING;
 8031822:	f06f 0003 	mvn.w	r0, #3
 8031826:	e7ae      	b.n	8031786 <LmHandlerSend+0x2a>
 8031828:	f04f 30ff 	mov.w	r0, #4294967295
 803182c:	e7ab      	b.n	8031786 <LmHandlerSend+0x2a>
 803182e:	bf00      	nop
 8031830:	20003458 	.word	0x20003458
 8031834:	200047e8 	.word	0x200047e8
 8031838:	0803baa8 	.word	0x0803baa8
 803183c:	200047dc 	.word	0x200047dc

08031840 <MlmeIndication>:
{
 8031840:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8031842:	4604      	mov	r4, r0
    RxParams.IsMcpsIndication = 0;
 8031844:	4b14      	ldr	r3, [pc, #80]	; (8031898 <MlmeIndication+0x58>)
    RxParams.Status = mlmeIndication->Status;
 8031846:	7862      	ldrb	r2, [r4, #1]
 8031848:	775a      	strb	r2, [r3, #29]
    RxParams.IsMcpsIndication = 0;
 803184a:	2000      	movs	r0, #0
 803184c:	7718      	strb	r0, [r3, #28]
    RxParams.Rssi = RxStatus->Rssi;
 803184e:	880d      	ldrh	r5, [r1, #0]
 8031850:	77dd      	strb	r5, [r3, #31]
    RxParams.Snr = RxStatus->Snr;
 8031852:	788d      	ldrb	r5, [r1, #2]
 8031854:	f883 5020 	strb.w	r5, [r3, #32]
    RxParams.RxSlot = RxStatus->RxSlot;
 8031858:	78c9      	ldrb	r1, [r1, #3]
 803185a:	f883 1028 	strb.w	r1, [r3, #40]	; 0x28
    if( RxParams.Status != LORAMAC_EVENT_INFO_STATUS_BEACON_LOCKED )
 803185e:	2a0e      	cmp	r2, #14
 8031860:	d005      	beq.n	803186e <MlmeIndication+0x2e>
        LmHandlerCallbacks->OnRxData( NULL, &RxParams );
 8031862:	4a0e      	ldr	r2, [pc, #56]	; (803189c <MlmeIndication+0x5c>)
 8031864:	6992      	ldr	r2, [r2, #24]
 8031866:	f103 011c 	add.w	r1, r3, #28
 803186a:	6a52      	ldr	r2, [r2, #36]	; 0x24
 803186c:	4790      	blx	r2
    switch( mlmeIndication->MlmeIndication )
 803186e:	7823      	ldrb	r3, [r4, #0]
 8031870:	2b07      	cmp	r3, #7
 8031872:	d10e      	bne.n	8031892 <MlmeIndication+0x52>
            LmHandlerAppData_t appData =
 8031874:	2300      	movs	r3, #0
 8031876:	f8ad 3000 	strh.w	r3, [sp]
 803187a:	9301      	str	r3, [sp, #4]
            if( LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->IsRunning( ) == false )
 803187c:	4b07      	ldr	r3, [pc, #28]	; (803189c <MlmeIndication+0x5c>)
 803187e:	69db      	ldr	r3, [r3, #28]
 8031880:	68db      	ldr	r3, [r3, #12]
 8031882:	4798      	blx	r3
 8031884:	4602      	mov	r2, r0
 8031886:	b920      	cbnz	r0, 8031892 <MlmeIndication+0x52>
                LmHandlerSend( &appData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true );
 8031888:	4601      	mov	r1, r0
 803188a:	2301      	movs	r3, #1
 803188c:	4668      	mov	r0, sp
 803188e:	f7ff ff65 	bl	803175c <LmHandlerSend>
}
 8031892:	b003      	add	sp, #12
 8031894:	bd30      	pop	{r4, r5, pc}
 8031896:	bf00      	nop
 8031898:	20003458 	.word	0x20003458
 803189c:	200047dc 	.word	0x200047dc

080318a0 <LmHandlerGetCurrentClass>:
{
 80318a0:	b510      	push	{r4, lr}
    if (deviceClass == NULL)
 80318a2:	4604      	mov	r4, r0
{
 80318a4:	b08a      	sub	sp, #40	; 0x28
    if (deviceClass == NULL)
 80318a6:	b918      	cbnz	r0, 80318b0 <LmHandlerGetCurrentClass+0x10>
        return LORAMAC_HANDLER_ERROR;
 80318a8:	f04f 30ff 	mov.w	r0, #4294967295
}
 80318ac:	b00a      	add	sp, #40	; 0x28
 80318ae:	bd10      	pop	{r4, pc}
    mibReq.Type = MIB_DEVICE_CLASS;
 80318b0:	2300      	movs	r3, #0
    if (LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK)
 80318b2:	a801      	add	r0, sp, #4
    mibReq.Type = MIB_DEVICE_CLASS;
 80318b4:	f88d 3004 	strb.w	r3, [sp, #4]
    if (LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK)
 80318b8:	f003 f9d0 	bl	8034c5c <LoRaMacMibGetRequestConfirm>
 80318bc:	2800      	cmp	r0, #0
 80318be:	d1f3      	bne.n	80318a8 <LmHandlerGetCurrentClass+0x8>
    *deviceClass = mibReq.Param.Class;
 80318c0:	f89d 3008 	ldrb.w	r3, [sp, #8]
 80318c4:	7023      	strb	r3, [r4, #0]
    return LORAMAC_HANDLER_SUCCESS;
 80318c6:	e7f1      	b.n	80318ac <LmHandlerGetCurrentClass+0xc>

080318c8 <McpsIndication>:
{
 80318c8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80318ca:	b087      	sub	sp, #28
    DeviceClass_t deviceClass = CLASS_A;
 80318cc:	2300      	movs	r3, #0
 80318ce:	f88d 3007 	strb.w	r3, [sp, #7]
    RxParams.IsMcpsIndication = 1;
 80318d2:	4b2c      	ldr	r3, [pc, #176]	; (8031984 <McpsIndication+0xbc>)
 80318d4:	2201      	movs	r2, #1
 80318d6:	771a      	strb	r2, [r3, #28]
    RxParams.Status = mcpsIndication->Status;
 80318d8:	7842      	ldrb	r2, [r0, #1]
 80318da:	775a      	strb	r2, [r3, #29]
{
 80318dc:	4604      	mov	r4, r0
    if( RxParams.Status != LORAMAC_EVENT_INFO_STATUS_OK )
 80318de:	2a00      	cmp	r2, #0
 80318e0:	d146      	bne.n	8031970 <McpsIndication+0xa8>
    RxParams.Datarate = mcpsIndication->RxDatarate;
 80318e2:	7902      	ldrb	r2, [r0, #4]
 80318e4:	779a      	strb	r2, [r3, #30]
    RxParams.Rssi = RxStatus->Rssi;
 80318e6:	880a      	ldrh	r2, [r1, #0]
 80318e8:	77da      	strb	r2, [r3, #31]
    RxParams.Snr = RxStatus->Snr;
 80318ea:	788a      	ldrb	r2, [r1, #2]
 80318ec:	f883 2020 	strb.w	r2, [r3, #32]
    RxParams.RxSlot = RxStatus->RxSlot;
 80318f0:	78ca      	ldrb	r2, [r1, #3]
 80318f2:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
    RxParams.DownlinkCounter = mcpsIndication->DownLinkCounter;
 80318f6:	6902      	ldr	r2, [r0, #16]
 80318f8:	625a      	str	r2, [r3, #36]	; 0x24
    appData.Port = mcpsIndication->Port;
 80318fa:	78c2      	ldrb	r2, [r0, #3]
    LmHandlerCallbacks->OnRxData(&appData, &RxParams);
 80318fc:	4e22      	ldr	r6, [pc, #136]	; (8031988 <McpsIndication+0xc0>)
    appData.Port = mcpsIndication->Port;
 80318fe:	f88d 2008 	strb.w	r2, [sp, #8]
    appData.BufferSize = mcpsIndication->BufferSize;
 8031902:	7b02      	ldrb	r2, [r0, #12]
 8031904:	f88d 2009 	strb.w	r2, [sp, #9]
    appData.Buffer = mcpsIndication->Buffer;
 8031908:	6882      	ldr	r2, [r0, #8]
 803190a:	9203      	str	r2, [sp, #12]
    LmHandlerCallbacks->OnRxData(&appData, &RxParams);
 803190c:	69b2      	ldr	r2, [r6, #24]
 803190e:	f103 011c 	add.w	r1, r3, #28
 8031912:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8031914:	a802      	add	r0, sp, #8
 8031916:	4790      	blx	r2
    if ((LmHandlerCallbacks->OnSysTimeUpdate != NULL) && (mcpsIndication->DeviceTimeAnsReceived == true))
 8031918:	69b3      	ldr	r3, [r6, #24]
 803191a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 803191c:	b113      	cbz	r3, 8031924 <McpsIndication+0x5c>
 803191e:	7e22      	ldrb	r2, [r4, #24]
 8031920:	b102      	cbz	r2, 8031924 <McpsIndication+0x5c>
        LmHandlerCallbacks->OnSysTimeUpdate( );
 8031922:	4798      	blx	r3
 8031924:	4f19      	ldr	r7, [pc, #100]	; (803198c <McpsIndication+0xc4>)
{
 8031926:	2500      	movs	r5, #0
        if( LmHandlerPackages[i] != NULL )
 8031928:	f857 3b04 	ldr.w	r3, [r7], #4
 803192c:	b153      	cbz	r3, 8031944 <McpsIndication+0x7c>
                    if( ( LmHandlerPackages[i]->OnMcpsIndicationProcess != NULL ) &&
 803192e:	69da      	ldr	r2, [r3, #28]
 8031930:	b142      	cbz	r2, 8031944 <McpsIndication+0x7c>
 8031932:	781a      	ldrb	r2, [r3, #0]
 8031934:	78e3      	ldrb	r3, [r4, #3]
 8031936:	429a      	cmp	r2, r3
 8031938:	d11c      	bne.n	8031974 <McpsIndication+0xac>
                        LmHandlerPackages[i]->OnMcpsIndicationProcess( ( McpsIndication_t* )params );
 803193a:	f857 3c04 	ldr.w	r3, [r7, #-4]
 803193e:	4620      	mov	r0, r4
 8031940:	69db      	ldr	r3, [r3, #28]
 8031942:	4798      	blx	r3
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 8031944:	1c6b      	adds	r3, r5, #1
 8031946:	b2da      	uxtb	r2, r3
 8031948:	2a05      	cmp	r2, #5
 803194a:	b25d      	sxtb	r5, r3
 803194c:	d1ec      	bne.n	8031928 <McpsIndication+0x60>
    LmHandlerGetCurrentClass(&deviceClass);
 803194e:	f10d 0007 	add.w	r0, sp, #7
 8031952:	f7ff ffa5 	bl	80318a0 <LmHandlerGetCurrentClass>
    if ((mcpsIndication->FramePending == true) && (deviceClass == CLASS_A))
 8031956:	7963      	ldrb	r3, [r4, #5]
 8031958:	2b01      	cmp	r3, #1
 803195a:	d109      	bne.n	8031970 <McpsIndication+0xa8>
 803195c:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8031960:	b932      	cbnz	r2, 8031970 <McpsIndication+0xa8>
        LmHandlerSend(&appData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true);
 8031962:	4611      	mov	r1, r2
 8031964:	a804      	add	r0, sp, #16
        LmHandlerAppData_t appData =
 8031966:	f8ad 2010 	strh.w	r2, [sp, #16]
 803196a:	9205      	str	r2, [sp, #20]
        LmHandlerSend(&appData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true);
 803196c:	f7ff fef6 	bl	803175c <LmHandlerSend>
}
 8031970:	b007      	add	sp, #28
 8031972:	bdf0      	pop	{r4, r5, r6, r7, pc}
                        ( ( LmHandlerPackages[i]->Port == ((McpsIndication_t* )params)->Port ) ||
 8031974:	2d00      	cmp	r5, #0
 8031976:	d1e5      	bne.n	8031944 <McpsIndication+0x7c>
                          ( ( i == PACKAGE_ID_COMPLIANCE ) && ( LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->IsRunning() ))))
 8031978:	69f3      	ldr	r3, [r6, #28]
 803197a:	68db      	ldr	r3, [r3, #12]
 803197c:	4798      	blx	r3
 803197e:	2800      	cmp	r0, #0
 8031980:	d1db      	bne.n	803193a <McpsIndication+0x72>
 8031982:	e7df      	b.n	8031944 <McpsIndication+0x7c>
 8031984:	20003458 	.word	0x20003458
 8031988:	200047dc 	.word	0x200047dc
 803198c:	200047f8 	.word	0x200047f8

08031990 <LmHandlerGetTxDatarate>:
{
 8031990:	b510      	push	{r4, lr}
    if (txDatarate == NULL)
 8031992:	4604      	mov	r4, r0
{
 8031994:	b08a      	sub	sp, #40	; 0x28
    if (txDatarate == NULL)
 8031996:	b918      	cbnz	r0, 80319a0 <LmHandlerGetTxDatarate+0x10>
        return LORAMAC_HANDLER_ERROR;
 8031998:	f04f 30ff 	mov.w	r0, #4294967295
}
 803199c:	b00a      	add	sp, #40	; 0x28
 803199e:	bd10      	pop	{r4, pc}
    mibGet.Type = MIB_CHANNELS_DATARATE;
 80319a0:	231f      	movs	r3, #31
    if (LoRaMacMibGetRequestConfirm( &mibGet ) != LORAMAC_STATUS_OK)
 80319a2:	a801      	add	r0, sp, #4
    mibGet.Type = MIB_CHANNELS_DATARATE;
 80319a4:	f88d 3004 	strb.w	r3, [sp, #4]
    if (LoRaMacMibGetRequestConfirm( &mibGet ) != LORAMAC_STATUS_OK)
 80319a8:	f003 f958 	bl	8034c5c <LoRaMacMibGetRequestConfirm>
 80319ac:	2800      	cmp	r0, #0
 80319ae:	d1f3      	bne.n	8031998 <LmHandlerGetTxDatarate+0x8>
    LmHandlerParams.TxDatarate = *txDatarate;
 80319b0:	4a03      	ldr	r2, [pc, #12]	; (80319c0 <LmHandlerGetTxDatarate+0x30>)
    *txDatarate = mibGet.Param.ChannelsDatarate;
 80319b2:	f99d 3008 	ldrsb.w	r3, [sp, #8]
 80319b6:	7023      	strb	r3, [r4, #0]
    LmHandlerParams.TxDatarate = *txDatarate;
 80319b8:	f882 3033 	strb.w	r3, [r2, #51]	; 0x33
    return LORAMAC_HANDLER_SUCCESS;
 80319bc:	e7ee      	b.n	803199c <LmHandlerGetTxDatarate+0xc>
 80319be:	bf00      	nop
 80319c0:	200047dc 	.word	0x200047dc

080319c4 <MlmeConfirm>:
{
 80319c4:	b5f0      	push	{r4, r5, r6, r7, lr}
    TxParams.IsMcpsConfirm = 0;
 80319c6:	4e23      	ldr	r6, [pc, #140]	; (8031a54 <MlmeConfirm+0x90>)
    TxParams.Status = mlmeConfirm->Status;
 80319c8:	7843      	ldrb	r3, [r0, #1]
 80319ca:	7073      	strb	r3, [r6, #1]
    LmHandlerCallbacks->OnTxData( &TxParams );
 80319cc:	69b3      	ldr	r3, [r6, #24]
    TxParams.IsMcpsConfirm = 0;
 80319ce:	2500      	movs	r5, #0
    LmHandlerCallbacks->OnTxData( &TxParams );
 80319d0:	6a1b      	ldr	r3, [r3, #32]
    TxParams.IsMcpsConfirm = 0;
 80319d2:	7035      	strb	r5, [r6, #0]
{
 80319d4:	b08b      	sub	sp, #44	; 0x2c
 80319d6:	4604      	mov	r4, r0
    LmHandlerCallbacks->OnTxData( &TxParams );
 80319d8:	4630      	mov	r0, r6
 80319da:	4798      	blx	r3
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 80319dc:	f106 071c 	add.w	r7, r6, #28
        if( LmHandlerPackages[i] != NULL )
 80319e0:	f857 3b04 	ldr.w	r3, [r7], #4
 80319e4:	b11b      	cbz	r3, 80319ee <MlmeConfirm+0x2a>
                    if( LmHandlerPackages[i]->OnMlmeConfirmProcess != NULL )
 80319e6:	6a1b      	ldr	r3, [r3, #32]
 80319e8:	b10b      	cbz	r3, 80319ee <MlmeConfirm+0x2a>
                        LmHandlerPackages[i]->OnMlmeConfirmProcess( ( MlmeConfirm_t* )params );
 80319ea:	4620      	mov	r0, r4
 80319ec:	4798      	blx	r3
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 80319ee:	3501      	adds	r5, #1
 80319f0:	b2eb      	uxtb	r3, r5
 80319f2:	2b05      	cmp	r3, #5
 80319f4:	b26d      	sxtb	r5, r5
 80319f6:	d1f3      	bne.n	80319e0 <MlmeConfirm+0x1c>
    switch( mlmeConfirm->MlmeRequest )
 80319f8:	7823      	ldrb	r3, [r4, #0]
 80319fa:	2b01      	cmp	r3, #1
 80319fc:	d003      	beq.n	8031a06 <MlmeConfirm+0x42>
 80319fe:	2b04      	cmp	r3, #4
 8031a00:	d01d      	beq.n	8031a3e <MlmeConfirm+0x7a>
}
 8031a02:	b00b      	add	sp, #44	; 0x2c
 8031a04:	bdf0      	pop	{r4, r5, r6, r7, pc}
            CommissioningParams.DevAddr = mibReq.Param.DevAddr;
 8031a06:	4d14      	ldr	r5, [pc, #80]	; (8031a58 <MlmeConfirm+0x94>)
            mibReq.Type = MIB_DEV_ADDR;
 8031a08:	2306      	movs	r3, #6
            LoRaMacMibGetRequestConfirm( &mibReq );
 8031a0a:	a801      	add	r0, sp, #4
            mibReq.Type = MIB_DEV_ADDR;
 8031a0c:	f88d 3004 	strb.w	r3, [sp, #4]
            LoRaMacMibGetRequestConfirm( &mibReq );
 8031a10:	f003 f924 	bl	8034c5c <LoRaMacMibGetRequestConfirm>
            CommissioningParams.DevAddr = mibReq.Param.DevAddr;
 8031a14:	9b02      	ldr	r3, [sp, #8]
 8031a16:	616b      	str	r3, [r5, #20]
            LmHandlerGetTxDatarate( &JoinParams.Datarate );
 8031a18:	f105 0018 	add.w	r0, r5, #24
 8031a1c:	f7ff ffb8 	bl	8031990 <LmHandlerGetTxDatarate>
            if( mlmeConfirm->Status == LORAMAC_EVENT_INFO_STATUS_OK )
 8031a20:	7863      	ldrb	r3, [r4, #1]
 8031a22:	b94b      	cbnz	r3, 8031a38 <MlmeConfirm+0x74>
                LmHandlerRequestClass(LmHandlerParams.DefaultClass);
 8031a24:	f896 0031 	ldrb.w	r0, [r6, #49]	; 0x31
                JoinParams.Status = LORAMAC_HANDLER_SUCCESS;
 8031a28:	766b      	strb	r3, [r5, #25]
                LmHandlerRequestClass(LmHandlerParams.DefaultClass);
 8031a2a:	f7ff fdd7 	bl	80315dc <LmHandlerRequestClass>
            LmHandlerCallbacks->OnJoinRequest( &JoinParams );
 8031a2e:	69b3      	ldr	r3, [r6, #24]
 8031a30:	480a      	ldr	r0, [pc, #40]	; (8031a5c <MlmeConfirm+0x98>)
 8031a32:	69db      	ldr	r3, [r3, #28]
 8031a34:	4798      	blx	r3
}
 8031a36:	e7e4      	b.n	8031a02 <MlmeConfirm+0x3e>
                JoinParams.Status = LORAMAC_HANDLER_ERROR;
 8031a38:	23ff      	movs	r3, #255	; 0xff
 8031a3a:	766b      	strb	r3, [r5, #25]
 8031a3c:	e7f7      	b.n	8031a2e <MlmeConfirm+0x6a>
            RxParams.LinkCheck = true;
 8031a3e:	4b06      	ldr	r3, [pc, #24]	; (8031a58 <MlmeConfirm+0x94>)
 8031a40:	2201      	movs	r2, #1
 8031a42:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
            RxParams.DemodMargin = mlmeConfirm->DemodMargin;
 8031a46:	7a22      	ldrb	r2, [r4, #8]
 8031a48:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
            RxParams.NbGateways = mlmeConfirm->NbGateways;
 8031a4c:	7a62      	ldrb	r2, [r4, #9]
 8031a4e:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
}
 8031a52:	e7d6      	b.n	8031a02 <MlmeConfirm+0x3e>
 8031a54:	200047dc 	.word	0x200047dc
 8031a58:	20003458 	.word	0x20003458
 8031a5c:	20003470 	.word	0x20003470

08031a60 <LmHandlerPackageRegister>:
{
 8031a60:	b537      	push	{r0, r1, r2, r4, r5, lr}
    LmhPackage_t *package = NULL;
 8031a62:	2300      	movs	r3, #0
{
 8031a64:	460d      	mov	r5, r1
    LmhPackage_t *package = NULL;
 8031a66:	9301      	str	r3, [sp, #4]
    switch( id )
 8031a68:	4604      	mov	r4, r0
 8031a6a:	b9c8      	cbnz	r0, 8031aa0 <LmHandlerPackageRegister+0x40>
            package = LmhpCompliancePackageFactory( );
 8031a6c:	f000 fb94 	bl	8032198 <LmhpCompliancePackageFactory>
 8031a70:	9001      	str	r0, [sp, #4]
    if( package != NULL )
 8031a72:	9b01      	ldr	r3, [sp, #4]
 8031a74:	b1c3      	cbz	r3, 8031aa8 <LmHandlerPackageRegister+0x48>
        LmHandlerPackages[id]->OnJoinRequest = LmHandlerJoin;
 8031a76:	4a0e      	ldr	r2, [pc, #56]	; (8031ab0 <LmHandlerPackageRegister+0x50>)
        LmHandlerPackages[id] = package;
 8031a78:	490e      	ldr	r1, [pc, #56]	; (8031ab4 <LmHandlerPackageRegister+0x54>)
        LmHandlerPackages[id]->OnJoinRequest = LmHandlerJoin;
 8031a7a:	625a      	str	r2, [r3, #36]	; 0x24
        LmHandlerPackages[id]->OnSendRequest = LmHandlerSend;
 8031a7c:	4a0e      	ldr	r2, [pc, #56]	; (8031ab8 <LmHandlerPackageRegister+0x58>)
 8031a7e:	629a      	str	r2, [r3, #40]	; 0x28
        LmHandlerPackages[id]->OnDeviceTimeRequest = LmHandlerDeviceTimeReq;
 8031a80:	4a0e      	ldr	r2, [pc, #56]	; (8031abc <LmHandlerPackageRegister+0x5c>)
 8031a82:	62da      	str	r2, [r3, #44]	; 0x2c
        LmHandlerPackages[id]->OnPackageProcessEvent = LmHandlerCallbacks->OnMacProcess;
 8031a84:	698a      	ldr	r2, [r1, #24]
        LmHandlerPackages[id] = package;
 8031a86:	eb01 0484 	add.w	r4, r1, r4, lsl #2
        LmHandlerPackages[id]->OnPackageProcessEvent = LmHandlerCallbacks->OnMacProcess;
 8031a8a:	6912      	ldr	r2, [r2, #16]
 8031a8c:	615a      	str	r2, [r3, #20]
        LmHandlerPackages[id] = package;
 8031a8e:	61e3      	str	r3, [r4, #28]
        LmHandlerPackages[id]->Init( params, AppData.Buffer, AppData.BufferSize );
 8031a90:	4628      	mov	r0, r5
 8031a92:	685b      	ldr	r3, [r3, #4]
 8031a94:	22f2      	movs	r2, #242	; 0xf2
 8031a96:	3165      	adds	r1, #101	; 0x65
 8031a98:	4798      	blx	r3
        return LORAMAC_HANDLER_SUCCESS;
 8031a9a:	2000      	movs	r0, #0
}
 8031a9c:	b003      	add	sp, #12
 8031a9e:	bd30      	pop	{r4, r5, pc}
            LmhpPackagesRegister(id, &package);
 8031aa0:	a901      	add	r1, sp, #4
 8031aa2:	f000 ff2b 	bl	80328fc <LmhpPackagesRegister>
            break;
 8031aa6:	e7e4      	b.n	8031a72 <LmHandlerPackageRegister+0x12>
        return LORAMAC_HANDLER_ERROR;
 8031aa8:	f04f 30ff 	mov.w	r0, #4294967295
 8031aac:	e7f6      	b.n	8031a9c <LmHandlerPackageRegister+0x3c>
 8031aae:	bf00      	nop
 8031ab0:	08031699 	.word	0x08031699
 8031ab4:	200047dc 	.word	0x200047dc
 8031ab8:	0803175d 	.word	0x0803175d
 8031abc:	08031361 	.word	0x08031361

08031ac0 <LmHandlerInit>:
{
 8031ac0:	b508      	push	{r3, lr}
    LmHandlerCallbacks = handlerCallbacks;
 8031ac2:	4b11      	ldr	r3, [pc, #68]	; (8031b08 <LmHandlerInit+0x48>)
    LoRaMacPrimitives.MacMcpsConfirm = McpsConfirm;
 8031ac4:	4a11      	ldr	r2, [pc, #68]	; (8031b0c <LmHandlerInit+0x4c>)
 8031ac6:	655a      	str	r2, [r3, #84]	; 0x54
    LoRaMacPrimitives.MacMcpsIndication = McpsIndication;
 8031ac8:	4a11      	ldr	r2, [pc, #68]	; (8031b10 <LmHandlerInit+0x50>)
 8031aca:	659a      	str	r2, [r3, #88]	; 0x58
    LoRaMacPrimitives.MacMlmeConfirm = MlmeConfirm;
 8031acc:	4a11      	ldr	r2, [pc, #68]	; (8031b14 <LmHandlerInit+0x54>)
 8031ace:	65da      	str	r2, [r3, #92]	; 0x5c
    LoRaMacPrimitives.MacMlmeIndication = MlmeIndication;
 8031ad0:	4a11      	ldr	r2, [pc, #68]	; (8031b18 <LmHandlerInit+0x58>)
 8031ad2:	661a      	str	r2, [r3, #96]	; 0x60
    LoRaMacCallbacks.GetBatteryLevel = LmHandlerCallbacks->GetBatteryLevel;
 8031ad4:	6802      	ldr	r2, [r0, #0]
 8031ad6:	641a      	str	r2, [r3, #64]	; 0x40
    LoRaMacCallbacks.GetTemperatureLevel = LmHandlerCallbacks->GetTemperature;
 8031ad8:	6842      	ldr	r2, [r0, #4]
 8031ada:	645a      	str	r2, [r3, #68]	; 0x44
    LoRaMacCallbacks.GetUniqueId = LmHandlerCallbacks->GetUniqueId;
 8031adc:	6882      	ldr	r2, [r0, #8]
 8031ade:	649a      	str	r2, [r3, #72]	; 0x48
    LoRaMacCallbacks.NvmDataChange  = NvmDataMgmtEvent;
 8031ae0:	4a0e      	ldr	r2, [pc, #56]	; (8031b1c <LmHandlerInit+0x5c>)
    LmHandlerCallbacks = handlerCallbacks;
 8031ae2:	6198      	str	r0, [r3, #24]
    LoRaMacCallbacks.NvmDataChange  = NvmDataMgmtEvent;
 8031ae4:	64da      	str	r2, [r3, #76]	; 0x4c
    if (LmHandlerPackageRegister(PACKAGE_ID_COMPLIANCE, &LmhpComplianceParams) != LORAMAC_HANDLER_SUCCESS)
 8031ae6:	490e      	ldr	r1, [pc, #56]	; (8031b20 <LmHandlerInit+0x60>)
    LoRaMacCallbacks.MacProcessNotify = LmHandlerCallbacks->OnMacProcess;
 8031ae8:	6902      	ldr	r2, [r0, #16]
 8031aea:	651a      	str	r2, [r3, #80]	; 0x50
    if (LmHandlerPackageRegister(PACKAGE_ID_COMPLIANCE, &LmhpComplianceParams) != LORAMAC_HANDLER_SUCCESS)
 8031aec:	2000      	movs	r0, #0
 8031aee:	f7ff ffb7 	bl	8031a60 <LmHandlerPackageRegister>
 8031af2:	b930      	cbnz	r0, 8031b02 <LmHandlerInit+0x42>
    if (LmhpPackagesRegistrationInit() != LORAMAC_HANDLER_SUCCESS)
 8031af4:	f000 fee2 	bl	80328bc <LmhpPackagesRegistrationInit>
 8031af8:	3800      	subs	r0, #0
 8031afa:	bf18      	it	ne
 8031afc:	2001      	movne	r0, #1
 8031afe:	4240      	negs	r0, r0
}
 8031b00:	bd08      	pop	{r3, pc}
        return LORAMAC_HANDLER_ERROR;
 8031b02:	f04f 30ff 	mov.w	r0, #4294967295
 8031b06:	e7fb      	b.n	8031b00 <LmHandlerInit+0x40>
 8031b08:	200047dc 	.word	0x200047dc
 8031b0c:	0803137d 	.word	0x0803137d
 8031b10:	080318c9 	.word	0x080318c9
 8031b14:	080319c5 	.word	0x080319c5
 8031b18:	08031841 	.word	0x08031841
 8031b1c:	08036707 	.word	0x08036707
 8031b20:	20003484 	.word	0x20003484

08031b24 <LmHandlerGetDutyCycleEnable>:
    if (dutyCycleEnable == NULL)
 8031b24:	b128      	cbz	r0, 8031b32 <LmHandlerGetDutyCycleEnable+0xe>
    *dutyCycleEnable = LmHandlerParams.DutyCycleEnabled;
 8031b26:	4b04      	ldr	r3, [pc, #16]	; (8031b38 <LmHandlerGetDutyCycleEnable+0x14>)
 8031b28:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8031b2c:	7003      	strb	r3, [r0, #0]
    return LORAMAC_HANDLER_SUCCESS;
 8031b2e:	2000      	movs	r0, #0
 8031b30:	4770      	bx	lr
        return LORAMAC_HANDLER_ERROR;
 8031b32:	f04f 30ff 	mov.w	r0, #4294967295
}
 8031b36:	4770      	bx	lr
 8031b38:	200047dc 	.word	0x200047dc

08031b3c <LmHandlerSetDutyCycleEnable>:
{
 8031b3c:	b508      	push	{r3, lr}
    LmHandlerParams.DutyCycleEnabled = dutyCycleEnable;
 8031b3e:	4b03      	ldr	r3, [pc, #12]	; (8031b4c <LmHandlerSetDutyCycleEnable+0x10>)
 8031b40:	f883 0035 	strb.w	r0, [r3, #53]	; 0x35
    LoRaMacTestSetDutyCycleOn(dutyCycleEnable);
 8031b44:	f003 feaa 	bl	803589c <LoRaMacTestSetDutyCycleOn>
}
 8031b48:	2000      	movs	r0, #0
 8031b4a:	bd08      	pop	{r3, pc}
 8031b4c:	200047dc 	.word	0x200047dc

08031b50 <LmhpClockSyncIsInitialized>:
}

static bool LmhpClockSyncIsInitialized( void )
{
    return LmhpClockSyncState.Initialized;
}
 8031b50:	4b01      	ldr	r3, [pc, #4]	; (8031b58 <LmhpClockSyncIsInitialized+0x8>)
 8031b52:	7818      	ldrb	r0, [r3, #0]
 8031b54:	4770      	bx	lr
 8031b56:	bf00      	nop
 8031b58:	20004934 	.word	0x20004934

08031b5c <LmhpClockSyncIsRunning>:

static bool LmhpClockSyncIsRunning( void )
{
    if( LmhpClockSyncState.Initialized == false )
 8031b5c:	4b02      	ldr	r3, [pc, #8]	; (8031b68 <LmhpClockSyncIsRunning+0xc>)
 8031b5e:	7818      	ldrb	r0, [r3, #0]
 8031b60:	b100      	cbz	r0, 8031b64 <LmhpClockSyncIsRunning+0x8>
    {
        return false;
    }

    return LmhpClockSyncState.IsRunning;
 8031b62:	7858      	ldrb	r0, [r3, #1]
}
 8031b64:	4770      	bx	lr
 8031b66:	bf00      	nop
 8031b68:	20004934 	.word	0x20004934

08031b6c <OnPeriodicTimeStartTimer>:

    return status;
}

static void OnPeriodicTimeStartTimer(void *context)
{
 8031b6c:	b510      	push	{r4, lr}
  LmhpClockSyncState.NbTransmissions = 1;
 8031b6e:	4805      	ldr	r0, [pc, #20]	; (8031b84 <OnPeriodicTimeStartTimer+0x18>)
 8031b70:	2301      	movs	r3, #1
 8031b72:	7343      	strb	r3, [r0, #13]
  TimerStart(&PeriodicTimeStartTimer);
 8031b74:	3010      	adds	r0, #16
 8031b76:	f009 fc33 	bl	803b3e0 <UTIL_TIMER_Start>
  LmhpClockSyncPackage.OnPackageProcessEvent();
 8031b7a:	4b03      	ldr	r3, [pc, #12]	; (8031b88 <OnPeriodicTimeStartTimer+0x1c>)
}
 8031b7c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  LmhpClockSyncPackage.OnPackageProcessEvent();
 8031b80:	695b      	ldr	r3, [r3, #20]
 8031b82:	4718      	bx	r3
 8031b84:	20004934 	.word	0x20004934
 8031b88:	20003490 	.word	0x20003490

08031b8c <LmhpClockSyncOnMcpsIndication>:
{
 8031b8c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if( mcpsIndication->Port != CLOCK_SYNC_PORT )
 8031b90:	78c3      	ldrb	r3, [r0, #3]
 8031b92:	2bca      	cmp	r3, #202	; 0xca
{
 8031b94:	b085      	sub	sp, #20
 8031b96:	4680      	mov	r8, r0
    if( mcpsIndication->Port != CLOCK_SYNC_PORT )
 8031b98:	f000 80ba 	beq.w	8031d10 <LmhpClockSyncOnMcpsIndication+0x184>
}
 8031b9c:	b005      	add	sp, #20
 8031b9e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        switch( mcpsIndication->Buffer[cmdIndex++] )
 8031ba2:	f8d8 1008 	ldr.w	r1, [r8, #8]
 8031ba6:	5cc8      	ldrb	r0, [r1, r3]
 8031ba8:	1c5a      	adds	r2, r3, #1
 8031baa:	b2d2      	uxtb	r2, r2
 8031bac:	2803      	cmp	r0, #3
 8031bae:	d80f      	bhi.n	8031bd0 <LmhpClockSyncOnMcpsIndication+0x44>
 8031bb0:	e8df f000 	tbb	[pc, r0]
 8031bb4:	a76e1002 	.word	0xa76e1002
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = CLOCK_SYNC_PKG_VERSION_ANS;
 8031bb8:	6871      	ldr	r1, [r6, #4]
 8031bba:	2300      	movs	r3, #0
 8031bbc:	550b      	strb	r3, [r1, r4]
 8031bbe:	1c60      	adds	r0, r4, #1
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = CLOCK_SYNC_ID;
 8031bc0:	1ca3      	adds	r3, r4, #2
 8031bc2:	b2db      	uxtb	r3, r3
 8031bc4:	b2c0      	uxtb	r0, r0
 8031bc6:	2501      	movs	r5, #1
 8031bc8:	540d      	strb	r5, [r1, r0]
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = CLOCK_SYNC_VERSION;
 8031bca:	3403      	adds	r4, #3
 8031bcc:	54cd      	strb	r5, [r1, r3]
 8031bce:	b2e4      	uxtb	r4, r4
        switch( mcpsIndication->Buffer[cmdIndex++] )
 8031bd0:	4617      	mov	r7, r2
 8031bd2:	e03b      	b.n	8031c4c <LmhpClockSyncOnMcpsIndication+0xc0>
                LmhpClockSyncState.NbTransmissions = 0;
 8031bd4:	2000      	movs	r0, #0
 8031bd6:	7370      	strb	r0, [r6, #13]
                if( mcpsIndication->DeviceTimeAnsReceived == true )
 8031bd8:	f898 0018 	ldrb.w	r0, [r8, #24]
 8031bdc:	1d9f      	adds	r7, r3, #6
 8031bde:	b2ff      	uxtb	r7, r7
 8031be0:	2800      	cmp	r0, #0
 8031be2:	d133      	bne.n	8031c4c <LmhpClockSyncOnMcpsIndication+0xc0>
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8031be4:	1d58      	adds	r0, r3, #5
                if( ( mcpsIndication->Buffer[cmdIndex++] & 0x0F ) == LmhpClockSyncState.TimeReqParam.Fields.TokenReq )
 8031be6:	b2c0      	uxtb	r0, r0
 8031be8:	7a35      	ldrb	r5, [r6, #8]
 8031bea:	5c08      	ldrb	r0, [r1, r0]
 8031bec:	f005 050f 	and.w	r5, r5, #15
 8031bf0:	f000 000f 	and.w	r0, r0, #15
 8031bf4:	4285      	cmp	r5, r0
 8031bf6:	d129      	bne.n	8031c4c <LmhpClockSyncOnMcpsIndication+0xc0>
                timeCorrection  = ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8031bf8:	5c8d      	ldrb	r5, [r1, r2]
 8031bfa:	1c9a      	adds	r2, r3, #2
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8031bfc:	b2d2      	uxtb	r2, r2
                    curTime = SysTimeGet( );
 8031bfe:	f10d 0b08 	add.w	fp, sp, #8
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8031c02:	5c8a      	ldrb	r2, [r1, r2]
 8031c04:	eb05 2502 	add.w	r5, r5, r2, lsl #8
 8031c08:	1cda      	adds	r2, r3, #3
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8031c0a:	b2d2      	uxtb	r2, r2
 8031c0c:	3304      	adds	r3, #4
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8031c0e:	b2db      	uxtb	r3, r3
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8031c10:	5c8a      	ldrb	r2, [r1, r2]
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8031c12:	5ccb      	ldrb	r3, [r1, r3]
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8031c14:	eb05 4502 	add.w	r5, r5, r2, lsl #16
                    curTime = SysTimeGet( );
 8031c18:	4658      	mov	r0, fp
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8031c1a:	eb05 6503 	add.w	r5, r5, r3, lsl #24
                    curTime = SysTimeGet( );
 8031c1e:	f009 faa1 	bl	803b164 <SysTimeGet>
                    curTime.Seconds += timeCorrection;
 8031c22:	9b02      	ldr	r3, [sp, #8]
 8031c24:	442b      	add	r3, r5
                    SysTimeSet( curTime );
 8031c26:	9302      	str	r3, [sp, #8]
 8031c28:	e89b 0003 	ldmia.w	fp, {r0, r1}
 8031c2c:	f009 fa72 	bl	803b114 <SysTimeSet>
                    LmhpClockSyncState.TimeReqParam.Fields.TokenReq = ( LmhpClockSyncState.TimeReqParam.Fields.TokenReq + 1 ) & 0x0F;
 8031c30:	7a33      	ldrb	r3, [r6, #8]
 8031c32:	f3c3 0203 	ubfx	r2, r3, #0, #4
 8031c36:	3201      	adds	r2, #1
 8031c38:	f362 0303 	bfi	r3, r2, #0, #4
 8031c3c:	7233      	strb	r3, [r6, #8]
                    if( LmhpClockSyncPackage.OnSysTimeUpdate != NULL )
 8031c3e:	4b38      	ldr	r3, [pc, #224]	; (8031d20 <LmhpClockSyncOnMcpsIndication+0x194>)
 8031c40:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8031c42:	b11b      	cbz	r3, 8031c4c <LmhpClockSyncOnMcpsIndication+0xc0>
                        if( ( timeCorrection >= -1 ) && ( timeCorrection <= 1 ) )
 8031c44:	3501      	adds	r5, #1
 8031c46:	2d02      	cmp	r5, #2
 8031c48:	d800      	bhi.n	8031c4c <LmhpClockSyncOnMcpsIndication+0xc0>
                            LmhpClockSyncPackage.OnSysTimeUpdate( );
 8031c4a:	4798      	blx	r3
        switch( mcpsIndication->Buffer[cmdIndex++] )
 8031c4c:	463b      	mov	r3, r7
    while( cmdIndex < mcpsIndication->BufferSize )
 8031c4e:	f898 200c 	ldrb.w	r2, [r8, #12]
 8031c52:	429a      	cmp	r2, r3
 8031c54:	d8a5      	bhi.n	8031ba2 <LmhpClockSyncOnMcpsIndication+0x16>
    if( dataBufferIndex != 0 )
 8031c56:	2c00      	cmp	r4, #0
 8031c58:	d0a0      	beq.n	8031b9c <LmhpClockSyncOnMcpsIndication+0x10>
        LmHandlerAppData_t appData =
 8031c5a:	23ca      	movs	r3, #202	; 0xca
 8031c5c:	f88d 3008 	strb.w	r3, [sp, #8]
            .Buffer = LmhpClockSyncState.DataBuffer,
 8031c60:	4b30      	ldr	r3, [pc, #192]	; (8031d24 <LmhpClockSyncOnMcpsIndication+0x198>)
        LmHandlerAppData_t appData =
 8031c62:	f88d 4009 	strb.w	r4, [sp, #9]
 8031c66:	685b      	ldr	r3, [r3, #4]
 8031c68:	9303      	str	r3, [sp, #12]
        LmHandlerGetDutyCycleEnable(&current_dutycycle);
 8031c6a:	f10d 0007 	add.w	r0, sp, #7
 8031c6e:	f7ff ff59 	bl	8031b24 <LmHandlerGetDutyCycleEnable>
        LmHandlerSetDutyCycleEnable(false);
 8031c72:	2000      	movs	r0, #0
 8031c74:	f7ff ff62 	bl	8031b3c <LmHandlerSetDutyCycleEnable>
        LmhpClockSyncPackage.OnSendRequest(&appData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true);
 8031c78:	4b29      	ldr	r3, [pc, #164]	; (8031d20 <LmhpClockSyncOnMcpsIndication+0x194>)
 8031c7a:	2200      	movs	r2, #0
 8031c7c:	6a9c      	ldr	r4, [r3, #40]	; 0x28
 8031c7e:	4611      	mov	r1, r2
 8031c80:	2301      	movs	r3, #1
 8031c82:	a802      	add	r0, sp, #8
 8031c84:	47a0      	blx	r4
        LmHandlerSetDutyCycleEnable(current_dutycycle);
 8031c86:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8031c8a:	f7ff ff57 	bl	8031b3c <LmHandlerSetDutyCycleEnable>
 8031c8e:	e785      	b.n	8031b9c <LmhpClockSyncOnMcpsIndication+0x10>
                uint32_t periodTime = mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8031c90:	1cdf      	adds	r7, r3, #3
                cmdIndex++;
 8031c92:	3302      	adds	r3, #2
                uint32_t periodTime = mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8031c94:	b2db      	uxtb	r3, r3
                periodTime = (128 << periodTime) + randr(0, 30);
 8031c96:	2000      	movs	r0, #0
                uint32_t periodTime = mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8031c98:	5ccd      	ldrb	r5, [r1, r3]
 8031c9a:	f005 010f 	and.w	r1, r5, #15
                periodTime = (128 << periodTime) + randr(0, 30);
 8031c9e:	2580      	movs	r5, #128	; 0x80
 8031ca0:	408d      	lsls	r5, r1
 8031ca2:	211e      	movs	r1, #30
 8031ca4:	f007 f928 	bl	8038ef8 <randr>
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = CLOCK_SYNC_APP_TIME_PERIOD_ANS;
 8031ca8:	6872      	ldr	r2, [r6, #4]
 8031caa:	2302      	movs	r3, #2
 8031cac:	5513      	strb	r3, [r2, r4]
 8031cae:	1c63      	adds	r3, r4, #1
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = 0x00;
 8031cb0:	b2db      	uxtb	r3, r3
 8031cb2:	2100      	movs	r1, #0
 8031cb4:	54d1      	strb	r1, [r2, r3]
                periodTime = (128 << periodTime) + randr(0, 30);
 8031cb6:	4683      	mov	fp, r0
                SysTime_t curTime = SysTimeGet( );
 8031cb8:	a802      	add	r0, sp, #8
 8031cba:	f009 fa53 	bl	803b164 <SysTimeGet>
                curTime.Seconds -= UNIX_GPS_EPOCH_OFFSET;
 8031cbe:	9b02      	ldr	r3, [sp, #8]
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 0  ) & 0xFF;
 8031cc0:	6872      	ldr	r2, [r6, #4]
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = 0x00;
 8031cc2:	1ca1      	adds	r1, r4, #2
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 0  ) & 0xFF;
 8031cc4:	b2c9      	uxtb	r1, r1
                curTime.Seconds -= UNIX_GPS_EPOCH_OFFSET;
 8031cc6:	4453      	add	r3, sl
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 0  ) & 0xFF;
 8031cc8:	5453      	strb	r3, [r2, r1]
 8031cca:	1ce1      	adds	r1, r4, #3
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 8  ) & 0xFF;
 8031ccc:	b2c9      	uxtb	r1, r1
 8031cce:	0a18      	lsrs	r0, r3, #8
 8031cd0:	5450      	strb	r0, [r2, r1]
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 16 ) & 0xFF;
 8031cd2:	1d61      	adds	r1, r4, #5
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 8  ) & 0xFF;
 8031cd4:	1d20      	adds	r0, r4, #4
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 16 ) & 0xFF;
 8031cd6:	b2c9      	uxtb	r1, r1
 8031cd8:	b2c0      	uxtb	r0, r0
 8031cda:	ea4f 4c13 	mov.w	ip, r3, lsr #16
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 24 ) & 0xFF;
 8031cde:	0e1b      	lsrs	r3, r3, #24
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 16 ) & 0xFF;
 8031ce0:	f802 c000 	strb.w	ip, [r2, r0]
                periodTime = (128 << periodTime) + randr(0, 30);
 8031ce4:	445d      	add	r5, fp
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 24 ) & 0xFF;
 8031ce6:	5453      	strb	r3, [r2, r1]
                TimerSetValue(&PeriodicTimeStartTimer, periodTime * 1000);
 8031ce8:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8031cec:	4369      	muls	r1, r5
 8031cee:	4648      	mov	r0, r9
 8031cf0:	f009 fbb0 	bl	803b454 <UTIL_TIMER_SetPeriod>
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 24 ) & 0xFF;
 8031cf4:	3406      	adds	r4, #6
                TimerStart(&PeriodicTimeStartTimer);
 8031cf6:	4648      	mov	r0, r9
                uint32_t periodTime = mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8031cf8:	b2ff      	uxtb	r7, r7
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 24 ) & 0xFF;
 8031cfa:	b2e4      	uxtb	r4, r4
                TimerStart(&PeriodicTimeStartTimer);
 8031cfc:	f009 fb70 	bl	803b3e0 <UTIL_TIMER_Start>
                break;
 8031d00:	e7a4      	b.n	8031c4c <LmhpClockSyncOnMcpsIndication+0xc0>
                LmhpClockSyncState.NbTransmissions = mcpsIndication->Buffer[cmdIndex++] & 0X07;
 8031d02:	3302      	adds	r3, #2
 8031d04:	b2df      	uxtb	r7, r3
 8031d06:	5c8b      	ldrb	r3, [r1, r2]
 8031d08:	f003 0307 	and.w	r3, r3, #7
 8031d0c:	7373      	strb	r3, [r6, #13]
                break;
 8031d0e:	e79d      	b.n	8031c4c <LmhpClockSyncOnMcpsIndication+0xc0>
                LmhpClockSyncState.NbTransmissions = mcpsIndication->Buffer[cmdIndex++] & 0X07;
 8031d10:	4e04      	ldr	r6, [pc, #16]	; (8031d24 <LmhpClockSyncOnMcpsIndication+0x198>)
                curTime.Seconds -= UNIX_GPS_EPOCH_OFFSET;
 8031d12:	f8df a014 	ldr.w	sl, [pc, #20]	; 8031d28 <LmhpClockSyncOnMcpsIndication+0x19c>
    uint8_t dataBufferIndex = 0;
 8031d16:	2400      	movs	r4, #0
    uint8_t cmdIndex = 0;
 8031d18:	4623      	mov	r3, r4
                TimerSetValue(&PeriodicTimeStartTimer, periodTime * 1000);
 8031d1a:	f106 0910 	add.w	r9, r6, #16
 8031d1e:	e796      	b.n	8031c4e <LmhpClockSyncOnMcpsIndication+0xc2>
 8031d20:	20003490 	.word	0x20003490
 8031d24:	20004934 	.word	0x20004934
 8031d28:	ed2ac280 	.word	0xed2ac280

08031d2c <LmhpClockSyncOnMcpsConfirm>:
{
 8031d2c:	b510      	push	{r4, lr}
    if( LmhpClockSyncState.AppTimeReqPending == true )
 8031d2e:	4c11      	ldr	r4, [pc, #68]	; (8031d74 <LmhpClockSyncOnMcpsConfirm+0x48>)
 8031d30:	7a63      	ldrb	r3, [r4, #9]
{
 8031d32:	b08a      	sub	sp, #40	; 0x28
    if( LmhpClockSyncState.AppTimeReqPending == true )
 8031d34:	b1e3      	cbz	r3, 8031d70 <LmhpClockSyncOnMcpsConfirm+0x44>
        mibReq.Type = MIB_ADR;
 8031d36:	2304      	movs	r3, #4
 8031d38:	f88d 3004 	strb.w	r3, [sp, #4]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8031d3c:	a801      	add	r0, sp, #4
        mibReq.Param.AdrEnable = LmhpClockSyncState.AdrEnabledPrev;
 8031d3e:	7aa3      	ldrb	r3, [r4, #10]
 8031d40:	f88d 3008 	strb.w	r3, [sp, #8]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8031d44:	f003 f846 	bl	8034dd4 <LoRaMacMibSetRequestConfirm>
        mibReq.Type = MIB_CHANNELS_NB_TRANS;
 8031d48:	2318      	movs	r3, #24
 8031d4a:	f88d 3004 	strb.w	r3, [sp, #4]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8031d4e:	a801      	add	r0, sp, #4
        mibReq.Param.ChannelsNbTrans = LmhpClockSyncState.NbTransPrev;
 8031d50:	7ae3      	ldrb	r3, [r4, #11]
 8031d52:	f88d 3008 	strb.w	r3, [sp, #8]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8031d56:	f003 f83d 	bl	8034dd4 <LoRaMacMibSetRequestConfirm>
        mibReq.Type = MIB_CHANNELS_DATARATE;
 8031d5a:	231f      	movs	r3, #31
 8031d5c:	f88d 3004 	strb.w	r3, [sp, #4]
        LoRaMacMibSetRequestConfirm( &mibReq );        
 8031d60:	a801      	add	r0, sp, #4
        mibReq.Param.ChannelsDatarate = LmhpClockSyncState.DataratePrev;
 8031d62:	7b23      	ldrb	r3, [r4, #12]
 8031d64:	f88d 3008 	strb.w	r3, [sp, #8]
        LoRaMacMibSetRequestConfirm( &mibReq );        
 8031d68:	f003 f834 	bl	8034dd4 <LoRaMacMibSetRequestConfirm>
        LmhpClockSyncState.AppTimeReqPending = false;
 8031d6c:	2300      	movs	r3, #0
 8031d6e:	7263      	strb	r3, [r4, #9]
}
 8031d70:	b00a      	add	sp, #40	; 0x28
 8031d72:	bd10      	pop	{r4, pc}
 8031d74:	20004934 	.word	0x20004934

08031d78 <LmhpClockSyncInit>:
{
 8031d78:	b507      	push	{r0, r1, r2, lr}
 8031d7a:	480a      	ldr	r0, [pc, #40]	; (8031da4 <LmhpClockSyncInit+0x2c>)
    if( dataBuffer != NULL )
 8031d7c:	b179      	cbz	r1, 8031d9e <LmhpClockSyncInit+0x26>
        LmhpClockSyncState.DataBufferMaxSize = dataBufferMaxSize;
 8031d7e:	7082      	strb	r2, [r0, #2]
        LmhpClockSyncState.Initialized = true;
 8031d80:	f240 1301 	movw	r3, #257	; 0x101
        TimerInit(&PeriodicTimeStartTimer, OnPeriodicTimeStartTimer);
 8031d84:	2200      	movs	r2, #0
        LmhpClockSyncState.DataBuffer = dataBuffer;
 8031d86:	6041      	str	r1, [r0, #4]
        LmhpClockSyncState.Initialized = true;
 8031d88:	f820 3b10 	strh.w	r3, [r0], #16
        TimerInit(&PeriodicTimeStartTimer, OnPeriodicTimeStartTimer);
 8031d8c:	f04f 31ff 	mov.w	r1, #4294967295
 8031d90:	4b05      	ldr	r3, [pc, #20]	; (8031da8 <LmhpClockSyncInit+0x30>)
 8031d92:	9200      	str	r2, [sp, #0]
 8031d94:	f009 fa76 	bl	803b284 <UTIL_TIMER_Create>
}
 8031d98:	b003      	add	sp, #12
 8031d9a:	f85d fb04 	ldr.w	pc, [sp], #4
        LmhpClockSyncState.Initialized = false;
 8031d9e:	8001      	strh	r1, [r0, #0]
}
 8031da0:	e7fa      	b.n	8031d98 <LmhpClockSyncInit+0x20>
 8031da2:	bf00      	nop
 8031da4:	20004934 	.word	0x20004934
 8031da8:	08031b6d 	.word	0x08031b6d

08031dac <LmhpClockSyncPackageFactory>:
}
 8031dac:	4800      	ldr	r0, [pc, #0]	; (8031db0 <LmhpClockSyncPackageFactory+0x4>)
 8031dae:	4770      	bx	lr
 8031db0:	20003490 	.word	0x20003490

08031db4 <LmhpClockSyncAppTimeReq>:
{
 8031db4:	b570      	push	{r4, r5, r6, lr}
 8031db6:	b08c      	sub	sp, #48	; 0x30
    if( LmHandlerIsBusy( ) == true )
 8031db8:	f7ff fcb8 	bl	803172c <LmHandlerIsBusy>
 8031dbc:	2800      	cmp	r0, #0
 8031dbe:	d15b      	bne.n	8031e78 <LmhpClockSyncAppTimeReq+0xc4>
    if( LmhpClockSyncState.AppTimeReqPending == false )
 8031dc0:	4c2f      	ldr	r4, [pc, #188]	; (8031e80 <LmhpClockSyncAppTimeReq+0xcc>)
 8031dc2:	4e30      	ldr	r6, [pc, #192]	; (8031e84 <LmhpClockSyncAppTimeReq+0xd0>)
 8031dc4:	7a65      	ldrb	r5, [r4, #9]
 8031dc6:	bb3d      	cbnz	r5, 8031e18 <LmhpClockSyncAppTimeReq+0x64>
        mibReq.Type = MIB_ADR;
 8031dc8:	2304      	movs	r3, #4
        LoRaMacMibGetRequestConfirm( &mibReq );
 8031dca:	a803      	add	r0, sp, #12
        mibReq.Type = MIB_ADR;
 8031dcc:	f88d 300c 	strb.w	r3, [sp, #12]
        LoRaMacMibGetRequestConfirm( &mibReq );
 8031dd0:	f002 ff44 	bl	8034c5c <LoRaMacMibGetRequestConfirm>
        LmhpClockSyncState.AdrEnabledPrev = mibReq.Param.AdrEnable;
 8031dd4:	f89d 3010 	ldrb.w	r3, [sp, #16]
 8031dd8:	72a3      	strb	r3, [r4, #10]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8031dda:	a803      	add	r0, sp, #12
        mibReq.Param.AdrEnable = false;
 8031ddc:	f88d 5010 	strb.w	r5, [sp, #16]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8031de0:	f002 fff8 	bl	8034dd4 <LoRaMacMibSetRequestConfirm>
        mibReq.Type = MIB_CHANNELS_NB_TRANS;
 8031de4:	2318      	movs	r3, #24
        LoRaMacMibGetRequestConfirm( &mibReq );
 8031de6:	a803      	add	r0, sp, #12
        mibReq.Type = MIB_CHANNELS_NB_TRANS;
 8031de8:	f88d 300c 	strb.w	r3, [sp, #12]
        LoRaMacMibGetRequestConfirm( &mibReq );
 8031dec:	f002 ff36 	bl	8034c5c <LoRaMacMibGetRequestConfirm>
        LmhpClockSyncState.NbTransPrev = mibReq.Param.ChannelsNbTrans;
 8031df0:	f89d 3010 	ldrb.w	r3, [sp, #16]
 8031df4:	72e3      	strb	r3, [r4, #11]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8031df6:	a803      	add	r0, sp, #12
        mibReq.Param.ChannelsNbTrans = 1;
 8031df8:	2301      	movs	r3, #1
 8031dfa:	f88d 3010 	strb.w	r3, [sp, #16]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8031dfe:	f002 ffe9 	bl	8034dd4 <LoRaMacMibSetRequestConfirm>
        mibReq.Type = MIB_CHANNELS_DATARATE;
 8031e02:	231f      	movs	r3, #31
        LoRaMacMibGetRequestConfirm( &mibReq );  
 8031e04:	a803      	add	r0, sp, #12
        mibReq.Type = MIB_CHANNELS_DATARATE;
 8031e06:	f88d 300c 	strb.w	r3, [sp, #12]
        LoRaMacMibGetRequestConfirm( &mibReq );  
 8031e0a:	f002 ff27 	bl	8034c5c <LoRaMacMibGetRequestConfirm>
        LmhpClockSyncState.DataratePrev = mibReq.Param.ChannelsDatarate;
 8031e0e:	f89d 3010 	ldrb.w	r3, [sp, #16]
 8031e12:	7323      	strb	r3, [r4, #12]
        LmhpClockSyncPackage.OnDeviceTimeRequest( );
 8031e14:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8031e16:	4798      	blx	r3
    SysTime_t curTime = SysTimeGet( );
 8031e18:	a801      	add	r0, sp, #4
 8031e1a:	f009 f9a3 	bl	803b164 <SysTimeGet>
    curTime.Seconds -= UNIX_GPS_EPOCH_OFFSET;
 8031e1e:	9b01      	ldr	r3, [sp, #4]
 8031e20:	4a19      	ldr	r2, [pc, #100]	; (8031e88 <LmhpClockSyncAppTimeReq+0xd4>)
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = CLOCK_SYNC_APP_TIME_REQ;
 8031e22:	6861      	ldr	r1, [r4, #4]
    curTime.Seconds -= UNIX_GPS_EPOCH_OFFSET;
 8031e24:	441a      	add	r2, r3
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 8  ) & 0xFF;
 8031e26:	0a13      	lsrs	r3, r2, #8
 8031e28:	708b      	strb	r3, [r1, #2]
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 16 ) & 0xFF;
 8031e2a:	0c13      	lsrs	r3, r2, #16
 8031e2c:	70cb      	strb	r3, [r1, #3]
    LmhpClockSyncState.TimeReqParam.Fields.AnsRequired = 0;
 8031e2e:	7a23      	ldrb	r3, [r4, #8]
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 0  ) & 0xFF;
 8031e30:	704a      	strb	r2, [r1, #1]
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = CLOCK_SYNC_APP_TIME_REQ;
 8031e32:	2501      	movs	r5, #1
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 24 ) & 0xFF;
 8031e34:	0e12      	lsrs	r2, r2, #24
    LmhpClockSyncState.TimeReqParam.Fields.AnsRequired = 0;
 8031e36:	f36f 1304 	bfc	r3, #4, #1
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 24 ) & 0xFF;
 8031e3a:	710a      	strb	r2, [r1, #4]
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = LmhpClockSyncState.TimeReqParam.Value;
 8031e3c:	714b      	strb	r3, [r1, #5]
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = CLOCK_SYNC_APP_TIME_REQ;
 8031e3e:	700d      	strb	r5, [r1, #0]
    LmhpClockSyncState.TimeReqParam.Fields.AnsRequired = 0;
 8031e40:	7223      	strb	r3, [r4, #8]
    LmHandlerGetDutyCycleEnable(&current_dutycycle);
 8031e42:	f10d 0003 	add.w	r0, sp, #3
    LmHandlerAppData_t appData =
 8031e46:	f240 63ca 	movw	r3, #1738	; 0x6ca
 8031e4a:	f8ad 300c 	strh.w	r3, [sp, #12]
 8031e4e:	9104      	str	r1, [sp, #16]
    LmhpClockSyncState.AppTimeReqPending = true;
 8031e50:	7265      	strb	r5, [r4, #9]
    LmHandlerGetDutyCycleEnable(&current_dutycycle);
 8031e52:	f7ff fe67 	bl	8031b24 <LmHandlerGetDutyCycleEnable>
    LmHandlerSetDutyCycleEnable(false);
 8031e56:	2000      	movs	r0, #0
 8031e58:	f7ff fe70 	bl	8031b3c <LmHandlerSetDutyCycleEnable>
    LmHandlerErrorStatus_t status = LmhpClockSyncPackage.OnSendRequest(&appData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true);
 8031e5c:	2200      	movs	r2, #0
 8031e5e:	6ab4      	ldr	r4, [r6, #40]	; 0x28
 8031e60:	462b      	mov	r3, r5
 8031e62:	4611      	mov	r1, r2
 8031e64:	a803      	add	r0, sp, #12
 8031e66:	47a0      	blx	r4
 8031e68:	4604      	mov	r4, r0
    LmHandlerSetDutyCycleEnable(current_dutycycle);
 8031e6a:	f89d 0003 	ldrb.w	r0, [sp, #3]
 8031e6e:	f7ff fe65 	bl	8031b3c <LmHandlerSetDutyCycleEnable>
}
 8031e72:	4620      	mov	r0, r4
 8031e74:	b00c      	add	sp, #48	; 0x30
 8031e76:	bd70      	pop	{r4, r5, r6, pc}
        return LORAMAC_HANDLER_ERROR;
 8031e78:	f04f 34ff 	mov.w	r4, #4294967295
 8031e7c:	e7f9      	b.n	8031e72 <LmhpClockSyncAppTimeReq+0xbe>
 8031e7e:	bf00      	nop
 8031e80:	20004934 	.word	0x20004934
 8031e84:	20003490 	.word	0x20003490
 8031e88:	ed2ac280 	.word	0xed2ac280

08031e8c <LmhpClockSyncProcess>:
{
 8031e8c:	b510      	push	{r4, lr}
    if( LmhpClockSyncState.NbTransmissions > 0 )
 8031e8e:	4c05      	ldr	r4, [pc, #20]	; (8031ea4 <LmhpClockSyncProcess+0x18>)
 8031e90:	7b63      	ldrb	r3, [r4, #13]
 8031e92:	b12b      	cbz	r3, 8031ea0 <LmhpClockSyncProcess+0x14>
        if( LmhpClockSyncAppTimeReq( ) == LORAMAC_HANDLER_SUCCESS )
 8031e94:	f7ff ff8e 	bl	8031db4 <LmhpClockSyncAppTimeReq>
 8031e98:	b910      	cbnz	r0, 8031ea0 <LmhpClockSyncProcess+0x14>
            LmhpClockSyncState.NbTransmissions--;
 8031e9a:	7b63      	ldrb	r3, [r4, #13]
 8031e9c:	3b01      	subs	r3, #1
 8031e9e:	7363      	strb	r3, [r4, #13]
}
 8031ea0:	bd10      	pop	{r4, pc}
 8031ea2:	bf00      	nop
 8031ea4:	20004934 	.word	0x20004934

08031ea8 <LmhpComplianceInit>:
    return &LmhpCompliancePackage;
}

static void LmhpComplianceInit( void *params, uint8_t *dataBuffer, uint8_t dataBufferMaxSize )
{
    if( ( params != NULL ) && ( dataBuffer != NULL ) )
 8031ea8:	4b05      	ldr	r3, [pc, #20]	; (8031ec0 <LmhpComplianceInit+0x18>)
 8031eaa:	b130      	cbz	r0, 8031eba <LmhpComplianceInit+0x12>
 8031eac:	b129      	cbz	r1, 8031eba <LmhpComplianceInit+0x12>
    {
        LmhpComplianceParams = ( LmhpComplianceParams_t* )params;
        ComplianceTestState.DataBuffer = dataBuffer;
        ComplianceTestState.DataBufferMaxSize = dataBufferMaxSize;
 8031eae:	725a      	strb	r2, [r3, #9]
        LmhpComplianceParams = ( LmhpComplianceParams_t* )params;
 8031eb0:	6018      	str	r0, [r3, #0]
        ComplianceTestState.DataBuffer = dataBuffer;
 8031eb2:	60d9      	str	r1, [r3, #12]
        ComplianceTestState.Initialized = true;
 8031eb4:	2201      	movs	r2, #1
    }
    else
    {
        LmhpComplianceParams = NULL;
        ComplianceTestState.Initialized = false;
 8031eb6:	711a      	strb	r2, [r3, #4]
    }
}
 8031eb8:	4770      	bx	lr
        LmhpComplianceParams = NULL;
 8031eba:	2200      	movs	r2, #0
 8031ebc:	601a      	str	r2, [r3, #0]
 8031ebe:	e7fa      	b.n	8031eb6 <LmhpComplianceInit+0xe>
 8031ec0:	2000495c 	.word	0x2000495c

08031ec4 <LmhpComplianceIsInitialized>:

static bool LmhpComplianceIsInitialized( void )
{
    return ComplianceTestState.Initialized;
}
 8031ec4:	4b01      	ldr	r3, [pc, #4]	; (8031ecc <LmhpComplianceIsInitialized+0x8>)
 8031ec6:	7918      	ldrb	r0, [r3, #4]
 8031ec8:	4770      	bx	lr
 8031eca:	bf00      	nop
 8031ecc:	2000495c 	.word	0x2000495c

08031ed0 <LmhpComplianceIsRunning>:

static bool LmhpComplianceIsRunning( void )
{
    if( ComplianceTestState.Initialized == false )
 8031ed0:	4b02      	ldr	r3, [pc, #8]	; (8031edc <LmhpComplianceIsRunning+0xc>)
 8031ed2:	7918      	ldrb	r0, [r3, #4]
 8031ed4:	b100      	cbz	r0, 8031ed8 <LmhpComplianceIsRunning+0x8>
    {
        return false;
    }

    return ComplianceTestState.IsRunning;
 8031ed6:	7958      	ldrb	r0, [r3, #5]
}
 8031ed8:	4770      	bx	lr
 8031eda:	bf00      	nop
 8031edc:	2000495c 	.word	0x2000495c

08031ee0 <LmhpComplianceProcess>:
}

static void LmhpComplianceProcess( void )
{
    /* Nothing to process */
}
 8031ee0:	4770      	bx	lr
	...

08031ee4 <LmhpComplianceOnMcpsConfirm>:
    if (ComplianceTestState.Initialized == false)
 8031ee4:	4b06      	ldr	r3, [pc, #24]	; (8031f00 <LmhpComplianceOnMcpsConfirm+0x1c>)
 8031ee6:	791a      	ldrb	r2, [r3, #4]
 8031ee8:	b14a      	cbz	r2, 8031efe <LmhpComplianceOnMcpsConfirm+0x1a>
    if ((ComplianceTestState.IsRunning == true) &&
 8031eea:	795a      	ldrb	r2, [r3, #5]
 8031eec:	b13a      	cbz	r2, 8031efe <LmhpComplianceOnMcpsConfirm+0x1a>
 8031eee:	7802      	ldrb	r2, [r0, #0]
 8031ef0:	2a01      	cmp	r2, #1
 8031ef2:	d104      	bne.n	8031efe <LmhpComplianceOnMcpsConfirm+0x1a>
        (mcpsConfirm->McpsRequest == MCPS_CONFIRMED) &&
 8031ef4:	7902      	ldrb	r2, [r0, #4]
 8031ef6:	b112      	cbz	r2, 8031efe <LmhpComplianceOnMcpsConfirm+0x1a>
        ComplianceTestState.DownLinkCounter++;
 8031ef8:	8a1a      	ldrh	r2, [r3, #16]
 8031efa:	3201      	adds	r2, #1
 8031efc:	821a      	strh	r2, [r3, #16]
}
 8031efe:	4770      	bx	lr
 8031f00:	2000495c 	.word	0x2000495c

08031f04 <LmhpComplianceOnMlmeConfirm>:
    if( ComplianceTestState.Initialized == false )
 8031f04:	4b07      	ldr	r3, [pc, #28]	; (8031f24 <LmhpComplianceOnMlmeConfirm+0x20>)
 8031f06:	791a      	ldrb	r2, [r3, #4]
 8031f08:	b152      	cbz	r2, 8031f20 <LmhpComplianceOnMlmeConfirm+0x1c>
    if( ComplianceTestState.IsRunning == false )
 8031f0a:	795a      	ldrb	r2, [r3, #5]
 8031f0c:	b142      	cbz	r2, 8031f20 <LmhpComplianceOnMlmeConfirm+0x1c>
    if( mlmeConfirm->MlmeRequest == MLME_LINK_CHECK )
 8031f0e:	7802      	ldrb	r2, [r0, #0]
 8031f10:	2a04      	cmp	r2, #4
 8031f12:	d105      	bne.n	8031f20 <LmhpComplianceOnMlmeConfirm+0x1c>
        ComplianceTestState.LinkCheck = true;
 8031f14:	2201      	movs	r2, #1
 8031f16:	749a      	strb	r2, [r3, #18]
        ComplianceTestState.DemodMargin = mlmeConfirm->DemodMargin;
 8031f18:	7a02      	ldrb	r2, [r0, #8]
 8031f1a:	74da      	strb	r2, [r3, #19]
        ComplianceTestState.NbGateways = mlmeConfirm->NbGateways;
 8031f1c:	7a42      	ldrb	r2, [r0, #9]
 8031f1e:	751a      	strb	r2, [r3, #20]
}
 8031f20:	4770      	bx	lr
 8031f22:	bf00      	nop
 8031f24:	2000495c 	.word	0x2000495c

08031f28 <LmhpComplianceTxProcess>:
{
 8031f28:	b537      	push	{r0, r1, r2, r4, r5, lr}
    if( ComplianceTestState.Initialized == false )
 8031f2a:	4c1b      	ldr	r4, [pc, #108]	; (8031f98 <LmhpComplianceTxProcess+0x70>)
 8031f2c:	7923      	ldrb	r3, [r4, #4]
 8031f2e:	b383      	cbz	r3, 8031f92 <LmhpComplianceTxProcess+0x6a>
    if( ComplianceTestState.IsRunning == false )
 8031f30:	7960      	ldrb	r0, [r4, #5]
 8031f32:	b328      	cbz	r0, 8031f80 <LmhpComplianceTxProcess+0x58>
    if( ComplianceTestState.LinkCheck == true )
 8031f34:	7ca2      	ldrb	r2, [r4, #18]
 8031f36:	68e3      	ldr	r3, [r4, #12]
 8031f38:	b162      	cbz	r2, 8031f54 <LmhpComplianceTxProcess+0x2c>
        ComplianceTestState.LinkCheck = false;
 8031f3a:	2200      	movs	r2, #0
 8031f3c:	74a2      	strb	r2, [r4, #18]
        ComplianceTestState.DataBufferSize = 3;
 8031f3e:	2203      	movs	r2, #3
 8031f40:	72a2      	strb	r2, [r4, #10]
        ComplianceTestState.DataBuffer[0] = 5;
 8031f42:	2205      	movs	r2, #5
 8031f44:	701a      	strb	r2, [r3, #0]
        ComplianceTestState.DataBuffer[1] = ComplianceTestState.DemodMargin;
 8031f46:	7ce2      	ldrb	r2, [r4, #19]
 8031f48:	705a      	strb	r2, [r3, #1]
        ComplianceTestState.DataBuffer[2] = ComplianceTestState.NbGateways;
 8031f4a:	7d22      	ldrb	r2, [r4, #20]
 8031f4c:	709a      	strb	r2, [r3, #2]
            ComplianceTestState.State = 1;
 8031f4e:	2201      	movs	r2, #1
 8031f50:	71a2      	strb	r2, [r4, #6]
            break;
 8031f52:	e004      	b.n	8031f5e <LmhpComplianceTxProcess+0x36>
        switch( ComplianceTestState.State )
 8031f54:	79a2      	ldrb	r2, [r4, #6]
 8031f56:	2a01      	cmp	r2, #1
 8031f58:	d014      	beq.n	8031f84 <LmhpComplianceTxProcess+0x5c>
 8031f5a:	2a04      	cmp	r2, #4
 8031f5c:	d0f7      	beq.n	8031f4e <LmhpComplianceTxProcess+0x26>
    LmHandlerAppData_t appData =
 8031f5e:	22e0      	movs	r2, #224	; 0xe0
 8031f60:	f88d 2000 	strb.w	r2, [sp]
    TimerStart( &ComplianceTxNextPacketTimer );
 8031f64:	480d      	ldr	r0, [pc, #52]	; (8031f9c <LmhpComplianceTxProcess+0x74>)
    LmHandlerAppData_t appData =
 8031f66:	7aa2      	ldrb	r2, [r4, #10]
 8031f68:	f88d 2001 	strb.w	r2, [sp, #1]
 8031f6c:	9301      	str	r3, [sp, #4]
    TimerStart( &ComplianceTxNextPacketTimer );
 8031f6e:	f009 fa37 	bl	803b3e0 <UTIL_TIMER_Start>
    return LmhpCompliancePackage.OnSendRequest( &appData, ( LmHandlerMsgTypes_t )ComplianceTestState.IsTxConfirmed, NULL, true );
 8031f72:	4b0b      	ldr	r3, [pc, #44]	; (8031fa0 <LmhpComplianceTxProcess+0x78>)
 8031f74:	79e1      	ldrb	r1, [r4, #7]
 8031f76:	6a9d      	ldr	r5, [r3, #40]	; 0x28
 8031f78:	2200      	movs	r2, #0
 8031f7a:	2301      	movs	r3, #1
 8031f7c:	4668      	mov	r0, sp
 8031f7e:	47a8      	blx	r5
}
 8031f80:	b003      	add	sp, #12
 8031f82:	bd30      	pop	{r4, r5, pc}
            ComplianceTestState.DataBufferSize = 2;
 8031f84:	2202      	movs	r2, #2
 8031f86:	72a2      	strb	r2, [r4, #10]
            ComplianceTestState.DataBuffer[0] = ComplianceTestState.DownLinkCounter >> 8;
 8031f88:	8a22      	ldrh	r2, [r4, #16]
            ComplianceTestState.DataBuffer[1] = ComplianceTestState.DownLinkCounter;
 8031f8a:	705a      	strb	r2, [r3, #1]
            ComplianceTestState.DataBuffer[0] = ComplianceTestState.DownLinkCounter >> 8;
 8031f8c:	0a11      	lsrs	r1, r2, #8
 8031f8e:	7019      	strb	r1, [r3, #0]
            break;
 8031f90:	e7e5      	b.n	8031f5e <LmhpComplianceTxProcess+0x36>
        return LORAMAC_HANDLER_ERROR;
 8031f92:	f04f 30ff 	mov.w	r0, #4294967295
 8031f96:	e7f3      	b.n	8031f80 <LmhpComplianceTxProcess+0x58>
 8031f98:	2000495c 	.word	0x2000495c
 8031f9c:	20004974 	.word	0x20004974
 8031fa0:	200034c4 	.word	0x200034c4

08031fa4 <OnComplianceTxNextPacketTimerEvent>:

static void OnComplianceTxNextPacketTimerEvent( void* context )
{
    LmhpComplianceTxProcess( );
 8031fa4:	f7ff bfc0 	b.w	8031f28 <LmhpComplianceTxProcess>

08031fa8 <LmhpComplianceOnMcpsIndication>:
{
 8031fa8:	b530      	push	{r4, r5, lr}
    if( ComplianceTestState.Initialized == false )
 8031faa:	4c77      	ldr	r4, [pc, #476]	; (8032188 <LmhpComplianceOnMcpsIndication+0x1e0>)
 8031fac:	7923      	ldrb	r3, [r4, #4]
{
 8031fae:	b08d      	sub	sp, #52	; 0x34
    if( ComplianceTestState.Initialized == false )
 8031fb0:	2b00      	cmp	r3, #0
 8031fb2:	d042      	beq.n	803203a <LmhpComplianceOnMcpsIndication+0x92>
    if( mcpsIndication->RxData == false )
 8031fb4:	7b43      	ldrb	r3, [r0, #13]
 8031fb6:	2b00      	cmp	r3, #0
 8031fb8:	d03f      	beq.n	803203a <LmhpComplianceOnMcpsIndication+0x92>
    if ((ComplianceTestState.IsRunning == true) &&
 8031fba:	7965      	ldrb	r5, [r4, #5]
 8031fbc:	b125      	cbz	r5, 8031fc8 <LmhpComplianceOnMcpsIndication+0x20>
 8031fbe:	7b83      	ldrb	r3, [r0, #14]
 8031fc0:	b913      	cbnz	r3, 8031fc8 <LmhpComplianceOnMcpsIndication+0x20>
        ComplianceTestState.DownLinkCounter++;
 8031fc2:	8a23      	ldrh	r3, [r4, #16]
 8031fc4:	3301      	adds	r3, #1
 8031fc6:	8223      	strh	r3, [r4, #16]
    if( mcpsIndication->Port != COMPLIANCE_PORT )
 8031fc8:	78c1      	ldrb	r1, [r0, #3]
 8031fca:	29e0      	cmp	r1, #224	; 0xe0
 8031fcc:	d135      	bne.n	803203a <LmhpComplianceOnMcpsIndication+0x92>
    if( ComplianceTestState.IsRunning == false )
 8031fce:	2d00      	cmp	r5, #0
 8031fd0:	d135      	bne.n	803203e <LmhpComplianceOnMcpsIndication+0x96>
        if( ( mcpsIndication->BufferSize == 4 ) &&
 8031fd2:	7b02      	ldrb	r2, [r0, #12]
 8031fd4:	2a04      	cmp	r2, #4
 8031fd6:	d130      	bne.n	803203a <LmhpComplianceOnMcpsIndication+0x92>
            ( mcpsIndication->Buffer[0] == 0x01 ) &&
 8031fd8:	6883      	ldr	r3, [r0, #8]
        if( ( mcpsIndication->BufferSize == 4 ) &&
 8031fda:	7818      	ldrb	r0, [r3, #0]
 8031fdc:	2801      	cmp	r0, #1
 8031fde:	d12c      	bne.n	803203a <LmhpComplianceOnMcpsIndication+0x92>
            ( mcpsIndication->Buffer[0] == 0x01 ) &&
 8031fe0:	7858      	ldrb	r0, [r3, #1]
 8031fe2:	2801      	cmp	r0, #1
 8031fe4:	d129      	bne.n	803203a <LmhpComplianceOnMcpsIndication+0x92>
            ( mcpsIndication->Buffer[1] == 0x01 ) &&
 8031fe6:	7898      	ldrb	r0, [r3, #2]
 8031fe8:	2801      	cmp	r0, #1
 8031fea:	d126      	bne.n	803203a <LmhpComplianceOnMcpsIndication+0x92>
            ( mcpsIndication->Buffer[2] == 0x01 ) &&
 8031fec:	78db      	ldrb	r3, [r3, #3]
 8031fee:	2b01      	cmp	r3, #1
 8031ff0:	d123      	bne.n	803203a <LmhpComplianceOnMcpsIndication+0x92>
            ComplianceTestState.DataBufferSize = 2;
 8031ff2:	2002      	movs	r0, #2
 8031ff4:	72a0      	strb	r0, [r4, #10]
            LoRaMacMibSetRequestConfirm( &mibReq );
 8031ff6:	a803      	add	r0, sp, #12
            ComplianceTestState.IsRunning = true;
 8031ff8:	7163      	strb	r3, [r4, #5]
            ComplianceTestState.State = 1;
 8031ffa:	80e3      	strh	r3, [r4, #6]
            mibReq.Param.AdrEnable = true;
 8031ffc:	f88d 3010 	strb.w	r3, [sp, #16]
            ComplianceTestState.Port = 224;
 8032000:	7221      	strb	r1, [r4, #8]
            mibReq.Type = MIB_ADR;
 8032002:	f88d 200c 	strb.w	r2, [sp, #12]
            ComplianceTestState.DownLinkCounter = 0;
 8032006:	6125      	str	r5, [r4, #16]
            ComplianceTestState.NbGateways = 0;
 8032008:	7525      	strb	r5, [r4, #20]
            LoRaMacMibSetRequestConfirm( &mibReq );
 803200a:	f002 fee3 	bl	8034dd4 <LoRaMacMibSetRequestConfirm>
            LoRaMacTestSetDutyCycleOn( false );
 803200e:	4628      	mov	r0, r5
 8032010:	f003 fc44 	bl	803589c <LoRaMacTestSetDutyCycleOn>
            if( LmhpComplianceParams->StopPeripherals != NULL )
 8032014:	6823      	ldr	r3, [r4, #0]
 8032016:	685b      	ldr	r3, [r3, #4]
 8032018:	b103      	cbz	r3, 803201c <LmhpComplianceOnMcpsIndication+0x74>
                LmhpComplianceParams->StopPeripherals( );
 803201a:	4798      	blx	r3
            TimerInit( &ComplianceTxNextPacketTimer, OnComplianceTxNextPacketTimerEvent );
 803201c:	2200      	movs	r2, #0
 803201e:	4b5b      	ldr	r3, [pc, #364]	; (803218c <LmhpComplianceOnMcpsIndication+0x1e4>)
 8032020:	9200      	str	r2, [sp, #0]
 8032022:	f04f 31ff 	mov.w	r1, #4294967295
 8032026:	485a      	ldr	r0, [pc, #360]	; (8032190 <LmhpComplianceOnMcpsIndication+0x1e8>)
 8032028:	f009 f92c 	bl	803b284 <UTIL_TIMER_Create>
            TimerSetValue( &ComplianceTxNextPacketTimer, COMPLIANCE_TX_DUTYCYCLE );
 803202c:	f241 3188 	movw	r1, #5000	; 0x1388
 8032030:	4857      	ldr	r0, [pc, #348]	; (8032190 <LmhpComplianceOnMcpsIndication+0x1e8>)
 8032032:	f009 fa0f 	bl	803b454 <UTIL_TIMER_SetPeriod>
            LmhpComplianceTxProcess( );
 8032036:	f7ff ff77 	bl	8031f28 <LmhpComplianceTxProcess>
}
 803203a:	b00d      	add	sp, #52	; 0x34
 803203c:	bd30      	pop	{r4, r5, pc}
        ComplianceTestState.State = mcpsIndication->Buffer[0];
 803203e:	6883      	ldr	r3, [r0, #8]
 8032040:	781a      	ldrb	r2, [r3, #0]
 8032042:	71a2      	strb	r2, [r4, #6]
        switch( ComplianceTestState.State )
 8032044:	2a0a      	cmp	r2, #10
 8032046:	d8f8      	bhi.n	803203a <LmhpComplianceOnMcpsIndication+0x92>
 8032048:	e8df f002 	tbb	[pc, r2]
 803204c:	27232006 	.word	0x27232006
 8032050:	60433c29 	.word	0x60433c29
 8032054:	8d8b      	.short	0x8d8b
 8032056:	97          	.byte	0x97
 8032057:	00          	.byte	0x00
                TimerStop( &ComplianceTxNextPacketTimer );
 8032058:	484d      	ldr	r0, [pc, #308]	; (8032190 <LmhpComplianceOnMcpsIndication+0x1e8>)
 803205a:	f009 f971 	bl	803b340 <UTIL_TIMER_Stop>
                ComplianceTestState.DownLinkCounter = 0;
 803205e:	2300      	movs	r3, #0
 8032060:	8223      	strh	r3, [r4, #16]
                ComplianceTestState.IsRunning = false;
 8032062:	7163      	strb	r3, [r4, #5]
                mibReq.Type = MIB_ADR;
 8032064:	2304      	movs	r3, #4
 8032066:	f88d 300c 	strb.w	r3, [sp, #12]
                mibReq.Param.AdrEnable = LmhpComplianceParams->AdrEnabled;
 803206a:	6823      	ldr	r3, [r4, #0]
                LoRaMacMibSetRequestConfirm( &mibReq );
 803206c:	a803      	add	r0, sp, #12
                mibReq.Param.AdrEnable = LmhpComplianceParams->AdrEnabled;
 803206e:	781b      	ldrb	r3, [r3, #0]
 8032070:	f88d 3010 	strb.w	r3, [sp, #16]
                LoRaMacMibSetRequestConfirm( &mibReq );
 8032074:	f002 feae 	bl	8034dd4 <LoRaMacMibSetRequestConfirm>
                LoRaMacTestSetDutyCycleOn( LmhpComplianceParams->DutyCycleEnabled );
 8032078:	6823      	ldr	r3, [r4, #0]
 803207a:	7858      	ldrb	r0, [r3, #1]
 803207c:	f003 fc0e 	bl	803589c <LoRaMacTestSetDutyCycleOn>
                if( LmhpComplianceParams->StartPeripherals != NULL )
 8032080:	6823      	ldr	r3, [r4, #0]
 8032082:	689b      	ldr	r3, [r3, #8]
 8032084:	2b00      	cmp	r3, #0
 8032086:	d0d8      	beq.n	803203a <LmhpComplianceOnMcpsIndication+0x92>
                    LmhpComplianceParams->StartPeripherals( );
 8032088:	4798      	blx	r3
            break;
 803208a:	e7d6      	b.n	803203a <LmhpComplianceOnMcpsIndication+0x92>
            ComplianceTestState.DataBufferSize = 2;
 803208c:	2302      	movs	r3, #2
 803208e:	72a3      	strb	r3, [r4, #10]
            break;
 8032090:	e7d3      	b.n	803203a <LmhpComplianceOnMcpsIndication+0x92>
            ComplianceTestState.State = 1;
 8032092:	f240 1301 	movw	r3, #257	; 0x101
            ComplianceTestState.State = 1;
 8032096:	80e3      	strh	r3, [r4, #6]
            break;
 8032098:	e7cf      	b.n	803203a <LmhpComplianceOnMcpsIndication+0x92>
            ComplianceTestState.State = 1;
 803209a:	2301      	movs	r3, #1
 803209c:	e7fb      	b.n	8032096 <LmhpComplianceOnMcpsIndication+0xee>
            ComplianceTestState.DataBuffer[0] = 4;
 803209e:	68e5      	ldr	r5, [r4, #12]
            ComplianceTestState.DataBufferSize = mcpsIndication->BufferSize;
 80320a0:	7b03      	ldrb	r3, [r0, #12]
 80320a2:	72a3      	strb	r3, [r4, #10]
            ComplianceTestState.DataBuffer[0] = 4;
 80320a4:	2204      	movs	r2, #4
 80320a6:	702a      	strb	r2, [r5, #0]
            for( uint8_t i = 1; i < MIN( ComplianceTestState.DataBufferSize, ComplianceTestState.DataBufferMaxSize ); i++ )
 80320a8:	7a62      	ldrb	r2, [r4, #9]
 80320aa:	429a      	cmp	r2, r3
 80320ac:	bf28      	it	cs
 80320ae:	461a      	movcs	r2, r3
 80320b0:	2300      	movs	r3, #0
 80320b2:	3301      	adds	r3, #1
 80320b4:	b2d9      	uxtb	r1, r3
 80320b6:	428a      	cmp	r2, r1
 80320b8:	d9bf      	bls.n	803203a <LmhpComplianceOnMcpsIndication+0x92>
                ComplianceTestState.DataBuffer[i] = mcpsIndication->Buffer[i] + 1;
 80320ba:	6881      	ldr	r1, [r0, #8]
 80320bc:	5cc9      	ldrb	r1, [r1, r3]
 80320be:	3101      	adds	r1, #1
 80320c0:	54e9      	strb	r1, [r5, r3]
            for( uint8_t i = 1; i < MIN( ComplianceTestState.DataBufferSize, ComplianceTestState.DataBufferMaxSize ); i++ )
 80320c2:	e7f6      	b.n	80320b2 <LmhpComplianceOnMcpsIndication+0x10a>
                mlmeReq.Type = MLME_LINK_CHECK;
 80320c4:	2304      	movs	r3, #4
                mlmeReq.Type = MLME_DEVICE_TIME;
 80320c6:	f88d 300c 	strb.w	r3, [sp, #12]
                LoRaMacMlmeRequest( &mlmeReq );
 80320ca:	a803      	add	r0, sp, #12
 80320cc:	f003 f96e 	bl	80353ac <LoRaMacMlmeRequest>
            break;
 80320d0:	e7b3      	b.n	803203a <LmhpComplianceOnMcpsIndication+0x92>
                TimerStop(&ComplianceTxNextPacketTimer);
 80320d2:	482f      	ldr	r0, [pc, #188]	; (8032190 <LmhpComplianceOnMcpsIndication+0x1e8>)
 80320d4:	f009 f934 	bl	803b340 <UTIL_TIMER_Stop>
                ComplianceTestState.DownLinkCounter = 0;
 80320d8:	2300      	movs	r3, #0
 80320da:	8223      	strh	r3, [r4, #16]
                ComplianceTestState.IsRunning = false;
 80320dc:	7163      	strb	r3, [r4, #5]
                mibReq.Type = MIB_ADR;
 80320de:	2304      	movs	r3, #4
 80320e0:	f88d 300c 	strb.w	r3, [sp, #12]
                mibReq.Param.AdrEnable = LmhpComplianceParams->AdrEnabled;
 80320e4:	6823      	ldr	r3, [r4, #0]
                LoRaMacMibSetRequestConfirm( &mibReq );
 80320e6:	a803      	add	r0, sp, #12
                mibReq.Param.AdrEnable = LmhpComplianceParams->AdrEnabled;
 80320e8:	781b      	ldrb	r3, [r3, #0]
 80320ea:	f88d 3010 	strb.w	r3, [sp, #16]
                LoRaMacMibSetRequestConfirm( &mibReq );
 80320ee:	f002 fe71 	bl	8034dd4 <LoRaMacMibSetRequestConfirm>
                LoRaMacTestSetDutyCycleOn( LmhpComplianceParams->DutyCycleEnabled );
 80320f2:	6823      	ldr	r3, [r4, #0]
 80320f4:	7858      	ldrb	r0, [r3, #1]
 80320f6:	f003 fbd1 	bl	803589c <LoRaMacTestSetDutyCycleOn>
                if( LmhpComplianceParams->StartPeripherals != NULL )
 80320fa:	6823      	ldr	r3, [r4, #0]
 80320fc:	689b      	ldr	r3, [r3, #8]
 80320fe:	b103      	cbz	r3, 8032102 <LmhpComplianceOnMcpsIndication+0x15a>
                    LmhpComplianceParams->StartPeripherals( );
 8032100:	4798      	blx	r3
                LmhpCompliancePackage.OnJoinRequest( ACTIVATION_TYPE_OTAA );
 8032102:	4b24      	ldr	r3, [pc, #144]	; (8032194 <LmhpComplianceOnMcpsIndication+0x1ec>)
 8032104:	2002      	movs	r0, #2
 8032106:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8032108:	4798      	blx	r3
            break;
 803210a:	e796      	b.n	803203a <LmhpComplianceOnMcpsIndication+0x92>
                if( mcpsIndication->BufferSize == 3 )
 803210c:	7b02      	ldrb	r2, [r0, #12]
 803210e:	2a03      	cmp	r2, #3
 8032110:	d10e      	bne.n	8032130 <LmhpComplianceOnMcpsIndication+0x188>
                    mlmeReq.Type = MLME_TXCW;
 8032112:	2205      	movs	r2, #5
 8032114:	f88d 200c 	strb.w	r2, [sp, #12]
                    mlmeReq.Req.TxCw.Timeout = ( uint16_t )( ( mcpsIndication->Buffer[1] << 8 ) | mcpsIndication->Buffer[2] );
 8032118:	785a      	ldrb	r2, [r3, #1]
 803211a:	789b      	ldrb	r3, [r3, #2]
 803211c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8032120:	f8ad 3010 	strh.w	r3, [sp, #16]
                LoRaMacMlmeRequest( &mlmeReq );
 8032124:	a803      	add	r0, sp, #12
 8032126:	f003 f941 	bl	80353ac <LoRaMacMlmeRequest>
                ComplianceTestState.State = 1;
 803212a:	2301      	movs	r3, #1
 803212c:	71a3      	strb	r3, [r4, #6]
            break;
 803212e:	e784      	b.n	803203a <LmhpComplianceOnMcpsIndication+0x92>
                else if( mcpsIndication->BufferSize == 7 )
 8032130:	2a07      	cmp	r2, #7
 8032132:	d1f7      	bne.n	8032124 <LmhpComplianceOnMcpsIndication+0x17c>
                    mlmeReq.Type = MLME_TXCW_1;
 8032134:	2206      	movs	r2, #6
 8032136:	f88d 200c 	strb.w	r2, [sp, #12]
                    mlmeReq.Req.TxCw.Timeout = ( uint16_t )( ( mcpsIndication->Buffer[1] << 8 ) | mcpsIndication->Buffer[2] );
 803213a:	7859      	ldrb	r1, [r3, #1]
 803213c:	789a      	ldrb	r2, [r3, #2]
 803213e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8032142:	f8ad 2010 	strh.w	r2, [sp, #16]
                    mlmeReq.Req.TxCw.Frequency = ( uint32_t )( ( mcpsIndication->Buffer[3] << 16 ) | ( mcpsIndication->Buffer[4] << 8 ) | mcpsIndication->Buffer[5] ) * 100;
 8032146:	791a      	ldrb	r2, [r3, #4]
 8032148:	78d9      	ldrb	r1, [r3, #3]
 803214a:	0212      	lsls	r2, r2, #8
 803214c:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8032150:	7959      	ldrb	r1, [r3, #5]
 8032152:	430a      	orrs	r2, r1
 8032154:	2164      	movs	r1, #100	; 0x64
 8032156:	434a      	muls	r2, r1
 8032158:	9205      	str	r2, [sp, #20]
                    mlmeReq.Req.TxCw.Power = mcpsIndication->Buffer[6];
 803215a:	799b      	ldrb	r3, [r3, #6]
 803215c:	f88d 3018 	strb.w	r3, [sp, #24]
 8032160:	e7e0      	b.n	8032124 <LmhpComplianceOnMcpsIndication+0x17c>
                mlmeReq.Type = MLME_DEVICE_TIME;
 8032162:	230a      	movs	r3, #10
 8032164:	e7af      	b.n	80320c6 <LmhpComplianceOnMcpsIndication+0x11e>
                mibReq.Type = MIB_DEVICE_CLASS;
 8032166:	2200      	movs	r2, #0
 8032168:	f88d 200c 	strb.w	r2, [sp, #12]
                mibReq.Param.Class = ( DeviceClass_t )mcpsIndication->Buffer[1];;
 803216c:	785b      	ldrb	r3, [r3, #1]
 803216e:	f88d 3010 	strb.w	r3, [sp, #16]
                LoRaMacMibSetRequestConfirm( &mibReq );
 8032172:	a803      	add	r0, sp, #12
 8032174:	f002 fe2e 	bl	8034dd4 <LoRaMacMibSetRequestConfirm>
            break;
 8032178:	e75f      	b.n	803203a <LmhpComplianceOnMcpsIndication+0x92>
                mlmeReq.Type = MLME_PING_SLOT_INFO;
 803217a:	220d      	movs	r2, #13
 803217c:	f88d 200c 	strb.w	r2, [sp, #12]
                mlmeReq.Req.PingSlotInfo.PingSlot.Value = mcpsIndication->Buffer[1];
 8032180:	785b      	ldrb	r3, [r3, #1]
 8032182:	f88d 3010 	strb.w	r3, [sp, #16]
 8032186:	e7a0      	b.n	80320ca <LmhpComplianceOnMcpsIndication+0x122>
 8032188:	2000495c 	.word	0x2000495c
 803218c:	08031fa5 	.word	0x08031fa5
 8032190:	20004974 	.word	0x20004974
 8032194:	200034c4 	.word	0x200034c4

08032198 <LmhpCompliancePackageFactory>:
}
 8032198:	4800      	ldr	r0, [pc, #0]	; (803219c <LmhpCompliancePackageFactory+0x4>)
 803219a:	4770      	bx	lr
 803219c:	200034c4 	.word	0x200034c4

080321a0 <__NVIC_SystemReset>:
  __ASM volatile ("dsb 0xF":::"memory");
 80321a0:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 80321a4:	4905      	ldr	r1, [pc, #20]	; (80321bc <__NVIC_SystemReset+0x1c>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 80321a6:	4b06      	ldr	r3, [pc, #24]	; (80321c0 <__NVIC_SystemReset+0x20>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 80321a8:	68ca      	ldr	r2, [r1, #12]
 80321aa:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 80321ae:	4313      	orrs	r3, r2
 80321b0:	60cb      	str	r3, [r1, #12]
 80321b2:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 80321b6:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 80321b8:	e7fd      	b.n	80321b6 <__NVIC_SystemReset+0x16>
 80321ba:	bf00      	nop
 80321bc:	e000ed00 	.word	0xe000ed00
 80321c0:	05fa0004 	.word	0x05fa0004

080321c4 <LmhpFirmwareManagementIsInitialized>:
}

static bool LmhpFirmwareManagementIsInitialized(void)
{
  return LmhpFirmwareManagementState.Initialized;
}
 80321c4:	4b01      	ldr	r3, [pc, #4]	; (80321cc <LmhpFirmwareManagementIsInitialized+0x8>)
 80321c6:	7818      	ldrb	r0, [r3, #0]
 80321c8:	4770      	bx	lr
 80321ca:	bf00      	nop
 80321cc:	2000498c 	.word	0x2000498c

080321d0 <LmhpFirmwareManagementIsRunning>:

static bool LmhpFirmwareManagementIsRunning(void)
{
  if (LmhpFirmwareManagementState.Initialized == false)
 80321d0:	4b02      	ldr	r3, [pc, #8]	; (80321dc <LmhpFirmwareManagementIsRunning+0xc>)
 80321d2:	7818      	ldrb	r0, [r3, #0]
 80321d4:	b100      	cbz	r0, 80321d8 <LmhpFirmwareManagementIsRunning+0x8>
  {
    return false;
  }

  return LmhpFirmwareManagementState.IsRunning;
 80321d6:	7858      	ldrb	r0, [r3, #1]
}
 80321d8:	4770      	bx	lr
 80321da:	bf00      	nop
 80321dc:	2000498c 	.word	0x2000498c

080321e0 <LmhpFirmwareManagementProcess>:

static void LmhpFirmwareManagementProcess(void)
{
  /* Not yet implemented */
}
 80321e0:	4770      	bx	lr

080321e2 <OnRebootTimer>:
    LmHandlerSetDutyCycleEnable(current_dutycycle);
  }
}

static void OnRebootTimer(void *context)
{
 80321e2:	b508      	push	{r3, lr}
  NVIC_SystemReset();
 80321e4:	f7ff ffdc 	bl	80321a0 <__NVIC_SystemReset>

080321e8 <LmhpFirmwareManagementOnMcpsIndication>:
{
 80321e8:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_DELETE_IMAGE_ANS;
 80321ec:	f8df a1d8 	ldr.w	sl, [pc, #472]	; 80323c8 <LmhpFirmwareManagementOnMcpsIndication+0x1e0>
          rebootTimeAns = rebootTimeReq - (curTime.Seconds - UNIX_GPS_EPOCH_OFFSET);
 80321f0:	f8df 91dc 	ldr.w	r9, [pc, #476]	; 80323d0 <LmhpFirmwareManagementOnMcpsIndication+0x1e8>
  uint8_t dataBufferIndex = 0;
 80321f4:	2400      	movs	r4, #0
{
 80321f6:	4680      	mov	r8, r0
  uint8_t cmdIndex = 0;
 80321f8:	4623      	mov	r3, r4
            TimerSetValue(&RebootTimer, rebootCountdown * 1000);
 80321fa:	f10a 0708 	add.w	r7, sl, #8
  while (cmdIndex < mcpsIndication->BufferSize)
 80321fe:	f898 200c 	ldrb.w	r2, [r8, #12]
 8032202:	429a      	cmp	r2, r3
 8032204:	d81d      	bhi.n	8032242 <LmhpFirmwareManagementOnMcpsIndication+0x5a>
  if (dataBufferIndex != 0)
 8032206:	b1cc      	cbz	r4, 803223c <LmhpFirmwareManagementOnMcpsIndication+0x54>
    LmHandlerAppData_t appData =
 8032208:	23cb      	movs	r3, #203	; 0xcb
 803220a:	f88d 3008 	strb.w	r3, [sp, #8]
      .Buffer = LmhpFirmwareManagementState.DataBuffer,
 803220e:	4b6e      	ldr	r3, [pc, #440]	; (80323c8 <LmhpFirmwareManagementOnMcpsIndication+0x1e0>)
    LmHandlerAppData_t appData =
 8032210:	f88d 4009 	strb.w	r4, [sp, #9]
 8032214:	685b      	ldr	r3, [r3, #4]
 8032216:	9303      	str	r3, [sp, #12]
    LmHandlerGetDutyCycleEnable(&current_dutycycle);
 8032218:	f10d 0007 	add.w	r0, sp, #7
 803221c:	f7ff fc82 	bl	8031b24 <LmHandlerGetDutyCycleEnable>
    LmHandlerSetDutyCycleEnable(false);
 8032220:	2000      	movs	r0, #0
 8032222:	f7ff fc8b 	bl	8031b3c <LmHandlerSetDutyCycleEnable>
    LmhpFirmwareManagementPackage.OnSendRequest(&appData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true);
 8032226:	4b69      	ldr	r3, [pc, #420]	; (80323cc <LmhpFirmwareManagementOnMcpsIndication+0x1e4>)
 8032228:	2200      	movs	r2, #0
 803222a:	6a9c      	ldr	r4, [r3, #40]	; 0x28
 803222c:	4611      	mov	r1, r2
 803222e:	2301      	movs	r3, #1
 8032230:	a802      	add	r0, sp, #8
 8032232:	47a0      	blx	r4
    LmHandlerSetDutyCycleEnable(current_dutycycle);
 8032234:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8032238:	f7ff fc80 	bl	8031b3c <LmHandlerSetDutyCycleEnable>
}
 803223c:	b004      	add	sp, #16
 803223e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    switch (mcpsIndication->Buffer[cmdIndex++])
 8032242:	f8d8 2008 	ldr.w	r2, [r8, #8]
 8032246:	5cd1      	ldrb	r1, [r2, r3]
 8032248:	1c5e      	adds	r6, r3, #1
 803224a:	b2f6      	uxtb	r6, r6
 803224c:	2905      	cmp	r1, #5
 803224e:	d832      	bhi.n	80322b6 <LmhpFirmwareManagementOnMcpsIndication+0xce>
 8032250:	e8df f001 	tbb	[pc, r1]
 8032254:	75331103 	.word	0x75331103
 8032258:	b0a5      	.short	0xb0a5
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_PKG_VERSION_ANS;
 803225a:	1c61      	adds	r1, r4, #1
 803225c:	f8da 2004 	ldr.w	r2, [sl, #4]
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_ID;
 8032260:	b2c9      	uxtb	r1, r1
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_PKG_VERSION_ANS;
 8032262:	2300      	movs	r3, #0
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_ID;
 8032264:	2004      	movs	r0, #4
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_PKG_VERSION_ANS;
 8032266:	5513      	strb	r3, [r2, r4]
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_ID;
 8032268:	1ca3      	adds	r3, r4, #2
 803226a:	5450      	strb	r0, [r2, r1]
 803226c:	b2db      	uxtb	r3, r3
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_VERSION;
 803226e:	3403      	adds	r4, #3
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = 0x01;
 8032270:	b2e4      	uxtb	r4, r4
 8032272:	2101      	movs	r1, #1
 8032274:	e09c      	b.n	80323b0 <LmhpFirmwareManagementOnMcpsIndication+0x1c8>
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_VERSION_ANS;
 8032276:	2201      	movs	r2, #1
 8032278:	f8da 3004 	ldr.w	r3, [sl, #4]
 803227c:	18a1      	adds	r1, r4, r2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (FW_VERSION >> 0) & 0xFF;
 803227e:	b2c9      	uxtb	r1, r1
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_VERSION_ANS;
 8032280:	551a      	strb	r2, [r3, r4]
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (FW_VERSION >> 0) & 0xFF;
 8032282:	2200      	movs	r2, #0
 8032284:	545a      	strb	r2, [r3, r1]
 8032286:	1ca1      	adds	r1, r4, #2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (FW_VERSION >> 8) & 0xFF;
 8032288:	b2c9      	uxtb	r1, r1
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (HW_VERSION >> 8) & 0xFF;
 803228a:	1de0      	adds	r0, r4, #7
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (FW_VERSION >> 8) & 0xFF;
 803228c:	545a      	strb	r2, [r3, r1]
 803228e:	1ce1      	adds	r1, r4, #3
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (FW_VERSION >> 16) & 0xFF;
 8032290:	b2c9      	uxtb	r1, r1
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (HW_VERSION >> 16) & 0xFF;
 8032292:	b2c0      	uxtb	r0, r0
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (FW_VERSION >> 16) & 0xFF;
 8032294:	545a      	strb	r2, [r3, r1]
 8032296:	1d21      	adds	r1, r4, #4
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (FW_VERSION >> 24) & 0xFF;
 8032298:	b2c9      	uxtb	r1, r1
 803229a:	545a      	strb	r2, [r3, r1]
 803229c:	1d61      	adds	r1, r4, #5
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (HW_VERSION >> 0) & 0xFF;
 803229e:	b2c9      	uxtb	r1, r1
 80322a0:	545a      	strb	r2, [r3, r1]
 80322a2:	1da1      	adds	r1, r4, #6
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (HW_VERSION >> 8) & 0xFF;
 80322a4:	b2c9      	uxtb	r1, r1
 80322a6:	545a      	strb	r2, [r3, r1]
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (HW_VERSION >> 16) & 0xFF;
 80322a8:	f104 0108 	add.w	r1, r4, #8
 80322ac:	b2c9      	uxtb	r1, r1
 80322ae:	541a      	strb	r2, [r3, r0]
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (HW_VERSION >> 24) & 0xFF;
 80322b0:	3409      	adds	r4, #9
 80322b2:	545a      	strb	r2, [r3, r1]
 80322b4:	b2e4      	uxtb	r4, r4
{
 80322b6:	4633      	mov	r3, r6
 80322b8:	e7a1      	b.n	80321fe <LmhpFirmwareManagementOnMcpsIndication+0x16>
        rebootTimeReq  = (mcpsIndication->Buffer[cmdIndex++] << 0) & 0x000000FF;
 80322ba:	1c99      	adds	r1, r3, #2
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 8) & 0x0000FF00;
 80322bc:	b2c9      	uxtb	r1, r1
        rebootTimeReq  = (mcpsIndication->Buffer[cmdIndex++] << 0) & 0x000000FF;
 80322be:	5d90      	ldrb	r0, [r2, r6]
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 8) & 0x0000FF00;
 80322c0:	5c56      	ldrb	r6, [r2, r1]
 80322c2:	1cd9      	adds	r1, r3, #3
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 16) & 0x00FF0000;
 80322c4:	b2c9      	uxtb	r1, r1
 80322c6:	5c55      	ldrb	r5, [r2, r1]
 80322c8:	042d      	lsls	r5, r5, #16
 80322ca:	eb05 2506 	add.w	r5, r5, r6, lsl #8
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 24) & 0xFF000000;
 80322ce:	1d5e      	adds	r6, r3, #5
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 16) & 0x00FF0000;
 80322d0:	3304      	adds	r3, #4
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 24) & 0xFF000000;
 80322d2:	b2db      	uxtb	r3, r3
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 16) & 0x00FF0000;
 80322d4:	4405      	add	r5, r0
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 24) & 0xFF000000;
 80322d6:	5cd3      	ldrb	r3, [r2, r3]
        if (rebootTimeReq == 0)
 80322d8:	eb15 6503 	adds.w	r5, r5, r3, lsl #24
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 24) & 0xFF000000;
 80322dc:	b2f6      	uxtb	r6, r6
        if (rebootTimeReq == 0)
 80322de:	d101      	bne.n	80322e4 <LmhpFirmwareManagementOnMcpsIndication+0xfc>
          NVIC_SystemReset();
 80322e0:	f7ff ff5e 	bl	80321a0 <__NVIC_SystemReset>
        else if (rebootTimeReq == 0xFFFFFFFF)
 80322e4:	1c6b      	adds	r3, r5, #1
 80322e6:	d118      	bne.n	803231a <LmhpFirmwareManagementOnMcpsIndication+0x132>
          TimerStop(&RebootTimer);
 80322e8:	4638      	mov	r0, r7
 80322ea:	f009 f829 	bl	803b340 <UTIL_TIMER_Stop>
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_REBOOT_TIME_ANS;
 80322ee:	f8da 3004 	ldr.w	r3, [sl, #4]
 80322f2:	2202      	movs	r2, #2
 80322f4:	551a      	strb	r2, [r3, r4]
 80322f6:	1c62      	adds	r2, r4, #1
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 0) & 0xFF;
 80322f8:	b2d2      	uxtb	r2, r2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 8) & 0xFF;
 80322fa:	0a29      	lsrs	r1, r5, #8
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 0) & 0xFF;
 80322fc:	549d      	strb	r5, [r3, r2]
 80322fe:	1ca2      	adds	r2, r4, #2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 8) & 0xFF;
 8032300:	b2d2      	uxtb	r2, r2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 16) & 0xFF;
 8032302:	0c28      	lsrs	r0, r5, #16
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 8) & 0xFF;
 8032304:	5499      	strb	r1, [r3, r2]
 8032306:	1ce1      	adds	r1, r4, #3
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 16) & 0xFF;
 8032308:	b2c9      	uxtb	r1, r1
 803230a:	1d22      	adds	r2, r4, #4
 803230c:	5458      	strb	r0, [r3, r1]
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 24) & 0xFF;
 803230e:	3405      	adds	r4, #5
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 16) & 0xFF;
 8032310:	b2d2      	uxtb	r2, r2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 24) & 0xFF;
 8032312:	b2e4      	uxtb	r4, r4
 8032314:	0e2d      	lsrs	r5, r5, #24
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootCountdown >> 16) & 0xFF;
 8032316:	549d      	strb	r5, [r3, r2]
        break;
 8032318:	e7cd      	b.n	80322b6 <LmhpFirmwareManagementOnMcpsIndication+0xce>
          curTime = SysTimeGet();
 803231a:	a802      	add	r0, sp, #8
 803231c:	f008 ff22 	bl	803b164 <SysTimeGet>
          rebootTimeAns = rebootTimeReq - (curTime.Seconds - UNIX_GPS_EPOCH_OFFSET);
 8032320:	9b02      	ldr	r3, [sp, #8]
 8032322:	eba9 0303 	sub.w	r3, r9, r3
          if (rebootTimeAns > 0)
 8032326:	18ed      	adds	r5, r5, r3
 8032328:	d0e1      	beq.n	80322ee <LmhpFirmwareManagementOnMcpsIndication+0x106>
            TimerSetValue(&RebootTimer, rebootTimeAns * 1000);
 803232a:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 803232e:	4369      	muls	r1, r5
 8032330:	4638      	mov	r0, r7
 8032332:	f009 f88f 	bl	803b454 <UTIL_TIMER_SetPeriod>
            TimerStart(&RebootTimer);
 8032336:	4638      	mov	r0, r7
 8032338:	f009 f852 	bl	803b3e0 <UTIL_TIMER_Start>
 803233c:	e7d7      	b.n	80322ee <LmhpFirmwareManagementOnMcpsIndication+0x106>
        rebootCountdown  = (mcpsIndication->Buffer[cmdIndex++] << 0) & 0x000000FF;
 803233e:	5d91      	ldrb	r1, [r2, r6]
 8032340:	1c98      	adds	r0, r3, #2
        rebootCountdown += (mcpsIndication->Buffer[cmdIndex++] << 16) & 0x00FF0000;
 8032342:	1d1e      	adds	r6, r3, #4
        rebootCountdown += (mcpsIndication->Buffer[cmdIndex++] << 8) & 0x0000FF00;
 8032344:	3303      	adds	r3, #3
        rebootCountdown += (mcpsIndication->Buffer[cmdIndex++] << 16) & 0x00FF0000;
 8032346:	b2db      	uxtb	r3, r3
        rebootCountdown += (mcpsIndication->Buffer[cmdIndex++] << 8) & 0x0000FF00;
 8032348:	b2c0      	uxtb	r0, r0
        rebootCountdown += (mcpsIndication->Buffer[cmdIndex++] << 16) & 0x00FF0000;
 803234a:	5cd5      	ldrb	r5, [r2, r3]
        rebootCountdown += (mcpsIndication->Buffer[cmdIndex++] << 8) & 0x0000FF00;
 803234c:	5c10      	ldrb	r0, [r2, r0]
        rebootCountdown += (mcpsIndication->Buffer[cmdIndex++] << 16) & 0x00FF0000;
 803234e:	042d      	lsls	r5, r5, #16
 8032350:	eb05 2500 	add.w	r5, r5, r0, lsl #8
        if (rebootCountdown == 0)
 8032354:	186d      	adds	r5, r5, r1
        rebootCountdown += (mcpsIndication->Buffer[cmdIndex++] << 16) & 0x00FF0000;
 8032356:	b2f6      	uxtb	r6, r6
        if (rebootCountdown == 0)
 8032358:	d0c2      	beq.n	80322e0 <LmhpFirmwareManagementOnMcpsIndication+0xf8>
        else if (rebootCountdown == 0xFFFFFF)
 803235a:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 803235e:	429d      	cmp	r5, r3
 8032360:	d113      	bne.n	803238a <LmhpFirmwareManagementOnMcpsIndication+0x1a2>
          TimerStop(&RebootTimer);
 8032362:	4638      	mov	r0, r7
 8032364:	f008 ffec 	bl	803b340 <UTIL_TIMER_Stop>
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_REBOOT_COUNTDOWN_ANS;
 8032368:	f8da 3004 	ldr.w	r3, [sl, #4]
 803236c:	2203      	movs	r2, #3
 803236e:	551a      	strb	r2, [r3, r4]
 8032370:	1c62      	adds	r2, r4, #1
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootCountdown >> 0) & 0xFF;
 8032372:	b2d2      	uxtb	r2, r2
 8032374:	1ca1      	adds	r1, r4, #2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootCountdown >> 8) & 0xFF;
 8032376:	b2c9      	uxtb	r1, r1
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootCountdown >> 0) & 0xFF;
 8032378:	549d      	strb	r5, [r3, r2]
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootCountdown >> 8) & 0xFF;
 803237a:	0a28      	lsrs	r0, r5, #8
 803237c:	1ce2      	adds	r2, r4, #3
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootCountdown >> 16) & 0xFF;
 803237e:	3404      	adds	r4, #4
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootCountdown >> 8) & 0xFF;
 8032380:	5458      	strb	r0, [r3, r1]
 8032382:	b2d2      	uxtb	r2, r2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootCountdown >> 16) & 0xFF;
 8032384:	b2e4      	uxtb	r4, r4
 8032386:	0c2d      	lsrs	r5, r5, #16
 8032388:	e7c5      	b.n	8032316 <LmhpFirmwareManagementOnMcpsIndication+0x12e>
            TimerSetValue(&RebootTimer, rebootCountdown * 1000);
 803238a:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 803238e:	4369      	muls	r1, r5
 8032390:	4638      	mov	r0, r7
 8032392:	f009 f85f 	bl	803b454 <UTIL_TIMER_SetPeriod>
            TimerStart(&RebootTimer);
 8032396:	4638      	mov	r0, r7
 8032398:	f009 f822 	bl	803b3e0 <UTIL_TIMER_Start>
 803239c:	e7e4      	b.n	8032368 <LmhpFirmwareManagementOnMcpsIndication+0x180>
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_UPGRADE_IMAGE_ANS;
 803239e:	f8da 2004 	ldr.w	r2, [sl, #4]
 80323a2:	2104      	movs	r1, #4
 80323a4:	5511      	strb	r1, [r2, r4]
 80323a6:	1c63      	adds	r3, r4, #1
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = imageStatus & 0x03;
 80323a8:	3402      	adds	r4, #2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_UPGRADE_IMAGE_ANS;
 80323aa:	b2db      	uxtb	r3, r3
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = imageStatus & 0x03;
 80323ac:	b2e4      	uxtb	r4, r4
 80323ae:	2100      	movs	r1, #0
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = 0x01;
 80323b0:	54d1      	strb	r1, [r2, r3]
        break;
 80323b2:	e780      	b.n	80322b6 <LmhpFirmwareManagementOnMcpsIndication+0xce>
        firmwareVersion += (mcpsIndication->Buffer[cmdIndex++] << 24) & 0xFF000000;
 80323b4:	3305      	adds	r3, #5
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_DELETE_IMAGE_ANS;
 80323b6:	f8da 2004 	ldr.w	r2, [sl, #4]
        firmwareVersion += (mcpsIndication->Buffer[cmdIndex++] << 24) & 0xFF000000;
 80323ba:	b2de      	uxtb	r6, r3
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_DELETE_IMAGE_ANS;
 80323bc:	2105      	movs	r1, #5
 80323be:	1c63      	adds	r3, r4, #1
 80323c0:	5511      	strb	r1, [r2, r4]
 80323c2:	b2db      	uxtb	r3, r3
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = 0x01;
 80323c4:	3402      	adds	r4, #2
 80323c6:	e753      	b.n	8032270 <LmhpFirmwareManagementOnMcpsIndication+0x88>
 80323c8:	2000498c 	.word	0x2000498c
 80323cc:	200034f8 	.word	0x200034f8
 80323d0:	12d53d80 	.word	0x12d53d80

080323d4 <LmhpFirmwareManagementInit>:
{
 80323d4:	b507      	push	{r0, r1, r2, lr}
 80323d6:	480a      	ldr	r0, [pc, #40]	; (8032400 <LmhpFirmwareManagementInit+0x2c>)
  if (dataBuffer != NULL)
 80323d8:	b179      	cbz	r1, 80323fa <LmhpFirmwareManagementInit+0x26>
    LmhpFirmwareManagementState.DataBufferMaxSize = dataBufferMaxSize;
 80323da:	7082      	strb	r2, [r0, #2]
    LmhpFirmwareManagementState.Initialized = true;
 80323dc:	f240 1301 	movw	r3, #257	; 0x101
    TimerInit(&RebootTimer, OnRebootTimer);
 80323e0:	2200      	movs	r2, #0
    LmhpFirmwareManagementState.DataBuffer = dataBuffer;
 80323e2:	6041      	str	r1, [r0, #4]
    LmhpFirmwareManagementState.Initialized = true;
 80323e4:	f820 3b08 	strh.w	r3, [r0], #8
    TimerInit(&RebootTimer, OnRebootTimer);
 80323e8:	f04f 31ff 	mov.w	r1, #4294967295
 80323ec:	4b05      	ldr	r3, [pc, #20]	; (8032404 <LmhpFirmwareManagementInit+0x30>)
 80323ee:	9200      	str	r2, [sp, #0]
 80323f0:	f008 ff48 	bl	803b284 <UTIL_TIMER_Create>
}
 80323f4:	b003      	add	sp, #12
 80323f6:	f85d fb04 	ldr.w	pc, [sp], #4
    LmhpFirmwareManagementState.Initialized = false;
 80323fa:	8001      	strh	r1, [r0, #0]
}
 80323fc:	e7fa      	b.n	80323f4 <LmhpFirmwareManagementInit+0x20>
 80323fe:	bf00      	nop
 8032400:	2000498c 	.word	0x2000498c
 8032404:	080321e3 	.word	0x080321e3

08032408 <LmhpFirmwareManagementPackageFactory>:
}
 8032408:	4800      	ldr	r0, [pc, #0]	; (803240c <LmhpFirmwareManagementPackageFactory+0x4>)
 803240a:	4770      	bx	lr
 803240c:	200034f8 	.word	0x200034f8

08032410 <LmhpFragmentationIsInitialized>:
}

static bool LmhpFragmentationIsInitialized( void )
{
    return LmhpFragmentationState.Initialized;
}
 8032410:	4b01      	ldr	r3, [pc, #4]	; (8032418 <LmhpFragmentationIsInitialized+0x8>)
 8032412:	7818      	ldrb	r0, [r3, #0]
 8032414:	4770      	bx	lr
 8032416:	bf00      	nop
 8032418:	200049ac 	.word	0x200049ac

0803241c <LmhpFragmentationIsRunning>:

static bool LmhpFragmentationIsRunning( void )
{
    if( LmhpFragmentationState.Initialized == false )
 803241c:	4b02      	ldr	r3, [pc, #8]	; (8032428 <LmhpFragmentationIsRunning+0xc>)
 803241e:	7818      	ldrb	r0, [r3, #0]
 8032420:	b100      	cbz	r0, 8032424 <LmhpFragmentationIsRunning+0x8>
    {
        return false;
    }

    return LmhpFragmentationState.IsRunning;
 8032422:	7858      	ldrb	r0, [r3, #1]
}
 8032424:	4770      	bx	lr
 8032426:	bf00      	nop
 8032428:	200049ac 	.word	0x200049ac

0803242c <LmhpFragmentationInit>:
{
 803242c:	b513      	push	{r0, r1, r4, lr}
 803242e:	4c0f      	ldr	r4, [pc, #60]	; (803246c <LmhpFragmentationInit+0x40>)
    if( ( params != NULL ) && ( dataBuffer != NULL ) )
 8032430:	b1c0      	cbz	r0, 8032464 <LmhpFragmentationInit+0x38>
 8032432:	b1b9      	cbz	r1, 8032464 <LmhpFragmentationInit+0x38>
        LmhpFragmentationState.Initialized = true;
 8032434:	f240 1301 	movw	r3, #257	; 0x101
        LmhpFragmentationState.DataBufferMaxSize = dataBufferMaxSize;
 8032438:	70e2      	strb	r2, [r4, #3]
        TxDelayTime = 0;
 803243a:	2200      	movs	r2, #0
        LmhpFragmentationParams = ( LmhpFragmentationParams_t* )params;
 803243c:	60e0      	str	r0, [r4, #12]
        LmhpFragmentationState.DataBuffer = dataBuffer;
 803243e:	6061      	str	r1, [r4, #4]
        LmhpFragmentationState.Initialized = true;
 8032440:	8023      	strh	r3, [r4, #0]
        TimerInit( &FragmentTxDelayTimer, OnFragmentTxDelay );
 8032442:	9200      	str	r2, [sp, #0]
 8032444:	4b0a      	ldr	r3, [pc, #40]	; (8032470 <LmhpFragmentationInit+0x44>)
        TxDelayTime = 0;
 8032446:	6122      	str	r2, [r4, #16]
        TimerInit( &FragmentTxDelayTimer, OnFragmentTxDelay );
 8032448:	f04f 31ff 	mov.w	r1, #4294967295
 803244c:	f104 0014 	add.w	r0, r4, #20
 8032450:	f008 ff18 	bl	803b284 <UTIL_TIMER_Create>
    UTIL_MEM_set_8( FragSessionData, 0, sizeof(FragSessionData) );
 8032454:	4807      	ldr	r0, [pc, #28]	; (8032474 <LmhpFragmentationInit+0x48>)
 8032456:	2260      	movs	r2, #96	; 0x60
 8032458:	2100      	movs	r1, #0
}
 803245a:	b002      	add	sp, #8
 803245c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    UTIL_MEM_set_8( FragSessionData, 0, sizeof(FragSessionData) );
 8032460:	f008 bd5e 	b.w	803af20 <UTIL_MEM_set_8>
        LmhpFragmentationParams = NULL;
 8032464:	2300      	movs	r3, #0
 8032466:	60e3      	str	r3, [r4, #12]
        LmhpFragmentationState.Initialized = false;
 8032468:	8023      	strh	r3, [r4, #0]
 803246a:	e7f3      	b.n	8032454 <LmhpFragmentationInit+0x28>
 803246c:	200049ac 	.word	0x200049ac
 8032470:	08032479 	.word	0x08032479
 8032474:	200049d8 	.word	0x200049d8

08032478 <OnFragmentTxDelay>:
{
 8032478:	b510      	push	{r4, lr}
    TimerStop( &FragmentTxDelayTimer );
 803247a:	4c06      	ldr	r4, [pc, #24]	; (8032494 <OnFragmentTxDelay+0x1c>)
 803247c:	f104 0014 	add.w	r0, r4, #20
 8032480:	f008 ff5e 	bl	803b340 <UTIL_TIMER_Stop>
    LmhpFragmentationState.TxDelayState = FRAGMENTATION_TX_DELAY_STATE_PENDING;
 8032484:	2302      	movs	r3, #2
 8032486:	70a3      	strb	r3, [r4, #2]
    LmhpFragmentationPackage.OnPackageProcessEvent();
 8032488:	4b03      	ldr	r3, [pc, #12]	; (8032498 <OnFragmentTxDelay+0x20>)
}
 803248a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    LmhpFragmentationPackage.OnPackageProcessEvent();
 803248e:	695b      	ldr	r3, [r3, #20]
 8032490:	4718      	bx	r3
 8032492:	bf00      	nop
 8032494:	200049ac 	.word	0x200049ac
 8032498:	2000352c 	.word	0x2000352c

0803249c <LmhpFragmentationOnMcpsIndication>:
            break;
    }
}

static void LmhpFragmentationOnMcpsIndication( McpsIndication_t *mcpsIndication )
{
 803249c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    // Answer struct for the commands.
    LmHandlerAppData_t cmdReplyAppData;
    // Co-efficient used to calculate delay.
    uint8_t blockAckDelay = 0;

    if( mcpsIndication->Port != FRAGMENTATION_PORT )
 80324a0:	78c3      	ldrb	r3, [r0, #3]
 80324a2:	2bc9      	cmp	r3, #201	; 0xc9
{
 80324a4:	b093      	sub	sp, #76	; 0x4c
 80324a6:	4607      	mov	r7, r0
    if( mcpsIndication->Port != FRAGMENTATION_PORT )
 80324a8:	d12a      	bne.n	8032500 <LmhpFragmentationOnMcpsIndication+0x64>
    uint8_t blockAckDelay = 0;
 80324aa:	2300      	movs	r3, #0
                fragCounter = ( mcpsIndication->Buffer[cmdIndex++] << 0 ) & 0x00FF;
                fragCounter |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;

                fragIndex = ( fragCounter >> 14 ) & 0x03;
                fragCounter &= 0x3FFF;
                if (FragSessionData[fragIndex].FragGroupData.IsActive == false)
 80324ac:	4eb8      	ldr	r6, [pc, #736]	; (8032790 <LmhpFragmentationOnMcpsIndication+0x2f4>)
    uint8_t blockAckDelay = 0;
 80324ae:	9301      	str	r3, [sp, #4]
    bool isAnswerDelayed = false;
 80324b0:	4699      	mov	r9, r3
    uint8_t dataBufferIndex = 0;
 80324b2:	461c      	mov	r4, r3
    uint8_t cmdIndex = 0;
 80324b4:	469b      	mov	fp, r3
    while( cmdIndex < mcpsIndication->BufferSize )
 80324b6:	7b39      	ldrb	r1, [r7, #12]
 80324b8:	458b      	cmp	fp, r1
 80324ba:	d324      	bcc.n	8032506 <LmhpFragmentationOnMcpsIndication+0x6a>

    // After processing the commands, if the end-node has to reply back then a flag is checked if the
    // reply is to be sent immediately or with a delay.
    // In some scenarios it is not desired that multiple end-notes send uplinks at the same time to
    // the same server. (Example: Fragment status during a multicast FUOTA)
    if( dataBufferIndex != 0 )
 80324bc:	b304      	cbz	r4, 8032500 <LmhpFragmentationOnMcpsIndication+0x64>
    {
        // Prepare Answer that is to be transmitted
        cmdReplyAppData.Buffer = LmhpFragmentationState.DataBuffer;
 80324be:	4db4      	ldr	r5, [pc, #720]	; (8032790 <LmhpFragmentationOnMcpsIndication+0x2f4>)
        cmdReplyAppData.BufferSize = dataBufferIndex;
 80324c0:	f88d 4031 	strb.w	r4, [sp, #49]	; 0x31
        cmdReplyAppData.Buffer = LmhpFragmentationState.DataBuffer;
 80324c4:	686b      	ldr	r3, [r5, #4]
 80324c6:	930d      	str	r3, [sp, #52]	; 0x34
        cmdReplyAppData.Port = FRAGMENTATION_PORT;
 80324c8:	23c9      	movs	r3, #201	; 0xc9
 80324ca:	4eb2      	ldr	r6, [pc, #712]	; (8032794 <LmhpFragmentationOnMcpsIndication+0x2f8>)
 80324cc:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30

        if( isAnswerDelayed == true )
 80324d0:	ac0c      	add	r4, sp, #48	; 0x30
 80324d2:	f1b9 0f00 	cmp.w	r9, #0
 80324d6:	f000 81ae 	beq.w	8032836 <LmhpFragmentationOnMcpsIndication+0x39a>
            // Delay = Pseudo Random Delay * 1000 milli seconds.
            // Eg: blockAckDelay = 7
            //     Pseudo Random Delay = rand(0:1) * 2^11
            //     rand(0:1) seconds = rand(0:1000) milliseconds
            //     Delay = rand(0:1000) * 2048 => 2048000ms = 34 minutes
            TxDelayTime = randr( 0, 1000 ) * ( 1 << ( blockAckDelay + 4 ) );
 80324da:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 80324de:	2000      	movs	r0, #0
 80324e0:	f006 fd0a 	bl	8038ef8 <randr>
 80324e4:	9b01      	ldr	r3, [sp, #4]
 80324e6:	3304      	adds	r3, #4
 80324e8:	fa00 f303 	lsl.w	r3, r0, r3
            DelayedReplyAppData = cmdReplyAppData;
 80324ec:	e894 0003 	ldmia.w	r4, {r0, r1}
            TxDelayTime = randr( 0, 1000 ) * ( 1 << ( blockAckDelay + 4 ) );
 80324f0:	612b      	str	r3, [r5, #16]
            DelayedReplyAppData = cmdReplyAppData;
 80324f2:	4ba9      	ldr	r3, [pc, #676]	; (8032798 <LmhpFragmentationOnMcpsIndication+0x2fc>)
 80324f4:	e883 0003 	stmia.w	r3, {r0, r1}
            LmhpFragmentationState.TxDelayState = FRAGMENTATION_TX_DELAY_STATE_START;
 80324f8:	2301      	movs	r3, #1
 80324fa:	70ab      	strb	r3, [r5, #2]
            LmhpFragmentationPackage.OnPackageProcessEvent();
 80324fc:	6973      	ldr	r3, [r6, #20]
 80324fe:	4798      	blx	r3

            /* restore initial Duty Cycle */
            LmHandlerSetDutyCycleEnable( current_dutycycle );
        }
    }
}
 8032500:	b013      	add	sp, #76	; 0x4c
 8032502:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        switch( mcpsIndication->Buffer[cmdIndex++] )
 8032506:	68bb      	ldr	r3, [r7, #8]
 8032508:	f813 200b 	ldrb.w	r2, [r3, fp]
 803250c:	f10b 0a01 	add.w	sl, fp, #1
 8032510:	fa5f fa8a 	uxtb.w	sl, sl
 8032514:	2a08      	cmp	r2, #8
 8032516:	d81a      	bhi.n	803254e <LmhpFragmentationOnMcpsIndication+0xb2>
 8032518:	e8df f012 	tbh	[pc, r2, lsl #1]
 803251c:	001b0009 	.word	0x001b0009
 8032520:	00ef005d 	.word	0x00ef005d
 8032524:	00190019 	.word	0x00190019
 8032528:	00190019 	.word	0x00190019
 803252c:	0111      	.short	0x0111
                if( mcpsIndication->Multicast == 1 )
 803252e:	78bb      	ldrb	r3, [r7, #2]
 8032530:	2b01      	cmp	r3, #1
 8032532:	d00c      	beq.n	803254e <LmhpFragmentationOnMcpsIndication+0xb2>
                LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FRAGMENTATION_PKG_VERSION_ANS;
 8032534:	6872      	ldr	r2, [r6, #4]
 8032536:	2300      	movs	r3, #0
 8032538:	1c61      	adds	r1, r4, #1
 803253a:	5513      	strb	r3, [r2, r4]
                LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FRAGMENTATION_ID;
 803253c:	b2c9      	uxtb	r1, r1
 803253e:	1ca3      	adds	r3, r4, #2
 8032540:	2003      	movs	r0, #3
 8032542:	b2db      	uxtb	r3, r3
 8032544:	5450      	strb	r0, [r2, r1]
                LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FRAGMENTATION_VERSION;
 8032546:	2101      	movs	r1, #1
 8032548:	4404      	add	r4, r0
 803254a:	54d1      	strb	r1, [r2, r3]
 803254c:	b2e4      	uxtb	r4, r4
                break;
 803254e:	46d3      	mov	fp, sl
 8032550:	e7b1      	b.n	80324b6 <LmhpFragmentationOnMcpsIndication+0x1a>
                uint8_t fragIndex = mcpsIndication->Buffer[cmdIndex++];
 8032552:	f813 a00a 	ldrb.w	sl, [r3, sl]
                FragSessionData[fragIndex].FragDecoderStatus = FragDecoderGetStatus( );
 8032556:	a808      	add	r0, sp, #32
 8032558:	2318      	movs	r3, #24
 803255a:	f3ca 0541 	ubfx	r5, sl, #1, #2
 803255e:	fb03 6805 	mla	r8, r3, r5, r6
 8032562:	f7fe fef5 	bl	8031350 <FragDecoderGetStatus>
 8032566:	9808      	ldr	r0, [sp, #32]
 8032568:	9909      	ldr	r1, [sp, #36]	; 0x24
                uint8_t fragIndex = mcpsIndication->Buffer[cmdIndex++];
 803256a:	f10b 0b02 	add.w	fp, fp, #2
                FragSessionData[fragIndex].FragDecoderStatus = FragDecoderGetStatus( );
 803256e:	f108 0338 	add.w	r3, r8, #56	; 0x38
                if( ( participants == 1 ) ||
 8032572:	f01a 0f01 	tst.w	sl, #1
                FragSessionData[fragIndex].FragDecoderStatus = FragDecoderGetStatus( );
 8032576:	c303      	stmia	r3!, {r0, r1}
                uint8_t fragIndex = mcpsIndication->Buffer[cmdIndex++];
 8032578:	fa5f fb8b 	uxtb.w	fp, fp
                if( ( participants == 1 ) ||
 803257c:	d102      	bne.n	8032584 <LmhpFragmentationOnMcpsIndication+0xe8>
                    ( ( participants == 0 ) && ( FragSessionData[fragIndex].FragDecoderStatus.FragNbLost > 0 ) ) )
 803257e:	f8b8 303a 	ldrh.w	r3, [r8, #58]	; 0x3a
 8032582:	b333      	cbz	r3, 80325d2 <LmhpFragmentationOnMcpsIndication+0x136>
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FRAGMENTATION_FRAG_STATUS_ANS;
 8032584:	6872      	ldr	r2, [r6, #4]
 8032586:	f04f 0901 	mov.w	r9, #1
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.FragNbRx & 0xFF;
 803258a:	2318      	movs	r3, #24
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FRAGMENTATION_FRAG_STATUS_ANS;
 803258c:	f802 9004 	strb.w	r9, [r2, r4]
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.FragNbRx & 0xFF;
 8032590:	fb03 6305 	mla	r3, r3, r5, r6
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FRAGMENTATION_FRAG_STATUS_ANS;
 8032594:	eb04 0109 	add.w	r1, r4, r9
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.FragNbRx & 0xFF;
 8032598:	b2c9      	uxtb	r1, r1
 803259a:	8f18      	ldrh	r0, [r3, #56]	; 0x38
 803259c:	5450      	strb	r0, [r2, r1]
                                                                           ( ( FragSessionData[fragIndex].FragDecoderStatus.FragNbRx >> 8 ) & 0x3F );
 803259e:	8f19      	ldrh	r1, [r3, #56]	; 0x38
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.FragNbRx & 0xFF;
 80325a0:	1ca0      	adds	r0, r4, #2
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = ( fragIndex << 6 ) |
 80325a2:	b2c0      	uxtb	r0, r0
                                                                           ( ( FragSessionData[fragIndex].FragDecoderStatus.FragNbRx >> 8 ) & 0x3F );
 80325a4:	f3c1 2105 	ubfx	r1, r1, #8, #6
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = ( fragIndex << 6 ) |
 80325a8:	ea41 1185 	orr.w	r1, r1, r5, lsl #6
 80325ac:	5411      	strb	r1, [r2, r0]
 80325ae:	1ce0      	adds	r0, r4, #3
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.FragNbLost;
 80325b0:	b2c0      	uxtb	r0, r0
 80325b2:	8f5d      	ldrh	r5, [r3, #58]	; 0x3a
 80325b4:	5415      	strb	r5, [r2, r0]
 80325b6:	1d21      	adds	r1, r4, #4
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.MatrixError & 0x01;
 80325b8:	f893 003e 	ldrb.w	r0, [r3, #62]	; 0x3e
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.FragNbLost;
 80325bc:	b2c9      	uxtb	r1, r1
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.MatrixError & 0x01;
 80325be:	ea00 0009 	and.w	r0, r0, r9
 80325c2:	5450      	strb	r0, [r2, r1]
                    blockAckDelay = FragSessionData[fragIndex].FragGroupData.Control.Fields.BlockAckDelay;
 80325c4:	f893 0031 	ldrb.w	r0, [r3, #49]	; 0x31
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.MatrixError & 0x01;
 80325c8:	3405      	adds	r4, #5
                    blockAckDelay = FragSessionData[fragIndex].FragGroupData.Control.Fields.BlockAckDelay;
 80325ca:	f000 0307 	and.w	r3, r0, #7
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.MatrixError & 0x01;
 80325ce:	b2e4      	uxtb	r4, r4
                    blockAckDelay = FragSessionData[fragIndex].FragGroupData.Control.Fields.BlockAckDelay;
 80325d0:	9301      	str	r3, [sp, #4]
                uint8_t fragIndex = mcpsIndication->Buffer[cmdIndex++];
 80325d2:	46da      	mov	sl, fp
 80325d4:	e7bb      	b.n	803254e <LmhpFragmentationOnMcpsIndication+0xb2>
                if( mcpsIndication->Multicast == 1 )
 80325d6:	78ba      	ldrb	r2, [r7, #2]
 80325d8:	2a01      	cmp	r2, #1
 80325da:	d0b8      	beq.n	803254e <LmhpFragmentationOnMcpsIndication+0xb2>
                fragSessionData.FragGroupData.FragSession.Value = mcpsIndication->Buffer[cmdIndex++];
 80325dc:	f813 200a 	ldrb.w	r2, [r3, sl]
 80325e0:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
                fragSessionData.FragGroupData.FragNb =  ( mcpsIndication->Buffer[cmdIndex++] << 0 ) & 0x00FF;
 80325e4:	f10b 0203 	add.w	r2, fp, #3
                fragSessionData.FragGroupData.FragNb |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 80325e8:	b2d2      	uxtb	r2, r2
                fragSessionData.FragGroupData.Padding = mcpsIndication->Buffer[cmdIndex++];
 80325ea:	f10b 0007 	add.w	r0, fp, #7
                fragSessionData.FragGroupData.FragNb |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 80325ee:	5c99      	ldrb	r1, [r3, r2]
                fragSessionData.FragGroupData.FragSession.Value = mcpsIndication->Buffer[cmdIndex++];
 80325f0:	f10b 0202 	add.w	r2, fp, #2
                fragSessionData.FragGroupData.FragNb =  ( mcpsIndication->Buffer[cmdIndex++] << 0 ) & 0x00FF;
 80325f4:	b2d2      	uxtb	r2, r2
                fragSessionData.FragGroupData.Descriptor =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 80325f6:	b2c0      	uxtb	r0, r0
                fragSessionData.FragGroupData.FragNb |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 80325f8:	f813 8002 	ldrb.w	r8, [r3, r2]
                fragSessionData.FragGroupData.Descriptor =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 80325fc:	5c18      	ldrb	r0, [r3, r0]
 80325fe:	9002      	str	r0, [sp, #8]
                fragSessionData.FragGroupData.FragNb |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 8032600:	f10b 0204 	add.w	r2, fp, #4
                fragSessionData.FragGroupData.FragSize = mcpsIndication->Buffer[cmdIndex++];
 8032604:	b2d2      	uxtb	r2, r2
                fragSessionData.FragGroupData.Descriptor =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032606:	f10b 0008 	add.w	r0, fp, #8
                fragSessionData.FragGroupData.FragSize = mcpsIndication->Buffer[cmdIndex++];
 803260a:	f813 9002 	ldrb.w	r9, [r3, r2]
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 803260e:	b2c0      	uxtb	r0, r0
                fragSessionData.FragGroupData.FragSize = mcpsIndication->Buffer[cmdIndex++];
 8032610:	f10b 0205 	add.w	r2, fp, #5
                fragSessionData.FragGroupData.Control.Value = mcpsIndication->Buffer[cmdIndex++];
 8032614:	b2d2      	uxtb	r2, r2
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032616:	5c18      	ldrb	r0, [r3, r0]
                fragSessionData.FragGroupData.Control.Value = mcpsIndication->Buffer[cmdIndex++];
 8032618:	5c9a      	ldrb	r2, [r3, r2]
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 803261a:	9003      	str	r0, [sp, #12]
                fragSessionData.FragGroupData.FragNb |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 803261c:	ea48 2801 	orr.w	r8, r8, r1, lsl #8
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032620:	f10b 0009 	add.w	r0, fp, #9
                fragSessionData.FragGroupData.Control.Value = mcpsIndication->Buffer[cmdIndex++];
 8032624:	f10b 0106 	add.w	r1, fp, #6
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032628:	f10b 0a0b 	add.w	sl, fp, #11
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 803262c:	f10b 0b0a 	add.w	fp, fp, #10
                fragSessionData.FragGroupData.Padding = mcpsIndication->Buffer[cmdIndex++];
 8032630:	b2c9      	uxtb	r1, r1
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032632:	b2c0      	uxtb	r0, r0
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032634:	fa5f fb8b 	uxtb.w	fp, fp
                if( fragSessionData.FragGroupData.Control.Fields.FragAlgo > 0 )
 8032638:	f012 0f38 	tst.w	r2, #56	; 0x38
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 803263c:	5c18      	ldrb	r0, [r3, r0]
                fragSessionData.FragGroupData.Padding = mcpsIndication->Buffer[cmdIndex++];
 803263e:	5c59      	ldrb	r1, [r3, r1]
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032640:	f813 b00b 	ldrb.w	fp, [r3, fp]
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032644:	9004      	str	r0, [sp, #16]
                    status |= 0x01; // Encoding unsupported
 8032646:	bf14      	ite	ne
 8032648:	2301      	movne	r3, #1
 803264a:	2300      	moveq	r3, #0
                if( ( fragSessionData.FragGroupData.FragNb > FRAG_MAX_NB ) || 
 803264c:	f5b8 7f33 	cmp.w	r8, #716	; 0x2cc
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032650:	fa5f fa8a 	uxtb.w	sl, sl
                if( ( fragSessionData.FragGroupData.FragNb > FRAG_MAX_NB ) || 
 8032654:	d941      	bls.n	80326da <LmhpFragmentationOnMcpsIndication+0x23e>
                    status |= 0x02; // Not enough Memory
 8032656:	f043 0302 	orr.w	r3, r3, #2
                status |= ( fragSessionData.FragGroupData.FragSession.Fields.FragIndex << 6 ) & 0xC0;
 803265a:	f89d c031 	ldrb.w	ip, [sp, #49]	; 0x31
 803265e:	f3cc 1c01 	ubfx	ip, ip, #4, #2
 8032662:	ea43 158c 	orr.w	r5, r3, ip, lsl #6
                if( ( status & 0x0F ) == 0 )
 8032666:	071b      	lsls	r3, r3, #28
 8032668:	d12c      	bne.n	80326c4 <LmhpFragmentationOnMcpsIndication+0x228>
                    FragSessionData[fragSessionData.FragGroupData.FragSession.Fields.FragIndex] = fragSessionData;
 803266a:	2301      	movs	r3, #1
 803266c:	f88d 2035 	strb.w	r2, [sp, #53]	; 0x35
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032670:	9a04      	ldr	r2, [sp, #16]
                    FragSessionData[fragSessionData.FragGroupData.FragSession.Fields.FragIndex] = fragSessionData;
 8032672:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032676:	ea4f 630b 	mov.w	r3, fp, lsl #24
 803267a:	eb03 4302 	add.w	r3, r3, r2, lsl #16
 803267e:	9a02      	ldr	r2, [sp, #8]
                    FragSessionData[fragSessionData.FragGroupData.FragSession.Fields.FragIndex] = fragSessionData;
 8032680:	f8ad 8032 	strh.w	r8, [sp, #50]	; 0x32
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032684:	4413      	add	r3, r2
 8032686:	9a03      	ldr	r2, [sp, #12]
                    FragSessionData[fragSessionData.FragGroupData.FragSession.Fields.FragIndex] = fragSessionData;
 8032688:	f88d 9034 	strb.w	r9, [sp, #52]	; 0x34
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 803268c:	eb03 2302 	add.w	r3, r3, r2, lsl #8
                    FragSessionData[fragSessionData.FragGroupData.FragSession.Fields.FragIndex] = fragSessionData;
 8032690:	930e      	str	r3, [sp, #56]	; 0x38
 8032692:	f04f 33ff 	mov.w	r3, #4294967295
 8032696:	9311      	str	r3, [sp, #68]	; 0x44
 8032698:	f88d 1036 	strb.w	r1, [sp, #54]	; 0x36
 803269c:	2318      	movs	r3, #24
 803269e:	f10d 0e30 	add.w	lr, sp, #48	; 0x30
 80326a2:	fb03 6c0c 	mla	ip, r3, ip, r6
 80326a6:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 80326aa:	f10c 0c2c 	add.w	ip, ip, #44	; 0x2c
 80326ae:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 80326b2:	e89e 0003 	ldmia.w	lr, {r0, r1}
                    FragDecoderInit( fragSessionData.FragGroupData.FragNb,
 80326b6:	68f2      	ldr	r2, [r6, #12]
                    FragSessionData[fragSessionData.FragGroupData.FragSession.Fields.FragIndex] = fragSessionData;
 80326b8:	e88c 0003 	stmia.w	ip, {r0, r1}
                    FragDecoderInit( fragSessionData.FragGroupData.FragNb,
 80326bc:	4649      	mov	r1, r9
 80326be:	4640      	mov	r0, r8
 80326c0:	f7fe fc5e 	bl	8030f80 <FragDecoderInit>
                LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FRAGMENTATION_FRAG_SESSION_SETUP_ANS;
 80326c4:	1c63      	adds	r3, r4, #1
 80326c6:	6872      	ldr	r2, [r6, #4]
 80326c8:	b2db      	uxtb	r3, r3
 80326ca:	2102      	movs	r1, #2
 80326cc:	5511      	strb	r1, [r2, r4]
                LmhpFragmentationState.DataBuffer[dataBufferIndex++] = status;
 80326ce:	440c      	add	r4, r1
 80326d0:	54d5      	strb	r5, [r2, r3]
 80326d2:	b2e4      	uxtb	r4, r4
                isAnswerDelayed = false;
 80326d4:	f04f 0900 	mov.w	r9, #0
                break;
 80326d8:	e739      	b.n	803254e <LmhpFragmentationOnMcpsIndication+0xb2>
                if( ( fragSessionData.FragGroupData.FragNb > FRAG_MAX_NB ) || 
 80326da:	f1b9 0f78 	cmp.w	r9, #120	; 0x78
 80326de:	d8ba      	bhi.n	8032656 <LmhpFragmentationOnMcpsIndication+0x1ba>
 80326e0:	e9cd 1306 	strd	r1, r3, [sp, #24]
 80326e4:	9205      	str	r2, [sp, #20]
                    ( ( fragSessionData.FragGroupData.FragNb * fragSessionData.FragGroupData.FragSize ) > FragDecoderGetMaxFileSize( ) ) )
 80326e6:	f7fe fc7d 	bl	8030fe4 <FragDecoderGetMaxFileSize>
 80326ea:	fb09 f508 	mul.w	r5, r9, r8
                    ( fragSessionData.FragGroupData.FragSize > FRAG_MAX_SIZE ) ||
 80326ee:	4285      	cmp	r5, r0
 80326f0:	e9dd 2105 	ldrd	r2, r1, [sp, #20]
 80326f4:	9b07      	ldr	r3, [sp, #28]
 80326f6:	d8ae      	bhi.n	8032656 <LmhpFragmentationOnMcpsIndication+0x1ba>
 80326f8:	e7af      	b.n	803265a <LmhpFragmentationOnMcpsIndication+0x1be>
                if( mcpsIndication->Multicast == 1 )
 80326fa:	78ba      	ldrb	r2, [r7, #2]
 80326fc:	2a01      	cmp	r2, #1
 80326fe:	f43f af26 	beq.w	803254e <LmhpFragmentationOnMcpsIndication+0xb2>
                uint8_t id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032702:	f813 300a 	ldrb.w	r3, [r3, sl]
                if( ( id >= FRAGMENTATION_MAX_SESSIONS ) || ( FragSessionData[id].FragGroupData.IsActive == false ) )
 8032706:	2218      	movs	r2, #24
                uint8_t id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032708:	f003 0303 	and.w	r3, r3, #3
                if( ( id >= FRAGMENTATION_MAX_SESSIONS ) || ( FragSessionData[id].FragGroupData.IsActive == false ) )
 803270c:	fb02 6203 	mla	r2, r2, r3, r6
                uint8_t id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032710:	f10b 0b02 	add.w	fp, fp, #2
                if( ( id >= FRAGMENTATION_MAX_SESSIONS ) || ( FragSessionData[id].FragGroupData.IsActive == false ) )
 8032714:	f892 102c 	ldrb.w	r1, [r2, #44]	; 0x2c
                uint8_t id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032718:	fa5f fb8b 	uxtb.w	fp, fp
                if( ( id >= FRAGMENTATION_MAX_SESSIONS ) || ( FragSessionData[id].FragGroupData.IsActive == false ) )
 803271c:	b959      	cbnz	r1, 8032736 <LmhpFragmentationOnMcpsIndication+0x29a>
                    status |= 0x04; // Session does not exist
 803271e:	f043 0304 	orr.w	r3, r3, #4
                LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FRAGMENTATION_FRAG_SESSION_DELETE_ANS;
 8032722:	6871      	ldr	r1, [r6, #4]
 8032724:	1c62      	adds	r2, r4, #1
 8032726:	b2d2      	uxtb	r2, r2
 8032728:	2003      	movs	r0, #3
 803272a:	5508      	strb	r0, [r1, r4]
                LmhpFragmentationState.DataBuffer[dataBufferIndex++] = status;
 803272c:	3402      	adds	r4, #2
 803272e:	548b      	strb	r3, [r1, r2]
 8032730:	b2e4      	uxtb	r4, r4
                uint8_t id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032732:	46da      	mov	sl, fp
 8032734:	e7ce      	b.n	80326d4 <LmhpFragmentationOnMcpsIndication+0x238>
                    FragSessionData[id].FragGroupData.IsActive = false;
 8032736:	2100      	movs	r1, #0
 8032738:	f882 102c 	strb.w	r1, [r2, #44]	; 0x2c
 803273c:	e7f1      	b.n	8032722 <LmhpFragmentationOnMcpsIndication+0x286>
                fragCounter = ( mcpsIndication->Buffer[cmdIndex++] << 0 ) & 0x00FF;
 803273e:	f10b 0202 	add.w	r2, fp, #2
                fragCounter |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 8032742:	b2d2      	uxtb	r2, r2
 8032744:	f813 8002 	ldrb.w	r8, [r3, r2]
 8032748:	f813 300a 	ldrb.w	r3, [r3, sl]
                if (FragSessionData[fragIndex].FragGroupData.IsActive == false)
 803274c:	2218      	movs	r2, #24
                fragCounter |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 803274e:	ea43 2308 	orr.w	r3, r3, r8, lsl #8
                if (FragSessionData[fragIndex].FragGroupData.IsActive == false)
 8032752:	ea4f 1898 	mov.w	r8, r8, lsr #6
 8032756:	fb02 6208 	mla	r2, r2, r8, r6
 803275a:	f102 052c 	add.w	r5, r2, #44	; 0x2c
 803275e:	f892 202c 	ldrb.w	r2, [r2, #44]	; 0x2c
 8032762:	2a00      	cmp	r2, #0
 8032764:	d065      	beq.n	8032832 <LmhpFragmentationOnMcpsIndication+0x396>
                if( mcpsIndication->Multicast == 1 )
 8032766:	78ba      	ldrb	r2, [r7, #2]
 8032768:	2a01      	cmp	r2, #1
 803276a:	d117      	bne.n	803279c <LmhpFragmentationOnMcpsIndication+0x300>
                    uint8_t groupId = LoRaMacMcChannelGetGroupId( mcpsIndication->DevAddress );
 803276c:	6978      	ldr	r0, [r7, #20]
 803276e:	9302      	str	r3, [sp, #8]
 8032770:	f002 fdc0 	bl	80352f4 <LoRaMacMcChannelGetGroupId>
                    if( ( groupId == 0xFF ) ||
 8032774:	28ff      	cmp	r0, #255	; 0xff
 8032776:	d008      	beq.n	803278a <LmhpFragmentationOnMcpsIndication+0x2ee>
                        ( ( FragSessionData[fragIndex].FragGroupData.FragSession.Fields.McGroupBitMask & ( 1 << groupId ) ) == 0 ) )
 8032778:	786a      	ldrb	r2, [r5, #1]
                    if( ( groupId == 0xFF ) ||
 803277a:	9b02      	ldr	r3, [sp, #8]
                        ( ( FragSessionData[fragIndex].FragGroupData.FragSession.Fields.McGroupBitMask & ( 1 << groupId ) ) == 0 ) )
 803277c:	f002 020f 	and.w	r2, r2, #15
 8032780:	fa42 f000 	asr.w	r0, r2, r0
                    if( ( groupId == 0xFF ) ||
 8032784:	f010 0f01 	tst.w	r0, #1
 8032788:	d108      	bne.n	803279c <LmhpFragmentationOnMcpsIndication+0x300>
                        cmdIndex = mcpsIndication->BufferSize;
 803278a:	f897 a00c 	ldrb.w	sl, [r7, #12]
                        break;
 803278e:	e6de      	b.n	803254e <LmhpFragmentationOnMcpsIndication+0xb2>
 8032790:	200049ac 	.word	0x200049ac
 8032794:	2000352c 	.word	0x2000352c
 8032798:	20006308 	.word	0x20006308
                if (FragSessionData[fragIndex].FragDecoderProcessStatus == FRAG_SESSION_ONGOING)
 803279c:	2218      	movs	r2, #24
 803279e:	fb02 6a08 	mla	sl, r2, r8, r6
                fragCounter |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 80327a2:	f10b 0503 	add.w	r5, fp, #3
                if (FragSessionData[fragIndex].FragDecoderProcessStatus == FRAG_SESSION_ONGOING)
 80327a6:	f8da 2040 	ldr.w	r2, [sl, #64]	; 0x40
 80327aa:	3201      	adds	r2, #1
                fragCounter |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 80327ac:	b2ed      	uxtb	r5, r5
                if (FragSessionData[fragIndex].FragDecoderProcessStatus == FRAG_SESSION_ONGOING)
 80327ae:	d137      	bne.n	8032820 <LmhpFragmentationOnMcpsIndication+0x384>
                    FragSessionData[fragIndex].FragDecoderProcessStatus = FragDecoderProcess( fragCounter, &mcpsIndication->Buffer[cmdIndex] );
 80327b0:	68b9      	ldr	r1, [r7, #8]
 80327b2:	f3c3 000d 	ubfx	r0, r3, #0, #14
 80327b6:	4429      	add	r1, r5
 80327b8:	f7fe fc18 	bl	8030fec <FragDecoderProcess>
 80327bc:	f8ca 0040 	str.w	r0, [sl, #64]	; 0x40
                    FragSessionData[fragIndex].FragDecoderStatus = FragDecoderGetStatus( );
 80327c0:	a808      	add	r0, sp, #32
 80327c2:	f7fe fdc5 	bl	8031350 <FragDecoderGetStatus>
 80327c6:	9808      	ldr	r0, [sp, #32]
 80327c8:	9909      	ldr	r1, [sp, #36]	; 0x24
 80327ca:	f10a 0338 	add.w	r3, sl, #56	; 0x38
 80327ce:	c303      	stmia	r3!, {r0, r1}
                    if( LmhpFragmentationParams->OnProgress != NULL )
 80327d0:	68f3      	ldr	r3, [r6, #12]
 80327d2:	f8d3 b00c 	ldr.w	fp, [r3, #12]
 80327d6:	f1bb 0f00 	cmp.w	fp, #0
 80327da:	d008      	beq.n	80327ee <LmhpFragmentationOnMcpsIndication+0x352>
                        LmhpFragmentationParams->OnProgress( FragSessionData[fragIndex].FragDecoderStatus.FragNbRx,
 80327dc:	f8ba 303a 	ldrh.w	r3, [sl, #58]	; 0x3a
 80327e0:	f89a 2030 	ldrb.w	r2, [sl, #48]	; 0x30
 80327e4:	f8ba 102e 	ldrh.w	r1, [sl, #46]	; 0x2e
 80327e8:	f8ba 0038 	ldrh.w	r0, [sl, #56]	; 0x38
 80327ec:	47d8      	blx	fp
                    if( FragSessionData[fragIndex].FragDecoderProcessStatus >= 0 )
 80327ee:	2318      	movs	r3, #24
 80327f0:	fb03 6308 	mla	r3, r3, r8, r6
 80327f4:	6c18      	ldr	r0, [r3, #64]	; 0x40
 80327f6:	2800      	cmp	r0, #0
 80327f8:	db12      	blt.n	8032820 <LmhpFragmentationOnMcpsIndication+0x384>
                        if( LmhpFragmentationParams->OnDone != NULL )
 80327fa:	68f2      	ldr	r2, [r6, #12]
 80327fc:	6912      	ldr	r2, [r2, #16]
 80327fe:	b14a      	cbz	r2, 8032814 <LmhpFragmentationOnMcpsIndication+0x378>
                                                            ( FragSessionData[fragIndex].FragGroupData.FragNb * FragSessionData[fragIndex].FragGroupData.FragSize ) - FragSessionData[fragIndex].FragGroupData.Padding );
 8032800:	f8b3 c02e 	ldrh.w	ip, [r3, #46]	; 0x2e
 8032804:	f893 1030 	ldrb.w	r1, [r3, #48]	; 0x30
 8032808:	f893 3032 	ldrb.w	r3, [r3, #50]	; 0x32
 803280c:	fb01 f10c 	mul.w	r1, r1, ip
                            LmhpFragmentationParams->OnDone( FragSessionData[fragIndex].FragDecoderProcessStatus,
 8032810:	1ac9      	subs	r1, r1, r3
 8032812:	4790      	blx	r2
                        FragSessionData[fragIndex].FragDecoderProcessStatus = FRAG_SESSION_NOT_STARTED;
 8032814:	2318      	movs	r3, #24
 8032816:	fb03 6308 	mla	r3, r3, r8, r6
 803281a:	f06f 0201 	mvn.w	r2, #1
 803281e:	641a      	str	r2, [r3, #64]	; 0x40
                cmdIndex += FragSessionData[fragIndex].FragGroupData.FragSize;
 8032820:	2318      	movs	r3, #24
 8032822:	fb03 6808 	mla	r8, r3, r8, r6
 8032826:	f898 a030 	ldrb.w	sl, [r8, #48]	; 0x30
 803282a:	4455      	add	r5, sl
 803282c:	fa5f fa85 	uxtb.w	sl, r5
                break;
 8032830:	e68d      	b.n	803254e <LmhpFragmentationOnMcpsIndication+0xb2>
 8032832:	468a      	mov	sl, r1
 8032834:	e68b      	b.n	803254e <LmhpFragmentationOnMcpsIndication+0xb2>
            LmHandlerGetDutyCycleEnable( &current_dutycycle );
 8032836:	f10d 002f 	add.w	r0, sp, #47	; 0x2f
 803283a:	f7ff f973 	bl	8031b24 <LmHandlerGetDutyCycleEnable>
            LmHandlerSetDutyCycleEnable( false );
 803283e:	4648      	mov	r0, r9
 8032840:	f7ff f97c 	bl	8031b3c <LmHandlerSetDutyCycleEnable>
            LmhpFragmentationPackage.OnSendRequest( &cmdReplyAppData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true );
 8032844:	6ab5      	ldr	r5, [r6, #40]	; 0x28
 8032846:	2301      	movs	r3, #1
 8032848:	464a      	mov	r2, r9
 803284a:	4649      	mov	r1, r9
 803284c:	4620      	mov	r0, r4
 803284e:	47a8      	blx	r5
            LmHandlerSetDutyCycleEnable( current_dutycycle );
 8032850:	f89d 002f 	ldrb.w	r0, [sp, #47]	; 0x2f
 8032854:	f7ff f972 	bl	8031b3c <LmHandlerSetDutyCycleEnable>
 8032858:	e652      	b.n	8032500 <LmhpFragmentationOnMcpsIndication+0x64>
 803285a:	bf00      	nop

0803285c <LmhpFragmentationProcess>:
{
 803285c:	b538      	push	{r3, r4, r5, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803285e:	f3ef 8210 	mrs	r2, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8032862:	b672      	cpsid	i
    delayTimerState = LmhpFragmentationState.TxDelayState;
 8032864:	4c0f      	ldr	r4, [pc, #60]	; (80328a4 <LmhpFragmentationProcess+0x48>)
 8032866:	78a3      	ldrb	r3, [r4, #2]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8032868:	f382 8810 	msr	PRIMASK, r2
    switch( delayTimerState )
 803286c:	2b01      	cmp	r3, #1
 803286e:	d002      	beq.n	8032876 <LmhpFragmentationProcess+0x1a>
 8032870:	2b02      	cmp	r3, #2
 8032872:	d00b      	beq.n	803288c <LmhpFragmentationProcess+0x30>
}
 8032874:	bd38      	pop	{r3, r4, r5, pc}
            TimerSetValue( &FragmentTxDelayTimer, TxDelayTime );
 8032876:	6921      	ldr	r1, [r4, #16]
 8032878:	f104 0014 	add.w	r0, r4, #20
 803287c:	f008 fdea 	bl	803b454 <UTIL_TIMER_SetPeriod>
            TimerStart( &FragmentTxDelayTimer );
 8032880:	f104 0014 	add.w	r0, r4, #20
}
 8032884:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
            TimerStart( &FragmentTxDelayTimer );
 8032888:	f008 bdaa 	b.w	803b3e0 <UTIL_TIMER_Start>
            if (LORAMAC_HANDLER_SUCCESS == LmhpFragmentationPackage.OnSendRequest( &DelayedReplyAppData,
 803288c:	4b06      	ldr	r3, [pc, #24]	; (80328a8 <LmhpFragmentationProcess+0x4c>)
 803288e:	4807      	ldr	r0, [pc, #28]	; (80328ac <LmhpFragmentationProcess+0x50>)
 8032890:	6a9d      	ldr	r5, [r3, #40]	; 0x28
 8032892:	2200      	movs	r2, #0
 8032894:	2301      	movs	r3, #1
 8032896:	4611      	mov	r1, r2
 8032898:	47a8      	blx	r5
 803289a:	2800      	cmp	r0, #0
 803289c:	d1ea      	bne.n	8032874 <LmhpFragmentationProcess+0x18>
                LmhpFragmentationState.TxDelayState = FRAGMENTATION_TX_DELAY_STATE_IDLE;
 803289e:	70a0      	strb	r0, [r4, #2]
}
 80328a0:	e7e8      	b.n	8032874 <LmhpFragmentationProcess+0x18>
 80328a2:	bf00      	nop
 80328a4:	200049ac 	.word	0x200049ac
 80328a8:	2000352c 	.word	0x2000352c
 80328ac:	20006308 	.word	0x20006308

080328b0 <LmhpFragmentationPackageFactory>:
}
 80328b0:	4800      	ldr	r0, [pc, #0]	; (80328b4 <LmhpFragmentationPackageFactory+0x4>)
 80328b2:	4770      	bx	lr
 80328b4:	2000352c 	.word	0x2000352c

080328b8 <LmhpFragmentationGetPackageVersion>:
}
 80328b8:	2001      	movs	r0, #1
 80328ba:	4770      	bx	lr

080328bc <LmhpPackagesRegistrationInit>:
/* Private variables ---------------------------------------------------------*/

/* Exported functions ---------------------------------------------------------*/
LmHandlerErrorStatus_t LmhpPackagesRegistrationInit(void)
{
  if (LmHandlerPackageRegister(PACKAGE_ID_CLOCK_SYNC, NULL) != LORAMAC_HANDLER_SUCCESS)
 80328bc:	2100      	movs	r1, #0
{
 80328be:	b508      	push	{r3, lr}
  if (LmHandlerPackageRegister(PACKAGE_ID_CLOCK_SYNC, NULL) != LORAMAC_HANDLER_SUCCESS)
 80328c0:	2001      	movs	r0, #1
 80328c2:	f7ff f8cd 	bl	8031a60 <LmHandlerPackageRegister>
 80328c6:	4601      	mov	r1, r0
 80328c8:	b110      	cbz	r0, 80328d0 <LmhpPackagesRegistrationInit+0x14>
  {
    return LORAMAC_HANDLER_ERROR;
 80328ca:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return LORAMAC_HANDLER_ERROR;
  }

  return LORAMAC_HANDLER_SUCCESS;
}
 80328ce:	bd08      	pop	{r3, pc}
  else if (LmHandlerPackageRegister(PACKAGE_ID_REMOTE_MCAST_SETUP, NULL) != LORAMAC_HANDLER_SUCCESS)
 80328d0:	2002      	movs	r0, #2
 80328d2:	f7ff f8c5 	bl	8031a60 <LmHandlerPackageRegister>
 80328d6:	2800      	cmp	r0, #0
 80328d8:	d1f7      	bne.n	80328ca <LmhpPackagesRegistrationInit+0xe>
  else if (LmHandlerPackageRegister(PACKAGE_ID_FRAGMENTATION, (LmhpFragmentationParams_t *)&FRAG_DECODER_IF_FragmentationParams) != LORAMAC_HANDLER_SUCCESS)
 80328da:	4907      	ldr	r1, [pc, #28]	; (80328f8 <LmhpPackagesRegistrationInit+0x3c>)
 80328dc:	2003      	movs	r0, #3
 80328de:	f7ff f8bf 	bl	8031a60 <LmHandlerPackageRegister>
 80328e2:	4601      	mov	r1, r0
 80328e4:	2800      	cmp	r0, #0
 80328e6:	d1f0      	bne.n	80328ca <LmhpPackagesRegistrationInit+0xe>
  else if (LmHandlerPackageRegister(PACKAGE_ID_FIRMWARE_MANAGEMENT, NULL) != LORAMAC_HANDLER_SUCCESS)
 80328e8:	2004      	movs	r0, #4
 80328ea:	f7ff f8b9 	bl	8031a60 <LmHandlerPackageRegister>
 80328ee:	3800      	subs	r0, #0
 80328f0:	bf18      	it	ne
 80328f2:	2001      	movne	r0, #1
 80328f4:	4240      	negs	r0, r0
 80328f6:	e7ea      	b.n	80328ce <LmhpPackagesRegistrationInit+0x12>
 80328f8:	0803b960 	.word	0x0803b960

080328fc <LmhpPackagesRegister>:

LmHandlerErrorStatus_t LmhpPackagesRegister(uint8_t id, LmhPackage_t **package)
{
 80328fc:	b510      	push	{r4, lr}
  if (package == NULL)
 80328fe:	460c      	mov	r4, r1
 8032900:	b1a1      	cbz	r1, 803292c <LmhpPackagesRegister+0x30>
  {
    return LORAMAC_HANDLER_ERROR;
  }
  switch (id)
 8032902:	3801      	subs	r0, #1
 8032904:	2803      	cmp	r0, #3
 8032906:	d806      	bhi.n	8032916 <LmhpPackagesRegister+0x1a>
 8032908:	e8df f000 	tbb	[pc, r0]
 803290c:	0d0a0702 	.word	0x0d0a0702
  {
    case PACKAGE_ID_CLOCK_SYNC:
    {
      *package = LmhpClockSyncPackageFactory();
 8032910:	f7ff fa4c 	bl	8031dac <LmhpClockSyncPackageFactory>
      *package = LmhpFragmentationPackageFactory();
      break;
    }
    case PACKAGE_ID_FIRMWARE_MANAGEMENT:
    {
      *package = LmhpFirmwareManagementPackageFactory();
 8032914:	6020      	str	r0, [r4, #0]
  if (package == NULL)
 8032916:	2000      	movs	r0, #0
 8032918:	e00a      	b.n	8032930 <LmhpPackagesRegister+0x34>
      *package = LmhpRemoteMcastSetupPackageFactory();
 803291a:	f000 fb45 	bl	8032fa8 <LmhpRemoteMcastSetupPackageFactory>
 803291e:	e7f9      	b.n	8032914 <LmhpPackagesRegister+0x18>
      *package = LmhpFragmentationPackageFactory();
 8032920:	f7ff ffc6 	bl	80328b0 <LmhpFragmentationPackageFactory>
 8032924:	e7f6      	b.n	8032914 <LmhpPackagesRegister+0x18>
      *package = LmhpFirmwareManagementPackageFactory();
 8032926:	f7ff fd6f 	bl	8032408 <LmhpFirmwareManagementPackageFactory>
 803292a:	e7f3      	b.n	8032914 <LmhpPackagesRegister+0x18>
    return LORAMAC_HANDLER_ERROR;
 803292c:	f04f 30ff 	mov.w	r0, #4294967295
      break;
    }
  }

  return LORAMAC_HANDLER_SUCCESS;
}
 8032930:	bd10      	pop	{r4, pc}
	...

08032934 <LmhpRemoteMcastSetupIsInitialized>:
}

static bool LmhpRemoteMcastSetupIsInitialized( void )
{
    return LmhpRemoteMcastSetupState.Initialized;
}
 8032934:	4b01      	ldr	r3, [pc, #4]	; (803293c <LmhpRemoteMcastSetupIsInitialized+0x8>)
 8032936:	7818      	ldrb	r0, [r3, #0]
 8032938:	4770      	bx	lr
 803293a:	bf00      	nop
 803293c:	20004a38 	.word	0x20004a38

08032940 <LmhpRemoteMcastSetupIsRunning>:

static bool LmhpRemoteMcastSetupIsRunning( void )
{
    if( LmhpRemoteMcastSetupState.Initialized == false )
 8032940:	4b02      	ldr	r3, [pc, #8]	; (803294c <LmhpRemoteMcastSetupIsRunning+0xc>)
 8032942:	7818      	ldrb	r0, [r3, #0]
 8032944:	b100      	cbz	r0, 8032948 <LmhpRemoteMcastSetupIsRunning+0x8>
    {
        return false;
    }

    return LmhpRemoteMcastSetupState.IsRunning;
 8032946:	7858      	ldrb	r0, [r3, #1]
}
 8032948:	4770      	bx	lr
 803294a:	bf00      	nop
 803294c:	20004a38 	.word	0x20004a38

08032950 <LmhpRemoteMcastSetupInit>:
{
 8032950:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8032952:	4c10      	ldr	r4, [pc, #64]	; (8032994 <LmhpRemoteMcastSetupInit+0x44>)
    if( dataBuffer != NULL )
 8032954:	b1e1      	cbz	r1, 8032990 <LmhpRemoteMcastSetupInit+0x40>
        LmhpRemoteMcastSetupState.Initialized = true;
 8032956:	4620      	mov	r0, r4
        TimerInit( &SessionStartTimer, OnSessionStartTimer );
 8032958:	2500      	movs	r5, #0
        LmhpRemoteMcastSetupState.Initialized = true;
 803295a:	f240 1301 	movw	r3, #257	; 0x101
 803295e:	f820 3b08 	strh.w	r3, [r0], #8
        LmhpRemoteMcastSetupState.DataBuffer = dataBuffer;
 8032962:	6061      	str	r1, [r4, #4]
        TimerInit( &SessionStartTimer, OnSessionStartTimer );
 8032964:	4b0c      	ldr	r3, [pc, #48]	; (8032998 <LmhpRemoteMcastSetupInit+0x48>)
        LmhpRemoteMcastSetupState.DataBufferMaxSize = dataBufferMaxSize;
 8032966:	70e2      	strb	r2, [r4, #3]
        TimerInit( &SessionStartTimer, OnSessionStartTimer );
 8032968:	f04f 31ff 	mov.w	r1, #4294967295
 803296c:	462a      	mov	r2, r5
 803296e:	9500      	str	r5, [sp, #0]
 8032970:	f008 fc88 	bl	803b284 <UTIL_TIMER_Create>
        TimerInit( &SessionStopTimer, OnSessionStopTimer );
 8032974:	4b09      	ldr	r3, [pc, #36]	; (803299c <LmhpRemoteMcastSetupInit+0x4c>)
 8032976:	9500      	str	r5, [sp, #0]
 8032978:	462a      	mov	r2, r5
 803297a:	f04f 31ff 	mov.w	r1, #4294967295
 803297e:	f104 0020 	add.w	r0, r4, #32
 8032982:	f008 fc7f 	bl	803b284 <UTIL_TIMER_Create>
        McSessionData[id].McGroupData.McGroupEnabled = false;
 8032986:	2300      	movs	r3, #0
 8032988:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
}
 803298c:	b003      	add	sp, #12
 803298e:	bd30      	pop	{r4, r5, pc}
        LmhpRemoteMcastSetupState.Initialized = false;
 8032990:	8021      	strh	r1, [r4, #0]
 8032992:	e7f8      	b.n	8032986 <LmhpRemoteMcastSetupInit+0x36>
 8032994:	20004a38 	.word	0x20004a38
 8032998:	080329c5 	.word	0x080329c5
 803299c:	080329a1 	.word	0x080329a1

080329a0 <OnSessionStopTimer>:
    LmhpRemoteMcastSetupState.SessionState = REMOTE_MCAST_SETUP_SESSION_STATE_START;
    LmhpRemoteMcastSetupPackage.OnPackageProcessEvent();
}

static void OnSessionStopTimer( void *context )
{
 80329a0:	b510      	push	{r4, lr}
    TimerStop( &SessionStopTimer );
 80329a2:	4c06      	ldr	r4, [pc, #24]	; (80329bc <OnSessionStopTimer+0x1c>)
 80329a4:	f104 0020 	add.w	r0, r4, #32
 80329a8:	f008 fcca 	bl	803b340 <UTIL_TIMER_Stop>
    LmhpRemoteMcastSetupState.SessionState = REMOTE_MCAST_SETUP_SESSION_STATE_STOP;
 80329ac:	2302      	movs	r3, #2
 80329ae:	70a3      	strb	r3, [r4, #2]
    LmhpRemoteMcastSetupPackage.OnPackageProcessEvent();
 80329b0:	4b03      	ldr	r3, [pc, #12]	; (80329c0 <OnSessionStopTimer+0x20>)
}
 80329b2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    LmhpRemoteMcastSetupPackage.OnPackageProcessEvent();
 80329b6:	695b      	ldr	r3, [r3, #20]
 80329b8:	4718      	bx	r3
 80329ba:	bf00      	nop
 80329bc:	20004a38 	.word	0x20004a38
 80329c0:	20003560 	.word	0x20003560

080329c4 <OnSessionStartTimer>:
{
 80329c4:	b510      	push	{r4, lr}
    TimerStop( &SessionStartTimer );
 80329c6:	4c06      	ldr	r4, [pc, #24]	; (80329e0 <OnSessionStartTimer+0x1c>)
 80329c8:	f104 0008 	add.w	r0, r4, #8
 80329cc:	f008 fcb8 	bl	803b340 <UTIL_TIMER_Stop>
    LmhpRemoteMcastSetupState.SessionState = REMOTE_MCAST_SETUP_SESSION_STATE_START;
 80329d0:	2301      	movs	r3, #1
 80329d2:	70a3      	strb	r3, [r4, #2]
    LmhpRemoteMcastSetupPackage.OnPackageProcessEvent();
 80329d4:	4b03      	ldr	r3, [pc, #12]	; (80329e4 <OnSessionStartTimer+0x20>)
}
 80329d6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    LmhpRemoteMcastSetupPackage.OnPackageProcessEvent();
 80329da:	695b      	ldr	r3, [r3, #20]
 80329dc:	4718      	bx	r3
 80329de:	bf00      	nop
 80329e0:	20004a38 	.word	0x20004a38
 80329e4:	20003560 	.word	0x20003560

080329e8 <LmhpRemoteMcastSetupOnMcpsIndication>:
{
 80329e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if( mcpsIndication->Port != REMOTE_MCAST_SETUP_PORT )
 80329ec:	78c3      	ldrb	r3, [r0, #3]
 80329ee:	2bc8      	cmp	r3, #200	; 0xc8
{
 80329f0:	b091      	sub	sp, #68	; 0x44
 80329f2:	4682      	mov	sl, r0
    if( mcpsIndication->Port != REMOTE_MCAST_SETUP_PORT )
 80329f4:	f000 8293 	beq.w	8032f1e <LmhpRemoteMcastSetupOnMcpsIndication+0x536>
}
 80329f8:	b011      	add	sp, #68	; 0x44
 80329fa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        switch( mcpsIndication->Buffer[cmdIndex++] )
 80329fe:	f8da 0008 	ldr.w	r0, [sl, #8]
 8032a02:	5c81      	ldrb	r1, [r0, r2]
 8032a04:	1c57      	adds	r7, r2, #1
 8032a06:	b2ff      	uxtb	r7, r7
 8032a08:	2904      	cmp	r1, #4
 8032a0a:	d813      	bhi.n	8032a34 <LmhpRemoteMcastSetupOnMcpsIndication+0x4c>
 8032a0c:	e8df f011 	tbh	[pc, r1, lsl #1]
 8032a10:	009c0005 	.word	0x009c0005
 8032a14:	01a800dd 	.word	0x01a800dd
 8032a18:	01d8      	.short	0x01d8
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_PKG_VERSION_ANS;
 8032a1a:	6872      	ldr	r2, [r6, #4]
 8032a1c:	2300      	movs	r3, #0
 8032a1e:	1c61      	adds	r1, r4, #1
 8032a20:	5513      	strb	r3, [r2, r4]
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_ID;
 8032a22:	b2c9      	uxtb	r1, r1
 8032a24:	1ca3      	adds	r3, r4, #2
 8032a26:	b2db      	uxtb	r3, r3
 8032a28:	2002      	movs	r0, #2
 8032a2a:	5450      	strb	r0, [r2, r1]
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_VERSION;
 8032a2c:	2101      	movs	r1, #1
 8032a2e:	3403      	adds	r4, #3
 8032a30:	54d1      	strb	r1, [r2, r3]
 8032a32:	b2e4      	uxtb	r4, r4
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032a34:	463a      	mov	r2, r7
    while( cmdIndex < mcpsIndication->BufferSize )
 8032a36:	f89a 300c 	ldrb.w	r3, [sl, #12]
 8032a3a:	4293      	cmp	r3, r2
 8032a3c:	d8df      	bhi.n	80329fe <LmhpRemoteMcastSetupOnMcpsIndication+0x16>
    if( dataBufferIndex != 0 )
 8032a3e:	2c00      	cmp	r4, #0
 8032a40:	d0da      	beq.n	80329f8 <LmhpRemoteMcastSetupOnMcpsIndication+0x10>
        LmHandlerAppData_t appData =
 8032a42:	f88d 4021 	strb.w	r4, [sp, #33]	; 0x21
            .Buffer = LmhpRemoteMcastSetupState.DataBuffer,
 8032a46:	4cb9      	ldr	r4, [pc, #740]	; (8032d2c <LmhpRemoteMcastSetupOnMcpsIndication+0x344>)
        LmHandlerAppData_t appData =
 8032a48:	23c8      	movs	r3, #200	; 0xc8
 8032a4a:	f88d 3020 	strb.w	r3, [sp, #32]
        LmHandlerGetDutyCycleEnable( &current_dutycycle );
 8032a4e:	f10d 001f 	add.w	r0, sp, #31
        LmHandlerAppData_t appData =
 8032a52:	6863      	ldr	r3, [r4, #4]
 8032a54:	9309      	str	r3, [sp, #36]	; 0x24
        LmHandlerGetDutyCycleEnable( &current_dutycycle );
 8032a56:	f7ff f865 	bl	8031b24 <LmHandlerGetDutyCycleEnable>
        LmHandlerSetDutyCycleEnable( false );
 8032a5a:	2000      	movs	r0, #0
 8032a5c:	f7ff f86e 	bl	8031b3c <LmHandlerSetDutyCycleEnable>
        LmhpRemoteMcastSetupPackage.OnSendRequest( &appData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true );
 8032a60:	4bb3      	ldr	r3, [pc, #716]	; (8032d30 <LmhpRemoteMcastSetupOnMcpsIndication+0x348>)
 8032a62:	2200      	movs	r2, #0
 8032a64:	6a9e      	ldr	r6, [r3, #40]	; 0x28
 8032a66:	4611      	mov	r1, r2
 8032a68:	2301      	movs	r3, #1
 8032a6a:	a808      	add	r0, sp, #32
 8032a6c:	47b0      	blx	r6
        LmHandlerSetDutyCycleEnable( current_dutycycle );
 8032a6e:	f89d 001f 	ldrb.w	r0, [sp, #31]
 8032a72:	f7ff f863 	bl	8031b3c <LmHandlerSetDutyCycleEnable>
        if (id != 0xFF && id < LORAMAC_MAX_MC_CTX)
 8032a76:	2d00      	cmp	r5, #0
 8032a78:	d1be      	bne.n	80329f8 <LmhpRemoteMcastSetupOnMcpsIndication+0x10>
            MW_LOG(TS_OFF, VLEVEL_M, "ID          : %d\r\n", McSessionData[id].McGroupData.IdHeader.Fields.McGroupId);
 8032a7a:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
                MW_LOG(TS_OFF, VLEVEL_M, "-%02X",  McSessionData[id].McGroupData.McKeyEncrypted[i]);
 8032a7e:	4fad      	ldr	r7, [pc, #692]	; (8032d34 <LmhpRemoteMcastSetupOnMcpsIndication+0x34c>)
            MW_LOG(TS_OFF, VLEVEL_M, "ID          : %d\r\n", McSessionData[id].McGroupData.IdHeader.Fields.McGroupId);
 8032a80:	f003 0303 	and.w	r3, r3, #3
 8032a84:	462a      	mov	r2, r5
 8032a86:	4629      	mov	r1, r5
 8032a88:	9300      	str	r3, [sp, #0]
 8032a8a:	2002      	movs	r0, #2
 8032a8c:	4baa      	ldr	r3, [pc, #680]	; (8032d38 <LmhpRemoteMcastSetupOnMcpsIndication+0x350>)
 8032a8e:	f008 f935 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
            MW_LOG(TS_OFF, VLEVEL_M, "McAddr      : %08X\r\n", McSessionData[id].McGroupData.McAddr);
 8032a92:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8032a94:	9300      	str	r3, [sp, #0]
 8032a96:	462a      	mov	r2, r5
 8032a98:	4629      	mov	r1, r5
 8032a9a:	4ba8      	ldr	r3, [pc, #672]	; (8032d3c <LmhpRemoteMcastSetupOnMcpsIndication+0x354>)
 8032a9c:	2002      	movs	r0, #2
 8032a9e:	f008 f92d 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
            MW_LOG(TS_OFF, VLEVEL_M, "McKey       : %02X", McSessionData[id].McGroupData.McKeyEncrypted[0]);
 8032aa2:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8032aa6:	9300      	str	r3, [sp, #0]
 8032aa8:	462a      	mov	r2, r5
 8032aaa:	4629      	mov	r1, r5
 8032aac:	4ba4      	ldr	r3, [pc, #656]	; (8032d40 <LmhpRemoteMcastSetupOnMcpsIndication+0x358>)
 8032aae:	2002      	movs	r0, #2
 8032ab0:	f008 f924 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
            for ( int i = 1; i < 16; i++ )
 8032ab4:	f104 0641 	add.w	r6, r4, #65	; 0x41
 8032ab8:	2501      	movs	r5, #1
                MW_LOG(TS_OFF, VLEVEL_M, "-%02X",  McSessionData[id].McGroupData.McKeyEncrypted[i]);
 8032aba:	f816 3b01 	ldrb.w	r3, [r6], #1
 8032abe:	9300      	str	r3, [sp, #0]
 8032ac0:	2200      	movs	r2, #0
 8032ac2:	463b      	mov	r3, r7
 8032ac4:	4611      	mov	r1, r2
 8032ac6:	2002      	movs	r0, #2
            for ( int i = 1; i < 16; i++ )
 8032ac8:	3501      	adds	r5, #1
                MW_LOG(TS_OFF, VLEVEL_M, "-%02X",  McSessionData[id].McGroupData.McKeyEncrypted[i]);
 8032aca:	f008 f917 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
            for ( int i = 1; i < 16; i++ )
 8032ace:	2d10      	cmp	r5, #16
 8032ad0:	d1f3      	bne.n	8032aba <LmhpRemoteMcastSetupOnMcpsIndication+0xd2>
            MW_LOG(TS_OFF, VLEVEL_M, "\r\n");
 8032ad2:	2200      	movs	r2, #0
 8032ad4:	4611      	mov	r1, r2
 8032ad6:	4b9b      	ldr	r3, [pc, #620]	; (8032d44 <LmhpRemoteMcastSetupOnMcpsIndication+0x35c>)
 8032ad8:	2002      	movs	r0, #2
 8032ada:	f008 f90f 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
            MW_LOG(TS_OFF, VLEVEL_M, "McFCountMin : %u\r\n",  McSessionData[id].McGroupData.McFCountMin);
 8032ade:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8032ae0:	9300      	str	r3, [sp, #0]
 8032ae2:	2200      	movs	r2, #0
 8032ae4:	4611      	mov	r1, r2
 8032ae6:	4b98      	ldr	r3, [pc, #608]	; (8032d48 <LmhpRemoteMcastSetupOnMcpsIndication+0x360>)
 8032ae8:	2002      	movs	r0, #2
 8032aea:	f008 f907 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
            MW_LOG(TS_OFF, VLEVEL_M, "McFCountMax : %u\r\n",  McSessionData[id].McGroupData.McFCountMax);
 8032aee:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8032af0:	9300      	str	r3, [sp, #0]
 8032af2:	2200      	movs	r2, #0
 8032af4:	4611      	mov	r1, r2
 8032af6:	4b95      	ldr	r3, [pc, #596]	; (8032d4c <LmhpRemoteMcastSetupOnMcpsIndication+0x364>)
 8032af8:	2002      	movs	r0, #2
 8032afa:	f008 f8ff 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
            MW_LOG(TS_OFF, VLEVEL_M, "SessionTime : %u\r\n",  McSessionData[id].SessionTime);
 8032afe:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8032b00:	9300      	str	r3, [sp, #0]
 8032b02:	2200      	movs	r2, #0
 8032b04:	4611      	mov	r1, r2
 8032b06:	4b92      	ldr	r3, [pc, #584]	; (8032d50 <LmhpRemoteMcastSetupOnMcpsIndication+0x368>)
 8032b08:	2002      	movs	r0, #2
 8032b0a:	f008 f8f7 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
            MW_LOG(TS_OFF, VLEVEL_M, "SessionTimeT: %d s\r\n", (1 << McSessionData[id].SessionTimeout));
 8032b0e:	f894 2060 	ldrb.w	r2, [r4, #96]	; 0x60
 8032b12:	2301      	movs	r3, #1
 8032b14:	4093      	lsls	r3, r2
 8032b16:	2200      	movs	r2, #0
 8032b18:	9300      	str	r3, [sp, #0]
 8032b1a:	4611      	mov	r1, r2
 8032b1c:	4b8d      	ldr	r3, [pc, #564]	; (8032d54 <LmhpRemoteMcastSetupOnMcpsIndication+0x36c>)
 8032b1e:	2002      	movs	r0, #2
 8032b20:	f008 f8ec 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
            MW_LOG(TS_OFF, VLEVEL_M, "Rx Freq     : %u\r\n", McSessionData[id].RxParams.ClassC.Frequency);
 8032b24:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8032b26:	9300      	str	r3, [sp, #0]
 8032b28:	2200      	movs	r2, #0
 8032b2a:	4611      	mov	r1, r2
 8032b2c:	4b8a      	ldr	r3, [pc, #552]	; (8032d58 <LmhpRemoteMcastSetupOnMcpsIndication+0x370>)
 8032b2e:	2002      	movs	r0, #2
 8032b30:	f008 f8e4 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
            MW_LOG(TS_OFF, VLEVEL_M, "Rx DR       : DR_%d\r\n", McSessionData[id].RxParams.ClassC.Datarate);
 8032b34:	f994 3068 	ldrsb.w	r3, [r4, #104]	; 0x68
 8032b38:	9300      	str	r3, [sp, #0]
 8032b3a:	2200      	movs	r2, #0
 8032b3c:	4b87      	ldr	r3, [pc, #540]	; (8032d5c <LmhpRemoteMcastSetupOnMcpsIndication+0x374>)
 8032b3e:	4611      	mov	r1, r2
 8032b40:	2002      	movs	r0, #2
 8032b42:	f008 f8db 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
 8032b46:	e757      	b.n	80329f8 <LmhpRemoteMcastSetupOnMcpsIndication+0x10>
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_STATUS_ANS;
 8032b48:	6875      	ldr	r5, [r6, #4]
                uint8_t reqGroupMask = mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8032b4a:	5dc7      	ldrb	r7, [r0, r7]
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_STATUS_ANS;
 8032b4c:	2301      	movs	r3, #1
 8032b4e:	552b      	strb	r3, [r5, r4]
                uint8_t reqGroupMask = mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8032b50:	3202      	adds	r2, #2
                for (id = 0; id < LORAMAC_MAX_MC_CTX; id++)
 8032b52:	2300      	movs	r3, #0
                dataBufferIndex++;
 8032b54:	3402      	adds	r4, #2
                uint8_t reqGroupMask = mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8032b56:	b2d2      	uxtb	r2, r2
                dataBufferIndex++;
 8032b58:	b2e4      	uxtb	r4, r4
                uint8_t AnsGroupMask = 0x00;
 8032b5a:	469c      	mov	ip, r3
                for (id = 0; id < LORAMAC_MAX_MC_CTX; id++)
 8032b5c:	4618      	mov	r0, r3
 8032b5e:	f007 0701 	and.w	r7, r7, #1
                    if( McSessionData[id].McGroupData.McGroupEnabled )
 8032b62:	f896 e038 	ldrb.w	lr, [r6, #56]	; 0x38
                for (id = 0; id < LORAMAC_MAX_MC_CTX; id++)
 8032b66:	b140      	cbz	r0, 8032b7a <LmhpRemoteMcastSetupOnMcpsIndication+0x192>
                LmhpRemoteMcastSetupState.DataBuffer[1] = (nbAvailableGroups & 0x07) << 4 | (AnsGroupMask & 0x0F);
 8032b68:	011b      	lsls	r3, r3, #4
 8032b6a:	f003 0370 	and.w	r3, r3, #112	; 0x70
 8032b6e:	ea43 030c 	orr.w	r3, r3, ip
 8032b72:	706b      	strb	r3, [r5, #1]
                uint8_t reqGroupMask = mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8032b74:	4617      	mov	r7, r2
                break;
 8032b76:	460d      	mov	r5, r1
 8032b78:	e75c      	b.n	8032a34 <LmhpRemoteMcastSetupOnMcpsIndication+0x4c>
                    if( McSessionData[id].McGroupData.McGroupEnabled )
 8032b7a:	f1be 0f00 	cmp.w	lr, #0
 8032b7e:	d0f3      	beq.n	8032b68 <LmhpRemoteMcastSetupOnMcpsIndication+0x180>
                        if( ( reqGroupMask & ( 1 << id ) ) != 0 )
 8032b80:	b307      	cbz	r7, 8032bc4 <LmhpRemoteMcastSetupOnMcpsIndication+0x1dc>
                            LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = id;
 8032b82:	5528      	strb	r0, [r5, r4]
 8032b84:	f104 0c01 	add.w	ip, r4, #1
                            LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (McSessionData[id].McGroupData.McAddr >> 0) & 0xFF;
 8032b88:	fa5f fc8c 	uxtb.w	ip, ip
 8032b8c:	6bf0      	ldr	r0, [r6, #60]	; 0x3c
 8032b8e:	f805 000c 	strb.w	r0, [r5, ip]
 8032b92:	f104 0c02 	add.w	ip, r4, #2
                            LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (McSessionData[id].McGroupData.McAddr >> 8) & 0xFF;
 8032b96:	6bf0      	ldr	r0, [r6, #60]	; 0x3c
 8032b98:	fa5f fc8c 	uxtb.w	ip, ip
 8032b9c:	0a00      	lsrs	r0, r0, #8
 8032b9e:	f805 000c 	strb.w	r0, [r5, ip]
 8032ba2:	f104 0c03 	add.w	ip, r4, #3
                            LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (McSessionData[id].McGroupData.McAddr >> 16) & 0xFF;
 8032ba6:	fa5f fc8c 	uxtb.w	ip, ip
 8032baa:	f8b6 e03e 	ldrh.w	lr, [r6, #62]	; 0x3e
 8032bae:	f805 e00c 	strb.w	lr, [r5, ip]
 8032bb2:	1d20      	adds	r0, r4, #4
 8032bb4:	b2c0      	uxtb	r0, r0
                            LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (McSessionData[id].McGroupData.McAddr >> 24) & 0xFF;
 8032bb6:	f896 c03f 	ldrb.w	ip, [r6, #63]	; 0x3f
 8032bba:	f805 c000 	strb.w	ip, [r5, r0]
 8032bbe:	3405      	adds	r4, #5
 8032bc0:	b2e4      	uxtb	r4, r4
                            AnsGroupMask |= (1 << id);
 8032bc2:	46bc      	mov	ip, r7
 8032bc4:	3301      	adds	r3, #1
 8032bc6:	4608      	mov	r0, r1
 8032bc8:	e7cb      	b.n	8032b62 <LmhpRemoteMcastSetupOnMcpsIndication+0x17a>
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032bca:	5dc5      	ldrb	r5, [r0, r7]
                McSessionData[id].McGroupData.IdHeader.Value = id;
 8032bcc:	f04f 0c34 	mov.w	ip, #52	; 0x34
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032bd0:	f005 0503 	and.w	r5, r5, #3
                McSessionData[id].McGroupData.IdHeader.Value = id;
 8032bd4:	fb0c 6705 	mla	r7, ip, r5, r6
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032bd8:	1c93      	adds	r3, r2, #2
                McSessionData[id].McGroupData.McAddr =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032bda:	b2db      	uxtb	r3, r3
                McSessionData[id].McGroupData.IdHeader.Value = id;
 8032bdc:	f887 5039 	strb.w	r5, [r7, #57]	; 0x39
                McSessionData[id].McGroupData.McAddr =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032be0:	5cc1      	ldrb	r1, [r0, r3]
 8032be2:	63f9      	str	r1, [r7, #60]	; 0x3c
 8032be4:	1cd3      	adds	r3, r2, #3
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032be6:	b2db      	uxtb	r3, r3
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032be8:	f102 0e05 	add.w	lr, r2, #5
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032bec:	5cc3      	ldrb	r3, [r0, r3]
 8032bee:	eb01 2103 	add.w	r1, r1, r3, lsl #8
 8032bf2:	1d13      	adds	r3, r2, #4
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032bf4:	b2db      	uxtb	r3, r3
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032bf6:	63f9      	str	r1, [r7, #60]	; 0x3c
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032bf8:	5cc3      	ldrb	r3, [r0, r3]
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032bfa:	fa5f fe8e 	uxtb.w	lr, lr
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032bfe:	eb01 4103 	add.w	r1, r1, r3, lsl #16
 8032c02:	63f9      	str	r1, [r7, #60]	; 0x3c
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032c04:	f810 e00e 	ldrb.w	lr, [r0, lr]
 8032c08:	fb0c bc05 	mla	ip, ip, r5, fp
 8032c0c:	eb01 610e 	add.w	r1, r1, lr, lsl #24
 8032c10:	63f9      	str	r1, [r7, #60]	; 0x3c
 8032c12:	9103      	str	r1, [sp, #12]
 8032c14:	f10c 0108 	add.w	r1, ip, #8
 8032c18:	1d93      	adds	r3, r2, #6
 8032c1a:	9104      	str	r1, [sp, #16]
 8032c1c:	460f      	mov	r7, r1
 8032c1e:	f102 0116 	add.w	r1, r2, #22
 8032c22:	b2db      	uxtb	r3, r3
                for( int8_t i = 0; i < 16; i++ )
 8032c24:	fa5f fe81 	uxtb.w	lr, r1
                    McSessionData[id].McGroupData.McKeyEncrypted[i] = mcpsIndication->Buffer[cmdIndex++];
 8032c28:	469c      	mov	ip, r3
 8032c2a:	3301      	adds	r3, #1
 8032c2c:	b2db      	uxtb	r3, r3
 8032c2e:	f810 c00c 	ldrb.w	ip, [r0, ip]
 8032c32:	f807 cb01 	strb.w	ip, [r7], #1
                for( int8_t i = 0; i < 16; i++ )
 8032c36:	4573      	cmp	r3, lr
 8032c38:	d1f6      	bne.n	8032c28 <LmhpRemoteMcastSetupOnMcpsIndication+0x240>
                McSessionData[id].McGroupData.McFCountMin =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032c3a:	b2c9      	uxtb	r1, r1
 8032c3c:	f04f 0834 	mov.w	r8, #52	; 0x34
 8032c40:	5c43      	ldrb	r3, [r0, r1]
 8032c42:	fb08 6805 	mla	r8, r8, r5, r6
 8032c46:	f102 0117 	add.w	r1, r2, #23
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032c4a:	b2c9      	uxtb	r1, r1
                McSessionData[id].McGroupData.McFCountMin =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032c4c:	f8c8 3050 	str.w	r3, [r8, #80]	; 0x50
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032c50:	5c41      	ldrb	r1, [r0, r1]
 8032c52:	eb03 2301 	add.w	r3, r3, r1, lsl #8
 8032c56:	f102 0118 	add.w	r1, r2, #24
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032c5a:	b2c9      	uxtb	r1, r1
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032c5c:	f8c8 3050 	str.w	r3, [r8, #80]	; 0x50
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032c60:	5c41      	ldrb	r1, [r0, r1]
 8032c62:	eb03 4301 	add.w	r3, r3, r1, lsl #16
 8032c66:	f102 0119 	add.w	r1, r2, #25
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032c6a:	b2c9      	uxtb	r1, r1
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032c6c:	f8c8 3050 	str.w	r3, [r8, #80]	; 0x50
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032c70:	5c41      	ldrb	r1, [r0, r1]
 8032c72:	eb03 6301 	add.w	r3, r3, r1, lsl #24
 8032c76:	f102 011a 	add.w	r1, r2, #26
                McSessionData[id].McGroupData.McFCountMax =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032c7a:	b2c9      	uxtb	r1, r1
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032c7c:	f8c8 3050 	str.w	r3, [r8, #80]	; 0x50
                McSessionData[id].McGroupData.McFCountMax =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032c80:	f102 071b 	add.w	r7, r2, #27
 8032c84:	5c41      	ldrb	r1, [r0, r1]
 8032c86:	f8c8 1054 	str.w	r1, [r8, #84]	; 0x54
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032c8a:	b2ff      	uxtb	r7, r7
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032c8c:	9305      	str	r3, [sp, #20]
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032c8e:	f810 9007 	ldrb.w	r9, [r0, r7]
 8032c92:	f102 071c 	add.w	r7, r2, #28
 8032c96:	eb01 2109 	add.w	r1, r1, r9, lsl #8
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032c9a:	b2ff      	uxtb	r7, r7
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032c9c:	f8c8 1054 	str.w	r1, [r8, #84]	; 0x54
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032ca0:	f810 9007 	ldrb.w	r9, [r0, r7]
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032ca4:	f102 071e 	add.w	r7, r2, #30
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032ca8:	321d      	adds	r2, #29
 8032caa:	eb01 4109 	add.w	r1, r1, r9, lsl #16
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032cae:	b2d2      	uxtb	r2, r2
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032cb0:	f8c8 1054 	str.w	r1, [r8, #84]	; 0x54
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032cb4:	f810 9002 	ldrb.w	r9, [r0, r2]
 8032cb8:	eb01 6909 	add.w	r9, r1, r9, lsl #24
                McChannelParams_t channel =
 8032cbc:	2214      	movs	r2, #20
 8032cbe:	2100      	movs	r1, #0
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032cc0:	f8c8 9054 	str.w	r9, [r8, #84]	; 0x54
                McChannelParams_t channel =
 8032cc4:	a80b      	add	r0, sp, #44	; 0x2c
 8032cc6:	f008 fd5f 	bl	803b788 <memset>
 8032cca:	f240 2201 	movw	r2, #513	; 0x201
 8032cce:	f8ad 2020 	strh.w	r2, [sp, #32]
 8032cd2:	2201      	movs	r2, #1
 8032cd4:	9b03      	ldr	r3, [sp, #12]
 8032cd6:	f88d 2022 	strb.w	r2, [sp, #34]	; 0x22
                    .GroupID = ( AddressIdentifier_t )McSessionData[id].McGroupData.IdHeader.Fields.McGroupId,
 8032cda:	f898 1039 	ldrb.w	r1, [r8, #57]	; 0x39
                McChannelParams_t channel =
 8032cde:	9309      	str	r3, [sp, #36]	; 0x24
 8032ce0:	9b04      	ldr	r3, [sp, #16]
 8032ce2:	930a      	str	r3, [sp, #40]	; 0x28
 8032ce4:	9b05      	ldr	r3, [sp, #20]
                    .GroupID = ( AddressIdentifier_t )McSessionData[id].McGroupData.IdHeader.Fields.McGroupId,
 8032ce6:	f3c1 0101 	ubfx	r1, r1, #0, #2
                if( LoRaMacMcChannelSetup( &channel ) == LORAMAC_STATUS_OK )
 8032cea:	a808      	add	r0, sp, #32
                McChannelParams_t channel =
 8032cec:	e9cd 390c 	strd	r3, r9, [sp, #48]	; 0x30
 8032cf0:	f88d 1023 	strb.w	r1, [sp, #35]	; 0x23
                if( LoRaMacMcChannelSetup( &channel ) == LORAMAC_STATUS_OK )
 8032cf4:	f002 fa8c 	bl	8035210 <LoRaMacMcChannelSetup>
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032cf8:	b2ff      	uxtb	r7, r7
                if( LoRaMacMcChannelSetup( &channel ) == LORAMAC_STATUS_OK )
 8032cfa:	2201      	movs	r2, #1
 8032cfc:	b998      	cbnz	r0, 8032d26 <LmhpRemoteMcastSetupOnMcpsIndication+0x33e>
                    McSessionData[id].McGroupData.McGroupEnabled = true;
 8032cfe:	f888 2038 	strb.w	r2, [r8, #56]	; 0x38
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_SETUP_ANS;
 8032d02:	6871      	ldr	r1, [r6, #4]
 8032d04:	2302      	movs	r3, #2
 8032d06:	550b      	strb	r3, [r1, r4]
 8032d08:	1c62      	adds	r2, r4, #1
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = ( idError << 2 ) | McSessionData[id].McGroupData.IdHeader.Fields.McGroupId;
 8032d0a:	441c      	add	r4, r3
 8032d0c:	2334      	movs	r3, #52	; 0x34
 8032d0e:	fb03 6305 	mla	r3, r3, r5, r6
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_SETUP_ANS;
 8032d12:	b2d2      	uxtb	r2, r2
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = ( idError << 2 ) | McSessionData[id].McGroupData.IdHeader.Fields.McGroupId;
 8032d14:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 8032d18:	f3c3 0301 	ubfx	r3, r3, #0, #2
 8032d1c:	ea43 0080 	orr.w	r0, r3, r0, lsl #2
 8032d20:	5488      	strb	r0, [r1, r2]
 8032d22:	b2e4      	uxtb	r4, r4
                break;
 8032d24:	e686      	b.n	8032a34 <LmhpRemoteMcastSetupOnMcpsIndication+0x4c>
                uint8_t idError = 0x01; // One bit value
 8032d26:	4610      	mov	r0, r2
 8032d28:	e7eb      	b.n	8032d02 <LmhpRemoteMcastSetupOnMcpsIndication+0x31a>
 8032d2a:	bf00      	nop
 8032d2c:	20004a38 	.word	0x20004a38
 8032d30:	20003560 	.word	0x20003560
 8032d34:	0803c2ea 	.word	0x0803c2ea
 8032d38:	0803c2af 	.word	0x0803c2af
 8032d3c:	0803c2c2 	.word	0x0803c2c2
 8032d40:	0803c2d7 	.word	0x0803c2d7
 8032d44:	0803c141 	.word	0x0803c141
 8032d48:	0803c2f0 	.word	0x0803c2f0
 8032d4c:	0803c303 	.word	0x0803c303
 8032d50:	0803c316 	.word	0x0803c316
 8032d54:	0803c329 	.word	0x0803c329
 8032d58:	0803c33e 	.word	0x0803c33e
 8032d5c:	0803c351 	.word	0x0803c351
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032d60:	5dc5      	ldrb	r5, [r0, r7]
                McSessionData[id].McGroupData.IdHeader.Value = 0;
 8032d62:	2034      	movs	r0, #52	; 0x34
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032d64:	f005 0503 	and.w	r5, r5, #3
                McSessionData[id].McGroupData.IdHeader.Value = 0;
 8032d68:	fb00 6705 	mla	r7, r0, r5, r6
 8032d6c:	f04f 0900 	mov.w	r9, #0
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032d70:	3202      	adds	r2, #2
                UTIL_MEM_set_8( McSessionData[id].McGroupData.McKeyEncrypted, 0x00, 16 );
 8032d72:	fb00 b005 	mla	r0, r0, r5, fp
                McSessionData[id].McGroupData.IdHeader.Value = 0;
 8032d76:	f887 9039 	strb.w	r9, [r7, #57]	; 0x39
                McSessionData[id].McGroupData.McAddr = 0;
 8032d7a:	f8c7 903c 	str.w	r9, [r7, #60]	; 0x3c
                UTIL_MEM_set_8( McSessionData[id].McGroupData.McKeyEncrypted, 0x00, 16 );
 8032d7e:	4649      	mov	r1, r9
 8032d80:	3008      	adds	r0, #8
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032d82:	fa5f f882 	uxtb.w	r8, r2
                UTIL_MEM_set_8( McSessionData[id].McGroupData.McKeyEncrypted, 0x00, 16 );
 8032d86:	2210      	movs	r2, #16
 8032d88:	f008 f8ca 	bl	803af20 <UTIL_MEM_set_8>
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_DELETE_ANS;
 8032d8c:	6873      	ldr	r3, [r6, #4]
 8032d8e:	2203      	movs	r2, #3
                McSessionData[id].McGroupData.McFCountMax = 0;
 8032d90:	e9c7 9914 	strd	r9, r9, [r7, #80]	; 0x50
                if( LoRaMacMcChannelDelete( ( AddressIdentifier_t )id ) != LORAMAC_STATUS_OK )
 8032d94:	4628      	mov	r0, r5
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_DELETE_ANS;
 8032d96:	f104 0901 	add.w	r9, r4, #1
 8032d9a:	551a      	strb	r2, [r3, r4]
 8032d9c:	fa5f f989 	uxtb.w	r9, r9
                if( LoRaMacMcChannelDelete( ( AddressIdentifier_t )id ) != LORAMAC_STATUS_OK )
 8032da0:	f002 fa84 	bl	80352ac <LoRaMacMcChannelDelete>
 8032da4:	b140      	cbz	r0, 8032db8 <LmhpRemoteMcastSetupOnMcpsIndication+0x3d0>
                    status |= 0x04; // McGroupUndefined bit set
 8032da6:	f045 0304 	orr.w	r3, r5, #4
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = status;
 8032daa:	6872      	ldr	r2, [r6, #4]
 8032dac:	3402      	adds	r4, #2
 8032dae:	f802 3009 	strb.w	r3, [r2, r9]
 8032db2:	b2e4      	uxtb	r4, r4
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032db4:	4647      	mov	r7, r8
                break;
 8032db6:	e63d      	b.n	8032a34 <LmhpRemoteMcastSetupOnMcpsIndication+0x4c>
                    McSessionData[id].McGroupData.McGroupEnabled = false;
 8032db8:	f887 0038 	strb.w	r0, [r7, #56]	; 0x38
                status = id;
 8032dbc:	462b      	mov	r3, r5
 8032dbe:	e7f4      	b.n	8032daa <LmhpRemoteMcastSetupOnMcpsIndication+0x3c2>
                uint8_t status = 0x00;
 8032dc0:	f04f 0300 	mov.w	r3, #0
 8032dc4:	f88d 301f 	strb.w	r3, [sp, #31]
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032dc8:	5dc5      	ldrb	r5, [r0, r7]
 8032dca:	1c93      	adds	r3, r2, #2
 8032dcc:	f005 0503 	and.w	r5, r5, #3
                McSessionData[id].SessionTime =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032dd0:	b2db      	uxtb	r3, r3
 8032dd2:	2134      	movs	r1, #52	; 0x34
 8032dd4:	fb01 6805 	mla	r8, r1, r5, r6
 8032dd8:	f102 0c03 	add.w	ip, r2, #3
 8032ddc:	5cc7      	ldrb	r7, [r0, r3]
 8032dde:	f8c8 705c 	str.w	r7, [r8, #92]	; 0x5c
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032de2:	fa5f fc8c 	uxtb.w	ip, ip
                McSessionData[id].SessionTime += UNIX_GPS_EPOCH_OFFSET;
 8032de6:	4b51      	ldr	r3, [pc, #324]	; (8032f2c <LmhpRemoteMcastSetupOnMcpsIndication+0x544>)
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032de8:	f810 c00c 	ldrb.w	ip, [r0, ip]
 8032dec:	eb07 270c 	add.w	r7, r7, ip, lsl #8
 8032df0:	f102 0c04 	add.w	ip, r2, #4
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032df4:	fa5f fc8c 	uxtb.w	ip, ip
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032df8:	f8c8 705c 	str.w	r7, [r8, #92]	; 0x5c
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032dfc:	f810 c00c 	ldrb.w	ip, [r0, ip]
 8032e00:	eb07 470c 	add.w	r7, r7, ip, lsl #16
 8032e04:	f102 0c05 	add.w	ip, r2, #5
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032e08:	fa5f fc8c 	uxtb.w	ip, ip
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032e0c:	f8c8 705c 	str.w	r7, [r8, #92]	; 0x5c
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032e10:	f810 c00c 	ldrb.w	ip, [r0, ip]
                McSessionData[id].SessionTime += UNIX_GPS_EPOCH_OFFSET;
 8032e14:	eb03 6c0c 	add.w	ip, r3, ip, lsl #24
 8032e18:	4467      	add	r7, ip
 8032e1a:	f8c8 705c 	str.w	r7, [r8, #92]	; 0x5c
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032e1e:	1d97      	adds	r7, r2, #6
                McSessionData[id].SessionTimeout =  mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8032e20:	b2ff      	uxtb	r7, r7
                McSessionData[id].RxParams.ClassC.Frequency =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032e22:	f102 0c08 	add.w	ip, r2, #8
                McSessionData[id].SessionTimeout =  mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8032e26:	5dc7      	ldrb	r7, [r0, r7]
 8032e28:	f007 070f 	and.w	r7, r7, #15
 8032e2c:	f888 7060 	strb.w	r7, [r8, #96]	; 0x60
 8032e30:	1dd7      	adds	r7, r2, #7
                McSessionData[id].RxParams.ClassC.Frequency =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032e32:	b2ff      	uxtb	r7, r7
                McSessionData[id].RxParams.ClassC.Frequency |= ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032e34:	fa5f fc8c 	uxtb.w	ip, ip
                McSessionData[id].RxParams.ClassC.Frequency =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032e38:	5dc7      	ldrb	r7, [r0, r7]
 8032e3a:	f8c8 7064 	str.w	r7, [r8, #100]	; 0x64
                McSessionData[id].RxParams.ClassC.Frequency |= ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032e3e:	f810 c00c 	ldrb.w	ip, [r0, ip]
 8032e42:	ea47 270c 	orr.w	r7, r7, ip, lsl #8
 8032e46:	f102 0c09 	add.w	ip, r2, #9
                McSessionData[id].RxParams.ClassC.Frequency |= ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032e4a:	fa5f fc8c 	uxtb.w	ip, ip
                McSessionData[id].RxParams.ClassC.Frequency |= ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032e4e:	f8c8 7064 	str.w	r7, [r8, #100]	; 0x64
                McSessionData[id].RxParams.ClassC.Frequency |= ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032e52:	f810 c00c 	ldrb.w	ip, [r0, ip]
 8032e56:	ea47 470c 	orr.w	r7, r7, ip, lsl #16
                McSessionData[id].RxParams.ClassC.Frequency *= 100;
 8032e5a:	f04f 0c64 	mov.w	ip, #100	; 0x64
 8032e5e:	fb0c f707 	mul.w	r7, ip, r7
 8032e62:	f8c8 7064 	str.w	r7, [r8, #100]	; 0x64
                McSessionData[id].RxParams.ClassC.Datarate = mcpsIndication->Buffer[cmdIndex++];
 8032e66:	f102 070b 	add.w	r7, r2, #11
                McSessionData[id].RxParams.ClassC.Frequency |= ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032e6a:	320a      	adds	r2, #10
                McSessionData[id].RxParams.ClassC.Datarate = mcpsIndication->Buffer[cmdIndex++];
 8032e6c:	b2d2      	uxtb	r2, r2
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_CLASS_C_SESSION_ANS;
 8032e6e:	f104 0901 	add.w	r9, r4, #1
                McSessionData[id].RxParams.ClassC.Datarate = mcpsIndication->Buffer[cmdIndex++];
 8032e72:	5c82      	ldrb	r2, [r0, r2]
 8032e74:	f888 2068 	strb.w	r2, [r8, #104]	; 0x68
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_CLASS_C_SESSION_ANS;
 8032e78:	6872      	ldr	r2, [r6, #4]
 8032e7a:	2004      	movs	r0, #4
                if( LoRaMacMcChannelSetupRxParams( ( AddressIdentifier_t )id, &McSessionData[id].RxParams, &status ) == LORAMAC_STATUS_OK )
 8032e7c:	fb01 b105 	mla	r1, r1, r5, fp
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_CLASS_C_SESSION_ANS;
 8032e80:	5510      	strb	r0, [r2, r4]
 8032e82:	fa5f f389 	uxtb.w	r3, r9
                if( LoRaMacMcChannelSetupRxParams( ( AddressIdentifier_t )id, &McSessionData[id].RxParams, &status ) == LORAMAC_STATUS_OK )
 8032e86:	f10d 021f 	add.w	r2, sp, #31
 8032e8a:	312c      	adds	r1, #44	; 0x2c
 8032e8c:	4628      	mov	r0, r5
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_CLASS_C_SESSION_ANS;
 8032e8e:	9303      	str	r3, [sp, #12]
                if( LoRaMacMcChannelSetupRxParams( ( AddressIdentifier_t )id, &McSessionData[id].RxParams, &status ) == LORAMAC_STATUS_OK )
 8032e90:	f002 fa3a 	bl	8035308 <LoRaMacMcChannelSetupRxParams>
                McSessionData[id].RxParams.ClassC.Datarate = mcpsIndication->Buffer[cmdIndex++];
 8032e94:	b2ff      	uxtb	r7, r7
                if( LoRaMacMcChannelSetupRxParams( ( AddressIdentifier_t )id, &McSessionData[id].RxParams, &status ) == LORAMAC_STATUS_OK )
 8032e96:	4681      	mov	r9, r0
 8032e98:	2800      	cmp	r0, #0
 8032e9a:	d13d      	bne.n	8032f18 <LmhpRemoteMcastSetupOnMcpsIndication+0x530>
                    curTime = SysTimeGet( );
 8032e9c:	a808      	add	r0, sp, #32
 8032e9e:	f008 f961 	bl	803b164 <SysTimeGet>
                    timeToSessionStart = McSessionData[id].SessionTime - curTime.Seconds;
 8032ea2:	f8d8 105c 	ldr.w	r1, [r8, #92]	; 0x5c
 8032ea6:	9b08      	ldr	r3, [sp, #32]
 8032ea8:	eba1 0803 	sub.w	r8, r1, r3
                    if( timeToSessionStart > 0 )
 8032eac:	f1b8 0f00 	cmp.w	r8, #0
 8032eb0:	dd2b      	ble.n	8032f0a <LmhpRemoteMcastSetupOnMcpsIndication+0x522>
                        TimerSetValue( &SessionStartTimer, timeToSessionStart * 1000 );
 8032eb2:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8032eb6:	fb01 f108 	mul.w	r1, r1, r8
 8032eba:	481d      	ldr	r0, [pc, #116]	; (8032f30 <LmhpRemoteMcastSetupOnMcpsIndication+0x548>)
 8032ebc:	9104      	str	r1, [sp, #16]
 8032ebe:	f008 fac9 	bl	803b454 <UTIL_TIMER_SetPeriod>
                        TimerStart( &SessionStartTimer );
 8032ec2:	481b      	ldr	r0, [pc, #108]	; (8032f30 <LmhpRemoteMcastSetupOnMcpsIndication+0x548>)
 8032ec4:	f008 fa8c 	bl	803b3e0 <UTIL_TIMER_Start>
                        MW_LOG(TS_OFF, VLEVEL_M, "Time2SessionStart: %d ms\r\n", timeToSessionStart * 1000);
 8032ec8:	9904      	ldr	r1, [sp, #16]
 8032eca:	9100      	str	r1, [sp, #0]
 8032ecc:	4b19      	ldr	r3, [pc, #100]	; (8032f34 <LmhpRemoteMcastSetupOnMcpsIndication+0x54c>)
 8032ece:	464a      	mov	r2, r9
 8032ed0:	4649      	mov	r1, r9
 8032ed2:	2002      	movs	r0, #2
 8032ed4:	f007 ff12 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = status;
 8032ed8:	6872      	ldr	r2, [r6, #4]
 8032eda:	f89d 101f 	ldrb.w	r1, [sp, #31]
 8032ede:	9803      	ldr	r0, [sp, #12]
 8032ee0:	1ca3      	adds	r3, r4, #2
 8032ee2:	5411      	strb	r1, [r2, r0]
 8032ee4:	b2db      	uxtb	r3, r3
                if( status == 0x00 )
 8032ee6:	b971      	cbnz	r1, 8032f06 <LmhpRemoteMcastSetupOnMcpsIndication+0x51e>
                    LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (timeToSessionStart >> 0) & 0xFF;
 8032ee8:	f802 8003 	strb.w	r8, [r2, r3]
 8032eec:	1ce3      	adds	r3, r4, #3
                    LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (timeToSessionStart >> 8) & 0xFF;
 8032eee:	b2db      	uxtb	r3, r3
 8032ef0:	ea4f 2128 	mov.w	r1, r8, asr #8
 8032ef4:	54d1      	strb	r1, [r2, r3]
                    LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (timeToSessionStart >> 16) & 0xFF;
 8032ef6:	1d63      	adds	r3, r4, #5
                    LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (timeToSessionStart >> 8) & 0xFF;
 8032ef8:	3404      	adds	r4, #4
                    LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (timeToSessionStart >> 16) & 0xFF;
 8032efa:	b2e4      	uxtb	r4, r4
 8032efc:	ea4f 4828 	mov.w	r8, r8, asr #16
 8032f00:	f802 8004 	strb.w	r8, [r2, r4]
 8032f04:	b2db      	uxtb	r3, r3
                break;
 8032f06:	461c      	mov	r4, r3
 8032f08:	e594      	b.n	8032a34 <LmhpRemoteMcastSetupOnMcpsIndication+0x4c>
                        status |= 0x10;
 8032f0a:	f89d 301f 	ldrb.w	r3, [sp, #31]
 8032f0e:	f043 0310 	orr.w	r3, r3, #16
 8032f12:	f88d 301f 	strb.w	r3, [sp, #31]
 8032f16:	e7df      	b.n	8032ed8 <LmhpRemoteMcastSetupOnMcpsIndication+0x4f0>
                int32_t timeToSessionStart = 0;
 8032f18:	f04f 0800 	mov.w	r8, #0
 8032f1c:	e7dc      	b.n	8032ed8 <LmhpRemoteMcastSetupOnMcpsIndication+0x4f0>
                McSessionData[id].SessionTime =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032f1e:	4e06      	ldr	r6, [pc, #24]	; (8032f38 <LmhpRemoteMcastSetupOnMcpsIndication+0x550>)
    uint8_t dataBufferIndex = 0;
 8032f20:	2400      	movs	r4, #0
    uint8_t id = 0xFF;
 8032f22:	25ff      	movs	r5, #255	; 0xff
    uint8_t cmdIndex = 0;
 8032f24:	4622      	mov	r2, r4
                if( LoRaMacMcChannelSetupRxParams( ( AddressIdentifier_t )id, &McSessionData[id].RxParams, &status ) == LORAMAC_STATUS_OK )
 8032f26:	f106 0b38 	add.w	fp, r6, #56	; 0x38
 8032f2a:	e584      	b.n	8032a36 <LmhpRemoteMcastSetupOnMcpsIndication+0x4e>
 8032f2c:	12d53d80 	.word	0x12d53d80
 8032f30:	20004a40 	.word	0x20004a40
 8032f34:	0803c294 	.word	0x0803c294
 8032f38:	20004a38 	.word	0x20004a38

08032f3c <LmhpRemoteMcastSetupProcess>:
{
 8032f3c:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8032f3e:	f3ef 8210 	mrs	r2, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8032f42:	b672      	cpsid	i
    state = LmhpRemoteMcastSetupState.SessionState;
 8032f44:	4c17      	ldr	r4, [pc, #92]	; (8032fa4 <LmhpRemoteMcastSetupProcess+0x68>)
 8032f46:	78a3      	ldrb	r3, [r4, #2]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8032f48:	f382 8810 	msr	PRIMASK, r2
    switch( state )
 8032f4c:	2b01      	cmp	r3, #1
 8032f4e:	d002      	beq.n	8032f56 <LmhpRemoteMcastSetupProcess+0x1a>
 8032f50:	2b02      	cmp	r3, #2
 8032f52:	d01d      	beq.n	8032f90 <LmhpRemoteMcastSetupProcess+0x54>
}
 8032f54:	bd10      	pop	{r4, pc}
            if ( LmHandlerRequestClass( CLASS_C ) == LORAMAC_HANDLER_SUCCESS )
 8032f56:	2002      	movs	r0, #2
 8032f58:	f7fe fb40 	bl	80315dc <LmHandlerRequestClass>
 8032f5c:	b960      	cbnz	r0, 8032f78 <LmhpRemoteMcastSetupProcess+0x3c>
                TimerSetValue( &SessionStopTimer, ( 1 << McSessionData[0].SessionTimeout ) * 1000 );
 8032f5e:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
                LmhpRemoteMcastSetupState.SessionState = REMOTE_MCAST_SETUP_SESSION_STATE_IDLE;
 8032f62:	70a0      	strb	r0, [r4, #2]
                TimerSetValue( &SessionStopTimer, ( 1 << McSessionData[0].SessionTimeout ) * 1000 );
 8032f64:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8032f68:	4099      	lsls	r1, r3
                TimerSetValue( &SessionStopTimer, 1000 );
 8032f6a:	f104 0020 	add.w	r0, r4, #32
 8032f6e:	f008 fa71 	bl	803b454 <UTIL_TIMER_SetPeriod>
                TimerStart(&SessionStopTimer);
 8032f72:	f104 0020 	add.w	r0, r4, #32
 8032f76:	e007      	b.n	8032f88 <LmhpRemoteMcastSetupProcess+0x4c>
                TimerSetValue( &SessionStartTimer, 1000 );
 8032f78:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8032f7c:	f104 0008 	add.w	r0, r4, #8
 8032f80:	f008 fa68 	bl	803b454 <UTIL_TIMER_SetPeriod>
                TimerStart(&SessionStartTimer);
 8032f84:	f104 0008 	add.w	r0, r4, #8
}
 8032f88:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
                TimerStart(&SessionStopTimer);
 8032f8c:	f008 ba28 	b.w	803b3e0 <UTIL_TIMER_Start>
            if ( LmHandlerRequestClass( CLASS_A ) == LORAMAC_HANDLER_SUCCESS )
 8032f90:	2000      	movs	r0, #0
 8032f92:	f7fe fb23 	bl	80315dc <LmHandlerRequestClass>
 8032f96:	b908      	cbnz	r0, 8032f9c <LmhpRemoteMcastSetupProcess+0x60>
                LmhpRemoteMcastSetupState.SessionState = REMOTE_MCAST_SETUP_SESSION_STATE_IDLE;
 8032f98:	70a0      	strb	r0, [r4, #2]
 8032f9a:	e7db      	b.n	8032f54 <LmhpRemoteMcastSetupProcess+0x18>
                TimerSetValue( &SessionStopTimer, 1000 );
 8032f9c:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8032fa0:	e7e3      	b.n	8032f6a <LmhpRemoteMcastSetupProcess+0x2e>
 8032fa2:	bf00      	nop
 8032fa4:	20004a38 	.word	0x20004a38

08032fa8 <LmhpRemoteMcastSetupPackageFactory>:
}
 8032fa8:	4800      	ldr	r0, [pc, #0]	; (8032fac <LmhpRemoteMcastSetupPackageFactory+0x4>)
 8032faa:	4770      	bx	lr
 8032fac:	20003560 	.word	0x20003560

08032fb0 <OnRadioRxError>:
    MW_LOG(TS_ON, VLEVEL_M, "MAC txTimeOut\r\n" );
}

static void OnRadioRxError( void )
{
    LoRaMacRadioEvents.Events.RxError = 1;
 8032fb0:	4b05      	ldr	r3, [pc, #20]	; (8032fc8 <OnRadioRxError+0x18>)
 8032fb2:	781a      	ldrb	r2, [r3, #0]
 8032fb4:	f042 0202 	orr.w	r2, r2, #2
 8032fb8:	701a      	strb	r2, [r3, #0]

    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 8032fba:	f8d3 334c 	ldr.w	r3, [r3, #844]	; 0x34c
 8032fbe:	b113      	cbz	r3, 8032fc6 <OnRadioRxError+0x16>
 8032fc0:	691b      	ldr	r3, [r3, #16]
 8032fc2:	b103      	cbz	r3, 8032fc6 <OnRadioRxError+0x16>
    {
        MacCtx.MacCallbacks->MacProcessNotify( );
 8032fc4:	4718      	bx	r3
    }
}
 8032fc6:	4770      	bx	lr
 8032fc8:	20004aa4 	.word	0x20004aa4

08032fcc <UpdateRxSlotIdleState>:
    MW_LOG(TS_ON, VLEVEL_M, "MAC rxTimeOut\r\n" );
}

static void UpdateRxSlotIdleState( void )
{
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 8032fcc:	4a04      	ldr	r2, [pc, #16]	; (8032fe0 <UpdateRxSlotIdleState+0x14>)
 8032fce:	f892 3608 	ldrb.w	r3, [r2, #1544]	; 0x608
 8032fd2:	2b02      	cmp	r3, #2
    {
        MacCtx.RxSlot = RX_SLOT_NONE;
 8032fd4:	bf18      	it	ne
 8032fd6:	2306      	movne	r3, #6
 8032fd8:	f882 3484 	strb.w	r3, [r2, #1156]	; 0x484
    }
    else
    {
        MacCtx.RxSlot = RX_SLOT_WIN_CLASS_C;
    }
}
 8032fdc:	4770      	bx	lr
 8032fde:	bf00      	nop
 8032fe0:	20004aa4 	.word	0x20004aa4

08032fe4 <StopRetransmission>:
    return false;
}

static bool StopRetransmission( void )
{
    if( ( MacCtx.MacFlags.Bits.McpsInd == 0 ) ||
 8032fe4:	4b0f      	ldr	r3, [pc, #60]	; (8033024 <StopRetransmission+0x40>)
 8032fe6:	f893 2485 	ldrb.w	r2, [r3, #1157]	; 0x485
 8032fea:	0792      	lsls	r2, r2, #30
 8032fec:	d503      	bpl.n	8032ff6 <StopRetransmission+0x12>
 8032fee:	f893 2483 	ldrb.w	r2, [r3, #1155]	; 0x483
 8032ff2:	2a01      	cmp	r2, #1
 8032ff4:	d907      	bls.n	8033006 <StopRetransmission+0x22>
        ( ( MacCtx.RxStatus.RxSlot != RX_SLOT_WIN_1 ) &&
          ( MacCtx.RxStatus.RxSlot != RX_SLOT_WIN_2 ) ) )
    {   // Maximum repetitions without downlink. Increase ADR Ack counter.
        // Only process the case when the MAC did not receive a downlink.
        if( Nvm.MacGroup2.AdrCtrlOn == true )
 8032ff6:	f893 260a 	ldrb.w	r2, [r3, #1546]	; 0x60a
 8032ffa:	b122      	cbz	r2, 8033006 <StopRetransmission+0x22>
        {
            Nvm.MacGroup1.AdrAckCounter++;
 8032ffc:	f8d3 2534 	ldr.w	r2, [r3, #1332]	; 0x534
 8033000:	3201      	adds	r2, #1
 8033002:	f8c3 2534 	str.w	r2, [r3, #1332]	; 0x534
        }
    }

    MacCtx.ChannelsNbTransCounter = 0;
 8033006:	2200      	movs	r2, #0
 8033008:	f883 2414 	strb.w	r2, [r3, #1044]	; 0x414
    MacCtx.NodeAckRequested = false;
 803300c:	f883 2418 	strb.w	r2, [r3, #1048]	; 0x418
    MacCtx.AckTimeoutRetry = false;
 8033010:	f883 2417 	strb.w	r2, [r3, #1047]	; 0x417
    MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 8033014:	f8d3 2344 	ldr.w	r2, [r3, #836]	; 0x344
 8033018:	f022 0202 	bic.w	r2, r2, #2
 803301c:	f8c3 2344 	str.w	r2, [r3, #836]	; 0x344

    return true;
}
 8033020:	2001      	movs	r0, #1
 8033022:	4770      	bx	lr
 8033024:	20004aa4 	.word	0x20004aa4

08033028 <GetMaxAppPayloadWithoutFOptsLength>:
{
 8033028:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 803302a:	4b0c      	ldr	r3, [pc, #48]	; (803305c <GetMaxAppPayloadWithoutFOptsLength+0x34>)
    getPhy.Datarate = datarate;
 803302c:	f88d 0009 	strb.w	r0, [sp, #9]
    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8033030:	f893 2580 	ldrb.w	r2, [r3, #1408]	; 0x580
 8033034:	f88d 200a 	strb.w	r2, [sp, #10]
    getPhy.Attribute = PHY_MAX_PAYLOAD;
 8033038:	220d      	movs	r2, #13
 803303a:	f88d 2008 	strb.w	r2, [sp, #8]
    if( Nvm.MacGroup2.MacParams.RepeaterSupport == true )
 803303e:	f893 258c 	ldrb.w	r2, [r3, #1420]	; 0x58c
 8033042:	b112      	cbz	r2, 803304a <GetMaxAppPayloadWithoutFOptsLength+0x22>
        getPhy.Attribute = PHY_MAX_PAYLOAD_REPEATER;
 8033044:	220e      	movs	r2, #14
 8033046:	f88d 2008 	strb.w	r2, [sp, #8]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803304a:	f893 054c 	ldrb.w	r0, [r3, #1356]	; 0x54c
 803304e:	a902      	add	r1, sp, #8
 8033050:	f003 fb67 	bl	8036722 <RegionGetPhyParam>
}
 8033054:	b2c0      	uxtb	r0, r0
 8033056:	b005      	add	sp, #20
 8033058:	f85d fb04 	ldr.w	pc, [sp], #4
 803305c:	20004aa4 	.word	0x20004aa4

08033060 <OnAckTimeoutTimerEvent>:
{
 8033060:	b510      	push	{r4, lr}
    TimerStop( &MacCtx.AckTimeoutTimer );
 8033062:	4c0f      	ldr	r4, [pc, #60]	; (80330a0 <OnAckTimeoutTimerEvent+0x40>)
 8033064:	f504 707f 	add.w	r0, r4, #1020	; 0x3fc
 8033068:	f008 f96a 	bl	803b340 <UTIL_TIMER_Stop>
    if( MacCtx.NodeAckRequested == true )
 803306c:	f894 2418 	ldrb.w	r2, [r4, #1048]	; 0x418
 8033070:	4623      	mov	r3, r4
 8033072:	b112      	cbz	r2, 803307a <OnAckTimeoutTimerEvent+0x1a>
        MacCtx.AckTimeoutRetry = true;
 8033074:	2201      	movs	r2, #1
 8033076:	f884 2417 	strb.w	r2, [r4, #1047]	; 0x417
    if( Nvm.MacGroup2.DeviceClass == CLASS_C )
 803307a:	f893 2608 	ldrb.w	r2, [r3, #1544]	; 0x608
 803307e:	2a02      	cmp	r2, #2
        MacCtx.MacFlags.Bits.MacDone = 1;
 8033080:	bf02      	ittt	eq
 8033082:	f893 2485 	ldrbeq.w	r2, [r3, #1157]	; 0x485
 8033086:	f042 0220 	orreq.w	r2, r2, #32
 803308a:	f883 2485 	strbeq.w	r2, [r3, #1157]	; 0x485
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 803308e:	f8d3 334c 	ldr.w	r3, [r3, #844]	; 0x34c
 8033092:	b123      	cbz	r3, 803309e <OnAckTimeoutTimerEvent+0x3e>
 8033094:	691b      	ldr	r3, [r3, #16]
 8033096:	b113      	cbz	r3, 803309e <OnAckTimeoutTimerEvent+0x3e>
}
 8033098:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        MacCtx.MacCallbacks->MacProcessNotify( );
 803309c:	4718      	bx	r3
}
 803309e:	bd10      	pop	{r4, pc}
 80330a0:	20004aa4 	.word	0x20004aa4

080330a4 <PrepareRxDoneAbort>:
{
 80330a4:	b510      	push	{r4, lr}
    MacCtx.MacState |= LORAMAC_RX_ABORT;
 80330a6:	4c0c      	ldr	r4, [pc, #48]	; (80330d8 <PrepareRxDoneAbort+0x34>)
 80330a8:	f8d4 2344 	ldr.w	r2, [r4, #836]	; 0x344
 80330ac:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80330b0:	f8c4 2344 	str.w	r2, [r4, #836]	; 0x344
    if( MacCtx.NodeAckRequested == true )
 80330b4:	f894 2418 	ldrb.w	r2, [r4, #1048]	; 0x418
 80330b8:	b112      	cbz	r2, 80330c0 <PrepareRxDoneAbort+0x1c>
        OnAckTimeoutTimerEvent( NULL );
 80330ba:	2000      	movs	r0, #0
 80330bc:	f7ff ffd0 	bl	8033060 <OnAckTimeoutTimerEvent>
    MacCtx.MacFlags.Bits.McpsInd = 1;
 80330c0:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 80330c4:	f023 0322 	bic.w	r3, r3, #34	; 0x22
 80330c8:	f043 0322 	orr.w	r3, r3, #34	; 0x22
 80330cc:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
}
 80330d0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    UpdateRxSlotIdleState( );
 80330d4:	f7ff bf7a 	b.w	8032fcc <UpdateRxSlotIdleState>
 80330d8:	20004aa4 	.word	0x20004aa4

080330dc <HandleRadioRxErrorTimeout>:
{
 80330dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 80330e0:	4c2c      	ldr	r4, [pc, #176]	; (8033194 <HandleRadioRxErrorTimeout+0xb8>)
 80330e2:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 80330e6:	2b02      	cmp	r3, #2
{
 80330e8:	4607      	mov	r7, r0
 80330ea:	460e      	mov	r6, r1
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 80330ec:	d002      	beq.n	80330f4 <HandleRadioRxErrorTimeout+0x18>
        Radio.Sleep( );
 80330ee:	4b2a      	ldr	r3, [pc, #168]	; (8033198 <HandleRadioRxErrorTimeout+0xbc>)
 80330f0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80330f2:	4798      	blx	r3
    if( LoRaMacClassBIsBeaconExpected( ) == true )
 80330f4:	f002 fc5d 	bl	80359b2 <LoRaMacClassBIsBeaconExpected>
 80330f8:	4605      	mov	r5, r0
 80330fa:	b128      	cbz	r0, 8033108 <HandleRadioRxErrorTimeout+0x2c>
        LoRaMacClassBSetBeaconState( BEACON_STATE_TIMEOUT );
 80330fc:	2002      	movs	r0, #2
 80330fe:	f002 fc4e 	bl	803599e <LoRaMacClassBSetBeaconState>
        LoRaMacClassBBeaconTimerEvent( NULL );
 8033102:	2000      	movs	r0, #0
 8033104:	f002 fc50 	bl	80359a8 <LoRaMacClassBBeaconTimerEvent>
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 8033108:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 803310c:	2b01      	cmp	r3, #1
 803310e:	d117      	bne.n	8033140 <HandleRadioRxErrorTimeout+0x64>
        if( LoRaMacClassBIsPingExpected( ) == true )
 8033110:	f002 fc51 	bl	80359b6 <LoRaMacClassBIsPingExpected>
 8033114:	4680      	mov	r8, r0
 8033116:	b130      	cbz	r0, 8033126 <HandleRadioRxErrorTimeout+0x4a>
            LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 8033118:	2000      	movs	r0, #0
 803311a:	f002 fc41 	bl	80359a0 <LoRaMacClassBSetPingSlotState>
            LoRaMacClassBPingSlotTimerEvent( NULL );
 803311e:	2000      	movs	r0, #0
 8033120:	f002 fc43 	bl	80359aa <LoRaMacClassBPingSlotTimerEvent>
            classBRx = true;
 8033124:	4645      	mov	r5, r8
        if( LoRaMacClassBIsMulticastExpected( ) == true )
 8033126:	f002 fc48 	bl	80359ba <LoRaMacClassBIsMulticastExpected>
 803312a:	b148      	cbz	r0, 8033140 <HandleRadioRxErrorTimeout+0x64>
            LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 803312c:	2000      	movs	r0, #0
 803312e:	f002 fc38 	bl	80359a2 <LoRaMacClassBSetMulticastSlotState>
            LoRaMacClassBMulticastSlotTimerEvent( NULL );
 8033132:	2000      	movs	r0, #0
 8033134:	f002 fc3a 	bl	80359ac <LoRaMacClassBMulticastSlotTimerEvent>
}
 8033138:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    UpdateRxSlotIdleState( );
 803313c:	f7ff bf46 	b.w	8032fcc <UpdateRxSlotIdleState>
    if( classBRx == false )
 8033140:	2d00      	cmp	r5, #0
 8033142:	d1f9      	bne.n	8033138 <HandleRadioRxErrorTimeout+0x5c>
        if( MacCtx.RxSlot == RX_SLOT_WIN_1 )
 8033144:	f894 2484 	ldrb.w	r2, [r4, #1156]	; 0x484
 8033148:	f894 3418 	ldrb.w	r3, [r4, #1048]	; 0x418
 803314c:	b9ba      	cbnz	r2, 803317e <HandleRadioRxErrorTimeout+0xa2>
            if( MacCtx.NodeAckRequested == true )
 803314e:	b10b      	cbz	r3, 8033154 <HandleRadioRxErrorTimeout+0x78>
                MacCtx.McpsConfirm.Status = rx1EventInfoStatus;
 8033150:	f884 743d 	strb.w	r7, [r4, #1085]	; 0x43d
            LoRaMacConfirmQueueSetStatusCmn( rx1EventInfoStatus );
 8033154:	4638      	mov	r0, r7
 8033156:	f002 fdd9 	bl	8035d0c <LoRaMacConfirmQueueSetStatusCmn>
            if( TimerGetElapsedTime( Nvm.MacGroup1.LastTxDoneTime ) >= MacCtx.RxWindow2Delay )
 803315a:	f8d4 0538 	ldr.w	r0, [r4, #1336]	; 0x538
 803315e:	f008 f8b5 	bl	803b2cc <UTIL_TIMER_GetElapsedTime>
 8033162:	f8d4 33b8 	ldr.w	r3, [r4, #952]	; 0x3b8
 8033166:	4298      	cmp	r0, r3
 8033168:	d3e6      	bcc.n	8033138 <HandleRadioRxErrorTimeout+0x5c>
                TimerStop( &MacCtx.RxWindowTimer2 );
 803316a:	480c      	ldr	r0, [pc, #48]	; (803319c <HandleRadioRxErrorTimeout+0xc0>)
 803316c:	f008 f8e8 	bl	803b340 <UTIL_TIMER_Stop>
                MacCtx.MacFlags.Bits.MacDone = 1;
 8033170:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 8033174:	f043 0320 	orr.w	r3, r3, #32
 8033178:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
 803317c:	e7dc      	b.n	8033138 <HandleRadioRxErrorTimeout+0x5c>
            if( MacCtx.NodeAckRequested == true )
 803317e:	b10b      	cbz	r3, 8033184 <HandleRadioRxErrorTimeout+0xa8>
                MacCtx.McpsConfirm.Status = rx2EventInfoStatus;
 8033180:	f884 643d 	strb.w	r6, [r4, #1085]	; 0x43d
            LoRaMacConfirmQueueSetStatusCmn( rx2EventInfoStatus );
 8033184:	4630      	mov	r0, r6
 8033186:	f002 fdc1 	bl	8035d0c <LoRaMacConfirmQueueSetStatusCmn>
            if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 803318a:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 803318e:	2b02      	cmp	r3, #2
 8033190:	d1ee      	bne.n	8033170 <HandleRadioRxErrorTimeout+0x94>
 8033192:	e7d1      	b.n	8033138 <HandleRadioRxErrorTimeout+0x5c>
 8033194:	20004aa4 	.word	0x20004aa4
 8033198:	0803bc30 	.word	0x0803bc30
 803319c:	20004e40 	.word	0x20004e40

080331a0 <OnRadioRxTimeout>:
    LoRaMacRadioEvents.Events.RxTimeout = 1;
 80331a0:	4b09      	ldr	r3, [pc, #36]	; (80331c8 <OnRadioRxTimeout+0x28>)
 80331a2:	781a      	ldrb	r2, [r3, #0]
 80331a4:	f042 0201 	orr.w	r2, r2, #1
{
 80331a8:	b510      	push	{r4, lr}
    LoRaMacRadioEvents.Events.RxTimeout = 1;
 80331aa:	701a      	strb	r2, [r3, #0]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 80331ac:	f8d3 334c 	ldr.w	r3, [r3, #844]	; 0x34c
 80331b0:	b113      	cbz	r3, 80331b8 <OnRadioRxTimeout+0x18>
 80331b2:	691b      	ldr	r3, [r3, #16]
 80331b4:	b103      	cbz	r3, 80331b8 <OnRadioRxTimeout+0x18>
        MacCtx.MacCallbacks->MacProcessNotify( );
 80331b6:	4798      	blx	r3
}
 80331b8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    MW_LOG(TS_ON, VLEVEL_M, "MAC rxTimeOut\r\n" );
 80331bc:	4b03      	ldr	r3, [pc, #12]	; (80331cc <OnRadioRxTimeout+0x2c>)
 80331be:	2201      	movs	r2, #1
 80331c0:	2100      	movs	r1, #0
 80331c2:	2002      	movs	r0, #2
 80331c4:	f007 bd9a 	b.w	803acfc <UTIL_ADV_TRACE_COND_FSend>
 80331c8:	20004aa4 	.word	0x20004aa4
 80331cc:	0803c367 	.word	0x0803c367

080331d0 <OnRadioTxTimeout>:
    LoRaMacRadioEvents.Events.TxTimeout = 1;
 80331d0:	4b09      	ldr	r3, [pc, #36]	; (80331f8 <OnRadioTxTimeout+0x28>)
 80331d2:	781a      	ldrb	r2, [r3, #0]
 80331d4:	f042 0204 	orr.w	r2, r2, #4
{
 80331d8:	b510      	push	{r4, lr}
    LoRaMacRadioEvents.Events.TxTimeout = 1;
 80331da:	701a      	strb	r2, [r3, #0]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 80331dc:	f8d3 334c 	ldr.w	r3, [r3, #844]	; 0x34c
 80331e0:	b113      	cbz	r3, 80331e8 <OnRadioTxTimeout+0x18>
 80331e2:	691b      	ldr	r3, [r3, #16]
 80331e4:	b103      	cbz	r3, 80331e8 <OnRadioTxTimeout+0x18>
        MacCtx.MacCallbacks->MacProcessNotify( );
 80331e6:	4798      	blx	r3
}
 80331e8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    MW_LOG(TS_ON, VLEVEL_M, "MAC txTimeOut\r\n" );
 80331ec:	4b03      	ldr	r3, [pc, #12]	; (80331fc <OnRadioTxTimeout+0x2c>)
 80331ee:	2201      	movs	r2, #1
 80331f0:	2100      	movs	r1, #0
 80331f2:	2002      	movs	r0, #2
 80331f4:	f007 bd82 	b.w	803acfc <UTIL_ADV_TRACE_COND_FSend>
 80331f8:	20004aa4 	.word	0x20004aa4
 80331fc:	0803c377 	.word	0x0803c377

08033200 <OnRadioRxDone>:
{
 8033200:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8033204:	4616      	mov	r6, r2
 8033206:	461d      	mov	r5, r3
 8033208:	4680      	mov	r8, r0
 803320a:	460f      	mov	r7, r1
    RxDoneParams.LastRxDone = TimerGetCurrentTime( );
 803320c:	f008 f854 	bl	803b2b8 <UTIL_TIMER_GetCurrentTime>
    LoRaMacRadioEvents.Events.RxDone = 1;
 8033210:	4b0c      	ldr	r3, [pc, #48]	; (8033244 <OnRadioRxDone+0x44>)
    RxDoneParams.LastRxDone = TimerGetCurrentTime( );
 8033212:	4c0d      	ldr	r4, [pc, #52]	; (8033248 <OnRadioRxDone+0x48>)
    LoRaMacRadioEvents.Events.RxDone = 1;
 8033214:	781a      	ldrb	r2, [r3, #0]
    RxDoneParams.Size = size;
 8033216:	8127      	strh	r7, [r4, #8]
    LoRaMacRadioEvents.Events.RxDone = 1;
 8033218:	f042 0208 	orr.w	r2, r2, #8
 803321c:	701a      	strb	r2, [r3, #0]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 803321e:	f8d3 334c 	ldr.w	r3, [r3, #844]	; 0x34c
    RxDoneParams.Rssi = rssi;
 8033222:	8166      	strh	r6, [r4, #10]
    RxDoneParams.Payload = payload;
 8033224:	e9c4 0800 	strd	r0, r8, [r4]
    RxDoneParams.Snr = snr;
 8033228:	7325      	strb	r5, [r4, #12]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 803322a:	b113      	cbz	r3, 8033232 <OnRadioRxDone+0x32>
 803322c:	691b      	ldr	r3, [r3, #16]
 803322e:	b103      	cbz	r3, 8033232 <OnRadioRxDone+0x32>
        MacCtx.MacCallbacks->MacProcessNotify( );
 8033230:	4798      	blx	r3
}
 8033232:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    MW_LOG(TS_ON, VLEVEL_M, "MAC rxDone\r\n" );
 8033236:	4b05      	ldr	r3, [pc, #20]	; (803324c <OnRadioRxDone+0x4c>)
 8033238:	2201      	movs	r2, #1
 803323a:	2100      	movs	r1, #0
 803323c:	2002      	movs	r0, #2
 803323e:	f007 bd5d 	b.w	803acfc <UTIL_ADV_TRACE_COND_FSend>
 8033242:	bf00      	nop
 8033244:	20004aa4 	.word	0x20004aa4
 8033248:	20006314 	.word	0x20006314
 803324c:	0803c387 	.word	0x0803c387

08033250 <OnRadioTxDone>:
{
 8033250:	b537      	push	{r0, r1, r2, r4, r5, lr}
    TxDoneParams.CurTime = TimerGetCurrentTime( );
 8033252:	f008 f831 	bl	803b2b8 <UTIL_TIMER_GetCurrentTime>
 8033256:	4b10      	ldr	r3, [pc, #64]	; (8033298 <OnRadioTxDone+0x48>)
    MacCtx.LastTxSysTime = SysTimeGet( );
 8033258:	4c10      	ldr	r4, [pc, #64]	; (803329c <OnRadioTxDone+0x4c>)
    TxDoneParams.CurTime = TimerGetCurrentTime( );
 803325a:	6018      	str	r0, [r3, #0]
    MacCtx.LastTxSysTime = SysTimeGet( );
 803325c:	466d      	mov	r5, sp
 803325e:	4628      	mov	r0, r5
 8033260:	f007 ff80 	bl	803b164 <SysTimeGet>
 8033264:	e895 0003 	ldmia.w	r5, {r0, r1}
 8033268:	f504 734f 	add.w	r3, r4, #828	; 0x33c
 803326c:	e883 0003 	stmia.w	r3, {r0, r1}
    LoRaMacRadioEvents.Events.TxDone = 1;
 8033270:	7823      	ldrb	r3, [r4, #0]
 8033272:	f043 0310 	orr.w	r3, r3, #16
 8033276:	7023      	strb	r3, [r4, #0]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 8033278:	f8d4 334c 	ldr.w	r3, [r4, #844]	; 0x34c
 803327c:	b113      	cbz	r3, 8033284 <OnRadioTxDone+0x34>
 803327e:	691b      	ldr	r3, [r3, #16]
 8033280:	b103      	cbz	r3, 8033284 <OnRadioTxDone+0x34>
        MacCtx.MacCallbacks->MacProcessNotify( );
 8033282:	4798      	blx	r3
    MW_LOG(TS_ON, VLEVEL_M, "MAC txDone\r\n" );
 8033284:	4b06      	ldr	r3, [pc, #24]	; (80332a0 <OnRadioTxDone+0x50>)
 8033286:	2201      	movs	r2, #1
 8033288:	2100      	movs	r1, #0
 803328a:	2002      	movs	r0, #2
}
 803328c:	b003      	add	sp, #12
 803328e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    MW_LOG(TS_ON, VLEVEL_M, "MAC txDone\r\n" );
 8033292:	f007 bd33 	b.w	803acfc <UTIL_ADV_TRACE_COND_FSend>
 8033296:	bf00      	nop
 8033298:	20006310 	.word	0x20006310
 803329c:	20004aa4 	.word	0x20004aa4
 80332a0:	0803c394 	.word	0x0803c394

080332a4 <ResetMacParameters>:
{
 80332a4:	b5f0      	push	{r4, r5, r6, r7, lr}
    Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_NONE;
 80332a6:	4c46      	ldr	r4, [pc, #280]	; (80333c0 <ResetMacParameters+0x11c>)
    Nvm.MacGroup1.ChannelsTxPower = Nvm.MacGroup2.ChannelsTxPowerDefault;
 80332a8:	f8b4 25d0 	ldrh.w	r2, [r4, #1488]	; 0x5d0
    Nvm.MacGroup2.MacParams.Rx2Channel = Nvm.MacGroup2.MacParamsDefaults.Rx2Channel;
 80332ac:	f8d4 15b4 	ldr.w	r1, [r4, #1460]	; 0x5b4
 80332b0:	f8d4 05b0 	ldr.w	r0, [r4, #1456]	; 0x5b0
    Nvm.MacGroup1.ChannelsTxPower = Nvm.MacGroup2.ChannelsTxPowerDefault;
 80332b4:	f8a4 2544 	strh.w	r2, [r4, #1348]	; 0x544
    Nvm.MacGroup2.MacParams.Rx1DrOffset = Nvm.MacGroup2.MacParamsDefaults.Rx1DrOffset;
 80332b8:	f894 25ad 	ldrb.w	r2, [r4, #1453]	; 0x5ad
 80332bc:	f884 256d 	strb.w	r2, [r4, #1389]	; 0x56d
    Nvm.MacGroup2.MacParams.Rx2Channel = Nvm.MacGroup2.MacParamsDefaults.Rx2Channel;
 80332c0:	f504 62ae 	add.w	r2, r4, #1392	; 0x570
 80332c4:	e882 0003 	stmia.w	r2, {r0, r1}
    Nvm.MacGroup2.MacParams.RxCChannel = Nvm.MacGroup2.MacParamsDefaults.RxCChannel;
 80332c8:	f8d4 15bc 	ldr.w	r1, [r4, #1468]	; 0x5bc
 80332cc:	f8d4 05b8 	ldr.w	r0, [r4, #1464]	; 0x5b8
 80332d0:	f504 62af 	add.w	r2, r4, #1400	; 0x578
{
 80332d4:	b08f      	sub	sp, #60	; 0x3c
    Nvm.MacGroup2.MacParams.RxCChannel = Nvm.MacGroup2.MacParamsDefaults.RxCChannel;
 80332d6:	e882 0003 	stmia.w	r2, {r0, r1}
    Nvm.MacGroup2.MacParams.UplinkDwellTime = Nvm.MacGroup2.MacParamsDefaults.UplinkDwellTime;
 80332da:	f8b4 25c0 	ldrh.w	r2, [r4, #1472]	; 0x5c0
 80332de:	f8a4 2580 	strh.w	r2, [r4, #1408]	; 0x580
    Nvm.MacGroup2.AggregatedDCycle = 1;
 80332e2:	2301      	movs	r3, #1
    Nvm.MacGroup2.MacParams.MaxEirp = Nvm.MacGroup2.MacParamsDefaults.MaxEirp;
 80332e4:	f8d4 25c4 	ldr.w	r2, [r4, #1476]	; 0x5c4
    Nvm.MacGroup2.AggregatedDCycle = 1;
 80332e8:	f8a4 360e 	strh.w	r3, [r4, #1550]	; 0x60e
    Nvm.MacGroup2.MacParams.MaxEirp = Nvm.MacGroup2.MacParamsDefaults.MaxEirp;
 80332ec:	f8c4 2584 	str.w	r2, [r4, #1412]	; 0x584
    params.Type = INIT_TYPE_RESET_TO_DEFAULT_CHANNELS;
 80332f0:	f88d 3014 	strb.w	r3, [sp, #20]
    Nvm.MacGroup2.MacParams.AntennaGain = Nvm.MacGroup2.MacParamsDefaults.AntennaGain;
 80332f4:	f8d4 25c8 	ldr.w	r2, [r4, #1480]	; 0x5c8
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 80332f8:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    Nvm.MacGroup2.MacParams.AntennaGain = Nvm.MacGroup2.MacParamsDefaults.AntennaGain;
 80332fc:	f8c4 2588 	str.w	r2, [r4, #1416]	; 0x588
    params.NvmGroup1 = &Nvm.RegionGroup1;
 8033300:	f504 63e5 	add.w	r3, r4, #1832	; 0x728
    Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_NONE;
 8033304:	2500      	movs	r5, #0
    MacCtx.ChannelsNbTransCounter = 0;
 8033306:	4a2f      	ldr	r2, [pc, #188]	; (80333c4 <ResetMacParameters+0x120>)
    params.NvmGroup1 = &Nvm.RegionGroup1;
 8033308:	9303      	str	r3, [sp, #12]
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 803330a:	a903      	add	r1, sp, #12
    params.NvmGroup2 = &Nvm.RegionGroup2;
 803330c:	f204 73cc 	addw	r3, r4, #1996	; 0x7cc
    MacCtx.ChannelsNbTransCounter = 0;
 8033310:	f8c4 2414 	str.w	r2, [r4, #1044]	; 0x414
    params.NvmGroup2 = &Nvm.RegionGroup2;
 8033314:	9304      	str	r3, [sp, #16]
    Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_NONE;
 8033316:	f884 561c 	strb.w	r5, [r4, #1564]	; 0x61c
    Nvm.MacGroup1.AdrAckCounter = 0;
 803331a:	f8c4 5534 	str.w	r5, [r4, #1332]	; 0x534
    Nvm.MacGroup2.MaxDCycle = 0;
 803331e:	f884 560b 	strb.w	r5, [r4, #1547]	; 0x60b
    MacCtx.NodeAckRequested = false;
 8033322:	f884 5418 	strb.w	r5, [r4, #1048]	; 0x418
    Nvm.MacGroup1.SrvAckRequested = false;
 8033326:	f884 5546 	strb.w	r5, [r4, #1350]	; 0x546
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 803332a:	f003 fa15 	bl	8036758 <RegionInitDefaults>
    MacCtx.RxWindow2Config.Frequency = Nvm.MacGroup2.MacParams.Rx2Channel.Frequency;
 803332e:	f8d4 3570 	ldr.w	r3, [r4, #1392]	; 0x570
 8033332:	f8c4 33d4 	str.w	r3, [r4, #980]	; 0x3d4
    MacCtx.RxWindow2Config.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 8033336:	f894 3581 	ldrb.w	r3, [r4, #1409]	; 0x581
 803333a:	f884 33e0 	strb.w	r3, [r4, #992]	; 0x3e0
    MacCtx.RxWindow2Config.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport; /* ST_WORKAROUND: Keep repeater feature */
 803333e:	f894 358c 	ldrb.w	r3, [r4, #1420]	; 0x58c
 8033342:	f884 33e1 	strb.w	r3, [r4, #993]	; 0x3e1
    MacCtx.RxWindow2Config.RxContinuous = false;
 8033346:	f44f 7380 	mov.w	r3, #256	; 0x100
 803334a:	f8a4 33e2 	strh.w	r3, [r4, #994]	; 0x3e2
    MacCtx.RxWindow2Config.Channel = MacCtx.Channel;
 803334e:	f884 53d0 	strb.w	r5, [r4, #976]	; 0x3d0
    MacCtx.RxWindowCConfig = MacCtx.RxWindow2Config;
 8033352:	f504 7774 	add.w	r7, r4, #976	; 0x3d0
 8033356:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8033358:	f504 7679 	add.w	r6, r4, #996	; 0x3e4
 803335c:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 803335e:	683b      	ldr	r3, [r7, #0]
 8033360:	6033      	str	r3, [r6, #0]
    MacCtx.RxWindowCConfig.RxContinuous = true;
 8033362:	f240 2301 	movw	r3, #513	; 0x201
 8033366:	f8a4 33f6 	strh.w	r3, [r4, #1014]	; 0x3f6
    if( MacCtx.MacCallbacks != NULL )
 803336a:	f8d4 334c 	ldr.w	r3, [r4, #844]	; 0x34c
    MacCtx.Channel = 0;
 803336e:	f884 5419 	strb.w	r5, [r4, #1049]	; 0x419
    classBCallbacks.MacProcessNotify = NULL;
 8033372:	e9cd 5501 	strd	r5, r5, [sp, #4]
    if( MacCtx.MacCallbacks != NULL )
 8033376:	b11b      	cbz	r3, 8033380 <ResetMacParameters+0xdc>
        classBCallbacks.GetTemperatureLevel = MacCtx.MacCallbacks->GetTemperatureLevel;
 8033378:	685a      	ldr	r2, [r3, #4]
        classBCallbacks.MacProcessNotify = MacCtx.MacCallbacks->MacProcessNotify;
 803337a:	691b      	ldr	r3, [r3, #16]
        classBCallbacks.GetTemperatureLevel = MacCtx.MacCallbacks->GetTemperatureLevel;
 803337c:	9201      	str	r2, [sp, #4]
        classBCallbacks.MacProcessNotify = MacCtx.MacCallbacks->MacProcessNotify;
 803337e:	9302      	str	r3, [sp, #8]
    classBParams.MlmeIndication = &MacCtx.MlmeIndication;
 8033380:	4a11      	ldr	r2, [pc, #68]	; (80333c8 <ResetMacParameters+0x124>)
 8033382:	9206      	str	r2, [sp, #24]
    classBParams.McpsIndication = &MacCtx.McpsIndication;
 8033384:	f1a2 0344 	sub.w	r3, r2, #68	; 0x44
 8033388:	9307      	str	r3, [sp, #28]
    classBParams.MlmeConfirm = &MacCtx.MlmeConfirm;
 803338a:	f1a2 0314 	sub.w	r3, r2, #20
 803338e:	9308      	str	r3, [sp, #32]
    classBParams.LoRaMacFlags = &MacCtx.MacFlags;
 8033390:	f102 0321 	add.w	r3, r2, #33	; 0x21
 8033394:	9309      	str	r3, [sp, #36]	; 0x24
    classBParams.LoRaMacDevAddr = &Nvm.MacGroup2.DevAddr;
 8033396:	f502 73ba 	add.w	r3, r2, #372	; 0x174
 803339a:	930a      	str	r3, [sp, #40]	; 0x28
    classBParams.LoRaMacRegion = &Nvm.MacGroup2.Region;
 803339c:	f102 03e8 	add.w	r3, r2, #232	; 0xe8
 80333a0:	930b      	str	r3, [sp, #44]	; 0x2c
    classBParams.LoRaMacParams = &Nvm.MacGroup2.MacParams;
 80333a2:	f102 03ec 	add.w	r3, r2, #236	; 0xec
 80333a6:	930c      	str	r3, [sp, #48]	; 0x30
    LoRaMacClassBInit( &classBParams, &classBCallbacks, &Nvm.ClassB );
 80333a8:	a901      	add	r1, sp, #4
    classBParams.MulticastChannels = &Nvm.MacGroup2.MulticastChannelList[0];
 80333aa:	f502 73bc 	add.w	r3, r2, #376	; 0x178
    LoRaMacClassBInit( &classBParams, &classBCallbacks, &Nvm.ClassB );
 80333ae:	a806      	add	r0, sp, #24
 80333b0:	f202 62e4 	addw	r2, r2, #1764	; 0x6e4
    classBParams.MulticastChannels = &Nvm.MacGroup2.MulticastChannelList[0];
 80333b4:	930d      	str	r3, [sp, #52]	; 0x34
    LoRaMacClassBInit( &classBParams, &classBCallbacks, &Nvm.ClassB );
 80333b6:	f002 faf1 	bl	803599c <LoRaMacClassBInit>
}
 80333ba:	b00f      	add	sp, #60	; 0x3c
 80333bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80333be:	bf00      	nop
 80333c0:	20004aa4 	.word	0x20004aa4
 80333c4:	00010100 	.word	0x00010100
 80333c8:	20004f08 	.word	0x20004f08

080333cc <ScheduleTx>:
{
 80333cc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80333ce:	b093      	sub	sp, #76	; 0x4c
 80333d0:	4607      	mov	r7, r0
    if( LoRaMacClassBIsBeaconExpected( ) == true )
 80333d2:	f002 faee 	bl	80359b2 <LoRaMacClassBIsBeaconExpected>
 80333d6:	2800      	cmp	r0, #0
 80333d8:	f040 8163 	bne.w	80336a2 <ScheduleTx+0x2d6>
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 80333dc:	4cb2      	ldr	r4, [pc, #712]	; (80336a8 <ScheduleTx+0x2dc>)
 80333de:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 80333e2:	2b01      	cmp	r3, #1
 80333e4:	d009      	beq.n	80333fa <ScheduleTx+0x2e>
    if( Nvm.MacGroup1.AggregatedTimeOff == 0 )
 80333e6:	f8d4 353c 	ldr.w	r3, [r4, #1340]	; 0x53c
 80333ea:	b193      	cbz	r3, 8033412 <ScheduleTx+0x46>
    switch( MacCtx.TxMsg.Type )
 80333ec:	f894 3108 	ldrb.w	r3, [r4, #264]	; 0x108
 80333f0:	b1c3      	cbz	r3, 8033424 <ScheduleTx+0x58>
 80333f2:	2b04      	cmp	r3, #4
 80333f4:	d076      	beq.n	80334e4 <ScheduleTx+0x118>
            return LORAMAC_STATUS_PARAMETER_INVALID;
 80333f6:	2503      	movs	r5, #3
 80333f8:	e003      	b.n	8033402 <ScheduleTx+0x36>
        if( LoRaMacClassBIsPingExpected( ) == true )
 80333fa:	f002 fadc 	bl	80359b6 <LoRaMacClassBIsPingExpected>
 80333fe:	b118      	cbz	r0, 8033408 <ScheduleTx+0x3c>
            return LORAMAC_STATUS_BUSY_PING_SLOT_WINDOW_TIME;
 8033400:	250f      	movs	r5, #15
}
 8033402:	4628      	mov	r0, r5
 8033404:	b013      	add	sp, #76	; 0x4c
 8033406:	bdf0      	pop	{r4, r5, r6, r7, pc}
        else if( LoRaMacClassBIsMulticastExpected( ) == true )
 8033408:	f002 fad7 	bl	80359ba <LoRaMacClassBIsMulticastExpected>
 803340c:	2800      	cmp	r0, #0
 803340e:	d0ea      	beq.n	80333e6 <ScheduleTx+0x1a>
 8033410:	e7f6      	b.n	8033400 <ScheduleTx+0x34>
        Nvm.MacGroup1.AggregatedTimeOff = ( MacCtx.TxTimeOnAir * Nvm.MacGroup2.AggregatedDCycle - MacCtx.TxTimeOnAir );
 8033412:	f8b4 360e 	ldrh.w	r3, [r4, #1550]	; 0x60e
 8033416:	1e5a      	subs	r2, r3, #1
 8033418:	f8d4 341c 	ldr.w	r3, [r4, #1052]	; 0x41c
 803341c:	4353      	muls	r3, r2
 803341e:	f8c4 353c 	str.w	r3, [r4, #1340]	; 0x53c
 8033422:	e7e3      	b.n	80333ec <ScheduleTx+0x20>
            serializeStatus = LoRaMacSerializerJoinRequest( &MacCtx.TxMsg.Message.JoinReq );
 8033424:	48a1      	ldr	r0, [pc, #644]	; (80336ac <ScheduleTx+0x2e0>)
 8033426:	f003 f8ce 	bl	80365c6 <LoRaMacSerializerJoinRequest>
            if( LORAMAC_SERIALIZER_SUCCESS != serializeStatus )
 803342a:	2800      	cmp	r0, #0
 803342c:	f040 8135 	bne.w	803369a <ScheduleTx+0x2ce>
            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.Data.BufSize;
 8033430:	f894 3110 	ldrb.w	r3, [r4, #272]	; 0x110
 8033434:	80a3      	strh	r3, [r4, #4]
    nextChan.AggrTimeOff = Nvm.MacGroup1.AggregatedTimeOff;
 8033436:	f8d4 353c 	ldr.w	r3, [r4, #1340]	; 0x53c
 803343a:	930c      	str	r3, [sp, #48]	; 0x30
    nextChan.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );
 803343c:	ae06      	add	r6, sp, #24
    nextChan.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 803343e:	f894 3545 	ldrb.w	r3, [r4, #1349]	; 0x545
 8033442:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
    nextChan.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );
 8033446:	4630      	mov	r0, r6
    nextChan.DutyCycleEnabled = Nvm.MacGroup2.DutyCycleOn;
 8033448:	f894 360c 	ldrb.w	r3, [r4, #1548]	; 0x60c
 803344c:	f88d 303a 	strb.w	r3, [sp, #58]	; 0x3a
    nextChan.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );
 8033450:	f007 feae 	bl	803b1b0 <SysTimeGetMcuTime>
 8033454:	f8d4 3614 	ldr.w	r3, [r4, #1556]	; 0x614
 8033458:	9300      	str	r3, [sp, #0]
 803345a:	ad02      	add	r5, sp, #8
 803345c:	e896 0006 	ldmia.w	r6, {r1, r2}
 8033460:	f8d4 3610 	ldr.w	r3, [r4, #1552]	; 0x610
 8033464:	4628      	mov	r0, r5
 8033466:	f007 fe39 	bl	803b0dc <SysTimeSub>
 803346a:	e895 0003 	ldmia.w	r5, {r0, r1}
 803346e:	ab0f      	add	r3, sp, #60	; 0x3c
 8033470:	e883 0003 	stmia.w	r3, {r0, r1}
    nextChan.LastAggrTx = Nvm.MacGroup1.LastTxDoneTime;
 8033474:	f8d4 3538 	ldr.w	r3, [r4, #1336]	; 0x538
 8033478:	930d      	str	r3, [sp, #52]	; 0x34
    nextChan.LastTxIsJoinRequest = false;
 803347a:	2300      	movs	r3, #0
 803347c:	f88d 3044 	strb.w	r3, [sp, #68]	; 0x44
    nextChan.PktLen = MacCtx.PktBufferLen;
 8033480:	88a3      	ldrh	r3, [r4, #4]
 8033482:	f8ad 3046 	strh.w	r3, [sp, #70]	; 0x46
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 8033486:	f894 361c 	ldrb.w	r3, [r4, #1564]	; 0x61c
    nextChan.Joined = true;
 803348a:	2201      	movs	r2, #1
 803348c:	f88d 2039 	strb.w	r2, [sp, #57]	; 0x39
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 8033490:	b91b      	cbnz	r3, 803349a <ScheduleTx+0xce>
        nextChan.LastTxIsJoinRequest = true;
 8033492:	f88d 2044 	strb.w	r2, [sp, #68]	; 0x44
        nextChan.Joined = false;
 8033496:	f88d 3039 	strb.w	r3, [sp, #57]	; 0x39
    status = RegionNextChannel( Nvm.MacGroup2.Region, &nextChan, &MacCtx.Channel, &MacCtx.DutyCycleWaitTime, &Nvm.MacGroup1.AggregatedTimeOff );
 803349a:	4e85      	ldr	r6, [pc, #532]	; (80336b0 <ScheduleTx+0x2e4>)
 803349c:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
 80334a0:	9600      	str	r6, [sp, #0]
 80334a2:	f46f 7291 	mvn.w	r2, #290	; 0x122
 80334a6:	f1a6 03b4 	sub.w	r3, r6, #180	; 0xb4
 80334aa:	18b2      	adds	r2, r6, r2
 80334ac:	a90c      	add	r1, sp, #48	; 0x30
 80334ae:	f003 fa06 	bl	80368be <RegionNextChannel>
    if( status != LORAMAC_STATUS_OK )
 80334b2:	4605      	mov	r5, r0
 80334b4:	b1d0      	cbz	r0, 80334ec <ScheduleTx+0x120>
        if( ( status == LORAMAC_STATUS_DUTYCYCLE_RESTRICTED ) &&
 80334b6:	280b      	cmp	r0, #11
 80334b8:	d1a3      	bne.n	8033402 <ScheduleTx+0x36>
 80334ba:	2f00      	cmp	r7, #0
 80334bc:	d0a1      	beq.n	8033402 <ScheduleTx+0x36>
            if( MacCtx.DutyCycleWaitTime != 0 )
 80334be:	f8d4 1488 	ldr.w	r1, [r4, #1160]	; 0x488
 80334c2:	b169      	cbz	r1, 80334e0 <ScheduleTx+0x114>
                MacCtx.MacState |= LORAMAC_TX_DELAYED;
 80334c4:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
                TimerSetValue( &MacCtx.TxDelayedTimer, MacCtx.DutyCycleWaitTime );
 80334c8:	f5a6 70e8 	sub.w	r0, r6, #464	; 0x1d0
                MacCtx.MacState |= LORAMAC_TX_DELAYED;
 80334cc:	f043 0320 	orr.w	r3, r3, #32
 80334d0:	f8c4 3344 	str.w	r3, [r4, #836]	; 0x344
                TimerSetValue( &MacCtx.TxDelayedTimer, MacCtx.DutyCycleWaitTime );
 80334d4:	f007 ffbe 	bl	803b454 <UTIL_TIMER_SetPeriod>
                TimerStart( &MacCtx.TxDelayedTimer );
 80334d8:	f5a6 70e8 	sub.w	r0, r6, #464	; 0x1d0
 80334dc:	f007 ff80 	bl	803b3e0 <UTIL_TIMER_Start>
            return LORAMAC_STATUS_OK;
 80334e0:	2500      	movs	r5, #0
 80334e2:	e78e      	b.n	8033402 <ScheduleTx+0x36>
            serializeStatus = LoRaMacSerializerData( &MacCtx.TxMsg.Message.Data );
 80334e4:	4871      	ldr	r0, [pc, #452]	; (80336ac <ScheduleTx+0x2e0>)
 80334e6:	f003 f8a2 	bl	803662e <LoRaMacSerializerData>
 80334ea:	e79e      	b.n	803342a <ScheduleTx+0x5e>
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 80334ec:	f894 754c 	ldrb.w	r7, [r4, #1356]	; 0x54c
                                     RegionApplyDrOffset( Nvm.MacGroup2.Region,
 80334f0:	f994 356d 	ldrsb.w	r3, [r4, #1389]	; 0x56d
 80334f4:	f994 2545 	ldrsb.w	r2, [r4, #1349]	; 0x545
 80334f8:	f894 1581 	ldrb.w	r1, [r4, #1409]	; 0x581
 80334fc:	4638      	mov	r0, r7
 80334fe:	f003 f9fc 	bl	80368fa <RegionApplyDrOffset>
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 8033502:	f5a6 73c0 	sub.w	r3, r6, #384	; 0x180
 8033506:	b241      	sxtb	r1, r0
 8033508:	f894 2554 	ldrb.w	r2, [r4, #1364]	; 0x554
 803350c:	9300      	str	r3, [sp, #0]
 803350e:	4638      	mov	r0, r7
 8033510:	f8d4 3550 	ldr.w	r3, [r4, #1360]	; 0x550
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 8033514:	f5a6 76b6 	sub.w	r6, r6, #364	; 0x16c
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 8033518:	f003 f94d 	bl	80367b6 <RegionComputeRxWindowParameters>
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 803351c:	f8d4 3550 	ldr.w	r3, [r4, #1360]	; 0x550
 8033520:	f994 1574 	ldrsb.w	r1, [r4, #1396]	; 0x574
 8033524:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
 8033528:	9600      	str	r6, [sp, #0]
 803352a:	f894 2554 	ldrb.w	r2, [r4, #1364]	; 0x554
 803352e:	f003 f942 	bl	80367b6 <RegionComputeRxWindowParameters>
    MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.ReceiveDelay2 + MacCtx.RxWindow2Config.WindowOffset;
 8033532:	f8d4 03dc 	ldr.w	r0, [r4, #988]	; 0x3dc
 8033536:	f8d4 1560 	ldr.w	r1, [r4, #1376]	; 0x560
    MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.ReceiveDelay1 + MacCtx.RxWindow1Config.WindowOffset;
 803353a:	f8d4 63c8 	ldr.w	r6, [r4, #968]	; 0x3c8
 803353e:	f8d4 355c 	ldr.w	r3, [r4, #1372]	; 0x55c
    MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.ReceiveDelay2 + MacCtx.RxWindow2Config.WindowOffset;
 8033542:	4401      	add	r1, r0
 8033544:	f8c4 13b8 	str.w	r1, [r4, #952]	; 0x3b8
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 8033548:	f894 161c 	ldrb.w	r1, [r4, #1564]	; 0x61c
    MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.ReceiveDelay1 + MacCtx.RxWindow1Config.WindowOffset;
 803354c:	4433      	add	r3, r6
 803354e:	f8c4 33b4 	str.w	r3, [r4, #948]	; 0x3b4
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 8033552:	b949      	cbnz	r1, 8033568 <ScheduleTx+0x19c>
        MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay1 + MacCtx.RxWindow1Config.WindowOffset;
 8033554:	f8d4 2564 	ldr.w	r2, [r4, #1380]	; 0x564
        MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay2 + MacCtx.RxWindow2Config.WindowOffset;
 8033558:	f8d4 3568 	ldr.w	r3, [r4, #1384]	; 0x568
        MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay1 + MacCtx.RxWindow1Config.WindowOffset;
 803355c:	4432      	add	r2, r6
        MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay2 + MacCtx.RxWindow2Config.WindowOffset;
 803355e:	4403      	add	r3, r0
        MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay1 + MacCtx.RxWindow1Config.WindowOffset;
 8033560:	f8c4 23b4 	str.w	r2, [r4, #948]	; 0x3b4
        MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay2 + MacCtx.RxWindow2Config.WindowOffset;
 8033564:	f8c4 33b8 	str.w	r3, [r4, #952]	; 0x3b8
    size_t macCmdsSize = 0;
 8033568:	2300      	movs	r3, #0
 803356a:	9308      	str	r3, [sp, #32]
    if( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE )
 803356c:	b181      	cbz	r1, 8033590 <ScheduleTx+0x1c4>
        if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )
 803356e:	a808      	add	r0, sp, #32
 8033570:	f002 fae4 	bl	8035b3c <LoRaMacCommandsGetSizeSerializedCmds>
 8033574:	2800      	cmp	r0, #0
 8033576:	d14a      	bne.n	803360e <ScheduleTx+0x242>
    maxN = GetMaxAppPayloadWithoutFOptsLength( datarate );
 8033578:	f994 0545 	ldrsb.w	r0, [r4, #1349]	; 0x545
        if( ValidatePayloadLength( MacCtx.AppDataSize, Nvm.MacGroup1.ChannelsDatarate, macCmdsSize ) == false )
 803357c:	f894 623b 	ldrb.w	r6, [r4, #571]	; 0x23b
 8033580:	f89d 7020 	ldrb.w	r7, [sp, #32]
    maxN = GetMaxAppPayloadWithoutFOptsLength( datarate );
 8033584:	f7ff fd50 	bl	8033028 <GetMaxAppPayloadWithoutFOptsLength>
    if( ( payloadSize <= maxN ) && ( payloadSize <= LORAMAC_PHY_MAXPAYLOAD ) )
 8033588:	443e      	add	r6, r7
 803358a:	b280      	uxth	r0, r0
 803358c:	42b0      	cmp	r0, r6
 803358e:	d33c      	bcc.n	803360a <ScheduleTx+0x23e>
    int8_t txPower = 0;
 8033590:	2300      	movs	r3, #0
 8033592:	f88d 3013 	strb.w	r3, [sp, #19]
    txConfig.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 8033596:	f894 3545 	ldrb.w	r3, [r4, #1349]	; 0x545
 803359a:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
    txConfig.TxPower = Nvm.MacGroup1.ChannelsTxPower;
 803359e:	f894 3544 	ldrb.w	r3, [r4, #1348]	; 0x544
 80335a2:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    txConfig.MaxEirp = Nvm.MacGroup2.MacParams.MaxEirp;
 80335a6:	f8d4 3584 	ldr.w	r3, [r4, #1412]	; 0x584
 80335aa:	9309      	str	r3, [sp, #36]	; 0x24
    txConfig.AntennaGain = Nvm.MacGroup2.MacParams.AntennaGain;
 80335ac:	f8d4 3588 	ldr.w	r3, [r4, #1416]	; 0x588
 80335b0:	930a      	str	r3, [sp, #40]	; 0x28
    txConfig.PktLen = MacCtx.PktBufferLen;
 80335b2:	88a3      	ldrh	r3, [r4, #4]
    return SendFrameOnChannel( MacCtx.Channel );
 80335b4:	f894 6419 	ldrb.w	r6, [r4, #1049]	; 0x419
    txConfig.PktLen = MacCtx.PktBufferLen;
 80335b8:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
    RegionTxConfig( Nvm.MacGroup2.Region, &txConfig, &txPower, &MacCtx.TxTimeOnAir );
 80335bc:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
 80335c0:	4b3c      	ldr	r3, [pc, #240]	; (80336b4 <ScheduleTx+0x2e8>)
    txConfig.Channel = channel;
 80335c2:	f88d 6020 	strb.w	r6, [sp, #32]
    RegionTxConfig( Nvm.MacGroup2.Region, &txConfig, &txPower, &MacCtx.TxTimeOnAir );
 80335c6:	f10d 0213 	add.w	r2, sp, #19
 80335ca:	a908      	add	r1, sp, #32
 80335cc:	f003 f912 	bl	80367f4 <RegionTxConfig>
    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 80335d0:	2301      	movs	r3, #1
 80335d2:	f884 343d 	strb.w	r3, [r4, #1085]	; 0x43d
    MacCtx.McpsConfirm.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 80335d6:	f894 3545 	ldrb.w	r3, [r4, #1349]	; 0x545
 80335da:	f884 343e 	strb.w	r3, [r4, #1086]	; 0x43e
    MacCtx.McpsConfirm.TxPower = txPower;
 80335de:	f89d 3013 	ldrb.w	r3, [sp, #19]
 80335e2:	f884 343f 	strb.w	r3, [r4, #1087]	; 0x43f
    MacCtx.McpsConfirm.TxTimeOnAir = MacCtx.TxTimeOnAir;
 80335e6:	f8d4 341c 	ldr.w	r3, [r4, #1052]	; 0x41c
    MacCtx.McpsConfirm.Channel = channel;
 80335ea:	f8c4 644c 	str.w	r6, [r4, #1100]	; 0x44c
    MacCtx.McpsConfirm.TxTimeOnAir = MacCtx.TxTimeOnAir;
 80335ee:	f8c4 3444 	str.w	r3, [r4, #1092]	; 0x444
    MacCtx.MlmeConfirm.TxTimeOnAir = MacCtx.TxTimeOnAir;
 80335f2:	f8c4 3454 	str.w	r3, [r4, #1108]	; 0x454
    if( LoRaMacClassBIsBeaconModeActive( ) == true )
 80335f6:	f002 f9e2 	bl	80359be <LoRaMacClassBIsBeaconModeActive>
 80335fa:	b150      	cbz	r0, 8033612 <ScheduleTx+0x246>
        TimerTime_t collisionTime = LoRaMacClassBIsUplinkCollision( MacCtx.TxTimeOnAir );
 80335fc:	f8d4 041c 	ldr.w	r0, [r4, #1052]	; 0x41c
 8033600:	f002 f9ef 	bl	80359e2 <LoRaMacClassBIsUplinkCollision>
        if( collisionTime > 0 )
 8033604:	b128      	cbz	r0, 8033612 <ScheduleTx+0x246>
            return LORAMAC_STATUS_BUSY_UPLINK_COLLISION;
 8033606:	2510      	movs	r5, #16
    return SendFrameOnChannel( MacCtx.Channel );
 8033608:	e6fb      	b.n	8033402 <ScheduleTx+0x36>
            return LORAMAC_STATUS_LENGTH_ERROR;
 803360a:	2508      	movs	r5, #8
 803360c:	e6f9      	b.n	8033402 <ScheduleTx+0x36>
            return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 803360e:	2513      	movs	r5, #19
 8033610:	e6f7      	b.n	8033402 <ScheduleTx+0x36>
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 8033612:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 8033616:	2b01      	cmp	r3, #1
 8033618:	d101      	bne.n	803361e <ScheduleTx+0x252>
        LoRaMacClassBStopRxSlots( );
 803361a:	f002 f9e4 	bl	80359e6 <LoRaMacClassBStopRxSlots>
    LoRaMacClassBHaltBeaconing( );
 803361e:	f002 f9d1 	bl	80359c4 <LoRaMacClassBHaltBeaconing>
    uint32_t fCntUp = 0;
 8033622:	2300      	movs	r3, #0
 8033624:	9305      	str	r3, [sp, #20]
    switch( MacCtx.TxMsg.Type )
 8033626:	f894 3108 	ldrb.w	r3, [r4, #264]	; 0x108
    status = SecureFrame( Nvm.MacGroup1.ChannelsDatarate, MacCtx.Channel );
 803362a:	f994 6545 	ldrsb.w	r6, [r4, #1349]	; 0x545
 803362e:	f894 7419 	ldrb.w	r7, [r4, #1049]	; 0x419
    switch( MacCtx.TxMsg.Type )
 8033632:	b1bb      	cbz	r3, 8033664 <ScheduleTx+0x298>
 8033634:	2b04      	cmp	r3, #4
 8033636:	f47f aede 	bne.w	80333f6 <ScheduleTx+0x2a>
            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetFCntUp( &fCntUp ) )
 803363a:	a805      	add	r0, sp, #20
 803363c:	f002 fce2 	bl	8036004 <LoRaMacCryptoGetFCntUp>
 8033640:	bb68      	cbnz	r0, 803369e <ScheduleTx+0x2d2>
            if( ( MacCtx.ChannelsNbTransCounter >= 1 ) || ( MacCtx.AckTimeoutRetriesCounter > 1 ) )
 8033642:	f894 3414 	ldrb.w	r3, [r4, #1044]	; 0x414
 8033646:	b91b      	cbnz	r3, 8033650 <ScheduleTx+0x284>
 8033648:	f894 3416 	ldrb.w	r3, [r4, #1046]	; 0x416
 803364c:	2b01      	cmp	r3, #1
 803364e:	d902      	bls.n	8033656 <ScheduleTx+0x28a>
                fCntUp -= 1;
 8033650:	9b05      	ldr	r3, [sp, #20]
 8033652:	3b01      	subs	r3, #1
 8033654:	9305      	str	r3, [sp, #20]
            macCryptoStatus = LoRaMacCryptoSecureMessage( fCntUp, txDr, txCh, &MacCtx.TxMsg.Message.Data );
 8033656:	4b15      	ldr	r3, [pc, #84]	; (80336ac <ScheduleTx+0x2e0>)
 8033658:	9805      	ldr	r0, [sp, #20]
 803365a:	463a      	mov	r2, r7
 803365c:	b2f1      	uxtb	r1, r6
 803365e:	f002 fd47 	bl	80360f0 <LoRaMacCryptoSecureMessage>
 8033662:	e002      	b.n	803366a <ScheduleTx+0x29e>
            macCryptoStatus = LoRaMacCryptoPrepareJoinRequest( &MacCtx.TxMsg.Message.JoinReq );
 8033664:	4811      	ldr	r0, [pc, #68]	; (80336ac <ScheduleTx+0x2e0>)
 8033666:	f002 fd1b 	bl	80360a0 <LoRaMacCryptoPrepareJoinRequest>
            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )
 803366a:	b9b0      	cbnz	r0, 803369a <ScheduleTx+0x2ce>
            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.Data.BufSize;
 803366c:	f894 3110 	ldrb.w	r3, [r4, #272]	; 0x110
 8033670:	80a3      	strh	r3, [r4, #4]
    MacCtx.MacState |= LORAMAC_TX_RUNNING;
 8033672:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 8033676:	f043 0302 	orr.w	r3, r3, #2
 803367a:	f8c4 3344 	str.w	r3, [r4, #836]	; 0x344
    if( MacCtx.NodeAckRequested == false )
 803367e:	f894 3418 	ldrb.w	r3, [r4, #1048]	; 0x418
 8033682:	b923      	cbnz	r3, 803368e <ScheduleTx+0x2c2>
        MacCtx.ChannelsNbTransCounter++;
 8033684:	f894 3414 	ldrb.w	r3, [r4, #1044]	; 0x414
 8033688:	3301      	adds	r3, #1
 803368a:	f884 3414 	strb.w	r3, [r4, #1044]	; 0x414
    Radio.Send( MacCtx.PktBuffer, MacCtx.PktBufferLen );
 803368e:	4b0a      	ldr	r3, [pc, #40]	; (80336b8 <ScheduleTx+0x2ec>)
 8033690:	7921      	ldrb	r1, [r4, #4]
 8033692:	480a      	ldr	r0, [pc, #40]	; (80336bc <ScheduleTx+0x2f0>)
 8033694:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8033696:	4798      	blx	r3
    return LORAMAC_STATUS_OK;
 8033698:	e6b3      	b.n	8033402 <ScheduleTx+0x36>
                return LORAMAC_STATUS_CRYPTO_ERROR;
 803369a:	2511      	movs	r5, #17
 803369c:	e6b1      	b.n	8033402 <ScheduleTx+0x36>
                return LORAMAC_STATUS_FCNT_HANDLER_ERROR;
 803369e:	2512      	movs	r5, #18
 80336a0:	e6af      	b.n	8033402 <ScheduleTx+0x36>
        return LORAMAC_STATUS_BUSY_BEACON_RESERVED_TIME;
 80336a2:	250e      	movs	r5, #14
 80336a4:	e6ad      	b.n	8033402 <ScheduleTx+0x36>
 80336a6:	bf00      	nop
 80336a8:	20004aa4 	.word	0x20004aa4
 80336ac:	20004bb0 	.word	0x20004bb0
 80336b0:	20004fe0 	.word	0x20004fe0
 80336b4:	20004ec0 	.word	0x20004ec0
 80336b8:	0803bc30 	.word	0x0803bc30
 80336bc:	20004aaa 	.word	0x20004aaa

080336c0 <OnTxDelayedTimerEvent>:
{
 80336c0:	b510      	push	{r4, lr}
    TimerStop( &MacCtx.TxDelayedTimer );
 80336c2:	4c11      	ldr	r4, [pc, #68]	; (8033708 <OnTxDelayedTimerEvent+0x48>)
 80336c4:	f504 705b 	add.w	r0, r4, #876	; 0x36c
 80336c8:	f007 fe3a 	bl	803b340 <UTIL_TIMER_Stop>
    MacCtx.MacState &= ~LORAMAC_TX_DELAYED;
 80336cc:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
    switch( ScheduleTx( true ) )
 80336d0:	2001      	movs	r0, #1
    MacCtx.MacState &= ~LORAMAC_TX_DELAYED;
 80336d2:	f023 0320 	bic.w	r3, r3, #32
 80336d6:	f8c4 3344 	str.w	r3, [r4, #836]	; 0x344
    switch( ScheduleTx( true ) )
 80336da:	f7ff fe77 	bl	80333cc <ScheduleTx>
 80336de:	b190      	cbz	r0, 8033706 <OnTxDelayedTimerEvent+0x46>
 80336e0:	280b      	cmp	r0, #11
 80336e2:	d010      	beq.n	8033706 <OnTxDelayedTimerEvent+0x46>
            MacCtx.McpsConfirm.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 80336e4:	f894 3545 	ldrb.w	r3, [r4, #1349]	; 0x545
 80336e8:	f884 343e 	strb.w	r3, [r4, #1086]	; 0x43e
            MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR;
 80336ec:	2009      	movs	r0, #9
            MacCtx.McpsConfirm.NbRetries = MacCtx.AckTimeoutRetriesCounter;
 80336ee:	f894 3416 	ldrb.w	r3, [r4, #1046]	; 0x416
 80336f2:	f884 3441 	strb.w	r3, [r4, #1089]	; 0x441
            MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR;
 80336f6:	f884 043d 	strb.w	r0, [r4, #1085]	; 0x43d
            LoRaMacConfirmQueueSetStatusCmn( LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR );
 80336fa:	f002 fb07 	bl	8035d0c <LoRaMacConfirmQueueSetStatusCmn>
}
 80336fe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            StopRetransmission( );
 8033702:	f7ff bc6f 	b.w	8032fe4 <StopRetransmission>
}
 8033706:	bd10      	pop	{r4, pc}
 8033708:	20004aa4 	.word	0x20004aa4

0803370c <OpenContinuousRxCWindow>:
{
 803370c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 803370e:	4c12      	ldr	r4, [pc, #72]	; (8033758 <OpenContinuousRxCWindow+0x4c>)
 8033710:	f504 7579 	add.w	r5, r4, #996	; 0x3e4
 8033714:	f8d4 3550 	ldr.w	r3, [r4, #1360]	; 0x550
 8033718:	f894 2554 	ldrb.w	r2, [r4, #1364]	; 0x554
 803371c:	f994 157c 	ldrsb.w	r1, [r4, #1404]	; 0x57c
 8033720:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
 8033724:	9500      	str	r5, [sp, #0]
 8033726:	f003 f846 	bl	80367b6 <RegionComputeRxWindowParameters>
    MacCtx.RxWindowCConfig.RxContinuous = true;
 803372a:	f240 2301 	movw	r3, #513	; 0x201
    if( RegionRxConfig( Nvm.MacGroup2.Region, &MacCtx.RxWindowCConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )
 803372e:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    MacCtx.RxWindowCConfig.RxContinuous = true;
 8033732:	f8a4 33f6 	strh.w	r3, [r4, #1014]	; 0x3f6
    if( RegionRxConfig( Nvm.MacGroup2.Region, &MacCtx.RxWindowCConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )
 8033736:	f204 4224 	addw	r2, r4, #1060	; 0x424
 803373a:	4629      	mov	r1, r5
 803373c:	f003 f84d 	bl	80367da <RegionRxConfig>
 8033740:	b138      	cbz	r0, 8033752 <OpenContinuousRxCWindow+0x46>
        Radio.Rx( 0 ); // Continuous mode
 8033742:	4b06      	ldr	r3, [pc, #24]	; (803375c <OpenContinuousRxCWindow+0x50>)
 8033744:	2000      	movs	r0, #0
 8033746:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8033748:	4798      	blx	r3
        MacCtx.RxSlot = MacCtx.RxWindowCConfig.RxSlot;
 803374a:	f894 33f7 	ldrb.w	r3, [r4, #1015]	; 0x3f7
 803374e:	f884 3484 	strb.w	r3, [r4, #1156]	; 0x484
}
 8033752:	b003      	add	sp, #12
 8033754:	bd30      	pop	{r4, r5, pc}
 8033756:	bf00      	nop
 8033758:	20004aa4 	.word	0x20004aa4
 803375c:	0803bc30 	.word	0x0803bc30

08033760 <SwitchClass>:
{
 8033760:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    switch( Nvm.MacGroup2.DeviceClass )
 8033762:	4f2f      	ldr	r7, [pc, #188]	; (8033820 <SwitchClass+0xc0>)
 8033764:	f897 5608 	ldrb.w	r5, [r7, #1544]	; 0x608
 8033768:	2d01      	cmp	r5, #1
{
 803376a:	4606      	mov	r6, r0
 803376c:	463c      	mov	r4, r7
    switch( Nvm.MacGroup2.DeviceClass )
 803376e:	d046      	beq.n	80337fe <SwitchClass+0x9e>
 8033770:	2d02      	cmp	r5, #2
 8033772:	d04c      	beq.n	803380e <SwitchClass+0xae>
 8033774:	b945      	cbnz	r5, 8033788 <SwitchClass+0x28>
            if( deviceClass == CLASS_A )
 8033776:	b948      	cbnz	r0, 803378c <SwitchClass+0x2c>
                Nvm.MacGroup2.MacParams.RxCChannel = Nvm.MacGroup2.MacParams.Rx2Channel;
 8033778:	f8d7 1574 	ldr.w	r1, [r7, #1396]	; 0x574
 803377c:	f8d7 0570 	ldr.w	r0, [r7, #1392]	; 0x570
 8033780:	f507 63af 	add.w	r3, r7, #1400	; 0x578
 8033784:	e883 0003 	stmia.w	r3, {r0, r1}
    LoRaMacStatus_t status = LORAMAC_STATUS_PARAMETER_INVALID;
 8033788:	2503      	movs	r5, #3
 803378a:	e036      	b.n	80337fa <SwitchClass+0x9a>
            if( deviceClass == CLASS_B )
 803378c:	2801      	cmp	r0, #1
 803378e:	d036      	beq.n	80337fe <SwitchClass+0x9e>
            if( deviceClass == CLASS_C )
 8033790:	2802      	cmp	r0, #2
 8033792:	d1f9      	bne.n	8033788 <SwitchClass+0x28>
                MacCtx.RxWindowCConfig = MacCtx.RxWindow2Config;
 8033794:	f504 7c74 	add.w	ip, r4, #976	; 0x3d0
                Nvm.MacGroup2.DeviceClass = deviceClass;
 8033798:	f884 0608 	strb.w	r0, [r4, #1544]	; 0x608
                MacCtx.RxWindowCConfig = MacCtx.RxWindow2Config;
 803379c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80337a0:	f507 7779 	add.w	r7, r7, #996	; 0x3e4
 80337a4:	c70f      	stmia	r7!, {r0, r1, r2, r3}
 80337a6:	f8dc 3000 	ldr.w	r3, [ip]
 80337aa:	603b      	str	r3, [r7, #0]
                    if( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.IsEnabled == true )
 80337ac:	f894 35de 	ldrb.w	r3, [r4, #1502]	; 0x5de
                MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C;
 80337b0:	f884 63f7 	strb.w	r6, [r4, #1015]	; 0x3f7
                    if( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.IsEnabled == true )
 80337b4:	b1cb      	cbz	r3, 80337ea <SwitchClass+0x8a>
                        Nvm.MacGroup2.MacParams.RxCChannel.Frequency = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.RxParams.ClassC.Frequency;
 80337b6:	f8d4 35f4 	ldr.w	r3, [r4, #1524]	; 0x5f4
 80337ba:	f8c4 3578 	str.w	r3, [r4, #1400]	; 0x578
                        MacCtx.RxWindowCConfig.Frequency = Nvm.MacGroup2.MacParams.RxCChannel.Frequency;
 80337be:	f8c4 33e8 	str.w	r3, [r4, #1000]	; 0x3e8
                        MacCtx.RxWindowCConfig.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 80337c2:	f894 3581 	ldrb.w	r3, [r4, #1409]	; 0x581
                        Nvm.MacGroup2.MacParams.RxCChannel.Datarate = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.RxParams.ClassC.Datarate;
 80337c6:	f894 25f8 	ldrb.w	r2, [r4, #1528]	; 0x5f8
                        MacCtx.RxWindowCConfig.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 80337ca:	f884 33f4 	strb.w	r3, [r4, #1012]	; 0x3f4
                        MacCtx.RxWindowCConfig.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport; /* ST_WORKAROUND: Keep repeater feature */
 80337ce:	f894 358c 	ldrb.w	r3, [r4, #1420]	; 0x58c
                        Nvm.MacGroup2.MacParams.RxCChannel.Datarate = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.RxParams.ClassC.Datarate;
 80337d2:	f884 257c 	strb.w	r2, [r4, #1404]	; 0x57c
                        MacCtx.RxWindowCConfig.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport; /* ST_WORKAROUND: Keep repeater feature */
 80337d6:	f884 33f5 	strb.w	r3, [r4, #1013]	; 0x3f5
                        MacCtx.RxWindowCConfig.Channel = MacCtx.Channel;
 80337da:	f894 2419 	ldrb.w	r2, [r4, #1049]	; 0x419
 80337de:	f884 23e4 	strb.w	r2, [r4, #996]	; 0x3e4
                        MacCtx.RxWindowCConfig.RxContinuous = true;
 80337e2:	f240 3301 	movw	r3, #769	; 0x301
 80337e6:	f8a4 33f6 	strh.w	r3, [r4, #1014]	; 0x3f6
                MacCtx.NodeAckRequested = false;
 80337ea:	2300      	movs	r3, #0
 80337ec:	f884 3418 	strb.w	r3, [r4, #1048]	; 0x418
                Radio.Sleep( );
 80337f0:	4b0c      	ldr	r3, [pc, #48]	; (8033824 <SwitchClass+0xc4>)
 80337f2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80337f4:	4798      	blx	r3
                OpenContinuousRxCWindow( );
 80337f6:	f7ff ff89 	bl	803370c <OpenContinuousRxCWindow>
}
 80337fa:	4628      	mov	r0, r5
 80337fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            status = LoRaMacClassBSwitchClass( deviceClass );
 80337fe:	f002 f8e3 	bl	80359c8 <LoRaMacClassBSwitchClass>
            if( status == LORAMAC_STATUS_OK )
 8033802:	4605      	mov	r5, r0
 8033804:	2800      	cmp	r0, #0
 8033806:	d1f8      	bne.n	80337fa <SwitchClass+0x9a>
                Nvm.MacGroup2.DeviceClass = deviceClass;
 8033808:	f887 6608 	strb.w	r6, [r7, #1544]	; 0x608
 803380c:	e7f5      	b.n	80337fa <SwitchClass+0x9a>
            if( deviceClass == CLASS_A )
 803380e:	2800      	cmp	r0, #0
 8033810:	d1ba      	bne.n	8033788 <SwitchClass+0x28>
                Radio.Sleep( );
 8033812:	4b04      	ldr	r3, [pc, #16]	; (8033824 <SwitchClass+0xc4>)
                Nvm.MacGroup2.DeviceClass = deviceClass;
 8033814:	f887 0608 	strb.w	r0, [r7, #1544]	; 0x608
                Radio.Sleep( );
 8033818:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 803381a:	4798      	blx	r3
                status = LORAMAC_STATUS_OK;
 803381c:	4635      	mov	r5, r6
 803381e:	e7ec      	b.n	80337fa <SwitchClass+0x9a>
 8033820:	20004aa4 	.word	0x20004aa4
 8033824:	0803bc30 	.word	0x0803bc30

08033828 <RxWindowSetup.constprop.0>:
static void RxWindowSetup( TimerEvent_t* rxTimer, RxConfigParams_t* rxConfig )
 8033828:	b570      	push	{r4, r5, r6, lr}
    Radio.Standby( );
 803382a:	4e0b      	ldr	r6, [pc, #44]	; (8033858 <RxWindowSetup.constprop.0+0x30>)
    if( RegionRxConfig( Nvm.MacGroup2.Region, rxConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )
 803382c:	4c0b      	ldr	r4, [pc, #44]	; (803385c <RxWindowSetup.constprop.0+0x34>)
static void RxWindowSetup( TimerEvent_t* rxTimer, RxConfigParams_t* rxConfig )
 803382e:	460d      	mov	r5, r1
    TimerStop( rxTimer );
 8033830:	f007 fd86 	bl	803b340 <UTIL_TIMER_Stop>
    Radio.Standby( );
 8033834:	6b33      	ldr	r3, [r6, #48]	; 0x30
 8033836:	4798      	blx	r3
    if( RegionRxConfig( Nvm.MacGroup2.Region, rxConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )
 8033838:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
 803383c:	f204 4224 	addw	r2, r4, #1060	; 0x424
 8033840:	4629      	mov	r1, r5
 8033842:	f002 ffca 	bl	80367da <RegionRxConfig>
 8033846:	b130      	cbz	r0, 8033856 <RxWindowSetup.constprop.0+0x2e>
        Radio.Rx( Nvm.MacGroup2.MacParams.MaxRxWindow );
 8033848:	6b73      	ldr	r3, [r6, #52]	; 0x34
 803384a:	f8d4 0558 	ldr.w	r0, [r4, #1368]	; 0x558
 803384e:	4798      	blx	r3
        MacCtx.RxSlot = rxConfig->RxSlot;
 8033850:	7ceb      	ldrb	r3, [r5, #19]
 8033852:	f884 3484 	strb.w	r3, [r4, #1156]	; 0x484
}
 8033856:	bd70      	pop	{r4, r5, r6, pc}
 8033858:	0803bc30 	.word	0x0803bc30
 803385c:	20004aa4 	.word	0x20004aa4

08033860 <OnRxWindow1TimerEvent>:
    MacCtx.RxWindow1Config.Channel = MacCtx.Channel;
 8033860:	480c      	ldr	r0, [pc, #48]	; (8033894 <OnRxWindow1TimerEvent+0x34>)
 8033862:	f890 3419 	ldrb.w	r3, [r0, #1049]	; 0x419
 8033866:	f880 33bc 	strb.w	r3, [r0, #956]	; 0x3bc
    MacCtx.RxWindow1Config.DrOffset = Nvm.MacGroup2.MacParams.Rx1DrOffset;
 803386a:	f890 356d 	ldrb.w	r3, [r0, #1389]	; 0x56d
 803386e:	f880 33bf 	strb.w	r3, [r0, #959]	; 0x3bf
    MacCtx.RxWindow1Config.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 8033872:	f890 3581 	ldrb.w	r3, [r0, #1409]	; 0x581
 8033876:	f880 33cc 	strb.w	r3, [r0, #972]	; 0x3cc
    MacCtx.RxWindow1Config.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport; /* ST_WORKAROUND: Keep repeater feature */
 803387a:	f890 358c 	ldrb.w	r3, [r0, #1420]	; 0x58c
 803387e:	f880 33cd 	strb.w	r3, [r0, #973]	; 0x3cd
    MacCtx.RxWindow1Config.RxContinuous = false;
 8033882:	2300      	movs	r3, #0
 8033884:	f8a0 33ce 	strh.w	r3, [r0, #974]	; 0x3ce
    RxWindowSetup( &MacCtx.RxWindowTimer1, &MacCtx.RxWindow1Config );
 8033888:	f500 716f 	add.w	r1, r0, #956	; 0x3bc
 803388c:	f500 7061 	add.w	r0, r0, #900	; 0x384
 8033890:	f7ff bfca 	b.w	8033828 <RxWindowSetup.constprop.0>
 8033894:	20004aa4 	.word	0x20004aa4

08033898 <OnRxWindow2TimerEvent>:
    if( MacCtx.RxSlot == RX_SLOT_WIN_1 )
 8033898:	480f      	ldr	r0, [pc, #60]	; (80338d8 <OnRxWindow2TimerEvent+0x40>)
 803389a:	f890 3484 	ldrb.w	r3, [r0, #1156]	; 0x484
 803389e:	b1cb      	cbz	r3, 80338d4 <OnRxWindow2TimerEvent+0x3c>
    MacCtx.RxWindow2Config.Channel = MacCtx.Channel;
 80338a0:	f890 3419 	ldrb.w	r3, [r0, #1049]	; 0x419
 80338a4:	f880 33d0 	strb.w	r3, [r0, #976]	; 0x3d0
    MacCtx.RxWindow2Config.Frequency = Nvm.MacGroup2.MacParams.Rx2Channel.Frequency;
 80338a8:	f8d0 3570 	ldr.w	r3, [r0, #1392]	; 0x570
 80338ac:	f8c0 33d4 	str.w	r3, [r0, #980]	; 0x3d4
    MacCtx.RxWindow2Config.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 80338b0:	f890 3581 	ldrb.w	r3, [r0, #1409]	; 0x581
 80338b4:	f880 33e0 	strb.w	r3, [r0, #992]	; 0x3e0
    MacCtx.RxWindow2Config.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport; /* ST_WORKAROUND: Keep repeater feature */
 80338b8:	f890 358c 	ldrb.w	r3, [r0, #1420]	; 0x58c
 80338bc:	f880 33e1 	strb.w	r3, [r0, #993]	; 0x3e1
    MacCtx.RxWindow2Config.RxContinuous = false;
 80338c0:	f44f 7380 	mov.w	r3, #256	; 0x100
 80338c4:	f8a0 33e2 	strh.w	r3, [r0, #994]	; 0x3e2
    RxWindowSetup( &MacCtx.RxWindowTimer2, &MacCtx.RxWindow2Config );
 80338c8:	f500 7174 	add.w	r1, r0, #976	; 0x3d0
 80338cc:	f500 7067 	add.w	r0, r0, #924	; 0x39c
 80338d0:	f7ff bfaa 	b.w	8033828 <RxWindowSetup.constprop.0>
}
 80338d4:	4770      	bx	lr
 80338d6:	bf00      	nop
 80338d8:	20004aa4 	.word	0x20004aa4

080338dc <ProcessMacCommands.isra.0.constprop.0>:
static void ProcessMacCommands( uint8_t *payload, uint8_t macIndex, uint8_t commandsSize, int8_t snr, LoRaMacRxSlot_t rxSlot )
 80338dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80338e0:	b091      	sub	sp, #68	; 0x44
    uint8_t status = 0;
 80338e2:	2700      	movs	r7, #0
                    if( ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_PING_SLOT ) && ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT ) )
 80338e4:	4dc3      	ldr	r5, [pc, #780]	; (8033bf4 <ProcessMacCommands.isra.0.constprop.0+0x318>)
    uint8_t status = 0;
 80338e6:	f88d 7015 	strb.w	r7, [sp, #21]
static void ProcessMacCommands( uint8_t *payload, uint8_t macIndex, uint8_t commandsSize, int8_t snr, LoRaMacRxSlot_t rxSlot )
 80338ea:	4606      	mov	r6, r0
 80338ec:	4688      	mov	r8, r1
 80338ee:	4693      	mov	fp, r2
    uint8_t macCmdPayload[2] = { 0x00, 0x00 };
 80338f0:	f8ad 7018 	strh.w	r7, [sp, #24]
    while( macIndex < commandsSize )
 80338f4:	46b9      	mov	r9, r7
 80338f6:	45c1      	cmp	r9, r8
 80338f8:	d302      	bcc.n	8033900 <ProcessMacCommands.isra.0.constprop.0+0x24>
}
 80338fa:	b011      	add	sp, #68	; 0x44
 80338fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if( ( LoRaMacCommandsGetCmdSize( payload[macIndex] ) + macIndex ) > commandsSize )
 8033900:	f816 0009 	ldrb.w	r0, [r6, r9]
 8033904:	f002 f96c 	bl	8035be0 <LoRaMacCommandsGetCmdSize>
 8033908:	4448      	add	r0, r9
 803390a:	4540      	cmp	r0, r8
 803390c:	dcf5      	bgt.n	80338fa <ProcessMacCommands.isra.0.constprop.0+0x1e>
        switch( payload[macIndex++] )
 803390e:	f816 3009 	ldrb.w	r3, [r6, r9]
 8033912:	f109 0401 	add.w	r4, r9, #1
 8033916:	3b02      	subs	r3, #2
 8033918:	b2e4      	uxtb	r4, r4
 803391a:	2b11      	cmp	r3, #17
 803391c:	d8ed      	bhi.n	80338fa <ProcessMacCommands.isra.0.constprop.0+0x1e>
 803391e:	a201      	add	r2, pc, #4	; (adr r2, 8033924 <ProcessMacCommands.isra.0.constprop.0+0x48>)
 8033920:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8033924:	0803396d 	.word	0x0803396d
 8033928:	0803399d 	.word	0x0803399d
 803392c:	08033a59 	.word	0x08033a59
 8033930:	08033a81 	.word	0x08033a81
 8033934:	08033b19 	.word	0x08033b19
 8033938:	08033b41 	.word	0x08033b41
 803393c:	08033bb3 	.word	0x08033bb3
 8033940:	08033bf9 	.word	0x08033bf9
 8033944:	08033c81 	.word	0x08033c81
 8033948:	080338fb 	.word	0x080338fb
 803394c:	080338fb 	.word	0x080338fb
 8033950:	08033cdf 	.word	0x08033cdf
 8033954:	080338fb 	.word	0x080338fb
 8033958:	080338fb 	.word	0x080338fb
 803395c:	08033d95 	.word	0x08033d95
 8033960:	08033dbb 	.word	0x08033dbb
 8033964:	08033dff 	.word	0x08033dff
 8033968:	08033e3d 	.word	0x08033e3d
                if( LoRaMacConfirmQueueIsCmdActive( MLME_LINK_CHECK ) == true )
 803396c:	2004      	movs	r0, #4
 803396e:	f002 f9e7 	bl	8035d40 <LoRaMacConfirmQueueIsCmdActive>
 8033972:	b188      	cbz	r0, 8033998 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_LINK_CHECK );
 8033974:	2104      	movs	r1, #4
 8033976:	2000      	movs	r0, #0
 8033978:	f002 f9a6 	bl	8035cc8 <LoRaMacConfirmQueueSetStatus>
                    MacCtx.MlmeConfirm.DemodMargin = payload[macIndex++];
 803397c:	5d33      	ldrb	r3, [r6, r4]
 803397e:	f885 3458 	strb.w	r3, [r5, #1112]	; 0x458
                    MacCtx.MlmeConfirm.NbGateways = payload[macIndex++];
 8033982:	f109 0403 	add.w	r4, r9, #3
                    MacCtx.MlmeConfirm.DemodMargin = payload[macIndex++];
 8033986:	f109 0902 	add.w	r9, r9, #2
                    MacCtx.MlmeConfirm.NbGateways = payload[macIndex++];
 803398a:	fa5f f989 	uxtb.w	r9, r9
 803398e:	b2e4      	uxtb	r4, r4
 8033990:	f816 3009 	ldrb.w	r3, [r6, r9]
 8033994:	f885 3459 	strb.w	r3, [r5, #1113]	; 0x459
                uint8_t eirpDwellTime = payload[macIndex++];
 8033998:	46a1      	mov	r9, r4
 803399a:	e7ac      	b.n	80338f6 <ProcessMacCommands.isra.0.constprop.0+0x1a>
                int8_t linkAdrDatarate = DR_0;
 803399c:	2300      	movs	r3, #0
 803399e:	f88d 3016 	strb.w	r3, [sp, #22]
                int8_t linkAdrTxPower = TX_POWER_0;
 80339a2:	f88d 3017 	strb.w	r3, [sp, #23]
                uint8_t linkAdrNbRep = 0;
 80339a6:	f88d 301c 	strb.w	r3, [sp, #28]
                uint8_t linkAdrNbBytesParsed = 0;
 80339aa:	f88d 3020 	strb.w	r3, [sp, #32]
                if( adrBlockFound == false )
 80339ae:	2f00      	cmp	r7, #0
 80339b0:	d150      	bne.n	8033a54 <ProcessMacCommands.isra.0.constprop.0+0x178>
                    linkAdrReq.PayloadSize = commandsSize - ( macIndex - 1 );
 80339b2:	eba8 0309 	sub.w	r3, r8, r9
 80339b6:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
                    linkAdrReq.AdrEnabled = Nvm.MacGroup2.AdrCtrlOn;
 80339ba:	f895 360a 	ldrb.w	r3, [r5, #1546]	; 0x60a
 80339be:	f88d 303a 	strb.w	r3, [sp, #58]	; 0x3a
                    linkAdrReq.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 80339c2:	f895 3580 	ldrb.w	r3, [r5, #1408]	; 0x580
 80339c6:	f88d 3039 	strb.w	r3, [sp, #57]	; 0x39
                    linkAdrReq.CurrentDatarate = Nvm.MacGroup1.ChannelsDatarate;
 80339ca:	f895 3545 	ldrb.w	r3, [r5, #1349]	; 0x545
 80339ce:	f88d 303b 	strb.w	r3, [sp, #59]	; 0x3b
                    linkAdrReq.CurrentTxPower = Nvm.MacGroup1.ChannelsTxPower;
 80339d2:	f895 3544 	ldrb.w	r3, [r5, #1348]	; 0x544
 80339d6:	f88d 303c 	strb.w	r3, [sp, #60]	; 0x3c
                    linkAdrReq.CurrentNbRep = Nvm.MacGroup2.MacParams.ChannelsNbTrans;
 80339da:	f895 356c 	ldrb.w	r3, [r5, #1388]	; 0x56c
 80339de:	f88d 303d 	strb.w	r3, [sp, #61]	; 0x3d
                    linkAdrReq.Version = Nvm.MacGroup2.Version;
 80339e2:	f8d5 3618 	ldr.w	r3, [r5, #1560]	; 0x618
 80339e6:	930c      	str	r3, [sp, #48]	; 0x30
                    status = RegionLinkAdrReq( Nvm.MacGroup2.Region, &linkAdrReq, &linkAdrDatarate,
 80339e8:	ab08      	add	r3, sp, #32
 80339ea:	9301      	str	r3, [sp, #4]
                    linkAdrReq.Payload = &payload[macIndex - 1];
 80339ec:	3c01      	subs	r4, #1
                    status = RegionLinkAdrReq( Nvm.MacGroup2.Region, &linkAdrReq, &linkAdrDatarate,
 80339ee:	ab07      	add	r3, sp, #28
 80339f0:	9300      	str	r3, [sp, #0]
 80339f2:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
                    linkAdrReq.Payload = &payload[macIndex - 1];
 80339f6:	4434      	add	r4, r6
                    status = RegionLinkAdrReq( Nvm.MacGroup2.Region, &linkAdrReq, &linkAdrDatarate,
 80339f8:	f10d 0317 	add.w	r3, sp, #23
 80339fc:	f10d 0216 	add.w	r2, sp, #22
 8033a00:	a90c      	add	r1, sp, #48	; 0x30
                    linkAdrReq.Payload = &payload[macIndex - 1];
 8033a02:	940d      	str	r4, [sp, #52]	; 0x34
                    status = RegionLinkAdrReq( Nvm.MacGroup2.Region, &linkAdrReq, &linkAdrDatarate,
 8033a04:	f002 ff08 	bl	8036818 <RegionLinkAdrReq>
 8033a08:	f88d 0015 	strb.w	r0, [sp, #21]
                    if( ( status & 0x07 ) == 0x07 )
 8033a0c:	f000 0007 	and.w	r0, r0, #7
 8033a10:	2807      	cmp	r0, #7
 8033a12:	d10b      	bne.n	8033a2c <ProcessMacCommands.isra.0.constprop.0+0x150>
                        Nvm.MacGroup1.ChannelsDatarate = linkAdrDatarate;
 8033a14:	f89d 3016 	ldrb.w	r3, [sp, #22]
 8033a18:	f885 3545 	strb.w	r3, [r5, #1349]	; 0x545
                        Nvm.MacGroup1.ChannelsTxPower = linkAdrTxPower;
 8033a1c:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8033a20:	f885 3544 	strb.w	r3, [r5, #1348]	; 0x544
                        Nvm.MacGroup2.MacParams.ChannelsNbTrans = linkAdrNbRep;
 8033a24:	f89d 301c 	ldrb.w	r3, [sp, #28]
 8033a28:	f885 356c 	strb.w	r3, [r5, #1388]	; 0x56c
static void ProcessMacCommands( uint8_t *payload, uint8_t macIndex, uint8_t commandsSize, int8_t snr, LoRaMacRxSlot_t rxSlot )
 8033a2c:	2700      	movs	r7, #0
                    for( uint8_t i = 0; i < ( linkAdrNbBytesParsed / 5 ); i++ )
 8033a2e:	f04f 0a05 	mov.w	sl, #5
 8033a32:	e006      	b.n	8033a42 <ProcessMacCommands.isra.0.constprop.0+0x166>
                        LoRaMacCommandsAddCmd( MOTE_MAC_LINK_ADR_ANS, &status, 1 );
 8033a34:	2201      	movs	r2, #1
 8033a36:	f10d 0115 	add.w	r1, sp, #21
 8033a3a:	2003      	movs	r0, #3
 8033a3c:	f001 ffe4 	bl	8035a08 <LoRaMacCommandsAddCmd>
                    for( uint8_t i = 0; i < ( linkAdrNbBytesParsed / 5 ); i++ )
 8033a40:	3701      	adds	r7, #1
 8033a42:	b2fb      	uxtb	r3, r7
 8033a44:	f89d 4020 	ldrb.w	r4, [sp, #32]
 8033a48:	fbb4 f2fa 	udiv	r2, r4, sl
 8033a4c:	429a      	cmp	r2, r3
 8033a4e:	d8f1      	bhi.n	8033a34 <ProcessMacCommands.isra.0.constprop.0+0x158>
                    macIndex += linkAdrNbBytesParsed - 1;
 8033a50:	444c      	add	r4, r9
 8033a52:	b2e4      	uxtb	r4, r4
                break;
 8033a54:	2701      	movs	r7, #1
 8033a56:	e79f      	b.n	8033998 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                Nvm.MacGroup2.MaxDCycle = payload[macIndex++] & 0x0F;
 8033a58:	5d33      	ldrb	r3, [r6, r4]
                Nvm.MacGroup2.AggregatedDCycle = 1 << Nvm.MacGroup2.MaxDCycle;
 8033a5a:	2201      	movs	r2, #1
                Nvm.MacGroup2.MaxDCycle = payload[macIndex++] & 0x0F;
 8033a5c:	f003 030f 	and.w	r3, r3, #15
 8033a60:	f109 0902 	add.w	r9, r9, #2
 8033a64:	f885 360b 	strb.w	r3, [r5, #1547]	; 0x60b
                Nvm.MacGroup2.AggregatedDCycle = 1 << Nvm.MacGroup2.MaxDCycle;
 8033a68:	fa02 f303 	lsl.w	r3, r2, r3
                Nvm.MacGroup2.MaxDCycle = payload[macIndex++] & 0x0F;
 8033a6c:	fa5f f989 	uxtb.w	r9, r9
                Nvm.MacGroup2.AggregatedDCycle = 1 << Nvm.MacGroup2.MaxDCycle;
 8033a70:	f8a5 360e 	strh.w	r3, [r5, #1550]	; 0x60e
                LoRaMacCommandsAddCmd( MOTE_MAC_DUTY_CYCLE_ANS, macCmdPayload, 0 );
 8033a74:	2200      	movs	r2, #0
 8033a76:	a906      	add	r1, sp, #24
 8033a78:	2004      	movs	r0, #4
                    LoRaMacCommandsAddCmd( MOTE_MAC_TX_PARAM_SETUP_ANS, macCmdPayload, 0 );
 8033a7a:	f001 ffc5 	bl	8035a08 <LoRaMacCommandsAddCmd>
                break;
 8033a7e:	e0b7      	b.n	8033bf0 <ProcessMacCommands.isra.0.constprop.0+0x314>
                status = 0x07;
 8033a80:	2307      	movs	r3, #7
 8033a82:	f88d 3015 	strb.w	r3, [sp, #21]
                rxParamSetupReq.DrOffset = ( payload[macIndex] >> 4 ) & 0x07;
 8033a86:	5d33      	ldrb	r3, [r6, r4]
                status = RegionRxParamSetupReq( Nvm.MacGroup2.Region, &rxParamSetupReq );
 8033a88:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
                rxParamSetupReq.DrOffset = ( payload[macIndex] >> 4 ) & 0x07;
 8033a8c:	f3c3 1202 	ubfx	r2, r3, #4, #3
                rxParamSetupReq.Datarate = payload[macIndex] & 0x0F;
 8033a90:	f003 030f 	and.w	r3, r3, #15
                rxParamSetupReq.DrOffset = ( payload[macIndex] >> 4 ) & 0x07;
 8033a94:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
                rxParamSetupReq.Datarate = payload[macIndex] & 0x0F;
 8033a98:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033a9c:	f109 0204 	add.w	r2, r9, #4
                rxParamSetupReq.Frequency = ( uint32_t ) payload[macIndex++];
 8033aa0:	f109 0303 	add.w	r3, r9, #3
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033aa4:	b2db      	uxtb	r3, r3
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033aa6:	b2d2      	uxtb	r2, r2
 8033aa8:	f109 0405 	add.w	r4, r9, #5
                macIndex++;
 8033aac:	f109 0902 	add.w	r9, r9, #2
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033ab0:	5cf1      	ldrb	r1, [r6, r3]
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033ab2:	5cb3      	ldrb	r3, [r6, r2]
                rxParamSetupReq.Frequency = ( uint32_t ) payload[macIndex++];
 8033ab4:	fa5f f989 	uxtb.w	r9, r9
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033ab8:	041b      	lsls	r3, r3, #16
                rxParamSetupReq.Frequency = ( uint32_t ) payload[macIndex++];
 8033aba:	f816 2009 	ldrb.w	r2, [r6, r9]
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033abe:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8033ac2:	4313      	orrs	r3, r2
                rxParamSetupReq.Frequency *= 100;
 8033ac4:	2264      	movs	r2, #100	; 0x64
 8033ac6:	4353      	muls	r3, r2
                status = RegionRxParamSetupReq( Nvm.MacGroup2.Region, &rxParamSetupReq );
 8033ac8:	a90c      	add	r1, sp, #48	; 0x30
                rxParamSetupReq.Frequency *= 100;
 8033aca:	930d      	str	r3, [sp, #52]	; 0x34
                status = RegionRxParamSetupReq( Nvm.MacGroup2.Region, &rxParamSetupReq );
 8033acc:	f002 feba 	bl	8036844 <RegionRxParamSetupReq>
                if( ( status & 0x07 ) == 0x07 )
 8033ad0:	f000 0307 	and.w	r3, r0, #7
 8033ad4:	2b07      	cmp	r3, #7
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033ad6:	b2e4      	uxtb	r4, r4
                status = RegionRxParamSetupReq( Nvm.MacGroup2.Region, &rxParamSetupReq );
 8033ad8:	f88d 0015 	strb.w	r0, [sp, #21]
                if( ( status & 0x07 ) == 0x07 )
 8033adc:	d10e      	bne.n	8033afc <ProcessMacCommands.isra.0.constprop.0+0x220>
                    Nvm.MacGroup2.MacParams.Rx2Channel.Datarate = rxParamSetupReq.Datarate;
 8033ade:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
 8033ae2:	f885 3574 	strb.w	r3, [r5, #1396]	; 0x574
                    Nvm.MacGroup2.MacParams.RxCChannel.Datarate = rxParamSetupReq.Datarate;
 8033ae6:	f885 357c 	strb.w	r3, [r5, #1404]	; 0x57c
                    Nvm.MacGroup2.MacParams.Rx2Channel.Frequency = rxParamSetupReq.Frequency;
 8033aea:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8033aec:	f8c5 3570 	str.w	r3, [r5, #1392]	; 0x570
                    Nvm.MacGroup2.MacParams.RxCChannel.Frequency = rxParamSetupReq.Frequency;
 8033af0:	f8c5 3578 	str.w	r3, [r5, #1400]	; 0x578
                    Nvm.MacGroup2.MacParams.Rx1DrOffset = rxParamSetupReq.DrOffset;
 8033af4:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
 8033af8:	f885 356d 	strb.w	r3, [r5, #1389]	; 0x56d
                macCmdPayload[0] = status;
 8033afc:	f88d 0018 	strb.w	r0, [sp, #24]
                LoRaMacCommandsAddCmd( MOTE_MAC_RX_PARAM_SETUP_ANS, macCmdPayload, 1 );
 8033b00:	2201      	movs	r2, #1
 8033b02:	a906      	add	r1, sp, #24
 8033b04:	2005      	movs	r0, #5
                    LoRaMacCommandsAddCmd( MOTE_MAC_DL_CHANNEL_ANS, macCmdPayload, 1 );
 8033b06:	f001 ff7f 	bl	8035a08 <LoRaMacCommandsAddCmd>
    MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 1;
 8033b0a:	f895 3485 	ldrb.w	r3, [r5, #1157]	; 0x485
 8033b0e:	f043 0310 	orr.w	r3, r3, #16
 8033b12:	f885 3485 	strb.w	r3, [r5, #1157]	; 0x485
}
 8033b16:	e73f      	b.n	8033998 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->GetBatteryLevel != NULL ) )
 8033b18:	f8d5 334c 	ldr.w	r3, [r5, #844]	; 0x34c
 8033b1c:	b173      	cbz	r3, 8033b3c <ProcessMacCommands.isra.0.constprop.0+0x260>
 8033b1e:	681b      	ldr	r3, [r3, #0]
 8033b20:	b163      	cbz	r3, 8033b3c <ProcessMacCommands.isra.0.constprop.0+0x260>
                    batteryLevel = MacCtx.MacCallbacks->GetBatteryLevel( );
 8033b22:	4798      	blx	r3
                macCmdPayload[1] = ( uint8_t )( snr & 0x3F );
 8033b24:	f00b 033f 	and.w	r3, fp, #63	; 0x3f
                macCmdPayload[0] = batteryLevel;
 8033b28:	f88d 0018 	strb.w	r0, [sp, #24]
                macCmdPayload[1] = ( uint8_t )( snr & 0x3F );
 8033b2c:	f88d 3019 	strb.w	r3, [sp, #25]
                LoRaMacCommandsAddCmd( MOTE_MAC_DEV_STATUS_ANS, macCmdPayload, 2 );
 8033b30:	2202      	movs	r2, #2
 8033b32:	a906      	add	r1, sp, #24
 8033b34:	2006      	movs	r0, #6
                    LoRaMacCommandsAddCmd( MOTE_MAC_BEACON_FREQ_ANS, macCmdPayload, 1 );
 8033b36:	f001 ff67 	bl	8035a08 <LoRaMacCommandsAddCmd>
                break;
 8033b3a:	e72d      	b.n	8033998 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                uint8_t batteryLevel = BAT_LEVEL_NO_MEASURE;
 8033b3c:	20ff      	movs	r0, #255	; 0xff
 8033b3e:	e7f1      	b.n	8033b24 <ProcessMacCommands.isra.0.constprop.0+0x248>
                status = 0x03;
 8033b40:	2303      	movs	r3, #3
 8033b42:	f88d 3015 	strb.w	r3, [sp, #21]
                newChannelReq.ChannelId = payload[macIndex++];
 8033b46:	5d33      	ldrb	r3, [r6, r4]
 8033b48:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
                newChannelReq.NewChannel = &chParam;
 8033b4c:	ab0c      	add	r3, sp, #48	; 0x30
 8033b4e:	9308      	str	r3, [sp, #32]
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033b50:	f109 0204 	add.w	r2, r9, #4
                chParam.Frequency = ( uint32_t ) payload[macIndex++];
 8033b54:	f109 0303 	add.w	r3, r9, #3
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033b58:	b2db      	uxtb	r3, r3
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033b5a:	b2d2      	uxtb	r2, r2
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033b5c:	5cf1      	ldrb	r1, [r6, r3]
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033b5e:	5cb3      	ldrb	r3, [r6, r2]
                status = ( uint8_t )RegionNewChannelReq( Nvm.MacGroup2.Region, &newChannelReq );
 8033b60:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
                newChannelReq.ChannelId = payload[macIndex++];
 8033b64:	f109 0202 	add.w	r2, r9, #2
                chParam.Frequency = ( uint32_t ) payload[macIndex++];
 8033b68:	b2d2      	uxtb	r2, r2
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033b6a:	041b      	lsls	r3, r3, #16
                chParam.Frequency = ( uint32_t ) payload[macIndex++];
 8033b6c:	5cb2      	ldrb	r2, [r6, r2]
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033b6e:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8033b72:	4313      	orrs	r3, r2
                chParam.DrRange.Value = payload[macIndex++];
 8033b74:	f109 0406 	add.w	r4, r9, #6
                chParam.Frequency *= 100;
 8033b78:	2264      	movs	r2, #100	; 0x64
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033b7a:	f109 0905 	add.w	r9, r9, #5
                chParam.Frequency *= 100;
 8033b7e:	4353      	muls	r3, r2
                chParam.DrRange.Value = payload[macIndex++];
 8033b80:	fa5f f989 	uxtb.w	r9, r9
                chParam.Frequency *= 100;
 8033b84:	930c      	str	r3, [sp, #48]	; 0x30
                chParam.Rx1Frequency = 0;
 8033b86:	2300      	movs	r3, #0
 8033b88:	930d      	str	r3, [sp, #52]	; 0x34
                status = ( uint8_t )RegionNewChannelReq( Nvm.MacGroup2.Region, &newChannelReq );
 8033b8a:	a908      	add	r1, sp, #32
                chParam.DrRange.Value = payload[macIndex++];
 8033b8c:	f816 3009 	ldrb.w	r3, [r6, r9]
 8033b90:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
                status = ( uint8_t )RegionNewChannelReq( Nvm.MacGroup2.Region, &newChannelReq );
 8033b94:	f002 fe62 	bl	803685c <RegionNewChannelReq>
 8033b98:	b2c3      	uxtb	r3, r0
                if( ( int8_t )status >= 0 )
 8033b9a:	2800      	cmp	r0, #0
                chParam.DrRange.Value = payload[macIndex++];
 8033b9c:	b2e4      	uxtb	r4, r4
                status = ( uint8_t )RegionNewChannelReq( Nvm.MacGroup2.Region, &newChannelReq );
 8033b9e:	f88d 3015 	strb.w	r3, [sp, #21]
                if( ( int8_t )status >= 0 )
 8033ba2:	f6ff aef9 	blt.w	8033998 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                    macCmdPayload[0] = status;
 8033ba6:	f88d 3018 	strb.w	r3, [sp, #24]
                    LoRaMacCommandsAddCmd( MOTE_MAC_NEW_CHANNEL_ANS, macCmdPayload, 1 );
 8033baa:	2201      	movs	r2, #1
 8033bac:	a906      	add	r1, sp, #24
 8033bae:	2007      	movs	r0, #7
 8033bb0:	e7c1      	b.n	8033b36 <ProcessMacCommands.isra.0.constprop.0+0x25a>
                uint8_t delay = payload[macIndex++] & 0x0F;
 8033bb2:	5d33      	ldrb	r3, [r6, r4]
 8033bb4:	f003 030f 	and.w	r3, r3, #15
                Nvm.MacGroup2.MacParams.ReceiveDelay1 = delay * 1000;
 8033bb8:	2b01      	cmp	r3, #1
 8033bba:	bf38      	it	cc
 8033bbc:	2301      	movcc	r3, #1
 8033bbe:	461a      	mov	r2, r3
 8033bc0:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8033bc4:	4353      	muls	r3, r2
 8033bc6:	f8c5 355c 	str.w	r3, [r5, #1372]	; 0x55c
                LoRaMacCommandsAddCmd( MOTE_MAC_RX_TIMING_SETUP_ANS, macCmdPayload, 0 );
 8033bca:	2200      	movs	r2, #0
                Nvm.MacGroup2.MacParams.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay1 + 1000;
 8033bcc:	f503 737a 	add.w	r3, r3, #1000	; 0x3e8
                LoRaMacCommandsAddCmd( MOTE_MAC_RX_TIMING_SETUP_ANS, macCmdPayload, 0 );
 8033bd0:	a906      	add	r1, sp, #24
 8033bd2:	2008      	movs	r0, #8
                Nvm.MacGroup2.MacParams.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay1 + 1000;
 8033bd4:	f8c5 3560 	str.w	r3, [r5, #1376]	; 0x560
                LoRaMacCommandsAddCmd( MOTE_MAC_RX_TIMING_SETUP_ANS, macCmdPayload, 0 );
 8033bd8:	f001 ff16 	bl	8035a08 <LoRaMacCommandsAddCmd>
    MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 1;
 8033bdc:	f895 3485 	ldrb.w	r3, [r5, #1157]	; 0x485
                uint8_t delay = payload[macIndex++] & 0x0F;
 8033be0:	f109 0902 	add.w	r9, r9, #2
    MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 1;
 8033be4:	f043 0310 	orr.w	r3, r3, #16
                uint8_t delay = payload[macIndex++] & 0x0F;
 8033be8:	fa5f f989 	uxtb.w	r9, r9
    MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 1;
 8033bec:	f885 3485 	strb.w	r3, [r5, #1157]	; 0x485
                uint8_t delay = payload[macIndex++] & 0x0F;
 8033bf0:	464c      	mov	r4, r9
}
 8033bf2:	e6d1      	b.n	8033998 <ProcessMacCommands.isra.0.constprop.0+0xbc>
 8033bf4:	20004aa4 	.word	0x20004aa4
                uint8_t eirpDwellTime = payload[macIndex++];
 8033bf8:	5d33      	ldrb	r3, [r6, r4]
                if( RegionTxParamSetupReq( Nvm.MacGroup2.Region, &txParamSetupReq ) != -1 )
 8033bfa:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
                txParamSetupReq.UplinkDwellTime = 0;
 8033bfe:	2200      	movs	r2, #0
 8033c00:	f88d 201c 	strb.w	r2, [sp, #28]
                if( ( eirpDwellTime & 0x20 ) == 0x20 )
 8033c04:	f013 0220 	ands.w	r2, r3, #32
                    txParamSetupReq.DownlinkDwellTime = 1;
 8033c08:	bf18      	it	ne
 8033c0a:	2201      	movne	r2, #1
 8033c0c:	f88d 201d 	strb.w	r2, [sp, #29]
                if( ( eirpDwellTime & 0x10 ) == 0x10 )
 8033c10:	06da      	lsls	r2, r3, #27
                    txParamSetupReq.UplinkDwellTime = 1;
 8033c12:	bf48      	it	mi
 8033c14:	2201      	movmi	r2, #1
                txParamSetupReq.MaxEirp = eirpDwellTime & 0x0F;
 8033c16:	f003 030f 	and.w	r3, r3, #15
                if( RegionTxParamSetupReq( Nvm.MacGroup2.Region, &txParamSetupReq ) != -1 )
 8033c1a:	a907      	add	r1, sp, #28
                    txParamSetupReq.UplinkDwellTime = 1;
 8033c1c:	bf48      	it	mi
 8033c1e:	f88d 201c 	strbmi.w	r2, [sp, #28]
                txParamSetupReq.MaxEirp = eirpDwellTime & 0x0F;
 8033c22:	f88d 301e 	strb.w	r3, [sp, #30]
                if( RegionTxParamSetupReq( Nvm.MacGroup2.Region, &txParamSetupReq ) != -1 )
 8033c26:	f002 fe25 	bl	8036874 <RegionTxParamSetupReq>
                uint8_t eirpDwellTime = payload[macIndex++];
 8033c2a:	f109 0902 	add.w	r9, r9, #2
                if( RegionTxParamSetupReq( Nvm.MacGroup2.Region, &txParamSetupReq ) != -1 )
 8033c2e:	3001      	adds	r0, #1
                uint8_t eirpDwellTime = payload[macIndex++];
 8033c30:	fa5f f989 	uxtb.w	r9, r9
                if( RegionTxParamSetupReq( Nvm.MacGroup2.Region, &txParamSetupReq ) != -1 )
 8033c34:	d0dc      	beq.n	8033bf0 <ProcessMacCommands.isra.0.constprop.0+0x314>
                    Nvm.MacGroup2.MacParams.UplinkDwellTime = txParamSetupReq.UplinkDwellTime;
 8033c36:	f8bd 301c 	ldrh.w	r3, [sp, #28]
                    Nvm.MacGroup2.MacParams.MaxEirp = LoRaMacMaxEirpTable[txParamSetupReq.MaxEirp];
 8033c3a:	4a8e      	ldr	r2, [pc, #568]	; (8033e74 <ProcessMacCommands.isra.0.constprop.0+0x598>)
                    Nvm.MacGroup2.MacParams.UplinkDwellTime = txParamSetupReq.UplinkDwellTime;
 8033c3c:	f8a5 3580 	strh.w	r3, [r5, #1408]	; 0x580
                    Nvm.MacGroup2.MacParams.MaxEirp = LoRaMacMaxEirpTable[txParamSetupReq.MaxEirp];
 8033c40:	f89d 301e 	ldrb.w	r3, [sp, #30]
                    Nvm.MacGroup2.MacParams.UplinkDwellTime = txParamSetupReq.UplinkDwellTime;
 8033c44:	f89d 401c 	ldrb.w	r4, [sp, #28]
                    Nvm.MacGroup2.MacParams.MaxEirp = LoRaMacMaxEirpTable[txParamSetupReq.MaxEirp];
 8033c48:	5cd0      	ldrb	r0, [r2, r3]
 8033c4a:	f7f7 ff23 	bl	802ba94 <__aeabi_ui2f>
                    getPhy.Attribute = PHY_MIN_TX_DR;
 8033c4e:	2302      	movs	r3, #2
                    Nvm.MacGroup2.MacParams.MaxEirp = LoRaMacMaxEirpTable[txParamSetupReq.MaxEirp];
 8033c50:	f8c5 0584 	str.w	r0, [r5, #1412]	; 0x584
                    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8033c54:	a90c      	add	r1, sp, #48	; 0x30
 8033c56:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
                    getPhy.Attribute = PHY_MIN_TX_DR;
 8033c5a:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
                    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8033c5e:	f88d 4032 	strb.w	r4, [sp, #50]	; 0x32
                    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8033c62:	f002 fd5e 	bl	8036722 <RegionGetPhyParam>
                    Nvm.MacGroup1.ChannelsDatarate = MAX( Nvm.MacGroup1.ChannelsDatarate, ( int8_t )phyParam.Value );
 8033c66:	f995 3545 	ldrsb.w	r3, [r5, #1349]	; 0x545
                    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8033c6a:	9008      	str	r0, [sp, #32]
                    Nvm.MacGroup1.ChannelsDatarate = MAX( Nvm.MacGroup1.ChannelsDatarate, ( int8_t )phyParam.Value );
 8033c6c:	b240      	sxtb	r0, r0
 8033c6e:	4298      	cmp	r0, r3
 8033c70:	bfb8      	it	lt
 8033c72:	4618      	movlt	r0, r3
 8033c74:	f885 0545 	strb.w	r0, [r5, #1349]	; 0x545
                    LoRaMacCommandsAddCmd( MOTE_MAC_TX_PARAM_SETUP_ANS, macCmdPayload, 0 );
 8033c78:	2200      	movs	r2, #0
 8033c7a:	a906      	add	r1, sp, #24
 8033c7c:	2009      	movs	r0, #9
 8033c7e:	e6fc      	b.n	8033a7a <ProcessMacCommands.isra.0.constprop.0+0x19e>
                status = 0x03;
 8033c80:	2303      	movs	r3, #3
 8033c82:	f88d 3015 	strb.w	r3, [sp, #21]
                dlChannelReq.ChannelId = payload[macIndex++];
 8033c86:	5d33      	ldrb	r3, [r6, r4]
 8033c88:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033c8c:	f109 0204 	add.w	r2, r9, #4
                dlChannelReq.Rx1Frequency = ( uint32_t ) payload[macIndex++];
 8033c90:	f109 0303 	add.w	r3, r9, #3
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033c94:	b2db      	uxtb	r3, r3
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033c96:	b2d2      	uxtb	r2, r2
 8033c98:	f109 0405 	add.w	r4, r9, #5
                dlChannelReq.ChannelId = payload[macIndex++];
 8033c9c:	f109 0902 	add.w	r9, r9, #2
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033ca0:	5cf1      	ldrb	r1, [r6, r3]
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033ca2:	5cb3      	ldrb	r3, [r6, r2]
                status = ( uint8_t )RegionDlChannelReq( Nvm.MacGroup2.Region, &dlChannelReq );
 8033ca4:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
                dlChannelReq.Rx1Frequency = ( uint32_t ) payload[macIndex++];
 8033ca8:	fa5f f989 	uxtb.w	r9, r9
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033cac:	041b      	lsls	r3, r3, #16
                dlChannelReq.Rx1Frequency = ( uint32_t ) payload[macIndex++];
 8033cae:	f816 2009 	ldrb.w	r2, [r6, r9]
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033cb2:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8033cb6:	4313      	orrs	r3, r2
                dlChannelReq.Rx1Frequency *= 100;
 8033cb8:	2264      	movs	r2, #100	; 0x64
 8033cba:	4353      	muls	r3, r2
                status = ( uint8_t )RegionDlChannelReq( Nvm.MacGroup2.Region, &dlChannelReq );
 8033cbc:	a90c      	add	r1, sp, #48	; 0x30
                dlChannelReq.Rx1Frequency *= 100;
 8033cbe:	930d      	str	r3, [sp, #52]	; 0x34
                status = ( uint8_t )RegionDlChannelReq( Nvm.MacGroup2.Region, &dlChannelReq );
 8033cc0:	f002 fde4 	bl	803688c <RegionDlChannelReq>
 8033cc4:	b2c3      	uxtb	r3, r0
                if( ( int8_t )status >= 0 )
 8033cc6:	2800      	cmp	r0, #0
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033cc8:	b2e4      	uxtb	r4, r4
                status = ( uint8_t )RegionDlChannelReq( Nvm.MacGroup2.Region, &dlChannelReq );
 8033cca:	f88d 3015 	strb.w	r3, [sp, #21]
                if( ( int8_t )status >= 0 )
 8033cce:	f6ff ae63 	blt.w	8033998 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                    macCmdPayload[0] = status;
 8033cd2:	f88d 3018 	strb.w	r3, [sp, #24]
                    LoRaMacCommandsAddCmd( MOTE_MAC_DL_CHANNEL_ANS, macCmdPayload, 1 );
 8033cd6:	2201      	movs	r2, #1
 8033cd8:	a906      	add	r1, sp, #24
 8033cda:	200a      	movs	r0, #10
 8033cdc:	e713      	b.n	8033b06 <ProcessMacCommands.isra.0.constprop.0+0x22a>
                if( LoRaMacConfirmQueueIsCmdActive( MLME_DEVICE_TIME ) == true )
 8033cde:	200a      	movs	r0, #10
 8033ce0:	f002 f82e 	bl	8035d40 <LoRaMacConfirmQueueIsCmdActive>
 8033ce4:	2800      	cmp	r0, #0
 8033ce6:	f43f ae57 	beq.w	8033998 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_DEVICE_TIME );
 8033cea:	210a      	movs	r1, #10
 8033cec:	2000      	movs	r0, #0
 8033cee:	f001 ffeb 	bl	8035cc8 <LoRaMacConfirmQueueSetStatus>
                    SysTime_t sysTime = { 0 };
 8033cf2:	2300      	movs	r3, #0
 8033cf4:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 8;
 8033cf8:	f109 0203 	add.w	r2, r9, #3
                    gpsEpochTime.Seconds = ( uint32_t )payload[macIndex++];
 8033cfc:	f109 0302 	add.w	r3, r9, #2
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 8;
 8033d00:	b2db      	uxtb	r3, r3
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 16;
 8033d02:	b2d2      	uxtb	r2, r2
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 8;
 8033d04:	5cf1      	ldrb	r1, [r6, r3]
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 16;
 8033d06:	5cb3      	ldrb	r3, [r6, r2]
                    gpsEpochTime.Seconds = ( uint32_t )payload[macIndex++];
 8033d08:	5d32      	ldrb	r2, [r6, r4]
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 16;
 8033d0a:	041b      	lsls	r3, r3, #16
 8033d0c:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8033d10:	4313      	orrs	r3, r2
 8033d12:	f109 0204 	add.w	r2, r9, #4
                    gpsEpochTime.SubSeconds = payload[macIndex++];
 8033d16:	f109 0406 	add.w	r4, r9, #6
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 24;
 8033d1a:	b2d2      	uxtb	r2, r2
 8033d1c:	f109 0905 	add.w	r9, r9, #5
                    gpsEpochTime.SubSeconds = payload[macIndex++];
 8033d20:	fa5f f989 	uxtb.w	r9, r9
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 24;
 8033d24:	5cb2      	ldrb	r2, [r6, r2]
                    gpsEpochTime.SubSeconds = ( int16_t )( ( ( int32_t )gpsEpochTime.SubSeconds * 1000 ) >> 8 );
 8033d26:	f816 1009 	ldrb.w	r1, [r6, r9]
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 24;
 8033d2a:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
                    gpsEpochTime.SubSeconds = ( int16_t )( ( ( int32_t )gpsEpochTime.SubSeconds * 1000 ) >> 8 );
 8033d2e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8033d32:	434a      	muls	r2, r1
                    sysTimeCurrent = SysTimeGet( );
 8033d34:	f10d 0a30 	add.w	sl, sp, #48	; 0x30
                    gpsEpochTime.SubSeconds = ( int16_t )( ( ( int32_t )gpsEpochTime.SubSeconds * 1000 ) >> 8 );
 8033d38:	1212      	asrs	r2, r2, #8
                    sysTimeCurrent = SysTimeGet( );
 8033d3a:	4650      	mov	r0, sl
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 24;
 8033d3c:	9303      	str	r3, [sp, #12]
                    gpsEpochTime.SubSeconds = ( int16_t )( ( ( int32_t )gpsEpochTime.SubSeconds * 1000 ) >> 8 );
 8033d3e:	f8ad 2024 	strh.w	r2, [sp, #36]	; 0x24
                    sysTimeCurrent = SysTimeGet( );
 8033d42:	f007 fa0f 	bl	803b164 <SysTimeGet>
                    sysTime.Seconds += UNIX_GPS_EPOCH_OFFSET;
 8033d46:	9b03      	ldr	r3, [sp, #12]
 8033d48:	f103 5396 	add.w	r3, r3, #314572800	; 0x12c00000
 8033d4c:	f503 13a9 	add.w	r3, r3, #1384448	; 0x152000
 8033d50:	f503 53ec 	add.w	r3, r3, #7552	; 0x1d80
                    sysTime = SysTimeAdd( sysTimeCurrent, SysTimeSub( sysTime, MacCtx.LastTxSysTime ) );
 8033d54:	9308      	str	r3, [sp, #32]
 8033d56:	f8d5 3340 	ldr.w	r3, [r5, #832]	; 0x340
 8033d5a:	9300      	str	r3, [sp, #0]
 8033d5c:	f10d 0920 	add.w	r9, sp, #32
 8033d60:	e899 0006 	ldmia.w	r9, {r1, r2}
 8033d64:	f8d5 333c 	ldr.w	r3, [r5, #828]	; 0x33c
 8033d68:	a80a      	add	r0, sp, #40	; 0x28
 8033d6a:	f007 f9b7 	bl	803b0dc <SysTimeSub>
 8033d6e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8033d70:	9300      	str	r3, [sp, #0]
 8033d72:	e89a 0006 	ldmia.w	sl, {r1, r2}
 8033d76:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8033d78:	4648      	mov	r0, r9
 8033d7a:	f007 f993 	bl	803b0a4 <SysTimeAdd>
                    SysTimeSet( sysTime );
 8033d7e:	e899 0003 	ldmia.w	r9, {r0, r1}
 8033d82:	f007 f9c7 	bl	803b114 <SysTimeSet>
                    LoRaMacClassBDeviceTimeAns( );
 8033d86:	f001 fe29 	bl	80359dc <LoRaMacClassBDeviceTimeAns>
                    MacCtx.McpsIndication.DeviceTimeAnsReceived = true;
 8033d8a:	2301      	movs	r3, #1
                    gpsEpochTime.SubSeconds = payload[macIndex++];
 8033d8c:	b2e4      	uxtb	r4, r4
                    MacCtx.McpsIndication.DeviceTimeAnsReceived = true;
 8033d8e:	f885 3438 	strb.w	r3, [r5, #1080]	; 0x438
 8033d92:	e601      	b.n	8033998 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                if( LoRaMacConfirmQueueIsCmdActive( MLME_PING_SLOT_INFO ) == true )
 8033d94:	200d      	movs	r0, #13
 8033d96:	f001 ffd3 	bl	8035d40 <LoRaMacConfirmQueueIsCmdActive>
 8033d9a:	2800      	cmp	r0, #0
 8033d9c:	f43f adfc 	beq.w	8033998 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_PING_SLOT_INFO );
 8033da0:	210d      	movs	r1, #13
 8033da2:	2000      	movs	r0, #0
 8033da4:	f001 ff90 	bl	8035cc8 <LoRaMacConfirmQueueSetStatus>
                    if( ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_PING_SLOT ) && ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT ) )
 8033da8:	f895 3484 	ldrb.w	r3, [r5, #1156]	; 0x484
 8033dac:	3b04      	subs	r3, #4
 8033dae:	2b01      	cmp	r3, #1
 8033db0:	f67f adf2 	bls.w	8033998 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                        LoRaMacClassBPingSlotInfoAns( );
 8033db4:	f001 fe0e 	bl	80359d4 <LoRaMacClassBPingSlotInfoAns>
 8033db8:	e5ee      	b.n	8033998 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                frequency = ( uint32_t )payload[macIndex++];
 8033dba:	f109 0202 	add.w	r2, r9, #2
                frequency |= ( uint32_t )payload[macIndex++] << 8;
 8033dbe:	b2d2      	uxtb	r2, r2
                frequency = ( uint32_t )payload[macIndex++];
 8033dc0:	5d31      	ldrb	r1, [r6, r4]
                frequency |= ( uint32_t )payload[macIndex++] << 8;
 8033dc2:	5cb0      	ldrb	r0, [r6, r2]
 8033dc4:	f109 0203 	add.w	r2, r9, #3
                frequency |= ( uint32_t )payload[macIndex++] << 16;
 8033dc8:	b2d2      	uxtb	r2, r2
                datarate = payload[macIndex++] & 0x0F;
 8033dca:	f109 0405 	add.w	r4, r9, #5
                frequency |= ( uint32_t )payload[macIndex++] << 16;
 8033dce:	5cb3      	ldrb	r3, [r6, r2]
 8033dd0:	f109 0904 	add.w	r9, r9, #4
                datarate = payload[macIndex++] & 0x0F;
 8033dd4:	fa5f f989 	uxtb.w	r9, r9
                frequency |= ( uint32_t )payload[macIndex++] << 16;
 8033dd8:	041b      	lsls	r3, r3, #16
 8033dda:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
                datarate = payload[macIndex++] & 0x0F;
 8033dde:	f816 0009 	ldrb.w	r0, [r6, r9]
                frequency |= ( uint32_t )payload[macIndex++] << 16;
 8033de2:	430b      	orrs	r3, r1
                status = LoRaMacClassBPingSlotChannelReq( datarate, frequency );
 8033de4:	2164      	movs	r1, #100	; 0x64
 8033de6:	4359      	muls	r1, r3
 8033de8:	f000 000f 	and.w	r0, r0, #15
 8033dec:	f001 fdf3 	bl	80359d6 <LoRaMacClassBPingSlotChannelReq>
                datarate = payload[macIndex++] & 0x0F;
 8033df0:	b2e4      	uxtb	r4, r4
                macCmdPayload[0] = status;
 8033df2:	f88d 0018 	strb.w	r0, [sp, #24]
                LoRaMacCommandsAddCmd( MOTE_MAC_PING_SLOT_FREQ_ANS, macCmdPayload, 1 );
 8033df6:	2201      	movs	r2, #1
 8033df8:	a906      	add	r1, sp, #24
 8033dfa:	2011      	movs	r0, #17
 8033dfc:	e69b      	b.n	8033b36 <ProcessMacCommands.isra.0.constprop.0+0x25a>
                if( LoRaMacConfirmQueueIsCmdActive( MLME_BEACON_TIMING ) == true )
 8033dfe:	200e      	movs	r0, #14
 8033e00:	f001 ff9e 	bl	8035d40 <LoRaMacConfirmQueueIsCmdActive>
 8033e04:	2800      	cmp	r0, #0
 8033e06:	f43f adc7 	beq.w	8033998 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_BEACON_TIMING );
 8033e0a:	210e      	movs	r1, #14
 8033e0c:	2000      	movs	r0, #0
 8033e0e:	f001 ff5b 	bl	8035cc8 <LoRaMacConfirmQueueSetStatus>
                    beaconTimingDelay = ( uint16_t )payload[macIndex++];
 8033e12:	f109 0302 	add.w	r3, r9, #2
                    beaconTimingDelay |= ( uint16_t )payload[macIndex++] << 8;
 8033e16:	b2db      	uxtb	r3, r3
                    LoRaMacClassBBeaconTimingAns( beaconTimingDelay, beaconTimingChannel, RxDoneParams.LastRxDone );
 8033e18:	4a17      	ldr	r2, [pc, #92]	; (8033e78 <ProcessMacCommands.isra.0.constprop.0+0x59c>)
                    beaconTimingDelay |= ( uint16_t )payload[macIndex++] << 8;
 8033e1a:	5cf0      	ldrb	r0, [r6, r3]
 8033e1c:	5d33      	ldrb	r3, [r6, r4]
                    LoRaMacClassBBeaconTimingAns( beaconTimingDelay, beaconTimingChannel, RxDoneParams.LastRxDone );
 8033e1e:	6812      	ldr	r2, [r2, #0]
                    beaconTimingChannel = payload[macIndex++];
 8033e20:	f109 0404 	add.w	r4, r9, #4
                    beaconTimingDelay |= ( uint16_t )payload[macIndex++] << 8;
 8033e24:	f109 0903 	add.w	r9, r9, #3
                    beaconTimingChannel = payload[macIndex++];
 8033e28:	fa5f f989 	uxtb.w	r9, r9
                    LoRaMacClassBBeaconTimingAns( beaconTimingDelay, beaconTimingChannel, RxDoneParams.LastRxDone );
 8033e2c:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 8033e30:	f816 1009 	ldrb.w	r1, [r6, r9]
                    beaconTimingChannel = payload[macIndex++];
 8033e34:	b2e4      	uxtb	r4, r4
                    LoRaMacClassBBeaconTimingAns( beaconTimingDelay, beaconTimingChannel, RxDoneParams.LastRxDone );
 8033e36:	f001 fdd0 	bl	80359da <LoRaMacClassBBeaconTimingAns>
 8033e3a:	e5ad      	b.n	8033998 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                    frequency = ( uint32_t )payload[macIndex++];
 8033e3c:	5d30      	ldrb	r0, [r6, r4]
 8033e3e:	f109 0302 	add.w	r3, r9, #2
                    frequency |= ( uint32_t )payload[macIndex++] << 16;
 8033e42:	f109 0404 	add.w	r4, r9, #4
                    frequency |= ( uint32_t )payload[macIndex++] << 8;
 8033e46:	f109 0903 	add.w	r9, r9, #3
 8033e4a:	b2db      	uxtb	r3, r3
                    frequency |= ( uint32_t )payload[macIndex++] << 16;
 8033e4c:	fa5f f989 	uxtb.w	r9, r9
                    frequency |= ( uint32_t )payload[macIndex++] << 8;
 8033e50:	5cf2      	ldrb	r2, [r6, r3]
                    frequency |= ( uint32_t )payload[macIndex++] << 16;
 8033e52:	f816 3009 	ldrb.w	r3, [r6, r9]
 8033e56:	041b      	lsls	r3, r3, #16
 8033e58:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8033e5c:	4303      	orrs	r3, r0
                    if( LoRaMacClassBBeaconFreqReq( frequency ) == true )
 8033e5e:	2064      	movs	r0, #100	; 0x64
 8033e60:	4358      	muls	r0, r3
 8033e62:	f001 fdbc 	bl	80359de <LoRaMacClassBBeaconFreqReq>
                    frequency |= ( uint32_t )payload[macIndex++] << 16;
 8033e66:	b2e4      	uxtb	r4, r4
                    if( LoRaMacClassBBeaconFreqReq( frequency ) == true )
 8033e68:	f88d 0018 	strb.w	r0, [sp, #24]
                    LoRaMacCommandsAddCmd( MOTE_MAC_BEACON_FREQ_ANS, macCmdPayload, 1 );
 8033e6c:	2201      	movs	r2, #1
 8033e6e:	a906      	add	r1, sp, #24
 8033e70:	2013      	movs	r0, #19
 8033e72:	e660      	b.n	8033b36 <ProcessMacCommands.isra.0.constprop.0+0x25a>
 8033e74:	0803baba 	.word	0x0803baba
 8033e78:	20006314 	.word	0x20006314

08033e7c <LoRaMacIsBusy>:
    if( ( MacCtx.MacState == LORAMAC_IDLE ) &&
 8033e7c:	4b05      	ldr	r3, [pc, #20]	; (8033e94 <LoRaMacIsBusy+0x18>)
 8033e7e:	f8d3 2344 	ldr.w	r2, [r3, #836]	; 0x344
 8033e82:	b92a      	cbnz	r2, 8033e90 <LoRaMacIsBusy+0x14>
 8033e84:	f893 0486 	ldrb.w	r0, [r3, #1158]	; 0x486
 8033e88:	3801      	subs	r0, #1
 8033e8a:	bf18      	it	ne
 8033e8c:	2001      	movne	r0, #1
 8033e8e:	4770      	bx	lr
    return true;
 8033e90:	2001      	movs	r0, #1
}
 8033e92:	4770      	bx	lr
 8033e94:	20004aa4 	.word	0x20004aa4

08033e98 <LoRaMacProcess>:
{
 8033e98:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8033e9c:	b0a5      	sub	sp, #148	; 0x94
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8033e9e:	f3ef 8210 	mrs	r2, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8033ea2:	b672      	cpsid	i
    events = LoRaMacRadioEvents;
 8033ea4:	4ccf      	ldr	r4, [pc, #828]	; (80341e4 <LoRaMacProcess+0x34c>)
    LoRaMacRadioEvents.Value = 0;
 8033ea6:	2100      	movs	r1, #0
    events = LoRaMacRadioEvents;
 8033ea8:	6823      	ldr	r3, [r4, #0]
    LoRaMacRadioEvents.Value = 0;
 8033eaa:	6021      	str	r1, [r4, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8033eac:	f382 8810 	msr	PRIMASK, r2
    if( events.Value != 0 )
 8033eb0:	2b00      	cmp	r3, #0
 8033eb2:	f000 80cd 	beq.w	8034050 <LoRaMacProcess+0x1b8>
        if( events.Events.TxDone == 1 )
 8033eb6:	06da      	lsls	r2, r3, #27
 8033eb8:	fa5f fa83 	uxtb.w	sl, r3
 8033ebc:	d560      	bpl.n	8033f80 <LoRaMacProcess+0xe8>
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 8033ebe:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 8033ec2:	2b02      	cmp	r3, #2
 8033ec4:	d002      	beq.n	8033ecc <LoRaMacProcess+0x34>
        Radio.Sleep( );
 8033ec6:	4bc8      	ldr	r3, [pc, #800]	; (80341e8 <LoRaMacProcess+0x350>)
 8033ec8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8033eca:	4798      	blx	r3
    TimerSetValue( &MacCtx.RxWindowTimer1, MacCtx.RxWindow1Delay );
 8033ecc:	f8d4 13b4 	ldr.w	r1, [r4, #948]	; 0x3b4
 8033ed0:	48c6      	ldr	r0, [pc, #792]	; (80341ec <LoRaMacProcess+0x354>)
 8033ed2:	f007 fabf 	bl	803b454 <UTIL_TIMER_SetPeriod>
    TimerStart( &MacCtx.RxWindowTimer1 );
 8033ed6:	48c5      	ldr	r0, [pc, #788]	; (80341ec <LoRaMacProcess+0x354>)
 8033ed8:	f007 fa82 	bl	803b3e0 <UTIL_TIMER_Start>
    TimerSetValue( &MacCtx.RxWindowTimer2, MacCtx.RxWindow2Delay );
 8033edc:	f8d4 13b8 	ldr.w	r1, [r4, #952]	; 0x3b8
 8033ee0:	48c3      	ldr	r0, [pc, #780]	; (80341f0 <LoRaMacProcess+0x358>)
 8033ee2:	f007 fab7 	bl	803b454 <UTIL_TIMER_SetPeriod>
    TimerStart( &MacCtx.RxWindowTimer2 );
 8033ee6:	48c2      	ldr	r0, [pc, #776]	; (80341f0 <LoRaMacProcess+0x358>)
 8033ee8:	f007 fa7a 	bl	803b3e0 <UTIL_TIMER_Start>
    if( ( Nvm.MacGroup2.DeviceClass == CLASS_C ) || ( MacCtx.NodeAckRequested == true ) )
 8033eec:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 8033ef0:	2b02      	cmp	r3, #2
 8033ef2:	d002      	beq.n	8033efa <LoRaMacProcess+0x62>
 8033ef4:	f894 3418 	ldrb.w	r3, [r4, #1048]	; 0x418
 8033ef8:	b18b      	cbz	r3, 8033f1e <LoRaMacProcess+0x86>
        getPhy.Attribute = PHY_ACK_TIMEOUT;
 8033efa:	2316      	movs	r3, #22
        phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8033efc:	a90e      	add	r1, sp, #56	; 0x38
 8033efe:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
        getPhy.Attribute = PHY_ACK_TIMEOUT;
 8033f02:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
        phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8033f06:	f002 fc0c 	bl	8036722 <RegionGetPhyParam>
        TimerSetValue( &MacCtx.AckTimeoutTimer, MacCtx.RxWindow2Delay + phyParam.Value );
 8033f0a:	f8d4 13b8 	ldr.w	r1, [r4, #952]	; 0x3b8
        phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8033f0e:	900c      	str	r0, [sp, #48]	; 0x30
        TimerSetValue( &MacCtx.AckTimeoutTimer, MacCtx.RxWindow2Delay + phyParam.Value );
 8033f10:	4401      	add	r1, r0
 8033f12:	48b8      	ldr	r0, [pc, #736]	; (80341f4 <LoRaMacProcess+0x35c>)
 8033f14:	f007 fa9e 	bl	803b454 <UTIL_TIMER_SetPeriod>
        TimerStart( &MacCtx.AckTimeoutTimer );
 8033f18:	48b6      	ldr	r0, [pc, #728]	; (80341f4 <LoRaMacProcess+0x35c>)
 8033f1a:	f007 fa61 	bl	803b3e0 <UTIL_TIMER_Start>
    Nvm.MacGroup1.LastTxDoneTime = TxDoneParams.CurTime;
 8033f1e:	4bb6      	ldr	r3, [pc, #728]	; (80341f8 <LoRaMacProcess+0x360>)
    txDone.Channel = MacCtx.Channel;
 8033f20:	f894 2419 	ldrb.w	r2, [r4, #1049]	; 0x419
    Nvm.MacGroup1.LastTxDoneTime = TxDoneParams.CurTime;
 8033f24:	681b      	ldr	r3, [r3, #0]
 8033f26:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    txDone.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );
 8033f2a:	ae0a      	add	r6, sp, #40	; 0x28
 8033f2c:	4630      	mov	r0, r6
    txDone.Channel = MacCtx.Channel;
 8033f2e:	f88d 2060 	strb.w	r2, [sp, #96]	; 0x60
    txDone.LastTxDoneTime = TxDoneParams.CurTime;
 8033f32:	9319      	str	r3, [sp, #100]	; 0x64
    txDone.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );
 8033f34:	f007 f93c 	bl	803b1b0 <SysTimeGetMcuTime>
 8033f38:	f8d4 3614 	ldr.w	r3, [r4, #1556]	; 0x614
 8033f3c:	9300      	str	r3, [sp, #0]
 8033f3e:	ad04      	add	r5, sp, #16
 8033f40:	e896 0006 	ldmia.w	r6, {r1, r2}
 8033f44:	f8d4 3610 	ldr.w	r3, [r4, #1552]	; 0x610
 8033f48:	4628      	mov	r0, r5
 8033f4a:	f007 f8c7 	bl	803b0dc <SysTimeSub>
 8033f4e:	e895 0003 	ldmia.w	r5, {r0, r1}
 8033f52:	ab1b      	add	r3, sp, #108	; 0x6c
 8033f54:	e883 0003 	stmia.w	r3, {r0, r1}
    txDone.LastTxAirTime = MacCtx.TxTimeOnAir;
 8033f58:	f8d4 341c 	ldr.w	r3, [r4, #1052]	; 0x41c
 8033f5c:	931a      	str	r3, [sp, #104]	; 0x68
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 8033f5e:	f894 361c 	ldrb.w	r3, [r4, #1564]	; 0x61c
    RegionSetBandTxDone( Nvm.MacGroup2.Region, &txDone );
 8033f62:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
        txDone.Joined  = false;
 8033f66:	2b00      	cmp	r3, #0
 8033f68:	bf18      	it	ne
 8033f6a:	2301      	movne	r3, #1
    RegionSetBandTxDone( Nvm.MacGroup2.Region, &txDone );
 8033f6c:	a918      	add	r1, sp, #96	; 0x60
        txDone.Joined  = false;
 8033f6e:	f88d 3061 	strb.w	r3, [sp, #97]	; 0x61
    RegionSetBandTxDone( Nvm.MacGroup2.Region, &txDone );
 8033f72:	f002 fbe6 	bl	8036742 <RegionSetBandTxDone>
    if( MacCtx.NodeAckRequested == false )
 8033f76:	f894 3418 	ldrb.w	r3, [r4, #1048]	; 0x418
 8033f7a:	b90b      	cbnz	r3, 8033f80 <LoRaMacProcess+0xe8>
        MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;
 8033f7c:	f884 343d 	strb.w	r3, [r4, #1085]	; 0x43d
        if( events.Events.RxDone == 1 )
 8033f80:	f01a 0f08 	tst.w	sl, #8
 8033f84:	d039      	beq.n	8033ffa <LoRaMacProcess+0x162>
    uint8_t *payload = RxDoneParams.Payload;
 8033f86:	4b9d      	ldr	r3, [pc, #628]	; (80341fc <LoRaMacProcess+0x364>)
    uint32_t address = Nvm.MacGroup2.DevAddr;
 8033f88:	f8d4 25d8 	ldr.w	r2, [r4, #1496]	; 0x5d8
    uint8_t *payload = RxDoneParams.Payload;
 8033f8c:	685e      	ldr	r6, [r3, #4]
    uint16_t size = RxDoneParams.Size;
 8033f8e:	891d      	ldrh	r5, [r3, #8]
    int16_t rssi = RxDoneParams.Rssi;
 8033f90:	f9b3 700a 	ldrsh.w	r7, [r3, #10]
    int8_t snr = RxDoneParams.Snr;
 8033f94:	f993 900c 	ldrsb.w	r9, [r3, #12]
    uint32_t address = Nvm.MacGroup2.DevAddr;
 8033f98:	9203      	str	r2, [sp, #12]
    uint32_t downLinkCounter = 0;
 8033f9a:	2300      	movs	r3, #0
 8033f9c:	9307      	str	r3, [sp, #28]
    MacCtx.McpsConfirm.AckReceived = false;
 8033f9e:	f884 3440 	strb.w	r3, [r4, #1088]	; 0x440
    MacCtx.McpsIndication.Multicast = 0;
 8033fa2:	f8a4 3422 	strh.w	r3, [r4, #1058]	; 0x422
    MacCtx.McpsIndication.FramePending = 0;
 8033fa6:	f884 3425 	strb.w	r3, [r4, #1061]	; 0x425
    MacCtx.McpsIndication.Buffer = NULL;
 8033faa:	f8c4 3428 	str.w	r3, [r4, #1064]	; 0x428
    MacCtx.McpsIndication.BufferSize = 0;
 8033fae:	f8a4 342c 	strh.w	r3, [r4, #1068]	; 0x42c
    MacCtx.McpsIndication.AckReceived = false;
 8033fb2:	f884 342e 	strb.w	r3, [r4, #1070]	; 0x42e
    MacCtx.McpsIndication.DownLinkCounter = 0;
 8033fb6:	f8c4 3430 	str.w	r3, [r4, #1072]	; 0x430
    MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED;
 8033fba:	f884 3420 	strb.w	r3, [r4, #1056]	; 0x420
    MacCtx.McpsIndication.DevAddress = 0;
 8033fbe:	f8c4 3434 	str.w	r3, [r4, #1076]	; 0x434
    MacCtx.McpsIndication.DeviceTimeAnsReceived = false;
 8033fc2:	f884 3438 	strb.w	r3, [r4, #1080]	; 0x438
    Radio.Sleep( );
 8033fc6:	4b88      	ldr	r3, [pc, #544]	; (80341e8 <LoRaMacProcess+0x350>)
    MacCtx.RxStatus.RxSlot = MacCtx.RxSlot;
 8033fc8:	f894 2484 	ldrb.w	r2, [r4, #1156]	; 0x484
    Radio.Sleep( );
 8033fcc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    MacCtx.RxStatus.RxSlot = MacCtx.RxSlot;
 8033fce:	f884 2483 	strb.w	r2, [r4, #1155]	; 0x483
    MacCtx.RxStatus.Rssi = rssi;
 8033fd2:	f8a4 7480 	strh.w	r7, [r4, #1152]	; 0x480
    MacCtx.RxStatus.Snr = snr;
 8033fd6:	f884 9482 	strb.w	r9, [r4, #1154]	; 0x482
    Radio.Sleep( );
 8033fda:	4798      	blx	r3
    TimerStop( &MacCtx.RxWindowTimer2 );
 8033fdc:	4884      	ldr	r0, [pc, #528]	; (80341f0 <LoRaMacProcess+0x358>)
 8033fde:	f007 f9af 	bl	803b340 <UTIL_TIMER_Stop>
    if( LoRaMacClassBRxBeacon( payload, size ) == true )
 8033fe2:	4629      	mov	r1, r5
 8033fe4:	4630      	mov	r0, r6
 8033fe6:	f001 fce2 	bl	80359ae <LoRaMacClassBRxBeacon>
 8033fea:	4680      	mov	r8, r0
 8033fec:	2800      	cmp	r0, #0
 8033fee:	f000 8169 	beq.w	80342c4 <LoRaMacProcess+0x42c>
        MacCtx.MlmeIndication.BeaconInfo.Rssi = rssi;
 8033ff2:	f8a4 7476 	strh.w	r7, [r4, #1142]	; 0x476
        MacCtx.MlmeIndication.BeaconInfo.Snr = snr;
 8033ff6:	f884 9478 	strb.w	r9, [r4, #1144]	; 0x478
        if( events.Events.TxTimeout == 1 )
 8033ffa:	f01a 0f04 	tst.w	sl, #4
 8033ffe:	d019      	beq.n	8034034 <LoRaMacProcess+0x19c>
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 8034000:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 8034004:	2b02      	cmp	r3, #2
 8034006:	d002      	beq.n	803400e <LoRaMacProcess+0x176>
        Radio.Sleep( );
 8034008:	4b77      	ldr	r3, [pc, #476]	; (80341e8 <LoRaMacProcess+0x350>)
 803400a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 803400c:	4798      	blx	r3
    UpdateRxSlotIdleState( );
 803400e:	f7fe ffdd 	bl	8032fcc <UpdateRxSlotIdleState>
    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT;
 8034012:	2002      	movs	r0, #2
 8034014:	f884 043d 	strb.w	r0, [r4, #1085]	; 0x43d
    LoRaMacConfirmQueueSetStatusCmn( LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT );
 8034018:	f001 fe78 	bl	8035d0c <LoRaMacConfirmQueueSetStatusCmn>
    if( MacCtx.NodeAckRequested == true )
 803401c:	f894 3418 	ldrb.w	r3, [r4, #1048]	; 0x418
 8034020:	b113      	cbz	r3, 8034028 <LoRaMacProcess+0x190>
        MacCtx.AckTimeoutRetry = true;
 8034022:	2301      	movs	r3, #1
 8034024:	f884 3417 	strb.w	r3, [r4, #1047]	; 0x417
    MacCtx.MacFlags.Bits.MacDone = 1;
 8034028:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 803402c:	f043 0320 	orr.w	r3, r3, #32
 8034030:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
        if( events.Events.RxError == 1 )
 8034034:	f01a 0f02 	tst.w	sl, #2
 8034038:	d003      	beq.n	8034042 <LoRaMacProcess+0x1aa>
    HandleRadioRxErrorTimeout( LORAMAC_EVENT_INFO_STATUS_RX1_ERROR, LORAMAC_EVENT_INFO_STATUS_RX2_ERROR );
 803403a:	2106      	movs	r1, #6
 803403c:	2005      	movs	r0, #5
 803403e:	f7ff f84d 	bl	80330dc <HandleRadioRxErrorTimeout>
        if( events.Events.RxTimeout == 1 )
 8034042:	f01a 0f01 	tst.w	sl, #1
 8034046:	d003      	beq.n	8034050 <LoRaMacProcess+0x1b8>
    HandleRadioRxErrorTimeout( LORAMAC_EVENT_INFO_STATUS_RX1_TIMEOUT, LORAMAC_EVENT_INFO_STATUS_RX2_TIMEOUT );
 8034048:	2104      	movs	r1, #4
 803404a:	2003      	movs	r0, #3
 803404c:	f7ff f846 	bl	80330dc <HandleRadioRxErrorTimeout>
    LoRaMacClassBProcess( );
 8034050:	f001 fccb 	bl	80359ea <LoRaMacClassBProcess>
    if( MacCtx.MacFlags.Bits.MacDone == 1 )
 8034054:	f894 2485 	ldrb.w	r2, [r4, #1157]	; 0x485
 8034058:	0697      	lsls	r7, r2, #26
 803405a:	f140 80f9 	bpl.w	8034250 <LoRaMacProcess+0x3b8>
    MacCtx.AllowRequests = requestState;
 803405e:	2300      	movs	r3, #0
 8034060:	f884 3486 	strb.w	r3, [r4, #1158]	; 0x486
    if( ( MacCtx.MacState & LORAMAC_RX_ABORT ) == LORAMAC_RX_ABORT )
 8034064:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 8034068:	061e      	lsls	r6, r3, #24
        MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 803406a:	bf44      	itt	mi
 803406c:	f023 0382 	bicmi.w	r3, r3, #130	; 0x82
 8034070:	f8c4 3344 	strmi.w	r3, [r4, #836]	; 0x344
    MacCtx.McpsConfirm.NbRetries = MacCtx.AckTimeoutRetriesCounter;
}

static uint8_t IsRequestPending( void )
{
    if( ( MacCtx.MacFlags.Bits.MlmeReq == 1 ) ||
 8034074:	f012 0f05 	tst.w	r2, #5
 8034078:	f000 832c 	beq.w	80346d4 <LoRaMacProcess+0x83c>
    if( ( LoRaMacConfirmQueueIsCmdActive( MLME_BEACON_ACQUISITION ) == true ) &&
 803407c:	200c      	movs	r0, #12
 803407e:	f001 fe5f 	bl	8035d40 <LoRaMacConfirmQueueIsCmdActive>
 8034082:	2800      	cmp	r0, #0
 8034084:	f000 8326 	beq.w	80346d4 <LoRaMacProcess+0x83c>
        ( MacCtx.MacFlags.Bits.McpsReq == 0 ) )
 8034088:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
    if( ( LoRaMacConfirmQueueIsCmdActive( MLME_BEACON_ACQUISITION ) == true ) &&
 803408c:	07dd      	lsls	r5, r3, #31
 803408e:	f100 8321 	bmi.w	80346d4 <LoRaMacProcess+0x83c>
        if( MacCtx.MacFlags.Bits.MlmeReq == 1 )
 8034092:	0758      	lsls	r0, r3, #29
 8034094:	f140 8332 	bpl.w	80346fc <LoRaMacProcess+0x864>
            MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 8034098:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 803409c:	f023 0302 	bic.w	r3, r3, #2
 80340a0:	f8c4 3344 	str.w	r3, [r4, #836]	; 0x344
    if( MacCtx.MacState == LORAMAC_IDLE )
 80340a4:	f8d4 2344 	ldr.w	r2, [r4, #836]	; 0x344
 80340a8:	2a00      	cmp	r2, #0
 80340aa:	f040 80ce 	bne.w	803424a <LoRaMacProcess+0x3b2>
 80340ae:	f894 5485 	ldrb.w	r5, [r4, #1157]	; 0x485
        if( MacCtx.MacFlags.Bits.McpsReq == 1 )
 80340b2:	f015 0101 	ands.w	r1, r5, #1
            MacCtx.MacFlags.Bits.McpsReq = 0;
 80340b6:	bf1e      	ittt	ne
 80340b8:	462b      	movne	r3, r5
 80340ba:	f362 0300 	bfine	r3, r2, #0, #1
 80340be:	f884 3485 	strbne.w	r3, [r4, #1157]	; 0x485
        if( MacCtx.MacFlags.Bits.MlmeReq == 1 )
 80340c2:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 80340c6:	075e      	lsls	r6, r3, #29
            MacCtx.MacFlags.Bits.MlmeReq = 0;
 80340c8:	bf44      	itt	mi
 80340ca:	f36f 0382 	bfcmi	r3, #2, #1
 80340ce:	f884 3485 	strbmi.w	r3, [r4, #1157]	; 0x485
    MacCtx.AllowRequests = requestState;
 80340d2:	2301      	movs	r3, #1
 80340d4:	f884 3486 	strb.w	r3, [r4, #1158]	; 0x486
        if( reqEvents.Bits.McpsReq == 1 )
 80340d8:	b121      	cbz	r1, 80340e4 <LoRaMacProcess+0x24c>
            MacCtx.MacPrimitives->MacMcpsConfirm( &MacCtx.McpsConfirm );
 80340da:	f8d4 3348 	ldr.w	r3, [r4, #840]	; 0x348
 80340de:	4848      	ldr	r0, [pc, #288]	; (8034200 <LoRaMacProcess+0x368>)
 80340e0:	681b      	ldr	r3, [r3, #0]
 80340e2:	4798      	blx	r3
        if( reqEvents.Bits.MlmeReq == 1 )
 80340e4:	076d      	lsls	r5, r5, #29
 80340e6:	d50b      	bpl.n	8034100 <LoRaMacProcess+0x268>
            LoRaMacConfirmQueueHandleCb( &MacCtx.MlmeConfirm );
 80340e8:	4846      	ldr	r0, [pc, #280]	; (8034204 <LoRaMacProcess+0x36c>)
 80340ea:	f001 fe35 	bl	8035d58 <LoRaMacConfirmQueueHandleCb>
            if( LoRaMacConfirmQueueGetCnt( ) > 0 )
 80340ee:	f001 fe5d 	bl	8035dac <LoRaMacConfirmQueueGetCnt>
 80340f2:	b128      	cbz	r0, 8034100 <LoRaMacProcess+0x268>
                MacCtx.MacFlags.Bits.MlmeReq = 1;
 80340f4:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 80340f8:	f043 0304 	orr.w	r3, r3, #4
 80340fc:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
        LoRaMacClassBResumeBeaconing( );
 8034100:	f001 fc61 	bl	80359c6 <LoRaMacClassBResumeBeaconing>
        MacCtx.MacFlags.Bits.MacDone = 0;
 8034104:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 8034108:	f36f 1345 	bfc	r3, #5, #1
 803410c:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
    if( MacCtx.MacState == LORAMAC_IDLE )
 8034110:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 8034114:	2b00      	cmp	r3, #0
 8034116:	f040 8098 	bne.w	803424a <LoRaMacProcess+0x3b2>
        LoRaMacCommandsStickyCmdsPending( &isStickyMacCommandPending );
 803411a:	a818      	add	r0, sp, #96	; 0x60
        bool isStickyMacCommandPending = false;
 803411c:	f88d 3060 	strb.w	r3, [sp, #96]	; 0x60
        LoRaMacCommandsStickyCmdsPending( &isStickyMacCommandPending );
 8034120:	f001 fd4a 	bl	8035bb8 <LoRaMacCommandsStickyCmdsPending>
        if( isStickyMacCommandPending == true )
 8034124:	f89d 3060 	ldrb.w	r3, [sp, #96]	; 0x60
 8034128:	b12b      	cbz	r3, 8034136 <LoRaMacProcess+0x29e>
    MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 1;
 803412a:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 803412e:	f043 0310 	orr.w	r3, r3, #16
 8034132:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
    if( MacCtx.MacState != LORAMAC_IDLE )
 8034136:	f8d4 5344 	ldr.w	r5, [r4, #836]	; 0x344
 803413a:	2d00      	cmp	r5, #0
 803413c:	f040 8085 	bne.w	803424a <LoRaMacProcess+0x3b2>
    crc = Crc32( ( uint8_t* ) &nvmData->Crypto, sizeof( nvmData->Crypto ) -
 8034140:	2124      	movs	r1, #36	; 0x24
 8034142:	4831      	ldr	r0, [pc, #196]	; (8034208 <LoRaMacProcess+0x370>)
 8034144:	f004 ff10 	bl	8038f68 <Crc32>
    if( crc != nvmData->Crypto.Crc32 )
 8034148:	f8d4 3530 	ldr.w	r3, [r4, #1328]	; 0x530
 803414c:	4298      	cmp	r0, r3
        nvmData->Crypto.Crc32 = crc;
 803414e:	bf18      	it	ne
 8034150:	f8c4 0530 	strne.w	r0, [r4, #1328]	; 0x530
    crc = Crc32( ( uint8_t* ) &nvmData->MacGroup1, sizeof( nvmData->MacGroup1 ) -
 8034154:	f04f 0114 	mov.w	r1, #20
 8034158:	482c      	ldr	r0, [pc, #176]	; (803420c <LoRaMacProcess+0x374>)
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_CRYPTO;
 803415a:	bf18      	it	ne
 803415c:	2501      	movne	r5, #1
    crc = Crc32( ( uint8_t* ) &nvmData->MacGroup1, sizeof( nvmData->MacGroup1 ) -
 803415e:	f004 ff03 	bl	8038f68 <Crc32>
    if( crc != nvmData->MacGroup1.Crc32 )
 8034162:	f8d4 3548 	ldr.w	r3, [r4, #1352]	; 0x548
 8034166:	4298      	cmp	r0, r3
        nvmData->MacGroup1.Crc32 = crc;
 8034168:	bf18      	it	ne
 803416a:	f8c4 0548 	strne.w	r0, [r4, #1352]	; 0x548
    crc = Crc32( ( uint8_t* ) &nvmData->MacGroup2, sizeof( nvmData->MacGroup2 ) -
 803416e:	f04f 01d4 	mov.w	r1, #212	; 0xd4
 8034172:	4827      	ldr	r0, [pc, #156]	; (8034210 <LoRaMacProcess+0x378>)
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_MAC_GROUP1;
 8034174:	bf18      	it	ne
 8034176:	f045 0502 	orrne.w	r5, r5, #2
    crc = Crc32( ( uint8_t* ) &nvmData->MacGroup2, sizeof( nvmData->MacGroup2 ) -
 803417a:	f004 fef5 	bl	8038f68 <Crc32>
    if( crc != nvmData->MacGroup2.Crc32 )
 803417e:	f8d4 3620 	ldr.w	r3, [r4, #1568]	; 0x620
 8034182:	4298      	cmp	r0, r3
        nvmData->MacGroup2.Crc32 = crc;
 8034184:	bf18      	it	ne
 8034186:	f8c4 0620 	strne.w	r0, [r4, #1568]	; 0x620
    crc = Crc32( ( uint8_t* ) &nvmData->SecureElement, sizeof( nvmData->SecureElement ) -
 803418a:	f44f 7180 	mov.w	r1, #256	; 0x100
 803418e:	4821      	ldr	r0, [pc, #132]	; (8034214 <LoRaMacProcess+0x37c>)
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_MAC_GROUP2;
 8034190:	bf18      	it	ne
 8034192:	f045 0504 	orrne.w	r5, r5, #4
    crc = Crc32( ( uint8_t* ) &nvmData->SecureElement, sizeof( nvmData->SecureElement ) -
 8034196:	f004 fee7 	bl	8038f68 <Crc32>
    if( crc != nvmData->SecureElement.Crc32 )
 803419a:	f8d4 3724 	ldr.w	r3, [r4, #1828]	; 0x724
 803419e:	4298      	cmp	r0, r3
        nvmData->SecureElement.Crc32 = crc;
 80341a0:	bf18      	it	ne
 80341a2:	f8c4 0724 	strne.w	r0, [r4, #1828]	; 0x724
    crc = Crc32( ( uint8_t* ) &nvmData->RegionGroup1, sizeof( nvmData->RegionGroup1 ) -
 80341a6:	f04f 01a0 	mov.w	r1, #160	; 0xa0
 80341aa:	481b      	ldr	r0, [pc, #108]	; (8034218 <LoRaMacProcess+0x380>)
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_SECURE_ELEMENT;
 80341ac:	bf18      	it	ne
 80341ae:	f045 0508 	orrne.w	r5, r5, #8
    crc = Crc32( ( uint8_t* ) &nvmData->RegionGroup1, sizeof( nvmData->RegionGroup1 ) -
 80341b2:	f004 fed9 	bl	8038f68 <Crc32>
    if( crc != nvmData->RegionGroup1.Crc32 )
 80341b6:	f8d4 37c8 	ldr.w	r3, [r4, #1992]	; 0x7c8
 80341ba:	4298      	cmp	r0, r3
        nvmData->RegionGroup1.Crc32 = crc;
 80341bc:	bf18      	it	ne
 80341be:	f8c4 07c8 	strne.w	r0, [r4, #1992]	; 0x7c8
    crc = Crc32( ( uint8_t* ) &nvmData->RegionGroup2, sizeof( nvmData->RegionGroup2 ) -
 80341c2:	f44f 715e 	mov.w	r1, #888	; 0x378
 80341c6:	4815      	ldr	r0, [pc, #84]	; (803421c <LoRaMacProcess+0x384>)
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_REGION_GROUP1;
 80341c8:	bf18      	it	ne
 80341ca:	f045 0510 	orrne.w	r5, r5, #16
    crc = Crc32( ( uint8_t* ) &nvmData->RegionGroup2, sizeof( nvmData->RegionGroup2 ) -
 80341ce:	f004 fecb 	bl	8038f68 <Crc32>
    if( crc != nvmData->RegionGroup2.Crc32 )
 80341d2:	f8d4 3b44 	ldr.w	r3, [r4, #2884]	; 0xb44
 80341d6:	4298      	cmp	r0, r3
        nvmData->RegionGroup2.Crc32 = crc;
 80341d8:	bf18      	it	ne
 80341da:	f8c4 0b44 	strne.w	r0, [r4, #2884]	; 0xb44
    crc = Crc32( ( uint8_t* ) &nvmData->ClassB, sizeof( nvmData->ClassB ) -
 80341de:	f04f 0114 	mov.w	r1, #20
 80341e2:	e01d      	b.n	8034220 <LoRaMacProcess+0x388>
 80341e4:	20004aa4 	.word	0x20004aa4
 80341e8:	0803bc30 	.word	0x0803bc30
 80341ec:	20004e28 	.word	0x20004e28
 80341f0:	20004e40 	.word	0x20004e40
 80341f4:	20004ea0 	.word	0x20004ea0
 80341f8:	20006310 	.word	0x20006310
 80341fc:	20006314 	.word	0x20006314
 8034200:	20004ee0 	.word	0x20004ee0
 8034204:	20004ef4 	.word	0x20004ef4
 8034208:	20004fb0 	.word	0x20004fb0
 803420c:	20004fd8 	.word	0x20004fd8
 8034210:	20004ff0 	.word	0x20004ff0
 8034214:	200050c8 	.word	0x200050c8
 8034218:	200051cc 	.word	0x200051cc
 803421c:	20005270 	.word	0x20005270
 8034220:	487f      	ldr	r0, [pc, #508]	; (8034420 <LoRaMacProcess+0x588>)
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_REGION_GROUP2;
 8034222:	bf18      	it	ne
 8034224:	f045 0520 	orrne.w	r5, r5, #32
    crc = Crc32( ( uint8_t* ) &nvmData->ClassB, sizeof( nvmData->ClassB ) -
 8034228:	f004 fe9e 	bl	8038f68 <Crc32>
    if( crc != nvmData->ClassB.Crc32 )
 803422c:	f8d4 3b5c 	ldr.w	r3, [r4, #2908]	; 0xb5c
 8034230:	4298      	cmp	r0, r3
    if( ( MacCtx.MacCallbacks != NULL ) &&
 8034232:	f8d4 334c 	ldr.w	r3, [r4, #844]	; 0x34c
        nvmData->ClassB.Crc32 = crc;
 8034236:	bf1c      	itt	ne
 8034238:	f8c4 0b5c 	strne.w	r0, [r4, #2908]	; 0xb5c
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_CLASS_B;
 803423c:	f045 0540 	orrne.w	r5, r5, #64	; 0x40
    if( ( MacCtx.MacCallbacks != NULL ) &&
 8034240:	b11b      	cbz	r3, 803424a <LoRaMacProcess+0x3b2>
        ( MacCtx.MacCallbacks->NvmDataChange  != NULL ) )
 8034242:	68db      	ldr	r3, [r3, #12]
    if( ( MacCtx.MacCallbacks != NULL ) &&
 8034244:	b10b      	cbz	r3, 803424a <LoRaMacProcess+0x3b2>
        MacCtx.MacCallbacks->NvmDataChange ( notifyFlags );
 8034246:	4628      	mov	r0, r5
 8034248:	4798      	blx	r3
    MacCtx.AllowRequests = requestState;
 803424a:	2301      	movs	r3, #1
 803424c:	f884 3486 	strb.w	r3, [r4, #1158]	; 0x486
    if( MacCtx.MacFlags.Bits.MlmeInd == 1 )
 8034250:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 8034254:	0718      	lsls	r0, r3, #28
 8034256:	d50a      	bpl.n	803426e <LoRaMacProcess+0x3d6>
        MacCtx.MacFlags.Bits.MlmeInd = 0;
 8034258:	f36f 03c3 	bfc	r3, #3, #1
        MacCtx.MacPrimitives->MacMlmeIndication( &MacCtx.MlmeIndication, &MacCtx.RxStatus );
 803425c:	4971      	ldr	r1, [pc, #452]	; (8034424 <LoRaMacProcess+0x58c>)
        MacCtx.MacFlags.Bits.MlmeInd = 0;
 803425e:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
        MacCtx.MacPrimitives->MacMlmeIndication( &MacCtx.MlmeIndication, &MacCtx.RxStatus );
 8034262:	f8d4 3348 	ldr.w	r3, [r4, #840]	; 0x348
 8034266:	f1a1 001c 	sub.w	r0, r1, #28
 803426a:	68db      	ldr	r3, [r3, #12]
 803426c:	4798      	blx	r3
    if( MacCtx.MacFlags.Bits.MlmeSchedUplinkInd == 1 )
 803426e:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 8034272:	06d9      	lsls	r1, r3, #27
 8034274:	d50e      	bpl.n	8034294 <LoRaMacProcess+0x3fc>
        schduleUplinkIndication.MlmeIndication = MLME_SCHEDULE_UPLINK;
 8034276:	2307      	movs	r3, #7
 8034278:	f8ad 3060 	strh.w	r3, [sp, #96]	; 0x60
        MacCtx.MacPrimitives->MacMlmeIndication( &schduleUplinkIndication, &MacCtx.RxStatus );
 803427c:	f8d4 3348 	ldr.w	r3, [r4, #840]	; 0x348
 8034280:	4968      	ldr	r1, [pc, #416]	; (8034424 <LoRaMacProcess+0x58c>)
 8034282:	68db      	ldr	r3, [r3, #12]
 8034284:	a818      	add	r0, sp, #96	; 0x60
 8034286:	4798      	blx	r3
        MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 0;
 8034288:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 803428c:	f36f 1304 	bfc	r3, #4, #1
 8034290:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
    if( MacCtx.MacFlags.Bits.McpsInd == 1 )
 8034294:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 8034298:	079a      	lsls	r2, r3, #30
 803429a:	d50a      	bpl.n	80342b2 <LoRaMacProcess+0x41a>
        MacCtx.MacFlags.Bits.McpsInd = 0;
 803429c:	f36f 0341 	bfc	r3, #1, #1
        MacCtx.MacPrimitives->MacMcpsIndication( &MacCtx.McpsIndication, &MacCtx.RxStatus );
 80342a0:	4960      	ldr	r1, [pc, #384]	; (8034424 <LoRaMacProcess+0x58c>)
        MacCtx.MacFlags.Bits.McpsInd = 0;
 80342a2:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
        MacCtx.MacPrimitives->MacMcpsIndication( &MacCtx.McpsIndication, &MacCtx.RxStatus );
 80342a6:	f8d4 3348 	ldr.w	r3, [r4, #840]	; 0x348
 80342aa:	f1a1 0060 	sub.w	r0, r1, #96	; 0x60
 80342ae:	685b      	ldr	r3, [r3, #4]
 80342b0:	4798      	blx	r3
    if( MacCtx.RxSlot == RX_SLOT_WIN_CLASS_C )
 80342b2:	f894 3484 	ldrb.w	r3, [r4, #1156]	; 0x484
 80342b6:	2b02      	cmp	r3, #2
 80342b8:	d101      	bne.n	80342be <LoRaMacProcess+0x426>
        OpenContinuousRxCWindow( );
 80342ba:	f7ff fa27 	bl	803370c <OpenContinuousRxCWindow>
}
 80342be:	b025      	add	sp, #148	; 0x94
 80342c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 80342c4:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 80342c8:	2b01      	cmp	r3, #1
 80342ca:	d10c      	bne.n	80342e6 <LoRaMacProcess+0x44e>
        if( LoRaMacClassBIsPingExpected( ) == true )
 80342cc:	f001 fb73 	bl	80359b6 <LoRaMacClassBIsPingExpected>
 80342d0:	4607      	mov	r7, r0
 80342d2:	b1c8      	cbz	r0, 8034308 <LoRaMacProcess+0x470>
            LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 80342d4:	4640      	mov	r0, r8
 80342d6:	f001 fb63 	bl	80359a0 <LoRaMacClassBSetPingSlotState>
            LoRaMacClassBPingSlotTimerEvent( NULL );
 80342da:	4640      	mov	r0, r8
 80342dc:	f001 fb65 	bl	80359aa <LoRaMacClassBPingSlotTimerEvent>
            MacCtx.RxStatus.RxSlot = RX_SLOT_WIN_CLASS_B_PING_SLOT;
 80342e0:	2304      	movs	r3, #4
            MacCtx.RxStatus.RxSlot = RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT;
 80342e2:	f884 3483 	strb.w	r3, [r4, #1155]	; 0x483
    macHdr.Value = payload[pktHeaderLen++];
 80342e6:	f896 b000 	ldrb.w	fp, [r6]
    switch( macHdr.Bits.MType )
 80342ea:	ea4f 135b 	mov.w	r3, fp, lsr #5
 80342ee:	3b01      	subs	r3, #1
 80342f0:	2b06      	cmp	r3, #6
 80342f2:	f200 81e3 	bhi.w	80346bc <LoRaMacProcess+0x824>
 80342f6:	e8df f013 	tbh	[pc, r3, lsl #1]
 80342fa:	0013      	.short	0x0013
 80342fc:	009a01e1 	.word	0x009a01e1
 8034300:	009701e1 	.word	0x009701e1
 8034304:	01d201e1 	.word	0x01d201e1
        else if( LoRaMacClassBIsMulticastExpected( ) == true )
 8034308:	f001 fb57 	bl	80359ba <LoRaMacClassBIsMulticastExpected>
 803430c:	2800      	cmp	r0, #0
 803430e:	d0ea      	beq.n	80342e6 <LoRaMacProcess+0x44e>
            LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 8034310:	4638      	mov	r0, r7
 8034312:	f001 fb46 	bl	80359a2 <LoRaMacClassBSetMulticastSlotState>
            LoRaMacClassBMulticastSlotTimerEvent( NULL );
 8034316:	4638      	mov	r0, r7
 8034318:	f001 fb48 	bl	80359ac <LoRaMacClassBMulticastSlotTimerEvent>
            MacCtx.RxStatus.RxSlot = RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT;
 803431c:	2305      	movs	r3, #5
 803431e:	e7e0      	b.n	80342e2 <LoRaMacProcess+0x44a>
            if( size < LORAMAC_JOIN_ACCEPT_FRAME_MIN_SIZE )
 8034320:	2d10      	cmp	r5, #16
 8034322:	d803      	bhi.n	803432c <LoRaMacProcess+0x494>
                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 8034324:	2301      	movs	r3, #1
 8034326:	f884 3421 	strb.w	r3, [r4, #1057]	; 0x421
 803432a:	e123      	b.n	8034574 <LoRaMacProcess+0x6dc>
            if( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE )
 803432c:	f894 361c 	ldrb.w	r3, [r4, #1564]	; 0x61c
            macMsgJoinAccept.Buffer = payload;
 8034330:	960e      	str	r6, [sp, #56]	; 0x38
            macMsgJoinAccept.BufSize = size;
 8034332:	b2ed      	uxtb	r5, r5
 8034334:	f88d 503c 	strb.w	r5, [sp, #60]	; 0x3c
            if( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE )
 8034338:	2b00      	cmp	r3, #0
 803433a:	d1f3      	bne.n	8034324 <LoRaMacProcess+0x48c>
            macCryptoStatus = LoRaMacCryptoHandleJoinAccept( JOIN_REQ, SecureElementGetJoinEui( ), &macMsgJoinAccept );
 803433c:	f004 fdd0 	bl	8038ee0 <SecureElementGetJoinEui>
 8034340:	aa0e      	add	r2, sp, #56	; 0x38
 8034342:	4601      	mov	r1, r0
 8034344:	20ff      	movs	r0, #255	; 0xff
 8034346:	f001 ffdb 	bl	8036300 <LoRaMacCryptoHandleJoinAccept>
            if( LORAMAC_CRYPTO_SUCCESS == macCryptoStatus )
 803434a:	2800      	cmp	r0, #0
 803434c:	d160      	bne.n	8034410 <LoRaMacProcess+0x578>
                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[2] << 16 );
 803434e:	f89d 3043 	ldrb.w	r3, [sp, #67]	; 0x43
                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[1] << 8 );
 8034352:	f89d 2042 	ldrb.w	r2, [sp, #66]	; 0x42
                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[2] << 16 );
 8034356:	041b      	lsls	r3, r3, #16
 8034358:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
                Nvm.MacGroup2.NetID = ( uint32_t ) macMsgJoinAccept.NetID[0];
 803435c:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[2] << 16 );
 8034360:	4313      	orrs	r3, r2
 8034362:	f8c4 35d4 	str.w	r3, [r4, #1492]	; 0x5d4
                Nvm.MacGroup2.DevAddr = macMsgJoinAccept.DevAddr;
 8034366:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8034368:	f8c4 35d8 	str.w	r3, [r4, #1496]	; 0x5d8
                Nvm.MacGroup2.MacParams.Rx1DrOffset = macMsgJoinAccept.DLSettings.Bits.RX1DRoffset;
 803436c:	f89d 3048 	ldrb.w	r3, [sp, #72]	; 0x48
 8034370:	f3c3 1202 	ubfx	r2, r3, #4, #3
                Nvm.MacGroup2.MacParams.Rx2Channel.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;
 8034374:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8034378:	f884 3574 	strb.w	r3, [r4, #1396]	; 0x574
                Nvm.MacGroup2.MacParams.RxCChannel.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;
 803437c:	f884 357c 	strb.w	r3, [r4, #1404]	; 0x57c
                Nvm.MacGroup2.MacParams.ReceiveDelay1 = macMsgJoinAccept.RxDelay;
 8034380:	f89d 3049 	ldrb.w	r3, [sp, #73]	; 0x49
                Nvm.MacGroup2.MacParams.Rx1DrOffset = macMsgJoinAccept.DLSettings.Bits.RX1DRoffset;
 8034384:	f884 256d 	strb.w	r2, [r4, #1389]	; 0x56d
                if( Nvm.MacGroup2.MacParams.ReceiveDelay1 == 0 )
 8034388:	2b00      	cmp	r3, #0
 803438a:	d03f      	beq.n	803440c <LoRaMacProcess+0x574>
                    Nvm.MacGroup2.MacParams.ReceiveDelay1 = 1;
 803438c:	f8c4 355c 	str.w	r3, [r4, #1372]	; 0x55c
                Nvm.MacGroup2.MacParams.ReceiveDelay1 *= 1000;
 8034390:	f8d4 255c 	ldr.w	r2, [r4, #1372]	; 0x55c
                RegionApplyCFList( Nvm.MacGroup2.Region, &applyCFList );
 8034394:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
                Nvm.MacGroup2.MacParams.ReceiveDelay1 *= 1000;
 8034398:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 803439c:	4353      	muls	r3, r2
 803439e:	f8c4 355c 	str.w	r3, [r4, #1372]	; 0x55c
                Nvm.MacGroup2.MacParams.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay1 + 1000;
 80343a2:	f503 737a 	add.w	r3, r3, #1000	; 0x3e8
 80343a6:	f8c4 3560 	str.w	r3, [r4, #1376]	; 0x560
                Nvm.MacGroup2.Version.Fields.Minor = 0;
 80343aa:	2600      	movs	r6, #0
                applyCFList.Payload = macMsgJoinAccept.CFList;
 80343ac:	f10d 034a 	add.w	r3, sp, #74	; 0x4a
                applyCFList.Size = size - 17;
 80343b0:	3d11      	subs	r5, #17
                RegionApplyCFList( Nvm.MacGroup2.Region, &applyCFList );
 80343b2:	a90c      	add	r1, sp, #48	; 0x30
                applyCFList.Payload = macMsgJoinAccept.CFList;
 80343b4:	930c      	str	r3, [sp, #48]	; 0x30
                Nvm.MacGroup2.Version.Fields.Minor = 0;
 80343b6:	f884 661a 	strb.w	r6, [r4, #1562]	; 0x61a
                applyCFList.Size = size - 17;
 80343ba:	f88d 5034 	strb.w	r5, [sp, #52]	; 0x34
                RegionApplyCFList( Nvm.MacGroup2.Region, &applyCFList );
 80343be:	f002 f9e3 	bl	8036788 <RegionApplyCFList>
                Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_OTAA;
 80343c2:	2302      	movs	r3, #2
                if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )
 80343c4:	2001      	movs	r0, #1
                Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_OTAA;
 80343c6:	f884 361c 	strb.w	r3, [r4, #1564]	; 0x61c
                if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )
 80343ca:	f001 fcb9 	bl	8035d40 <LoRaMacConfirmQueueIsCmdActive>
 80343ce:	b118      	cbz	r0, 80343d8 <LoRaMacProcess+0x540>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_JOIN );
 80343d0:	2101      	movs	r1, #1
 80343d2:	4630      	mov	r0, r6
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL, MLME_JOIN );
 80343d4:	f001 fc78 	bl	8035cc8 <LoRaMacConfirmQueueSetStatus>
            MacCtx.MacFlags.Bits.MlmeInd = 1;
 80343d8:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 80343dc:	f043 0308 	orr.w	r3, r3, #8
            MacCtx.MacFlags.Bits.McpsInd = 1;
 80343e0:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
    if( MacCtx.NodeAckRequested == true )
 80343e4:	f894 3418 	ldrb.w	r3, [r4, #1048]	; 0x418
 80343e8:	2b00      	cmp	r3, #0
 80343ea:	f000 816d 	beq.w	80346c8 <LoRaMacProcess+0x830>
        if( MacCtx.McpsConfirm.AckReceived == true )
 80343ee:	f894 3440 	ldrb.w	r3, [r4, #1088]	; 0x440
 80343f2:	b113      	cbz	r3, 80343fa <LoRaMacProcess+0x562>
            OnAckTimeoutTimerEvent( NULL );
 80343f4:	2000      	movs	r0, #0
 80343f6:	f7fe fe33 	bl	8033060 <OnAckTimeoutTimerEvent>
    MacCtx.MacFlags.Bits.MacDone = 1;
 80343fa:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 80343fe:	f043 0320 	orr.w	r3, r3, #32
 8034402:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
    UpdateRxSlotIdleState( );
 8034406:	f7fe fde1 	bl	8032fcc <UpdateRxSlotIdleState>
 803440a:	e5f6      	b.n	8033ffa <LoRaMacProcess+0x162>
                    Nvm.MacGroup2.MacParams.ReceiveDelay1 = 1;
 803440c:	2301      	movs	r3, #1
 803440e:	e7bd      	b.n	803438c <LoRaMacProcess+0x4f4>
                if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )
 8034410:	2001      	movs	r0, #1
 8034412:	f001 fc95 	bl	8035d40 <LoRaMacConfirmQueueIsCmdActive>
 8034416:	2800      	cmp	r0, #0
 8034418:	d0de      	beq.n	80343d8 <LoRaMacProcess+0x540>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL, MLME_JOIN );
 803441a:	2101      	movs	r1, #1
 803441c:	2007      	movs	r0, #7
 803441e:	e7d9      	b.n	80343d4 <LoRaMacProcess+0x53c>
 8034420:	200055ec 	.word	0x200055ec
 8034424:	20004f24 	.word	0x20004f24
            MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED;
 8034428:	2301      	movs	r3, #1
 803442a:	f884 3420 	strb.w	r3, [r4, #1056]	; 0x420
            getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 803442e:	f894 3581 	ldrb.w	r3, [r4, #1409]	; 0x581
 8034432:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
            getPhy.Datarate = MacCtx.McpsIndication.RxDatarate;
 8034436:	f894 3424 	ldrb.w	r3, [r4, #1060]	; 0x424
 803443a:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
            getPhy.Attribute = PHY_MAX_PAYLOAD;
 803443e:	230d      	movs	r3, #13
 8034440:	f88d 3020 	strb.w	r3, [sp, #32]
            if( Nvm.MacGroup2.MacParams.RepeaterSupport == true )
 8034444:	f894 358c 	ldrb.w	r3, [r4, #1420]	; 0x58c
 8034448:	b113      	cbz	r3, 8034450 <LoRaMacProcess+0x5b8>
                getPhy.Attribute = PHY_MAX_PAYLOAD_REPEATER;
 803444a:	230e      	movs	r3, #14
 803444c:	f88d 3020 	strb.w	r3, [sp, #32]
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034450:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
 8034454:	a908      	add	r1, sp, #32
 8034456:	f002 f964 	bl	8036722 <RegionGetPhyParam>
            if( ( MAX( 0, ( int16_t )( ( int16_t ) size - ( int16_t ) LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE ) ) > ( int16_t )phyParam.Value ) ||
 803445a:	f1a5 030d 	sub.w	r3, r5, #13
 803445e:	b21b      	sxth	r3, r3
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034460:	9006      	str	r0, [sp, #24]
            if( ( MAX( 0, ( int16_t )( ( int16_t ) size - ( int16_t ) LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE ) ) > ( int16_t )phyParam.Value ) ||
 8034462:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8034466:	b200      	sxth	r0, r0
 8034468:	4283      	cmp	r3, r0
 803446a:	f73f af5b 	bgt.w	8034324 <LoRaMacProcess+0x48c>
 803446e:	2d0b      	cmp	r5, #11
 8034470:	f67f af58 	bls.w	8034324 <LoRaMacProcess+0x48c>
            macMsgData.FRMPayload = MacCtx.RxPayload;
 8034474:	4bb9      	ldr	r3, [pc, #740]	; (803475c <LoRaMacProcess+0x8c4>)
 8034476:	9321      	str	r3, [sp, #132]	; 0x84
            if( LORAMAC_PARSER_SUCCESS != LoRaMacParserData( &macMsgData ) )
 8034478:	a818      	add	r0, sp, #96	; 0x60
            macMsgData.FRMPayloadSize = LORAMAC_PHY_MAXPAYLOAD;
 803447a:	23ff      	movs	r3, #255	; 0xff
            macMsgData.Buffer = payload;
 803447c:	9618      	str	r6, [sp, #96]	; 0x60
            macMsgData.BufSize = size;
 803447e:	f88d 5064 	strb.w	r5, [sp, #100]	; 0x64
            macMsgData.FRMPayloadSize = LORAMAC_PHY_MAXPAYLOAD;
 8034482:	f88d 3088 	strb.w	r3, [sp, #136]	; 0x88
            if( LORAMAC_PARSER_SUCCESS != LoRaMacParserData( &macMsgData ) )
 8034486:	f002 f843 	bl	8036510 <LoRaMacParserData>
 803448a:	4606      	mov	r6, r0
 803448c:	2800      	cmp	r0, #0
 803448e:	f47f af49 	bne.w	8034324 <LoRaMacProcess+0x48c>
    if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen > 0 ) && ( macMsg->FPort > 0 ) )
 8034492:	f89d 306c 	ldrb.w	r3, [sp, #108]	; 0x6c
            MacCtx.McpsIndication.DevAddress = macMsgData.FHDR.DevAddr;
 8034496:	991a      	ldr	r1, [sp, #104]	; 0x68
 8034498:	f8c4 1434 	str.w	r1, [r4, #1076]	; 0x434
    if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen > 0 ) && ( macMsg->FPort > 0 ) )
 803449c:	f013 020f 	ands.w	r2, r3, #15
 80344a0:	d003      	beq.n	80344aa <LoRaMacProcess+0x612>
 80344a2:	f89d 0080 	ldrb.w	r0, [sp, #128]	; 0x80
 80344a6:	2800      	cmp	r0, #0
 80344a8:	d167      	bne.n	803457a <LoRaMacProcess+0x6e2>
    else if( macMsg->FRMPayloadSize == 0 )
 80344aa:	f89d 0088 	ldrb.w	r0, [sp, #136]	; 0x88
 80344ae:	2800      	cmp	r0, #0
 80344b0:	d065      	beq.n	803457e <LoRaMacProcess+0x6e6>
    else if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen == 0 ) && ( macMsg->FPort == 0 ) )
 80344b2:	2a00      	cmp	r2, #0
 80344b4:	f47f af36 	bne.w	8034324 <LoRaMacProcess+0x48c>
 80344b8:	f89d 2080 	ldrb.w	r2, [sp, #128]	; 0x80
        *fType = FRAME_TYPE_D;
 80344bc:	2a00      	cmp	r2, #0
 80344be:	bf0c      	ite	eq
 80344c0:	2502      	moveq	r5, #2
 80344c2:	2503      	movne	r5, #3
            downLinkCounter = 0;
 80344c4:	2200      	movs	r2, #0
 80344c6:	9207      	str	r2, [sp, #28]
                if( ( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.Address == macMsgData.FHDR.DevAddr ) &&
 80344c8:	f8d4 25e0 	ldr.w	r2, [r4, #1504]	; 0x5e0
 80344cc:	4291      	cmp	r1, r2
 80344ce:	d158      	bne.n	8034582 <LoRaMacProcess+0x6ea>
 80344d0:	f894 15de 	ldrb.w	r1, [r4, #1502]	; 0x5de
 80344d4:	2900      	cmp	r1, #0
 80344d6:	d054      	beq.n	8034582 <LoRaMacProcess+0x6ea>
                    downLinkCounter = *( Nvm.MacGroup2.MulticastChannelList[i].DownLinkCounter );
 80344d8:	f8d4 15fc 	ldr.w	r1, [r4, #1532]	; 0x5fc
                    addrID = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.GroupID;
 80344dc:	f894 85df 	ldrb.w	r8, [r4, #1503]	; 0x5df
                    downLinkCounter = *( Nvm.MacGroup2.MulticastChannelList[i].DownLinkCounter );
 80344e0:	6809      	ldr	r1, [r1, #0]
 80344e2:	9107      	str	r1, [sp, #28]
                    if( Nvm.MacGroup2.DeviceClass == CLASS_C )
 80344e4:	f894 1608 	ldrb.w	r1, [r4, #1544]	; 0x608
 80344e8:	2902      	cmp	r1, #2
 80344ea:	d102      	bne.n	80344f2 <LoRaMacProcess+0x65a>
                        MacCtx.RxStatus.RxSlot = RX_SLOT_WIN_CLASS_C_MULTICAST;
 80344ec:	2103      	movs	r1, #3
 80344ee:	f884 1483 	strb.w	r1, [r4, #1155]	; 0x483
            if( ( multicast == 1 ) && ( ( fType != FRAME_TYPE_D ) ||
 80344f2:	2d03      	cmp	r5, #3
 80344f4:	f47f af16 	bne.w	8034324 <LoRaMacProcess+0x48c>
                                        ( macMsgData.FHDR.FCtrl.Bits.Ack != 0 ) ||
 80344f8:	f013 0f60 	tst.w	r3, #96	; 0x60
 80344fc:	f47f af12 	bne.w	8034324 <LoRaMacProcess+0x48c>
 8034500:	9203      	str	r2, [sp, #12]
 8034502:	2601      	movs	r6, #1
            getPhy.Attribute = PHY_MAX_FCNT_GAP;
 8034504:	2315      	movs	r3, #21
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034506:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
            getPhy.Attribute = PHY_MAX_FCNT_GAP;
 803450a:	f88d 3020 	strb.w	r3, [sp, #32]
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803450e:	a908      	add	r1, sp, #32
 8034510:	f002 f907 	bl	8036722 <RegionGetPhyParam>
            macCryptoStatus = GetFCntDown( addrID, fType, &macMsgData, Nvm.MacGroup2.Version, phyParam.Value, &fCntID, &downLinkCounter );
 8034514:	f894 761a 	ldrb.w	r7, [r4, #1562]	; 0x61a
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034518:	9006      	str	r0, [sp, #24]
    switch( addrID )
 803451a:	f1b8 0f00 	cmp.w	r8, #0
 803451e:	d033      	beq.n	8034588 <LoRaMacProcess+0x6f0>
 8034520:	f1b8 0f01 	cmp.w	r8, #1
 8034524:	d13c      	bne.n	80345a0 <LoRaMacProcess+0x708>
            if( lrWanVersion.Fields.Minor == 1 )
 8034526:	2f01      	cmp	r7, #1
 8034528:	d130      	bne.n	803458c <LoRaMacProcess+0x6f4>
                if( ( fType == FRAME_TYPE_A ) || ( fType == FRAME_TYPE_D ) )
 803452a:	b38d      	cbz	r5, 8034590 <LoRaMacProcess+0x6f8>
                    *fCntID = A_FCNT_DOWN;
 803452c:	2d03      	cmp	r5, #3
 803452e:	bf14      	ite	ne
 8034530:	4647      	movne	r7, r8
 8034532:	2702      	moveq	r7, #2
    return LoRaMacCryptoGetFCntDown( *fCntID, maxFCntGap, macMsg->FHDR.FCnt, currentDown );
 8034534:	f8bd 206e 	ldrh.w	r2, [sp, #110]	; 0x6e
 8034538:	f8bd 1018 	ldrh.w	r1, [sp, #24]
 803453c:	ab07      	add	r3, sp, #28
 803453e:	4638      	mov	r0, r7
 8034540:	f001 fd6c 	bl	803601c <LoRaMacCryptoGetFCntDown>
            if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS )
 8034544:	b370      	cbz	r0, 80345a4 <LoRaMacProcess+0x70c>
                if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_FCNT_DUPLICATED )
 8034546:	2807      	cmp	r0, #7
 8034548:	d124      	bne.n	8034594 <LoRaMacProcess+0x6fc>
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_REPEATED;
 803454a:	2308      	movs	r3, #8
 803454c:	f884 3421 	strb.w	r3, [r4, #1057]	; 0x421
                    if( ( Nvm.MacGroup2.Version.Fields.Minor == 0 ) && ( macHdr.Bits.MType == FRAME_TYPE_DATA_CONFIRMED_DOWN ) && ( Nvm.MacGroup1.LastRxMic == macMsgData.MIC ) )
 8034550:	f894 361a 	ldrb.w	r3, [r4, #1562]	; 0x61a
 8034554:	b95b      	cbnz	r3, 803456e <LoRaMacProcess+0x6d6>
 8034556:	f00b 03e0 	and.w	r3, fp, #224	; 0xe0
 803455a:	2ba0      	cmp	r3, #160	; 0xa0
 803455c:	d107      	bne.n	803456e <LoRaMacProcess+0x6d6>
 803455e:	f8d4 2540 	ldr.w	r2, [r4, #1344]	; 0x540
 8034562:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8034564:	429a      	cmp	r2, r3
 8034566:	d102      	bne.n	803456e <LoRaMacProcess+0x6d6>
                        Nvm.MacGroup1.SrvAckRequested = true;
 8034568:	2301      	movs	r3, #1
 803456a:	f884 3546 	strb.w	r3, [r4, #1350]	; 0x546
                MacCtx.McpsIndication.DownLinkCounter = downLinkCounter;
 803456e:	9b07      	ldr	r3, [sp, #28]
 8034570:	f8c4 3430 	str.w	r3, [r4, #1072]	; 0x430
                PrepareRxDoneAbort( );
 8034574:	f7fe fd96 	bl	80330a4 <PrepareRxDoneAbort>
                return;
 8034578:	e53f      	b.n	8033ffa <LoRaMacProcess+0x162>
        *fType = FRAME_TYPE_A;
 803457a:	4635      	mov	r5, r6
 803457c:	e7a2      	b.n	80344c4 <LoRaMacProcess+0x62c>
        *fType = FRAME_TYPE_B;
 803457e:	2501      	movs	r5, #1
 8034580:	e7a0      	b.n	80344c4 <LoRaMacProcess+0x62c>
 8034582:	f04f 0801 	mov.w	r8, #1
 8034586:	e7bd      	b.n	8034504 <LoRaMacProcess+0x66c>
    switch( addrID )
 8034588:	2704      	movs	r7, #4
 803458a:	e7d3      	b.n	8034534 <LoRaMacProcess+0x69c>
                *fCntID = FCNT_DOWN;
 803458c:	2703      	movs	r7, #3
 803458e:	e7d1      	b.n	8034534 <LoRaMacProcess+0x69c>
                    *fCntID = A_FCNT_DOWN;
 8034590:	2702      	movs	r7, #2
 8034592:	e7cf      	b.n	8034534 <LoRaMacProcess+0x69c>
                else if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_MAX_GAP_FCNT )
 8034594:	2808      	cmp	r0, #8
 8034596:	d103      	bne.n	80345a0 <LoRaMacProcess+0x708>
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_TOO_MANY_FRAMES_LOSS;
 8034598:	230a      	movs	r3, #10
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 803459a:	f884 3421 	strb.w	r3, [r4, #1057]	; 0x421
 803459e:	e7e6      	b.n	803456e <LoRaMacProcess+0x6d6>
 80345a0:	2301      	movs	r3, #1
 80345a2:	e7fa      	b.n	803459a <LoRaMacProcess+0x702>
            macCryptoStatus = LoRaMacCryptoUnsecureMessage( addrID, address, fCntID, downLinkCounter, &macMsgData );
 80345a4:	ab18      	add	r3, sp, #96	; 0x60
 80345a6:	9300      	str	r3, [sp, #0]
 80345a8:	9903      	ldr	r1, [sp, #12]
 80345aa:	9b07      	ldr	r3, [sp, #28]
 80345ac:	463a      	mov	r2, r7
 80345ae:	4640      	mov	r0, r8
 80345b0:	f001 fe04 	bl	80361bc <LoRaMacCryptoUnsecureMessage>
            if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS )
 80345b4:	b120      	cbz	r0, 80345c0 <LoRaMacProcess+0x728>
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_MIC_FAIL;
 80345b6:	2802      	cmp	r0, #2
 80345b8:	bf0c      	ite	eq
 80345ba:	230b      	moveq	r3, #11
 80345bc:	230c      	movne	r3, #12
 80345be:	e6b2      	b.n	8034326 <LoRaMacProcess+0x48e>
            MacCtx.McpsIndication.FramePending = macMsgData.FHDR.FCtrl.Bits.FPending;
 80345c0:	f89d 306c 	ldrb.w	r3, [sp, #108]	; 0x6c
            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK;
 80345c4:	f884 0421 	strb.w	r0, [r4, #1057]	; 0x421
            MacCtx.McpsIndication.FramePending = macMsgData.FHDR.FCtrl.Bits.FPending;
 80345c8:	f3c3 1200 	ubfx	r2, r3, #4, #1
 80345cc:	f884 2425 	strb.w	r2, [r4, #1061]	; 0x425
            MacCtx.McpsIndication.DownLinkCounter = downLinkCounter;
 80345d0:	9a07      	ldr	r2, [sp, #28]
 80345d2:	f8c4 2430 	str.w	r2, [r4, #1072]	; 0x430
            if( ( MacCtx.RxStatus.RxSlot == RX_SLOT_WIN_1 ) ||
 80345d6:	f894 2483 	ldrb.w	r2, [r4, #1155]	; 0x483
            MacCtx.McpsIndication.Multicast = multicast;
 80345da:	f884 6422 	strb.w	r6, [r4, #1058]	; 0x422
            if( ( MacCtx.RxStatus.RxSlot == RX_SLOT_WIN_1 ) ||
 80345de:	2a01      	cmp	r2, #1
            MacCtx.McpsIndication.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;
 80345e0:	f3c3 1340 	ubfx	r3, r3, #5, #1
                Nvm.MacGroup1.AdrAckCounter = 0;
 80345e4:	bf98      	it	ls
 80345e6:	f8c4 0534 	strls.w	r0, [r4, #1332]	; 0x534
            if( multicast == 1 )
 80345ea:	2e01      	cmp	r6, #1
            MacCtx.McpsIndication.Buffer = NULL;
 80345ec:	f8c4 0428 	str.w	r0, [r4, #1064]	; 0x428
            MacCtx.McpsIndication.BufferSize = 0;
 80345f0:	f884 042c 	strb.w	r0, [r4, #1068]	; 0x42c
            MacCtx.McpsIndication.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;
 80345f4:	f884 342e 	strb.w	r3, [r4, #1070]	; 0x42e
            MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;
 80345f8:	f884 043d 	strb.w	r0, [r4, #1085]	; 0x43d
            MacCtx.McpsConfirm.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;
 80345fc:	f884 3440 	strb.w	r3, [r4, #1088]	; 0x440
            if( multicast == 1 )
 8034600:	d12b      	bne.n	803465a <LoRaMacProcess+0x7c2>
                MacCtx.McpsIndication.McpsIndication = MCPS_MULTICAST;
 8034602:	2302      	movs	r3, #2
    if( rxSlot == RX_SLOT_WIN_1 || rxSlot == RX_SLOT_WIN_2  )
 8034604:	2a01      	cmp	r2, #1
                    MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED;
 8034606:	f884 3420 	strb.w	r3, [r4, #1056]	; 0x420
            RemoveMacCommands( MacCtx.RxStatus.RxSlot, macMsgData.FHDR.FCtrl, MacCtx.McpsConfirm.McpsRequest );
 803460a:	f894 143c 	ldrb.w	r1, [r4, #1084]	; 0x43c
 803460e:	f89d 306c 	ldrb.w	r3, [sp, #108]	; 0x6c
    if( rxSlot == RX_SLOT_WIN_1 || rxSlot == RX_SLOT_WIN_2  )
 8034612:	d805      	bhi.n	8034620 <LoRaMacProcess+0x788>
        if( request == MCPS_CONFIRMED )
 8034614:	2901      	cmp	r1, #1
 8034616:	d101      	bne.n	803461c <LoRaMacProcess+0x784>
            if( fCtrl.Bits.Ack == 1 )
 8034618:	069b      	lsls	r3, r3, #26
 803461a:	d501      	bpl.n	8034620 <LoRaMacProcess+0x788>
                LoRaMacCommandsRemoveStickyAnsCmds( );
 803461c:	f001 fa7c 	bl	8035b18 <LoRaMacCommandsRemoveStickyAnsCmds>
            switch( fType )
 8034620:	2d02      	cmp	r5, #2
 8034622:	d02d      	beq.n	8034680 <LoRaMacProcess+0x7e8>
 8034624:	2d03      	cmp	r5, #3
 8034626:	d009      	beq.n	803463c <LoRaMacProcess+0x7a4>
 8034628:	f89d 106c 	ldrb.w	r1, [sp, #108]	; 0x6c
 803462c:	2d01      	cmp	r5, #1
                    ProcessMacCommands( macMsgData.FHDR.FOpts, 0, macMsgData.FHDR.FCtrl.Bits.FOptsLen, snr, MacCtx.RxStatus.RxSlot );
 803462e:	464a      	mov	r2, r9
 8034630:	f001 010f 	and.w	r1, r1, #15
 8034634:	a81c      	add	r0, sp, #112	; 0x70
 8034636:	d027      	beq.n	8034688 <LoRaMacProcess+0x7f0>
 8034638:	f7ff f950 	bl	80338dc <ProcessMacCommands.isra.0.constprop.0>
                    MacCtx.McpsIndication.Port = macMsgData.FPort;
 803463c:	f89d 3080 	ldrb.w	r3, [sp, #128]	; 0x80
 8034640:	f884 3423 	strb.w	r3, [r4, #1059]	; 0x423
                    MacCtx.McpsIndication.Buffer = macMsgData.FRMPayload;
 8034644:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8034646:	f8c4 3428 	str.w	r3, [r4, #1064]	; 0x428
                    MacCtx.McpsIndication.BufferSize = macMsgData.FRMPayloadSize;
 803464a:	f89d 3088 	ldrb.w	r3, [sp, #136]	; 0x88
 803464e:	f884 342c 	strb.w	r3, [r4, #1068]	; 0x42c
                    MacCtx.McpsIndication.RxData = true;
 8034652:	2301      	movs	r3, #1
 8034654:	f884 342d 	strb.w	r3, [r4, #1069]	; 0x42d
                    break;
 8034658:	e01c      	b.n	8034694 <LoRaMacProcess+0x7fc>
                if( macHdr.Bits.MType == FRAME_TYPE_DATA_CONFIRMED_DOWN )
 803465a:	f00b 03e0 	and.w	r3, fp, #224	; 0xe0
 803465e:	2ba0      	cmp	r3, #160	; 0xa0
 8034660:	d10a      	bne.n	8034678 <LoRaMacProcess+0x7e0>
                    if( Nvm.MacGroup2.Version.Fields.Minor == 0 )
 8034662:	f894 161a 	ldrb.w	r1, [r4, #1562]	; 0x61a
                    Nvm.MacGroup1.SrvAckRequested = true;
 8034666:	2301      	movs	r3, #1
 8034668:	f884 3546 	strb.w	r3, [r4, #1350]	; 0x546
                    if( Nvm.MacGroup2.Version.Fields.Minor == 0 )
 803466c:	2900      	cmp	r1, #0
 803466e:	d1c9      	bne.n	8034604 <LoRaMacProcess+0x76c>
                        Nvm.MacGroup1.LastRxMic = macMsgData.MIC;
 8034670:	9923      	ldr	r1, [sp, #140]	; 0x8c
 8034672:	f8c4 1540 	str.w	r1, [r4, #1344]	; 0x540
                    MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED;
 8034676:	e7c5      	b.n	8034604 <LoRaMacProcess+0x76c>
                    Nvm.MacGroup1.SrvAckRequested = false;
 8034678:	2300      	movs	r3, #0
 803467a:	f884 3546 	strb.w	r3, [r4, #1350]	; 0x546
 803467e:	e7c1      	b.n	8034604 <LoRaMacProcess+0x76c>
                    ProcessMacCommands( macMsgData.FRMPayload, 0, macMsgData.FRMPayloadSize, snr, MacCtx.RxStatus.RxSlot );
 8034680:	f89d 1088 	ldrb.w	r1, [sp, #136]	; 0x88
 8034684:	9821      	ldr	r0, [sp, #132]	; 0x84
 8034686:	464a      	mov	r2, r9
 8034688:	f7ff f928 	bl	80338dc <ProcessMacCommands.isra.0.constprop.0>
                    MacCtx.McpsIndication.Port = macMsgData.FPort;
 803468c:	f89d 3080 	ldrb.w	r3, [sp, #128]	; 0x80
 8034690:	f884 3423 	strb.w	r3, [r4, #1059]	; 0x423
            MacCtx.MacFlags.Bits.McpsInd = 1;
 8034694:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 8034698:	f043 0302 	orr.w	r3, r3, #2
 803469c:	e6a0      	b.n	80343e0 <LoRaMacProcess+0x548>
            memcpy1( MacCtx.RxPayload, &payload[pktHeaderLen], size - pktHeaderLen );
 803469e:	4f2f      	ldr	r7, [pc, #188]	; (803475c <LoRaMacProcess+0x8c4>)
 80346a0:	3d01      	subs	r5, #1
 80346a2:	b2aa      	uxth	r2, r5
 80346a4:	1c71      	adds	r1, r6, #1
 80346a6:	4638      	mov	r0, r7
 80346a8:	f004 fc42 	bl	8038f30 <memcpy1>
            MacCtx.McpsIndication.McpsIndication = MCPS_PROPRIETARY;
 80346ac:	2303      	movs	r3, #3
 80346ae:	f8a4 3420 	strh.w	r3, [r4, #1056]	; 0x420
            MacCtx.McpsIndication.Buffer = MacCtx.RxPayload;
 80346b2:	f8c4 7428 	str.w	r7, [r4, #1064]	; 0x428
            MacCtx.McpsIndication.BufferSize = size - pktHeaderLen;
 80346b6:	f884 542c 	strb.w	r5, [r4, #1068]	; 0x42c
            MacCtx.MacFlags.Bits.McpsInd = 1;
 80346ba:	e7eb      	b.n	8034694 <LoRaMacProcess+0x7fc>
            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 80346bc:	2301      	movs	r3, #1
 80346be:	f884 3421 	strb.w	r3, [r4, #1057]	; 0x421
            PrepareRxDoneAbort( );
 80346c2:	f7fe fcef 	bl	80330a4 <PrepareRxDoneAbort>
            break;
 80346c6:	e68d      	b.n	80343e4 <LoRaMacProcess+0x54c>
        if( Nvm.MacGroup2.DeviceClass == CLASS_C )
 80346c8:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 80346cc:	2b02      	cmp	r3, #2
 80346ce:	f47f ae94 	bne.w	80343fa <LoRaMacProcess+0x562>
 80346d2:	e68f      	b.n	80343f4 <LoRaMacProcess+0x55c>
    if( MacCtx.MacFlags.Bits.MlmeReq == 1 )
 80346d4:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 80346d8:	0759      	lsls	r1, r3, #29
 80346da:	d50f      	bpl.n	80346fc <LoRaMacProcess+0x864>
        if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )
 80346dc:	2001      	movs	r0, #1
 80346de:	f001 fb2f 	bl	8035d40 <LoRaMacConfirmQueueIsCmdActive>
 80346e2:	b380      	cbz	r0, 8034746 <LoRaMacProcess+0x8ae>
            if( LoRaMacConfirmQueueGetStatus( MLME_JOIN ) == LORAMAC_EVENT_INFO_STATUS_OK )
 80346e4:	2001      	movs	r0, #1
 80346e6:	f001 fb01 	bl	8035cec <LoRaMacConfirmQueueGetStatus>
 80346ea:	b908      	cbnz	r0, 80346f0 <LoRaMacProcess+0x858>
                MacCtx.ChannelsNbTransCounter = 0;
 80346ec:	f884 0414 	strb.w	r0, [r4, #1044]	; 0x414
            MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 80346f0:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 80346f4:	f023 0302 	bic.w	r3, r3, #2
 80346f8:	f8c4 3344 	str.w	r3, [r4, #836]	; 0x344
    if( MacCtx.MacFlags.Bits.McpsReq == 1 )
 80346fc:	f894 1485 	ldrb.w	r1, [r4, #1157]	; 0x485
 8034700:	07ca      	lsls	r2, r1, #31
 8034702:	f57f accf 	bpl.w	80340a4 <LoRaMacProcess+0x20c>
        if( ( MacCtx.McpsConfirm.McpsRequest == MCPS_UNCONFIRMED ) ||
 8034706:	f894 343c 	ldrb.w	r3, [r4, #1084]	; 0x43c
 803470a:	b10b      	cbz	r3, 8034710 <LoRaMacProcess+0x878>
 803470c:	2b03      	cmp	r3, #3
 803470e:	d129      	bne.n	8034764 <LoRaMacProcess+0x8cc>
    if( MacCtx.ChannelsNbTransCounter >=
 8034710:	f894 2414 	ldrb.w	r2, [r4, #1044]	; 0x414
 8034714:	f894 356c 	ldrb.w	r3, [r4, #1388]	; 0x56c
 8034718:	429a      	cmp	r2, r3
 803471a:	d208      	bcs.n	803472e <LoRaMacProcess+0x896>
    else if( MacCtx.MacFlags.Bits.McpsInd == 1 )
 803471c:	078b      	lsls	r3, r1, #30
 803471e:	d553      	bpl.n	80347c8 <LoRaMacProcess+0x930>
        if( Nvm.MacGroup2.DeviceClass == CLASS_A )
 8034720:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 8034724:	b11b      	cbz	r3, 803472e <LoRaMacProcess+0x896>
            if( MacCtx.RxStatus.RxSlot == RX_SLOT_WIN_1 )
 8034726:	f894 3483 	ldrb.w	r3, [r4, #1155]	; 0x483
 803472a:	2b00      	cmp	r3, #0
 803472c:	d14c      	bne.n	80347c8 <LoRaMacProcess+0x930>
            TimerStop( &MacCtx.TxDelayedTimer );
 803472e:	480c      	ldr	r0, [pc, #48]	; (8034760 <LoRaMacProcess+0x8c8>)
 8034730:	f006 fe06 	bl	803b340 <UTIL_TIMER_Stop>
            MacCtx.MacState &= ~LORAMAC_TX_DELAYED;
 8034734:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 8034738:	f023 0320 	bic.w	r3, r3, #32
 803473c:	f8c4 3344 	str.w	r3, [r4, #836]	; 0x344
            StopRetransmission( );
 8034740:	f7fe fc50 	bl	8032fe4 <StopRetransmission>
 8034744:	e4ae      	b.n	80340a4 <LoRaMacProcess+0x20c>
        else if( ( LoRaMacConfirmQueueIsCmdActive( MLME_TXCW ) == true ) ||
 8034746:	2005      	movs	r0, #5
 8034748:	f001 fafa 	bl	8035d40 <LoRaMacConfirmQueueIsCmdActive>
 803474c:	2800      	cmp	r0, #0
 803474e:	d1cf      	bne.n	80346f0 <LoRaMacProcess+0x858>
                 ( LoRaMacConfirmQueueIsCmdActive( MLME_TXCW_1 ) == true ) )
 8034750:	2006      	movs	r0, #6
 8034752:	f001 faf5 	bl	8035d40 <LoRaMacConfirmQueueIsCmdActive>
        else if( ( LoRaMacConfirmQueueIsCmdActive( MLME_TXCW ) == true ) ||
 8034756:	2800      	cmp	r0, #0
 8034758:	d1ca      	bne.n	80346f0 <LoRaMacProcess+0x858>
 803475a:	e7cf      	b.n	80346fc <LoRaMacProcess+0x864>
 803475c:	20004ce0 	.word	0x20004ce0
 8034760:	20004e10 	.word	0x20004e10
        else if( MacCtx.McpsConfirm.McpsRequest == MCPS_CONFIRMED )
 8034764:	2b01      	cmp	r3, #1
 8034766:	d12f      	bne.n	80347c8 <LoRaMacProcess+0x930>
            if( MacCtx.AckTimeoutRetry == true )
 8034768:	f894 2417 	ldrb.w	r2, [r4, #1047]	; 0x417
 803476c:	2a00      	cmp	r2, #0
 803476e:	f43f ac99 	beq.w	80340a4 <LoRaMacProcess+0x20c>
    if( MacCtx.AckTimeoutRetriesCounter >=
 8034772:	f894 3416 	ldrb.w	r3, [r4, #1046]	; 0x416
        MacCtx.AckTimeoutRetries )
 8034776:	f894 0415 	ldrb.w	r0, [r4, #1045]	; 0x415
    if( MacCtx.AckTimeoutRetriesCounter >=
 803477a:	4283      	cmp	r3, r0
 803477c:	d204      	bcs.n	8034788 <LoRaMacProcess+0x8f0>
    else if( MacCtx.MacFlags.Bits.McpsInd == 1 )
 803477e:	f011 0202 	ands.w	r2, r1, #2
        if( MacCtx.McpsConfirm.AckReceived == true )
 8034782:	bf18      	it	ne
 8034784:	f894 2440 	ldrbne.w	r2, [r4, #1088]	; 0x440
                if( Nvm.MacGroup2.Version.Fields.Minor == 0 )
 8034788:	f894 161a 	ldrb.w	r1, [r4, #1562]	; 0x61a
 803478c:	2900      	cmp	r1, #0
 803478e:	d13f      	bne.n	8034810 <LoRaMacProcess+0x978>
                    if( stopRetransmission == false )
 8034790:	bb32      	cbnz	r2, 80347e0 <LoRaMacProcess+0x948>
    if( MacCtx.AckTimeoutRetriesCounter < MacCtx.AckTimeoutRetries )
 8034792:	4283      	cmp	r3, r0
 8034794:	d218      	bcs.n	80347c8 <LoRaMacProcess+0x930>
        MacCtx.AckTimeoutRetriesCounter++;
 8034796:	3301      	adds	r3, #1
 8034798:	b2db      	uxtb	r3, r3
        if( ( MacCtx.AckTimeoutRetriesCounter % 2 ) == 1 )
 803479a:	07df      	lsls	r7, r3, #31
        MacCtx.AckTimeoutRetriesCounter++;
 803479c:	f884 3416 	strb.w	r3, [r4, #1046]	; 0x416
        if( ( MacCtx.AckTimeoutRetriesCounter % 2 ) == 1 )
 80347a0:	d512      	bpl.n	80347c8 <LoRaMacProcess+0x930>
            getPhy.Attribute = PHY_NEXT_LOWER_TX_DR;
 80347a2:	2322      	movs	r3, #34	; 0x22
 80347a4:	f88d 3060 	strb.w	r3, [sp, #96]	; 0x60
            getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 80347a8:	f894 3580 	ldrb.w	r3, [r4, #1408]	; 0x580
 80347ac:	f88d 3062 	strb.w	r3, [sp, #98]	; 0x62
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80347b0:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
            getPhy.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 80347b4:	f894 3545 	ldrb.w	r3, [r4, #1349]	; 0x545
 80347b8:	f88d 3061 	strb.w	r3, [sp, #97]	; 0x61
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80347bc:	a918      	add	r1, sp, #96	; 0x60
 80347be:	f001 ffb0 	bl	8036722 <RegionGetPhyParam>
 80347c2:	900e      	str	r0, [sp, #56]	; 0x38
            Nvm.MacGroup1.ChannelsDatarate = phyParam.Value;
 80347c4:	f884 0545 	strb.w	r0, [r4, #1349]	; 0x545
            MacCtx.MacFlags.Bits.MacDone = 0;
 80347c8:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
            MacCtx.AckTimeoutRetry = false;
 80347cc:	2000      	movs	r0, #0
            MacCtx.MacFlags.Bits.MacDone = 0;
 80347ce:	f36f 1345 	bfc	r3, #5, #1
 80347d2:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
            MacCtx.AckTimeoutRetry = false;
 80347d6:	f884 0417 	strb.w	r0, [r4, #1047]	; 0x417
            OnTxDelayedTimerEvent( NULL );
 80347da:	f7fe ff71 	bl	80336c0 <OnTxDelayedTimerEvent>
 80347de:	e461      	b.n	80340a4 <LoRaMacProcess+0x20c>
    if( MacCtx.McpsConfirm.AckReceived == false )
 80347e0:	f894 5440 	ldrb.w	r5, [r4, #1088]	; 0x440
 80347e4:	b97d      	cbnz	r5, 8034806 <LoRaMacProcess+0x96e>
        params.Type = INIT_TYPE_ACTIVATE_DEFAULT_CHANNELS;
 80347e6:	2302      	movs	r3, #2
 80347e8:	f88d 3068 	strb.w	r3, [sp, #104]	; 0x68
        params.NvmGroup1 = &Nvm.RegionGroup1;
 80347ec:	4b0a      	ldr	r3, [pc, #40]	; (8034818 <LoRaMacProcess+0x980>)
 80347ee:	9318      	str	r3, [sp, #96]	; 0x60
        RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 80347f0:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
        params.NvmGroup2 = &Nvm.RegionGroup2;
 80347f4:	33a4      	adds	r3, #164	; 0xa4
        RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 80347f6:	a918      	add	r1, sp, #96	; 0x60
        params.NvmGroup2 = &Nvm.RegionGroup2;
 80347f8:	9319      	str	r3, [sp, #100]	; 0x64
        RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 80347fa:	f001 ffad 	bl	8036758 <RegionInitDefaults>
        MacCtx.NodeAckRequested = false;
 80347fe:	f884 5418 	strb.w	r5, [r4, #1048]	; 0x418
        MacCtx.McpsConfirm.AckReceived = false;
 8034802:	f884 5440 	strb.w	r5, [r4, #1088]	; 0x440
    MacCtx.McpsConfirm.NbRetries = MacCtx.AckTimeoutRetriesCounter;
 8034806:	f894 3416 	ldrb.w	r3, [r4, #1046]	; 0x416
 803480a:	f884 3441 	strb.w	r3, [r4, #1089]	; 0x441
        if( stopRetransmission == true )
 803480e:	e78e      	b.n	803472e <LoRaMacProcess+0x896>
 8034810:	2a00      	cmp	r2, #0
 8034812:	d0d9      	beq.n	80347c8 <LoRaMacProcess+0x930>
 8034814:	e78b      	b.n	803472e <LoRaMacProcess+0x896>
 8034816:	bf00      	nop
 8034818:	200051cc 	.word	0x200051cc

0803481c <LoRaMacInitialization>:
    return 0;
}


LoRaMacStatus_t LoRaMacInitialization( LoRaMacPrimitives_t* primitives, LoRaMacCallback_t* callbacks, LoRaMacRegion_t region )
{
 803481c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8034820:	4688      	mov	r8, r1
 8034822:	b08a      	sub	sp, #40	; 0x28
 8034824:	4691      	mov	r9, r2
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;

    if( ( primitives == NULL ) ||
 8034826:	4606      	mov	r6, r0
 8034828:	2800      	cmp	r0, #0
 803482a:	f000 8197 	beq.w	8034b5c <LoRaMacInitialization+0x340>
 803482e:	2900      	cmp	r1, #0
 8034830:	f000 8194 	beq.w	8034b5c <LoRaMacInitialization+0x340>
        ( callbacks == NULL ) )
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }

    if( ( primitives->MacMcpsConfirm == NULL ) ||
 8034834:	6803      	ldr	r3, [r0, #0]
 8034836:	2b00      	cmp	r3, #0
 8034838:	f000 8190 	beq.w	8034b5c <LoRaMacInitialization+0x340>
 803483c:	6843      	ldr	r3, [r0, #4]
 803483e:	2b00      	cmp	r3, #0
 8034840:	f000 818c 	beq.w	8034b5c <LoRaMacInitialization+0x340>
        ( primitives->MacMcpsIndication == NULL ) ||
 8034844:	6883      	ldr	r3, [r0, #8]
 8034846:	2b00      	cmp	r3, #0
 8034848:	f000 8188 	beq.w	8034b5c <LoRaMacInitialization+0x340>
        ( primitives->MacMlmeConfirm == NULL ) ||
 803484c:	68c3      	ldr	r3, [r0, #12]
 803484e:	2b00      	cmp	r3, #0
 8034850:	f000 8184 	beq.w	8034b5c <LoRaMacInitialization+0x340>
        ( primitives->MacMlmeIndication == NULL ) )
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }
    // Verify if the region is supported
    if( RegionIsActive( region ) == false )
 8034854:	4610      	mov	r0, r2
 8034856:	f001 ff5b 	bl	8036710 <RegionIsActive>
 803485a:	2800      	cmp	r0, #0
 803485c:	f000 8180 	beq.w	8034b60 <LoRaMacInitialization+0x344>

    // Confirm queue reset
    LoRaMacConfirmQueueInit( primitives );

    // Initialize the module context with zeros
    memset1( ( uint8_t* ) &Nvm, 0x00, sizeof( LoRaMacNvmData_t ) );
 8034860:	4cc1      	ldr	r4, [pc, #772]	; (8034b68 <LoRaMacInitialization+0x34c>)
    LoRaMacConfirmQueueInit( primitives );
 8034862:	4630      	mov	r0, r6
 8034864:	f001 f9e4 	bl	8035c30 <LoRaMacConfirmQueueInit>
    memset1( ( uint8_t* ) &Nvm, 0x00, sizeof( LoRaMacNvmData_t ) );
 8034868:	f240 6254 	movw	r2, #1620	; 0x654
 803486c:	2100      	movs	r1, #0
 803486e:	f204 500c 	addw	r0, r4, #1292	; 0x50c
 8034872:	f004 fb71 	bl	8038f58 <memset1>
    memset1( ( uint8_t* ) &MacCtx, 0x00, sizeof( LoRaMacCtx_t ) );
 8034876:	f44f 62a1 	mov.w	r2, #1288	; 0x508
 803487a:	2100      	movs	r1, #0
 803487c:	1d20      	adds	r0, r4, #4
 803487e:	f004 fb6b 	bl	8038f58 <memset1>
    Nvm.MacGroup2.Region = region;
    Nvm.MacGroup2.DeviceClass = CLASS_A;
    Nvm.MacGroup2.MacParams.RepeaterSupport = false; /* ST_WORKAROUND: Keep repeater feature */

    // Setup version
    Nvm.MacGroup2.Version.Value = LORAMAC_VERSION;
 8034882:	4bba      	ldr	r3, [pc, #744]	; (8034b6c <LoRaMacInitialization+0x350>)
 8034884:	f8c4 3618 	str.w	r3, [r4, #1560]	; 0x618
    Nvm.MacGroup2.DeviceClass = CLASS_A;
 8034888:	2500      	movs	r5, #0
    MacCtx.AckTimeoutRetriesCounter = 1;
 803488a:	2701      	movs	r7, #1

    // Reset to defaults
    getPhy.Attribute = PHY_DUTY_CYCLE;
 803488c:	230f      	movs	r3, #15
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803488e:	a905      	add	r1, sp, #20
 8034890:	4648      	mov	r0, r9
    getPhy.Attribute = PHY_DUTY_CYCLE;
 8034892:	f88d 3014 	strb.w	r3, [sp, #20]
    Nvm.MacGroup2.Region = region;
 8034896:	f884 954c 	strb.w	r9, [r4, #1356]	; 0x54c
    Nvm.MacGroup2.DeviceClass = CLASS_A;
 803489a:	f884 5608 	strb.w	r5, [r4, #1544]	; 0x608
    Nvm.MacGroup2.MacParams.RepeaterSupport = false; /* ST_WORKAROUND: Keep repeater feature */
 803489e:	f884 558c 	strb.w	r5, [r4, #1420]	; 0x58c
    MacCtx.AckTimeoutRetriesCounter = 1;
 80348a2:	f884 7416 	strb.w	r7, [r4, #1046]	; 0x416
    MacCtx.AckTimeoutRetries = 1;
 80348a6:	f884 7415 	strb.w	r7, [r4, #1045]	; 0x415
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348aa:	f001 ff3a 	bl	8036722 <RegionGetPhyParam>
    Nvm.MacGroup2.DutyCycleOn = ( bool ) phyParam.Value;
 80348ae:	1b40      	subs	r0, r0, r5
 80348b0:	bf18      	it	ne
 80348b2:	2001      	movne	r0, #1

    getPhy.Attribute = PHY_DEF_TX_POWER;
 80348b4:	f04f 0a0a 	mov.w	sl, #10
    Nvm.MacGroup2.DutyCycleOn = ( bool ) phyParam.Value;
 80348b8:	f884 060c 	strb.w	r0, [r4, #1548]	; 0x60c
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348bc:	a905      	add	r1, sp, #20
 80348be:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_TX_POWER;
 80348c2:	f88d a014 	strb.w	sl, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348c6:	f001 ff2c 	bl	8036722 <RegionGetPhyParam>
    Nvm.MacGroup2.ChannelsTxPowerDefault = phyParam.Value;

    getPhy.Attribute = PHY_DEF_TX_DR;
 80348ca:	f04f 0906 	mov.w	r9, #6
    Nvm.MacGroup2.ChannelsTxPowerDefault = phyParam.Value;
 80348ce:	f884 05d0 	strb.w	r0, [r4, #1488]	; 0x5d0
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348d2:	a905      	add	r1, sp, #20
 80348d4:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_TX_DR;
 80348d8:	f88d 9014 	strb.w	r9, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348dc:	f001 ff21 	bl	8036722 <RegionGetPhyParam>
    Nvm.MacGroup2.ChannelsDatarateDefault = phyParam.Value;

    getPhy.Attribute = PHY_MAX_RX_WINDOW;
 80348e0:	2310      	movs	r3, #16
    Nvm.MacGroup2.ChannelsDatarateDefault = phyParam.Value;
 80348e2:	f884 05d1 	strb.w	r0, [r4, #1489]	; 0x5d1
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348e6:	a905      	add	r1, sp, #20
 80348e8:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_MAX_RX_WINDOW;
 80348ec:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348f0:	f001 ff17 	bl	8036722 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.MaxRxWindow = phyParam.Value;

    getPhy.Attribute = PHY_RECEIVE_DELAY1;
 80348f4:	2311      	movs	r3, #17
    Nvm.MacGroup2.MacParamsDefaults.MaxRxWindow = phyParam.Value;
 80348f6:	f8c4 0598 	str.w	r0, [r4, #1432]	; 0x598
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348fa:	a905      	add	r1, sp, #20
 80348fc:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_RECEIVE_DELAY1;
 8034900:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034904:	f001 ff0d 	bl	8036722 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay1 = phyParam.Value;

    getPhy.Attribute = PHY_RECEIVE_DELAY2;
 8034908:	2312      	movs	r3, #18
    Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay1 = phyParam.Value;
 803490a:	f8c4 059c 	str.w	r0, [r4, #1436]	; 0x59c
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803490e:	a905      	add	r1, sp, #20
 8034910:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_RECEIVE_DELAY2;
 8034914:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034918:	f001 ff03 	bl	8036722 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay2 = phyParam.Value;

    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY1;
 803491c:	2313      	movs	r3, #19
    Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay2 = phyParam.Value;
 803491e:	f8c4 05a0 	str.w	r0, [r4, #1440]	; 0x5a0
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034922:	a905      	add	r1, sp, #20
 8034924:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY1;
 8034928:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803492c:	f001 fef9 	bl	8036722 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay1 = phyParam.Value;

    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY2;
 8034930:	2314      	movs	r3, #20
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034932:	eb0d 0103 	add.w	r1, sp, r3
    Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay1 = phyParam.Value;
 8034936:	f8c4 05a4 	str.w	r0, [r4, #1444]	; 0x5a4
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803493a:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY2;
 803493e:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034942:	f001 feee 	bl	8036722 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay2 = phyParam.Value;

    getPhy.Attribute = PHY_DEF_DR1_OFFSET;
 8034946:	2317      	movs	r3, #23
    Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay2 = phyParam.Value;
 8034948:	f8c4 05a8 	str.w	r0, [r4, #1448]	; 0x5a8
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803494c:	a905      	add	r1, sp, #20
 803494e:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_DR1_OFFSET;
 8034952:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034956:	f001 fee4 	bl	8036722 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.Rx1DrOffset = phyParam.Value;

    getPhy.Attribute = PHY_DEF_RX2_FREQUENCY;
 803495a:	2318      	movs	r3, #24
    Nvm.MacGroup2.MacParamsDefaults.Rx1DrOffset = phyParam.Value;
 803495c:	f884 05ad 	strb.w	r0, [r4, #1453]	; 0x5ad
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034960:	a905      	add	r1, sp, #20
 8034962:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_RX2_FREQUENCY;
 8034966:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803496a:	f001 feda 	bl	8036722 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.Rx2Channel.Frequency = phyParam.Value;
    Nvm.MacGroup2.MacParamsDefaults.RxCChannel.Frequency = phyParam.Value;

    getPhy.Attribute = PHY_DEF_RX2_DR;
 803496e:	2319      	movs	r3, #25
    Nvm.MacGroup2.MacParamsDefaults.Rx2Channel.Frequency = phyParam.Value;
 8034970:	f8c4 05b0 	str.w	r0, [r4, #1456]	; 0x5b0
    Nvm.MacGroup2.MacParamsDefaults.RxCChannel.Frequency = phyParam.Value;
 8034974:	f8c4 05b8 	str.w	r0, [r4, #1464]	; 0x5b8
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034978:	a905      	add	r1, sp, #20
 803497a:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_RX2_DR;
 803497e:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034982:	f001 fece 	bl	8036722 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.Rx2Channel.Datarate = phyParam.Value;
 8034986:	b2c0      	uxtb	r0, r0
    Nvm.MacGroup2.MacParamsDefaults.RxCChannel.Datarate = phyParam.Value;

    getPhy.Attribute = PHY_DEF_UPLINK_DWELL_TIME;
 8034988:	231e      	movs	r3, #30
    Nvm.MacGroup2.MacParamsDefaults.Rx2Channel.Datarate = phyParam.Value;
 803498a:	f884 05b4 	strb.w	r0, [r4, #1460]	; 0x5b4
    Nvm.MacGroup2.MacParamsDefaults.RxCChannel.Datarate = phyParam.Value;
 803498e:	f884 05bc 	strb.w	r0, [r4, #1468]	; 0x5bc
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034992:	a905      	add	r1, sp, #20
 8034994:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_UPLINK_DWELL_TIME;
 8034998:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803499c:	f001 fec1 	bl	8036722 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.UplinkDwellTime = phyParam.Value;

    getPhy.Attribute = PHY_DEF_DOWNLINK_DWELL_TIME;
 80349a0:	231f      	movs	r3, #31
    Nvm.MacGroup2.MacParamsDefaults.UplinkDwellTime = phyParam.Value;
 80349a2:	f884 05c0 	strb.w	r0, [r4, #1472]	; 0x5c0
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80349a6:	a905      	add	r1, sp, #20
 80349a8:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_DOWNLINK_DWELL_TIME;
 80349ac:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80349b0:	f001 feb7 	bl	8036722 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.DownlinkDwellTime = phyParam.Value;

    getPhy.Attribute = PHY_DEF_MAX_EIRP;
 80349b4:	2320      	movs	r3, #32
    Nvm.MacGroup2.MacParamsDefaults.DownlinkDwellTime = phyParam.Value;
 80349b6:	f884 05c1 	strb.w	r0, [r4, #1473]	; 0x5c1
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80349ba:	a905      	add	r1, sp, #20
 80349bc:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_MAX_EIRP;
 80349c0:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80349c4:	f001 fead 	bl	8036722 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.MaxEirp = phyParam.fValue;

    getPhy.Attribute = PHY_DEF_ANTENNA_GAIN;
 80349c8:	2321      	movs	r3, #33	; 0x21
    Nvm.MacGroup2.MacParamsDefaults.MaxEirp = phyParam.fValue;
 80349ca:	f8c4 05c4 	str.w	r0, [r4, #1476]	; 0x5c4
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80349ce:	a905      	add	r1, sp, #20
 80349d0:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_ANTENNA_GAIN;
 80349d4:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80349d8:	f001 fea3 	bl	8036722 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.AntennaGain = phyParam.fValue;

    getPhy.Attribute = PHY_DEF_ADR_ACK_LIMIT;
 80349dc:	230b      	movs	r3, #11
    Nvm.MacGroup2.MacParamsDefaults.AntennaGain = phyParam.fValue;
 80349de:	f8c4 05c8 	str.w	r0, [r4, #1480]	; 0x5c8
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80349e2:	a905      	add	r1, sp, #20
 80349e4:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_ADR_ACK_LIMIT;
 80349e8:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80349ec:	f001 fe99 	bl	8036722 <RegionGetPhyParam>
    MacCtx.AdrAckLimit = phyParam.Value;

    getPhy.Attribute = PHY_DEF_ADR_ACK_DELAY;
 80349f0:	230c      	movs	r3, #12
    MacCtx.AdrAckLimit = phyParam.Value;
 80349f2:	f8a4 03f8 	strh.w	r0, [r4, #1016]	; 0x3f8
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80349f6:	a905      	add	r1, sp, #20
 80349f8:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_ADR_ACK_DELAY;
 80349fc:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034a00:	f001 fe8f 	bl	8036722 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError = 10;
    Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols = 6;

    Nvm.MacGroup2.MacParams.SystemMaxRxError = Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError;
    Nvm.MacGroup2.MacParams.MinRxSymbols = Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols;
    Nvm.MacGroup2.MacParams.MaxRxWindow = Nvm.MacGroup2.MacParamsDefaults.MaxRxWindow;
 8034a04:	f8d4 3598 	ldr.w	r3, [r4, #1432]	; 0x598
 8034a08:	f8c4 3558 	str.w	r3, [r4, #1368]	; 0x558
    Nvm.MacGroup2.MacParams.ReceiveDelay1 = Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay1;
 8034a0c:	f8d4 359c 	ldr.w	r3, [r4, #1436]	; 0x59c
 8034a10:	f8c4 355c 	str.w	r3, [r4, #1372]	; 0x55c
    Nvm.MacGroup2.MacParams.ReceiveDelay2 = Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay2;
 8034a14:	f8d4 35a0 	ldr.w	r3, [r4, #1440]	; 0x5a0
 8034a18:	f8c4 3560 	str.w	r3, [r4, #1376]	; 0x560
    Nvm.MacGroup2.MacParams.JoinAcceptDelay1 = Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay1;
 8034a1c:	f8d4 35a4 	ldr.w	r3, [r4, #1444]	; 0x5a4
 8034a20:	f8c4 3564 	str.w	r3, [r4, #1380]	; 0x564
    Nvm.MacGroup2.MacParams.JoinAcceptDelay2 = Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay2;
 8034a24:	f8d4 35a8 	ldr.w	r3, [r4, #1448]	; 0x5a8
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034a28:	9004      	str	r0, [sp, #16]

    InitDefaultsParams_t params;
    params.Type = INIT_TYPE_DEFAULTS;
    params.NvmGroup1 = &Nvm.RegionGroup1;
    params.NvmGroup2 = &Nvm.RegionGroup2;
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 8034a2a:	a907      	add	r1, sp, #28
    MacCtx.AdrAckDelay = phyParam.Value;
 8034a2c:	f8a4 03fa 	strh.w	r0, [r4, #1018]	; 0x3fa
    Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols = 6;
 8034a30:	f884 9594 	strb.w	r9, [r4, #1428]	; 0x594
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 8034a34:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    Nvm.MacGroup2.MacParams.MinRxSymbols = Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols;
 8034a38:	f884 9554 	strb.w	r9, [r4, #1364]	; 0x554
    Nvm.MacGroup2.MacParams.JoinAcceptDelay2 = Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay2;
 8034a3c:	f8c4 3568 	str.w	r3, [r4, #1384]	; 0x568
    params.NvmGroup1 = &Nvm.RegionGroup1;
 8034a40:	f504 69e5 	add.w	r9, r4, #1832	; 0x728
    params.NvmGroup2 = &Nvm.RegionGroup2;
 8034a44:	f204 73cc 	addw	r3, r4, #1996	; 0x7cc
 8034a48:	9308      	str	r3, [sp, #32]
    params.Type = INIT_TYPE_DEFAULTS;
 8034a4a:	f88d 5024 	strb.w	r5, [sp, #36]	; 0x24
    Nvm.MacGroup2.MacParamsDefaults.ChannelsNbTrans = 1;
 8034a4e:	f884 75ac 	strb.w	r7, [r4, #1452]	; 0x5ac
    Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError = 10;
 8034a52:	f8c4 a590 	str.w	sl, [r4, #1424]	; 0x590
    Nvm.MacGroup2.MacParams.SystemMaxRxError = Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError;
 8034a56:	f8c4 a550 	str.w	sl, [r4, #1360]	; 0x550
    Nvm.MacGroup2.MacParams.ChannelsNbTrans = Nvm.MacGroup2.MacParamsDefaults.ChannelsNbTrans;
 8034a5a:	f884 756c 	strb.w	r7, [r4, #1388]	; 0x56c
    params.NvmGroup1 = &Nvm.RegionGroup1;
 8034a5e:	f8cd 901c 	str.w	r9, [sp, #28]
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 8034a62:	f001 fe79 	bl	8036758 <RegionInitDefaults>

    MacCtx.MacCallbacks = callbacks;
 8034a66:	f8c4 834c 	str.w	r8, [r4, #844]	; 0x34c
    ResetMacParameters( );
 8034a6a:	f7fe fc1b 	bl	80332a4 <ResetMacParameters>
    // Reset duty cycle times
    Nvm.MacGroup1.LastTxDoneTime = 0;
    Nvm.MacGroup1.AggregatedTimeOff = 0;

    // Initialize timers
    TimerInit( &MacCtx.TxDelayedTimer, OnTxDelayedTimerEvent );
 8034a6e:	462a      	mov	r2, r5
 8034a70:	4b3f      	ldr	r3, [pc, #252]	; (8034b70 <LoRaMacInitialization+0x354>)
 8034a72:	9500      	str	r5, [sp, #0]
 8034a74:	f04f 31ff 	mov.w	r1, #4294967295
 8034a78:	f504 705b 	add.w	r0, r4, #876	; 0x36c
    MacCtx.MacPrimitives = primitives;
 8034a7c:	f8c4 6348 	str.w	r6, [r4, #840]	; 0x348
    MacCtx.MacFlags.Value = 0;
 8034a80:	f884 5485 	strb.w	r5, [r4, #1157]	; 0x485
    Nvm.MacGroup1.LastTxDoneTime = 0;
 8034a84:	f8c4 5538 	str.w	r5, [r4, #1336]	; 0x538
    Nvm.MacGroup1.AggregatedTimeOff = 0;
 8034a88:	f8c4 553c 	str.w	r5, [r4, #1340]	; 0x53c
    Nvm.MacGroup2.PublicNetwork = true;
 8034a8c:	f884 7609 	strb.w	r7, [r4, #1545]	; 0x609
    MacCtx.MacState = LORAMAC_STOPPED;
 8034a90:	f8c4 7344 	str.w	r7, [r4, #836]	; 0x344
    TimerInit( &MacCtx.TxDelayedTimer, OnTxDelayedTimerEvent );
 8034a94:	f006 fbf6 	bl	803b284 <UTIL_TIMER_Create>
    TimerInit( &MacCtx.RxWindowTimer1, OnRxWindow1TimerEvent );
 8034a98:	462a      	mov	r2, r5
 8034a9a:	4b36      	ldr	r3, [pc, #216]	; (8034b74 <LoRaMacInitialization+0x358>)
 8034a9c:	9500      	str	r5, [sp, #0]
 8034a9e:	f04f 31ff 	mov.w	r1, #4294967295
 8034aa2:	f504 7061 	add.w	r0, r4, #900	; 0x384
 8034aa6:	f006 fbed 	bl	803b284 <UTIL_TIMER_Create>
    TimerInit( &MacCtx.RxWindowTimer2, OnRxWindow2TimerEvent );
 8034aaa:	462a      	mov	r2, r5
 8034aac:	4b32      	ldr	r3, [pc, #200]	; (8034b78 <LoRaMacInitialization+0x35c>)
 8034aae:	9500      	str	r5, [sp, #0]
 8034ab0:	f04f 31ff 	mov.w	r1, #4294967295
 8034ab4:	f504 7067 	add.w	r0, r4, #924	; 0x39c
 8034ab8:	f006 fbe4 	bl	803b284 <UTIL_TIMER_Create>
    TimerInit( &MacCtx.AckTimeoutTimer, OnAckTimeoutTimerEvent );
 8034abc:	462a      	mov	r2, r5
 8034abe:	4b2f      	ldr	r3, [pc, #188]	; (8034b7c <LoRaMacInitialization+0x360>)
 8034ac0:	9500      	str	r5, [sp, #0]
 8034ac2:	f04f 31ff 	mov.w	r1, #4294967295

    // Store the current initialization time
    Nvm.MacGroup2.InitializationTime = SysTimeGetMcuTime( );
 8034ac6:	ad02      	add	r5, sp, #8
    TimerInit( &MacCtx.AckTimeoutTimer, OnAckTimeoutTimerEvent );
 8034ac8:	f504 707f 	add.w	r0, r4, #1020	; 0x3fc
 8034acc:	f006 fbda 	bl	803b284 <UTIL_TIMER_Create>
    Nvm.MacGroup2.InitializationTime = SysTimeGetMcuTime( );
 8034ad0:	4628      	mov	r0, r5
 8034ad2:	f006 fb6d 	bl	803b1b0 <SysTimeGetMcuTime>
 8034ad6:	e895 0003 	ldmia.w	r5, {r0, r1}
 8034ada:	f504 63c2 	add.w	r3, r4, #1552	; 0x610
 8034ade:	e883 0003 	stmia.w	r3, {r0, r1}

    // Initialize Radio driver
    MacCtx.RadioEvents.TxDone = OnRadioTxDone;
 8034ae2:	4b27      	ldr	r3, [pc, #156]	; (8034b80 <LoRaMacInitialization+0x364>)
 8034ae4:	f8c4 3350 	str.w	r3, [r4, #848]	; 0x350
    MacCtx.RadioEvents.RxDone = OnRadioRxDone;
 8034ae8:	4b26      	ldr	r3, [pc, #152]	; (8034b84 <LoRaMacInitialization+0x368>)
 8034aea:	f8c4 3358 	str.w	r3, [r4, #856]	; 0x358
    MacCtx.RadioEvents.RxError = OnRadioRxError;
 8034aee:	4b26      	ldr	r3, [pc, #152]	; (8034b88 <LoRaMacInitialization+0x36c>)
 8034af0:	f8c4 3360 	str.w	r3, [r4, #864]	; 0x360
    MacCtx.RadioEvents.TxTimeout = OnRadioTxTimeout;
    MacCtx.RadioEvents.RxTimeout = OnRadioRxTimeout;
    Radio.Init( &MacCtx.RadioEvents );
 8034af4:	4e25      	ldr	r6, [pc, #148]	; (8034b8c <LoRaMacInitialization+0x370>)
    MacCtx.RadioEvents.TxTimeout = OnRadioTxTimeout;
 8034af6:	4b26      	ldr	r3, [pc, #152]	; (8034b90 <LoRaMacInitialization+0x374>)
 8034af8:	f8c4 3354 	str.w	r3, [r4, #852]	; 0x354
    MacCtx.RadioEvents.RxTimeout = OnRadioRxTimeout;
 8034afc:	4b25      	ldr	r3, [pc, #148]	; (8034b94 <LoRaMacInitialization+0x378>)
 8034afe:	f8c4 335c 	str.w	r3, [r4, #860]	; 0x35c
    Radio.Init( &MacCtx.RadioEvents );
 8034b02:	f504 7054 	add.w	r0, r4, #848	; 0x350
 8034b06:	6833      	ldr	r3, [r6, #0]
 8034b08:	4798      	blx	r3

    // Initialize the Secure Element driver
    if( SecureElementInit( &Nvm.SecureElement, callbacks->GetUniqueId ) != SECURE_ELEMENT_SUCCESS ) /* ST_WORKAROUND: Add unique ID callback as input parameter */
 8034b0a:	f8d8 1008 	ldr.w	r1, [r8, #8]
 8034b0e:	f204 6024 	addw	r0, r4, #1572	; 0x624
 8034b12:	f003 feeb 	bl	80388ec <SecureElementInit>
 8034b16:	b120      	cbz	r0, 8034b22 <LoRaMacInitialization+0x306>
    {
        return LORAMAC_STATUS_CRYPTO_ERROR;
 8034b18:	2511      	movs	r5, #17
    Radio.Sleep( );

    LoRaMacEnableRequests( LORAMAC_REQUEST_HANDLING_ON );

    return LORAMAC_STATUS_OK;
}
 8034b1a:	4628      	mov	r0, r5
 8034b1c:	b00a      	add	sp, #40	; 0x28
 8034b1e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if( LoRaMacCryptoInit( &Nvm.Crypto ) != LORAMAC_CRYPTO_SUCCESS )
 8034b22:	f5a9 7007 	sub.w	r0, r9, #540	; 0x21c
 8034b26:	f001 fa49 	bl	8035fbc <LoRaMacCryptoInit>
 8034b2a:	2800      	cmp	r0, #0
 8034b2c:	d1f4      	bne.n	8034b18 <LoRaMacInitialization+0x2fc>
    if( LoRaMacCommandsInit( ) != LORAMAC_COMMANDS_SUCCESS )
 8034b2e:	f000 ff5d 	bl	80359ec <LoRaMacCommandsInit>
 8034b32:	b9b8      	cbnz	r0, 8034b64 <LoRaMacInitialization+0x348>
    if( LoRaMacCryptoSetMulticastReference( Nvm.MacGroup2.MulticastChannelList ) != LORAMAC_CRYPTO_SUCCESS )
 8034b34:	4818      	ldr	r0, [pc, #96]	; (8034b98 <LoRaMacInitialization+0x37c>)
 8034b36:	f001 faa7 	bl	8036088 <LoRaMacCryptoSetMulticastReference>
 8034b3a:	4605      	mov	r5, r0
 8034b3c:	2800      	cmp	r0, #0
 8034b3e:	d1eb      	bne.n	8034b18 <LoRaMacInitialization+0x2fc>
    srand1( Radio.Random( ) );
 8034b40:	6973      	ldr	r3, [r6, #20]
 8034b42:	4798      	blx	r3
 8034b44:	f004 f9d2 	bl	8038eec <srand1>
    Radio.SetPublicNetwork( Nvm.MacGroup2.PublicNetwork );
 8034b48:	6db3      	ldr	r3, [r6, #88]	; 0x58
 8034b4a:	f894 0609 	ldrb.w	r0, [r4, #1545]	; 0x609
 8034b4e:	4798      	blx	r3
    Radio.Sleep( );
 8034b50:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8034b52:	4798      	blx	r3
    MacCtx.AllowRequests = requestState;
 8034b54:	2301      	movs	r3, #1
 8034b56:	f884 3486 	strb.w	r3, [r4, #1158]	; 0x486
    return LORAMAC_STATUS_OK;
 8034b5a:	e7de      	b.n	8034b1a <LoRaMacInitialization+0x2fe>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 8034b5c:	2503      	movs	r5, #3
 8034b5e:	e7dc      	b.n	8034b1a <LoRaMacInitialization+0x2fe>
        return LORAMAC_STATUS_REGION_NOT_SUPPORTED;
 8034b60:	2509      	movs	r5, #9
 8034b62:	e7da      	b.n	8034b1a <LoRaMacInitialization+0x2fe>
        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 8034b64:	2513      	movs	r5, #19
 8034b66:	e7d8      	b.n	8034b1a <LoRaMacInitialization+0x2fe>
 8034b68:	20004aa4 	.word	0x20004aa4
 8034b6c:	01000300 	.word	0x01000300
 8034b70:	080336c1 	.word	0x080336c1
 8034b74:	08033861 	.word	0x08033861
 8034b78:	08033899 	.word	0x08033899
 8034b7c:	08033061 	.word	0x08033061
 8034b80:	08033251 	.word	0x08033251
 8034b84:	08033201 	.word	0x08033201
 8034b88:	08032fb1 	.word	0x08032fb1
 8034b8c:	0803bc30 	.word	0x0803bc30
 8034b90:	080331d1 	.word	0x080331d1
 8034b94:	080331a1 	.word	0x080331a1
 8034b98:	20005080 	.word	0x20005080

08034b9c <LoRaMacStart>:

LoRaMacStatus_t LoRaMacStart( void )
{
    MacCtx.MacState = LORAMAC_IDLE;
 8034b9c:	4b02      	ldr	r3, [pc, #8]	; (8034ba8 <LoRaMacStart+0xc>)
 8034b9e:	2000      	movs	r0, #0
 8034ba0:	f8c3 0344 	str.w	r0, [r3, #836]	; 0x344
    return LORAMAC_STATUS_OK;
}
 8034ba4:	4770      	bx	lr
 8034ba6:	bf00      	nop
 8034ba8:	20004aa4 	.word	0x20004aa4

08034bac <LoRaMacQueryTxPossible>:
    }
    return LORAMAC_STATUS_BUSY;
}

LoRaMacStatus_t LoRaMacQueryTxPossible( uint8_t size, LoRaMacTxInfo_t* txInfo )
{
 8034bac:	b530      	push	{r4, r5, lr}
    CalcNextAdrParams_t adrNext;
    uint32_t adrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 8034bae:	4b2a      	ldr	r3, [pc, #168]	; (8034c58 <LoRaMacQueryTxPossible+0xac>)
{
 8034bb0:	b089      	sub	sp, #36	; 0x24
 8034bb2:	4605      	mov	r5, r0
    int8_t datarate = Nvm.MacGroup2.ChannelsDatarateDefault;
 8034bb4:	f893 05d1 	ldrb.w	r0, [r3, #1489]	; 0x5d1
 8034bb8:	f88d 0002 	strb.w	r0, [sp, #2]
    int8_t txPower = Nvm.MacGroup2.ChannelsTxPowerDefault;
 8034bbc:	f893 05d0 	ldrb.w	r0, [r3, #1488]	; 0x5d0
    uint32_t adrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 8034bc0:	f8d3 2534 	ldr.w	r2, [r3, #1332]	; 0x534
    int8_t txPower = Nvm.MacGroup2.ChannelsTxPowerDefault;
 8034bc4:	f88d 0003 	strb.w	r0, [sp, #3]
    size_t macCmdsSize = 0;
 8034bc8:	2000      	movs	r0, #0
    uint32_t adrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 8034bca:	9201      	str	r2, [sp, #4]
    size_t macCmdsSize = 0;
 8034bcc:	9002      	str	r0, [sp, #8]

    if( txInfo == NULL )
 8034bce:	460c      	mov	r4, r1
 8034bd0:	2900      	cmp	r1, #0
 8034bd2:	d03c      	beq.n	8034c4e <LoRaMacQueryTxPossible+0xa2>

    // Setup ADR request
    adrNext.Version = Nvm.MacGroup2.Version;
    adrNext.UpdateChanMask = false;
    adrNext.AdrEnabled = Nvm.MacGroup2.AdrCtrlOn;
    adrNext.AdrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 8034bd4:	9205      	str	r2, [sp, #20]
    adrNext.AdrAckLimit = MacCtx.AdrAckLimit;
 8034bd6:	f8d3 23f8 	ldr.w	r2, [r3, #1016]	; 0x3f8
 8034bda:	9206      	str	r2, [sp, #24]
    adrNext.AdrAckDelay = MacCtx.AdrAckDelay;
    adrNext.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 8034bdc:	f8b3 2544 	ldrh.w	r2, [r3, #1348]	; 0x544
    adrNext.Version = Nvm.MacGroup2.Version;
 8034be0:	f8d3 1618 	ldr.w	r1, [r3, #1560]	; 0x618
 8034be4:	9103      	str	r1, [sp, #12]
    adrNext.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 8034be6:	ba52      	rev16	r2, r2
    adrNext.AdrEnabled = Nvm.MacGroup2.AdrCtrlOn;
 8034be8:	f893 160a 	ldrb.w	r1, [r3, #1546]	; 0x60a
    adrNext.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 8034bec:	f8ad 201c 	strh.w	r2, [sp, #28]
    adrNext.TxPower = Nvm.MacGroup1.ChannelsTxPower;
    adrNext.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8034bf0:	f893 2580 	ldrb.w	r2, [r3, #1408]	; 0x580
    adrNext.Region = Nvm.MacGroup2.Region;
 8034bf4:	f893 354c 	ldrb.w	r3, [r3, #1356]	; 0x54c
    adrNext.UpdateChanMask = false;
 8034bf8:	f88d 0010 	strb.w	r0, [sp, #16]
    adrNext.AdrEnabled = Nvm.MacGroup2.AdrCtrlOn;
 8034bfc:	f88d 1011 	strb.w	r1, [sp, #17]
    adrNext.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8034c00:	f88d 201e 	strb.w	r2, [sp, #30]
    adrNext.Region = Nvm.MacGroup2.Region;
 8034c04:	f88d 301f 	strb.w	r3, [sp, #31]

    // We call the function for information purposes only. We don't want to
    // apply the datarate, the tx power and the ADR ack counter.
    LoRaMacAdrCalcNext( &adrNext, &datarate, &txPower, &adrAckCounter );
 8034c08:	f10d 0203 	add.w	r2, sp, #3
 8034c0c:	ab01      	add	r3, sp, #4
 8034c0e:	f10d 0102 	add.w	r1, sp, #2
 8034c12:	a803      	add	r0, sp, #12
 8034c14:	f000 fe54 	bl	80358c0 <LoRaMacAdrCalcNext>

    txInfo->CurrentPossiblePayloadSize = GetMaxAppPayloadWithoutFOptsLength( datarate );
 8034c18:	f99d 0002 	ldrsb.w	r0, [sp, #2]
 8034c1c:	f7fe fa04 	bl	8033028 <GetMaxAppPayloadWithoutFOptsLength>
 8034c20:	7060      	strb	r0, [r4, #1]

    if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )
 8034c22:	a802      	add	r0, sp, #8
 8034c24:	f000 ff8a 	bl	8035b3c <LoRaMacCommandsGetSizeSerializedCmds>
 8034c28:	b998      	cbnz	r0, 8034c52 <LoRaMacQueryTxPossible+0xa6>
    {
        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
    }

    // Verify if the MAC commands fit into the FOpts and into the maximum payload.
    if( ( LORA_MAC_COMMAND_MAX_FOPTS_LENGTH >= macCmdsSize ) && ( txInfo->CurrentPossiblePayloadSize >= macCmdsSize ) )
 8034c2a:	9b02      	ldr	r3, [sp, #8]
 8034c2c:	2b0f      	cmp	r3, #15
 8034c2e:	d80a      	bhi.n	8034c46 <LoRaMacQueryTxPossible+0x9a>
 8034c30:	7862      	ldrb	r2, [r4, #1]
 8034c32:	4293      	cmp	r3, r2
 8034c34:	d807      	bhi.n	8034c46 <LoRaMacQueryTxPossible+0x9a>
    {
        txInfo->MaxPossibleApplicationDataSize = txInfo->CurrentPossiblePayloadSize - macCmdsSize;
 8034c36:	1ad1      	subs	r1, r2, r3

        // Verify if the application data together with MAC command fit into the maximum payload.
        if( txInfo->CurrentPossiblePayloadSize >= ( macCmdsSize + size ) )
 8034c38:	441d      	add	r5, r3
        txInfo->MaxPossibleApplicationDataSize = txInfo->CurrentPossiblePayloadSize - macCmdsSize;
 8034c3a:	7021      	strb	r1, [r4, #0]
        {
            return LORAMAC_STATUS_OK;
        }
        else
        {
           return LORAMAC_STATUS_LENGTH_ERROR;
 8034c3c:	42aa      	cmp	r2, r5
 8034c3e:	bf38      	it	cc
 8034c40:	2008      	movcc	r0, #8
    else
    {
        txInfo->MaxPossibleApplicationDataSize = 0;
        return LORAMAC_STATUS_LENGTH_ERROR;
    }
}
 8034c42:	b009      	add	sp, #36	; 0x24
 8034c44:	bd30      	pop	{r4, r5, pc}
        txInfo->MaxPossibleApplicationDataSize = 0;
 8034c46:	2300      	movs	r3, #0
 8034c48:	7023      	strb	r3, [r4, #0]
        return LORAMAC_STATUS_LENGTH_ERROR;
 8034c4a:	2008      	movs	r0, #8
 8034c4c:	e7f9      	b.n	8034c42 <LoRaMacQueryTxPossible+0x96>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 8034c4e:	2003      	movs	r0, #3
 8034c50:	e7f7      	b.n	8034c42 <LoRaMacQueryTxPossible+0x96>
        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 8034c52:	2013      	movs	r0, #19
 8034c54:	e7f5      	b.n	8034c42 <LoRaMacQueryTxPossible+0x96>
 8034c56:	bf00      	nop
 8034c58:	20004aa4 	.word	0x20004aa4

08034c5c <LoRaMacMibGetRequestConfirm>:

LoRaMacStatus_t LoRaMacMibGetRequestConfirm( MibRequestConfirm_t* mibGet )
{
 8034c5c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;

    if( mibGet == NULL )
 8034c5e:	4604      	mov	r4, r0
 8034c60:	2800      	cmp	r0, #0
 8034c62:	f000 80a8 	beq.w	8034db6 <LoRaMacMibGetRequestConfirm+0x15a>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }

    switch( mibGet->Type )
 8034c66:	7800      	ldrb	r0, [r0, #0]
 8034c68:	2828      	cmp	r0, #40	; 0x28
 8034c6a:	f200 80a0 	bhi.w	8034dae <LoRaMacMibGetRequestConfirm+0x152>
 8034c6e:	e8df f000 	tbb	[pc, r0]
 8034c72:	1b15      	.short	0x1b15
 8034c74:	2c282520 	.word	0x2c282520
 8034c78:	9e9e9e31 	.word	0x9e9e9e31
 8034c7c:	9e9e9e9e 	.word	0x9e9e9e9e
 8034c80:	3d39359e 	.word	0x3d39359e
 8034c84:	54514e47 	.word	0x54514e47
 8034c88:	5f5b5759 	.word	0x5f5b5759
 8034c8c:	6f6b6763 	.word	0x6f6b6763
 8034c90:	7b7f7773 	.word	0x7b7f7773
 8034c94:	928b8783 	.word	0x928b8783
 8034c98:	9e90      	.short	0x9e90
 8034c9a:	96          	.byte	0x96
 8034c9b:	00          	.byte	0x00
    {
        case MIB_DEVICE_CLASS:
        {
            mibGet->Param.Class = Nvm.MacGroup2.DeviceClass;
 8034c9c:	4b47      	ldr	r3, [pc, #284]	; (8034dbc <LoRaMacMibGetRequestConfirm+0x160>)
 8034c9e:	f893 3608 	ldrb.w	r3, [r3, #1544]	; 0x608
 8034ca2:	7123      	strb	r3, [r4, #4]
            status = LoRaMacClassBMibGetRequestConfirm( mibGet );
            break;
        }
    }
    return status;
}
 8034ca4:	b004      	add	sp, #16
 8034ca6:	bd10      	pop	{r4, pc}
            mibGet->Param.NetworkActivation = Nvm.MacGroup2.NetworkActivation;
 8034ca8:	4b44      	ldr	r3, [pc, #272]	; (8034dbc <LoRaMacMibGetRequestConfirm+0x160>)
 8034caa:	f893 361c 	ldrb.w	r3, [r3, #1564]	; 0x61c
            mibGet->Param.AdrEnable = Nvm.MacGroup2.AdrCtrlOn;
 8034cae:	7123      	strb	r3, [r4, #4]
            break;
 8034cb0:	e002      	b.n	8034cb8 <LoRaMacMibGetRequestConfirm+0x5c>
            mibGet->Param.DevEui = SecureElementGetDevEui( );
 8034cb2:	f004 f8ff 	bl	8038eb4 <SecureElementGetDevEui>
            mibGet->Param.JoinEui = SecureElementGetJoinEui( );
 8034cb6:	6060      	str	r0, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 8034cb8:	2000      	movs	r0, #0
            break;
 8034cba:	e7f3      	b.n	8034ca4 <LoRaMacMibGetRequestConfirm+0x48>
            mibGet->Param.JoinEui = SecureElementGetJoinEui( );
 8034cbc:	f004 f910 	bl	8038ee0 <SecureElementGetJoinEui>
 8034cc0:	e7f9      	b.n	8034cb6 <LoRaMacMibGetRequestConfirm+0x5a>
            mibGet->Param.AdrEnable = Nvm.MacGroup2.AdrCtrlOn;
 8034cc2:	4b3e      	ldr	r3, [pc, #248]	; (8034dbc <LoRaMacMibGetRequestConfirm+0x160>)
 8034cc4:	f893 360a 	ldrb.w	r3, [r3, #1546]	; 0x60a
 8034cc8:	e7f1      	b.n	8034cae <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.NetID = Nvm.MacGroup2.NetID;
 8034cca:	4b3c      	ldr	r3, [pc, #240]	; (8034dbc <LoRaMacMibGetRequestConfirm+0x160>)
 8034ccc:	f8d3 35d4 	ldr.w	r3, [r3, #1492]	; 0x5d4
            mibGet->Param.Contexts = GetNvmData( );
 8034cd0:	6063      	str	r3, [r4, #4]
            break;
 8034cd2:	e7f1      	b.n	8034cb8 <LoRaMacMibGetRequestConfirm+0x5c>
            mibGet->Param.DevAddr = Nvm.MacGroup2.DevAddr;
 8034cd4:	4b39      	ldr	r3, [pc, #228]	; (8034dbc <LoRaMacMibGetRequestConfirm+0x160>)
 8034cd6:	f8d3 35d8 	ldr.w	r3, [r3, #1496]	; 0x5d8
 8034cda:	e7f9      	b.n	8034cd0 <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.EnablePublicNetwork = Nvm.MacGroup2.PublicNetwork;
 8034cdc:	4b37      	ldr	r3, [pc, #220]	; (8034dbc <LoRaMacMibGetRequestConfirm+0x160>)
 8034cde:	f893 3609 	ldrb.w	r3, [r3, #1545]	; 0x609
 8034ce2:	e7e4      	b.n	8034cae <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.EnableRepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport;
 8034ce4:	4b35      	ldr	r3, [pc, #212]	; (8034dbc <LoRaMacMibGetRequestConfirm+0x160>)
 8034ce6:	f893 358c 	ldrb.w	r3, [r3, #1420]	; 0x58c
 8034cea:	e7e0      	b.n	8034cae <LoRaMacMibGetRequestConfirm+0x52>
            getPhy.Attribute = PHY_CHANNELS;
 8034cec:	231d      	movs	r3, #29
            getPhy.Attribute = PHY_CHANNELS_MASK;
 8034cee:	f88d 3008 	strb.w	r3, [sp, #8]
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034cf2:	4b32      	ldr	r3, [pc, #200]	; (8034dbc <LoRaMacMibGetRequestConfirm+0x160>)
 8034cf4:	a902      	add	r1, sp, #8
 8034cf6:	f893 054c 	ldrb.w	r0, [r3, #1356]	; 0x54c
 8034cfa:	f001 fd12 	bl	8036722 <RegionGetPhyParam>
 8034cfe:	e7da      	b.n	8034cb6 <LoRaMacMibGetRequestConfirm+0x5a>
            mibGet->Param.Rx2Channel = Nvm.MacGroup2.MacParams.Rx2Channel;
 8034d00:	4b2f      	ldr	r3, [pc, #188]	; (8034dc0 <LoRaMacMibGetRequestConfirm+0x164>)
 8034d02:	3404      	adds	r4, #4
            mibGet->Param.RxCChannel = Nvm.MacGroup2.MacParamsDefaults.RxCChannel;
 8034d04:	e893 0003 	ldmia.w	r3, {r0, r1}
 8034d08:	e884 0003 	stmia.w	r4, {r0, r1}
            break;
 8034d0c:	e7d4      	b.n	8034cb8 <LoRaMacMibGetRequestConfirm+0x5c>
            mibGet->Param.Rx2Channel = Nvm.MacGroup2.MacParamsDefaults.Rx2Channel;
 8034d0e:	4b2d      	ldr	r3, [pc, #180]	; (8034dc4 <LoRaMacMibGetRequestConfirm+0x168>)
 8034d10:	3404      	adds	r4, #4
 8034d12:	e7f7      	b.n	8034d04 <LoRaMacMibGetRequestConfirm+0xa8>
            mibGet->Param.RxCChannel = Nvm.MacGroup2.MacParams.RxCChannel;
 8034d14:	4b2c      	ldr	r3, [pc, #176]	; (8034dc8 <LoRaMacMibGetRequestConfirm+0x16c>)
 8034d16:	3404      	adds	r4, #4
 8034d18:	e7f4      	b.n	8034d04 <LoRaMacMibGetRequestConfirm+0xa8>
            mibGet->Param.RxCChannel = Nvm.MacGroup2.MacParamsDefaults.RxCChannel;
 8034d1a:	4b2c      	ldr	r3, [pc, #176]	; (8034dcc <LoRaMacMibGetRequestConfirm+0x170>)
 8034d1c:	3404      	adds	r4, #4
 8034d1e:	e7f1      	b.n	8034d04 <LoRaMacMibGetRequestConfirm+0xa8>
            getPhy.Attribute = PHY_CHANNELS_DEFAULT_MASK;
 8034d20:	231b      	movs	r3, #27
 8034d22:	e7e4      	b.n	8034cee <LoRaMacMibGetRequestConfirm+0x92>
            getPhy.Attribute = PHY_CHANNELS_MASK;
 8034d24:	231a      	movs	r3, #26
 8034d26:	e7e2      	b.n	8034cee <LoRaMacMibGetRequestConfirm+0x92>
            mibGet->Param.ChannelsNbTrans = Nvm.MacGroup2.MacParams.ChannelsNbTrans;
 8034d28:	4b24      	ldr	r3, [pc, #144]	; (8034dbc <LoRaMacMibGetRequestConfirm+0x160>)
 8034d2a:	f893 356c 	ldrb.w	r3, [r3, #1388]	; 0x56c
 8034d2e:	e7be      	b.n	8034cae <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.MaxRxWindow = Nvm.MacGroup2.MacParams.MaxRxWindow;
 8034d30:	4b22      	ldr	r3, [pc, #136]	; (8034dbc <LoRaMacMibGetRequestConfirm+0x160>)
 8034d32:	f8d3 3558 	ldr.w	r3, [r3, #1368]	; 0x558
 8034d36:	e7cb      	b.n	8034cd0 <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.ReceiveDelay1 = Nvm.MacGroup2.MacParams.ReceiveDelay1;
 8034d38:	4b20      	ldr	r3, [pc, #128]	; (8034dbc <LoRaMacMibGetRequestConfirm+0x160>)
 8034d3a:	f8d3 355c 	ldr.w	r3, [r3, #1372]	; 0x55c
 8034d3e:	e7c7      	b.n	8034cd0 <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay2;
 8034d40:	4b1e      	ldr	r3, [pc, #120]	; (8034dbc <LoRaMacMibGetRequestConfirm+0x160>)
 8034d42:	f8d3 3560 	ldr.w	r3, [r3, #1376]	; 0x560
 8034d46:	e7c3      	b.n	8034cd0 <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.JoinAcceptDelay1 = Nvm.MacGroup2.MacParams.JoinAcceptDelay1;
 8034d48:	4b1c      	ldr	r3, [pc, #112]	; (8034dbc <LoRaMacMibGetRequestConfirm+0x160>)
 8034d4a:	f8d3 3564 	ldr.w	r3, [r3, #1380]	; 0x564
 8034d4e:	e7bf      	b.n	8034cd0 <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.JoinAcceptDelay2 = Nvm.MacGroup2.MacParams.JoinAcceptDelay2;
 8034d50:	4b1a      	ldr	r3, [pc, #104]	; (8034dbc <LoRaMacMibGetRequestConfirm+0x160>)
 8034d52:	f8d3 3568 	ldr.w	r3, [r3, #1384]	; 0x568
 8034d56:	e7bb      	b.n	8034cd0 <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.ChannelsDefaultDatarate = Nvm.MacGroup2.ChannelsDatarateDefault;
 8034d58:	4b18      	ldr	r3, [pc, #96]	; (8034dbc <LoRaMacMibGetRequestConfirm+0x160>)
 8034d5a:	f893 35d1 	ldrb.w	r3, [r3, #1489]	; 0x5d1
 8034d5e:	e7a6      	b.n	8034cae <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.ChannelsDatarate = Nvm.MacGroup1.ChannelsDatarate;
 8034d60:	4b16      	ldr	r3, [pc, #88]	; (8034dbc <LoRaMacMibGetRequestConfirm+0x160>)
 8034d62:	f893 3545 	ldrb.w	r3, [r3, #1349]	; 0x545
 8034d66:	e7a2      	b.n	8034cae <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.ChannelsDefaultTxPower = Nvm.MacGroup2.ChannelsTxPowerDefault;
 8034d68:	4b14      	ldr	r3, [pc, #80]	; (8034dbc <LoRaMacMibGetRequestConfirm+0x160>)
 8034d6a:	f893 35d0 	ldrb.w	r3, [r3, #1488]	; 0x5d0
 8034d6e:	e79e      	b.n	8034cae <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.ChannelsTxPower = Nvm.MacGroup1.ChannelsTxPower;
 8034d70:	4b12      	ldr	r3, [pc, #72]	; (8034dbc <LoRaMacMibGetRequestConfirm+0x160>)
 8034d72:	f893 3544 	ldrb.w	r3, [r3, #1348]	; 0x544
 8034d76:	e79a      	b.n	8034cae <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.SystemMaxRxError = Nvm.MacGroup2.MacParams.SystemMaxRxError;
 8034d78:	4b10      	ldr	r3, [pc, #64]	; (8034dbc <LoRaMacMibGetRequestConfirm+0x160>)
 8034d7a:	f8d3 3550 	ldr.w	r3, [r3, #1360]	; 0x550
 8034d7e:	e7a7      	b.n	8034cd0 <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.MinRxSymbols = Nvm.MacGroup2.MacParams.MinRxSymbols;
 8034d80:	4b0e      	ldr	r3, [pc, #56]	; (8034dbc <LoRaMacMibGetRequestConfirm+0x160>)
 8034d82:	f893 3554 	ldrb.w	r3, [r3, #1364]	; 0x554
 8034d86:	e792      	b.n	8034cae <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.AntennaGain = Nvm.MacGroup2.MacParams.AntennaGain;
 8034d88:	4b0c      	ldr	r3, [pc, #48]	; (8034dbc <LoRaMacMibGetRequestConfirm+0x160>)
 8034d8a:	f8d3 3588 	ldr.w	r3, [r3, #1416]	; 0x588
            mibGet->Param.DefaultAntennaGain = Nvm.MacGroup2.MacParamsDefaults.AntennaGain;
 8034d8e:	6063      	str	r3, [r4, #4]
            break;
 8034d90:	e792      	b.n	8034cb8 <LoRaMacMibGetRequestConfirm+0x5c>
            mibGet->Param.Contexts = GetNvmData( );
 8034d92:	4b0f      	ldr	r3, [pc, #60]	; (8034dd0 <LoRaMacMibGetRequestConfirm+0x174>)
 8034d94:	e79c      	b.n	8034cd0 <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.DefaultAntennaGain = Nvm.MacGroup2.MacParamsDefaults.AntennaGain;
 8034d96:	4b09      	ldr	r3, [pc, #36]	; (8034dbc <LoRaMacMibGetRequestConfirm+0x160>)
 8034d98:	f8d3 35c8 	ldr.w	r3, [r3, #1480]	; 0x5c8
 8034d9c:	e7f7      	b.n	8034d8e <LoRaMacMibGetRequestConfirm+0x132>
            mibGet->Param.LrWanVersion.LoRaWan = Nvm.MacGroup2.Version;
 8034d9e:	4b07      	ldr	r3, [pc, #28]	; (8034dbc <LoRaMacMibGetRequestConfirm+0x160>)
 8034da0:	f8d3 3618 	ldr.w	r3, [r3, #1560]	; 0x618
 8034da4:	6063      	str	r3, [r4, #4]
            mibGet->Param.LrWanVersion.LoRaWanRegion = RegionGetVersion( );
 8034da6:	f001 fdbb 	bl	8036920 <RegionGetVersion>
 8034daa:	60a0      	str	r0, [r4, #8]
 8034dac:	e784      	b.n	8034cb8 <LoRaMacMibGetRequestConfirm+0x5c>
            status = LoRaMacClassBMibGetRequestConfirm( mibGet );
 8034dae:	4620      	mov	r0, r4
 8034db0:	f000 fe0c 	bl	80359cc <LoRaMacClassBMibGetRequestConfirm>
            break;
 8034db4:	e776      	b.n	8034ca4 <LoRaMacMibGetRequestConfirm+0x48>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 8034db6:	2003      	movs	r0, #3
 8034db8:	e774      	b.n	8034ca4 <LoRaMacMibGetRequestConfirm+0x48>
 8034dba:	bf00      	nop
 8034dbc:	20004aa4 	.word	0x20004aa4
 8034dc0:	20005014 	.word	0x20005014
 8034dc4:	20005054 	.word	0x20005054
 8034dc8:	2000501c 	.word	0x2000501c
 8034dcc:	2000505c 	.word	0x2000505c
 8034dd0:	20004fb0 	.word	0x20004fb0

08034dd4 <LoRaMacMibSetRequestConfirm>:

LoRaMacStatus_t LoRaMacMibSetRequestConfirm( MibRequestConfirm_t* mibSet )
{
 8034dd4:	b573      	push	{r0, r1, r4, r5, r6, lr}
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
    ChanMaskSetParams_t chanMaskSet;
    VerifyParams_t verify;

    if( mibSet == NULL )
 8034dd6:	4604      	mov	r4, r0
 8034dd8:	2800      	cmp	r0, #0
 8034dda:	d044      	beq.n	8034e66 <LoRaMacMibSetRequestConfirm+0x92>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }
    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 8034ddc:	4da5      	ldr	r5, [pc, #660]	; (8035074 <LoRaMacMibSetRequestConfirm+0x2a0>)
 8034dde:	f8d5 3344 	ldr.w	r3, [r5, #836]	; 0x344
 8034de2:	079a      	lsls	r2, r3, #30
 8034de4:	f100 8206 	bmi.w	80351f4 <LoRaMacMibSetRequestConfirm+0x420>
    {
        return LORAMAC_STATUS_BUSY;
    }

    switch( mibSet->Type )
 8034de8:	7802      	ldrb	r2, [r0, #0]
 8034dea:	2a27      	cmp	r2, #39	; 0x27
 8034dec:	f200 81ff 	bhi.w	80351ee <LoRaMacMibSetRequestConfirm+0x41a>
 8034df0:	e8df f012 	tbh	[pc, r2, lsl #1]
 8034df4:	002d0028 	.word	0x002d0028
 8034df8:	003b0034 	.word	0x003b0034
 8034dfc:	0043003f 	.word	0x0043003f
 8034e00:	004b0047 	.word	0x004b0047
 8034e04:	005a0055 	.word	0x005a0055
 8034e08:	0064005f 	.word	0x0064005f
 8034e0c:	006e0069 	.word	0x006e0069
 8034e10:	00780073 	.word	0x00780073
 8034e14:	01fd0081 	.word	0x01fd0081
 8034e18:	00a40085 	.word	0x00a40085
 8034e1c:	00da00b5 	.word	0x00da00b5
 8034e20:	00ec00fa 	.word	0x00ec00fa
 8034e24:	010600fe 	.word	0x010600fe
 8034e28:	010e010a 	.word	0x010e010a
 8034e2c:	01160112 	.word	0x01160112
 8034e30:	012b011a 	.word	0x012b011a
 8034e34:	014c015d 	.word	0x014c015d
 8034e38:	0174016e 	.word	0x0174016e
 8034e3c:	017e017a 	.word	0x017e017a
 8034e40:	01f20182 	.word	0x01f20182
    {
        case MIB_DEVICE_CLASS:
        {
            status = SwitchClass( mibSet->Param.Class );
 8034e44:	7900      	ldrb	r0, [r0, #4]
 8034e46:	f7fe fc8b 	bl	8033760 <SwitchClass>
            status = LoRaMacMibClassBSetRequestConfirm( mibSet );
            break;
        }
    }
    return status;
}
 8034e4a:	b002      	add	sp, #8
 8034e4c:	bd70      	pop	{r4, r5, r6, pc}
            if( mibSet->Param.NetworkActivation != ACTIVATION_TYPE_OTAA  )
 8034e4e:	7903      	ldrb	r3, [r0, #4]
 8034e50:	2b02      	cmp	r3, #2
 8034e52:	d008      	beq.n	8034e66 <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup2.NetworkActivation = mibSet->Param.NetworkActivation;
 8034e54:	f885 361c 	strb.w	r3, [r5, #1564]	; 0x61c
    return LORAMAC_STATUS_OK;
 8034e58:	2000      	movs	r0, #0
 8034e5a:	e7f6      	b.n	8034e4a <LoRaMacMibSetRequestConfirm+0x76>
            if( SecureElementSetDevEui( mibSet->Param.DevEui ) != SECURE_ELEMENT_SUCCESS )
 8034e5c:	6840      	ldr	r0, [r0, #4]
 8034e5e:	f004 f81b 	bl	8038e98 <SecureElementSetDevEui>
 8034e62:	2800      	cmp	r0, #0
 8034e64:	d0f8      	beq.n	8034e58 <LoRaMacMibSetRequestConfirm+0x84>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 8034e66:	2003      	movs	r0, #3
 8034e68:	e7ef      	b.n	8034e4a <LoRaMacMibSetRequestConfirm+0x76>
            if( SecureElementSetJoinEui( mibSet->Param.JoinEui ) != SECURE_ELEMENT_SUCCESS )
 8034e6a:	6840      	ldr	r0, [r0, #4]
 8034e6c:	f004 f828 	bl	8038ec0 <SecureElementSetJoinEui>
 8034e70:	e7f7      	b.n	8034e62 <LoRaMacMibSetRequestConfirm+0x8e>
            Nvm.MacGroup2.AdrCtrlOn = mibSet->Param.AdrEnable;
 8034e72:	7903      	ldrb	r3, [r0, #4]
 8034e74:	f885 360a 	strb.w	r3, [r5, #1546]	; 0x60a
            break;
 8034e78:	e7ee      	b.n	8034e58 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.NetID = mibSet->Param.NetID;
 8034e7a:	6843      	ldr	r3, [r0, #4]
 8034e7c:	f8c5 35d4 	str.w	r3, [r5, #1492]	; 0x5d4
            break;
 8034e80:	e7ea      	b.n	8034e58 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.DevAddr = mibSet->Param.DevAddr;
 8034e82:	6843      	ldr	r3, [r0, #4]
 8034e84:	f8c5 35d8 	str.w	r3, [r5, #1496]	; 0x5d8
            break;
 8034e88:	e7e6      	b.n	8034e58 <LoRaMacMibSetRequestConfirm+0x84>
            if( mibSet->Param.AppKey != NULL )
 8034e8a:	6841      	ldr	r1, [r0, #4]
 8034e8c:	2900      	cmp	r1, #0
 8034e8e:	d0ea      	beq.n	8034e66 <LoRaMacMibSetRequestConfirm+0x92>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( APP_KEY, mibSet->Param.AppKey ) )
 8034e90:	2000      	movs	r0, #0
 8034e92:	f001 fa1f 	bl	80362d4 <LoRaMacCryptoSetKey>
 8034e96:	2800      	cmp	r0, #0
 8034e98:	d0de      	beq.n	8034e58 <LoRaMacMibSetRequestConfirm+0x84>
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 8034e9a:	2011      	movs	r0, #17
 8034e9c:	e7d5      	b.n	8034e4a <LoRaMacMibSetRequestConfirm+0x76>
            if( mibSet->Param.NwkKey != NULL )
 8034e9e:	6841      	ldr	r1, [r0, #4]
 8034ea0:	2900      	cmp	r1, #0
 8034ea2:	d0e0      	beq.n	8034e66 <LoRaMacMibSetRequestConfirm+0x92>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( NWK_KEY, mibSet->Param.NwkKey ) )
 8034ea4:	2001      	movs	r0, #1
 8034ea6:	e7f4      	b.n	8034e92 <LoRaMacMibSetRequestConfirm+0xbe>
            if( mibSet->Param.NwkSKey != NULL )
 8034ea8:	6841      	ldr	r1, [r0, #4]
 8034eaa:	2900      	cmp	r1, #0
 8034eac:	d0db      	beq.n	8034e66 <LoRaMacMibSetRequestConfirm+0x92>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( NWK_S_KEY, mibSet->Param.NwkSKey ) )
 8034eae:	2002      	movs	r0, #2
 8034eb0:	e7ef      	b.n	8034e92 <LoRaMacMibSetRequestConfirm+0xbe>
            if( mibSet->Param.AppSKey != NULL )
 8034eb2:	6841      	ldr	r1, [r0, #4]
 8034eb4:	2900      	cmp	r1, #0
 8034eb6:	d0d6      	beq.n	8034e66 <LoRaMacMibSetRequestConfirm+0x92>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( APP_S_KEY, mibSet->Param.AppSKey ) )
 8034eb8:	2003      	movs	r0, #3
 8034eba:	e7ea      	b.n	8034e92 <LoRaMacMibSetRequestConfirm+0xbe>
            if( mibSet->Param.McKEKey != NULL )
 8034ebc:	6841      	ldr	r1, [r0, #4]
 8034ebe:	2900      	cmp	r1, #0
 8034ec0:	d0d1      	beq.n	8034e66 <LoRaMacMibSetRequestConfirm+0x92>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KE_KEY, mibSet->Param.McKEKey ) )
 8034ec2:	207f      	movs	r0, #127	; 0x7f
 8034ec4:	e7e5      	b.n	8034e92 <LoRaMacMibSetRequestConfirm+0xbe>
            if( mibSet->Param.McKey0 != NULL )
 8034ec6:	6841      	ldr	r1, [r0, #4]
 8034ec8:	2900      	cmp	r1, #0
 8034eca:	d0cc      	beq.n	8034e66 <LoRaMacMibSetRequestConfirm+0x92>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KEY_0, mibSet->Param.McKey0 ) )
 8034ecc:	2080      	movs	r0, #128	; 0x80
 8034ece:	e7e0      	b.n	8034e92 <LoRaMacMibSetRequestConfirm+0xbe>
            if( mibSet->Param.McAppSKey0 != NULL )
 8034ed0:	6841      	ldr	r1, [r0, #4]
 8034ed2:	2900      	cmp	r1, #0
 8034ed4:	d0c7      	beq.n	8034e66 <LoRaMacMibSetRequestConfirm+0x92>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_APP_S_KEY_0, mibSet->Param.McAppSKey0 ) )
 8034ed6:	2081      	movs	r0, #129	; 0x81
 8034ed8:	e7db      	b.n	8034e92 <LoRaMacMibSetRequestConfirm+0xbe>
            if( mibSet->Param.McNwkSKey0 != NULL )
 8034eda:	6841      	ldr	r1, [r0, #4]
 8034edc:	2900      	cmp	r1, #0
 8034ede:	d0c2      	beq.n	8034e66 <LoRaMacMibSetRequestConfirm+0x92>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_NWK_S_KEY_0, mibSet->Param.McNwkSKey0 ) )
 8034ee0:	2082      	movs	r0, #130	; 0x82
 8034ee2:	e7d6      	b.n	8034e92 <LoRaMacMibSetRequestConfirm+0xbe>
            Radio.SetPublicNetwork( Nvm.MacGroup2.PublicNetwork );
 8034ee4:	4c64      	ldr	r4, [pc, #400]	; (8035078 <LoRaMacMibSetRequestConfirm+0x2a4>)
            Nvm.MacGroup2.PublicNetwork = mibSet->Param.EnablePublicNetwork;
 8034ee6:	7900      	ldrb	r0, [r0, #4]
            Radio.SetPublicNetwork( Nvm.MacGroup2.PublicNetwork );
 8034ee8:	6da3      	ldr	r3, [r4, #88]	; 0x58
            Nvm.MacGroup2.PublicNetwork = mibSet->Param.EnablePublicNetwork;
 8034eea:	f885 0609 	strb.w	r0, [r5, #1545]	; 0x609
            Radio.SetPublicNetwork( Nvm.MacGroup2.PublicNetwork );
 8034eee:	4798      	blx	r3
            Radio.Sleep( );
 8034ef0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8034ef2:	4798      	blx	r3
            break;
 8034ef4:	e7b0      	b.n	8034e58 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.RepeaterSupport = mibSet->Param.EnableRepeaterSupport;
 8034ef6:	7903      	ldrb	r3, [r0, #4]
 8034ef8:	f885 358c 	strb.w	r3, [r5, #1420]	; 0x58c
            break;
 8034efc:	e7ac      	b.n	8034e58 <LoRaMacMibSetRequestConfirm+0x84>
            verify.DatarateParams.Datarate = mibSet->Param.Rx2Channel.Datarate;
 8034efe:	7a03      	ldrb	r3, [r0, #8]
 8034f00:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) != true )
 8034f04:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 8034f08:	f895 3581 	ldrb.w	r3, [r5, #1409]	; 0x581
 8034f0c:	f88d 3001 	strb.w	r3, [sp, #1]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) != true )
 8034f10:	2207      	movs	r2, #7
 8034f12:	4669      	mov	r1, sp
 8034f14:	f001 fc2b 	bl	803676e <RegionVerify>
 8034f18:	2800      	cmp	r0, #0
 8034f1a:	d0a4      	beq.n	8034e66 <LoRaMacMibSetRequestConfirm+0x92>
                verify.Frequency = mibSet->Param.Rx2Channel.Frequency;
 8034f1c:	6863      	ldr	r3, [r4, #4]
                if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_FREQUENCY ) != true )
 8034f1e:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
                verify.Frequency = mibSet->Param.Rx2Channel.Frequency;
 8034f22:	9300      	str	r3, [sp, #0]
                if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_FREQUENCY ) != true )
 8034f24:	2200      	movs	r2, #0
 8034f26:	4669      	mov	r1, sp
 8034f28:	f001 fc21 	bl	803676e <RegionVerify>
 8034f2c:	2800      	cmp	r0, #0
 8034f2e:	d09a      	beq.n	8034e66 <LoRaMacMibSetRequestConfirm+0x92>
                    Nvm.MacGroup2.MacParams.Rx2Channel = mibSet->Param.Rx2Channel;
 8034f30:	4b52      	ldr	r3, [pc, #328]	; (803507c <LoRaMacMibSetRequestConfirm+0x2a8>)
                Nvm.MacGroup2.MacParamsDefaults.Rx2Channel = mibSet->Param.Rx2DefaultChannel;
 8034f32:	e9d4 0101 	ldrd	r0, r1, [r4, #4]
 8034f36:	e883 0003 	stmia.w	r3, {r0, r1}
 8034f3a:	e78d      	b.n	8034e58 <LoRaMacMibSetRequestConfirm+0x84>
            verify.DatarateParams.Datarate = mibSet->Param.Rx2Channel.Datarate;
 8034f3c:	7a03      	ldrb	r3, [r0, #8]
 8034f3e:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 8034f42:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 8034f46:	f895 3581 	ldrb.w	r3, [r5, #1409]	; 0x581
 8034f4a:	f88d 3001 	strb.w	r3, [sp, #1]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 8034f4e:	2207      	movs	r2, #7
 8034f50:	4669      	mov	r1, sp
 8034f52:	f001 fc0c 	bl	803676e <RegionVerify>
 8034f56:	2800      	cmp	r0, #0
 8034f58:	d085      	beq.n	8034e66 <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup2.MacParamsDefaults.Rx2Channel = mibSet->Param.Rx2DefaultChannel;
 8034f5a:	4b49      	ldr	r3, [pc, #292]	; (8035080 <LoRaMacMibSetRequestConfirm+0x2ac>)
 8034f5c:	e7e9      	b.n	8034f32 <LoRaMacMibSetRequestConfirm+0x15e>
            verify.DatarateParams.Datarate = mibSet->Param.RxCChannel.Datarate;
 8034f5e:	7a03      	ldrb	r3, [r0, #8]
 8034f60:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 8034f64:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 8034f68:	f895 3581 	ldrb.w	r3, [r5, #1409]	; 0x581
 8034f6c:	f88d 3001 	strb.w	r3, [sp, #1]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 8034f70:	2207      	movs	r2, #7
 8034f72:	4669      	mov	r1, sp
 8034f74:	f001 fbfb 	bl	803676e <RegionVerify>
 8034f78:	2800      	cmp	r0, #0
 8034f7a:	f43f af74 	beq.w	8034e66 <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup2.MacParams.RxCChannel = mibSet->Param.RxCChannel;
 8034f7e:	e9d4 0101 	ldrd	r0, r1, [r4, #4]
 8034f82:	4b40      	ldr	r3, [pc, #256]	; (8035084 <LoRaMacMibSetRequestConfirm+0x2b0>)
 8034f84:	e883 0003 	stmia.w	r3, {r0, r1}
                if( ( Nvm.MacGroup2.DeviceClass == CLASS_C ) && ( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE ) )
 8034f88:	f895 3608 	ldrb.w	r3, [r5, #1544]	; 0x608
 8034f8c:	2b02      	cmp	r3, #2
 8034f8e:	f47f af63 	bne.w	8034e58 <LoRaMacMibSetRequestConfirm+0x84>
 8034f92:	f895 361c 	ldrb.w	r3, [r5, #1564]	; 0x61c
 8034f96:	2b00      	cmp	r3, #0
 8034f98:	f43f af5e 	beq.w	8034e58 <LoRaMacMibSetRequestConfirm+0x84>
                    Radio.Sleep( );
 8034f9c:	4b36      	ldr	r3, [pc, #216]	; (8035078 <LoRaMacMibSetRequestConfirm+0x2a4>)
 8034f9e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8034fa0:	4798      	blx	r3
                    OpenContinuousRxCWindow( );
 8034fa2:	f7fe fbb3 	bl	803370c <OpenContinuousRxCWindow>
 8034fa6:	e757      	b.n	8034e58 <LoRaMacMibSetRequestConfirm+0x84>
            verify.DatarateParams.Datarate = mibSet->Param.RxCChannel.Datarate;
 8034fa8:	7a03      	ldrb	r3, [r0, #8]
 8034faa:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 8034fae:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 8034fb2:	f895 3581 	ldrb.w	r3, [r5, #1409]	; 0x581
 8034fb6:	f88d 3001 	strb.w	r3, [sp, #1]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 8034fba:	2207      	movs	r2, #7
 8034fbc:	4669      	mov	r1, sp
 8034fbe:	f001 fbd6 	bl	803676e <RegionVerify>
 8034fc2:	2800      	cmp	r0, #0
 8034fc4:	f43f af4f 	beq.w	8034e66 <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup2.MacParamsDefaults.RxCChannel = mibSet->Param.RxCDefaultChannel;
 8034fc8:	4b2f      	ldr	r3, [pc, #188]	; (8035088 <LoRaMacMibSetRequestConfirm+0x2b4>)
 8034fca:	e7b2      	b.n	8034f32 <LoRaMacMibSetRequestConfirm+0x15e>
            chanMaskSet.ChannelsMaskIn = mibSet->Param.ChannelsDefaultMask;
 8034fcc:	6843      	ldr	r3, [r0, #4]
 8034fce:	9300      	str	r3, [sp, #0]
            chanMaskSet.ChannelsMaskType = CHANNELS_DEFAULT_MASK;
 8034fd0:	2301      	movs	r3, #1
            if( RegionChanMaskSet( Nvm.MacGroup2.Region, &chanMaskSet ) == false )
 8034fd2:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            chanMaskSet.ChannelsMaskType = CHANNELS_MASK;
 8034fd6:	f88d 3004 	strb.w	r3, [sp, #4]
            if( RegionChanMaskSet( Nvm.MacGroup2.Region, &chanMaskSet ) == false )
 8034fda:	4669      	mov	r1, sp
 8034fdc:	f001 fbdf 	bl	803679e <RegionChanMaskSet>
 8034fe0:	2800      	cmp	r0, #0
 8034fe2:	f47f af39 	bne.w	8034e58 <LoRaMacMibSetRequestConfirm+0x84>
 8034fe6:	e73e      	b.n	8034e66 <LoRaMacMibSetRequestConfirm+0x92>
            chanMaskSet.ChannelsMaskIn = mibSet->Param.ChannelsMask;
 8034fe8:	6843      	ldr	r3, [r0, #4]
 8034fea:	9300      	str	r3, [sp, #0]
            chanMaskSet.ChannelsMaskType = CHANNELS_MASK;
 8034fec:	2300      	movs	r3, #0
 8034fee:	e7f0      	b.n	8034fd2 <LoRaMacMibSetRequestConfirm+0x1fe>
            if( ( mibSet->Param.ChannelsNbTrans >= 1 ) &&
 8034ff0:	7903      	ldrb	r3, [r0, #4]
 8034ff2:	1e5a      	subs	r2, r3, #1
 8034ff4:	2a0e      	cmp	r2, #14
 8034ff6:	f63f af36 	bhi.w	8034e66 <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup2.MacParams.ChannelsNbTrans = mibSet->Param.ChannelsNbTrans;
 8034ffa:	f885 356c 	strb.w	r3, [r5, #1388]	; 0x56c
 8034ffe:	e72b      	b.n	8034e58 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.MaxRxWindow = mibSet->Param.MaxRxWindow;
 8035000:	6843      	ldr	r3, [r0, #4]
 8035002:	f8c5 3558 	str.w	r3, [r5, #1368]	; 0x558
            break;
 8035006:	e727      	b.n	8034e58 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.ReceiveDelay1 = mibSet->Param.ReceiveDelay1;
 8035008:	6843      	ldr	r3, [r0, #4]
 803500a:	f8c5 355c 	str.w	r3, [r5, #1372]	; 0x55c
            break;
 803500e:	e723      	b.n	8034e58 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.ReceiveDelay2 = mibSet->Param.ReceiveDelay2;
 8035010:	6843      	ldr	r3, [r0, #4]
 8035012:	f8c5 3560 	str.w	r3, [r5, #1376]	; 0x560
            break;
 8035016:	e71f      	b.n	8034e58 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.JoinAcceptDelay1 = mibSet->Param.JoinAcceptDelay1;
 8035018:	6843      	ldr	r3, [r0, #4]
 803501a:	f8c5 3564 	str.w	r3, [r5, #1380]	; 0x564
            break;
 803501e:	e71b      	b.n	8034e58 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.JoinAcceptDelay2 = mibSet->Param.JoinAcceptDelay2;
 8035020:	6843      	ldr	r3, [r0, #4]
 8035022:	f8c5 3568 	str.w	r3, [r5, #1384]	; 0x568
            break;
 8035026:	e717      	b.n	8034e58 <LoRaMacMibSetRequestConfirm+0x84>
            verify.DatarateParams.Datarate = mibSet->Param.ChannelsDefaultDatarate;
 8035028:	7903      	ldrb	r3, [r0, #4]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_DR ) == true )
 803502a:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            verify.DatarateParams.Datarate = mibSet->Param.ChannelsDefaultDatarate;
 803502e:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_DR ) == true )
 8035032:	2206      	movs	r2, #6
 8035034:	4669      	mov	r1, sp
 8035036:	f001 fb9a 	bl	803676e <RegionVerify>
 803503a:	2800      	cmp	r0, #0
 803503c:	f43f af13 	beq.w	8034e66 <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup2.ChannelsDatarateDefault = verify.DatarateParams.Datarate;
 8035040:	f89d 3000 	ldrb.w	r3, [sp]
 8035044:	f885 35d1 	strb.w	r3, [r5, #1489]	; 0x5d1
 8035048:	e706      	b.n	8034e58 <LoRaMacMibSetRequestConfirm+0x84>
            verify.DatarateParams.Datarate = mibSet->Param.ChannelsDatarate;
 803504a:	7903      	ldrb	r3, [r0, #4]
 803504c:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_DR ) == true )
 8035050:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            verify.DatarateParams.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8035054:	f895 3580 	ldrb.w	r3, [r5, #1408]	; 0x580
 8035058:	f88d 3002 	strb.w	r3, [sp, #2]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_DR ) == true )
 803505c:	2205      	movs	r2, #5
 803505e:	4669      	mov	r1, sp
 8035060:	f001 fb85 	bl	803676e <RegionVerify>
 8035064:	2800      	cmp	r0, #0
 8035066:	f43f aefe 	beq.w	8034e66 <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup1.ChannelsDatarate = verify.DatarateParams.Datarate;
 803506a:	f89d 3000 	ldrb.w	r3, [sp]
 803506e:	f885 3545 	strb.w	r3, [r5, #1349]	; 0x545
 8035072:	e6f1      	b.n	8034e58 <LoRaMacMibSetRequestConfirm+0x84>
 8035074:	20004aa4 	.word	0x20004aa4
 8035078:	0803bc30 	.word	0x0803bc30
 803507c:	20005014 	.word	0x20005014
 8035080:	20005054 	.word	0x20005054
 8035084:	2000501c 	.word	0x2000501c
 8035088:	2000505c 	.word	0x2000505c
            verify.TxPower = mibSet->Param.ChannelsDefaultTxPower;
 803508c:	7903      	ldrb	r3, [r0, #4]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_POWER ) == true )
 803508e:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            verify.TxPower = mibSet->Param.ChannelsDefaultTxPower;
 8035092:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_POWER ) == true )
 8035096:	220a      	movs	r2, #10
 8035098:	4669      	mov	r1, sp
 803509a:	f001 fb68 	bl	803676e <RegionVerify>
 803509e:	2800      	cmp	r0, #0
 80350a0:	f43f aee1 	beq.w	8034e66 <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup2.ChannelsTxPowerDefault = verify.TxPower;
 80350a4:	f89d 3000 	ldrb.w	r3, [sp]
 80350a8:	f885 35d0 	strb.w	r3, [r5, #1488]	; 0x5d0
 80350ac:	e6d4      	b.n	8034e58 <LoRaMacMibSetRequestConfirm+0x84>
            verify.TxPower = mibSet->Param.ChannelsTxPower;
 80350ae:	7903      	ldrb	r3, [r0, #4]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_POWER ) == true )
 80350b0:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            verify.TxPower = mibSet->Param.ChannelsTxPower;
 80350b4:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_POWER ) == true )
 80350b8:	2209      	movs	r2, #9
 80350ba:	4669      	mov	r1, sp
 80350bc:	f001 fb57 	bl	803676e <RegionVerify>
 80350c0:	2800      	cmp	r0, #0
 80350c2:	f43f aed0 	beq.w	8034e66 <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup1.ChannelsTxPower = verify.TxPower;
 80350c6:	f89d 3000 	ldrb.w	r3, [sp]
 80350ca:	f885 3544 	strb.w	r3, [r5, #1348]	; 0x544
 80350ce:	e6c3      	b.n	8034e58 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.SystemMaxRxError = Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError = mibSet->Param.SystemMaxRxError;
 80350d0:	6843      	ldr	r3, [r0, #4]
 80350d2:	f8c5 3590 	str.w	r3, [r5, #1424]	; 0x590
 80350d6:	f8c5 3550 	str.w	r3, [r5, #1360]	; 0x550
            break;
 80350da:	e6bd      	b.n	8034e58 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.MinRxSymbols = Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols = mibSet->Param.MinRxSymbols;
 80350dc:	7903      	ldrb	r3, [r0, #4]
 80350de:	f885 3594 	strb.w	r3, [r5, #1428]	; 0x594
 80350e2:	f885 3554 	strb.w	r3, [r5, #1364]	; 0x554
            break;
 80350e6:	e6b7      	b.n	8034e58 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.AntennaGain = mibSet->Param.AntennaGain;
 80350e8:	6843      	ldr	r3, [r0, #4]
 80350ea:	f8c5 3588 	str.w	r3, [r5, #1416]	; 0x588
            break;
 80350ee:	e6b3      	b.n	8034e58 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParamsDefaults.AntennaGain = mibSet->Param.DefaultAntennaGain;
 80350f0:	6843      	ldr	r3, [r0, #4]
 80350f2:	f8c5 35c8 	str.w	r3, [r5, #1480]	; 0x5c8
            break;
 80350f6:	e6af      	b.n	8034e58 <LoRaMacMibSetRequestConfirm+0x84>
            if( mibSet->Param.Contexts != 0 )
 80350f8:	6844      	ldr	r4, [r0, #4]
 80350fa:	2c00      	cmp	r4, #0
 80350fc:	f43f aeb3 	beq.w	8034e66 <LoRaMacMibSetRequestConfirm+0x92>
    if( MacCtx.MacState != LORAMAC_STOPPED )
 8035100:	2b01      	cmp	r3, #1
 8035102:	d177      	bne.n	80351f4 <LoRaMacMibSetRequestConfirm+0x420>
    crc = Crc32( ( uint8_t* ) &nvm->Crypto, sizeof( nvm->Crypto ) -
 8035104:	2124      	movs	r1, #36	; 0x24
 8035106:	4620      	mov	r0, r4
 8035108:	f003 ff2e 	bl	8038f68 <Crc32>
    if( crc == nvm->Crypto.Crc32 )
 803510c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 803510e:	4298      	cmp	r0, r3
 8035110:	d104      	bne.n	803511c <LoRaMacMibSetRequestConfirm+0x348>
        memcpy1( ( uint8_t* ) &Nvm.Crypto, ( uint8_t* ) &nvm->Crypto,
 8035112:	4839      	ldr	r0, [pc, #228]	; (80351f8 <LoRaMacMibSetRequestConfirm+0x424>)
 8035114:	2228      	movs	r2, #40	; 0x28
 8035116:	4621      	mov	r1, r4
 8035118:	f003 ff0a 	bl	8038f30 <memcpy1>
    crc = Crc32( ( uint8_t* ) &nvm->MacGroup1, sizeof( nvm->MacGroup1 ) -
 803511c:	f104 0628 	add.w	r6, r4, #40	; 0x28
 8035120:	2114      	movs	r1, #20
 8035122:	4630      	mov	r0, r6
 8035124:	f003 ff20 	bl	8038f68 <Crc32>
    if( crc == nvm->MacGroup1.Crc32 )
 8035128:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 803512a:	4298      	cmp	r0, r3
 803512c:	d104      	bne.n	8035138 <LoRaMacMibSetRequestConfirm+0x364>
        memcpy1( ( uint8_t* ) &Nvm.MacGroup1, ( uint8_t* ) &nvm->MacGroup1,
 803512e:	4833      	ldr	r0, [pc, #204]	; (80351fc <LoRaMacMibSetRequestConfirm+0x428>)
 8035130:	2218      	movs	r2, #24
 8035132:	4631      	mov	r1, r6
 8035134:	f003 fefc 	bl	8038f30 <memcpy1>
    crc = Crc32( ( uint8_t* ) &nvm->MacGroup2, sizeof( nvm->MacGroup2 ) -
 8035138:	f104 0640 	add.w	r6, r4, #64	; 0x40
 803513c:	21d4      	movs	r1, #212	; 0xd4
 803513e:	4630      	mov	r0, r6
 8035140:	f003 ff12 	bl	8038f68 <Crc32>
    if( crc == nvm->MacGroup2.Crc32 )
 8035144:	f8d4 3114 	ldr.w	r3, [r4, #276]	; 0x114
 8035148:	4298      	cmp	r0, r3
 803514a:	d114      	bne.n	8035176 <LoRaMacMibSetRequestConfirm+0x3a2>
        memcpy1( ( uint8_t* ) &Nvm.MacGroup2, ( uint8_t* ) &nvm->MacGroup2,
 803514c:	482c      	ldr	r0, [pc, #176]	; (8035200 <LoRaMacMibSetRequestConfirm+0x42c>)
 803514e:	22d8      	movs	r2, #216	; 0xd8
 8035150:	4631      	mov	r1, r6
 8035152:	f003 feed 	bl	8038f30 <memcpy1>
        MacCtx.RxWindowCConfig.Channel = MacCtx.Channel;
 8035156:	f895 3419 	ldrb.w	r3, [r5, #1049]	; 0x419
 803515a:	f885 33e4 	strb.w	r3, [r5, #996]	; 0x3e4
        MacCtx.RxWindowCConfig.Frequency = Nvm.MacGroup2.MacParams.RxCChannel.Frequency;
 803515e:	f8d5 3578 	ldr.w	r3, [r5, #1400]	; 0x578
 8035162:	f8c5 33e8 	str.w	r3, [r5, #1000]	; 0x3e8
        MacCtx.RxWindowCConfig.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 8035166:	f895 3581 	ldrb.w	r3, [r5, #1409]	; 0x581
 803516a:	f885 33f4 	strb.w	r3, [r5, #1012]	; 0x3f4
        MacCtx.RxWindowCConfig.RxContinuous = true;
 803516e:	f240 2301 	movw	r3, #513	; 0x201
 8035172:	f8a5 33f6 	strh.w	r3, [r5, #1014]	; 0x3f6
    crc = Crc32( ( uint8_t* ) &nvm->SecureElement, sizeof( nvm->SecureElement ) -
 8035176:	f504 758c 	add.w	r5, r4, #280	; 0x118
 803517a:	f44f 7180 	mov.w	r1, #256	; 0x100
 803517e:	4628      	mov	r0, r5
 8035180:	f003 fef2 	bl	8038f68 <Crc32>
    if( crc == nvm->SecureElement.Crc32 )
 8035184:	f8d4 3218 	ldr.w	r3, [r4, #536]	; 0x218
 8035188:	4298      	cmp	r0, r3
 803518a:	d105      	bne.n	8035198 <LoRaMacMibSetRequestConfirm+0x3c4>
        memcpy1( ( uint8_t* ) &Nvm.SecureElement,( uint8_t* ) &nvm->SecureElement,
 803518c:	481d      	ldr	r0, [pc, #116]	; (8035204 <LoRaMacMibSetRequestConfirm+0x430>)
 803518e:	f44f 7282 	mov.w	r2, #260	; 0x104
 8035192:	4629      	mov	r1, r5
 8035194:	f003 fecc 	bl	8038f30 <memcpy1>
    crc = Crc32( ( uint8_t* ) &nvm->RegionGroup1, sizeof( nvm->RegionGroup1 ) -
 8035198:	f504 7507 	add.w	r5, r4, #540	; 0x21c
 803519c:	21a0      	movs	r1, #160	; 0xa0
 803519e:	4628      	mov	r0, r5
 80351a0:	f003 fee2 	bl	8038f68 <Crc32>
    if( crc == nvm->RegionGroup1.Crc32 )
 80351a4:	f8d4 32bc 	ldr.w	r3, [r4, #700]	; 0x2bc
 80351a8:	4298      	cmp	r0, r3
 80351aa:	d104      	bne.n	80351b6 <LoRaMacMibSetRequestConfirm+0x3e2>
        memcpy1( ( uint8_t* ) &Nvm.RegionGroup1,( uint8_t* ) &nvm->RegionGroup1,
 80351ac:	4816      	ldr	r0, [pc, #88]	; (8035208 <LoRaMacMibSetRequestConfirm+0x434>)
 80351ae:	22a4      	movs	r2, #164	; 0xa4
 80351b0:	4629      	mov	r1, r5
 80351b2:	f003 febd 	bl	8038f30 <memcpy1>
    crc = Crc32( ( uint8_t* ) &nvm->ClassB, sizeof( nvm->ClassB ) -
 80351b6:	f204 653c 	addw	r5, r4, #1596	; 0x63c
 80351ba:	2114      	movs	r1, #20
 80351bc:	4628      	mov	r0, r5
 80351be:	f003 fed3 	bl	8038f68 <Crc32>
    if( crc == nvm->ClassB.Crc32 )
 80351c2:	f8d4 3650 	ldr.w	r3, [r4, #1616]	; 0x650
 80351c6:	4298      	cmp	r0, r3
 80351c8:	f47f ae46 	bne.w	8034e58 <LoRaMacMibSetRequestConfirm+0x84>
        memcpy1( ( uint8_t* ) &Nvm.ClassB,( uint8_t* ) &nvm->ClassB,
 80351cc:	480f      	ldr	r0, [pc, #60]	; (803520c <LoRaMacMibSetRequestConfirm+0x438>)
 80351ce:	2218      	movs	r2, #24
 80351d0:	4629      	mov	r1, r5
 80351d2:	f003 fead 	bl	8038f30 <memcpy1>
 80351d6:	e63f      	b.n	8034e58 <LoRaMacMibSetRequestConfirm+0x84>
            if( mibSet->Param.AbpLrWanVersion.Fields.Minor <= 1 )
 80351d8:	7983      	ldrb	r3, [r0, #6]
 80351da:	2b01      	cmp	r3, #1
 80351dc:	f63f ae43 	bhi.w	8034e66 <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup2.Version = mibSet->Param.AbpLrWanVersion;
 80351e0:	6843      	ldr	r3, [r0, #4]
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetLrWanVersion( mibSet->Param.AbpLrWanVersion ) )
 80351e2:	6840      	ldr	r0, [r0, #4]
                Nvm.MacGroup2.Version = mibSet->Param.AbpLrWanVersion;
 80351e4:	f8c5 3618 	str.w	r3, [r5, #1560]	; 0x618
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetLrWanVersion( mibSet->Param.AbpLrWanVersion ) )
 80351e8:	f000 ff04 	bl	8035ff4 <LoRaMacCryptoSetLrWanVersion>
 80351ec:	e653      	b.n	8034e96 <LoRaMacMibSetRequestConfirm+0xc2>
            status = LoRaMacMibClassBSetRequestConfirm( mibSet );
 80351ee:	f000 fbef 	bl	80359d0 <LoRaMacMibClassBSetRequestConfirm>
            break;
 80351f2:	e62a      	b.n	8034e4a <LoRaMacMibSetRequestConfirm+0x76>
        return LORAMAC_STATUS_BUSY;
 80351f4:	2001      	movs	r0, #1
 80351f6:	e628      	b.n	8034e4a <LoRaMacMibSetRequestConfirm+0x76>
 80351f8:	20004fb0 	.word	0x20004fb0
 80351fc:	20004fd8 	.word	0x20004fd8
 8035200:	20004ff0 	.word	0x20004ff0
 8035204:	200050c8 	.word	0x200050c8
 8035208:	200051cc 	.word	0x200051cc
 803520c:	200055ec 	.word	0x200055ec

08035210 <LoRaMacMcChannelSetup>:
    return LORAMAC_STATUS_OK;
}

LoRaMacStatus_t LoRaMacMcChannelSetup( McChannelParams_t *channel )
{
    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 8035210:	4b24      	ldr	r3, [pc, #144]	; (80352a4 <LoRaMacMcChannelSetup+0x94>)
 8035212:	f8d3 2344 	ldr.w	r2, [r3, #836]	; 0x344
 8035216:	f012 0f02 	tst.w	r2, #2
{
 803521a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 803521e:	4604      	mov	r4, r0
 8035220:	4698      	mov	r8, r3
    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 8035222:	d13b      	bne.n	803529c <LoRaMacMcChannelSetup+0x8c>
    {
        return LORAMAC_STATUS_BUSY;
    }

    if( channel->GroupID >= LORAMAC_MAX_MC_CTX )
 8035224:	78c7      	ldrb	r7, [r0, #3]
 8035226:	2f00      	cmp	r7, #0
 8035228:	d13a      	bne.n	80352a0 <LoRaMacMcChannelSetup+0x90>
    {
        return LORAMAC_STATUS_MC_GROUP_UNDEFINED;
    }

    Nvm.MacGroup2.MulticastChannelList[channel->GroupID].ChannelParams = *channel;
 803522a:	4606      	mov	r6, r0
 803522c:	f203 55dc 	addw	r5, r3, #1500	; 0x5dc
 8035230:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8035232:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8035234:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
 8035238:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}

    if( channel->IsRemotelySetup == true )
 803523c:	7823      	ldrb	r3, [r4, #0]
#if ( LORAMAC_MAX_MC_CTX > 3 )
            , MC_KEY_3
#endif /* LORAMAC_MAX_MC_CTX > 3 */
        };
        /* ST_WORKAROUND_END */
        if( LoRaMacCryptoSetKey( mcKeys[channel->GroupID], channel->McKeys.McKeyE ) != LORAMAC_CRYPTO_SUCCESS )
 803523e:	68a1      	ldr	r1, [r4, #8]
    if( channel->IsRemotelySetup == true )
 8035240:	b313      	cbz	r3, 8035288 <LoRaMacMcChannelSetup+0x78>
        if( LoRaMacCryptoSetKey( mcKeys[channel->GroupID], channel->McKeys.McKeyE ) != LORAMAC_CRYPTO_SUCCESS )
 8035242:	2080      	movs	r0, #128	; 0x80
 8035244:	f001 f846 	bl	80362d4 <LoRaMacCryptoSetKey>
 8035248:	b118      	cbz	r0, 8035252 <LoRaMacMcChannelSetup+0x42>
{
 803524a:	2711      	movs	r7, #17
    }

    // Reset multicast channel downlink counter to initial value.
    *Nvm.MacGroup2.MulticastChannelList[channel->GroupID].DownLinkCounter = FCNT_DOWN_INITAL_VALUE;
    return LORAMAC_STATUS_OK;
}
 803524c:	4638      	mov	r0, r7
 803524e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if( LoRaMacCryptoDeriveMcSessionKeyPair( channel->GroupID, channel->Address ) != LORAMAC_CRYPTO_SUCCESS )
 8035252:	6861      	ldr	r1, [r4, #4]
 8035254:	78e0      	ldrb	r0, [r4, #3]
 8035256:	f001 f8c5 	bl	80363e4 <LoRaMacCryptoDeriveMcSessionKeyPair>
        if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( mcNwkSKeys[channel->GroupID], channel->McKeys.Session.McNwkSKey ) )
 803525a:	2800      	cmp	r0, #0
 803525c:	d1f5      	bne.n	803524a <LoRaMacMcChannelSetup+0x3a>
    if( channel->Class == CLASS_B )
 803525e:	7863      	ldrb	r3, [r4, #1]
 8035260:	2b01      	cmp	r3, #1
 8035262:	d107      	bne.n	8035274 <LoRaMacMcChannelSetup+0x64>
        LoRaMacClassBSetMulticastPeriodicity( &Nvm.MacGroup2.MulticastChannelList[channel->GroupID] );
 8035264:	78e0      	ldrb	r0, [r4, #3]
 8035266:	4b10      	ldr	r3, [pc, #64]	; (80352a8 <LoRaMacMcChannelSetup+0x98>)
 8035268:	222c      	movs	r2, #44	; 0x2c
 803526a:	fb02 3000 	mla	r0, r2, r0, r3
 803526e:	30d0      	adds	r0, #208	; 0xd0
 8035270:	f000 fbba 	bl	80359e8 <LoRaMacClassBSetMulticastPeriodicity>
    *Nvm.MacGroup2.MulticastChannelList[channel->GroupID].DownLinkCounter = FCNT_DOWN_INITAL_VALUE;
 8035274:	78e3      	ldrb	r3, [r4, #3]
 8035276:	222c      	movs	r2, #44	; 0x2c
 8035278:	fb02 8803 	mla	r8, r2, r3, r8
 803527c:	f04f 32ff 	mov.w	r2, #4294967295
 8035280:	f8d8 35fc 	ldr.w	r3, [r8, #1532]	; 0x5fc
 8035284:	601a      	str	r2, [r3, #0]
    return LORAMAC_STATUS_OK;
 8035286:	e7e1      	b.n	803524c <LoRaMacMcChannelSetup+0x3c>
        if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( mcAppSKeys[channel->GroupID], channel->McKeys.Session.McAppSKey ) )
 8035288:	2081      	movs	r0, #129	; 0x81
 803528a:	f001 f823 	bl	80362d4 <LoRaMacCryptoSetKey>
 803528e:	2800      	cmp	r0, #0
 8035290:	d1db      	bne.n	803524a <LoRaMacMcChannelSetup+0x3a>
        if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( mcNwkSKeys[channel->GroupID], channel->McKeys.Session.McNwkSKey ) )
 8035292:	68e1      	ldr	r1, [r4, #12]
 8035294:	2082      	movs	r0, #130	; 0x82
 8035296:	f001 f81d 	bl	80362d4 <LoRaMacCryptoSetKey>
 803529a:	e7de      	b.n	803525a <LoRaMacMcChannelSetup+0x4a>
        return LORAMAC_STATUS_BUSY;
 803529c:	2701      	movs	r7, #1
 803529e:	e7d5      	b.n	803524c <LoRaMacMcChannelSetup+0x3c>
        return LORAMAC_STATUS_MC_GROUP_UNDEFINED;
 80352a0:	2716      	movs	r7, #22
 80352a2:	e7d3      	b.n	803524c <LoRaMacMcChannelSetup+0x3c>
 80352a4:	20004aa4 	.word	0x20004aa4
 80352a8:	20004fb0 	.word	0x20004fb0

080352ac <LoRaMacMcChannelDelete>:

LoRaMacStatus_t LoRaMacMcChannelDelete( AddressIdentifier_t groupID )
{
 80352ac:	b570      	push	{r4, r5, r6, lr}
    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 80352ae:	4c10      	ldr	r4, [pc, #64]	; (80352f0 <LoRaMacMcChannelDelete+0x44>)
 80352b0:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 80352b4:	079b      	lsls	r3, r3, #30
{
 80352b6:	b088      	sub	sp, #32
 80352b8:	4606      	mov	r6, r0
    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 80352ba:	d414      	bmi.n	80352e6 <LoRaMacMcChannelDelete+0x3a>
    {
        return LORAMAC_STATUS_BUSY;
    }

    if( ( groupID >= LORAMAC_MAX_MC_CTX ) ||
 80352bc:	b9a8      	cbnz	r0, 80352ea <LoRaMacMcChannelDelete+0x3e>
 80352be:	f894 35de 	ldrb.w	r3, [r4, #1502]	; 0x5de
 80352c2:	b193      	cbz	r3, 80352ea <LoRaMacMcChannelDelete+0x3e>
    }

    McChannelParams_t channel;

    // Set all channel fields with 0
    memset1( ( uint8_t* )&channel, 0, sizeof( McChannelParams_t ) );
 80352c4:	4601      	mov	r1, r0
 80352c6:	2220      	movs	r2, #32
 80352c8:	4668      	mov	r0, sp

    Nvm.MacGroup2.MulticastChannelList[groupID].ChannelParams = channel;
 80352ca:	466d      	mov	r5, sp
    memset1( ( uint8_t* )&channel, 0, sizeof( McChannelParams_t ) );
 80352cc:	f003 fe44 	bl	8038f58 <memset1>
    Nvm.MacGroup2.MulticastChannelList[groupID].ChannelParams = channel;
 80352d0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80352d2:	f204 54dc 	addw	r4, r4, #1500	; 0x5dc
 80352d6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80352d8:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 80352dc:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    return LORAMAC_STATUS_OK;
}
 80352e0:	4630      	mov	r0, r6
 80352e2:	b008      	add	sp, #32
 80352e4:	bd70      	pop	{r4, r5, r6, pc}
        return LORAMAC_STATUS_BUSY;
 80352e6:	2601      	movs	r6, #1
 80352e8:	e7fa      	b.n	80352e0 <LoRaMacMcChannelDelete+0x34>
        return LORAMAC_STATUS_MC_GROUP_UNDEFINED;
 80352ea:	2616      	movs	r6, #22
 80352ec:	e7f8      	b.n	80352e0 <LoRaMacMcChannelDelete+0x34>
 80352ee:	bf00      	nop
 80352f0:	20004aa4 	.word	0x20004aa4

080352f4 <LoRaMacMcChannelGetGroupId>:

uint8_t LoRaMacMcChannelGetGroupId( uint32_t mcAddress )
{
    for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
    {
        if( mcAddress == Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.Address )
 80352f4:	4b03      	ldr	r3, [pc, #12]	; (8035304 <LoRaMacMcChannelGetGroupId+0x10>)
 80352f6:	f8d3 35e0 	ldr.w	r3, [r3, #1504]	; 0x5e0
        {
            return i;
        }
    }
    return 0xFF;
}
 80352fa:	4283      	cmp	r3, r0
 80352fc:	bf14      	ite	ne
 80352fe:	20ff      	movne	r0, #255	; 0xff
 8035300:	2000      	moveq	r0, #0
 8035302:	4770      	bx	lr
 8035304:	20004aa4 	.word	0x20004aa4

08035308 <LoRaMacMcChannelSetupRxParams>:

LoRaMacStatus_t LoRaMacMcChannelSetupRxParams( AddressIdentifier_t groupID, McRxParams_t *rxParams, uint8_t *status )
{
   *status = 0x1C + ( groupID & 0x03 );
 8035308:	f000 0303 	and.w	r3, r0, #3
{
 803530c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   *status = 0x1C + ( groupID & 0x03 );
 803530e:	331c      	adds	r3, #28

    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 8035310:	4e24      	ldr	r6, [pc, #144]	; (80353a4 <LoRaMacMcChannelSetupRxParams+0x9c>)
   *status = 0x1C + ( groupID & 0x03 );
 8035312:	7013      	strb	r3, [r2, #0]
{
 8035314:	4615      	mov	r5, r2
    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 8035316:	f8d6 2344 	ldr.w	r2, [r6, #836]	; 0x344
 803531a:	0792      	lsls	r2, r2, #30
{
 803531c:	4604      	mov	r4, r0
 803531e:	460f      	mov	r7, r1
    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 8035320:	d439      	bmi.n	8035396 <LoRaMacMcChannelSetupRxParams+0x8e>
    {
        return LORAMAC_STATUS_BUSY;
    }

    DeviceClass_t devClass = Nvm.MacGroup2.MulticastChannelList[groupID].ChannelParams.Class;
 8035322:	222c      	movs	r2, #44	; 0x2c
 8035324:	fb02 6200 	mla	r2, r2, r0, r6
 8035328:	f892 25dd 	ldrb.w	r2, [r2, #1501]	; 0x5dd
    if( ( devClass == CLASS_A ) || ( devClass > CLASS_C ) )
 803532c:	1e51      	subs	r1, r2, #1
 803532e:	2901      	cmp	r1, #1
 8035330:	d833      	bhi.n	803539a <LoRaMacMcChannelSetupRxParams+0x92>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }

    if( ( groupID >= LORAMAC_MAX_MC_CTX ) ||
 8035332:	bba0      	cbnz	r0, 803539e <LoRaMacMcChannelSetupRxParams+0x96>
 8035334:	f896 15de 	ldrb.w	r1, [r6, #1502]	; 0x5de
 8035338:	b389      	cbz	r1, 803539e <LoRaMacMcChannelSetupRxParams+0x96>
        ( Nvm.MacGroup2.MulticastChannelList[groupID].ChannelParams.IsEnabled == false ) )
    {
        return LORAMAC_STATUS_MC_GROUP_UNDEFINED;
    }
    *status &= 0x0F; // groupID OK
 803533a:	f003 030f 	and.w	r3, r3, #15
 803533e:	702b      	strb	r3, [r5, #0]

    VerifyParams_t verify;
    // Check datarate
    if( devClass == CLASS_B )
    {
        verify.DatarateParams.Datarate = rxParams->ClassB.Datarate;
 8035340:	f997 3004 	ldrsb.w	r3, [r7, #4]
 8035344:	f88d 3004 	strb.w	r3, [sp, #4]
    {
        verify.DatarateParams.Datarate = rxParams->ClassC.Datarate;
    }
    verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;

    if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 8035348:	f896 054c 	ldrb.w	r0, [r6, #1356]	; 0x54c
    verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 803534c:	f896 3581 	ldrb.w	r3, [r6, #1409]	; 0x581
 8035350:	f88d 3005 	strb.w	r3, [sp, #5]
    if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 8035354:	2207      	movs	r2, #7
 8035356:	a901      	add	r1, sp, #4
 8035358:	f001 fa09 	bl	803676e <RegionVerify>
 803535c:	b118      	cbz	r0, 8035366 <LoRaMacMcChannelSetupRxParams+0x5e>
    {
        *status &= 0xFB; // datarate OK
 803535e:	782b      	ldrb	r3, [r5, #0]
 8035360:	f023 0304 	bic.w	r3, r3, #4
 8035364:	702b      	strb	r3, [r5, #0]
    }

    // Check frequency
    if( devClass == CLASS_B )
 8035366:	683b      	ldr	r3, [r7, #0]
    }
    else
    {
        verify.Frequency = rxParams->ClassC.Frequency;
    }
    if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_FREQUENCY ) == true )
 8035368:	f896 054c 	ldrb.w	r0, [r6, #1356]	; 0x54c
 803536c:	9301      	str	r3, [sp, #4]
 803536e:	2200      	movs	r2, #0
 8035370:	a901      	add	r1, sp, #4
 8035372:	f001 f9fc 	bl	803676e <RegionVerify>
 8035376:	b118      	cbz	r0, 8035380 <LoRaMacMcChannelSetupRxParams+0x78>
    {
        *status &= 0xF7; // frequency OK
 8035378:	782b      	ldrb	r3, [r5, #0]
 803537a:	f023 0308 	bic.w	r3, r3, #8
 803537e:	702b      	strb	r3, [r5, #0]
    }

    if( *status == ( groupID & 0x03 ) )
 8035380:	782b      	ldrb	r3, [r5, #0]
 8035382:	b92b      	cbnz	r3, 8035390 <LoRaMacMcChannelSetupRxParams+0x88>
    {
        // Apply parameters
        Nvm.MacGroup2.MulticastChannelList[groupID].ChannelParams.RxParams = *rxParams;
 8035384:	e897 0003 	ldmia.w	r7, {r0, r1}
 8035388:	4a07      	ldr	r2, [pc, #28]	; (80353a8 <LoRaMacMcChannelSetupRxParams+0xa0>)
 803538a:	e882 0003 	stmia.w	r2, {r0, r1}
    }
    return LORAMAC_STATUS_OK;
 803538e:	461c      	mov	r4, r3
}
 8035390:	4620      	mov	r0, r4
 8035392:	b003      	add	sp, #12
 8035394:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return LORAMAC_STATUS_BUSY;
 8035396:	2401      	movs	r4, #1
 8035398:	e7fa      	b.n	8035390 <LoRaMacMcChannelSetupRxParams+0x88>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 803539a:	2403      	movs	r4, #3
 803539c:	e7f8      	b.n	8035390 <LoRaMacMcChannelSetupRxParams+0x88>
        return LORAMAC_STATUS_MC_GROUP_UNDEFINED;
 803539e:	2416      	movs	r4, #22
 80353a0:	e7f6      	b.n	8035390 <LoRaMacMcChannelSetupRxParams+0x88>
 80353a2:	bf00      	nop
 80353a4:	20004aa4 	.word	0x20004aa4
 80353a8:	20005098 	.word	0x20005098

080353ac <LoRaMacMlmeRequest>:

LoRaMacStatus_t LoRaMacMlmeRequest( MlmeReq_t* mlmeRequest )
{
 80353ac:	b5f0      	push	{r4, r5, r6, r7, lr}
 80353ae:	b087      	sub	sp, #28
    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;
    MlmeConfirmQueue_t queueElement;
    uint8_t macCmdPayload[2] = { 0x00, 0x00 };
 80353b0:	2300      	movs	r3, #0
 80353b2:	f8ad 3000 	strh.w	r3, [sp]

    if( mlmeRequest == NULL )
 80353b6:	4606      	mov	r6, r0
 80353b8:	2800      	cmp	r0, #0
 80353ba:	f000 80df 	beq.w	803557c <LoRaMacMlmeRequest+0x1d0>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }
    if( LoRaMacIsBusy( ) == true )
 80353be:	f7fe fd5d 	bl	8033e7c <LoRaMacIsBusy>
 80353c2:	b118      	cbz	r0, 80353cc <LoRaMacMlmeRequest+0x20>
    {
        return LORAMAC_STATUS_BUSY;
 80353c4:	2501      	movs	r5, #1
    else
    {
        LoRaMacConfirmQueueAdd( &queueElement );
    }
    return status;
}
 80353c6:	4628      	mov	r0, r5
 80353c8:	b007      	add	sp, #28
 80353ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if( LoRaMacConfirmQueueIsFull( ) == true )
 80353cc:	f000 fcf4 	bl	8035db8 <LoRaMacConfirmQueueIsFull>
 80353d0:	2800      	cmp	r0, #0
 80353d2:	d1f7      	bne.n	80353c4 <LoRaMacMlmeRequest+0x18>
    if( LoRaMacConfirmQueueGetCnt( ) == 0 )
 80353d4:	f000 fcea 	bl	8035dac <LoRaMacConfirmQueueGetCnt>
 80353d8:	4601      	mov	r1, r0
 80353da:	b918      	cbnz	r0, 80353e4 <LoRaMacMlmeRequest+0x38>
        memset1( ( uint8_t* ) &MacCtx.MlmeConfirm, 0, sizeof( MacCtx.MlmeConfirm ) );
 80353dc:	4868      	ldr	r0, [pc, #416]	; (8035580 <LoRaMacMlmeRequest+0x1d4>)
 80353de:	2214      	movs	r2, #20
 80353e0:	f003 fdba 	bl	8038f58 <memset1>
    MacCtx.MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 80353e4:	4c67      	ldr	r4, [pc, #412]	; (8035584 <LoRaMacMlmeRequest+0x1d8>)
    MacCtx.MacFlags.Bits.MlmeReq = 1;
 80353e6:	f894 2485 	ldrb.w	r2, [r4, #1157]	; 0x485
    MacCtx.MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 80353ea:	2301      	movs	r3, #1
    MacCtx.MacFlags.Bits.MlmeReq = 1;
 80353ec:	f042 0204 	orr.w	r2, r2, #4
    MacCtx.MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 80353f0:	f884 3451 	strb.w	r3, [r4, #1105]	; 0x451
    MacCtx.MacFlags.Bits.MlmeReq = 1;
 80353f4:	f884 2485 	strb.w	r2, [r4, #1157]	; 0x485
    queueElement.Request = mlmeRequest->Type;
 80353f8:	7832      	ldrb	r2, [r6, #0]
 80353fa:	f88d 2004 	strb.w	r2, [sp, #4]
    queueElement.RestrictCommonReadyToHandle = false;
 80353fe:	2100      	movs	r1, #0
 8035400:	3a01      	subs	r2, #1
    queueElement.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 8035402:	f88d 3005 	strb.w	r3, [sp, #5]
    queueElement.RestrictCommonReadyToHandle = false;
 8035406:	f88d 1007 	strb.w	r1, [sp, #7]
    switch( mlmeRequest->Type )
 803540a:	2a0d      	cmp	r2, #13
 803540c:	f200 80ae 	bhi.w	803556c <LoRaMacMlmeRequest+0x1c0>
 8035410:	e8df f002 	tbb	[pc, r2]
 8035414:	57acac07 	.word	0x57acac07
 8035418:	acac8261 	.word	0xacac8261
 803541c:	a0ac8aac 	.word	0xa0ac8aac
 8035420:	9c8e      	.short	0x9c8e
            if( ( MacCtx.MacState & LORAMAC_TX_DELAYED ) == LORAMAC_TX_DELAYED )
 8035422:	f8d4 5344 	ldr.w	r5, [r4, #836]	; 0x344
 8035426:	f015 0520 	ands.w	r5, r5, #32
 803542a:	d1cb      	bne.n	80353c4 <LoRaMacMlmeRequest+0x18>
            ResetMacParameters( );
 803542c:	f7fd ff3a 	bl	80332a4 <ResetMacParameters>
            Nvm.MacGroup1.ChannelsDatarate = RegionAlternateDr( Nvm.MacGroup2.Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR );
 8035430:	462a      	mov	r2, r5
 8035432:	f996 1004 	ldrsb.w	r1, [r6, #4]
 8035436:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
            MacCtx.TxMsg.Message.JoinReq.Buffer = MacCtx.PktBuffer;
 803543a:	4f53      	ldr	r7, [pc, #332]	; (8035588 <LoRaMacMlmeRequest+0x1dc>)
            Nvm.MacGroup1.ChannelsDatarate = RegionAlternateDr( Nvm.MacGroup2.Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR );
 803543c:	f001 fa32 	bl	80368a4 <RegionAlternateDr>
            queueElement.Status = LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL;
 8035440:	2307      	movs	r3, #7
            Nvm.MacGroup1.ChannelsDatarate = RegionAlternateDr( Nvm.MacGroup2.Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR );
 8035442:	f884 0545 	strb.w	r0, [r4, #1349]	; 0x545
            SwitchClass( CLASS_A );
 8035446:	4628      	mov	r0, r5
            queueElement.Status = LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL;
 8035448:	f88d 3005 	strb.w	r3, [sp, #5]
            SwitchClass( CLASS_A );
 803544c:	f7fe f988 	bl	8033760 <SwitchClass>
            MacCtx.TxMsg.Message.JoinReq.BufSize = LORAMAC_PHY_MAXPAYLOAD;
 8035450:	23ff      	movs	r3, #255	; 0xff
 8035452:	f884 3110 	strb.w	r3, [r4, #272]	; 0x110
            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_JOIN_REQUEST;
 8035456:	f884 5108 	strb.w	r5, [r4, #264]	; 0x108
            MacCtx.TxMsg.Message.JoinReq.MHDR.Value = macHdr.Value;
 803545a:	f884 5111 	strb.w	r5, [r4, #273]	; 0x111
            MacCtx.TxMsg.Message.JoinReq.Buffer = MacCtx.PktBuffer;
 803545e:	f8c4 710c 	str.w	r7, [r4, #268]	; 0x10c
            memcpy1( MacCtx.TxMsg.Message.JoinReq.JoinEUI, SecureElementGetJoinEui( ), LORAMAC_JOIN_EUI_FIELD_SIZE );
 8035462:	f003 fd3d 	bl	8038ee0 <SecureElementGetJoinEui>
 8035466:	2208      	movs	r2, #8
 8035468:	4601      	mov	r1, r0
 803546a:	f507 7086 	add.w	r0, r7, #268	; 0x10c
 803546e:	f003 fd5f 	bl	8038f30 <memcpy1>
            memcpy1( MacCtx.TxMsg.Message.JoinReq.DevEUI, SecureElementGetDevEui( ), LORAMAC_DEV_EUI_FIELD_SIZE );
 8035472:	f003 fd1f 	bl	8038eb4 <SecureElementGetDevEui>
 8035476:	2208      	movs	r2, #8
 8035478:	4601      	mov	r1, r0
 803547a:	f507 708a 	add.w	r0, r7, #276	; 0x114
 803547e:	f003 fd57 	bl	8038f30 <memcpy1>
    status = ScheduleTx( allowDelayedTx );
 8035482:	4628      	mov	r0, r5
 8035484:	f7fd ffa2 	bl	80333cc <ScheduleTx>
            if( status != LORAMAC_STATUS_OK )
 8035488:	4605      	mov	r5, r0
 803548a:	b140      	cbz	r0, 803549e <LoRaMacMlmeRequest+0xf2>
                Nvm.MacGroup1.ChannelsDatarate = RegionAlternateDr( Nvm.MacGroup2.Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR_RESTORE );
 803548c:	f996 1004 	ldrsb.w	r1, [r6, #4]
 8035490:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
 8035494:	2201      	movs	r2, #1
 8035496:	f001 fa05 	bl	80368a4 <RegionAlternateDr>
 803549a:	f884 0545 	strb.w	r0, [r4, #1349]	; 0x545
    mlmeRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;
 803549e:	f8d4 3488 	ldr.w	r3, [r4, #1160]	; 0x488
 80354a2:	6133      	str	r3, [r6, #16]
    if( status != LORAMAC_STATUS_OK )
 80354a4:	2d00      	cmp	r5, #0
 80354a6:	d065      	beq.n	8035574 <LoRaMacMlmeRequest+0x1c8>
        if( LoRaMacConfirmQueueGetCnt( ) == 0 )
 80354a8:	f000 fc80 	bl	8035dac <LoRaMacConfirmQueueGetCnt>
 80354ac:	2800      	cmp	r0, #0
 80354ae:	d18a      	bne.n	80353c6 <LoRaMacMlmeRequest+0x1a>
            MacCtx.MacFlags.Bits.MlmeReq = 0;
 80354b0:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
            MacCtx.NodeAckRequested = false;
 80354b4:	f884 0418 	strb.w	r0, [r4, #1048]	; 0x418
            MacCtx.MacFlags.Bits.MlmeReq = 0;
 80354b8:	f360 0382 	bfi	r3, r0, #2, #1
 80354bc:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
 80354c0:	e781      	b.n	80353c6 <LoRaMacMlmeRequest+0x1a>
            if( LoRaMacCommandsAddCmd( MOTE_MAC_LINK_CHECK_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )
 80354c2:	2200      	movs	r2, #0
 80354c4:	4669      	mov	r1, sp
 80354c6:	2002      	movs	r0, #2
 80354c8:	f000 fa9e 	bl	8035a08 <LoRaMacCommandsAddCmd>
 80354cc:	b908      	cbnz	r0, 80354d2 <LoRaMacMlmeRequest+0x126>
            status = SetTxContinuousWave( mlmeRequest->Req.TxCw.Timeout );
 80354ce:	2500      	movs	r5, #0
            break;
 80354d0:	e7e5      	b.n	803549e <LoRaMacMlmeRequest+0xf2>
                status = LORAMAC_STATUS_MAC_COMMAD_ERROR;
 80354d2:	2513      	movs	r5, #19
 80354d4:	e7e3      	b.n	803549e <LoRaMacMlmeRequest+0xf2>
    continuousWave.Channel = MacCtx.Channel;
 80354d6:	f894 2419 	ldrb.w	r2, [r4, #1049]	; 0x419
 80354da:	f88d 2008 	strb.w	r2, [sp, #8]
    continuousWave.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 80354de:	f894 2545 	ldrb.w	r2, [r4, #1349]	; 0x545
 80354e2:	f88d 2009 	strb.w	r2, [sp, #9]
    continuousWave.TxPower = Nvm.MacGroup1.ChannelsTxPower;
 80354e6:	f894 2544 	ldrb.w	r2, [r4, #1348]	; 0x544
 80354ea:	f88d 200a 	strb.w	r2, [sp, #10]
    continuousWave.MaxEirp = Nvm.MacGroup2.MacParams.MaxEirp;
 80354ee:	f8d4 2584 	ldr.w	r2, [r4, #1412]	; 0x584
            status = SetTxContinuousWave( mlmeRequest->Req.TxCw.Timeout );
 80354f2:	88b3      	ldrh	r3, [r6, #4]
    continuousWave.MaxEirp = Nvm.MacGroup2.MacParams.MaxEirp;
 80354f4:	9203      	str	r2, [sp, #12]
    RegionSetContinuousWave( Nvm.MacGroup2.Region, &continuousWave );
 80354f6:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    continuousWave.AntennaGain = Nvm.MacGroup2.MacParams.AntennaGain;
 80354fa:	f8d4 2588 	ldr.w	r2, [r4, #1416]	; 0x588
 80354fe:	9204      	str	r2, [sp, #16]
    RegionSetContinuousWave( Nvm.MacGroup2.Region, &continuousWave );
 8035500:	a902      	add	r1, sp, #8
    continuousWave.Timeout = timeout;
 8035502:	f8ad 3014 	strh.w	r3, [sp, #20]
    RegionSetContinuousWave( Nvm.MacGroup2.Region, &continuousWave );
 8035506:	f001 f9ed 	bl	80368e4 <RegionSetContinuousWave>
    MacCtx.MacState |= LORAMAC_TX_RUNNING;
 803550a:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 803550e:	f043 0302 	orr.w	r3, r3, #2
 8035512:	f8c4 3344 	str.w	r3, [r4, #836]	; 0x344
 8035516:	e7da      	b.n	80354ce <LoRaMacMlmeRequest+0x122>
    Radio.SetTxContinuousWave( frequency, power, timeout );
 8035518:	4b1c      	ldr	r3, [pc, #112]	; (803558c <LoRaMacMlmeRequest+0x1e0>)
 803551a:	88b2      	ldrh	r2, [r6, #4]
 803551c:	f996 100c 	ldrsb.w	r1, [r6, #12]
 8035520:	68b0      	ldr	r0, [r6, #8]
 8035522:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8035524:	4798      	blx	r3
    MacCtx.MacState |= LORAMAC_TX_RUNNING;
 8035526:	e7f0      	b.n	803550a <LoRaMacMlmeRequest+0x15e>
            if( LoRaMacCommandsAddCmd( MOTE_MAC_DEVICE_TIME_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )
 8035528:	2200      	movs	r2, #0
 803552a:	4669      	mov	r1, sp
 803552c:	200d      	movs	r0, #13
 803552e:	e7cb      	b.n	80354c8 <LoRaMacMlmeRequest+0x11c>
            if( Nvm.MacGroup2.DeviceClass == CLASS_A )
 8035530:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 8035534:	b9d3      	cbnz	r3, 803556c <LoRaMacMlmeRequest+0x1c0>
                uint8_t value = mlmeRequest->Req.PingSlotInfo.PingSlot.Value;
 8035536:	7935      	ldrb	r5, [r6, #4]
                LoRaMacClassBSetPingSlotInfo( mlmeRequest->Req.PingSlotInfo.PingSlot.Fields.Periodicity );
 8035538:	f005 0007 	and.w	r0, r5, #7
 803553c:	f000 fa41 	bl	80359c2 <LoRaMacClassBSetPingSlotInfo>
                macCmdPayload[0] = value;
 8035540:	f88d 5000 	strb.w	r5, [sp]
                if( LoRaMacCommandsAddCmd( MOTE_MAC_PING_SLOT_INFO_REQ, macCmdPayload, 1 ) != LORAMAC_COMMANDS_SUCCESS )
 8035544:	2201      	movs	r2, #1
 8035546:	4669      	mov	r1, sp
 8035548:	2010      	movs	r0, #16
 803554a:	e7bd      	b.n	80354c8 <LoRaMacMlmeRequest+0x11c>
            if( LoRaMacCommandsAddCmd( MOTE_MAC_BEACON_TIMING_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )
 803554c:	2200      	movs	r2, #0
 803554e:	4669      	mov	r1, sp
 8035550:	2012      	movs	r0, #18
 8035552:	e7b9      	b.n	80354c8 <LoRaMacMlmeRequest+0x11c>
            queueElement.RestrictCommonReadyToHandle = true;
 8035554:	f88d 3007 	strb.w	r3, [sp, #7]
            if( LoRaMacClassBIsAcquisitionInProgress( ) == false )
 8035558:	f000 fa24 	bl	80359a4 <LoRaMacClassBIsAcquisitionInProgress>
 803555c:	4605      	mov	r5, r0
 803555e:	b938      	cbnz	r0, 8035570 <LoRaMacMlmeRequest+0x1c4>
                LoRaMacClassBSetBeaconState( BEACON_STATE_ACQUISITION );
 8035560:	f000 fa1d 	bl	803599e <LoRaMacClassBSetBeaconState>
                LoRaMacClassBBeaconTimerEvent( NULL );
 8035564:	4628      	mov	r0, r5
 8035566:	f000 fa1f 	bl	80359a8 <LoRaMacClassBBeaconTimerEvent>
                status = LORAMAC_STATUS_OK;
 803556a:	e798      	b.n	803549e <LoRaMacMlmeRequest+0xf2>
    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;
 803556c:	2502      	movs	r5, #2
 803556e:	e796      	b.n	803549e <LoRaMacMlmeRequest+0xf2>
                status = LORAMAC_STATUS_BUSY;
 8035570:	2501      	movs	r5, #1
 8035572:	e794      	b.n	803549e <LoRaMacMlmeRequest+0xf2>
        LoRaMacConfirmQueueAdd( &queueElement );
 8035574:	a801      	add	r0, sp, #4
 8035576:	f000 fb6f 	bl	8035c58 <LoRaMacConfirmQueueAdd>
 803557a:	e724      	b.n	80353c6 <LoRaMacMlmeRequest+0x1a>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 803557c:	2503      	movs	r5, #3
 803557e:	e722      	b.n	80353c6 <LoRaMacMlmeRequest+0x1a>
 8035580:	20004ef4 	.word	0x20004ef4
 8035584:	20004aa4 	.word	0x20004aa4
 8035588:	20004aaa 	.word	0x20004aaa
 803558c:	0803bc30 	.word	0x0803bc30

08035590 <LoRaMacMcpsRequest>:

/* ST_WORKAROUND_BEGIN: Update MCPS request with new input parameter to allow delayed tx */
LoRaMacStatus_t LoRaMacMcpsRequest( McpsReq_t* mcpsRequest, bool allowDelayedTx )
{
 8035590:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8035594:	b08f      	sub	sp, #60	; 0x3c
 8035596:	2600      	movs	r6, #0
 8035598:	9101      	str	r1, [sp, #4]
    /* ST_WORKAROUND_END */
    uint16_t fBufferSize;
    int8_t datarate = DR_0;
    bool readyToSend = false;

    if( mcpsRequest == NULL )
 803559a:	4605      	mov	r5, r0
 803559c:	b918      	cbnz	r0, 80355a6 <LoRaMacMcpsRequest+0x16>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
 803559e:	2003      	movs	r0, #3

    // Fill return structure
    mcpsRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;

    return status;
}
 80355a0:	b00f      	add	sp, #60	; 0x3c
 80355a2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( LoRaMacIsBusy( ) == true )
 80355a6:	f7fe fc69 	bl	8033e7c <LoRaMacIsBusy>
 80355aa:	4680      	mov	r8, r0
 80355ac:	2800      	cmp	r0, #0
 80355ae:	f040 815f 	bne.w	8035870 <LoRaMacMcpsRequest+0x2e0>
    memset1( ( uint8_t* ) &MacCtx.McpsConfirm, 0, sizeof( MacCtx.McpsConfirm ) );
 80355b2:	4cb5      	ldr	r4, [pc, #724]	; (8035888 <LoRaMacMcpsRequest+0x2f8>)
 80355b4:	4601      	mov	r1, r0
    macHdr.Value = 0;
 80355b6:	4607      	mov	r7, r0
    memset1( ( uint8_t* ) &MacCtx.McpsConfirm, 0, sizeof( MacCtx.McpsConfirm ) );
 80355b8:	2214      	movs	r2, #20
 80355ba:	f204 403c 	addw	r0, r4, #1084	; 0x43c
 80355be:	f003 fccb 	bl	8038f58 <memset1>
    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 80355c2:	2101      	movs	r1, #1
 80355c4:	f884 143d 	strb.w	r1, [r4, #1085]	; 0x43d
    MacCtx.AckTimeoutRetriesCounter = 1;
 80355c8:	f884 1416 	strb.w	r1, [r4, #1046]	; 0x416
    switch( mcpsRequest->Type )
 80355cc:	7828      	ldrb	r0, [r5, #0]
 80355ce:	4288      	cmp	r0, r1
 80355d0:	f000 80ac 	beq.w	803572c <LoRaMacMcpsRequest+0x19c>
 80355d4:	2803      	cmp	r0, #3
 80355d6:	f000 80bb 	beq.w	8035750 <LoRaMacMcpsRequest+0x1c0>
 80355da:	2800      	cmp	r0, #0
 80355dc:	f040 80c5 	bne.w	803576a <LoRaMacMcpsRequest+0x1da>
            MacCtx.AckTimeoutRetries = 1;
 80355e0:	f884 1415 	strb.w	r1, [r4, #1045]	; 0x415
            macHdr.Bits.MType = FRAME_TYPE_DATA_UNCONFIRMED_UP;
 80355e4:	2302      	movs	r3, #2
            fPort = mcpsRequest->Req.Unconfirmed.fPort;
 80355e6:	f895 a004 	ldrb.w	sl, [r5, #4]
            fBuffer = mcpsRequest->Req.Unconfirmed.fBuffer;
 80355ea:	f8d5 9008 	ldr.w	r9, [r5, #8]
            fBufferSize = mcpsRequest->Req.Unconfirmed.fBufferSize;
 80355ee:	89ae      	ldrh	r6, [r5, #12]
            datarate = mcpsRequest->Req.Unconfirmed.Datarate;
 80355f0:	f995 b00e 	ldrsb.w	fp, [r5, #14]
            macHdr.Bits.MType = FRAME_TYPE_DATA_UNCONFIRMED_UP;
 80355f4:	f363 1747 	bfi	r7, r3, #5, #3
            readyToSend = true;
 80355f8:	4688      	mov	r8, r1
    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 80355fa:	f894 1580 	ldrb.w	r1, [r4, #1408]	; 0x580
 80355fe:	f88d 101e 	strb.w	r1, [sp, #30]
    getPhy.Attribute = PHY_MIN_TX_DR;
 8035602:	2302      	movs	r3, #2
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8035604:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_MIN_TX_DR;
 8035608:	f88d 301c 	strb.w	r3, [sp, #28]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803560c:	a907      	add	r1, sp, #28
 803560e:	f001 f888 	bl	8036722 <RegionGetPhyParam>
    if( readyToSend == true )
 8035612:	2302      	movs	r3, #2
 8035614:	f1b8 0f00 	cmp.w	r8, #0
 8035618:	f000 8128 	beq.w	803586c <LoRaMacMcpsRequest+0x2dc>
        if( Nvm.MacGroup2.AdrCtrlOn == false )
 803561c:	f894 360a 	ldrb.w	r3, [r4, #1546]	; 0x60a
 8035620:	b9ab      	cbnz	r3, 803564e <LoRaMacMcpsRequest+0xbe>
    datarate = MAX( datarate, ( int8_t )phyParam.Value );
 8035622:	b240      	sxtb	r0, r0
 8035624:	4558      	cmp	r0, fp
 8035626:	bfb8      	it	lt
 8035628:	4658      	movlt	r0, fp
            verify.DatarateParams.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 803562a:	f894 3580 	ldrb.w	r3, [r4, #1408]	; 0x580
            verify.DatarateParams.Datarate = datarate;
 803562e:	f88d 000c 	strb.w	r0, [sp, #12]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_DR ) == true )
 8035632:	2205      	movs	r2, #5
 8035634:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
            verify.DatarateParams.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8035638:	f88d 300e 	strb.w	r3, [sp, #14]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_DR ) == true )
 803563c:	a903      	add	r1, sp, #12
 803563e:	f001 f896 	bl	803676e <RegionVerify>
 8035642:	2800      	cmp	r0, #0
 8035644:	d0ab      	beq.n	803559e <LoRaMacMcpsRequest+0xe>
                Nvm.MacGroup1.ChannelsDatarate = verify.DatarateParams.Datarate;
 8035646:	f89d 300c 	ldrb.w	r3, [sp, #12]
 803564a:	f884 3545 	strb.w	r3, [r4, #1349]	; 0x545
    int8_t txPower = Nvm.MacGroup1.ChannelsTxPower;
 803564e:	f8b4 2544 	ldrh.w	r2, [r4, #1348]	; 0x544
 8035652:	f8b4 3544 	ldrh.w	r3, [r4, #1348]	; 0x544
 8035656:	9200      	str	r2, [sp, #0]
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 8035658:	f894 261c 	ldrb.w	r2, [r4, #1564]	; 0x61c
    uint32_t adrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 803565c:	f8d4 1534 	ldr.w	r1, [r4, #1332]	; 0x534
 8035660:	9104      	str	r1, [sp, #16]
 8035662:	ba5b      	rev16	r3, r3
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 8035664:	2a00      	cmp	r2, #0
 8035666:	f000 80ff 	beq.w	8035868 <LoRaMacMcpsRequest+0x2d8>
    if( Nvm.MacGroup2.MaxDCycle == 0 )
 803566a:	f894 260b 	ldrb.w	r2, [r4, #1547]	; 0x60b
 803566e:	b90a      	cbnz	r2, 8035674 <LoRaMacMcpsRequest+0xe4>
        Nvm.MacGroup1.AggregatedTimeOff = 0;
 8035670:	f8c4 253c 	str.w	r2, [r4, #1340]	; 0x53c
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 8035674:	f894 2608 	ldrb.w	r2, [r4, #1544]	; 0x608
    fCtrl.Bits.Adr           = Nvm.MacGroup2.AdrCtrlOn;
 8035678:	f894 060a 	ldrb.w	r0, [r4, #1546]	; 0x60a
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 803567c:	f102 3cff 	add.w	ip, r2, #4294967295
    fCtrl.Value = 0;
 8035680:	f04f 0800 	mov.w	r8, #0
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 8035684:	f1dc 0200 	rsbs	r2, ip, #0
 8035688:	eb42 020c 	adc.w	r2, r2, ip
    fCtrl.Bits.Adr           = Nvm.MacGroup2.AdrCtrlOn;
 803568c:	f360 18c7 	bfi	r8, r0, #7, #1
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 8035690:	f362 1804 	bfi	r8, r2, #4, #1
    if( Nvm.MacGroup1.SrvAckRequested == true )
 8035694:	f894 2546 	ldrb.w	r2, [r4, #1350]	; 0x546
 8035698:	b10a      	cbz	r2, 803569e <LoRaMacMcpsRequest+0x10e>
        fCtrl.Bits.Ack = 1;
 803569a:	f048 0820 	orr.w	r8, r8, #32
    adrNext.Version = Nvm.MacGroup2.Version;
 803569e:	f8d4 2618 	ldr.w	r2, [r4, #1560]	; 0x618
 80356a2:	9209      	str	r2, [sp, #36]	; 0x24
    adrNext.AdrAckLimit = MacCtx.AdrAckLimit;
 80356a4:	f8d4 23f8 	ldr.w	r2, [r4, #1016]	; 0x3f8
 80356a8:	920c      	str	r2, [sp, #48]	; 0x30
    adrNext.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 80356aa:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
    fCtrl.Bits.AdrAckReq = LoRaMacAdrCalcNext( &adrNext, &Nvm.MacGroup1.ChannelsDatarate,
 80356ae:	4a77      	ldr	r2, [pc, #476]	; (803588c <LoRaMacMcpsRequest+0x2fc>)
    adrNext.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 80356b0:	f894 3580 	ldrb.w	r3, [r4, #1408]	; 0x580
 80356b4:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    adrNext.UpdateChanMask = true;
 80356b8:	f04f 0b01 	mov.w	fp, #1
    adrNext.Region = Nvm.MacGroup2.Region;
 80356bc:	f894 354c 	ldrb.w	r3, [r4, #1356]	; 0x54c
    adrNext.AdrEnabled = fCtrl.Bits.Adr;
 80356c0:	f88d 0029 	strb.w	r0, [sp, #41]	; 0x29
    adrNext.AdrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 80356c4:	910b      	str	r1, [sp, #44]	; 0x2c
    adrNext.Region = Nvm.MacGroup2.Region;
 80356c6:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    fCtrl.Bits.AdrAckReq = LoRaMacAdrCalcNext( &adrNext, &Nvm.MacGroup1.ChannelsDatarate,
 80356ca:	eb02 010b 	add.w	r1, r2, fp
 80356ce:	ab04      	add	r3, sp, #16
 80356d0:	a809      	add	r0, sp, #36	; 0x24
    adrNext.UpdateChanMask = true;
 80356d2:	f88d b028 	strb.w	fp, [sp, #40]	; 0x28
    fCtrl.Bits.AdrAckReq = LoRaMacAdrCalcNext( &adrNext, &Nvm.MacGroup1.ChannelsDatarate,
 80356d6:	f000 f8f3 	bl	80358c0 <LoRaMacAdrCalcNext>
    MacCtx.PktBufferLen = 0;
 80356da:	2300      	movs	r3, #0
        fBufferSize = 0;
 80356dc:	4599      	cmp	r9, r3
 80356de:	bf08      	it	eq
 80356e0:	461e      	moveq	r6, r3
    memcpy1( MacCtx.AppData, ( uint8_t* ) fBuffer, fBufferSize );
 80356e2:	4632      	mov	r2, r6
    fCtrl.Bits.AdrAckReq = LoRaMacAdrCalcNext( &adrNext, &Nvm.MacGroup1.ChannelsDatarate,
 80356e4:	f360 1886 	bfi	r8, r0, #6, #1
    memcpy1( MacCtx.AppData, ( uint8_t* ) fBuffer, fBufferSize );
 80356e8:	4649      	mov	r1, r9
 80356ea:	4869      	ldr	r0, [pc, #420]	; (8035890 <LoRaMacMcpsRequest+0x300>)
    MacCtx.PktBufferLen = 0;
 80356ec:	80a3      	strh	r3, [r4, #4]
    size_t macCmdsSize = 0;
 80356ee:	e9cd 3305 	strd	r3, r3, [sp, #20]
    MacCtx.NodeAckRequested = false;
 80356f2:	f884 3418 	strb.w	r3, [r4, #1048]	; 0x418
    memcpy1( MacCtx.AppData, ( uint8_t* ) fBuffer, fBufferSize );
 80356f6:	f003 fc1b 	bl	8038f30 <memcpy1>
    MacCtx.PktBuffer[0] = macHdr->Value;
 80356fa:	b2fb      	uxtb	r3, r7
 80356fc:	71a7      	strb	r7, [r4, #6]
    switch( macHdr->Bits.MType )
 80356fe:	f3c7 1742 	ubfx	r7, r7, #5, #3
    MacCtx.AppDataSize = fBufferSize;
 8035702:	b2f2      	uxtb	r2, r6
    switch( macHdr->Bits.MType )
 8035704:	2f04      	cmp	r7, #4
    MacCtx.AppDataSize = fBufferSize;
 8035706:	f884 223b 	strb.w	r2, [r4, #571]	; 0x23b
    switch( macHdr->Bits.MType )
 803570a:	d032      	beq.n	8035772 <LoRaMacMcpsRequest+0x1e2>
 803570c:	2f07      	cmp	r7, #7
 803570e:	f000 809b 	beq.w	8035848 <LoRaMacMcpsRequest+0x2b8>
 8035712:	2f02      	cmp	r7, #2
 8035714:	d02f      	beq.n	8035776 <LoRaMacMcpsRequest+0x1e6>
            return LORAMAC_STATUS_SERVICE_UNKNOWN;
 8035716:	2002      	movs	r0, #2
        Nvm.MacGroup1.ChannelsTxPower = txPower;
 8035718:	9b00      	ldr	r3, [sp, #0]
 803571a:	f8a4 3544 	strh.w	r3, [r4, #1348]	; 0x544
            MacCtx.NodeAckRequested = false;
 803571e:	2300      	movs	r3, #0
 8035720:	f884 3418 	strb.w	r3, [r4, #1048]	; 0x418
    mcpsRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;
 8035724:	f8d4 3488 	ldr.w	r3, [r4, #1160]	; 0x488
 8035728:	612b      	str	r3, [r5, #16]
    return status;
 803572a:	e739      	b.n	80355a0 <LoRaMacMcpsRequest+0x10>
            MacCtx.AckTimeoutRetries = MIN( mcpsRequest->Req.Confirmed.NbTrials, MAX_ACK_RETRIES );
 803572c:	7beb      	ldrb	r3, [r5, #15]
 803572e:	2b08      	cmp	r3, #8
 8035730:	bf28      	it	cs
 8035732:	2308      	movcs	r3, #8
 8035734:	f884 3415 	strb.w	r3, [r4, #1045]	; 0x415
            macHdr.Bits.MType = FRAME_TYPE_DATA_CONFIRMED_UP;
 8035738:	2304      	movs	r3, #4
            fPort = mcpsRequest->Req.Confirmed.fPort;
 803573a:	f895 a004 	ldrb.w	sl, [r5, #4]
            fBuffer = mcpsRequest->Req.Confirmed.fBuffer;
 803573e:	f8d5 9008 	ldr.w	r9, [r5, #8]
            fBufferSize = mcpsRequest->Req.Confirmed.fBufferSize;
 8035742:	89ae      	ldrh	r6, [r5, #12]
            datarate = mcpsRequest->Req.Confirmed.Datarate;
 8035744:	f995 b00e 	ldrsb.w	fp, [r5, #14]
            macHdr.Bits.MType = FRAME_TYPE_DATA_CONFIRMED_UP;
 8035748:	f363 1747 	bfi	r7, r3, #5, #3
            readyToSend = true;
 803574c:	4680      	mov	r8, r0
            break;
 803574e:	e754      	b.n	80355fa <LoRaMacMcpsRequest+0x6a>
            MacCtx.AckTimeoutRetries = 1;
 8035750:	f884 1415 	strb.w	r1, [r4, #1045]	; 0x415
            fBuffer = mcpsRequest->Req.Proprietary.fBuffer;
 8035754:	f8d5 9004 	ldr.w	r9, [r5, #4]
            fBufferSize = mcpsRequest->Req.Proprietary.fBufferSize;
 8035758:	892e      	ldrh	r6, [r5, #8]
            datarate = mcpsRequest->Req.Proprietary.Datarate;
 803575a:	f995 b00a 	ldrsb.w	fp, [r5, #10]
            macHdr.Bits.MType = FRAME_TYPE_PROPRIETARY;
 803575e:	f067 071f 	orn	r7, r7, #31
            readyToSend = true;
 8035762:	4688      	mov	r8, r1
    uint8_t fPort = 0;
 8035764:	f04f 0a00 	mov.w	sl, #0
            break;
 8035768:	e747      	b.n	80355fa <LoRaMacMcpsRequest+0x6a>
    switch( mcpsRequest->Type )
 803576a:	46c3      	mov	fp, r8
 803576c:	46c1      	mov	r9, r8
 803576e:	46c2      	mov	sl, r8
 8035770:	e743      	b.n	80355fa <LoRaMacMcpsRequest+0x6a>
            MacCtx.NodeAckRequested = true;
 8035772:	f884 b418 	strb.w	fp, [r4, #1048]	; 0x418
            MacCtx.TxMsg.Message.Data.Buffer = MacCtx.PktBuffer;
 8035776:	4f47      	ldr	r7, [pc, #284]	; (8035894 <LoRaMacMcpsRequest+0x304>)
            MacCtx.TxMsg.Message.Data.MHDR.Value = macHdr->Value;
 8035778:	f884 3111 	strb.w	r3, [r4, #273]	; 0x111
            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_DATA;
 803577c:	2104      	movs	r1, #4
            MacCtx.TxMsg.Message.Data.FHDR.DevAddr = Nvm.MacGroup2.DevAddr;
 803577e:	f8d4 35d8 	ldr.w	r3, [r4, #1496]	; 0x5d8
            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_DATA;
 8035782:	f884 1108 	strb.w	r1, [r4, #264]	; 0x108
            MacCtx.TxMsg.Message.Data.FHDR.DevAddr = Nvm.MacGroup2.DevAddr;
 8035786:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
            MacCtx.TxMsg.Message.Data.BufSize = LORAMAC_PHY_MAXPAYLOAD;
 803578a:	21ff      	movs	r1, #255	; 0xff
            MacCtx.TxMsg.Message.Data.FRMPayload = MacCtx.AppData;
 803578c:	f507 739b 	add.w	r3, r7, #310	; 0x136
            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetFCntUp( &fCntUp ) )
 8035790:	a805      	add	r0, sp, #20
            MacCtx.TxMsg.Message.Data.Buffer = MacCtx.PktBuffer;
 8035792:	f8c4 710c 	str.w	r7, [r4, #268]	; 0x10c
            MacCtx.TxMsg.Message.Data.BufSize = LORAMAC_PHY_MAXPAYLOAD;
 8035796:	f884 1110 	strb.w	r1, [r4, #272]	; 0x110
            MacCtx.TxMsg.Message.Data.FPort = fPort;
 803579a:	f884 a12c 	strb.w	sl, [r4, #300]	; 0x12c
            MacCtx.TxMsg.Message.Data.FHDR.FCtrl.Value = fCtrl->Value;
 803579e:	f884 8118 	strb.w	r8, [r4, #280]	; 0x118
            MacCtx.TxMsg.Message.Data.FRMPayloadSize = MacCtx.AppDataSize;
 80357a2:	f884 2134 	strb.w	r2, [r4, #308]	; 0x134
            MacCtx.TxMsg.Message.Data.FRMPayload = MacCtx.AppData;
 80357a6:	f8c4 3130 	str.w	r3, [r4, #304]	; 0x130
            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetFCntUp( &fCntUp ) )
 80357aa:	f000 fc2b 	bl	8036004 <LoRaMacCryptoGetFCntUp>
 80357ae:	2800      	cmp	r0, #0
 80357b0:	d158      	bne.n	8035864 <LoRaMacMcpsRequest+0x2d4>
            MacCtx.TxMsg.Message.Data.FHDR.FCnt = ( uint16_t )fCntUp;
 80357b2:	9b05      	ldr	r3, [sp, #20]
            MacCtx.McpsConfirm.AckReceived = false;
 80357b4:	f8a4 0440 	strh.w	r0, [r4, #1088]	; 0x440
            if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )
 80357b8:	a806      	add	r0, sp, #24
            MacCtx.TxMsg.Message.Data.FHDR.FCnt = ( uint16_t )fCntUp;
 80357ba:	f8a4 311a 	strh.w	r3, [r4, #282]	; 0x11a
            MacCtx.McpsConfirm.UpLinkCounter = fCntUp;
 80357be:	f8c4 3448 	str.w	r3, [r4, #1096]	; 0x448
            if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )
 80357c2:	f000 f9bb 	bl	8035b3c <LoRaMacCommandsGetSizeSerializedCmds>
 80357c6:	bb68      	cbnz	r0, 8035824 <LoRaMacMcpsRequest+0x294>
            if( macCmdsSize > 0 )
 80357c8:	9b06      	ldr	r3, [sp, #24]
 80357ca:	b1ab      	cbz	r3, 80357f8 <LoRaMacMcpsRequest+0x268>
                availableSize = GetMaxAppPayloadWithoutFOptsLength( Nvm.MacGroup1.ChannelsDatarate );
 80357cc:	f994 0545 	ldrsb.w	r0, [r4, #1349]	; 0x545
 80357d0:	f7fd fc2a 	bl	8033028 <GetMaxAppPayloadWithoutFOptsLength>
                if( ( MacCtx.AppDataSize > 0 ) && ( macCmdsSize <= LORA_MAC_COMMAND_MAX_FOPTS_LENGTH ) )
 80357d4:	f894 323b 	ldrb.w	r3, [r4, #571]	; 0x23b
 80357d8:	b333      	cbz	r3, 8035828 <LoRaMacMcpsRequest+0x298>
 80357da:	9b06      	ldr	r3, [sp, #24]
 80357dc:	2b0f      	cmp	r3, #15
 80357de:	d81a      	bhi.n	8035816 <LoRaMacMcpsRequest+0x286>
                    if( LoRaMacCommandsSerializeCmds( LORA_MAC_COMMAND_MAX_FOPTS_LENGTH, &macCmdsSize, MacCtx.TxMsg.Message.Data.FHDR.FOpts ) != LORAMAC_COMMANDS_SUCCESS )
 80357e0:	f507 728b 	add.w	r2, r7, #278	; 0x116
 80357e4:	a906      	add	r1, sp, #24
 80357e6:	200f      	movs	r0, #15
 80357e8:	f000 f9b4 	bl	8035b54 <LoRaMacCommandsSerializeCmds>
 80357ec:	b9d0      	cbnz	r0, 8035824 <LoRaMacMcpsRequest+0x294>
                    fCtrl->Bits.FOptsLen = macCmdsSize;
 80357ee:	9b06      	ldr	r3, [sp, #24]
 80357f0:	f363 0803 	bfi	r8, r3, #0, #4
                    MacCtx.TxMsg.Message.Data.FHDR.FCtrl.Value = fCtrl->Value;
 80357f4:	f884 8118 	strb.w	r8, [r4, #280]	; 0x118
        status = ScheduleTx( allowDelayedTx ); /* ST_WORKAROUND: Update Send request with new input parameter to allow delayed tx */
 80357f8:	9801      	ldr	r0, [sp, #4]
 80357fa:	f7fd fde7 	bl	80333cc <ScheduleTx>
    if( status != LORAMAC_STATUS_OK )
 80357fe:	2800      	cmp	r0, #0
 8035800:	d18a      	bne.n	8035718 <LoRaMacMcpsRequest+0x188>
        Nvm.MacGroup1.AdrAckCounter = adrAckCounter;
 8035802:	9b04      	ldr	r3, [sp, #16]
        Nvm.MacGroup1.SrvAckRequested = false;
 8035804:	f884 0546 	strb.w	r0, [r4, #1350]	; 0x546
        Nvm.MacGroup1.AdrAckCounter = adrAckCounter;
 8035808:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
        if( LoRaMacCommandsRemoveNoneStickyCmds( ) != LORAMAC_COMMANDS_SUCCESS )
 803580c:	f000 f976 	bl	8035afc <LoRaMacCommandsRemoveNoneStickyCmds>
 8035810:	b380      	cbz	r0, 8035874 <LoRaMacMcpsRequest+0x2e4>
            return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 8035812:	2013      	movs	r0, #19
 8035814:	e783      	b.n	803571e <LoRaMacMcpsRequest+0x18e>
                    if( LoRaMacCommandsSerializeCmds( availableSize, &macCmdsSize, MacCtx.MacCommandsBuffer ) != LORAMAC_COMMANDS_SUCCESS )
 8035816:	f207 4286 	addw	r2, r7, #1158	; 0x486
 803581a:	a906      	add	r1, sp, #24
 803581c:	f000 f99a 	bl	8035b54 <LoRaMacCommandsSerializeCmds>
 8035820:	2800      	cmp	r0, #0
 8035822:	d0e9      	beq.n	80357f8 <LoRaMacMcpsRequest+0x268>
                        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 8035824:	2013      	movs	r0, #19
 8035826:	e777      	b.n	8035718 <LoRaMacMcpsRequest+0x188>
                    if( LoRaMacCommandsSerializeCmds( availableSize, &macCmdsSize, MacCtx.MacCommandsBuffer ) != LORAMAC_COMMANDS_SUCCESS )
 8035828:	f207 4786 	addw	r7, r7, #1158	; 0x486
 803582c:	463a      	mov	r2, r7
 803582e:	a906      	add	r1, sp, #24
 8035830:	f000 f990 	bl	8035b54 <LoRaMacCommandsSerializeCmds>
 8035834:	2800      	cmp	r0, #0
 8035836:	d1f5      	bne.n	8035824 <LoRaMacMcpsRequest+0x294>
                    MacCtx.TxMsg.Message.Data.FRMPayloadSize = macCmdsSize;
 8035838:	9b06      	ldr	r3, [sp, #24]
                    MacCtx.TxMsg.Message.Data.FPort = 0;
 803583a:	f884 012c 	strb.w	r0, [r4, #300]	; 0x12c
                    MacCtx.TxMsg.Message.Data.FRMPayload = MacCtx.MacCommandsBuffer;
 803583e:	f8c4 7130 	str.w	r7, [r4, #304]	; 0x130
                    MacCtx.TxMsg.Message.Data.FRMPayloadSize = macCmdsSize;
 8035842:	f884 3134 	strb.w	r3, [r4, #308]	; 0x134
    if( ( status == LORAMAC_STATUS_OK ) || ( status == LORAMAC_STATUS_SKIPPED_APP_DATA ) )
 8035846:	e7d7      	b.n	80357f8 <LoRaMacMcpsRequest+0x268>
            if( ( fBuffer != NULL ) && ( MacCtx.AppDataSize > 0 ) )
 8035848:	f1b9 0f00 	cmp.w	r9, #0
 803584c:	d0d4      	beq.n	80357f8 <LoRaMacMcpsRequest+0x268>
 803584e:	2a00      	cmp	r2, #0
 8035850:	d0d2      	beq.n	80357f8 <LoRaMacMcpsRequest+0x268>
                memcpy1( MacCtx.PktBuffer + LORAMAC_MHDR_FIELD_SIZE, ( uint8_t* ) fBuffer, MacCtx.AppDataSize );
 8035852:	4811      	ldr	r0, [pc, #68]	; (8035898 <LoRaMacMcpsRequest+0x308>)
 8035854:	4649      	mov	r1, r9
 8035856:	f003 fb6b 	bl	8038f30 <memcpy1>
                MacCtx.PktBufferLen = LORAMAC_MHDR_FIELD_SIZE + MacCtx.AppDataSize;
 803585a:	f894 323b 	ldrb.w	r3, [r4, #571]	; 0x23b
 803585e:	3301      	adds	r3, #1
 8035860:	80a3      	strh	r3, [r4, #4]
    if( ( status == LORAMAC_STATUS_OK ) || ( status == LORAMAC_STATUS_SKIPPED_APP_DATA ) )
 8035862:	e7c9      	b.n	80357f8 <LoRaMacMcpsRequest+0x268>
                return LORAMAC_STATUS_FCNT_HANDLER_ERROR;
 8035864:	2012      	movs	r0, #18
 8035866:	e757      	b.n	8035718 <LoRaMacMcpsRequest+0x188>
        return LORAMAC_STATUS_NO_NETWORK_JOINED;
 8035868:	2007      	movs	r0, #7
 803586a:	e758      	b.n	803571e <LoRaMacMcpsRequest+0x18e>
    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;
 803586c:	4618      	mov	r0, r3
 803586e:	e759      	b.n	8035724 <LoRaMacMcpsRequest+0x194>
        return LORAMAC_STATUS_BUSY;
 8035870:	2001      	movs	r0, #1
 8035872:	e695      	b.n	80355a0 <LoRaMacMcpsRequest+0x10>
            MacCtx.McpsConfirm.McpsRequest = mcpsRequest->Type;
 8035874:	782b      	ldrb	r3, [r5, #0]
 8035876:	f884 343c 	strb.w	r3, [r4, #1084]	; 0x43c
            MacCtx.MacFlags.Bits.McpsReq = 1;
 803587a:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 803587e:	f043 0301 	orr.w	r3, r3, #1
 8035882:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
 8035886:	e74d      	b.n	8035724 <LoRaMacMcpsRequest+0x194>
 8035888:	20004aa4 	.word	0x20004aa4
 803588c:	20004fe8 	.word	0x20004fe8
 8035890:	20004be0 	.word	0x20004be0
 8035894:	20004aaa 	.word	0x20004aaa
 8035898:	20004aab 	.word	0x20004aab

0803589c <LoRaMacTestSetDutyCycleOn>:
/* ST_WORKAROUND_END */

void LoRaMacTestSetDutyCycleOn( bool enable )
{
 803589c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    VerifyParams_t verify;

    verify.DutyCycle = enable;

    if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DUTY_CYCLE ) == true )
 803589e:	4d07      	ldr	r5, [pc, #28]	; (80358bc <LoRaMacTestSetDutyCycleOn+0x20>)
    verify.DutyCycle = enable;
 80358a0:	f88d 0004 	strb.w	r0, [sp, #4]
{
 80358a4:	4604      	mov	r4, r0
    if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DUTY_CYCLE ) == true )
 80358a6:	220f      	movs	r2, #15
 80358a8:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
 80358ac:	a901      	add	r1, sp, #4
 80358ae:	f000 ff5e 	bl	803676e <RegionVerify>
 80358b2:	b108      	cbz	r0, 80358b8 <LoRaMacTestSetDutyCycleOn+0x1c>
    {
        Nvm.MacGroup2.DutyCycleOn = enable;
 80358b4:	f885 460c 	strb.w	r4, [r5, #1548]	; 0x60c
    }
}
 80358b8:	b003      	add	sp, #12
 80358ba:	bd30      	pop	{r4, r5, pc}
 80358bc:	20004aa4 	.word	0x20004aa4

080358c0 <LoRaMacAdrCalcNext>:
 * \param [OUT] adrAckCounter The calculated ADR acknowledgement counter.
 *
 * \retval Returns true, if an ADR request should be performed.
 */
bool LoRaMacAdrCalcNext( CalcNextAdrParams_t* adrNext, int8_t* drOut, int8_t* txPowOut, uint32_t* adrAckCounter )
{
 80358c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if( adrNext->Version.Fields.Minor == 0 )
 80358c4:	f890 9002 	ldrb.w	r9, [r0, #2]
{
 80358c8:	b08b      	sub	sp, #44	; 0x2c
 80358ca:	4604      	mov	r4, r0
 80358cc:	468a      	mov	sl, r1
 80358ce:	9201      	str	r2, [sp, #4]
    if( adrNext->Version.Fields.Minor == 0 )
 80358d0:	f1b9 0f00 	cmp.w	r9, #0
 80358d4:	d160      	bne.n	8035998 <LoRaMacAdrCalcNext+0xd8>
    if( adrNext->AdrEnabled == true )
 80358d6:	7945      	ldrb	r5, [r0, #5]
    *adrAckCounter = adrNext->AdrAckCounter;
 80358d8:	6881      	ldr	r1, [r0, #8]
    int8_t datarate = adrNext->Datarate;
 80358da:	f990 2010 	ldrsb.w	r2, [r0, #16]
    int8_t txPower = adrNext->TxPower;
 80358de:	f990 8011 	ldrsb.w	r8, [r0, #17]
    *adrAckCounter = adrNext->AdrAckCounter;
 80358e2:	6019      	str	r1, [r3, #0]
    if( adrNext->AdrEnabled == true )
 80358e4:	2d00      	cmp	r5, #0
 80358e6:	d055      	beq.n	8035994 <LoRaMacAdrCalcNext+0xd4>
        getPhy.UplinkDwellTime = adrNext->UplinkDwellTime;
 80358e8:	7c81      	ldrb	r1, [r0, #18]
 80358ea:	f88d 1016 	strb.w	r1, [sp, #22]
        phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 80358ee:	7cc0      	ldrb	r0, [r0, #19]
        getPhy.Attribute = PHY_MIN_TX_DR;
 80358f0:	f04f 0b02 	mov.w	fp, #2
        phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 80358f4:	a905      	add	r1, sp, #20
 80358f6:	e9cd 2302 	strd	r2, r3, [sp, #8]
        getPhy.Attribute = PHY_MIN_TX_DR;
 80358fa:	f88d b014 	strb.w	fp, [sp, #20]
        phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 80358fe:	f000 ff10 	bl	8036722 <RegionGetPhyParam>
        datarate = MAX( datarate, minTxDatarate );
 8035902:	9a02      	ldr	r2, [sp, #8]
        minTxDatarate = phyParam.Value;
 8035904:	b247      	sxtb	r7, r0
        datarate = MAX( datarate, minTxDatarate );
 8035906:	42ba      	cmp	r2, r7
 8035908:	4616      	mov	r6, r2
 803590a:	bfb8      	it	lt
 803590c:	463e      	movlt	r6, r7
        if( datarate == minTxDatarate )
 803590e:	42ba      	cmp	r2, r7
 8035910:	dc0c      	bgt.n	803592c <LoRaMacAdrCalcNext+0x6c>
            *adrAckCounter = 0;
 8035912:	9b03      	ldr	r3, [sp, #12]
 8035914:	f8c3 9000 	str.w	r9, [r3]
                        adrAckReq = false;
 8035918:	464d      	mov	r5, r9
    *txPowOut = txPower;
 803591a:	9b01      	ldr	r3, [sp, #4]
    *drOut = datarate;
 803591c:	f88a 6000 	strb.w	r6, [sl]
    *txPowOut = txPower;
 8035920:	f883 8000 	strb.w	r8, [r3]
    {
        return CalcNextV10X( adrNext, drOut, txPowOut, adrAckCounter );
    }
    return false;
}
 8035924:	4628      	mov	r0, r5
 8035926:	b00b      	add	sp, #44	; 0x2c
 8035928:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            if( adrNext->AdrAckCounter >=  adrNext->AdrAckLimit )
 803592c:	68a2      	ldr	r2, [r4, #8]
 803592e:	89a1      	ldrh	r1, [r4, #12]
            if( adrNext->AdrAckCounter >= ( adrNext->AdrAckLimit + adrNext->AdrAckDelay ) )
 8035930:	89e3      	ldrh	r3, [r4, #14]
            if( adrNext->AdrAckCounter >=  adrNext->AdrAckLimit )
 8035932:	428a      	cmp	r2, r1
            if( adrNext->AdrAckCounter >= ( adrNext->AdrAckLimit + adrNext->AdrAckDelay ) )
 8035934:	440b      	add	r3, r1
            if( adrNext->AdrAckCounter >=  adrNext->AdrAckLimit )
 8035936:	bf34      	ite	cc
 8035938:	2500      	movcc	r5, #0
 803593a:	2501      	movcs	r5, #1
            if( adrNext->AdrAckCounter >= ( adrNext->AdrAckLimit + adrNext->AdrAckDelay ) )
 803593c:	429a      	cmp	r2, r3
 803593e:	d3ec      	bcc.n	803591a <LoRaMacAdrCalcNext+0x5a>
                getPhy.Attribute = PHY_MAX_TX_POWER;
 8035940:	2308      	movs	r3, #8
                phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 8035942:	a905      	add	r1, sp, #20
 8035944:	7ce0      	ldrb	r0, [r4, #19]
                getPhy.Attribute = PHY_MAX_TX_POWER;
 8035946:	f88d 3014 	strb.w	r3, [sp, #20]
                phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 803594a:	f000 feea 	bl	8036722 <RegionGetPhyParam>
                if( ( adrNext->AdrAckCounter % adrNext->AdrAckDelay ) == 1 )
 803594e:	89e2      	ldrh	r2, [r4, #14]
 8035950:	68a1      	ldr	r1, [r4, #8]
 8035952:	fbb1 f3f2 	udiv	r3, r1, r2
 8035956:	fb02 1313 	mls	r3, r2, r3, r1
 803595a:	2b01      	cmp	r3, #1
                txPower = phyParam.Value;
 803595c:	fa4f f880 	sxtb.w	r8, r0
                if( ( adrNext->AdrAckCounter % adrNext->AdrAckDelay ) == 1 )
 8035960:	d1db      	bne.n	803591a <LoRaMacAdrCalcNext+0x5a>
                    getPhy.Attribute = PHY_NEXT_LOWER_TX_DR;
 8035962:	2322      	movs	r3, #34	; 0x22
 8035964:	f88d 3014 	strb.w	r3, [sp, #20]
                    phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 8035968:	7ce0      	ldrb	r0, [r4, #19]
                    getPhy.UplinkDwellTime = adrNext->UplinkDwellTime;
 803596a:	7ca3      	ldrb	r3, [r4, #18]
                    getPhy.Datarate = datarate;
 803596c:	f88d 6015 	strb.w	r6, [sp, #21]
                    phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 8035970:	a905      	add	r1, sp, #20
                    getPhy.UplinkDwellTime = adrNext->UplinkDwellTime;
 8035972:	f88d 3016 	strb.w	r3, [sp, #22]
                    phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 8035976:	f000 fed4 	bl	8036722 <RegionGetPhyParam>
                    datarate = phyParam.Value;
 803597a:	b246      	sxtb	r6, r0
                    if( datarate == minTxDatarate )
 803597c:	42b7      	cmp	r7, r6
 803597e:	d1cc      	bne.n	803591a <LoRaMacAdrCalcNext+0x5a>
                        if( adrNext->UpdateChanMask == true )
 8035980:	7925      	ldrb	r5, [r4, #4]
 8035982:	2d00      	cmp	r5, #0
 8035984:	d0c9      	beq.n	803591a <LoRaMacAdrCalcNext+0x5a>
                            RegionInitDefaults( adrNext->Region, &params );
 8035986:	7ce0      	ldrb	r0, [r4, #19]
                            params.Type = INIT_TYPE_ACTIVATE_DEFAULT_CHANNELS;
 8035988:	f88d b024 	strb.w	fp, [sp, #36]	; 0x24
                            RegionInitDefaults( adrNext->Region, &params );
 803598c:	a907      	add	r1, sp, #28
 803598e:	f000 fee3 	bl	8036758 <RegionInitDefaults>
 8035992:	e7c1      	b.n	8035918 <LoRaMacAdrCalcNext+0x58>
    int8_t datarate = adrNext->Datarate;
 8035994:	4616      	mov	r6, r2
 8035996:	e7c0      	b.n	803591a <LoRaMacAdrCalcNext+0x5a>
    return false;
 8035998:	2500      	movs	r5, #0
 803599a:	e7c3      	b.n	8035924 <LoRaMacAdrCalcNext+0x64>

0803599c <LoRaMacClassBInit>:
    TimerInit( &Ctx.PingSlotTimer, LoRaMacClassBPingSlotTimerEvent );
    TimerInit( &Ctx.MulticastSlotTimer, LoRaMacClassBMulticastSlotTimerEvent );

    InitClassB( );
#endif /* LORAMAC_CLASSB_ENABLED */
}
 803599c:	4770      	bx	lr

0803599e <LoRaMacClassBSetBeaconState>:
        {
            Ctx.BeaconState = beaconState;
        }
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 803599e:	4770      	bx	lr

080359a0 <LoRaMacClassBSetPingSlotState>:
 80359a0:	4770      	bx	lr

080359a2 <LoRaMacClassBSetMulticastSlotState>:
 80359a2:	4770      	bx	lr

080359a4 <LoRaMacClassBIsAcquisitionInProgress>:
    }
    return false;
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 80359a4:	2000      	movs	r0, #0
 80359a6:	4770      	bx	lr

080359a8 <LoRaMacClassBBeaconTimerEvent>:
    if( Ctx.LoRaMacClassBCallbacks.MacProcessNotify != NULL )
    {
        Ctx.LoRaMacClassBCallbacks.MacProcessNotify( );
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 80359a8:	4770      	bx	lr

080359aa <LoRaMacClassBPingSlotTimerEvent>:
 80359aa:	4770      	bx	lr

080359ac <LoRaMacClassBMulticastSlotTimerEvent>:
 80359ac:	4770      	bx	lr

080359ae <LoRaMacClassBRxBeacon>:
    }
    return beaconProcessed;
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 80359ae:	2000      	movs	r0, #0
 80359b0:	4770      	bx	lr

080359b2 <LoRaMacClassBIsBeaconExpected>:
 80359b2:	2000      	movs	r0, #0
 80359b4:	4770      	bx	lr

080359b6 <LoRaMacClassBIsPingExpected>:
 80359b6:	2000      	movs	r0, #0
 80359b8:	4770      	bx	lr

080359ba <LoRaMacClassBIsMulticastExpected>:
 80359ba:	2000      	movs	r0, #0
 80359bc:	4770      	bx	lr

080359be <LoRaMacClassBIsBeaconModeActive>:
 80359be:	2000      	movs	r0, #0
 80359c0:	4770      	bx	lr

080359c2 <LoRaMacClassBSetPingSlotInfo>:
 80359c2:	4770      	bx	lr

080359c4 <LoRaMacClassBHaltBeaconing>:

        // Halt ping and multicast slot state machines
        LoRaMacClassBStopRxSlots( );
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 80359c4:	4770      	bx	lr

080359c6 <LoRaMacClassBResumeBeaconing>:
 80359c6:	4770      	bx	lr

080359c8 <LoRaMacClassBSwitchClass>:
    }
    return LORAMAC_STATUS_SERVICE_UNKNOWN;
#else
    return LORAMAC_STATUS_SERVICE_UNKNOWN;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 80359c8:	2002      	movs	r0, #2
 80359ca:	4770      	bx	lr

080359cc <LoRaMacClassBMibGetRequestConfirm>:
    }
    return status;
#else
    return LORAMAC_STATUS_SERVICE_UNKNOWN;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 80359cc:	2002      	movs	r0, #2
 80359ce:	4770      	bx	lr

080359d0 <LoRaMacMibClassBSetRequestConfirm>:
 80359d0:	2002      	movs	r0, #2
 80359d2:	4770      	bx	lr

080359d4 <LoRaMacClassBPingSlotInfoAns>:
 80359d4:	4770      	bx	lr

080359d6 <LoRaMacClassBPingSlotChannelReq>:

    return status;
#else
    return 0;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 80359d6:	2000      	movs	r0, #0
 80359d8:	4770      	bx	lr

080359da <LoRaMacClassBBeaconTimingAns>:

        Ctx.LoRaMacClassBParams.MlmeConfirm->BeaconTimingDelay = Ctx.BeaconCtx.BeaconTimingDelay;
        Ctx.LoRaMacClassBParams.MlmeConfirm->BeaconTimingChannel = Ctx.BeaconCtx.BeaconTimingChannel;
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 80359da:	4770      	bx	lr

080359dc <LoRaMacClassBDeviceTimeAns>:
 80359dc:	4770      	bx	lr

080359de <LoRaMacClassBBeaconFreqReq>:
    }
    return false;
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 80359de:	2000      	movs	r0, #0
 80359e0:	4770      	bx	lr

080359e2 <LoRaMacClassBIsUplinkCollision>:
    }
    return 0;
#else
    return 0;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 80359e2:	2000      	movs	r0, #0
 80359e4:	4770      	bx	lr

080359e6 <LoRaMacClassBStopRxSlots>:
 80359e6:	4770      	bx	lr

080359e8 <LoRaMacClassBSetMulticastPeriodicity>:
 80359e8:	4770      	bx	lr

080359ea <LoRaMacClassBProcess>:
 80359ea:	4770      	bx	lr

080359ec <LoRaMacCommandsInit>:
            return false;
    }
}

LoRaMacCommandStatus_t LoRaMacCommandsInit( void )
{
 80359ec:	b510      	push	{r4, lr}
    // Initialize with default
    memset1( ( uint8_t* )&CommandsCtx, 0, sizeof( CommandsCtx ) );
 80359ee:	4c05      	ldr	r4, [pc, #20]	; (8035a04 <LoRaMacCommandsInit+0x18>)
 80359f0:	22fc      	movs	r2, #252	; 0xfc
 80359f2:	4620      	mov	r0, r4
 80359f4:	2100      	movs	r1, #0
 80359f6:	f003 faaf 	bl	8038f58 <memset1>
    list->First = NULL;
 80359fa:	2000      	movs	r0, #0
    list->Last = NULL;
 80359fc:	e9c4 0000 	strd	r0, r0, [r4]

    LinkedListInit( &CommandsCtx.MacCommandList );

    return LORAMAC_COMMANDS_SUCCESS;
}
 8035a00:	bd10      	pop	{r4, pc}
 8035a02:	bf00      	nop
 8035a04:	20005604 	.word	0x20005604

08035a08 <LoRaMacCommandsAddCmd>:

LoRaMacCommandStatus_t LoRaMacCommandsAddCmd( uint8_t cid, uint8_t* payload, size_t payloadSize )
{
 8035a08:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8035a0c:	4680      	mov	r8, r0
 8035a0e:	4616      	mov	r6, r2
    if( payload == NULL )
 8035a10:	2900      	cmp	r1, #0
 8035a12:	d03d      	beq.n	8035a90 <LoRaMacCommandsAddCmd+0x88>
 8035a14:	4c22      	ldr	r4, [pc, #136]	; (8035aa0 <LoRaMacCommandsAddCmd+0x98>)
 8035a16:	2300      	movs	r3, #0
    while( IsSlotFree( ( const MacCommand_t* )&CommandsCtx.MacCommandSlots[itr] ) == false )
 8035a18:	1c65      	adds	r5, r4, #1
 8035a1a:	4622      	mov	r2, r4
 8035a1c:	0118      	lsls	r0, r3, #4
 8035a1e:	3410      	adds	r4, #16
        if( mem[size] != 0x00 )
 8035a20:	f812 7f01 	ldrb.w	r7, [r2, #1]!
 8035a24:	bbb7      	cbnz	r7, 8035a94 <LoRaMacCommandsAddCmd+0x8c>
    for( uint16_t size = 0; size < sizeof( MacCommand_t ); size++ )
 8035a26:	42a2      	cmp	r2, r4
 8035a28:	d1fa      	bne.n	8035a20 <LoRaMacCommandsAddCmd+0x18>
    if( list->First == NULL )
 8035a2a:	4c1e      	ldr	r4, [pc, #120]	; (8035aa4 <LoRaMacCommandsAddCmd+0x9c>)
 8035a2c:	6822      	ldr	r2, [r4, #0]
 8035a2e:	b902      	cbnz	r2, 8035a32 <LoRaMacCommandsAddCmd+0x2a>
        list->First = element;
 8035a30:	6025      	str	r5, [r4, #0]
    if( list->Last )
 8035a32:	6862      	ldr	r2, [r4, #4]
 8035a34:	b102      	cbz	r2, 8035a38 <LoRaMacCommandsAddCmd+0x30>
        list->Last->Next = element;
 8035a36:	6015      	str	r5, [r2, #0]
    list->Last = element;
 8035a38:	6065      	str	r5, [r4, #4]
        return LORAMAC_COMMANDS_ERROR;
    }

    // Set Values
    newCmd->CID = cid;
    newCmd->PayloadSize = payloadSize;
 8035a3a:	1c5d      	adds	r5, r3, #1
    element->Next = NULL;
 8035a3c:	1822      	adds	r2, r4, r0
    newCmd->PayloadSize = payloadSize;
 8035a3e:	012b      	lsls	r3, r5, #4
    element->Next = NULL;
 8035a40:	f04f 0c00 	mov.w	ip, #0
    memcpy1( ( uint8_t* )newCmd->Payload, payload, payloadSize );
 8035a44:	300d      	adds	r0, #13
    element->Next = NULL;
 8035a46:	f8c2 c008 	str.w	ip, [r2, #8]
    newCmd->CID = cid;
 8035a4a:	f882 800c 	strb.w	r8, [r2, #12]
    newCmd->PayloadSize = payloadSize;
 8035a4e:	50e6      	str	r6, [r4, r3]
    memcpy1( ( uint8_t* )newCmd->Payload, payload, payloadSize );
 8035a50:	b2b2      	uxth	r2, r6
 8035a52:	4420      	add	r0, r4
 8035a54:	f003 fa6c 	bl	8038f30 <memcpy1>
    switch( cid )
 8035a58:	f1b8 0f05 	cmp.w	r8, #5
 8035a5c:	d015      	beq.n	8035a8a <LoRaMacCommandsAddCmd+0x82>
 8035a5e:	f1a8 0808 	sub.w	r8, r8, #8
 8035a62:	f1b8 0f02 	cmp.w	r8, #2
 8035a66:	bf8c      	ite	hi
 8035a68:	f04f 0800 	movhi.w	r8, #0
 8035a6c:	f04f 0801 	movls.w	r8, #1
    newCmd->IsSticky = IsSticky( cid );
 8035a70:	eb04 1305 	add.w	r3, r4, r5, lsl #4
 8035a74:	f883 8004 	strb.w	r8, [r3, #4]

    CommandsCtx.SerializedCmdsSize += ( CID_FIELD_SIZE + payloadSize );
 8035a78:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
 8035a7c:	3301      	adds	r3, #1
 8035a7e:	4433      	add	r3, r6
 8035a80:	f8c4 30f8 	str.w	r3, [r4, #248]	; 0xf8

    return LORAMAC_COMMANDS_SUCCESS;
}
 8035a84:	4638      	mov	r0, r7
 8035a86:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            return true;
 8035a8a:	f04f 0801 	mov.w	r8, #1
 8035a8e:	e7ef      	b.n	8035a70 <LoRaMacCommandsAddCmd+0x68>
        return LORAMAC_COMMANDS_ERROR_NPE;
 8035a90:	2701      	movs	r7, #1
 8035a92:	e7f7      	b.n	8035a84 <LoRaMacCommandsAddCmd+0x7c>
        if( itr == NUM_OF_MAC_COMMANDS )
 8035a94:	3301      	adds	r3, #1
 8035a96:	2b0f      	cmp	r3, #15
 8035a98:	d1be      	bne.n	8035a18 <LoRaMacCommandsAddCmd+0x10>
        return LORAMAC_COMMANDS_ERROR_MEMORY;
 8035a9a:	2702      	movs	r7, #2
 8035a9c:	e7f2      	b.n	8035a84 <LoRaMacCommandsAddCmd+0x7c>
 8035a9e:	bf00      	nop
 8035aa0:	2000560b 	.word	0x2000560b
 8035aa4:	20005604 	.word	0x20005604

08035aa8 <LoRaMacCommandsRemoveCmd>:

LoRaMacCommandStatus_t LoRaMacCommandsRemoveCmd( MacCommand_t* macCmd )
{
 8035aa8:	b510      	push	{r4, lr}
    if( macCmd == NULL )
 8035aaa:	b310      	cbz	r0, 8035af2 <LoRaMacCommandsRemoveCmd+0x4a>
    curElement = list->First;
 8035aac:	4b12      	ldr	r3, [pc, #72]	; (8035af8 <LoRaMacCommandsRemoveCmd+0x50>)
 8035aae:	681a      	ldr	r2, [r3, #0]
    if( element != curElement )
 8035ab0:	4290      	cmp	r0, r2
 8035ab2:	d104      	bne.n	8035abe <LoRaMacCommandsRemoveCmd+0x16>
        list->First = element->Next;
 8035ab4:	6802      	ldr	r2, [r0, #0]
 8035ab6:	601a      	str	r2, [r3, #0]
 8035ab8:	2200      	movs	r2, #0
 8035aba:	e004      	b.n	8035ac6 <LoRaMacCommandsRemoveCmd+0x1e>
 8035abc:	460a      	mov	r2, r1
        while( ( curElement != NULL ) && ( curElement->Next != element ) )
 8035abe:	b112      	cbz	r2, 8035ac6 <LoRaMacCommandsRemoveCmd+0x1e>
 8035ac0:	6811      	ldr	r1, [r2, #0]
 8035ac2:	4288      	cmp	r0, r1
 8035ac4:	d1fa      	bne.n	8035abc <LoRaMacCommandsRemoveCmd+0x14>
    if( list->Last == element )
 8035ac6:	6859      	ldr	r1, [r3, #4]
 8035ac8:	4288      	cmp	r0, r1
        list->Last = PrevElement;
 8035aca:	bf08      	it	eq
 8035acc:	605a      	streq	r2, [r3, #4]
    if( PrevElement != NULL )
 8035ace:	b10a      	cbz	r2, 8035ad4 <LoRaMacCommandsRemoveCmd+0x2c>
        PrevElement->Next = element->Next;
 8035ad0:	6801      	ldr	r1, [r0, #0]
 8035ad2:	6011      	str	r1, [r2, #0]
    if( LinkedListRemove( &CommandsCtx.MacCommandList, macCmd ) == false )
    {
        return LORAMAC_COMMANDS_ERROR_CMD_NOT_FOUND;
    }

    CommandsCtx.SerializedCmdsSize -= ( CID_FIELD_SIZE + macCmd->PayloadSize );
 8035ad4:	f8d3 20f8 	ldr.w	r2, [r3, #248]	; 0xf8
 8035ad8:	6881      	ldr	r1, [r0, #8]
 8035ada:	3a01      	subs	r2, #1
    element->Next = NULL;
 8035adc:	2400      	movs	r4, #0
    CommandsCtx.SerializedCmdsSize -= ( CID_FIELD_SIZE + macCmd->PayloadSize );
 8035ade:	1a52      	subs	r2, r2, r1
    element->Next = NULL;
 8035ae0:	6004      	str	r4, [r0, #0]
    memset1( ( uint8_t* )slot, 0x00, sizeof( MacCommand_t ) );
 8035ae2:	4621      	mov	r1, r4
    CommandsCtx.SerializedCmdsSize -= ( CID_FIELD_SIZE + macCmd->PayloadSize );
 8035ae4:	f8c3 20f8 	str.w	r2, [r3, #248]	; 0xf8
    memset1( ( uint8_t* )slot, 0x00, sizeof( MacCommand_t ) );
 8035ae8:	2210      	movs	r2, #16
 8035aea:	f003 fa35 	bl	8038f58 <memset1>
    return true;
 8035aee:	4620      	mov	r0, r4
    {
        return LORAMAC_COMMANDS_ERROR;
    }

    return LORAMAC_COMMANDS_SUCCESS;
}
 8035af0:	bd10      	pop	{r4, pc}
        return LORAMAC_COMMANDS_ERROR_NPE;
 8035af2:	2001      	movs	r0, #1
 8035af4:	e7fc      	b.n	8035af0 <LoRaMacCommandsRemoveCmd+0x48>
 8035af6:	bf00      	nop
 8035af8:	20005604 	.word	0x20005604

08035afc <LoRaMacCommandsRemoveNoneStickyCmds>:
    }
    return LORAMAC_COMMANDS_SUCCESS;
}

LoRaMacCommandStatus_t LoRaMacCommandsRemoveNoneStickyCmds( void )
{
 8035afc:	b510      	push	{r4, lr}
    MacCommand_t* curElement;
    MacCommand_t* nexElement;

    // Start at the head of the list
    curElement = CommandsCtx.MacCommandList.First;
 8035afe:	4b05      	ldr	r3, [pc, #20]	; (8035b14 <LoRaMacCommandsRemoveNoneStickyCmds+0x18>)
 8035b00:	6818      	ldr	r0, [r3, #0]

    // Loop through all elements
    while( curElement != NULL )
 8035b02:	b900      	cbnz	r0, 8035b06 <LoRaMacCommandsRemoveNoneStickyCmds+0xa>
            curElement = curElement->Next;
        }
    }

    return LORAMAC_COMMANDS_SUCCESS;
}
 8035b04:	bd10      	pop	{r4, pc}
        if( curElement->IsSticky == false )
 8035b06:	7b03      	ldrb	r3, [r0, #12]
 8035b08:	6804      	ldr	r4, [r0, #0]
 8035b0a:	b90b      	cbnz	r3, 8035b10 <LoRaMacCommandsRemoveNoneStickyCmds+0x14>
            LoRaMacCommandsRemoveCmd( curElement );
 8035b0c:	f7ff ffcc 	bl	8035aa8 <LoRaMacCommandsRemoveCmd>
{
 8035b10:	4620      	mov	r0, r4
 8035b12:	e7f6      	b.n	8035b02 <LoRaMacCommandsRemoveNoneStickyCmds+0x6>
 8035b14:	20005604 	.word	0x20005604

08035b18 <LoRaMacCommandsRemoveStickyAnsCmds>:

LoRaMacCommandStatus_t LoRaMacCommandsRemoveStickyAnsCmds( void )
{
 8035b18:	b510      	push	{r4, lr}
    MacCommand_t* curElement;
    MacCommand_t* nexElement;

    // Start at the head of the list
    curElement = CommandsCtx.MacCommandList.First;
 8035b1a:	4b07      	ldr	r3, [pc, #28]	; (8035b38 <LoRaMacCommandsRemoveStickyAnsCmds+0x20>)
 8035b1c:	6818      	ldr	r0, [r3, #0]

    // Loop through all elements
    while( curElement != NULL )
 8035b1e:	b900      	cbnz	r0, 8035b22 <LoRaMacCommandsRemoveStickyAnsCmds+0xa>
        }
        curElement = nexElement;
    }

    return LORAMAC_COMMANDS_SUCCESS;
}
 8035b20:	bd10      	pop	{r4, pc}
        if( IsSticky( curElement->CID ) == true )
 8035b22:	7903      	ldrb	r3, [r0, #4]
        nexElement = curElement->Next;
 8035b24:	6804      	ldr	r4, [r0, #0]
    switch( cid )
 8035b26:	2b05      	cmp	r3, #5
 8035b28:	d002      	beq.n	8035b30 <LoRaMacCommandsRemoveStickyAnsCmds+0x18>
 8035b2a:	3b08      	subs	r3, #8
 8035b2c:	2b02      	cmp	r3, #2
 8035b2e:	d801      	bhi.n	8035b34 <LoRaMacCommandsRemoveStickyAnsCmds+0x1c>
            LoRaMacCommandsRemoveCmd( curElement );
 8035b30:	f7ff ffba 	bl	8035aa8 <LoRaMacCommandsRemoveCmd>
{
 8035b34:	4620      	mov	r0, r4
 8035b36:	e7f2      	b.n	8035b1e <LoRaMacCommandsRemoveStickyAnsCmds+0x6>
 8035b38:	20005604 	.word	0x20005604

08035b3c <LoRaMacCommandsGetSizeSerializedCmds>:

LoRaMacCommandStatus_t LoRaMacCommandsGetSizeSerializedCmds( size_t* size )
{
    if( size == NULL )
 8035b3c:	b128      	cbz	r0, 8035b4a <LoRaMacCommandsGetSizeSerializedCmds+0xe>
    {
        return LORAMAC_COMMANDS_ERROR_NPE;
    }
    *size = CommandsCtx.SerializedCmdsSize;
 8035b3e:	4b04      	ldr	r3, [pc, #16]	; (8035b50 <LoRaMacCommandsGetSizeSerializedCmds+0x14>)
 8035b40:	f8d3 30f8 	ldr.w	r3, [r3, #248]	; 0xf8
 8035b44:	6003      	str	r3, [r0, #0]
    return LORAMAC_COMMANDS_SUCCESS;
 8035b46:	2000      	movs	r0, #0
 8035b48:	4770      	bx	lr
        return LORAMAC_COMMANDS_ERROR_NPE;
 8035b4a:	2001      	movs	r0, #1
}
 8035b4c:	4770      	bx	lr
 8035b4e:	bf00      	nop
 8035b50:	20005604 	.word	0x20005604

08035b54 <LoRaMacCommandsSerializeCmds>:

LoRaMacCommandStatus_t LoRaMacCommandsSerializeCmds( size_t availableSize, size_t* effectiveSize, uint8_t* buffer )
{
 8035b54:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8035b58:	4607      	mov	r7, r0
 8035b5a:	460e      	mov	r6, r1
    MacCommand_t* curElement = CommandsCtx.MacCommandList.First;
    MacCommand_t* nextElement;
    uint8_t itr = 0;

    if( ( buffer == NULL ) || ( effectiveSize == NULL ) )
 8035b5c:	4615      	mov	r5, r2
 8035b5e:	b332      	cbz	r2, 8035bae <LoRaMacCommandsSerializeCmds+0x5a>
 8035b60:	b329      	cbz	r1, 8035bae <LoRaMacCommandsSerializeCmds+0x5a>
    MacCommand_t* curElement = CommandsCtx.MacCommandList.First;
 8035b62:	4b14      	ldr	r3, [pc, #80]	; (8035bb4 <LoRaMacCommandsSerializeCmds+0x60>)
 8035b64:	681c      	ldr	r4, [r3, #0]
    uint8_t itr = 0;
 8035b66:	2300      	movs	r3, #0
    {
        return LORAMAC_COMMANDS_ERROR_NPE;
    }

    // Loop through all elements which fits into the buffer
    while( curElement != NULL )
 8035b68:	b92c      	cbnz	r4, 8035b76 <LoRaMacCommandsSerializeCmds+0x22>
        LoRaMacCommandsRemoveCmd( curElement );
        curElement = nextElement;
    }

    // Fetch the effective size of the mac commands
    LoRaMacCommandsGetSizeSerializedCmds( effectiveSize );
 8035b6a:	4630      	mov	r0, r6
 8035b6c:	f7ff ffe6 	bl	8035b3c <LoRaMacCommandsGetSizeSerializedCmds>

    return LORAMAC_COMMANDS_SUCCESS;
 8035b70:	2000      	movs	r0, #0
}
 8035b72:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if( ( availableSize - itr ) >= ( CID_FIELD_SIZE + curElement->PayloadSize ) )
 8035b76:	68a2      	ldr	r2, [r4, #8]
 8035b78:	1af9      	subs	r1, r7, r3
 8035b7a:	3201      	adds	r2, #1
 8035b7c:	4291      	cmp	r1, r2
 8035b7e:	d30f      	bcc.n	8035ba0 <LoRaMacCommandsSerializeCmds+0x4c>
            buffer[itr++] = curElement->CID;
 8035b80:	7922      	ldrb	r2, [r4, #4]
 8035b82:	54ea      	strb	r2, [r5, r3]
 8035b84:	1c58      	adds	r0, r3, #1
            memcpy1( &buffer[itr], curElement->Payload, curElement->PayloadSize );
 8035b86:	8922      	ldrh	r2, [r4, #8]
            buffer[itr++] = curElement->CID;
 8035b88:	fa5f f880 	uxtb.w	r8, r0
            memcpy1( &buffer[itr], curElement->Payload, curElement->PayloadSize );
 8035b8c:	1d61      	adds	r1, r4, #5
 8035b8e:	fa55 f080 	uxtab	r0, r5, r0
 8035b92:	f003 f9cd 	bl	8038f30 <memcpy1>
            itr += curElement->PayloadSize;
 8035b96:	68a3      	ldr	r3, [r4, #8]
        curElement = curElement->Next;
 8035b98:	6824      	ldr	r4, [r4, #0]
            itr += curElement->PayloadSize;
 8035b9a:	4443      	add	r3, r8
 8035b9c:	b2db      	uxtb	r3, r3
        curElement = curElement->Next;
 8035b9e:	e7e3      	b.n	8035b68 <LoRaMacCommandsSerializeCmds+0x14>
        nextElement = curElement->Next;
 8035ba0:	4620      	mov	r0, r4
 8035ba2:	6824      	ldr	r4, [r4, #0]
        LoRaMacCommandsRemoveCmd( curElement );
 8035ba4:	f7ff ff80 	bl	8035aa8 <LoRaMacCommandsRemoveCmd>
    while( curElement != NULL )
 8035ba8:	2c00      	cmp	r4, #0
 8035baa:	d1f9      	bne.n	8035ba0 <LoRaMacCommandsSerializeCmds+0x4c>
 8035bac:	e7dd      	b.n	8035b6a <LoRaMacCommandsSerializeCmds+0x16>
        return LORAMAC_COMMANDS_ERROR_NPE;
 8035bae:	2001      	movs	r0, #1
 8035bb0:	e7df      	b.n	8035b72 <LoRaMacCommandsSerializeCmds+0x1e>
 8035bb2:	bf00      	nop
 8035bb4:	20005604 	.word	0x20005604

08035bb8 <LoRaMacCommandsStickyCmdsPending>:

LoRaMacCommandStatus_t LoRaMacCommandsStickyCmdsPending( bool* cmdsPending )
{
    if( cmdsPending == NULL )
 8035bb8:	4603      	mov	r3, r0
 8035bba:	b168      	cbz	r0, 8035bd8 <LoRaMacCommandsStickyCmdsPending+0x20>
    {
        return LORAMAC_COMMANDS_ERROR_NPE;
    }
    MacCommand_t* curElement;
    curElement = CommandsCtx.MacCommandList.First;
 8035bbc:	4a07      	ldr	r2, [pc, #28]	; (8035bdc <LoRaMacCommandsStickyCmdsPending+0x24>)
 8035bbe:	6810      	ldr	r0, [r2, #0]

    *cmdsPending = false;
 8035bc0:	2200      	movs	r2, #0
 8035bc2:	701a      	strb	r2, [r3, #0]

    // Loop through all elements
    while( curElement != NULL )
 8035bc4:	b900      	cbnz	r0, 8035bc8 <LoRaMacCommandsStickyCmdsPending+0x10>
 8035bc6:	4770      	bx	lr
    {
        if( curElement->IsSticky == true )
 8035bc8:	7b02      	ldrb	r2, [r0, #12]
 8035bca:	b11a      	cbz	r2, 8035bd4 <LoRaMacCommandsStickyCmdsPending+0x1c>
        {
            // Found one sticky MAC command
            *cmdsPending = true;
 8035bcc:	2201      	movs	r2, #1
 8035bce:	701a      	strb	r2, [r3, #0]
            return LORAMAC_COMMANDS_SUCCESS;
 8035bd0:	2000      	movs	r0, #0
 8035bd2:	4770      	bx	lr
        }
        curElement = curElement->Next;
 8035bd4:	6800      	ldr	r0, [r0, #0]
 8035bd6:	e7f5      	b.n	8035bc4 <LoRaMacCommandsStickyCmdsPending+0xc>
        return LORAMAC_COMMANDS_ERROR_NPE;
 8035bd8:	2001      	movs	r0, #1
    }

    return LORAMAC_COMMANDS_SUCCESS;
}
 8035bda:	4770      	bx	lr
 8035bdc:	20005604 	.word	0x20005604

08035be0 <LoRaMacCommandsGetCmdSize>:
uint8_t LoRaMacCommandsGetCmdSize( uint8_t cid )
{
    uint8_t cidSize = 0;

    // Decode Frame MAC commands
    switch( cid )
 8035be0:	3802      	subs	r0, #2
 8035be2:	b2c0      	uxtb	r0, r0
 8035be4:	2811      	cmp	r0, #17
 8035be6:	bf9a      	itte	ls
 8035be8:	4b01      	ldrls	r3, [pc, #4]	; (8035bf0 <LoRaMacCommandsGetCmdSize+0x10>)
 8035bea:	5c18      	ldrbls	r0, [r3, r0]
{
 8035bec:	2000      	movhi	r0, #0
            // Unknown command. ABORT MAC commands processing
            break;
        }
    }
    return cidSize;
}
 8035bee:	4770      	bx	lr
 8035bf0:	0803baca 	.word	0x0803baca

08035bf4 <GetElement.isra.0>:
        return true;
    }
    return false;
}

static MlmeConfirmQueue_t* GetElement( Mlme_t request, MlmeConfirmQueue_t* bufferStart, MlmeConfirmQueue_t* bufferEnd )
 8035bf4:	b530      	push	{r4, r5, lr}
{
    MlmeConfirmQueue_t* element = bufferStart;

    if( IsListEmpty( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == true )
 8035bf6:	4b0c      	ldr	r3, [pc, #48]	; (8035c28 <GetElement.isra.0+0x34>)
 8035bf8:	f893 2020 	ldrb.w	r2, [r3, #32]
static MlmeConfirmQueue_t* GetElement( Mlme_t request, MlmeConfirmQueue_t* bufferStart, MlmeConfirmQueue_t* bufferEnd )
 8035bfc:	4604      	mov	r4, r0
 8035bfe:	4608      	mov	r0, r1
    if( count == 0 )
 8035c00:	b17a      	cbz	r2, 8035c22 <GetElement.isra.0+0x2e>
 8035c02:	2100      	movs	r1, #0
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 8035c04:	331c      	adds	r3, #28
    {
        return NULL;
    }

    for( uint8_t elementCnt = 0; elementCnt < ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt; elementCnt++ )
 8035c06:	b2cd      	uxtb	r5, r1
 8035c08:	42aa      	cmp	r2, r5
 8035c0a:	d801      	bhi.n	8035c10 <GetElement.isra.0+0x1c>
        return NULL;
 8035c0c:	2000      	movs	r0, #0
        }
        element = IncreaseBufferPointer( element );
    }

    return NULL;
}
 8035c0e:	bd30      	pop	{r4, r5, pc}
        if( element->Request == request )
 8035c10:	7805      	ldrb	r5, [r0, #0]
 8035c12:	42a5      	cmp	r5, r4
 8035c14:	d0fb      	beq.n	8035c0e <GetElement.isra.0+0x1a>
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 8035c16:	4298      	cmp	r0, r3
        bufferPointer = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 8035c18:	bf0c      	ite	eq
 8035c1a:	4804      	ldreq	r0, [pc, #16]	; (8035c2c <GetElement.isra.0+0x38>)
        bufferPointer++;
 8035c1c:	3004      	addne	r0, #4
    for( uint8_t elementCnt = 0; elementCnt < ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt; elementCnt++ )
 8035c1e:	3101      	adds	r1, #1
 8035c20:	e7f1      	b.n	8035c06 <GetElement.isra.0+0x12>
        return NULL;
 8035c22:	4610      	mov	r0, r2
 8035c24:	e7f3      	b.n	8035c0e <GetElement.isra.0+0x1a>
 8035c26:	bf00      	nop
 8035c28:	20005700 	.word	0x20005700
 8035c2c:	2000570c 	.word	0x2000570c

08035c30 <LoRaMacConfirmQueueInit>:

void LoRaMacConfirmQueueInit( LoRaMacPrimitives_t* primitives )
{
 8035c30:	b510      	push	{r4, lr}
    ConfirmQueueCtx.Primitives = primitives;
 8035c32:	4c08      	ldr	r4, [pc, #32]	; (8035c54 <LoRaMacConfirmQueueInit+0x24>)

    // Init counter
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt = 0;
 8035c34:	2300      	movs	r3, #0
    ConfirmQueueCtx.Primitives = primitives;
 8035c36:	6020      	str	r0, [r4, #0]

    // Init buffer
    ConfirmQueueCtx.BufferStart = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
    ConfirmQueueCtx.BufferEnd = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;

    memset1( ( uint8_t* )ConfirmQueueCtx.Nvm.MlmeConfirmQueue, 0xFF, sizeof( ConfirmQueueCtx.Nvm.MlmeConfirmQueue ) );
 8035c38:	2214      	movs	r2, #20
    ConfirmQueueCtx.BufferStart = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 8035c3a:	f104 000c 	add.w	r0, r4, #12
    memset1( ( uint8_t* )ConfirmQueueCtx.Nvm.MlmeConfirmQueue, 0xFF, sizeof( ConfirmQueueCtx.Nvm.MlmeConfirmQueue ) );
 8035c3e:	21ff      	movs	r1, #255	; 0xff
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt = 0;
 8035c40:	f884 3020 	strb.w	r3, [r4, #32]
    ConfirmQueueCtx.BufferEnd = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 8035c44:	e9c4 0001 	strd	r0, r0, [r4, #4]
    memset1( ( uint8_t* )ConfirmQueueCtx.Nvm.MlmeConfirmQueue, 0xFF, sizeof( ConfirmQueueCtx.Nvm.MlmeConfirmQueue ) );
 8035c48:	f003 f986 	bl	8038f58 <memset1>

    // Common status
    ConfirmQueueCtx.Nvm.CommonStatus = LORAMAC_EVENT_INFO_STATUS_ERROR;
 8035c4c:	2301      	movs	r3, #1
 8035c4e:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
}
 8035c52:	bd10      	pop	{r4, pc}
 8035c54:	20005700 	.word	0x20005700

08035c58 <LoRaMacConfirmQueueAdd>:

bool LoRaMacConfirmQueueAdd( MlmeConfirmQueue_t* mlmeConfirm )
{
    if( IsListFull( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == true )
 8035c58:	4b0f      	ldr	r3, [pc, #60]	; (8035c98 <LoRaMacConfirmQueueAdd+0x40>)
    if( count >= LORA_MAC_MLME_CONFIRM_QUEUE_LEN )
 8035c5a:	f893 2020 	ldrb.w	r2, [r3, #32]
 8035c5e:	2a04      	cmp	r2, #4
 8035c60:	d817      	bhi.n	8035c92 <LoRaMacConfirmQueueAdd+0x3a>
        // Protect the buffer against overwrites
        return false;
    }

    // Add the element to the ring buffer
    ConfirmQueueCtx.BufferEnd->Request = mlmeConfirm->Request;
 8035c62:	689a      	ldr	r2, [r3, #8]
 8035c64:	7801      	ldrb	r1, [r0, #0]
 8035c66:	7011      	strb	r1, [r2, #0]
    ConfirmQueueCtx.BufferEnd->Status = mlmeConfirm->Status;
 8035c68:	7841      	ldrb	r1, [r0, #1]
 8035c6a:	7051      	strb	r1, [r2, #1]
    ConfirmQueueCtx.BufferEnd->RestrictCommonReadyToHandle = mlmeConfirm->RestrictCommonReadyToHandle;
 8035c6c:	78c1      	ldrb	r1, [r0, #3]
 8035c6e:	70d1      	strb	r1, [r2, #3]
    ConfirmQueueCtx.BufferEnd->ReadyToHandle = false;
 8035c70:	2100      	movs	r1, #0
 8035c72:	7091      	strb	r1, [r2, #2]
    // Increase counter
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt++;
 8035c74:	f893 1020 	ldrb.w	r1, [r3, #32]
 8035c78:	3101      	adds	r1, #1
 8035c7a:	f883 1020 	strb.w	r1, [r3, #32]
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 8035c7e:	f103 011c 	add.w	r1, r3, #28
 8035c82:	428a      	cmp	r2, r1
        bufferPointer++;
 8035c84:	bf14      	ite	ne
 8035c86:	3204      	addne	r2, #4
        bufferPointer = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 8035c88:	f103 020c 	addeq.w	r2, r3, #12
    // Update end pointer
    ConfirmQueueCtx.BufferEnd = IncreaseBufferPointer( ConfirmQueueCtx.BufferEnd );
 8035c8c:	609a      	str	r2, [r3, #8]
 8035c8e:	2001      	movs	r0, #1
 8035c90:	4770      	bx	lr
        return false;
 8035c92:	2000      	movs	r0, #0

    return true;
}
 8035c94:	4770      	bx	lr
 8035c96:	bf00      	nop
 8035c98:	20005700 	.word	0x20005700

08035c9c <LoRaMacConfirmQueueRemoveFirst>:
    return true;
}

bool LoRaMacConfirmQueueRemoveFirst( void )
{
    if( IsListEmpty( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == true )
 8035c9c:	4b09      	ldr	r3, [pc, #36]	; (8035cc4 <LoRaMacConfirmQueueRemoveFirst+0x28>)
 8035c9e:	f893 0020 	ldrb.w	r0, [r3, #32]
    if( count == 0 )
 8035ca2:	b168      	cbz	r0, 8035cc0 <LoRaMacConfirmQueueRemoveFirst+0x24>
    }

    // Increase counter
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt--;
    // Update start pointer
    ConfirmQueueCtx.BufferStart = IncreaseBufferPointer( ConfirmQueueCtx.BufferStart );
 8035ca4:	685a      	ldr	r2, [r3, #4]
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 8035ca6:	f103 011c 	add.w	r1, r3, #28
 8035caa:	428a      	cmp	r2, r1
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt--;
 8035cac:	f100 30ff 	add.w	r0, r0, #4294967295
        bufferPointer++;
 8035cb0:	bf14      	ite	ne
 8035cb2:	3204      	addne	r2, #4
        bufferPointer = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 8035cb4:	f103 020c 	addeq.w	r2, r3, #12
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt--;
 8035cb8:	f883 0020 	strb.w	r0, [r3, #32]
    ConfirmQueueCtx.BufferStart = IncreaseBufferPointer( ConfirmQueueCtx.BufferStart );
 8035cbc:	605a      	str	r2, [r3, #4]

    return true;
 8035cbe:	2001      	movs	r0, #1
}
 8035cc0:	4770      	bx	lr
 8035cc2:	bf00      	nop
 8035cc4:	20005700 	.word	0x20005700

08035cc8 <LoRaMacConfirmQueueSetStatus>:

void LoRaMacConfirmQueueSetStatus( LoRaMacEventInfoStatus_t status, Mlme_t request )
{
 8035cc8:	b510      	push	{r4, lr}
    MlmeConfirmQueue_t* element = NULL;

    if( IsListEmpty( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == false )
 8035cca:	4b07      	ldr	r3, [pc, #28]	; (8035ce8 <LoRaMacConfirmQueueSetStatus+0x20>)
    if( count == 0 )
 8035ccc:	f893 2020 	ldrb.w	r2, [r3, #32]
{
 8035cd0:	4604      	mov	r4, r0
 8035cd2:	4608      	mov	r0, r1
    if( count == 0 )
 8035cd4:	b132      	cbz	r2, 8035ce4 <LoRaMacConfirmQueueSetStatus+0x1c>
    {
        element = GetElement( request, ConfirmQueueCtx.BufferStart, ConfirmQueueCtx.BufferEnd );
 8035cd6:	6859      	ldr	r1, [r3, #4]
 8035cd8:	f7ff ff8c 	bl	8035bf4 <GetElement.isra.0>
        if( element != NULL )
 8035cdc:	b110      	cbz	r0, 8035ce4 <LoRaMacConfirmQueueSetStatus+0x1c>
        {
            element->Status = status;
            element->ReadyToHandle = true;
 8035cde:	2301      	movs	r3, #1
            element->Status = status;
 8035ce0:	7044      	strb	r4, [r0, #1]
            element->ReadyToHandle = true;
 8035ce2:	7083      	strb	r3, [r0, #2]
        }
    }
}
 8035ce4:	bd10      	pop	{r4, pc}
 8035ce6:	bf00      	nop
 8035ce8:	20005700 	.word	0x20005700

08035cec <LoRaMacConfirmQueueGetStatus>:

LoRaMacEventInfoStatus_t LoRaMacConfirmQueueGetStatus( Mlme_t request )
{
 8035cec:	b508      	push	{r3, lr}
    MlmeConfirmQueue_t* element = NULL;

    if( IsListEmpty( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == false )
 8035cee:	4b06      	ldr	r3, [pc, #24]	; (8035d08 <LoRaMacConfirmQueueGetStatus+0x1c>)
    if( count == 0 )
 8035cf0:	f893 2020 	ldrb.w	r2, [r3, #32]
 8035cf4:	b12a      	cbz	r2, 8035d02 <LoRaMacConfirmQueueGetStatus+0x16>
    {
        element = GetElement( request, ConfirmQueueCtx.BufferStart, ConfirmQueueCtx.BufferEnd );
 8035cf6:	6859      	ldr	r1, [r3, #4]
 8035cf8:	f7ff ff7c 	bl	8035bf4 <GetElement.isra.0>
        if( element != NULL )
 8035cfc:	b108      	cbz	r0, 8035d02 <LoRaMacConfirmQueueGetStatus+0x16>
        {
            return element->Status;
 8035cfe:	7840      	ldrb	r0, [r0, #1]
        }
    }
    return LORAMAC_EVENT_INFO_STATUS_ERROR;
}
 8035d00:	bd08      	pop	{r3, pc}
    return LORAMAC_EVENT_INFO_STATUS_ERROR;
 8035d02:	2001      	movs	r0, #1
 8035d04:	e7fc      	b.n	8035d00 <LoRaMacConfirmQueueGetStatus+0x14>
 8035d06:	bf00      	nop
 8035d08:	20005700 	.word	0x20005700

08035d0c <LoRaMacConfirmQueueSetStatusCmn>:

void LoRaMacConfirmQueueSetStatusCmn( LoRaMacEventInfoStatus_t status )
{
 8035d0c:	b530      	push	{r4, r5, lr}
    MlmeConfirmQueue_t* element = ConfirmQueueCtx.BufferStart;
 8035d0e:	4a0a      	ldr	r2, [pc, #40]	; (8035d38 <LoRaMacConfirmQueueSetStatusCmn+0x2c>)
    if( count == 0 )
 8035d10:	f892 1020 	ldrb.w	r1, [r2, #32]
    MlmeConfirmQueue_t* element = ConfirmQueueCtx.BufferStart;
 8035d14:	6853      	ldr	r3, [r2, #4]

    ConfirmQueueCtx.Nvm.CommonStatus = status;
 8035d16:	f882 0021 	strb.w	r0, [r2, #33]	; 0x21
    if( count == 0 )
 8035d1a:	b161      	cbz	r1, 8035d36 <LoRaMacConfirmQueueSetStatusCmn+0x2a>
            if( element->RestrictCommonReadyToHandle == false )
            {
                element->ReadyToHandle = true;
            }
            element = IncreaseBufferPointer( element );
        }while( element != ConfirmQueueCtx.BufferEnd );
 8035d1c:	6891      	ldr	r1, [r2, #8]
                element->ReadyToHandle = true;
 8035d1e:	2401      	movs	r4, #1
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 8035d20:	321c      	adds	r2, #28
            if( element->RestrictCommonReadyToHandle == false )
 8035d22:	78dd      	ldrb	r5, [r3, #3]
            element->Status = status;
 8035d24:	7058      	strb	r0, [r3, #1]
            if( element->RestrictCommonReadyToHandle == false )
 8035d26:	b905      	cbnz	r5, 8035d2a <LoRaMacConfirmQueueSetStatusCmn+0x1e>
                element->ReadyToHandle = true;
 8035d28:	709c      	strb	r4, [r3, #2]
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 8035d2a:	4293      	cmp	r3, r2
        bufferPointer = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 8035d2c:	bf0c      	ite	eq
 8035d2e:	4b03      	ldreq	r3, [pc, #12]	; (8035d3c <LoRaMacConfirmQueueSetStatusCmn+0x30>)
        bufferPointer++;
 8035d30:	3304      	addne	r3, #4
        }while( element != ConfirmQueueCtx.BufferEnd );
 8035d32:	4299      	cmp	r1, r3
 8035d34:	d1f5      	bne.n	8035d22 <LoRaMacConfirmQueueSetStatusCmn+0x16>
    }
}
 8035d36:	bd30      	pop	{r4, r5, pc}
 8035d38:	20005700 	.word	0x20005700
 8035d3c:	2000570c 	.word	0x2000570c

08035d40 <LoRaMacConfirmQueueIsCmdActive>:
{
    return ConfirmQueueCtx.Nvm.CommonStatus;
}

bool LoRaMacConfirmQueueIsCmdActive( Mlme_t request )
{
 8035d40:	b508      	push	{r3, lr}
    if( GetElement( request, ConfirmQueueCtx.BufferStart, ConfirmQueueCtx.BufferEnd ) != NULL )
 8035d42:	4b04      	ldr	r3, [pc, #16]	; (8035d54 <LoRaMacConfirmQueueIsCmdActive+0x14>)
 8035d44:	6859      	ldr	r1, [r3, #4]
 8035d46:	f7ff ff55 	bl	8035bf4 <GetElement.isra.0>
    {
        return true;
    }
    return false;
}
 8035d4a:	3800      	subs	r0, #0
 8035d4c:	bf18      	it	ne
 8035d4e:	2001      	movne	r0, #1
 8035d50:	bd08      	pop	{r3, pc}
 8035d52:	bf00      	nop
 8035d54:	20005700 	.word	0x20005700

08035d58 <LoRaMacConfirmQueueHandleCb>:

void LoRaMacConfirmQueueHandleCb( MlmeConfirm_t* mlmeConfirm )
{
 8035d58:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    uint8_t nbElements = ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt;
 8035d5c:	4d12      	ldr	r5, [pc, #72]	; (8035da8 <LoRaMacConfirmQueueHandleCb+0x50>)
 8035d5e:	f895 8020 	ldrb.w	r8, [r5, #32]
{
 8035d62:	4604      	mov	r4, r0
    bool readyToHandle = false;
    MlmeConfirmQueue_t mlmeConfirmToStore;

    for( uint8_t i = 0; i < nbElements; i++ )
 8035d64:	2600      	movs	r6, #0
 8035d66:	b2f3      	uxtb	r3, r6
 8035d68:	4598      	cmp	r8, r3
 8035d6a:	d802      	bhi.n	8035d72 <LoRaMacConfirmQueueHandleCb+0x1a>
        {
            // Add a request which has not been finished again to the queue
            LoRaMacConfirmQueueAdd( &mlmeConfirmToStore );
        }
    }
}
 8035d6c:	b002      	add	sp, #8
 8035d6e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        mlmeConfirm->MlmeRequest = ConfirmQueueCtx.BufferStart->Request;
 8035d72:	686b      	ldr	r3, [r5, #4]
 8035d74:	7819      	ldrb	r1, [r3, #0]
 8035d76:	7021      	strb	r1, [r4, #0]
        mlmeConfirm->Status = ConfirmQueueCtx.BufferStart->Status;
 8035d78:	785a      	ldrb	r2, [r3, #1]
 8035d7a:	7062      	strb	r2, [r4, #1]
        readyToHandle = ConfirmQueueCtx.BufferStart->ReadyToHandle;
 8035d7c:	789f      	ldrb	r7, [r3, #2]
        if( readyToHandle == true )
 8035d7e:	b15f      	cbz	r7, 8035d98 <LoRaMacConfirmQueueHandleCb+0x40>
            ConfirmQueueCtx.Primitives->MacMlmeConfirm( mlmeConfirm );
 8035d80:	682b      	ldr	r3, [r5, #0]
 8035d82:	4620      	mov	r0, r4
 8035d84:	689b      	ldr	r3, [r3, #8]
 8035d86:	4798      	blx	r3
        LoRaMacConfirmQueueRemoveFirst( );
 8035d88:	f7ff ff88 	bl	8035c9c <LoRaMacConfirmQueueRemoveFirst>
        if( readyToHandle == false )
 8035d8c:	b917      	cbnz	r7, 8035d94 <LoRaMacConfirmQueueHandleCb+0x3c>
            LoRaMacConfirmQueueAdd( &mlmeConfirmToStore );
 8035d8e:	a801      	add	r0, sp, #4
 8035d90:	f7ff ff62 	bl	8035c58 <LoRaMacConfirmQueueAdd>
    for( uint8_t i = 0; i < nbElements; i++ )
 8035d94:	3601      	adds	r6, #1
 8035d96:	e7e6      	b.n	8035d66 <LoRaMacConfirmQueueHandleCb+0xe>
            mlmeConfirmToStore.RestrictCommonReadyToHandle = ConfirmQueueCtx.BufferStart->RestrictCommonReadyToHandle;
 8035d98:	78db      	ldrb	r3, [r3, #3]
            mlmeConfirmToStore.Request = ConfirmQueueCtx.BufferStart->Request;
 8035d9a:	f88d 1004 	strb.w	r1, [sp, #4]
            mlmeConfirmToStore.Status = ConfirmQueueCtx.BufferStart->Status;
 8035d9e:	f88d 2005 	strb.w	r2, [sp, #5]
            mlmeConfirmToStore.RestrictCommonReadyToHandle = ConfirmQueueCtx.BufferStart->RestrictCommonReadyToHandle;
 8035da2:	f88d 3007 	strb.w	r3, [sp, #7]
 8035da6:	e7ef      	b.n	8035d88 <LoRaMacConfirmQueueHandleCb+0x30>
 8035da8:	20005700 	.word	0x20005700

08035dac <LoRaMacConfirmQueueGetCnt>:

uint8_t LoRaMacConfirmQueueGetCnt( void )
{
    return ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt;
}
 8035dac:	4b01      	ldr	r3, [pc, #4]	; (8035db4 <LoRaMacConfirmQueueGetCnt+0x8>)
 8035dae:	f893 0020 	ldrb.w	r0, [r3, #32]
 8035db2:	4770      	bx	lr
 8035db4:	20005700 	.word	0x20005700

08035db8 <LoRaMacConfirmQueueIsFull>:

bool LoRaMacConfirmQueueIsFull( void )
{
    if( IsListFull( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == true )
 8035db8:	4b03      	ldr	r3, [pc, #12]	; (8035dc8 <LoRaMacConfirmQueueIsFull+0x10>)
    if( count >= LORA_MAC_MLME_CONFIRM_QUEUE_LEN )
 8035dba:	f893 0020 	ldrb.w	r0, [r3, #32]
    }
    else
    {
        return false;
    }
}
 8035dbe:	2804      	cmp	r0, #4
 8035dc0:	bf94      	ite	ls
 8035dc2:	2000      	movls	r0, #0
 8035dc4:	2001      	movhi	r0, #1
 8035dc6:	4770      	bx	lr
 8035dc8:	20005700 	.word	0x20005700

08035dcc <DeriveSessionKey10x>:
 * \param[IN]  netID          - Network Identifier
 * \param[IN]  deviceNonce    - Device nonce
 * \retval                    - Status of the operation
 */
static LoRaMacCryptoStatus_t DeriveSessionKey10x( KeyIdentifier_t keyID, uint32_t joinNonce, uint32_t netID, uint16_t devNonce )
{
 8035dcc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    uint8_t compBase[16] = { 0 };
 8035dce:	2400      	movs	r4, #0
 8035dd0:	e9cd 4402 	strd	r4, r4, [sp, #8]

    /* ST_WORKAROUND_BEGIN: integrate 1.1.x keys only if required */
    switch( keyID )
 8035dd4:	1e44      	subs	r4, r0, #1
 8035dd6:	f88d 4000 	strb.w	r4, [sp]
        default:
            return LORAMAC_CRYPTO_ERROR_INVALID_KEY_ID;
    }
   /* ST_WORKAROUND_END */

    compBase[1] = ( uint8_t )( ( joinNonce >> 0 ) & 0xFF );
 8035dda:	f88d 1001 	strb.w	r1, [sp, #1]
    compBase[2] = ( uint8_t )( ( joinNonce >> 8 ) & 0xFF );
 8035dde:	0a0c      	lsrs	r4, r1, #8
    compBase[3] = ( uint8_t )( ( joinNonce >> 16 ) & 0xFF );

    compBase[4] = ( uint8_t )( ( netID >> 0 ) & 0xFF );
 8035de0:	f8ad 2004 	strh.w	r2, [sp, #4]
    compBase[3] = ( uint8_t )( ( joinNonce >> 16 ) & 0xFF );
 8035de4:	0c09      	lsrs	r1, r1, #16
    compBase[5] = ( uint8_t )( ( netID >> 8 ) & 0xFF );
    compBase[6] = ( uint8_t )( ( netID >> 16 ) & 0xFF );
 8035de6:	0c12      	lsrs	r2, r2, #16
    compBase[3] = ( uint8_t )( ( joinNonce >> 16 ) & 0xFF );
 8035de8:	f88d 1003 	strb.w	r1, [sp, #3]
    compBase[6] = ( uint8_t )( ( netID >> 16 ) & 0xFF );
 8035dec:	f88d 2006 	strb.w	r2, [sp, #6]

    compBase[7] = ( uint8_t )( ( devNonce >> 0 ) & 0xFF );
 8035df0:	f88d 3007 	strb.w	r3, [sp, #7]
    compBase[8] = ( uint8_t )( ( devNonce >> 8 ) & 0xFF );

    if( SecureElementDeriveAndStoreKey( compBase, NWK_KEY, keyID ) != SECURE_ELEMENT_SUCCESS )
 8035df4:	4602      	mov	r2, r0
    compBase[8] = ( uint8_t )( ( devNonce >> 8 ) & 0xFF );
 8035df6:	0a1b      	lsrs	r3, r3, #8
    if( SecureElementDeriveAndStoreKey( compBase, NWK_KEY, keyID ) != SECURE_ELEMENT_SUCCESS )
 8035df8:	2101      	movs	r1, #1
 8035dfa:	4668      	mov	r0, sp
    compBase[2] = ( uint8_t )( ( joinNonce >> 8 ) & 0xFF );
 8035dfc:	f88d 4002 	strb.w	r4, [sp, #2]
    compBase[8] = ( uint8_t )( ( devNonce >> 8 ) & 0xFF );
 8035e00:	f88d 3008 	strb.w	r3, [sp, #8]
    if( SecureElementDeriveAndStoreKey( compBase, NWK_KEY, keyID ) != SECURE_ELEMENT_SUCCESS )
 8035e04:	f002 ffa0 	bl	8038d48 <SecureElementDeriveAndStoreKey>
 8035e08:	2800      	cmp	r0, #0
    {
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
    }

    return LORAMAC_CRYPTO_SUCCESS;
}
 8035e0a:	bf18      	it	ne
 8035e0c:	200f      	movne	r0, #15
 8035e0e:	b004      	add	sp, #16
 8035e10:	bd10      	pop	{r4, pc}

08035e12 <PayloadEncrypt>:
{
 8035e12:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8035e16:	b088      	sub	sp, #32
 8035e18:	4617      	mov	r7, r2
 8035e1a:	460d      	mov	r5, r1
 8035e1c:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    if( buffer == 0 )
 8035e1e:	4606      	mov	r6, r0
 8035e20:	2800      	cmp	r0, #0
 8035e22:	d04d      	beq.n	8035ec0 <PayloadEncrypt+0xae>
    uint8_t sBlock[16] = { 0 };
 8035e24:	2400      	movs	r4, #0
    aBlock[0] = 0x01;
 8035e26:	2101      	movs	r1, #1
    uint8_t aBlock[16] = { 0 };
 8035e28:	e9cd 4404 	strd	r4, r4, [sp, #16]
    aBlock[0] = 0x01;
 8035e2c:	f88d 1010 	strb.w	r1, [sp, #16]
    aBlock[5] = dir;
 8035e30:	f89d 1038 	ldrb.w	r1, [sp, #56]	; 0x38
 8035e34:	f88d 1015 	strb.w	r1, [sp, #21]
    aBlock[6] = address & 0xFF;
 8035e38:	f8ad 3016 	strh.w	r3, [sp, #22]
    aBlock[8] = ( address >> 16 ) & 0xFF;
 8035e3c:	0c19      	lsrs	r1, r3, #16
    uint8_t sBlock[16] = { 0 };
 8035e3e:	e9cd 4400 	strd	r4, r4, [sp]
    aBlock[9] = ( address >> 24 ) & 0xFF;
 8035e42:	0e1b      	lsrs	r3, r3, #24
    uint8_t sBlock[16] = { 0 };
 8035e44:	e9cd 4402 	strd	r4, r4, [sp, #8]
    aBlock[9] = ( address >> 24 ) & 0xFF;
 8035e48:	f88d 3019 	strb.w	r3, [sp, #25]
    aBlock[10] = frameCounter & 0xFF;
 8035e4c:	f8ad 201a 	strh.w	r2, [sp, #26]
    aBlock[12] = ( frameCounter >> 16 ) & 0xFF;
 8035e50:	0c13      	lsrs	r3, r2, #16
    aBlock[13] = ( frameCounter >> 24 ) & 0xFF;
 8035e52:	0e12      	lsrs	r2, r2, #24
    uint8_t aBlock[16] = { 0 };
 8035e54:	9407      	str	r4, [sp, #28]
    aBlock[8] = ( address >> 16 ) & 0xFF;
 8035e56:	f88d 1018 	strb.w	r1, [sp, #24]
    aBlock[12] = ( frameCounter >> 16 ) & 0xFF;
 8035e5a:	f88d 301c 	strb.w	r3, [sp, #28]
    aBlock[13] = ( frameCounter >> 24 ) & 0xFF;
 8035e5e:	f88d 201d 	strb.w	r2, [sp, #29]
    while( size > 0 )
 8035e62:	b2e3      	uxtb	r3, r4
 8035e64:	ea4f 1803 	mov.w	r8, r3, lsl #4
 8035e68:	2d00      	cmp	r5, #0
 8035e6a:	fa5f f888 	uxtb.w	r8, r8
 8035e6e:	dc03      	bgt.n	8035e78 <PayloadEncrypt+0x66>
    return LORAMAC_CRYPTO_SUCCESS;
 8035e70:	2000      	movs	r0, #0
}
 8035e72:	b008      	add	sp, #32
 8035e74:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        aBlock[15] = ctr & 0xFF;
 8035e78:	3301      	adds	r3, #1
        if( SecureElementAesEncrypt( aBlock, 16, keyID, sBlock ) != SECURE_ELEMENT_SUCCESS )
 8035e7a:	2110      	movs	r1, #16
        aBlock[15] = ctr & 0xFF;
 8035e7c:	f88d 301f 	strb.w	r3, [sp, #31]
        if( SecureElementAesEncrypt( aBlock, 16, keyID, sBlock ) != SECURE_ELEMENT_SUCCESS )
 8035e80:	463a      	mov	r2, r7
 8035e82:	466b      	mov	r3, sp
 8035e84:	eb0d 0001 	add.w	r0, sp, r1
 8035e88:	f002 fe76 	bl	8038b78 <SecureElementAesEncrypt>
 8035e8c:	4603      	mov	r3, r0
 8035e8e:	b9c8      	cbnz	r0, 8035ec4 <PayloadEncrypt+0xb2>
        for( uint8_t i = 0; i < ( ( size > 16 ) ? 16 : size ); i++ )
 8035e90:	2d10      	cmp	r5, #16
 8035e92:	46ac      	mov	ip, r5
 8035e94:	bfa8      	it	ge
 8035e96:	f04f 0c10 	movge.w	ip, #16
 8035e9a:	b2da      	uxtb	r2, r3
 8035e9c:	4562      	cmp	r2, ip
 8035e9e:	f103 0301 	add.w	r3, r3, #1
 8035ea2:	db03      	blt.n	8035eac <PayloadEncrypt+0x9a>
        size -= 16;
 8035ea4:	3d10      	subs	r5, #16
 8035ea6:	b22d      	sxth	r5, r5
        bufferIndex += 16;
 8035ea8:	3401      	adds	r4, #1
 8035eaa:	e7da      	b.n	8035e62 <PayloadEncrypt+0x50>
            buffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i];
 8035eac:	a908      	add	r1, sp, #32
 8035eae:	eb08 0002 	add.w	r0, r8, r2
 8035eb2:	440a      	add	r2, r1
 8035eb4:	5c31      	ldrb	r1, [r6, r0]
 8035eb6:	f812 2c20 	ldrb.w	r2, [r2, #-32]
 8035eba:	404a      	eors	r2, r1
 8035ebc:	5432      	strb	r2, [r6, r0]
        for( uint8_t i = 0; i < ( ( size > 16 ) ? 16 : size ); i++ )
 8035ebe:	e7ec      	b.n	8035e9a <PayloadEncrypt+0x88>
        return LORAMAC_CRYPTO_ERROR_NPE;
 8035ec0:	200a      	movs	r0, #10
 8035ec2:	e7d6      	b.n	8035e72 <PayloadEncrypt+0x60>
            return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 8035ec4:	200f      	movs	r0, #15
 8035ec6:	e7d4      	b.n	8035e72 <PayloadEncrypt+0x60>

08035ec8 <GetLastFcntDown>:
{
    if( lastDown == NULL )
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
    }
    switch( fCntID )
 8035ec8:	3801      	subs	r0, #1
 8035eca:	2803      	cmp	r0, #3
 8035ecc:	d81c      	bhi.n	8035f08 <GetLastFcntDown+0x40>
 8035ece:	e8df f000 	tbb	[pc, r0]
 8035ed2:	0a02      	.short	0x0a02
 8035ed4:	1610      	.short	0x1610
    {
        case N_FCNT_DOWN:
            *lastDown = CryptoNvm->FCntList.NFCntDown;
 8035ed6:	4b0d      	ldr	r3, [pc, #52]	; (8035f0c <GetLastFcntDown+0x44>)
 8035ed8:	681b      	ldr	r3, [r3, #0]
 8035eda:	691a      	ldr	r2, [r3, #16]
 8035edc:	600a      	str	r2, [r1, #0]
            CryptoNvm->LastDownFCnt = CryptoNvm->FCntList.NFCntDown;
 8035ede:	691a      	ldr	r2, [r3, #16]
            break;
        case A_FCNT_DOWN:
            *lastDown = CryptoNvm->FCntList.AFCntDown;
            CryptoNvm->LastDownFCnt = CryptoNvm->FCntList.AFCntDown;
 8035ee0:	621a      	str	r2, [r3, #32]
            break;
#endif /* LORAMAC_MAX_MC_CTX > 3 */
        default:
            return LORAMAC_CRYPTO_FAIL_FCNT_ID;
    }
    return LORAMAC_CRYPTO_SUCCESS;
 8035ee2:	2000      	movs	r0, #0
            break;
 8035ee4:	4770      	bx	lr
            *lastDown = CryptoNvm->FCntList.AFCntDown;
 8035ee6:	4b09      	ldr	r3, [pc, #36]	; (8035f0c <GetLastFcntDown+0x44>)
 8035ee8:	681b      	ldr	r3, [r3, #0]
 8035eea:	695a      	ldr	r2, [r3, #20]
 8035eec:	600a      	str	r2, [r1, #0]
            CryptoNvm->LastDownFCnt = CryptoNvm->FCntList.AFCntDown;
 8035eee:	695a      	ldr	r2, [r3, #20]
 8035ef0:	e7f6      	b.n	8035ee0 <GetLastFcntDown+0x18>
            *lastDown = CryptoNvm->FCntList.FCntDown;
 8035ef2:	4b06      	ldr	r3, [pc, #24]	; (8035f0c <GetLastFcntDown+0x44>)
 8035ef4:	681b      	ldr	r3, [r3, #0]
 8035ef6:	699a      	ldr	r2, [r3, #24]
 8035ef8:	600a      	str	r2, [r1, #0]
            CryptoNvm->LastDownFCnt = CryptoNvm->FCntList.FCntDown;
 8035efa:	699a      	ldr	r2, [r3, #24]
 8035efc:	e7f0      	b.n	8035ee0 <GetLastFcntDown+0x18>
            *lastDown = CryptoNvm->FCntList.McFCntDown[0];
 8035efe:	4b03      	ldr	r3, [pc, #12]	; (8035f0c <GetLastFcntDown+0x44>)
 8035f00:	681b      	ldr	r3, [r3, #0]
 8035f02:	69db      	ldr	r3, [r3, #28]
 8035f04:	600b      	str	r3, [r1, #0]
            break;
 8035f06:	e7ec      	b.n	8035ee2 <GetLastFcntDown+0x1a>
            CryptoNvm->LastDownFCnt = CryptoNvm->FCntList.NFCntDown;
 8035f08:	2005      	movs	r0, #5
}
 8035f0a:	4770      	bx	lr
 8035f0c:	20005724 	.word	0x20005724

08035f10 <LoRaMacCryptoDeriveMcKEKey.part.0>:
    }

    return LORAMAC_CRYPTO_SUCCESS;
}

LoRaMacCryptoStatus_t LoRaMacCryptoDeriveMcKEKey( KeyIdentifier_t keyID )
 8035f10:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    // Prevent other keys than McRootKey
    if( keyID != MC_ROOT_KEY )
    {
        return LORAMAC_CRYPTO_ERROR_INVALID_KEY_ID;
    }
    uint8_t compBase[16] = { 0 };
 8035f12:	2300      	movs	r3, #0

    if( SecureElementDeriveAndStoreKey( compBase, keyID, MC_KE_KEY ) != SECURE_ELEMENT_SUCCESS )
 8035f14:	227f      	movs	r2, #127	; 0x7f
 8035f16:	2104      	movs	r1, #4
 8035f18:	4668      	mov	r0, sp
    uint8_t compBase[16] = { 0 };
 8035f1a:	e9cd 3300 	strd	r3, r3, [sp]
 8035f1e:	e9cd 3302 	strd	r3, r3, [sp, #8]
    if( SecureElementDeriveAndStoreKey( compBase, keyID, MC_KE_KEY ) != SECURE_ELEMENT_SUCCESS )
 8035f22:	f002 ff11 	bl	8038d48 <SecureElementDeriveAndStoreKey>
 8035f26:	2800      	cmp	r0, #0
    {
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
    }

    return LORAMAC_CRYPTO_SUCCESS;
}
 8035f28:	bf18      	it	ne
 8035f2a:	200f      	movne	r0, #15
 8035f2c:	b005      	add	sp, #20
 8035f2e:	f85d fb04 	ldr.w	pc, [sp], #4

08035f32 <VerifyCmacB0.isra.0.constprop.0>:
static LoRaMacCryptoStatus_t VerifyCmacB0( uint8_t* msg, uint16_t len, KeyIdentifier_t keyID, bool isAck, uint8_t dir, uint32_t devAddr, uint32_t fCnt, uint32_t expectedCmac )
 8035f32:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8035f36:	b0c4      	sub	sp, #272	; 0x110
 8035f38:	460c      	mov	r4, r1
 8035f3a:	9e4a      	ldr	r6, [sp, #296]	; 0x128
 8035f3c:	4617      	mov	r7, r2
 8035f3e:	461d      	mov	r5, r3
    if( msg == 0 )
 8035f40:	4680      	mov	r8, r0
 8035f42:	b3b8      	cbz	r0, 8035fb4 <VerifyCmacB0.isra.0.constprop.0+0x82>
    if( len > CRYPTO_MAXMESSAGE_SIZE )
 8035f44:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 8035f48:	d836      	bhi.n	8035fb8 <VerifyCmacB0.isra.0.constprop.0+0x86>
    memset1( micBuff, 0, CRYPTO_BUFFER_SIZE );
 8035f4a:	f44f 7288 	mov.w	r2, #272	; 0x110
 8035f4e:	2100      	movs	r1, #0
 8035f50:	4668      	mov	r0, sp
 8035f52:	f003 f801 	bl	8038f58 <memset1>
    b0[0] = 0x49;
 8035f56:	2349      	movs	r3, #73	; 0x49
 8035f58:	9300      	str	r3, [sp, #0]
    b0[4] = 0x00;
 8035f5a:	f44f 7380 	mov.w	r3, #256	; 0x100
 8035f5e:	f8ad 3004 	strh.w	r3, [sp, #4]
    b0[8] = ( devAddr >> 16 ) & 0xFF;
 8035f62:	0c2b      	lsrs	r3, r5, #16
 8035f64:	f88d 3008 	strb.w	r3, [sp, #8]
    b0[12] = ( fCnt >> 16 ) & 0xFF;
 8035f68:	0c33      	lsrs	r3, r6, #16
    b0[6] = devAddr & 0xFF;
 8035f6a:	f8ad 5006 	strh.w	r5, [sp, #6]
    b0[10] = fCnt & 0xFF;
 8035f6e:	f8ad 600a 	strh.w	r6, [sp, #10]
    b0[12] = ( fCnt >> 16 ) & 0xFF;
 8035f72:	f88d 300c 	strb.w	r3, [sp, #12]
    memcpy1( ( micBuff + MIC_BLOCK_BX_SIZE ), msg, len );
 8035f76:	4622      	mov	r2, r4
    b0[14] = 0x00;
 8035f78:	2300      	movs	r3, #0
    memcpy1( ( micBuff + MIC_BLOCK_BX_SIZE ), msg, len );
 8035f7a:	4641      	mov	r1, r8
 8035f7c:	a804      	add	r0, sp, #16
    b0[9] = ( devAddr >> 24 ) & 0xFF;
 8035f7e:	0e2d      	lsrs	r5, r5, #24
    b0[13] = ( fCnt >> 24 ) & 0xFF;
 8035f80:	0e36      	lsrs	r6, r6, #24
    b0[14] = 0x00;
 8035f82:	f88d 300e 	strb.w	r3, [sp, #14]
    b0[9] = ( devAddr >> 24 ) & 0xFF;
 8035f86:	f88d 5009 	strb.w	r5, [sp, #9]
    b0[13] = ( fCnt >> 24 ) & 0xFF;
 8035f8a:	f88d 600d 	strb.w	r6, [sp, #13]
    b0[15] = msgLen & 0xFF;
 8035f8e:	f88d 400f 	strb.w	r4, [sp, #15]
    memcpy1( ( micBuff + MIC_BLOCK_BX_SIZE ), msg, len );
 8035f92:	f002 ffcd 	bl	8038f30 <memcpy1>
    retval = SecureElementVerifyAesCmac( micBuff, ( len + MIC_BLOCK_BX_SIZE ), expectedCmac, keyID );
 8035f96:	f104 0110 	add.w	r1, r4, #16
 8035f9a:	9a4b      	ldr	r2, [sp, #300]	; 0x12c
 8035f9c:	463b      	mov	r3, r7
 8035f9e:	b289      	uxth	r1, r1
 8035fa0:	4668      	mov	r0, sp
 8035fa2:	f002 fdab 	bl	8038afc <SecureElementVerifyAesCmac>
    if( retval == SECURE_ELEMENT_SUCCESS )
 8035fa6:	b110      	cbz	r0, 8035fae <VerifyCmacB0.isra.0.constprop.0+0x7c>
    return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 8035fa8:	2801      	cmp	r0, #1
 8035faa:	bf18      	it	ne
 8035fac:	200f      	movne	r0, #15
}
 8035fae:	b044      	add	sp, #272	; 0x110
 8035fb0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return LORAMAC_CRYPTO_ERROR_NPE;
 8035fb4:	200a      	movs	r0, #10
 8035fb6:	e7fa      	b.n	8035fae <VerifyCmacB0.isra.0.constprop.0+0x7c>
        return LORAMAC_CRYPTO_ERROR_BUF_SIZE;
 8035fb8:	200e      	movs	r0, #14
 8035fba:	e7f8      	b.n	8035fae <VerifyCmacB0.isra.0.constprop.0+0x7c>

08035fbc <LoRaMacCryptoInit>:
{
 8035fbc:	b510      	push	{r4, lr}
    if( nvm == NULL )
 8035fbe:	b190      	cbz	r0, 8035fe6 <LoRaMacCryptoInit+0x2a>
    CryptoNvm = nvm;
 8035fc0:	4c0a      	ldr	r4, [pc, #40]	; (8035fec <LoRaMacCryptoInit+0x30>)
    memset1( ( uint8_t* )CryptoNvm, 0, sizeof( LoRaMacCryptoNvmData_t ) );
 8035fc2:	2228      	movs	r2, #40	; 0x28
 8035fc4:	2100      	movs	r1, #0
    CryptoNvm = nvm;
 8035fc6:	6020      	str	r0, [r4, #0]
    memset1( ( uint8_t* )CryptoNvm, 0, sizeof( LoRaMacCryptoNvmData_t ) );
 8035fc8:	f002 ffc6 	bl	8038f58 <memset1>
    CryptoNvm->LrWanVersion.Fields.Major = 1;
 8035fcc:	6823      	ldr	r3, [r4, #0]
    CryptoNvm->LrWanVersion.Fields.Revision = 0;
 8035fce:	4a08      	ldr	r2, [pc, #32]	; (8035ff0 <LoRaMacCryptoInit+0x34>)
 8035fd0:	601a      	str	r2, [r3, #0]
    CryptoNvm->FCntList.NFCntDown = FCNT_DOWN_INITAL_VALUE;
 8035fd2:	2000      	movs	r0, #0
 8035fd4:	f04f 32ff 	mov.w	r2, #4294967295
 8035fd8:	e9c3 0203 	strd	r0, r2, [r3, #12]
    CryptoNvm->FCntList.FCntDown = FCNT_DOWN_INITAL_VALUE;
 8035fdc:	e9c3 2205 	strd	r2, r2, [r3, #20]
        CryptoNvm->FCntList.McFCntDown[i] = FCNT_DOWN_INITAL_VALUE;
 8035fe0:	e9c3 2207 	strd	r2, r2, [r3, #28]
}
 8035fe4:	bd10      	pop	{r4, pc}
        return LORAMAC_CRYPTO_FAIL_PARAM;
 8035fe6:	2009      	movs	r0, #9
 8035fe8:	e7fc      	b.n	8035fe4 <LoRaMacCryptoInit+0x28>
 8035fea:	bf00      	nop
 8035fec:	20005724 	.word	0x20005724
 8035ff0:	01010100 	.word	0x01010100

08035ff4 <LoRaMacCryptoSetLrWanVersion>:
    CryptoNvm->LrWanVersion = version;
 8035ff4:	4b02      	ldr	r3, [pc, #8]	; (8036000 <LoRaMacCryptoSetLrWanVersion+0xc>)
 8035ff6:	681b      	ldr	r3, [r3, #0]
 8035ff8:	6018      	str	r0, [r3, #0]
}
 8035ffa:	2000      	movs	r0, #0
 8035ffc:	4770      	bx	lr
 8035ffe:	bf00      	nop
 8036000:	20005724 	.word	0x20005724

08036004 <LoRaMacCryptoGetFCntUp>:
    if( currentUp == NULL )
 8036004:	b130      	cbz	r0, 8036014 <LoRaMacCryptoGetFCntUp+0x10>
    *currentUp = CryptoNvm->FCntList.FCntUp + 1;
 8036006:	4b04      	ldr	r3, [pc, #16]	; (8036018 <LoRaMacCryptoGetFCntUp+0x14>)
 8036008:	681b      	ldr	r3, [r3, #0]
 803600a:	68db      	ldr	r3, [r3, #12]
 803600c:	3301      	adds	r3, #1
 803600e:	6003      	str	r3, [r0, #0]
    return LORAMAC_CRYPTO_SUCCESS;
 8036010:	2000      	movs	r0, #0
 8036012:	4770      	bx	lr
        return LORAMAC_CRYPTO_ERROR_NPE;
 8036014:	200a      	movs	r0, #10
}
 8036016:	4770      	bx	lr
 8036018:	20005724 	.word	0x20005724

0803601c <LoRaMacCryptoGetFCntDown>:
{
 803601c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 803601e:	4617      	mov	r7, r2
    uint32_t lastDown = 0;
 8036020:	2200      	movs	r2, #0
{
 8036022:	460e      	mov	r6, r1
    uint32_t lastDown = 0;
 8036024:	9201      	str	r2, [sp, #4]
    if( currentDown == NULL )
 8036026:	461c      	mov	r4, r3
 8036028:	b353      	cbz	r3, 8036080 <LoRaMacCryptoGetFCntDown+0x64>
    cryptoStatus = GetLastFcntDown( fCntID, &lastDown );
 803602a:	a901      	add	r1, sp, #4
 803602c:	f7ff ff4c 	bl	8035ec8 <GetLastFcntDown>
    if( cryptoStatus != LORAMAC_CRYPTO_SUCCESS )
 8036030:	b9e8      	cbnz	r0, 803606e <LoRaMacCryptoGetFCntDown+0x52>
    if( lastDown == FCNT_DOWN_INITAL_VALUE )
 8036032:	9d01      	ldr	r5, [sp, #4]
 8036034:	1c6b      	adds	r3, r5, #1
 8036036:	d110      	bne.n	803605a <LoRaMacCryptoGetFCntDown+0x3e>
        *currentDown = frameFcnt;
 8036038:	6027      	str	r7, [r4, #0]
    if( CryptoNvm->LrWanVersion.Fields.Minor == 0 )
 803603a:	4b12      	ldr	r3, [pc, #72]	; (8036084 <LoRaMacCryptoGetFCntDown+0x68>)
 803603c:	681b      	ldr	r3, [r3, #0]
 803603e:	789b      	ldrb	r3, [r3, #2]
 8036040:	b9ab      	cbnz	r3, 803606e <LoRaMacCryptoGetFCntDown+0x52>
        if( ( ( int64_t )*currentDown - ( int64_t )lastDown ) >= maxFCntGap )
 8036042:	6822      	ldr	r2, [r4, #0]
 8036044:	b2b6      	uxth	r6, r6
 8036046:	1b52      	subs	r2, r2, r5
 8036048:	eb62 0302 	sbc.w	r3, r2, r2
 803604c:	2700      	movs	r7, #0
 803604e:	42b2      	cmp	r2, r6
 8036050:	41bb      	sbcs	r3, r7
            return LORAMAC_CRYPTO_FAIL_MAX_GAP_FCNT;
 8036052:	bfb4      	ite	lt
 8036054:	2000      	movlt	r0, #0
 8036056:	2008      	movge	r0, #8
 8036058:	e009      	b.n	803606e <LoRaMacCryptoGetFCntDown+0x52>
        fCntDiff = ( int32_t )( ( int64_t )frameFcnt - ( int64_t )( lastDown & 0x0000FFFF ) );
 803605a:	b2a9      	uxth	r1, r5
 803605c:	1a79      	subs	r1, r7, r1
        if( fCntDiff > 0 )
 803605e:	2900      	cmp	r1, #0
 8036060:	dd02      	ble.n	8036068 <LoRaMacCryptoGetFCntDown+0x4c>
            *currentDown = lastDown + fCntDiff;
 8036062:	4429      	add	r1, r5
 8036064:	6021      	str	r1, [r4, #0]
 8036066:	e7e8      	b.n	803603a <LoRaMacCryptoGetFCntDown+0x1e>
        else if( fCntDiff == 0 )
 8036068:	d103      	bne.n	8036072 <LoRaMacCryptoGetFCntDown+0x56>
            *currentDown = lastDown;
 803606a:	6025      	str	r5, [r4, #0]
            return LORAMAC_CRYPTO_FAIL_FCNT_DUPLICATED;
 803606c:	2007      	movs	r0, #7
}
 803606e:	b003      	add	sp, #12
 8036070:	bdf0      	pop	{r4, r5, r6, r7, pc}
            *currentDown = ( lastDown & 0xFFFF0000 ) + 0x10000 + frameFcnt;
 8036072:	0c2b      	lsrs	r3, r5, #16
 8036074:	041b      	lsls	r3, r3, #16
 8036076:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 803607a:	443b      	add	r3, r7
 803607c:	6023      	str	r3, [r4, #0]
 803607e:	e7dc      	b.n	803603a <LoRaMacCryptoGetFCntDown+0x1e>
        return LORAMAC_CRYPTO_ERROR_NPE;
 8036080:	200a      	movs	r0, #10
 8036082:	e7f4      	b.n	803606e <LoRaMacCryptoGetFCntDown+0x52>
 8036084:	20005724 	.word	0x20005724

08036088 <LoRaMacCryptoSetMulticastReference>:
    if( multicastList == NULL )
 8036088:	b128      	cbz	r0, 8036096 <LoRaMacCryptoSetMulticastReference+0xe>
        multicastList[i].DownLinkCounter = &CryptoNvm->FCntList.McFCntDown[i];
 803608a:	4b04      	ldr	r3, [pc, #16]	; (803609c <LoRaMacCryptoSetMulticastReference+0x14>)
 803608c:	681b      	ldr	r3, [r3, #0]
 803608e:	331c      	adds	r3, #28
 8036090:	6203      	str	r3, [r0, #32]
    return LORAMAC_CRYPTO_SUCCESS;
 8036092:	2000      	movs	r0, #0
 8036094:	4770      	bx	lr
        return LORAMAC_CRYPTO_ERROR_NPE;
 8036096:	200a      	movs	r0, #10
}
 8036098:	4770      	bx	lr
 803609a:	bf00      	nop
 803609c:	20005724 	.word	0x20005724

080360a0 <LoRaMacCryptoPrepareJoinRequest>:
{
 80360a0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    if( macMsg == 0 )
 80360a2:	4604      	mov	r4, r0
 80360a4:	b1f0      	cbz	r0, 80360e4 <LoRaMacCryptoPrepareJoinRequest+0x44>
    uint32_t devNonce = 0;
 80360a6:	2300      	movs	r3, #0
    SecureElementRandomNumber( &devNonce );
 80360a8:	a803      	add	r0, sp, #12
    uint32_t devNonce = 0;
 80360aa:	9303      	str	r3, [sp, #12]
    SecureElementRandomNumber( &devNonce );
 80360ac:	f002 fee6 	bl	8038e7c <SecureElementRandomNumber>
    CryptoNvm->DevNonce = devNonce;
 80360b0:	4a0e      	ldr	r2, [pc, #56]	; (80360ec <LoRaMacCryptoPrepareJoinRequest+0x4c>)
 80360b2:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 80360b6:	6812      	ldr	r2, [r2, #0]
    if( LoRaMacSerializerJoinRequest( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 80360b8:	4620      	mov	r0, r4
    CryptoNvm->DevNonce = devNonce;
 80360ba:	8093      	strh	r3, [r2, #4]
    macMsg->DevNonce = CryptoNvm->DevNonce;
 80360bc:	82e3      	strh	r3, [r4, #22]
    if( LoRaMacSerializerJoinRequest( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 80360be:	f000 fa82 	bl	80365c6 <LoRaMacSerializerJoinRequest>
 80360c2:	b960      	cbnz	r0, 80360de <LoRaMacCryptoPrepareJoinRequest+0x3e>
    if( SecureElementComputeAesCmac( NULL, macMsg->Buffer, ( LORAMAC_JOIN_REQ_MSG_SIZE - LORAMAC_MIC_FIELD_SIZE ), micComputationKeyID, &macMsg->MIC ) != SECURE_ELEMENT_SUCCESS )
 80360c4:	f104 0318 	add.w	r3, r4, #24
 80360c8:	9300      	str	r3, [sp, #0]
 80360ca:	6821      	ldr	r1, [r4, #0]
 80360cc:	2301      	movs	r3, #1
 80360ce:	2213      	movs	r2, #19
 80360d0:	f002 fcae 	bl	8038a30 <SecureElementComputeAesCmac>
 80360d4:	b940      	cbnz	r0, 80360e8 <LoRaMacCryptoPrepareJoinRequest+0x48>
    if( LoRaMacSerializerJoinRequest( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 80360d6:	4620      	mov	r0, r4
 80360d8:	f000 fa75 	bl	80365c6 <LoRaMacSerializerJoinRequest>
 80360dc:	b100      	cbz	r0, 80360e0 <LoRaMacCryptoPrepareJoinRequest+0x40>
        return LORAMAC_CRYPTO_ERROR_SERIALIZER;
 80360de:	2011      	movs	r0, #17
}
 80360e0:	b004      	add	sp, #16
 80360e2:	bd10      	pop	{r4, pc}
        return LORAMAC_CRYPTO_ERROR_NPE;
 80360e4:	200a      	movs	r0, #10
 80360e6:	e7fb      	b.n	80360e0 <LoRaMacCryptoPrepareJoinRequest+0x40>
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 80360e8:	200f      	movs	r0, #15
 80360ea:	e7f9      	b.n	80360e0 <LoRaMacCryptoPrepareJoinRequest+0x40>
 80360ec:	20005724 	.word	0x20005724

080360f0 <LoRaMacCryptoSecureMessage>:
{
 80360f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80360f2:	4605      	mov	r5, r0
 80360f4:	b087      	sub	sp, #28
    if( macMsg == NULL )
 80360f6:	461c      	mov	r4, r3
 80360f8:	b323      	cbz	r3, 8036144 <LoRaMacCryptoSecureMessage+0x54>
    if( fCntUp < CryptoNvm->FCntList.FCntUp )
 80360fa:	4e2f      	ldr	r6, [pc, #188]	; (80361b8 <LoRaMacCryptoSecureMessage+0xc8>)
 80360fc:	6833      	ldr	r3, [r6, #0]
 80360fe:	68db      	ldr	r3, [r3, #12]
 8036100:	4283      	cmp	r3, r0
 8036102:	d856      	bhi.n	80361b2 <LoRaMacCryptoSecureMessage+0xc2>
    if( macMsg->FPort == 0 )
 8036104:	f894 2020 	ldrb.w	r2, [r4, #32]
        payloadDecryptionKeyID = NWK_S_KEY;
 8036108:	2a00      	cmp	r2, #0
 803610a:	bf14      	ite	ne
 803610c:	2203      	movne	r2, #3
 803610e:	2202      	moveq	r2, #2
    if( fCntUp > CryptoNvm->FCntList.FCntUp )
 8036110:	4283      	cmp	r3, r0
 8036112:	d305      	bcc.n	8036120 <LoRaMacCryptoSecureMessage+0x30>
    if( LoRaMacSerializerData( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 8036114:	4620      	mov	r0, r4
 8036116:	f000 fa8a 	bl	803662e <LoRaMacSerializerData>
 803611a:	b170      	cbz	r0, 803613a <LoRaMacCryptoSecureMessage+0x4a>
        return LORAMAC_CRYPTO_ERROR_SERIALIZER;
 803611c:	2011      	movs	r0, #17
 803611e:	e00a      	b.n	8036136 <LoRaMacCryptoSecureMessage+0x46>
        retval = PayloadEncrypt( macMsg->FRMPayload, macMsg->FRMPayloadSize, payloadDecryptionKeyID, macMsg->FHDR.DevAddr, UPLINK, fCntUp );
 8036120:	2300      	movs	r3, #0
 8036122:	9001      	str	r0, [sp, #4]
 8036124:	9300      	str	r3, [sp, #0]
 8036126:	68a3      	ldr	r3, [r4, #8]
 8036128:	f894 1028 	ldrb.w	r1, [r4, #40]	; 0x28
 803612c:	6a60      	ldr	r0, [r4, #36]	; 0x24
 803612e:	f7ff fe70 	bl	8035e12 <PayloadEncrypt>
        if( retval != LORAMAC_CRYPTO_SUCCESS )
 8036132:	2800      	cmp	r0, #0
 8036134:	d0ee      	beq.n	8036114 <LoRaMacCryptoSecureMessage+0x24>
}
 8036136:	b007      	add	sp, #28
 8036138:	bdf0      	pop	{r4, r5, r6, r7, pc}
        retval = ComputeCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), payloadDecryptionKeyID, false, UPLINK, macMsg->FHDR.DevAddr, fCntUp, &macMsg->MIC );
 803613a:	7923      	ldrb	r3, [r4, #4]
 803613c:	6821      	ldr	r1, [r4, #0]
 803613e:	3b04      	subs	r3, #4
 8036140:	b29a      	uxth	r2, r3
    if( ( msg == 0 ) || ( cmac == 0 ) )
 8036142:	b909      	cbnz	r1, 8036148 <LoRaMacCryptoSecureMessage+0x58>
        return LORAMAC_CRYPTO_ERROR_NPE;
 8036144:	200a      	movs	r0, #10
 8036146:	e7f6      	b.n	8036136 <LoRaMacCryptoSecureMessage+0x46>
    if( len > CRYPTO_MAXMESSAGE_SIZE )
 8036148:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 803614c:	d82f      	bhi.n	80361ae <LoRaMacCryptoSecureMessage+0xbe>
        retval = ComputeCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), payloadDecryptionKeyID, false, UPLINK, macMsg->FHDR.DevAddr, fCntUp, &macMsg->MIC );
 803614e:	68a7      	ldr	r7, [r4, #8]
    b0[5] = dir;
 8036150:	f8b4 c008 	ldrh.w	ip, [r4, #8]
    b0[6] = devAddr & 0xFF;
 8036154:	f8ad c00e 	strh.w	ip, [sp, #14]
    b0[8] = ( devAddr >> 16 ) & 0xFF;
 8036158:	ea4f 4c17 	mov.w	ip, r7, lsr #16
    b0[9] = ( devAddr >> 24 ) & 0xFF;
 803615c:	0e3f      	lsrs	r7, r7, #24
 803615e:	f88d 7011 	strb.w	r7, [sp, #17]
    b0[15] = msgLen & 0xFF;
 8036162:	f88d 3017 	strb.w	r3, [sp, #23]
    b0[12] = ( fCnt >> 16 ) & 0xFF;
 8036166:	0c2f      	lsrs	r7, r5, #16
        retval = ComputeCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), payloadDecryptionKeyID, false, UPLINK, macMsg->FHDR.DevAddr, fCntUp, &macMsg->MIC );
 8036168:	f104 032c 	add.w	r3, r4, #44	; 0x2c
    b0[0] = 0x49;
 803616c:	f04f 0e49 	mov.w	lr, #73	; 0x49
    b0[4] = 0x00;
 8036170:	f8ad 000c 	strh.w	r0, [sp, #12]
    b0[12] = ( fCnt >> 16 ) & 0xFF;
 8036174:	f88d 7014 	strb.w	r7, [sp, #20]
    b0[14] = 0x00;
 8036178:	f88d 0016 	strb.w	r0, [sp, #22]
    b0[13] = ( fCnt >> 24 ) & 0xFF;
 803617c:	0e2f      	lsrs	r7, r5, #24
    if( SecureElementComputeAesCmac( micBuff, msg, len, keyID, cmac ) != SECURE_ELEMENT_SUCCESS )
 803617e:	9300      	str	r3, [sp, #0]
 8036180:	a802      	add	r0, sp, #8
 8036182:	2302      	movs	r3, #2
    b0[0] = 0x49;
 8036184:	f8cd e008 	str.w	lr, [sp, #8]
    b0[8] = ( devAddr >> 16 ) & 0xFF;
 8036188:	f88d c010 	strb.w	ip, [sp, #16]
    b0[10] = fCnt & 0xFF;
 803618c:	f8ad 5012 	strh.w	r5, [sp, #18]
    b0[13] = ( fCnt >> 24 ) & 0xFF;
 8036190:	f88d 7015 	strb.w	r7, [sp, #21]
    if( SecureElementComputeAesCmac( micBuff, msg, len, keyID, cmac ) != SECURE_ELEMENT_SUCCESS )
 8036194:	f002 fc4c 	bl	8038a30 <SecureElementComputeAesCmac>
 8036198:	b108      	cbz	r0, 803619e <LoRaMacCryptoSecureMessage+0xae>
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 803619a:	200f      	movs	r0, #15
 803619c:	e7cb      	b.n	8036136 <LoRaMacCryptoSecureMessage+0x46>
    if( LoRaMacSerializerData( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 803619e:	4620      	mov	r0, r4
 80361a0:	f000 fa45 	bl	803662e <LoRaMacSerializerData>
 80361a4:	2800      	cmp	r0, #0
 80361a6:	d1b9      	bne.n	803611c <LoRaMacCryptoSecureMessage+0x2c>
    CryptoNvm->FCntList.FCntUp = fCntUp;
 80361a8:	6833      	ldr	r3, [r6, #0]
 80361aa:	60dd      	str	r5, [r3, #12]
    return LORAMAC_CRYPTO_SUCCESS;
 80361ac:	e7c3      	b.n	8036136 <LoRaMacCryptoSecureMessage+0x46>
        return LORAMAC_CRYPTO_ERROR_BUF_SIZE;
 80361ae:	200e      	movs	r0, #14
 80361b0:	e7c1      	b.n	8036136 <LoRaMacCryptoSecureMessage+0x46>
        return LORAMAC_CRYPTO_FAIL_FCNT_SMALLER;
 80361b2:	2006      	movs	r0, #6
 80361b4:	e7bf      	b.n	8036136 <LoRaMacCryptoSecureMessage+0x46>
 80361b6:	bf00      	nop
 80361b8:	20005724 	.word	0x20005724

080361bc <LoRaMacCryptoUnsecureMessage>:
{
 80361bc:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 80361c0:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 80361c2:	4680      	mov	r8, r0
 80361c4:	460f      	mov	r7, r1
 80361c6:	4616      	mov	r6, r2
 80361c8:	461c      	mov	r4, r3
    if( macMsg == 0 )
 80361ca:	2d00      	cmp	r5, #0
 80361cc:	d059      	beq.n	8036282 <LoRaMacCryptoUnsecureMessage+0xc6>
    uint32_t lastDown = 0;
 80361ce:	2300      	movs	r3, #0
    if( GetLastFcntDown( fCntID, &lastDown ) != LORAMAC_CRYPTO_SUCCESS )
 80361d0:	a903      	add	r1, sp, #12
 80361d2:	4610      	mov	r0, r2
    uint32_t lastDown = 0;
 80361d4:	9303      	str	r3, [sp, #12]
    if( GetLastFcntDown( fCntID, &lastDown ) != LORAMAC_CRYPTO_SUCCESS )
 80361d6:	f7ff fe77 	bl	8035ec8 <GetLastFcntDown>
 80361da:	b118      	cbz	r0, 80361e4 <LoRaMacCryptoUnsecureMessage+0x28>
        return LORAMAC_CRYPTO_FAIL_FCNT_SMALLER;
 80361dc:	2006      	movs	r0, #6
}
 80361de:	b004      	add	sp, #16
 80361e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if( ( currentDown > lastDown ) ||
 80361e4:	9b03      	ldr	r3, [sp, #12]
 80361e6:	429c      	cmp	r4, r3
 80361e8:	d801      	bhi.n	80361ee <LoRaMacCryptoUnsecureMessage+0x32>
 80361ea:	3301      	adds	r3, #1
 80361ec:	d1f6      	bne.n	80361dc <LoRaMacCryptoUnsecureMessage+0x20>
    if( LoRaMacParserData( macMsg ) != LORAMAC_PARSER_SUCCESS )
 80361ee:	4628      	mov	r0, r5
 80361f0:	f000 f98e 	bl	8036510 <LoRaMacParserData>
 80361f4:	2800      	cmp	r0, #0
 80361f6:	d146      	bne.n	8036286 <LoRaMacCryptoUnsecureMessage+0xca>
        if( KeyAddrList[i].AddrID == addrID )
 80361f8:	4b26      	ldr	r3, [pc, #152]	; (8036294 <LoRaMacCryptoUnsecureMessage+0xd8>)
 80361fa:	781a      	ldrb	r2, [r3, #0]
 80361fc:	4542      	cmp	r2, r8
 80361fe:	d003      	beq.n	8036208 <LoRaMacCryptoUnsecureMessage+0x4c>
 8036200:	791a      	ldrb	r2, [r3, #4]
 8036202:	4542      	cmp	r2, r8
 8036204:	d141      	bne.n	803628a <LoRaMacCryptoUnsecureMessage+0xce>
 8036206:	2001      	movs	r0, #1
    if( address != macMsg->FHDR.DevAddr )
 8036208:	68aa      	ldr	r2, [r5, #8]
 803620a:	42ba      	cmp	r2, r7
 803620c:	d13f      	bne.n	803628e <LoRaMacCryptoUnsecureMessage+0xd2>
    payloadDecryptionKeyID = curItem->AppSkey;
 803620e:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    retval = VerifyCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), micComputationKeyID, isAck, DOWNLINK, address, fCntDown, macMsg->MIC );
 8036212:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    payloadDecryptionKeyID = curItem->AppSkey;
 8036214:	f890 8001 	ldrb.w	r8, [r0, #1]
    retval = VerifyCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), micComputationKeyID, isAck, DOWNLINK, address, fCntDown, macMsg->MIC );
 8036218:	7929      	ldrb	r1, [r5, #4]
 803621a:	e9cd 4300 	strd	r4, r3, [sp]
 803621e:	3904      	subs	r1, #4
 8036220:	7882      	ldrb	r2, [r0, #2]
 8036222:	6828      	ldr	r0, [r5, #0]
 8036224:	463b      	mov	r3, r7
 8036226:	b289      	uxth	r1, r1
 8036228:	f7ff fe83 	bl	8035f32 <VerifyCmacB0.isra.0.constprop.0>
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 803622c:	2800      	cmp	r0, #0
 803622e:	d1d6      	bne.n	80361de <LoRaMacCryptoUnsecureMessage+0x22>
    if( macMsg->FPort == 0 )
 8036230:	f895 3020 	ldrb.w	r3, [r5, #32]
    retval = PayloadEncrypt( macMsg->FRMPayload, macMsg->FRMPayloadSize, payloadDecryptionKeyID, address, DOWNLINK, fCntDown );
 8036234:	9401      	str	r4, [sp, #4]
        payloadDecryptionKeyID = NWK_S_KEY;
 8036236:	2b00      	cmp	r3, #0
    retval = PayloadEncrypt( macMsg->FRMPayload, macMsg->FRMPayloadSize, payloadDecryptionKeyID, address, DOWNLINK, fCntDown );
 8036238:	f04f 0301 	mov.w	r3, #1
 803623c:	9300      	str	r3, [sp, #0]
 803623e:	bf14      	ite	ne
 8036240:	4642      	movne	r2, r8
 8036242:	2202      	moveq	r2, #2
 8036244:	f895 1028 	ldrb.w	r1, [r5, #40]	; 0x28
 8036248:	6a68      	ldr	r0, [r5, #36]	; 0x24
 803624a:	463b      	mov	r3, r7
 803624c:	f7ff fde1 	bl	8035e12 <PayloadEncrypt>
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 8036250:	2800      	cmp	r0, #0
 8036252:	d1c4      	bne.n	80361de <LoRaMacCryptoUnsecureMessage+0x22>
    switch( fCntID )
 8036254:	3e01      	subs	r6, #1
 8036256:	2e03      	cmp	r6, #3
 8036258:	d8c1      	bhi.n	80361de <LoRaMacCryptoUnsecureMessage+0x22>
 803625a:	e8df f006 	tbb	[pc, r6]
 803625e:	0602      	.short	0x0602
 8036260:	0e0a      	.short	0x0e0a
            CryptoNvm->FCntList.NFCntDown = currentDown;
 8036262:	4b0d      	ldr	r3, [pc, #52]	; (8036298 <LoRaMacCryptoUnsecureMessage+0xdc>)
 8036264:	681b      	ldr	r3, [r3, #0]
 8036266:	611c      	str	r4, [r3, #16]
            break;
 8036268:	e7b9      	b.n	80361de <LoRaMacCryptoUnsecureMessage+0x22>
            CryptoNvm->FCntList.AFCntDown = currentDown;
 803626a:	4b0b      	ldr	r3, [pc, #44]	; (8036298 <LoRaMacCryptoUnsecureMessage+0xdc>)
 803626c:	681b      	ldr	r3, [r3, #0]
 803626e:	615c      	str	r4, [r3, #20]
            break;
 8036270:	e7b5      	b.n	80361de <LoRaMacCryptoUnsecureMessage+0x22>
            CryptoNvm->FCntList.FCntDown = currentDown;
 8036272:	4b09      	ldr	r3, [pc, #36]	; (8036298 <LoRaMacCryptoUnsecureMessage+0xdc>)
 8036274:	681b      	ldr	r3, [r3, #0]
 8036276:	619c      	str	r4, [r3, #24]
            break;
 8036278:	e7b1      	b.n	80361de <LoRaMacCryptoUnsecureMessage+0x22>
            CryptoNvm->FCntList.McFCntDown[0] = currentDown;
 803627a:	4b07      	ldr	r3, [pc, #28]	; (8036298 <LoRaMacCryptoUnsecureMessage+0xdc>)
 803627c:	681b      	ldr	r3, [r3, #0]
 803627e:	61dc      	str	r4, [r3, #28]
            break;
 8036280:	e7ad      	b.n	80361de <LoRaMacCryptoUnsecureMessage+0x22>
        return LORAMAC_CRYPTO_ERROR_NPE;
 8036282:	200a      	movs	r0, #10
 8036284:	e7ab      	b.n	80361de <LoRaMacCryptoUnsecureMessage+0x22>
        return LORAMAC_CRYPTO_ERROR_PARSER;
 8036286:	2010      	movs	r0, #16
 8036288:	e7a9      	b.n	80361de <LoRaMacCryptoUnsecureMessage+0x22>
    return LORAMAC_CRYPTO_ERROR_INVALID_ADDR_ID;
 803628a:	200c      	movs	r0, #12
 803628c:	e7a7      	b.n	80361de <LoRaMacCryptoUnsecureMessage+0x22>
        return LORAMAC_CRYPTO_FAIL_ADDRESS;
 803628e:	2002      	movs	r0, #2
 8036290:	e7a5      	b.n	80361de <LoRaMacCryptoUnsecureMessage+0x22>
 8036292:	bf00      	nop
 8036294:	20003594 	.word	0x20003594
 8036298:	20005724 	.word	0x20005724

0803629c <LoRaMacCryptoDeriveMcRootKey>:
{
 803629c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    if( keyID != APP_KEY )
 803629e:	b9b1      	cbnz	r1, 80362ce <LoRaMacCryptoDeriveMcRootKey+0x32>
    if( versionMinor == 1 )
 80362a0:	2801      	cmp	r0, #1
    uint8_t compBase[16] = { 0 };
 80362a2:	e9cd 1100 	strd	r1, r1, [sp]
        compBase[0] = 0x20;
 80362a6:	bf08      	it	eq
 80362a8:	2320      	moveq	r3, #32
    uint8_t compBase[16] = { 0 };
 80362aa:	e9cd 1102 	strd	r1, r1, [sp, #8]
    if( SecureElementDeriveAndStoreKey( compBase, keyID, MC_ROOT_KEY ) != SECURE_ELEMENT_SUCCESS )
 80362ae:	f04f 0204 	mov.w	r2, #4
 80362b2:	f04f 0100 	mov.w	r1, #0
 80362b6:	4668      	mov	r0, sp
        compBase[0] = 0x20;
 80362b8:	bf08      	it	eq
 80362ba:	f88d 3000 	strbeq.w	r3, [sp]
    if( SecureElementDeriveAndStoreKey( compBase, keyID, MC_ROOT_KEY ) != SECURE_ELEMENT_SUCCESS )
 80362be:	f002 fd43 	bl	8038d48 <SecureElementDeriveAndStoreKey>
 80362c2:	2800      	cmp	r0, #0
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 80362c4:	bf18      	it	ne
 80362c6:	200f      	movne	r0, #15
}
 80362c8:	b005      	add	sp, #20
 80362ca:	f85d fb04 	ldr.w	pc, [sp], #4
        return LORAMAC_CRYPTO_ERROR_INVALID_KEY_ID;
 80362ce:	200b      	movs	r0, #11
 80362d0:	e7fa      	b.n	80362c8 <LoRaMacCryptoDeriveMcRootKey+0x2c>
	...

080362d4 <LoRaMacCryptoSetKey>:
{
 80362d4:	b538      	push	{r3, r4, r5, lr}
 80362d6:	4605      	mov	r5, r0
    if( SecureElementSetKey( keyID, key ) != SECURE_ELEMENT_SUCCESS )
 80362d8:	f002 fcb0 	bl	8038c3c <SecureElementSetKey>
 80362dc:	4604      	mov	r4, r0
 80362de:	b950      	cbnz	r0, 80362f6 <LoRaMacCryptoSetKey+0x22>
    if( keyID == APP_KEY )
 80362e0:	b955      	cbnz	r5, 80362f8 <LoRaMacCryptoSetKey+0x24>
        if( LoRaMacCryptoDeriveMcRootKey( CryptoNvm->LrWanVersion.Fields.Minor, keyID ) != LORAMAC_CRYPTO_SUCCESS )
 80362e2:	4b06      	ldr	r3, [pc, #24]	; (80362fc <LoRaMacCryptoSetKey+0x28>)
 80362e4:	681b      	ldr	r3, [r3, #0]
 80362e6:	4601      	mov	r1, r0
 80362e8:	7898      	ldrb	r0, [r3, #2]
 80362ea:	f7ff ffd7 	bl	803629c <LoRaMacCryptoDeriveMcRootKey>
 80362ee:	b910      	cbnz	r0, 80362f6 <LoRaMacCryptoSetKey+0x22>
    if( keyID != MC_ROOT_KEY )
 80362f0:	f7ff fe0e 	bl	8035f10 <LoRaMacCryptoDeriveMcKEKey.part.0>
        if( LoRaMacCryptoDeriveMcKEKey( MC_ROOT_KEY ) != LORAMAC_CRYPTO_SUCCESS )
 80362f4:	b100      	cbz	r0, 80362f8 <LoRaMacCryptoSetKey+0x24>
            return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 80362f6:	240f      	movs	r4, #15
}
 80362f8:	4620      	mov	r0, r4
 80362fa:	bd38      	pop	{r3, r4, r5, pc}
 80362fc:	20005724 	.word	0x20005724

08036300 <LoRaMacCryptoHandleJoinAccept>:
{
 8036300:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8036304:	4680      	mov	r8, r0
 8036306:	b08f      	sub	sp, #60	; 0x3c
 8036308:	460d      	mov	r5, r1
    if( ( macMsg == 0 ) || ( joinEUI == 0 ) )
 803630a:	4614      	mov	r4, r2
 803630c:	2a00      	cmp	r2, #0
 803630e:	d05f      	beq.n	80363d0 <LoRaMacCryptoHandleJoinAccept+0xd0>
 8036310:	2900      	cmp	r1, #0
 8036312:	d05d      	beq.n	80363d0 <LoRaMacCryptoHandleJoinAccept+0xd0>
    uint8_t decJoinAccept[LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE] = { 0 };
 8036314:	2600      	movs	r6, #0
 8036316:	4631      	mov	r1, r6
 8036318:	221d      	movs	r2, #29
 803631a:	a806      	add	r0, sp, #24
 803631c:	9605      	str	r6, [sp, #20]
 803631e:	f005 fa33 	bl	803b788 <memset>
    uint8_t versionMinor         = 0;
 8036322:	f88d 6013 	strb.w	r6, [sp, #19]
    uint16_t nonce               = CryptoNvm->DevNonce;
 8036326:	4e2e      	ldr	r6, [pc, #184]	; (80363e0 <LoRaMacCryptoHandleJoinAccept+0xe0>)
 8036328:	6833      	ldr	r3, [r6, #0]
    if( SecureElementProcessJoinAccept( joinReqType, joinEUI, nonce, macMsg->Buffer,
 803632a:	f10d 0914 	add.w	r9, sp, #20
    uint16_t nonce               = CryptoNvm->DevNonce;
 803632e:	889f      	ldrh	r7, [r3, #4]
    if( SecureElementProcessJoinAccept( joinReqType, joinEUI, nonce, macMsg->Buffer,
 8036330:	f8cd 9004 	str.w	r9, [sp, #4]
 8036334:	f10d 0313 	add.w	r3, sp, #19
 8036338:	9302      	str	r3, [sp, #8]
 803633a:	7923      	ldrb	r3, [r4, #4]
 803633c:	9300      	str	r3, [sp, #0]
 803633e:	6823      	ldr	r3, [r4, #0]
 8036340:	463a      	mov	r2, r7
 8036342:	4629      	mov	r1, r5
 8036344:	4640      	mov	r0, r8
 8036346:	f002 fd55 	bl	8038df4 <SecureElementProcessJoinAccept>
 803634a:	2800      	cmp	r0, #0
 803634c:	d142      	bne.n	80363d4 <LoRaMacCryptoHandleJoinAccept+0xd4>
    memcpy1( macMsg->Buffer, decJoinAccept, macMsg->BufSize );
 803634e:	4649      	mov	r1, r9
 8036350:	7922      	ldrb	r2, [r4, #4]
 8036352:	6820      	ldr	r0, [r4, #0]
 8036354:	f002 fdec 	bl	8038f30 <memcpy1>
    if( LoRaMacParserJoinAccept( macMsg ) != LORAMAC_PARSER_SUCCESS )
 8036358:	4620      	mov	r0, r4
 803635a:	f000 f88b 	bl	8036474 <LoRaMacParserJoinAccept>
 803635e:	4601      	mov	r1, r0
 8036360:	2800      	cmp	r0, #0
 8036362:	d139      	bne.n	80363d8 <LoRaMacCryptoHandleJoinAccept+0xd8>
    currentJoinNonce |= ( ( uint32_t )macMsg->JoinNonce[2] << 16 );
 8036364:	7a25      	ldrb	r5, [r4, #8]
    currentJoinNonce |= ( ( uint32_t )macMsg->JoinNonce[1] << 8 );
 8036366:	79e2      	ldrb	r2, [r4, #7]
    currentJoinNonce = ( uint32_t )macMsg->JoinNonce[0];
 8036368:	79a3      	ldrb	r3, [r4, #6]
    currentJoinNonce |= ( ( uint32_t )macMsg->JoinNonce[2] << 16 );
 803636a:	042d      	lsls	r5, r5, #16
 803636c:	ea45 2502 	orr.w	r5, r5, r2, lsl #8
 8036370:	431d      	orrs	r5, r3
    if( currentJoinNonce != CryptoNvm->JoinNonce )
 8036372:	6833      	ldr	r3, [r6, #0]
 8036374:	689a      	ldr	r2, [r3, #8]
 8036376:	42aa      	cmp	r2, r5
 8036378:	d030      	beq.n	80363dc <LoRaMacCryptoHandleJoinAccept+0xdc>
    retval = LoRaMacCryptoDeriveMcRootKey( versionMinor, APP_KEY );
 803637a:	f89d 0013 	ldrb.w	r0, [sp, #19]
        CryptoNvm->JoinNonce = currentJoinNonce;
 803637e:	609d      	str	r5, [r3, #8]
    retval = LoRaMacCryptoDeriveMcRootKey( versionMinor, APP_KEY );
 8036380:	f7ff ff8c 	bl	803629c <LoRaMacCryptoDeriveMcRootKey>
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 8036384:	bb08      	cbnz	r0, 80363ca <LoRaMacCryptoHandleJoinAccept+0xca>
    if( keyID != MC_ROOT_KEY )
 8036386:	f7ff fdc3 	bl	8035f10 <LoRaMacCryptoDeriveMcKEKey.part.0>
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 803638a:	b9f0      	cbnz	r0, 80363ca <LoRaMacCryptoHandleJoinAccept+0xca>
        netID = ( uint32_t )macMsg->NetID[0];
 803638c:	7a62      	ldrb	r2, [r4, #9]
        netID |= ( ( uint32_t )macMsg->NetID[1] << 8 );
 803638e:	7aa3      	ldrb	r3, [r4, #10]
        netID |= ( ( uint32_t )macMsg->NetID[2] << 16 );
 8036390:	7ae4      	ldrb	r4, [r4, #11]
 8036392:	0424      	lsls	r4, r4, #16
 8036394:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
 8036398:	4314      	orrs	r4, r2
        retval = DeriveSessionKey10x( APP_S_KEY, currentJoinNonce, netID, nonce );
 803639a:	463b      	mov	r3, r7
 803639c:	4622      	mov	r2, r4
 803639e:	4629      	mov	r1, r5
 80363a0:	2003      	movs	r0, #3
 80363a2:	f7ff fd13 	bl	8035dcc <DeriveSessionKey10x>
        if( retval != LORAMAC_CRYPTO_SUCCESS )
 80363a6:	b980      	cbnz	r0, 80363ca <LoRaMacCryptoHandleJoinAccept+0xca>
        retval = DeriveSessionKey10x( NWK_S_KEY, currentJoinNonce, netID, nonce );
 80363a8:	463b      	mov	r3, r7
 80363aa:	4622      	mov	r2, r4
 80363ac:	4629      	mov	r1, r5
 80363ae:	2002      	movs	r0, #2
 80363b0:	f7ff fd0c 	bl	8035dcc <DeriveSessionKey10x>
        if( retval != LORAMAC_CRYPTO_SUCCESS )
 80363b4:	b948      	cbnz	r0, 80363ca <LoRaMacCryptoHandleJoinAccept+0xca>
    CryptoNvm->LrWanVersion.Fields.Minor = versionMinor;
 80363b6:	6833      	ldr	r3, [r6, #0]
 80363b8:	f89d 2013 	ldrb.w	r2, [sp, #19]
 80363bc:	709a      	strb	r2, [r3, #2]
    CryptoNvm->FCntList.FCntDown = FCNT_DOWN_INITAL_VALUE;
 80363be:	f04f 32ff 	mov.w	r2, #4294967295
    CryptoNvm->FCntList.AFCntDown = FCNT_DOWN_INITAL_VALUE;
 80363c2:	e9c3 2204 	strd	r2, r2, [r3, #16]
    CryptoNvm->FCntList.FCntUp = 0;
 80363c6:	60d8      	str	r0, [r3, #12]
    CryptoNvm->FCntList.FCntDown = FCNT_DOWN_INITAL_VALUE;
 80363c8:	619a      	str	r2, [r3, #24]
}
 80363ca:	b00f      	add	sp, #60	; 0x3c
 80363cc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        return LORAMAC_CRYPTO_ERROR_NPE;
 80363d0:	200a      	movs	r0, #10
 80363d2:	e7fa      	b.n	80363ca <LoRaMacCryptoHandleJoinAccept+0xca>
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 80363d4:	200f      	movs	r0, #15
 80363d6:	e7f8      	b.n	80363ca <LoRaMacCryptoHandleJoinAccept+0xca>
        return LORAMAC_CRYPTO_ERROR_PARSER;
 80363d8:	2010      	movs	r0, #16
 80363da:	e7f6      	b.n	80363ca <LoRaMacCryptoHandleJoinAccept+0xca>
        return LORAMAC_CRYPTO_FAIL_JOIN_NONCE;
 80363dc:	2003      	movs	r0, #3
 80363de:	e7f4      	b.n	80363ca <LoRaMacCryptoHandleJoinAccept+0xca>
 80363e0:	20005724 	.word	0x20005724

080363e4 <LoRaMacCryptoDeriveMcSessionKeyPair>:

LoRaMacCryptoStatus_t LoRaMacCryptoDeriveMcSessionKeyPair( AddressIdentifier_t addrID, uint32_t mcAddr )
{
 80363e4:	b570      	push	{r4, r5, r6, lr}
 80363e6:	b088      	sub	sp, #32
    if( mcAddr == 0 )
 80363e8:	2900      	cmp	r1, #0
 80363ea:	d03d      	beq.n	8036468 <LoRaMacCryptoDeriveMcSessionKeyPair+0x84>
        if( KeyAddrList[i].AddrID == addrID )
 80363ec:	4c20      	ldr	r4, [pc, #128]	; (8036470 <LoRaMacCryptoDeriveMcSessionKeyPair+0x8c>)
 80363ee:	7823      	ldrb	r3, [r4, #0]
 80363f0:	4283      	cmp	r3, r0
 80363f2:	d037      	beq.n	8036464 <LoRaMacCryptoDeriveMcSessionKeyPair+0x80>
 80363f4:	7923      	ldrb	r3, [r4, #4]
 80363f6:	4283      	cmp	r3, r0
 80363f8:	d138      	bne.n	803646c <LoRaMacCryptoDeriveMcSessionKeyPair+0x88>
 80363fa:	2201      	movs	r2, #1
    }

    // McAppSKey = aes128_encrypt(McKey, 0x01 | McAddr | pad16)
    // McNwkSKey = aes128_encrypt(McKey, 0x02 | McAddr | pad16)

    uint8_t compBaseAppS[16] = { 0 };
 80363fc:	2300      	movs	r3, #0
 80363fe:	e9cd 3301 	strd	r3, r3, [sp, #4]
    uint8_t compBaseNwkS[16] = { 0 };
 8036402:	e9cd 3305 	strd	r3, r3, [sp, #20]
    compBaseNwkS[1] = mcAddr & 0xFF;
    compBaseNwkS[2] = ( mcAddr >> 8 ) & 0xFF;
    compBaseNwkS[3] = ( mcAddr >> 16 ) & 0xFF;
    compBaseNwkS[4] = ( mcAddr >> 24 ) & 0xFF;

    if( SecureElementDeriveAndStoreKey( compBaseAppS, curItem->RootKey, curItem->AppSkey ) != SECURE_ELEMENT_SUCCESS )
 8036406:	eb04 0482 	add.w	r4, r4, r2, lsl #2
    uint8_t compBaseAppS[16] = { 0 };
 803640a:	9303      	str	r3, [sp, #12]
    uint8_t compBaseNwkS[16] = { 0 };
 803640c:	9307      	str	r3, [sp, #28]
    compBaseAppS[0] = 0x01;
 803640e:	2301      	movs	r3, #1
    compBaseAppS[2] = ( mcAddr >> 8 ) & 0xFF;
 8036410:	f3c1 2007 	ubfx	r0, r1, #8, #8
    compBaseAppS[1] = mcAddr & 0xFF;
 8036414:	b2cd      	uxtb	r5, r1
    compBaseAppS[0] = 0x01;
 8036416:	f88d 3000 	strb.w	r3, [sp]
    compBaseAppS[3] = ( mcAddr >> 16 ) & 0xFF;
 803641a:	f3c1 4307 	ubfx	r3, r1, #16, #8
    compBaseAppS[4] = ( mcAddr >> 24 ) & 0xFF;
 803641e:	0e09      	lsrs	r1, r1, #24
    compBaseAppS[2] = ( mcAddr >> 8 ) & 0xFF;
 8036420:	f88d 0002 	strb.w	r0, [sp, #2]
    compBaseAppS[4] = ( mcAddr >> 24 ) & 0xFF;
 8036424:	f88d 1004 	strb.w	r1, [sp, #4]
    compBaseNwkS[0] = 0x02;
 8036428:	2602      	movs	r6, #2
    compBaseNwkS[2] = ( mcAddr >> 8 ) & 0xFF;
 803642a:	f88d 0012 	strb.w	r0, [sp, #18]
    compBaseNwkS[4] = ( mcAddr >> 24 ) & 0xFF;
 803642e:	f88d 1014 	strb.w	r1, [sp, #20]
    if( SecureElementDeriveAndStoreKey( compBaseAppS, curItem->RootKey, curItem->AppSkey ) != SECURE_ELEMENT_SUCCESS )
 8036432:	7862      	ldrb	r2, [r4, #1]
 8036434:	78e1      	ldrb	r1, [r4, #3]
    compBaseAppS[1] = mcAddr & 0xFF;
 8036436:	f88d 5001 	strb.w	r5, [sp, #1]
    if( SecureElementDeriveAndStoreKey( compBaseAppS, curItem->RootKey, curItem->AppSkey ) != SECURE_ELEMENT_SUCCESS )
 803643a:	4668      	mov	r0, sp
    compBaseAppS[3] = ( mcAddr >> 16 ) & 0xFF;
 803643c:	f88d 3003 	strb.w	r3, [sp, #3]
    compBaseNwkS[0] = 0x02;
 8036440:	f88d 6010 	strb.w	r6, [sp, #16]
    compBaseNwkS[1] = mcAddr & 0xFF;
 8036444:	f88d 5011 	strb.w	r5, [sp, #17]
    compBaseNwkS[3] = ( mcAddr >> 16 ) & 0xFF;
 8036448:	f88d 3013 	strb.w	r3, [sp, #19]
    if( SecureElementDeriveAndStoreKey( compBaseAppS, curItem->RootKey, curItem->AppSkey ) != SECURE_ELEMENT_SUCCESS )
 803644c:	f002 fc7c 	bl	8038d48 <SecureElementDeriveAndStoreKey>
 8036450:	b928      	cbnz	r0, 803645e <LoRaMacCryptoDeriveMcSessionKeyPair+0x7a>
    {
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
    }

    if( SecureElementDeriveAndStoreKey( compBaseNwkS, curItem->RootKey, curItem->NwkSkey ) != SECURE_ELEMENT_SUCCESS )
 8036452:	78a2      	ldrb	r2, [r4, #2]
 8036454:	78e1      	ldrb	r1, [r4, #3]
 8036456:	a804      	add	r0, sp, #16
 8036458:	f002 fc76 	bl	8038d48 <SecureElementDeriveAndStoreKey>
 803645c:	b100      	cbz	r0, 8036460 <LoRaMacCryptoDeriveMcSessionKeyPair+0x7c>
    {
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 803645e:	200f      	movs	r0, #15
    }

    return LORAMAC_CRYPTO_SUCCESS;
}
 8036460:	b008      	add	sp, #32
 8036462:	bd70      	pop	{r4, r5, r6, pc}
        if( KeyAddrList[i].AddrID == addrID )
 8036464:	2200      	movs	r2, #0
 8036466:	e7c9      	b.n	80363fc <LoRaMacCryptoDeriveMcSessionKeyPair+0x18>
        return LORAMAC_CRYPTO_ERROR_NPE;
 8036468:	200a      	movs	r0, #10
 803646a:	e7f9      	b.n	8036460 <LoRaMacCryptoDeriveMcSessionKeyPair+0x7c>
    return LORAMAC_CRYPTO_ERROR_INVALID_ADDR_ID;
 803646c:	200c      	movs	r0, #12
 803646e:	e7f7      	b.n	8036460 <LoRaMacCryptoDeriveMcSessionKeyPair+0x7c>
 8036470:	20003594 	.word	0x20003594

08036474 <LoRaMacParserJoinAccept>:
 */
#include "LoRaMacParser.h"
#include "utilities.h"

LoRaMacParserStatus_t LoRaMacParserJoinAccept( LoRaMacMessageJoinAccept_t* macMsg )
{
 8036474:	b510      	push	{r4, lr}
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 8036476:	4604      	mov	r4, r0
 8036478:	2800      	cmp	r0, #0
 803647a:	d045      	beq.n	8036508 <LoRaMacParserJoinAccept+0x94>
 803647c:	6801      	ldr	r1, [r0, #0]
 803647e:	2900      	cmp	r1, #0
 8036480:	d042      	beq.n	8036508 <LoRaMacParserJoinAccept+0x94>
        return LORAMAC_PARSER_ERROR_NPE;
    }

    uint16_t bufItr = 0;

    macMsg->MHDR.Value = macMsg->Buffer[bufItr++];
 8036482:	f811 3b01 	ldrb.w	r3, [r1], #1
 8036486:	7143      	strb	r3, [r0, #5]

    memcpy1( macMsg->JoinNonce, &macMsg->Buffer[bufItr], 3 );
 8036488:	2203      	movs	r2, #3
 803648a:	3006      	adds	r0, #6
 803648c:	f002 fd50 	bl	8038f30 <memcpy1>
    bufItr = bufItr + 3;

    memcpy1( macMsg->NetID, &macMsg->Buffer[bufItr], 3 );
 8036490:	4620      	mov	r0, r4
 8036492:	2203      	movs	r2, #3
 8036494:	f850 1b09 	ldr.w	r1, [r0], #9
 8036498:	3104      	adds	r1, #4
 803649a:	f002 fd49 	bl	8038f30 <memcpy1>
    bufItr = bufItr + 3;

    macMsg->DevAddr = ( uint32_t ) macMsg->Buffer[bufItr++];
 803649e:	6821      	ldr	r1, [r4, #0]
 80364a0:	79cb      	ldrb	r3, [r1, #7]
 80364a2:	60e3      	str	r3, [r4, #12]
    macMsg->DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 80364a4:	7a0a      	ldrb	r2, [r1, #8]
 80364a6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80364aa:	60e3      	str	r3, [r4, #12]
    macMsg->DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 80364ac:	7a4a      	ldrb	r2, [r1, #9]
 80364ae:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80364b2:	60e3      	str	r3, [r4, #12]
    macMsg->DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 24 );
 80364b4:	7a8a      	ldrb	r2, [r1, #10]
 80364b6:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80364ba:	60e3      	str	r3, [r4, #12]

    macMsg->DLSettings.Value = macMsg->Buffer[bufItr++];
 80364bc:	7acb      	ldrb	r3, [r1, #11]
 80364be:	7423      	strb	r3, [r4, #16]

    macMsg->RxDelay = macMsg->Buffer[bufItr++];
 80364c0:	7b0b      	ldrb	r3, [r1, #12]
 80364c2:	7463      	strb	r3, [r4, #17]

    if( ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE - bufItr ) == LORAMAC_CF_LIST_FIELD_SIZE )
 80364c4:	7923      	ldrb	r3, [r4, #4]
 80364c6:	2b21      	cmp	r3, #33	; 0x21
 80364c8:	d11a      	bne.n	8036500 <LoRaMacParserJoinAccept+0x8c>
    {
        memcpy1( macMsg->CFList, &macMsg->Buffer[bufItr], LORAMAC_CF_LIST_FIELD_SIZE );
 80364ca:	2210      	movs	r2, #16
 80364cc:	310d      	adds	r1, #13
 80364ce:	f104 0012 	add.w	r0, r4, #18
 80364d2:	f002 fd2d 	bl	8038f30 <memcpy1>
        bufItr = bufItr + LORAMAC_CF_LIST_FIELD_SIZE;
 80364d6:	221d      	movs	r2, #29
    else if( ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE - bufItr ) > 0 )
    {
        return LORAMAC_PARSER_FAIL;
    }

    macMsg->MIC = ( uint32_t ) macMsg->Buffer[bufItr++];
 80364d8:	6821      	ldr	r1, [r4, #0]
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 80364da:	1c50      	adds	r0, r2, #1
    macMsg->MIC = ( uint32_t ) macMsg->Buffer[bufItr++];
 80364dc:	5c8b      	ldrb	r3, [r1, r2]
 80364de:	6263      	str	r3, [r4, #36]	; 0x24
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 80364e0:	5c08      	ldrb	r0, [r1, r0]
 80364e2:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 80364e6:	1c90      	adds	r0, r2, #2
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 80364e8:	6263      	str	r3, [r4, #36]	; 0x24
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 80364ea:	5c08      	ldrb	r0, [r1, r0]
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 24 );
 80364ec:	3203      	adds	r2, #3
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 80364ee:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
 80364f2:	6263      	str	r3, [r4, #36]	; 0x24
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 24 );
 80364f4:	5c8a      	ldrb	r2, [r1, r2]
 80364f6:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80364fa:	6263      	str	r3, [r4, #36]	; 0x24

    return LORAMAC_PARSER_SUCCESS;
 80364fc:	2000      	movs	r0, #0
}
 80364fe:	bd10      	pop	{r4, pc}
    else if( ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE - bufItr ) > 0 )
 8036500:	2b11      	cmp	r3, #17
 8036502:	dc03      	bgt.n	803650c <LoRaMacParserJoinAccept+0x98>
    macMsg->RxDelay = macMsg->Buffer[bufItr++];
 8036504:	220d      	movs	r2, #13
 8036506:	e7e7      	b.n	80364d8 <LoRaMacParserJoinAccept+0x64>
        return LORAMAC_PARSER_ERROR_NPE;
 8036508:	2002      	movs	r0, #2
 803650a:	e7f8      	b.n	80364fe <LoRaMacParserJoinAccept+0x8a>
        return LORAMAC_PARSER_FAIL;
 803650c:	2001      	movs	r0, #1
 803650e:	e7f6      	b.n	80364fe <LoRaMacParserJoinAccept+0x8a>

08036510 <LoRaMacParserData>:

LoRaMacParserStatus_t LoRaMacParserData( LoRaMacMessageData_t* macMsg )
{
 8036510:	b510      	push	{r4, lr}
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 8036512:	4604      	mov	r4, r0
 8036514:	2800      	cmp	r0, #0
 8036516:	d054      	beq.n	80365c2 <LoRaMacParserData+0xb2>
 8036518:	6801      	ldr	r1, [r0, #0]
 803651a:	2900      	cmp	r1, #0
 803651c:	d051      	beq.n	80365c2 <LoRaMacParserData+0xb2>
        return LORAMAC_PARSER_ERROR_NPE;
    }

    uint16_t bufItr = 0;

    macMsg->MHDR.Value = macMsg->Buffer[bufItr++];
 803651e:	780b      	ldrb	r3, [r1, #0]
 8036520:	7143      	strb	r3, [r0, #5]

    macMsg->FHDR.DevAddr = macMsg->Buffer[bufItr++];
 8036522:	784b      	ldrb	r3, [r1, #1]
 8036524:	6083      	str	r3, [r0, #8]
    macMsg->FHDR.DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 8036526:	788a      	ldrb	r2, [r1, #2]
 8036528:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 803652c:	6083      	str	r3, [r0, #8]
    macMsg->FHDR.DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 803652e:	78ca      	ldrb	r2, [r1, #3]
 8036530:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8036534:	6083      	str	r3, [r0, #8]
    macMsg->FHDR.DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 24 );
 8036536:	790a      	ldrb	r2, [r1, #4]
 8036538:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 803653c:	6083      	str	r3, [r0, #8]

    macMsg->FHDR.FCtrl.Value = macMsg->Buffer[bufItr++];
 803653e:	794b      	ldrb	r3, [r1, #5]
 8036540:	7303      	strb	r3, [r0, #12]

    macMsg->FHDR.FCnt = macMsg->Buffer[bufItr++];
 8036542:	798b      	ldrb	r3, [r1, #6]
 8036544:	81c3      	strh	r3, [r0, #14]
    macMsg->FHDR.FCnt |= macMsg->Buffer[bufItr++] << 8;
 8036546:	79ca      	ldrb	r2, [r1, #7]
 8036548:	ea43 2302 	orr.w	r3, r3, r2, lsl #8

    if( macMsg->FHDR.FCtrl.Bits.FOptsLen <= 15 )
    {
        memcpy1( macMsg->FHDR.FOpts, &macMsg->Buffer[bufItr], macMsg->FHDR.FCtrl.Bits.FOptsLen );
 803654c:	7b02      	ldrb	r2, [r0, #12]
    macMsg->FHDR.FCnt |= macMsg->Buffer[bufItr++] << 8;
 803654e:	81c3      	strh	r3, [r0, #14]
        memcpy1( macMsg->FHDR.FOpts, &macMsg->Buffer[bufItr], macMsg->FHDR.FCtrl.Bits.FOptsLen );
 8036550:	f002 020f 	and.w	r2, r2, #15
 8036554:	3108      	adds	r1, #8
 8036556:	3010      	adds	r0, #16
 8036558:	f002 fcea 	bl	8038f30 <memcpy1>
        bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 803655c:	7b23      	ldrb	r3, [r4, #12]
    {
        return LORAMAC_PARSER_FAIL;
    }

    // Initialize anyway with zero.
    macMsg->FPort = 0;
 803655e:	2200      	movs	r2, #0
        bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 8036560:	f003 030f 	and.w	r3, r3, #15
    macMsg->FPort = 0;
 8036564:	f884 2020 	strb.w	r2, [r4, #32]
    macMsg->FRMPayloadSize = 0;
 8036568:	f884 2028 	strb.w	r2, [r4, #40]	; 0x28

    if( ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE ) > 0 )
 803656c:	7922      	ldrb	r2, [r4, #4]
        bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 803656e:	f103 0008 	add.w	r0, r3, #8
    if( ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE ) > 0 )
 8036572:	1a11      	subs	r1, r2, r0
 8036574:	2904      	cmp	r1, #4
 8036576:	dd0d      	ble.n	8036594 <LoRaMacParserData+0x84>
    {
        macMsg->FPort = macMsg->Buffer[bufItr++];
 8036578:	6821      	ldr	r1, [r4, #0]
 803657a:	3309      	adds	r3, #9

        macMsg->FRMPayloadSize = ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE );
 803657c:	3a04      	subs	r2, #4
 803657e:	1ad2      	subs	r2, r2, r3
        macMsg->FPort = macMsg->Buffer[bufItr++];
 8036580:	5c08      	ldrb	r0, [r1, r0]
 8036582:	f884 0020 	strb.w	r0, [r4, #32]
        macMsg->FRMPayloadSize = ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE );
 8036586:	b2d2      	uxtb	r2, r2
        memcpy1( macMsg->FRMPayload, &macMsg->Buffer[bufItr], macMsg->FRMPayloadSize );
 8036588:	6a60      	ldr	r0, [r4, #36]	; 0x24
        macMsg->FRMPayloadSize = ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE );
 803658a:	f884 2028 	strb.w	r2, [r4, #40]	; 0x28
        memcpy1( macMsg->FRMPayload, &macMsg->Buffer[bufItr], macMsg->FRMPayloadSize );
 803658e:	4419      	add	r1, r3
 8036590:	f002 fcce 	bl	8038f30 <memcpy1>
        bufItr = bufItr + macMsg->FRMPayloadSize;
    }

    macMsg->MIC = ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE )];
 8036594:	7923      	ldrb	r3, [r4, #4]
 8036596:	6822      	ldr	r2, [r4, #0]
 8036598:	441a      	add	r2, r3
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 1] << 8 );
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 2] << 16 );
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 3] << 24 );

    return LORAMAC_PARSER_SUCCESS;
 803659a:	2000      	movs	r0, #0
    macMsg->MIC = ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE )];
 803659c:	f812 3c04 	ldrb.w	r3, [r2, #-4]
 80365a0:	62e3      	str	r3, [r4, #44]	; 0x2c
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 1] << 8 );
 80365a2:	f812 1c03 	ldrb.w	r1, [r2, #-3]
 80365a6:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 80365aa:	62e3      	str	r3, [r4, #44]	; 0x2c
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 2] << 16 );
 80365ac:	f812 1c02 	ldrb.w	r1, [r2, #-2]
 80365b0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 80365b4:	62e3      	str	r3, [r4, #44]	; 0x2c
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 3] << 24 );
 80365b6:	f812 2c01 	ldrb.w	r2, [r2, #-1]
 80365ba:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80365be:	62e3      	str	r3, [r4, #44]	; 0x2c
}
 80365c0:	bd10      	pop	{r4, pc}
        return LORAMAC_PARSER_ERROR_NPE;
 80365c2:	2002      	movs	r0, #2
 80365c4:	e7fc      	b.n	80365c0 <LoRaMacParserData+0xb0>

080365c6 <LoRaMacSerializerJoinRequest>:
 */
#include "LoRaMacSerializer.h"
#include "utilities.h"

LoRaMacSerializerStatus_t LoRaMacSerializerJoinRequest( LoRaMacMessageJoinRequest_t* macMsg )
{
 80365c6:	b510      	push	{r4, lr}
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 80365c8:	4604      	mov	r4, r0
 80365ca:	b360      	cbz	r0, 8036626 <LoRaMacSerializerJoinRequest+0x60>
 80365cc:	6803      	ldr	r3, [r0, #0]
 80365ce:	b353      	cbz	r3, 8036626 <LoRaMacSerializerJoinRequest+0x60>
    }

    uint16_t bufItr = 0;

    // Check macMsg->BufSize
    if( macMsg->BufSize < LORAMAC_JOIN_REQ_MSG_SIZE )
 80365d0:	7902      	ldrb	r2, [r0, #4]
 80365d2:	2a16      	cmp	r2, #22
 80365d4:	d929      	bls.n	803662a <LoRaMacSerializerJoinRequest+0x64>
    {
        return LORAMAC_SERIALIZER_ERROR_BUF_SIZE;
    }

    macMsg->Buffer[bufItr++] = macMsg->MHDR.Value;
 80365d6:	7942      	ldrb	r2, [r0, #5]
 80365d8:	701a      	strb	r2, [r3, #0]

    memcpyr( &macMsg->Buffer[bufItr], macMsg->JoinEUI, LORAMAC_JOIN_EUI_FIELD_SIZE );
 80365da:	4601      	mov	r1, r0
 80365dc:	2208      	movs	r2, #8
 80365de:	f851 0b06 	ldr.w	r0, [r1], #6
 80365e2:	3001      	adds	r0, #1
 80365e4:	f002 fcae 	bl	8038f44 <memcpyr>
    bufItr += LORAMAC_JOIN_EUI_FIELD_SIZE;

    memcpyr( &macMsg->Buffer[bufItr], macMsg->DevEUI, LORAMAC_DEV_EUI_FIELD_SIZE );
 80365e8:	4621      	mov	r1, r4
 80365ea:	2208      	movs	r2, #8
 80365ec:	f851 0b0e 	ldr.w	r0, [r1], #14
 80365f0:	3009      	adds	r0, #9
 80365f2:	f002 fca7 	bl	8038f44 <memcpyr>
    bufItr += LORAMAC_DEV_EUI_FIELD_SIZE;

    macMsg->Buffer[bufItr++] = macMsg->DevNonce & 0xFF;
 80365f6:	6823      	ldr	r3, [r4, #0]
 80365f8:	8ae2      	ldrh	r2, [r4, #22]
 80365fa:	745a      	strb	r2, [r3, #17]
    macMsg->Buffer[bufItr++] = ( macMsg->DevNonce >> 8 ) & 0xFF;
 80365fc:	8ae3      	ldrh	r3, [r4, #22]
 80365fe:	6822      	ldr	r2, [r4, #0]
 8036600:	0a1b      	lsrs	r3, r3, #8
 8036602:	7493      	strb	r3, [r2, #18]

    macMsg->Buffer[bufItr++] = macMsg->MIC & 0xFF;
 8036604:	6823      	ldr	r3, [r4, #0]
 8036606:	69a2      	ldr	r2, [r4, #24]
 8036608:	74da      	strb	r2, [r3, #19]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 8 ) & 0xFF;
 803660a:	69a3      	ldr	r3, [r4, #24]
 803660c:	6822      	ldr	r2, [r4, #0]
 803660e:	0a1b      	lsrs	r3, r3, #8
 8036610:	7513      	strb	r3, [r2, #20]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 16 ) & 0xFF;
 8036612:	6823      	ldr	r3, [r4, #0]
 8036614:	8b62      	ldrh	r2, [r4, #26]
 8036616:	755a      	strb	r2, [r3, #21]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 24 ) & 0xFF;
 8036618:	6823      	ldr	r3, [r4, #0]
 803661a:	7ee2      	ldrb	r2, [r4, #27]
 803661c:	759a      	strb	r2, [r3, #22]

    macMsg->BufSize = bufItr;
 803661e:	2317      	movs	r3, #23
 8036620:	7123      	strb	r3, [r4, #4]

    return LORAMAC_SERIALIZER_SUCCESS;
 8036622:	2000      	movs	r0, #0
}
 8036624:	bd10      	pop	{r4, pc}
        return LORAMAC_SERIALIZER_ERROR_NPE;
 8036626:	2001      	movs	r0, #1
 8036628:	e7fc      	b.n	8036624 <LoRaMacSerializerJoinRequest+0x5e>
        return LORAMAC_SERIALIZER_ERROR_BUF_SIZE;
 803662a:	2002      	movs	r0, #2
 803662c:	e7fa      	b.n	8036624 <LoRaMacSerializerJoinRequest+0x5e>

0803662e <LoRaMacSerializerData>:

    return LORAMAC_SERIALIZER_SUCCESS;
}

LoRaMacSerializerStatus_t LoRaMacSerializerData( LoRaMacMessageData_t* macMsg )
{
 803662e:	b538      	push	{r3, r4, r5, lr}
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 8036630:	4604      	mov	r4, r0
 8036632:	2800      	cmp	r0, #0
 8036634:	d063      	beq.n	80366fe <LoRaMacSerializerData+0xd0>
 8036636:	6801      	ldr	r1, [r0, #0]
 8036638:	2900      	cmp	r1, #0
 803663a:	d060      	beq.n	80366fe <LoRaMacSerializerData+0xd0>
    uint16_t computedBufSize =   LORAMAC_MHDR_FIELD_SIZE
                               + LORAMAC_FHDR_DEV_ADDR_FIELD_SIZE
                               + LORAMAC_FHDR_F_CTRL_FIELD_SIZE
                               + LORAMAC_FHDR_F_CNT_FIELD_SIZE;

    computedBufSize += macMsg->FHDR.FCtrl.Bits.FOptsLen;
 803663c:	7b03      	ldrb	r3, [r0, #12]

    if( macMsg->FRMPayloadSize > 0 )
 803663e:	f890 2028 	ldrb.w	r2, [r0, #40]	; 0x28
    computedBufSize += macMsg->FHDR.FCtrl.Bits.FOptsLen;
 8036642:	f003 030f 	and.w	r3, r3, #15
    if( macMsg->FRMPayloadSize > 0 )
 8036646:	2a00      	cmp	r2, #0
 8036648:	d157      	bne.n	80366fa <LoRaMacSerializerData+0xcc>
    computedBufSize += macMsg->FHDR.FCtrl.Bits.FOptsLen;
 803664a:	3308      	adds	r3, #8
    }

    computedBufSize += macMsg->FRMPayloadSize;
    computedBufSize += LORAMAC_MIC_FIELD_SIZE;

    if( macMsg->BufSize < computedBufSize )
 803664c:	7920      	ldrb	r0, [r4, #4]
    computedBufSize += LORAMAC_MIC_FIELD_SIZE;
 803664e:	3204      	adds	r2, #4
    if( macMsg->BufSize < computedBufSize )
 8036650:	4413      	add	r3, r2
 8036652:	4298      	cmp	r0, r3
 8036654:	d355      	bcc.n	8036702 <LoRaMacSerializerData+0xd4>
    {
        return LORAMAC_SERIALIZER_ERROR_BUF_SIZE;
    }

    macMsg->Buffer[bufItr++] = macMsg->MHDR.Value;
 8036656:	7963      	ldrb	r3, [r4, #5]
 8036658:	700b      	strb	r3, [r1, #0]

    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr ) & 0xFF;
 803665a:	6823      	ldr	r3, [r4, #0]
 803665c:	68a2      	ldr	r2, [r4, #8]
 803665e:	705a      	strb	r2, [r3, #1]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr >> 8 ) & 0xFF;
 8036660:	68a3      	ldr	r3, [r4, #8]
 8036662:	6822      	ldr	r2, [r4, #0]
 8036664:	0a1b      	lsrs	r3, r3, #8
 8036666:	7093      	strb	r3, [r2, #2]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr >> 16 ) & 0xFF;
 8036668:	6823      	ldr	r3, [r4, #0]
 803666a:	8962      	ldrh	r2, [r4, #10]
 803666c:	70da      	strb	r2, [r3, #3]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr >> 24 ) & 0xFF;
 803666e:	6823      	ldr	r3, [r4, #0]
 8036670:	7ae2      	ldrb	r2, [r4, #11]
 8036672:	711a      	strb	r2, [r3, #4]

    macMsg->Buffer[bufItr++] = macMsg->FHDR.FCtrl.Value;
 8036674:	6823      	ldr	r3, [r4, #0]
 8036676:	7b22      	ldrb	r2, [r4, #12]
 8036678:	715a      	strb	r2, [r3, #5]

    macMsg->Buffer[bufItr++] = macMsg->FHDR.FCnt & 0xFF;
 803667a:	6823      	ldr	r3, [r4, #0]
 803667c:	89e2      	ldrh	r2, [r4, #14]
 803667e:	719a      	strb	r2, [r3, #6]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.FCnt >> 8 ) & 0xFF;
 8036680:	89e3      	ldrh	r3, [r4, #14]
 8036682:	6822      	ldr	r2, [r4, #0]
 8036684:	0a1b      	lsrs	r3, r3, #8

    memcpy1( &macMsg->Buffer[bufItr], macMsg->FHDR.FOpts, macMsg->FHDR.FCtrl.Bits.FOptsLen );
 8036686:	4621      	mov	r1, r4
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.FCnt >> 8 ) & 0xFF;
 8036688:	71d3      	strb	r3, [r2, #7]
    memcpy1( &macMsg->Buffer[bufItr], macMsg->FHDR.FOpts, macMsg->FHDR.FCtrl.Bits.FOptsLen );
 803668a:	7b22      	ldrb	r2, [r4, #12]
 803668c:	f851 0b10 	ldr.w	r0, [r1], #16
 8036690:	f002 020f 	and.w	r2, r2, #15
 8036694:	3008      	adds	r0, #8
 8036696:	f002 fc4b 	bl	8038f30 <memcpy1>
    bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 803669a:	7b23      	ldrb	r3, [r4, #12]

    if( macMsg->FRMPayloadSize > 0 )
 803669c:	f894 2028 	ldrb.w	r2, [r4, #40]	; 0x28
    bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 80366a0:	f003 030f 	and.w	r3, r3, #15
 80366a4:	f103 0508 	add.w	r5, r3, #8
    if( macMsg->FRMPayloadSize > 0 )
 80366a8:	b12a      	cbz	r2, 80366b6 <LoRaMacSerializerData+0x88>
    {
        macMsg->Buffer[bufItr++] = macMsg->FPort;
 80366aa:	6822      	ldr	r2, [r4, #0]
 80366ac:	f894 1020 	ldrb.w	r1, [r4, #32]
 80366b0:	5551      	strb	r1, [r2, r5]
 80366b2:	f103 0509 	add.w	r5, r3, #9
    }

    memcpy1( &macMsg->Buffer[bufItr], macMsg->FRMPayload, macMsg->FRMPayloadSize );
 80366b6:	6820      	ldr	r0, [r4, #0]
 80366b8:	f894 2028 	ldrb.w	r2, [r4, #40]	; 0x28
 80366bc:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80366be:	4428      	add	r0, r5
 80366c0:	f002 fc36 	bl	8038f30 <memcpy1>
    bufItr = bufItr + macMsg->FRMPayloadSize;
 80366c4:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28

    macMsg->Buffer[bufItr++] = macMsg->MIC & 0xFF;
 80366c8:	6822      	ldr	r2, [r4, #0]
 80366ca:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
    bufItr = bufItr + macMsg->FRMPayloadSize;
 80366cc:	442b      	add	r3, r5
    macMsg->Buffer[bufItr++] = macMsg->MIC & 0xFF;
 80366ce:	54d1      	strb	r1, [r2, r3]
 80366d0:	1c5a      	adds	r2, r3, #1
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 8 ) & 0xFF;
 80366d2:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 80366d4:	6820      	ldr	r0, [r4, #0]
 80366d6:	b292      	uxth	r2, r2
 80366d8:	0a09      	lsrs	r1, r1, #8
 80366da:	5481      	strb	r1, [r0, r2]
 80366dc:	1c9a      	adds	r2, r3, #2
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 16 ) & 0xFF;
 80366de:	6821      	ldr	r1, [r4, #0]
 80366e0:	8de0      	ldrh	r0, [r4, #46]	; 0x2e
 80366e2:	b292      	uxth	r2, r2
 80366e4:	5488      	strb	r0, [r1, r2]
 80366e6:	1cda      	adds	r2, r3, #3
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 24 ) & 0xFF;
 80366e8:	6821      	ldr	r1, [r4, #0]
 80366ea:	f894 002f 	ldrb.w	r0, [r4, #47]	; 0x2f
 80366ee:	b292      	uxth	r2, r2
 80366f0:	3304      	adds	r3, #4
 80366f2:	5488      	strb	r0, [r1, r2]

    macMsg->BufSize = bufItr;
 80366f4:	7123      	strb	r3, [r4, #4]

    return LORAMAC_SERIALIZER_SUCCESS;
 80366f6:	2000      	movs	r0, #0
}
 80366f8:	bd38      	pop	{r3, r4, r5, pc}
        computedBufSize += LORAMAC_F_PORT_FIELD_SIZE;
 80366fa:	3309      	adds	r3, #9
 80366fc:	e7a6      	b.n	803664c <LoRaMacSerializerData+0x1e>
        return LORAMAC_SERIALIZER_ERROR_NPE;
 80366fe:	2001      	movs	r0, #1
 8036700:	e7fa      	b.n	80366f8 <LoRaMacSerializerData+0xca>
        return LORAMAC_SERIALIZER_ERROR_BUF_SIZE;
 8036702:	2002      	movs	r0, #2
 8036704:	e7f8      	b.n	80366f8 <LoRaMacSerializerData+0xca>

08036706 <NvmDataMgmtEvent>:
void NvmDataMgmtEvent( uint16_t notifyFlags )
{
#if( CONTEXT_MANAGEMENT_ENABLED == 1 )
    NvmNotifyFlags = notifyFlags;
#endif /* CONTEXT_MANAGEMENT_ENABLED == 1 */
}
 8036706:	4770      	bx	lr

08036708 <NvmDataMgmtStore>:
    LoRaMacStart( );
    return dataSize;
#else
    return 0;
#endif
}
 8036708:	2000      	movs	r0, #0
 803670a:	4770      	bx	lr

0803670c <NvmDataMgmtRestore>:
 803670c:	2000      	movs	r0, #0
 803670e:	4770      	bx	lr

08036710 <RegionIsActive>:
#define RU864_RX_BEACON_SETUP( )
#endif

bool RegionIsActive( LoRaMacRegion_t region )
{
    switch( region )
 8036710:	2805      	cmp	r0, #5
 8036712:	d004      	beq.n	803671e <RegionIsActive+0xe>
 8036714:	f1a0 0308 	sub.w	r3, r0, #8
 8036718:	4258      	negs	r0, r3
 803671a:	4158      	adcs	r0, r3
 803671c:	4770      	bx	lr
        AS923_IS_ACTIVE( );
        AU915_IS_ACTIVE( );
        CN470_IS_ACTIVE( );
        CN779_IS_ACTIVE( );
        EU433_IS_ACTIVE( );
        EU868_IS_ACTIVE( );
 803671e:	2001      	movs	r0, #1
        default:
        {
            return false;
        }
    }
}
 8036720:	4770      	bx	lr

08036722 <RegionGetPhyParam>:

PhyParam_t RegionGetPhyParam( LoRaMacRegion_t region, GetPhyParams_t* getPhy )
{
 8036722:	4603      	mov	r3, r0
    PhyParam_t phyParam = { 0 };
    switch( region )
 8036724:	2b05      	cmp	r3, #5
{
 8036726:	b082      	sub	sp, #8
 8036728:	4608      	mov	r0, r1
    switch( region )
 803672a:	d004      	beq.n	8036736 <RegionGetPhyParam+0x14>
 803672c:	2b08      	cmp	r3, #8
 803672e:	d005      	beq.n	803673c <RegionGetPhyParam+0x1a>
        default:
        {
            return phyParam;
        }
    }
}
 8036730:	2000      	movs	r0, #0
 8036732:	b002      	add	sp, #8
 8036734:	4770      	bx	lr
 8036736:	b002      	add	sp, #8
        EU868_GET_PHY_PARAM( );
 8036738:	f000 bcf4 	b.w	8037124 <RegionEU868GetPhyParam>
}
 803673c:	b002      	add	sp, #8
        US915_GET_PHY_PARAM( );
 803673e:	f001 ba35 	b.w	8037bac <RegionUS915GetPhyParam>

08036742 <RegionSetBandTxDone>:

void RegionSetBandTxDone( LoRaMacRegion_t region, SetBandTxDoneParams_t* txDone )
{
 8036742:	4603      	mov	r3, r0
    switch( region )
 8036744:	2b05      	cmp	r3, #5
{
 8036746:	4608      	mov	r0, r1
    switch( region )
 8036748:	d002      	beq.n	8036750 <RegionSetBandTxDone+0xe>
 803674a:	2b08      	cmp	r3, #8
 803674c:	d002      	beq.n	8036754 <RegionSetBandTxDone+0x12>
 803674e:	4770      	bx	lr
        AS923_SET_BAND_TX_DONE( );
        AU915_SET_BAND_TX_DONE( );
        CN470_SET_BAND_TX_DONE( );
        CN779_SET_BAND_TX_DONE( );
        EU433_SET_BAND_TX_DONE( );
        EU868_SET_BAND_TX_DONE( );
 8036750:	f000 bd88 	b.w	8037264 <RegionEU868SetBandTxDone>
        KR920_SET_BAND_TX_DONE( );
        IN865_SET_BAND_TX_DONE( );
        US915_SET_BAND_TX_DONE( );
 8036754:	f001 bad4 	b.w	8037d00 <RegionUS915SetBandTxDone>

08036758 <RegionInitDefaults>:
        }
    }
}

void RegionInitDefaults( LoRaMacRegion_t region, InitDefaultsParams_t* params )
{
 8036758:	4603      	mov	r3, r0
    switch( region )
 803675a:	2b05      	cmp	r3, #5
{
 803675c:	4608      	mov	r0, r1
    switch( region )
 803675e:	d002      	beq.n	8036766 <RegionInitDefaults+0xe>
 8036760:	2b08      	cmp	r3, #8
 8036762:	d002      	beq.n	803676a <RegionInitDefaults+0x12>
 8036764:	4770      	bx	lr
        AS923_INIT_DEFAULTS( );
        AU915_INIT_DEFAULTS( );
        CN470_INIT_DEFAULTS( );
        CN779_INIT_DEFAULTS( );
        EU433_INIT_DEFAULTS( );
        EU868_INIT_DEFAULTS( );
 8036766:	f000 bd95 	b.w	8037294 <RegionEU868InitDefaults>
        KR920_INIT_DEFAULTS( );
        IN865_INIT_DEFAULTS( );
        US915_INIT_DEFAULTS( );
 803676a:	f001 bae1 	b.w	8037d30 <RegionUS915InitDefaults>

0803676e <RegionVerify>:
        }
    }
}

bool RegionVerify( LoRaMacRegion_t region, VerifyParams_t* verify, PhyAttribute_t phyAttribute )
{
 803676e:	4603      	mov	r3, r0
    switch( region )
 8036770:	2b05      	cmp	r3, #5
{
 8036772:	4608      	mov	r0, r1
 8036774:	4611      	mov	r1, r2
    switch( region )
 8036776:	d003      	beq.n	8036780 <RegionVerify+0x12>
 8036778:	2b08      	cmp	r3, #8
 803677a:	d003      	beq.n	8036784 <RegionVerify+0x16>
        default:
        {
            return false;
        }
    }
}
 803677c:	2000      	movs	r0, #0
 803677e:	4770      	bx	lr
        EU868_VERIFY( );
 8036780:	f000 bdea 	b.w	8037358 <RegionEU868Verify>
        US915_VERIFY( );
 8036784:	f001 bb56 	b.w	8037e34 <RegionUS915Verify>

08036788 <RegionApplyCFList>:

void RegionApplyCFList( LoRaMacRegion_t region, ApplyCFListParams_t* applyCFList )
{
 8036788:	4603      	mov	r3, r0
    switch( region )
 803678a:	2b05      	cmp	r3, #5
{
 803678c:	4608      	mov	r0, r1
    switch( region )
 803678e:	d002      	beq.n	8036796 <RegionApplyCFList+0xe>
 8036790:	2b08      	cmp	r3, #8
 8036792:	d002      	beq.n	803679a <RegionApplyCFList+0x12>
 8036794:	4770      	bx	lr
        AS923_APPLY_CF_LIST( );
        AU915_APPLY_CF_LIST( );
        CN470_APPLY_CF_LIST( );
        CN779_APPLY_CF_LIST( );
        EU433_APPLY_CF_LIST( );
        EU868_APPLY_CF_LIST( );
 8036796:	f001 b93f 	b.w	8037a18 <RegionEU868ApplyCFList>
        KR920_APPLY_CF_LIST( );
        IN865_APPLY_CF_LIST( );
        US915_APPLY_CF_LIST( );
 803679a:	f001 bb6d 	b.w	8037e78 <RegionUS915ApplyCFList>

0803679e <RegionChanMaskSet>:
        }
    }
}

bool RegionChanMaskSet( LoRaMacRegion_t region, ChanMaskSetParams_t* chanMaskSet )
{
 803679e:	4603      	mov	r3, r0
    switch( region )
 80367a0:	2b05      	cmp	r3, #5
{
 80367a2:	4608      	mov	r0, r1
    switch( region )
 80367a4:	d003      	beq.n	80367ae <RegionChanMaskSet+0x10>
 80367a6:	2b08      	cmp	r3, #8
 80367a8:	d003      	beq.n	80367b2 <RegionChanMaskSet+0x14>
        default:
        {
            return false;
        }
    }
}
 80367aa:	2000      	movs	r0, #0
 80367ac:	4770      	bx	lr
        EU868_CHAN_MASK_SET( );
 80367ae:	f000 bdfb 	b.w	80373a8 <RegionEU868ChanMaskSet>
        US915_CHAN_MASK_SET( );
 80367b2:	f001 bb8b 	b.w	8037ecc <RegionUS915ChanMaskSet>

080367b6 <RegionComputeRxWindowParameters>:

void RegionComputeRxWindowParameters( LoRaMacRegion_t region, int8_t datarate, uint8_t minRxSymbols, uint32_t rxError, RxConfigParams_t *rxConfigParams )
{
 80367b6:	b410      	push	{r4}
 80367b8:	4604      	mov	r4, r0
    switch( region )
 80367ba:	2c05      	cmp	r4, #5
{
 80367bc:	4608      	mov	r0, r1
 80367be:	4611      	mov	r1, r2
 80367c0:	461a      	mov	r2, r3
 80367c2:	9b01      	ldr	r3, [sp, #4]
    switch( region )
 80367c4:	d003      	beq.n	80367ce <RegionComputeRxWindowParameters+0x18>
 80367c6:	2c08      	cmp	r4, #8
 80367c8:	d004      	beq.n	80367d4 <RegionComputeRxWindowParameters+0x1e>
        default:
        {
            break;
        }
    }
}
 80367ca:	bc10      	pop	{r4}
 80367cc:	4770      	bx	lr
 80367ce:	bc10      	pop	{r4}
        EU868_COMPUTE_RX_WINDOW_PARAMETERS( );
 80367d0:	f000 be08 	b.w	80373e4 <RegionEU868ComputeRxWindowParameters>
}
 80367d4:	bc10      	pop	{r4}
        US915_COMPUTE_RX_WINDOW_PARAMETERS( );
 80367d6:	f001 bbb3 	b.w	8037f40 <RegionUS915ComputeRxWindowParameters>

080367da <RegionRxConfig>:

bool RegionRxConfig( LoRaMacRegion_t region, RxConfigParams_t* rxConfig, int8_t* datarate )
{
 80367da:	4603      	mov	r3, r0
    switch( region )
 80367dc:	2b05      	cmp	r3, #5
{
 80367de:	4608      	mov	r0, r1
 80367e0:	4611      	mov	r1, r2
    switch( region )
 80367e2:	d003      	beq.n	80367ec <RegionRxConfig+0x12>
 80367e4:	2b08      	cmp	r3, #8
 80367e6:	d003      	beq.n	80367f0 <RegionRxConfig+0x16>
        default:
        {
            return false;
        }
    }
}
 80367e8:	2000      	movs	r0, #0
 80367ea:	4770      	bx	lr
        EU868_RX_CONFIG( );
 80367ec:	f000 be2c 	b.w	8037448 <RegionEU868RxConfig>
        US915_RX_CONFIG( );
 80367f0:	f001 bbd2 	b.w	8037f98 <RegionUS915RxConfig>

080367f4 <RegionTxConfig>:

bool RegionTxConfig( LoRaMacRegion_t region, TxConfigParams_t* txConfig, int8_t* txPower, TimerTime_t* txTimeOnAir )
{
 80367f4:	b410      	push	{r4}
 80367f6:	4604      	mov	r4, r0
    switch( region )
 80367f8:	2c05      	cmp	r4, #5
{
 80367fa:	4608      	mov	r0, r1
 80367fc:	4611      	mov	r1, r2
 80367fe:	461a      	mov	r2, r3
    switch( region )
 8036800:	d004      	beq.n	803680c <RegionTxConfig+0x18>
 8036802:	2c08      	cmp	r4, #8
 8036804:	d005      	beq.n	8036812 <RegionTxConfig+0x1e>
        default:
        {
            return false;
        }
    }
}
 8036806:	2000      	movs	r0, #0
 8036808:	bc10      	pop	{r4}
 803680a:	4770      	bx	lr
 803680c:	bc10      	pop	{r4}
        EU868_TX_CONFIG( );
 803680e:	f000 be99 	b.w	8037544 <RegionEU868TxConfig>
}
 8036812:	bc10      	pop	{r4}
        US915_TX_CONFIG( );
 8036814:	f001 bc14 	b.w	8038040 <RegionUS915TxConfig>

08036818 <RegionLinkAdrReq>:

uint8_t RegionLinkAdrReq( LoRaMacRegion_t region, LinkAdrReqParams_t* linkAdrReq, int8_t* drOut, int8_t* txPowOut, uint8_t* nbRepOut, uint8_t* nbBytesParsed )
{
 8036818:	b430      	push	{r4, r5}
 803681a:	4604      	mov	r4, r0
    switch( region )
 803681c:	2c05      	cmp	r4, #5
{
 803681e:	4608      	mov	r0, r1
 8036820:	4611      	mov	r1, r2
 8036822:	461a      	mov	r2, r3
 8036824:	e9dd 3502 	ldrd	r3, r5, [sp, #8]
    switch( region )
 8036828:	d004      	beq.n	8036834 <RegionLinkAdrReq+0x1c>
 803682a:	2c08      	cmp	r4, #8
 803682c:	d006      	beq.n	803683c <RegionLinkAdrReq+0x24>
        default:
        {
            return 0;
        }
    }
}
 803682e:	2000      	movs	r0, #0
 8036830:	bc30      	pop	{r4, r5}
 8036832:	4770      	bx	lr
        EU868_LINK_ADR_REQ( );
 8036834:	9502      	str	r5, [sp, #8]
}
 8036836:	bc30      	pop	{r4, r5}
        EU868_LINK_ADR_REQ( );
 8036838:	f000 bf08 	b.w	803764c <RegionEU868LinkAdrReq>
        US915_LINK_ADR_REQ( );
 803683c:	9502      	str	r5, [sp, #8]
}
 803683e:	bc30      	pop	{r4, r5}
        US915_LINK_ADR_REQ( );
 8036840:	f001 bc86 	b.w	8038150 <RegionUS915LinkAdrReq>

08036844 <RegionRxParamSetupReq>:

uint8_t RegionRxParamSetupReq( LoRaMacRegion_t region, RxParamSetupReqParams_t* rxParamSetupReq )
{
 8036844:	4603      	mov	r3, r0
    switch( region )
 8036846:	2b05      	cmp	r3, #5
{
 8036848:	4608      	mov	r0, r1
    switch( region )
 803684a:	d003      	beq.n	8036854 <RegionRxParamSetupReq+0x10>
 803684c:	2b08      	cmp	r3, #8
 803684e:	d003      	beq.n	8036858 <RegionRxParamSetupReq+0x14>
        default:
        {
            return 0;
        }
    }
}
 8036850:	2000      	movs	r0, #0
 8036852:	4770      	bx	lr
        EU868_RX_PARAM_SETUP_REQ( );
 8036854:	f000 bfa8 	b.w	80377a8 <RegionEU868RxParamSetupReq>
        US915_RX_PARAM_SETUP_REQ( );
 8036858:	f001 bd90 	b.w	803837c <RegionUS915RxParamSetupReq>

0803685c <RegionNewChannelReq>:

int8_t RegionNewChannelReq( LoRaMacRegion_t region, NewChannelReqParams_t* newChannelReq )
{
 803685c:	4603      	mov	r3, r0
    switch( region )
 803685e:	2b05      	cmp	r3, #5
{
 8036860:	4608      	mov	r0, r1
    switch( region )
 8036862:	d003      	beq.n	803686c <RegionNewChannelReq+0x10>
 8036864:	2b08      	cmp	r3, #8
 8036866:	d003      	beq.n	8036870 <RegionNewChannelReq+0x14>
        default:
        {
            return 0;
        }
    }
}
 8036868:	2000      	movs	r0, #0
 803686a:	4770      	bx	lr
        EU868_NEW_CHANNEL_REQ( );
 803686c:	f001 b912 	b.w	8037a94 <RegionEU868NewChannelReq>
        US915_NEW_CHANNEL_REQ( );
 8036870:	f001 bdb0 	b.w	80383d4 <RegionUS915NewChannelReq>

08036874 <RegionTxParamSetupReq>:

int8_t RegionTxParamSetupReq( LoRaMacRegion_t region, TxParamSetupReqParams_t* txParamSetupReq )
{
 8036874:	4603      	mov	r3, r0
    switch( region )
 8036876:	2b05      	cmp	r3, #5
{
 8036878:	4608      	mov	r0, r1
    switch( region )
 803687a:	d003      	beq.n	8036884 <RegionTxParamSetupReq+0x10>
 803687c:	2b08      	cmp	r3, #8
 803687e:	d003      	beq.n	8036888 <RegionTxParamSetupReq+0x14>
        default:
        {
            return 0;
        }
    }
}
 8036880:	2000      	movs	r0, #0
 8036882:	4770      	bx	lr
        EU868_TX_PARAM_SETUP_REQ( );
 8036884:	f000 bfb3 	b.w	80377ee <RegionEU868TxParamSetupReq>
        US915_TX_PARAM_SETUP_REQ( );
 8036888:	f001 bda7 	b.w	80383da <RegionUS915TxParamSetupReq>

0803688c <RegionDlChannelReq>:

int8_t RegionDlChannelReq( LoRaMacRegion_t region, DlChannelReqParams_t* dlChannelReq )
{
 803688c:	4603      	mov	r3, r0
    switch( region )
 803688e:	2b05      	cmp	r3, #5
{
 8036890:	4608      	mov	r0, r1
    switch( region )
 8036892:	d003      	beq.n	803689c <RegionDlChannelReq+0x10>
 8036894:	2b08      	cmp	r3, #8
 8036896:	d003      	beq.n	80368a0 <RegionDlChannelReq+0x14>
        default:
        {
            return 0;
        }
    }
}
 8036898:	2000      	movs	r0, #0
 803689a:	4770      	bx	lr
        EU868_DL_CHANNEL_REQ( );
 803689c:	f000 bfaa 	b.w	80377f4 <RegionEU868DlChannelReq>
        US915_DL_CHANNEL_REQ( );
 80368a0:	f001 bd9e 	b.w	80383e0 <RegionUS915DlChannelReq>

080368a4 <RegionAlternateDr>:

int8_t RegionAlternateDr( LoRaMacRegion_t region, int8_t currentDr, AlternateDrType_t type )
{
 80368a4:	4603      	mov	r3, r0
    switch( region )
 80368a6:	2b05      	cmp	r3, #5
{
 80368a8:	4608      	mov	r0, r1
 80368aa:	4611      	mov	r1, r2
    switch( region )
 80368ac:	d003      	beq.n	80368b6 <RegionAlternateDr+0x12>
 80368ae:	2b08      	cmp	r3, #8
 80368b0:	d003      	beq.n	80368ba <RegionAlternateDr+0x16>
        default:
        {
            return 0;
        }
    }
}
 80368b2:	2000      	movs	r0, #0
 80368b4:	4770      	bx	lr
        EU868_ALTERNATE_DR( );
 80368b6:	f000 bfc1 	b.w	803783c <RegionEU868AlternateDr>
        US915_ALTERNATE_DR( );
 80368ba:	f001 bd95 	b.w	80383e8 <RegionUS915AlternateDr>

080368be <RegionNextChannel>:

LoRaMacStatus_t RegionNextChannel( LoRaMacRegion_t region, NextChanParams_t* nextChanParams, uint8_t* channel, TimerTime_t* time, TimerTime_t* aggregatedTimeOff )
{
 80368be:	b410      	push	{r4}
 80368c0:	4604      	mov	r4, r0
    switch( region )
 80368c2:	2c05      	cmp	r4, #5
{
 80368c4:	4608      	mov	r0, r1
 80368c6:	4611      	mov	r1, r2
 80368c8:	461a      	mov	r2, r3
 80368ca:	9b01      	ldr	r3, [sp, #4]
    switch( region )
 80368cc:	d004      	beq.n	80368d8 <RegionNextChannel+0x1a>
 80368ce:	2c08      	cmp	r4, #8
 80368d0:	d005      	beq.n	80368de <RegionNextChannel+0x20>
        default:
        {
            return LORAMAC_STATUS_REGION_NOT_SUPPORTED;
        }
    }
}
 80368d2:	2009      	movs	r0, #9
 80368d4:	bc10      	pop	{r4}
 80368d6:	4770      	bx	lr
 80368d8:	bc10      	pop	{r4}
        EU868_NEXT_CHANNEL( );
 80368da:	f000 bfb1 	b.w	8037840 <RegionEU868NextChannel>
}
 80368de:	bc10      	pop	{r4}
        US915_NEXT_CHANNEL( );
 80368e0:	f001 bd9a 	b.w	8038418 <RegionUS915NextChannel>

080368e4 <RegionSetContinuousWave>:
        }
    }
}

void RegionSetContinuousWave( LoRaMacRegion_t region, ContinuousWaveParams_t* continuousWave )
{
 80368e4:	4603      	mov	r3, r0
    switch( region )
 80368e6:	2b05      	cmp	r3, #5
{
 80368e8:	4608      	mov	r0, r1
    switch( region )
 80368ea:	d002      	beq.n	80368f2 <RegionSetContinuousWave+0xe>
 80368ec:	2b08      	cmp	r3, #8
 80368ee:	d002      	beq.n	80368f6 <RegionSetContinuousWave+0x12>
 80368f0:	4770      	bx	lr
        AS923_SET_CONTINUOUS_WAVE( );
        AU915_SET_CONTINUOUS_WAVE( );
        CN470_SET_CONTINUOUS_WAVE( );
        CN779_SET_CONTINUOUS_WAVE( );
        EU433_SET_CONTINUOUS_WAVE( );
        EU868_SET_CONTINUOUS_WAVE( );
 80368f2:	f001 b8f1 	b.w	8037ad8 <RegionEU868SetContinuousWave>
        KR920_SET_CONTINUOUS_WAVE( );
        IN865_SET_CONTINUOUS_WAVE( );
        US915_SET_CONTINUOUS_WAVE( );
 80368f6:	f001 be2b 	b.w	8038550 <RegionUS915SetContinuousWave>

080368fa <RegionApplyDrOffset>:
        }
    }
}

uint8_t RegionApplyDrOffset( LoRaMacRegion_t region, uint8_t downlinkDwellTime, int8_t dr, int8_t drOffset )
{
 80368fa:	b410      	push	{r4}
 80368fc:	4604      	mov	r4, r0
    switch( region )
 80368fe:	2c05      	cmp	r4, #5
{
 8036900:	4608      	mov	r0, r1
 8036902:	4611      	mov	r1, r2
 8036904:	461a      	mov	r2, r3
    switch( region )
 8036906:	d004      	beq.n	8036912 <RegionApplyDrOffset+0x18>
 8036908:	2c08      	cmp	r4, #8
 803690a:	d005      	beq.n	8036918 <RegionApplyDrOffset+0x1e>
        default:
        {
            return dr;
        }
    }
}
 803690c:	b2c8      	uxtb	r0, r1
 803690e:	bc10      	pop	{r4}
 8036910:	4770      	bx	lr
 8036912:	bc10      	pop	{r4}
        EU868_APPLY_DR_OFFSET( );
 8036914:	f001 b908 	b.w	8037b28 <RegionEU868ApplyDrOffset>
}
 8036918:	bc10      	pop	{r4}
        US915_APPLY_DR_OFFSET( );
 803691a:	f001 be61 	b.w	80385e0 <RegionUS915ApplyDrOffset>
	...

08036920 <RegionGetVersion>:
    Version_t version;

    version.Value = REGION_VERSION;

    return version;
}
 8036920:	4800      	ldr	r0, [pc, #0]	; (8036924 <RegionGetVersion+0x4>)
 8036922:	4770      	bx	lr
 8036924:	01000300 	.word	0x01000300

08036928 <RegionBaseUSComputeNext125kHzJoinChannel>:
    return LORAMAC_STATUS_OK;
}

LoRaMacStatus_t RegionBaseUSComputeNext125kHzJoinChannel( uint16_t* channelsMaskRemaining,
                                                          uint8_t* groupsCurrentIndex, uint8_t* newChannelIndex )
{
 8036928:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    uint8_t currentChannelMaskLeftIndex;
    uint16_t currentChannelMaskLeft;
    uint8_t findAvailableChannelsIndex[8] = { 0 };
 803692c:	2300      	movs	r3, #0
 803692e:	e9cd 3300 	strd	r3, r3, [sp]
{
 8036932:	460e      	mov	r6, r1
 8036934:	4690      	mov	r8, r2
    uint8_t availableChannels = 0;
    uint8_t startIndex;

    // Null pointer check
    if( channelsMaskRemaining == NULL || groupsCurrentIndex == NULL || newChannelIndex == NULL )
 8036936:	4607      	mov	r7, r0
 8036938:	b918      	cbnz	r0, 8036942 <RegionBaseUSComputeNext125kHzJoinChannel+0x1a>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
 803693a:	2003      	movs	r0, #3
        *groupsCurrentIndex = startIndex;
        return LORAMAC_STATUS_OK;
    }

    return LORAMAC_STATUS_PARAMETER_INVALID;
}
 803693c:	b002      	add	sp, #8
 803693e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if( channelsMaskRemaining == NULL || groupsCurrentIndex == NULL || newChannelIndex == NULL )
 8036942:	2900      	cmp	r1, #0
 8036944:	d0f9      	beq.n	803693a <RegionBaseUSComputeNext125kHzJoinChannel+0x12>
 8036946:	2a00      	cmp	r2, #0
 8036948:	d0f7      	beq.n	803693a <RegionBaseUSComputeNext125kHzJoinChannel+0x12>
    startIndex = *groupsCurrentIndex;
 803694a:	780c      	ldrb	r4, [r1, #0]
        if( ( startIndex % 2 ) == 0 )
 803694c:	0863      	lsrs	r3, r4, #1
 803694e:	07e0      	lsls	r0, r4, #31
            currentChannelMaskLeft = ( channelsMaskRemaining[currentChannelMaskLeftIndex] & 0x00FF );
 8036950:	f837 1013 	ldrh.w	r1, [r7, r3, lsl #1]
{
 8036954:	f04f 0300 	mov.w	r3, #0
            currentChannelMaskLeft = ( channelsMaskRemaining[currentChannelMaskLeftIndex] & 0x00FF );
 8036958:	bf54      	ite	pl
 803695a:	b2c9      	uxtbpl	r1, r1
            currentChannelMaskLeft = ( ( channelsMaskRemaining[currentChannelMaskLeftIndex] >> 8 ) & 0x00FF );
 803695c:	0a09      	lsrmi	r1, r1, #8
    *availableChannels = 0;
 803695e:	461d      	mov	r5, r3
        if( ( currentChannelMaskLeft & ( 1 << i ) ) != 0 )
 8036960:	fa41 f203 	asr.w	r2, r1, r3
 8036964:	07d2      	lsls	r2, r2, #31
 8036966:	b2d8      	uxtb	r0, r3
 8036968:	d505      	bpl.n	8036976 <RegionBaseUSComputeNext125kHzJoinChannel+0x4e>
            findAvailableChannelsIndex[*availableChannels] = i;
 803696a:	aa02      	add	r2, sp, #8
 803696c:	442a      	add	r2, r5
            ( *availableChannels )++;
 803696e:	3501      	adds	r5, #1
            findAvailableChannelsIndex[*availableChannels] = i;
 8036970:	f802 0c08 	strb.w	r0, [r2, #-8]
            ( *availableChannels )++;
 8036974:	b2ed      	uxtb	r5, r5
    for( uint8_t i = 0; i < 8; i++ )
 8036976:	3301      	adds	r3, #1
 8036978:	2b08      	cmp	r3, #8
 803697a:	d1f1      	bne.n	8036960 <RegionBaseUSComputeNext125kHzJoinChannel+0x38>
        if ( availableChannels > 0 )
 803697c:	b15d      	cbz	r5, 8036996 <RegionBaseUSComputeNext125kHzJoinChannel+0x6e>
            *newChannelIndex = ( startIndex * 8 ) + findAvailableChannelsIndex[randr( 0, ( availableChannels - 1 ) )];
 803697e:	1e69      	subs	r1, r5, #1
 8036980:	2000      	movs	r0, #0
 8036982:	f002 fab9 	bl	8038ef8 <randr>
 8036986:	ab02      	add	r3, sp, #8
 8036988:	4418      	add	r0, r3
 803698a:	f810 3c08 	ldrb.w	r3, [r0, #-8]
 803698e:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 8036992:	f888 3000 	strb.w	r3, [r8]
        startIndex++;
 8036996:	3401      	adds	r4, #1
 8036998:	b2e4      	uxtb	r4, r4
            startIndex = 0;
 803699a:	2c08      	cmp	r4, #8
 803699c:	bf28      	it	cs
 803699e:	2400      	movcs	r4, #0
    } while( ( availableChannels == 0 ) && ( startIndex != *groupsCurrentIndex ) );
 80369a0:	b91d      	cbnz	r5, 80369aa <RegionBaseUSComputeNext125kHzJoinChannel+0x82>
 80369a2:	7833      	ldrb	r3, [r6, #0]
 80369a4:	42a3      	cmp	r3, r4
 80369a6:	d1d1      	bne.n	803694c <RegionBaseUSComputeNext125kHzJoinChannel+0x24>
 80369a8:	e7c7      	b.n	803693a <RegionBaseUSComputeNext125kHzJoinChannel+0x12>
        *groupsCurrentIndex = startIndex;
 80369aa:	7034      	strb	r4, [r6, #0]
        return LORAMAC_STATUS_OK;
 80369ac:	2000      	movs	r0, #0
 80369ae:	e7c5      	b.n	803693c <RegionBaseUSComputeNext125kHzJoinChannel+0x14>

080369b0 <RegionBaseUSCalcDownlinkFrequency>:
uint32_t RegionBaseUSCalcDownlinkFrequency( uint8_t channel, uint32_t frequency,
                                            uint32_t stepwidth )
{
    // Calculate the frequency
    return frequency + ( channel * stepwidth );
}
 80369b0:	fb02 1000 	mla	r0, r2, r0, r1
 80369b4:	4770      	bx	lr

080369b6 <RegionCommonChanVerifyDr>:
    }
    return nbActiveBits;
}

bool RegionCommonChanVerifyDr( uint8_t nbChannels, uint16_t* channelsMask, int8_t dr, int8_t minDr, int8_t maxDr, ChannelParams_t* channels )
{
 80369b6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    return false;
}

uint8_t RegionCommonValueInRange( int8_t value, int8_t min, int8_t max )
{
    if( ( value >= min ) && ( value <= max ) )
 80369ba:	429a      	cmp	r2, r3
{
 80369bc:	9f07      	ldr	r7, [sp, #28]
    if( ( value >= min ) && ( value <= max ) )
 80369be:	db03      	blt.n	80369c8 <RegionCommonChanVerifyDr+0x12>
 80369c0:	f99d 3018 	ldrsb.w	r3, [sp, #24]
 80369c4:	429a      	cmp	r2, r3
 80369c6:	dd24      	ble.n	8036a12 <RegionCommonChanVerifyDr+0x5c>
        return false;
 80369c8:	2000      	movs	r0, #0
}
 80369ca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            if( ( ( channelsMask[k] & ( 1 << j ) ) != 0 ) )
 80369ce:	f831 8014 	ldrh.w	r8, [r1, r4, lsl #1]
 80369d2:	fb1e 7303 	smlabb	r3, lr, r3, r7
 80369d6:	2500      	movs	r5, #0
 80369d8:	fa48 f605 	asr.w	r6, r8, r5
 80369dc:	07f6      	lsls	r6, r6, #31
 80369de:	d50e      	bpl.n	80369fe <RegionCommonChanVerifyDr+0x48>
                if( RegionCommonValueInRange( dr, ( channels[i + j].DrRange.Fields.Min & 0x0F ),
 80369e0:	fb0e 3605 	mla	r6, lr, r5, r3
                                                  ( channels[i + j].DrRange.Fields.Max & 0x0F ) ) == 1 )
 80369e4:	f896 c008 	ldrb.w	ip, [r6, #8]
 80369e8:	f34c 1603 	sbfx	r6, ip, #4, #4
    if( ( value >= min ) && ( value <= max ) )
 80369ec:	f00c 0c0f 	and.w	ip, ip, #15
 80369f0:	4562      	cmp	r2, ip
                                                  ( channels[i + j].DrRange.Fields.Max & 0x0F ) ) == 1 )
 80369f2:	b276      	sxtb	r6, r6
    if( ( value >= min ) && ( value <= max ) )
 80369f4:	db03      	blt.n	80369fe <RegionCommonChanVerifyDr+0x48>
 80369f6:	f006 060f 	and.w	r6, r6, #15
 80369fa:	42b2      	cmp	r2, r6
 80369fc:	dd0d      	ble.n	8036a1a <RegionCommonChanVerifyDr+0x64>
        for( uint8_t j = 0; j < 16; j++ )
 80369fe:	3501      	adds	r5, #1
 8036a00:	2d10      	cmp	r5, #16
 8036a02:	d1e9      	bne.n	80369d8 <RegionCommonChanVerifyDr+0x22>
    for( uint8_t i = 0, k = 0; i < nbChannels; i += 16, k++ )
 8036a04:	3401      	adds	r4, #1
 8036a06:	b2e4      	uxtb	r4, r4
 8036a08:	0123      	lsls	r3, r4, #4
 8036a0a:	b2db      	uxtb	r3, r3
 8036a0c:	4298      	cmp	r0, r3
 8036a0e:	d8de      	bhi.n	80369ce <RegionCommonChanVerifyDr+0x18>
 8036a10:	e7da      	b.n	80369c8 <RegionCommonChanVerifyDr+0x12>
 8036a12:	2400      	movs	r4, #0
 8036a14:	f04f 0e0c 	mov.w	lr, #12
 8036a18:	e7f6      	b.n	8036a08 <RegionCommonChanVerifyDr+0x52>
                    return true;
 8036a1a:	2001      	movs	r0, #1
 8036a1c:	e7d5      	b.n	80369ca <RegionCommonChanVerifyDr+0x14>

08036a1e <RegionCommonValueInRange>:
    if( ( value >= min ) && ( value <= max ) )
 8036a1e:	4288      	cmp	r0, r1
 8036a20:	db04      	blt.n	8036a2c <RegionCommonValueInRange+0xe>
    {
        return 1;
 8036a22:	4290      	cmp	r0, r2
 8036a24:	bfcc      	ite	gt
 8036a26:	2000      	movgt	r0, #0
 8036a28:	2001      	movle	r0, #1
 8036a2a:	4770      	bx	lr
    }
    return 0;
 8036a2c:	2000      	movs	r0, #0
}
 8036a2e:	4770      	bx	lr

08036a30 <RegionCommonChanDisable>:

bool RegionCommonChanDisable( uint16_t* channelsMask, uint8_t id, uint8_t maxChannels )
{
 8036a30:	b510      	push	{r4, lr}
    uint8_t index = id / 16;

    if( ( index > ( maxChannels / 16 ) ) || ( id >= maxChannels ) )
 8036a32:	0914      	lsrs	r4, r2, #4
 8036a34:	ebb4 1f11 	cmp.w	r4, r1, lsr #4
{
 8036a38:	4603      	mov	r3, r0
    uint8_t index = id / 16;
 8036a3a:	ea4f 1011 	mov.w	r0, r1, lsr #4
    if( ( index > ( maxChannels / 16 ) ) || ( id >= maxChannels ) )
 8036a3e:	d30e      	bcc.n	8036a5e <RegionCommonChanDisable+0x2e>
 8036a40:	4291      	cmp	r1, r2
 8036a42:	d20c      	bcs.n	8036a5e <RegionCommonChanDisable+0x2e>
    {
        return false;
    }

    // Deactivate channel
    channelsMask[index] &= ~( 1 << ( id % 16 ) );
 8036a44:	b202      	sxth	r2, r0
 8036a46:	f001 010f 	and.w	r1, r1, #15
 8036a4a:	f833 4012 	ldrh.w	r4, [r3, r2, lsl #1]
 8036a4e:	2001      	movs	r0, #1
 8036a50:	fa00 f101 	lsl.w	r1, r0, r1
 8036a54:	ea24 0101 	bic.w	r1, r4, r1
 8036a58:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]

    return true;
}
 8036a5c:	bd10      	pop	{r4, pc}
        return false;
 8036a5e:	2000      	movs	r0, #0
 8036a60:	e7fc      	b.n	8036a5c <RegionCommonChanDisable+0x2c>

08036a62 <RegionCommonCountChannels>:

uint8_t RegionCommonCountChannels( uint16_t* channelsMask, uint8_t startIdx, uint8_t stopIdx )
{
 8036a62:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint8_t nbChannels = 0;

    if( channelsMask == NULL )
 8036a64:	b128      	cbz	r0, 8036a72 <RegionCommonCountChannels+0x10>
 8036a66:	eb00 0541 	add.w	r5, r0, r1, lsl #1
        if( ( mask & ( 1 << j ) ) == ( 1 << j ) )
 8036a6a:	2601      	movs	r6, #1
    uint8_t nbChannels = 0;
 8036a6c:	2000      	movs	r0, #0
    {
        return 0;
    }

    for( uint8_t i = startIdx; i < stopIdx; i++ )
 8036a6e:	4291      	cmp	r1, r2
 8036a70:	d300      	bcc.n	8036a74 <RegionCommonCountChannels+0x12>
    {
        nbChannels += CountChannels( channelsMask[i], 16 );
    }

    return nbChannels;
}
 8036a72:	bdf0      	pop	{r4, r5, r6, r7, pc}
        nbChannels += CountChannels( channelsMask[i], 16 );
 8036a74:	2400      	movs	r4, #0
 8036a76:	f835 7b02 	ldrh.w	r7, [r5], #2
    uint8_t nbActiveBits = 0;
 8036a7a:	4623      	mov	r3, r4
        if( ( mask & ( 1 << j ) ) == ( 1 << j ) )
 8036a7c:	fa06 fc04 	lsl.w	ip, r6, r4
 8036a80:	ea3c 0c07 	bics.w	ip, ip, r7
            nbActiveBits++;
 8036a84:	bf08      	it	eq
 8036a86:	3301      	addeq	r3, #1
 8036a88:	f104 0401 	add.w	r4, r4, #1
 8036a8c:	bf08      	it	eq
 8036a8e:	b2db      	uxtbeq	r3, r3
    for( uint8_t j = 0; j < nbBits; j++ )
 8036a90:	2c10      	cmp	r4, #16
 8036a92:	d1f3      	bne.n	8036a7c <RegionCommonCountChannels+0x1a>
        nbChannels += CountChannels( channelsMask[i], 16 );
 8036a94:	4418      	add	r0, r3
    for( uint8_t i = startIdx; i < stopIdx; i++ )
 8036a96:	3101      	adds	r1, #1
        nbChannels += CountChannels( channelsMask[i], 16 );
 8036a98:	b2c0      	uxtb	r0, r0
    for( uint8_t i = startIdx; i < stopIdx; i++ )
 8036a9a:	b2c9      	uxtb	r1, r1
 8036a9c:	e7e7      	b.n	8036a6e <RegionCommonCountChannels+0xc>

08036a9e <RegionCommonChanMaskCopy>:

void RegionCommonChanMaskCopy( uint16_t* channelsMaskDest, uint16_t* channelsMaskSrc, uint8_t len )
{
 8036a9e:	b510      	push	{r4, lr}
    if( ( channelsMaskDest != NULL ) && ( channelsMaskSrc != NULL ) )
 8036aa0:	b100      	cbz	r0, 8036aa4 <RegionCommonChanMaskCopy+0x6>
 8036aa2:	b949      	cbnz	r1, 8036ab8 <RegionCommonChanMaskCopy+0x1a>
        for( uint8_t i = 0; i < len; i++ )
        {
            channelsMaskDest[i] = channelsMaskSrc[i];
        }
    }
}
 8036aa4:	bd10      	pop	{r4, pc}
            channelsMaskDest[i] = channelsMaskSrc[i];
 8036aa6:	f831 4013 	ldrh.w	r4, [r1, r3, lsl #1]
 8036aaa:	f820 4013 	strh.w	r4, [r0, r3, lsl #1]
        for( uint8_t i = 0; i < len; i++ )
 8036aae:	3301      	adds	r3, #1
 8036ab0:	b2dc      	uxtb	r4, r3
 8036ab2:	42a2      	cmp	r2, r4
 8036ab4:	d8f7      	bhi.n	8036aa6 <RegionCommonChanMaskCopy+0x8>
 8036ab6:	e7f5      	b.n	8036aa4 <RegionCommonChanMaskCopy+0x6>
 8036ab8:	2300      	movs	r3, #0
 8036aba:	e7f9      	b.n	8036ab0 <RegionCommonChanMaskCopy+0x12>

08036abc <RegionCommonSetBandTxDone>:

void RegionCommonSetBandTxDone( Band_t* band, TimerTime_t lastTxAirTime, bool joined, SysTime_t elapsedTimeSinceStartup )
{
 8036abc:	b082      	sub	sp, #8
 8036abe:	b530      	push	{r4, r5, lr}
    // Get the band duty cycle. If not joined, the function either returns the join duty cycle
    // or the band duty cycle, whichever is more restrictive.
    uint16_t dutyCycle = GetDutyCycle( band, joined, elapsedTimeSinceStartup );
 8036ac0:	8804      	ldrh	r4, [r0, #0]
{
 8036ac2:	9304      	str	r3, [sp, #16]
    if( joined == false )
 8036ac4:	b972      	cbnz	r2, 8036ae4 <RegionCommonSetBandTxDone+0x28>
        if( elapsedTimeSinceStartup.Seconds < BACKOFF_DUTY_CYCLE_1_HOUR_IN_S )
 8036ac6:	f5b3 6f61 	cmp.w	r3, #3600	; 0xe10
 8036aca:	d319      	bcc.n	8036b00 <RegionCommonSetBandTxDone+0x44>
            joinDutyCycle = BACKOFF_DC_24_HOURS;
 8036acc:	f649 25af 	movw	r5, #39599	; 0x9aaf
 8036ad0:	f242 7210 	movw	r2, #10000	; 0x2710
 8036ad4:	42ab      	cmp	r3, r5
 8036ad6:	bf8c      	ite	hi
 8036ad8:	4613      	movhi	r3, r2
 8036ada:	f44f 737a 	movls.w	r3, #1000	; 0x3e8
        dutyCycle = MAX( dutyCycle, joinDutyCycle );
 8036ade:	429c      	cmp	r4, r3
 8036ae0:	bf38      	it	cc
 8036ae2:	461c      	movcc	r4, r3

    // Reduce with transmission time
    if( band->TimeCredits > ( lastTxAirTime * dutyCycle ) )
 8036ae4:	2c01      	cmp	r4, #1
 8036ae6:	bf38      	it	cc
 8036ae8:	2401      	movcc	r4, #1
 8036aea:	4361      	muls	r1, r4
    }
    else
    {
        band->TimeCredits = 0;
    }
}
 8036aec:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    if( band->TimeCredits > ( lastTxAirTime * dutyCycle ) )
 8036af0:	68c3      	ldr	r3, [r0, #12]
 8036af2:	428b      	cmp	r3, r1
        band->TimeCredits -= ( lastTxAirTime * dutyCycle );
 8036af4:	bf8c      	ite	hi
 8036af6:	1a59      	subhi	r1, r3, r1
        band->TimeCredits = 0;
 8036af8:	2100      	movls	r1, #0
 8036afa:	60c1      	str	r1, [r0, #12]
}
 8036afc:	b002      	add	sp, #8
 8036afe:	4770      	bx	lr
            joinDutyCycle = BACKOFF_DC_1_HOUR;
 8036b00:	2364      	movs	r3, #100	; 0x64
 8036b02:	e7ec      	b.n	8036ade <RegionCommonSetBandTxDone+0x22>

08036b04 <RegionCommonUpdateBandTimeOff>:

TimerTime_t RegionCommonUpdateBandTimeOff( bool joined, Band_t* bands,
                                           uint8_t nbBands, bool dutyCycleEnabled,
                                           bool lastTxIsJoinRequest, SysTime_t elapsedTimeSinceStartup,
                                           TimerTime_t expectedTimeOnAir )
{
 8036b04:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8036b08:	b091      	sub	sp, #68	; 0x44
 8036b0a:	4615      	mov	r5, r2
 8036b0c:	f8dd 806c 	ldr.w	r8, [sp, #108]	; 0x6c
 8036b10:	9305      	str	r3, [sp, #20]
 8036b12:	f89d 3068 	ldrb.w	r3, [sp, #104]	; 0x68
 8036b16:	9309      	str	r3, [sp, #36]	; 0x24
 8036b18:	460c      	mov	r4, r1
 8036b1a:	4606      	mov	r6, r0
    TimerTime_t minTimeToWait = TIMERTIME_T_MAX;
    TimerTime_t currentTime = TimerGetCurrentTime( );
 8036b1c:	f004 fbcc 	bl	803b2b8 <UTIL_TIMER_GetCurrentTime>
                timeDiff.Seconds = ( elapsedTimeSinceStartup.Seconds - BACKOFF_DUTY_CYCLE_24_HOURS_IN_S ) / BACKOFF_24_HOURS_IN_S;
 8036b20:	4b68      	ldr	r3, [pc, #416]	; (8036cc4 <RegionCommonUpdateBandTimeOff+0x1c0>)
 8036b22:	f8df b1b8 	ldr.w	fp, [pc, #440]	; 8036cdc <RegionCommonUpdateBandTimeOff+0x1d8>
    TimerTime_t currentTime = TimerGetCurrentTime( );
 8036b26:	9006      	str	r0, [sp, #24]
                timeDiff.Seconds = ( elapsedTimeSinceStartup.Seconds - BACKOFF_DUTY_CYCLE_24_HOURS_IN_S ) / BACKOFF_24_HOURS_IN_S;
 8036b28:	f5a8 32f6 	sub.w	r2, r8, #125952	; 0x1ec00
 8036b2c:	3a30      	subs	r2, #48	; 0x30
 8036b2e:	fbb2 f2f3 	udiv	r2, r2, r3
                timeDiff.Seconds *= BACKOFF_24_HOURS_IN_S;
 8036b32:	4353      	muls	r3, r2
                timeDiff.Seconds += BACKOFF_DUTY_CYCLE_24_HOURS_IN_S;
 8036b34:	f503 32f6 	add.w	r2, r3, #125952	; 0x1ec00
 8036b38:	3230      	adds	r2, #48	; 0x30
                    backoffTimeRange.Seconds = BACKOFF_DUTY_CYCLE_24_HOURS_IN_S;
                }
                // Calculate the time to wait.
                if( elapsedTimeSinceStartup.Seconds > BACKOFF_DUTY_CYCLE_24_HOURS_IN_S )
                {
                    backoffTimeRange.Seconds += BACKOFF_24_HOURS_IN_S * ( ( ( elapsedTimeSinceStartup.Seconds - BACKOFF_DUTY_CYCLE_24_HOURS_IN_S ) / BACKOFF_24_HOURS_IN_S ) + 1 );
 8036b3a:	f503 33a8 	add.w	r3, r3, #86016	; 0x15000
 8036b3e:	f503 73c0 	add.w	r3, r3, #384	; 0x180
                timeDiff.Seconds += BACKOFF_DUTY_CYCLE_24_HOURS_IN_S;
 8036b42:	9204      	str	r2, [sp, #16]
 8036b44:	2218      	movs	r2, #24
                    backoffTimeRange.Seconds += BACKOFF_24_HOURS_IN_S * ( ( ( elapsedTimeSinceStartup.Seconds - BACKOFF_DUTY_CYCLE_24_HOURS_IN_S ) / BACKOFF_24_HOURS_IN_S ) + 1 );
 8036b46:	9303      	str	r3, [sp, #12]
 8036b48:	fb12 4305 	smlabb	r3, r2, r5, r4
 8036b4c:	9307      	str	r3, [sp, #28]
    uint8_t validBands = 0;
 8036b4e:	2500      	movs	r5, #0
    TimerTime_t minTimeToWait = TIMERTIME_T_MAX;
 8036b50:	f04f 3aff 	mov.w	sl, #4294967295
    for( uint8_t i = 0; i < nbBands; i++ )
 8036b54:	9b07      	ldr	r3, [sp, #28]
 8036b56:	42a3      	cmp	r3, r4
 8036b58:	d107      	bne.n	8036b6a <RegionCommonUpdateBandTimeOff+0x66>

    if( validBands == 0 )
    {
        // There is no valid band available to handle a transmission
        // in the given DUTY_CYCLE_TIME_PERIOD.
        return TIMERTIME_T_MAX;
 8036b5a:	2d00      	cmp	r5, #0
    }
    return minTimeToWait;
}
 8036b5c:	bf14      	ite	ne
 8036b5e:	4650      	movne	r0, sl
 8036b60:	f04f 30ff 	moveq.w	r0, #4294967295
 8036b64:	b011      	add	sp, #68	; 0x44
 8036b66:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        dutyCycle = UpdateTimeCredits( &bands[i], joined, dutyCycleEnabled,
 8036b6a:	f9bd 3070 	ldrsh.w	r3, [sp, #112]	; 0x70
 8036b6e:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
    TimerTime_t elapsedTime = SysTimeToMs( elapsedTimeSinceStartup );
 8036b72:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8036b74:	f8cd 806c 	str.w	r8, [sp, #108]	; 0x6c
 8036b78:	4640      	mov	r0, r8
 8036b7a:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
 8036b7e:	f004 fb2d 	bl	803b1dc <SysTimeToMs>
    dutyCycle = GetDutyCycle( band, joined, elapsedTimeSinceStartup );
 8036b82:	f8b4 9000 	ldrh.w	r9, [r4]
    if( joined == false )
 8036b86:	b96e      	cbnz	r6, 8036ba4 <RegionCommonUpdateBandTimeOff+0xa0>
        if( elapsedTimeSinceStartup.Seconds < BACKOFF_DUTY_CYCLE_1_HOUR_IN_S )
 8036b88:	f5b8 6f61 	cmp.w	r8, #3600	; 0xe10
 8036b8c:	d35b      	bcc.n	8036c46 <RegionCommonUpdateBandTimeOff+0x142>
            joinDutyCycle = BACKOFF_DC_24_HOURS;
 8036b8e:	f649 22af 	movw	r2, #39599	; 0x9aaf
 8036b92:	f242 7310 	movw	r3, #10000	; 0x2710
 8036b96:	4590      	cmp	r8, r2
 8036b98:	bf98      	it	ls
 8036b9a:	f44f 737a 	movls.w	r3, #1000	; 0x3e8
        dutyCycle = MAX( dutyCycle, joinDutyCycle );
 8036b9e:	4599      	cmp	r9, r3
 8036ba0:	bf38      	it	cc
 8036ba2:	4699      	movcc	r9, r3
    if( dutyCycle == 0 )
 8036ba4:	464b      	mov	r3, r9
 8036ba6:	2b01      	cmp	r3, #1
 8036ba8:	bf38      	it	cc
 8036baa:	2301      	movcc	r3, #1
 8036bac:	9308      	str	r3, [sp, #32]
    if( joined == false )
 8036bae:	2e00      	cmp	r6, #0
 8036bb0:	d152      	bne.n	8036c58 <RegionCommonUpdateBandTimeOff+0x154>
        if( dutyCycle == BACKOFF_DC_1_HOUR )
 8036bb2:	f1b9 0f64 	cmp.w	r9, #100	; 0x64
 8036bb6:	d148      	bne.n	8036c4a <RegionCommonUpdateBandTimeOff+0x146>
            band->LastMaxCreditAssignTime = elapsedTime;
 8036bb8:	60a0      	str	r0, [r4, #8]
            maxCredits = DUTY_CYCLE_TIME_PERIOD;
 8036bba:	465f      	mov	r7, fp
        timeDiff = SysTimeSub( elapsedTimeSinceStartup, SysTimeFromMs( band->LastMaxCreditAssignTime ) );
 8036bbc:	68a1      	ldr	r1, [r4, #8]
 8036bbe:	a80e      	add	r0, sp, #56	; 0x38
 8036bc0:	f004 fb2c 	bl	803b21c <SysTimeFromMs>
 8036bc4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8036bc6:	9300      	str	r3, [sp, #0]
 8036bc8:	e9dd 120a 	ldrd	r1, r2, [sp, #40]	; 0x28
 8036bcc:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8036bce:	a80c      	add	r0, sp, #48	; 0x30
 8036bd0:	f004 fa84 	bl	803b0dc <SysTimeSub>
        if( ( ( dutyCycleEnabled == false ) && ( lastTxIsJoinRequest == false ) ) ||
 8036bd4:	9b05      	ldr	r3, [sp, #20]
 8036bd6:	b90b      	cbnz	r3, 8036bdc <RegionCommonUpdateBandTimeOff+0xd8>
 8036bd8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8036bda:	b133      	cbz	r3, 8036bea <RegionCommonUpdateBandTimeOff+0xe6>
 8036bdc:	6923      	ldr	r3, [r4, #16]
 8036bde:	42bb      	cmp	r3, r7
 8036be0:	d103      	bne.n	8036bea <RegionCommonUpdateBandTimeOff+0xe6>
            ( band->MaxTimeCredits != maxCredits ) ||
 8036be2:	4b39      	ldr	r3, [pc, #228]	; (8036cc8 <RegionCommonUpdateBandTimeOff+0x1c4>)
 8036be4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8036be6:	429a      	cmp	r2, r3
 8036be8:	d90d      	bls.n	8036c06 <RegionCommonUpdateBandTimeOff+0x102>
            if( elapsedTimeSinceStartup.Seconds >= BACKOFF_DUTY_CYCLE_24_HOURS_IN_S )
 8036bea:	4b38      	ldr	r3, [pc, #224]	; (8036ccc <RegionCommonUpdateBandTimeOff+0x1c8>)
            band->TimeCredits = maxCredits;
 8036bec:	60e7      	str	r7, [r4, #12]
            if( elapsedTimeSinceStartup.Seconds >= BACKOFF_DUTY_CYCLE_24_HOURS_IN_S )
 8036bee:	4598      	cmp	r8, r3
 8036bf0:	d909      	bls.n	8036c06 <RegionCommonUpdateBandTimeOff+0x102>
                timeDiff.SubSeconds = 0;
 8036bf2:	2300      	movs	r3, #0
 8036bf4:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
                band->LastMaxCreditAssignTime = SysTimeToMs( timeDiff );
 8036bf8:	9b04      	ldr	r3, [sp, #16]
 8036bfa:	990d      	ldr	r1, [sp, #52]	; 0x34
 8036bfc:	930c      	str	r3, [sp, #48]	; 0x30
 8036bfe:	4618      	mov	r0, r3
 8036c00:	f004 faec 	bl	803b1dc <SysTimeToMs>
 8036c04:	60a0      	str	r0, [r4, #8]
    if( band->LastBandUpdateTime == 0 )
 8036c06:	6860      	ldr	r0, [r4, #4]
 8036c08:	b900      	cbnz	r0, 8036c0c <RegionCommonUpdateBandTimeOff+0x108>
        band->TimeCredits = maxCredits;
 8036c0a:	60e7      	str	r7, [r4, #12]
    band->MaxTimeCredits = maxCredits;
 8036c0c:	6127      	str	r7, [r4, #16]
    if( joined == true )
 8036c0e:	b126      	cbz	r6, 8036c1a <RegionCommonUpdateBandTimeOff+0x116>
        band->TimeCredits += TimerGetElapsedTime( band->LastBandUpdateTime );
 8036c10:	f004 fb5c 	bl	803b2cc <UTIL_TIMER_GetElapsedTime>
 8036c14:	68e3      	ldr	r3, [r4, #12]
 8036c16:	4403      	add	r3, r0
 8036c18:	60e3      	str	r3, [r4, #12]
    if( band->TimeCredits > band->MaxTimeCredits )
 8036c1a:	e9d4 3203 	ldrd	r3, r2, [r4, #12]
 8036c1e:	4293      	cmp	r3, r2
    band->LastBandUpdateTime = currentTime;
 8036c20:	9b06      	ldr	r3, [sp, #24]
        creditCosts = expectedTimeOnAir * dutyCycle;
 8036c22:	991d      	ldr	r1, [sp, #116]	; 0x74
    band->LastBandUpdateTime = currentTime;
 8036c24:	6063      	str	r3, [r4, #4]
        creditCosts = expectedTimeOnAir * dutyCycle;
 8036c26:	9b08      	ldr	r3, [sp, #32]
        band->TimeCredits = band->MaxTimeCredits;
 8036c28:	bf88      	it	hi
 8036c2a:	60e2      	strhi	r2, [r4, #12]
        creditCosts = expectedTimeOnAir * dutyCycle;
 8036c2c:	434b      	muls	r3, r1
        if( ( bands[i].TimeCredits > creditCosts ) ||
 8036c2e:	68e1      	ldr	r1, [r4, #12]
 8036c30:	4299      	cmp	r1, r3
 8036c32:	d802      	bhi.n	8036c3a <RegionCommonUpdateBandTimeOff+0x136>
 8036c34:	9805      	ldr	r0, [sp, #20]
 8036c36:	b9a8      	cbnz	r0, 8036c64 <RegionCommonUpdateBandTimeOff+0x160>
            ( ( dutyCycleEnabled == false ) && ( joined == true ) ) )
 8036c38:	b1a6      	cbz	r6, 8036c64 <RegionCommonUpdateBandTimeOff+0x160>
            bands[i].ReadyForTransmission = true;
 8036c3a:	2301      	movs	r3, #1
            validBands++;
 8036c3c:	441d      	add	r5, r3
            bands[i].ReadyForTransmission = true;
 8036c3e:	7523      	strb	r3, [r4, #20]
            validBands++;
 8036c40:	b2ed      	uxtb	r5, r5
    for( uint8_t i = 0; i < nbBands; i++ )
 8036c42:	3418      	adds	r4, #24
 8036c44:	e786      	b.n	8036b54 <RegionCommonUpdateBandTimeOff+0x50>
            joinDutyCycle = BACKOFF_DC_1_HOUR;
 8036c46:	2364      	movs	r3, #100	; 0x64
 8036c48:	e7a9      	b.n	8036b9e <RegionCommonUpdateBandTimeOff+0x9a>
        else if( dutyCycle == BACKOFF_DC_10_HOURS )
 8036c4a:	f5b9 7f7a 	cmp.w	r9, #1000	; 0x3e8
            maxCredits = DUTY_CYCLE_TIME_PERIOD * 10;
 8036c4e:	bf0a      	itet	eq
 8036c50:	4f1f      	ldreq	r7, [pc, #124]	; (8036cd0 <RegionCommonUpdateBandTimeOff+0x1cc>)
            maxCredits = DUTY_CYCLE_TIME_PERIOD * 24;
 8036c52:	4f20      	ldrne	r7, [pc, #128]	; (8036cd4 <RegionCommonUpdateBandTimeOff+0x1d0>)
            band->LastMaxCreditAssignTime = elapsedTime;
 8036c54:	60a0      	streq	r0, [r4, #8]
 8036c56:	e7b1      	b.n	8036bbc <RegionCommonUpdateBandTimeOff+0xb8>
        if( dutyCycleEnabled == false )
 8036c58:	9b05      	ldr	r3, [sp, #20]
 8036c5a:	b90b      	cbnz	r3, 8036c60 <RegionCommonUpdateBandTimeOff+0x15c>
            band->TimeCredits = maxCredits;
 8036c5c:	f8c4 b00c 	str.w	fp, [r4, #12]
    TimerTime_t maxCredits = DUTY_CYCLE_TIME_PERIOD;
 8036c60:	465f      	mov	r7, fp
 8036c62:	e7d0      	b.n	8036c06 <RegionCommonUpdateBandTimeOff+0x102>
            bands[i].ReadyForTransmission = false;
 8036c64:	2000      	movs	r0, #0
            if( bands[i].MaxTimeCredits > creditCosts )
 8036c66:	4293      	cmp	r3, r2
            bands[i].ReadyForTransmission = false;
 8036c68:	7520      	strb	r0, [r4, #20]
            if( bands[i].MaxTimeCredits > creditCosts )
 8036c6a:	d206      	bcs.n	8036c7a <RegionCommonUpdateBandTimeOff+0x176>
                minTimeToWait = MIN( minTimeToWait, ( creditCosts - bands[i].TimeCredits ) );
 8036c6c:	1a5b      	subs	r3, r3, r1
 8036c6e:	459a      	cmp	sl, r3
                validBands++;
 8036c70:	f105 0501 	add.w	r5, r5, #1
                minTimeToWait = MIN( minTimeToWait, ( creditCosts - bands[i].TimeCredits ) );
 8036c74:	bf28      	it	cs
 8036c76:	469a      	movcs	sl, r3
                validBands++;
 8036c78:	b2ed      	uxtb	r5, r5
            if( joined == false )
 8036c7a:	2e00      	cmp	r6, #0
 8036c7c:	d1e1      	bne.n	8036c42 <RegionCommonUpdateBandTimeOff+0x13e>
                if( dutyCycle == BACKOFF_DC_1_HOUR )
 8036c7e:	f1b9 0f64 	cmp.w	r9, #100	; 0x64
 8036c82:	4a15      	ldr	r2, [pc, #84]	; (8036cd8 <RegionCommonUpdateBandTimeOff+0x1d4>)
                SysTime_t backoffTimeRange = {
 8036c84:	f8ad 6034 	strh.w	r6, [sp, #52]	; 0x34
                if( dutyCycle == BACKOFF_DC_1_HOUR )
 8036c88:	d019      	beq.n	8036cbe <RegionCommonUpdateBandTimeOff+0x1ba>
                    backoffTimeRange.Seconds = BACKOFF_DUTY_CYCLE_24_HOURS_IN_S;
 8036c8a:	f649 23b0 	movw	r3, #39600	; 0x9ab0
 8036c8e:	f5b9 7f7a 	cmp.w	r9, #1000	; 0x3e8
 8036c92:	bf18      	it	ne
 8036c94:	4613      	movne	r3, r2
                if( elapsedTimeSinceStartup.Seconds > BACKOFF_DUTY_CYCLE_24_HOURS_IN_S )
 8036c96:	4590      	cmp	r8, r2
                    backoffTimeRange.Seconds += BACKOFF_24_HOURS_IN_S * ( ( ( elapsedTimeSinceStartup.Seconds - BACKOFF_DUTY_CYCLE_24_HOURS_IN_S ) / BACKOFF_24_HOURS_IN_S ) + 1 );
 8036c98:	bf84      	itt	hi
 8036c9a:	9a03      	ldrhi	r2, [sp, #12]
 8036c9c:	189b      	addhi	r3, r3, r2
                backoffTimeRange  = SysTimeSub( backoffTimeRange, elapsedTimeSinceStartup );
 8036c9e:	930c      	str	r3, [sp, #48]	; 0x30
 8036ca0:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8036ca2:	9300      	str	r3, [sp, #0]
 8036ca4:	af0c      	add	r7, sp, #48	; 0x30
 8036ca6:	e897 0006 	ldmia.w	r7, {r1, r2}
 8036caa:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8036cac:	4638      	mov	r0, r7
 8036cae:	f004 fa15 	bl	803b0dc <SysTimeSub>
                minTimeToWait = SysTimeToMs( backoffTimeRange );
 8036cb2:	e897 0003 	ldmia.w	r7, {r0, r1}
 8036cb6:	f004 fa91 	bl	803b1dc <SysTimeToMs>
 8036cba:	4682      	mov	sl, r0
 8036cbc:	e7c1      	b.n	8036c42 <RegionCommonUpdateBandTimeOff+0x13e>
                    backoffTimeRange.Seconds = BACKOFF_DUTY_CYCLE_1_HOUR_IN_S;
 8036cbe:	f44f 6361 	mov.w	r3, #3600	; 0xe10
 8036cc2:	e7e8      	b.n	8036c96 <RegionCommonUpdateBandTimeOff+0x192>
 8036cc4:	00015180 	.word	0x00015180
 8036cc8:	0001517f 	.word	0x0001517f
 8036ccc:	0001ec2f 	.word	0x0001ec2f
 8036cd0:	0112a880 	.word	0x0112a880
 8036cd4:	02932e00 	.word	0x02932e00
 8036cd8:	0001ec30 	.word	0x0001ec30
 8036cdc:	001b7740 	.word	0x001b7740

08036ce0 <RegionCommonParseLinkAdrReq>:

uint8_t RegionCommonParseLinkAdrReq( uint8_t* payload, RegionCommonLinkAdrParams_t* linkAdrParams )
{
    uint8_t retIndex = 0;

    if( payload[0] == SRV_MAC_LINK_ADR_REQ )
 8036ce0:	7803      	ldrb	r3, [r0, #0]
 8036ce2:	2b03      	cmp	r3, #3
 8036ce4:	d114      	bne.n	8036d10 <RegionCommonParseLinkAdrReq+0x30>
    {
        // Parse datarate and tx power
        linkAdrParams->Datarate = payload[1];
 8036ce6:	7843      	ldrb	r3, [r0, #1]
        linkAdrParams->TxPower = linkAdrParams->Datarate & 0x0F;
 8036ce8:	f003 020f 	and.w	r2, r3, #15
        linkAdrParams->Datarate = ( linkAdrParams->Datarate >> 4 ) & 0x0F;
 8036cec:	091b      	lsrs	r3, r3, #4
        linkAdrParams->TxPower = linkAdrParams->Datarate & 0x0F;
 8036cee:	708a      	strb	r2, [r1, #2]
        linkAdrParams->Datarate = ( linkAdrParams->Datarate >> 4 ) & 0x0F;
 8036cf0:	704b      	strb	r3, [r1, #1]
        // Parse ChMask
        linkAdrParams->ChMask = ( uint16_t )payload[2];
 8036cf2:	7883      	ldrb	r3, [r0, #2]
 8036cf4:	808b      	strh	r3, [r1, #4]
        linkAdrParams->ChMask |= ( uint16_t )payload[3] << 8;
 8036cf6:	78c2      	ldrb	r2, [r0, #3]
 8036cf8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8036cfc:	808b      	strh	r3, [r1, #4]
        // Parse ChMaskCtrl and nbRep
        linkAdrParams->NbRep = payload[4];
 8036cfe:	7903      	ldrb	r3, [r0, #4]
        linkAdrParams->ChMaskCtrl = ( linkAdrParams->NbRep >> 4 ) & 0x07;
 8036d00:	f3c3 1202 	ubfx	r2, r3, #4, #3
        linkAdrParams->NbRep &= 0x0F;
 8036d04:	f003 030f 	and.w	r3, r3, #15
        linkAdrParams->ChMaskCtrl = ( linkAdrParams->NbRep >> 4 ) & 0x07;
 8036d08:	70ca      	strb	r2, [r1, #3]
        linkAdrParams->NbRep &= 0x0F;
 8036d0a:	700b      	strb	r3, [r1, #0]

        // LinkAdrReq has 4 bytes length + 1 byte CMD
        retIndex = 5;
 8036d0c:	2005      	movs	r0, #5
 8036d0e:	4770      	bx	lr
    uint8_t retIndex = 0;
 8036d10:	2000      	movs	r0, #0
    }
    return retIndex;
}
 8036d12:	4770      	bx	lr

08036d14 <RegionCommonLinkAdrReqVerifyParams>:

uint8_t RegionCommonLinkAdrReqVerifyParams( RegionCommonLinkAdrReqVerifyParams_t* verifyParams, int8_t* dr, int8_t* txPow, uint8_t* nbRep )
{
 8036d14:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 8036d18:	4698      	mov	r8, r3
    int8_t datarate = verifyParams->Datarate;
    int8_t txPower = verifyParams->TxPower;
    int8_t nbRepetitions = verifyParams->NbRep;

    // Handle the case when ADR is off.
    if( verifyParams->AdrEnabled == false )
 8036d1a:	7943      	ldrb	r3, [r0, #5]
    uint8_t status = verifyParams->Status;
 8036d1c:	7905      	ldrb	r5, [r0, #4]
    int8_t txPower = verifyParams->TxPower;
 8036d1e:	f990 7007 	ldrsb.w	r7, [r0, #7]
    int8_t nbRepetitions = verifyParams->NbRep;
 8036d22:	7a06      	ldrb	r6, [r0, #8]
{
 8036d24:	4691      	mov	r9, r2
 8036d26:	4604      	mov	r4, r0
    int8_t datarate = verifyParams->Datarate;
 8036d28:	f990 2006 	ldrsb.w	r2, [r0, #6]
{
 8036d2c:	468a      	mov	sl, r1
    if( verifyParams->AdrEnabled == false )
 8036d2e:	b31b      	cbz	r3, 8036d78 <RegionCommonLinkAdrReqVerifyParams+0x64>
    int8_t nbRepetitions = verifyParams->NbRep;
 8036d30:	b276      	sxtb	r6, r6
        nbRepetitions = verifyParams->CurrentNbRep;
        datarate =  verifyParams->CurrentDatarate;
        txPower =  verifyParams->CurrentTxPower;
    }

    if( status != 0 )
 8036d32:	b1bd      	cbz	r5, 8036d64 <RegionCommonLinkAdrReqVerifyParams+0x50>
    {
        // Verify datarate. The variable phyParam. Value contains the minimum allowed datarate.
        if( RegionCommonChanVerifyDr( verifyParams->NbChannels, verifyParams->ChannelsMask, datarate,
 8036d34:	69a3      	ldr	r3, [r4, #24]
 8036d36:	9301      	str	r3, [sp, #4]
 8036d38:	f994 3015 	ldrsb.w	r3, [r4, #21]
 8036d3c:	9300      	str	r3, [sp, #0]
 8036d3e:	6921      	ldr	r1, [r4, #16]
 8036d40:	f994 3014 	ldrsb.w	r3, [r4, #20]
 8036d44:	7b20      	ldrb	r0, [r4, #12]
 8036d46:	f7ff fe36 	bl	80369b6 <RegionCommonChanVerifyDr>
 8036d4a:	b908      	cbnz	r0, 8036d50 <RegionCommonLinkAdrReqVerifyParams+0x3c>
                                      verifyParams->MinDatarate, verifyParams->MaxDatarate, verifyParams->Channels  ) == false )
        {
            status &= 0xFD; // Datarate KO
 8036d4c:	f005 05fd 	and.w	r5, r5, #253	; 0xfd
        }

        // Verify tx power
        if( RegionCommonValueInRange( txPower, verifyParams->MaxTxPower, verifyParams->MinTxPower ) == 0 )
 8036d50:	f994 301d 	ldrsb.w	r3, [r4, #29]
 8036d54:	f994 101c 	ldrsb.w	r1, [r4, #28]
    if( ( value >= min ) && ( value <= max ) )
 8036d58:	42bb      	cmp	r3, r7
 8036d5a:	dc14      	bgt.n	8036d86 <RegionCommonLinkAdrReqVerifyParams+0x72>
 8036d5c:	42b9      	cmp	r1, r7
 8036d5e:	da13      	bge.n	8036d88 <RegionCommonLinkAdrReqVerifyParams+0x74>
            { // Apply maximum TX power. Accept TX power.
                txPower = verifyParams->MaxTxPower;
            }
            else
            {
                status &= 0xFB; // TxPower KO
 8036d60:	f005 05fb 	and.w	r5, r5, #251	; 0xfb
    *dr = datarate;
    *txPow = txPower;
    *nbRep = nbRepetitions;

    return status;
}
 8036d64:	4628      	mov	r0, r5
    *dr = datarate;
 8036d66:	f88a 2000 	strb.w	r2, [sl]
    *txPow = txPower;
 8036d6a:	f889 7000 	strb.w	r7, [r9]
    *nbRep = nbRepetitions;
 8036d6e:	f888 6000 	strb.w	r6, [r8]
}
 8036d72:	b002      	add	sp, #8
 8036d74:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        nbRepetitions = verifyParams->CurrentNbRep;
 8036d78:	f990 600b 	ldrsb.w	r6, [r0, #11]
        datarate =  verifyParams->CurrentDatarate;
 8036d7c:	f990 2009 	ldrsb.w	r2, [r0, #9]
        txPower =  verifyParams->CurrentTxPower;
 8036d80:	f990 700a 	ldrsb.w	r7, [r0, #10]
 8036d84:	e7d5      	b.n	8036d32 <RegionCommonLinkAdrReqVerifyParams+0x1e>
 8036d86:	461f      	mov	r7, r3
    if( status == 0x07 )
 8036d88:	2d07      	cmp	r5, #7
 8036d8a:	d1eb      	bne.n	8036d64 <RegionCommonLinkAdrReqVerifyParams+0x50>
            nbRepetitions = 1;
 8036d8c:	2e00      	cmp	r6, #0
 8036d8e:	bf08      	it	eq
 8036d90:	2601      	moveq	r6, #1
 8036d92:	e7e7      	b.n	8036d64 <RegionCommonLinkAdrReqVerifyParams+0x50>

08036d94 <RegionCommonComputeSymbolTimeLoRa>:

uint32_t RegionCommonComputeSymbolTimeLoRa( uint8_t phyDr, uint32_t bandwidthInHz )
{
    return ( 1 << phyDr ) * 1000000 / bandwidthInHz;
 8036d94:	4b02      	ldr	r3, [pc, #8]	; (8036da0 <RegionCommonComputeSymbolTimeLoRa+0xc>)
 8036d96:	fa03 f000 	lsl.w	r0, r3, r0
}
 8036d9a:	fbb0 f0f1 	udiv	r0, r0, r1
 8036d9e:	4770      	bx	lr
 8036da0:	000f4240 	.word	0x000f4240

08036da4 <RegionCommonComputeSymbolTimeFsk>:

uint32_t RegionCommonComputeSymbolTimeFsk( uint8_t phyDrInKbps )
{
    return 8000 / ( uint32_t )phyDrInKbps; // 1 symbol equals 1 byte
}
 8036da4:	f44f 53fa 	mov.w	r3, #8000	; 0x1f40
 8036da8:	fbb3 f0f0 	udiv	r0, r3, r0
 8036dac:	4770      	bx	lr

08036dae <RegionCommonComputeRxWindowParameters>:

void RegionCommonComputeRxWindowParameters( uint32_t tSymbolInUs, uint8_t minRxSymbols, uint32_t rxErrorInMs, uint32_t wakeUpTimeInMs, uint32_t* windowTimeoutInSymbols, int32_t* windowOffsetInMs )
{
 8036dae:	b530      	push	{r4, r5, lr}
    *windowTimeoutInSymbols = MAX( DIV_CEIL( ( ( 2 * minRxSymbols - 8 ) * tSymbolInUs + 2 * ( rxErrorInMs * 1000 ) ),  tSymbolInUs ), minRxSymbols ); // Computed number of symbols
 8036db0:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 8036db4:	1f0c      	subs	r4, r1, #4
 8036db6:	436a      	muls	r2, r5
 8036db8:	fb00 2204 	mla	r2, r0, r4, r2
 8036dbc:	0052      	lsls	r2, r2, #1
 8036dbe:	bf1e      	ittt	ne
 8036dc0:	f100 34ff 	addne.w	r4, r0, #4294967295
 8036dc4:	1912      	addne	r2, r2, r4
 8036dc6:	fbb2 f2f0 	udivne	r2, r2, r0
 8036dca:	428a      	cmp	r2, r1
 8036dcc:	bf38      	it	cc
 8036dce:	460a      	movcc	r2, r1
 8036dd0:	9903      	ldr	r1, [sp, #12]
 8036dd2:	600a      	str	r2, [r1, #0]
    *windowOffsetInMs = ( int32_t )DIV_CEIL( ( int32_t )( 4 * tSymbolInUs ) -
 8036dd4:	0081      	lsls	r1, r0, #2
 8036dd6:	4350      	muls	r0, r2
 8036dd8:	bf1c      	itt	ne
 8036dda:	3001      	addne	r0, #1
 8036ddc:	0840      	lsrne	r0, r0, #1
 8036dde:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8036de2:	1a08      	subs	r0, r1, r0
 8036de4:	fb02 0313 	mls	r3, r2, r3, r0
 8036de8:	2b00      	cmp	r3, #0
 8036dea:	bfca      	itet	gt
 8036dec:	f203 33e7 	addwgt	r3, r3, #999	; 0x3e7
 8036df0:	fb93 f3f2 	sdivle	r3, r3, r2
 8036df4:	fbb3 f3f2 	udivgt	r3, r3, r2
 8036df8:	9a04      	ldr	r2, [sp, #16]
 8036dfa:	6013      	str	r3, [r2, #0]
                                               ( int32_t )DIV_CEIL( ( *windowTimeoutInSymbols * tSymbolInUs ), 2 ) -
                                               ( int32_t )( wakeUpTimeInMs * 1000 ), 1000 );
}
 8036dfc:	bd30      	pop	{r4, r5, pc}

08036dfe <RegionCommonComputeTxPower>:

int8_t RegionCommonComputeTxPower( int8_t txPowerIndex, float maxEirp, float antennaGain )
{
 8036dfe:	b538      	push	{r3, r4, r5, lr}
    int8_t phyTxPower = 0;

    phyTxPower = ( int8_t )floor( ( maxEirp - ( txPowerIndex * 2U ) ) - antennaGain );
 8036e00:	0040      	lsls	r0, r0, #1
{
 8036e02:	4614      	mov	r4, r2
 8036e04:	460d      	mov	r5, r1
    phyTxPower = ( int8_t )floor( ( maxEirp - ( txPowerIndex * 2U ) ) - antennaGain );
 8036e06:	f7f4 fe45 	bl	802ba94 <__aeabi_ui2f>
 8036e0a:	4601      	mov	r1, r0
 8036e0c:	4628      	mov	r0, r5
 8036e0e:	f7f4 fd8f 	bl	802b930 <__aeabi_fsub>
 8036e12:	4621      	mov	r1, r4
 8036e14:	f7f4 fd8c 	bl	802b930 <__aeabi_fsub>
 8036e18:	f7f4 fc7e 	bl	802b718 <__aeabi_f2d>
 8036e1c:	f004 fcbc 	bl	803b798 <floor>
 8036e20:	f7f4 fd5a 	bl	802b8d8 <__aeabi_d2iz>

    return phyTxPower;
}
 8036e24:	b240      	sxtb	r0, r0
 8036e26:	bd38      	pop	{r3, r4, r5, pc}

08036e28 <RegionCommonCountNbOfEnabledChannels>:
    /* ST_WORKAROUND_END */
}

void RegionCommonCountNbOfEnabledChannels( RegionCommonCountNbOfEnabledChannelsParams_t* countNbOfEnabledChannelsParams,
                                           uint8_t* enabledChannels, uint8_t* nbEnabledChannels, uint8_t* nbRestrictedChannels )
{
 8036e28:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8036e2c:	e9cd 2300 	strd	r2, r3, [sp]
    uint8_t nbChannelCount = 0;
    uint8_t nbRestrictedChannelsCount = 0;

    for( uint8_t i = 0, k = 0; i < countNbOfEnabledChannelsParams->MaxNbChannels; i += 16, k++ )
 8036e30:	2300      	movs	r3, #0
    uint8_t nbRestrictedChannelsCount = 0;
 8036e32:	461d      	mov	r5, r3
    uint8_t nbChannelCount = 0;
 8036e34:	461e      	mov	r6, r3
    {
        for( uint8_t j = 0; j < 16; j++ )
        {
            if( ( countNbOfEnabledChannelsParams->ChannelsMask[k] & ( 1 << j ) ) != 0 )
            {
                if( countNbOfEnabledChannelsParams->Channels[i + j].Frequency == 0 )
 8036e36:	f04f 090c 	mov.w	r9, #12
 8036e3a:	011a      	lsls	r2, r3, #4
    for( uint8_t i = 0, k = 0; i < countNbOfEnabledChannelsParams->MaxNbChannels; i += 16, k++ )
 8036e3c:	8a04      	ldrh	r4, [r0, #16]
 8036e3e:	fa5f f882 	uxtb.w	r8, r2
 8036e42:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 8036e46:	4294      	cmp	r4, r2
 8036e48:	d806      	bhi.n	8036e58 <RegionCommonCountNbOfEnabledChannels+0x30>
                }
                enabledChannels[nbChannelCount++] = i + j;
            }
        }
    }
    *nbEnabledChannels = nbChannelCount;
 8036e4a:	9b00      	ldr	r3, [sp, #0]
 8036e4c:	701e      	strb	r6, [r3, #0]
    *nbRestrictedChannels = nbRestrictedChannelsCount;
 8036e4e:	9b01      	ldr	r3, [sp, #4]
 8036e50:	701d      	strb	r5, [r3, #0]
}
 8036e52:	b003      	add	sp, #12
 8036e54:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            if( ( countNbOfEnabledChannelsParams->ChannelsMask[k] & ( 1 << j ) ) != 0 )
 8036e58:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8036e5c:	2200      	movs	r2, #0
 8036e5e:	6844      	ldr	r4, [r0, #4]
 8036e60:	f834 400c 	ldrh.w	r4, [r4, ip]
 8036e64:	4114      	asrs	r4, r2
 8036e66:	07e7      	lsls	r7, r4, #31
 8036e68:	d52a      	bpl.n	8036ec0 <RegionCommonCountNbOfEnabledChannels+0x98>
                if( countNbOfEnabledChannelsParams->Channels[i + j].Frequency == 0 )
 8036e6a:	eb02 0e08 	add.w	lr, r2, r8
 8036e6e:	6887      	ldr	r7, [r0, #8]
 8036e70:	fb09 f40e 	mul.w	r4, r9, lr
 8036e74:	eb07 0a04 	add.w	sl, r7, r4
 8036e78:	593c      	ldr	r4, [r7, r4]
 8036e7a:	b30c      	cbz	r4, 8036ec0 <RegionCommonCountNbOfEnabledChannels+0x98>
                if( ( countNbOfEnabledChannelsParams->Joined == false ) &&
 8036e7c:	7804      	ldrb	r4, [r0, #0]
 8036e7e:	b934      	cbnz	r4, 8036e8e <RegionCommonCountNbOfEnabledChannels+0x66>
                    ( countNbOfEnabledChannelsParams->JoinChannels != NULL ) )
 8036e80:	6944      	ldr	r4, [r0, #20]
                if( ( countNbOfEnabledChannelsParams->Joined == false ) &&
 8036e82:	b124      	cbz	r4, 8036e8e <RegionCommonCountNbOfEnabledChannels+0x66>
                    if( ( countNbOfEnabledChannelsParams->JoinChannels[k] & ( 1 << j ) ) == 0 )
 8036e84:	f834 400c 	ldrh.w	r4, [r4, ip]
 8036e88:	4114      	asrs	r4, r2
 8036e8a:	07e4      	lsls	r4, r4, #31
 8036e8c:	d518      	bpl.n	8036ec0 <RegionCommonCountNbOfEnabledChannels+0x98>
                                              countNbOfEnabledChannelsParams->Channels[i + j].DrRange.Fields.Min,
 8036e8e:	f89a 4008 	ldrb.w	r4, [sl, #8]
                if( RegionCommonValueInRange( countNbOfEnabledChannelsParams->Datarate,
 8036e92:	f990 b001 	ldrsb.w	fp, [r0, #1]
                                              countNbOfEnabledChannelsParams->Channels[i + j].DrRange.Fields.Min,
 8036e96:	f344 0703 	sbfx	r7, r4, #0, #4
    if( ( value >= min ) && ( value <= max ) )
 8036e9a:	b27f      	sxtb	r7, r7
 8036e9c:	455f      	cmp	r7, fp
 8036e9e:	dc0f      	bgt.n	8036ec0 <RegionCommonCountNbOfEnabledChannels+0x98>
                                              countNbOfEnabledChannelsParams->Channels[i + j].DrRange.Fields.Max ) == false )
 8036ea0:	f344 1403 	sbfx	r4, r4, #4, #4
    if( ( value >= min ) && ( value <= max ) )
 8036ea4:	b264      	sxtb	r4, r4
 8036ea6:	455c      	cmp	r4, fp
 8036ea8:	db0a      	blt.n	8036ec0 <RegionCommonCountNbOfEnabledChannels+0x98>
                if( countNbOfEnabledChannelsParams->Bands[countNbOfEnabledChannelsParams->Channels[i + j].Band].ReadyForTransmission == false )
 8036eaa:	f89a 4009 	ldrb.w	r4, [sl, #9]
 8036eae:	eb04 0744 	add.w	r7, r4, r4, lsl #1
 8036eb2:	68c4      	ldr	r4, [r0, #12]
 8036eb4:	eb04 04c7 	add.w	r4, r4, r7, lsl #3
 8036eb8:	7d24      	ldrb	r4, [r4, #20]
 8036eba:	b93c      	cbnz	r4, 8036ecc <RegionCommonCountNbOfEnabledChannels+0xa4>
                    nbRestrictedChannelsCount++;
 8036ebc:	3501      	adds	r5, #1
 8036ebe:	b2ed      	uxtb	r5, r5
        for( uint8_t j = 0; j < 16; j++ )
 8036ec0:	3201      	adds	r2, #1
 8036ec2:	2a10      	cmp	r2, #16
 8036ec4:	d1cb      	bne.n	8036e5e <RegionCommonCountNbOfEnabledChannels+0x36>
    for( uint8_t i = 0, k = 0; i < countNbOfEnabledChannelsParams->MaxNbChannels; i += 16, k++ )
 8036ec6:	3301      	adds	r3, #1
 8036ec8:	b2db      	uxtb	r3, r3
 8036eca:	e7b6      	b.n	8036e3a <RegionCommonCountNbOfEnabledChannels+0x12>
                enabledChannels[nbChannelCount++] = i + j;
 8036ecc:	1c74      	adds	r4, r6, #1
 8036ece:	f801 e006 	strb.w	lr, [r1, r6]
 8036ed2:	b2e6      	uxtb	r6, r4
 8036ed4:	e7f4      	b.n	8036ec0 <RegionCommonCountNbOfEnabledChannels+0x98>

08036ed6 <RegionCommonIdentifyChannels>:

LoRaMacStatus_t RegionCommonIdentifyChannels( RegionCommonIdentifyChannelsParam_t* identifyChannelsParam,
                                              TimerTime_t* aggregatedTimeOff, uint8_t* enabledChannels,
                                              uint8_t* nbEnabledChannels, uint8_t* nbRestrictedChannels,
                                              TimerTime_t* nextTxDelay )
{
 8036ed6:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 8036eda:	4604      	mov	r4, r0
    TimerTime_t elapsed = TimerGetElapsedTime( identifyChannelsParam->LastAggrTx );
 8036edc:	6840      	ldr	r0, [r0, #4]
{
 8036ede:	e9dd 780c 	ldrd	r7, r8, [sp, #48]	; 0x30
 8036ee2:	461e      	mov	r6, r3
 8036ee4:	468a      	mov	sl, r1
 8036ee6:	4691      	mov	r9, r2
    TimerTime_t elapsed = TimerGetElapsedTime( identifyChannelsParam->LastAggrTx );
 8036ee8:	f004 f9f0 	bl	803b2cc <UTIL_TIMER_GetElapsedTime>
    *nextTxDelay = identifyChannelsParam->AggrTimeOff - elapsed;
 8036eec:	6823      	ldr	r3, [r4, #0]
 8036eee:	1a1b      	subs	r3, r3, r0
 8036ef0:	f8c8 3000 	str.w	r3, [r8]
    *nbRestrictedChannels = 1;
    *nbEnabledChannels = 0;
 8036ef4:	2500      	movs	r5, #0
    *nbRestrictedChannels = 1;
 8036ef6:	2301      	movs	r3, #1
 8036ef8:	703b      	strb	r3, [r7, #0]
    *nbEnabledChannels = 0;
 8036efa:	7035      	strb	r5, [r6, #0]

    if( ( identifyChannelsParam->LastAggrTx == 0 ) ||
 8036efc:	6863      	ldr	r3, [r4, #4]
 8036efe:	b113      	cbz	r3, 8036f06 <RegionCommonIdentifyChannels+0x30>
 8036f00:	6823      	ldr	r3, [r4, #0]
 8036f02:	4283      	cmp	r3, r0
 8036f04:	d825      	bhi.n	8036f52 <RegionCommonIdentifyChannels+0x7c>
        ( identifyChannelsParam->AggrTimeOff <= elapsed ) )
    {
        // Reset Aggregated time off
        *aggregatedTimeOff = 0;
 8036f06:	f8ca 5000 	str.w	r5, [sl]

        // Update bands Time OFF
        *nextTxDelay = RegionCommonUpdateBandTimeOff( identifyChannelsParam->CountNbOfEnabledChannelsParam->Joined,
 8036f0a:	f8d4 c01c 	ldr.w	ip, [r4, #28]
 8036f0e:	69a3      	ldr	r3, [r4, #24]
 8036f10:	f89c e000 	ldrb.w	lr, [ip]
 8036f14:	9303      	str	r3, [sp, #12]
 8036f16:	e9d4 0103 	ldrd	r0, r1, [r4, #12]
 8036f1a:	ab01      	add	r3, sp, #4
 8036f1c:	e883 0003 	stmia.w	r3, {r0, r1}
 8036f20:	7d23      	ldrb	r3, [r4, #20]
 8036f22:	9300      	str	r3, [sp, #0]
 8036f24:	f8dc 100c 	ldr.w	r1, [ip, #12]
 8036f28:	7a23      	ldrb	r3, [r4, #8]
 8036f2a:	7a62      	ldrb	r2, [r4, #9]
 8036f2c:	4670      	mov	r0, lr
 8036f2e:	f7ff fde9 	bl	8036b04 <RegionCommonUpdateBandTimeOff>
                                                      identifyChannelsParam->DutyCycleEnabled,
                                                      identifyChannelsParam->LastTxIsJoinRequest,
                                                      identifyChannelsParam->ElapsedTimeSinceStartUp,
                                                      identifyChannelsParam->ExpectedTimeOnAir );

        RegionCommonCountNbOfEnabledChannels( identifyChannelsParam->CountNbOfEnabledChannelsParam, enabledChannels,
 8036f32:	463b      	mov	r3, r7
        *nextTxDelay = RegionCommonUpdateBandTimeOff( identifyChannelsParam->CountNbOfEnabledChannelsParam->Joined,
 8036f34:	f8c8 0000 	str.w	r0, [r8]
        RegionCommonCountNbOfEnabledChannels( identifyChannelsParam->CountNbOfEnabledChannelsParam, enabledChannels,
 8036f38:	4632      	mov	r2, r6
 8036f3a:	69e0      	ldr	r0, [r4, #28]
 8036f3c:	4649      	mov	r1, r9
 8036f3e:	f7ff ff73 	bl	8036e28 <RegionCommonCountNbOfEnabledChannels>
                                              nbEnabledChannels, nbRestrictedChannels );
    }

    if( *nbEnabledChannels > 0 )
 8036f42:	7833      	ldrb	r3, [r6, #0]
 8036f44:	b12b      	cbz	r3, 8036f52 <RegionCommonIdentifyChannels+0x7c>
    {
        *nextTxDelay = 0;
 8036f46:	f8c8 5000 	str.w	r5, [r8]
        return LORAMAC_STATUS_OK;
 8036f4a:	2000      	movs	r0, #0
    }
    else
    {
        return LORAMAC_STATUS_NO_CHANNEL_FOUND;
    }
}
 8036f4c:	b004      	add	sp, #16
 8036f4e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    else if( *nbRestrictedChannels > 0 )
 8036f52:	783b      	ldrb	r3, [r7, #0]
        return LORAMAC_STATUS_NO_CHANNEL_FOUND;
 8036f54:	2b00      	cmp	r3, #0
 8036f56:	bf14      	ite	ne
 8036f58:	200b      	movne	r0, #11
 8036f5a:	200c      	moveq	r0, #12
 8036f5c:	e7f6      	b.n	8036f4c <RegionCommonIdentifyChannels+0x76>

08036f5e <RegionCommonGetNextLowerTxDr>:

int8_t RegionCommonGetNextLowerTxDr( RegionCommonGetNextLowerTxDrParams_t *params )
{
 8036f5e:	b537      	push	{r0, r1, r2, r4, r5, lr}
    int8_t drLocal = params->CurrentDr;
 8036f60:	f990 2000 	ldrsb.w	r2, [r0]

    if( params->CurrentDr == params->MinDr )
 8036f64:	f990 5002 	ldrsb.w	r5, [r0, #2]
 8036f68:	4295      	cmp	r5, r2
{
 8036f6a:	4604      	mov	r4, r0
    if( params->CurrentDr == params->MinDr )
 8036f6c:	d00f      	beq.n	8036f8e <RegionCommonGetNextLowerTxDr+0x30>
    }
    else
    {
        do
        {
            drLocal = ( drLocal - 1 );
 8036f6e:	3a01      	subs	r2, #1
 8036f70:	b252      	sxtb	r2, r2
        } while( ( drLocal != params->MinDr ) &&
                 ( RegionCommonChanVerifyDr( params->NbChannels, params->ChannelsMask, drLocal, params->MinDr, params->MaxDr, params->Channels  ) == false ) );
 8036f72:	42aa      	cmp	r2, r5
 8036f74:	d00b      	beq.n	8036f8e <RegionCommonGetNextLowerTxDr+0x30>
 8036f76:	68a3      	ldr	r3, [r4, #8]
 8036f78:	9301      	str	r3, [sp, #4]
 8036f7a:	f994 3001 	ldrsb.w	r3, [r4, #1]
 8036f7e:	9300      	str	r3, [sp, #0]
 8036f80:	6861      	ldr	r1, [r4, #4]
 8036f82:	78e0      	ldrb	r0, [r4, #3]
 8036f84:	462b      	mov	r3, r5
 8036f86:	f7ff fd16 	bl	80369b6 <RegionCommonChanVerifyDr>
        } while( ( drLocal != params->MinDr ) &&
 8036f8a:	2800      	cmp	r0, #0
 8036f8c:	d0ef      	beq.n	8036f6e <RegionCommonGetNextLowerTxDr+0x10>

        return drLocal;
    }
}
 8036f8e:	4610      	mov	r0, r2
 8036f90:	b003      	add	sp, #12
 8036f92:	bd30      	pop	{r4, r5, pc}

08036f94 <RegionCommonLimitTxPower>:

int8_t RegionCommonLimitTxPower( int8_t txPower, int8_t maxBandTxPower )
{
    // Limit tx power to the band max
    return MAX( txPower, maxBandTxPower );
}
 8036f94:	4288      	cmp	r0, r1
 8036f96:	bfb8      	it	lt
 8036f98:	4608      	movlt	r0, r1
 8036f9a:	4770      	bx	lr

08036f9c <RegionCommonGetBandwidth>:

uint32_t RegionCommonGetBandwidth( uint32_t drIndex, const uint32_t* bandwidths )
{
    switch( bandwidths[drIndex] )
 8036f9c:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
 8036fa0:	4b05      	ldr	r3, [pc, #20]	; (8036fb8 <RegionCommonGetBandwidth+0x1c>)
 8036fa2:	4298      	cmp	r0, r3
 8036fa4:	d005      	beq.n	8036fb2 <RegionCommonGetBandwidth+0x16>
        case 125000:
            return 0;
        case 250000:
            return 1;
        case 500000:
            return 2;
 8036fa6:	4b05      	ldr	r3, [pc, #20]	; (8036fbc <RegionCommonGetBandwidth+0x20>)
 8036fa8:	4298      	cmp	r0, r3
 8036faa:	bf0c      	ite	eq
 8036fac:	2002      	moveq	r0, #2
 8036fae:	2000      	movne	r0, #0
 8036fb0:	4770      	bx	lr
    switch( bandwidths[drIndex] )
 8036fb2:	2001      	movs	r0, #1
    }
}
 8036fb4:	4770      	bx	lr
 8036fb6:	bf00      	nop
 8036fb8:	0003d090 	.word	0x0003d090
 8036fbc:	0007a120 	.word	0x0007a120

08036fc0 <RegionCommonRxConfigPrint>:

/* ST_WORKAROUND_BEGIN: Print Tx/Rx config */
void RegionCommonRxConfigPrint(LoRaMacRxSlot_t rxSlot, uint32_t frequency, int8_t dr)
{
 8036fc0:	b5f0      	push	{r4, r5, r6, r7, lr}
    const char *slotStrings[] = { "1", "2", "C", "Multi_C", "P", "Multi_P" };
 8036fc2:	4d13      	ldr	r5, [pc, #76]	; (8037010 <RegionCommonRxConfigPrint+0x50>)
{
 8036fc4:	4606      	mov	r6, r0
 8036fc6:	460f      	mov	r7, r1
 8036fc8:	4694      	mov	ip, r2
    const char *slotStrings[] = { "1", "2", "C", "Multi_C", "P", "Multi_P" };
 8036fca:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
{
 8036fcc:	b08b      	sub	sp, #44	; 0x2c
    const char *slotStrings[] = { "1", "2", "C", "Multi_C", "P", "Multi_P" };
 8036fce:	ac04      	add	r4, sp, #16
 8036fd0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8036fd2:	e895 0003 	ldmia.w	r5, {r0, r1}

    if ( rxSlot < RX_SLOT_NONE )
 8036fd6:	2e05      	cmp	r6, #5
    const char *slotStrings[] = { "1", "2", "C", "Multi_C", "P", "Multi_P" };
 8036fd8:	e884 0003 	stmia.w	r4, {r0, r1}
    if ( rxSlot < RX_SLOT_NONE )
 8036fdc:	d80f      	bhi.n	8036ffe <RegionCommonRxConfigPrint+0x3e>
    {
        MW_LOG(TS_ON, VLEVEL_M,  "RX_%s on freq %d Hz at DR %d\r\n", slotStrings[rxSlot], frequency, dr );
 8036fde:	ab0a      	add	r3, sp, #40	; 0x28
 8036fe0:	e9cd 7c01 	strd	r7, ip, [sp, #4]
 8036fe4:	eb03 0686 	add.w	r6, r3, r6, lsl #2
 8036fe8:	2201      	movs	r2, #1
 8036fea:	f856 3c18 	ldr.w	r3, [r6, #-24]
 8036fee:	9300      	str	r3, [sp, #0]
 8036ff0:	2100      	movs	r1, #0
 8036ff2:	4b08      	ldr	r3, [pc, #32]	; (8037014 <RegionCommonRxConfigPrint+0x54>)
 8036ff4:	2002      	movs	r0, #2
 8036ff6:	f003 fe81 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
    }
    else
    {
        MW_LOG(TS_ON, VLEVEL_M,  "RX on freq %d Hz at DR %d\r\n", frequency, dr );
    }
}
 8036ffa:	b00b      	add	sp, #44	; 0x2c
 8036ffc:	bdf0      	pop	{r4, r5, r6, r7, pc}
        MW_LOG(TS_ON, VLEVEL_M,  "RX on freq %d Hz at DR %d\r\n", frequency, dr );
 8036ffe:	e9cd 7c00 	strd	r7, ip, [sp]
 8037002:	4b05      	ldr	r3, [pc, #20]	; (8037018 <RegionCommonRxConfigPrint+0x58>)
 8037004:	2201      	movs	r2, #1
 8037006:	2100      	movs	r1, #0
 8037008:	2002      	movs	r0, #2
 803700a:	f003 fe77 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
}
 803700e:	e7f4      	b.n	8036ffa <RegionCommonRxConfigPrint+0x3a>
 8037010:	0803badc 	.word	0x0803badc
 8037014:	0803c3d0 	.word	0x0803c3d0
 8037018:	0803c3ef 	.word	0x0803c3ef

0803701c <RegionCommonTxConfigPrint>:

void RegionCommonTxConfigPrint(uint32_t frequency, int8_t dr)
{
 803701c:	b507      	push	{r0, r1, r2, lr}
    MW_LOG(TS_ON, VLEVEL_M,  "TX on freq %d Hz at DR %d\r\n", frequency, dr );
 803701e:	4b05      	ldr	r3, [pc, #20]	; (8037034 <RegionCommonTxConfigPrint+0x18>)
 8037020:	e9cd 0100 	strd	r0, r1, [sp]
 8037024:	2201      	movs	r2, #1
 8037026:	2100      	movs	r1, #0
 8037028:	2002      	movs	r0, #2
 803702a:	f003 fe67 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
}
 803702e:	b003      	add	sp, #12
 8037030:	f85d fb04 	ldr.w	pc, [sp], #4
 8037034:	0803c40b 	.word	0x0803c40b

08037038 <GetTimeOnAir>:
    }
    return true;
}

static TimerTime_t GetTimeOnAir( int8_t datarate, uint16_t pktLen )
{
 8037038:	b5f0      	push	{r4, r5, r6, r7, lr}
 803703a:	460c      	mov	r4, r1
    int8_t phyDr = DataratesEU868[datarate];
 803703c:	4910      	ldr	r1, [pc, #64]	; (8037080 <GetTimeOnAir+0x48>)
{
 803703e:	b085      	sub	sp, #20
    int8_t phyDr = DataratesEU868[datarate];
 8037040:	560f      	ldrsb	r7, [r1, r0]
    uint32_t bandwidth = RegionCommonGetBandwidth( datarate, BandwidthsEU868 );
 8037042:	3108      	adds	r1, #8
{
 8037044:	4605      	mov	r5, r0
    uint32_t bandwidth = RegionCommonGetBandwidth( datarate, BandwidthsEU868 );
 8037046:	f7ff ffa9 	bl	8036f9c <RegionCommonGetBandwidth>
 803704a:	4b0e      	ldr	r3, [pc, #56]	; (8037084 <GetTimeOnAir+0x4c>)
 803704c:	b2e4      	uxtb	r4, r4
 803704e:	6a5e      	ldr	r6, [r3, #36]	; 0x24
    TimerTime_t timeOnAir = 0;

    if( datarate == DR_7 )
 8037050:	2d07      	cmp	r5, #7
 8037052:	f04f 0301 	mov.w	r3, #1
    { // High Speed FSK channel
        timeOnAir = Radio.TimeOnAir( MODEM_FSK, bandwidth, phyDr * 1000, 0, 5, false, pktLen, true );
 8037056:	e9cd 4302 	strd	r4, r3, [sp, #8]
    uint32_t bandwidth = RegionCommonGetBandwidth( datarate, BandwidthsEU868 );
 803705a:	4601      	mov	r1, r0
    if( datarate == DR_7 )
 803705c:	d10a      	bne.n	8037074 <GetTimeOnAir+0x3c>
        timeOnAir = Radio.TimeOnAir( MODEM_FSK, bandwidth, phyDr * 1000, 0, 5, false, pktLen, true );
 803705e:	2205      	movs	r2, #5
 8037060:	2300      	movs	r3, #0
 8037062:	e9cd 2300 	strd	r2, r3, [sp]
 8037066:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 803706a:	437a      	muls	r2, r7
    }
    else
    {
        timeOnAir = Radio.TimeOnAir( MODEM_LORA, bandwidth, phyDr, 1, 8, false, pktLen, true );
 803706c:	4618      	mov	r0, r3
 803706e:	47b0      	blx	r6
    }
    return timeOnAir;
}
 8037070:	b005      	add	sp, #20
 8037072:	bdf0      	pop	{r4, r5, r6, r7, pc}
        timeOnAir = Radio.TimeOnAir( MODEM_LORA, bandwidth, phyDr, 1, 8, false, pktLen, true );
 8037074:	2208      	movs	r2, #8
 8037076:	2000      	movs	r0, #0
 8037078:	e9cd 2000 	strd	r2, r0, [sp]
 803707c:	463a      	mov	r2, r7
 803707e:	e7f5      	b.n	803706c <GetTimeOnAir+0x34>
 8037080:	0803baf4 	.word	0x0803baf4
 8037084:	0803bc30 	.word	0x0803bc30

08037088 <VerifyRfFreq>:
{
 8037088:	b538      	push	{r3, r4, r5, lr}
    if( Radio.CheckRfFrequency( freq ) == false )
 803708a:	4b19      	ldr	r3, [pc, #100]	; (80370f0 <VerifyRfFreq+0x68>)
 803708c:	6a1b      	ldr	r3, [r3, #32]
{
 803708e:	4605      	mov	r5, r0
 8037090:	460c      	mov	r4, r1
    if( Radio.CheckRfFrequency( freq ) == false )
 8037092:	4798      	blx	r3
 8037094:	b130      	cbz	r0, 80370a4 <VerifyRfFreq+0x1c>
    if( ( freq >= 863000000 ) && ( freq < 865000000 ) )
 8037096:	4b17      	ldr	r3, [pc, #92]	; (80370f4 <VerifyRfFreq+0x6c>)
 8037098:	4a17      	ldr	r2, [pc, #92]	; (80370f8 <VerifyRfFreq+0x70>)
 803709a:	442b      	add	r3, r5
 803709c:	4293      	cmp	r3, r2
 803709e:	d802      	bhi.n	80370a6 <VerifyRfFreq+0x1e>
        *band = 2;
 80370a0:	2302      	movs	r3, #2
        *band = 3;
 80370a2:	7023      	strb	r3, [r4, #0]
}
 80370a4:	bd38      	pop	{r3, r4, r5, pc}
    else if( ( freq >= 865000000 ) && ( freq <= 868000000 ) )
 80370a6:	4b15      	ldr	r3, [pc, #84]	; (80370fc <VerifyRfFreq+0x74>)
 80370a8:	4a15      	ldr	r2, [pc, #84]	; (8037100 <VerifyRfFreq+0x78>)
 80370aa:	442b      	add	r3, r5
 80370ac:	4293      	cmp	r3, r2
 80370ae:	d801      	bhi.n	80370b4 <VerifyRfFreq+0x2c>
        *band = 0;
 80370b0:	2300      	movs	r3, #0
 80370b2:	e7f6      	b.n	80370a2 <VerifyRfFreq+0x1a>
    else if( ( freq > 868000000 ) && ( freq <= 868600000 ) )
 80370b4:	4b13      	ldr	r3, [pc, #76]	; (8037104 <VerifyRfFreq+0x7c>)
 80370b6:	4a14      	ldr	r2, [pc, #80]	; (8037108 <VerifyRfFreq+0x80>)
 80370b8:	442b      	add	r3, r5
 80370ba:	4293      	cmp	r3, r2
 80370bc:	d801      	bhi.n	80370c2 <VerifyRfFreq+0x3a>
        *band = 1;
 80370be:	2301      	movs	r3, #1
 80370c0:	e7ef      	b.n	80370a2 <VerifyRfFreq+0x1a>
    else if( ( freq >= 868700000 ) && ( freq <= 869200000 ) )
 80370c2:	4b12      	ldr	r3, [pc, #72]	; (803710c <VerifyRfFreq+0x84>)
 80370c4:	4a12      	ldr	r2, [pc, #72]	; (8037110 <VerifyRfFreq+0x88>)
 80370c6:	442b      	add	r3, r5
 80370c8:	4293      	cmp	r3, r2
 80370ca:	d801      	bhi.n	80370d0 <VerifyRfFreq+0x48>
        *band = 5;
 80370cc:	2305      	movs	r3, #5
 80370ce:	e7e8      	b.n	80370a2 <VerifyRfFreq+0x1a>
    else if( ( freq >= 869400000 ) && ( freq <= 869650000 ) )
 80370d0:	4b10      	ldr	r3, [pc, #64]	; (8037114 <VerifyRfFreq+0x8c>)
 80370d2:	4a11      	ldr	r2, [pc, #68]	; (8037118 <VerifyRfFreq+0x90>)
 80370d4:	442b      	add	r3, r5
 80370d6:	4293      	cmp	r3, r2
 80370d8:	d801      	bhi.n	80370de <VerifyRfFreq+0x56>
        *band = 3;
 80370da:	2303      	movs	r3, #3
 80370dc:	e7e1      	b.n	80370a2 <VerifyRfFreq+0x1a>
    else if( ( freq >= 869700000 ) && ( freq <= 870000000 ) )
 80370de:	4b0f      	ldr	r3, [pc, #60]	; (803711c <VerifyRfFreq+0x94>)
 80370e0:	4a0f      	ldr	r2, [pc, #60]	; (8037120 <VerifyRfFreq+0x98>)
 80370e2:	442b      	add	r3, r5
 80370e4:	4293      	cmp	r3, r2
 80370e6:	d801      	bhi.n	80370ec <VerifyRfFreq+0x64>
        *band = 4;
 80370e8:	2304      	movs	r3, #4
 80370ea:	e7da      	b.n	80370a2 <VerifyRfFreq+0x1a>
        return false;
 80370ec:	2000      	movs	r0, #0
 80370ee:	e7d9      	b.n	80370a4 <VerifyRfFreq+0x1c>
 80370f0:	0803bc30 	.word	0x0803bc30
 80370f4:	cc8faa40 	.word	0xcc8faa40
 80370f8:	001e847f 	.word	0x001e847f
 80370fc:	cc7125c0 	.word	0xcc7125c0
 8037100:	002dc6c0 	.word	0x002dc6c0
 8037104:	cc435eff 	.word	0xcc435eff
 8037108:	000927bf 	.word	0x000927bf
 803710c:	cc38b0a0 	.word	0xcc38b0a0
 8037110:	0007a120 	.word	0x0007a120
 8037114:	cc2e0240 	.word	0xcc2e0240
 8037118:	0003d090 	.word	0x0003d090
 803711c:	cc296e60 	.word	0xcc296e60
 8037120:	000493e0 	.word	0x000493e0

08037124 <RegionEU868GetPhyParam>:
#endif /* REGION_EU868 */

PhyParam_t RegionEU868GetPhyParam( GetPhyParams_t* getPhy )
{
 8037124:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8037126:	7802      	ldrb	r2, [r0, #0]
    PhyParam_t phyParam = { 0 };
 8037128:	2300      	movs	r3, #0
 803712a:	3a0b      	subs	r2, #11
 803712c:	9300      	str	r3, [sp, #0]

#if defined( REGION_EU868 )
    switch( getPhy->Attribute )
 803712e:	2a2e      	cmp	r2, #46	; 0x2e
 8037130:	d871      	bhi.n	8037216 <RegionEU868GetPhyParam+0xf2>
 8037132:	e8df f002 	tbb	[pc, r2]
 8037136:	302d      	.short	0x302d
 8037138:	42403932 	.word	0x42403932
 803713c:	4e4b4845 	.word	0x4e4b4845
 8037140:	5c705451 	.word	0x5c705451
 8037144:	68635e70 	.word	0x68635e70
 8037148:	6d70706a 	.word	0x6d70706a
 803714c:	70701874 	.word	0x70701874
 8037150:	70707070 	.word	0x70707070
 8037154:	70707070 	.word	0x70707070
 8037158:	5c707070 	.word	0x5c707070
 803715c:	70707d76 	.word	0x70707d76
 8037160:	7f707d5c 	.word	0x7f707d5c
 8037164:	84          	.byte	0x84
 8037165:	00          	.byte	0x00
            phyParam.Value = EU868_DEFAULT_DATARATE;
            break;
        }
        case PHY_NEXT_LOWER_TX_DR:
        {
            RegionCommonGetNextLowerTxDrParams_t nextLowerTxDrParams =
 8037166:	7843      	ldrb	r3, [r0, #1]
 8037168:	f88d 3004 	strb.w	r3, [sp, #4]
 803716c:	2307      	movs	r3, #7
 803716e:	f88d 3005 	strb.w	r3, [sp, #5]
 8037172:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8037176:	f8ad 3006 	strh.w	r3, [sp, #6]
            {
                .CurrentDr = getPhy->Datarate,
                .MaxDr = ( int8_t )EU868_TX_MAX_DATARATE,
                .MinDr = ( int8_t )EU868_TX_MIN_DATARATE,
                .NbChannels = EU868_MAX_NB_CHANNELS,
                .ChannelsMask = RegionNvmGroup2->ChannelsMask,
 803717a:	4b34      	ldr	r3, [pc, #208]	; (803724c <RegionEU868GetPhyParam+0x128>)
 803717c:	681b      	ldr	r3, [r3, #0]
                .Channels = RegionNvmGroup2->Channels,
            };
            phyParam.Value = RegionCommonGetNextLowerTxDr( &nextLowerTxDrParams );
 803717e:	a801      	add	r0, sp, #4
                .ChannelsMask = RegionNvmGroup2->ChannelsMask,
 8037180:	f503 7258 	add.w	r2, r3, #864	; 0x360
            RegionCommonGetNextLowerTxDrParams_t nextLowerTxDrParams =
 8037184:	e9cd 2302 	strd	r2, r3, [sp, #8]
            phyParam.Value = RegionCommonGetNextLowerTxDr( &nextLowerTxDrParams );
 8037188:	f7ff fee9 	bl	8036f5e <RegionCommonGetNextLowerTxDr>
            phyParam.Value = DataratesEU868[getPhy->Datarate];
            break;
        }
        case PHY_BW_FROM_DR:
        {
            phyParam.Value = RegionCommonGetBandwidth( getPhy->Datarate, BandwidthsEU868 );
 803718c:	9000      	str	r0, [sp, #0]
            break;
 803718e:	e042      	b.n	8037216 <RegionEU868GetPhyParam+0xf2>
            phyParam.Value = REGION_COMMON_DEFAULT_ADR_ACK_LIMIT;
 8037190:	2340      	movs	r3, #64	; 0x40
            phyParam.Value = EU868_BEACON_CHANNEL_DR;
 8037192:	9300      	str	r3, [sp, #0]
            break;
 8037194:	e03f      	b.n	8037216 <RegionEU868GetPhyParam+0xf2>
            phyParam.Value = REGION_COMMON_DEFAULT_ADR_ACK_DELAY;
 8037196:	2320      	movs	r3, #32
 8037198:	e7fb      	b.n	8037192 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = MaxPayloadOfDatarateEU868[getPhy->Datarate];
 803719a:	f990 2001 	ldrsb.w	r2, [r0, #1]
 803719e:	4b2c      	ldr	r3, [pc, #176]	; (8037250 <RegionEU868GetPhyParam+0x12c>)
 80371a0:	4413      	add	r3, r2
 80371a2:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 80371a6:	e7f4      	b.n	8037192 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = MaxPayloadOfDatarateRepeaterEU868[getPhy->Datarate];
 80371a8:	f990 2001 	ldrsb.w	r2, [r0, #1]
 80371ac:	4b28      	ldr	r3, [pc, #160]	; (8037250 <RegionEU868GetPhyParam+0x12c>)
 80371ae:	4413      	add	r3, r2
 80371b0:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 80371b4:	e7ed      	b.n	8037192 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = EU868_DUTY_CYCLE_ENABLED;
 80371b6:	2301      	movs	r3, #1
 80371b8:	e7eb      	b.n	8037192 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = EU868_MAX_RX_WINDOW;
 80371ba:	f640 33b8 	movw	r3, #3000	; 0xbb8
 80371be:	e7e8      	b.n	8037192 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = REGION_COMMON_DEFAULT_RECEIVE_DELAY1;
 80371c0:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80371c4:	e7e5      	b.n	8037192 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = REGION_COMMON_DEFAULT_RECEIVE_DELAY2;
 80371c6:	f44f 63fa 	mov.w	r3, #2000	; 0x7d0
 80371ca:	e7e2      	b.n	8037192 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = REGION_COMMON_DEFAULT_JOIN_ACCEPT_DELAY1;
 80371cc:	f241 3388 	movw	r3, #5000	; 0x1388
 80371d0:	e7df      	b.n	8037192 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = REGION_COMMON_DEFAULT_JOIN_ACCEPT_DELAY2;
 80371d2:	f241 7370 	movw	r3, #6000	; 0x1770
 80371d6:	e7dc      	b.n	8037192 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = REGION_COMMON_DEFAULT_MAX_FCNT_GAP;
 80371d8:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 80371dc:	e7d9      	b.n	8037192 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = ( REGION_COMMON_DEFAULT_ACK_TIMEOUT + randr( -REGION_COMMON_DEFAULT_ACK_TIMEOUT_RND, REGION_COMMON_DEFAULT_ACK_TIMEOUT_RND ) );
 80371de:	481d      	ldr	r0, [pc, #116]	; (8037254 <RegionEU868GetPhyParam+0x130>)
 80371e0:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 80371e4:	f001 fe88 	bl	8038ef8 <randr>
 80371e8:	f500 60fa 	add.w	r0, r0, #2000	; 0x7d0
 80371ec:	e7ce      	b.n	803718c <RegionEU868GetPhyParam+0x68>
            phyParam.Value = EU868_RX_WND_2_FREQ;
 80371ee:	4b1a      	ldr	r3, [pc, #104]	; (8037258 <RegionEU868GetPhyParam+0x134>)
 80371f0:	e7cf      	b.n	8037192 <RegionEU868GetPhyParam+0x6e>
            phyParam.ChannelsMask = RegionNvmGroup2->ChannelsMask;
 80371f2:	4b16      	ldr	r3, [pc, #88]	; (803724c <RegionEU868GetPhyParam+0x128>)
 80371f4:	681b      	ldr	r3, [r3, #0]
 80371f6:	f503 7358 	add.w	r3, r3, #864	; 0x360
 80371fa:	e7ca      	b.n	8037192 <RegionEU868GetPhyParam+0x6e>
            phyParam.ChannelsMask = RegionNvmGroup2->ChannelsDefaultMask;
 80371fc:	4b13      	ldr	r3, [pc, #76]	; (803724c <RegionEU868GetPhyParam+0x128>)
 80371fe:	681b      	ldr	r3, [r3, #0]
 8037200:	f503 735b 	add.w	r3, r3, #876	; 0x36c
 8037204:	e7c5      	b.n	8037192 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = EU868_MAX_NB_CHANNELS;
 8037206:	2310      	movs	r3, #16
 8037208:	e7c3      	b.n	8037192 <RegionEU868GetPhyParam+0x6e>
            phyParam.Channels = RegionNvmGroup2->Channels;
 803720a:	4b10      	ldr	r3, [pc, #64]	; (803724c <RegionEU868GetPhyParam+0x128>)
 803720c:	681b      	ldr	r3, [r3, #0]
 803720e:	e7c0      	b.n	8037192 <RegionEU868GetPhyParam+0x6e>
            phyParam.fValue = EU868_DEFAULT_MAX_EIRP;
 8037210:	f04f 4383 	mov.w	r3, #1098907648	; 0x41800000
            phyParam.fValue = EU868_DEFAULT_ANTENNA_GAIN;
 8037214:	9300      	str	r3, [sp, #0]
        }
    }

#endif /* REGION_EU868 */
    return phyParam;
}
 8037216:	9800      	ldr	r0, [sp, #0]
 8037218:	b005      	add	sp, #20
 803721a:	f85d fb04 	ldr.w	pc, [sp], #4
            phyParam.fValue = EU868_DEFAULT_ANTENNA_GAIN;
 803721e:	4b0f      	ldr	r3, [pc, #60]	; (803725c <RegionEU868GetPhyParam+0x138>)
 8037220:	e7f8      	b.n	8037214 <RegionEU868GetPhyParam+0xf0>
            phyParam.BeaconFormat.BeaconSize = EU868_BEACON_SIZE;
 8037222:	f240 2211 	movw	r2, #529	; 0x211
 8037226:	f8ad 2000 	strh.w	r2, [sp]
            phyParam.BeaconFormat.Rfu2Size = EU868_RFU2_SIZE;
 803722a:	f88d 3002 	strb.w	r3, [sp, #2]
            break;
 803722e:	e7f2      	b.n	8037216 <RegionEU868GetPhyParam+0xf2>
            phyParam.Value = EU868_BEACON_CHANNEL_DR;
 8037230:	2303      	movs	r3, #3
 8037232:	e7ae      	b.n	8037192 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = DataratesEU868[getPhy->Datarate];
 8037234:	f990 3001 	ldrsb.w	r3, [r0, #1]
 8037238:	4a05      	ldr	r2, [pc, #20]	; (8037250 <RegionEU868GetPhyParam+0x12c>)
 803723a:	5cd3      	ldrb	r3, [r2, r3]
 803723c:	e7a9      	b.n	8037192 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = RegionCommonGetBandwidth( getPhy->Datarate, BandwidthsEU868 );
 803723e:	4908      	ldr	r1, [pc, #32]	; (8037260 <RegionEU868GetPhyParam+0x13c>)
 8037240:	f990 0001 	ldrsb.w	r0, [r0, #1]
 8037244:	f7ff feaa 	bl	8036f9c <RegionCommonGetBandwidth>
 8037248:	e7a0      	b.n	803718c <RegionEU868GetPhyParam+0x68>
 803724a:	bf00      	nop
 803724c:	20005728 	.word	0x20005728
 8037250:	0803baf4 	.word	0x0803baf4
 8037254:	fffffc18 	.word	0xfffffc18
 8037258:	33d3e608 	.word	0x33d3e608
 803725c:	4009999a 	.word	0x4009999a
 8037260:	0803bafc 	.word	0x0803bafc

08037264 <RegionEU868SetBandTxDone>:

void RegionEU868SetBandTxDone( SetBandTxDoneParams_t* txDone )
{
 8037264:	b537      	push	{r0, r1, r2, r4, r5, lr}
#if defined( REGION_EU868 )
    RegionCommonSetBandTxDone( &RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txDone->Channel].Band],
 8037266:	4a0a      	ldr	r2, [pc, #40]	; (8037290 <RegionEU868SetBandTxDone+0x2c>)
 8037268:	7803      	ldrb	r3, [r0, #0]
 803726a:	6811      	ldr	r1, [r2, #0]
 803726c:	6855      	ldr	r5, [r2, #4]
 803726e:	240c      	movs	r4, #12
 8037270:	fb04 1303 	mla	r3, r4, r3, r1
 8037274:	7a5b      	ldrb	r3, [r3, #9]
 8037276:	eb03 0443 	add.w	r4, r3, r3, lsl #1
 803727a:	6903      	ldr	r3, [r0, #16]
 803727c:	9300      	str	r3, [sp, #0]
 803727e:	68c3      	ldr	r3, [r0, #12]
 8037280:	7842      	ldrb	r2, [r0, #1]
 8037282:	6881      	ldr	r1, [r0, #8]
 8037284:	eb05 00c4 	add.w	r0, r5, r4, lsl #3
 8037288:	f7ff fc18 	bl	8036abc <RegionCommonSetBandTxDone>
                               txDone->LastTxAirTime, txDone->Joined, txDone->ElapsedTimeSinceStartUp );
#endif /* REGION_EU868 */
}
 803728c:	b003      	add	sp, #12
 803728e:	bd30      	pop	{r4, r5, pc}
 8037290:	20005728 	.word	0x20005728

08037294 <RegionEU868InitDefaults>:

void RegionEU868InitDefaults( InitDefaultsParams_t* params )
{
 8037294:	b530      	push	{r4, r5, lr}
 8037296:	b0a5      	sub	sp, #148	; 0x94
 8037298:	4604      	mov	r4, r0
#if defined( REGION_EU868 )
    Band_t bands[EU868_MAX_NB_BANDS] =
 803729a:	2290      	movs	r2, #144	; 0x90
 803729c:	2100      	movs	r1, #0
 803729e:	4668      	mov	r0, sp
 80372a0:	f004 fa72 	bl	803b788 <memset>
 80372a4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80372a8:	f8ad 2030 	strh.w	r2, [sp, #48]	; 0x30
 80372ac:	f8ad 2078 	strh.w	r2, [sp, #120]	; 0x78
        EU868_BAND3,
        EU868_BAND4,
        EU868_BAND5,
    };

    switch( params->Type )
 80372b0:	7a22      	ldrb	r2, [r4, #8]
    Band_t bands[EU868_MAX_NB_BANDS] =
 80372b2:	2364      	movs	r3, #100	; 0x64
 80372b4:	210a      	movs	r1, #10
    switch( params->Type )
 80372b6:	2a01      	cmp	r2, #1
    Band_t bands[EU868_MAX_NB_BANDS] =
 80372b8:	f8ad 3000 	strh.w	r3, [sp]
 80372bc:	f8ad 3018 	strh.w	r3, [sp, #24]
 80372c0:	f8ad 1048 	strh.w	r1, [sp, #72]	; 0x48
 80372c4:	f8ad 3060 	strh.w	r3, [sp, #96]	; 0x60
    switch( params->Type )
 80372c8:	d02d      	beq.n	8037326 <RegionEU868InitDefaults+0x92>
 80372ca:	2a02      	cmp	r2, #2
 80372cc:	d036      	beq.n	803733c <RegionEU868InitDefaults+0xa8>
 80372ce:	bb42      	cbnz	r2, 8037322 <RegionEU868InitDefaults+0x8e>
    {
        case INIT_TYPE_DEFAULTS:
        {
            if( ( params->NvmGroup1 == NULL ) || ( params->NvmGroup2 == NULL ) )
 80372d0:	6820      	ldr	r0, [r4, #0]
 80372d2:	b330      	cbz	r0, 8037322 <RegionEU868InitDefaults+0x8e>
 80372d4:	6863      	ldr	r3, [r4, #4]
 80372d6:	b323      	cbz	r3, 8037322 <RegionEU868InitDefaults+0x8e>
            {
                return;
            }

            RegionNvmGroup1 = (RegionNvmDataGroup1_t*) params->NvmGroup1;
 80372d8:	4c1d      	ldr	r4, [pc, #116]	; (8037350 <RegionEU868InitDefaults+0xbc>)
            RegionNvmGroup2 = (RegionNvmDataGroup2_t*) params->NvmGroup2;

            // Default bands
            memcpy1( ( uint8_t* )RegionNvmGroup1->Bands, ( uint8_t* )bands, sizeof( Band_t ) * EU868_MAX_NB_BANDS );
 80372da:	2290      	movs	r2, #144	; 0x90
 80372dc:	4669      	mov	r1, sp
            RegionNvmGroup2 = (RegionNvmDataGroup2_t*) params->NvmGroup2;
 80372de:	e9c4 3000 	strd	r3, r0, [r4]
            memcpy1( ( uint8_t* )RegionNvmGroup1->Bands, ( uint8_t* )bands, sizeof( Band_t ) * EU868_MAX_NB_BANDS );
 80372e2:	f001 fe25 	bl	8038f30 <memcpy1>

            // Default channels
            RegionNvmGroup2->Channels[0] = ( ChannelParams_t ) EU868_LC1;
 80372e6:	4b1b      	ldr	r3, [pc, #108]	; (8037354 <RegionEU868InitDefaults+0xc0>)
 80372e8:	6824      	ldr	r4, [r4, #0]
 80372ea:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 80372ee:	e884 0007 	stmia.w	r4, {r0, r1, r2}
            RegionNvmGroup2->Channels[1] = ( ChannelParams_t ) EU868_LC2;
 80372f2:	f103 020c 	add.w	r2, r3, #12
 80372f6:	ca07      	ldmia	r2, {r0, r1, r2}
 80372f8:	f104 050c 	add.w	r5, r4, #12
            RegionNvmGroup2->Channels[2] = ( ChannelParams_t ) EU868_LC3;
 80372fc:	3318      	adds	r3, #24
            RegionNvmGroup2->Channels[1] = ( ChannelParams_t ) EU868_LC2;
 80372fe:	e885 0007 	stmia.w	r5, {r0, r1, r2}
            RegionNvmGroup2->Channels[2] = ( ChannelParams_t ) EU868_LC3;
 8037302:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8037306:	f104 0518 	add.w	r5, r4, #24

            // Default ChannelsMask
            RegionNvmGroup2->ChannelsDefaultMask[0] = LC( 1 ) + LC( 2 ) + LC( 3 );
 803730a:	2307      	movs	r3, #7
            RegionNvmGroup2->Channels[2] = ( ChannelParams_t ) EU868_LC3;
 803730c:	e885 0007 	stmia.w	r5, {r0, r1, r2}
            RegionNvmGroup2->ChannelsDefaultMask[0] = LC( 1 ) + LC( 2 ) + LC( 3 );
 8037310:	f8a4 336c 	strh.w	r3, [r4, #876]	; 0x36c

            // Update the channels mask
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
 8037314:	2201      	movs	r2, #1
 8037316:	f504 715b 	add.w	r1, r4, #876	; 0x36c
 803731a:	f504 7058 	add.w	r0, r4, #864	; 0x360
            // Reset Channels Rx1Frequency to default 0
            RegionNvmGroup2->Channels[0].Rx1Frequency = 0;
            RegionNvmGroup2->Channels[1].Rx1Frequency = 0;
            RegionNvmGroup2->Channels[2].Rx1Frequency = 0;
            // Update the channels mask
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
 803731e:	f7ff fbbe 	bl	8036a9e <RegionCommonChanMaskCopy>
        {
            break;
        }
    }
#endif /* REGION_EU868 */
}
 8037322:	b025      	add	sp, #148	; 0x94
 8037324:	bd30      	pop	{r4, r5, pc}
            RegionNvmGroup2->Channels[0].Rx1Frequency = 0;
 8037326:	4b0a      	ldr	r3, [pc, #40]	; (8037350 <RegionEU868InitDefaults+0xbc>)
 8037328:	6818      	ldr	r0, [r3, #0]
 803732a:	2300      	movs	r3, #0
 803732c:	6043      	str	r3, [r0, #4]
            RegionNvmGroup2->Channels[1].Rx1Frequency = 0;
 803732e:	6103      	str	r3, [r0, #16]
            RegionNvmGroup2->Channels[2].Rx1Frequency = 0;
 8037330:	61c3      	str	r3, [r0, #28]
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
 8037332:	f500 715b 	add.w	r1, r0, #876	; 0x36c
 8037336:	f500 7058 	add.w	r0, r0, #864	; 0x360
 803733a:	e7f0      	b.n	803731e <RegionEU868InitDefaults+0x8a>
            RegionNvmGroup2->ChannelsMask[0] |= RegionNvmGroup2->ChannelsDefaultMask[0];
 803733c:	4b04      	ldr	r3, [pc, #16]	; (8037350 <RegionEU868InitDefaults+0xbc>)
 803733e:	681b      	ldr	r3, [r3, #0]
 8037340:	f8b3 2360 	ldrh.w	r2, [r3, #864]	; 0x360
 8037344:	f8b3 136c 	ldrh.w	r1, [r3, #876]	; 0x36c
 8037348:	430a      	orrs	r2, r1
 803734a:	f8a3 2360 	strh.w	r2, [r3, #864]	; 0x360
            break;
 803734e:	e7e8      	b.n	8037322 <RegionEU868InitDefaults+0x8e>
 8037350:	20005728 	.word	0x20005728
 8037354:	0803bb2c 	.word	0x0803bb2c

08037358 <RegionEU868Verify>:

bool RegionEU868Verify( VerifyParams_t* verify, PhyAttribute_t phyAttribute )
{
 8037358:	b507      	push	{r0, r1, r2, lr}
 803735a:	290f      	cmp	r1, #15
 803735c:	d809      	bhi.n	8037372 <RegionEU868Verify+0x1a>
 803735e:	e8df f001 	tbb	[pc, r1]
 8037362:	080c      	.short	0x080c
 8037364:	1f080808 	.word	0x1f080808
 8037368:	1f081f15 	.word	0x1f081f15
 803736c:	0808081f 	.word	0x0808081f
 8037370:	2108      	.short	0x2108
            // Remark: switched min and max!
            return RegionCommonValueInRange( verify->TxPower, EU868_MAX_TX_POWER, EU868_MIN_TX_POWER );
        }
        case PHY_DUTY_CYCLE:
        {
            return EU868_DUTY_CYCLE_ENABLED;
 8037372:	2000      	movs	r0, #0
            return false;
    }
#else
    return false;
#endif /* REGION_EU868 */
}
 8037374:	b003      	add	sp, #12
 8037376:	f85d fb04 	ldr.w	pc, [sp], #4
            uint8_t band = 0;
 803737a:	2300      	movs	r3, #0
            return VerifyRfFreq( verify->Frequency, &band );
 803737c:	f10d 0107 	add.w	r1, sp, #7
 8037380:	6800      	ldr	r0, [r0, #0]
            uint8_t band = 0;
 8037382:	f88d 3007 	strb.w	r3, [sp, #7]
            return VerifyRfFreq( verify->Frequency, &band );
 8037386:	f7ff fe7f 	bl	8037088 <VerifyRfFreq>
 803738a:	e7f3      	b.n	8037374 <RegionEU868Verify+0x1c>
            return RegionCommonValueInRange( verify->DatarateParams.Datarate, DR_0, DR_5 );
 803738c:	2205      	movs	r2, #5
 803738e:	f990 0000 	ldrsb.w	r0, [r0]
 8037392:	2100      	movs	r1, #0
 8037394:	f7ff fb43 	bl	8036a1e <RegionCommonValueInRange>
 8037398:	3800      	subs	r0, #0
 803739a:	bf18      	it	ne
 803739c:	2001      	movne	r0, #1
 803739e:	e7e9      	b.n	8037374 <RegionEU868Verify+0x1c>
            return RegionCommonValueInRange( verify->TxPower, EU868_MAX_TX_POWER, EU868_MIN_TX_POWER );
 80373a0:	2207      	movs	r2, #7
 80373a2:	e7f4      	b.n	803738e <RegionEU868Verify+0x36>
            return EU868_DUTY_CYCLE_ENABLED;
 80373a4:	2001      	movs	r0, #1
 80373a6:	e7e5      	b.n	8037374 <RegionEU868Verify+0x1c>

080373a8 <RegionEU868ChanMaskSet>:
    }
#endif /* REGION_EU868 */
}

bool RegionEU868ChanMaskSet( ChanMaskSetParams_t* chanMaskSet )
{
 80373a8:	b510      	push	{r4, lr}
#if defined( REGION_EU868 )
    switch( chanMaskSet->ChannelsMaskType )
 80373aa:	7904      	ldrb	r4, [r0, #4]
 80373ac:	b11c      	cbz	r4, 80373b6 <RegionEU868ChanMaskSet+0xe>
 80373ae:	2c01      	cmp	r4, #1
 80373b0:	d00b      	beq.n	80373ca <RegionEU868ChanMaskSet+0x22>
 80373b2:	2000      	movs	r0, #0
    }
    return true;
#else
    return false;
#endif /* REGION_EU868 */
}
 80373b4:	bd10      	pop	{r4, pc}
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, chanMaskSet->ChannelsMaskIn, CHANNELS_MASK_SIZE );
 80373b6:	4b0a      	ldr	r3, [pc, #40]	; (80373e0 <RegionEU868ChanMaskSet+0x38>)
 80373b8:	6801      	ldr	r1, [r0, #0]
 80373ba:	681b      	ldr	r3, [r3, #0]
 80373bc:	2201      	movs	r2, #1
 80373be:	f503 7058 	add.w	r0, r3, #864	; 0x360
 80373c2:	f7ff fb6c 	bl	8036a9e <RegionCommonChanMaskCopy>
    return true;
 80373c6:	2001      	movs	r0, #1
            break;
 80373c8:	e7f4      	b.n	80373b4 <RegionEU868ChanMaskSet+0xc>
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsDefaultMask, chanMaskSet->ChannelsMaskIn, CHANNELS_MASK_SIZE );
 80373ca:	4b05      	ldr	r3, [pc, #20]	; (80373e0 <RegionEU868ChanMaskSet+0x38>)
 80373cc:	6801      	ldr	r1, [r0, #0]
 80373ce:	681b      	ldr	r3, [r3, #0]
 80373d0:	4622      	mov	r2, r4
 80373d2:	f503 705b 	add.w	r0, r3, #876	; 0x36c
 80373d6:	f7ff fb62 	bl	8036a9e <RegionCommonChanMaskCopy>
    return true;
 80373da:	4620      	mov	r0, r4
            break;
 80373dc:	e7ea      	b.n	80373b4 <RegionEU868ChanMaskSet+0xc>
 80373de:	bf00      	nop
 80373e0:	20005728 	.word	0x20005728

080373e4 <RegionEU868ComputeRxWindowParameters>:

void RegionEU868ComputeRxWindowParameters( int8_t datarate, uint8_t minRxSymbols, uint32_t rxError, RxConfigParams_t *rxConfigParams )
{
 80373e4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
#if defined( REGION_EU868 )
    uint32_t tSymbolInUs = 0;

    // Get the datarate, perform a boundary check
    rxConfigParams->Datarate = MIN( datarate, EU868_RX_MAX_DATARATE );
 80373e6:	2807      	cmp	r0, #7
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsEU868 );
 80373e8:	4d15      	ldr	r5, [pc, #84]	; (8037440 <RegionEU868ComputeRxWindowParameters+0x5c>)
{
 80373ea:	461c      	mov	r4, r3
    rxConfigParams->Datarate = MIN( datarate, EU868_RX_MAX_DATARATE );
 80373ec:	bfa8      	it	ge
 80373ee:	2007      	movge	r0, #7
 80373f0:	7058      	strb	r0, [r3, #1]
{
 80373f2:	460e      	mov	r6, r1
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsEU868 );
 80373f4:	f105 0108 	add.w	r1, r5, #8
{
 80373f8:	4617      	mov	r7, r2
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsEU868 );
 80373fa:	f7ff fdcf 	bl	8036f9c <RegionCommonGetBandwidth>

    if( rxConfigParams->Datarate == DR_7 )
 80373fe:	f994 3001 	ldrsb.w	r3, [r4, #1]
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsEU868 );
 8037402:	70a0      	strb	r0, [r4, #2]
    if( rxConfigParams->Datarate == DR_7 )
 8037404:	2b07      	cmp	r3, #7
 8037406:	d113      	bne.n	8037430 <RegionEU868ComputeRxWindowParameters+0x4c>
    { // FSK
        tSymbolInUs = RegionCommonComputeSymbolTimeFsk( DataratesEU868[rxConfigParams->Datarate] );
 8037408:	2032      	movs	r0, #50	; 0x32
 803740a:	f7ff fccb 	bl	8036da4 <RegionCommonComputeSymbolTimeFsk>
    else
    { // LoRa
        tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesEU868[rxConfigParams->Datarate], BandwidthsEU868[rxConfigParams->Datarate] );
    }

    RegionCommonComputeRxWindowParameters( tSymbolInUs, minRxSymbols, rxError, Radio.GetWakeupTime( ), &rxConfigParams->WindowTimeout, &rxConfigParams->WindowOffset );
 803740e:	4b0d      	ldr	r3, [pc, #52]	; (8037444 <RegionEU868ComputeRxWindowParameters+0x60>)
 8037410:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
        tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesEU868[rxConfigParams->Datarate], BandwidthsEU868[rxConfigParams->Datarate] );
 8037412:	4605      	mov	r5, r0
    RegionCommonComputeRxWindowParameters( tSymbolInUs, minRxSymbols, rxError, Radio.GetWakeupTime( ), &rxConfigParams->WindowTimeout, &rxConfigParams->WindowOffset );
 8037414:	4798      	blx	r3
 8037416:	f104 020c 	add.w	r2, r4, #12
 803741a:	3408      	adds	r4, #8
 803741c:	4603      	mov	r3, r0
 803741e:	9201      	str	r2, [sp, #4]
 8037420:	9400      	str	r4, [sp, #0]
 8037422:	463a      	mov	r2, r7
 8037424:	4631      	mov	r1, r6
 8037426:	4628      	mov	r0, r5
 8037428:	f7ff fcc1 	bl	8036dae <RegionCommonComputeRxWindowParameters>
#endif /* REGION_EU868 */
}
 803742c:	b003      	add	sp, #12
 803742e:	bdf0      	pop	{r4, r5, r6, r7, pc}
        tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesEU868[rxConfigParams->Datarate], BandwidthsEU868[rxConfigParams->Datarate] );
 8037430:	eb05 0283 	add.w	r2, r5, r3, lsl #2
 8037434:	5ce8      	ldrb	r0, [r5, r3]
 8037436:	6891      	ldr	r1, [r2, #8]
 8037438:	f7ff fcac 	bl	8036d94 <RegionCommonComputeSymbolTimeLoRa>
 803743c:	e7e7      	b.n	803740e <RegionEU868ComputeRxWindowParameters+0x2a>
 803743e:	bf00      	nop
 8037440:	0803baf4 	.word	0x0803baf4
 8037444:	0803bc30 	.word	0x0803bc30

08037448 <RegionEU868RxConfig>:

bool RegionEU868RxConfig( RxConfigParams_t* rxConfig, int8_t* datarate )
{
 8037448:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int8_t dr = rxConfig->Datarate;
    uint8_t maxPayload = 0;
    int8_t phyDr = 0;
    uint32_t frequency = rxConfig->Frequency;

    if( Radio.GetStatus( ) != RF_IDLE )
 803744c:	4e39      	ldr	r6, [pc, #228]	; (8037534 <RegionEU868RxConfig+0xec>)
    int8_t dr = rxConfig->Datarate;
 803744e:	f990 7001 	ldrsb.w	r7, [r0, #1]
    if( Radio.GetStatus( ) != RF_IDLE )
 8037452:	6873      	ldr	r3, [r6, #4]
    uint32_t frequency = rxConfig->Frequency;
 8037454:	f8d0 9004 	ldr.w	r9, [r0, #4]
{
 8037458:	b08d      	sub	sp, #52	; 0x34
 803745a:	4604      	mov	r4, r0
 803745c:	468a      	mov	sl, r1
    if( Radio.GetStatus( ) != RF_IDLE )
 803745e:	4798      	blx	r3
 8037460:	46b0      	mov	r8, r6
 8037462:	4605      	mov	r5, r0
 8037464:	2800      	cmp	r0, #0
 8037466:	d163      	bne.n	8037530 <RegionEU868RxConfig+0xe8>
    {
        return false;
    }

    if( rxConfig->RxSlot == RX_SLOT_WIN_1 )
 8037468:	7ce3      	ldrb	r3, [r4, #19]
 803746a:	b963      	cbnz	r3, 8037486 <RegionEU868RxConfig+0x3e>
    {
        // Apply window 1 frequency
        frequency = RegionNvmGroup2->Channels[rxConfig->Channel].Frequency;
 803746c:	4a32      	ldr	r2, [pc, #200]	; (8037538 <RegionEU868RxConfig+0xf0>)
 803746e:	7823      	ldrb	r3, [r4, #0]
 8037470:	6812      	ldr	r2, [r2, #0]
 8037472:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8037476:	eb02 0183 	add.w	r1, r2, r3, lsl #2
 803747a:	f852 9023 	ldr.w	r9, [r2, r3, lsl #2]
        // Apply the alternative RX 1 window frequency, if it is available
        if( RegionNvmGroup2->Channels[rxConfig->Channel].Rx1Frequency != 0 )
 803747e:	684b      	ldr	r3, [r1, #4]
 8037480:	2b00      	cmp	r3, #0
 8037482:	bf18      	it	ne
 8037484:	4699      	movne	r9, r3
            frequency = RegionNvmGroup2->Channels[rxConfig->Channel].Rx1Frequency;
        }
    }

    // Read the physical datarate from the datarates table
    phyDr = DataratesEU868[dr];
 8037486:	4e2d      	ldr	r6, [pc, #180]	; (803753c <RegionEU868RxConfig+0xf4>)

    Radio.SetChannel( frequency );
 8037488:	f8d8 300c 	ldr.w	r3, [r8, #12]
    phyDr = DataratesEU868[dr];
 803748c:	f916 b007 	ldrsb.w	fp, [r6, r7]
    Radio.SetChannel( frequency );
 8037490:	4648      	mov	r0, r9
 8037492:	4798      	blx	r3

    // Radio configuration
    if( dr == DR_7 )
 8037494:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8037498:	68a0      	ldr	r0, [r4, #8]
 803749a:	960b      	str	r6, [sp, #44]	; 0x2c
 803749c:	469c      	mov	ip, r3
 803749e:	2f07      	cmp	r7, #7
 80374a0:	7ca3      	ldrb	r3, [r4, #18]
    {
        modem = MODEM_FSK;
        Radio.SetRxConfig( modem, 50000, phyDr * 1000, 0, 83333, 5, rxConfig->WindowTimeout, false, 0, true, 0, 0, false, rxConfig->RxContinuous );
 80374a2:	9309      	str	r3, [sp, #36]	; 0x24
    if( dr == DR_7 )
 80374a4:	d12d      	bne.n	8037502 <RegionEU868RxConfig+0xba>
        Radio.SetRxConfig( modem, 50000, phyDr * 1000, 0, 83333, 5, rxConfig->WindowTimeout, false, 0, true, 0, 0, false, rxConfig->RxContinuous );
 80374a6:	2300      	movs	r3, #0
 80374a8:	2101      	movs	r1, #1
 80374aa:	e9cd 3104 	strd	r3, r1, [sp, #16]
 80374ae:	4924      	ldr	r1, [pc, #144]	; (8037540 <RegionEU868RxConfig+0xf8>)
 80374b0:	9306      	str	r3, [sp, #24]
 80374b2:	2205      	movs	r2, #5
 80374b4:	e9cd 3307 	strd	r3, r3, [sp, #28]
 80374b8:	e9cd 1200 	strd	r1, r2, [sp]
 80374bc:	b280      	uxth	r0, r0
 80374be:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80374c2:	9002      	str	r0, [sp, #8]
 80374c4:	9303      	str	r3, [sp, #12]
 80374c6:	fb02 f20b 	mul.w	r2, r2, fp
 80374ca:	f24c 3150 	movw	r1, #50000	; 0xc350
 80374ce:	4618      	mov	r0, r3
    }
    else
    {
        modem = MODEM_LORA;
        Radio.SetRxConfig( modem, rxConfig->Bandwidth, phyDr, 1, 0, 8, rxConfig->WindowTimeout, false, 0, false, 0, 0, true, rxConfig->RxContinuous );
 80374d0:	4666      	mov	r6, ip
 80374d2:	47b0      	blx	r6
    }

    /* ST_WORKAROUND_BEGIN: Keep repeater feature */
    if( rxConfig->RepeaterSupport == true )
 80374d4:	7c63      	ldrb	r3, [r4, #17]
 80374d6:	b333      	cbz	r3, 8037526 <RegionEU868RxConfig+0xde>
    {
        maxPayload = MaxPayloadOfDatarateRepeaterEU868[dr];
 80374d8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80374da:	443b      	add	r3, r7
 80374dc:	f893 1030 	ldrb.w	r1, [r3, #48]	; 0x30
    else
    {
        maxPayload = MaxPayloadOfDatarateEU868[dr];
    }

    Radio.SetMaxPayloadLength( modem, maxPayload + LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE );
 80374e0:	f8d8 3054 	ldr.w	r3, [r8, #84]	; 0x54
 80374e4:	310d      	adds	r1, #13
 80374e6:	b2c9      	uxtb	r1, r1
 80374e8:	4628      	mov	r0, r5
 80374ea:	4798      	blx	r3
    /* ST_WORKAROUND_END */

    /* ST_WORKAROUND_BEGIN: Print Rx config */
    RegionCommonRxConfigPrint(rxConfig->RxSlot, frequency, dr);
 80374ec:	7ce0      	ldrb	r0, [r4, #19]
 80374ee:	463a      	mov	r2, r7
 80374f0:	4649      	mov	r1, r9
 80374f2:	f7ff fd65 	bl	8036fc0 <RegionCommonRxConfigPrint>
    /* ST_WORKAROUND_END */

    *datarate = (uint8_t) dr;
 80374f6:	f88a 7000 	strb.w	r7, [sl]
    return true;
 80374fa:	2001      	movs	r0, #1
#else
    return false;
#endif /* REGION_EU868 */
}
 80374fc:	b00d      	add	sp, #52	; 0x34
 80374fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        Radio.SetRxConfig( modem, rxConfig->Bandwidth, phyDr, 1, 0, 8, rxConfig->WindowTimeout, false, 0, false, 0, 0, true, rxConfig->RxContinuous );
 8037502:	2100      	movs	r1, #0
 8037504:	2501      	movs	r5, #1
 8037506:	b280      	uxth	r0, r0
 8037508:	2308      	movs	r3, #8
 803750a:	e9cd 1300 	strd	r1, r3, [sp]
 803750e:	e9cd 1507 	strd	r1, r5, [sp, #28]
 8037512:	e9cd 1105 	strd	r1, r1, [sp, #20]
 8037516:	e9cd 1103 	strd	r1, r1, [sp, #12]
 803751a:	9002      	str	r0, [sp, #8]
 803751c:	78a1      	ldrb	r1, [r4, #2]
 803751e:	462b      	mov	r3, r5
 8037520:	465a      	mov	r2, fp
 8037522:	4628      	mov	r0, r5
 8037524:	e7d4      	b.n	80374d0 <RegionEU868RxConfig+0x88>
        maxPayload = MaxPayloadOfDatarateEU868[dr];
 8037526:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8037528:	443b      	add	r3, r7
 803752a:	f893 1028 	ldrb.w	r1, [r3, #40]	; 0x28
 803752e:	e7d7      	b.n	80374e0 <RegionEU868RxConfig+0x98>
        return false;
 8037530:	2000      	movs	r0, #0
 8037532:	e7e3      	b.n	80374fc <RegionEU868RxConfig+0xb4>
 8037534:	0803bc30 	.word	0x0803bc30
 8037538:	20005728 	.word	0x20005728
 803753c:	0803baf4 	.word	0x0803baf4
 8037540:	00014585 	.word	0x00014585

08037544 <RegionEU868TxConfig>:

bool RegionEU868TxConfig( TxConfigParams_t* txConfig, int8_t* txPower, TimerTime_t* txTimeOnAir )
{
 8037544:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if defined( REGION_EU868 )
    RadioModems_t modem;
    int8_t phyDr = DataratesEU868[txConfig->Datarate];
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
 8037548:	4f3d      	ldr	r7, [pc, #244]	; (8037640 <RegionEU868TxConfig+0xfc>)
    int8_t phyDr = DataratesEU868[txConfig->Datarate];
 803754a:	f990 3001 	ldrsb.w	r3, [r0, #1]
 803754e:	4e3d      	ldr	r6, [pc, #244]	; (8037644 <RegionEU868TxConfig+0x100>)
{
 8037550:	b08f      	sub	sp, #60	; 0x3c
 8037552:	e9cd 120b 	strd	r1, r2, [sp, #44]	; 0x2c
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
 8037556:	e9d7 1200 	ldrd	r1, r2, [r7]
{
 803755a:	4604      	mov	r4, r0
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
 803755c:	7800      	ldrb	r0, [r0, #0]
    int8_t phyDr = DataratesEU868[txConfig->Datarate];
 803755e:	56f3      	ldrsb	r3, [r6, r3]
 8037560:	930d      	str	r3, [sp, #52]	; 0x34
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
 8037562:	250c      	movs	r5, #12
 8037564:	fb05 1100 	mla	r1, r5, r0, r1
 8037568:	2018      	movs	r0, #24
 803756a:	7a49      	ldrb	r1, [r1, #9]
 803756c:	fb00 2201 	mla	r2, r0, r1, r2
 8037570:	f994 0002 	ldrsb.w	r0, [r4, #2]
 8037574:	f992 1002 	ldrsb.w	r1, [r2, #2]
 8037578:	f7ff fd0c 	bl	8036f94 <RegionCommonLimitTxPower>
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsEU868 );
 803757c:	f106 0108 	add.w	r1, r6, #8
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
 8037580:	4681      	mov	r9, r0
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsEU868 );
 8037582:	f994 0001 	ldrsb.w	r0, [r4, #1]
 8037586:	f7ff fd09 	bl	8036f9c <RegionCommonGetBandwidth>
    int8_t phyTxPower = 0;

    // Calculate physical TX power
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, txConfig->MaxEirp, txConfig->AntennaGain );
 803758a:	68a2      	ldr	r2, [r4, #8]
 803758c:	6861      	ldr	r1, [r4, #4]
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsEU868 );
 803758e:	4683      	mov	fp, r0
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, txConfig->MaxEirp, txConfig->AntennaGain );
 8037590:	4648      	mov	r0, r9
 8037592:	f7ff fc34 	bl	8036dfe <RegionCommonComputeTxPower>
 8037596:	4682      	mov	sl, r0

    // Setup the radio frequency
    Radio.SetChannel( RegionNvmGroup2->Channels[txConfig->Channel].Frequency );
 8037598:	7820      	ldrb	r0, [r4, #0]
 803759a:	6839      	ldr	r1, [r7, #0]
 803759c:	4368      	muls	r0, r5
 803759e:	4d2a      	ldr	r5, [pc, #168]	; (8037648 <RegionEU868TxConfig+0x104>)
 80375a0:	5808      	ldr	r0, [r1, r0]
 80375a2:	68ea      	ldr	r2, [r5, #12]
 80375a4:	4790      	blx	r2

    if( txConfig->Datarate == DR_7 )
 80375a6:	f994 2001 	ldrsb.w	r2, [r4, #1]
 80375aa:	69eb      	ldr	r3, [r5, #28]
 80375ac:	2a07      	cmp	r2, #7
 80375ae:	46a8      	mov	r8, r5
 80375b0:	f44f 627a 	mov.w	r2, #4000	; 0xfa0
 80375b4:	f04f 0500 	mov.w	r5, #0
 80375b8:	469c      	mov	ip, r3
    { // High Speed FSK channel
        modem = MODEM_FSK;
        Radio.SetTxConfig( modem, phyTxPower, 25000, bandwidth, phyDr * 1000, 0, 5, false, true, 0, 0, false, 4000 );
 80375ba:	e9cd 5207 	strd	r5, r2, [sp, #28]
 80375be:	e9cd 5505 	strd	r5, r5, [sp, #20]
    if( txConfig->Datarate == DR_7 )
 80375c2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80375c4:	d12c      	bne.n	8037620 <RegionEU868TxConfig+0xdc>
        Radio.SetTxConfig( modem, phyTxPower, 25000, bandwidth, phyDr * 1000, 0, 5, false, true, 0, 0, false, 4000 );
 80375c6:	2201      	movs	r2, #1
 80375c8:	e9cd 5203 	strd	r5, r2, [sp, #12]
 80375cc:	2205      	movs	r2, #5
 80375ce:	e9cd 5201 	strd	r5, r2, [sp, #4]
 80375d2:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80375d6:	4353      	muls	r3, r2
 80375d8:	9300      	str	r3, [sp, #0]
 80375da:	f246 12a8 	movw	r2, #25000	; 0x61a8
 80375de:	465b      	mov	r3, fp
 80375e0:	4651      	mov	r1, sl
 80375e2:	4628      	mov	r0, r5
 80375e4:	4666      	mov	r6, ip
 80375e6:	47b0      	blx	r6
    {
        modem = MODEM_LORA;
        Radio.SetTxConfig( modem, phyTxPower, 0, bandwidth, phyDr, 1, 8, false, true, 0, 0, false, 4000 );
    }
    /* ST_WORKAROUND_BEGIN: Print Tx config */
    RegionCommonTxConfigPrint(RegionNvmGroup2->Channels[txConfig->Channel].Frequency, txConfig->Datarate);
 80375e8:	7821      	ldrb	r1, [r4, #0]
 80375ea:	683a      	ldr	r2, [r7, #0]
 80375ec:	230c      	movs	r3, #12
 80375ee:	434b      	muls	r3, r1
 80375f0:	f994 1001 	ldrsb.w	r1, [r4, #1]
 80375f4:	58d0      	ldr	r0, [r2, r3]
 80375f6:	f7ff fd11 	bl	803701c <RegionCommonTxConfigPrint>
    /* ST_WORKAROUND_END */

    // Update time-on-air
    *txTimeOnAir = GetTimeOnAir( txConfig->Datarate, txConfig->PktLen );
 80375fa:	89a1      	ldrh	r1, [r4, #12]
 80375fc:	f994 0001 	ldrsb.w	r0, [r4, #1]
 8037600:	f7ff fd1a 	bl	8037038 <GetTimeOnAir>
 8037604:	9b0c      	ldr	r3, [sp, #48]	; 0x30

    // Setup maximum payload length of the radio driver
    Radio.SetMaxPayloadLength( modem, txConfig->PktLen );
 8037606:	7b21      	ldrb	r1, [r4, #12]
    *txTimeOnAir = GetTimeOnAir( txConfig->Datarate, txConfig->PktLen );
 8037608:	6018      	str	r0, [r3, #0]
    Radio.SetMaxPayloadLength( modem, txConfig->PktLen );
 803760a:	f8d8 3054 	ldr.w	r3, [r8, #84]	; 0x54
 803760e:	4628      	mov	r0, r5
 8037610:	4798      	blx	r3

    *txPower = txPowerLimited;
 8037612:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    return true;
#else
    return false;
#endif /* REGION_EU868 */
}
 8037614:	2001      	movs	r0, #1
    *txPower = txPowerLimited;
 8037616:	f883 9000 	strb.w	r9, [r3]
}
 803761a:	b00f      	add	sp, #60	; 0x3c
 803761c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        Radio.SetTxConfig( modem, phyTxPower, 0, bandwidth, phyDr, 1, 8, false, true, 0, 0, false, 4000 );
 8037620:	2601      	movs	r6, #1
 8037622:	2208      	movs	r2, #8
 8037624:	e9cd 5603 	strd	r5, r6, [sp, #12]
 8037628:	e9cd 6201 	strd	r6, r2, [sp, #4]
 803762c:	9300      	str	r3, [sp, #0]
 803762e:	462a      	mov	r2, r5
 8037630:	465b      	mov	r3, fp
 8037632:	4665      	mov	r5, ip
 8037634:	4651      	mov	r1, sl
 8037636:	4630      	mov	r0, r6
 8037638:	47a8      	blx	r5
        modem = MODEM_LORA;
 803763a:	4635      	mov	r5, r6
 803763c:	e7d4      	b.n	80375e8 <RegionEU868TxConfig+0xa4>
 803763e:	bf00      	nop
 8037640:	20005728 	.word	0x20005728
 8037644:	0803baf4 	.word	0x0803baf4
 8037648:	0803bc30 	.word	0x0803bc30

0803764c <RegionEU868LinkAdrReq>:

uint8_t RegionEU868LinkAdrReq( LinkAdrReqParams_t* linkAdrReq, int8_t* drOut, int8_t* txPowOut, uint8_t* nbRepOut, uint8_t* nbBytesParsed )
{
 803764c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8037650:	b08d      	sub	sp, #52	; 0x34
    uint8_t status = 0x07;
#if defined( REGION_EU868 )
    RegionCommonLinkAdrParams_t linkAdrParams = { 0 };
 8037652:	2400      	movs	r4, #0
{
 8037654:	4605      	mov	r5, r0
 8037656:	468a      	mov	sl, r1
 8037658:	4691      	mov	r9, r2
 803765a:	4698      	mov	r8, r3
    RegionCommonLinkAdrParams_t linkAdrParams = { 0 };
 803765c:	9402      	str	r4, [sp, #8]
 803765e:	f8ad 400c 	strh.w	r4, [sp, #12]
    uint8_t nextIndex = 0;
    uint8_t bytesProcessed = 0;
    uint16_t chMask = 0;
 8037662:	f8ad 4006 	strh.w	r4, [sp, #6]
    uint8_t status = 0x07;
 8037666:	2607      	movs	r6, #7
            {
                if( linkAdrParams.ChMaskCtrl == 6 )
                {
                    if( RegionNvmGroup2->Channels[i].Frequency != 0 )
                    {
                        chMask |= 1 << i;
 8037668:	f04f 0b01 	mov.w	fp, #1
    while( bytesProcessed < linkAdrReq->PayloadSize )
 803766c:	7a2b      	ldrb	r3, [r5, #8]
 803766e:	42a3      	cmp	r3, r4
 8037670:	d906      	bls.n	8037680 <RegionEU868LinkAdrReq+0x34>
        nextIndex = RegionCommonParseLinkAdrReq( &( linkAdrReq->Payload[bytesProcessed] ), &linkAdrParams );
 8037672:	6868      	ldr	r0, [r5, #4]
 8037674:	a902      	add	r1, sp, #8
 8037676:	4420      	add	r0, r4
 8037678:	f7ff fb32 	bl	8036ce0 <RegionCommonParseLinkAdrReq>
        if( nextIndex == 0 )
 803767c:	2800      	cmp	r0, #0
 803767e:	d154      	bne.n	803772a <RegionEU868LinkAdrReq+0xde>
    getPhy.Attribute = PHY_MIN_TX_DR;
    getPhy.UplinkDwellTime = linkAdrReq->UplinkDwellTime;
    phyParam = RegionEU868GetPhyParam( &getPhy );

    linkAdrVerifyParams.Status = status;
    linkAdrVerifyParams.AdrEnabled = linkAdrReq->AdrEnabled;
 8037680:	7aab      	ldrb	r3, [r5, #10]
 8037682:	f88d 3015 	strb.w	r3, [sp, #21]
    linkAdrVerifyParams.Datarate = linkAdrParams.Datarate;
 8037686:	f89d 3009 	ldrb.w	r3, [sp, #9]
 803768a:	f88d 3016 	strb.w	r3, [sp, #22]
    linkAdrVerifyParams.TxPower = linkAdrParams.TxPower;
 803768e:	f89d 300a 	ldrb.w	r3, [sp, #10]
 8037692:	f88d 3017 	strb.w	r3, [sp, #23]
    linkAdrVerifyParams.NbRep = linkAdrParams.NbRep;
 8037696:	f89d 3008 	ldrb.w	r3, [sp, #8]
 803769a:	f88d 3018 	strb.w	r3, [sp, #24]
    linkAdrVerifyParams.CurrentDatarate = linkAdrReq->CurrentDatarate;
 803769e:	7aeb      	ldrb	r3, [r5, #11]
 80376a0:	f88d 3019 	strb.w	r3, [sp, #25]
    linkAdrVerifyParams.CurrentTxPower = linkAdrReq->CurrentTxPower;
 80376a4:	7b2b      	ldrb	r3, [r5, #12]
 80376a6:	f88d 301a 	strb.w	r3, [sp, #26]
    linkAdrVerifyParams.CurrentNbRep = linkAdrReq->CurrentNbRep;
 80376aa:	7b6b      	ldrb	r3, [r5, #13]
 80376ac:	f88d 301b 	strb.w	r3, [sp, #27]
    linkAdrVerifyParams.NbChannels = EU868_MAX_NB_CHANNELS;
 80376b0:	2310      	movs	r3, #16
    linkAdrVerifyParams.Status = status;
 80376b2:	f88d 6014 	strb.w	r6, [sp, #20]
    linkAdrVerifyParams.NbChannels = EU868_MAX_NB_CHANNELS;
 80376b6:	f88d 301c 	strb.w	r3, [sp, #28]
    linkAdrVerifyParams.ChannelsMask = &chMask;
    linkAdrVerifyParams.MinDatarate = ( int8_t )phyParam.Value;
    linkAdrVerifyParams.MaxDatarate = EU868_TX_MAX_DATARATE;
    linkAdrVerifyParams.Channels = RegionNvmGroup2->Channels;
 80376ba:	4e3a      	ldr	r6, [pc, #232]	; (80377a4 <RegionEU868LinkAdrReq+0x158>)
    linkAdrVerifyParams.ChannelsMask = &chMask;
 80376bc:	f10d 0306 	add.w	r3, sp, #6
 80376c0:	9308      	str	r3, [sp, #32]
    linkAdrVerifyParams.MinDatarate = ( int8_t )phyParam.Value;
 80376c2:	f44f 63e0 	mov.w	r3, #1792	; 0x700
 80376c6:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
    linkAdrVerifyParams.Channels = RegionNvmGroup2->Channels;
 80376ca:	6833      	ldr	r3, [r6, #0]
 80376cc:	930a      	str	r3, [sp, #40]	; 0x28
    linkAdrVerifyParams.MinTxPower = EU868_MIN_TX_POWER;
 80376ce:	2307      	movs	r3, #7
 80376d0:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
    linkAdrVerifyParams.MaxTxPower = EU868_MAX_TX_POWER;
    linkAdrVerifyParams.Version = linkAdrReq->Version;
 80376d4:	682b      	ldr	r3, [r5, #0]
 80376d6:	9304      	str	r3, [sp, #16]

    // Verify the parameters and update, if necessary
    status = RegionCommonLinkAdrReqVerifyParams( &linkAdrVerifyParams, &linkAdrParams.Datarate, &linkAdrParams.TxPower, &linkAdrParams.NbRep );
 80376d8:	f10d 020a 	add.w	r2, sp, #10
 80376dc:	ab02      	add	r3, sp, #8
 80376de:	f10d 0109 	add.w	r1, sp, #9
 80376e2:	a804      	add	r0, sp, #16
 80376e4:	f7ff fb16 	bl	8036d14 <RegionCommonLinkAdrReqVerifyParams>

    // Update channelsMask if everything is correct
    if( status == 0x07 )
 80376e8:	2807      	cmp	r0, #7
    status = RegionCommonLinkAdrReqVerifyParams( &linkAdrVerifyParams, &linkAdrParams.Datarate, &linkAdrParams.TxPower, &linkAdrParams.NbRep );
 80376ea:	4605      	mov	r5, r0
    if( status == 0x07 )
 80376ec:	d10b      	bne.n	8037706 <RegionEU868LinkAdrReq+0xba>
    {
        // Set the channels mask to a default value
        memset1( ( uint8_t* ) RegionNvmGroup2->ChannelsMask, 0, sizeof( RegionNvmGroup2->ChannelsMask ) );
 80376ee:	6830      	ldr	r0, [r6, #0]
 80376f0:	220c      	movs	r2, #12
 80376f2:	2100      	movs	r1, #0
 80376f4:	f500 7058 	add.w	r0, r0, #864	; 0x360
 80376f8:	f001 fc2e 	bl	8038f58 <memset1>
        // Update the channels mask
        RegionNvmGroup2->ChannelsMask[0] = chMask;
 80376fc:	6833      	ldr	r3, [r6, #0]
 80376fe:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 8037702:	f8a3 2360 	strh.w	r2, [r3, #864]	; 0x360
    }

    // Update status variables
    *drOut = linkAdrParams.Datarate;
 8037706:	f89d 3009 	ldrb.w	r3, [sp, #9]
 803770a:	f88a 3000 	strb.w	r3, [sl]
    *txPowOut = linkAdrParams.TxPower;
 803770e:	f89d 300a 	ldrb.w	r3, [sp, #10]
 8037712:	f889 3000 	strb.w	r3, [r9]
    *nbRepOut = linkAdrParams.NbRep;
 8037716:	f89d 3008 	ldrb.w	r3, [sp, #8]
 803771a:	f888 3000 	strb.w	r3, [r8]
    *nbBytesParsed = bytesProcessed;
 803771e:	9b16      	ldr	r3, [sp, #88]	; 0x58

#endif /* REGION_EU868 */
    return status;
}
 8037720:	4628      	mov	r0, r5
    *nbBytesParsed = bytesProcessed;
 8037722:	701c      	strb	r4, [r3, #0]
}
 8037724:	b00d      	add	sp, #52	; 0x34
 8037726:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if( ( linkAdrParams.ChMaskCtrl == 0 ) && ( chMask == 0 ) )
 803772a:	f89d 300b 	ldrb.w	r3, [sp, #11]
        chMask = linkAdrParams.ChMask;
 803772e:	f8bd 700c 	ldrh.w	r7, [sp, #12]
 8037732:	f8ad 7006 	strh.w	r7, [sp, #6]
        bytesProcessed += nextIndex;
 8037736:	4404      	add	r4, r0
 8037738:	b2e4      	uxtb	r4, r4
        if( ( linkAdrParams.ChMaskCtrl == 0 ) && ( chMask == 0 ) )
 803773a:	b9f3      	cbnz	r3, 803777a <RegionEU868LinkAdrReq+0x12e>
 803773c:	b317      	cbz	r7, 8037784 <RegionEU868LinkAdrReq+0x138>
                        ( RegionNvmGroup2->Channels[i].Frequency == 0 ) )
 803773e:	4a19      	ldr	r2, [pc, #100]	; (80377a4 <RegionEU868LinkAdrReq+0x158>)
 8037740:	2000      	movs	r0, #0
 8037742:	6811      	ldr	r1, [r2, #0]
 8037744:	2607      	movs	r6, #7
 8037746:	4602      	mov	r2, r0
 8037748:	f04f 0c0c 	mov.w	ip, #12
                if( linkAdrParams.ChMaskCtrl == 6 )
 803774c:	2b06      	cmp	r3, #6
 803774e:	d11b      	bne.n	8037788 <RegionEU868LinkAdrReq+0x13c>
                    if( RegionNvmGroup2->Channels[i].Frequency != 0 )
 8037750:	fb0c fe00 	mul.w	lr, ip, r0
 8037754:	f851 e00e 	ldr.w	lr, [r1, lr]
 8037758:	f1be 0f00 	cmp.w	lr, #0
 803775c:	d004      	beq.n	8037768 <RegionEU868LinkAdrReq+0x11c>
                        chMask |= 1 << i;
 803775e:	fa0b f200 	lsl.w	r2, fp, r0
 8037762:	4317      	orrs	r7, r2
 8037764:	b2bf      	uxth	r7, r7
 8037766:	2201      	movs	r2, #1
            for( uint8_t i = 0; i < EU868_MAX_NB_CHANNELS; i++ )
 8037768:	3001      	adds	r0, #1
 803776a:	2810      	cmp	r0, #16
 803776c:	d1ee      	bne.n	803774c <RegionEU868LinkAdrReq+0x100>
 803776e:	2a00      	cmp	r2, #0
 8037770:	f43f af7c 	beq.w	803766c <RegionEU868LinkAdrReq+0x20>
 8037774:	f8ad 7006 	strh.w	r7, [sp, #6]
 8037778:	e778      	b.n	803766c <RegionEU868LinkAdrReq+0x20>
        else if( ( ( linkAdrParams.ChMaskCtrl >= 1 ) && ( linkAdrParams.ChMaskCtrl <= 5 )) ||
 803777a:	1e5a      	subs	r2, r3, #1
 803777c:	2a04      	cmp	r2, #4
 803777e:	d901      	bls.n	8037784 <RegionEU868LinkAdrReq+0x138>
 8037780:	2b06      	cmp	r3, #6
 8037782:	d0dc      	beq.n	803773e <RegionEU868LinkAdrReq+0xf2>
            status &= 0xFE; // Channel mask KO
 8037784:	2606      	movs	r6, #6
 8037786:	e771      	b.n	803766c <RegionEU868LinkAdrReq+0x20>
                    if( ( ( chMask & ( 1 << i ) ) != 0 ) &&
 8037788:	fa47 fe00 	asr.w	lr, r7, r0
 803778c:	f01e 0f01 	tst.w	lr, #1
 8037790:	d0ea      	beq.n	8037768 <RegionEU868LinkAdrReq+0x11c>
                        ( RegionNvmGroup2->Channels[i].Frequency == 0 ) )
 8037792:	fb0c fe00 	mul.w	lr, ip, r0
                    if( ( ( chMask & ( 1 << i ) ) != 0 ) &&
 8037796:	f851 e00e 	ldr.w	lr, [r1, lr]
                        status &= 0xFE; // Channel mask KO
 803779a:	f1be 0f00 	cmp.w	lr, #0
 803779e:	bf08      	it	eq
 80377a0:	2606      	moveq	r6, #6
 80377a2:	e7e1      	b.n	8037768 <RegionEU868LinkAdrReq+0x11c>
 80377a4:	20005728 	.word	0x20005728

080377a8 <RegionEU868RxParamSetupReq>:

uint8_t RegionEU868RxParamSetupReq( RxParamSetupReqParams_t* rxParamSetupReq )
{
 80377a8:	b573      	push	{r0, r1, r4, r5, r6, lr}
    uint8_t status = 0x07;
#if defined( REGION_EU868 )
    uint8_t band = 0;
 80377aa:	2600      	movs	r6, #0
{
 80377ac:	4605      	mov	r5, r0

    // Verify radio frequency
    if( VerifyRfFreq( rxParamSetupReq->Frequency, &band ) == false )
 80377ae:	f10d 0107 	add.w	r1, sp, #7
 80377b2:	6840      	ldr	r0, [r0, #4]
    uint8_t band = 0;
 80377b4:	f88d 6007 	strb.w	r6, [sp, #7]
    if( VerifyRfFreq( rxParamSetupReq->Frequency, &band ) == false )
 80377b8:	f7ff fc66 	bl	8037088 <VerifyRfFreq>
    {
        status &= 0xFE; // Channel frequency KO
    }

    // Verify datarate
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, EU868_RX_MIN_DATARATE, EU868_RX_MAX_DATARATE ) == false )
 80377bc:	2207      	movs	r2, #7
    if( VerifyRfFreq( rxParamSetupReq->Frequency, &band ) == false )
 80377be:	42b0      	cmp	r0, r6
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, EU868_RX_MIN_DATARATE, EU868_RX_MAX_DATARATE ) == false )
 80377c0:	4631      	mov	r1, r6
 80377c2:	f995 0000 	ldrsb.w	r0, [r5]
        status &= 0xFE; // Channel frequency KO
 80377c6:	bf14      	ite	ne
 80377c8:	2407      	movne	r4, #7
 80377ca:	2406      	moveq	r4, #6
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, EU868_RX_MIN_DATARATE, EU868_RX_MAX_DATARATE ) == false )
 80377cc:	f7ff f927 	bl	8036a1e <RegionCommonValueInRange>
 80377d0:	b908      	cbnz	r0, 80377d6 <RegionEU868RxParamSetupReq+0x2e>
    {
        status &= 0xFD; // Datarate KO
 80377d2:	f004 0405 	and.w	r4, r4, #5
    }

    // Verify datarate offset
    if( RegionCommonValueInRange( rxParamSetupReq->DrOffset, EU868_MIN_RX1_DR_OFFSET, EU868_MAX_RX1_DR_OFFSET ) == false )
 80377d6:	f995 0001 	ldrsb.w	r0, [r5, #1]
 80377da:	2205      	movs	r2, #5
 80377dc:	2100      	movs	r1, #0
 80377de:	f7ff f91e 	bl	8036a1e <RegionCommonValueInRange>
 80377e2:	b908      	cbnz	r0, 80377e8 <RegionEU868RxParamSetupReq+0x40>
    {
        status &= 0xFB; // Rx1DrOffset range KO
 80377e4:	f004 04fb 	and.w	r4, r4, #251	; 0xfb
    }

#endif /* REGION_EU868 */
    return status;
}
 80377e8:	4620      	mov	r0, r4
 80377ea:	b002      	add	sp, #8
 80377ec:	bd70      	pop	{r4, r5, r6, pc}

080377ee <RegionEU868TxParamSetupReq>:

int8_t RegionEU868TxParamSetupReq( TxParamSetupReqParams_t* txParamSetupReq )
{
    // Do not accept the request
    return -1;
}
 80377ee:	f04f 30ff 	mov.w	r0, #4294967295
 80377f2:	4770      	bx	lr

080377f4 <RegionEU868DlChannelReq>:

int8_t RegionEU868DlChannelReq( DlChannelReqParams_t* dlChannelReq )
{
 80377f4:	b513      	push	{r0, r1, r4, lr}
 80377f6:	4604      	mov	r4, r0
    uint8_t status = 0x03;
#if defined( REGION_EU868 )
    uint8_t band = 0;
 80377f8:	2300      	movs	r3, #0

    // Verify if the frequency is supported
    if( VerifyRfFreq( dlChannelReq->Rx1Frequency, &band ) == false )
 80377fa:	f10d 0107 	add.w	r1, sp, #7
 80377fe:	6840      	ldr	r0, [r0, #4]
    uint8_t band = 0;
 8037800:	f88d 3007 	strb.w	r3, [sp, #7]
    if( VerifyRfFreq( dlChannelReq->Rx1Frequency, &band ) == false )
 8037804:	f7ff fc40 	bl	8037088 <VerifyRfFreq>
 8037808:	7823      	ldrb	r3, [r4, #0]
 803780a:	4a0b      	ldr	r2, [pc, #44]	; (8037838 <RegionEU868DlChannelReq+0x44>)
 803780c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8037810:	6812      	ldr	r2, [r2, #0]
 8037812:	eb02 0183 	add.w	r1, r2, r3, lsl #2
    {
        status &= 0xFE;
    }

    // Verify if an uplink frequency exists
    if( RegionNvmGroup2->Channels[dlChannelReq->ChannelId].Frequency == 0 )
 8037816:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    if( VerifyRfFreq( dlChannelReq->Rx1Frequency, &band ) == false )
 803781a:	2800      	cmp	r0, #0
        status &= 0xFE;
 803781c:	bf14      	ite	ne
 803781e:	2003      	movne	r0, #3
 8037820:	2002      	moveq	r0, #2
    if( RegionNvmGroup2->Channels[dlChannelReq->ChannelId].Frequency == 0 )
 8037822:	b91b      	cbnz	r3, 803782c <RegionEU868DlChannelReq+0x38>
    {
        status &= 0xFD;
 8037824:	f000 0001 	and.w	r0, r0, #1
        RegionNvmGroup2->Channels[dlChannelReq->ChannelId].Rx1Frequency = dlChannelReq->Rx1Frequency;
    }

#endif /* REGION_EU868 */
    return status;
}
 8037828:	b002      	add	sp, #8
 803782a:	bd10      	pop	{r4, pc}
    if( status == 0x03 )
 803782c:	2803      	cmp	r0, #3
        RegionNvmGroup2->Channels[dlChannelReq->ChannelId].Rx1Frequency = dlChannelReq->Rx1Frequency;
 803782e:	bf06      	itte	eq
 8037830:	6863      	ldreq	r3, [r4, #4]
 8037832:	604b      	streq	r3, [r1, #4]
 8037834:	2002      	movne	r0, #2
 8037836:	e7f7      	b.n	8037828 <RegionEU868DlChannelReq+0x34>
 8037838:	20005728 	.word	0x20005728

0803783c <RegionEU868AlternateDr>:
#if defined( REGION_EU868 )
    return currentDr;
#else
    return -1;
#endif /* REGION_EU868 */
}
 803783c:	4770      	bx	lr
	...

08037840 <RegionEU868NextChannel>:

LoRaMacStatus_t RegionEU868NextChannel( NextChanParams_t* nextChanParams, uint8_t* channel, TimerTime_t* time, TimerTime_t* aggregatedTimeOff )
{
 8037840:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    RegionCommonIdentifyChannelsParam_t identifyChannelsParam;
    RegionCommonCountNbOfEnabledChannelsParams_t countChannelsParams;
    LoRaMacStatus_t status = LORAMAC_STATUS_NO_CHANNEL_FOUND;
    uint16_t joinChannels = EU868_JOIN_CHANNELS;

    if( RegionCommonCountChannels( RegionNvmGroup2->ChannelsMask, 0, 1 ) == 0 )
 8037844:	4d38      	ldr	r5, [pc, #224]	; (8037928 <RegionEU868NextChannel+0xe8>)
{
 8037846:	4604      	mov	r4, r0
    if( RegionCommonCountChannels( RegionNvmGroup2->ChannelsMask, 0, 1 ) == 0 )
 8037848:	6828      	ldr	r0, [r5, #0]
{
 803784a:	b096      	sub	sp, #88	; 0x58
 803784c:	460e      	mov	r6, r1
 803784e:	4690      	mov	r8, r2
    uint8_t nbEnabledChannels = 0;
 8037850:	2100      	movs	r1, #0
{
 8037852:	461f      	mov	r7, r3
    if( RegionCommonCountChannels( RegionNvmGroup2->ChannelsMask, 0, 1 ) == 0 )
 8037854:	2201      	movs	r2, #1
    uint16_t joinChannels = EU868_JOIN_CHANNELS;
 8037856:	2307      	movs	r3, #7
    if( RegionCommonCountChannels( RegionNvmGroup2->ChannelsMask, 0, 1 ) == 0 )
 8037858:	f500 7058 	add.w	r0, r0, #864	; 0x360
    uint8_t enabledChannels[EU868_MAX_NB_CHANNELS] = { 0 };
 803785c:	e9cd 1104 	strd	r1, r1, [sp, #16]
 8037860:	e9cd 1106 	strd	r1, r1, [sp, #24]
    uint8_t nbEnabledChannels = 0;
 8037864:	f88d 100c 	strb.w	r1, [sp, #12]
    uint8_t nbRestrictedChannels = 0;
 8037868:	f88d 100d 	strb.w	r1, [sp, #13]
    uint16_t joinChannels = EU868_JOIN_CHANNELS;
 803786c:	f8ad 300e 	strh.w	r3, [sp, #14]
    if( RegionCommonCountChannels( RegionNvmGroup2->ChannelsMask, 0, 1 ) == 0 )
 8037870:	f7ff f8f7 	bl	8036a62 <RegionCommonCountChannels>
 8037874:	b930      	cbnz	r0, 8037884 <RegionEU868NextChannel+0x44>
    { // Reactivate default channels
        RegionNvmGroup2->ChannelsMask[0] |= LC( 1 ) + LC( 2 ) + LC( 3 );
 8037876:	682a      	ldr	r2, [r5, #0]
 8037878:	f8b2 3360 	ldrh.w	r3, [r2, #864]	; 0x360
 803787c:	f043 0307 	orr.w	r3, r3, #7
 8037880:	f8a2 3360 	strh.w	r3, [r2, #864]	; 0x360
    }

    // Search how many channels are enabled
    countChannelsParams.Joined = nextChanParams->Joined;
    countChannelsParams.Datarate = nextChanParams->Datarate;
    countChannelsParams.ChannelsMask = RegionNvmGroup2->ChannelsMask;
 8037884:	682a      	ldr	r2, [r5, #0]
    countChannelsParams.Joined = nextChanParams->Joined;
 8037886:	7a63      	ldrb	r3, [r4, #9]
 8037888:	f88d 3020 	strb.w	r3, [sp, #32]
    countChannelsParams.ChannelsMask = RegionNvmGroup2->ChannelsMask;
 803788c:	f502 7158 	add.w	r1, r2, #864	; 0x360
    countChannelsParams.Channels = RegionNvmGroup2->Channels;
 8037890:	e9cd 1209 	strd	r1, r2, [sp, #36]	; 0x24
    countChannelsParams.Bands = RegionNvmGroup1->Bands;
 8037894:	686a      	ldr	r2, [r5, #4]
 8037896:	920b      	str	r2, [sp, #44]	; 0x2c
    countChannelsParams.MaxNbChannels = EU868_MAX_NB_CHANNELS;
 8037898:	2210      	movs	r2, #16
 803789a:	f8ad 2030 	strh.w	r2, [sp, #48]	; 0x30
    countChannelsParams.JoinChannels = &joinChannels;
 803789e:	f10d 020e 	add.w	r2, sp, #14
 80378a2:	920d      	str	r2, [sp, #52]	; 0x34

    identifyChannelsParam.AggrTimeOff = nextChanParams->AggrTimeOff;
 80378a4:	6822      	ldr	r2, [r4, #0]
 80378a6:	920e      	str	r2, [sp, #56]	; 0x38
    identifyChannelsParam.LastAggrTx = nextChanParams->LastAggrTx;
 80378a8:	6862      	ldr	r2, [r4, #4]
 80378aa:	920f      	str	r2, [sp, #60]	; 0x3c
    identifyChannelsParam.DutyCycleEnabled = nextChanParams->DutyCycleEnabled;
    identifyChannelsParam.MaxBands = EU868_MAX_NB_BANDS;

    identifyChannelsParam.ElapsedTimeSinceStartUp = nextChanParams->ElapsedTimeSinceStartUp;
 80378ac:	e9d4 0103 	ldrd	r0, r1, [r4, #12]
    identifyChannelsParam.DutyCycleEnabled = nextChanParams->DutyCycleEnabled;
 80378b0:	7aa2      	ldrb	r2, [r4, #10]
    countChannelsParams.Datarate = nextChanParams->Datarate;
 80378b2:	f994 3008 	ldrsb.w	r3, [r4, #8]
    identifyChannelsParam.DutyCycleEnabled = nextChanParams->DutyCycleEnabled;
 80378b6:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
    identifyChannelsParam.MaxBands = EU868_MAX_NB_BANDS;
 80378ba:	2206      	movs	r2, #6
 80378bc:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
    identifyChannelsParam.ElapsedTimeSinceStartUp = nextChanParams->ElapsedTimeSinceStartUp;
 80378c0:	aa11      	add	r2, sp, #68	; 0x44
 80378c2:	e882 0003 	stmia.w	r2, {r0, r1}
    identifyChannelsParam.LastTxIsJoinRequest = nextChanParams->LastTxIsJoinRequest;
 80378c6:	7d22      	ldrb	r2, [r4, #20]
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 80378c8:	8ae1      	ldrh	r1, [r4, #22]
    countChannelsParams.Datarate = nextChanParams->Datarate;
 80378ca:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 80378ce:	4618      	mov	r0, r3
    identifyChannelsParam.LastTxIsJoinRequest = nextChanParams->LastTxIsJoinRequest;
 80378d0:	f88d 204c 	strb.w	r2, [sp, #76]	; 0x4c
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 80378d4:	f7ff fbb0 	bl	8037038 <GetTimeOnAir>

    identifyChannelsParam.CountNbOfEnabledChannelsParam = &countChannelsParams;
 80378d8:	ab08      	add	r3, sp, #32
 80378da:	9315      	str	r3, [sp, #84]	; 0x54

    status = RegionCommonIdentifyChannels( &identifyChannelsParam, aggregatedTimeOff, enabledChannels,
 80378dc:	f10d 030d 	add.w	r3, sp, #13
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 80378e0:	9014      	str	r0, [sp, #80]	; 0x50
    status = RegionCommonIdentifyChannels( &identifyChannelsParam, aggregatedTimeOff, enabledChannels,
 80378e2:	9300      	str	r3, [sp, #0]
 80378e4:	f8cd 8004 	str.w	r8, [sp, #4]
 80378e8:	ab03      	add	r3, sp, #12
 80378ea:	aa04      	add	r2, sp, #16
 80378ec:	4639      	mov	r1, r7
 80378ee:	a80e      	add	r0, sp, #56	; 0x38
 80378f0:	f7ff faf1 	bl	8036ed6 <RegionCommonIdentifyChannels>
                                           &nbEnabledChannels, &nbRestrictedChannels, time );

    if( status == LORAMAC_STATUS_OK )
 80378f4:	4604      	mov	r4, r0
 80378f6:	b968      	cbnz	r0, 8037914 <RegionEU868NextChannel+0xd4>
    {
        // We found a valid channel
        *channel = enabledChannels[randr( 0, nbEnabledChannels - 1 )];
 80378f8:	f89d 100c 	ldrb.w	r1, [sp, #12]
 80378fc:	3901      	subs	r1, #1
 80378fe:	f001 fafb 	bl	8038ef8 <randr>
 8037902:	ab16      	add	r3, sp, #88	; 0x58
 8037904:	4418      	add	r0, r3
 8037906:	f810 3c48 	ldrb.w	r3, [r0, #-72]
 803790a:	7033      	strb	r3, [r6, #0]
    }
    return status;
#else
    return LORAMAC_STATUS_NO_CHANNEL_FOUND;
#endif /* REGION_EU868 */
}
 803790c:	4620      	mov	r0, r4
 803790e:	b016      	add	sp, #88	; 0x58
 8037910:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    else if( status == LORAMAC_STATUS_NO_CHANNEL_FOUND )
 8037914:	280c      	cmp	r0, #12
        RegionNvmGroup2->ChannelsMask[0] |= LC( 1 ) + LC( 2 ) + LC( 3 );
 8037916:	bf01      	itttt	eq
 8037918:	682a      	ldreq	r2, [r5, #0]
 803791a:	f8b2 3360 	ldrheq.w	r3, [r2, #864]	; 0x360
 803791e:	f043 0307 	orreq.w	r3, r3, #7
 8037922:	f8a2 3360 	strheq.w	r3, [r2, #864]	; 0x360
 8037926:	e7f1      	b.n	803790c <RegionEU868NextChannel+0xcc>
 8037928:	20005728 	.word	0x20005728

0803792c <RegionEU868ChannelAdd>:

LoRaMacStatus_t RegionEU868ChannelAdd( ChannelAddParams_t* channelAdd )
{
 803792c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
#if defined( REGION_EU868 )
    uint8_t band = 0;
    bool drInvalid = false;
    bool freqInvalid = false;
    uint8_t id = channelAdd->ChannelId;
 803792e:	7906      	ldrb	r6, [r0, #4]
    uint8_t band = 0;
 8037930:	2700      	movs	r7, #0

    if( id < EU868_NUMB_DEFAULT_CHANNELS )
 8037932:	2e02      	cmp	r6, #2
{
 8037934:	4605      	mov	r5, r0
    uint8_t band = 0;
 8037936:	f88d 7007 	strb.w	r7, [sp, #7]
    if( id < EU868_NUMB_DEFAULT_CHANNELS )
 803793a:	d802      	bhi.n	8037942 <RegionEU868ChannelAdd+0x16>
    {
        return LORAMAC_STATUS_FREQ_AND_DR_INVALID;
 803793c:	2006      	movs	r0, #6
    RegionNvmGroup2->ChannelsMask[0] |= ( 1 << id );
    return LORAMAC_STATUS_OK;
#else
    return LORAMAC_STATUS_NO_CHANNEL_FOUND;
#endif /* REGION_EU868 */
}
 803793e:	b003      	add	sp, #12
 8037940:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if( id >= EU868_MAX_NB_CHANNELS )
 8037942:	2e0f      	cmp	r6, #15
 8037944:	d82d      	bhi.n	80379a2 <RegionEU868ChannelAdd+0x76>
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Min, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 8037946:	6803      	ldr	r3, [r0, #0]
 8037948:	7a18      	ldrb	r0, [r3, #8]
 803794a:	f340 0003 	sbfx	r0, r0, #0, #4
 803794e:	2207      	movs	r2, #7
 8037950:	4639      	mov	r1, r7
 8037952:	b240      	sxtb	r0, r0
 8037954:	f7ff f863 	bl	8036a1e <RegionCommonValueInRange>
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Max, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 8037958:	682b      	ldr	r3, [r5, #0]
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Min, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 803795a:	4604      	mov	r4, r0
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Max, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 803795c:	7a18      	ldrb	r0, [r3, #8]
 803795e:	f340 1003 	sbfx	r0, r0, #4, #4
 8037962:	2207      	movs	r2, #7
 8037964:	4639      	mov	r1, r7
 8037966:	b240      	sxtb	r0, r0
 8037968:	f7ff f859 	bl	8036a1e <RegionCommonValueInRange>
 803796c:	b1b8      	cbz	r0, 803799e <RegionEU868ChannelAdd+0x72>
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Min, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 803796e:	fab4 f484 	clz	r4, r4
 8037972:	0964      	lsrs	r4, r4, #5
    if( channelAdd->NewChannel->DrRange.Fields.Min > channelAdd->NewChannel->DrRange.Fields.Max )
 8037974:	6828      	ldr	r0, [r5, #0]
 8037976:	7a03      	ldrb	r3, [r0, #8]
        if( VerifyRfFreq( channelAdd->NewChannel->Frequency, &band ) == false )
 8037978:	6800      	ldr	r0, [r0, #0]
    if( channelAdd->NewChannel->DrRange.Fields.Min > channelAdd->NewChannel->DrRange.Fields.Max )
 803797a:	f343 0203 	sbfx	r2, r3, #0, #4
 803797e:	f343 1303 	sbfx	r3, r3, #4, #4
 8037982:	b252      	sxtb	r2, r2
 8037984:	b25b      	sxtb	r3, r3
        if( VerifyRfFreq( channelAdd->NewChannel->Frequency, &band ) == false )
 8037986:	f10d 0107 	add.w	r1, sp, #7
        drInvalid = true;
 803798a:	429a      	cmp	r2, r3
 803798c:	bfc8      	it	gt
 803798e:	2401      	movgt	r4, #1
        if( VerifyRfFreq( channelAdd->NewChannel->Frequency, &band ) == false )
 8037990:	f7ff fb7a 	bl	8037088 <VerifyRfFreq>
 8037994:	b948      	cbnz	r0, 80379aa <RegionEU868ChannelAdd+0x7e>
    if( ( drInvalid == true ) && ( freqInvalid == true ) )
 8037996:	2c00      	cmp	r4, #0
 8037998:	d1d0      	bne.n	803793c <RegionEU868ChannelAdd+0x10>
        return LORAMAC_STATUS_FREQUENCY_INVALID;
 803799a:	2004      	movs	r0, #4
 803799c:	e7cf      	b.n	803793e <RegionEU868ChannelAdd+0x12>
        drInvalid = true;
 803799e:	2401      	movs	r4, #1
 80379a0:	e7e8      	b.n	8037974 <RegionEU868ChannelAdd+0x48>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 80379a2:	2003      	movs	r0, #3
 80379a4:	e7cb      	b.n	803793e <RegionEU868ChannelAdd+0x12>
        return LORAMAC_STATUS_DATARATE_INVALID;
 80379a6:	2005      	movs	r0, #5
 80379a8:	e7c9      	b.n	803793e <RegionEU868ChannelAdd+0x12>
    if( ( drInvalid == true ) && ( freqInvalid == true ) )
 80379aa:	2c00      	cmp	r4, #0
 80379ac:	d1fb      	bne.n	80379a6 <RegionEU868ChannelAdd+0x7a>
    memcpy1( ( uint8_t* ) &(RegionNvmGroup2->Channels[id]), ( uint8_t* ) channelAdd->NewChannel, sizeof( RegionNvmGroup2->Channels[id] ) );
 80379ae:	4f0d      	ldr	r7, [pc, #52]	; (80379e4 <RegionEU868ChannelAdd+0xb8>)
 80379b0:	6829      	ldr	r1, [r5, #0]
 80379b2:	683b      	ldr	r3, [r7, #0]
 80379b4:	eb06 0046 	add.w	r0, r6, r6, lsl #1
 80379b8:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 80379bc:	220c      	movs	r2, #12
 80379be:	f001 fab7 	bl	8038f30 <memcpy1>
    RegionNvmGroup2->Channels[id].Band = band;
 80379c2:	683a      	ldr	r2, [r7, #0]
 80379c4:	f89d 1007 	ldrb.w	r1, [sp, #7]
 80379c8:	230c      	movs	r3, #12
 80379ca:	fb03 2306 	mla	r3, r3, r6, r2
    return LORAMAC_STATUS_OK;
 80379ce:	4620      	mov	r0, r4
    RegionNvmGroup2->Channels[id].Band = band;
 80379d0:	7259      	strb	r1, [r3, #9]
    RegionNvmGroup2->ChannelsMask[0] |= ( 1 << id );
 80379d2:	2301      	movs	r3, #1
 80379d4:	fa03 f606 	lsl.w	r6, r3, r6
 80379d8:	f8b2 3360 	ldrh.w	r3, [r2, #864]	; 0x360
 80379dc:	431e      	orrs	r6, r3
 80379de:	f8a2 6360 	strh.w	r6, [r2, #864]	; 0x360
    return LORAMAC_STATUS_OK;
 80379e2:	e7ac      	b.n	803793e <RegionEU868ChannelAdd+0x12>
 80379e4:	20005728 	.word	0x20005728

080379e8 <RegionEU868ChannelsRemove>:

bool RegionEU868ChannelsRemove( ChannelRemoveParams_t* channelRemove  )
{
 80379e8:	b410      	push	{r4}
#if defined( REGION_EU868 )
    uint8_t id = channelRemove->ChannelId;
 80379ea:	7801      	ldrb	r1, [r0, #0]

    if( id < EU868_NUMB_DEFAULT_CHANNELS )
 80379ec:	2902      	cmp	r1, #2
 80379ee:	d90e      	bls.n	8037a0e <RegionEU868ChannelsRemove+0x26>
    {
        return false;
    }

    // Remove the channel from the list of channels
    RegionNvmGroup2->Channels[id] = ( ChannelParams_t ){ 0, 0, { 0 }, 0 };
 80379f0:	4b08      	ldr	r3, [pc, #32]	; (8037a14 <RegionEU868ChannelsRemove+0x2c>)
 80379f2:	6818      	ldr	r0, [r3, #0]
 80379f4:	230c      	movs	r3, #12
 80379f6:	434b      	muls	r3, r1
 80379f8:	18c4      	adds	r4, r0, r3
 80379fa:	2200      	movs	r2, #0
 80379fc:	50c2      	str	r2, [r0, r3]
 80379fe:	e9c4 2201 	strd	r2, r2, [r4, #4]

    return RegionCommonChanDisable( RegionNvmGroup2->ChannelsMask, id, EU868_MAX_NB_CHANNELS );
 8037a02:	f500 7058 	add.w	r0, r0, #864	; 0x360
#else
    return false;
#endif /* REGION_EU868 */
}
 8037a06:	bc10      	pop	{r4}
    return RegionCommonChanDisable( RegionNvmGroup2->ChannelsMask, id, EU868_MAX_NB_CHANNELS );
 8037a08:	2210      	movs	r2, #16
 8037a0a:	f7ff b811 	b.w	8036a30 <RegionCommonChanDisable>
}
 8037a0e:	2000      	movs	r0, #0
 8037a10:	bc10      	pop	{r4}
 8037a12:	4770      	bx	lr
 8037a14:	20005728 	.word	0x20005728

08037a18 <RegionEU868ApplyCFList>:
{
 8037a18:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8037a1c:	b086      	sub	sp, #24
    newChannel.DrRange.Value = ( DR_5 << 4 ) | DR_0;
 8037a1e:	2350      	movs	r3, #80	; 0x50
 8037a20:	f88d 3014 	strb.w	r3, [sp, #20]
    if( applyCFList->Size != 16 )
 8037a24:	7903      	ldrb	r3, [r0, #4]
 8037a26:	2b10      	cmp	r3, #16
{
 8037a28:	4607      	mov	r7, r0
    if( applyCFList->Size != 16 )
 8037a2a:	d130      	bne.n	8037a8e <RegionEU868ApplyCFList+0x76>
    if( applyCFList->Payload[15] != 0 )
 8037a2c:	6803      	ldr	r3, [r0, #0]
 8037a2e:	7bdd      	ldrb	r5, [r3, #15]
 8037a30:	bb6d      	cbnz	r5, 8037a8e <RegionEU868ApplyCFList+0x76>
    for( uint8_t i = 0, chanIdx = EU868_NUMB_DEFAULT_CHANNELS; chanIdx < EU868_MAX_NB_CHANNELS; i+=3, chanIdx++ )
 8037a32:	2403      	movs	r4, #3
            newChannel.Frequency = 0;
 8037a34:	46a8      	mov	r8, r5
            newChannel.Frequency *= 100;
 8037a36:	2664      	movs	r6, #100	; 0x64
        if( chanIdx < ( EU868_NUMB_CHANNELS_CF_LIST + EU868_NUMB_DEFAULT_CHANNELS ) )
 8037a38:	2c07      	cmp	r4, #7
 8037a3a:	d814      	bhi.n	8037a66 <RegionEU868ApplyCFList+0x4e>
            newChannel.Frequency = (uint32_t) applyCFList->Payload[i];
 8037a3c:	683a      	ldr	r2, [r7, #0]
 8037a3e:	5d53      	ldrb	r3, [r2, r5]
 8037a40:	9303      	str	r3, [sp, #12]
            newChannel.Frequency |= ( (uint32_t) applyCFList->Payload[i + 1] << 8 );
 8037a42:	442a      	add	r2, r5
 8037a44:	7851      	ldrb	r1, [r2, #1]
 8037a46:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8037a4a:	9303      	str	r3, [sp, #12]
            newChannel.Frequency |= ( (uint32_t) applyCFList->Payload[i + 2] << 16 );
 8037a4c:	7892      	ldrb	r2, [r2, #2]
 8037a4e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
            newChannel.Frequency *= 100;
 8037a52:	4373      	muls	r3, r6
            newChannel.Rx1Frequency = 0;
 8037a54:	e9cd 3803 	strd	r3, r8, [sp, #12]
        if( newChannel.Frequency != 0 )
 8037a58:	b963      	cbnz	r3, 8037a74 <RegionEU868ApplyCFList+0x5c>
            RegionEU868ChannelsRemove( &channelRemove );
 8037a5a:	4668      	mov	r0, sp
            channelRemove.ChannelId = chanIdx;
 8037a5c:	f88d 4000 	strb.w	r4, [sp]
            RegionEU868ChannelsRemove( &channelRemove );
 8037a60:	f7ff ffc2 	bl	80379e8 <RegionEU868ChannelsRemove>
 8037a64:	e00d      	b.n	8037a82 <RegionEU868ApplyCFList+0x6a>
            newChannel.Frequency = 0;
 8037a66:	f8cd 800c 	str.w	r8, [sp, #12]
            newChannel.DrRange.Value = 0;
 8037a6a:	f88d 8014 	strb.w	r8, [sp, #20]
            newChannel.Rx1Frequency = 0;
 8037a6e:	f8cd 8010 	str.w	r8, [sp, #16]
        if( newChannel.Frequency != 0 )
 8037a72:	e7f2      	b.n	8037a5a <RegionEU868ApplyCFList+0x42>
            channelAdd.NewChannel = &newChannel;
 8037a74:	ab03      	add	r3, sp, #12
            RegionEU868ChannelAdd( &channelAdd );
 8037a76:	a801      	add	r0, sp, #4
            channelAdd.NewChannel = &newChannel;
 8037a78:	9301      	str	r3, [sp, #4]
            channelAdd.ChannelId = chanIdx;
 8037a7a:	f88d 4008 	strb.w	r4, [sp, #8]
            RegionEU868ChannelAdd( &channelAdd );
 8037a7e:	f7ff ff55 	bl	803792c <RegionEU868ChannelAdd>
    for( uint8_t i = 0, chanIdx = EU868_NUMB_DEFAULT_CHANNELS; chanIdx < EU868_MAX_NB_CHANNELS; i+=3, chanIdx++ )
 8037a82:	3401      	adds	r4, #1
 8037a84:	b2e4      	uxtb	r4, r4
 8037a86:	2c10      	cmp	r4, #16
 8037a88:	f105 0503 	add.w	r5, r5, #3
 8037a8c:	d1d4      	bne.n	8037a38 <RegionEU868ApplyCFList+0x20>
}
 8037a8e:	b006      	add	sp, #24
 8037a90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08037a94 <RegionEU868NewChannelReq>:
{
 8037a94:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    if( newChannelReq->NewChannel->Frequency == 0 )
 8037a96:	6802      	ldr	r2, [r0, #0]
 8037a98:	7903      	ldrb	r3, [r0, #4]
 8037a9a:	6811      	ldr	r1, [r2, #0]
 8037a9c:	b951      	cbnz	r1, 8037ab4 <RegionEU868NewChannelReq+0x20>
        if( RegionEU868ChannelsRemove( &channelRemove ) == false )
 8037a9e:	a801      	add	r0, sp, #4
        channelRemove.ChannelId = newChannelReq->ChannelId;
 8037aa0:	f88d 3004 	strb.w	r3, [sp, #4]
        if( RegionEU868ChannelsRemove( &channelRemove ) == false )
 8037aa4:	f7ff ffa0 	bl	80379e8 <RegionEU868ChannelsRemove>
 8037aa8:	b988      	cbnz	r0, 8037ace <RegionEU868NewChannelReq+0x3a>
            status &= 0xFC;
 8037aaa:	2000      	movs	r0, #0
}
 8037aac:	b240      	sxtb	r0, r0
 8037aae:	b005      	add	sp, #20
 8037ab0:	f85d fb04 	ldr.w	pc, [sp], #4
        switch( RegionEU868ChannelAdd( &channelAdd ) )
 8037ab4:	a802      	add	r0, sp, #8
        channelAdd.NewChannel = newChannelReq->NewChannel;
 8037ab6:	9202      	str	r2, [sp, #8]
        channelAdd.ChannelId = newChannelReq->ChannelId;
 8037ab8:	f88d 300c 	strb.w	r3, [sp, #12]
        switch( RegionEU868ChannelAdd( &channelAdd ) )
 8037abc:	f7ff ff36 	bl	803792c <RegionEU868ChannelAdd>
 8037ac0:	2806      	cmp	r0, #6
 8037ac2:	d8f2      	bhi.n	8037aaa <RegionEU868NewChannelReq+0x16>
 8037ac4:	4b03      	ldr	r3, [pc, #12]	; (8037ad4 <RegionEU868NewChannelReq+0x40>)
 8037ac6:	4418      	add	r0, r3
 8037ac8:	f890 005c 	ldrb.w	r0, [r0, #92]	; 0x5c
 8037acc:	e7ee      	b.n	8037aac <RegionEU868NewChannelReq+0x18>
    uint8_t status = 0x03;
 8037ace:	2003      	movs	r0, #3
 8037ad0:	e7ec      	b.n	8037aac <RegionEU868NewChannelReq+0x18>
 8037ad2:	bf00      	nop
 8037ad4:	0803baf4 	.word	0x0803baf4

08037ad8 <RegionEU868SetContinuousWave>:

void RegionEU868SetContinuousWave( ContinuousWaveParams_t* continuousWave )
{
 8037ad8:	b570      	push	{r4, r5, r6, lr}
#if defined( REGION_EU868 )
    int8_t txPowerLimited = RegionCommonLimitTxPower( continuousWave->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[continuousWave->Channel].Band].TxMaxPower );
 8037ada:	4e11      	ldr	r6, [pc, #68]	; (8037b20 <RegionEU868SetContinuousWave+0x48>)
 8037adc:	7802      	ldrb	r2, [r0, #0]
 8037ade:	e9d6 3100 	ldrd	r3, r1, [r6]
 8037ae2:	250c      	movs	r5, #12
 8037ae4:	fb05 3202 	mla	r2, r5, r2, r3
{
 8037ae8:	4604      	mov	r4, r0
    int8_t txPowerLimited = RegionCommonLimitTxPower( continuousWave->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[continuousWave->Channel].Band].TxMaxPower );
 8037aea:	7a53      	ldrb	r3, [r2, #9]
 8037aec:	f990 0002 	ldrsb.w	r0, [r0, #2]
 8037af0:	2218      	movs	r2, #24
 8037af2:	fb02 1303 	mla	r3, r2, r3, r1
 8037af6:	f993 1002 	ldrsb.w	r1, [r3, #2]
 8037afa:	f7ff fa4b 	bl	8036f94 <RegionCommonLimitTxPower>
    int8_t phyTxPower = 0;
    uint32_t frequency = RegionNvmGroup2->Channels[continuousWave->Channel].Frequency;
 8037afe:	7822      	ldrb	r2, [r4, #0]
 8037b00:	6833      	ldr	r3, [r6, #0]

    // Calculate physical TX power
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, continuousWave->MaxEirp, continuousWave->AntennaGain );
 8037b02:	6861      	ldr	r1, [r4, #4]
    uint32_t frequency = RegionNvmGroup2->Channels[continuousWave->Channel].Frequency;
 8037b04:	4355      	muls	r5, r2
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, continuousWave->MaxEirp, continuousWave->AntennaGain );
 8037b06:	68a2      	ldr	r2, [r4, #8]
    uint32_t frequency = RegionNvmGroup2->Channels[continuousWave->Channel].Frequency;
 8037b08:	595d      	ldr	r5, [r3, r5]
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, continuousWave->MaxEirp, continuousWave->AntennaGain );
 8037b0a:	f7ff f978 	bl	8036dfe <RegionCommonComputeTxPower>

    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 8037b0e:	4b05      	ldr	r3, [pc, #20]	; (8037b24 <RegionEU868SetContinuousWave+0x4c>)
 8037b10:	89a2      	ldrh	r2, [r4, #12]
 8037b12:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, continuousWave->MaxEirp, continuousWave->AntennaGain );
 8037b14:	4601      	mov	r1, r0
    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 8037b16:	4628      	mov	r0, r5
#endif /* REGION_EU868 */
}
 8037b18:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 8037b1c:	4718      	bx	r3
 8037b1e:	bf00      	nop
 8037b20:	20005728 	.word	0x20005728
 8037b24:	0803bc30 	.word	0x0803bc30

08037b28 <RegionEU868ApplyDrOffset>:

uint8_t RegionEU868ApplyDrOffset( uint8_t downlinkDwellTime, int8_t dr, int8_t drOffset )
{
#if defined( REGION_EU868 )
    int8_t datarate = dr - drOffset;
 8037b28:	1a88      	subs	r0, r1, r2
 8037b2a:	b240      	sxtb	r0, r0

    if( datarate < 0 )
    {
        datarate = DR_0;
    }
    return datarate;
 8037b2c:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
#else
    return 0;
#endif /* REGION_EU868 */
}
 8037b30:	b2c0      	uxtb	r0, r0
 8037b32:	4770      	bx	lr

08037b34 <GetTimeOnAir>:
    }
    return true;
}

static TimerTime_t GetTimeOnAir( int8_t datarate, uint16_t pktLen )
{
 8037b34:	b530      	push	{r4, r5, lr}
 8037b36:	460c      	mov	r4, r1
    int8_t phyDr = DataratesUS915[datarate];
 8037b38:	490a      	ldr	r1, [pc, #40]	; (8037b64 <GetTimeOnAir+0x30>)
{
 8037b3a:	b085      	sub	sp, #20
    int8_t phyDr = DataratesUS915[datarate];
 8037b3c:	560d      	ldrsb	r5, [r1, r0]
    uint32_t bandwidth = RegionCommonGetBandwidth( datarate, BandwidthsUS915 );
 8037b3e:	3110      	adds	r1, #16
 8037b40:	f7ff fa2c 	bl	8036f9c <RegionCommonGetBandwidth>

    return Radio.TimeOnAir( MODEM_LORA, bandwidth, phyDr, 1, 8, false, pktLen, true );
 8037b44:	2208      	movs	r2, #8
    uint32_t bandwidth = RegionCommonGetBandwidth( datarate, BandwidthsUS915 );
 8037b46:	4601      	mov	r1, r0
    return Radio.TimeOnAir( MODEM_LORA, bandwidth, phyDr, 1, 8, false, pktLen, true );
 8037b48:	2000      	movs	r0, #0
 8037b4a:	e9cd 2000 	strd	r2, r0, [sp]
 8037b4e:	4a06      	ldr	r2, [pc, #24]	; (8037b68 <GetTimeOnAir+0x34>)
 8037b50:	2301      	movs	r3, #1
 8037b52:	b2e4      	uxtb	r4, r4
 8037b54:	9402      	str	r4, [sp, #8]
 8037b56:	9303      	str	r3, [sp, #12]
 8037b58:	6a54      	ldr	r4, [r2, #36]	; 0x24
 8037b5a:	4618      	mov	r0, r3
 8037b5c:	462a      	mov	r2, r5
 8037b5e:	47a0      	blx	r4
}
 8037b60:	b005      	add	sp, #20
 8037b62:	bd30      	pop	{r4, r5, pc}
 8037b64:	0803bb58 	.word	0x0803bb58
 8037b68:	0803bc30 	.word	0x0803bc30

08037b6c <VerifyRfFreq>:
    if( Radio.CheckRfFrequency( freq ) == false )
 8037b6c:	4b0b      	ldr	r3, [pc, #44]	; (8037b9c <VerifyRfFreq+0x30>)
{
 8037b6e:	b510      	push	{r4, lr}
    if( Radio.CheckRfFrequency( freq ) == false )
 8037b70:	6a1b      	ldr	r3, [r3, #32]
{
 8037b72:	4604      	mov	r4, r0
    if( Radio.CheckRfFrequency( freq ) == false )
 8037b74:	4798      	blx	r3
 8037b76:	b168      	cbz	r0, 8037b94 <VerifyRfFreq+0x28>
    if( ( freq < US915_FIRST_RX1_CHANNEL ) ||
 8037b78:	4b09      	ldr	r3, [pc, #36]	; (8037ba0 <VerifyRfFreq+0x34>)
 8037b7a:	4a0a      	ldr	r2, [pc, #40]	; (8037ba4 <VerifyRfFreq+0x38>)
 8037b7c:	4423      	add	r3, r4
 8037b7e:	4293      	cmp	r3, r2
 8037b80:	d809      	bhi.n	8037b96 <VerifyRfFreq+0x2a>
        ( freq > US915_LAST_RX1_CHANNEL ) ||
 8037b82:	4a09      	ldr	r2, [pc, #36]	; (8037ba8 <VerifyRfFreq+0x3c>)
 8037b84:	4353      	muls	r3, r2
 8037b86:	f641 32f6 	movw	r2, #7158	; 0x1bf6
 8037b8a:	ebb2 1fb3 	cmp.w	r2, r3, ror #6
 8037b8e:	bf2c      	ite	cs
 8037b90:	2001      	movcs	r0, #1
 8037b92:	2000      	movcc	r0, #0
}
 8037b94:	bd10      	pop	{r4, pc}
        return false;
 8037b96:	2000      	movs	r0, #0
 8037b98:	e7fc      	b.n	8037b94 <VerifyRfFreq+0x28>
 8037b9a:	bf00      	nop
 8037b9c:	0803bc30 	.word	0x0803bc30
 8037ba0:	c8f78f60 	.word	0xc8f78f60
 8037ba4:	00401640 	.word	0x00401640
 8037ba8:	5943f75f 	.word	0x5943f75f

08037bac <RegionUS915GetPhyParam>:
#endif /* REGION_US915 */

PhyParam_t RegionUS915GetPhyParam( GetPhyParams_t* getPhy )
{
 8037bac:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    PhyParam_t phyParam = { 0 };
 8037bae:	2300      	movs	r3, #0
 8037bb0:	9300      	str	r3, [sp, #0]

#if defined( REGION_US915 )
    switch( getPhy->Attribute )
 8037bb2:	7803      	ldrb	r3, [r0, #0]
 8037bb4:	3b01      	subs	r3, #1
 8037bb6:	2b38      	cmp	r3, #56	; 0x38
 8037bb8:	d875      	bhi.n	8037ca6 <RegionUS915GetPhyParam+0xfa>
 8037bba:	e8df f003 	tbb	[pc, r3]
 8037bbe:	741d      	.short	0x741d
 8037bc0:	74747474 	.word	0x74747474
 8037bc4:	74747474 	.word	0x74747474
 8037bc8:	40393735 	.word	0x40393735
 8037bcc:	4d4a4774 	.word	0x4d4a4774
 8037bd0:	59565350 	.word	0x59565350
 8037bd4:	631d6174 	.word	0x631d6174
 8037bd8:	746f6d68 	.word	0x746f6d68
 8037bdc:	20787274 	.word	0x20787274
 8037be0:	74747474 	.word	0x74747474
 8037be4:	74747474 	.word	0x74747474
 8037be8:	74747474 	.word	0x74747474
 8037bec:	1d807a74 	.word	0x1d807a74
 8037bf0:	1d7a741d 	.word	0x1d7a741d
 8037bf4:	881d      	.short	0x881d
 8037bf6:	8d          	.byte	0x8d
 8037bf7:	00          	.byte	0x00
    {
        case PHY_MIN_RX_DR:
        {
            phyParam.Value = US915_RX_MIN_DATARATE;
 8037bf8:	2308      	movs	r3, #8
            phyParam.Value = US915_BEACON_NB_CHANNELS;
            break;
        }
        case PHY_SF_FROM_DR:
        {
            phyParam.Value = DataratesUS915[getPhy->Datarate];
 8037bfa:	9300      	str	r3, [sp, #0]
            break;
 8037bfc:	e053      	b.n	8037ca6 <RegionUS915GetPhyParam+0xfa>
            RegionCommonGetNextLowerTxDrParams_t nextLowerTxDrParams =
 8037bfe:	7843      	ldrb	r3, [r0, #1]
 8037c00:	f88d 3004 	strb.w	r3, [sp, #4]
 8037c04:	2304      	movs	r3, #4
 8037c06:	f88d 3005 	strb.w	r3, [sp, #5]
 8037c0a:	f44f 4390 	mov.w	r3, #18432	; 0x4800
 8037c0e:	f8ad 3006 	strh.w	r3, [sp, #6]
                .ChannelsMask = RegionNvmGroup2->ChannelsMask,
 8037c12:	4b34      	ldr	r3, [pc, #208]	; (8037ce4 <RegionUS915GetPhyParam+0x138>)
 8037c14:	681b      	ldr	r3, [r3, #0]
            phyParam.Value = RegionCommonGetNextLowerTxDr( &nextLowerTxDrParams );
 8037c16:	a801      	add	r0, sp, #4
                .ChannelsMask = RegionNvmGroup2->ChannelsMask,
 8037c18:	f503 7258 	add.w	r2, r3, #864	; 0x360
            RegionCommonGetNextLowerTxDrParams_t nextLowerTxDrParams =
 8037c1c:	e9cd 2302 	strd	r2, r3, [sp, #8]
            phyParam.Value = RegionCommonGetNextLowerTxDr( &nextLowerTxDrParams );
 8037c20:	f7ff f99d 	bl	8036f5e <RegionCommonGetNextLowerTxDr>
        }
        case PHY_BW_FROM_DR:
        {
            phyParam.Value = RegionCommonGetBandwidth( getPhy->Datarate, BandwidthsUS915 );
 8037c24:	9000      	str	r0, [sp, #0]
            break;
 8037c26:	e03e      	b.n	8037ca6 <RegionUS915GetPhyParam+0xfa>
            phyParam.Value = REGION_COMMON_DEFAULT_ADR_ACK_LIMIT;
 8037c28:	2340      	movs	r3, #64	; 0x40
 8037c2a:	e7e6      	b.n	8037bfa <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = REGION_COMMON_DEFAULT_ADR_ACK_DELAY;
 8037c2c:	2320      	movs	r3, #32
 8037c2e:	e7e4      	b.n	8037bfa <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = MaxPayloadOfDatarateUS915[getPhy->Datarate];
 8037c30:	f990 2001 	ldrsb.w	r2, [r0, #1]
 8037c34:	4b2c      	ldr	r3, [pc, #176]	; (8037ce8 <RegionUS915GetPhyParam+0x13c>)
 8037c36:	4413      	add	r3, r2
 8037c38:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 8037c3c:	e7dd      	b.n	8037bfa <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = MaxPayloadOfDatarateRepeaterUS915[getPhy->Datarate];
 8037c3e:	f990 2001 	ldrsb.w	r2, [r0, #1]
 8037c42:	4b29      	ldr	r3, [pc, #164]	; (8037ce8 <RegionUS915GetPhyParam+0x13c>)
 8037c44:	4413      	add	r3, r2
 8037c46:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8037c4a:	e7d6      	b.n	8037bfa <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = US915_MAX_RX_WINDOW;
 8037c4c:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8037c50:	e7d3      	b.n	8037bfa <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = REGION_COMMON_DEFAULT_RECEIVE_DELAY1;
 8037c52:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8037c56:	e7d0      	b.n	8037bfa <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = REGION_COMMON_DEFAULT_RECEIVE_DELAY2;
 8037c58:	f44f 63fa 	mov.w	r3, #2000	; 0x7d0
 8037c5c:	e7cd      	b.n	8037bfa <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = REGION_COMMON_DEFAULT_JOIN_ACCEPT_DELAY1;
 8037c5e:	f241 3388 	movw	r3, #5000	; 0x1388
 8037c62:	e7ca      	b.n	8037bfa <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = REGION_COMMON_DEFAULT_JOIN_ACCEPT_DELAY2;
 8037c64:	f241 7370 	movw	r3, #6000	; 0x1770
 8037c68:	e7c7      	b.n	8037bfa <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = REGION_COMMON_DEFAULT_MAX_FCNT_GAP;
 8037c6a:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8037c6e:	e7c4      	b.n	8037bfa <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = ( REGION_COMMON_DEFAULT_ACK_TIMEOUT + randr( -REGION_COMMON_DEFAULT_ACK_TIMEOUT_RND, REGION_COMMON_DEFAULT_ACK_TIMEOUT_RND ) );
 8037c70:	481e      	ldr	r0, [pc, #120]	; (8037cec <RegionUS915GetPhyParam+0x140>)
 8037c72:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8037c76:	f001 f93f 	bl	8038ef8 <randr>
 8037c7a:	f500 60fa 	add.w	r0, r0, #2000	; 0x7d0
 8037c7e:	e7d1      	b.n	8037c24 <RegionUS915GetPhyParam+0x78>
            phyParam.Value = US915_RX_WND_2_FREQ;
 8037c80:	4b1b      	ldr	r3, [pc, #108]	; (8037cf0 <RegionUS915GetPhyParam+0x144>)
 8037c82:	e7ba      	b.n	8037bfa <RegionUS915GetPhyParam+0x4e>
            phyParam.ChannelsMask = RegionNvmGroup2->ChannelsMask;
 8037c84:	4b17      	ldr	r3, [pc, #92]	; (8037ce4 <RegionUS915GetPhyParam+0x138>)
 8037c86:	681b      	ldr	r3, [r3, #0]
 8037c88:	f503 7358 	add.w	r3, r3, #864	; 0x360
 8037c8c:	e7b5      	b.n	8037bfa <RegionUS915GetPhyParam+0x4e>
            phyParam.ChannelsMask = RegionNvmGroup2->ChannelsDefaultMask;
 8037c8e:	4b15      	ldr	r3, [pc, #84]	; (8037ce4 <RegionUS915GetPhyParam+0x138>)
 8037c90:	681b      	ldr	r3, [r3, #0]
 8037c92:	f503 735b 	add.w	r3, r3, #876	; 0x36c
 8037c96:	e7b0      	b.n	8037bfa <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = US915_MAX_NB_CHANNELS;
 8037c98:	2348      	movs	r3, #72	; 0x48
 8037c9a:	e7ae      	b.n	8037bfa <RegionUS915GetPhyParam+0x4e>
            phyParam.Channels = RegionNvmGroup2->Channels;
 8037c9c:	4b11      	ldr	r3, [pc, #68]	; (8037ce4 <RegionUS915GetPhyParam+0x138>)
 8037c9e:	681b      	ldr	r3, [r3, #0]
 8037ca0:	e7ab      	b.n	8037bfa <RegionUS915GetPhyParam+0x4e>
            phyParam.fValue = US915_DEFAULT_MAX_ERP + 2.15f;
 8037ca2:	4b14      	ldr	r3, [pc, #80]	; (8037cf4 <RegionUS915GetPhyParam+0x148>)
            phyParam.fValue = 0;
 8037ca4:	9300      	str	r3, [sp, #0]
        }
    }

#endif /* REGION_US915 */
    return phyParam;
}
 8037ca6:	9800      	ldr	r0, [sp, #0]
 8037ca8:	b005      	add	sp, #20
 8037caa:	f85d fb04 	ldr.w	pc, [sp], #4
            phyParam.fValue = 0;
 8037cae:	2300      	movs	r3, #0
 8037cb0:	e7f8      	b.n	8037ca4 <RegionUS915GetPhyParam+0xf8>
            phyParam.Value = RegionBaseUSCalcDownlinkFrequency( getPhy->Channel,
 8037cb2:	4a11      	ldr	r2, [pc, #68]	; (8037cf8 <RegionUS915GetPhyParam+0x14c>)
 8037cb4:	490e      	ldr	r1, [pc, #56]	; (8037cf0 <RegionUS915GetPhyParam+0x144>)
 8037cb6:	7900      	ldrb	r0, [r0, #4]
 8037cb8:	f7fe fe7a 	bl	80369b0 <RegionBaseUSCalcDownlinkFrequency>
 8037cbc:	e7b2      	b.n	8037c24 <RegionUS915GetPhyParam+0x78>
            phyParam.BeaconFormat.BeaconSize = US915_BEACON_SIZE;
 8037cbe:	f240 5317 	movw	r3, #1303	; 0x517
 8037cc2:	f8ad 3000 	strh.w	r3, [sp]
            phyParam.BeaconFormat.Rfu2Size = US915_RFU2_SIZE;
 8037cc6:	2303      	movs	r3, #3
 8037cc8:	f88d 3002 	strb.w	r3, [sp, #2]
            break;
 8037ccc:	e7eb      	b.n	8037ca6 <RegionUS915GetPhyParam+0xfa>
            phyParam.Value = DataratesUS915[getPhy->Datarate];
 8037cce:	f990 3001 	ldrsb.w	r3, [r0, #1]
 8037cd2:	4a05      	ldr	r2, [pc, #20]	; (8037ce8 <RegionUS915GetPhyParam+0x13c>)
 8037cd4:	5cd3      	ldrb	r3, [r2, r3]
 8037cd6:	e790      	b.n	8037bfa <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = RegionCommonGetBandwidth( getPhy->Datarate, BandwidthsUS915 );
 8037cd8:	4908      	ldr	r1, [pc, #32]	; (8037cfc <RegionUS915GetPhyParam+0x150>)
 8037cda:	f990 0001 	ldrsb.w	r0, [r0, #1]
 8037cde:	f7ff f95d 	bl	8036f9c <RegionCommonGetBandwidth>
 8037ce2:	e79f      	b.n	8037c24 <RegionUS915GetPhyParam+0x78>
 8037ce4:	20005730 	.word	0x20005730
 8037ce8:	0803bb58 	.word	0x0803bb58
 8037cec:	fffffc18 	.word	0xfffffc18
 8037cf0:	370870a0 	.word	0x370870a0
 8037cf4:	4200999a 	.word	0x4200999a
 8037cf8:	000927c0 	.word	0x000927c0
 8037cfc:	0803bb68 	.word	0x0803bb68

08037d00 <RegionUS915SetBandTxDone>:

void RegionUS915SetBandTxDone( SetBandTxDoneParams_t* txDone )
{
 8037d00:	b537      	push	{r0, r1, r2, r4, r5, lr}
#if defined( REGION_US915 )
    RegionCommonSetBandTxDone( &RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txDone->Channel].Band],
 8037d02:	4a0a      	ldr	r2, [pc, #40]	; (8037d2c <RegionUS915SetBandTxDone+0x2c>)
 8037d04:	7803      	ldrb	r3, [r0, #0]
 8037d06:	6811      	ldr	r1, [r2, #0]
 8037d08:	6855      	ldr	r5, [r2, #4]
 8037d0a:	240c      	movs	r4, #12
 8037d0c:	fb04 1303 	mla	r3, r4, r3, r1
 8037d10:	7a5b      	ldrb	r3, [r3, #9]
 8037d12:	eb03 0443 	add.w	r4, r3, r3, lsl #1
 8037d16:	6903      	ldr	r3, [r0, #16]
 8037d18:	9300      	str	r3, [sp, #0]
 8037d1a:	68c3      	ldr	r3, [r0, #12]
 8037d1c:	7842      	ldrb	r2, [r0, #1]
 8037d1e:	6881      	ldr	r1, [r0, #8]
 8037d20:	eb05 00c4 	add.w	r0, r5, r4, lsl #3
 8037d24:	f7fe feca 	bl	8036abc <RegionCommonSetBandTxDone>
                               txDone->LastTxAirTime, txDone->Joined, txDone->ElapsedTimeSinceStartUp );
#endif /* REGION_US915 */
}
 8037d28:	b003      	add	sp, #12
 8037d2a:	bd30      	pop	{r4, r5, pc}
 8037d2c:	20005730 	.word	0x20005730

08037d30 <RegionUS915InitDefaults>:

void RegionUS915InitDefaults( InitDefaultsParams_t* params )
{
 8037d30:	b5f0      	push	{r4, r5, r6, r7, lr}
 8037d32:	b087      	sub	sp, #28
#if defined( REGION_US915 )
    Band_t bands[US915_MAX_NB_BANDS] =
 8037d34:	2301      	movs	r3, #1
    {
       US915_BAND0
    };

    switch( params->Type )
 8037d36:	7a04      	ldrb	r4, [r0, #8]
    Band_t bands[US915_MAX_NB_BANDS] =
 8037d38:	f8ad 3000 	strh.w	r3, [sp]
 8037d3c:	2300      	movs	r3, #0
 8037d3e:	e9cd 3301 	strd	r3, r3, [sp, #4]
 8037d42:	e9cd 3303 	strd	r3, r3, [sp, #12]
{
 8037d46:	4602      	mov	r2, r0
    Band_t bands[US915_MAX_NB_BANDS] =
 8037d48:	f88d 3002 	strb.w	r3, [sp, #2]
 8037d4c:	f88d 3014 	strb.w	r3, [sp, #20]
    switch( params->Type )
 8037d50:	b124      	cbz	r4, 8037d5c <RegionUS915InitDefaults+0x2c>
 8037d52:	3c01      	subs	r4, #1
 8037d54:	2c01      	cmp	r4, #1
 8037d56:	d94a      	bls.n	8037dee <RegionUS915InitDefaults+0xbe>
        {
            break;
        }
    }
#endif /* REGION_US915 */
}
 8037d58:	b007      	add	sp, #28
 8037d5a:	bdf0      	pop	{r4, r5, r6, r7, pc}
            if( ( params->NvmGroup1 == NULL ) || ( params->NvmGroup2 == NULL ) )
 8037d5c:	6800      	ldr	r0, [r0, #0]
 8037d5e:	2800      	cmp	r0, #0
 8037d60:	d0fa      	beq.n	8037d58 <RegionUS915InitDefaults+0x28>
 8037d62:	6853      	ldr	r3, [r2, #4]
 8037d64:	2b00      	cmp	r3, #0
 8037d66:	d0f7      	beq.n	8037d58 <RegionUS915InitDefaults+0x28>
            RegionNvmGroup1 = (RegionNvmDataGroup1_t*) params->NvmGroup1;
 8037d68:	4d2d      	ldr	r5, [pc, #180]	; (8037e20 <RegionUS915InitDefaults+0xf0>)
            RegionNvmGroup1->JoinChannelGroupsCurrentIndex = 0;
 8037d6a:	f8a0 409c 	strh.w	r4, [r0, #156]	; 0x9c
            memcpy1( ( uint8_t* )RegionNvmGroup1->Bands, ( uint8_t* )bands, sizeof( Band_t ) * US915_MAX_NB_BANDS );
 8037d6e:	2218      	movs	r2, #24
 8037d70:	4669      	mov	r1, sp
            RegionNvmGroup2 = (RegionNvmDataGroup2_t*) params->NvmGroup2;
 8037d72:	e9c5 3000 	strd	r3, r0, [r5]
            memcpy1( ( uint8_t* )RegionNvmGroup1->Bands, ( uint8_t* )bands, sizeof( Band_t ) * US915_MAX_NB_BANDS );
 8037d76:	f001 f8db 	bl	8038f30 <memcpy1>
                RegionNvmGroup2->Channels[i].Frequency = 902300000 + i * 200000;
 8037d7a:	6828      	ldr	r0, [r5, #0]
 8037d7c:	4b29      	ldr	r3, [pc, #164]	; (8037e24 <RegionUS915InitDefaults+0xf4>)
            for( uint8_t i = 0; i < US915_MAX_NB_CHANNELS - 8; i++ )
 8037d7e:	4e2a      	ldr	r6, [pc, #168]	; (8037e28 <RegionUS915InitDefaults+0xf8>)
 8037d80:	4602      	mov	r2, r0
                RegionNvmGroup2->Channels[i].Frequency = 902300000 + i * 200000;
 8037d82:	4601      	mov	r1, r0
                RegionNvmGroup2->Channels[i].DrRange.Value = ( DR_3 << 4 ) | DR_0;
 8037d84:	2730      	movs	r7, #48	; 0x30
                RegionNvmGroup2->Channels[i].Frequency = 902300000 + i * 200000;
 8037d86:	600b      	str	r3, [r1, #0]
                RegionNvmGroup2->Channels[i].DrRange.Value = ( DR_3 << 4 ) | DR_0;
 8037d88:	f503 3343 	add.w	r3, r3, #199680	; 0x30c00
 8037d8c:	f503 73a0 	add.w	r3, r3, #320	; 0x140
            for( uint8_t i = 0; i < US915_MAX_NB_CHANNELS - 8; i++ )
 8037d90:	42b3      	cmp	r3, r6
                RegionNvmGroup2->Channels[i].DrRange.Value = ( DR_3 << 4 ) | DR_0;
 8037d92:	720f      	strb	r7, [r1, #8]
                RegionNvmGroup2->Channels[i].Band = 0;
 8037d94:	724c      	strb	r4, [r1, #9]
            for( uint8_t i = 0; i < US915_MAX_NB_CHANNELS - 8; i++ )
 8037d96:	f101 010c 	add.w	r1, r1, #12
 8037d9a:	d1f4      	bne.n	8037d86 <RegionUS915InitDefaults+0x56>
 8037d9c:	4b23      	ldr	r3, [pc, #140]	; (8037e2c <RegionUS915InitDefaults+0xfc>)
            for( uint8_t i = US915_MAX_NB_CHANNELS - 8; i < US915_MAX_NB_CHANNELS; i++ )
 8037d9e:	4924      	ldr	r1, [pc, #144]	; (8037e30 <RegionUS915InitDefaults+0x100>)
                RegionNvmGroup2->Channels[i].DrRange.Value = ( DR_4 << 4 ) | DR_4;
 8037da0:	2644      	movs	r6, #68	; 0x44
                RegionNvmGroup2->Channels[i].Band = 0;
 8037da2:	2400      	movs	r4, #0
                RegionNvmGroup2->Channels[i].Frequency = 903000000 + ( i - ( US915_MAX_NB_CHANNELS - 8 ) ) * 1600000;
 8037da4:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
                RegionNvmGroup2->Channels[i].DrRange.Value = ( DR_4 << 4 ) | DR_4;
 8037da8:	f503 13c3 	add.w	r3, r3, #1597440	; 0x186000
 8037dac:	f503 6320 	add.w	r3, r3, #2560	; 0xa00
            for( uint8_t i = US915_MAX_NB_CHANNELS - 8; i < US915_MAX_NB_CHANNELS; i++ )
 8037db0:	428b      	cmp	r3, r1
                RegionNvmGroup2->Channels[i].DrRange.Value = ( DR_4 << 4 ) | DR_4;
 8037db2:	f882 6308 	strb.w	r6, [r2, #776]	; 0x308
                RegionNvmGroup2->Channels[i].Band = 0;
 8037db6:	f882 4309 	strb.w	r4, [r2, #777]	; 0x309
            for( uint8_t i = US915_MAX_NB_CHANNELS - 8; i < US915_MAX_NB_CHANNELS; i++ )
 8037dba:	f102 020c 	add.w	r2, r2, #12
 8037dbe:	d1f1      	bne.n	8037da4 <RegionUS915InitDefaults+0x74>
            RegionNvmGroup2->ChannelsDefaultMask[0] = 0xFFFF;
 8037dc0:	f04f 33ff 	mov.w	r3, #4294967295
            RegionNvmGroup2->ChannelsDefaultMask[2] = 0xFFFF;
 8037dc4:	e9c0 33db 	strd	r3, r3, [r0, #876]	; 0x36c
            RegionNvmGroup2->ChannelsDefaultMask[4] = 0x00FF;
 8037dc8:	23ff      	movs	r3, #255	; 0xff
 8037dca:	f8c0 3374 	str.w	r3, [r0, #884]	; 0x374
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
 8037dce:	f500 715b 	add.w	r1, r0, #876	; 0x36c
 8037dd2:	2206      	movs	r2, #6
 8037dd4:	f500 7058 	add.w	r0, r0, #864	; 0x360
 8037dd8:	f7fe fe61 	bl	8036a9e <RegionCommonChanMaskCopy>
            RegionCommonChanMaskCopy( RegionNvmGroup1->ChannelsMaskRemaining, RegionNvmGroup2->ChannelsMask, CHANNELS_MASK_SIZE );
 8037ddc:	e9d5 1000 	ldrd	r1, r0, [r5]
 8037de0:	2206      	movs	r2, #6
 8037de2:	f501 7158 	add.w	r1, r1, #864	; 0x360
 8037de6:	3090      	adds	r0, #144	; 0x90
 8037de8:	f7fe fe59 	bl	8036a9e <RegionCommonChanMaskCopy>
            break;
 8037dec:	e7b4      	b.n	8037d58 <RegionUS915InitDefaults+0x28>
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
 8037dee:	4c0c      	ldr	r4, [pc, #48]	; (8037e20 <RegionUS915InitDefaults+0xf0>)
 8037df0:	6820      	ldr	r0, [r4, #0]
 8037df2:	2206      	movs	r2, #6
 8037df4:	f500 715b 	add.w	r1, r0, #876	; 0x36c
 8037df8:	f500 7058 	add.w	r0, r0, #864	; 0x360
 8037dfc:	f7fe fe4f 	bl	8036a9e <RegionCommonChanMaskCopy>
                RegionNvmGroup1->ChannelsMaskRemaining[i] &= RegionNvmGroup2->ChannelsMask[i];
 8037e00:	6863      	ldr	r3, [r4, #4]
 8037e02:	6821      	ldr	r1, [r4, #0]
 8037e04:	f103 0290 	add.w	r2, r3, #144	; 0x90
 8037e08:	f501 7158 	add.w	r1, r1, #864	; 0x360
 8037e0c:	339c      	adds	r3, #156	; 0x9c
 8037e0e:	8810      	ldrh	r0, [r2, #0]
 8037e10:	f831 4b02 	ldrh.w	r4, [r1], #2
 8037e14:	4020      	ands	r0, r4
 8037e16:	f822 0b02 	strh.w	r0, [r2], #2
            for( uint8_t i = 0; i < CHANNELS_MASK_SIZE; i++ )
 8037e1a:	429a      	cmp	r2, r3
 8037e1c:	d1f7      	bne.n	8037e0e <RegionUS915InitDefaults+0xde>
 8037e1e:	e79b      	b.n	8037d58 <RegionUS915InitDefaults+0x28>
 8037e20:	20005730 	.word	0x20005730
 8037e24:	35c80160 	.word	0x35c80160
 8037e28:	368b5160 	.word	0x368b5160
 8037e2c:	35d2afc0 	.word	0x35d2afc0
 8037e30:	3695ffc0 	.word	0x3695ffc0

08037e34 <RegionUS915Verify>:

bool RegionUS915Verify( VerifyParams_t* verify, PhyAttribute_t phyAttribute )
{
 8037e34:	b508      	push	{r3, lr}
 8037e36:	290a      	cmp	r1, #10
 8037e38:	d81b      	bhi.n	8037e72 <RegionUS915Verify+0x3e>
 8037e3a:	e8df f001 	tbb	[pc, r1]
 8037e3e:	1a06      	.short	0x1a06
 8037e40:	0b1a1a1a 	.word	0x0b1a1a1a
 8037e44:	181a0e0b 	.word	0x181a0e0b
 8037e48:	18          	.byte	0x18
 8037e49:	00          	.byte	0x00
            return false;
    }
#else
    return false;
#endif /* REGION_US915 */
}
 8037e4a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            return VerifyRfFreq( verify->Frequency );
 8037e4e:	6800      	ldr	r0, [r0, #0]
 8037e50:	f7ff be8c 	b.w	8037b6c <VerifyRfFreq>
            return RegionCommonValueInRange( verify->DatarateParams.Datarate, US915_TX_MIN_DATARATE, US915_TX_MAX_DATARATE );
 8037e54:	2204      	movs	r2, #4
            return RegionCommonValueInRange( verify->TxPower, US915_MAX_TX_POWER, US915_MIN_TX_POWER );
 8037e56:	2100      	movs	r1, #0
 8037e58:	e001      	b.n	8037e5e <RegionUS915Verify+0x2a>
            return RegionCommonValueInRange( verify->DatarateParams.Datarate, US915_RX_MIN_DATARATE, US915_RX_MAX_DATARATE );
 8037e5a:	220d      	movs	r2, #13
 8037e5c:	2108      	movs	r1, #8
            return RegionCommonValueInRange( verify->TxPower, US915_MAX_TX_POWER, US915_MIN_TX_POWER );
 8037e5e:	f990 0000 	ldrsb.w	r0, [r0]
 8037e62:	f7fe fddc 	bl	8036a1e <RegionCommonValueInRange>
 8037e66:	3800      	subs	r0, #0
 8037e68:	bf18      	it	ne
 8037e6a:	2001      	movne	r0, #1
}
 8037e6c:	bd08      	pop	{r3, pc}
            return RegionCommonValueInRange( verify->TxPower, US915_MAX_TX_POWER, US915_MIN_TX_POWER );
 8037e6e:	220e      	movs	r2, #14
 8037e70:	e7f1      	b.n	8037e56 <RegionUS915Verify+0x22>
{
 8037e72:	2000      	movs	r0, #0
 8037e74:	e7fa      	b.n	8037e6c <RegionUS915Verify+0x38>
	...

08037e78 <RegionUS915ApplyCFList>:

void RegionUS915ApplyCFList( ApplyCFListParams_t* applyCFList )
{
 8037e78:	b5f0      	push	{r4, r5, r6, r7, lr}
#if defined( REGION_US915 )
    // Size of the optional CF list must be 16 byte
    if( applyCFList->Size != 16 )
 8037e7a:	7903      	ldrb	r3, [r0, #4]
 8037e7c:	2b10      	cmp	r3, #16
 8037e7e:	d122      	bne.n	8037ec6 <RegionUS915ApplyCFList+0x4e>
    {
        return;
    }

    // Last byte CFListType must be 0x01 to indicate the CFList contains a series of ChMask fields
    if( applyCFList->Payload[15] != 0x01 )
 8037e80:	6804      	ldr	r4, [r0, #0]
 8037e82:	7be3      	ldrb	r3, [r4, #15]
 8037e84:	2b01      	cmp	r3, #1
 8037e86:	d11e      	bne.n	8037ec6 <RegionUS915ApplyCFList+0x4e>
    }

    // ChMask0 - ChMask4 must be set (every ChMask has 16 bit)
    for( uint8_t chMaskItr = 0, cntPayload = 0; chMaskItr <= 4; chMaskItr++, cntPayload+=2 )
    {
        RegionNvmGroup2->ChannelsMask[chMaskItr] = (uint16_t) (0x00FF & applyCFList->Payload[cntPayload]);
 8037e88:	4b0f      	ldr	r3, [pc, #60]	; (8037ec8 <RegionUS915ApplyCFList+0x50>)
 8037e8a:	681d      	ldr	r5, [r3, #0]
 8037e8c:	6859      	ldr	r1, [r3, #4]
 8037e8e:	f505 7058 	add.w	r0, r5, #864	; 0x360
 8037e92:	3190      	adds	r1, #144	; 0x90
        if( chMaskItr == 4 )
        {
            RegionNvmGroup2->ChannelsMask[chMaskItr] = RegionNvmGroup2->ChannelsMask[chMaskItr] & CHANNELS_MASK_500KHZ_MASK;
        }
        // Set the channel mask to the remaining
        RegionNvmGroup1->ChannelsMaskRemaining[chMaskItr] &= RegionNvmGroup2->ChannelsMask[chMaskItr];
 8037e94:	2200      	movs	r2, #0
        RegionNvmGroup2->ChannelsMask[chMaskItr] |= (uint16_t) (applyCFList->Payload[cntPayload+1] << 8);
 8037e96:	1c67      	adds	r7, r4, #1
        RegionNvmGroup2->ChannelsMask[chMaskItr] = (uint16_t) (0x00FF & applyCFList->Payload[cntPayload]);
 8037e98:	f814 3012 	ldrb.w	r3, [r4, r2, lsl #1]
 8037e9c:	8003      	strh	r3, [r0, #0]
        RegionNvmGroup2->ChannelsMask[chMaskItr] |= (uint16_t) (applyCFList->Payload[cntPayload+1] << 8);
 8037e9e:	f817 6012 	ldrb.w	r6, [r7, r2, lsl #1]
        if( chMaskItr == 4 )
 8037ea2:	2a04      	cmp	r2, #4
        RegionNvmGroup2->ChannelsMask[chMaskItr] |= (uint16_t) (applyCFList->Payload[cntPayload+1] << 8);
 8037ea4:	ea43 2306 	orr.w	r3, r3, r6, lsl #8
 8037ea8:	f820 3b02 	strh.w	r3, [r0], #2
            RegionNvmGroup2->ChannelsMask[chMaskItr] = RegionNvmGroup2->ChannelsMask[chMaskItr] & CHANNELS_MASK_500KHZ_MASK;
 8037eac:	bf04      	itt	eq
 8037eae:	b2db      	uxtbeq	r3, r3
 8037eb0:	f8a5 3368 	strheq.w	r3, [r5, #872]	; 0x368
        RegionNvmGroup1->ChannelsMaskRemaining[chMaskItr] &= RegionNvmGroup2->ChannelsMask[chMaskItr];
 8037eb4:	880b      	ldrh	r3, [r1, #0]
 8037eb6:	f830 6c02 	ldrh.w	r6, [r0, #-2]
 8037eba:	3201      	adds	r2, #1
 8037ebc:	4033      	ands	r3, r6
    for( uint8_t chMaskItr = 0, cntPayload = 0; chMaskItr <= 4; chMaskItr++, cntPayload+=2 )
 8037ebe:	2a05      	cmp	r2, #5
        RegionNvmGroup1->ChannelsMaskRemaining[chMaskItr] &= RegionNvmGroup2->ChannelsMask[chMaskItr];
 8037ec0:	f821 3b02 	strh.w	r3, [r1], #2
    for( uint8_t chMaskItr = 0, cntPayload = 0; chMaskItr <= 4; chMaskItr++, cntPayload+=2 )
 8037ec4:	d1e8      	bne.n	8037e98 <RegionUS915ApplyCFList+0x20>
    }
#endif /* REGION_US915 */
}
 8037ec6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8037ec8:	20005730 	.word	0x20005730

08037ecc <RegionUS915ChanMaskSet>:

bool RegionUS915ChanMaskSet( ChanMaskSetParams_t* chanMaskSet )
{
 8037ecc:	b570      	push	{r4, r5, r6, lr}
#if defined( REGION_US915 )
    uint8_t nbChannels = RegionCommonCountChannels( chanMaskSet->ChannelsMaskIn, 0, 4 );
 8037ece:	2204      	movs	r2, #4
{
 8037ed0:	4605      	mov	r5, r0
    uint8_t nbChannels = RegionCommonCountChannels( chanMaskSet->ChannelsMaskIn, 0, 4 );
 8037ed2:	2100      	movs	r1, #0
 8037ed4:	6800      	ldr	r0, [r0, #0]
 8037ed6:	f7fe fdc4 	bl	8036a62 <RegionCommonCountChannels>

    // Check the number of active channels
    if( ( nbChannels < 2 ) &&
 8037eda:	2801      	cmp	r0, #1
 8037edc:	d003      	beq.n	8037ee6 <RegionUS915ChanMaskSet+0x1a>
        ( nbChannels > 0 ) )
    {
        return false;
    }

    switch( chanMaskSet->ChannelsMaskType )
 8037ede:	792c      	ldrb	r4, [r5, #4]
 8037ee0:	b11c      	cbz	r4, 8037eea <RegionUS915ChanMaskSet+0x1e>
 8037ee2:	2c01      	cmp	r4, #1
 8037ee4:	d020      	beq.n	8037f28 <RegionUS915ChanMaskSet+0x5c>
        return false;
 8037ee6:	2000      	movs	r0, #0
 8037ee8:	e01d      	b.n	8037f26 <RegionUS915ChanMaskSet+0x5a>
    {
        case CHANNELS_MASK:
        {
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, chanMaskSet->ChannelsMaskIn, CHANNELS_MASK_SIZE );
 8037eea:	4e14      	ldr	r6, [pc, #80]	; (8037f3c <RegionUS915ChanMaskSet+0x70>)
 8037eec:	6829      	ldr	r1, [r5, #0]
 8037eee:	6830      	ldr	r0, [r6, #0]
 8037ef0:	2206      	movs	r2, #6
 8037ef2:	f500 7058 	add.w	r0, r0, #864	; 0x360
 8037ef6:	f7fe fdd2 	bl	8036a9e <RegionCommonChanMaskCopy>

            RegionNvmGroup2->ChannelsDefaultMask[4] = RegionNvmGroup2->ChannelsDefaultMask[4] & CHANNELS_MASK_500KHZ_MASK;
 8037efa:	6833      	ldr	r3, [r6, #0]
 8037efc:	f893 2374 	ldrb.w	r2, [r3, #884]	; 0x374
 8037f00:	f8a3 2374 	strh.w	r2, [r3, #884]	; 0x374
            RegionNvmGroup2->ChannelsDefaultMask[5] = 0x0000;

            for( uint8_t i = 0; i < CHANNELS_MASK_SIZE; i++ )
            { // Copy-And the channels mask
                RegionNvmGroup1->ChannelsMaskRemaining[i] &= RegionNvmGroup2->ChannelsMask[i];
 8037f04:	6872      	ldr	r2, [r6, #4]
            RegionNvmGroup2->ChannelsDefaultMask[5] = 0x0000;
 8037f06:	f8a3 4376 	strh.w	r4, [r3, #886]	; 0x376
            for( uint8_t i = 0; i < CHANNELS_MASK_SIZE; i++ )
 8037f0a:	f102 0190 	add.w	r1, r2, #144	; 0x90
 8037f0e:	f503 7358 	add.w	r3, r3, #864	; 0x360
 8037f12:	329c      	adds	r2, #156	; 0x9c
                RegionNvmGroup1->ChannelsMaskRemaining[i] &= RegionNvmGroup2->ChannelsMask[i];
 8037f14:	8808      	ldrh	r0, [r1, #0]
 8037f16:	f833 4b02 	ldrh.w	r4, [r3], #2
 8037f1a:	4020      	ands	r0, r4
 8037f1c:	f821 0b02 	strh.w	r0, [r1], #2
            for( uint8_t i = 0; i < CHANNELS_MASK_SIZE; i++ )
 8037f20:	4291      	cmp	r1, r2
 8037f22:	d1f7      	bne.n	8037f14 <RegionUS915ChanMaskSet+0x48>
            break;
        }
        default:
            return false;
    }
    return true;
 8037f24:	2001      	movs	r0, #1
#else
    return false;
#endif /* REGION_US915 */
}
 8037f26:	bd70      	pop	{r4, r5, r6, pc}
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsDefaultMask, chanMaskSet->ChannelsMaskIn, CHANNELS_MASK_SIZE );
 8037f28:	4b04      	ldr	r3, [pc, #16]	; (8037f3c <RegionUS915ChanMaskSet+0x70>)
 8037f2a:	6829      	ldr	r1, [r5, #0]
 8037f2c:	6818      	ldr	r0, [r3, #0]
 8037f2e:	2206      	movs	r2, #6
 8037f30:	f500 705b 	add.w	r0, r0, #876	; 0x36c
 8037f34:	f7fe fdb3 	bl	8036a9e <RegionCommonChanMaskCopy>
            break;
 8037f38:	e7f4      	b.n	8037f24 <RegionUS915ChanMaskSet+0x58>
 8037f3a:	bf00      	nop
 8037f3c:	20005730 	.word	0x20005730

08037f40 <RegionUS915ComputeRxWindowParameters>:

void RegionUS915ComputeRxWindowParameters( int8_t datarate, uint8_t minRxSymbols, uint32_t rxError, RxConfigParams_t *rxConfigParams )
{
 8037f40:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
#if defined( REGION_US915 )
    uint32_t tSymbolInUs = 0;

    // Get the datarate, perform a boundary check
    rxConfigParams->Datarate = MIN( datarate, US915_RX_MAX_DATARATE );
 8037f42:	280d      	cmp	r0, #13
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsUS915 );
 8037f44:	4d12      	ldr	r5, [pc, #72]	; (8037f90 <RegionUS915ComputeRxWindowParameters+0x50>)
    rxConfigParams->Datarate = MIN( datarate, US915_RX_MAX_DATARATE );
 8037f46:	bfa8      	it	ge
 8037f48:	200d      	movge	r0, #13
{
 8037f4a:	461c      	mov	r4, r3
 8037f4c:	460e      	mov	r6, r1
    rxConfigParams->Datarate = MIN( datarate, US915_RX_MAX_DATARATE );
 8037f4e:	7058      	strb	r0, [r3, #1]
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsUS915 );
 8037f50:	f105 0110 	add.w	r1, r5, #16
{
 8037f54:	4617      	mov	r7, r2
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsUS915 );
 8037f56:	f7ff f821 	bl	8036f9c <RegionCommonGetBandwidth>

    tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesUS915[rxConfigParams->Datarate], BandwidthsUS915[rxConfigParams->Datarate] );
 8037f5a:	f994 3001 	ldrsb.w	r3, [r4, #1]
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsUS915 );
 8037f5e:	70a0      	strb	r0, [r4, #2]
    tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesUS915[rxConfigParams->Datarate], BandwidthsUS915[rxConfigParams->Datarate] );
 8037f60:	eb05 0283 	add.w	r2, r5, r3, lsl #2
 8037f64:	5ce8      	ldrb	r0, [r5, r3]
 8037f66:	6911      	ldr	r1, [r2, #16]
 8037f68:	f7fe ff14 	bl	8036d94 <RegionCommonComputeSymbolTimeLoRa>

    RegionCommonComputeRxWindowParameters( tSymbolInUs, minRxSymbols, rxError, Radio.GetWakeupTime( ), &rxConfigParams->WindowTimeout, &rxConfigParams->WindowOffset );
 8037f6c:	4b09      	ldr	r3, [pc, #36]	; (8037f94 <RegionUS915ComputeRxWindowParameters+0x54>)
 8037f6e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesUS915[rxConfigParams->Datarate], BandwidthsUS915[rxConfigParams->Datarate] );
 8037f70:	4605      	mov	r5, r0
    RegionCommonComputeRxWindowParameters( tSymbolInUs, minRxSymbols, rxError, Radio.GetWakeupTime( ), &rxConfigParams->WindowTimeout, &rxConfigParams->WindowOffset );
 8037f72:	4798      	blx	r3
 8037f74:	f104 020c 	add.w	r2, r4, #12
 8037f78:	3408      	adds	r4, #8
 8037f7a:	4603      	mov	r3, r0
 8037f7c:	9201      	str	r2, [sp, #4]
 8037f7e:	9400      	str	r4, [sp, #0]
 8037f80:	463a      	mov	r2, r7
 8037f82:	4631      	mov	r1, r6
 8037f84:	4628      	mov	r0, r5
 8037f86:	f7fe ff12 	bl	8036dae <RegionCommonComputeRxWindowParameters>
#endif /* REGION_US915 */
}
 8037f8a:	b003      	add	sp, #12
 8037f8c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8037f8e:	bf00      	nop
 8037f90:	0803bb58 	.word	0x0803bb58
 8037f94:	0803bc30 	.word	0x0803bc30

08037f98 <RegionUS915RxConfig>:

bool RegionUS915RxConfig( RxConfigParams_t* rxConfig, int8_t* datarate )
{
 8037f98:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int8_t dr = rxConfig->Datarate;
    uint8_t maxPayload = 0;
    int8_t phyDr = 0;
    uint32_t frequency = rxConfig->Frequency;

    if( Radio.GetStatus( ) != RF_IDLE )
 8037f9c:	4e24      	ldr	r6, [pc, #144]	; (8038030 <RegionUS915RxConfig+0x98>)
    int8_t dr = rxConfig->Datarate;
 8037f9e:	f990 9001 	ldrsb.w	r9, [r0, #1]
    if( Radio.GetStatus( ) != RF_IDLE )
 8037fa2:	6873      	ldr	r3, [r6, #4]
    uint32_t frequency = rxConfig->Frequency;
 8037fa4:	6845      	ldr	r5, [r0, #4]
{
 8037fa6:	b08b      	sub	sp, #44	; 0x2c
 8037fa8:	4604      	mov	r4, r0
 8037faa:	468a      	mov	sl, r1
    if( Radio.GetStatus( ) != RF_IDLE )
 8037fac:	4798      	blx	r3
 8037fae:	2800      	cmp	r0, #0
 8037fb0:	d13c      	bne.n	803802c <RegionUS915RxConfig+0x94>
    {
        return false;
    }

    if( rxConfig->RxSlot == RX_SLOT_WIN_1 )
 8037fb2:	7ce3      	ldrb	r3, [r4, #19]
 8037fb4:	b933      	cbnz	r3, 8037fc4 <RegionUS915RxConfig+0x2c>
    {
        // Apply window 1 frequency
        frequency = US915_FIRST_RX1_CHANNEL + ( rxConfig->Channel % 8 ) * US915_STEPWIDTH_RX1_CHANNEL;
 8037fb6:	7825      	ldrb	r5, [r4, #0]
 8037fb8:	4a1e      	ldr	r2, [pc, #120]	; (8038034 <RegionUS915RxConfig+0x9c>)
 8037fba:	4b1f      	ldr	r3, [pc, #124]	; (8038038 <RegionUS915RxConfig+0xa0>)
 8037fbc:	f005 0507 	and.w	r5, r5, #7
 8037fc0:	fb02 3505 	mla	r5, r2, r5, r3
    }

    // Read the physical datarate from the datarates table
    phyDr = DataratesUS915[dr];
 8037fc4:	f8df 8074 	ldr.w	r8, [pc, #116]	; 803803c <RegionUS915RxConfig+0xa4>

    Radio.SetChannel( frequency );
 8037fc8:	68f3      	ldr	r3, [r6, #12]
    phyDr = DataratesUS915[dr];
 8037fca:	f918 b009 	ldrsb.w	fp, [r8, r9]
    Radio.SetChannel( frequency );
 8037fce:	4628      	mov	r0, r5
 8037fd0:	4798      	blx	r3

    // Radio configuration
    Radio.SetRxConfig( MODEM_LORA, rxConfig->Bandwidth, phyDr, 1, 0, 8, rxConfig->WindowTimeout, false, 0, false, 0, 0, true, rxConfig->RxContinuous );
 8037fd2:	8922      	ldrh	r2, [r4, #8]
 8037fd4:	9202      	str	r2, [sp, #8]
 8037fd6:	2000      	movs	r0, #0
 8037fd8:	2208      	movs	r2, #8
 8037fda:	e9cd 0200 	strd	r0, r2, [sp]
 8037fde:	7ca3      	ldrb	r3, [r4, #18]
 8037fe0:	69b2      	ldr	r2, [r6, #24]
 8037fe2:	9309      	str	r3, [sp, #36]	; 0x24
 8037fe4:	2301      	movs	r3, #1
 8037fe6:	e9cd 0307 	strd	r0, r3, [sp, #28]
 8037fea:	e9cd 0005 	strd	r0, r0, [sp, #20]
 8037fee:	e9cd 0003 	strd	r0, r0, [sp, #12]
 8037ff2:	4617      	mov	r7, r2
 8037ff4:	4618      	mov	r0, r3
 8037ff6:	78a1      	ldrb	r1, [r4, #2]
 8037ff8:	465a      	mov	r2, fp
 8037ffa:	47b8      	blx	r7

    /* ST_WORKAROUND_BEGIN: Keep repeater feature */
    if( rxConfig->RepeaterSupport == true )
 8037ffc:	7c63      	ldrb	r3, [r4, #17]
 8037ffe:	44c8      	add	r8, r9
 8038000:	b18b      	cbz	r3, 8038026 <RegionUS915RxConfig+0x8e>
    {
        maxPayload = MaxPayloadOfDatarateRepeaterUS915[dr];
 8038002:	f898 1060 	ldrb.w	r1, [r8, #96]	; 0x60
    else
    {
        maxPayload = MaxPayloadOfDatarateUS915[dr];
    }

    Radio.SetMaxPayloadLength( MODEM_LORA, maxPayload + LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE );
 8038006:	6d73      	ldr	r3, [r6, #84]	; 0x54
 8038008:	310d      	adds	r1, #13
 803800a:	b2c9      	uxtb	r1, r1
 803800c:	2001      	movs	r0, #1
 803800e:	4798      	blx	r3
    /* ST_WORKAROUND_END */

    /* ST_WORKAROUND_BEGIN: Print Rx config */
    RegionCommonRxConfigPrint(rxConfig->RxSlot, frequency, dr);
 8038010:	7ce0      	ldrb	r0, [r4, #19]
 8038012:	464a      	mov	r2, r9
 8038014:	4629      	mov	r1, r5
 8038016:	f7fe ffd3 	bl	8036fc0 <RegionCommonRxConfigPrint>
    /* ST_WORKAROUND_END */

    *datarate = (uint8_t) dr;
 803801a:	f88a 9000 	strb.w	r9, [sl]
    return true;
 803801e:	2001      	movs	r0, #1
#else
    return false;
#endif /* REGION_US915 */
}
 8038020:	b00b      	add	sp, #44	; 0x2c
 8038022:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        maxPayload = MaxPayloadOfDatarateUS915[dr];
 8038026:	f898 1050 	ldrb.w	r1, [r8, #80]	; 0x50
 803802a:	e7ec      	b.n	8038006 <RegionUS915RxConfig+0x6e>
        return false;
 803802c:	2000      	movs	r0, #0
 803802e:	e7f7      	b.n	8038020 <RegionUS915RxConfig+0x88>
 8038030:	0803bc30 	.word	0x0803bc30
 8038034:	000927c0 	.word	0x000927c0
 8038038:	370870a0 	.word	0x370870a0
 803803c:	0803bb58 	.word	0x0803bb58

08038040 <RegionUS915TxConfig>:

bool RegionUS915TxConfig( TxConfigParams_t* txConfig, int8_t* txPower, TimerTime_t* txTimeOnAir )
{
 8038040:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if defined( REGION_US915 )
    int8_t phyDr = DataratesUS915[txConfig->Datarate];
    int8_t txPowerLimited = LimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower, txConfig->Datarate, RegionNvmGroup2->ChannelsMask );
 8038044:	4e3d      	ldr	r6, [pc, #244]	; (803813c <RegionUS915TxConfig+0xfc>)
    int8_t phyDr = DataratesUS915[txConfig->Datarate];
 8038046:	f990 b001 	ldrsb.w	fp, [r0, #1]
 803804a:	4b3d      	ldr	r3, [pc, #244]	; (8038140 <RegionUS915TxConfig+0x100>)
    int8_t txPowerLimited = LimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower, txConfig->Datarate, RegionNvmGroup2->ChannelsMask );
 803804c:	f990 8002 	ldrsb.w	r8, [r0, #2]
    int8_t phyDr = DataratesUS915[txConfig->Datarate];
 8038050:	f913 700b 	ldrsb.w	r7, [r3, fp]
    int8_t txPowerLimited = LimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower, txConfig->Datarate, RegionNvmGroup2->ChannelsMask );
 8038054:	7803      	ldrb	r3, [r0, #0]
{
 8038056:	b08f      	sub	sp, #60	; 0x3c
 8038058:	4692      	mov	sl, r2
    int8_t txPowerLimited = LimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower, txConfig->Datarate, RegionNvmGroup2->ChannelsMask );
 803805a:	e9d6 9200 	ldrd	r9, r2, [r6]
{
 803805e:	910b      	str	r1, [sp, #44]	; 0x2c
    int8_t txPowerLimited = LimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower, txConfig->Datarate, RegionNvmGroup2->ChannelsMask );
 8038060:	210c      	movs	r1, #12
 8038062:	fb01 9303 	mla	r3, r1, r3, r9
 8038066:	2118      	movs	r1, #24
 8038068:	7a5b      	ldrb	r3, [r3, #9]
 803806a:	fb01 2303 	mla	r3, r1, r3, r2
{
 803806e:	4604      	mov	r4, r0
    txPowerResult =  RegionCommonLimitTxPower( txPower, maxBandTxPower );
 8038070:	f993 1002 	ldrsb.w	r1, [r3, #2]
 8038074:	4640      	mov	r0, r8
 8038076:	f7fe ff8d 	bl	8036f94 <RegionCommonLimitTxPower>
    if( datarate == DR_4 )
 803807a:	f1bb 0f04 	cmp.w	fp, #4
    txPowerResult =  RegionCommonLimitTxPower( txPower, maxBandTxPower );
 803807e:	4605      	mov	r5, r0
    if( datarate == DR_4 )
 8038080:	d14e      	bne.n	8038120 <RegionUS915TxConfig+0xe0>
        txPowerResult = MAX( txPower, TX_POWER_2 );
 8038082:	4645      	mov	r5, r8
 8038084:	2d02      	cmp	r5, #2
 8038086:	bfb8      	it	lt
 8038088:	2502      	movlt	r5, #2
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsUS915 );
 803808a:	492e      	ldr	r1, [pc, #184]	; (8038144 <RegionUS915TxConfig+0x104>)
 803808c:	f994 0001 	ldrsb.w	r0, [r4, #1]

    // Calculate physical TX power
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );

    // Setup the radio frequency
    Radio.SetChannel( RegionNvmGroup2->Channels[txConfig->Channel].Frequency );
 8038090:	f8df b0b8 	ldr.w	fp, [pc, #184]	; 803814c <RegionUS915TxConfig+0x10c>
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsUS915 );
 8038094:	f7fe ff82 	bl	8036f9c <RegionCommonGetBandwidth>
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );
 8038098:	492b      	ldr	r1, [pc, #172]	; (8038148 <RegionUS915TxConfig+0x108>)
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsUS915 );
 803809a:	900d      	str	r0, [sp, #52]	; 0x34
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );
 803809c:	2200      	movs	r2, #0
 803809e:	4628      	mov	r0, r5
 80380a0:	f7fe fead 	bl	8036dfe <RegionCommonComputeTxPower>
    Radio.SetChannel( RegionNvmGroup2->Channels[txConfig->Channel].Frequency );
 80380a4:	f894 c000 	ldrb.w	ip, [r4]
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );
 80380a8:	900c      	str	r0, [sp, #48]	; 0x30
    Radio.SetChannel( RegionNvmGroup2->Channels[txConfig->Channel].Frequency );
 80380aa:	f04f 090c 	mov.w	r9, #12
 80380ae:	fb09 fc0c 	mul.w	ip, r9, ip
 80380b2:	6830      	ldr	r0, [r6, #0]
 80380b4:	f8db 200c 	ldr.w	r2, [fp, #12]
 80380b8:	f850 000c 	ldr.w	r0, [r0, ip]
 80380bc:	4790      	blx	r2

    Radio.SetTxConfig( MODEM_LORA, phyTxPower, 0, bandwidth, phyDr, 1, 8, false, true, 0, 0, false, 4000 );
 80380be:	f04f 0801 	mov.w	r8, #1
 80380c2:	2200      	movs	r2, #0
 80380c4:	f44f 637a 	mov.w	r3, #4000	; 0xfa0
 80380c8:	2008      	movs	r0, #8
 80380ca:	e9cd 2307 	strd	r2, r3, [sp, #28]
 80380ce:	e9cd 2205 	strd	r2, r2, [sp, #20]
 80380d2:	e9dd 130c 	ldrd	r1, r3, [sp, #48]	; 0x30
 80380d6:	e9cd 2803 	strd	r2, r8, [sp, #12]
 80380da:	e9cd 8001 	strd	r8, r0, [sp, #4]
 80380de:	9700      	str	r7, [sp, #0]
 80380e0:	4640      	mov	r0, r8
 80380e2:	f8db 701c 	ldr.w	r7, [fp, #28]
 80380e6:	47b8      	blx	r7
    /* ST_WORKAROUND_BEGIN: Print Tx config */
    RegionCommonTxConfigPrint(RegionNvmGroup2->Channels[txConfig->Channel].Frequency, txConfig->Datarate);
 80380e8:	7822      	ldrb	r2, [r4, #0]
 80380ea:	6833      	ldr	r3, [r6, #0]
 80380ec:	f994 1001 	ldrsb.w	r1, [r4, #1]
 80380f0:	fb09 f902 	mul.w	r9, r9, r2
 80380f4:	f853 0009 	ldr.w	r0, [r3, r9]
 80380f8:	f7fe ff90 	bl	803701c <RegionCommonTxConfigPrint>
    /* ST_WORKAROUND_END */

    // Setup maximum payload length of the radio driver
    Radio.SetMaxPayloadLength( MODEM_LORA, txConfig->PktLen );
 80380fc:	f8db 3054 	ldr.w	r3, [fp, #84]	; 0x54
 8038100:	7b21      	ldrb	r1, [r4, #12]
 8038102:	4640      	mov	r0, r8
 8038104:	4798      	blx	r3

    // Update time-on-air
    *txTimeOnAir = GetTimeOnAir( txConfig->Datarate, txConfig->PktLen );
 8038106:	89a1      	ldrh	r1, [r4, #12]
 8038108:	f994 0001 	ldrsb.w	r0, [r4, #1]
 803810c:	f7ff fd12 	bl	8037b34 <GetTimeOnAir>

    *txPower = txPowerLimited;
 8038110:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    *txTimeOnAir = GetTimeOnAir( txConfig->Datarate, txConfig->PktLen );
 8038112:	f8ca 0000 	str.w	r0, [sl]
    return true;
#else
    return false;
#endif /* REGION_US915 */
}
 8038116:	4640      	mov	r0, r8
    *txPower = txPowerLimited;
 8038118:	701d      	strb	r5, [r3, #0]
}
 803811a:	b00f      	add	sp, #60	; 0x3c
 803811c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if( RegionCommonCountChannels( channelsMask, 0, 4 ) < 50 )
 8038120:	2204      	movs	r2, #4
 8038122:	2100      	movs	r1, #0
 8038124:	f509 7058 	add.w	r0, r9, #864	; 0x360
 8038128:	f7fe fc9b 	bl	8036a62 <RegionCommonCountChannels>
 803812c:	2831      	cmp	r0, #49	; 0x31
 803812e:	d8ac      	bhi.n	803808a <RegionUS915TxConfig+0x4a>
            txPowerResult = MAX( txPower, TX_POWER_5 );
 8038130:	4645      	mov	r5, r8
 8038132:	2d05      	cmp	r5, #5
 8038134:	bfb8      	it	lt
 8038136:	2505      	movlt	r5, #5
 8038138:	e7a7      	b.n	803808a <RegionUS915TxConfig+0x4a>
 803813a:	bf00      	nop
 803813c:	20005730 	.word	0x20005730
 8038140:	0803bb58 	.word	0x0803bb58
 8038144:	0803bb68 	.word	0x0803bb68
 8038148:	41f00000 	.word	0x41f00000
 803814c:	0803bc30 	.word	0x0803bc30

08038150 <RegionUS915LinkAdrReq>:

uint8_t RegionUS915LinkAdrReq( LinkAdrReqParams_t* linkAdrReq, int8_t* drOut, int8_t* txPowOut, uint8_t* nbRepOut, uint8_t* nbBytesParsed )
{
 8038150:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;
    RegionCommonLinkAdrReqVerifyParams_t linkAdrVerifyParams;

    // Initialize local copy of channels mask
    RegionCommonChanMaskCopy( channelsMask, RegionNvmGroup2->ChannelsMask, CHANNELS_MASK_SIZE );
 8038154:	4e88      	ldr	r6, [pc, #544]	; (8038378 <RegionUS915LinkAdrReq+0x228>)
{
 8038156:	b095      	sub	sp, #84	; 0x54
 8038158:	e9cd 1201 	strd	r1, r2, [sp, #4]
    RegionCommonChanMaskCopy( channelsMask, RegionNvmGroup2->ChannelsMask, CHANNELS_MASK_SIZE );
 803815c:	6831      	ldr	r1, [r6, #0]
{
 803815e:	9303      	str	r3, [sp, #12]
    uint16_t channelsMask[CHANNELS_MASK_SIZE] = { 0, 0, 0, 0, 0, 0 };
 8038160:	af09      	add	r7, sp, #36	; 0x24
    RegionCommonLinkAdrParams_t linkAdrParams = { 0 };
 8038162:	2400      	movs	r4, #0
{
 8038164:	4605      	mov	r5, r0
    RegionCommonChanMaskCopy( channelsMask, RegionNvmGroup2->ChannelsMask, CHANNELS_MASK_SIZE );
 8038166:	2206      	movs	r2, #6
 8038168:	f501 7158 	add.w	r1, r1, #864	; 0x360
 803816c:	4638      	mov	r0, r7
    uint16_t channelsMask[CHANNELS_MASK_SIZE] = { 0, 0, 0, 0, 0, 0 };
 803816e:	e9c7 4401 	strd	r4, r4, [r7, #4]
    RegionCommonLinkAdrParams_t linkAdrParams = { 0 };
 8038172:	9407      	str	r4, [sp, #28]
 8038174:	f8ad 4020 	strh.w	r4, [sp, #32]
    uint16_t channelsMask[CHANNELS_MASK_SIZE] = { 0, 0, 0, 0, 0, 0 };
 8038178:	9409      	str	r4, [sp, #36]	; 0x24
    RegionCommonChanMaskCopy( channelsMask, RegionNvmGroup2->ChannelsMask, CHANNELS_MASK_SIZE );
 803817a:	f7fe fc90 	bl	8036a9e <RegionCommonChanMaskCopy>
            channelsMask[4] = linkAdrParams.ChMask & CHANNELS_MASK_500KHZ_MASK;
        }
        else if( linkAdrParams.ChMaskCtrl == 7 )
        {
            // Disable all 125 kHz channels
            channelsMask[0] = 0x0000;
 803817e:	46a0      	mov	r8, r4
            channelsMask[0] = 0xFFFF;
 8038180:	f04f 39ff 	mov.w	r9, #4294967295
    while( bytesProcessed < linkAdrReq->PayloadSize )
 8038184:	7a2b      	ldrb	r3, [r5, #8]
 8038186:	42a3      	cmp	r3, r4
 8038188:	d907      	bls.n	803819a <RegionUS915LinkAdrReq+0x4a>
        nextIndex = RegionCommonParseLinkAdrReq( &( linkAdrReq->Payload[bytesProcessed] ), &linkAdrParams );
 803818a:	6868      	ldr	r0, [r5, #4]
 803818c:	a907      	add	r1, sp, #28
 803818e:	4420      	add	r0, r4
 8038190:	f7fe fda6 	bl	8036ce0 <RegionCommonParseLinkAdrReq>
        if( nextIndex == 0 )
 8038194:	2800      	cmp	r0, #0
 8038196:	f040 808c 	bne.w	80382b2 <RegionUS915LinkAdrReq+0x162>
            channelsMask[linkAdrParams.ChMaskCtrl] = linkAdrParams.ChMask;
        }
    }

    // FCC 15.247 paragraph F mandates to hop on at least 2 125 kHz channels
    if( ( linkAdrParams.Datarate < DR_4 ) && ( RegionCommonCountChannels( channelsMask, 0, 4 ) < 2 ) )
 803819a:	f99d 301d 	ldrsb.w	r3, [sp, #29]
 803819e:	2b03      	cmp	r3, #3
 80381a0:	dc07      	bgt.n	80381b2 <RegionUS915LinkAdrReq+0x62>
 80381a2:	2204      	movs	r2, #4
 80381a4:	2100      	movs	r1, #0
 80381a6:	a809      	add	r0, sp, #36	; 0x24
 80381a8:	f7fe fc5b 	bl	8036a62 <RegionCommonCountChannels>
 80381ac:	2801      	cmp	r0, #1
 80381ae:	f240 80df 	bls.w	8038370 <RegionUS915LinkAdrReq+0x220>
    uint8_t bytesProcessed = 0;
 80381b2:	f04f 0807 	mov.w	r8, #7
    {
        status &= 0xFE; // Channel mask KO
    }

    // Get the minimum possible datarate
    getPhy.Attribute = PHY_MIN_TX_DR;
 80381b6:	2302      	movs	r3, #2
 80381b8:	f88d 3014 	strb.w	r3, [sp, #20]
    getPhy.UplinkDwellTime = linkAdrReq->UplinkDwellTime;
    phyParam = RegionUS915GetPhyParam( &getPhy );
 80381bc:	a805      	add	r0, sp, #20
    getPhy.UplinkDwellTime = linkAdrReq->UplinkDwellTime;
 80381be:	7a6b      	ldrb	r3, [r5, #9]
 80381c0:	f88d 3016 	strb.w	r3, [sp, #22]
    phyParam = RegionUS915GetPhyParam( &getPhy );
 80381c4:	f7ff fcf2 	bl	8037bac <RegionUS915GetPhyParam>

    linkAdrVerifyParams.Status = status;
    linkAdrVerifyParams.AdrEnabled = linkAdrReq->AdrEnabled;
 80381c8:	7aab      	ldrb	r3, [r5, #10]
 80381ca:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
    linkAdrVerifyParams.Datarate = linkAdrParams.Datarate;
 80381ce:	f89d 301d 	ldrb.w	r3, [sp, #29]
 80381d2:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    linkAdrVerifyParams.TxPower = linkAdrParams.TxPower;
 80381d6:	f89d 301e 	ldrb.w	r3, [sp, #30]
 80381da:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    linkAdrVerifyParams.NbRep = linkAdrParams.NbRep;
 80381de:	f89d 301c 	ldrb.w	r3, [sp, #28]
 80381e2:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
    linkAdrVerifyParams.CurrentDatarate = linkAdrReq->CurrentDatarate;
 80381e6:	7aeb      	ldrb	r3, [r5, #11]
 80381e8:	f88d 3039 	strb.w	r3, [sp, #57]	; 0x39
    linkAdrVerifyParams.CurrentTxPower = linkAdrReq->CurrentTxPower;
 80381ec:	7b2b      	ldrb	r3, [r5, #12]
 80381ee:	f88d 303a 	strb.w	r3, [sp, #58]	; 0x3a
    linkAdrVerifyParams.CurrentNbRep = linkAdrReq->CurrentNbRep;
 80381f2:	7b6b      	ldrb	r3, [r5, #13]
 80381f4:	f88d 303b 	strb.w	r3, [sp, #59]	; 0x3b
    linkAdrVerifyParams.NbChannels = US915_MAX_NB_CHANNELS;
 80381f8:	2348      	movs	r3, #72	; 0x48
 80381fa:	f88d 303c 	strb.w	r3, [sp, #60]	; 0x3c
    linkAdrVerifyParams.ChannelsMask = channelsMask;
    linkAdrVerifyParams.MinDatarate = ( int8_t )phyParam.Value;
    linkAdrVerifyParams.MaxDatarate = US915_TX_MAX_DATARATE;
 80381fe:	2304      	movs	r3, #4
 8038200:	f88d 3045 	strb.w	r3, [sp, #69]	; 0x45
    linkAdrVerifyParams.Channels = RegionNvmGroup2->Channels;
 8038204:	6833      	ldr	r3, [r6, #0]
 8038206:	9312      	str	r3, [sp, #72]	; 0x48
    linkAdrVerifyParams.MinTxPower = US915_MIN_TX_POWER;
 8038208:	230e      	movs	r3, #14
 803820a:	f8ad 304c 	strh.w	r3, [sp, #76]	; 0x4c
    linkAdrVerifyParams.MaxTxPower = US915_MAX_TX_POWER;
    linkAdrVerifyParams.Version = linkAdrReq->Version;
 803820e:	682b      	ldr	r3, [r5, #0]
    phyParam = RegionUS915GetPhyParam( &getPhy );
 8038210:	9004      	str	r0, [sp, #16]
    linkAdrVerifyParams.MinDatarate = ( int8_t )phyParam.Value;
 8038212:	f88d 0044 	strb.w	r0, [sp, #68]	; 0x44
    linkAdrVerifyParams.Version = linkAdrReq->Version;
 8038216:	930c      	str	r3, [sp, #48]	; 0x30

    // Verify the parameters and update, if necessary
    status = RegionCommonLinkAdrReqVerifyParams( &linkAdrVerifyParams, &linkAdrParams.Datarate, &linkAdrParams.TxPower, &linkAdrParams.NbRep );
 8038218:	f10d 021e 	add.w	r2, sp, #30
 803821c:	ab07      	add	r3, sp, #28
 803821e:	f10d 011d 	add.w	r1, sp, #29
 8038222:	a80c      	add	r0, sp, #48	; 0x30
    linkAdrVerifyParams.Status = status;
 8038224:	f88d 8034 	strb.w	r8, [sp, #52]	; 0x34
    linkAdrVerifyParams.ChannelsMask = channelsMask;
 8038228:	9710      	str	r7, [sp, #64]	; 0x40
    status = RegionCommonLinkAdrReqVerifyParams( &linkAdrVerifyParams, &linkAdrParams.Datarate, &linkAdrParams.TxPower, &linkAdrParams.NbRep );
 803822a:	f7fe fd73 	bl	8036d14 <RegionCommonLinkAdrReqVerifyParams>

    // Update channelsMask if everything is correct
    if( status == 0x07 )
 803822e:	2807      	cmp	r0, #7
    status = RegionCommonLinkAdrReqVerifyParams( &linkAdrVerifyParams, &linkAdrParams.Datarate, &linkAdrParams.TxPower, &linkAdrParams.NbRep );
 8038230:	4605      	mov	r5, r0
    if( status == 0x07 )
 8038232:	d12c      	bne.n	803828e <RegionUS915LinkAdrReq+0x13e>
    {
        // Copy Mask
        RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, channelsMask, 6 );
 8038234:	6830      	ldr	r0, [r6, #0]
 8038236:	2206      	movs	r2, #6
 8038238:	4639      	mov	r1, r7
 803823a:	f500 7058 	add.w	r0, r0, #864	; 0x360
 803823e:	f7fe fc2e 	bl	8036a9e <RegionCommonChanMaskCopy>

        RegionNvmGroup1->ChannelsMaskRemaining[0] &= RegionNvmGroup2->ChannelsMask[0];
 8038242:	e9d6 2300 	ldrd	r2, r3, [r6]
 8038246:	f8b2 0360 	ldrh.w	r0, [r2, #864]	; 0x360
 803824a:	f8b3 1090 	ldrh.w	r1, [r3, #144]	; 0x90
 803824e:	4001      	ands	r1, r0
 8038250:	f8a3 1090 	strh.w	r1, [r3, #144]	; 0x90
        RegionNvmGroup1->ChannelsMaskRemaining[1] &= RegionNvmGroup2->ChannelsMask[1];
 8038254:	f8b2 0362 	ldrh.w	r0, [r2, #866]	; 0x362
 8038258:	f8b3 1092 	ldrh.w	r1, [r3, #146]	; 0x92
 803825c:	4001      	ands	r1, r0
 803825e:	f8a3 1092 	strh.w	r1, [r3, #146]	; 0x92
        RegionNvmGroup1->ChannelsMaskRemaining[2] &= RegionNvmGroup2->ChannelsMask[2];
 8038262:	f8b2 0364 	ldrh.w	r0, [r2, #868]	; 0x364
 8038266:	f8b3 1094 	ldrh.w	r1, [r3, #148]	; 0x94
 803826a:	4001      	ands	r1, r0
 803826c:	f8a3 1094 	strh.w	r1, [r3, #148]	; 0x94
        RegionNvmGroup1->ChannelsMaskRemaining[3] &= RegionNvmGroup2->ChannelsMask[3];
 8038270:	f8b2 0366 	ldrh.w	r0, [r2, #870]	; 0x366
 8038274:	f8b3 1096 	ldrh.w	r1, [r3, #150]	; 0x96
 8038278:	4001      	ands	r1, r0
 803827a:	f8a3 1096 	strh.w	r1, [r3, #150]	; 0x96
        RegionNvmGroup1->ChannelsMaskRemaining[4] = RegionNvmGroup2->ChannelsMask[4];
 803827e:	f8b2 1368 	ldrh.w	r1, [r2, #872]	; 0x368
        RegionNvmGroup1->ChannelsMaskRemaining[5] = RegionNvmGroup2->ChannelsMask[5];
 8038282:	f8b2 236a 	ldrh.w	r2, [r2, #874]	; 0x36a
        RegionNvmGroup1->ChannelsMaskRemaining[4] = RegionNvmGroup2->ChannelsMask[4];
 8038286:	f8a3 1098 	strh.w	r1, [r3, #152]	; 0x98
        RegionNvmGroup1->ChannelsMaskRemaining[5] = RegionNvmGroup2->ChannelsMask[5];
 803828a:	f8a3 209a 	strh.w	r2, [r3, #154]	; 0x9a
    }

    // Update status variables
    *drOut = linkAdrParams.Datarate;
 803828e:	9a01      	ldr	r2, [sp, #4]
 8038290:	f89d 301d 	ldrb.w	r3, [sp, #29]
 8038294:	7013      	strb	r3, [r2, #0]
    *txPowOut = linkAdrParams.TxPower;
 8038296:	9a02      	ldr	r2, [sp, #8]
 8038298:	f89d 301e 	ldrb.w	r3, [sp, #30]
 803829c:	7013      	strb	r3, [r2, #0]
    *nbRepOut = linkAdrParams.NbRep;
 803829e:	9a03      	ldr	r2, [sp, #12]
 80382a0:	f89d 301c 	ldrb.w	r3, [sp, #28]
 80382a4:	7013      	strb	r3, [r2, #0]
    *nbBytesParsed = bytesProcessed;
 80382a6:	9b1e      	ldr	r3, [sp, #120]	; 0x78

#endif /* REGION_US915 */
    return status;
}
 80382a8:	4628      	mov	r0, r5
    *nbBytesParsed = bytesProcessed;
 80382aa:	701c      	strb	r4, [r3, #0]
}
 80382ac:	b015      	add	sp, #84	; 0x54
 80382ae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if( linkAdrParams.ChMaskCtrl == 6 )
 80382b2:	f89d 301f 	ldrb.w	r3, [sp, #31]
 80382b6:	f8bd 2020 	ldrh.w	r2, [sp, #32]
        bytesProcessed += nextIndex;
 80382ba:	4404      	add	r4, r0
        if( linkAdrParams.ChMaskCtrl == 6 )
 80382bc:	2b06      	cmp	r3, #6
        bytesProcessed += nextIndex;
 80382be:	b2e4      	uxtb	r4, r4
        if( linkAdrParams.ChMaskCtrl == 6 )
 80382c0:	d105      	bne.n	80382ce <RegionUS915LinkAdrReq+0x17e>
            channelsMask[2] = 0xFFFF;
 80382c2:	e9cd 9909 	strd	r9, r9, [sp, #36]	; 0x24
            channelsMask[4] = linkAdrParams.ChMask & CHANNELS_MASK_500KHZ_MASK;
 80382c6:	b2d2      	uxtb	r2, r2
 80382c8:	f8ad 202c 	strh.w	r2, [sp, #44]	; 0x2c
 80382cc:	e75a      	b.n	8038184 <RegionUS915LinkAdrReq+0x34>
        else if( linkAdrParams.ChMaskCtrl == 7 )
 80382ce:	2b07      	cmp	r3, #7
 80382d0:	d102      	bne.n	80382d8 <RegionUS915LinkAdrReq+0x188>
            channelsMask[2] = 0x0000;
 80382d2:	e9cd 8809 	strd	r8, r8, [sp, #36]	; 0x24
 80382d6:	e7f6      	b.n	80382c6 <RegionUS915LinkAdrReq+0x176>
        else if( linkAdrParams.ChMaskCtrl == 5 )
 80382d8:	2b05      	cmp	r3, #5
 80382da:	d143      	bne.n	8038364 <RegionUS915LinkAdrReq+0x214>
                if( ( ( linkAdrParams.ChMask & 0x00FF ) & ( bitMask << i ) ) != 0 )
 80382dc:	f04f 0c00 	mov.w	ip, #0
 80382e0:	b2d2      	uxtb	r2, r2
            uint8_t cntChannelMask = 0;
 80382e2:	4661      	mov	r1, ip
                if( ( ( linkAdrParams.ChMask & 0x00FF ) & ( bitMask << i ) ) != 0 )
 80382e4:	2301      	movs	r3, #1
 80382e6:	fa03 fa0c 	lsl.w	sl, r3, ip
 80382ea:	ea0c 0b03 	and.w	fp, ip, r3
 80382ee:	ab14      	add	r3, sp, #80	; 0x50
 80382f0:	eb03 0e41 	add.w	lr, r3, r1, lsl #1
 80382f4:	ea12 0f0a 	tst.w	r2, sl
 80382f8:	f83e 3c2c 	ldrh.w	r3, [lr, #-44]
 80382fc:	fa0f f08a 	sxth.w	r0, sl
 8038300:	d01d      	beq.n	803833e <RegionUS915LinkAdrReq+0x1ee>
                    if( ( i % 2 ) == 0 )
 8038302:	f1bb 0f00 	cmp.w	fp, #0
 8038306:	d10e      	bne.n	8038326 <RegionUS915LinkAdrReq+0x1d6>
                        channelsMask[cntChannelMask] |= 0x00FF;
 8038308:	f043 03ff 	orr.w	r3, r3, #255	; 0xff
 803830c:	f82e 3c2c 	strh.w	r3, [lr, #-44]
                        channelsMask[4] |= ( bitMask << i );
 8038310:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
 8038314:	4318      	orrs	r0, r3
                        channelsMask[4] &= ~( bitMask << i );
 8038316:	f8ad 002c 	strh.w	r0, [sp, #44]	; 0x2c
            for( uint8_t i = 0; i <= 7; i++ )
 803831a:	f10c 0c01 	add.w	ip, ip, #1
 803831e:	f1bc 0f08 	cmp.w	ip, #8
 8038322:	d1df      	bne.n	80382e4 <RegionUS915LinkAdrReq+0x194>
 8038324:	e72e      	b.n	8038184 <RegionUS915LinkAdrReq+0x34>
                        channelsMask[cntChannelMask] |= 0xFF00;
 8038326:	f063 03ff 	orn	r3, r3, #255	; 0xff
 803832a:	f82e 3c2c 	strh.w	r3, [lr, #-44]
                        channelsMask[4] |= ( bitMask << i );
 803832e:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
 8038332:	4318      	orrs	r0, r3
                        cntChannelMask++;
 8038334:	3101      	adds	r1, #1
                        channelsMask[4] &= ~( bitMask << i );
 8038336:	f8ad 002c 	strh.w	r0, [sp, #44]	; 0x2c
                        cntChannelMask++;
 803833a:	b2c9      	uxtb	r1, r1
 803833c:	e7ed      	b.n	803831a <RegionUS915LinkAdrReq+0x1ca>
                    if( ( i % 2 ) == 0 )
 803833e:	43c0      	mvns	r0, r0
 8038340:	f1bb 0f00 	cmp.w	fp, #0
 8038344:	d107      	bne.n	8038356 <RegionUS915LinkAdrReq+0x206>
                        channelsMask[cntChannelMask] &= 0xFF00;
 8038346:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 803834a:	f82e 3c2c 	strh.w	r3, [lr, #-44]
                        channelsMask[4] &= ~( bitMask << i );
 803834e:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
 8038352:	4018      	ands	r0, r3
 8038354:	e7df      	b.n	8038316 <RegionUS915LinkAdrReq+0x1c6>
                        channelsMask[cntChannelMask] &= 0x00FF;
 8038356:	b2db      	uxtb	r3, r3
 8038358:	f82e 3c2c 	strh.w	r3, [lr, #-44]
                        channelsMask[4] &= ~( bitMask << i );
 803835c:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
 8038360:	4018      	ands	r0, r3
 8038362:	e7e7      	b.n	8038334 <RegionUS915LinkAdrReq+0x1e4>
            channelsMask[linkAdrParams.ChMaskCtrl] = linkAdrParams.ChMask;
 8038364:	a914      	add	r1, sp, #80	; 0x50
 8038366:	eb01 0343 	add.w	r3, r1, r3, lsl #1
 803836a:	f823 2c2c 	strh.w	r2, [r3, #-44]
 803836e:	e709      	b.n	8038184 <RegionUS915LinkAdrReq+0x34>
        status &= 0xFE; // Channel mask KO
 8038370:	f04f 0806 	mov.w	r8, #6
 8038374:	e71f      	b.n	80381b6 <RegionUS915LinkAdrReq+0x66>
 8038376:	bf00      	nop
 8038378:	20005730 	.word	0x20005730

0803837c <RegionUS915RxParamSetupReq>:

uint8_t RegionUS915RxParamSetupReq( RxParamSetupReqParams_t* rxParamSetupReq )
{
 803837c:	b538      	push	{r3, r4, r5, lr}
 803837e:	4605      	mov	r5, r0
    uint8_t status = 0x07;
#if defined( REGION_US915 )

    // Verify radio frequency
    if( VerifyRfFreq( rxParamSetupReq->Frequency ) == false )
 8038380:	6840      	ldr	r0, [r0, #4]
 8038382:	f7ff fbf3 	bl	8037b6c <VerifyRfFreq>
    {
        status &= 0xFE; // Channel frequency KO
    }

    // Verify datarate
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, US915_RX_MIN_DATARATE, US915_RX_MAX_DATARATE ) == false )
 8038386:	220d      	movs	r2, #13
        status &= 0xFE; // Channel frequency KO
 8038388:	2800      	cmp	r0, #0
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, US915_RX_MIN_DATARATE, US915_RX_MAX_DATARATE ) == false )
 803838a:	f04f 0108 	mov.w	r1, #8
 803838e:	f995 0000 	ldrsb.w	r0, [r5]
        status &= 0xFE; // Channel frequency KO
 8038392:	bf14      	ite	ne
 8038394:	2407      	movne	r4, #7
 8038396:	2406      	moveq	r4, #6
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, US915_RX_MIN_DATARATE, US915_RX_MAX_DATARATE ) == false )
 8038398:	f7fe fb41 	bl	8036a1e <RegionCommonValueInRange>
 803839c:	b908      	cbnz	r0, 80383a2 <RegionUS915RxParamSetupReq+0x26>
    {
        status &= 0xFD; // Datarate KO
 803839e:	f004 0405 	and.w	r4, r4, #5
    }
    if( ( RegionCommonValueInRange( rxParamSetupReq->Datarate, DR_5, DR_7 ) == true ) ||
 80383a2:	f995 0000 	ldrsb.w	r0, [r5]
 80383a6:	2207      	movs	r2, #7
 80383a8:	2105      	movs	r1, #5
 80383aa:	f7fe fb38 	bl	8036a1e <RegionCommonValueInRange>
 80383ae:	2801      	cmp	r0, #1
 80383b0:	d003      	beq.n	80383ba <RegionUS915RxParamSetupReq+0x3e>
 80383b2:	f995 3000 	ldrsb.w	r3, [r5]
 80383b6:	2b0d      	cmp	r3, #13
 80383b8:	dd01      	ble.n	80383be <RegionUS915RxParamSetupReq+0x42>
        ( rxParamSetupReq->Datarate > DR_13 ) )
    {
        status &= 0xFD; // Datarate KO
 80383ba:	f004 04fd 	and.w	r4, r4, #253	; 0xfd
    }

    // Verify datarate offset
    if( RegionCommonValueInRange( rxParamSetupReq->DrOffset, US915_MIN_RX1_DR_OFFSET, US915_MAX_RX1_DR_OFFSET ) == false )
 80383be:	f995 0001 	ldrsb.w	r0, [r5, #1]
 80383c2:	2203      	movs	r2, #3
 80383c4:	2100      	movs	r1, #0
 80383c6:	f7fe fb2a 	bl	8036a1e <RegionCommonValueInRange>
 80383ca:	b908      	cbnz	r0, 80383d0 <RegionUS915RxParamSetupReq+0x54>
    {
        status &= 0xFB; // Rx1DrOffset range KO
 80383cc:	f004 04fb 	and.w	r4, r4, #251	; 0xfb
    }

#endif /* REGION_US915 */
    return status;
}
 80383d0:	4620      	mov	r0, r4
 80383d2:	bd38      	pop	{r3, r4, r5, pc}

080383d4 <RegionUS915NewChannelReq>:

int8_t RegionUS915NewChannelReq( NewChannelReqParams_t* newChannelReq )
{
    // Do not accept the request
    return -1;
}
 80383d4:	f04f 30ff 	mov.w	r0, #4294967295
 80383d8:	4770      	bx	lr

080383da <RegionUS915TxParamSetupReq>:
 80383da:	f04f 30ff 	mov.w	r0, #4294967295
 80383de:	4770      	bx	lr

080383e0 <RegionUS915DlChannelReq>:
 80383e0:	f04f 30ff 	mov.w	r0, #4294967295
 80383e4:	4770      	bx	lr
	...

080383e8 <RegionUS915AlternateDr>:
int8_t RegionUS915AlternateDr( int8_t currentDr, AlternateDrType_t type )
{
#if defined( REGION_US915 )
    // Alternates the data rate according to the channel sequence:
    // Eight times a 125kHz DR_0 and then one 500kHz DR_4 channel
    if( type == ALTERNATE_DR )
 80383e8:	4b0a      	ldr	r3, [pc, #40]	; (8038414 <RegionUS915AlternateDr+0x2c>)
 80383ea:	685a      	ldr	r2, [r3, #4]
 80383ec:	f892 309d 	ldrb.w	r3, [r2, #157]	; 0x9d
 80383f0:	b971      	cbnz	r1, 8038410 <RegionUS915AlternateDr+0x28>
    {
        RegionNvmGroup1->JoinTrialsCounter++;
 80383f2:	3301      	adds	r3, #1
    }
    else
    {
        RegionNvmGroup1->JoinTrialsCounter--;
 80383f4:	f882 309d 	strb.w	r3, [r2, #157]	; 0x9d
 80383f8:	f892 309d 	ldrb.w	r3, [r2, #157]	; 0x9d
 80383fc:	ebc3 02c3 	rsb	r2, r3, r3, lsl #3
 8038400:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    }

    if( RegionNvmGroup1->JoinTrialsCounter % 9 == 0 )
 8038404:	b2db      	uxtb	r3, r3
        // Use DR_4 every 9th times.
        currentDr = DR_4;
    }
    else
    {
        currentDr = DR_0;
 8038406:	2b1d      	cmp	r3, #29
    }
    return currentDr;
#else
    return -1;
#endif /* REGION_US915 */
}
 8038408:	bf34      	ite	cc
 803840a:	2004      	movcc	r0, #4
 803840c:	2000      	movcs	r0, #0
 803840e:	4770      	bx	lr
        RegionNvmGroup1->JoinTrialsCounter--;
 8038410:	3b01      	subs	r3, #1
 8038412:	e7ef      	b.n	80383f4 <RegionUS915AlternateDr+0xc>
 8038414:	20005730 	.word	0x20005730

08038418 <RegionUS915NextChannel>:

LoRaMacStatus_t RegionUS915NextChannel( NextChanParams_t* nextChanParams, uint8_t* channel, TimerTime_t* time, TimerTime_t* aggregatedTimeOff )
{
 8038418:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
#if defined( REGION_US915 )
    uint8_t nbEnabledChannels = 0;
 803841c:	2600      	movs	r6, #0
{
 803841e:	b0a5      	sub	sp, #148	; 0x94
    RegionCommonIdentifyChannelsParam_t identifyChannelsParam;
    RegionCommonCountNbOfEnabledChannelsParams_t countChannelsParams;
    LoRaMacStatus_t status = LORAMAC_STATUS_NO_CHANNEL_FOUND;

    // Count 125kHz channels
    if( RegionCommonCountChannels( RegionNvmGroup1->ChannelsMaskRemaining, 0, 4 ) == 0 )
 8038420:	4d4a      	ldr	r5, [pc, #296]	; (803854c <RegionUS915NextChannel+0x134>)
    uint8_t nbEnabledChannels = 0;
 8038422:	f88d 600e 	strb.w	r6, [sp, #14]
{
 8038426:	4604      	mov	r4, r0
 8038428:	460f      	mov	r7, r1
 803842a:	4691      	mov	r9, r2
    uint8_t enabledChannels[US915_MAX_NB_CHANNELS] = { 0 };
 803842c:	4631      	mov	r1, r6
 803842e:	2244      	movs	r2, #68	; 0x44
 8038430:	a813      	add	r0, sp, #76	; 0x4c
{
 8038432:	4698      	mov	r8, r3
    uint8_t nbRestrictedChannels = 0;
 8038434:	f88d 600f 	strb.w	r6, [sp, #15]
    uint8_t enabledChannels[US915_MAX_NB_CHANNELS] = { 0 };
 8038438:	9612      	str	r6, [sp, #72]	; 0x48
 803843a:	f003 f9a5 	bl	803b788 <memset>
    if( RegionCommonCountChannels( RegionNvmGroup1->ChannelsMaskRemaining, 0, 4 ) == 0 )
 803843e:	6868      	ldr	r0, [r5, #4]
 8038440:	4631      	mov	r1, r6
 8038442:	2204      	movs	r2, #4
 8038444:	3090      	adds	r0, #144	; 0x90
 8038446:	f7fe fb0c 	bl	8036a62 <RegionCommonCountChannels>
 803844a:	4606      	mov	r6, r0
 803844c:	b950      	cbnz	r0, 8038464 <RegionUS915NextChannel+0x4c>
    { // Reactivate default channels
        RegionCommonChanMaskCopy( RegionNvmGroup1->ChannelsMaskRemaining, RegionNvmGroup2->ChannelsMask, 4  );
 803844e:	e9d5 1000 	ldrd	r1, r0, [r5]
 8038452:	2204      	movs	r2, #4
 8038454:	f501 7158 	add.w	r1, r1, #864	; 0x360
 8038458:	3090      	adds	r0, #144	; 0x90
 803845a:	f7fe fb20 	bl	8036a9e <RegionCommonChanMaskCopy>

        RegionNvmGroup1->JoinChannelGroupsCurrentIndex = 0;
 803845e:	686b      	ldr	r3, [r5, #4]
 8038460:	f883 609c 	strb.w	r6, [r3, #156]	; 0x9c
    }
    // Check other channels
    if( nextChanParams->Datarate >= DR_4 )
 8038464:	f994 3008 	ldrsb.w	r3, [r4, #8]
 8038468:	2b03      	cmp	r3, #3
 803846a:	e9d5 2100 	ldrd	r2, r1, [r5]
 803846e:	dd06      	ble.n	803847e <RegionUS915NextChannel+0x66>
    {
        if( ( RegionNvmGroup1->ChannelsMaskRemaining[4] & CHANNELS_MASK_500KHZ_MASK ) == 0 )
 8038470:	f891 0098 	ldrb.w	r0, [r1, #152]	; 0x98
 8038474:	b918      	cbnz	r0, 803847e <RegionUS915NextChannel+0x66>
        {
            RegionNvmGroup1->ChannelsMaskRemaining[4] = RegionNvmGroup2->ChannelsMask[4];
 8038476:	f8b2 0368 	ldrh.w	r0, [r2, #872]	; 0x368
 803847a:	f8a1 0098 	strh.w	r0, [r1, #152]	; 0x98
        }
    }

    // Search how many channels are enabled
    countChannelsParams.Joined = nextChanParams->Joined;
 803847e:	7a60      	ldrb	r0, [r4, #9]
 8038480:	f88d 0010 	strb.w	r0, [sp, #16]
    countChannelsParams.Datarate = nextChanParams->Datarate;
    countChannelsParams.ChannelsMask = RegionNvmGroup1->ChannelsMaskRemaining;
 8038484:	f101 0090 	add.w	r0, r1, #144	; 0x90
    countChannelsParams.Channels = RegionNvmGroup2->Channels;
 8038488:	e9cd 0205 	strd	r0, r2, [sp, #20]
    countChannelsParams.Bands = RegionNvmGroup1->Bands;
    countChannelsParams.MaxNbChannels = US915_MAX_NB_CHANNELS;
 803848c:	2248      	movs	r2, #72	; 0x48
 803848e:	f8ad 2020 	strh.w	r2, [sp, #32]
    countChannelsParams.JoinChannels = NULL;
 8038492:	2200      	movs	r2, #0
 8038494:	9209      	str	r2, [sp, #36]	; 0x24

    identifyChannelsParam.AggrTimeOff = nextChanParams->AggrTimeOff;
 8038496:	6822      	ldr	r2, [r4, #0]
 8038498:	920a      	str	r2, [sp, #40]	; 0x28
    identifyChannelsParam.LastAggrTx = nextChanParams->LastAggrTx;
 803849a:	6862      	ldr	r2, [r4, #4]
    countChannelsParams.Bands = RegionNvmGroup1->Bands;
 803849c:	9107      	str	r1, [sp, #28]
    identifyChannelsParam.LastAggrTx = nextChanParams->LastAggrTx;
 803849e:	920b      	str	r2, [sp, #44]	; 0x2c
    identifyChannelsParam.DutyCycleEnabled = nextChanParams->DutyCycleEnabled;
    identifyChannelsParam.MaxBands = US915_MAX_NB_BANDS;

    identifyChannelsParam.ElapsedTimeSinceStartUp = nextChanParams->ElapsedTimeSinceStartUp;
 80384a0:	e9d4 0103 	ldrd	r0, r1, [r4, #12]
    identifyChannelsParam.DutyCycleEnabled = nextChanParams->DutyCycleEnabled;
 80384a4:	7aa2      	ldrb	r2, [r4, #10]
 80384a6:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
    identifyChannelsParam.MaxBands = US915_MAX_NB_BANDS;
 80384aa:	2201      	movs	r2, #1
 80384ac:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
    identifyChannelsParam.ElapsedTimeSinceStartUp = nextChanParams->ElapsedTimeSinceStartUp;
 80384b0:	aa0d      	add	r2, sp, #52	; 0x34
 80384b2:	e882 0003 	stmia.w	r2, {r0, r1}
    identifyChannelsParam.LastTxIsJoinRequest = nextChanParams->LastTxIsJoinRequest;
 80384b6:	7d22      	ldrb	r2, [r4, #20]
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 80384b8:	8ae1      	ldrh	r1, [r4, #22]
    countChannelsParams.Datarate = nextChanParams->Datarate;
 80384ba:	f88d 3011 	strb.w	r3, [sp, #17]
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 80384be:	4618      	mov	r0, r3
    identifyChannelsParam.LastTxIsJoinRequest = nextChanParams->LastTxIsJoinRequest;
 80384c0:	f88d 203c 	strb.w	r2, [sp, #60]	; 0x3c
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 80384c4:	f7ff fb36 	bl	8037b34 <GetTimeOnAir>

    identifyChannelsParam.CountNbOfEnabledChannelsParam = &countChannelsParams;
 80384c8:	ab04      	add	r3, sp, #16
 80384ca:	9311      	str	r3, [sp, #68]	; 0x44

    status = RegionCommonIdentifyChannels( &identifyChannelsParam, aggregatedTimeOff, enabledChannels,
 80384cc:	f10d 030f 	add.w	r3, sp, #15
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 80384d0:	9010      	str	r0, [sp, #64]	; 0x40
    status = RegionCommonIdentifyChannels( &identifyChannelsParam, aggregatedTimeOff, enabledChannels,
 80384d2:	9300      	str	r3, [sp, #0]
 80384d4:	f8cd 9004 	str.w	r9, [sp, #4]
 80384d8:	f10d 030e 	add.w	r3, sp, #14
 80384dc:	aa12      	add	r2, sp, #72	; 0x48
 80384de:	4641      	mov	r1, r8
 80384e0:	a80a      	add	r0, sp, #40	; 0x28
 80384e2:	f7fe fcf8 	bl	8036ed6 <RegionCommonIdentifyChannels>
                                           &nbEnabledChannels, &nbRestrictedChannels, time );

    if( status == LORAMAC_STATUS_OK )
 80384e6:	4606      	mov	r6, r0
 80384e8:	b988      	cbnz	r0, 803850e <RegionUS915NextChannel+0xf6>
    {
        if( nextChanParams->Joined == true )
 80384ea:	7a63      	ldrb	r3, [r4, #9]
 80384ec:	b19b      	cbz	r3, 8038516 <RegionUS915NextChannel+0xfe>
        {
            // Choose randomly on of the remaining channels
            *channel = enabledChannels[randr( 0, nbEnabledChannels - 1 )];
 80384ee:	f89d 100e 	ldrb.w	r1, [sp, #14]
 80384f2:	3901      	subs	r1, #1
 80384f4:	f000 fd00 	bl	8038ef8 <randr>
 80384f8:	ab24      	add	r3, sp, #144	; 0x90
 80384fa:	4418      	add	r0, r3
 80384fc:	f810 3c48 	ldrb.w	r3, [r0, #-72]
                uint8_t i = 0;
                while( ( ( RegionNvmGroup1->ChannelsMaskRemaining[4] & CHANNELS_MASK_500KHZ_MASK ) & ( 1 << i ) ) == 0 )
                {
                    i++;
                }
                *channel = 64 + i;
 8038500:	703b      	strb	r3, [r7, #0]
            }
        }

        // Disable the channel in the mask
        RegionCommonChanDisable( RegionNvmGroup1->ChannelsMaskRemaining, *channel, US915_MAX_NB_CHANNELS );
 8038502:	6868      	ldr	r0, [r5, #4]
 8038504:	7839      	ldrb	r1, [r7, #0]
 8038506:	2248      	movs	r2, #72	; 0x48
 8038508:	3090      	adds	r0, #144	; 0x90
 803850a:	f7fe fa91 	bl	8036a30 <RegionCommonChanDisable>
    }
    return status;
#else
    return LORAMAC_STATUS_NO_CHANNEL_FOUND;
#endif /* REGION_US915 */
}
 803850e:	4630      	mov	r0, r6
 8038510:	b025      	add	sp, #148	; 0x94
 8038512:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            if( nextChanParams->Datarate == DR_0 )
 8038516:	f994 3008 	ldrsb.w	r3, [r4, #8]
 803851a:	6868      	ldr	r0, [r5, #4]
 803851c:	b15b      	cbz	r3, 8038536 <RegionUS915NextChannel+0x11e>
                while( ( ( RegionNvmGroup1->ChannelsMaskRemaining[4] & CHANNELS_MASK_500KHZ_MASK ) & ( 1 << i ) ) == 0 )
 803851e:	f890 0098 	ldrb.w	r0, [r0, #152]	; 0x98
 8038522:	4632      	mov	r2, r6
 8038524:	b2d3      	uxtb	r3, r2
 8038526:	fa40 f103 	asr.w	r1, r0, r3
 803852a:	07c9      	lsls	r1, r1, #31
 803852c:	f102 0201 	add.w	r2, r2, #1
 8038530:	d5f8      	bpl.n	8038524 <RegionUS915NextChannel+0x10c>
                *channel = 64 + i;
 8038532:	3340      	adds	r3, #64	; 0x40
 8038534:	e7e4      	b.n	8038500 <RegionUS915NextChannel+0xe8>
                if( RegionBaseUSComputeNext125kHzJoinChannel( ( uint16_t* ) RegionNvmGroup1->ChannelsMaskRemaining,
 8038536:	f100 019c 	add.w	r1, r0, #156	; 0x9c
 803853a:	463a      	mov	r2, r7
 803853c:	3090      	adds	r0, #144	; 0x90
 803853e:	f7fe f9f3 	bl	8036928 <RegionBaseUSComputeNext125kHzJoinChannel>
 8038542:	2803      	cmp	r0, #3
 8038544:	d1dd      	bne.n	8038502 <RegionUS915NextChannel+0xea>
                    return LORAMAC_STATUS_PARAMETER_INVALID;
 8038546:	4606      	mov	r6, r0
 8038548:	e7e1      	b.n	803850e <RegionUS915NextChannel+0xf6>
 803854a:	bf00      	nop
 803854c:	20005730 	.word	0x20005730

08038550 <RegionUS915SetContinuousWave>:
{
    return LORAMAC_STATUS_PARAMETER_INVALID;
}

void RegionUS915SetContinuousWave( ContinuousWaveParams_t* continuousWave )
{
 8038550:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
#if defined( REGION_US915 )
    int8_t txPowerLimited = LimitTxPower( continuousWave->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[continuousWave->Channel].Band].TxMaxPower, continuousWave->Datarate, RegionNvmGroup2->ChannelsMask );
 8038554:	4e1f      	ldr	r6, [pc, #124]	; (80385d4 <RegionUS915SetContinuousWave+0x84>)
 8038556:	7802      	ldrb	r2, [r0, #0]
 8038558:	f8d6 8000 	ldr.w	r8, [r6]
 803855c:	6871      	ldr	r1, [r6, #4]
 803855e:	f990 7002 	ldrsb.w	r7, [r0, #2]
 8038562:	f990 9001 	ldrsb.w	r9, [r0, #1]
 8038566:	230c      	movs	r3, #12
 8038568:	fb03 8202 	mla	r2, r3, r2, r8
{
 803856c:	4604      	mov	r4, r0
    int8_t txPowerLimited = LimitTxPower( continuousWave->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[continuousWave->Channel].Band].TxMaxPower, continuousWave->Datarate, RegionNvmGroup2->ChannelsMask );
 803856e:	7a53      	ldrb	r3, [r2, #9]
 8038570:	2218      	movs	r2, #24
 8038572:	fb02 1303 	mla	r3, r2, r3, r1
    txPowerResult =  RegionCommonLimitTxPower( txPower, maxBandTxPower );
 8038576:	4638      	mov	r0, r7
 8038578:	f993 1002 	ldrsb.w	r1, [r3, #2]
 803857c:	f7fe fd0a 	bl	8036f94 <RegionCommonLimitTxPower>
    if( datarate == DR_4 )
 8038580:	f1b9 0f04 	cmp.w	r9, #4
    txPowerResult =  RegionCommonLimitTxPower( txPower, maxBandTxPower );
 8038584:	4605      	mov	r5, r0
    if( datarate == DR_4 )
 8038586:	d117      	bne.n	80385b8 <RegionUS915SetContinuousWave+0x68>
        txPowerResult = MAX( txPower, TX_POWER_2 );
 8038588:	2f02      	cmp	r7, #2
 803858a:	463d      	mov	r5, r7
 803858c:	bfb8      	it	lt
 803858e:	2502      	movlt	r5, #2
    int8_t phyTxPower = 0;
    uint32_t frequency = RegionNvmGroup2->Channels[continuousWave->Channel].Frequency;
 8038590:	7821      	ldrb	r1, [r4, #0]
 8038592:	6832      	ldr	r2, [r6, #0]
 8038594:	230c      	movs	r3, #12
 8038596:	434b      	muls	r3, r1

    // Calculate physical TX power
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );
 8038598:	4628      	mov	r0, r5
    uint32_t frequency = RegionNvmGroup2->Channels[continuousWave->Channel].Frequency;
 803859a:	58d6      	ldr	r6, [r2, r3]
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );
 803859c:	490e      	ldr	r1, [pc, #56]	; (80385d8 <RegionUS915SetContinuousWave+0x88>)
 803859e:	2200      	movs	r2, #0
 80385a0:	f7fe fc2d 	bl	8036dfe <RegionCommonComputeTxPower>

    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 80385a4:	4b0d      	ldr	r3, [pc, #52]	; (80385dc <RegionUS915SetContinuousWave+0x8c>)
 80385a6:	89a2      	ldrh	r2, [r4, #12]
 80385a8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80385aa:	9301      	str	r3, [sp, #4]
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );
 80385ac:	4601      	mov	r1, r0
    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 80385ae:	4630      	mov	r0, r6
#endif /* REGION_US915 */
}
 80385b0:	b003      	add	sp, #12
 80385b2:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 80385b6:	4718      	bx	r3
        if( RegionCommonCountChannels( channelsMask, 0, 4 ) < 50 )
 80385b8:	2204      	movs	r2, #4
 80385ba:	2100      	movs	r1, #0
 80385bc:	f508 7058 	add.w	r0, r8, #864	; 0x360
 80385c0:	f7fe fa4f 	bl	8036a62 <RegionCommonCountChannels>
 80385c4:	2831      	cmp	r0, #49	; 0x31
 80385c6:	d8e3      	bhi.n	8038590 <RegionUS915SetContinuousWave+0x40>
            txPowerResult = MAX( txPower, TX_POWER_5 );
 80385c8:	2f05      	cmp	r7, #5
 80385ca:	463d      	mov	r5, r7
 80385cc:	bfb8      	it	lt
 80385ce:	2505      	movlt	r5, #5
 80385d0:	e7de      	b.n	8038590 <RegionUS915SetContinuousWave+0x40>
 80385d2:	bf00      	nop
 80385d4:	20005730 	.word	0x20005730
 80385d8:	41f00000 	.word	0x41f00000
 80385dc:	0803bc30 	.word	0x0803bc30

080385e0 <RegionUS915ApplyDrOffset>:

uint8_t RegionUS915ApplyDrOffset( uint8_t downlinkDwellTime, int8_t dr, int8_t drOffset )
{
#if defined( REGION_US915 )
    int8_t datarate = DatarateOffsetsUS915[dr][drOffset];
 80385e0:	4b04      	ldr	r3, [pc, #16]	; (80385f4 <RegionUS915ApplyDrOffset+0x14>)
 80385e2:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 80385e6:	4413      	add	r3, r2
 80385e8:	f993 0070 	ldrsb.w	r0, [r3, #112]	; 0x70

    if( datarate < 0 )
    {
        datarate = DR_0;
    }
    return datarate;
 80385ec:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
#else
    return 0;
#endif /* REGION_US915 */
}
 80385f0:	b2c0      	uxtb	r0, r0
 80385f2:	4770      	bx	lr
 80385f4:	0803bb58 	.word	0x0803bb58

080385f8 <GetKeyIndexByID>:
 */
static SecureElementStatus_t GetKeyIndexByID( KeyIdentifier_t keyID, CK_OBJECT_HANDLE *keyIndex )
{
    for (uint8_t i = 0; i < NUM_OF_KEYS; i++)
    {
        if (SeNvm->KeyList[i].KeyID == keyID)
 80385f8:	4b0a      	ldr	r3, [pc, #40]	; (8038624 <GetKeyIndexByID+0x2c>)
 80385fa:	681a      	ldr	r2, [r3, #0]
{
 80385fc:	b5f0      	push	{r4, r5, r6, r7, lr}
        if (SeNvm->KeyList[i].KeyID == keyID)
 80385fe:	2300      	movs	r3, #0
 8038600:	f102 0510 	add.w	r5, r2, #16
 8038604:	2618      	movs	r6, #24
 8038606:	fb06 f403 	mul.w	r4, r6, r3
 803860a:	5d2f      	ldrb	r7, [r5, r4]
 803860c:	4287      	cmp	r7, r0
 803860e:	d104      	bne.n	803861a <GetKeyIndexByID+0x22>
        {
            *keyIndex = SeNvm->KeyList[i].Object_Index;
 8038610:	4422      	add	r2, r4
            return SECURE_ELEMENT_SUCCESS;
 8038612:	2000      	movs	r0, #0
            *keyIndex = SeNvm->KeyList[i].Object_Index;
 8038614:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8038616:	600b      	str	r3, [r1, #0]
        }
    }
    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
}
 8038618:	bdf0      	pop	{r4, r5, r6, r7, pc}
    for (uint8_t i = 0; i < NUM_OF_KEYS; i++)
 803861a:	3301      	adds	r3, #1
 803861c:	2b0a      	cmp	r3, #10
 803861e:	d1f2      	bne.n	8038606 <GetKeyIndexByID+0xe>
    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 8038620:	2003      	movs	r0, #3
 8038622:	e7f9      	b.n	8038618 <GetKeyIndexByID+0x20>
 8038624:	20005738 	.word	0x20005738

08038628 <SecureElementGetKeyByID>:
    return SECURE_ELEMENT_SUCCESS;
}

/* ST_WORKAROUND_BEGIN: Add KMS specific functions */
SecureElementStatus_t SecureElementGetKeyByID( KeyIdentifier_t keyID, Key_t **keyItem )
{
 8038628:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 803862c:	b08d      	sub	sp, #52	; 0x34
    CK_SESSION_HANDLE session;
    CK_FLAGS session_flags = CKF_SERIAL_SESSION;  /* Read ONLY session */
    CK_OBJECT_HANDLE key_handle = (CK_OBJECT_HANDLE)(~0UL);
    CK_ULONG derive_key_template_class = CKO_SECRET_KEY;
    uint8_t extractable_key[16] = {0};
    CK_ATTRIBUTE key_attribute_template = {CKA_VALUE, (CK_VOID_PTR) &derive_key_template_class, 16UL};
 803862e:	2211      	movs	r2, #17
    CK_ULONG derive_key_template_class = CKO_SECRET_KEY;
 8038630:	2304      	movs	r3, #4
    uint8_t index_keylist = 0;
    for (index_keylist = 0; index_keylist < NUM_OF_KEYS; index_keylist++)
    {
        if (SeNvm->KeyList[index_keylist].KeyID == keyID)
 8038632:	4e27      	ldr	r6, [pc, #156]	; (80386d0 <SecureElementGetKeyByID+0xa8>)
    CK_ATTRIBUTE key_attribute_template = {CKA_VALUE, (CK_VOID_PTR) &derive_key_template_class, 16UL};
 8038634:	9205      	str	r2, [sp, #20]
 8038636:	aa04      	add	r2, sp, #16
    CK_ULONG derive_key_template_class = CKO_SECRET_KEY;
 8038638:	9304      	str	r3, [sp, #16]
    CK_ATTRIBUTE key_attribute_template = {CKA_VALUE, (CK_VOID_PTR) &derive_key_template_class, 16UL};
 803863a:	9206      	str	r2, [sp, #24]
    uint8_t extractable_key[16] = {0};
 803863c:	2300      	movs	r3, #0
    CK_ATTRIBUTE key_attribute_template = {CKA_VALUE, (CK_VOID_PTR) &derive_key_template_class, 16UL};
 803863e:	2210      	movs	r2, #16
 8038640:	9207      	str	r2, [sp, #28]
    uint8_t extractable_key[16] = {0};
 8038642:	e9cd 3308 	strd	r3, r3, [sp, #32]
        if (SeNvm->KeyList[index_keylist].KeyID == keyID)
 8038646:	6832      	ldr	r2, [r6, #0]
    uint8_t extractable_key[16] = {0};
 8038648:	e9cd 330a 	strd	r3, r3, [sp, #40]	; 0x28
{
 803864c:	460f      	mov	r7, r1
        if (SeNvm->KeyList[index_keylist].KeyID == keyID)
 803864e:	2418      	movs	r4, #24
 8038650:	f102 0110 	add.w	r1, r2, #16
 8038654:	fb04 f503 	mul.w	r5, r4, r3
 8038658:	f811 c005 	ldrb.w	ip, [r1, r5]
 803865c:	4584      	cmp	ip, r0
 803865e:	d107      	bne.n	8038670 <SecureElementGetKeyByID+0x48>
        {
            key_handle = SeNvm->KeyList[index_keylist].Object_Index;
 8038660:	442a      	add	r2, r5
 8038662:	f8d2 9024 	ldr.w	r9, [r2, #36]	; 0x24
            break;
        }
    }
    if (key_handle == (CK_OBJECT_HANDLE)(~0UL))
 8038666:	f1b9 3fff 	cmp.w	r9, #4294967295
 803866a:	d105      	bne.n	8038678 <SecureElementGetKeyByID+0x50>
    {
        return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 803866c:	2003      	movs	r0, #3
 803866e:	e02c      	b.n	80386ca <SecureElementGetKeyByID+0xa2>
    for (index_keylist = 0; index_keylist < NUM_OF_KEYS; index_keylist++)
 8038670:	3301      	adds	r3, #1
 8038672:	2b0a      	cmp	r3, #10
 8038674:	d1ee      	bne.n	8038654 <SecureElementGetKeyByID+0x2c>
 8038676:	e7f9      	b.n	803866c <SecureElementGetKeyByID+0x44>
    }

    /* Open session with KMS */
    rv = C_OpenSession(0, session_flags, NULL, 0, &session);
 8038678:	ab03      	add	r3, sp, #12
 803867a:	9300      	str	r3, [sp, #0]
 803867c:	2300      	movs	r3, #0
 803867e:	461a      	mov	r2, r3
 8038680:	2104      	movs	r1, #4
 8038682:	4618      	mov	r0, r3
 8038684:	f7d0 fb6a 	bl	8008d5c <SE_KMS_OpenSession>

    /* Get key to display */
    if (rv == CKR_OK)
 8038688:	4604      	mov	r4, r0
 803868a:	b9b8      	cbnz	r0, 80386bc <SecureElementGetKeyByID+0x94>
    {
        key_attribute_template.pValue = extractable_key;
        rv = C_GetAttributeValue(session, key_handle, &key_attribute_template, 1UL);
 803868c:	9803      	ldr	r0, [sp, #12]
        key_attribute_template.pValue = extractable_key;
 803868e:	f10d 0820 	add.w	r8, sp, #32
        rv = C_GetAttributeValue(session, key_handle, &key_attribute_template, 1UL);
 8038692:	2301      	movs	r3, #1
 8038694:	aa05      	add	r2, sp, #20
 8038696:	4649      	mov	r1, r9
        key_attribute_template.pValue = extractable_key;
 8038698:	f8cd 8018 	str.w	r8, [sp, #24]
        rv = C_GetAttributeValue(session, key_handle, &key_attribute_template, 1UL);
 803869c:	f7d0 fbce 	bl	8008e3c <SE_KMS_GetAttributeValue>
    }
    if (rv == CKR_OK)
 80386a0:	4604      	mov	r4, r0
 80386a2:	b958      	cbnz	r0, 80386bc <SecureElementGetKeyByID+0x94>
    {
        memcpy1(SeNvm->KeyList[index_keylist].KeyValue, extractable_key, sizeof(extractable_key));
 80386a4:	6833      	ldr	r3, [r6, #0]
 80386a6:	f105 0011 	add.w	r0, r5, #17
 80386aa:	4418      	add	r0, r3
 80386ac:	2210      	movs	r2, #16
 80386ae:	4641      	mov	r1, r8
 80386b0:	f000 fc3e 	bl	8038f30 <memcpy1>
        *keyItem = &(SeNvm->KeyList[index_keylist]);
 80386b4:	6833      	ldr	r3, [r6, #0]
 80386b6:	3510      	adds	r5, #16
 80386b8:	441d      	add	r5, r3
 80386ba:	603d      	str	r5, [r7, #0]
    }

    /* Close sessions */
    (void)C_CloseSession(session);
 80386bc:	9803      	ldr	r0, [sp, #12]
 80386be:	f7d0 fb6d 	bl	8008d9c <SE_KMS_CloseSession>

    if (rv != CKR_OK)
    {
        return SECURE_ELEMENT_ERROR;
 80386c2:	2c00      	cmp	r4, #0
 80386c4:	bf0c      	ite	eq
 80386c6:	2000      	moveq	r0, #0
 80386c8:	2006      	movne	r0, #6
    }
    return SECURE_ELEMENT_SUCCESS;

#endif /* LORAWAN_KMS == 1 */
}
 80386ca:	b00d      	add	sp, #52	; 0x34
 80386cc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80386d0:	20005738 	.word	0x20005738

080386d4 <PrintKey>:
{
 80386d4:	b510      	push	{r4, lr}
 80386d6:	b092      	sub	sp, #72	; 0x48
    retval = SecureElementGetKeyByID(key, &keyItem);
 80386d8:	a911      	add	r1, sp, #68	; 0x44
{
 80386da:	4604      	mov	r4, r0
    retval = SecureElementGetKeyByID(key, &keyItem);
 80386dc:	f7ff ffa4 	bl	8038628 <SecureElementGetKeyByID>
    if (retval == SECURE_ELEMENT_SUCCESS)
 80386e0:	4602      	mov	r2, r0
 80386e2:	2800      	cmp	r0, #0
 80386e4:	d131      	bne.n	803874a <PrintKey+0x76>
        if (key == APP_KEY)
 80386e6:	b914      	cbnz	r4, 80386ee <PrintKey+0x1a>
            MW_LOG(TS_OFF, VLEVEL_M, "###### AppKey:      ");
 80386e8:	4b27      	ldr	r3, [pc, #156]	; (8038788 <PrintKey+0xb4>)
            MW_LOG(TS_OFF, VLEVEL_M, "###### MCNwkSKey_0: ");
 80386ea:	2200      	movs	r2, #0
 80386ec:	e002      	b.n	80386f4 <PrintKey+0x20>
        else if (key == NWK_KEY)
 80386ee:	2c01      	cmp	r4, #1
 80386f0:	d12d      	bne.n	803874e <PrintKey+0x7a>
            MW_LOG(TS_OFF, VLEVEL_M, "###### NwkKey:      ");
 80386f2:	4b26      	ldr	r3, [pc, #152]	; (803878c <PrintKey+0xb8>)
            MW_LOG(TS_OFF, VLEVEL_M, "###### MCNwkSKey_0: ");
 80386f4:	4611      	mov	r1, r2
 80386f6:	2002      	movs	r0, #2
 80386f8:	f002 fb00 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
        MW_LOG(TS_OFF, VLEVEL_M, "%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\r\n",
 80386fc:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80386fe:	7c1a      	ldrb	r2, [r3, #16]
 8038700:	920f      	str	r2, [sp, #60]	; 0x3c
 8038702:	7bda      	ldrb	r2, [r3, #15]
 8038704:	920e      	str	r2, [sp, #56]	; 0x38
 8038706:	7b9a      	ldrb	r2, [r3, #14]
 8038708:	920d      	str	r2, [sp, #52]	; 0x34
 803870a:	7b5a      	ldrb	r2, [r3, #13]
 803870c:	920c      	str	r2, [sp, #48]	; 0x30
 803870e:	7b1a      	ldrb	r2, [r3, #12]
 8038710:	920b      	str	r2, [sp, #44]	; 0x2c
 8038712:	7ada      	ldrb	r2, [r3, #11]
 8038714:	920a      	str	r2, [sp, #40]	; 0x28
 8038716:	7a9a      	ldrb	r2, [r3, #10]
 8038718:	9209      	str	r2, [sp, #36]	; 0x24
 803871a:	7a5a      	ldrb	r2, [r3, #9]
 803871c:	9208      	str	r2, [sp, #32]
 803871e:	7a1a      	ldrb	r2, [r3, #8]
 8038720:	9207      	str	r2, [sp, #28]
 8038722:	79da      	ldrb	r2, [r3, #7]
 8038724:	9206      	str	r2, [sp, #24]
 8038726:	799a      	ldrb	r2, [r3, #6]
 8038728:	9205      	str	r2, [sp, #20]
 803872a:	795a      	ldrb	r2, [r3, #5]
 803872c:	9204      	str	r2, [sp, #16]
 803872e:	791a      	ldrb	r2, [r3, #4]
 8038730:	9203      	str	r2, [sp, #12]
 8038732:	78da      	ldrb	r2, [r3, #3]
 8038734:	9202      	str	r2, [sp, #8]
 8038736:	789a      	ldrb	r2, [r3, #2]
 8038738:	9201      	str	r2, [sp, #4]
 803873a:	785b      	ldrb	r3, [r3, #1]
 803873c:	9300      	str	r3, [sp, #0]
 803873e:	2200      	movs	r2, #0
 8038740:	4b13      	ldr	r3, [pc, #76]	; (8038790 <PrintKey+0xbc>)
 8038742:	4611      	mov	r1, r2
 8038744:	2002      	movs	r0, #2
 8038746:	f002 fad9 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
}
 803874a:	b012      	add	sp, #72	; 0x48
 803874c:	bd10      	pop	{r4, pc}
        else if (key == APP_S_KEY)
 803874e:	2c03      	cmp	r4, #3
 8038750:	d101      	bne.n	8038756 <PrintKey+0x82>
            MW_LOG(TS_OFF, VLEVEL_M, "###### AppSKey:     ");
 8038752:	4b10      	ldr	r3, [pc, #64]	; (8038794 <PrintKey+0xc0>)
 8038754:	e7ce      	b.n	80386f4 <PrintKey+0x20>
        else if (key == NWK_S_KEY)
 8038756:	2c02      	cmp	r4, #2
 8038758:	d101      	bne.n	803875e <PrintKey+0x8a>
            MW_LOG(TS_OFF, VLEVEL_M, "###### NwkSKey:     ");
 803875a:	4b0f      	ldr	r3, [pc, #60]	; (8038798 <PrintKey+0xc4>)
 803875c:	e7ca      	b.n	80386f4 <PrintKey+0x20>
        else if (key == MC_ROOT_KEY)
 803875e:	2c04      	cmp	r4, #4
 8038760:	d101      	bne.n	8038766 <PrintKey+0x92>
            MW_LOG(TS_OFF, VLEVEL_M, "###### MCRootKey:   ");
 8038762:	4b0e      	ldr	r3, [pc, #56]	; (803879c <PrintKey+0xc8>)
 8038764:	e7c6      	b.n	80386f4 <PrintKey+0x20>
        else if (key == MC_KE_KEY)
 8038766:	2c7f      	cmp	r4, #127	; 0x7f
 8038768:	d101      	bne.n	803876e <PrintKey+0x9a>
            MW_LOG(TS_OFF, VLEVEL_M, "###### MCKEKey:     ");
 803876a:	4b0d      	ldr	r3, [pc, #52]	; (80387a0 <PrintKey+0xcc>)
 803876c:	e7c2      	b.n	80386f4 <PrintKey+0x20>
        else if (key == MC_KEY_0)
 803876e:	2c80      	cmp	r4, #128	; 0x80
 8038770:	d101      	bne.n	8038776 <PrintKey+0xa2>
            MW_LOG(TS_OFF, VLEVEL_M, "###### MCKey_0:     ");
 8038772:	4b0c      	ldr	r3, [pc, #48]	; (80387a4 <PrintKey+0xd0>)
 8038774:	e7be      	b.n	80386f4 <PrintKey+0x20>
        else if (key == MC_APP_S_KEY_0)
 8038776:	2c81      	cmp	r4, #129	; 0x81
 8038778:	d101      	bne.n	803877e <PrintKey+0xaa>
            MW_LOG(TS_OFF, VLEVEL_M, "###### MCAppSKey_0: ");
 803877a:	4b0b      	ldr	r3, [pc, #44]	; (80387a8 <PrintKey+0xd4>)
 803877c:	e7ba      	b.n	80386f4 <PrintKey+0x20>
        else if (key == MC_NWK_S_KEY_0)
 803877e:	2c82      	cmp	r4, #130	; 0x82
 8038780:	d1bc      	bne.n	80386fc <PrintKey+0x28>
            MW_LOG(TS_OFF, VLEVEL_M, "###### MCNwkSKey_0: ");
 8038782:	4b0a      	ldr	r3, [pc, #40]	; (80387ac <PrintKey+0xd8>)
 8038784:	e7b1      	b.n	80386ea <PrintKey+0x16>
 8038786:	bf00      	nop
 8038788:	0803c427 	.word	0x0803c427
 803878c:	0803c43c 	.word	0x0803c43c
 8038790:	0803c4e4 	.word	0x0803c4e4
 8038794:	0803c451 	.word	0x0803c451
 8038798:	0803c466 	.word	0x0803c466
 803879c:	0803c47b 	.word	0x0803c47b
 80387a0:	0803c490 	.word	0x0803c490
 80387a4:	0803c4a5 	.word	0x0803c4a5
 80387a8:	0803c4ba 	.word	0x0803c4ba
 80387ac:	0803c4cf 	.word	0x0803c4cf

080387b0 <SecureElementDeleteDynamicKeys>:

SecureElementStatus_t SecureElementDeleteDynamicKeys( KeyIdentifier_t keyID, uint32_t *key_label )
{
 80387b0:	b530      	push	{r4, r5, lr}
 80387b2:	b095      	sub	sp, #84	; 0x54
#else /* LORAWAN_KMS == 1 */
    CK_RV rv;
    CK_SESSION_HANDLE session;
    CK_FLAGS session_flags = CKF_SERIAL_SESSION;    /* Read ONLY session */
    CK_OBJECT_HANDLE hObject[NUM_OF_KEYS];
    CK_ULONG local_template_label[] = {GlobalTemplateLabel, 0UL};
 80387b4:	4b37      	ldr	r3, [pc, #220]	; (8038894 <SecureElementDeleteDynamicKeys+0xe4>)
 80387b6:	9305      	str	r3, [sp, #20]
    CK_ATTRIBUTE dynamic_key_template = {CKA_LABEL, (CK_VOID_PTR)local_template_label, sizeof(local_template_label)};
 80387b8:	2303      	movs	r3, #3
 80387ba:	9307      	str	r3, [sp, #28]
 80387bc:	ab05      	add	r3, sp, #20
 80387be:	9308      	str	r3, [sp, #32]
 80387c0:	2308      	movs	r3, #8
 80387c2:	9309      	str	r3, [sp, #36]	; 0x24
    switch (keyID)
 80387c4:	2804      	cmp	r0, #4
    uint32_t ulCount = 0;
 80387c6:	f04f 0300 	mov.w	r3, #0
 80387ca:	9304      	str	r3, [sp, #16]
    switch (keyID)
 80387cc:	d90b      	bls.n	80387e6 <SecureElementDeleteDynamicKeys+0x36>
 80387ce:	387f      	subs	r0, #127	; 0x7f
 80387d0:	b2c3      	uxtb	r3, r0
 80387d2:	2b03      	cmp	r3, #3
 80387d4:	d901      	bls.n	80387da <SecureElementDeleteDynamicKeys+0x2a>
 80387d6:	2006      	movs	r0, #6
 80387d8:	e038      	b.n	803884c <SecureElementDeleteDynamicKeys+0x9c>
 80387da:	2803      	cmp	r0, #3
 80387dc:	d8fb      	bhi.n	80387d6 <SecureElementDeleteDynamicKeys+0x26>
 80387de:	e8df f000 	tbb	[pc, r0]
 80387e2:	413f      	.short	0x413f
 80387e4:	4543      	.short	0x4543
 80387e6:	3801      	subs	r0, #1
 80387e8:	2803      	cmp	r0, #3
 80387ea:	d803      	bhi.n	80387f4 <SecureElementDeleteDynamicKeys+0x44>
 80387ec:	e8df f000 	tbb	[pc, r0]
 80387f0:	36343230 	.word	0x36343230
            *specificLabel = 0x5F505041U;
 80387f4:	4b28      	ldr	r3, [pc, #160]	; (8038898 <SecureElementDeleteDynamicKeys+0xe8>)
            *specificLabel = 0x30534E4DU;
 80387f6:	9306      	str	r3, [sp, #24]

    if (SECURE_ELEMENT_SUCCESS != GetSpecificLabelByID(keyID, &local_template_label[1]))
    {
        return SECURE_ELEMENT_ERROR;
    }
    *key_label = local_template_label[1];
 80387f8:	9b06      	ldr	r3, [sp, #24]
 80387fa:	600b      	str	r3, [r1, #0]

    /* Open session with KMS */
    rv = C_OpenSession(0,    session_flags, NULL, 0, &session);
 80387fc:	ab03      	add	r3, sp, #12
 80387fe:	9300      	str	r3, [sp, #0]
 8038800:	2300      	movs	r3, #0
 8038802:	461a      	mov	r2, r3
 8038804:	2104      	movs	r1, #4
 8038806:	4618      	mov	r0, r3
 8038808:	f7d0 faa8 	bl	8008d5c <SE_KMS_OpenSession>

    /* Search from Template pattern */
    if (rv == CKR_OK)
 803880c:	4604      	mov	r4, r0
 803880e:	b990      	cbnz	r0, 8038836 <SecureElementDeleteDynamicKeys+0x86>
    {
        rv = C_FindObjectsInit(session, &dynamic_key_template, sizeof(dynamic_key_template) / sizeof(CK_ATTRIBUTE));
 8038810:	9803      	ldr	r0, [sp, #12]
 8038812:	2201      	movs	r2, #1
 8038814:	a907      	add	r1, sp, #28
 8038816:	f7d0 fb4d 	bl	8008eb4 <SE_KMS_FindObjectsInit>
    }

    /* Find all existing keys handle Template pattern */
    if (rv == CKR_OK)
 803881a:	4604      	mov	r4, r0
 803881c:	b958      	cbnz	r0, 8038836 <SecureElementDeleteDynamicKeys+0x86>
    {
        rv = C_FindObjects(session, hObject, NUM_OF_KEYS, (CK_ULONG *) &ulCount);
 803881e:	9803      	ldr	r0, [sp, #12]
 8038820:	ab04      	add	r3, sp, #16
 8038822:	220a      	movs	r2, #10
 8038824:	a90a      	add	r1, sp, #40	; 0x28
 8038826:	f7d0 fb61 	bl	8008eec <SE_KMS_FindObjects>
    }

    if (rv == CKR_OK)
 803882a:	4604      	mov	r4, r0
 803882c:	b918      	cbnz	r0, 8038836 <SecureElementDeleteDynamicKeys+0x86>
    {
        rv = C_FindObjectsFinal(session);
 803882e:	9803      	ldr	r0, [sp, #12]
 8038830:	f7d0 fb7a 	bl	8008f28 <SE_KMS_FindObjectsFinal>
 8038834:	4604      	mov	r4, r0
    }

    if (ulCount <= NUM_OF_KEYS)
 8038836:	9b04      	ldr	r3, [sp, #16]
 8038838:	2b0a      	cmp	r3, #10
 803883a:	d929      	bls.n	8038890 <SecureElementDeleteDynamicKeys+0xe0>
            }
        }
    }

    /* Close sessions */
    if (session > 0)
 803883c:	9803      	ldr	r0, [sp, #12]
 803883e:	b108      	cbz	r0, 8038844 <SecureElementDeleteDynamicKeys+0x94>
    {
        (void)C_CloseSession(session);
 8038840:	f7d0 faac 	bl	8008d9c <SE_KMS_CloseSession>
    }

    if (rv != CKR_OK)
    {
        return SECURE_ELEMENT_ERROR;
 8038844:	2c00      	cmp	r4, #0
 8038846:	bf0c      	ite	eq
 8038848:	2000      	moveq	r0, #0
 803884a:	2006      	movne	r0, #6
    }
    return SECURE_ELEMENT_SUCCESS;
#endif /* LORAWAN_KMS == 1 */
}
 803884c:	b015      	add	sp, #84	; 0x54
 803884e:	bd30      	pop	{r4, r5, pc}
            *specificLabel = 0x5F4B574EU;
 8038850:	4b12      	ldr	r3, [pc, #72]	; (803889c <SecureElementDeleteDynamicKeys+0xec>)
 8038852:	e7d0      	b.n	80387f6 <SecureElementDeleteDynamicKeys+0x46>
            *specificLabel = 0x534B574EU;
 8038854:	4b12      	ldr	r3, [pc, #72]	; (80388a0 <SecureElementDeleteDynamicKeys+0xf0>)
 8038856:	e7ce      	b.n	80387f6 <SecureElementDeleteDynamicKeys+0x46>
            *specificLabel = 0x53505041U;
 8038858:	4b12      	ldr	r3, [pc, #72]	; (80388a4 <SecureElementDeleteDynamicKeys+0xf4>)
 803885a:	e7cc      	b.n	80387f6 <SecureElementDeleteDynamicKeys+0x46>
            *specificLabel = 0x5452434DU;
 803885c:	4b12      	ldr	r3, [pc, #72]	; (80388a8 <SecureElementDeleteDynamicKeys+0xf8>)
 803885e:	e7ca      	b.n	80387f6 <SecureElementDeleteDynamicKeys+0x46>
            *specificLabel = 0x454B434DU;
 8038860:	4b12      	ldr	r3, [pc, #72]	; (80388ac <SecureElementDeleteDynamicKeys+0xfc>)
 8038862:	e7c8      	b.n	80387f6 <SecureElementDeleteDynamicKeys+0x46>
            *specificLabel = 0x304B434DU;
 8038864:	4b12      	ldr	r3, [pc, #72]	; (80388b0 <SecureElementDeleteDynamicKeys+0x100>)
 8038866:	e7c6      	b.n	80387f6 <SecureElementDeleteDynamicKeys+0x46>
            *specificLabel = 0x3053414DU;
 8038868:	4b12      	ldr	r3, [pc, #72]	; (80388b4 <SecureElementDeleteDynamicKeys+0x104>)
 803886a:	e7c4      	b.n	80387f6 <SecureElementDeleteDynamicKeys+0x46>
            *specificLabel = 0x30534E4DU;
 803886c:	4b12      	ldr	r3, [pc, #72]	; (80388b8 <SecureElementDeleteDynamicKeys+0x108>)
 803886e:	e7c2      	b.n	80387f6 <SecureElementDeleteDynamicKeys+0x46>
            if (rv == CKR_OK)
 8038870:	b944      	cbnz	r4, 8038884 <SecureElementDeleteDynamicKeys+0xd4>
                rv = C_DestroyObject(session, hObject[i]);
 8038872:	aa14      	add	r2, sp, #80	; 0x50
 8038874:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8038878:	9803      	ldr	r0, [sp, #12]
 803887a:	f853 1c28 	ldr.w	r1, [r3, #-40]
 803887e:	f7d0 fac3 	bl	8008e08 <SE_KMS_DestroyObject>
 8038882:	4604      	mov	r4, r0
        for (uint8_t i = 0; i < ulCount; i++)
 8038884:	3501      	adds	r5, #1
 8038886:	9a04      	ldr	r2, [sp, #16]
 8038888:	b2eb      	uxtb	r3, r5
 803888a:	429a      	cmp	r2, r3
 803888c:	d8f0      	bhi.n	8038870 <SecureElementDeleteDynamicKeys+0xc0>
 803888e:	e7d5      	b.n	803883c <SecureElementDeleteDynamicKeys+0x8c>
 8038890:	2500      	movs	r5, #0
 8038892:	e7f8      	b.n	8038886 <SecureElementDeleteDynamicKeys+0xd6>
 8038894:	444e524c 	.word	0x444e524c
 8038898:	5f505041 	.word	0x5f505041
 803889c:	5f4b574e 	.word	0x5f4b574e
 80388a0:	534b574e 	.word	0x534b574e
 80388a4:	53505041 	.word	0x53505041
 80388a8:	5452434d 	.word	0x5452434d
 80388ac:	454b434d 	.word	0x454b434d
 80388b0:	304b434d 	.word	0x304b434d
 80388b4:	3053414d 	.word	0x3053414d
 80388b8:	30534e4d 	.word	0x30534e4d

080388bc <SecureElementSetObjHandler>:
#if (!defined (LORAWAN_KMS) || (LORAWAN_KMS == 0))
    return SECURE_ELEMENT_ERROR;
#else /* LORAWAN_KMS == 1 */
    for (uint8_t i = 0; i < NUM_OF_KEYS; i++)
    {
        if (SeNvm->KeyList[i].KeyID == keyID)
 80388bc:	4b0a      	ldr	r3, [pc, #40]	; (80388e8 <SecureElementSetObjHandler+0x2c>)
 80388be:	681a      	ldr	r2, [r3, #0]
{
 80388c0:	b5f0      	push	{r4, r5, r6, r7, lr}
        if (SeNvm->KeyList[i].KeyID == keyID)
 80388c2:	2300      	movs	r3, #0
 80388c4:	f102 0510 	add.w	r5, r2, #16
 80388c8:	2618      	movs	r6, #24
 80388ca:	fb06 f403 	mul.w	r4, r6, r3
 80388ce:	5d2f      	ldrb	r7, [r5, r4]
 80388d0:	4287      	cmp	r7, r0
 80388d2:	d103      	bne.n	80388dc <SecureElementSetObjHandler+0x20>
        {
            SeNvm->KeyList[i].Object_Index = (CK_OBJECT_HANDLE) keyIndex;
 80388d4:	4422      	add	r2, r4
            return SECURE_ELEMENT_SUCCESS;
 80388d6:	2000      	movs	r0, #0
            SeNvm->KeyList[i].Object_Index = (CK_OBJECT_HANDLE) keyIndex;
 80388d8:	6251      	str	r1, [r2, #36]	; 0x24
        }
    }
    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
#endif /* LORAWAN_KMS */
}
 80388da:	bdf0      	pop	{r4, r5, r6, r7, pc}
    for (uint8_t i = 0; i < NUM_OF_KEYS; i++)
 80388dc:	3301      	adds	r3, #1
 80388de:	2b0a      	cmp	r3, #10
 80388e0:	d1f3      	bne.n	80388ca <SecureElementSetObjHandler+0xe>
    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 80388e2:	2003      	movs	r0, #3
 80388e4:	e7f9      	b.n	80388da <SecureElementSetObjHandler+0x1e>
 80388e6:	bf00      	nop
 80388e8:	20005738 	.word	0x20005738

080388ec <SecureElementInit>:
{
 80388ec:	b510      	push	{r4, lr}
    uint8_t devEUI[SE_EUI_SIZE] = LORAWAN_DEVICE_EUI;
 80388ee:	4b4c      	ldr	r3, [pc, #304]	; (8038a20 <SecureElementInit+0x134>)
{
 80388f0:	b092      	sub	sp, #72	; 0x48
    uint8_t devEUI[SE_EUI_SIZE] = LORAWAN_DEVICE_EUI;
 80388f2:	6859      	ldr	r1, [r3, #4]
{
 80388f4:	4602      	mov	r2, r0
    uint8_t devEUI[SE_EUI_SIZE] = LORAWAN_DEVICE_EUI;
 80388f6:	6818      	ldr	r0, [r3, #0]
 80388f8:	ac04      	add	r4, sp, #16
 80388fa:	c403      	stmia	r4!, {r0, r1}
    uint8_t joinEUI[SE_EUI_SIZE] = LORAWAN_JOIN_EUI;
 80388fc:	f853 0f08 	ldr.w	r0, [r3, #8]!
 8038900:	6859      	ldr	r1, [r3, #4]
 8038902:	ac06      	add	r4, sp, #24
 8038904:	c403      	stmia	r4!, {r0, r1}
    if (nvm == NULL)
 8038906:	4610      	mov	r0, r2
 8038908:	2a00      	cmp	r2, #0
 803890a:	f000 8087 	beq.w	8038a1c <SecureElementInit+0x130>
    SeNvm = nvm;
 803890e:	4c45      	ldr	r4, [pc, #276]	; (8038a24 <SecureElementInit+0x138>)
    memcpy1((uint8_t *)SeNvm->DevEui, devEUI, SE_EUI_SIZE);
 8038910:	a904      	add	r1, sp, #16
    SeNvm = nvm;
 8038912:	6022      	str	r2, [r4, #0]
    memcpy1((uint8_t *)SeNvm->DevEui, devEUI, SE_EUI_SIZE);
 8038914:	2208      	movs	r2, #8
 8038916:	f000 fb0b 	bl	8038f30 <memcpy1>
    memcpy1((uint8_t *)SeNvm->JoinEui, joinEUI, SE_EUI_SIZE);
 803891a:	6820      	ldr	r0, [r4, #0]
 803891c:	2208      	movs	r2, #8
 803891e:	4410      	add	r0, r2
 8038920:	a906      	add	r1, sp, #24
 8038922:	f000 fb05 	bl	8038f30 <memcpy1>
    SeNvm->KeyList[itr++].KeyID = APP_KEY;
 8038926:	6822      	ldr	r2, [r4, #0]
    SeNvm->KeyList[itr++].KeyID = MC_KE_KEY;
 8038928:	207f      	movs	r0, #127	; 0x7f
 803892a:	f882 0088 	strb.w	r0, [r2, #136]	; 0x88
    SeNvm->KeyList[itr++].KeyID = NWK_KEY;
 803892e:	2101      	movs	r1, #1
    SeNvm->KeyList[itr++].KeyID = MC_KEY_0;
 8038930:	2080      	movs	r0, #128	; 0x80
    SeNvm->KeyList[itr++].KeyID = NWK_KEY;
 8038932:	f882 1028 	strb.w	r1, [r2, #40]	; 0x28
    SeNvm->KeyList[itr++].KeyID = MC_KEY_0;
 8038936:	f882 00a0 	strb.w	r0, [r2, #160]	; 0xa0
    SeNvm->KeyList[itr++].KeyID = NWK_S_KEY;
 803893a:	2102      	movs	r1, #2
    SeNvm->KeyList[itr++].KeyID = MC_APP_S_KEY_0;
 803893c:	2081      	movs	r0, #129	; 0x81
    SeNvm->KeyList[itr++].KeyID = NWK_S_KEY;
 803893e:	f882 1040 	strb.w	r1, [r2, #64]	; 0x40
    SeNvm->KeyList[itr++].KeyID = MC_APP_S_KEY_0;
 8038942:	f882 00b8 	strb.w	r0, [r2, #184]	; 0xb8
    SeNvm->KeyList[itr++].KeyID = APP_S_KEY;
 8038946:	2103      	movs	r1, #3
    SeNvm->KeyList[itr++].KeyID = MC_NWK_S_KEY_0;
 8038948:	2082      	movs	r0, #130	; 0x82
    SeNvm->KeyList[itr++].KeyID = APP_KEY;
 803894a:	2300      	movs	r3, #0
    SeNvm->KeyList[itr++].KeyID = APP_S_KEY;
 803894c:	f882 1058 	strb.w	r1, [r2, #88]	; 0x58
    SeNvm->KeyList[itr++].KeyID = MC_NWK_S_KEY_0;
 8038950:	f882 00d0 	strb.w	r0, [r2, #208]	; 0xd0
    SeNvm->KeyList[itr++].KeyID = MC_ROOT_KEY;
 8038954:	2104      	movs	r1, #4
    SeNvm->KeyList[itr].KeyID = SLOT_RAND_ZERO_KEY;
 8038956:	2083      	movs	r0, #131	; 0x83
 8038958:	f882 00e8 	strb.w	r0, [r2, #232]	; 0xe8
    SeNvm->KeyList[itr++].KeyID = APP_KEY;
 803895c:	7413      	strb	r3, [r2, #16]
    SeNvm->KeyList[itr++].KeyID = MC_ROOT_KEY;
 803895e:	f882 1070 	strb.w	r1, [r2, #112]	; 0x70
    rv = C_OpenSession(0,  session_flags, NULL, 0, &session);
 8038962:	aa02      	add	r2, sp, #8
 8038964:	9200      	str	r2, [sp, #0]
 8038966:	4618      	mov	r0, r3
 8038968:	461a      	mov	r2, r3
    uint32_t ulCount = 0;
 803896a:	9303      	str	r3, [sp, #12]
    rv = C_OpenSession(0,  session_flags, NULL, 0, &session);
 803896c:	f7d0 f9f6 	bl	8008d5c <SE_KMS_OpenSession>
    if (rv == CKR_OK)
 8038970:	b978      	cbnz	r0, 8038992 <SecureElementInit+0xa6>
        rv = C_FindObjectsInit(session, NULL, 0);
 8038972:	4602      	mov	r2, r0
 8038974:	4601      	mov	r1, r0
 8038976:	9802      	ldr	r0, [sp, #8]
 8038978:	f7d0 fa9c 	bl	8008eb4 <SE_KMS_FindObjectsInit>
    if (rv == CKR_OK)
 803897c:	b948      	cbnz	r0, 8038992 <SecureElementInit+0xa6>
        rv = C_FindObjects(session, hObject, NUM_OF_KEYS, (CK_ULONG *) &ulCount);
 803897e:	9802      	ldr	r0, [sp, #8]
 8038980:	ab03      	add	r3, sp, #12
 8038982:	220a      	movs	r2, #10
 8038984:	a908      	add	r1, sp, #32
 8038986:	f7d0 fab1 	bl	8008eec <SE_KMS_FindObjects>
    if (rv == CKR_OK)
 803898a:	b910      	cbnz	r0, 8038992 <SecureElementInit+0xa6>
        rv = C_FindObjectsFinal(session);
 803898c:	9802      	ldr	r0, [sp, #8]
 803898e:	f7d0 facb 	bl	8008f28 <SE_KMS_FindObjectsFinal>
    if (ulCount <= NUM_OF_KEYS)
 8038992:	9b03      	ldr	r3, [sp, #12]
 8038994:	2b0a      	cmp	r3, #10
 8038996:	d93f      	bls.n	8038a18 <SecureElementInit+0x12c>
    if (session > 0)
 8038998:	9802      	ldr	r0, [sp, #8]
 803899a:	b108      	cbz	r0, 80389a0 <SecureElementInit+0xb4>
        (void)C_CloseSession(session);
 803899c:	f7d0 f9fe 	bl	8008d9c <SE_KMS_CloseSession>
    SecureElementSetObjHandler(APP_KEY, KMS_APP_KEY_OBJECT_HANDLE);
 80389a0:	210e      	movs	r1, #14
 80389a2:	2000      	movs	r0, #0
 80389a4:	f7ff ff8a 	bl	80388bc <SecureElementSetObjHandler>
    SecureElementSetObjHandler(NWK_KEY, KMS_NWK_KEY_OBJECT_HANDLE);
 80389a8:	210f      	movs	r1, #15
 80389aa:	2001      	movs	r0, #1
 80389ac:	f7ff ff86 	bl	80388bc <SecureElementSetObjHandler>
    SecureElementSetObjHandler(APP_S_KEY, KMS_APP_S_KEY_OBJECT_HANDLE);
 80389b0:	2111      	movs	r1, #17
 80389b2:	2003      	movs	r0, #3
 80389b4:	f7ff ff82 	bl	80388bc <SecureElementSetObjHandler>
    SecureElementSetObjHandler(NWK_S_KEY, KMS_NWK_S_KEY_OBJECT_HANDLE);
 80389b8:	2110      	movs	r1, #16
 80389ba:	2002      	movs	r0, #2
 80389bc:	f7ff ff7e 	bl	80388bc <SecureElementSetObjHandler>
    MW_LOG(TS_OFF, VLEVEL_M, "###### OTAA ######\r\n");
 80389c0:	2200      	movs	r2, #0
 80389c2:	4611      	mov	r1, r2
 80389c4:	4b18      	ldr	r3, [pc, #96]	; (8038a28 <SecureElementInit+0x13c>)
 80389c6:	2002      	movs	r0, #2
 80389c8:	f002 f998 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
    PrintKey(APP_KEY);
 80389cc:	2000      	movs	r0, #0
 80389ce:	f7ff fe81 	bl	80386d4 <PrintKey>
    PrintKey(NWK_KEY);
 80389d2:	2001      	movs	r0, #1
 80389d4:	f7ff fe7e 	bl	80386d4 <PrintKey>
    MW_LOG(TS_OFF, VLEVEL_M, "###### ABP  ######\r\n");
 80389d8:	2200      	movs	r2, #0
 80389da:	4b14      	ldr	r3, [pc, #80]	; (8038a2c <SecureElementInit+0x140>)
 80389dc:	4611      	mov	r1, r2
 80389de:	2002      	movs	r0, #2
 80389e0:	f002 f98c 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
    PrintKey(APP_S_KEY);
 80389e4:	2003      	movs	r0, #3
 80389e6:	f7ff fe75 	bl	80386d4 <PrintKey>
    PrintKey(NWK_S_KEY);
 80389ea:	2002      	movs	r0, #2
 80389ec:	f7ff fe72 	bl	80386d4 <PrintKey>
    return SECURE_ELEMENT_SUCCESS;
 80389f0:	2000      	movs	r0, #0
}
 80389f2:	b012      	add	sp, #72	; 0x48
 80389f4:	bd10      	pop	{r4, pc}
            if (hObject[i] > LAST_KMS_KEY_OBJECT_HANDLE)
 80389f6:	aa12      	add	r2, sp, #72	; 0x48
 80389f8:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80389fc:	f853 1c28 	ldr.w	r1, [r3, #-40]
 8038a00:	2912      	cmp	r1, #18
 8038a02:	d903      	bls.n	8038a0c <SecureElementInit+0x120>
                if (rv == CKR_OK)
 8038a04:	b910      	cbnz	r0, 8038a0c <SecureElementInit+0x120>
                    rv = C_DestroyObject(session, hObject[i]);
 8038a06:	9802      	ldr	r0, [sp, #8]
 8038a08:	f7d0 f9fe 	bl	8008e08 <SE_KMS_DestroyObject>
        for (uint8_t i = 0; i < ulCount; i++)
 8038a0c:	3401      	adds	r4, #1
 8038a0e:	9a03      	ldr	r2, [sp, #12]
 8038a10:	b2e3      	uxtb	r3, r4
 8038a12:	4293      	cmp	r3, r2
 8038a14:	d3ef      	bcc.n	80389f6 <SecureElementInit+0x10a>
 8038a16:	e7bf      	b.n	8038998 <SecureElementInit+0xac>
 8038a18:	2400      	movs	r4, #0
 8038a1a:	e7f8      	b.n	8038a0e <SecureElementInit+0x122>
        return SECURE_ELEMENT_ERROR_NPE;
 8038a1c:	2002      	movs	r0, #2
 8038a1e:	e7e8      	b.n	80389f2 <SecureElementInit+0x106>
 8038a20:	0803bbdc 	.word	0x0803bbdc
 8038a24:	20005738 	.word	0x20005738
 8038a28:	0803c536 	.word	0x0803c536
 8038a2c:	0803c54b 	.word	0x0803c54b

08038a30 <SecureElementComputeAesCmac>:
#endif /* LORAWAN_KMS */
}

SecureElementStatus_t SecureElementComputeAesCmac( uint8_t* micBxBuffer, uint8_t* buffer, uint16_t size,
                                                   KeyIdentifier_t keyID, uint32_t* cmac )
{
 8038a30:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8038a34:	b089      	sub	sp, #36	; 0x24
    if( keyID >= LORAMAC_CRYPTO_MULTICAST_KEYS )
 8038a36:	2b7e      	cmp	r3, #126	; 0x7e
{
 8038a38:	4681      	mov	r9, r0
 8038a3a:	9f10      	ldr	r7, [sp, #64]	; 0x40
 8038a3c:	4688      	mov	r8, r1
 8038a3e:	4616      	mov	r6, r2
 8038a40:	4618      	mov	r0, r3
    if( keyID >= LORAMAC_CRYPTO_MULTICAST_KEYS )
 8038a42:	d851      	bhi.n	8038ae8 <SecureElementComputeAesCmac+0xb8>
    if( ( buffer == NULL ) || ( cmac == NULL ) )
 8038a44:	2900      	cmp	r1, #0
 8038a46:	d04d      	beq.n	8038ae4 <SecureElementComputeAesCmac+0xb4>
 8038a48:	2f00      	cmp	r7, #0
 8038a4a:	d04b      	beq.n	8038ae4 <SecureElementComputeAesCmac+0xb4>
    uint32_t tag_lenth = 0;
 8038a4c:	2300      	movs	r3, #0
    CK_MECHANISM aes_cmac_mechanism = { CKM_AES_CMAC, (CK_VOID_PTR)NULL, 0 };
 8038a4e:	f241 028a 	movw	r2, #4234	; 0x108a
    SecureElementStatus_t retval = GetKeyIndexByID(keyID, &key_handle);
 8038a52:	a904      	add	r1, sp, #16
    CK_MECHANISM aes_cmac_mechanism = { CKM_AES_CMAC, (CK_VOID_PTR)NULL, 0 };
 8038a54:	e9cd 2305 	strd	r2, r3, [sp, #20]
    uint32_t tag_lenth = 0;
 8038a58:	9303      	str	r3, [sp, #12]
    CK_MECHANISM aes_cmac_mechanism = { CKM_AES_CMAC, (CK_VOID_PTR)NULL, 0 };
 8038a5a:	9307      	str	r3, [sp, #28]
    SecureElementStatus_t retval = GetKeyIndexByID(keyID, &key_handle);
 8038a5c:	f7ff fdcc 	bl	80385f8 <GetKeyIndexByID>
    if (retval != SECURE_ELEMENT_SUCCESS)
 8038a60:	4605      	mov	r5, r0
 8038a62:	2800      	cmp	r0, #0
 8038a64:	d131      	bne.n	8038aca <SecureElementComputeAesCmac+0x9a>
    rv = C_OpenSession(0,    session_flags, NULL, 0, &session);
 8038a66:	ab02      	add	r3, sp, #8
 8038a68:	9300      	str	r3, [sp, #0]
 8038a6a:	4602      	mov	r2, r0
 8038a6c:	4603      	mov	r3, r0
 8038a6e:	2104      	movs	r1, #4
 8038a70:	f7d0 f974 	bl	8008d5c <SE_KMS_OpenSession>
    if (rv == CKR_OK)
 8038a74:	4604      	mov	r4, r0
 8038a76:	b9f0      	cbnz	r0, 8038ab6 <SecureElementComputeAesCmac+0x86>
        rv = C_SignInit(session, &aes_cmac_mechanism, key_handle);
 8038a78:	9a04      	ldr	r2, [sp, #16]
 8038a7a:	9802      	ldr	r0, [sp, #8]
 8038a7c:	a905      	add	r1, sp, #20
 8038a7e:	f7d0 fbcd 	bl	800921c <SE_KMS_SignInit>
    if (rv == CKR_OK)
 8038a82:	4604      	mov	r4, r0
 8038a84:	b9b8      	cbnz	r0, 8038ab6 <SecureElementComputeAesCmac+0x86>
        if (micBxBuffer != NULL)
 8038a86:	ac03      	add	r4, sp, #12
 8038a88:	f1b9 0f00 	cmp.w	r9, #0
 8038a8c:	d021      	beq.n	8038ad2 <SecureElementComputeAesCmac+0xa2>
            memcpy1((uint8_t *) &input_align_combined_buf[0], (uint8_t *) micBxBuffer, SE_KEY_SIZE);
 8038a8e:	4817      	ldr	r0, [pc, #92]	; (8038aec <SecureElementComputeAesCmac+0xbc>)
 8038a90:	2210      	movs	r2, #16
 8038a92:	4649      	mov	r1, r9
 8038a94:	f000 fa4c 	bl	8038f30 <memcpy1>
            memcpy1((uint8_t *) &input_align_combined_buf[SE_KEY_SIZE], (uint8_t *) buffer, size);
 8038a98:	4632      	mov	r2, r6
 8038a9a:	4815      	ldr	r0, [pc, #84]	; (8038af0 <SecureElementComputeAesCmac+0xc0>)
 8038a9c:	4641      	mov	r1, r8
 8038a9e:	f000 fa47 	bl	8038f30 <memcpy1>
            rv = C_Sign(session, (CK_BYTE_PTR)&input_align_combined_buf[0], size + SE_KEY_SIZE, &tag[0],
 8038aa2:	4b14      	ldr	r3, [pc, #80]	; (8038af4 <SecureElementComputeAesCmac+0xc4>)
 8038aa4:	9400      	str	r4, [sp, #0]
 8038aa6:	f106 0210 	add.w	r2, r6, #16
            rv = C_Sign(session, (CK_BYTE_PTR)&input_align_combined_buf[0], size, &tag[0],
 8038aaa:	9802      	ldr	r0, [sp, #8]
 8038aac:	f5a3 7190 	sub.w	r1, r3, #288	; 0x120
 8038ab0:	f7d0 fbd0 	bl	8009254 <SE_KMS_Sign>
 8038ab4:	4604      	mov	r4, r0
    (void)C_CloseSession(session);
 8038ab6:	9802      	ldr	r0, [sp, #8]
 8038ab8:	f7d0 f970 	bl	8008d9c <SE_KMS_CloseSession>
    *cmac = (uint32_t)((uint32_t) tag[3] << 24 | (uint32_t) tag[2] << 16 | (uint32_t) tag[1] << 8 |
 8038abc:	4b0e      	ldr	r3, [pc, #56]	; (8038af8 <SecureElementComputeAesCmac+0xc8>)
        retval = SECURE_ELEMENT_ERROR;
 8038abe:	2c00      	cmp	r4, #0
    *cmac = (uint32_t)((uint32_t) tag[3] << 24 | (uint32_t) tag[2] << 16 | (uint32_t) tag[1] << 8 |
 8038ac0:	f8d3 3124 	ldr.w	r3, [r3, #292]	; 0x124
 8038ac4:	603b      	str	r3, [r7, #0]
        retval = SECURE_ELEMENT_ERROR;
 8038ac6:	bf18      	it	ne
 8038ac8:	2506      	movne	r5, #6
        // Never accept multicast key identifier for cmac computation
        return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
    }

    return ComputeCmac( micBxBuffer, buffer, size, keyID, cmac );
}
 8038aca:	4628      	mov	r0, r5
 8038acc:	b009      	add	sp, #36	; 0x24
 8038ace:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            memcpy1((uint8_t *) &input_align_combined_buf[0], (uint8_t *) buffer, size);
 8038ad2:	4632      	mov	r2, r6
 8038ad4:	4805      	ldr	r0, [pc, #20]	; (8038aec <SecureElementComputeAesCmac+0xbc>)
 8038ad6:	4641      	mov	r1, r8
 8038ad8:	f000 fa2a 	bl	8038f30 <memcpy1>
            rv = C_Sign(session, (CK_BYTE_PTR)&input_align_combined_buf[0], size, &tag[0],
 8038adc:	4b05      	ldr	r3, [pc, #20]	; (8038af4 <SecureElementComputeAesCmac+0xc4>)
 8038ade:	9400      	str	r4, [sp, #0]
 8038ae0:	4632      	mov	r2, r6
 8038ae2:	e7e2      	b.n	8038aaa <SecureElementComputeAesCmac+0x7a>
        return SECURE_ELEMENT_ERROR_NPE;
 8038ae4:	2502      	movs	r5, #2
    return ComputeCmac( micBxBuffer, buffer, size, keyID, cmac );
 8038ae6:	e7f0      	b.n	8038aca <SecureElementComputeAesCmac+0x9a>
        return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 8038ae8:	2503      	movs	r5, #3
 8038aea:	e7ee      	b.n	8038aca <SecureElementComputeAesCmac+0x9a>
 8038aec:	2000573c 	.word	0x2000573c
 8038af0:	2000574c 	.word	0x2000574c
 8038af4:	2000585c 	.word	0x2000585c
 8038af8:	20005738 	.word	0x20005738

08038afc <SecureElementVerifyAesCmac>:

SecureElementStatus_t SecureElementVerifyAesCmac( uint8_t* buffer, uint16_t size, uint32_t expectedCmac,
                                                  KeyIdentifier_t keyID )
{
 8038afc:	b5f0      	push	{r4, r5, r6, r7, lr}
 8038afe:	b08b      	sub	sp, #44	; 0x2c
 8038b00:	460e      	mov	r6, r1
 8038b02:	9203      	str	r2, [sp, #12]
    if( buffer == NULL )
 8038b04:	4607      	mov	r7, r0
 8038b06:	2800      	cmp	r0, #0
 8038b08:	d032      	beq.n	8038b70 <SecureElementVerifyAesCmac+0x74>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

    /* AES CMAC Authentication variables */
    CK_MECHANISM aes_cmac_mechanism = { CKM_AES_CMAC, (CK_VOID_PTR)NULL, 0 };
 8038b0a:	2200      	movs	r2, #0
 8038b0c:	f241 018a 	movw	r1, #4234	; 0x108a
 8038b10:	e9cd 1207 	strd	r1, r2, [sp, #28]

    retval = GetKeyIndexByID(keyID, &object_handle);
 8038b14:	4618      	mov	r0, r3
 8038b16:	a906      	add	r1, sp, #24
    CK_MECHANISM aes_cmac_mechanism = { CKM_AES_CMAC, (CK_VOID_PTR)NULL, 0 };
 8038b18:	9209      	str	r2, [sp, #36]	; 0x24
    retval = GetKeyIndexByID(keyID, &object_handle);
 8038b1a:	f7ff fd6d 	bl	80385f8 <GetKeyIndexByID>
    if (retval != SECURE_ELEMENT_SUCCESS)
 8038b1e:	4605      	mov	r5, r0
 8038b20:	bb18      	cbnz	r0, 8038b6a <SecureElementVerifyAesCmac+0x6e>
    {
        return retval;
    }

    /* Open session with KMS */
    rv = C_OpenSession(0,    session_flags, NULL, 0, &session);
 8038b22:	ab05      	add	r3, sp, #20
 8038b24:	9300      	str	r3, [sp, #0]
 8038b26:	4602      	mov	r2, r0
 8038b28:	4603      	mov	r3, r0
 8038b2a:	2104      	movs	r1, #4
 8038b2c:	f7d0 f916 	bl	8008d5c <SE_KMS_OpenSession>

    /* Configure session to Verify the message in AES CMAC with settings included into the mechanism */
    if (rv == CKR_OK)
 8038b30:	4604      	mov	r4, r0
 8038b32:	b9a0      	cbnz	r0, 8038b5e <SecureElementVerifyAesCmac+0x62>
    {
        rv = C_VerifyInit(session, &aes_cmac_mechanism, object_handle);
 8038b34:	9a06      	ldr	r2, [sp, #24]
 8038b36:	9805      	ldr	r0, [sp, #20]
 8038b38:	a907      	add	r1, sp, #28
 8038b3a:	f7d0 fbab 	bl	8009294 <SE_KMS_VerifyInit>
    }

    /* Verify the message */
    if (rv == CKR_OK)
 8038b3e:	4604      	mov	r4, r0
 8038b40:	b968      	cbnz	r0, 8038b5e <SecureElementVerifyAesCmac+0x62>
    {
        memcpy1(input_align_combined_buf, buffer, size);
 8038b42:	480c      	ldr	r0, [pc, #48]	; (8038b74 <SecureElementVerifyAesCmac+0x78>)
 8038b44:	4632      	mov	r2, r6
 8038b46:	4639      	mov	r1, r7
 8038b48:	f000 f9f2 	bl	8038f30 <memcpy1>
        rv = C_Verify(session, (CK_BYTE_PTR)input_align_combined_buf, size, (CK_BYTE_PTR)&expectedCmac, 4);
 8038b4c:	2304      	movs	r3, #4
 8038b4e:	9300      	str	r3, [sp, #0]
 8038b50:	4908      	ldr	r1, [pc, #32]	; (8038b74 <SecureElementVerifyAesCmac+0x78>)
 8038b52:	9805      	ldr	r0, [sp, #20]
 8038b54:	ab03      	add	r3, sp, #12
 8038b56:	4632      	mov	r2, r6
 8038b58:	f7d0 fbb8 	bl	80092cc <SE_KMS_Verify>
 8038b5c:	4604      	mov	r4, r0
    }

    (void)C_CloseSession(session);
 8038b5e:	9805      	ldr	r0, [sp, #20]
 8038b60:	f7d0 f91c 	bl	8008d9c <SE_KMS_CloseSession>

    if (rv != CKR_OK)
    {
        retval = SECURE_ELEMENT_ERROR;
 8038b64:	2c00      	cmp	r4, #0
 8038b66:	bf18      	it	ne
 8038b68:	2506      	movne	r5, #6
    }

#endif /* LORAWAN_KMS */

    return retval;
}
 8038b6a:	4628      	mov	r0, r5
 8038b6c:	b00b      	add	sp, #44	; 0x2c
 8038b6e:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 8038b70:	2502      	movs	r5, #2
 8038b72:	e7fa      	b.n	8038b6a <SecureElementVerifyAesCmac+0x6e>
 8038b74:	2000573c 	.word	0x2000573c

08038b78 <SecureElementAesEncrypt>:

SecureElementStatus_t SecureElementAesEncrypt( uint8_t* buffer, uint16_t size, KeyIdentifier_t keyID,
                                               uint8_t* encBuffer )
{
 8038b78:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8038b7c:	460e      	mov	r6, r1
 8038b7e:	b08e      	sub	sp, #56	; 0x38
 8038b80:	461f      	mov	r7, r3
    if( buffer == NULL || encBuffer == NULL )
 8038b82:	4680      	mov	r8, r0
 8038b84:	2800      	cmp	r0, #0
 8038b86:	d050      	beq.n	8038c2a <SecureElementAesEncrypt+0xb2>
 8038b88:	2b00      	cmp	r3, #0
 8038b8a:	d04e      	beq.n	8038c2a <SecureElementAesEncrypt+0xb2>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

    // Check if the size is divisible by 16,
    if( ( size % 16 ) != 0 )
 8038b8c:	f011 040f 	ands.w	r4, r1, #15
 8038b90:	d14d      	bne.n	8038c2e <SecureElementAesEncrypt+0xb6>
    uint32_t encrypted_length = 0;
    CK_OBJECT_HANDLE object_handle;
    uint8_t dummy_tag[SE_KEY_SIZE] = {0};
    uint32_t dummy_tag_lenth = 0;

    CK_MECHANISM aes_ecb_mechanism = { CKM_AES_ECB, (CK_VOID_PTR *) NULL, 0 };
 8038b92:	f241 0381 	movw	r3, #4225	; 0x1081

    SecureElementStatus_t retval = GetKeyIndexByID(keyID, &object_handle);
 8038b96:	a905      	add	r1, sp, #20
 8038b98:	4610      	mov	r0, r2
    uint8_t dummy_tag[SE_KEY_SIZE] = {0};
 8038b9a:	e9cd 440a 	strd	r4, r4, [sp, #40]	; 0x28
 8038b9e:	e9cd 440c 	strd	r4, r4, [sp, #48]	; 0x30
    CK_MECHANISM aes_ecb_mechanism = { CKM_AES_ECB, (CK_VOID_PTR *) NULL, 0 };
 8038ba2:	e9cd 3407 	strd	r3, r4, [sp, #28]
    uint32_t encrypted_length = 0;
 8038ba6:	9404      	str	r4, [sp, #16]
    uint32_t dummy_tag_lenth = 0;
 8038ba8:	9406      	str	r4, [sp, #24]
    CK_MECHANISM aes_ecb_mechanism = { CKM_AES_ECB, (CK_VOID_PTR *) NULL, 0 };
 8038baa:	9409      	str	r4, [sp, #36]	; 0x24
    SecureElementStatus_t retval = GetKeyIndexByID(keyID, &object_handle);
 8038bac:	f7ff fd24 	bl	80385f8 <GetKeyIndexByID>
    if (retval != SECURE_ELEMENT_SUCCESS)
 8038bb0:	4605      	mov	r5, r0
 8038bb2:	2800      	cmp	r0, #0
 8038bb4:	d135      	bne.n	8038c22 <SecureElementAesEncrypt+0xaa>
    {
        return retval;
    }

    /* Open session with KMS */
    rv = C_OpenSession(0,    session_flags, NULL, 0, &session);
 8038bb6:	ab03      	add	r3, sp, #12
 8038bb8:	9300      	str	r3, [sp, #0]
 8038bba:	4602      	mov	r2, r0
 8038bbc:	4603      	mov	r3, r0
 8038bbe:	2104      	movs	r1, #4
 8038bc0:	f7d0 f8cc 	bl	8008d5c <SE_KMS_OpenSession>

    /* Configure session to encrypt message in AES ECB with settings included into the mechanism */
    if (rv == CKR_OK)
 8038bc4:	4604      	mov	r4, r0
 8038bc6:	bb30      	cbnz	r0, 8038c16 <SecureElementAesEncrypt+0x9e>
    {
        rv = C_EncryptInit(session, &aes_ecb_mechanism, object_handle);
 8038bc8:	9a05      	ldr	r2, [sp, #20]
 8038bca:	9803      	ldr	r0, [sp, #12]
 8038bcc:	a907      	add	r1, sp, #28
 8038bce:	f7d0 f9c3 	bl	8008f58 <SE_KMS_EncryptInit>
    }

    /* Encrypt clear message */
    if (rv == CKR_OK)
 8038bd2:	4604      	mov	r4, r0
 8038bd4:	b9f8      	cbnz	r0, 8038c16 <SecureElementAesEncrypt+0x9e>
    {
        memcpy1(input_align_combined_buf, buffer, size);
 8038bd6:	4817      	ldr	r0, [pc, #92]	; (8038c34 <SecureElementAesEncrypt+0xbc>)
 8038bd8:	4632      	mov	r2, r6
 8038bda:	4641      	mov	r1, r8
 8038bdc:	f000 f9a8 	bl	8038f30 <memcpy1>
        encrypted_length = sizeof(output_align);
 8038be0:	f44f 7387 	mov.w	r3, #270	; 0x10e
 8038be4:	9304      	str	r3, [sp, #16]
        rv = C_EncryptUpdate(session, (CK_BYTE_PTR)input_align_combined_buf, size,
 8038be6:	ab04      	add	r3, sp, #16
 8038be8:	9300      	str	r3, [sp, #0]
 8038bea:	4b13      	ldr	r3, [pc, #76]	; (8038c38 <SecureElementAesEncrypt+0xc0>)
 8038bec:	9803      	ldr	r0, [sp, #12]
 8038bee:	4632      	mov	r2, r6
 8038bf0:	f5a3 7198 	sub.w	r1, r3, #304	; 0x130
 8038bf4:	f7d0 f9ec 	bl	8008fd0 <SE_KMS_EncryptUpdate>
                             output_align, (CK_ULONG_PTR)&encrypted_length);
        memcpy1(encBuffer, output_align, size);
 8038bf8:	490f      	ldr	r1, [pc, #60]	; (8038c38 <SecureElementAesEncrypt+0xc0>)
        rv = C_EncryptUpdate(session, (CK_BYTE_PTR)input_align_combined_buf, size,
 8038bfa:	4604      	mov	r4, r0
        memcpy1(encBuffer, output_align, size);
 8038bfc:	4632      	mov	r2, r6
 8038bfe:	4638      	mov	r0, r7
 8038c00:	f000 f996 	bl	8038f30 <memcpy1>
    }

    /* In this case C_EncryptFinal is just called to Free the Alloc mem */
    if (rv == CKR_OK)
 8038c04:	b93c      	cbnz	r4, 8038c16 <SecureElementAesEncrypt+0x9e>
    {
        dummy_tag_lenth = sizeof(tag);
 8038c06:	2310      	movs	r3, #16
        rv = C_EncryptFinal(session, &dummy_tag[0], (CK_ULONG_PTR)&dummy_tag_lenth);
 8038c08:	9803      	ldr	r0, [sp, #12]
        dummy_tag_lenth = sizeof(tag);
 8038c0a:	9306      	str	r3, [sp, #24]
        rv = C_EncryptFinal(session, &dummy_tag[0], (CK_ULONG_PTR)&dummy_tag_lenth);
 8038c0c:	aa06      	add	r2, sp, #24
 8038c0e:	a90a      	add	r1, sp, #40	; 0x28
 8038c10:	f7d0 f9fe 	bl	8009010 <SE_KMS_EncryptFinal>
 8038c14:	4604      	mov	r4, r0
    }

    /* Close session with KMS */
    (void)C_CloseSession(session);
 8038c16:	9803      	ldr	r0, [sp, #12]
 8038c18:	f7d0 f8c0 	bl	8008d9c <SE_KMS_CloseSession>

    if (rv != CKR_OK)
    {
        retval = SECURE_ELEMENT_ERROR;
 8038c1c:	2c00      	cmp	r4, #0
 8038c1e:	bf18      	it	ne
 8038c20:	2506      	movne	r5, #6
    }
#endif /* LORAWAN_KMS */

    return retval;
}
 8038c22:	4628      	mov	r0, r5
 8038c24:	b00e      	add	sp, #56	; 0x38
 8038c26:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 8038c2a:	2502      	movs	r5, #2
 8038c2c:	e7f9      	b.n	8038c22 <SecureElementAesEncrypt+0xaa>
        return SECURE_ELEMENT_ERROR_BUF_SIZE;
 8038c2e:	2505      	movs	r5, #5
 8038c30:	e7f7      	b.n	8038c22 <SecureElementAesEncrypt+0xaa>
 8038c32:	bf00      	nop
 8038c34:	2000573c 	.word	0x2000573c
 8038c38:	2000586c 	.word	0x2000586c

08038c3c <SecureElementSetKey>:
{
 8038c3c:	b570      	push	{r4, r5, r6, lr}
 8038c3e:	4606      	mov	r6, r0
 8038c40:	b0a0      	sub	sp, #128	; 0x80
    if( key == NULL )
 8038c42:	4608      	mov	r0, r1
 8038c44:	2900      	cmp	r1, #0
 8038c46:	d07a      	beq.n	8038d3e <SecureElementSetKey+0x102>
    CK_ULONG template_type = CKK_AES;
 8038c48:	2204      	movs	r2, #4
 8038c4a:	231f      	movs	r3, #31
 8038c4c:	e9cd 2304 	strd	r2, r3, [sp, #16]
    CK_ULONG template_true = CK_TRUE;
 8038c50:	680b      	ldr	r3, [r1, #0]
 8038c52:	ba1b      	rev	r3, r3
    uint32_t key_ui32[] =
 8038c54:	9309      	str	r3, [sp, #36]	; 0x24
 8038c56:	684b      	ldr	r3, [r1, #4]
 8038c58:	ba1b      	rev	r3, r3
 8038c5a:	930a      	str	r3, [sp, #40]	; 0x28
 8038c5c:	688b      	ldr	r3, [r1, #8]
 8038c5e:	ba1b      	rev	r3, r3
 8038c60:	930b      	str	r3, [sp, #44]	; 0x2c
 8038c62:	68cb      	ldr	r3, [r1, #12]
    uint32_t specific_label[] = {GlobalTemplateLabel, 0UL};
 8038c64:	4937      	ldr	r1, [pc, #220]	; (8038d44 <SecureElementSetKey+0x108>)
 8038c66:	ba1b      	rev	r3, r3
    uint32_t key_ui32[] =
 8038c68:	930c      	str	r3, [sp, #48]	; 0x30
    uint32_t specific_label[] = {GlobalTemplateLabel, 0UL};
 8038c6a:	2300      	movs	r3, #0
    CK_ULONG template_true = CK_TRUE;
 8038c6c:	2201      	movs	r2, #1
    uint32_t specific_label[] = {GlobalTemplateLabel, 0UL};
 8038c6e:	e9cd 1307 	strd	r1, r3, [sp, #28]
    CK_ATTRIBUTE key_attribute_template[] =
 8038c72:	a904      	add	r1, sp, #16
 8038c74:	e9cd 1212 	strd	r1, r2, [sp, #72]	; 0x48
 8038c78:	f44f 7180 	mov.w	r1, #256	; 0x100
 8038c7c:	9114      	str	r1, [sp, #80]	; 0x50
 8038c7e:	a905      	add	r1, sp, #20
 8038c80:	e9cd 1215 	strd	r1, r2, [sp, #84]	; 0x54
 8038c84:	2111      	movs	r1, #17
 8038c86:	9117      	str	r1, [sp, #92]	; 0x5c
 8038c88:	a909      	add	r1, sp, #36	; 0x24
 8038c8a:	f44f 74b1 	mov.w	r4, #354	; 0x162
 8038c8e:	9118      	str	r1, [sp, #96]	; 0x60
 8038c90:	2110      	movs	r1, #16
 8038c92:	e9cd 1419 	strd	r1, r4, [sp, #100]	; 0x64
 8038c96:	ac06      	add	r4, sp, #24
 8038c98:	e9cd 421b 	strd	r4, r2, [sp, #108]	; 0x6c
    CK_ULONG template_true = CK_TRUE;
 8038c9c:	9206      	str	r2, [sp, #24]
    CK_ATTRIBUTE key_attribute_template[] =
 8038c9e:	2203      	movs	r2, #3
 8038ca0:	921d      	str	r2, [sp, #116]	; 0x74
 8038ca2:	aa07      	add	r2, sp, #28
 8038ca4:	921e      	str	r2, [sp, #120]	; 0x78
    if ( keyID == MC_KEY_0 )
 8038ca6:	2e80      	cmp	r6, #128	; 0x80
    CK_ATTRIBUTE key_attribute_template[] =
 8038ca8:	f04f 0208 	mov.w	r2, #8
 8038cac:	9311      	str	r3, [sp, #68]	; 0x44
 8038cae:	921f      	str	r2, [sp, #124]	; 0x7c
    if ( keyID == MC_KEY_0 )
 8038cb0:	d118      	bne.n	8038ce4 <SecureElementSetKey+0xa8>
        uint8_t decryptedKey[16] = { 0 };
 8038cb2:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
 8038cb6:	e9cd 330f 	strd	r3, r3, [sp, #60]	; 0x3c
        if (SECURE_ELEMENT_SUCCESS != SecureElementAesEncrypt( key, 16, MC_KE_KEY, decryptedKey ))
 8038cba:	227f      	movs	r2, #127	; 0x7f
 8038cbc:	ab0d      	add	r3, sp, #52	; 0x34
 8038cbe:	f7ff ff5b 	bl	8038b78 <SecureElementAesEncrypt>
 8038cc2:	b118      	cbz	r0, 8038ccc <SecureElementSetKey+0x90>
        return SECURE_ELEMENT_ERROR;
 8038cc4:	2406      	movs	r4, #6
}
 8038cc6:	4620      	mov	r0, r4
 8038cc8:	b020      	add	sp, #128	; 0x80
 8038cca:	bd70      	pop	{r4, r5, r6, pc}
        key_ui32[0] = decryptedKey[3]  | (decryptedKey[2] << 8)  | (decryptedKey[1] << 16)  | (decryptedKey[0] << 24);
 8038ccc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8038cce:	ba1b      	rev	r3, r3
 8038cd0:	9309      	str	r3, [sp, #36]	; 0x24
        key_ui32[1] = decryptedKey[7]  | (decryptedKey[6] << 8)  | (decryptedKey[5] << 16)  | (decryptedKey[4] << 24);
 8038cd2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8038cd4:	ba1b      	rev	r3, r3
 8038cd6:	930a      	str	r3, [sp, #40]	; 0x28
        key_ui32[2] = decryptedKey[11] | (decryptedKey[10] << 8) | (decryptedKey[9] << 16)  | (decryptedKey[8] << 24);
 8038cd8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8038cda:	ba1b      	rev	r3, r3
 8038cdc:	930b      	str	r3, [sp, #44]	; 0x2c
        key_ui32[3] = decryptedKey[15] | (decryptedKey[14] << 8) | (decryptedKey[13] << 16) | (decryptedKey[12] << 24);
 8038cde:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8038ce0:	ba1b      	rev	r3, r3
 8038ce2:	930c      	str	r3, [sp, #48]	; 0x30
    if (SECURE_ELEMENT_SUCCESS != GetKeyIndexByID(keyID, &key_handle))
 8038ce4:	a90d      	add	r1, sp, #52	; 0x34
 8038ce6:	4630      	mov	r0, r6
 8038ce8:	f7ff fc86 	bl	80385f8 <GetKeyIndexByID>
 8038cec:	2800      	cmp	r0, #0
 8038cee:	d1e9      	bne.n	8038cc4 <SecureElementSetKey+0x88>
    if (SECURE_ELEMENT_SUCCESS != SecureElementDeleteDynamicKeys(keyID, &specific_label[1]))
 8038cf0:	a908      	add	r1, sp, #32
 8038cf2:	4630      	mov	r0, r6
 8038cf4:	f7ff fd5c 	bl	80387b0 <SecureElementDeleteDynamicKeys>
 8038cf8:	4603      	mov	r3, r0
 8038cfa:	2800      	cmp	r0, #0
 8038cfc:	d1e2      	bne.n	8038cc4 <SecureElementSetKey+0x88>
    rv = C_OpenSession(0, session_flags, NULL, 0, &session);
 8038cfe:	aa03      	add	r2, sp, #12
 8038d00:	9200      	str	r2, [sp, #0]
 8038d02:	2104      	movs	r1, #4
 8038d04:	4602      	mov	r2, r0
 8038d06:	f7d0 f829 	bl	8008d5c <SE_KMS_OpenSession>
    if (rv == CKR_OK)
 8038d0a:	4605      	mov	r5, r0
 8038d0c:	b9a8      	cbnz	r0, 8038d3a <SecureElementSetKey+0xfe>
        rv = C_CreateObject(session, key_attribute_template, sizeof(key_attribute_template) / sizeof(CK_ATTRIBUTE),
 8038d0e:	9803      	ldr	r0, [sp, #12]
 8038d10:	ab0d      	add	r3, sp, #52	; 0x34
 8038d12:	2205      	movs	r2, #5
 8038d14:	a911      	add	r1, sp, #68	; 0x44
 8038d16:	f7d0 f859 	bl	8008dcc <SE_KMS_CreateObject>
    if (rv == CKR_OK)
 8038d1a:	4605      	mov	r5, r0
 8038d1c:	b968      	cbnz	r0, 8038d3a <SecureElementSetKey+0xfe>
        retval = SecureElementSetObjHandler(keyID, key_handle);
 8038d1e:	990d      	ldr	r1, [sp, #52]	; 0x34
 8038d20:	4630      	mov	r0, r6
 8038d22:	f7ff fdcb 	bl	80388bc <SecureElementSetObjHandler>
 8038d26:	4604      	mov	r4, r0
    PrintKey(keyID);
 8038d28:	4630      	mov	r0, r6
 8038d2a:	f7ff fcd3 	bl	80386d4 <PrintKey>
    (void)C_CloseSession(session);
 8038d2e:	9803      	ldr	r0, [sp, #12]
 8038d30:	f7d0 f834 	bl	8008d9c <SE_KMS_CloseSession>
    if (rv != CKR_OK)
 8038d34:	2d00      	cmp	r5, #0
 8038d36:	d0c6      	beq.n	8038cc6 <SecureElementSetKey+0x8a>
 8038d38:	e7c4      	b.n	8038cc4 <SecureElementSetKey+0x88>
    SecureElementStatus_t retval = SECURE_ELEMENT_ERROR;
 8038d3a:	2406      	movs	r4, #6
 8038d3c:	e7f4      	b.n	8038d28 <SecureElementSetKey+0xec>
        return SECURE_ELEMENT_ERROR_NPE;
 8038d3e:	2402      	movs	r4, #2
 8038d40:	e7c1      	b.n	8038cc6 <SecureElementSetKey+0x8a>
 8038d42:	bf00      	nop
 8038d44:	444e524c 	.word	0x444e524c

08038d48 <SecureElementDeriveAndStoreKey>:

SecureElementStatus_t SecureElementDeriveAndStoreKey( uint8_t* input, KeyIdentifier_t rootKeyID,
                                                      KeyIdentifier_t targetKeyID )
{
 8038d48:	b570      	push	{r4, r5, r6, lr}
 8038d4a:	460b      	mov	r3, r1
 8038d4c:	b08e      	sub	sp, #56	; 0x38
 8038d4e:	4616      	mov	r6, r2
    if( input == NULL )
 8038d50:	2800      	cmp	r0, #0
 8038d52:	d049      	beq.n	8038de8 <SecureElementDeriveAndStoreKey+0xa0>
    }

    SecureElementStatus_t retval  = SECURE_ELEMENT_ERROR;

    // In case of MC_KE_KEY, only McRootKey can be used as root key
    if( targetKeyID == MC_KE_KEY )
 8038d54:	2a7f      	cmp	r2, #127	; 0x7f
 8038d56:	d101      	bne.n	8038d5c <SecureElementDeriveAndStoreKey+0x14>
    {
        if( rootKeyID != MC_ROOT_KEY )
 8038d58:	2904      	cmp	r1, #4
 8038d5a:	d147      	bne.n	8038dec <SecureElementDeriveAndStoreKey+0xa4>
#else /* LORAWAN_KMS == 1 */
    CK_RV rv;
    CK_SESSION_HANDLE session;
    CK_FLAGS session_flags = CKF_SERIAL_SESSION;    /* Read ONLY session */
    /* Key derivation */
    CK_MECHANISM            mech = {CKM_AES_ECB_ENCRYPT_DATA, input, SE_KEY_SIZE};
 8038d5c:	f241 1204 	movw	r2, #4356	; 0x1104
 8038d60:	e9cd 2008 	strd	r2, r0, [sp, #32]
    CK_OBJECT_HANDLE  derived_object_handle;
    CK_OBJECT_HANDLE    rootkey_object_handle;
    uint32_t specific_label[] = {GlobalTemplateLabel, 0UL};
 8038d64:	4822      	ldr	r0, [pc, #136]	; (8038df0 <SecureElementDeriveAndStoreKey+0xa8>)
    CK_MECHANISM            mech = {CKM_AES_ECB_ENCRYPT_DATA, input, SE_KEY_SIZE};
 8038d66:	2210      	movs	r2, #16
 8038d68:	920a      	str	r2, [sp, #40]	; 0x28
    uint32_t specific_label[] = {GlobalTemplateLabel, 0UL};
 8038d6a:	2200      	movs	r2, #0
 8038d6c:	e9cd 0206 	strd	r0, r2, [sp, #24]
    CK_ATTRIBUTE DeriveKey_template = {CKA_LABEL, (CK_VOID_PTR)specific_label, sizeof(specific_label)};
 8038d70:	2203      	movs	r2, #3
 8038d72:	920b      	str	r2, [sp, #44]	; 0x2c
 8038d74:	aa06      	add	r2, sp, #24
 8038d76:	920c      	str	r2, [sp, #48]	; 0x30

    /* Derive key */
    if (SECURE_ELEMENT_SUCCESS != GetKeyIndexByID(rootKeyID, &rootkey_object_handle))
 8038d78:	a905      	add	r1, sp, #20
    CK_ATTRIBUTE DeriveKey_template = {CKA_LABEL, (CK_VOID_PTR)specific_label, sizeof(specific_label)};
 8038d7a:	2208      	movs	r2, #8
    if (SECURE_ELEMENT_SUCCESS != GetKeyIndexByID(rootKeyID, &rootkey_object_handle))
 8038d7c:	4618      	mov	r0, r3
    CK_ATTRIBUTE DeriveKey_template = {CKA_LABEL, (CK_VOID_PTR)specific_label, sizeof(specific_label)};
 8038d7e:	920d      	str	r2, [sp, #52]	; 0x34
    if (SECURE_ELEMENT_SUCCESS != GetKeyIndexByID(rootKeyID, &rootkey_object_handle))
 8038d80:	f7ff fc3a 	bl	80385f8 <GetKeyIndexByID>
 8038d84:	bb50      	cbnz	r0, 8038ddc <SecureElementDeriveAndStoreKey+0x94>
    {
        return SECURE_ELEMENT_ERROR;
    }

    if (SECURE_ELEMENT_SUCCESS != GetKeyIndexByID(targetKeyID, &derived_object_handle))
 8038d86:	ac04      	add	r4, sp, #16
 8038d88:	4621      	mov	r1, r4
 8038d8a:	4630      	mov	r0, r6
 8038d8c:	f7ff fc34 	bl	80385f8 <GetKeyIndexByID>
 8038d90:	bb20      	cbnz	r0, 8038ddc <SecureElementDeriveAndStoreKey+0x94>
    {
        return SECURE_ELEMENT_ERROR;
    }

    if (SECURE_ELEMENT_SUCCESS != SecureElementDeleteDynamicKeys(targetKeyID, &specific_label[1]))
 8038d92:	a907      	add	r1, sp, #28
 8038d94:	4630      	mov	r0, r6
 8038d96:	f7ff fd0b 	bl	80387b0 <SecureElementDeleteDynamicKeys>
 8038d9a:	4603      	mov	r3, r0
 8038d9c:	b9f0      	cbnz	r0, 8038ddc <SecureElementDeriveAndStoreKey+0x94>
    {
        return SECURE_ELEMENT_ERROR;
    }

    /* Open session with KMS */
    rv = C_OpenSession(0,    session_flags, NULL, 0, &session);
 8038d9e:	aa03      	add	r2, sp, #12
 8038da0:	9200      	str	r2, [sp, #0]
 8038da2:	2104      	movs	r1, #4
 8038da4:	4602      	mov	r2, r0
 8038da6:	f7cf ffd9 	bl	8008d5c <SE_KMS_OpenSession>

    /* Derive key with pass phrase */
    if (rv == CKR_OK)
 8038daa:	4605      	mov	r5, r0
 8038dac:	b9d0      	cbnz	r0, 8038de4 <SecureElementDeriveAndStoreKey+0x9c>
    {
        rv = C_DeriveKey(session, &(mech), rootkey_object_handle,
 8038dae:	2301      	movs	r3, #1
 8038db0:	9300      	str	r3, [sp, #0]
 8038db2:	9a05      	ldr	r2, [sp, #20]
 8038db4:	9803      	ldr	r0, [sp, #12]
 8038db6:	9401      	str	r4, [sp, #4]
 8038db8:	ab0b      	add	r3, sp, #44	; 0x2c
 8038dba:	a908      	add	r1, sp, #32
 8038dbc:	f7d0 faa6 	bl	800930c <SE_KMS_DeriveKey>
                         &DeriveKey_template, sizeof(DeriveKey_template) / sizeof(CK_ATTRIBUTE), &derived_object_handle);
    }

    if (rv == CKR_OK)
 8038dc0:	4605      	mov	r5, r0
 8038dc2:	b978      	cbnz	r0, 8038de4 <SecureElementDeriveAndStoreKey+0x9c>
    {
        /* Store Derived Index in table */
        retval = SecureElementSetObjHandler(targetKeyID, derived_object_handle);
 8038dc4:	9904      	ldr	r1, [sp, #16]
 8038dc6:	4630      	mov	r0, r6
 8038dc8:	f7ff fd78 	bl	80388bc <SecureElementSetObjHandler>
 8038dcc:	4604      	mov	r4, r0
    }

    PrintKey(targetKeyID);
 8038dce:	4630      	mov	r0, r6
 8038dd0:	f7ff fc80 	bl	80386d4 <PrintKey>

    /* Close session with KMS */
    (void)C_CloseSession(session);
 8038dd4:	9803      	ldr	r0, [sp, #12]
 8038dd6:	f7cf ffe1 	bl	8008d9c <SE_KMS_CloseSession>

    if (rv != CKR_OK)
 8038dda:	b105      	cbz	r5, 8038dde <SecureElementDeriveAndStoreKey+0x96>
    {
        retval = SECURE_ELEMENT_ERROR;
 8038ddc:	2406      	movs	r4, #6
    }
    return retval;
#endif /* LORAWAN_KMS */
}
 8038dde:	4620      	mov	r0, r4
 8038de0:	b00e      	add	sp, #56	; 0x38
 8038de2:	bd70      	pop	{r4, r5, r6, pc}
    SecureElementStatus_t retval  = SECURE_ELEMENT_ERROR;
 8038de4:	2406      	movs	r4, #6
 8038de6:	e7f2      	b.n	8038dce <SecureElementDeriveAndStoreKey+0x86>
        return SECURE_ELEMENT_ERROR_NPE;
 8038de8:	2402      	movs	r4, #2
 8038dea:	e7f8      	b.n	8038dde <SecureElementDeriveAndStoreKey+0x96>
            return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 8038dec:	2403      	movs	r4, #3
 8038dee:	e7f6      	b.n	8038dde <SecureElementDeriveAndStoreKey+0x96>
 8038df0:	444e524c 	.word	0x444e524c

08038df4 <SecureElementProcessJoinAccept>:

SecureElementStatus_t SecureElementProcessJoinAccept( JoinReqIdentifier_t joinReqType, uint8_t* joinEui,
                                                      uint16_t devNonce, uint8_t* encJoinAccept,
                                                      uint8_t encJoinAcceptSize, uint8_t* decJoinAccept,
                                                      uint8_t* versionMinor )
{
 8038df4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if( ( encJoinAccept == NULL ) || ( decJoinAccept == NULL ) || ( versionMinor == NULL ) )
 8038df8:	461f      	mov	r7, r3
{
 8038dfa:	e9dd 5807 	ldrd	r5, r8, [sp, #28]
 8038dfe:	f89d 4018 	ldrb.w	r4, [sp, #24]
    if( ( encJoinAccept == NULL ) || ( decJoinAccept == NULL ) || ( versionMinor == NULL ) )
 8038e02:	b393      	cbz	r3, 8038e6a <SecureElementProcessJoinAccept+0x76>
 8038e04:	b38d      	cbz	r5, 8038e6a <SecureElementProcessJoinAccept+0x76>
 8038e06:	f1b8 0f00 	cmp.w	r8, #0
 8038e0a:	d02e      	beq.n	8038e6a <SecureElementProcessJoinAccept+0x76>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

    // Check that frame size isn't bigger than a JoinAccept with CFList size
    if( encJoinAcceptSize > LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE )
 8038e0c:	2c21      	cmp	r4, #33	; 0x21
 8038e0e:	d82e      	bhi.n	8038e6e <SecureElementProcessJoinAccept+0x7a>
    {
        encKeyID = J_S_ENC_KEY;
    }
#endif /* USE_LRWAN_1_1_X_CRYPTO == 1 */

    memcpy1( decJoinAccept, encJoinAccept, encJoinAcceptSize );
 8038e10:	b2a6      	uxth	r6, r4
 8038e12:	4619      	mov	r1, r3
 8038e14:	4632      	mov	r2, r6
 8038e16:	4628      	mov	r0, r5
 8038e18:	f000 f88a 	bl	8038f30 <memcpy1>

    // Decrypt JoinAccept, skip MHDR
    if( SecureElementAesEncrypt( encJoinAccept + LORAMAC_MHDR_FIELD_SIZE, encJoinAcceptSize - LORAMAC_MHDR_FIELD_SIZE,
 8038e1c:	1e71      	subs	r1, r6, #1
 8038e1e:	2201      	movs	r2, #1
 8038e20:	1c6b      	adds	r3, r5, #1
 8038e22:	b289      	uxth	r1, r1
 8038e24:	18b8      	adds	r0, r7, r2
 8038e26:	f7ff fea7 	bl	8038b78 <SecureElementAesEncrypt>
 8038e2a:	bb10      	cbnz	r0, 8038e72 <SecureElementProcessJoinAccept+0x7e>
                                 encKeyID, decJoinAccept + LORAMAC_MHDR_FIELD_SIZE ) != SECURE_ELEMENT_SUCCESS )
    {
        return SECURE_ELEMENT_FAIL_ENCRYPT;
    }

    *versionMinor = ( ( decJoinAccept[11] & 0x80 ) == 0x80 ) ? 1 : 0;
 8038e2c:	7aeb      	ldrb	r3, [r5, #11]
 8038e2e:	09db      	lsrs	r3, r3, #7
 8038e30:	f888 3000 	strb.w	r3, [r8]
    //  - Header buffer to be used for MIC computation
    //        - LoRaWAN 1.0.x : micHeader = [MHDR(1)]
    //        - LoRaWAN 1.1.x : micHeader = [JoinReqType(1), JoinEUI(8), DevNonce(2), MHDR(1)]

    // Verify mic
    if( *versionMinor == 0 )
 8038e34:	b9fb      	cbnz	r3, 8038e76 <SecureElementProcessJoinAccept+0x82>
    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 2] << 16 );
 8038e36:	192b      	adds	r3, r5, r4
    {
        // For LoRaWAN 1.0.x
        //   cmac = aes128_cmac(NwkKey, MHDR |  JoinNonce | NetID | DevAddr | DLSettings | RxDelay | CFList |
        //   CFListType)
        if( SecureElementVerifyAesCmac( decJoinAccept, ( encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE ), mic, NWK_KEY ) !=
 8038e38:	1f31      	subs	r1, r6, #4
    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 3] << 24 );
 8038e3a:	f813 0c01 	ldrb.w	r0, [r3, #-1]
    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 2] << 16 );
 8038e3e:	f813 2c02 	ldrb.w	r2, [r3, #-2]
    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 3] << 24 );
 8038e42:	0600      	lsls	r0, r0, #24
 8038e44:	ea40 4002 	orr.w	r0, r0, r2, lsl #16
    mic = ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE] << 0 );
 8038e48:	f813 2c04 	ldrb.w	r2, [r3, #-4]
 8038e4c:	4310      	orrs	r0, r2
    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 1] << 8 );
 8038e4e:	f813 2c03 	ldrb.w	r2, [r3, #-3]
        if( SecureElementVerifyAesCmac( decJoinAccept, ( encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE ), mic, NWK_KEY ) !=
 8038e52:	b289      	uxth	r1, r1
 8038e54:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
 8038e58:	2301      	movs	r3, #1
 8038e5a:	4628      	mov	r0, r5
 8038e5c:	f7ff fe4e 	bl	8038afc <SecureElementVerifyAesCmac>
        return SECURE_ELEMENT_ERROR_NPE;
 8038e60:	3800      	subs	r0, #0
 8038e62:	bf18      	it	ne
 8038e64:	2001      	movne	r0, #1
    {
        return SECURE_ELEMENT_ERROR_INVALID_LORAWAM_SPEC_VERSION;
    }

    return SECURE_ELEMENT_SUCCESS;
}
 8038e66:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 8038e6a:	2002      	movs	r0, #2
 8038e6c:	e7fb      	b.n	8038e66 <SecureElementProcessJoinAccept+0x72>
        return SECURE_ELEMENT_ERROR_BUF_SIZE;
 8038e6e:	2005      	movs	r0, #5
 8038e70:	e7f9      	b.n	8038e66 <SecureElementProcessJoinAccept+0x72>
        return SECURE_ELEMENT_FAIL_ENCRYPT;
 8038e72:	2007      	movs	r0, #7
 8038e74:	e7f7      	b.n	8038e66 <SecureElementProcessJoinAccept+0x72>
        return SECURE_ELEMENT_ERROR_INVALID_LORAWAM_SPEC_VERSION;
 8038e76:	2004      	movs	r0, #4
 8038e78:	e7f5      	b.n	8038e66 <SecureElementProcessJoinAccept+0x72>
	...

08038e7c <SecureElementRandomNumber>:

SecureElementStatus_t SecureElementRandomNumber( uint32_t* randomNum )
{
 8038e7c:	b510      	push	{r4, lr}
    if( randomNum == NULL )
 8038e7e:	4604      	mov	r4, r0
 8038e80:	b128      	cbz	r0, 8038e8e <SecureElementRandomNumber+0x12>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }
    *randomNum = Radio.Random();
 8038e82:	4b04      	ldr	r3, [pc, #16]	; (8038e94 <SecureElementRandomNumber+0x18>)
 8038e84:	695b      	ldr	r3, [r3, #20]
 8038e86:	4798      	blx	r3
 8038e88:	6020      	str	r0, [r4, #0]
    return SECURE_ELEMENT_SUCCESS;
 8038e8a:	2000      	movs	r0, #0
}
 8038e8c:	bd10      	pop	{r4, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 8038e8e:	2002      	movs	r0, #2
 8038e90:	e7fc      	b.n	8038e8c <SecureElementRandomNumber+0x10>
 8038e92:	bf00      	nop
 8038e94:	0803bc30 	.word	0x0803bc30

08038e98 <SecureElementSetDevEui>:

SecureElementStatus_t SecureElementSetDevEui( uint8_t* devEui )
{
 8038e98:	b508      	push	{r3, lr}
    if( devEui == NULL )
 8038e9a:	4601      	mov	r1, r0
 8038e9c:	b130      	cbz	r0, 8038eac <SecureElementSetDevEui+0x14>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }
    memcpy1( SeNvm->DevEui, devEui, SE_EUI_SIZE );
 8038e9e:	4b04      	ldr	r3, [pc, #16]	; (8038eb0 <SecureElementSetDevEui+0x18>)
 8038ea0:	2208      	movs	r2, #8
 8038ea2:	6818      	ldr	r0, [r3, #0]
 8038ea4:	f000 f844 	bl	8038f30 <memcpy1>
    return SECURE_ELEMENT_SUCCESS;
 8038ea8:	2000      	movs	r0, #0
}
 8038eaa:	bd08      	pop	{r3, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 8038eac:	2002      	movs	r0, #2
 8038eae:	e7fc      	b.n	8038eaa <SecureElementSetDevEui+0x12>
 8038eb0:	20005738 	.word	0x20005738

08038eb4 <SecureElementGetDevEui>:

uint8_t* SecureElementGetDevEui( void )
{
    return SeNvm->DevEui;
}
 8038eb4:	4b01      	ldr	r3, [pc, #4]	; (8038ebc <SecureElementGetDevEui+0x8>)
 8038eb6:	6818      	ldr	r0, [r3, #0]
 8038eb8:	4770      	bx	lr
 8038eba:	bf00      	nop
 8038ebc:	20005738 	.word	0x20005738

08038ec0 <SecureElementSetJoinEui>:

SecureElementStatus_t SecureElementSetJoinEui( uint8_t* joinEui )
{
 8038ec0:	b508      	push	{r3, lr}
    if( joinEui == NULL )
 8038ec2:	4601      	mov	r1, r0
 8038ec4:	b138      	cbz	r0, 8038ed6 <SecureElementSetJoinEui+0x16>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }
    memcpy1( SeNvm->JoinEui, joinEui, SE_EUI_SIZE );
 8038ec6:	4b05      	ldr	r3, [pc, #20]	; (8038edc <SecureElementSetJoinEui+0x1c>)
 8038ec8:	6818      	ldr	r0, [r3, #0]
 8038eca:	2208      	movs	r2, #8
 8038ecc:	4410      	add	r0, r2
 8038ece:	f000 f82f 	bl	8038f30 <memcpy1>
    return SECURE_ELEMENT_SUCCESS;
 8038ed2:	2000      	movs	r0, #0
}
 8038ed4:	bd08      	pop	{r3, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 8038ed6:	2002      	movs	r0, #2
 8038ed8:	e7fc      	b.n	8038ed4 <SecureElementSetJoinEui+0x14>
 8038eda:	bf00      	nop
 8038edc:	20005738 	.word	0x20005738

08038ee0 <SecureElementGetJoinEui>:

uint8_t* SecureElementGetJoinEui( void )
{
    return SeNvm->JoinEui;
 8038ee0:	4b01      	ldr	r3, [pc, #4]	; (8038ee8 <SecureElementGetJoinEui+0x8>)
 8038ee2:	6818      	ldr	r0, [r3, #0]
}
 8038ee4:	3008      	adds	r0, #8
 8038ee6:	4770      	bx	lr
 8038ee8:	20005738 	.word	0x20005738

08038eec <srand1>:
    return ( ( next = next * 1103515245L + 12345L ) % RAND_LOCAL_MAX );
}

void srand1( uint32_t seed )
{
    next = seed;
 8038eec:	4b01      	ldr	r3, [pc, #4]	; (8038ef4 <srand1+0x8>)
 8038eee:	6018      	str	r0, [r3, #0]
}
 8038ef0:	4770      	bx	lr
 8038ef2:	bf00      	nop
 8038ef4:	2000359c 	.word	0x2000359c

08038ef8 <randr>:
    return ( ( next = next * 1103515245L + 12345L ) % RAND_LOCAL_MAX );
 8038ef8:	4a0b      	ldr	r2, [pc, #44]	; (8038f28 <randr+0x30>)
// Standard random functions redefinition end

int32_t randr( int32_t min, int32_t max )
{
 8038efa:	b530      	push	{r4, r5, lr}
    return ( ( next = next * 1103515245L + 12345L ) % RAND_LOCAL_MAX );
 8038efc:	6813      	ldr	r3, [r2, #0]
 8038efe:	4d0b      	ldr	r5, [pc, #44]	; (8038f2c <randr+0x34>)
 8038f00:	f243 0439 	movw	r4, #12345	; 0x3039
 8038f04:	fb05 4303 	mla	r3, r5, r3, r4
 8038f08:	6013      	str	r3, [r2, #0]
    return ( int32_t )rand1( ) % ( max - min + 1 ) + min;
 8038f0a:	1a09      	subs	r1, r1, r0
    return ( ( next = next * 1103515245L + 12345L ) % RAND_LOCAL_MAX );
 8038f0c:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
 8038f10:	fbb3 f2f2 	udiv	r2, r3, r2
 8038f14:	ebc2 72c2 	rsb	r2, r2, r2, lsl #31
    return ( int32_t )rand1( ) % ( max - min + 1 ) + min;
 8038f18:	3101      	adds	r1, #1
    return ( ( next = next * 1103515245L + 12345L ) % RAND_LOCAL_MAX );
 8038f1a:	1a9b      	subs	r3, r3, r2
    return ( int32_t )rand1( ) % ( max - min + 1 ) + min;
 8038f1c:	fb93 f2f1 	sdiv	r2, r3, r1
 8038f20:	fb01 3312 	mls	r3, r1, r2, r3
}
 8038f24:	4418      	add	r0, r3
 8038f26:	bd30      	pop	{r4, r5, pc}
 8038f28:	2000359c 	.word	0x2000359c
 8038f2c:	41c64e6d 	.word	0x41c64e6d

08038f30 <memcpy1>:

void memcpy1( uint8_t *dst, const uint8_t *src, uint16_t size )
{
    while( size-- )
 8038f30:	3801      	subs	r0, #1
 8038f32:	440a      	add	r2, r1
 8038f34:	4291      	cmp	r1, r2
 8038f36:	d100      	bne.n	8038f3a <memcpy1+0xa>
    {
        *dst++ = *src++;
    }
}
 8038f38:	4770      	bx	lr
        *dst++ = *src++;
 8038f3a:	f811 3b01 	ldrb.w	r3, [r1], #1
 8038f3e:	f800 3f01 	strb.w	r3, [r0, #1]!
 8038f42:	e7f7      	b.n	8038f34 <memcpy1+0x4>

08038f44 <memcpyr>:

void memcpyr( uint8_t *dst, const uint8_t *src, uint16_t size )
{
    dst = dst + ( size - 1 );
    while( size-- )
 8038f44:	4410      	add	r0, r2
 8038f46:	440a      	add	r2, r1
 8038f48:	4291      	cmp	r1, r2
 8038f4a:	d100      	bne.n	8038f4e <memcpyr+0xa>
    {
        *dst-- = *src++;
    }
}
 8038f4c:	4770      	bx	lr
        *dst-- = *src++;
 8038f4e:	f811 3b01 	ldrb.w	r3, [r1], #1
 8038f52:	f800 3d01 	strb.w	r3, [r0, #-1]!
 8038f56:	e7f7      	b.n	8038f48 <memcpyr+0x4>

08038f58 <memset1>:

void memset1( uint8_t *dst, uint8_t value, uint16_t size )
{
    while( size-- )
 8038f58:	4402      	add	r2, r0
 8038f5a:	4290      	cmp	r0, r2
 8038f5c:	d100      	bne.n	8038f60 <memset1+0x8>
    {
        *dst++ = value;
    }
}
 8038f5e:	4770      	bx	lr
        *dst++ = value;
 8038f60:	f800 1b01 	strb.w	r1, [r0], #1
 8038f64:	e7f9      	b.n	8038f5a <memset1+0x2>
	...

08038f68 <Crc32>:
        return '?';
    }
}

uint32_t Crc32( uint8_t *buffer, uint16_t length )
{
 8038f68:	b530      	push	{r4, r5, lr}
    const uint32_t reversedPolynom = 0xEDB88320;

    // CRC initial value
    uint32_t crc = 0xFFFFFFFF;

    if( buffer == NULL )
 8038f6a:	b130      	cbz	r0, 8038f7a <Crc32+0x12>
    for( uint16_t i = 0; i < length; ++i )
    {
        crc ^= ( uint32_t )buffer[i];
        for( uint16_t i = 0; i < 8; i++ )
        {
            crc = ( crc >> 1 ) ^ ( reversedPolynom & ~( ( crc & 0x01 ) - 1 ) );
 8038f6c:	4d0a      	ldr	r5, [pc, #40]	; (8038f98 <Crc32+0x30>)
 8038f6e:	4401      	add	r1, r0
    uint32_t crc = 0xFFFFFFFF;
 8038f70:	f04f 33ff 	mov.w	r3, #4294967295
    for( uint16_t i = 0; i < length; ++i )
 8038f74:	4281      	cmp	r1, r0
 8038f76:	d101      	bne.n	8038f7c <Crc32+0x14>
        }
    }

    return ~crc;
 8038f78:	43d8      	mvns	r0, r3
}
 8038f7a:	bd30      	pop	{r4, r5, pc}
        crc ^= ( uint32_t )buffer[i];
 8038f7c:	f810 2b01 	ldrb.w	r2, [r0], #1
 8038f80:	4053      	eors	r3, r2
 8038f82:	2208      	movs	r2, #8
            crc = ( crc >> 1 ) ^ ( reversedPolynom & ~( ( crc & 0x01 ) - 1 ) );
 8038f84:	f343 0400 	sbfx	r4, r3, #0, #1
 8038f88:	3a01      	subs	r2, #1
 8038f8a:	402c      	ands	r4, r5
 8038f8c:	b292      	uxth	r2, r2
 8038f8e:	ea84 0353 	eor.w	r3, r4, r3, lsr #1
        for( uint16_t i = 0; i < 8; i++ )
 8038f92:	2a00      	cmp	r2, #0
 8038f94:	d1f6      	bne.n	8038f84 <Crc32+0x1c>
 8038f96:	e7ed      	b.n	8038f74 <Crc32+0xc>
 8038f98:	edb88320 	.word	0xedb88320

08038f9c <RadioCheckRfFrequency>:
}

static bool RadioCheckRfFrequency( uint32_t frequency )
{
    return true;
}
 8038f9c:	2001      	movs	r0, #1
 8038f9e:	4770      	bx	lr

08038fa0 <RadioOnTxTimeoutIrq>:
{
    /* ST_WORKAROUND_BEGIN: Reset DBG pin */
    DBG_GPIO_RADIO_TX(RST);
    /* ST_WORKAROUND_END */

    if( ( RadioEvents != NULL ) && ( RadioEvents->TxTimeout != NULL ) )
 8038fa0:	4b03      	ldr	r3, [pc, #12]	; (8038fb0 <RadioOnTxTimeoutIrq+0x10>)
 8038fa2:	681b      	ldr	r3, [r3, #0]
 8038fa4:	b113      	cbz	r3, 8038fac <RadioOnTxTimeoutIrq+0xc>
 8038fa6:	685b      	ldr	r3, [r3, #4]
 8038fa8:	b103      	cbz	r3, 8038fac <RadioOnTxTimeoutIrq+0xc>
    {
        RadioEvents->TxTimeout( );
 8038faa:	4718      	bx	r3
}
 8038fac:	4770      	bx	lr
 8038fae:	bf00      	nop
 8038fb0:	2000597c 	.word	0x2000597c

08038fb4 <RadioOnRxTimeoutIrq>:
{
    /* ST_WORKAROUND_BEGIN: Reset DBG pin */
    DBG_GPIO_RADIO_RX(RST);
    /* ST_WORKAROUND_END */

    if( ( RadioEvents != NULL ) && ( RadioEvents->RxTimeout != NULL ) )
 8038fb4:	4b03      	ldr	r3, [pc, #12]	; (8038fc4 <RadioOnRxTimeoutIrq+0x10>)
 8038fb6:	681b      	ldr	r3, [r3, #0]
 8038fb8:	b113      	cbz	r3, 8038fc0 <RadioOnRxTimeoutIrq+0xc>
 8038fba:	68db      	ldr	r3, [r3, #12]
 8038fbc:	b103      	cbz	r3, 8038fc0 <RadioOnRxTimeoutIrq+0xc>
    {
        RadioEvents->RxTimeout( );
 8038fbe:	4718      	bx	r3
}
 8038fc0:	4770      	bx	lr
 8038fc2:	bf00      	nop
 8038fc4:	2000597c 	.word	0x2000597c

08038fc8 <RadioRead>:
    return SUBGRF_ReadRegister(addr);
 8038fc8:	f001 baf4 	b.w	803a5b4 <SUBGRF_ReadRegister>

08038fcc <RadioWrite>:
    SUBGRF_WriteRegister(addr, data );
 8038fcc:	f001 ba2c 	b.w	803a428 <SUBGRF_WriteRegister>

08038fd0 <RadioTxCw>:
    SUBGRF_SetTxInfinitePreamble( );
    SUBGRF_SetTx( 0x0fffff );
}

static void RadioTxCw( int8_t power )
{
 8038fd0:	b508      	push	{r3, lr}
    uint8_t paselect = SUBGRF_SetRfTxPower( power );
 8038fd2:	f001 fd1c 	bl	803aa0e <SUBGRF_SetRfTxPower>
    SUBGRF_SetSwitch( paselect, RFSWITCH_TX );
 8038fd6:	2101      	movs	r1, #1
 8038fd8:	f001 fd03 	bl	803a9e2 <SUBGRF_SetSwitch>
    SUBGRF_SetTxContinuousWave( );
}
 8038fdc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    SUBGRF_SetTxContinuousWave( );
 8038fe0:	f001 b90c 	b.w	803a1fc <SUBGRF_SetTxContinuousWave>

08038fe4 <RadioSetRxDutyCycle>:
{
 8038fe4:	b538      	push	{r3, r4, r5, lr}
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_RX);
 8038fe6:	4b07      	ldr	r3, [pc, #28]	; (8039004 <RadioSetRxDutyCycle+0x20>)
{
 8038fe8:	4604      	mov	r4, r0
 8038fea:	460d      	mov	r5, r1
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_RX);
 8038fec:	f893 0056 	ldrb.w	r0, [r3, #86]	; 0x56
 8038ff0:	2100      	movs	r1, #0
 8038ff2:	f001 fcf6 	bl	803a9e2 <SUBGRF_SetSwitch>
    SUBGRF_SetRxDutyCycle( rxTime, sleepTime );
 8038ff6:	4629      	mov	r1, r5
 8038ff8:	4620      	mov	r0, r4
}
 8038ffa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    SUBGRF_SetRxDutyCycle( rxTime, sleepTime );
 8038ffe:	f001 b8d5 	b.w	803a1ac <SUBGRF_SetRxDutyCycle>
 8039002:	bf00      	nop
 8039004:	20006324 	.word	0x20006324

08039008 <RadioStandby>:
    SUBGRF_SetStandby( STDBY_RC );
 8039008:	2000      	movs	r0, #0
 803900a:	f001 b88d 	b.w	803a128 <SUBGRF_SetStandby>
	...

08039010 <RadioGetStatus>:
{
 8039010:	b508      	push	{r3, lr}
    switch( SUBGRF_GetOperatingMode( ) )
 8039012:	f001 f883 	bl	803a11c <SUBGRF_GetOperatingMode>
 8039016:	3804      	subs	r0, #4
 8039018:	b2c0      	uxtb	r0, r0
 803901a:	2803      	cmp	r0, #3
 803901c:	bf96      	itet	ls
 803901e:	4b02      	ldrls	r3, [pc, #8]	; (8039028 <RadioGetStatus+0x18>)
 8039020:	2000      	movhi	r0, #0
 8039022:	5c18      	ldrbls	r0, [r3, r0]
}
 8039024:	bd08      	pop	{r3, pc}
 8039026:	bf00      	nop
 8039028:	0803bbec 	.word	0x0803bbec

0803902c <RadioIrqProcess>:
{
 803902c:	b573      	push	{r0, r1, r4, r5, r6, lr}
    switch ( SubgRf.RadioIrq )
 803902e:	4e84      	ldr	r6, [pc, #528]	; (8039240 <RadioIrqProcess+0x214>)
 8039030:	f8b6 3054 	ldrh.w	r3, [r6, #84]	; 0x54
    uint8_t size = 0;
 8039034:	2400      	movs	r4, #0
    switch ( SubgRf.RadioIrq )
 8039036:	2b20      	cmp	r3, #32
    uint8_t size = 0;
 8039038:	f88d 4003 	strb.w	r4, [sp, #3]
    int32_t cfo = 0;
 803903c:	9401      	str	r4, [sp, #4]
    switch ( SubgRf.RadioIrq )
 803903e:	4635      	mov	r5, r6
 8039040:	f000 80d9 	beq.w	80391f6 <RadioIrqProcess+0x1ca>
 8039044:	d810      	bhi.n	8039068 <RadioIrqProcess+0x3c>
 8039046:	2b08      	cmp	r3, #8
 8039048:	d809      	bhi.n	803905e <RadioIrqProcess+0x32>
 803904a:	b15b      	cbz	r3, 8039064 <RadioIrqProcess+0x38>
 803904c:	3b01      	subs	r3, #1
 803904e:	2b07      	cmp	r3, #7
 8039050:	d808      	bhi.n	8039064 <RadioIrqProcess+0x38>
 8039052:	e8df f003 	tbb	[pc, r3]
 8039056:	4e39      	.short	0x4e39
 8039058:	0707b907 	.word	0x0707b907
 803905c:	c007      	.short	0xc007
 803905e:	2b10      	cmp	r3, #16
 8039060:	f000 80c7 	beq.w	80391f2 <RadioIrqProcess+0x1c6>
}
 8039064:	b002      	add	sp, #8
 8039066:	bd70      	pop	{r4, r5, r6, pc}
    switch ( SubgRf.RadioIrq )
 8039068:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 803906c:	f000 808c 	beq.w	8039188 <RadioIrqProcess+0x15c>
 8039070:	d811      	bhi.n	8039096 <RadioIrqProcess+0x6a>
 8039072:	2b40      	cmp	r3, #64	; 0x40
 8039074:	f000 80d2 	beq.w	803921c <RadioIrqProcess+0x1f0>
 8039078:	2b80      	cmp	r3, #128	; 0x80
 803907a:	d1f3      	bne.n	8039064 <RadioIrqProcess+0x38>
        SUBGRF_SetStandby( STDBY_RC );
 803907c:	4620      	mov	r0, r4
 803907e:	f001 f853 	bl	803a128 <SUBGRF_SetStandby>
        if( ( RadioEvents != NULL ) && ( RadioEvents->CadDone != NULL ) )
 8039082:	4b70      	ldr	r3, [pc, #448]	; (8039244 <RadioIrqProcess+0x218>)
 8039084:	681b      	ldr	r3, [r3, #0]
 8039086:	2b00      	cmp	r3, #0
 8039088:	d0ec      	beq.n	8039064 <RadioIrqProcess+0x38>
 803908a:	699b      	ldr	r3, [r3, #24]
 803908c:	2b00      	cmp	r3, #0
 803908e:	d0e9      	beq.n	8039064 <RadioIrqProcess+0x38>
            RadioEvents->CadDone( false );
 8039090:	4620      	mov	r0, r4
            RadioEvents->CadDone( true );
 8039092:	4798      	blx	r3
 8039094:	e7e6      	b.n	8039064 <RadioIrqProcess+0x38>
    switch ( SubgRf.RadioIrq )
 8039096:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 803909a:	d1e3      	bne.n	8039064 <RadioIrqProcess+0x38>
        MW_LOG( TS_ON, VLEVEL_M,  "IRQ_RX_TX_TIMEOUT\r\n" );
 803909c:	4b6a      	ldr	r3, [pc, #424]	; (8039248 <RadioIrqProcess+0x21c>)
 803909e:	2201      	movs	r2, #1
 80390a0:	4621      	mov	r1, r4
 80390a2:	2002      	movs	r0, #2
 80390a4:	f001 fe2a 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
        if( SUBGRF_GetOperatingMode( ) == MODE_TX )
 80390a8:	f001 f838 	bl	803a11c <SUBGRF_GetOperatingMode>
 80390ac:	2804      	cmp	r0, #4
 80390ae:	d179      	bne.n	80391a4 <RadioIrqProcess+0x178>
            TimerStop( &TxTimeoutTimer );
 80390b0:	4866      	ldr	r0, [pc, #408]	; (803924c <RadioIrqProcess+0x220>)
 80390b2:	f002 f945 	bl	803b340 <UTIL_TIMER_Stop>
            SUBGRF_SetStandby( STDBY_RC );
 80390b6:	4620      	mov	r0, r4
 80390b8:	f001 f836 	bl	803a128 <SUBGRF_SetStandby>
            if( ( RadioEvents != NULL ) && ( RadioEvents->TxTimeout != NULL ) )
 80390bc:	4b61      	ldr	r3, [pc, #388]	; (8039244 <RadioIrqProcess+0x218>)
 80390be:	681b      	ldr	r3, [r3, #0]
 80390c0:	2b00      	cmp	r3, #0
 80390c2:	d0cf      	beq.n	8039064 <RadioIrqProcess+0x38>
 80390c4:	685b      	ldr	r3, [r3, #4]
 80390c6:	e010      	b.n	80390ea <RadioIrqProcess+0xbe>
        TimerStop( &TxTimeoutTimer );
 80390c8:	4860      	ldr	r0, [pc, #384]	; (803924c <RadioIrqProcess+0x220>)
 80390ca:	f002 f939 	bl	803b340 <UTIL_TIMER_Stop>
        SUBGRF_SetStandby( STDBY_RC );
 80390ce:	2000      	movs	r0, #0
 80390d0:	f001 f82a 	bl	803a128 <SUBGRF_SetStandby>
        if ( RFW_Is_LongPacketModeEnabled() == 1 )
 80390d4:	f001 fd56 	bl	803ab84 <RFW_Is_LongPacketModeEnabled>
 80390d8:	2801      	cmp	r0, #1
 80390da:	d101      	bne.n	80390e0 <RadioIrqProcess+0xb4>
            RFW_DeInit_TxLongPacket( );
 80390dc:	f001 fd5b 	bl	803ab96 <RFW_DeInit_TxLongPacket>
        if( ( RadioEvents != NULL ) && ( RadioEvents->TxDone != NULL ) )
 80390e0:	4b58      	ldr	r3, [pc, #352]	; (8039244 <RadioIrqProcess+0x218>)
 80390e2:	681b      	ldr	r3, [r3, #0]
 80390e4:	2b00      	cmp	r3, #0
 80390e6:	d0bd      	beq.n	8039064 <RadioIrqProcess+0x38>
 80390e8:	681b      	ldr	r3, [r3, #0]
        if( ( RadioEvents != NULL ) && ( RadioEvents->RxError ) )
 80390ea:	2b00      	cmp	r3, #0
 80390ec:	d0ba      	beq.n	8039064 <RadioIrqProcess+0x38>
            RadioEvents->RxError( );
 80390ee:	4798      	blx	r3
}
 80390f0:	e7b8      	b.n	8039064 <RadioIrqProcess+0x38>
        TimerStop( &RxTimeoutTimer );
 80390f2:	4857      	ldr	r0, [pc, #348]	; (8039250 <RadioIrqProcess+0x224>)
 80390f4:	f002 f924 	bl	803b340 <UTIL_TIMER_Stop>
        if( SubgRf.RxContinuous == false )
 80390f8:	7874      	ldrb	r4, [r6, #1]
 80390fa:	b994      	cbnz	r4, 8039122 <RadioIrqProcess+0xf6>
            SUBGRF_SetStandby( STDBY_RC );
 80390fc:	4620      	mov	r0, r4
 80390fe:	f001 f813 	bl	803a128 <SUBGRF_SetStandby>
            SUBGRF_WriteRegister( 0x0902, 0x00 );
 8039102:	4621      	mov	r1, r4
 8039104:	f640 1002 	movw	r0, #2306	; 0x902
 8039108:	f001 f98e 	bl	803a428 <SUBGRF_WriteRegister>
            SUBGRF_WriteRegister( 0x0944, SUBGRF_ReadRegister( 0x0944 ) | ( 1 << 1 ) );
 803910c:	f640 1044 	movw	r0, #2372	; 0x944
 8039110:	f001 fa50 	bl	803a5b4 <SUBGRF_ReadRegister>
 8039114:	f040 0102 	orr.w	r1, r0, #2
 8039118:	b2c9      	uxtb	r1, r1
 803911a:	f640 1044 	movw	r0, #2372	; 0x944
 803911e:	f001 f983 	bl	803a428 <SUBGRF_WriteRegister>
        SUBGRF_GetPayload( RadioBuffer, &size , 255 );
 8039122:	4c48      	ldr	r4, [pc, #288]	; (8039244 <RadioIrqProcess+0x218>)
 8039124:	22ff      	movs	r2, #255	; 0xff
 8039126:	f10d 0103 	add.w	r1, sp, #3
 803912a:	1d20      	adds	r0, r4, #4
 803912c:	f001 fc40 	bl	803a9b0 <SUBGRF_GetPayload>
        SUBGRF_GetPacketStatus( &(SubgRf.PacketStatus) );
 8039130:	4848      	ldr	r0, [pc, #288]	; (8039254 <RadioIrqProcess+0x228>)
 8039132:	f001 f93f 	bl	803a3b4 <SUBGRF_GetPacketStatus>
        if( ( RadioEvents != NULL ) && ( RadioEvents->RxDone != NULL ) )
 8039136:	6823      	ldr	r3, [r4, #0]
 8039138:	2b00      	cmp	r3, #0
 803913a:	d093      	beq.n	8039064 <RadioIrqProcess+0x38>
 803913c:	689e      	ldr	r6, [r3, #8]
 803913e:	2e00      	cmp	r6, #0
 8039140:	d090      	beq.n	8039064 <RadioIrqProcess+0x38>
            switch ( SubgRf.PacketStatus.packetType )
 8039142:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
 8039146:	2b01      	cmp	r3, #1
 8039148:	d108      	bne.n	803915c <RadioIrqProcess+0x130>
                RadioEvents->RxDone( RadioBuffer, size, SubgRf.PacketStatus.Params.LoRa.RssiPkt, SubgRf.PacketStatus.Params.LoRa.SnrPkt );
 803914a:	f995 3031 	ldrsb.w	r3, [r5, #49]	; 0x31
 803914e:	f995 2030 	ldrsb.w	r2, [r5, #48]	; 0x30
 8039152:	f89d 1003 	ldrb.w	r1, [sp, #3]
 8039156:	1d20      	adds	r0, r4, #4
 8039158:	47b0      	blx	r6
                break;
 803915a:	e783      	b.n	8039064 <RadioIrqProcess+0x38>
                SUBGRF_GetCFO( SubgRf.ModulationParams.Params.Gfsk.BitRate, &cfo );
 803915c:	6be8      	ldr	r0, [r5, #60]	; 0x3c
 803915e:	a901      	add	r1, sp, #4
 8039160:	f001 fcc4 	bl	803aaec <SUBGRF_GetCFO>
                RadioEvents->RxDone( RadioBuffer, size, SubgRf.PacketStatus.Params.Gfsk.RssiAvg, (int8_t) DIVR(cfo, 1000) );
 8039164:	4620      	mov	r0, r4
 8039166:	9b01      	ldr	r3, [sp, #4]
 8039168:	f89d 1003 	ldrb.w	r1, [sp, #3]
 803916c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8039170:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
 8039174:	fb93 f3f2 	sdiv	r3, r3, r2
 8039178:	f850 2b04 	ldr.w	r2, [r0], #4
 803917c:	b25b      	sxtb	r3, r3
 803917e:	6894      	ldr	r4, [r2, #8]
 8039180:	f995 2029 	ldrsb.w	r2, [r5, #41]	; 0x29
 8039184:	47a0      	blx	r4
                break;
 8039186:	e76d      	b.n	8039064 <RadioIrqProcess+0x38>
        SUBGRF_SetStandby( STDBY_RC );
 8039188:	4620      	mov	r0, r4
 803918a:	f000 ffcd 	bl	803a128 <SUBGRF_SetStandby>
        if( ( RadioEvents != NULL ) && ( RadioEvents->CadDone != NULL ) )
 803918e:	4b2d      	ldr	r3, [pc, #180]	; (8039244 <RadioIrqProcess+0x218>)
 8039190:	681b      	ldr	r3, [r3, #0]
 8039192:	2b00      	cmp	r3, #0
 8039194:	f43f af66 	beq.w	8039064 <RadioIrqProcess+0x38>
 8039198:	699b      	ldr	r3, [r3, #24]
 803919a:	2b00      	cmp	r3, #0
 803919c:	f43f af62 	beq.w	8039064 <RadioIrqProcess+0x38>
            RadioEvents->CadDone( true );
 80391a0:	2001      	movs	r0, #1
 80391a2:	e776      	b.n	8039092 <RadioIrqProcess+0x66>
        else if( SUBGRF_GetOperatingMode( ) == MODE_RX )
 80391a4:	f000 ffba 	bl	803a11c <SUBGRF_GetOperatingMode>
 80391a8:	2805      	cmp	r0, #5
 80391aa:	f47f af5b 	bne.w	8039064 <RadioIrqProcess+0x38>
            TimerStop( &RxTimeoutTimer );
 80391ae:	4828      	ldr	r0, [pc, #160]	; (8039250 <RadioIrqProcess+0x224>)
 80391b0:	f002 f8c6 	bl	803b340 <UTIL_TIMER_Stop>
            SUBGRF_SetStandby( STDBY_RC );
 80391b4:	4620      	mov	r0, r4
 80391b6:	f000 ffb7 	bl	803a128 <SUBGRF_SetStandby>
            if( ( RadioEvents != NULL ) && ( RadioEvents->RxTimeout != NULL ) )
 80391ba:	4b22      	ldr	r3, [pc, #136]	; (8039244 <RadioIrqProcess+0x218>)
 80391bc:	681b      	ldr	r3, [r3, #0]
 80391be:	2b00      	cmp	r3, #0
 80391c0:	f43f af50 	beq.w	8039064 <RadioIrqProcess+0x38>
 80391c4:	68db      	ldr	r3, [r3, #12]
 80391c6:	e790      	b.n	80390ea <RadioIrqProcess+0xbe>
        MW_LOG( TS_ON, VLEVEL_M,  "PRE OK\r\n" );
 80391c8:	4b23      	ldr	r3, [pc, #140]	; (8039258 <RadioIrqProcess+0x22c>)
            MW_LOG( TS_ON, VLEVEL_M,  "HDR KO\r\n" );
 80391ca:	2201      	movs	r2, #1
 80391cc:	2100      	movs	r1, #0
 80391ce:	2002      	movs	r0, #2
 80391d0:	f001 fd94 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
 80391d4:	e746      	b.n	8039064 <RadioIrqProcess+0x38>
        MW_LOG( TS_ON, VLEVEL_M,  "SYNC OK\r\n" );
 80391d6:	4b21      	ldr	r3, [pc, #132]	; (803925c <RadioIrqProcess+0x230>)
 80391d8:	2201      	movs	r2, #1
 80391da:	2100      	movs	r1, #0
 80391dc:	2002      	movs	r0, #2
 80391de:	f001 fd8d 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
        if ( 1UL == RFW_Is_Init( ) )
 80391e2:	f001 fccd 	bl	803ab80 <RFW_Is_Init>
 80391e6:	2801      	cmp	r0, #1
 80391e8:	f47f af3c 	bne.w	8039064 <RadioIrqProcess+0x38>
            RFW_ReceivePayload( );
 80391ec:	f001 fcd4 	bl	803ab98 <RFW_ReceivePayload>
 80391f0:	e738      	b.n	8039064 <RadioIrqProcess+0x38>
        MW_LOG( TS_ON, VLEVEL_M,  "HDR OK\r\n" );
 80391f2:	4b1b      	ldr	r3, [pc, #108]	; (8039260 <RadioIrqProcess+0x234>)
 80391f4:	e7e9      	b.n	80391ca <RadioIrqProcess+0x19e>
        TimerStop( &RxTimeoutTimer );
 80391f6:	4816      	ldr	r0, [pc, #88]	; (8039250 <RadioIrqProcess+0x224>)
 80391f8:	f002 f8a2 	bl	803b340 <UTIL_TIMER_Stop>
        if( SubgRf.RxContinuous == false )
 80391fc:	7870      	ldrb	r0, [r6, #1]
 80391fe:	b908      	cbnz	r0, 8039204 <RadioIrqProcess+0x1d8>
            SUBGRF_SetStandby( STDBY_RC );
 8039200:	f000 ff92 	bl	803a128 <SUBGRF_SetStandby>
        if( ( RadioEvents != NULL ) && ( RadioEvents->RxTimeout != NULL ) )
 8039204:	4b0f      	ldr	r3, [pc, #60]	; (8039244 <RadioIrqProcess+0x218>)
 8039206:	681b      	ldr	r3, [r3, #0]
 8039208:	2b00      	cmp	r3, #0
 803920a:	f43f af2b 	beq.w	8039064 <RadioIrqProcess+0x38>
 803920e:	68db      	ldr	r3, [r3, #12]
 8039210:	2b00      	cmp	r3, #0
 8039212:	f43f af27 	beq.w	8039064 <RadioIrqProcess+0x38>
            RadioEvents->RxTimeout( );
 8039216:	4798      	blx	r3
            MW_LOG( TS_ON, VLEVEL_M,  "HDR KO\r\n" );
 8039218:	4b12      	ldr	r3, [pc, #72]	; (8039264 <RadioIrqProcess+0x238>)
 803921a:	e7d6      	b.n	80391ca <RadioIrqProcess+0x19e>
        MW_LOG( TS_ON, VLEVEL_M,  "IRQ_CRC_ERROR\r\n" );
 803921c:	4b12      	ldr	r3, [pc, #72]	; (8039268 <RadioIrqProcess+0x23c>)
 803921e:	2201      	movs	r2, #1
 8039220:	4621      	mov	r1, r4
 8039222:	2002      	movs	r0, #2
 8039224:	f001 fd6a 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
        if( SubgRf.RxContinuous == false )
 8039228:	7870      	ldrb	r0, [r6, #1]
 803922a:	b908      	cbnz	r0, 8039230 <RadioIrqProcess+0x204>
            SUBGRF_SetStandby( STDBY_RC );
 803922c:	f000 ff7c 	bl	803a128 <SUBGRF_SetStandby>
        if( ( RadioEvents != NULL ) && ( RadioEvents->RxError ) )
 8039230:	4b04      	ldr	r3, [pc, #16]	; (8039244 <RadioIrqProcess+0x218>)
 8039232:	681b      	ldr	r3, [r3, #0]
 8039234:	2b00      	cmp	r3, #0
 8039236:	f43f af15 	beq.w	8039064 <RadioIrqProcess+0x38>
 803923a:	691b      	ldr	r3, [r3, #16]
 803923c:	e755      	b.n	80390ea <RadioIrqProcess+0xbe>
 803923e:	bf00      	nop
 8039240:	20006324 	.word	0x20006324
 8039244:	2000597c 	.word	0x2000597c
 8039248:	0803c560 	.word	0x0803c560
 803924c:	2000637c 	.word	0x2000637c
 8039250:	20006394 	.word	0x20006394
 8039254:	20006348 	.word	0x20006348
 8039258:	0803c574 	.word	0x0803c574
 803925c:	0803c57d 	.word	0x0803c57d
 8039260:	0803c587 	.word	0x0803c587
 8039264:	0803c590 	.word	0x0803c590
 8039268:	0803c599 	.word	0x0803c599

0803926c <RadioOnDioIrq>:
    SubgRf.RadioIrq = radioIrq;
 803926c:	4b02      	ldr	r3, [pc, #8]	; (8039278 <RadioOnDioIrq+0xc>)
 803926e:	f8a3 0054 	strh.w	r0, [r3, #84]	; 0x54
    RADIO_IRQ_PROCESS();
 8039272:	f7ff bedb 	b.w	803902c <RadioIrqProcess>
 8039276:	bf00      	nop
 8039278:	20006324 	.word	0x20006324

0803927c <RadioGetWakeupTime>:
{
 803927c:	b508      	push	{r3, lr}
    return SUBGRF_GetRadioWakeUpTime() + RADIO_WAKEUP_TIME;
 803927e:	f001 fbdb 	bl	803aa38 <SUBGRF_GetRadioWakeUpTime>
}
 8039282:	3003      	adds	r0, #3
 8039284:	bd08      	pop	{r3, pc}

08039286 <RadioReadRegisters>:
    SUBGRF_ReadRegisters( addr, buffer, size );
 8039286:	f001 bb21 	b.w	803a8cc <SUBGRF_ReadRegisters>

0803928a <RadioWriteRegisters>:
    SUBGRF_WriteRegisters( addr, buffer, size );
 803928a:	f001 ba7f 	b.w	803a78c <SUBGRF_WriteRegisters>

0803928e <RadioRssi>:
{
 803928e:	b508      	push	{r3, lr}
    return SUBGRF_GetRssiInst( );
 8039290:	f001 f883 	bl	803a39a <SUBGRF_GetRssiInst>
}
 8039294:	b200      	sxth	r0, r0
 8039296:	bd08      	pop	{r3, pc}

08039298 <RadioSetTxContinuousWave>:
{
 8039298:	b538      	push	{r3, r4, r5, lr}
 803929a:	460d      	mov	r5, r1
 803929c:	4614      	mov	r4, r2
    SUBGRF_SetRfFrequency( freq );
 803929e:	f001 f851 	bl	803a344 <SUBGRF_SetRfFrequency>
    antswitchpow = SUBGRF_SetRfTxPower( power );
 80392a2:	4628      	mov	r0, r5
 80392a4:	f001 fbb3 	bl	803aa0e <SUBGRF_SetRfTxPower>
    TimerSetValue( &TxTimeoutTimer, timeout );
 80392a8:	4d08      	ldr	r5, [pc, #32]	; (80392cc <RadioSetTxContinuousWave+0x34>)
    SUBGRF_SetSwitch(antswitchpow, RFSWITCH_TX);
 80392aa:	2101      	movs	r1, #1
 80392ac:	f001 fb99 	bl	803a9e2 <SUBGRF_SetSwitch>
    SUBGRF_SetTxContinuousWave( );
 80392b0:	f000 ffa4 	bl	803a1fc <SUBGRF_SetTxContinuousWave>
    TimerSetValue( &TxTimeoutTimer, timeout );
 80392b4:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 80392b8:	4361      	muls	r1, r4
 80392ba:	4628      	mov	r0, r5
 80392bc:	f002 f8ca 	bl	803b454 <UTIL_TIMER_SetPeriod>
    TimerStart( &TxTimeoutTimer );
 80392c0:	4628      	mov	r0, r5
}
 80392c2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    TimerStart( &TxTimeoutTimer );
 80392c6:	f002 b88b 	b.w	803b3e0 <UTIL_TIMER_Start>
 80392ca:	bf00      	nop
 80392cc:	2000637c 	.word	0x2000637c

080392d0 <RadioSetChannel>:
    SUBGRF_SetRfFrequency( freq );
 80392d0:	f001 b838 	b.w	803a344 <SUBGRF_SetRfFrequency>

080392d4 <RadioStartCad>:
{
 80392d4:	b508      	push	{r3, lr}
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_RX);
 80392d6:	4b08      	ldr	r3, [pc, #32]	; (80392f8 <RadioStartCad+0x24>)
 80392d8:	2100      	movs	r1, #0
 80392da:	f893 0056 	ldrb.w	r0, [r3, #86]	; 0x56
 80392de:	f001 fb80 	bl	803a9e2 <SUBGRF_SetSwitch>
    SUBGRF_SetDioIrqParams( IRQ_CAD_CLEAR | IRQ_CAD_DETECTED,
 80392e2:	2300      	movs	r3, #0
 80392e4:	f44f 71c0 	mov.w	r1, #384	; 0x180
 80392e8:	461a      	mov	r2, r3
 80392ea:	4608      	mov	r0, r1
 80392ec:	f001 f800 	bl	803a2f0 <SUBGRF_SetDioIrqParams>
}
 80392f0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    SUBGRF_SetCad( );
 80392f4:	f000 bf76 	b.w	803a1e4 <SUBGRF_SetCad>
 80392f8:	20006324 	.word	0x20006324

080392fc <RadioSleep>:
{
 80392fc:	b508      	push	{r3, lr}
    SUBGRF_SetSleep( params );
 80392fe:	f04f 0004 	mov.w	r0, #4
 8039302:	f001 f9ab 	bl	803a65c <SUBGRF_SetSleep>
}
 8039306:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RADIO_DELAY_MS( 2 );
 803930a:	2002      	movs	r0, #2
 803930c:	f7f3 b99c 	b.w	802c648 <HAL_Delay>

08039310 <RadioTimeOnAir>:
{
 8039310:	b5f0      	push	{r4, r5, r6, r7, lr}
 8039312:	f8bd 5014 	ldrh.w	r5, [sp, #20]
 8039316:	f89d e018 	ldrb.w	lr, [sp, #24]
 803931a:	f89d c01c 	ldrb.w	ip, [sp, #28]
 803931e:	f89d 4020 	ldrb.w	r4, [sp, #32]
    switch( modem )
 8039322:	b140      	cbz	r0, 8039336 <RadioTimeOnAir+0x26>
 8039324:	2801      	cmp	r0, #1
 8039326:	d019      	beq.n	803935c <RadioTimeOnAir+0x4c>
 8039328:	2201      	movs	r2, #1
 803932a:	2300      	movs	r3, #0
    return DIVC(numerator, denominator); /* ST_WORKAROUND : simplified calculation with macro usage */
 803932c:	4413      	add	r3, r2
 803932e:	1e58      	subs	r0, r3, #1
 8039330:	fbb0 f0f2 	udiv	r0, r0, r2
}
 8039334:	bdf0      	pop	{r4, r5, r6, r7, pc}
           ( ( fixLen == false ) ? 8 : 0 ) + 24 +
 8039336:	f1be 0f00 	cmp.w	lr, #0
 803933a:	bf0c      	ite	eq
 803933c:	2308      	moveq	r3, #8
 803933e:	2300      	movne	r3, #0
           ( ( payloadLen + ( ( crcOn == true ) ? 2 : 0 ) ) << 3 );
 8039340:	2c00      	cmp	r4, #0
    return ( preambleLen << 3 ) +
 8039342:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
           ( ( payloadLen + ( ( crcOn == true ) ? 2 : 0 ) ) << 3 );
 8039346:	bf14      	ite	ne
 8039348:	2402      	movne	r4, #2
 803934a:	2400      	moveq	r4, #0
           ( ( fixLen == false ) ? 8 : 0 ) + 24 +
 803934c:	3318      	adds	r3, #24
           ( ( payloadLen + ( ( crcOn == true ) ? 2 : 0 ) ) << 3 );
 803934e:	4464      	add	r4, ip
           ( ( fixLen == false ) ? 8 : 0 ) + 24 +
 8039350:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
            numerator   = 1000U * RadioGetGfskTimeOnAirNumerator( datarate, coderate,
 8039354:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8039358:	4363      	muls	r3, r4
        break;
 803935a:	e7e7      	b.n	803932c <RadioTimeOnAir+0x1c>
    int32_t crDenom           = coderate + 4;
 803935c:	1d1e      	adds	r6, r3, #4
    if( ( datarate == 5 ) || ( datarate == 6 ) )
 803935e:	1f53      	subs	r3, r2, #5
 8039360:	2b01      	cmp	r3, #1
 8039362:	d802      	bhi.n	803936a <RadioTimeOnAir+0x5a>
        if( preambleLen < 12 )
 8039364:	2d0c      	cmp	r5, #12
 8039366:	bf38      	it	cc
 8039368:	250c      	movcc	r5, #12
    if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 803936a:	2900      	cmp	r1, #0
 803936c:	d138      	bne.n	80393e0 <RadioTimeOnAir+0xd0>
 803936e:	f1a2 070b 	sub.w	r7, r2, #11
 8039372:	2f01      	cmp	r7, #1
 8039374:	bf8c      	ite	hi
 8039376:	2700      	movhi	r7, #0
 8039378:	2701      	movls	r7, #1
                            ( crcOn ? 16 : 0 ) -
 803937a:	2c00      	cmp	r4, #0
 803937c:	bf14      	ite	ne
 803937e:	2410      	movne	r4, #16
 8039380:	2400      	moveq	r4, #0
    int32_t ceilNumerator = ( payloadLen << 3 ) +
 8039382:	eb04 04cc 	add.w	r4, r4, ip, lsl #3
                            ( fixLen ? 0 : 20 );
 8039386:	f1be 0f00 	cmp.w	lr, #0
 803938a:	bf14      	ite	ne
 803938c:	2000      	movne	r0, #0
 803938e:	2014      	moveq	r0, #20
                            ( crcOn ? 16 : 0 ) -
 8039390:	eba4 0482 	sub.w	r4, r4, r2, lsl #2
    if( datarate <= 6 )
 8039394:	2a06      	cmp	r2, #6
                            ( 4 * datarate ) +
 8039396:	4404      	add	r4, r0
 8039398:	ea4f 0382 	mov.w	r3, r2, lsl #2
 803939c:	f1a2 0002 	sub.w	r0, r2, #2
    if( datarate <= 6 )
 80393a0:	d902      	bls.n	80393a8 <RadioTimeOnAir+0x98>
        ceilNumerator += 8;
 80393a2:	3408      	adds	r4, #8
        if( lowDatareOptimize == true )
 80393a4:	b107      	cbz	r7, 80393a8 <RadioTimeOnAir+0x98>
            ceilDenominator = 4 * ( datarate - 2 );
 80393a6:	0083      	lsls	r3, r0, #2
        ( ( ceilNumerator + ceilDenominator - 1 ) / ceilDenominator ) * crDenom + preambleLen + 12;
 80393a8:	2c00      	cmp	r4, #0
 80393aa:	bfac      	ite	ge
 80393ac:	191c      	addge	r4, r3, r4
 80393ae:	1c1c      	addlt	r4, r3, #0
 80393b0:	3c01      	subs	r4, #1
 80393b2:	fb94 f3f3 	sdiv	r3, r4, r3
            denominator = RadioGetLoRaBandwidthInHz( Bandwidths[bandwidth] );
 80393b6:	4c0f      	ldr	r4, [pc, #60]	; (80393f4 <RadioTimeOnAir+0xe4>)
 80393b8:	4421      	add	r1, r4
    if( datarate <= 6 )
 80393ba:	2a06      	cmp	r2, #6
            denominator = RadioGetLoRaBandwidthInHz( Bandwidths[bandwidth] );
 80393bc:	7909      	ldrb	r1, [r1, #4]
        ( ( ceilNumerator + ceilDenominator - 1 ) / ceilDenominator ) * crDenom + preambleLen + 12;
 80393be:	fb06 5303 	mla	r3, r6, r3, r5
    int32_t intermediate =
 80393c2:	bf8c      	ite	hi
 80393c4:	330c      	addhi	r3, #12
        intermediate += 2;
 80393c6:	330e      	addls	r3, #14
    switch( bw )
 80393c8:	290a      	cmp	r1, #10
 80393ca:	d812      	bhi.n	80393f2 <RadioTimeOnAir+0xe2>
    return ( uint32_t )( ( 4 * intermediate + 1 ) * ( 1 << ( datarate - 2 ) ) );
 80393cc:	009b      	lsls	r3, r3, #2
 80393ce:	3301      	adds	r3, #1
 80393d0:	eb04 0481 	add.w	r4, r4, r1, lsl #2
            numerator   = 1000U * RadioGetLoRaTimeOnAirNumerator( bandwidth, datarate,
 80393d4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    return ( uint32_t )( ( 4 * intermediate + 1 ) * ( 1 << ( datarate - 2 ) ) );
 80393d8:	4083      	lsls	r3, r0
            numerator   = 1000U * RadioGetLoRaTimeOnAirNumerator( bandwidth, datarate,
 80393da:	4353      	muls	r3, r2
 80393dc:	68a2      	ldr	r2, [r4, #8]
 80393de:	e7a5      	b.n	803932c <RadioTimeOnAir+0x1c>
    if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 80393e0:	2901      	cmp	r1, #1
 80393e2:	d104      	bne.n	80393ee <RadioTimeOnAir+0xde>
        ( ( bandwidth == 1 ) && ( datarate == 12 ) ) )
 80393e4:	f1a2 030c 	sub.w	r3, r2, #12
 80393e8:	425f      	negs	r7, r3
 80393ea:	415f      	adcs	r7, r3
 80393ec:	e7c5      	b.n	803937a <RadioTimeOnAir+0x6a>
    bool    lowDatareOptimize = false;
 80393ee:	2700      	movs	r7, #0
 80393f0:	e7c3      	b.n	803937a <RadioTimeOnAir+0x6a>
    return DIVC(numerator, denominator); /* ST_WORKAROUND : simplified calculation with macro usage */
 80393f2:	deff      	udf	#255	; 0xff
 80393f4:	0803bbec 	.word	0x0803bbec

080393f8 <RadioSetMaxPayloadLength>:
    if( modem == MODEM_LORA )
 80393f8:	2801      	cmp	r0, #1
 80393fa:	4808      	ldr	r0, [pc, #32]	; (803941c <RadioSetMaxPayloadLength+0x24>)
 80393fc:	d105      	bne.n	803940a <RadioSetMaxPayloadLength+0x12>
        SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength = max;
 80393fe:	4b08      	ldr	r3, [pc, #32]	; (8039420 <RadioSetMaxPayloadLength+0x28>)
 8039400:	77c1      	strb	r1, [r0, #31]
 8039402:	7019      	strb	r1, [r3, #0]
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039404:	300e      	adds	r0, #14
 8039406:	f001 b9ff 	b.w	803a808 <SUBGRF_SetPacketParams>
        if( SubgRf.PacketParams.Params.Gfsk.HeaderType == RADIO_PACKET_VARIABLE_LENGTH )
 803940a:	7d43      	ldrb	r3, [r0, #21]
 803940c:	2b01      	cmp	r3, #1
 803940e:	d103      	bne.n	8039418 <RadioSetMaxPayloadLength+0x20>
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength = max;
 8039410:	4b03      	ldr	r3, [pc, #12]	; (8039420 <RadioSetMaxPayloadLength+0x28>)
 8039412:	7581      	strb	r1, [r0, #22]
 8039414:	7019      	strb	r1, [r3, #0]
 8039416:	e7f5      	b.n	8039404 <RadioSetMaxPayloadLength+0xc>
}
 8039418:	4770      	bx	lr
 803941a:	bf00      	nop
 803941c:	20006324 	.word	0x20006324
 8039420:	200035a0 	.word	0x200035a0

08039424 <RadioRxBoosted>:
{
 8039424:	b510      	push	{r4, lr}
 8039426:	4604      	mov	r4, r0
    if (1UL==RFW_Is_Init())
 8039428:	f001 fbaa 	bl	803ab80 <RFW_Is_Init>
 803942c:	2801      	cmp	r0, #1
 803942e:	d117      	bne.n	8039460 <RadioRxBoosted+0x3c>
      RFW_ReceiveInit();
 8039430:	f001 fbae 	bl	803ab90 <RFW_ReceiveInit>
    if( timeout != 0 )
 8039434:	b134      	cbz	r4, 8039444 <RadioRxBoosted+0x20>
        TimerSetValue( &RxTimeoutTimer, timeout );
 8039436:	4810      	ldr	r0, [pc, #64]	; (8039478 <RadioRxBoosted+0x54>)
 8039438:	4621      	mov	r1, r4
 803943a:	f002 f80b 	bl	803b454 <UTIL_TIMER_SetPeriod>
        TimerStart( &RxTimeoutTimer );
 803943e:	480e      	ldr	r0, [pc, #56]	; (8039478 <RadioRxBoosted+0x54>)
 8039440:	f001 ffce 	bl	803b3e0 <UTIL_TIMER_Start>
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_RX);
 8039444:	4c0d      	ldr	r4, [pc, #52]	; (803947c <RadioRxBoosted+0x58>)
 8039446:	2100      	movs	r1, #0
 8039448:	f894 0056 	ldrb.w	r0, [r4, #86]	; 0x56
 803944c:	f001 fac9 	bl	803a9e2 <SUBGRF_SetSwitch>
    if( SubgRf.RxContinuous == true )
 8039450:	7863      	ldrb	r3, [r4, #1]
 8039452:	b16b      	cbz	r3, 8039470 <RadioRxBoosted+0x4c>
        SUBGRF_SetRxBoosted( 0xFFFFFF ); // Rx Continuous
 8039454:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
}
 8039458:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        SUBGRF_SetRxBoosted( SubgRf.RxTimeout << 6 );
 803945c:	f000 bff4 	b.w	803a448 <SUBGRF_SetRxBoosted>
      SUBGRF_SetDioIrqParams( IRQ_RX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_CRC_ERROR | IRQ_HEADER_ERROR | IRQ_RX_DBG,
 8039460:	2300      	movs	r3, #0
 8039462:	f240 2162 	movw	r1, #610	; 0x262
 8039466:	461a      	mov	r2, r3
 8039468:	4608      	mov	r0, r1
 803946a:	f000 ff41 	bl	803a2f0 <SUBGRF_SetDioIrqParams>
 803946e:	e7e1      	b.n	8039434 <RadioRxBoosted+0x10>
        SUBGRF_SetRxBoosted( SubgRf.RxTimeout << 6 );
 8039470:	68a0      	ldr	r0, [r4, #8]
 8039472:	0180      	lsls	r0, r0, #6
 8039474:	e7f0      	b.n	8039458 <RadioRxBoosted+0x34>
 8039476:	bf00      	nop
 8039478:	20006394 	.word	0x20006394
 803947c:	20006324 	.word	0x20006324

08039480 <RadioRx>:
{
 8039480:	b510      	push	{r4, lr}
 8039482:	4604      	mov	r4, r0
    if ( 1UL == RFW_Is_Init( ) )
 8039484:	f001 fb7c 	bl	803ab80 <RFW_Is_Init>
 8039488:	2801      	cmp	r0, #1
 803948a:	d117      	bne.n	80394bc <RadioRx+0x3c>
      RFW_ReceiveInit( );
 803948c:	f001 fb80 	bl	803ab90 <RFW_ReceiveInit>
    if( timeout != 0 )
 8039490:	b134      	cbz	r4, 80394a0 <RadioRx+0x20>
        TimerSetValue( &RxTimeoutTimer, timeout );
 8039492:	4810      	ldr	r0, [pc, #64]	; (80394d4 <RadioRx+0x54>)
 8039494:	4621      	mov	r1, r4
 8039496:	f001 ffdd 	bl	803b454 <UTIL_TIMER_SetPeriod>
        TimerStart( &RxTimeoutTimer );
 803949a:	480e      	ldr	r0, [pc, #56]	; (80394d4 <RadioRx+0x54>)
 803949c:	f001 ffa0 	bl	803b3e0 <UTIL_TIMER_Start>
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_RX);
 80394a0:	4c0d      	ldr	r4, [pc, #52]	; (80394d8 <RadioRx+0x58>)
 80394a2:	2100      	movs	r1, #0
 80394a4:	f894 0056 	ldrb.w	r0, [r4, #86]	; 0x56
 80394a8:	f001 fa9b 	bl	803a9e2 <SUBGRF_SetSwitch>
    if( SubgRf.RxContinuous == true )
 80394ac:	7863      	ldrb	r3, [r4, #1]
 80394ae:	b16b      	cbz	r3, 80394cc <RadioRx+0x4c>
        SUBGRF_SetRx( 0xFFFFFF ); // Rx Continuous
 80394b0:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
}
 80394b4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        SUBGRF_SetRx( SubgRf.RxTimeout << 6 );
 80394b8:	f000 be62 	b.w	803a180 <SUBGRF_SetRx>
      SUBGRF_SetDioIrqParams( IRQ_RX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_CRC_ERROR | IRQ_HEADER_ERROR | IRQ_RX_DBG,
 80394bc:	2300      	movs	r3, #0
 80394be:	f240 2162 	movw	r1, #610	; 0x262
 80394c2:	461a      	mov	r2, r3
 80394c4:	4608      	mov	r0, r1
 80394c6:	f000 ff13 	bl	803a2f0 <SUBGRF_SetDioIrqParams>
 80394ca:	e7e1      	b.n	8039490 <RadioRx+0x10>
        SUBGRF_SetRx( SubgRf.RxTimeout << 6 );
 80394cc:	68a0      	ldr	r0, [r4, #8]
 80394ce:	0180      	lsls	r0, r0, #6
 80394d0:	e7f0      	b.n	80394b4 <RadioRx+0x34>
 80394d2:	bf00      	nop
 80394d4:	20006394 	.word	0x20006394
 80394d8:	20006324 	.word	0x20006324

080394dc <RadioSetPublicNetwork>:
    SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous = enable;
 80394dc:	4b0d      	ldr	r3, [pc, #52]	; (8039514 <RadioSetPublicNetwork+0x38>)
{
 80394de:	b510      	push	{r4, lr}
 80394e0:	4604      	mov	r4, r0
    SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous = enable;
 80394e2:	7318      	strb	r0, [r3, #12]
 80394e4:	7358      	strb	r0, [r3, #13]
    RadioSetModem( MODEM_LORA );
 80394e6:	2001      	movs	r0, #1
 80394e8:	f000 f816 	bl	8039518 <RadioSetModem>
    if( enable == true )
 80394ec:	b15c      	cbz	r4, 8039506 <RadioSetPublicNetwork+0x2a>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD, ( LORA_MAC_PUBLIC_SYNCWORD >> 8 ) & 0xFF );
 80394ee:	2134      	movs	r1, #52	; 0x34
 80394f0:	f44f 60e8 	mov.w	r0, #1856	; 0x740
 80394f4:	f000 ff98 	bl	803a428 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PUBLIC_SYNCWORD & 0xFF );
 80394f8:	2144      	movs	r1, #68	; 0x44
}
 80394fa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PRIVATE_SYNCWORD & 0xFF );
 80394fe:	f240 7041 	movw	r0, #1857	; 0x741
 8039502:	f000 bf91 	b.w	803a428 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD, ( LORA_MAC_PRIVATE_SYNCWORD >> 8 ) & 0xFF );
 8039506:	2114      	movs	r1, #20
 8039508:	f44f 60e8 	mov.w	r0, #1856	; 0x740
 803950c:	f000 ff8c 	bl	803a428 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PRIVATE_SYNCWORD & 0xFF );
 8039510:	2124      	movs	r1, #36	; 0x24
 8039512:	e7f2      	b.n	80394fa <RadioSetPublicNetwork+0x1e>
 8039514:	20006324 	.word	0x20006324

08039518 <RadioSetModem>:
{
 8039518:	b538      	push	{r3, r4, r5, lr}
    SubgRf.Modem = modem;
 803951a:	4d0f      	ldr	r5, [pc, #60]	; (8039558 <RadioSetModem+0x40>)
{
 803951c:	4604      	mov	r4, r0
    SubgRf.Modem = modem;
 803951e:	7028      	strb	r0, [r5, #0]
    RFW_SetRadioModem(modem);
 8039520:	f001 fb3b 	bl	803ab9a <RFW_SetRadioModem>
    switch( modem )
 8039524:	2c01      	cmp	r4, #1
 8039526:	d00a      	beq.n	803953e <RadioSetModem+0x26>
 8039528:	3c02      	subs	r4, #2
 803952a:	2c01      	cmp	r4, #1
 803952c:	f04f 0400 	mov.w	r4, #0
        SUBGRF_SetPacketType( PACKET_TYPE_BPSK );
 8039530:	bf94      	ite	ls
 8039532:	2002      	movls	r0, #2
        SUBGRF_SetPacketType( PACKET_TYPE_GFSK );
 8039534:	4620      	movhi	r0, r4
 8039536:	f000 ffbb 	bl	803a4b0 <SUBGRF_SetPacketType>
        SubgRf.PublicNetwork.Current = false;
 803953a:	736c      	strb	r4, [r5, #13]
}
 803953c:	bd38      	pop	{r3, r4, r5, pc}
        SUBGRF_SetPacketType( PACKET_TYPE_LORA );
 803953e:	4620      	mov	r0, r4
 8039540:	f000 ffb6 	bl	803a4b0 <SUBGRF_SetPacketType>
        if( SubgRf.PublicNetwork.Current != SubgRf.PublicNetwork.Previous )
 8039544:	7b28      	ldrb	r0, [r5, #12]
 8039546:	7b6b      	ldrb	r3, [r5, #13]
 8039548:	4283      	cmp	r3, r0
 803954a:	d0f7      	beq.n	803953c <RadioSetModem+0x24>
            SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous;
 803954c:	7368      	strb	r0, [r5, #13]
}
 803954e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
            RadioSetPublicNetwork( SubgRf.PublicNetwork.Current );
 8039552:	f7ff bfc3 	b.w	80394dc <RadioSetPublicNetwork>
 8039556:	bf00      	nop
 8039558:	20006324 	.word	0x20006324

0803955c <RadioSetTxGenericConfig>:
    }
    return status;
}

static int32_t RadioSetTxGenericConfig( GenericModems_t modem, TxConfigGeneric_t* config, int8_t power, uint32_t timeout )
{
 803955c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8039560:	4605      	mov	r5, r0
 8039562:	b087      	sub	sp, #28
    uint8_t syncword[8] = {0};
 8039564:	2700      	movs	r7, #0
 8039566:	e9cd 7701 	strd	r7, r7, [sp, #4]
{
 803956a:	460c      	mov	r4, r1
 803956c:	4691      	mov	r9, r2
 803956e:	4698      	mov	r8, r3
    RFW_DeInit( ); /* switch Off FwPacketDecoding by default */
 8039570:	f001 fb05 	bl	803ab7e <RFW_DeInit>
    switch( modem )
 8039574:	2d01      	cmp	r5, #1
 8039576:	d078      	beq.n	803966a <RadioSetTxGenericConfig+0x10e>
 8039578:	2d02      	cmp	r5, #2
 803957a:	f000 80c4 	beq.w	8039706 <RadioSetTxGenericConfig+0x1aa>
 803957e:	2d00      	cmp	r5, #0
 8039580:	d15c      	bne.n	803963c <RadioSetTxGenericConfig+0xe0>
    {
    case GENERIC_FSK:
        if( ( config->fsk.BitRate == 0 ) || ( config->fsk.PreambleLen == 0 ) )
 8039582:	68a3      	ldr	r3, [r4, #8]
 8039584:	2b00      	cmp	r3, #0
 8039586:	f000 80d2 	beq.w	803972e <RadioSetTxGenericConfig+0x1d2>
 803958a:	6922      	ldr	r2, [r4, #16]
 803958c:	2a00      	cmp	r2, #0
 803958e:	f000 80ce 	beq.w	803972e <RadioSetTxGenericConfig+0x1d2>
        {
            return -1;
        }
        if( config->fsk.SyncWordLength > 8 )
 8039592:	7d22      	ldrb	r2, [r4, #20]
 8039594:	2a08      	cmp	r2, #8
 8039596:	f200 80ca 	bhi.w	803972e <RadioSetTxGenericConfig+0x1d2>
        }
        else
        {
            for(int i = 0; i < config->fsk.SyncWordLength; i++)
            {
                syncword[i] = config->fsk.SyncWord[i];
 803959a:	a901      	add	r1, sp, #4
            for(int i = 0; i < config->fsk.SyncWordLength; i++)
 803959c:	42aa      	cmp	r2, r5
 803959e:	dc5b      	bgt.n	8039658 <RadioSetTxGenericConfig+0xfc>
            }
        }
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 80395a0:	4d64      	ldr	r5, [pc, #400]	; (8039734 <RadioSetTxGenericConfig+0x1d8>)
 80395a2:	2600      	movs	r6, #0
 80395a4:	f885 6038 	strb.w	r6, [r5, #56]	; 0x38
        SubgRf.ModulationParams.Params.Gfsk.BitRate = config->fsk.BitRate;
 80395a8:	63eb      	str	r3, [r5, #60]	; 0x3c
        SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = ( RadioModShapings_t ) config->fsk.ModulationShaping;
 80395aa:	7823      	ldrb	r3, [r4, #0]
 80395ac:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
        SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( config->fsk.Bandwidth );
 80395b0:	6860      	ldr	r0, [r4, #4]
 80395b2:	f001 fa85 	bl	803aac0 <SUBGRF_GetFskBandwidthRegValue>
 80395b6:	f885 0045 	strb.w	r0, [r5, #69]	; 0x45
        SubgRf.ModulationParams.Params.Gfsk.Fdev = config->fsk.FrequencyDeviation;
 80395ba:	68e3      	ldr	r3, [r4, #12]
 80395bc:	642b      	str	r3, [r5, #64]	; 0x40
    
        SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
        SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( config->fsk.PreambleLen ) << 3; // convert byte into bit
 80395be:	6923      	ldr	r3, [r4, #16]
        SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS; // don't care in tx
        SubgRf.PacketParams.Params.Gfsk.SyncWordLength = ( config->fsk.SyncWordLength ) << 3; // convert byte into bit
        SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF; // don't care in tx

        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING ) || ( config->fsk.HeaderType == RADIO_FSK_PACKET_2BYTES_LENGTH ) )
 80395c0:	f894 1024 	ldrb.w	r1, [r4, #36]	; 0x24
        SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 80395c4:	73ae      	strb	r6, [r5, #14]
        SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( config->fsk.PreambleLen ) << 3; // convert byte into bit
 80395c6:	00db      	lsls	r3, r3, #3
 80395c8:	822b      	strh	r3, [r5, #16]
        SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS; // don't care in tx
 80395ca:	2304      	movs	r3, #4
 80395cc:	74ab      	strb	r3, [r5, #18]
        SubgRf.PacketParams.Params.Gfsk.SyncWordLength = ( config->fsk.SyncWordLength ) << 3; // convert byte into bit
 80395ce:	7d23      	ldrb	r3, [r4, #20]
        SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF; // don't care in tx
 80395d0:	752e      	strb	r6, [r5, #20]
        SubgRf.PacketParams.Params.Gfsk.SyncWordLength = ( config->fsk.SyncWordLength ) << 3; // convert byte into bit
 80395d2:	00db      	lsls	r3, r3, #3
        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING ) || ( config->fsk.HeaderType == RADIO_FSK_PACKET_2BYTES_LENGTH ) )
 80395d4:	2902      	cmp	r1, #2
        SubgRf.PacketParams.Params.Gfsk.SyncWordLength = ( config->fsk.SyncWordLength ) << 3; // convert byte into bit
 80395d6:	74eb      	strb	r3, [r5, #19]
        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING ) || ( config->fsk.HeaderType == RADIO_FSK_PACKET_2BYTES_LENGTH ) )
 80395d8:	462e      	mov	r6, r5
 80395da:	7fe3      	ldrb	r3, [r4, #31]
 80395dc:	d002      	beq.n	80395e4 <RadioSetTxGenericConfig+0x88>
 80395de:	7fa2      	ldrb	r2, [r4, #30]
 80395e0:	2a02      	cmp	r2, #2
 80395e2:	d13e      	bne.n	8039662 <RadioSetTxGenericConfig+0x106>
        {
            /* Supports only RADIO_FSK_CRC_2_BYTES_IBM or RADIO_FSK_CRC_2_BYTES_CCIT */
            if( ( config->fsk.CrcLength != RADIO_FSK_CRC_2_BYTES_IBM ) && ( config->fsk.CrcLength != RADIO_FSK_CRC_2_BYTES_CCIT ) &&( config->fsk.CrcLength != RADIO_FSK_CRC_OFF ) )
 80395e4:	f103 020f 	add.w	r2, r3, #15
 80395e8:	b2d2      	uxtb	r2, r2
 80395ea:	2a01      	cmp	r2, #1
 80395ec:	d902      	bls.n	80395f4 <RadioSetTxGenericConfig+0x98>
 80395ee:	2b01      	cmp	r3, #1
 80395f0:	f040 809d 	bne.w	803972e <RadioSetTxGenericConfig+0x1d2>
                return -1;
            }
            ConfigGeneric_t ConfigGeneric;
            ConfigGeneric.rtx = CONFIG_TX;
            ConfigGeneric.TxConfig = config;
            if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &TxTimeoutTimer ) )
 80395f4:	4b50      	ldr	r3, [pc, #320]	; (8039738 <RadioSetTxGenericConfig+0x1dc>)
 80395f6:	4a51      	ldr	r2, [pc, #324]	; (803973c <RadioSetTxGenericConfig+0x1e0>)
 80395f8:	6819      	ldr	r1, [r3, #0]
            ConfigGeneric.TxConfig = config;
 80395fa:	9403      	str	r4, [sp, #12]
            ConfigGeneric.rtx = CONFIG_TX;
 80395fc:	2501      	movs	r5, #1
            if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &TxTimeoutTimer ) )
 80395fe:	a803      	add	r0, sp, #12
            ConfigGeneric.rtx = CONFIG_TX;
 8039600:	f88d 5014 	strb.w	r5, [sp, #20]
            if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &TxTimeoutTimer ) )
 8039604:	f001 fab8 	bl	803ab78 <RFW_Init>
 8039608:	2800      	cmp	r0, #0
 803960a:	f040 8090 	bne.w	803972e <RadioSetTxGenericConfig+0x1d2>
            {
              return -1;
            }
            /* whitening off, will be processed by FW, switch off built-in radio whitening */
            SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) RADIO_FSK_DC_FREE_OFF;
 803960e:	7630      	strb	r0, [r6, #24]
            /* Crc processed by FW, switch off built-in radio Crc */
            SubgRf.PacketParams.Params.Gfsk.CrcLength = (RadioCrcTypes_t) RADIO_CRC_OFF;
 8039610:	75f5      	strb	r5, [r6, #23]
            /* length contained in Tx, but will be processed by FW after de-whitening */
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) RADIO_PACKET_FIXED_LENGTH;
 8039612:	7570      	strb	r0, [r6, #21]
          SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) config->fsk.CrcLength;
          SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) config->fsk.Whitening;
          SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) config->fsk.HeaderType;
        }

        RadioStandby( );
 8039614:	f7ff fcf8 	bl	8039008 <RadioStandby>
        RadioSetModem( MODEM_FSK );
 8039618:	2000      	movs	r0, #0
 803961a:	f7ff ff7d 	bl	8039518 <RadioSetModem>
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 803961e:	4848      	ldr	r0, [pc, #288]	; (8039740 <RadioSetTxGenericConfig+0x1e4>)
 8039620:	f000 ff5c 	bl	803a4dc <SUBGRF_SetModulationParams>
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039624:	4847      	ldr	r0, [pc, #284]	; (8039744 <RadioSetTxGenericConfig+0x1e8>)
 8039626:	f001 f8ef 	bl	803a808 <SUBGRF_SetPacketParams>
        SUBGRF_SetSyncWord( syncword );
 803962a:	a801      	add	r0, sp, #4
 803962c:	f001 f8be 	bl	803a7ac <SUBGRF_SetSyncWord>
        SUBGRF_SetWhiteningSeed( config->fsk.whiteSeed );
 8039630:	8ba0      	ldrh	r0, [r4, #28]
 8039632:	f001 f82d 	bl	803a690 <SUBGRF_SetWhiteningSeed>
        SUBGRF_SetCrcPolynomial(config->fsk.CrcPolynomial );
 8039636:	8c20      	ldrh	r0, [r4, #32]
 8039638:	f001 f8d4 	bl	803a7e4 <SUBGRF_SetCrcPolynomial>
        break;
    default:
        break;
    }

    SubgRf.AntSwitchPaSelect = SUBGRF_SetRfTxPower( power );
 803963c:	4648      	mov	r0, r9
 803963e:	f001 f9e6 	bl	803aa0e <SUBGRF_SetRfTxPower>
 8039642:	4c3c      	ldr	r4, [pc, #240]	; (8039734 <RadioSetTxGenericConfig+0x1d8>)
 8039644:	f884 0056 	strb.w	r0, [r4, #86]	; 0x56
    RFW_SetAntSwitch( SubgRf.AntSwitchPaSelect );
 8039648:	f001 fa9e 	bl	803ab88 <RFW_SetAntSwitch>
    SubgRf.TxTimeout = timeout;
 803964c:	f8c4 8004 	str.w	r8, [r4, #4]
    return 0;
 8039650:	2000      	movs	r0, #0
}
 8039652:	b007      	add	sp, #28
 8039654:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
                syncword[i] = config->fsk.SyncWord[i];
 8039658:	69a0      	ldr	r0, [r4, #24]
 803965a:	5d40      	ldrb	r0, [r0, r5]
 803965c:	5468      	strb	r0, [r5, r1]
            for(int i = 0; i < config->fsk.SyncWordLength; i++)
 803965e:	3501      	adds	r5, #1
 8039660:	e79c      	b.n	803959c <RadioSetTxGenericConfig+0x40>
          SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) config->fsk.CrcLength;
 8039662:	75eb      	strb	r3, [r5, #23]
          SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) config->fsk.Whitening;
 8039664:	7629      	strb	r1, [r5, #24]
          SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) config->fsk.HeaderType;
 8039666:	756a      	strb	r2, [r5, #21]
 8039668:	e7d4      	b.n	8039614 <RadioSetTxGenericConfig+0xb8>
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_LORA;
 803966a:	4e32      	ldr	r6, [pc, #200]	; (8039734 <RadioSetTxGenericConfig+0x1d8>)
 803966c:	f886 5038 	strb.w	r5, [r6, #56]	; 0x38
        SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t ) config->lora.SpreadingFactor;
 8039670:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 8039674:	f886 3050 	strb.w	r3, [r6, #80]	; 0x50
        SubgRf.ModulationParams.Params.LoRa.Bandwidth = ( RadioLoRaBandwidths_t ) config->lora.Bandwidth;
 8039678:	f894 2029 	ldrb.w	r2, [r4, #41]	; 0x29
 803967c:	f886 2051 	strb.w	r2, [r6, #81]	; 0x51
        SubgRf.ModulationParams.Params.LoRa.CodingRate = ( RadioLoRaCodingRates_t ) config->lora.Coderate;
 8039680:	f894 202a 	ldrb.w	r2, [r4, #42]	; 0x2a
 8039684:	f886 2052 	strb.w	r2, [r6, #82]	; 0x52
        switch( config->lora.LowDatarateOptimize )
 8039688:	f894 102b 	ldrb.w	r1, [r4, #43]	; 0x2b
 803968c:	2901      	cmp	r1, #1
 803968e:	d002      	beq.n	8039696 <RadioSetTxGenericConfig+0x13a>
 8039690:	2902      	cmp	r1, #2
 8039692:	d02b      	beq.n	80396ec <RadioSetTxGenericConfig+0x190>
 8039694:	b909      	cbnz	r1, 803969a <RadioSetTxGenericConfig+0x13e>
            SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 1;
 8039696:	f886 1053 	strb.w	r1, [r6, #83]	; 0x53
        SubgRf.PacketParams.Params.LoRa.PreambleLength = config->lora.PreambleLen;
 803969a:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 803969c:	83b3      	strh	r3, [r6, #28]
        SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t ) config->lora.LengthMode;
 803969e:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
 80396a2:	77b3      	strb	r3, [r6, #30]
        SubgRf.PacketParams.Params.LoRa.CrcMode = ( RadioLoRaCrcModes_t ) config->lora.CrcMode;
 80396a4:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
 80396a8:	f886 3020 	strb.w	r3, [r6, #32]
        SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 80396ac:	2501      	movs	r5, #1
        SubgRf.PacketParams.Params.LoRa.InvertIQ = ( RadioLoRaIQModes_t ) config->lora.IqInverted;
 80396ae:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
 80396b2:	f886 3021 	strb.w	r3, [r6, #33]	; 0x21
        SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 80396b6:	73b5      	strb	r5, [r6, #14]
        RadioStandby( );
 80396b8:	f7ff fca6 	bl	8039008 <RadioStandby>
        RadioSetModem( MODEM_LORA );
 80396bc:	4628      	mov	r0, r5
 80396be:	f7ff ff2b 	bl	8039518 <RadioSetModem>
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 80396c2:	481f      	ldr	r0, [pc, #124]	; (8039740 <RadioSetTxGenericConfig+0x1e4>)
 80396c4:	f000 ff0a 	bl	803a4dc <SUBGRF_SetModulationParams>
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 80396c8:	481e      	ldr	r0, [pc, #120]	; (8039744 <RadioSetTxGenericConfig+0x1e8>)
 80396ca:	f001 f89d 	bl	803a808 <SUBGRF_SetPacketParams>
        if( SubgRf.ModulationParams.Params.LoRa.Bandwidth == LORA_BW_500 )
 80396ce:	f896 3051 	ldrb.w	r3, [r6, #81]	; 0x51
 80396d2:	2b06      	cmp	r3, #6
            SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) & ~( 1 << 2 ) );
 80396d4:	f640 0089 	movw	r0, #2185	; 0x889
        if( SubgRf.ModulationParams.Params.LoRa.Bandwidth == LORA_BW_500 )
 80396d8:	d10f      	bne.n	80396fa <RadioSetTxGenericConfig+0x19e>
            SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) & ~( 1 << 2 ) );
 80396da:	f000 ff6b 	bl	803a5b4 <SUBGRF_ReadRegister>
 80396de:	f000 01fb 	and.w	r1, r0, #251	; 0xfb
            SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) | ( 1 << 2 ) );
 80396e2:	f640 0089 	movw	r0, #2185	; 0x889
 80396e6:	f000 fe9f 	bl	803a428 <SUBGRF_WriteRegister>
 80396ea:	e7a7      	b.n	803963c <RadioSetTxGenericConfig+0xe0>
            if( ( config->lora.SpreadingFactor == RADIO_LORA_SF11 ) || ( config->lora.SpreadingFactor == RADIO_LORA_SF12 ) )
 80396ec:	3b0b      	subs	r3, #11
              SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 1;
 80396ee:	2b01      	cmp	r3, #1
 80396f0:	bf88      	it	hi
 80396f2:	463d      	movhi	r5, r7
 80396f4:	f886 5053 	strb.w	r5, [r6, #83]	; 0x53
 80396f8:	e7cf      	b.n	803969a <RadioSetTxGenericConfig+0x13e>
            SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) | ( 1 << 2 ) );
 80396fa:	f000 ff5b 	bl	803a5b4 <SUBGRF_ReadRegister>
 80396fe:	f040 0104 	orr.w	r1, r0, #4
 8039702:	b2c9      	uxtb	r1, r1
 8039704:	e7ed      	b.n	80396e2 <RadioSetTxGenericConfig+0x186>
        if( ( config->bpsk.BitRate == 0 ) || ( config->bpsk.BitRate > 1000 ) )
 8039706:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8039708:	3b01      	subs	r3, #1
 803970a:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 803970e:	d20e      	bcs.n	803972e <RadioSetTxGenericConfig+0x1d2>
        RadioSetModem( MODEM_BPSK );
 8039710:	4628      	mov	r0, r5
 8039712:	f7ff ff01 	bl	8039518 <RadioSetModem>
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_BPSK;
 8039716:	4807      	ldr	r0, [pc, #28]	; (8039734 <RadioSetTxGenericConfig+0x1d8>)
 8039718:	f880 5038 	strb.w	r5, [r0, #56]	; 0x38
        SubgRf.ModulationParams.Params.Bpsk.BitRate = config->bpsk.BitRate;
 803971c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 803971e:	6483      	str	r3, [r0, #72]	; 0x48
        SubgRf.ModulationParams.Params.Bpsk.ModulationShaping = MOD_SHAPING_DBPSK;
 8039720:	2316      	movs	r3, #22
 8039722:	f880 304c 	strb.w	r3, [r0, #76]	; 0x4c
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8039726:	3038      	adds	r0, #56	; 0x38
 8039728:	f000 fed8 	bl	803a4dc <SUBGRF_SetModulationParams>
        break;
 803972c:	e786      	b.n	803963c <RadioSetTxGenericConfig+0xe0>
            return -1;
 803972e:	f04f 30ff 	mov.w	r0, #4294967295
 8039732:	e78e      	b.n	8039652 <RadioSetTxGenericConfig+0xf6>
 8039734:	20006324 	.word	0x20006324
 8039738:	2000597c 	.word	0x2000597c
 803973c:	2000637c 	.word	0x2000637c
 8039740:	2000635c 	.word	0x2000635c
 8039744:	20006332 	.word	0x20006332

08039748 <RadioSetRxGenericConfig>:
{
 8039748:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uint8_t syncword[8] = {0};
 803974c:	2600      	movs	r6, #0
{
 803974e:	b086      	sub	sp, #24
 8039750:	4698      	mov	r8, r3
 8039752:	4614      	mov	r4, r2
    uint8_t syncword[8] = {0};
 8039754:	e9cd 6601 	strd	r6, r6, [sp, #4]
{
 8039758:	4607      	mov	r7, r0
 803975a:	460d      	mov	r5, r1
    RFW_DeInit( ); /* switch Off FwPacketDecoding by default */
 803975c:	f001 fa0f 	bl	803ab7e <RFW_DeInit>
        symbTimeout = 0;
 8039760:	42b4      	cmp	r4, r6
    SubgRf.RxContinuous = ( rxContinuous == 0 ) ? false : true;
 8039762:	4c77      	ldr	r4, [pc, #476]	; (8039940 <RadioSetRxGenericConfig+0x1f8>)
 8039764:	bf16      	itet	ne
 8039766:	2301      	movne	r3, #1
 8039768:	4633      	moveq	r3, r6
        symbTimeout = 0;
 803976a:	46b0      	movne	r8, r6
    SubgRf.RxContinuous = ( rxContinuous == 0 ) ? false : true;
 803976c:	7063      	strb	r3, [r4, #1]
    switch( modem )
 803976e:	b137      	cbz	r7, 803977e <RadioSetRxGenericConfig+0x36>
 8039770:	2f01      	cmp	r7, #1
 8039772:	f000 8082 	beq.w	803987a <RadioSetRxGenericConfig+0x132>
    return status;
 8039776:	2000      	movs	r0, #0
}
 8039778:	b006      	add	sp, #24
 803977a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if( ( config->fsk.BitRate == 0 ) || ( config->fsk.PreambleLen == 0 ) )
 803977e:	68eb      	ldr	r3, [r5, #12]
 8039780:	2b00      	cmp	r3, #0
 8039782:	f000 80d9 	beq.w	8039938 <RadioSetRxGenericConfig+0x1f0>
 8039786:	692b      	ldr	r3, [r5, #16]
 8039788:	2b00      	cmp	r3, #0
 803978a:	f000 80d5 	beq.w	8039938 <RadioSetRxGenericConfig+0x1f0>
        if( config->fsk.SyncWordLength > 8 )
 803978e:	7d6b      	ldrb	r3, [r5, #21]
 8039790:	2b08      	cmp	r3, #8
 8039792:	f200 80d1 	bhi.w	8039938 <RadioSetRxGenericConfig+0x1f0>
            for(int i = 0; i < config->fsk.SyncWordLength; i++)
 8039796:	4638      	mov	r0, r7
                syncword[i] = config->fsk.SyncWord[i];
 8039798:	aa01      	add	r2, sp, #4
            for(int i = 0; i < config->fsk.SyncWordLength; i++)
 803979a:	4283      	cmp	r3, r0
 803979c:	dc62      	bgt.n	8039864 <RadioSetRxGenericConfig+0x11c>
        SUBGRF_SetStopRxTimerOnPreambleDetect( ( config->fsk.StopTimerOnPreambleDetect == 0 ) ? false : true );
 803979e:	6828      	ldr	r0, [r5, #0]
 80397a0:	3800      	subs	r0, #0
 80397a2:	bf18      	it	ne
 80397a4:	2001      	movne	r0, #1
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 80397a6:	2600      	movs	r6, #0
        SUBGRF_SetStopRxTimerOnPreambleDetect( ( config->fsk.StopTimerOnPreambleDetect == 0 ) ? false : true );
 80397a8:	f000 fd32 	bl	803a210 <SUBGRF_SetStopRxTimerOnPreambleDetect>
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 80397ac:	f884 6038 	strb.w	r6, [r4, #56]	; 0x38
        SubgRf.ModulationParams.Params.Gfsk.BitRate = config->fsk.BitRate;
 80397b0:	68eb      	ldr	r3, [r5, #12]
 80397b2:	63e3      	str	r3, [r4, #60]	; 0x3c
        SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = (RadioModShapings_t) config->fsk.ModulationShaping;
 80397b4:	792b      	ldrb	r3, [r5, #4]
 80397b6:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
        SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( config->fsk.Bandwidth );
 80397ba:	68a8      	ldr	r0, [r5, #8]
 80397bc:	f001 f980 	bl	803aac0 <SUBGRF_GetFskBandwidthRegValue>
 80397c0:	f884 0045 	strb.w	r0, [r4, #69]	; 0x45
        SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( config->fsk.PreambleLen ) << 3 ; // convert byte into bit
 80397c4:	692b      	ldr	r3, [r5, #16]
        SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 80397c6:	73a6      	strb	r6, [r4, #14]
        SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( config->fsk.PreambleLen ) << 3 ; // convert byte into bit
 80397c8:	00db      	lsls	r3, r3, #3
 80397ca:	8223      	strh	r3, [r4, #16]
        SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = ( RadioPreambleDetection_t ) config->fsk.PreambleMinDetect;
 80397cc:	7d2b      	ldrb	r3, [r5, #20]
 80397ce:	74a3      	strb	r3, [r4, #18]
        SubgRf.PacketParams.Params.Gfsk.SyncWordLength = ( config->fsk.SyncWordLength ) << 3; // convert byte into bit
 80397d0:	7d6b      	ldrb	r3, [r5, #21]
 80397d2:	00db      	lsls	r3, r3, #3
 80397d4:	74e3      	strb	r3, [r4, #19]
        SubgRf.PacketParams.Params.Gfsk.AddrComp = ( RadioAddressComp_t ) config->fsk.AddrComp;
 80397d6:	f895 3022 	ldrb.w	r3, [r5, #34]	; 0x22
 80397da:	7523      	strb	r3, [r4, #20]
        if( config->fsk.LengthMode == RADIO_FSK_PACKET_FIXED_LENGTH )
 80397dc:	f895 3023 	ldrb.w	r3, [r5, #35]	; 0x23
 80397e0:	2b00      	cmp	r3, #0
 80397e2:	d144      	bne.n	803986e <RadioSetRxGenericConfig+0x126>
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = config->fsk.MaxPayloadLength;
 80397e4:	69ea      	ldr	r2, [r5, #28]
        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING ) || ( config->fsk.LengthMode == RADIO_FSK_PACKET_2BYTES_LENGTH ) )
 80397e6:	f895 102a 	ldrb.w	r1, [r5, #42]	; 0x2a
          SubgRf.PacketParams.Params.Gfsk.PayloadLength = 0xFF;
 80397ea:	75a2      	strb	r2, [r4, #22]
        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING ) || ( config->fsk.LengthMode == RADIO_FSK_PACKET_2BYTES_LENGTH ) )
 80397ec:	2902      	cmp	r1, #2
 80397ee:	f895 2024 	ldrb.w	r2, [r5, #36]	; 0x24
 80397f2:	d001      	beq.n	80397f8 <RadioSetRxGenericConfig+0xb0>
 80397f4:	2b02      	cmp	r3, #2
 80397f6:	d13c      	bne.n	8039872 <RadioSetRxGenericConfig+0x12a>
          if( ( config->fsk.CrcLength != RADIO_FSK_CRC_2_BYTES_IBM ) && ( config->fsk.CrcLength != RADIO_FSK_CRC_2_BYTES_CCIT ) && ( config->fsk.CrcLength != RADIO_FSK_CRC_OFF ) )
 80397f8:	f102 030f 	add.w	r3, r2, #15
 80397fc:	b2db      	uxtb	r3, r3
 80397fe:	2b01      	cmp	r3, #1
 8039800:	d902      	bls.n	8039808 <RadioSetRxGenericConfig+0xc0>
 8039802:	2a01      	cmp	r2, #1
 8039804:	f040 8098 	bne.w	8039938 <RadioSetRxGenericConfig+0x1f0>
          ConfigGeneric.rtx = CONFIG_RX;
 8039808:	2300      	movs	r3, #0
 803980a:	f88d 3014 	strb.w	r3, [sp, #20]
          if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &RxTimeoutTimer ) )
 803980e:	4b4d      	ldr	r3, [pc, #308]	; (8039944 <RadioSetRxGenericConfig+0x1fc>)
 8039810:	4a4d      	ldr	r2, [pc, #308]	; (8039948 <RadioSetRxGenericConfig+0x200>)
 8039812:	6819      	ldr	r1, [r3, #0]
          ConfigGeneric.RxConfig = config;
 8039814:	9504      	str	r5, [sp, #16]
          if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &RxTimeoutTimer ) )
 8039816:	a803      	add	r0, sp, #12
 8039818:	f001 f9ae 	bl	803ab78 <RFW_Init>
 803981c:	2800      	cmp	r0, #0
 803981e:	f040 808b 	bne.w	8039938 <RadioSetRxGenericConfig+0x1f0>
          SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) RADIO_CRC_OFF;
 8039822:	2301      	movs	r3, #1
          SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) RADIO_FSK_DC_FREE_OFF;
 8039824:	7620      	strb	r0, [r4, #24]
          SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) RADIO_CRC_OFF;
 8039826:	75e3      	strb	r3, [r4, #23]
          SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) RADIO_PACKET_FIXED_LENGTH;
 8039828:	7560      	strb	r0, [r4, #21]
        RadioStandby( );
 803982a:	f7ff fbed 	bl	8039008 <RadioStandby>
        RadioSetModem( MODEM_FSK );
 803982e:	2000      	movs	r0, #0
 8039830:	f7ff fe72 	bl	8039518 <RadioSetModem>
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8039834:	4845      	ldr	r0, [pc, #276]	; (803994c <RadioSetRxGenericConfig+0x204>)
 8039836:	f000 fe51 	bl	803a4dc <SUBGRF_SetModulationParams>
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 803983a:	4845      	ldr	r0, [pc, #276]	; (8039950 <RadioSetRxGenericConfig+0x208>)
 803983c:	f000 ffe4 	bl	803a808 <SUBGRF_SetPacketParams>
        SUBGRF_SetSyncWord( syncword );
 8039840:	a801      	add	r0, sp, #4
 8039842:	f000 ffb3 	bl	803a7ac <SUBGRF_SetSyncWord>
        SUBGRF_SetWhiteningSeed( config->fsk.whiteSeed );
 8039846:	8c28      	ldrh	r0, [r5, #32]
 8039848:	f000 ff22 	bl	803a690 <SUBGRF_SetWhiteningSeed>
        SUBGRF_SetCrcPolynomial( config->fsk.CrcPolynomial );
 803984c:	8ce8      	ldrh	r0, [r5, #38]	; 0x26
 803984e:	f000 ffc9 	bl	803a7e4 <SUBGRF_SetCrcPolynomial>
        SubgRf.RxTimeout = ( uint32_t )( ( symbTimeout * 1000 * 8 ) / config->fsk.BitRate );
 8039852:	f44f 53fa 	mov.w	r3, #8000	; 0x1f40
 8039856:	fb03 f808 	mul.w	r8, r3, r8
 803985a:	68eb      	ldr	r3, [r5, #12]
 803985c:	fbb8 f3f3 	udiv	r3, r8, r3
        SubgRf.RxTimeout = 0xFFFF;
 8039860:	60a3      	str	r3, [r4, #8]
 8039862:	e788      	b.n	8039776 <RadioSetRxGenericConfig+0x2e>
                syncword[i] = config->fsk.SyncWord[i];
 8039864:	69a9      	ldr	r1, [r5, #24]
 8039866:	5c09      	ldrb	r1, [r1, r0]
 8039868:	5481      	strb	r1, [r0, r2]
            for(int i = 0; i < config->fsk.SyncWordLength; i++)
 803986a:	3001      	adds	r0, #1
 803986c:	e795      	b.n	803979a <RadioSetRxGenericConfig+0x52>
          SubgRf.PacketParams.Params.Gfsk.PayloadLength = 0xFF;
 803986e:	22ff      	movs	r2, #255	; 0xff
 8039870:	e7b9      	b.n	80397e6 <RadioSetRxGenericConfig+0x9e>
          SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) config->fsk.CrcLength;
 8039872:	75e2      	strb	r2, [r4, #23]
          SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) config->fsk.Whitening;
 8039874:	7621      	strb	r1, [r4, #24]
          SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) config->fsk.LengthMode;
 8039876:	7563      	strb	r3, [r4, #21]
 8039878:	e7d7      	b.n	803982a <RadioSetRxGenericConfig+0xe2>
        if( config->lora.PreambleLen == 0 )
 803987a:	8eab      	ldrh	r3, [r5, #52]	; 0x34
 803987c:	2b00      	cmp	r3, #0
 803987e:	d05b      	beq.n	8039938 <RadioSetRxGenericConfig+0x1f0>
        if( config->lora.LengthMode == RADIO_LORA_PACKET_FIXED_LENGTH )
 8039880:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
        SUBGRF_SetStopRxTimerOnPreambleDetect( ( config->lora.StopTimerOnPreambleDetect == 0 ) ? false : true );
 8039884:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
        if( config->lora.LengthMode == RADIO_LORA_PACKET_FIXED_LENGTH )
 8039886:	2b01      	cmp	r3, #1
            MaxPayloadLength = config->fsk.MaxPayloadLength;
 8039888:	bf0c      	ite	eq
 803988a:	7f2f      	ldrbeq	r7, [r5, #28]
            MaxPayloadLength = 0xFF;
 803988c:	27ff      	movne	r7, #255	; 0xff
        SUBGRF_SetStopRxTimerOnPreambleDetect( ( config->lora.StopTimerOnPreambleDetect == 0 ) ? false : true );
 803988e:	3800      	subs	r0, #0
 8039890:	bf18      	it	ne
 8039892:	2001      	movne	r0, #1
 8039894:	f000 fcbc 	bl	803a210 <SUBGRF_SetStopRxTimerOnPreambleDetect>
        SUBGRF_SetLoRaSymbNumTimeout( symbTimeout );
 8039898:	fa5f f088 	uxtb.w	r0, r8
 803989c:	f000 fdf0 	bl	803a480 <SUBGRF_SetLoRaSymbNumTimeout>
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_LORA;
 80398a0:	2101      	movs	r1, #1
 80398a2:	f884 1038 	strb.w	r1, [r4, #56]	; 0x38
        SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t ) config->lora.SpreadingFactor;
 80398a6:	f895 2030 	ldrb.w	r2, [r5, #48]	; 0x30
 80398aa:	f884 2050 	strb.w	r2, [r4, #80]	; 0x50
        SubgRf.ModulationParams.Params.LoRa.Bandwidth = ( RadioLoRaBandwidths_t ) config->lora.Bandwidth;
 80398ae:	f895 3031 	ldrb.w	r3, [r5, #49]	; 0x31
 80398b2:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
        SubgRf.ModulationParams.Params.LoRa.CodingRate = ( RadioLoRaCodingRates_t ) config->lora.Coderate;
 80398b6:	f895 3032 	ldrb.w	r3, [r5, #50]	; 0x32
 80398ba:	f884 3052 	strb.w	r3, [r4, #82]	; 0x52
        switch( config->lora.LowDatarateOptimize )
 80398be:	f895 3033 	ldrb.w	r3, [r5, #51]	; 0x33
 80398c2:	428b      	cmp	r3, r1
 80398c4:	d002      	beq.n	80398cc <RadioSetRxGenericConfig+0x184>
 80398c6:	2b02      	cmp	r3, #2
 80398c8:	d003      	beq.n	80398d2 <RadioSetRxGenericConfig+0x18a>
 80398ca:	b93b      	cbnz	r3, 80398dc <RadioSetRxGenericConfig+0x194>
              SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0;
 80398cc:	f884 3053 	strb.w	r3, [r4, #83]	; 0x53
 80398d0:	e004      	b.n	80398dc <RadioSetRxGenericConfig+0x194>
            if( ( config->lora.SpreadingFactor == RADIO_LORA_SF11 ) || ( config->lora.SpreadingFactor == RADIO_LORA_SF12 ) )
 80398d2:	3a0b      	subs	r2, #11
 80398d4:	2a01      	cmp	r2, #1
 80398d6:	d827      	bhi.n	8039928 <RadioSetRxGenericConfig+0x1e0>
              SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 1;
 80398d8:	f884 1053 	strb.w	r1, [r4, #83]	; 0x53
        SubgRf.PacketParams.Params.LoRa.PreambleLength = config->lora.PreambleLen;
 80398dc:	8eab      	ldrh	r3, [r5, #52]	; 0x34
 80398de:	83a3      	strh	r3, [r4, #28]
        SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t ) config->lora.LengthMode;
 80398e0:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
 80398e4:	77a3      	strb	r3, [r4, #30]
        SubgRf.PacketParams.Params.LoRa.CrcMode = ( RadioLoRaCrcModes_t ) config->lora.CrcMode;
 80398e6:	8f2b      	ldrh	r3, [r5, #56]	; 0x38
 80398e8:	8423      	strh	r3, [r4, #32]
        SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 80398ea:	2601      	movs	r6, #1
 80398ec:	73a6      	strb	r6, [r4, #14]
        SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength;
 80398ee:	77e7      	strb	r7, [r4, #31]
        RadioStandby( );
 80398f0:	f7ff fb8a 	bl	8039008 <RadioStandby>
        RadioSetModem( MODEM_LORA );
 80398f4:	4630      	mov	r0, r6
 80398f6:	f7ff fe0f 	bl	8039518 <RadioSetModem>
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 80398fa:	4814      	ldr	r0, [pc, #80]	; (803994c <RadioSetRxGenericConfig+0x204>)
 80398fc:	f000 fdee 	bl	803a4dc <SUBGRF_SetModulationParams>
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039900:	4813      	ldr	r0, [pc, #76]	; (8039950 <RadioSetRxGenericConfig+0x208>)
 8039902:	f000 ff81 	bl	803a808 <SUBGRF_SetPacketParams>
        if( SubgRf.PacketParams.Params.LoRa.InvertIQ == LORA_IQ_INVERTED )
 8039906:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
 803990a:	42b3      	cmp	r3, r6
            SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) & ~( 1 << 2 ) );
 803990c:	f240 7036 	movw	r0, #1846	; 0x736
        if( SubgRf.PacketParams.Params.LoRa.InvertIQ == LORA_IQ_INVERTED )
 8039910:	d10c      	bne.n	803992c <RadioSetRxGenericConfig+0x1e4>
            SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) & ~( 1 << 2 ) );
 8039912:	f000 fe4f 	bl	803a5b4 <SUBGRF_ReadRegister>
 8039916:	f000 01fb 	and.w	r1, r0, #251	; 0xfb
            SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) | ( 1 << 2 ) );
 803991a:	f240 7036 	movw	r0, #1846	; 0x736
 803991e:	f000 fd83 	bl	803a428 <SUBGRF_WriteRegister>
        SubgRf.RxTimeout = 0xFFFF;
 8039922:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8039926:	e79b      	b.n	8039860 <RadioSetRxGenericConfig+0x118>
              SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0;
 8039928:	2300      	movs	r3, #0
 803992a:	e7cf      	b.n	80398cc <RadioSetRxGenericConfig+0x184>
            SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) | ( 1 << 2 ) );
 803992c:	f000 fe42 	bl	803a5b4 <SUBGRF_ReadRegister>
 8039930:	f040 0104 	orr.w	r1, r0, #4
 8039934:	b2c9      	uxtb	r1, r1
 8039936:	e7f0      	b.n	803991a <RadioSetRxGenericConfig+0x1d2>
            return -1;
 8039938:	f04f 30ff 	mov.w	r0, #4294967295
 803993c:	e71c      	b.n	8039778 <RadioSetRxGenericConfig+0x30>
 803993e:	bf00      	nop
 8039940:	20006324 	.word	0x20006324
 8039944:	2000597c 	.word	0x2000597c
 8039948:	20006394 	.word	0x20006394
 803994c:	2000635c 	.word	0x2000635c
 8039950:	20006332 	.word	0x20006332

08039954 <RadioSetTxConfig>:
{
 8039954:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8039958:	b085      	sub	sp, #20
 803995a:	4682      	mov	sl, r0
 803995c:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 803995e:	f8bd b040 	ldrh.w	fp, [sp, #64]	; 0x40
 8039962:	f89d 7044 	ldrb.w	r7, [sp, #68]	; 0x44
 8039966:	f89d 9048 	ldrb.w	r9, [sp, #72]	; 0x48
 803996a:	9201      	str	r2, [sp, #4]
 803996c:	4688      	mov	r8, r1
 803996e:	461e      	mov	r6, r3
    RFW_DeInit(); /* ST_WORKAROUND: Switch Off FwPacketDecoding by default */
 8039970:	f001 f905 	bl	803ab7e <RFW_DeInit>
    switch( modem )
 8039974:	f1ba 0f01 	cmp.w	sl, #1
 8039978:	4c54      	ldr	r4, [pc, #336]	; (8039acc <RadioSetTxConfig+0x178>)
 803997a:	d051      	beq.n	8039a20 <RadioSetTxConfig+0xcc>
 803997c:	f1ba 0f03 	cmp.w	sl, #3
 8039980:	f000 8094 	beq.w	8039aac <RadioSetTxConfig+0x158>
 8039984:	f1ba 0f00 	cmp.w	sl, #0
 8039988:	d13e      	bne.n	8039a08 <RadioSetTxConfig+0xb4>
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_1;
 803998a:	220b      	movs	r2, #11
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 803998c:	4630      	mov	r0, r6
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_1;
 803998e:	f884 2044 	strb.w	r2, [r4, #68]	; 0x44
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 8039992:	f884 a038 	strb.w	sl, [r4, #56]	; 0x38
            SubgRf.ModulationParams.Params.Gfsk.BitRate = datarate;
 8039996:	63e5      	str	r5, [r4, #60]	; 0x3c
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8039998:	f001 f892 	bl	803aac0 <SUBGRF_GetFskBandwidthRegValue>
            SubgRf.ModulationParams.Params.Gfsk.Fdev = fdev;
 803999c:	9b01      	ldr	r3, [sp, #4]
 803999e:	6423      	str	r3, [r4, #64]	; 0x40
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 80399a0:	ea4f 03cb 	mov.w	r3, fp, lsl #3
            if( crcOn == true )
 80399a4:	f1b9 0f00 	cmp.w	r9, #0
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 80399a8:	8223      	strh	r3, [r4, #16]
            SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS;
 80399aa:	f641 0304 	movw	r3, #6148	; 0x1804
 80399ae:	8263      	strh	r3, [r4, #18]
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 80399b0:	bf14      	ite	ne
 80399b2:	23f2      	movne	r3, #242	; 0xf2
 80399b4:	2301      	moveq	r3, #1
 80399b6:	75e3      	strb	r3, [r4, #23]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( fixLen == true ) ? RADIO_PACKET_FIXED_LENGTH : RADIO_PACKET_VARIABLE_LENGTH;
 80399b8:	f087 0701 	eor.w	r7, r7, #1
            SubgRf.PacketParams.Params.Gfsk.DcFree = RADIO_DC_FREEWHITENING;
 80399bc:	2301      	movs	r3, #1
 80399be:	7623      	strb	r3, [r4, #24]
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 80399c0:	f884 0045 	strb.w	r0, [r4, #69]	; 0x45
            SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 80399c4:	f884 a00e 	strb.w	sl, [r4, #14]
            SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF;
 80399c8:	f884 a014 	strb.w	sl, [r4, #20]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( fixLen == true ) ? RADIO_PACKET_FIXED_LENGTH : RADIO_PACKET_VARIABLE_LENGTH;
 80399cc:	7567      	strb	r7, [r4, #21]
            RadioStandby( );
 80399ce:	f7ff fb1b 	bl	8039008 <RadioStandby>
            RadioSetModem( ( SubgRf.ModulationParams.PacketType == PACKET_TYPE_GFSK ) ? MODEM_FSK : MODEM_LORA );
 80399d2:	f894 0038 	ldrb.w	r0, [r4, #56]	; 0x38
 80399d6:	3800      	subs	r0, #0
 80399d8:	bf18      	it	ne
 80399da:	2001      	movne	r0, #1
 80399dc:	f7ff fd9c 	bl	8039518 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 80399e0:	f104 0038 	add.w	r0, r4, #56	; 0x38
 80399e4:	f000 fd7a 	bl	803a4dc <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 80399e8:	f104 000e 	add.w	r0, r4, #14
 80399ec:	f000 ff0c 	bl	803a808 <SUBGRF_SetPacketParams>
            SUBGRF_SetSyncWord( ( uint8_t[] ){ 0xC1, 0x94, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00 } );
 80399f0:	4a37      	ldr	r2, [pc, #220]	; (8039ad0 <RadioSetTxConfig+0x17c>)
 80399f2:	6810      	ldr	r0, [r2, #0]
 80399f4:	6851      	ldr	r1, [r2, #4]
 80399f6:	ab02      	add	r3, sp, #8
 80399f8:	c303      	stmia	r3!, {r0, r1}
 80399fa:	a802      	add	r0, sp, #8
 80399fc:	f000 fed6 	bl	803a7ac <SUBGRF_SetSyncWord>
            SUBGRF_SetWhiteningSeed( 0x01FF );
 8039a00:	f240 10ff 	movw	r0, #511	; 0x1ff
 8039a04:	f000 fe44 	bl	803a690 <SUBGRF_SetWhiteningSeed>
    SubgRf.AntSwitchPaSelect = SUBGRF_SetRfTxPower( power );
 8039a08:	4640      	mov	r0, r8
 8039a0a:	f001 f800 	bl	803aa0e <SUBGRF_SetRfTxPower>
 8039a0e:	f884 0056 	strb.w	r0, [r4, #86]	; 0x56
    RFW_SetAntSwitch( SubgRf.AntSwitchPaSelect ); /* ST_WORKAROUND: ?????? */
 8039a12:	f001 f8b9 	bl	803ab88 <RFW_SetAntSwitch>
    SubgRf.TxTimeout = timeout;
 8039a16:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8039a18:	6063      	str	r3, [r4, #4]
}
 8039a1a:	b005      	add	sp, #20
 8039a1c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            SubgRf.ModulationParams.Params.LoRa.Bandwidth =  Bandwidths[bandwidth];
 8039a20:	492c      	ldr	r1, [pc, #176]	; (8039ad4 <RadioSetTxConfig+0x180>)
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_LORA;
 8039a22:	f884 a038 	strb.w	sl, [r4, #56]	; 0x38
            SubgRf.ModulationParams.Params.LoRa.Bandwidth =  Bandwidths[bandwidth];
 8039a26:	4431      	add	r1, r6
            SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t ) datarate;
 8039a28:	b2ea      	uxtb	r2, r5
            SubgRf.ModulationParams.Params.LoRa.Bandwidth =  Bandwidths[bandwidth];
 8039a2a:	7909      	ldrb	r1, [r1, #4]
 8039a2c:	f884 1051 	strb.w	r1, [r4, #81]	; 0x51
            SubgRf.ModulationParams.Params.LoRa.CodingRate= ( RadioLoRaCodingRates_t )coderate;
 8039a30:	f89d 103c 	ldrb.w	r1, [sp, #60]	; 0x3c
            SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t ) datarate;
 8039a34:	f884 2050 	strb.w	r2, [r4, #80]	; 0x50
            SubgRf.ModulationParams.Params.LoRa.CodingRate= ( RadioLoRaCodingRates_t )coderate;
 8039a38:	f884 1052 	strb.w	r1, [r4, #82]	; 0x52
            if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 8039a3c:	bb56      	cbnz	r6, 8039a94 <RadioSetTxConfig+0x140>
 8039a3e:	3d0b      	subs	r5, #11
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x00;
 8039a40:	2d01      	cmp	r5, #1
 8039a42:	bf8c      	ite	hi
 8039a44:	2500      	movhi	r5, #0
 8039a46:	2501      	movls	r5, #1
            SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 8039a48:	2101      	movs	r1, #1
            if( ( SubgRf.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF5 ) ||
 8039a4a:	3a05      	subs	r2, #5
 8039a4c:	428a      	cmp	r2, r1
 8039a4e:	f884 5053 	strb.w	r5, [r4, #83]	; 0x53
            SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 8039a52:	73a1      	strb	r1, [r4, #14]
            if( ( SubgRf.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF5 ) ||
 8039a54:	d827      	bhi.n	8039aa6 <RadioSetTxConfig+0x152>
                if( preambleLen < 12 )
 8039a56:	f1bb 0f0b 	cmp.w	fp, #11
 8039a5a:	d824      	bhi.n	8039aa6 <RadioSetTxConfig+0x152>
                    SubgRf.PacketParams.Params.LoRa.PreambleLength = 12;
 8039a5c:	230c      	movs	r3, #12
 8039a5e:	83a3      	strh	r3, [r4, #28]
            SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength;
 8039a60:	4b1d      	ldr	r3, [pc, #116]	; (8039ad8 <RadioSetTxConfig+0x184>)
            SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t )fixLen;
 8039a62:	77a7      	strb	r7, [r4, #30]
            SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength;
 8039a64:	781b      	ldrb	r3, [r3, #0]
 8039a66:	77e3      	strb	r3, [r4, #31]
            SubgRf.PacketParams.Params.LoRa.InvertIQ = ( RadioLoRaIQModes_t )iqInverted;
 8039a68:	f89d 3054 	ldrb.w	r3, [sp, #84]	; 0x54
 8039a6c:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
            SubgRf.PacketParams.Params.LoRa.CrcMode = ( RadioLoRaCrcModes_t )crcOn;
 8039a70:	f884 9020 	strb.w	r9, [r4, #32]
            RadioStandby( );
 8039a74:	f7ff fac8 	bl	8039008 <RadioStandby>
            RadioSetModem( ( SubgRf.ModulationParams.PacketType == PACKET_TYPE_GFSK ) ? MODEM_FSK : MODEM_LORA );
 8039a78:	f894 0038 	ldrb.w	r0, [r4, #56]	; 0x38
 8039a7c:	3800      	subs	r0, #0
 8039a7e:	bf18      	it	ne
 8039a80:	2001      	movne	r0, #1
 8039a82:	f7ff fd49 	bl	8039518 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8039a86:	4815      	ldr	r0, [pc, #84]	; (8039adc <RadioSetTxConfig+0x188>)
 8039a88:	f000 fd28 	bl	803a4dc <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039a8c:	4814      	ldr	r0, [pc, #80]	; (8039ae0 <RadioSetTxConfig+0x18c>)
 8039a8e:	f000 febb 	bl	803a808 <SUBGRF_SetPacketParams>
            break;
 8039a92:	e7b9      	b.n	8039a08 <RadioSetTxConfig+0xb4>
            if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 8039a94:	2e01      	cmp	r6, #1
 8039a96:	d104      	bne.n	8039aa2 <RadioSetTxConfig+0x14e>
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x00;
 8039a98:	f1a5 030c 	sub.w	r3, r5, #12
 8039a9c:	425d      	negs	r5, r3
 8039a9e:	415d      	adcs	r5, r3
 8039aa0:	e7d2      	b.n	8039a48 <RadioSetTxConfig+0xf4>
 8039aa2:	2500      	movs	r5, #0
 8039aa4:	e7d0      	b.n	8039a48 <RadioSetTxConfig+0xf4>
                    SubgRf.PacketParams.Params.LoRa.PreambleLength = preambleLen;
 8039aa6:	f8a4 b01c 	strh.w	fp, [r4, #28]
 8039aaa:	e7d9      	b.n	8039a60 <RadioSetTxConfig+0x10c>
            RadioSetModem(MODEM_SIGFOX_TX);
 8039aac:	4650      	mov	r0, sl
 8039aae:	f7ff fd33 	bl	8039518 <RadioSetModem>
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_BPSK;
 8039ab2:	2302      	movs	r3, #2
 8039ab4:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8039ab8:	f104 0038 	add.w	r0, r4, #56	; 0x38
            SubgRf.ModulationParams.Params.Bpsk.ModulationShaping = MOD_SHAPING_DBPSK;
 8039abc:	2316      	movs	r3, #22
            SubgRf.ModulationParams.Params.Bpsk.BitRate           = datarate;
 8039abe:	64a5      	str	r5, [r4, #72]	; 0x48
            SubgRf.ModulationParams.Params.Bpsk.ModulationShaping = MOD_SHAPING_DBPSK;
 8039ac0:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8039ac4:	f000 fd0a 	bl	803a4dc <SUBGRF_SetModulationParams>
            break;
 8039ac8:	e79e      	b.n	8039a08 <RadioSetTxConfig+0xb4>
 8039aca:	bf00      	nop
 8039acc:	20006324 	.word	0x20006324
 8039ad0:	0803bc20 	.word	0x0803bc20
 8039ad4:	0803bbec 	.word	0x0803bbec
 8039ad8:	200035a0 	.word	0x200035a0
 8039adc:	2000635c 	.word	0x2000635c
 8039ae0:	20006332 	.word	0x20006332

08039ae4 <RadioSetRxConfig>:
{
 8039ae4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8039ae8:	b087      	sub	sp, #28
    SubgRf.RxContinuous = rxContinuous;
 8039aea:	f8df b2d4 	ldr.w	fp, [pc, #724]	; 8039dc0 <RadioSetRxConfig+0x2dc>
{
 8039aee:	9301      	str	r3, [sp, #4]
 8039af0:	4605      	mov	r5, r0
 8039af2:	f89d 3054 	ldrb.w	r3, [sp, #84]	; 0x54
 8039af6:	f89d 0050 	ldrb.w	r0, [sp, #80]	; 0x50
 8039afa:	f8bd 8048 	ldrh.w	r8, [sp, #72]	; 0x48
 8039afe:	f89d 904c 	ldrb.w	r9, [sp, #76]	; 0x4c
 8039b02:	9003      	str	r0, [sp, #12]
 8039b04:	460f      	mov	r7, r1
 8039b06:	f89d 1064 	ldrb.w	r1, [sp, #100]	; 0x64
    SubgRf.RxContinuous = rxContinuous;
 8039b0a:	f88b 1001 	strb.w	r1, [fp, #1]
 8039b0e:	9102      	str	r1, [sp, #8]
{
 8039b10:	f8bd 6044 	ldrh.w	r6, [sp, #68]	; 0x44
 8039b14:	9300      	str	r3, [sp, #0]
 8039b16:	4614      	mov	r4, r2
    RFW_DeInit(); /* ST_WORKAROUND: Switch Off FwPacketDecoding by default */
 8039b18:	f001 f831 	bl	803ab7e <RFW_DeInit>
        symbTimeout = 0;
 8039b1c:	9902      	ldr	r1, [sp, #8]
        MaxPayloadLength = 0xFF;
 8039b1e:	9803      	ldr	r0, [sp, #12]
        symbTimeout = 0;
 8039b20:	2900      	cmp	r1, #0
 8039b22:	bf18      	it	ne
 8039b24:	f04f 0800 	movne.w	r8, #0
    if( fixLen == true )
 8039b28:	499f      	ldr	r1, [pc, #636]	; (8039da8 <RadioSetRxConfig+0x2c4>)
        MaxPayloadLength = 0xFF;
 8039b2a:	f1b9 0f00 	cmp.w	r9, #0
 8039b2e:	bf08      	it	eq
 8039b30:	20ff      	moveq	r0, #255	; 0xff
    switch( modem )
 8039b32:	2d01      	cmp	r5, #1
 8039b34:	46da      	mov	sl, fp
 8039b36:	7008      	strb	r0, [r1, #0]
 8039b38:	f000 80cc 	beq.w	8039cd4 <RadioSetRxConfig+0x1f0>
 8039b3c:	2d04      	cmp	r5, #4
 8039b3e:	d04c      	beq.n	8039bda <RadioSetRxConfig+0xf6>
 8039b40:	2d00      	cmp	r5, #0
 8039b42:	f040 80c4 	bne.w	8039cce <RadioSetRxConfig+0x1ea>
            SUBGRF_SetStopRxTimerOnPreambleDetect( false );
 8039b46:	4628      	mov	r0, r5
 8039b48:	f000 fb62 	bl	803a210 <SUBGRF_SetStopRxTimerOnPreambleDetect>
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_1;
 8039b4c:	220b      	movs	r2, #11
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8039b4e:	4638      	mov	r0, r7
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_1;
 8039b50:	f88b 2044 	strb.w	r2, [fp, #68]	; 0x44
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 8039b54:	f88b 5038 	strb.w	r5, [fp, #56]	; 0x38
            SubgRf.ModulationParams.Params.Gfsk.BitRate = datarate;
 8039b58:	f8cb 403c 	str.w	r4, [fp, #60]	; 0x3c
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8039b5c:	f000 ffb0 	bl	803aac0 <SUBGRF_GetFskBandwidthRegValue>
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 8039b60:	9b00      	ldr	r3, [sp, #0]
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength;
 8039b62:	4991      	ldr	r1, [pc, #580]	; (8039da8 <RadioSetRxConfig+0x2c4>)
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8039b64:	f88b 0045 	strb.w	r0, [fp, #69]	; 0x45
            SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS;
 8039b68:	f641 0204 	movw	r2, #6148	; 0x1804
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 8039b6c:	2b00      	cmp	r3, #0
            SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS;
 8039b6e:	f8ab 2012 	strh.w	r2, [fp, #18]
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength;
 8039b72:	780a      	ldrb	r2, [r1, #0]
 8039b74:	f88b 2016 	strb.w	r2, [fp, #22]
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 8039b78:	bf14      	ite	ne
 8039b7a:	22f2      	movne	r2, #242	; 0xf2
 8039b7c:	2201      	moveq	r2, #1
 8039b7e:	f88b 2017 	strb.w	r2, [fp, #23]
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 8039b82:	00f6      	lsls	r6, r6, #3
            SubgRf.PacketParams.Params.Gfsk.DcFree = RADIO_DC_FREEWHITENING;
 8039b84:	2201      	movs	r2, #1
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( fixLen == true ) ? RADIO_PACKET_FIXED_LENGTH : RADIO_PACKET_VARIABLE_LENGTH;
 8039b86:	f089 0901 	eor.w	r9, r9, #1
            SubgRf.PacketParams.Params.Gfsk.DcFree = RADIO_DC_FREEWHITENING;
 8039b8a:	f88b 2018 	strb.w	r2, [fp, #24]
            SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 8039b8e:	f88b 500e 	strb.w	r5, [fp, #14]
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 8039b92:	f8ab 6010 	strh.w	r6, [fp, #16]
            SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF;
 8039b96:	f88b 5014 	strb.w	r5, [fp, #20]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( fixLen == true ) ? RADIO_PACKET_FIXED_LENGTH : RADIO_PACKET_VARIABLE_LENGTH;
 8039b9a:	f88b 9015 	strb.w	r9, [fp, #21]
            RadioStandby( );
 8039b9e:	f7ff fa33 	bl	8039008 <RadioStandby>
            RadioSetModem( ( SubgRf.ModulationParams.PacketType == PACKET_TYPE_GFSK ) ? MODEM_FSK : MODEM_LORA );
 8039ba2:	f89b 0038 	ldrb.w	r0, [fp, #56]	; 0x38
 8039ba6:	3800      	subs	r0, #0
 8039ba8:	bf18      	it	ne
 8039baa:	2001      	movne	r0, #1
 8039bac:	f7ff fcb4 	bl	8039518 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8039bb0:	f10b 0038 	add.w	r0, fp, #56	; 0x38
 8039bb4:	f000 fc92 	bl	803a4dc <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039bb8:	f10b 000e 	add.w	r0, fp, #14
 8039bbc:	f000 fe24 	bl	803a808 <SUBGRF_SetPacketParams>
            SUBGRF_SetSyncWord( ( uint8_t[] ){ 0xC1, 0x94, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00 } );
 8039bc0:	497a      	ldr	r1, [pc, #488]	; (8039dac <RadioSetRxConfig+0x2c8>)
 8039bc2:	6808      	ldr	r0, [r1, #0]
 8039bc4:	6849      	ldr	r1, [r1, #4]
 8039bc6:	aa04      	add	r2, sp, #16
 8039bc8:	c203      	stmia	r2!, {r0, r1}
 8039bca:	a804      	add	r0, sp, #16
 8039bcc:	f000 fdee 	bl	803a7ac <SUBGRF_SetSyncWord>
            SUBGRF_SetWhiteningSeed( 0x01FF );
 8039bd0:	f240 10ff 	movw	r0, #511	; 0x1ff
 8039bd4:	f000 fd5c 	bl	803a690 <SUBGRF_SetWhiteningSeed>
 8039bd8:	e071      	b.n	8039cbe <RadioSetRxConfig+0x1da>
            SUBGRF_SetStopRxTimerOnPreambleDetect( true );
 8039bda:	2001      	movs	r0, #1
 8039bdc:	f000 fb18 	bl	803a210 <SUBGRF_SetStopRxTimerOnPreambleDetect>
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_05;
 8039be0:	2209      	movs	r2, #9
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 8039be2:	f04f 0900 	mov.w	r9, #0
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_05;
 8039be6:	f88b 2044 	strb.w	r2, [fp, #68]	; 0x44
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8039bea:	4638      	mov	r0, r7
            SubgRf.ModulationParams.Params.Gfsk.Fdev = 800;
 8039bec:	f44f 7248 	mov.w	r2, #800	; 0x320
 8039bf0:	f8cb 2040 	str.w	r2, [fp, #64]	; 0x40
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 8039bf4:	f88b 9038 	strb.w	r9, [fp, #56]	; 0x38
            SubgRf.ModulationParams.Params.Gfsk.BitRate = datarate;
 8039bf8:	f8cb 403c 	str.w	r4, [fp, #60]	; 0x3c
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8039bfc:	f000 ff60 	bl	803aac0 <SUBGRF_GetFskBandwidthRegValue>
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength;
 8039c00:	4969      	ldr	r1, [pc, #420]	; (8039da8 <RadioSetRxConfig+0x2c4>)
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8039c02:	f88b 0045 	strb.w	r0, [fp, #69]	; 0x45
            SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_OFF;
 8039c06:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8039c0a:	f8ab 2012 	strh.w	r2, [fp, #18]
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength;
 8039c0e:	780a      	ldrb	r2, [r1, #0]
 8039c10:	f88b 2016 	strb.w	r2, [fp, #22]
            RadioSetModem( MODEM_SIGFOX_RX );
 8039c14:	4628      	mov	r0, r5
            SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 8039c16:	2201      	movs	r2, #1
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 8039c18:	00f6      	lsls	r6, r6, #3
            SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 8039c1a:	f88b 2017 	strb.w	r2, [fp, #23]
            SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 8039c1e:	f88b 900e 	strb.w	r9, [fp, #14]
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 8039c22:	f8ab 6010 	strh.w	r6, [fp, #16]
            SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF;
 8039c26:	f8ab 9014 	strh.w	r9, [fp, #20]
            SubgRf.PacketParams.Params.Gfsk.DcFree = RADIO_DC_FREE_OFF;
 8039c2a:	f88b 9018 	strb.w	r9, [fp, #24]
            RadioSetModem( MODEM_SIGFOX_RX );
 8039c2e:	f7ff fc73 	bl	8039518 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8039c32:	f10b 0038 	add.w	r0, fp, #56	; 0x38
 8039c36:	f000 fc51 	bl	803a4dc <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039c3a:	f10b 000e 	add.w	r0, fp, #14
 8039c3e:	f000 fde3 	bl	803a808 <SUBGRF_SetPacketParams>
            SUBGRF_SetSyncWord( ( uint8_t[] ){0xB2, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } );
 8039c42:	495b      	ldr	r1, [pc, #364]	; (8039db0 <RadioSetRxConfig+0x2cc>)
 8039c44:	6808      	ldr	r0, [r1, #0]
 8039c46:	6849      	ldr	r1, [r1, #4]
 8039c48:	aa04      	add	r2, sp, #16
 8039c4a:	c203      	stmia	r2!, {r0, r1}
 8039c4c:	a804      	add	r0, sp, #16
 8039c4e:	f000 fdad 	bl	803a7ac <SUBGRF_SetSyncWord>
            SUBGRF_SetWhiteningSeed( 0x01FF );
 8039c52:	f240 10ff 	movw	r0, #511	; 0x1ff
 8039c56:	f000 fd1b 	bl	803a690 <SUBGRF_SetWhiteningSeed>
    return SUBGRF_ReadRegister(addr);
 8039c5a:	f640 00b8 	movw	r0, #2232	; 0x8b8
 8039c5e:	f000 fca9 	bl	803a5b4 <SUBGRF_ReadRegister>
    SUBGRF_WriteRegister(addr, data );
 8039c62:	f000 01ef 	and.w	r1, r0, #239	; 0xef
 8039c66:	f640 00b8 	movw	r0, #2232	; 0x8b8
 8039c6a:	f000 fbdd 	bl	803a428 <SUBGRF_WriteRegister>
 8039c6e:	4629      	mov	r1, r5
 8039c70:	f640 00b9 	movw	r0, #2233	; 0x8b9
 8039c74:	f000 fbd8 	bl	803a428 <SUBGRF_WriteRegister>
    return SUBGRF_ReadRegister(addr);
 8039c78:	f640 009b 	movw	r0, #2203	; 0x89b
 8039c7c:	f000 fc9a 	bl	803a5b4 <SUBGRF_ReadRegister>
            RadioWrite(0x89b, (modReg| (0x1<<3) ) );
 8039c80:	f000 01e3 	and.w	r1, r0, #227	; 0xe3
    SUBGRF_WriteRegister(addr, data );
 8039c84:	f041 0108 	orr.w	r1, r1, #8
 8039c88:	f640 009b 	movw	r0, #2203	; 0x89b
 8039c8c:	f000 fbcc 	bl	803a428 <SUBGRF_WriteRegister>
    return SUBGRF_ReadRegister(addr);
 8039c90:	f240 60d1 	movw	r0, #1745	; 0x6d1
 8039c94:	f000 fc8e 	bl	803a5b4 <SUBGRF_ReadRegister>
            RadioWrite(0x6d1, (modReg| (0x3<<3) ));
 8039c98:	f040 0118 	orr.w	r1, r0, #24
    SUBGRF_WriteRegister(addr, data );
 8039c9c:	b2c9      	uxtb	r1, r1
 8039c9e:	f240 60d1 	movw	r0, #1745	; 0x6d1
 8039ca2:	f000 fbc1 	bl	803a428 <SUBGRF_WriteRegister>
    return SUBGRF_ReadRegister(addr);
 8039ca6:	f240 60ac 	movw	r0, #1708	; 0x6ac
 8039caa:	f000 fc83 	bl	803a5b4 <SUBGRF_ReadRegister>
            RadioWrite(0x6ac, (modReg| (0x5<<4) ));
 8039cae:	f000 018f 	and.w	r1, r0, #143	; 0x8f
    SUBGRF_WriteRegister(addr, data );
 8039cb2:	f041 0150 	orr.w	r1, r1, #80	; 0x50
 8039cb6:	f240 60ac 	movw	r0, #1708	; 0x6ac
 8039cba:	f000 fbb5 	bl	803a428 <SUBGRF_WriteRegister>
            SubgRf.RxTimeout = ( uint32_t )(( symbTimeout * 8 * 1000 ) /datarate);
 8039cbe:	f44f 52fa 	mov.w	r2, #8000	; 0x1f40
 8039cc2:	fb02 f808 	mul.w	r8, r2, r8
 8039cc6:	fbb8 f4f4 	udiv	r4, r8, r4
 8039cca:	f8cb 4008 	str.w	r4, [fp, #8]
}
 8039cce:	b007      	add	sp, #28
 8039cd0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            SUBGRF_SetStopRxTimerOnPreambleDetect( false );
 8039cd4:	2000      	movs	r0, #0
 8039cd6:	f000 fa9b 	bl	803a210 <SUBGRF_SetStopRxTimerOnPreambleDetect>
            SubgRf.ModulationParams.Params.LoRa.Bandwidth = Bandwidths[bandwidth];
 8039cda:	4936      	ldr	r1, [pc, #216]	; (8039db4 <RadioSetRxConfig+0x2d0>)
            SubgRf.ModulationParams.Params.LoRa.CodingRate = ( RadioLoRaCodingRates_t )coderate;
 8039cdc:	9a01      	ldr	r2, [sp, #4]
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_LORA;
 8039cde:	f88b 5038 	strb.w	r5, [fp, #56]	; 0x38
            SubgRf.ModulationParams.Params.LoRa.Bandwidth = Bandwidths[bandwidth];
 8039ce2:	4439      	add	r1, r7
            SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t )datarate;
 8039ce4:	b2e3      	uxtb	r3, r4
            SubgRf.ModulationParams.Params.LoRa.Bandwidth = Bandwidths[bandwidth];
 8039ce6:	7909      	ldrb	r1, [r1, #4]
            SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t )datarate;
 8039ce8:	f88b 3050 	strb.w	r3, [fp, #80]	; 0x50
            SubgRf.ModulationParams.Params.LoRa.Bandwidth = Bandwidths[bandwidth];
 8039cec:	f88b 1051 	strb.w	r1, [fp, #81]	; 0x51
            SubgRf.ModulationParams.Params.LoRa.CodingRate = ( RadioLoRaCodingRates_t )coderate;
 8039cf0:	f88b 2052 	strb.w	r2, [fp, #82]	; 0x52
            if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 8039cf4:	2f00      	cmp	r7, #0
 8039cf6:	d144      	bne.n	8039d82 <RadioSetRxConfig+0x29e>
 8039cf8:	3c0b      	subs	r4, #11
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x00;
 8039cfa:	2c01      	cmp	r4, #1
 8039cfc:	bf8c      	ite	hi
 8039cfe:	2400      	movhi	r4, #0
 8039d00:	2401      	movls	r4, #1
            SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 8039d02:	2101      	movs	r1, #1
            if( ( SubgRf.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF5 ) ||
 8039d04:	3b05      	subs	r3, #5
 8039d06:	428b      	cmp	r3, r1
 8039d08:	f88a 4053 	strb.w	r4, [sl, #83]	; 0x53
            SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 8039d0c:	f88a 100e 	strb.w	r1, [sl, #14]
            if( ( SubgRf.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF5 ) ||
 8039d10:	d840      	bhi.n	8039d94 <RadioSetRxConfig+0x2b0>
                if( preambleLen < 12 )
 8039d12:	2e0b      	cmp	r6, #11
 8039d14:	d83e      	bhi.n	8039d94 <RadioSetRxConfig+0x2b0>
                    SubgRf.PacketParams.Params.LoRa.PreambleLength = 12;
 8039d16:	230c      	movs	r3, #12
 8039d18:	f8aa 301c 	strh.w	r3, [sl, #28]
            SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength;
 8039d1c:	4b22      	ldr	r3, [pc, #136]	; (8039da8 <RadioSetRxConfig+0x2c4>)
            SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t )fixLen;
 8039d1e:	f88a 901e 	strb.w	r9, [sl, #30]
            SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength;
 8039d22:	781b      	ldrb	r3, [r3, #0]
 8039d24:	f88a 301f 	strb.w	r3, [sl, #31]
            SubgRf.PacketParams.Params.LoRa.CrcMode = ( RadioLoRaCrcModes_t )crcOn;
 8039d28:	9b00      	ldr	r3, [sp, #0]
 8039d2a:	f88a 3020 	strb.w	r3, [sl, #32]
            SubgRf.PacketParams.Params.LoRa.InvertIQ = ( RadioLoRaIQModes_t )iqInverted;
 8039d2e:	f89d 3060 	ldrb.w	r3, [sp, #96]	; 0x60
 8039d32:	f88a 3021 	strb.w	r3, [sl, #33]	; 0x21
            RadioStandby( );
 8039d36:	f7ff f967 	bl	8039008 <RadioStandby>
            RadioSetModem( ( SubgRf.ModulationParams.PacketType == PACKET_TYPE_GFSK ) ? MODEM_FSK : MODEM_LORA );
 8039d3a:	f89a 0038 	ldrb.w	r0, [sl, #56]	; 0x38
 8039d3e:	3800      	subs	r0, #0
 8039d40:	bf18      	it	ne
 8039d42:	2001      	movne	r0, #1
 8039d44:	f7ff fbe8 	bl	8039518 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8039d48:	481b      	ldr	r0, [pc, #108]	; (8039db8 <RadioSetRxConfig+0x2d4>)
 8039d4a:	f000 fbc7 	bl	803a4dc <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039d4e:	481b      	ldr	r0, [pc, #108]	; (8039dbc <RadioSetRxConfig+0x2d8>)
 8039d50:	f000 fd5a 	bl	803a808 <SUBGRF_SetPacketParams>
            SUBGRF_SetLoRaSymbNumTimeout( symbTimeout );
 8039d54:	fa5f f088 	uxtb.w	r0, r8
 8039d58:	f000 fb92 	bl	803a480 <SUBGRF_SetLoRaSymbNumTimeout>
            if( SubgRf.PacketParams.Params.LoRa.InvertIQ == LORA_IQ_INVERTED )
 8039d5c:	f89a 3021 	ldrb.w	r3, [sl, #33]	; 0x21
 8039d60:	2b01      	cmp	r3, #1
                SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) & ~( 1 << 2 ) );
 8039d62:	f240 7036 	movw	r0, #1846	; 0x736
            if( SubgRf.PacketParams.Params.LoRa.InvertIQ == LORA_IQ_INVERTED )
 8039d66:	d118      	bne.n	8039d9a <RadioSetRxConfig+0x2b6>
                SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) & ~( 1 << 2 ) );
 8039d68:	f000 fc24 	bl	803a5b4 <SUBGRF_ReadRegister>
 8039d6c:	f000 01fb 	and.w	r1, r0, #251	; 0xfb
                SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) | ( 1 << 2 ) );
 8039d70:	f240 7036 	movw	r0, #1846	; 0x736
 8039d74:	f000 fb58 	bl	803a428 <SUBGRF_WriteRegister>
            SubgRf.RxTimeout = 0xFFFF;
 8039d78:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8039d7c:	f8ca 3008 	str.w	r3, [sl, #8]
}
 8039d80:	e7a5      	b.n	8039cce <RadioSetRxConfig+0x1ea>
            if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 8039d82:	2f01      	cmp	r7, #1
 8039d84:	d104      	bne.n	8039d90 <RadioSetRxConfig+0x2ac>
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x00;
 8039d86:	f1a4 020c 	sub.w	r2, r4, #12
 8039d8a:	4254      	negs	r4, r2
 8039d8c:	4154      	adcs	r4, r2
 8039d8e:	e7b8      	b.n	8039d02 <RadioSetRxConfig+0x21e>
 8039d90:	2400      	movs	r4, #0
 8039d92:	e7b6      	b.n	8039d02 <RadioSetRxConfig+0x21e>
                    SubgRf.PacketParams.Params.LoRa.PreambleLength = preambleLen;
 8039d94:	f8aa 601c 	strh.w	r6, [sl, #28]
 8039d98:	e7c0      	b.n	8039d1c <RadioSetRxConfig+0x238>
                SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) | ( 1 << 2 ) );
 8039d9a:	f000 fc0b 	bl	803a5b4 <SUBGRF_ReadRegister>
 8039d9e:	f040 0104 	orr.w	r1, r0, #4
 8039da2:	b2c9      	uxtb	r1, r1
 8039da4:	e7e4      	b.n	8039d70 <RadioSetRxConfig+0x28c>
 8039da6:	bf00      	nop
 8039da8:	200035a0 	.word	0x200035a0
 8039dac:	0803bc20 	.word	0x0803bc20
 8039db0:	0803bc28 	.word	0x0803bc28
 8039db4:	0803bbec 	.word	0x0803bbec
 8039db8:	2000635c 	.word	0x2000635c
 8039dbc:	20006332 	.word	0x20006332
 8039dc0:	20006324 	.word	0x20006324

08039dc4 <RadioRandom>:
{
 8039dc4:	b508      	push	{r3, lr}
    RadioSetModem( MODEM_LORA );
 8039dc6:	2001      	movs	r0, #1
 8039dc8:	f7ff fba6 	bl	8039518 <RadioSetModem>
    SUBGRF_SetDioIrqParams( IRQ_RADIO_NONE, IRQ_RADIO_NONE, IRQ_RADIO_NONE, IRQ_RADIO_NONE );
 8039dcc:	2300      	movs	r3, #0
 8039dce:	461a      	mov	r2, r3
 8039dd0:	4619      	mov	r1, r3
 8039dd2:	4618      	mov	r0, r3
 8039dd4:	f000 fa8c 	bl	803a2f0 <SUBGRF_SetDioIrqParams>
}
 8039dd8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    rnd = SUBGRF_GetRandom();
 8039ddc:	f000 bd86 	b.w	803a8ec <SUBGRF_GetRandom>

08039de0 <RadioIsChannelFree>:
{
 8039de0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8039de2:	b08b      	sub	sp, #44	; 0x2c
 8039de4:	460d      	mov	r5, r1
 8039de6:	4604      	mov	r4, r0
 8039de8:	4617      	mov	r7, r2
 8039dea:	461e      	mov	r6, r3
    RadioStandby( );
 8039dec:	f7ff f90c 	bl	8039008 <RadioStandby>
    RadioSetModem( MODEM_FSK );
 8039df0:	2000      	movs	r0, #0
 8039df2:	f7ff fb91 	bl	8039518 <RadioSetModem>
    SUBGRF_SetRfFrequency( freq );
 8039df6:	4620      	mov	r0, r4
 8039df8:	f000 faa4 	bl	803a344 <SUBGRF_SetRfFrequency>
    RadioSetRxConfig( MODEM_FSK, rxBandwidth, 600, 0, rxBandwidth, 3, 0, false,
 8039dfc:	2400      	movs	r4, #0
 8039dfe:	2301      	movs	r3, #1
 8039e00:	e9cd 4308 	strd	r4, r3, [sp, #32]
 8039e04:	2303      	movs	r3, #3
 8039e06:	f44f 7216 	mov.w	r2, #600	; 0x258
 8039e0a:	4629      	mov	r1, r5
 8039e0c:	4620      	mov	r0, r4
 8039e0e:	e9cd 4406 	strd	r4, r4, [sp, #24]
 8039e12:	e9cd 4404 	strd	r4, r4, [sp, #16]
 8039e16:	e9cd 4402 	strd	r4, r4, [sp, #8]
 8039e1a:	e9cd 5300 	strd	r5, r3, [sp]
 8039e1e:	4623      	mov	r3, r4
 8039e20:	f7ff fe60 	bl	8039ae4 <RadioSetRxConfig>
    RadioRx( 0 );
 8039e24:	4620      	mov	r0, r4
 8039e26:	f7ff fb2b 	bl	8039480 <RadioRx>
    RADIO_DELAY_MS( RadioGetWakeupTime( ) );
 8039e2a:	f7ff fa27 	bl	803927c <RadioGetWakeupTime>
 8039e2e:	f7f2 fc0b 	bl	802c648 <HAL_Delay>
    carrierSenseTime = TimerGetCurrentTime( );
 8039e32:	f001 fa41 	bl	803b2b8 <UTIL_TIMER_GetCurrentTime>
 8039e36:	4604      	mov	r4, r0
    while( TimerGetElapsedTime( carrierSenseTime ) < maxCarrierSenseTime )
 8039e38:	4620      	mov	r0, r4
 8039e3a:	f001 fa47 	bl	803b2cc <UTIL_TIMER_GetElapsedTime>
 8039e3e:	42b0      	cmp	r0, r6
 8039e40:	d305      	bcc.n	8039e4e <RadioIsChannelFree+0x6e>
    bool status = true;
 8039e42:	2401      	movs	r4, #1
    RadioStandby( );
 8039e44:	f7ff f8e0 	bl	8039008 <RadioStandby>
}
 8039e48:	4620      	mov	r0, r4
 8039e4a:	b00b      	add	sp, #44	; 0x2c
 8039e4c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return SUBGRF_GetRssiInst( );
 8039e4e:	f000 faa4 	bl	803a39a <SUBGRF_GetRssiInst>
        if( rssi > rssiThresh )
 8039e52:	b200      	sxth	r0, r0
 8039e54:	4287      	cmp	r7, r0
 8039e56:	daef      	bge.n	8039e38 <RadioIsChannelFree+0x58>
            status = false;
 8039e58:	2400      	movs	r4, #0
 8039e5a:	e7f3      	b.n	8039e44 <RadioIsChannelFree+0x64>

08039e5c <RadioInit>:
    RadioEvents = events;
 8039e5c:	4b1e      	ldr	r3, [pc, #120]	; (8039ed8 <RadioInit+0x7c>)
{
 8039e5e:	b573      	push	{r0, r1, r4, r5, r6, lr}
    RadioEvents = events;
 8039e60:	6018      	str	r0, [r3, #0]
    SubgRf.RxContinuous = false;
 8039e62:	4b1e      	ldr	r3, [pc, #120]	; (8039edc <RadioInit+0x80>)
    SUBGRF_Init( RadioOnDioIrq );
 8039e64:	481e      	ldr	r0, [pc, #120]	; (8039ee0 <RadioInit+0x84>)
    TimerInit( &TxTimeoutTimer, RadioOnTxTimeoutIrq );
 8039e66:	4e1f      	ldr	r6, [pc, #124]	; (8039ee4 <RadioInit+0x88>)
    TimerInit( &RxTimeoutTimer, RadioOnRxTimeoutIrq );
 8039e68:	4d1f      	ldr	r5, [pc, #124]	; (8039ee8 <RadioInit+0x8c>)
    SubgRf.RxContinuous = false;
 8039e6a:	2400      	movs	r4, #0
    SubgRf.RxTimeout = 0;
 8039e6c:	e9c3 4401 	strd	r4, r4, [r3, #4]
    SubgRf.RxContinuous = false;
 8039e70:	705c      	strb	r4, [r3, #1]
    SUBGRF_Init( RadioOnDioIrq );
 8039e72:	f000 fbc3 	bl	803a5fc <SUBGRF_Init>
    RadioSetPublicNetwork( false );
 8039e76:	4620      	mov	r0, r4
 8039e78:	f7ff fb30 	bl	80394dc <RadioSetPublicNetwork>
    SUBGRF_SetRegulatorMode(  );
 8039e7c:	f000 f9d4 	bl	803a228 <SUBGRF_SetRegulatorMode>
    SUBGRF_SetBufferBaseAddress( 0x00, 0x00 );
 8039e80:	4621      	mov	r1, r4
 8039e82:	4620      	mov	r0, r4
 8039e84:	f000 fa7c 	bl	803a380 <SUBGRF_SetBufferBaseAddress>
    SUBGRF_SetTxParams(RFO_LP, 0, RADIO_RAMP_200_US);
 8039e88:	4621      	mov	r1, r4
 8039e8a:	2204      	movs	r2, #4
 8039e8c:	2001      	movs	r0, #1
 8039e8e:	f000 fc1b 	bl	803a6c8 <SUBGRF_SetTxParams>
    SUBGRF_SetDioIrqParams( IRQ_RADIO_ALL, IRQ_RADIO_ALL, IRQ_RADIO_NONE, IRQ_RADIO_NONE );
 8039e92:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8039e96:	4623      	mov	r3, r4
 8039e98:	4622      	mov	r2, r4
 8039e9a:	4608      	mov	r0, r1
 8039e9c:	f000 fa28 	bl	803a2f0 <SUBGRF_SetDioIrqParams>
    RadioSleep();
 8039ea0:	f7ff fa2c 	bl	80392fc <RadioSleep>
    TimerInit( &TxTimeoutTimer, RadioOnTxTimeoutIrq );
 8039ea4:	4622      	mov	r2, r4
 8039ea6:	4b11      	ldr	r3, [pc, #68]	; (8039eec <RadioInit+0x90>)
 8039ea8:	9400      	str	r4, [sp, #0]
 8039eaa:	f04f 31ff 	mov.w	r1, #4294967295
 8039eae:	4630      	mov	r0, r6
 8039eb0:	f001 f9e8 	bl	803b284 <UTIL_TIMER_Create>
    TimerInit( &RxTimeoutTimer, RadioOnRxTimeoutIrq );
 8039eb4:	4b0e      	ldr	r3, [pc, #56]	; (8039ef0 <RadioInit+0x94>)
 8039eb6:	9400      	str	r4, [sp, #0]
 8039eb8:	4622      	mov	r2, r4
 8039eba:	f04f 31ff 	mov.w	r1, #4294967295
 8039ebe:	4628      	mov	r0, r5
 8039ec0:	f001 f9e0 	bl	803b284 <UTIL_TIMER_Create>
    TimerStop( &TxTimeoutTimer );
 8039ec4:	4630      	mov	r0, r6
 8039ec6:	f001 fa3b 	bl	803b340 <UTIL_TIMER_Stop>
    TimerStop( &RxTimeoutTimer );
 8039eca:	4628      	mov	r0, r5
}
 8039ecc:	b002      	add	sp, #8
 8039ece:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    TimerStop( &RxTimeoutTimer );
 8039ed2:	f001 ba35 	b.w	803b340 <UTIL_TIMER_Stop>
 8039ed6:	bf00      	nop
 8039ed8:	2000597c 	.word	0x2000597c
 8039edc:	20006324 	.word	0x20006324
 8039ee0:	0803926d 	.word	0x0803926d
 8039ee4:	2000637c 	.word	0x2000637c
 8039ee8:	20006394 	.word	0x20006394
 8039eec:	08038fa1 	.word	0x08038fa1
 8039ef0:	08038fb5 	.word	0x08038fb5

08039ef4 <RadioSend>:
{
 8039ef4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    SUBGRF_SetDioIrqParams( IRQ_TX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_TX_DBG,
 8039ef6:	2300      	movs	r3, #0
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_TX);
 8039ef8:	4d66      	ldr	r5, [pc, #408]	; (803a094 <RadioSend+0x1a0>)
{
 8039efa:	460c      	mov	r4, r1
    SUBGRF_SetDioIrqParams( IRQ_TX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_TX_DBG,
 8039efc:	f240 2101 	movw	r1, #513	; 0x201
 8039f00:	461a      	mov	r2, r3
{
 8039f02:	4606      	mov	r6, r0
    SUBGRF_SetDioIrqParams( IRQ_TX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_TX_DBG,
 8039f04:	4608      	mov	r0, r1
 8039f06:	f000 f9f3 	bl	803a2f0 <SUBGRF_SetDioIrqParams>
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_TX);
 8039f0a:	f895 0056 	ldrb.w	r0, [r5, #86]	; 0x56
 8039f0e:	2101      	movs	r1, #1
 8039f10:	f000 fd67 	bl	803a9e2 <SUBGRF_SetSwitch>
    if((SubgRf.Modem==MODEM_LORA) && (SubgRf.ModulationParams.Params.LoRa.Bandwidth == LORA_BW_500 ))
 8039f14:	782b      	ldrb	r3, [r5, #0]
 8039f16:	2b01      	cmp	r3, #1
        SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) & ~( 1 << 2 ) );
 8039f18:	f640 0089 	movw	r0, #2185	; 0x889
    if((SubgRf.Modem==MODEM_LORA) && (SubgRf.ModulationParams.Params.LoRa.Bandwidth == LORA_BW_500 ))
 8039f1c:	d112      	bne.n	8039f44 <RadioSend+0x50>
 8039f1e:	f895 3051 	ldrb.w	r3, [r5, #81]	; 0x51
 8039f22:	2b06      	cmp	r3, #6
 8039f24:	d10e      	bne.n	8039f44 <RadioSend+0x50>
        SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) & ~( 1 << 2 ) );
 8039f26:	f000 fb45 	bl	803a5b4 <SUBGRF_ReadRegister>
 8039f2a:	f000 01fb 	and.w	r1, r0, #251	; 0xfb
        SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) | ( 1 << 2 ) );
 8039f2e:	f640 0089 	movw	r0, #2185	; 0x889
 8039f32:	f000 fa79 	bl	803a428 <SUBGRF_WriteRegister>
    switch(SubgRf.Modem)
 8039f36:	782b      	ldrb	r3, [r5, #0]
 8039f38:	2b03      	cmp	r3, #3
 8039f3a:	d86f      	bhi.n	803a01c <RadioSend+0x128>
 8039f3c:	e8df f003 	tbb	[pc, r3]
 8039f40:	08804e55 	.word	0x08804e55
        SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) | ( 1 << 2 ) );
 8039f44:	f000 fb36 	bl	803a5b4 <SUBGRF_ReadRegister>
 8039f48:	f040 0104 	orr.w	r1, r0, #4
 8039f4c:	b2c9      	uxtb	r1, r1
 8039f4e:	e7ee      	b.n	8039f2e <RadioSend+0x3a>
 8039f50:	4a51      	ldr	r2, [pc, #324]	; (803a098 <RadioSend+0x1a4>)
 8039f52:	1e73      	subs	r3, r6, #1
 8039f54:	4610      	mov	r0, r2
    for (i = 0; i < size; i++)
 8039f56:	f1c6 0701 	rsb	r7, r6, #1
        outBuffer[i] = 0;
 8039f5a:	f04f 0c00 	mov.w	ip, #0
    for (i = 0; i < size; i++)
 8039f5e:	18f9      	adds	r1, r7, r3
 8039f60:	428c      	cmp	r4, r1
 8039f62:	dc71      	bgt.n	803a048 <RadioSend+0x154>
    for (i = 0; i < (size * 8); i++)
 8039f64:	2300      	movs	r3, #0
 8039f66:	00e7      	lsls	r7, r4, #3
    uint8_t prevInt = 0;
 8039f68:	4619      	mov	r1, r3
    for (i = 0; i < (size * 8); i++)
 8039f6a:	42bb      	cmp	r3, r7
 8039f6c:	d173      	bne.n	803a056 <RadioSend+0x162>
    outBuffer[size] = ( prevInt << 7 ) | ( prevInt << 6 ) | ( ( ( !prevInt ) & 0x01 ) << 5 ) ;
 8039f6e:	4a4b      	ldr	r2, [pc, #300]	; (803a09c <RadioSend+0x1a8>)
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039f70:	484b      	ldr	r0, [pc, #300]	; (803a0a0 <RadioSend+0x1ac>)
    outBuffer[size] = ( prevInt << 7 ) | ( prevInt << 6 ) | ( ( ( !prevInt ) & 0x01 ) << 5 ) ;
 8039f72:	2900      	cmp	r1, #0
 8039f74:	ea4f 1381 	mov.w	r3, r1, lsl #6
 8039f78:	ea43 13c1 	orr.w	r3, r3, r1, lsl #7
 8039f7c:	4422      	add	r2, r4
 8039f7e:	bf0c      	ite	eq
 8039f80:	2120      	moveq	r1, #32
 8039f82:	2100      	movne	r1, #0
 8039f84:	430b      	orrs	r3, r1
            SubgRf.PacketParams.Params.Bpsk.PayloadLength = size + 1;
 8039f86:	1c66      	adds	r6, r4, #1
    outBuffer[size] = ( prevInt << 7 ) | ( prevInt << 6 ) | ( ( ( !prevInt ) & 0x01 ) << 5 ) ;
 8039f88:	7113      	strb	r3, [r2, #4]
            SubgRf.PacketParams.Params.Bpsk.PayloadLength = size + 1;
 8039f8a:	b2f6      	uxtb	r6, r6
            SubgRf.PacketParams.PacketType = PACKET_TYPE_BPSK;
 8039f8c:	2302      	movs	r3, #2
 8039f8e:	73ab      	strb	r3, [r5, #14]
            SubgRf.PacketParams.Params.Bpsk.PayloadLength = size + 1;
 8039f90:	76ae      	strb	r6, [r5, #26]
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039f92:	f000 fc39 	bl	803a808 <SUBGRF_SetPacketParams>
    SUBGRF_WriteRegister(addr, data );
 8039f96:	2100      	movs	r1, #0
 8039f98:	20f1      	movs	r0, #241	; 0xf1
 8039f9a:	f000 fa45 	bl	803a428 <SUBGRF_WriteRegister>
 8039f9e:	2100      	movs	r1, #0
 8039fa0:	20f0      	movs	r0, #240	; 0xf0
 8039fa2:	f000 fa41 	bl	803a428 <SUBGRF_WriteRegister>
            if( SubgRf.ModulationParams.Params.Bpsk.BitRate == 100 )
 8039fa6:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8039fa8:	2b64      	cmp	r3, #100	; 0x64
 8039faa:	d16d      	bne.n	803a088 <RadioSend+0x194>
    SUBGRF_WriteRegister(addr, data );
 8039fac:	2170      	movs	r1, #112	; 0x70
 8039fae:	20f3      	movs	r0, #243	; 0xf3
 8039fb0:	f000 fa3a 	bl	803a428 <SUBGRF_WriteRegister>
 8039fb4:	211d      	movs	r1, #29
 8039fb6:	20f2      	movs	r0, #242	; 0xf2
 8039fb8:	f000 fa36 	bl	803a428 <SUBGRF_WriteRegister>
            uint16_t bitNum = ( size * 8 ) + 2;
 8039fbc:	00e1      	lsls	r1, r4, #3
 8039fbe:	1c8c      	adds	r4, r1, #2
    SUBGRF_WriteRegister(addr, data );
 8039fc0:	20f4      	movs	r0, #244	; 0xf4
 8039fc2:	0a09      	lsrs	r1, r1, #8
 8039fc4:	f000 fa30 	bl	803a428 <SUBGRF_WriteRegister>
 8039fc8:	f004 01fe 	and.w	r1, r4, #254	; 0xfe
 8039fcc:	20f5      	movs	r0, #245	; 0xf5
 8039fce:	f000 fa2b 	bl	803a428 <SUBGRF_WriteRegister>
            SUBGRF_SendPayload( RadioBuffer, size+1 , 0xFFFFFF );
 8039fd2:	4831      	ldr	r0, [pc, #196]	; (803a098 <RadioSend+0x1a4>)
 8039fd4:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
 8039fd8:	4631      	mov	r1, r6
 8039fda:	e01d      	b.n	803a018 <RadioSend+0x124>
            SubgRf.PacketParams.Params.LoRa.PayloadLength = size;
 8039fdc:	77ec      	strb	r4, [r5, #31]
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039fde:	4830      	ldr	r0, [pc, #192]	; (803a0a0 <RadioSend+0x1ac>)
 8039fe0:	f000 fc12 	bl	803a808 <SUBGRF_SetPacketParams>
            SUBGRF_SendPayload( buffer, size, 0 );
 8039fe4:	2200      	movs	r2, #0
 8039fe6:	4621      	mov	r1, r4
 8039fe8:	e015      	b.n	803a016 <RadioSend+0x122>
            if ( 1UL == RFW_Is_Init( ) )
 8039fea:	f000 fdc9 	bl	803ab80 <RFW_Is_Init>
 8039fee:	2801      	cmp	r0, #1
 8039ff0:	4607      	mov	r7, r0
 8039ff2:	d123      	bne.n	803a03c <RadioSend+0x148>
              if ( 0UL == RFW_TransmitInit( buffer,size, &outsize ) )
 8039ff4:	4621      	mov	r1, r4
 8039ff6:	f10d 0207 	add.w	r2, sp, #7
 8039ffa:	4630      	mov	r0, r6
 8039ffc:	f000 fdc5 	bl	803ab8a <RFW_TransmitInit>
 803a000:	4604      	mov	r4, r0
 803a002:	b998      	cbnz	r0, 803a02c <RadioSend+0x138>
                  SubgRf.PacketParams.Params.Gfsk.PayloadLength = outsize;
 803a004:	f89d 3007 	ldrb.w	r3, [sp, #7]
                  SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 803a008:	4825      	ldr	r0, [pc, #148]	; (803a0a0 <RadioSend+0x1ac>)
                  SubgRf.PacketParams.Params.Gfsk.PayloadLength = outsize;
 803a00a:	75ab      	strb	r3, [r5, #22]
                  SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 803a00c:	f000 fbfc 	bl	803a808 <SUBGRF_SetPacketParams>
                  SUBGRF_SendPayload( buffer, outsize, 0 );
 803a010:	f89d 1007 	ldrb.w	r1, [sp, #7]
 803a014:	4622      	mov	r2, r4
            SUBGRF_SendPayload( buffer, size, 0 );
 803a016:	4630      	mov	r0, r6
            SUBGRF_SendPayload( RadioBuffer, size+1 , 0xFFFFFF );
 803a018:	f000 fcb1 	bl	803a97e <SUBGRF_SendPayload>
    TimerSetValue( &TxTimeoutTimer, SubgRf.TxTimeout );
 803a01c:	6869      	ldr	r1, [r5, #4]
 803a01e:	4821      	ldr	r0, [pc, #132]	; (803a0a4 <RadioSend+0x1b0>)
 803a020:	f001 fa18 	bl	803b454 <UTIL_TIMER_SetPeriod>
    TimerStart( &TxTimeoutTimer );
 803a024:	481f      	ldr	r0, [pc, #124]	; (803a0a4 <RadioSend+0x1b0>)
 803a026:	f001 f9db 	bl	803b3e0 <UTIL_TIMER_Start>
 803a02a:	e005      	b.n	803a038 <RadioSend+0x144>
                MW_LOG( TS_ON, VLEVEL_M, "RadioSend Oversize\r\n");
 803a02c:	4b1e      	ldr	r3, [pc, #120]	; (803a0a8 <RadioSend+0x1b4>)
 803a02e:	463a      	mov	r2, r7
 803a030:	2100      	movs	r1, #0
 803a032:	2002      	movs	r0, #2
 803a034:	f000 fe62 	bl	803acfc <UTIL_ADV_TRACE_COND_FSend>
}
 803a038:	b003      	add	sp, #12
 803a03a:	bdf0      	pop	{r4, r5, r6, r7, pc}
              SubgRf.PacketParams.Params.Gfsk.PayloadLength = size;
 803a03c:	75ac      	strb	r4, [r5, #22]
              SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 803a03e:	e7ce      	b.n	8039fde <RadioSend+0xea>
            SubgRf.PacketParams.PacketType = PACKET_TYPE_BPSK;
 803a040:	2302      	movs	r3, #2
 803a042:	73ab      	strb	r3, [r5, #14]
            SubgRf.PacketParams.Params.Bpsk.PayloadLength = size;
 803a044:	76ac      	strb	r4, [r5, #26]
 803a046:	e7ca      	b.n	8039fde <RadioSend+0xea>
        inBuffer[i] = ~inBuffer[i];
 803a048:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 803a04c:	43c9      	mvns	r1, r1
 803a04e:	7019      	strb	r1, [r3, #0]
        outBuffer[i] = 0;
 803a050:	f802 cb01 	strb.w	ip, [r2], #1
    for (i = 0; i < size; i++)
 803a054:	e783      	b.n	8039f5e <RadioSend+0x6a>
        index_bit = 7 - ( i % 8 );
 803a056:	43da      	mvns	r2, r3
 803a058:	f002 0c07 	and.w	ip, r2, #7
        index_byte = i / 8;
 803a05c:	10da      	asrs	r2, r3, #3
        index_bit_out = 7 - ( ( i + 1 ) % 8 );
 803a05e:	3301      	adds	r3, #1
        currBit = ( inBuffer[index_byte] >> index_bit ) & 0x01;
 803a060:	5cb2      	ldrb	r2, [r6, r2]
 803a062:	fa42 f20c 	asr.w	r2, r2, ip
 803a066:	f002 0201 	and.w	r2, r2, #1
        index_byte_out = ( i + 1 ) / 8;
 803a06a:	ea4f 0ce3 	mov.w	ip, r3, asr #3
        prevInt ^= currBit;
 803a06e:	4051      	eors	r1, r2
        index_bit_out = 7 - ( ( i + 1 ) % 8 );
 803a070:	43da      	mvns	r2, r3
        outBuffer[index_byte_out] |= ( prevInt << index_bit_out );
 803a072:	f810 e00c 	ldrb.w	lr, [r0, ip]
 803a076:	f002 0207 	and.w	r2, r2, #7
 803a07a:	fa01 f202 	lsl.w	r2, r1, r2
 803a07e:	ea42 020e 	orr.w	r2, r2, lr
 803a082:	f800 200c 	strb.w	r2, [r0, ip]
    for (i = 0; i < (size * 8); i++)
 803a086:	e770      	b.n	8039f6a <RadioSend+0x76>
    SUBGRF_WriteRegister(addr, data );
 803a088:	21e1      	movs	r1, #225	; 0xe1
 803a08a:	20f3      	movs	r0, #243	; 0xf3
 803a08c:	f000 f9cc 	bl	803a428 <SUBGRF_WriteRegister>
 803a090:	2104      	movs	r1, #4
 803a092:	e790      	b.n	8039fb6 <RadioSend+0xc2>
 803a094:	20006324 	.word	0x20006324
 803a098:	20005980 	.word	0x20005980
 803a09c:	2000597c 	.word	0x2000597c
 803a0a0:	20006332 	.word	0x20006332
 803a0a4:	2000637c 	.word	0x2000637c
 803a0a8:	0803c5a9 	.word	0x0803c5a9

0803a0ac <RadioTxPrbs>:
{
 803a0ac:	b508      	push	{r3, lr}
    SUBGRF_SetSwitch( SubgRf.AntSwitchPaSelect, RFSWITCH_TX );
 803a0ae:	4b09      	ldr	r3, [pc, #36]	; (803a0d4 <RadioTxPrbs+0x28>)
 803a0b0:	2101      	movs	r1, #1
 803a0b2:	f893 0056 	ldrb.w	r0, [r3, #86]	; 0x56
 803a0b6:	f000 fc94 	bl	803a9e2 <SUBGRF_SetSwitch>
    SUBGRF_WriteRegister(addr, data );
 803a0ba:	f44f 60d7 	mov.w	r0, #1720	; 0x6b8
 803a0be:	212d      	movs	r1, #45	; 0x2d
 803a0c0:	f000 f9b2 	bl	803a428 <SUBGRF_WriteRegister>
    SUBGRF_SetTxInfinitePreamble( );
 803a0c4:	f000 f89f 	bl	803a206 <SUBGRF_SetTxInfinitePreamble>
}
 803a0c8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    SUBGRF_SetTx( 0x0fffff );
 803a0cc:	4802      	ldr	r0, [pc, #8]	; (803a0d8 <RadioTxPrbs+0x2c>)
 803a0ce:	f000 b841 	b.w	803a154 <SUBGRF_SetTx>
 803a0d2:	bf00      	nop
 803a0d4:	20006324 	.word	0x20006324
 803a0d8:	000fffff 	.word	0x000fffff

0803a0dc <SUBGRF_WriteCommand>:
    CRITICAL_SECTION_END();
}

void SUBGRF_WriteCommand( SUBGHZ_RadioSetCmd_t Command, uint8_t *pBuffer,
                                        uint16_t Size )
{
 803a0dc:	b510      	push	{r4, lr}
 803a0de:	4613      	mov	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803a0e0:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803a0e4:	b672      	cpsid	i
    CRITICAL_SECTION_BEGIN();
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 803a0e6:	460a      	mov	r2, r1
 803a0e8:	4601      	mov	r1, r0
 803a0ea:	4803      	ldr	r0, [pc, #12]	; (803a0f8 <SUBGRF_WriteCommand+0x1c>)
 803a0ec:	f7f5 fd14 	bl	802fb18 <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803a0f0:	f384 8810 	msr	PRIMASK, r4
    CRITICAL_SECTION_END();
}
 803a0f4:	bd10      	pop	{r4, pc}
 803a0f6:	bf00      	nop
 803a0f8:	200061f0 	.word	0x200061f0

0803a0fc <SUBGRF_ReadCommand>:

void SUBGRF_ReadCommand( SUBGHZ_RadioGetCmd_t Command, uint8_t *pBuffer,
                                        uint16_t Size )
{
 803a0fc:	b510      	push	{r4, lr}
 803a0fe:	4613      	mov	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803a100:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803a104:	b672      	cpsid	i
    CRITICAL_SECTION_BEGIN();
    HAL_SUBGHZ_ExecGetCmd( &hsubghz, Command, pBuffer, Size );
 803a106:	460a      	mov	r2, r1
 803a108:	4601      	mov	r1, r0
 803a10a:	4803      	ldr	r0, [pc, #12]	; (803a118 <SUBGRF_ReadCommand+0x1c>)
 803a10c:	f7f5 fda6 	bl	802fc5c <HAL_SUBGHZ_ExecGetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803a110:	f384 8810 	msr	PRIMASK, r4
    CRITICAL_SECTION_END();
}
 803a114:	bd10      	pop	{r4, pc}
 803a116:	bf00      	nop
 803a118:	200061f0 	.word	0x200061f0

0803a11c <SUBGRF_GetOperatingMode>:
}
 803a11c:	4b01      	ldr	r3, [pc, #4]	; (803a124 <SUBGRF_GetOperatingMode+0x8>)
 803a11e:	7818      	ldrb	r0, [r3, #0]
 803a120:	4770      	bx	lr
 803a122:	bf00      	nop
 803a124:	20005a80 	.word	0x20005a80

0803a128 <SUBGRF_SetStandby>:
{
 803a128:	b507      	push	{r0, r1, r2, lr}
    SUBGRF_WriteCommand( RADIO_SET_STANDBY, ( uint8_t* )&standbyConfig, 1 );
 803a12a:	2201      	movs	r2, #1
{
 803a12c:	f88d 0007 	strb.w	r0, [sp, #7]
    SUBGRF_WriteCommand( RADIO_SET_STANDBY, ( uint8_t* )&standbyConfig, 1 );
 803a130:	f10d 0107 	add.w	r1, sp, #7
 803a134:	2080      	movs	r0, #128	; 0x80
 803a136:	f7ff ffd1 	bl	803a0dc <SUBGRF_WriteCommand>
    if( standbyConfig == STDBY_RC )
 803a13a:	f89d 3007 	ldrb.w	r3, [sp, #7]
 803a13e:	2b00      	cmp	r3, #0
 803a140:	4b03      	ldr	r3, [pc, #12]	; (803a150 <SUBGRF_SetStandby+0x28>)
        OperatingMode = MODE_STDBY_XOSC;
 803a142:	bf0c      	ite	eq
 803a144:	2201      	moveq	r2, #1
 803a146:	2202      	movne	r2, #2
 803a148:	701a      	strb	r2, [r3, #0]
}
 803a14a:	b003      	add	sp, #12
 803a14c:	f85d fb04 	ldr.w	pc, [sp], #4
 803a150:	20005a80 	.word	0x20005a80

0803a154 <SUBGRF_SetTx>:
{
 803a154:	b507      	push	{r0, r1, r2, lr}
    OperatingMode = MODE_TX;
 803a156:	4b09      	ldr	r3, [pc, #36]	; (803a17c <SUBGRF_SetTx+0x28>)
    buf[2] = ( uint8_t )( timeout & 0xFF );
 803a158:	f88d 0006 	strb.w	r0, [sp, #6]
    OperatingMode = MODE_TX;
 803a15c:	2204      	movs	r2, #4
 803a15e:	701a      	strb	r2, [r3, #0]
    buf[0] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 803a160:	0c03      	lsrs	r3, r0, #16
 803a162:	f88d 3004 	strb.w	r3, [sp, #4]
    SUBGRF_WriteCommand( RADIO_SET_TX, buf, 3 );
 803a166:	2203      	movs	r2, #3
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 803a168:	0a03      	lsrs	r3, r0, #8
    SUBGRF_WriteCommand( RADIO_SET_TX, buf, 3 );
 803a16a:	a901      	add	r1, sp, #4
 803a16c:	2083      	movs	r0, #131	; 0x83
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 803a16e:	f88d 3005 	strb.w	r3, [sp, #5]
    SUBGRF_WriteCommand( RADIO_SET_TX, buf, 3 );
 803a172:	f7ff ffb3 	bl	803a0dc <SUBGRF_WriteCommand>
}
 803a176:	b003      	add	sp, #12
 803a178:	f85d fb04 	ldr.w	pc, [sp], #4
 803a17c:	20005a80 	.word	0x20005a80

0803a180 <SUBGRF_SetRx>:
{
 803a180:	b507      	push	{r0, r1, r2, lr}
    OperatingMode = MODE_RX;
 803a182:	4b09      	ldr	r3, [pc, #36]	; (803a1a8 <SUBGRF_SetRx+0x28>)
    buf[2] = ( uint8_t )( timeout & 0xFF );
 803a184:	f88d 0006 	strb.w	r0, [sp, #6]
    OperatingMode = MODE_RX;
 803a188:	2205      	movs	r2, #5
 803a18a:	701a      	strb	r2, [r3, #0]
    buf[0] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 803a18c:	0c03      	lsrs	r3, r0, #16
 803a18e:	f88d 3004 	strb.w	r3, [sp, #4]
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 803a192:	2203      	movs	r2, #3
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 803a194:	0a03      	lsrs	r3, r0, #8
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 803a196:	a901      	add	r1, sp, #4
 803a198:	2082      	movs	r0, #130	; 0x82
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 803a19a:	f88d 3005 	strb.w	r3, [sp, #5]
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 803a19e:	f7ff ff9d 	bl	803a0dc <SUBGRF_WriteCommand>
}
 803a1a2:	b003      	add	sp, #12
 803a1a4:	f85d fb04 	ldr.w	pc, [sp], #4
 803a1a8:	20005a80 	.word	0x20005a80

0803a1ac <SUBGRF_SetRxDutyCycle>:
{
 803a1ac:	b507      	push	{r0, r1, r2, lr}
    buf[0] = ( uint8_t )( ( rxTime >> 16 ) & 0xFF );
 803a1ae:	0c03      	lsrs	r3, r0, #16
 803a1b0:	f88d 3000 	strb.w	r3, [sp]
    buf[1] = ( uint8_t )( ( rxTime >> 8 ) & 0xFF );
 803a1b4:	0a03      	lsrs	r3, r0, #8
 803a1b6:	f88d 3001 	strb.w	r3, [sp, #1]
    buf[3] = ( uint8_t )( ( sleepTime >> 16 ) & 0xFF );
 803a1ba:	0c0b      	lsrs	r3, r1, #16
    buf[4] = ( uint8_t )( ( sleepTime >> 8 ) & 0xFF );
 803a1bc:	ba49      	rev16	r1, r1
    buf[2] = ( uint8_t )( rxTime & 0xFF );
 803a1be:	f88d 0002 	strb.w	r0, [sp, #2]
    buf[4] = ( uint8_t )( ( sleepTime >> 8 ) & 0xFF );
 803a1c2:	f8ad 1004 	strh.w	r1, [sp, #4]
    SUBGRF_WriteCommand( RADIO_SET_RXDUTYCYCLE, buf, 6 );
 803a1c6:	2206      	movs	r2, #6
 803a1c8:	4669      	mov	r1, sp
 803a1ca:	2094      	movs	r0, #148	; 0x94
    buf[3] = ( uint8_t )( ( sleepTime >> 16 ) & 0xFF );
 803a1cc:	f88d 3003 	strb.w	r3, [sp, #3]
    SUBGRF_WriteCommand( RADIO_SET_RXDUTYCYCLE, buf, 6 );
 803a1d0:	f7ff ff84 	bl	803a0dc <SUBGRF_WriteCommand>
    OperatingMode = MODE_RX_DC;
 803a1d4:	4b02      	ldr	r3, [pc, #8]	; (803a1e0 <SUBGRF_SetRxDutyCycle+0x34>)
 803a1d6:	2206      	movs	r2, #6
 803a1d8:	701a      	strb	r2, [r3, #0]
}
 803a1da:	b003      	add	sp, #12
 803a1dc:	f85d fb04 	ldr.w	pc, [sp], #4
 803a1e0:	20005a80 	.word	0x20005a80

0803a1e4 <SUBGRF_SetCad>:
    SUBGRF_WriteCommand( RADIO_SET_CAD, 0, 0 );
 803a1e4:	2200      	movs	r2, #0
{
 803a1e6:	b508      	push	{r3, lr}
    SUBGRF_WriteCommand( RADIO_SET_CAD, 0, 0 );
 803a1e8:	4611      	mov	r1, r2
 803a1ea:	20c5      	movs	r0, #197	; 0xc5
 803a1ec:	f7ff ff76 	bl	803a0dc <SUBGRF_WriteCommand>
    OperatingMode = MODE_CAD;
 803a1f0:	4b01      	ldr	r3, [pc, #4]	; (803a1f8 <SUBGRF_SetCad+0x14>)
 803a1f2:	2207      	movs	r2, #7
 803a1f4:	701a      	strb	r2, [r3, #0]
}
 803a1f6:	bd08      	pop	{r3, pc}
 803a1f8:	20005a80 	.word	0x20005a80

0803a1fc <SUBGRF_SetTxContinuousWave>:
    SUBGRF_WriteCommand( RADIO_SET_TXCONTINUOUSWAVE, 0, 0 );
 803a1fc:	2200      	movs	r2, #0
 803a1fe:	4611      	mov	r1, r2
 803a200:	20d1      	movs	r0, #209	; 0xd1
 803a202:	f7ff bf6b 	b.w	803a0dc <SUBGRF_WriteCommand>

0803a206 <SUBGRF_SetTxInfinitePreamble>:
    SUBGRF_WriteCommand( RADIO_SET_TXCONTINUOUSPREAMBLE, 0, 0 );
 803a206:	2200      	movs	r2, #0
 803a208:	4611      	mov	r1, r2
 803a20a:	20d2      	movs	r0, #210	; 0xd2
 803a20c:	f7ff bf66 	b.w	803a0dc <SUBGRF_WriteCommand>

0803a210 <SUBGRF_SetStopRxTimerOnPreambleDetect>:
{
 803a210:	b507      	push	{r0, r1, r2, lr}
    SUBGRF_WriteCommand( RADIO_SET_STOPRXTIMERONPREAMBLE, ( uint8_t* )&enable, 1 );
 803a212:	2201      	movs	r2, #1
{
 803a214:	f88d 0007 	strb.w	r0, [sp, #7]
    SUBGRF_WriteCommand( RADIO_SET_STOPRXTIMERONPREAMBLE, ( uint8_t* )&enable, 1 );
 803a218:	f10d 0107 	add.w	r1, sp, #7
 803a21c:	209f      	movs	r0, #159	; 0x9f
 803a21e:	f7ff ff5d 	bl	803a0dc <SUBGRF_WriteCommand>
}
 803a222:	b003      	add	sp, #12
 803a224:	f85d fb04 	ldr.w	pc, [sp], #4

0803a228 <SUBGRF_SetRegulatorMode>:
{
 803a228:	b507      	push	{r0, r1, r2, lr}
    if ( ( 1UL == RBI_IsDCDC() ) && ( 1UL == DCDC_ENABLE ) )
 803a22a:	f7f2 ffad 	bl	802d188 <RBI_IsDCDC>
 803a22e:	1e43      	subs	r3, r0, #1
 803a230:	4258      	negs	r0, r3
 803a232:	4158      	adcs	r0, r3
 803a234:	f88d 0007 	strb.w	r0, [sp, #7]
    SUBGRF_WriteCommand( RADIO_SET_REGULATORMODE, ( uint8_t* )&mode, 1 );
 803a238:	2201      	movs	r2, #1
 803a23a:	f10d 0107 	add.w	r1, sp, #7
 803a23e:	2096      	movs	r0, #150	; 0x96
 803a240:	f7ff ff4c 	bl	803a0dc <SUBGRF_WriteCommand>
}
 803a244:	b003      	add	sp, #12
 803a246:	f85d fb04 	ldr.w	pc, [sp], #4

0803a24a <SUBGRF_Calibrate>:
{
 803a24a:	b507      	push	{r0, r1, r2, lr}
                      ( ( uint8_t )calibParam.Fields.RC13MEnable << 1 ) |
 803a24c:	f000 007f 	and.w	r0, r0, #127	; 0x7f
    uint8_t value = ( ( ( uint8_t )calibParam.Fields.ImgEnable << 6 ) |
 803a250:	f88d 0007 	strb.w	r0, [sp, #7]
    SUBGRF_WriteCommand( RADIO_CALIBRATE, &value, 1 );
 803a254:	2201      	movs	r2, #1
 803a256:	f10d 0107 	add.w	r1, sp, #7
 803a25a:	2089      	movs	r0, #137	; 0x89
 803a25c:	f7ff ff3e 	bl	803a0dc <SUBGRF_WriteCommand>
}
 803a260:	b003      	add	sp, #12
 803a262:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0803a268 <SUBGRF_CalibrateImage>:
    if( freq > 900000000 )
 803a268:	4b13      	ldr	r3, [pc, #76]	; (803a2b8 <SUBGRF_CalibrateImage+0x50>)
 803a26a:	4298      	cmp	r0, r3
{
 803a26c:	b507      	push	{r0, r1, r2, lr}
    if( freq > 900000000 )
 803a26e:	d90b      	bls.n	803a288 <SUBGRF_CalibrateImage+0x20>
        calFreq[0] = 0xE1;
 803a270:	f64e 13e1 	movw	r3, #59873	; 0xe9e1
        calFreq[0] = 0x6B;
 803a274:	f8ad 3004 	strh.w	r3, [sp, #4]
    SUBGRF_WriteCommand( RADIO_CALIBRATEIMAGE, calFreq, 2 );
 803a278:	2202      	movs	r2, #2
 803a27a:	a901      	add	r1, sp, #4
 803a27c:	2098      	movs	r0, #152	; 0x98
 803a27e:	f7ff ff2d 	bl	803a0dc <SUBGRF_WriteCommand>
}
 803a282:	b003      	add	sp, #12
 803a284:	f85d fb04 	ldr.w	pc, [sp], #4
    else if( freq > 850000000 )
 803a288:	4b0c      	ldr	r3, [pc, #48]	; (803a2bc <SUBGRF_CalibrateImage+0x54>)
 803a28a:	4298      	cmp	r0, r3
 803a28c:	d902      	bls.n	803a294 <SUBGRF_CalibrateImage+0x2c>
        calFreq[0] = 0xD7;
 803a28e:	f64d 33d7 	movw	r3, #56279	; 0xdbd7
 803a292:	e7ef      	b.n	803a274 <SUBGRF_CalibrateImage+0xc>
    else if( freq > 770000000 )
 803a294:	4b0a      	ldr	r3, [pc, #40]	; (803a2c0 <SUBGRF_CalibrateImage+0x58>)
 803a296:	4298      	cmp	r0, r3
 803a298:	d902      	bls.n	803a2a0 <SUBGRF_CalibrateImage+0x38>
        calFreq[0] = 0xC1;
 803a29a:	f24c 53c1 	movw	r3, #50625	; 0xc5c1
 803a29e:	e7e9      	b.n	803a274 <SUBGRF_CalibrateImage+0xc>
    else if( freq > 460000000 )
 803a2a0:	4b08      	ldr	r3, [pc, #32]	; (803a2c4 <SUBGRF_CalibrateImage+0x5c>)
 803a2a2:	4298      	cmp	r0, r3
 803a2a4:	d902      	bls.n	803a2ac <SUBGRF_CalibrateImage+0x44>
        calFreq[0] = 0x75;
 803a2a6:	f248 1375 	movw	r3, #33141	; 0x8175
 803a2aa:	e7e3      	b.n	803a274 <SUBGRF_CalibrateImage+0xc>
    else if( freq > 425000000 )
 803a2ac:	4b06      	ldr	r3, [pc, #24]	; (803a2c8 <SUBGRF_CalibrateImage+0x60>)
 803a2ae:	4298      	cmp	r0, r3
 803a2b0:	d9e2      	bls.n	803a278 <SUBGRF_CalibrateImage+0x10>
        calFreq[0] = 0x6B;
 803a2b2:	f646 736b 	movw	r3, #28523	; 0x6f6b
 803a2b6:	e7dd      	b.n	803a274 <SUBGRF_CalibrateImage+0xc>
 803a2b8:	35a4e900 	.word	0x35a4e900
 803a2bc:	32a9f880 	.word	0x32a9f880
 803a2c0:	2de54480 	.word	0x2de54480
 803a2c4:	1b6b0b00 	.word	0x1b6b0b00
 803a2c8:	1954fc40 	.word	0x1954fc40

0803a2cc <SUBGRF_SetPaConfig>:
{
 803a2cc:	b507      	push	{r0, r1, r2, lr}
    buf[2] = deviceSel;
 803a2ce:	f88d 2006 	strb.w	r2, [sp, #6]
    SUBGRF_WriteCommand( RADIO_SET_PACONFIG, buf, 4 );
 803a2d2:	2204      	movs	r2, #4
    buf[0] = paDutyCycle;
 803a2d4:	f88d 0004 	strb.w	r0, [sp, #4]
    buf[1] = hpMax;
 803a2d8:	f88d 1005 	strb.w	r1, [sp, #5]
    SUBGRF_WriteCommand( RADIO_SET_PACONFIG, buf, 4 );
 803a2dc:	2095      	movs	r0, #149	; 0x95
 803a2de:	eb0d 0102 	add.w	r1, sp, r2
    buf[3] = paLut;
 803a2e2:	f88d 3007 	strb.w	r3, [sp, #7]
    SUBGRF_WriteCommand( RADIO_SET_PACONFIG, buf, 4 );
 803a2e6:	f7ff fef9 	bl	803a0dc <SUBGRF_WriteCommand>
}
 803a2ea:	b003      	add	sp, #12
 803a2ec:	f85d fb04 	ldr.w	pc, [sp], #4

0803a2f0 <SUBGRF_SetDioIrqParams>:
{
 803a2f0:	b507      	push	{r0, r1, r2, lr}
    buf[4] = ( uint8_t )( ( dio2Mask >> 8 ) & 0x00FF );
 803a2f2:	ba52      	rev16	r2, r2
 803a2f4:	f8ad 2004 	strh.w	r2, [sp, #4]
    buf[0] = ( uint8_t )( ( irqMask >> 8 ) & 0x00FF );
 803a2f8:	ba40      	rev16	r0, r0
    SUBGRF_WriteCommand( RADIO_CFG_DIOIRQ, buf, 8 );
 803a2fa:	2208      	movs	r2, #8
    buf[2] = ( uint8_t )( ( dio1Mask >> 8 ) & 0x00FF );
 803a2fc:	ba49      	rev16	r1, r1
    buf[0] = ( uint8_t )( ( irqMask >> 8 ) & 0x00FF );
 803a2fe:	f8ad 0000 	strh.w	r0, [sp]
    buf[2] = ( uint8_t )( ( dio1Mask >> 8 ) & 0x00FF );
 803a302:	f8ad 1002 	strh.w	r1, [sp, #2]
    buf[6] = ( uint8_t )( ( dio3Mask >> 8 ) & 0x00FF );
 803a306:	ba5b      	rev16	r3, r3
    SUBGRF_WriteCommand( RADIO_CFG_DIOIRQ, buf, 8 );
 803a308:	4669      	mov	r1, sp
 803a30a:	4610      	mov	r0, r2
    buf[6] = ( uint8_t )( ( dio3Mask >> 8 ) & 0x00FF );
 803a30c:	f8ad 3006 	strh.w	r3, [sp, #6]
    SUBGRF_WriteCommand( RADIO_CFG_DIOIRQ, buf, 8 );
 803a310:	f7ff fee4 	bl	803a0dc <SUBGRF_WriteCommand>
}
 803a314:	b003      	add	sp, #12
 803a316:	f85d fb04 	ldr.w	pc, [sp], #4

0803a31a <SUBGRF_SetTcxoMode>:
{
 803a31a:	b507      	push	{r0, r1, r2, lr}
    buf[1] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 803a31c:	0c0b      	lsrs	r3, r1, #16
    SUBGRF_WriteCommand( RADIO_SET_TCXOMODE, buf, 4 );
 803a31e:	2204      	movs	r2, #4
    buf[0] = tcxoVoltage & 0x07;
 803a320:	f000 0007 	and.w	r0, r0, #7
    buf[2] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 803a324:	ba49      	rev16	r1, r1
    buf[0] = tcxoVoltage & 0x07;
 803a326:	f88d 0004 	strb.w	r0, [sp, #4]
    buf[2] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 803a32a:	f8ad 1006 	strh.w	r1, [sp, #6]
    SUBGRF_WriteCommand( RADIO_SET_TCXOMODE, buf, 4 );
 803a32e:	2097      	movs	r0, #151	; 0x97
 803a330:	eb0d 0102 	add.w	r1, sp, r2
    buf[1] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 803a334:	f88d 3005 	strb.w	r3, [sp, #5]
    SUBGRF_WriteCommand( RADIO_SET_TCXOMODE, buf, 4 );
 803a338:	f7ff fed0 	bl	803a0dc <SUBGRF_WriteCommand>
}
 803a33c:	b003      	add	sp, #12
 803a33e:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0803a344 <SUBGRF_SetRfFrequency>:
{
 803a344:	b537      	push	{r0, r1, r2, r4, r5, lr}
    if( ImageCalibrated == false )
 803a346:	4d0c      	ldr	r5, [pc, #48]	; (803a378 <SUBGRF_SetRfFrequency+0x34>)
 803a348:	786b      	ldrb	r3, [r5, #1]
{
 803a34a:	4604      	mov	r4, r0
    if( ImageCalibrated == false )
 803a34c:	b91b      	cbnz	r3, 803a356 <SUBGRF_SetRfFrequency+0x12>
        SUBGRF_CalibrateImage( frequency );
 803a34e:	f7ff ff8b 	bl	803a268 <SUBGRF_CalibrateImage>
        ImageCalibrated = true;
 803a352:	2301      	movs	r3, #1
 803a354:	706b      	strb	r3, [r5, #1]
    SX_FREQ_TO_CHANNEL(chan, frequency);   
 803a356:	2300      	movs	r3, #0
 803a358:	4a08      	ldr	r2, [pc, #32]	; (803a37c <SUBGRF_SetRfFrequency+0x38>)
 803a35a:	0660      	lsls	r0, r4, #25
 803a35c:	09e1      	lsrs	r1, r4, #7
 803a35e:	f7f1 fbf1 	bl	802bb44 <__aeabi_uldivmod>
    SUBGRF_WriteCommand( RADIO_SET_RFFREQUENCY, buf, 4 );
 803a362:	2204      	movs	r2, #4
 803a364:	ba00      	rev	r0, r0
    buf[0] = ( uint8_t )( ( chan >> 24 ) & 0xFF );
 803a366:	9001      	str	r0, [sp, #4]
    SUBGRF_WriteCommand( RADIO_SET_RFFREQUENCY, buf, 4 );
 803a368:	eb0d 0102 	add.w	r1, sp, r2
 803a36c:	2086      	movs	r0, #134	; 0x86
 803a36e:	f7ff feb5 	bl	803a0dc <SUBGRF_WriteCommand>
}
 803a372:	b003      	add	sp, #12
 803a374:	bd30      	pop	{r4, r5, pc}
 803a376:	bf00      	nop
 803a378:	20005a80 	.word	0x20005a80
 803a37c:	01e84800 	.word	0x01e84800

0803a380 <SUBGRF_SetBufferBaseAddress>:
{
 803a380:	b507      	push	{r0, r1, r2, lr}
    SUBGRF_WriteCommand( RADIO_SET_BUFFERBASEADDRESS, buf, 2 );
 803a382:	2202      	movs	r2, #2
    buf[0] = txBaseAddress;
 803a384:	f88d 0004 	strb.w	r0, [sp, #4]
    buf[1] = rxBaseAddress;
 803a388:	f88d 1005 	strb.w	r1, [sp, #5]
    SUBGRF_WriteCommand( RADIO_SET_BUFFERBASEADDRESS, buf, 2 );
 803a38c:	208f      	movs	r0, #143	; 0x8f
 803a38e:	a901      	add	r1, sp, #4
 803a390:	f7ff fea4 	bl	803a0dc <SUBGRF_WriteCommand>
}
 803a394:	b003      	add	sp, #12
 803a396:	f85d fb04 	ldr.w	pc, [sp], #4

0803a39a <SUBGRF_GetRssiInst>:
{
 803a39a:	b507      	push	{r0, r1, r2, lr}
    SUBGRF_ReadCommand( RADIO_GET_RSSIINST, buf, 1 );
 803a39c:	2201      	movs	r2, #1
 803a39e:	a901      	add	r1, sp, #4
 803a3a0:	2015      	movs	r0, #21
 803a3a2:	f7ff feab 	bl	803a0fc <SUBGRF_ReadCommand>
    rssi = -buf[0] >> 1;
 803a3a6:	f89d 0004 	ldrb.w	r0, [sp, #4]
 803a3aa:	4240      	negs	r0, r0
}
 803a3ac:	1040      	asrs	r0, r0, #1
 803a3ae:	b003      	add	sp, #12
 803a3b0:	f85d fb04 	ldr.w	pc, [sp], #4

0803a3b4 <SUBGRF_GetPacketStatus>:
{
 803a3b4:	b513      	push	{r0, r1, r4, lr}
    SUBGRF_ReadCommand( RADIO_GET_PACKETSTATUS, status, 3 );
 803a3b6:	2203      	movs	r2, #3
{
 803a3b8:	4604      	mov	r4, r0
    SUBGRF_ReadCommand( RADIO_GET_PACKETSTATUS, status, 3 );
 803a3ba:	a901      	add	r1, sp, #4
 803a3bc:	2014      	movs	r0, #20
 803a3be:	f7ff fe9d 	bl	803a0fc <SUBGRF_ReadCommand>
    return PacketType;
 803a3c2:	4918      	ldr	r1, [pc, #96]	; (803a424 <SUBGRF_GetPacketStatus+0x70>)
 803a3c4:	788a      	ldrb	r2, [r1, #2]
    pktStatus->packetType = SUBGRF_GetPacketType( );
 803a3c6:	7022      	strb	r2, [r4, #0]
    switch( pktStatus->packetType )
 803a3c8:	b14a      	cbz	r2, 803a3de <SUBGRF_GetPacketStatus+0x2a>
 803a3ca:	2a01      	cmp	r2, #1
 803a3cc:	d017      	beq.n	803a3fe <SUBGRF_GetPacketStatus+0x4a>
            RADIO_MEMSET8( pktStatus, 0, sizeof( PacketStatus_t ) );
 803a3ce:	2214      	movs	r2, #20
 803a3d0:	2100      	movs	r1, #0
 803a3d2:	4620      	mov	r0, r4
 803a3d4:	f000 fda4 	bl	803af20 <UTIL_MEM_set_8>
            pktStatus->packetType = PACKET_TYPE_NONE;
 803a3d8:	230f      	movs	r3, #15
 803a3da:	7023      	strb	r3, [r4, #0]
}
 803a3dc:	e00d      	b.n	803a3fa <SUBGRF_GetPacketStatus+0x46>
            pktStatus->Params.Gfsk.RxStatus = status[0];
 803a3de:	f89d 3004 	ldrb.w	r3, [sp, #4]
 803a3e2:	7123      	strb	r3, [r4, #4]
            pktStatus->Params.Gfsk.RssiSync = -status[1] >> 1;
 803a3e4:	f89d 3005 	ldrb.w	r3, [sp, #5]
            pktStatus->Params.Gfsk.FreqError = 0;
 803a3e8:	60a2      	str	r2, [r4, #8]
            pktStatus->Params.Gfsk.RssiSync = -status[1] >> 1;
 803a3ea:	425b      	negs	r3, r3
 803a3ec:	105b      	asrs	r3, r3, #1
 803a3ee:	71a3      	strb	r3, [r4, #6]
            pktStatus->Params.Gfsk.RssiAvg = -status[2] >> 1;
 803a3f0:	f89d 3006 	ldrb.w	r3, [sp, #6]
 803a3f4:	425b      	negs	r3, r3
 803a3f6:	105b      	asrs	r3, r3, #1
 803a3f8:	7163      	strb	r3, [r4, #5]
}
 803a3fa:	b002      	add	sp, #8
 803a3fc:	bd10      	pop	{r4, pc}
            pktStatus->Params.LoRa.RssiPkt = -status[0] >> 1;
 803a3fe:	f89d 3004 	ldrb.w	r3, [sp, #4]
 803a402:	425b      	negs	r3, r3
 803a404:	105b      	asrs	r3, r3, #1
 803a406:	7323      	strb	r3, [r4, #12]
            pktStatus->Params.LoRa.SnrPkt = ( ( ( int8_t )status[1] ) + 2 ) >> 2;
 803a408:	f99d 3005 	ldrsb.w	r3, [sp, #5]
 803a40c:	3302      	adds	r3, #2
 803a40e:	109b      	asrs	r3, r3, #2
 803a410:	7363      	strb	r3, [r4, #13]
            pktStatus->Params.LoRa.SignalRssiPkt = -status[2] >> 1;
 803a412:	f89d 3006 	ldrb.w	r3, [sp, #6]
 803a416:	425b      	negs	r3, r3
 803a418:	105b      	asrs	r3, r3, #1
 803a41a:	73a3      	strb	r3, [r4, #14]
            pktStatus->Params.LoRa.FreqError = FrequencyError;
 803a41c:	684b      	ldr	r3, [r1, #4]
 803a41e:	6123      	str	r3, [r4, #16]
            break;
 803a420:	e7eb      	b.n	803a3fa <SUBGRF_GetPacketStatus+0x46>
 803a422:	bf00      	nop
 803a424:	20005a80 	.word	0x20005a80

0803a428 <SUBGRF_WriteRegister>:
{
 803a428:	b507      	push	{r0, r1, r2, lr}
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 803a42a:	2301      	movs	r3, #1
{
 803a42c:	f88d 1007 	strb.w	r1, [sp, #7]
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 803a430:	f10d 0207 	add.w	r2, sp, #7
 803a434:	4601      	mov	r1, r0
 803a436:	4803      	ldr	r0, [pc, #12]	; (803a444 <SUBGRF_WriteRegister+0x1c>)
 803a438:	f7f5 fafa 	bl	802fa30 <HAL_SUBGHZ_WriteRegisters>
}
 803a43c:	b003      	add	sp, #12
 803a43e:	f85d fb04 	ldr.w	pc, [sp], #4
 803a442:	bf00      	nop
 803a444:	200061f0 	.word	0x200061f0

0803a448 <SUBGRF_SetRxBoosted>:
{
 803a448:	b513      	push	{r0, r1, r4, lr}
    OperatingMode = MODE_RX;
 803a44a:	4b0c      	ldr	r3, [pc, #48]	; (803a47c <SUBGRF_SetRxBoosted+0x34>)
{
 803a44c:	4604      	mov	r4, r0
    OperatingMode = MODE_RX;
 803a44e:	2205      	movs	r2, #5
    SUBGRF_WriteRegister( REG_RX_GAIN, 0x97 ); // max LNA gain, increase current by ~2mA for around ~3dB in sensitivity
 803a450:	2197      	movs	r1, #151	; 0x97
 803a452:	f640 00ac 	movw	r0, #2220	; 0x8ac
    OperatingMode = MODE_RX;
 803a456:	701a      	strb	r2, [r3, #0]
    SUBGRF_WriteRegister( REG_RX_GAIN, 0x97 ); // max LNA gain, increase current by ~2mA for around ~3dB in sensitivity
 803a458:	f7ff ffe6 	bl	803a428 <SUBGRF_WriteRegister>
    buf[0] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 803a45c:	0c23      	lsrs	r3, r4, #16
 803a45e:	f88d 3004 	strb.w	r3, [sp, #4]
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 803a462:	2203      	movs	r2, #3
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 803a464:	0a23      	lsrs	r3, r4, #8
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 803a466:	a901      	add	r1, sp, #4
 803a468:	2082      	movs	r0, #130	; 0x82
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 803a46a:	f88d 3005 	strb.w	r3, [sp, #5]
    buf[2] = ( uint8_t )( timeout & 0xFF );
 803a46e:	f88d 4006 	strb.w	r4, [sp, #6]
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 803a472:	f7ff fe33 	bl	803a0dc <SUBGRF_WriteCommand>
}
 803a476:	b002      	add	sp, #8
 803a478:	bd10      	pop	{r4, pc}
 803a47a:	bf00      	nop
 803a47c:	20005a80 	.word	0x20005a80

0803a480 <SUBGRF_SetLoRaSymbNumTimeout>:
{
 803a480:	b507      	push	{r0, r1, r2, lr}
    SUBGRF_WriteCommand( RADIO_SET_LORASYMBTIMEOUT, &symbNum, 1 );
 803a482:	2201      	movs	r2, #1
{
 803a484:	f88d 0007 	strb.w	r0, [sp, #7]
    SUBGRF_WriteCommand( RADIO_SET_LORASYMBTIMEOUT, &symbNum, 1 );
 803a488:	f10d 0107 	add.w	r1, sp, #7
 803a48c:	20a0      	movs	r0, #160	; 0xa0
 803a48e:	f7ff fe25 	bl	803a0dc <SUBGRF_WriteCommand>
    if( symbNum >= 64 )
 803a492:	f89d 1007 	ldrb.w	r1, [sp, #7]
 803a496:	293f      	cmp	r1, #63	; 0x3f
 803a498:	d907      	bls.n	803a4aa <SUBGRF_SetLoRaSymbNumTimeout+0x2a>
        reg = exp + ( mant << 3 );
 803a49a:	f001 01f8 	and.w	r1, r1, #248	; 0xf8
 803a49e:	3101      	adds	r1, #1
        SUBGRF_WriteRegister( REG_LR_SYNCH_TIMEOUT, reg );
 803a4a0:	b2c9      	uxtb	r1, r1
 803a4a2:	f240 7006 	movw	r0, #1798	; 0x706
 803a4a6:	f7ff ffbf 	bl	803a428 <SUBGRF_WriteRegister>
}
 803a4aa:	b003      	add	sp, #12
 803a4ac:	f85d fb04 	ldr.w	pc, [sp], #4

0803a4b0 <SUBGRF_SetPacketType>:
{
 803a4b0:	b507      	push	{r0, r1, r2, lr}
    PacketType = packetType;
 803a4b2:	4b09      	ldr	r3, [pc, #36]	; (803a4d8 <SUBGRF_SetPacketType+0x28>)
{
 803a4b4:	f88d 0007 	strb.w	r0, [sp, #7]
 803a4b8:	4601      	mov	r1, r0
    PacketType = packetType;
 803a4ba:	7098      	strb	r0, [r3, #2]
    if( packetType == PACKET_TYPE_GFSK )
 803a4bc:	b918      	cbnz	r0, 803a4c6 <SUBGRF_SetPacketType+0x16>
        SUBGRF_WriteRegister( REG_BIT_SYNC, 0x00 );
 803a4be:	f240 60ac 	movw	r0, #1708	; 0x6ac
 803a4c2:	f7ff ffb1 	bl	803a428 <SUBGRF_WriteRegister>
    SUBGRF_WriteCommand( RADIO_SET_PACKETTYPE, ( uint8_t* )&packetType, 1 );
 803a4c6:	2201      	movs	r2, #1
 803a4c8:	f10d 0107 	add.w	r1, sp, #7
 803a4cc:	208a      	movs	r0, #138	; 0x8a
 803a4ce:	f7ff fe05 	bl	803a0dc <SUBGRF_WriteCommand>
}
 803a4d2:	b003      	add	sp, #12
 803a4d4:	f85d fb04 	ldr.w	pc, [sp], #4
 803a4d8:	20005a80 	.word	0x20005a80

0803a4dc <SUBGRF_SetModulationParams>:
{
 803a4dc:	b513      	push	{r0, r1, r4, lr}
    uint8_t buf[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 803a4de:	4a31      	ldr	r2, [pc, #196]	; (803a5a4 <SUBGRF_SetModulationParams+0xc8>)
{
 803a4e0:	4604      	mov	r4, r0
    uint8_t buf[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 803a4e2:	6851      	ldr	r1, [r2, #4]
 803a4e4:	6810      	ldr	r0, [r2, #0]
 803a4e6:	466b      	mov	r3, sp
 803a4e8:	c303      	stmia	r3!, {r0, r1}
    if( PacketType != modulationParams->PacketType )
 803a4ea:	4b2f      	ldr	r3, [pc, #188]	; (803a5a8 <SUBGRF_SetModulationParams+0xcc>)
 803a4ec:	7820      	ldrb	r0, [r4, #0]
 803a4ee:	789b      	ldrb	r3, [r3, #2]
 803a4f0:	4283      	cmp	r3, r0
 803a4f2:	d001      	beq.n	803a4f8 <SUBGRF_SetModulationParams+0x1c>
        SUBGRF_SetPacketType( modulationParams->PacketType );
 803a4f4:	f7ff ffdc 	bl	803a4b0 <SUBGRF_SetPacketType>
    switch( modulationParams->PacketType )
 803a4f8:	7823      	ldrb	r3, [r4, #0]
 803a4fa:	2b03      	cmp	r3, #3
 803a4fc:	d827      	bhi.n	803a54e <SUBGRF_SetModulationParams+0x72>
 803a4fe:	e8df f003 	tbb	[pc, r3]
 803a502:	3902      	.short	0x3902
 803a504:	3c28      	.short	0x3c28
        tempVal = ( uint32_t )(( 32 * XTAL_FREQ ) / modulationParams->Params.Gfsk.BitRate );
 803a506:	6862      	ldr	r2, [r4, #4]
 803a508:	4b28      	ldr	r3, [pc, #160]	; (803a5ac <SUBGRF_SetModulationParams+0xd0>)
 803a50a:	fbb3 f3f2 	udiv	r3, r3, r2
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 803a50e:	0c1a      	lsrs	r2, r3, #16
        SX_FREQ_TO_CHANNEL(tempVal, modulationParams->Params.Gfsk.Fdev);
 803a510:	68a1      	ldr	r1, [r4, #8]
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 803a512:	f88d 2000 	strb.w	r2, [sp]
        buf[2] = tempVal & 0xFF;
 803a516:	f88d 3002 	strb.w	r3, [sp, #2]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 803a51a:	0a1a      	lsrs	r2, r3, #8
        buf[3] = modulationParams->Params.Gfsk.ModulationShaping;
 803a51c:	7b23      	ldrb	r3, [r4, #12]
 803a51e:	f88d 3003 	strb.w	r3, [sp, #3]
        buf[4] = modulationParams->Params.Gfsk.Bandwidth;
 803a522:	7b63      	ldrb	r3, [r4, #13]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 803a524:	f88d 2001 	strb.w	r2, [sp, #1]
        buf[4] = modulationParams->Params.Gfsk.Bandwidth;
 803a528:	f88d 3004 	strb.w	r3, [sp, #4]
        SX_FREQ_TO_CHANNEL(tempVal, modulationParams->Params.Gfsk.Fdev);
 803a52c:	4a20      	ldr	r2, [pc, #128]	; (803a5b0 <SUBGRF_SetModulationParams+0xd4>)
 803a52e:	2300      	movs	r3, #0
 803a530:	0648      	lsls	r0, r1, #25
 803a532:	09c9      	lsrs	r1, r1, #7
 803a534:	f7f1 fb06 	bl	802bb44 <__aeabi_uldivmod>
        buf[5] = ( tempVal >> 16 ) & 0xFF;
 803a538:	0c03      	lsrs	r3, r0, #16
        buf[6] = ( tempVal >> 8 ) & 0xFF;
 803a53a:	ba40      	rev16	r0, r0
        buf[5] = ( tempVal >> 16 ) & 0xFF;
 803a53c:	f88d 3005 	strb.w	r3, [sp, #5]
        buf[6] = ( tempVal >> 8 ) & 0xFF;
 803a540:	f8ad 0006 	strh.w	r0, [sp, #6]
        SUBGRF_WriteCommand( RADIO_SET_MODULATIONPARAMS, buf, n );
 803a544:	2208      	movs	r2, #8
        SUBGRF_WriteCommand( RADIO_SET_MODULATIONPARAMS, buf, n );
 803a546:	4669      	mov	r1, sp
 803a548:	208b      	movs	r0, #139	; 0x8b
 803a54a:	f7ff fdc7 	bl	803a0dc <SUBGRF_WriteCommand>
}
 803a54e:	b002      	add	sp, #8
 803a550:	bd10      	pop	{r4, pc}
        tempVal = ( uint32_t ) (( 32 * XTAL_FREQ) / modulationParams->Params.Bpsk.BitRate );
 803a552:	6922      	ldr	r2, [r4, #16]
 803a554:	4b15      	ldr	r3, [pc, #84]	; (803a5ac <SUBGRF_SetModulationParams+0xd0>)
 803a556:	fbb3 f3f2 	udiv	r3, r3, r2
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 803a55a:	0c1a      	lsrs	r2, r3, #16
 803a55c:	f88d 2000 	strb.w	r2, [sp]
        buf[2] = tempVal & 0xFF;
 803a560:	f88d 3002 	strb.w	r3, [sp, #2]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 803a564:	0a1a      	lsrs	r2, r3, #8
        buf[3] = modulationParams->Params.Bpsk.ModulationShaping;
 803a566:	7d23      	ldrb	r3, [r4, #20]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 803a568:	f88d 2001 	strb.w	r2, [sp, #1]
        buf[3] = modulationParams->Params.Bpsk.ModulationShaping;
 803a56c:	f88d 3003 	strb.w	r3, [sp, #3]
        SUBGRF_WriteCommand( RADIO_SET_MODULATIONPARAMS, buf, n );
 803a570:	2204      	movs	r2, #4
 803a572:	e7e8      	b.n	803a546 <SUBGRF_SetModulationParams+0x6a>
        buf[0] = modulationParams->Params.LoRa.SpreadingFactor;
 803a574:	69a3      	ldr	r3, [r4, #24]
 803a576:	9300      	str	r3, [sp, #0]
 803a578:	e7fa      	b.n	803a570 <SUBGRF_SetModulationParams+0x94>
        tempVal = ( uint32_t )(( 32 *XTAL_FREQ) / modulationParams->Params.Gfsk.BitRate );
 803a57a:	6862      	ldr	r2, [r4, #4]
 803a57c:	4b0b      	ldr	r3, [pc, #44]	; (803a5ac <SUBGRF_SetModulationParams+0xd0>)
 803a57e:	fbb3 f3f2 	udiv	r3, r3, r2
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 803a582:	0c1a      	lsrs	r2, r3, #16
 803a584:	f88d 2000 	strb.w	r2, [sp]
        buf[2] = tempVal & 0xFF;
 803a588:	f88d 3002 	strb.w	r3, [sp, #2]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 803a58c:	0a1a      	lsrs	r2, r3, #8
        buf[3] = modulationParams->Params.Gfsk.ModulationShaping;
 803a58e:	7b23      	ldrb	r3, [r4, #12]
 803a590:	f88d 3003 	strb.w	r3, [sp, #3]
        buf[4] = modulationParams->Params.Gfsk.Bandwidth;
 803a594:	7b63      	ldrb	r3, [r4, #13]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 803a596:	f88d 2001 	strb.w	r2, [sp, #1]
        buf[4] = modulationParams->Params.Gfsk.Bandwidth;
 803a59a:	f88d 3004 	strb.w	r3, [sp, #4]
        SUBGRF_WriteCommand( RADIO_SET_MODULATIONPARAMS, buf, n );
 803a59e:	2205      	movs	r2, #5
 803a5a0:	e7d1      	b.n	803a546 <SUBGRF_SetModulationParams+0x6a>
 803a5a2:	bf00      	nop
 803a5a4:	0803bcb4 	.word	0x0803bcb4
 803a5a8:	20005a80 	.word	0x20005a80
 803a5ac:	3d090000 	.word	0x3d090000
 803a5b0:	01e84800 	.word	0x01e84800

0803a5b4 <SUBGRF_ReadRegister>:
{
 803a5b4:	b507      	push	{r0, r1, r2, lr}
    HAL_SUBGHZ_ReadRegisters( &hsubghz, addr, &data, 1 );
 803a5b6:	2301      	movs	r3, #1
{
 803a5b8:	4601      	mov	r1, r0
    HAL_SUBGHZ_ReadRegisters( &hsubghz, addr, &data, 1 );
 803a5ba:	f10d 0207 	add.w	r2, sp, #7
 803a5be:	4804      	ldr	r0, [pc, #16]	; (803a5d0 <SUBGRF_ReadRegister+0x1c>)
 803a5c0:	f7f5 fa6f 	bl	802faa2 <HAL_SUBGHZ_ReadRegisters>
}
 803a5c4:	f89d 0007 	ldrb.w	r0, [sp, #7]
 803a5c8:	b003      	add	sp, #12
 803a5ca:	f85d fb04 	ldr.w	pc, [sp], #4
 803a5ce:	bf00      	nop
 803a5d0:	200061f0 	.word	0x200061f0

0803a5d4 <Radio_SMPS_Set>:
{
    RadioOnDioIrqCb( IRQ_HEADER_VALID );
}

static void Radio_SMPS_Set(uint8_t level)
{
 803a5d4:	b510      	push	{r4, lr}
 803a5d6:	4604      	mov	r4, r0
  if ( 1U == RBI_IsDCDC() )
 803a5d8:	f7f2 fdd6 	bl	802d188 <RBI_IsDCDC>
 803a5dc:	2801      	cmp	r0, #1
 803a5de:	d10c      	bne.n	803a5fa <Radio_SMPS_Set+0x26>
  {
    uint8_t modReg;
    modReg= SUBGRF_ReadRegister(SUBGHZ_SMPSC2R);
 803a5e0:	f640 1023 	movw	r0, #2339	; 0x923
 803a5e4:	f7ff ffe6 	bl	803a5b4 <SUBGRF_ReadRegister>
    modReg&= (~SMPS_DRV_MASK);
    SUBGRF_WriteRegister(SUBGHZ_SMPSC2R, modReg | level);
 803a5e8:	f000 01f9 	and.w	r1, r0, #249	; 0xf9
 803a5ec:	4321      	orrs	r1, r4
 803a5ee:	f640 1023 	movw	r0, #2339	; 0x923
  }
}
 803a5f2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    SUBGRF_WriteRegister(SUBGHZ_SMPSC2R, modReg | level);
 803a5f6:	f7ff bf17 	b.w	803a428 <SUBGRF_WriteRegister>
}
 803a5fa:	bd10      	pop	{r4, pc}

0803a5fc <SUBGRF_Init>:
{
 803a5fc:	b538      	push	{r3, r4, r5, lr}
 803a5fe:	4c16      	ldr	r4, [pc, #88]	; (803a658 <SUBGRF_Init+0x5c>)
    if ( dioIrq != NULL)
 803a600:	b100      	cbz	r0, 803a604 <SUBGRF_Init+0x8>
        RadioOnDioIrqCb = dioIrq;
 803a602:	60a0      	str	r0, [r4, #8]
    RADIO_INIT();
 803a604:	f7f1 ff22 	bl	802c44c <MX_SUBGHZ_Init>
    ImageCalibrated = false;
 803a608:	2500      	movs	r5, #0
    Radio_SMPS_Set(SMPS_DRIVE_SETTING_DEFAULT);
 803a60a:	2002      	movs	r0, #2
 803a60c:	f7ff ffe2 	bl	803a5d4 <Radio_SMPS_Set>
    SUBGRF_SetStandby( STDBY_RC );
 803a610:	4628      	mov	r0, r5
    ImageCalibrated = false;
 803a612:	7065      	strb	r5, [r4, #1]
    SUBGRF_SetStandby( STDBY_RC );
 803a614:	f7ff fd88 	bl	803a128 <SUBGRF_SetStandby>
    if (1U == RBI_IsTCXO() )
 803a618:	f7f2 fdb4 	bl	802d184 <RBI_IsTCXO>
 803a61c:	2801      	cmp	r0, #1
 803a61e:	d110      	bne.n	803a642 <SUBGRF_Init+0x46>
        SUBGRF_SetTcxoMode( TCXO_CTRL_VOLTAGE, RF_WAKEUP_TIME << 6 );// 100 ms
 803a620:	2140      	movs	r1, #64	; 0x40
 803a622:	f7ff fe7a 	bl	803a31a <SUBGRF_SetTcxoMode>
        SUBGRF_WriteRegister( REG_XTA_TRIM, 0x00 );
 803a626:	f640 1011 	movw	r0, #2321	; 0x911
 803a62a:	4629      	mov	r1, r5
 803a62c:	f7ff fefc 	bl	803a428 <SUBGRF_WriteRegister>
        SUBGRF_Calibrate( calibParam );
 803a630:	f04f 007f 	mov.w	r0, #127	; 0x7f
 803a634:	f7ff fe09 	bl	803a24a <SUBGRF_Calibrate>
    RBI_Init();
 803a638:	f7f2 fd9e 	bl	802d178 <RBI_Init>
    OperatingMode = MODE_STDBY_RC;
 803a63c:	2301      	movs	r3, #1
 803a63e:	7023      	strb	r3, [r4, #0]
}
 803a640:	bd38      	pop	{r3, r4, r5, pc}
        SUBGRF_WriteRegister( REG_XTA_TRIM, XTAL_DEFAULT_CAP_VALUE );
 803a642:	2120      	movs	r1, #32
 803a644:	f640 1011 	movw	r0, #2321	; 0x911
 803a648:	f7ff feee 	bl	803a428 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_XTB_TRIM, XTAL_DEFAULT_CAP_VALUE );
 803a64c:	2120      	movs	r1, #32
 803a64e:	f640 1012 	movw	r0, #2322	; 0x912
 803a652:	f7ff fee9 	bl	803a428 <SUBGRF_WriteRegister>
 803a656:	e7ef      	b.n	803a638 <SUBGRF_Init+0x3c>
 803a658:	20005a80 	.word	0x20005a80

0803a65c <SUBGRF_SetSleep>:
{
 803a65c:	b513      	push	{r0, r1, r4, lr}
 803a65e:	4604      	mov	r4, r0
    RBI_ConfigRFSwitch(RBI_SWITCH_OFF);
 803a660:	2000      	movs	r0, #0
 803a662:	f7f2 fd8b 	bl	802d17c <RBI_ConfigRFSwitch>
    Radio_SMPS_Set(SMPS_DRIVE_SETTING_DEFAULT);
 803a666:	2002      	movs	r0, #2
 803a668:	f7ff ffb4 	bl	803a5d4 <Radio_SMPS_Set>
                      ( ( uint8_t )sleepConfig.Fields.Reset << 1 ) |
 803a66c:	f004 0407 	and.w	r4, r4, #7
    SUBGRF_WriteCommand( RADIO_SET_SLEEP, &value, 1 );
 803a670:	2201      	movs	r2, #1
 803a672:	f10d 0107 	add.w	r1, sp, #7
 803a676:	2084      	movs	r0, #132	; 0x84
    uint8_t value = ( ( ( uint8_t )sleepConfig.Fields.WarmStart << 2 ) |
 803a678:	f88d 4007 	strb.w	r4, [sp, #7]
    SUBGRF_WriteCommand( RADIO_SET_SLEEP, &value, 1 );
 803a67c:	f7ff fd2e 	bl	803a0dc <SUBGRF_WriteCommand>
    OperatingMode = MODE_SLEEP;
 803a680:	4b02      	ldr	r3, [pc, #8]	; (803a68c <SUBGRF_SetSleep+0x30>)
 803a682:	2200      	movs	r2, #0
 803a684:	701a      	strb	r2, [r3, #0]
}
 803a686:	b002      	add	sp, #8
 803a688:	bd10      	pop	{r4, pc}
 803a68a:	bf00      	nop
 803a68c:	20005a80 	.word	0x20005a80

0803a690 <SUBGRF_SetWhiteningSeed>:
{
 803a690:	b510      	push	{r4, lr}
    return PacketType;
 803a692:	4b0c      	ldr	r3, [pc, #48]	; (803a6c4 <SUBGRF_SetWhiteningSeed+0x34>)
    switch( SUBGRF_GetPacketType( ) )
 803a694:	789b      	ldrb	r3, [r3, #2]
{
 803a696:	4604      	mov	r4, r0
    switch( SUBGRF_GetPacketType( ) )
 803a698:	b99b      	cbnz	r3, 803a6c2 <SUBGRF_SetWhiteningSeed+0x32>
            regValue = SUBGRF_ReadRegister( REG_LR_WHITSEEDBASEADDR_MSB ) & 0xFE;
 803a69a:	f44f 60d7 	mov.w	r0, #1720	; 0x6b8
 803a69e:	f7ff ff89 	bl	803a5b4 <SUBGRF_ReadRegister>
            regValue = ( ( seed >> 8 ) & 0x01 ) | regValue;
 803a6a2:	f3c4 2100 	ubfx	r1, r4, #8, #1
 803a6a6:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
            SUBGRF_WriteRegister( REG_LR_WHITSEEDBASEADDR_MSB, regValue ); // only 1 bit.
 803a6aa:	4301      	orrs	r1, r0
 803a6ac:	f44f 60d7 	mov.w	r0, #1720	; 0x6b8
 803a6b0:	f7ff feba 	bl	803a428 <SUBGRF_WriteRegister>
            SUBGRF_WriteRegister( REG_LR_WHITSEEDBASEADDR_LSB, (uint8_t)seed );
 803a6b4:	b2e1      	uxtb	r1, r4
 803a6b6:	f240 60b9 	movw	r0, #1721	; 0x6b9
}
 803a6ba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            SUBGRF_WriteRegister( REG_LR_WHITSEEDBASEADDR_LSB, (uint8_t)seed );
 803a6be:	f7ff beb3 	b.w	803a428 <SUBGRF_WriteRegister>
}
 803a6c2:	bd10      	pop	{r4, pc}
 803a6c4:	20005a80 	.word	0x20005a80

0803a6c8 <SUBGRF_SetTxParams>:
    if( paSelect == RFO_LP )
 803a6c8:	2801      	cmp	r0, #1
{
 803a6ca:	b537      	push	{r0, r1, r2, r4, r5, lr}
 803a6cc:	4603      	mov	r3, r0
 803a6ce:	460c      	mov	r4, r1
 803a6d0:	4615      	mov	r5, r2
    if( paSelect == RFO_LP )
 803a6d2:	d120      	bne.n	803a716 <SUBGRF_SetTxParams+0x4e>
        if( power == 15 )
 803a6d4:	2c0f      	cmp	r4, #15
            SUBGRF_SetPaConfig( 0x06, 0x00, 0x01, 0x01 );
 803a6d6:	4602      	mov	r2, r0
 803a6d8:	f04f 0100 	mov.w	r1, #0
 803a6dc:	bf0c      	ite	eq
 803a6de:	2006      	moveq	r0, #6
            SUBGRF_SetPaConfig( 0x04, 0x00, 0x01, 0x01 );
 803a6e0:	2004      	movne	r0, #4
 803a6e2:	f7ff fdf3 	bl	803a2cc <SUBGRF_SetPaConfig>
        if( power >= 14 )
 803a6e6:	f06f 0110 	mvn.w	r1, #16
 803a6ea:	428c      	cmp	r4, r1
 803a6ec:	bfb8      	it	lt
 803a6ee:	460c      	movlt	r4, r1
 803a6f0:	2c0e      	cmp	r4, #14
 803a6f2:	bfa8      	it	ge
 803a6f4:	240e      	movge	r4, #14
        SUBGRF_WriteRegister( REG_OCP, 0x18 ); // current max is 80 mA for the whole device
 803a6f6:	2118      	movs	r1, #24
        SUBGRF_WriteRegister( REG_OCP, 0x38 ); // current max 160mA for the whole device
 803a6f8:	f640 00e7 	movw	r0, #2279	; 0x8e7
 803a6fc:	f7ff fe94 	bl	803a428 <SUBGRF_WriteRegister>
    SUBGRF_WriteCommand( RADIO_SET_TXPARAMS, buf, 2 );
 803a700:	2202      	movs	r2, #2
 803a702:	a901      	add	r1, sp, #4
 803a704:	208e      	movs	r0, #142	; 0x8e
    buf[0] = power;
 803a706:	f88d 4004 	strb.w	r4, [sp, #4]
    buf[1] = ( uint8_t )rampTime;
 803a70a:	f88d 5005 	strb.w	r5, [sp, #5]
    SUBGRF_WriteCommand( RADIO_SET_TXPARAMS, buf, 2 );
 803a70e:	f7ff fce5 	bl	803a0dc <SUBGRF_WriteCommand>
}
 803a712:	b003      	add	sp, #12
 803a714:	bd30      	pop	{r4, r5, pc}
        SUBGRF_WriteRegister( REG_TX_CLAMP, SUBGRF_ReadRegister( REG_TX_CLAMP ) | ( 0x0F << 1 ) );
 803a716:	f640 00d8 	movw	r0, #2264	; 0x8d8
 803a71a:	f7ff ff4b 	bl	803a5b4 <SUBGRF_ReadRegister>
 803a71e:	f040 011e 	orr.w	r1, r0, #30
 803a722:	b2c9      	uxtb	r1, r1
 803a724:	f640 00d8 	movw	r0, #2264	; 0x8d8
 803a728:	f7ff fe7e 	bl	803a428 <SUBGRF_WriteRegister>
        SUBGRF_SetPaConfig( 0x04, 0x07, 0x00, 0x01 );
 803a72c:	2107      	movs	r1, #7
 803a72e:	2301      	movs	r3, #1
 803a730:	2200      	movs	r2, #0
 803a732:	2004      	movs	r0, #4
 803a734:	f7ff fdca 	bl	803a2cc <SUBGRF_SetPaConfig>
        if( power > 22 )
 803a738:	f06f 0108 	mvn.w	r1, #8
 803a73c:	428c      	cmp	r4, r1
 803a73e:	bfb8      	it	lt
 803a740:	460c      	movlt	r4, r1
 803a742:	2c16      	cmp	r4, #22
 803a744:	bfa8      	it	ge
 803a746:	2416      	movge	r4, #22
        SUBGRF_WriteRegister( REG_OCP, 0x38 ); // current max 160mA for the whole device
 803a748:	2138      	movs	r1, #56	; 0x38
 803a74a:	e7d5      	b.n	803a6f8 <SUBGRF_SetTxParams+0x30>

0803a74c <SUBGRF_GetRxBufferStatus>:
{
 803a74c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    SUBGRF_ReadCommand( RADIO_GET_RXBUFFERSTATUS, status, 2 );
 803a74e:	2202      	movs	r2, #2
{
 803a750:	4604      	mov	r4, r0
 803a752:	460d      	mov	r5, r1
    SUBGRF_ReadCommand( RADIO_GET_RXBUFFERSTATUS, status, 2 );
 803a754:	2013      	movs	r0, #19
 803a756:	a901      	add	r1, sp, #4
 803a758:	f7ff fcd0 	bl	803a0fc <SUBGRF_ReadCommand>
    return PacketType;
 803a75c:	4b0a      	ldr	r3, [pc, #40]	; (803a788 <SUBGRF_GetRxBufferStatus+0x3c>)
    if( ( SUBGRF_GetPacketType( ) == PACKET_TYPE_LORA ) && ( LoRaHeaderType == LORA_PACKET_FIXED_LENGTH ) )
 803a75e:	789a      	ldrb	r2, [r3, #2]
 803a760:	2a01      	cmp	r2, #1
 803a762:	d10c      	bne.n	803a77e <SUBGRF_GetRxBufferStatus+0x32>
 803a764:	7b1b      	ldrb	r3, [r3, #12]
 803a766:	2b01      	cmp	r3, #1
 803a768:	d109      	bne.n	803a77e <SUBGRF_GetRxBufferStatus+0x32>
        *payloadLength = SUBGRF_ReadRegister( REG_LR_PAYLOADLENGTH );
 803a76a:	f240 7002 	movw	r0, #1794	; 0x702
 803a76e:	f7ff ff21 	bl	803a5b4 <SUBGRF_ReadRegister>
 803a772:	7020      	strb	r0, [r4, #0]
    *rxStartBufferPointer = status[1];
 803a774:	f89d 3005 	ldrb.w	r3, [sp, #5]
 803a778:	702b      	strb	r3, [r5, #0]
}
 803a77a:	b003      	add	sp, #12
 803a77c:	bd30      	pop	{r4, r5, pc}
        *payloadLength = status[0];
 803a77e:	f89d 3004 	ldrb.w	r3, [sp, #4]
 803a782:	7023      	strb	r3, [r4, #0]
 803a784:	e7f6      	b.n	803a774 <SUBGRF_GetRxBufferStatus+0x28>
 803a786:	bf00      	nop
 803a788:	20005a80 	.word	0x20005a80

0803a78c <SUBGRF_WriteRegisters>:
{
 803a78c:	b510      	push	{r4, lr}
 803a78e:	4613      	mov	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803a790:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803a794:	b672      	cpsid	i
    HAL_SUBGHZ_WriteRegisters( &hsubghz, address, buffer, size );
 803a796:	460a      	mov	r2, r1
 803a798:	4601      	mov	r1, r0
 803a79a:	4803      	ldr	r0, [pc, #12]	; (803a7a8 <SUBGRF_WriteRegisters+0x1c>)
 803a79c:	f7f5 f948 	bl	802fa30 <HAL_SUBGHZ_WriteRegisters>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803a7a0:	f384 8810 	msr	PRIMASK, r4
}
 803a7a4:	bd10      	pop	{r4, pc}
 803a7a6:	bf00      	nop
 803a7a8:	200061f0 	.word	0x200061f0

0803a7ac <SUBGRF_SetSyncWord>:
{
 803a7ac:	b508      	push	{r3, lr}
 803a7ae:	4601      	mov	r1, r0
    SUBGRF_WriteRegisters( REG_LR_SYNCWORDBASEADDRESS, syncWord, 8 );
 803a7b0:	2208      	movs	r2, #8
 803a7b2:	f44f 60d8 	mov.w	r0, #1728	; 0x6c0
 803a7b6:	f7ff ffe9 	bl	803a78c <SUBGRF_WriteRegisters>
}
 803a7ba:	2000      	movs	r0, #0
 803a7bc:	bd08      	pop	{r3, pc}
	...

0803a7c0 <SUBGRF_SetCrcSeed>:
{
 803a7c0:	b507      	push	{r0, r1, r2, lr}
    return PacketType;
 803a7c2:	4b07      	ldr	r3, [pc, #28]	; (803a7e0 <SUBGRF_SetCrcSeed+0x20>)
    switch( SUBGRF_GetPacketType( ) )
 803a7c4:	789b      	ldrb	r3, [r3, #2]
    buf[0] = ( uint8_t )( ( seed >> 8 ) & 0xFF );
 803a7c6:	ba40      	rev16	r0, r0
 803a7c8:	f8ad 0004 	strh.w	r0, [sp, #4]
    switch( SUBGRF_GetPacketType( ) )
 803a7cc:	b92b      	cbnz	r3, 803a7da <SUBGRF_SetCrcSeed+0x1a>
            SUBGRF_WriteRegisters( REG_LR_CRCSEEDBASEADDR, buf, 2 );
 803a7ce:	2202      	movs	r2, #2
 803a7d0:	a901      	add	r1, sp, #4
 803a7d2:	f240 60bc 	movw	r0, #1724	; 0x6bc
 803a7d6:	f7ff ffd9 	bl	803a78c <SUBGRF_WriteRegisters>
}
 803a7da:	b003      	add	sp, #12
 803a7dc:	f85d fb04 	ldr.w	pc, [sp], #4
 803a7e0:	20005a80 	.word	0x20005a80

0803a7e4 <SUBGRF_SetCrcPolynomial>:
{
 803a7e4:	b507      	push	{r0, r1, r2, lr}
    return PacketType;
 803a7e6:	4b07      	ldr	r3, [pc, #28]	; (803a804 <SUBGRF_SetCrcPolynomial+0x20>)
    switch( SUBGRF_GetPacketType( ) )
 803a7e8:	789b      	ldrb	r3, [r3, #2]
    buf[0] = ( uint8_t )( ( polynomial >> 8 ) & 0xFF );
 803a7ea:	ba40      	rev16	r0, r0
 803a7ec:	f8ad 0004 	strh.w	r0, [sp, #4]
    switch( SUBGRF_GetPacketType( ) )
 803a7f0:	b92b      	cbnz	r3, 803a7fe <SUBGRF_SetCrcPolynomial+0x1a>
            SUBGRF_WriteRegisters( REG_LR_CRCPOLYBASEADDR, buf, 2 );
 803a7f2:	2202      	movs	r2, #2
 803a7f4:	a901      	add	r1, sp, #4
 803a7f6:	f240 60be 	movw	r0, #1726	; 0x6be
 803a7fa:	f7ff ffc7 	bl	803a78c <SUBGRF_WriteRegisters>
}
 803a7fe:	b003      	add	sp, #12
 803a800:	f85d fb04 	ldr.w	pc, [sp], #4
 803a804:	20005a80 	.word	0x20005a80

0803a808 <SUBGRF_SetPacketParams>:
{
 803a808:	b530      	push	{r4, r5, lr}
    uint8_t buf[9] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 803a80a:	4a2e      	ldr	r2, [pc, #184]	; (803a8c4 <SUBGRF_SetPacketParams+0xbc>)
    if( PacketType != packetParams->PacketType )
 803a80c:	4d2e      	ldr	r5, [pc, #184]	; (803a8c8 <SUBGRF_SetPacketParams+0xc0>)
    uint8_t buf[9] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 803a80e:	6851      	ldr	r1, [r2, #4]
{
 803a810:	4604      	mov	r4, r0
 803a812:	b085      	sub	sp, #20
    uint8_t buf[9] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 803a814:	6810      	ldr	r0, [r2, #0]
 803a816:	7a12      	ldrb	r2, [r2, #8]
 803a818:	ab01      	add	r3, sp, #4
 803a81a:	c303      	stmia	r3!, {r0, r1}
    if( PacketType != packetParams->PacketType )
 803a81c:	7820      	ldrb	r0, [r4, #0]
    uint8_t buf[9] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 803a81e:	701a      	strb	r2, [r3, #0]
    if( PacketType != packetParams->PacketType )
 803a820:	78aa      	ldrb	r2, [r5, #2]
 803a822:	4282      	cmp	r2, r0
 803a824:	d001      	beq.n	803a82a <SUBGRF_SetPacketParams+0x22>
        SUBGRF_SetPacketType( packetParams->PacketType );
 803a826:	f7ff fe43 	bl	803a4b0 <SUBGRF_SetPacketType>
    switch( packetParams->PacketType )
 803a82a:	7823      	ldrb	r3, [r4, #0]
 803a82c:	2b03      	cmp	r3, #3
 803a82e:	d826      	bhi.n	803a87e <SUBGRF_SetPacketParams+0x76>
 803a830:	e8df f003 	tbb	[pc, r3]
 803a834:	02333802 	.word	0x02333802
        if( packetParams->Params.Gfsk.CrcLength == RADIO_CRC_2_BYTES_IBM )
 803a838:	7a63      	ldrb	r3, [r4, #9]
 803a83a:	2bf1      	cmp	r3, #241	; 0xf1
 803a83c:	d121      	bne.n	803a882 <SUBGRF_SetPacketParams+0x7a>
            SUBGRF_SetCrcSeed( CRC_IBM_SEED );
 803a83e:	f64f 70ff 	movw	r0, #65535	; 0xffff
 803a842:	f7ff ffbd 	bl	803a7c0 <SUBGRF_SetCrcSeed>
            SUBGRF_SetCrcPolynomial( CRC_POLYNOMIAL_IBM );
 803a846:	f248 0005 	movw	r0, #32773	; 0x8005
 803a84a:	f7ff ffcb 	bl	803a7e4 <SUBGRF_SetCrcPolynomial>
            crcVal = RADIO_CRC_2_BYTES;
 803a84e:	2302      	movs	r3, #2
        buf[0] = ( packetParams->Params.Gfsk.PreambleLength >> 8 ) & 0xFF;
 803a850:	8862      	ldrh	r2, [r4, #2]
        buf[2] = packetParams->Params.Gfsk.PreambleMinDetect;
 803a852:	88a1      	ldrh	r1, [r4, #4]
 803a854:	f8ad 1006 	strh.w	r1, [sp, #6]
        buf[0] = ( packetParams->Params.Gfsk.PreambleLength >> 8 ) & 0xFF;
 803a858:	ba52      	rev16	r2, r2
        buf[4] = packetParams->Params.Gfsk.AddrComp;
 803a85a:	88e1      	ldrh	r1, [r4, #6]
        buf[0] = ( packetParams->Params.Gfsk.PreambleLength >> 8 ) & 0xFF;
 803a85c:	f8ad 2004 	strh.w	r2, [sp, #4]
        buf[7] = crcVal;
 803a860:	f88d 300b 	strb.w	r3, [sp, #11]
        buf[6] = packetParams->Params.Gfsk.PayloadLength;
 803a864:	7a22      	ldrb	r2, [r4, #8]
        buf[8] = packetParams->Params.Gfsk.DcFree;
 803a866:	7aa3      	ldrb	r3, [r4, #10]
        buf[6] = packetParams->Params.Gfsk.PayloadLength;
 803a868:	f88d 200a 	strb.w	r2, [sp, #10]
        buf[4] = packetParams->Params.Gfsk.AddrComp;
 803a86c:	f8ad 1008 	strh.w	r1, [sp, #8]
        buf[8] = packetParams->Params.Gfsk.DcFree;
 803a870:	f88d 300c 	strb.w	r3, [sp, #12]
        n = 9;
 803a874:	2209      	movs	r2, #9
    SUBGRF_WriteCommand( RADIO_SET_PACKETPARAMS, buf, n );
 803a876:	a901      	add	r1, sp, #4
 803a878:	208c      	movs	r0, #140	; 0x8c
 803a87a:	f7ff fc2f 	bl	803a0dc <SUBGRF_WriteCommand>
}
 803a87e:	b005      	add	sp, #20
 803a880:	bd30      	pop	{r4, r5, pc}
        else if( packetParams->Params.Gfsk.CrcLength == RADIO_CRC_2_BYTES_CCIT )
 803a882:	2bf2      	cmp	r3, #242	; 0xf2
 803a884:	d1e4      	bne.n	803a850 <SUBGRF_SetPacketParams+0x48>
            SUBGRF_SetCrcSeed( CRC_CCITT_SEED );
 803a886:	f641 500f 	movw	r0, #7439	; 0x1d0f
 803a88a:	f7ff ff99 	bl	803a7c0 <SUBGRF_SetCrcSeed>
            SUBGRF_SetCrcPolynomial( CRC_POLYNOMIAL_CCITT );
 803a88e:	f241 0021 	movw	r0, #4129	; 0x1021
 803a892:	f7ff ffa7 	bl	803a7e4 <SUBGRF_SetCrcPolynomial>
            crcVal = RADIO_CRC_2_BYTES_INV;
 803a896:	2306      	movs	r3, #6
 803a898:	e7da      	b.n	803a850 <SUBGRF_SetPacketParams+0x48>
        buf[0] = packetParams->Params.Bpsk.PayloadLength;
 803a89a:	7b23      	ldrb	r3, [r4, #12]
 803a89c:	f88d 3004 	strb.w	r3, [sp, #4]
        n = 1;
 803a8a0:	2201      	movs	r2, #1
        break;
 803a8a2:	e7e8      	b.n	803a876 <SUBGRF_SetPacketParams+0x6e>
        buf[0] = ( packetParams->Params.LoRa.PreambleLength >> 8 ) & 0xFF;
 803a8a4:	89e3      	ldrh	r3, [r4, #14]
 803a8a6:	ba5b      	rev16	r3, r3
 803a8a8:	f8ad 3004 	strh.w	r3, [sp, #4]
        buf[2] = LoRaHeaderType = packetParams->Params.LoRa.HeaderType;
 803a8ac:	7c23      	ldrb	r3, [r4, #16]
 803a8ae:	732b      	strb	r3, [r5, #12]
 803a8b0:	f88d 3006 	strb.w	r3, [sp, #6]
        buf[3] = packetParams->Params.LoRa.PayloadLength;
 803a8b4:	7c63      	ldrb	r3, [r4, #17]
 803a8b6:	f88d 3007 	strb.w	r3, [sp, #7]
        buf[4] = packetParams->Params.LoRa.CrcMode;
 803a8ba:	8a63      	ldrh	r3, [r4, #18]
 803a8bc:	f8ad 3008 	strh.w	r3, [sp, #8]
        n = 6;
 803a8c0:	2206      	movs	r2, #6
        break;
 803a8c2:	e7d8      	b.n	803a876 <SUBGRF_SetPacketParams+0x6e>
 803a8c4:	0803bcbc 	.word	0x0803bcbc
 803a8c8:	20005a80 	.word	0x20005a80

0803a8cc <SUBGRF_ReadRegisters>:
{
 803a8cc:	b510      	push	{r4, lr}
 803a8ce:	4613      	mov	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803a8d0:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803a8d4:	b672      	cpsid	i
    HAL_SUBGHZ_ReadRegisters( &hsubghz, address, buffer, size );
 803a8d6:	460a      	mov	r2, r1
 803a8d8:	4601      	mov	r1, r0
 803a8da:	4803      	ldr	r0, [pc, #12]	; (803a8e8 <SUBGRF_ReadRegisters+0x1c>)
 803a8dc:	f7f5 f8e1 	bl	802faa2 <HAL_SUBGHZ_ReadRegisters>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803a8e0:	f384 8810 	msr	PRIMASK, r4
}
 803a8e4:	bd10      	pop	{r4, pc}
 803a8e6:	bf00      	nop
 803a8e8:	200061f0 	.word	0x200061f0

0803a8ec <SUBGRF_GetRandom>:
{
 803a8ec:	b573      	push	{r0, r1, r4, r5, r6, lr}
    uint32_t number = 0;
 803a8ee:	2600      	movs	r6, #0
    regAnaLna = SUBGRF_ReadRegister( REG_ANA_LNA );
 803a8f0:	f640 00e2 	movw	r0, #2274	; 0x8e2
    uint32_t number = 0;
 803a8f4:	9601      	str	r6, [sp, #4]
    regAnaLna = SUBGRF_ReadRegister( REG_ANA_LNA );
 803a8f6:	f7ff fe5d 	bl	803a5b4 <SUBGRF_ReadRegister>
    SUBGRF_WriteRegister( REG_ANA_LNA, regAnaLna & ~( 1 << 0 ) );
 803a8fa:	f000 01fe 	and.w	r1, r0, #254	; 0xfe
    regAnaLna = SUBGRF_ReadRegister( REG_ANA_LNA );
 803a8fe:	4605      	mov	r5, r0
    SUBGRF_WriteRegister( REG_ANA_LNA, regAnaLna & ~( 1 << 0 ) );
 803a900:	f640 00e2 	movw	r0, #2274	; 0x8e2
 803a904:	f7ff fd90 	bl	803a428 <SUBGRF_WriteRegister>
    regAnaMixer = SUBGRF_ReadRegister( REG_ANA_MIXER );
 803a908:	f640 00e5 	movw	r0, #2277	; 0x8e5
 803a90c:	f7ff fe52 	bl	803a5b4 <SUBGRF_ReadRegister>
    SUBGRF_WriteRegister( REG_ANA_MIXER, regAnaMixer & ~( 1 << 7 ) );
 803a910:	f000 017f 	and.w	r1, r0, #127	; 0x7f
    regAnaMixer = SUBGRF_ReadRegister( REG_ANA_MIXER );
 803a914:	4604      	mov	r4, r0
    SUBGRF_WriteRegister( REG_ANA_MIXER, regAnaMixer & ~( 1 << 7 ) );
 803a916:	f640 00e5 	movw	r0, #2277	; 0x8e5
 803a91a:	f7ff fd85 	bl	803a428 <SUBGRF_WriteRegister>
    SUBGRF_SetRx( 0xFFFFFF ); // Rx Continuous
 803a91e:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 803a922:	f7ff fc2d 	bl	803a180 <SUBGRF_SetRx>
    SUBGRF_ReadRegisters( RANDOM_NUMBER_GENERATORBASEADDR, ( uint8_t* )&number, 4 );
 803a926:	2204      	movs	r2, #4
 803a928:	eb0d 0102 	add.w	r1, sp, r2
 803a92c:	f640 0019 	movw	r0, #2073	; 0x819
 803a930:	f7ff ffcc 	bl	803a8cc <SUBGRF_ReadRegisters>
    SUBGRF_SetStandby( STDBY_RC );
 803a934:	4630      	mov	r0, r6
 803a936:	f7ff fbf7 	bl	803a128 <SUBGRF_SetStandby>
    SUBGRF_WriteRegister( REG_ANA_LNA, regAnaLna );
 803a93a:	4629      	mov	r1, r5
 803a93c:	f640 00e2 	movw	r0, #2274	; 0x8e2
 803a940:	f7ff fd72 	bl	803a428 <SUBGRF_WriteRegister>
    SUBGRF_WriteRegister( REG_ANA_MIXER, regAnaMixer );
 803a944:	4621      	mov	r1, r4
 803a946:	f640 00e5 	movw	r0, #2277	; 0x8e5
 803a94a:	f7ff fd6d 	bl	803a428 <SUBGRF_WriteRegister>
}
 803a94e:	9801      	ldr	r0, [sp, #4]
 803a950:	b002      	add	sp, #8
 803a952:	bd70      	pop	{r4, r5, r6, pc}

0803a954 <SUBGRF_WriteBuffer>:
{
 803a954:	b510      	push	{r4, lr}
 803a956:	4613      	mov	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803a958:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803a95c:	b672      	cpsid	i
    HAL_SUBGHZ_WriteBuffer( &hsubghz, offset, buffer, size );
 803a95e:	460a      	mov	r2, r1
 803a960:	4601      	mov	r1, r0
 803a962:	4803      	ldr	r0, [pc, #12]	; (803a970 <SUBGRF_WriteBuffer+0x1c>)
 803a964:	f7f5 f910 	bl	802fb88 <HAL_SUBGHZ_WriteBuffer>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803a968:	f384 8810 	msr	PRIMASK, r4
}
 803a96c:	bd10      	pop	{r4, pc}
 803a96e:	bf00      	nop
 803a970:	200061f0 	.word	0x200061f0

0803a974 <SUBGRF_SetPayload>:
{
 803a974:	460a      	mov	r2, r1
    SUBGRF_WriteBuffer( 0x00, payload, size );
 803a976:	4601      	mov	r1, r0
 803a978:	2000      	movs	r0, #0
 803a97a:	f7ff bfeb 	b.w	803a954 <SUBGRF_WriteBuffer>

0803a97e <SUBGRF_SendPayload>:
{
 803a97e:	b510      	push	{r4, lr}
 803a980:	4614      	mov	r4, r2
    SUBGRF_SetPayload( payload, size );
 803a982:	f7ff fff7 	bl	803a974 <SUBGRF_SetPayload>
    SUBGRF_SetTx( timeout );
 803a986:	4620      	mov	r0, r4
}
 803a988:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    SUBGRF_SetTx( timeout );
 803a98c:	f7ff bbe2 	b.w	803a154 <SUBGRF_SetTx>

0803a990 <SUBGRF_ReadBuffer>:
{
 803a990:	b510      	push	{r4, lr}
 803a992:	4613      	mov	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803a994:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803a998:	b672      	cpsid	i
    HAL_SUBGHZ_ReadBuffer( &hsubghz, offset, buffer, size );
 803a99a:	460a      	mov	r2, r1
 803a99c:	4601      	mov	r1, r0
 803a99e:	4803      	ldr	r0, [pc, #12]	; (803a9ac <SUBGRF_ReadBuffer+0x1c>)
 803a9a0:	f7f5 f925 	bl	802fbee <HAL_SUBGHZ_ReadBuffer>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803a9a4:	f384 8810 	msr	PRIMASK, r4
}
 803a9a8:	bd10      	pop	{r4, pc}
 803a9aa:	bf00      	nop
 803a9ac:	200061f0 	.word	0x200061f0

0803a9b0 <SUBGRF_GetPayload>:
{
 803a9b0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 803a9b2:	460d      	mov	r5, r1
 803a9b4:	4606      	mov	r6, r0
    uint8_t offset = 0;
 803a9b6:	2400      	movs	r4, #0
    SUBGRF_GetRxBufferStatus( size, &offset );
 803a9b8:	f10d 0107 	add.w	r1, sp, #7
 803a9bc:	4628      	mov	r0, r5
{
 803a9be:	4617      	mov	r7, r2
    uint8_t offset = 0;
 803a9c0:	f88d 4007 	strb.w	r4, [sp, #7]
    SUBGRF_GetRxBufferStatus( size, &offset );
 803a9c4:	f7ff fec2 	bl	803a74c <SUBGRF_GetRxBufferStatus>
    if( *size > maxSize )
 803a9c8:	782a      	ldrb	r2, [r5, #0]
 803a9ca:	42ba      	cmp	r2, r7
 803a9cc:	d807      	bhi.n	803a9de <SUBGRF_GetPayload+0x2e>
    SUBGRF_ReadBuffer( offset, buffer, *size );
 803a9ce:	f89d 0007 	ldrb.w	r0, [sp, #7]
 803a9d2:	4631      	mov	r1, r6
 803a9d4:	f7ff ffdc 	bl	803a990 <SUBGRF_ReadBuffer>
    return 0;
 803a9d8:	4620      	mov	r0, r4
}
 803a9da:	b003      	add	sp, #12
 803a9dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return 1;
 803a9de:	2001      	movs	r0, #1
 803a9e0:	e7fb      	b.n	803a9da <SUBGRF_GetPayload+0x2a>

0803a9e2 <SUBGRF_SetSwitch>:
    if (rxtx == RFSWITCH_TX)
 803a9e2:	2901      	cmp	r1, #1
{
 803a9e4:	b508      	push	{r3, lr}
 803a9e6:	4603      	mov	r3, r0
 803a9e8:	4608      	mov	r0, r1
    if (rxtx == RFSWITCH_TX)
 803a9ea:	d10e      	bne.n	803aa0a <SUBGRF_SetSwitch+0x28>
        if (paSelect == RFO_LP)
 803a9ec:	2b01      	cmp	r3, #1
 803a9ee:	d107      	bne.n	803aa00 <SUBGRF_SetSwitch+0x1e>
            Radio_SMPS_Set(SMPS_DRIVE_SETTING_MAX);
 803a9f0:	2004      	movs	r0, #4
 803a9f2:	f7ff fdef 	bl	803a5d4 <Radio_SMPS_Set>
            state = RBI_SWITCH_RFO_LP;
 803a9f6:	2002      	movs	r0, #2
}
 803a9f8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RBI_ConfigRFSwitch(state);
 803a9fc:	f7f2 bbbe 	b.w	802d17c <RBI_ConfigRFSwitch>
        if (paSelect == RFO_HP)
 803aa00:	2b02      	cmp	r3, #2
            state = RBI_SWITCH_RFO_HP;
 803aa02:	bf14      	ite	ne
 803aa04:	4608      	movne	r0, r1
 803aa06:	2003      	moveq	r0, #3
 803aa08:	e7f6      	b.n	803a9f8 <SUBGRF_SetSwitch+0x16>
    RBI_Switch_TypeDef state = RBI_SWITCH_RX;
 803aa0a:	2001      	movs	r0, #1
 803aa0c:	e7f4      	b.n	803a9f8 <SUBGRF_SetSwitch+0x16>

0803aa0e <SUBGRF_SetRfTxPower>:
{
 803aa0e:	b538      	push	{r3, r4, r5, lr}
 803aa10:	4604      	mov	r4, r0
    int32_t TxConfig = RBI_GetTxConfig();
 803aa12:	f7f2 fbb5 	bl	802d180 <RBI_GetTxConfig>
    switch (TxConfig)
 803aa16:	b150      	cbz	r0, 803aa2e <SUBGRF_SetRfTxPower+0x20>
 803aa18:	2802      	cmp	r0, #2
 803aa1a:	bf14      	ite	ne
 803aa1c:	2501      	movne	r5, #1
 803aa1e:	2502      	moveq	r5, #2
    SUBGRF_SetTxParams( paSelect, power, RADIO_RAMP_40_US );
 803aa20:	4628      	mov	r0, r5
 803aa22:	2202      	movs	r2, #2
 803aa24:	4621      	mov	r1, r4
 803aa26:	f7ff fe4f 	bl	803a6c8 <SUBGRF_SetTxParams>
}
 803aa2a:	4628      	mov	r0, r5
 803aa2c:	bd38      	pop	{r3, r4, r5, pc}
            if (power > 15)
 803aa2e:	2c0f      	cmp	r4, #15
                paSelect = RFO_LP;
 803aa30:	bfcc      	ite	gt
 803aa32:	2502      	movgt	r5, #2
 803aa34:	2501      	movle	r5, #1
 803aa36:	e7f3      	b.n	803aa20 <SUBGRF_SetRfTxPower+0x12>

0803aa38 <SUBGRF_GetRadioWakeUpTime>:
}
 803aa38:	2001      	movs	r0, #1
 803aa3a:	4770      	bx	lr

0803aa3c <HAL_SUBGHZ_TxCpltCallback>:
    RadioOnDioIrqCb( IRQ_TX_DONE );
 803aa3c:	4b01      	ldr	r3, [pc, #4]	; (803aa44 <HAL_SUBGHZ_TxCpltCallback+0x8>)
 803aa3e:	2001      	movs	r0, #1
 803aa40:	689b      	ldr	r3, [r3, #8]
 803aa42:	4718      	bx	r3
 803aa44:	20005a80 	.word	0x20005a80

0803aa48 <HAL_SUBGHZ_RxCpltCallback>:
    RadioOnDioIrqCb( IRQ_RX_DONE );
 803aa48:	4b01      	ldr	r3, [pc, #4]	; (803aa50 <HAL_SUBGHZ_RxCpltCallback+0x8>)
 803aa4a:	2002      	movs	r0, #2
 803aa4c:	689b      	ldr	r3, [r3, #8]
 803aa4e:	4718      	bx	r3
 803aa50:	20005a80 	.word	0x20005a80

0803aa54 <HAL_SUBGHZ_CRCErrorCallback>:
    RadioOnDioIrqCb( IRQ_CRC_ERROR);
 803aa54:	4b01      	ldr	r3, [pc, #4]	; (803aa5c <HAL_SUBGHZ_CRCErrorCallback+0x8>)
 803aa56:	2040      	movs	r0, #64	; 0x40
 803aa58:	689b      	ldr	r3, [r3, #8]
 803aa5a:	4718      	bx	r3
 803aa5c:	20005a80 	.word	0x20005a80

0803aa60 <HAL_SUBGHZ_CADStatusCallback>:
    switch (cadstatus)
 803aa60:	b111      	cbz	r1, 803aa68 <HAL_SUBGHZ_CADStatusCallback+0x8>
 803aa62:	2901      	cmp	r1, #1
 803aa64:	d004      	beq.n	803aa70 <HAL_SUBGHZ_CADStatusCallback+0x10>
 803aa66:	4770      	bx	lr
            RadioOnDioIrqCb( IRQ_CAD_CLEAR);
 803aa68:	4b04      	ldr	r3, [pc, #16]	; (803aa7c <HAL_SUBGHZ_CADStatusCallback+0x1c>)
 803aa6a:	689b      	ldr	r3, [r3, #8]
 803aa6c:	2080      	movs	r0, #128	; 0x80
            RadioOnDioIrqCb( IRQ_CAD_DETECTED);
 803aa6e:	4718      	bx	r3
 803aa70:	4b02      	ldr	r3, [pc, #8]	; (803aa7c <HAL_SUBGHZ_CADStatusCallback+0x1c>)
 803aa72:	f44f 7080 	mov.w	r0, #256	; 0x100
 803aa76:	689b      	ldr	r3, [r3, #8]
 803aa78:	e7f9      	b.n	803aa6e <HAL_SUBGHZ_CADStatusCallback+0xe>
 803aa7a:	bf00      	nop
 803aa7c:	20005a80 	.word	0x20005a80

0803aa80 <HAL_SUBGHZ_RxTxTimeoutCallback>:
    RadioOnDioIrqCb( IRQ_RX_TX_TIMEOUT );
 803aa80:	4b02      	ldr	r3, [pc, #8]	; (803aa8c <HAL_SUBGHZ_RxTxTimeoutCallback+0xc>)
 803aa82:	f44f 7000 	mov.w	r0, #512	; 0x200
 803aa86:	689b      	ldr	r3, [r3, #8]
 803aa88:	4718      	bx	r3
 803aa8a:	bf00      	nop
 803aa8c:	20005a80 	.word	0x20005a80

0803aa90 <HAL_SUBGHZ_HeaderErrorCallback>:
    RadioOnDioIrqCb( IRQ_HEADER_ERROR );
 803aa90:	4b01      	ldr	r3, [pc, #4]	; (803aa98 <HAL_SUBGHZ_HeaderErrorCallback+0x8>)
 803aa92:	2020      	movs	r0, #32
 803aa94:	689b      	ldr	r3, [r3, #8]
 803aa96:	4718      	bx	r3
 803aa98:	20005a80 	.word	0x20005a80

0803aa9c <HAL_SUBGHZ_PreambleDetectedCallback>:
    RadioOnDioIrqCb( IRQ_PREAMBLE_DETECTED );
 803aa9c:	4b01      	ldr	r3, [pc, #4]	; (803aaa4 <HAL_SUBGHZ_PreambleDetectedCallback+0x8>)
 803aa9e:	2004      	movs	r0, #4
 803aaa0:	689b      	ldr	r3, [r3, #8]
 803aaa2:	4718      	bx	r3
 803aaa4:	20005a80 	.word	0x20005a80

0803aaa8 <HAL_SUBGHZ_SyncWordValidCallback>:
    RadioOnDioIrqCb( IRQ_SYNCWORD_VALID );
 803aaa8:	4b01      	ldr	r3, [pc, #4]	; (803aab0 <HAL_SUBGHZ_SyncWordValidCallback+0x8>)
 803aaaa:	2008      	movs	r0, #8
 803aaac:	689b      	ldr	r3, [r3, #8]
 803aaae:	4718      	bx	r3
 803aab0:	20005a80 	.word	0x20005a80

0803aab4 <HAL_SUBGHZ_HeaderValidCallback>:
    RadioOnDioIrqCb( IRQ_HEADER_VALID );
 803aab4:	4b01      	ldr	r3, [pc, #4]	; (803aabc <HAL_SUBGHZ_HeaderValidCallback+0x8>)
 803aab6:	2010      	movs	r0, #16
 803aab8:	689b      	ldr	r3, [r3, #8]
 803aaba:	4718      	bx	r3
 803aabc:	20005a80 	.word	0x20005a80

0803aac0 <SUBGRF_GetFskBandwidthRegValue>:

uint8_t SUBGRF_GetFskBandwidthRegValue( uint32_t bandwidth )
{
 803aac0:	b510      	push	{r4, lr}
    uint8_t i;

    if( bandwidth == 0 )
 803aac2:	b178      	cbz	r0, 803aae4 <SUBGRF_GetFskBandwidthRegValue+0x24>
    }

    /* ST_WORKAROUND_BEGIN: Simplified loop */
    for( i = 0; i < ( sizeof( FskBandwidths ) / sizeof( FskBandwidth_t ) ); i++ )
    {
        if ( bandwidth < FskBandwidths[i].bandwidth )
 803aac4:	4a08      	ldr	r2, [pc, #32]	; (803aae8 <SUBGRF_GetFskBandwidthRegValue+0x28>)
 803aac6:	2300      	movs	r3, #0
 803aac8:	f102 0114 	add.w	r1, r2, #20
 803aacc:	f851 4033 	ldr.w	r4, [r1, r3, lsl #3]
 803aad0:	4284      	cmp	r4, r0
 803aad2:	d903      	bls.n	803aadc <SUBGRF_GetFskBandwidthRegValue+0x1c>
        {
            return FskBandwidths[i].RegValue;
 803aad4:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 803aad8:	7e18      	ldrb	r0, [r3, #24]
        }
    }
    /* ST_WORKAROUND_END */
    // ERROR: Value not found
    while( 1 );
}
 803aada:	bd10      	pop	{r4, pc}
    for( i = 0; i < ( sizeof( FskBandwidths ) / sizeof( FskBandwidth_t ) ); i++ )
 803aadc:	3301      	adds	r3, #1
 803aade:	2b16      	cmp	r3, #22
 803aae0:	d1f4      	bne.n	803aacc <SUBGRF_GetFskBandwidthRegValue+0xc>
    while( 1 );
 803aae2:	e7fe      	b.n	803aae2 <SUBGRF_GetFskBandwidthRegValue+0x22>
        return( 0x1F );
 803aae4:	201f      	movs	r0, #31
 803aae6:	e7f8      	b.n	803aada <SUBGRF_GetFskBandwidthRegValue+0x1a>
 803aae8:	0803bcb4 	.word	0x0803bcb4

0803aaec <SUBGRF_GetCFO>:
void SUBGRF_GetCFO( uint32_t bitRate, int32_t *cfo)
{
 803aaec:	b573      	push	{r0, r1, r4, r5, r6, lr}
  uint8_t BwMant[] = {4, 8, 10, 12};
 803aaee:	4b1d      	ldr	r3, [pc, #116]	; (803ab64 <SUBGRF_GetCFO+0x78>)
 803aaf0:	9301      	str	r3, [sp, #4]
{
 803aaf2:	4604      	mov	r4, r0
  /* read demod bandwidth: mant bit4:3, exp bits 2:0 */
  uint8_t reg = (SUBGRF_ReadRegister( SUBGHZ_BWSEL ));
 803aaf4:	f640 0007 	movw	r0, #2055	; 0x807
{
 803aaf8:	460d      	mov	r5, r1
  uint8_t reg = (SUBGRF_ReadRegister( SUBGHZ_BWSEL ));
 803aafa:	f7ff fd5b 	bl	803a5b4 <SUBGRF_ReadRegister>
  uint8_t bandwidth_mant = BwMant[( reg >> 3 ) & 0x3];
 803aafe:	aa02      	add	r2, sp, #8
 803ab00:	f3c0 03c1 	ubfx	r3, r0, #3, #2
 803ab04:	4413      	add	r3, r2
  uint8_t bandwidth_exp = reg & 0x7;
  uint32_t cf_fs = XTAL_FREQ / ( bandwidth_mant * ( 1 << ( bandwidth_exp - 1 )));
 803ab06:	f813 2c04 	ldrb.w	r2, [r3, #-4]
 803ab0a:	f000 0307 	and.w	r3, r0, #7
 803ab0e:	3b01      	subs	r3, #1
 803ab10:	fa02 f003 	lsl.w	r0, r2, r3
 803ab14:	4b14      	ldr	r3, [pc, #80]	; (803ab68 <SUBGRF_GetCFO+0x7c>)
 803ab16:	fbb3 f3f0 	udiv	r3, r3, r0
  uint32_t cf_osr = cf_fs / bitRate;
 803ab1a:	fbb3 f0f4 	udiv	r0, r3, r4
  uint8_t interp = 1;
  /* calculate demod interpolation factor */
  if (cf_osr * interp < 8)
 803ab1e:	2807      	cmp	r0, #7
 803ab20:	d81d      	bhi.n	803ab5e <SUBGRF_GetCFO+0x72>
  {
    interp = 2;
  }
  if (cf_osr * interp < 4)
 803ab22:	0040      	lsls	r0, r0, #1
  {
    interp = 4;
 803ab24:	2803      	cmp	r0, #3
 803ab26:	bf8c      	ite	hi
 803ab28:	2402      	movhi	r4, #2
 803ab2a:	2404      	movls	r4, #4
  }
  /* calculate demod sampling frequency */
  uint32_t fs = cf_fs* interp;
  /* get the cfo registers */
  int32_t cfo_bin = ( SUBGRF_ReadRegister( SUBGHZ_CFO_H ) & 0xF ) << 8;
 803ab2c:	f44f 60d6 	mov.w	r0, #1712	; 0x6b0
  uint32_t fs = cf_fs* interp;
 803ab30:	435c      	muls	r4, r3
  int32_t cfo_bin = ( SUBGRF_ReadRegister( SUBGHZ_CFO_H ) & 0xF ) << 8;
 803ab32:	f7ff fd3f 	bl	803a5b4 <SUBGRF_ReadRegister>
 803ab36:	0200      	lsls	r0, r0, #8
 803ab38:	f400 6670 	and.w	r6, r0, #3840	; 0xf00
  cfo_bin |= SUBGRF_ReadRegister( SUBGHZ_CFO_L );
 803ab3c:	f240 60b1 	movw	r0, #1713	; 0x6b1
 803ab40:	f7ff fd38 	bl	803a5b4 <SUBGRF_ReadRegister>
 803ab44:	4330      	orrs	r0, r6
  /* negate if 12 bits sign bit is 1 */
  if (( cfo_bin & 0x800 ) == 0x800 )
 803ab46:	0503      	lsls	r3, r0, #20
  {
    cfo_bin |= 0xFFFFF000;
 803ab48:	bf44      	itt	mi
 803ab4a:	ea6f 5000 	mvnmi.w	r0, r0, lsl #20
 803ab4e:	ea6f 5010 	mvnmi.w	r0, r0, lsr #20
  }
  /* calculate cfo in Hz */
  /* shift by 5 first to not saturate, cfo_bin on 12bits */
  *cfo = ((int32_t)( cfo_bin * ( fs >> 5 ))) >> ( 12 - 5 );
 803ab52:	0963      	lsrs	r3, r4, #5
 803ab54:	4358      	muls	r0, r3
 803ab56:	11c0      	asrs	r0, r0, #7
 803ab58:	6028      	str	r0, [r5, #0]
}
 803ab5a:	b002      	add	sp, #8
 803ab5c:	bd70      	pop	{r4, r5, r6, pc}
  uint8_t interp = 1;
 803ab5e:	2401      	movs	r4, #1
 803ab60:	e7e4      	b.n	803ab2c <SUBGRF_GetCFO+0x40>
 803ab62:	bf00      	nop
 803ab64:	0c0a0804 	.word	0x0c0a0804
 803ab68:	01e84800 	.word	0x01e84800

0803ab6c <RFW_TransmitLongPacket>:
  }
#else
  status= -1;
#endif
  return status;
}
 803ab6c:	f04f 30ff 	mov.w	r0, #4294967295
 803ab70:	4770      	bx	lr

0803ab72 <RFW_ReceiveLongPacket>:
  }
#else
  status= -1;
#endif
  return status;
}
 803ab72:	f04f 30ff 	mov.w	r0, #4294967295
 803ab76:	4770      	bx	lr

0803ab78 <RFW_Init>:
  TimerInit( &RFWPacket.Timer, RFW_GetPayloadTimerEvent );
  return 0;
#else
  return -1;
#endif
}
 803ab78:	f04f 30ff 	mov.w	r0, #4294967295
 803ab7c:	4770      	bx	lr

0803ab7e <RFW_DeInit>:
void RFW_DeInit( void)
{
#if (RFW_ENABLE ==1 )
  RFWPacket.Init.Enable=0; /*Disable the RFWPacket decoding*/
#endif
}
 803ab7e:	4770      	bx	lr

0803ab80 <RFW_Is_Init>:
#if (RFW_ENABLE ==1 )
  return RFWPacket.Init.Enable;
#else
  return 0;
#endif
}
 803ab80:	2000      	movs	r0, #0
 803ab82:	4770      	bx	lr

0803ab84 <RFW_Is_LongPacketModeEnabled>:
 803ab84:	2000      	movs	r0, #0
 803ab86:	4770      	bx	lr

0803ab88 <RFW_SetAntSwitch>:
 803ab88:	4770      	bx	lr

0803ab8a <RFW_TransmitInit>:
    
    status= 0;
  }
#endif
  return status;
}
 803ab8a:	f04f 30ff 	mov.w	r0, #4294967295
 803ab8e:	4770      	bx	lr

0803ab90 <RFW_ReceiveInit>:
  RFWPacket.LongPacketModeEnable=0;
  return 0;
#else
  return -1;
#endif
}
 803ab90:	f04f 30ff 	mov.w	r0, #4294967295
 803ab94:	4770      	bx	lr

0803ab96 <RFW_DeInit_TxLongPacket>:
 803ab96:	4770      	bx	lr

0803ab98 <RFW_ReceivePayload>:
 803ab98:	4770      	bx	lr

0803ab9a <RFW_SetRadioModem>:
void RFW_SetRadioModem(RadioModems_t Modem)
{
#if (RFW_ENABLE ==1 )
  RFWPacket.Init.Modem= Modem;
#endif
}
 803ab9a:	4770      	bx	lr

0803ab9c <TRACE_AllocateBufer>:
 * @param  Size to allocate within fifo
 * @param  Pos position within the fifo
 * @retval write position inside the buffer is -1 no space available.
 */
static int16_t TRACE_AllocateBufer(uint16_t Size, uint16_t *Pos)
{
 803ab9c:	b570      	push	{r4, r5, r6, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803ab9e:	f3ef 8610 	mrs	r6, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803aba2:	b672      	cpsid	i
  uint16_t freesize;
  int16_t ret = -1;

  UTIL_ADV_TRACE_ENTER_CRITICAL_SECTION();

  if(ADV_TRACE_Ctx.TraceWrPtr == ADV_TRACE_Ctx.TraceRdPtr)
 803aba4:	4b14      	ldr	r3, [pc, #80]	; (803abf8 <TRACE_AllocateBufer+0x5c>)
 803aba6:	8a5c      	ldrh	r4, [r3, #18]
 803aba8:	8a1a      	ldrh	r2, [r3, #16]
 803abaa:	4294      	cmp	r4, r2
 803abac:	d113      	bne.n	803abd6 <TRACE_AllocateBufer+0x3a>
  {
#ifdef UTIL_ADV_TRACE_UNCHUNK_MODE
    freesize = (uint16_t)(UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceWrPtr);
 803abae:	f5c4 6280 	rsb	r2, r4, #1024	; 0x400
    if((Size >= freesize) && (ADV_TRACE_Ctx.TraceRdPtr > Size))
 803abb2:	b292      	uxth	r2, r2
 803abb4:	4290      	cmp	r0, r2
 803abb6:	d306      	bcc.n	803abc6 <TRACE_AllocateBufer+0x2a>
 803abb8:	4284      	cmp	r4, r0
  {
#ifdef UTIL_ADV_TRACE_UNCHUNK_MODE
    if (ADV_TRACE_Ctx.TraceWrPtr > ADV_TRACE_Ctx.TraceRdPtr)
    {
      freesize = (uint16_t)(UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceWrPtr);
      if((Size >= freesize) && (ADV_TRACE_Ctx.TraceRdPtr > Size)) 
 803abba:	d918      	bls.n	803abee <TRACE_AllocateBufer+0x52>
      {
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_DETECTED;
 803abbc:	2201      	movs	r2, #1
 803abbe:	709a      	strb	r2, [r3, #2]
        ADV_TRACE_Ctx.unchunk_enabled = ADV_TRACE_Ctx.TraceWrPtr;
        freesize = ADV_TRACE_Ctx.TraceRdPtr;
        ADV_TRACE_Ctx.TraceWrPtr = 0;
 803abc0:	2200      	movs	r2, #0
        ADV_TRACE_Ctx.unchunk_enabled = ADV_TRACE_Ctx.TraceWrPtr;
 803abc2:	801c      	strh	r4, [r3, #0]
        ADV_TRACE_Ctx.TraceWrPtr = 0;
 803abc4:	825a      	strh	r2, [r3, #18]
#endif
  }

  if(freesize > Size)
  {
    *Pos = ADV_TRACE_Ctx.TraceWrPtr;
 803abc6:	8a5a      	ldrh	r2, [r3, #18]
 803abc8:	800a      	strh	r2, [r1, #0]
    ADV_TRACE_Ctx.TraceWrPtr = (ADV_TRACE_Ctx.TraceWrPtr + Size) % UTIL_ADV_TRACE_FIFO_SIZE;
 803abca:	4410      	add	r0, r2
 803abcc:	f3c0 0009 	ubfx	r0, r0, #0, #10
 803abd0:	8258      	strh	r0, [r3, #18]
    ret = 0;
 803abd2:	2000      	movs	r0, #0
 803abd4:	e00d      	b.n	803abf2 <TRACE_AllocateBufer+0x56>
    if (ADV_TRACE_Ctx.TraceWrPtr > ADV_TRACE_Ctx.TraceRdPtr)
 803abd6:	d906      	bls.n	803abe6 <TRACE_AllocateBufer+0x4a>
      freesize = (uint16_t)(UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceWrPtr);
 803abd8:	f5c4 6580 	rsb	r5, r4, #1024	; 0x400
      if((Size >= freesize) && (ADV_TRACE_Ctx.TraceRdPtr > Size)) 
 803abdc:	b2ad      	uxth	r5, r5
 803abde:	4285      	cmp	r5, r0
 803abe0:	d8f1      	bhi.n	803abc6 <TRACE_AllocateBufer+0x2a>
 803abe2:	4282      	cmp	r2, r0
 803abe4:	e7e9      	b.n	803abba <TRACE_AllocateBufer+0x1e>
      freesize = (uint16_t)(ADV_TRACE_Ctx.TraceRdPtr - ADV_TRACE_Ctx.TraceWrPtr);
 803abe6:	1b12      	subs	r2, r2, r4
  if(freesize > Size)
 803abe8:	b292      	uxth	r2, r2
 803abea:	4282      	cmp	r2, r0
 803abec:	d8eb      	bhi.n	803abc6 <TRACE_AllocateBufer+0x2a>
  int16_t ret = -1;
 803abee:	f04f 30ff 	mov.w	r0, #4294967295
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803abf2:	f386 8810 	msr	PRIMASK, r6
  }
#endif

  UTIL_ADV_TRACE_EXIT_CRITICAL_SECTION();
  return ret;
}
 803abf6:	bd70      	pop	{r4, r5, r6, pc}
 803abf8:	20005a90 	.word	0x20005a90

0803abfc <TRACE_Lock>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803abfc:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803ac00:	b672      	cpsid	i
 * @retval None.
 */
static void TRACE_Lock(void)
{
  UTIL_ADV_TRACE_ENTER_CRITICAL_SECTION();
  ADV_TRACE_Ctx.TraceLock++;
 803ac02:	4a03      	ldr	r2, [pc, #12]	; (803ac10 <TRACE_Lock+0x14>)
 803ac04:	8ad3      	ldrh	r3, [r2, #22]
 803ac06:	3301      	adds	r3, #1
 803ac08:	82d3      	strh	r3, [r2, #22]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803ac0a:	f381 8810 	msr	PRIMASK, r1
  UTIL_ADV_TRACE_EXIT_CRITICAL_SECTION();
}
 803ac0e:	4770      	bx	lr
 803ac10:	20005a90 	.word	0x20005a90

0803ac14 <TRACE_UnLock>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803ac14:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803ac18:	b672      	cpsid	i
 * @retval None.
 */
static void TRACE_UnLock(void)
{
  UTIL_ADV_TRACE_ENTER_CRITICAL_SECTION();
  ADV_TRACE_Ctx.TraceLock--;
 803ac1a:	4a03      	ldr	r2, [pc, #12]	; (803ac28 <TRACE_UnLock+0x14>)
 803ac1c:	8ad3      	ldrh	r3, [r2, #22]
 803ac1e:	3b01      	subs	r3, #1
 803ac20:	82d3      	strh	r3, [r2, #22]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803ac22:	f381 8810 	msr	PRIMASK, r1
  UTIL_ADV_TRACE_EXIT_CRITICAL_SECTION();
}
 803ac26:	4770      	bx	lr
 803ac28:	20005a90 	.word	0x20005a90

0803ac2c <UTIL_ADV_TRACE_Init>:
{
 803ac2c:	b510      	push	{r4, lr}
  (void)UTIL_ADV_TRACE_MEMSET8(&ADV_TRACE_Ctx, 0x0, sizeof(ADV_TRACE_Context));
 803ac2e:	4c09      	ldr	r4, [pc, #36]	; (803ac54 <UTIL_ADV_TRACE_Init+0x28>)
 803ac30:	2218      	movs	r2, #24
 803ac32:	4620      	mov	r0, r4
 803ac34:	2100      	movs	r1, #0
 803ac36:	f000 f973 	bl	803af20 <UTIL_MEM_set_8>
  (void)UTIL_ADV_TRACE_MEMSET8(&ADV_TRACE_Buffer, 0x0, sizeof(ADV_TRACE_Buffer));
 803ac3a:	f104 0018 	add.w	r0, r4, #24
 803ac3e:	f44f 6280 	mov.w	r2, #1024	; 0x400
 803ac42:	2100      	movs	r1, #0
 803ac44:	f000 f96c 	bl	803af20 <UTIL_MEM_set_8>
  return UTIL_TraceDriver.Init(TRACE_TxCpltCallback);
 803ac48:	4b03      	ldr	r3, [pc, #12]	; (803ac58 <UTIL_ADV_TRACE_Init+0x2c>)
 803ac4a:	4804      	ldr	r0, [pc, #16]	; (803ac5c <UTIL_ADV_TRACE_Init+0x30>)
 803ac4c:	681b      	ldr	r3, [r3, #0]
}
 803ac4e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return UTIL_TraceDriver.Init(TRACE_TxCpltCallback);
 803ac52:	4718      	bx	r3
 803ac54:	20005a90 	.word	0x20005a90
 803ac58:	0803b908 	.word	0x0803b908
 803ac5c:	0803adcd 	.word	0x0803adcd

0803ac60 <UTIL_ADV_TRACE_RegisterTimeStampFunction>:
  ADV_TRACE_Ctx.timestamp_func = *cb;
 803ac60:	4b01      	ldr	r3, [pc, #4]	; (803ac68 <UTIL_ADV_TRACE_RegisterTimeStampFunction+0x8>)
 803ac62:	6058      	str	r0, [r3, #4]
}
 803ac64:	4770      	bx	lr
 803ac66:	bf00      	nop
 803ac68:	20005a90 	.word	0x20005a90

0803ac6c <UTIL_ADV_TRACE_SetVerboseLevel>:
  ADV_TRACE_Ctx.CurrentVerboseLevel = Level;
 803ac6c:	4b01      	ldr	r3, [pc, #4]	; (803ac74 <UTIL_ADV_TRACE_SetVerboseLevel+0x8>)
 803ac6e:	7218      	strb	r0, [r3, #8]
}
 803ac70:	4770      	bx	lr
 803ac72:	bf00      	nop
 803ac74:	20005a90 	.word	0x20005a90

0803ac78 <TRACE_Send>:
{
 803ac78:	b573      	push	{r0, r1, r4, r5, r6, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803ac7a:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803ac7e:	b672      	cpsid	i
 * @brief  UnLock the trace buffer.
 * @retval None.
 */
static uint32_t TRACE_IsLocked(void)
{
  return (ADV_TRACE_Ctx.TraceLock == 0u? 0u: 1u);
 803ac80:	4c1b      	ldr	r4, [pc, #108]	; (803acf0 <TRACE_Send+0x78>)
  if(TRACE_IsLocked() == 0u)
 803ac82:	8ae0      	ldrh	r0, [r4, #22]
 803ac84:	2800      	cmp	r0, #0
 803ac86:	d12e      	bne.n	803ace6 <TRACE_Send+0x6e>
    TRACE_Lock();
 803ac88:	f7ff ffb8 	bl	803abfc <TRACE_Lock>
    if(ADV_TRACE_Ctx.TraceRdPtr != ADV_TRACE_Ctx.TraceWrPtr)
 803ac8c:	8a26      	ldrh	r6, [r4, #16]
 803ac8e:	8a62      	ldrh	r2, [r4, #18]
 803ac90:	4296      	cmp	r6, r2
 803ac92:	d026      	beq.n	803ace2 <TRACE_Send+0x6a>
      if(TRACE_UNCHUNK_DETECTED == ADV_TRACE_Ctx.unchunk_status)
 803ac94:	78a1      	ldrb	r1, [r4, #2]
 803ac96:	2901      	cmp	r1, #1
 803ac98:	d111      	bne.n	803acbe <TRACE_Send+0x46>
        ADV_TRACE_Ctx.TraceSentSize = (uint16_t) (ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr);
 803ac9a:	8823      	ldrh	r3, [r4, #0]
        ADV_TRACE_Ctx.unchunk_enabled = 0;
 803ac9c:	8020      	strh	r0, [r4, #0]
        ADV_TRACE_Ctx.TraceSentSize = (uint16_t) (ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr);
 803ac9e:	1b9b      	subs	r3, r3, r6
 803aca0:	b29b      	uxth	r3, r3
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_TRANSFER;
 803aca2:	2102      	movs	r1, #2
        ADV_TRACE_Ctx.TraceSentSize = (uint16_t) (ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr);
 803aca4:	82a3      	strh	r3, [r4, #20]
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_TRANSFER;
 803aca6:	70a1      	strb	r1, [r4, #2]
        if(0u == ADV_TRACE_Ctx.TraceSentSize)
 803aca8:	b95b      	cbnz	r3, 803acc2 <TRACE_Send+0x4a>
          ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_NONE;
 803acaa:	70a3      	strb	r3, [r4, #2]
          ADV_TRACE_Ctx.TraceRdPtr = 0;
 803acac:	8223      	strh	r3, [r4, #16]
        if(ADV_TRACE_Ctx.TraceWrPtr > ADV_TRACE_Ctx.TraceRdPtr)
 803acae:	8a23      	ldrh	r3, [r4, #16]
 803acb0:	429a      	cmp	r2, r3
          ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.TraceWrPtr - ADV_TRACE_Ctx.TraceRdPtr;
 803acb2:	bf8c      	ite	hi
 803acb4:	1ad3      	subhi	r3, r2, r3
          ADV_TRACE_Ctx.TraceSentSize = UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceRdPtr;
 803acb6:	f5c3 6380 	rsbls	r3, r3, #1024	; 0x400
 803acba:	82a3      	strh	r3, [r4, #20]
 803acbc:	e001      	b.n	803acc2 <TRACE_Send+0x4a>
      if(TRACE_UNCHUNK_NONE == ADV_TRACE_Ctx.unchunk_status)
 803acbe:	2900      	cmp	r1, #0
 803acc0:	d0f5      	beq.n	803acae <TRACE_Send+0x36>
      ptr = &ADV_TRACE_Buffer[ADV_TRACE_Ctx.TraceRdPtr];
 803acc2:	8a20      	ldrh	r0, [r4, #16]
 803acc4:	4e0b      	ldr	r6, [pc, #44]	; (803acf4 <TRACE_Send+0x7c>)
 803acc6:	4406      	add	r6, r0
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803acc8:	f385 8810 	msr	PRIMASK, r5
      UTIL_ADV_TRACE_PreSendHook();
 803accc:	f7f1 fcb0 	bl	802c630 <UTIL_ADV_TRACE_PreSendHook>
      ret = UTIL_TraceDriver.Send(ptr, ADV_TRACE_Ctx.TraceSentSize);
 803acd0:	4b09      	ldr	r3, [pc, #36]	; (803acf8 <TRACE_Send+0x80>)
 803acd2:	8aa1      	ldrh	r1, [r4, #20]
 803acd4:	68db      	ldr	r3, [r3, #12]
 803acd6:	9301      	str	r3, [sp, #4]
 803acd8:	4630      	mov	r0, r6
}
 803acda:	b002      	add	sp, #8
 803acdc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      ret = UTIL_TraceDriver.Send(ptr, ADV_TRACE_Ctx.TraceSentSize);
 803ace0:	4718      	bx	r3
      TRACE_UnLock();
 803ace2:	f7ff ff97 	bl	803ac14 <TRACE_UnLock>
 803ace6:	f385 8810 	msr	PRIMASK, r5
}
 803acea:	2000      	movs	r0, #0
 803acec:	b002      	add	sp, #8
 803acee:	bd70      	pop	{r4, r5, r6, pc}
 803acf0:	20005a90 	.word	0x20005a90
 803acf4:	20005aa8 	.word	0x20005aa8
 803acf8:	0803b908 	.word	0x0803b908

0803acfc <UTIL_ADV_TRACE_COND_FSend>:
{
 803acfc:	b408      	push	{r3}
 803acfe:	b5f0      	push	{r4, r5, r6, r7, lr}
  if(!(ADV_TRACE_Ctx.CurrentVerboseLevel >= VerboseLevel))
 803ad00:	4c2f      	ldr	r4, [pc, #188]	; (803adc0 <UTIL_ADV_TRACE_COND_FSend+0xc4>)
{
 803ad02:	b086      	sub	sp, #24
  uint16_t timestamp_size = 0u;
 803ad04:	2300      	movs	r3, #0
 803ad06:	f8ad 3000 	strh.w	r3, [sp]
  if(!(ADV_TRACE_Ctx.CurrentVerboseLevel >= VerboseLevel))
 803ad0a:	7a23      	ldrb	r3, [r4, #8]
{
 803ad0c:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
  if(!(ADV_TRACE_Ctx.CurrentVerboseLevel >= VerboseLevel))
 803ad0e:	4283      	cmp	r3, r0
 803ad10:	d34f      	bcc.n	803adb2 <UTIL_ADV_TRACE_COND_FSend+0xb6>
  if((Region & ADV_TRACE_Ctx.RegionMask) != Region)
 803ad12:	68e3      	ldr	r3, [r4, #12]
 803ad14:	ea31 0303 	bics.w	r3, r1, r3
 803ad18:	d14e      	bne.n	803adb8 <UTIL_ADV_TRACE_COND_FSend+0xbc>
  if((ADV_TRACE_Ctx.timestamp_func != NULL) && (TimeStampState != 0u))
 803ad1a:	6863      	ldr	r3, [r4, #4]
 803ad1c:	b11b      	cbz	r3, 803ad26 <UTIL_ADV_TRACE_COND_FSend+0x2a>
 803ad1e:	b112      	cbz	r2, 803ad26 <UTIL_ADV_TRACE_COND_FSend+0x2a>
    ADV_TRACE_Ctx.timestamp_func(buf,&timestamp_size);
 803ad20:	4669      	mov	r1, sp
 803ad22:	a802      	add	r0, sp, #8
 803ad24:	4798      	blx	r3
  va_start( vaArgs, strFormat);
 803ad26:	ab0c      	add	r3, sp, #48	; 0x30
  buff_size =(uint16_t)UTIL_ADV_TRACE_VSNPRINTF((char *)sztmp,UTIL_ADV_TRACE_TMP_BUF_SIZE, strFormat, vaArgs);
 803ad28:	462a      	mov	r2, r5
 803ad2a:	f44f 7100 	mov.w	r1, #512	; 0x200
 803ad2e:	4825      	ldr	r0, [pc, #148]	; (803adc4 <UTIL_ADV_TRACE_COND_FSend+0xc8>)
  va_start( vaArgs, strFormat);
 803ad30:	9301      	str	r3, [sp, #4]
  buff_size =(uint16_t)UTIL_ADV_TRACE_VSNPRINTF((char *)sztmp,UTIL_ADV_TRACE_TMP_BUF_SIZE, strFormat, vaArgs);
 803ad32:	f000 fbeb 	bl	803b50c <tiny_vsnprintf_like>
  TRACE_Lock();
 803ad36:	f7ff ff61 	bl	803abfc <TRACE_Lock>
  if (TRACE_AllocateBufer((buff_size+timestamp_size),&writepos) != -1)
 803ad3a:	f8bd 3000 	ldrh.w	r3, [sp]
 803ad3e:	4418      	add	r0, r3
 803ad40:	f10d 0102 	add.w	r1, sp, #2
 803ad44:	b280      	uxth	r0, r0
 803ad46:	f7ff ff29 	bl	803ab9c <TRACE_AllocateBufer>
 803ad4a:	3001      	adds	r0, #1
 803ad4c:	d02c      	beq.n	803ada8 <UTIL_ADV_TRACE_COND_FSend+0xac>
    for (idx = 0u; idx < timestamp_size; idx++)
 803ad4e:	2200      	movs	r2, #0
 803ad50:	f8bd 3000 	ldrh.w	r3, [sp]
 803ad54:	f8bd 7002 	ldrh.w	r7, [sp, #2]
 803ad58:	4616      	mov	r6, r2
      ADV_TRACE_Buffer[writepos] = buf[idx];
 803ad5a:	f10d 0c08 	add.w	ip, sp, #8
 803ad5e:	b290      	uxth	r0, r2
 803ad60:	fa17 f182 	uxtah	r1, r7, r2
    for (idx = 0u; idx < timestamp_size; idx++)
 803ad64:	4283      	cmp	r3, r0
 803ad66:	b289      	uxth	r1, r1
 803ad68:	d817      	bhi.n	803ad9a <UTIL_ADV_TRACE_COND_FSend+0x9e>
 803ad6a:	443b      	add	r3, r7
 803ad6c:	b29b      	uxth	r3, r3
 803ad6e:	b10e      	cbz	r6, 803ad74 <UTIL_ADV_TRACE_COND_FSend+0x78>
 803ad70:	f8ad 3002 	strh.w	r3, [sp, #2]
    (void)UTIL_ADV_TRACE_VSNPRINTF((char *)(&ADV_TRACE_Buffer[writepos]), UTIL_ADV_TRACE_TMP_BUF_SIZE, strFormat, vaArgs);
 803ad74:	f8bd 0002 	ldrh.w	r0, [sp, #2]
 803ad78:	4c13      	ldr	r4, [pc, #76]	; (803adc8 <UTIL_ADV_TRACE_COND_FSend+0xcc>)
 803ad7a:	9b01      	ldr	r3, [sp, #4]
 803ad7c:	462a      	mov	r2, r5
 803ad7e:	f44f 7100 	mov.w	r1, #512	; 0x200
 803ad82:	4420      	add	r0, r4
 803ad84:	f000 fbc2 	bl	803b50c <tiny_vsnprintf_like>
    TRACE_UnLock();
 803ad88:	f7ff ff44 	bl	803ac14 <TRACE_UnLock>
    return TRACE_Send();
 803ad8c:	f7ff ff74 	bl	803ac78 <TRACE_Send>
}
 803ad90:	b006      	add	sp, #24
 803ad92:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 803ad96:	b001      	add	sp, #4
 803ad98:	4770      	bx	lr
      ADV_TRACE_Buffer[writepos] = buf[idx];
 803ad9a:	4421      	add	r1, r4
 803ad9c:	f812 000c 	ldrb.w	r0, [r2, ip]
 803ada0:	7608      	strb	r0, [r1, #24]
    for (idx = 0u; idx < timestamp_size; idx++)
 803ada2:	3201      	adds	r2, #1
      ADV_TRACE_Buffer[writepos] = buf[idx];
 803ada4:	2601      	movs	r6, #1
 803ada6:	e7da      	b.n	803ad5e <UTIL_ADV_TRACE_COND_FSend+0x62>
  TRACE_UnLock();
 803ada8:	f7ff ff34 	bl	803ac14 <TRACE_UnLock>
  return UTIL_ADV_TRACE_MEM_FULL;
 803adac:	f06f 0002 	mvn.w	r0, #2
 803adb0:	e7ee      	b.n	803ad90 <UTIL_ADV_TRACE_COND_FSend+0x94>
    return UTIL_ADV_TRACE_GIVEUP;
 803adb2:	f06f 0004 	mvn.w	r0, #4
 803adb6:	e7eb      	b.n	803ad90 <UTIL_ADV_TRACE_COND_FSend+0x94>
    return UTIL_ADV_TRACE_REGIONMASKED;
 803adb8:	f06f 0005 	mvn.w	r0, #5
 803adbc:	e7e8      	b.n	803ad90 <UTIL_ADV_TRACE_COND_FSend+0x94>
 803adbe:	bf00      	nop
 803adc0:	20005a90 	.word	0x20005a90
 803adc4:	20005ea8 	.word	0x20005ea8
 803adc8:	20005aa8 	.word	0x20005aa8

0803adcc <TRACE_TxCpltCallback>:
{
 803adcc:	b537      	push	{r0, r1, r2, r4, r5, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803adce:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803add2:	b672      	cpsid	i
  if(TRACE_UNCHUNK_TRANSFER == ADV_TRACE_Ctx.unchunk_status)
 803add4:	4b21      	ldr	r3, [pc, #132]	; (803ae5c <TRACE_TxCpltCallback+0x90>)
 803add6:	789a      	ldrb	r2, [r3, #2]
 803add8:	2a02      	cmp	r2, #2
    ADV_TRACE_Ctx.TraceRdPtr = (ADV_TRACE_Ctx.TraceRdPtr + ADV_TRACE_Ctx.TraceSentSize) % UTIL_ADV_TRACE_FIFO_SIZE;
 803adda:	bf1d      	ittte	ne
 803addc:	8a1a      	ldrhne	r2, [r3, #16]
 803adde:	8a99      	ldrhne	r1, [r3, #20]
 803ade0:	1852      	addne	r2, r2, r1
    ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_NONE;
 803ade2:	2200      	moveq	r2, #0
    ADV_TRACE_Ctx.TraceRdPtr = (ADV_TRACE_Ctx.TraceRdPtr + ADV_TRACE_Ctx.TraceSentSize) % UTIL_ADV_TRACE_FIFO_SIZE;
 803ade4:	bf18      	it	ne
 803ade6:	f3c2 0209 	ubfxne	r2, r2, #0, #10
 803adea:	821a      	strh	r2, [r3, #16]
  if((ADV_TRACE_Ctx.TraceRdPtr != ADV_TRACE_Ctx.TraceWrPtr) && (1u == ADV_TRACE_Ctx.TraceLock))
 803adec:	8a1d      	ldrh	r5, [r3, #16]
 803adee:	8a59      	ldrh	r1, [r3, #18]
    ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_NONE;
 803adf0:	bf08      	it	eq
 803adf2:	709a      	strbeq	r2, [r3, #2]
  if((ADV_TRACE_Ctx.TraceRdPtr != ADV_TRACE_Ctx.TraceWrPtr) && (1u == ADV_TRACE_Ctx.TraceLock))
 803adf4:	428d      	cmp	r5, r1
 803adf6:	d027      	beq.n	803ae48 <TRACE_TxCpltCallback+0x7c>
 803adf8:	8ada      	ldrh	r2, [r3, #22]
 803adfa:	2a01      	cmp	r2, #1
 803adfc:	d124      	bne.n	803ae48 <TRACE_TxCpltCallback+0x7c>
    if(TRACE_UNCHUNK_DETECTED == ADV_TRACE_Ctx.unchunk_status)
 803adfe:	7898      	ldrb	r0, [r3, #2]
 803ae00:	2801      	cmp	r0, #1
 803ae02:	d112      	bne.n	803ae2a <TRACE_TxCpltCallback+0x5e>
      ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr;
 803ae04:	881a      	ldrh	r2, [r3, #0]
      ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_TRANSFER;
 803ae06:	2002      	movs	r0, #2
      ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr;
 803ae08:	1b52      	subs	r2, r2, r5
 803ae0a:	b292      	uxth	r2, r2
      ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_TRANSFER;
 803ae0c:	7098      	strb	r0, [r3, #2]
      ADV_TRACE_Ctx.unchunk_enabled = 0;
 803ae0e:	2000      	movs	r0, #0
      ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr;
 803ae10:	829a      	strh	r2, [r3, #20]
      ADV_TRACE_Ctx.unchunk_enabled = 0;
 803ae12:	8018      	strh	r0, [r3, #0]
      if(0u == ADV_TRACE_Ctx.TraceSentSize)
 803ae14:	b95a      	cbnz	r2, 803ae2e <TRACE_TxCpltCallback+0x62>
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_NONE;
 803ae16:	709a      	strb	r2, [r3, #2]
        ADV_TRACE_Ctx.TraceRdPtr = 0;
 803ae18:	821a      	strh	r2, [r3, #16]
      if(ADV_TRACE_Ctx.TraceWrPtr > ADV_TRACE_Ctx.TraceRdPtr)
 803ae1a:	8a1a      	ldrh	r2, [r3, #16]
 803ae1c:	4291      	cmp	r1, r2
        ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.TraceWrPtr - ADV_TRACE_Ctx.TraceRdPtr;
 803ae1e:	bf8c      	ite	hi
 803ae20:	1a8a      	subhi	r2, r1, r2
        ADV_TRACE_Ctx.TraceSentSize = UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceRdPtr;
 803ae22:	f5c2 6280 	rsbls	r2, r2, #1024	; 0x400
 803ae26:	829a      	strh	r2, [r3, #20]
 803ae28:	e001      	b.n	803ae2e <TRACE_TxCpltCallback+0x62>
    if(TRACE_UNCHUNK_NONE == ADV_TRACE_Ctx.unchunk_status)
 803ae2a:	2800      	cmp	r0, #0
 803ae2c:	d0f5      	beq.n	803ae1a <TRACE_TxCpltCallback+0x4e>
    ptr = &ADV_TRACE_Buffer[ADV_TRACE_Ctx.TraceRdPtr];
 803ae2e:	8a1a      	ldrh	r2, [r3, #16]
 803ae30:	480b      	ldr	r0, [pc, #44]	; (803ae60 <TRACE_TxCpltCallback+0x94>)
 803ae32:	4410      	add	r0, r2
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803ae34:	f384 8810 	msr	PRIMASK, r4
    UTIL_TraceDriver.Send(ptr, ADV_TRACE_Ctx.TraceSentSize);
 803ae38:	4a0a      	ldr	r2, [pc, #40]	; (803ae64 <TRACE_TxCpltCallback+0x98>)
 803ae3a:	8a99      	ldrh	r1, [r3, #20]
 803ae3c:	68d3      	ldr	r3, [r2, #12]
 803ae3e:	9301      	str	r3, [sp, #4]
}
 803ae40:	b003      	add	sp, #12
 803ae42:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    UTIL_TraceDriver.Send(ptr, ADV_TRACE_Ctx.TraceSentSize);
 803ae46:	4718      	bx	r3
 803ae48:	f384 8810 	msr	PRIMASK, r4
    UTIL_ADV_TRACE_PostSendHook();
 803ae4c:	f7f1 fbf4 	bl	802c638 <UTIL_ADV_TRACE_PostSendHook>
}
 803ae50:	b003      	add	sp, #12
 803ae52:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    TRACE_UnLock();
 803ae56:	f7ff bedd 	b.w	803ac14 <TRACE_UnLock>
 803ae5a:	bf00      	nop
 803ae5c:	20005a90 	.word	0x20005a90
 803ae60:	20005aa8 	.word	0x20005aa8
 803ae64:	0803b908 	.word	0x0803b908

0803ae68 <UTIL_LPM_Init>:
/** @addtogroup TINY_LPM_Exported_function
  * @{
  */
void UTIL_LPM_Init( void )
{
  StopModeDisable = UTIL_LPM_NO_BIT_SET;
 803ae68:	4b02      	ldr	r3, [pc, #8]	; (803ae74 <UTIL_LPM_Init+0xc>)
 803ae6a:	2200      	movs	r2, #0
  OffModeDisable = UTIL_LPM_NO_BIT_SET;
 803ae6c:	e9c3 2200 	strd	r2, r2, [r3]
  UTIL_LPM_INIT_CRITICAL_SECTION( );
}
 803ae70:	4770      	bx	lr
 803ae72:	bf00      	nop
 803ae74:	200060a8 	.word	0x200060a8

0803ae78 <UTIL_LPM_SetStopMode>:
void UTIL_LPM_DeInit( void )
{
}

void UTIL_LPM_SetStopMode( UTIL_LPM_bm_t lpm_id_bm, UTIL_LPM_State_t state )
{
 803ae78:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803ae7a:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803ae7e:	b672      	cpsid	i
  UTIL_LPM_ENTER_CRITICAL_SECTION( );
  
  switch( state )
 803ae80:	b141      	cbz	r1, 803ae94 <UTIL_LPM_SetStopMode+0x1c>
 803ae82:	2901      	cmp	r1, #1
 803ae84:	d103      	bne.n	803ae8e <UTIL_LPM_SetStopMode+0x16>
  {
  case UTIL_LPM_DISABLE:
    {
      StopModeDisable |= lpm_id_bm;
 803ae86:	4a06      	ldr	r2, [pc, #24]	; (803aea0 <UTIL_LPM_SetStopMode+0x28>)
 803ae88:	6813      	ldr	r3, [r2, #0]
 803ae8a:	4318      	orrs	r0, r3
      break;
    }
  case UTIL_LPM_ENABLE:
    {
      StopModeDisable &= ( ~lpm_id_bm );
 803ae8c:	6010      	str	r0, [r2, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803ae8e:	f384 8810 	msr	PRIMASK, r4
      break;
    }
  }
  
  UTIL_LPM_EXIT_CRITICAL_SECTION( );
}
 803ae92:	bd10      	pop	{r4, pc}
      StopModeDisable &= ( ~lpm_id_bm );
 803ae94:	4a02      	ldr	r2, [pc, #8]	; (803aea0 <UTIL_LPM_SetStopMode+0x28>)
 803ae96:	6813      	ldr	r3, [r2, #0]
 803ae98:	ea23 0000 	bic.w	r0, r3, r0
 803ae9c:	e7f6      	b.n	803ae8c <UTIL_LPM_SetStopMode+0x14>
 803ae9e:	bf00      	nop
 803aea0:	200060a8 	.word	0x200060a8

0803aea4 <UTIL_LPM_SetOffMode>:

void UTIL_LPM_SetOffMode( UTIL_LPM_bm_t lpm_id_bm, UTIL_LPM_State_t state )
{
 803aea4:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803aea6:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803aeaa:	b672      	cpsid	i
  UTIL_LPM_ENTER_CRITICAL_SECTION( );
  
  switch(state)
 803aeac:	b141      	cbz	r1, 803aec0 <UTIL_LPM_SetOffMode+0x1c>
 803aeae:	2901      	cmp	r1, #1
 803aeb0:	d103      	bne.n	803aeba <UTIL_LPM_SetOffMode+0x16>
  {
  case UTIL_LPM_DISABLE:
    {
      OffModeDisable |= lpm_id_bm;
 803aeb2:	4a06      	ldr	r2, [pc, #24]	; (803aecc <UTIL_LPM_SetOffMode+0x28>)
 803aeb4:	6853      	ldr	r3, [r2, #4]
 803aeb6:	4318      	orrs	r0, r3
      break;
    }
  case UTIL_LPM_ENABLE:
    {
      OffModeDisable &= ( ~lpm_id_bm );
 803aeb8:	6050      	str	r0, [r2, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803aeba:	f384 8810 	msr	PRIMASK, r4
      break;
    }
  }
  
  UTIL_LPM_EXIT_CRITICAL_SECTION( );
}
 803aebe:	bd10      	pop	{r4, pc}
      OffModeDisable &= ( ~lpm_id_bm );
 803aec0:	4a02      	ldr	r2, [pc, #8]	; (803aecc <UTIL_LPM_SetOffMode+0x28>)
 803aec2:	6853      	ldr	r3, [r2, #4]
 803aec4:	ea23 0000 	bic.w	r0, r3, r0
 803aec8:	e7f6      	b.n	803aeb8 <UTIL_LPM_SetOffMode+0x14>
 803aeca:	bf00      	nop
 803aecc:	200060a8 	.word	0x200060a8

0803aed0 <UTIL_LPM_EnterLowPower>:

  return mode_selected;
}

void UTIL_LPM_EnterLowPower( void )
{
 803aed0:	b538      	push	{r3, r4, r5, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803aed2:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803aed6:	b672      	cpsid	i
  UTIL_LPM_ENTER_CRITICAL_SECTION_ELP( );

  if( StopModeDisable != UTIL_LPM_NO_BIT_SET )
 803aed8:	4b0a      	ldr	r3, [pc, #40]	; (803af04 <UTIL_LPM_EnterLowPower+0x34>)
 803aeda:	4c0b      	ldr	r4, [pc, #44]	; (803af08 <UTIL_LPM_EnterLowPower+0x38>)
 803aedc:	681a      	ldr	r2, [r3, #0]
 803aede:	b132      	cbz	r2, 803aeee <UTIL_LPM_EnterLowPower+0x1e>
  {
    /**
     * At least one user disallows Stop Mode
     * SLEEP mode is required
     */
      UTIL_PowerDriver.EnterSleepMode( );
 803aee0:	6823      	ldr	r3, [r4, #0]
 803aee2:	4798      	blx	r3
      UTIL_PowerDriver.ExitSleepMode( );
 803aee4:	6863      	ldr	r3, [r4, #4]
    {
      /**
       * OFF mode is required
       */
      UTIL_PowerDriver.EnterOffMode( );
      UTIL_PowerDriver.ExitOffMode( );
 803aee6:	4798      	blx	r3
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803aee8:	f385 8810 	msr	PRIMASK, r5
    }
  }
  
  UTIL_LPM_EXIT_CRITICAL_SECTION_ELP( );
}
 803aeec:	bd38      	pop	{r3, r4, r5, pc}
    if( OffModeDisable != UTIL_LPM_NO_BIT_SET )
 803aeee:	685b      	ldr	r3, [r3, #4]
 803aef0:	b11b      	cbz	r3, 803aefa <UTIL_LPM_EnterLowPower+0x2a>
        UTIL_PowerDriver.EnterStopMode( );
 803aef2:	68a3      	ldr	r3, [r4, #8]
 803aef4:	4798      	blx	r3
        UTIL_PowerDriver.ExitStopMode( );
 803aef6:	68e3      	ldr	r3, [r4, #12]
 803aef8:	e7f5      	b.n	803aee6 <UTIL_LPM_EnterLowPower+0x16>
      UTIL_PowerDriver.EnterOffMode( );
 803aefa:	6923      	ldr	r3, [r4, #16]
 803aefc:	4798      	blx	r3
      UTIL_PowerDriver.ExitOffMode( );
 803aefe:	6963      	ldr	r3, [r4, #20]
 803af00:	e7f1      	b.n	803aee6 <UTIL_LPM_EnterLowPower+0x16>
 803af02:	bf00      	nop
 803af04:	200060a8 	.word	0x200060a8
 803af08:	0803b8b0 	.word	0x0803b8b0

0803af0c <UTIL_MEM_cpy_8>:
void UTIL_MEM_cpy_8( void *dst, const void *src, uint16_t size )
{
  uint8_t* dst8= (uint8_t *) dst;
  uint8_t* src8= (uint8_t *) src;

  while( size-- )
 803af0c:	3801      	subs	r0, #1
 803af0e:	440a      	add	r2, r1
 803af10:	4291      	cmp	r1, r2
 803af12:	d100      	bne.n	803af16 <UTIL_MEM_cpy_8+0xa>
    {
        *dst8++ = *src8++;
    }
}
 803af14:	4770      	bx	lr
        *dst8++ = *src8++;
 803af16:	f811 3b01 	ldrb.w	r3, [r1], #1
 803af1a:	f800 3f01 	strb.w	r3, [r0, #1]!
 803af1e:	e7f7      	b.n	803af10 <UTIL_MEM_cpy_8+0x4>

0803af20 <UTIL_MEM_set_8>:
}

void UTIL_MEM_set_8( void *dst, uint8_t value, uint16_t size )
{
  uint8_t* dst8= (uint8_t *) dst;
  while( size-- )
 803af20:	4402      	add	r2, r0
 803af22:	4290      	cmp	r0, r2
 803af24:	d100      	bne.n	803af28 <UTIL_MEM_set_8+0x8>
  {
    *dst8++ = value;
  }
}
 803af26:	4770      	bx	lr
    *dst8++ = value;
 803af28:	f800 1b01 	strb.w	r1, [r0], #1
 803af2c:	e7f9      	b.n	803af22 <UTIL_MEM_set_8+0x2>
	...

0803af30 <UTIL_SEQ_SetTask>:

  return;
}

void UTIL_SEQ_SetTask( UTIL_SEQ_bm_t TaskId_bm , uint32_t Task_Prio )
{
 803af30:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803af32:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803af36:	b672      	cpsid	i
  UTIL_SEQ_ENTER_CRITICAL_SECTION( );

  TaskSet |= TaskId_bm;
 803af38:	4b06      	ldr	r3, [pc, #24]	; (803af54 <UTIL_SEQ_SetTask+0x24>)
 803af3a:	681a      	ldr	r2, [r3, #0]
 803af3c:	4302      	orrs	r2, r0
 803af3e:	601a      	str	r2, [r3, #0]
  TaskPrio[Task_Prio].priority |= TaskId_bm;
 803af40:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 803af44:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 803af48:	4310      	orrs	r0, r2
 803af4a:	f8c3 0090 	str.w	r0, [r3, #144]	; 0x90
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803af4e:	f384 8810 	msr	PRIMASK, r4

  UTIL_SEQ_EXIT_CRITICAL_SECTION( );

  return;
}
 803af52:	bd10      	pop	{r4, pc}
 803af54:	200060b0 	.word	0x200060b0

0803af58 <UTIL_SEQ_PreIdle>:
 803af58:	4770      	bx	lr

0803af5a <UTIL_SEQ_PostIdle>:
 803af5a:	4770      	bx	lr

0803af5c <SEQ_BitPosition>:
 */
uint8_t SEQ_BitPosition(uint32_t Value)
{
  uint8_t n = 0U;

  if ((Value & 0xFFFF0000U) == 0U)  { n  = 16U; Value <<= 16U;  }
 803af5c:	0c03      	lsrs	r3, r0, #16
 803af5e:	041b      	lsls	r3, r3, #16
 803af60:	b9c3      	cbnz	r3, 803af94 <SEQ_BitPosition+0x38>
 803af62:	0400      	lsls	r0, r0, #16
 803af64:	2310      	movs	r3, #16
  if ((Value & 0xFF000000U) == 0U)  { n +=  8U; Value <<=  8U;  }
 803af66:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
 803af6a:	bf02      	ittt	eq
 803af6c:	3308      	addeq	r3, #8
 803af6e:	0200      	lsleq	r0, r0, #8
 803af70:	b2db      	uxtbeq	r3, r3
  if ((Value & 0xF0000000U) == 0U)  { n +=  4U; Value <<=  4U;  }
 803af72:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
 803af76:	bf08      	it	eq
 803af78:	0100      	lsleq	r0, r0, #4

  n += SEQ_clz_table_4bit[Value >> (32-4)];

  return (uint8_t)(31U-n);
 803af7a:	4a07      	ldr	r2, [pc, #28]	; (803af98 <SEQ_BitPosition+0x3c>)
  n += SEQ_clz_table_4bit[Value >> (32-4)];
 803af7c:	ea4f 7010 	mov.w	r0, r0, lsr #28
  if ((Value & 0xF0000000U) == 0U)  { n +=  4U; Value <<=  4U;  }
 803af80:	bf08      	it	eq
 803af82:	3304      	addeq	r3, #4
  return (uint8_t)(31U-n);
 803af84:	5c10      	ldrb	r0, [r2, r0]
  if ((Value & 0xF0000000U) == 0U)  { n +=  4U; Value <<=  4U;  }
 803af86:	bf08      	it	eq
 803af88:	b2db      	uxtbeq	r3, r3
  return (uint8_t)(31U-n);
 803af8a:	f1c3 031f 	rsb	r3, r3, #31
 803af8e:	1a18      	subs	r0, r3, r0
}
 803af90:	b2c0      	uxtb	r0, r0
 803af92:	4770      	bx	lr
  uint8_t n = 0U;
 803af94:	2300      	movs	r3, #0
 803af96:	e7e6      	b.n	803af66 <SEQ_BitPosition+0xa>
 803af98:	0803bd78 	.word	0x0803bd78

0803af9c <UTIL_SEQ_Run>:
{
 803af9c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  super_mask_backup = SuperMask;
 803afa0:	4d36      	ldr	r5, [pc, #216]	; (803b07c <UTIL_SEQ_Run+0xe0>)
  while(((TaskSet & TaskMask & SuperMask) != 0U) && ((EvtSet & EvtWaited)==0U))
 803afa2:	f8df 80dc 	ldr.w	r8, [pc, #220]	; 803b080 <UTIL_SEQ_Run+0xe4>
  super_mask_backup = SuperMask;
 803afa6:	686e      	ldr	r6, [r5, #4]
  SuperMask &= Mask_bm;
 803afa8:	4030      	ands	r0, r6
 803afaa:	6068      	str	r0, [r5, #4]
  while(((TaskSet & TaskMask & SuperMask) != 0U) && ((EvtSet & EvtWaited)==0U))
 803afac:	4644      	mov	r4, r8
      counter++;
 803afae:	2701      	movs	r7, #1
  while(((TaskSet & TaskMask & SuperMask) != 0U) && ((EvtSet & EvtWaited)==0U))
 803afb0:	e9d5 2000 	ldrd	r2, r0, [r5]
 803afb4:	f8d8 3000 	ldr.w	r3, [r8]
 803afb8:	4013      	ands	r3, r2
 803afba:	4203      	tst	r3, r0
 803afbc:	d043      	beq.n	803b046 <UTIL_SEQ_Run+0xaa>
 803afbe:	e9d8 3101 	ldrd	r3, r1, [r8, #4]
 803afc2:	400b      	ands	r3, r1
 803afc4:	d13f      	bne.n	803b046 <UTIL_SEQ_Run+0xaa>
    while((TaskPrio[counter].priority & TaskMask & SuperMask)== 0U)
 803afc6:	4002      	ands	r2, r0
 803afc8:	f8d8 0090 	ldr.w	r0, [r8, #144]	; 0x90
 803afcc:	4010      	ands	r0, r2
 803afce:	d103      	bne.n	803afd8 <UTIL_SEQ_Run+0x3c>
 803afd0:	f8d8 0098 	ldr.w	r0, [r8, #152]	; 0x98
      counter++;
 803afd4:	2301      	movs	r3, #1
    while((TaskPrio[counter].priority & TaskMask & SuperMask)== 0U)
 803afd6:	4010      	ands	r0, r2
    if ((TaskPrio[counter].round_robin & current_task_set) == 0U)
 803afd8:	00d9      	lsls	r1, r3, #3
 803afda:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
    CurrentTaskIdx = (SEQ_BitPosition(current_task_set & TaskPrio[counter].round_robin));
 803afde:	4421      	add	r1, r4
    if ((TaskPrio[counter].round_robin & current_task_set) == 0U)
 803afe0:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 803afe4:	4210      	tst	r0, r2
      TaskPrio[counter].round_robin = UTIL_SEQ_ALL_BIT_SET;
 803afe6:	bf04      	itt	eq
 803afe8:	f04f 32ff 	moveq.w	r2, #4294967295
 803afec:	f8c3 2094 	streq.w	r2, [r3, #148]	; 0x94
    CurrentTaskIdx = (SEQ_BitPosition(current_task_set & TaskPrio[counter].round_robin));
 803aff0:	f8d1 9094 	ldr.w	r9, [r1, #148]	; 0x94
 803aff4:	ea09 0000 	and.w	r0, r9, r0
 803aff8:	f7ff ffb0 	bl	803af5c <SEQ_BitPosition>
 803affc:	60e0      	str	r0, [r4, #12]
    TaskPrio[counter].round_robin &= ~(1U << CurrentTaskIdx);
 803affe:	fa07 f000 	lsl.w	r0, r7, r0
 803b002:	ea29 0000 	bic.w	r0, r9, r0
 803b006:	f8c1 0094 	str.w	r0, [r1, #148]	; 0x94
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803b00a:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803b00e:	b672      	cpsid	i
    TaskSet &= ~(1U << CurrentTaskIdx);
 803b010:	68e3      	ldr	r3, [r4, #12]
 803b012:	6822      	ldr	r2, [r4, #0]
 803b014:	fa07 f303 	lsl.w	r3, r7, r3
 803b018:	ea22 0203 	bic.w	r2, r2, r3
 803b01c:	6022      	str	r2, [r4, #0]
      TaskPrio[counter - 1U].priority &= ~(1U << CurrentTaskIdx);
 803b01e:	f8d4 2098 	ldr.w	r2, [r4, #152]	; 0x98
 803b022:	ea22 0203 	bic.w	r2, r2, r3
 803b026:	f8c4 2098 	str.w	r2, [r4, #152]	; 0x98
 803b02a:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
 803b02e:	ea22 0303 	bic.w	r3, r2, r3
 803b032:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803b036:	f381 8810 	msr	PRIMASK, r1
    TaskCb[CurrentTaskIdx]( );
 803b03a:	68e3      	ldr	r3, [r4, #12]
 803b03c:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 803b040:	691b      	ldr	r3, [r3, #16]
 803b042:	4798      	blx	r3
 803b044:	e7b4      	b.n	803afb0 <UTIL_SEQ_Run+0x14>
  CurrentTaskIdx = UTIL_SEQ_NOTASKRUNNING;
 803b046:	f04f 33ff 	mov.w	r3, #4294967295
 803b04a:	60e3      	str	r3, [r4, #12]
  UTIL_SEQ_PreIdle( );
 803b04c:	f7ff ff84 	bl	803af58 <UTIL_SEQ_PreIdle>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803b050:	f3ef 8710 	mrs	r7, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803b054:	b672      	cpsid	i
  if (!(((TaskSet & TaskMask & SuperMask) != 0U) || ((EvtSet & EvtWaited)!= 0U))) 
 803b056:	682a      	ldr	r2, [r5, #0]
 803b058:	6823      	ldr	r3, [r4, #0]
 803b05a:	4013      	ands	r3, r2
 803b05c:	686a      	ldr	r2, [r5, #4]
 803b05e:	4013      	ands	r3, r2
 803b060:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 803b064:	400a      	ands	r2, r1
 803b066:	4313      	orrs	r3, r2
 803b068:	d101      	bne.n	803b06e <UTIL_SEQ_Run+0xd2>
	UTIL_SEQ_Idle( );
 803b06a:	f7f1 fa6b 	bl	802c544 <UTIL_SEQ_Idle>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803b06e:	f387 8810 	msr	PRIMASK, r7
  UTIL_SEQ_PostIdle( );
 803b072:	f7ff ff72 	bl	803af5a <UTIL_SEQ_PostIdle>
  SuperMask = super_mask_backup;
 803b076:	606e      	str	r6, [r5, #4]
}
 803b078:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 803b07c:	200035a4 	.word	0x200035a4
 803b080:	200060b0 	.word	0x200060b0

0803b084 <UTIL_SEQ_RegTask>:
{
 803b084:	b510      	push	{r4, lr}
 803b086:	4611      	mov	r1, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803b088:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803b08c:	b672      	cpsid	i
  TaskCb[SEQ_BitPosition(TaskId_bm)] = Task;
 803b08e:	f7ff ff65 	bl	803af5c <SEQ_BitPosition>
 803b092:	4b03      	ldr	r3, [pc, #12]	; (803b0a0 <UTIL_SEQ_RegTask+0x1c>)
 803b094:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 803b098:	6119      	str	r1, [r3, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803b09a:	f384 8810 	msr	PRIMASK, r4
}
 803b09e:	bd10      	pop	{r4, pc}
 803b0a0:	200060b0 	.word	0x200060b0

0803b0a4 <SysTimeAdd>:
  * @addtogroup SYSTIME_exported_function
  *  @{
  */

SysTime_t SysTimeAdd( SysTime_t a, SysTime_t b )
{
 803b0a4:	b082      	sub	sp, #8
 803b0a6:	b082      	sub	sp, #8
 803b0a8:	f10d 0c08 	add.w	ip, sp, #8
 803b0ac:	e90c 0006 	stmdb	ip, {r1, r2}
  SysTime_t c =  { .Seconds = 0, .SubSeconds = 0 };

  c.Seconds = a.Seconds + b.Seconds;
 803b0b0:	9a00      	ldr	r2, [sp, #0]
  c.SubSeconds = a.SubSeconds + b.SubSeconds;
 803b0b2:	f8bd 1010 	ldrh.w	r1, [sp, #16]
{
 803b0b6:	9303      	str	r3, [sp, #12]
  c.Seconds = a.Seconds + b.Seconds;
 803b0b8:	4413      	add	r3, r2
  c.SubSeconds = a.SubSeconds + b.SubSeconds;
 803b0ba:	f8bd 2004 	ldrh.w	r2, [sp, #4]
 803b0be:	440a      	add	r2, r1
 803b0c0:	b291      	uxth	r1, r2
 803b0c2:	b212      	sxth	r2, r2
  if( c.SubSeconds >= 1000 )
 803b0c4:	f5b2 7f7a 	cmp.w	r2, #1000	; 0x3e8
  {
    c.Seconds++;
    c.SubSeconds -= 1000;
 803b0c8:	bfa2      	ittt	ge
 803b0ca:	f5a1 727a 	subge.w	r2, r1, #1000	; 0x3e8
    c.Seconds++;
 803b0ce:	3301      	addge	r3, #1
    c.SubSeconds -= 1000;
 803b0d0:	b212      	sxthge	r2, r2
  }
  return c;
 803b0d2:	6003      	str	r3, [r0, #0]
 803b0d4:	8082      	strh	r2, [r0, #4]
}
 803b0d6:	b002      	add	sp, #8
 803b0d8:	b002      	add	sp, #8
 803b0da:	4770      	bx	lr

0803b0dc <SysTimeSub>:

SysTime_t SysTimeSub( SysTime_t a, SysTime_t b )
{
 803b0dc:	b082      	sub	sp, #8
 803b0de:	b082      	sub	sp, #8
 803b0e0:	f10d 0c08 	add.w	ip, sp, #8
 803b0e4:	e90c 0006 	stmdb	ip, {r1, r2}
  SysTime_t c = { .Seconds = 0, .SubSeconds = 0 };

  c.Seconds = a.Seconds - b.Seconds;
 803b0e8:	9a00      	ldr	r2, [sp, #0]
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 803b0ea:	f8bd 1010 	ldrh.w	r1, [sp, #16]
{
 803b0ee:	9303      	str	r3, [sp, #12]
  c.Seconds = a.Seconds - b.Seconds;
 803b0f0:	1ad3      	subs	r3, r2, r3
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 803b0f2:	f8bd 2004 	ldrh.w	r2, [sp, #4]
 803b0f6:	1a52      	subs	r2, r2, r1
 803b0f8:	b291      	uxth	r1, r2
 803b0fa:	b212      	sxth	r2, r2
  if( c.SubSeconds < 0 )
 803b0fc:	2a00      	cmp	r2, #0
  {
    c.Seconds--;
    c.SubSeconds += 1000;
 803b0fe:	bfbe      	ittt	lt
 803b100:	f501 727a 	addlt.w	r2, r1, #1000	; 0x3e8
    c.Seconds--;
 803b104:	f103 33ff 	addlt.w	r3, r3, #4294967295
    c.SubSeconds += 1000;
 803b108:	b212      	sxthlt	r2, r2
  }
  return c;
 803b10a:	6003      	str	r3, [r0, #0]
 803b10c:	8082      	strh	r2, [r0, #4]
}
 803b10e:	b002      	add	sp, #8
 803b110:	b002      	add	sp, #8
 803b112:	4770      	bx	lr

0803b114 <SysTimeSet>:

void SysTimeSet( SysTime_t sysTime )
{
 803b114:	b530      	push	{r4, r5, lr}
 803b116:	b085      	sub	sp, #20
  SysTime_t DeltaTime;
  
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };

  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 803b118:	4d11      	ldr	r5, [pc, #68]	; (803b160 <SysTimeSet+0x4c>)
{
 803b11a:	466b      	mov	r3, sp
 803b11c:	e883 0003 	stmia.w	r3, {r0, r1}
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 803b120:	2300      	movs	r3, #0
 803b122:	9302      	str	r3, [sp, #8]
 803b124:	f8ad 300c 	strh.w	r3, [sp, #12]
  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 803b128:	a803      	add	r0, sp, #12
 803b12a:	692b      	ldr	r3, [r5, #16]
 803b12c:	4798      	blx	r3
  c.Seconds = a.Seconds - b.Seconds;
 803b12e:	9b00      	ldr	r3, [sp, #0]
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 803b130:	f8bd 4004 	ldrh.w	r4, [sp, #4]
  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 803b134:	9002      	str	r0, [sp, #8]
  c.Seconds = a.Seconds - b.Seconds;
 803b136:	1a18      	subs	r0, r3, r0
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 803b138:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 803b13c:	1ae4      	subs	r4, r4, r3
 803b13e:	b2a3      	uxth	r3, r4
 803b140:	b224      	sxth	r4, r4
  if( c.SubSeconds < 0 )
 803b142:	2c00      	cmp	r4, #0
    c.SubSeconds += 1000;
 803b144:	bfbe      	ittt	lt
 803b146:	f503 747a 	addlt.w	r4, r3, #1000	; 0x3e8
    c.Seconds--;
 803b14a:	f100 30ff 	addlt.w	r0, r0, #4294967295
    c.SubSeconds += 1000;
 803b14e:	b224      	sxthlt	r4, r4

  // sysTime is UNIX epoch
  DeltaTime = SysTimeSub( sysTime, calendarTime );

  UTIL_SYSTIMDriver.BKUPWrite_Seconds( DeltaTime.Seconds );
 803b150:	682b      	ldr	r3, [r5, #0]
 803b152:	4798      	blx	r3
  UTIL_SYSTIMDriver.BKUPWrite_SubSeconds( ( uint32_t ) DeltaTime.SubSeconds );
 803b154:	68ab      	ldr	r3, [r5, #8]
 803b156:	4620      	mov	r0, r4
 803b158:	4798      	blx	r3
}
 803b15a:	b005      	add	sp, #20
 803b15c:	bd30      	pop	{r4, r5, pc}
 803b15e:	bf00      	nop
 803b160:	0803b8c8 	.word	0x0803b8c8

0803b164 <SysTimeGet>:

SysTime_t SysTimeGet( void )
{
 803b164:	b573      	push	{r0, r1, r4, r5, r6, lr}
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
  SysTime_t sysTime = { .Seconds = 0, .SubSeconds = 0 };
  SysTime_t DeltaTime;

  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 803b166:	4e11      	ldr	r6, [pc, #68]	; (803b1ac <SysTimeGet+0x48>)
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 803b168:	2300      	movs	r3, #0
{
 803b16a:	4605      	mov	r5, r0
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 803b16c:	9300      	str	r3, [sp, #0]
 803b16e:	f8ad 3004 	strh.w	r3, [sp, #4]
  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 803b172:	a801      	add	r0, sp, #4
 803b174:	6933      	ldr	r3, [r6, #16]
 803b176:	4798      	blx	r3

  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b178:	68f3      	ldr	r3, [r6, #12]
  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 803b17a:	9000      	str	r0, [sp, #0]
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b17c:	4798      	blx	r3
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 803b17e:	6873      	ldr	r3, [r6, #4]
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b180:	4604      	mov	r4, r0
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 803b182:	4798      	blx	r3
  c.Seconds = a.Seconds + b.Seconds;
 803b184:	9b00      	ldr	r3, [sp, #0]
 803b186:	4418      	add	r0, r3
  c.SubSeconds = a.SubSeconds + b.SubSeconds;
 803b188:	f8bd 3004 	ldrh.w	r3, [sp, #4]
 803b18c:	4423      	add	r3, r4
 803b18e:	b29a      	uxth	r2, r3
 803b190:	b21b      	sxth	r3, r3
  if( c.SubSeconds >= 1000 )
 803b192:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
    c.Seconds++;
 803b196:	bfa2      	ittt	ge
 803b198:	3001      	addge	r0, #1
    c.SubSeconds -= 1000;
 803b19a:	f5a2 737a 	subge.w	r3, r2, #1000	; 0x3e8
 803b19e:	b21b      	sxthge	r3, r3

  sysTime = SysTimeAdd( DeltaTime, calendarTime );

  return sysTime;
 803b1a0:	6028      	str	r0, [r5, #0]
}
 803b1a2:	4628      	mov	r0, r5
  return sysTime;
 803b1a4:	80ab      	strh	r3, [r5, #4]
}
 803b1a6:	b002      	add	sp, #8
 803b1a8:	bd70      	pop	{r4, r5, r6, pc}
 803b1aa:	bf00      	nop
 803b1ac:	0803b8c8 	.word	0x0803b8c8

0803b1b0 <SysTimeGetMcuTime>:


SysTime_t SysTimeGetMcuTime( void )
{
 803b1b0:	b537      	push	{r0, r1, r2, r4, r5, lr}
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 803b1b2:	2300      	movs	r3, #0
 803b1b4:	9300      	str	r3, [sp, #0]
 803b1b6:	f8ad 3004 	strh.w	r3, [sp, #4]

  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 803b1ba:	4b07      	ldr	r3, [pc, #28]	; (803b1d8 <SysTimeGetMcuTime+0x28>)
{
 803b1bc:	4604      	mov	r4, r0
  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 803b1be:	691b      	ldr	r3, [r3, #16]
 803b1c0:	a801      	add	r0, sp, #4
 803b1c2:	4798      	blx	r3
 803b1c4:	466d      	mov	r5, sp
 803b1c6:	9000      	str	r0, [sp, #0]
  
  return calendarTime;
 803b1c8:	e895 0003 	ldmia.w	r5, {r0, r1}
 803b1cc:	e884 0003 	stmia.w	r4, {r0, r1}
}
 803b1d0:	4620      	mov	r0, r4
 803b1d2:	b003      	add	sp, #12
 803b1d4:	bd30      	pop	{r4, r5, pc}
 803b1d6:	bf00      	nop
 803b1d8:	0803b8c8 	.word	0x0803b8c8

0803b1dc <SysTimeToMs>:

uint32_t SysTimeToMs( SysTime_t sysTime )
{
 803b1dc:	b537      	push	{r0, r1, r2, r4, r5, lr}
  SysTime_t DeltaTime;
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b1de:	4d0e      	ldr	r5, [pc, #56]	; (803b218 <SysTimeToMs+0x3c>)
{
 803b1e0:	ab02      	add	r3, sp, #8
 803b1e2:	e903 0003 	stmdb	r3, {r0, r1}
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b1e6:	68eb      	ldr	r3, [r5, #12]
 803b1e8:	4798      	blx	r3
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 803b1ea:	686b      	ldr	r3, [r5, #4]
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b1ec:	4604      	mov	r4, r0
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 803b1ee:	4798      	blx	r3
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 803b1f0:	f8bd 3004 	ldrh.w	r3, [sp, #4]
  c.Seconds = a.Seconds - b.Seconds;
 803b1f4:	9a00      	ldr	r2, [sp, #0]
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 803b1f6:	1b1b      	subs	r3, r3, r4
  c.Seconds = a.Seconds - b.Seconds;
 803b1f8:	1a12      	subs	r2, r2, r0
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 803b1fa:	b298      	uxth	r0, r3
 803b1fc:	b21b      	sxth	r3, r3
  if( c.SubSeconds < 0 )
 803b1fe:	2b00      	cmp	r3, #0
    c.SubSeconds += 1000;
 803b200:	bfbe      	ittt	lt
 803b202:	f500 707a 	addlt.w	r0, r0, #1000	; 0x3e8
 803b206:	b203      	sxthlt	r3, r0
    c.Seconds--;
 803b208:	f102 32ff 	addlt.w	r2, r2, #4294967295
  
  SysTime_t calendarTime = SysTimeSub( sysTime, DeltaTime );
  return calendarTime.Seconds * 1000 + calendarTime.SubSeconds;
}
 803b20c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 803b210:	fb00 3002 	mla	r0, r0, r2, r3
 803b214:	b003      	add	sp, #12
 803b216:	bd30      	pop	{r4, r5, pc}
 803b218:	0803b8c8 	.word	0x0803b8c8

0803b21c <SysTimeFromMs>:

SysTime_t SysTimeFromMs( uint32_t timeMs )
{
 803b21c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t seconds = timeMs / 1000;
 803b220:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 803b224:	fbb1 f5f5 	udiv	r5, r1, r5
  SysTime_t sysTime = { .Seconds = seconds, .SubSeconds =  timeMs - seconds * 1000 };
 803b228:	ebc5 1345 	rsb	r3, r5, r5, lsl #5
  SysTime_t DeltaTime = { 0 };

  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b22c:	f8df 803c 	ldr.w	r8, [pc, #60]	; 803b26c <SysTimeFromMs+0x50>
  SysTime_t sysTime = { .Seconds = seconds, .SubSeconds =  timeMs - seconds * 1000 };
 803b230:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 803b234:	eba1 03c3 	sub.w	r3, r1, r3, lsl #3
 803b238:	b29c      	uxth	r4, r3
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b23a:	f8d8 300c 	ldr.w	r3, [r8, #12]
{
 803b23e:	4606      	mov	r6, r0
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b240:	4798      	blx	r3
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 803b242:	f8d8 3004 	ldr.w	r3, [r8, #4]
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b246:	4607      	mov	r7, r0
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 803b248:	4798      	blx	r3
  c.SubSeconds = a.SubSeconds + b.SubSeconds;
 803b24a:	19e3      	adds	r3, r4, r7
 803b24c:	b29a      	uxth	r2, r3
 803b24e:	b21b      	sxth	r3, r3
  if( c.SubSeconds >= 1000 )
 803b250:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
  c.Seconds = a.Seconds + b.Seconds;
 803b254:	4405      	add	r5, r0
    c.SubSeconds -= 1000;
 803b256:	bfa2      	ittt	ge
 803b258:	f5a2 737a 	subge.w	r3, r2, #1000	; 0x3e8
    c.Seconds++;
 803b25c:	3501      	addge	r5, #1
    c.SubSeconds -= 1000;
 803b25e:	b21b      	sxthge	r3, r3
  return c;
 803b260:	6035      	str	r5, [r6, #0]
 803b262:	80b3      	strh	r3, [r6, #4]
  return SysTimeAdd( sysTime, DeltaTime );
}
 803b264:	4630      	mov	r0, r6
 803b266:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 803b26a:	bf00      	nop
 803b26c:	0803b8c8 	.word	0x0803b8c8

0803b270 <UTIL_TIMER_Init>:
  */

UTIL_TIMER_Status_t UTIL_TIMER_Init(void)
{
  UTIL_TIMER_INIT_CRITICAL_SECTION();
  TimerListHead = NULL;
 803b270:	4b02      	ldr	r3, [pc, #8]	; (803b27c <UTIL_TIMER_Init+0xc>)
 803b272:	2200      	movs	r2, #0
 803b274:	601a      	str	r2, [r3, #0]
  return UTIL_TimerDriver.InitTimer();
 803b276:	4b02      	ldr	r3, [pc, #8]	; (803b280 <UTIL_TIMER_Init+0x10>)
 803b278:	681b      	ldr	r3, [r3, #0]
 803b27a:	4718      	bx	r3
 803b27c:	20006150 	.word	0x20006150
 803b280:	0803b8dc 	.word	0x0803b8dc

0803b284 <UTIL_TIMER_Create>:
{
  return UTIL_TimerDriver.DeInitTimer();
}

UTIL_TIMER_Status_t UTIL_TIMER_Create( UTIL_TIMER_Object_t *TimerObject, uint32_t PeriodValue, UTIL_TIMER_Mode_t Mode, void ( *Callback )( void *), void *Argument)
{
 803b284:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 803b286:	4604      	mov	r4, r0
 803b288:	4617      	mov	r7, r2
 803b28a:	4608      	mov	r0, r1
 803b28c:	461e      	mov	r6, r3
  if((TimerObject != NULL) && (Callback != NULL))
 803b28e:	b17c      	cbz	r4, 803b2b0 <UTIL_TIMER_Create+0x2c>
 803b290:	b173      	cbz	r3, 803b2b0 <UTIL_TIMER_Create+0x2c>
  {
    TimerObject->Timestamp = 0U;
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(PeriodValue);
 803b292:	4b08      	ldr	r3, [pc, #32]	; (803b2b4 <UTIL_TIMER_Create+0x30>)
    TimerObject->Timestamp = 0U;
 803b294:	2500      	movs	r5, #0
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(PeriodValue);
 803b296:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    TimerObject->Timestamp = 0U;
 803b298:	6025      	str	r5, [r4, #0]
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(PeriodValue);
 803b29a:	4798      	blx	r3
    TimerObject->IsPending = 0U;
    TimerObject->IsRunning = 0U;
    TimerObject->IsReloadStopped = 0U;
    TimerObject->Callback = Callback;
    TimerObject->argument = Argument;
 803b29c:	9b06      	ldr	r3, [sp, #24]
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(PeriodValue);
 803b29e:	6060      	str	r0, [r4, #4]
    TimerObject->IsPending = 0U;
 803b2a0:	8125      	strh	r5, [r4, #8]
    TimerObject->IsReloadStopped = 0U;
 803b2a2:	72a5      	strb	r5, [r4, #10]
    TimerObject->Callback = Callback;
 803b2a4:	60e6      	str	r6, [r4, #12]
    TimerObject->argument = Argument;
 803b2a6:	6123      	str	r3, [r4, #16]
    TimerObject->Mode = Mode;
 803b2a8:	72e7      	strb	r7, [r4, #11]
    TimerObject->Next = NULL;
 803b2aa:	6165      	str	r5, [r4, #20]
    return UTIL_TIMER_OK;
 803b2ac:	4628      	mov	r0, r5
  }
  else
  {
    return UTIL_TIMER_INVALID_PARAM;
  }
}
 803b2ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return UTIL_TIMER_INVALID_PARAM;
 803b2b0:	2001      	movs	r0, #1
 803b2b2:	e7fc      	b.n	803b2ae <UTIL_TIMER_Create+0x2a>
 803b2b4:	0803b8dc 	.word	0x0803b8dc

0803b2b8 <UTIL_TIMER_GetCurrentTime>:
  }
  UTIL_TIMER_EXIT_CRITICAL_SECTION();
}

UTIL_TIMER_Time_t UTIL_TIMER_GetCurrentTime(void)
{
 803b2b8:	b510      	push	{r4, lr}
  uint32_t now = UTIL_TimerDriver.GetTimerValue( );
 803b2ba:	4c03      	ldr	r4, [pc, #12]	; (803b2c8 <UTIL_TIMER_GetCurrentTime+0x10>)
 803b2bc:	69e3      	ldr	r3, [r4, #28]
 803b2be:	4798      	blx	r3
  return  UTIL_TimerDriver.Tick2ms(now);
 803b2c0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
}
 803b2c2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return  UTIL_TimerDriver.Tick2ms(now);
 803b2c6:	4718      	bx	r3
 803b2c8:	0803b8dc 	.word	0x0803b8dc

0803b2cc <UTIL_TIMER_GetElapsedTime>:

UTIL_TIMER_Time_t UTIL_TIMER_GetElapsedTime(UTIL_TIMER_Time_t past )
{
 803b2cc:	b570      	push	{r4, r5, r6, lr}
  uint32_t nowInTicks = UTIL_TimerDriver.GetTimerValue( );
 803b2ce:	4d06      	ldr	r5, [pc, #24]	; (803b2e8 <UTIL_TIMER_GetElapsedTime+0x1c>)
 803b2d0:	69eb      	ldr	r3, [r5, #28]
{
 803b2d2:	4606      	mov	r6, r0
  uint32_t nowInTicks = UTIL_TimerDriver.GetTimerValue( );
 803b2d4:	4798      	blx	r3
  uint32_t pastInTicks = UTIL_TimerDriver.ms2Tick( past );
 803b2d6:	6a6b      	ldr	r3, [r5, #36]	; 0x24
  uint32_t nowInTicks = UTIL_TimerDriver.GetTimerValue( );
 803b2d8:	4604      	mov	r4, r0
  uint32_t pastInTicks = UTIL_TimerDriver.ms2Tick( past );
 803b2da:	4630      	mov	r0, r6
 803b2dc:	4798      	blx	r3
  /* intentional wrap around. Works Ok if tick duation below 1ms */
  return UTIL_TimerDriver.Tick2ms( nowInTicks- pastInTicks );
 803b2de:	6aab      	ldr	r3, [r5, #40]	; 0x28
 803b2e0:	1a20      	subs	r0, r4, r0
}
 803b2e2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  return UTIL_TimerDriver.Tick2ms( nowInTicks- pastInTicks );
 803b2e6:	4718      	bx	r3
 803b2e8:	0803b8dc 	.word	0x0803b8dc

0803b2ec <TimerExists>:
 * @param TimerObject Structure containing the timer object parameters
 * @retval 1 (the object is already in the list) or 0
 */
bool TimerExists( UTIL_TIMER_Object_t *TimerObject )
{
  UTIL_TIMER_Object_t* cur = TimerListHead;
 803b2ec:	4a05      	ldr	r2, [pc, #20]	; (803b304 <TimerExists+0x18>)
{
 803b2ee:	4603      	mov	r3, r0
  UTIL_TIMER_Object_t* cur = TimerListHead;
 803b2f0:	6810      	ldr	r0, [r2, #0]

  while( cur != NULL )
 803b2f2:	b900      	cbnz	r0, 803b2f6 <TimerExists+0xa>
 803b2f4:	4770      	bx	lr
  {
    if( cur == TimerObject )
 803b2f6:	4298      	cmp	r0, r3
 803b2f8:	d001      	beq.n	803b2fe <TimerExists+0x12>
    {
      return true;
    }
    cur = cur->Next;
 803b2fa:	6940      	ldr	r0, [r0, #20]
 803b2fc:	e7f9      	b.n	803b2f2 <TimerExists+0x6>
      return true;
 803b2fe:	2001      	movs	r0, #1
  }
  return false;
}
 803b300:	4770      	bx	lr
 803b302:	bf00      	nop
 803b304:	20006150 	.word	0x20006150

0803b308 <TimerSetTimeout>:
 * @brief Sets a timeout with the duration "timestamp"
 *
 * @param TimerObject Structure containing the timer object parameters
 */
void TimerSetTimeout( UTIL_TIMER_Object_t *TimerObject )
{
 803b308:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  uint32_t minTicks= UTIL_TimerDriver.GetMinimumTimeout( );
 803b30c:	4d0b      	ldr	r5, [pc, #44]	; (803b33c <TimerSetTimeout+0x34>)
 803b30e:	6a2b      	ldr	r3, [r5, #32]
{
 803b310:	4604      	mov	r4, r0
  uint32_t minTicks= UTIL_TimerDriver.GetMinimumTimeout( );
 803b312:	4798      	blx	r3
  TimerObject->IsPending = 1;
 803b314:	2301      	movs	r3, #1

  /* In case deadline too soon */
  if(TimerObject->Timestamp  < (UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks) )
 803b316:	69af      	ldr	r7, [r5, #24]
  TimerObject->IsPending = 1;
 803b318:	7223      	strb	r3, [r4, #8]
  if(TimerObject->Timestamp  < (UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks) )
 803b31a:	f8d4 8000 	ldr.w	r8, [r4]
  uint32_t minTicks= UTIL_TimerDriver.GetMinimumTimeout( );
 803b31e:	4606      	mov	r6, r0
  if(TimerObject->Timestamp  < (UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks) )
 803b320:	47b8      	blx	r7
 803b322:	4430      	add	r0, r6
 803b324:	4580      	cmp	r8, r0
 803b326:	d202      	bcs.n	803b32e <TimerSetTimeout+0x26>
  {
	  TimerObject->Timestamp = UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks;
 803b328:	47b8      	blx	r7
 803b32a:	4406      	add	r6, r0
 803b32c:	6026      	str	r6, [r4, #0]
  }
  UTIL_TimerDriver.StartTimerEvt( TimerObject->Timestamp );
 803b32e:	68ab      	ldr	r3, [r5, #8]
 803b330:	6820      	ldr	r0, [r4, #0]
 803b332:	9301      	str	r3, [sp, #4]
}
 803b334:	b002      	add	sp, #8
 803b336:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  UTIL_TimerDriver.StartTimerEvt( TimerObject->Timestamp );
 803b33a:	4718      	bx	r3
 803b33c:	0803b8dc 	.word	0x0803b8dc

0803b340 <UTIL_TIMER_Stop>:
{
 803b340:	b570      	push	{r4, r5, r6, lr}
  if (NULL != TimerObject)
 803b342:	b320      	cbz	r0, 803b38e <UTIL_TIMER_Stop+0x4e>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803b344:	f3ef 8610 	mrs	r6, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803b348:	b672      	cpsid	i
    UTIL_TIMER_Object_t* prev = TimerListHead;
 803b34a:	4d12      	ldr	r5, [pc, #72]	; (803b394 <UTIL_TIMER_Stop+0x54>)
 803b34c:	682b      	ldr	r3, [r5, #0]
    TimerObject->IsReloadStopped = 1U;
 803b34e:	2201      	movs	r2, #1
 803b350:	7282      	strb	r2, [r0, #10]
    if(NULL != TimerListHead)
 803b352:	b153      	cbz	r3, 803b36a <UTIL_TIMER_Stop+0x2a>
      TimerObject->IsRunning = 0U;
 803b354:	2200      	movs	r2, #0
      if( TimerListHead == TimerObject ) /* Stop the Head */
 803b356:	4298      	cmp	r0, r3
      TimerObject->IsRunning = 0U;
 803b358:	7242      	strb	r2, [r0, #9]
      if( TimerListHead == TimerObject ) /* Stop the Head */
 803b35a:	d10f      	bne.n	803b37c <UTIL_TIMER_Stop+0x3c>
 803b35c:	6944      	ldr	r4, [r0, #20]
          TimerListHead->IsPending = 0;
 803b35e:	7202      	strb	r2, [r0, #8]
          if( TimerListHead->Next != NULL )
 803b360:	b13c      	cbz	r4, 803b372 <UTIL_TIMER_Stop+0x32>
            TimerSetTimeout( TimerListHead );
 803b362:	4620      	mov	r0, r4
            TimerListHead = TimerListHead->Next;
 803b364:	602c      	str	r4, [r5, #0]
            TimerSetTimeout( TimerListHead );
 803b366:	f7ff ffcf 	bl	803b308 <TimerSetTimeout>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803b36a:	f386 8810 	msr	PRIMASK, r6
}
 803b36e:	2000      	movs	r0, #0
}
 803b370:	bd70      	pop	{r4, r5, r6, pc}
            UTIL_TimerDriver.StopTimerEvt( );
 803b372:	4b09      	ldr	r3, [pc, #36]	; (803b398 <UTIL_TIMER_Stop+0x58>)
 803b374:	68db      	ldr	r3, [r3, #12]
 803b376:	4798      	blx	r3
            TimerListHead = NULL;
 803b378:	602c      	str	r4, [r5, #0]
 803b37a:	e7f6      	b.n	803b36a <UTIL_TIMER_Stop+0x2a>
            cur = cur->Next;
 803b37c:	461a      	mov	r2, r3
 803b37e:	695b      	ldr	r3, [r3, #20]
        while( cur != NULL )
 803b380:	2b00      	cmp	r3, #0
 803b382:	d0f2      	beq.n	803b36a <UTIL_TIMER_Stop+0x2a>
          if( cur == TimerObject )
 803b384:	4298      	cmp	r0, r3
 803b386:	d1f9      	bne.n	803b37c <UTIL_TIMER_Stop+0x3c>
            if( cur->Next != NULL )
 803b388:	6943      	ldr	r3, [r0, #20]
              prev->Next = cur;
 803b38a:	6153      	str	r3, [r2, #20]
 803b38c:	e7ed      	b.n	803b36a <UTIL_TIMER_Stop+0x2a>
    ret = UTIL_TIMER_INVALID_PARAM;
 803b38e:	2001      	movs	r0, #1
 803b390:	e7ee      	b.n	803b370 <UTIL_TIMER_Stop+0x30>
 803b392:	bf00      	nop
 803b394:	20006150 	.word	0x20006150
 803b398:	0803b8dc 	.word	0x0803b8dc

0803b39c <TimerInsertTimer>:
 *
 * @param TimerObject Structure containing the timer object parameters
 */
void TimerInsertTimer( UTIL_TIMER_Object_t *TimerObject)
{
  UTIL_TIMER_Object_t* cur = TimerListHead;
 803b39c:	4b09      	ldr	r3, [pc, #36]	; (803b3c4 <TimerInsertTimer+0x28>)
{
 803b39e:	b510      	push	{r4, lr}
  UTIL_TIMER_Object_t* cur = TimerListHead;
 803b3a0:	681b      	ldr	r3, [r3, #0]
  UTIL_TIMER_Object_t* next = TimerListHead->Next;
 803b3a2:	695a      	ldr	r2, [r3, #20]

  while (cur->Next != NULL )
 803b3a4:	6959      	ldr	r1, [r3, #20]
 803b3a6:	b911      	cbnz	r1, 803b3ae <TimerInsertTimer+0x12>
        TimerObject->Next = next;
        return;

    }
  }
  cur->Next = TimerObject;
 803b3a8:	6158      	str	r0, [r3, #20]
  TimerObject->Next = NULL;
 803b3aa:	6141      	str	r1, [r0, #20]
 803b3ac:	e008      	b.n	803b3c0 <TimerInsertTimer+0x24>
    if( TimerObject->Timestamp  > next->Timestamp )
 803b3ae:	6804      	ldr	r4, [r0, #0]
 803b3b0:	6811      	ldr	r1, [r2, #0]
 803b3b2:	428c      	cmp	r4, r1
 803b3b4:	d902      	bls.n	803b3bc <TimerInsertTimer+0x20>
        next = next->Next;
 803b3b6:	4613      	mov	r3, r2
 803b3b8:	6952      	ldr	r2, [r2, #20]
 803b3ba:	e7f3      	b.n	803b3a4 <TimerInsertTimer+0x8>
        cur->Next = TimerObject;
 803b3bc:	6158      	str	r0, [r3, #20]
        TimerObject->Next = next;
 803b3be:	6142      	str	r2, [r0, #20]
}
 803b3c0:	bd10      	pop	{r4, pc}
 803b3c2:	bf00      	nop
 803b3c4:	20006150 	.word	0x20006150

0803b3c8 <TimerInsertNewHeadTimer>:
 * @remark The list is automatically sorted. The list head always contains the
 *         next timer to expire.
 */
void TimerInsertNewHeadTimer( UTIL_TIMER_Object_t *TimerObject )
{
  UTIL_TIMER_Object_t* cur = TimerListHead;
 803b3c8:	4b04      	ldr	r3, [pc, #16]	; (803b3dc <TimerInsertNewHeadTimer+0x14>)
 803b3ca:	681a      	ldr	r2, [r3, #0]

  if( cur != NULL )
 803b3cc:	b10a      	cbz	r2, 803b3d2 <TimerInsertNewHeadTimer+0xa>
  {
    cur->IsPending = 0;
 803b3ce:	2100      	movs	r1, #0
 803b3d0:	7211      	strb	r1, [r2, #8]
  }

  TimerObject->Next = cur;
 803b3d2:	6142      	str	r2, [r0, #20]
  TimerListHead = TimerObject;
 803b3d4:	6018      	str	r0, [r3, #0]
  TimerSetTimeout( TimerListHead );
 803b3d6:	f7ff bf97 	b.w	803b308 <TimerSetTimeout>
 803b3da:	bf00      	nop
 803b3dc:	20006150 	.word	0x20006150

0803b3e0 <UTIL_TIMER_Start>:
{
 803b3e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if(( TimerObject != NULL ) && ( TimerExists( TimerObject ) == false ) && (TimerObject->IsRunning == 0U))
 803b3e4:	4604      	mov	r4, r0
 803b3e6:	2800      	cmp	r0, #0
 803b3e8:	d02d      	beq.n	803b446 <UTIL_TIMER_Start+0x66>
 803b3ea:	f7ff ff7f 	bl	803b2ec <TimerExists>
 803b3ee:	bb50      	cbnz	r0, 803b446 <UTIL_TIMER_Start+0x66>
 803b3f0:	7a65      	ldrb	r5, [r4, #9]
 803b3f2:	bb45      	cbnz	r5, 803b446 <UTIL_TIMER_Start+0x66>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803b3f4:	f3ef 8810 	mrs	r8, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803b3f8:	b672      	cpsid	i
    minValue = UTIL_TimerDriver.GetMinimumTimeout( );
 803b3fa:	4e14      	ldr	r6, [pc, #80]	; (803b44c <UTIL_TIMER_Start+0x6c>)
    ticks = TimerObject->ReloadValue;
 803b3fc:	6867      	ldr	r7, [r4, #4]
    minValue = UTIL_TimerDriver.GetMinimumTimeout( );
 803b3fe:	6a33      	ldr	r3, [r6, #32]
 803b400:	4798      	blx	r3
    TimerObject->Timestamp = ticks;
 803b402:	4287      	cmp	r7, r0
 803b404:	bf2c      	ite	cs
 803b406:	6027      	strcs	r7, [r4, #0]
 803b408:	6020      	strcc	r0, [r4, #0]
    if( TimerListHead == NULL )
 803b40a:	4f11      	ldr	r7, [pc, #68]	; (803b450 <UTIL_TIMER_Start+0x70>)
    TimerObject->IsReloadStopped = 0U;
 803b40c:	72a5      	strb	r5, [r4, #10]
    TimerObject->IsPending = 0U;
 803b40e:	f44f 7380 	mov.w	r3, #256	; 0x100
 803b412:	8123      	strh	r3, [r4, #8]
    if( TimerListHead == NULL )
 803b414:	683b      	ldr	r3, [r7, #0]
 803b416:	b94b      	cbnz	r3, 803b42c <UTIL_TIMER_Start+0x4c>
      UTIL_TimerDriver.SetTimerContext();
 803b418:	6933      	ldr	r3, [r6, #16]
 803b41a:	4798      	blx	r3
      TimerInsertNewHeadTimer( TimerObject ); /* insert a timeout at now+obj->Timestamp */
 803b41c:	4620      	mov	r0, r4
        TimerInsertNewHeadTimer( TimerObject);
 803b41e:	f7ff ffd3 	bl	803b3c8 <TimerInsertNewHeadTimer>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803b422:	f388 8810 	msr	PRIMASK, r8
}
 803b426:	4628      	mov	r0, r5
 803b428:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      elapsedTime = UTIL_TimerDriver.GetTimerElapsedTime( );
 803b42c:	69b3      	ldr	r3, [r6, #24]
 803b42e:	4798      	blx	r3
      TimerObject->Timestamp += elapsedTime;
 803b430:	6823      	ldr	r3, [r4, #0]
 803b432:	4418      	add	r0, r3
      if( TimerObject->Timestamp < TimerListHead->Timestamp )
 803b434:	683b      	ldr	r3, [r7, #0]
      TimerObject->Timestamp += elapsedTime;
 803b436:	6020      	str	r0, [r4, #0]
      if( TimerObject->Timestamp < TimerListHead->Timestamp )
 803b438:	681b      	ldr	r3, [r3, #0]
 803b43a:	4298      	cmp	r0, r3
        TimerInsertNewHeadTimer( TimerObject);
 803b43c:	4620      	mov	r0, r4
      if( TimerObject->Timestamp < TimerListHead->Timestamp )
 803b43e:	d3ee      	bcc.n	803b41e <UTIL_TIMER_Start+0x3e>
        TimerInsertTimer( TimerObject);
 803b440:	f7ff ffac 	bl	803b39c <TimerInsertTimer>
 803b444:	e7ed      	b.n	803b422 <UTIL_TIMER_Start+0x42>
    ret =  UTIL_TIMER_INVALID_PARAM;
 803b446:	2501      	movs	r5, #1
 803b448:	e7ed      	b.n	803b426 <UTIL_TIMER_Start+0x46>
 803b44a:	bf00      	nop
 803b44c:	0803b8dc 	.word	0x0803b8dc
 803b450:	20006150 	.word	0x20006150

0803b454 <UTIL_TIMER_SetPeriod>:
{
 803b454:	b510      	push	{r4, lr}
 803b456:	4604      	mov	r4, r0
 803b458:	4608      	mov	r0, r1
  if(NULL == TimerObject)
 803b45a:	b17c      	cbz	r4, 803b47c <UTIL_TIMER_SetPeriod+0x28>
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(NewPeriodValue);
 803b45c:	4b08      	ldr	r3, [pc, #32]	; (803b480 <UTIL_TIMER_SetPeriod+0x2c>)
 803b45e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 803b460:	4798      	blx	r3
 803b462:	6060      	str	r0, [r4, #4]
    if(TimerExists(TimerObject))
 803b464:	4620      	mov	r0, r4
 803b466:	f7ff ff41 	bl	803b2ec <TimerExists>
 803b46a:	b140      	cbz	r0, 803b47e <UTIL_TIMER_SetPeriod+0x2a>
      (void)UTIL_TIMER_Stop(TimerObject);
 803b46c:	4620      	mov	r0, r4
 803b46e:	f7ff ff67 	bl	803b340 <UTIL_TIMER_Stop>
      ret = UTIL_TIMER_Start(TimerObject);
 803b472:	4620      	mov	r0, r4
}
 803b474:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      ret = UTIL_TIMER_Start(TimerObject);
 803b478:	f7ff bfb2 	b.w	803b3e0 <UTIL_TIMER_Start>
	  ret = UTIL_TIMER_INVALID_PARAM;
 803b47c:	2001      	movs	r0, #1
}
 803b47e:	bd10      	pop	{r4, pc}
 803b480:	0803b8dc 	.word	0x0803b8dc

0803b484 <UTIL_TIMER_IRQ_Handler>:
{
 803b484:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803b488:	f3ef 8710 	mrs	r7, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803b48c:	b672      	cpsid	i
  old  =  UTIL_TimerDriver.GetTimerContext( );
 803b48e:	4e1d      	ldr	r6, [pc, #116]	; (803b504 <UTIL_TIMER_IRQ_Handler+0x80>)
  if ( TimerListHead != NULL )
 803b490:	4c1d      	ldr	r4, [pc, #116]	; (803b508 <UTIL_TIMER_IRQ_Handler+0x84>)
  old  =  UTIL_TimerDriver.GetTimerContext( );
 803b492:	6973      	ldr	r3, [r6, #20]
 803b494:	4798      	blx	r3
  now  =  UTIL_TimerDriver.SetTimerContext( );
 803b496:	6933      	ldr	r3, [r6, #16]
  old  =  UTIL_TimerDriver.GetTimerContext( );
 803b498:	4605      	mov	r5, r0
  now  =  UTIL_TimerDriver.SetTimerContext( );
 803b49a:	4798      	blx	r3
  if ( TimerListHead != NULL )
 803b49c:	6823      	ldr	r3, [r4, #0]
 803b49e:	b94b      	cbnz	r3, 803b4b4 <UTIL_TIMER_IRQ_Handler+0x30>
      cur->IsPending = 0;
 803b4a0:	f04f 0800 	mov.w	r8, #0
  while ((TimerListHead != NULL) && ((TimerListHead->Timestamp == 0U) || (TimerListHead->Timestamp < UTIL_TimerDriver.GetTimerElapsedTime(  ))))
 803b4a4:	6823      	ldr	r3, [r4, #0]
 803b4a6:	b98b      	cbnz	r3, 803b4cc <UTIL_TIMER_IRQ_Handler+0x48>
  if(( TimerListHead != NULL ) && (TimerListHead->IsPending == 0U))
 803b4a8:	6820      	ldr	r0, [r4, #0]
 803b4aa:	bb28      	cbnz	r0, 803b4f8 <UTIL_TIMER_IRQ_Handler+0x74>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803b4ac:	f387 8810 	msr	PRIMASK, r7
}
 803b4b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  DeltaContext = now  - old; /*intentional wrap around */
 803b4b4:	1b41      	subs	r1, r0, r5
        cur->Timestamp -= DeltaContext;
 803b4b6:	1a2d      	subs	r5, r5, r0
      if (cur->Timestamp > DeltaContext)
 803b4b8:	681a      	ldr	r2, [r3, #0]
 803b4ba:	428a      	cmp	r2, r1
        cur->Timestamp -= DeltaContext;
 803b4bc:	bf8c      	ite	hi
 803b4be:	1952      	addhi	r2, r2, r5
        cur->Timestamp = 0;
 803b4c0:	2200      	movls	r2, #0
 803b4c2:	601a      	str	r2, [r3, #0]
      cur = cur->Next;
 803b4c4:	695b      	ldr	r3, [r3, #20]
    } while(cur != NULL);
 803b4c6:	2b00      	cmp	r3, #0
 803b4c8:	d1f6      	bne.n	803b4b8 <UTIL_TIMER_IRQ_Handler+0x34>
 803b4ca:	e7e9      	b.n	803b4a0 <UTIL_TIMER_IRQ_Handler+0x1c>
  while ((TimerListHead != NULL) && ((TimerListHead->Timestamp == 0U) || (TimerListHead->Timestamp < UTIL_TimerDriver.GetTimerElapsedTime(  ))))
 803b4cc:	681d      	ldr	r5, [r3, #0]
 803b4ce:	b11d      	cbz	r5, 803b4d8 <UTIL_TIMER_IRQ_Handler+0x54>
 803b4d0:	69b3      	ldr	r3, [r6, #24]
 803b4d2:	4798      	blx	r3
 803b4d4:	4285      	cmp	r5, r0
 803b4d6:	d2e7      	bcs.n	803b4a8 <UTIL_TIMER_IRQ_Handler+0x24>
      cur = TimerListHead;
 803b4d8:	6825      	ldr	r5, [r4, #0]
      TimerListHead = TimerListHead->Next;
 803b4da:	696b      	ldr	r3, [r5, #20]
 803b4dc:	6023      	str	r3, [r4, #0]
      cur->IsPending = 0;
 803b4de:	f8a5 8008 	strh.w	r8, [r5, #8]
      cur->Callback(cur->argument);
 803b4e2:	e9d5 3003 	ldrd	r3, r0, [r5, #12]
 803b4e6:	4798      	blx	r3
      if(( cur->Mode == UTIL_TIMER_PERIODIC) && (cur->IsReloadStopped == 0U))
 803b4e8:	896b      	ldrh	r3, [r5, #10]
 803b4ea:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 803b4ee:	d1d9      	bne.n	803b4a4 <UTIL_TIMER_IRQ_Handler+0x20>
        (void)UTIL_TIMER_Start(cur);
 803b4f0:	4628      	mov	r0, r5
 803b4f2:	f7ff ff75 	bl	803b3e0 <UTIL_TIMER_Start>
 803b4f6:	e7d5      	b.n	803b4a4 <UTIL_TIMER_IRQ_Handler+0x20>
  if(( TimerListHead != NULL ) && (TimerListHead->IsPending == 0U))
 803b4f8:	7a03      	ldrb	r3, [r0, #8]
 803b4fa:	2b00      	cmp	r3, #0
 803b4fc:	d1d6      	bne.n	803b4ac <UTIL_TIMER_IRQ_Handler+0x28>
    TimerSetTimeout( TimerListHead );
 803b4fe:	f7ff ff03 	bl	803b308 <TimerSetTimeout>
 803b502:	e7d3      	b.n	803b4ac <UTIL_TIMER_IRQ_Handler+0x28>
 803b504:	0803b8dc 	.word	0x0803b8dc
 803b508:	20006150 	.word	0x20006150

0803b50c <tiny_vsnprintf_like>:

#define CHECK_STR_SIZE(_buf, _str, _size) \
  if ((((_str) - (_buf)) >= ((_size)-1))) { break; }

int tiny_vsnprintf_like(char *buf, const int size, const char *fmt, va_list args)
{
 803b50c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 803b510:	b099      	sub	sp, #100	; 0x64

  int field_width;      // Width of output field
  int precision;        // Min. # of digits for integers; max number of chars for from string
  int qualifier;        // 'h', 'l', or 'L' for integer fields

  if (size <= 0)
 803b512:	2900      	cmp	r1, #0
{
 803b514:	4683      	mov	fp, r0
  if (size <= 0)
 803b516:	9105      	str	r1, [sp, #20]
 803b518:	f340 8109 	ble.w	803b72e <tiny_vsnprintf_like+0x222>
  {
    return 0;
  }
  
  for (str = buf; *fmt || ((str - buf) >= size-1); fmt++)
 803b51c:	4604      	mov	r4, r0
  if (!(type & (ZEROPAD /* TINY option   | LEFT */))) while (size-- > 0) ASSIGN_STR(' ');
 803b51e:	f04f 0920 	mov.w	r9, #32
  for (str = buf; *fmt || ((str - buf) >= size-1); fmt++)
 803b522:	9905      	ldr	r1, [sp, #20]
 803b524:	7815      	ldrb	r5, [r2, #0]
 803b526:	eba4 000b 	sub.w	r0, r4, fp
 803b52a:	3901      	subs	r1, #1
 803b52c:	b925      	cbnz	r5, 803b538 <tiny_vsnprintf_like+0x2c>
      num = va_arg(args, unsigned int);

    str = ee_number(str, ((size - 1) - (str - buf)), num, base, field_width, precision, flags);
  }

  *str = '\0';
 803b52e:	2300      	movs	r3, #0
 803b530:	7023      	strb	r3, [r4, #0]
  return str - buf;
}
 803b532:	b019      	add	sp, #100	; 0x64
 803b534:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    CHECK_STR_SIZE(buf, str, size);
 803b538:	4288      	cmp	r0, r1
 803b53a:	daf8      	bge.n	803b52e <tiny_vsnprintf_like+0x22>
    if (*fmt != '%')
 803b53c:	2d25      	cmp	r5, #37	; 0x25
 803b53e:	d004      	beq.n	803b54a <tiny_vsnprintf_like+0x3e>
      *str++ = *fmt;
 803b540:	f804 5b01 	strb.w	r5, [r4], #1
      continue;
 803b544:	4616      	mov	r6, r2
  for (str = buf; *fmt || ((str - buf) >= size-1); fmt++)
 803b546:	1c72      	adds	r2, r6, #1
 803b548:	e7eb      	b.n	803b522 <tiny_vsnprintf_like+0x16>
    if (*fmt == '0')
 803b54a:	f892 e001 	ldrb.w	lr, [r2, #1]
 803b54e:	1c56      	adds	r6, r2, #1
 803b550:	f1ae 0230 	sub.w	r2, lr, #48	; 0x30
 803b554:	4250      	negs	r0, r2
 803b556:	4150      	adcs	r0, r2
    if (is_digit(*fmt))
 803b558:	f1ae 0230 	sub.w	r2, lr, #48	; 0x30
 803b55c:	2a09      	cmp	r2, #9
 803b55e:	d828      	bhi.n	803b5b2 <tiny_vsnprintf_like+0xa6>
 803b560:	4637      	mov	r7, r6
  int i = 0;
 803b562:	2500      	movs	r5, #0
 803b564:	463e      	mov	r6, r7
  while (is_digit(**s)) i = i*10 + *((*s)++) - '0';
 803b566:	f817 2b01 	ldrb.w	r2, [r7], #1
 803b56a:	f1a2 0c30 	sub.w	ip, r2, #48	; 0x30
 803b56e:	f1bc 0f09 	cmp.w	ip, #9
 803b572:	d919      	bls.n	803b5a8 <tiny_vsnprintf_like+0x9c>
    switch (*fmt)
 803b574:	7832      	ldrb	r2, [r6, #0]
 803b576:	2a69      	cmp	r2, #105	; 0x69
 803b578:	f000 8097 	beq.w	803b6aa <tiny_vsnprintf_like+0x19e>
 803b57c:	d81c      	bhi.n	803b5b8 <tiny_vsnprintf_like+0xac>
 803b57e:	2a63      	cmp	r2, #99	; 0x63
 803b580:	d028      	beq.n	803b5d4 <tiny_vsnprintf_like+0xc8>
 803b582:	2a64      	cmp	r2, #100	; 0x64
 803b584:	f000 8091 	beq.w	803b6aa <tiny_vsnprintf_like+0x19e>
 803b588:	2a58      	cmp	r2, #88	; 0x58
 803b58a:	d059      	beq.n	803b640 <tiny_vsnprintf_like+0x134>
        if (*fmt != '%') *str++ = '%';
 803b58c:	2a25      	cmp	r2, #37	; 0x25
 803b58e:	d119      	bne.n	803b5c4 <tiny_vsnprintf_like+0xb8>
        if (*fmt)
 803b590:	7832      	ldrb	r2, [r6, #0]
 803b592:	2a00      	cmp	r2, #0
 803b594:	f000 808d 	beq.w	803b6b2 <tiny_vsnprintf_like+0x1a6>
          *str++ = *fmt;
 803b598:	f804 2b01 	strb.w	r2, [r4], #1
        CHECK_STR_SIZE(buf, str, size);
 803b59c:	eba4 020b 	sub.w	r2, r4, fp
 803b5a0:	428a      	cmp	r2, r1
 803b5a2:	f280 8084 	bge.w	803b6ae <tiny_vsnprintf_like+0x1a2>
 803b5a6:	e7ce      	b.n	803b546 <tiny_vsnprintf_like+0x3a>
  while (is_digit(**s)) i = i*10 + *((*s)++) - '0';
 803b5a8:	260a      	movs	r6, #10
 803b5aa:	fb06 2505 	mla	r5, r6, r5, r2
 803b5ae:	3d30      	subs	r5, #48	; 0x30
 803b5b0:	e7d8      	b.n	803b564 <tiny_vsnprintf_like+0x58>
    field_width = -1;
 803b5b2:	f04f 35ff 	mov.w	r5, #4294967295
 803b5b6:	e7dd      	b.n	803b574 <tiny_vsnprintf_like+0x68>
    switch (*fmt)
 803b5b8:	2a75      	cmp	r2, #117	; 0x75
 803b5ba:	d078      	beq.n	803b6ae <tiny_vsnprintf_like+0x1a2>
 803b5bc:	2a78      	cmp	r2, #120	; 0x78
 803b5be:	d041      	beq.n	803b644 <tiny_vsnprintf_like+0x138>
 803b5c0:	2a73      	cmp	r2, #115	; 0x73
 803b5c2:	d01c      	beq.n	803b5fe <tiny_vsnprintf_like+0xf2>
        if (*fmt != '%') *str++ = '%';
 803b5c4:	2225      	movs	r2, #37	; 0x25
 803b5c6:	f804 2b01 	strb.w	r2, [r4], #1
        CHECK_STR_SIZE(buf, str, size);
 803b5ca:	eba4 020b 	sub.w	r2, r4, fp
 803b5ce:	428a      	cmp	r2, r1
 803b5d0:	da6d      	bge.n	803b6ae <tiny_vsnprintf_like+0x1a2>
 803b5d2:	e7dd      	b.n	803b590 <tiny_vsnprintf_like+0x84>
 803b5d4:	1e61      	subs	r1, r4, #1
    switch (*fmt)
 803b5d6:	462a      	mov	r2, r5
          while (--field_width > 0) *str++ = ' ';
 803b5d8:	3a01      	subs	r2, #1
 803b5da:	2a00      	cmp	r2, #0
 803b5dc:	dc0c      	bgt.n	803b5f8 <tiny_vsnprintf_like+0xec>
 803b5de:	2d00      	cmp	r5, #0
 803b5e0:	f105 32ff 	add.w	r2, r5, #4294967295
 803b5e4:	bfd8      	it	le
 803b5e6:	2200      	movle	r2, #0
 803b5e8:	4422      	add	r2, r4
        *str++ = (unsigned char) va_arg(args, int);
 803b5ea:	f853 1b04 	ldr.w	r1, [r3], #4
 803b5ee:	7011      	strb	r1, [r2, #0]
 803b5f0:	bfd8      	it	le
 803b5f2:	2501      	movle	r5, #1
 803b5f4:	442c      	add	r4, r5
        continue;
 803b5f6:	e7a6      	b.n	803b546 <tiny_vsnprintf_like+0x3a>
          while (--field_width > 0) *str++ = ' ';
 803b5f8:	f801 9f01 	strb.w	r9, [r1, #1]!
 803b5fc:	e7ec      	b.n	803b5d8 <tiny_vsnprintf_like+0xcc>
        s = va_arg(args, char *);
 803b5fe:	4698      	mov	r8, r3
        if (!s) s = "<NULL>";
 803b600:	4b4c      	ldr	r3, [pc, #304]	; (803b734 <tiny_vsnprintf_like+0x228>)
        s = va_arg(args, char *);
 803b602:	f858 7b04 	ldr.w	r7, [r8], #4
        if (!s) s = "<NULL>";
 803b606:	2f00      	cmp	r7, #0
 803b608:	bf08      	it	eq
 803b60a:	461f      	moveq	r7, r3
        len = strlen(s);
 803b60c:	4638      	mov	r0, r7
 803b60e:	f7ef ff17 	bl	802b440 <strlen>
          while (len < field_width--) *str++ = ' ';
 803b612:	4623      	mov	r3, r4
 803b614:	1961      	adds	r1, r4, r5
 803b616:	1aca      	subs	r2, r1, r3
 803b618:	4290      	cmp	r0, r2
 803b61a:	db0a      	blt.n	803b632 <tiny_vsnprintf_like+0x126>
 803b61c:	1a2b      	subs	r3, r5, r0
 803b61e:	4285      	cmp	r5, r0
 803b620:	bfb8      	it	lt
 803b622:	2300      	movlt	r3, #0
 803b624:	441c      	add	r4, r3
        for (i = 0; i < len; ++i) *str++ = *s++;
 803b626:	2300      	movs	r3, #0
 803b628:	4283      	cmp	r3, r0
 803b62a:	db05      	blt.n	803b638 <tiny_vsnprintf_like+0x12c>
 803b62c:	4404      	add	r4, r0
        s = va_arg(args, char *);
 803b62e:	4643      	mov	r3, r8
 803b630:	e789      	b.n	803b546 <tiny_vsnprintf_like+0x3a>
          while (len < field_width--) *str++ = ' ';
 803b632:	f803 9b01 	strb.w	r9, [r3], #1
 803b636:	e7ee      	b.n	803b616 <tiny_vsnprintf_like+0x10a>
        for (i = 0; i < len; ++i) *str++ = *s++;
 803b638:	5cfa      	ldrb	r2, [r7, r3]
 803b63a:	54e2      	strb	r2, [r4, r3]
 803b63c:	3301      	adds	r3, #1
 803b63e:	e7f3      	b.n	803b628 <tiny_vsnprintf_like+0x11c>
        flags |= UPPERCASE;
 803b640:	f040 0040 	orr.w	r0, r0, #64	; 0x40
    switch (*fmt)
 803b644:	2710      	movs	r7, #16
    str = ee_number(str, ((size - 1) - (str - buf)), num, base, field_width, precision, flags);
 803b646:	eba4 020b 	sub.w	r2, r4, fp
 803b64a:	9302      	str	r3, [sp, #8]
 803b64c:	1a8b      	subs	r3, r1, r2
 803b64e:	9301      	str	r3, [sp, #4]
 803b650:	9b02      	ldr	r3, [sp, #8]
  char *dig = lower_digits;
 803b652:	4a39      	ldr	r2, [pc, #228]	; (803b738 <tiny_vsnprintf_like+0x22c>)
    str = ee_number(str, ((size - 1) - (str - buf)), num, base, field_width, precision, flags);
 803b654:	f853 1b04 	ldr.w	r1, [r3], #4
 803b658:	9302      	str	r3, [sp, #8]
  char *dig = lower_digits;
 803b65a:	f010 0f40 	tst.w	r0, #64	; 0x40
 803b65e:	4b37      	ldr	r3, [pc, #220]	; (803b73c <tiny_vsnprintf_like+0x230>)
 803b660:	bf08      	it	eq
 803b662:	4613      	moveq	r3, r2
  c = (type & ZEROPAD) ? '0' : ' ';
 803b664:	f1be 0f30 	cmp.w	lr, #48	; 0x30
  char *dig = lower_digits;
 803b668:	9303      	str	r3, [sp, #12]
  c = (type & ZEROPAD) ? '0' : ' ';
 803b66a:	bf0c      	ite	eq
 803b66c:	2330      	moveq	r3, #48	; 0x30
 803b66e:	2320      	movne	r3, #32
 803b670:	9304      	str	r3, [sp, #16]
  if (type & SIGN)
 803b672:	0783      	lsls	r3, r0, #30
 803b674:	d51f      	bpl.n	803b6b6 <tiny_vsnprintf_like+0x1aa>
    if (num < 0)
 803b676:	2900      	cmp	r1, #0
 803b678:	da1d      	bge.n	803b6b6 <tiny_vsnprintf_like+0x1aa>
      num = -num;
 803b67a:	4249      	negs	r1, r1
      size--;
 803b67c:	3d01      	subs	r5, #1
      sign = '-';
 803b67e:	f04f 0c2d 	mov.w	ip, #45	; 0x2d
    while (num != 0)
 803b682:	ab07      	add	r3, sp, #28
 803b684:	461a      	mov	r2, r3
  i = 0;
 803b686:	2000      	movs	r0, #0
      tmp[i++] = dig[((unsigned long) num) % (unsigned) base];
 803b688:	4688      	mov	r8, r1
 803b68a:	9b03      	ldr	r3, [sp, #12]
 803b68c:	fbb1 f1f7 	udiv	r1, r1, r7
 803b690:	fb07 8a11 	mls	sl, r7, r1, r8
    while (num != 0)
 803b694:	4547      	cmp	r7, r8
      tmp[i++] = dig[((unsigned long) num) % (unsigned) base];
 803b696:	f813 a00a 	ldrb.w	sl, [r3, sl]
 803b69a:	4613      	mov	r3, r2
 803b69c:	f100 0001 	add.w	r0, r0, #1
 803b6a0:	f803 ab01 	strb.w	sl, [r3], #1
 803b6a4:	461a      	mov	r2, r3
    while (num != 0)
 803b6a6:	d9ef      	bls.n	803b688 <tiny_vsnprintf_like+0x17c>
 803b6a8:	e00e      	b.n	803b6c8 <tiny_vsnprintf_like+0x1bc>
        flags |= SIGN;
 803b6aa:	f040 0002 	orr.w	r0, r0, #2
    base = 10;
 803b6ae:	270a      	movs	r7, #10
 803b6b0:	e7c9      	b.n	803b646 <tiny_vsnprintf_like+0x13a>
          --fmt;
 803b6b2:	3e01      	subs	r6, #1
        CHECK_STR_SIZE(buf, str, size);
 803b6b4:	e747      	b.n	803b546 <tiny_vsnprintf_like+0x3a>
  if (num == 0)
 803b6b6:	b111      	cbz	r1, 803b6be <tiny_vsnprintf_like+0x1b2>
 803b6b8:	f04f 0c00 	mov.w	ip, #0
 803b6bc:	e7e1      	b.n	803b682 <tiny_vsnprintf_like+0x176>
    tmp[i++] = '0';
 803b6be:	2030      	movs	r0, #48	; 0x30
 803b6c0:	f88d 001c 	strb.w	r0, [sp, #28]
 803b6c4:	468c      	mov	ip, r1
 803b6c6:	2001      	movs	r0, #1
  if (!(type & (ZEROPAD /* TINY option   | LEFT */))) while (size-- > 0) ASSIGN_STR(' ');
 803b6c8:	f1be 0f30 	cmp.w	lr, #48	; 0x30
  size -= precision;
 803b6cc:	eba5 0500 	sub.w	r5, r5, r0
  if (!(type & (ZEROPAD /* TINY option   | LEFT */))) while (size-- > 0) ASSIGN_STR(' ');
 803b6d0:	d110      	bne.n	803b6f4 <tiny_vsnprintf_like+0x1e8>
  if (sign) ASSIGN_STR(sign);
 803b6d2:	f1bc 0f00 	cmp.w	ip, #0
 803b6d6:	d028      	beq.n	803b72a <tiny_vsnprintf_like+0x21e>
 803b6d8:	9b01      	ldr	r3, [sp, #4]
 803b6da:	f804 cb01 	strb.w	ip, [r4], #1
 803b6de:	3b01      	subs	r3, #1
 803b6e0:	9301      	str	r3, [sp, #4]
 803b6e2:	d122      	bne.n	803b72a <tiny_vsnprintf_like+0x21e>
 803b6e4:	9b02      	ldr	r3, [sp, #8]
 803b6e6:	e72e      	b.n	803b546 <tiny_vsnprintf_like+0x3a>
  if (!(type & (ZEROPAD /* TINY option   | LEFT */))) while (size-- > 0) ASSIGN_STR(' ');
 803b6e8:	9b01      	ldr	r3, [sp, #4]
 803b6ea:	f804 9b01 	strb.w	r9, [r4], #1
 803b6ee:	3b01      	subs	r3, #1
 803b6f0:	9301      	str	r3, [sp, #4]
 803b6f2:	d0f7      	beq.n	803b6e4 <tiny_vsnprintf_like+0x1d8>
 803b6f4:	2d00      	cmp	r5, #0
 803b6f6:	f105 35ff 	add.w	r5, r5, #4294967295
 803b6fa:	dcf5      	bgt.n	803b6e8 <tiny_vsnprintf_like+0x1dc>
 803b6fc:	e7e9      	b.n	803b6d2 <tiny_vsnprintf_like+0x1c6>
  while (size-- > 0) ASSIGN_STR(c);
 803b6fe:	9b04      	ldr	r3, [sp, #16]
 803b700:	f804 3b01 	strb.w	r3, [r4], #1
 803b704:	9b01      	ldr	r3, [sp, #4]
 803b706:	3b01      	subs	r3, #1
 803b708:	9301      	str	r3, [sp, #4]
 803b70a:	d0eb      	beq.n	803b6e4 <tiny_vsnprintf_like+0x1d8>
 803b70c:	1b29      	subs	r1, r5, r4
 803b70e:	2900      	cmp	r1, #0
 803b710:	dcf5      	bgt.n	803b6fe <tiny_vsnprintf_like+0x1f2>
  while (i-- > 0) ASSIGN_STR(tmp[i]);
 803b712:	9b01      	ldr	r3, [sp, #4]
 803b714:	4423      	add	r3, r4
 803b716:	461a      	mov	r2, r3
 803b718:	3801      	subs	r0, #1
 803b71a:	d3e3      	bcc.n	803b6e4 <tiny_vsnprintf_like+0x1d8>
 803b71c:	ab07      	add	r3, sp, #28
 803b71e:	5c19      	ldrb	r1, [r3, r0]
 803b720:	f804 1b01 	strb.w	r1, [r4], #1
 803b724:	4294      	cmp	r4, r2
 803b726:	d1f7      	bne.n	803b718 <tiny_vsnprintf_like+0x20c>
 803b728:	e7dc      	b.n	803b6e4 <tiny_vsnprintf_like+0x1d8>
 803b72a:	4425      	add	r5, r4
 803b72c:	e7ee      	b.n	803b70c <tiny_vsnprintf_like+0x200>
    return 0;
 803b72e:	2000      	movs	r0, #0
 803b730:	e6ff      	b.n	803b532 <tiny_vsnprintf_like+0x26>
 803b732:	bf00      	nop
 803b734:	0803c5be 	.word	0x0803c5be
 803b738:	0803c5ea 	.word	0x0803c5ea
 803b73c:	0803c5c5 	.word	0x0803c5c5

0803b740 <__libc_init_array>:
 803b740:	b570      	push	{r4, r5, r6, lr}
 803b742:	4d0d      	ldr	r5, [pc, #52]	; (803b778 <__libc_init_array+0x38>)
 803b744:	4c0d      	ldr	r4, [pc, #52]	; (803b77c <__libc_init_array+0x3c>)
 803b746:	1b64      	subs	r4, r4, r5
 803b748:	10a4      	asrs	r4, r4, #2
 803b74a:	2600      	movs	r6, #0
 803b74c:	42a6      	cmp	r6, r4
 803b74e:	d109      	bne.n	803b764 <__libc_init_array+0x24>
 803b750:	4d0b      	ldr	r5, [pc, #44]	; (803b780 <__libc_init_array+0x40>)
 803b752:	4c0c      	ldr	r4, [pc, #48]	; (803b784 <__libc_init_array+0x44>)
 803b754:	f000 f8a0 	bl	803b898 <_init>
 803b758:	1b64      	subs	r4, r4, r5
 803b75a:	10a4      	asrs	r4, r4, #2
 803b75c:	2600      	movs	r6, #0
 803b75e:	42a6      	cmp	r6, r4
 803b760:	d105      	bne.n	803b76e <__libc_init_array+0x2e>
 803b762:	bd70      	pop	{r4, r5, r6, pc}
 803b764:	f855 3b04 	ldr.w	r3, [r5], #4
 803b768:	4798      	blx	r3
 803b76a:	3601      	adds	r6, #1
 803b76c:	e7ee      	b.n	803b74c <__libc_init_array+0xc>
 803b76e:	f855 3b04 	ldr.w	r3, [r5], #4
 803b772:	4798      	blx	r3
 803b774:	3601      	adds	r6, #1
 803b776:	e7f2      	b.n	803b75e <__libc_init_array+0x1e>
 803b778:	0803c618 	.word	0x0803c618
 803b77c:	0803c618 	.word	0x0803c618
 803b780:	0803c618 	.word	0x0803c618
 803b784:	0803c61c 	.word	0x0803c61c

0803b788 <memset>:
 803b788:	4402      	add	r2, r0
 803b78a:	4603      	mov	r3, r0
 803b78c:	4293      	cmp	r3, r2
 803b78e:	d100      	bne.n	803b792 <memset+0xa>
 803b790:	4770      	bx	lr
 803b792:	f803 1b01 	strb.w	r1, [r3], #1
 803b796:	e7f9      	b.n	803b78c <memset+0x4>

0803b798 <floor>:
 803b798:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 803b79c:	f3c1 580a 	ubfx	r8, r1, #20, #11
 803b7a0:	f2a8 36ff 	subw	r6, r8, #1023	; 0x3ff
 803b7a4:	2e13      	cmp	r6, #19
 803b7a6:	4602      	mov	r2, r0
 803b7a8:	460b      	mov	r3, r1
 803b7aa:	4607      	mov	r7, r0
 803b7ac:	460c      	mov	r4, r1
 803b7ae:	4605      	mov	r5, r0
 803b7b0:	dc34      	bgt.n	803b81c <floor+0x84>
 803b7b2:	2e00      	cmp	r6, #0
 803b7b4:	da15      	bge.n	803b7e2 <floor+0x4a>
 803b7b6:	a334      	add	r3, pc, #208	; (adr r3, 803b888 <floor+0xf0>)
 803b7b8:	e9d3 2300 	ldrd	r2, r3, [r3]
 803b7bc:	f7ef fe4e 	bl	802b45c <__adddf3>
 803b7c0:	2200      	movs	r2, #0
 803b7c2:	2300      	movs	r3, #0
 803b7c4:	f7f0 f87e 	bl	802b8c4 <__aeabi_dcmpgt>
 803b7c8:	b140      	cbz	r0, 803b7dc <floor+0x44>
 803b7ca:	2c00      	cmp	r4, #0
 803b7cc:	da59      	bge.n	803b882 <floor+0xea>
 803b7ce:	f024 4300 	bic.w	r3, r4, #2147483648	; 0x80000000
 803b7d2:	ea57 0503 	orrs.w	r5, r7, r3
 803b7d6:	d001      	beq.n	803b7dc <floor+0x44>
 803b7d8:	4c2d      	ldr	r4, [pc, #180]	; (803b890 <floor+0xf8>)
 803b7da:	2500      	movs	r5, #0
 803b7dc:	4623      	mov	r3, r4
 803b7de:	462f      	mov	r7, r5
 803b7e0:	e025      	b.n	803b82e <floor+0x96>
 803b7e2:	4a2c      	ldr	r2, [pc, #176]	; (803b894 <floor+0xfc>)
 803b7e4:	fa42 f806 	asr.w	r8, r2, r6
 803b7e8:	ea01 0208 	and.w	r2, r1, r8
 803b7ec:	4302      	orrs	r2, r0
 803b7ee:	d01e      	beq.n	803b82e <floor+0x96>
 803b7f0:	a325      	add	r3, pc, #148	; (adr r3, 803b888 <floor+0xf0>)
 803b7f2:	e9d3 2300 	ldrd	r2, r3, [r3]
 803b7f6:	f7ef fe31 	bl	802b45c <__adddf3>
 803b7fa:	2200      	movs	r2, #0
 803b7fc:	2300      	movs	r3, #0
 803b7fe:	f7f0 f861 	bl	802b8c4 <__aeabi_dcmpgt>
 803b802:	2800      	cmp	r0, #0
 803b804:	d0ea      	beq.n	803b7dc <floor+0x44>
 803b806:	2c00      	cmp	r4, #0
 803b808:	bfbe      	ittt	lt
 803b80a:	f44f 1380 	movlt.w	r3, #1048576	; 0x100000
 803b80e:	fa43 f606 	asrlt.w	r6, r3, r6
 803b812:	19a4      	addlt	r4, r4, r6
 803b814:	ea24 0408 	bic.w	r4, r4, r8
 803b818:	2500      	movs	r5, #0
 803b81a:	e7df      	b.n	803b7dc <floor+0x44>
 803b81c:	2e33      	cmp	r6, #51	; 0x33
 803b81e:	dd0a      	ble.n	803b836 <floor+0x9e>
 803b820:	f5b6 6f80 	cmp.w	r6, #1024	; 0x400
 803b824:	d103      	bne.n	803b82e <floor+0x96>
 803b826:	f7ef fe19 	bl	802b45c <__adddf3>
 803b82a:	4607      	mov	r7, r0
 803b82c:	460b      	mov	r3, r1
 803b82e:	4638      	mov	r0, r7
 803b830:	4619      	mov	r1, r3
 803b832:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 803b836:	f2a8 4813 	subw	r8, r8, #1043	; 0x413
 803b83a:	f04f 32ff 	mov.w	r2, #4294967295
 803b83e:	fa22 f808 	lsr.w	r8, r2, r8
 803b842:	ea18 0f00 	tst.w	r8, r0
 803b846:	d0f2      	beq.n	803b82e <floor+0x96>
 803b848:	a30f      	add	r3, pc, #60	; (adr r3, 803b888 <floor+0xf0>)
 803b84a:	e9d3 2300 	ldrd	r2, r3, [r3]
 803b84e:	f7ef fe05 	bl	802b45c <__adddf3>
 803b852:	2200      	movs	r2, #0
 803b854:	2300      	movs	r3, #0
 803b856:	f7f0 f835 	bl	802b8c4 <__aeabi_dcmpgt>
 803b85a:	2800      	cmp	r0, #0
 803b85c:	d0be      	beq.n	803b7dc <floor+0x44>
 803b85e:	2c00      	cmp	r4, #0
 803b860:	da02      	bge.n	803b868 <floor+0xd0>
 803b862:	2e14      	cmp	r6, #20
 803b864:	d103      	bne.n	803b86e <floor+0xd6>
 803b866:	3401      	adds	r4, #1
 803b868:	ea25 0508 	bic.w	r5, r5, r8
 803b86c:	e7b6      	b.n	803b7dc <floor+0x44>
 803b86e:	2301      	movs	r3, #1
 803b870:	f1c6 0634 	rsb	r6, r6, #52	; 0x34
 803b874:	fa03 f606 	lsl.w	r6, r3, r6
 803b878:	4435      	add	r5, r6
 803b87a:	42bd      	cmp	r5, r7
 803b87c:	bf38      	it	cc
 803b87e:	18e4      	addcc	r4, r4, r3
 803b880:	e7f2      	b.n	803b868 <floor+0xd0>
 803b882:	2500      	movs	r5, #0
 803b884:	462c      	mov	r4, r5
 803b886:	e7a9      	b.n	803b7dc <floor+0x44>
 803b888:	8800759c 	.word	0x8800759c
 803b88c:	7e37e43c 	.word	0x7e37e43c
 803b890:	bff00000 	.word	0xbff00000
 803b894:	000fffff 	.word	0x000fffff

0803b898 <_init>:
 803b898:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 803b89a:	bf00      	nop
 803b89c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 803b89e:	bc08      	pop	{r3}
 803b8a0:	469e      	mov	lr, r3
 803b8a2:	4770      	bx	lr

0803b8a4 <_fini>:
 803b8a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 803b8a6:	bf00      	nop
 803b8a8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 803b8aa:	bc08      	pop	{r3}
 803b8ac:	469e      	mov	lr, r3
 803b8ae:	4770      	bx	lr
