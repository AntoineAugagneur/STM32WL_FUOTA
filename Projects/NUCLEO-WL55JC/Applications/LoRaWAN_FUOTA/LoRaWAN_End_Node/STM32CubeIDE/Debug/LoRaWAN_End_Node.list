
LoRaWAN_End_Node.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000200  0802b200  0802b200  000000f4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00010458  0802b400  0802b400  000002f8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000cf0  0803b858  0803b858  00010750  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0803c548  0803c548  00011608  2**0
                  CONTENTS
  4 .ARM          00000008  0803c548  0803c548  00011440  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  0803c550  0803c550  00011608  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  0803c550  0803c550  00011448  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  0803c554  0803c554  0001144c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         000001ac  20003400  0803c558  00011450  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .align16      0000000c  0803c704  0803c704  000115fc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 10 .bss          00002e00  200035ac  200035ac  00011608  2**2
                  ALLOC
 11 ._user_heap_stack 00000a04  200063ac  200063ac  00011608  2**0
                  ALLOC
 12 .ARM.attributes 0000002a  00000000  00000000  00011608  2**0
                  CONTENTS, READONLY
 13 .debug_info   00082b7e  00000000  00000000  00011632  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 000107d4  00000000  00000000  000941b0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_loc    00024920  00000000  00000000  000a4984  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_aranges 000028d0  00000000  00000000  000c92a8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_ranges 00004a68  00000000  00000000  000cbb78  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_macro  0002f3f2  00000000  00000000  000d05e0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_line   000524b6  00000000  00000000  000ff9d2  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_str    000e666a  00000000  00000000  00151e88  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .comment      00000053  00000000  00000000  002384f2  2**0
                  CONTENTS, READONLY
 22 .debug_frame  000072a0  00000000  00000000  00238548  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

0802b400 <__do_global_dtors_aux>:
 802b400:	b510      	push	{r4, lr}
 802b402:	4c05      	ldr	r4, [pc, #20]	; (802b418 <__do_global_dtors_aux+0x18>)
 802b404:	7823      	ldrb	r3, [r4, #0]
 802b406:	b933      	cbnz	r3, 802b416 <__do_global_dtors_aux+0x16>
 802b408:	4b04      	ldr	r3, [pc, #16]	; (802b41c <__do_global_dtors_aux+0x1c>)
 802b40a:	b113      	cbz	r3, 802b412 <__do_global_dtors_aux+0x12>
 802b40c:	4804      	ldr	r0, [pc, #16]	; (802b420 <__do_global_dtors_aux+0x20>)
 802b40e:	f3af 8000 	nop.w
 802b412:	2301      	movs	r3, #1
 802b414:	7023      	strb	r3, [r4, #0]
 802b416:	bd10      	pop	{r4, pc}
 802b418:	200035ac 	.word	0x200035ac
 802b41c:	00000000 	.word	0x00000000
 802b420:	0803b840 	.word	0x0803b840

0802b424 <frame_dummy>:
 802b424:	b508      	push	{r3, lr}
 802b426:	4b03      	ldr	r3, [pc, #12]	; (802b434 <frame_dummy+0x10>)
 802b428:	b11b      	cbz	r3, 802b432 <frame_dummy+0xe>
 802b42a:	4903      	ldr	r1, [pc, #12]	; (802b438 <frame_dummy+0x14>)
 802b42c:	4803      	ldr	r0, [pc, #12]	; (802b43c <frame_dummy+0x18>)
 802b42e:	f3af 8000 	nop.w
 802b432:	bd08      	pop	{r3, pc}
 802b434:	00000000 	.word	0x00000000
 802b438:	200035b0 	.word	0x200035b0
 802b43c:	0803b840 	.word	0x0803b840

0802b440 <strlen>:
 802b440:	4603      	mov	r3, r0
 802b442:	f813 2b01 	ldrb.w	r2, [r3], #1
 802b446:	2a00      	cmp	r2, #0
 802b448:	d1fb      	bne.n	802b442 <strlen+0x2>
 802b44a:	1a18      	subs	r0, r3, r0
 802b44c:	3801      	subs	r0, #1
 802b44e:	4770      	bx	lr

0802b450 <__aeabi_drsub>:
 802b450:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 802b454:	e002      	b.n	802b45c <__adddf3>
 802b456:	bf00      	nop

0802b458 <__aeabi_dsub>:
 802b458:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0802b45c <__adddf3>:
 802b45c:	b530      	push	{r4, r5, lr}
 802b45e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 802b462:	ea4f 0543 	mov.w	r5, r3, lsl #1
 802b466:	ea94 0f05 	teq	r4, r5
 802b46a:	bf08      	it	eq
 802b46c:	ea90 0f02 	teqeq	r0, r2
 802b470:	bf1f      	itttt	ne
 802b472:	ea54 0c00 	orrsne.w	ip, r4, r0
 802b476:	ea55 0c02 	orrsne.w	ip, r5, r2
 802b47a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 802b47e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 802b482:	f000 80e2 	beq.w	802b64a <__adddf3+0x1ee>
 802b486:	ea4f 5454 	mov.w	r4, r4, lsr #21
 802b48a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 802b48e:	bfb8      	it	lt
 802b490:	426d      	neglt	r5, r5
 802b492:	dd0c      	ble.n	802b4ae <__adddf3+0x52>
 802b494:	442c      	add	r4, r5
 802b496:	ea80 0202 	eor.w	r2, r0, r2
 802b49a:	ea81 0303 	eor.w	r3, r1, r3
 802b49e:	ea82 0000 	eor.w	r0, r2, r0
 802b4a2:	ea83 0101 	eor.w	r1, r3, r1
 802b4a6:	ea80 0202 	eor.w	r2, r0, r2
 802b4aa:	ea81 0303 	eor.w	r3, r1, r3
 802b4ae:	2d36      	cmp	r5, #54	; 0x36
 802b4b0:	bf88      	it	hi
 802b4b2:	bd30      	pophi	{r4, r5, pc}
 802b4b4:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 802b4b8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 802b4bc:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 802b4c0:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 802b4c4:	d002      	beq.n	802b4cc <__adddf3+0x70>
 802b4c6:	4240      	negs	r0, r0
 802b4c8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 802b4cc:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 802b4d0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 802b4d4:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 802b4d8:	d002      	beq.n	802b4e0 <__adddf3+0x84>
 802b4da:	4252      	negs	r2, r2
 802b4dc:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 802b4e0:	ea94 0f05 	teq	r4, r5
 802b4e4:	f000 80a7 	beq.w	802b636 <__adddf3+0x1da>
 802b4e8:	f1a4 0401 	sub.w	r4, r4, #1
 802b4ec:	f1d5 0e20 	rsbs	lr, r5, #32
 802b4f0:	db0d      	blt.n	802b50e <__adddf3+0xb2>
 802b4f2:	fa02 fc0e 	lsl.w	ip, r2, lr
 802b4f6:	fa22 f205 	lsr.w	r2, r2, r5
 802b4fa:	1880      	adds	r0, r0, r2
 802b4fc:	f141 0100 	adc.w	r1, r1, #0
 802b500:	fa03 f20e 	lsl.w	r2, r3, lr
 802b504:	1880      	adds	r0, r0, r2
 802b506:	fa43 f305 	asr.w	r3, r3, r5
 802b50a:	4159      	adcs	r1, r3
 802b50c:	e00e      	b.n	802b52c <__adddf3+0xd0>
 802b50e:	f1a5 0520 	sub.w	r5, r5, #32
 802b512:	f10e 0e20 	add.w	lr, lr, #32
 802b516:	2a01      	cmp	r2, #1
 802b518:	fa03 fc0e 	lsl.w	ip, r3, lr
 802b51c:	bf28      	it	cs
 802b51e:	f04c 0c02 	orrcs.w	ip, ip, #2
 802b522:	fa43 f305 	asr.w	r3, r3, r5
 802b526:	18c0      	adds	r0, r0, r3
 802b528:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 802b52c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 802b530:	d507      	bpl.n	802b542 <__adddf3+0xe6>
 802b532:	f04f 0e00 	mov.w	lr, #0
 802b536:	f1dc 0c00 	rsbs	ip, ip, #0
 802b53a:	eb7e 0000 	sbcs.w	r0, lr, r0
 802b53e:	eb6e 0101 	sbc.w	r1, lr, r1
 802b542:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 802b546:	d31b      	bcc.n	802b580 <__adddf3+0x124>
 802b548:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 802b54c:	d30c      	bcc.n	802b568 <__adddf3+0x10c>
 802b54e:	0849      	lsrs	r1, r1, #1
 802b550:	ea5f 0030 	movs.w	r0, r0, rrx
 802b554:	ea4f 0c3c 	mov.w	ip, ip, rrx
 802b558:	f104 0401 	add.w	r4, r4, #1
 802b55c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 802b560:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 802b564:	f080 809a 	bcs.w	802b69c <__adddf3+0x240>
 802b568:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 802b56c:	bf08      	it	eq
 802b56e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 802b572:	f150 0000 	adcs.w	r0, r0, #0
 802b576:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 802b57a:	ea41 0105 	orr.w	r1, r1, r5
 802b57e:	bd30      	pop	{r4, r5, pc}
 802b580:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 802b584:	4140      	adcs	r0, r0
 802b586:	eb41 0101 	adc.w	r1, r1, r1
 802b58a:	3c01      	subs	r4, #1
 802b58c:	bf28      	it	cs
 802b58e:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
 802b592:	d2e9      	bcs.n	802b568 <__adddf3+0x10c>
 802b594:	f091 0f00 	teq	r1, #0
 802b598:	bf04      	itt	eq
 802b59a:	4601      	moveq	r1, r0
 802b59c:	2000      	moveq	r0, #0
 802b59e:	fab1 f381 	clz	r3, r1
 802b5a2:	bf08      	it	eq
 802b5a4:	3320      	addeq	r3, #32
 802b5a6:	f1a3 030b 	sub.w	r3, r3, #11
 802b5aa:	f1b3 0220 	subs.w	r2, r3, #32
 802b5ae:	da0c      	bge.n	802b5ca <__adddf3+0x16e>
 802b5b0:	320c      	adds	r2, #12
 802b5b2:	dd08      	ble.n	802b5c6 <__adddf3+0x16a>
 802b5b4:	f102 0c14 	add.w	ip, r2, #20
 802b5b8:	f1c2 020c 	rsb	r2, r2, #12
 802b5bc:	fa01 f00c 	lsl.w	r0, r1, ip
 802b5c0:	fa21 f102 	lsr.w	r1, r1, r2
 802b5c4:	e00c      	b.n	802b5e0 <__adddf3+0x184>
 802b5c6:	f102 0214 	add.w	r2, r2, #20
 802b5ca:	bfd8      	it	le
 802b5cc:	f1c2 0c20 	rsble	ip, r2, #32
 802b5d0:	fa01 f102 	lsl.w	r1, r1, r2
 802b5d4:	fa20 fc0c 	lsr.w	ip, r0, ip
 802b5d8:	bfdc      	itt	le
 802b5da:	ea41 010c 	orrle.w	r1, r1, ip
 802b5de:	4090      	lslle	r0, r2
 802b5e0:	1ae4      	subs	r4, r4, r3
 802b5e2:	bfa2      	ittt	ge
 802b5e4:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 802b5e8:	4329      	orrge	r1, r5
 802b5ea:	bd30      	popge	{r4, r5, pc}
 802b5ec:	ea6f 0404 	mvn.w	r4, r4
 802b5f0:	3c1f      	subs	r4, #31
 802b5f2:	da1c      	bge.n	802b62e <__adddf3+0x1d2>
 802b5f4:	340c      	adds	r4, #12
 802b5f6:	dc0e      	bgt.n	802b616 <__adddf3+0x1ba>
 802b5f8:	f104 0414 	add.w	r4, r4, #20
 802b5fc:	f1c4 0220 	rsb	r2, r4, #32
 802b600:	fa20 f004 	lsr.w	r0, r0, r4
 802b604:	fa01 f302 	lsl.w	r3, r1, r2
 802b608:	ea40 0003 	orr.w	r0, r0, r3
 802b60c:	fa21 f304 	lsr.w	r3, r1, r4
 802b610:	ea45 0103 	orr.w	r1, r5, r3
 802b614:	bd30      	pop	{r4, r5, pc}
 802b616:	f1c4 040c 	rsb	r4, r4, #12
 802b61a:	f1c4 0220 	rsb	r2, r4, #32
 802b61e:	fa20 f002 	lsr.w	r0, r0, r2
 802b622:	fa01 f304 	lsl.w	r3, r1, r4
 802b626:	ea40 0003 	orr.w	r0, r0, r3
 802b62a:	4629      	mov	r1, r5
 802b62c:	bd30      	pop	{r4, r5, pc}
 802b62e:	fa21 f004 	lsr.w	r0, r1, r4
 802b632:	4629      	mov	r1, r5
 802b634:	bd30      	pop	{r4, r5, pc}
 802b636:	f094 0f00 	teq	r4, #0
 802b63a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 802b63e:	bf06      	itte	eq
 802b640:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 802b644:	3401      	addeq	r4, #1
 802b646:	3d01      	subne	r5, #1
 802b648:	e74e      	b.n	802b4e8 <__adddf3+0x8c>
 802b64a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 802b64e:	bf18      	it	ne
 802b650:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 802b654:	d029      	beq.n	802b6aa <__adddf3+0x24e>
 802b656:	ea94 0f05 	teq	r4, r5
 802b65a:	bf08      	it	eq
 802b65c:	ea90 0f02 	teqeq	r0, r2
 802b660:	d005      	beq.n	802b66e <__adddf3+0x212>
 802b662:	ea54 0c00 	orrs.w	ip, r4, r0
 802b666:	bf04      	itt	eq
 802b668:	4619      	moveq	r1, r3
 802b66a:	4610      	moveq	r0, r2
 802b66c:	bd30      	pop	{r4, r5, pc}
 802b66e:	ea91 0f03 	teq	r1, r3
 802b672:	bf1e      	ittt	ne
 802b674:	2100      	movne	r1, #0
 802b676:	2000      	movne	r0, #0
 802b678:	bd30      	popne	{r4, r5, pc}
 802b67a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 802b67e:	d105      	bne.n	802b68c <__adddf3+0x230>
 802b680:	0040      	lsls	r0, r0, #1
 802b682:	4149      	adcs	r1, r1
 802b684:	bf28      	it	cs
 802b686:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 802b68a:	bd30      	pop	{r4, r5, pc}
 802b68c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 802b690:	bf3c      	itt	cc
 802b692:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 802b696:	bd30      	popcc	{r4, r5, pc}
 802b698:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 802b69c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 802b6a0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 802b6a4:	f04f 0000 	mov.w	r0, #0
 802b6a8:	bd30      	pop	{r4, r5, pc}
 802b6aa:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 802b6ae:	bf1a      	itte	ne
 802b6b0:	4619      	movne	r1, r3
 802b6b2:	4610      	movne	r0, r2
 802b6b4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 802b6b8:	bf1c      	itt	ne
 802b6ba:	460b      	movne	r3, r1
 802b6bc:	4602      	movne	r2, r0
 802b6be:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 802b6c2:	bf06      	itte	eq
 802b6c4:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 802b6c8:	ea91 0f03 	teqeq	r1, r3
 802b6cc:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 802b6d0:	bd30      	pop	{r4, r5, pc}
 802b6d2:	bf00      	nop

0802b6d4 <__aeabi_ui2d>:
 802b6d4:	f090 0f00 	teq	r0, #0
 802b6d8:	bf04      	itt	eq
 802b6da:	2100      	moveq	r1, #0
 802b6dc:	4770      	bxeq	lr
 802b6de:	b530      	push	{r4, r5, lr}
 802b6e0:	f44f 6480 	mov.w	r4, #1024	; 0x400
 802b6e4:	f104 0432 	add.w	r4, r4, #50	; 0x32
 802b6e8:	f04f 0500 	mov.w	r5, #0
 802b6ec:	f04f 0100 	mov.w	r1, #0
 802b6f0:	e750      	b.n	802b594 <__adddf3+0x138>
 802b6f2:	bf00      	nop

0802b6f4 <__aeabi_i2d>:
 802b6f4:	f090 0f00 	teq	r0, #0
 802b6f8:	bf04      	itt	eq
 802b6fa:	2100      	moveq	r1, #0
 802b6fc:	4770      	bxeq	lr
 802b6fe:	b530      	push	{r4, r5, lr}
 802b700:	f44f 6480 	mov.w	r4, #1024	; 0x400
 802b704:	f104 0432 	add.w	r4, r4, #50	; 0x32
 802b708:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 802b70c:	bf48      	it	mi
 802b70e:	4240      	negmi	r0, r0
 802b710:	f04f 0100 	mov.w	r1, #0
 802b714:	e73e      	b.n	802b594 <__adddf3+0x138>
 802b716:	bf00      	nop

0802b718 <__aeabi_f2d>:
 802b718:	0042      	lsls	r2, r0, #1
 802b71a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 802b71e:	ea4f 0131 	mov.w	r1, r1, rrx
 802b722:	ea4f 7002 	mov.w	r0, r2, lsl #28
 802b726:	bf1f      	itttt	ne
 802b728:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 802b72c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 802b730:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 802b734:	4770      	bxne	lr
 802b736:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 802b73a:	bf08      	it	eq
 802b73c:	4770      	bxeq	lr
 802b73e:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 802b742:	bf04      	itt	eq
 802b744:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 802b748:	4770      	bxeq	lr
 802b74a:	b530      	push	{r4, r5, lr}
 802b74c:	f44f 7460 	mov.w	r4, #896	; 0x380
 802b750:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 802b754:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 802b758:	e71c      	b.n	802b594 <__adddf3+0x138>
 802b75a:	bf00      	nop

0802b75c <__aeabi_ul2d>:
 802b75c:	ea50 0201 	orrs.w	r2, r0, r1
 802b760:	bf08      	it	eq
 802b762:	4770      	bxeq	lr
 802b764:	b530      	push	{r4, r5, lr}
 802b766:	f04f 0500 	mov.w	r5, #0
 802b76a:	e00a      	b.n	802b782 <__aeabi_l2d+0x16>

0802b76c <__aeabi_l2d>:
 802b76c:	ea50 0201 	orrs.w	r2, r0, r1
 802b770:	bf08      	it	eq
 802b772:	4770      	bxeq	lr
 802b774:	b530      	push	{r4, r5, lr}
 802b776:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 802b77a:	d502      	bpl.n	802b782 <__aeabi_l2d+0x16>
 802b77c:	4240      	negs	r0, r0
 802b77e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 802b782:	f44f 6480 	mov.w	r4, #1024	; 0x400
 802b786:	f104 0432 	add.w	r4, r4, #50	; 0x32
 802b78a:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 802b78e:	f43f aed8 	beq.w	802b542 <__adddf3+0xe6>
 802b792:	f04f 0203 	mov.w	r2, #3
 802b796:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 802b79a:	bf18      	it	ne
 802b79c:	3203      	addne	r2, #3
 802b79e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 802b7a2:	bf18      	it	ne
 802b7a4:	3203      	addne	r2, #3
 802b7a6:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 802b7aa:	f1c2 0320 	rsb	r3, r2, #32
 802b7ae:	fa00 fc03 	lsl.w	ip, r0, r3
 802b7b2:	fa20 f002 	lsr.w	r0, r0, r2
 802b7b6:	fa01 fe03 	lsl.w	lr, r1, r3
 802b7ba:	ea40 000e 	orr.w	r0, r0, lr
 802b7be:	fa21 f102 	lsr.w	r1, r1, r2
 802b7c2:	4414      	add	r4, r2
 802b7c4:	e6bd      	b.n	802b542 <__adddf3+0xe6>
 802b7c6:	bf00      	nop

0802b7c8 <__gedf2>:
 802b7c8:	f04f 3cff 	mov.w	ip, #4294967295
 802b7cc:	e006      	b.n	802b7dc <__cmpdf2+0x4>
 802b7ce:	bf00      	nop

0802b7d0 <__ledf2>:
 802b7d0:	f04f 0c01 	mov.w	ip, #1
 802b7d4:	e002      	b.n	802b7dc <__cmpdf2+0x4>
 802b7d6:	bf00      	nop

0802b7d8 <__cmpdf2>:
 802b7d8:	f04f 0c01 	mov.w	ip, #1
 802b7dc:	f84d cd04 	str.w	ip, [sp, #-4]!
 802b7e0:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 802b7e4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 802b7e8:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 802b7ec:	bf18      	it	ne
 802b7ee:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 802b7f2:	d01b      	beq.n	802b82c <__cmpdf2+0x54>
 802b7f4:	b001      	add	sp, #4
 802b7f6:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 802b7fa:	bf0c      	ite	eq
 802b7fc:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 802b800:	ea91 0f03 	teqne	r1, r3
 802b804:	bf02      	ittt	eq
 802b806:	ea90 0f02 	teqeq	r0, r2
 802b80a:	2000      	moveq	r0, #0
 802b80c:	4770      	bxeq	lr
 802b80e:	f110 0f00 	cmn.w	r0, #0
 802b812:	ea91 0f03 	teq	r1, r3
 802b816:	bf58      	it	pl
 802b818:	4299      	cmppl	r1, r3
 802b81a:	bf08      	it	eq
 802b81c:	4290      	cmpeq	r0, r2
 802b81e:	bf2c      	ite	cs
 802b820:	17d8      	asrcs	r0, r3, #31
 802b822:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 802b826:	f040 0001 	orr.w	r0, r0, #1
 802b82a:	4770      	bx	lr
 802b82c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 802b830:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 802b834:	d102      	bne.n	802b83c <__cmpdf2+0x64>
 802b836:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 802b83a:	d107      	bne.n	802b84c <__cmpdf2+0x74>
 802b83c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 802b840:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 802b844:	d1d6      	bne.n	802b7f4 <__cmpdf2+0x1c>
 802b846:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 802b84a:	d0d3      	beq.n	802b7f4 <__cmpdf2+0x1c>
 802b84c:	f85d 0b04 	ldr.w	r0, [sp], #4
 802b850:	4770      	bx	lr
 802b852:	bf00      	nop

0802b854 <__aeabi_cdrcmple>:
 802b854:	4684      	mov	ip, r0
 802b856:	4610      	mov	r0, r2
 802b858:	4662      	mov	r2, ip
 802b85a:	468c      	mov	ip, r1
 802b85c:	4619      	mov	r1, r3
 802b85e:	4663      	mov	r3, ip
 802b860:	e000      	b.n	802b864 <__aeabi_cdcmpeq>
 802b862:	bf00      	nop

0802b864 <__aeabi_cdcmpeq>:
 802b864:	b501      	push	{r0, lr}
 802b866:	f7ff ffb7 	bl	802b7d8 <__cmpdf2>
 802b86a:	2800      	cmp	r0, #0
 802b86c:	bf48      	it	mi
 802b86e:	f110 0f00 	cmnmi.w	r0, #0
 802b872:	bd01      	pop	{r0, pc}

0802b874 <__aeabi_dcmpeq>:
 802b874:	f84d ed08 	str.w	lr, [sp, #-8]!
 802b878:	f7ff fff4 	bl	802b864 <__aeabi_cdcmpeq>
 802b87c:	bf0c      	ite	eq
 802b87e:	2001      	moveq	r0, #1
 802b880:	2000      	movne	r0, #0
 802b882:	f85d fb08 	ldr.w	pc, [sp], #8
 802b886:	bf00      	nop

0802b888 <__aeabi_dcmplt>:
 802b888:	f84d ed08 	str.w	lr, [sp, #-8]!
 802b88c:	f7ff ffea 	bl	802b864 <__aeabi_cdcmpeq>
 802b890:	bf34      	ite	cc
 802b892:	2001      	movcc	r0, #1
 802b894:	2000      	movcs	r0, #0
 802b896:	f85d fb08 	ldr.w	pc, [sp], #8
 802b89a:	bf00      	nop

0802b89c <__aeabi_dcmple>:
 802b89c:	f84d ed08 	str.w	lr, [sp, #-8]!
 802b8a0:	f7ff ffe0 	bl	802b864 <__aeabi_cdcmpeq>
 802b8a4:	bf94      	ite	ls
 802b8a6:	2001      	movls	r0, #1
 802b8a8:	2000      	movhi	r0, #0
 802b8aa:	f85d fb08 	ldr.w	pc, [sp], #8
 802b8ae:	bf00      	nop

0802b8b0 <__aeabi_dcmpge>:
 802b8b0:	f84d ed08 	str.w	lr, [sp, #-8]!
 802b8b4:	f7ff ffce 	bl	802b854 <__aeabi_cdrcmple>
 802b8b8:	bf94      	ite	ls
 802b8ba:	2001      	movls	r0, #1
 802b8bc:	2000      	movhi	r0, #0
 802b8be:	f85d fb08 	ldr.w	pc, [sp], #8
 802b8c2:	bf00      	nop

0802b8c4 <__aeabi_dcmpgt>:
 802b8c4:	f84d ed08 	str.w	lr, [sp, #-8]!
 802b8c8:	f7ff ffc4 	bl	802b854 <__aeabi_cdrcmple>
 802b8cc:	bf34      	ite	cc
 802b8ce:	2001      	movcc	r0, #1
 802b8d0:	2000      	movcs	r0, #0
 802b8d2:	f85d fb08 	ldr.w	pc, [sp], #8
 802b8d6:	bf00      	nop

0802b8d8 <__aeabi_d2iz>:
 802b8d8:	ea4f 0241 	mov.w	r2, r1, lsl #1
 802b8dc:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 802b8e0:	d215      	bcs.n	802b90e <__aeabi_d2iz+0x36>
 802b8e2:	d511      	bpl.n	802b908 <__aeabi_d2iz+0x30>
 802b8e4:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 802b8e8:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 802b8ec:	d912      	bls.n	802b914 <__aeabi_d2iz+0x3c>
 802b8ee:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 802b8f2:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 802b8f6:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 802b8fa:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 802b8fe:	fa23 f002 	lsr.w	r0, r3, r2
 802b902:	bf18      	it	ne
 802b904:	4240      	negne	r0, r0
 802b906:	4770      	bx	lr
 802b908:	f04f 0000 	mov.w	r0, #0
 802b90c:	4770      	bx	lr
 802b90e:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 802b912:	d105      	bne.n	802b920 <__aeabi_d2iz+0x48>
 802b914:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 802b918:	bf08      	it	eq
 802b91a:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 802b91e:	4770      	bx	lr
 802b920:	f04f 0000 	mov.w	r0, #0
 802b924:	4770      	bx	lr
 802b926:	bf00      	nop

0802b928 <__aeabi_frsub>:
 802b928:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
 802b92c:	e002      	b.n	802b934 <__addsf3>
 802b92e:	bf00      	nop

0802b930 <__aeabi_fsub>:
 802b930:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

0802b934 <__addsf3>:
 802b934:	0042      	lsls	r2, r0, #1
 802b936:	bf1f      	itttt	ne
 802b938:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 802b93c:	ea92 0f03 	teqne	r2, r3
 802b940:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 802b944:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 802b948:	d06a      	beq.n	802ba20 <__addsf3+0xec>
 802b94a:	ea4f 6212 	mov.w	r2, r2, lsr #24
 802b94e:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 802b952:	bfc1      	itttt	gt
 802b954:	18d2      	addgt	r2, r2, r3
 802b956:	4041      	eorgt	r1, r0
 802b958:	4048      	eorgt	r0, r1
 802b95a:	4041      	eorgt	r1, r0
 802b95c:	bfb8      	it	lt
 802b95e:	425b      	neglt	r3, r3
 802b960:	2b19      	cmp	r3, #25
 802b962:	bf88      	it	hi
 802b964:	4770      	bxhi	lr
 802b966:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 802b96a:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 802b96e:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 802b972:	bf18      	it	ne
 802b974:	4240      	negne	r0, r0
 802b976:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 802b97a:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 802b97e:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 802b982:	bf18      	it	ne
 802b984:	4249      	negne	r1, r1
 802b986:	ea92 0f03 	teq	r2, r3
 802b98a:	d03f      	beq.n	802ba0c <__addsf3+0xd8>
 802b98c:	f1a2 0201 	sub.w	r2, r2, #1
 802b990:	fa41 fc03 	asr.w	ip, r1, r3
 802b994:	eb10 000c 	adds.w	r0, r0, ip
 802b998:	f1c3 0320 	rsb	r3, r3, #32
 802b99c:	fa01 f103 	lsl.w	r1, r1, r3
 802b9a0:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 802b9a4:	d502      	bpl.n	802b9ac <__addsf3+0x78>
 802b9a6:	4249      	negs	r1, r1
 802b9a8:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 802b9ac:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 802b9b0:	d313      	bcc.n	802b9da <__addsf3+0xa6>
 802b9b2:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 802b9b6:	d306      	bcc.n	802b9c6 <__addsf3+0x92>
 802b9b8:	0840      	lsrs	r0, r0, #1
 802b9ba:	ea4f 0131 	mov.w	r1, r1, rrx
 802b9be:	f102 0201 	add.w	r2, r2, #1
 802b9c2:	2afe      	cmp	r2, #254	; 0xfe
 802b9c4:	d251      	bcs.n	802ba6a <__addsf3+0x136>
 802b9c6:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 802b9ca:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 802b9ce:	bf08      	it	eq
 802b9d0:	f020 0001 	biceq.w	r0, r0, #1
 802b9d4:	ea40 0003 	orr.w	r0, r0, r3
 802b9d8:	4770      	bx	lr
 802b9da:	0049      	lsls	r1, r1, #1
 802b9dc:	eb40 0000 	adc.w	r0, r0, r0
 802b9e0:	3a01      	subs	r2, #1
 802b9e2:	bf28      	it	cs
 802b9e4:	f5b0 0f00 	cmpcs.w	r0, #8388608	; 0x800000
 802b9e8:	d2ed      	bcs.n	802b9c6 <__addsf3+0x92>
 802b9ea:	fab0 fc80 	clz	ip, r0
 802b9ee:	f1ac 0c08 	sub.w	ip, ip, #8
 802b9f2:	ebb2 020c 	subs.w	r2, r2, ip
 802b9f6:	fa00 f00c 	lsl.w	r0, r0, ip
 802b9fa:	bfaa      	itet	ge
 802b9fc:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 802ba00:	4252      	neglt	r2, r2
 802ba02:	4318      	orrge	r0, r3
 802ba04:	bfbc      	itt	lt
 802ba06:	40d0      	lsrlt	r0, r2
 802ba08:	4318      	orrlt	r0, r3
 802ba0a:	4770      	bx	lr
 802ba0c:	f092 0f00 	teq	r2, #0
 802ba10:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
 802ba14:	bf06      	itte	eq
 802ba16:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
 802ba1a:	3201      	addeq	r2, #1
 802ba1c:	3b01      	subne	r3, #1
 802ba1e:	e7b5      	b.n	802b98c <__addsf3+0x58>
 802ba20:	ea4f 0341 	mov.w	r3, r1, lsl #1
 802ba24:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 802ba28:	bf18      	it	ne
 802ba2a:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 802ba2e:	d021      	beq.n	802ba74 <__addsf3+0x140>
 802ba30:	ea92 0f03 	teq	r2, r3
 802ba34:	d004      	beq.n	802ba40 <__addsf3+0x10c>
 802ba36:	f092 0f00 	teq	r2, #0
 802ba3a:	bf08      	it	eq
 802ba3c:	4608      	moveq	r0, r1
 802ba3e:	4770      	bx	lr
 802ba40:	ea90 0f01 	teq	r0, r1
 802ba44:	bf1c      	itt	ne
 802ba46:	2000      	movne	r0, #0
 802ba48:	4770      	bxne	lr
 802ba4a:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
 802ba4e:	d104      	bne.n	802ba5a <__addsf3+0x126>
 802ba50:	0040      	lsls	r0, r0, #1
 802ba52:	bf28      	it	cs
 802ba54:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
 802ba58:	4770      	bx	lr
 802ba5a:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 802ba5e:	bf3c      	itt	cc
 802ba60:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
 802ba64:	4770      	bxcc	lr
 802ba66:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 802ba6a:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
 802ba6e:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 802ba72:	4770      	bx	lr
 802ba74:	ea7f 6222 	mvns.w	r2, r2, asr #24
 802ba78:	bf16      	itet	ne
 802ba7a:	4608      	movne	r0, r1
 802ba7c:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 802ba80:	4601      	movne	r1, r0
 802ba82:	0242      	lsls	r2, r0, #9
 802ba84:	bf06      	itte	eq
 802ba86:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 802ba8a:	ea90 0f01 	teqeq	r0, r1
 802ba8e:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
 802ba92:	4770      	bx	lr

0802ba94 <__aeabi_ui2f>:
 802ba94:	f04f 0300 	mov.w	r3, #0
 802ba98:	e004      	b.n	802baa4 <__aeabi_i2f+0x8>
 802ba9a:	bf00      	nop

0802ba9c <__aeabi_i2f>:
 802ba9c:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
 802baa0:	bf48      	it	mi
 802baa2:	4240      	negmi	r0, r0
 802baa4:	ea5f 0c00 	movs.w	ip, r0
 802baa8:	bf08      	it	eq
 802baaa:	4770      	bxeq	lr
 802baac:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
 802bab0:	4601      	mov	r1, r0
 802bab2:	f04f 0000 	mov.w	r0, #0
 802bab6:	e01c      	b.n	802baf2 <__aeabi_l2f+0x2a>

0802bab8 <__aeabi_ul2f>:
 802bab8:	ea50 0201 	orrs.w	r2, r0, r1
 802babc:	bf08      	it	eq
 802babe:	4770      	bxeq	lr
 802bac0:	f04f 0300 	mov.w	r3, #0
 802bac4:	e00a      	b.n	802badc <__aeabi_l2f+0x14>
 802bac6:	bf00      	nop

0802bac8 <__aeabi_l2f>:
 802bac8:	ea50 0201 	orrs.w	r2, r0, r1
 802bacc:	bf08      	it	eq
 802bace:	4770      	bxeq	lr
 802bad0:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
 802bad4:	d502      	bpl.n	802badc <__aeabi_l2f+0x14>
 802bad6:	4240      	negs	r0, r0
 802bad8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 802badc:	ea5f 0c01 	movs.w	ip, r1
 802bae0:	bf02      	ittt	eq
 802bae2:	4684      	moveq	ip, r0
 802bae4:	4601      	moveq	r1, r0
 802bae6:	2000      	moveq	r0, #0
 802bae8:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
 802baec:	bf08      	it	eq
 802baee:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
 802baf2:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 802baf6:	fabc f28c 	clz	r2, ip
 802bafa:	3a08      	subs	r2, #8
 802bafc:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 802bb00:	db10      	blt.n	802bb24 <__aeabi_l2f+0x5c>
 802bb02:	fa01 fc02 	lsl.w	ip, r1, r2
 802bb06:	4463      	add	r3, ip
 802bb08:	fa00 fc02 	lsl.w	ip, r0, r2
 802bb0c:	f1c2 0220 	rsb	r2, r2, #32
 802bb10:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 802bb14:	fa20 f202 	lsr.w	r2, r0, r2
 802bb18:	eb43 0002 	adc.w	r0, r3, r2
 802bb1c:	bf08      	it	eq
 802bb1e:	f020 0001 	biceq.w	r0, r0, #1
 802bb22:	4770      	bx	lr
 802bb24:	f102 0220 	add.w	r2, r2, #32
 802bb28:	fa01 fc02 	lsl.w	ip, r1, r2
 802bb2c:	f1c2 0220 	rsb	r2, r2, #32
 802bb30:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 802bb34:	fa21 f202 	lsr.w	r2, r1, r2
 802bb38:	eb43 0002 	adc.w	r0, r3, r2
 802bb3c:	bf08      	it	eq
 802bb3e:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 802bb42:	4770      	bx	lr

0802bb44 <__aeabi_uldivmod>:
 802bb44:	b953      	cbnz	r3, 802bb5c <__aeabi_uldivmod+0x18>
 802bb46:	b94a      	cbnz	r2, 802bb5c <__aeabi_uldivmod+0x18>
 802bb48:	2900      	cmp	r1, #0
 802bb4a:	bf08      	it	eq
 802bb4c:	2800      	cmpeq	r0, #0
 802bb4e:	bf1c      	itt	ne
 802bb50:	f04f 31ff 	movne.w	r1, #4294967295
 802bb54:	f04f 30ff 	movne.w	r0, #4294967295
 802bb58:	f000 b96c 	b.w	802be34 <__aeabi_idiv0>
 802bb5c:	f1ad 0c08 	sub.w	ip, sp, #8
 802bb60:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 802bb64:	f000 f806 	bl	802bb74 <__udivmoddi4>
 802bb68:	f8dd e004 	ldr.w	lr, [sp, #4]
 802bb6c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 802bb70:	b004      	add	sp, #16
 802bb72:	4770      	bx	lr

0802bb74 <__udivmoddi4>:
 802bb74:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 802bb78:	9e08      	ldr	r6, [sp, #32]
 802bb7a:	460d      	mov	r5, r1
 802bb7c:	4604      	mov	r4, r0
 802bb7e:	468e      	mov	lr, r1
 802bb80:	2b00      	cmp	r3, #0
 802bb82:	f040 8082 	bne.w	802bc8a <__udivmoddi4+0x116>
 802bb86:	428a      	cmp	r2, r1
 802bb88:	4617      	mov	r7, r2
 802bb8a:	d946      	bls.n	802bc1a <__udivmoddi4+0xa6>
 802bb8c:	fab2 f282 	clz	r2, r2
 802bb90:	b14a      	cbz	r2, 802bba6 <__udivmoddi4+0x32>
 802bb92:	f1c2 0120 	rsb	r1, r2, #32
 802bb96:	fa05 f302 	lsl.w	r3, r5, r2
 802bb9a:	fa20 f101 	lsr.w	r1, r0, r1
 802bb9e:	4097      	lsls	r7, r2
 802bba0:	ea41 0e03 	orr.w	lr, r1, r3
 802bba4:	4094      	lsls	r4, r2
 802bba6:	ea4f 4817 	mov.w	r8, r7, lsr #16
 802bbaa:	0c23      	lsrs	r3, r4, #16
 802bbac:	fbbe fcf8 	udiv	ip, lr, r8
 802bbb0:	b2b9      	uxth	r1, r7
 802bbb2:	fb08 ee1c 	mls	lr, r8, ip, lr
 802bbb6:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
 802bbba:	fb0c f001 	mul.w	r0, ip, r1
 802bbbe:	4298      	cmp	r0, r3
 802bbc0:	d90a      	bls.n	802bbd8 <__udivmoddi4+0x64>
 802bbc2:	18fb      	adds	r3, r7, r3
 802bbc4:	f10c 35ff 	add.w	r5, ip, #4294967295
 802bbc8:	f080 8116 	bcs.w	802bdf8 <__udivmoddi4+0x284>
 802bbcc:	4298      	cmp	r0, r3
 802bbce:	f240 8113 	bls.w	802bdf8 <__udivmoddi4+0x284>
 802bbd2:	f1ac 0c02 	sub.w	ip, ip, #2
 802bbd6:	443b      	add	r3, r7
 802bbd8:	1a1b      	subs	r3, r3, r0
 802bbda:	b2a4      	uxth	r4, r4
 802bbdc:	fbb3 f0f8 	udiv	r0, r3, r8
 802bbe0:	fb08 3310 	mls	r3, r8, r0, r3
 802bbe4:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 802bbe8:	fb00 f101 	mul.w	r1, r0, r1
 802bbec:	42a1      	cmp	r1, r4
 802bbee:	d909      	bls.n	802bc04 <__udivmoddi4+0x90>
 802bbf0:	193c      	adds	r4, r7, r4
 802bbf2:	f100 33ff 	add.w	r3, r0, #4294967295
 802bbf6:	f080 8101 	bcs.w	802bdfc <__udivmoddi4+0x288>
 802bbfa:	42a1      	cmp	r1, r4
 802bbfc:	f240 80fe 	bls.w	802bdfc <__udivmoddi4+0x288>
 802bc00:	3802      	subs	r0, #2
 802bc02:	443c      	add	r4, r7
 802bc04:	1a64      	subs	r4, r4, r1
 802bc06:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 802bc0a:	2100      	movs	r1, #0
 802bc0c:	b11e      	cbz	r6, 802bc16 <__udivmoddi4+0xa2>
 802bc0e:	40d4      	lsrs	r4, r2
 802bc10:	2300      	movs	r3, #0
 802bc12:	e9c6 4300 	strd	r4, r3, [r6]
 802bc16:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802bc1a:	b902      	cbnz	r2, 802bc1e <__udivmoddi4+0xaa>
 802bc1c:	deff      	udf	#255	; 0xff
 802bc1e:	fab2 f282 	clz	r2, r2
 802bc22:	2a00      	cmp	r2, #0
 802bc24:	d14f      	bne.n	802bcc6 <__udivmoddi4+0x152>
 802bc26:	1bcb      	subs	r3, r1, r7
 802bc28:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 802bc2c:	fa1f f887 	uxth.w	r8, r7
 802bc30:	2101      	movs	r1, #1
 802bc32:	fbb3 fcfe 	udiv	ip, r3, lr
 802bc36:	0c25      	lsrs	r5, r4, #16
 802bc38:	fb0e 331c 	mls	r3, lr, ip, r3
 802bc3c:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 802bc40:	fb08 f30c 	mul.w	r3, r8, ip
 802bc44:	42ab      	cmp	r3, r5
 802bc46:	d907      	bls.n	802bc58 <__udivmoddi4+0xe4>
 802bc48:	197d      	adds	r5, r7, r5
 802bc4a:	f10c 30ff 	add.w	r0, ip, #4294967295
 802bc4e:	d202      	bcs.n	802bc56 <__udivmoddi4+0xe2>
 802bc50:	42ab      	cmp	r3, r5
 802bc52:	f200 80e7 	bhi.w	802be24 <__udivmoddi4+0x2b0>
 802bc56:	4684      	mov	ip, r0
 802bc58:	1aed      	subs	r5, r5, r3
 802bc5a:	b2a3      	uxth	r3, r4
 802bc5c:	fbb5 f0fe 	udiv	r0, r5, lr
 802bc60:	fb0e 5510 	mls	r5, lr, r0, r5
 802bc64:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
 802bc68:	fb08 f800 	mul.w	r8, r8, r0
 802bc6c:	45a0      	cmp	r8, r4
 802bc6e:	d907      	bls.n	802bc80 <__udivmoddi4+0x10c>
 802bc70:	193c      	adds	r4, r7, r4
 802bc72:	f100 33ff 	add.w	r3, r0, #4294967295
 802bc76:	d202      	bcs.n	802bc7e <__udivmoddi4+0x10a>
 802bc78:	45a0      	cmp	r8, r4
 802bc7a:	f200 80d7 	bhi.w	802be2c <__udivmoddi4+0x2b8>
 802bc7e:	4618      	mov	r0, r3
 802bc80:	eba4 0408 	sub.w	r4, r4, r8
 802bc84:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 802bc88:	e7c0      	b.n	802bc0c <__udivmoddi4+0x98>
 802bc8a:	428b      	cmp	r3, r1
 802bc8c:	d908      	bls.n	802bca0 <__udivmoddi4+0x12c>
 802bc8e:	2e00      	cmp	r6, #0
 802bc90:	f000 80af 	beq.w	802bdf2 <__udivmoddi4+0x27e>
 802bc94:	2100      	movs	r1, #0
 802bc96:	e9c6 0500 	strd	r0, r5, [r6]
 802bc9a:	4608      	mov	r0, r1
 802bc9c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802bca0:	fab3 f183 	clz	r1, r3
 802bca4:	2900      	cmp	r1, #0
 802bca6:	d14b      	bne.n	802bd40 <__udivmoddi4+0x1cc>
 802bca8:	42ab      	cmp	r3, r5
 802bcaa:	d302      	bcc.n	802bcb2 <__udivmoddi4+0x13e>
 802bcac:	4282      	cmp	r2, r0
 802bcae:	f200 80b7 	bhi.w	802be20 <__udivmoddi4+0x2ac>
 802bcb2:	1a84      	subs	r4, r0, r2
 802bcb4:	eb65 0303 	sbc.w	r3, r5, r3
 802bcb8:	2001      	movs	r0, #1
 802bcba:	469e      	mov	lr, r3
 802bcbc:	2e00      	cmp	r6, #0
 802bcbe:	d0aa      	beq.n	802bc16 <__udivmoddi4+0xa2>
 802bcc0:	e9c6 4e00 	strd	r4, lr, [r6]
 802bcc4:	e7a7      	b.n	802bc16 <__udivmoddi4+0xa2>
 802bcc6:	f1c2 0c20 	rsb	ip, r2, #32
 802bcca:	fa01 f302 	lsl.w	r3, r1, r2
 802bcce:	4097      	lsls	r7, r2
 802bcd0:	fa20 f00c 	lsr.w	r0, r0, ip
 802bcd4:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 802bcd8:	fa21 fc0c 	lsr.w	ip, r1, ip
 802bcdc:	4318      	orrs	r0, r3
 802bcde:	fbbc f1fe 	udiv	r1, ip, lr
 802bce2:	0c05      	lsrs	r5, r0, #16
 802bce4:	fb0e cc11 	mls	ip, lr, r1, ip
 802bce8:	fa1f f887 	uxth.w	r8, r7
 802bcec:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
 802bcf0:	fb01 f308 	mul.w	r3, r1, r8
 802bcf4:	42ab      	cmp	r3, r5
 802bcf6:	fa04 f402 	lsl.w	r4, r4, r2
 802bcfa:	d909      	bls.n	802bd10 <__udivmoddi4+0x19c>
 802bcfc:	197d      	adds	r5, r7, r5
 802bcfe:	f101 3cff 	add.w	ip, r1, #4294967295
 802bd02:	f080 808b 	bcs.w	802be1c <__udivmoddi4+0x2a8>
 802bd06:	42ab      	cmp	r3, r5
 802bd08:	f240 8088 	bls.w	802be1c <__udivmoddi4+0x2a8>
 802bd0c:	3902      	subs	r1, #2
 802bd0e:	443d      	add	r5, r7
 802bd10:	1aeb      	subs	r3, r5, r3
 802bd12:	b285      	uxth	r5, r0
 802bd14:	fbb3 f0fe 	udiv	r0, r3, lr
 802bd18:	fb0e 3310 	mls	r3, lr, r0, r3
 802bd1c:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 802bd20:	fb00 f308 	mul.w	r3, r0, r8
 802bd24:	42ab      	cmp	r3, r5
 802bd26:	d907      	bls.n	802bd38 <__udivmoddi4+0x1c4>
 802bd28:	197d      	adds	r5, r7, r5
 802bd2a:	f100 3cff 	add.w	ip, r0, #4294967295
 802bd2e:	d271      	bcs.n	802be14 <__udivmoddi4+0x2a0>
 802bd30:	42ab      	cmp	r3, r5
 802bd32:	d96f      	bls.n	802be14 <__udivmoddi4+0x2a0>
 802bd34:	3802      	subs	r0, #2
 802bd36:	443d      	add	r5, r7
 802bd38:	1aeb      	subs	r3, r5, r3
 802bd3a:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 802bd3e:	e778      	b.n	802bc32 <__udivmoddi4+0xbe>
 802bd40:	f1c1 0c20 	rsb	ip, r1, #32
 802bd44:	408b      	lsls	r3, r1
 802bd46:	fa22 f70c 	lsr.w	r7, r2, ip
 802bd4a:	431f      	orrs	r7, r3
 802bd4c:	fa20 f40c 	lsr.w	r4, r0, ip
 802bd50:	fa05 f301 	lsl.w	r3, r5, r1
 802bd54:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 802bd58:	fa25 f50c 	lsr.w	r5, r5, ip
 802bd5c:	431c      	orrs	r4, r3
 802bd5e:	0c23      	lsrs	r3, r4, #16
 802bd60:	fbb5 f9fe 	udiv	r9, r5, lr
 802bd64:	fa1f f887 	uxth.w	r8, r7
 802bd68:	fb0e 5519 	mls	r5, lr, r9, r5
 802bd6c:	ea43 4505 	orr.w	r5, r3, r5, lsl #16
 802bd70:	fb09 fa08 	mul.w	sl, r9, r8
 802bd74:	45aa      	cmp	sl, r5
 802bd76:	fa02 f201 	lsl.w	r2, r2, r1
 802bd7a:	fa00 f301 	lsl.w	r3, r0, r1
 802bd7e:	d908      	bls.n	802bd92 <__udivmoddi4+0x21e>
 802bd80:	197d      	adds	r5, r7, r5
 802bd82:	f109 30ff 	add.w	r0, r9, #4294967295
 802bd86:	d247      	bcs.n	802be18 <__udivmoddi4+0x2a4>
 802bd88:	45aa      	cmp	sl, r5
 802bd8a:	d945      	bls.n	802be18 <__udivmoddi4+0x2a4>
 802bd8c:	f1a9 0902 	sub.w	r9, r9, #2
 802bd90:	443d      	add	r5, r7
 802bd92:	eba5 050a 	sub.w	r5, r5, sl
 802bd96:	b2a4      	uxth	r4, r4
 802bd98:	fbb5 f0fe 	udiv	r0, r5, lr
 802bd9c:	fb0e 5510 	mls	r5, lr, r0, r5
 802bda0:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 802bda4:	fb00 f808 	mul.w	r8, r0, r8
 802bda8:	45a0      	cmp	r8, r4
 802bdaa:	d907      	bls.n	802bdbc <__udivmoddi4+0x248>
 802bdac:	193c      	adds	r4, r7, r4
 802bdae:	f100 35ff 	add.w	r5, r0, #4294967295
 802bdb2:	d22d      	bcs.n	802be10 <__udivmoddi4+0x29c>
 802bdb4:	45a0      	cmp	r8, r4
 802bdb6:	d92b      	bls.n	802be10 <__udivmoddi4+0x29c>
 802bdb8:	3802      	subs	r0, #2
 802bdba:	443c      	add	r4, r7
 802bdbc:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 802bdc0:	eba4 0408 	sub.w	r4, r4, r8
 802bdc4:	fba0 8902 	umull	r8, r9, r0, r2
 802bdc8:	454c      	cmp	r4, r9
 802bdca:	46c6      	mov	lr, r8
 802bdcc:	464d      	mov	r5, r9
 802bdce:	d319      	bcc.n	802be04 <__udivmoddi4+0x290>
 802bdd0:	d016      	beq.n	802be00 <__udivmoddi4+0x28c>
 802bdd2:	b15e      	cbz	r6, 802bdec <__udivmoddi4+0x278>
 802bdd4:	ebb3 020e 	subs.w	r2, r3, lr
 802bdd8:	eb64 0405 	sbc.w	r4, r4, r5
 802bddc:	fa04 fc0c 	lsl.w	ip, r4, ip
 802bde0:	40ca      	lsrs	r2, r1
 802bde2:	ea4c 0202 	orr.w	r2, ip, r2
 802bde6:	40cc      	lsrs	r4, r1
 802bde8:	e9c6 2400 	strd	r2, r4, [r6]
 802bdec:	2100      	movs	r1, #0
 802bdee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802bdf2:	4631      	mov	r1, r6
 802bdf4:	4630      	mov	r0, r6
 802bdf6:	e70e      	b.n	802bc16 <__udivmoddi4+0xa2>
 802bdf8:	46ac      	mov	ip, r5
 802bdfa:	e6ed      	b.n	802bbd8 <__udivmoddi4+0x64>
 802bdfc:	4618      	mov	r0, r3
 802bdfe:	e701      	b.n	802bc04 <__udivmoddi4+0x90>
 802be00:	4543      	cmp	r3, r8
 802be02:	d2e6      	bcs.n	802bdd2 <__udivmoddi4+0x25e>
 802be04:	ebb8 0e02 	subs.w	lr, r8, r2
 802be08:	eb69 0507 	sbc.w	r5, r9, r7
 802be0c:	3801      	subs	r0, #1
 802be0e:	e7e0      	b.n	802bdd2 <__udivmoddi4+0x25e>
 802be10:	4628      	mov	r0, r5
 802be12:	e7d3      	b.n	802bdbc <__udivmoddi4+0x248>
 802be14:	4660      	mov	r0, ip
 802be16:	e78f      	b.n	802bd38 <__udivmoddi4+0x1c4>
 802be18:	4681      	mov	r9, r0
 802be1a:	e7ba      	b.n	802bd92 <__udivmoddi4+0x21e>
 802be1c:	4661      	mov	r1, ip
 802be1e:	e777      	b.n	802bd10 <__udivmoddi4+0x19c>
 802be20:	4608      	mov	r0, r1
 802be22:	e74b      	b.n	802bcbc <__udivmoddi4+0x148>
 802be24:	f1ac 0c02 	sub.w	ip, ip, #2
 802be28:	443d      	add	r5, r7
 802be2a:	e715      	b.n	802bc58 <__udivmoddi4+0xe4>
 802be2c:	3802      	subs	r0, #2
 802be2e:	443c      	add	r4, r7
 802be30:	e726      	b.n	802bc80 <__udivmoddi4+0x10c>
 802be32:	bf00      	nop

0802be34 <__aeabi_idiv0>:
 802be34:	4770      	bx	lr
 802be36:	bf00      	nop

0802be38 <MX_ADC_Init>:
  /* USER CODE BEGIN ADC_Init 1 */

  /* USER CODE END ADC_Init 1 */
  /** Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion)
  */
  hadc.Instance = ADC;
 802be38:	4813      	ldr	r0, [pc, #76]	; (802be88 <MX_ADC_Init+0x50>)
  hadc.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
 802be3a:	4a14      	ldr	r2, [pc, #80]	; (802be8c <MX_ADC_Init+0x54>)
{
 802be3c:	b508      	push	{r3, lr}
  hadc.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
 802be3e:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 802be42:	e9c0 2300 	strd	r2, r3, [r0]
  hadc.Init.Resolution = ADC_RESOLUTION_12B;
  hadc.Init.DataAlign = ADC_DATAALIGN_RIGHT;
  hadc.Init.ScanConvMode = ADC_SCAN_DISABLE;
  hadc.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 802be46:	2204      	movs	r2, #4
  hadc.Init.Resolution = ADC_RESOLUTION_12B;
 802be48:	2300      	movs	r3, #0
  hadc.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 802be4a:	6142      	str	r2, [r0, #20]
  hadc.Init.LowPowerAutoWait = DISABLE;
  hadc.Init.LowPowerAutoPowerOff = DISABLE;
  hadc.Init.ContinuousConvMode = DISABLE;
  hadc.Init.NbrOfConversion = 1;
 802be4c:	2201      	movs	r2, #1
 802be4e:	61c2      	str	r2, [r0, #28]
  hadc.Init.DiscontinuousConvMode = DISABLE;
  hadc.Init.ExternalTrigConv = ADC_SOFTWARE_START;
  hadc.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
  hadc.Init.DMAContinuousRequests = DISABLE;
  hadc.Init.Overrun = ADC_OVR_DATA_OVERWRITTEN;
  hadc.Init.SamplingTimeCommon1 = ADC_SAMPLETIME_160CYCLES_5;
 802be50:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 802be54:	2207      	movs	r2, #7
  hadc.Init.LowPowerAutoWait = DISABLE;
 802be56:	8303      	strh	r3, [r0, #24]
  hadc.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 802be58:	e9c0 3302 	strd	r3, r3, [r0, #8]
  hadc.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 802be5c:	e9c0 3309 	strd	r3, r3, [r0, #36]	; 0x24
  hadc.Init.SamplingTimeCommon1 = ADC_SAMPLETIME_160CYCLES_5;
 802be60:	e9c0 120c 	strd	r1, r2, [r0, #48]	; 0x30
  hadc.Init.ScanConvMode = ADC_SCAN_DISABLE;
 802be64:	6103      	str	r3, [r0, #16]
  hadc.Init.ContinuousConvMode = DISABLE;
 802be66:	7683      	strb	r3, [r0, #26]
  hadc.Init.DiscontinuousConvMode = DISABLE;
 802be68:	f880 3020 	strb.w	r3, [r0, #32]
  hadc.Init.DMAContinuousRequests = DISABLE;
 802be6c:	f880 302c 	strb.w	r3, [r0, #44]	; 0x2c
  hadc.Init.SamplingTimeCommon2 = ADC_SAMPLETIME_160CYCLES_5;
 802be70:	6382      	str	r2, [r0, #56]	; 0x38
  hadc.Init.OversamplingMode = DISABLE;
 802be72:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  hadc.Init.TriggerFrequencyMode = ADC_TRIGGER_FREQ_HIGH;
 802be76:	64c3      	str	r3, [r0, #76]	; 0x4c
  if (HAL_ADC_Init(&hadc) != HAL_OK)
 802be78:	f001 fb46 	bl	802d508 <HAL_ADC_Init>
 802be7c:	b118      	cbz	r0, 802be86 <MX_ADC_Init+0x4e>
  }
  /* USER CODE BEGIN ADC_Init 2 */

  /* USER CODE END ADC_Init 2 */

}
 802be7e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 802be82:	f000 ba17 	b.w	802c2b4 <Error_Handler>
}
 802be86:	bd08      	pop	{r3, pc}
 802be88:	20006154 	.word	0x20006154
 802be8c:	40012400 	.word	0x40012400

0802be90 <HAL_ADC_MspInit>:

void HAL_ADC_MspInit(ADC_HandleTypeDef* adcHandle)
{

  if(adcHandle->Instance==ADC)
 802be90:	6802      	ldr	r2, [r0, #0]
 802be92:	4b08      	ldr	r3, [pc, #32]	; (802beb4 <HAL_ADC_MspInit+0x24>)
 802be94:	429a      	cmp	r2, r3
{
 802be96:	b082      	sub	sp, #8
  if(adcHandle->Instance==ADC)
 802be98:	d10a      	bne.n	802beb0 <HAL_ADC_MspInit+0x20>
  * @retval None
  */
__STATIC_INLINE void LL_APB2_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB2ENR, Periphs);
 802be9a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802be9e:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 802bea0:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 802bea4:	661a      	str	r2, [r3, #96]	; 0x60
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
 802bea6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 802bea8:	f403 7300 	and.w	r3, r3, #512	; 0x200
 802beac:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 802beae:	9b01      	ldr	r3, [sp, #4]
    __HAL_RCC_ADC_CLK_ENABLE();
  /* USER CODE BEGIN ADC_MspInit 1 */

  /* USER CODE END ADC_MspInit 1 */
  }
}
 802beb0:	b002      	add	sp, #8
 802beb2:	4770      	bx	lr
 802beb4:	40012400 	.word	0x40012400

0802beb8 <HAL_ADC_MspDeInit>:

void HAL_ADC_MspDeInit(ADC_HandleTypeDef* adcHandle)
{

  if(adcHandle->Instance==ADC)
 802beb8:	6802      	ldr	r2, [r0, #0]
 802beba:	4b05      	ldr	r3, [pc, #20]	; (802bed0 <HAL_ADC_MspDeInit+0x18>)
 802bebc:	429a      	cmp	r2, r3
  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM17
  * @retval None
  */
__STATIC_INLINE void LL_APB2_GRP1_DisableClock(uint32_t Periphs)
{
  CLEAR_BIT(RCC->APB2ENR, Periphs);
 802bebe:	bf01      	itttt	eq
 802bec0:	f04f 42b0 	moveq.w	r2, #1476395008	; 0x58000000
 802bec4:	6e13      	ldreq	r3, [r2, #96]	; 0x60
 802bec6:	f423 7300 	biceq.w	r3, r3, #512	; 0x200
 802beca:	6613      	streq	r3, [r2, #96]	; 0x60
    __HAL_RCC_ADC_CLK_DISABLE();
  /* USER CODE BEGIN ADC_MspDeInit 1 */

  /* USER CODE END ADC_MspDeInit 1 */
  }
}
 802becc:	4770      	bx	lr
 802bece:	bf00      	nop
 802bed0:	40012400 	.word	0x40012400

0802bed4 <ADC_ReadChannels>:
/* USER CODE BEGIN PrFD */

/* USER CODE END PrFD */

static uint32_t ADC_ReadChannels(uint32_t channel)
{
 802bed4:	b530      	push	{r4, r5, lr}
 802bed6:	b085      	sub	sp, #20
  /* USER CODE BEGIN ADC_ReadChannels_1 */

  /* USER CODE END ADC_ReadChannels_1 */
  uint32_t ADCxConvertedValues = 0;
  ADC_ChannelConfTypeDef sConfig = {0};
 802bed8:	2400      	movs	r4, #0
{
 802beda:	4605      	mov	r5, r0
  ADC_ChannelConfTypeDef sConfig = {0};
 802bedc:	e9cd 4401 	strd	r4, r4, [sp, #4]
 802bee0:	9403      	str	r4, [sp, #12]

  MX_ADC_Init();
 802bee2:	f7ff ffa9 	bl	802be38 <MX_ADC_Init>

  /* Start Calibration */
  if (HAL_ADCEx_Calibration_Start(&hadc) != HAL_OK)
 802bee6:	4814      	ldr	r0, [pc, #80]	; (802bf38 <ADC_ReadChannels+0x64>)
 802bee8:	f001 feb6 	bl	802dc58 <HAL_ADCEx_Calibration_Start>
 802beec:	b108      	cbz	r0, 802bef2 <ADC_ReadChannels+0x1e>
  {
    Error_Handler();
 802beee:	f000 f9e1 	bl	802c2b4 <Error_Handler>

  /* Configure Regular Channel */
  sConfig.Channel = channel;
  sConfig.Rank = ADC_REGULAR_RANK_1;
  sConfig.SamplingTime = ADC_SAMPLINGTIME_COMMON_1;
  if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 802bef2:	4811      	ldr	r0, [pc, #68]	; (802bf38 <ADC_ReadChannels+0x64>)
  sConfig.SamplingTime = ADC_SAMPLINGTIME_COMMON_1;
 802bef4:	9403      	str	r4, [sp, #12]
  if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 802bef6:	a901      	add	r1, sp, #4
  sConfig.Rank = ADC_REGULAR_RANK_1;
 802bef8:	e9cd 5401 	strd	r5, r4, [sp, #4]
  if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 802befc:	f001 fc86 	bl	802d80c <HAL_ADC_ConfigChannel>
 802bf00:	b108      	cbz	r0, 802bf06 <ADC_ReadChannels+0x32>
  {
    Error_Handler();
 802bf02:	f000 f9d7 	bl	802c2b4 <Error_Handler>
  }

  if (HAL_ADC_Start(&hadc) != HAL_OK)
 802bf06:	480c      	ldr	r0, [pc, #48]	; (802bf38 <ADC_ReadChannels+0x64>)
 802bf08:	f001 fdda 	bl	802dac0 <HAL_ADC_Start>
 802bf0c:	b108      	cbz	r0, 802bf12 <ADC_ReadChannels+0x3e>
  {
    /* Start Error */
    Error_Handler();
 802bf0e:	f000 f9d1 	bl	802c2b4 <Error_Handler>
  }
  /** Wait for end of conversion */
  HAL_ADC_PollForConversion(&hadc, HAL_MAX_DELAY);
 802bf12:	f04f 31ff 	mov.w	r1, #4294967295
 802bf16:	4808      	ldr	r0, [pc, #32]	; (802bf38 <ADC_ReadChannels+0x64>)
 802bf18:	f001 fc1a 	bl	802d750 <HAL_ADC_PollForConversion>

  /** Wait for end of conversion */
  HAL_ADC_Stop(&hadc) ;   /* it calls also ADC_Disable() */
 802bf1c:	4806      	ldr	r0, [pc, #24]	; (802bf38 <ADC_ReadChannels+0x64>)
 802bf1e:	f001 fe7d 	bl	802dc1c <HAL_ADC_Stop>

  ADCxConvertedValues = HAL_ADC_GetValue(&hadc);
 802bf22:	4805      	ldr	r0, [pc, #20]	; (802bf38 <ADC_ReadChannels+0x64>)
 802bf24:	f001 fc6f 	bl	802d806 <HAL_ADC_GetValue>
 802bf28:	4604      	mov	r4, r0

  HAL_ADC_DeInit(&hadc);
 802bf2a:	4803      	ldr	r0, [pc, #12]	; (802bf38 <ADC_ReadChannels+0x64>)
 802bf2c:	f001 fe2a 	bl	802db84 <HAL_ADC_DeInit>

  return ADCxConvertedValues;
  /* USER CODE BEGIN ADC_ReadChannels_2 */

  /* USER CODE END ADC_ReadChannels_2 */
}
 802bf30:	4620      	mov	r0, r4
 802bf32:	b005      	add	sp, #20
 802bf34:	bd30      	pop	{r4, r5, pc}
 802bf36:	bf00      	nop
 802bf38:	20006154 	.word	0x20006154

0802bf3c <SYS_InitMeasurement>:
  hadc.Instance = ADC;
 802bf3c:	4b01      	ldr	r3, [pc, #4]	; (802bf44 <SYS_InitMeasurement+0x8>)
 802bf3e:	4a02      	ldr	r2, [pc, #8]	; (802bf48 <SYS_InitMeasurement+0xc>)
 802bf40:	601a      	str	r2, [r3, #0]
}
 802bf42:	4770      	bx	lr
 802bf44:	20006154 	.word	0x20006154
 802bf48:	40012400 	.word	0x40012400

0802bf4c <SYS_GetBatteryLevel>:
{
 802bf4c:	b508      	push	{r3, lr}
  measuredLevel = ADC_ReadChannels(ADC_CHANNEL_VREFINT);
 802bf4e:	4809      	ldr	r0, [pc, #36]	; (802bf74 <SYS_GetBatteryLevel+0x28>)
 802bf50:	f7ff ffc0 	bl	802bed4 <ADC_ReadChannels>
  if (measuredLevel == 0)
 802bf54:	b160      	cbz	r0, 802bf70 <SYS_GetBatteryLevel+0x24>
    if ((uint32_t)*VREFINT_CAL_ADDR != (uint32_t)0xFFFFU)
 802bf56:	4b08      	ldr	r3, [pc, #32]	; (802bf78 <SYS_GetBatteryLevel+0x2c>)
 802bf58:	881a      	ldrh	r2, [r3, #0]
 802bf5a:	f64f 73ff 	movw	r3, #65535	; 0xffff
 802bf5e:	429a      	cmp	r2, r3
      batteryLevelmV = __LL_ADC_CALC_VREFANALOG_VOLTAGE(measuredLevel,
 802bf60:	bf16      	itet	ne
 802bf62:	f640 43e4 	movwne	r3, #3300	; 0xce4
      batteryLevelmV = (VREFINT_CAL_VREF * 1510) / measuredLevel;
 802bf66:	4b05      	ldreq	r3, [pc, #20]	; (802bf7c <SYS_GetBatteryLevel+0x30>)
      batteryLevelmV = __LL_ADC_CALC_VREFANALOG_VOLTAGE(measuredLevel,
 802bf68:	4353      	mulne	r3, r2
      batteryLevelmV = (VREFINT_CAL_VREF * 1510) / measuredLevel;
 802bf6a:	fbb3 f0f0 	udiv	r0, r3, r0
 802bf6e:	b280      	uxth	r0, r0
}
 802bf70:	bd08      	pop	{r3, pc}
 802bf72:	bf00      	nop
 802bf74:	b4002000 	.word	0xb4002000
 802bf78:	1fff75aa 	.word	0x1fff75aa
 802bf7c:	004c08d8 	.word	0x004c08d8

0802bf80 <SYS_GetTemperatureLevel>:
{
 802bf80:	b513      	push	{r0, r1, r4, lr}
  uint16_t batteryLevelmV = SYS_GetBatteryLevel();
 802bf82:	f7ff ffe3 	bl	802bf4c <SYS_GetBatteryLevel>
 802bf86:	4604      	mov	r4, r0
  measuredLevel = ADC_ReadChannels(ADC_CHANNEL_TEMPSENSOR);
 802bf88:	4818      	ldr	r0, [pc, #96]	; (802bfec <SYS_GetTemperatureLevel+0x6c>)
 802bf8a:	f7ff ffa3 	bl	802bed4 <ADC_ReadChannels>
  if (((int32_t)*TEMPSENSOR_CAL2_ADDR - (int32_t)*TEMPSENSOR_CAL1_ADDR) != 0)
 802bf8e:	4b18      	ldr	r3, [pc, #96]	; (802bff0 <SYS_GetTemperatureLevel+0x70>)
 802bf90:	4a18      	ldr	r2, [pc, #96]	; (802bff4 <SYS_GetTemperatureLevel+0x74>)
 802bf92:	881b      	ldrh	r3, [r3, #0]
 802bf94:	8812      	ldrh	r2, [r2, #0]
 802bf96:	4293      	cmp	r3, r2
 802bf98:	fb00 f004 	mul.w	r0, r0, r4
 802bf9c:	d016      	beq.n	802bfcc <SYS_GetTemperatureLevel+0x4c>
    temperatureDegreeC = __LL_ADC_CALC_TEMPERATURE(batteryLevelmV,
 802bf9e:	f640 44e4 	movw	r4, #3300	; 0xce4
 802bfa2:	fbb0 f0f4 	udiv	r0, r0, r4
 802bfa6:	2464      	movs	r4, #100	; 0x64
 802bfa8:	1a80      	subs	r0, r0, r2
 802bfaa:	4344      	muls	r4, r0
 802bfac:	1a9b      	subs	r3, r3, r2
 802bfae:	fb94 f4f3 	sdiv	r4, r4, r3
    temperatureDegreeC = __LL_ADC_CALC_TEMPERATURE_TYP_PARAMS(TEMPSENSOR_TYP_AVGSLOPE,
 802bfb2:	341e      	adds	r4, #30
 802bfb4:	b224      	sxth	r4, r4
  APP_LOG(TS_ON, VLEVEL_L, "temp= %d\n\r", temperatureDegreeC);
 802bfb6:	2201      	movs	r2, #1
 802bfb8:	4b0f      	ldr	r3, [pc, #60]	; (802bff8 <SYS_GetTemperatureLevel+0x78>)
 802bfba:	9400      	str	r4, [sp, #0]
 802bfbc:	2100      	movs	r1, #0
 802bfbe:	4610      	mov	r0, r2
 802bfc0:	f00e fe70 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
  temperatureDegreeC <<= 8;
 802bfc4:	0220      	lsls	r0, r4, #8
}
 802bfc6:	b200      	sxth	r0, r0
 802bfc8:	b002      	add	sp, #8
 802bfca:	bd10      	pop	{r4, pc}
    temperatureDegreeC = __LL_ADC_CALC_TEMPERATURE_TYP_PARAMS(TEMPSENSOR_TYP_AVGSLOPE,
 802bfcc:	f640 74ff 	movw	r4, #4095	; 0xfff
 802bfd0:	fbb0 f0f4 	udiv	r0, r0, r4
 802bfd4:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 802bfd8:	4344      	muls	r4, r0
 802bfda:	f5a4 2439 	sub.w	r4, r4, #757760	; 0xb9000
 802bfde:	f5a4 640c 	sub.w	r4, r4, #2240	; 0x8c0
 802bfe2:	f640 10c4 	movw	r0, #2500	; 0x9c4
 802bfe6:	fb94 f4f0 	sdiv	r4, r4, r0
 802bfea:	e7e2      	b.n	802bfb2 <SYS_GetTemperatureLevel+0x32>
 802bfec:	b0001000 	.word	0xb0001000
 802bff0:	1fff75c8 	.word	0x1fff75c8
 802bff4:	1fff75a8 	.word	0x1fff75a8
 802bff8:	0803bd30 	.word	0x0803bd30

0802bffc <MX_DMA_Init>:
  SET_BIT(RCC->AHB1ENR, Periphs);
 802bffc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000

/**
  * Enable DMA controller clock
  */
void MX_DMA_Init(void)
{
 802c000:	b507      	push	{r0, r1, r2, lr}
 802c002:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 802c004:	f042 0204 	orr.w	r2, r2, #4
 802c008:	649a      	str	r2, [r3, #72]	; 0x48
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 802c00a:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 802c00c:	f002 0204 	and.w	r2, r2, #4
 802c010:	9201      	str	r2, [sp, #4]
  (void)tmpreg;
 802c012:	9a01      	ldr	r2, [sp, #4]
  SET_BIT(RCC->AHB1ENR, Periphs);
 802c014:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 802c016:	f042 0201 	orr.w	r2, r2, #1
 802c01a:	649a      	str	r2, [r3, #72]	; 0x48
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 802c01c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 802c01e:	f003 0301 	and.w	r3, r3, #1
 802c022:	9300      	str	r3, [sp, #0]
  __HAL_RCC_DMAMUX1_CLK_ENABLE();
  __HAL_RCC_DMA1_CLK_ENABLE();

  /* DMA interrupt init */
  /* DMA1_Channel5_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Channel5_IRQn, 2, 0);
 802c024:	2200      	movs	r2, #0
 802c026:	2102      	movs	r1, #2
 802c028:	200f      	movs	r0, #15
  (void)tmpreg;
 802c02a:	9b00      	ldr	r3, [sp, #0]
 802c02c:	f001 fe72 	bl	802dd14 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel5_IRQn);
 802c030:	200f      	movs	r0, #15

}
 802c032:	b003      	add	sp, #12
 802c034:	f85d eb04 	ldr.w	lr, [sp], #4
  HAL_NVIC_EnableIRQ(DMA1_Channel5_IRQn);
 802c038:	f001 be9e 	b.w	802dd78 <HAL_NVIC_EnableIRQ>

0802c03c <FLASH_IF_Write64>:

  /* USER CODE END FLASH_IF_Write_2 */
}

int32_t FLASH_IF_Write64(uint32_t address, uint64_t data)
{
 802c03c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
__STATIC_INLINE uint32_t LL_FLASH_IsActiveFlag_OperationSuspended(void)
{
#if defined(CORE_CM0PLUS)
  return ((READ_BIT(FLASH->C2SR, FLASH_C2SR_PESD) == (FLASH_C2SR_PESD)) ? 1UL : 0UL);
#else
  return ((READ_BIT(FLASH->SR, FLASH_SR_PESD) == (FLASH_SR_PESD)) ? 1UL : 0UL);
 802c03e:	4f0b      	ldr	r7, [pc, #44]	; (802c06c <FLASH_IF_Write64+0x30>)
 802c040:	4606      	mov	r6, r0
 802c042:	4614      	mov	r4, r2
 802c044:	461d      	mov	r5, r3
  /* USER CODE BEGIN FLASH_IF_Write64_1 */

  /* USER CODE END FLASH_IF_Write64_1 */
  while (*(uint64_t *)address != data)
 802c046:	e9d6 2300 	ldrd	r2, r3, [r6]
 802c04a:	42ab      	cmp	r3, r5
 802c04c:	bf08      	it	eq
 802c04e:	42a2      	cmpeq	r2, r4
 802c050:	d101      	bne.n	802c056 <FLASH_IF_Write64+0x1a>

  return FLASH_OK;
  /* USER CODE BEGIN HW_FLASH_Write_2 */

  /* USER CODE END HW_FLASH_Write_2 */
}
 802c052:	2000      	movs	r0, #0
 802c054:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802c056:	693b      	ldr	r3, [r7, #16]
 802c058:	031b      	lsls	r3, r3, #12
 802c05a:	d4fc      	bmi.n	802c056 <FLASH_IF_Write64+0x1a>
    HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, address, data);
 802c05c:	4622      	mov	r2, r4
 802c05e:	462b      	mov	r3, r5
 802c060:	4631      	mov	r1, r6
 802c062:	2001      	movs	r0, #1
 802c064:	f002 f93e 	bl	802e2e4 <HAL_FLASH_Program>
 802c068:	e7ed      	b.n	802c046 <FLASH_IF_Write64+0xa>
 802c06a:	bf00      	nop
 802c06c:	58004000 	.word	0x58004000

0802c070 <FLASH_IF_Write_Buffer>:

/* USER CODE END EF */

/* Private Functions Definition -----------------------------------------------*/
static int32_t FLASH_IF_Write_Buffer(uint32_t pDestination, uint8_t *pSource, uint32_t uLength)
{
 802c070:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 802c072:	f022 0507 	bic.w	r5, r2, #7
 802c076:	4604      	mov	r4, r0
 802c078:	4405      	add	r5, r0
 802c07a:	1a0e      	subs	r6, r1, r0
  /* USER CODE END FLASH_IF_Write_Buffer_1 */
  uint8_t *pSrc = pSource;
  uint64_t src_value;
  int32_t status = FLASH_OK;

  for (uint32_t i = 0; i < (uLength / sizeof(uint64_t)); i++)
 802c07c:	42ac      	cmp	r4, r5
 802c07e:	eb06 0104 	add.w	r1, r6, r4
 802c082:	d101      	bne.n	802c088 <FLASH_IF_Write_Buffer+0x18>
 802c084:	2000      	movs	r0, #0
      /* exit the for loop*/
      break;
    }
  }

  return status;
 802c086:	e014      	b.n	802c0b2 <FLASH_IF_Write_Buffer+0x42>
    UTIL_MEM_cpy_8(&src_value, pSrc, sizeof(uint64_t));
 802c088:	2208      	movs	r2, #8
 802c08a:	4668      	mov	r0, sp
 802c08c:	f00e ff12 	bl	803aeb4 <UTIL_MEM_cpy_8>
    if (src_value != UINT64_MAX)
 802c090:	e9dd 2300 	ldrd	r2, r3, [sp]
 802c094:	1c59      	adds	r1, r3, #1
 802c096:	bf08      	it	eq
 802c098:	f1b2 3fff 	cmpeq.w	r2, #4294967295
 802c09c:	f104 0708 	add.w	r7, r4, #8
 802c0a0:	d101      	bne.n	802c0a6 <FLASH_IF_Write_Buffer+0x36>
    pDestination += sizeof(uint64_t);
 802c0a2:	463c      	mov	r4, r7
    if (status != FLASH_OK)
 802c0a4:	e7ea      	b.n	802c07c <FLASH_IF_Write_Buffer+0xc>
      status = FLASH_IF_Write64(pDestination, src_value);
 802c0a6:	4620      	mov	r0, r4
 802c0a8:	f7ff ffc8 	bl	802c03c <FLASH_IF_Write64>
    pDestination += sizeof(uint64_t);
 802c0ac:	463c      	mov	r4, r7
    if (status != FLASH_OK)
 802c0ae:	2800      	cmp	r0, #0
 802c0b0:	d0e4      	beq.n	802c07c <FLASH_IF_Write_Buffer+0xc>
  /* USER CODE BEGIN FLASH_IF_Write_Buffer_2 */

  /* USER CODE END FLASH_IF_Write_Buffer_2 */
}
 802c0b2:	b003      	add	sp, #12
 802c0b4:	bdf0      	pop	{r4, r5, r6, r7, pc}

0802c0b6 <FLASH_IF_EraseByPages>:
{
 802c0b6:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  erase_str.TypeErase = FLASH_TYPEERASE_PAGES;
 802c0b8:	2302      	movs	r3, #2
  erase_str.Page = page;
 802c0ba:	e9cd 3001 	strd	r3, r0, [sp, #4]
  erase_str.NbPages = n;
 802c0be:	9103      	str	r1, [sp, #12]
  if (interrupt)
 802c0c0:	b15a      	cbz	r2, 802c0da <FLASH_IF_EraseByPages+0x24>
    hal_status = HAL_FLASHEx_Erase_IT(&erase_str);
 802c0c2:	a801      	add	r0, sp, #4
 802c0c4:	f002 f9a2 	bl	802e40c <HAL_FLASHEx_Erase_IT>
  return ((hal_status == HAL_OK) ? FLASH_OK : ((hal_status == HAL_BUSY) ? FLASH_BUSY : FLASH_ERASE_ERROR));
 802c0c8:	b120      	cbz	r0, 802c0d4 <FLASH_IF_EraseByPages+0x1e>
 802c0ca:	2802      	cmp	r0, #2
 802c0cc:	bf0c      	ite	eq
 802c0ce:	2001      	moveq	r0, #1
 802c0d0:	f06f 0001 	mvnne.w	r0, #1
}
 802c0d4:	b005      	add	sp, #20
 802c0d6:	f85d fb04 	ldr.w	pc, [sp], #4
    hal_status = HAL_FLASHEx_Erase(&erase_str, &page_error);
 802c0da:	4669      	mov	r1, sp
 802c0dc:	a801      	add	r0, sp, #4
 802c0de:	f002 f947 	bl	802e370 <HAL_FLASHEx_Erase>
 802c0e2:	e7f1      	b.n	802c0c8 <FLASH_IF_EraseByPages+0x12>

0802c0e4 <FLASH_IF_Write>:
{
 802c0e4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802c0e8:	469a      	mov	sl, r3
  uint32_t page_start_index = PAGE(address);
 802c0ea:	4b46      	ldr	r3, [pc, #280]	; (802c204 <FLASH_IF_Write+0x120>)
{
 802c0ec:	4691      	mov	r9, r2
  uint32_t page_end_index = PAGE(address + size - 1);
 802c0ee:	f109 4878 	add.w	r8, r9, #4160749568	; 0xf8000000
  uint32_t page_start_index = PAGE(address);
 802c0f2:	681a      	ldr	r2, [r3, #0]
 802c0f4:	4b44      	ldr	r3, [pc, #272]	; (802c208 <FLASH_IF_Write+0x124>)
  uint32_t page_end_index = PAGE(address + size - 1);
 802c0f6:	f108 38ff 	add.w	r8, r8, #4294967295
  uint32_t page_start_index = PAGE(address);
 802c0fa:	ea03 2382 	and.w	r3, r3, r2, lsl #10
  uint32_t page_end_index = PAGE(address + size - 1);
 802c0fe:	4480      	add	r8, r0
  uint32_t page_start_index = PAGE(address);
 802c100:	f100 4278 	add.w	r2, r0, #4160749568	; 0xf8000000
 802c104:	fbb2 f6f3 	udiv	r6, r2, r3
 802c108:	fb03 2616 	mls	r6, r3, r6, r2
  uint32_t page_end_index = PAGE(address + size - 1);
 802c10c:	fbb8 f2f3 	udiv	r2, r8, r3
 802c110:	fb03 8812 	mls	r8, r3, r2, r8
{
 802c114:	4605      	mov	r5, r0
  uint32_t page_start_index = PAGE(address);
 802c116:	0af6      	lsrs	r6, r6, #11
  uint32_t page_end_index = PAGE(address + size - 1);
 802c118:	ea4f 28d8 	mov.w	r8, r8, lsr #11
  if ((data == NULL) || ((size % sizeof(uint64_t)) != 0) || ((address % sizeof(uint64_t)) != 0))
 802c11c:	460f      	mov	r7, r1
 802c11e:	b921      	cbnz	r1, 802c12a <FLASH_IF_Write+0x46>
    return FLASH_PARAM_ERROR;
 802c120:	f06f 0004 	mvn.w	r0, #4
}
 802c124:	b003      	add	sp, #12
 802c126:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if ((data == NULL) || ((size % sizeof(uint64_t)) != 0) || ((address % sizeof(uint64_t)) != 0))
 802c12a:	ea40 0309 	orr.w	r3, r0, r9
 802c12e:	075b      	lsls	r3, r3, #29
 802c130:	d1f6      	bne.n	802c120 <FLASH_IF_Write+0x3c>
  if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0U)
 802c132:	4b36      	ldr	r3, [pc, #216]	; (802c20c <FLASH_IF_Write+0x128>)
 802c134:	695b      	ldr	r3, [r3, #20]
 802c136:	2b00      	cmp	r3, #0
 802c138:	db5e      	blt.n	802c1f8 <FLASH_IF_Write+0x114>
  if (page_start_index != page_end_index)
 802c13a:	4546      	cmp	r6, r8
    curr_size = FLASH_PAGE_SIZE - (address % FLASH_PAGE_SIZE);
 802c13c:	bf1a      	itte	ne
 802c13e:	f3c0 030a 	ubfxne	r3, r0, #0, #11
 802c142:	f5c3 6b00 	rsbne	fp, r3, #2048	; 0x800
 802c146:	46cb      	moveq	fp, r9
  for (uint32_t idx = page_start_index; idx <= page_end_index; idx++)
 802c148:	4546      	cmp	r6, r8
 802c14a:	d901      	bls.n	802c150 <FLASH_IF_Write+0x6c>
  int32_t status = FLASH_OK;
 802c14c:	2000      	movs	r0, #0
 802c14e:	e7e9      	b.n	802c124 <FLASH_IF_Write+0x40>
    if (FLASH_IF_IsEmpty((uint8_t *)curr_dest_addr, curr_size) != FLASH_EMPTY)
 802c150:	eb0b 0305 	add.w	r3, fp, r5
 802c154:	462c      	mov	r4, r5
  /* USER CODE END FLASH_IF_IsEmpty_1 */
  uint64_t *addr64;
  uint32_t i;

  /* start memory NOT 64bits aligned */
  while ((((uint32_t)addr) % sizeof(uint64_t)) != 0)
 802c156:	9301      	str	r3, [sp, #4]
 802c158:	9b01      	ldr	r3, [sp, #4]
 802c15a:	f014 0c07 	ands.w	ip, r4, #7
 802c15e:	eba3 0204 	sub.w	r2, r3, r4
 802c162:	d10c      	bne.n	802c17e <FLASH_IF_Write+0x9a>
    size--;
  }

  /* addr64 is 64 bits aligned */
  addr64 = (uint64_t *)addr;
  for (i = 0; i < (size / sizeof(uint64_t)); i++)
 802c164:	ea4f 0ed2 	mov.w	lr, r2, lsr #3
 802c168:	45f4      	cmp	ip, lr
 802c16a:	d130      	bne.n	802c1ce <FLASH_IF_Write+0xea>
    if (*addr64++ != UINT64_MAX)
    {
      return FLASH_NOT_EMPTY;
    }
  }
  size -= sizeof(uint64_t) * i;
 802c16c:	eba2 02cc 	sub.w	r2, r2, ip, lsl #3
 802c170:	4422      	add	r2, r4

  /* end memory NOT 64 bits aligned */
  addr = (uint8_t *)addr64;
  while (size != 0)
 802c172:	42a2      	cmp	r2, r4
 802c174:	d135      	bne.n	802c1e2 <FLASH_IF_Write+0xfe>
      if (FLASH_IF_Write_Buffer(curr_dest_addr, (uint8_t *)curr_src_addr, curr_size) != FLASH_OK)
 802c176:	465a      	mov	r2, fp
 802c178:	4639      	mov	r1, r7
 802c17a:	4628      	mov	r0, r5
 802c17c:	e021      	b.n	802c1c2 <FLASH_IF_Write+0xde>
    if (*addr++ != UINT8_MAX)
 802c17e:	f814 2b01 	ldrb.w	r2, [r4], #1
 802c182:	2aff      	cmp	r2, #255	; 0xff
 802c184:	d0e8      	beq.n	802c158 <FLASH_IF_Write+0x74>
      if (dataTempPage == NULL)
 802c186:	f1ba 0f00 	cmp.w	sl, #0
 802c18a:	d0c9      	beq.n	802c120 <FLASH_IF_Write+0x3c>
      UTIL_MEM_cpy_8(dataTempPage, (uint8_t *)(idx * FLASH_PAGE_SIZE + FLASH_BASE), FLASH_PAGE_SIZE);
 802c18c:	02f4      	lsls	r4, r6, #11
 802c18e:	f104 6400 	add.w	r4, r4, #134217728	; 0x8000000
 802c192:	f44f 6200 	mov.w	r2, #2048	; 0x800
 802c196:	4621      	mov	r1, r4
 802c198:	4650      	mov	r0, sl
 802c19a:	f00e fe8b 	bl	803aeb4 <UTIL_MEM_cpy_8>
      UTIL_MEM_cpy_8(&dataTempPage[((uint32_t)curr_dest_addr) % FLASH_PAGE_SIZE], (uint8_t *)curr_src_addr, curr_size);
 802c19e:	f3c5 000a 	ubfx	r0, r5, #0, #11
 802c1a2:	fa1f f28b 	uxth.w	r2, fp
 802c1a6:	4639      	mov	r1, r7
 802c1a8:	4450      	add	r0, sl
 802c1aa:	f00e fe83 	bl	803aeb4 <UTIL_MEM_cpy_8>
      if (FLASH_IF_EraseByPages(idx, 1, 0) != FLASH_OK)
 802c1ae:	2200      	movs	r2, #0
 802c1b0:	2101      	movs	r1, #1
 802c1b2:	4630      	mov	r0, r6
 802c1b4:	f7ff ff7f 	bl	802c0b6 <FLASH_IF_EraseByPages>
 802c1b8:	bb08      	cbnz	r0, 802c1fe <FLASH_IF_Write+0x11a>
        if (FLASH_IF_Write_Buffer(idx * FLASH_PAGE_SIZE + FLASH_BASE, dataTempPage, FLASH_PAGE_SIZE) != FLASH_OK)
 802c1ba:	f44f 6200 	mov.w	r2, #2048	; 0x800
 802c1be:	4651      	mov	r1, sl
 802c1c0:	4620      	mov	r0, r4
 802c1c2:	f7ff ff55 	bl	802c070 <FLASH_IF_Write_Buffer>
 802c1c6:	b188      	cbz	r0, 802c1ec <FLASH_IF_Write+0x108>
          status = FLASH_WRITE_ERROR;
 802c1c8:	f06f 0002 	mvn.w	r0, #2
 802c1cc:	e7aa      	b.n	802c124 <FLASH_IF_Write+0x40>
    if (*addr64++ != UINT64_MAX)
 802c1ce:	e8f4 0102 	ldrd	r0, r1, [r4], #8
 802c1d2:	3101      	adds	r1, #1
 802c1d4:	bf08      	it	eq
 802c1d6:	f1b0 3fff 	cmpeq.w	r0, #4294967295
 802c1da:	d1d4      	bne.n	802c186 <FLASH_IF_Write+0xa2>
  for (i = 0; i < (size / sizeof(uint64_t)); i++)
 802c1dc:	f10c 0c01 	add.w	ip, ip, #1
 802c1e0:	e7c2      	b.n	802c168 <FLASH_IF_Write+0x84>
  {
    if (*addr++ != UINT8_MAX)
 802c1e2:	f814 1b01 	ldrb.w	r1, [r4], #1
 802c1e6:	29ff      	cmp	r1, #255	; 0xff
 802c1e8:	d0c3      	beq.n	802c172 <FLASH_IF_Write+0x8e>
 802c1ea:	e7cc      	b.n	802c186 <FLASH_IF_Write+0xa2>
    curr_src_addr += curr_size;
 802c1ec:	445f      	add	r7, fp
  for (uint32_t idx = page_start_index; idx <= page_end_index; idx++)
 802c1ee:	9d01      	ldr	r5, [sp, #4]
    curr_size = size - curr_size;
 802c1f0:	eba9 0b0b 	sub.w	fp, r9, fp
  for (uint32_t idx = page_start_index; idx <= page_end_index; idx++)
 802c1f4:	3601      	adds	r6, #1
 802c1f6:	e7a7      	b.n	802c148 <FLASH_IF_Write+0x64>
    return FLASH_LOCK_ERROR;
 802c1f8:	f06f 0003 	mvn.w	r0, #3
 802c1fc:	e792      	b.n	802c124 <FLASH_IF_Write+0x40>
        status = FLASH_ERASE_ERROR;
 802c1fe:	f06f 0001 	mvn.w	r0, #1
 802c202:	e78f      	b.n	802c124 <FLASH_IF_Write+0x40>
 802c204:	1fff75e0 	.word	0x1fff75e0
 802c208:	03fffc00 	.word	0x03fffc00
 802c20c:	58004000 	.word	0x58004000

0802c210 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 802c210:	b500      	push	{lr}
 802c212:	b09b      	sub	sp, #108	; 0x6c
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 802c214:	2248      	movs	r2, #72	; 0x48
 802c216:	2100      	movs	r1, #0
 802c218:	a808      	add	r0, sp, #32
 802c21a:	f00f fa89 	bl	803b730 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 802c21e:	221c      	movs	r2, #28
 802c220:	2100      	movs	r1, #0
 802c222:	a801      	add	r0, sp, #4
 802c224:	f00f fa84 	bl	803b730 <memset>

  /** Configure LSE Drive Capability
  */
  HAL_PWR_EnableBkUpAccess();
 802c228:	f002 fa5c 	bl	802e6e4 <HAL_PWR_EnableBkUpAccess>
  *         @arg @ref LL_RCC_LSEDRIVE_HIGH
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSE_SetDriveCapability(uint32_t LSEDrive)
{
  MODIFY_REG(RCC->BDCR, RCC_BDCR_LSEDRV, LSEDrive);
 802c22c:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
  /** Initializes the CPU, AHB and APB busses clocks
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSE|RCC_OSCILLATORTYPE_MSI;
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
  RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
 802c230:	2001      	movs	r0, #1
 802c232:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 802c236:	f023 0318 	bic.w	r3, r3, #24
 802c23a:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 802c23e:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
 802c242:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 802c246:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 802c24a:	f8c2 3400 	str.w	r3, [r2, #1024]	; 0x400
 802c24e:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
 802c252:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 802c256:	9300      	str	r3, [sp, #0]
 802c258:	9b00      	ldr	r3, [sp, #0]
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSE|RCC_OSCILLATORTYPE_MSI;
 802c25a:	2324      	movs	r3, #36	; 0x24
 802c25c:	9308      	str	r3, [sp, #32]
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 802c25e:	2381      	movs	r3, #129	; 0x81
 802c260:	930b      	str	r3, [sp, #44]	; 0x2c
  RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
 802c262:	2300      	movs	r3, #0
 802c264:	e9cd 0310 	strd	r0, r3, [sp, #64]	; 0x40
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_11;
 802c268:	22b0      	movs	r2, #176	; 0xb0
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 802c26a:	a808      	add	r0, sp, #32
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 802c26c:	e9cd 2312 	strd	r2, r3, [sp, #72]	; 0x48
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 802c270:	f002 fbb8 	bl	802e9e4 <HAL_RCC_OscConfig>
 802c274:	b108      	cbz	r0, 802c27a <SystemClock_Config+0x6a>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 802c276:	b672      	cpsid	i
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 802c278:	e7fe      	b.n	802c278 <SystemClock_Config+0x68>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK3|RCC_CLOCKTYPE_HCLK
 802c27a:	234f      	movs	r3, #79	; 0x4f
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
 802c27c:	e9cd 3001 	strd	r3, r0, [sp, #4]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 802c280:	e9cd 0003 	strd	r0, r0, [sp, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 802c284:	9005      	str	r0, [sp, #20]
  RCC_ClkInitStruct.AHBCLK3Divider = RCC_SYSCLK_DIV1;
 802c286:	9007      	str	r0, [sp, #28]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
 802c288:	2102      	movs	r1, #2
 802c28a:	a801      	add	r0, sp, #4
 802c28c:	f002 fe4a 	bl	802ef24 <HAL_RCC_ClockConfig>
 802c290:	b108      	cbz	r0, 802c296 <SystemClock_Config+0x86>
 802c292:	b672      	cpsid	i
  while (1)
 802c294:	e7fe      	b.n	802c294 <SystemClock_Config+0x84>
}
 802c296:	b01b      	add	sp, #108	; 0x6c
 802c298:	f85d fb04 	ldr.w	pc, [sp], #4

0802c29c <main>:
{
 802c29c:	b508      	push	{r3, lr}
  HAL_Init();
 802c29e:	f001 f8c7 	bl	802d430 <HAL_Init>
  SystemClock_Config();
 802c2a2:	f7ff ffb5 	bl	802c210 <SystemClock_Config>
  MX_KMS_Init();
 802c2a6:	f000 fc3f 	bl	802cb28 <MX_KMS_Init>
  MX_LoRaWAN_Init();
 802c2aa:	f000 fc40 	bl	802cb2e <MX_LoRaWAN_Init>
    MX_LoRaWAN_Process();
 802c2ae:	f000 fc45 	bl	802cb3c <MX_LoRaWAN_Process>
  while (1)
 802c2b2:	e7fc      	b.n	802c2ae <main+0x12>

0802c2b4 <Error_Handler>:
 802c2b4:	b672      	cpsid	i
  while (1)
 802c2b6:	e7fe      	b.n	802c2b6 <Error_Handler+0x2>

0802c2b8 <MX_RTC_Init>:

RTC_HandleTypeDef hrtc;

/* RTC init function */
void MX_RTC_Init(void)
{
 802c2b8:	b500      	push	{lr}
 802c2ba:	b08d      	sub	sp, #52	; 0x34

  /* USER CODE BEGIN RTC_Init 0 */

  /* USER CODE END RTC_Init 0 */

  RTC_AlarmTypeDef sAlarm = {0};
 802c2bc:	222c      	movs	r2, #44	; 0x2c
 802c2be:	2100      	movs	r1, #0
 802c2c0:	a801      	add	r0, sp, #4
 802c2c2:	f00f fa35 	bl	803b730 <memset>
  /* USER CODE BEGIN RTC_Init 1 */

  /* USER CODE END RTC_Init 1 */
  /** Initialize RTC Only
  */
  hrtc.Instance = RTC;
 802c2c6:	4817      	ldr	r0, [pc, #92]	; (802c324 <MX_RTC_Init+0x6c>)
 802c2c8:	4b17      	ldr	r3, [pc, #92]	; (802c328 <MX_RTC_Init+0x70>)
 802c2ca:	6003      	str	r3, [r0, #0]
  hrtc.Init.AsynchPrediv = RTC_PREDIV_A;
 802c2cc:	231f      	movs	r3, #31
 802c2ce:	6083      	str	r3, [r0, #8]
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
  hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
 802c2d0:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
 802c2d4:	2300      	movs	r3, #0
  hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
 802c2d6:	e9c0 3304 	strd	r3, r3, [r0, #16]
  hrtc.Init.OutPutPullUp = RTC_OUTPUT_PULLUP_NONE;
 802c2da:	e9c0 2307 	strd	r2, r3, [r0, #28]
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
 802c2de:	6183      	str	r3, [r0, #24]
  hrtc.Init.BinMode = RTC_BINARY_ONLY;
 802c2e0:	f44f 7380 	mov.w	r3, #256	; 0x100
 802c2e4:	6243      	str	r3, [r0, #36]	; 0x24
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
 802c2e6:	f003 f8e9 	bl	802f4bc <HAL_RTC_Init>
 802c2ea:	b108      	cbz	r0, 802c2f0 <MX_RTC_Init+0x38>
  {
    Error_Handler();
 802c2ec:	f7ff ffe2 	bl	802c2b4 <Error_Handler>

  /* USER CODE END Check_RTC_BKUP */

  /** Initialize RTC and set the Time and Date
  */
  if (HAL_RTCEx_SetSSRU_IT(&hrtc) != HAL_OK)
 802c2f0:	480c      	ldr	r0, [pc, #48]	; (802c324 <MX_RTC_Init+0x6c>)
 802c2f2:	f003 fa07 	bl	802f704 <HAL_RTCEx_SetSSRU_IT>
 802c2f6:	b108      	cbz	r0, 802c2fc <MX_RTC_Init+0x44>
  {
    Error_Handler();
 802c2f8:	f7ff ffdc 	bl	802c2b4 <Error_Handler>
  /** Enable the Alarm A
  */
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
  sAlarm.AlarmTime.SubSeconds = 0x0;
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDBINMASK_NONE;
 802c2fc:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
 802c300:	2200      	movs	r2, #0
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDBINMASK_NONE;
 802c302:	9307      	str	r3, [sp, #28]
  sAlarm.Alarm = RTC_ALARM_A;
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, 0) != HAL_OK)
 802c304:	4807      	ldr	r0, [pc, #28]	; (802c324 <MX_RTC_Init+0x6c>)
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
 802c306:	9208      	str	r2, [sp, #32]
  sAlarm.Alarm = RTC_ALARM_A;
 802c308:	f44f 7380 	mov.w	r3, #256	; 0x100
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, 0) != HAL_OK)
 802c30c:	a901      	add	r1, sp, #4
  sAlarm.AlarmTime.SubSeconds = 0x0;
 802c30e:	9202      	str	r2, [sp, #8]
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
 802c310:	9206      	str	r2, [sp, #24]
  sAlarm.Alarm = RTC_ALARM_A;
 802c312:	930b      	str	r3, [sp, #44]	; 0x2c
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, 0) != HAL_OK)
 802c314:	f003 f92e 	bl	802f574 <HAL_RTC_SetAlarm_IT>
 802c318:	b108      	cbz	r0, 802c31e <MX_RTC_Init+0x66>
  {
    Error_Handler();
 802c31a:	f7ff ffcb 	bl	802c2b4 <Error_Handler>
  }
  /* USER CODE BEGIN RTC_Init 2 */

  /* USER CODE END RTC_Init 2 */

}
 802c31e:	b00d      	add	sp, #52	; 0x34
 802c320:	f85d fb04 	ldr.w	pc, [sp], #4
 802c324:	200061b8 	.word	0x200061b8
 802c328:	40002800 	.word	0x40002800

0802c32c <HAL_RTC_MspInit>:

void HAL_RTC_MspInit(RTC_HandleTypeDef* rtcHandle)
{
 802c32c:	b510      	push	{r4, lr}
 802c32e:	4604      	mov	r4, r0
 802c330:	b090      	sub	sp, #64	; 0x40

  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 802c332:	2238      	movs	r2, #56	; 0x38
 802c334:	2100      	movs	r1, #0
 802c336:	a802      	add	r0, sp, #8
 802c338:	f00f f9fa 	bl	803b730 <memset>
  if(rtcHandle->Instance==RTC)
 802c33c:	6822      	ldr	r2, [r4, #0]
 802c33e:	4b19      	ldr	r3, [pc, #100]	; (802c3a4 <HAL_RTC_MspInit+0x78>)
 802c340:	429a      	cmp	r2, r3
 802c342:	d12c      	bne.n	802c39e <HAL_RTC_MspInit+0x72>
  /* USER CODE BEGIN RTC_MspInit 0 */

  /* USER CODE END RTC_MspInit 0 */
  /** Initializes the peripherals clocks
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 802c344:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 802c348:	9302      	str	r3, [sp, #8]
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;

    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 802c34a:	a802      	add	r0, sp, #8
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
 802c34c:	f44f 7380 	mov.w	r3, #256	; 0x100
 802c350:	930f      	str	r3, [sp, #60]	; 0x3c
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 802c352:	f002 ff23 	bl	802f19c <HAL_RCCEx_PeriphCLKConfig>
 802c356:	b108      	cbz	r0, 802c35c <HAL_RTC_MspInit+0x30>
    {
      Error_Handler();
 802c358:	f7ff ffac 	bl	802c2b4 <Error_Handler>
  * @rmtoll BDCR         RTCEN         LL_RCC_EnableRTC
  * @retval None
  */
__STATIC_INLINE void LL_RCC_EnableRTC(void)
{
  SET_BIT(RCC->BDCR, RCC_BDCR_RTCEN);
 802c35c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
    /* RTC clock enable */
    __HAL_RCC_RTC_ENABLE();
    __HAL_RCC_RTCAPB_CLK_ENABLE();

    /* RTC interrupt Init */
    HAL_NVIC_SetPriority(TAMP_STAMP_LSECSS_SSRU_IRQn, 0, 0);
 802c360:	2002      	movs	r0, #2
 802c362:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 802c366:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 802c36a:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  SET_BIT(RCC->APB1ENR1, Periphs);
 802c36e:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 802c370:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 802c374:	659a      	str	r2, [r3, #88]	; 0x58
  tmpreg = READ_BIT(RCC->APB1ENR1, Periphs);
 802c376:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 802c378:	2200      	movs	r2, #0
 802c37a:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 802c37e:	4611      	mov	r1, r2
 802c380:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 802c382:	9b01      	ldr	r3, [sp, #4]
 802c384:	f001 fcc6 	bl	802dd14 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TAMP_STAMP_LSECSS_SSRU_IRQn);
 802c388:	2002      	movs	r0, #2
 802c38a:	f001 fcf5 	bl	802dd78 <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(RTC_Alarm_IRQn, 0, 0);
 802c38e:	2200      	movs	r2, #0
 802c390:	202a      	movs	r0, #42	; 0x2a
 802c392:	4611      	mov	r1, r2
 802c394:	f001 fcbe 	bl	802dd14 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(RTC_Alarm_IRQn);
 802c398:	202a      	movs	r0, #42	; 0x2a
 802c39a:	f001 fced 	bl	802dd78 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN RTC_MspInit 1 */

  /* USER CODE END RTC_MspInit 1 */
  }
}
 802c39e:	b010      	add	sp, #64	; 0x40
 802c3a0:	bd10      	pop	{r4, pc}
 802c3a2:	bf00      	nop
 802c3a4:	40002800 	.word	0x40002800

0802c3a8 <PWR_EnterOffMode>:
void PWR_EnterOffMode(void)
{
  /* USER CODE BEGIN EnterOffMode_1 */

  /* USER CODE END EnterOffMode_1 */
}
 802c3a8:	4770      	bx	lr
	...

0802c3ac <PWR_EnterStopMode>:

  /* USER CODE END ExitOffMode_1 */
}

void PWR_EnterStopMode(void)
{
 802c3ac:	b508      	push	{r3, lr}
  /* USER CODE BEGIN EnterStopMode_1 */

  /* USER CODE END EnterStopMode_1 */
  HAL_SuspendTick();
 802c3ae:	f001 f855 	bl	802d45c <HAL_SuspendTick>
  * @rmtoll EXTSCR       C1CSSF        LL_PWR_ClearFlag_C1STOP_C1STB
  * @retval None
  */
__STATIC_INLINE void LL_PWR_ClearFlag_C1STOP_C1STB(void)
{
  WRITE_REG(PWR->EXTSCR, PWR_EXTSCR_C1CSSF);
 802c3b2:	4b04      	ldr	r3, [pc, #16]	; (802c3c4 <PWR_EnterStopMode+0x18>)
 802c3b4:	2001      	movs	r0, #1
 802c3b6:	f8c3 0088 	str.w	r0, [r3, #136]	; 0x88
  /* USER CODE END EnterStopMode_2 */
  HAL_PWREx_EnterSTOP2Mode(PWR_STOPENTRY_WFI);
  /* USER CODE BEGIN EnterStopMode_3 */

  /* USER CODE END EnterStopMode_3 */
}
 802c3ba:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_PWREx_EnterSTOP2Mode(PWR_STOPENTRY_WFI);
 802c3be:	f002 b9eb 	b.w	802e798 <HAL_PWREx_EnterSTOP2Mode>
 802c3c2:	bf00      	nop
 802c3c4:	58000400 	.word	0x58000400

0802c3c8 <PWR_ExitSleepMode>:
{
  /* USER CODE BEGIN ExitSleepMode_1 */

  /* USER CODE END ExitSleepMode_1 */
  /* Suspend sysTick */
  HAL_ResumeTick();
 802c3c8:	f001 b850 	b.w	802d46c <HAL_ResumeTick>

0802c3cc <PWR_ExitStopMode>:
{
 802c3cc:	b508      	push	{r3, lr}
  HAL_ResumeTick();
 802c3ce:	f001 f84d 	bl	802d46c <HAL_ResumeTick>
}
 802c3d2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  vcom_Resume();
 802c3d6:	f000 bb77 	b.w	802cac8 <vcom_Resume>

0802c3da <PWR_EnterSleepMode>:
{
 802c3da:	b508      	push	{r3, lr}
  HAL_SuspendTick();
 802c3dc:	f001 f83e 	bl	802d45c <HAL_SuspendTick>
}
 802c3e0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_SLEEPENTRY_WFI);
 802c3e4:	2101      	movs	r1, #1
 802c3e6:	2000      	movs	r0, #0
 802c3e8:	f002 b984 	b.w	802e6f4 <HAL_PWR_EnterSLEEPMode>

0802c3ec <PWR_ExitOffMode>:
 802c3ec:	4770      	bx	lr

0802c3ee <HAL_MspInit>:
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 802c3ee:	4770      	bx	lr

0802c3f0 <NMI_Handler>:
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 802c3f0:	e7fe      	b.n	802c3f0 <NMI_Handler>

0802c3f2 <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 802c3f2:	e7fe      	b.n	802c3f2 <HardFault_Handler>

0802c3f4 <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 802c3f4:	e7fe      	b.n	802c3f4 <MemManage_Handler>

0802c3f6 <BusFault_Handler>:
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 802c3f6:	e7fe      	b.n	802c3f6 <BusFault_Handler>

0802c3f8 <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 802c3f8:	e7fe      	b.n	802c3f8 <UsageFault_Handler>

0802c3fa <SVC_Handler>:

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 802c3fa:	4770      	bx	lr

0802c3fc <DebugMon_Handler>:
 802c3fc:	4770      	bx	lr

0802c3fe <PendSV_Handler>:
 802c3fe:	4770      	bx	lr

0802c400 <SysTick_Handler>:
 802c400:	4770      	bx	lr
	...

0802c404 <TAMP_STAMP_LSECSS_SSRU_IRQHandler>:
void TAMP_STAMP_LSECSS_SSRU_IRQHandler(void)
{
  /* USER CODE BEGIN TAMP_STAMP_LSECSS_SSRU_IRQn 0 */

  /* USER CODE END TAMP_STAMP_LSECSS_SSRU_IRQn 0 */
  HAL_RTCEx_SSRUIRQHandler(&hrtc);
 802c404:	4801      	ldr	r0, [pc, #4]	; (802c40c <TAMP_STAMP_LSECSS_SSRU_IRQHandler+0x8>)
 802c406:	f003 b9a3 	b.w	802f750 <HAL_RTCEx_SSRUIRQHandler>
 802c40a:	bf00      	nop
 802c40c:	200061b8 	.word	0x200061b8

0802c410 <EXTI0_IRQHandler>:
void EXTI0_IRQHandler(void)
{
  /* USER CODE BEGIN EXTI0_IRQn 0 */

  /* USER CODE END EXTI0_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_0);
 802c410:	2001      	movs	r0, #1
 802c412:	f002 b95b 	b.w	802e6cc <HAL_GPIO_EXTI_IRQHandler>

0802c416 <EXTI1_IRQHandler>:
void EXTI1_IRQHandler(void)
{
  /* USER CODE BEGIN EXTI1_IRQn 0 */

  /* USER CODE END EXTI1_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_1);
 802c416:	2002      	movs	r0, #2
 802c418:	f002 b958 	b.w	802e6cc <HAL_GPIO_EXTI_IRQHandler>

0802c41c <DMA1_Channel5_IRQHandler>:
void DMA1_Channel5_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Channel5_IRQn 0 */

  /* USER CODE END DMA1_Channel5_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_usart2_tx);
 802c41c:	4801      	ldr	r0, [pc, #4]	; (802c424 <DMA1_Channel5_IRQHandler+0x8>)
 802c41e:	f001 be89 	b.w	802e134 <HAL_DMA_IRQHandler>
 802c422:	bf00      	nop
 802c424:	200061fc 	.word	0x200061fc

0802c428 <USART2_IRQHandler>:
void USART2_IRQHandler(void)
{
  /* USER CODE BEGIN USART2_IRQn 0 */

  /* USER CODE END USART2_IRQn 0 */
  HAL_UART_IRQHandler(&huart2);
 802c428:	4801      	ldr	r0, [pc, #4]	; (802c430 <USART2_IRQHandler+0x8>)
 802c42a:	f003 bd61 	b.w	802fef0 <HAL_UART_IRQHandler>
 802c42e:	bf00      	nop
 802c430:	2000625c 	.word	0x2000625c

0802c434 <RTC_Alarm_IRQHandler>:
void RTC_Alarm_IRQHandler(void)
{
  /* USER CODE BEGIN RTC_Alarm_IRQn 0 */

  /* USER CODE END RTC_Alarm_IRQn 0 */
  HAL_RTC_AlarmIRQHandler(&hrtc);
 802c434:	4801      	ldr	r0, [pc, #4]	; (802c43c <RTC_Alarm_IRQHandler+0x8>)
 802c436:	f002 bfc3 	b.w	802f3c0 <HAL_RTC_AlarmIRQHandler>
 802c43a:	bf00      	nop
 802c43c:	200061b8 	.word	0x200061b8

0802c440 <SUBGHZ_Radio_IRQHandler>:
void SUBGHZ_Radio_IRQHandler(void)
{
  /* USER CODE BEGIN SUBGHZ_Radio_IRQn 0 */

  /* USER CODE END SUBGHZ_Radio_IRQn 0 */
  HAL_SUBGHZ_IRQHandler(&hsubghz);
 802c440:	4801      	ldr	r0, [pc, #4]	; (802c448 <SUBGHZ_Radio_IRQHandler+0x8>)
 802c442:	f003 bc16 	b.w	802fc72 <HAL_SUBGHZ_IRQHandler>
 802c446:	bf00      	nop
 802c448:	200061f0 	.word	0x200061f0

0802c44c <MX_SUBGHZ_Init>:
  /* USER CODE END SUBGHZ_Init 0 */

  /* USER CODE BEGIN SUBGHZ_Init 1 */

  /* USER CODE END SUBGHZ_Init 1 */
  hsubghz.Init.BaudratePrescaler = SUBGHZSPI_BAUDRATEPRESCALER_4;
 802c44c:	4805      	ldr	r0, [pc, #20]	; (802c464 <MX_SUBGHZ_Init+0x18>)
{
 802c44e:	b508      	push	{r3, lr}
  hsubghz.Init.BaudratePrescaler = SUBGHZSPI_BAUDRATEPRESCALER_4;
 802c450:	2308      	movs	r3, #8
 802c452:	6003      	str	r3, [r0, #0]
  if (HAL_SUBGHZ_Init(&hsubghz) != HAL_OK)
 802c454:	f003 f9c2 	bl	802f7dc <HAL_SUBGHZ_Init>
 802c458:	b118      	cbz	r0, 802c462 <MX_SUBGHZ_Init+0x16>
  }
  /* USER CODE BEGIN SUBGHZ_Init 2 */

  /* USER CODE END SUBGHZ_Init 2 */

}
 802c45a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 802c45e:	f7ff bf29 	b.w	802c2b4 <Error_Handler>
}
 802c462:	bd08      	pop	{r3, pc}
 802c464:	200061f0 	.word	0x200061f0

0802c468 <HAL_SUBGHZ_MspInit>:
  * @retval None
  */
__STATIC_INLINE void LL_APB3_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB3ENR, Periphs);
 802c468:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000

void HAL_SUBGHZ_MspInit(SUBGHZ_HandleTypeDef* subghzHandle)
{
 802c46c:	b507      	push	{r0, r1, r2, lr}
 802c46e:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 802c470:	f042 0201 	orr.w	r2, r2, #1
 802c474:	665a      	str	r2, [r3, #100]	; 0x64
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB3ENR, Periphs);
 802c476:	6e5b      	ldr	r3, [r3, #100]	; 0x64
  /* USER CODE END SUBGHZ_MspInit 0 */
    /* SUBGHZ clock enable */
    __HAL_RCC_SUBGHZSPI_CLK_ENABLE();

    /* SUBGHZ interrupt Init */
    HAL_NVIC_SetPriority(SUBGHZ_Radio_IRQn, 0, 0);
 802c478:	2200      	movs	r2, #0
 802c47a:	f003 0301 	and.w	r3, r3, #1
 802c47e:	9301      	str	r3, [sp, #4]
 802c480:	4611      	mov	r1, r2
 802c482:	2032      	movs	r0, #50	; 0x32
  (void)tmpreg;
 802c484:	9b01      	ldr	r3, [sp, #4]
 802c486:	f001 fc45 	bl	802dd14 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SUBGHZ_Radio_IRQn);
 802c48a:	2032      	movs	r0, #50	; 0x32
  /* USER CODE BEGIN SUBGHZ_MspInit 1 */

  /* USER CODE END SUBGHZ_MspInit 1 */
}
 802c48c:	b003      	add	sp, #12
 802c48e:	f85d eb04 	ldr.w	lr, [sp], #4
    HAL_NVIC_EnableIRQ(SUBGHZ_Radio_IRQn);
 802c492:	f001 bc71 	b.w	802dd78 <HAL_NVIC_EnableIRQ>
	...

0802c498 <tiny_snprintf_like.constprop.0>:
  /* USER CODE BEGIN UTIL_LPM_SetStopMode_2 */

  /* USER CODE END UTIL_LPM_SetStopMode_2 */
}

static void tiny_snprintf_like(char *buf, uint32_t maxsize, const char *strFormat, ...)
 802c498:	b40c      	push	{r2, r3}
 802c49a:	b507      	push	{r0, r1, r2, lr}
  /* USER CODE BEGIN tiny_snprintf_like_1 */

  /* USER CODE END tiny_snprintf_like_1 */
  va_list vaArgs;
  va_start(vaArgs, strFormat);
  UTIL_ADV_TRACE_VSNPRINTF(buf, maxsize, strFormat, vaArgs);
 802c49c:	4a05      	ldr	r2, [pc, #20]	; (802c4b4 <tiny_snprintf_like.constprop.0+0x1c>)
  va_start(vaArgs, strFormat);
 802c49e:	ab05      	add	r3, sp, #20
  UTIL_ADV_TRACE_VSNPRINTF(buf, maxsize, strFormat, vaArgs);
 802c4a0:	2110      	movs	r1, #16
  va_start(vaArgs, strFormat);
 802c4a2:	9301      	str	r3, [sp, #4]
  UTIL_ADV_TRACE_VSNPRINTF(buf, maxsize, strFormat, vaArgs);
 802c4a4:	f00f f806 	bl	803b4b4 <tiny_vsnprintf_like>
  va_end(vaArgs);
  /* USER CODE BEGIN tiny_snprintf_like_2 */

  /* USER CODE END tiny_snprintf_like_2 */
}
 802c4a8:	b003      	add	sp, #12
 802c4aa:	f85d eb04 	ldr.w	lr, [sp], #4
 802c4ae:	b002      	add	sp, #8
 802c4b0:	4770      	bx	lr
 802c4b2:	bf00      	nop
 802c4b4:	0803bd3b 	.word	0x0803bd3b

0802c4b8 <TimestampNow>:
{
 802c4b8:	b530      	push	{r4, r5, lr}
 802c4ba:	b085      	sub	sp, #20
 802c4bc:	4604      	mov	r4, r0
  SysTime_t curtime = SysTimeGet();
 802c4be:	a802      	add	r0, sp, #8
{
 802c4c0:	460d      	mov	r5, r1
  SysTime_t curtime = SysTimeGet();
 802c4c2:	f00e fe23 	bl	803b10c <SysTimeGet>
  tiny_snprintf_like((char *)buff, MAX_TS_SIZE, "%ds%03d:", curtime.Seconds, curtime.SubSeconds);
 802c4c6:	f9bd 300c 	ldrsh.w	r3, [sp, #12]
 802c4ca:	4a06      	ldr	r2, [pc, #24]	; (802c4e4 <TimestampNow+0x2c>)
 802c4cc:	9300      	str	r3, [sp, #0]
 802c4ce:	2110      	movs	r1, #16
 802c4d0:	9b02      	ldr	r3, [sp, #8]
 802c4d2:	4620      	mov	r0, r4
 802c4d4:	f7ff ffe0 	bl	802c498 <tiny_snprintf_like.constprop.0>
  *size = strlen((char *)buff);
 802c4d8:	4620      	mov	r0, r4
 802c4da:	f7fe ffb1 	bl	802b440 <strlen>
 802c4de:	8028      	strh	r0, [r5, #0]
}
 802c4e0:	b005      	add	sp, #20
 802c4e2:	bd30      	pop	{r4, r5, pc}
 802c4e4:	0803bd3b 	.word	0x0803bd3b

0802c4e8 <SystemApp_Init>:
  MODIFY_REG(RCC->CFGR, RCC_CFGR_STOPWUCK, Clock);
 802c4e8:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
{
 802c4ec:	b508      	push	{r3, lr}
 802c4ee:	6893      	ldr	r3, [r2, #8]
 802c4f0:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 802c4f4:	6093      	str	r3, [r2, #8]
  UTIL_TIMER_Init();
 802c4f6:	f00e fe8f 	bl	803b218 <UTIL_TIMER_Init>
  DBG_Disable();
 802c4fa:	f000 f8be 	bl	802c67a <DBG_Disable>
  DBG_ProbesInit();
 802c4fe:	f000 f8bf 	bl	802c680 <DBG_ProbesInit>
  UTIL_ADV_TRACE_Init();
 802c502:	f00e fb67 	bl	803abd4 <UTIL_ADV_TRACE_Init>
  UTIL_ADV_TRACE_RegisterTimeStampFunction(TimestampNow);
 802c506:	480d      	ldr	r0, [pc, #52]	; (802c53c <SystemApp_Init+0x54>)
 802c508:	f00e fb7e 	bl	803ac08 <UTIL_ADV_TRACE_RegisterTimeStampFunction>
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPTVERR);
 802c50c:	4b0c      	ldr	r3, [pc, #48]	; (802c540 <SystemApp_Init+0x58>)
 802c50e:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 802c512:	611a      	str	r2, [r3, #16]
  UTIL_ADV_TRACE_SetVerboseLevel(VERBOSE_LEVEL);
 802c514:	2003      	movs	r0, #3
 802c516:	f00e fb7d 	bl	803ac14 <UTIL_ADV_TRACE_SetVerboseLevel>
  SYS_InitMeasurement();
 802c51a:	f7ff fd0f 	bl	802bf3c <SYS_InitMeasurement>
  EnvSensors_Init();
 802c51e:	f000 f8b9 	bl	802c694 <EnvSensors_Init>
  UTIL_LPM_Init();
 802c522:	f00e fc75 	bl	803ae10 <UTIL_LPM_Init>
  UTIL_LPM_SetOffMode((1 << CFG_LPM_APPLI_Id), UTIL_LPM_DISABLE);
 802c526:	2101      	movs	r1, #1
 802c528:	4608      	mov	r0, r1
 802c52a:	f00e fc8f 	bl	803ae4c <UTIL_LPM_SetOffMode>
  UTIL_LPM_SetStopMode((1 << CFG_LPM_APPLI_Id), UTIL_LPM_DISABLE);
 802c52e:	2101      	movs	r1, #1
}
 802c530:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  UTIL_LPM_SetStopMode((1 << CFG_LPM_APPLI_Id), UTIL_LPM_DISABLE);
 802c534:	4608      	mov	r0, r1
 802c536:	f00e bc73 	b.w	803ae20 <UTIL_LPM_SetStopMode>
 802c53a:	bf00      	nop
 802c53c:	0802c4b9 	.word	0x0802c4b9
 802c540:	58004000 	.word	0x58004000

0802c544 <UTIL_SEQ_Idle>:
  UTIL_LPM_EnterLowPower();
 802c544:	f00e bc98 	b.w	803ae78 <UTIL_LPM_EnterLowPower>

0802c548 <GetBatteryLevel>:
{
 802c548:	b513      	push	{r0, r1, r4, lr}
  batteryLevelmV = (uint16_t) SYS_GetBatteryLevel();
 802c54a:	f7ff fcff 	bl	802bf4c <SYS_GetBatteryLevel>
  if (batteryLevelmV > VDD_BAT)
 802c54e:	f640 33b8 	movw	r3, #3000	; 0xbb8
 802c552:	4298      	cmp	r0, r3
 802c554:	d815      	bhi.n	802c582 <GetBatteryLevel+0x3a>
  else if (batteryLevelmV < VDD_MIN)
 802c556:	f5b0 6fe1 	cmp.w	r0, #1800	; 0x708
 802c55a:	d314      	bcc.n	802c586 <GetBatteryLevel+0x3e>
    batteryLevel = (((uint32_t)(batteryLevelmV - VDD_MIN) * LORAWAN_MAX_BAT) / (VDD_BAT - VDD_MIN));
 802c55c:	f5a0 60e1 	sub.w	r0, r0, #1800	; 0x708
 802c560:	24fe      	movs	r4, #254	; 0xfe
 802c562:	4344      	muls	r4, r0
 802c564:	f44f 6396 	mov.w	r3, #1200	; 0x4b0
 802c568:	fbb4 f4f3 	udiv	r4, r4, r3
 802c56c:	b2e4      	uxtb	r4, r4
  APP_LOG(TS_ON, VLEVEL_M, "VDDA= %d\r\n", batteryLevel);
 802c56e:	4b07      	ldr	r3, [pc, #28]	; (802c58c <GetBatteryLevel+0x44>)
 802c570:	9400      	str	r4, [sp, #0]
 802c572:	2201      	movs	r2, #1
 802c574:	2100      	movs	r1, #0
 802c576:	2002      	movs	r0, #2
 802c578:	f00e fb94 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
}
 802c57c:	4620      	mov	r0, r4
 802c57e:	b002      	add	sp, #8
 802c580:	bd10      	pop	{r4, pc}
    batteryLevel = LORAWAN_MAX_BAT;
 802c582:	24fe      	movs	r4, #254	; 0xfe
 802c584:	e7f3      	b.n	802c56e <GetBatteryLevel+0x26>
    batteryLevel = 0;
 802c586:	2400      	movs	r4, #0
 802c588:	e7f1      	b.n	802c56e <GetBatteryLevel+0x26>
 802c58a:	bf00      	nop
 802c58c:	0803bd44 	.word	0x0803bd44

0802c590 <GetTemperatureLevel>:
{
 802c590:	b508      	push	{r3, lr}
  temperatureLevel = (uint16_t)(SYS_GetTemperatureLevel() / 256);
 802c592:	f7ff fcf5 	bl	802bf80 <SYS_GetTemperatureLevel>
 802c596:	2800      	cmp	r0, #0
 802c598:	bfb8      	it	lt
 802c59a:	30ff      	addlt	r0, #255	; 0xff
}
 802c59c:	f3c0 200f 	ubfx	r0, r0, #8, #16
 802c5a0:	bd08      	pop	{r3, pc}
	...

0802c5a4 <GetUniqueId>:
{
 802c5a4:	b538      	push	{r3, r4, r5, lr}
  * @brief  Return the Unique Device Number
  * @retval Values between Min_Data=0x00000000 and Max_Data=0xFFFFFFFF
  */
__STATIC_INLINE uint32_t LL_FLASH_GetUDN(void)
{
  return (READ_REG(*((uint32_t *)UID64_BASE)));
 802c5a6:	4b17      	ldr	r3, [pc, #92]	; (802c604 <GetUniqueId+0x60>)
 802c5a8:	681b      	ldr	r3, [r3, #0]
  if (val == 0xFFFFFFFF)  /* Normally this should not happen */
 802c5aa:	1c5a      	adds	r2, r3, #1
{
 802c5ac:	4604      	mov	r4, r0
  if (val == 0xFFFFFFFF)  /* Normally this should not happen */
 802c5ae:	d116      	bne.n	802c5de <GetUniqueId+0x3a>
    uint32_t ID_1_3_val = HAL_GetUIDw0() + HAL_GetUIDw2();
 802c5b0:	f000 ff64 	bl	802d47c <HAL_GetUIDw0>
 802c5b4:	4605      	mov	r5, r0
 802c5b6:	f000 ff6d 	bl	802d494 <HAL_GetUIDw2>
 802c5ba:	4405      	add	r5, r0
    uint32_t ID_2_val = HAL_GetUIDw1();
 802c5bc:	f000 ff64 	bl	802d488 <HAL_GetUIDw1>
    id[7] = (ID_1_3_val) >> 24;
 802c5c0:	0e2b      	lsrs	r3, r5, #24
 802c5c2:	71e3      	strb	r3, [r4, #7]
    id[6] = (ID_1_3_val) >> 16;
 802c5c4:	0c2b      	lsrs	r3, r5, #16
 802c5c6:	71a3      	strb	r3, [r4, #6]
    id[5] = (ID_1_3_val) >> 8;
 802c5c8:	0a2b      	lsrs	r3, r5, #8
 802c5ca:	7163      	strb	r3, [r4, #5]
    id[3] = (ID_2_val) >> 24;
 802c5cc:	0e03      	lsrs	r3, r0, #24
 802c5ce:	70e3      	strb	r3, [r4, #3]
    id[2] = (ID_2_val) >> 16;
 802c5d0:	0c03      	lsrs	r3, r0, #16
 802c5d2:	70a3      	strb	r3, [r4, #2]
    id[1] = (ID_2_val) >> 8;
 802c5d4:	0a03      	lsrs	r3, r0, #8
    id[4] = (ID_1_3_val);
 802c5d6:	7125      	strb	r5, [r4, #4]
    id[1] = (ID_2_val) >> 8;
 802c5d8:	7063      	strb	r3, [r4, #1]
    id[0] = (ID_2_val);
 802c5da:	7020      	strb	r0, [r4, #0]
}
 802c5dc:	bd38      	pop	{r3, r4, r5, pc}
    id[6] = (val >> 8) & 0xFF;
 802c5de:	0a1a      	lsrs	r2, r3, #8
    id[7] = val & 0xFF;
 802c5e0:	71c3      	strb	r3, [r0, #7]
    id[6] = (val >> 8) & 0xFF;
 802c5e2:	7182      	strb	r2, [r0, #6]
    id[5] = (val >> 16) & 0xFF;
 802c5e4:	0c1a      	lsrs	r2, r3, #16
    id[4] = (val >> 24) & 0xFF;
 802c5e6:	0e1b      	lsrs	r3, r3, #24
 802c5e8:	7103      	strb	r3, [r0, #4]
  *         For STM32WLxxxx devices, the device ID is 0x15
  * @retval Values between Min_Data=0x00 and Max_Data=0xFF (ex: Device ID is 0x15)
  */
__STATIC_INLINE uint32_t LL_FLASH_GetDeviceID(void)
{
  return ((READ_REG(*((uint32_t *)UID64_BASE + 1U))) & 0x000000FFU);
 802c5ea:	4b07      	ldr	r3, [pc, #28]	; (802c608 <GetUniqueId+0x64>)
    id[5] = (val >> 16) & 0xFF;
 802c5ec:	7142      	strb	r2, [r0, #5]
    id[3] = val & 0xFF;
 802c5ee:	681a      	ldr	r2, [r3, #0]
 802c5f0:	70c2      	strb	r2, [r0, #3]
  * @note   For STM32WLxxxx devices, the ST Company ID is 0x0080E1
  * @retval Values between Min_Data=0x00 and Max_Data=0xFFFFFF (ex: ST Company ID is 0x0080E1)
  */
__STATIC_INLINE uint32_t LL_FLASH_GetSTCompanyID(void)
{
  return (((READ_REG(*((uint32_t *)UID64_BASE + 1U))) >> 8U) & 0x00FFFFFFU);
 802c5f2:	681b      	ldr	r3, [r3, #0]
 802c5f4:	0a1a      	lsrs	r2, r3, #8
    id[2] = val & 0xFF;
 802c5f6:	7082      	strb	r2, [r0, #2]
    id[1] = (val >> 8) & 0xFF;
 802c5f8:	0c1a      	lsrs	r2, r3, #16
    id[0] = (val >> 16) & 0xFF;
 802c5fa:	0e1b      	lsrs	r3, r3, #24
    id[1] = (val >> 8) & 0xFF;
 802c5fc:	7042      	strb	r2, [r0, #1]
    id[0] = (val >> 16) & 0xFF;
 802c5fe:	7003      	strb	r3, [r0, #0]
}
 802c600:	e7ec      	b.n	802c5dc <GetUniqueId+0x38>
 802c602:	bf00      	nop
 802c604:	1fff7580 	.word	0x1fff7580
 802c608:	1fff7584 	.word	0x1fff7584

0802c60c <GetDevAddr>:
  return (READ_REG(*((uint32_t *)UID64_BASE)));
 802c60c:	4b07      	ldr	r3, [pc, #28]	; (802c62c <GetDevAddr+0x20>)
 802c60e:	6818      	ldr	r0, [r3, #0]
  if (val == 0xFFFFFFFF)
 802c610:	1c43      	adds	r3, r0, #1
{
 802c612:	b510      	push	{r4, lr}
  if (val == 0xFFFFFFFF)
 802c614:	d108      	bne.n	802c628 <GetDevAddr+0x1c>
    val = ((HAL_GetUIDw0()) ^ (HAL_GetUIDw1()) ^ (HAL_GetUIDw2()));
 802c616:	f000 ff31 	bl	802d47c <HAL_GetUIDw0>
 802c61a:	4604      	mov	r4, r0
 802c61c:	f000 ff34 	bl	802d488 <HAL_GetUIDw1>
 802c620:	4044      	eors	r4, r0
 802c622:	f000 ff37 	bl	802d494 <HAL_GetUIDw2>
 802c626:	4060      	eors	r0, r4
}
 802c628:	bd10      	pop	{r4, pc}
 802c62a:	bf00      	nop
 802c62c:	1fff7580 	.word	0x1fff7580

0802c630 <UTIL_ADV_TRACE_PreSendHook>:
  UTIL_LPM_SetStopMode((1 << CFG_LPM_UART_TX_Id), UTIL_LPM_DISABLE);
 802c630:	2101      	movs	r1, #1
 802c632:	2002      	movs	r0, #2
 802c634:	f00e bbf4 	b.w	803ae20 <UTIL_LPM_SetStopMode>

0802c638 <UTIL_ADV_TRACE_PostSendHook>:
  UTIL_LPM_SetStopMode((1 << CFG_LPM_UART_TX_Id), UTIL_LPM_ENABLE);
 802c638:	2100      	movs	r1, #0
 802c63a:	2002      	movs	r0, #2
 802c63c:	f00e bbf0 	b.w	803ae20 <UTIL_LPM_SetStopMode>

0802c640 <HAL_InitTick>:
  /* USER CODE END HAL_InitTick_1 */
  return HAL_OK;
  /* USER CODE BEGIN HAL_InitTick_2 */

  /* USER CODE END HAL_InitTick_2 */
}
 802c640:	2000      	movs	r0, #0
 802c642:	4770      	bx	lr

0802c644 <HAL_GetTick>:
{
  /* TIMER_IF can be based on other counter the SysTick e.g. RTC */
  /* USER CODE BEGIN HAL_GetTick_1 */

  /* USER CODE END HAL_GetTick_1 */
  return TIMER_IF_GetTimerValue();
 802c644:	f000 b844 	b.w	802c6d0 <TIMER_IF_GetTimerValue>

0802c648 <HAL_Delay>:

/**
  * @note This function overwrites the __weak one from HAL
  */
void HAL_Delay(__IO uint32_t Delay)
{
 802c648:	b082      	sub	sp, #8
 802c64a:	9001      	str	r0, [sp, #4]
  /* TIMER_IF can be based on other counter the SysTick e.g. RTC */
  /* USER CODE BEGIN HAL_Delay_1 */

  /* USER CODE END HAL_Delay_1 */
  TIMER_IF_DelayMs(Delay);
 802c64c:	9801      	ldr	r0, [sp, #4]
  /* USER CODE BEGIN HAL_Delay_2 */

  /* USER CODE END HAL_Delay_2 */
}
 802c64e:	b002      	add	sp, #8
  TIMER_IF_DelayMs(Delay);
 802c650:	f000 b8f8 	b.w	802c844 <TIMER_IF_DelayMs>

0802c654 <DBG_ConfigForLpm>:
  enable_dbg = 0;
#elif !defined (DEBUGGER_ENABLED)
#error "DEBUGGER_ENABLED not defined or out of range <0,1>"
#endif /* DEBUGGER_OFF */

  if (enable_dbg == 1)
 802c654:	2801      	cmp	r0, #1
{
 802c656:	b508      	push	{r3, lr}
  if (enable_dbg == 1)
 802c658:	d107      	bne.n	802c66a <DBG_ConfigForLpm+0x16>
  {
    HAL_DBGMCU_EnableDBGSleepMode();
 802c65a:	f000 ff21 	bl	802d4a0 <HAL_DBGMCU_EnableDBGSleepMode>
    HAL_DBGMCU_EnableDBGStopMode();
 802c65e:	f000 ff2f 	bl	802d4c0 <HAL_DBGMCU_EnableDBGStopMode>
  }

  /* USER CODE BEGIN DBG_ConfigForLpm_Last */

  /* USER CODE END DBG_ConfigForLpm_Last */
}
 802c662:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    HAL_DBGMCU_EnableDBGStandbyMode();
 802c666:	f000 bf3b 	b.w	802d4e0 <HAL_DBGMCU_EnableDBGStandbyMode>
    HAL_DBGMCU_DisableDBGSleepMode();
 802c66a:	f000 ff21 	bl	802d4b0 <HAL_DBGMCU_DisableDBGSleepMode>
    HAL_DBGMCU_DisableDBGStopMode();
 802c66e:	f000 ff2f 	bl	802d4d0 <HAL_DBGMCU_DisableDBGStopMode>
}
 802c672:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    HAL_DBGMCU_DisableDBGStandbyMode();
 802c676:	f000 bf3b 	b.w	802d4f0 <HAL_DBGMCU_DisableDBGStandbyMode>

0802c67a <DBG_Disable>:
  DBG_ConfigForLpm(0);
 802c67a:	2000      	movs	r0, #0
 802c67c:	f7ff bfea 	b.w	802c654 <DBG_ConfigForLpm>

0802c680 <DBG_ProbesInit>:
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_EnableIT_32_63(uint32_t ExtiLine)
{
  SET_BIT(EXTI->IMR2, ExtiLine);
 802c680:	4a03      	ldr	r2, [pc, #12]	; (802c690 <DBG_ProbesInit+0x10>)
 802c682:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 802c686:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 802c68a:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
#endif /* CORE_CM4 */

  /* USER CODE BEGIN DBG_ProbesInit_Last */

  /* USER CODE END DBG_ProbesInit_Last */
}
 802c68e:	4770      	bx	lr
 802c690:	58000800 	.word	0x58000800

0802c694 <EnvSensors_Init>:
#elif !defined (SENSOR_ENABLED)
#error SENSOR_ENABLED not defined
#endif /* SENSOR_ENABLED  */
  return 0;
  /* USER CODE END EnvSensors_Init */
}
 802c694:	2000      	movs	r0, #0
 802c696:	4770      	bx	lr

0802c698 <TIMER_IF_SetTimerContext>:
  * @retval If binary mode is none, Value between Min_Data=0x0 and Max_Data=0x7FFF
  *         else Value between Min_Data=0x0 and Max_Data=0xFFFFFFFF
  */
__STATIC_INLINE uint32_t LL_RTC_TIME_GetSubSecond(RTC_TypeDef *RTCx)
{
  return (uint32_t)(READ_BIT(RTCx->SSR, RTC_SSR_SS));
 802c698:	4b02      	ldr	r3, [pc, #8]	; (802c6a4 <TIMER_IF_SetTimerContext+0xc>)
 802c69a:	6898      	ldr	r0, [r3, #8]
}

uint32_t TIMER_IF_SetTimerContext(void)
{
  /*store time context*/
  RtcTimerContext = GetTimerTicks();
 802c69c:	4b02      	ldr	r3, [pc, #8]	; (802c6a8 <TIMER_IF_SetTimerContext+0x10>)
static inline uint32_t GetTimerTicks(void)
{
  /* USER CODE BEGIN GetTimerTicks */

  /* USER CODE END GetTimerTicks */
  return (UINT32_MAX - LL_RTC_TIME_GetSubSecond(RTC));
 802c69e:	43c0      	mvns	r0, r0
  RtcTimerContext = GetTimerTicks();
 802c6a0:	6018      	str	r0, [r3, #0]
}
 802c6a2:	4770      	bx	lr
 802c6a4:	40002800 	.word	0x40002800
 802c6a8:	200035c8 	.word	0x200035c8

0802c6ac <TIMER_IF_GetTimerContext>:
}
 802c6ac:	4b01      	ldr	r3, [pc, #4]	; (802c6b4 <TIMER_IF_GetTimerContext+0x8>)
 802c6ae:	6818      	ldr	r0, [r3, #0]
 802c6b0:	4770      	bx	lr
 802c6b2:	bf00      	nop
 802c6b4:	200035c8 	.word	0x200035c8

0802c6b8 <TIMER_IF_GetTimerElapsedTime>:
 802c6b8:	4b03      	ldr	r3, [pc, #12]	; (802c6c8 <TIMER_IF_GetTimerElapsedTime+0x10>)
  ret = ((uint32_t)(GetTimerTicks() - RtcTimerContext));
 802c6ba:	4a04      	ldr	r2, [pc, #16]	; (802c6cc <TIMER_IF_GetTimerElapsedTime+0x14>)
 802c6bc:	689b      	ldr	r3, [r3, #8]
 802c6be:	6810      	ldr	r0, [r2, #0]
  return (UINT32_MAX - LL_RTC_TIME_GetSubSecond(RTC));
 802c6c0:	43db      	mvns	r3, r3
}
 802c6c2:	1a18      	subs	r0, r3, r0
 802c6c4:	4770      	bx	lr
 802c6c6:	bf00      	nop
 802c6c8:	40002800 	.word	0x40002800
 802c6cc:	200035c8 	.word	0x200035c8

0802c6d0 <TIMER_IF_GetTimerValue>:
  if (RTC_Initialized == true)
 802c6d0:	4b03      	ldr	r3, [pc, #12]	; (802c6e0 <TIMER_IF_GetTimerValue+0x10>)
 802c6d2:	7918      	ldrb	r0, [r3, #4]
 802c6d4:	b110      	cbz	r0, 802c6dc <TIMER_IF_GetTimerValue+0xc>
 802c6d6:	4b03      	ldr	r3, [pc, #12]	; (802c6e4 <TIMER_IF_GetTimerValue+0x14>)
 802c6d8:	6898      	ldr	r0, [r3, #8]
  return (UINT32_MAX - LL_RTC_TIME_GetSubSecond(RTC));
 802c6da:	43c0      	mvns	r0, r0
}
 802c6dc:	4770      	bx	lr
 802c6de:	bf00      	nop
 802c6e0:	200035c8 	.word	0x200035c8
 802c6e4:	40002800 	.word	0x40002800

0802c6e8 <TIMER_IF_GetMinimumTimeout>:
}
 802c6e8:	2003      	movs	r0, #3
 802c6ea:	4770      	bx	lr

0802c6ec <TIMER_IF_Convert_ms2Tick>:
{
 802c6ec:	b508      	push	{r3, lr}
 802c6ee:	4601      	mov	r1, r0
  ret = ((uint32_t)((((uint64_t) timeMilliSec) << RTC_N_PREDIV_S) / 1000));
 802c6f0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 802c6f4:	2300      	movs	r3, #0
 802c6f6:	0280      	lsls	r0, r0, #10
 802c6f8:	0d89      	lsrs	r1, r1, #22
 802c6fa:	f7ff fa23 	bl	802bb44 <__aeabi_uldivmod>
}
 802c6fe:	bd08      	pop	{r3, pc}

0802c700 <TIMER_IF_Convert_Tick2ms>:
  ret = ((uint32_t)((((uint64_t)(tick)) * 1000) >> RTC_N_PREDIV_S));
 802c700:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 802c704:	fba0 2302 	umull	r2, r3, r0, r2
 802c708:	0a90      	lsrs	r0, r2, #10
}
 802c70a:	ea40 5083 	orr.w	r0, r0, r3, lsl #22
 802c70e:	4770      	bx	lr

0802c710 <TIMER_IF_StopTimer>:
{
 802c710:	b510      	push	{r4, lr}
  __HAL_RTC_ALARM_CLEAR_FLAG(&hrtc, RTC_FLAG_ALRAF);
 802c712:	4b07      	ldr	r3, [pc, #28]	; (802c730 <TIMER_IF_StopTimer+0x20>)
  HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_A);
 802c714:	4c07      	ldr	r4, [pc, #28]	; (802c734 <TIMER_IF_StopTimer+0x24>)
  __HAL_RTC_ALARM_CLEAR_FLAG(&hrtc, RTC_FLAG_ALRAF);
 802c716:	2201      	movs	r2, #1
 802c718:	65da      	str	r2, [r3, #92]	; 0x5c
  HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_A);
 802c71a:	f44f 7180 	mov.w	r1, #256	; 0x100
 802c71e:	4620      	mov	r0, r4
 802c720:	f002 fe12 	bl	802f348 <HAL_RTC_DeactivateAlarm>
  hrtc.IsEnabled.RtcFeatures = UINT32_MAX;
 802c724:	f04f 33ff 	mov.w	r3, #4294967295
 802c728:	6323      	str	r3, [r4, #48]	; 0x30
}
 802c72a:	2000      	movs	r0, #0
 802c72c:	bd10      	pop	{r4, pc}
 802c72e:	bf00      	nop
 802c730:	40002800 	.word	0x40002800
 802c734:	200061b8 	.word	0x200061b8

0802c738 <TIMER_IF_BkUp_Write_Seconds>:
{
 802c738:	4602      	mov	r2, r0
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_SECONDS, Seconds);
 802c73a:	2100      	movs	r1, #0
 802c73c:	4801      	ldr	r0, [pc, #4]	; (802c744 <TIMER_IF_BkUp_Write_Seconds+0xc>)
 802c73e:	f003 b818 	b.w	802f772 <HAL_RTCEx_BKUPWrite>
 802c742:	bf00      	nop
 802c744:	200061b8 	.word	0x200061b8

0802c748 <TIMER_IF_BkUp_Write_SubSeconds>:
{
 802c748:	4602      	mov	r2, r0
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_SUBSECONDS, SubSeconds);
 802c74a:	2101      	movs	r1, #1
 802c74c:	4801      	ldr	r0, [pc, #4]	; (802c754 <TIMER_IF_BkUp_Write_SubSeconds+0xc>)
 802c74e:	f003 b810 	b.w	802f772 <HAL_RTCEx_BKUPWrite>
 802c752:	bf00      	nop
 802c754:	200061b8 	.word	0x200061b8

0802c758 <TIMER_IF_StartTimer>:
{
 802c758:	b510      	push	{r4, lr}
 802c75a:	b08c      	sub	sp, #48	; 0x30
  RTC_AlarmTypeDef sAlarm = {0};
 802c75c:	222c      	movs	r2, #44	; 0x2c
 802c75e:	2100      	movs	r1, #0
{
 802c760:	4604      	mov	r4, r0
  RTC_AlarmTypeDef sAlarm = {0};
 802c762:	a801      	add	r0, sp, #4
 802c764:	f00e ffe4 	bl	803b730 <memset>
  TIMER_IF_StopTimer();
 802c768:	f7ff ffd2 	bl	802c710 <TIMER_IF_StopTimer>
  timeout += RtcTimerContext;
 802c76c:	4b0c      	ldr	r3, [pc, #48]	; (802c7a0 <TIMER_IF_StartTimer+0x48>)
 802c76e:	6818      	ldr	r0, [r3, #0]
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
 802c770:	2300      	movs	r3, #0
  timeout += RtcTimerContext;
 802c772:	4404      	add	r4, r0
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
 802c774:	9308      	str	r3, [sp, #32]
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
 802c776:	9306      	str	r3, [sp, #24]
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDBINMASK_NONE;
 802c778:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
  sAlarm.AlarmTime.SubSeconds = UINT32_MAX - timeout;
 802c77c:	43e4      	mvns	r4, r4
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDBINMASK_NONE;
 802c77e:	9307      	str	r3, [sp, #28]
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 802c780:	4808      	ldr	r0, [pc, #32]	; (802c7a4 <TIMER_IF_StartTimer+0x4c>)
  sAlarm.AlarmTime.SubSeconds = UINT32_MAX - timeout;
 802c782:	9402      	str	r4, [sp, #8]
  sAlarm.Alarm = RTC_ALARM_A;
 802c784:	f44f 7380 	mov.w	r3, #256	; 0x100
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 802c788:	2201      	movs	r2, #1
 802c78a:	a901      	add	r1, sp, #4
  sAlarm.Alarm = RTC_ALARM_A;
 802c78c:	930b      	str	r3, [sp, #44]	; 0x2c
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 802c78e:	f002 fef1 	bl	802f574 <HAL_RTC_SetAlarm_IT>
 802c792:	b108      	cbz	r0, 802c798 <TIMER_IF_StartTimer+0x40>
    Error_Handler();
 802c794:	f7ff fd8e 	bl	802c2b4 <Error_Handler>
}
 802c798:	2000      	movs	r0, #0
 802c79a:	b00c      	add	sp, #48	; 0x30
 802c79c:	bd10      	pop	{r4, pc}
 802c79e:	bf00      	nop
 802c7a0:	200035c8 	.word	0x200035c8
 802c7a4:	200061b8 	.word	0x200061b8

0802c7a8 <TIMER_IF_GetTime>:
 802c7a8:	4b0c      	ldr	r3, [pc, #48]	; (802c7dc <TIMER_IF_GetTime+0x34>)
{
 802c7aa:	b570      	push	{r4, r5, r6, lr}
 802c7ac:	689c      	ldr	r4, [r3, #8]
 802c7ae:	4606      	mov	r6, r0
  MSBticks = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_MSBTICKS);
 802c7b0:	2102      	movs	r1, #2
 802c7b2:	480b      	ldr	r0, [pc, #44]	; (802c7e0 <TIMER_IF_GetTime+0x38>)
 802c7b4:	f002 ffe4 	bl	802f780 <HAL_RTCEx_BKUPRead>
  return (UINT32_MAX - LL_RTC_TIME_GetSubSecond(RTC));
 802c7b8:	43e4      	mvns	r4, r4
  ticks = (((uint64_t) timerValueMSB) << 32) + timerValueLsb;
 802c7ba:	2200      	movs	r2, #0
 802c7bc:	1912      	adds	r2, r2, r4
  ticks = (uint32_t) ticks & RTC_PREDIV_S;
 802c7be:	f3c2 0409 	ubfx	r4, r2, #0, #10
  ret = ((uint32_t)((((uint64_t)(tick)) * 1000) >> RTC_N_PREDIV_S));
 802c7c2:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 802c7c6:	fba4 4501 	umull	r4, r5, r4, r1
  ticks = (((uint64_t) timerValueMSB) << 32) + timerValueLsb;
 802c7ca:	f140 0300 	adc.w	r3, r0, #0
  ret = ((uint32_t)((((uint64_t)(tick)) * 1000) >> RTC_N_PREDIV_S));
 802c7ce:	0aa4      	lsrs	r4, r4, #10
  seconds = (uint32_t)(ticks >> RTC_N_PREDIV_S);
 802c7d0:	0a90      	lsrs	r0, r2, #10
  *mSeconds = TIMER_IF_Convert_Tick2ms(ticks);
 802c7d2:	8034      	strh	r4, [r6, #0]
}
 802c7d4:	ea40 5083 	orr.w	r0, r0, r3, lsl #22
 802c7d8:	bd70      	pop	{r4, r5, r6, pc}
 802c7da:	bf00      	nop
 802c7dc:	40002800 	.word	0x40002800
 802c7e0:	200061b8 	.word	0x200061b8

0802c7e4 <TIMER_IF_BkUp_Read_Seconds>:
  ret = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_SECONDS);
 802c7e4:	4801      	ldr	r0, [pc, #4]	; (802c7ec <TIMER_IF_BkUp_Read_Seconds+0x8>)
 802c7e6:	2100      	movs	r1, #0
 802c7e8:	f002 bfca 	b.w	802f780 <HAL_RTCEx_BKUPRead>
 802c7ec:	200061b8 	.word	0x200061b8

0802c7f0 <TIMER_IF_BkUp_Read_SubSeconds>:
  ret = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_SUBSECONDS);
 802c7f0:	4801      	ldr	r0, [pc, #4]	; (802c7f8 <TIMER_IF_BkUp_Read_SubSeconds+0x8>)
 802c7f2:	2101      	movs	r1, #1
 802c7f4:	f002 bfc4 	b.w	802f780 <HAL_RTCEx_BKUPRead>
 802c7f8:	200061b8 	.word	0x200061b8

0802c7fc <TIMER_IF_Init>:
{
 802c7fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (RTC_Initialized == false)
 802c7fe:	4d0f      	ldr	r5, [pc, #60]	; (802c83c <TIMER_IF_Init+0x40>)
 802c800:	792e      	ldrb	r6, [r5, #4]
 802c802:	b9ce      	cbnz	r6, 802c838 <TIMER_IF_Init+0x3c>
    hrtc.IsEnabled.RtcFeatures = UINT32_MAX;
 802c804:	4c0e      	ldr	r4, [pc, #56]	; (802c840 <TIMER_IF_Init+0x44>)
 802c806:	f04f 37ff 	mov.w	r7, #4294967295
 802c80a:	6327      	str	r7, [r4, #48]	; 0x30
    MX_RTC_Init();
 802c80c:	f7ff fd54 	bl	802c2b8 <MX_RTC_Init>
    TIMER_IF_StopTimer();
 802c810:	f7ff ff7e 	bl	802c710 <TIMER_IF_StopTimer>
    HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_A);
 802c814:	f44f 7180 	mov.w	r1, #256	; 0x100
 802c818:	4620      	mov	r0, r4
 802c81a:	f002 fd95 	bl	802f348 <HAL_RTC_DeactivateAlarm>
    HAL_RTCEx_EnableBypassShadow(&hrtc);
 802c81e:	4620      	mov	r0, r4
    hrtc.IsEnabled.RtcFeatures = UINT32_MAX;
 802c820:	6327      	str	r7, [r4, #48]	; 0x30
    HAL_RTCEx_EnableBypassShadow(&hrtc);
 802c822:	f002 ff51 	bl	802f6c8 <HAL_RTCEx_EnableBypassShadow>
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_MSBTICKS, MSBticks);
 802c826:	4632      	mov	r2, r6
 802c828:	2102      	movs	r1, #2
 802c82a:	4620      	mov	r0, r4
 802c82c:	f002 ffa1 	bl	802f772 <HAL_RTCEx_BKUPWrite>
    TIMER_IF_SetTimerContext();
 802c830:	f7ff ff32 	bl	802c698 <TIMER_IF_SetTimerContext>
    RTC_Initialized = true;
 802c834:	2301      	movs	r3, #1
 802c836:	712b      	strb	r3, [r5, #4]
}
 802c838:	2000      	movs	r0, #0
 802c83a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802c83c:	200035c8 	.word	0x200035c8
 802c840:	200061b8 	.word	0x200061b8

0802c844 <TIMER_IF_DelayMs>:
{
 802c844:	4601      	mov	r1, r0
 802c846:	b508      	push	{r3, lr}
  ret = ((uint32_t)((((uint64_t) timeMilliSec) << RTC_N_PREDIV_S) / 1000));
 802c848:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 802c84c:	2300      	movs	r3, #0
 802c84e:	0280      	lsls	r0, r0, #10
 802c850:	0d89      	lsrs	r1, r1, #22
 802c852:	f7ff f977 	bl	802bb44 <__aeabi_uldivmod>
 802c856:	4a05      	ldr	r2, [pc, #20]	; (802c86c <TIMER_IF_DelayMs+0x28>)
 802c858:	6891      	ldr	r1, [r2, #8]
  return (UINT32_MAX - LL_RTC_TIME_GetSubSecond(RTC));
 802c85a:	43c9      	mvns	r1, r1
 802c85c:	6893      	ldr	r3, [r2, #8]
 802c85e:	43db      	mvns	r3, r3
  while (((GetTimerTicks() - timeout)) < delayTicks)
 802c860:	1a5b      	subs	r3, r3, r1
 802c862:	4283      	cmp	r3, r0
 802c864:	d300      	bcc.n	802c868 <TIMER_IF_DelayMs+0x24>
}
 802c866:	bd08      	pop	{r3, pc}
    __NOP();
 802c868:	bf00      	nop
 802c86a:	e7f7      	b.n	802c85c <TIMER_IF_DelayMs+0x18>
 802c86c:	40002800 	.word	0x40002800

0802c870 <HAL_RTC_AlarmAEventCallback>:
  UTIL_TIMER_IRQ_MAP_PROCESS();
 802c870:	f00e bddc 	b.w	803b42c <UTIL_TIMER_IRQ_Handler>

0802c874 <HAL_RTCEx_SSRUEventCallback>:
{
 802c874:	b510      	push	{r4, lr}
  MSBticks = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_MSBTICKS);
 802c876:	4c06      	ldr	r4, [pc, #24]	; (802c890 <HAL_RTCEx_SSRUEventCallback+0x1c>)
 802c878:	2102      	movs	r1, #2
 802c87a:	4620      	mov	r0, r4
 802c87c:	f002 ff80 	bl	802f780 <HAL_RTCEx_BKUPRead>
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_MSBTICKS, MSBticks);
 802c880:	2102      	movs	r1, #2
 802c882:	1c42      	adds	r2, r0, #1
 802c884:	4620      	mov	r0, r4
}
 802c886:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_MSBTICKS, MSBticks);
 802c88a:	f002 bf72 	b.w	802f772 <HAL_RTCEx_BKUPWrite>
 802c88e:	bf00      	nop
 802c890:	200061b8 	.word	0x200061b8

0802c894 <MX_USART2_UART_Init>:
  /* USER CODE END USART2_Init 0 */

  /* USER CODE BEGIN USART2_Init 1 */

  /* USER CODE END USART2_Init 1 */
  huart2.Instance = USART2;
 802c894:	4816      	ldr	r0, [pc, #88]	; (802c8f0 <MX_USART2_UART_Init+0x5c>)
  huart2.Init.BaudRate = 115200;
 802c896:	4a17      	ldr	r2, [pc, #92]	; (802c8f4 <MX_USART2_UART_Init+0x60>)
{
 802c898:	b508      	push	{r3, lr}
  huart2.Init.BaudRate = 115200;
 802c89a:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
 802c89e:	e9c0 2300 	strd	r2, r3, [r0]
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 802c8a2:	2300      	movs	r3, #0
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
 802c8a4:	220c      	movs	r2, #12
  huart2.Init.StopBits = UART_STOPBITS_1;
 802c8a6:	e9c0 3302 	strd	r3, r3, [r0, #8]
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 802c8aa:	e9c0 2305 	strd	r2, r3, [r0, #20]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 802c8ae:	e9c0 3307 	strd	r3, r3, [r0, #28]
  huart2.Init.ClockPrescaler = UART_PRESCALER_DIV1;
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 802c8b2:	e9c0 3309 	strd	r3, r3, [r0, #36]	; 0x24
  huart2.Init.Parity = UART_PARITY_NONE;
 802c8b6:	6103      	str	r3, [r0, #16]
  if (HAL_UART_Init(&huart2) != HAL_OK)
 802c8b8:	f004 f880 	bl	80309bc <HAL_UART_Init>
 802c8bc:	b108      	cbz	r0, 802c8c2 <MX_USART2_UART_Init+0x2e>
  {
    Error_Handler();
 802c8be:	f7ff fcf9 	bl	802c2b4 <Error_Handler>
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart2, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
 802c8c2:	480b      	ldr	r0, [pc, #44]	; (802c8f0 <MX_USART2_UART_Init+0x5c>)
 802c8c4:	2100      	movs	r1, #0
 802c8c6:	f004 fa00 	bl	8030cca <HAL_UARTEx_SetTxFifoThreshold>
 802c8ca:	b108      	cbz	r0, 802c8d0 <MX_USART2_UART_Init+0x3c>
  {
    Error_Handler();
 802c8cc:	f7ff fcf2 	bl	802c2b4 <Error_Handler>
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart2, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
 802c8d0:	4807      	ldr	r0, [pc, #28]	; (802c8f0 <MX_USART2_UART_Init+0x5c>)
 802c8d2:	2100      	movs	r1, #0
 802c8d4:	f004 fa1d 	bl	8030d12 <HAL_UARTEx_SetRxFifoThreshold>
 802c8d8:	b108      	cbz	r0, 802c8de <MX_USART2_UART_Init+0x4a>
  {
    Error_Handler();
 802c8da:	f7ff fceb 	bl	802c2b4 <Error_Handler>
  }
  if (HAL_UARTEx_EnableFifoMode(&huart2) != HAL_OK)
 802c8de:	4804      	ldr	r0, [pc, #16]	; (802c8f0 <MX_USART2_UART_Init+0x5c>)
 802c8e0:	f004 f9d0 	bl	8030c84 <HAL_UARTEx_EnableFifoMode>
 802c8e4:	b118      	cbz	r0, 802c8ee <MX_USART2_UART_Init+0x5a>
  }
  /* USER CODE BEGIN USART2_Init 2 */

  /* USER CODE END USART2_Init 2 */

}
 802c8e6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 802c8ea:	f7ff bce3 	b.w	802c2b4 <Error_Handler>
}
 802c8ee:	bd08      	pop	{r3, pc}
 802c8f0:	2000625c 	.word	0x2000625c
 802c8f4:	40004400 	.word	0x40004400

0802c8f8 <HAL_UART_MspInit>:

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
 802c8f8:	b570      	push	{r4, r5, r6, lr}
 802c8fa:	b096      	sub	sp, #88	; 0x58
 802c8fc:	4606      	mov	r6, r0

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 802c8fe:	2214      	movs	r2, #20
 802c900:	2100      	movs	r1, #0
 802c902:	a803      	add	r0, sp, #12
 802c904:	f00e ff14 	bl	803b730 <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 802c908:	2238      	movs	r2, #56	; 0x38
 802c90a:	2100      	movs	r1, #0
 802c90c:	a808      	add	r0, sp, #32
 802c90e:	f00e ff0f 	bl	803b730 <memset>
  if(uartHandle->Instance==USART2)
 802c912:	6832      	ldr	r2, [r6, #0]
 802c914:	4b2b      	ldr	r3, [pc, #172]	; (802c9c4 <HAL_UART_MspInit+0xcc>)
 802c916:	429a      	cmp	r2, r3
 802c918:	d151      	bne.n	802c9be <HAL_UART_MspInit+0xc6>
  /* USER CODE BEGIN USART2_MspInit 0 */

  /* USER CODE END USART2_MspInit 0 */
  /** Initializes the peripherals clocks
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART2;
 802c91a:	2302      	movs	r3, #2
 802c91c:	9308      	str	r3, [sp, #32]
    PeriphClkInitStruct.Usart2ClockSelection = RCC_USART2CLKSOURCE_SYSCLK;
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 802c91e:	a808      	add	r0, sp, #32
    PeriphClkInitStruct.Usart2ClockSelection = RCC_USART2CLKSOURCE_SYSCLK;
 802c920:	4b29      	ldr	r3, [pc, #164]	; (802c9c8 <HAL_UART_MspInit+0xd0>)
 802c922:	930a      	str	r3, [sp, #40]	; 0x28
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 802c924:	f002 fc3a 	bl	802f19c <HAL_RCCEx_PeriphCLKConfig>
 802c928:	b108      	cbz	r0, 802c92e <HAL_UART_MspInit+0x36>
    {
      Error_Handler();
 802c92a:	f7ff fcc3 	bl	802c2b4 <Error_Handler>
  SET_BIT(RCC->APB1ENR1, Periphs);
 802c92e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
    PA2     ------> USART2_TX
    */
    GPIO_InitStruct.Pin = USARTx_RX_Pin|USARTx_TX_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 802c932:	2500      	movs	r5, #0
 802c934:	6d9a      	ldr	r2, [r3, #88]	; 0x58
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* USART2 DMA Init */
    /* USART2_TX Init */
    hdma_usart2_tx.Instance = DMA1_Channel5;
 802c936:	4c25      	ldr	r4, [pc, #148]	; (802c9cc <HAL_UART_MspInit+0xd4>)
 802c938:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 802c93c:	659a      	str	r2, [r3, #88]	; 0x58
  tmpreg = READ_BIT(RCC->APB1ENR1, Periphs);
 802c93e:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 802c940:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
 802c944:	9202      	str	r2, [sp, #8]
  (void)tmpreg;
 802c946:	9a02      	ldr	r2, [sp, #8]
  SET_BIT(RCC->AHB2ENR, Periphs);
 802c948:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 802c94a:	f042 0201 	orr.w	r2, r2, #1
 802c94e:	64da      	str	r2, [r3, #76]	; 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 802c950:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 802c952:	f003 0301 	and.w	r3, r3, #1
 802c956:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 802c958:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 802c95a:	220c      	movs	r2, #12
 802c95c:	2302      	movs	r3, #2
 802c95e:	e9cd 2303 	strd	r2, r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 802c962:	2303      	movs	r3, #3
 802c964:	e9cd 5305 	strd	r5, r3, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 802c968:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 802c96a:	2307      	movs	r3, #7
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 802c96c:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 802c970:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 802c972:	f001 fd7d 	bl	802e470 <HAL_GPIO_Init>
    hdma_usart2_tx.Init.Request = DMA_REQUEST_USART2_TX;
 802c976:	4916      	ldr	r1, [pc, #88]	; (802c9d0 <HAL_UART_MspInit+0xd8>)
    hdma_usart2_tx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_usart2_tx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_usart2_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_usart2_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_usart2_tx.Init.Mode = DMA_NORMAL;
    hdma_usart2_tx.Init.Priority = DMA_PRIORITY_LOW;
 802c978:	6225      	str	r5, [r4, #32]
    hdma_usart2_tx.Init.Request = DMA_REQUEST_USART2_TX;
 802c97a:	2314      	movs	r3, #20
 802c97c:	e9c4 1300 	strd	r1, r3, [r4]
    hdma_usart2_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 802c980:	2310      	movs	r3, #16
    hdma_usart2_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 802c982:	e9c4 3502 	strd	r3, r5, [r4, #8]
    if (HAL_DMA_Init(&hdma_usart2_tx) != HAL_OK)
 802c986:	4620      	mov	r0, r4
    hdma_usart2_tx.Init.MemInc = DMA_MINC_ENABLE;
 802c988:	2380      	movs	r3, #128	; 0x80
    hdma_usart2_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 802c98a:	e9c4 3504 	strd	r3, r5, [r4, #16]
    hdma_usart2_tx.Init.Mode = DMA_NORMAL;
 802c98e:	e9c4 5506 	strd	r5, r5, [r4, #24]
    if (HAL_DMA_Init(&hdma_usart2_tx) != HAL_OK)
 802c992:	f001 fa53 	bl	802de3c <HAL_DMA_Init>
 802c996:	b108      	cbz	r0, 802c99c <HAL_UART_MspInit+0xa4>
    {
      Error_Handler();
 802c998:	f7ff fc8c 	bl	802c2b4 <Error_Handler>
    }

    if (HAL_DMA_ConfigChannelAttributes(&hdma_usart2_tx, DMA_CHANNEL_NPRIV) != HAL_OK)
 802c99c:	480b      	ldr	r0, [pc, #44]	; (802c9cc <HAL_UART_MspInit+0xd4>)
 802c99e:	2110      	movs	r1, #16
 802c9a0:	f001 fc1e 	bl	802e1e0 <HAL_DMA_ConfigChannelAttributes>
 802c9a4:	b108      	cbz	r0, 802c9aa <HAL_UART_MspInit+0xb2>
    {
      Error_Handler();
 802c9a6:	f7ff fc85 	bl	802c2b4 <Error_Handler>
    }

    __HAL_LINKDMA(uartHandle,hdmatx,hdma_usart2_tx);

    /* USART2 interrupt Init */
    HAL_NVIC_SetPriority(USART2_IRQn, 2, 0);
 802c9aa:	2025      	movs	r0, #37	; 0x25
    __HAL_LINKDMA(uartHandle,hdmatx,hdma_usart2_tx);
 802c9ac:	67b4      	str	r4, [r6, #120]	; 0x78
    HAL_NVIC_SetPriority(USART2_IRQn, 2, 0);
 802c9ae:	2200      	movs	r2, #0
 802c9b0:	2102      	movs	r1, #2
    __HAL_LINKDMA(uartHandle,hdmatx,hdma_usart2_tx);
 802c9b2:	62a6      	str	r6, [r4, #40]	; 0x28
    HAL_NVIC_SetPriority(USART2_IRQn, 2, 0);
 802c9b4:	f001 f9ae 	bl	802dd14 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART2_IRQn);
 802c9b8:	2025      	movs	r0, #37	; 0x25
 802c9ba:	f001 f9dd 	bl	802dd78 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USART2_MspInit 1 */

  /* USER CODE END USART2_MspInit 1 */
  }
}
 802c9be:	b016      	add	sp, #88	; 0x58
 802c9c0:	bd70      	pop	{r4, r5, r6, pc}
 802c9c2:	bf00      	nop
 802c9c4:	40004400 	.word	0x40004400
 802c9c8:	000c0004 	.word	0x000c0004
 802c9cc:	200061fc 	.word	0x200061fc
 802c9d0:	40020058 	.word	0x40020058

0802c9d4 <HAL_UART_MspDeInit>:

void HAL_UART_MspDeInit(UART_HandleTypeDef* uartHandle)
{

  if(uartHandle->Instance==USART2)
 802c9d4:	6802      	ldr	r2, [r0, #0]
 802c9d6:	4b0c      	ldr	r3, [pc, #48]	; (802ca08 <HAL_UART_MspDeInit+0x34>)
 802c9d8:	429a      	cmp	r2, r3
{
 802c9da:	b510      	push	{r4, lr}
 802c9dc:	4604      	mov	r4, r0
  if(uartHandle->Instance==USART2)
 802c9de:	d112      	bne.n	802ca06 <HAL_UART_MspDeInit+0x32>
  CLEAR_BIT(RCC->APB1ENR1, Periphs);
 802c9e0:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000

    /**USART2 GPIO Configuration
    PA3     ------> USART2_RX
    PA2     ------> USART2_TX
    */
    HAL_GPIO_DeInit(GPIOA, USARTx_RX_Pin|USARTx_TX_Pin);
 802c9e4:	210c      	movs	r1, #12
 802c9e6:	6d93      	ldr	r3, [r2, #88]	; 0x58
 802c9e8:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 802c9ec:	6593      	str	r3, [r2, #88]	; 0x58
 802c9ee:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 802c9f2:	f001 fde9 	bl	802e5c8 <HAL_GPIO_DeInit>

    /* USART2 DMA DeInit */
    HAL_DMA_DeInit(uartHandle->hdmatx);
 802c9f6:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 802c9f8:	f001 fa92 	bl	802df20 <HAL_DMA_DeInit>
    HAL_NVIC_DisableIRQ(USART2_IRQn);
  /* USER CODE BEGIN USART2_MspDeInit 1 */

  /* USER CODE END USART2_MspDeInit 1 */
  }
}
 802c9fc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    HAL_NVIC_DisableIRQ(USART2_IRQn);
 802ca00:	2025      	movs	r0, #37	; 0x25
 802ca02:	f001 b9c7 	b.w	802dd94 <HAL_NVIC_DisableIRQ>
}
 802ca06:	bd10      	pop	{r4, pc}
 802ca08:	40004400 	.word	0x40004400

0802ca0c <vcom_Trace_DMA>:

  /* USER CODE END vcom_Trace_2 */
}

UTIL_ADV_TRACE_Status_t vcom_Trace_DMA(uint8_t *p_data, uint16_t size)
{
 802ca0c:	b508      	push	{r3, lr}
 802ca0e:	460a      	mov	r2, r1
  /* USER CODE BEGIN vcom_Trace_DMA_1 */

  /* USER CODE END vcom_Trace_DMA_1 */
  HAL_UART_Transmit_DMA(&huart2, p_data, size);
 802ca10:	4601      	mov	r1, r0
 802ca12:	4802      	ldr	r0, [pc, #8]	; (802ca1c <vcom_Trace_DMA+0x10>)
 802ca14:	f003 f9be 	bl	802fd94 <HAL_UART_Transmit_DMA>
  return UTIL_ADV_TRACE_OK;
  /* USER CODE BEGIN vcom_Trace_DMA_2 */

  /* USER CODE END vcom_Trace_DMA_2 */
}
 802ca18:	2000      	movs	r0, #0
 802ca1a:	bd08      	pop	{r3, pc}
 802ca1c:	2000625c 	.word	0x2000625c

0802ca20 <vcom_ReceiveInit>:

UTIL_ADV_TRACE_Status_t vcom_ReceiveInit(void (*RxCb)(uint8_t *rxChar, uint16_t size, uint8_t error))
{
 802ca20:	b513      	push	{r0, r1, r4, lr}

  /* USER CODE END vcom_ReceiveInit_1 */
  UART_WakeUpTypeDef WakeUpSelection;

  /*record call back*/
  RxCpltCallback = RxCb;
 802ca22:	4b11      	ldr	r3, [pc, #68]	; (802ca68 <vcom_ReceiveInit+0x48>)

  /*Set wakeUp event on start bit*/
  WakeUpSelection.WakeUpEvent = UART_WAKEUP_ON_STARTBIT;

  HAL_UARTEx_StopModeWakeUpSourceConfig(&huart2, WakeUpSelection);
 802ca24:	4c11      	ldr	r4, [pc, #68]	; (802ca6c <vcom_ReceiveInit+0x4c>)
  RxCpltCallback = RxCb;
 802ca26:	6018      	str	r0, [r3, #0]
  WakeUpSelection.WakeUpEvent = UART_WAKEUP_ON_STARTBIT;
 802ca28:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 802ca2c:	9300      	str	r3, [sp, #0]
  HAL_UARTEx_StopModeWakeUpSourceConfig(&huart2, WakeUpSelection);
 802ca2e:	ab02      	add	r3, sp, #8
 802ca30:	e913 0006 	ldmdb	r3, {r1, r2}
 802ca34:	4620      	mov	r0, r4
 802ca36:	f004 f8c8 	bl	8030bca <HAL_UARTEx_StopModeWakeUpSourceConfig>

  /* Make sure that no UART transfer is on-going */
  while (__HAL_UART_GET_FLAG(&huart2, USART_ISR_BUSY) == SET);
 802ca3a:	6823      	ldr	r3, [r4, #0]
 802ca3c:	69da      	ldr	r2, [r3, #28]
 802ca3e:	03d1      	lsls	r1, r2, #15
 802ca40:	d4fc      	bmi.n	802ca3c <vcom_ReceiveInit+0x1c>

  /* Make sure that UART is ready to receive)   */
  while (__HAL_UART_GET_FLAG(&huart2, USART_ISR_REACK) == RESET);
 802ca42:	69da      	ldr	r2, [r3, #28]
 802ca44:	0252      	lsls	r2, r2, #9
 802ca46:	d5fc      	bpl.n	802ca42 <vcom_ReceiveInit+0x22>

  /* Enable USART interrupt */
  __HAL_UART_ENABLE_IT(&huart2, UART_IT_WUF);
 802ca48:	689a      	ldr	r2, [r3, #8]

  /*Enable wakeup from stop mode*/
  HAL_UARTEx_EnableStopMode(&huart2);
 802ca4a:	4808      	ldr	r0, [pc, #32]	; (802ca6c <vcom_ReceiveInit+0x4c>)
  __HAL_UART_ENABLE_IT(&huart2, UART_IT_WUF);
 802ca4c:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 802ca50:	609a      	str	r2, [r3, #8]
  HAL_UARTEx_EnableStopMode(&huart2);
 802ca52:	f004 f901 	bl	8030c58 <HAL_UARTEx_EnableStopMode>

  /*Start LPUART receive on IT*/
  HAL_UART_Receive_IT(&huart2, &charRx, 1);
 802ca56:	4906      	ldr	r1, [pc, #24]	; (802ca70 <vcom_ReceiveInit+0x50>)
 802ca58:	4804      	ldr	r0, [pc, #16]	; (802ca6c <vcom_ReceiveInit+0x4c>)
 802ca5a:	2201      	movs	r2, #1
 802ca5c:	f004 f866 	bl	8030b2c <HAL_UART_Receive_IT>

  return UTIL_ADV_TRACE_OK;
  /* USER CODE BEGIN vcom_ReceiveInit_2 */

  /* USER CODE END vcom_ReceiveInit_2 */
}
 802ca60:	2000      	movs	r0, #0
 802ca62:	b002      	add	sp, #8
 802ca64:	bd10      	pop	{r4, pc}
 802ca66:	bf00      	nop
 802ca68:	200035d0 	.word	0x200035d0
 802ca6c:	2000625c 	.word	0x2000625c
 802ca70:	200062ec 	.word	0x200062ec

0802ca74 <vcom_Init>:
{
 802ca74:	b508      	push	{r3, lr}
  TxCpltCallback = cb;
 802ca76:	4b07      	ldr	r3, [pc, #28]	; (802ca94 <vcom_Init+0x20>)
 802ca78:	6058      	str	r0, [r3, #4]
  MX_DMA_Init();
 802ca7a:	f7ff fabf 	bl	802bffc <MX_DMA_Init>
  MX_USART2_UART_Init();
 802ca7e:	f7ff ff09 	bl	802c894 <MX_USART2_UART_Init>
  SET_BIT(EXTI->IMR1, ExtiLine);
 802ca82:	4a05      	ldr	r2, [pc, #20]	; (802ca98 <vcom_Init+0x24>)
 802ca84:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
 802ca88:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 802ca8c:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
}
 802ca90:	2000      	movs	r0, #0
 802ca92:	bd08      	pop	{r3, pc}
 802ca94:	200035d0 	.word	0x200035d0
 802ca98:	58000800 	.word	0x58000800

0802ca9c <vcom_DeInit>:
{
 802ca9c:	b508      	push	{r3, lr}
  SET_BIT(RCC->APB1RSTR1, Periphs);
 802ca9e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
  HAL_UART_MspDeInit(&huart2);
 802caa2:	4808      	ldr	r0, [pc, #32]	; (802cac4 <vcom_DeInit+0x28>)
 802caa4:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 802caa6:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 802caaa:	639a      	str	r2, [r3, #56]	; 0x38
  CLEAR_BIT(RCC->APB1RSTR1, Periphs);
 802caac:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 802caae:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 802cab2:	639a      	str	r2, [r3, #56]	; 0x38
 802cab4:	f7ff ff8e 	bl	802c9d4 <HAL_UART_MspDeInit>
  HAL_NVIC_DisableIRQ(DMA1_Channel5_IRQn);
 802cab8:	200f      	movs	r0, #15
 802caba:	f001 f96b 	bl	802dd94 <HAL_NVIC_DisableIRQ>
}
 802cabe:	2000      	movs	r0, #0
 802cac0:	bd08      	pop	{r3, pc}
 802cac2:	bf00      	nop
 802cac4:	2000625c 	.word	0x2000625c

0802cac8 <vcom_Resume>:

void vcom_Resume(void)
{
 802cac8:	b508      	push	{r3, lr}
  /* USER CODE BEGIN vcom_Resume_1 */

  /* USER CODE END vcom_Resume_1 */
  /*to re-enable lost UART settings*/
  if (HAL_UART_Init(&huart2) != HAL_OK)
 802caca:	4807      	ldr	r0, [pc, #28]	; (802cae8 <vcom_Resume+0x20>)
 802cacc:	f003 ff76 	bl	80309bc <HAL_UART_Init>
 802cad0:	b108      	cbz	r0, 802cad6 <vcom_Resume+0xe>
  {
    Error_Handler();
 802cad2:	f7ff fbef 	bl	802c2b4 <Error_Handler>
  }

  /*to re-enable lost DMA settings*/
  if (HAL_DMA_Init(&hdma_usart2_tx) != HAL_OK)
 802cad6:	4805      	ldr	r0, [pc, #20]	; (802caec <vcom_Resume+0x24>)
 802cad8:	f001 f9b0 	bl	802de3c <HAL_DMA_Init>
 802cadc:	b118      	cbz	r0, 802cae6 <vcom_Resume+0x1e>
    Error_Handler();
  }
  /* USER CODE BEGIN vcom_Resume_2 */

  /* USER CODE END vcom_Resume_2 */
}
 802cade:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 802cae2:	f7ff bbe7 	b.w	802c2b4 <Error_Handler>
}
 802cae6:	bd08      	pop	{r3, pc}
 802cae8:	2000625c 	.word	0x2000625c
 802caec:	200061fc 	.word	0x200061fc

0802caf0 <HAL_UART_TxCpltCallback>:
{
  /* USER CODE BEGIN HAL_UART_TxCpltCallback_1 */

  /* USER CODE END HAL_UART_TxCpltCallback_1 */
  /* buffer transmission complete*/
  TxCpltCallback(NULL);
 802caf0:	4b01      	ldr	r3, [pc, #4]	; (802caf8 <HAL_UART_TxCpltCallback+0x8>)
 802caf2:	2000      	movs	r0, #0
 802caf4:	685b      	ldr	r3, [r3, #4]
 802caf6:	4718      	bx	r3
 802caf8:	200035d0 	.word	0x200035d0

0802cafc <HAL_UART_RxCpltCallback>:
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart2)
{
  /* USER CODE BEGIN HAL_UART_RxCpltCallback_1 */

  /* USER CODE END HAL_UART_RxCpltCallback_1 */
  if ((NULL != RxCpltCallback) && (HAL_UART_ERROR_NONE == huart2->ErrorCode))
 802cafc:	4b08      	ldr	r3, [pc, #32]	; (802cb20 <HAL_UART_RxCpltCallback+0x24>)
 802cafe:	681b      	ldr	r3, [r3, #0]
{
 802cb00:	b510      	push	{r4, lr}
 802cb02:	4604      	mov	r4, r0
  if ((NULL != RxCpltCallback) && (HAL_UART_ERROR_NONE == huart2->ErrorCode))
 802cb04:	b12b      	cbz	r3, 802cb12 <HAL_UART_RxCpltCallback+0x16>
 802cb06:	f8d0 208c 	ldr.w	r2, [r0, #140]	; 0x8c
 802cb0a:	b912      	cbnz	r2, 802cb12 <HAL_UART_RxCpltCallback+0x16>
  {
    RxCpltCallback(&charRx, 1, 0);
 802cb0c:	4805      	ldr	r0, [pc, #20]	; (802cb24 <HAL_UART_RxCpltCallback+0x28>)
 802cb0e:	2101      	movs	r1, #1
 802cb10:	4798      	blx	r3
  }
  HAL_UART_Receive_IT(huart2, &charRx, 1);
 802cb12:	4620      	mov	r0, r4
 802cb14:	4903      	ldr	r1, [pc, #12]	; (802cb24 <HAL_UART_RxCpltCallback+0x28>)
  /* USER CODE BEGIN HAL_UART_RxCpltCallback_2 */

  /* USER CODE END HAL_UART_RxCpltCallback_2 */
}
 802cb16:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  HAL_UART_Receive_IT(huart2, &charRx, 1);
 802cb1a:	2201      	movs	r2, #1
 802cb1c:	f004 b806 	b.w	8030b2c <HAL_UART_Receive_IT>
 802cb20:	200035d0 	.word	0x200035d0
 802cb24:	200062ec 	.word	0x200062ec

0802cb28 <MX_KMS_Init>:
{
/***************************************/
   /**
  */

  C_Initialize(NULL);
 802cb28:	2000      	movs	r0, #0
 802cb2a:	f7dc b861 	b.w	8008bf0 <SE_KMS_Initialize>

0802cb2e <MX_LoRaWAN_Init>:
/* USER CODE END PFP */

/* Exported functions --------------------------------------------------------*/

void MX_LoRaWAN_Init(void)
{
 802cb2e:	b508      	push	{r3, lr}
  /* USER CODE BEGIN MX_LoRaWAN_Init_1 */

  /* USER CODE END MX_LoRaWAN_Init_1 */
  SystemApp_Init();
 802cb30:	f7ff fcda 	bl	802c4e8 <SystemApp_Init>
  /* USER CODE END MX_LoRaWAN_Init_2 */
  LoRaWAN_Init();
  /* USER CODE BEGIN MX_LoRaWAN_Init_3 */

  /* USER CODE END MX_LoRaWAN_Init_3 */
}
 802cb34:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  LoRaWAN_Init();
 802cb38:	f000 b996 	b.w	802ce68 <LoRaWAN_Init>

0802cb3c <MX_LoRaWAN_Process>:
void MX_LoRaWAN_Process(void)
{
  /* USER CODE BEGIN MX_LoRaWAN_Process_1 */

  /* USER CODE END MX_LoRaWAN_Process_1 */
  UTIL_SEQ_Run(UTIL_SEQ_DEFAULT);
 802cb3c:	f04f 30ff 	mov.w	r0, #4294967295
 802cb40:	f00e ba00 	b.w	803af44 <UTIL_SEQ_Run>

0802cb44 <FwUpdateAgent_Run>:
/* USER CODE END PFP */

/* Exported functions --------------------------------------------------------*/
#if (INTEROP_TEST_MODE == 0)
void FwUpdateAgent_Run(void)
{
 802cb44:	b530      	push	{r4, r5, lr}
  /* USER CODE BEGIN FwUpdateAgent_Run_1 */

  /* USER CODE END FwUpdateAgent_Run_1 */
  int32_t status = FLASH_OK;
  uint8_t fw_header_dwl_slot[SE_FW_HEADER_TOT_LEN];
  uint32_t first_page = PAGE(FRAG_DECODER_SWAP_REGION_START);
 802cb46:	4b23      	ldr	r3, [pc, #140]	; (802cbd4 <FwUpdateAgent_Run+0x90>)
  uint32_t nb_pages = PAGE(FRAG_DECODER_SWAP_REGION_START + SFU_IMG_IMAGE_OFFSET - 1) - first_page + 1U;

  /* Read header in slot 1 */
  UTIL_MEM_cpy_8(fw_header_dwl_slot, (void *)FRAG_DECODER_DWL_REGION_START, SE_FW_HEADER_TOT_LEN);
 802cb48:	4923      	ldr	r1, [pc, #140]	; (802cbd8 <FwUpdateAgent_Run+0x94>)
  uint32_t first_page = PAGE(FRAG_DECODER_SWAP_REGION_START);
 802cb4a:	681c      	ldr	r4, [r3, #0]
{
 802cb4c:	b0d1      	sub	sp, #324	; 0x144
  UTIL_MEM_cpy_8(fw_header_dwl_slot, (void *)FRAG_DECODER_DWL_REGION_START, SE_FW_HEADER_TOT_LEN);
 802cb4e:	f44f 72a0 	mov.w	r2, #320	; 0x140
 802cb52:	4668      	mov	r0, sp
 802cb54:	f00e f9ae 	bl	803aeb4 <UTIL_MEM_cpy_8>

  /* Ask for installation at next reset */
  if (HAL_FLASH_Unlock() == HAL_OK)
 802cb58:	f001 fb78 	bl	802e24c <HAL_FLASH_Unlock>
 802cb5c:	4602      	mov	r2, r0
 802cb5e:	bb80      	cbnz	r0, 802cbc2 <FwUpdateAgent_Run+0x7e>
  uint32_t first_page = PAGE(FRAG_DECODER_SWAP_REGION_START);
 802cb60:	4d1e      	ldr	r5, [pc, #120]	; (802cbdc <FwUpdateAgent_Run+0x98>)
 802cb62:	4b1f      	ldr	r3, [pc, #124]	; (802cbe0 <FwUpdateAgent_Run+0x9c>)
  uint32_t nb_pages = PAGE(FRAG_DECODER_SWAP_REGION_START + SFU_IMG_IMAGE_OFFSET - 1) - first_page + 1U;
 802cb64:	f205 10ff 	addw	r0, r5, #511	; 0x1ff
  uint32_t first_page = PAGE(FRAG_DECODER_SWAP_REGION_START);
 802cb68:	ea03 2384 	and.w	r3, r3, r4, lsl #10
  uint32_t nb_pages = PAGE(FRAG_DECODER_SWAP_REGION_START + SFU_IMG_IMAGE_OFFSET - 1) - first_page + 1U;
 802cb6c:	fbb0 f1f3 	udiv	r1, r0, r3
 802cb70:	fb03 0111 	mls	r1, r3, r1, r0
 802cb74:	0ac9      	lsrs	r1, r1, #11
  uint32_t first_page = PAGE(FRAG_DECODER_SWAP_REGION_START);
 802cb76:	fbb5 f4f3 	udiv	r4, r5, r3
  uint32_t nb_pages = PAGE(FRAG_DECODER_SWAP_REGION_START + SFU_IMG_IMAGE_OFFSET - 1) - first_page + 1U;
 802cb7a:	3101      	adds	r1, #1
  uint32_t first_page = PAGE(FRAG_DECODER_SWAP_REGION_START);
 802cb7c:	fb03 5414 	mls	r4, r3, r4, r5
  uint32_t nb_pages = PAGE(FRAG_DECODER_SWAP_REGION_START + SFU_IMG_IMAGE_OFFSET - 1) - first_page + 1U;
 802cb80:	eba1 21d4 	sub.w	r1, r1, r4, lsr #11
  {
    status = FLASH_IF_EraseByPages(first_page, nb_pages, 0U);
 802cb84:	0ae0      	lsrs	r0, r4, #11
 802cb86:	b289      	uxth	r1, r1
 802cb88:	f7ff fa95 	bl	802c0b6 <FLASH_IF_EraseByPages>

    if (status == FLASH_OK)
 802cb8c:	4604      	mov	r4, r0
 802cb8e:	b940      	cbnz	r0, 802cba2 <FwUpdateAgent_Run+0x5e>
    {
      status = FLASH_IF_Write(FRAG_DECODER_SWAP_REGION_START, fw_header_dwl_slot, SE_FW_HEADER_TOT_LEN, NULL);
 802cb90:	4603      	mov	r3, r0
 802cb92:	f44f 72a0 	mov.w	r2, #320	; 0x140
 802cb96:	4669      	mov	r1, sp
 802cb98:	f105 6000 	add.w	r0, r5, #134217728	; 0x8000000
 802cb9c:	f7ff faa2 	bl	802c0e4 <FLASH_IF_Write>
 802cba0:	4604      	mov	r4, r0
    }
    HAL_FLASH_Lock();
 802cba2:	f001 fb65 	bl	802e270 <HAL_FLASH_Lock>
  else
  {
    status = FLASH_LOCK_ERROR;
  }

  if (status == FLASH_OK)
 802cba6:	b964      	cbnz	r4, 802cbc2 <FwUpdateAgent_Run+0x7e>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 802cba8:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 802cbac:	490d      	ldr	r1, [pc, #52]	; (802cbe4 <FwUpdateAgent_Run+0xa0>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 802cbae:	4b0e      	ldr	r3, [pc, #56]	; (802cbe8 <FwUpdateAgent_Run+0xa4>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 802cbb0:	68ca      	ldr	r2, [r1, #12]
 802cbb2:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 802cbb6:	4313      	orrs	r3, r2
 802cbb8:	60cb      	str	r3, [r1, #12]
 802cbba:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 802cbbe:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 802cbc0:	e7fd      	b.n	802cbbe <FwUpdateAgent_Run+0x7a>
    /* System Reboot*/
    NVIC_SystemReset();
  }
  else
  {
    APP_LOG(TS_OFF, VLEVEL_M, "FW Update Agent Run Failed\r\n");
 802cbc2:	2200      	movs	r2, #0
 802cbc4:	4b09      	ldr	r3, [pc, #36]	; (802cbec <FwUpdateAgent_Run+0xa8>)
 802cbc6:	4611      	mov	r1, r2
 802cbc8:	2002      	movs	r0, #2
 802cbca:	f00e f86b 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
  }
  /* USER CODE BEGIN FwUpdateAgent_Run_2 */

  /* USER CODE END FwUpdateAgent_Run_2 */
}
 802cbce:	b051      	add	sp, #324	; 0x144
 802cbd0:	bd30      	pop	{r4, r5, pc}
 802cbd2:	bf00      	nop
 802cbd4:	1fff75e0 	.word	0x1fff75e0
 802cbd8:	08016000 	.word	0x08016000
 802cbdc:	00015000 	.word	0x00015000
 802cbe0:	03fffc00 	.word	0x03fffc00
 802cbe4:	e000ed00 	.word	0xe000ed00
 802cbe8:	05fa0004 	.word	0x05fa0004
 802cbec:	0803bd4f 	.word	0x0803bd4f

0802cbf0 <OnMacProcessNotify>:
static void OnMacProcessNotify(void)
{
  /* USER CODE BEGIN OnMacProcessNotify_1 */

  /* USER CODE END OnMacProcessNotify_1 */
  UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_LmHandlerProcess), CFG_SEQ_Prio_0);
 802cbf0:	2100      	movs	r1, #0
 802cbf2:	2001      	movs	r0, #1
 802cbf4:	f00e b970 	b.w	803aed8 <UTIL_SEQ_SetTask>

0802cbf8 <OnClassChange>:
  if (deviceClass == CLASS_C)
 802cbf8:	2802      	cmp	r0, #2
    UTIL_TIMER_Stop(&TxTimer);
 802cbfa:	4803      	ldr	r0, [pc, #12]	; (802cc08 <OnClassChange+0x10>)
  if (deviceClass == CLASS_C)
 802cbfc:	d101      	bne.n	802cc02 <OnClassChange+0xa>
    UTIL_TIMER_Stop(&TxTimer);
 802cbfe:	f00e bb73 	b.w	803b2e8 <UTIL_TIMER_Stop>
    UTIL_TIMER_Start(&TxTimer);
 802cc02:	f00e bbc1 	b.w	803b388 <UTIL_TIMER_Start>
 802cc06:	bf00      	nop
 802cc08:	200035d8 	.word	0x200035d8

0802cc0c <OnRxData>:
{
 802cc0c:	b530      	push	{r4, r5, lr}
 802cc0e:	460d      	mov	r5, r1
 802cc10:	b087      	sub	sp, #28
  if ((appData != NULL) || (params != NULL))
 802cc12:	4604      	mov	r4, r0
 802cc14:	b908      	cbnz	r0, 802cc1a <OnRxData+0xe>
 802cc16:	2900      	cmp	r1, #0
 802cc18:	d057      	beq.n	802ccca <OnRxData+0xbe>
    BSP_LED_On(LED_BLUE) ;
 802cc1a:	2000      	movs	r0, #0
 802cc1c:	f000 faea 	bl	802d1f4 <BSP_LED_On>
    UTIL_TIMER_Start(&RxLedTimer);
 802cc20:	482b      	ldr	r0, [pc, #172]	; (802ccd0 <OnRxData+0xc4>)
 802cc22:	f00e fbb1 	bl	803b388 <UTIL_TIMER_Start>
    APP_LOG(TS_OFF, VLEVEL_M, "\r\n###### ========== MCPS-Indication ==========\r\n");
 802cc26:	2200      	movs	r2, #0
 802cc28:	4611      	mov	r1, r2
 802cc2a:	4b2a      	ldr	r3, [pc, #168]	; (802ccd4 <OnRxData+0xc8>)
 802cc2c:	2002      	movs	r0, #2
 802cc2e:	f00e f839 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
    APP_LOG(TS_OFF, VLEVEL_H, "###### D/L FRAME:%04d | SLOT:%s | PORT:%d | DR:%d | RSSI:%d | SNR:%d\r\n",
 802cc32:	f995 3004 	ldrsb.w	r3, [r5, #4]
 802cc36:	9305      	str	r3, [sp, #20]
 802cc38:	f995 3003 	ldrsb.w	r3, [r5, #3]
 802cc3c:	9304      	str	r3, [sp, #16]
 802cc3e:	f995 3002 	ldrsb.w	r3, [r5, #2]
 802cc42:	9303      	str	r3, [sp, #12]
 802cc44:	7823      	ldrb	r3, [r4, #0]
 802cc46:	9302      	str	r3, [sp, #8]
 802cc48:	f995 200c 	ldrsb.w	r2, [r5, #12]
 802cc4c:	4b22      	ldr	r3, [pc, #136]	; (802ccd8 <OnRxData+0xcc>)
 802cc4e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 802cc52:	9301      	str	r3, [sp, #4]
 802cc54:	68ab      	ldr	r3, [r5, #8]
 802cc56:	9300      	str	r3, [sp, #0]
 802cc58:	2200      	movs	r2, #0
 802cc5a:	4b20      	ldr	r3, [pc, #128]	; (802ccdc <OnRxData+0xd0>)
 802cc5c:	4611      	mov	r1, r2
 802cc5e:	2003      	movs	r0, #3
 802cc60:	f00e f820 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
    switch (appData->Port)
 802cc64:	7825      	ldrb	r5, [r4, #0]
 802cc66:	2d02      	cmp	r5, #2
 802cc68:	d010      	beq.n	802cc8c <OnRxData+0x80>
 802cc6a:	2d03      	cmp	r5, #3
 802cc6c:	d12d      	bne.n	802ccca <OnRxData+0xbe>
        if (appData->BufferSize == 1)
 802cc6e:	7863      	ldrb	r3, [r4, #1]
 802cc70:	2b01      	cmp	r3, #1
 802cc72:	d12a      	bne.n	802ccca <OnRxData+0xbe>
          switch (appData->Buffer[0])
 802cc74:	6863      	ldr	r3, [r4, #4]
 802cc76:	7818      	ldrb	r0, [r3, #0]
 802cc78:	2801      	cmp	r0, #1
 802cc7a:	d002      	beq.n	802cc82 <OnRxData+0x76>
 802cc7c:	2802      	cmp	r0, #2
 802cc7e:	d000      	beq.n	802cc82 <OnRxData+0x76>
 802cc80:	bb18      	cbnz	r0, 802ccca <OnRxData+0xbe>
}
 802cc82:	b007      	add	sp, #28
 802cc84:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
              LmHandlerRequestClass(CLASS_C);
 802cc88:	f004 bc80 	b.w	803158c <LmHandlerRequestClass>
        if (appData->BufferSize == 1)
 802cc8c:	7863      	ldrb	r3, [r4, #1]
 802cc8e:	2b01      	cmp	r3, #1
 802cc90:	d11b      	bne.n	802ccca <OnRxData+0xbe>
          AppLedStateOn = appData->Buffer[0] & 0x01;
 802cc92:	6863      	ldr	r3, [r4, #4]
 802cc94:	781a      	ldrb	r2, [r3, #0]
          if (AppLedStateOn == RESET)
 802cc96:	f012 0201 	ands.w	r2, r2, #1
 802cc9a:	d10a      	bne.n	802ccb2 <OnRxData+0xa6>
            APP_LOG(TS_OFF, VLEVEL_H,   "LED OFF\r\n");
 802cc9c:	4b10      	ldr	r3, [pc, #64]	; (802cce0 <OnRxData+0xd4>)
 802cc9e:	4611      	mov	r1, r2
 802cca0:	2003      	movs	r0, #3
 802cca2:	f00d ffff 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
            BSP_LED_Off(LED_RED) ;
 802cca6:	4628      	mov	r0, r5
}
 802cca8:	b007      	add	sp, #28
 802ccaa:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
            BSP_LED_Off(LED_RED) ;
 802ccae:	f000 baaf 	b.w	802d210 <BSP_LED_Off>
            APP_LOG(TS_OFF, VLEVEL_H, "LED ON\r\n");
 802ccb2:	2200      	movs	r2, #0
 802ccb4:	4b0b      	ldr	r3, [pc, #44]	; (802cce4 <OnRxData+0xd8>)
 802ccb6:	4611      	mov	r1, r2
 802ccb8:	2003      	movs	r0, #3
 802ccba:	f00d fff3 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
            BSP_LED_On(LED_RED) ;
 802ccbe:	4628      	mov	r0, r5
}
 802ccc0:	b007      	add	sp, #28
 802ccc2:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
            BSP_LED_On(LED_RED) ;
 802ccc6:	f000 ba95 	b.w	802d1f4 <BSP_LED_On>
}
 802ccca:	b007      	add	sp, #28
 802cccc:	bd30      	pop	{r4, r5, pc}
 802ccce:	bf00      	nop
 802ccd0:	200035f0 	.word	0x200035f0
 802ccd4:	0803bd6c 	.word	0x0803bd6c
 802ccd8:	0803b8f0 	.word	0x0803b8f0
 802ccdc:	0803bd9d 	.word	0x0803bd9d
 802cce0:	0803bde4 	.word	0x0803bde4
 802cce4:	0803bdee 	.word	0x0803bdee

0802cce8 <OnRxTimerLedEvent>:
  BSP_LED_Off(LED_BLUE) ;
 802cce8:	2000      	movs	r0, #0
 802ccea:	f000 ba91 	b.w	802d210 <BSP_LED_Off>

0802ccee <OnTxTimerLedEvent>:
  BSP_LED_Off(LED_GREEN) ;
 802ccee:	2001      	movs	r0, #1
 802ccf0:	f000 ba8e 	b.w	802d210 <BSP_LED_Off>

0802ccf4 <OnJoinTimerLedEvent>:
  BSP_LED_Toggle(LED_RED) ;
 802ccf4:	2002      	movs	r0, #2
 802ccf6:	f000 ba99 	b.w	802d22c <BSP_LED_Toggle>
	...

0802ccfc <OnTxData>:
{
 802ccfc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  if ((params != NULL))
 802ccfe:	4604      	mov	r4, r0
 802cd00:	2800      	cmp	r0, #0
 802cd02:	d034      	beq.n	802cd6e <OnTxData+0x72>
    if (params->IsMcpsConfirm != 0)
 802cd04:	7803      	ldrb	r3, [r0, #0]
 802cd06:	2b00      	cmp	r3, #0
 802cd08:	d031      	beq.n	802cd6e <OnTxData+0x72>
      BSP_LED_On(LED_GREEN) ;
 802cd0a:	2001      	movs	r0, #1
 802cd0c:	f000 fa72 	bl	802d1f4 <BSP_LED_On>
      UTIL_TIMER_Start(&TxLedTimer);
 802cd10:	481c      	ldr	r0, [pc, #112]	; (802cd84 <OnTxData+0x88>)
 802cd12:	f00e fb39 	bl	803b388 <UTIL_TIMER_Start>
      APP_LOG(TS_OFF, VLEVEL_M, "\r\n###### ========== MCPS-Confirm =============\r\n");
 802cd16:	2200      	movs	r2, #0
 802cd18:	4611      	mov	r1, r2
 802cd1a:	4b1b      	ldr	r3, [pc, #108]	; (802cd88 <OnTxData+0x8c>)
 802cd1c:	2002      	movs	r0, #2
 802cd1e:	f00d ffc1 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
      APP_LOG(TS_OFF, VLEVEL_H, "###### U/L FRAME:%04d | PORT:%d | DR:%d | PWR:%d", params->UplinkCounter,
 802cd22:	f994 3014 	ldrsb.w	r3, [r4, #20]
 802cd26:	9303      	str	r3, [sp, #12]
 802cd28:	f994 3004 	ldrsb.w	r3, [r4, #4]
 802cd2c:	9302      	str	r3, [sp, #8]
 802cd2e:	7b23      	ldrb	r3, [r4, #12]
 802cd30:	9301      	str	r3, [sp, #4]
 802cd32:	68a3      	ldr	r3, [r4, #8]
 802cd34:	9300      	str	r3, [sp, #0]
 802cd36:	2200      	movs	r2, #0
 802cd38:	4611      	mov	r1, r2
 802cd3a:	4b14      	ldr	r3, [pc, #80]	; (802cd8c <OnTxData+0x90>)
 802cd3c:	2003      	movs	r0, #3
 802cd3e:	f00d ffb1 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
      APP_LOG(TS_OFF, VLEVEL_H, " | MSG TYPE:");
 802cd42:	2200      	movs	r2, #0
 802cd44:	4b12      	ldr	r3, [pc, #72]	; (802cd90 <OnTxData+0x94>)
 802cd46:	4611      	mov	r1, r2
 802cd48:	2003      	movs	r0, #3
 802cd4a:	f00d ffab 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
      if (params->MsgType == LORAMAC_HANDLER_CONFIRMED_MSG)
 802cd4e:	78a3      	ldrb	r3, [r4, #2]
 802cd50:	2b01      	cmp	r3, #1
 802cd52:	d10e      	bne.n	802cd72 <OnTxData+0x76>
        APP_LOG(TS_OFF, VLEVEL_H, "CONFIRMED [%s]\r\n", (params->AckReceived != 0) ? "ACK" : "NACK");
 802cd54:	78e1      	ldrb	r1, [r4, #3]
 802cd56:	4a0f      	ldr	r2, [pc, #60]	; (802cd94 <OnTxData+0x98>)
 802cd58:	4b0f      	ldr	r3, [pc, #60]	; (802cd98 <OnTxData+0x9c>)
 802cd5a:	2900      	cmp	r1, #0
 802cd5c:	bf08      	it	eq
 802cd5e:	4613      	moveq	r3, r2
 802cd60:	2200      	movs	r2, #0
 802cd62:	9300      	str	r3, [sp, #0]
 802cd64:	4611      	mov	r1, r2
 802cd66:	4b0d      	ldr	r3, [pc, #52]	; (802cd9c <OnTxData+0xa0>)
 802cd68:	2003      	movs	r0, #3
 802cd6a:	f00d ff9b 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
}
 802cd6e:	b004      	add	sp, #16
 802cd70:	bd10      	pop	{r4, pc}
        APP_LOG(TS_OFF, VLEVEL_H, "UNCONFIRMED\r\n");
 802cd72:	2200      	movs	r2, #0
 802cd74:	4b0a      	ldr	r3, [pc, #40]	; (802cda0 <OnTxData+0xa4>)
 802cd76:	4611      	mov	r1, r2
 802cd78:	2003      	movs	r0, #3
}
 802cd7a:	b004      	add	sp, #16
 802cd7c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        APP_LOG(TS_OFF, VLEVEL_H, "UNCONFIRMED\r\n");
 802cd80:	f00d bf90 	b.w	803aca4 <UTIL_ADV_TRACE_COND_FSend>
 802cd84:	20003608 	.word	0x20003608
 802cd88:	0803bdfc 	.word	0x0803bdfc
 802cd8c:	0803be2d 	.word	0x0803be2d
 802cd90:	0803be5e 	.word	0x0803be5e
 802cd94:	0803bdf7 	.word	0x0803bdf7
 802cd98:	0803bdf8 	.word	0x0803bdf8
 802cd9c:	0803be6b 	.word	0x0803be6b
 802cda0:	0803be7c 	.word	0x0803be7c

0802cda4 <OnJoinRequest>:
{
 802cda4:	b570      	push	{r4, r5, r6, lr}
  if (joinParams != NULL)
 802cda6:	4605      	mov	r5, r0
 802cda8:	b320      	cbz	r0, 802cdf4 <OnJoinRequest+0x50>
    if (joinParams->Status == LORAMAC_HANDLER_SUCCESS)
 802cdaa:	f990 4001 	ldrsb.w	r4, [r0, #1]
 802cdae:	b9cc      	cbnz	r4, 802cde4 <OnJoinRequest+0x40>
      UTIL_TIMER_Stop(&JoinLedTimer);
 802cdb0:	4811      	ldr	r0, [pc, #68]	; (802cdf8 <OnJoinRequest+0x54>)
 802cdb2:	f00e fa99 	bl	803b2e8 <UTIL_TIMER_Stop>
      BSP_LED_Off(LED_RED) ;
 802cdb6:	2002      	movs	r0, #2
 802cdb8:	f000 fa2a 	bl	802d210 <BSP_LED_Off>
      APP_LOG(TS_OFF, VLEVEL_M, "\r\n###### = JOINED = ");
 802cdbc:	4622      	mov	r2, r4
 802cdbe:	4621      	mov	r1, r4
 802cdc0:	4b0e      	ldr	r3, [pc, #56]	; (802cdfc <OnJoinRequest+0x58>)
 802cdc2:	2002      	movs	r0, #2
 802cdc4:	f00d ff6e 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
      if (joinParams->Mode == ACTIVATION_TYPE_ABP)
 802cdc8:	78ab      	ldrb	r3, [r5, #2]
 802cdca:	2b01      	cmp	r3, #1
        APP_LOG(TS_OFF, VLEVEL_M, "OTAA =====================\r\n");
 802cdcc:	4622      	mov	r2, r4
 802cdce:	4621      	mov	r1, r4
        APP_LOG(TS_OFF, VLEVEL_M, "ABP ======================\r\n");
 802cdd0:	bf0c      	ite	eq
 802cdd2:	4b0b      	ldreq	r3, [pc, #44]	; (802ce00 <OnJoinRequest+0x5c>)
        APP_LOG(TS_OFF, VLEVEL_M, "OTAA =====================\r\n");
 802cdd4:	4b0b      	ldrne	r3, [pc, #44]	; (802ce04 <OnJoinRequest+0x60>)
 802cdd6:	2002      	movs	r0, #2
 802cdd8:	f00d ff64 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
}
 802cddc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      LmHandlerDeviceTimeReq();
 802cde0:	f004 ba96 	b.w	8031310 <LmHandlerDeviceTimeReq>
      APP_LOG(TS_OFF, VLEVEL_M, "\r\n###### = JOIN FAILED\r\n");
 802cde4:	2200      	movs	r2, #0
}
 802cde6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      APP_LOG(TS_OFF, VLEVEL_M, "\r\n###### = JOIN FAILED\r\n");
 802cdea:	4b07      	ldr	r3, [pc, #28]	; (802ce08 <OnJoinRequest+0x64>)
 802cdec:	4611      	mov	r1, r2
 802cdee:	2002      	movs	r0, #2
 802cdf0:	f00d bf58 	b.w	803aca4 <UTIL_ADV_TRACE_COND_FSend>
}
 802cdf4:	bd70      	pop	{r4, r5, r6, pc}
 802cdf6:	bf00      	nop
 802cdf8:	20003620 	.word	0x20003620
 802cdfc:	0803be8a 	.word	0x0803be8a
 802ce00:	0803be9f 	.word	0x0803be9f
 802ce04:	0803bebc 	.word	0x0803bebc
 802ce08:	0803bed9 	.word	0x0803bed9

0802ce0c <SendTxData>:
{
 802ce0c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  AppData.Port = LORAWAN_USER_APP_PORT;
 802ce0e:	4813      	ldr	r0, [pc, #76]	; (802ce5c <SendTxData+0x50>)
  AppData.Buffer[j++] = 0;
 802ce10:	6842      	ldr	r2, [r0, #4]
  UTIL_TIMER_Time_t nextTxIn = 0;
 802ce12:	2400      	movs	r4, #0
  AppData.Port = LORAWAN_USER_APP_PORT;
 802ce14:	2302      	movs	r3, #2
  UTIL_TIMER_Time_t nextTxIn = 0;
 802ce16:	9403      	str	r4, [sp, #12]
  AppData.Port = LORAWAN_USER_APP_PORT;
 802ce18:	7003      	strb	r3, [r0, #0]
  AppData.Buffer[j++] = 0;
 802ce1a:	7014      	strb	r4, [r2, #0]
  AppData.Buffer[j++] = 2;
 802ce1c:	6842      	ldr	r2, [r0, #4]
  if (LORAMAC_HANDLER_SUCCESS == LmHandlerSend(&AppData, LORAWAN_DEFAULT_CONFIRMED_MSG_STATE, &nextTxIn, false))
 802ce1e:	4621      	mov	r1, r4
  AppData.Buffer[j++] = 2;
 802ce20:	7053      	strb	r3, [r2, #1]
  AppData.BufferSize = j;
 802ce22:	7043      	strb	r3, [r0, #1]
  if (LORAMAC_HANDLER_SUCCESS == LmHandlerSend(&AppData, LORAWAN_DEFAULT_CONFIRMED_MSG_STATE, &nextTxIn, false))
 802ce24:	aa03      	add	r2, sp, #12
 802ce26:	4623      	mov	r3, r4
 802ce28:	f004 fc70 	bl	803170c <LmHandlerSend>
 802ce2c:	4601      	mov	r1, r0
 802ce2e:	b930      	cbnz	r0, 802ce3e <SendTxData+0x32>
    APP_LOG(TS_ON, VLEVEL_L, "SEND REQUEST\r\n");
 802ce30:	2201      	movs	r2, #1
 802ce32:	4b0b      	ldr	r3, [pc, #44]	; (802ce60 <SendTxData+0x54>)
 802ce34:	4610      	mov	r0, r2
 802ce36:	f00d ff35 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
}
 802ce3a:	b004      	add	sp, #16
 802ce3c:	bd10      	pop	{r4, pc}
  else if (nextTxIn > 0)
 802ce3e:	9b03      	ldr	r3, [sp, #12]
 802ce40:	2b00      	cmp	r3, #0
 802ce42:	d0fa      	beq.n	802ce3a <SendTxData+0x2e>
    APP_LOG(TS_ON, VLEVEL_L, "Next Tx in  : ~%d second(s)\r\n", (nextTxIn / 1000));
 802ce44:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 802ce48:	fbb3 f3f2 	udiv	r3, r3, r2
 802ce4c:	2201      	movs	r2, #1
 802ce4e:	9300      	str	r3, [sp, #0]
 802ce50:	4621      	mov	r1, r4
 802ce52:	4b04      	ldr	r3, [pc, #16]	; (802ce64 <SendTxData+0x58>)
 802ce54:	4610      	mov	r0, r2
 802ce56:	f00d ff25 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
}
 802ce5a:	e7ee      	b.n	802ce3a <SendTxData+0x2e>
 802ce5c:	20003400 	.word	0x20003400
 802ce60:	0803bef2 	.word	0x0803bef2
 802ce64:	0803bf01 	.word	0x0803bf01

0802ce68 <LoRaWAN_Init>:
{
 802ce68:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  BSP_LED_Init(LED_BLUE);
 802ce6c:	2000      	movs	r0, #0
{
 802ce6e:	b085      	sub	sp, #20
  BSP_LED_Init(LED_BLUE);
 802ce70:	f000 f99a 	bl	802d1a8 <BSP_LED_Init>
  BSP_LED_Init(LED_GREEN);
 802ce74:	2001      	movs	r0, #1
 802ce76:	f000 f997 	bl	802d1a8 <BSP_LED_Init>
  BSP_LED_Init(LED_RED);
 802ce7a:	2002      	movs	r0, #2
 802ce7c:	f000 f994 	bl	802d1a8 <BSP_LED_Init>
  BSP_PB_Init(BUTTON_SW2, BUTTON_MODE_EXTI);
 802ce80:	2101      	movs	r1, #1
 802ce82:	4608      	mov	r0, r1
 802ce84:	f000 f9e0 	bl	802d248 <BSP_PB_Init>
  APP_LOG(TS_OFF, VLEVEL_M, "APP_VERSION:        V%X.%X.%X\r\n",
 802ce88:	2501      	movs	r5, #1
 802ce8a:	2200      	movs	r2, #0
 802ce8c:	4611      	mov	r1, r2
 802ce8e:	e9cd 5501 	strd	r5, r5, [sp, #4]
 802ce92:	4b35      	ldr	r3, [pc, #212]	; (802cf68 <LoRaWAN_Init+0x100>)
 802ce94:	9500      	str	r5, [sp, #0]
 802ce96:	2002      	movs	r0, #2
  APP_LOG(TS_OFF, VLEVEL_M, "MW_LORAWAN_VERSION: V%X.%X.%X\r\n",
 802ce98:	2400      	movs	r4, #0
  APP_LOG(TS_OFF, VLEVEL_M, "APP_VERSION:        V%X.%X.%X\r\n",
 802ce9a:	f00d ff03 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
  APP_LOG(TS_OFF, VLEVEL_M, "MW_LORAWAN_VERSION: V%X.%X.%X\r\n",
 802ce9e:	2702      	movs	r7, #2
  UTIL_TIMER_Create(&TxLedTimer, 0xFFFFFFFFU, UTIL_TIMER_ONESHOT, OnTxTimerLedEvent, NULL);
 802cea0:	4e32      	ldr	r6, [pc, #200]	; (802cf6c <LoRaWAN_Init+0x104>)
  APP_LOG(TS_OFF, VLEVEL_M, "MW_LORAWAN_VERSION: V%X.%X.%X\r\n",
 802cea2:	9700      	str	r7, [sp, #0]
 802cea4:	2303      	movs	r3, #3
 802cea6:	e9cd 3401 	strd	r3, r4, [sp, #4]
 802ceaa:	4622      	mov	r2, r4
 802ceac:	4621      	mov	r1, r4
 802ceae:	4b30      	ldr	r3, [pc, #192]	; (802cf70 <LoRaWAN_Init+0x108>)
 802ceb0:	4638      	mov	r0, r7
 802ceb2:	f00d fef7 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
  UTIL_TIMER_Create(&TxLedTimer, 0xFFFFFFFFU, UTIL_TIMER_ONESHOT, OnTxTimerLedEvent, NULL);
 802ceb6:	f106 0930 	add.w	r9, r6, #48	; 0x30
  APP_LOG(TS_OFF, VLEVEL_M, "MW_RADIO_VERSION:   V%X.%X.%X\r\n",
 802ceba:	4622      	mov	r2, r4
 802cebc:	4621      	mov	r1, r4
 802cebe:	e9cd 5401 	strd	r5, r4, [sp, #4]
 802cec2:	4b2c      	ldr	r3, [pc, #176]	; (802cf74 <LoRaWAN_Init+0x10c>)
 802cec4:	9500      	str	r5, [sp, #0]
 802cec6:	4638      	mov	r0, r7
 802cec8:	f00d feec 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
  UTIL_TIMER_Create(&RxLedTimer, 0xFFFFFFFFU, UTIL_TIMER_ONESHOT, OnRxTimerLedEvent, NULL);
 802cecc:	f106 0818 	add.w	r8, r6, #24
  UTIL_TIMER_Create(&TxLedTimer, 0xFFFFFFFFU, UTIL_TIMER_ONESHOT, OnTxTimerLedEvent, NULL);
 802ced0:	4622      	mov	r2, r4
 802ced2:	4b29      	ldr	r3, [pc, #164]	; (802cf78 <LoRaWAN_Init+0x110>)
 802ced4:	9400      	str	r4, [sp, #0]
 802ced6:	f04f 31ff 	mov.w	r1, #4294967295
 802ceda:	4648      	mov	r0, r9
 802cedc:	f00e f9a6 	bl	803b22c <UTIL_TIMER_Create>
  UTIL_TIMER_Create(&JoinLedTimer, 0xFFFFFFFFU, UTIL_TIMER_PERIODIC, OnJoinTimerLedEvent, NULL);
 802cee0:	3648      	adds	r6, #72	; 0x48
  UTIL_TIMER_Create(&RxLedTimer, 0xFFFFFFFFU, UTIL_TIMER_ONESHOT, OnRxTimerLedEvent, NULL);
 802cee2:	4622      	mov	r2, r4
 802cee4:	4b25      	ldr	r3, [pc, #148]	; (802cf7c <LoRaWAN_Init+0x114>)
 802cee6:	9400      	str	r4, [sp, #0]
 802cee8:	f04f 31ff 	mov.w	r1, #4294967295
 802ceec:	4640      	mov	r0, r8
 802ceee:	f00e f99d 	bl	803b22c <UTIL_TIMER_Create>
  UTIL_TIMER_Create(&JoinLedTimer, 0xFFFFFFFFU, UTIL_TIMER_PERIODIC, OnJoinTimerLedEvent, NULL);
 802cef2:	4b23      	ldr	r3, [pc, #140]	; (802cf80 <LoRaWAN_Init+0x118>)
 802cef4:	9400      	str	r4, [sp, #0]
 802cef6:	462a      	mov	r2, r5
 802cef8:	f04f 31ff 	mov.w	r1, #4294967295
 802cefc:	4630      	mov	r0, r6
 802cefe:	f00e f995 	bl	803b22c <UTIL_TIMER_Create>
  UTIL_TIMER_SetPeriod(&TxLedTimer, 500);
 802cf02:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 802cf06:	4648      	mov	r0, r9
 802cf08:	f00e fa78 	bl	803b3fc <UTIL_TIMER_SetPeriod>
  UTIL_TIMER_SetPeriod(&RxLedTimer, 500);
 802cf0c:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 802cf10:	4640      	mov	r0, r8
 802cf12:	f00e fa73 	bl	803b3fc <UTIL_TIMER_SetPeriod>
  UTIL_TIMER_SetPeriod(&JoinLedTimer, 500);
 802cf16:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 802cf1a:	4630      	mov	r0, r6
 802cf1c:	f00e fa6e 	bl	803b3fc <UTIL_TIMER_SetPeriod>
  LmHandlerInit(&LmHandlerCallbacks);
 802cf20:	f8df 8068 	ldr.w	r8, [pc, #104]	; 802cf8c <LoRaWAN_Init+0x124>
  UTIL_SEQ_RegTask((1 << CFG_SEQ_Task_LmHandlerProcess), UTIL_SEQ_RFU, LmHandlerProcess);
 802cf24:	4a17      	ldr	r2, [pc, #92]	; (802cf84 <LoRaWAN_Init+0x11c>)
 802cf26:	4621      	mov	r1, r4
 802cf28:	4628      	mov	r0, r5
 802cf2a:	f00e f87f 	bl	803b02c <UTIL_SEQ_RegTask>
  UTIL_SEQ_RegTask((1 << CFG_SEQ_Task_LoRaSendOnTxTimerOrButtonEvent), UTIL_SEQ_RFU, SendTxData);
 802cf2e:	4621      	mov	r1, r4
 802cf30:	4a15      	ldr	r2, [pc, #84]	; (802cf88 <LoRaWAN_Init+0x120>)
 802cf32:	4638      	mov	r0, r7
 802cf34:	f00e f87a 	bl	803b02c <UTIL_SEQ_RegTask>
  LoraInfo_Init();
 802cf38:	f000 f832 	bl	802cfa0 <LoraInfo_Init>
  LmHandlerInit(&LmHandlerCallbacks);
 802cf3c:	f108 0008 	add.w	r0, r8, #8
 802cf40:	f004 fd96 	bl	8031a70 <LmHandlerInit>
  LmHandlerConfigure(&LmHandlerParams);
 802cf44:	f108 003c 	add.w	r0, r8, #60	; 0x3c
 802cf48:	f004 fa16 	bl	8031378 <LmHandlerConfigure>
  UTIL_TIMER_Start(&JoinLedTimer);
 802cf4c:	4630      	mov	r0, r6
 802cf4e:	f00e fa1b 	bl	803b388 <UTIL_TIMER_Start>
  LmHandlerJoin(ActivationType);
 802cf52:	4638      	mov	r0, r7
 802cf54:	f004 fb78 	bl	8031648 <LmHandlerJoin>
    BSP_PB_Init(BUTTON_SW1, BUTTON_MODE_EXTI);
 802cf58:	4629      	mov	r1, r5
 802cf5a:	4620      	mov	r0, r4
}
 802cf5c:	b005      	add	sp, #20
 802cf5e:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    BSP_PB_Init(BUTTON_SW1, BUTTON_MODE_EXTI);
 802cf62:	f000 b971 	b.w	802d248 <BSP_PB_Init>
 802cf66:	bf00      	nop
 802cf68:	0803bf1f 	.word	0x0803bf1f
 802cf6c:	200035d8 	.word	0x200035d8
 802cf70:	0803bf3f 	.word	0x0803bf3f
 802cf74:	0803bf5f 	.word	0x0803bf5f
 802cf78:	0802ccef 	.word	0x0802ccef
 802cf7c:	0802cce9 	.word	0x0802cce9
 802cf80:	0802ccf5 	.word	0x0802ccf5
 802cf84:	08031529 	.word	0x08031529
 802cf88:	0802ce0d 	.word	0x0802ce0d
 802cf8c:	20003400 	.word	0x20003400

0802cf90 <HAL_GPIO_EXTI_Callback>:
  switch (GPIO_Pin)
 802cf90:	2801      	cmp	r0, #1
 802cf92:	d103      	bne.n	802cf9c <HAL_GPIO_EXTI_Callback+0xc>
      UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_LoRaSendOnTxTimerOrButtonEvent), CFG_SEQ_Prio_0);
 802cf94:	2100      	movs	r1, #0
 802cf96:	2002      	movs	r0, #2
 802cf98:	f00d bf9e 	b.w	803aed8 <UTIL_SEQ_SetTask>
}
 802cf9c:	4770      	bx	lr
	...

0802cfa0 <LoraInfo_Init>:
/* Exported functions --------------------------------------------------------*/
void LoraInfo_Init(void)
{
  loraInfo.ActivationMode = 0;
  loraInfo.Region = 0;
  loraInfo.ClassB = 0;
 802cfa0:	4b05      	ldr	r3, [pc, #20]	; (802cfb8 <LoraInfo_Init+0x18>)
#endif /* REGION_KR920 */
#ifdef  REGION_IN865
  loraInfo.Region |= (1 << LORAMAC_REGION_IN865) ;
#endif /* REGION_IN865 */
#ifdef  REGION_US915
  loraInfo.Region |= (1 << LORAMAC_REGION_US915) ;
 802cfa2:	f44f 7290 	mov.w	r2, #288	; 0x120
 802cfa6:	2100      	movs	r1, #0
 802cfa8:	e9c3 2101 	strd	r2, r1, [r3, #4]

#if (!defined (LORAWAN_KMS) || (LORAWAN_KMS == 0))
  loraInfo.Kms = 0;
  loraInfo.ActivationMode = 3;
#else /* LORAWAN_KMS == 1 */
  loraInfo.Kms = 1;
 802cfac:	2201      	movs	r2, #1
 802cfae:	60da      	str	r2, [r3, #12]
  loraInfo.ActivationMode = ACTIVATION_BY_PERSONALIZATION + (OVER_THE_AIR_ACTIVATION << 1);
 802cfb0:	2203      	movs	r2, #3
 802cfb2:	601a      	str	r2, [r3, #0]
#endif /* LORAWAN_KMS */
  /* USER CODE BEGIN LoraInfo_Init_2 */

  /* USER CODE END LoraInfo_Init_2 */
}
 802cfb4:	4770      	bx	lr
 802cfb6:	bf00      	nop
 802cfb8:	2000372c 	.word	0x2000372c

0802cfbc <LoraInfo_GetPtr>:
{
  /* USER CODE BEGIN LoraInfo_GetPtr */

  /* USER CODE END LoraInfo_GetPtr */
  return &loraInfo;
}
 802cfbc:	4800      	ldr	r0, [pc, #0]	; (802cfc0 <LoraInfo_GetPtr+0x4>)
 802cfbe:	4770      	bx	lr
 802cfc0:	2000372c 	.word	0x2000372c

0802cfc4 <FRAG_DECODER_IF_Erase>:

/* USER CODE END PFP */

/* Exported functions --------------------------------------------------------*/
int32_t FRAG_DECODER_IF_Erase(void)
{
 802cfc4:	b538      	push	{r3, r4, r5, lr}
  /* USER CODE END FRAG_DECODER_IF_Erase_1 */
  int32_t status = FLASH_OK;
#if (INTEROP_TEST_MODE == 1)
  UTIL_MEM_set_8(UnfragmentedData, 0xFF, UNFRAGMENTED_DATA_SIZE);
#else /* INTEROP_TEST_MODE == 0 */
  uint32_t first_page = PAGE(FRAG_DECODER_DWL_REGION_START);
 802cfc6:	4b16      	ldr	r3, [pc, #88]	; (802d020 <FRAG_DECODER_IF_Erase+0x5c>)
 802cfc8:	4c16      	ldr	r4, [pc, #88]	; (802d024 <FRAG_DECODER_IF_Erase+0x60>)
 802cfca:	681b      	ldr	r3, [r3, #0]
 802cfcc:	4a16      	ldr	r2, [pc, #88]	; (802d028 <FRAG_DECODER_IF_Erase+0x64>)
 802cfce:	ea04 2383 	and.w	r3, r4, r3, lsl #10
 802cfd2:	6894      	ldr	r4, [r2, #8]
  uint32_t nb_pages = PAGE(FRAG_DECODER_DWL_REGION_START + FRAG_DECODER_DWL_REGION_SIZE - 1) - first_page + 1U;
 802cfd4:	4a15      	ldr	r2, [pc, #84]	; (802d02c <FRAG_DECODER_IF_Erase+0x68>)
  uint32_t first_page = PAGE(FRAG_DECODER_DWL_REGION_START);
 802cfd6:	f104 4478 	add.w	r4, r4, #4160749568	; 0xf8000000
 802cfda:	fbb4 f1f3 	udiv	r1, r4, r3
 802cfde:	fb03 4111 	mls	r1, r3, r1, r4
  uint32_t nb_pages = PAGE(FRAG_DECODER_DWL_REGION_START + FRAG_DECODER_DWL_REGION_SIZE - 1) - first_page + 1U;
 802cfe2:	6894      	ldr	r4, [r2, #8]
 802cfe4:	f104 4278 	add.w	r2, r4, #4160749568	; 0xf8000000
 802cfe8:	fbb2 f4f3 	udiv	r4, r2, r3
 802cfec:	fb03 2414 	mls	r4, r3, r4, r2
 802cff0:	0ae4      	lsrs	r4, r4, #11
 802cff2:	3401      	adds	r4, #1
  uint32_t first_page = PAGE(FRAG_DECODER_DWL_REGION_START);
 802cff4:	0acd      	lsrs	r5, r1, #11
  uint32_t nb_pages = PAGE(FRAG_DECODER_DWL_REGION_START + FRAG_DECODER_DWL_REGION_SIZE - 1) - first_page + 1U;
 802cff6:	eba4 24d1 	sub.w	r4, r4, r1, lsr #11

  if (HAL_FLASH_Unlock() == HAL_OK)
 802cffa:	f001 f927 	bl	802e24c <HAL_FLASH_Unlock>
 802cffe:	4602      	mov	r2, r0
 802d000:	b958      	cbnz	r0, 802d01a <FRAG_DECODER_IF_Erase+0x56>
  {
    status = FLASH_IF_EraseByPages(first_page, nb_pages, 0U);
 802d002:	b2a1      	uxth	r1, r4
 802d004:	4628      	mov	r0, r5
 802d006:	f7ff f856 	bl	802c0b6 <FLASH_IF_EraseByPages>
 802d00a:	4604      	mov	r4, r0
    /* Lock the Flash to disable the flash control register access (recommended
    to protect the FLASH memory against possible unwanted operation) *********/
    HAL_FLASH_Lock();
 802d00c:	f001 f930 	bl	802e270 <HAL_FLASH_Lock>
  {
    status = FLASH_LOCK_ERROR;
  }

#endif /* INTEROP_TEST_MODE */
  if (status != FLASH_OK)
 802d010:	1e20      	subs	r0, r4, #0
 802d012:	bf18      	it	ne
 802d014:	2001      	movne	r0, #1
 802d016:	4240      	negs	r0, r0
  }
  return status;
  /* USER CODE BEGIN FRAG_DECODER_IF_Erase_2 */

  /* USER CODE END FRAG_DECODER_IF_Erase_2 */
}
 802d018:	bd38      	pop	{r3, r4, r5, pc}
    status = FLASH_ERROR;
 802d01a:	f04f 30ff 	mov.w	r0, #4294967295
  return status;
 802d01e:	e7fb      	b.n	802d018 <FRAG_DECODER_IF_Erase+0x54>
 802d020:	1fff75e0 	.word	0x1fff75e0
 802d024:	03fffc00 	.word	0x03fffc00
 802d028:	0803b8d0 	.word	0x0803b8d0
 802d02c:	0803b8c0 	.word	0x0803b8c0

0802d030 <FRAG_DECODER_IF_Write>:

int32_t FRAG_DECODER_IF_Write(uint32_t addr, uint8_t *data, uint32_t size)
{
 802d030:	b573      	push	{r0, r1, r4, r5, r6, lr}
 802d032:	4604      	mov	r4, r0
 802d034:	460d      	mov	r5, r1
 802d036:	4616      	mov	r6, r2

#if (INTEROP_TEST_MODE == 1)  /*write fragment in RAM - Caching mode*/
  UTIL_MEM_cpy_8(&UnfragmentedData[addr], data, size);
#else /* INTEROP_TEST_MODE == 0 */

  if (HAL_FLASH_Unlock() == HAL_OK)
 802d038:	f001 f908 	bl	802e24c <HAL_FLASH_Unlock>
 802d03c:	b9b8      	cbnz	r0, 802d06e <FRAG_DECODER_IF_Write+0x3e>
  {
    status = FLASH_IF_Write(FRAG_DECODER_DWL_REGION_START + addr, data, size, FRAG_DECODER_IF_RAM_buffer);
 802d03e:	480d      	ldr	r0, [pc, #52]	; (802d074 <FRAG_DECODER_IF_Write+0x44>)
 802d040:	4b0d      	ldr	r3, [pc, #52]	; (802d078 <FRAG_DECODER_IF_Write+0x48>)
 802d042:	6880      	ldr	r0, [r0, #8]
 802d044:	4632      	mov	r2, r6
 802d046:	4420      	add	r0, r4
 802d048:	4629      	mov	r1, r5
 802d04a:	f7ff f84b 	bl	802c0e4 <FLASH_IF_Write>
 802d04e:	4604      	mov	r4, r0
    HAL_FLASH_Lock();
 802d050:	f001 f90e 	bl	802e270 <HAL_FLASH_Lock>
  else
  {
    status = FLASH_LOCK_ERROR;
  }

  if (status != FLASH_OK)
 802d054:	b144      	cbz	r4, 802d068 <FRAG_DECODER_IF_Write+0x38>
  {
    APP_LOG(TS_OFF, VLEVEL_M, "\r\n....... !! FLASH_IF_WRITE_ERROR: %d !! .......\r\n", status);
 802d056:	2200      	movs	r2, #0
 802d058:	9400      	str	r4, [sp, #0]
 802d05a:	4b08      	ldr	r3, [pc, #32]	; (802d07c <FRAG_DECODER_IF_Write+0x4c>)
 802d05c:	4611      	mov	r1, r2
 802d05e:	2002      	movs	r0, #2
 802d060:	f00d fe20 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
  }
#endif /* INTEROP_TEST_MODE */
  if (status != FLASH_OK)
  {
    status = FLASH_ERROR;
 802d064:	f04f 34ff 	mov.w	r4, #4294967295
  }
  return status;
  /* USER CODE BEGIN FRAG_DECODER_IF_Write_2 */

  /* USER CODE END FRAG_DECODER_IF_Write_2 */
}
 802d068:	4620      	mov	r0, r4
 802d06a:	b002      	add	sp, #8
 802d06c:	bd70      	pop	{r4, r5, r6, pc}
    status = FLASH_LOCK_ERROR;
 802d06e:	f06f 0403 	mvn.w	r4, #3
 802d072:	e7f0      	b.n	802d056 <FRAG_DECODER_IF_Write+0x26>
 802d074:	0803b8d0 	.word	0x0803b8d0
 802d078:	2000373c 	.word	0x2000373c
 802d07c:	0803bfb1 	.word	0x0803bfb1

0802d080 <FRAG_DECODER_IF_OnProgress>:

  /* USER CODE END FRAG_DECODER_IF_Read_2 */
}

void FRAG_DECODER_IF_OnProgress(uint16_t fragCounter, uint16_t fragNb, uint8_t fragSize, uint16_t fragNbLost)
{
 802d080:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 802d082:	4614      	mov	r4, r2
  /* USER CODE BEGIN FRAG_DECODER_IF_OnProgress_1 */

  /* USER CODE END FRAG_DECODER_IF_OnProgress_1 */
  APP_LOG(TS_OFF, VLEVEL_M, "\r\n....... FRAG_DECODER in Progress .......\r\n");
 802d084:	2200      	movs	r2, #0
{
 802d086:	4606      	mov	r6, r0
 802d088:	460d      	mov	r5, r1
 802d08a:	461f      	mov	r7, r3
  APP_LOG(TS_OFF, VLEVEL_M, "\r\n....... FRAG_DECODER in Progress .......\r\n");
 802d08c:	4611      	mov	r1, r2
 802d08e:	4b0f      	ldr	r3, [pc, #60]	; (802d0cc <FRAG_DECODER_IF_OnProgress+0x4c>)
 802d090:	2002      	movs	r0, #2
 802d092:	f00d fe07 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
  APP_LOG(TS_OFF, VLEVEL_M, "RECEIVED    : %5d / %5d Fragments\r\n", fragCounter, fragNb);
 802d096:	2200      	movs	r2, #0
 802d098:	e9cd 6500 	strd	r6, r5, [sp]
 802d09c:	4611      	mov	r1, r2
 802d09e:	4b0c      	ldr	r3, [pc, #48]	; (802d0d0 <FRAG_DECODER_IF_OnProgress+0x50>)
 802d0a0:	2002      	movs	r0, #2
 802d0a2:	f00d fdff 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
  APP_LOG(TS_OFF, VLEVEL_M, "              %5d / %5d Bytes\r\n", fragCounter * fragSize, fragNb * fragSize);
 802d0a6:	4365      	muls	r5, r4
 802d0a8:	2200      	movs	r2, #0
 802d0aa:	4374      	muls	r4, r6
 802d0ac:	4611      	mov	r1, r2
 802d0ae:	4b09      	ldr	r3, [pc, #36]	; (802d0d4 <FRAG_DECODER_IF_OnProgress+0x54>)
 802d0b0:	9501      	str	r5, [sp, #4]
 802d0b2:	9400      	str	r4, [sp, #0]
 802d0b4:	2002      	movs	r0, #2
 802d0b6:	f00d fdf5 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
  APP_LOG(TS_OFF, VLEVEL_M, "LOST        :       %7d Fragments\r\n\r\n", fragNbLost);
 802d0ba:	2200      	movs	r2, #0
 802d0bc:	4b06      	ldr	r3, [pc, #24]	; (802d0d8 <FRAG_DECODER_IF_OnProgress+0x58>)
 802d0be:	9700      	str	r7, [sp, #0]
 802d0c0:	4611      	mov	r1, r2
 802d0c2:	2002      	movs	r0, #2
 802d0c4:	f00d fdee 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
  BSP_LED_Toggle(LED_BLUE);
#endif /* INTEROP_TEST_MODE == 1 */
  /* USER CODE BEGIN FRAG_DECODER_IF_OnProgress_2 */

  /* USER CODE END FRAG_DECODER_IF_OnProgress_2 */
}
 802d0c8:	b003      	add	sp, #12
 802d0ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802d0cc:	0803bfe4 	.word	0x0803bfe4
 802d0d0:	0803c011 	.word	0x0803c011
 802d0d4:	0803c035 	.word	0x0803c035
 802d0d8:	0803c055 	.word	0x0803c055

0802d0dc <FRAG_DECODER_IF_Read>:
{
 802d0dc:	b508      	push	{r3, lr}
 802d0de:	460b      	mov	r3, r1
  UTIL_MEM_cpy_8(data, (void *)(FRAG_DECODER_DWL_REGION_START + addr), size);
 802d0e0:	4904      	ldr	r1, [pc, #16]	; (802d0f4 <FRAG_DECODER_IF_Read+0x18>)
 802d0e2:	6889      	ldr	r1, [r1, #8]
 802d0e4:	b292      	uxth	r2, r2
 802d0e6:	4401      	add	r1, r0
 802d0e8:	4618      	mov	r0, r3
 802d0ea:	f00d fee3 	bl	803aeb4 <UTIL_MEM_cpy_8>
}
 802d0ee:	2000      	movs	r0, #0
 802d0f0:	bd08      	pop	{r3, pc}
 802d0f2:	bf00      	nop
 802d0f4:	0803b8d0 	.word	0x0803b8d0

0802d0f8 <FRAG_DECODER_IF_OnDone>:

void FRAG_DECODER_IF_OnDone(int32_t status, uint32_t size)
{
 802d0f8:	b513      	push	{r0, r1, r4, lr}
  /* USER CODE BEGIN FRAG_DECODER_IF_OnDone_1 */

  /* USER CODE END FRAG_DECODER_IF_OnDone_1 */
  APP_LOG(TS_OFF, VLEVEL_M, "\r\n....... FRAG_DECODER Finished .......\r\n");
 802d0fa:	2200      	movs	r2, #0
{
 802d0fc:	4604      	mov	r4, r0
  APP_LOG(TS_OFF, VLEVEL_M, "\r\n....... FRAG_DECODER Finished .......\r\n");
 802d0fe:	4611      	mov	r1, r2
 802d100:	4b07      	ldr	r3, [pc, #28]	; (802d120 <FRAG_DECODER_IF_OnDone+0x28>)
 802d102:	2002      	movs	r0, #2
 802d104:	f00d fdce 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
  APP_LOG(TS_OFF, VLEVEL_M, "STATUS      : %d\r\n", status);
 802d108:	2200      	movs	r2, #0
 802d10a:	4b06      	ldr	r3, [pc, #24]	; (802d124 <FRAG_DECODER_IF_OnDone+0x2c>)
 802d10c:	9400      	str	r4, [sp, #0]
 802d10e:	4611      	mov	r1, r2
 802d110:	2002      	movs	r0, #2
 802d112:	f00d fdc7 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
  BSP_LED_Off(LED_BLUE);
#endif /* INTEROP_TEST_MODE == 1 */
  /* USER CODE BEGIN FRAG_DECODER_IF_OnDone_2 */

  /* USER CODE END FRAG_DECODER_IF_OnDone_2 */
}
 802d116:	b002      	add	sp, #8
 802d118:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  FwUpdateAgent_Run();
 802d11c:	f7ff bd12 	b.w	802cb44 <FwUpdateAgent_Run>
 802d120:	0803c07b 	.word	0x0803c07b
 802d124:	0803c0a5 	.word	0x0803c0a5

0802d128 <RBI_Init>:
   *       or at https://github.com/STMicroelectronics/STM32CubeWL/tree/main/Drivers/BSP/STM32WLxx_Nucleo/
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration */
  return BSP_RADIO_Init();
 802d128:	f000 b8e6 	b.w	802d2f8 <BSP_RADIO_Init>

0802d12c <RBI_ConfigRFSwitch>:
   *       or at https://github.com/STMicroelectronics/STM32CubeWL/tree/main/Drivers/BSP/STM32WLxx_Nucleo/
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration */
  return BSP_RADIO_ConfigRFSwitch((BSP_RADIO_Switch_TypeDef) Config);
 802d12c:	f000 b924 	b.w	802d378 <BSP_RADIO_ConfigRFSwitch>

0802d130 <RBI_GetTxConfig>:
   *       or at https://github.com/STMicroelectronics/STM32CubeWL/tree/main/Drivers/BSP/STM32WLxx_Nucleo/
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration */
  return BSP_RADIO_GetTxConfig();
 802d130:	f000 b956 	b.w	802d3e0 <BSP_RADIO_GetTxConfig>

0802d134 <RBI_IsTCXO>:
   *       or at https://github.com/STMicroelectronics/STM32CubeWL/tree/main/Drivers/BSP/STM32WLxx_Nucleo/
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration */
  return BSP_RADIO_IsTCXO();
 802d134:	f000 b956 	b.w	802d3e4 <BSP_RADIO_IsTCXO>

0802d138 <RBI_IsDCDC>:
   *       or at https://github.com/STMicroelectronics/STM32CubeWL/tree/main/Drivers/BSP/STM32WLxx_Nucleo/
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration */
  return BSP_RADIO_IsDCDC();
 802d138:	f000 b956 	b.w	802d3e8 <BSP_RADIO_IsDCDC>

0802d13c <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 802d13c:	480d      	ldr	r0, [pc, #52]	; (802d174 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 802d13e:	4685      	mov	sp, r0

/* Call the clock system initialization function.*/
  bl  SystemInit
 802d140:	f000 f954 	bl	802d3ec <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 802d144:	480c      	ldr	r0, [pc, #48]	; (802d178 <LoopForever+0x6>)
  ldr r1, =_edata
 802d146:	490d      	ldr	r1, [pc, #52]	; (802d17c <LoopForever+0xa>)
  ldr r2, =_sidata
 802d148:	4a0d      	ldr	r2, [pc, #52]	; (802d180 <LoopForever+0xe>)
  movs r3, #0
 802d14a:	2300      	movs	r3, #0
  b LoopCopyDataInit
 802d14c:	e002      	b.n	802d154 <LoopCopyDataInit>

0802d14e <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 802d14e:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 802d150:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 802d152:	3304      	adds	r3, #4

0802d154 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 802d154:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 802d156:	428c      	cmp	r4, r1
  bcc CopyDataInit
 802d158:	d3f9      	bcc.n	802d14e <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 802d15a:	4a0a      	ldr	r2, [pc, #40]	; (802d184 <LoopForever+0x12>)
  ldr r4, =_ebss
 802d15c:	4c0a      	ldr	r4, [pc, #40]	; (802d188 <LoopForever+0x16>)
  movs r3, #0
 802d15e:	2300      	movs	r3, #0
  b LoopFillZerobss
 802d160:	e001      	b.n	802d166 <LoopFillZerobss>

0802d162 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 802d162:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 802d164:	3204      	adds	r2, #4

0802d166 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 802d166:	42a2      	cmp	r2, r4
  bcc FillZerobss
 802d168:	d3fb      	bcc.n	802d162 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 802d16a:	f00e fabd 	bl	803b6e8 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 802d16e:	f7ff f895 	bl	802c29c <main>

0802d172 <LoopForever>:

LoopForever:
    b LoopForever
 802d172:	e7fe      	b.n	802d172 <LoopForever>
  ldr   r0, =_estack
 802d174:	20008000 	.word	0x20008000
  ldr r0, =_sdata
 802d178:	20003400 	.word	0x20003400
  ldr r1, =_edata
 802d17c:	200035ac 	.word	0x200035ac
  ldr r2, =_sidata
 802d180:	0803c558 	.word	0x0803c558
  ldr r2, =_sbss
 802d184:	200035ac 	.word	0x200035ac
  ldr r4, =_ebss
 802d188:	200063ac 	.word	0x200063ac

0802d18c <ADC_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 802d18c:	e7fe      	b.n	802d18c <ADC_IRQHandler>

0802d18e <LL_AHB2_GRP1_EnableClock>:
  SET_BIT(RCC->AHB2ENR, Periphs);
 802d18e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
{
 802d192:	b082      	sub	sp, #8
  SET_BIT(RCC->AHB2ENR, Periphs);
 802d194:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 802d196:	4302      	orrs	r2, r0
 802d198:	64da      	str	r2, [r3, #76]	; 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 802d19a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 802d19c:	4018      	ands	r0, r3
 802d19e:	9001      	str	r0, [sp, #4]
  (void)tmpreg;
 802d1a0:	9b01      	ldr	r3, [sp, #4]
}
 802d1a2:	b002      	add	sp, #8
 802d1a4:	4770      	bx	lr
	...

0802d1a8 <BSP_LED_Init>:
  *            @arg LED2
  *            @arg LED3
  * @retval BSP status
  */
int32_t BSP_LED_Init(Led_TypeDef Led)
{
 802d1a8:	b570      	push	{r4, r5, r6, lr}
 802d1aa:	b086      	sub	sp, #24
 802d1ac:	4604      	mov	r4, r0
  GPIO_InitTypeDef  gpio_init_structure = {0};
 802d1ae:	2214      	movs	r2, #20
 802d1b0:	2100      	movs	r1, #0
 802d1b2:	a801      	add	r0, sp, #4
 802d1b4:	f00e fabc 	bl	803b730 <memset>
  
  /* Enable the GPIO_LED Clock */
  LEDx_GPIO_CLK_ENABLE(Led);
 802d1b8:	2002      	movs	r0, #2
 802d1ba:	f7ff ffe8 	bl	802d18e <LL_AHB2_GRP1_EnableClock>

  /* Configure the GPIO_LED pin */
  gpio_init_structure.Pin = LED_PIN[Led];
 802d1be:	4b0c      	ldr	r3, [pc, #48]	; (802d1f0 <BSP_LED_Init+0x48>)
 802d1c0:	f833 6014 	ldrh.w	r6, [r3, r4, lsl #1]
 802d1c4:	9601      	str	r6, [sp, #4]
  gpio_init_structure.Mode = GPIO_MODE_OUTPUT_PP;
  gpio_init_structure.Pull = GPIO_NOPULL;
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;
  
  HAL_GPIO_Init(LED_PORT[Led], &gpio_init_structure);
 802d1c6:	eb03 0384 	add.w	r3, r3, r4, lsl #2
  gpio_init_structure.Pull = GPIO_NOPULL;
 802d1ca:	2500      	movs	r5, #0
  HAL_GPIO_Init(LED_PORT[Led], &gpio_init_structure);
 802d1cc:	689c      	ldr	r4, [r3, #8]
  gpio_init_structure.Pull = GPIO_NOPULL;
 802d1ce:	2201      	movs	r2, #1
 802d1d0:	e9cd 2502 	strd	r2, r5, [sp, #8]
  HAL_GPIO_Init(LED_PORT[Led], &gpio_init_structure);
 802d1d4:	a901      	add	r1, sp, #4
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;
 802d1d6:	2202      	movs	r2, #2
  HAL_GPIO_Init(LED_PORT[Led], &gpio_init_structure);
 802d1d8:	4620      	mov	r0, r4
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;
 802d1da:	9204      	str	r2, [sp, #16]
  HAL_GPIO_Init(LED_PORT[Led], &gpio_init_structure);
 802d1dc:	f001 f948 	bl	802e470 <HAL_GPIO_Init>
  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_RESET);
 802d1e0:	4620      	mov	r0, r4
 802d1e2:	462a      	mov	r2, r5
 802d1e4:	4631      	mov	r1, r6
 802d1e6:	f001 fa63 	bl	802e6b0 <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
}
 802d1ea:	4628      	mov	r0, r5
 802d1ec:	b006      	add	sp, #24
 802d1ee:	bd70      	pop	{r4, r5, r6, pc}
 802d1f0:	0803b91c 	.word	0x0803b91c

0802d1f4 <BSP_LED_On>:
  *            @arg LED3
  * @retval BSP status
  */
int32_t BSP_LED_On(Led_TypeDef Led)
{
  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_SET); 
 802d1f4:	4b05      	ldr	r3, [pc, #20]	; (802d20c <BSP_LED_On+0x18>)
{
 802d1f6:	b510      	push	{r4, lr}
  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_SET); 
 802d1f8:	eb03 0480 	add.w	r4, r3, r0, lsl #2
 802d1fc:	f833 1010 	ldrh.w	r1, [r3, r0, lsl #1]
 802d200:	68a0      	ldr	r0, [r4, #8]
 802d202:	2201      	movs	r2, #1
 802d204:	f001 fa54 	bl	802e6b0 <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
}
 802d208:	2000      	movs	r0, #0
 802d20a:	bd10      	pop	{r4, pc}
 802d20c:	0803b91c 	.word	0x0803b91c

0802d210 <BSP_LED_Off>:
  *            @arg LED3
  * @retval BSP status
  */
int32_t BSP_LED_Off(Led_TypeDef Led)
{
  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_RESET); 
 802d210:	4b05      	ldr	r3, [pc, #20]	; (802d228 <BSP_LED_Off+0x18>)
{
 802d212:	b510      	push	{r4, lr}
  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_RESET); 
 802d214:	eb03 0480 	add.w	r4, r3, r0, lsl #2
 802d218:	f833 1010 	ldrh.w	r1, [r3, r0, lsl #1]
 802d21c:	68a0      	ldr	r0, [r4, #8]
 802d21e:	2200      	movs	r2, #0
 802d220:	f001 fa46 	bl	802e6b0 <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
}
 802d224:	2000      	movs	r0, #0
 802d226:	bd10      	pop	{r4, pc}
 802d228:	0803b91c 	.word	0x0803b91c

0802d22c <BSP_LED_Toggle>:
  *            @arg LED2
  *            @arg LED3
  * @retval BSP status
  */
int32_t BSP_LED_Toggle(Led_TypeDef Led)
{
 802d22c:	b508      	push	{r3, lr}
  HAL_GPIO_TogglePin(LED_PORT[Led], LED_PIN[Led]);
 802d22e:	4b05      	ldr	r3, [pc, #20]	; (802d244 <BSP_LED_Toggle+0x18>)
 802d230:	eb03 0280 	add.w	r2, r3, r0, lsl #2
 802d234:	f833 1010 	ldrh.w	r1, [r3, r0, lsl #1]
 802d238:	6890      	ldr	r0, [r2, #8]
 802d23a:	f001 fa3e 	bl	802e6ba <HAL_GPIO_TogglePin>

  return BSP_ERROR_NONE;
}
 802d23e:	2000      	movs	r0, #0
 802d240:	bd08      	pop	{r3, pc}
 802d242:	bf00      	nop
 802d244:	0803b91c 	.word	0x0803b91c

0802d248 <BSP_PB_Init>:
  *     @arg BUTTON_MODE_EXTI: Button will be connected to EXTI line with interrupt
  *                            generation capability  
  * @retval BSP status
  */
int32_t BSP_PB_Init(Button_TypeDef Button, ButtonMode_TypeDef ButtonMode)
{
 802d248:	b5f0      	push	{r4, r5, r6, r7, lr}
 802d24a:	b087      	sub	sp, #28
 802d24c:	4604      	mov	r4, r0
 802d24e:	460f      	mov	r7, r1
  GPIO_InitTypeDef gpio_init_structure = {0};
 802d250:	2214      	movs	r2, #20
 802d252:	2100      	movs	r1, #0
 802d254:	a801      	add	r0, sp, #4
 802d256:	f00e fa6b 	bl	803b730 <memset>
  static BSP_EXTI_LineCallback button_callback[BUTTONn] = {BUTTON_SW1_EXTI_Callback, BUTTON_SW2_EXTI_Callback, BUTTON_SW3_EXTI_Callback};
  static uint32_t button_interrupt_priority[BUTTONn] = {BSP_BUTTON_SWx_IT_PRIORITY, BSP_BUTTON_SWx_IT_PRIORITY, BSP_BUTTON_SWx_IT_PRIORITY};
  static const uint32_t button_exti_line[BUTTONn] = {BUTTON_SW1_EXTI_LINE, BUTTON_SW2_EXTI_LINE, BUTTON_SW3_EXTI_LINE};

  /* Enable the BUTTON Clock */
  BUTTONx_GPIO_CLK_ENABLE(Button);
 802d25a:	2c01      	cmp	r4, #1
 802d25c:	d816      	bhi.n	802d28c <BSP_PB_Init+0x44>
 802d25e:	2001      	movs	r0, #1
 802d260:	f7ff ff95 	bl	802d18e <LL_AHB2_GRP1_EnableClock>
  
  gpio_init_structure.Pin = BUTTON_PIN[Button];
 802d264:	4d1a      	ldr	r5, [pc, #104]	; (802d2d0 <BSP_PB_Init+0x88>)
 802d266:	eb05 0344 	add.w	r3, r5, r4, lsl #1
 802d26a:	eb05 0684 	add.w	r6, r5, r4, lsl #2
 802d26e:	8a9b      	ldrh	r3, [r3, #20]
 802d270:	9301      	str	r3, [sp, #4]
  gpio_init_structure.Pull = GPIO_PULLUP;
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;
 802d272:	2201      	movs	r2, #1
 802d274:	2302      	movs	r3, #2
 802d276:	e9cd 2303 	strd	r2, r3, [sp, #12]

  if(ButtonMode == BUTTON_MODE_GPIO)
 802d27a:	69f0      	ldr	r0, [r6, #28]
 802d27c:	b957      	cbnz	r7, 802d294 <BSP_PB_Init+0x4c>
  {
    /* Configure Button pin as input */
    gpio_init_structure.Mode = GPIO_MODE_INPUT;
    HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
 802d27e:	a901      	add	r1, sp, #4
    gpio_init_structure.Mode = GPIO_MODE_INPUT;
 802d280:	9702      	str	r7, [sp, #8]
    HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
 802d282:	f001 f8f5 	bl	802e470 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority((BUTTON_IRQn[Button]), button_interrupt_priority[Button], 0x00);
    HAL_NVIC_EnableIRQ((BUTTON_IRQn[Button]));
  }

  return BSP_ERROR_NONE;
}
 802d286:	2000      	movs	r0, #0
 802d288:	b007      	add	sp, #28
 802d28a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  BUTTONx_GPIO_CLK_ENABLE(Button);
 802d28c:	2c02      	cmp	r4, #2
 802d28e:	d1e9      	bne.n	802d264 <BSP_PB_Init+0x1c>
 802d290:	2004      	movs	r0, #4
 802d292:	e7e5      	b.n	802d260 <BSP_PB_Init+0x18>
    (void)HAL_EXTI_GetHandle(&hpb_exti[Button], button_exti_line[Button]);
 802d294:	4f0f      	ldr	r7, [pc, #60]	; (802d2d4 <BSP_PB_Init+0x8c>)
    gpio_init_structure.Mode = GPIO_MODE_IT_FALLING;
 802d296:	f44f 1304 	mov.w	r3, #2162688	; 0x210000
    (void)HAL_EXTI_GetHandle(&hpb_exti[Button], button_exti_line[Button]);
 802d29a:	eb07 07c4 	add.w	r7, r7, r4, lsl #3
    HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
 802d29e:	a901      	add	r1, sp, #4
    gpio_init_structure.Mode = GPIO_MODE_IT_FALLING;
 802d2a0:	9302      	str	r3, [sp, #8]
    HAL_NVIC_SetPriority((BUTTON_IRQn[Button]), button_interrupt_priority[Button], 0x00);
 802d2a2:	442c      	add	r4, r5
    HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
 802d2a4:	f001 f8e4 	bl	802e470 <HAL_GPIO_Init>
    (void)HAL_EXTI_GetHandle(&hpb_exti[Button], button_exti_line[Button]);
 802d2a8:	6ab1      	ldr	r1, [r6, #40]	; 0x28
 802d2aa:	4638      	mov	r0, r7
 802d2ac:	f000 ffaf 	bl	802e20e <HAL_EXTI_GetHandle>
    (void)HAL_EXTI_RegisterCallback(&hpb_exti[Button],  HAL_EXTI_COMMON_CB_ID, button_callback[Button]);
 802d2b0:	6b72      	ldr	r2, [r6, #52]	; 0x34
 802d2b2:	2100      	movs	r1, #0
 802d2b4:	4638      	mov	r0, r7
 802d2b6:	f000 ffa3 	bl	802e200 <HAL_EXTI_RegisterCallback>
    HAL_NVIC_SetPriority((BUTTON_IRQn[Button]), button_interrupt_priority[Button], 0x00);
 802d2ba:	f994 4040 	ldrsb.w	r4, [r4, #64]	; 0x40
 802d2be:	6c71      	ldr	r1, [r6, #68]	; 0x44
 802d2c0:	4620      	mov	r0, r4
 802d2c2:	2200      	movs	r2, #0
 802d2c4:	f000 fd26 	bl	802dd14 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ((BUTTON_IRQn[Button]));
 802d2c8:	4620      	mov	r0, r4
 802d2ca:	f000 fd55 	bl	802dd78 <HAL_NVIC_EnableIRQ>
 802d2ce:	e7da      	b.n	802d286 <BSP_PB_Init+0x3e>
 802d2d0:	0803b91c 	.word	0x0803b91c
 802d2d4:	200062f0 	.word	0x200062f0

0802d2d8 <BSP_PB_Callback>:
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Button);

  /* This function should be implemented by the user application.
     It is called into this driver when an event on Button is triggered. */
}
 802d2d8:	4770      	bx	lr

0802d2da <BUTTON_SW3_EXTI_Callback>:
/**
  * @brief  Button SW3 EXTI line detection callback.
  * @retval None
  */
static void BUTTON_SW3_EXTI_Callback(void)
{
 802d2da:	b508      	push	{r3, lr}
  BSP_PB_Callback(BUTTON_SW3);
 802d2dc:	2002      	movs	r0, #2
 802d2de:	f7ff fffb 	bl	802d2d8 <BSP_PB_Callback>
}
 802d2e2:	bd08      	pop	{r3, pc}

0802d2e4 <BUTTON_SW2_EXTI_Callback>:
{
 802d2e4:	b508      	push	{r3, lr}
  BSP_PB_Callback(BUTTON_SW2);
 802d2e6:	2001      	movs	r0, #1
 802d2e8:	f7ff fff6 	bl	802d2d8 <BSP_PB_Callback>
}
 802d2ec:	bd08      	pop	{r3, pc}

0802d2ee <BUTTON_SW1_EXTI_Callback>:
{
 802d2ee:	b508      	push	{r3, lr}
  BSP_PB_Callback(BUTTON_SW1);
 802d2f0:	2000      	movs	r0, #0
 802d2f2:	f7ff fff1 	bl	802d2d8 <BSP_PB_Callback>
}
 802d2f6:	bd08      	pop	{r3, pc}

0802d2f8 <BSP_RADIO_Init>:
/**
  * @brief  Init Radio Switch 
  * @retval BSP status
  */
int32_t BSP_RADIO_Init(void)
{
 802d2f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802d2fc:	b086      	sub	sp, #24
  GPIO_InitTypeDef  gpio_init_structure = {0};
 802d2fe:	2400      	movs	r4, #0
  SET_BIT(RCC->AHB2ENR, Periphs);
 802d300:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802d304:	9405      	str	r4, [sp, #20]
 802d306:	6cda      	ldr	r2, [r3, #76]	; 0x4c
  gpio_init_structure.Pin   = RF_SW_CTRL1_PIN;
  gpio_init_structure.Mode  = GPIO_MODE_OUTPUT_PP;
  gpio_init_structure.Pull  = GPIO_NOPULL;
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  
  HAL_GPIO_Init(RF_SW_CTRL1_GPIO_PORT, &gpio_init_structure);
 802d308:	4d1a      	ldr	r5, [pc, #104]	; (802d374 <BSP_RADIO_Init+0x7c>)
 802d30a:	f042 0204 	orr.w	r2, r2, #4
 802d30e:	64da      	str	r2, [r3, #76]	; 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 802d310:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  gpio_init_structure.Pull  = GPIO_NOPULL;
 802d312:	9403      	str	r4, [sp, #12]
 802d314:	f003 0304 	and.w	r3, r3, #4
 802d318:	9300      	str	r3, [sp, #0]
  (void)tmpreg;
 802d31a:	9b00      	ldr	r3, [sp, #0]
  gpio_init_structure.Mode  = GPIO_MODE_OUTPUT_PP;
 802d31c:	2710      	movs	r7, #16
 802d31e:	2301      	movs	r3, #1
 802d320:	e9cd 7301 	strd	r7, r3, [sp, #4]
  HAL_GPIO_Init(RF_SW_CTRL1_GPIO_PORT, &gpio_init_structure);
 802d324:	a901      	add	r1, sp, #4
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 802d326:	2303      	movs	r3, #3
  HAL_GPIO_Init(RF_SW_CTRL1_GPIO_PORT, &gpio_init_structure);
 802d328:	4628      	mov	r0, r5
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 802d32a:	9304      	str	r3, [sp, #16]
  
  gpio_init_structure.Pin = RF_SW_CTRL2_PIN;
 802d32c:	f04f 0820 	mov.w	r8, #32
  HAL_GPIO_Init(RF_SW_CTRL1_GPIO_PORT, &gpio_init_structure);
 802d330:	f001 f89e 	bl	802e470 <HAL_GPIO_Init>
  HAL_GPIO_Init(RF_SW_CTRL2_GPIO_PORT, &gpio_init_structure);
 802d334:	a901      	add	r1, sp, #4
 802d336:	4628      	mov	r0, r5
  
  gpio_init_structure.Pin = RF_SW_CTRL3_PIN;
 802d338:	2608      	movs	r6, #8
  gpio_init_structure.Pin = RF_SW_CTRL2_PIN;
 802d33a:	f8cd 8004 	str.w	r8, [sp, #4]
  HAL_GPIO_Init(RF_SW_CTRL2_GPIO_PORT, &gpio_init_structure);
 802d33e:	f001 f897 	bl	802e470 <HAL_GPIO_Init>
  HAL_GPIO_Init(RF_SW_CTRL3_GPIO_PORT, &gpio_init_structure);
 802d342:	a901      	add	r1, sp, #4
 802d344:	4628      	mov	r0, r5
  gpio_init_structure.Pin = RF_SW_CTRL3_PIN;
 802d346:	9601      	str	r6, [sp, #4]
  HAL_GPIO_Init(RF_SW_CTRL3_GPIO_PORT, &gpio_init_structure);
 802d348:	f001 f892 	bl	802e470 <HAL_GPIO_Init>

  HAL_GPIO_WritePin(RF_SW_CTRL2_GPIO_PORT, RF_SW_CTRL2_PIN, GPIO_PIN_RESET); 
 802d34c:	4622      	mov	r2, r4
 802d34e:	4641      	mov	r1, r8
 802d350:	4628      	mov	r0, r5
 802d352:	f001 f9ad 	bl	802e6b0 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_RESET); 
 802d356:	4622      	mov	r2, r4
 802d358:	4639      	mov	r1, r7
 802d35a:	4628      	mov	r0, r5
 802d35c:	f001 f9a8 	bl	802e6b0 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_RESET); 
 802d360:	4628      	mov	r0, r5
 802d362:	4622      	mov	r2, r4
 802d364:	4631      	mov	r1, r6
 802d366:	f001 f9a3 	bl	802e6b0 <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
}
 802d36a:	4620      	mov	r0, r4
 802d36c:	b006      	add	sp, #24
 802d36e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802d372:	bf00      	nop
 802d374:	48000800 	.word	0x48000800

0802d378 <BSP_RADIO_ConfigRFSwitch>:
  *           @arg RADIO_SWITCH_RFO_LP
  *           @arg RADIO_SWITCH_RFO_HP
  * @retval BSP status
  */
int32_t BSP_RADIO_ConfigRFSwitch(BSP_RADIO_Switch_TypeDef Config)
{
 802d378:	b508      	push	{r3, lr}
 802d37a:	2803      	cmp	r0, #3
 802d37c:	d812      	bhi.n	802d3a4 <BSP_RADIO_ConfigRFSwitch+0x2c>
 802d37e:	e8df f000 	tbb	[pc, r0]
 802d382:	1302      	.short	0x1302
 802d384:	261a      	.short	0x261a
  switch (Config)
  {
    case RADIO_SWITCH_OFF:
    {
      /* Turn off switch */
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_RESET);
 802d386:	2200      	movs	r2, #0
 802d388:	4814      	ldr	r0, [pc, #80]	; (802d3dc <BSP_RADIO_ConfigRFSwitch+0x64>)
 802d38a:	2108      	movs	r1, #8
 802d38c:	f001 f990 	bl	802e6b0 <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_RESET);
 802d390:	2200      	movs	r2, #0
    }
    case RADIO_SWITCH_RX:
    {
      /*Turns On in Rx Mode the RF Switch */
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_SET);
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_SET); 
 802d392:	4812      	ldr	r0, [pc, #72]	; (802d3dc <BSP_RADIO_ConfigRFSwitch+0x64>)
 802d394:	2110      	movs	r1, #16
 802d396:	f001 f98b 	bl	802e6b0 <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL2_GPIO_PORT, RF_SW_CTRL2_PIN, GPIO_PIN_RESET); 
 802d39a:	2200      	movs	r2, #0
    case RADIO_SWITCH_RFO_HP:
    {
      /*Turns On in Tx High Power the RF Switch */
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_SET);
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_RESET); 
      HAL_GPIO_WritePin(RF_SW_CTRL2_GPIO_PORT, RF_SW_CTRL2_PIN, GPIO_PIN_SET); 
 802d39c:	480f      	ldr	r0, [pc, #60]	; (802d3dc <BSP_RADIO_ConfigRFSwitch+0x64>)
 802d39e:	2120      	movs	r1, #32
 802d3a0:	f001 f986 	bl	802e6b0 <HAL_GPIO_WritePin>
    default:
      break;    
  }  

  return BSP_ERROR_NONE;
}
 802d3a4:	2000      	movs	r0, #0
 802d3a6:	bd08      	pop	{r3, pc}
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_SET);
 802d3a8:	2201      	movs	r2, #1
 802d3aa:	480c      	ldr	r0, [pc, #48]	; (802d3dc <BSP_RADIO_ConfigRFSwitch+0x64>)
 802d3ac:	2108      	movs	r1, #8
 802d3ae:	f001 f97f 	bl	802e6b0 <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_SET); 
 802d3b2:	2201      	movs	r2, #1
 802d3b4:	e7ed      	b.n	802d392 <BSP_RADIO_ConfigRFSwitch+0x1a>
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_SET);
 802d3b6:	2201      	movs	r2, #1
 802d3b8:	4808      	ldr	r0, [pc, #32]	; (802d3dc <BSP_RADIO_ConfigRFSwitch+0x64>)
 802d3ba:	2108      	movs	r1, #8
 802d3bc:	f001 f978 	bl	802e6b0 <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_SET); 
 802d3c0:	2201      	movs	r2, #1
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_RESET); 
 802d3c2:	4806      	ldr	r0, [pc, #24]	; (802d3dc <BSP_RADIO_ConfigRFSwitch+0x64>)
 802d3c4:	2110      	movs	r1, #16
 802d3c6:	f001 f973 	bl	802e6b0 <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL2_GPIO_PORT, RF_SW_CTRL2_PIN, GPIO_PIN_SET); 
 802d3ca:	2201      	movs	r2, #1
 802d3cc:	e7e6      	b.n	802d39c <BSP_RADIO_ConfigRFSwitch+0x24>
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_SET);
 802d3ce:	2201      	movs	r2, #1
 802d3d0:	4802      	ldr	r0, [pc, #8]	; (802d3dc <BSP_RADIO_ConfigRFSwitch+0x64>)
 802d3d2:	2108      	movs	r1, #8
 802d3d4:	f001 f96c 	bl	802e6b0 <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_RESET); 
 802d3d8:	2200      	movs	r2, #0
 802d3da:	e7f2      	b.n	802d3c2 <BSP_RADIO_ConfigRFSwitch+0x4a>
 802d3dc:	48000800 	.word	0x48000800

0802d3e0 <BSP_RADIO_GetTxConfig>:
  *  RADIO_CONF_RFO_HP
  */
int32_t BSP_RADIO_GetTxConfig(void)
{
  return RADIO_CONF_RFO_LP_HP;
}
 802d3e0:	2000      	movs	r0, #0
 802d3e2:	4770      	bx	lr

0802d3e4 <BSP_RADIO_IsTCXO>:
  *  RADIO_CONF_TCXO_SUPPORTED
  */
int32_t BSP_RADIO_IsTCXO(void)
{
  return RADIO_CONF_TCXO_SUPPORTED;
}
 802d3e4:	2001      	movs	r0, #1
 802d3e6:	4770      	bx	lr

0802d3e8 <BSP_RADIO_IsDCDC>:
 802d3e8:	2001      	movs	r0, #1
 802d3ea:	4770      	bx	lr

0802d3ec <SystemInit>:
  * @retval None
  */
void SystemInit(void)
{
  /* Configure the Vector Table location  ------------------*/
  SCB->VTOR = INTVECT_START;
 802d3ec:	4b0c      	ldr	r3, [pc, #48]	; (802d420 <SystemInit+0x34>)
 802d3ee:	4a0d      	ldr	r2, [pc, #52]	; (802d424 <SystemInit+0x38>)
 802d3f0:	609a      	str	r2, [r3, #8]
  SCB->CPACR |= ((3UL << (10UL*2UL))|(3UL << (11UL*2UL)));  /* set CP10 and CP11 Full Access */
#endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 802d3f2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802d3f6:	681a      	ldr	r2, [r3, #0]
 802d3f8:	f042 0201 	orr.w	r2, r2, #1
 802d3fc:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00070000U;
 802d3fe:	f44f 22e0 	mov.w	r2, #458752	; 0x70000
 802d402:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON , HSION, and PLLON bits */
  /* RCC->CR &= 0xEAF6FFFFU; */
  RCC->CR &= 0x2321EFF;
 802d404:	6819      	ldr	r1, [r3, #0]
 802d406:	4a08      	ldr	r2, [pc, #32]	; (802d428 <SystemInit+0x3c>)
 802d408:	400a      	ands	r2, r1
 802d40a:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x22040100;
 802d40c:	4a07      	ldr	r2, [pc, #28]	; (802d42c <SystemInit+0x40>)
 802d40e:	60da      	str	r2, [r3, #12]

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFDFFFFFFU;
 802d410:	681a      	ldr	r2, [r3, #0]
 802d412:	f022 7200 	bic.w	r2, r2, #33554432	; 0x2000000
 802d416:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000U;
 802d418:	2200      	movs	r2, #0
 802d41a:	619a      	str	r2, [r3, #24]
}
 802d41c:	4770      	bx	lr
 802d41e:	bf00      	nop
 802d420:	e000ed00 	.word	0xe000ed00
 802d424:	0802b200 	.word	0x0802b200
 802d428:	02321eff 	.word	0x02321eff
 802d42c:	22040100 	.word	0x22040100

0802d430 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 802d430:	b510      	push	{r4, lr}
#endif /* PREFETCH_ENABLE */

#ifdef CORE_CM0PLUS
#else
  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 802d432:	2003      	movs	r0, #3
 802d434:	f000 fc5c 	bl	802dcf0 <HAL_NVIC_SetPriorityGrouping>

  /* Update the SystemCoreClock global variable */
#if defined(DUAL_CORE) && defined(CORE_CM0PLUS)
  SystemCoreClock = HAL_RCC_GetHCLK2Freq();
#else
  SystemCoreClock = HAL_RCC_GetHCLKFreq();
 802d438:	f001 fac4 	bl	802e9c4 <HAL_RCC_GetHCLKFreq>
 802d43c:	4b06      	ldr	r3, [pc, #24]	; (802d458 <HAL_Init+0x28>)
 802d43e:	6018      	str	r0, [r3, #0]
#endif

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 802d440:	200f      	movs	r0, #15
 802d442:	f7ff f8fd 	bl	802c640 <HAL_InitTick>
 802d446:	4604      	mov	r4, r0
 802d448:	b918      	cbnz	r0, 802d452 <HAL_Init+0x22>
    status = HAL_ERROR;
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
 802d44a:	f7fe ffd0 	bl	802c3ee <HAL_MspInit>
  }

  /* Return function status */
  return status;
}
 802d44e:	4620      	mov	r0, r4
 802d450:	bd10      	pop	{r4, pc}
    status = HAL_ERROR;
 802d452:	2401      	movs	r4, #1
 802d454:	e7fb      	b.n	802d44e <HAL_Init+0x1e>
 802d456:	bf00      	nop
 802d458:	2000344c 	.word	0x2000344c

0802d45c <HAL_SuspendTick>:
  * @retval None
  */
__weak void HAL_SuspendTick(void)
{
  /* Disable SysTick Interrupt */
  CLEAR_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
 802d45c:	4a02      	ldr	r2, [pc, #8]	; (802d468 <HAL_SuspendTick+0xc>)
 802d45e:	6813      	ldr	r3, [r2, #0]
 802d460:	f023 0302 	bic.w	r3, r3, #2
 802d464:	6013      	str	r3, [r2, #0]
}
 802d466:	4770      	bx	lr
 802d468:	e000e010 	.word	0xe000e010

0802d46c <HAL_ResumeTick>:
  * @retval None
  */
__weak void HAL_ResumeTick(void)
{
  /* Enable SysTick Interrupt */
  SET_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
 802d46c:	4a02      	ldr	r2, [pc, #8]	; (802d478 <HAL_ResumeTick+0xc>)
 802d46e:	6813      	ldr	r3, [r2, #0]
 802d470:	f043 0302 	orr.w	r3, r3, #2
 802d474:	6013      	str	r3, [r2, #0]
}
 802d476:	4770      	bx	lr
 802d478:	e000e010 	.word	0xe000e010

0802d47c <HAL_GetUIDw0>:
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw0(void)
{
  return (READ_REG(*((uint32_t *)UID_BASE)));
}
 802d47c:	4b01      	ldr	r3, [pc, #4]	; (802d484 <HAL_GetUIDw0+0x8>)
 802d47e:	6818      	ldr	r0, [r3, #0]
 802d480:	4770      	bx	lr
 802d482:	bf00      	nop
 802d484:	1fff7590 	.word	0x1fff7590

0802d488 <HAL_GetUIDw1>:
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw1(void)
{
  return (READ_REG(*((uint32_t *)(UID_BASE + 4U))));
}
 802d488:	4b01      	ldr	r3, [pc, #4]	; (802d490 <HAL_GetUIDw1+0x8>)
 802d48a:	6818      	ldr	r0, [r3, #0]
 802d48c:	4770      	bx	lr
 802d48e:	bf00      	nop
 802d490:	1fff7594 	.word	0x1fff7594

0802d494 <HAL_GetUIDw2>:
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw2(void)
{
  return (READ_REG(*((uint32_t *)(UID_BASE + 8U))));
}
 802d494:	4b01      	ldr	r3, [pc, #4]	; (802d49c <HAL_GetUIDw2+0x8>)
 802d496:	6818      	ldr	r0, [r3, #0]
 802d498:	4770      	bx	lr
 802d49a:	bf00      	nop
 802d49c:	1fff7598 	.word	0x1fff7598

0802d4a0 <HAL_DBGMCU_EnableDBGSleepMode>:
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
 802d4a0:	4a02      	ldr	r2, [pc, #8]	; (802d4ac <HAL_DBGMCU_EnableDBGSleepMode+0xc>)
 802d4a2:	6853      	ldr	r3, [r2, #4]
 802d4a4:	f043 0301 	orr.w	r3, r3, #1
 802d4a8:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_EnableDBGSleepMode(void)
{
  LL_DBGMCU_EnableDBGSleepMode();
}
 802d4aa:	4770      	bx	lr
 802d4ac:	e0042000 	.word	0xe0042000

0802d4b0 <HAL_DBGMCU_DisableDBGSleepMode>:
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
 802d4b0:	4a02      	ldr	r2, [pc, #8]	; (802d4bc <HAL_DBGMCU_DisableDBGSleepMode+0xc>)
 802d4b2:	6853      	ldr	r3, [r2, #4]
 802d4b4:	f023 0301 	bic.w	r3, r3, #1
 802d4b8:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_DisableDBGSleepMode(void)
{
  LL_DBGMCU_DisableDBGSleepMode();
}
 802d4ba:	4770      	bx	lr
 802d4bc:	e0042000 	.word	0xe0042000

0802d4c0 <HAL_DBGMCU_EnableDBGStopMode>:
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
 802d4c0:	4a02      	ldr	r2, [pc, #8]	; (802d4cc <HAL_DBGMCU_EnableDBGStopMode+0xc>)
 802d4c2:	6853      	ldr	r3, [r2, #4]
 802d4c4:	f043 0302 	orr.w	r3, r3, #2
 802d4c8:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_EnableDBGStopMode(void)
{
  LL_DBGMCU_EnableDBGStopMode();
}
 802d4ca:	4770      	bx	lr
 802d4cc:	e0042000 	.word	0xe0042000

0802d4d0 <HAL_DBGMCU_DisableDBGStopMode>:
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
 802d4d0:	4a02      	ldr	r2, [pc, #8]	; (802d4dc <HAL_DBGMCU_DisableDBGStopMode+0xc>)
 802d4d2:	6853      	ldr	r3, [r2, #4]
 802d4d4:	f023 0302 	bic.w	r3, r3, #2
 802d4d8:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_DisableDBGStopMode(void)
{
  LL_DBGMCU_DisableDBGStopMode();
}
 802d4da:	4770      	bx	lr
 802d4dc:	e0042000 	.word	0xe0042000

0802d4e0 <HAL_DBGMCU_EnableDBGStandbyMode>:
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
 802d4e0:	4a02      	ldr	r2, [pc, #8]	; (802d4ec <HAL_DBGMCU_EnableDBGStandbyMode+0xc>)
 802d4e2:	6853      	ldr	r3, [r2, #4]
 802d4e4:	f043 0304 	orr.w	r3, r3, #4
 802d4e8:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_EnableDBGStandbyMode(void)
{
  LL_DBGMCU_EnableDBGStandbyMode();
}
 802d4ea:	4770      	bx	lr
 802d4ec:	e0042000 	.word	0xe0042000

0802d4f0 <HAL_DBGMCU_DisableDBGStandbyMode>:
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
 802d4f0:	4a02      	ldr	r2, [pc, #8]	; (802d4fc <HAL_DBGMCU_DisableDBGStandbyMode+0xc>)
 802d4f2:	6853      	ldr	r3, [r2, #4]
 802d4f4:	f023 0304 	bic.w	r3, r3, #4
 802d4f8:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_DisableDBGStandbyMode(void)
{
  LL_DBGMCU_DisableDBGStandbyMode();
}
 802d4fa:	4770      	bx	lr
 802d4fc:	e0042000 	.word	0xe0042000

0802d500 <LL_ADC_REG_IsConversionOngoing>:
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group regular.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsConversionOngoing(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 802d500:	6880      	ldr	r0, [r0, #8]
}
 802d502:	f3c0 0080 	ubfx	r0, r0, #2, #1
 802d506:	4770      	bx	lr

0802d508 <HAL_ADC_Init>:
  *         of structure "ADC_InitTypeDef".
  * @param hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef *hadc)
{
 802d508:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  uint32_t tmpCFGR1 = 0UL;
  uint32_t tmpCFGR2 = 0UL;
  uint32_t tmp_adc_reg_is_conversion_on_going;
  __IO uint32_t wait_loop_index = 0UL;
 802d50c:	2300      	movs	r3, #0
 802d50e:	9301      	str	r3, [sp, #4]

  /* Check ADC handle */
  if (hadc == NULL)
 802d510:	4604      	mov	r4, r0
 802d512:	2800      	cmp	r0, #0
 802d514:	f000 810a 	beq.w	802d72c <HAL_ADC_Init+0x224>
  /* continuous mode is disabled.                                             */
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));

  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  if (hadc->State == HAL_ADC_STATE_RESET)
 802d518:	6d85      	ldr	r5, [r0, #88]	; 0x58
 802d51a:	b925      	cbnz	r5, 802d526 <HAL_ADC_Init+0x1e>

    /* Init the low level hardware */
    hadc->MspInitCallback(hadc);
#else
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
 802d51c:	f7fe fcb8 	bl	802be90 <HAL_ADC_MspInit>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Set ADC error code to none */
    ADC_CLEAR_ERRORCODE(hadc);
 802d520:	65e5      	str	r5, [r4, #92]	; 0x5c

    /* Initialize Lock */
    hadc->Lock = HAL_UNLOCKED;
 802d522:	f884 5054 	strb.w	r5, [r4, #84]	; 0x54
  }

  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
 802d526:	6820      	ldr	r0, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 802d528:	6883      	ldr	r3, [r0, #8]
 802d52a:	00d9      	lsls	r1, r3, #3
 802d52c:	f140 80b3 	bpl.w	802d696 <HAL_ADC_Init+0x18e>
 802d530:	6883      	ldr	r3, [r0, #8]
 802d532:	00da      	lsls	r2, r3, #3
 802d534:	f100 80c6 	bmi.w	802d6c4 <HAL_ADC_Init+0x1bc>
  /* or not ADC is coming from state reset (if any potential problem of       */
  /* clocking, voltage regulator would not be enabled).                       */
  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 802d538:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802d53a:	f043 0310 	orr.w	r3, r3, #16
 802d53e:	65a3      	str	r3, [r4, #88]	; 0x58

    /* Set ADC error code to ADC peripheral internal error */
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 802d540:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 802d542:	f043 0301 	orr.w	r3, r3, #1
 802d546:	65e3      	str	r3, [r4, #92]	; 0x5c

    tmp_hal_status = HAL_ERROR;
 802d548:	2101      	movs	r1, #1

  /* Configuration of ADC parameters if previous preliminary actions are      */
  /* correctly completed and if there is no conversion on going on regular    */
  /* group (ADC may already be enabled at this point if HAL_ADC_Init() is     */
  /* called to update a parameter on the fly).                                */
  tmp_adc_reg_is_conversion_on_going = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 802d54a:	f7ff ffd9 	bl	802d500 <LL_ADC_REG_IsConversionOngoing>

  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 802d54e:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802d550:	f003 0310 	and.w	r3, r3, #16
 802d554:	4318      	orrs	r0, r3
      && (tmp_adc_reg_is_conversion_on_going == 0UL)
     )
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 802d556:	6da3      	ldr	r3, [r4, #88]	; 0x58
  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 802d558:	f040 80ea 	bne.w	802d730 <HAL_ADC_Init+0x228>
    ADC_STATE_CLR_SET(hadc->State,
 802d55c:	f423 7381 	bic.w	r3, r3, #258	; 0x102
 802d560:	f043 0302 	orr.w	r3, r3, #2
    /*  - Oversampling                                                        */
    /*  - Trigger frequency mode                                              */
    /* Note: If low power mode AutoPowerOff is enabled, ADC enable            */
    /*       and disable phases are performed automatically by hardware       */
    /*       (in this case, flag ADC_FLAG_RDY is not set).                    */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 802d564:	6822      	ldr	r2, [r4, #0]
    ADC_STATE_CLR_SET(hadc->State,
 802d566:	65a3      	str	r3, [r4, #88]	; 0x58
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 802d568:	6893      	ldr	r3, [r2, #8]
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 802d56a:	07db      	lsls	r3, r3, #31
 802d56c:	f100 80ac 	bmi.w	802d6c8 <HAL_ADC_Init+0x1c0>
      /* parameters):                                                         */
      /*   - internal measurement paths (VrefInt, ...)                        */
      /*     (set into HAL_ADC_ConfigChannel() )                              */

      /* Configuration of ADC resolution                                      */
      MODIFY_REG(hadc->Instance->CFGR1,
 802d570:	68d3      	ldr	r3, [r2, #12]
 802d572:	68a5      	ldr	r5, [r4, #8]
                 ADC_CFGR1_RES,
                 hadc->Init.Resolution);

      tmpCFGR2 |= ((hadc->Init.ClockPrescaler & ADC_CFGR2_CKMODE) |
 802d574:	6866      	ldr	r6, [r4, #4]
      MODIFY_REG(hadc->Instance->CFGR1,
 802d576:	f023 0318 	bic.w	r3, r3, #24
 802d57a:	432b      	orrs	r3, r5
 802d57c:	60d3      	str	r3, [r2, #12]
      tmpCFGR2 |= ((hadc->Init.ClockPrescaler & ADC_CFGR2_CKMODE) |
 802d57e:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 802d580:	f006 4c40 	and.w	ip, r6, #3221225472	; 0xc0000000
 802d584:	ea4c 0503 	orr.w	r5, ip, r3
                   hadc->Init.TriggerFrequencyMode
                  );

      if (hadc->Init.OversamplingMode == ENABLE)
 802d588:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
 802d58c:	2b01      	cmp	r3, #1
 802d58e:	d109      	bne.n	802d5a4 <HAL_ADC_Init+0x9c>
      {
        tmpCFGR2 |= (ADC_CFGR2_OVSE |
 802d590:	e9d4 3710 	ldrd	r3, r7, [r4, #64]	; 0x40
 802d594:	433b      	orrs	r3, r7
 802d596:	432b      	orrs	r3, r5
 802d598:	6ca5      	ldr	r5, [r4, #72]	; 0x48
 802d59a:	432b      	orrs	r3, r5
 802d59c:	ea43 030c 	orr.w	r3, r3, ip
 802d5a0:	f043 0501 	orr.w	r5, r3, #1
                     hadc->Init.Oversampling.RightBitShift |
                     hadc->Init.Oversampling.TriggeredMode
                    );
      }

      MODIFY_REG(hadc->Instance->CFGR2,
 802d5a4:	6917      	ldr	r7, [r2, #16]
 802d5a6:	4b64      	ldr	r3, [pc, #400]	; (802d738 <HAL_ADC_Init+0x230>)
 802d5a8:	403b      	ands	r3, r7
 802d5aa:	432b      	orrs	r3, r5
 802d5ac:	6113      	str	r3, [r2, #16]
                 ADC_CFGR2_TOVS,
                 tmpCFGR2);

      /* Configuration of ADC clock mode: asynchronous clock source           */
      /* with selectable prescaler.                                           */
      if (((hadc->Init.ClockPrescaler) != ADC_CLOCK_SYNC_PCLK_DIV1) &&
 802d5ae:	f026 4300 	bic.w	r3, r6, #2147483648	; 0x80000000
 802d5b2:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 802d5b6:	d00a      	beq.n	802d5ce <HAL_ADC_Init+0xc6>
          ((hadc->Init.ClockPrescaler) != ADC_CLOCK_SYNC_PCLK_DIV2) &&
 802d5b8:	f1b6 4f00 	cmp.w	r6, #2147483648	; 0x80000000
 802d5bc:	d007      	beq.n	802d5ce <HAL_ADC_Init+0xc6>
          ((hadc->Init.ClockPrescaler) != ADC_CLOCK_SYNC_PCLK_DIV4))
      {
        MODIFY_REG(ADC_COMMON->CCR,
 802d5be:	4f5f      	ldr	r7, [pc, #380]	; (802d73c <HAL_ADC_Init+0x234>)
 802d5c0:	683b      	ldr	r3, [r7, #0]
 802d5c2:	f406 1670 	and.w	r6, r6, #3932160	; 0x3c0000
 802d5c6:	f423 1370 	bic.w	r3, r3, #3932160	; 0x3c0000
 802d5ca:	431e      	orrs	r6, r3
 802d5cc:	603e      	str	r6, [r7, #0]
    /*  - data alignment                                                      */
    /*  - resolution                                                          */
    /*  - scan direction                                                      */
    /*  - DMA continuous request                                              */
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)      |
                 ADC_CFGR1_AUTOOFF((uint32_t)hadc->Init.LowPowerAutoPowerOff)   |
 802d5ce:	7e63      	ldrb	r3, [r4, #25]
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)      |
 802d5d0:	7e26      	ldrb	r6, [r4, #24]
 802d5d2:	68e7      	ldr	r7, [r4, #12]
                 ADC_CFGR1_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)  |
                 ADC_CFGR1_OVERRUN(hadc->Init.Overrun)                          |
 802d5d4:	f8d4 c030 	ldr.w	ip, [r4, #48]	; 0x30
                 hadc->Init.DataAlign                                           |
                 ADC_SCAN_SEQ_MODE(hadc->Init.ScanConvMode)                     |
                 ADC_CFGR1_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests));
 802d5d8:	f894 802c 	ldrb.w	r8, [r4, #44]	; 0x2c
                 ADC_CFGR1_AUTOOFF((uint32_t)hadc->Init.LowPowerAutoPowerOff)   |
 802d5dc:	03db      	lsls	r3, r3, #15
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)      |
 802d5de:	ea43 3386 	orr.w	r3, r3, r6, lsl #14
                 ADC_CFGR1_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)  |
 802d5e2:	7ea6      	ldrb	r6, [r4, #26]
 802d5e4:	433b      	orrs	r3, r7
                 ADC_CFGR1_OVERRUN(hadc->Init.Overrun)                          |
 802d5e6:	f1bc 0f00 	cmp.w	ip, #0
 802d5ea:	ea43 3346 	orr.w	r3, r3, r6, lsl #13
 802d5ee:	bf18      	it	ne
 802d5f0:	f44f 5c80 	movne.w	ip, #4096	; 0x1000
                 ADC_SCAN_SEQ_MODE(hadc->Init.ScanConvMode)                     |
 802d5f4:	6927      	ldr	r7, [r4, #16]
 802d5f6:	ea43 0348 	orr.w	r3, r3, r8, lsl #1
 802d5fa:	ea43 030c 	orr.w	r3, r3, ip

    /* Update setting of discontinuous mode only if continuous mode is disabled */
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 802d5fe:	f894 c020 	ldrb.w	ip, [r4, #32]
                 ADC_SCAN_SEQ_MODE(hadc->Init.ScanConvMode)                     |
 802d602:	2f00      	cmp	r7, #0
 802d604:	bfb4      	ite	lt
 802d606:	f027 4e00 	biclt.w	lr, r7, #2147483648	; 0x80000000
 802d60a:	f44f 1e00 	movge.w	lr, #2097152	; 0x200000
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 802d60e:	f1bc 0f01 	cmp.w	ip, #1
                 ADC_SCAN_SEQ_MODE(hadc->Init.ScanConvMode)                     |
 802d612:	ea43 0e0e 	orr.w	lr, r3, lr
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 802d616:	d103      	bne.n	802d620 <HAL_ADC_Init+0x118>
    {
      if (hadc->Init.ContinuousConvMode == DISABLE)
 802d618:	2e00      	cmp	r6, #0
 802d61a:	d157      	bne.n	802d6cc <HAL_ADC_Init+0x1c4>
      {
        /* Enable the selected ADC group regular discontinuous mode */
        tmpCFGR1 |= ADC_CFGR1_DISCEN;
 802d61c:	f44e 3e80 	orr.w	lr, lr, #65536	; 0x10000
    /* Enable external trigger if trigger selection is different of software  */
    /* start.                                                                 */
    /* Note: This configuration keeps the hardware feature of parameter       */
    /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
    /*       software start.                                                  */
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 802d620:	6a66      	ldr	r6, [r4, #36]	; 0x24
 802d622:	b12e      	cbz	r6, 802d630 <HAL_ADC_Init+0x128>
    {
      tmpCFGR1 |= ((hadc->Init.ExternalTrigConv & ADC_CFGR1_EXTSEL) |
 802d624:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 802d626:	f406 76e0 	and.w	r6, r6, #448	; 0x1c0
 802d62a:	431e      	orrs	r6, r3
 802d62c:	ea4e 0e06 	orr.w	lr, lr, r6
                   hadc->Init.ExternalTrigConvEdge);
    }

    /* Update ADC configuration register with previous settings */
    MODIFY_REG(hadc->Instance->CFGR1,
 802d630:	68d6      	ldr	r6, [r2, #12]
 802d632:	f426 36fe 	bic.w	r6, r6, #130048	; 0x1fc00
 802d636:	f426 76f3 	bic.w	r6, r6, #486	; 0x1e6
 802d63a:	ea46 060e 	orr.w	r6, r6, lr
 802d63e:	60d6      	str	r6, [r2, #12]
               ADC_CFGR1_ALIGN   |
               ADC_CFGR1_SCANDIR |
               ADC_CFGR1_DMACFG,
               tmpCFGR1);

    MODIFY_REG(hadc->Instance->CFGR2,
 802d640:	f8d2 c010 	ldr.w	ip, [r2, #16]
 802d644:	4e3e      	ldr	r6, [pc, #248]	; (802d740 <HAL_ADC_Init+0x238>)
 802d646:	ea0c 0606 	and.w	r6, ip, r6
 802d64a:	4335      	orrs	r5, r6
 802d64c:	6115      	str	r5, [r2, #16]
  MODIFY_REG(ADCx->SMPR,
 802d64e:	6955      	ldr	r5, [r2, #20]
 802d650:	6b66      	ldr	r6, [r4, #52]	; 0x34
 802d652:	f025 0507 	bic.w	r5, r5, #7
 802d656:	4335      	orrs	r5, r6
 802d658:	6155      	str	r5, [r2, #20]
 802d65a:	6955      	ldr	r5, [r2, #20]
 802d65c:	6ba6      	ldr	r6, [r4, #56]	; 0x38
 802d65e:	f025 0570 	bic.w	r5, r5, #112	; 0x70
 802d662:	ea45 1506 	orr.w	r5, r5, r6, lsl #4
 802d666:	6155      	str	r5, [r2, #20]
    /*   emulated by software for alignment over all STM32 devices.           */
    /* - if scan mode is enabled, regular channels sequence length is set to  */
    /*   parameter "NbrOfConversion".                                         */
    /*   Channels must be configured into each rank using function            */
    /*   "HAL_ADC_ConfigChannel()".                                           */
    if (hadc->Init.ScanConvMode == ADC_SCAN_DISABLE)
 802d668:	2f00      	cmp	r7, #0
 802d66a:	d138      	bne.n	802d6de <HAL_ADC_Init+0x1d6>
      if (ADCGroupRegularSequencerRanksCount == 1UL)
      {
        /* Set ADC group regular sequencer:                                   */
        /* Set sequencer scan length by clearing ranks above rank 1           */
        /* and do not modify rank 1 value.                                    */
        SET_BIT(hadc->Instance->CHSELR,
 802d66c:	6a90      	ldr	r0, [r2, #40]	; 0x28
 802d66e:	f060 000f 	orn	r0, r0, #15
        /*          therefore after the first call of "HAL_ADC_Init()",       */
        /*          each rank corresponding to parameter "NbrOfConversion"    */
        /*          must be set using "HAL_ADC_ConfigChannel()".              */
        /*  - Set sequencer scan length by clearing ranks above maximum rank  */
        /*    and do not modify other ranks value.                            */
        MODIFY_REG(hadc->Instance->CHSELR,
 802d672:	6290      	str	r0, [r2, #40]	; 0x28
    /* Check back that ADC registers have effectively been configured to      */
    /* ensure of no potential problem of ADC core peripheral clocking.        */
    /* Check through register CFGR1 (excluding analog watchdog configuration: */
    /* set into separate dedicated function, and bits of ADC resolution set   */
    /* out of temporary variable 'tmpCFGR1').                                 */
    if ((hadc->Instance->CFGR1 & ~(ADC_CFGR1_AWD1CH | ADC_CFGR1_AWD1EN | ADC_CFGR1_AWD1SGL | ADC_CFGR1_RES))
 802d674:	68d0      	ldr	r0, [r2, #12]
 802d676:	4a33      	ldr	r2, [pc, #204]	; (802d744 <HAL_ADC_Init+0x23c>)
 802d678:	4002      	ands	r2, r0
 802d67a:	4572      	cmp	r2, lr
 802d67c:	d14c      	bne.n	802d718 <HAL_ADC_Init+0x210>
        == tmpCFGR1)
    {
      /* Set ADC error code to none */
      ADC_CLEAR_ERRORCODE(hadc);
 802d67e:	2300      	movs	r3, #0
 802d680:	65e3      	str	r3, [r4, #92]	; 0x5c

      /* Set the ADC state */
      ADC_STATE_CLR_SET(hadc->State,
 802d682:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802d684:	f023 0303 	bic.w	r3, r3, #3
 802d688:	f043 0301 	orr.w	r3, r3, #1
 802d68c:	65a3      	str	r3, [r4, #88]	; 0x58

    tmp_hal_status = HAL_ERROR;
  }

  return tmp_hal_status;
}
 802d68e:	4608      	mov	r0, r1
 802d690:	b002      	add	sp, #8
 802d692:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  MODIFY_REG(ADCx->CR,
 802d696:	6883      	ldr	r3, [r0, #8]
    wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 802d698:	4a2b      	ldr	r2, [pc, #172]	; (802d748 <HAL_ADC_Init+0x240>)
 802d69a:	f023 4310 	bic.w	r3, r3, #2415919104	; 0x90000000
 802d69e:	f023 0317 	bic.w	r3, r3, #23
 802d6a2:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 802d6a6:	6083      	str	r3, [r0, #8]
 802d6a8:	4b28      	ldr	r3, [pc, #160]	; (802d74c <HAL_ADC_Init+0x244>)
 802d6aa:	681b      	ldr	r3, [r3, #0]
 802d6ac:	fbb3 f3f2 	udiv	r3, r3, r2
 802d6b0:	3301      	adds	r3, #1
 802d6b2:	005b      	lsls	r3, r3, #1
      wait_loop_index--;
 802d6b4:	9301      	str	r3, [sp, #4]
    while (wait_loop_index != 0UL)
 802d6b6:	9b01      	ldr	r3, [sp, #4]
 802d6b8:	2b00      	cmp	r3, #0
 802d6ba:	f43f af39 	beq.w	802d530 <HAL_ADC_Init+0x28>
      wait_loop_index--;
 802d6be:	9b01      	ldr	r3, [sp, #4]
 802d6c0:	3b01      	subs	r3, #1
 802d6c2:	e7f7      	b.n	802d6b4 <HAL_ADC_Init+0x1ac>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 802d6c4:	2100      	movs	r1, #0
 802d6c6:	e740      	b.n	802d54a <HAL_ADC_Init+0x42>
  uint32_t tmpCFGR2 = 0UL;
 802d6c8:	4605      	mov	r5, r0
 802d6ca:	e780      	b.n	802d5ce <HAL_ADC_Init+0xc6>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 802d6cc:	6da6      	ldr	r6, [r4, #88]	; 0x58
 802d6ce:	f046 0620 	orr.w	r6, r6, #32
 802d6d2:	65a6      	str	r6, [r4, #88]	; 0x58
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 802d6d4:	6de6      	ldr	r6, [r4, #92]	; 0x5c
 802d6d6:	f046 0601 	orr.w	r6, r6, #1
 802d6da:	65e6      	str	r6, [r4, #92]	; 0x5c
 802d6dc:	e7a0      	b.n	802d620 <HAL_ADC_Init+0x118>
    else if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
 802d6de:	f5b7 1f00 	cmp.w	r7, #2097152	; 0x200000
 802d6e2:	d1c7      	bne.n	802d674 <HAL_ADC_Init+0x16c>
        if (((hadc->ADCGroupRegularSequencerRanks >> (ADCGroupRegularSequencerRanksCount * 4UL)) & ADC_CHSELR_SQ1) ==
 802d6e4:	6e26      	ldr	r6, [r4, #96]	; 0x60
 802d6e6:	0085      	lsls	r5, r0, #2
 802d6e8:	fa26 f505 	lsr.w	r5, r6, r5
 802d6ec:	f005 050f 	and.w	r5, r5, #15
 802d6f0:	2d0f      	cmp	r5, #15
 802d6f2:	d00e      	beq.n	802d712 <HAL_ADC_Init+0x20a>
      for (ADCGroupRegularSequencerRanksCount = 0UL; ADCGroupRegularSequencerRanksCount < (8UL); ADCGroupRegularSequencerRanksCount++)
 802d6f4:	3001      	adds	r0, #1
 802d6f6:	2808      	cmp	r0, #8
 802d6f8:	d1f5      	bne.n	802d6e6 <HAL_ADC_Init+0x1de>
        MODIFY_REG(hadc->Instance->CHSELR,
 802d6fa:	6a90      	ldr	r0, [r2, #40]	; 0x28
 802d6fc:	69e0      	ldr	r0, [r4, #28]
 802d6fe:	3801      	subs	r0, #1
 802d700:	0080      	lsls	r0, r0, #2
 802d702:	f000 001c 	and.w	r0, r0, #28
 802d706:	f06f 050f 	mvn.w	r5, #15
 802d70a:	fa05 f000 	lsl.w	r0, r5, r0
 802d70e:	4330      	orrs	r0, r6
 802d710:	e7af      	b.n	802d672 <HAL_ADC_Init+0x16a>
      if (ADCGroupRegularSequencerRanksCount == 1UL)
 802d712:	2801      	cmp	r0, #1
 802d714:	d0aa      	beq.n	802d66c <HAL_ADC_Init+0x164>
 802d716:	e7f0      	b.n	802d6fa <HAL_ADC_Init+0x1f2>
      ADC_STATE_CLR_SET(hadc->State,
 802d718:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802d71a:	f023 0312 	bic.w	r3, r3, #18
 802d71e:	f043 0310 	orr.w	r3, r3, #16
 802d722:	65a3      	str	r3, [r4, #88]	; 0x58
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 802d724:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 802d726:	f043 0301 	orr.w	r3, r3, #1
 802d72a:	65e3      	str	r3, [r4, #92]	; 0x5c
    return HAL_ERROR;
 802d72c:	2101      	movs	r1, #1
 802d72e:	e7ae      	b.n	802d68e <HAL_ADC_Init+0x186>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 802d730:	f043 0310 	orr.w	r3, r3, #16
 802d734:	65a3      	str	r3, [r4, #88]	; 0x58
    tmp_hal_status = HAL_ERROR;
 802d736:	e7f9      	b.n	802d72c <HAL_ADC_Init+0x224>
 802d738:	1ffffc02 	.word	0x1ffffc02
 802d73c:	40012708 	.word	0x40012708
 802d740:	dffffc02 	.word	0xdffffc02
 802d744:	833fffe7 	.word	0x833fffe7
 802d748:	00030d40 	.word	0x00030d40
 802d74c:	2000344c 	.word	0x2000344c

0802d750 <HAL_ADC_PollForConversion>:
  * @param hadc ADC handle
  * @param Timeout Timeout value in millisecond.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef *hadc, uint32_t Timeout)
{
 802d750:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  /* If end of conversion selected to end of sequence conversions */
  if (hadc->Init.EOCSelection == ADC_EOC_SEQ_CONV)
 802d752:	6945      	ldr	r5, [r0, #20]
 802d754:	2d08      	cmp	r5, #8
{
 802d756:	4604      	mov	r4, r0
 802d758:	460e      	mov	r6, r1
  if (hadc->Init.EOCSelection == ADC_EOC_SEQ_CONV)
 802d75a:	d00a      	beq.n	802d772 <HAL_ADC_PollForConversion+0x22>
    /* each conversion:                                                       */
    /* Particular case is ADC configured in DMA mode and ADC sequencer with   */
    /* several ranks and polling for end of each conversion.                  */
    /* For code simplicity sake, this particular case is generalized to       */
    /* ADC configured in DMA mode and and polling for end of each conversion. */
    if ((hadc->Instance->CFGR1 & ADC_CFGR1_DMAEN) != 0UL)
 802d75c:	6803      	ldr	r3, [r0, #0]
 802d75e:	68db      	ldr	r3, [r3, #12]
 802d760:	07d9      	lsls	r1, r3, #31
 802d762:	d505      	bpl.n	802d770 <HAL_ADC_PollForConversion+0x20>
    {
      /* Update ADC state machine to error */
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 802d764:	6d83      	ldr	r3, [r0, #88]	; 0x58
 802d766:	f043 0320 	orr.w	r3, r3, #32
 802d76a:	6583      	str	r3, [r0, #88]	; 0x58

      return HAL_ERROR;
 802d76c:	2001      	movs	r0, #1
    __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS));
  }

  /* Return function status */
  return HAL_OK;
}
 802d76e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      tmp_flag_end = (ADC_FLAG_EOC);
 802d770:	2504      	movs	r5, #4
  tickstart = HAL_GetTick();
 802d772:	f7fe ff67 	bl	802c644 <HAL_GetTick>
 802d776:	4607      	mov	r7, r0
  while ((hadc->Instance->ISR & tmp_flag_end) == 0UL)
 802d778:	6820      	ldr	r0, [r4, #0]
 802d77a:	6803      	ldr	r3, [r0, #0]
 802d77c:	422b      	tst	r3, r5
 802d77e:	d022      	beq.n	802d7c6 <HAL_ADC_PollForConversion+0x76>
  SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
 802d780:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802d782:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 802d786:	65a3      	str	r3, [r4, #88]	; 0x58
  return ((READ_BIT(ADCx->CFGR1, ADC_CFGR1_EXTEN) == (LL_ADC_REG_TRIG_SOFTWARE & ADC_CFGR1_EXTEN)) ? 1UL : 0UL);
 802d788:	68c3      	ldr	r3, [r0, #12]
 802d78a:	f413 6f40 	tst.w	r3, #3072	; 0xc00
 802d78e:	d114      	bne.n	802d7ba <HAL_ADC_PollForConversion+0x6a>
      && (hadc->Init.ContinuousConvMode == DISABLE)
 802d790:	7ea3      	ldrb	r3, [r4, #26]
 802d792:	b993      	cbnz	r3, 802d7ba <HAL_ADC_PollForConversion+0x6a>
    if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS))
 802d794:	6803      	ldr	r3, [r0, #0]
 802d796:	071b      	lsls	r3, r3, #28
 802d798:	d50f      	bpl.n	802d7ba <HAL_ADC_PollForConversion+0x6a>
      if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 802d79a:	f7ff feb1 	bl	802d500 <LL_ADC_REG_IsConversionOngoing>
 802d79e:	bb38      	cbnz	r0, 802d7f0 <HAL_ADC_PollForConversion+0xa0>
        __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC | ADC_IT_EOS);
 802d7a0:	6822      	ldr	r2, [r4, #0]
 802d7a2:	6853      	ldr	r3, [r2, #4]
 802d7a4:	f023 030c 	bic.w	r3, r3, #12
 802d7a8:	6053      	str	r3, [r2, #4]
        ADC_STATE_CLR_SET(hadc->State,
 802d7aa:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802d7ac:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 802d7b0:	f023 0301 	bic.w	r3, r3, #1
 802d7b4:	f043 0301 	orr.w	r3, r3, #1
 802d7b8:	65a3      	str	r3, [r4, #88]	; 0x58
  if (hadc->Init.LowPowerAutoWait == DISABLE)
 802d7ba:	7e20      	ldrb	r0, [r4, #24]
 802d7bc:	bb08      	cbnz	r0, 802d802 <HAL_ADC_PollForConversion+0xb2>
    __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS));
 802d7be:	6823      	ldr	r3, [r4, #0]
 802d7c0:	220c      	movs	r2, #12
 802d7c2:	601a      	str	r2, [r3, #0]
 802d7c4:	e7d3      	b.n	802d76e <HAL_ADC_PollForConversion+0x1e>
    if (Timeout != HAL_MAX_DELAY)
 802d7c6:	1c72      	adds	r2, r6, #1
 802d7c8:	d0d7      	beq.n	802d77a <HAL_ADC_PollForConversion+0x2a>
      if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0UL))
 802d7ca:	f7fe ff3b 	bl	802c644 <HAL_GetTick>
 802d7ce:	1bc0      	subs	r0, r0, r7
 802d7d0:	42b0      	cmp	r0, r6
 802d7d2:	d801      	bhi.n	802d7d8 <HAL_ADC_PollForConversion+0x88>
 802d7d4:	2e00      	cmp	r6, #0
 802d7d6:	d1cf      	bne.n	802d778 <HAL_ADC_PollForConversion+0x28>
        if ((hadc->Instance->ISR & tmp_flag_end) == 0UL)
 802d7d8:	6823      	ldr	r3, [r4, #0]
 802d7da:	681b      	ldr	r3, [r3, #0]
 802d7dc:	402b      	ands	r3, r5
 802d7de:	d1cb      	bne.n	802d778 <HAL_ADC_PollForConversion+0x28>
          SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 802d7e0:	6da2      	ldr	r2, [r4, #88]	; 0x58
          __HAL_UNLOCK(hadc);
 802d7e2:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54
          SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 802d7e6:	f042 0204 	orr.w	r2, r2, #4
 802d7ea:	65a2      	str	r2, [r4, #88]	; 0x58
          return HAL_TIMEOUT;
 802d7ec:	2003      	movs	r0, #3
 802d7ee:	e7be      	b.n	802d76e <HAL_ADC_PollForConversion+0x1e>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 802d7f0:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802d7f2:	f043 0320 	orr.w	r3, r3, #32
 802d7f6:	65a3      	str	r3, [r4, #88]	; 0x58
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 802d7f8:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 802d7fa:	f043 0301 	orr.w	r3, r3, #1
 802d7fe:	65e3      	str	r3, [r4, #92]	; 0x5c
 802d800:	e7db      	b.n	802d7ba <HAL_ADC_PollForConversion+0x6a>
  return HAL_OK;
 802d802:	2000      	movs	r0, #0
 802d804:	e7b3      	b.n	802d76e <HAL_ADC_PollForConversion+0x1e>

0802d806 <HAL_ADC_GetValue>:

  /* Note: EOC flag is not cleared here by software because automatically     */
  /*       cleared by hardware when reading register DR.                      */

  /* Return ADC converted value */
  return hadc->Instance->DR;
 802d806:	6803      	ldr	r3, [r0, #0]
 802d808:	6c18      	ldr	r0, [r3, #64]	; 0x40
}
 802d80a:	4770      	bx	lr

0802d80c <HAL_ADC_ConfigChannel>:
  * @param hadc ADC handle
  * @param pConfig Structure of ADC channel assigned to ADC group regular.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef *hadc, ADC_ChannelConfTypeDef *pConfig)
{
 802d80c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  uint32_t tmp_config_internal_channel;
  __IO uint32_t wait_loop_index = 0UL;
 802d80e:	2300      	movs	r3, #0
 802d810:	9301      	str	r3, [sp, #4]
    assert_param(IS_ADC_REGULAR_NB_CONV(hadc->Init.NbrOfConversion));

    assert_param(IS_ADC_REGULAR_RANK(pConfig->Rank));
  }

  __HAL_LOCK(hadc);
 802d812:	f890 3054 	ldrb.w	r3, [r0, #84]	; 0x54
 802d816:	2b01      	cmp	r3, #1
{
 802d818:	4604      	mov	r4, r0
  __HAL_LOCK(hadc);
 802d81a:	f000 80bb 	beq.w	802d994 <HAL_ADC_ConfigChannel+0x188>
 802d81e:	2301      	movs	r3, #1
 802d820:	f880 3054 	strb.w	r3, [r0, #84]	; 0x54
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Channel number                                                        */
  /*  - Channel sampling time                                                 */
  /*  - Management of internal measurement channels: VrefInt/TempSensor/Vbat  */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 802d824:	6800      	ldr	r0, [r0, #0]
 802d826:	f7ff fe6b 	bl	802d500 <LL_ADC_REG_IsConversionOngoing>
 802d82a:	2800      	cmp	r0, #0
 802d82c:	f040 80ac 	bne.w	802d988 <HAL_ADC_ConfigChannel+0x17c>
    /* If sequencer set to not fully configurable with channel rank set to    */
    /* none, remove the channel from the sequencer.                           */
    /* Otherwise (sequencer set to fully configurable or to to not fully      */
    /* configurable with channel rank to be set), configure the selected      */
    /* channel.                                                               */
    if (pConfig->Rank != ADC_RANK_NONE)
 802d830:	6848      	ldr	r0, [r1, #4]
 802d832:	6923      	ldr	r3, [r4, #16]
 802d834:	680a      	ldr	r2, [r1, #0]
 802d836:	2802      	cmp	r0, #2
 802d838:	f023 0304 	bic.w	r3, r3, #4
 802d83c:	d07c      	beq.n	802d938 <HAL_ADC_ConfigChannel+0x12c>
      /* Note: ADC channel configuration requires few ADC clock cycles        */
      /*       to be ready. Processing of ADC settings in this function       */
      /*       induce that a specific wait time is not necessary.             */
      /*       For more details on ADC channel configuration ready,           */
      /*       refer to function "LL_ADC_IsActiveFlag_CCRDY()".               */
      if ((hadc->Init.ScanConvMode == ADC_SCAN_SEQ_FIXED)       ||
 802d83e:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 802d842:	6825      	ldr	r5, [r4, #0]
 802d844:	f3c2 0e11 	ubfx	lr, r2, #0, #18
 802d848:	d113      	bne.n	802d872 <HAL_ADC_ConfigChannel+0x66>
  SET_BIT(ADCx->CHSELR, (Channel & ADC_CHANNEL_ID_BITFIELD_MASK));
 802d84a:	6aab      	ldr	r3, [r5, #40]	; 0x28
 802d84c:	ea43 030e 	orr.w	r3, r3, lr
  MODIFY_REG(ADCx->CHSELR,
 802d850:	62ab      	str	r3, [r5, #40]	; 0x28
  MODIFY_REG(ADCx->SMPR,
 802d852:	688b      	ldr	r3, [r1, #8]
 802d854:	6968      	ldr	r0, [r5, #20]
 802d856:	ea03 2302 	and.w	r3, r3, r2, lsl #8
 802d85a:	f023 437c 	bic.w	r3, r3, #4227858432	; 0xfc000000
 802d85e:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 802d862:	ea20 2102 	bic.w	r1, r0, r2, lsl #8
 802d866:	430b      	orrs	r3, r1
      /* internal measurement paths enable: If internal channel selected,     */
      /* enable dedicated internal buffers and path.                          */
      /* Note: these internal measurement paths can be disabled using         */
      /*       HAL_ADC_DeInit() or removing the channel from sequencer with   */
      /*       channel configuration parameter "Rank".                        */
      if (__LL_ADC_IS_CHANNEL_INTERNAL(pConfig->Channel))
 802d868:	2a00      	cmp	r2, #0
 802d86a:	616b      	str	r3, [r5, #20]
 802d86c:	db26      	blt.n	802d8bc <HAL_ADC_ConfigChannel+0xb0>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 802d86e:	2000      	movs	r0, #0
}
 802d870:	e050      	b.n	802d914 <HAL_ADC_ConfigChannel+0x108>
        MODIFY_REG(hadc->ADCGroupRegularSequencerRanks,
 802d872:	6e23      	ldr	r3, [r4, #96]	; 0x60
 802d874:	f000 071f 	and.w	r7, r0, #31
 802d878:	f04f 0c0f 	mov.w	ip, #15
 802d87c:	fa0c fc07 	lsl.w	ip, ip, r7
 802d880:	ea6f 060c 	mvn.w	r6, ip
 802d884:	ea23 0c0c 	bic.w	ip, r3, ip
 802d888:	f1be 0f00 	cmp.w	lr, #0
 802d88c:	d111      	bne.n	802d8b2 <HAL_ADC_ConfigChannel+0xa6>
 802d88e:	f3c2 6384 	ubfx	r3, r2, #26, #5
 802d892:	40bb      	lsls	r3, r7
 802d894:	ea43 030c 	orr.w	r3, r3, ip
 802d898:	6623      	str	r3, [r4, #96]	; 0x60
        if (((pConfig->Rank >> 2UL) + 1UL) <= hadc->Init.NbrOfConversion)
 802d89a:	0880      	lsrs	r0, r0, #2
 802d89c:	69e3      	ldr	r3, [r4, #28]
 802d89e:	3001      	adds	r0, #1
 802d8a0:	4298      	cmp	r0, r3
 802d8a2:	d8d6      	bhi.n	802d852 <HAL_ADC_ConfigChannel+0x46>
  MODIFY_REG(ADCx->CHSELR,
 802d8a4:	6aa8      	ldr	r0, [r5, #40]	; 0x28
 802d8a6:	f3c2 6383 	ubfx	r3, r2, #26, #4
 802d8aa:	40bb      	lsls	r3, r7
 802d8ac:	4006      	ands	r6, r0
 802d8ae:	4333      	orrs	r3, r6
 802d8b0:	e7ce      	b.n	802d850 <HAL_ADC_ConfigChannel+0x44>
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 802d8b2:	fa92 f3a2 	rbit	r3, r2
   */
  if (value == 0U)
  {
    return 32U;
  }
  return __builtin_clz(value);
 802d8b6:	fab3 f383 	clz	r3, r3
 802d8ba:	e7ea      	b.n	802d892 <HAL_ADC_ConfigChannel+0x86>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 802d8bc:	4936      	ldr	r1, [pc, #216]	; (802d998 <HAL_ADC_ConfigChannel+0x18c>)
      {
        tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));

        /* If the requested internal measurement path has already been enabled,   */
        /* bypass the configuration processing.                                   */
        if ((pConfig->Channel == ADC_CHANNEL_TEMPSENSOR) &&
 802d8be:	4837      	ldr	r0, [pc, #220]	; (802d99c <HAL_ADC_ConfigChannel+0x190>)
 802d8c0:	680b      	ldr	r3, [r1, #0]
 802d8c2:	4282      	cmp	r2, r0
 802d8c4:	f003 75e0 	and.w	r5, r3, #29360128	; 0x1c00000
 802d8c8:	d117      	bne.n	802d8fa <HAL_ADC_ConfigChannel+0xee>
 802d8ca:	021b      	lsls	r3, r3, #8
 802d8cc:	d4cf      	bmi.n	802d86e <HAL_ADC_ConfigChannel+0x62>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 802d8ce:	680b      	ldr	r3, [r1, #0]
          /* Delay for temperature sensor stabilization time */
          /* Wait loop initialization and execution */
          /* Note: Variable divided by 2 to compensate partially              */
          /*       CPU processing cycles, scaling in us split to not          */
          /*       exceed 32 bits register capacity and handle low frequency. */
          wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 802d8d0:	4a33      	ldr	r2, [pc, #204]	; (802d9a0 <HAL_ADC_ConfigChannel+0x194>)
 802d8d2:	f023 73e0 	bic.w	r3, r3, #29360128	; 0x1c00000
 802d8d6:	432b      	orrs	r3, r5
 802d8d8:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 802d8dc:	600b      	str	r3, [r1, #0]
 802d8de:	4b31      	ldr	r3, [pc, #196]	; (802d9a4 <HAL_ADC_ConfigChannel+0x198>)
 802d8e0:	681b      	ldr	r3, [r3, #0]
 802d8e2:	fbb3 f2f2 	udiv	r2, r3, r2
 802d8e6:	230c      	movs	r3, #12
 802d8e8:	fb02 3303 	mla	r3, r2, r3, r3
          while (wait_loop_index != 0UL)
          {
            wait_loop_index--;
 802d8ec:	9301      	str	r3, [sp, #4]
          while (wait_loop_index != 0UL)
 802d8ee:	9b01      	ldr	r3, [sp, #4]
 802d8f0:	2b00      	cmp	r3, #0
 802d8f2:	d0bc      	beq.n	802d86e <HAL_ADC_ConfigChannel+0x62>
            wait_loop_index--;
 802d8f4:	9b01      	ldr	r3, [sp, #4]
 802d8f6:	3b01      	subs	r3, #1
 802d8f8:	e7f8      	b.n	802d8ec <HAL_ADC_ConfigChannel+0xe0>
          }
        }
        else if ((pConfig->Channel == ADC_CHANNEL_VBAT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
 802d8fa:	482b      	ldr	r0, [pc, #172]	; (802d9a8 <HAL_ADC_ConfigChannel+0x19c>)
 802d8fc:	4282      	cmp	r2, r0
 802d8fe:	d10e      	bne.n	802d91e <HAL_ADC_ConfigChannel+0x112>
 802d900:	f013 7080 	ands.w	r0, r3, #16777216	; 0x1000000
 802d904:	d1b3      	bne.n	802d86e <HAL_ADC_ConfigChannel+0x62>
 802d906:	680b      	ldr	r3, [r1, #0]
 802d908:	f023 73e0 	bic.w	r3, r3, #29360128	; 0x1c00000
 802d90c:	432b      	orrs	r3, r5
 802d90e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 802d912:	600b      	str	r3, [r1, #0]
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);

    tmp_hal_status = HAL_ERROR;
  }

  __HAL_UNLOCK(hadc);
 802d914:	2300      	movs	r3, #0
 802d916:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54

  return tmp_hal_status;
}
 802d91a:	b003      	add	sp, #12
 802d91c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        else if ((pConfig->Channel == ADC_CHANNEL_VREFINT) &&
 802d91e:	4823      	ldr	r0, [pc, #140]	; (802d9ac <HAL_ADC_ConfigChannel+0x1a0>)
 802d920:	4282      	cmp	r2, r0
 802d922:	d1a4      	bne.n	802d86e <HAL_ADC_ConfigChannel+0x62>
 802d924:	f413 0080 	ands.w	r0, r3, #4194304	; 0x400000
 802d928:	d1a1      	bne.n	802d86e <HAL_ADC_ConfigChannel+0x62>
 802d92a:	680b      	ldr	r3, [r1, #0]
 802d92c:	f023 73e0 	bic.w	r3, r3, #29360128	; 0x1c00000
 802d930:	432b      	orrs	r3, r5
 802d932:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 802d936:	e7ec      	b.n	802d912 <HAL_ADC_ConfigChannel+0x106>
      if ((hadc->Init.ScanConvMode == ADC_SCAN_SEQ_FIXED)       ||
 802d938:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 802d93c:	d106      	bne.n	802d94c <HAL_ADC_ConfigChannel+0x140>
        LL_ADC_REG_SetSequencerChRem(hadc->Instance, pConfig->Channel);
 802d93e:	6821      	ldr	r1, [r4, #0]
  CLEAR_BIT(ADCx->CHSELR, (Channel & ADC_CHANNEL_ID_BITFIELD_MASK));
 802d940:	6a8b      	ldr	r3, [r1, #40]	; 0x28
 802d942:	f3c2 0011 	ubfx	r0, r2, #0, #18
 802d946:	ea23 0300 	bic.w	r3, r3, r0
 802d94a:	628b      	str	r3, [r1, #40]	; 0x28
      if (__LL_ADC_IS_CHANNEL_INTERNAL(pConfig->Channel))
 802d94c:	2a00      	cmp	r2, #0
 802d94e:	da8e      	bge.n	802d86e <HAL_ADC_ConfigChannel+0x62>
        if (pConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 802d950:	4812      	ldr	r0, [pc, #72]	; (802d99c <HAL_ADC_ConfigChannel+0x190>)
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 802d952:	4911      	ldr	r1, [pc, #68]	; (802d998 <HAL_ADC_ConfigChannel+0x18c>)
 802d954:	4282      	cmp	r2, r0
 802d956:	680b      	ldr	r3, [r1, #0]
 802d958:	d107      	bne.n	802d96a <HAL_ADC_ConfigChannel+0x15e>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 802d95a:	680a      	ldr	r2, [r1, #0]
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 802d95c:	f003 73a0 	and.w	r3, r3, #20971520	; 0x1400000
 802d960:	f022 72e0 	bic.w	r2, r2, #29360128	; 0x1c00000
 802d964:	4313      	orrs	r3, r2
 802d966:	600b      	str	r3, [r1, #0]
 802d968:	e781      	b.n	802d86e <HAL_ADC_ConfigChannel+0x62>
        else if (pConfig->Channel == ADC_CHANNEL_VBAT)
 802d96a:	480f      	ldr	r0, [pc, #60]	; (802d9a8 <HAL_ADC_ConfigChannel+0x19c>)
 802d96c:	4282      	cmp	r2, r0
 802d96e:	d103      	bne.n	802d978 <HAL_ADC_ConfigChannel+0x16c>
 802d970:	680a      	ldr	r2, [r1, #0]
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 802d972:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
 802d976:	e7f3      	b.n	802d960 <HAL_ADC_ConfigChannel+0x154>
        else if (pConfig->Channel == ADC_CHANNEL_VREFINT)
 802d978:	480c      	ldr	r0, [pc, #48]	; (802d9ac <HAL_ADC_ConfigChannel+0x1a0>)
 802d97a:	4282      	cmp	r2, r0
 802d97c:	f47f af77 	bne.w	802d86e <HAL_ADC_ConfigChannel+0x62>
 802d980:	680a      	ldr	r2, [r1, #0]
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 802d982:	f003 73c0 	and.w	r3, r3, #25165824	; 0x1800000
 802d986:	e7eb      	b.n	802d960 <HAL_ADC_ConfigChannel+0x154>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 802d988:	6da2      	ldr	r2, [r4, #88]	; 0x58
 802d98a:	f042 0220 	orr.w	r2, r2, #32
 802d98e:	65a2      	str	r2, [r4, #88]	; 0x58
    tmp_hal_status = HAL_ERROR;
 802d990:	4618      	mov	r0, r3
 802d992:	e7bf      	b.n	802d914 <HAL_ADC_ConfigChannel+0x108>
  __HAL_LOCK(hadc);
 802d994:	2002      	movs	r0, #2
 802d996:	e7c0      	b.n	802d91a <HAL_ADC_ConfigChannel+0x10e>
 802d998:	40012708 	.word	0x40012708
 802d99c:	b0001000 	.word	0xb0001000
 802d9a0:	00030d40 	.word	0x00030d40
 802d9a4:	2000344c 	.word	0x2000344c
 802d9a8:	b8004000 	.word	0xb8004000
 802d9ac:	b4002000 	.word	0xb4002000

0802d9b0 <ADC_ConversionStop>:
  *         stopped to disable the ADC.
  * @param  hadc ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_ConversionStop(ADC_HandleTypeDef *hadc)
{
 802d9b0:	b538      	push	{r3, r4, r5, lr}
 802d9b2:	4604      	mov	r4, r0
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  /* Verification if ADC is not already stopped on regular group to bypass    */
  /* this function if not needed.                                             */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) != 0UL)
 802d9b4:	6800      	ldr	r0, [r0, #0]
 802d9b6:	f7ff fda3 	bl	802d500 <LL_ADC_REG_IsConversionOngoing>
 802d9ba:	b908      	cbnz	r0, 802d9c0 <ADC_ConversionStop+0x10>
    }

  }

  /* Return HAL status */
  return HAL_OK;
 802d9bc:	2000      	movs	r0, #0
}
 802d9be:	bd38      	pop	{r3, r4, r5, pc}
    if (LL_ADC_IsDisableOngoing(hadc->Instance) == 0UL)
 802d9c0:	6822      	ldr	r2, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADDIS) == (ADC_CR_ADDIS)) ? 1UL : 0UL);
 802d9c2:	6893      	ldr	r3, [r2, #8]
 802d9c4:	0799      	lsls	r1, r3, #30
 802d9c6:	d407      	bmi.n	802d9d8 <ADC_ConversionStop+0x28>
  MODIFY_REG(ADCx->CR,
 802d9c8:	6893      	ldr	r3, [r2, #8]
 802d9ca:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802d9ce:	f023 0317 	bic.w	r3, r3, #23
 802d9d2:	f043 0310 	orr.w	r3, r3, #16
 802d9d6:	6093      	str	r3, [r2, #8]
    tickstart = HAL_GetTick();
 802d9d8:	f7fe fe34 	bl	802c644 <HAL_GetTick>
 802d9dc:	4605      	mov	r5, r0
    while ((hadc->Instance->CR & ADC_CR_ADSTART) != 0UL)
 802d9de:	6823      	ldr	r3, [r4, #0]
 802d9e0:	689b      	ldr	r3, [r3, #8]
 802d9e2:	075b      	lsls	r3, r3, #29
 802d9e4:	d5ea      	bpl.n	802d9bc <ADC_ConversionStop+0xc>
      if ((HAL_GetTick() - tickstart) > ADC_STOP_CONVERSION_TIMEOUT)
 802d9e6:	f7fe fe2d 	bl	802c644 <HAL_GetTick>
 802d9ea:	1b40      	subs	r0, r0, r5
 802d9ec:	2802      	cmp	r0, #2
 802d9ee:	d9f6      	bls.n	802d9de <ADC_ConversionStop+0x2e>
        if ((hadc->Instance->CR & ADC_CR_ADSTART) != 0UL)
 802d9f0:	6823      	ldr	r3, [r4, #0]
 802d9f2:	689b      	ldr	r3, [r3, #8]
 802d9f4:	075a      	lsls	r2, r3, #29
 802d9f6:	d5f2      	bpl.n	802d9de <ADC_ConversionStop+0x2e>
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 802d9f8:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802d9fa:	f043 0310 	orr.w	r3, r3, #16
 802d9fe:	65a3      	str	r3, [r4, #88]	; 0x58
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 802da00:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 802da02:	f043 0301 	orr.w	r3, r3, #1
 802da06:	65e3      	str	r3, [r4, #92]	; 0x5c
 802da08:	2001      	movs	r0, #1
 802da0a:	e7d8      	b.n	802d9be <ADC_ConversionStop+0xe>

0802da0c <ADC_Enable>:
  *         and voltage regulator must be enabled (done into HAL_ADC_Init()).
  * @param hadc ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_Enable(ADC_HandleTypeDef *hadc)
{
 802da0c:	b573      	push	{r0, r1, r4, r5, r6, lr}
  uint32_t tickstart;
  __IO uint32_t wait_loop_index = 0UL;
 802da0e:	2300      	movs	r3, #0

  /* ADC enable and wait for ADC ready (in case of ADC is disabled or         */
  /* enabling phase not yet completed: flag ADC ready not yet set).           */
  /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
  /* causes: ADC clock not running, ...).                                     */
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 802da10:	6802      	ldr	r2, [r0, #0]
  __IO uint32_t wait_loop_index = 0UL;
 802da12:	9301      	str	r3, [sp, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 802da14:	6893      	ldr	r3, [r2, #8]
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 802da16:	07dd      	lsls	r5, r3, #31
{
 802da18:	4604      	mov	r4, r0
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 802da1a:	d502      	bpl.n	802da22 <ADC_Enable+0x16>
      }
    }
  }

  /* Return HAL status */
  return HAL_OK;
 802da1c:	2000      	movs	r0, #0
}
 802da1e:	b002      	add	sp, #8
 802da20:	bd70      	pop	{r4, r5, r6, pc}
    if ((hadc->Instance->CR & (ADC_CR_ADCAL | ADC_CR_ADSTP | ADC_CR_ADSTART | ADC_CR_ADDIS | ADC_CR_ADEN)) != 0UL)
 802da22:	6891      	ldr	r1, [r2, #8]
 802da24:	4b21      	ldr	r3, [pc, #132]	; (802daac <ADC_Enable+0xa0>)
 802da26:	4219      	tst	r1, r3
 802da28:	d009      	beq.n	802da3e <ADC_Enable+0x32>
            SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 802da2a:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802da2c:	f043 0310 	orr.w	r3, r3, #16
 802da30:	65a3      	str	r3, [r4, #88]	; 0x58
            SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 802da32:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 802da34:	f043 0301 	orr.w	r3, r3, #1
 802da38:	65e3      	str	r3, [r4, #92]	; 0x5c
            return HAL_ERROR;
 802da3a:	2001      	movs	r0, #1
 802da3c:	e7ef      	b.n	802da1e <ADC_Enable+0x12>
  MODIFY_REG(ADCx->CR,
 802da3e:	6893      	ldr	r3, [r2, #8]
 802da40:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802da44:	f023 0317 	bic.w	r3, r3, #23
 802da48:	f043 0301 	orr.w	r3, r3, #1
 802da4c:	6093      	str	r3, [r2, #8]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 802da4e:	4b18      	ldr	r3, [pc, #96]	; (802dab0 <ADC_Enable+0xa4>)
 802da50:	681b      	ldr	r3, [r3, #0]
    if ((LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) & LL_ADC_PATH_INTERNAL_TEMPSENSOR) != 0UL)
 802da52:	0218      	lsls	r0, r3, #8
 802da54:	d41c      	bmi.n	802da90 <ADC_Enable+0x84>
    if (hadc->Init.LowPowerAutoPowerOff != ENABLE)
 802da56:	7e63      	ldrb	r3, [r4, #25]
 802da58:	2b01      	cmp	r3, #1
 802da5a:	d0df      	beq.n	802da1c <ADC_Enable+0x10>
      tickstart = HAL_GetTick();
 802da5c:	f7fe fdf2 	bl	802c644 <HAL_GetTick>
  MODIFY_REG(ADCx->CR,
 802da60:	4e14      	ldr	r6, [pc, #80]	; (802dab4 <ADC_Enable+0xa8>)
 802da62:	4605      	mov	r5, r0
      while (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
 802da64:	6822      	ldr	r2, [r4, #0]
 802da66:	6813      	ldr	r3, [r2, #0]
 802da68:	07db      	lsls	r3, r3, #31
 802da6a:	d4d7      	bmi.n	802da1c <ADC_Enable+0x10>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 802da6c:	6893      	ldr	r3, [r2, #8]
        if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 802da6e:	07d9      	lsls	r1, r3, #31
  MODIFY_REG(ADCx->CR,
 802da70:	bf5f      	itttt	pl
 802da72:	6893      	ldrpl	r3, [r2, #8]
 802da74:	4033      	andpl	r3, r6
 802da76:	f043 0301 	orrpl.w	r3, r3, #1
 802da7a:	6093      	strpl	r3, [r2, #8]
        if ((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
 802da7c:	f7fe fde2 	bl	802c644 <HAL_GetTick>
 802da80:	1b40      	subs	r0, r0, r5
 802da82:	2802      	cmp	r0, #2
 802da84:	d9ee      	bls.n	802da64 <ADC_Enable+0x58>
          if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
 802da86:	6823      	ldr	r3, [r4, #0]
 802da88:	681b      	ldr	r3, [r3, #0]
 802da8a:	07da      	lsls	r2, r3, #31
 802da8c:	d4ea      	bmi.n	802da64 <ADC_Enable+0x58>
 802da8e:	e7cc      	b.n	802da2a <ADC_Enable+0x1e>
      wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_BUFFER_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 802da90:	4b09      	ldr	r3, [pc, #36]	; (802dab8 <ADC_Enable+0xac>)
 802da92:	4a0a      	ldr	r2, [pc, #40]	; (802dabc <ADC_Enable+0xb0>)
 802da94:	681b      	ldr	r3, [r3, #0]
 802da96:	fbb3 f3f2 	udiv	r3, r3, r2
 802da9a:	3301      	adds	r3, #1
        wait_loop_index--;
 802da9c:	9301      	str	r3, [sp, #4]
      while (wait_loop_index != 0UL)
 802da9e:	9b01      	ldr	r3, [sp, #4]
 802daa0:	2b00      	cmp	r3, #0
 802daa2:	d0d8      	beq.n	802da56 <ADC_Enable+0x4a>
        wait_loop_index--;
 802daa4:	9b01      	ldr	r3, [sp, #4]
 802daa6:	3b01      	subs	r3, #1
 802daa8:	e7f8      	b.n	802da9c <ADC_Enable+0x90>
 802daaa:	bf00      	nop
 802daac:	80000017 	.word	0x80000017
 802dab0:	40012708 	.word	0x40012708
 802dab4:	7fffffe8 	.word	0x7fffffe8
 802dab8:	2000344c 	.word	0x2000344c
 802dabc:	00030d40 	.word	0x00030d40

0802dac0 <HAL_ADC_Start>:
{
 802dac0:	b538      	push	{r3, r4, r5, lr}
 802dac2:	4604      	mov	r4, r0
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 802dac4:	6800      	ldr	r0, [r0, #0]
 802dac6:	f7ff fd1b 	bl	802d500 <LL_ADC_REG_IsConversionOngoing>
 802daca:	4605      	mov	r5, r0
 802dacc:	bb20      	cbnz	r0, 802db18 <HAL_ADC_Start+0x58>
    __HAL_LOCK(hadc);
 802dace:	f894 3054 	ldrb.w	r3, [r4, #84]	; 0x54
 802dad2:	2b01      	cmp	r3, #1
 802dad4:	d020      	beq.n	802db18 <HAL_ADC_Start+0x58>
 802dad6:	2301      	movs	r3, #1
 802dad8:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54
    tmp_hal_status = ADC_Enable(hadc);
 802dadc:	4620      	mov	r0, r4
 802dade:	f7ff ff95 	bl	802da0c <ADC_Enable>
    if (tmp_hal_status == HAL_OK)
 802dae2:	b9b0      	cbnz	r0, 802db12 <HAL_ADC_Start+0x52>
      ADC_STATE_CLR_SET(hadc->State,
 802dae4:	6da3      	ldr	r3, [r4, #88]	; 0x58
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 802dae6:	6822      	ldr	r2, [r4, #0]
      ADC_STATE_CLR_SET(hadc->State,
 802dae8:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 802daec:	f023 0301 	bic.w	r3, r3, #1
 802daf0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 802daf4:	65a3      	str	r3, [r4, #88]	; 0x58
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 802daf6:	231c      	movs	r3, #28
      ADC_CLEAR_ERRORCODE(hadc);
 802daf8:	65e0      	str	r0, [r4, #92]	; 0x5c
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 802dafa:	6013      	str	r3, [r2, #0]
      __HAL_UNLOCK(hadc);
 802dafc:	f884 0054 	strb.w	r0, [r4, #84]	; 0x54
  MODIFY_REG(ADCx->CR,
 802db00:	6893      	ldr	r3, [r2, #8]
 802db02:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802db06:	f023 0317 	bic.w	r3, r3, #23
 802db0a:	f043 0304 	orr.w	r3, r3, #4
 802db0e:	6093      	str	r3, [r2, #8]
}
 802db10:	bd38      	pop	{r3, r4, r5, pc}
      __HAL_UNLOCK(hadc);
 802db12:	f884 5054 	strb.w	r5, [r4, #84]	; 0x54
 802db16:	e7fb      	b.n	802db10 <HAL_ADC_Start+0x50>
    tmp_hal_status = HAL_BUSY;
 802db18:	2002      	movs	r0, #2
 802db1a:	e7f9      	b.n	802db10 <HAL_ADC_Start+0x50>

0802db1c <ADC_Disable>:
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_Disable(ADC_HandleTypeDef *hadc)
{
  uint32_t tickstart;
  const uint32_t tmp_adc_is_disable_on_going = LL_ADC_IsDisableOngoing(hadc->Instance);
 802db1c:	6802      	ldr	r2, [r0, #0]
{
 802db1e:	b538      	push	{r3, r4, r5, lr}
  return ((READ_BIT(ADCx->CR, ADC_CR_ADDIS) == (ADC_CR_ADDIS)) ? 1UL : 0UL);
 802db20:	6893      	ldr	r3, [r2, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 802db22:	6891      	ldr	r1, [r2, #8]
 802db24:	4604      	mov	r4, r0

  /* Verification if ADC is not already disabled:                             */
  /* Note: forbidden to disable ADC (set bit ADC_CR_ADDIS) if ADC is already  */
  /*       disabled.                                                          */
  if ((LL_ADC_IsEnabled(hadc->Instance) != 0UL)
 802db26:	07c8      	lsls	r0, r1, #31
 802db28:	d401      	bmi.n	802db2e <ADC_Disable+0x12>
      }
    }
  }

  /* Return HAL status */
  return HAL_OK;
 802db2a:	2000      	movs	r0, #0
}
 802db2c:	bd38      	pop	{r3, r4, r5, pc}
      && (tmp_adc_is_disable_on_going == 0UL)
 802db2e:	0799      	lsls	r1, r3, #30
 802db30:	d4fb      	bmi.n	802db2a <ADC_Disable+0xe>
    if ((hadc->Instance->CR & (ADC_CR_ADSTART | ADC_CR_ADEN)) == ADC_CR_ADEN)
 802db32:	6893      	ldr	r3, [r2, #8]
 802db34:	f003 0305 	and.w	r3, r3, #5
 802db38:	2b01      	cmp	r3, #1
 802db3a:	d119      	bne.n	802db70 <ADC_Disable+0x54>
  MODIFY_REG(ADCx->CR,
 802db3c:	6893      	ldr	r3, [r2, #8]
 802db3e:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802db42:	f023 0317 	bic.w	r3, r3, #23
 802db46:	f043 0302 	orr.w	r3, r3, #2
 802db4a:	6093      	str	r3, [r2, #8]
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOSMP | ADC_FLAG_RDY));
 802db4c:	2303      	movs	r3, #3
 802db4e:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 802db50:	f7fe fd78 	bl	802c644 <HAL_GetTick>
 802db54:	4605      	mov	r5, r0
    while ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
 802db56:	6823      	ldr	r3, [r4, #0]
 802db58:	689b      	ldr	r3, [r3, #8]
 802db5a:	07db      	lsls	r3, r3, #31
 802db5c:	d5e5      	bpl.n	802db2a <ADC_Disable+0xe>
      if ((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
 802db5e:	f7fe fd71 	bl	802c644 <HAL_GetTick>
 802db62:	1b40      	subs	r0, r0, r5
 802db64:	2802      	cmp	r0, #2
 802db66:	d9f6      	bls.n	802db56 <ADC_Disable+0x3a>
        if ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
 802db68:	6823      	ldr	r3, [r4, #0]
 802db6a:	689b      	ldr	r3, [r3, #8]
 802db6c:	07da      	lsls	r2, r3, #31
 802db6e:	d5f2      	bpl.n	802db56 <ADC_Disable+0x3a>
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 802db70:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802db72:	f043 0310 	orr.w	r3, r3, #16
 802db76:	65a3      	str	r3, [r4, #88]	; 0x58
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 802db78:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 802db7a:	f043 0301 	orr.w	r3, r3, #1
 802db7e:	65e3      	str	r3, [r4, #92]	; 0x5c
          return HAL_ERROR;
 802db80:	2001      	movs	r0, #1
 802db82:	e7d3      	b.n	802db2c <ADC_Disable+0x10>

0802db84 <HAL_ADC_DeInit>:
{
 802db84:	b570      	push	{r4, r5, r6, lr}
  if (hadc == NULL)
 802db86:	4604      	mov	r4, r0
 802db88:	2800      	cmp	r0, #0
 802db8a:	d041      	beq.n	802dc10 <HAL_ADC_DeInit+0x8c>
  SET_BIT(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL);
 802db8c:	6d83      	ldr	r3, [r0, #88]	; 0x58
 802db8e:	f043 0302 	orr.w	r3, r3, #2
 802db92:	6583      	str	r3, [r0, #88]	; 0x58
  tmp_hal_status = ADC_ConversionStop(hadc);
 802db94:	f7ff ff0c 	bl	802d9b0 <ADC_ConversionStop>
  if (tmp_hal_status == HAL_OK)
 802db98:	4605      	mov	r5, r0
 802db9a:	b968      	cbnz	r0, 802dbb8 <HAL_ADC_DeInit+0x34>
    tmp_hal_status = ADC_Disable(hadc);
 802db9c:	4620      	mov	r0, r4
 802db9e:	f7ff ffbd 	bl	802db1c <ADC_Disable>
    if (tmp_hal_status == HAL_OK)
 802dba2:	4605      	mov	r5, r0
 802dba4:	b908      	cbnz	r0, 802dbaa <HAL_ADC_DeInit+0x26>
      hadc->State = HAL_ADC_STATE_READY;
 802dba6:	2301      	movs	r3, #1
 802dba8:	65a3      	str	r3, [r4, #88]	; 0x58
    LL_ADC_DisableInternalRegulator(hadc->Instance);
 802dbaa:	6822      	ldr	r2, [r4, #0]
  CLEAR_BIT(ADCx->CR, (ADC_CR_ADVREGEN | ADC_CR_BITS_PROPERTY_RS));
 802dbac:	6893      	ldr	r3, [r2, #8]
 802dbae:	f023 4310 	bic.w	r3, r3, #2415919104	; 0x90000000
 802dbb2:	f023 0317 	bic.w	r3, r3, #23
 802dbb6:	6093      	str	r3, [r2, #8]
  __HAL_ADC_DISABLE_IT(hadc, (ADC_IT_AWD3  | ADC_IT_AWD2 |
 802dbb8:	6823      	ldr	r3, [r4, #0]
 802dbba:	685a      	ldr	r2, [r3, #4]
 802dbbc:	f422 7267 	bic.w	r2, r2, #924	; 0x39c
 802dbc0:	f022 0203 	bic.w	r2, r2, #3
 802dbc4:	605a      	str	r2, [r3, #4]
  __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_AWD3  | ADC_FLAG_AWD2 |
 802dbc6:	f240 329f 	movw	r2, #927	; 0x39f
 802dbca:	601a      	str	r2, [r3, #0]
  hadc->Instance->CFGR1 &= ~(ADC_CFGR1_AWD1CH   | ADC_CFGR1_AWD1EN  | ADC_CFGR1_AWD1SGL | ADC_CFGR1_DISCEN |
 802dbcc:	68d9      	ldr	r1, [r3, #12]
 802dbce:	4a11      	ldr	r2, [pc, #68]	; (802dc14 <HAL_ADC_DeInit+0x90>)
 802dbd0:	400a      	ands	r2, r1
 802dbd2:	60da      	str	r2, [r3, #12]
  hadc->Instance->CFGR2 &= ~ADC_CFGR2_CKMODE;
 802dbd4:	691a      	ldr	r2, [r3, #16]
 802dbd6:	f022 4240 	bic.w	r2, r2, #3221225472	; 0xc0000000
 802dbda:	611a      	str	r2, [r3, #16]
  hadc->Instance->SMPR &= ~ADC_SMPR_SMP1;
 802dbdc:	695a      	ldr	r2, [r3, #20]
 802dbde:	f022 0207 	bic.w	r2, r2, #7
 802dbe2:	615a      	str	r2, [r3, #20]
  hadc->Instance->TR1 &= ~(ADC_TR1_HT1 | ADC_TR1_LT1);
 802dbe4:	6a1a      	ldr	r2, [r3, #32]
 802dbe6:	f002 22f0 	and.w	r2, r2, #4026593280	; 0xf000f000
 802dbea:	621a      	str	r2, [r3, #32]
  hadc->Instance->CHSELR &= ~(ADC_CHSELR_SQ_ALL);
 802dbec:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  ADC_COMMON->CCR &= ~(ADC_CCR_VBATEN | ADC_CCR_TSEN | ADC_CCR_VREFEN | ADC_CCR_PRESC);
 802dbee:	4a0a      	ldr	r2, [pc, #40]	; (802dc18 <HAL_ADC_DeInit+0x94>)
  hadc->Instance->CHSELR &= ~(ADC_CHSELR_SQ_ALL);
 802dbf0:	2600      	movs	r6, #0
 802dbf2:	629e      	str	r6, [r3, #40]	; 0x28
  ADC_COMMON->CCR &= ~(ADC_CCR_VBATEN | ADC_CCR_TSEN | ADC_CCR_VREFEN | ADC_CCR_PRESC);
 802dbf4:	6813      	ldr	r3, [r2, #0]
 802dbf6:	f023 73fe 	bic.w	r3, r3, #33292288	; 0x1fc0000
 802dbfa:	6013      	str	r3, [r2, #0]
  HAL_ADC_MspDeInit(hadc);
 802dbfc:	4620      	mov	r0, r4
 802dbfe:	f7fe f95b 	bl	802beb8 <HAL_ADC_MspDeInit>
  ADC_CLEAR_ERRORCODE(hadc);
 802dc02:	65e6      	str	r6, [r4, #92]	; 0x5c
  hadc->ADCGroupRegularSequencerRanks = 0x00000000UL;
 802dc04:	6626      	str	r6, [r4, #96]	; 0x60
  hadc->State = HAL_ADC_STATE_RESET;
 802dc06:	65a6      	str	r6, [r4, #88]	; 0x58
  __HAL_UNLOCK(hadc);
 802dc08:	f884 6054 	strb.w	r6, [r4, #84]	; 0x54
}
 802dc0c:	4628      	mov	r0, r5
 802dc0e:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
 802dc10:	2501      	movs	r5, #1
 802dc12:	e7fb      	b.n	802dc0c <HAL_ADC_DeInit+0x88>
 802dc14:	833e0200 	.word	0x833e0200
 802dc18:	40012708 	.word	0x40012708

0802dc1c <HAL_ADC_Stop>:
{
 802dc1c:	b510      	push	{r4, lr}
  __HAL_LOCK(hadc);
 802dc1e:	f890 3054 	ldrb.w	r3, [r0, #84]	; 0x54
 802dc22:	2b01      	cmp	r3, #1
{
 802dc24:	4604      	mov	r4, r0
  __HAL_LOCK(hadc);
 802dc26:	d015      	beq.n	802dc54 <HAL_ADC_Stop+0x38>
 802dc28:	2301      	movs	r3, #1
 802dc2a:	f880 3054 	strb.w	r3, [r0, #84]	; 0x54
  tmp_hal_status = ADC_ConversionStop(hadc);
 802dc2e:	f7ff febf 	bl	802d9b0 <ADC_ConversionStop>
  if (tmp_hal_status == HAL_OK)
 802dc32:	b958      	cbnz	r0, 802dc4c <HAL_ADC_Stop+0x30>
    tmp_hal_status = ADC_Disable(hadc);
 802dc34:	4620      	mov	r0, r4
 802dc36:	f7ff ff71 	bl	802db1c <ADC_Disable>
    if (tmp_hal_status == HAL_OK)
 802dc3a:	b938      	cbnz	r0, 802dc4c <HAL_ADC_Stop+0x30>
      ADC_STATE_CLR_SET(hadc->State,
 802dc3c:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802dc3e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 802dc42:	f023 0301 	bic.w	r3, r3, #1
 802dc46:	f043 0301 	orr.w	r3, r3, #1
 802dc4a:	65a3      	str	r3, [r4, #88]	; 0x58
  __HAL_UNLOCK(hadc);
 802dc4c:	2300      	movs	r3, #0
 802dc4e:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54
}
 802dc52:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hadc);
 802dc54:	2002      	movs	r0, #2
 802dc56:	e7fc      	b.n	802dc52 <HAL_ADC_Stop+0x36>

0802dc58 <HAL_ADCEx_Calibration_Start>:
  *         HAL_ADC_GetValue() (value on 7 bits: from DR[6;0]).
  * @param  hadc       ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef *hadc)
{
 802dc58:	b513      	push	{r0, r1, r4, lr}
  HAL_StatusTypeDef tmp_hal_status;
  __IO uint32_t wait_loop_index = 0UL;
 802dc5a:	2300      	movs	r3, #0
 802dc5c:	9301      	str	r3, [sp, #4]
  uint32_t backup_setting_adc_dma_transfer; /* Note: Variable not declared as volatile because register read is already declared as volatile */

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  __HAL_LOCK(hadc);
 802dc5e:	f890 3054 	ldrb.w	r3, [r0, #84]	; 0x54
 802dc62:	2b01      	cmp	r3, #1
{
 802dc64:	4604      	mov	r4, r0
  __HAL_LOCK(hadc);
 802dc66:	d040      	beq.n	802dcea <HAL_ADCEx_Calibration_Start+0x92>
 802dc68:	2301      	movs	r3, #1
 802dc6a:	f880 3054 	strb.w	r3, [r0, #84]	; 0x54

  /* Calibration prerequisite: ADC must be disabled. */

  /* Disable the ADC (if not already disabled) */
  tmp_hal_status = ADC_Disable(hadc);
 802dc6e:	f7ff ff55 	bl	802db1c <ADC_Disable>

  /* Check if ADC is effectively disabled */
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 802dc72:	6823      	ldr	r3, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 802dc74:	689a      	ldr	r2, [r3, #8]
 802dc76:	07d2      	lsls	r2, r2, #31
 802dc78:	d433      	bmi.n	802dce2 <HAL_ADCEx_Calibration_Start+0x8a>
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 802dc7a:	6da2      	ldr	r2, [r4, #88]	; 0x58
 802dc7c:	f422 7281 	bic.w	r2, r2, #258	; 0x102
 802dc80:	f042 0202 	orr.w	r2, r2, #2
 802dc84:	65a2      	str	r2, [r4, #88]	; 0x58
    /* Note: Specificity of this STM32 series: Calibration factor is          */
    /*       available in data register and also transferred by DMA.          */
    /*       To not insert ADC calibration factor among ADC conversion data   */
    /*       in array variable, DMA transfer must be disabled during          */
    /*       calibration.                                                     */
    backup_setting_adc_dma_transfer = READ_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 802dc86:	68d9      	ldr	r1, [r3, #12]
    CLEAR_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 802dc88:	68da      	ldr	r2, [r3, #12]
 802dc8a:	f022 0203 	bic.w	r2, r2, #3
 802dc8e:	60da      	str	r2, [r3, #12]

    /* Start ADC calibration */
    SET_BIT(hadc->Instance->CR, ADC_CR_ADCAL);
 802dc90:	689a      	ldr	r2, [r3, #8]
 802dc92:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
    backup_setting_adc_dma_transfer = READ_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 802dc96:	f001 0103 	and.w	r1, r1, #3
    SET_BIT(hadc->Instance->CR, ADC_CR_ADCAL);
 802dc9a:	609a      	str	r2, [r3, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADCAL) == (ADC_CR_ADCAL)) ? 1UL : 0UL);
 802dc9c:	689a      	ldr	r2, [r3, #8]
 802dc9e:	2a00      	cmp	r2, #0
 802dca0:	da12      	bge.n	802dcc8 <HAL_ADCEx_Calibration_Start+0x70>

    /* Wait for calibration completion */
    while (LL_ADC_IsCalibrationOnGoing(hadc->Instance) != 0UL)
    {
      wait_loop_index++;
 802dca2:	9a01      	ldr	r2, [sp, #4]
 802dca4:	3201      	adds	r2, #1
 802dca6:	9201      	str	r2, [sp, #4]
      if (wait_loop_index >= ADC_CALIBRATION_TIMEOUT)
 802dca8:	9a01      	ldr	r2, [sp, #4]
 802dcaa:	f5b2 3f2e 	cmp.w	r2, #178176	; 0x2b800
 802dcae:	d3f5      	bcc.n	802dc9c <HAL_ADCEx_Calibration_Start+0x44>
      {
        /* Update ADC state machine to error */
        ADC_STATE_CLR_SET(hadc->State,
 802dcb0:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802dcb2:	f023 0312 	bic.w	r3, r3, #18
 802dcb6:	f043 0310 	orr.w	r3, r3, #16
 802dcba:	65a3      	str	r3, [r4, #88]	; 0x58
                          HAL_ADC_STATE_BUSY_INTERNAL,
                          HAL_ADC_STATE_ERROR_INTERNAL);

        __HAL_UNLOCK(hadc);
 802dcbc:	2300      	movs	r3, #0
 802dcbe:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54

        return HAL_ERROR;
 802dcc2:	2001      	movs	r0, #1
  }

  __HAL_UNLOCK(hadc);

  return tmp_hal_status;
}
 802dcc4:	b002      	add	sp, #8
 802dcc6:	bd10      	pop	{r4, pc}
    SET_BIT(hadc->Instance->CFGR1, backup_setting_adc_dma_transfer);
 802dcc8:	68da      	ldr	r2, [r3, #12]
 802dcca:	430a      	orrs	r2, r1
 802dccc:	60da      	str	r2, [r3, #12]
    ADC_STATE_CLR_SET(hadc->State,
 802dcce:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802dcd0:	f023 0303 	bic.w	r3, r3, #3
 802dcd4:	f043 0301 	orr.w	r3, r3, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 802dcd8:	65a3      	str	r3, [r4, #88]	; 0x58
  __HAL_UNLOCK(hadc);
 802dcda:	2300      	movs	r3, #0
 802dcdc:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54
  return tmp_hal_status;
 802dce0:	e7f0      	b.n	802dcc4 <HAL_ADCEx_Calibration_Start+0x6c>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 802dce2:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802dce4:	f043 0310 	orr.w	r3, r3, #16
 802dce8:	e7f6      	b.n	802dcd8 <HAL_ADCEx_Calibration_Start+0x80>
  __HAL_LOCK(hadc);
 802dcea:	2002      	movs	r0, #2
 802dcec:	e7ea      	b.n	802dcc4 <HAL_ADCEx_Calibration_Start+0x6c>
	...

0802dcf0 <HAL_NVIC_SetPriorityGrouping>:
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 802dcf0:	4907      	ldr	r1, [pc, #28]	; (802dd10 <HAL_NVIC_SetPriorityGrouping+0x20>)
 802dcf2:	68ca      	ldr	r2, [r1, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 802dcf4:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 802dcf8:	0203      	lsls	r3, r0, #8
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 802dcfa:	0412      	lsls	r2, r2, #16
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 802dcfc:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 802dd00:	0c12      	lsrs	r2, r2, #16
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 802dd02:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 802dd04:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 802dd08:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  SCB->AIRCR =  reg_value;
 802dd0c:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 802dd0e:	4770      	bx	lr
 802dd10:	e000ed00 	.word	0xe000ed00

0802dd14 <HAL_NVIC_SetPriority>:
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 802dd14:	4b16      	ldr	r3, [pc, #88]	; (802dd70 <HAL_NVIC_SetPriority+0x5c>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 802dd16:	b530      	push	{r4, r5, lr}
 802dd18:	68dc      	ldr	r4, [r3, #12]
 802dd1a:	f3c4 2402 	ubfx	r4, r4, #8, #3
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 802dd1e:	f1c4 0307 	rsb	r3, r4, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 802dd22:	1d25      	adds	r5, r4, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 802dd24:	2b04      	cmp	r3, #4
 802dd26:	bf28      	it	cs
 802dd28:	2304      	movcs	r3, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 802dd2a:	2d06      	cmp	r5, #6
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 802dd2c:	f04f 35ff 	mov.w	r5, #4294967295
 802dd30:	fa05 f303 	lsl.w	r3, r5, r3
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 802dd34:	bf8c      	ite	hi
 802dd36:	3c03      	subhi	r4, #3
 802dd38:	2400      	movls	r4, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 802dd3a:	ea21 0303 	bic.w	r3, r1, r3
 802dd3e:	40a3      	lsls	r3, r4
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 802dd40:	fa05 f404 	lsl.w	r4, r5, r4
 802dd44:	ea22 0204 	bic.w	r2, r2, r4
  if ((int32_t)(IRQn) >= 0)
 802dd48:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 802dd4a:	ea43 0302 	orr.w	r3, r3, r2
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802dd4e:	bfac      	ite	ge
 802dd50:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802dd54:	4a07      	ldrlt	r2, [pc, #28]	; (802dd74 <HAL_NVIC_SetPriority+0x60>)
 802dd56:	ea4f 1303 	mov.w	r3, r3, lsl #4
 802dd5a:	bfb8      	it	lt
 802dd5c:	f000 000f 	andlt.w	r0, r0, #15
 802dd60:	b2db      	uxtb	r3, r3
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802dd62:	bfaa      	itet	ge
 802dd64:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802dd68:	5413      	strblt	r3, [r2, r0]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802dd6a:	f880 3300 	strbge.w	r3, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 802dd6e:	bd30      	pop	{r4, r5, pc}
 802dd70:	e000ed00 	.word	0xe000ed00
 802dd74:	e000ed14 	.word	0xe000ed14

0802dd78 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 802dd78:	2800      	cmp	r0, #0
 802dd7a:	db08      	blt.n	802dd8e <HAL_NVIC_EnableIRQ+0x16>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 802dd7c:	2301      	movs	r3, #1
 802dd7e:	0942      	lsrs	r2, r0, #5
 802dd80:	f000 001f 	and.w	r0, r0, #31
 802dd84:	fa03 f000 	lsl.w	r0, r3, r0
 802dd88:	4b01      	ldr	r3, [pc, #4]	; (802dd90 <HAL_NVIC_EnableIRQ+0x18>)
 802dd8a:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 802dd8e:	4770      	bx	lr
 802dd90:	e000e100 	.word	0xe000e100

0802dd94 <HAL_NVIC_DisableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 802dd94:	2800      	cmp	r0, #0
 802dd96:	db0d      	blt.n	802ddb4 <HAL_NVIC_DisableIRQ+0x20>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 802dd98:	0943      	lsrs	r3, r0, #5
 802dd9a:	2201      	movs	r2, #1
 802dd9c:	f000 001f 	and.w	r0, r0, #31
 802dda0:	fa02 f000 	lsl.w	r0, r2, r0
 802dda4:	3320      	adds	r3, #32
 802dda6:	4a04      	ldr	r2, [pc, #16]	; (802ddb8 <HAL_NVIC_DisableIRQ+0x24>)
 802dda8:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
 802ddac:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 802ddb0:	f3bf 8f6f 	isb	sy
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
}
 802ddb4:	4770      	bx	lr
 802ddb6:	bf00      	nop
 802ddb8:	e000e100 	.word	0xe000e100

0802ddbc <DMA_SetConfig>:
  * @param DstAddress The destination memory Buffer address
  * @param DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 802ddbc:	b570      	push	{r4, r5, r6, lr}
  /* Clear the DMAMUX synchro overrun flag */
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 802ddbe:	e9d0 4513 	ldrd	r4, r5, [r0, #76]	; 0x4c
 802ddc2:	6065      	str	r5, [r4, #4]

  if (hdma->DMAmuxRequestGen != 0U)
 802ddc4:	6d44      	ldr	r4, [r0, #84]	; 0x54
 802ddc6:	b114      	cbz	r4, 802ddce <DMA_SetConfig+0x12>
  {
    /* Clear the DMAMUX request generator overrun flag */
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 802ddc8:	e9d0 4516 	ldrd	r4, r5, [r0, #88]	; 0x58
 802ddcc:	6065      	str	r5, [r4, #4]
  }

  /* Clear all flags */
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 802ddce:	e9d0 5410 	ldrd	r5, r4, [r0, #64]	; 0x40
 802ddd2:	f004 061c 	and.w	r6, r4, #28
 802ddd6:	2401      	movs	r4, #1
 802ddd8:	40b4      	lsls	r4, r6
 802ddda:	606c      	str	r4, [r5, #4]

  /* Configure DMA Channel data length */
  hdma->Instance->CNDTR = DataLength;
 802dddc:	6804      	ldr	r4, [r0, #0]
 802ddde:	6063      	str	r3, [r4, #4]

  /* Memory to Peripheral */
  if ((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 802dde0:	6883      	ldr	r3, [r0, #8]
 802dde2:	2b10      	cmp	r3, #16
  {
    /* Configure DMA Channel destination address */
    hdma->Instance->CPAR = DstAddress;
 802dde4:	bf0b      	itete	eq
 802dde6:	60a2      	streq	r2, [r4, #8]
  }
  /* Peripheral to Memory */
  else
  {
    /* Configure DMA Channel source address */
    hdma->Instance->CPAR = SrcAddress;
 802dde8:	60a1      	strne	r1, [r4, #8]
    hdma->Instance->CMAR = SrcAddress;
 802ddea:	60e1      	streq	r1, [r4, #12]

    /* Configure DMA Channel destination address */
    hdma->Instance->CMAR = DstAddress;
 802ddec:	60e2      	strne	r2, [r4, #12]
  }
}
 802ddee:	bd70      	pop	{r4, r5, r6, pc}

0802ddf0 <DMA_CalcDMAMUXChannelBaseAndMask>:
static void DMA_CalcDMAMUXChannelBaseAndMask(DMA_HandleTypeDef *hdma)
{
  uint32_t channel_number;

  /* check if instance is not outside the DMA channel range */
  if ((uint32_t)hdma->Instance < (uint32_t)DMA2_Channel1)
 802ddf0:	6802      	ldr	r2, [r0, #0]
 802ddf2:	6c41      	ldr	r1, [r0, #68]	; 0x44
 802ddf4:	b2d3      	uxtb	r3, r2
{
 802ddf6:	b510      	push	{r4, lr}
 802ddf8:	3b08      	subs	r3, #8
 802ddfa:	2414      	movs	r4, #20
 802ddfc:	fbb3 f3f4 	udiv	r3, r3, r4
  if ((uint32_t)hdma->Instance < (uint32_t)DMA2_Channel1)
 802de00:	4c0b      	ldr	r4, [pc, #44]	; (802de30 <DMA_CalcDMAMUXChannelBaseAndMask+0x40>)
 802de02:	42a2      	cmp	r2, r4
  }
  else
  {
    /* DMA2 */
    /* Associate a DMA Channel to a DMAMUX channel */
    hdma->DMAmuxChannel = (DMAMUX1_Channel7 + (hdma->ChannelIndex >> 2U));
 802de04:	bf88      	it	hi
 802de06:	4a0b      	ldrhi	r2, [pc, #44]	; (802de34 <DMA_CalcDMAMUXChannelBaseAndMask+0x44>)
 802de08:	f021 0103 	bic.w	r1, r1, #3
    hdma->DMAmuxChannel = (DMAMUX1_Channel0 + (hdma->ChannelIndex >> 2U));
 802de0c:	bf99      	ittee	ls
 802de0e:	f101 4280 	addls.w	r2, r1, #1073741824	; 0x40000000
 802de12:	f502 3202 	addls.w	r2, r2, #133120	; 0x20800
    hdma->DMAmuxChannel = (DMAMUX1_Channel7 + (hdma->ChannelIndex >> 2U));
 802de16:	1852      	addhi	r2, r2, r1

    /* Prepare channel_number used for DMAmuxChannelStatusMask computation */
    channel_number = (((((uint32_t)hdma->Instance & 0xFFU) - 8U) / 20U) + 7U);
 802de18:	3307      	addhi	r3, #7
 802de1a:	6482      	str	r2, [r0, #72]	; 0x48
  }

  /* Initialize the field DMAmuxChannelStatus to DMAMUX1_ChannelStatus base */
  hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
 802de1c:	4a06      	ldr	r2, [pc, #24]	; (802de38 <DMA_CalcDMAMUXChannelBaseAndMask+0x48>)
 802de1e:	64c2      	str	r2, [r0, #76]	; 0x4c

  /* Initialize the field DMAmuxChannelStatusMask with the corresponding index of the DMAMUX channel selected for the current ChannelIndex */
  hdma->DMAmuxChannelStatusMask = 1UL << (channel_number & 0x1FU);
 802de20:	f003 031f 	and.w	r3, r3, #31
 802de24:	2201      	movs	r2, #1
 802de26:	fa02 f303 	lsl.w	r3, r2, r3
 802de2a:	6503      	str	r3, [r0, #80]	; 0x50
}
 802de2c:	bd10      	pop	{r4, pc}
 802de2e:	bf00      	nop
 802de30:	40020407 	.word	0x40020407
 802de34:	4002081c 	.word	0x4002081c
 802de38:	40020880 	.word	0x40020880

0802de3c <HAL_DMA_Init>:
{
 802de3c:	b510      	push	{r4, lr}
  if (hdma == NULL)
 802de3e:	2800      	cmp	r0, #0
 802de40:	d060      	beq.n	802df04 <HAL_DMA_Init+0xc8>
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 802de42:	6802      	ldr	r2, [r0, #0]
 802de44:	4b30      	ldr	r3, [pc, #192]	; (802df08 <HAL_DMA_Init+0xcc>)
 802de46:	429a      	cmp	r2, r3
 802de48:	f04f 0414 	mov.w	r4, #20
 802de4c:	d84d      	bhi.n	802deea <HAL_DMA_Init+0xae>
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 802de4e:	492f      	ldr	r1, [pc, #188]	; (802df0c <HAL_DMA_Init+0xd0>)
 802de50:	4411      	add	r1, r2
 802de52:	fbb1 f1f4 	udiv	r1, r1, r4
 802de56:	0089      	lsls	r1, r1, #2
 802de58:	6441      	str	r1, [r0, #68]	; 0x44
    hdma->DmaBaseAddress = DMA1;
 802de5a:	f2a3 4307 	subw	r3, r3, #1031	; 0x407
    hdma->DmaBaseAddress = DMA2;
 802de5e:	6403      	str	r3, [r0, #64]	; 0x40
  hdma->State = HAL_DMA_STATE_BUSY;
 802de60:	2302      	movs	r3, #2
 802de62:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
  CLEAR_BIT(hdma->Instance->CCR, (DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 802de66:	6813      	ldr	r3, [r2, #0]
 802de68:	f423 43ff 	bic.w	r3, r3, #32640	; 0x7f80
 802de6c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 802de70:	6013      	str	r3, [r2, #0]
  SET_BIT(hdma->Instance->CCR, (hdma->Init.Direction           |                               \
 802de72:	e9d0 3402 	ldrd	r3, r4, [r0, #8]
 802de76:	4323      	orrs	r3, r4
 802de78:	6904      	ldr	r4, [r0, #16]
 802de7a:	6811      	ldr	r1, [r2, #0]
 802de7c:	4323      	orrs	r3, r4
 802de7e:	6944      	ldr	r4, [r0, #20]
 802de80:	4323      	orrs	r3, r4
 802de82:	6984      	ldr	r4, [r0, #24]
 802de84:	4323      	orrs	r3, r4
 802de86:	69c4      	ldr	r4, [r0, #28]
 802de88:	4323      	orrs	r3, r4
 802de8a:	6a04      	ldr	r4, [r0, #32]
 802de8c:	4323      	orrs	r3, r4
 802de8e:	430b      	orrs	r3, r1
 802de90:	6013      	str	r3, [r2, #0]
  DMA_CalcDMAMUXChannelBaseAndMask(hdma);
 802de92:	f7ff ffad 	bl	802ddf0 <DMA_CalcDMAMUXChannelBaseAndMask>
  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 802de96:	6883      	ldr	r3, [r0, #8]
  hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 802de98:	6c81      	ldr	r1, [r0, #72]	; 0x48
  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 802de9a:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
    hdma->Init.Request = DMA_REQUEST_MEM2MEM;
 802de9e:	bf04      	itt	eq
 802dea0:	2300      	moveq	r3, #0
 802dea2:	6043      	streq	r3, [r0, #4]
  hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 802dea4:	6842      	ldr	r2, [r0, #4]
 802dea6:	f002 037f 	and.w	r3, r2, #127	; 0x7f
 802deaa:	600b      	str	r3, [r1, #0]
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 802deac:	e9d0 1413 	ldrd	r1, r4, [r0, #76]	; 0x4c
  if (((hdma->Init.Request >  0UL) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 802deb0:	3a01      	subs	r2, #1
 802deb2:	2a03      	cmp	r2, #3
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 802deb4:	604c      	str	r4, [r1, #4]
  if (((hdma->Init.Request >  0UL) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 802deb6:	d820      	bhi.n	802defa <HAL_DMA_Init+0xbe>
static void DMA_CalcDMAMUXRequestGenBaseAndMask(DMA_HandleTypeDef *hdma)
{
  uint32_t request =  hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID;

  /* DMA Channels are connected to DMAMUX1 request generator blocks*/
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 802deb8:	4a15      	ldr	r2, [pc, #84]	; (802df10 <HAL_DMA_Init+0xd4>)

  hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
 802deba:	4c16      	ldr	r4, [pc, #88]	; (802df14 <HAL_DMA_Init+0xd8>)
 802debc:	6584      	str	r4, [r0, #88]	; 0x58
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 802debe:	441a      	add	r2, r3

  /* here "Request" is either DMA_REQUEST_GENERATOR0 to DMA_REQUEST_GENERATOR3, i.e. <= 4*/
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x3U);
 802dec0:	3b01      	subs	r3, #1
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 802dec2:	0092      	lsls	r2, r2, #2
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x3U);
 802dec4:	2101      	movs	r1, #1
 802dec6:	f003 0303 	and.w	r3, r3, #3
 802deca:	fa01 f303 	lsl.w	r3, r1, r3
    hdma->DMAmuxRequestGen->RGCR = 0U;
 802dece:	2100      	movs	r1, #0
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 802ded0:	6542      	str	r2, [r0, #84]	; 0x54
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x3U);
 802ded2:	65c3      	str	r3, [r0, #92]	; 0x5c
    hdma->DMAmuxRequestGen->RGCR = 0U;
 802ded4:	6011      	str	r1, [r2, #0]
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 802ded6:	6063      	str	r3, [r4, #4]
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 802ded8:	2300      	movs	r3, #0
  hdma->State = HAL_DMA_STATE_READY;
 802deda:	2201      	movs	r2, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 802dedc:	63c3      	str	r3, [r0, #60]	; 0x3c
  __HAL_UNLOCK(hdma);
 802dede:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
  hdma->State = HAL_DMA_STATE_READY;
 802dee2:	f880 2025 	strb.w	r2, [r0, #37]	; 0x25
  return HAL_OK;
 802dee6:	4618      	mov	r0, r3
}
 802dee8:	bd10      	pop	{r4, pc}
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2U;
 802deea:	4b0b      	ldr	r3, [pc, #44]	; (802df18 <HAL_DMA_Init+0xdc>)
 802deec:	4413      	add	r3, r2
 802deee:	fbb3 f3f4 	udiv	r3, r3, r4
 802def2:	009b      	lsls	r3, r3, #2
 802def4:	6443      	str	r3, [r0, #68]	; 0x44
    hdma->DmaBaseAddress = DMA2;
 802def6:	4b09      	ldr	r3, [pc, #36]	; (802df1c <HAL_DMA_Init+0xe0>)
 802def8:	e7b1      	b.n	802de5e <HAL_DMA_Init+0x22>
    hdma->DMAmuxRequestGen = 0U;
 802defa:	2300      	movs	r3, #0
    hdma->DMAmuxRequestGenStatus = 0U;
 802defc:	e9c0 3315 	strd	r3, r3, [r0, #84]	; 0x54
    hdma->DMAmuxRequestGenStatusMask = 0U;
 802df00:	65c3      	str	r3, [r0, #92]	; 0x5c
 802df02:	e7e9      	b.n	802ded8 <HAL_DMA_Init+0x9c>
    return HAL_ERROR;
 802df04:	2001      	movs	r0, #1
 802df06:	e7ef      	b.n	802dee8 <HAL_DMA_Init+0xac>
 802df08:	40020407 	.word	0x40020407
 802df0c:	bffdfff8 	.word	0xbffdfff8
 802df10:	1000823f 	.word	0x1000823f
 802df14:	40020940 	.word	0x40020940
 802df18:	bffdfbf8 	.word	0xbffdfbf8
 802df1c:	40020400 	.word	0x40020400

0802df20 <HAL_DMA_DeInit>:
{
 802df20:	b538      	push	{r3, r4, r5, lr}
  if (NULL == hdma)
 802df22:	2800      	cmp	r0, #0
 802df24:	d045      	beq.n	802dfb2 <HAL_DMA_DeInit+0x92>
  __HAL_DMA_DISABLE(hdma);
 802df26:	6801      	ldr	r1, [r0, #0]
 802df28:	680b      	ldr	r3, [r1, #0]
 802df2a:	f023 0301 	bic.w	r3, r3, #1
 802df2e:	600b      	str	r3, [r1, #0]
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 802df30:	4b21      	ldr	r3, [pc, #132]	; (802dfb8 <HAL_DMA_DeInit+0x98>)
 802df32:	4299      	cmp	r1, r3
 802df34:	f04f 0414 	mov.w	r4, #20
 802df38:	d833      	bhi.n	802dfa2 <HAL_DMA_DeInit+0x82>
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 802df3a:	4a20      	ldr	r2, [pc, #128]	; (802dfbc <HAL_DMA_DeInit+0x9c>)
 802df3c:	440a      	add	r2, r1
 802df3e:	fbb2 f2f4 	udiv	r2, r2, r4
 802df42:	0092      	lsls	r2, r2, #2
 802df44:	6442      	str	r2, [r0, #68]	; 0x44
    hdma->DmaBaseAddress = DMA1;
 802df46:	f2a3 4307 	subw	r3, r3, #1031	; 0x407
    hdma->DmaBaseAddress = DMA2;
 802df4a:	6403      	str	r3, [r0, #64]	; 0x40
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 802df4c:	e9d0 2310 	ldrd	r2, r3, [r0, #64]	; 0x40
 802df50:	2401      	movs	r4, #1
 802df52:	f003 031c 	and.w	r3, r3, #28
 802df56:	fa04 f303 	lsl.w	r3, r4, r3
  hdma->Instance->CCR = 0U;
 802df5a:	2500      	movs	r5, #0
 802df5c:	600d      	str	r5, [r1, #0]
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 802df5e:	6053      	str	r3, [r2, #4]
  DMA_CalcDMAMUXChannelBaseAndMask(hdma);
 802df60:	f7ff ff46 	bl	802ddf0 <DMA_CalcDMAMUXChannelBaseAndMask>
  hdma->DMAmuxChannel->CCR = 0U;
 802df64:	6c83      	ldr	r3, [r0, #72]	; 0x48
  if (((hdma->Init.Request >  0UL) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 802df66:	6841      	ldr	r1, [r0, #4]
  hdma->DMAmuxChannel->CCR = 0U;
 802df68:	601d      	str	r5, [r3, #0]
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 802df6a:	e9d0 3213 	ldrd	r3, r2, [r0, #76]	; 0x4c
 802df6e:	605a      	str	r2, [r3, #4]
  if (((hdma->Init.Request >  0UL) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 802df70:	1e4a      	subs	r2, r1, #1
 802df72:	2a03      	cmp	r2, #3
 802df74:	d806      	bhi.n	802df84 <HAL_DMA_DeInit+0x64>
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 802df76:	4b12      	ldr	r3, [pc, #72]	; (802dfc0 <HAL_DMA_DeInit+0xa0>)
 802df78:	440b      	add	r3, r1
 802df7a:	009b      	lsls	r3, r3, #2
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x3U);
 802df7c:	4094      	lsls	r4, r2
    hdma->DMAmuxRequestGen->RGCR = 0U;
 802df7e:	601d      	str	r5, [r3, #0]
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 802df80:	4b10      	ldr	r3, [pc, #64]	; (802dfc4 <HAL_DMA_DeInit+0xa4>)
 802df82:	605c      	str	r4, [r3, #4]
  hdma->DMAmuxRequestGen = 0U;
 802df84:	2300      	movs	r3, #0
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 802df86:	63c3      	str	r3, [r0, #60]	; 0x3c
  hdma->DMAmuxRequestGenStatus = 0U;
 802df88:	e9c0 3315 	strd	r3, r3, [r0, #84]	; 0x54
  hdma->XferHalfCpltCallback = NULL;
 802df8c:	e9c0 330b 	strd	r3, r3, [r0, #44]	; 0x2c
  hdma->XferAbortCallback = NULL;
 802df90:	e9c0 330d 	strd	r3, r3, [r0, #52]	; 0x34
  hdma->DMAmuxRequestGenStatusMask = 0U;
 802df94:	65c3      	str	r3, [r0, #92]	; 0x5c
  hdma->State = HAL_DMA_STATE_RESET;
 802df96:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
  __HAL_UNLOCK(hdma);
 802df9a:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
  return HAL_OK;
 802df9e:	4618      	mov	r0, r3
}
 802dfa0:	bd38      	pop	{r3, r4, r5, pc}
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2U;
 802dfa2:	4b09      	ldr	r3, [pc, #36]	; (802dfc8 <HAL_DMA_DeInit+0xa8>)
 802dfa4:	440b      	add	r3, r1
 802dfa6:	fbb3 f3f4 	udiv	r3, r3, r4
 802dfaa:	009b      	lsls	r3, r3, #2
 802dfac:	6443      	str	r3, [r0, #68]	; 0x44
    hdma->DmaBaseAddress = DMA2;
 802dfae:	4b07      	ldr	r3, [pc, #28]	; (802dfcc <HAL_DMA_DeInit+0xac>)
 802dfb0:	e7cb      	b.n	802df4a <HAL_DMA_DeInit+0x2a>
    return HAL_ERROR;
 802dfb2:	2001      	movs	r0, #1
 802dfb4:	e7f4      	b.n	802dfa0 <HAL_DMA_DeInit+0x80>
 802dfb6:	bf00      	nop
 802dfb8:	40020407 	.word	0x40020407
 802dfbc:	bffdfff8 	.word	0xbffdfff8
 802dfc0:	1000823f 	.word	0x1000823f
 802dfc4:	40020940 	.word	0x40020940
 802dfc8:	bffdfbf8 	.word	0xbffdfbf8
 802dfcc:	40020400 	.word	0x40020400

0802dfd0 <HAL_DMA_Start_IT>:
{
 802dfd0:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(hdma);
 802dfd2:	f890 5024 	ldrb.w	r5, [r0, #36]	; 0x24
 802dfd6:	2d01      	cmp	r5, #1
{
 802dfd8:	4604      	mov	r4, r0
  __HAL_LOCK(hdma);
 802dfda:	d03c      	beq.n	802e056 <HAL_DMA_Start_IT+0x86>
  if (hdma->State == HAL_DMA_STATE_READY)
 802dfdc:	f890 6025 	ldrb.w	r6, [r0, #37]	; 0x25
  __HAL_LOCK(hdma);
 802dfe0:	2501      	movs	r5, #1
  if (hdma->State == HAL_DMA_STATE_READY)
 802dfe2:	42ae      	cmp	r6, r5
  __HAL_LOCK(hdma);
 802dfe4:	f880 5024 	strb.w	r5, [r0, #36]	; 0x24
  if (hdma->State == HAL_DMA_STATE_READY)
 802dfe8:	f04f 0600 	mov.w	r6, #0
 802dfec:	d12d      	bne.n	802e04a <HAL_DMA_Start_IT+0x7a>
    hdma->State = HAL_DMA_STATE_BUSY;
 802dfee:	2502      	movs	r5, #2
 802dff0:	f880 5025 	strb.w	r5, [r0, #37]	; 0x25
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 802dff4:	63c6      	str	r6, [r0, #60]	; 0x3c
    __HAL_DMA_DISABLE(hdma);
 802dff6:	6806      	ldr	r6, [r0, #0]
 802dff8:	6835      	ldr	r5, [r6, #0]
 802dffa:	f025 0501 	bic.w	r5, r5, #1
 802dffe:	6035      	str	r5, [r6, #0]
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
 802e000:	f7ff fedc 	bl	802ddbc <DMA_SetConfig>
    if (NULL != hdma->XferHalfCpltCallback)
 802e004:	6b02      	ldr	r2, [r0, #48]	; 0x30
 802e006:	6803      	ldr	r3, [r0, #0]
 802e008:	b1ba      	cbz	r2, 802e03a <HAL_DMA_Start_IT+0x6a>
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 802e00a:	681a      	ldr	r2, [r3, #0]
 802e00c:	f042 020e 	orr.w	r2, r2, #14
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_TE));
 802e010:	601a      	str	r2, [r3, #0]
    if ((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)
 802e012:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 802e014:	6811      	ldr	r1, [r2, #0]
 802e016:	03c9      	lsls	r1, r1, #15
      hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;
 802e018:	bf42      	ittt	mi
 802e01a:	6811      	ldrmi	r1, [r2, #0]
 802e01c:	f441 7180 	orrmi.w	r1, r1, #256	; 0x100
 802e020:	6011      	strmi	r1, [r2, #0]
    if (hdma->DMAmuxRequestGen != 0U)
 802e022:	6d62      	ldr	r2, [r4, #84]	; 0x54
 802e024:	b11a      	cbz	r2, 802e02e <HAL_DMA_Start_IT+0x5e>
      hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
 802e026:	6811      	ldr	r1, [r2, #0]
 802e028:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 802e02c:	6011      	str	r1, [r2, #0]
    __HAL_DMA_ENABLE(hdma);
 802e02e:	681a      	ldr	r2, [r3, #0]
 802e030:	f042 0201 	orr.w	r2, r2, #1
 802e034:	601a      	str	r2, [r3, #0]
  HAL_StatusTypeDef status = HAL_OK;
 802e036:	2000      	movs	r0, #0
}
 802e038:	bd70      	pop	{r4, r5, r6, pc}
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 802e03a:	681a      	ldr	r2, [r3, #0]
 802e03c:	f022 0204 	bic.w	r2, r2, #4
 802e040:	601a      	str	r2, [r3, #0]
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_TE));
 802e042:	681a      	ldr	r2, [r3, #0]
 802e044:	f042 020a 	orr.w	r2, r2, #10
 802e048:	e7e2      	b.n	802e010 <HAL_DMA_Start_IT+0x40>
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
 802e04a:	2380      	movs	r3, #128	; 0x80
 802e04c:	63c3      	str	r3, [r0, #60]	; 0x3c
    __HAL_UNLOCK(hdma);
 802e04e:	f880 6024 	strb.w	r6, [r0, #36]	; 0x24
    status = HAL_ERROR;
 802e052:	4628      	mov	r0, r5
 802e054:	e7f0      	b.n	802e038 <HAL_DMA_Start_IT+0x68>
  __HAL_LOCK(hdma);
 802e056:	2002      	movs	r0, #2
 802e058:	e7ee      	b.n	802e038 <HAL_DMA_Start_IT+0x68>

0802e05a <HAL_DMA_Abort>:
  if (NULL == hdma)
 802e05a:	b140      	cbz	r0, 802e06e <HAL_DMA_Abort+0x14>
  if (hdma->State != HAL_DMA_STATE_BUSY)
 802e05c:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
 802e060:	2b02      	cmp	r3, #2
 802e062:	d006      	beq.n	802e072 <HAL_DMA_Abort+0x18>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 802e064:	2304      	movs	r3, #4
 802e066:	63c3      	str	r3, [r0, #60]	; 0x3c
    __HAL_UNLOCK(hdma);
 802e068:	2300      	movs	r3, #0
 802e06a:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
    return HAL_ERROR;
 802e06e:	2001      	movs	r0, #1
}
 802e070:	4770      	bx	lr
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 802e072:	6803      	ldr	r3, [r0, #0]
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 802e074:	6c81      	ldr	r1, [r0, #72]	; 0x48
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 802e076:	681a      	ldr	r2, [r3, #0]
 802e078:	f022 020e 	bic.w	r2, r2, #14
 802e07c:	601a      	str	r2, [r3, #0]
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 802e07e:	680a      	ldr	r2, [r1, #0]
 802e080:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 802e084:	600a      	str	r2, [r1, #0]
    __HAL_DMA_DISABLE(hdma);
 802e086:	681a      	ldr	r2, [r3, #0]
 802e088:	f022 0201 	bic.w	r2, r2, #1
 802e08c:	601a      	str	r2, [r3, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 802e08e:	e9d0 1310 	ldrd	r1, r3, [r0, #64]	; 0x40
 802e092:	f003 021c 	and.w	r2, r3, #28
 802e096:	2301      	movs	r3, #1
 802e098:	4093      	lsls	r3, r2
 802e09a:	604b      	str	r3, [r1, #4]
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 802e09c:	e9d0 3213 	ldrd	r3, r2, [r0, #76]	; 0x4c
 802e0a0:	605a      	str	r2, [r3, #4]
    if (hdma->DMAmuxRequestGen != 0U)
 802e0a2:	6d43      	ldr	r3, [r0, #84]	; 0x54
 802e0a4:	b133      	cbz	r3, 802e0b4 <HAL_DMA_Abort+0x5a>
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 802e0a6:	681a      	ldr	r2, [r3, #0]
 802e0a8:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 802e0ac:	601a      	str	r2, [r3, #0]
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 802e0ae:	e9d0 3216 	ldrd	r3, r2, [r0, #88]	; 0x58
 802e0b2:	605a      	str	r2, [r3, #4]
    hdma->State = HAL_DMA_STATE_READY;
 802e0b4:	2301      	movs	r3, #1
 802e0b6:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
    __HAL_UNLOCK(hdma);
 802e0ba:	2300      	movs	r3, #0
 802e0bc:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
  return HAL_OK;
 802e0c0:	4618      	mov	r0, r3
 802e0c2:	4770      	bx	lr

0802e0c4 <HAL_DMA_Abort_IT>:
{
 802e0c4:	b510      	push	{r4, lr}
  if (hdma->State != HAL_DMA_STATE_BUSY)
 802e0c6:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
 802e0ca:	2b02      	cmp	r3, #2
 802e0cc:	d003      	beq.n	802e0d6 <HAL_DMA_Abort_IT+0x12>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 802e0ce:	2304      	movs	r3, #4
 802e0d0:	63c3      	str	r3, [r0, #60]	; 0x3c
    status = HAL_ERROR;
 802e0d2:	2001      	movs	r0, #1
}
 802e0d4:	bd10      	pop	{r4, pc}
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 802e0d6:	6803      	ldr	r3, [r0, #0]
 802e0d8:	681a      	ldr	r2, [r3, #0]
 802e0da:	f022 020e 	bic.w	r2, r2, #14
 802e0de:	601a      	str	r2, [r3, #0]
    __HAL_DMA_DISABLE(hdma);
 802e0e0:	681a      	ldr	r2, [r3, #0]
 802e0e2:	f022 0201 	bic.w	r2, r2, #1
 802e0e6:	601a      	str	r2, [r3, #0]
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 802e0e8:	6c82      	ldr	r2, [r0, #72]	; 0x48
 802e0ea:	6813      	ldr	r3, [r2, #0]
 802e0ec:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 802e0f0:	6013      	str	r3, [r2, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 802e0f2:	e9d0 1310 	ldrd	r1, r3, [r0, #64]	; 0x40
 802e0f6:	f003 021c 	and.w	r2, r3, #28
 802e0fa:	2301      	movs	r3, #1
 802e0fc:	4093      	lsls	r3, r2
 802e0fe:	604b      	str	r3, [r1, #4]
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 802e100:	e9d0 3213 	ldrd	r3, r2, [r0, #76]	; 0x4c
 802e104:	605a      	str	r2, [r3, #4]
    if (hdma->DMAmuxRequestGen != 0U)
 802e106:	6d43      	ldr	r3, [r0, #84]	; 0x54
 802e108:	b133      	cbz	r3, 802e118 <HAL_DMA_Abort_IT+0x54>
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 802e10a:	681a      	ldr	r2, [r3, #0]
 802e10c:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 802e110:	601a      	str	r2, [r3, #0]
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 802e112:	e9d0 3216 	ldrd	r3, r2, [r0, #88]	; 0x58
 802e116:	605a      	str	r2, [r3, #4]
    hdma->State = HAL_DMA_STATE_READY;
 802e118:	2301      	movs	r3, #1
 802e11a:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
    if (hdma->XferAbortCallback != NULL)
 802e11e:	6b83      	ldr	r3, [r0, #56]	; 0x38
    __HAL_UNLOCK(hdma);
 802e120:	2400      	movs	r4, #0
 802e122:	f880 4024 	strb.w	r4, [r0, #36]	; 0x24
    if (hdma->XferAbortCallback != NULL)
 802e126:	b113      	cbz	r3, 802e12e <HAL_DMA_Abort_IT+0x6a>
      hdma->XferAbortCallback(hdma);
 802e128:	4798      	blx	r3
  HAL_StatusTypeDef status = HAL_OK;
 802e12a:	4620      	mov	r0, r4
 802e12c:	e7d2      	b.n	802e0d4 <HAL_DMA_Abort_IT+0x10>
 802e12e:	4618      	mov	r0, r3
 802e130:	e7d0      	b.n	802e0d4 <HAL_DMA_Abort_IT+0x10>
	...

0802e134 <HAL_DMA_IRQHandler>:
{
 802e134:	b470      	push	{r4, r5, r6}
  if (((flag_it & (DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1CU))) != 0U) && ((source_it & DMA_IT_HT) != 0U))
 802e136:	6c42      	ldr	r2, [r0, #68]	; 0x44
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 802e138:	6c04      	ldr	r4, [r0, #64]	; 0x40
  uint32_t source_it = hdma->Instance->CCR;
 802e13a:	6803      	ldr	r3, [r0, #0]
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 802e13c:	6826      	ldr	r6, [r4, #0]
  uint32_t source_it = hdma->Instance->CCR;
 802e13e:	681d      	ldr	r5, [r3, #0]
  if (((flag_it & (DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1CU))) != 0U) && ((source_it & DMA_IT_HT) != 0U))
 802e140:	f002 021c 	and.w	r2, r2, #28
 802e144:	2104      	movs	r1, #4
 802e146:	4091      	lsls	r1, r2
 802e148:	4231      	tst	r1, r6
 802e14a:	d00f      	beq.n	802e16c <HAL_DMA_IRQHandler+0x38>
 802e14c:	f015 0f04 	tst.w	r5, #4
 802e150:	d00c      	beq.n	802e16c <HAL_DMA_IRQHandler+0x38>
      if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 802e152:	681a      	ldr	r2, [r3, #0]
 802e154:	0692      	lsls	r2, r2, #26
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 802e156:	bf5e      	ittt	pl
 802e158:	681a      	ldrpl	r2, [r3, #0]
 802e15a:	f022 0204 	bicpl.w	r2, r2, #4
 802e15e:	601a      	strpl	r2, [r3, #0]
      if (hdma->XferHalfCpltCallback != NULL)
 802e160:	6b03      	ldr	r3, [r0, #48]	; 0x30
      hdma->DmaBaseAddress->IFCR = DMA_ISR_HTIF1 << (hdma->ChannelIndex & 0x1CU);
 802e162:	6061      	str	r1, [r4, #4]
    if (hdma->XferErrorCallback != NULL)
 802e164:	2b00      	cmp	r3, #0
 802e166:	d033      	beq.n	802e1d0 <HAL_DMA_IRQHandler+0x9c>
}
 802e168:	bc70      	pop	{r4, r5, r6}
      hdma->XferErrorCallback(hdma);
 802e16a:	4718      	bx	r3
  else if ((0U != (flag_it & (DMA_FLAG_TC1 << (hdma->ChannelIndex & 0x1CU)))) && (0U != (source_it & DMA_IT_TC)))
 802e16c:	2102      	movs	r1, #2
 802e16e:	4091      	lsls	r1, r2
 802e170:	4231      	tst	r1, r6
 802e172:	d017      	beq.n	802e1a4 <HAL_DMA_IRQHandler+0x70>
 802e174:	f015 0f02 	tst.w	r5, #2
 802e178:	d014      	beq.n	802e1a4 <HAL_DMA_IRQHandler+0x70>
      if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 802e17a:	681a      	ldr	r2, [r3, #0]
 802e17c:	0694      	lsls	r4, r2, #26
 802e17e:	d406      	bmi.n	802e18e <HAL_DMA_IRQHandler+0x5a>
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
 802e180:	681a      	ldr	r2, [r3, #0]
 802e182:	f022 020a 	bic.w	r2, r2, #10
 802e186:	601a      	str	r2, [r3, #0]
        hdma->State = HAL_DMA_STATE_READY;
 802e188:	2201      	movs	r2, #1
 802e18a:	f880 2025 	strb.w	r2, [r0, #37]	; 0x25
      __HAL_DMA_CLEAR_FLAG(hdma, (DMA_FLAG_TC1 << (hdma->ChannelIndex & 0x1CU)));
 802e18e:	4a11      	ldr	r2, [pc, #68]	; (802e1d4 <HAL_DMA_IRQHandler+0xa0>)
 802e190:	4293      	cmp	r3, r2
 802e192:	bf8c      	ite	hi
 802e194:	4b10      	ldrhi	r3, [pc, #64]	; (802e1d8 <HAL_DMA_IRQHandler+0xa4>)
 802e196:	4b11      	ldrls	r3, [pc, #68]	; (802e1dc <HAL_DMA_IRQHandler+0xa8>)
 802e198:	6059      	str	r1, [r3, #4]
      __HAL_UNLOCK(hdma);
 802e19a:	2300      	movs	r3, #0
 802e19c:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
      if (hdma->XferCpltCallback != NULL)
 802e1a0:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 802e1a2:	e7df      	b.n	802e164 <HAL_DMA_IRQHandler+0x30>
  else if (((flag_it & (DMA_FLAG_TE1 << (hdma->ChannelIndex & 0x1CU))) != 0U) && ((source_it & DMA_IT_TE) != 0U))
 802e1a4:	2108      	movs	r1, #8
 802e1a6:	4091      	lsls	r1, r2
 802e1a8:	4231      	tst	r1, r6
 802e1aa:	d011      	beq.n	802e1d0 <HAL_DMA_IRQHandler+0x9c>
 802e1ac:	0729      	lsls	r1, r5, #28
 802e1ae:	d50f      	bpl.n	802e1d0 <HAL_DMA_IRQHandler+0x9c>
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 802e1b0:	6819      	ldr	r1, [r3, #0]
 802e1b2:	f021 010e 	bic.w	r1, r1, #14
 802e1b6:	6019      	str	r1, [r3, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 802e1b8:	2301      	movs	r3, #1
 802e1ba:	fa03 f202 	lsl.w	r2, r3, r2
 802e1be:	6062      	str	r2, [r4, #4]
    hdma->ErrorCode = HAL_DMA_ERROR_TE;
 802e1c0:	63c3      	str	r3, [r0, #60]	; 0x3c
    hdma->State = HAL_DMA_STATE_READY;
 802e1c2:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
    __HAL_UNLOCK(hdma);
 802e1c6:	2300      	movs	r3, #0
 802e1c8:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
    if (hdma->XferErrorCallback != NULL)
 802e1cc:	6b43      	ldr	r3, [r0, #52]	; 0x34
 802e1ce:	e7c9      	b.n	802e164 <HAL_DMA_IRQHandler+0x30>
}
 802e1d0:	bc70      	pop	{r4, r5, r6}
 802e1d2:	4770      	bx	lr
 802e1d4:	40020080 	.word	0x40020080
 802e1d8:	40020400 	.word	0x40020400
 802e1dc:	40020000 	.word	0x40020000

0802e1e0 <HAL_DMA_ConfigChannelAttributes>:
  if (hdma == NULL)
 802e1e0:	b160      	cbz	r0, 802e1fc <HAL_DMA_ConfigChannelAttributes+0x1c>
  ccr = READ_REG(hdma->Instance->CCR);
 802e1e2:	6802      	ldr	r2, [r0, #0]
  if ((ChannelAttributes & DMA_CHANNEL_ATTR_PRIV_MASK) != 0U)
 802e1e4:	06c8      	lsls	r0, r1, #27
  ccr = READ_REG(hdma->Instance->CCR);
 802e1e6:	6813      	ldr	r3, [r2, #0]
  if ((ChannelAttributes & DMA_CHANNEL_ATTR_PRIV_MASK) != 0U)
 802e1e8:	d505      	bpl.n	802e1f6 <HAL_DMA_ConfigChannelAttributes+0x16>
    if ((ChannelAttributes & DMA_CCR_PRIV) != 0U)
 802e1ea:	02c9      	lsls	r1, r1, #11
      SET_BIT(ccr, DMA_CCR_PRIV);
 802e1ec:	bf4c      	ite	mi
 802e1ee:	f443 1380 	orrmi.w	r3, r3, #1048576	; 0x100000
      CLEAR_BIT(ccr, DMA_CCR_PRIV);
 802e1f2:	f423 1380 	bicpl.w	r3, r3, #1048576	; 0x100000
  WRITE_REG(hdma->Instance->CCR, ccr);
 802e1f6:	6013      	str	r3, [r2, #0]
  return status;
 802e1f8:	2000      	movs	r0, #0
 802e1fa:	4770      	bx	lr
    return status;
 802e1fc:	2001      	movs	r0, #1
}
 802e1fe:	4770      	bx	lr

0802e200 <HAL_EXTI_RegisterCallback>:
  *         This parameter can be one of @arg @ref EXTI_CallbackIDTypeDef values.
  * @param  pPendingCbfn function pointer to be stored as callback.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_RegisterCallback(EXTI_HandleTypeDef *hexti, EXTI_CallbackIDTypeDef CallbackID, void (*pPendingCbfn)(void))
{
 802e200:	4603      	mov	r3, r0
  HAL_StatusTypeDef status = HAL_OK;

  switch (CallbackID)
 802e202:	4608      	mov	r0, r1
 802e204:	b909      	cbnz	r1, 802e20a <HAL_EXTI_RegisterCallback+0xa>
  {
    case  HAL_EXTI_COMMON_CB_ID:
      hexti->PendingCallback = pPendingCbfn;
 802e206:	605a      	str	r2, [r3, #4]
      break;
 802e208:	4770      	bx	lr

    default:
      status = HAL_ERROR;
 802e20a:	2001      	movs	r0, #1
      break;
  }

  return status;
}
 802e20c:	4770      	bx	lr

0802e20e <HAL_EXTI_GetHandle>:
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(ExtiLine));

  /* Check null pointer */
  if (hexti == NULL)
 802e20e:	b110      	cbz	r0, 802e216 <HAL_EXTI_GetHandle+0x8>
    return HAL_ERROR;
  }
  else
  {
    /* Store line number as handle private field */
    hexti->Line = ExtiLine;
 802e210:	6001      	str	r1, [r0, #0]

    return HAL_OK;
 802e212:	2000      	movs	r0, #0
 802e214:	4770      	bx	lr
    return HAL_ERROR;
 802e216:	2001      	movs	r0, #1
  }
}
 802e218:	4770      	bx	lr
	...

0802e21c <FLASH_Program_Fast>:

  /* Set FSTPG bit */
#ifdef CORE_CM0PLUS
  SET_BIT(FLASH->C2CR, FLASH_CR_FSTPG);
#else
  SET_BIT(FLASH->CR, FLASH_CR_FSTPG);
 802e21c:	4b0a      	ldr	r3, [pc, #40]	; (802e248 <FLASH_Program_Fast+0x2c>)
 802e21e:	695a      	ldr	r2, [r3, #20]
 802e220:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
{
 802e224:	b530      	push	{r4, r5, lr}
  SET_BIT(FLASH->CR, FLASH_CR_FSTPG);
 802e226:	615a      	str	r2, [r3, #20]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 802e228:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 802e22c:	b672      	cpsid	i
}
 802e22e:	2200      	movs	r2, #0
  __disable_irq();

  /* Program the double word of the row */
  do
  {
    *dest_addr = *src_addr;
 802e230:	588d      	ldr	r5, [r1, r2]
 802e232:	5085      	str	r5, [r0, r2]
    dest_addr++;
    src_addr++;
    row_index--;
  }
  while (row_index != 0U);
 802e234:	3204      	adds	r2, #4
 802e236:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 802e23a:	d1f9      	bne.n	802e230 <FLASH_Program_Fast+0x14>

  /* wait for BSY in order to be sure that flash operation is ended before
     allowing prefetch in flash. Timeout does not return status, as it will
     be anyway done later */
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != 0U)
 802e23c:	691a      	ldr	r2, [r3, #16]
 802e23e:	03d2      	lsls	r2, r2, #15
 802e240:	d4fc      	bmi.n	802e23c <FLASH_Program_Fast+0x20>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 802e242:	f384 8810 	msr	PRIMASK, r4
  {
  }

  /* Exit critical section: restore previous priority mask */
  __set_PRIMASK(primask_bit);
}
 802e246:	bd30      	pop	{r4, r5, pc}
 802e248:	58004000 	.word	0x58004000

0802e24c <HAL_FLASH_Unlock>:
  if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0U)
 802e24c:	4b06      	ldr	r3, [pc, #24]	; (802e268 <HAL_FLASH_Unlock+0x1c>)
 802e24e:	695a      	ldr	r2, [r3, #20]
 802e250:	2a00      	cmp	r2, #0
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 802e252:	bfbf      	itttt	lt
 802e254:	4a05      	ldrlt	r2, [pc, #20]	; (802e26c <HAL_FLASH_Unlock+0x20>)
 802e256:	609a      	strlt	r2, [r3, #8]
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 802e258:	f102 3288 	addlt.w	r2, r2, #2290649224	; 0x88888888
 802e25c:	609a      	strlt	r2, [r3, #8]
    if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0U)
 802e25e:	bfba      	itte	lt
 802e260:	6958      	ldrlt	r0, [r3, #20]
  HAL_StatusTypeDef status = HAL_OK;
 802e262:	0fc0      	lsrlt	r0, r0, #31
 802e264:	2000      	movge	r0, #0
}
 802e266:	4770      	bx	lr
 802e268:	58004000 	.word	0x58004000
 802e26c:	45670123 	.word	0x45670123

0802e270 <HAL_FLASH_Lock>:
  SET_BIT(FLASH->CR, FLASH_CR_LOCK);
 802e270:	4b04      	ldr	r3, [pc, #16]	; (802e284 <HAL_FLASH_Lock+0x14>)
 802e272:	695a      	ldr	r2, [r3, #20]
 802e274:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 802e278:	615a      	str	r2, [r3, #20]
  if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) == 0U)
 802e27a:	6958      	ldr	r0, [r3, #20]
}
 802e27c:	43c0      	mvns	r0, r0
 802e27e:	0fc0      	lsrs	r0, r0, #31
 802e280:	4770      	bx	lr
 802e282:	bf00      	nop
 802e284:	58004000 	.word	0x58004000

0802e288 <FLASH_WaitForLastOperation>:
{
 802e288:	b570      	push	{r4, r5, r6, lr}
 802e28a:	4605      	mov	r5, r0
  uint32_t tickstart = HAL_GetTick();
 802e28c:	f7fe f9da 	bl	802c644 <HAL_GetTick>
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 802e290:	4e12      	ldr	r6, [pc, #72]	; (802e2dc <FLASH_WaitForLastOperation+0x54>)
  uint32_t tickstart = HAL_GetTick();
 802e292:	4604      	mov	r4, r0
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 802e294:	6933      	ldr	r3, [r6, #16]
 802e296:	03d9      	lsls	r1, r3, #15
 802e298:	d413      	bmi.n	802e2c2 <FLASH_WaitForLastOperation+0x3a>
  error = FLASH->SR;
 802e29a:	6933      	ldr	r3, [r6, #16]
  if ((error & FLASH_FLAG_EOP) != 0U)
 802e29c:	07da      	lsls	r2, r3, #31
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 802e29e:	bf44      	itt	mi
 802e2a0:	2201      	movmi	r2, #1
 802e2a2:	6132      	strmi	r2, [r6, #16]
  error &= FLASH_FLAG_SR_ERRORS;
 802e2a4:	f24c 32fa 	movw	r2, #50170	; 0xc3fa
  __HAL_FLASH_CLEAR_FLAG(error);
 802e2a8:	4013      	ands	r3, r2
 802e2aa:	d111      	bne.n	802e2d0 <FLASH_WaitForLastOperation+0x48>
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_CFGBSY))
 802e2ac:	4e0b      	ldr	r6, [pc, #44]	; (802e2dc <FLASH_WaitForLastOperation+0x54>)
 802e2ae:	6930      	ldr	r0, [r6, #16]
 802e2b0:	f410 2080 	ands.w	r0, r0, #262144	; 0x40000
 802e2b4:	d00b      	beq.n	802e2ce <FLASH_WaitForLastOperation+0x46>
    if ((HAL_GetTick() - tickstart) >= Timeout)
 802e2b6:	f7fe f9c5 	bl	802c644 <HAL_GetTick>
 802e2ba:	1b00      	subs	r0, r0, r4
 802e2bc:	42a8      	cmp	r0, r5
 802e2be:	d3f6      	bcc.n	802e2ae <FLASH_WaitForLastOperation+0x26>
 802e2c0:	e004      	b.n	802e2cc <FLASH_WaitForLastOperation+0x44>
    if ((HAL_GetTick() - tickstart) >= Timeout)
 802e2c2:	f7fe f9bf 	bl	802c644 <HAL_GetTick>
 802e2c6:	1b00      	subs	r0, r0, r4
 802e2c8:	42a8      	cmp	r0, r5
 802e2ca:	d3e3      	bcc.n	802e294 <FLASH_WaitForLastOperation+0xc>
      return HAL_TIMEOUT;
 802e2cc:	2003      	movs	r0, #3
}
 802e2ce:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_FLASH_CLEAR_FLAG(error);
 802e2d0:	4a02      	ldr	r2, [pc, #8]	; (802e2dc <FLASH_WaitForLastOperation+0x54>)
 802e2d2:	6113      	str	r3, [r2, #16]
    pFlash.ErrorCode = error;
 802e2d4:	4a02      	ldr	r2, [pc, #8]	; (802e2e0 <FLASH_WaitForLastOperation+0x58>)
    return HAL_ERROR;
 802e2d6:	2001      	movs	r0, #1
    pFlash.ErrorCode = error;
 802e2d8:	6053      	str	r3, [r2, #4]
    return HAL_ERROR;
 802e2da:	e7f8      	b.n	802e2ce <FLASH_WaitForLastOperation+0x46>
 802e2dc:	58004000 	.word	0x58004000
 802e2e0:	20003f3c 	.word	0x20003f3c

0802e2e4 <HAL_FLASH_Program>:
{
 802e2e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __HAL_LOCK(&pFlash);
 802e2e8:	4c18      	ldr	r4, [pc, #96]	; (802e34c <HAL_FLASH_Program+0x68>)
{
 802e2ea:	4698      	mov	r8, r3
  __HAL_LOCK(&pFlash);
 802e2ec:	7823      	ldrb	r3, [r4, #0]
 802e2ee:	2b01      	cmp	r3, #1
{
 802e2f0:	4606      	mov	r6, r0
 802e2f2:	460d      	mov	r5, r1
 802e2f4:	4617      	mov	r7, r2
  __HAL_LOCK(&pFlash);
 802e2f6:	d026      	beq.n	802e346 <HAL_FLASH_Program+0x62>
 802e2f8:	2301      	movs	r3, #1
 802e2fa:	7023      	strb	r3, [r4, #0]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e2fc:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 802e300:	2300      	movs	r3, #0
 802e302:	6063      	str	r3, [r4, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e304:	f7ff ffc0 	bl	802e288 <FLASH_WaitForLastOperation>
  if (status == HAL_OK)
 802e308:	b9a0      	cbnz	r0, 802e334 <HAL_FLASH_Program+0x50>
    if (TypeProgram == FLASH_TYPEPROGRAM_DOUBLEWORD)
 802e30a:	2e01      	cmp	r6, #1
 802e30c:	d116      	bne.n	802e33c <HAL_FLASH_Program+0x58>
  SET_BIT(FLASH->CR, FLASH_CR_PG);
 802e30e:	4a10      	ldr	r2, [pc, #64]	; (802e350 <HAL_FLASH_Program+0x6c>)
 802e310:	6953      	ldr	r3, [r2, #20]
 802e312:	f043 0301 	orr.w	r3, r3, #1
 802e316:	6153      	str	r3, [r2, #20]
  *(uint32_t *)Address = (uint32_t)Data;
 802e318:	602f      	str	r7, [r5, #0]
  __ASM volatile ("isb 0xF":::"memory");
 802e31a:	f3bf 8f6f 	isb	sy
  *(uint32_t *)(Address + 4U) = (uint32_t)(Data >> 32U);
 802e31e:	f8c5 8004 	str.w	r8, [r5, #4]
    status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e322:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 802e326:	f7ff ffaf 	bl	802e288 <FLASH_WaitForLastOperation>
    CLEAR_BIT(FLASH->CR, TypeProgram);
 802e32a:	4a09      	ldr	r2, [pc, #36]	; (802e350 <HAL_FLASH_Program+0x6c>)
 802e32c:	6953      	ldr	r3, [r2, #20]
 802e32e:	ea23 0606 	bic.w	r6, r3, r6
 802e332:	6156      	str	r6, [r2, #20]
  __HAL_UNLOCK(&pFlash);
 802e334:	2300      	movs	r3, #0
 802e336:	7023      	strb	r3, [r4, #0]
}
 802e338:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      FLASH_Program_Fast(Address, (uint32_t)Data);
 802e33c:	4639      	mov	r1, r7
 802e33e:	4628      	mov	r0, r5
 802e340:	f7ff ff6c 	bl	802e21c <FLASH_Program_Fast>
 802e344:	e7ed      	b.n	802e322 <HAL_FLASH_Program+0x3e>
  __HAL_LOCK(&pFlash);
 802e346:	2002      	movs	r0, #2
 802e348:	e7f6      	b.n	802e338 <HAL_FLASH_Program+0x54>
 802e34a:	bf00      	nop
 802e34c:	20003f3c 	.word	0x20003f3c
 802e350:	58004000 	.word	0x58004000

0802e354 <FLASH_PageErase>:

  /* Proceed to erase the page */
#ifdef CORE_CM0PLUS
  MODIFY_REG(FLASH->C2CR, FLASH_CR_PNB, ((Page << FLASH_CR_PNB_Pos) | FLASH_CR_PER | FLASH_CR_STRT));
#else
  MODIFY_REG(FLASH->CR, FLASH_CR_PNB, ((Page << FLASH_CR_PNB_Pos) | FLASH_CR_PER | FLASH_CR_STRT));
 802e354:	4a05      	ldr	r2, [pc, #20]	; (802e36c <FLASH_PageErase+0x18>)
 802e356:	6953      	ldr	r3, [r2, #20]
 802e358:	f423 737e 	bic.w	r3, r3, #1016	; 0x3f8
 802e35c:	ea43 00c0 	orr.w	r0, r3, r0, lsl #3
 802e360:	f440 3080 	orr.w	r0, r0, #65536	; 0x10000
 802e364:	f040 0002 	orr.w	r0, r0, #2
 802e368:	6150      	str	r0, [r2, #20]
#endif
}
 802e36a:	4770      	bx	lr
 802e36c:	58004000 	.word	0x58004000

0802e370 <HAL_FLASHEx_Erase>:
{
 802e370:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __HAL_LOCK(&pFlash);
 802e374:	4d23      	ldr	r5, [pc, #140]	; (802e404 <HAL_FLASHEx_Erase+0x94>)
 802e376:	782b      	ldrb	r3, [r5, #0]
 802e378:	2b01      	cmp	r3, #1
{
 802e37a:	4606      	mov	r6, r0
 802e37c:	4688      	mov	r8, r1
  __HAL_LOCK(&pFlash);
 802e37e:	d03f      	beq.n	802e400 <HAL_FLASHEx_Erase+0x90>
 802e380:	2301      	movs	r3, #1
 802e382:	702b      	strb	r3, [r5, #0]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e384:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 802e388:	2300      	movs	r3, #0
 802e38a:	606b      	str	r3, [r5, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e38c:	f7ff ff7c 	bl	802e288 <FLASH_WaitForLastOperation>
  if (status == HAL_OK)
 802e390:	4604      	mov	r4, r0
 802e392:	b988      	cbnz	r0, 802e3b8 <HAL_FLASHEx_Erase+0x48>
    if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 802e394:	6833      	ldr	r3, [r6, #0]
 802e396:	2b04      	cmp	r3, #4
 802e398:	d113      	bne.n	802e3c2 <HAL_FLASHEx_Erase+0x52>
  SET_BIT(FLASH->CR, (FLASH_CR_MER | FLASH_CR_STRT));
 802e39a:	4a1b      	ldr	r2, [pc, #108]	; (802e408 <HAL_FLASHEx_Erase+0x98>)
 802e39c:	6953      	ldr	r3, [r2, #20]
 802e39e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 802e3a2:	f043 0304 	orr.w	r3, r3, #4
 802e3a6:	6153      	str	r3, [r2, #20]
      status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e3a8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 802e3ac:	f7ff ff6c 	bl	802e288 <FLASH_WaitForLastOperation>
 802e3b0:	4604      	mov	r4, r0
  * @retval None
  */
void FLASH_FlushCaches(void)
{
  /* Flush instruction cache  */
  if (READ_BIT(FLASH->ACR, FLASH_ACR_ICEN) == 1U)
 802e3b2:	4b15      	ldr	r3, [pc, #84]	; (802e408 <HAL_FLASHEx_Erase+0x98>)
 802e3b4:	681a      	ldr	r2, [r3, #0]
  }

#ifdef CORE_CM0PLUS
#else
  /* Flush data cache */
  if (READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) == 1U)
 802e3b6:	681b      	ldr	r3, [r3, #0]
  __HAL_UNLOCK(&pFlash);
 802e3b8:	2300      	movs	r3, #0
 802e3ba:	702b      	strb	r3, [r5, #0]
}
 802e3bc:	4620      	mov	r0, r4
 802e3be:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      *PageError = 0xFFFFFFFFU;
 802e3c2:	f04f 33ff 	mov.w	r3, #4294967295
 802e3c6:	f8c8 3000 	str.w	r3, [r8]
      for (index = pEraseInit->Page; index < (pEraseInit->Page + pEraseInit->NbPages); index++)
 802e3ca:	6877      	ldr	r7, [r6, #4]
 802e3cc:	e9d6 3201 	ldrd	r3, r2, [r6, #4]
 802e3d0:	4413      	add	r3, r2
 802e3d2:	42bb      	cmp	r3, r7
 802e3d4:	d90a      	bls.n	802e3ec <HAL_FLASHEx_Erase+0x7c>
        FLASH_PageErase(index);
 802e3d6:	4638      	mov	r0, r7
 802e3d8:	f7ff ffbc 	bl	802e354 <FLASH_PageErase>
        status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e3dc:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 802e3e0:	f7ff ff52 	bl	802e288 <FLASH_WaitForLastOperation>
        if (status != HAL_OK)
 802e3e4:	b150      	cbz	r0, 802e3fc <HAL_FLASHEx_Erase+0x8c>
          *PageError = index;
 802e3e6:	f8c8 7000 	str.w	r7, [r8]
        status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e3ea:	4604      	mov	r4, r0
static void FLASH_AcknowledgePageErase(void)
{
#ifdef CORE_CM0PLUS
  CLEAR_BIT(FLASH->C2CR, (FLASH_CR_PER | FLASH_CR_PNB));
#else
  CLEAR_BIT(FLASH->CR, (FLASH_CR_PER | FLASH_CR_PNB));
 802e3ec:	4a06      	ldr	r2, [pc, #24]	; (802e408 <HAL_FLASHEx_Erase+0x98>)
 802e3ee:	6953      	ldr	r3, [r2, #20]
 802e3f0:	f423 737e 	bic.w	r3, r3, #1016	; 0x3f8
 802e3f4:	f023 0302 	bic.w	r3, r3, #2
 802e3f8:	6153      	str	r3, [r2, #20]
#endif
}
 802e3fa:	e7da      	b.n	802e3b2 <HAL_FLASHEx_Erase+0x42>
      for (index = pEraseInit->Page; index < (pEraseInit->Page + pEraseInit->NbPages); index++)
 802e3fc:	3701      	adds	r7, #1
 802e3fe:	e7e5      	b.n	802e3cc <HAL_FLASHEx_Erase+0x5c>
  __HAL_LOCK(&pFlash);
 802e400:	2402      	movs	r4, #2
 802e402:	e7db      	b.n	802e3bc <HAL_FLASHEx_Erase+0x4c>
 802e404:	20003f3c 	.word	0x20003f3c
 802e408:	58004000 	.word	0x58004000

0802e40c <HAL_FLASHEx_Erase_IT>:
{
 802e40c:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(&pFlash);
 802e40e:	4c16      	ldr	r4, [pc, #88]	; (802e468 <HAL_FLASHEx_Erase_IT+0x5c>)
 802e410:	7823      	ldrb	r3, [r4, #0]
 802e412:	2b01      	cmp	r3, #1
{
 802e414:	4605      	mov	r5, r0
  __HAL_LOCK(&pFlash);
 802e416:	d025      	beq.n	802e464 <HAL_FLASHEx_Erase_IT+0x58>
 802e418:	2301      	movs	r3, #1
 802e41a:	7023      	strb	r3, [r4, #0]
  pFlash.ProcedureOnGoing = pEraseInit->TypeErase;
 802e41c:	6803      	ldr	r3, [r0, #0]
 802e41e:	60a3      	str	r3, [r4, #8]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 802e420:	2600      	movs	r6, #0
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e422:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 802e426:	6066      	str	r6, [r4, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 802e428:	f7ff ff2e 	bl	802e288 <FLASH_WaitForLastOperation>
  if (status != HAL_OK)
 802e42c:	4601      	mov	r1, r0
 802e42e:	b110      	cbz	r0, 802e436 <HAL_FLASHEx_Erase_IT+0x2a>
    __HAL_UNLOCK(&pFlash);
 802e430:	7026      	strb	r6, [r4, #0]
}
 802e432:	4608      	mov	r0, r1
 802e434:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP | FLASH_IT_OPERR);
 802e436:	4a0d      	ldr	r2, [pc, #52]	; (802e46c <HAL_FLASHEx_Erase_IT+0x60>)
 802e438:	6953      	ldr	r3, [r2, #20]
 802e43a:	f043 7340 	orr.w	r3, r3, #50331648	; 0x3000000
 802e43e:	6153      	str	r3, [r2, #20]
    if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 802e440:	682b      	ldr	r3, [r5, #0]
 802e442:	2b04      	cmp	r3, #4
 802e444:	d107      	bne.n	802e456 <HAL_FLASHEx_Erase_IT+0x4a>
      pFlash.Page = 0;
 802e446:	6120      	str	r0, [r4, #16]
  SET_BIT(FLASH->CR, (FLASH_CR_MER | FLASH_CR_STRT));
 802e448:	6953      	ldr	r3, [r2, #20]
 802e44a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 802e44e:	f043 0304 	orr.w	r3, r3, #4
 802e452:	6153      	str	r3, [r2, #20]
}
 802e454:	e7ed      	b.n	802e432 <HAL_FLASHEx_Erase_IT+0x26>
      pFlash.NbPagesToErase = pEraseInit->NbPages;
 802e456:	68ab      	ldr	r3, [r5, #8]
      pFlash.Page = pEraseInit->Page;
 802e458:	6868      	ldr	r0, [r5, #4]
      pFlash.NbPagesToErase = pEraseInit->NbPages;
 802e45a:	6163      	str	r3, [r4, #20]
      pFlash.Page = pEraseInit->Page;
 802e45c:	6120      	str	r0, [r4, #16]
      FLASH_PageErase(pEraseInit->Page);
 802e45e:	f7ff ff79 	bl	802e354 <FLASH_PageErase>
 802e462:	e7e6      	b.n	802e432 <HAL_FLASHEx_Erase_IT+0x26>
  __HAL_LOCK(&pFlash);
 802e464:	2102      	movs	r1, #2
 802e466:	e7e4      	b.n	802e432 <HAL_FLASHEx_Erase_IT+0x26>
 802e468:	20003f3c 	.word	0x20003f3c
 802e46c:	58004000 	.word	0x58004000

0802e470 <HAL_GPIO_Init>:
  * @param GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 802e470:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

        /* Clear EXTI line configuration */
#ifdef CORE_CM0PLUS
        temp = EXTI->C2IMR1;
#else
        temp = EXTI->IMR1;
 802e474:	4c52      	ldr	r4, [pc, #328]	; (802e5c0 <HAL_GPIO_Init+0x150>)
  uint32_t position = 0x00u;
 802e476:	2300      	movs	r3, #0
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 802e478:	f04f 090f 	mov.w	r9, #15
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 802e47c:	680a      	ldr	r2, [r1, #0]
 802e47e:	fa32 f503 	lsrs.w	r5, r2, r3
 802e482:	d101      	bne.n	802e488 <HAL_GPIO_Init+0x18>
      }
    }

    position++;
  }
}
 802e484:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 802e488:	2501      	movs	r5, #1
 802e48a:	fa05 f803 	lsl.w	r8, r5, r3
    if (iocurrent != 0x00u)
 802e48e:	ea18 0202 	ands.w	r2, r8, r2
 802e492:	f000 808f 	beq.w	802e5b4 <HAL_GPIO_Init+0x144>
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 802e496:	684e      	ldr	r6, [r1, #4]
 802e498:	2703      	movs	r7, #3
 802e49a:	f006 0503 	and.w	r5, r6, #3
 802e49e:	ea4f 0e43 	mov.w	lr, r3, lsl #1
 802e4a2:	fa07 fc0e 	lsl.w	ip, r7, lr
 802e4a6:	1e6f      	subs	r7, r5, #1
 802e4a8:	2f01      	cmp	r7, #1
 802e4aa:	ea6f 0c0c 	mvn.w	ip, ip
 802e4ae:	d832      	bhi.n	802e516 <HAL_GPIO_Init+0xa6>
        temp = GPIOx->OSPEEDR;
 802e4b0:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 802e4b2:	ea07 0a0c 	and.w	sl, r7, ip
        temp |= (GPIO_Init->Speed << (position * 2U));
 802e4b6:	68cf      	ldr	r7, [r1, #12]
 802e4b8:	fa07 f70e 	lsl.w	r7, r7, lr
 802e4bc:	ea47 070a 	orr.w	r7, r7, sl
        GPIOx->OSPEEDR = temp;
 802e4c0:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 802e4c2:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 802e4c4:	ea27 0808 	bic.w	r8, r7, r8
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 802e4c8:	f3c6 1700 	ubfx	r7, r6, #4, #1
 802e4cc:	409f      	lsls	r7, r3
 802e4ce:	ea47 0708 	orr.w	r7, r7, r8
        GPIOx->OTYPER = temp;
 802e4d2:	6047      	str	r7, [r0, #4]
        temp = GPIOx->PUPDR;
 802e4d4:	68c7      	ldr	r7, [r0, #12]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 802e4d6:	ea07 080c 	and.w	r8, r7, ip
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 802e4da:	688f      	ldr	r7, [r1, #8]
 802e4dc:	fa07 f70e 	lsl.w	r7, r7, lr
 802e4e0:	ea47 0708 	orr.w	r7, r7, r8
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 802e4e4:	2d02      	cmp	r5, #2
        GPIOx->PUPDR = temp;
 802e4e6:	60c7      	str	r7, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 802e4e8:	d117      	bne.n	802e51a <HAL_GPIO_Init+0xaa>
        temp = GPIOx->AFR[position >> 3U];
 802e4ea:	ea4f 08d3 	mov.w	r8, r3, lsr #3
 802e4ee:	eb00 0888 	add.w	r8, r0, r8, lsl #2
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 802e4f2:	f003 0a07 	and.w	sl, r3, #7
        temp = GPIOx->AFR[position >> 3U];
 802e4f6:	f8d8 7020 	ldr.w	r7, [r8, #32]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 802e4fa:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 802e4fe:	fa09 fb0a 	lsl.w	fp, r9, sl
 802e502:	ea27 0b0b 	bic.w	fp, r7, fp
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 802e506:	690f      	ldr	r7, [r1, #16]
 802e508:	fa07 f70a 	lsl.w	r7, r7, sl
 802e50c:	ea47 070b 	orr.w	r7, r7, fp
        GPIOx->AFR[position >> 3u] = temp;
 802e510:	f8c8 7020 	str.w	r7, [r8, #32]
 802e514:	e001      	b.n	802e51a <HAL_GPIO_Init+0xaa>
      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 802e516:	2d03      	cmp	r5, #3
 802e518:	d1dc      	bne.n	802e4d4 <HAL_GPIO_Init+0x64>
      temp = GPIOx->MODER;
 802e51a:	6807      	ldr	r7, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 802e51c:	ea07 0c0c 	and.w	ip, r7, ip
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 802e520:	fa05 f70e 	lsl.w	r7, r5, lr
 802e524:	ea47 070c 	orr.w	r7, r7, ip
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 802e528:	f416 3f40 	tst.w	r6, #196608	; 0x30000
      GPIOx->MODER = temp;
 802e52c:	6007      	str	r7, [r0, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 802e52e:	d041      	beq.n	802e5b4 <HAL_GPIO_Init+0x144>
        temp = SYSCFG->EXTICR[position >> 2u];
 802e530:	f023 0703 	bic.w	r7, r3, #3
 802e534:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
 802e538:	f507 3780 	add.w	r7, r7, #65536	; 0x10000
        temp &= ~(0x07uL << (4U * (position & 0x03U)));
 802e53c:	f003 0c03 	and.w	ip, r3, #3
        temp = SYSCFG->EXTICR[position >> 2u];
 802e540:	68bd      	ldr	r5, [r7, #8]
        temp &= ~(0x07uL << (4U * (position & 0x03U)));
 802e542:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 802e546:	f04f 0e07 	mov.w	lr, #7
 802e54a:	fa0e fe0c 	lsl.w	lr, lr, ip
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 802e54e:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
        temp &= ~(0x07uL << (4U * (position & 0x03U)));
 802e552:	ea25 0e0e 	bic.w	lr, r5, lr
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 802e556:	d02f      	beq.n	802e5b8 <HAL_GPIO_Init+0x148>
 802e558:	4d1a      	ldr	r5, [pc, #104]	; (802e5c4 <HAL_GPIO_Init+0x154>)
 802e55a:	42a8      	cmp	r0, r5
 802e55c:	d02e      	beq.n	802e5bc <HAL_GPIO_Init+0x14c>
 802e55e:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 802e562:	42a8      	cmp	r0, r5
 802e564:	bf0c      	ite	eq
 802e566:	2502      	moveq	r5, #2
 802e568:	2507      	movne	r5, #7
 802e56a:	fa05 f50c 	lsl.w	r5, r5, ip
 802e56e:	ea45 050e 	orr.w	r5, r5, lr
        SYSCFG->EXTICR[position >> 2u] = temp;
 802e572:	60bd      	str	r5, [r7, #8]
        temp = EXTI->IMR1;
 802e574:	f8d4 5080 	ldr.w	r5, [r4, #128]	; 0x80
        temp &= ~(iocurrent);
 802e578:	43d7      	mvns	r7, r2
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00u)
 802e57a:	f416 3f80 	tst.w	r6, #65536	; 0x10000
        temp &= ~(iocurrent);
 802e57e:	bf0c      	ite	eq
 802e580:	403d      	andeq	r5, r7
          temp |= iocurrent;
 802e582:	4315      	orrne	r5, r2
        EXTI->IMR1 = temp;
 802e584:	f8c4 5080 	str.w	r5, [r4, #128]	; 0x80
        temp = EXTI->EMR1;
 802e588:	f8d4 5084 	ldr.w	r5, [r4, #132]	; 0x84
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
 802e58c:	f416 3f00 	tst.w	r6, #131072	; 0x20000
        temp &= ~(iocurrent);
 802e590:	bf0c      	ite	eq
 802e592:	403d      	andeq	r5, r7
          temp |= iocurrent;
 802e594:	4315      	orrne	r5, r2
        EXTI->EMR1 = temp;
 802e596:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
        temp = EXTI->RTSR1;
 802e59a:	6825      	ldr	r5, [r4, #0]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
 802e59c:	f416 1f80 	tst.w	r6, #1048576	; 0x100000
        temp &= ~(iocurrent);
 802e5a0:	bf0c      	ite	eq
 802e5a2:	403d      	andeq	r5, r7
          temp |= iocurrent;
 802e5a4:	4315      	orrne	r5, r2
        EXTI->RTSR1 = temp;
 802e5a6:	6025      	str	r5, [r4, #0]
        temp = EXTI->FTSR1;
 802e5a8:	6865      	ldr	r5, [r4, #4]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
 802e5aa:	02b6      	lsls	r6, r6, #10
        temp &= ~(iocurrent);
 802e5ac:	bf54      	ite	pl
 802e5ae:	403d      	andpl	r5, r7
          temp |= iocurrent;
 802e5b0:	4315      	orrmi	r5, r2
        EXTI->FTSR1 = temp;
 802e5b2:	6065      	str	r5, [r4, #4]
    position++;
 802e5b4:	3301      	adds	r3, #1
 802e5b6:	e761      	b.n	802e47c <HAL_GPIO_Init+0xc>
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 802e5b8:	2500      	movs	r5, #0
 802e5ba:	e7d6      	b.n	802e56a <HAL_GPIO_Init+0xfa>
 802e5bc:	2501      	movs	r5, #1
 802e5be:	e7d4      	b.n	802e56a <HAL_GPIO_Init+0xfa>
 802e5c0:	58000800 	.word	0x58000800
 802e5c4:	48000400 	.word	0x48000400

0802e5c8 <HAL_GPIO_DeInit>:
        /* Clear EXTI line configuration */
#ifdef CORE_CM0PLUS
        EXTI->C2IMR1 &= ~(iocurrent);
        EXTI->C2EMR1 &= ~(iocurrent);
#else
        EXTI->IMR1 &= ~(iocurrent);
 802e5c8:	4a37      	ldr	r2, [pc, #220]	; (802e6a8 <HAL_GPIO_DeInit+0xe0>)
{
 802e5ca:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t position = 0x00u;
 802e5ce:	2300      	movs	r3, #0
    iocurrent = (GPIO_Pin) & (1uL << position);
 802e5d0:	f04f 0a01 	mov.w	sl, #1
      tmp &= (0x07uL << (4U * (position & 0x03U)));
 802e5d4:	f04f 0b07 	mov.w	fp, #7
      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
 802e5d8:	f04f 090f 	mov.w	r9, #15
  while ((GPIO_Pin >> position) != 0x00u)
 802e5dc:	fa31 f403 	lsrs.w	r4, r1, r3
 802e5e0:	d101      	bne.n	802e5e6 <HAL_GPIO_DeInit+0x1e>
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
    }

    position++;
  }
}
 802e5e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Pin) & (1uL << position);
 802e5e6:	fa0a fc03 	lsl.w	ip, sl, r3
    if (iocurrent != 0x00u)
 802e5ea:	ea1c 0601 	ands.w	r6, ip, r1
 802e5ee:	d054      	beq.n	802e69a <HAL_GPIO_DeInit+0xd2>
      tmp = SYSCFG->EXTICR[position >> 2u];
 802e5f0:	f023 0403 	bic.w	r4, r3, #3
 802e5f4:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 802e5f8:	f504 3480 	add.w	r4, r4, #65536	; 0x10000
      tmp &= (0x07uL << (4U * (position & 0x03U)));
 802e5fc:	f003 0703 	and.w	r7, r3, #3
      tmp = SYSCFG->EXTICR[position >> 2u];
 802e600:	68a5      	ldr	r5, [r4, #8]
      tmp &= (0x07uL << (4U * (position & 0x03U)));
 802e602:	00bf      	lsls	r7, r7, #2
 802e604:	fa0b f807 	lsl.w	r8, fp, r7
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 802e608:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
      tmp &= (0x07uL << (4U * (position & 0x03U)));
 802e60c:	ea08 0e05 	and.w	lr, r8, r5
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 802e610:	d045      	beq.n	802e69e <HAL_GPIO_DeInit+0xd6>
 802e612:	4d26      	ldr	r5, [pc, #152]	; (802e6ac <HAL_GPIO_DeInit+0xe4>)
 802e614:	42a8      	cmp	r0, r5
 802e616:	d044      	beq.n	802e6a2 <HAL_GPIO_DeInit+0xda>
 802e618:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 802e61c:	42a8      	cmp	r0, r5
 802e61e:	bf0c      	ite	eq
 802e620:	2502      	moveq	r5, #2
 802e622:	2507      	movne	r5, #7
 802e624:	40bd      	lsls	r5, r7
 802e626:	4575      	cmp	r5, lr
 802e628:	d117      	bne.n	802e65a <HAL_GPIO_DeInit+0x92>
        EXTI->IMR1 &= ~(iocurrent);
 802e62a:	f8d2 5080 	ldr.w	r5, [r2, #128]	; 0x80
 802e62e:	ea25 0506 	bic.w	r5, r5, r6
 802e632:	f8c2 5080 	str.w	r5, [r2, #128]	; 0x80
        EXTI->EMR1 &= ~(iocurrent);
 802e636:	f8d2 5084 	ldr.w	r5, [r2, #132]	; 0x84
 802e63a:	ea25 0506 	bic.w	r5, r5, r6
 802e63e:	f8c2 5084 	str.w	r5, [r2, #132]	; 0x84
        EXTI->RTSR1 &= ~(iocurrent);
 802e642:	6815      	ldr	r5, [r2, #0]
 802e644:	ea25 0506 	bic.w	r5, r5, r6
 802e648:	6015      	str	r5, [r2, #0]
        EXTI->FTSR1 &= ~(iocurrent);
 802e64a:	6855      	ldr	r5, [r2, #4]
 802e64c:	ea25 0606 	bic.w	r6, r5, r6
 802e650:	6056      	str	r6, [r2, #4]
        SYSCFG->EXTICR[position >> 2u] &= ~tmp;
 802e652:	68a5      	ldr	r5, [r4, #8]
 802e654:	ea25 0508 	bic.w	r5, r5, r8
 802e658:	60a5      	str	r5, [r4, #8]
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
 802e65a:	6805      	ldr	r5, [r0, #0]
 802e65c:	2603      	movs	r6, #3
 802e65e:	005c      	lsls	r4, r3, #1
 802e660:	fa06 f404 	lsl.w	r4, r6, r4
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
 802e664:	fa23 f606 	lsr.w	r6, r3, r6
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
 802e668:	4325      	orrs	r5, r4
 802e66a:	eb00 0686 	add.w	r6, r0, r6, lsl #2
 802e66e:	6005      	str	r5, [r0, #0]
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
 802e670:	f003 0507 	and.w	r5, r3, #7
 802e674:	6a37      	ldr	r7, [r6, #32]
 802e676:	00ad      	lsls	r5, r5, #2
 802e678:	fa09 f505 	lsl.w	r5, r9, r5
 802e67c:	ea27 0505 	bic.w	r5, r7, r5
 802e680:	6235      	str	r5, [r6, #32]
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 802e682:	6885      	ldr	r5, [r0, #8]
 802e684:	ea25 0504 	bic.w	r5, r5, r4
 802e688:	6085      	str	r5, [r0, #8]
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
 802e68a:	6845      	ldr	r5, [r0, #4]
 802e68c:	ea25 050c 	bic.w	r5, r5, ip
 802e690:	6045      	str	r5, [r0, #4]
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 802e692:	68c5      	ldr	r5, [r0, #12]
 802e694:	ea25 0404 	bic.w	r4, r5, r4
 802e698:	60c4      	str	r4, [r0, #12]
    position++;
 802e69a:	3301      	adds	r3, #1
 802e69c:	e79e      	b.n	802e5dc <HAL_GPIO_DeInit+0x14>
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 802e69e:	2500      	movs	r5, #0
 802e6a0:	e7c0      	b.n	802e624 <HAL_GPIO_DeInit+0x5c>
 802e6a2:	2501      	movs	r5, #1
 802e6a4:	e7be      	b.n	802e624 <HAL_GPIO_DeInit+0x5c>
 802e6a6:	bf00      	nop
 802e6a8:	58000800 	.word	0x58000800
 802e6ac:	48000400 	.word	0x48000400

0802e6b0 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 802e6b0:	b10a      	cbz	r2, 802e6b6 <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 802e6b2:	6181      	str	r1, [r0, #24]
 802e6b4:	4770      	bx	lr
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 802e6b6:	6281      	str	r1, [r0, #40]	; 0x28
  }
}
 802e6b8:	4770      	bx	lr

0802e6ba <HAL_GPIO_TogglePin>:

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
 802e6ba:	6943      	ldr	r3, [r0, #20]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
 802e6bc:	ea01 0203 	and.w	r2, r1, r3
 802e6c0:	ea21 0103 	bic.w	r1, r1, r3
 802e6c4:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 802e6c8:	6181      	str	r1, [r0, #24]
}
 802e6ca:	4770      	bx	lr

0802e6cc <HAL_GPIO_EXTI_IRQHandler>:
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
  /* EXTI line interrupt detected */
  if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)
 802e6cc:	4a04      	ldr	r2, [pc, #16]	; (802e6e0 <HAL_GPIO_EXTI_IRQHandler+0x14>)
 802e6ce:	68d1      	ldr	r1, [r2, #12]
 802e6d0:	4201      	tst	r1, r0
{
 802e6d2:	b508      	push	{r3, lr}
  if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)
 802e6d4:	d002      	beq.n	802e6dc <HAL_GPIO_EXTI_IRQHandler+0x10>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 802e6d6:	60d0      	str	r0, [r2, #12]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 802e6d8:	f7fe fc5a 	bl	802cf90 <HAL_GPIO_EXTI_Callback>
  }
}
 802e6dc:	bd08      	pop	{r3, pc}
 802e6de:	bf00      	nop
 802e6e0:	58000800 	.word	0x58000800

0802e6e4 <HAL_PWR_EnableBkUpAccess>:
  *         backup domain.
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
 802e6e4:	4a02      	ldr	r2, [pc, #8]	; (802e6f0 <HAL_PWR_EnableBkUpAccess+0xc>)
 802e6e6:	6813      	ldr	r3, [r2, #0]
 802e6e8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 802e6ec:	6013      	str	r3, [r2, #0]
}
 802e6ee:	4770      	bx	lr
 802e6f0:	58000400 	.word	0x58000400

0802e6f4 <HAL_PWR_EnterSLEEPMode>:
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR(Regulator));
  assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));

  /* Set Regulator parameter */
  if (Regulator == PWR_MAINREGULATOR_ON)
 802e6f4:	4b0d      	ldr	r3, [pc, #52]	; (802e72c <HAL_PWR_EnterSLEEPMode+0x38>)
{
 802e6f6:	b510      	push	{r4, lr}
  {
    /* If in low-power run mode at this point, exit it */
    if (HAL_IS_BIT_SET(PWR->SR2, (PWR_SR2_REGLPF)))
 802e6f8:	695b      	ldr	r3, [r3, #20]
{
 802e6fa:	460c      	mov	r4, r1
  if (Regulator == PWR_MAINREGULATOR_ON)
 802e6fc:	b928      	cbnz	r0, 802e70a <HAL_PWR_EnterSLEEPMode+0x16>
    if (HAL_IS_BIT_SET(PWR->SR2, (PWR_SR2_REGLPF)))
 802e6fe:	059a      	lsls	r2, r3, #22
 802e700:	d507      	bpl.n	802e712 <HAL_PWR_EnterSLEEPMode+0x1e>
    {
      if (HAL_PWREx_DisableLowPowerRunMode() != HAL_OK)
 802e702:	f000 f827 	bl	802e754 <HAL_PWREx_DisableLowPowerRunMode>
 802e706:	b120      	cbz	r0, 802e712 <HAL_PWR_EnterSLEEPMode+0x1e>
    /* Request Wait For Event */
    __SEV();
    __WFE();
    __WFE();
  }
}
 802e708:	bd10      	pop	{r4, pc}
    if (HAL_IS_BIT_CLR(PWR->SR2, (PWR_SR2_REGLPF)))
 802e70a:	059b      	lsls	r3, r3, #22
 802e70c:	d401      	bmi.n	802e712 <HAL_PWR_EnterSLEEPMode+0x1e>
      HAL_PWREx_EnableLowPowerRunMode();
 802e70e:	f000 f819 	bl	802e744 <HAL_PWREx_EnableLowPowerRunMode>
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 802e712:	4a07      	ldr	r2, [pc, #28]	; (802e730 <HAL_PWR_EnterSLEEPMode+0x3c>)
 802e714:	6913      	ldr	r3, [r2, #16]
  if (SLEEPEntry == PWR_SLEEPENTRY_WFI)
 802e716:	2c01      	cmp	r4, #1
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 802e718:	f023 0304 	bic.w	r3, r3, #4
 802e71c:	6113      	str	r3, [r2, #16]
  if (SLEEPEntry == PWR_SLEEPENTRY_WFI)
 802e71e:	d101      	bne.n	802e724 <HAL_PWR_EnterSLEEPMode+0x30>
    __WFI();
 802e720:	bf30      	wfi
 802e722:	e7f1      	b.n	802e708 <HAL_PWR_EnterSLEEPMode+0x14>
    __SEV();
 802e724:	bf40      	sev
    __WFE();
 802e726:	bf20      	wfe
    __WFE();
 802e728:	bf20      	wfe
 802e72a:	e7ed      	b.n	802e708 <HAL_PWR_EnterSLEEPMode+0x14>
 802e72c:	58000400 	.word	0x58000400
 802e730:	e000ed00 	.word	0xe000ed00

0802e734 <HAL_PWREx_GetVoltageRange>:
  * @brief Return Voltage Scaling Range.
  * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_SCALE1 or PWPWR_REGULATOR_VOLTAGE_SCALE2)
  */
uint32_t HAL_PWREx_GetVoltageRange(void)
{
  return (PWR->CR1 & PWR_CR1_VOS);
 802e734:	4b02      	ldr	r3, [pc, #8]	; (802e740 <HAL_PWREx_GetVoltageRange+0xc>)
 802e736:	6818      	ldr	r0, [r3, #0]
}
 802e738:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
 802e73c:	4770      	bx	lr
 802e73e:	bf00      	nop
 802e740:	58000400 	.word	0x58000400

0802e744 <HAL_PWREx_EnableLowPowerRunMode>:
  * @retval None
  */
void HAL_PWREx_EnableLowPowerRunMode(void)
{
  /* Set Regulator parameter */
  SET_BIT(PWR->CR1, PWR_CR1_LPR);
 802e744:	4a02      	ldr	r2, [pc, #8]	; (802e750 <HAL_PWREx_EnableLowPowerRunMode+0xc>)
 802e746:	6813      	ldr	r3, [r2, #0]
 802e748:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 802e74c:	6013      	str	r3, [r2, #0]
}
 802e74e:	4770      	bx	lr
 802e750:	58000400 	.word	0x58000400

0802e754 <HAL_PWREx_DisableLowPowerRunMode>:
HAL_StatusTypeDef HAL_PWREx_DisableLowPowerRunMode(void)
{
  uint32_t wait_loop_index;

  /* Clear LPR bit */
  CLEAR_BIT(PWR->CR1, PWR_CR1_LPR);
 802e754:	4a0d      	ldr	r2, [pc, #52]	; (802e78c <HAL_PWREx_DisableLowPowerRunMode+0x38>)
 802e756:	6813      	ldr	r3, [r2, #0]
 802e758:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 802e75c:	6013      	str	r3, [r2, #0]

  /* Wait until REGLPF is reset */
  wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000UL);
 802e75e:	4b0c      	ldr	r3, [pc, #48]	; (802e790 <HAL_PWREx_DisableLowPowerRunMode+0x3c>)
 802e760:	6819      	ldr	r1, [r3, #0]
 802e762:	2332      	movs	r3, #50	; 0x32
 802e764:	434b      	muls	r3, r1
 802e766:	490b      	ldr	r1, [pc, #44]	; (802e794 <HAL_PWREx_DisableLowPowerRunMode+0x40>)
 802e768:	fbb3 f3f1 	udiv	r3, r3, r1
  while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF)) && (wait_loop_index != 0U))
 802e76c:	4611      	mov	r1, r2
 802e76e:	6950      	ldr	r0, [r2, #20]
 802e770:	f410 7f00 	tst.w	r0, #512	; 0x200
 802e774:	d000      	beq.n	802e778 <HAL_PWREx_DisableLowPowerRunMode+0x24>
 802e776:	b933      	cbnz	r3, 802e786 <HAL_PWREx_DisableLowPowerRunMode+0x32>
  {
    wait_loop_index--;
  }
  if (HAL_IS_BIT_SET(PWR->SR2, (PWR_SR2_REGLPF)))
 802e778:	694b      	ldr	r3, [r1, #20]
  {
    return HAL_TIMEOUT;
 802e77a:	f413 7f00 	tst.w	r3, #512	; 0x200
  }

  return HAL_OK;
}
 802e77e:	bf14      	ite	ne
 802e780:	2003      	movne	r0, #3
 802e782:	2000      	moveq	r0, #0
 802e784:	4770      	bx	lr
    wait_loop_index--;
 802e786:	3b01      	subs	r3, #1
 802e788:	e7f1      	b.n	802e76e <HAL_PWREx_DisableLowPowerRunMode+0x1a>
 802e78a:	bf00      	nop
 802e78c:	58000400 	.word	0x58000400
 802e790:	2000344c 	.word	0x2000344c
 802e794:	000f4240 	.word	0x000f4240

0802e798 <HAL_PWREx_EnterSTOP2Mode>:
#ifdef CORE_CM0PLUS
  /* Set Stop mode 2 */
  MODIFY_REG(PWR->C2CR1, PWR_C2CR1_LPMS, PWR_LOWPOWERMODE_STOP2);
#else
  /* Set Stop mode 2 */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_LOWPOWERMODE_STOP2);
 802e798:	4a0b      	ldr	r2, [pc, #44]	; (802e7c8 <HAL_PWREx_EnterSTOP2Mode+0x30>)
 802e79a:	6813      	ldr	r3, [r2, #0]
 802e79c:	f023 0307 	bic.w	r3, r3, #7
 802e7a0:	f043 0302 	orr.w	r3, r3, #2
 802e7a4:	6013      	str	r3, [r2, #0]
#endif

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 802e7a6:	4b09      	ldr	r3, [pc, #36]	; (802e7cc <HAL_PWREx_EnterSTOP2Mode+0x34>)
 802e7a8:	691a      	ldr	r2, [r3, #16]

  /* Select Stop mode entry --------------------------------------------------*/
  if (STOPEntry == PWR_STOPENTRY_WFI)
 802e7aa:	2801      	cmp	r0, #1
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 802e7ac:	f042 0204 	orr.w	r2, r2, #4
 802e7b0:	611a      	str	r2, [r3, #16]
  if (STOPEntry == PWR_STOPENTRY_WFI)
 802e7b2:	d105      	bne.n	802e7c0 <HAL_PWREx_EnterSTOP2Mode+0x28>
  {
    /* Request Wait For Interrupt */
    __WFI();
 802e7b4:	bf30      	wfi
    __WFE();
    __WFE();
  }

  /* Reset SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 802e7b6:	691a      	ldr	r2, [r3, #16]
 802e7b8:	f022 0204 	bic.w	r2, r2, #4
 802e7bc:	611a      	str	r2, [r3, #16]
}
 802e7be:	4770      	bx	lr
    __SEV();
 802e7c0:	bf40      	sev
    __WFE();
 802e7c2:	bf20      	wfe
    __WFE();
 802e7c4:	bf20      	wfe
 802e7c6:	e7f6      	b.n	802e7b6 <HAL_PWREx_EnterSTOP2Mode+0x1e>
 802e7c8:	58000400 	.word	0x58000400
 802e7cc:	e000ed00 	.word	0xe000ed00

0802e7d0 <LL_RCC_HSE_IsReady>:
  return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
 802e7d0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802e7d4:	6818      	ldr	r0, [r3, #0]
}
 802e7d6:	f3c0 4040 	ubfx	r0, r0, #17, #1
 802e7da:	4770      	bx	lr

0802e7dc <LL_RCC_HSI_IsReady>:
  return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
 802e7dc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802e7e0:	6818      	ldr	r0, [r3, #0]
}
 802e7e2:	f3c0 2080 	ubfx	r0, r0, #10, #1
 802e7e6:	4770      	bx	lr

0802e7e8 <LL_RCC_MSI_IsReady>:
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRDY) == (RCC_CR_MSIRDY)) ? 1UL : 0UL);
 802e7e8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802e7ec:	6818      	ldr	r0, [r3, #0]
}
 802e7ee:	f3c0 0040 	ubfx	r0, r0, #1, #1
 802e7f2:	4770      	bx	lr

0802e7f4 <LL_RCC_MSI_SetCalibTrimming>:
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_MSITRIM, Value << RCC_ICSCR_MSITRIM_Pos);
 802e7f4:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 802e7f8:	6853      	ldr	r3, [r2, #4]
 802e7fa:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 802e7fe:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 802e802:	6053      	str	r3, [r2, #4]
}
 802e804:	4770      	bx	lr

0802e806 <LL_RCC_PLL_IsReady>:
  * @rmtoll CR           PLLRDY        LL_RCC_PLL_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_IsReady(void)
{
  return ((READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY)) ? 1UL : 0UL);
 802e806:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802e80a:	6818      	ldr	r0, [r3, #0]
}
 802e80c:	f3c0 6040 	ubfx	r0, r0, #25, #1
 802e810:	4770      	bx	lr
	...

0802e814 <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  MSI_Range  MSI range value from @ref RCC_MSIRANGE_0 to @ref RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t MSI_Range)
{
 802e814:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  return (uint32_t)(READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPRE) << 4);
 802e816:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
  uint32_t flash_clksrcfreq;
  uint32_t msifreq;

  /* MSI frequency range in Hz */
  msifreq           = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSIRANGESEL_RUN, MSI_Range);
  flash_clksrcfreq  = __LL_RCC_CALC_HCLK3_FREQ(msifreq, LL_RCC_GetAHB3Prescaler());
 802e81a:	4a2c      	ldr	r2, [pc, #176]	; (802e8cc <RCC_SetFlashLatencyFromMSIRange+0xb8>)
 802e81c:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
  msifreq           = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSIRANGESEL_RUN, MSI_Range);
 802e820:	f3c0 1003 	ubfx	r0, r0, #4, #4
  flash_clksrcfreq  = __LL_RCC_CALC_HCLK3_FREQ(msifreq, LL_RCC_GetAHB3Prescaler());
 802e824:	f003 030f 	and.w	r3, r3, #15
 802e828:	f852 4020 	ldr.w	r4, [r2, r0, lsl #2]
 802e82c:	4a28      	ldr	r2, [pc, #160]	; (802e8d0 <RCC_SetFlashLatencyFromMSIRange+0xbc>)
 802e82e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 802e832:	fbb4 f4f3 	udiv	r4, r4, r3

  return RCC_SetFlashLatency((flash_clksrcfreq / MEGA_HZ), HAL_PWREx_GetVoltageRange());
 802e836:	f7ff ff7d 	bl	802e734 <HAL_PWREx_GetVoltageRange>

  /* Flash Clock source (HCLK3) range in MHz for VCORE range2 */
  const uint16_t FLASH_CLK_SRC_RANGE_VOS2[] = {6, 12, 16};

  /* Flash Latency range */
  const uint32_t FLASH_LATENCY_RANGE[] = {FLASH_LATENCY_0, FLASH_LATENCY_1, FLASH_LATENCY_2};
 802e83a:	4b26      	ldr	r3, [pc, #152]	; (802e8d4 <RCC_SetFlashLatencyFromMSIRange+0xc0>)
  return RCC_SetFlashLatency((flash_clksrcfreq / MEGA_HZ), HAL_PWREx_GetVoltageRange());
 802e83c:	4605      	mov	r5, r0
  const uint32_t FLASH_LATENCY_RANGE[] = {FLASH_LATENCY_0, FLASH_LATENCY_1, FLASH_LATENCY_2};
 802e83e:	e893 0007 	ldmia.w	r3, {r0, r1, r2}

  uint32_t latency   = FLASH_LATENCY_0;  /* default value 0WS */
  uint32_t tickstart;

  if (VCORE_Voltage == PWR_REGULATOR_VOLTAGE_SCALE1)
 802e842:	f5b5 7f00 	cmp.w	r5, #512	; 0x200
  const uint32_t FLASH_LATENCY_RANGE[] = {FLASH_LATENCY_0, FLASH_LATENCY_1, FLASH_LATENCY_2};
 802e846:	ab04      	add	r3, sp, #16
 802e848:	e903 0007 	stmdb	r3, {r0, r1, r2}
  if (VCORE_Voltage == PWR_REGULATOR_VOLTAGE_SCALE1)
 802e84c:	d010      	beq.n	802e870 <RCC_SetFlashLatencyFromMSIRange+0x5c>
  }
  else  /* PWR_REGULATOR_VOLTAGE_SCALE2 */
  {
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
    {
      if (Flash_ClkSrcFreq <= FLASH_CLK_SRC_RANGE_VOS2[index])
 802e84e:	4b22      	ldr	r3, [pc, #136]	; (802e8d8 <RCC_SetFlashLatencyFromMSIRange+0xc4>)
 802e850:	429c      	cmp	r4, r3
 802e852:	d318      	bcc.n	802e886 <RCC_SetFlashLatencyFromMSIRange+0x72>
 802e854:	f503 03b7 	add.w	r3, r3, #5996544	; 0x5b8000
 802e858:	f603 537f 	addw	r3, r3, #3455	; 0xd7f
 802e85c:	429c      	cmp	r4, r3
 802e85e:	d929      	bls.n	802e8b4 <RCC_SetFlashLatencyFromMSIRange+0xa0>
 802e860:	f503 1374 	add.w	r3, r3, #3997696	; 0x3d0000
 802e864:	f503 6310 	add.w	r3, r3, #2304	; 0x900
      if (Flash_ClkSrcFreq <= FLASH_CLK_SRC_RANGE_VOS1[index])
 802e868:	429c      	cmp	r4, r3
 802e86a:	d825      	bhi.n	802e8b8 <RCC_SetFlashLatencyFromMSIRange+0xa4>
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
 802e86c:	2302      	movs	r3, #2
 802e86e:	e00b      	b.n	802e888 <RCC_SetFlashLatencyFromMSIRange+0x74>
      if (Flash_ClkSrcFreq <= FLASH_CLK_SRC_RANGE_VOS1[index])
 802e870:	4b1a      	ldr	r3, [pc, #104]	; (802e8dc <RCC_SetFlashLatencyFromMSIRange+0xc8>)
 802e872:	429c      	cmp	r4, r3
 802e874:	d907      	bls.n	802e886 <RCC_SetFlashLatencyFromMSIRange+0x72>
 802e876:	4b1a      	ldr	r3, [pc, #104]	; (802e8e0 <RCC_SetFlashLatencyFromMSIRange+0xcc>)
 802e878:	429c      	cmp	r4, r3
 802e87a:	d91b      	bls.n	802e8b4 <RCC_SetFlashLatencyFromMSIRange+0xa0>
 802e87c:	f503 0337 	add.w	r3, r3, #11993088	; 0xb70000
 802e880:	f503 53d8 	add.w	r3, r3, #6912	; 0x1b00
 802e884:	e7f0      	b.n	802e868 <RCC_SetFlashLatencyFromMSIRange+0x54>
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
 802e886:	2300      	movs	r3, #0
      {
        latency = FLASH_LATENCY_RANGE[index];
 802e888:	aa04      	add	r2, sp, #16
 802e88a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 802e88e:	f853 4c0c 	ldr.w	r4, [r3, #-12]
        break;
      }
    }
  }

  __HAL_FLASH_SET_LATENCY(latency);
 802e892:	4d14      	ldr	r5, [pc, #80]	; (802e8e4 <RCC_SetFlashLatencyFromMSIRange+0xd0>)
 802e894:	682b      	ldr	r3, [r5, #0]
 802e896:	f023 0307 	bic.w	r3, r3, #7
 802e89a:	4323      	orrs	r3, r4
 802e89c:	602b      	str	r3, [r5, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 802e89e:	f7fd fed1 	bl	802c644 <HAL_GetTick>
 802e8a2:	4606      	mov	r6, r0

  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  while (__HAL_FLASH_GET_LATENCY() != latency)
 802e8a4:	682b      	ldr	r3, [r5, #0]
 802e8a6:	f003 0307 	and.w	r3, r3, #7
 802e8aa:	429c      	cmp	r4, r3
 802e8ac:	d106      	bne.n	802e8bc <RCC_SetFlashLatencyFromMSIRange+0xa8>
    if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
    {
      return HAL_TIMEOUT;
    }
  }
  return HAL_OK;
 802e8ae:	2000      	movs	r0, #0
}
 802e8b0:	b004      	add	sp, #16
 802e8b2:	bd70      	pop	{r4, r5, r6, pc}
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
 802e8b4:	2301      	movs	r3, #1
 802e8b6:	e7e7      	b.n	802e888 <RCC_SetFlashLatencyFromMSIRange+0x74>
  uint32_t latency   = FLASH_LATENCY_0;  /* default value 0WS */
 802e8b8:	2400      	movs	r4, #0
 802e8ba:	e7ea      	b.n	802e892 <RCC_SetFlashLatencyFromMSIRange+0x7e>
    if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 802e8bc:	f7fd fec2 	bl	802c644 <HAL_GetTick>
 802e8c0:	1b80      	subs	r0, r0, r6
 802e8c2:	2802      	cmp	r0, #2
 802e8c4:	d9ee      	bls.n	802e8a4 <RCC_SetFlashLatencyFromMSIRange+0x90>
      return HAL_TIMEOUT;
 802e8c6:	2003      	movs	r0, #3
 802e8c8:	e7f2      	b.n	802e8b0 <RCC_SetFlashLatencyFromMSIRange+0x9c>
 802e8ca:	bf00      	nop
 802e8cc:	0803b96c 	.word	0x0803b96c
 802e8d0:	0803b9ac 	.word	0x0803b9ac
 802e8d4:	0803ba0c 	.word	0x0803ba0c
 802e8d8:	006acfc0 	.word	0x006acfc0
 802e8dc:	0121eabf 	.word	0x0121eabf
 802e8e0:	0234933f 	.word	0x0234933f
 802e8e4:	58004000 	.word	0x58004000

0802e8e8 <HAL_RCC_GetSysClockFreq>:
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 802e8e8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
{
 802e8ec:	b510      	push	{r4, lr}
 802e8ee:	689a      	ldr	r2, [r3, #8]
  *         @arg @ref LL_RCC_PLLSOURCE_HSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetMainSource(void)
{
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 802e8f0:	68d9      	ldr	r1, [r3, #12]
  if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 802e8f2:	f012 020c 	ands.w	r2, r2, #12
 802e8f6:	d005      	beq.n	802e904 <HAL_RCC_GetSysClockFreq+0x1c>
 802e8f8:	2a0c      	cmp	r2, #12
 802e8fa:	d14a      	bne.n	802e992 <HAL_RCC_GetSysClockFreq+0xaa>
 802e8fc:	f001 0303 	and.w	r3, r1, #3
      ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pllsource == RCC_PLLSOURCE_MSI)))
 802e900:	2b01      	cmp	r3, #1
 802e902:	d150      	bne.n	802e9a6 <HAL_RCC_GetSysClockFreq+0xbe>
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == (RCC_CR_MSIRGSEL)) ? 1UL : 0UL);
 802e904:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 802e908:	482b      	ldr	r0, [pc, #172]	; (802e9b8 <HAL_RCC_GetSysClockFreq+0xd0>)
 802e90a:	680b      	ldr	r3, [r1, #0]
 802e90c:	f013 0308 	ands.w	r3, r3, #8
 802e910:	d006      	beq.n	802e920 <HAL_RCC_GetSysClockFreq+0x38>
 802e912:	680b      	ldr	r3, [r1, #0]
 802e914:	f013 0308 	ands.w	r3, r3, #8
 802e918:	d137      	bne.n	802e98a <HAL_RCC_GetSysClockFreq+0xa2>
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 802e91a:	f8d1 1094 	ldr.w	r1, [r1, #148]	; 0x94
 802e91e:	e007      	b.n	802e930 <HAL_RCC_GetSysClockFreq+0x48>
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == (RCC_CR_MSIRGSEL)) ? 1UL : 0UL);
 802e920:	680c      	ldr	r4, [r1, #0]
 802e922:	0724      	lsls	r4, r4, #28
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 802e924:	bf56      	itet	pl
 802e926:	f8d1 3094 	ldrpl.w	r3, [r1, #148]	; 0x94
  return (uint32_t)(READ_BIT(RCC->CR, RCC_CR_MSIRANGE));
 802e92a:	6809      	ldrmi	r1, [r1, #0]
    msifreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
 802e92c:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 802e930:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
      sysclockfreq = msifreq;
 802e934:	2a00      	cmp	r2, #0
 802e936:	bf0c      	ite	eq
 802e938:	4618      	moveq	r0, r3
 802e93a:	2000      	movne	r0, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 802e93c:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 802e940:	688a      	ldr	r2, [r1, #8]
 802e942:	f002 020c 	and.w	r2, r2, #12
  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 802e946:	2a0c      	cmp	r2, #12
 802e948:	d11e      	bne.n	802e988 <HAL_RCC_GetSysClockFreq+0xa0>
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 802e94a:	68ca      	ldr	r2, [r1, #12]
 802e94c:	f002 0203 	and.w	r2, r2, #3
    switch (pllsource)
 802e950:	2a02      	cmp	r2, #2
 802e952:	d02e      	beq.n	802e9b2 <HAL_RCC_GetSysClockFreq+0xca>
 802e954:	2a03      	cmp	r2, #3
 802e956:	d106      	bne.n	802e966 <HAL_RCC_GetSysClockFreq+0x7e>
  return ((READ_BIT(RCC->CR, RCC_CR_HSEPRE) == (RCC_CR_HSEPRE)) ? 1UL : 0UL);
 802e958:	680b      	ldr	r3, [r1, #0]
          pllinputfreq = HSE_VALUE / 2U;
 802e95a:	4818      	ldr	r0, [pc, #96]	; (802e9bc <HAL_RCC_GetSysClockFreq+0xd4>)
 802e95c:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 802e960:	4b17      	ldr	r3, [pc, #92]	; (802e9c0 <HAL_RCC_GetSysClockFreq+0xd8>)
 802e962:	bf18      	it	ne
 802e964:	4603      	movne	r3, r0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 802e966:	f04f 40b0 	mov.w	r0, #1476395008	; 0x58000000
 802e96a:	68c1      	ldr	r1, [r0, #12]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM));
 802e96c:	68c2      	ldr	r2, [r0, #12]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR));
 802e96e:	68c0      	ldr	r0, [r0, #12]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 802e970:	f3c1 2106 	ubfx	r1, r1, #8, #7
    sysclockfreq = __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
 802e974:	f3c2 1202 	ubfx	r2, r2, #4, #3
 802e978:	0f40      	lsrs	r0, r0, #29
 802e97a:	434b      	muls	r3, r1
 802e97c:	3201      	adds	r2, #1
 802e97e:	3001      	adds	r0, #1
 802e980:	fbb3 f3f2 	udiv	r3, r3, r2
 802e984:	fbb3 f0f0 	udiv	r0, r3, r0
}
 802e988:	bd10      	pop	{r4, pc}
  return (uint32_t)(READ_BIT(RCC->CR, RCC_CR_MSIRANGE));
 802e98a:	680b      	ldr	r3, [r1, #0]
    msifreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
 802e98c:	f3c3 1303 	ubfx	r3, r3, #4, #4
 802e990:	e7ce      	b.n	802e930 <HAL_RCC_GetSysClockFreq+0x48>
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI)
 802e992:	2a04      	cmp	r2, #4
 802e994:	d00a      	beq.n	802e9ac <HAL_RCC_GetSysClockFreq+0xc4>
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 802e996:	2a08      	cmp	r2, #8
 802e998:	d105      	bne.n	802e9a6 <HAL_RCC_GetSysClockFreq+0xbe>
  return ((READ_BIT(RCC->CR, RCC_CR_HSEPRE) == (RCC_CR_HSEPRE)) ? 1UL : 0UL);
 802e99a:	681b      	ldr	r3, [r3, #0]
 802e99c:	f413 1380 	ands.w	r3, r3, #1048576	; 0x100000
 802e9a0:	d104      	bne.n	802e9ac <HAL_RCC_GetSysClockFreq+0xc4>
      sysclockfreq = HSE_VALUE;
 802e9a2:	4807      	ldr	r0, [pc, #28]	; (802e9c0 <HAL_RCC_GetSysClockFreq+0xd8>)
 802e9a4:	e7ca      	b.n	802e93c <HAL_RCC_GetSysClockFreq+0x54>
  uint32_t msifreq = 0U;
 802e9a6:	2300      	movs	r3, #0
  uint32_t sysclockfreq = 0U;
 802e9a8:	4618      	mov	r0, r3
 802e9aa:	e7c7      	b.n	802e93c <HAL_RCC_GetSysClockFreq+0x54>
      sysclockfreq = HSE_VALUE / 2U;
 802e9ac:	4803      	ldr	r0, [pc, #12]	; (802e9bc <HAL_RCC_GetSysClockFreq+0xd4>)
  uint32_t msifreq = 0U;
 802e9ae:	2300      	movs	r3, #0
 802e9b0:	e7c4      	b.n	802e93c <HAL_RCC_GetSysClockFreq+0x54>
        pllinputfreq = HSI_VALUE;
 802e9b2:	4b02      	ldr	r3, [pc, #8]	; (802e9bc <HAL_RCC_GetSysClockFreq+0xd4>)
 802e9b4:	e7d7      	b.n	802e966 <HAL_RCC_GetSysClockFreq+0x7e>
 802e9b6:	bf00      	nop
 802e9b8:	0803b96c 	.word	0x0803b96c
 802e9bc:	00f42400 	.word	0x00f42400
 802e9c0:	01e84800 	.word	0x01e84800

0802e9c4 <HAL_RCC_GetHCLKFreq>:
{
 802e9c4:	b508      	push	{r3, lr}
  return ((uint32_t)(__LL_RCC_CALC_HCLK1_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler())));
 802e9c6:	f7ff ff8f 	bl	802e8e8 <HAL_RCC_GetSysClockFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
 802e9ca:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802e9ce:	4a04      	ldr	r2, [pc, #16]	; (802e9e0 <HAL_RCC_GetHCLKFreq+0x1c>)
 802e9d0:	689b      	ldr	r3, [r3, #8]
 802e9d2:	f3c3 1303 	ubfx	r3, r3, #4, #4
 802e9d6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
}
 802e9da:	fbb0 f0f3 	udiv	r0, r0, r3
 802e9de:	bd08      	pop	{r3, pc}
 802e9e0:	0803b9ac 	.word	0x0803b9ac

0802e9e4 <HAL_RCC_OscConfig>:
{
 802e9e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (RCC_OscInitStruct == NULL)
 802e9e8:	4604      	mov	r4, r0
 802e9ea:	2800      	cmp	r0, #0
 802e9ec:	d055      	beq.n	802ea9a <HAL_RCC_OscConfig+0xb6>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 802e9ee:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802e9f2:	689e      	ldr	r6, [r3, #8]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 802e9f4:	68dd      	ldr	r5, [r3, #12]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 802e9f6:	6803      	ldr	r3, [r0, #0]
 802e9f8:	0699      	lsls	r1, r3, #26
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 802e9fa:	f006 060c 	and.w	r6, r6, #12
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 802e9fe:	f005 0503 	and.w	r5, r5, #3
 802ea02:	d56b      	bpl.n	802eadc <HAL_RCC_OscConfig+0xf8>
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 802ea04:	b11e      	cbz	r6, 802ea0e <HAL_RCC_OscConfig+0x2a>
 802ea06:	2e0c      	cmp	r6, #12
 802ea08:	d149      	bne.n	802ea9e <HAL_RCC_OscConfig+0xba>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_MSI)))
 802ea0a:	2d01      	cmp	r5, #1
 802ea0c:	d147      	bne.n	802ea9e <HAL_RCC_OscConfig+0xba>
      if ((LL_RCC_MSI_IsReady() != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 802ea0e:	f7ff feeb 	bl	802e7e8 <LL_RCC_MSI_IsReady>
 802ea12:	b110      	cbz	r0, 802ea1a <HAL_RCC_OscConfig+0x36>
 802ea14:	6a23      	ldr	r3, [r4, #32]
 802ea16:	2b00      	cmp	r3, #0
 802ea18:	d03f      	beq.n	802ea9a <HAL_RCC_OscConfig+0xb6>
        if (RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 802ea1a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802ea1e:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 802ea20:	681a      	ldr	r2, [r3, #0]
 802ea22:	0712      	lsls	r2, r2, #28
 802ea24:	bf56      	itet	pl
 802ea26:	f8d3 3094 	ldrpl.w	r3, [r3, #148]	; 0x94
 802ea2a:	681b      	ldrmi	r3, [r3, #0]
 802ea2c:	091b      	lsrpl	r3, r3, #4
 802ea2e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 802ea32:	4298      	cmp	r0, r3
 802ea34:	d91e      	bls.n	802ea74 <HAL_RCC_OscConfig+0x90>
          if (RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 802ea36:	f7ff feed 	bl	802e814 <RCC_SetFlashLatencyFromMSIRange>
 802ea3a:	2800      	cmp	r0, #0
 802ea3c:	d12d      	bne.n	802ea9a <HAL_RCC_OscConfig+0xb6>
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 802ea3e:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 802ea42:	6813      	ldr	r3, [r2, #0]
 802ea44:	f043 0308 	orr.w	r3, r3, #8
 802ea48:	6013      	str	r3, [r2, #0]
 802ea4a:	6813      	ldr	r3, [r2, #0]
 802ea4c:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 802ea4e:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 802ea52:	430b      	orrs	r3, r1
 802ea54:	6013      	str	r3, [r2, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 802ea56:	6a60      	ldr	r0, [r4, #36]	; 0x24
 802ea58:	f7ff fecc 	bl	802e7f4 <LL_RCC_MSI_SetCalibTrimming>
        SystemCoreClock = HAL_RCC_GetHCLKFreq();
 802ea5c:	f7ff ffb2 	bl	802e9c4 <HAL_RCC_GetHCLKFreq>
 802ea60:	4bac      	ldr	r3, [pc, #688]	; (802ed14 <HAL_RCC_OscConfig+0x330>)
 802ea62:	6018      	str	r0, [r3, #0]
        status = HAL_InitTick(uwTickPrio);
 802ea64:	4bac      	ldr	r3, [pc, #688]	; (802ed18 <HAL_RCC_OscConfig+0x334>)
 802ea66:	6818      	ldr	r0, [r3, #0]
 802ea68:	f7fd fdea 	bl	802c640 <HAL_InitTick>
        if (status != HAL_OK)
 802ea6c:	2800      	cmp	r0, #0
 802ea6e:	d035      	beq.n	802eadc <HAL_RCC_OscConfig+0xf8>
}
 802ea70:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 802ea74:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 802ea78:	6813      	ldr	r3, [r2, #0]
 802ea7a:	f043 0308 	orr.w	r3, r3, #8
 802ea7e:	6013      	str	r3, [r2, #0]
 802ea80:	6813      	ldr	r3, [r2, #0]
 802ea82:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 802ea86:	4303      	orrs	r3, r0
 802ea88:	6013      	str	r3, [r2, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 802ea8a:	6a60      	ldr	r0, [r4, #36]	; 0x24
 802ea8c:	f7ff feb2 	bl	802e7f4 <LL_RCC_MSI_SetCalibTrimming>
          if (RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 802ea90:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 802ea92:	f7ff febf 	bl	802e814 <RCC_SetFlashLatencyFromMSIRange>
 802ea96:	2800      	cmp	r0, #0
 802ea98:	d0e0      	beq.n	802ea5c <HAL_RCC_OscConfig+0x78>
          return HAL_ERROR;
 802ea9a:	2001      	movs	r0, #1
 802ea9c:	e7e8      	b.n	802ea70 <HAL_RCC_OscConfig+0x8c>
      if (RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 802ea9e:	6a22      	ldr	r2, [r4, #32]
 802eaa0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802eaa4:	2a00      	cmp	r2, #0
 802eaa6:	d054      	beq.n	802eb52 <HAL_RCC_OscConfig+0x16e>
  SET_BIT(RCC->CR, RCC_CR_MSION);
 802eaa8:	681a      	ldr	r2, [r3, #0]
 802eaaa:	f042 0201 	orr.w	r2, r2, #1
 802eaae:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 802eab0:	f7fd fdc8 	bl	802c644 <HAL_GetTick>
 802eab4:	4607      	mov	r7, r0
        while (LL_RCC_MSI_IsReady() == 0U)
 802eab6:	f7ff fe97 	bl	802e7e8 <LL_RCC_MSI_IsReady>
 802eaba:	2800      	cmp	r0, #0
 802eabc:	d042      	beq.n	802eb44 <HAL_RCC_OscConfig+0x160>
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 802eabe:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 802eac2:	6813      	ldr	r3, [r2, #0]
 802eac4:	f043 0308 	orr.w	r3, r3, #8
 802eac8:	6013      	str	r3, [r2, #0]
 802eaca:	6813      	ldr	r3, [r2, #0]
 802eacc:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 802eace:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 802ead2:	430b      	orrs	r3, r1
 802ead4:	6013      	str	r3, [r2, #0]
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 802ead6:	6a60      	ldr	r0, [r4, #36]	; 0x24
 802ead8:	f7ff fe8c 	bl	802e7f4 <LL_RCC_MSI_SetCalibTrimming>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 802eadc:	6823      	ldr	r3, [r4, #0]
 802eade:	07db      	lsls	r3, r3, #31
 802eae0:	d448      	bmi.n	802eb74 <HAL_RCC_OscConfig+0x190>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 802eae2:	6823      	ldr	r3, [r4, #0]
 802eae4:	079f      	lsls	r7, r3, #30
 802eae6:	f100 8090 	bmi.w	802ec0a <HAL_RCC_OscConfig+0x226>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 802eaea:	6823      	ldr	r3, [r4, #0]
 802eaec:	071d      	lsls	r5, r3, #28
 802eaee:	f140 80fc 	bpl.w	802ecea <HAL_RCC_OscConfig+0x306>
    if (RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 802eaf2:	69a3      	ldr	r3, [r4, #24]
 802eaf4:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
 802eaf8:	2b00      	cmp	r3, #0
 802eafa:	f000 80e3 	beq.w	802ecc4 <HAL_RCC_OscConfig+0x2e0>
      uint32_t csr_temp = RCC->CSR;
 802eafe:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
      if (RCC_OscInitStruct->LSIDiv != (csr_temp & RCC_CSR_LSIPRE))
 802eb02:	69e1      	ldr	r1, [r4, #28]
 802eb04:	f003 0210 	and.w	r2, r3, #16
 802eb08:	4291      	cmp	r1, r2
 802eb0a:	f000 80c6 	beq.w	802ec9a <HAL_RCC_OscConfig+0x2b6>
        if (((csr_temp & RCC_CSR_LSIRDY) == RCC_CSR_LSIRDY) && \
 802eb0e:	f003 0203 	and.w	r2, r3, #3
 802eb12:	2a02      	cmp	r2, #2
 802eb14:	d0c1      	beq.n	802ea9a <HAL_RCC_OscConfig+0xb6>
        if ((csr_temp & RCC_CSR_LSION) == RCC_CSR_LSION)
 802eb16:	07d8      	lsls	r0, r3, #31
 802eb18:	f140 80b5 	bpl.w	802ec86 <HAL_RCC_OscConfig+0x2a2>
  CLEAR_BIT(RCC->CSR, RCC_CSR_LSION);
 802eb1c:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 802eb20:	f023 0301 	bic.w	r3, r3, #1
 802eb24:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94
          tickstart = HAL_GetTick();
 802eb28:	f7fd fd8c 	bl	802c644 <HAL_GetTick>
 802eb2c:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == (RCC_CSR_LSIRDY)) ? 1UL : 0UL);
 802eb2e:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 802eb32:	0799      	lsls	r1, r3, #30
 802eb34:	f140 80a7 	bpl.w	802ec86 <HAL_RCC_OscConfig+0x2a2>
            if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 802eb38:	f7fd fd84 	bl	802c644 <HAL_GetTick>
 802eb3c:	1bc3      	subs	r3, r0, r7
 802eb3e:	2b11      	cmp	r3, #17
 802eb40:	d9f5      	bls.n	802eb2e <HAL_RCC_OscConfig+0x14a>
 802eb42:	e004      	b.n	802eb4e <HAL_RCC_OscConfig+0x16a>
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 802eb44:	f7fd fd7e 	bl	802c644 <HAL_GetTick>
 802eb48:	1bc0      	subs	r0, r0, r7
 802eb4a:	2802      	cmp	r0, #2
 802eb4c:	d9b3      	bls.n	802eab6 <HAL_RCC_OscConfig+0xd2>
            return HAL_TIMEOUT;
 802eb4e:	2003      	movs	r0, #3
 802eb50:	e78e      	b.n	802ea70 <HAL_RCC_OscConfig+0x8c>
  CLEAR_BIT(RCC->CR, RCC_CR_MSION);
 802eb52:	681a      	ldr	r2, [r3, #0]
 802eb54:	f022 0201 	bic.w	r2, r2, #1
 802eb58:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 802eb5a:	f7fd fd73 	bl	802c644 <HAL_GetTick>
 802eb5e:	4607      	mov	r7, r0
        while (LL_RCC_MSI_IsReady() != 0U)
 802eb60:	f7ff fe42 	bl	802e7e8 <LL_RCC_MSI_IsReady>
 802eb64:	2800      	cmp	r0, #0
 802eb66:	d0b9      	beq.n	802eadc <HAL_RCC_OscConfig+0xf8>
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 802eb68:	f7fd fd6c 	bl	802c644 <HAL_GetTick>
 802eb6c:	1bc0      	subs	r0, r0, r7
 802eb6e:	2802      	cmp	r0, #2
 802eb70:	d9f6      	bls.n	802eb60 <HAL_RCC_OscConfig+0x17c>
 802eb72:	e7ec      	b.n	802eb4e <HAL_RCC_OscConfig+0x16a>
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE) ||
 802eb74:	2e08      	cmp	r6, #8
 802eb76:	d003      	beq.n	802eb80 <HAL_RCC_OscConfig+0x19c>
 802eb78:	2e0c      	cmp	r6, #12
 802eb7a:	d109      	bne.n	802eb90 <HAL_RCC_OscConfig+0x1ac>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSE)))
 802eb7c:	2d03      	cmp	r5, #3
 802eb7e:	d107      	bne.n	802eb90 <HAL_RCC_OscConfig+0x1ac>
      if ((LL_RCC_HSE_IsReady() != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 802eb80:	f7ff fe26 	bl	802e7d0 <LL_RCC_HSE_IsReady>
 802eb84:	2800      	cmp	r0, #0
 802eb86:	d0ac      	beq.n	802eae2 <HAL_RCC_OscConfig+0xfe>
 802eb88:	6863      	ldr	r3, [r4, #4]
 802eb8a:	2b00      	cmp	r3, #0
 802eb8c:	d1a9      	bne.n	802eae2 <HAL_RCC_OscConfig+0xfe>
 802eb8e:	e784      	b.n	802ea9a <HAL_RCC_OscConfig+0xb6>
      MODIFY_REG(RCC->CR, RCC_CR_HSEPRE, RCC_OscInitStruct->HSEDiv);
 802eb90:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802eb94:	68a1      	ldr	r1, [r4, #8]
 802eb96:	681a      	ldr	r2, [r3, #0]
 802eb98:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 802eb9c:	430a      	orrs	r2, r1
 802eb9e:	601a      	str	r2, [r3, #0]
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 802eba0:	6862      	ldr	r2, [r4, #4]
 802eba2:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 802eba6:	d110      	bne.n	802ebca <HAL_RCC_OscConfig+0x1e6>
  SET_BIT(RCC->CR, RCC_CR_HSEON);
 802eba8:	681a      	ldr	r2, [r3, #0]
 802ebaa:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 802ebae:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 802ebb0:	f7fd fd48 	bl	802c644 <HAL_GetTick>
 802ebb4:	4607      	mov	r7, r0
        while (LL_RCC_HSE_IsReady() == 0U)
 802ebb6:	f7ff fe0b 	bl	802e7d0 <LL_RCC_HSE_IsReady>
 802ebba:	2800      	cmp	r0, #0
 802ebbc:	d191      	bne.n	802eae2 <HAL_RCC_OscConfig+0xfe>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 802ebbe:	f7fd fd41 	bl	802c644 <HAL_GetTick>
 802ebc2:	1bc0      	subs	r0, r0, r7
 802ebc4:	2864      	cmp	r0, #100	; 0x64
 802ebc6:	d9f6      	bls.n	802ebb6 <HAL_RCC_OscConfig+0x1d2>
 802ebc8:	e7c1      	b.n	802eb4e <HAL_RCC_OscConfig+0x16a>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 802ebca:	f5b2 1f04 	cmp.w	r2, #2162688	; 0x210000
 802ebce:	d104      	bne.n	802ebda <HAL_RCC_OscConfig+0x1f6>
  SET_BIT(RCC->CR, RCC_CR_HSEBYPPWR);
 802ebd0:	681a      	ldr	r2, [r3, #0]
 802ebd2:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 802ebd6:	601a      	str	r2, [r3, #0]
 802ebd8:	e7e6      	b.n	802eba8 <HAL_RCC_OscConfig+0x1c4>
  CLEAR_BIT(RCC->CR, RCC_CR_HSEON);
 802ebda:	6819      	ldr	r1, [r3, #0]
 802ebdc:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 802ebe0:	6019      	str	r1, [r3, #0]
  CLEAR_BIT(RCC->CR, RCC_CR_HSEBYPPWR);
 802ebe2:	6819      	ldr	r1, [r3, #0]
 802ebe4:	f421 1100 	bic.w	r1, r1, #2097152	; 0x200000
 802ebe8:	6019      	str	r1, [r3, #0]
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 802ebea:	2a00      	cmp	r2, #0
 802ebec:	d1e0      	bne.n	802ebb0 <HAL_RCC_OscConfig+0x1cc>
        tickstart = HAL_GetTick();
 802ebee:	f7fd fd29 	bl	802c644 <HAL_GetTick>
 802ebf2:	4607      	mov	r7, r0
        while (LL_RCC_HSE_IsReady() != 0U)
 802ebf4:	f7ff fdec 	bl	802e7d0 <LL_RCC_HSE_IsReady>
 802ebf8:	2800      	cmp	r0, #0
 802ebfa:	f43f af72 	beq.w	802eae2 <HAL_RCC_OscConfig+0xfe>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 802ebfe:	f7fd fd21 	bl	802c644 <HAL_GetTick>
 802ec02:	1bc0      	subs	r0, r0, r7
 802ec04:	2864      	cmp	r0, #100	; 0x64
 802ec06:	d9f5      	bls.n	802ebf4 <HAL_RCC_OscConfig+0x210>
 802ec08:	e7a1      	b.n	802eb4e <HAL_RCC_OscConfig+0x16a>
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI) ||
 802ec0a:	2e04      	cmp	r6, #4
 802ec0c:	d003      	beq.n	802ec16 <HAL_RCC_OscConfig+0x232>
 802ec0e:	2e0c      	cmp	r6, #12
 802ec10:	d112      	bne.n	802ec38 <HAL_RCC_OscConfig+0x254>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSI)))
 802ec12:	2d02      	cmp	r5, #2
 802ec14:	d110      	bne.n	802ec38 <HAL_RCC_OscConfig+0x254>
      if ((LL_RCC_HSI_IsReady() != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 802ec16:	f7ff fde1 	bl	802e7dc <LL_RCC_HSI_IsReady>
 802ec1a:	b118      	cbz	r0, 802ec24 <HAL_RCC_OscConfig+0x240>
 802ec1c:	6923      	ldr	r3, [r4, #16]
 802ec1e:	2b00      	cmp	r3, #0
 802ec20:	f43f af3b 	beq.w	802ea9a <HAL_RCC_OscConfig+0xb6>
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_HSITRIM, Value << RCC_ICSCR_HSITRIM_Pos);
 802ec24:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 802ec28:	6961      	ldr	r1, [r4, #20]
 802ec2a:	6853      	ldr	r3, [r2, #4]
 802ec2c:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 802ec30:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 802ec34:	6053      	str	r3, [r2, #4]
}
 802ec36:	e758      	b.n	802eaea <HAL_RCC_OscConfig+0x106>
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 802ec38:	6922      	ldr	r2, [r4, #16]
 802ec3a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802ec3e:	b182      	cbz	r2, 802ec62 <HAL_RCC_OscConfig+0x27e>
  SET_BIT(RCC->CR, RCC_CR_HSION);
 802ec40:	681a      	ldr	r2, [r3, #0]
 802ec42:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 802ec46:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 802ec48:	f7fd fcfc 	bl	802c644 <HAL_GetTick>
 802ec4c:	4605      	mov	r5, r0
        while (LL_RCC_HSI_IsReady() == 0U)
 802ec4e:	f7ff fdc5 	bl	802e7dc <LL_RCC_HSI_IsReady>
 802ec52:	2800      	cmp	r0, #0
 802ec54:	d1e6      	bne.n	802ec24 <HAL_RCC_OscConfig+0x240>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 802ec56:	f7fd fcf5 	bl	802c644 <HAL_GetTick>
 802ec5a:	1b40      	subs	r0, r0, r5
 802ec5c:	2802      	cmp	r0, #2
 802ec5e:	d9f6      	bls.n	802ec4e <HAL_RCC_OscConfig+0x26a>
 802ec60:	e775      	b.n	802eb4e <HAL_RCC_OscConfig+0x16a>
  CLEAR_BIT(RCC->CR, RCC_CR_HSION);
 802ec62:	681a      	ldr	r2, [r3, #0]
 802ec64:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 802ec68:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 802ec6a:	f7fd fceb 	bl	802c644 <HAL_GetTick>
 802ec6e:	4605      	mov	r5, r0
        while (LL_RCC_HSI_IsReady() != 0U)
 802ec70:	f7ff fdb4 	bl	802e7dc <LL_RCC_HSI_IsReady>
 802ec74:	2800      	cmp	r0, #0
 802ec76:	f43f af38 	beq.w	802eaea <HAL_RCC_OscConfig+0x106>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 802ec7a:	f7fd fce3 	bl	802c644 <HAL_GetTick>
 802ec7e:	1b40      	subs	r0, r0, r5
 802ec80:	2802      	cmp	r0, #2
 802ec82:	d9f5      	bls.n	802ec70 <HAL_RCC_OscConfig+0x28c>
 802ec84:	e763      	b.n	802eb4e <HAL_RCC_OscConfig+0x16a>
        MODIFY_REG(RCC->CSR, RCC_CSR_LSIPRE, RCC_OscInitStruct->LSIDiv);
 802ec86:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 802ec8a:	69e1      	ldr	r1, [r4, #28]
 802ec8c:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
 802ec90:	f023 0310 	bic.w	r3, r3, #16
 802ec94:	430b      	orrs	r3, r1
 802ec96:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
  SET_BIT(RCC->CSR, RCC_CSR_LSION);
 802ec9a:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
 802ec9e:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 802eca2:	f043 0301 	orr.w	r3, r3, #1
 802eca6:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94
      tickstart = HAL_GetTick();
 802ecaa:	f7fd fccb 	bl	802c644 <HAL_GetTick>
 802ecae:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == (RCC_CSR_LSIRDY)) ? 1UL : 0UL);
 802ecb0:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 802ecb4:	079a      	lsls	r2, r3, #30
 802ecb6:	d418      	bmi.n	802ecea <HAL_RCC_OscConfig+0x306>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 802ecb8:	f7fd fcc4 	bl	802c644 <HAL_GetTick>
 802ecbc:	1bc3      	subs	r3, r0, r7
 802ecbe:	2b11      	cmp	r3, #17
 802ecc0:	d9f6      	bls.n	802ecb0 <HAL_RCC_OscConfig+0x2cc>
 802ecc2:	e744      	b.n	802eb4e <HAL_RCC_OscConfig+0x16a>
  CLEAR_BIT(RCC->CSR, RCC_CSR_LSION);
 802ecc4:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 802ecc8:	f023 0301 	bic.w	r3, r3, #1
 802eccc:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94
      tickstart = HAL_GetTick();
 802ecd0:	f7fd fcb8 	bl	802c644 <HAL_GetTick>
 802ecd4:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == (RCC_CSR_LSIRDY)) ? 1UL : 0UL);
 802ecd6:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 802ecda:	079b      	lsls	r3, r3, #30
 802ecdc:	d505      	bpl.n	802ecea <HAL_RCC_OscConfig+0x306>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 802ecde:	f7fd fcb1 	bl	802c644 <HAL_GetTick>
 802ece2:	1bc3      	subs	r3, r0, r7
 802ece4:	2b11      	cmp	r3, #17
 802ece6:	d9f6      	bls.n	802ecd6 <HAL_RCC_OscConfig+0x2f2>
 802ece8:	e731      	b.n	802eb4e <HAL_RCC_OscConfig+0x16a>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 802ecea:	6823      	ldr	r3, [r4, #0]
 802ecec:	0758      	lsls	r0, r3, #29
 802ecee:	d553      	bpl.n	802ed98 <HAL_RCC_OscConfig+0x3b4>
  return ((READ_BIT(PWR->CR1, PWR_CR1_DBP) == (PWR_CR1_DBP)) ? 1UL : 0UL);
 802ecf0:	4d0a      	ldr	r5, [pc, #40]	; (802ed1c <HAL_RCC_OscConfig+0x338>)
 802ecf2:	682b      	ldr	r3, [r5, #0]
 802ecf4:	05d9      	lsls	r1, r3, #23
 802ecf6:	d413      	bmi.n	802ed20 <HAL_RCC_OscConfig+0x33c>
      HAL_PWR_EnableBkUpAccess();
 802ecf8:	f7ff fcf4 	bl	802e6e4 <HAL_PWR_EnableBkUpAccess>
      tickstart = HAL_GetTick();
 802ecfc:	f7fd fca2 	bl	802c644 <HAL_GetTick>
 802ed00:	4607      	mov	r7, r0
 802ed02:	682b      	ldr	r3, [r5, #0]
 802ed04:	05da      	lsls	r2, r3, #23
 802ed06:	d40b      	bmi.n	802ed20 <HAL_RCC_OscConfig+0x33c>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 802ed08:	f7fd fc9c 	bl	802c644 <HAL_GetTick>
 802ed0c:	1bc3      	subs	r3, r0, r7
 802ed0e:	2b02      	cmp	r3, #2
 802ed10:	d9f7      	bls.n	802ed02 <HAL_RCC_OscConfig+0x31e>
 802ed12:	e71c      	b.n	802eb4e <HAL_RCC_OscConfig+0x16a>
 802ed14:	2000344c 	.word	0x2000344c
 802ed18:	20003454 	.word	0x20003454
 802ed1c:	58000400 	.word	0x58000400
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 802ed20:	68e3      	ldr	r3, [r4, #12]
 802ed22:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
 802ed26:	2b00      	cmp	r3, #0
 802ed28:	d058      	beq.n	802eddc <HAL_RCC_OscConfig+0x3f8>
          || (RCC_OscInitStruct->LSEState == RCC_LSE_BYPASS_RTC_ONLY))
 802ed2a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 802ed2e:	2b05      	cmp	r3, #5
        SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
 802ed30:	bf02      	ittt	eq
 802ed32:	f8d5 3090 	ldreq.w	r3, [r5, #144]	; 0x90
 802ed36:	f043 0304 	orreq.w	r3, r3, #4
 802ed3a:	f8c5 3090 	streq.w	r3, [r5, #144]	; 0x90
      SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 802ed3e:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
      tickstart = HAL_GetTick();
 802ed42:	f7fd fc7f 	bl	802c644 <HAL_GetTick>
      SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 802ed46:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802ed4a:	f043 0301 	orr.w	r3, r3, #1
      tickstart = HAL_GetTick();
 802ed4e:	4607      	mov	r7, r0
      SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 802ed50:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802ed54:	f241 3888 	movw	r8, #5000	; 0x1388
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? 1UL : 0UL);
 802ed58:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802ed5c:	079b      	lsls	r3, r3, #30
 802ed5e:	d405      	bmi.n	802ed6c <HAL_RCC_OscConfig+0x388>
 802ed60:	f7fd fc70 	bl	802c644 <HAL_GetTick>
 802ed64:	1bc3      	subs	r3, r0, r7
 802ed66:	4543      	cmp	r3, r8
 802ed68:	d9f6      	bls.n	802ed58 <HAL_RCC_OscConfig+0x374>
 802ed6a:	e6f0      	b.n	802eb4e <HAL_RCC_OscConfig+0x16a>
      if ((RCC_OscInitStruct->LSEState == RCC_LSE_ON)
 802ed6c:	68e3      	ldr	r3, [r4, #12]
 802ed6e:	f023 0304 	bic.w	r3, r3, #4
 802ed72:	2b81      	cmp	r3, #129	; 0x81
 802ed74:	d11b      	bne.n	802edae <HAL_RCC_OscConfig+0x3ca>
        tickstart = HAL_GetTick();
 802ed76:	f7fd fc65 	bl	802c644 <HAL_GetTick>
        SET_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 802ed7a:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802ed7e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 802ed82:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        tickstart = HAL_GetTick();
 802ed86:	4607      	mov	r7, r0
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) == 0U)
 802ed88:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802ed8c:	f241 3888 	movw	r8, #5000	; 0x1388
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) == 0U)
 802ed90:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802ed94:	0518      	lsls	r0, r3, #20
 802ed96:	d504      	bpl.n	802eda2 <HAL_RCC_OscConfig+0x3be>
  if (RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 802ed98:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 802ed9a:	2800      	cmp	r0, #0
 802ed9c:	d14a      	bne.n	802ee34 <HAL_RCC_OscConfig+0x450>
  return HAL_OK;
 802ed9e:	2000      	movs	r0, #0
 802eda0:	e666      	b.n	802ea70 <HAL_RCC_OscConfig+0x8c>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802eda2:	f7fd fc4f 	bl	802c644 <HAL_GetTick>
 802eda6:	1bc0      	subs	r0, r0, r7
 802eda8:	4540      	cmp	r0, r8
 802edaa:	d9f1      	bls.n	802ed90 <HAL_RCC_OscConfig+0x3ac>
 802edac:	e6cf      	b.n	802eb4e <HAL_RCC_OscConfig+0x16a>
        tickstart = HAL_GetTick();
 802edae:	f7fd fc49 	bl	802c644 <HAL_GetTick>
        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 802edb2:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802edb6:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 802edba:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        tickstart = HAL_GetTick();
 802edbe:	4607      	mov	r7, r0
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 802edc0:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802edc4:	f241 3888 	movw	r8, #5000	; 0x1388
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 802edc8:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802edcc:	0519      	lsls	r1, r3, #20
 802edce:	d5e3      	bpl.n	802ed98 <HAL_RCC_OscConfig+0x3b4>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802edd0:	f7fd fc38 	bl	802c644 <HAL_GetTick>
 802edd4:	1bc0      	subs	r0, r0, r7
 802edd6:	4540      	cmp	r0, r8
 802edd8:	d9f6      	bls.n	802edc8 <HAL_RCC_OscConfig+0x3e4>
 802edda:	e6b8      	b.n	802eb4e <HAL_RCC_OscConfig+0x16a>
      tickstart = HAL_GetTick();
 802eddc:	f7fd fc32 	bl	802c644 <HAL_GetTick>
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 802ede0:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802ede4:	f023 0380 	bic.w	r3, r3, #128	; 0x80
      tickstart = HAL_GetTick();
 802ede8:	4607      	mov	r7, r0
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 802edea:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802edee:	f241 3888 	movw	r8, #5000	; 0x1388
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 802edf2:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802edf6:	051a      	lsls	r2, r3, #20
 802edf8:	d416      	bmi.n	802ee28 <HAL_RCC_OscConfig+0x444>
      tickstart = HAL_GetTick();
 802edfa:	f7fd fc23 	bl	802c644 <HAL_GetTick>
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 802edfe:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 802ee02:	f023 0301 	bic.w	r3, r3, #1
 802ee06:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
      tickstart = HAL_GetTick();
 802ee0a:	4607      	mov	r7, r0
 802ee0c:	f04f 48b0 	mov.w	r8, #1476395008	; 0x58000000
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802ee10:	f241 3588 	movw	r5, #5000	; 0x1388
 802ee14:	f8d8 3090 	ldr.w	r3, [r8, #144]	; 0x90
 802ee18:	079b      	lsls	r3, r3, #30
 802ee1a:	d5bd      	bpl.n	802ed98 <HAL_RCC_OscConfig+0x3b4>
 802ee1c:	f7fd fc12 	bl	802c644 <HAL_GetTick>
 802ee20:	1bc3      	subs	r3, r0, r7
 802ee22:	42ab      	cmp	r3, r5
 802ee24:	d9f6      	bls.n	802ee14 <HAL_RCC_OscConfig+0x430>
 802ee26:	e692      	b.n	802eb4e <HAL_RCC_OscConfig+0x16a>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802ee28:	f7fd fc0c 	bl	802c644 <HAL_GetTick>
 802ee2c:	1bc0      	subs	r0, r0, r7
 802ee2e:	4540      	cmp	r0, r8
 802ee30:	d9df      	bls.n	802edf2 <HAL_RCC_OscConfig+0x40e>
 802ee32:	e68c      	b.n	802eb4e <HAL_RCC_OscConfig+0x16a>
    if (sysclk_source != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 802ee34:	2e0c      	cmp	r6, #12
 802ee36:	d053      	beq.n	802eee0 <HAL_RCC_OscConfig+0x4fc>
      if (RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 802ee38:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802ee3c:	2802      	cmp	r0, #2
  CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
 802ee3e:	681a      	ldr	r2, [r3, #0]
 802ee40:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 802ee44:	601a      	str	r2, [r3, #0]
 802ee46:	d133      	bne.n	802eeb0 <HAL_RCC_OscConfig+0x4cc>
        tickstart = HAL_GetTick();
 802ee48:	f7fd fbfc 	bl	802c644 <HAL_GetTick>
 802ee4c:	4605      	mov	r5, r0
        while (LL_RCC_PLL_IsReady() != 0U)
 802ee4e:	f7ff fcda 	bl	802e806 <LL_RCC_PLL_IsReady>
 802ee52:	bb38      	cbnz	r0, 802eea4 <HAL_RCC_OscConfig+0x4c0>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 802ee54:	e9d4 310c 	ldrd	r3, r1, [r4, #48]	; 0x30
 802ee58:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 802ee5c:	430b      	orrs	r3, r1
 802ee5e:	68d0      	ldr	r0, [r2, #12]
 802ee60:	492f      	ldr	r1, [pc, #188]	; (802ef20 <HAL_RCC_OscConfig+0x53c>)
 802ee62:	4001      	ands	r1, r0
 802ee64:	430b      	orrs	r3, r1
 802ee66:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 802ee68:	430b      	orrs	r3, r1
 802ee6a:	6c21      	ldr	r1, [r4, #64]	; 0x40
 802ee6c:	430b      	orrs	r3, r1
 802ee6e:	6c61      	ldr	r1, [r4, #68]	; 0x44
 802ee70:	430b      	orrs	r3, r1
 802ee72:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 802ee74:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 802ee78:	60d3      	str	r3, [r2, #12]
  SET_BIT(RCC->CR, RCC_CR_PLLON);
 802ee7a:	6813      	ldr	r3, [r2, #0]
 802ee7c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 802ee80:	6013      	str	r3, [r2, #0]
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 802ee82:	68d3      	ldr	r3, [r2, #12]
 802ee84:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 802ee88:	60d3      	str	r3, [r2, #12]
        tickstart = HAL_GetTick();
 802ee8a:	f7fd fbdb 	bl	802c644 <HAL_GetTick>
 802ee8e:	4604      	mov	r4, r0
        while (LL_RCC_PLL_IsReady() == 0U)
 802ee90:	f7ff fcb9 	bl	802e806 <LL_RCC_PLL_IsReady>
 802ee94:	2800      	cmp	r0, #0
 802ee96:	d182      	bne.n	802ed9e <HAL_RCC_OscConfig+0x3ba>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 802ee98:	f7fd fbd4 	bl	802c644 <HAL_GetTick>
 802ee9c:	1b00      	subs	r0, r0, r4
 802ee9e:	280a      	cmp	r0, #10
 802eea0:	d9f6      	bls.n	802ee90 <HAL_RCC_OscConfig+0x4ac>
 802eea2:	e654      	b.n	802eb4e <HAL_RCC_OscConfig+0x16a>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 802eea4:	f7fd fbce 	bl	802c644 <HAL_GetTick>
 802eea8:	1b40      	subs	r0, r0, r5
 802eeaa:	280a      	cmp	r0, #10
 802eeac:	d9cf      	bls.n	802ee4e <HAL_RCC_OscConfig+0x46a>
 802eeae:	e64e      	b.n	802eb4e <HAL_RCC_OscConfig+0x16a>
        MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PLLSOURCE_NONE);
 802eeb0:	68da      	ldr	r2, [r3, #12]
 802eeb2:	f022 0203 	bic.w	r2, r2, #3
 802eeb6:	60da      	str	r2, [r3, #12]
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_RNGCLK | RCC_PLL_ADCCLK);
 802eeb8:	68da      	ldr	r2, [r3, #12]
 802eeba:	f022 5288 	bic.w	r2, r2, #285212672	; 0x11000000
 802eebe:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 802eec2:	60da      	str	r2, [r3, #12]
        tickstart = HAL_GetTick();
 802eec4:	f7fd fbbe 	bl	802c644 <HAL_GetTick>
 802eec8:	4604      	mov	r4, r0
        while (LL_RCC_PLL_IsReady() != 0U)
 802eeca:	f7ff fc9c 	bl	802e806 <LL_RCC_PLL_IsReady>
 802eece:	2800      	cmp	r0, #0
 802eed0:	f43f af65 	beq.w	802ed9e <HAL_RCC_OscConfig+0x3ba>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 802eed4:	f7fd fbb6 	bl	802c644 <HAL_GetTick>
 802eed8:	1b00      	subs	r0, r0, r4
 802eeda:	280a      	cmp	r0, #10
 802eedc:	d9f5      	bls.n	802eeca <HAL_RCC_OscConfig+0x4e6>
 802eede:	e636      	b.n	802eb4e <HAL_RCC_OscConfig+0x16a>
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 802eee0:	2801      	cmp	r0, #1
 802eee2:	f43f adc5 	beq.w	802ea70 <HAL_RCC_OscConfig+0x8c>
        pll_config = RCC->PLLCFGR;
 802eee6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
        if ((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource)
 802eeea:	6b22      	ldr	r2, [r4, #48]	; 0x30
        pll_config = RCC->PLLCFGR;
 802eeec:	68db      	ldr	r3, [r3, #12]
        if ((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource)
 802eeee:	f003 0103 	and.w	r1, r3, #3
 802eef2:	4291      	cmp	r1, r2
 802eef4:	f47f add1 	bne.w	802ea9a <HAL_RCC_OscConfig+0xb6>
            || (READ_BIT(pll_config, RCC_PLLCFGR_PLLM)   != RCC_OscInitStruct->PLL.PLLM)
 802eef8:	6b61      	ldr	r1, [r4, #52]	; 0x34
 802eefa:	f003 0270 	and.w	r2, r3, #112	; 0x70
 802eefe:	428a      	cmp	r2, r1
 802ef00:	f47f adcb 	bne.w	802ea9a <HAL_RCC_OscConfig+0xb6>
            || (READ_BIT(pll_config, RCC_PLLCFGR_PLLN)   != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos))
 802ef04:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 802ef06:	f403 42fe 	and.w	r2, r3, #32512	; 0x7f00
 802ef0a:	ebb2 2f01 	cmp.w	r2, r1, lsl #8
 802ef0e:	f47f adc4 	bne.w	802ea9a <HAL_RCC_OscConfig+0xb6>
            || (READ_BIT(pll_config, RCC_PLLCFGR_PLLR)   != RCC_OscInitStruct->PLL.PLLR))
 802ef12:	6c62      	ldr	r2, [r4, #68]	; 0x44
 802ef14:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
 802ef18:	4293      	cmp	r3, r2
 802ef1a:	f43f af40 	beq.w	802ed9e <HAL_RCC_OscConfig+0x3ba>
 802ef1e:	e5bc      	b.n	802ea9a <HAL_RCC_OscConfig+0xb6>
 802ef20:	11c1808c 	.word	0x11c1808c

0802ef24 <HAL_RCC_ClockConfig>:
{
 802ef24:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802ef28:	460d      	mov	r5, r1
  if (RCC_ClkInitStruct == NULL)
 802ef2a:	4604      	mov	r4, r0
 802ef2c:	b910      	cbnz	r0, 802ef34 <HAL_RCC_ClockConfig+0x10>
    return HAL_ERROR;
 802ef2e:	2001      	movs	r0, #1
}
 802ef30:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 802ef34:	4e74      	ldr	r6, [pc, #464]	; (802f108 <HAL_RCC_ClockConfig+0x1e4>)
 802ef36:	6833      	ldr	r3, [r6, #0]
 802ef38:	f003 0307 	and.w	r3, r3, #7
 802ef3c:	428b      	cmp	r3, r1
 802ef3e:	d316      	bcc.n	802ef6e <HAL_RCC_ClockConfig+0x4a>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 802ef40:	6823      	ldr	r3, [r4, #0]
 802ef42:	079a      	lsls	r2, r3, #30
 802ef44:	d527      	bpl.n	802ef96 <HAL_RCC_ClockConfig+0x72>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
 802ef46:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
 802ef4a:	68a2      	ldr	r2, [r4, #8]
 802ef4c:	68b3      	ldr	r3, [r6, #8]
 802ef4e:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 802ef52:	4313      	orrs	r3, r2
 802ef54:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 802ef56:	f7fd fb75 	bl	802c644 <HAL_GetTick>
 802ef5a:	4607      	mov	r7, r0
  * @rmtoll CFGR         HPREF       LL_RCC_IsActiveFlag_HPRE
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_HPRE(void)
{
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_HPREF) == (RCC_CFGR_HPREF)) ? 1UL : 0UL);
 802ef5c:	68b3      	ldr	r3, [r6, #8]
 802ef5e:	03db      	lsls	r3, r3, #15
 802ef60:	d419      	bmi.n	802ef96 <HAL_RCC_ClockConfig+0x72>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 802ef62:	f7fd fb6f 	bl	802c644 <HAL_GetTick>
 802ef66:	1bc3      	subs	r3, r0, r7
 802ef68:	2b02      	cmp	r3, #2
 802ef6a:	d9f7      	bls.n	802ef5c <HAL_RCC_ClockConfig+0x38>
 802ef6c:	e011      	b.n	802ef92 <HAL_RCC_ClockConfig+0x6e>
    __HAL_FLASH_SET_LATENCY(FLatency);
 802ef6e:	6833      	ldr	r3, [r6, #0]
 802ef70:	f023 0307 	bic.w	r3, r3, #7
 802ef74:	430b      	orrs	r3, r1
 802ef76:	6033      	str	r3, [r6, #0]
    tickstart = HAL_GetTick();
 802ef78:	f7fd fb64 	bl	802c644 <HAL_GetTick>
 802ef7c:	4607      	mov	r7, r0
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 802ef7e:	6833      	ldr	r3, [r6, #0]
 802ef80:	f003 0307 	and.w	r3, r3, #7
 802ef84:	42ab      	cmp	r3, r5
 802ef86:	d0db      	beq.n	802ef40 <HAL_RCC_ClockConfig+0x1c>
      if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 802ef88:	f7fd fb5c 	bl	802c644 <HAL_GetTick>
 802ef8c:	1bc0      	subs	r0, r0, r7
 802ef8e:	2802      	cmp	r0, #2
 802ef90:	d9f5      	bls.n	802ef7e <HAL_RCC_ClockConfig+0x5a>
        return HAL_TIMEOUT;
 802ef92:	2003      	movs	r0, #3
 802ef94:	e7cc      	b.n	802ef30 <HAL_RCC_ClockConfig+0xc>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK2) == RCC_CLOCKTYPE_HCLK2)
 802ef96:	6823      	ldr	r3, [r4, #0]
 802ef98:	0698      	lsls	r0, r3, #26
 802ef9a:	d516      	bpl.n	802efca <HAL_RCC_ClockConfig+0xa6>
  MODIFY_REG(RCC->EXTCFGR, RCC_EXTCFGR_C2HPRE, Prescaler);
 802ef9c:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
 802efa0:	6962      	ldr	r2, [r4, #20]
 802efa2:	f8d6 3108 	ldr.w	r3, [r6, #264]	; 0x108
 802efa6:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 802efaa:	4313      	orrs	r3, r2
 802efac:	f8c6 3108 	str.w	r3, [r6, #264]	; 0x108
    tickstart = HAL_GetTick();
 802efb0:	f7fd fb48 	bl	802c644 <HAL_GetTick>
 802efb4:	4607      	mov	r7, r0
  * @rmtoll EXTCFGR         C2HPREF       LL_RCC_IsActiveFlag_C2HPRE
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_C2HPRE(void)
{
  return ((READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_C2HPREF) == (RCC_EXTCFGR_C2HPREF)) ? 1UL : 0UL);
 802efb6:	f8d6 3108 	ldr.w	r3, [r6, #264]	; 0x108
 802efba:	0399      	lsls	r1, r3, #14
 802efbc:	d405      	bmi.n	802efca <HAL_RCC_ClockConfig+0xa6>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 802efbe:	f7fd fb41 	bl	802c644 <HAL_GetTick>
 802efc2:	1bc3      	subs	r3, r0, r7
 802efc4:	2b02      	cmp	r3, #2
 802efc6:	d9f6      	bls.n	802efb6 <HAL_RCC_ClockConfig+0x92>
 802efc8:	e7e3      	b.n	802ef92 <HAL_RCC_ClockConfig+0x6e>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK3) == RCC_CLOCKTYPE_HCLK3)
 802efca:	6823      	ldr	r3, [r4, #0]
 802efcc:	065a      	lsls	r2, r3, #25
 802efce:	d517      	bpl.n	802f000 <HAL_RCC_ClockConfig+0xdc>
  MODIFY_REG(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPRE, Prescaler >> 4);
 802efd0:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
 802efd4:	69a2      	ldr	r2, [r4, #24]
 802efd6:	f8d6 3108 	ldr.w	r3, [r6, #264]	; 0x108
 802efda:	f023 030f 	bic.w	r3, r3, #15
 802efde:	ea43 1312 	orr.w	r3, r3, r2, lsr #4
 802efe2:	f8c6 3108 	str.w	r3, [r6, #264]	; 0x108
    tickstart = HAL_GetTick();
 802efe6:	f7fd fb2d 	bl	802c644 <HAL_GetTick>
 802efea:	4607      	mov	r7, r0
  * @rmtoll EXTCFGR         SHDHPREF       LL_RCC_IsActiveFlag_SHDHPRE
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_SHDHPRE(void)
{
  return ((READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPREF) == (RCC_EXTCFGR_SHDHPREF)) ? 1UL : 0UL);
 802efec:	f8d6 3108 	ldr.w	r3, [r6, #264]	; 0x108
 802eff0:	03db      	lsls	r3, r3, #15
 802eff2:	d405      	bmi.n	802f000 <HAL_RCC_ClockConfig+0xdc>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 802eff4:	f7fd fb26 	bl	802c644 <HAL_GetTick>
 802eff8:	1bc3      	subs	r3, r0, r7
 802effa:	2b02      	cmp	r3, #2
 802effc:	d9f6      	bls.n	802efec <HAL_RCC_ClockConfig+0xc8>
 802effe:	e7c8      	b.n	802ef92 <HAL_RCC_ClockConfig+0x6e>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 802f000:	6823      	ldr	r3, [r4, #0]
 802f002:	075e      	lsls	r6, r3, #29
 802f004:	d513      	bpl.n	802f02e <HAL_RCC_ClockConfig+0x10a>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, Prescaler);
 802f006:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
 802f00a:	68e2      	ldr	r2, [r4, #12]
 802f00c:	68b3      	ldr	r3, [r6, #8]
 802f00e:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 802f012:	4313      	orrs	r3, r2
 802f014:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 802f016:	f7fd fb15 	bl	802c644 <HAL_GetTick>
 802f01a:	4607      	mov	r7, r0
  * @rmtoll CFGR         PPRE1F       LL_RCC_IsActiveFlag_PPRE1
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_PPRE1(void)
{
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1F) == (RCC_CFGR_PPRE1F)) ? 1UL : 0UL);
 802f01c:	68b3      	ldr	r3, [r6, #8]
 802f01e:	0398      	lsls	r0, r3, #14
 802f020:	d405      	bmi.n	802f02e <HAL_RCC_ClockConfig+0x10a>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 802f022:	f7fd fb0f 	bl	802c644 <HAL_GetTick>
 802f026:	1bc3      	subs	r3, r0, r7
 802f028:	2b02      	cmp	r3, #2
 802f02a:	d9f7      	bls.n	802f01c <HAL_RCC_ClockConfig+0xf8>
 802f02c:	e7b1      	b.n	802ef92 <HAL_RCC_ClockConfig+0x6e>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 802f02e:	6823      	ldr	r3, [r4, #0]
 802f030:	0719      	lsls	r1, r3, #28
 802f032:	d514      	bpl.n	802f05e <HAL_RCC_ClockConfig+0x13a>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, Prescaler);
 802f034:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
    LL_RCC_SetAPB2Prescaler((RCC_ClkInitStruct->APB2CLKDivider) << 3U);
 802f038:	6922      	ldr	r2, [r4, #16]
 802f03a:	68b3      	ldr	r3, [r6, #8]
 802f03c:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 802f040:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 802f044:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 802f046:	f7fd fafd 	bl	802c644 <HAL_GetTick>
 802f04a:	4607      	mov	r7, r0
  * @rmtoll CFGR         PPRE2F       LL_RCC_IsActiveFlag_PPRE2
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_PPRE2(void)
{
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2F) == (RCC_CFGR_PPRE2F)) ? 1UL : 0UL);
 802f04c:	68b3      	ldr	r3, [r6, #8]
 802f04e:	035a      	lsls	r2, r3, #13
 802f050:	d405      	bmi.n	802f05e <HAL_RCC_ClockConfig+0x13a>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 802f052:	f7fd faf7 	bl	802c644 <HAL_GetTick>
 802f056:	1bc3      	subs	r3, r0, r7
 802f058:	2b02      	cmp	r3, #2
 802f05a:	d9f7      	bls.n	802f04c <HAL_RCC_ClockConfig+0x128>
 802f05c:	e799      	b.n	802ef92 <HAL_RCC_ClockConfig+0x6e>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 802f05e:	6823      	ldr	r3, [r4, #0]
 802f060:	07db      	lsls	r3, r3, #31
 802f062:	d40f      	bmi.n	802f084 <HAL_RCC_ClockConfig+0x160>
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 802f064:	4c28      	ldr	r4, [pc, #160]	; (802f108 <HAL_RCC_ClockConfig+0x1e4>)
 802f066:	6823      	ldr	r3, [r4, #0]
 802f068:	f003 0307 	and.w	r3, r3, #7
 802f06c:	42ab      	cmp	r3, r5
 802f06e:	d837      	bhi.n	802f0e0 <HAL_RCC_ClockConfig+0x1bc>
  SystemCoreClock = HAL_RCC_GetHCLKFreq();
 802f070:	f7ff fca8 	bl	802e9c4 <HAL_RCC_GetHCLKFreq>
 802f074:	4b25      	ldr	r3, [pc, #148]	; (802f10c <HAL_RCC_ClockConfig+0x1e8>)
 802f076:	6018      	str	r0, [r3, #0]
  return HAL_InitTick(uwTickPrio);
 802f078:	4b25      	ldr	r3, [pc, #148]	; (802f110 <HAL_RCC_ClockConfig+0x1ec>)
}
 802f07a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  return HAL_InitTick(uwTickPrio);
 802f07e:	6818      	ldr	r0, [r3, #0]
 802f080:	f7fd bade 	b.w	802c640 <HAL_InitTick>
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 802f084:	6863      	ldr	r3, [r4, #4]
 802f086:	2b02      	cmp	r3, #2
 802f088:	d11e      	bne.n	802f0c8 <HAL_RCC_ClockConfig+0x1a4>
      if (LL_RCC_HSE_IsReady() == 0U)
 802f08a:	f7ff fba1 	bl	802e7d0 <LL_RCC_HSE_IsReady>
      if (LL_RCC_HSI_IsReady() == 0U)
 802f08e:	2800      	cmp	r0, #0
 802f090:	f43f af4d 	beq.w	802ef2e <HAL_RCC_ClockConfig+0xa>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
 802f094:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
 802f098:	6862      	ldr	r2, [r4, #4]
 802f09a:	68b3      	ldr	r3, [r6, #8]
 802f09c:	f023 0303 	bic.w	r3, r3, #3
 802f0a0:	4313      	orrs	r3, r2
 802f0a2:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 802f0a4:	f7fd face 	bl	802c644 <HAL_GetTick>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 802f0a8:	f241 3888 	movw	r8, #5000	; 0x1388
    tickstart = HAL_GetTick();
 802f0ac:	4607      	mov	r7, r0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 802f0ae:	68b3      	ldr	r3, [r6, #8]
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 802f0b0:	6862      	ldr	r2, [r4, #4]
 802f0b2:	f003 030c 	and.w	r3, r3, #12
 802f0b6:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 802f0ba:	d0d3      	beq.n	802f064 <HAL_RCC_ClockConfig+0x140>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 802f0bc:	f7fd fac2 	bl	802c644 <HAL_GetTick>
 802f0c0:	1bc0      	subs	r0, r0, r7
 802f0c2:	4540      	cmp	r0, r8
 802f0c4:	d9f3      	bls.n	802f0ae <HAL_RCC_ClockConfig+0x18a>
 802f0c6:	e764      	b.n	802ef92 <HAL_RCC_ClockConfig+0x6e>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 802f0c8:	2b03      	cmp	r3, #3
 802f0ca:	d102      	bne.n	802f0d2 <HAL_RCC_ClockConfig+0x1ae>
      if (LL_RCC_PLL_IsReady() == 0U)
 802f0cc:	f7ff fb9b 	bl	802e806 <LL_RCC_PLL_IsReady>
 802f0d0:	e7dd      	b.n	802f08e <HAL_RCC_ClockConfig+0x16a>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 802f0d2:	b913      	cbnz	r3, 802f0da <HAL_RCC_ClockConfig+0x1b6>
      if (LL_RCC_MSI_IsReady() == 0U)
 802f0d4:	f7ff fb88 	bl	802e7e8 <LL_RCC_MSI_IsReady>
 802f0d8:	e7d9      	b.n	802f08e <HAL_RCC_ClockConfig+0x16a>
      if (LL_RCC_HSI_IsReady() == 0U)
 802f0da:	f7ff fb7f 	bl	802e7dc <LL_RCC_HSI_IsReady>
 802f0de:	e7d6      	b.n	802f08e <HAL_RCC_ClockConfig+0x16a>
    __HAL_FLASH_SET_LATENCY(FLatency);
 802f0e0:	6823      	ldr	r3, [r4, #0]
 802f0e2:	f023 0307 	bic.w	r3, r3, #7
 802f0e6:	432b      	orrs	r3, r5
 802f0e8:	6023      	str	r3, [r4, #0]
    tickstart = HAL_GetTick();
 802f0ea:	f7fd faab 	bl	802c644 <HAL_GetTick>
 802f0ee:	4606      	mov	r6, r0
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 802f0f0:	6823      	ldr	r3, [r4, #0]
 802f0f2:	f003 0307 	and.w	r3, r3, #7
 802f0f6:	42ab      	cmp	r3, r5
 802f0f8:	d0ba      	beq.n	802f070 <HAL_RCC_ClockConfig+0x14c>
      if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 802f0fa:	f7fd faa3 	bl	802c644 <HAL_GetTick>
 802f0fe:	1b80      	subs	r0, r0, r6
 802f100:	2802      	cmp	r0, #2
 802f102:	d9f5      	bls.n	802f0f0 <HAL_RCC_ClockConfig+0x1cc>
 802f104:	e745      	b.n	802ef92 <HAL_RCC_ClockConfig+0x6e>
 802f106:	bf00      	nop
 802f108:	58004000 	.word	0x58004000
 802f10c:	2000344c 	.word	0x2000344c
 802f110:	20003454 	.word	0x20003454

0802f114 <HAL_RCC_GetPCLK1Freq>:
{
 802f114:	b508      	push	{r3, lr}
  return ((uint32_t)(__LL_RCC_CALC_PCLK1_FREQ(HAL_RCC_GetHCLKFreq(), LL_RCC_GetAPB1Prescaler())));
 802f116:	f7ff fc55 	bl	802e9c4 <HAL_RCC_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1));
 802f11a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802f11e:	4a04      	ldr	r2, [pc, #16]	; (802f130 <HAL_RCC_GetPCLK1Freq+0x1c>)
 802f120:	689b      	ldr	r3, [r3, #8]
 802f122:	f3c3 2302 	ubfx	r3, r3, #8, #3
 802f126:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
}
 802f12a:	40d8      	lsrs	r0, r3
 802f12c:	bd08      	pop	{r3, pc}
 802f12e:	bf00      	nop
 802f130:	0803b9ec 	.word	0x0803b9ec

0802f134 <HAL_RCC_GetPCLK2Freq>:
{
 802f134:	b508      	push	{r3, lr}
  return ((uint32_t)(__LL_RCC_CALC_PCLK2_FREQ(HAL_RCC_GetHCLKFreq(), LL_RCC_GetAPB2Prescaler())));
 802f136:	f7ff fc45 	bl	802e9c4 <HAL_RCC_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2));
 802f13a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802f13e:	4a04      	ldr	r2, [pc, #16]	; (802f150 <HAL_RCC_GetPCLK2Freq+0x1c>)
 802f140:	689b      	ldr	r3, [r3, #8]
 802f142:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 802f146:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
}
 802f14a:	40d8      	lsrs	r0, r3
 802f14c:	bd08      	pop	{r3, pc}
 802f14e:	bf00      	nop
 802f150:	0803b9ec 	.word	0x0803b9ec

0802f154 <LL_RCC_LSE_IsReady>:
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? 1UL : 0UL);
 802f154:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802f158:	f8d3 0090 	ldr.w	r0, [r3, #144]	; 0x90
}
 802f15c:	f3c0 0040 	ubfx	r0, r0, #1, #1
 802f160:	4770      	bx	lr

0802f162 <LL_RCC_SetI2CClockSource>:
  MODIFY_REG(RCC->CCIPR, ((I2CxSource >> 4) & 0x000FF000U), ((I2CxSource << 4) & 0x000FF000U));
 802f162:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 802f166:	0902      	lsrs	r2, r0, #4
 802f168:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 802f16c:	f402 227f 	and.w	r2, r2, #1044480	; 0xff000
 802f170:	0100      	lsls	r0, r0, #4
 802f172:	ea23 0302 	bic.w	r3, r3, r2
 802f176:	f400 207f 	and.w	r0, r0, #1044480	; 0xff000
 802f17a:	4318      	orrs	r0, r3
 802f17c:	f8c1 0088 	str.w	r0, [r1, #136]	; 0x88
}
 802f180:	4770      	bx	lr

0802f182 <LL_RCC_SetLPTIMClockSource>:
  MODIFY_REG(RCC->CCIPR, (LPTIMxSource & 0xFFFF0000U), (LPTIMxSource << 16));
 802f182:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 802f186:	0c02      	lsrs	r2, r0, #16
 802f188:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 802f18c:	0412      	lsls	r2, r2, #16
 802f18e:	ea23 0302 	bic.w	r3, r3, r2
 802f192:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 802f196:	f8c1 0088 	str.w	r0, [r1, #136]	; 0x88
}
 802f19a:	4770      	bx	lr

0802f19c <HAL_RCCEx_PeriphCLKConfig>:
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 802f19c:	b570      	push	{r4, r5, r6, lr}

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*-------------------------- RTC clock source configuration ----------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 802f19e:	6805      	ldr	r5, [r0, #0]
 802f1a0:	f415 3580 	ands.w	r5, r5, #65536	; 0x10000
{
 802f1a4:	4604      	mov	r4, r0
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 802f1a6:	d038      	beq.n	802f21a <HAL_RCCEx_PeriphCLKConfig+0x7e>
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));


    /* Enable write access to Backup domain */
    HAL_PWR_EnableBkUpAccess();
 802f1a8:	f7ff fa9c 	bl	802e6e4 <HAL_PWR_EnableBkUpAccess>

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 802f1ac:	f7fd fa4a 	bl	802c644 <HAL_GetTick>

    while (!(READ_BIT(PWR->CR1, PWR_CR1_DBP) == (PWR_CR1_DBP)))
 802f1b0:	4e64      	ldr	r6, [pc, #400]	; (802f344 <HAL_RCCEx_PeriphCLKConfig+0x1a8>)
    tickstart = HAL_GetTick();
 802f1b2:	4605      	mov	r5, r0
    while (!(READ_BIT(PWR->CR1, PWR_CR1_DBP) == (PWR_CR1_DBP)))
 802f1b4:	6833      	ldr	r3, [r6, #0]
 802f1b6:	05db      	lsls	r3, r3, #23
 802f1b8:	d529      	bpl.n	802f20e <HAL_RCCEx_PeriphCLKConfig+0x72>
  return (uint32_t)(READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL));
 802f1ba:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
    }

    if (ret == HAL_OK)
    {
      /* Reset the Backup domain only if the RTC Clock source selection is modified */
      if (LL_RCC_GetRTCClockSource() != PeriphClkInit->RTCClockSelection)
 802f1be:	6b61      	ldr	r1, [r4, #52]	; 0x34
 802f1c0:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 802f1c4:	f402 7240 	and.w	r2, r2, #768	; 0x300
 802f1c8:	4291      	cmp	r1, r2
 802f1ca:	d014      	beq.n	802f1f6 <HAL_RCCEx_PeriphCLKConfig+0x5a>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 802f1cc:	f8d3 1090 	ldr.w	r1, [r3, #144]	; 0x90
  SET_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 802f1d0:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 802f1d4:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 802f1d8:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 802f1dc:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 802f1e0:	f421 7040 	bic.w	r0, r1, #768	; 0x300
 802f1e4:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpregister;
      }

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSERDY))
 802f1e8:	078d      	lsls	r5, r1, #30
 802f1ea:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
        RCC->BDCR = tmpregister;
 802f1ee:	f8c3 0090 	str.w	r0, [r3, #144]	; 0x90
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSERDY))
 802f1f2:	f100 8096 	bmi.w	802f322 <HAL_RCCEx_PeriphCLKConfig+0x186>
  MODIFY_REG(RCC->BDCR, RCC_BDCR_RTCSEL, Source);
 802f1f6:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 802f1fa:	6b61      	ldr	r1, [r4, #52]	; 0x34
 802f1fc:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 802f200:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 802f204:	430b      	orrs	r3, r1
 802f206:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  HAL_StatusTypeDef status  = HAL_OK;   /* Final status */
 802f20a:	2500      	movs	r5, #0
}
 802f20c:	e005      	b.n	802f21a <HAL_RCCEx_PeriphCLKConfig+0x7e>
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 802f20e:	f7fd fa19 	bl	802c644 <HAL_GetTick>
 802f212:	1b40      	subs	r0, r0, r5
 802f214:	2802      	cmp	r0, #2
 802f216:	d9cd      	bls.n	802f1b4 <HAL_RCCEx_PeriphCLKConfig+0x18>
        ret = HAL_TIMEOUT;
 802f218:	2503      	movs	r5, #3
    }

  }

  /*-------------------- USART1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 802f21a:	6822      	ldr	r2, [r4, #0]
 802f21c:	07d0      	lsls	r0, r2, #31
 802f21e:	d50a      	bpl.n	802f236 <HAL_RCCEx_PeriphCLKConfig+0x9a>
  MODIFY_REG(RCC->CCIPR, (USARTxSource >> 16), (USARTxSource & 0x0000FFFFU));
 802f220:	f04f 40b0 	mov.w	r0, #1476395008	; 0x58000000
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 802f224:	6861      	ldr	r1, [r4, #4]
 802f226:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
 802f22a:	ea23 4311 	bic.w	r3, r3, r1, lsr #16
 802f22e:	b289      	uxth	r1, r1
 802f230:	430b      	orrs	r3, r1
 802f232:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
  }

  /*-------------------- USART2 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 802f236:	0791      	lsls	r1, r2, #30
 802f238:	d50a      	bpl.n	802f250 <HAL_RCCEx_PeriphCLKConfig+0xb4>
 802f23a:	f04f 40b0 	mov.w	r0, #1476395008	; 0x58000000
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 802f23e:	68a1      	ldr	r1, [r4, #8]
 802f240:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
 802f244:	ea23 4311 	bic.w	r3, r3, r1, lsr #16
 802f248:	b289      	uxth	r1, r1
 802f24a:	430b      	orrs	r3, r1
 802f24c:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
  }

  /*-------------------- LPUART1 clock source configuration ------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 802f250:	0693      	lsls	r3, r2, #26
 802f252:	d509      	bpl.n	802f268 <HAL_RCCEx_PeriphCLKConfig+0xcc>
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_LPUART1SEL, LPUARTxSource);
 802f254:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 802f258:	6920      	ldr	r0, [r4, #16]
 802f25a:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 802f25e:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 802f262:	4303      	orrs	r3, r0
 802f264:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
  }

  /*-------------------- LPTIM1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 802f268:	0596      	lsls	r6, r2, #22
 802f26a:	d502      	bpl.n	802f272 <HAL_RCCEx_PeriphCLKConfig+0xd6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));

    /* Configure the LPTIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 802f26c:	6a20      	ldr	r0, [r4, #32]
 802f26e:	f7ff ff88 	bl	802f182 <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------- LPTIM2 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 802f272:	6823      	ldr	r3, [r4, #0]
 802f274:	0558      	lsls	r0, r3, #21
 802f276:	d502      	bpl.n	802f27e <HAL_RCCEx_PeriphCLKConfig+0xe2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM2CLKSOURCE(PeriphClkInit->Lptim2ClockSelection));

    /* Configure the LPTIM2 clock source */
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 802f278:	6a60      	ldr	r0, [r4, #36]	; 0x24
 802f27a:	f7ff ff82 	bl	802f182 <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------- LPTIM3 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM3) == (RCC_PERIPHCLK_LPTIM3))
 802f27e:	6823      	ldr	r3, [r4, #0]
 802f280:	0519      	lsls	r1, r3, #20
 802f282:	d502      	bpl.n	802f28a <HAL_RCCEx_PeriphCLKConfig+0xee>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM3CLKSOURCE(PeriphClkInit->Lptim3ClockSelection));

    /* Configure the LPTIM3 clock source */
    __HAL_RCC_LPTIM3_CONFIG(PeriphClkInit->Lptim3ClockSelection);
 802f284:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 802f286:	f7ff ff7c 	bl	802f182 <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------- I2C1 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 802f28a:	6823      	ldr	r3, [r4, #0]
 802f28c:	065a      	lsls	r2, r3, #25
 802f28e:	d502      	bpl.n	802f296 <HAL_RCCEx_PeriphCLKConfig+0xfa>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 802f290:	6960      	ldr	r0, [r4, #20]
 802f292:	f7ff ff66 	bl	802f162 <LL_RCC_SetI2CClockSource>
  }

  /*-------------------- I2C2 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 802f296:	6823      	ldr	r3, [r4, #0]
 802f298:	061b      	lsls	r3, r3, #24
 802f29a:	d502      	bpl.n	802f2a2 <HAL_RCCEx_PeriphCLKConfig+0x106>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 802f29c:	69a0      	ldr	r0, [r4, #24]
 802f29e:	f7ff ff60 	bl	802f162 <LL_RCC_SetI2CClockSource>
  }

  /*-------------------- I2C3 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 802f2a2:	6823      	ldr	r3, [r4, #0]
 802f2a4:	05de      	lsls	r6, r3, #23
 802f2a6:	d502      	bpl.n	802f2ae <HAL_RCCEx_PeriphCLKConfig+0x112>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 802f2a8:	69e0      	ldr	r0, [r4, #28]
 802f2aa:	f7ff ff5a 	bl	802f162 <LL_RCC_SetI2CClockSource>
  }

  /*-------------------- I2S2 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S2) == (RCC_PERIPHCLK_I2S2))
 802f2ae:	6821      	ldr	r1, [r4, #0]
 802f2b0:	06c8      	lsls	r0, r1, #27
 802f2b2:	d510      	bpl.n	802f2d6 <HAL_RCCEx_PeriphCLKConfig+0x13a>
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_I2S2SEL, I2SxSource);
 802f2b4:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2S2CLKSOURCE(PeriphClkInit->I2s2ClockSelection));

    /* Configure the I2S2 clock source */
    __HAL_RCC_I2S2_CONFIG(PeriphClkInit->I2s2ClockSelection);
 802f2b8:	68e0      	ldr	r0, [r4, #12]
 802f2ba:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 802f2be:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 802f2c2:	4303      	orrs	r3, r0
 802f2c4:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

    if (PeriphClkInit->I2s2ClockSelection == RCC_I2S2CLKSOURCE_PLL)
 802f2c8:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
    {
      /* Enable RCC_PLL_I2S2CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_I2S2CLK);
 802f2cc:	bf02      	ittt	eq
 802f2ce:	68d3      	ldreq	r3, [r2, #12]
 802f2d0:	f043 7380 	orreq.w	r3, r3, #16777216	; 0x1000000
 802f2d4:	60d3      	streq	r3, [r2, #12]
    }
  }

  /*-------------------- RNG clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 802f2d6:	040a      	lsls	r2, r1, #16
 802f2d8:	d50e      	bpl.n	802f2f8 <HAL_RCCEx_PeriphCLKConfig+0x15c>
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_RNGSEL, RNGxSource);
 802f2da:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
  {
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 802f2de:	6b20      	ldr	r0, [r4, #48]	; 0x30
 802f2e0:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 802f2e4:	f023 4340 	bic.w	r3, r3, #3221225472	; 0xc0000000
 802f2e8:	4303      	orrs	r3, r0
 802f2ea:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

    if (PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 802f2ee:	b918      	cbnz	r0, 802f2f8 <HAL_RCCEx_PeriphCLKConfig+0x15c>
    {
      /* Enable RCC_PLL_RNGCLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_RNGCLK);
 802f2f0:	68d3      	ldr	r3, [r2, #12]
 802f2f2:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 802f2f6:	60d3      	str	r3, [r2, #12]
    }
  }

  /*-------------------- ADC clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 802f2f8:	044b      	lsls	r3, r1, #17
 802f2fa:	d510      	bpl.n	802f31e <HAL_RCCEx_PeriphCLKConfig+0x182>
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_ADCSEL, ADCxSource);
 802f2fc:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));

    /* Configure the ADC interface clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 802f300:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 802f302:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 802f306:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 802f30a:	430b      	orrs	r3, r1

    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLL)
 802f30c:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
 802f310:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
 802f314:	d103      	bne.n	802f31e <HAL_RCCEx_PeriphCLKConfig+0x182>
    {
      /* Enable RCC_PLL_RNGCLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_ADCCLK);
 802f316:	68d3      	ldr	r3, [r2, #12]
 802f318:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 802f31c:	60d3      	str	r3, [r2, #12]
    }
  }

  return status;
}
 802f31e:	4628      	mov	r0, r5
 802f320:	bd70      	pop	{r4, r5, r6, pc}
        tickstart = HAL_GetTick();
 802f322:	f7fd f98f 	bl	802c644 <HAL_GetTick>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802f326:	f241 3688 	movw	r6, #5000	; 0x1388
        tickstart = HAL_GetTick();
 802f32a:	4605      	mov	r5, r0
        while (LL_RCC_LSE_IsReady() != 1U)
 802f32c:	f7ff ff12 	bl	802f154 <LL_RCC_LSE_IsReady>
 802f330:	2801      	cmp	r0, #1
 802f332:	f43f af60 	beq.w	802f1f6 <HAL_RCCEx_PeriphCLKConfig+0x5a>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 802f336:	f7fd f985 	bl	802c644 <HAL_GetTick>
 802f33a:	1b40      	subs	r0, r0, r5
 802f33c:	42b0      	cmp	r0, r6
 802f33e:	d9f5      	bls.n	802f32c <HAL_RCCEx_PeriphCLKConfig+0x190>
 802f340:	e76a      	b.n	802f218 <HAL_RCCEx_PeriphCLKConfig+0x7c>
 802f342:	bf00      	nop
 802f344:	58000400 	.word	0x58000400

0802f348 <HAL_RTC_DeactivateAlarm>:
  *            @arg RTC_ALARM_A:  AlarmA
  *            @arg RTC_ALARM_B:  AlarmB
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_DeactivateAlarm(RTC_HandleTypeDef *hrtc, uint32_t Alarm)
{
 802f348:	b530      	push	{r4, r5, lr}
  /* Check the parameters */
  assert_param(IS_RTC_ALARM(Alarm));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 802f34a:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 802f34e:	2b01      	cmp	r3, #1
 802f350:	f04f 0202 	mov.w	r2, #2
 802f354:	d022      	beq.n	802f39c <HAL_RTC_DeactivateAlarm+0x54>

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f356:	4b19      	ldr	r3, [pc, #100]	; (802f3bc <HAL_RTC_DeactivateAlarm+0x74>)
  hrtc->State = HAL_RTC_STATE_BUSY;
 802f358:	f880 202d 	strb.w	r2, [r0, #45]	; 0x2d
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f35c:	24ca      	movs	r4, #202	; 0xca
  __HAL_LOCK(hrtc);
 802f35e:	2501      	movs	r5, #1
 802f360:	f880 502c 	strb.w	r5, [r0, #44]	; 0x2c
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f364:	625c      	str	r4, [r3, #36]	; 0x24
 802f366:	2453      	movs	r4, #83	; 0x53
 802f368:	625c      	str	r4, [r3, #36]	; 0x24

  if (Alarm == RTC_ALARM_A)
 802f36a:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 802f36e:	6b04      	ldr	r4, [r0, #48]	; 0x30
 802f370:	d116      	bne.n	802f3a0 <HAL_RTC_DeactivateAlarm+0x58>
  {
    /* AlarmA, In case of interrupt mode is used, the interrupt source must disabled */
    CLEAR_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 802f372:	699a      	ldr	r2, [r3, #24]
 802f374:	f422 5288 	bic.w	r2, r2, #4352	; 0x1100
 802f378:	619a      	str	r2, [r3, #24]

    /* AlarmA, Clear SSCLR */
    CLEAR_BIT(RTC->ALRMASSR, RTC_ALRMASSR_SSCLR);
 802f37a:	6c5a      	ldr	r2, [r3, #68]	; 0x44

    /* Store in the handle the Alarm A disabled */
    CLEAR_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRAMF);
 802f37c:	f024 0401 	bic.w	r4, r4, #1
    CLEAR_BIT(RTC->ALRMASSR, RTC_ALRMASSR_SSCLR);
 802f380:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 802f384:	645a      	str	r2, [r3, #68]	; 0x44
    CLEAR_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRAMF);
 802f386:	6304      	str	r4, [r0, #48]	; 0x30

    /* Clear AlarmA flag */
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
 802f388:	65dd      	str	r5, [r3, #92]	; 0x5c
    /* Clear AlarmB flag */
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 802f38a:	4b0c      	ldr	r3, [pc, #48]	; (802f3bc <HAL_RTC_DeactivateAlarm+0x74>)
 802f38c:	22ff      	movs	r2, #255	; 0xff
 802f38e:	625a      	str	r2, [r3, #36]	; 0x24

  hrtc->State = HAL_RTC_STATE_READY;
 802f390:	2301      	movs	r3, #1

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 802f392:	2200      	movs	r2, #0
  hrtc->State = HAL_RTC_STATE_READY;
 802f394:	f880 302d 	strb.w	r3, [r0, #45]	; 0x2d
  __HAL_UNLOCK(hrtc);
 802f398:	f880 202c 	strb.w	r2, [r0, #44]	; 0x2c
  __HAL_LOCK(hrtc);
 802f39c:	4610      	mov	r0, r2

  return HAL_OK;
}
 802f39e:	bd30      	pop	{r4, r5, pc}
    CLEAR_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 802f3a0:	6999      	ldr	r1, [r3, #24]
 802f3a2:	f421 5108 	bic.w	r1, r1, #8704	; 0x2200
 802f3a6:	6199      	str	r1, [r3, #24]
    CLEAR_BIT(RTC->ALRMBSSR, RTC_ALRMBSSR_SSCLR);
 802f3a8:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
    CLEAR_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRBMF);
 802f3aa:	f024 0402 	bic.w	r4, r4, #2
    CLEAR_BIT(RTC->ALRMBSSR, RTC_ALRMBSSR_SSCLR);
 802f3ae:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 802f3b2:	64d9      	str	r1, [r3, #76]	; 0x4c
    CLEAR_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRBMF);
 802f3b4:	6304      	str	r4, [r0, #48]	; 0x30
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
 802f3b6:	65da      	str	r2, [r3, #92]	; 0x5c
 802f3b8:	e7e7      	b.n	802f38a <HAL_RTC_DeactivateAlarm+0x42>
 802f3ba:	bf00      	nop
 802f3bc:	40002800 	.word	0x40002800

0802f3c0 <HAL_RTC_AlarmIRQHandler>:
  * @brief  Handle Alarm interrupt request.
  * @param  hrtc RTC handle
  * @retval None
  */
void HAL_RTC_AlarmIRQHandler(RTC_HandleTypeDef *hrtc)
{
 802f3c0:	b570      	push	{r4, r5, r6, lr}
  uint32_t tmp = READ_REG(RTC->MISR) & READ_REG(hrtc->IsEnabled.RtcFeatures);
 802f3c2:	4d0b      	ldr	r5, [pc, #44]	; (802f3f0 <HAL_RTC_AlarmIRQHandler+0x30>)
 802f3c4:	6b03      	ldr	r3, [r0, #48]	; 0x30
 802f3c6:	6d6e      	ldr	r6, [r5, #84]	; 0x54
 802f3c8:	401e      	ands	r6, r3

  if ((tmp & RTC_MISR_ALRAMF) != 0U)
 802f3ca:	07f2      	lsls	r2, r6, #31
{
 802f3cc:	4604      	mov	r4, r0
  if ((tmp & RTC_MISR_ALRAMF) != 0U)
 802f3ce:	d503      	bpl.n	802f3d8 <HAL_RTC_AlarmIRQHandler+0x18>
  {
    /* Clear the AlarmA interrupt pending bit */
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
 802f3d0:	2301      	movs	r3, #1
 802f3d2:	65eb      	str	r3, [r5, #92]	; 0x5c

#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
    /* Call Compare Match registered Callback */
    hrtc->AlarmAEventCallback(hrtc);
#else
    HAL_RTC_AlarmAEventCallback(hrtc);
 802f3d4:	f7fd fa4c 	bl	802c870 <HAL_RTC_AlarmAEventCallback>
#endif
  }

  if ((tmp & RTC_MISR_ALRBMF) != 0U)
 802f3d8:	07b3      	lsls	r3, r6, #30
 802f3da:	d504      	bpl.n	802f3e6 <HAL_RTC_AlarmIRQHandler+0x26>
  {
    /* Clear the AlarmB interrupt pending bit */
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
 802f3dc:	2302      	movs	r3, #2
 802f3de:	65eb      	str	r3, [r5, #92]	; 0x5c

#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
    /* Call Compare Match registered Callback */
    hrtc->AlarmBEventCallback(hrtc);
#else
    HAL_RTCEx_AlarmBEventCallback(hrtc);
 802f3e0:	4620      	mov	r0, r4
 802f3e2:	f000 f9c5 	bl	802f770 <HAL_RTCEx_AlarmBEventCallback>
#endif
  }

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 802f3e6:	2301      	movs	r3, #1
 802f3e8:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
}
 802f3ec:	bd70      	pop	{r4, r5, r6, pc}
 802f3ee:	bf00      	nop
 802f3f0:	40002800 	.word	0x40002800

0802f3f4 <HAL_RTC_WaitForSynchro>:
  *         correctly copied into the RTC_TR and RTC_DR shadow registers.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef *hrtc)
{
 802f3f4:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart;

  UNUSED(hrtc);
  /* Clear RSF flag */
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_RSF);
 802f3f6:	4c0a      	ldr	r4, [pc, #40]	; (802f420 <HAL_RTC_WaitForSynchro+0x2c>)
 802f3f8:	68e3      	ldr	r3, [r4, #12]
 802f3fa:	f023 0320 	bic.w	r3, r3, #32
 802f3fe:	60e3      	str	r3, [r4, #12]

  tickstart = HAL_GetTick();
 802f400:	f7fd f920 	bl	802c644 <HAL_GetTick>
 802f404:	4605      	mov	r5, r0

  /* Wait the registers to be synchronised */
  while (READ_BIT(RTC->ICSR, RTC_ICSR_RSF) == 0U)
 802f406:	68e3      	ldr	r3, [r4, #12]
 802f408:	069b      	lsls	r3, r3, #26
 802f40a:	d501      	bpl.n	802f410 <HAL_RTC_WaitForSynchro+0x1c>
    {
      return HAL_TIMEOUT;
    }
  }

  return HAL_OK;
 802f40c:	2000      	movs	r0, #0
}
 802f40e:	bd38      	pop	{r3, r4, r5, pc}
    if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 802f410:	f7fd f918 	bl	802c644 <HAL_GetTick>
 802f414:	1b40      	subs	r0, r0, r5
 802f416:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 802f41a:	d9f4      	bls.n	802f406 <HAL_RTC_WaitForSynchro+0x12>
      return HAL_TIMEOUT;
 802f41c:	2003      	movs	r0, #3
 802f41e:	e7f6      	b.n	802f40e <HAL_RTC_WaitForSynchro+0x1a>
 802f420:	40002800 	.word	0x40002800

0802f424 <RTC_EnterInitMode>:
  *         __HAL_RTC_WRITEPROTECTION_DISABLE() before calling this function.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef *hrtc)
{
 802f424:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;

  UNUSED(hrtc);
  /* Check if the Initialization mode is set */
  if (READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U)
 802f428:	4d11      	ldr	r5, [pc, #68]	; (802f470 <RTC_EnterInitMode+0x4c>)
 802f42a:	68ec      	ldr	r4, [r5, #12]
 802f42c:	f014 0440 	ands.w	r4, r4, #64	; 0x40
{
 802f430:	4607      	mov	r7, r0
  if (READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U)
 802f432:	d11a      	bne.n	802f46a <RTC_EnterInitMode+0x46>
  {
    /* Set the Initialization mode */
    SET_BIT(RTC->ICSR, RTC_ICSR_INIT);
 802f434:	68eb      	ldr	r3, [r5, #12]
 802f436:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 802f43a:	60eb      	str	r3, [r5, #12]

    tickstart = HAL_GetTick();
 802f43c:	f7fd f902 	bl	802c644 <HAL_GetTick>
    while ((READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U) && (status != HAL_TIMEOUT))
    {
      if ((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
      {
        status = HAL_TIMEOUT;
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 802f440:	f04f 0803 	mov.w	r8, #3
    tickstart = HAL_GetTick();
 802f444:	4606      	mov	r6, r0
    while ((READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U) && (status != HAL_TIMEOUT))
 802f446:	68eb      	ldr	r3, [r5, #12]
 802f448:	065b      	lsls	r3, r3, #25
 802f44a:	d401      	bmi.n	802f450 <RTC_EnterInitMode+0x2c>
 802f44c:	2c03      	cmp	r4, #3
 802f44e:	d102      	bne.n	802f456 <RTC_EnterInitMode+0x32>
      }
    }
  }

  return status;
}
 802f450:	4620      	mov	r0, r4
 802f452:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if ((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
 802f456:	f7fd f8f5 	bl	802c644 <HAL_GetTick>
 802f45a:	1b80      	subs	r0, r0, r6
 802f45c:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 802f460:	bf84      	itt	hi
 802f462:	f887 802d 	strbhi.w	r8, [r7, #45]	; 0x2d
        status = HAL_TIMEOUT;
 802f466:	2403      	movhi	r4, #3
 802f468:	e7ed      	b.n	802f446 <RTC_EnterInitMode+0x22>
  HAL_StatusTypeDef status = HAL_OK;
 802f46a:	2400      	movs	r4, #0
 802f46c:	e7f0      	b.n	802f450 <RTC_EnterInitMode+0x2c>
 802f46e:	bf00      	nop
 802f470:	40002800 	.word	0x40002800

0802f474 <RTC_ExitInitMode>:
HAL_StatusTypeDef RTC_ExitInitMode(RTC_HandleTypeDef *hrtc)
{
  HAL_StatusTypeDef status = HAL_OK;

  /* Exit Initialization mode */
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_INIT);
 802f474:	4b10      	ldr	r3, [pc, #64]	; (802f4b8 <RTC_ExitInitMode+0x44>)
 802f476:	68da      	ldr	r2, [r3, #12]
 802f478:	f022 0280 	bic.w	r2, r2, #128	; 0x80
{
 802f47c:	b510      	push	{r4, lr}
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_INIT);
 802f47e:	60da      	str	r2, [r3, #12]

  /* If CR_BYPSHAD bit = 0, wait for synchro */
  if (READ_BIT(RTC->CR, RTC_CR_BYPSHAD) == 0U)
 802f480:	699a      	ldr	r2, [r3, #24]
 802f482:	0692      	lsls	r2, r2, #26
{
 802f484:	4604      	mov	r4, r0
  if (READ_BIT(RTC->CR, RTC_CR_BYPSHAD) == 0U)
 802f486:	d406      	bmi.n	802f496 <RTC_ExitInitMode+0x22>
  {
    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 802f488:	f7ff ffb4 	bl	802f3f4 <HAL_RTC_WaitForSynchro>
 802f48c:	b110      	cbz	r0, 802f494 <RTC_ExitInitMode+0x20>
    {
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 802f48e:	2003      	movs	r0, #3
 802f490:	f884 002d 	strb.w	r0, [r4, #45]	; 0x2d
    /* Restore BYPSHAD bit */
    SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
  }

  return status;
}
 802f494:	bd10      	pop	{r4, pc}
    CLEAR_BIT(RTC->CR, RTC_CR_BYPSHAD);
 802f496:	699a      	ldr	r2, [r3, #24]
 802f498:	f022 0220 	bic.w	r2, r2, #32
 802f49c:	619a      	str	r2, [r3, #24]
    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 802f49e:	f7ff ffa9 	bl	802f3f4 <HAL_RTC_WaitForSynchro>
 802f4a2:	b110      	cbz	r0, 802f4aa <RTC_ExitInitMode+0x36>
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 802f4a4:	2003      	movs	r0, #3
 802f4a6:	f884 002d 	strb.w	r0, [r4, #45]	; 0x2d
    SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
 802f4aa:	4a03      	ldr	r2, [pc, #12]	; (802f4b8 <RTC_ExitInitMode+0x44>)
 802f4ac:	6993      	ldr	r3, [r2, #24]
 802f4ae:	f043 0320 	orr.w	r3, r3, #32
 802f4b2:	6193      	str	r3, [r2, #24]
  return status;
 802f4b4:	e7ee      	b.n	802f494 <RTC_ExitInitMode+0x20>
 802f4b6:	bf00      	nop
 802f4b8:	40002800 	.word	0x40002800

0802f4bc <HAL_RTC_Init>:
{
 802f4bc:	b538      	push	{r3, r4, r5, lr}
  if (hrtc != NULL)
 802f4be:	4604      	mov	r4, r0
 802f4c0:	2800      	cmp	r0, #0
 802f4c2:	d047      	beq.n	802f554 <HAL_RTC_Init+0x98>
    if (hrtc->State == HAL_RTC_STATE_RESET)
 802f4c4:	f890 302d 	ldrb.w	r3, [r0, #45]	; 0x2d
 802f4c8:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 802f4cc:	b91b      	cbnz	r3, 802f4d6 <HAL_RTC_Init+0x1a>
      hrtc->Lock = HAL_UNLOCKED;
 802f4ce:	f880 202c 	strb.w	r2, [r0, #44]	; 0x2c
      HAL_RTC_MspInit(hrtc);
 802f4d2:	f7fc ff2b 	bl	802c32c <HAL_RTC_MspInit>
    __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f4d6:	4d20      	ldr	r5, [pc, #128]	; (802f558 <HAL_RTC_Init+0x9c>)
    hrtc->State = HAL_RTC_STATE_BUSY;
 802f4d8:	2302      	movs	r3, #2
 802f4da:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
    __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f4de:	23ca      	movs	r3, #202	; 0xca
 802f4e0:	626b      	str	r3, [r5, #36]	; 0x24
 802f4e2:	2353      	movs	r3, #83	; 0x53
 802f4e4:	626b      	str	r3, [r5, #36]	; 0x24
    status = RTC_EnterInitMode(hrtc);
 802f4e6:	4620      	mov	r0, r4
 802f4e8:	f7ff ff9c 	bl	802f424 <RTC_EnterInitMode>
    if (status == HAL_OK)
 802f4ec:	bb70      	cbnz	r0, 802f54c <HAL_RTC_Init+0x90>
      CLEAR_BIT(RTC->CR, (RTC_CR_FMT | RTC_CR_POL | RTC_CR_OSEL | RTC_CR_TAMPOE));
 802f4ee:	69ab      	ldr	r3, [r5, #24]
 802f4f0:	f023 638e 	bic.w	r3, r3, #74448896	; 0x4700000
 802f4f4:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 802f4f8:	61ab      	str	r3, [r5, #24]
      SET_BIT(RTC->CR, (hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity));
 802f4fa:	6921      	ldr	r1, [r4, #16]
 802f4fc:	6863      	ldr	r3, [r4, #4]
 802f4fe:	69aa      	ldr	r2, [r5, #24]
 802f500:	430b      	orrs	r3, r1
 802f502:	4313      	orrs	r3, r2
 802f504:	69a2      	ldr	r2, [r4, #24]
 802f506:	4313      	orrs	r3, r2
 802f508:	61ab      	str	r3, [r5, #24]
      WRITE_REG(RTC->PRER, ((hrtc->Init.SynchPrediv) | (hrtc->Init.AsynchPrediv << RTC_PRER_PREDIV_A_Pos)));
 802f50a:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 802f50e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 802f512:	612b      	str	r3, [r5, #16]
      MODIFY_REG(RTC->ICSR, RTC_ICSR_BIN | RTC_ICSR_BCDU, hrtc->Init.BinMode | hrtc->Init.BinMixBcdU);
 802f514:	e9d4 3109 	ldrd	r3, r1, [r4, #36]	; 0x24
 802f518:	68ea      	ldr	r2, [r5, #12]
 802f51a:	430b      	orrs	r3, r1
 802f51c:	f422 52f8 	bic.w	r2, r2, #7936	; 0x1f00
 802f520:	4313      	orrs	r3, r2
 802f522:	60eb      	str	r3, [r5, #12]
      status = RTC_ExitInitMode(hrtc);
 802f524:	4620      	mov	r0, r4
 802f526:	f7ff ffa5 	bl	802f474 <RTC_ExitInitMode>
      if (status == HAL_OK)
 802f52a:	b978      	cbnz	r0, 802f54c <HAL_RTC_Init+0x90>
        MODIFY_REG(RTC->CR, \
 802f52c:	e9d4 1307 	ldrd	r1, r3, [r4, #28]
 802f530:	69aa      	ldr	r2, [r5, #24]
 802f532:	430b      	orrs	r3, r1
 802f534:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
 802f538:	4313      	orrs	r3, r2
 802f53a:	6962      	ldr	r2, [r4, #20]
 802f53c:	4313      	orrs	r3, r2
 802f53e:	61ab      	str	r3, [r5, #24]
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 802f540:	23ff      	movs	r3, #255	; 0xff
 802f542:	626b      	str	r3, [r5, #36]	; 0x24
      hrtc->State = HAL_RTC_STATE_READY;
 802f544:	2301      	movs	r3, #1
 802f546:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
}
 802f54a:	bd38      	pop	{r3, r4, r5, pc}
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 802f54c:	4b02      	ldr	r3, [pc, #8]	; (802f558 <HAL_RTC_Init+0x9c>)
 802f54e:	22ff      	movs	r2, #255	; 0xff
 802f550:	625a      	str	r2, [r3, #36]	; 0x24
    if (status == HAL_OK)
 802f552:	e7fa      	b.n	802f54a <HAL_RTC_Init+0x8e>
  HAL_StatusTypeDef status = HAL_ERROR;
 802f554:	2001      	movs	r0, #1
 802f556:	e7f8      	b.n	802f54a <HAL_RTC_Init+0x8e>
 802f558:	40002800 	.word	0x40002800

0802f55c <RTC_ByteToBcd2>:
  * @param  Value Byte to be converted
  * @retval Converted byte
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0U;
 802f55c:	2300      	movs	r3, #0
  uint8_t tmp_Value = Value;

  while (tmp_Value >= 10U)
 802f55e:	2809      	cmp	r0, #9
 802f560:	d803      	bhi.n	802f56a <RTC_ByteToBcd2+0xe>
  {
    bcdhigh++;
    tmp_Value -= 10U;
  }

  return ((uint8_t)(bcdhigh << 4U) | tmp_Value);
 802f562:	ea40 1003 	orr.w	r0, r0, r3, lsl #4
}
 802f566:	b2c0      	uxtb	r0, r0
 802f568:	4770      	bx	lr
    tmp_Value -= 10U;
 802f56a:	380a      	subs	r0, #10
    bcdhigh++;
 802f56c:	3301      	adds	r3, #1
    tmp_Value -= 10U;
 802f56e:	b2c0      	uxtb	r0, r0
 802f570:	e7f5      	b.n	802f55e <RTC_ByteToBcd2+0x2>
	...

0802f574 <HAL_RTC_SetAlarm_IT>:
{
 802f574:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  __HAL_LOCK(hrtc);
 802f578:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 802f57c:	2b01      	cmp	r3, #1
{
 802f57e:	4605      	mov	r5, r0
 802f580:	f04f 0002 	mov.w	r0, #2
  __HAL_LOCK(hrtc);
 802f584:	d067      	beq.n	802f656 <HAL_RTC_SetAlarm_IT+0xe2>
 802f586:	2301      	movs	r3, #1
 802f588:	f885 302c 	strb.w	r3, [r5, #44]	; 0x2c
  binaryMode = READ_BIT(RTC->ICSR, RTC_ICSR_BIN);
 802f58c:	4b4c      	ldr	r3, [pc, #304]	; (802f6c0 <HAL_RTC_SetAlarm_IT+0x14c>)
  hrtc->State = HAL_RTC_STATE_BUSY;
 802f58e:	f885 002d 	strb.w	r0, [r5, #45]	; 0x2d
  binaryMode = READ_BIT(RTC->ICSR, RTC_ICSR_BIN);
 802f592:	68de      	ldr	r6, [r3, #12]
 802f594:	f406 7640 	and.w	r6, r6, #768	; 0x300
  if (binaryMode != RTC_BINARY_ONLY)
 802f598:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
 802f59c:	d076      	beq.n	802f68c <HAL_RTC_SetAlarm_IT+0x118>
    if (Format == RTC_FORMAT_BIN)
 802f59e:	694c      	ldr	r4, [r1, #20]
 802f5a0:	7808      	ldrb	r0, [r1, #0]
 802f5a2:	f891 8001 	ldrb.w	r8, [r1, #1]
 802f5a6:	f891 a002 	ldrb.w	sl, [r1, #2]
 802f5aa:	f891 7024 	ldrb.w	r7, [r1, #36]	; 0x24
 802f5ae:	2a00      	cmp	r2, #0
 802f5b0:	d153      	bne.n	802f65a <HAL_RTC_SetAlarm_IT+0xe6>
      if (READ_BIT(RTC->CR, RTC_CR_FMT) != 0U)
 802f5b2:	699a      	ldr	r2, [r3, #24]
 802f5b4:	f012 0240 	ands.w	r2, r2, #64	; 0x40
        sAlarm->AlarmTime.TimeFormat = 0x00U;
 802f5b8:	bf08      	it	eq
 802f5ba:	70ca      	strbeq	r2, [r1, #3]
      tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 802f5bc:	f7ff ffce 	bl	802f55c <RTC_ByteToBcd2>
 802f5c0:	4681      	mov	r9, r0
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
 802f5c2:	4640      	mov	r0, r8
 802f5c4:	f7ff ffca 	bl	802f55c <RTC_ByteToBcd2>
 802f5c8:	4680      	mov	r8, r0
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds) << RTC_ALRMAR_SU_Pos) | \
 802f5ca:	4650      	mov	r0, sl
 802f5cc:	f7ff ffc6 	bl	802f55c <RTC_ByteToBcd2>
 802f5d0:	4682      	mov	sl, r0
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << RTC_ALRMAR_DU_Pos) | \
 802f5d2:	4638      	mov	r0, r7
 802f5d4:	f7ff ffc2 	bl	802f55c <RTC_ByteToBcd2>
      tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 802f5d8:	6a0a      	ldr	r2, [r1, #32]
                ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
 802f5da:	78cb      	ldrb	r3, [r1, #3]
      tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 802f5dc:	4314      	orrs	r4, r2
 802f5de:	ea44 5483 	orr.w	r4, r4, r3, lsl #22
 802f5e2:	ea44 030a 	orr.w	r3, r4, sl
 802f5e6:	ea43 4309 	orr.w	r3, r3, r9, lsl #16
 802f5ea:	ea43 2308 	orr.w	r3, r3, r8, lsl #8
 802f5ee:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f5f2:	4a33      	ldr	r2, [pc, #204]	; (802f6c0 <HAL_RTC_SetAlarm_IT+0x14c>)
 802f5f4:	20ca      	movs	r0, #202	; 0xca
 802f5f6:	6250      	str	r0, [r2, #36]	; 0x24
 802f5f8:	2053      	movs	r0, #83	; 0x53
 802f5fa:	6250      	str	r0, [r2, #36]	; 0x24
  if (sAlarm->Alarm == RTC_ALARM_A)
 802f5fc:	6a8c      	ldr	r4, [r1, #40]	; 0x28
 802f5fe:	6988      	ldr	r0, [r1, #24]
 802f600:	f5b4 7f80 	cmp.w	r4, #256	; 0x100
    CLEAR_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 802f604:	6994      	ldr	r4, [r2, #24]
  if (sAlarm->Alarm == RTC_ALARM_A)
 802f606:	d143      	bne.n	802f690 <HAL_RTC_SetAlarm_IT+0x11c>
    CLEAR_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 802f608:	f424 5488 	bic.w	r4, r4, #4352	; 0x1100
 802f60c:	6194      	str	r4, [r2, #24]
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
 802f60e:	2401      	movs	r4, #1
 802f610:	65d4      	str	r4, [r2, #92]	; 0x5c
    if (binaryMode == RTC_BINARY_ONLY)
 802f612:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
      RTC->ALRMASSR = sAlarm->AlarmSubSecondMask | sAlarm->BinaryAutoClr;
 802f616:	bf0a      	itet	eq
 802f618:	69cb      	ldreq	r3, [r1, #28]
      WRITE_REG(RTC->ALRMAR, tmpreg);
 802f61a:	6413      	strne	r3, [r2, #64]	; 0x40
      RTC->ALRMASSR = sAlarm->AlarmSubSecondMask | sAlarm->BinaryAutoClr;
 802f61c:	4318      	orreq	r0, r3
      WRITE_REG(RTC->ALRMASSR, sAlarm->AlarmSubSecondMask);
 802f61e:	6450      	str	r0, [r2, #68]	; 0x44
    WRITE_REG(RTC->ALRABINR, sAlarm->AlarmTime.SubSeconds);
 802f620:	4b27      	ldr	r3, [pc, #156]	; (802f6c0 <HAL_RTC_SetAlarm_IT+0x14c>)
 802f622:	684a      	ldr	r2, [r1, #4]
 802f624:	671a      	str	r2, [r3, #112]	; 0x70
    SET_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRAMF);
 802f626:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 802f628:	f042 0201 	orr.w	r2, r2, #1
 802f62c:	632a      	str	r2, [r5, #48]	; 0x30
    SET_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 802f62e:	699a      	ldr	r2, [r3, #24]
 802f630:	f442 5288 	orr.w	r2, r2, #4352	; 0x1100
    SET_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 802f634:	619a      	str	r2, [r3, #24]
  __HAL_RTC_ALARM_EXTI_ENABLE_IT();
 802f636:	4a23      	ldr	r2, [pc, #140]	; (802f6c4 <HAL_RTC_SetAlarm_IT+0x150>)
 802f638:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
 802f63c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 802f640:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 802f644:	4b1e      	ldr	r3, [pc, #120]	; (802f6c0 <HAL_RTC_SetAlarm_IT+0x14c>)
 802f646:	22ff      	movs	r2, #255	; 0xff
 802f648:	625a      	str	r2, [r3, #36]	; 0x24
  __HAL_UNLOCK(hrtc);
 802f64a:	2000      	movs	r0, #0
  hrtc->State = HAL_RTC_STATE_READY;
 802f64c:	2301      	movs	r3, #1
 802f64e:	f885 302d 	strb.w	r3, [r5, #45]	; 0x2d
  __HAL_UNLOCK(hrtc);
 802f652:	f885 002c 	strb.w	r0, [r5, #44]	; 0x2c
}
 802f656:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      if( sAlarm->AlarmMask != RTC_ALARMMASK_ALL )
 802f65a:	f1b4 3f80 	cmp.w	r4, #2155905152	; 0x80808080
 802f65e:	d007      	beq.n	802f670 <HAL_RTC_SetAlarm_IT+0xfc>
        if( sAlarm->AlarmMask != RTC_ALARMMASK_HOURS )
 802f660:	f5b4 0f00 	cmp.w	r4, #8388608	; 0x800000
 802f664:	d004      	beq.n	802f670 <HAL_RTC_SetAlarm_IT+0xfc>
          if (READ_BIT(RTC->CR, RTC_CR_FMT) != 0U)
 802f666:	699a      	ldr	r2, [r3, #24]
 802f668:	f012 0240 	ands.w	r2, r2, #64	; 0x40
            sAlarm->AlarmTime.TimeFormat = 0x00U;
 802f66c:	bf08      	it	eq
 802f66e:	70ca      	strbeq	r2, [r1, #3]
      tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 802f670:	6a0a      	ldr	r2, [r1, #32]
 802f672:	4314      	orrs	r4, r2
 802f674:	ea44 040a 	orr.w	r4, r4, sl
 802f678:	ea44 4300 	orr.w	r3, r4, r0, lsl #16
                ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
 802f67c:	78c8      	ldrb	r0, [r1, #3]
      tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 802f67e:	ea43 2308 	orr.w	r3, r3, r8, lsl #8
 802f682:	ea43 5380 	orr.w	r3, r3, r0, lsl #22
 802f686:	ea43 6307 	orr.w	r3, r3, r7, lsl #24
 802f68a:	e7b2      	b.n	802f5f2 <HAL_RTC_SetAlarm_IT+0x7e>
  uint32_t tmpreg = 0;
 802f68c:	2300      	movs	r3, #0
 802f68e:	e7b0      	b.n	802f5f2 <HAL_RTC_SetAlarm_IT+0x7e>
    CLEAR_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 802f690:	f424 5408 	bic.w	r4, r4, #8704	; 0x2200
 802f694:	6194      	str	r4, [r2, #24]
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
 802f696:	2402      	movs	r4, #2
 802f698:	65d4      	str	r4, [r2, #92]	; 0x5c
    if (binaryMode == RTC_BINARY_ONLY)
 802f69a:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
      WRITE_REG(RTC->ALRMBSSR, sAlarm->AlarmSubSecondMask | sAlarm->BinaryAutoClr);
 802f69e:	bf0a      	itet	eq
 802f6a0:	69cb      	ldreq	r3, [r1, #28]
      WRITE_REG(RTC->ALRMBR, tmpreg);
 802f6a2:	6493      	strne	r3, [r2, #72]	; 0x48
      WRITE_REG(RTC->ALRMBSSR, sAlarm->AlarmSubSecondMask | sAlarm->BinaryAutoClr);
 802f6a4:	4318      	orreq	r0, r3
      WRITE_REG(RTC->ALRMBSSR, sAlarm->AlarmSubSecondMask);
 802f6a6:	64d0      	str	r0, [r2, #76]	; 0x4c
    WRITE_REG(RTC->ALRBBINR, sAlarm->AlarmTime.SubSeconds);
 802f6a8:	4b05      	ldr	r3, [pc, #20]	; (802f6c0 <HAL_RTC_SetAlarm_IT+0x14c>)
 802f6aa:	684a      	ldr	r2, [r1, #4]
 802f6ac:	675a      	str	r2, [r3, #116]	; 0x74
    SET_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRBMF);
 802f6ae:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 802f6b0:	f042 0202 	orr.w	r2, r2, #2
 802f6b4:	632a      	str	r2, [r5, #48]	; 0x30
    SET_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 802f6b6:	699a      	ldr	r2, [r3, #24]
 802f6b8:	f442 5208 	orr.w	r2, r2, #8704	; 0x2200
 802f6bc:	e7ba      	b.n	802f634 <HAL_RTC_SetAlarm_IT+0xc0>
 802f6be:	bf00      	nop
 802f6c0:	40002800 	.word	0x40002800
 802f6c4:	58000800 	.word	0x58000800

0802f6c8 <HAL_RTCEx_EnableBypassShadow>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_EnableBypassShadow(RTC_HandleTypeDef *hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);
 802f6c8:	f890 202c 	ldrb.w	r2, [r0, #44]	; 0x2c
 802f6cc:	2a01      	cmp	r2, #1
{
 802f6ce:	4603      	mov	r3, r0
 802f6d0:	f04f 0002 	mov.w	r0, #2
  __HAL_LOCK(hrtc);
 802f6d4:	d012      	beq.n	802f6fc <HAL_RTCEx_EnableBypassShadow+0x34>

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f6d6:	4a0a      	ldr	r2, [pc, #40]	; (802f700 <HAL_RTCEx_EnableBypassShadow+0x38>)
  hrtc->State = HAL_RTC_STATE_BUSY;
 802f6d8:	f883 002d 	strb.w	r0, [r3, #45]	; 0x2d
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f6dc:	21ca      	movs	r1, #202	; 0xca
 802f6de:	6251      	str	r1, [r2, #36]	; 0x24
 802f6e0:	2153      	movs	r1, #83	; 0x53
 802f6e2:	6251      	str	r1, [r2, #36]	; 0x24

  /* Set the BYPSHAD bit */
  SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
 802f6e4:	6991      	ldr	r1, [r2, #24]
 802f6e6:	f041 0120 	orr.w	r1, r1, #32
 802f6ea:	6191      	str	r1, [r2, #24]

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 802f6ec:	21ff      	movs	r1, #255	; 0xff
 802f6ee:	6251      	str	r1, [r2, #36]	; 0x24

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 802f6f0:	2000      	movs	r0, #0
  hrtc->State = HAL_RTC_STATE_READY;
 802f6f2:	2201      	movs	r2, #1
 802f6f4:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
  __HAL_UNLOCK(hrtc);
 802f6f8:	f883 002c 	strb.w	r0, [r3, #44]	; 0x2c

  return HAL_OK;
}
 802f6fc:	4770      	bx	lr
 802f6fe:	bf00      	nop
 802f700:	40002800 	.word	0x40002800

0802f704 <HAL_RTCEx_SetSSRU_IT>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetSSRU_IT(RTC_HandleTypeDef *hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);
 802f704:	f890 202c 	ldrb.w	r2, [r0, #44]	; 0x2c
 802f708:	2a01      	cmp	r2, #1
{
 802f70a:	4603      	mov	r3, r0
 802f70c:	f04f 0002 	mov.w	r0, #2
  __HAL_LOCK(hrtc);
 802f710:	d019      	beq.n	802f746 <HAL_RTCEx_SetSSRU_IT+0x42>

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f712:	4a0d      	ldr	r2, [pc, #52]	; (802f748 <HAL_RTCEx_SetSSRU_IT+0x44>)
  hrtc->State = HAL_RTC_STATE_BUSY;
 802f714:	f883 002d 	strb.w	r0, [r3, #45]	; 0x2d
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802f718:	21ca      	movs	r1, #202	; 0xca
 802f71a:	6251      	str	r1, [r2, #36]	; 0x24
 802f71c:	2153      	movs	r1, #83	; 0x53
 802f71e:	6251      	str	r1, [r2, #36]	; 0x24

  /* Enable IT SSRU */
  __HAL_RTC_SSRU_ENABLE_IT(hrtc, RTC_IT_SSRU);
 802f720:	6991      	ldr	r1, [r2, #24]

  /* RTC SSRU Interrupt Configuration: EXTI configuration */
  __HAL_RTC_SSRU_EXTI_ENABLE_IT();
 802f722:	480a      	ldr	r0, [pc, #40]	; (802f74c <HAL_RTCEx_SetSSRU_IT+0x48>)
  __HAL_RTC_SSRU_ENABLE_IT(hrtc, RTC_IT_SSRU);
 802f724:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 802f728:	6191      	str	r1, [r2, #24]
  __HAL_RTC_SSRU_EXTI_ENABLE_IT();
 802f72a:	f8d0 1080 	ldr.w	r1, [r0, #128]	; 0x80
 802f72e:	f441 2180 	orr.w	r1, r1, #262144	; 0x40000
 802f732:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 802f736:	21ff      	movs	r1, #255	; 0xff
 802f738:	6251      	str	r1, [r2, #36]	; 0x24

  hrtc->State = HAL_RTC_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 802f73a:	2000      	movs	r0, #0
  hrtc->State = HAL_RTC_STATE_READY;
 802f73c:	2201      	movs	r2, #1
 802f73e:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
  __HAL_UNLOCK(hrtc);
 802f742:	f883 002c 	strb.w	r0, [r3, #44]	; 0x2c

  return HAL_OK;
}
 802f746:	4770      	bx	lr
 802f748:	40002800 	.word	0x40002800
 802f74c:	58000800 	.word	0x58000800

0802f750 <HAL_RTCEx_SSRUIRQHandler>:
  * @param  hrtc RTC handle
  * @retval None
  */
void HAL_RTCEx_SSRUIRQHandler(RTC_HandleTypeDef *hrtc)
{
  if ((RTC->MISR & RTC_MISR_SSRUMF) != 0u)
 802f750:	4b06      	ldr	r3, [pc, #24]	; (802f76c <HAL_RTCEx_SSRUIRQHandler+0x1c>)
 802f752:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 802f754:	0652      	lsls	r2, r2, #25
{
 802f756:	b510      	push	{r4, lr}
 802f758:	4604      	mov	r4, r0
  if ((RTC->MISR & RTC_MISR_SSRUMF) != 0u)
 802f75a:	d503      	bpl.n	802f764 <HAL_RTCEx_SSRUIRQHandler+0x14>
  {
    /* Immediately clear flags */
    RTC->SCR = RTC_SCR_CSSRUF;
 802f75c:	2240      	movs	r2, #64	; 0x40
 802f75e:	65da      	str	r2, [r3, #92]	; 0x5c
    /* SSRU callback */
#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
    /* Call SSRUEvent registered Callback */
    hrtc->SSRUEventCallback(hrtc);
#else
    HAL_RTCEx_SSRUEventCallback(hrtc);
 802f760:	f7fd f888 	bl	802c874 <HAL_RTCEx_SSRUEventCallback>
#endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
  }

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 802f764:	2301      	movs	r3, #1
 802f766:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
}
 802f76a:	bd10      	pop	{r4, pc}
 802f76c:	40002800 	.word	0x40002800

0802f770 <HAL_RTCEx_AlarmBEventCallback>:
 802f770:	4770      	bx	lr

0802f772 <HAL_RTCEx_BKUPWrite>:
  UNUSED(hrtc);
  /* Check the parameters */
  assert_param(IS_RTC_BKP(BackupRegister));

  tmp = (uint32_t) & (TAMP->BKP0R);
  tmp += (BackupRegister * 4U);
 802f772:	0089      	lsls	r1, r1, #2
 802f774:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 802f778:	f501 4131 	add.w	r1, r1, #45312	; 0xb100

  /* Write the specified register */
  *(__IO uint32_t *)tmp = (uint32_t)Data;
 802f77c:	600a      	str	r2, [r1, #0]
}
 802f77e:	4770      	bx	lr

0802f780 <HAL_RTCEx_BKUPRead>:
  UNUSED(hrtc);
  /* Check the parameters */
  assert_param(IS_RTC_BKP(BackupRegister));

  tmp = (uint32_t) & (TAMP->BKP0R);
  tmp += (BackupRegister * 4U);
 802f780:	0089      	lsls	r1, r1, #2
 802f782:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 802f786:	f501 4131 	add.w	r1, r1, #45312	; 0xb100

  /* Read the specified register */
  return (*(__IO uint32_t *)tmp);
 802f78a:	6808      	ldr	r0, [r1, #0]
}
 802f78c:	4770      	bx	lr
	...

0802f790 <LL_PWR_UnselectSUBGHZSPI_NSS>:
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 802f790:	4a03      	ldr	r2, [pc, #12]	; (802f7a0 <LL_PWR_UnselectSUBGHZSPI_NSS+0x10>)
 802f792:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 802f796:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 802f79a:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 802f79e:	4770      	bx	lr
 802f7a0:	58000400 	.word	0x58000400

0802f7a4 <LL_PWR_SelectSUBGHZSPI_NSS>:
  CLEAR_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 802f7a4:	4a03      	ldr	r2, [pc, #12]	; (802f7b4 <LL_PWR_SelectSUBGHZSPI_NSS+0x10>)
 802f7a6:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 802f7aa:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 802f7ae:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 802f7b2:	4770      	bx	lr
 802f7b4:	58000400 	.word	0x58000400

0802f7b8 <SUBGHZSPI_Init>:
{
  /* Check the parameters */
  assert_param(IS_SUBGHZ_ALL_INSTANCE(SUBGHZSPI));

  /* Disable SUBGHZSPI Peripheral */
  CLEAR_BIT(SUBGHZSPI->CR1, SPI_CR1_SPE);
 802f7b8:	4b07      	ldr	r3, [pc, #28]	; (802f7d8 <SUBGHZSPI_Init+0x20>)
 802f7ba:	681a      	ldr	r2, [r3, #0]
 802f7bc:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 802f7c0:	601a      	str	r2, [r3, #0]
   *       NSS management: Internal (Done with External bit inside PWR        *
   *  Communication speed: BaudratePrescaler                             *
   *            First bit: MSB                                                *
   *      CRC calculation: Disable                                            *
   *--------------------------------------------------------------------------*/
  WRITE_REG(SUBGHZSPI->CR1, (SPI_CR1_MSTR | SPI_CR1_SSI | BaudratePrescaler | SPI_CR1_SSM));
 802f7c2:	f440 7041 	orr.w	r0, r0, #772	; 0x304
   *            Data Size: 8bits                                              *
   *              TI Mode: Disable                                            *
   *            NSS Pulse: Disable                                            *
   *    Rx FIFO Threshold: 8bits                                              *
   *--------------------------------------------------------------------------*/
  WRITE_REG(SUBGHZSPI->CR2, (SPI_CR2_FRXTH |  SPI_CR2_DS_0 | SPI_CR2_DS_1 | SPI_CR2_DS_2));
 802f7c6:	f44f 52b8 	mov.w	r2, #5888	; 0x1700
  WRITE_REG(SUBGHZSPI->CR1, (SPI_CR1_MSTR | SPI_CR1_SSI | BaudratePrescaler | SPI_CR1_SSM));
 802f7ca:	6018      	str	r0, [r3, #0]
  WRITE_REG(SUBGHZSPI->CR2, (SPI_CR2_FRXTH |  SPI_CR2_DS_0 | SPI_CR2_DS_1 | SPI_CR2_DS_2));
 802f7cc:	605a      	str	r2, [r3, #4]

  /* Enable SUBGHZSPI Peripheral */
  SET_BIT(SUBGHZSPI->CR1, SPI_CR1_SPE);
 802f7ce:	681a      	ldr	r2, [r3, #0]
 802f7d0:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 802f7d4:	601a      	str	r2, [r3, #0]
}
 802f7d6:	4770      	bx	lr
 802f7d8:	58010000 	.word	0x58010000

0802f7dc <HAL_SUBGHZ_Init>:
{
 802f7dc:	b513      	push	{r0, r1, r4, lr}
  if (hsubghz == NULL)
 802f7de:	4604      	mov	r4, r0
 802f7e0:	2800      	cmp	r0, #0
 802f7e2:	d042      	beq.n	802f86a <HAL_SUBGHZ_Init+0x8e>
  if (hsubghz->State == HAL_SUBGHZ_STATE_RESET)
 802f7e4:	7983      	ldrb	r3, [r0, #6]
 802f7e6:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 802f7ea:	b913      	cbnz	r3, 802f7f2 <HAL_SUBGHZ_Init+0x16>
    hsubghz->Lock = HAL_UNLOCKED;
 802f7ec:	7142      	strb	r2, [r0, #5]
    HAL_SUBGHZ_MspInit(hsubghz);
 802f7ee:	f7fc fe3b 	bl	802c468 <HAL_SUBGHZ_MspInit>
  hsubghz->State = HAL_SUBGHZ_STATE_BUSY;
 802f7f2:	2302      	movs	r3, #2
 802f7f4:	71a3      	strb	r3, [r4, #6]
  CLEAR_BIT(RCC->CSR, RCC_CSR_RFRST);
 802f7f6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802f7fa:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 802f7fe:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 802f802:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f806:	4a1a      	ldr	r2, [pc, #104]	; (802f870 <HAL_SUBGHZ_Init+0x94>)
 802f808:	6811      	ldr	r1, [r2, #0]
 802f80a:	221c      	movs	r2, #28
 802f80c:	434a      	muls	r2, r1
 802f80e:	0cd2      	lsrs	r2, r2, #19
 802f810:	2164      	movs	r1, #100	; 0x64
 802f812:	434a      	muls	r2, r1
 802f814:	9201      	str	r2, [sp, #4]
    if (count == 0U)
 802f816:	9a01      	ldr	r2, [sp, #4]
 802f818:	b9f2      	cbnz	r2, 802f858 <HAL_SUBGHZ_Init+0x7c>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 802f81a:	2101      	movs	r1, #1
 802f81c:	60a1      	str	r1, [r4, #8]
  LL_PWR_UnselectSUBGHZSPI_NSS();
 802f81e:	f7ff ffb7 	bl	802f790 <LL_PWR_UnselectSUBGHZSPI_NSS>
  SET_BIT(EXTI->IMR2, ExtiLine);
 802f822:	4a14      	ldr	r2, [pc, #80]	; (802f874 <HAL_SUBGHZ_Init+0x98>)
 802f824:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 802f828:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 802f82c:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  MODIFY_REG(PWR->CR3, PWR_CR3_EWRFBUSY, RadioBusyTrigger);
 802f830:	4b11      	ldr	r3, [pc, #68]	; (802f878 <HAL_SUBGHZ_Init+0x9c>)
 802f832:	689a      	ldr	r2, [r3, #8]
 802f834:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 802f838:	609a      	str	r2, [r3, #8]
  WRITE_REG(PWR->SCR, PWR_SCR_CWRFBUSYF);
 802f83a:	f44f 6200 	mov.w	r2, #2048	; 0x800
 802f83e:	619a      	str	r2, [r3, #24]
  if (status == HAL_OK)
 802f840:	b929      	cbnz	r1, 802f84e <HAL_SUBGHZ_Init+0x72>
    SUBGHZSPI_Init(hsubghz->Init.BaudratePrescaler);
 802f842:	6820      	ldr	r0, [r4, #0]
 802f844:	f7ff ffb8 	bl	802f7b8 <SUBGHZSPI_Init>
    hsubghz->DeepSleep = SUBGHZ_DEEP_SLEEP_ENABLE;
 802f848:	2301      	movs	r3, #1
 802f84a:	7123      	strb	r3, [r4, #4]
    hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_NONE;
 802f84c:	60a1      	str	r1, [r4, #8]
  hsubghz->State     = HAL_SUBGHZ_STATE_READY;
 802f84e:	2301      	movs	r3, #1
 802f850:	71a3      	strb	r3, [r4, #6]
}
 802f852:	4608      	mov	r0, r1
 802f854:	b002      	add	sp, #8
 802f856:	bd10      	pop	{r4, pc}
    count--;
 802f858:	9a01      	ldr	r2, [sp, #4]
 802f85a:	3a01      	subs	r2, #1
 802f85c:	9201      	str	r2, [sp, #4]
  return ((READ_BIT(RCC->CSR, RCC_CSR_RFRSTF) == (RCC_CSR_RFRSTF)) ? 1UL : 0UL);
 802f85e:	f8d3 1094 	ldr.w	r1, [r3, #148]	; 0x94
 802f862:	f411 4180 	ands.w	r1, r1, #16384	; 0x4000
 802f866:	d1d6      	bne.n	802f816 <HAL_SUBGHZ_Init+0x3a>
 802f868:	e7d9      	b.n	802f81e <HAL_SUBGHZ_Init+0x42>
    return status;
 802f86a:	2101      	movs	r1, #1
 802f86c:	e7f1      	b.n	802f852 <HAL_SUBGHZ_Init+0x76>
 802f86e:	bf00      	nop
 802f870:	2000344c 	.word	0x2000344c
 802f874:	58000800 	.word	0x58000800
 802f878:	58000400 	.word	0x58000400

0802f87c <SUBGHZSPI_Transmit>:
  * @param  Data  data to transmit
  * @retval HAL status
  */
HAL_StatusTypeDef SUBGHZSPI_Transmit(SUBGHZ_HandleTypeDef *hsubghz,
                                     uint8_t Data)
{
 802f87c:	b513      	push	{r0, r1, r4, lr}
 802f87e:	4602      	mov	r2, r0
  HAL_StatusTypeDef status = HAL_OK;
  __IO uint32_t count;

  /* Handle Tx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f880:	4817      	ldr	r0, [pc, #92]	; (802f8e0 <SUBGHZSPI_Transmit+0x64>)
 802f882:	6804      	ldr	r4, [r0, #0]
 802f884:	231c      	movs	r3, #28
 802f886:	4363      	muls	r3, r4
 802f888:	0cdb      	lsrs	r3, r3, #19
 802f88a:	2464      	movs	r4, #100	; 0x64
 802f88c:	4363      	muls	r3, r4
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_TXE) != (SPI_SR_TXE));
 802f88e:	4c15      	ldr	r4, [pc, #84]	; (802f8e4 <SUBGHZSPI_Transmit+0x68>)
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f890:	9301      	str	r3, [sp, #4]
 802f892:	4603      	mov	r3, r0
    if (count == 0U)
 802f894:	9801      	ldr	r0, [sp, #4]
 802f896:	b998      	cbnz	r0, 802f8c0 <SUBGHZSPI_Transmit+0x44>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 802f898:	2001      	movs	r0, #1
 802f89a:	6090      	str	r0, [r2, #8]

  /* Transmit Data*/
#if defined (__GNUC__)
  __IO uint8_t *spidr = ((__IO uint8_t *)&SUBGHZSPI->DR);
  *spidr = Data;
 802f89c:	4c12      	ldr	r4, [pc, #72]	; (802f8e8 <SUBGHZSPI_Transmit+0x6c>)
 802f89e:	7021      	strb	r1, [r4, #0]
  *((__IO uint8_t *)&SUBGHZSPI->DR) = Data;
#endif /* __GNUC__ */

  /* Handle Rx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f8a0:	6819      	ldr	r1, [r3, #0]
 802f8a2:	231c      	movs	r3, #28
 802f8a4:	434b      	muls	r3, r1
 802f8a6:	0cdb      	lsrs	r3, r3, #19
 802f8a8:	2164      	movs	r1, #100	; 0x64
 802f8aa:	434b      	muls	r3, r1
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_RXNE) != (SPI_SR_RXNE));
 802f8ac:	490d      	ldr	r1, [pc, #52]	; (802f8e4 <SUBGHZSPI_Transmit+0x68>)
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f8ae:	9301      	str	r3, [sp, #4]
    if (count == 0U)
 802f8b0:	9b01      	ldr	r3, [sp, #4]
 802f8b2:	b96b      	cbnz	r3, 802f8d0 <SUBGHZSPI_Transmit+0x54>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 802f8b4:	2001      	movs	r0, #1
 802f8b6:	6090      	str	r0, [r2, #8]

  /* Flush Rx data */
  READ_REG(SUBGHZSPI->DR);
 802f8b8:	4b0a      	ldr	r3, [pc, #40]	; (802f8e4 <SUBGHZSPI_Transmit+0x68>)
 802f8ba:	68db      	ldr	r3, [r3, #12]

  return status;
}
 802f8bc:	b002      	add	sp, #8
 802f8be:	bd10      	pop	{r4, pc}
    count--;
 802f8c0:	9801      	ldr	r0, [sp, #4]
 802f8c2:	3801      	subs	r0, #1
 802f8c4:	9001      	str	r0, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_TXE) != (SPI_SR_TXE));
 802f8c6:	68a0      	ldr	r0, [r4, #8]
 802f8c8:	0780      	lsls	r0, r0, #30
 802f8ca:	d5e3      	bpl.n	802f894 <SUBGHZSPI_Transmit+0x18>
  HAL_StatusTypeDef status = HAL_OK;
 802f8cc:	2000      	movs	r0, #0
 802f8ce:	e7e5      	b.n	802f89c <SUBGHZSPI_Transmit+0x20>
    count--;
 802f8d0:	9b01      	ldr	r3, [sp, #4]
 802f8d2:	3b01      	subs	r3, #1
 802f8d4:	9301      	str	r3, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_RXNE) != (SPI_SR_RXNE));
 802f8d6:	688b      	ldr	r3, [r1, #8]
 802f8d8:	07db      	lsls	r3, r3, #31
 802f8da:	d5e9      	bpl.n	802f8b0 <SUBGHZSPI_Transmit+0x34>
 802f8dc:	e7ec      	b.n	802f8b8 <SUBGHZSPI_Transmit+0x3c>
 802f8de:	bf00      	nop
 802f8e0:	2000344c 	.word	0x2000344c
 802f8e4:	58010000 	.word	0x58010000
 802f8e8:	5801000c 	.word	0x5801000c

0802f8ec <SUBGHZSPI_Receive>:
  * @param  pData  pointer on data to receive
  * @retval HAL status
  */
HAL_StatusTypeDef SUBGHZSPI_Receive(SUBGHZ_HandleTypeDef *hsubghz,
                                    uint8_t *pData)
{
 802f8ec:	b537      	push	{r0, r1, r2, r4, r5, lr}
 802f8ee:	4602      	mov	r2, r0
  HAL_StatusTypeDef status = HAL_OK;
  __IO uint32_t count;

  /* Handle Tx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f8f0:	4818      	ldr	r0, [pc, #96]	; (802f954 <SUBGHZSPI_Receive+0x68>)
 802f8f2:	6804      	ldr	r4, [r0, #0]
 802f8f4:	231c      	movs	r3, #28
 802f8f6:	4363      	muls	r3, r4
 802f8f8:	0cdb      	lsrs	r3, r3, #19
 802f8fa:	2464      	movs	r4, #100	; 0x64
 802f8fc:	4363      	muls	r3, r4
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_TXE) != (SPI_SR_TXE));
 802f8fe:	4c16      	ldr	r4, [pc, #88]	; (802f958 <SUBGHZSPI_Receive+0x6c>)
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f900:	9301      	str	r3, [sp, #4]
 802f902:	4603      	mov	r3, r0
    if (count == 0U)
 802f904:	9801      	ldr	r0, [sp, #4]
 802f906:	b9a8      	cbnz	r0, 802f934 <SUBGHZSPI_Receive+0x48>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 802f908:	2001      	movs	r0, #1
 802f90a:	6090      	str	r0, [r2, #8]

  /* Transmit Data*/
#if defined (__GNUC__)
  __IO uint8_t *spidr = ((__IO uint8_t *)&SUBGHZSPI->DR);
  *spidr = SUBGHZ_DUMMY_DATA;
 802f90c:	4c13      	ldr	r4, [pc, #76]	; (802f95c <SUBGHZSPI_Receive+0x70>)
 802f90e:	25ff      	movs	r5, #255	; 0xff
 802f910:	7025      	strb	r5, [r4, #0]
  *((__IO uint8_t *)&SUBGHZSPI->DR) = SUBGHZ_DUMMY_DATA;
#endif /* __GNUC__ */

  /* Handle Rx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f912:	681c      	ldr	r4, [r3, #0]
 802f914:	231c      	movs	r3, #28
 802f916:	4363      	muls	r3, r4
 802f918:	0cdb      	lsrs	r3, r3, #19
 802f91a:	2464      	movs	r4, #100	; 0x64
 802f91c:	4363      	muls	r3, r4
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_RXNE) != (SPI_SR_RXNE));
 802f91e:	4c0e      	ldr	r4, [pc, #56]	; (802f958 <SUBGHZSPI_Receive+0x6c>)
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802f920:	9301      	str	r3, [sp, #4]
    if (count == 0U)
 802f922:	9b01      	ldr	r3, [sp, #4]
 802f924:	b973      	cbnz	r3, 802f944 <SUBGHZSPI_Receive+0x58>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 802f926:	2001      	movs	r0, #1
 802f928:	6090      	str	r0, [r2, #8]

  /* Retrieve pData */
  *pData = (uint8_t)(READ_REG(SUBGHZSPI->DR));
 802f92a:	4b0b      	ldr	r3, [pc, #44]	; (802f958 <SUBGHZSPI_Receive+0x6c>)
 802f92c:	68db      	ldr	r3, [r3, #12]
 802f92e:	700b      	strb	r3, [r1, #0]

  return status;
}
 802f930:	b003      	add	sp, #12
 802f932:	bd30      	pop	{r4, r5, pc}
    count--;
 802f934:	9801      	ldr	r0, [sp, #4]
 802f936:	3801      	subs	r0, #1
 802f938:	9001      	str	r0, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_TXE) != (SPI_SR_TXE));
 802f93a:	68a0      	ldr	r0, [r4, #8]
 802f93c:	0780      	lsls	r0, r0, #30
 802f93e:	d5e1      	bpl.n	802f904 <SUBGHZSPI_Receive+0x18>
  HAL_StatusTypeDef status = HAL_OK;
 802f940:	2000      	movs	r0, #0
 802f942:	e7e3      	b.n	802f90c <SUBGHZSPI_Receive+0x20>
    count--;
 802f944:	9b01      	ldr	r3, [sp, #4]
 802f946:	3b01      	subs	r3, #1
 802f948:	9301      	str	r3, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_RXNE) != (SPI_SR_RXNE));
 802f94a:	68a3      	ldr	r3, [r4, #8]
 802f94c:	07db      	lsls	r3, r3, #31
 802f94e:	d5e8      	bpl.n	802f922 <SUBGHZSPI_Receive+0x36>
 802f950:	e7eb      	b.n	802f92a <SUBGHZSPI_Receive+0x3e>
 802f952:	bf00      	nop
 802f954:	2000344c 	.word	0x2000344c
 802f958:	58010000 	.word	0x58010000
 802f95c:	5801000c 	.word	0x5801000c

0802f960 <SUBGHZ_WaitOnBusy>:
  HAL_StatusTypeDef status;
  __IO uint32_t count;
  uint32_t mask;

  status = HAL_OK;
  count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_RFBUSY_LOOP_TIME;
 802f960:	4b0f      	ldr	r3, [pc, #60]	; (802f9a0 <SUBGHZ_WaitOnBusy+0x40>)
{
 802f962:	b513      	push	{r0, r1, r4, lr}
  count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_RFBUSY_LOOP_TIME;
 802f964:	681a      	ldr	r2, [r3, #0]
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYMS) == (PWR_SR2_RFBUSYMS)) ? 1UL : 0UL);
 802f966:	4c0f      	ldr	r4, [pc, #60]	; (802f9a4 <SUBGHZ_WaitOnBusy+0x44>)
 802f968:	2318      	movs	r3, #24
 802f96a:	4353      	muls	r3, r2
 802f96c:	0d1b      	lsrs	r3, r3, #20
 802f96e:	2264      	movs	r2, #100	; 0x64
 802f970:	4353      	muls	r3, r2
{
 802f972:	4601      	mov	r1, r0
  count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_RFBUSY_LOOP_TIME;
 802f974:	9301      	str	r3, [sp, #4]
 802f976:	6962      	ldr	r2, [r4, #20]
  /* Wait until Busy signal is set */
  do
  {
    mask = LL_PWR_IsActiveFlag_RFBUSYMS();

    if (count == 0U)
 802f978:	9b01      	ldr	r3, [sp, #4]
 802f97a:	f002 0204 	and.w	r2, r2, #4
 802f97e:	b923      	cbnz	r3, 802f98a <SUBGHZ_WaitOnBusy+0x2a>
    {
      status  = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_RF_BUSY;
 802f980:	2302      	movs	r3, #2
 802f982:	608b      	str	r3, [r1, #8]
      status  = HAL_ERROR;
 802f984:	2001      	movs	r0, #1
    }
    count--;
  } while ((LL_PWR_IsActiveFlag_RFBUSYS()& mask) == 1UL);

  return status;
}
 802f986:	b002      	add	sp, #8
 802f988:	bd10      	pop	{r4, pc}
    count--;
 802f98a:	9b01      	ldr	r3, [sp, #4]
 802f98c:	3b01      	subs	r3, #1
 802f98e:	9301      	str	r3, [sp, #4]
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYS) == (PWR_SR2_RFBUSYS)) ? 1UL : 0UL);
 802f990:	6960      	ldr	r0, [r4, #20]
 802f992:	f010 0002 	ands.w	r0, r0, #2
 802f996:	d0f6      	beq.n	802f986 <SUBGHZ_WaitOnBusy+0x26>
  } while ((LL_PWR_IsActiveFlag_RFBUSYS()& mask) == 1UL);
 802f998:	2a00      	cmp	r2, #0
 802f99a:	d1ec      	bne.n	802f976 <SUBGHZ_WaitOnBusy+0x16>
  status = HAL_OK;
 802f99c:	4610      	mov	r0, r2
 802f99e:	e7f2      	b.n	802f986 <SUBGHZ_WaitOnBusy+0x26>
 802f9a0:	2000344c 	.word	0x2000344c
 802f9a4:	58000400 	.word	0x58000400

0802f9a8 <SUBGHZ_CheckDeviceReady>:
{
 802f9a8:	b507      	push	{r0, r1, r2, lr}
  if (hsubghz->DeepSleep == SUBGHZ_DEEP_SLEEP_ENABLE)
 802f9aa:	7903      	ldrb	r3, [r0, #4]
 802f9ac:	2b01      	cmp	r3, #1
 802f9ae:	d10f      	bne.n	802f9d0 <SUBGHZ_CheckDeviceReady+0x28>
    count  = SUBGHZ_NSS_LOOP_TIME;
 802f9b0:	4b0a      	ldr	r3, [pc, #40]	; (802f9dc <SUBGHZ_CheckDeviceReady+0x34>)
 802f9b2:	681a      	ldr	r2, [r3, #0]
 802f9b4:	2318      	movs	r3, #24
 802f9b6:	4353      	muls	r3, r2
 802f9b8:	0c1b      	lsrs	r3, r3, #16
 802f9ba:	9301      	str	r3, [sp, #4]
    LL_PWR_SelectSUBGHZSPI_NSS();
 802f9bc:	f7ff fef2 	bl	802f7a4 <LL_PWR_SelectSUBGHZSPI_NSS>
      count--;
 802f9c0:	9b01      	ldr	r3, [sp, #4]
 802f9c2:	3b01      	subs	r3, #1
 802f9c4:	9301      	str	r3, [sp, #4]
    } while (count != 0UL);
 802f9c6:	9b01      	ldr	r3, [sp, #4]
 802f9c8:	2b00      	cmp	r3, #0
 802f9ca:	d1f9      	bne.n	802f9c0 <SUBGHZ_CheckDeviceReady+0x18>
    LL_PWR_UnselectSUBGHZSPI_NSS();
 802f9cc:	f7ff fee0 	bl	802f790 <LL_PWR_UnselectSUBGHZSPI_NSS>
}
 802f9d0:	b003      	add	sp, #12
 802f9d2:	f85d eb04 	ldr.w	lr, [sp], #4
  return (SUBGHZ_WaitOnBusy(hsubghz));
 802f9d6:	f7ff bfc3 	b.w	802f960 <SUBGHZ_WaitOnBusy>
 802f9da:	bf00      	nop
 802f9dc:	2000344c 	.word	0x2000344c

0802f9e0 <HAL_SUBGHZ_WriteRegisters>:
{
 802f9e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802f9e2:	461e      	mov	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802f9e4:	7983      	ldrb	r3, [r0, #6]
 802f9e6:	2b01      	cmp	r3, #1
{
 802f9e8:	4615      	mov	r5, r2
 802f9ea:	4604      	mov	r4, r0
 802f9ec:	460f      	mov	r7, r1
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802f9ee:	b2da      	uxtb	r2, r3
 802f9f0:	d12d      	bne.n	802fa4e <HAL_SUBGHZ_WriteRegisters+0x6e>
    __HAL_LOCK(hsubghz);
 802f9f2:	7943      	ldrb	r3, [r0, #5]
 802f9f4:	2b01      	cmp	r3, #1
 802f9f6:	d02a      	beq.n	802fa4e <HAL_SUBGHZ_WriteRegisters+0x6e>
    hsubghz->State = HAL_SUBGHZ_STATE_BUSY;
 802f9f8:	2302      	movs	r3, #2
    __HAL_LOCK(hsubghz);
 802f9fa:	7142      	strb	r2, [r0, #5]
    hsubghz->State = HAL_SUBGHZ_STATE_BUSY;
 802f9fc:	7183      	strb	r3, [r0, #6]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 802f9fe:	f7ff ffd3 	bl	802f9a8 <SUBGHZ_CheckDeviceReady>
    LL_PWR_SelectSUBGHZSPI_NSS();
 802fa02:	f7ff fecf 	bl	802f7a4 <LL_PWR_SelectSUBGHZSPI_NSS>
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_WRITE_REGISTER);
 802fa06:	210d      	movs	r1, #13
 802fa08:	4620      	mov	r0, r4
 802fa0a:	f7ff ff37 	bl	802f87c <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)((Address & 0xFF00U) >> 8U));
 802fa0e:	0a39      	lsrs	r1, r7, #8
 802fa10:	4620      	mov	r0, r4
 802fa12:	f7ff ff33 	bl	802f87c <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)(Address & 0x00FFU));
 802fa16:	b2f9      	uxtb	r1, r7
 802fa18:	4620      	mov	r0, r4
 802fa1a:	f7ff ff2f 	bl	802f87c <SUBGHZSPI_Transmit>
HAL_StatusTypeDef HAL_SUBGHZ_WriteRegisters(SUBGHZ_HandleTypeDef *hsubghz,
 802fa1e:	442e      	add	r6, r5
    for (uint16_t i = 0U; i < Size; i++)
 802fa20:	42b5      	cmp	r5, r6
 802fa22:	d10e      	bne.n	802fa42 <HAL_SUBGHZ_WriteRegisters+0x62>
    LL_PWR_UnselectSUBGHZSPI_NSS();
 802fa24:	f7ff feb4 	bl	802f790 <LL_PWR_UnselectSUBGHZSPI_NSS>
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 802fa28:	4620      	mov	r0, r4
 802fa2a:	f7ff ff99 	bl	802f960 <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 802fa2e:	68a0      	ldr	r0, [r4, #8]
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fa30:	2301      	movs	r3, #1
      status = HAL_ERROR;
 802fa32:	3800      	subs	r0, #0
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fa34:	71a3      	strb	r3, [r4, #6]
    __HAL_UNLOCK(hsubghz);
 802fa36:	f04f 0300 	mov.w	r3, #0
      status = HAL_ERROR;
 802fa3a:	bf18      	it	ne
 802fa3c:	2001      	movne	r0, #1
    __HAL_UNLOCK(hsubghz);
 802fa3e:	7163      	strb	r3, [r4, #5]
}
 802fa40:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void)SUBGHZSPI_Transmit(hsubghz, pBuffer[i]);
 802fa42:	f815 1b01 	ldrb.w	r1, [r5], #1
 802fa46:	4620      	mov	r0, r4
 802fa48:	f7ff ff18 	bl	802f87c <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 802fa4c:	e7e8      	b.n	802fa20 <HAL_SUBGHZ_WriteRegisters+0x40>
    return HAL_BUSY;
 802fa4e:	2002      	movs	r0, #2
 802fa50:	e7f6      	b.n	802fa40 <HAL_SUBGHZ_WriteRegisters+0x60>

0802fa52 <HAL_SUBGHZ_ReadRegisters>:
{
 802fa52:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802fa54:	461e      	mov	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fa56:	7983      	ldrb	r3, [r0, #6]
 802fa58:	2b01      	cmp	r3, #1
{
 802fa5a:	4615      	mov	r5, r2
 802fa5c:	4604      	mov	r4, r0
 802fa5e:	460f      	mov	r7, r1
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fa60:	b2da      	uxtb	r2, r3
 802fa62:	d12f      	bne.n	802fac4 <HAL_SUBGHZ_ReadRegisters+0x72>
    __HAL_LOCK(hsubghz);
 802fa64:	7943      	ldrb	r3, [r0, #5]
 802fa66:	2b01      	cmp	r3, #1
 802fa68:	d02c      	beq.n	802fac4 <HAL_SUBGHZ_ReadRegisters+0x72>
 802fa6a:	7142      	strb	r2, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 802fa6c:	f7ff ff9c 	bl	802f9a8 <SUBGHZ_CheckDeviceReady>
    LL_PWR_SelectSUBGHZSPI_NSS();
 802fa70:	f7ff fe98 	bl	802f7a4 <LL_PWR_SelectSUBGHZSPI_NSS>
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_READ_REGISTER);
 802fa74:	211d      	movs	r1, #29
 802fa76:	4620      	mov	r0, r4
 802fa78:	f7ff ff00 	bl	802f87c <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)((Address & 0xFF00U) >> 8U));
 802fa7c:	0a39      	lsrs	r1, r7, #8
 802fa7e:	4620      	mov	r0, r4
 802fa80:	f7ff fefc 	bl	802f87c <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)(Address & 0x00FFU));
 802fa84:	b2f9      	uxtb	r1, r7
 802fa86:	4620      	mov	r0, r4
 802fa88:	f7ff fef8 	bl	802f87c <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, 0U);
 802fa8c:	2100      	movs	r1, #0
 802fa8e:	4620      	mov	r0, r4
 802fa90:	f7ff fef4 	bl	802f87c <SUBGHZSPI_Transmit>
HAL_StatusTypeDef HAL_SUBGHZ_ReadRegisters(SUBGHZ_HandleTypeDef *hsubghz,
 802fa94:	442e      	add	r6, r5
    for (uint16_t i = 0U; i < Size; i++)
 802fa96:	42b5      	cmp	r5, r6
 802fa98:	d10e      	bne.n	802fab8 <HAL_SUBGHZ_ReadRegisters+0x66>
    LL_PWR_UnselectSUBGHZSPI_NSS();
 802fa9a:	f7ff fe79 	bl	802f790 <LL_PWR_UnselectSUBGHZSPI_NSS>
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 802fa9e:	4620      	mov	r0, r4
 802faa0:	f7ff ff5e 	bl	802f960 <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 802faa4:	68a0      	ldr	r0, [r4, #8]
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802faa6:	2301      	movs	r3, #1
      status = HAL_ERROR;
 802faa8:	3800      	subs	r0, #0
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802faaa:	71a3      	strb	r3, [r4, #6]
    __HAL_UNLOCK(hsubghz);
 802faac:	f04f 0300 	mov.w	r3, #0
      status = HAL_ERROR;
 802fab0:	bf18      	it	ne
 802fab2:	2001      	movne	r0, #1
    __HAL_UNLOCK(hsubghz);
 802fab4:	7163      	strb	r3, [r4, #5]
}
 802fab6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void)SUBGHZSPI_Receive(hsubghz, (pData));
 802fab8:	4629      	mov	r1, r5
 802faba:	4620      	mov	r0, r4
 802fabc:	f7ff ff16 	bl	802f8ec <SUBGHZSPI_Receive>
      pData++;
 802fac0:	3501      	adds	r5, #1
    for (uint16_t i = 0U; i < Size; i++)
 802fac2:	e7e8      	b.n	802fa96 <HAL_SUBGHZ_ReadRegisters+0x44>
    return HAL_BUSY;
 802fac4:	2002      	movs	r0, #2
 802fac6:	e7f6      	b.n	802fab6 <HAL_SUBGHZ_ReadRegisters+0x64>

0802fac8 <HAL_SUBGHZ_ExecSetCmd>:
{
 802fac8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802faca:	461f      	mov	r7, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802facc:	7983      	ldrb	r3, [r0, #6]
 802face:	2b01      	cmp	r3, #1
{
 802fad0:	4615      	mov	r5, r2
 802fad2:	4604      	mov	r4, r0
 802fad4:	460e      	mov	r6, r1
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fad6:	b2da      	uxtb	r2, r3
 802fad8:	d12c      	bne.n	802fb34 <HAL_SUBGHZ_ExecSetCmd+0x6c>
    __HAL_LOCK(hsubghz);
 802fada:	7943      	ldrb	r3, [r0, #5]
 802fadc:	2b01      	cmp	r3, #1
 802fade:	d029      	beq.n	802fb34 <HAL_SUBGHZ_ExecSetCmd+0x6c>
 802fae0:	7142      	strb	r2, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 802fae2:	f7ff ff61 	bl	802f9a8 <SUBGHZ_CheckDeviceReady>
    if ((Command == RADIO_SET_SLEEP) || (Command == RADIO_SET_RXDUTYCYCLE))
 802fae6:	f006 03ef 	and.w	r3, r6, #239	; 0xef
 802faea:	f1a3 0284 	sub.w	r2, r3, #132	; 0x84
 802faee:	4253      	negs	r3, r2
 802faf0:	4153      	adcs	r3, r2
 802faf2:	7123      	strb	r3, [r4, #4]
    LL_PWR_SelectSUBGHZSPI_NSS();
 802faf4:	f7ff fe56 	bl	802f7a4 <LL_PWR_SelectSUBGHZSPI_NSS>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)Command);
 802faf8:	4631      	mov	r1, r6
 802fafa:	4620      	mov	r0, r4
 802fafc:	f7ff febe 	bl	802f87c <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 802fb00:	442f      	add	r7, r5
 802fb02:	42af      	cmp	r7, r5
 802fb04:	d110      	bne.n	802fb28 <HAL_SUBGHZ_ExecSetCmd+0x60>
    LL_PWR_UnselectSUBGHZSPI_NSS();
 802fb06:	f7ff fe43 	bl	802f790 <LL_PWR_UnselectSUBGHZSPI_NSS>
    if (Command != RADIO_SET_SLEEP)
 802fb0a:	2e84      	cmp	r6, #132	; 0x84
 802fb0c:	d002      	beq.n	802fb14 <HAL_SUBGHZ_ExecSetCmd+0x4c>
      (void)SUBGHZ_WaitOnBusy(hsubghz);
 802fb0e:	4620      	mov	r0, r4
 802fb10:	f7ff ff26 	bl	802f960 <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 802fb14:	68a0      	ldr	r0, [r4, #8]
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fb16:	2301      	movs	r3, #1
      status = HAL_ERROR;
 802fb18:	3800      	subs	r0, #0
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fb1a:	71a3      	strb	r3, [r4, #6]
    __HAL_UNLOCK(hsubghz);
 802fb1c:	f04f 0300 	mov.w	r3, #0
      status = HAL_ERROR;
 802fb20:	bf18      	it	ne
 802fb22:	2001      	movne	r0, #1
    __HAL_UNLOCK(hsubghz);
 802fb24:	7163      	strb	r3, [r4, #5]
}
 802fb26:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void)SUBGHZSPI_Transmit(hsubghz, pBuffer[i]);
 802fb28:	f815 1b01 	ldrb.w	r1, [r5], #1
 802fb2c:	4620      	mov	r0, r4
 802fb2e:	f7ff fea5 	bl	802f87c <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 802fb32:	e7e6      	b.n	802fb02 <HAL_SUBGHZ_ExecSetCmd+0x3a>
    return HAL_BUSY;
 802fb34:	2002      	movs	r0, #2
 802fb36:	e7f6      	b.n	802fb26 <HAL_SUBGHZ_ExecSetCmd+0x5e>

0802fb38 <HAL_SUBGHZ_WriteBuffer>:
{
 802fb38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802fb3a:	461e      	mov	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fb3c:	7983      	ldrb	r3, [r0, #6]
 802fb3e:	2b01      	cmp	r3, #1
{
 802fb40:	4615      	mov	r5, r2
 802fb42:	4604      	mov	r4, r0
 802fb44:	460f      	mov	r7, r1
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fb46:	b2da      	uxtb	r2, r3
 802fb48:	d127      	bne.n	802fb9a <HAL_SUBGHZ_WriteBuffer+0x62>
    __HAL_LOCK(hsubghz);
 802fb4a:	7943      	ldrb	r3, [r0, #5]
 802fb4c:	2b01      	cmp	r3, #1
 802fb4e:	d024      	beq.n	802fb9a <HAL_SUBGHZ_WriteBuffer+0x62>
 802fb50:	7142      	strb	r2, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 802fb52:	f7ff ff29 	bl	802f9a8 <SUBGHZ_CheckDeviceReady>
    LL_PWR_SelectSUBGHZSPI_NSS();
 802fb56:	f7ff fe25 	bl	802f7a4 <LL_PWR_SelectSUBGHZSPI_NSS>
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_WRITE_BUFFER);
 802fb5a:	210e      	movs	r1, #14
 802fb5c:	4620      	mov	r0, r4
 802fb5e:	f7ff fe8d 	bl	802f87c <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, Offset);
 802fb62:	4639      	mov	r1, r7
 802fb64:	4620      	mov	r0, r4
 802fb66:	f7ff fe89 	bl	802f87c <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 802fb6a:	442e      	add	r6, r5
 802fb6c:	42b5      	cmp	r5, r6
 802fb6e:	d10e      	bne.n	802fb8e <HAL_SUBGHZ_WriteBuffer+0x56>
    LL_PWR_UnselectSUBGHZSPI_NSS();
 802fb70:	f7ff fe0e 	bl	802f790 <LL_PWR_UnselectSUBGHZSPI_NSS>
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 802fb74:	4620      	mov	r0, r4
 802fb76:	f7ff fef3 	bl	802f960 <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 802fb7a:	68a0      	ldr	r0, [r4, #8]
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fb7c:	2301      	movs	r3, #1
      status = HAL_ERROR;
 802fb7e:	3800      	subs	r0, #0
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fb80:	71a3      	strb	r3, [r4, #6]
    __HAL_UNLOCK(hsubghz);
 802fb82:	f04f 0300 	mov.w	r3, #0
      status = HAL_ERROR;
 802fb86:	bf18      	it	ne
 802fb88:	2001      	movne	r0, #1
    __HAL_UNLOCK(hsubghz);
 802fb8a:	7163      	strb	r3, [r4, #5]
}
 802fb8c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void)SUBGHZSPI_Transmit(hsubghz, pBuffer[i]);
 802fb8e:	f815 1b01 	ldrb.w	r1, [r5], #1
 802fb92:	4620      	mov	r0, r4
 802fb94:	f7ff fe72 	bl	802f87c <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 802fb98:	e7e8      	b.n	802fb6c <HAL_SUBGHZ_WriteBuffer+0x34>
    return HAL_BUSY;
 802fb9a:	2002      	movs	r0, #2
 802fb9c:	e7f6      	b.n	802fb8c <HAL_SUBGHZ_WriteBuffer+0x54>

0802fb9e <HAL_SUBGHZ_ReadBuffer>:
{
 802fb9e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802fba0:	461e      	mov	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fba2:	7983      	ldrb	r3, [r0, #6]
 802fba4:	2b01      	cmp	r3, #1
{
 802fba6:	4615      	mov	r5, r2
 802fba8:	4604      	mov	r4, r0
 802fbaa:	460f      	mov	r7, r1
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fbac:	b2da      	uxtb	r2, r3
 802fbae:	d12b      	bne.n	802fc08 <HAL_SUBGHZ_ReadBuffer+0x6a>
    __HAL_LOCK(hsubghz);
 802fbb0:	7943      	ldrb	r3, [r0, #5]
 802fbb2:	2b01      	cmp	r3, #1
 802fbb4:	d028      	beq.n	802fc08 <HAL_SUBGHZ_ReadBuffer+0x6a>
 802fbb6:	7142      	strb	r2, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 802fbb8:	f7ff fef6 	bl	802f9a8 <SUBGHZ_CheckDeviceReady>
    LL_PWR_SelectSUBGHZSPI_NSS();
 802fbbc:	f7ff fdf2 	bl	802f7a4 <LL_PWR_SelectSUBGHZSPI_NSS>
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_READ_BUFFER);
 802fbc0:	211e      	movs	r1, #30
 802fbc2:	4620      	mov	r0, r4
 802fbc4:	f7ff fe5a 	bl	802f87c <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, Offset);
 802fbc8:	4639      	mov	r1, r7
 802fbca:	4620      	mov	r0, r4
 802fbcc:	f7ff fe56 	bl	802f87c <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, 0x00U);
 802fbd0:	2100      	movs	r1, #0
 802fbd2:	4620      	mov	r0, r4
 802fbd4:	f7ff fe52 	bl	802f87c <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 802fbd8:	442e      	add	r6, r5
 802fbda:	42b5      	cmp	r5, r6
 802fbdc:	d10e      	bne.n	802fbfc <HAL_SUBGHZ_ReadBuffer+0x5e>
    LL_PWR_UnselectSUBGHZSPI_NSS();
 802fbde:	f7ff fdd7 	bl	802f790 <LL_PWR_UnselectSUBGHZSPI_NSS>
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 802fbe2:	4620      	mov	r0, r4
 802fbe4:	f7ff febc 	bl	802f960 <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 802fbe8:	68a0      	ldr	r0, [r4, #8]
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fbea:	2301      	movs	r3, #1
      status = HAL_ERROR;
 802fbec:	3800      	subs	r0, #0
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fbee:	71a3      	strb	r3, [r4, #6]
    __HAL_UNLOCK(hsubghz);
 802fbf0:	f04f 0300 	mov.w	r3, #0
      status = HAL_ERROR;
 802fbf4:	bf18      	it	ne
 802fbf6:	2001      	movne	r0, #1
    __HAL_UNLOCK(hsubghz);
 802fbf8:	7163      	strb	r3, [r4, #5]
}
 802fbfa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void)SUBGHZSPI_Receive(hsubghz, (pData));
 802fbfc:	4629      	mov	r1, r5
 802fbfe:	4620      	mov	r0, r4
 802fc00:	f7ff fe74 	bl	802f8ec <SUBGHZSPI_Receive>
      pData++;
 802fc04:	3501      	adds	r5, #1
    for (uint16_t i = 0U; i < Size; i++)
 802fc06:	e7e8      	b.n	802fbda <HAL_SUBGHZ_ReadBuffer+0x3c>
    return HAL_BUSY;
 802fc08:	2002      	movs	r0, #2
 802fc0a:	e7f6      	b.n	802fbfa <HAL_SUBGHZ_ReadBuffer+0x5c>

0802fc0c <HAL_SUBGHZ_ExecGetCmd>:
{
 802fc0c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802fc0e:	461e      	mov	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fc10:	7983      	ldrb	r3, [r0, #6]
 802fc12:	2b01      	cmp	r3, #1
{
 802fc14:	4615      	mov	r5, r2
 802fc16:	4604      	mov	r4, r0
 802fc18:	460f      	mov	r7, r1
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802fc1a:	b2da      	uxtb	r2, r3
 802fc1c:	d127      	bne.n	802fc6e <HAL_SUBGHZ_ExecGetCmd+0x62>
    __HAL_LOCK(hsubghz);
 802fc1e:	7943      	ldrb	r3, [r0, #5]
 802fc20:	2b01      	cmp	r3, #1
 802fc22:	d024      	beq.n	802fc6e <HAL_SUBGHZ_ExecGetCmd+0x62>
 802fc24:	7142      	strb	r2, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 802fc26:	f7ff febf 	bl	802f9a8 <SUBGHZ_CheckDeviceReady>
    LL_PWR_SelectSUBGHZSPI_NSS();
 802fc2a:	f7ff fdbb 	bl	802f7a4 <LL_PWR_SelectSUBGHZSPI_NSS>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)Command);
 802fc2e:	4639      	mov	r1, r7
 802fc30:	4620      	mov	r0, r4
 802fc32:	f7ff fe23 	bl	802f87c <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, 0x00U);
 802fc36:	2100      	movs	r1, #0
 802fc38:	4620      	mov	r0, r4
 802fc3a:	f7ff fe1f 	bl	802f87c <SUBGHZSPI_Transmit>
HAL_StatusTypeDef HAL_SUBGHZ_ReadRegisters(SUBGHZ_HandleTypeDef *hsubghz,
 802fc3e:	442e      	add	r6, r5
    for (uint16_t i = 0U; i < Size; i++)
 802fc40:	42b5      	cmp	r5, r6
 802fc42:	d10e      	bne.n	802fc62 <HAL_SUBGHZ_ExecGetCmd+0x56>
    LL_PWR_UnselectSUBGHZSPI_NSS();
 802fc44:	f7ff fda4 	bl	802f790 <LL_PWR_UnselectSUBGHZSPI_NSS>
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 802fc48:	4620      	mov	r0, r4
 802fc4a:	f7ff fe89 	bl	802f960 <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 802fc4e:	68a0      	ldr	r0, [r4, #8]
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fc50:	2301      	movs	r3, #1
      status = HAL_ERROR;
 802fc52:	3800      	subs	r0, #0
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802fc54:	71a3      	strb	r3, [r4, #6]
    __HAL_UNLOCK(hsubghz);
 802fc56:	f04f 0300 	mov.w	r3, #0
      status = HAL_ERROR;
 802fc5a:	bf18      	it	ne
 802fc5c:	2001      	movne	r0, #1
    __HAL_UNLOCK(hsubghz);
 802fc5e:	7163      	strb	r3, [r4, #5]
}
 802fc60:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void)SUBGHZSPI_Receive(hsubghz, (pData));
 802fc62:	4629      	mov	r1, r5
 802fc64:	4620      	mov	r0, r4
 802fc66:	f7ff fe41 	bl	802f8ec <SUBGHZSPI_Receive>
      pData++;
 802fc6a:	3501      	adds	r5, #1
    for (uint16_t i = 0U; i < Size; i++)
 802fc6c:	e7e8      	b.n	802fc40 <HAL_SUBGHZ_ExecGetCmd+0x34>
    return HAL_BUSY;
 802fc6e:	2002      	movs	r0, #2
 802fc70:	e7f6      	b.n	802fc60 <HAL_SUBGHZ_ExecGetCmd+0x54>

0802fc72 <HAL_SUBGHZ_IRQHandler>:
{
 802fc72:	b537      	push	{r0, r1, r2, r4, r5, lr}
  uint8_t tmpisr[2] = {0};
 802fc74:	2300      	movs	r3, #0
 802fc76:	f8ad 3004 	strh.w	r3, [sp, #4]
  (void)HAL_SUBGHZ_ExecGetCmd(hsubghz, RADIO_GET_IRQSTATUS, tmpisr, 2);
 802fc7a:	aa01      	add	r2, sp, #4
 802fc7c:	2302      	movs	r3, #2
 802fc7e:	2112      	movs	r1, #18
{
 802fc80:	4604      	mov	r4, r0
  (void)HAL_SUBGHZ_ExecGetCmd(hsubghz, RADIO_GET_IRQSTATUS, tmpisr, 2);
 802fc82:	f7ff ffc3 	bl	802fc0c <HAL_SUBGHZ_ExecGetCmd>
  itsource = (itsource << 8) | tmpisr[1];
 802fc86:	f89d 3005 	ldrb.w	r3, [sp, #5]
 802fc8a:	f89d 5004 	ldrb.w	r5, [sp, #4]
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_TX_CPLT) != RESET)
 802fc8e:	07da      	lsls	r2, r3, #31
  itsource = (itsource << 8) | tmpisr[1];
 802fc90:	ea43 2505 	orr.w	r5, r3, r5, lsl #8
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_TX_CPLT) != RESET)
 802fc94:	d502      	bpl.n	802fc9c <HAL_SUBGHZ_IRQHandler+0x2a>
    HAL_SUBGHZ_TxCpltCallback(hsubghz);
 802fc96:	4620      	mov	r0, r4
 802fc98:	f00a fea4 	bl	803a9e4 <HAL_SUBGHZ_TxCpltCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_RX_CPLT) != RESET)
 802fc9c:	07ab      	lsls	r3, r5, #30
 802fc9e:	d502      	bpl.n	802fca6 <HAL_SUBGHZ_IRQHandler+0x34>
    HAL_SUBGHZ_RxCpltCallback(hsubghz);
 802fca0:	4620      	mov	r0, r4
 802fca2:	f00a fea5 	bl	803a9f0 <HAL_SUBGHZ_RxCpltCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_PREAMBLE_DETECTED) != RESET)
 802fca6:	0768      	lsls	r0, r5, #29
 802fca8:	d502      	bpl.n	802fcb0 <HAL_SUBGHZ_IRQHandler+0x3e>
    HAL_SUBGHZ_PreambleDetectedCallback(hsubghz);
 802fcaa:	4620      	mov	r0, r4
 802fcac:	f00a feca 	bl	803aa44 <HAL_SUBGHZ_PreambleDetectedCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_SYNCWORD_VALID) != RESET)
 802fcb0:	0729      	lsls	r1, r5, #28
 802fcb2:	d502      	bpl.n	802fcba <HAL_SUBGHZ_IRQHandler+0x48>
    HAL_SUBGHZ_SyncWordValidCallback(hsubghz);
 802fcb4:	4620      	mov	r0, r4
 802fcb6:	f00a fecb 	bl	803aa50 <HAL_SUBGHZ_SyncWordValidCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_HEADER_VALID) != RESET)
 802fcba:	06ea      	lsls	r2, r5, #27
 802fcbc:	d502      	bpl.n	802fcc4 <HAL_SUBGHZ_IRQHandler+0x52>
    HAL_SUBGHZ_HeaderValidCallback(hsubghz);
 802fcbe:	4620      	mov	r0, r4
 802fcc0:	f00a fecc 	bl	803aa5c <HAL_SUBGHZ_HeaderValidCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_HEADER_ERROR) != RESET)
 802fcc4:	06ab      	lsls	r3, r5, #26
 802fcc6:	d502      	bpl.n	802fcce <HAL_SUBGHZ_IRQHandler+0x5c>
    HAL_SUBGHZ_HeaderErrorCallback(hsubghz);
 802fcc8:	4620      	mov	r0, r4
 802fcca:	f00a feb5 	bl	803aa38 <HAL_SUBGHZ_HeaderErrorCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_CRC_ERROR) != RESET)
 802fcce:	0668      	lsls	r0, r5, #25
 802fcd0:	d502      	bpl.n	802fcd8 <HAL_SUBGHZ_IRQHandler+0x66>
    HAL_SUBGHZ_CRCErrorCallback(hsubghz);
 802fcd2:	4620      	mov	r0, r4
 802fcd4:	f00a fe92 	bl	803a9fc <HAL_SUBGHZ_CRCErrorCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_CAD_DONE) != RESET)
 802fcd8:	0629      	lsls	r1, r5, #24
 802fcda:	d507      	bpl.n	802fcec <HAL_SUBGHZ_IRQHandler+0x7a>
    if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_CAD_ACTIVITY_DETECTED) != RESET)
 802fcdc:	05ea      	lsls	r2, r5, #23
 802fcde:	f3c5 2100 	ubfx	r1, r5, #8, #1
      HAL_SUBGHZ_CADStatusCallback(hsubghz, HAL_SUBGHZ_CAD_CLEAR);
 802fce2:	4620      	mov	r0, r4
      HAL_SUBGHZ_CADStatusCallback(hsubghz, HAL_SUBGHZ_CAD_DETECTED);
 802fce4:	bf48      	it	mi
 802fce6:	2101      	movmi	r1, #1
      HAL_SUBGHZ_CADStatusCallback(hsubghz, HAL_SUBGHZ_CAD_CLEAR);
 802fce8:	f00a fe8e 	bl	803aa08 <HAL_SUBGHZ_CADStatusCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_RX_TX_TIMEOUT) != RESET)
 802fcec:	05ab      	lsls	r3, r5, #22
 802fcee:	d502      	bpl.n	802fcf6 <HAL_SUBGHZ_IRQHandler+0x84>
    HAL_SUBGHZ_RxTxTimeoutCallback(hsubghz);
 802fcf0:	4620      	mov	r0, r4
 802fcf2:	f00a fe99 	bl	803aa28 <HAL_SUBGHZ_RxTxTimeoutCallback>
  (void)HAL_SUBGHZ_ExecSetCmd(hsubghz, RADIO_CLR_IRQSTATUS, tmpisr, 2);
 802fcf6:	2302      	movs	r3, #2
 802fcf8:	aa01      	add	r2, sp, #4
 802fcfa:	4619      	mov	r1, r3
 802fcfc:	4620      	mov	r0, r4
 802fcfe:	f7ff fee3 	bl	802fac8 <HAL_SUBGHZ_ExecSetCmd>
}
 802fd02:	b003      	add	sp, #12
 802fd04:	bd30      	pop	{r4, r5, pc}

0802fd06 <UART_EndTxTransfer>:
  * @retval None
  */
static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable TXEIE, TCIE, TXFT interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE | USART_CR1_TCIE));
 802fd06:	6802      	ldr	r2, [r0, #0]
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802fd08:	e852 3f00 	ldrex	r3, [r2]
 802fd0c:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802fd10:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 802fd14:	6802      	ldr	r2, [r0, #0]
 802fd16:	2900      	cmp	r1, #0
 802fd18:	d1f5      	bne.n	802fd06 <UART_EndTxTransfer>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802fd1a:	f102 0308 	add.w	r3, r2, #8
 802fd1e:	e853 3f00 	ldrex	r3, [r3]
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_TXFTIE));
 802fd22:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802fd26:	f102 0c08 	add.w	ip, r2, #8
 802fd2a:	e84c 3100 	strex	r1, r3, [ip]
 802fd2e:	2900      	cmp	r1, #0
 802fd30:	d1f3      	bne.n	802fd1a <UART_EndTxTransfer+0x14>

  /* At end of Tx process, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 802fd32:	2320      	movs	r3, #32
 802fd34:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
}
 802fd38:	4770      	bx	lr
	...

0802fd3c <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
 802fd3c:	b510      	push	{r4, lr}
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 802fd3e:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802fd40:	e852 3f00 	ldrex	r3, [r2]
 802fd44:	f423 7390 	bic.w	r3, r3, #288	; 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802fd48:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 802fd4c:	6802      	ldr	r2, [r0, #0]
 802fd4e:	2900      	cmp	r1, #0
 802fd50:	d1f5      	bne.n	802fd3e <UART_EndRxTransfer+0x2>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 802fd52:	4c0f      	ldr	r4, [pc, #60]	; (802fd90 <UART_EndRxTransfer+0x54>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802fd54:	f102 0308 	add.w	r3, r2, #8
 802fd58:	e853 3f00 	ldrex	r3, [r3]
 802fd5c:	4023      	ands	r3, r4
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802fd5e:	f102 0c08 	add.w	ip, r2, #8
 802fd62:	e84c 3100 	strex	r1, r3, [ip]
 802fd66:	2900      	cmp	r1, #0
 802fd68:	d1f4      	bne.n	802fd54 <UART_EndRxTransfer+0x18>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 802fd6a:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 802fd6c:	2b01      	cmp	r3, #1
 802fd6e:	d107      	bne.n	802fd80 <UART_EndRxTransfer+0x44>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802fd70:	e852 3f00 	ldrex	r3, [r2]
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 802fd74:	f023 0310 	bic.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802fd78:	e842 3100 	strex	r1, r3, [r2]
 802fd7c:	2900      	cmp	r1, #0
 802fd7e:	d1f7      	bne.n	802fd70 <UART_EndRxTransfer+0x34>
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 802fd80:	2320      	movs	r3, #32
 802fd82:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 802fd86:	2300      	movs	r3, #0
 802fd88:	66c3      	str	r3, [r0, #108]	; 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 802fd8a:	6703      	str	r3, [r0, #112]	; 0x70
}
 802fd8c:	bd10      	pop	{r4, pc}
 802fd8e:	bf00      	nop
 802fd90:	effffffe 	.word	0xeffffffe

0802fd94 <HAL_UART_Transmit_DMA>:
{
 802fd94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802fd96:	4604      	mov	r4, r0
 802fd98:	4613      	mov	r3, r2
  if (huart->gState == HAL_UART_STATE_READY)
 802fd9a:	f8d4 7084 	ldr.w	r7, [r4, #132]	; 0x84
 802fd9e:	2f20      	cmp	r7, #32
 802fda0:	d143      	bne.n	802fe2a <HAL_UART_Transmit_DMA+0x96>
    if ((pData == NULL) || (Size == 0U))
 802fda2:	b361      	cbz	r1, 802fdfe <HAL_UART_Transmit_DMA+0x6a>
 802fda4:	b35a      	cbz	r2, 802fdfe <HAL_UART_Transmit_DMA+0x6a>
    __HAL_LOCK(huart);
 802fda6:	f894 2080 	ldrb.w	r2, [r4, #128]	; 0x80
 802fdaa:	2a01      	cmp	r2, #1
 802fdac:	d03d      	beq.n	802fe2a <HAL_UART_Transmit_DMA+0x96>
    if (huart->hdmatx != NULL)
 802fdae:	6fa0      	ldr	r0, [r4, #120]	; 0x78
    huart->TxXferCount = Size;
 802fdb0:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
    __HAL_LOCK(huart);
 802fdb4:	2501      	movs	r5, #1
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 802fdb6:	2600      	movs	r6, #0
    huart->gState = HAL_UART_STATE_BUSY_TX;
 802fdb8:	2221      	movs	r2, #33	; 0x21
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 802fdba:	f8c4 608c 	str.w	r6, [r4, #140]	; 0x8c
    __HAL_LOCK(huart);
 802fdbe:	f884 5080 	strb.w	r5, [r4, #128]	; 0x80
    huart->pTxBuffPtr  = pData;
 802fdc2:	6521      	str	r1, [r4, #80]	; 0x50
    huart->TxXferSize  = Size;
 802fdc4:	f8a4 3054 	strh.w	r3, [r4, #84]	; 0x54
    huart->gState = HAL_UART_STATE_BUSY_TX;
 802fdc8:	f8c4 2084 	str.w	r2, [r4, #132]	; 0x84
    if (huart->hdmatx != NULL)
 802fdcc:	b1c8      	cbz	r0, 802fe02 <HAL_UART_Transmit_DMA+0x6e>
      huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
 802fdce:	f8df c060 	ldr.w	ip, [pc, #96]	; 802fe30 <HAL_UART_Transmit_DMA+0x9c>
 802fdd2:	6822      	ldr	r2, [r4, #0]
 802fdd4:	f8c0 c02c 	str.w	ip, [r0, #44]	; 0x2c
      huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
 802fdd8:	f8df c058 	ldr.w	ip, [pc, #88]	; 802fe34 <HAL_UART_Transmit_DMA+0xa0>
 802fddc:	f8c0 c030 	str.w	ip, [r0, #48]	; 0x30
      huart->hdmatx->XferErrorCallback = UART_DMAError;
 802fde0:	f8df c054 	ldr.w	ip, [pc, #84]	; 802fe38 <HAL_UART_Transmit_DMA+0xa4>
      if (HAL_DMA_Start_IT(huart->hdmatx, (uint32_t)huart->pTxBuffPtr, (uint32_t)&huart->Instance->TDR, Size) != HAL_OK)
 802fde4:	3228      	adds	r2, #40	; 0x28
      huart->hdmatx->XferAbortCallback = NULL;
 802fde6:	e9c0 c60d 	strd	ip, r6, [r0, #52]	; 0x34
      if (HAL_DMA_Start_IT(huart->hdmatx, (uint32_t)huart->pTxBuffPtr, (uint32_t)&huart->Instance->TDR, Size) != HAL_OK)
 802fdea:	f7fe f8f1 	bl	802dfd0 <HAL_DMA_Start_IT>
 802fdee:	b140      	cbz	r0, 802fe02 <HAL_UART_Transmit_DMA+0x6e>
        huart->ErrorCode = HAL_UART_ERROR_DMA;
 802fdf0:	2310      	movs	r3, #16
 802fdf2:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
        __HAL_UNLOCK(huart);
 802fdf6:	f884 6080 	strb.w	r6, [r4, #128]	; 0x80
        huart->gState = HAL_UART_STATE_READY;
 802fdfa:	f8c4 7084 	str.w	r7, [r4, #132]	; 0x84
      return HAL_ERROR;
 802fdfe:	2001      	movs	r0, #1
 802fe00:	e012      	b.n	802fe28 <HAL_UART_Transmit_DMA+0x94>
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_TCF);
 802fe02:	6823      	ldr	r3, [r4, #0]
 802fe04:	2240      	movs	r2, #64	; 0x40
 802fe06:	621a      	str	r2, [r3, #32]
    __HAL_UNLOCK(huart);
 802fe08:	2300      	movs	r3, #0
 802fe0a:	6822      	ldr	r2, [r4, #0]
 802fe0c:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802fe10:	f102 0308 	add.w	r3, r2, #8
 802fe14:	e853 3f00 	ldrex	r3, [r3]
    ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 802fe18:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802fe1c:	f102 0108 	add.w	r1, r2, #8
 802fe20:	e841 3000 	strex	r0, r3, [r1]
 802fe24:	2800      	cmp	r0, #0
 802fe26:	d1f3      	bne.n	802fe10 <HAL_UART_Transmit_DMA+0x7c>
}
 802fe28:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_BUSY;
 802fe2a:	2002      	movs	r0, #2
 802fe2c:	e7fc      	b.n	802fe28 <HAL_UART_Transmit_DMA+0x94>
 802fe2e:	bf00      	nop
 802fe30:	0802fe3d 	.word	0x0802fe3d
 802fe34:	0802fe85 	.word	0x0802fe85
 802fe38:	0802fe91 	.word	0x0802fe91

0802fe3c <UART_DMATransmitCplt>:
  * @brief DMA UART transmit process complete callback.
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
{
 802fe3c:	b508      	push	{r3, lr}
 802fe3e:	4603      	mov	r3, r0
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 802fe40:	6a80      	ldr	r0, [r0, #40]	; 0x28

  /* DMA Normal mode */
  if (HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC))
 802fe42:	681b      	ldr	r3, [r3, #0]
 802fe44:	681b      	ldr	r3, [r3, #0]
 802fe46:	f013 0320 	ands.w	r3, r3, #32
 802fe4a:	d117      	bne.n	802fe7c <UART_DMATransmitCplt+0x40>
  {
    huart->TxXferCount = 0U;
 802fe4c:	f8a0 3056 	strh.w	r3, [r0, #86]	; 0x56

    /* Disable the DMA transfer for transmit request by resetting the DMAT bit
       in the UART CR3 register */
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 802fe50:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802fe52:	f102 0308 	add.w	r3, r2, #8
 802fe56:	e853 3f00 	ldrex	r3, [r3]
 802fe5a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802fe5e:	3208      	adds	r2, #8
 802fe60:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 802fe64:	6802      	ldr	r2, [r0, #0]
 802fe66:	2900      	cmp	r1, #0
 802fe68:	d1f2      	bne.n	802fe50 <UART_DMATransmitCplt+0x14>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802fe6a:	e852 3f00 	ldrex	r3, [r2]

    /* Enable the UART Transmit Complete Interrupt */
    ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 802fe6e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802fe72:	e842 3100 	strex	r1, r3, [r2]
 802fe76:	2900      	cmp	r1, #0
 802fe78:	d1f7      	bne.n	802fe6a <UART_DMATransmitCplt+0x2e>
#else
    /*Call legacy weak Tx complete callback*/
    HAL_UART_TxCpltCallback(huart);
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
  }
}
 802fe7a:	bd08      	pop	{r3, pc}
    HAL_UART_TxCpltCallback(huart);
 802fe7c:	f7fc fe38 	bl	802caf0 <HAL_UART_TxCpltCallback>
}
 802fe80:	e7fb      	b.n	802fe7a <UART_DMATransmitCplt+0x3e>

0802fe82 <HAL_UART_TxHalfCpltCallback>:
 802fe82:	4770      	bx	lr

0802fe84 <UART_DMATxHalfCplt>:
  * @brief DMA UART transmit process half complete callback.
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
{
 802fe84:	b508      	push	{r3, lr}
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx Half complete callback*/
  huart->TxHalfCpltCallback(huart);
#else
  /*Call legacy weak Tx Half complete callback*/
  HAL_UART_TxHalfCpltCallback(huart);
 802fe86:	6a80      	ldr	r0, [r0, #40]	; 0x28
 802fe88:	f7ff fffb 	bl	802fe82 <HAL_UART_TxHalfCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 802fe8c:	bd08      	pop	{r3, pc}

0802fe8e <HAL_UART_ErrorCallback>:
 802fe8e:	4770      	bx	lr

0802fe90 <UART_DMAError>:
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMAError(DMA_HandleTypeDef *hdma)
{
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 802fe90:	6a80      	ldr	r0, [r0, #40]	; 0x28

  const HAL_UART_StateTypeDef gstate = huart->gState;
  const HAL_UART_StateTypeDef rxstate = huart->RxState;

  /* Stop UART DMA Tx request if ongoing */
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
 802fe92:	6802      	ldr	r2, [r0, #0]
  const HAL_UART_StateTypeDef gstate = huart->gState;
 802fe94:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
{
 802fe98:	b510      	push	{r4, lr}
  const HAL_UART_StateTypeDef rxstate = huart->RxState;
 802fe9a:	f8d0 4088 	ldr.w	r4, [r0, #136]	; 0x88
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
 802fe9e:	6892      	ldr	r2, [r2, #8]
 802fea0:	0612      	lsls	r2, r2, #24
 802fea2:	d506      	bpl.n	802feb2 <UART_DMAError+0x22>
 802fea4:	2b21      	cmp	r3, #33	; 0x21
 802fea6:	d104      	bne.n	802feb2 <UART_DMAError+0x22>
      (gstate == HAL_UART_STATE_BUSY_TX))
  {
    huart->TxXferCount = 0U;
 802fea8:	2300      	movs	r3, #0
 802feaa:	f8a0 3056 	strh.w	r3, [r0, #86]	; 0x56
    UART_EndTxTransfer(huart);
 802feae:	f7ff ff2a 	bl	802fd06 <UART_EndTxTransfer>
  }

  /* Stop UART DMA Rx request if ongoing */
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) &&
 802feb2:	6803      	ldr	r3, [r0, #0]
 802feb4:	689b      	ldr	r3, [r3, #8]
 802feb6:	065b      	lsls	r3, r3, #25
 802feb8:	d506      	bpl.n	802fec8 <UART_DMAError+0x38>
 802feba:	2c22      	cmp	r4, #34	; 0x22
 802febc:	d104      	bne.n	802fec8 <UART_DMAError+0x38>
      (rxstate == HAL_UART_STATE_BUSY_RX))
  {
    huart->RxXferCount = 0U;
 802febe:	2300      	movs	r3, #0
 802fec0:	f8a0 305e 	strh.w	r3, [r0, #94]	; 0x5e
    UART_EndRxTransfer(huart);
 802fec4:	f7ff ff3a 	bl	802fd3c <UART_EndRxTransfer>
  }

  huart->ErrorCode |= HAL_UART_ERROR_DMA;
 802fec8:	f8d0 308c 	ldr.w	r3, [r0, #140]	; 0x8c
 802fecc:	f043 0310 	orr.w	r3, r3, #16
 802fed0:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 802fed4:	f7ff ffdb 	bl	802fe8e <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 802fed8:	bd10      	pop	{r4, pc}

0802feda <UART_DMAAbortOnError>:
  *         (To be called at end of DMA Abort procedure following error occurrence).
  * @param  hdma DMA handle.
  * @retval None
  */
static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
 802feda:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 802fedc:	6a80      	ldr	r0, [r0, #40]	; 0x28
  huart->RxXferCount = 0U;
 802fede:	2300      	movs	r3, #0
 802fee0:	f8a0 305e 	strh.w	r3, [r0, #94]	; 0x5e
  huart->TxXferCount = 0U;
 802fee4:	f8a0 3056 	strh.w	r3, [r0, #86]	; 0x56
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 802fee8:	f7ff ffd1 	bl	802fe8e <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 802feec:	bd08      	pop	{r3, pc}

0802feee <HAL_UARTEx_RxEventCallback>:
}
 802feee:	4770      	bx	lr

0802fef0 <HAL_UART_IRQHandler>:
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
 802fef0:	6803      	ldr	r3, [r0, #0]
 802fef2:	69da      	ldr	r2, [r3, #28]
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 802fef4:	6819      	ldr	r1, [r3, #0]
{
 802fef6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (errorflags == 0U)
 802fefa:	f640 060f 	movw	r6, #2063	; 0x80f
 802fefe:	4232      	tst	r2, r6
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 802ff00:	689d      	ldr	r5, [r3, #8]
{
 802ff02:	4604      	mov	r4, r0
  if (errorflags == 0U)
 802ff04:	d110      	bne.n	802ff28 <HAL_UART_IRQHandler+0x38>
    if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)
 802ff06:	0696      	lsls	r6, r2, #26
 802ff08:	f140 8096 	bpl.w	8030038 <HAL_UART_IRQHandler+0x148>
        && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)
 802ff0c:	f001 0620 	and.w	r6, r1, #32
            || ((cr3its & USART_CR3_RXFTIE) != 0U)))
 802ff10:	f005 5780 	and.w	r7, r5, #268435456	; 0x10000000
 802ff14:	433e      	orrs	r6, r7
 802ff16:	f000 808f 	beq.w	8030038 <HAL_UART_IRQHandler+0x148>
      if (huart->RxISR != NULL)
 802ff1a:	6f03      	ldr	r3, [r0, #112]	; 0x70
 802ff1c:	2b00      	cmp	r3, #0
 802ff1e:	f000 8084 	beq.w	803002a <HAL_UART_IRQHandler+0x13a>
}
 802ff22:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 802ff26:	4718      	bx	r3
      && ((((cr3its & (USART_CR3_RXFTIE | USART_CR3_EIE)) != 0U)
 802ff28:	4ea7      	ldr	r6, [pc, #668]	; (80301c8 <HAL_UART_IRQHandler+0x2d8>)
           || ((cr1its & (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_RTOIE)) != 0U))))
 802ff2a:	48a8      	ldr	r0, [pc, #672]	; (80301cc <HAL_UART_IRQHandler+0x2dc>)
      && ((((cr3its & (USART_CR3_RXFTIE | USART_CR3_EIE)) != 0U)
 802ff2c:	402e      	ands	r6, r5
           || ((cr1its & (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_RTOIE)) != 0U))))
 802ff2e:	4008      	ands	r0, r1
 802ff30:	4330      	orrs	r0, r6
 802ff32:	f000 8081 	beq.w	8030038 <HAL_UART_IRQHandler+0x148>
    if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 802ff36:	07d7      	lsls	r7, r2, #31
 802ff38:	d509      	bpl.n	802ff4e <HAL_UART_IRQHandler+0x5e>
 802ff3a:	05c8      	lsls	r0, r1, #23
 802ff3c:	d507      	bpl.n	802ff4e <HAL_UART_IRQHandler+0x5e>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 802ff3e:	2001      	movs	r0, #1
 802ff40:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 802ff42:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 802ff46:	f040 0001 	orr.w	r0, r0, #1
 802ff4a:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 802ff4e:	0797      	lsls	r7, r2, #30
 802ff50:	d509      	bpl.n	802ff66 <HAL_UART_IRQHandler+0x76>
 802ff52:	07e8      	lsls	r0, r5, #31
 802ff54:	d507      	bpl.n	802ff66 <HAL_UART_IRQHandler+0x76>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 802ff56:	2002      	movs	r0, #2
 802ff58:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 802ff5a:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 802ff5e:	f040 0004 	orr.w	r0, r0, #4
 802ff62:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 802ff66:	0757      	lsls	r7, r2, #29
 802ff68:	d509      	bpl.n	802ff7e <HAL_UART_IRQHandler+0x8e>
 802ff6a:	07e8      	lsls	r0, r5, #31
 802ff6c:	d507      	bpl.n	802ff7e <HAL_UART_IRQHandler+0x8e>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 802ff6e:	2004      	movs	r0, #4
 802ff70:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 802ff72:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 802ff76:	f040 0002 	orr.w	r0, r0, #2
 802ff7a:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    if (((isrflags & USART_ISR_ORE) != 0U)
 802ff7e:	0717      	lsls	r7, r2, #28
 802ff80:	d50b      	bpl.n	802ff9a <HAL_UART_IRQHandler+0xaa>
        && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U) ||
 802ff82:	f001 0020 	and.w	r0, r1, #32
 802ff86:	4330      	orrs	r0, r6
 802ff88:	d007      	beq.n	802ff9a <HAL_UART_IRQHandler+0xaa>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 802ff8a:	2008      	movs	r0, #8
 802ff8c:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 802ff8e:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 802ff92:	f040 0008 	orr.w	r0, r0, #8
 802ff96:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    if (((isrflags & USART_ISR_RTOF) != 0U) && ((cr1its & USART_CR1_RTOIE) != 0U))
 802ff9a:	0516      	lsls	r6, r2, #20
 802ff9c:	d50a      	bpl.n	802ffb4 <HAL_UART_IRQHandler+0xc4>
 802ff9e:	0148      	lsls	r0, r1, #5
 802ffa0:	d508      	bpl.n	802ffb4 <HAL_UART_IRQHandler+0xc4>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 802ffa2:	f44f 6000 	mov.w	r0, #2048	; 0x800
 802ffa6:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_RTO;
 802ffa8:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 802ffac:	f043 0320 	orr.w	r3, r3, #32
 802ffb0:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 802ffb4:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 802ffb8:	2b00      	cmp	r3, #0
 802ffba:	d036      	beq.n	803002a <HAL_UART_IRQHandler+0x13a>
      if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)
 802ffbc:	0693      	lsls	r3, r2, #26
 802ffbe:	d50a      	bpl.n	802ffd6 <HAL_UART_IRQHandler+0xe6>
          && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)
 802ffc0:	f001 0120 	and.w	r1, r1, #32
              || ((cr3its & USART_CR3_RXFTIE) != 0U)))
 802ffc4:	f005 5580 	and.w	r5, r5, #268435456	; 0x10000000
 802ffc8:	ea51 0305 	orrs.w	r3, r1, r5
 802ffcc:	d003      	beq.n	802ffd6 <HAL_UART_IRQHandler+0xe6>
        if (huart->RxISR != NULL)
 802ffce:	6f23      	ldr	r3, [r4, #112]	; 0x70
 802ffd0:	b10b      	cbz	r3, 802ffd6 <HAL_UART_IRQHandler+0xe6>
          huart->RxISR(huart);
 802ffd2:	4620      	mov	r0, r4
 802ffd4:	4798      	blx	r3
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 802ffd6:	6823      	ldr	r3, [r4, #0]
      errorcode = huart->ErrorCode;
 802ffd8:	f8d4 508c 	ldr.w	r5, [r4, #140]	; 0x8c
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 802ffdc:	689b      	ldr	r3, [r3, #8]
          ((errorcode & (HAL_UART_ERROR_RTO | HAL_UART_ERROR_ORE)) != 0U))
 802ffde:	f005 0528 	and.w	r5, r5, #40	; 0x28
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 802ffe2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 802ffe6:	431d      	orrs	r5, r3
        UART_EndRxTransfer(huart);
 802ffe8:	4620      	mov	r0, r4
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 802ffea:	d020      	beq.n	803002e <HAL_UART_IRQHandler+0x13e>
        UART_EndRxTransfer(huart);
 802ffec:	f7ff fea6 	bl	802fd3c <UART_EndRxTransfer>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 802fff0:	6822      	ldr	r2, [r4, #0]
 802fff2:	6893      	ldr	r3, [r2, #8]
 802fff4:	065f      	lsls	r7, r3, #25
 802fff6:	d515      	bpl.n	8030024 <HAL_UART_IRQHandler+0x134>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802fff8:	f102 0308 	add.w	r3, r2, #8
 802fffc:	e853 3f00 	ldrex	r3, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8030000:	f023 0340 	bic.w	r3, r3, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030004:	f102 0008 	add.w	r0, r2, #8
 8030008:	e840 3100 	strex	r1, r3, [r0]
 803000c:	2900      	cmp	r1, #0
 803000e:	d1f3      	bne.n	802fff8 <HAL_UART_IRQHandler+0x108>
          if (huart->hdmarx != NULL)
 8030010:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 8030012:	b138      	cbz	r0, 8030024 <HAL_UART_IRQHandler+0x134>
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 8030014:	4b6e      	ldr	r3, [pc, #440]	; (80301d0 <HAL_UART_IRQHandler+0x2e0>)
 8030016:	6383      	str	r3, [r0, #56]	; 0x38
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 8030018:	f7fe f854 	bl	802e0c4 <HAL_DMA_Abort_IT>
 803001c:	b128      	cbz	r0, 803002a <HAL_UART_IRQHandler+0x13a>
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 803001e:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 8030020:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8030022:	e77e      	b.n	802ff22 <HAL_UART_IRQHandler+0x32>
            HAL_UART_ErrorCallback(huart);
 8030024:	4620      	mov	r0, r4
 8030026:	f7ff ff32 	bl	802fe8e <HAL_UART_ErrorCallback>
}
 803002a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        HAL_UART_ErrorCallback(huart);
 803002e:	f7ff ff2e 	bl	802fe8e <HAL_UART_ErrorCallback>
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 8030032:	f8c4 508c 	str.w	r5, [r4, #140]	; 0x8c
 8030036:	e7f8      	b.n	803002a <HAL_UART_IRQHandler+0x13a>
  if (  (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8030038:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 803003a:	2801      	cmp	r0, #1
 803003c:	f040 8081 	bne.w	8030142 <HAL_UART_IRQHandler+0x252>
      &&((isrflags & USART_ISR_IDLE) != 0U)
 8030040:	06d6      	lsls	r6, r2, #27
 8030042:	d57e      	bpl.n	8030142 <HAL_UART_IRQHandler+0x252>
      &&((cr1its & USART_ISR_IDLE) != 0U))
 8030044:	06c8      	lsls	r0, r1, #27
 8030046:	d57c      	bpl.n	8030142 <HAL_UART_IRQHandler+0x252>
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 8030048:	2210      	movs	r2, #16
 803004a:	621a      	str	r2, [r3, #32]
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 803004c:	689a      	ldr	r2, [r3, #8]
 803004e:	0651      	lsls	r1, r2, #25
 8030050:	d547      	bpl.n	80300e2 <HAL_UART_IRQHandler+0x1f2>
      uint16_t nb_remaining_rx_data = (uint16_t) __HAL_DMA_GET_COUNTER(huart->hdmarx);
 8030052:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
 8030054:	6811      	ldr	r1, [r2, #0]
 8030056:	684a      	ldr	r2, [r1, #4]
 8030058:	b292      	uxth	r2, r2
      if (  (nb_remaining_rx_data > 0U)
 803005a:	2a00      	cmp	r2, #0
 803005c:	d0e5      	beq.n	803002a <HAL_UART_IRQHandler+0x13a>
          &&(nb_remaining_rx_data < huart->RxXferSize))
 803005e:	f8b4 005c 	ldrh.w	r0, [r4, #92]	; 0x5c
 8030062:	4290      	cmp	r0, r2
 8030064:	d9e1      	bls.n	803002a <HAL_UART_IRQHandler+0x13a>
        huart->RxXferCount = nb_remaining_rx_data;
 8030066:	f8a4 205e 	strh.w	r2, [r4, #94]	; 0x5e
        if (HAL_IS_BIT_CLR(huart->hdmarx->Instance->CCR, DMA_CCR_CIRC))
 803006a:	680a      	ldr	r2, [r1, #0]
 803006c:	0692      	lsls	r2, r2, #26
 803006e:	d42e      	bmi.n	80300ce <HAL_UART_IRQHandler+0x1de>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030070:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8030074:	f422 7280 	bic.w	r2, r2, #256	; 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030078:	e843 2100 	strex	r1, r2, [r3]
 803007c:	2900      	cmp	r1, #0
 803007e:	d1f7      	bne.n	8030070 <HAL_UART_IRQHandler+0x180>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030080:	f103 0208 	add.w	r2, r3, #8
 8030084:	e852 2f00 	ldrex	r2, [r2]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8030088:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 803008c:	f103 0008 	add.w	r0, r3, #8
 8030090:	e840 2100 	strex	r1, r2, [r0]
 8030094:	2900      	cmp	r1, #0
 8030096:	d1f3      	bne.n	8030080 <HAL_UART_IRQHandler+0x190>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030098:	f103 0208 	add.w	r2, r3, #8
 803009c:	e852 2f00 	ldrex	r2, [r2]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 80300a0:	f022 0240 	bic.w	r2, r2, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80300a4:	f103 0008 	add.w	r0, r3, #8
 80300a8:	e840 2100 	strex	r1, r2, [r0]
 80300ac:	2900      	cmp	r1, #0
 80300ae:	d1f3      	bne.n	8030098 <HAL_UART_IRQHandler+0x1a8>
          huart->RxState = HAL_UART_STATE_READY;
 80300b0:	2220      	movs	r2, #32
 80300b2:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80300b6:	66e1      	str	r1, [r4, #108]	; 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80300b8:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 80300bc:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80300c0:	e843 2100 	strex	r1, r2, [r3]
 80300c4:	2900      	cmp	r1, #0
 80300c6:	d1f7      	bne.n	80300b8 <HAL_UART_IRQHandler+0x1c8>
          (void)HAL_DMA_Abort(huart->hdmarx);
 80300c8:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 80300ca:	f7fd ffc6 	bl	802e05a <HAL_DMA_Abort>
        HAL_UARTEx_RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
 80300ce:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 80300d2:	f8b4 105c 	ldrh.w	r1, [r4, #92]	; 0x5c
 80300d6:	1ac9      	subs	r1, r1, r3
 80300d8:	b289      	uxth	r1, r1
        HAL_UARTEx_RxEventCallback(huart, nb_rx_data);
 80300da:	4620      	mov	r0, r4
 80300dc:	f7ff ff07 	bl	802feee <HAL_UARTEx_RxEventCallback>
 80300e0:	e7a3      	b.n	803002a <HAL_UART_IRQHandler+0x13a>
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 80300e2:	f8b4 105e 	ldrh.w	r1, [r4, #94]	; 0x5e
 80300e6:	b28a      	uxth	r2, r1
      if (  (huart->RxXferCount > 0U)
 80300e8:	f8b4 105e 	ldrh.w	r1, [r4, #94]	; 0x5e
 80300ec:	b289      	uxth	r1, r1
 80300ee:	2900      	cmp	r1, #0
 80300f0:	d09b      	beq.n	803002a <HAL_UART_IRQHandler+0x13a>
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 80300f2:	f8b4 105c 	ldrh.w	r1, [r4, #92]	; 0x5c
 80300f6:	1a89      	subs	r1, r1, r2
 80300f8:	b289      	uxth	r1, r1
          &&(nb_rx_data > 0U) )
 80300fa:	2900      	cmp	r1, #0
 80300fc:	d095      	beq.n	803002a <HAL_UART_IRQHandler+0x13a>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80300fe:	e853 2f00 	ldrex	r2, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 8030102:	f422 7290 	bic.w	r2, r2, #288	; 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030106:	e843 2000 	strex	r0, r2, [r3]
 803010a:	2800      	cmp	r0, #0
 803010c:	d1f7      	bne.n	80300fe <HAL_UART_IRQHandler+0x20e>
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 803010e:	4d31      	ldr	r5, [pc, #196]	; (80301d4 <HAL_UART_IRQHandler+0x2e4>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030110:	f103 0208 	add.w	r2, r3, #8
 8030114:	e852 2f00 	ldrex	r2, [r2]
 8030118:	402a      	ands	r2, r5
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 803011a:	f103 0608 	add.w	r6, r3, #8
 803011e:	e846 2000 	strex	r0, r2, [r6]
 8030122:	2800      	cmp	r0, #0
 8030124:	d1f4      	bne.n	8030110 <HAL_UART_IRQHandler+0x220>
        huart->RxState = HAL_UART_STATE_READY;
 8030126:	2220      	movs	r2, #32
 8030128:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
        huart->RxISR = NULL;
 803012c:	6720      	str	r0, [r4, #112]	; 0x70
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 803012e:	66e0      	str	r0, [r4, #108]	; 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030130:	e853 2f00 	ldrex	r2, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8030134:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030138:	e843 2000 	strex	r0, r2, [r3]
 803013c:	2800      	cmp	r0, #0
 803013e:	d1f7      	bne.n	8030130 <HAL_UART_IRQHandler+0x240>
 8030140:	e7cb      	b.n	80300da <HAL_UART_IRQHandler+0x1ea>
  if (((isrflags & USART_ISR_WUF) != 0U) && ((cr3its & USART_CR3_WUFIE) != 0U))
 8030142:	02d7      	lsls	r7, r2, #11
 8030144:	d509      	bpl.n	803015a <HAL_UART_IRQHandler+0x26a>
 8030146:	026e      	lsls	r6, r5, #9
 8030148:	d507      	bpl.n	803015a <HAL_UART_IRQHandler+0x26a>
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);
 803014a:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    HAL_UARTEx_WakeupCallback(huart);
 803014e:	4620      	mov	r0, r4
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);
 8030150:	621a      	str	r2, [r3, #32]
}
 8030152:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    HAL_UARTEx_WakeupCallback(huart);
 8030156:	f000 bd35 	b.w	8030bc4 <HAL_UARTEx_WakeupCallback>
  if (((isrflags & USART_ISR_TXE_TXFNF) != 0U)
 803015a:	0610      	lsls	r0, r2, #24
 803015c:	d50b      	bpl.n	8030176 <HAL_UART_IRQHandler+0x286>
      && (((cr1its & USART_CR1_TXEIE_TXFNFIE) != 0U)
 803015e:	f001 0080 	and.w	r0, r1, #128	; 0x80
          || ((cr3its & USART_CR3_TXFTIE) != 0U)))
 8030162:	f405 0500 	and.w	r5, r5, #8388608	; 0x800000
 8030166:	4328      	orrs	r0, r5
 8030168:	d005      	beq.n	8030176 <HAL_UART_IRQHandler+0x286>
    if (huart->TxISR != NULL)
 803016a:	6f63      	ldr	r3, [r4, #116]	; 0x74
 803016c:	2b00      	cmp	r3, #0
 803016e:	f43f af5c 	beq.w	803002a <HAL_UART_IRQHandler+0x13a>
      huart->TxISR(huart);
 8030172:	4620      	mov	r0, r4
 8030174:	e6d5      	b.n	802ff22 <HAL_UART_IRQHandler+0x32>
  if (((isrflags & USART_ISR_TC) != 0U) && ((cr1its & USART_CR1_TCIE) != 0U))
 8030176:	0657      	lsls	r7, r2, #25
 8030178:	d511      	bpl.n	803019e <HAL_UART_IRQHandler+0x2ae>
 803017a:	064e      	lsls	r6, r1, #25
 803017c:	d50f      	bpl.n	803019e <HAL_UART_IRQHandler+0x2ae>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 803017e:	e853 2f00 	ldrex	r2, [r3]
  * @retval None
  */
static void UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
  /* Disable the UART Transmit Complete Interrupt */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8030182:	f022 0240 	bic.w	r2, r2, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030186:	e843 2100 	strex	r1, r2, [r3]
 803018a:	2900      	cmp	r1, #0
 803018c:	d1f7      	bne.n	803017e <HAL_UART_IRQHandler+0x28e>

  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 803018e:	2320      	movs	r3, #32
 8030190:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84

  /* Cleat TxISR function pointer */
  huart->TxISR = NULL;
 8030194:	6761      	str	r1, [r4, #116]	; 0x74
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx complete callback*/
  huart->TxCpltCallback(huart);
#else
  /*Call legacy weak Tx complete callback*/
  HAL_UART_TxCpltCallback(huart);
 8030196:	4620      	mov	r0, r4
 8030198:	f7fc fcaa 	bl	802caf0 <HAL_UART_TxCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 803019c:	e745      	b.n	803002a <HAL_UART_IRQHandler+0x13a>
  if (((isrflags & USART_ISR_TXFE) != 0U) && ((cr1its & USART_CR1_TXFEIE) != 0U))
 803019e:	0215      	lsls	r5, r2, #8
 80301a0:	d506      	bpl.n	80301b0 <HAL_UART_IRQHandler+0x2c0>
 80301a2:	0048      	lsls	r0, r1, #1
 80301a4:	d504      	bpl.n	80301b0 <HAL_UART_IRQHandler+0x2c0>
    HAL_UARTEx_TxFifoEmptyCallback(huart);
 80301a6:	4620      	mov	r0, r4
}
 80301a8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    HAL_UARTEx_TxFifoEmptyCallback(huart);
 80301ac:	f000 bd0c 	b.w	8030bc8 <HAL_UARTEx_TxFifoEmptyCallback>
  if (((isrflags & USART_ISR_RXFF) != 0U) && ((cr1its & USART_CR1_RXFFIE) != 0U))
 80301b0:	01d3      	lsls	r3, r2, #7
 80301b2:	f57f af3a 	bpl.w	803002a <HAL_UART_IRQHandler+0x13a>
 80301b6:	2900      	cmp	r1, #0
 80301b8:	f6bf af37 	bge.w	803002a <HAL_UART_IRQHandler+0x13a>
    HAL_UARTEx_RxFifoFullCallback(huart);
 80301bc:	4620      	mov	r0, r4
}
 80301be:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    HAL_UARTEx_RxFifoFullCallback(huart);
 80301c2:	f000 bd00 	b.w	8030bc6 <HAL_UARTEx_RxFifoFullCallback>
 80301c6:	bf00      	nop
 80301c8:	10000001 	.word	0x10000001
 80301cc:	04000120 	.word	0x04000120
 80301d0:	0802fedb 	.word	0x0802fedb
 80301d4:	effffffe 	.word	0xeffffffe

080301d8 <UART_RxISR_16BIT.part.0>:
/**
  * @brief RX interrupt handler for 7 or 8 bits data word length .
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_8BIT(UART_HandleTypeDef *huart)
 80301d8:	b508      	push	{r3, lr}
    huart->RxXferCount--;

    if (huart->RxXferCount == 0U)
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupts */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 80301da:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80301dc:	e852 3f00 	ldrex	r3, [r2]
 80301e0:	f423 7390 	bic.w	r3, r3, #288	; 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80301e4:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 80301e8:	6803      	ldr	r3, [r0, #0]
 80301ea:	2900      	cmp	r1, #0
 80301ec:	d1f5      	bne.n	80301da <UART_RxISR_16BIT.part.0+0x2>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80301ee:	f103 0208 	add.w	r2, r3, #8
 80301f2:	e852 2f00 	ldrex	r2, [r2]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80301f6:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80301fa:	f103 0c08 	add.w	ip, r3, #8
 80301fe:	e84c 2100 	strex	r1, r2, [ip]
 8030202:	2900      	cmp	r1, #0
 8030204:	d1f3      	bne.n	80301ee <UART_RxISR_16BIT.part.0+0x16>

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 8030206:	2220      	movs	r2, #32
 8030208:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
      /* Clear RxISR function pointer */
      huart->RxISR = NULL;

      /* Check current reception Mode :
         If Reception till IDLE event has been selected : */
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 803020c:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
      huart->RxISR = NULL;
 803020e:	6701      	str	r1, [r0, #112]	; 0x70
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8030210:	2a01      	cmp	r2, #1
 8030212:	d112      	bne.n	803023a <UART_RxISR_16BIT.part.0+0x62>
      {
        /* Set reception type to Standard */
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8030214:	66c1      	str	r1, [r0, #108]	; 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030216:	e853 2f00 	ldrex	r2, [r3]

        /* Disable IDLE interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 803021a:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 803021e:	e843 2100 	strex	r1, r2, [r3]
 8030222:	2900      	cmp	r1, #0
 8030224:	d1f7      	bne.n	8030216 <UART_RxISR_16BIT.part.0+0x3e>

        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 8030226:	69da      	ldr	r2, [r3, #28]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, huart->RxXferSize);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8030228:	f8b0 105c 	ldrh.w	r1, [r0, #92]	; 0x5c
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 803022c:	06d2      	lsls	r2, r2, #27
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 803022e:	bf44      	itt	mi
 8030230:	2210      	movmi	r2, #16
 8030232:	621a      	strmi	r2, [r3, #32]
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8030234:	f7ff fe5b 	bl	802feee <HAL_UARTEx_RxEventCallback>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 8030238:	bd08      	pop	{r3, pc}
        HAL_UART_RxCpltCallback(huart);
 803023a:	f7fc fc5f 	bl	802cafc <HAL_UART_RxCpltCallback>
}
 803023e:	e7fb      	b.n	8030238 <UART_RxISR_16BIT.part.0+0x60>

08030240 <UART_RxISR_16BIT>:
  uint16_t *tmp;
  uint16_t uhMask = huart->Mask;
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8030240:	f8d0 1088 	ldr.w	r1, [r0, #136]	; 0x88
 8030244:	6802      	ldr	r2, [r0, #0]
 8030246:	2922      	cmp	r1, #34	; 0x22
 8030248:	d113      	bne.n	8030272 <UART_RxISR_16BIT+0x32>
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 803024a:	6a51      	ldr	r1, [r2, #36]	; 0x24
    tmp = (uint16_t *) huart->pRxBuffPtr ;
    *tmp = (uint16_t)(uhdata & uhMask);
 803024c:	f8b0 2060 	ldrh.w	r2, [r0, #96]	; 0x60
 8030250:	4011      	ands	r1, r2
 8030252:	6d82      	ldr	r2, [r0, #88]	; 0x58
 8030254:	f822 1b02 	strh.w	r1, [r2], #2
    huart->pRxBuffPtr += 2U;
 8030258:	6582      	str	r2, [r0, #88]	; 0x58
    huart->RxXferCount--;
 803025a:	f8b0 205e 	ldrh.w	r2, [r0, #94]	; 0x5e
 803025e:	3a01      	subs	r2, #1
 8030260:	b292      	uxth	r2, r2
 8030262:	f8a0 205e 	strh.w	r2, [r0, #94]	; 0x5e

    if (huart->RxXferCount == 0U)
 8030266:	f8b0 305e 	ldrh.w	r3, [r0, #94]	; 0x5e
 803026a:	b29b      	uxth	r3, r3
 803026c:	b92b      	cbnz	r3, 803027a <UART_RxISR_16BIT+0x3a>
 803026e:	f7ff bfb3 	b.w	80301d8 <UART_RxISR_16BIT.part.0>
    }
  }
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 8030272:	6993      	ldr	r3, [r2, #24]
 8030274:	f043 0308 	orr.w	r3, r3, #8
 8030278:	6193      	str	r3, [r2, #24]
  }
}
 803027a:	4770      	bx	lr

0803027c <UART_RxISR_8BIT>:
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 803027c:	f8d0 1088 	ldr.w	r1, [r0, #136]	; 0x88
 8030280:	6802      	ldr	r2, [r0, #0]
 8030282:	2922      	cmp	r1, #34	; 0x22
{
 8030284:	b410      	push	{r4}
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8030286:	d115      	bne.n	80302b4 <UART_RxISR_8BIT+0x38>
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8030288:	6a52      	ldr	r2, [r2, #36]	; 0x24
    *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 803028a:	f890 4060 	ldrb.w	r4, [r0, #96]	; 0x60
 803028e:	6d81      	ldr	r1, [r0, #88]	; 0x58
 8030290:	4022      	ands	r2, r4
 8030292:	700a      	strb	r2, [r1, #0]
    huart->pRxBuffPtr++;
 8030294:	6d82      	ldr	r2, [r0, #88]	; 0x58
 8030296:	3201      	adds	r2, #1
 8030298:	6582      	str	r2, [r0, #88]	; 0x58
    huart->RxXferCount--;
 803029a:	f8b0 205e 	ldrh.w	r2, [r0, #94]	; 0x5e
 803029e:	3a01      	subs	r2, #1
 80302a0:	b292      	uxth	r2, r2
 80302a2:	f8a0 205e 	strh.w	r2, [r0, #94]	; 0x5e
    if (huart->RxXferCount == 0U)
 80302a6:	f8b0 305e 	ldrh.w	r3, [r0, #94]	; 0x5e
 80302aa:	b29b      	uxth	r3, r3
 80302ac:	b933      	cbnz	r3, 80302bc <UART_RxISR_8BIT+0x40>
}
 80302ae:	bc10      	pop	{r4}
 80302b0:	f7ff bf92 	b.w	80301d8 <UART_RxISR_16BIT.part.0>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 80302b4:	6993      	ldr	r3, [r2, #24]
 80302b6:	f043 0308 	orr.w	r3, r3, #8
 80302ba:	6193      	str	r3, [r2, #24]
}
 80302bc:	bc10      	pop	{r4}
 80302be:	4770      	bx	lr

080302c0 <UART_RxISR_8BIT_FIFOEN>:
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_8BIT_FIFOEN(UART_HandleTypeDef *huart)
{
 80302c0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint16_t  uhMask = huart->Mask;
  uint16_t  uhdata;
  uint16_t  nb_rx_data;
  uint16_t  rxdatacount;
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
 80302c4:	6803      	ldr	r3, [r0, #0]
 80302c6:	69dd      	ldr	r5, [r3, #28]
  uint32_t  cr1its   = READ_REG(huart->Instance->CR1);
 80302c8:	f8d3 8000 	ldr.w	r8, [r3]
  uint32_t  cr3its   = READ_REG(huart->Instance->CR3);
 80302cc:	689e      	ldr	r6, [r3, #8]

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 80302ce:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 80302d2:	2a22      	cmp	r2, #34	; 0x22
{
 80302d4:	4604      	mov	r4, r0
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 80302d6:	f040 80a7 	bne.w	8030428 <UART_RxISR_8BIT_FIFOEN+0x168>
  uint16_t  uhMask = huart->Mask;
 80302da:	f8b0 7060 	ldrh.w	r7, [r0, #96]	; 0x60
  {
    nb_rx_data = huart->NbRxDataToProcess;
 80302de:	f8b0 9068 	ldrh.w	r9, [r0, #104]	; 0x68
        /* Disable the UART Parity Error Interrupt and RXFT interrupt*/
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);

        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error)
           and RX FIFO Threshold interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 80302e2:	f8df b154 	ldr.w	fp, [pc, #340]	; 8030438 <UART_RxISR_8BIT_FIFOEN+0x178>
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 80302e6:	f04f 0a00 	mov.w	sl, #0
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 80302ea:	f006 0601 	and.w	r6, r6, #1
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 80302ee:	f1b9 0f00 	cmp.w	r9, #0
 80302f2:	d001      	beq.n	80302f8 <UART_RxISR_8BIT_FIFOEN+0x38>
 80302f4:	06ab      	lsls	r3, r5, #26
 80302f6:	d420      	bmi.n	803033a <UART_RxISR_8BIT_FIFOEN+0x7a>

    /* When remaining number of bytes to receive is less than the RX FIFO
    threshold, next incoming frames are processed as if FIFO mode was
    disabled (i.e. one interrupt per received frame).
    */
    rxdatacount = huart->RxXferCount;
 80302f8:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 80302fc:	b29b      	uxth	r3, r3
    if ((rxdatacount != 0U) && (rxdatacount < huart->NbRxDataToProcess))
 80302fe:	b1d3      	cbz	r3, 8030336 <UART_RxISR_8BIT_FIFOEN+0x76>
 8030300:	f8b4 2068 	ldrh.w	r2, [r4, #104]	; 0x68
 8030304:	429a      	cmp	r2, r3
 8030306:	d916      	bls.n	8030336 <UART_RxISR_8BIT_FIFOEN+0x76>
    {
      /* Disable the UART RXFT interrupt*/
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 8030308:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 803030a:	f102 0308 	add.w	r3, r2, #8
 803030e:	e853 3f00 	ldrex	r3, [r3]
 8030312:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030316:	3208      	adds	r2, #8
 8030318:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 803031c:	6822      	ldr	r2, [r4, #0]
 803031e:	2900      	cmp	r1, #0
 8030320:	d1f2      	bne.n	8030308 <UART_RxISR_8BIT_FIFOEN+0x48>

      /* Update the RxISR function pointer */
      huart->RxISR = UART_RxISR_8BIT;
 8030322:	4b44      	ldr	r3, [pc, #272]	; (8030434 <UART_RxISR_8BIT_FIFOEN+0x174>)
 8030324:	6723      	str	r3, [r4, #112]	; 0x70
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030326:	e852 3f00 	ldrex	r3, [r2]

      /* Enable the UART Data Register Not Empty interrupt */
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
 803032a:	f043 0320 	orr.w	r3, r3, #32
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 803032e:	e842 3100 	strex	r1, r3, [r2]
 8030332:	2900      	cmp	r1, #0
 8030334:	d1f7      	bne.n	8030326 <UART_RxISR_8BIT_FIFOEN+0x66>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 8030336:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 803033a:	6823      	ldr	r3, [r4, #0]
      *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 803033c:	6da2      	ldr	r2, [r4, #88]	; 0x58
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 803033e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
      *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 8030340:	403b      	ands	r3, r7
 8030342:	7013      	strb	r3, [r2, #0]
      huart->pRxBuffPtr++;
 8030344:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8030346:	3301      	adds	r3, #1
 8030348:	65a3      	str	r3, [r4, #88]	; 0x58
      huart->RxXferCount--;
 803034a:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 803034e:	3b01      	subs	r3, #1
 8030350:	b29b      	uxth	r3, r3
 8030352:	f8a4 305e 	strh.w	r3, [r4, #94]	; 0x5e
      isrflags = READ_REG(huart->Instance->ISR);
 8030356:	6823      	ldr	r3, [r4, #0]
 8030358:	69dd      	ldr	r5, [r3, #28]
      if ((isrflags & (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE)) != 0U)
 803035a:	0769      	lsls	r1, r5, #29
 803035c:	d02a      	beq.n	80303b4 <UART_RxISR_8BIT_FIFOEN+0xf4>
        if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 803035e:	07ea      	lsls	r2, r5, #31
 8030360:	d50a      	bpl.n	8030378 <UART_RxISR_8BIT_FIFOEN+0xb8>
 8030362:	f418 7f80 	tst.w	r8, #256	; 0x100
 8030366:	d007      	beq.n	8030378 <UART_RxISR_8BIT_FIFOEN+0xb8>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 8030368:	2201      	movs	r2, #1
 803036a:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_PE;
 803036c:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 8030370:	f042 0201 	orr.w	r2, r2, #1
 8030374:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
        if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8030378:	07a8      	lsls	r0, r5, #30
 803037a:	d508      	bpl.n	803038e <UART_RxISR_8BIT_FIFOEN+0xce>
 803037c:	b13e      	cbz	r6, 803038e <UART_RxISR_8BIT_FIFOEN+0xce>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 803037e:	2202      	movs	r2, #2
 8030380:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_FE;
 8030382:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 8030386:	f042 0204 	orr.w	r2, r2, #4
 803038a:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 803038e:	0769      	lsls	r1, r5, #29
 8030390:	d508      	bpl.n	80303a4 <UART_RxISR_8BIT_FIFOEN+0xe4>
 8030392:	b13e      	cbz	r6, 80303a4 <UART_RxISR_8BIT_FIFOEN+0xe4>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 8030394:	2204      	movs	r2, #4
 8030396:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_NE;
 8030398:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 803039c:	f043 0302 	orr.w	r3, r3, #2
 80303a0:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
        if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 80303a4:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 80303a8:	b123      	cbz	r3, 80303b4 <UART_RxISR_8BIT_FIFOEN+0xf4>
          HAL_UART_ErrorCallback(huart);
 80303aa:	4620      	mov	r0, r4
 80303ac:	f7ff fd6f 	bl	802fe8e <HAL_UART_ErrorCallback>
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 80303b0:	f8c4 a08c 	str.w	sl, [r4, #140]	; 0x8c
      if (huart->RxXferCount == 0U)
 80303b4:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 80303b8:	b29b      	uxth	r3, r3
 80303ba:	2b00      	cmp	r3, #0
 80303bc:	d197      	bne.n	80302ee <UART_RxISR_8BIT_FIFOEN+0x2e>
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 80303be:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80303c0:	e852 3f00 	ldrex	r3, [r2]
 80303c4:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80303c8:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 80303cc:	6823      	ldr	r3, [r4, #0]
 80303ce:	2900      	cmp	r1, #0
 80303d0:	d1f5      	bne.n	80303be <UART_RxISR_8BIT_FIFOEN+0xfe>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80303d2:	f103 0208 	add.w	r2, r3, #8
 80303d6:	e852 2f00 	ldrex	r2, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 80303da:	ea02 020b 	and.w	r2, r2, fp
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80303de:	f103 0008 	add.w	r0, r3, #8
 80303e2:	e840 2100 	strex	r1, r2, [r0]
 80303e6:	2900      	cmp	r1, #0
 80303e8:	d1f3      	bne.n	80303d2 <UART_RxISR_8BIT_FIFOEN+0x112>
        huart->RxState = HAL_UART_STATE_READY;
 80303ea:	2220      	movs	r2, #32
 80303ec:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 80303f0:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
        huart->RxISR = NULL;
 80303f2:	6721      	str	r1, [r4, #112]	; 0x70
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 80303f4:	2a01      	cmp	r2, #1
 80303f6:	d113      	bne.n	8030420 <UART_RxISR_8BIT_FIFOEN+0x160>
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80303f8:	66e1      	str	r1, [r4, #108]	; 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80303fa:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 80303fe:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030402:	e843 2100 	strex	r1, r2, [r3]
 8030406:	2900      	cmp	r1, #0
 8030408:	d1f7      	bne.n	80303fa <UART_RxISR_8BIT_FIFOEN+0x13a>
          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 803040a:	69da      	ldr	r2, [r3, #28]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 803040c:	f8b4 105c 	ldrh.w	r1, [r4, #92]	; 0x5c
          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 8030410:	06d2      	lsls	r2, r2, #27
            __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 8030412:	bf44      	itt	mi
 8030414:	2210      	movmi	r2, #16
 8030416:	621a      	strmi	r2, [r3, #32]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8030418:	4620      	mov	r0, r4
 803041a:	f7ff fd68 	bl	802feee <HAL_UARTEx_RxEventCallback>
 803041e:	e766      	b.n	80302ee <UART_RxISR_8BIT_FIFOEN+0x2e>
          HAL_UART_RxCpltCallback(huart);
 8030420:	4620      	mov	r0, r4
 8030422:	f7fc fb6b 	bl	802cafc <HAL_UART_RxCpltCallback>
 8030426:	e762      	b.n	80302ee <UART_RxISR_8BIT_FIFOEN+0x2e>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 8030428:	699a      	ldr	r2, [r3, #24]
 803042a:	f042 0208 	orr.w	r2, r2, #8
 803042e:	619a      	str	r2, [r3, #24]
}
 8030430:	e781      	b.n	8030336 <UART_RxISR_8BIT_FIFOEN+0x76>
 8030432:	bf00      	nop
 8030434:	0803027d 	.word	0x0803027d
 8030438:	effffffe 	.word	0xeffffffe

0803043c <UART_RxISR_16BIT_FIFOEN>:
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_16BIT_FIFOEN(UART_HandleTypeDef *huart)
{
 803043c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint16_t *tmp;
  uint16_t  uhMask = huart->Mask;
  uint16_t  uhdata;
  uint16_t  nb_rx_data;
  uint16_t  rxdatacount;
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
 8030440:	6803      	ldr	r3, [r0, #0]
 8030442:	69dd      	ldr	r5, [r3, #28]
  uint32_t  cr1its   = READ_REG(huart->Instance->CR1);
 8030444:	f8d3 8000 	ldr.w	r8, [r3]
  uint32_t  cr3its   = READ_REG(huart->Instance->CR3);
 8030448:	689e      	ldr	r6, [r3, #8]

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 803044a:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 803044e:	2a22      	cmp	r2, #34	; 0x22
{
 8030450:	4604      	mov	r4, r0
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8030452:	f040 80a5 	bne.w	80305a0 <UART_RxISR_16BIT_FIFOEN+0x164>
  uint16_t  uhMask = huart->Mask;
 8030456:	f8b0 7060 	ldrh.w	r7, [r0, #96]	; 0x60
  {
    nb_rx_data = huart->NbRxDataToProcess;
 803045a:	f8b0 9068 	ldrh.w	r9, [r0, #104]	; 0x68
        /* Disable the UART Parity Error Interrupt and RXFT interrupt*/
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);

        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error)
           and RX FIFO Threshold interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 803045e:	f8df b150 	ldr.w	fp, [pc, #336]	; 80305b0 <UART_RxISR_16BIT_FIFOEN+0x174>
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 8030462:	f04f 0a00 	mov.w	sl, #0
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8030466:	f006 0601 	and.w	r6, r6, #1
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 803046a:	f1b9 0f00 	cmp.w	r9, #0
 803046e:	d001      	beq.n	8030474 <UART_RxISR_16BIT_FIFOEN+0x38>
 8030470:	06ab      	lsls	r3, r5, #26
 8030472:	d420      	bmi.n	80304b6 <UART_RxISR_16BIT_FIFOEN+0x7a>

    /* When remaining number of bytes to receive is less than the RX FIFO
    threshold, next incoming frames are processed as if FIFO mode was
    disabled (i.e. one interrupt per received frame).
    */
    rxdatacount = huart->RxXferCount;
 8030474:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 8030478:	b29b      	uxth	r3, r3
    if ((rxdatacount != 0U) && (rxdatacount < huart->NbRxDataToProcess))
 803047a:	b1d3      	cbz	r3, 80304b2 <UART_RxISR_16BIT_FIFOEN+0x76>
 803047c:	f8b4 2068 	ldrh.w	r2, [r4, #104]	; 0x68
 8030480:	429a      	cmp	r2, r3
 8030482:	d916      	bls.n	80304b2 <UART_RxISR_16BIT_FIFOEN+0x76>
    {
      /* Disable the UART RXFT interrupt*/
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 8030484:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030486:	f102 0308 	add.w	r3, r2, #8
 803048a:	e853 3f00 	ldrex	r3, [r3]
 803048e:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030492:	3208      	adds	r2, #8
 8030494:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 8030498:	6822      	ldr	r2, [r4, #0]
 803049a:	2900      	cmp	r1, #0
 803049c:	d1f2      	bne.n	8030484 <UART_RxISR_16BIT_FIFOEN+0x48>

      /* Update the RxISR function pointer */
      huart->RxISR = UART_RxISR_16BIT;
 803049e:	4b43      	ldr	r3, [pc, #268]	; (80305ac <UART_RxISR_16BIT_FIFOEN+0x170>)
 80304a0:	6723      	str	r3, [r4, #112]	; 0x70
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80304a2:	e852 3f00 	ldrex	r3, [r2]

      /* Enable the UART Data Register Not Empty interrupt */
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
 80304a6:	f043 0320 	orr.w	r3, r3, #32
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80304aa:	e842 3100 	strex	r1, r3, [r2]
 80304ae:	2900      	cmp	r1, #0
 80304b0:	d1f7      	bne.n	80304a2 <UART_RxISR_16BIT_FIFOEN+0x66>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 80304b2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 80304b6:	6823      	ldr	r3, [r4, #0]
      *tmp = (uint16_t)(uhdata & uhMask);
 80304b8:	6da2      	ldr	r2, [r4, #88]	; 0x58
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 80304ba:	6a59      	ldr	r1, [r3, #36]	; 0x24
      *tmp = (uint16_t)(uhdata & uhMask);
 80304bc:	4039      	ands	r1, r7
 80304be:	f822 1b02 	strh.w	r1, [r2], #2
      huart->pRxBuffPtr += 2U;
 80304c2:	65a2      	str	r2, [r4, #88]	; 0x58
      huart->RxXferCount--;
 80304c4:	f8b4 205e 	ldrh.w	r2, [r4, #94]	; 0x5e
 80304c8:	3a01      	subs	r2, #1
 80304ca:	b292      	uxth	r2, r2
 80304cc:	f8a4 205e 	strh.w	r2, [r4, #94]	; 0x5e
      isrflags = READ_REG(huart->Instance->ISR);
 80304d0:	69dd      	ldr	r5, [r3, #28]
      if ((isrflags & (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE)) != 0U)
 80304d2:	0769      	lsls	r1, r5, #29
 80304d4:	d02a      	beq.n	803052c <UART_RxISR_16BIT_FIFOEN+0xf0>
        if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 80304d6:	07ea      	lsls	r2, r5, #31
 80304d8:	d50a      	bpl.n	80304f0 <UART_RxISR_16BIT_FIFOEN+0xb4>
 80304da:	f418 7f80 	tst.w	r8, #256	; 0x100
 80304de:	d007      	beq.n	80304f0 <UART_RxISR_16BIT_FIFOEN+0xb4>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 80304e0:	2201      	movs	r2, #1
 80304e2:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_PE;
 80304e4:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 80304e8:	f042 0201 	orr.w	r2, r2, #1
 80304ec:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
        if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 80304f0:	07a8      	lsls	r0, r5, #30
 80304f2:	d508      	bpl.n	8030506 <UART_RxISR_16BIT_FIFOEN+0xca>
 80304f4:	b13e      	cbz	r6, 8030506 <UART_RxISR_16BIT_FIFOEN+0xca>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 80304f6:	2202      	movs	r2, #2
 80304f8:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_FE;
 80304fa:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 80304fe:	f042 0204 	orr.w	r2, r2, #4
 8030502:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8030506:	0769      	lsls	r1, r5, #29
 8030508:	d508      	bpl.n	803051c <UART_RxISR_16BIT_FIFOEN+0xe0>
 803050a:	b13e      	cbz	r6, 803051c <UART_RxISR_16BIT_FIFOEN+0xe0>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 803050c:	2204      	movs	r2, #4
 803050e:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_NE;
 8030510:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 8030514:	f043 0302 	orr.w	r3, r3, #2
 8030518:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
        if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 803051c:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 8030520:	b123      	cbz	r3, 803052c <UART_RxISR_16BIT_FIFOEN+0xf0>
          HAL_UART_ErrorCallback(huart);
 8030522:	4620      	mov	r0, r4
 8030524:	f7ff fcb3 	bl	802fe8e <HAL_UART_ErrorCallback>
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 8030528:	f8c4 a08c 	str.w	sl, [r4, #140]	; 0x8c
      if (huart->RxXferCount == 0U)
 803052c:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 8030530:	b29b      	uxth	r3, r3
 8030532:	2b00      	cmp	r3, #0
 8030534:	d199      	bne.n	803046a <UART_RxISR_16BIT_FIFOEN+0x2e>
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8030536:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030538:	e852 3f00 	ldrex	r3, [r2]
 803053c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030540:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 8030544:	6823      	ldr	r3, [r4, #0]
 8030546:	2900      	cmp	r1, #0
 8030548:	d1f5      	bne.n	8030536 <UART_RxISR_16BIT_FIFOEN+0xfa>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 803054a:	f103 0208 	add.w	r2, r3, #8
 803054e:	e852 2f00 	ldrex	r2, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 8030552:	ea02 020b 	and.w	r2, r2, fp
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030556:	f103 0008 	add.w	r0, r3, #8
 803055a:	e840 2100 	strex	r1, r2, [r0]
 803055e:	2900      	cmp	r1, #0
 8030560:	d1f3      	bne.n	803054a <UART_RxISR_16BIT_FIFOEN+0x10e>
        huart->RxState = HAL_UART_STATE_READY;
 8030562:	2220      	movs	r2, #32
 8030564:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8030568:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
        huart->RxISR = NULL;
 803056a:	6721      	str	r1, [r4, #112]	; 0x70
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 803056c:	2a01      	cmp	r2, #1
 803056e:	d113      	bne.n	8030598 <UART_RxISR_16BIT_FIFOEN+0x15c>
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8030570:	66e1      	str	r1, [r4, #108]	; 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030572:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8030576:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 803057a:	e843 2100 	strex	r1, r2, [r3]
 803057e:	2900      	cmp	r1, #0
 8030580:	d1f7      	bne.n	8030572 <UART_RxISR_16BIT_FIFOEN+0x136>
          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 8030582:	69da      	ldr	r2, [r3, #28]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8030584:	f8b4 105c 	ldrh.w	r1, [r4, #92]	; 0x5c
          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 8030588:	06d2      	lsls	r2, r2, #27
            __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 803058a:	bf44      	itt	mi
 803058c:	2210      	movmi	r2, #16
 803058e:	621a      	strmi	r2, [r3, #32]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8030590:	4620      	mov	r0, r4
 8030592:	f7ff fcac 	bl	802feee <HAL_UARTEx_RxEventCallback>
 8030596:	e768      	b.n	803046a <UART_RxISR_16BIT_FIFOEN+0x2e>
          HAL_UART_RxCpltCallback(huart);
 8030598:	4620      	mov	r0, r4
 803059a:	f7fc faaf 	bl	802cafc <HAL_UART_RxCpltCallback>
 803059e:	e764      	b.n	803046a <UART_RxISR_16BIT_FIFOEN+0x2e>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 80305a0:	699a      	ldr	r2, [r3, #24]
 80305a2:	f042 0208 	orr.w	r2, r2, #8
 80305a6:	619a      	str	r2, [r3, #24]
}
 80305a8:	e783      	b.n	80304b2 <UART_RxISR_16BIT_FIFOEN+0x76>
 80305aa:	bf00      	nop
 80305ac:	08030241 	.word	0x08030241
 80305b0:	effffffe 	.word	0xeffffffe

080305b4 <UART_SetConfig>:
{
 80305b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80305b6:	4604      	mov	r4, r0
  if (UART_INSTANCE_LOWPOWER(huart))
 80305b8:	6803      	ldr	r3, [r0, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80305ba:	6921      	ldr	r1, [r4, #16]
 80305bc:	68a2      	ldr	r2, [r4, #8]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80305be:	681d      	ldr	r5, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80305c0:	69c0      	ldr	r0, [r0, #28]
 80305c2:	430a      	orrs	r2, r1
 80305c4:	6961      	ldr	r1, [r4, #20]
 80305c6:	430a      	orrs	r2, r1
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80305c8:	497f      	ldr	r1, [pc, #508]	; (80307c8 <UART_SetConfig+0x214>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80305ca:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80305cc:	4029      	ands	r1, r5
 80305ce:	430a      	orrs	r2, r1
 80305d0:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80305d2:	685a      	ldr	r2, [r3, #4]
 80305d4:	68e1      	ldr	r1, [r4, #12]
 80305d6:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 80305da:	430a      	orrs	r2, r1
 80305dc:	605a      	str	r2, [r3, #4]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 80305de:	4a7b      	ldr	r2, [pc, #492]	; (80307cc <UART_SetConfig+0x218>)
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 80305e0:	69a1      	ldr	r1, [r4, #24]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 80305e2:	4293      	cmp	r3, r2
    tmpreg |= huart->Init.OneBitSampling;
 80305e4:	bf1c      	itt	ne
 80305e6:	6a22      	ldrne	r2, [r4, #32]
 80305e8:	4311      	orrne	r1, r2
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 80305ea:	689a      	ldr	r2, [r3, #8]
 80305ec:	f022 426e 	bic.w	r2, r2, #3992977408	; 0xee000000
 80305f0:	f422 6230 	bic.w	r2, r2, #2816	; 0xb00
 80305f4:	430a      	orrs	r2, r1
 80305f6:	609a      	str	r2, [r3, #8]
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 80305f8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80305fa:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80305fc:	f022 020f 	bic.w	r2, r2, #15
 8030600:	430a      	orrs	r2, r1
 8030602:	62da      	str	r2, [r3, #44]	; 0x2c
  UART_GETCLOCKSOURCE(huart, clocksource);
 8030604:	4a72      	ldr	r2, [pc, #456]	; (80307d0 <UART_SetConfig+0x21c>)
 8030606:	4293      	cmp	r3, r2
 8030608:	d11c      	bne.n	8030644 <UART_SetConfig+0x90>
  return (uint32_t)(READ_BIT(RCC->CCIPR, USARTx) | (USARTx << 16));
 803060a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 803060e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8030612:	f003 0303 	and.w	r3, r3, #3
 8030616:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
 803061a:	f5a3 3340 	sub.w	r3, r3, #196608	; 0x30000
 803061e:	3b01      	subs	r3, #1
 8030620:	2b02      	cmp	r3, #2
 8030622:	f200 80cb 	bhi.w	80307bc <UART_SetConfig+0x208>
 8030626:	4a6b      	ldr	r2, [pc, #428]	; (80307d4 <UART_SetConfig+0x220>)
 8030628:	5c9b      	ldrb	r3, [r3, r2]
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 803062a:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 803062e:	f040 808c 	bne.w	803074a <UART_SetConfig+0x196>
    switch (clocksource)
 8030632:	2b08      	cmp	r3, #8
 8030634:	d824      	bhi.n	8030680 <UART_SetConfig+0xcc>
 8030636:	e8df f003 	tbb	[pc, r3]
 803063a:	c462      	.short	0xc462
 803063c:	23832386 	.word	0x23832386
 8030640:	2323      	.short	0x2323
 8030642:	66          	.byte	0x66
 8030643:	00          	.byte	0x00
  UART_GETCLOCKSOURCE(huart, clocksource);
 8030644:	4a64      	ldr	r2, [pc, #400]	; (80307d8 <UART_SetConfig+0x224>)
 8030646:	4293      	cmp	r3, r2
 8030648:	d109      	bne.n	803065e <UART_SetConfig+0xaa>
 803064a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 803064e:	4a63      	ldr	r2, [pc, #396]	; (80307dc <UART_SetConfig+0x228>)
 8030650:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8030654:	f003 030c 	and.w	r3, r3, #12
 8030658:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
 803065c:	e7e4      	b.n	8030628 <UART_SetConfig+0x74>
 803065e:	4a5b      	ldr	r2, [pc, #364]	; (80307cc <UART_SetConfig+0x218>)
 8030660:	4293      	cmp	r3, r2
 8030662:	d10d      	bne.n	8030680 <UART_SetConfig+0xcc>
  return (uint32_t)(READ_BIT(RCC->CCIPR, LPUARTx));
 8030664:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8030668:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 803066c:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
 8030670:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8030674:	d01a      	beq.n	80306ac <UART_SetConfig+0xf8>
 8030676:	d805      	bhi.n	8030684 <UART_SetConfig+0xd0>
 8030678:	b153      	cbz	r3, 8030690 <UART_SetConfig+0xdc>
 803067a:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 803067e:	d012      	beq.n	80306a6 <UART_SetConfig+0xf2>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8030680:	2001      	movs	r0, #1
 8030682:	e009      	b.n	8030698 <UART_SetConfig+0xe4>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8030684:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 8030688:	d1fa      	bne.n	8030680 <UART_SetConfig+0xcc>
        pclk = (uint32_t) LSE_VALUE;
 803068a:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 803068e:	e00e      	b.n	80306ae <UART_SetConfig+0xfa>
        pclk = HAL_RCC_GetPCLK1Freq();
 8030690:	f7fe fd40 	bl	802f114 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 8030694:	b958      	cbnz	r0, 80306ae <UART_SetConfig+0xfa>
 8030696:	2000      	movs	r0, #0
  huart->NbRxDataToProcess = 1;
 8030698:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 803069c:	66a3      	str	r3, [r4, #104]	; 0x68
  huart->RxISR = NULL;
 803069e:	2300      	movs	r3, #0
  huart->TxISR = NULL;
 80306a0:	e9c4 331c 	strd	r3, r3, [r4, #112]	; 0x70
}
 80306a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        pclk = HAL_RCC_GetSysClockFreq();
 80306a6:	f7fe f91f 	bl	802e8e8 <HAL_RCC_GetSysClockFreq>
        break;
 80306aa:	e7f3      	b.n	8030694 <UART_SetConfig+0xe0>
  UART_GETCLOCKSOURCE(huart, clocksource);
 80306ac:	484c      	ldr	r0, [pc, #304]	; (80307e0 <UART_SetConfig+0x22c>)
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 80306ae:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80306b0:	4b48      	ldr	r3, [pc, #288]	; (80307d4 <UART_SetConfig+0x220>)
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 80306b2:	6865      	ldr	r5, [r4, #4]
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 80306b4:	eb03 0342 	add.w	r3, r3, r2, lsl #1
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 80306b8:	eb05 0145 	add.w	r1, r5, r5, lsl #1
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 80306bc:	8a1a      	ldrh	r2, [r3, #16]
 80306be:	fbb0 f3f2 	udiv	r3, r0, r2
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 80306c2:	4299      	cmp	r1, r3
 80306c4:	d8dc      	bhi.n	8030680 <UART_SetConfig+0xcc>
 80306c6:	ebb3 3f05 	cmp.w	r3, r5, lsl #12
 80306ca:	d8d9      	bhi.n	8030680 <UART_SetConfig+0xcc>
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 80306cc:	2300      	movs	r3, #0
 80306ce:	2100      	movs	r1, #0
 80306d0:	f7fb fa38 	bl	802bb44 <__aeabi_uldivmod>
 80306d4:	020f      	lsls	r7, r1, #8
 80306d6:	ea47 6710 	orr.w	r7, r7, r0, lsr #24
 80306da:	0206      	lsls	r6, r0, #8
 80306dc:	0868      	lsrs	r0, r5, #1
 80306de:	1830      	adds	r0, r6, r0
 80306e0:	462a      	mov	r2, r5
 80306e2:	f04f 0300 	mov.w	r3, #0
 80306e6:	f147 0100 	adc.w	r1, r7, #0
 80306ea:	f7fb fa2b 	bl	802bb44 <__aeabi_uldivmod>
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 80306ee:	4b3d      	ldr	r3, [pc, #244]	; (80307e4 <UART_SetConfig+0x230>)
 80306f0:	f5a0 7240 	sub.w	r2, r0, #768	; 0x300
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 80306f4:	429a      	cmp	r2, r3
 80306f6:	d8c3      	bhi.n	8030680 <UART_SetConfig+0xcc>
        huart->Instance->BRR = usartdiv;
 80306f8:	6823      	ldr	r3, [r4, #0]
 80306fa:	60d8      	str	r0, [r3, #12]
 80306fc:	e7cb      	b.n	8030696 <UART_SetConfig+0xe2>
        pclk = HAL_RCC_GetPCLK1Freq();
 80306fe:	f7fe fd09 	bl	802f114 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 8030702:	2800      	cmp	r0, #0
 8030704:	d0c7      	beq.n	8030696 <UART_SetConfig+0xe2>
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8030706:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8030708:	4b32      	ldr	r3, [pc, #200]	; (80307d4 <UART_SetConfig+0x220>)
 803070a:	6862      	ldr	r2, [r4, #4]
 803070c:	eb03 0341 	add.w	r3, r3, r1, lsl #1
 8030710:	8a1b      	ldrh	r3, [r3, #16]
 8030712:	fbb0 f3f3 	udiv	r3, r0, r3
 8030716:	0850      	lsrs	r0, r2, #1
 8030718:	eb00 0043 	add.w	r0, r0, r3, lsl #1
 803071c:	fbb0 f0f2 	udiv	r0, r0, r2
 8030720:	b283      	uxth	r3, r0
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8030722:	f1a3 0110 	sub.w	r1, r3, #16
 8030726:	f64f 72ef 	movw	r2, #65519	; 0xffef
 803072a:	4291      	cmp	r1, r2
 803072c:	d8a8      	bhi.n	8030680 <UART_SetConfig+0xcc>
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 803072e:	f020 000f 	bic.w	r0, r0, #15
        huart->Instance->BRR = brrtemp;
 8030732:	6822      	ldr	r2, [r4, #0]
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 8030734:	b280      	uxth	r0, r0
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 8030736:	f3c3 0342 	ubfx	r3, r3, #1, #3
        huart->Instance->BRR = brrtemp;
 803073a:	4318      	orrs	r0, r3
 803073c:	60d0      	str	r0, [r2, #12]
 803073e:	e7aa      	b.n	8030696 <UART_SetConfig+0xe2>
        pclk = HAL_RCC_GetSysClockFreq();
 8030740:	f7fe f8d2 	bl	802e8e8 <HAL_RCC_GetSysClockFreq>
        break;
 8030744:	e7dd      	b.n	8030702 <UART_SetConfig+0x14e>
        pclk = (uint32_t) HSI_VALUE;
 8030746:	4826      	ldr	r0, [pc, #152]	; (80307e0 <UART_SetConfig+0x22c>)
 8030748:	e7dd      	b.n	8030706 <UART_SetConfig+0x152>
    switch (clocksource)
 803074a:	2b08      	cmp	r3, #8
 803074c:	d898      	bhi.n	8030680 <UART_SetConfig+0xcc>
 803074e:	a201      	add	r2, pc, #4	; (adr r2, 8030754 <UART_SetConfig+0x1a0>)
 8030750:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8030754:	080307a1 	.word	0x080307a1
 8030758:	080307ad 	.word	0x080307ad
 803075c:	080307b9 	.word	0x080307b9
 8030760:	08030681 	.word	0x08030681
 8030764:	080307b3 	.word	0x080307b3
 8030768:	08030681 	.word	0x08030681
 803076c:	08030681 	.word	0x08030681
 8030770:	08030681 	.word	0x08030681
 8030774:	08030779 	.word	0x08030779
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8030778:	f44f 4000 	mov.w	r0, #32768	; 0x8000
      usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 803077c:	6a61      	ldr	r1, [r4, #36]	; 0x24
 803077e:	4b15      	ldr	r3, [pc, #84]	; (80307d4 <UART_SetConfig+0x220>)
 8030780:	6862      	ldr	r2, [r4, #4]
 8030782:	eb03 0341 	add.w	r3, r3, r1, lsl #1
 8030786:	8a1b      	ldrh	r3, [r3, #16]
 8030788:	fbb0 f0f3 	udiv	r0, r0, r3
 803078c:	eb00 0052 	add.w	r0, r0, r2, lsr #1
 8030790:	fbb0 f0f2 	udiv	r0, r0, r2
 8030794:	b280      	uxth	r0, r0
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8030796:	f1a0 0210 	sub.w	r2, r0, #16
 803079a:	f64f 73ef 	movw	r3, #65519	; 0xffef
 803079e:	e7a9      	b.n	80306f4 <UART_SetConfig+0x140>
        pclk = HAL_RCC_GetPCLK1Freq();
 80307a0:	f7fe fcb8 	bl	802f114 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 80307a4:	2800      	cmp	r0, #0
 80307a6:	f43f af76 	beq.w	8030696 <UART_SetConfig+0xe2>
 80307aa:	e7e7      	b.n	803077c <UART_SetConfig+0x1c8>
        pclk = HAL_RCC_GetPCLK2Freq();
 80307ac:	f7fe fcc2 	bl	802f134 <HAL_RCC_GetPCLK2Freq>
        break;
 80307b0:	e7f8      	b.n	80307a4 <UART_SetConfig+0x1f0>
        pclk = HAL_RCC_GetSysClockFreq();
 80307b2:	f7fe f899 	bl	802e8e8 <HAL_RCC_GetSysClockFreq>
        break;
 80307b6:	e7f5      	b.n	80307a4 <UART_SetConfig+0x1f0>
        pclk = (uint32_t) HSI_VALUE;
 80307b8:	4809      	ldr	r0, [pc, #36]	; (80307e0 <UART_SetConfig+0x22c>)
 80307ba:	e7df      	b.n	803077c <UART_SetConfig+0x1c8>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80307bc:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 80307c0:	d1f4      	bne.n	80307ac <UART_SetConfig+0x1f8>
        pclk = HAL_RCC_GetPCLK2Freq();
 80307c2:	f7fe fcb7 	bl	802f134 <HAL_RCC_GetPCLK2Freq>
        break;
 80307c6:	e79c      	b.n	8030702 <UART_SetConfig+0x14e>
 80307c8:	cfff69f3 	.word	0xcfff69f3
 80307cc:	40008000 	.word	0x40008000
 80307d0:	40013800 	.word	0x40013800
 80307d4:	0803ba18 	.word	0x0803ba18
 80307d8:	40004400 	.word	0x40004400
 80307dc:	07f7ba1b 	.word	0x07f7ba1b
 80307e0:	00f42400 	.word	0x00f42400
 80307e4:	000ffcff 	.word	0x000ffcff

080307e8 <UART_AdvFeatureConfig>:
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 80307e8:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80307ea:	07da      	lsls	r2, r3, #31
{
 80307ec:	b510      	push	{r4, lr}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 80307ee:	d506      	bpl.n	80307fe <UART_AdvFeatureConfig+0x16>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 80307f0:	6801      	ldr	r1, [r0, #0]
 80307f2:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 80307f4:	684a      	ldr	r2, [r1, #4]
 80307f6:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 80307fa:	4322      	orrs	r2, r4
 80307fc:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 80307fe:	079c      	lsls	r4, r3, #30
 8030800:	d506      	bpl.n	8030810 <UART_AdvFeatureConfig+0x28>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 8030802:	6801      	ldr	r1, [r0, #0]
 8030804:	6b04      	ldr	r4, [r0, #48]	; 0x30
 8030806:	684a      	ldr	r2, [r1, #4]
 8030808:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 803080c:	4322      	orrs	r2, r4
 803080e:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 8030810:	0759      	lsls	r1, r3, #29
 8030812:	d506      	bpl.n	8030822 <UART_AdvFeatureConfig+0x3a>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 8030814:	6801      	ldr	r1, [r0, #0]
 8030816:	6b44      	ldr	r4, [r0, #52]	; 0x34
 8030818:	684a      	ldr	r2, [r1, #4]
 803081a:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 803081e:	4322      	orrs	r2, r4
 8030820:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 8030822:	071a      	lsls	r2, r3, #28
 8030824:	d506      	bpl.n	8030834 <UART_AdvFeatureConfig+0x4c>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 8030826:	6801      	ldr	r1, [r0, #0]
 8030828:	6b84      	ldr	r4, [r0, #56]	; 0x38
 803082a:	684a      	ldr	r2, [r1, #4]
 803082c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8030830:	4322      	orrs	r2, r4
 8030832:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 8030834:	06dc      	lsls	r4, r3, #27
 8030836:	d506      	bpl.n	8030846 <UART_AdvFeatureConfig+0x5e>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 8030838:	6801      	ldr	r1, [r0, #0]
 803083a:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 803083c:	688a      	ldr	r2, [r1, #8]
 803083e:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8030842:	4322      	orrs	r2, r4
 8030844:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 8030846:	0699      	lsls	r1, r3, #26
 8030848:	d506      	bpl.n	8030858 <UART_AdvFeatureConfig+0x70>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 803084a:	6801      	ldr	r1, [r0, #0]
 803084c:	6c04      	ldr	r4, [r0, #64]	; 0x40
 803084e:	688a      	ldr	r2, [r1, #8]
 8030850:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8030854:	4322      	orrs	r2, r4
 8030856:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 8030858:	065a      	lsls	r2, r3, #25
 803085a:	d50f      	bpl.n	803087c <UART_AdvFeatureConfig+0x94>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 803085c:	6801      	ldr	r1, [r0, #0]
 803085e:	6c44      	ldr	r4, [r0, #68]	; 0x44
 8030860:	684a      	ldr	r2, [r1, #4]
 8030862:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 8030866:	4322      	orrs	r2, r4
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8030868:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 803086c:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 803086e:	d105      	bne.n	803087c <UART_AdvFeatureConfig+0x94>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 8030870:	684a      	ldr	r2, [r1, #4]
 8030872:	6c84      	ldr	r4, [r0, #72]	; 0x48
 8030874:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
 8030878:	4322      	orrs	r2, r4
 803087a:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 803087c:	061b      	lsls	r3, r3, #24
 803087e:	d506      	bpl.n	803088e <UART_AdvFeatureConfig+0xa6>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 8030880:	6802      	ldr	r2, [r0, #0]
 8030882:	6cc1      	ldr	r1, [r0, #76]	; 0x4c
 8030884:	6853      	ldr	r3, [r2, #4]
 8030886:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 803088a:	430b      	orrs	r3, r1
 803088c:	6053      	str	r3, [r2, #4]
}
 803088e:	bd10      	pop	{r4, pc}

08030890 <UART_WaitOnFlagUntilTimeout>:
{
 8030890:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8030894:	f8dd 8018 	ldr.w	r8, [sp, #24]
 8030898:	4604      	mov	r4, r0
 803089a:	460e      	mov	r6, r1
 803089c:	4615      	mov	r5, r2
 803089e:	461f      	mov	r7, r3
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 80308a0:	6822      	ldr	r2, [r4, #0]
 80308a2:	69d3      	ldr	r3, [r2, #28]
 80308a4:	ea36 0303 	bics.w	r3, r6, r3
 80308a8:	bf0c      	ite	eq
 80308aa:	2301      	moveq	r3, #1
 80308ac:	2300      	movne	r3, #0
 80308ae:	42ab      	cmp	r3, r5
 80308b0:	d001      	beq.n	80308b6 <UART_WaitOnFlagUntilTimeout+0x26>
  return HAL_OK;
 80308b2:	2000      	movs	r0, #0
 80308b4:	e027      	b.n	8030906 <UART_WaitOnFlagUntilTimeout+0x76>
    if (Timeout != HAL_MAX_DELAY)
 80308b6:	f1b8 3fff 	cmp.w	r8, #4294967295
 80308ba:	d0f2      	beq.n	80308a2 <UART_WaitOnFlagUntilTimeout+0x12>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80308bc:	f7fb fec2 	bl	802c644 <HAL_GetTick>
 80308c0:	1bc0      	subs	r0, r0, r7
 80308c2:	4540      	cmp	r0, r8
 80308c4:	6820      	ldr	r0, [r4, #0]
 80308c6:	d802      	bhi.n	80308ce <UART_WaitOnFlagUntilTimeout+0x3e>
 80308c8:	f1b8 0f00 	cmp.w	r8, #0
 80308cc:	d11d      	bne.n	803090a <UART_WaitOnFlagUntilTimeout+0x7a>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80308ce:	e850 3f00 	ldrex	r3, [r0]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |
 80308d2:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80308d6:	e840 3200 	strex	r2, r3, [r0]
 80308da:	2a00      	cmp	r2, #0
 80308dc:	d1f7      	bne.n	80308ce <UART_WaitOnFlagUntilTimeout+0x3e>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80308de:	f100 0308 	add.w	r3, r0, #8
 80308e2:	e853 3f00 	ldrex	r3, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80308e6:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80308ea:	f100 0108 	add.w	r1, r0, #8
 80308ee:	e841 3200 	strex	r2, r3, [r1]
 80308f2:	2a00      	cmp	r2, #0
 80308f4:	d1f3      	bne.n	80308de <UART_WaitOnFlagUntilTimeout+0x4e>
        huart->gState = HAL_UART_STATE_READY;
 80308f6:	2320      	movs	r3, #32
 80308f8:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
        huart->RxState = HAL_UART_STATE_READY;
 80308fc:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
          __HAL_UNLOCK(huart);
 8030900:	f884 2080 	strb.w	r2, [r4, #128]	; 0x80
          return HAL_TIMEOUT;
 8030904:	2003      	movs	r0, #3
}
 8030906:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 803090a:	6803      	ldr	r3, [r0, #0]
 803090c:	075a      	lsls	r2, r3, #29
 803090e:	d5c7      	bpl.n	80308a0 <UART_WaitOnFlagUntilTimeout+0x10>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 8030910:	69c3      	ldr	r3, [r0, #28]
 8030912:	051b      	lsls	r3, r3, #20
 8030914:	d5c4      	bpl.n	80308a0 <UART_WaitOnFlagUntilTimeout+0x10>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 8030916:	f44f 6300 	mov.w	r3, #2048	; 0x800
 803091a:	6203      	str	r3, [r0, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 803091c:	e850 3f00 	ldrex	r3, [r0]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |
 8030920:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030924:	e840 3200 	strex	r2, r3, [r0]
 8030928:	2a00      	cmp	r2, #0
 803092a:	d1f7      	bne.n	803091c <UART_WaitOnFlagUntilTimeout+0x8c>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 803092c:	f100 0308 	add.w	r3, r0, #8
 8030930:	e853 3f00 	ldrex	r3, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8030934:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030938:	f100 0108 	add.w	r1, r0, #8
 803093c:	e841 3200 	strex	r2, r3, [r1]
 8030940:	2a00      	cmp	r2, #0
 8030942:	d1f3      	bne.n	803092c <UART_WaitOnFlagUntilTimeout+0x9c>
          huart->gState = HAL_UART_STATE_READY;
 8030944:	2320      	movs	r3, #32
 8030946:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
          huart->RxState = HAL_UART_STATE_READY;
 803094a:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 803094e:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
 8030952:	e7d5      	b.n	8030900 <UART_WaitOnFlagUntilTimeout+0x70>

08030954 <UART_CheckIdleState>:
{
 8030954:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8030956:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8030958:	2600      	movs	r6, #0
 803095a:	f8c0 608c 	str.w	r6, [r0, #140]	; 0x8c
  tickstart = HAL_GetTick();
 803095e:	f7fb fe71 	bl	802c644 <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8030962:	6823      	ldr	r3, [r4, #0]
 8030964:	681b      	ldr	r3, [r3, #0]
 8030966:	071a      	lsls	r2, r3, #28
  tickstart = HAL_GetTick();
 8030968:	4605      	mov	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 803096a:	d418      	bmi.n	803099e <UART_CheckIdleState+0x4a>
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 803096c:	6823      	ldr	r3, [r4, #0]
 803096e:	681b      	ldr	r3, [r3, #0]
 8030970:	075b      	lsls	r3, r3, #29
 8030972:	d50a      	bpl.n	803098a <UART_CheckIdleState+0x36>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8030974:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 8030978:	9300      	str	r3, [sp, #0]
 803097a:	2200      	movs	r2, #0
 803097c:	462b      	mov	r3, r5
 803097e:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 8030982:	4620      	mov	r0, r4
 8030984:	f7ff ff84 	bl	8030890 <UART_WaitOnFlagUntilTimeout>
 8030988:	b9a8      	cbnz	r0, 80309b6 <UART_CheckIdleState+0x62>
  huart->gState = HAL_UART_STATE_READY;
 803098a:	2320      	movs	r3, #32
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 803098c:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
 803098e:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  __HAL_UNLOCK(huart);
 8030992:	f884 0080 	strb.w	r0, [r4, #128]	; 0x80
  huart->RxState = HAL_UART_STATE_READY;
 8030996:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 803099a:	66e0      	str	r0, [r4, #108]	; 0x6c
  return HAL_OK;
 803099c:	e00c      	b.n	80309b8 <UART_CheckIdleState+0x64>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 803099e:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 80309a2:	9300      	str	r3, [sp, #0]
 80309a4:	4632      	mov	r2, r6
 80309a6:	4603      	mov	r3, r0
 80309a8:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 80309ac:	4620      	mov	r0, r4
 80309ae:	f7ff ff6f 	bl	8030890 <UART_WaitOnFlagUntilTimeout>
 80309b2:	2800      	cmp	r0, #0
 80309b4:	d0da      	beq.n	803096c <UART_CheckIdleState+0x18>
      return HAL_TIMEOUT;
 80309b6:	2003      	movs	r0, #3
}
 80309b8:	b002      	add	sp, #8
 80309ba:	bd70      	pop	{r4, r5, r6, pc}

080309bc <HAL_UART_Init>:
{
 80309bc:	b510      	push	{r4, lr}
  if (huart == NULL)
 80309be:	4604      	mov	r4, r0
 80309c0:	b350      	cbz	r0, 8030a18 <HAL_UART_Init+0x5c>
  if (huart->gState == HAL_UART_STATE_RESET)
 80309c2:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
 80309c6:	b91b      	cbnz	r3, 80309d0 <HAL_UART_Init+0x14>
    huart->Lock = HAL_UNLOCKED;
 80309c8:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
    HAL_UART_MspInit(huart);
 80309cc:	f7fb ff94 	bl	802c8f8 <HAL_UART_MspInit>
  __HAL_UART_DISABLE(huart);
 80309d0:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 80309d2:	2324      	movs	r3, #36	; 0x24
 80309d4:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  __HAL_UART_DISABLE(huart);
 80309d8:	6813      	ldr	r3, [r2, #0]
 80309da:	f023 0301 	bic.w	r3, r3, #1
 80309de:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 80309e0:	4620      	mov	r0, r4
 80309e2:	f7ff fde7 	bl	80305b4 <UART_SetConfig>
 80309e6:	2801      	cmp	r0, #1
 80309e8:	d016      	beq.n	8030a18 <HAL_UART_Init+0x5c>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 80309ea:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80309ec:	b113      	cbz	r3, 80309f4 <HAL_UART_Init+0x38>
    UART_AdvFeatureConfig(huart);
 80309ee:	4620      	mov	r0, r4
 80309f0:	f7ff fefa 	bl	80307e8 <UART_AdvFeatureConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 80309f4:	6823      	ldr	r3, [r4, #0]
 80309f6:	685a      	ldr	r2, [r3, #4]
 80309f8:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 80309fc:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 80309fe:	689a      	ldr	r2, [r3, #8]
 8030a00:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 8030a04:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 8030a06:	681a      	ldr	r2, [r3, #0]
 8030a08:	f042 0201 	orr.w	r2, r2, #1
  return (UART_CheckIdleState(huart));
 8030a0c:	4620      	mov	r0, r4
  __HAL_UART_ENABLE(huart);
 8030a0e:	601a      	str	r2, [r3, #0]
}
 8030a10:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return (UART_CheckIdleState(huart));
 8030a14:	f7ff bf9e 	b.w	8030954 <UART_CheckIdleState>
}
 8030a18:	2001      	movs	r0, #1
 8030a1a:	bd10      	pop	{r4, pc}

08030a1c <UART_Start_Receive_IT>:
  UART_MASK_COMPUTATION(huart);
 8030a1c:	6883      	ldr	r3, [r0, #8]
{
 8030a1e:	b510      	push	{r4, lr}
  UART_MASK_COMPUTATION(huart);
 8030a20:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
  huart->pRxBuffPtr  = pData;
 8030a24:	6581      	str	r1, [r0, #88]	; 0x58
  huart->RxISR       = NULL;
 8030a26:	f04f 0100 	mov.w	r1, #0
  huart->RxXferSize  = Size;
 8030a2a:	f8a0 205c 	strh.w	r2, [r0, #92]	; 0x5c
  huart->RxXferCount = Size;
 8030a2e:	f8a0 205e 	strh.w	r2, [r0, #94]	; 0x5e
  huart->RxISR       = NULL;
 8030a32:	6701      	str	r1, [r0, #112]	; 0x70
  UART_MASK_COMPUTATION(huart);
 8030a34:	d147      	bne.n	8030ac6 <UART_Start_Receive_IT+0xaa>
 8030a36:	6903      	ldr	r3, [r0, #16]
 8030a38:	2b00      	cmp	r3, #0
 8030a3a:	d142      	bne.n	8030ac2 <UART_Start_Receive_IT+0xa6>
 8030a3c:	f240 13ff 	movw	r3, #511	; 0x1ff
 8030a40:	f8a0 3060 	strh.w	r3, [r0, #96]	; 0x60
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8030a44:	2300      	movs	r3, #0
 8030a46:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
  huart->RxState = HAL_UART_STATE_BUSY_RX;
 8030a4a:	2322      	movs	r3, #34	; 0x22
 8030a4c:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
  ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8030a50:	6801      	ldr	r1, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030a52:	f101 0308 	add.w	r3, r1, #8
 8030a56:	e853 3f00 	ldrex	r3, [r3]
 8030a5a:	f043 0301 	orr.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030a5e:	3108      	adds	r1, #8
 8030a60:	e841 3400 	strex	r4, r3, [r1]
   return(result);
 8030a64:	6803      	ldr	r3, [r0, #0]
 8030a66:	2c00      	cmp	r4, #0
 8030a68:	d1f2      	bne.n	8030a50 <UART_Start_Receive_IT+0x34>
  if ((huart->FifoMode == UART_FIFOMODE_ENABLE) && (Size >= huart->NbRxDataToProcess))
 8030a6a:	6e44      	ldr	r4, [r0, #100]	; 0x64
 8030a6c:	6881      	ldr	r1, [r0, #8]
 8030a6e:	f1b4 5f00 	cmp.w	r4, #536870912	; 0x20000000
 8030a72:	d13b      	bne.n	8030aec <UART_Start_Receive_IT+0xd0>
 8030a74:	f8b0 4068 	ldrh.w	r4, [r0, #104]	; 0x68
 8030a78:	4294      	cmp	r4, r2
 8030a7a:	d837      	bhi.n	8030aec <UART_Start_Receive_IT+0xd0>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8030a7c:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 8030a80:	d132      	bne.n	8030ae8 <UART_Start_Receive_IT+0xcc>
 8030a82:	6904      	ldr	r4, [r0, #16]
      huart->RxISR = UART_RxISR_16BIT_FIFOEN;
 8030a84:	4a25      	ldr	r2, [pc, #148]	; (8030b1c <UART_Start_Receive_IT+0x100>)
 8030a86:	4926      	ldr	r1, [pc, #152]	; (8030b20 <UART_Start_Receive_IT+0x104>)
 8030a88:	2c00      	cmp	r4, #0
 8030a8a:	bf08      	it	eq
 8030a8c:	460a      	moveq	r2, r1
 8030a8e:	6702      	str	r2, [r0, #112]	; 0x70
    __HAL_UNLOCK(huart);
 8030a90:	2200      	movs	r2, #0
 8030a92:	f880 2080 	strb.w	r2, [r0, #128]	; 0x80
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030a96:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8030a9a:	f442 7280 	orr.w	r2, r2, #256	; 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030a9e:	e843 2100 	strex	r1, r2, [r3]
 8030aa2:	2900      	cmp	r1, #0
 8030aa4:	d1f7      	bne.n	8030a96 <UART_Start_Receive_IT+0x7a>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030aa6:	f103 0208 	add.w	r2, r3, #8
 8030aaa:	e852 2f00 	ldrex	r2, [r2]
    ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 8030aae:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030ab2:	f103 0008 	add.w	r0, r3, #8
 8030ab6:	e840 2100 	strex	r1, r2, [r0]
 8030aba:	2900      	cmp	r1, #0
 8030abc:	d1f3      	bne.n	8030aa6 <UART_Start_Receive_IT+0x8a>
}
 8030abe:	2000      	movs	r0, #0
 8030ac0:	bd10      	pop	{r4, pc}
  UART_MASK_COMPUTATION(huart);
 8030ac2:	23ff      	movs	r3, #255	; 0xff
 8030ac4:	e7bc      	b.n	8030a40 <UART_Start_Receive_IT+0x24>
 8030ac6:	b923      	cbnz	r3, 8030ad2 <UART_Start_Receive_IT+0xb6>
 8030ac8:	6903      	ldr	r3, [r0, #16]
 8030aca:	2b00      	cmp	r3, #0
 8030acc:	d0f9      	beq.n	8030ac2 <UART_Start_Receive_IT+0xa6>
 8030ace:	237f      	movs	r3, #127	; 0x7f
 8030ad0:	e7b6      	b.n	8030a40 <UART_Start_Receive_IT+0x24>
 8030ad2:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8030ad6:	d104      	bne.n	8030ae2 <UART_Start_Receive_IT+0xc6>
 8030ad8:	6903      	ldr	r3, [r0, #16]
 8030ada:	2b00      	cmp	r3, #0
 8030adc:	d0f7      	beq.n	8030ace <UART_Start_Receive_IT+0xb2>
 8030ade:	233f      	movs	r3, #63	; 0x3f
 8030ae0:	e7ae      	b.n	8030a40 <UART_Start_Receive_IT+0x24>
 8030ae2:	f8a0 1060 	strh.w	r1, [r0, #96]	; 0x60
 8030ae6:	e7ad      	b.n	8030a44 <UART_Start_Receive_IT+0x28>
      huart->RxISR = UART_RxISR_8BIT_FIFOEN;
 8030ae8:	4a0c      	ldr	r2, [pc, #48]	; (8030b1c <UART_Start_Receive_IT+0x100>)
 8030aea:	e7d0      	b.n	8030a8e <UART_Start_Receive_IT+0x72>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8030aec:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 8030af0:	d112      	bne.n	8030b18 <UART_Start_Receive_IT+0xfc>
 8030af2:	6904      	ldr	r4, [r0, #16]
      huart->RxISR = UART_RxISR_16BIT;
 8030af4:	4a0b      	ldr	r2, [pc, #44]	; (8030b24 <UART_Start_Receive_IT+0x108>)
 8030af6:	490c      	ldr	r1, [pc, #48]	; (8030b28 <UART_Start_Receive_IT+0x10c>)
 8030af8:	2c00      	cmp	r4, #0
 8030afa:	bf08      	it	eq
 8030afc:	460a      	moveq	r2, r1
 8030afe:	6702      	str	r2, [r0, #112]	; 0x70
    __HAL_UNLOCK(huart);
 8030b00:	2200      	movs	r2, #0
 8030b02:	f880 2080 	strb.w	r2, [r0, #128]	; 0x80
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030b06:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE);
 8030b0a:	f442 7290 	orr.w	r2, r2, #288	; 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030b0e:	e843 2100 	strex	r1, r2, [r3]
 8030b12:	2900      	cmp	r1, #0
 8030b14:	d1f7      	bne.n	8030b06 <UART_Start_Receive_IT+0xea>
 8030b16:	e7d2      	b.n	8030abe <UART_Start_Receive_IT+0xa2>
      huart->RxISR = UART_RxISR_8BIT;
 8030b18:	4a02      	ldr	r2, [pc, #8]	; (8030b24 <UART_Start_Receive_IT+0x108>)
 8030b1a:	e7f0      	b.n	8030afe <UART_Start_Receive_IT+0xe2>
 8030b1c:	080302c1 	.word	0x080302c1
 8030b20:	0803043d 	.word	0x0803043d
 8030b24:	0803027d 	.word	0x0803027d
 8030b28:	08030241 	.word	0x08030241

08030b2c <HAL_UART_Receive_IT>:
  if (huart->RxState == HAL_UART_STATE_READY)
 8030b2c:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
 8030b30:	2b20      	cmp	r3, #32
{
 8030b32:	b430      	push	{r4, r5}
  if (huart->RxState == HAL_UART_STATE_READY)
 8030b34:	d11f      	bne.n	8030b76 <HAL_UART_Receive_IT+0x4a>
    if ((pData == NULL) || (Size == 0U))
 8030b36:	b1d9      	cbz	r1, 8030b70 <HAL_UART_Receive_IT+0x44>
 8030b38:	b1d2      	cbz	r2, 8030b70 <HAL_UART_Receive_IT+0x44>
    __HAL_LOCK(huart);
 8030b3a:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 8030b3e:	2b01      	cmp	r3, #1
 8030b40:	d019      	beq.n	8030b76 <HAL_UART_Receive_IT+0x4a>
 8030b42:	2301      	movs	r3, #1
 8030b44:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8030b48:	2300      	movs	r3, #0
    if (!(IS_LPUART_INSTANCE(huart->Instance)))
 8030b4a:	6804      	ldr	r4, [r0, #0]
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8030b4c:	66c3      	str	r3, [r0, #108]	; 0x6c
    if (!(IS_LPUART_INSTANCE(huart->Instance)))
 8030b4e:	4b0b      	ldr	r3, [pc, #44]	; (8030b7c <HAL_UART_Receive_IT+0x50>)
 8030b50:	429c      	cmp	r4, r3
 8030b52:	d00a      	beq.n	8030b6a <HAL_UART_Receive_IT+0x3e>
      if(READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 8030b54:	6863      	ldr	r3, [r4, #4]
 8030b56:	021b      	lsls	r3, r3, #8
 8030b58:	d507      	bpl.n	8030b6a <HAL_UART_Receive_IT+0x3e>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030b5a:	e854 3f00 	ldrex	r3, [r4]
        ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 8030b5e:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030b62:	e844 3500 	strex	r5, r3, [r4]
 8030b66:	2d00      	cmp	r5, #0
 8030b68:	d1f7      	bne.n	8030b5a <HAL_UART_Receive_IT+0x2e>
}
 8030b6a:	bc30      	pop	{r4, r5}
    return(UART_Start_Receive_IT(huart, pData, Size));
 8030b6c:	f7ff bf56 	b.w	8030a1c <UART_Start_Receive_IT>
      return HAL_ERROR;
 8030b70:	2001      	movs	r0, #1
}
 8030b72:	bc30      	pop	{r4, r5}
 8030b74:	4770      	bx	lr
    return HAL_BUSY;
 8030b76:	2002      	movs	r0, #2
 8030b78:	e7fb      	b.n	8030b72 <HAL_UART_Receive_IT+0x46>
 8030b7a:	bf00      	nop
 8030b7c:	40008000 	.word	0x40008000

08030b80 <UARTEx_SetNbDataToProcess>:
  uint8_t rx_fifo_threshold;
  uint8_t tx_fifo_threshold;
  static const uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
  static const uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};

  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 8030b80:	6e43      	ldr	r3, [r0, #100]	; 0x64
{
 8030b82:	b510      	push	{r4, lr}
  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 8030b84:	b91b      	cbnz	r3, 8030b8e <UARTEx_SetNbDataToProcess+0xe>
  {
    huart->NbTxDataToProcess = 1U;
    huart->NbRxDataToProcess = 1U;
 8030b86:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 8030b8a:	6683      	str	r3, [r0, #104]	; 0x68
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
                               (uint16_t)denominator[tx_fifo_threshold];
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
                               (uint16_t)denominator[rx_fifo_threshold];
  }
}
 8030b8c:	bd10      	pop	{r4, pc}
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
 8030b8e:	6803      	ldr	r3, [r0, #0]
 8030b90:	689c      	ldr	r4, [r3, #8]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 8030b92:	689a      	ldr	r2, [r3, #8]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8030b94:	4b0a      	ldr	r3, [pc, #40]	; (8030bc0 <UARTEx_SetNbDataToProcess+0x40>)
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 8030b96:	0f52      	lsrs	r2, r2, #29
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8030b98:	5c99      	ldrb	r1, [r3, r2]
                               (uint16_t)denominator[tx_fifo_threshold];
 8030b9a:	441a      	add	r2, r3
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8030b9c:	00c9      	lsls	r1, r1, #3
                               (uint16_t)denominator[tx_fifo_threshold];
 8030b9e:	7a12      	ldrb	r2, [r2, #8]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8030ba0:	fbb1 f2f2 	udiv	r2, r1, r2
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8030ba4:	f3c4 6142 	ubfx	r1, r4, #25, #3
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8030ba8:	f8a0 206a 	strh.w	r2, [r0, #106]	; 0x6a
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8030bac:	5c5a      	ldrb	r2, [r3, r1]
                               (uint16_t)denominator[rx_fifo_threshold];
 8030bae:	440b      	add	r3, r1
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8030bb0:	00d2      	lsls	r2, r2, #3
                               (uint16_t)denominator[rx_fifo_threshold];
 8030bb2:	7a1b      	ldrb	r3, [r3, #8]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8030bb4:	fbb2 f3f3 	udiv	r3, r2, r3
 8030bb8:	f8a0 3068 	strh.w	r3, [r0, #104]	; 0x68
}
 8030bbc:	e7e6      	b.n	8030b8c <UARTEx_SetNbDataToProcess+0xc>
 8030bbe:	bf00      	nop
 8030bc0:	0803ba40 	.word	0x0803ba40

08030bc4 <HAL_UARTEx_WakeupCallback>:
}
 8030bc4:	4770      	bx	lr

08030bc6 <HAL_UARTEx_RxFifoFullCallback>:
 8030bc6:	4770      	bx	lr

08030bc8 <HAL_UARTEx_TxFifoEmptyCallback>:
 8030bc8:	4770      	bx	lr

08030bca <HAL_UARTEx_StopModeWakeUpSourceConfig>:
{
 8030bca:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8030bcc:	ab04      	add	r3, sp, #16
 8030bce:	e903 0006 	stmdb	r3, {r1, r2}
  __HAL_LOCK(huart);
 8030bd2:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 8030bd6:	9902      	ldr	r1, [sp, #8]
 8030bd8:	2b01      	cmp	r3, #1
{
 8030bda:	4604      	mov	r4, r0
  __HAL_LOCK(huart);
 8030bdc:	d03a      	beq.n	8030c54 <HAL_UARTEx_StopModeWakeUpSourceConfig+0x8a>
 8030bde:	2301      	movs	r3, #1
 8030be0:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
  huart->gState = HAL_UART_STATE_BUSY;
 8030be4:	2324      	movs	r3, #36	; 0x24
 8030be6:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  __HAL_UART_DISABLE(huart);
 8030bea:	6803      	ldr	r3, [r0, #0]
 8030bec:	681a      	ldr	r2, [r3, #0]
 8030bee:	f022 0201 	bic.w	r2, r2, #1
 8030bf2:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_WUS, WakeUpSelection.WakeUpEvent);
 8030bf4:	689a      	ldr	r2, [r3, #8]
 8030bf6:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8030bfa:	430a      	orrs	r2, r1
 8030bfc:	609a      	str	r2, [r3, #8]
  if (WakeUpSelection.WakeUpEvent == UART_WAKEUP_ON_ADDRESS)
 8030bfe:	b971      	cbnz	r1, 8030c1e <HAL_UARTEx_StopModeWakeUpSourceConfig+0x54>
  MODIFY_REG(huart->Instance->CR2, USART_CR2_ADDM7, WakeUpSelection.AddressLength);
 8030c00:	6859      	ldr	r1, [r3, #4]
 8030c02:	f8bd 200c 	ldrh.w	r2, [sp, #12]
    UARTEx_Wakeup_AddressConfig(huart, WakeUpSelection);
 8030c06:	f89d 000e 	ldrb.w	r0, [sp, #14]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_ADDM7, WakeUpSelection.AddressLength);
 8030c0a:	f021 0110 	bic.w	r1, r1, #16
 8030c0e:	4311      	orrs	r1, r2
 8030c10:	6059      	str	r1, [r3, #4]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, ((uint32_t)WakeUpSelection.Address << UART_CR2_ADDRESS_LSB_POS));
 8030c12:	685a      	ldr	r2, [r3, #4]
 8030c14:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 8030c18:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
 8030c1c:	605a      	str	r2, [r3, #4]
  __HAL_UART_ENABLE(huart);
 8030c1e:	681a      	ldr	r2, [r3, #0]
 8030c20:	f042 0201 	orr.w	r2, r2, #1
 8030c24:	601a      	str	r2, [r3, #0]
  tickstart = HAL_GetTick();
 8030c26:	f7fb fd0d 	bl	802c644 <HAL_GetTick>
  if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8030c2a:	f06f 427e 	mvn.w	r2, #4261412864	; 0xfe000000
  tickstart = HAL_GetTick();
 8030c2e:	4603      	mov	r3, r0
  if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8030c30:	9200      	str	r2, [sp, #0]
 8030c32:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 8030c36:	2200      	movs	r2, #0
 8030c38:	4620      	mov	r0, r4
 8030c3a:	f7ff fe29 	bl	8030890 <UART_WaitOnFlagUntilTimeout>
 8030c3e:	b938      	cbnz	r0, 8030c50 <HAL_UARTEx_StopModeWakeUpSourceConfig+0x86>
    huart->gState = HAL_UART_STATE_READY;
 8030c40:	2320      	movs	r3, #32
 8030c42:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  __HAL_UNLOCK(huart);
 8030c46:	2300      	movs	r3, #0
 8030c48:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
}
 8030c4c:	b004      	add	sp, #16
 8030c4e:	bd10      	pop	{r4, pc}
    status = HAL_TIMEOUT;
 8030c50:	2003      	movs	r0, #3
 8030c52:	e7f8      	b.n	8030c46 <HAL_UARTEx_StopModeWakeUpSourceConfig+0x7c>
  __HAL_LOCK(huart);
 8030c54:	2002      	movs	r0, #2
 8030c56:	e7f9      	b.n	8030c4c <HAL_UARTEx_StopModeWakeUpSourceConfig+0x82>

08030c58 <HAL_UARTEx_EnableStopMode>:
  __HAL_LOCK(huart);
 8030c58:	f890 2080 	ldrb.w	r2, [r0, #128]	; 0x80
 8030c5c:	2a01      	cmp	r2, #1
{
 8030c5e:	4603      	mov	r3, r0
  __HAL_LOCK(huart);
 8030c60:	d00e      	beq.n	8030c80 <HAL_UARTEx_EnableStopMode+0x28>
 8030c62:	2201      	movs	r2, #1
 8030c64:	f880 2080 	strb.w	r2, [r0, #128]	; 0x80
  ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_UESM);
 8030c68:	6819      	ldr	r1, [r3, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8030c6a:	e851 2f00 	ldrex	r2, [r1]
 8030c6e:	f042 0202 	orr.w	r2, r2, #2
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8030c72:	e841 2000 	strex	r0, r2, [r1]
 8030c76:	2800      	cmp	r0, #0
 8030c78:	d1f6      	bne.n	8030c68 <HAL_UARTEx_EnableStopMode+0x10>
  __HAL_UNLOCK(huart);
 8030c7a:	f883 0080 	strb.w	r0, [r3, #128]	; 0x80
  return HAL_OK;
 8030c7e:	4770      	bx	lr
  __HAL_LOCK(huart);
 8030c80:	2002      	movs	r0, #2
}
 8030c82:	4770      	bx	lr

08030c84 <HAL_UARTEx_EnableFifoMode>:
{
 8030c84:	b510      	push	{r4, lr}
  __HAL_LOCK(huart);
 8030c86:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 8030c8a:	2b01      	cmp	r3, #1
{
 8030c8c:	4604      	mov	r4, r0
  __HAL_LOCK(huart);
 8030c8e:	d01a      	beq.n	8030cc6 <HAL_UARTEx_EnableFifoMode+0x42>
 8030c90:	2301      	movs	r3, #1
 8030c92:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
  huart->gState = HAL_UART_STATE_BUSY;
 8030c96:	2324      	movs	r3, #36	; 0x24
 8030c98:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8030c9c:	6803      	ldr	r3, [r0, #0]
 8030c9e:	681a      	ldr	r2, [r3, #0]
  __HAL_UART_DISABLE(huart);
 8030ca0:	6819      	ldr	r1, [r3, #0]
 8030ca2:	f021 0101 	bic.w	r1, r1, #1
 8030ca6:	6019      	str	r1, [r3, #0]
  SET_BIT(tmpcr1, USART_CR1_FIFOEN);
 8030ca8:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
  huart->FifoMode = UART_FIFOMODE_ENABLE;
 8030cac:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
 8030cb0:	6641      	str	r1, [r0, #100]	; 0x64
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8030cb2:	601a      	str	r2, [r3, #0]
  UARTEx_SetNbDataToProcess(huart);
 8030cb4:	f7ff ff64 	bl	8030b80 <UARTEx_SetNbDataToProcess>
  huart->gState = HAL_UART_STATE_READY;
 8030cb8:	2320      	movs	r3, #32
 8030cba:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  __HAL_UNLOCK(huart);
 8030cbe:	2000      	movs	r0, #0
 8030cc0:	f884 0080 	strb.w	r0, [r4, #128]	; 0x80
}
 8030cc4:	bd10      	pop	{r4, pc}
  __HAL_LOCK(huart);
 8030cc6:	2002      	movs	r0, #2
 8030cc8:	e7fc      	b.n	8030cc4 <HAL_UARTEx_EnableFifoMode+0x40>

08030cca <HAL_UARTEx_SetTxFifoThreshold>:
{
 8030cca:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(huart);
 8030ccc:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 8030cd0:	2b01      	cmp	r3, #1
{
 8030cd2:	4604      	mov	r4, r0
  __HAL_LOCK(huart);
 8030cd4:	d01b      	beq.n	8030d0e <HAL_UARTEx_SetTxFifoThreshold+0x44>
 8030cd6:	2301      	movs	r3, #1
 8030cd8:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
  huart->gState = HAL_UART_STATE_BUSY;
 8030cdc:	2324      	movs	r3, #36	; 0x24
 8030cde:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8030ce2:	6803      	ldr	r3, [r0, #0]
 8030ce4:	681d      	ldr	r5, [r3, #0]
  __HAL_UART_DISABLE(huart);
 8030ce6:	681a      	ldr	r2, [r3, #0]
 8030ce8:	f022 0201 	bic.w	r2, r2, #1
 8030cec:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
 8030cee:	689a      	ldr	r2, [r3, #8]
 8030cf0:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
 8030cf4:	4311      	orrs	r1, r2
 8030cf6:	6099      	str	r1, [r3, #8]
  UARTEx_SetNbDataToProcess(huart);
 8030cf8:	f7ff ff42 	bl	8030b80 <UARTEx_SetNbDataToProcess>
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8030cfc:	6803      	ldr	r3, [r0, #0]
 8030cfe:	601d      	str	r5, [r3, #0]
  huart->gState = HAL_UART_STATE_READY;
 8030d00:	2320      	movs	r3, #32
 8030d02:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  __HAL_UNLOCK(huart);
 8030d06:	2000      	movs	r0, #0
 8030d08:	f884 0080 	strb.w	r0, [r4, #128]	; 0x80
}
 8030d0c:	bd38      	pop	{r3, r4, r5, pc}
  __HAL_LOCK(huart);
 8030d0e:	2002      	movs	r0, #2
 8030d10:	e7fc      	b.n	8030d0c <HAL_UARTEx_SetTxFifoThreshold+0x42>

08030d12 <HAL_UARTEx_SetRxFifoThreshold>:
{
 8030d12:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(huart);
 8030d14:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 8030d18:	2b01      	cmp	r3, #1
{
 8030d1a:	4604      	mov	r4, r0
  __HAL_LOCK(huart);
 8030d1c:	d01b      	beq.n	8030d56 <HAL_UARTEx_SetRxFifoThreshold+0x44>
 8030d1e:	2301      	movs	r3, #1
 8030d20:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
  huart->gState = HAL_UART_STATE_BUSY;
 8030d24:	2324      	movs	r3, #36	; 0x24
 8030d26:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8030d2a:	6803      	ldr	r3, [r0, #0]
 8030d2c:	681d      	ldr	r5, [r3, #0]
  __HAL_UART_DISABLE(huart);
 8030d2e:	681a      	ldr	r2, [r3, #0]
 8030d30:	f022 0201 	bic.w	r2, r2, #1
 8030d34:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
 8030d36:	689a      	ldr	r2, [r3, #8]
 8030d38:	f022 6260 	bic.w	r2, r2, #234881024	; 0xe000000
 8030d3c:	4311      	orrs	r1, r2
 8030d3e:	6099      	str	r1, [r3, #8]
  UARTEx_SetNbDataToProcess(huart);
 8030d40:	f7ff ff1e 	bl	8030b80 <UARTEx_SetNbDataToProcess>
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8030d44:	6803      	ldr	r3, [r0, #0]
 8030d46:	601d      	str	r5, [r3, #0]
  huart->gState = HAL_UART_STATE_READY;
 8030d48:	2320      	movs	r3, #32
 8030d4a:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  __HAL_UNLOCK(huart);
 8030d4e:	2000      	movs	r0, #0
 8030d50:	f884 0080 	strb.w	r0, [r4, #128]	; 0x80
}
 8030d54:	bd38      	pop	{r3, r4, r5, pc}
  __HAL_LOCK(huart);
 8030d56:	2002      	movs	r0, #2
 8030d58:	e7fc      	b.n	8030d54 <HAL_UARTEx_SetRxFifoThreshold+0x42>
	...

08030d5c <SetRow>:
 * Fragmentation decoder algorithm utilities
 *=============================================================================
 */

static void SetRow( uint8_t *src, uint16_t row, uint16_t size )
{
 8030d5c:	460b      	mov	r3, r1
    if( ( FragDecoder.Callbacks != NULL ) && ( FragDecoder.Callbacks->FragDecoderWrite != NULL ) )
 8030d5e:	4907      	ldr	r1, [pc, #28]	; (8030d7c <SetRow+0x20>)
 8030d60:	6809      	ldr	r1, [r1, #0]
{
 8030d62:	b430      	push	{r4, r5}
    if( ( FragDecoder.Callbacks != NULL ) && ( FragDecoder.Callbacks->FragDecoderWrite != NULL ) )
 8030d64:	b139      	cbz	r1, 8030d76 <SetRow+0x1a>
 8030d66:	684d      	ldr	r5, [r1, #4]
 8030d68:	b12d      	cbz	r5, 8030d76 <SetRow+0x1a>
    {
        FragDecoder.Callbacks->FragDecoderWrite( row * size, src, size );
 8030d6a:	4601      	mov	r1, r0
 8030d6c:	fb02 f003 	mul.w	r0, r2, r3
 8030d70:	462b      	mov	r3, r5
    }
}
 8030d72:	bc30      	pop	{r4, r5}
        FragDecoder.Callbacks->FragDecoderWrite( row * size, src, size );
 8030d74:	4718      	bx	r3
}
 8030d76:	bc30      	pop	{r4, r5}
 8030d78:	4770      	bx	lr
 8030d7a:	bf00      	nop
 8030d7c:	20003f54 	.word	0x20003f54

08030d80 <GetRow>:

static void GetRow( uint8_t *dst, uint16_t row, uint16_t size )
{
 8030d80:	460b      	mov	r3, r1
    if( ( FragDecoder.Callbacks != NULL ) && ( FragDecoder.Callbacks->FragDecoderRead != NULL ) )
 8030d82:	4907      	ldr	r1, [pc, #28]	; (8030da0 <GetRow+0x20>)
 8030d84:	6809      	ldr	r1, [r1, #0]
{
 8030d86:	b430      	push	{r4, r5}
    if( ( FragDecoder.Callbacks != NULL ) && ( FragDecoder.Callbacks->FragDecoderRead != NULL ) )
 8030d88:	b139      	cbz	r1, 8030d9a <GetRow+0x1a>
 8030d8a:	688d      	ldr	r5, [r1, #8]
 8030d8c:	b12d      	cbz	r5, 8030d9a <GetRow+0x1a>
    {
        FragDecoder.Callbacks->FragDecoderRead( row * size, dst, size );
 8030d8e:	4601      	mov	r1, r0
 8030d90:	fb02 f003 	mul.w	r0, r2, r3
 8030d94:	462b      	mov	r3, r5
    }
}
 8030d96:	bc30      	pop	{r4, r5}
        FragDecoder.Callbacks->FragDecoderRead( row * size, dst, size );
 8030d98:	4718      	bx	r3
}
 8030d9a:	bc30      	pop	{r4, r5}
 8030d9c:	4770      	bx	lr
 8030d9e:	bf00      	nop
 8030da0:	20003f54 	.word	0x20003f54

08030da4 <GetParity>:

static uint8_t GetParity( uint16_t index, uint8_t *matrixRow  )
{
    uint8_t parity;
    parity = matrixRow[index >> 3];
 8030da4:	08c3      	lsrs	r3, r0, #3
    parity = ( parity >> ( 7 - ( index % 8 ) ) ) & 0x01;
 8030da6:	43c0      	mvns	r0, r0
 8030da8:	5ccb      	ldrb	r3, [r1, r3]
 8030daa:	f000 0007 	and.w	r0, r0, #7
 8030dae:	fa43 f000 	asr.w	r0, r3, r0
    return parity;
}
 8030db2:	f000 0001 	and.w	r0, r0, #1
 8030db6:	4770      	bx	lr

08030db8 <SetParity>:

static void SetParity( uint16_t index, uint8_t *matrixRow, uint8_t parity )
{
    uint8_t mask = 0xFF - ( 1 << ( 7 - ( index % 8 ) ) );
 8030db8:	43c3      	mvns	r3, r0
 8030dba:	f003 0307 	and.w	r3, r3, #7
    parity = parity << ( 7 - ( index % 8 ) );
    matrixRow[index >> 3] = ( matrixRow[index >> 3] & mask ) + parity;
 8030dbe:	08c0      	lsrs	r0, r0, #3
{
 8030dc0:	b510      	push	{r4, lr}
    parity = parity << ( 7 - ( index % 8 ) );
 8030dc2:	fa02 f403 	lsl.w	r4, r2, r3
    uint8_t mask = 0xFF - ( 1 << ( 7 - ( index % 8 ) ) );
 8030dc6:	2201      	movs	r2, #1
 8030dc8:	fa02 f303 	lsl.w	r3, r2, r3
    matrixRow[index >> 3] = ( matrixRow[index >> 3] & mask ) + parity;
 8030dcc:	5c0a      	ldrb	r2, [r1, r0]
 8030dce:	ea22 0203 	bic.w	r2, r2, r3
 8030dd2:	4422      	add	r2, r4
 8030dd4:	540a      	strb	r2, [r1, r0]
}
 8030dd6:	bd10      	pop	{r4, pc}

08030dd8 <XorDataLine>:
    }
    return false;
}

static void XorDataLine( uint8_t *line1, uint8_t *line2, int32_t size )
{
 8030dd8:	b530      	push	{r4, r5, lr}
 8030dda:	3801      	subs	r0, #1
    for( int32_t i = 0; i < size; i++ )
 8030ddc:	2300      	movs	r3, #0
 8030dde:	4293      	cmp	r3, r2
 8030de0:	d100      	bne.n	8030de4 <XorDataLine+0xc>
    {
        line1[i] = line1[i] ^ line2[i];
    }
}
 8030de2:	bd30      	pop	{r4, r5, pc}
        line1[i] = line1[i] ^ line2[i];
 8030de4:	5ccd      	ldrb	r5, [r1, r3]
 8030de6:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 8030dea:	406c      	eors	r4, r5
 8030dec:	7004      	strb	r4, [r0, #0]
    for( int32_t i = 0; i < size; i++ )
 8030dee:	3301      	adds	r3, #1
 8030df0:	e7f5      	b.n	8030dde <XorDataLine+0x6>

08030df2 <XorParityLine>:

static void XorParityLine( uint8_t* line1, uint8_t* line2, int32_t size )
{
 8030df2:	e92d 41d8 	stmdb	sp!, {r3, r4, r6, r7, r8, lr}
 8030df6:	4606      	mov	r6, r0
 8030df8:	4688      	mov	r8, r1
 8030dfa:	b297      	uxth	r7, r2
    for( int32_t i = 0; i < size; i++ )
 8030dfc:	2400      	movs	r4, #0
 8030dfe:	42bc      	cmp	r4, r7
 8030e00:	d101      	bne.n	8030e06 <XorParityLine+0x14>
    {
        SetParity( i, line1, ( GetParity( i, line1 ) ^ GetParity( i, line2 ) ) );
    }
}
 8030e02:	e8bd 81d8 	ldmia.w	sp!, {r3, r4, r6, r7, r8, pc}
        SetParity( i, line1, ( GetParity( i, line1 ) ^ GetParity( i, line2 ) ) );
 8030e06:	4631      	mov	r1, r6
 8030e08:	4620      	mov	r0, r4
 8030e0a:	f7ff ffcb 	bl	8030da4 <GetParity>
 8030e0e:	4641      	mov	r1, r8
 8030e10:	4602      	mov	r2, r0
 8030e12:	4620      	mov	r0, r4
 8030e14:	f7ff ffc6 	bl	8030da4 <GetParity>
 8030e18:	4042      	eors	r2, r0
 8030e1a:	b2d2      	uxtb	r2, r2
 8030e1c:	4620      	mov	r0, r4
 8030e1e:	4631      	mov	r1, r6
 8030e20:	3401      	adds	r4, #1
 8030e22:	f7ff ffc9 	bl	8030db8 <SetParity>
    for( int32_t i = 0; i < size; i++ )
 8030e26:	b2a4      	uxth	r4, r4
 8030e28:	e7e9      	b.n	8030dfe <XorParityLine+0xc>
	...

08030e2c <FragFindMissingFrags>:
 * \param [OUT] FragDecoder.FragNbMissingIndex[] array is updated in place
 */
static void FragFindMissingFrags( uint16_t counter )
{
    int32_t i;
    for( i = FragDecoder.Status.FragNbLastRx; i < ( counter - 1 ); i++ )
 8030e2c:	4b13      	ldr	r3, [pc, #76]	; (8030e7c <FragFindMissingFrags+0x50>)
{
 8030e2e:	b5f0      	push	{r4, r5, r6, r7, lr}
    for( i = FragDecoder.Status.FragNbLastRx; i < ( counter - 1 ); i++ )
 8030e30:	f8b3 6882 	ldrh.w	r6, [r3, #2178]	; 0x882
    {
        if( i < FragDecoder.FragNb )
 8030e34:	889c      	ldrh	r4, [r3, #4]
 8030e36:	f8b3 1880 	ldrh.w	r1, [r3, #2176]	; 0x880
    for( i = FragDecoder.Status.FragNbLastRx; i < ( counter - 1 ); i++ )
 8030e3a:	4635      	mov	r5, r6
 8030e3c:	2700      	movs	r7, #0
 8030e3e:	1e42      	subs	r2, r0, #1
 8030e40:	42aa      	cmp	r2, r5
 8030e42:	dc0f      	bgt.n	8030e64 <FragFindMissingFrags+0x38>
 8030e44:	43f2      	mvns	r2, r6
 8030e46:	4402      	add	r2, r0
 8030e48:	4286      	cmp	r6, r0
 8030e4a:	bf28      	it	cs
 8030e4c:	2200      	movcs	r2, #0
 8030e4e:	4432      	add	r2, r6
 8030e50:	b10f      	cbz	r7, 8030e56 <FragFindMissingFrags+0x2a>
 8030e52:	f8a3 1880 	strh.w	r1, [r3, #2176]	; 0x880
        {
            FragDecoder.Status.FragNbLost++;
            FragDecoder.FragNbMissingIndex[i] = FragDecoder.Status.FragNbLost;
        }
    }
    if( i < FragDecoder.FragNb )
 8030e56:	4294      	cmp	r4, r2
    {
        FragDecoder.Status.FragNbLastRx = counter;
    }
    else
    {
        FragDecoder.Status.FragNbLastRx = FragDecoder.FragNb + 1;
 8030e58:	bfdc      	itt	le
 8030e5a:	1c60      	addle	r0, r4, #1
 8030e5c:	b280      	uxthle	r0, r0
 8030e5e:	f8a3 0882 	strh.w	r0, [r3, #2178]	; 0x882
    }
}
 8030e62:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if( i < FragDecoder.FragNb )
 8030e64:	42ac      	cmp	r4, r5
 8030e66:	dd06      	ble.n	8030e76 <FragFindMissingFrags+0x4a>
            FragDecoder.FragNbMissingIndex[i] = FragDecoder.Status.FragNbLost;
 8030e68:	eb03 0745 	add.w	r7, r3, r5, lsl #1
            FragDecoder.Status.FragNbLost++;
 8030e6c:	3101      	adds	r1, #1
 8030e6e:	b289      	uxth	r1, r1
            FragDecoder.FragNbMissingIndex[i] = FragDecoder.Status.FragNbLost;
 8030e70:	f8a7 12dc 	strh.w	r1, [r7, #732]	; 0x2dc
 8030e74:	2701      	movs	r7, #1
    for( i = FragDecoder.Status.FragNbLastRx; i < ( counter - 1 ); i++ )
 8030e76:	3501      	adds	r5, #1
 8030e78:	e7e2      	b.n	8030e40 <FragFindMissingFrags+0x14>
 8030e7a:	bf00      	nop
 8030e7c:	20003f54 	.word	0x20003f54

08030e80 <FragFindMissingIndex>:
 *
 * \retval counter The counter value associated to the x th missing frag
 */
static uint16_t FragFindMissingIndex( uint16_t x )
{
    for( uint16_t i = 0; i < FragDecoder.FragNb; i++ )
 8030e80:	4b09      	ldr	r3, [pc, #36]	; (8030ea8 <FragFindMissingIndex+0x28>)
{
 8030e82:	b530      	push	{r4, r5, lr}
    for( uint16_t i = 0; i < FragDecoder.FragNb; i++ )
 8030e84:	2200      	movs	r2, #0
 8030e86:	889c      	ldrh	r4, [r3, #4]
    {
        if( FragDecoder.FragNbMissingIndex[i] == ( x + 1 ) )
 8030e88:	1c41      	adds	r1, r0, #1
 8030e8a:	f503 7337 	add.w	r3, r3, #732	; 0x2dc
 8030e8e:	b290      	uxth	r0, r2
    for( uint16_t i = 0; i < FragDecoder.FragNb; i++ )
 8030e90:	4284      	cmp	r4, r0
 8030e92:	d801      	bhi.n	8030e98 <FragFindMissingIndex+0x18>
        {
            return i;
        }
    }
    return 0;
 8030e94:	2000      	movs	r0, #0
 8030e96:	e005      	b.n	8030ea4 <FragFindMissingIndex+0x24>
        if( FragDecoder.FragNbMissingIndex[i] == ( x + 1 ) )
 8030e98:	f833 5b02 	ldrh.w	r5, [r3], #2
 8030e9c:	428d      	cmp	r5, r1
 8030e9e:	f102 0201 	add.w	r2, r2, #1
 8030ea2:	d1f4      	bne.n	8030e8e <FragFindMissingIndex+0xe>
}
 8030ea4:	bd30      	pop	{r4, r5, pc}
 8030ea6:	bf00      	nop
 8030ea8:	20003f54 	.word	0x20003f54

08030eac <FragExtractLineFromBinaryMatrix>:
 * \param [IN] bitArray  Pointer to the bit array
 * \param [IN] rowIndex  Matrix row index
 * \param [IN] bitsInRow Number of bits in one row
 */
static void FragExtractLineFromBinaryMatrix( uint8_t* bitArray, uint16_t rowIndex, uint16_t bitsInRow )
{
 8030eac:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8030eb0:	4680      	mov	r8, r0
 8030eb2:	4616      	mov	r6, r2
    uint32_t findByte = 0;
    uint32_t findBitInByte = 0;

    if( rowIndex > 0 )
 8030eb4:	460d      	mov	r5, r1
 8030eb6:	b309      	cbz	r1, 8030efc <FragExtractLineFromBinaryMatrix+0x50>
    {
        findByte      = ( rowIndex * bitsInRow - ( ( rowIndex * ( rowIndex - 1 ) ) >> 1 ) ) >> 3;
 8030eb8:	1e4b      	subs	r3, r1, #1
 8030eba:	434b      	muls	r3, r1
 8030ebc:	fb01 f402 	mul.w	r4, r1, r2
 8030ec0:	eba4 0463 	sub.w	r4, r4, r3, asr #1
        findBitInByte = ( rowIndex * bitsInRow - ( ( rowIndex * ( rowIndex - 1 ) ) >> 1 ) ) % 8;
 8030ec4:	4263      	negs	r3, r4
 8030ec6:	f003 0307 	and.w	r3, r3, #7
        findByte      = ( rowIndex * bitsInRow - ( ( rowIndex * ( rowIndex - 1 ) ) >> 1 ) ) >> 3;
 8030eca:	ea4f 07e4 	mov.w	r7, r4, asr #3
        findBitInByte = ( rowIndex * bitsInRow - ( ( rowIndex * ( rowIndex - 1 ) ) >> 1 ) ) % 8;
 8030ece:	f04f 0900 	mov.w	r9, #0
 8030ed2:	f004 0407 	and.w	r4, r4, #7
 8030ed6:	bf58      	it	pl
 8030ed8:	425c      	negpl	r4, r3
    }
    if( rowIndex > 0 )
    {
        for( uint16_t i = 0; i < rowIndex; i++ )
 8030eda:	45a9      	cmp	r9, r5
 8030edc:	fa1f f089 	uxth.w	r0, r9
 8030ee0:	d105      	bne.n	8030eee <FragExtractLineFromBinaryMatrix+0x42>
    }
    for( uint16_t i = rowIndex; i < bitsInRow; i++ )
    {
        SetParity( i,
                   bitArray, 
                   ( FragDecoder.MatrixM2B[findByte] >> ( 7 - findBitInByte ) ) & 0x01 );
 8030ee2:	f8df 9048 	ldr.w	r9, [pc, #72]	; 8030f2c <FragExtractLineFromBinaryMatrix+0x80>
    for( uint16_t i = rowIndex; i < bitsInRow; i++ )
 8030ee6:	42b5      	cmp	r5, r6
 8030ee8:	d30b      	bcc.n	8030f02 <FragExtractLineFromBinaryMatrix+0x56>
        {
            findBitInByte = 0;
            findByte++;
        }
    }
}
 8030eea:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            SetParity( i, bitArray, 0 );
 8030eee:	2200      	movs	r2, #0
 8030ef0:	4641      	mov	r1, r8
 8030ef2:	f7ff ff61 	bl	8030db8 <SetParity>
        for( uint16_t i = 0; i < rowIndex; i++ )
 8030ef6:	f109 0901 	add.w	r9, r9, #1
 8030efa:	e7ee      	b.n	8030eda <FragExtractLineFromBinaryMatrix+0x2e>
    uint32_t findBitInByte = 0;
 8030efc:	460c      	mov	r4, r1
    uint32_t findByte = 0;
 8030efe:	460f      	mov	r7, r1
 8030f00:	e7ef      	b.n	8030ee2 <FragExtractLineFromBinaryMatrix+0x36>
                   ( FragDecoder.MatrixM2B[findByte] >> ( 7 - findBitInByte ) ) & 0x01 );
 8030f02:	eb09 0307 	add.w	r3, r9, r7
        SetParity( i,
 8030f06:	4628      	mov	r0, r5
                   ( FragDecoder.MatrixM2B[findByte] >> ( 7 - findBitInByte ) ) & 0x01 );
 8030f08:	7b1a      	ldrb	r2, [r3, #12]
 8030f0a:	f1c4 0307 	rsb	r3, r4, #7
 8030f0e:	411a      	asrs	r2, r3
        findBitInByte++;
 8030f10:	3401      	adds	r4, #1
        SetParity( i,
 8030f12:	f002 0201 	and.w	r2, r2, #1
 8030f16:	4641      	mov	r1, r8
 8030f18:	f7ff ff4e 	bl	8030db8 <SetParity>
    for( uint16_t i = rowIndex; i < bitsInRow; i++ )
 8030f1c:	3501      	adds	r5, #1
        if( findBitInByte == 8 )
 8030f1e:	2c08      	cmp	r4, #8
            findByte++;
 8030f20:	bf04      	itt	eq
 8030f22:	3701      	addeq	r7, #1
            findBitInByte = 0;
 8030f24:	2400      	moveq	r4, #0
    for( uint16_t i = rowIndex; i < bitsInRow; i++ )
 8030f26:	b2ad      	uxth	r5, r5
 8030f28:	e7dd      	b.n	8030ee6 <FragExtractLineFromBinaryMatrix+0x3a>
 8030f2a:	bf00      	nop
 8030f2c:	20003f54 	.word	0x20003f54

08030f30 <FragDecoderInit>:
{
 8030f30:	b510      	push	{r4, lr}
    FragDecoder.Callbacks = callbacks;
 8030f32:	4c15      	ldr	r4, [pc, #84]	; (8030f88 <FragDecoderInit+0x58>)
    FragDecoder.Status.FragNbLost = 0;
 8030f34:	2300      	movs	r3, #0
    FragDecoder.FragNb = fragNb;                                // FragNb = FRAG_MAX_SIZE
 8030f36:	80a0      	strh	r0, [r4, #4]
    FragDecoder.FragSize = fragSize;                            // number of byte on a row
 8030f38:	71a1      	strb	r1, [r4, #6]
    FragDecoder.Status.FragNbLost = 0;
 8030f3a:	f8c4 3880 	str.w	r3, [r4, #2176]	; 0x880
    FragDecoder.M2BLine = 0;
 8030f3e:	60a3      	str	r3, [r4, #8]
    FragDecoder.Callbacks = callbacks;
 8030f40:	6022      	str	r2, [r4, #0]
    for( uint16_t i = 0; i < FRAG_MAX_NB; i++ )
 8030f42:	f504 7137 	add.w	r1, r4, #732	; 0x2dc
    FragDecoder.M2BLine = 0;
 8030f46:	f44f 7333 	mov.w	r3, #716	; 0x2cc
        FragDecoder.FragNbMissingIndex[i] = 1;
 8030f4a:	2001      	movs	r0, #1
 8030f4c:	3b01      	subs	r3, #1
 8030f4e:	b29b      	uxth	r3, r3
 8030f50:	f821 0b02 	strh.w	r0, [r1], #2
    for( uint16_t i = 0; i < FRAG_MAX_NB; i++ )
 8030f54:	2b00      	cmp	r3, #0
 8030f56:	d1f9      	bne.n	8030f4c <FragDecoderInit+0x1c>
 8030f58:	490c      	ldr	r1, [pc, #48]	; (8030f8c <FragDecoderInit+0x5c>)
        FragDecoder.S[i] = 0;
 8030f5a:	4618      	mov	r0, r3
    for( uint32_t i = 0; i < ( ( FRAG_MAX_REDUNDANCY >> 3 ) + 1 ); i++ )
 8030f5c:	3301      	adds	r3, #1
 8030f5e:	2b0a      	cmp	r3, #10
        FragDecoder.S[i] = 0;
 8030f60:	f801 0b01 	strb.w	r0, [r1], #1
    for( uint32_t i = 0; i < ( ( FRAG_MAX_REDUNDANCY >> 3 ) + 1 ); i++ )
 8030f64:	d1fa      	bne.n	8030f5c <FragDecoderInit+0x2c>
 8030f66:	490a      	ldr	r1, [pc, #40]	; (8030f90 <FragDecoderInit+0x60>)
    for( uint32_t i = 0; i < ( ( ( FRAG_MAX_REDUNDANCY >> 3 ) + 1 ) * FRAG_MAX_REDUNDANCY ); i++ )
 8030f68:	2300      	movs	r3, #0
       FragDecoder.MatrixM2B[i] = 0xFF;
 8030f6a:	20ff      	movs	r0, #255	; 0xff
    for( uint32_t i = 0; i < ( ( ( FRAG_MAX_REDUNDANCY >> 3 ) + 1 ) * FRAG_MAX_REDUNDANCY ); i++ )
 8030f6c:	3301      	adds	r3, #1
 8030f6e:	f5b3 7f34 	cmp.w	r3, #720	; 0x2d0
       FragDecoder.MatrixM2B[i] = 0xFF;
 8030f72:	f801 0b01 	strb.w	r0, [r1], #1
    for( uint32_t i = 0; i < ( ( ( FRAG_MAX_REDUNDANCY >> 3 ) + 1 ) * FRAG_MAX_REDUNDANCY ); i++ )
 8030f76:	d1f9      	bne.n	8030f6c <FragDecoderInit+0x3c>
    if (FragDecoder.Callbacks->FragDecoderErase != NULL)
 8030f78:	6813      	ldr	r3, [r2, #0]
 8030f7a:	b103      	cbz	r3, 8030f7e <FragDecoderInit+0x4e>
        FragDecoder.Callbacks->FragDecoderErase();
 8030f7c:	4798      	blx	r3
    FragDecoder.Status.FragNbLost = 0;
 8030f7e:	2300      	movs	r3, #0
 8030f80:	f8c4 3880 	str.w	r3, [r4, #2176]	; 0x880
}
 8030f84:	bd10      	pop	{r4, pc}
 8030f86:	bf00      	nop
 8030f88:	20003f54 	.word	0x20003f54
 8030f8c:	200047c8 	.word	0x200047c8
 8030f90:	20003f60 	.word	0x20003f60

08030f94 <FragDecoderGetMaxFileSize>:
}
 8030f94:	4800      	ldr	r0, [pc, #0]	; (8030f98 <FragDecoderGetMaxFileSize+0x4>)
 8030f96:	4770      	bx	lr
 8030f98:	00014fa0 	.word	0x00014fa0

08030f9c <FragDecoderProcess>:
{
 8030f9c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8030fa0:	b0bd      	sub	sp, #244	; 0xf4
 8030fa2:	4604      	mov	r4, r0
    UTIL_MEM_set_8(matrixRow, 0, (FRAG_MAX_NB >> 3) + 1);
 8030fa4:	225a      	movs	r2, #90	; 0x5a
 8030fa6:	a807      	add	r0, sp, #28
{
 8030fa8:	460f      	mov	r7, r1
    UTIL_MEM_set_8(matrixRow, 0, (FRAG_MAX_NB >> 3) + 1);
 8030faa:	2100      	movs	r1, #0
 8030fac:	f009 ff8c 	bl	803aec8 <UTIL_MEM_set_8>
    UTIL_MEM_set_8(matrixDataTemp, 0, FRAG_MAX_SIZE);
 8030fb0:	2278      	movs	r2, #120	; 0x78
 8030fb2:	eb0d 0002 	add.w	r0, sp, r2
 8030fb6:	2100      	movs	r1, #0
 8030fb8:	f009 ff86 	bl	803aec8 <UTIL_MEM_set_8>
    FragDecoder.Status.FragNbRx = fragCounter;
 8030fbc:	4eba      	ldr	r6, [pc, #744]	; (80312a8 <FragDecoderProcess+0x30c>)
    UTIL_MEM_set_8(dataTempVector, 0, (FRAG_MAX_REDUNDANCY >> 3) + 1);
 8030fbe:	220a      	movs	r2, #10
 8030fc0:	2100      	movs	r1, #0
 8030fc2:	a801      	add	r0, sp, #4
 8030fc4:	f009 ff80 	bl	803aec8 <UTIL_MEM_set_8>
    UTIL_MEM_set_8(dataTempVector2, 0, (FRAG_MAX_REDUNDANCY >> 3) + 1);
 8030fc8:	220a      	movs	r2, #10
 8030fca:	2100      	movs	r1, #0
 8030fcc:	a804      	add	r0, sp, #16
 8030fce:	f009 ff7b 	bl	803aec8 <UTIL_MEM_set_8>
    if( fragCounter < FragDecoder.Status.FragNbLastRx )
 8030fd2:	f8b6 3882 	ldrh.w	r3, [r6, #2178]	; 0x882
    FragDecoder.Status.FragNbRx = fragCounter;
 8030fd6:	f8a6 487e 	strh.w	r4, [r6, #2174]	; 0x87e
    if( fragCounter < FragDecoder.Status.FragNbLastRx )
 8030fda:	42a3      	cmp	r3, r4
 8030fdc:	4635      	mov	r5, r6
 8030fde:	d904      	bls.n	8030fea <FragDecoderProcess+0x4e>
        return FRAG_SESSION_ONGOING;  // Drop frame out of order
 8030fe0:	f04f 30ff 	mov.w	r0, #4294967295
}
 8030fe4:	b03d      	add	sp, #244	; 0xf4
 8030fe6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( fragCounter < ( FragDecoder.FragNb + 1 ) )
 8030fea:	88b3      	ldrh	r3, [r6, #4]
 8030fec:	42a3      	cmp	r3, r4
 8030fee:	d318      	bcc.n	8031022 <FragDecoderProcess+0x86>
        SetRow( rawData, fragCounter - 1, FragDecoder.FragSize );
 8030ff0:	1e61      	subs	r1, r4, #1
 8030ff2:	79b2      	ldrb	r2, [r6, #6]
 8030ff4:	b289      	uxth	r1, r1
 8030ff6:	4638      	mov	r0, r7
 8030ff8:	f7ff feb0 	bl	8030d5c <SetRow>
        FragDecoder.FragNbMissingIndex[fragCounter - 1] = 0;
 8030ffc:	f204 136b 	addw	r3, r4, #363	; 0x16b
 8031000:	eb06 0343 	add.w	r3, r6, r3, lsl #1
 8031004:	2200      	movs	r2, #0
        FragFindMissingFrags( fragCounter );
 8031006:	4620      	mov	r0, r4
        FragDecoder.FragNbMissingIndex[fragCounter - 1] = 0;
 8031008:	809a      	strh	r2, [r3, #4]
        FragFindMissingFrags( fragCounter );
 803100a:	f7ff ff0f 	bl	8030e2c <FragFindMissingFrags>
        if ((fragCounter == FragDecoder.FragNb) && (FragDecoder.Status.FragNbLost == 0U))
 803100e:	88b3      	ldrh	r3, [r6, #4]
 8031010:	42a3      	cmp	r3, r4
 8031012:	d1e5      	bne.n	8030fe0 <FragDecoderProcess+0x44>
 8031014:	f8b6 0880 	ldrh.w	r0, [r6, #2176]	; 0x880
 8031018:	3800      	subs	r0, #0
 803101a:	bf18      	it	ne
 803101c:	2001      	movne	r0, #1
 803101e:	4240      	negs	r0, r0
 8031020:	e7e0      	b.n	8030fe4 <FragDecoderProcess+0x48>
        if( FragDecoder.Status.FragNbLost > FRAG_MAX_REDUNDANCY )
 8031022:	f8b6 3880 	ldrh.w	r3, [r6, #2176]	; 0x880
 8031026:	2b48      	cmp	r3, #72	; 0x48
 8031028:	d904      	bls.n	8031034 <FragDecoderProcess+0x98>
           FragDecoder.Status.MatrixError = 1;
 803102a:	2301      	movs	r3, #1
 803102c:	f886 3884 	strb.w	r3, [r6, #2180]	; 0x884
           return FRAG_SESSION_FINISHED;
 8031030:	2000      	movs	r0, #0
 8031032:	e7d7      	b.n	8030fe4 <FragDecoderProcess+0x48>
        FragFindMissingFrags( fragCounter );
 8031034:	4620      	mov	r0, r4
 8031036:	f7ff fef9 	bl	8030e2c <FragFindMissingFrags>
        if( FragDecoder.Status.FragNbLost == 0 )
 803103a:	f8b6 0880 	ldrh.w	r0, [r6, #2176]	; 0x880
 803103e:	2800      	cmp	r0, #0
 8031040:	d0d0      	beq.n	8030fe4 <FragDecoderProcess+0x48>
        FragGetParityMatrixRow( fragCounter - FragDecoder.FragNb, FragDecoder.FragNb, matrixRow );
 8031042:	f8b6 9004 	ldrh.w	r9, [r6, #4]
    if( IsPowerOfTwo( m ) != false )
 8031046:	2300      	movs	r3, #0
        FragGetParityMatrixRow( fragCounter - FragDecoder.FragNb, FragDecoder.FragNb, matrixRow );
 8031048:	eba4 0409 	sub.w	r4, r4, r9
    uint8_t sumBit = 0;
 803104c:	461e      	mov	r6, r3
        sumBit += ( x & ( 1 << i ) ) >> i;
 803104e:	2101      	movs	r1, #1
 8031050:	fa01 f203 	lsl.w	r2, r1, r3
 8031054:	ea02 0209 	and.w	r2, r2, r9
 8031058:	40da      	lsrs	r2, r3
 803105a:	3301      	adds	r3, #1
 803105c:	4416      	add	r6, r2
    for( uint8_t i = 0; i < 32; i++ )
 803105e:	2b20      	cmp	r3, #32
        sumBit += ( x & ( 1 << i ) ) >> i;
 8031060:	b2f6      	uxtb	r6, r6
    for( uint8_t i = 0; i < 32; i++ )
 8031062:	d1f5      	bne.n	8031050 <FragDecoderProcess+0xb4>
    if( sumBit == 1 )
 8031064:	1e73      	subs	r3, r6, #1
 8031066:	425e      	negs	r6, r3
    x = 1 + ( 1001 * n );
 8031068:	f240 30e9 	movw	r0, #1001	; 0x3e9
 803106c:	fb00 f404 	mul.w	r4, r0, r4
    if( sumBit == 1 )
 8031070:	415e      	adcs	r6, r3
    for( uint8_t i = 0; i < ( ( m >> 3 ) + 1 ); i++ )
 8031072:	2300      	movs	r3, #0
    x = 1 + ( 1001 * n );
 8031074:	3401      	adds	r4, #1
    for( uint8_t i = 0; i < ( ( m >> 3 ) + 1 ); i++ )
 8031076:	ea4f 02e9 	mov.w	r2, r9, asr #3
        matrixRow[i] = 0;
 803107a:	4618      	mov	r0, r3
 803107c:	a93c      	add	r1, sp, #240	; 0xf0
 803107e:	4419      	add	r1, r3
    for( uint8_t i = 0; i < ( ( m >> 3 ) + 1 ); i++ )
 8031080:	3301      	adds	r3, #1
 8031082:	b2db      	uxtb	r3, r3
 8031084:	429a      	cmp	r2, r3
        matrixRow[i] = 0;
 8031086:	f801 0cd4 	strb.w	r0, [r1, #-212]
    for( uint8_t i = 0; i < ( ( m >> 3 ) + 1 ); i++ )
 803108a:	daf7      	bge.n	803107c <FragDecoderProcess+0xe0>
    while( nbCoeff < ( m >> 1 ) )
 803108c:	ea4f 0b69 	mov.w	fp, r9, asr #1
    int32_t nbCoeff = 0;
 8031090:	f04f 0a00 	mov.w	sl, #0
            r = x % ( m + mTemp );
 8031094:	444e      	add	r6, r9
    while( nbCoeff < ( m >> 1 ) )
 8031096:	45da      	cmp	sl, fp
 8031098:	db0c      	blt.n	80310b4 <FragDecoderProcess+0x118>
        for( int32_t i = 0; i < FragDecoder.FragNb; i++ )
 803109a:	2600      	movs	r6, #0
    int32_t first = 0;
 803109c:	46b0      	mov	r8, r6
        for( int32_t i = 0; i < FragDecoder.FragNb; i++ )
 803109e:	88ab      	ldrh	r3, [r5, #4]
 80310a0:	42b3      	cmp	r3, r6
 80310a2:	dc28      	bgt.n	80310f6 <FragDecoderProcess+0x15a>
        firstOneInRow = BitArrayFindFirstOne( dataTempVector, FragDecoder.Status.FragNbLost );
 80310a4:	f8b5 6880 	ldrh.w	r6, [r5, #2176]	; 0x880
    for( uint16_t i = 0; i < size; i++)
 80310a8:	2200      	movs	r2, #0
 80310aa:	b294      	uxth	r4, r2
 80310ac:	42a6      	cmp	r6, r4
 80310ae:	d848      	bhi.n	8031142 <FragDecoderProcess+0x1a6>
    return 0;
 80310b0:	2400      	movs	r4, #0
 80310b2:	e04e      	b.n	8031152 <FragDecoderProcess+0x1b6>
    return ( value >> 1 ) + ( ( b0 ^ b1 ) << 22 );
 80310b4:	ea84 1364 	eor.w	r3, r4, r4, asr #5
 80310b8:	059b      	lsls	r3, r3, #22
 80310ba:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 80310be:	eb03 0464 	add.w	r4, r3, r4, asr #1
            r = x % ( m + mTemp );
 80310c2:	fb94 f8f6 	sdiv	r8, r4, r6
 80310c6:	fb06 4818 	mls	r8, r6, r8, r4
        while( r >= m )
 80310ca:	45c1      	cmp	r9, r8
 80310cc:	ddf2      	ble.n	80310b4 <FragDecoderProcess+0x118>
        if ((GetParity(r, matrixRow) == 0) || (LmhpFragmentationGetPackageVersion() == 1U))
 80310ce:	fa1f f888 	uxth.w	r8, r8
 80310d2:	a907      	add	r1, sp, #28
 80310d4:	4640      	mov	r0, r8
 80310d6:	f7ff fe65 	bl	8030da4 <GetParity>
 80310da:	b938      	cbnz	r0, 80310ec <FragDecoderProcess+0x150>
            SetParity(r, matrixRow, 1);
 80310dc:	2201      	movs	r2, #1
 80310de:	a907      	add	r1, sp, #28
 80310e0:	4640      	mov	r0, r8
 80310e2:	f7ff fe69 	bl	8030db8 <SetParity>
            nbCoeff += 1;
 80310e6:	f10a 0a01 	add.w	sl, sl, #1
 80310ea:	e7d4      	b.n	8031096 <FragDecoderProcess+0xfa>
        if ((GetParity(r, matrixRow) == 0) || (LmhpFragmentationGetPackageVersion() == 1U))
 80310ec:	f001 fbb8 	bl	8032860 <LmhpFragmentationGetPackageVersion>
 80310f0:	2801      	cmp	r0, #1
 80310f2:	d1d0      	bne.n	8031096 <FragDecoderProcess+0xfa>
 80310f4:	e7f2      	b.n	80310dc <FragDecoderProcess+0x140>
            if( GetParity( i , matrixRow ) == 1 )
 80310f6:	fa1f f986 	uxth.w	r9, r6
 80310fa:	a907      	add	r1, sp, #28
 80310fc:	4648      	mov	r0, r9
 80310fe:	f7ff fe51 	bl	8030da4 <GetParity>
 8031102:	2801      	cmp	r0, #1
 8031104:	4604      	mov	r4, r0
 8031106:	d112      	bne.n	803112e <FragDecoderProcess+0x192>
                if( FragDecoder.FragNbMissingIndex[i] == 0 )
 8031108:	eb05 0346 	add.w	r3, r5, r6, lsl #1
 803110c:	f8b3 22dc 	ldrh.w	r2, [r3, #732]	; 0x2dc
 8031110:	b97a      	cbnz	r2, 8031132 <FragDecoderProcess+0x196>
                    SetParity( i, matrixRow, 0 );
 8031112:	a907      	add	r1, sp, #28
 8031114:	4648      	mov	r0, r9
 8031116:	f7ff fe4f 	bl	8030db8 <SetParity>
                    GetRow( matrixDataTemp, i, FragDecoder.FragSize );
 803111a:	79aa      	ldrb	r2, [r5, #6]
 803111c:	4649      	mov	r1, r9
 803111e:	a81e      	add	r0, sp, #120	; 0x78
 8031120:	f7ff fe2e 	bl	8030d80 <GetRow>
                    XorDataLine( rawData, matrixDataTemp, FragDecoder.FragSize );
 8031124:	79aa      	ldrb	r2, [r5, #6]
 8031126:	a91e      	add	r1, sp, #120	; 0x78
 8031128:	4638      	mov	r0, r7
 803112a:	f7ff fe55 	bl	8030dd8 <XorDataLine>
        for( int32_t i = 0; i < FragDecoder.FragNb; i++ )
 803112e:	3601      	adds	r6, #1
 8031130:	e7b5      	b.n	803109e <FragDecoderProcess+0x102>
                    SetParity( FragDecoder.FragNbMissingIndex[i] - 1, dataTempVector, 1 );
 8031132:	1e50      	subs	r0, r2, #1
 8031134:	a901      	add	r1, sp, #4
 8031136:	4622      	mov	r2, r4
 8031138:	b280      	uxth	r0, r0
 803113a:	f7ff fe3d 	bl	8030db8 <SetParity>
                        first = 1;
 803113e:	46a0      	mov	r8, r4
 8031140:	e7f5      	b.n	803112e <FragDecoderProcess+0x192>
        if ( GetParity( i, bitArray ) == 1 )
 8031142:	a901      	add	r1, sp, #4
 8031144:	4620      	mov	r0, r4
 8031146:	f7ff fe2d 	bl	8030da4 <GetParity>
 803114a:	2801      	cmp	r0, #1
 803114c:	f102 0201 	add.w	r2, r2, #1
 8031150:	d1ab      	bne.n	80310aa <FragDecoderProcess+0x10e>
        if( first > 0 )
 8031152:	f1b8 0f00 	cmp.w	r8, #0
 8031156:	f43f af43 	beq.w	8030fe0 <FragDecoderProcess+0x44>
            while( GetParity( firstOneInRow, FragDecoder.S ) == 1 )
 803115a:	f8df 8150 	ldr.w	r8, [pc, #336]	; 80312ac <FragDecoderProcess+0x310>
 803115e:	4641      	mov	r1, r8
 8031160:	4620      	mov	r0, r4
 8031162:	f7ff fe1f 	bl	8030da4 <GetParity>
 8031166:	2801      	cmp	r0, #1
 8031168:	f8b5 2880 	ldrh.w	r2, [r5, #2176]	; 0x880
 803116c:	d004      	beq.n	8031178 <FragDecoderProcess+0x1dc>
static void FragPushLineToBinaryMatrix( uint8_t *bitArray, uint16_t rowIndex, uint16_t bitsInRow )
{
    uint32_t findByte = 0;
    uint32_t findBitInByte = 0;

    if ( rowIndex > 0) {
 803116e:	2c00      	cmp	r4, #0
 8031170:	d15b      	bne.n	803122a <FragDecoderProcess+0x28e>
    uint32_t findBitInByte = 0;
 8031172:	4626      	mov	r6, r4
    uint32_t findByte = 0;
 8031174:	46a1      	mov	r9, r4
 8031176:	e067      	b.n	8031248 <FragDecoderProcess+0x2ac>
                FragExtractLineFromBinaryMatrix( dataTempVector2, firstOneInRow, FragDecoder.Status.FragNbLost );
 8031178:	4621      	mov	r1, r4
 803117a:	a804      	add	r0, sp, #16
 803117c:	f7ff fe96 	bl	8030eac <FragExtractLineFromBinaryMatrix>
                XorParityLine( dataTempVector, dataTempVector2, FragDecoder.Status.FragNbLost );
 8031180:	f8b5 2880 	ldrh.w	r2, [r5, #2176]	; 0x880
 8031184:	a904      	add	r1, sp, #16
 8031186:	a801      	add	r0, sp, #4
 8031188:	f7ff fe33 	bl	8030df2 <XorParityLine>
                li = FragFindMissingIndex( firstOneInRow );
 803118c:	4620      	mov	r0, r4
 803118e:	f7ff fe77 	bl	8030e80 <FragFindMissingIndex>
                GetRow( matrixDataTemp, li, FragDecoder.FragSize );
 8031192:	79aa      	ldrb	r2, [r5, #6]
                li = FragFindMissingIndex( firstOneInRow );
 8031194:	4601      	mov	r1, r0
                GetRow( matrixDataTemp, li, FragDecoder.FragSize );
 8031196:	a81e      	add	r0, sp, #120	; 0x78
 8031198:	f7ff fdf2 	bl	8030d80 <GetRow>
                XorDataLine( rawData, matrixDataTemp, FragDecoder.FragSize );
 803119c:	79aa      	ldrb	r2, [r5, #6]
 803119e:	a91e      	add	r1, sp, #120	; 0x78
 80311a0:	4638      	mov	r0, r7
 80311a2:	f7ff fe19 	bl	8030dd8 <XorDataLine>
                if( BitArrayIsAllZeros( dataTempVector, FragDecoder.Status.FragNbLost ) )
 80311a6:	f8b5 6880 	ldrh.w	r6, [r5, #2176]	; 0x880
    for( uint16_t i = 0; i < size; i++ )
 80311aa:	2200      	movs	r2, #0
 80311ac:	b290      	uxth	r0, r2
 80311ae:	4286      	cmp	r6, r0
 80311b0:	d825      	bhi.n	80311fe <FragDecoderProcess+0x262>
            if( FragDecoder.M2BLine == FragDecoder.Status.FragNbLost )
 80311b2:	f8b5 3880 	ldrh.w	r3, [r5, #2176]	; 0x880
 80311b6:	68ac      	ldr	r4, [r5, #8]
 80311b8:	429c      	cmp	r4, r3
 80311ba:	f47f af11 	bne.w	8030fe0 <FragDecoderProcess+0x44>
                if( FragDecoder.Status.FragNbLost > 1 )
 80311be:	2c01      	cmp	r4, #1
 80311c0:	4620      	mov	r0, r4
 80311c2:	f67f af0f 	bls.w	8030fe4 <FragDecoderProcess+0x48>
                        GetRow( matrixDataTemp, li, FragDecoder.FragSize );
 80311c6:	4d38      	ldr	r5, [pc, #224]	; (80312a8 <FragDecoderProcess+0x30c>)
                    for( i = ( FragDecoder.Status.FragNbLost - 2 ); i >= 0 ; i-- )
 80311c8:	3c02      	subs	r4, #2
                        li = FragFindMissingIndex( i );
 80311ca:	fa1f fa84 	uxth.w	sl, r4
 80311ce:	4650      	mov	r0, sl
 80311d0:	f7ff fe56 	bl	8030e80 <FragFindMissingIndex>
                        GetRow( matrixDataTemp, li, FragDecoder.FragSize );
 80311d4:	79aa      	ldrb	r2, [r5, #6]
 80311d6:	4601      	mov	r1, r0
                        li = FragFindMissingIndex( i );
 80311d8:	4680      	mov	r8, r0
                        GetRow( matrixDataTemp, li, FragDecoder.FragSize );
 80311da:	a81e      	add	r0, sp, #120	; 0x78
 80311dc:	f7ff fdd0 	bl	8030d80 <GetRow>
                        for( j = ( FragDecoder.Status.FragNbLost - 1 ); j > i; j--)
 80311e0:	f8b5 6880 	ldrh.w	r6, [r5, #2176]	; 0x880
 80311e4:	3e01      	subs	r6, #1
 80311e6:	42a6      	cmp	r6, r4
 80311e8:	dc62      	bgt.n	80312b0 <FragDecoderProcess+0x314>
                        SetRow( matrixDataTemp, li, FragDecoder.FragSize );
 80311ea:	79aa      	ldrb	r2, [r5, #6]
 80311ec:	4641      	mov	r1, r8
 80311ee:	a81e      	add	r0, sp, #120	; 0x78
 80311f0:	f7ff fdb4 	bl	8030d5c <SetRow>
                    for( i = ( FragDecoder.Status.FragNbLost - 2 ); i >= 0 ; i-- )
 80311f4:	3c01      	subs	r4, #1
 80311f6:	d2e8      	bcs.n	80311ca <FragDecoderProcess+0x22e>
                    return FragDecoder.Status.FragNbLost;
 80311f8:	f8b5 0880 	ldrh.w	r0, [r5, #2176]	; 0x880
 80311fc:	e6f2      	b.n	8030fe4 <FragDecoderProcess+0x48>
        if( GetParity( i, bitArray ) == 1 )
 80311fe:	a901      	add	r1, sp, #4
 8031200:	f7ff fdd0 	bl	8030da4 <GetParity>
 8031204:	2801      	cmp	r0, #1
 8031206:	f102 0201 	add.w	r2, r2, #1
 803120a:	d1cf      	bne.n	80311ac <FragDecoderProcess+0x210>
 803120c:	2200      	movs	r2, #0
 803120e:	e007      	b.n	8031220 <FragDecoderProcess+0x284>
        if ( GetParity( i, bitArray ) == 1 )
 8031210:	a901      	add	r1, sp, #4
 8031212:	4620      	mov	r0, r4
 8031214:	f7ff fdc6 	bl	8030da4 <GetParity>
 8031218:	2801      	cmp	r0, #1
 803121a:	f102 0201 	add.w	r2, r2, #1
 803121e:	d09e      	beq.n	803115e <FragDecoderProcess+0x1c2>
 8031220:	b294      	uxth	r4, r2
    for( uint16_t i = 0; i < size; i++)
 8031222:	42a6      	cmp	r6, r4
 8031224:	d8f4      	bhi.n	8031210 <FragDecoderProcess+0x274>
    return 0;
 8031226:	2400      	movs	r4, #0
 8031228:	e799      	b.n	803115e <FragDecoderProcess+0x1c2>
        findByte      = ( rowIndex * bitsInRow - ( ( rowIndex * ( rowIndex - 1 ) ) >> 1 ) ) >> 3;
 803122a:	1e63      	subs	r3, r4, #1
 803122c:	4363      	muls	r3, r4
 803122e:	fb04 f602 	mul.w	r6, r4, r2
 8031232:	eba6 0663 	sub.w	r6, r6, r3, asr #1
        findBitInByte = ( rowIndex * bitsInRow - ( ( rowIndex * ( rowIndex - 1 ) ) >> 1 ) ) % 8;
 8031236:	4273      	negs	r3, r6
 8031238:	f003 0307 	and.w	r3, r3, #7
        findByte      = ( rowIndex * bitsInRow - ( ( rowIndex * ( rowIndex - 1 ) ) >> 1 ) ) >> 3;
 803123c:	ea4f 09e6 	mov.w	r9, r6, asr #3
        findBitInByte = ( rowIndex * bitsInRow - ( ( rowIndex * ( rowIndex - 1 ) ) >> 1 ) ) % 8;
 8031240:	f006 0607 	and.w	r6, r6, #7
 8031244:	bf58      	it	pl
 8031246:	425e      	negpl	r6, r3
    uint32_t findByte = 0;
 8031248:	46a0      	mov	r8, r4
    }
    for( uint16_t i = rowIndex; i < bitsInRow; i++ )
    {
        if( GetParity( i, bitArray ) == 0 )
        {
            FragDecoder.MatrixM2B[findByte] = FragDecoder.MatrixM2B[findByte] & ( 0xFF - ( 1 << ( 7 - findBitInByte ) ) );
 803124a:	f04f 0a01 	mov.w	sl, #1
 803124e:	e018      	b.n	8031282 <FragDecoderProcess+0x2e6>
        if( GetParity( i, bitArray ) == 0 )
 8031250:	a901      	add	r1, sp, #4
 8031252:	4640      	mov	r0, r8
 8031254:	f7ff fda6 	bl	8030da4 <GetParity>
 8031258:	b948      	cbnz	r0, 803126e <FragDecoderProcess+0x2d2>
            FragDecoder.MatrixM2B[findByte] = FragDecoder.MatrixM2B[findByte] & ( 0xFF - ( 1 << ( 7 - findBitInByte ) ) );
 803125a:	eb05 0309 	add.w	r3, r5, r9
 803125e:	f1c6 0107 	rsb	r1, r6, #7
 8031262:	fa0a f001 	lsl.w	r0, sl, r1
 8031266:	7b19      	ldrb	r1, [r3, #12]
 8031268:	ea21 0100 	bic.w	r1, r1, r0
 803126c:	7319      	strb	r1, [r3, #12]
        }
        findBitInByte++;
 803126e:	3601      	adds	r6, #1
        if( findBitInByte == 8 )
 8031270:	2e08      	cmp	r6, #8
    for( uint16_t i = rowIndex; i < bitsInRow; i++ )
 8031272:	f108 0801 	add.w	r8, r8, #1
        {
            findBitInByte = 0;
            findByte++;
 8031276:	bf04      	itt	eq
 8031278:	f109 0901 	addeq.w	r9, r9, #1
            findBitInByte = 0;
 803127c:	2600      	moveq	r6, #0
    for( uint16_t i = rowIndex; i < bitsInRow; i++ )
 803127e:	fa1f f888 	uxth.w	r8, r8
 8031282:	4542      	cmp	r2, r8
 8031284:	d8e4      	bhi.n	8031250 <FragDecoderProcess+0x2b4>
                li = FragFindMissingIndex( firstOneInRow );
 8031286:	4620      	mov	r0, r4
 8031288:	f7ff fdfa 	bl	8030e80 <FragFindMissingIndex>
                SetRow( rawData, li, FragDecoder.FragSize );
 803128c:	79aa      	ldrb	r2, [r5, #6]
                li = FragFindMissingIndex( firstOneInRow );
 803128e:	4601      	mov	r1, r0
                SetRow( rawData, li, FragDecoder.FragSize );
 8031290:	4638      	mov	r0, r7
 8031292:	f7ff fd63 	bl	8030d5c <SetRow>
                SetParity( firstOneInRow, FragDecoder.S, 1 );
 8031296:	4905      	ldr	r1, [pc, #20]	; (80312ac <FragDecoderProcess+0x310>)
 8031298:	2201      	movs	r2, #1
 803129a:	4620      	mov	r0, r4
 803129c:	f7ff fd8c 	bl	8030db8 <SetParity>
                FragDecoder.M2BLine++;
 80312a0:	68ab      	ldr	r3, [r5, #8]
 80312a2:	3301      	adds	r3, #1
 80312a4:	60ab      	str	r3, [r5, #8]
 80312a6:	e784      	b.n	80311b2 <FragDecoderProcess+0x216>
 80312a8:	20003f54 	.word	0x20003f54
 80312ac:	200047c8 	.word	0x200047c8
                            FragExtractLineFromBinaryMatrix( dataTempVector2, i, FragDecoder.Status.FragNbLost );
 80312b0:	f8b5 2880 	ldrh.w	r2, [r5, #2176]	; 0x880
 80312b4:	4651      	mov	r1, sl
 80312b6:	a804      	add	r0, sp, #16
 80312b8:	fa1f f986 	uxth.w	r9, r6
 80312bc:	f7ff fdf6 	bl	8030eac <FragExtractLineFromBinaryMatrix>
                            FragExtractLineFromBinaryMatrix( dataTempVector, j, FragDecoder.Status.FragNbLost );
 80312c0:	f8b5 2880 	ldrh.w	r2, [r5, #2176]	; 0x880
 80312c4:	4649      	mov	r1, r9
 80312c6:	a801      	add	r0, sp, #4
 80312c8:	f7ff fdf0 	bl	8030eac <FragExtractLineFromBinaryMatrix>
                            if( GetParity( j, dataTempVector2 ) == 1 )
 80312cc:	a904      	add	r1, sp, #16
 80312ce:	4648      	mov	r0, r9
 80312d0:	f7ff fd68 	bl	8030da4 <GetParity>
 80312d4:	2801      	cmp	r0, #1
 80312d6:	d185      	bne.n	80311e4 <FragDecoderProcess+0x248>
                                XorParityLine( dataTempVector2, dataTempVector, FragDecoder.Status.FragNbLost );
 80312d8:	f8b5 2880 	ldrh.w	r2, [r5, #2176]	; 0x880
 80312dc:	a901      	add	r1, sp, #4
 80312de:	a804      	add	r0, sp, #16
 80312e0:	f7ff fd87 	bl	8030df2 <XorParityLine>
                                lj = FragFindMissingIndex( j );
 80312e4:	4648      	mov	r0, r9
 80312e6:	f7ff fdcb 	bl	8030e80 <FragFindMissingIndex>
                                GetRow( rawData, lj, FragDecoder.FragSize );
 80312ea:	79aa      	ldrb	r2, [r5, #6]
                                lj = FragFindMissingIndex( j );
 80312ec:	4601      	mov	r1, r0
                                GetRow( rawData, lj, FragDecoder.FragSize );
 80312ee:	4638      	mov	r0, r7
 80312f0:	f7ff fd46 	bl	8030d80 <GetRow>
                                XorDataLine( matrixDataTemp , rawData , FragDecoder.FragSize );
 80312f4:	79aa      	ldrb	r2, [r5, #6]
 80312f6:	4639      	mov	r1, r7
 80312f8:	a81e      	add	r0, sp, #120	; 0x78
 80312fa:	f7ff fd6d 	bl	8030dd8 <XorDataLine>
 80312fe:	e771      	b.n	80311e4 <FragDecoderProcess+0x248>

08031300 <FragDecoderGetStatus>:
    return FragDecoder.Status;
 8031300:	4902      	ldr	r1, [pc, #8]	; (803130c <FragDecoderGetStatus+0xc>)
 8031302:	680a      	ldr	r2, [r1, #0]
 8031304:	6002      	str	r2, [r0, #0]
 8031306:	684a      	ldr	r2, [r1, #4]
 8031308:	6042      	str	r2, [r0, #4]
}
 803130a:	4770      	bx	lr
 803130c:	200047d2 	.word	0x200047d2

08031310 <LmHandlerDeviceTimeReq>:
        return LORAMAC_HANDLER_ERROR;
    }
}

LmHandlerErrorStatus_t LmHandlerDeviceTimeReq( void )
{
 8031310:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    LoRaMacStatus_t status;
    MlmeReq_t mlmeReq;

    mlmeReq.Type = MLME_DEVICE_TIME;
 8031312:	230a      	movs	r3, #10

    status = LoRaMacMlmeRequest( &mlmeReq );
 8031314:	a801      	add	r0, sp, #4
    mlmeReq.Type = MLME_DEVICE_TIME;
 8031316:	f88d 3004 	strb.w	r3, [sp, #4]
    status = LoRaMacMlmeRequest( &mlmeReq );
 803131a:	f004 f81b 	bl	8035354 <LoRaMacMlmeRequest>

    if( status == LORAMAC_STATUS_OK )
 803131e:	3800      	subs	r0, #0
 8031320:	bf18      	it	ne
 8031322:	2001      	movne	r0, #1
    }
    else
    {
        return LORAMAC_HANDLER_ERROR;
    }
}
 8031324:	4240      	negs	r0, r0
 8031326:	b007      	add	sp, #28
 8031328:	f85d fb04 	ldr.w	pc, [sp], #4

0803132c <McpsConfirm>:
 * LORAMAC NOTIFICATIONS HANDLING
 *=============================================================================
 */

static void McpsConfirm( McpsConfirm_t *mcpsConfirm )
{
 803132c:	b570      	push	{r4, r5, r6, lr}
    TxParams.IsMcpsConfirm = 1;
 803132e:	4c11      	ldr	r4, [pc, #68]	; (8031374 <McpsConfirm+0x48>)
 8031330:	2301      	movs	r3, #1
 8031332:	7023      	strb	r3, [r4, #0]
    TxParams.Status = mcpsConfirm->Status;
 8031334:	7843      	ldrb	r3, [r0, #1]
 8031336:	7063      	strb	r3, [r4, #1]
    TxParams.Datarate = mcpsConfirm->Datarate;
 8031338:	7883      	ldrb	r3, [r0, #2]
 803133a:	7123      	strb	r3, [r4, #4]
    TxParams.UplinkCounter = mcpsConfirm->UpLinkCounter;
 803133c:	68c3      	ldr	r3, [r0, #12]
 803133e:	60a3      	str	r3, [r4, #8]
    TxParams.TxPower = mcpsConfirm->TxPower;
 8031340:	78c3      	ldrb	r3, [r0, #3]
 8031342:	7523      	strb	r3, [r4, #20]
    TxParams.Channel = mcpsConfirm->Channel;
 8031344:	6903      	ldr	r3, [r0, #16]
 8031346:	7563      	strb	r3, [r4, #21]
    TxParams.AckReceived = mcpsConfirm->AckReceived;
 8031348:	7903      	ldrb	r3, [r0, #4]
 803134a:	70e3      	strb	r3, [r4, #3]

    LmHandlerCallbacks->OnTxData( &TxParams );
 803134c:	69a3      	ldr	r3, [r4, #24]
{
 803134e:	4605      	mov	r5, r0
    LmHandlerCallbacks->OnTxData( &TxParams );
 8031350:	6a1b      	ldr	r3, [r3, #32]
 8031352:	4620      	mov	r0, r4
 8031354:	4798      	blx	r3
    }
}

static void LmHandlerPackagesNotify( PackageNotifyTypes_t notifyType, void *params )
{
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 8031356:	341c      	adds	r4, #28
 8031358:	2600      	movs	r6, #0
    {
        if( LmHandlerPackages[i] != NULL )
 803135a:	f854 3b04 	ldr.w	r3, [r4], #4
 803135e:	b11b      	cbz	r3, 8031368 <McpsConfirm+0x3c>
        {
            switch( notifyType )
            {
                case PACKAGE_MCPS_CONFIRM:
                {
                    if( LmHandlerPackages[i]->OnMcpsConfirmProcess != NULL )
 8031360:	699b      	ldr	r3, [r3, #24]
 8031362:	b10b      	cbz	r3, 8031368 <McpsConfirm+0x3c>
                    {
                        LmHandlerPackages[i]->OnMcpsConfirmProcess( ( McpsConfirm_t* ) params );
 8031364:	4628      	mov	r0, r5
 8031366:	4798      	blx	r3
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 8031368:	3601      	adds	r6, #1
 803136a:	b2f3      	uxtb	r3, r6
 803136c:	2b05      	cmp	r3, #5
 803136e:	b276      	sxtb	r6, r6
 8031370:	d1f3      	bne.n	803135a <McpsConfirm+0x2e>
}
 8031372:	bd70      	pop	{r4, r5, r6, pc}
 8031374:	200047dc 	.word	0x200047dc

08031378 <LmHandlerConfigure>:
{
 8031378:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    UTIL_MEM_cpy_8((void *)&LmHandlerParams, (const void *)handlerParams, sizeof(LmHandlerParams_t));
 803137c:	4e63      	ldr	r6, [pc, #396]	; (803150c <LmHandlerConfigure+0x194>)
{
 803137e:	4601      	mov	r1, r0
    UTIL_MEM_cpy_8((void *)&LmHandlerParams, (const void *)handlerParams, sizeof(LmHandlerParams_t));
 8031380:	2210      	movs	r2, #16
{
 8031382:	b09e      	sub	sp, #120	; 0x78
    UTIL_MEM_cpy_8((void *)&LmHandlerParams, (const void *)handlerParams, sizeof(LmHandlerParams_t));
 8031384:	f106 0030 	add.w	r0, r6, #48	; 0x30
 8031388:	f009 fd94 	bl	803aeb4 <UTIL_MEM_cpy_8>
    loraInfo = LoraInfo_GetPtr();
 803138c:	f7fb fe16 	bl	802cfbc <LoraInfo_GetPtr>
    if (0U != ((1 << (LmHandlerParams.ActiveRegion)) & (loraInfo->Region)))
 8031390:	f896 2030 	ldrb.w	r2, [r6, #48]	; 0x30
 8031394:	6843      	ldr	r3, [r0, #4]
 8031396:	2701      	movs	r7, #1
 8031398:	fa07 f102 	lsl.w	r1, r7, r2
 803139c:	4019      	ands	r1, r3
 803139e:	d00a      	beq.n	80313b6 <LmHandlerConfigure+0x3e>
        if (LoRaMacInitialization(&LoRaMacPrimitives, &LoRaMacCallbacks, LmHandlerParams.ActiveRegion) != LORAMAC_STATUS_OK)
 80313a0:	f106 0140 	add.w	r1, r6, #64	; 0x40
 80313a4:	f106 0054 	add.w	r0, r6, #84	; 0x54
 80313a8:	f003 fa0c 	bl	80347c4 <LoRaMacInitialization>
 80313ac:	4605      	mov	r5, r0
 80313ae:	b140      	cbz	r0, 80313c2 <LmHandlerConfigure+0x4a>
            return LORAMAC_HANDLER_ERROR;
 80313b0:	f04f 30ff 	mov.w	r0, #4294967295
 80313b4:	e0a6      	b.n	8031504 <LmHandlerConfigure+0x18c>
        MW_LOG(TS_ON, VLEVEL_ALWAYS, "error: Region is not defined in the MW: set lorawan_conf.h accordingly\r\n");
 80313b6:	4b56      	ldr	r3, [pc, #344]	; (8031510 <LmHandlerConfigure+0x198>)
 80313b8:	463a      	mov	r2, r7
 80313ba:	4608      	mov	r0, r1
 80313bc:	f009 fc72 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
        while (1) {}  /* error: Region is not defined in the MW */
 80313c0:	e7fe      	b.n	80313c0 <LmHandlerConfigure+0x48>
    nbNvmData = NvmDataMgmtRestore( );
 80313c2:	f005 f977 	bl	80366b4 <NvmDataMgmtRestore>
    if( nbNvmData > 0 )
 80313c6:	3800      	subs	r0, #0
    memcpy1( CommissioningParams.DevEui, mibReq.Param.DevEui, 8 );
 80313c8:	4c52      	ldr	r4, [pc, #328]	; (8031514 <LmHandlerConfigure+0x19c>)
    if( nbNvmData > 0 )
 80313ca:	bf18      	it	ne
 80313cc:	2001      	movne	r0, #1
    mibReq.Type = MIB_DEV_EUI;
 80313ce:	f04f 0802 	mov.w	r8, #2
    if( nbNvmData > 0 )
 80313d2:	f886 0064 	strb.w	r0, [r6, #100]	; 0x64
    LoRaMacMibGetRequestConfirm( &mibReq );
 80313d6:	a80c      	add	r0, sp, #48	; 0x30
    mibReq.Type = MIB_DEV_EUI;
 80313d8:	f88d 8030 	strb.w	r8, [sp, #48]	; 0x30
    LoRaMacMibGetRequestConfirm( &mibReq );
 80313dc:	f003 fc12 	bl	8034c04 <LoRaMacMibGetRequestConfirm>
    memcpy1( CommissioningParams.DevEui, mibReq.Param.DevEui, 8 );
 80313e0:	990d      	ldr	r1, [sp, #52]	; 0x34
 80313e2:	2208      	movs	r2, #8
 80313e4:	4620      	mov	r0, r4
 80313e6:	f007 fd77 	bl	8038ed8 <memcpy1>
    mibReq.Type = MIB_JOIN_EUI;
 80313ea:	2303      	movs	r3, #3
    LoRaMacMibGetRequestConfirm( &mibReq );
 80313ec:	a80c      	add	r0, sp, #48	; 0x30
    mibReq.Type = MIB_JOIN_EUI;
 80313ee:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
    LoRaMacMibGetRequestConfirm( &mibReq );
 80313f2:	f003 fc07 	bl	8034c04 <LoRaMacMibGetRequestConfirm>
    memcpy1( CommissioningParams.JoinEui, mibReq.Param.JoinEui, 8 );
 80313f6:	2208      	movs	r2, #8
 80313f8:	18a0      	adds	r0, r4, r2
 80313fa:	990d      	ldr	r1, [sp, #52]	; 0x34
 80313fc:	f007 fd6c 	bl	8038ed8 <memcpy1>
    mibReq.Type = MIB_DEV_ADDR;
 8031400:	2306      	movs	r3, #6
 8031402:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
    LoRaMacMibSetRequestConfirm(&mibReq);
 8031406:	a80c      	add	r0, sp, #48	; 0x30
    mibReq.Param.DevAddr = CommissioningParams.DevAddr;
 8031408:	6963      	ldr	r3, [r4, #20]
 803140a:	930d      	str	r3, [sp, #52]	; 0x34
    LoRaMacMibSetRequestConfirm(&mibReq);
 803140c:	f003 fcb6 	bl	8034d7c <LoRaMacMibSetRequestConfirm>
    MW_LOG(TS_OFF, VLEVEL_M, "###### DevEui:  %02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\r\n",
 8031410:	79e3      	ldrb	r3, [r4, #7]
 8031412:	9307      	str	r3, [sp, #28]
 8031414:	79a3      	ldrb	r3, [r4, #6]
 8031416:	9306      	str	r3, [sp, #24]
 8031418:	7963      	ldrb	r3, [r4, #5]
 803141a:	9305      	str	r3, [sp, #20]
 803141c:	7923      	ldrb	r3, [r4, #4]
 803141e:	9304      	str	r3, [sp, #16]
 8031420:	78e3      	ldrb	r3, [r4, #3]
 8031422:	9303      	str	r3, [sp, #12]
 8031424:	78a3      	ldrb	r3, [r4, #2]
 8031426:	9302      	str	r3, [sp, #8]
 8031428:	7863      	ldrb	r3, [r4, #1]
 803142a:	9301      	str	r3, [sp, #4]
 803142c:	7823      	ldrb	r3, [r4, #0]
 803142e:	9300      	str	r3, [sp, #0]
 8031430:	462a      	mov	r2, r5
 8031432:	4b39      	ldr	r3, [pc, #228]	; (8031518 <LmHandlerConfigure+0x1a0>)
 8031434:	4629      	mov	r1, r5
 8031436:	4640      	mov	r0, r8
 8031438:	f009 fc34 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
    MW_LOG(TS_OFF, VLEVEL_M, "###### AppEui:  %02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\r\n",
 803143c:	7be3      	ldrb	r3, [r4, #15]
 803143e:	9307      	str	r3, [sp, #28]
 8031440:	7ba3      	ldrb	r3, [r4, #14]
 8031442:	9306      	str	r3, [sp, #24]
 8031444:	7b63      	ldrb	r3, [r4, #13]
 8031446:	9305      	str	r3, [sp, #20]
 8031448:	7b23      	ldrb	r3, [r4, #12]
 803144a:	9304      	str	r3, [sp, #16]
 803144c:	7ae3      	ldrb	r3, [r4, #11]
 803144e:	9303      	str	r3, [sp, #12]
 8031450:	7aa3      	ldrb	r3, [r4, #10]
 8031452:	9302      	str	r3, [sp, #8]
 8031454:	7a63      	ldrb	r3, [r4, #9]
 8031456:	9301      	str	r3, [sp, #4]
 8031458:	7a23      	ldrb	r3, [r4, #8]
 803145a:	9300      	str	r3, [sp, #0]
 803145c:	462a      	mov	r2, r5
 803145e:	4b2f      	ldr	r3, [pc, #188]	; (803151c <LmHandlerConfigure+0x1a4>)
 8031460:	4629      	mov	r1, r5
 8031462:	4640      	mov	r0, r8
 8031464:	f009 fc1e 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
    MW_LOG(TS_OFF, VLEVEL_M, "###### DevAddr: %02X:%02X:%02X:%02X\r\n",
 8031468:	7d23      	ldrb	r3, [r4, #20]
 803146a:	9303      	str	r3, [sp, #12]
 803146c:	7d63      	ldrb	r3, [r4, #21]
 803146e:	9302      	str	r3, [sp, #8]
 8031470:	7da3      	ldrb	r3, [r4, #22]
 8031472:	9301      	str	r3, [sp, #4]
 8031474:	7de3      	ldrb	r3, [r4, #23]
 8031476:	9300      	str	r3, [sp, #0]
 8031478:	462a      	mov	r2, r5
 803147a:	4b29      	ldr	r3, [pc, #164]	; (8031520 <LmHandlerConfigure+0x1a8>)
 803147c:	4629      	mov	r1, r5
 803147e:	4640      	mov	r0, r8
 8031480:	f009 fc10 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
    MW_LOG(TS_OFF, VLEVEL_L, "###### KMS ENABLED \r\n");
 8031484:	462a      	mov	r2, r5
 8031486:	4629      	mov	r1, r5
 8031488:	4b26      	ldr	r3, [pc, #152]	; (8031524 <LmHandlerConfigure+0x1ac>)
 803148a:	4638      	mov	r0, r7
 803148c:	f009 fc0a 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
    mibReq.Type = MIB_PUBLIC_NETWORK;
 8031490:	240f      	movs	r4, #15
    LoRaMacMibSetRequestConfirm(&mibReq);
 8031492:	a80c      	add	r0, sp, #48	; 0x30
    mibReq.Type = MIB_PUBLIC_NETWORK;
 8031494:	f88d 4030 	strb.w	r4, [sp, #48]	; 0x30
    mibReq.Param.EnablePublicNetwork = LORAWAN_PUBLIC_NETWORK;
 8031498:	f88d 7034 	strb.w	r7, [sp, #52]	; 0x34
    LoRaMacMibSetRequestConfirm(&mibReq);
 803149c:	f003 fc6e 	bl	8034d7c <LoRaMacMibSetRequestConfirm>
    mibReq.Type = MIB_NET_ID;
 80314a0:	2305      	movs	r3, #5
    LoRaMacMibSetRequestConfirm(&mibReq);
 80314a2:	a80c      	add	r0, sp, #48	; 0x30
    mibReq.Type = MIB_NET_ID;
 80314a4:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
    mibReq.Param.NetID = LORAWAN_NETWORK_ID;
 80314a8:	950d      	str	r5, [sp, #52]	; 0x34
    LoRaMacMibSetRequestConfirm(&mibReq);
 80314aa:	f003 fc67 	bl	8034d7c <LoRaMacMibSetRequestConfirm>
    mibReq.Type = MIB_REPEATER_SUPPORT;
 80314ae:	2310      	movs	r3, #16
    LoRaMacMibSetRequestConfirm( &mibReq );
 80314b0:	a80c      	add	r0, sp, #48	; 0x30
    mibReq.Type = MIB_REPEATER_SUPPORT;
 80314b2:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
    mibReq.Param.EnableRepeaterSupport = LORAWAN_REPEATER_SUPPORT;
 80314b6:	f88d 5034 	strb.w	r5, [sp, #52]	; 0x34
    LoRaMacMibSetRequestConfirm( &mibReq );
 80314ba:	f003 fc5f 	bl	8034d7c <LoRaMacMibSetRequestConfirm>
    mibReq.Type = MIB_ADR;
 80314be:	2304      	movs	r3, #4
 80314c0:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
    LoRaMacMibSetRequestConfirm( &mibReq );
 80314c4:	a80c      	add	r0, sp, #48	; 0x30
    mibReq.Param.AdrEnable = LmHandlerParams.AdrEnable;
 80314c6:	f896 3032 	ldrb.w	r3, [r6, #50]	; 0x32
 80314ca:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
    LoRaMacMibSetRequestConfirm( &mibReq );
 80314ce:	f003 fc55 	bl	8034d7c <LoRaMacMibSetRequestConfirm>
    phyParam = RegionGetPhyParam( LmHandlerParams.ActiveRegion, &getPhy );
 80314d2:	a90a      	add	r1, sp, #40	; 0x28
 80314d4:	f896 0030 	ldrb.w	r0, [r6, #48]	; 0x30
    getPhy.Attribute = PHY_DUTY_CYCLE;
 80314d8:	f88d 4028 	strb.w	r4, [sp, #40]	; 0x28
    phyParam = RegionGetPhyParam( LmHandlerParams.ActiveRegion, &getPhy );
 80314dc:	f005 f8f5 	bl	80366ca <RegionGetPhyParam>
    LmHandlerParams.DutyCycleEnabled = (bool) phyParam.Value;
 80314e0:	3800      	subs	r0, #0
 80314e2:	bf18      	it	ne
 80314e4:	2001      	movne	r0, #1
    mibReq.Type = MIB_SYSTEM_MAX_RX_ERROR;
 80314e6:	2322      	movs	r3, #34	; 0x22
    LmHandlerParams.DutyCycleEnabled = (bool) phyParam.Value;
 80314e8:	f886 0035 	strb.w	r0, [r6, #53]	; 0x35
    mibReq.Type = MIB_SYSTEM_MAX_RX_ERROR;
 80314ec:	f88d 3054 	strb.w	r3, [sp, #84]	; 0x54
    if( LoRaMacMibSetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 80314f0:	a815      	add	r0, sp, #84	; 0x54
    mibReq.Param.SystemMaxRxError = maxErrorInMs;
 80314f2:	2314      	movs	r3, #20
 80314f4:	9316      	str	r3, [sp, #88]	; 0x58
    if( LoRaMacMibSetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 80314f6:	f003 fc41 	bl	8034d7c <LoRaMacMibSetRequestConfirm>
    LoRaMacTestSetDutyCycleOn( LmHandlerParams.DutyCycleEnabled );
 80314fa:	f896 0035 	ldrb.w	r0, [r6, #53]	; 0x35
 80314fe:	f004 f9a1 	bl	8035844 <LoRaMacTestSetDutyCycleOn>
    return LORAMAC_HANDLER_SUCCESS;
 8031502:	4628      	mov	r0, r5
}
 8031504:	b01e      	add	sp, #120	; 0x78
 8031506:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 803150a:	bf00      	nop
 803150c:	200047dc 	.word	0x200047dc
 8031510:	0803c0b8 	.word	0x0803c0b8
 8031514:	20003458 	.word	0x20003458
 8031518:	0803c101 	.word	0x0803c101
 803151c:	0803c13b 	.word	0x0803c13b
 8031520:	0803c175 	.word	0x0803c175
 8031524:	0803c19b 	.word	0x0803c19b

08031528 <LmHandlerProcess>:
{
 8031528:	b538      	push	{r3, r4, r5, lr}
    LoRaMacProcess( );
 803152a:	f002 fc89 	bl	8033e40 <LoRaMacProcess>
    }
}

static void LmHandlerPackagesProcess( void )
{
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 803152e:	4d0c      	ldr	r5, [pc, #48]	; (8031560 <LmHandlerProcess+0x38>)
    LoRaMacProcess( );
 8031530:	2405      	movs	r4, #5
    {
        if( ( LmHandlerPackages[i] != NULL ) &&
 8031532:	f855 3b04 	ldr.w	r3, [r5], #4
 8031536:	b15b      	cbz	r3, 8031550 <LmHandlerProcess+0x28>
 8031538:	691b      	ldr	r3, [r3, #16]
 803153a:	b14b      	cbz	r3, 8031550 <LmHandlerProcess+0x28>
    if (( id < PKG_MAX_NUMBER ) && ( LmHandlerPackages[id]->IsInitialized != NULL ))
 803153c:	f855 3c04 	ldr.w	r3, [r5, #-4]
 8031540:	689b      	ldr	r3, [r3, #8]
 8031542:	b12b      	cbz	r3, 8031550 <LmHandlerProcess+0x28>
        return LmHandlerPackages[id]->IsInitialized( );
 8031544:	4798      	blx	r3
            ( LmHandlerPackages[i]->Process != NULL ) &&
 8031546:	b118      	cbz	r0, 8031550 <LmHandlerProcess+0x28>
            ( LmHandlerPackageIsInitialized( i ) != false ) )
        {
            LmHandlerPackages[i]->Process( );
 8031548:	f855 3c04 	ldr.w	r3, [r5, #-4]
 803154c:	691b      	ldr	r3, [r3, #16]
 803154e:	4798      	blx	r3
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 8031550:	3c01      	subs	r4, #1
 8031552:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
 8031556:	d1ec      	bne.n	8031532 <LmHandlerProcess+0xa>
}
 8031558:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    NvmDataMgmtStore( );
 803155c:	f005 b8a8 	b.w	80366b0 <NvmDataMgmtStore>
 8031560:	200047f8 	.word	0x200047f8

08031564 <LmHandlerJoinStatus>:
{
 8031564:	b500      	push	{lr}
 8031566:	b08b      	sub	sp, #44	; 0x2c
    mibReq.Type = MIB_NETWORK_ACTIVATION;
 8031568:	2301      	movs	r3, #1
    status = LoRaMacMibGetRequestConfirm( &mibReq );
 803156a:	a801      	add	r0, sp, #4
    mibReq.Type = MIB_NETWORK_ACTIVATION;
 803156c:	f88d 3004 	strb.w	r3, [sp, #4]
    status = LoRaMacMibGetRequestConfirm( &mibReq );
 8031570:	f003 fb48 	bl	8034c04 <LoRaMacMibGetRequestConfirm>
    if( status == LORAMAC_STATUS_OK )
 8031574:	b938      	cbnz	r0, 8031586 <LmHandlerJoinStatus+0x22>
        if( mibReq.Param.NetworkActivation == ACTIVATION_TYPE_NONE )
 8031576:	f89d 0008 	ldrb.w	r0, [sp, #8]
            return LORAMAC_HANDLER_RESET;
 803157a:	3800      	subs	r0, #0
 803157c:	bf18      	it	ne
 803157e:	2001      	movne	r0, #1
}
 8031580:	b00b      	add	sp, #44	; 0x2c
 8031582:	f85d fb04 	ldr.w	pc, [sp], #4
        return LORAMAC_HANDLER_RESET;
 8031586:	2000      	movs	r0, #0
 8031588:	e7fa      	b.n	8031580 <LmHandlerJoinStatus+0x1c>
	...

0803158c <LmHandlerRequestClass>:
{
 803158c:	b530      	push	{r4, r5, lr}
 803158e:	b08d      	sub	sp, #52	; 0x34
 8031590:	4605      	mov	r5, r0
    if (LoRaMacIsBusy() == true)
 8031592:	f002 fc47 	bl	8033e24 <LoRaMacIsBusy>
 8031596:	4604      	mov	r4, r0
 8031598:	2800      	cmp	r0, #0
 803159a:	d14a      	bne.n	8031632 <LmHandlerRequestClass+0xa6>
    if (LmHandlerJoinStatus() != LORAMAC_HANDLER_SET)
 803159c:	f7ff ffe2 	bl	8031564 <LmHandlerJoinStatus>
 80315a0:	2801      	cmp	r0, #1
 80315a2:	d149      	bne.n	8031638 <LmHandlerRequestClass+0xac>
    if ( LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 80315a4:	a803      	add	r0, sp, #12
    mibReq.Type = MIB_DEVICE_CLASS;
 80315a6:	f88d 400c 	strb.w	r4, [sp, #12]
    if ( LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 80315aa:	f003 fb2b 	bl	8034c04 <LoRaMacMibGetRequestConfirm>
 80315ae:	b110      	cbz	r0, 80315b6 <LmHandlerRequestClass+0x2a>
        switch( newClass )
 80315b0:	f04f 30ff 	mov.w	r0, #4294967295
 80315b4:	e004      	b.n	80315c0 <LmHandlerRequestClass+0x34>
    currentClass = mibReq.Param.Class;
 80315b6:	f89d 3010 	ldrb.w	r3, [sp, #16]
    if( currentClass != newClass )
 80315ba:	42ab      	cmp	r3, r5
 80315bc:	d102      	bne.n	80315c4 <LmHandlerRequestClass+0x38>
    LmHandlerErrorStatus_t errorStatus = LORAMAC_HANDLER_SUCCESS;
 80315be:	2000      	movs	r0, #0
}
 80315c0:	b00d      	add	sp, #52	; 0x34
 80315c2:	bd30      	pop	{r4, r5, pc}
        switch( newClass )
 80315c4:	2d01      	cmp	r5, #1
 80315c6:	d0f3      	beq.n	80315b0 <LmHandlerRequestClass+0x24>
 80315c8:	2d02      	cmp	r5, #2
 80315ca:	d01a      	beq.n	8031602 <LmHandlerRequestClass+0x76>
 80315cc:	2d00      	cmp	r5, #0
 80315ce:	d1f7      	bne.n	80315c0 <LmHandlerRequestClass+0x34>
                if( currentClass != CLASS_A )
 80315d0:	2b00      	cmp	r3, #0
 80315d2:	d0f4      	beq.n	80315be <LmHandlerRequestClass+0x32>
                    if( LoRaMacMibSetRequestConfirm( &mibReq ) == LORAMAC_STATUS_OK )
 80315d4:	a803      	add	r0, sp, #12
                    mibReq.Param.Class = newClass;
 80315d6:	f88d 5010 	strb.w	r5, [sp, #16]
                    if( LoRaMacMibSetRequestConfirm( &mibReq ) == LORAMAC_STATUS_OK )
 80315da:	f003 fbcf 	bl	8034d7c <LoRaMacMibSetRequestConfirm>
 80315de:	4602      	mov	r2, r0
 80315e0:	2800      	cmp	r0, #0
 80315e2:	d1e5      	bne.n	80315b0 <LmHandlerRequestClass+0x24>
    }
}

static void DisplayClassUpdate(DeviceClass_t deviceClass)
{
    MW_LOG(TS_OFF, VLEVEL_M, "Switch to Class %c done\r\n", "ABC"[deviceClass]);
 80315e4:	2341      	movs	r3, #65	; 0x41
 80315e6:	9300      	str	r3, [sp, #0]
 80315e8:	4601      	mov	r1, r0
 80315ea:	4b15      	ldr	r3, [pc, #84]	; (8031640 <LmHandlerRequestClass+0xb4>)
 80315ec:	2002      	movs	r0, #2
 80315ee:	f009 fb59 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
                        if (LmHandlerCallbacks->OnClassChange != NULL)
 80315f2:	4b14      	ldr	r3, [pc, #80]	; (8031644 <LmHandlerRequestClass+0xb8>)
 80315f4:	699b      	ldr	r3, [r3, #24]
 80315f6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80315f8:	2b00      	cmp	r3, #0
 80315fa:	d0e0      	beq.n	80315be <LmHandlerRequestClass+0x32>
                            LmHandlerCallbacks->OnClassChange( newClass );
 80315fc:	2000      	movs	r0, #0
 80315fe:	4798      	blx	r3
 8031600:	e7dd      	b.n	80315be <LmHandlerRequestClass+0x32>
                if( currentClass != CLASS_A )
 8031602:	2b00      	cmp	r3, #0
 8031604:	d1d4      	bne.n	80315b0 <LmHandlerRequestClass+0x24>
                    if (LoRaMacMibSetRequestConfirm( &mibReq ) == LORAMAC_STATUS_OK)
 8031606:	a803      	add	r0, sp, #12
                    mibReq.Param.Class = newClass;
 8031608:	f88d 5010 	strb.w	r5, [sp, #16]
                    if (LoRaMacMibSetRequestConfirm( &mibReq ) == LORAMAC_STATUS_OK)
 803160c:	f003 fbb6 	bl	8034d7c <LoRaMacMibSetRequestConfirm>
 8031610:	2800      	cmp	r0, #0
 8031612:	d1cd      	bne.n	80315b0 <LmHandlerRequestClass+0x24>
    MW_LOG(TS_OFF, VLEVEL_M, "Switch to Class %c done\r\n", "ABC"[deviceClass]);
 8031614:	2343      	movs	r3, #67	; 0x43
 8031616:	9300      	str	r3, [sp, #0]
 8031618:	4602      	mov	r2, r0
 803161a:	4b09      	ldr	r3, [pc, #36]	; (8031640 <LmHandlerRequestClass+0xb4>)
 803161c:	4601      	mov	r1, r0
 803161e:	4628      	mov	r0, r5
 8031620:	f009 fb40 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
                        if (LmHandlerCallbacks->OnClassChange != NULL)
 8031624:	4b07      	ldr	r3, [pc, #28]	; (8031644 <LmHandlerRequestClass+0xb8>)
 8031626:	699b      	ldr	r3, [r3, #24]
 8031628:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 803162a:	2b00      	cmp	r3, #0
 803162c:	d0c7      	beq.n	80315be <LmHandlerRequestClass+0x32>
                            LmHandlerCallbacks->OnClassChange( newClass );
 803162e:	4628      	mov	r0, r5
 8031630:	e7e5      	b.n	80315fe <LmHandlerRequestClass+0x72>
        return LORAMAC_HANDLER_BUSY_ERROR;
 8031632:	f06f 0001 	mvn.w	r0, #1
 8031636:	e7c3      	b.n	80315c0 <LmHandlerRequestClass+0x34>
        return LORAMAC_HANDLER_NO_NETWORK_JOINED;
 8031638:	f06f 0002 	mvn.w	r0, #2
 803163c:	e7c0      	b.n	80315c0 <LmHandlerRequestClass+0x34>
 803163e:	bf00      	nop
 8031640:	0803c1b1 	.word	0x0803c1b1
 8031644:	200047dc 	.word	0x200047dc

08031648 <LmHandlerJoin>:
{
 8031648:	b530      	push	{r4, r5, lr}
    if ( mode == ACTIVATION_TYPE_OTAA )
 803164a:	2802      	cmp	r0, #2
 803164c:	4b1f      	ldr	r3, [pc, #124]	; (80316cc <LmHandlerJoin+0x84>)
 803164e:	4c20      	ldr	r4, [pc, #128]	; (80316d0 <LmHandlerJoin+0x88>)
{
 8031650:	b08b      	sub	sp, #44	; 0x2c
 8031652:	f04f 0501 	mov.w	r5, #1
    if ( mode == ACTIVATION_TYPE_OTAA )
 8031656:	d10d      	bne.n	8031674 <LmHandlerJoin+0x2c>
        JoinParams.Mode = ACTIVATION_TYPE_OTAA;
 8031658:	7698      	strb	r0, [r3, #26]
        LoRaMacStart();
 803165a:	f003 fa73 	bl	8034b44 <LoRaMacStart>
        mlmeReq.Req.Join.Datarate = LmHandlerParams.TxDatarate;
 803165e:	f894 3033 	ldrb.w	r3, [r4, #51]	; 0x33
        mlmeReq.Type = MLME_JOIN;
 8031662:	f88d 5004 	strb.w	r5, [sp, #4]
        LoRaMacMlmeRequest( &mlmeReq );
 8031666:	a801      	add	r0, sp, #4
        mlmeReq.Req.Join.Datarate = LmHandlerParams.TxDatarate;
 8031668:	f88d 3008 	strb.w	r3, [sp, #8]
        LoRaMacMlmeRequest( &mlmeReq );
 803166c:	f003 fe72 	bl	8035354 <LoRaMacMlmeRequest>
}
 8031670:	b00b      	add	sp, #44	; 0x2c
 8031672:	bd30      	pop	{r4, r5, pc}
        JoinParams.Datarate = LmHandlerParams.TxDatarate;
 8031674:	f894 2033 	ldrb.w	r2, [r4, #51]	; 0x33
 8031678:	761a      	strb	r2, [r3, #24]
        JoinParams.Status = LORAMAC_HANDLER_SUCCESS;
 803167a:	2200      	movs	r2, #0
        JoinParams.Mode = ACTIVATION_TYPE_ABP;
 803167c:	769d      	strb	r5, [r3, #26]
        JoinParams.Status = LORAMAC_HANDLER_SUCCESS;
 803167e:	765a      	strb	r2, [r3, #25]
        if (CtxRestoreDone == false)
 8031680:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
 8031684:	b97b      	cbnz	r3, 80316a6 <LmHandlerJoin+0x5e>
            mibReq.Type = MIB_ABP_LORAWAN_VERSION;
 8031686:	2327      	movs	r3, #39	; 0x27
 8031688:	f88d 3004 	strb.w	r3, [sp, #4]
            LoRaMacMibSetRequestConfirm(&mibReq);
 803168c:	a801      	add	r0, sp, #4
            mibReq.Param.AbpLrWanVersion.Value = ABP_ACTIVATION_LRWAN_VERSION;
 803168e:	4b11      	ldr	r3, [pc, #68]	; (80316d4 <LmHandlerJoin+0x8c>)
 8031690:	9302      	str	r3, [sp, #8]
            LoRaMacMibSetRequestConfirm(&mibReq);
 8031692:	f003 fb73 	bl	8034d7c <LoRaMacMibSetRequestConfirm>
            SecureElementSetObjHandler(NWK_S_KEY, KMS_NWK_S_KEY_OBJECT_HANDLE);
 8031696:	2110      	movs	r1, #16
 8031698:	2002      	movs	r0, #2
 803169a:	f007 f8e3 	bl	8038864 <SecureElementSetObjHandler>
            SecureElementSetObjHandler(APP_S_KEY, KMS_APP_S_KEY_OBJECT_HANDLE);
 803169e:	2111      	movs	r1, #17
 80316a0:	2003      	movs	r0, #3
 80316a2:	f007 f8df 	bl	8038864 <SecureElementSetObjHandler>
        LoRaMacStart();
 80316a6:	f003 fa4d 	bl	8034b44 <LoRaMacStart>
        mibReq.Type = MIB_NETWORK_ACTIVATION;
 80316aa:	2301      	movs	r3, #1
        LoRaMacMibSetRequestConfirm( &mibReq );
 80316ac:	a801      	add	r0, sp, #4
        mibReq.Type = MIB_NETWORK_ACTIVATION;
 80316ae:	f88d 3004 	strb.w	r3, [sp, #4]
        mibReq.Param.NetworkActivation = ACTIVATION_TYPE_ABP;
 80316b2:	f88d 3008 	strb.w	r3, [sp, #8]
        LoRaMacMibSetRequestConfirm( &mibReq );
 80316b6:	f003 fb61 	bl	8034d7c <LoRaMacMibSetRequestConfirm>
        LmHandlerCallbacks->OnJoinRequest( &JoinParams );
 80316ba:	69a3      	ldr	r3, [r4, #24]
 80316bc:	4806      	ldr	r0, [pc, #24]	; (80316d8 <LmHandlerJoin+0x90>)
 80316be:	69db      	ldr	r3, [r3, #28]
 80316c0:	4798      	blx	r3
        LmHandlerRequestClass(LmHandlerParams.DefaultClass);
 80316c2:	f894 0031 	ldrb.w	r0, [r4, #49]	; 0x31
 80316c6:	f7ff ff61 	bl	803158c <LmHandlerRequestClass>
}
 80316ca:	e7d1      	b.n	8031670 <LmHandlerJoin+0x28>
 80316cc:	20003458 	.word	0x20003458
 80316d0:	200047dc 	.word	0x200047dc
 80316d4:	01000300 	.word	0x01000300
 80316d8:	20003470 	.word	0x20003470

080316dc <LmHandlerIsBusy>:
{
 80316dc:	b510      	push	{r4, lr}
    if( LoRaMacIsBusy( ) == true )
 80316de:	f002 fba1 	bl	8033e24 <LoRaMacIsBusy>
 80316e2:	b940      	cbnz	r0, 80316f6 <LmHandlerIsBusy+0x1a>
    if( LmHandlerJoinStatus( ) != LORAMAC_HANDLER_SET )
 80316e4:	f7ff ff3e 	bl	8031564 <LmHandlerJoinStatus>
 80316e8:	2801      	cmp	r0, #1
 80316ea:	d005      	beq.n	80316f8 <LmHandlerIsBusy+0x1c>
        LmHandlerJoin( JoinParams.Mode );
 80316ec:	4b05      	ldr	r3, [pc, #20]	; (8031704 <LmHandlerIsBusy+0x28>)
 80316ee:	7e98      	ldrb	r0, [r3, #26]
 80316f0:	f7ff ffaa 	bl	8031648 <LmHandlerJoin>
        return true;
 80316f4:	2001      	movs	r0, #1
}
 80316f6:	bd10      	pop	{r4, pc}
    if( LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->IsRunning( ) == true )
 80316f8:	4b03      	ldr	r3, [pc, #12]	; (8031708 <LmHandlerIsBusy+0x2c>)
 80316fa:	69db      	ldr	r3, [r3, #28]
}
 80316fc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    if( LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->IsRunning( ) == true )
 8031700:	68db      	ldr	r3, [r3, #12]
 8031702:	4718      	bx	r3
 8031704:	20003458 	.word	0x20003458
 8031708:	200047dc 	.word	0x200047dc

0803170c <LmHandlerSend>:
{
 803170c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8031710:	b087      	sub	sp, #28
 8031712:	4604      	mov	r4, r0
 8031714:	460e      	mov	r6, r1
 8031716:	4617      	mov	r7, r2
 8031718:	4698      	mov	r8, r3
    if (LoRaMacIsBusy() == true)
 803171a:	f002 fb83 	bl	8033e24 <LoRaMacIsBusy>
 803171e:	2800      	cmp	r0, #0
 8031720:	d154      	bne.n	80317cc <LmHandlerSend+0xc0>
    if( LmHandlerJoinStatus( ) != LORAMAC_HANDLER_SET )
 8031722:	f7ff ff1f 	bl	8031564 <LmHandlerJoinStatus>
 8031726:	2801      	cmp	r0, #1
 8031728:	d008      	beq.n	803173c <LmHandlerSend+0x30>
        LmHandlerJoin(JoinParams.Mode);
 803172a:	4b2d      	ldr	r3, [pc, #180]	; (80317e0 <LmHandlerSend+0xd4>)
 803172c:	7e98      	ldrb	r0, [r3, #26]
 803172e:	f7ff ff8b 	bl	8031648 <LmHandlerJoin>
        return LORAMAC_HANDLER_NO_NETWORK_JOINED;
 8031732:	f06f 0002 	mvn.w	r0, #2
}
 8031736:	b007      	add	sp, #28
 8031738:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if( ( LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->IsRunning( ) == true ) && ( appData->Port != LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->Port ) && ( appData->Port != 0 ) )
 803173c:	f8df 90ac 	ldr.w	r9, [pc, #172]	; 80317ec <LmHandlerSend+0xe0>
 8031740:	f8d9 301c 	ldr.w	r3, [r9, #28]
 8031744:	68db      	ldr	r3, [r3, #12]
 8031746:	4798      	blx	r3
 8031748:	464d      	mov	r5, r9
 803174a:	b138      	cbz	r0, 803175c <LmHandlerSend+0x50>
 803174c:	f8d9 201c 	ldr.w	r2, [r9, #28]
 8031750:	7823      	ldrb	r3, [r4, #0]
 8031752:	7812      	ldrb	r2, [r2, #0]
 8031754:	429a      	cmp	r2, r3
 8031756:	d001      	beq.n	803175c <LmHandlerSend+0x50>
 8031758:	2b00      	cmp	r3, #0
 803175a:	d13a      	bne.n	80317d2 <LmHandlerSend+0xc6>
    mcpsReq.Req.Unconfirmed.Datarate = LmHandlerParams.TxDatarate;
 803175c:	f895 3033 	ldrb.w	r3, [r5, #51]	; 0x33
    if( LoRaMacQueryTxPossible( appData->BufferSize, &txInfo ) != LORAMAC_STATUS_OK )
 8031760:	7860      	ldrb	r0, [r4, #1]
    mcpsReq.Req.Unconfirmed.Datarate = LmHandlerParams.TxDatarate;
 8031762:	f88d 3012 	strb.w	r3, [sp, #18]
    if( LoRaMacQueryTxPossible( appData->BufferSize, &txInfo ) != LORAMAC_STATUS_OK )
 8031766:	4669      	mov	r1, sp
 8031768:	f003 f9f4 	bl	8034b54 <LoRaMacQueryTxPossible>
 803176c:	b1d0      	cbz	r0, 80317a4 <LmHandlerSend+0x98>
        TxParams.MsgType = LORAMAC_HANDLER_UNCONFIRMED_MSG;
 803176e:	2200      	movs	r2, #0
 8031770:	70aa      	strb	r2, [r5, #2]
        mcpsReq.Type = MCPS_UNCONFIRMED;
 8031772:	f88d 2004 	strb.w	r2, [sp, #4]
        mcpsReq.Req.Unconfirmed.fBuffer = NULL;
 8031776:	9203      	str	r2, [sp, #12]
        mcpsReq.Req.Unconfirmed.fBufferSize = 0;
 8031778:	f8ad 2010 	strh.w	r2, [sp, #16]
    TxParams.AppData = *appData;
 803177c:	e894 0003 	ldmia.w	r4, {r0, r1}
 8031780:	4b18      	ldr	r3, [pc, #96]	; (80317e4 <LmHandlerSend+0xd8>)
 8031782:	e883 0003 	stmia.w	r3, {r0, r1}
    TxParams.Datarate = LmHandlerParams.TxDatarate;
 8031786:	f895 3033 	ldrb.w	r3, [r5, #51]	; 0x33
 803178a:	712b      	strb	r3, [r5, #4]
    status = LoRaMacMcpsRequest(&mcpsReq, allowDelayedTx);
 803178c:	4641      	mov	r1, r8
 803178e:	a801      	add	r0, sp, #4
 8031790:	f003 fed2 	bl	8035538 <LoRaMacMcpsRequest>
    if (nextTxIn != NULL)
 8031794:	b10f      	cbz	r7, 803179a <LmHandlerSend+0x8e>
        *nextTxIn = mcpsReq.ReqReturn.DutyCycleWaitTime;
 8031796:	9b05      	ldr	r3, [sp, #20]
 8031798:	603b      	str	r3, [r7, #0]
    switch (status)
 803179a:	2811      	cmp	r0, #17
 803179c:	d81c      	bhi.n	80317d8 <LmHandlerSend+0xcc>
 803179e:	4b12      	ldr	r3, [pc, #72]	; (80317e8 <LmHandlerSend+0xdc>)
 80317a0:	5618      	ldrsb	r0, [r3, r0]
 80317a2:	e7c8      	b.n	8031736 <LmHandlerSend+0x2a>
        TxParams.MsgType = isTxConfirmed;
 80317a4:	70ae      	strb	r6, [r5, #2]
        mcpsReq.Req.Unconfirmed.fPort = appData->Port;
 80317a6:	7823      	ldrb	r3, [r4, #0]
 80317a8:	f88d 3008 	strb.w	r3, [sp, #8]
        mcpsReq.Req.Unconfirmed.fBufferSize = appData->BufferSize;
 80317ac:	7863      	ldrb	r3, [r4, #1]
 80317ae:	f8ad 3010 	strh.w	r3, [sp, #16]
        mcpsReq.Req.Unconfirmed.fBuffer = appData->Buffer;
 80317b2:	6863      	ldr	r3, [r4, #4]
 80317b4:	9303      	str	r3, [sp, #12]
        if( isTxConfirmed == LORAMAC_HANDLER_UNCONFIRMED_MSG )
 80317b6:	b916      	cbnz	r6, 80317be <LmHandlerSend+0xb2>
            mcpsReq.Type = MCPS_UNCONFIRMED;
 80317b8:	f88d 6004 	strb.w	r6, [sp, #4]
 80317bc:	e7de      	b.n	803177c <LmHandlerSend+0x70>
            mcpsReq.Type = MCPS_CONFIRMED;
 80317be:	2301      	movs	r3, #1
 80317c0:	f88d 3004 	strb.w	r3, [sp, #4]
            mcpsReq.Req.Confirmed.NbTrials = 8;
 80317c4:	2308      	movs	r3, #8
 80317c6:	f88d 3013 	strb.w	r3, [sp, #19]
 80317ca:	e7d7      	b.n	803177c <LmHandlerSend+0x70>
        return LORAMAC_HANDLER_BUSY_ERROR;
 80317cc:	f06f 0001 	mvn.w	r0, #1
 80317d0:	e7b1      	b.n	8031736 <LmHandlerSend+0x2a>
        return LORAMAC_HANDLER_COMPLIANCE_RUNNING;
 80317d2:	f06f 0003 	mvn.w	r0, #3
 80317d6:	e7ae      	b.n	8031736 <LmHandlerSend+0x2a>
 80317d8:	f04f 30ff 	mov.w	r0, #4294967295
 80317dc:	e7ab      	b.n	8031736 <LmHandlerSend+0x2a>
 80317de:	bf00      	nop
 80317e0:	20003458 	.word	0x20003458
 80317e4:	200047e8 	.word	0x200047e8
 80317e8:	0803ba50 	.word	0x0803ba50
 80317ec:	200047dc 	.word	0x200047dc

080317f0 <MlmeIndication>:
{
 80317f0:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80317f2:	4604      	mov	r4, r0
    RxParams.IsMcpsIndication = 0;
 80317f4:	4b14      	ldr	r3, [pc, #80]	; (8031848 <MlmeIndication+0x58>)
    RxParams.Status = mlmeIndication->Status;
 80317f6:	7862      	ldrb	r2, [r4, #1]
 80317f8:	775a      	strb	r2, [r3, #29]
    RxParams.IsMcpsIndication = 0;
 80317fa:	2000      	movs	r0, #0
 80317fc:	7718      	strb	r0, [r3, #28]
    RxParams.Rssi = RxStatus->Rssi;
 80317fe:	880d      	ldrh	r5, [r1, #0]
 8031800:	77dd      	strb	r5, [r3, #31]
    RxParams.Snr = RxStatus->Snr;
 8031802:	788d      	ldrb	r5, [r1, #2]
 8031804:	f883 5020 	strb.w	r5, [r3, #32]
    RxParams.RxSlot = RxStatus->RxSlot;
 8031808:	78c9      	ldrb	r1, [r1, #3]
 803180a:	f883 1028 	strb.w	r1, [r3, #40]	; 0x28
    if( RxParams.Status != LORAMAC_EVENT_INFO_STATUS_BEACON_LOCKED )
 803180e:	2a0e      	cmp	r2, #14
 8031810:	d005      	beq.n	803181e <MlmeIndication+0x2e>
        LmHandlerCallbacks->OnRxData( NULL, &RxParams );
 8031812:	4a0e      	ldr	r2, [pc, #56]	; (803184c <MlmeIndication+0x5c>)
 8031814:	6992      	ldr	r2, [r2, #24]
 8031816:	f103 011c 	add.w	r1, r3, #28
 803181a:	6a52      	ldr	r2, [r2, #36]	; 0x24
 803181c:	4790      	blx	r2
    switch( mlmeIndication->MlmeIndication )
 803181e:	7823      	ldrb	r3, [r4, #0]
 8031820:	2b07      	cmp	r3, #7
 8031822:	d10e      	bne.n	8031842 <MlmeIndication+0x52>
            LmHandlerAppData_t appData =
 8031824:	2300      	movs	r3, #0
 8031826:	f8ad 3000 	strh.w	r3, [sp]
 803182a:	9301      	str	r3, [sp, #4]
            if( LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->IsRunning( ) == false )
 803182c:	4b07      	ldr	r3, [pc, #28]	; (803184c <MlmeIndication+0x5c>)
 803182e:	69db      	ldr	r3, [r3, #28]
 8031830:	68db      	ldr	r3, [r3, #12]
 8031832:	4798      	blx	r3
 8031834:	4602      	mov	r2, r0
 8031836:	b920      	cbnz	r0, 8031842 <MlmeIndication+0x52>
                LmHandlerSend( &appData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true );
 8031838:	4601      	mov	r1, r0
 803183a:	2301      	movs	r3, #1
 803183c:	4668      	mov	r0, sp
 803183e:	f7ff ff65 	bl	803170c <LmHandlerSend>
}
 8031842:	b003      	add	sp, #12
 8031844:	bd30      	pop	{r4, r5, pc}
 8031846:	bf00      	nop
 8031848:	20003458 	.word	0x20003458
 803184c:	200047dc 	.word	0x200047dc

08031850 <LmHandlerGetCurrentClass>:
{
 8031850:	b510      	push	{r4, lr}
    if (deviceClass == NULL)
 8031852:	4604      	mov	r4, r0
{
 8031854:	b08a      	sub	sp, #40	; 0x28
    if (deviceClass == NULL)
 8031856:	b918      	cbnz	r0, 8031860 <LmHandlerGetCurrentClass+0x10>
        return LORAMAC_HANDLER_ERROR;
 8031858:	f04f 30ff 	mov.w	r0, #4294967295
}
 803185c:	b00a      	add	sp, #40	; 0x28
 803185e:	bd10      	pop	{r4, pc}
    mibReq.Type = MIB_DEVICE_CLASS;
 8031860:	2300      	movs	r3, #0
    if (LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK)
 8031862:	a801      	add	r0, sp, #4
    mibReq.Type = MIB_DEVICE_CLASS;
 8031864:	f88d 3004 	strb.w	r3, [sp, #4]
    if (LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK)
 8031868:	f003 f9cc 	bl	8034c04 <LoRaMacMibGetRequestConfirm>
 803186c:	2800      	cmp	r0, #0
 803186e:	d1f3      	bne.n	8031858 <LmHandlerGetCurrentClass+0x8>
    *deviceClass = mibReq.Param.Class;
 8031870:	f89d 3008 	ldrb.w	r3, [sp, #8]
 8031874:	7023      	strb	r3, [r4, #0]
    return LORAMAC_HANDLER_SUCCESS;
 8031876:	e7f1      	b.n	803185c <LmHandlerGetCurrentClass+0xc>

08031878 <McpsIndication>:
{
 8031878:	b5f0      	push	{r4, r5, r6, r7, lr}
 803187a:	b087      	sub	sp, #28
    DeviceClass_t deviceClass = CLASS_A;
 803187c:	2300      	movs	r3, #0
 803187e:	f88d 3007 	strb.w	r3, [sp, #7]
    RxParams.IsMcpsIndication = 1;
 8031882:	4b2c      	ldr	r3, [pc, #176]	; (8031934 <McpsIndication+0xbc>)
 8031884:	2201      	movs	r2, #1
 8031886:	771a      	strb	r2, [r3, #28]
    RxParams.Status = mcpsIndication->Status;
 8031888:	7842      	ldrb	r2, [r0, #1]
 803188a:	775a      	strb	r2, [r3, #29]
{
 803188c:	4604      	mov	r4, r0
    if( RxParams.Status != LORAMAC_EVENT_INFO_STATUS_OK )
 803188e:	2a00      	cmp	r2, #0
 8031890:	d146      	bne.n	8031920 <McpsIndication+0xa8>
    RxParams.Datarate = mcpsIndication->RxDatarate;
 8031892:	7902      	ldrb	r2, [r0, #4]
 8031894:	779a      	strb	r2, [r3, #30]
    RxParams.Rssi = RxStatus->Rssi;
 8031896:	880a      	ldrh	r2, [r1, #0]
 8031898:	77da      	strb	r2, [r3, #31]
    RxParams.Snr = RxStatus->Snr;
 803189a:	788a      	ldrb	r2, [r1, #2]
 803189c:	f883 2020 	strb.w	r2, [r3, #32]
    RxParams.RxSlot = RxStatus->RxSlot;
 80318a0:	78ca      	ldrb	r2, [r1, #3]
 80318a2:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
    RxParams.DownlinkCounter = mcpsIndication->DownLinkCounter;
 80318a6:	6902      	ldr	r2, [r0, #16]
 80318a8:	625a      	str	r2, [r3, #36]	; 0x24
    appData.Port = mcpsIndication->Port;
 80318aa:	78c2      	ldrb	r2, [r0, #3]
    LmHandlerCallbacks->OnRxData(&appData, &RxParams);
 80318ac:	4e22      	ldr	r6, [pc, #136]	; (8031938 <McpsIndication+0xc0>)
    appData.Port = mcpsIndication->Port;
 80318ae:	f88d 2008 	strb.w	r2, [sp, #8]
    appData.BufferSize = mcpsIndication->BufferSize;
 80318b2:	7b02      	ldrb	r2, [r0, #12]
 80318b4:	f88d 2009 	strb.w	r2, [sp, #9]
    appData.Buffer = mcpsIndication->Buffer;
 80318b8:	6882      	ldr	r2, [r0, #8]
 80318ba:	9203      	str	r2, [sp, #12]
    LmHandlerCallbacks->OnRxData(&appData, &RxParams);
 80318bc:	69b2      	ldr	r2, [r6, #24]
 80318be:	f103 011c 	add.w	r1, r3, #28
 80318c2:	6a52      	ldr	r2, [r2, #36]	; 0x24
 80318c4:	a802      	add	r0, sp, #8
 80318c6:	4790      	blx	r2
    if ((LmHandlerCallbacks->OnSysTimeUpdate != NULL) && (mcpsIndication->DeviceTimeAnsReceived == true))
 80318c8:	69b3      	ldr	r3, [r6, #24]
 80318ca:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80318cc:	b113      	cbz	r3, 80318d4 <McpsIndication+0x5c>
 80318ce:	7e22      	ldrb	r2, [r4, #24]
 80318d0:	b102      	cbz	r2, 80318d4 <McpsIndication+0x5c>
        LmHandlerCallbacks->OnSysTimeUpdate( );
 80318d2:	4798      	blx	r3
 80318d4:	4f19      	ldr	r7, [pc, #100]	; (803193c <McpsIndication+0xc4>)
{
 80318d6:	2500      	movs	r5, #0
        if( LmHandlerPackages[i] != NULL )
 80318d8:	f857 3b04 	ldr.w	r3, [r7], #4
 80318dc:	b153      	cbz	r3, 80318f4 <McpsIndication+0x7c>
                    if( ( LmHandlerPackages[i]->OnMcpsIndicationProcess != NULL ) &&
 80318de:	69da      	ldr	r2, [r3, #28]
 80318e0:	b142      	cbz	r2, 80318f4 <McpsIndication+0x7c>
 80318e2:	781a      	ldrb	r2, [r3, #0]
 80318e4:	78e3      	ldrb	r3, [r4, #3]
 80318e6:	429a      	cmp	r2, r3
 80318e8:	d11c      	bne.n	8031924 <McpsIndication+0xac>
                        LmHandlerPackages[i]->OnMcpsIndicationProcess( ( McpsIndication_t* )params );
 80318ea:	f857 3c04 	ldr.w	r3, [r7, #-4]
 80318ee:	4620      	mov	r0, r4
 80318f0:	69db      	ldr	r3, [r3, #28]
 80318f2:	4798      	blx	r3
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 80318f4:	1c6b      	adds	r3, r5, #1
 80318f6:	b2da      	uxtb	r2, r3
 80318f8:	2a05      	cmp	r2, #5
 80318fa:	b25d      	sxtb	r5, r3
 80318fc:	d1ec      	bne.n	80318d8 <McpsIndication+0x60>
    LmHandlerGetCurrentClass(&deviceClass);
 80318fe:	f10d 0007 	add.w	r0, sp, #7
 8031902:	f7ff ffa5 	bl	8031850 <LmHandlerGetCurrentClass>
    if ((mcpsIndication->FramePending == true) && (deviceClass == CLASS_A))
 8031906:	7963      	ldrb	r3, [r4, #5]
 8031908:	2b01      	cmp	r3, #1
 803190a:	d109      	bne.n	8031920 <McpsIndication+0xa8>
 803190c:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8031910:	b932      	cbnz	r2, 8031920 <McpsIndication+0xa8>
        LmHandlerSend(&appData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true);
 8031912:	4611      	mov	r1, r2
 8031914:	a804      	add	r0, sp, #16
        LmHandlerAppData_t appData =
 8031916:	f8ad 2010 	strh.w	r2, [sp, #16]
 803191a:	9205      	str	r2, [sp, #20]
        LmHandlerSend(&appData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true);
 803191c:	f7ff fef6 	bl	803170c <LmHandlerSend>
}
 8031920:	b007      	add	sp, #28
 8031922:	bdf0      	pop	{r4, r5, r6, r7, pc}
                        ( ( LmHandlerPackages[i]->Port == ((McpsIndication_t* )params)->Port ) ||
 8031924:	2d00      	cmp	r5, #0
 8031926:	d1e5      	bne.n	80318f4 <McpsIndication+0x7c>
                          ( ( i == PACKAGE_ID_COMPLIANCE ) && ( LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->IsRunning() ))))
 8031928:	69f3      	ldr	r3, [r6, #28]
 803192a:	68db      	ldr	r3, [r3, #12]
 803192c:	4798      	blx	r3
 803192e:	2800      	cmp	r0, #0
 8031930:	d1db      	bne.n	80318ea <McpsIndication+0x72>
 8031932:	e7df      	b.n	80318f4 <McpsIndication+0x7c>
 8031934:	20003458 	.word	0x20003458
 8031938:	200047dc 	.word	0x200047dc
 803193c:	200047f8 	.word	0x200047f8

08031940 <LmHandlerGetTxDatarate>:
{
 8031940:	b510      	push	{r4, lr}
    if (txDatarate == NULL)
 8031942:	4604      	mov	r4, r0
{
 8031944:	b08a      	sub	sp, #40	; 0x28
    if (txDatarate == NULL)
 8031946:	b918      	cbnz	r0, 8031950 <LmHandlerGetTxDatarate+0x10>
        return LORAMAC_HANDLER_ERROR;
 8031948:	f04f 30ff 	mov.w	r0, #4294967295
}
 803194c:	b00a      	add	sp, #40	; 0x28
 803194e:	bd10      	pop	{r4, pc}
    mibGet.Type = MIB_CHANNELS_DATARATE;
 8031950:	231f      	movs	r3, #31
    if (LoRaMacMibGetRequestConfirm( &mibGet ) != LORAMAC_STATUS_OK)
 8031952:	a801      	add	r0, sp, #4
    mibGet.Type = MIB_CHANNELS_DATARATE;
 8031954:	f88d 3004 	strb.w	r3, [sp, #4]
    if (LoRaMacMibGetRequestConfirm( &mibGet ) != LORAMAC_STATUS_OK)
 8031958:	f003 f954 	bl	8034c04 <LoRaMacMibGetRequestConfirm>
 803195c:	2800      	cmp	r0, #0
 803195e:	d1f3      	bne.n	8031948 <LmHandlerGetTxDatarate+0x8>
    LmHandlerParams.TxDatarate = *txDatarate;
 8031960:	4a03      	ldr	r2, [pc, #12]	; (8031970 <LmHandlerGetTxDatarate+0x30>)
    *txDatarate = mibGet.Param.ChannelsDatarate;
 8031962:	f99d 3008 	ldrsb.w	r3, [sp, #8]
 8031966:	7023      	strb	r3, [r4, #0]
    LmHandlerParams.TxDatarate = *txDatarate;
 8031968:	f882 3033 	strb.w	r3, [r2, #51]	; 0x33
    return LORAMAC_HANDLER_SUCCESS;
 803196c:	e7ee      	b.n	803194c <LmHandlerGetTxDatarate+0xc>
 803196e:	bf00      	nop
 8031970:	200047dc 	.word	0x200047dc

08031974 <MlmeConfirm>:
{
 8031974:	b5f0      	push	{r4, r5, r6, r7, lr}
    TxParams.IsMcpsConfirm = 0;
 8031976:	4e23      	ldr	r6, [pc, #140]	; (8031a04 <MlmeConfirm+0x90>)
    TxParams.Status = mlmeConfirm->Status;
 8031978:	7843      	ldrb	r3, [r0, #1]
 803197a:	7073      	strb	r3, [r6, #1]
    LmHandlerCallbacks->OnTxData( &TxParams );
 803197c:	69b3      	ldr	r3, [r6, #24]
    TxParams.IsMcpsConfirm = 0;
 803197e:	2500      	movs	r5, #0
    LmHandlerCallbacks->OnTxData( &TxParams );
 8031980:	6a1b      	ldr	r3, [r3, #32]
    TxParams.IsMcpsConfirm = 0;
 8031982:	7035      	strb	r5, [r6, #0]
{
 8031984:	b08b      	sub	sp, #44	; 0x2c
 8031986:	4604      	mov	r4, r0
    LmHandlerCallbacks->OnTxData( &TxParams );
 8031988:	4630      	mov	r0, r6
 803198a:	4798      	blx	r3
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 803198c:	f106 071c 	add.w	r7, r6, #28
        if( LmHandlerPackages[i] != NULL )
 8031990:	f857 3b04 	ldr.w	r3, [r7], #4
 8031994:	b11b      	cbz	r3, 803199e <MlmeConfirm+0x2a>
                    if( LmHandlerPackages[i]->OnMlmeConfirmProcess != NULL )
 8031996:	6a1b      	ldr	r3, [r3, #32]
 8031998:	b10b      	cbz	r3, 803199e <MlmeConfirm+0x2a>
                        LmHandlerPackages[i]->OnMlmeConfirmProcess( ( MlmeConfirm_t* )params );
 803199a:	4620      	mov	r0, r4
 803199c:	4798      	blx	r3
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 803199e:	3501      	adds	r5, #1
 80319a0:	b2eb      	uxtb	r3, r5
 80319a2:	2b05      	cmp	r3, #5
 80319a4:	b26d      	sxtb	r5, r5
 80319a6:	d1f3      	bne.n	8031990 <MlmeConfirm+0x1c>
    switch( mlmeConfirm->MlmeRequest )
 80319a8:	7823      	ldrb	r3, [r4, #0]
 80319aa:	2b01      	cmp	r3, #1
 80319ac:	d003      	beq.n	80319b6 <MlmeConfirm+0x42>
 80319ae:	2b04      	cmp	r3, #4
 80319b0:	d01d      	beq.n	80319ee <MlmeConfirm+0x7a>
}
 80319b2:	b00b      	add	sp, #44	; 0x2c
 80319b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
            CommissioningParams.DevAddr = mibReq.Param.DevAddr;
 80319b6:	4d14      	ldr	r5, [pc, #80]	; (8031a08 <MlmeConfirm+0x94>)
            mibReq.Type = MIB_DEV_ADDR;
 80319b8:	2306      	movs	r3, #6
            LoRaMacMibGetRequestConfirm( &mibReq );
 80319ba:	a801      	add	r0, sp, #4
            mibReq.Type = MIB_DEV_ADDR;
 80319bc:	f88d 3004 	strb.w	r3, [sp, #4]
            LoRaMacMibGetRequestConfirm( &mibReq );
 80319c0:	f003 f920 	bl	8034c04 <LoRaMacMibGetRequestConfirm>
            CommissioningParams.DevAddr = mibReq.Param.DevAddr;
 80319c4:	9b02      	ldr	r3, [sp, #8]
 80319c6:	616b      	str	r3, [r5, #20]
            LmHandlerGetTxDatarate( &JoinParams.Datarate );
 80319c8:	f105 0018 	add.w	r0, r5, #24
 80319cc:	f7ff ffb8 	bl	8031940 <LmHandlerGetTxDatarate>
            if( mlmeConfirm->Status == LORAMAC_EVENT_INFO_STATUS_OK )
 80319d0:	7863      	ldrb	r3, [r4, #1]
 80319d2:	b94b      	cbnz	r3, 80319e8 <MlmeConfirm+0x74>
                LmHandlerRequestClass(LmHandlerParams.DefaultClass);
 80319d4:	f896 0031 	ldrb.w	r0, [r6, #49]	; 0x31
                JoinParams.Status = LORAMAC_HANDLER_SUCCESS;
 80319d8:	766b      	strb	r3, [r5, #25]
                LmHandlerRequestClass(LmHandlerParams.DefaultClass);
 80319da:	f7ff fdd7 	bl	803158c <LmHandlerRequestClass>
            LmHandlerCallbacks->OnJoinRequest( &JoinParams );
 80319de:	69b3      	ldr	r3, [r6, #24]
 80319e0:	480a      	ldr	r0, [pc, #40]	; (8031a0c <MlmeConfirm+0x98>)
 80319e2:	69db      	ldr	r3, [r3, #28]
 80319e4:	4798      	blx	r3
}
 80319e6:	e7e4      	b.n	80319b2 <MlmeConfirm+0x3e>
                JoinParams.Status = LORAMAC_HANDLER_ERROR;
 80319e8:	23ff      	movs	r3, #255	; 0xff
 80319ea:	766b      	strb	r3, [r5, #25]
 80319ec:	e7f7      	b.n	80319de <MlmeConfirm+0x6a>
            RxParams.LinkCheck = true;
 80319ee:	4b06      	ldr	r3, [pc, #24]	; (8031a08 <MlmeConfirm+0x94>)
 80319f0:	2201      	movs	r2, #1
 80319f2:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
            RxParams.DemodMargin = mlmeConfirm->DemodMargin;
 80319f6:	7a22      	ldrb	r2, [r4, #8]
 80319f8:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
            RxParams.NbGateways = mlmeConfirm->NbGateways;
 80319fc:	7a62      	ldrb	r2, [r4, #9]
 80319fe:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
}
 8031a02:	e7d6      	b.n	80319b2 <MlmeConfirm+0x3e>
 8031a04:	200047dc 	.word	0x200047dc
 8031a08:	20003458 	.word	0x20003458
 8031a0c:	20003470 	.word	0x20003470

08031a10 <LmHandlerPackageRegister>:
{
 8031a10:	b537      	push	{r0, r1, r2, r4, r5, lr}
    LmhPackage_t *package = NULL;
 8031a12:	2300      	movs	r3, #0
{
 8031a14:	460d      	mov	r5, r1
    LmhPackage_t *package = NULL;
 8031a16:	9301      	str	r3, [sp, #4]
    switch( id )
 8031a18:	4604      	mov	r4, r0
 8031a1a:	b9c8      	cbnz	r0, 8031a50 <LmHandlerPackageRegister+0x40>
            package = LmhpCompliancePackageFactory( );
 8031a1c:	f000 fb94 	bl	8032148 <LmhpCompliancePackageFactory>
 8031a20:	9001      	str	r0, [sp, #4]
    if( package != NULL )
 8031a22:	9b01      	ldr	r3, [sp, #4]
 8031a24:	b1c3      	cbz	r3, 8031a58 <LmHandlerPackageRegister+0x48>
        LmHandlerPackages[id]->OnJoinRequest = LmHandlerJoin;
 8031a26:	4a0e      	ldr	r2, [pc, #56]	; (8031a60 <LmHandlerPackageRegister+0x50>)
        LmHandlerPackages[id] = package;
 8031a28:	490e      	ldr	r1, [pc, #56]	; (8031a64 <LmHandlerPackageRegister+0x54>)
        LmHandlerPackages[id]->OnJoinRequest = LmHandlerJoin;
 8031a2a:	625a      	str	r2, [r3, #36]	; 0x24
        LmHandlerPackages[id]->OnSendRequest = LmHandlerSend;
 8031a2c:	4a0e      	ldr	r2, [pc, #56]	; (8031a68 <LmHandlerPackageRegister+0x58>)
 8031a2e:	629a      	str	r2, [r3, #40]	; 0x28
        LmHandlerPackages[id]->OnDeviceTimeRequest = LmHandlerDeviceTimeReq;
 8031a30:	4a0e      	ldr	r2, [pc, #56]	; (8031a6c <LmHandlerPackageRegister+0x5c>)
 8031a32:	62da      	str	r2, [r3, #44]	; 0x2c
        LmHandlerPackages[id]->OnPackageProcessEvent = LmHandlerCallbacks->OnMacProcess;
 8031a34:	698a      	ldr	r2, [r1, #24]
        LmHandlerPackages[id] = package;
 8031a36:	eb01 0484 	add.w	r4, r1, r4, lsl #2
        LmHandlerPackages[id]->OnPackageProcessEvent = LmHandlerCallbacks->OnMacProcess;
 8031a3a:	6912      	ldr	r2, [r2, #16]
 8031a3c:	615a      	str	r2, [r3, #20]
        LmHandlerPackages[id] = package;
 8031a3e:	61e3      	str	r3, [r4, #28]
        LmHandlerPackages[id]->Init( params, AppData.Buffer, AppData.BufferSize );
 8031a40:	4628      	mov	r0, r5
 8031a42:	685b      	ldr	r3, [r3, #4]
 8031a44:	22f2      	movs	r2, #242	; 0xf2
 8031a46:	3165      	adds	r1, #101	; 0x65
 8031a48:	4798      	blx	r3
        return LORAMAC_HANDLER_SUCCESS;
 8031a4a:	2000      	movs	r0, #0
}
 8031a4c:	b003      	add	sp, #12
 8031a4e:	bd30      	pop	{r4, r5, pc}
            LmhpPackagesRegister(id, &package);
 8031a50:	a901      	add	r1, sp, #4
 8031a52:	f000 ff27 	bl	80328a4 <LmhpPackagesRegister>
            break;
 8031a56:	e7e4      	b.n	8031a22 <LmHandlerPackageRegister+0x12>
        return LORAMAC_HANDLER_ERROR;
 8031a58:	f04f 30ff 	mov.w	r0, #4294967295
 8031a5c:	e7f6      	b.n	8031a4c <LmHandlerPackageRegister+0x3c>
 8031a5e:	bf00      	nop
 8031a60:	08031649 	.word	0x08031649
 8031a64:	200047dc 	.word	0x200047dc
 8031a68:	0803170d 	.word	0x0803170d
 8031a6c:	08031311 	.word	0x08031311

08031a70 <LmHandlerInit>:
{
 8031a70:	b508      	push	{r3, lr}
    LmHandlerCallbacks = handlerCallbacks;
 8031a72:	4b11      	ldr	r3, [pc, #68]	; (8031ab8 <LmHandlerInit+0x48>)
    LoRaMacPrimitives.MacMcpsConfirm = McpsConfirm;
 8031a74:	4a11      	ldr	r2, [pc, #68]	; (8031abc <LmHandlerInit+0x4c>)
 8031a76:	655a      	str	r2, [r3, #84]	; 0x54
    LoRaMacPrimitives.MacMcpsIndication = McpsIndication;
 8031a78:	4a11      	ldr	r2, [pc, #68]	; (8031ac0 <LmHandlerInit+0x50>)
 8031a7a:	659a      	str	r2, [r3, #88]	; 0x58
    LoRaMacPrimitives.MacMlmeConfirm = MlmeConfirm;
 8031a7c:	4a11      	ldr	r2, [pc, #68]	; (8031ac4 <LmHandlerInit+0x54>)
 8031a7e:	65da      	str	r2, [r3, #92]	; 0x5c
    LoRaMacPrimitives.MacMlmeIndication = MlmeIndication;
 8031a80:	4a11      	ldr	r2, [pc, #68]	; (8031ac8 <LmHandlerInit+0x58>)
 8031a82:	661a      	str	r2, [r3, #96]	; 0x60
    LoRaMacCallbacks.GetBatteryLevel = LmHandlerCallbacks->GetBatteryLevel;
 8031a84:	6802      	ldr	r2, [r0, #0]
 8031a86:	641a      	str	r2, [r3, #64]	; 0x40
    LoRaMacCallbacks.GetTemperatureLevel = LmHandlerCallbacks->GetTemperature;
 8031a88:	6842      	ldr	r2, [r0, #4]
 8031a8a:	645a      	str	r2, [r3, #68]	; 0x44
    LoRaMacCallbacks.GetUniqueId = LmHandlerCallbacks->GetUniqueId;
 8031a8c:	6882      	ldr	r2, [r0, #8]
 8031a8e:	649a      	str	r2, [r3, #72]	; 0x48
    LoRaMacCallbacks.NvmDataChange  = NvmDataMgmtEvent;
 8031a90:	4a0e      	ldr	r2, [pc, #56]	; (8031acc <LmHandlerInit+0x5c>)
    LmHandlerCallbacks = handlerCallbacks;
 8031a92:	6198      	str	r0, [r3, #24]
    LoRaMacCallbacks.NvmDataChange  = NvmDataMgmtEvent;
 8031a94:	64da      	str	r2, [r3, #76]	; 0x4c
    if (LmHandlerPackageRegister(PACKAGE_ID_COMPLIANCE, &LmhpComplianceParams) != LORAMAC_HANDLER_SUCCESS)
 8031a96:	490e      	ldr	r1, [pc, #56]	; (8031ad0 <LmHandlerInit+0x60>)
    LoRaMacCallbacks.MacProcessNotify = LmHandlerCallbacks->OnMacProcess;
 8031a98:	6902      	ldr	r2, [r0, #16]
 8031a9a:	651a      	str	r2, [r3, #80]	; 0x50
    if (LmHandlerPackageRegister(PACKAGE_ID_COMPLIANCE, &LmhpComplianceParams) != LORAMAC_HANDLER_SUCCESS)
 8031a9c:	2000      	movs	r0, #0
 8031a9e:	f7ff ffb7 	bl	8031a10 <LmHandlerPackageRegister>
 8031aa2:	b930      	cbnz	r0, 8031ab2 <LmHandlerInit+0x42>
    if (LmhpPackagesRegistrationInit() != LORAMAC_HANDLER_SUCCESS)
 8031aa4:	f000 fede 	bl	8032864 <LmhpPackagesRegistrationInit>
 8031aa8:	3800      	subs	r0, #0
 8031aaa:	bf18      	it	ne
 8031aac:	2001      	movne	r0, #1
 8031aae:	4240      	negs	r0, r0
}
 8031ab0:	bd08      	pop	{r3, pc}
        return LORAMAC_HANDLER_ERROR;
 8031ab2:	f04f 30ff 	mov.w	r0, #4294967295
 8031ab6:	e7fb      	b.n	8031ab0 <LmHandlerInit+0x40>
 8031ab8:	200047dc 	.word	0x200047dc
 8031abc:	0803132d 	.word	0x0803132d
 8031ac0:	08031879 	.word	0x08031879
 8031ac4:	08031975 	.word	0x08031975
 8031ac8:	080317f1 	.word	0x080317f1
 8031acc:	080366af 	.word	0x080366af
 8031ad0:	20003484 	.word	0x20003484

08031ad4 <LmHandlerGetDutyCycleEnable>:
    if (dutyCycleEnable == NULL)
 8031ad4:	b128      	cbz	r0, 8031ae2 <LmHandlerGetDutyCycleEnable+0xe>
    *dutyCycleEnable = LmHandlerParams.DutyCycleEnabled;
 8031ad6:	4b04      	ldr	r3, [pc, #16]	; (8031ae8 <LmHandlerGetDutyCycleEnable+0x14>)
 8031ad8:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8031adc:	7003      	strb	r3, [r0, #0]
    return LORAMAC_HANDLER_SUCCESS;
 8031ade:	2000      	movs	r0, #0
 8031ae0:	4770      	bx	lr
        return LORAMAC_HANDLER_ERROR;
 8031ae2:	f04f 30ff 	mov.w	r0, #4294967295
}
 8031ae6:	4770      	bx	lr
 8031ae8:	200047dc 	.word	0x200047dc

08031aec <LmHandlerSetDutyCycleEnable>:
{
 8031aec:	b508      	push	{r3, lr}
    LmHandlerParams.DutyCycleEnabled = dutyCycleEnable;
 8031aee:	4b03      	ldr	r3, [pc, #12]	; (8031afc <LmHandlerSetDutyCycleEnable+0x10>)
 8031af0:	f883 0035 	strb.w	r0, [r3, #53]	; 0x35
    LoRaMacTestSetDutyCycleOn(dutyCycleEnable);
 8031af4:	f003 fea6 	bl	8035844 <LoRaMacTestSetDutyCycleOn>
}
 8031af8:	2000      	movs	r0, #0
 8031afa:	bd08      	pop	{r3, pc}
 8031afc:	200047dc 	.word	0x200047dc

08031b00 <LmhpClockSyncIsInitialized>:
}

static bool LmhpClockSyncIsInitialized( void )
{
    return LmhpClockSyncState.Initialized;
}
 8031b00:	4b01      	ldr	r3, [pc, #4]	; (8031b08 <LmhpClockSyncIsInitialized+0x8>)
 8031b02:	7818      	ldrb	r0, [r3, #0]
 8031b04:	4770      	bx	lr
 8031b06:	bf00      	nop
 8031b08:	20004934 	.word	0x20004934

08031b0c <LmhpClockSyncIsRunning>:

static bool LmhpClockSyncIsRunning( void )
{
    if( LmhpClockSyncState.Initialized == false )
 8031b0c:	4b02      	ldr	r3, [pc, #8]	; (8031b18 <LmhpClockSyncIsRunning+0xc>)
 8031b0e:	7818      	ldrb	r0, [r3, #0]
 8031b10:	b100      	cbz	r0, 8031b14 <LmhpClockSyncIsRunning+0x8>
    {
        return false;
    }

    return LmhpClockSyncState.IsRunning;
 8031b12:	7858      	ldrb	r0, [r3, #1]
}
 8031b14:	4770      	bx	lr
 8031b16:	bf00      	nop
 8031b18:	20004934 	.word	0x20004934

08031b1c <OnPeriodicTimeStartTimer>:

    return status;
}

static void OnPeriodicTimeStartTimer(void *context)
{
 8031b1c:	b510      	push	{r4, lr}
  LmhpClockSyncState.NbTransmissions = 1;
 8031b1e:	4805      	ldr	r0, [pc, #20]	; (8031b34 <OnPeriodicTimeStartTimer+0x18>)
 8031b20:	2301      	movs	r3, #1
 8031b22:	7343      	strb	r3, [r0, #13]
  TimerStart(&PeriodicTimeStartTimer);
 8031b24:	3010      	adds	r0, #16
 8031b26:	f009 fc2f 	bl	803b388 <UTIL_TIMER_Start>
  LmhpClockSyncPackage.OnPackageProcessEvent();
 8031b2a:	4b03      	ldr	r3, [pc, #12]	; (8031b38 <OnPeriodicTimeStartTimer+0x1c>)
}
 8031b2c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  LmhpClockSyncPackage.OnPackageProcessEvent();
 8031b30:	695b      	ldr	r3, [r3, #20]
 8031b32:	4718      	bx	r3
 8031b34:	20004934 	.word	0x20004934
 8031b38:	20003490 	.word	0x20003490

08031b3c <LmhpClockSyncOnMcpsIndication>:
{
 8031b3c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if( mcpsIndication->Port != CLOCK_SYNC_PORT )
 8031b40:	78c3      	ldrb	r3, [r0, #3]
 8031b42:	2bca      	cmp	r3, #202	; 0xca
{
 8031b44:	b085      	sub	sp, #20
 8031b46:	4680      	mov	r8, r0
    if( mcpsIndication->Port != CLOCK_SYNC_PORT )
 8031b48:	f000 80ba 	beq.w	8031cc0 <LmhpClockSyncOnMcpsIndication+0x184>
}
 8031b4c:	b005      	add	sp, #20
 8031b4e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        switch( mcpsIndication->Buffer[cmdIndex++] )
 8031b52:	f8d8 1008 	ldr.w	r1, [r8, #8]
 8031b56:	5cc8      	ldrb	r0, [r1, r3]
 8031b58:	1c5a      	adds	r2, r3, #1
 8031b5a:	b2d2      	uxtb	r2, r2
 8031b5c:	2803      	cmp	r0, #3
 8031b5e:	d80f      	bhi.n	8031b80 <LmhpClockSyncOnMcpsIndication+0x44>
 8031b60:	e8df f000 	tbb	[pc, r0]
 8031b64:	a76e1002 	.word	0xa76e1002
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = CLOCK_SYNC_PKG_VERSION_ANS;
 8031b68:	6871      	ldr	r1, [r6, #4]
 8031b6a:	2300      	movs	r3, #0
 8031b6c:	550b      	strb	r3, [r1, r4]
 8031b6e:	1c60      	adds	r0, r4, #1
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = CLOCK_SYNC_ID;
 8031b70:	1ca3      	adds	r3, r4, #2
 8031b72:	b2db      	uxtb	r3, r3
 8031b74:	b2c0      	uxtb	r0, r0
 8031b76:	2501      	movs	r5, #1
 8031b78:	540d      	strb	r5, [r1, r0]
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = CLOCK_SYNC_VERSION;
 8031b7a:	3403      	adds	r4, #3
 8031b7c:	54cd      	strb	r5, [r1, r3]
 8031b7e:	b2e4      	uxtb	r4, r4
        switch( mcpsIndication->Buffer[cmdIndex++] )
 8031b80:	4617      	mov	r7, r2
 8031b82:	e03b      	b.n	8031bfc <LmhpClockSyncOnMcpsIndication+0xc0>
                LmhpClockSyncState.NbTransmissions = 0;
 8031b84:	2000      	movs	r0, #0
 8031b86:	7370      	strb	r0, [r6, #13]
                if( mcpsIndication->DeviceTimeAnsReceived == true )
 8031b88:	f898 0018 	ldrb.w	r0, [r8, #24]
 8031b8c:	1d9f      	adds	r7, r3, #6
 8031b8e:	b2ff      	uxtb	r7, r7
 8031b90:	2800      	cmp	r0, #0
 8031b92:	d133      	bne.n	8031bfc <LmhpClockSyncOnMcpsIndication+0xc0>
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8031b94:	1d58      	adds	r0, r3, #5
                if( ( mcpsIndication->Buffer[cmdIndex++] & 0x0F ) == LmhpClockSyncState.TimeReqParam.Fields.TokenReq )
 8031b96:	b2c0      	uxtb	r0, r0
 8031b98:	7a35      	ldrb	r5, [r6, #8]
 8031b9a:	5c08      	ldrb	r0, [r1, r0]
 8031b9c:	f005 050f 	and.w	r5, r5, #15
 8031ba0:	f000 000f 	and.w	r0, r0, #15
 8031ba4:	4285      	cmp	r5, r0
 8031ba6:	d129      	bne.n	8031bfc <LmhpClockSyncOnMcpsIndication+0xc0>
                timeCorrection  = ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8031ba8:	5c8d      	ldrb	r5, [r1, r2]
 8031baa:	1c9a      	adds	r2, r3, #2
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8031bac:	b2d2      	uxtb	r2, r2
                    curTime = SysTimeGet( );
 8031bae:	f10d 0b08 	add.w	fp, sp, #8
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8031bb2:	5c8a      	ldrb	r2, [r1, r2]
 8031bb4:	eb05 2502 	add.w	r5, r5, r2, lsl #8
 8031bb8:	1cda      	adds	r2, r3, #3
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8031bba:	b2d2      	uxtb	r2, r2
 8031bbc:	3304      	adds	r3, #4
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8031bbe:	b2db      	uxtb	r3, r3
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8031bc0:	5c8a      	ldrb	r2, [r1, r2]
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8031bc2:	5ccb      	ldrb	r3, [r1, r3]
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8031bc4:	eb05 4502 	add.w	r5, r5, r2, lsl #16
                    curTime = SysTimeGet( );
 8031bc8:	4658      	mov	r0, fp
                timeCorrection += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8031bca:	eb05 6503 	add.w	r5, r5, r3, lsl #24
                    curTime = SysTimeGet( );
 8031bce:	f009 fa9d 	bl	803b10c <SysTimeGet>
                    curTime.Seconds += timeCorrection;
 8031bd2:	9b02      	ldr	r3, [sp, #8]
 8031bd4:	442b      	add	r3, r5
                    SysTimeSet( curTime );
 8031bd6:	9302      	str	r3, [sp, #8]
 8031bd8:	e89b 0003 	ldmia.w	fp, {r0, r1}
 8031bdc:	f009 fa6e 	bl	803b0bc <SysTimeSet>
                    LmhpClockSyncState.TimeReqParam.Fields.TokenReq = ( LmhpClockSyncState.TimeReqParam.Fields.TokenReq + 1 ) & 0x0F;
 8031be0:	7a33      	ldrb	r3, [r6, #8]
 8031be2:	f3c3 0203 	ubfx	r2, r3, #0, #4
 8031be6:	3201      	adds	r2, #1
 8031be8:	f362 0303 	bfi	r3, r2, #0, #4
 8031bec:	7233      	strb	r3, [r6, #8]
                    if( LmhpClockSyncPackage.OnSysTimeUpdate != NULL )
 8031bee:	4b38      	ldr	r3, [pc, #224]	; (8031cd0 <LmhpClockSyncOnMcpsIndication+0x194>)
 8031bf0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8031bf2:	b11b      	cbz	r3, 8031bfc <LmhpClockSyncOnMcpsIndication+0xc0>
                        if( ( timeCorrection >= -1 ) && ( timeCorrection <= 1 ) )
 8031bf4:	3501      	adds	r5, #1
 8031bf6:	2d02      	cmp	r5, #2
 8031bf8:	d800      	bhi.n	8031bfc <LmhpClockSyncOnMcpsIndication+0xc0>
                            LmhpClockSyncPackage.OnSysTimeUpdate( );
 8031bfa:	4798      	blx	r3
        switch( mcpsIndication->Buffer[cmdIndex++] )
 8031bfc:	463b      	mov	r3, r7
    while( cmdIndex < mcpsIndication->BufferSize )
 8031bfe:	f898 200c 	ldrb.w	r2, [r8, #12]
 8031c02:	429a      	cmp	r2, r3
 8031c04:	d8a5      	bhi.n	8031b52 <LmhpClockSyncOnMcpsIndication+0x16>
    if( dataBufferIndex != 0 )
 8031c06:	2c00      	cmp	r4, #0
 8031c08:	d0a0      	beq.n	8031b4c <LmhpClockSyncOnMcpsIndication+0x10>
        LmHandlerAppData_t appData =
 8031c0a:	23ca      	movs	r3, #202	; 0xca
 8031c0c:	f88d 3008 	strb.w	r3, [sp, #8]
            .Buffer = LmhpClockSyncState.DataBuffer,
 8031c10:	4b30      	ldr	r3, [pc, #192]	; (8031cd4 <LmhpClockSyncOnMcpsIndication+0x198>)
        LmHandlerAppData_t appData =
 8031c12:	f88d 4009 	strb.w	r4, [sp, #9]
 8031c16:	685b      	ldr	r3, [r3, #4]
 8031c18:	9303      	str	r3, [sp, #12]
        LmHandlerGetDutyCycleEnable(&current_dutycycle);
 8031c1a:	f10d 0007 	add.w	r0, sp, #7
 8031c1e:	f7ff ff59 	bl	8031ad4 <LmHandlerGetDutyCycleEnable>
        LmHandlerSetDutyCycleEnable(false);
 8031c22:	2000      	movs	r0, #0
 8031c24:	f7ff ff62 	bl	8031aec <LmHandlerSetDutyCycleEnable>
        LmhpClockSyncPackage.OnSendRequest(&appData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true);
 8031c28:	4b29      	ldr	r3, [pc, #164]	; (8031cd0 <LmhpClockSyncOnMcpsIndication+0x194>)
 8031c2a:	2200      	movs	r2, #0
 8031c2c:	6a9c      	ldr	r4, [r3, #40]	; 0x28
 8031c2e:	4611      	mov	r1, r2
 8031c30:	2301      	movs	r3, #1
 8031c32:	a802      	add	r0, sp, #8
 8031c34:	47a0      	blx	r4
        LmHandlerSetDutyCycleEnable(current_dutycycle);
 8031c36:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8031c3a:	f7ff ff57 	bl	8031aec <LmHandlerSetDutyCycleEnable>
 8031c3e:	e785      	b.n	8031b4c <LmhpClockSyncOnMcpsIndication+0x10>
                uint32_t periodTime = mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8031c40:	1cdf      	adds	r7, r3, #3
                cmdIndex++;
 8031c42:	3302      	adds	r3, #2
                uint32_t periodTime = mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8031c44:	b2db      	uxtb	r3, r3
                periodTime = (128 << periodTime) + randr(0, 30);
 8031c46:	2000      	movs	r0, #0
                uint32_t periodTime = mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8031c48:	5ccd      	ldrb	r5, [r1, r3]
 8031c4a:	f005 010f 	and.w	r1, r5, #15
                periodTime = (128 << periodTime) + randr(0, 30);
 8031c4e:	2580      	movs	r5, #128	; 0x80
 8031c50:	408d      	lsls	r5, r1
 8031c52:	211e      	movs	r1, #30
 8031c54:	f007 f924 	bl	8038ea0 <randr>
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = CLOCK_SYNC_APP_TIME_PERIOD_ANS;
 8031c58:	6872      	ldr	r2, [r6, #4]
 8031c5a:	2302      	movs	r3, #2
 8031c5c:	5513      	strb	r3, [r2, r4]
 8031c5e:	1c63      	adds	r3, r4, #1
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = 0x00;
 8031c60:	b2db      	uxtb	r3, r3
 8031c62:	2100      	movs	r1, #0
 8031c64:	54d1      	strb	r1, [r2, r3]
                periodTime = (128 << periodTime) + randr(0, 30);
 8031c66:	4683      	mov	fp, r0
                SysTime_t curTime = SysTimeGet( );
 8031c68:	a802      	add	r0, sp, #8
 8031c6a:	f009 fa4f 	bl	803b10c <SysTimeGet>
                curTime.Seconds -= UNIX_GPS_EPOCH_OFFSET;
 8031c6e:	9b02      	ldr	r3, [sp, #8]
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 0  ) & 0xFF;
 8031c70:	6872      	ldr	r2, [r6, #4]
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = 0x00;
 8031c72:	1ca1      	adds	r1, r4, #2
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 0  ) & 0xFF;
 8031c74:	b2c9      	uxtb	r1, r1
                curTime.Seconds -= UNIX_GPS_EPOCH_OFFSET;
 8031c76:	4453      	add	r3, sl
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 0  ) & 0xFF;
 8031c78:	5453      	strb	r3, [r2, r1]
 8031c7a:	1ce1      	adds	r1, r4, #3
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 8  ) & 0xFF;
 8031c7c:	b2c9      	uxtb	r1, r1
 8031c7e:	0a18      	lsrs	r0, r3, #8
 8031c80:	5450      	strb	r0, [r2, r1]
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 16 ) & 0xFF;
 8031c82:	1d61      	adds	r1, r4, #5
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 8  ) & 0xFF;
 8031c84:	1d20      	adds	r0, r4, #4
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 16 ) & 0xFF;
 8031c86:	b2c9      	uxtb	r1, r1
 8031c88:	b2c0      	uxtb	r0, r0
 8031c8a:	ea4f 4c13 	mov.w	ip, r3, lsr #16
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 24 ) & 0xFF;
 8031c8e:	0e1b      	lsrs	r3, r3, #24
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 16 ) & 0xFF;
 8031c90:	f802 c000 	strb.w	ip, [r2, r0]
                periodTime = (128 << periodTime) + randr(0, 30);
 8031c94:	445d      	add	r5, fp
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 24 ) & 0xFF;
 8031c96:	5453      	strb	r3, [r2, r1]
                TimerSetValue(&PeriodicTimeStartTimer, periodTime * 1000);
 8031c98:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8031c9c:	4369      	muls	r1, r5
 8031c9e:	4648      	mov	r0, r9
 8031ca0:	f009 fbac 	bl	803b3fc <UTIL_TIMER_SetPeriod>
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 24 ) & 0xFF;
 8031ca4:	3406      	adds	r4, #6
                TimerStart(&PeriodicTimeStartTimer);
 8031ca6:	4648      	mov	r0, r9
                uint32_t periodTime = mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8031ca8:	b2ff      	uxtb	r7, r7
                LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 24 ) & 0xFF;
 8031caa:	b2e4      	uxtb	r4, r4
                TimerStart(&PeriodicTimeStartTimer);
 8031cac:	f009 fb6c 	bl	803b388 <UTIL_TIMER_Start>
                break;
 8031cb0:	e7a4      	b.n	8031bfc <LmhpClockSyncOnMcpsIndication+0xc0>
                LmhpClockSyncState.NbTransmissions = mcpsIndication->Buffer[cmdIndex++] & 0X07;
 8031cb2:	3302      	adds	r3, #2
 8031cb4:	b2df      	uxtb	r7, r3
 8031cb6:	5c8b      	ldrb	r3, [r1, r2]
 8031cb8:	f003 0307 	and.w	r3, r3, #7
 8031cbc:	7373      	strb	r3, [r6, #13]
                break;
 8031cbe:	e79d      	b.n	8031bfc <LmhpClockSyncOnMcpsIndication+0xc0>
                LmhpClockSyncState.NbTransmissions = mcpsIndication->Buffer[cmdIndex++] & 0X07;
 8031cc0:	4e04      	ldr	r6, [pc, #16]	; (8031cd4 <LmhpClockSyncOnMcpsIndication+0x198>)
                curTime.Seconds -= UNIX_GPS_EPOCH_OFFSET;
 8031cc2:	f8df a014 	ldr.w	sl, [pc, #20]	; 8031cd8 <LmhpClockSyncOnMcpsIndication+0x19c>
    uint8_t dataBufferIndex = 0;
 8031cc6:	2400      	movs	r4, #0
    uint8_t cmdIndex = 0;
 8031cc8:	4623      	mov	r3, r4
                TimerSetValue(&PeriodicTimeStartTimer, periodTime * 1000);
 8031cca:	f106 0910 	add.w	r9, r6, #16
 8031cce:	e796      	b.n	8031bfe <LmhpClockSyncOnMcpsIndication+0xc2>
 8031cd0:	20003490 	.word	0x20003490
 8031cd4:	20004934 	.word	0x20004934
 8031cd8:	ed2ac280 	.word	0xed2ac280

08031cdc <LmhpClockSyncOnMcpsConfirm>:
{
 8031cdc:	b510      	push	{r4, lr}
    if( LmhpClockSyncState.AppTimeReqPending == true )
 8031cde:	4c11      	ldr	r4, [pc, #68]	; (8031d24 <LmhpClockSyncOnMcpsConfirm+0x48>)
 8031ce0:	7a63      	ldrb	r3, [r4, #9]
{
 8031ce2:	b08a      	sub	sp, #40	; 0x28
    if( LmhpClockSyncState.AppTimeReqPending == true )
 8031ce4:	b1e3      	cbz	r3, 8031d20 <LmhpClockSyncOnMcpsConfirm+0x44>
        mibReq.Type = MIB_ADR;
 8031ce6:	2304      	movs	r3, #4
 8031ce8:	f88d 3004 	strb.w	r3, [sp, #4]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8031cec:	a801      	add	r0, sp, #4
        mibReq.Param.AdrEnable = LmhpClockSyncState.AdrEnabledPrev;
 8031cee:	7aa3      	ldrb	r3, [r4, #10]
 8031cf0:	f88d 3008 	strb.w	r3, [sp, #8]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8031cf4:	f003 f842 	bl	8034d7c <LoRaMacMibSetRequestConfirm>
        mibReq.Type = MIB_CHANNELS_NB_TRANS;
 8031cf8:	2318      	movs	r3, #24
 8031cfa:	f88d 3004 	strb.w	r3, [sp, #4]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8031cfe:	a801      	add	r0, sp, #4
        mibReq.Param.ChannelsNbTrans = LmhpClockSyncState.NbTransPrev;
 8031d00:	7ae3      	ldrb	r3, [r4, #11]
 8031d02:	f88d 3008 	strb.w	r3, [sp, #8]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8031d06:	f003 f839 	bl	8034d7c <LoRaMacMibSetRequestConfirm>
        mibReq.Type = MIB_CHANNELS_DATARATE;
 8031d0a:	231f      	movs	r3, #31
 8031d0c:	f88d 3004 	strb.w	r3, [sp, #4]
        LoRaMacMibSetRequestConfirm( &mibReq );        
 8031d10:	a801      	add	r0, sp, #4
        mibReq.Param.ChannelsDatarate = LmhpClockSyncState.DataratePrev;
 8031d12:	7b23      	ldrb	r3, [r4, #12]
 8031d14:	f88d 3008 	strb.w	r3, [sp, #8]
        LoRaMacMibSetRequestConfirm( &mibReq );        
 8031d18:	f003 f830 	bl	8034d7c <LoRaMacMibSetRequestConfirm>
        LmhpClockSyncState.AppTimeReqPending = false;
 8031d1c:	2300      	movs	r3, #0
 8031d1e:	7263      	strb	r3, [r4, #9]
}
 8031d20:	b00a      	add	sp, #40	; 0x28
 8031d22:	bd10      	pop	{r4, pc}
 8031d24:	20004934 	.word	0x20004934

08031d28 <LmhpClockSyncInit>:
{
 8031d28:	b507      	push	{r0, r1, r2, lr}
 8031d2a:	480a      	ldr	r0, [pc, #40]	; (8031d54 <LmhpClockSyncInit+0x2c>)
    if( dataBuffer != NULL )
 8031d2c:	b179      	cbz	r1, 8031d4e <LmhpClockSyncInit+0x26>
        LmhpClockSyncState.DataBufferMaxSize = dataBufferMaxSize;
 8031d2e:	7082      	strb	r2, [r0, #2]
        LmhpClockSyncState.Initialized = true;
 8031d30:	f240 1301 	movw	r3, #257	; 0x101
        TimerInit(&PeriodicTimeStartTimer, OnPeriodicTimeStartTimer);
 8031d34:	2200      	movs	r2, #0
        LmhpClockSyncState.DataBuffer = dataBuffer;
 8031d36:	6041      	str	r1, [r0, #4]
        LmhpClockSyncState.Initialized = true;
 8031d38:	f820 3b10 	strh.w	r3, [r0], #16
        TimerInit(&PeriodicTimeStartTimer, OnPeriodicTimeStartTimer);
 8031d3c:	f04f 31ff 	mov.w	r1, #4294967295
 8031d40:	4b05      	ldr	r3, [pc, #20]	; (8031d58 <LmhpClockSyncInit+0x30>)
 8031d42:	9200      	str	r2, [sp, #0]
 8031d44:	f009 fa72 	bl	803b22c <UTIL_TIMER_Create>
}
 8031d48:	b003      	add	sp, #12
 8031d4a:	f85d fb04 	ldr.w	pc, [sp], #4
        LmhpClockSyncState.Initialized = false;
 8031d4e:	8001      	strh	r1, [r0, #0]
}
 8031d50:	e7fa      	b.n	8031d48 <LmhpClockSyncInit+0x20>
 8031d52:	bf00      	nop
 8031d54:	20004934 	.word	0x20004934
 8031d58:	08031b1d 	.word	0x08031b1d

08031d5c <LmhpClockSyncPackageFactory>:
}
 8031d5c:	4800      	ldr	r0, [pc, #0]	; (8031d60 <LmhpClockSyncPackageFactory+0x4>)
 8031d5e:	4770      	bx	lr
 8031d60:	20003490 	.word	0x20003490

08031d64 <LmhpClockSyncAppTimeReq>:
{
 8031d64:	b570      	push	{r4, r5, r6, lr}
 8031d66:	b08c      	sub	sp, #48	; 0x30
    if( LmHandlerIsBusy( ) == true )
 8031d68:	f7ff fcb8 	bl	80316dc <LmHandlerIsBusy>
 8031d6c:	2800      	cmp	r0, #0
 8031d6e:	d15b      	bne.n	8031e28 <LmhpClockSyncAppTimeReq+0xc4>
    if( LmhpClockSyncState.AppTimeReqPending == false )
 8031d70:	4c2f      	ldr	r4, [pc, #188]	; (8031e30 <LmhpClockSyncAppTimeReq+0xcc>)
 8031d72:	4e30      	ldr	r6, [pc, #192]	; (8031e34 <LmhpClockSyncAppTimeReq+0xd0>)
 8031d74:	7a65      	ldrb	r5, [r4, #9]
 8031d76:	bb3d      	cbnz	r5, 8031dc8 <LmhpClockSyncAppTimeReq+0x64>
        mibReq.Type = MIB_ADR;
 8031d78:	2304      	movs	r3, #4
        LoRaMacMibGetRequestConfirm( &mibReq );
 8031d7a:	a803      	add	r0, sp, #12
        mibReq.Type = MIB_ADR;
 8031d7c:	f88d 300c 	strb.w	r3, [sp, #12]
        LoRaMacMibGetRequestConfirm( &mibReq );
 8031d80:	f002 ff40 	bl	8034c04 <LoRaMacMibGetRequestConfirm>
        LmhpClockSyncState.AdrEnabledPrev = mibReq.Param.AdrEnable;
 8031d84:	f89d 3010 	ldrb.w	r3, [sp, #16]
 8031d88:	72a3      	strb	r3, [r4, #10]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8031d8a:	a803      	add	r0, sp, #12
        mibReq.Param.AdrEnable = false;
 8031d8c:	f88d 5010 	strb.w	r5, [sp, #16]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8031d90:	f002 fff4 	bl	8034d7c <LoRaMacMibSetRequestConfirm>
        mibReq.Type = MIB_CHANNELS_NB_TRANS;
 8031d94:	2318      	movs	r3, #24
        LoRaMacMibGetRequestConfirm( &mibReq );
 8031d96:	a803      	add	r0, sp, #12
        mibReq.Type = MIB_CHANNELS_NB_TRANS;
 8031d98:	f88d 300c 	strb.w	r3, [sp, #12]
        LoRaMacMibGetRequestConfirm( &mibReq );
 8031d9c:	f002 ff32 	bl	8034c04 <LoRaMacMibGetRequestConfirm>
        LmhpClockSyncState.NbTransPrev = mibReq.Param.ChannelsNbTrans;
 8031da0:	f89d 3010 	ldrb.w	r3, [sp, #16]
 8031da4:	72e3      	strb	r3, [r4, #11]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8031da6:	a803      	add	r0, sp, #12
        mibReq.Param.ChannelsNbTrans = 1;
 8031da8:	2301      	movs	r3, #1
 8031daa:	f88d 3010 	strb.w	r3, [sp, #16]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8031dae:	f002 ffe5 	bl	8034d7c <LoRaMacMibSetRequestConfirm>
        mibReq.Type = MIB_CHANNELS_DATARATE;
 8031db2:	231f      	movs	r3, #31
        LoRaMacMibGetRequestConfirm( &mibReq );  
 8031db4:	a803      	add	r0, sp, #12
        mibReq.Type = MIB_CHANNELS_DATARATE;
 8031db6:	f88d 300c 	strb.w	r3, [sp, #12]
        LoRaMacMibGetRequestConfirm( &mibReq );  
 8031dba:	f002 ff23 	bl	8034c04 <LoRaMacMibGetRequestConfirm>
        LmhpClockSyncState.DataratePrev = mibReq.Param.ChannelsDatarate;
 8031dbe:	f89d 3010 	ldrb.w	r3, [sp, #16]
 8031dc2:	7323      	strb	r3, [r4, #12]
        LmhpClockSyncPackage.OnDeviceTimeRequest( );
 8031dc4:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8031dc6:	4798      	blx	r3
    SysTime_t curTime = SysTimeGet( );
 8031dc8:	a801      	add	r0, sp, #4
 8031dca:	f009 f99f 	bl	803b10c <SysTimeGet>
    curTime.Seconds -= UNIX_GPS_EPOCH_OFFSET;
 8031dce:	9b01      	ldr	r3, [sp, #4]
 8031dd0:	4a19      	ldr	r2, [pc, #100]	; (8031e38 <LmhpClockSyncAppTimeReq+0xd4>)
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = CLOCK_SYNC_APP_TIME_REQ;
 8031dd2:	6861      	ldr	r1, [r4, #4]
    curTime.Seconds -= UNIX_GPS_EPOCH_OFFSET;
 8031dd4:	441a      	add	r2, r3
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 8  ) & 0xFF;
 8031dd6:	0a13      	lsrs	r3, r2, #8
 8031dd8:	708b      	strb	r3, [r1, #2]
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 16 ) & 0xFF;
 8031dda:	0c13      	lsrs	r3, r2, #16
 8031ddc:	70cb      	strb	r3, [r1, #3]
    LmhpClockSyncState.TimeReqParam.Fields.AnsRequired = 0;
 8031dde:	7a23      	ldrb	r3, [r4, #8]
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 0  ) & 0xFF;
 8031de0:	704a      	strb	r2, [r1, #1]
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = CLOCK_SYNC_APP_TIME_REQ;
 8031de2:	2501      	movs	r5, #1
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 24 ) & 0xFF;
 8031de4:	0e12      	lsrs	r2, r2, #24
    LmhpClockSyncState.TimeReqParam.Fields.AnsRequired = 0;
 8031de6:	f36f 1304 	bfc	r3, #4, #1
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = ( curTime.Seconds >> 24 ) & 0xFF;
 8031dea:	710a      	strb	r2, [r1, #4]
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = LmhpClockSyncState.TimeReqParam.Value;
 8031dec:	714b      	strb	r3, [r1, #5]
    LmhpClockSyncState.DataBuffer[dataBufferIndex++] = CLOCK_SYNC_APP_TIME_REQ;
 8031dee:	700d      	strb	r5, [r1, #0]
    LmhpClockSyncState.TimeReqParam.Fields.AnsRequired = 0;
 8031df0:	7223      	strb	r3, [r4, #8]
    LmHandlerGetDutyCycleEnable(&current_dutycycle);
 8031df2:	f10d 0003 	add.w	r0, sp, #3
    LmHandlerAppData_t appData =
 8031df6:	f240 63ca 	movw	r3, #1738	; 0x6ca
 8031dfa:	f8ad 300c 	strh.w	r3, [sp, #12]
 8031dfe:	9104      	str	r1, [sp, #16]
    LmhpClockSyncState.AppTimeReqPending = true;
 8031e00:	7265      	strb	r5, [r4, #9]
    LmHandlerGetDutyCycleEnable(&current_dutycycle);
 8031e02:	f7ff fe67 	bl	8031ad4 <LmHandlerGetDutyCycleEnable>
    LmHandlerSetDutyCycleEnable(false);
 8031e06:	2000      	movs	r0, #0
 8031e08:	f7ff fe70 	bl	8031aec <LmHandlerSetDutyCycleEnable>
    LmHandlerErrorStatus_t status = LmhpClockSyncPackage.OnSendRequest(&appData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true);
 8031e0c:	2200      	movs	r2, #0
 8031e0e:	6ab4      	ldr	r4, [r6, #40]	; 0x28
 8031e10:	462b      	mov	r3, r5
 8031e12:	4611      	mov	r1, r2
 8031e14:	a803      	add	r0, sp, #12
 8031e16:	47a0      	blx	r4
 8031e18:	4604      	mov	r4, r0
    LmHandlerSetDutyCycleEnable(current_dutycycle);
 8031e1a:	f89d 0003 	ldrb.w	r0, [sp, #3]
 8031e1e:	f7ff fe65 	bl	8031aec <LmHandlerSetDutyCycleEnable>
}
 8031e22:	4620      	mov	r0, r4
 8031e24:	b00c      	add	sp, #48	; 0x30
 8031e26:	bd70      	pop	{r4, r5, r6, pc}
        return LORAMAC_HANDLER_ERROR;
 8031e28:	f04f 34ff 	mov.w	r4, #4294967295
 8031e2c:	e7f9      	b.n	8031e22 <LmhpClockSyncAppTimeReq+0xbe>
 8031e2e:	bf00      	nop
 8031e30:	20004934 	.word	0x20004934
 8031e34:	20003490 	.word	0x20003490
 8031e38:	ed2ac280 	.word	0xed2ac280

08031e3c <LmhpClockSyncProcess>:
{
 8031e3c:	b510      	push	{r4, lr}
    if( LmhpClockSyncState.NbTransmissions > 0 )
 8031e3e:	4c05      	ldr	r4, [pc, #20]	; (8031e54 <LmhpClockSyncProcess+0x18>)
 8031e40:	7b63      	ldrb	r3, [r4, #13]
 8031e42:	b12b      	cbz	r3, 8031e50 <LmhpClockSyncProcess+0x14>
        if( LmhpClockSyncAppTimeReq( ) == LORAMAC_HANDLER_SUCCESS )
 8031e44:	f7ff ff8e 	bl	8031d64 <LmhpClockSyncAppTimeReq>
 8031e48:	b910      	cbnz	r0, 8031e50 <LmhpClockSyncProcess+0x14>
            LmhpClockSyncState.NbTransmissions--;
 8031e4a:	7b63      	ldrb	r3, [r4, #13]
 8031e4c:	3b01      	subs	r3, #1
 8031e4e:	7363      	strb	r3, [r4, #13]
}
 8031e50:	bd10      	pop	{r4, pc}
 8031e52:	bf00      	nop
 8031e54:	20004934 	.word	0x20004934

08031e58 <LmhpComplianceInit>:
    return &LmhpCompliancePackage;
}

static void LmhpComplianceInit( void *params, uint8_t *dataBuffer, uint8_t dataBufferMaxSize )
{
    if( ( params != NULL ) && ( dataBuffer != NULL ) )
 8031e58:	4b05      	ldr	r3, [pc, #20]	; (8031e70 <LmhpComplianceInit+0x18>)
 8031e5a:	b130      	cbz	r0, 8031e6a <LmhpComplianceInit+0x12>
 8031e5c:	b129      	cbz	r1, 8031e6a <LmhpComplianceInit+0x12>
    {
        LmhpComplianceParams = ( LmhpComplianceParams_t* )params;
        ComplianceTestState.DataBuffer = dataBuffer;
        ComplianceTestState.DataBufferMaxSize = dataBufferMaxSize;
 8031e5e:	725a      	strb	r2, [r3, #9]
        LmhpComplianceParams = ( LmhpComplianceParams_t* )params;
 8031e60:	6018      	str	r0, [r3, #0]
        ComplianceTestState.DataBuffer = dataBuffer;
 8031e62:	60d9      	str	r1, [r3, #12]
        ComplianceTestState.Initialized = true;
 8031e64:	2201      	movs	r2, #1
    }
    else
    {
        LmhpComplianceParams = NULL;
        ComplianceTestState.Initialized = false;
 8031e66:	711a      	strb	r2, [r3, #4]
    }
}
 8031e68:	4770      	bx	lr
        LmhpComplianceParams = NULL;
 8031e6a:	2200      	movs	r2, #0
 8031e6c:	601a      	str	r2, [r3, #0]
 8031e6e:	e7fa      	b.n	8031e66 <LmhpComplianceInit+0xe>
 8031e70:	2000495c 	.word	0x2000495c

08031e74 <LmhpComplianceIsInitialized>:

static bool LmhpComplianceIsInitialized( void )
{
    return ComplianceTestState.Initialized;
}
 8031e74:	4b01      	ldr	r3, [pc, #4]	; (8031e7c <LmhpComplianceIsInitialized+0x8>)
 8031e76:	7918      	ldrb	r0, [r3, #4]
 8031e78:	4770      	bx	lr
 8031e7a:	bf00      	nop
 8031e7c:	2000495c 	.word	0x2000495c

08031e80 <LmhpComplianceIsRunning>:

static bool LmhpComplianceIsRunning( void )
{
    if( ComplianceTestState.Initialized == false )
 8031e80:	4b02      	ldr	r3, [pc, #8]	; (8031e8c <LmhpComplianceIsRunning+0xc>)
 8031e82:	7918      	ldrb	r0, [r3, #4]
 8031e84:	b100      	cbz	r0, 8031e88 <LmhpComplianceIsRunning+0x8>
    {
        return false;
    }

    return ComplianceTestState.IsRunning;
 8031e86:	7958      	ldrb	r0, [r3, #5]
}
 8031e88:	4770      	bx	lr
 8031e8a:	bf00      	nop
 8031e8c:	2000495c 	.word	0x2000495c

08031e90 <LmhpComplianceProcess>:
}

static void LmhpComplianceProcess( void )
{
    /* Nothing to process */
}
 8031e90:	4770      	bx	lr
	...

08031e94 <LmhpComplianceOnMcpsConfirm>:
    if (ComplianceTestState.Initialized == false)
 8031e94:	4b06      	ldr	r3, [pc, #24]	; (8031eb0 <LmhpComplianceOnMcpsConfirm+0x1c>)
 8031e96:	791a      	ldrb	r2, [r3, #4]
 8031e98:	b14a      	cbz	r2, 8031eae <LmhpComplianceOnMcpsConfirm+0x1a>
    if ((ComplianceTestState.IsRunning == true) &&
 8031e9a:	795a      	ldrb	r2, [r3, #5]
 8031e9c:	b13a      	cbz	r2, 8031eae <LmhpComplianceOnMcpsConfirm+0x1a>
 8031e9e:	7802      	ldrb	r2, [r0, #0]
 8031ea0:	2a01      	cmp	r2, #1
 8031ea2:	d104      	bne.n	8031eae <LmhpComplianceOnMcpsConfirm+0x1a>
        (mcpsConfirm->McpsRequest == MCPS_CONFIRMED) &&
 8031ea4:	7902      	ldrb	r2, [r0, #4]
 8031ea6:	b112      	cbz	r2, 8031eae <LmhpComplianceOnMcpsConfirm+0x1a>
        ComplianceTestState.DownLinkCounter++;
 8031ea8:	8a1a      	ldrh	r2, [r3, #16]
 8031eaa:	3201      	adds	r2, #1
 8031eac:	821a      	strh	r2, [r3, #16]
}
 8031eae:	4770      	bx	lr
 8031eb0:	2000495c 	.word	0x2000495c

08031eb4 <LmhpComplianceOnMlmeConfirm>:
    if( ComplianceTestState.Initialized == false )
 8031eb4:	4b07      	ldr	r3, [pc, #28]	; (8031ed4 <LmhpComplianceOnMlmeConfirm+0x20>)
 8031eb6:	791a      	ldrb	r2, [r3, #4]
 8031eb8:	b152      	cbz	r2, 8031ed0 <LmhpComplianceOnMlmeConfirm+0x1c>
    if( ComplianceTestState.IsRunning == false )
 8031eba:	795a      	ldrb	r2, [r3, #5]
 8031ebc:	b142      	cbz	r2, 8031ed0 <LmhpComplianceOnMlmeConfirm+0x1c>
    if( mlmeConfirm->MlmeRequest == MLME_LINK_CHECK )
 8031ebe:	7802      	ldrb	r2, [r0, #0]
 8031ec0:	2a04      	cmp	r2, #4
 8031ec2:	d105      	bne.n	8031ed0 <LmhpComplianceOnMlmeConfirm+0x1c>
        ComplianceTestState.LinkCheck = true;
 8031ec4:	2201      	movs	r2, #1
 8031ec6:	749a      	strb	r2, [r3, #18]
        ComplianceTestState.DemodMargin = mlmeConfirm->DemodMargin;
 8031ec8:	7a02      	ldrb	r2, [r0, #8]
 8031eca:	74da      	strb	r2, [r3, #19]
        ComplianceTestState.NbGateways = mlmeConfirm->NbGateways;
 8031ecc:	7a42      	ldrb	r2, [r0, #9]
 8031ece:	751a      	strb	r2, [r3, #20]
}
 8031ed0:	4770      	bx	lr
 8031ed2:	bf00      	nop
 8031ed4:	2000495c 	.word	0x2000495c

08031ed8 <LmhpComplianceTxProcess>:
{
 8031ed8:	b537      	push	{r0, r1, r2, r4, r5, lr}
    if( ComplianceTestState.Initialized == false )
 8031eda:	4c1b      	ldr	r4, [pc, #108]	; (8031f48 <LmhpComplianceTxProcess+0x70>)
 8031edc:	7923      	ldrb	r3, [r4, #4]
 8031ede:	b383      	cbz	r3, 8031f42 <LmhpComplianceTxProcess+0x6a>
    if( ComplianceTestState.IsRunning == false )
 8031ee0:	7960      	ldrb	r0, [r4, #5]
 8031ee2:	b328      	cbz	r0, 8031f30 <LmhpComplianceTxProcess+0x58>
    if( ComplianceTestState.LinkCheck == true )
 8031ee4:	7ca2      	ldrb	r2, [r4, #18]
 8031ee6:	68e3      	ldr	r3, [r4, #12]
 8031ee8:	b162      	cbz	r2, 8031f04 <LmhpComplianceTxProcess+0x2c>
        ComplianceTestState.LinkCheck = false;
 8031eea:	2200      	movs	r2, #0
 8031eec:	74a2      	strb	r2, [r4, #18]
        ComplianceTestState.DataBufferSize = 3;
 8031eee:	2203      	movs	r2, #3
 8031ef0:	72a2      	strb	r2, [r4, #10]
        ComplianceTestState.DataBuffer[0] = 5;
 8031ef2:	2205      	movs	r2, #5
 8031ef4:	701a      	strb	r2, [r3, #0]
        ComplianceTestState.DataBuffer[1] = ComplianceTestState.DemodMargin;
 8031ef6:	7ce2      	ldrb	r2, [r4, #19]
 8031ef8:	705a      	strb	r2, [r3, #1]
        ComplianceTestState.DataBuffer[2] = ComplianceTestState.NbGateways;
 8031efa:	7d22      	ldrb	r2, [r4, #20]
 8031efc:	709a      	strb	r2, [r3, #2]
            ComplianceTestState.State = 1;
 8031efe:	2201      	movs	r2, #1
 8031f00:	71a2      	strb	r2, [r4, #6]
            break;
 8031f02:	e004      	b.n	8031f0e <LmhpComplianceTxProcess+0x36>
        switch( ComplianceTestState.State )
 8031f04:	79a2      	ldrb	r2, [r4, #6]
 8031f06:	2a01      	cmp	r2, #1
 8031f08:	d014      	beq.n	8031f34 <LmhpComplianceTxProcess+0x5c>
 8031f0a:	2a04      	cmp	r2, #4
 8031f0c:	d0f7      	beq.n	8031efe <LmhpComplianceTxProcess+0x26>
    LmHandlerAppData_t appData =
 8031f0e:	22e0      	movs	r2, #224	; 0xe0
 8031f10:	f88d 2000 	strb.w	r2, [sp]
    TimerStart( &ComplianceTxNextPacketTimer );
 8031f14:	480d      	ldr	r0, [pc, #52]	; (8031f4c <LmhpComplianceTxProcess+0x74>)
    LmHandlerAppData_t appData =
 8031f16:	7aa2      	ldrb	r2, [r4, #10]
 8031f18:	f88d 2001 	strb.w	r2, [sp, #1]
 8031f1c:	9301      	str	r3, [sp, #4]
    TimerStart( &ComplianceTxNextPacketTimer );
 8031f1e:	f009 fa33 	bl	803b388 <UTIL_TIMER_Start>
    return LmhpCompliancePackage.OnSendRequest( &appData, ( LmHandlerMsgTypes_t )ComplianceTestState.IsTxConfirmed, NULL, true );
 8031f22:	4b0b      	ldr	r3, [pc, #44]	; (8031f50 <LmhpComplianceTxProcess+0x78>)
 8031f24:	79e1      	ldrb	r1, [r4, #7]
 8031f26:	6a9d      	ldr	r5, [r3, #40]	; 0x28
 8031f28:	2200      	movs	r2, #0
 8031f2a:	2301      	movs	r3, #1
 8031f2c:	4668      	mov	r0, sp
 8031f2e:	47a8      	blx	r5
}
 8031f30:	b003      	add	sp, #12
 8031f32:	bd30      	pop	{r4, r5, pc}
            ComplianceTestState.DataBufferSize = 2;
 8031f34:	2202      	movs	r2, #2
 8031f36:	72a2      	strb	r2, [r4, #10]
            ComplianceTestState.DataBuffer[0] = ComplianceTestState.DownLinkCounter >> 8;
 8031f38:	8a22      	ldrh	r2, [r4, #16]
            ComplianceTestState.DataBuffer[1] = ComplianceTestState.DownLinkCounter;
 8031f3a:	705a      	strb	r2, [r3, #1]
            ComplianceTestState.DataBuffer[0] = ComplianceTestState.DownLinkCounter >> 8;
 8031f3c:	0a11      	lsrs	r1, r2, #8
 8031f3e:	7019      	strb	r1, [r3, #0]
            break;
 8031f40:	e7e5      	b.n	8031f0e <LmhpComplianceTxProcess+0x36>
        return LORAMAC_HANDLER_ERROR;
 8031f42:	f04f 30ff 	mov.w	r0, #4294967295
 8031f46:	e7f3      	b.n	8031f30 <LmhpComplianceTxProcess+0x58>
 8031f48:	2000495c 	.word	0x2000495c
 8031f4c:	20004974 	.word	0x20004974
 8031f50:	200034c4 	.word	0x200034c4

08031f54 <OnComplianceTxNextPacketTimerEvent>:

static void OnComplianceTxNextPacketTimerEvent( void* context )
{
    LmhpComplianceTxProcess( );
 8031f54:	f7ff bfc0 	b.w	8031ed8 <LmhpComplianceTxProcess>

08031f58 <LmhpComplianceOnMcpsIndication>:
{
 8031f58:	b530      	push	{r4, r5, lr}
    if( ComplianceTestState.Initialized == false )
 8031f5a:	4c77      	ldr	r4, [pc, #476]	; (8032138 <LmhpComplianceOnMcpsIndication+0x1e0>)
 8031f5c:	7923      	ldrb	r3, [r4, #4]
{
 8031f5e:	b08d      	sub	sp, #52	; 0x34
    if( ComplianceTestState.Initialized == false )
 8031f60:	2b00      	cmp	r3, #0
 8031f62:	d042      	beq.n	8031fea <LmhpComplianceOnMcpsIndication+0x92>
    if( mcpsIndication->RxData == false )
 8031f64:	7b43      	ldrb	r3, [r0, #13]
 8031f66:	2b00      	cmp	r3, #0
 8031f68:	d03f      	beq.n	8031fea <LmhpComplianceOnMcpsIndication+0x92>
    if ((ComplianceTestState.IsRunning == true) &&
 8031f6a:	7965      	ldrb	r5, [r4, #5]
 8031f6c:	b125      	cbz	r5, 8031f78 <LmhpComplianceOnMcpsIndication+0x20>
 8031f6e:	7b83      	ldrb	r3, [r0, #14]
 8031f70:	b913      	cbnz	r3, 8031f78 <LmhpComplianceOnMcpsIndication+0x20>
        ComplianceTestState.DownLinkCounter++;
 8031f72:	8a23      	ldrh	r3, [r4, #16]
 8031f74:	3301      	adds	r3, #1
 8031f76:	8223      	strh	r3, [r4, #16]
    if( mcpsIndication->Port != COMPLIANCE_PORT )
 8031f78:	78c1      	ldrb	r1, [r0, #3]
 8031f7a:	29e0      	cmp	r1, #224	; 0xe0
 8031f7c:	d135      	bne.n	8031fea <LmhpComplianceOnMcpsIndication+0x92>
    if( ComplianceTestState.IsRunning == false )
 8031f7e:	2d00      	cmp	r5, #0
 8031f80:	d135      	bne.n	8031fee <LmhpComplianceOnMcpsIndication+0x96>
        if( ( mcpsIndication->BufferSize == 4 ) &&
 8031f82:	7b02      	ldrb	r2, [r0, #12]
 8031f84:	2a04      	cmp	r2, #4
 8031f86:	d130      	bne.n	8031fea <LmhpComplianceOnMcpsIndication+0x92>
            ( mcpsIndication->Buffer[0] == 0x01 ) &&
 8031f88:	6883      	ldr	r3, [r0, #8]
        if( ( mcpsIndication->BufferSize == 4 ) &&
 8031f8a:	7818      	ldrb	r0, [r3, #0]
 8031f8c:	2801      	cmp	r0, #1
 8031f8e:	d12c      	bne.n	8031fea <LmhpComplianceOnMcpsIndication+0x92>
            ( mcpsIndication->Buffer[0] == 0x01 ) &&
 8031f90:	7858      	ldrb	r0, [r3, #1]
 8031f92:	2801      	cmp	r0, #1
 8031f94:	d129      	bne.n	8031fea <LmhpComplianceOnMcpsIndication+0x92>
            ( mcpsIndication->Buffer[1] == 0x01 ) &&
 8031f96:	7898      	ldrb	r0, [r3, #2]
 8031f98:	2801      	cmp	r0, #1
 8031f9a:	d126      	bne.n	8031fea <LmhpComplianceOnMcpsIndication+0x92>
            ( mcpsIndication->Buffer[2] == 0x01 ) &&
 8031f9c:	78db      	ldrb	r3, [r3, #3]
 8031f9e:	2b01      	cmp	r3, #1
 8031fa0:	d123      	bne.n	8031fea <LmhpComplianceOnMcpsIndication+0x92>
            ComplianceTestState.DataBufferSize = 2;
 8031fa2:	2002      	movs	r0, #2
 8031fa4:	72a0      	strb	r0, [r4, #10]
            LoRaMacMibSetRequestConfirm( &mibReq );
 8031fa6:	a803      	add	r0, sp, #12
            ComplianceTestState.IsRunning = true;
 8031fa8:	7163      	strb	r3, [r4, #5]
            ComplianceTestState.State = 1;
 8031faa:	80e3      	strh	r3, [r4, #6]
            mibReq.Param.AdrEnable = true;
 8031fac:	f88d 3010 	strb.w	r3, [sp, #16]
            ComplianceTestState.Port = 224;
 8031fb0:	7221      	strb	r1, [r4, #8]
            mibReq.Type = MIB_ADR;
 8031fb2:	f88d 200c 	strb.w	r2, [sp, #12]
            ComplianceTestState.DownLinkCounter = 0;
 8031fb6:	6125      	str	r5, [r4, #16]
            ComplianceTestState.NbGateways = 0;
 8031fb8:	7525      	strb	r5, [r4, #20]
            LoRaMacMibSetRequestConfirm( &mibReq );
 8031fba:	f002 fedf 	bl	8034d7c <LoRaMacMibSetRequestConfirm>
            LoRaMacTestSetDutyCycleOn( false );
 8031fbe:	4628      	mov	r0, r5
 8031fc0:	f003 fc40 	bl	8035844 <LoRaMacTestSetDutyCycleOn>
            if( LmhpComplianceParams->StopPeripherals != NULL )
 8031fc4:	6823      	ldr	r3, [r4, #0]
 8031fc6:	685b      	ldr	r3, [r3, #4]
 8031fc8:	b103      	cbz	r3, 8031fcc <LmhpComplianceOnMcpsIndication+0x74>
                LmhpComplianceParams->StopPeripherals( );
 8031fca:	4798      	blx	r3
            TimerInit( &ComplianceTxNextPacketTimer, OnComplianceTxNextPacketTimerEvent );
 8031fcc:	2200      	movs	r2, #0
 8031fce:	4b5b      	ldr	r3, [pc, #364]	; (803213c <LmhpComplianceOnMcpsIndication+0x1e4>)
 8031fd0:	9200      	str	r2, [sp, #0]
 8031fd2:	f04f 31ff 	mov.w	r1, #4294967295
 8031fd6:	485a      	ldr	r0, [pc, #360]	; (8032140 <LmhpComplianceOnMcpsIndication+0x1e8>)
 8031fd8:	f009 f928 	bl	803b22c <UTIL_TIMER_Create>
            TimerSetValue( &ComplianceTxNextPacketTimer, COMPLIANCE_TX_DUTYCYCLE );
 8031fdc:	f241 3188 	movw	r1, #5000	; 0x1388
 8031fe0:	4857      	ldr	r0, [pc, #348]	; (8032140 <LmhpComplianceOnMcpsIndication+0x1e8>)
 8031fe2:	f009 fa0b 	bl	803b3fc <UTIL_TIMER_SetPeriod>
            LmhpComplianceTxProcess( );
 8031fe6:	f7ff ff77 	bl	8031ed8 <LmhpComplianceTxProcess>
}
 8031fea:	b00d      	add	sp, #52	; 0x34
 8031fec:	bd30      	pop	{r4, r5, pc}
        ComplianceTestState.State = mcpsIndication->Buffer[0];
 8031fee:	6883      	ldr	r3, [r0, #8]
 8031ff0:	781a      	ldrb	r2, [r3, #0]
 8031ff2:	71a2      	strb	r2, [r4, #6]
        switch( ComplianceTestState.State )
 8031ff4:	2a0a      	cmp	r2, #10
 8031ff6:	d8f8      	bhi.n	8031fea <LmhpComplianceOnMcpsIndication+0x92>
 8031ff8:	e8df f002 	tbb	[pc, r2]
 8031ffc:	27232006 	.word	0x27232006
 8032000:	60433c29 	.word	0x60433c29
 8032004:	8d8b      	.short	0x8d8b
 8032006:	97          	.byte	0x97
 8032007:	00          	.byte	0x00
                TimerStop( &ComplianceTxNextPacketTimer );
 8032008:	484d      	ldr	r0, [pc, #308]	; (8032140 <LmhpComplianceOnMcpsIndication+0x1e8>)
 803200a:	f009 f96d 	bl	803b2e8 <UTIL_TIMER_Stop>
                ComplianceTestState.DownLinkCounter = 0;
 803200e:	2300      	movs	r3, #0
 8032010:	8223      	strh	r3, [r4, #16]
                ComplianceTestState.IsRunning = false;
 8032012:	7163      	strb	r3, [r4, #5]
                mibReq.Type = MIB_ADR;
 8032014:	2304      	movs	r3, #4
 8032016:	f88d 300c 	strb.w	r3, [sp, #12]
                mibReq.Param.AdrEnable = LmhpComplianceParams->AdrEnabled;
 803201a:	6823      	ldr	r3, [r4, #0]
                LoRaMacMibSetRequestConfirm( &mibReq );
 803201c:	a803      	add	r0, sp, #12
                mibReq.Param.AdrEnable = LmhpComplianceParams->AdrEnabled;
 803201e:	781b      	ldrb	r3, [r3, #0]
 8032020:	f88d 3010 	strb.w	r3, [sp, #16]
                LoRaMacMibSetRequestConfirm( &mibReq );
 8032024:	f002 feaa 	bl	8034d7c <LoRaMacMibSetRequestConfirm>
                LoRaMacTestSetDutyCycleOn( LmhpComplianceParams->DutyCycleEnabled );
 8032028:	6823      	ldr	r3, [r4, #0]
 803202a:	7858      	ldrb	r0, [r3, #1]
 803202c:	f003 fc0a 	bl	8035844 <LoRaMacTestSetDutyCycleOn>
                if( LmhpComplianceParams->StartPeripherals != NULL )
 8032030:	6823      	ldr	r3, [r4, #0]
 8032032:	689b      	ldr	r3, [r3, #8]
 8032034:	2b00      	cmp	r3, #0
 8032036:	d0d8      	beq.n	8031fea <LmhpComplianceOnMcpsIndication+0x92>
                    LmhpComplianceParams->StartPeripherals( );
 8032038:	4798      	blx	r3
            break;
 803203a:	e7d6      	b.n	8031fea <LmhpComplianceOnMcpsIndication+0x92>
            ComplianceTestState.DataBufferSize = 2;
 803203c:	2302      	movs	r3, #2
 803203e:	72a3      	strb	r3, [r4, #10]
            break;
 8032040:	e7d3      	b.n	8031fea <LmhpComplianceOnMcpsIndication+0x92>
            ComplianceTestState.State = 1;
 8032042:	f240 1301 	movw	r3, #257	; 0x101
            ComplianceTestState.State = 1;
 8032046:	80e3      	strh	r3, [r4, #6]
            break;
 8032048:	e7cf      	b.n	8031fea <LmhpComplianceOnMcpsIndication+0x92>
            ComplianceTestState.State = 1;
 803204a:	2301      	movs	r3, #1
 803204c:	e7fb      	b.n	8032046 <LmhpComplianceOnMcpsIndication+0xee>
            ComplianceTestState.DataBuffer[0] = 4;
 803204e:	68e5      	ldr	r5, [r4, #12]
            ComplianceTestState.DataBufferSize = mcpsIndication->BufferSize;
 8032050:	7b03      	ldrb	r3, [r0, #12]
 8032052:	72a3      	strb	r3, [r4, #10]
            ComplianceTestState.DataBuffer[0] = 4;
 8032054:	2204      	movs	r2, #4
 8032056:	702a      	strb	r2, [r5, #0]
            for( uint8_t i = 1; i < MIN( ComplianceTestState.DataBufferSize, ComplianceTestState.DataBufferMaxSize ); i++ )
 8032058:	7a62      	ldrb	r2, [r4, #9]
 803205a:	429a      	cmp	r2, r3
 803205c:	bf28      	it	cs
 803205e:	461a      	movcs	r2, r3
 8032060:	2300      	movs	r3, #0
 8032062:	3301      	adds	r3, #1
 8032064:	b2d9      	uxtb	r1, r3
 8032066:	428a      	cmp	r2, r1
 8032068:	d9bf      	bls.n	8031fea <LmhpComplianceOnMcpsIndication+0x92>
                ComplianceTestState.DataBuffer[i] = mcpsIndication->Buffer[i] + 1;
 803206a:	6881      	ldr	r1, [r0, #8]
 803206c:	5cc9      	ldrb	r1, [r1, r3]
 803206e:	3101      	adds	r1, #1
 8032070:	54e9      	strb	r1, [r5, r3]
            for( uint8_t i = 1; i < MIN( ComplianceTestState.DataBufferSize, ComplianceTestState.DataBufferMaxSize ); i++ )
 8032072:	e7f6      	b.n	8032062 <LmhpComplianceOnMcpsIndication+0x10a>
                mlmeReq.Type = MLME_LINK_CHECK;
 8032074:	2304      	movs	r3, #4
                mlmeReq.Type = MLME_DEVICE_TIME;
 8032076:	f88d 300c 	strb.w	r3, [sp, #12]
                LoRaMacMlmeRequest( &mlmeReq );
 803207a:	a803      	add	r0, sp, #12
 803207c:	f003 f96a 	bl	8035354 <LoRaMacMlmeRequest>
            break;
 8032080:	e7b3      	b.n	8031fea <LmhpComplianceOnMcpsIndication+0x92>
                TimerStop(&ComplianceTxNextPacketTimer);
 8032082:	482f      	ldr	r0, [pc, #188]	; (8032140 <LmhpComplianceOnMcpsIndication+0x1e8>)
 8032084:	f009 f930 	bl	803b2e8 <UTIL_TIMER_Stop>
                ComplianceTestState.DownLinkCounter = 0;
 8032088:	2300      	movs	r3, #0
 803208a:	8223      	strh	r3, [r4, #16]
                ComplianceTestState.IsRunning = false;
 803208c:	7163      	strb	r3, [r4, #5]
                mibReq.Type = MIB_ADR;
 803208e:	2304      	movs	r3, #4
 8032090:	f88d 300c 	strb.w	r3, [sp, #12]
                mibReq.Param.AdrEnable = LmhpComplianceParams->AdrEnabled;
 8032094:	6823      	ldr	r3, [r4, #0]
                LoRaMacMibSetRequestConfirm( &mibReq );
 8032096:	a803      	add	r0, sp, #12
                mibReq.Param.AdrEnable = LmhpComplianceParams->AdrEnabled;
 8032098:	781b      	ldrb	r3, [r3, #0]
 803209a:	f88d 3010 	strb.w	r3, [sp, #16]
                LoRaMacMibSetRequestConfirm( &mibReq );
 803209e:	f002 fe6d 	bl	8034d7c <LoRaMacMibSetRequestConfirm>
                LoRaMacTestSetDutyCycleOn( LmhpComplianceParams->DutyCycleEnabled );
 80320a2:	6823      	ldr	r3, [r4, #0]
 80320a4:	7858      	ldrb	r0, [r3, #1]
 80320a6:	f003 fbcd 	bl	8035844 <LoRaMacTestSetDutyCycleOn>
                if( LmhpComplianceParams->StartPeripherals != NULL )
 80320aa:	6823      	ldr	r3, [r4, #0]
 80320ac:	689b      	ldr	r3, [r3, #8]
 80320ae:	b103      	cbz	r3, 80320b2 <LmhpComplianceOnMcpsIndication+0x15a>
                    LmhpComplianceParams->StartPeripherals( );
 80320b0:	4798      	blx	r3
                LmhpCompliancePackage.OnJoinRequest( ACTIVATION_TYPE_OTAA );
 80320b2:	4b24      	ldr	r3, [pc, #144]	; (8032144 <LmhpComplianceOnMcpsIndication+0x1ec>)
 80320b4:	2002      	movs	r0, #2
 80320b6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80320b8:	4798      	blx	r3
            break;
 80320ba:	e796      	b.n	8031fea <LmhpComplianceOnMcpsIndication+0x92>
                if( mcpsIndication->BufferSize == 3 )
 80320bc:	7b02      	ldrb	r2, [r0, #12]
 80320be:	2a03      	cmp	r2, #3
 80320c0:	d10e      	bne.n	80320e0 <LmhpComplianceOnMcpsIndication+0x188>
                    mlmeReq.Type = MLME_TXCW;
 80320c2:	2205      	movs	r2, #5
 80320c4:	f88d 200c 	strb.w	r2, [sp, #12]
                    mlmeReq.Req.TxCw.Timeout = ( uint16_t )( ( mcpsIndication->Buffer[1] << 8 ) | mcpsIndication->Buffer[2] );
 80320c8:	785a      	ldrb	r2, [r3, #1]
 80320ca:	789b      	ldrb	r3, [r3, #2]
 80320cc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80320d0:	f8ad 3010 	strh.w	r3, [sp, #16]
                LoRaMacMlmeRequest( &mlmeReq );
 80320d4:	a803      	add	r0, sp, #12
 80320d6:	f003 f93d 	bl	8035354 <LoRaMacMlmeRequest>
                ComplianceTestState.State = 1;
 80320da:	2301      	movs	r3, #1
 80320dc:	71a3      	strb	r3, [r4, #6]
            break;
 80320de:	e784      	b.n	8031fea <LmhpComplianceOnMcpsIndication+0x92>
                else if( mcpsIndication->BufferSize == 7 )
 80320e0:	2a07      	cmp	r2, #7
 80320e2:	d1f7      	bne.n	80320d4 <LmhpComplianceOnMcpsIndication+0x17c>
                    mlmeReq.Type = MLME_TXCW_1;
 80320e4:	2206      	movs	r2, #6
 80320e6:	f88d 200c 	strb.w	r2, [sp, #12]
                    mlmeReq.Req.TxCw.Timeout = ( uint16_t )( ( mcpsIndication->Buffer[1] << 8 ) | mcpsIndication->Buffer[2] );
 80320ea:	7859      	ldrb	r1, [r3, #1]
 80320ec:	789a      	ldrb	r2, [r3, #2]
 80320ee:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 80320f2:	f8ad 2010 	strh.w	r2, [sp, #16]
                    mlmeReq.Req.TxCw.Frequency = ( uint32_t )( ( mcpsIndication->Buffer[3] << 16 ) | ( mcpsIndication->Buffer[4] << 8 ) | mcpsIndication->Buffer[5] ) * 100;
 80320f6:	791a      	ldrb	r2, [r3, #4]
 80320f8:	78d9      	ldrb	r1, [r3, #3]
 80320fa:	0212      	lsls	r2, r2, #8
 80320fc:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8032100:	7959      	ldrb	r1, [r3, #5]
 8032102:	430a      	orrs	r2, r1
 8032104:	2164      	movs	r1, #100	; 0x64
 8032106:	434a      	muls	r2, r1
 8032108:	9205      	str	r2, [sp, #20]
                    mlmeReq.Req.TxCw.Power = mcpsIndication->Buffer[6];
 803210a:	799b      	ldrb	r3, [r3, #6]
 803210c:	f88d 3018 	strb.w	r3, [sp, #24]
 8032110:	e7e0      	b.n	80320d4 <LmhpComplianceOnMcpsIndication+0x17c>
                mlmeReq.Type = MLME_DEVICE_TIME;
 8032112:	230a      	movs	r3, #10
 8032114:	e7af      	b.n	8032076 <LmhpComplianceOnMcpsIndication+0x11e>
                mibReq.Type = MIB_DEVICE_CLASS;
 8032116:	2200      	movs	r2, #0
 8032118:	f88d 200c 	strb.w	r2, [sp, #12]
                mibReq.Param.Class = ( DeviceClass_t )mcpsIndication->Buffer[1];;
 803211c:	785b      	ldrb	r3, [r3, #1]
 803211e:	f88d 3010 	strb.w	r3, [sp, #16]
                LoRaMacMibSetRequestConfirm( &mibReq );
 8032122:	a803      	add	r0, sp, #12
 8032124:	f002 fe2a 	bl	8034d7c <LoRaMacMibSetRequestConfirm>
            break;
 8032128:	e75f      	b.n	8031fea <LmhpComplianceOnMcpsIndication+0x92>
                mlmeReq.Type = MLME_PING_SLOT_INFO;
 803212a:	220d      	movs	r2, #13
 803212c:	f88d 200c 	strb.w	r2, [sp, #12]
                mlmeReq.Req.PingSlotInfo.PingSlot.Value = mcpsIndication->Buffer[1];
 8032130:	785b      	ldrb	r3, [r3, #1]
 8032132:	f88d 3010 	strb.w	r3, [sp, #16]
 8032136:	e7a0      	b.n	803207a <LmhpComplianceOnMcpsIndication+0x122>
 8032138:	2000495c 	.word	0x2000495c
 803213c:	08031f55 	.word	0x08031f55
 8032140:	20004974 	.word	0x20004974
 8032144:	200034c4 	.word	0x200034c4

08032148 <LmhpCompliancePackageFactory>:
}
 8032148:	4800      	ldr	r0, [pc, #0]	; (803214c <LmhpCompliancePackageFactory+0x4>)
 803214a:	4770      	bx	lr
 803214c:	200034c4 	.word	0x200034c4

08032150 <__NVIC_SystemReset>:
  __ASM volatile ("dsb 0xF":::"memory");
 8032150:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8032154:	4905      	ldr	r1, [pc, #20]	; (803216c <__NVIC_SystemReset+0x1c>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8032156:	4b06      	ldr	r3, [pc, #24]	; (8032170 <__NVIC_SystemReset+0x20>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8032158:	68ca      	ldr	r2, [r1, #12]
 803215a:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 803215e:	4313      	orrs	r3, r2
 8032160:	60cb      	str	r3, [r1, #12]
 8032162:	f3bf 8f4f 	dsb	sy
    __NOP();
 8032166:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 8032168:	e7fd      	b.n	8032166 <__NVIC_SystemReset+0x16>
 803216a:	bf00      	nop
 803216c:	e000ed00 	.word	0xe000ed00
 8032170:	05fa0004 	.word	0x05fa0004

08032174 <LmhpFirmwareManagementIsInitialized>:
}

static bool LmhpFirmwareManagementIsInitialized(void)
{
  return LmhpFirmwareManagementState.Initialized;
}
 8032174:	4b01      	ldr	r3, [pc, #4]	; (803217c <LmhpFirmwareManagementIsInitialized+0x8>)
 8032176:	7818      	ldrb	r0, [r3, #0]
 8032178:	4770      	bx	lr
 803217a:	bf00      	nop
 803217c:	2000498c 	.word	0x2000498c

08032180 <LmhpFirmwareManagementIsRunning>:

static bool LmhpFirmwareManagementIsRunning(void)
{
  if (LmhpFirmwareManagementState.Initialized == false)
 8032180:	4b02      	ldr	r3, [pc, #8]	; (803218c <LmhpFirmwareManagementIsRunning+0xc>)
 8032182:	7818      	ldrb	r0, [r3, #0]
 8032184:	b100      	cbz	r0, 8032188 <LmhpFirmwareManagementIsRunning+0x8>
  {
    return false;
  }

  return LmhpFirmwareManagementState.IsRunning;
 8032186:	7858      	ldrb	r0, [r3, #1]
}
 8032188:	4770      	bx	lr
 803218a:	bf00      	nop
 803218c:	2000498c 	.word	0x2000498c

08032190 <LmhpFirmwareManagementProcess>:

static void LmhpFirmwareManagementProcess(void)
{
  /* Not yet implemented */
}
 8032190:	4770      	bx	lr

08032192 <OnRebootTimer>:
    LmHandlerSetDutyCycleEnable(current_dutycycle);
  }
}

static void OnRebootTimer(void *context)
{
 8032192:	b508      	push	{r3, lr}
  NVIC_SystemReset();
 8032194:	f7ff ffdc 	bl	8032150 <__NVIC_SystemReset>

08032198 <LmhpFirmwareManagementOnMcpsIndication>:
{
 8032198:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_DELETE_IMAGE_ANS;
 803219c:	f8df a1d4 	ldr.w	sl, [pc, #468]	; 8032374 <LmhpFirmwareManagementOnMcpsIndication+0x1dc>
  uint8_t dataBufferIndex = 0;
 80321a0:	2400      	movs	r4, #0
{
 80321a2:	4680      	mov	r8, r0
  uint8_t cmdIndex = 0;
 80321a4:	4623      	mov	r3, r4
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_DELETE_IMAGE_ANS;
 80321a6:	f04f 0905 	mov.w	r9, #5
            TimerSetValue(&RebootTimer, rebootCountdown * 1000);
 80321aa:	f10a 0708 	add.w	r7, sl, #8
  while (cmdIndex < mcpsIndication->BufferSize)
 80321ae:	f898 200c 	ldrb.w	r2, [r8, #12]
 80321b2:	429a      	cmp	r2, r3
 80321b4:	d81d      	bhi.n	80321f2 <LmhpFirmwareManagementOnMcpsIndication+0x5a>
  if (dataBufferIndex != 0)
 80321b6:	b1cc      	cbz	r4, 80321ec <LmhpFirmwareManagementOnMcpsIndication+0x54>
    LmHandlerAppData_t appData =
 80321b8:	23cb      	movs	r3, #203	; 0xcb
 80321ba:	f88d 3008 	strb.w	r3, [sp, #8]
      .Buffer = LmhpFirmwareManagementState.DataBuffer,
 80321be:	4b6d      	ldr	r3, [pc, #436]	; (8032374 <LmhpFirmwareManagementOnMcpsIndication+0x1dc>)
    LmHandlerAppData_t appData =
 80321c0:	f88d 4009 	strb.w	r4, [sp, #9]
 80321c4:	685b      	ldr	r3, [r3, #4]
 80321c6:	9303      	str	r3, [sp, #12]
    LmHandlerGetDutyCycleEnable(&current_dutycycle);
 80321c8:	f10d 0007 	add.w	r0, sp, #7
 80321cc:	f7ff fc82 	bl	8031ad4 <LmHandlerGetDutyCycleEnable>
    LmHandlerSetDutyCycleEnable(false);
 80321d0:	2000      	movs	r0, #0
 80321d2:	f7ff fc8b 	bl	8031aec <LmHandlerSetDutyCycleEnable>
    LmhpFirmwareManagementPackage.OnSendRequest(&appData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true);
 80321d6:	4b68      	ldr	r3, [pc, #416]	; (8032378 <LmhpFirmwareManagementOnMcpsIndication+0x1e0>)
 80321d8:	2200      	movs	r2, #0
 80321da:	6a9c      	ldr	r4, [r3, #40]	; 0x28
 80321dc:	4611      	mov	r1, r2
 80321de:	2301      	movs	r3, #1
 80321e0:	a802      	add	r0, sp, #8
 80321e2:	47a0      	blx	r4
    LmHandlerSetDutyCycleEnable(current_dutycycle);
 80321e4:	f89d 0007 	ldrb.w	r0, [sp, #7]
 80321e8:	f7ff fc80 	bl	8031aec <LmHandlerSetDutyCycleEnable>
}
 80321ec:	b004      	add	sp, #16
 80321ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    switch (mcpsIndication->Buffer[cmdIndex++])
 80321f2:	f8d8 2008 	ldr.w	r2, [r8, #8]
 80321f6:	5cd1      	ldrb	r1, [r2, r3]
 80321f8:	1c5e      	adds	r6, r3, #1
 80321fa:	b2f6      	uxtb	r6, r6
 80321fc:	2905      	cmp	r1, #5
 80321fe:	d832      	bhi.n	8032266 <LmhpFirmwareManagementOnMcpsIndication+0xce>
 8032200:	e8df f001 	tbb	[pc, r1]
 8032204:	73331103 	.word	0x73331103
 8032208:	aea3      	.short	0xaea3
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_PKG_VERSION_ANS;
 803220a:	1c61      	adds	r1, r4, #1
 803220c:	f8da 2004 	ldr.w	r2, [sl, #4]
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_ID;
 8032210:	b2c9      	uxtb	r1, r1
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_PKG_VERSION_ANS;
 8032212:	2300      	movs	r3, #0
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_ID;
 8032214:	2004      	movs	r0, #4
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_PKG_VERSION_ANS;
 8032216:	5513      	strb	r3, [r2, r4]
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_ID;
 8032218:	1ca3      	adds	r3, r4, #2
 803221a:	5450      	strb	r0, [r2, r1]
 803221c:	b2db      	uxtb	r3, r3
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_VERSION;
 803221e:	3403      	adds	r4, #3
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = 0x01;
 8032220:	b2e4      	uxtb	r4, r4
 8032222:	2101      	movs	r1, #1
 8032224:	e09a      	b.n	803235c <LmhpFirmwareManagementOnMcpsIndication+0x1c4>
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_VERSION_ANS;
 8032226:	2201      	movs	r2, #1
 8032228:	f8da 3004 	ldr.w	r3, [sl, #4]
 803222c:	18a1      	adds	r1, r4, r2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (FW_VERSION >> 0) & 0xFF;
 803222e:	b2c9      	uxtb	r1, r1
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_VERSION_ANS;
 8032230:	551a      	strb	r2, [r3, r4]
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (FW_VERSION >> 0) & 0xFF;
 8032232:	2200      	movs	r2, #0
 8032234:	545a      	strb	r2, [r3, r1]
 8032236:	1ca1      	adds	r1, r4, #2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (FW_VERSION >> 8) & 0xFF;
 8032238:	b2c9      	uxtb	r1, r1
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (HW_VERSION >> 8) & 0xFF;
 803223a:	1de0      	adds	r0, r4, #7
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (FW_VERSION >> 8) & 0xFF;
 803223c:	545a      	strb	r2, [r3, r1]
 803223e:	1ce1      	adds	r1, r4, #3
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (FW_VERSION >> 16) & 0xFF;
 8032240:	b2c9      	uxtb	r1, r1
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (HW_VERSION >> 16) & 0xFF;
 8032242:	b2c0      	uxtb	r0, r0
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (FW_VERSION >> 16) & 0xFF;
 8032244:	545a      	strb	r2, [r3, r1]
 8032246:	1d21      	adds	r1, r4, #4
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (FW_VERSION >> 24) & 0xFF;
 8032248:	b2c9      	uxtb	r1, r1
 803224a:	545a      	strb	r2, [r3, r1]
 803224c:	1d61      	adds	r1, r4, #5
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (HW_VERSION >> 0) & 0xFF;
 803224e:	b2c9      	uxtb	r1, r1
 8032250:	545a      	strb	r2, [r3, r1]
 8032252:	1da1      	adds	r1, r4, #6
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (HW_VERSION >> 8) & 0xFF;
 8032254:	b2c9      	uxtb	r1, r1
 8032256:	545a      	strb	r2, [r3, r1]
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (HW_VERSION >> 16) & 0xFF;
 8032258:	f104 0108 	add.w	r1, r4, #8
 803225c:	b2c9      	uxtb	r1, r1
 803225e:	541a      	strb	r2, [r3, r0]
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (HW_VERSION >> 24) & 0xFF;
 8032260:	3409      	adds	r4, #9
 8032262:	545a      	strb	r2, [r3, r1]
 8032264:	b2e4      	uxtb	r4, r4
{
 8032266:	4633      	mov	r3, r6
 8032268:	e7a1      	b.n	80321ae <LmhpFirmwareManagementOnMcpsIndication+0x16>
        rebootTimeReq  = (mcpsIndication->Buffer[cmdIndex++] << 0) & 0x000000FF;
 803226a:	1c99      	adds	r1, r3, #2
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 8) & 0x0000FF00;
 803226c:	b2c9      	uxtb	r1, r1
        rebootTimeReq  = (mcpsIndication->Buffer[cmdIndex++] << 0) & 0x000000FF;
 803226e:	5d90      	ldrb	r0, [r2, r6]
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 8) & 0x0000FF00;
 8032270:	5c56      	ldrb	r6, [r2, r1]
 8032272:	1cd9      	adds	r1, r3, #3
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 16) & 0x00FF0000;
 8032274:	b2c9      	uxtb	r1, r1
 8032276:	5c55      	ldrb	r5, [r2, r1]
 8032278:	042d      	lsls	r5, r5, #16
 803227a:	eb05 2506 	add.w	r5, r5, r6, lsl #8
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 24) & 0xFF000000;
 803227e:	1d5e      	adds	r6, r3, #5
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 16) & 0x00FF0000;
 8032280:	3304      	adds	r3, #4
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 24) & 0xFF000000;
 8032282:	b2db      	uxtb	r3, r3
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 16) & 0x00FF0000;
 8032284:	4405      	add	r5, r0
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 24) & 0xFF000000;
 8032286:	5cd3      	ldrb	r3, [r2, r3]
        if (rebootTimeReq == 0)
 8032288:	eb15 6503 	adds.w	r5, r5, r3, lsl #24
        rebootTimeReq += (mcpsIndication->Buffer[cmdIndex++] << 24) & 0xFF000000;
 803228c:	b2f6      	uxtb	r6, r6
        if (rebootTimeReq == 0)
 803228e:	d101      	bne.n	8032294 <LmhpFirmwareManagementOnMcpsIndication+0xfc>
          NVIC_SystemReset();
 8032290:	f7ff ff5e 	bl	8032150 <__NVIC_SystemReset>
        else if (rebootTimeReq == 0xFFFFFFFF)
 8032294:	1c6b      	adds	r3, r5, #1
 8032296:	d118      	bne.n	80322ca <LmhpFirmwareManagementOnMcpsIndication+0x132>
          TimerStop(&RebootTimer);
 8032298:	4638      	mov	r0, r7
 803229a:	f009 f825 	bl	803b2e8 <UTIL_TIMER_Stop>
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_REBOOT_TIME_ANS;
 803229e:	f8da 3004 	ldr.w	r3, [sl, #4]
 80322a2:	2202      	movs	r2, #2
 80322a4:	551a      	strb	r2, [r3, r4]
 80322a6:	1c62      	adds	r2, r4, #1
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 0) & 0xFF;
 80322a8:	b2d2      	uxtb	r2, r2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 8) & 0xFF;
 80322aa:	0a29      	lsrs	r1, r5, #8
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 0) & 0xFF;
 80322ac:	549d      	strb	r5, [r3, r2]
 80322ae:	1ca2      	adds	r2, r4, #2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 8) & 0xFF;
 80322b0:	b2d2      	uxtb	r2, r2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 16) & 0xFF;
 80322b2:	0c28      	lsrs	r0, r5, #16
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 8) & 0xFF;
 80322b4:	5499      	strb	r1, [r3, r2]
 80322b6:	1ce1      	adds	r1, r4, #3
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 16) & 0xFF;
 80322b8:	b2c9      	uxtb	r1, r1
 80322ba:	1d22      	adds	r2, r4, #4
 80322bc:	5458      	strb	r0, [r3, r1]
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 24) & 0xFF;
 80322be:	3405      	adds	r4, #5
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 16) & 0xFF;
 80322c0:	b2d2      	uxtb	r2, r2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootTimeAns >> 24) & 0xFF;
 80322c2:	b2e4      	uxtb	r4, r4
 80322c4:	0e2d      	lsrs	r5, r5, #24
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootCountdown >> 16) & 0xFF;
 80322c6:	549d      	strb	r5, [r3, r2]
        break;
 80322c8:	e7cd      	b.n	8032266 <LmhpFirmwareManagementOnMcpsIndication+0xce>
          curTime = SysTimeGet();
 80322ca:	a802      	add	r0, sp, #8
 80322cc:	f008 ff1e 	bl	803b10c <SysTimeGet>
          rebootTimeAns = rebootTimeReq - curTime.Seconds;
 80322d0:	9b02      	ldr	r3, [sp, #8]
          if (rebootTimeAns > 0)
 80322d2:	1aed      	subs	r5, r5, r3
 80322d4:	d0e3      	beq.n	803229e <LmhpFirmwareManagementOnMcpsIndication+0x106>
            TimerSetValue(&RebootTimer, rebootTimeAns * 1000);
 80322d6:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 80322da:	4369      	muls	r1, r5
 80322dc:	4638      	mov	r0, r7
 80322de:	f009 f88d 	bl	803b3fc <UTIL_TIMER_SetPeriod>
            TimerStart(&RebootTimer);
 80322e2:	4638      	mov	r0, r7
 80322e4:	f009 f850 	bl	803b388 <UTIL_TIMER_Start>
 80322e8:	e7d9      	b.n	803229e <LmhpFirmwareManagementOnMcpsIndication+0x106>
        rebootCountdown  = (mcpsIndication->Buffer[cmdIndex++] << 0) & 0x000000FF;
 80322ea:	5d91      	ldrb	r1, [r2, r6]
 80322ec:	1c98      	adds	r0, r3, #2
        rebootCountdown += (mcpsIndication->Buffer[cmdIndex++] << 16) & 0x00FF0000;
 80322ee:	1d1e      	adds	r6, r3, #4
        rebootCountdown += (mcpsIndication->Buffer[cmdIndex++] << 8) & 0x0000FF00;
 80322f0:	3303      	adds	r3, #3
        rebootCountdown += (mcpsIndication->Buffer[cmdIndex++] << 16) & 0x00FF0000;
 80322f2:	b2db      	uxtb	r3, r3
        rebootCountdown += (mcpsIndication->Buffer[cmdIndex++] << 8) & 0x0000FF00;
 80322f4:	b2c0      	uxtb	r0, r0
        rebootCountdown += (mcpsIndication->Buffer[cmdIndex++] << 16) & 0x00FF0000;
 80322f6:	5cd5      	ldrb	r5, [r2, r3]
        rebootCountdown += (mcpsIndication->Buffer[cmdIndex++] << 8) & 0x0000FF00;
 80322f8:	5c10      	ldrb	r0, [r2, r0]
        rebootCountdown += (mcpsIndication->Buffer[cmdIndex++] << 16) & 0x00FF0000;
 80322fa:	042d      	lsls	r5, r5, #16
 80322fc:	eb05 2500 	add.w	r5, r5, r0, lsl #8
        if (rebootCountdown == 0)
 8032300:	186d      	adds	r5, r5, r1
        rebootCountdown += (mcpsIndication->Buffer[cmdIndex++] << 16) & 0x00FF0000;
 8032302:	b2f6      	uxtb	r6, r6
        if (rebootCountdown == 0)
 8032304:	d0c4      	beq.n	8032290 <LmhpFirmwareManagementOnMcpsIndication+0xf8>
        else if (rebootCountdown == 0xFFFFFF)
 8032306:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 803230a:	429d      	cmp	r5, r3
 803230c:	d113      	bne.n	8032336 <LmhpFirmwareManagementOnMcpsIndication+0x19e>
          TimerStop(&RebootTimer);
 803230e:	4638      	mov	r0, r7
 8032310:	f008 ffea 	bl	803b2e8 <UTIL_TIMER_Stop>
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_REBOOT_COUNTDOWN_ANS;
 8032314:	f8da 3004 	ldr.w	r3, [sl, #4]
 8032318:	2203      	movs	r2, #3
 803231a:	551a      	strb	r2, [r3, r4]
 803231c:	1c62      	adds	r2, r4, #1
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootCountdown >> 0) & 0xFF;
 803231e:	b2d2      	uxtb	r2, r2
 8032320:	1ca1      	adds	r1, r4, #2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootCountdown >> 8) & 0xFF;
 8032322:	b2c9      	uxtb	r1, r1
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootCountdown >> 0) & 0xFF;
 8032324:	549d      	strb	r5, [r3, r2]
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootCountdown >> 8) & 0xFF;
 8032326:	0a28      	lsrs	r0, r5, #8
 8032328:	1ce2      	adds	r2, r4, #3
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootCountdown >> 16) & 0xFF;
 803232a:	3404      	adds	r4, #4
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootCountdown >> 8) & 0xFF;
 803232c:	5458      	strb	r0, [r3, r1]
 803232e:	b2d2      	uxtb	r2, r2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = (rebootCountdown >> 16) & 0xFF;
 8032330:	b2e4      	uxtb	r4, r4
 8032332:	0c2d      	lsrs	r5, r5, #16
 8032334:	e7c7      	b.n	80322c6 <LmhpFirmwareManagementOnMcpsIndication+0x12e>
            TimerSetValue(&RebootTimer, rebootCountdown * 1000);
 8032336:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 803233a:	4369      	muls	r1, r5
 803233c:	4638      	mov	r0, r7
 803233e:	f009 f85d 	bl	803b3fc <UTIL_TIMER_SetPeriod>
            TimerStart(&RebootTimer);
 8032342:	4638      	mov	r0, r7
 8032344:	f009 f820 	bl	803b388 <UTIL_TIMER_Start>
 8032348:	e7e4      	b.n	8032314 <LmhpFirmwareManagementOnMcpsIndication+0x17c>
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_UPGRADE_IMAGE_ANS;
 803234a:	f8da 2004 	ldr.w	r2, [sl, #4]
 803234e:	2104      	movs	r1, #4
 8032350:	5511      	strb	r1, [r2, r4]
 8032352:	1c63      	adds	r3, r4, #1
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = imageStatus & 0x03;
 8032354:	3402      	adds	r4, #2
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_UPGRADE_IMAGE_ANS;
 8032356:	b2db      	uxtb	r3, r3
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = imageStatus & 0x03;
 8032358:	b2e4      	uxtb	r4, r4
 803235a:	2100      	movs	r1, #0
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = 0x01;
 803235c:	54d1      	strb	r1, [r2, r3]
        break;
 803235e:	e782      	b.n	8032266 <LmhpFirmwareManagementOnMcpsIndication+0xce>
        firmwareVersion += (mcpsIndication->Buffer[cmdIndex++] << 24) & 0xFF000000;
 8032360:	3305      	adds	r3, #5
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_DELETE_IMAGE_ANS;
 8032362:	f8da 2004 	ldr.w	r2, [sl, #4]
        firmwareVersion += (mcpsIndication->Buffer[cmdIndex++] << 24) & 0xFF000000;
 8032366:	b2de      	uxtb	r6, r3
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = FW_MANAGEMENT_DEV_DELETE_IMAGE_ANS;
 8032368:	1c63      	adds	r3, r4, #1
 803236a:	f802 9004 	strb.w	r9, [r2, r4]
 803236e:	b2db      	uxtb	r3, r3
        LmhpFirmwareManagementState.DataBuffer[dataBufferIndex++] = 0x01;
 8032370:	3402      	adds	r4, #2
 8032372:	e755      	b.n	8032220 <LmhpFirmwareManagementOnMcpsIndication+0x88>
 8032374:	2000498c 	.word	0x2000498c
 8032378:	200034f8 	.word	0x200034f8

0803237c <LmhpFirmwareManagementInit>:
{
 803237c:	b507      	push	{r0, r1, r2, lr}
 803237e:	480a      	ldr	r0, [pc, #40]	; (80323a8 <LmhpFirmwareManagementInit+0x2c>)
  if (dataBuffer != NULL)
 8032380:	b179      	cbz	r1, 80323a2 <LmhpFirmwareManagementInit+0x26>
    LmhpFirmwareManagementState.DataBufferMaxSize = dataBufferMaxSize;
 8032382:	7082      	strb	r2, [r0, #2]
    LmhpFirmwareManagementState.Initialized = true;
 8032384:	f240 1301 	movw	r3, #257	; 0x101
    TimerInit(&RebootTimer, OnRebootTimer);
 8032388:	2200      	movs	r2, #0
    LmhpFirmwareManagementState.DataBuffer = dataBuffer;
 803238a:	6041      	str	r1, [r0, #4]
    LmhpFirmwareManagementState.Initialized = true;
 803238c:	f820 3b08 	strh.w	r3, [r0], #8
    TimerInit(&RebootTimer, OnRebootTimer);
 8032390:	f04f 31ff 	mov.w	r1, #4294967295
 8032394:	4b05      	ldr	r3, [pc, #20]	; (80323ac <LmhpFirmwareManagementInit+0x30>)
 8032396:	9200      	str	r2, [sp, #0]
 8032398:	f008 ff48 	bl	803b22c <UTIL_TIMER_Create>
}
 803239c:	b003      	add	sp, #12
 803239e:	f85d fb04 	ldr.w	pc, [sp], #4
    LmhpFirmwareManagementState.Initialized = false;
 80323a2:	8001      	strh	r1, [r0, #0]
}
 80323a4:	e7fa      	b.n	803239c <LmhpFirmwareManagementInit+0x20>
 80323a6:	bf00      	nop
 80323a8:	2000498c 	.word	0x2000498c
 80323ac:	08032193 	.word	0x08032193

080323b0 <LmhpFirmwareManagementPackageFactory>:
}
 80323b0:	4800      	ldr	r0, [pc, #0]	; (80323b4 <LmhpFirmwareManagementPackageFactory+0x4>)
 80323b2:	4770      	bx	lr
 80323b4:	200034f8 	.word	0x200034f8

080323b8 <LmhpFragmentationIsInitialized>:
}

static bool LmhpFragmentationIsInitialized( void )
{
    return LmhpFragmentationState.Initialized;
}
 80323b8:	4b01      	ldr	r3, [pc, #4]	; (80323c0 <LmhpFragmentationIsInitialized+0x8>)
 80323ba:	7818      	ldrb	r0, [r3, #0]
 80323bc:	4770      	bx	lr
 80323be:	bf00      	nop
 80323c0:	200049ac 	.word	0x200049ac

080323c4 <LmhpFragmentationIsRunning>:

static bool LmhpFragmentationIsRunning( void )
{
    if( LmhpFragmentationState.Initialized == false )
 80323c4:	4b02      	ldr	r3, [pc, #8]	; (80323d0 <LmhpFragmentationIsRunning+0xc>)
 80323c6:	7818      	ldrb	r0, [r3, #0]
 80323c8:	b100      	cbz	r0, 80323cc <LmhpFragmentationIsRunning+0x8>
    {
        return false;
    }

    return LmhpFragmentationState.IsRunning;
 80323ca:	7858      	ldrb	r0, [r3, #1]
}
 80323cc:	4770      	bx	lr
 80323ce:	bf00      	nop
 80323d0:	200049ac 	.word	0x200049ac

080323d4 <LmhpFragmentationInit>:
{
 80323d4:	b513      	push	{r0, r1, r4, lr}
 80323d6:	4c0f      	ldr	r4, [pc, #60]	; (8032414 <LmhpFragmentationInit+0x40>)
    if( ( params != NULL ) && ( dataBuffer != NULL ) )
 80323d8:	b1c0      	cbz	r0, 803240c <LmhpFragmentationInit+0x38>
 80323da:	b1b9      	cbz	r1, 803240c <LmhpFragmentationInit+0x38>
        LmhpFragmentationState.Initialized = true;
 80323dc:	f240 1301 	movw	r3, #257	; 0x101
        LmhpFragmentationState.DataBufferMaxSize = dataBufferMaxSize;
 80323e0:	70e2      	strb	r2, [r4, #3]
        TxDelayTime = 0;
 80323e2:	2200      	movs	r2, #0
        LmhpFragmentationParams = ( LmhpFragmentationParams_t* )params;
 80323e4:	60e0      	str	r0, [r4, #12]
        LmhpFragmentationState.DataBuffer = dataBuffer;
 80323e6:	6061      	str	r1, [r4, #4]
        LmhpFragmentationState.Initialized = true;
 80323e8:	8023      	strh	r3, [r4, #0]
        TimerInit( &FragmentTxDelayTimer, OnFragmentTxDelay );
 80323ea:	9200      	str	r2, [sp, #0]
 80323ec:	4b0a      	ldr	r3, [pc, #40]	; (8032418 <LmhpFragmentationInit+0x44>)
        TxDelayTime = 0;
 80323ee:	6122      	str	r2, [r4, #16]
        TimerInit( &FragmentTxDelayTimer, OnFragmentTxDelay );
 80323f0:	f04f 31ff 	mov.w	r1, #4294967295
 80323f4:	f104 0014 	add.w	r0, r4, #20
 80323f8:	f008 ff18 	bl	803b22c <UTIL_TIMER_Create>
    UTIL_MEM_set_8( FragSessionData, 0, sizeof(FragSessionData) );
 80323fc:	4807      	ldr	r0, [pc, #28]	; (803241c <LmhpFragmentationInit+0x48>)
 80323fe:	2260      	movs	r2, #96	; 0x60
 8032400:	2100      	movs	r1, #0
}
 8032402:	b002      	add	sp, #8
 8032404:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    UTIL_MEM_set_8( FragSessionData, 0, sizeof(FragSessionData) );
 8032408:	f008 bd5e 	b.w	803aec8 <UTIL_MEM_set_8>
        LmhpFragmentationParams = NULL;
 803240c:	2300      	movs	r3, #0
 803240e:	60e3      	str	r3, [r4, #12]
        LmhpFragmentationState.Initialized = false;
 8032410:	8023      	strh	r3, [r4, #0]
 8032412:	e7f3      	b.n	80323fc <LmhpFragmentationInit+0x28>
 8032414:	200049ac 	.word	0x200049ac
 8032418:	08032421 	.word	0x08032421
 803241c:	200049d8 	.word	0x200049d8

08032420 <OnFragmentTxDelay>:
{
 8032420:	b510      	push	{r4, lr}
    TimerStop( &FragmentTxDelayTimer );
 8032422:	4c06      	ldr	r4, [pc, #24]	; (803243c <OnFragmentTxDelay+0x1c>)
 8032424:	f104 0014 	add.w	r0, r4, #20
 8032428:	f008 ff5e 	bl	803b2e8 <UTIL_TIMER_Stop>
    LmhpFragmentationState.TxDelayState = FRAGMENTATION_TX_DELAY_STATE_PENDING;
 803242c:	2302      	movs	r3, #2
 803242e:	70a3      	strb	r3, [r4, #2]
    LmhpFragmentationPackage.OnPackageProcessEvent();
 8032430:	4b03      	ldr	r3, [pc, #12]	; (8032440 <OnFragmentTxDelay+0x20>)
}
 8032432:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    LmhpFragmentationPackage.OnPackageProcessEvent();
 8032436:	695b      	ldr	r3, [r3, #20]
 8032438:	4718      	bx	r3
 803243a:	bf00      	nop
 803243c:	200049ac 	.word	0x200049ac
 8032440:	2000352c 	.word	0x2000352c

08032444 <LmhpFragmentationOnMcpsIndication>:
            break;
    }
}

static void LmhpFragmentationOnMcpsIndication( McpsIndication_t *mcpsIndication )
{
 8032444:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    // Answer struct for the commands.
    LmHandlerAppData_t cmdReplyAppData;
    // Co-efficient used to calculate delay.
    uint8_t blockAckDelay = 0;

    if( mcpsIndication->Port != FRAGMENTATION_PORT )
 8032448:	78c3      	ldrb	r3, [r0, #3]
 803244a:	2bc9      	cmp	r3, #201	; 0xc9
{
 803244c:	b093      	sub	sp, #76	; 0x4c
 803244e:	4607      	mov	r7, r0
    if( mcpsIndication->Port != FRAGMENTATION_PORT )
 8032450:	d12a      	bne.n	80324a8 <LmhpFragmentationOnMcpsIndication+0x64>
    uint8_t blockAckDelay = 0;
 8032452:	2300      	movs	r3, #0
                fragCounter = ( mcpsIndication->Buffer[cmdIndex++] << 0 ) & 0x00FF;
                fragCounter |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;

                fragIndex = ( fragCounter >> 14 ) & 0x03;
                fragCounter &= 0x3FFF;
                if (FragSessionData[fragIndex].FragGroupData.IsActive == false)
 8032454:	4eb8      	ldr	r6, [pc, #736]	; (8032738 <LmhpFragmentationOnMcpsIndication+0x2f4>)
    uint8_t blockAckDelay = 0;
 8032456:	9301      	str	r3, [sp, #4]
    bool isAnswerDelayed = false;
 8032458:	4699      	mov	r9, r3
    uint8_t dataBufferIndex = 0;
 803245a:	461c      	mov	r4, r3
    uint8_t cmdIndex = 0;
 803245c:	469b      	mov	fp, r3
    while( cmdIndex < mcpsIndication->BufferSize )
 803245e:	7b39      	ldrb	r1, [r7, #12]
 8032460:	458b      	cmp	fp, r1
 8032462:	d324      	bcc.n	80324ae <LmhpFragmentationOnMcpsIndication+0x6a>

    // After processing the commands, if the end-node has to reply back then a flag is checked if the
    // reply is to be sent immediately or with a delay.
    // In some scenarios it is not desired that multiple end-notes send uplinks at the same time to
    // the same server. (Example: Fragment status during a multicast FUOTA)
    if( dataBufferIndex != 0 )
 8032464:	b304      	cbz	r4, 80324a8 <LmhpFragmentationOnMcpsIndication+0x64>
    {
        // Prepare Answer that is to be transmitted
        cmdReplyAppData.Buffer = LmhpFragmentationState.DataBuffer;
 8032466:	4db4      	ldr	r5, [pc, #720]	; (8032738 <LmhpFragmentationOnMcpsIndication+0x2f4>)
        cmdReplyAppData.BufferSize = dataBufferIndex;
 8032468:	f88d 4031 	strb.w	r4, [sp, #49]	; 0x31
        cmdReplyAppData.Buffer = LmhpFragmentationState.DataBuffer;
 803246c:	686b      	ldr	r3, [r5, #4]
 803246e:	930d      	str	r3, [sp, #52]	; 0x34
        cmdReplyAppData.Port = FRAGMENTATION_PORT;
 8032470:	23c9      	movs	r3, #201	; 0xc9
 8032472:	4eb2      	ldr	r6, [pc, #712]	; (803273c <LmhpFragmentationOnMcpsIndication+0x2f8>)
 8032474:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30

        if( isAnswerDelayed == true )
 8032478:	ac0c      	add	r4, sp, #48	; 0x30
 803247a:	f1b9 0f00 	cmp.w	r9, #0
 803247e:	f000 81ae 	beq.w	80327de <LmhpFragmentationOnMcpsIndication+0x39a>
            // Delay = Pseudo Random Delay * 1000 milli seconds.
            // Eg: blockAckDelay = 7
            //     Pseudo Random Delay = rand(0:1) * 2^11
            //     rand(0:1) seconds = rand(0:1000) milliseconds
            //     Delay = rand(0:1000) * 2048 => 2048000ms = 34 minutes
            TxDelayTime = randr( 0, 1000 ) * ( 1 << ( blockAckDelay + 4 ) );
 8032482:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8032486:	2000      	movs	r0, #0
 8032488:	f006 fd0a 	bl	8038ea0 <randr>
 803248c:	9b01      	ldr	r3, [sp, #4]
 803248e:	3304      	adds	r3, #4
 8032490:	fa00 f303 	lsl.w	r3, r0, r3
            DelayedReplyAppData = cmdReplyAppData;
 8032494:	e894 0003 	ldmia.w	r4, {r0, r1}
            TxDelayTime = randr( 0, 1000 ) * ( 1 << ( blockAckDelay + 4 ) );
 8032498:	612b      	str	r3, [r5, #16]
            DelayedReplyAppData = cmdReplyAppData;
 803249a:	4ba9      	ldr	r3, [pc, #676]	; (8032740 <LmhpFragmentationOnMcpsIndication+0x2fc>)
 803249c:	e883 0003 	stmia.w	r3, {r0, r1}
            LmhpFragmentationState.TxDelayState = FRAGMENTATION_TX_DELAY_STATE_START;
 80324a0:	2301      	movs	r3, #1
 80324a2:	70ab      	strb	r3, [r5, #2]
            LmhpFragmentationPackage.OnPackageProcessEvent();
 80324a4:	6973      	ldr	r3, [r6, #20]
 80324a6:	4798      	blx	r3

            /* restore initial Duty Cycle */
            LmHandlerSetDutyCycleEnable( current_dutycycle );
        }
    }
}
 80324a8:	b013      	add	sp, #76	; 0x4c
 80324aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        switch( mcpsIndication->Buffer[cmdIndex++] )
 80324ae:	68bb      	ldr	r3, [r7, #8]
 80324b0:	f813 200b 	ldrb.w	r2, [r3, fp]
 80324b4:	f10b 0a01 	add.w	sl, fp, #1
 80324b8:	fa5f fa8a 	uxtb.w	sl, sl
 80324bc:	2a08      	cmp	r2, #8
 80324be:	d81a      	bhi.n	80324f6 <LmhpFragmentationOnMcpsIndication+0xb2>
 80324c0:	e8df f012 	tbh	[pc, r2, lsl #1]
 80324c4:	001b0009 	.word	0x001b0009
 80324c8:	00ef005d 	.word	0x00ef005d
 80324cc:	00190019 	.word	0x00190019
 80324d0:	00190019 	.word	0x00190019
 80324d4:	0111      	.short	0x0111
                if( mcpsIndication->Multicast == 1 )
 80324d6:	78bb      	ldrb	r3, [r7, #2]
 80324d8:	2b01      	cmp	r3, #1
 80324da:	d00c      	beq.n	80324f6 <LmhpFragmentationOnMcpsIndication+0xb2>
                LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FRAGMENTATION_PKG_VERSION_ANS;
 80324dc:	6872      	ldr	r2, [r6, #4]
 80324de:	2300      	movs	r3, #0
 80324e0:	1c61      	adds	r1, r4, #1
 80324e2:	5513      	strb	r3, [r2, r4]
                LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FRAGMENTATION_ID;
 80324e4:	b2c9      	uxtb	r1, r1
 80324e6:	1ca3      	adds	r3, r4, #2
 80324e8:	2003      	movs	r0, #3
 80324ea:	b2db      	uxtb	r3, r3
 80324ec:	5450      	strb	r0, [r2, r1]
                LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FRAGMENTATION_VERSION;
 80324ee:	2101      	movs	r1, #1
 80324f0:	4404      	add	r4, r0
 80324f2:	54d1      	strb	r1, [r2, r3]
 80324f4:	b2e4      	uxtb	r4, r4
                break;
 80324f6:	46d3      	mov	fp, sl
 80324f8:	e7b1      	b.n	803245e <LmhpFragmentationOnMcpsIndication+0x1a>
                uint8_t fragIndex = mcpsIndication->Buffer[cmdIndex++];
 80324fa:	f813 a00a 	ldrb.w	sl, [r3, sl]
                FragSessionData[fragIndex].FragDecoderStatus = FragDecoderGetStatus( );
 80324fe:	a808      	add	r0, sp, #32
 8032500:	2318      	movs	r3, #24
 8032502:	f3ca 0541 	ubfx	r5, sl, #1, #2
 8032506:	fb03 6805 	mla	r8, r3, r5, r6
 803250a:	f7fe fef9 	bl	8031300 <FragDecoderGetStatus>
 803250e:	9808      	ldr	r0, [sp, #32]
 8032510:	9909      	ldr	r1, [sp, #36]	; 0x24
                uint8_t fragIndex = mcpsIndication->Buffer[cmdIndex++];
 8032512:	f10b 0b02 	add.w	fp, fp, #2
                FragSessionData[fragIndex].FragDecoderStatus = FragDecoderGetStatus( );
 8032516:	f108 0338 	add.w	r3, r8, #56	; 0x38
                if( ( participants == 1 ) ||
 803251a:	f01a 0f01 	tst.w	sl, #1
                FragSessionData[fragIndex].FragDecoderStatus = FragDecoderGetStatus( );
 803251e:	c303      	stmia	r3!, {r0, r1}
                uint8_t fragIndex = mcpsIndication->Buffer[cmdIndex++];
 8032520:	fa5f fb8b 	uxtb.w	fp, fp
                if( ( participants == 1 ) ||
 8032524:	d102      	bne.n	803252c <LmhpFragmentationOnMcpsIndication+0xe8>
                    ( ( participants == 0 ) && ( FragSessionData[fragIndex].FragDecoderStatus.FragNbLost > 0 ) ) )
 8032526:	f8b8 303a 	ldrh.w	r3, [r8, #58]	; 0x3a
 803252a:	b333      	cbz	r3, 803257a <LmhpFragmentationOnMcpsIndication+0x136>
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FRAGMENTATION_FRAG_STATUS_ANS;
 803252c:	6872      	ldr	r2, [r6, #4]
 803252e:	f04f 0901 	mov.w	r9, #1
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.FragNbRx & 0xFF;
 8032532:	2318      	movs	r3, #24
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FRAGMENTATION_FRAG_STATUS_ANS;
 8032534:	f802 9004 	strb.w	r9, [r2, r4]
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.FragNbRx & 0xFF;
 8032538:	fb03 6305 	mla	r3, r3, r5, r6
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FRAGMENTATION_FRAG_STATUS_ANS;
 803253c:	eb04 0109 	add.w	r1, r4, r9
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.FragNbRx & 0xFF;
 8032540:	b2c9      	uxtb	r1, r1
 8032542:	8f18      	ldrh	r0, [r3, #56]	; 0x38
 8032544:	5450      	strb	r0, [r2, r1]
                                                                           ( ( FragSessionData[fragIndex].FragDecoderStatus.FragNbRx >> 8 ) & 0x3F );
 8032546:	8f19      	ldrh	r1, [r3, #56]	; 0x38
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.FragNbRx & 0xFF;
 8032548:	1ca0      	adds	r0, r4, #2
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = ( fragIndex << 6 ) |
 803254a:	b2c0      	uxtb	r0, r0
                                                                           ( ( FragSessionData[fragIndex].FragDecoderStatus.FragNbRx >> 8 ) & 0x3F );
 803254c:	f3c1 2105 	ubfx	r1, r1, #8, #6
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = ( fragIndex << 6 ) |
 8032550:	ea41 1185 	orr.w	r1, r1, r5, lsl #6
 8032554:	5411      	strb	r1, [r2, r0]
 8032556:	1ce0      	adds	r0, r4, #3
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.FragNbLost;
 8032558:	b2c0      	uxtb	r0, r0
 803255a:	8f5d      	ldrh	r5, [r3, #58]	; 0x3a
 803255c:	5415      	strb	r5, [r2, r0]
 803255e:	1d21      	adds	r1, r4, #4
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.MatrixError & 0x01;
 8032560:	f893 003e 	ldrb.w	r0, [r3, #62]	; 0x3e
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.FragNbLost;
 8032564:	b2c9      	uxtb	r1, r1
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.MatrixError & 0x01;
 8032566:	ea00 0009 	and.w	r0, r0, r9
 803256a:	5450      	strb	r0, [r2, r1]
                    blockAckDelay = FragSessionData[fragIndex].FragGroupData.Control.Fields.BlockAckDelay;
 803256c:	f893 0031 	ldrb.w	r0, [r3, #49]	; 0x31
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.MatrixError & 0x01;
 8032570:	3405      	adds	r4, #5
                    blockAckDelay = FragSessionData[fragIndex].FragGroupData.Control.Fields.BlockAckDelay;
 8032572:	f000 0307 	and.w	r3, r0, #7
                    LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FragSessionData[fragIndex].FragDecoderStatus.MatrixError & 0x01;
 8032576:	b2e4      	uxtb	r4, r4
                    blockAckDelay = FragSessionData[fragIndex].FragGroupData.Control.Fields.BlockAckDelay;
 8032578:	9301      	str	r3, [sp, #4]
                uint8_t fragIndex = mcpsIndication->Buffer[cmdIndex++];
 803257a:	46da      	mov	sl, fp
 803257c:	e7bb      	b.n	80324f6 <LmhpFragmentationOnMcpsIndication+0xb2>
                if( mcpsIndication->Multicast == 1 )
 803257e:	78ba      	ldrb	r2, [r7, #2]
 8032580:	2a01      	cmp	r2, #1
 8032582:	d0b8      	beq.n	80324f6 <LmhpFragmentationOnMcpsIndication+0xb2>
                fragSessionData.FragGroupData.FragSession.Value = mcpsIndication->Buffer[cmdIndex++];
 8032584:	f813 200a 	ldrb.w	r2, [r3, sl]
 8032588:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
                fragSessionData.FragGroupData.FragNb =  ( mcpsIndication->Buffer[cmdIndex++] << 0 ) & 0x00FF;
 803258c:	f10b 0203 	add.w	r2, fp, #3
                fragSessionData.FragGroupData.FragNb |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 8032590:	b2d2      	uxtb	r2, r2
                fragSessionData.FragGroupData.Padding = mcpsIndication->Buffer[cmdIndex++];
 8032592:	f10b 0007 	add.w	r0, fp, #7
                fragSessionData.FragGroupData.FragNb |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 8032596:	5c99      	ldrb	r1, [r3, r2]
                fragSessionData.FragGroupData.FragSession.Value = mcpsIndication->Buffer[cmdIndex++];
 8032598:	f10b 0202 	add.w	r2, fp, #2
                fragSessionData.FragGroupData.FragNb =  ( mcpsIndication->Buffer[cmdIndex++] << 0 ) & 0x00FF;
 803259c:	b2d2      	uxtb	r2, r2
                fragSessionData.FragGroupData.Descriptor =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 803259e:	b2c0      	uxtb	r0, r0
                fragSessionData.FragGroupData.FragNb |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 80325a0:	f813 8002 	ldrb.w	r8, [r3, r2]
                fragSessionData.FragGroupData.Descriptor =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 80325a4:	5c18      	ldrb	r0, [r3, r0]
 80325a6:	9002      	str	r0, [sp, #8]
                fragSessionData.FragGroupData.FragNb |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 80325a8:	f10b 0204 	add.w	r2, fp, #4
                fragSessionData.FragGroupData.FragSize = mcpsIndication->Buffer[cmdIndex++];
 80325ac:	b2d2      	uxtb	r2, r2
                fragSessionData.FragGroupData.Descriptor =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 80325ae:	f10b 0008 	add.w	r0, fp, #8
                fragSessionData.FragGroupData.FragSize = mcpsIndication->Buffer[cmdIndex++];
 80325b2:	f813 9002 	ldrb.w	r9, [r3, r2]
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 80325b6:	b2c0      	uxtb	r0, r0
                fragSessionData.FragGroupData.FragSize = mcpsIndication->Buffer[cmdIndex++];
 80325b8:	f10b 0205 	add.w	r2, fp, #5
                fragSessionData.FragGroupData.Control.Value = mcpsIndication->Buffer[cmdIndex++];
 80325bc:	b2d2      	uxtb	r2, r2
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 80325be:	5c18      	ldrb	r0, [r3, r0]
                fragSessionData.FragGroupData.Control.Value = mcpsIndication->Buffer[cmdIndex++];
 80325c0:	5c9a      	ldrb	r2, [r3, r2]
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 80325c2:	9003      	str	r0, [sp, #12]
                fragSessionData.FragGroupData.FragNb |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 80325c4:	ea48 2801 	orr.w	r8, r8, r1, lsl #8
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 80325c8:	f10b 0009 	add.w	r0, fp, #9
                fragSessionData.FragGroupData.Control.Value = mcpsIndication->Buffer[cmdIndex++];
 80325cc:	f10b 0106 	add.w	r1, fp, #6
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 80325d0:	f10b 0a0b 	add.w	sl, fp, #11
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 80325d4:	f10b 0b0a 	add.w	fp, fp, #10
                fragSessionData.FragGroupData.Padding = mcpsIndication->Buffer[cmdIndex++];
 80325d8:	b2c9      	uxtb	r1, r1
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 80325da:	b2c0      	uxtb	r0, r0
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 80325dc:	fa5f fb8b 	uxtb.w	fp, fp
                if( fragSessionData.FragGroupData.Control.Fields.FragAlgo > 0 )
 80325e0:	f012 0f38 	tst.w	r2, #56	; 0x38
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 80325e4:	5c18      	ldrb	r0, [r3, r0]
                fragSessionData.FragGroupData.Padding = mcpsIndication->Buffer[cmdIndex++];
 80325e6:	5c59      	ldrb	r1, [r3, r1]
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 80325e8:	f813 b00b 	ldrb.w	fp, [r3, fp]
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 80325ec:	9004      	str	r0, [sp, #16]
                    status |= 0x01; // Encoding unsupported
 80325ee:	bf14      	ite	ne
 80325f0:	2301      	movne	r3, #1
 80325f2:	2300      	moveq	r3, #0
                if( ( fragSessionData.FragGroupData.FragNb > FRAG_MAX_NB ) || 
 80325f4:	f5b8 7f33 	cmp.w	r8, #716	; 0x2cc
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 80325f8:	fa5f fa8a 	uxtb.w	sl, sl
                if( ( fragSessionData.FragGroupData.FragNb > FRAG_MAX_NB ) || 
 80325fc:	d941      	bls.n	8032682 <LmhpFragmentationOnMcpsIndication+0x23e>
                    status |= 0x02; // Not enough Memory
 80325fe:	f043 0302 	orr.w	r3, r3, #2
                status |= ( fragSessionData.FragGroupData.FragSession.Fields.FragIndex << 6 ) & 0xC0;
 8032602:	f89d c031 	ldrb.w	ip, [sp, #49]	; 0x31
 8032606:	f3cc 1c01 	ubfx	ip, ip, #4, #2
 803260a:	ea43 158c 	orr.w	r5, r3, ip, lsl #6
                if( ( status & 0x0F ) == 0 )
 803260e:	071b      	lsls	r3, r3, #28
 8032610:	d12c      	bne.n	803266c <LmhpFragmentationOnMcpsIndication+0x228>
                    FragSessionData[fragSessionData.FragGroupData.FragSession.Fields.FragIndex] = fragSessionData;
 8032612:	2301      	movs	r3, #1
 8032614:	f88d 2035 	strb.w	r2, [sp, #53]	; 0x35
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032618:	9a04      	ldr	r2, [sp, #16]
                    FragSessionData[fragSessionData.FragGroupData.FragSession.Fields.FragIndex] = fragSessionData;
 803261a:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 803261e:	ea4f 630b 	mov.w	r3, fp, lsl #24
 8032622:	eb03 4302 	add.w	r3, r3, r2, lsl #16
 8032626:	9a02      	ldr	r2, [sp, #8]
                    FragSessionData[fragSessionData.FragGroupData.FragSession.Fields.FragIndex] = fragSessionData;
 8032628:	f8ad 8032 	strh.w	r8, [sp, #50]	; 0x32
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 803262c:	4413      	add	r3, r2
 803262e:	9a03      	ldr	r2, [sp, #12]
                    FragSessionData[fragSessionData.FragGroupData.FragSession.Fields.FragIndex] = fragSessionData;
 8032630:	f88d 9034 	strb.w	r9, [sp, #52]	; 0x34
                fragSessionData.FragGroupData.Descriptor += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032634:	eb03 2302 	add.w	r3, r3, r2, lsl #8
                    FragSessionData[fragSessionData.FragGroupData.FragSession.Fields.FragIndex] = fragSessionData;
 8032638:	930e      	str	r3, [sp, #56]	; 0x38
 803263a:	f04f 33ff 	mov.w	r3, #4294967295
 803263e:	9311      	str	r3, [sp, #68]	; 0x44
 8032640:	f88d 1036 	strb.w	r1, [sp, #54]	; 0x36
 8032644:	2318      	movs	r3, #24
 8032646:	f10d 0e30 	add.w	lr, sp, #48	; 0x30
 803264a:	fb03 6c0c 	mla	ip, r3, ip, r6
 803264e:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 8032652:	f10c 0c2c 	add.w	ip, ip, #44	; 0x2c
 8032656:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 803265a:	e89e 0003 	ldmia.w	lr, {r0, r1}
                    FragDecoderInit( fragSessionData.FragGroupData.FragNb,
 803265e:	68f2      	ldr	r2, [r6, #12]
                    FragSessionData[fragSessionData.FragGroupData.FragSession.Fields.FragIndex] = fragSessionData;
 8032660:	e88c 0003 	stmia.w	ip, {r0, r1}
                    FragDecoderInit( fragSessionData.FragGroupData.FragNb,
 8032664:	4649      	mov	r1, r9
 8032666:	4640      	mov	r0, r8
 8032668:	f7fe fc62 	bl	8030f30 <FragDecoderInit>
                LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FRAGMENTATION_FRAG_SESSION_SETUP_ANS;
 803266c:	1c63      	adds	r3, r4, #1
 803266e:	6872      	ldr	r2, [r6, #4]
 8032670:	b2db      	uxtb	r3, r3
 8032672:	2102      	movs	r1, #2
 8032674:	5511      	strb	r1, [r2, r4]
                LmhpFragmentationState.DataBuffer[dataBufferIndex++] = status;
 8032676:	440c      	add	r4, r1
 8032678:	54d5      	strb	r5, [r2, r3]
 803267a:	b2e4      	uxtb	r4, r4
                isAnswerDelayed = false;
 803267c:	f04f 0900 	mov.w	r9, #0
                break;
 8032680:	e739      	b.n	80324f6 <LmhpFragmentationOnMcpsIndication+0xb2>
                if( ( fragSessionData.FragGroupData.FragNb > FRAG_MAX_NB ) || 
 8032682:	f1b9 0f78 	cmp.w	r9, #120	; 0x78
 8032686:	d8ba      	bhi.n	80325fe <LmhpFragmentationOnMcpsIndication+0x1ba>
 8032688:	e9cd 1306 	strd	r1, r3, [sp, #24]
 803268c:	9205      	str	r2, [sp, #20]
                    ( ( fragSessionData.FragGroupData.FragNb * fragSessionData.FragGroupData.FragSize ) > FragDecoderGetMaxFileSize( ) ) )
 803268e:	f7fe fc81 	bl	8030f94 <FragDecoderGetMaxFileSize>
 8032692:	fb09 f508 	mul.w	r5, r9, r8
                    ( fragSessionData.FragGroupData.FragSize > FRAG_MAX_SIZE ) ||
 8032696:	4285      	cmp	r5, r0
 8032698:	e9dd 2105 	ldrd	r2, r1, [sp, #20]
 803269c:	9b07      	ldr	r3, [sp, #28]
 803269e:	d8ae      	bhi.n	80325fe <LmhpFragmentationOnMcpsIndication+0x1ba>
 80326a0:	e7af      	b.n	8032602 <LmhpFragmentationOnMcpsIndication+0x1be>
                if( mcpsIndication->Multicast == 1 )
 80326a2:	78ba      	ldrb	r2, [r7, #2]
 80326a4:	2a01      	cmp	r2, #1
 80326a6:	f43f af26 	beq.w	80324f6 <LmhpFragmentationOnMcpsIndication+0xb2>
                uint8_t id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 80326aa:	f813 300a 	ldrb.w	r3, [r3, sl]
                if( ( id >= FRAGMENTATION_MAX_SESSIONS ) || ( FragSessionData[id].FragGroupData.IsActive == false ) )
 80326ae:	2218      	movs	r2, #24
                uint8_t id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 80326b0:	f003 0303 	and.w	r3, r3, #3
                if( ( id >= FRAGMENTATION_MAX_SESSIONS ) || ( FragSessionData[id].FragGroupData.IsActive == false ) )
 80326b4:	fb02 6203 	mla	r2, r2, r3, r6
                uint8_t id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 80326b8:	f10b 0b02 	add.w	fp, fp, #2
                if( ( id >= FRAGMENTATION_MAX_SESSIONS ) || ( FragSessionData[id].FragGroupData.IsActive == false ) )
 80326bc:	f892 102c 	ldrb.w	r1, [r2, #44]	; 0x2c
                uint8_t id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 80326c0:	fa5f fb8b 	uxtb.w	fp, fp
                if( ( id >= FRAGMENTATION_MAX_SESSIONS ) || ( FragSessionData[id].FragGroupData.IsActive == false ) )
 80326c4:	b959      	cbnz	r1, 80326de <LmhpFragmentationOnMcpsIndication+0x29a>
                    status |= 0x04; // Session does not exist
 80326c6:	f043 0304 	orr.w	r3, r3, #4
                LmhpFragmentationState.DataBuffer[dataBufferIndex++] = FRAGMENTATION_FRAG_SESSION_DELETE_ANS;
 80326ca:	6871      	ldr	r1, [r6, #4]
 80326cc:	1c62      	adds	r2, r4, #1
 80326ce:	b2d2      	uxtb	r2, r2
 80326d0:	2003      	movs	r0, #3
 80326d2:	5508      	strb	r0, [r1, r4]
                LmhpFragmentationState.DataBuffer[dataBufferIndex++] = status;
 80326d4:	3402      	adds	r4, #2
 80326d6:	548b      	strb	r3, [r1, r2]
 80326d8:	b2e4      	uxtb	r4, r4
                uint8_t id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 80326da:	46da      	mov	sl, fp
 80326dc:	e7ce      	b.n	803267c <LmhpFragmentationOnMcpsIndication+0x238>
                    FragSessionData[id].FragGroupData.IsActive = false;
 80326de:	2100      	movs	r1, #0
 80326e0:	f882 102c 	strb.w	r1, [r2, #44]	; 0x2c
 80326e4:	e7f1      	b.n	80326ca <LmhpFragmentationOnMcpsIndication+0x286>
                fragCounter = ( mcpsIndication->Buffer[cmdIndex++] << 0 ) & 0x00FF;
 80326e6:	f10b 0202 	add.w	r2, fp, #2
                fragCounter |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 80326ea:	b2d2      	uxtb	r2, r2
 80326ec:	f813 8002 	ldrb.w	r8, [r3, r2]
 80326f0:	f813 300a 	ldrb.w	r3, [r3, sl]
                if (FragSessionData[fragIndex].FragGroupData.IsActive == false)
 80326f4:	2218      	movs	r2, #24
                fragCounter |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 80326f6:	ea43 2308 	orr.w	r3, r3, r8, lsl #8
                if (FragSessionData[fragIndex].FragGroupData.IsActive == false)
 80326fa:	ea4f 1898 	mov.w	r8, r8, lsr #6
 80326fe:	fb02 6208 	mla	r2, r2, r8, r6
 8032702:	f102 052c 	add.w	r5, r2, #44	; 0x2c
 8032706:	f892 202c 	ldrb.w	r2, [r2, #44]	; 0x2c
 803270a:	2a00      	cmp	r2, #0
 803270c:	d065      	beq.n	80327da <LmhpFragmentationOnMcpsIndication+0x396>
                if( mcpsIndication->Multicast == 1 )
 803270e:	78ba      	ldrb	r2, [r7, #2]
 8032710:	2a01      	cmp	r2, #1
 8032712:	d117      	bne.n	8032744 <LmhpFragmentationOnMcpsIndication+0x300>
                    uint8_t groupId = LoRaMacMcChannelGetGroupId( mcpsIndication->DevAddress );
 8032714:	6978      	ldr	r0, [r7, #20]
 8032716:	9302      	str	r3, [sp, #8]
 8032718:	f002 fdc0 	bl	803529c <LoRaMacMcChannelGetGroupId>
                    if( ( groupId == 0xFF ) ||
 803271c:	28ff      	cmp	r0, #255	; 0xff
 803271e:	d008      	beq.n	8032732 <LmhpFragmentationOnMcpsIndication+0x2ee>
                        ( ( FragSessionData[fragIndex].FragGroupData.FragSession.Fields.McGroupBitMask & ( 1 << groupId ) ) == 0 ) )
 8032720:	786a      	ldrb	r2, [r5, #1]
                    if( ( groupId == 0xFF ) ||
 8032722:	9b02      	ldr	r3, [sp, #8]
                        ( ( FragSessionData[fragIndex].FragGroupData.FragSession.Fields.McGroupBitMask & ( 1 << groupId ) ) == 0 ) )
 8032724:	f002 020f 	and.w	r2, r2, #15
 8032728:	fa42 f000 	asr.w	r0, r2, r0
                    if( ( groupId == 0xFF ) ||
 803272c:	f010 0f01 	tst.w	r0, #1
 8032730:	d108      	bne.n	8032744 <LmhpFragmentationOnMcpsIndication+0x300>
                        cmdIndex = mcpsIndication->BufferSize;
 8032732:	f897 a00c 	ldrb.w	sl, [r7, #12]
                        break;
 8032736:	e6de      	b.n	80324f6 <LmhpFragmentationOnMcpsIndication+0xb2>
 8032738:	200049ac 	.word	0x200049ac
 803273c:	2000352c 	.word	0x2000352c
 8032740:	20006308 	.word	0x20006308
                if (FragSessionData[fragIndex].FragDecoderProcessStatus == FRAG_SESSION_ONGOING)
 8032744:	2218      	movs	r2, #24
 8032746:	fb02 6a08 	mla	sl, r2, r8, r6
                fragCounter |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 803274a:	f10b 0503 	add.w	r5, fp, #3
                if (FragSessionData[fragIndex].FragDecoderProcessStatus == FRAG_SESSION_ONGOING)
 803274e:	f8da 2040 	ldr.w	r2, [sl, #64]	; 0x40
 8032752:	3201      	adds	r2, #1
                fragCounter |= ( mcpsIndication->Buffer[cmdIndex++] << 8 ) & 0xFF00;
 8032754:	b2ed      	uxtb	r5, r5
                if (FragSessionData[fragIndex].FragDecoderProcessStatus == FRAG_SESSION_ONGOING)
 8032756:	d137      	bne.n	80327c8 <LmhpFragmentationOnMcpsIndication+0x384>
                    FragSessionData[fragIndex].FragDecoderProcessStatus = FragDecoderProcess( fragCounter, &mcpsIndication->Buffer[cmdIndex] );
 8032758:	68b9      	ldr	r1, [r7, #8]
 803275a:	f3c3 000d 	ubfx	r0, r3, #0, #14
 803275e:	4429      	add	r1, r5
 8032760:	f7fe fc1c 	bl	8030f9c <FragDecoderProcess>
 8032764:	f8ca 0040 	str.w	r0, [sl, #64]	; 0x40
                    FragSessionData[fragIndex].FragDecoderStatus = FragDecoderGetStatus( );
 8032768:	a808      	add	r0, sp, #32
 803276a:	f7fe fdc9 	bl	8031300 <FragDecoderGetStatus>
 803276e:	9808      	ldr	r0, [sp, #32]
 8032770:	9909      	ldr	r1, [sp, #36]	; 0x24
 8032772:	f10a 0338 	add.w	r3, sl, #56	; 0x38
 8032776:	c303      	stmia	r3!, {r0, r1}
                    if( LmhpFragmentationParams->OnProgress != NULL )
 8032778:	68f3      	ldr	r3, [r6, #12]
 803277a:	f8d3 b00c 	ldr.w	fp, [r3, #12]
 803277e:	f1bb 0f00 	cmp.w	fp, #0
 8032782:	d008      	beq.n	8032796 <LmhpFragmentationOnMcpsIndication+0x352>
                        LmhpFragmentationParams->OnProgress( FragSessionData[fragIndex].FragDecoderStatus.FragNbRx,
 8032784:	f8ba 303a 	ldrh.w	r3, [sl, #58]	; 0x3a
 8032788:	f89a 2030 	ldrb.w	r2, [sl, #48]	; 0x30
 803278c:	f8ba 102e 	ldrh.w	r1, [sl, #46]	; 0x2e
 8032790:	f8ba 0038 	ldrh.w	r0, [sl, #56]	; 0x38
 8032794:	47d8      	blx	fp
                    if( FragSessionData[fragIndex].FragDecoderProcessStatus >= 0 )
 8032796:	2318      	movs	r3, #24
 8032798:	fb03 6308 	mla	r3, r3, r8, r6
 803279c:	6c18      	ldr	r0, [r3, #64]	; 0x40
 803279e:	2800      	cmp	r0, #0
 80327a0:	db12      	blt.n	80327c8 <LmhpFragmentationOnMcpsIndication+0x384>
                        if( LmhpFragmentationParams->OnDone != NULL )
 80327a2:	68f2      	ldr	r2, [r6, #12]
 80327a4:	6912      	ldr	r2, [r2, #16]
 80327a6:	b14a      	cbz	r2, 80327bc <LmhpFragmentationOnMcpsIndication+0x378>
                                                            ( FragSessionData[fragIndex].FragGroupData.FragNb * FragSessionData[fragIndex].FragGroupData.FragSize ) - FragSessionData[fragIndex].FragGroupData.Padding );
 80327a8:	f8b3 c02e 	ldrh.w	ip, [r3, #46]	; 0x2e
 80327ac:	f893 1030 	ldrb.w	r1, [r3, #48]	; 0x30
 80327b0:	f893 3032 	ldrb.w	r3, [r3, #50]	; 0x32
 80327b4:	fb01 f10c 	mul.w	r1, r1, ip
                            LmhpFragmentationParams->OnDone( FragSessionData[fragIndex].FragDecoderProcessStatus,
 80327b8:	1ac9      	subs	r1, r1, r3
 80327ba:	4790      	blx	r2
                        FragSessionData[fragIndex].FragDecoderProcessStatus = FRAG_SESSION_NOT_STARTED;
 80327bc:	2318      	movs	r3, #24
 80327be:	fb03 6308 	mla	r3, r3, r8, r6
 80327c2:	f06f 0201 	mvn.w	r2, #1
 80327c6:	641a      	str	r2, [r3, #64]	; 0x40
                cmdIndex += FragSessionData[fragIndex].FragGroupData.FragSize;
 80327c8:	2318      	movs	r3, #24
 80327ca:	fb03 6808 	mla	r8, r3, r8, r6
 80327ce:	f898 a030 	ldrb.w	sl, [r8, #48]	; 0x30
 80327d2:	4455      	add	r5, sl
 80327d4:	fa5f fa85 	uxtb.w	sl, r5
                break;
 80327d8:	e68d      	b.n	80324f6 <LmhpFragmentationOnMcpsIndication+0xb2>
 80327da:	468a      	mov	sl, r1
 80327dc:	e68b      	b.n	80324f6 <LmhpFragmentationOnMcpsIndication+0xb2>
            LmHandlerGetDutyCycleEnable( &current_dutycycle );
 80327de:	f10d 002f 	add.w	r0, sp, #47	; 0x2f
 80327e2:	f7ff f977 	bl	8031ad4 <LmHandlerGetDutyCycleEnable>
            LmHandlerSetDutyCycleEnable( false );
 80327e6:	4648      	mov	r0, r9
 80327e8:	f7ff f980 	bl	8031aec <LmHandlerSetDutyCycleEnable>
            LmhpFragmentationPackage.OnSendRequest( &cmdReplyAppData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true );
 80327ec:	6ab5      	ldr	r5, [r6, #40]	; 0x28
 80327ee:	2301      	movs	r3, #1
 80327f0:	464a      	mov	r2, r9
 80327f2:	4649      	mov	r1, r9
 80327f4:	4620      	mov	r0, r4
 80327f6:	47a8      	blx	r5
            LmHandlerSetDutyCycleEnable( current_dutycycle );
 80327f8:	f89d 002f 	ldrb.w	r0, [sp, #47]	; 0x2f
 80327fc:	f7ff f976 	bl	8031aec <LmHandlerSetDutyCycleEnable>
 8032800:	e652      	b.n	80324a8 <LmhpFragmentationOnMcpsIndication+0x64>
 8032802:	bf00      	nop

08032804 <LmhpFragmentationProcess>:
{
 8032804:	b538      	push	{r3, r4, r5, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8032806:	f3ef 8210 	mrs	r2, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803280a:	b672      	cpsid	i
    delayTimerState = LmhpFragmentationState.TxDelayState;
 803280c:	4c0f      	ldr	r4, [pc, #60]	; (803284c <LmhpFragmentationProcess+0x48>)
 803280e:	78a3      	ldrb	r3, [r4, #2]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8032810:	f382 8810 	msr	PRIMASK, r2
    switch( delayTimerState )
 8032814:	2b01      	cmp	r3, #1
 8032816:	d002      	beq.n	803281e <LmhpFragmentationProcess+0x1a>
 8032818:	2b02      	cmp	r3, #2
 803281a:	d00b      	beq.n	8032834 <LmhpFragmentationProcess+0x30>
}
 803281c:	bd38      	pop	{r3, r4, r5, pc}
            TimerSetValue( &FragmentTxDelayTimer, TxDelayTime );
 803281e:	6921      	ldr	r1, [r4, #16]
 8032820:	f104 0014 	add.w	r0, r4, #20
 8032824:	f008 fdea 	bl	803b3fc <UTIL_TIMER_SetPeriod>
            TimerStart( &FragmentTxDelayTimer );
 8032828:	f104 0014 	add.w	r0, r4, #20
}
 803282c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
            TimerStart( &FragmentTxDelayTimer );
 8032830:	f008 bdaa 	b.w	803b388 <UTIL_TIMER_Start>
            if (LORAMAC_HANDLER_SUCCESS == LmhpFragmentationPackage.OnSendRequest( &DelayedReplyAppData,
 8032834:	4b06      	ldr	r3, [pc, #24]	; (8032850 <LmhpFragmentationProcess+0x4c>)
 8032836:	4807      	ldr	r0, [pc, #28]	; (8032854 <LmhpFragmentationProcess+0x50>)
 8032838:	6a9d      	ldr	r5, [r3, #40]	; 0x28
 803283a:	2200      	movs	r2, #0
 803283c:	2301      	movs	r3, #1
 803283e:	4611      	mov	r1, r2
 8032840:	47a8      	blx	r5
 8032842:	2800      	cmp	r0, #0
 8032844:	d1ea      	bne.n	803281c <LmhpFragmentationProcess+0x18>
                LmhpFragmentationState.TxDelayState = FRAGMENTATION_TX_DELAY_STATE_IDLE;
 8032846:	70a0      	strb	r0, [r4, #2]
}
 8032848:	e7e8      	b.n	803281c <LmhpFragmentationProcess+0x18>
 803284a:	bf00      	nop
 803284c:	200049ac 	.word	0x200049ac
 8032850:	2000352c 	.word	0x2000352c
 8032854:	20006308 	.word	0x20006308

08032858 <LmhpFragmentationPackageFactory>:
}
 8032858:	4800      	ldr	r0, [pc, #0]	; (803285c <LmhpFragmentationPackageFactory+0x4>)
 803285a:	4770      	bx	lr
 803285c:	2000352c 	.word	0x2000352c

08032860 <LmhpFragmentationGetPackageVersion>:
}
 8032860:	2001      	movs	r0, #1
 8032862:	4770      	bx	lr

08032864 <LmhpPackagesRegistrationInit>:
/* Private variables ---------------------------------------------------------*/

/* Exported functions ---------------------------------------------------------*/
LmHandlerErrorStatus_t LmhpPackagesRegistrationInit(void)
{
  if (LmHandlerPackageRegister(PACKAGE_ID_CLOCK_SYNC, NULL) != LORAMAC_HANDLER_SUCCESS)
 8032864:	2100      	movs	r1, #0
{
 8032866:	b508      	push	{r3, lr}
  if (LmHandlerPackageRegister(PACKAGE_ID_CLOCK_SYNC, NULL) != LORAMAC_HANDLER_SUCCESS)
 8032868:	2001      	movs	r0, #1
 803286a:	f7ff f8d1 	bl	8031a10 <LmHandlerPackageRegister>
 803286e:	4601      	mov	r1, r0
 8032870:	b110      	cbz	r0, 8032878 <LmhpPackagesRegistrationInit+0x14>
  {
    return LORAMAC_HANDLER_ERROR;
 8032872:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return LORAMAC_HANDLER_ERROR;
  }

  return LORAMAC_HANDLER_SUCCESS;
}
 8032876:	bd08      	pop	{r3, pc}
  else if (LmHandlerPackageRegister(PACKAGE_ID_REMOTE_MCAST_SETUP, NULL) != LORAMAC_HANDLER_SUCCESS)
 8032878:	2002      	movs	r0, #2
 803287a:	f7ff f8c9 	bl	8031a10 <LmHandlerPackageRegister>
 803287e:	2800      	cmp	r0, #0
 8032880:	d1f7      	bne.n	8032872 <LmhpPackagesRegistrationInit+0xe>
  else if (LmHandlerPackageRegister(PACKAGE_ID_FRAGMENTATION, (LmhpFragmentationParams_t *)&FRAG_DECODER_IF_FragmentationParams) != LORAMAC_HANDLER_SUCCESS)
 8032882:	4907      	ldr	r1, [pc, #28]	; (80328a0 <LmhpPackagesRegistrationInit+0x3c>)
 8032884:	2003      	movs	r0, #3
 8032886:	f7ff f8c3 	bl	8031a10 <LmHandlerPackageRegister>
 803288a:	4601      	mov	r1, r0
 803288c:	2800      	cmp	r0, #0
 803288e:	d1f0      	bne.n	8032872 <LmhpPackagesRegistrationInit+0xe>
  else if (LmHandlerPackageRegister(PACKAGE_ID_FIRMWARE_MANAGEMENT, NULL) != LORAMAC_HANDLER_SUCCESS)
 8032890:	2004      	movs	r0, #4
 8032892:	f7ff f8bd 	bl	8031a10 <LmHandlerPackageRegister>
 8032896:	3800      	subs	r0, #0
 8032898:	bf18      	it	ne
 803289a:	2001      	movne	r0, #1
 803289c:	4240      	negs	r0, r0
 803289e:	e7ea      	b.n	8032876 <LmhpPackagesRegistrationInit+0x12>
 80328a0:	0803b908 	.word	0x0803b908

080328a4 <LmhpPackagesRegister>:

LmHandlerErrorStatus_t LmhpPackagesRegister(uint8_t id, LmhPackage_t **package)
{
 80328a4:	b510      	push	{r4, lr}
  if (package == NULL)
 80328a6:	460c      	mov	r4, r1
 80328a8:	b1a1      	cbz	r1, 80328d4 <LmhpPackagesRegister+0x30>
  {
    return LORAMAC_HANDLER_ERROR;
  }
  switch (id)
 80328aa:	3801      	subs	r0, #1
 80328ac:	2803      	cmp	r0, #3
 80328ae:	d806      	bhi.n	80328be <LmhpPackagesRegister+0x1a>
 80328b0:	e8df f000 	tbb	[pc, r0]
 80328b4:	0d0a0702 	.word	0x0d0a0702
  {
    case PACKAGE_ID_CLOCK_SYNC:
    {
      *package = LmhpClockSyncPackageFactory();
 80328b8:	f7ff fa50 	bl	8031d5c <LmhpClockSyncPackageFactory>
      *package = LmhpFragmentationPackageFactory();
      break;
    }
    case PACKAGE_ID_FIRMWARE_MANAGEMENT:
    {
      *package = LmhpFirmwareManagementPackageFactory();
 80328bc:	6020      	str	r0, [r4, #0]
  if (package == NULL)
 80328be:	2000      	movs	r0, #0
 80328c0:	e00a      	b.n	80328d8 <LmhpPackagesRegister+0x34>
      *package = LmhpRemoteMcastSetupPackageFactory();
 80328c2:	f000 fb45 	bl	8032f50 <LmhpRemoteMcastSetupPackageFactory>
 80328c6:	e7f9      	b.n	80328bc <LmhpPackagesRegister+0x18>
      *package = LmhpFragmentationPackageFactory();
 80328c8:	f7ff ffc6 	bl	8032858 <LmhpFragmentationPackageFactory>
 80328cc:	e7f6      	b.n	80328bc <LmhpPackagesRegister+0x18>
      *package = LmhpFirmwareManagementPackageFactory();
 80328ce:	f7ff fd6f 	bl	80323b0 <LmhpFirmwareManagementPackageFactory>
 80328d2:	e7f3      	b.n	80328bc <LmhpPackagesRegister+0x18>
    return LORAMAC_HANDLER_ERROR;
 80328d4:	f04f 30ff 	mov.w	r0, #4294967295
      break;
    }
  }

  return LORAMAC_HANDLER_SUCCESS;
}
 80328d8:	bd10      	pop	{r4, pc}
	...

080328dc <LmhpRemoteMcastSetupIsInitialized>:
}

static bool LmhpRemoteMcastSetupIsInitialized( void )
{
    return LmhpRemoteMcastSetupState.Initialized;
}
 80328dc:	4b01      	ldr	r3, [pc, #4]	; (80328e4 <LmhpRemoteMcastSetupIsInitialized+0x8>)
 80328de:	7818      	ldrb	r0, [r3, #0]
 80328e0:	4770      	bx	lr
 80328e2:	bf00      	nop
 80328e4:	20004a38 	.word	0x20004a38

080328e8 <LmhpRemoteMcastSetupIsRunning>:

static bool LmhpRemoteMcastSetupIsRunning( void )
{
    if( LmhpRemoteMcastSetupState.Initialized == false )
 80328e8:	4b02      	ldr	r3, [pc, #8]	; (80328f4 <LmhpRemoteMcastSetupIsRunning+0xc>)
 80328ea:	7818      	ldrb	r0, [r3, #0]
 80328ec:	b100      	cbz	r0, 80328f0 <LmhpRemoteMcastSetupIsRunning+0x8>
    {
        return false;
    }

    return LmhpRemoteMcastSetupState.IsRunning;
 80328ee:	7858      	ldrb	r0, [r3, #1]
}
 80328f0:	4770      	bx	lr
 80328f2:	bf00      	nop
 80328f4:	20004a38 	.word	0x20004a38

080328f8 <LmhpRemoteMcastSetupInit>:
{
 80328f8:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80328fa:	4c10      	ldr	r4, [pc, #64]	; (803293c <LmhpRemoteMcastSetupInit+0x44>)
    if( dataBuffer != NULL )
 80328fc:	b1e1      	cbz	r1, 8032938 <LmhpRemoteMcastSetupInit+0x40>
        LmhpRemoteMcastSetupState.Initialized = true;
 80328fe:	4620      	mov	r0, r4
        TimerInit( &SessionStartTimer, OnSessionStartTimer );
 8032900:	2500      	movs	r5, #0
        LmhpRemoteMcastSetupState.Initialized = true;
 8032902:	f240 1301 	movw	r3, #257	; 0x101
 8032906:	f820 3b08 	strh.w	r3, [r0], #8
        LmhpRemoteMcastSetupState.DataBuffer = dataBuffer;
 803290a:	6061      	str	r1, [r4, #4]
        TimerInit( &SessionStartTimer, OnSessionStartTimer );
 803290c:	4b0c      	ldr	r3, [pc, #48]	; (8032940 <LmhpRemoteMcastSetupInit+0x48>)
        LmhpRemoteMcastSetupState.DataBufferMaxSize = dataBufferMaxSize;
 803290e:	70e2      	strb	r2, [r4, #3]
        TimerInit( &SessionStartTimer, OnSessionStartTimer );
 8032910:	f04f 31ff 	mov.w	r1, #4294967295
 8032914:	462a      	mov	r2, r5
 8032916:	9500      	str	r5, [sp, #0]
 8032918:	f008 fc88 	bl	803b22c <UTIL_TIMER_Create>
        TimerInit( &SessionStopTimer, OnSessionStopTimer );
 803291c:	4b09      	ldr	r3, [pc, #36]	; (8032944 <LmhpRemoteMcastSetupInit+0x4c>)
 803291e:	9500      	str	r5, [sp, #0]
 8032920:	462a      	mov	r2, r5
 8032922:	f04f 31ff 	mov.w	r1, #4294967295
 8032926:	f104 0020 	add.w	r0, r4, #32
 803292a:	f008 fc7f 	bl	803b22c <UTIL_TIMER_Create>
        McSessionData[id].McGroupData.McGroupEnabled = false;
 803292e:	2300      	movs	r3, #0
 8032930:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
}
 8032934:	b003      	add	sp, #12
 8032936:	bd30      	pop	{r4, r5, pc}
        LmhpRemoteMcastSetupState.Initialized = false;
 8032938:	8021      	strh	r1, [r4, #0]
 803293a:	e7f8      	b.n	803292e <LmhpRemoteMcastSetupInit+0x36>
 803293c:	20004a38 	.word	0x20004a38
 8032940:	0803296d 	.word	0x0803296d
 8032944:	08032949 	.word	0x08032949

08032948 <OnSessionStopTimer>:
    LmhpRemoteMcastSetupState.SessionState = REMOTE_MCAST_SETUP_SESSION_STATE_START;
    LmhpRemoteMcastSetupPackage.OnPackageProcessEvent();
}

static void OnSessionStopTimer( void *context )
{
 8032948:	b510      	push	{r4, lr}
    TimerStop( &SessionStopTimer );
 803294a:	4c06      	ldr	r4, [pc, #24]	; (8032964 <OnSessionStopTimer+0x1c>)
 803294c:	f104 0020 	add.w	r0, r4, #32
 8032950:	f008 fcca 	bl	803b2e8 <UTIL_TIMER_Stop>
    LmhpRemoteMcastSetupState.SessionState = REMOTE_MCAST_SETUP_SESSION_STATE_STOP;
 8032954:	2302      	movs	r3, #2
 8032956:	70a3      	strb	r3, [r4, #2]
    LmhpRemoteMcastSetupPackage.OnPackageProcessEvent();
 8032958:	4b03      	ldr	r3, [pc, #12]	; (8032968 <OnSessionStopTimer+0x20>)
}
 803295a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    LmhpRemoteMcastSetupPackage.OnPackageProcessEvent();
 803295e:	695b      	ldr	r3, [r3, #20]
 8032960:	4718      	bx	r3
 8032962:	bf00      	nop
 8032964:	20004a38 	.word	0x20004a38
 8032968:	20003560 	.word	0x20003560

0803296c <OnSessionStartTimer>:
{
 803296c:	b510      	push	{r4, lr}
    TimerStop( &SessionStartTimer );
 803296e:	4c06      	ldr	r4, [pc, #24]	; (8032988 <OnSessionStartTimer+0x1c>)
 8032970:	f104 0008 	add.w	r0, r4, #8
 8032974:	f008 fcb8 	bl	803b2e8 <UTIL_TIMER_Stop>
    LmhpRemoteMcastSetupState.SessionState = REMOTE_MCAST_SETUP_SESSION_STATE_START;
 8032978:	2301      	movs	r3, #1
 803297a:	70a3      	strb	r3, [r4, #2]
    LmhpRemoteMcastSetupPackage.OnPackageProcessEvent();
 803297c:	4b03      	ldr	r3, [pc, #12]	; (803298c <OnSessionStartTimer+0x20>)
}
 803297e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    LmhpRemoteMcastSetupPackage.OnPackageProcessEvent();
 8032982:	695b      	ldr	r3, [r3, #20]
 8032984:	4718      	bx	r3
 8032986:	bf00      	nop
 8032988:	20004a38 	.word	0x20004a38
 803298c:	20003560 	.word	0x20003560

08032990 <LmhpRemoteMcastSetupOnMcpsIndication>:
{
 8032990:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if( mcpsIndication->Port != REMOTE_MCAST_SETUP_PORT )
 8032994:	78c3      	ldrb	r3, [r0, #3]
 8032996:	2bc8      	cmp	r3, #200	; 0xc8
{
 8032998:	b091      	sub	sp, #68	; 0x44
 803299a:	4682      	mov	sl, r0
    if( mcpsIndication->Port != REMOTE_MCAST_SETUP_PORT )
 803299c:	f000 8293 	beq.w	8032ec6 <LmhpRemoteMcastSetupOnMcpsIndication+0x536>
}
 80329a0:	b011      	add	sp, #68	; 0x44
 80329a2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        switch( mcpsIndication->Buffer[cmdIndex++] )
 80329a6:	f8da 0008 	ldr.w	r0, [sl, #8]
 80329aa:	5c81      	ldrb	r1, [r0, r2]
 80329ac:	1c57      	adds	r7, r2, #1
 80329ae:	b2ff      	uxtb	r7, r7
 80329b0:	2904      	cmp	r1, #4
 80329b2:	d813      	bhi.n	80329dc <LmhpRemoteMcastSetupOnMcpsIndication+0x4c>
 80329b4:	e8df f011 	tbh	[pc, r1, lsl #1]
 80329b8:	009c0005 	.word	0x009c0005
 80329bc:	01a800dd 	.word	0x01a800dd
 80329c0:	01d8      	.short	0x01d8
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_PKG_VERSION_ANS;
 80329c2:	6872      	ldr	r2, [r6, #4]
 80329c4:	2300      	movs	r3, #0
 80329c6:	1c61      	adds	r1, r4, #1
 80329c8:	5513      	strb	r3, [r2, r4]
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_ID;
 80329ca:	b2c9      	uxtb	r1, r1
 80329cc:	1ca3      	adds	r3, r4, #2
 80329ce:	b2db      	uxtb	r3, r3
 80329d0:	2002      	movs	r0, #2
 80329d2:	5450      	strb	r0, [r2, r1]
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_VERSION;
 80329d4:	2101      	movs	r1, #1
 80329d6:	3403      	adds	r4, #3
 80329d8:	54d1      	strb	r1, [r2, r3]
 80329da:	b2e4      	uxtb	r4, r4
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 80329dc:	463a      	mov	r2, r7
    while( cmdIndex < mcpsIndication->BufferSize )
 80329de:	f89a 300c 	ldrb.w	r3, [sl, #12]
 80329e2:	4293      	cmp	r3, r2
 80329e4:	d8df      	bhi.n	80329a6 <LmhpRemoteMcastSetupOnMcpsIndication+0x16>
    if( dataBufferIndex != 0 )
 80329e6:	2c00      	cmp	r4, #0
 80329e8:	d0da      	beq.n	80329a0 <LmhpRemoteMcastSetupOnMcpsIndication+0x10>
        LmHandlerAppData_t appData =
 80329ea:	f88d 4021 	strb.w	r4, [sp, #33]	; 0x21
            .Buffer = LmhpRemoteMcastSetupState.DataBuffer,
 80329ee:	4cb9      	ldr	r4, [pc, #740]	; (8032cd4 <LmhpRemoteMcastSetupOnMcpsIndication+0x344>)
        LmHandlerAppData_t appData =
 80329f0:	23c8      	movs	r3, #200	; 0xc8
 80329f2:	f88d 3020 	strb.w	r3, [sp, #32]
        LmHandlerGetDutyCycleEnable( &current_dutycycle );
 80329f6:	f10d 001f 	add.w	r0, sp, #31
        LmHandlerAppData_t appData =
 80329fa:	6863      	ldr	r3, [r4, #4]
 80329fc:	9309      	str	r3, [sp, #36]	; 0x24
        LmHandlerGetDutyCycleEnable( &current_dutycycle );
 80329fe:	f7ff f869 	bl	8031ad4 <LmHandlerGetDutyCycleEnable>
        LmHandlerSetDutyCycleEnable( false );
 8032a02:	2000      	movs	r0, #0
 8032a04:	f7ff f872 	bl	8031aec <LmHandlerSetDutyCycleEnable>
        LmhpRemoteMcastSetupPackage.OnSendRequest( &appData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true );
 8032a08:	4bb3      	ldr	r3, [pc, #716]	; (8032cd8 <LmhpRemoteMcastSetupOnMcpsIndication+0x348>)
 8032a0a:	2200      	movs	r2, #0
 8032a0c:	6a9e      	ldr	r6, [r3, #40]	; 0x28
 8032a0e:	4611      	mov	r1, r2
 8032a10:	2301      	movs	r3, #1
 8032a12:	a808      	add	r0, sp, #32
 8032a14:	47b0      	blx	r6
        LmHandlerSetDutyCycleEnable( current_dutycycle );
 8032a16:	f89d 001f 	ldrb.w	r0, [sp, #31]
 8032a1a:	f7ff f867 	bl	8031aec <LmHandlerSetDutyCycleEnable>
        if (id != 0xFF && id < LORAMAC_MAX_MC_CTX)
 8032a1e:	2d00      	cmp	r5, #0
 8032a20:	d1be      	bne.n	80329a0 <LmhpRemoteMcastSetupOnMcpsIndication+0x10>
            MW_LOG(TS_OFF, VLEVEL_M, "ID          : %d\r\n", McSessionData[id].McGroupData.IdHeader.Fields.McGroupId);
 8032a22:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
                MW_LOG(TS_OFF, VLEVEL_M, "-%02X",  McSessionData[id].McGroupData.McKeyEncrypted[i]);
 8032a26:	4fad      	ldr	r7, [pc, #692]	; (8032cdc <LmhpRemoteMcastSetupOnMcpsIndication+0x34c>)
            MW_LOG(TS_OFF, VLEVEL_M, "ID          : %d\r\n", McSessionData[id].McGroupData.IdHeader.Fields.McGroupId);
 8032a28:	f003 0303 	and.w	r3, r3, #3
 8032a2c:	462a      	mov	r2, r5
 8032a2e:	4629      	mov	r1, r5
 8032a30:	9300      	str	r3, [sp, #0]
 8032a32:	2002      	movs	r0, #2
 8032a34:	4baa      	ldr	r3, [pc, #680]	; (8032ce0 <LmhpRemoteMcastSetupOnMcpsIndication+0x350>)
 8032a36:	f008 f935 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
            MW_LOG(TS_OFF, VLEVEL_M, "McAddr      : %08X\r\n", McSessionData[id].McGroupData.McAddr);
 8032a3a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8032a3c:	9300      	str	r3, [sp, #0]
 8032a3e:	462a      	mov	r2, r5
 8032a40:	4629      	mov	r1, r5
 8032a42:	4ba8      	ldr	r3, [pc, #672]	; (8032ce4 <LmhpRemoteMcastSetupOnMcpsIndication+0x354>)
 8032a44:	2002      	movs	r0, #2
 8032a46:	f008 f92d 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
            MW_LOG(TS_OFF, VLEVEL_M, "McKey       : %02X", McSessionData[id].McGroupData.McKeyEncrypted[0]);
 8032a4a:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8032a4e:	9300      	str	r3, [sp, #0]
 8032a50:	462a      	mov	r2, r5
 8032a52:	4629      	mov	r1, r5
 8032a54:	4ba4      	ldr	r3, [pc, #656]	; (8032ce8 <LmhpRemoteMcastSetupOnMcpsIndication+0x358>)
 8032a56:	2002      	movs	r0, #2
 8032a58:	f008 f924 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
            for ( int i = 1; i < 16; i++ )
 8032a5c:	f104 0641 	add.w	r6, r4, #65	; 0x41
 8032a60:	2501      	movs	r5, #1
                MW_LOG(TS_OFF, VLEVEL_M, "-%02X",  McSessionData[id].McGroupData.McKeyEncrypted[i]);
 8032a62:	f816 3b01 	ldrb.w	r3, [r6], #1
 8032a66:	9300      	str	r3, [sp, #0]
 8032a68:	2200      	movs	r2, #0
 8032a6a:	463b      	mov	r3, r7
 8032a6c:	4611      	mov	r1, r2
 8032a6e:	2002      	movs	r0, #2
            for ( int i = 1; i < 16; i++ )
 8032a70:	3501      	adds	r5, #1
                MW_LOG(TS_OFF, VLEVEL_M, "-%02X",  McSessionData[id].McGroupData.McKeyEncrypted[i]);
 8032a72:	f008 f917 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
            for ( int i = 1; i < 16; i++ )
 8032a76:	2d10      	cmp	r5, #16
 8032a78:	d1f3      	bne.n	8032a62 <LmhpRemoteMcastSetupOnMcpsIndication+0xd2>
            MW_LOG(TS_OFF, VLEVEL_M, "\r\n");
 8032a7a:	2200      	movs	r2, #0
 8032a7c:	4611      	mov	r1, r2
 8032a7e:	4b9b      	ldr	r3, [pc, #620]	; (8032cec <LmhpRemoteMcastSetupOnMcpsIndication+0x35c>)
 8032a80:	2002      	movs	r0, #2
 8032a82:	f008 f90f 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
            MW_LOG(TS_OFF, VLEVEL_M, "McFCountMin : %u\r\n",  McSessionData[id].McGroupData.McFCountMin);
 8032a86:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8032a88:	9300      	str	r3, [sp, #0]
 8032a8a:	2200      	movs	r2, #0
 8032a8c:	4611      	mov	r1, r2
 8032a8e:	4b98      	ldr	r3, [pc, #608]	; (8032cf0 <LmhpRemoteMcastSetupOnMcpsIndication+0x360>)
 8032a90:	2002      	movs	r0, #2
 8032a92:	f008 f907 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
            MW_LOG(TS_OFF, VLEVEL_M, "McFCountMax : %u\r\n",  McSessionData[id].McGroupData.McFCountMax);
 8032a96:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8032a98:	9300      	str	r3, [sp, #0]
 8032a9a:	2200      	movs	r2, #0
 8032a9c:	4611      	mov	r1, r2
 8032a9e:	4b95      	ldr	r3, [pc, #596]	; (8032cf4 <LmhpRemoteMcastSetupOnMcpsIndication+0x364>)
 8032aa0:	2002      	movs	r0, #2
 8032aa2:	f008 f8ff 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
            MW_LOG(TS_OFF, VLEVEL_M, "SessionTime : %u\r\n",  McSessionData[id].SessionTime);
 8032aa6:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8032aa8:	9300      	str	r3, [sp, #0]
 8032aaa:	2200      	movs	r2, #0
 8032aac:	4611      	mov	r1, r2
 8032aae:	4b92      	ldr	r3, [pc, #584]	; (8032cf8 <LmhpRemoteMcastSetupOnMcpsIndication+0x368>)
 8032ab0:	2002      	movs	r0, #2
 8032ab2:	f008 f8f7 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
            MW_LOG(TS_OFF, VLEVEL_M, "SessionTimeT: %d s\r\n", (1 << McSessionData[id].SessionTimeout));
 8032ab6:	f894 2060 	ldrb.w	r2, [r4, #96]	; 0x60
 8032aba:	2301      	movs	r3, #1
 8032abc:	4093      	lsls	r3, r2
 8032abe:	2200      	movs	r2, #0
 8032ac0:	9300      	str	r3, [sp, #0]
 8032ac2:	4611      	mov	r1, r2
 8032ac4:	4b8d      	ldr	r3, [pc, #564]	; (8032cfc <LmhpRemoteMcastSetupOnMcpsIndication+0x36c>)
 8032ac6:	2002      	movs	r0, #2
 8032ac8:	f008 f8ec 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
            MW_LOG(TS_OFF, VLEVEL_M, "Rx Freq     : %u\r\n", McSessionData[id].RxParams.ClassC.Frequency);
 8032acc:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8032ace:	9300      	str	r3, [sp, #0]
 8032ad0:	2200      	movs	r2, #0
 8032ad2:	4611      	mov	r1, r2
 8032ad4:	4b8a      	ldr	r3, [pc, #552]	; (8032d00 <LmhpRemoteMcastSetupOnMcpsIndication+0x370>)
 8032ad6:	2002      	movs	r0, #2
 8032ad8:	f008 f8e4 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
            MW_LOG(TS_OFF, VLEVEL_M, "Rx DR       : DR_%d\r\n", McSessionData[id].RxParams.ClassC.Datarate);
 8032adc:	f994 3068 	ldrsb.w	r3, [r4, #104]	; 0x68
 8032ae0:	9300      	str	r3, [sp, #0]
 8032ae2:	2200      	movs	r2, #0
 8032ae4:	4b87      	ldr	r3, [pc, #540]	; (8032d04 <LmhpRemoteMcastSetupOnMcpsIndication+0x374>)
 8032ae6:	4611      	mov	r1, r2
 8032ae8:	2002      	movs	r0, #2
 8032aea:	f008 f8db 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
 8032aee:	e757      	b.n	80329a0 <LmhpRemoteMcastSetupOnMcpsIndication+0x10>
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_STATUS_ANS;
 8032af0:	6875      	ldr	r5, [r6, #4]
                uint8_t reqGroupMask = mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8032af2:	5dc7      	ldrb	r7, [r0, r7]
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_STATUS_ANS;
 8032af4:	2301      	movs	r3, #1
 8032af6:	552b      	strb	r3, [r5, r4]
                uint8_t reqGroupMask = mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8032af8:	3202      	adds	r2, #2
                for (id = 0; id < LORAMAC_MAX_MC_CTX; id++)
 8032afa:	2300      	movs	r3, #0
                dataBufferIndex++;
 8032afc:	3402      	adds	r4, #2
                uint8_t reqGroupMask = mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8032afe:	b2d2      	uxtb	r2, r2
                dataBufferIndex++;
 8032b00:	b2e4      	uxtb	r4, r4
                uint8_t AnsGroupMask = 0x00;
 8032b02:	469c      	mov	ip, r3
                for (id = 0; id < LORAMAC_MAX_MC_CTX; id++)
 8032b04:	4618      	mov	r0, r3
 8032b06:	f007 0701 	and.w	r7, r7, #1
                    if( McSessionData[id].McGroupData.McGroupEnabled )
 8032b0a:	f896 e038 	ldrb.w	lr, [r6, #56]	; 0x38
                for (id = 0; id < LORAMAC_MAX_MC_CTX; id++)
 8032b0e:	b140      	cbz	r0, 8032b22 <LmhpRemoteMcastSetupOnMcpsIndication+0x192>
                LmhpRemoteMcastSetupState.DataBuffer[1] = (nbAvailableGroups & 0x07) << 4 | (AnsGroupMask & 0x0F);
 8032b10:	011b      	lsls	r3, r3, #4
 8032b12:	f003 0370 	and.w	r3, r3, #112	; 0x70
 8032b16:	ea43 030c 	orr.w	r3, r3, ip
 8032b1a:	706b      	strb	r3, [r5, #1]
                uint8_t reqGroupMask = mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8032b1c:	4617      	mov	r7, r2
                break;
 8032b1e:	460d      	mov	r5, r1
 8032b20:	e75c      	b.n	80329dc <LmhpRemoteMcastSetupOnMcpsIndication+0x4c>
                    if( McSessionData[id].McGroupData.McGroupEnabled )
 8032b22:	f1be 0f00 	cmp.w	lr, #0
 8032b26:	d0f3      	beq.n	8032b10 <LmhpRemoteMcastSetupOnMcpsIndication+0x180>
                        if( ( reqGroupMask & ( 1 << id ) ) != 0 )
 8032b28:	b307      	cbz	r7, 8032b6c <LmhpRemoteMcastSetupOnMcpsIndication+0x1dc>
                            LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = id;
 8032b2a:	5528      	strb	r0, [r5, r4]
 8032b2c:	f104 0c01 	add.w	ip, r4, #1
                            LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (McSessionData[id].McGroupData.McAddr >> 0) & 0xFF;
 8032b30:	fa5f fc8c 	uxtb.w	ip, ip
 8032b34:	6bf0      	ldr	r0, [r6, #60]	; 0x3c
 8032b36:	f805 000c 	strb.w	r0, [r5, ip]
 8032b3a:	f104 0c02 	add.w	ip, r4, #2
                            LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (McSessionData[id].McGroupData.McAddr >> 8) & 0xFF;
 8032b3e:	6bf0      	ldr	r0, [r6, #60]	; 0x3c
 8032b40:	fa5f fc8c 	uxtb.w	ip, ip
 8032b44:	0a00      	lsrs	r0, r0, #8
 8032b46:	f805 000c 	strb.w	r0, [r5, ip]
 8032b4a:	f104 0c03 	add.w	ip, r4, #3
                            LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (McSessionData[id].McGroupData.McAddr >> 16) & 0xFF;
 8032b4e:	fa5f fc8c 	uxtb.w	ip, ip
 8032b52:	f8b6 e03e 	ldrh.w	lr, [r6, #62]	; 0x3e
 8032b56:	f805 e00c 	strb.w	lr, [r5, ip]
 8032b5a:	1d20      	adds	r0, r4, #4
 8032b5c:	b2c0      	uxtb	r0, r0
                            LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (McSessionData[id].McGroupData.McAddr >> 24) & 0xFF;
 8032b5e:	f896 c03f 	ldrb.w	ip, [r6, #63]	; 0x3f
 8032b62:	f805 c000 	strb.w	ip, [r5, r0]
 8032b66:	3405      	adds	r4, #5
 8032b68:	b2e4      	uxtb	r4, r4
                            AnsGroupMask |= (1 << id);
 8032b6a:	46bc      	mov	ip, r7
 8032b6c:	3301      	adds	r3, #1
 8032b6e:	4608      	mov	r0, r1
 8032b70:	e7cb      	b.n	8032b0a <LmhpRemoteMcastSetupOnMcpsIndication+0x17a>
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032b72:	5dc5      	ldrb	r5, [r0, r7]
                McSessionData[id].McGroupData.IdHeader.Value = id;
 8032b74:	f04f 0c34 	mov.w	ip, #52	; 0x34
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032b78:	f005 0503 	and.w	r5, r5, #3
                McSessionData[id].McGroupData.IdHeader.Value = id;
 8032b7c:	fb0c 6705 	mla	r7, ip, r5, r6
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032b80:	1c93      	adds	r3, r2, #2
                McSessionData[id].McGroupData.McAddr =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032b82:	b2db      	uxtb	r3, r3
                McSessionData[id].McGroupData.IdHeader.Value = id;
 8032b84:	f887 5039 	strb.w	r5, [r7, #57]	; 0x39
                McSessionData[id].McGroupData.McAddr =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032b88:	5cc1      	ldrb	r1, [r0, r3]
 8032b8a:	63f9      	str	r1, [r7, #60]	; 0x3c
 8032b8c:	1cd3      	adds	r3, r2, #3
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032b8e:	b2db      	uxtb	r3, r3
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032b90:	f102 0e05 	add.w	lr, r2, #5
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032b94:	5cc3      	ldrb	r3, [r0, r3]
 8032b96:	eb01 2103 	add.w	r1, r1, r3, lsl #8
 8032b9a:	1d13      	adds	r3, r2, #4
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032b9c:	b2db      	uxtb	r3, r3
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032b9e:	63f9      	str	r1, [r7, #60]	; 0x3c
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032ba0:	5cc3      	ldrb	r3, [r0, r3]
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032ba2:	fa5f fe8e 	uxtb.w	lr, lr
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032ba6:	eb01 4103 	add.w	r1, r1, r3, lsl #16
 8032baa:	63f9      	str	r1, [r7, #60]	; 0x3c
                McSessionData[id].McGroupData.McAddr += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032bac:	f810 e00e 	ldrb.w	lr, [r0, lr]
 8032bb0:	fb0c bc05 	mla	ip, ip, r5, fp
 8032bb4:	eb01 610e 	add.w	r1, r1, lr, lsl #24
 8032bb8:	63f9      	str	r1, [r7, #60]	; 0x3c
 8032bba:	9103      	str	r1, [sp, #12]
 8032bbc:	f10c 0108 	add.w	r1, ip, #8
 8032bc0:	1d93      	adds	r3, r2, #6
 8032bc2:	9104      	str	r1, [sp, #16]
 8032bc4:	460f      	mov	r7, r1
 8032bc6:	f102 0116 	add.w	r1, r2, #22
 8032bca:	b2db      	uxtb	r3, r3
                for( int8_t i = 0; i < 16; i++ )
 8032bcc:	fa5f fe81 	uxtb.w	lr, r1
                    McSessionData[id].McGroupData.McKeyEncrypted[i] = mcpsIndication->Buffer[cmdIndex++];
 8032bd0:	469c      	mov	ip, r3
 8032bd2:	3301      	adds	r3, #1
 8032bd4:	b2db      	uxtb	r3, r3
 8032bd6:	f810 c00c 	ldrb.w	ip, [r0, ip]
 8032bda:	f807 cb01 	strb.w	ip, [r7], #1
                for( int8_t i = 0; i < 16; i++ )
 8032bde:	4573      	cmp	r3, lr
 8032be0:	d1f6      	bne.n	8032bd0 <LmhpRemoteMcastSetupOnMcpsIndication+0x240>
                McSessionData[id].McGroupData.McFCountMin =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032be2:	b2c9      	uxtb	r1, r1
 8032be4:	f04f 0834 	mov.w	r8, #52	; 0x34
 8032be8:	5c43      	ldrb	r3, [r0, r1]
 8032bea:	fb08 6805 	mla	r8, r8, r5, r6
 8032bee:	f102 0117 	add.w	r1, r2, #23
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032bf2:	b2c9      	uxtb	r1, r1
                McSessionData[id].McGroupData.McFCountMin =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032bf4:	f8c8 3050 	str.w	r3, [r8, #80]	; 0x50
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032bf8:	5c41      	ldrb	r1, [r0, r1]
 8032bfa:	eb03 2301 	add.w	r3, r3, r1, lsl #8
 8032bfe:	f102 0118 	add.w	r1, r2, #24
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032c02:	b2c9      	uxtb	r1, r1
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032c04:	f8c8 3050 	str.w	r3, [r8, #80]	; 0x50
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032c08:	5c41      	ldrb	r1, [r0, r1]
 8032c0a:	eb03 4301 	add.w	r3, r3, r1, lsl #16
 8032c0e:	f102 0119 	add.w	r1, r2, #25
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032c12:	b2c9      	uxtb	r1, r1
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032c14:	f8c8 3050 	str.w	r3, [r8, #80]	; 0x50
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032c18:	5c41      	ldrb	r1, [r0, r1]
 8032c1a:	eb03 6301 	add.w	r3, r3, r1, lsl #24
 8032c1e:	f102 011a 	add.w	r1, r2, #26
                McSessionData[id].McGroupData.McFCountMax =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032c22:	b2c9      	uxtb	r1, r1
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032c24:	f8c8 3050 	str.w	r3, [r8, #80]	; 0x50
                McSessionData[id].McGroupData.McFCountMax =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032c28:	f102 071b 	add.w	r7, r2, #27
 8032c2c:	5c41      	ldrb	r1, [r0, r1]
 8032c2e:	f8c8 1054 	str.w	r1, [r8, #84]	; 0x54
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032c32:	b2ff      	uxtb	r7, r7
                McSessionData[id].McGroupData.McFCountMin += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032c34:	9305      	str	r3, [sp, #20]
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032c36:	f810 9007 	ldrb.w	r9, [r0, r7]
 8032c3a:	f102 071c 	add.w	r7, r2, #28
 8032c3e:	eb01 2109 	add.w	r1, r1, r9, lsl #8
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032c42:	b2ff      	uxtb	r7, r7
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032c44:	f8c8 1054 	str.w	r1, [r8, #84]	; 0x54
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032c48:	f810 9007 	ldrb.w	r9, [r0, r7]
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032c4c:	f102 071e 	add.w	r7, r2, #30
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032c50:	321d      	adds	r2, #29
 8032c52:	eb01 4109 	add.w	r1, r1, r9, lsl #16
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032c56:	b2d2      	uxtb	r2, r2
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032c58:	f8c8 1054 	str.w	r1, [r8, #84]	; 0x54
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032c5c:	f810 9002 	ldrb.w	r9, [r0, r2]
 8032c60:	eb01 6909 	add.w	r9, r1, r9, lsl #24
                McChannelParams_t channel =
 8032c64:	2214      	movs	r2, #20
 8032c66:	2100      	movs	r1, #0
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032c68:	f8c8 9054 	str.w	r9, [r8, #84]	; 0x54
                McChannelParams_t channel =
 8032c6c:	a80b      	add	r0, sp, #44	; 0x2c
 8032c6e:	f008 fd5f 	bl	803b730 <memset>
 8032c72:	f240 2201 	movw	r2, #513	; 0x201
 8032c76:	f8ad 2020 	strh.w	r2, [sp, #32]
 8032c7a:	2201      	movs	r2, #1
 8032c7c:	9b03      	ldr	r3, [sp, #12]
 8032c7e:	f88d 2022 	strb.w	r2, [sp, #34]	; 0x22
                    .GroupID = ( AddressIdentifier_t )McSessionData[id].McGroupData.IdHeader.Fields.McGroupId,
 8032c82:	f898 1039 	ldrb.w	r1, [r8, #57]	; 0x39
                McChannelParams_t channel =
 8032c86:	9309      	str	r3, [sp, #36]	; 0x24
 8032c88:	9b04      	ldr	r3, [sp, #16]
 8032c8a:	930a      	str	r3, [sp, #40]	; 0x28
 8032c8c:	9b05      	ldr	r3, [sp, #20]
                    .GroupID = ( AddressIdentifier_t )McSessionData[id].McGroupData.IdHeader.Fields.McGroupId,
 8032c8e:	f3c1 0101 	ubfx	r1, r1, #0, #2
                if( LoRaMacMcChannelSetup( &channel ) == LORAMAC_STATUS_OK )
 8032c92:	a808      	add	r0, sp, #32
                McChannelParams_t channel =
 8032c94:	e9cd 390c 	strd	r3, r9, [sp, #48]	; 0x30
 8032c98:	f88d 1023 	strb.w	r1, [sp, #35]	; 0x23
                if( LoRaMacMcChannelSetup( &channel ) == LORAMAC_STATUS_OK )
 8032c9c:	f002 fa8c 	bl	80351b8 <LoRaMacMcChannelSetup>
                McSessionData[id].McGroupData.McFCountMax += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032ca0:	b2ff      	uxtb	r7, r7
                if( LoRaMacMcChannelSetup( &channel ) == LORAMAC_STATUS_OK )
 8032ca2:	2201      	movs	r2, #1
 8032ca4:	b998      	cbnz	r0, 8032cce <LmhpRemoteMcastSetupOnMcpsIndication+0x33e>
                    McSessionData[id].McGroupData.McGroupEnabled = true;
 8032ca6:	f888 2038 	strb.w	r2, [r8, #56]	; 0x38
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_SETUP_ANS;
 8032caa:	6871      	ldr	r1, [r6, #4]
 8032cac:	2302      	movs	r3, #2
 8032cae:	550b      	strb	r3, [r1, r4]
 8032cb0:	1c62      	adds	r2, r4, #1
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = ( idError << 2 ) | McSessionData[id].McGroupData.IdHeader.Fields.McGroupId;
 8032cb2:	441c      	add	r4, r3
 8032cb4:	2334      	movs	r3, #52	; 0x34
 8032cb6:	fb03 6305 	mla	r3, r3, r5, r6
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_SETUP_ANS;
 8032cba:	b2d2      	uxtb	r2, r2
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = ( idError << 2 ) | McSessionData[id].McGroupData.IdHeader.Fields.McGroupId;
 8032cbc:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 8032cc0:	f3c3 0301 	ubfx	r3, r3, #0, #2
 8032cc4:	ea43 0080 	orr.w	r0, r3, r0, lsl #2
 8032cc8:	5488      	strb	r0, [r1, r2]
 8032cca:	b2e4      	uxtb	r4, r4
                break;
 8032ccc:	e686      	b.n	80329dc <LmhpRemoteMcastSetupOnMcpsIndication+0x4c>
                uint8_t idError = 0x01; // One bit value
 8032cce:	4610      	mov	r0, r2
 8032cd0:	e7eb      	b.n	8032caa <LmhpRemoteMcastSetupOnMcpsIndication+0x31a>
 8032cd2:	bf00      	nop
 8032cd4:	20004a38 	.word	0x20004a38
 8032cd8:	20003560 	.word	0x20003560
 8032cdc:	0803c221 	.word	0x0803c221
 8032ce0:	0803c1e6 	.word	0x0803c1e6
 8032ce4:	0803c1f9 	.word	0x0803c1f9
 8032ce8:	0803c20e 	.word	0x0803c20e
 8032cec:	0803c078 	.word	0x0803c078
 8032cf0:	0803c227 	.word	0x0803c227
 8032cf4:	0803c23a 	.word	0x0803c23a
 8032cf8:	0803c24d 	.word	0x0803c24d
 8032cfc:	0803c260 	.word	0x0803c260
 8032d00:	0803c275 	.word	0x0803c275
 8032d04:	0803c288 	.word	0x0803c288
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032d08:	5dc5      	ldrb	r5, [r0, r7]
                McSessionData[id].McGroupData.IdHeader.Value = 0;
 8032d0a:	2034      	movs	r0, #52	; 0x34
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032d0c:	f005 0503 	and.w	r5, r5, #3
                McSessionData[id].McGroupData.IdHeader.Value = 0;
 8032d10:	fb00 6705 	mla	r7, r0, r5, r6
 8032d14:	f04f 0900 	mov.w	r9, #0
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032d18:	3202      	adds	r2, #2
                UTIL_MEM_set_8( McSessionData[id].McGroupData.McKeyEncrypted, 0x00, 16 );
 8032d1a:	fb00 b005 	mla	r0, r0, r5, fp
                McSessionData[id].McGroupData.IdHeader.Value = 0;
 8032d1e:	f887 9039 	strb.w	r9, [r7, #57]	; 0x39
                McSessionData[id].McGroupData.McAddr = 0;
 8032d22:	f8c7 903c 	str.w	r9, [r7, #60]	; 0x3c
                UTIL_MEM_set_8( McSessionData[id].McGroupData.McKeyEncrypted, 0x00, 16 );
 8032d26:	4649      	mov	r1, r9
 8032d28:	3008      	adds	r0, #8
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032d2a:	fa5f f882 	uxtb.w	r8, r2
                UTIL_MEM_set_8( McSessionData[id].McGroupData.McKeyEncrypted, 0x00, 16 );
 8032d2e:	2210      	movs	r2, #16
 8032d30:	f008 f8ca 	bl	803aec8 <UTIL_MEM_set_8>
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_DELETE_ANS;
 8032d34:	6873      	ldr	r3, [r6, #4]
 8032d36:	2203      	movs	r2, #3
                McSessionData[id].McGroupData.McFCountMax = 0;
 8032d38:	e9c7 9914 	strd	r9, r9, [r7, #80]	; 0x50
                if( LoRaMacMcChannelDelete( ( AddressIdentifier_t )id ) != LORAMAC_STATUS_OK )
 8032d3c:	4628      	mov	r0, r5
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_DELETE_ANS;
 8032d3e:	f104 0901 	add.w	r9, r4, #1
 8032d42:	551a      	strb	r2, [r3, r4]
 8032d44:	fa5f f989 	uxtb.w	r9, r9
                if( LoRaMacMcChannelDelete( ( AddressIdentifier_t )id ) != LORAMAC_STATUS_OK )
 8032d48:	f002 fa84 	bl	8035254 <LoRaMacMcChannelDelete>
 8032d4c:	b140      	cbz	r0, 8032d60 <LmhpRemoteMcastSetupOnMcpsIndication+0x3d0>
                    status |= 0x04; // McGroupUndefined bit set
 8032d4e:	f045 0304 	orr.w	r3, r5, #4
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = status;
 8032d52:	6872      	ldr	r2, [r6, #4]
 8032d54:	3402      	adds	r4, #2
 8032d56:	f802 3009 	strb.w	r3, [r2, r9]
 8032d5a:	b2e4      	uxtb	r4, r4
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032d5c:	4647      	mov	r7, r8
                break;
 8032d5e:	e63d      	b.n	80329dc <LmhpRemoteMcastSetupOnMcpsIndication+0x4c>
                    McSessionData[id].McGroupData.McGroupEnabled = false;
 8032d60:	f887 0038 	strb.w	r0, [r7, #56]	; 0x38
                status = id;
 8032d64:	462b      	mov	r3, r5
 8032d66:	e7f4      	b.n	8032d52 <LmhpRemoteMcastSetupOnMcpsIndication+0x3c2>
                uint8_t status = 0x00;
 8032d68:	f04f 0300 	mov.w	r3, #0
 8032d6c:	f88d 301f 	strb.w	r3, [sp, #31]
                id = mcpsIndication->Buffer[cmdIndex++] & 0x03;
 8032d70:	5dc5      	ldrb	r5, [r0, r7]
 8032d72:	1c93      	adds	r3, r2, #2
 8032d74:	f005 0503 	and.w	r5, r5, #3
                McSessionData[id].SessionTime =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032d78:	b2db      	uxtb	r3, r3
 8032d7a:	2134      	movs	r1, #52	; 0x34
 8032d7c:	fb01 6805 	mla	r8, r1, r5, r6
 8032d80:	f102 0c03 	add.w	ip, r2, #3
 8032d84:	5cc7      	ldrb	r7, [r0, r3]
 8032d86:	f8c8 705c 	str.w	r7, [r8, #92]	; 0x5c
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032d8a:	fa5f fc8c 	uxtb.w	ip, ip
                McSessionData[id].SessionTime += UNIX_GPS_EPOCH_OFFSET;
 8032d8e:	4b51      	ldr	r3, [pc, #324]	; (8032ed4 <LmhpRemoteMcastSetupOnMcpsIndication+0x544>)
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032d90:	f810 c00c 	ldrb.w	ip, [r0, ip]
 8032d94:	eb07 270c 	add.w	r7, r7, ip, lsl #8
 8032d98:	f102 0c04 	add.w	ip, r2, #4
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032d9c:	fa5f fc8c 	uxtb.w	ip, ip
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032da0:	f8c8 705c 	str.w	r7, [r8, #92]	; 0x5c
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032da4:	f810 c00c 	ldrb.w	ip, [r0, ip]
 8032da8:	eb07 470c 	add.w	r7, r7, ip, lsl #16
 8032dac:	f102 0c05 	add.w	ip, r2, #5
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032db0:	fa5f fc8c 	uxtb.w	ip, ip
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032db4:	f8c8 705c 	str.w	r7, [r8, #92]	; 0x5c
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032db8:	f810 c00c 	ldrb.w	ip, [r0, ip]
                McSessionData[id].SessionTime += UNIX_GPS_EPOCH_OFFSET;
 8032dbc:	eb03 6c0c 	add.w	ip, r3, ip, lsl #24
 8032dc0:	4467      	add	r7, ip
 8032dc2:	f8c8 705c 	str.w	r7, [r8, #92]	; 0x5c
                McSessionData[id].SessionTime += ( mcpsIndication->Buffer[cmdIndex++] << 24 ) & 0xFF000000;
 8032dc6:	1d97      	adds	r7, r2, #6
                McSessionData[id].SessionTimeout =  mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8032dc8:	b2ff      	uxtb	r7, r7
                McSessionData[id].RxParams.ClassC.Frequency =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032dca:	f102 0c08 	add.w	ip, r2, #8
                McSessionData[id].SessionTimeout =  mcpsIndication->Buffer[cmdIndex++] & 0x0F;
 8032dce:	5dc7      	ldrb	r7, [r0, r7]
 8032dd0:	f007 070f 	and.w	r7, r7, #15
 8032dd4:	f888 7060 	strb.w	r7, [r8, #96]	; 0x60
 8032dd8:	1dd7      	adds	r7, r2, #7
                McSessionData[id].RxParams.ClassC.Frequency =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032dda:	b2ff      	uxtb	r7, r7
                McSessionData[id].RxParams.ClassC.Frequency |= ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032ddc:	fa5f fc8c 	uxtb.w	ip, ip
                McSessionData[id].RxParams.ClassC.Frequency =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032de0:	5dc7      	ldrb	r7, [r0, r7]
 8032de2:	f8c8 7064 	str.w	r7, [r8, #100]	; 0x64
                McSessionData[id].RxParams.ClassC.Frequency |= ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032de6:	f810 c00c 	ldrb.w	ip, [r0, ip]
 8032dea:	ea47 270c 	orr.w	r7, r7, ip, lsl #8
 8032dee:	f102 0c09 	add.w	ip, r2, #9
                McSessionData[id].RxParams.ClassC.Frequency |= ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032df2:	fa5f fc8c 	uxtb.w	ip, ip
                McSessionData[id].RxParams.ClassC.Frequency |= ( mcpsIndication->Buffer[cmdIndex++] << 8  ) & 0x0000FF00;
 8032df6:	f8c8 7064 	str.w	r7, [r8, #100]	; 0x64
                McSessionData[id].RxParams.ClassC.Frequency |= ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032dfa:	f810 c00c 	ldrb.w	ip, [r0, ip]
 8032dfe:	ea47 470c 	orr.w	r7, r7, ip, lsl #16
                McSessionData[id].RxParams.ClassC.Frequency *= 100;
 8032e02:	f04f 0c64 	mov.w	ip, #100	; 0x64
 8032e06:	fb0c f707 	mul.w	r7, ip, r7
 8032e0a:	f8c8 7064 	str.w	r7, [r8, #100]	; 0x64
                McSessionData[id].RxParams.ClassC.Datarate = mcpsIndication->Buffer[cmdIndex++];
 8032e0e:	f102 070b 	add.w	r7, r2, #11
                McSessionData[id].RxParams.ClassC.Frequency |= ( mcpsIndication->Buffer[cmdIndex++] << 16 ) & 0x00FF0000;
 8032e12:	320a      	adds	r2, #10
                McSessionData[id].RxParams.ClassC.Datarate = mcpsIndication->Buffer[cmdIndex++];
 8032e14:	b2d2      	uxtb	r2, r2
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_CLASS_C_SESSION_ANS;
 8032e16:	f104 0901 	add.w	r9, r4, #1
                McSessionData[id].RxParams.ClassC.Datarate = mcpsIndication->Buffer[cmdIndex++];
 8032e1a:	5c82      	ldrb	r2, [r0, r2]
 8032e1c:	f888 2068 	strb.w	r2, [r8, #104]	; 0x68
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_CLASS_C_SESSION_ANS;
 8032e20:	6872      	ldr	r2, [r6, #4]
 8032e22:	2004      	movs	r0, #4
                if( LoRaMacMcChannelSetupRxParams( ( AddressIdentifier_t )id, &McSessionData[id].RxParams, &status ) == LORAMAC_STATUS_OK )
 8032e24:	fb01 b105 	mla	r1, r1, r5, fp
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_CLASS_C_SESSION_ANS;
 8032e28:	5510      	strb	r0, [r2, r4]
 8032e2a:	fa5f f389 	uxtb.w	r3, r9
                if( LoRaMacMcChannelSetupRxParams( ( AddressIdentifier_t )id, &McSessionData[id].RxParams, &status ) == LORAMAC_STATUS_OK )
 8032e2e:	f10d 021f 	add.w	r2, sp, #31
 8032e32:	312c      	adds	r1, #44	; 0x2c
 8032e34:	4628      	mov	r0, r5
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = REMOTE_MCAST_SETUP_MC_GROUP_CLASS_C_SESSION_ANS;
 8032e36:	9303      	str	r3, [sp, #12]
                if( LoRaMacMcChannelSetupRxParams( ( AddressIdentifier_t )id, &McSessionData[id].RxParams, &status ) == LORAMAC_STATUS_OK )
 8032e38:	f002 fa3a 	bl	80352b0 <LoRaMacMcChannelSetupRxParams>
                McSessionData[id].RxParams.ClassC.Datarate = mcpsIndication->Buffer[cmdIndex++];
 8032e3c:	b2ff      	uxtb	r7, r7
                if( LoRaMacMcChannelSetupRxParams( ( AddressIdentifier_t )id, &McSessionData[id].RxParams, &status ) == LORAMAC_STATUS_OK )
 8032e3e:	4681      	mov	r9, r0
 8032e40:	2800      	cmp	r0, #0
 8032e42:	d13d      	bne.n	8032ec0 <LmhpRemoteMcastSetupOnMcpsIndication+0x530>
                    curTime = SysTimeGet( );
 8032e44:	a808      	add	r0, sp, #32
 8032e46:	f008 f961 	bl	803b10c <SysTimeGet>
                    timeToSessionStart = McSessionData[id].SessionTime - curTime.Seconds;
 8032e4a:	f8d8 105c 	ldr.w	r1, [r8, #92]	; 0x5c
 8032e4e:	9b08      	ldr	r3, [sp, #32]
 8032e50:	eba1 0803 	sub.w	r8, r1, r3
                    if( timeToSessionStart > 0 )
 8032e54:	f1b8 0f00 	cmp.w	r8, #0
 8032e58:	dd2b      	ble.n	8032eb2 <LmhpRemoteMcastSetupOnMcpsIndication+0x522>
                        TimerSetValue( &SessionStartTimer, timeToSessionStart * 1000 );
 8032e5a:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8032e5e:	fb01 f108 	mul.w	r1, r1, r8
 8032e62:	481d      	ldr	r0, [pc, #116]	; (8032ed8 <LmhpRemoteMcastSetupOnMcpsIndication+0x548>)
 8032e64:	9104      	str	r1, [sp, #16]
 8032e66:	f008 fac9 	bl	803b3fc <UTIL_TIMER_SetPeriod>
                        TimerStart( &SessionStartTimer );
 8032e6a:	481b      	ldr	r0, [pc, #108]	; (8032ed8 <LmhpRemoteMcastSetupOnMcpsIndication+0x548>)
 8032e6c:	f008 fa8c 	bl	803b388 <UTIL_TIMER_Start>
                        MW_LOG(TS_OFF, VLEVEL_M, "Time2SessionStart: %d ms\r\n", timeToSessionStart * 1000);
 8032e70:	9904      	ldr	r1, [sp, #16]
 8032e72:	9100      	str	r1, [sp, #0]
 8032e74:	4b19      	ldr	r3, [pc, #100]	; (8032edc <LmhpRemoteMcastSetupOnMcpsIndication+0x54c>)
 8032e76:	464a      	mov	r2, r9
 8032e78:	4649      	mov	r1, r9
 8032e7a:	2002      	movs	r0, #2
 8032e7c:	f007 ff12 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
                LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = status;
 8032e80:	6872      	ldr	r2, [r6, #4]
 8032e82:	f89d 101f 	ldrb.w	r1, [sp, #31]
 8032e86:	9803      	ldr	r0, [sp, #12]
 8032e88:	1ca3      	adds	r3, r4, #2
 8032e8a:	5411      	strb	r1, [r2, r0]
 8032e8c:	b2db      	uxtb	r3, r3
                if( status == 0x00 )
 8032e8e:	b971      	cbnz	r1, 8032eae <LmhpRemoteMcastSetupOnMcpsIndication+0x51e>
                    LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (timeToSessionStart >> 0) & 0xFF;
 8032e90:	f802 8003 	strb.w	r8, [r2, r3]
 8032e94:	1ce3      	adds	r3, r4, #3
                    LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (timeToSessionStart >> 8) & 0xFF;
 8032e96:	b2db      	uxtb	r3, r3
 8032e98:	ea4f 2128 	mov.w	r1, r8, asr #8
 8032e9c:	54d1      	strb	r1, [r2, r3]
                    LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (timeToSessionStart >> 16) & 0xFF;
 8032e9e:	1d63      	adds	r3, r4, #5
                    LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (timeToSessionStart >> 8) & 0xFF;
 8032ea0:	3404      	adds	r4, #4
                    LmhpRemoteMcastSetupState.DataBuffer[dataBufferIndex++] = (timeToSessionStart >> 16) & 0xFF;
 8032ea2:	b2e4      	uxtb	r4, r4
 8032ea4:	ea4f 4828 	mov.w	r8, r8, asr #16
 8032ea8:	f802 8004 	strb.w	r8, [r2, r4]
 8032eac:	b2db      	uxtb	r3, r3
                break;
 8032eae:	461c      	mov	r4, r3
 8032eb0:	e594      	b.n	80329dc <LmhpRemoteMcastSetupOnMcpsIndication+0x4c>
                        status |= 0x10;
 8032eb2:	f89d 301f 	ldrb.w	r3, [sp, #31]
 8032eb6:	f043 0310 	orr.w	r3, r3, #16
 8032eba:	f88d 301f 	strb.w	r3, [sp, #31]
 8032ebe:	e7df      	b.n	8032e80 <LmhpRemoteMcastSetupOnMcpsIndication+0x4f0>
                int32_t timeToSessionStart = 0;
 8032ec0:	f04f 0800 	mov.w	r8, #0
 8032ec4:	e7dc      	b.n	8032e80 <LmhpRemoteMcastSetupOnMcpsIndication+0x4f0>
                McSessionData[id].SessionTime =  ( mcpsIndication->Buffer[cmdIndex++] << 0  ) & 0x000000FF;
 8032ec6:	4e06      	ldr	r6, [pc, #24]	; (8032ee0 <LmhpRemoteMcastSetupOnMcpsIndication+0x550>)
    uint8_t dataBufferIndex = 0;
 8032ec8:	2400      	movs	r4, #0
    uint8_t id = 0xFF;
 8032eca:	25ff      	movs	r5, #255	; 0xff
    uint8_t cmdIndex = 0;
 8032ecc:	4622      	mov	r2, r4
                if( LoRaMacMcChannelSetupRxParams( ( AddressIdentifier_t )id, &McSessionData[id].RxParams, &status ) == LORAMAC_STATUS_OK )
 8032ece:	f106 0b38 	add.w	fp, r6, #56	; 0x38
 8032ed2:	e584      	b.n	80329de <LmhpRemoteMcastSetupOnMcpsIndication+0x4e>
 8032ed4:	12d53d80 	.word	0x12d53d80
 8032ed8:	20004a40 	.word	0x20004a40
 8032edc:	0803c1cb 	.word	0x0803c1cb
 8032ee0:	20004a38 	.word	0x20004a38

08032ee4 <LmhpRemoteMcastSetupProcess>:
{
 8032ee4:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8032ee6:	f3ef 8210 	mrs	r2, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8032eea:	b672      	cpsid	i
    state = LmhpRemoteMcastSetupState.SessionState;
 8032eec:	4c17      	ldr	r4, [pc, #92]	; (8032f4c <LmhpRemoteMcastSetupProcess+0x68>)
 8032eee:	78a3      	ldrb	r3, [r4, #2]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8032ef0:	f382 8810 	msr	PRIMASK, r2
    switch( state )
 8032ef4:	2b01      	cmp	r3, #1
 8032ef6:	d002      	beq.n	8032efe <LmhpRemoteMcastSetupProcess+0x1a>
 8032ef8:	2b02      	cmp	r3, #2
 8032efa:	d01d      	beq.n	8032f38 <LmhpRemoteMcastSetupProcess+0x54>
}
 8032efc:	bd10      	pop	{r4, pc}
            if ( LmHandlerRequestClass( CLASS_C ) == LORAMAC_HANDLER_SUCCESS )
 8032efe:	2002      	movs	r0, #2
 8032f00:	f7fe fb44 	bl	803158c <LmHandlerRequestClass>
 8032f04:	b960      	cbnz	r0, 8032f20 <LmhpRemoteMcastSetupProcess+0x3c>
                TimerSetValue( &SessionStopTimer, ( 1 << McSessionData[0].SessionTimeout ) * 1000 );
 8032f06:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
                LmhpRemoteMcastSetupState.SessionState = REMOTE_MCAST_SETUP_SESSION_STATE_IDLE;
 8032f0a:	70a0      	strb	r0, [r4, #2]
                TimerSetValue( &SessionStopTimer, ( 1 << McSessionData[0].SessionTimeout ) * 1000 );
 8032f0c:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8032f10:	4099      	lsls	r1, r3
                TimerSetValue( &SessionStopTimer, 1000 );
 8032f12:	f104 0020 	add.w	r0, r4, #32
 8032f16:	f008 fa71 	bl	803b3fc <UTIL_TIMER_SetPeriod>
                TimerStart(&SessionStopTimer);
 8032f1a:	f104 0020 	add.w	r0, r4, #32
 8032f1e:	e007      	b.n	8032f30 <LmhpRemoteMcastSetupProcess+0x4c>
                TimerSetValue( &SessionStartTimer, 1000 );
 8032f20:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8032f24:	f104 0008 	add.w	r0, r4, #8
 8032f28:	f008 fa68 	bl	803b3fc <UTIL_TIMER_SetPeriod>
                TimerStart(&SessionStartTimer);
 8032f2c:	f104 0008 	add.w	r0, r4, #8
}
 8032f30:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
                TimerStart(&SessionStopTimer);
 8032f34:	f008 ba28 	b.w	803b388 <UTIL_TIMER_Start>
            if ( LmHandlerRequestClass( CLASS_A ) == LORAMAC_HANDLER_SUCCESS )
 8032f38:	2000      	movs	r0, #0
 8032f3a:	f7fe fb27 	bl	803158c <LmHandlerRequestClass>
 8032f3e:	b908      	cbnz	r0, 8032f44 <LmhpRemoteMcastSetupProcess+0x60>
                LmhpRemoteMcastSetupState.SessionState = REMOTE_MCAST_SETUP_SESSION_STATE_IDLE;
 8032f40:	70a0      	strb	r0, [r4, #2]
 8032f42:	e7db      	b.n	8032efc <LmhpRemoteMcastSetupProcess+0x18>
                TimerSetValue( &SessionStopTimer, 1000 );
 8032f44:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8032f48:	e7e3      	b.n	8032f12 <LmhpRemoteMcastSetupProcess+0x2e>
 8032f4a:	bf00      	nop
 8032f4c:	20004a38 	.word	0x20004a38

08032f50 <LmhpRemoteMcastSetupPackageFactory>:
}
 8032f50:	4800      	ldr	r0, [pc, #0]	; (8032f54 <LmhpRemoteMcastSetupPackageFactory+0x4>)
 8032f52:	4770      	bx	lr
 8032f54:	20003560 	.word	0x20003560

08032f58 <OnRadioRxError>:
    MW_LOG(TS_ON, VLEVEL_M, "MAC txTimeOut\r\n" );
}

static void OnRadioRxError( void )
{
    LoRaMacRadioEvents.Events.RxError = 1;
 8032f58:	4b05      	ldr	r3, [pc, #20]	; (8032f70 <OnRadioRxError+0x18>)
 8032f5a:	781a      	ldrb	r2, [r3, #0]
 8032f5c:	f042 0202 	orr.w	r2, r2, #2
 8032f60:	701a      	strb	r2, [r3, #0]

    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 8032f62:	f8d3 334c 	ldr.w	r3, [r3, #844]	; 0x34c
 8032f66:	b113      	cbz	r3, 8032f6e <OnRadioRxError+0x16>
 8032f68:	691b      	ldr	r3, [r3, #16]
 8032f6a:	b103      	cbz	r3, 8032f6e <OnRadioRxError+0x16>
    {
        MacCtx.MacCallbacks->MacProcessNotify( );
 8032f6c:	4718      	bx	r3
    }
}
 8032f6e:	4770      	bx	lr
 8032f70:	20004aa4 	.word	0x20004aa4

08032f74 <UpdateRxSlotIdleState>:
    MW_LOG(TS_ON, VLEVEL_M, "MAC rxTimeOut\r\n" );
}

static void UpdateRxSlotIdleState( void )
{
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 8032f74:	4a04      	ldr	r2, [pc, #16]	; (8032f88 <UpdateRxSlotIdleState+0x14>)
 8032f76:	f892 3608 	ldrb.w	r3, [r2, #1544]	; 0x608
 8032f7a:	2b02      	cmp	r3, #2
    {
        MacCtx.RxSlot = RX_SLOT_NONE;
 8032f7c:	bf18      	it	ne
 8032f7e:	2306      	movne	r3, #6
 8032f80:	f882 3484 	strb.w	r3, [r2, #1156]	; 0x484
    }
    else
    {
        MacCtx.RxSlot = RX_SLOT_WIN_CLASS_C;
    }
}
 8032f84:	4770      	bx	lr
 8032f86:	bf00      	nop
 8032f88:	20004aa4 	.word	0x20004aa4

08032f8c <StopRetransmission>:
    return false;
}

static bool StopRetransmission( void )
{
    if( ( MacCtx.MacFlags.Bits.McpsInd == 0 ) ||
 8032f8c:	4b0f      	ldr	r3, [pc, #60]	; (8032fcc <StopRetransmission+0x40>)
 8032f8e:	f893 2485 	ldrb.w	r2, [r3, #1157]	; 0x485
 8032f92:	0792      	lsls	r2, r2, #30
 8032f94:	d503      	bpl.n	8032f9e <StopRetransmission+0x12>
 8032f96:	f893 2483 	ldrb.w	r2, [r3, #1155]	; 0x483
 8032f9a:	2a01      	cmp	r2, #1
 8032f9c:	d907      	bls.n	8032fae <StopRetransmission+0x22>
        ( ( MacCtx.RxStatus.RxSlot != RX_SLOT_WIN_1 ) &&
          ( MacCtx.RxStatus.RxSlot != RX_SLOT_WIN_2 ) ) )
    {   // Maximum repetitions without downlink. Increase ADR Ack counter.
        // Only process the case when the MAC did not receive a downlink.
        if( Nvm.MacGroup2.AdrCtrlOn == true )
 8032f9e:	f893 260a 	ldrb.w	r2, [r3, #1546]	; 0x60a
 8032fa2:	b122      	cbz	r2, 8032fae <StopRetransmission+0x22>
        {
            Nvm.MacGroup1.AdrAckCounter++;
 8032fa4:	f8d3 2534 	ldr.w	r2, [r3, #1332]	; 0x534
 8032fa8:	3201      	adds	r2, #1
 8032faa:	f8c3 2534 	str.w	r2, [r3, #1332]	; 0x534
        }
    }

    MacCtx.ChannelsNbTransCounter = 0;
 8032fae:	2200      	movs	r2, #0
 8032fb0:	f883 2414 	strb.w	r2, [r3, #1044]	; 0x414
    MacCtx.NodeAckRequested = false;
 8032fb4:	f883 2418 	strb.w	r2, [r3, #1048]	; 0x418
    MacCtx.AckTimeoutRetry = false;
 8032fb8:	f883 2417 	strb.w	r2, [r3, #1047]	; 0x417
    MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 8032fbc:	f8d3 2344 	ldr.w	r2, [r3, #836]	; 0x344
 8032fc0:	f022 0202 	bic.w	r2, r2, #2
 8032fc4:	f8c3 2344 	str.w	r2, [r3, #836]	; 0x344

    return true;
}
 8032fc8:	2001      	movs	r0, #1
 8032fca:	4770      	bx	lr
 8032fcc:	20004aa4 	.word	0x20004aa4

08032fd0 <GetMaxAppPayloadWithoutFOptsLength>:
{
 8032fd0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8032fd2:	4b0c      	ldr	r3, [pc, #48]	; (8033004 <GetMaxAppPayloadWithoutFOptsLength+0x34>)
    getPhy.Datarate = datarate;
 8032fd4:	f88d 0009 	strb.w	r0, [sp, #9]
    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8032fd8:	f893 2580 	ldrb.w	r2, [r3, #1408]	; 0x580
 8032fdc:	f88d 200a 	strb.w	r2, [sp, #10]
    getPhy.Attribute = PHY_MAX_PAYLOAD;
 8032fe0:	220d      	movs	r2, #13
 8032fe2:	f88d 2008 	strb.w	r2, [sp, #8]
    if( Nvm.MacGroup2.MacParams.RepeaterSupport == true )
 8032fe6:	f893 258c 	ldrb.w	r2, [r3, #1420]	; 0x58c
 8032fea:	b112      	cbz	r2, 8032ff2 <GetMaxAppPayloadWithoutFOptsLength+0x22>
        getPhy.Attribute = PHY_MAX_PAYLOAD_REPEATER;
 8032fec:	220e      	movs	r2, #14
 8032fee:	f88d 2008 	strb.w	r2, [sp, #8]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8032ff2:	f893 054c 	ldrb.w	r0, [r3, #1356]	; 0x54c
 8032ff6:	a902      	add	r1, sp, #8
 8032ff8:	f003 fb67 	bl	80366ca <RegionGetPhyParam>
}
 8032ffc:	b2c0      	uxtb	r0, r0
 8032ffe:	b005      	add	sp, #20
 8033000:	f85d fb04 	ldr.w	pc, [sp], #4
 8033004:	20004aa4 	.word	0x20004aa4

08033008 <OnAckTimeoutTimerEvent>:
{
 8033008:	b510      	push	{r4, lr}
    TimerStop( &MacCtx.AckTimeoutTimer );
 803300a:	4c0f      	ldr	r4, [pc, #60]	; (8033048 <OnAckTimeoutTimerEvent+0x40>)
 803300c:	f504 707f 	add.w	r0, r4, #1020	; 0x3fc
 8033010:	f008 f96a 	bl	803b2e8 <UTIL_TIMER_Stop>
    if( MacCtx.NodeAckRequested == true )
 8033014:	f894 2418 	ldrb.w	r2, [r4, #1048]	; 0x418
 8033018:	4623      	mov	r3, r4
 803301a:	b112      	cbz	r2, 8033022 <OnAckTimeoutTimerEvent+0x1a>
        MacCtx.AckTimeoutRetry = true;
 803301c:	2201      	movs	r2, #1
 803301e:	f884 2417 	strb.w	r2, [r4, #1047]	; 0x417
    if( Nvm.MacGroup2.DeviceClass == CLASS_C )
 8033022:	f893 2608 	ldrb.w	r2, [r3, #1544]	; 0x608
 8033026:	2a02      	cmp	r2, #2
        MacCtx.MacFlags.Bits.MacDone = 1;
 8033028:	bf02      	ittt	eq
 803302a:	f893 2485 	ldrbeq.w	r2, [r3, #1157]	; 0x485
 803302e:	f042 0220 	orreq.w	r2, r2, #32
 8033032:	f883 2485 	strbeq.w	r2, [r3, #1157]	; 0x485
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 8033036:	f8d3 334c 	ldr.w	r3, [r3, #844]	; 0x34c
 803303a:	b123      	cbz	r3, 8033046 <OnAckTimeoutTimerEvent+0x3e>
 803303c:	691b      	ldr	r3, [r3, #16]
 803303e:	b113      	cbz	r3, 8033046 <OnAckTimeoutTimerEvent+0x3e>
}
 8033040:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        MacCtx.MacCallbacks->MacProcessNotify( );
 8033044:	4718      	bx	r3
}
 8033046:	bd10      	pop	{r4, pc}
 8033048:	20004aa4 	.word	0x20004aa4

0803304c <PrepareRxDoneAbort>:
{
 803304c:	b510      	push	{r4, lr}
    MacCtx.MacState |= LORAMAC_RX_ABORT;
 803304e:	4c0c      	ldr	r4, [pc, #48]	; (8033080 <PrepareRxDoneAbort+0x34>)
 8033050:	f8d4 2344 	ldr.w	r2, [r4, #836]	; 0x344
 8033054:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8033058:	f8c4 2344 	str.w	r2, [r4, #836]	; 0x344
    if( MacCtx.NodeAckRequested == true )
 803305c:	f894 2418 	ldrb.w	r2, [r4, #1048]	; 0x418
 8033060:	b112      	cbz	r2, 8033068 <PrepareRxDoneAbort+0x1c>
        OnAckTimeoutTimerEvent( NULL );
 8033062:	2000      	movs	r0, #0
 8033064:	f7ff ffd0 	bl	8033008 <OnAckTimeoutTimerEvent>
    MacCtx.MacFlags.Bits.McpsInd = 1;
 8033068:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 803306c:	f023 0322 	bic.w	r3, r3, #34	; 0x22
 8033070:	f043 0322 	orr.w	r3, r3, #34	; 0x22
 8033074:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
}
 8033078:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    UpdateRxSlotIdleState( );
 803307c:	f7ff bf7a 	b.w	8032f74 <UpdateRxSlotIdleState>
 8033080:	20004aa4 	.word	0x20004aa4

08033084 <HandleRadioRxErrorTimeout>:
{
 8033084:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 8033088:	4c2c      	ldr	r4, [pc, #176]	; (803313c <HandleRadioRxErrorTimeout+0xb8>)
 803308a:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 803308e:	2b02      	cmp	r3, #2
{
 8033090:	4607      	mov	r7, r0
 8033092:	460e      	mov	r6, r1
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 8033094:	d002      	beq.n	803309c <HandleRadioRxErrorTimeout+0x18>
        Radio.Sleep( );
 8033096:	4b2a      	ldr	r3, [pc, #168]	; (8033140 <HandleRadioRxErrorTimeout+0xbc>)
 8033098:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 803309a:	4798      	blx	r3
    if( LoRaMacClassBIsBeaconExpected( ) == true )
 803309c:	f002 fc5d 	bl	803595a <LoRaMacClassBIsBeaconExpected>
 80330a0:	4605      	mov	r5, r0
 80330a2:	b128      	cbz	r0, 80330b0 <HandleRadioRxErrorTimeout+0x2c>
        LoRaMacClassBSetBeaconState( BEACON_STATE_TIMEOUT );
 80330a4:	2002      	movs	r0, #2
 80330a6:	f002 fc4e 	bl	8035946 <LoRaMacClassBSetBeaconState>
        LoRaMacClassBBeaconTimerEvent( NULL );
 80330aa:	2000      	movs	r0, #0
 80330ac:	f002 fc50 	bl	8035950 <LoRaMacClassBBeaconTimerEvent>
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 80330b0:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 80330b4:	2b01      	cmp	r3, #1
 80330b6:	d117      	bne.n	80330e8 <HandleRadioRxErrorTimeout+0x64>
        if( LoRaMacClassBIsPingExpected( ) == true )
 80330b8:	f002 fc51 	bl	803595e <LoRaMacClassBIsPingExpected>
 80330bc:	4680      	mov	r8, r0
 80330be:	b130      	cbz	r0, 80330ce <HandleRadioRxErrorTimeout+0x4a>
            LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 80330c0:	2000      	movs	r0, #0
 80330c2:	f002 fc41 	bl	8035948 <LoRaMacClassBSetPingSlotState>
            LoRaMacClassBPingSlotTimerEvent( NULL );
 80330c6:	2000      	movs	r0, #0
 80330c8:	f002 fc43 	bl	8035952 <LoRaMacClassBPingSlotTimerEvent>
            classBRx = true;
 80330cc:	4645      	mov	r5, r8
        if( LoRaMacClassBIsMulticastExpected( ) == true )
 80330ce:	f002 fc48 	bl	8035962 <LoRaMacClassBIsMulticastExpected>
 80330d2:	b148      	cbz	r0, 80330e8 <HandleRadioRxErrorTimeout+0x64>
            LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 80330d4:	2000      	movs	r0, #0
 80330d6:	f002 fc38 	bl	803594a <LoRaMacClassBSetMulticastSlotState>
            LoRaMacClassBMulticastSlotTimerEvent( NULL );
 80330da:	2000      	movs	r0, #0
 80330dc:	f002 fc3a 	bl	8035954 <LoRaMacClassBMulticastSlotTimerEvent>
}
 80330e0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    UpdateRxSlotIdleState( );
 80330e4:	f7ff bf46 	b.w	8032f74 <UpdateRxSlotIdleState>
    if( classBRx == false )
 80330e8:	2d00      	cmp	r5, #0
 80330ea:	d1f9      	bne.n	80330e0 <HandleRadioRxErrorTimeout+0x5c>
        if( MacCtx.RxSlot == RX_SLOT_WIN_1 )
 80330ec:	f894 2484 	ldrb.w	r2, [r4, #1156]	; 0x484
 80330f0:	f894 3418 	ldrb.w	r3, [r4, #1048]	; 0x418
 80330f4:	b9ba      	cbnz	r2, 8033126 <HandleRadioRxErrorTimeout+0xa2>
            if( MacCtx.NodeAckRequested == true )
 80330f6:	b10b      	cbz	r3, 80330fc <HandleRadioRxErrorTimeout+0x78>
                MacCtx.McpsConfirm.Status = rx1EventInfoStatus;
 80330f8:	f884 743d 	strb.w	r7, [r4, #1085]	; 0x43d
            LoRaMacConfirmQueueSetStatusCmn( rx1EventInfoStatus );
 80330fc:	4638      	mov	r0, r7
 80330fe:	f002 fdd9 	bl	8035cb4 <LoRaMacConfirmQueueSetStatusCmn>
            if( TimerGetElapsedTime( Nvm.MacGroup1.LastTxDoneTime ) >= MacCtx.RxWindow2Delay )
 8033102:	f8d4 0538 	ldr.w	r0, [r4, #1336]	; 0x538
 8033106:	f008 f8b5 	bl	803b274 <UTIL_TIMER_GetElapsedTime>
 803310a:	f8d4 33b8 	ldr.w	r3, [r4, #952]	; 0x3b8
 803310e:	4298      	cmp	r0, r3
 8033110:	d3e6      	bcc.n	80330e0 <HandleRadioRxErrorTimeout+0x5c>
                TimerStop( &MacCtx.RxWindowTimer2 );
 8033112:	480c      	ldr	r0, [pc, #48]	; (8033144 <HandleRadioRxErrorTimeout+0xc0>)
 8033114:	f008 f8e8 	bl	803b2e8 <UTIL_TIMER_Stop>
                MacCtx.MacFlags.Bits.MacDone = 1;
 8033118:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 803311c:	f043 0320 	orr.w	r3, r3, #32
 8033120:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
 8033124:	e7dc      	b.n	80330e0 <HandleRadioRxErrorTimeout+0x5c>
            if( MacCtx.NodeAckRequested == true )
 8033126:	b10b      	cbz	r3, 803312c <HandleRadioRxErrorTimeout+0xa8>
                MacCtx.McpsConfirm.Status = rx2EventInfoStatus;
 8033128:	f884 643d 	strb.w	r6, [r4, #1085]	; 0x43d
            LoRaMacConfirmQueueSetStatusCmn( rx2EventInfoStatus );
 803312c:	4630      	mov	r0, r6
 803312e:	f002 fdc1 	bl	8035cb4 <LoRaMacConfirmQueueSetStatusCmn>
            if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 8033132:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 8033136:	2b02      	cmp	r3, #2
 8033138:	d1ee      	bne.n	8033118 <HandleRadioRxErrorTimeout+0x94>
 803313a:	e7d1      	b.n	80330e0 <HandleRadioRxErrorTimeout+0x5c>
 803313c:	20004aa4 	.word	0x20004aa4
 8033140:	0803bbd8 	.word	0x0803bbd8
 8033144:	20004e40 	.word	0x20004e40

08033148 <OnRadioRxTimeout>:
    LoRaMacRadioEvents.Events.RxTimeout = 1;
 8033148:	4b09      	ldr	r3, [pc, #36]	; (8033170 <OnRadioRxTimeout+0x28>)
 803314a:	781a      	ldrb	r2, [r3, #0]
 803314c:	f042 0201 	orr.w	r2, r2, #1
{
 8033150:	b510      	push	{r4, lr}
    LoRaMacRadioEvents.Events.RxTimeout = 1;
 8033152:	701a      	strb	r2, [r3, #0]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 8033154:	f8d3 334c 	ldr.w	r3, [r3, #844]	; 0x34c
 8033158:	b113      	cbz	r3, 8033160 <OnRadioRxTimeout+0x18>
 803315a:	691b      	ldr	r3, [r3, #16]
 803315c:	b103      	cbz	r3, 8033160 <OnRadioRxTimeout+0x18>
        MacCtx.MacCallbacks->MacProcessNotify( );
 803315e:	4798      	blx	r3
}
 8033160:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    MW_LOG(TS_ON, VLEVEL_M, "MAC rxTimeOut\r\n" );
 8033164:	4b03      	ldr	r3, [pc, #12]	; (8033174 <OnRadioRxTimeout+0x2c>)
 8033166:	2201      	movs	r2, #1
 8033168:	2100      	movs	r1, #0
 803316a:	2002      	movs	r0, #2
 803316c:	f007 bd9a 	b.w	803aca4 <UTIL_ADV_TRACE_COND_FSend>
 8033170:	20004aa4 	.word	0x20004aa4
 8033174:	0803c29e 	.word	0x0803c29e

08033178 <OnRadioTxTimeout>:
    LoRaMacRadioEvents.Events.TxTimeout = 1;
 8033178:	4b09      	ldr	r3, [pc, #36]	; (80331a0 <OnRadioTxTimeout+0x28>)
 803317a:	781a      	ldrb	r2, [r3, #0]
 803317c:	f042 0204 	orr.w	r2, r2, #4
{
 8033180:	b510      	push	{r4, lr}
    LoRaMacRadioEvents.Events.TxTimeout = 1;
 8033182:	701a      	strb	r2, [r3, #0]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 8033184:	f8d3 334c 	ldr.w	r3, [r3, #844]	; 0x34c
 8033188:	b113      	cbz	r3, 8033190 <OnRadioTxTimeout+0x18>
 803318a:	691b      	ldr	r3, [r3, #16]
 803318c:	b103      	cbz	r3, 8033190 <OnRadioTxTimeout+0x18>
        MacCtx.MacCallbacks->MacProcessNotify( );
 803318e:	4798      	blx	r3
}
 8033190:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    MW_LOG(TS_ON, VLEVEL_M, "MAC txTimeOut\r\n" );
 8033194:	4b03      	ldr	r3, [pc, #12]	; (80331a4 <OnRadioTxTimeout+0x2c>)
 8033196:	2201      	movs	r2, #1
 8033198:	2100      	movs	r1, #0
 803319a:	2002      	movs	r0, #2
 803319c:	f007 bd82 	b.w	803aca4 <UTIL_ADV_TRACE_COND_FSend>
 80331a0:	20004aa4 	.word	0x20004aa4
 80331a4:	0803c2ae 	.word	0x0803c2ae

080331a8 <OnRadioRxDone>:
{
 80331a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80331ac:	4616      	mov	r6, r2
 80331ae:	461d      	mov	r5, r3
 80331b0:	4680      	mov	r8, r0
 80331b2:	460f      	mov	r7, r1
    RxDoneParams.LastRxDone = TimerGetCurrentTime( );
 80331b4:	f008 f854 	bl	803b260 <UTIL_TIMER_GetCurrentTime>
    LoRaMacRadioEvents.Events.RxDone = 1;
 80331b8:	4b0c      	ldr	r3, [pc, #48]	; (80331ec <OnRadioRxDone+0x44>)
    RxDoneParams.LastRxDone = TimerGetCurrentTime( );
 80331ba:	4c0d      	ldr	r4, [pc, #52]	; (80331f0 <OnRadioRxDone+0x48>)
    LoRaMacRadioEvents.Events.RxDone = 1;
 80331bc:	781a      	ldrb	r2, [r3, #0]
    RxDoneParams.Size = size;
 80331be:	8127      	strh	r7, [r4, #8]
    LoRaMacRadioEvents.Events.RxDone = 1;
 80331c0:	f042 0208 	orr.w	r2, r2, #8
 80331c4:	701a      	strb	r2, [r3, #0]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 80331c6:	f8d3 334c 	ldr.w	r3, [r3, #844]	; 0x34c
    RxDoneParams.Rssi = rssi;
 80331ca:	8166      	strh	r6, [r4, #10]
    RxDoneParams.Payload = payload;
 80331cc:	e9c4 0800 	strd	r0, r8, [r4]
    RxDoneParams.Snr = snr;
 80331d0:	7325      	strb	r5, [r4, #12]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 80331d2:	b113      	cbz	r3, 80331da <OnRadioRxDone+0x32>
 80331d4:	691b      	ldr	r3, [r3, #16]
 80331d6:	b103      	cbz	r3, 80331da <OnRadioRxDone+0x32>
        MacCtx.MacCallbacks->MacProcessNotify( );
 80331d8:	4798      	blx	r3
}
 80331da:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    MW_LOG(TS_ON, VLEVEL_M, "MAC rxDone\r\n" );
 80331de:	4b05      	ldr	r3, [pc, #20]	; (80331f4 <OnRadioRxDone+0x4c>)
 80331e0:	2201      	movs	r2, #1
 80331e2:	2100      	movs	r1, #0
 80331e4:	2002      	movs	r0, #2
 80331e6:	f007 bd5d 	b.w	803aca4 <UTIL_ADV_TRACE_COND_FSend>
 80331ea:	bf00      	nop
 80331ec:	20004aa4 	.word	0x20004aa4
 80331f0:	20006314 	.word	0x20006314
 80331f4:	0803c2be 	.word	0x0803c2be

080331f8 <OnRadioTxDone>:
{
 80331f8:	b537      	push	{r0, r1, r2, r4, r5, lr}
    TxDoneParams.CurTime = TimerGetCurrentTime( );
 80331fa:	f008 f831 	bl	803b260 <UTIL_TIMER_GetCurrentTime>
 80331fe:	4b10      	ldr	r3, [pc, #64]	; (8033240 <OnRadioTxDone+0x48>)
    MacCtx.LastTxSysTime = SysTimeGet( );
 8033200:	4c10      	ldr	r4, [pc, #64]	; (8033244 <OnRadioTxDone+0x4c>)
    TxDoneParams.CurTime = TimerGetCurrentTime( );
 8033202:	6018      	str	r0, [r3, #0]
    MacCtx.LastTxSysTime = SysTimeGet( );
 8033204:	466d      	mov	r5, sp
 8033206:	4628      	mov	r0, r5
 8033208:	f007 ff80 	bl	803b10c <SysTimeGet>
 803320c:	e895 0003 	ldmia.w	r5, {r0, r1}
 8033210:	f504 734f 	add.w	r3, r4, #828	; 0x33c
 8033214:	e883 0003 	stmia.w	r3, {r0, r1}
    LoRaMacRadioEvents.Events.TxDone = 1;
 8033218:	7823      	ldrb	r3, [r4, #0]
 803321a:	f043 0310 	orr.w	r3, r3, #16
 803321e:	7023      	strb	r3, [r4, #0]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 8033220:	f8d4 334c 	ldr.w	r3, [r4, #844]	; 0x34c
 8033224:	b113      	cbz	r3, 803322c <OnRadioTxDone+0x34>
 8033226:	691b      	ldr	r3, [r3, #16]
 8033228:	b103      	cbz	r3, 803322c <OnRadioTxDone+0x34>
        MacCtx.MacCallbacks->MacProcessNotify( );
 803322a:	4798      	blx	r3
    MW_LOG(TS_ON, VLEVEL_M, "MAC txDone\r\n" );
 803322c:	4b06      	ldr	r3, [pc, #24]	; (8033248 <OnRadioTxDone+0x50>)
 803322e:	2201      	movs	r2, #1
 8033230:	2100      	movs	r1, #0
 8033232:	2002      	movs	r0, #2
}
 8033234:	b003      	add	sp, #12
 8033236:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    MW_LOG(TS_ON, VLEVEL_M, "MAC txDone\r\n" );
 803323a:	f007 bd33 	b.w	803aca4 <UTIL_ADV_TRACE_COND_FSend>
 803323e:	bf00      	nop
 8033240:	20006310 	.word	0x20006310
 8033244:	20004aa4 	.word	0x20004aa4
 8033248:	0803c2cb 	.word	0x0803c2cb

0803324c <ResetMacParameters>:
{
 803324c:	b5f0      	push	{r4, r5, r6, r7, lr}
    Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_NONE;
 803324e:	4c46      	ldr	r4, [pc, #280]	; (8033368 <ResetMacParameters+0x11c>)
    Nvm.MacGroup1.ChannelsTxPower = Nvm.MacGroup2.ChannelsTxPowerDefault;
 8033250:	f8b4 25d0 	ldrh.w	r2, [r4, #1488]	; 0x5d0
    Nvm.MacGroup2.MacParams.Rx2Channel = Nvm.MacGroup2.MacParamsDefaults.Rx2Channel;
 8033254:	f8d4 15b4 	ldr.w	r1, [r4, #1460]	; 0x5b4
 8033258:	f8d4 05b0 	ldr.w	r0, [r4, #1456]	; 0x5b0
    Nvm.MacGroup1.ChannelsTxPower = Nvm.MacGroup2.ChannelsTxPowerDefault;
 803325c:	f8a4 2544 	strh.w	r2, [r4, #1348]	; 0x544
    Nvm.MacGroup2.MacParams.Rx1DrOffset = Nvm.MacGroup2.MacParamsDefaults.Rx1DrOffset;
 8033260:	f894 25ad 	ldrb.w	r2, [r4, #1453]	; 0x5ad
 8033264:	f884 256d 	strb.w	r2, [r4, #1389]	; 0x56d
    Nvm.MacGroup2.MacParams.Rx2Channel = Nvm.MacGroup2.MacParamsDefaults.Rx2Channel;
 8033268:	f504 62ae 	add.w	r2, r4, #1392	; 0x570
 803326c:	e882 0003 	stmia.w	r2, {r0, r1}
    Nvm.MacGroup2.MacParams.RxCChannel = Nvm.MacGroup2.MacParamsDefaults.RxCChannel;
 8033270:	f8d4 15bc 	ldr.w	r1, [r4, #1468]	; 0x5bc
 8033274:	f8d4 05b8 	ldr.w	r0, [r4, #1464]	; 0x5b8
 8033278:	f504 62af 	add.w	r2, r4, #1400	; 0x578
{
 803327c:	b08f      	sub	sp, #60	; 0x3c
    Nvm.MacGroup2.MacParams.RxCChannel = Nvm.MacGroup2.MacParamsDefaults.RxCChannel;
 803327e:	e882 0003 	stmia.w	r2, {r0, r1}
    Nvm.MacGroup2.MacParams.UplinkDwellTime = Nvm.MacGroup2.MacParamsDefaults.UplinkDwellTime;
 8033282:	f8b4 25c0 	ldrh.w	r2, [r4, #1472]	; 0x5c0
 8033286:	f8a4 2580 	strh.w	r2, [r4, #1408]	; 0x580
    Nvm.MacGroup2.AggregatedDCycle = 1;
 803328a:	2301      	movs	r3, #1
    Nvm.MacGroup2.MacParams.MaxEirp = Nvm.MacGroup2.MacParamsDefaults.MaxEirp;
 803328c:	f8d4 25c4 	ldr.w	r2, [r4, #1476]	; 0x5c4
    Nvm.MacGroup2.AggregatedDCycle = 1;
 8033290:	f8a4 360e 	strh.w	r3, [r4, #1550]	; 0x60e
    Nvm.MacGroup2.MacParams.MaxEirp = Nvm.MacGroup2.MacParamsDefaults.MaxEirp;
 8033294:	f8c4 2584 	str.w	r2, [r4, #1412]	; 0x584
    params.Type = INIT_TYPE_RESET_TO_DEFAULT_CHANNELS;
 8033298:	f88d 3014 	strb.w	r3, [sp, #20]
    Nvm.MacGroup2.MacParams.AntennaGain = Nvm.MacGroup2.MacParamsDefaults.AntennaGain;
 803329c:	f8d4 25c8 	ldr.w	r2, [r4, #1480]	; 0x5c8
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 80332a0:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    Nvm.MacGroup2.MacParams.AntennaGain = Nvm.MacGroup2.MacParamsDefaults.AntennaGain;
 80332a4:	f8c4 2588 	str.w	r2, [r4, #1416]	; 0x588
    params.NvmGroup1 = &Nvm.RegionGroup1;
 80332a8:	f504 63e5 	add.w	r3, r4, #1832	; 0x728
    Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_NONE;
 80332ac:	2500      	movs	r5, #0
    MacCtx.ChannelsNbTransCounter = 0;
 80332ae:	4a2f      	ldr	r2, [pc, #188]	; (803336c <ResetMacParameters+0x120>)
    params.NvmGroup1 = &Nvm.RegionGroup1;
 80332b0:	9303      	str	r3, [sp, #12]
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 80332b2:	a903      	add	r1, sp, #12
    params.NvmGroup2 = &Nvm.RegionGroup2;
 80332b4:	f204 73cc 	addw	r3, r4, #1996	; 0x7cc
    MacCtx.ChannelsNbTransCounter = 0;
 80332b8:	f8c4 2414 	str.w	r2, [r4, #1044]	; 0x414
    params.NvmGroup2 = &Nvm.RegionGroup2;
 80332bc:	9304      	str	r3, [sp, #16]
    Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_NONE;
 80332be:	f884 561c 	strb.w	r5, [r4, #1564]	; 0x61c
    Nvm.MacGroup1.AdrAckCounter = 0;
 80332c2:	f8c4 5534 	str.w	r5, [r4, #1332]	; 0x534
    Nvm.MacGroup2.MaxDCycle = 0;
 80332c6:	f884 560b 	strb.w	r5, [r4, #1547]	; 0x60b
    MacCtx.NodeAckRequested = false;
 80332ca:	f884 5418 	strb.w	r5, [r4, #1048]	; 0x418
    Nvm.MacGroup1.SrvAckRequested = false;
 80332ce:	f884 5546 	strb.w	r5, [r4, #1350]	; 0x546
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 80332d2:	f003 fa15 	bl	8036700 <RegionInitDefaults>
    MacCtx.RxWindow2Config.Frequency = Nvm.MacGroup2.MacParams.Rx2Channel.Frequency;
 80332d6:	f8d4 3570 	ldr.w	r3, [r4, #1392]	; 0x570
 80332da:	f8c4 33d4 	str.w	r3, [r4, #980]	; 0x3d4
    MacCtx.RxWindow2Config.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 80332de:	f894 3581 	ldrb.w	r3, [r4, #1409]	; 0x581
 80332e2:	f884 33e0 	strb.w	r3, [r4, #992]	; 0x3e0
    MacCtx.RxWindow2Config.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport; /* ST_WORKAROUND: Keep repeater feature */
 80332e6:	f894 358c 	ldrb.w	r3, [r4, #1420]	; 0x58c
 80332ea:	f884 33e1 	strb.w	r3, [r4, #993]	; 0x3e1
    MacCtx.RxWindow2Config.RxContinuous = false;
 80332ee:	f44f 7380 	mov.w	r3, #256	; 0x100
 80332f2:	f8a4 33e2 	strh.w	r3, [r4, #994]	; 0x3e2
    MacCtx.RxWindow2Config.Channel = MacCtx.Channel;
 80332f6:	f884 53d0 	strb.w	r5, [r4, #976]	; 0x3d0
    MacCtx.RxWindowCConfig = MacCtx.RxWindow2Config;
 80332fa:	f504 7774 	add.w	r7, r4, #976	; 0x3d0
 80332fe:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8033300:	f504 7679 	add.w	r6, r4, #996	; 0x3e4
 8033304:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8033306:	683b      	ldr	r3, [r7, #0]
 8033308:	6033      	str	r3, [r6, #0]
    MacCtx.RxWindowCConfig.RxContinuous = true;
 803330a:	f240 2301 	movw	r3, #513	; 0x201
 803330e:	f8a4 33f6 	strh.w	r3, [r4, #1014]	; 0x3f6
    if( MacCtx.MacCallbacks != NULL )
 8033312:	f8d4 334c 	ldr.w	r3, [r4, #844]	; 0x34c
    MacCtx.Channel = 0;
 8033316:	f884 5419 	strb.w	r5, [r4, #1049]	; 0x419
    classBCallbacks.MacProcessNotify = NULL;
 803331a:	e9cd 5501 	strd	r5, r5, [sp, #4]
    if( MacCtx.MacCallbacks != NULL )
 803331e:	b11b      	cbz	r3, 8033328 <ResetMacParameters+0xdc>
        classBCallbacks.GetTemperatureLevel = MacCtx.MacCallbacks->GetTemperatureLevel;
 8033320:	685a      	ldr	r2, [r3, #4]
        classBCallbacks.MacProcessNotify = MacCtx.MacCallbacks->MacProcessNotify;
 8033322:	691b      	ldr	r3, [r3, #16]
        classBCallbacks.GetTemperatureLevel = MacCtx.MacCallbacks->GetTemperatureLevel;
 8033324:	9201      	str	r2, [sp, #4]
        classBCallbacks.MacProcessNotify = MacCtx.MacCallbacks->MacProcessNotify;
 8033326:	9302      	str	r3, [sp, #8]
    classBParams.MlmeIndication = &MacCtx.MlmeIndication;
 8033328:	4a11      	ldr	r2, [pc, #68]	; (8033370 <ResetMacParameters+0x124>)
 803332a:	9206      	str	r2, [sp, #24]
    classBParams.McpsIndication = &MacCtx.McpsIndication;
 803332c:	f1a2 0344 	sub.w	r3, r2, #68	; 0x44
 8033330:	9307      	str	r3, [sp, #28]
    classBParams.MlmeConfirm = &MacCtx.MlmeConfirm;
 8033332:	f1a2 0314 	sub.w	r3, r2, #20
 8033336:	9308      	str	r3, [sp, #32]
    classBParams.LoRaMacFlags = &MacCtx.MacFlags;
 8033338:	f102 0321 	add.w	r3, r2, #33	; 0x21
 803333c:	9309      	str	r3, [sp, #36]	; 0x24
    classBParams.LoRaMacDevAddr = &Nvm.MacGroup2.DevAddr;
 803333e:	f502 73ba 	add.w	r3, r2, #372	; 0x174
 8033342:	930a      	str	r3, [sp, #40]	; 0x28
    classBParams.LoRaMacRegion = &Nvm.MacGroup2.Region;
 8033344:	f102 03e8 	add.w	r3, r2, #232	; 0xe8
 8033348:	930b      	str	r3, [sp, #44]	; 0x2c
    classBParams.LoRaMacParams = &Nvm.MacGroup2.MacParams;
 803334a:	f102 03ec 	add.w	r3, r2, #236	; 0xec
 803334e:	930c      	str	r3, [sp, #48]	; 0x30
    LoRaMacClassBInit( &classBParams, &classBCallbacks, &Nvm.ClassB );
 8033350:	a901      	add	r1, sp, #4
    classBParams.MulticastChannels = &Nvm.MacGroup2.MulticastChannelList[0];
 8033352:	f502 73bc 	add.w	r3, r2, #376	; 0x178
    LoRaMacClassBInit( &classBParams, &classBCallbacks, &Nvm.ClassB );
 8033356:	a806      	add	r0, sp, #24
 8033358:	f202 62e4 	addw	r2, r2, #1764	; 0x6e4
    classBParams.MulticastChannels = &Nvm.MacGroup2.MulticastChannelList[0];
 803335c:	930d      	str	r3, [sp, #52]	; 0x34
    LoRaMacClassBInit( &classBParams, &classBCallbacks, &Nvm.ClassB );
 803335e:	f002 faf1 	bl	8035944 <LoRaMacClassBInit>
}
 8033362:	b00f      	add	sp, #60	; 0x3c
 8033364:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8033366:	bf00      	nop
 8033368:	20004aa4 	.word	0x20004aa4
 803336c:	00010100 	.word	0x00010100
 8033370:	20004f08 	.word	0x20004f08

08033374 <ScheduleTx>:
{
 8033374:	b5f0      	push	{r4, r5, r6, r7, lr}
 8033376:	b093      	sub	sp, #76	; 0x4c
 8033378:	4607      	mov	r7, r0
    if( LoRaMacClassBIsBeaconExpected( ) == true )
 803337a:	f002 faee 	bl	803595a <LoRaMacClassBIsBeaconExpected>
 803337e:	2800      	cmp	r0, #0
 8033380:	f040 8163 	bne.w	803364a <ScheduleTx+0x2d6>
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 8033384:	4cb2      	ldr	r4, [pc, #712]	; (8033650 <ScheduleTx+0x2dc>)
 8033386:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 803338a:	2b01      	cmp	r3, #1
 803338c:	d009      	beq.n	80333a2 <ScheduleTx+0x2e>
    if( Nvm.MacGroup1.AggregatedTimeOff == 0 )
 803338e:	f8d4 353c 	ldr.w	r3, [r4, #1340]	; 0x53c
 8033392:	b193      	cbz	r3, 80333ba <ScheduleTx+0x46>
    switch( MacCtx.TxMsg.Type )
 8033394:	f894 3108 	ldrb.w	r3, [r4, #264]	; 0x108
 8033398:	b1c3      	cbz	r3, 80333cc <ScheduleTx+0x58>
 803339a:	2b04      	cmp	r3, #4
 803339c:	d076      	beq.n	803348c <ScheduleTx+0x118>
            return LORAMAC_STATUS_PARAMETER_INVALID;
 803339e:	2503      	movs	r5, #3
 80333a0:	e003      	b.n	80333aa <ScheduleTx+0x36>
        if( LoRaMacClassBIsPingExpected( ) == true )
 80333a2:	f002 fadc 	bl	803595e <LoRaMacClassBIsPingExpected>
 80333a6:	b118      	cbz	r0, 80333b0 <ScheduleTx+0x3c>
            return LORAMAC_STATUS_BUSY_PING_SLOT_WINDOW_TIME;
 80333a8:	250f      	movs	r5, #15
}
 80333aa:	4628      	mov	r0, r5
 80333ac:	b013      	add	sp, #76	; 0x4c
 80333ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
        else if( LoRaMacClassBIsMulticastExpected( ) == true )
 80333b0:	f002 fad7 	bl	8035962 <LoRaMacClassBIsMulticastExpected>
 80333b4:	2800      	cmp	r0, #0
 80333b6:	d0ea      	beq.n	803338e <ScheduleTx+0x1a>
 80333b8:	e7f6      	b.n	80333a8 <ScheduleTx+0x34>
        Nvm.MacGroup1.AggregatedTimeOff = ( MacCtx.TxTimeOnAir * Nvm.MacGroup2.AggregatedDCycle - MacCtx.TxTimeOnAir );
 80333ba:	f8b4 360e 	ldrh.w	r3, [r4, #1550]	; 0x60e
 80333be:	1e5a      	subs	r2, r3, #1
 80333c0:	f8d4 341c 	ldr.w	r3, [r4, #1052]	; 0x41c
 80333c4:	4353      	muls	r3, r2
 80333c6:	f8c4 353c 	str.w	r3, [r4, #1340]	; 0x53c
 80333ca:	e7e3      	b.n	8033394 <ScheduleTx+0x20>
            serializeStatus = LoRaMacSerializerJoinRequest( &MacCtx.TxMsg.Message.JoinReq );
 80333cc:	48a1      	ldr	r0, [pc, #644]	; (8033654 <ScheduleTx+0x2e0>)
 80333ce:	f003 f8ce 	bl	803656e <LoRaMacSerializerJoinRequest>
            if( LORAMAC_SERIALIZER_SUCCESS != serializeStatus )
 80333d2:	2800      	cmp	r0, #0
 80333d4:	f040 8135 	bne.w	8033642 <ScheduleTx+0x2ce>
            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.Data.BufSize;
 80333d8:	f894 3110 	ldrb.w	r3, [r4, #272]	; 0x110
 80333dc:	80a3      	strh	r3, [r4, #4]
    nextChan.AggrTimeOff = Nvm.MacGroup1.AggregatedTimeOff;
 80333de:	f8d4 353c 	ldr.w	r3, [r4, #1340]	; 0x53c
 80333e2:	930c      	str	r3, [sp, #48]	; 0x30
    nextChan.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );
 80333e4:	ae06      	add	r6, sp, #24
    nextChan.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 80333e6:	f894 3545 	ldrb.w	r3, [r4, #1349]	; 0x545
 80333ea:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
    nextChan.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );
 80333ee:	4630      	mov	r0, r6
    nextChan.DutyCycleEnabled = Nvm.MacGroup2.DutyCycleOn;
 80333f0:	f894 360c 	ldrb.w	r3, [r4, #1548]	; 0x60c
 80333f4:	f88d 303a 	strb.w	r3, [sp, #58]	; 0x3a
    nextChan.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );
 80333f8:	f007 feae 	bl	803b158 <SysTimeGetMcuTime>
 80333fc:	f8d4 3614 	ldr.w	r3, [r4, #1556]	; 0x614
 8033400:	9300      	str	r3, [sp, #0]
 8033402:	ad02      	add	r5, sp, #8
 8033404:	e896 0006 	ldmia.w	r6, {r1, r2}
 8033408:	f8d4 3610 	ldr.w	r3, [r4, #1552]	; 0x610
 803340c:	4628      	mov	r0, r5
 803340e:	f007 fe39 	bl	803b084 <SysTimeSub>
 8033412:	e895 0003 	ldmia.w	r5, {r0, r1}
 8033416:	ab0f      	add	r3, sp, #60	; 0x3c
 8033418:	e883 0003 	stmia.w	r3, {r0, r1}
    nextChan.LastAggrTx = Nvm.MacGroup1.LastTxDoneTime;
 803341c:	f8d4 3538 	ldr.w	r3, [r4, #1336]	; 0x538
 8033420:	930d      	str	r3, [sp, #52]	; 0x34
    nextChan.LastTxIsJoinRequest = false;
 8033422:	2300      	movs	r3, #0
 8033424:	f88d 3044 	strb.w	r3, [sp, #68]	; 0x44
    nextChan.PktLen = MacCtx.PktBufferLen;
 8033428:	88a3      	ldrh	r3, [r4, #4]
 803342a:	f8ad 3046 	strh.w	r3, [sp, #70]	; 0x46
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 803342e:	f894 361c 	ldrb.w	r3, [r4, #1564]	; 0x61c
    nextChan.Joined = true;
 8033432:	2201      	movs	r2, #1
 8033434:	f88d 2039 	strb.w	r2, [sp, #57]	; 0x39
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 8033438:	b91b      	cbnz	r3, 8033442 <ScheduleTx+0xce>
        nextChan.LastTxIsJoinRequest = true;
 803343a:	f88d 2044 	strb.w	r2, [sp, #68]	; 0x44
        nextChan.Joined = false;
 803343e:	f88d 3039 	strb.w	r3, [sp, #57]	; 0x39
    status = RegionNextChannel( Nvm.MacGroup2.Region, &nextChan, &MacCtx.Channel, &MacCtx.DutyCycleWaitTime, &Nvm.MacGroup1.AggregatedTimeOff );
 8033442:	4e85      	ldr	r6, [pc, #532]	; (8033658 <ScheduleTx+0x2e4>)
 8033444:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
 8033448:	9600      	str	r6, [sp, #0]
 803344a:	f46f 7291 	mvn.w	r2, #290	; 0x122
 803344e:	f1a6 03b4 	sub.w	r3, r6, #180	; 0xb4
 8033452:	18b2      	adds	r2, r6, r2
 8033454:	a90c      	add	r1, sp, #48	; 0x30
 8033456:	f003 fa06 	bl	8036866 <RegionNextChannel>
    if( status != LORAMAC_STATUS_OK )
 803345a:	4605      	mov	r5, r0
 803345c:	b1d0      	cbz	r0, 8033494 <ScheduleTx+0x120>
        if( ( status == LORAMAC_STATUS_DUTYCYCLE_RESTRICTED ) &&
 803345e:	280b      	cmp	r0, #11
 8033460:	d1a3      	bne.n	80333aa <ScheduleTx+0x36>
 8033462:	2f00      	cmp	r7, #0
 8033464:	d0a1      	beq.n	80333aa <ScheduleTx+0x36>
            if( MacCtx.DutyCycleWaitTime != 0 )
 8033466:	f8d4 1488 	ldr.w	r1, [r4, #1160]	; 0x488
 803346a:	b169      	cbz	r1, 8033488 <ScheduleTx+0x114>
                MacCtx.MacState |= LORAMAC_TX_DELAYED;
 803346c:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
                TimerSetValue( &MacCtx.TxDelayedTimer, MacCtx.DutyCycleWaitTime );
 8033470:	f5a6 70e8 	sub.w	r0, r6, #464	; 0x1d0
                MacCtx.MacState |= LORAMAC_TX_DELAYED;
 8033474:	f043 0320 	orr.w	r3, r3, #32
 8033478:	f8c4 3344 	str.w	r3, [r4, #836]	; 0x344
                TimerSetValue( &MacCtx.TxDelayedTimer, MacCtx.DutyCycleWaitTime );
 803347c:	f007 ffbe 	bl	803b3fc <UTIL_TIMER_SetPeriod>
                TimerStart( &MacCtx.TxDelayedTimer );
 8033480:	f5a6 70e8 	sub.w	r0, r6, #464	; 0x1d0
 8033484:	f007 ff80 	bl	803b388 <UTIL_TIMER_Start>
            return LORAMAC_STATUS_OK;
 8033488:	2500      	movs	r5, #0
 803348a:	e78e      	b.n	80333aa <ScheduleTx+0x36>
            serializeStatus = LoRaMacSerializerData( &MacCtx.TxMsg.Message.Data );
 803348c:	4871      	ldr	r0, [pc, #452]	; (8033654 <ScheduleTx+0x2e0>)
 803348e:	f003 f8a2 	bl	80365d6 <LoRaMacSerializerData>
 8033492:	e79e      	b.n	80333d2 <ScheduleTx+0x5e>
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 8033494:	f894 754c 	ldrb.w	r7, [r4, #1356]	; 0x54c
                                     RegionApplyDrOffset( Nvm.MacGroup2.Region,
 8033498:	f994 356d 	ldrsb.w	r3, [r4, #1389]	; 0x56d
 803349c:	f994 2545 	ldrsb.w	r2, [r4, #1349]	; 0x545
 80334a0:	f894 1581 	ldrb.w	r1, [r4, #1409]	; 0x581
 80334a4:	4638      	mov	r0, r7
 80334a6:	f003 f9fc 	bl	80368a2 <RegionApplyDrOffset>
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 80334aa:	f5a6 73c0 	sub.w	r3, r6, #384	; 0x180
 80334ae:	b241      	sxtb	r1, r0
 80334b0:	f894 2554 	ldrb.w	r2, [r4, #1364]	; 0x554
 80334b4:	9300      	str	r3, [sp, #0]
 80334b6:	4638      	mov	r0, r7
 80334b8:	f8d4 3550 	ldr.w	r3, [r4, #1360]	; 0x550
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 80334bc:	f5a6 76b6 	sub.w	r6, r6, #364	; 0x16c
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 80334c0:	f003 f94d 	bl	803675e <RegionComputeRxWindowParameters>
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 80334c4:	f8d4 3550 	ldr.w	r3, [r4, #1360]	; 0x550
 80334c8:	f994 1574 	ldrsb.w	r1, [r4, #1396]	; 0x574
 80334cc:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
 80334d0:	9600      	str	r6, [sp, #0]
 80334d2:	f894 2554 	ldrb.w	r2, [r4, #1364]	; 0x554
 80334d6:	f003 f942 	bl	803675e <RegionComputeRxWindowParameters>
    MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.ReceiveDelay2 + MacCtx.RxWindow2Config.WindowOffset;
 80334da:	f8d4 03dc 	ldr.w	r0, [r4, #988]	; 0x3dc
 80334de:	f8d4 1560 	ldr.w	r1, [r4, #1376]	; 0x560
    MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.ReceiveDelay1 + MacCtx.RxWindow1Config.WindowOffset;
 80334e2:	f8d4 63c8 	ldr.w	r6, [r4, #968]	; 0x3c8
 80334e6:	f8d4 355c 	ldr.w	r3, [r4, #1372]	; 0x55c
    MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.ReceiveDelay2 + MacCtx.RxWindow2Config.WindowOffset;
 80334ea:	4401      	add	r1, r0
 80334ec:	f8c4 13b8 	str.w	r1, [r4, #952]	; 0x3b8
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 80334f0:	f894 161c 	ldrb.w	r1, [r4, #1564]	; 0x61c
    MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.ReceiveDelay1 + MacCtx.RxWindow1Config.WindowOffset;
 80334f4:	4433      	add	r3, r6
 80334f6:	f8c4 33b4 	str.w	r3, [r4, #948]	; 0x3b4
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 80334fa:	b949      	cbnz	r1, 8033510 <ScheduleTx+0x19c>
        MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay1 + MacCtx.RxWindow1Config.WindowOffset;
 80334fc:	f8d4 2564 	ldr.w	r2, [r4, #1380]	; 0x564
        MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay2 + MacCtx.RxWindow2Config.WindowOffset;
 8033500:	f8d4 3568 	ldr.w	r3, [r4, #1384]	; 0x568
        MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay1 + MacCtx.RxWindow1Config.WindowOffset;
 8033504:	4432      	add	r2, r6
        MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay2 + MacCtx.RxWindow2Config.WindowOffset;
 8033506:	4403      	add	r3, r0
        MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay1 + MacCtx.RxWindow1Config.WindowOffset;
 8033508:	f8c4 23b4 	str.w	r2, [r4, #948]	; 0x3b4
        MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay2 + MacCtx.RxWindow2Config.WindowOffset;
 803350c:	f8c4 33b8 	str.w	r3, [r4, #952]	; 0x3b8
    size_t macCmdsSize = 0;
 8033510:	2300      	movs	r3, #0
 8033512:	9308      	str	r3, [sp, #32]
    if( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE )
 8033514:	b181      	cbz	r1, 8033538 <ScheduleTx+0x1c4>
        if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )
 8033516:	a808      	add	r0, sp, #32
 8033518:	f002 fae4 	bl	8035ae4 <LoRaMacCommandsGetSizeSerializedCmds>
 803351c:	2800      	cmp	r0, #0
 803351e:	d14a      	bne.n	80335b6 <ScheduleTx+0x242>
    maxN = GetMaxAppPayloadWithoutFOptsLength( datarate );
 8033520:	f994 0545 	ldrsb.w	r0, [r4, #1349]	; 0x545
        if( ValidatePayloadLength( MacCtx.AppDataSize, Nvm.MacGroup1.ChannelsDatarate, macCmdsSize ) == false )
 8033524:	f894 623b 	ldrb.w	r6, [r4, #571]	; 0x23b
 8033528:	f89d 7020 	ldrb.w	r7, [sp, #32]
    maxN = GetMaxAppPayloadWithoutFOptsLength( datarate );
 803352c:	f7ff fd50 	bl	8032fd0 <GetMaxAppPayloadWithoutFOptsLength>
    if( ( payloadSize <= maxN ) && ( payloadSize <= LORAMAC_PHY_MAXPAYLOAD ) )
 8033530:	443e      	add	r6, r7
 8033532:	b280      	uxth	r0, r0
 8033534:	42b0      	cmp	r0, r6
 8033536:	d33c      	bcc.n	80335b2 <ScheduleTx+0x23e>
    int8_t txPower = 0;
 8033538:	2300      	movs	r3, #0
 803353a:	f88d 3013 	strb.w	r3, [sp, #19]
    txConfig.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 803353e:	f894 3545 	ldrb.w	r3, [r4, #1349]	; 0x545
 8033542:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
    txConfig.TxPower = Nvm.MacGroup1.ChannelsTxPower;
 8033546:	f894 3544 	ldrb.w	r3, [r4, #1348]	; 0x544
 803354a:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    txConfig.MaxEirp = Nvm.MacGroup2.MacParams.MaxEirp;
 803354e:	f8d4 3584 	ldr.w	r3, [r4, #1412]	; 0x584
 8033552:	9309      	str	r3, [sp, #36]	; 0x24
    txConfig.AntennaGain = Nvm.MacGroup2.MacParams.AntennaGain;
 8033554:	f8d4 3588 	ldr.w	r3, [r4, #1416]	; 0x588
 8033558:	930a      	str	r3, [sp, #40]	; 0x28
    txConfig.PktLen = MacCtx.PktBufferLen;
 803355a:	88a3      	ldrh	r3, [r4, #4]
    return SendFrameOnChannel( MacCtx.Channel );
 803355c:	f894 6419 	ldrb.w	r6, [r4, #1049]	; 0x419
    txConfig.PktLen = MacCtx.PktBufferLen;
 8033560:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
    RegionTxConfig( Nvm.MacGroup2.Region, &txConfig, &txPower, &MacCtx.TxTimeOnAir );
 8033564:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
 8033568:	4b3c      	ldr	r3, [pc, #240]	; (803365c <ScheduleTx+0x2e8>)
    txConfig.Channel = channel;
 803356a:	f88d 6020 	strb.w	r6, [sp, #32]
    RegionTxConfig( Nvm.MacGroup2.Region, &txConfig, &txPower, &MacCtx.TxTimeOnAir );
 803356e:	f10d 0213 	add.w	r2, sp, #19
 8033572:	a908      	add	r1, sp, #32
 8033574:	f003 f912 	bl	803679c <RegionTxConfig>
    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 8033578:	2301      	movs	r3, #1
 803357a:	f884 343d 	strb.w	r3, [r4, #1085]	; 0x43d
    MacCtx.McpsConfirm.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 803357e:	f894 3545 	ldrb.w	r3, [r4, #1349]	; 0x545
 8033582:	f884 343e 	strb.w	r3, [r4, #1086]	; 0x43e
    MacCtx.McpsConfirm.TxPower = txPower;
 8033586:	f89d 3013 	ldrb.w	r3, [sp, #19]
 803358a:	f884 343f 	strb.w	r3, [r4, #1087]	; 0x43f
    MacCtx.McpsConfirm.TxTimeOnAir = MacCtx.TxTimeOnAir;
 803358e:	f8d4 341c 	ldr.w	r3, [r4, #1052]	; 0x41c
    MacCtx.McpsConfirm.Channel = channel;
 8033592:	f8c4 644c 	str.w	r6, [r4, #1100]	; 0x44c
    MacCtx.McpsConfirm.TxTimeOnAir = MacCtx.TxTimeOnAir;
 8033596:	f8c4 3444 	str.w	r3, [r4, #1092]	; 0x444
    MacCtx.MlmeConfirm.TxTimeOnAir = MacCtx.TxTimeOnAir;
 803359a:	f8c4 3454 	str.w	r3, [r4, #1108]	; 0x454
    if( LoRaMacClassBIsBeaconModeActive( ) == true )
 803359e:	f002 f9e2 	bl	8035966 <LoRaMacClassBIsBeaconModeActive>
 80335a2:	b150      	cbz	r0, 80335ba <ScheduleTx+0x246>
        TimerTime_t collisionTime = LoRaMacClassBIsUplinkCollision( MacCtx.TxTimeOnAir );
 80335a4:	f8d4 041c 	ldr.w	r0, [r4, #1052]	; 0x41c
 80335a8:	f002 f9ef 	bl	803598a <LoRaMacClassBIsUplinkCollision>
        if( collisionTime > 0 )
 80335ac:	b128      	cbz	r0, 80335ba <ScheduleTx+0x246>
            return LORAMAC_STATUS_BUSY_UPLINK_COLLISION;
 80335ae:	2510      	movs	r5, #16
    return SendFrameOnChannel( MacCtx.Channel );
 80335b0:	e6fb      	b.n	80333aa <ScheduleTx+0x36>
            return LORAMAC_STATUS_LENGTH_ERROR;
 80335b2:	2508      	movs	r5, #8
 80335b4:	e6f9      	b.n	80333aa <ScheduleTx+0x36>
            return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 80335b6:	2513      	movs	r5, #19
 80335b8:	e6f7      	b.n	80333aa <ScheduleTx+0x36>
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 80335ba:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 80335be:	2b01      	cmp	r3, #1
 80335c0:	d101      	bne.n	80335c6 <ScheduleTx+0x252>
        LoRaMacClassBStopRxSlots( );
 80335c2:	f002 f9e4 	bl	803598e <LoRaMacClassBStopRxSlots>
    LoRaMacClassBHaltBeaconing( );
 80335c6:	f002 f9d1 	bl	803596c <LoRaMacClassBHaltBeaconing>
    uint32_t fCntUp = 0;
 80335ca:	2300      	movs	r3, #0
 80335cc:	9305      	str	r3, [sp, #20]
    switch( MacCtx.TxMsg.Type )
 80335ce:	f894 3108 	ldrb.w	r3, [r4, #264]	; 0x108
    status = SecureFrame( Nvm.MacGroup1.ChannelsDatarate, MacCtx.Channel );
 80335d2:	f994 6545 	ldrsb.w	r6, [r4, #1349]	; 0x545
 80335d6:	f894 7419 	ldrb.w	r7, [r4, #1049]	; 0x419
    switch( MacCtx.TxMsg.Type )
 80335da:	b1bb      	cbz	r3, 803360c <ScheduleTx+0x298>
 80335dc:	2b04      	cmp	r3, #4
 80335de:	f47f aede 	bne.w	803339e <ScheduleTx+0x2a>
            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetFCntUp( &fCntUp ) )
 80335e2:	a805      	add	r0, sp, #20
 80335e4:	f002 fce2 	bl	8035fac <LoRaMacCryptoGetFCntUp>
 80335e8:	bb68      	cbnz	r0, 8033646 <ScheduleTx+0x2d2>
            if( ( MacCtx.ChannelsNbTransCounter >= 1 ) || ( MacCtx.AckTimeoutRetriesCounter > 1 ) )
 80335ea:	f894 3414 	ldrb.w	r3, [r4, #1044]	; 0x414
 80335ee:	b91b      	cbnz	r3, 80335f8 <ScheduleTx+0x284>
 80335f0:	f894 3416 	ldrb.w	r3, [r4, #1046]	; 0x416
 80335f4:	2b01      	cmp	r3, #1
 80335f6:	d902      	bls.n	80335fe <ScheduleTx+0x28a>
                fCntUp -= 1;
 80335f8:	9b05      	ldr	r3, [sp, #20]
 80335fa:	3b01      	subs	r3, #1
 80335fc:	9305      	str	r3, [sp, #20]
            macCryptoStatus = LoRaMacCryptoSecureMessage( fCntUp, txDr, txCh, &MacCtx.TxMsg.Message.Data );
 80335fe:	4b15      	ldr	r3, [pc, #84]	; (8033654 <ScheduleTx+0x2e0>)
 8033600:	9805      	ldr	r0, [sp, #20]
 8033602:	463a      	mov	r2, r7
 8033604:	b2f1      	uxtb	r1, r6
 8033606:	f002 fd47 	bl	8036098 <LoRaMacCryptoSecureMessage>
 803360a:	e002      	b.n	8033612 <ScheduleTx+0x29e>
            macCryptoStatus = LoRaMacCryptoPrepareJoinRequest( &MacCtx.TxMsg.Message.JoinReq );
 803360c:	4811      	ldr	r0, [pc, #68]	; (8033654 <ScheduleTx+0x2e0>)
 803360e:	f002 fd1b 	bl	8036048 <LoRaMacCryptoPrepareJoinRequest>
            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )
 8033612:	b9b0      	cbnz	r0, 8033642 <ScheduleTx+0x2ce>
            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.Data.BufSize;
 8033614:	f894 3110 	ldrb.w	r3, [r4, #272]	; 0x110
 8033618:	80a3      	strh	r3, [r4, #4]
    MacCtx.MacState |= LORAMAC_TX_RUNNING;
 803361a:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 803361e:	f043 0302 	orr.w	r3, r3, #2
 8033622:	f8c4 3344 	str.w	r3, [r4, #836]	; 0x344
    if( MacCtx.NodeAckRequested == false )
 8033626:	f894 3418 	ldrb.w	r3, [r4, #1048]	; 0x418
 803362a:	b923      	cbnz	r3, 8033636 <ScheduleTx+0x2c2>
        MacCtx.ChannelsNbTransCounter++;
 803362c:	f894 3414 	ldrb.w	r3, [r4, #1044]	; 0x414
 8033630:	3301      	adds	r3, #1
 8033632:	f884 3414 	strb.w	r3, [r4, #1044]	; 0x414
    Radio.Send( MacCtx.PktBuffer, MacCtx.PktBufferLen );
 8033636:	4b0a      	ldr	r3, [pc, #40]	; (8033660 <ScheduleTx+0x2ec>)
 8033638:	7921      	ldrb	r1, [r4, #4]
 803363a:	480a      	ldr	r0, [pc, #40]	; (8033664 <ScheduleTx+0x2f0>)
 803363c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 803363e:	4798      	blx	r3
    return LORAMAC_STATUS_OK;
 8033640:	e6b3      	b.n	80333aa <ScheduleTx+0x36>
                return LORAMAC_STATUS_CRYPTO_ERROR;
 8033642:	2511      	movs	r5, #17
 8033644:	e6b1      	b.n	80333aa <ScheduleTx+0x36>
                return LORAMAC_STATUS_FCNT_HANDLER_ERROR;
 8033646:	2512      	movs	r5, #18
 8033648:	e6af      	b.n	80333aa <ScheduleTx+0x36>
        return LORAMAC_STATUS_BUSY_BEACON_RESERVED_TIME;
 803364a:	250e      	movs	r5, #14
 803364c:	e6ad      	b.n	80333aa <ScheduleTx+0x36>
 803364e:	bf00      	nop
 8033650:	20004aa4 	.word	0x20004aa4
 8033654:	20004bb0 	.word	0x20004bb0
 8033658:	20004fe0 	.word	0x20004fe0
 803365c:	20004ec0 	.word	0x20004ec0
 8033660:	0803bbd8 	.word	0x0803bbd8
 8033664:	20004aaa 	.word	0x20004aaa

08033668 <OnTxDelayedTimerEvent>:
{
 8033668:	b510      	push	{r4, lr}
    TimerStop( &MacCtx.TxDelayedTimer );
 803366a:	4c11      	ldr	r4, [pc, #68]	; (80336b0 <OnTxDelayedTimerEvent+0x48>)
 803366c:	f504 705b 	add.w	r0, r4, #876	; 0x36c
 8033670:	f007 fe3a 	bl	803b2e8 <UTIL_TIMER_Stop>
    MacCtx.MacState &= ~LORAMAC_TX_DELAYED;
 8033674:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
    switch( ScheduleTx( true ) )
 8033678:	2001      	movs	r0, #1
    MacCtx.MacState &= ~LORAMAC_TX_DELAYED;
 803367a:	f023 0320 	bic.w	r3, r3, #32
 803367e:	f8c4 3344 	str.w	r3, [r4, #836]	; 0x344
    switch( ScheduleTx( true ) )
 8033682:	f7ff fe77 	bl	8033374 <ScheduleTx>
 8033686:	b190      	cbz	r0, 80336ae <OnTxDelayedTimerEvent+0x46>
 8033688:	280b      	cmp	r0, #11
 803368a:	d010      	beq.n	80336ae <OnTxDelayedTimerEvent+0x46>
            MacCtx.McpsConfirm.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 803368c:	f894 3545 	ldrb.w	r3, [r4, #1349]	; 0x545
 8033690:	f884 343e 	strb.w	r3, [r4, #1086]	; 0x43e
            MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR;
 8033694:	2009      	movs	r0, #9
            MacCtx.McpsConfirm.NbRetries = MacCtx.AckTimeoutRetriesCounter;
 8033696:	f894 3416 	ldrb.w	r3, [r4, #1046]	; 0x416
 803369a:	f884 3441 	strb.w	r3, [r4, #1089]	; 0x441
            MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR;
 803369e:	f884 043d 	strb.w	r0, [r4, #1085]	; 0x43d
            LoRaMacConfirmQueueSetStatusCmn( LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR );
 80336a2:	f002 fb07 	bl	8035cb4 <LoRaMacConfirmQueueSetStatusCmn>
}
 80336a6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            StopRetransmission( );
 80336aa:	f7ff bc6f 	b.w	8032f8c <StopRetransmission>
}
 80336ae:	bd10      	pop	{r4, pc}
 80336b0:	20004aa4 	.word	0x20004aa4

080336b4 <OpenContinuousRxCWindow>:
{
 80336b4:	b537      	push	{r0, r1, r2, r4, r5, lr}
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 80336b6:	4c12      	ldr	r4, [pc, #72]	; (8033700 <OpenContinuousRxCWindow+0x4c>)
 80336b8:	f504 7579 	add.w	r5, r4, #996	; 0x3e4
 80336bc:	f8d4 3550 	ldr.w	r3, [r4, #1360]	; 0x550
 80336c0:	f894 2554 	ldrb.w	r2, [r4, #1364]	; 0x554
 80336c4:	f994 157c 	ldrsb.w	r1, [r4, #1404]	; 0x57c
 80336c8:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
 80336cc:	9500      	str	r5, [sp, #0]
 80336ce:	f003 f846 	bl	803675e <RegionComputeRxWindowParameters>
    MacCtx.RxWindowCConfig.RxContinuous = true;
 80336d2:	f240 2301 	movw	r3, #513	; 0x201
    if( RegionRxConfig( Nvm.MacGroup2.Region, &MacCtx.RxWindowCConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )
 80336d6:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    MacCtx.RxWindowCConfig.RxContinuous = true;
 80336da:	f8a4 33f6 	strh.w	r3, [r4, #1014]	; 0x3f6
    if( RegionRxConfig( Nvm.MacGroup2.Region, &MacCtx.RxWindowCConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )
 80336de:	f204 4224 	addw	r2, r4, #1060	; 0x424
 80336e2:	4629      	mov	r1, r5
 80336e4:	f003 f84d 	bl	8036782 <RegionRxConfig>
 80336e8:	b138      	cbz	r0, 80336fa <OpenContinuousRxCWindow+0x46>
        Radio.Rx( 0 ); // Continuous mode
 80336ea:	4b06      	ldr	r3, [pc, #24]	; (8033704 <OpenContinuousRxCWindow+0x50>)
 80336ec:	2000      	movs	r0, #0
 80336ee:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80336f0:	4798      	blx	r3
        MacCtx.RxSlot = MacCtx.RxWindowCConfig.RxSlot;
 80336f2:	f894 33f7 	ldrb.w	r3, [r4, #1015]	; 0x3f7
 80336f6:	f884 3484 	strb.w	r3, [r4, #1156]	; 0x484
}
 80336fa:	b003      	add	sp, #12
 80336fc:	bd30      	pop	{r4, r5, pc}
 80336fe:	bf00      	nop
 8033700:	20004aa4 	.word	0x20004aa4
 8033704:	0803bbd8 	.word	0x0803bbd8

08033708 <SwitchClass>:
{
 8033708:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    switch( Nvm.MacGroup2.DeviceClass )
 803370a:	4f2f      	ldr	r7, [pc, #188]	; (80337c8 <SwitchClass+0xc0>)
 803370c:	f897 5608 	ldrb.w	r5, [r7, #1544]	; 0x608
 8033710:	2d01      	cmp	r5, #1
{
 8033712:	4606      	mov	r6, r0
 8033714:	463c      	mov	r4, r7
    switch( Nvm.MacGroup2.DeviceClass )
 8033716:	d046      	beq.n	80337a6 <SwitchClass+0x9e>
 8033718:	2d02      	cmp	r5, #2
 803371a:	d04c      	beq.n	80337b6 <SwitchClass+0xae>
 803371c:	b945      	cbnz	r5, 8033730 <SwitchClass+0x28>
            if( deviceClass == CLASS_A )
 803371e:	b948      	cbnz	r0, 8033734 <SwitchClass+0x2c>
                Nvm.MacGroup2.MacParams.RxCChannel = Nvm.MacGroup2.MacParams.Rx2Channel;
 8033720:	f8d7 1574 	ldr.w	r1, [r7, #1396]	; 0x574
 8033724:	f8d7 0570 	ldr.w	r0, [r7, #1392]	; 0x570
 8033728:	f507 63af 	add.w	r3, r7, #1400	; 0x578
 803372c:	e883 0003 	stmia.w	r3, {r0, r1}
    LoRaMacStatus_t status = LORAMAC_STATUS_PARAMETER_INVALID;
 8033730:	2503      	movs	r5, #3
 8033732:	e036      	b.n	80337a2 <SwitchClass+0x9a>
            if( deviceClass == CLASS_B )
 8033734:	2801      	cmp	r0, #1
 8033736:	d036      	beq.n	80337a6 <SwitchClass+0x9e>
            if( deviceClass == CLASS_C )
 8033738:	2802      	cmp	r0, #2
 803373a:	d1f9      	bne.n	8033730 <SwitchClass+0x28>
                MacCtx.RxWindowCConfig = MacCtx.RxWindow2Config;
 803373c:	f504 7c74 	add.w	ip, r4, #976	; 0x3d0
                Nvm.MacGroup2.DeviceClass = deviceClass;
 8033740:	f884 0608 	strb.w	r0, [r4, #1544]	; 0x608
                MacCtx.RxWindowCConfig = MacCtx.RxWindow2Config;
 8033744:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8033748:	f507 7779 	add.w	r7, r7, #996	; 0x3e4
 803374c:	c70f      	stmia	r7!, {r0, r1, r2, r3}
 803374e:	f8dc 3000 	ldr.w	r3, [ip]
 8033752:	603b      	str	r3, [r7, #0]
                    if( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.IsEnabled == true )
 8033754:	f894 35de 	ldrb.w	r3, [r4, #1502]	; 0x5de
                MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C;
 8033758:	f884 63f7 	strb.w	r6, [r4, #1015]	; 0x3f7
                    if( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.IsEnabled == true )
 803375c:	b1cb      	cbz	r3, 8033792 <SwitchClass+0x8a>
                        Nvm.MacGroup2.MacParams.RxCChannel.Frequency = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.RxParams.ClassC.Frequency;
 803375e:	f8d4 35f4 	ldr.w	r3, [r4, #1524]	; 0x5f4
 8033762:	f8c4 3578 	str.w	r3, [r4, #1400]	; 0x578
                        MacCtx.RxWindowCConfig.Frequency = Nvm.MacGroup2.MacParams.RxCChannel.Frequency;
 8033766:	f8c4 33e8 	str.w	r3, [r4, #1000]	; 0x3e8
                        MacCtx.RxWindowCConfig.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 803376a:	f894 3581 	ldrb.w	r3, [r4, #1409]	; 0x581
                        Nvm.MacGroup2.MacParams.RxCChannel.Datarate = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.RxParams.ClassC.Datarate;
 803376e:	f894 25f8 	ldrb.w	r2, [r4, #1528]	; 0x5f8
                        MacCtx.RxWindowCConfig.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 8033772:	f884 33f4 	strb.w	r3, [r4, #1012]	; 0x3f4
                        MacCtx.RxWindowCConfig.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport; /* ST_WORKAROUND: Keep repeater feature */
 8033776:	f894 358c 	ldrb.w	r3, [r4, #1420]	; 0x58c
                        Nvm.MacGroup2.MacParams.RxCChannel.Datarate = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.RxParams.ClassC.Datarate;
 803377a:	f884 257c 	strb.w	r2, [r4, #1404]	; 0x57c
                        MacCtx.RxWindowCConfig.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport; /* ST_WORKAROUND: Keep repeater feature */
 803377e:	f884 33f5 	strb.w	r3, [r4, #1013]	; 0x3f5
                        MacCtx.RxWindowCConfig.Channel = MacCtx.Channel;
 8033782:	f894 2419 	ldrb.w	r2, [r4, #1049]	; 0x419
 8033786:	f884 23e4 	strb.w	r2, [r4, #996]	; 0x3e4
                        MacCtx.RxWindowCConfig.RxContinuous = true;
 803378a:	f240 3301 	movw	r3, #769	; 0x301
 803378e:	f8a4 33f6 	strh.w	r3, [r4, #1014]	; 0x3f6
                MacCtx.NodeAckRequested = false;
 8033792:	2300      	movs	r3, #0
 8033794:	f884 3418 	strb.w	r3, [r4, #1048]	; 0x418
                Radio.Sleep( );
 8033798:	4b0c      	ldr	r3, [pc, #48]	; (80337cc <SwitchClass+0xc4>)
 803379a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 803379c:	4798      	blx	r3
                OpenContinuousRxCWindow( );
 803379e:	f7ff ff89 	bl	80336b4 <OpenContinuousRxCWindow>
}
 80337a2:	4628      	mov	r0, r5
 80337a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            status = LoRaMacClassBSwitchClass( deviceClass );
 80337a6:	f002 f8e3 	bl	8035970 <LoRaMacClassBSwitchClass>
            if( status == LORAMAC_STATUS_OK )
 80337aa:	4605      	mov	r5, r0
 80337ac:	2800      	cmp	r0, #0
 80337ae:	d1f8      	bne.n	80337a2 <SwitchClass+0x9a>
                Nvm.MacGroup2.DeviceClass = deviceClass;
 80337b0:	f887 6608 	strb.w	r6, [r7, #1544]	; 0x608
 80337b4:	e7f5      	b.n	80337a2 <SwitchClass+0x9a>
            if( deviceClass == CLASS_A )
 80337b6:	2800      	cmp	r0, #0
 80337b8:	d1ba      	bne.n	8033730 <SwitchClass+0x28>
                Radio.Sleep( );
 80337ba:	4b04      	ldr	r3, [pc, #16]	; (80337cc <SwitchClass+0xc4>)
                Nvm.MacGroup2.DeviceClass = deviceClass;
 80337bc:	f887 0608 	strb.w	r0, [r7, #1544]	; 0x608
                Radio.Sleep( );
 80337c0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80337c2:	4798      	blx	r3
                status = LORAMAC_STATUS_OK;
 80337c4:	4635      	mov	r5, r6
 80337c6:	e7ec      	b.n	80337a2 <SwitchClass+0x9a>
 80337c8:	20004aa4 	.word	0x20004aa4
 80337cc:	0803bbd8 	.word	0x0803bbd8

080337d0 <RxWindowSetup.constprop.0>:
static void RxWindowSetup( TimerEvent_t* rxTimer, RxConfigParams_t* rxConfig )
 80337d0:	b570      	push	{r4, r5, r6, lr}
    Radio.Standby( );
 80337d2:	4e0b      	ldr	r6, [pc, #44]	; (8033800 <RxWindowSetup.constprop.0+0x30>)
    if( RegionRxConfig( Nvm.MacGroup2.Region, rxConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )
 80337d4:	4c0b      	ldr	r4, [pc, #44]	; (8033804 <RxWindowSetup.constprop.0+0x34>)
static void RxWindowSetup( TimerEvent_t* rxTimer, RxConfigParams_t* rxConfig )
 80337d6:	460d      	mov	r5, r1
    TimerStop( rxTimer );
 80337d8:	f007 fd86 	bl	803b2e8 <UTIL_TIMER_Stop>
    Radio.Standby( );
 80337dc:	6b33      	ldr	r3, [r6, #48]	; 0x30
 80337de:	4798      	blx	r3
    if( RegionRxConfig( Nvm.MacGroup2.Region, rxConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )
 80337e0:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
 80337e4:	f204 4224 	addw	r2, r4, #1060	; 0x424
 80337e8:	4629      	mov	r1, r5
 80337ea:	f002 ffca 	bl	8036782 <RegionRxConfig>
 80337ee:	b130      	cbz	r0, 80337fe <RxWindowSetup.constprop.0+0x2e>
        Radio.Rx( Nvm.MacGroup2.MacParams.MaxRxWindow );
 80337f0:	6b73      	ldr	r3, [r6, #52]	; 0x34
 80337f2:	f8d4 0558 	ldr.w	r0, [r4, #1368]	; 0x558
 80337f6:	4798      	blx	r3
        MacCtx.RxSlot = rxConfig->RxSlot;
 80337f8:	7ceb      	ldrb	r3, [r5, #19]
 80337fa:	f884 3484 	strb.w	r3, [r4, #1156]	; 0x484
}
 80337fe:	bd70      	pop	{r4, r5, r6, pc}
 8033800:	0803bbd8 	.word	0x0803bbd8
 8033804:	20004aa4 	.word	0x20004aa4

08033808 <OnRxWindow1TimerEvent>:
    MacCtx.RxWindow1Config.Channel = MacCtx.Channel;
 8033808:	480c      	ldr	r0, [pc, #48]	; (803383c <OnRxWindow1TimerEvent+0x34>)
 803380a:	f890 3419 	ldrb.w	r3, [r0, #1049]	; 0x419
 803380e:	f880 33bc 	strb.w	r3, [r0, #956]	; 0x3bc
    MacCtx.RxWindow1Config.DrOffset = Nvm.MacGroup2.MacParams.Rx1DrOffset;
 8033812:	f890 356d 	ldrb.w	r3, [r0, #1389]	; 0x56d
 8033816:	f880 33bf 	strb.w	r3, [r0, #959]	; 0x3bf
    MacCtx.RxWindow1Config.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 803381a:	f890 3581 	ldrb.w	r3, [r0, #1409]	; 0x581
 803381e:	f880 33cc 	strb.w	r3, [r0, #972]	; 0x3cc
    MacCtx.RxWindow1Config.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport; /* ST_WORKAROUND: Keep repeater feature */
 8033822:	f890 358c 	ldrb.w	r3, [r0, #1420]	; 0x58c
 8033826:	f880 33cd 	strb.w	r3, [r0, #973]	; 0x3cd
    MacCtx.RxWindow1Config.RxContinuous = false;
 803382a:	2300      	movs	r3, #0
 803382c:	f8a0 33ce 	strh.w	r3, [r0, #974]	; 0x3ce
    RxWindowSetup( &MacCtx.RxWindowTimer1, &MacCtx.RxWindow1Config );
 8033830:	f500 716f 	add.w	r1, r0, #956	; 0x3bc
 8033834:	f500 7061 	add.w	r0, r0, #900	; 0x384
 8033838:	f7ff bfca 	b.w	80337d0 <RxWindowSetup.constprop.0>
 803383c:	20004aa4 	.word	0x20004aa4

08033840 <OnRxWindow2TimerEvent>:
    if( MacCtx.RxSlot == RX_SLOT_WIN_1 )
 8033840:	480f      	ldr	r0, [pc, #60]	; (8033880 <OnRxWindow2TimerEvent+0x40>)
 8033842:	f890 3484 	ldrb.w	r3, [r0, #1156]	; 0x484
 8033846:	b1cb      	cbz	r3, 803387c <OnRxWindow2TimerEvent+0x3c>
    MacCtx.RxWindow2Config.Channel = MacCtx.Channel;
 8033848:	f890 3419 	ldrb.w	r3, [r0, #1049]	; 0x419
 803384c:	f880 33d0 	strb.w	r3, [r0, #976]	; 0x3d0
    MacCtx.RxWindow2Config.Frequency = Nvm.MacGroup2.MacParams.Rx2Channel.Frequency;
 8033850:	f8d0 3570 	ldr.w	r3, [r0, #1392]	; 0x570
 8033854:	f8c0 33d4 	str.w	r3, [r0, #980]	; 0x3d4
    MacCtx.RxWindow2Config.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 8033858:	f890 3581 	ldrb.w	r3, [r0, #1409]	; 0x581
 803385c:	f880 33e0 	strb.w	r3, [r0, #992]	; 0x3e0
    MacCtx.RxWindow2Config.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport; /* ST_WORKAROUND: Keep repeater feature */
 8033860:	f890 358c 	ldrb.w	r3, [r0, #1420]	; 0x58c
 8033864:	f880 33e1 	strb.w	r3, [r0, #993]	; 0x3e1
    MacCtx.RxWindow2Config.RxContinuous = false;
 8033868:	f44f 7380 	mov.w	r3, #256	; 0x100
 803386c:	f8a0 33e2 	strh.w	r3, [r0, #994]	; 0x3e2
    RxWindowSetup( &MacCtx.RxWindowTimer2, &MacCtx.RxWindow2Config );
 8033870:	f500 7174 	add.w	r1, r0, #976	; 0x3d0
 8033874:	f500 7067 	add.w	r0, r0, #924	; 0x39c
 8033878:	f7ff bfaa 	b.w	80337d0 <RxWindowSetup.constprop.0>
}
 803387c:	4770      	bx	lr
 803387e:	bf00      	nop
 8033880:	20004aa4 	.word	0x20004aa4

08033884 <ProcessMacCommands.isra.0.constprop.0>:
static void ProcessMacCommands( uint8_t *payload, uint8_t macIndex, uint8_t commandsSize, int8_t snr, LoRaMacRxSlot_t rxSlot )
 8033884:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8033888:	b091      	sub	sp, #68	; 0x44
    uint8_t status = 0;
 803388a:	2700      	movs	r7, #0
                    if( ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_PING_SLOT ) && ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT ) )
 803388c:	4dc3      	ldr	r5, [pc, #780]	; (8033b9c <ProcessMacCommands.isra.0.constprop.0+0x318>)
    uint8_t status = 0;
 803388e:	f88d 7015 	strb.w	r7, [sp, #21]
static void ProcessMacCommands( uint8_t *payload, uint8_t macIndex, uint8_t commandsSize, int8_t snr, LoRaMacRxSlot_t rxSlot )
 8033892:	4606      	mov	r6, r0
 8033894:	4688      	mov	r8, r1
 8033896:	4693      	mov	fp, r2
    uint8_t macCmdPayload[2] = { 0x00, 0x00 };
 8033898:	f8ad 7018 	strh.w	r7, [sp, #24]
    while( macIndex < commandsSize )
 803389c:	46b9      	mov	r9, r7
 803389e:	45c1      	cmp	r9, r8
 80338a0:	d302      	bcc.n	80338a8 <ProcessMacCommands.isra.0.constprop.0+0x24>
}
 80338a2:	b011      	add	sp, #68	; 0x44
 80338a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if( ( LoRaMacCommandsGetCmdSize( payload[macIndex] ) + macIndex ) > commandsSize )
 80338a8:	f816 0009 	ldrb.w	r0, [r6, r9]
 80338ac:	f002 f96c 	bl	8035b88 <LoRaMacCommandsGetCmdSize>
 80338b0:	4448      	add	r0, r9
 80338b2:	4540      	cmp	r0, r8
 80338b4:	dcf5      	bgt.n	80338a2 <ProcessMacCommands.isra.0.constprop.0+0x1e>
        switch( payload[macIndex++] )
 80338b6:	f816 3009 	ldrb.w	r3, [r6, r9]
 80338ba:	f109 0401 	add.w	r4, r9, #1
 80338be:	3b02      	subs	r3, #2
 80338c0:	b2e4      	uxtb	r4, r4
 80338c2:	2b11      	cmp	r3, #17
 80338c4:	d8ed      	bhi.n	80338a2 <ProcessMacCommands.isra.0.constprop.0+0x1e>
 80338c6:	a201      	add	r2, pc, #4	; (adr r2, 80338cc <ProcessMacCommands.isra.0.constprop.0+0x48>)
 80338c8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80338cc:	08033915 	.word	0x08033915
 80338d0:	08033945 	.word	0x08033945
 80338d4:	08033a01 	.word	0x08033a01
 80338d8:	08033a29 	.word	0x08033a29
 80338dc:	08033ac1 	.word	0x08033ac1
 80338e0:	08033ae9 	.word	0x08033ae9
 80338e4:	08033b5b 	.word	0x08033b5b
 80338e8:	08033ba1 	.word	0x08033ba1
 80338ec:	08033c29 	.word	0x08033c29
 80338f0:	080338a3 	.word	0x080338a3
 80338f4:	080338a3 	.word	0x080338a3
 80338f8:	08033c87 	.word	0x08033c87
 80338fc:	080338a3 	.word	0x080338a3
 8033900:	080338a3 	.word	0x080338a3
 8033904:	08033d3d 	.word	0x08033d3d
 8033908:	08033d63 	.word	0x08033d63
 803390c:	08033da7 	.word	0x08033da7
 8033910:	08033de5 	.word	0x08033de5
                if( LoRaMacConfirmQueueIsCmdActive( MLME_LINK_CHECK ) == true )
 8033914:	2004      	movs	r0, #4
 8033916:	f002 f9e7 	bl	8035ce8 <LoRaMacConfirmQueueIsCmdActive>
 803391a:	b188      	cbz	r0, 8033940 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_LINK_CHECK );
 803391c:	2104      	movs	r1, #4
 803391e:	2000      	movs	r0, #0
 8033920:	f002 f9a6 	bl	8035c70 <LoRaMacConfirmQueueSetStatus>
                    MacCtx.MlmeConfirm.DemodMargin = payload[macIndex++];
 8033924:	5d33      	ldrb	r3, [r6, r4]
 8033926:	f885 3458 	strb.w	r3, [r5, #1112]	; 0x458
                    MacCtx.MlmeConfirm.NbGateways = payload[macIndex++];
 803392a:	f109 0403 	add.w	r4, r9, #3
                    MacCtx.MlmeConfirm.DemodMargin = payload[macIndex++];
 803392e:	f109 0902 	add.w	r9, r9, #2
                    MacCtx.MlmeConfirm.NbGateways = payload[macIndex++];
 8033932:	fa5f f989 	uxtb.w	r9, r9
 8033936:	b2e4      	uxtb	r4, r4
 8033938:	f816 3009 	ldrb.w	r3, [r6, r9]
 803393c:	f885 3459 	strb.w	r3, [r5, #1113]	; 0x459
                uint8_t eirpDwellTime = payload[macIndex++];
 8033940:	46a1      	mov	r9, r4
 8033942:	e7ac      	b.n	803389e <ProcessMacCommands.isra.0.constprop.0+0x1a>
                int8_t linkAdrDatarate = DR_0;
 8033944:	2300      	movs	r3, #0
 8033946:	f88d 3016 	strb.w	r3, [sp, #22]
                int8_t linkAdrTxPower = TX_POWER_0;
 803394a:	f88d 3017 	strb.w	r3, [sp, #23]
                uint8_t linkAdrNbRep = 0;
 803394e:	f88d 301c 	strb.w	r3, [sp, #28]
                uint8_t linkAdrNbBytesParsed = 0;
 8033952:	f88d 3020 	strb.w	r3, [sp, #32]
                if( adrBlockFound == false )
 8033956:	2f00      	cmp	r7, #0
 8033958:	d150      	bne.n	80339fc <ProcessMacCommands.isra.0.constprop.0+0x178>
                    linkAdrReq.PayloadSize = commandsSize - ( macIndex - 1 );
 803395a:	eba8 0309 	sub.w	r3, r8, r9
 803395e:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
                    linkAdrReq.AdrEnabled = Nvm.MacGroup2.AdrCtrlOn;
 8033962:	f895 360a 	ldrb.w	r3, [r5, #1546]	; 0x60a
 8033966:	f88d 303a 	strb.w	r3, [sp, #58]	; 0x3a
                    linkAdrReq.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 803396a:	f895 3580 	ldrb.w	r3, [r5, #1408]	; 0x580
 803396e:	f88d 3039 	strb.w	r3, [sp, #57]	; 0x39
                    linkAdrReq.CurrentDatarate = Nvm.MacGroup1.ChannelsDatarate;
 8033972:	f895 3545 	ldrb.w	r3, [r5, #1349]	; 0x545
 8033976:	f88d 303b 	strb.w	r3, [sp, #59]	; 0x3b
                    linkAdrReq.CurrentTxPower = Nvm.MacGroup1.ChannelsTxPower;
 803397a:	f895 3544 	ldrb.w	r3, [r5, #1348]	; 0x544
 803397e:	f88d 303c 	strb.w	r3, [sp, #60]	; 0x3c
                    linkAdrReq.CurrentNbRep = Nvm.MacGroup2.MacParams.ChannelsNbTrans;
 8033982:	f895 356c 	ldrb.w	r3, [r5, #1388]	; 0x56c
 8033986:	f88d 303d 	strb.w	r3, [sp, #61]	; 0x3d
                    linkAdrReq.Version = Nvm.MacGroup2.Version;
 803398a:	f8d5 3618 	ldr.w	r3, [r5, #1560]	; 0x618
 803398e:	930c      	str	r3, [sp, #48]	; 0x30
                    status = RegionLinkAdrReq( Nvm.MacGroup2.Region, &linkAdrReq, &linkAdrDatarate,
 8033990:	ab08      	add	r3, sp, #32
 8033992:	9301      	str	r3, [sp, #4]
                    linkAdrReq.Payload = &payload[macIndex - 1];
 8033994:	3c01      	subs	r4, #1
                    status = RegionLinkAdrReq( Nvm.MacGroup2.Region, &linkAdrReq, &linkAdrDatarate,
 8033996:	ab07      	add	r3, sp, #28
 8033998:	9300      	str	r3, [sp, #0]
 803399a:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
                    linkAdrReq.Payload = &payload[macIndex - 1];
 803399e:	4434      	add	r4, r6
                    status = RegionLinkAdrReq( Nvm.MacGroup2.Region, &linkAdrReq, &linkAdrDatarate,
 80339a0:	f10d 0317 	add.w	r3, sp, #23
 80339a4:	f10d 0216 	add.w	r2, sp, #22
 80339a8:	a90c      	add	r1, sp, #48	; 0x30
                    linkAdrReq.Payload = &payload[macIndex - 1];
 80339aa:	940d      	str	r4, [sp, #52]	; 0x34
                    status = RegionLinkAdrReq( Nvm.MacGroup2.Region, &linkAdrReq, &linkAdrDatarate,
 80339ac:	f002 ff08 	bl	80367c0 <RegionLinkAdrReq>
 80339b0:	f88d 0015 	strb.w	r0, [sp, #21]
                    if( ( status & 0x07 ) == 0x07 )
 80339b4:	f000 0007 	and.w	r0, r0, #7
 80339b8:	2807      	cmp	r0, #7
 80339ba:	d10b      	bne.n	80339d4 <ProcessMacCommands.isra.0.constprop.0+0x150>
                        Nvm.MacGroup1.ChannelsDatarate = linkAdrDatarate;
 80339bc:	f89d 3016 	ldrb.w	r3, [sp, #22]
 80339c0:	f885 3545 	strb.w	r3, [r5, #1349]	; 0x545
                        Nvm.MacGroup1.ChannelsTxPower = linkAdrTxPower;
 80339c4:	f89d 3017 	ldrb.w	r3, [sp, #23]
 80339c8:	f885 3544 	strb.w	r3, [r5, #1348]	; 0x544
                        Nvm.MacGroup2.MacParams.ChannelsNbTrans = linkAdrNbRep;
 80339cc:	f89d 301c 	ldrb.w	r3, [sp, #28]
 80339d0:	f885 356c 	strb.w	r3, [r5, #1388]	; 0x56c
static void ProcessMacCommands( uint8_t *payload, uint8_t macIndex, uint8_t commandsSize, int8_t snr, LoRaMacRxSlot_t rxSlot )
 80339d4:	2700      	movs	r7, #0
                    for( uint8_t i = 0; i < ( linkAdrNbBytesParsed / 5 ); i++ )
 80339d6:	f04f 0a05 	mov.w	sl, #5
 80339da:	e006      	b.n	80339ea <ProcessMacCommands.isra.0.constprop.0+0x166>
                        LoRaMacCommandsAddCmd( MOTE_MAC_LINK_ADR_ANS, &status, 1 );
 80339dc:	2201      	movs	r2, #1
 80339de:	f10d 0115 	add.w	r1, sp, #21
 80339e2:	2003      	movs	r0, #3
 80339e4:	f001 ffe4 	bl	80359b0 <LoRaMacCommandsAddCmd>
                    for( uint8_t i = 0; i < ( linkAdrNbBytesParsed / 5 ); i++ )
 80339e8:	3701      	adds	r7, #1
 80339ea:	b2fb      	uxtb	r3, r7
 80339ec:	f89d 4020 	ldrb.w	r4, [sp, #32]
 80339f0:	fbb4 f2fa 	udiv	r2, r4, sl
 80339f4:	429a      	cmp	r2, r3
 80339f6:	d8f1      	bhi.n	80339dc <ProcessMacCommands.isra.0.constprop.0+0x158>
                    macIndex += linkAdrNbBytesParsed - 1;
 80339f8:	444c      	add	r4, r9
 80339fa:	b2e4      	uxtb	r4, r4
                break;
 80339fc:	2701      	movs	r7, #1
 80339fe:	e79f      	b.n	8033940 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                Nvm.MacGroup2.MaxDCycle = payload[macIndex++] & 0x0F;
 8033a00:	5d33      	ldrb	r3, [r6, r4]
                Nvm.MacGroup2.AggregatedDCycle = 1 << Nvm.MacGroup2.MaxDCycle;
 8033a02:	2201      	movs	r2, #1
                Nvm.MacGroup2.MaxDCycle = payload[macIndex++] & 0x0F;
 8033a04:	f003 030f 	and.w	r3, r3, #15
 8033a08:	f109 0902 	add.w	r9, r9, #2
 8033a0c:	f885 360b 	strb.w	r3, [r5, #1547]	; 0x60b
                Nvm.MacGroup2.AggregatedDCycle = 1 << Nvm.MacGroup2.MaxDCycle;
 8033a10:	fa02 f303 	lsl.w	r3, r2, r3
                Nvm.MacGroup2.MaxDCycle = payload[macIndex++] & 0x0F;
 8033a14:	fa5f f989 	uxtb.w	r9, r9
                Nvm.MacGroup2.AggregatedDCycle = 1 << Nvm.MacGroup2.MaxDCycle;
 8033a18:	f8a5 360e 	strh.w	r3, [r5, #1550]	; 0x60e
                LoRaMacCommandsAddCmd( MOTE_MAC_DUTY_CYCLE_ANS, macCmdPayload, 0 );
 8033a1c:	2200      	movs	r2, #0
 8033a1e:	a906      	add	r1, sp, #24
 8033a20:	2004      	movs	r0, #4
                    LoRaMacCommandsAddCmd( MOTE_MAC_TX_PARAM_SETUP_ANS, macCmdPayload, 0 );
 8033a22:	f001 ffc5 	bl	80359b0 <LoRaMacCommandsAddCmd>
                break;
 8033a26:	e0b7      	b.n	8033b98 <ProcessMacCommands.isra.0.constprop.0+0x314>
                status = 0x07;
 8033a28:	2307      	movs	r3, #7
 8033a2a:	f88d 3015 	strb.w	r3, [sp, #21]
                rxParamSetupReq.DrOffset = ( payload[macIndex] >> 4 ) & 0x07;
 8033a2e:	5d33      	ldrb	r3, [r6, r4]
                status = RegionRxParamSetupReq( Nvm.MacGroup2.Region, &rxParamSetupReq );
 8033a30:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
                rxParamSetupReq.DrOffset = ( payload[macIndex] >> 4 ) & 0x07;
 8033a34:	f3c3 1202 	ubfx	r2, r3, #4, #3
                rxParamSetupReq.Datarate = payload[macIndex] & 0x0F;
 8033a38:	f003 030f 	and.w	r3, r3, #15
                rxParamSetupReq.DrOffset = ( payload[macIndex] >> 4 ) & 0x07;
 8033a3c:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
                rxParamSetupReq.Datarate = payload[macIndex] & 0x0F;
 8033a40:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033a44:	f109 0204 	add.w	r2, r9, #4
                rxParamSetupReq.Frequency = ( uint32_t ) payload[macIndex++];
 8033a48:	f109 0303 	add.w	r3, r9, #3
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033a4c:	b2db      	uxtb	r3, r3
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033a4e:	b2d2      	uxtb	r2, r2
 8033a50:	f109 0405 	add.w	r4, r9, #5
                macIndex++;
 8033a54:	f109 0902 	add.w	r9, r9, #2
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033a58:	5cf1      	ldrb	r1, [r6, r3]
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033a5a:	5cb3      	ldrb	r3, [r6, r2]
                rxParamSetupReq.Frequency = ( uint32_t ) payload[macIndex++];
 8033a5c:	fa5f f989 	uxtb.w	r9, r9
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033a60:	041b      	lsls	r3, r3, #16
                rxParamSetupReq.Frequency = ( uint32_t ) payload[macIndex++];
 8033a62:	f816 2009 	ldrb.w	r2, [r6, r9]
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033a66:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8033a6a:	4313      	orrs	r3, r2
                rxParamSetupReq.Frequency *= 100;
 8033a6c:	2264      	movs	r2, #100	; 0x64
 8033a6e:	4353      	muls	r3, r2
                status = RegionRxParamSetupReq( Nvm.MacGroup2.Region, &rxParamSetupReq );
 8033a70:	a90c      	add	r1, sp, #48	; 0x30
                rxParamSetupReq.Frequency *= 100;
 8033a72:	930d      	str	r3, [sp, #52]	; 0x34
                status = RegionRxParamSetupReq( Nvm.MacGroup2.Region, &rxParamSetupReq );
 8033a74:	f002 feba 	bl	80367ec <RegionRxParamSetupReq>
                if( ( status & 0x07 ) == 0x07 )
 8033a78:	f000 0307 	and.w	r3, r0, #7
 8033a7c:	2b07      	cmp	r3, #7
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033a7e:	b2e4      	uxtb	r4, r4
                status = RegionRxParamSetupReq( Nvm.MacGroup2.Region, &rxParamSetupReq );
 8033a80:	f88d 0015 	strb.w	r0, [sp, #21]
                if( ( status & 0x07 ) == 0x07 )
 8033a84:	d10e      	bne.n	8033aa4 <ProcessMacCommands.isra.0.constprop.0+0x220>
                    Nvm.MacGroup2.MacParams.Rx2Channel.Datarate = rxParamSetupReq.Datarate;
 8033a86:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
 8033a8a:	f885 3574 	strb.w	r3, [r5, #1396]	; 0x574
                    Nvm.MacGroup2.MacParams.RxCChannel.Datarate = rxParamSetupReq.Datarate;
 8033a8e:	f885 357c 	strb.w	r3, [r5, #1404]	; 0x57c
                    Nvm.MacGroup2.MacParams.Rx2Channel.Frequency = rxParamSetupReq.Frequency;
 8033a92:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8033a94:	f8c5 3570 	str.w	r3, [r5, #1392]	; 0x570
                    Nvm.MacGroup2.MacParams.RxCChannel.Frequency = rxParamSetupReq.Frequency;
 8033a98:	f8c5 3578 	str.w	r3, [r5, #1400]	; 0x578
                    Nvm.MacGroup2.MacParams.Rx1DrOffset = rxParamSetupReq.DrOffset;
 8033a9c:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
 8033aa0:	f885 356d 	strb.w	r3, [r5, #1389]	; 0x56d
                macCmdPayload[0] = status;
 8033aa4:	f88d 0018 	strb.w	r0, [sp, #24]
                LoRaMacCommandsAddCmd( MOTE_MAC_RX_PARAM_SETUP_ANS, macCmdPayload, 1 );
 8033aa8:	2201      	movs	r2, #1
 8033aaa:	a906      	add	r1, sp, #24
 8033aac:	2005      	movs	r0, #5
                    LoRaMacCommandsAddCmd( MOTE_MAC_DL_CHANNEL_ANS, macCmdPayload, 1 );
 8033aae:	f001 ff7f 	bl	80359b0 <LoRaMacCommandsAddCmd>
    MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 1;
 8033ab2:	f895 3485 	ldrb.w	r3, [r5, #1157]	; 0x485
 8033ab6:	f043 0310 	orr.w	r3, r3, #16
 8033aba:	f885 3485 	strb.w	r3, [r5, #1157]	; 0x485
}
 8033abe:	e73f      	b.n	8033940 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->GetBatteryLevel != NULL ) )
 8033ac0:	f8d5 334c 	ldr.w	r3, [r5, #844]	; 0x34c
 8033ac4:	b173      	cbz	r3, 8033ae4 <ProcessMacCommands.isra.0.constprop.0+0x260>
 8033ac6:	681b      	ldr	r3, [r3, #0]
 8033ac8:	b163      	cbz	r3, 8033ae4 <ProcessMacCommands.isra.0.constprop.0+0x260>
                    batteryLevel = MacCtx.MacCallbacks->GetBatteryLevel( );
 8033aca:	4798      	blx	r3
                macCmdPayload[1] = ( uint8_t )( snr & 0x3F );
 8033acc:	f00b 033f 	and.w	r3, fp, #63	; 0x3f
                macCmdPayload[0] = batteryLevel;
 8033ad0:	f88d 0018 	strb.w	r0, [sp, #24]
                macCmdPayload[1] = ( uint8_t )( snr & 0x3F );
 8033ad4:	f88d 3019 	strb.w	r3, [sp, #25]
                LoRaMacCommandsAddCmd( MOTE_MAC_DEV_STATUS_ANS, macCmdPayload, 2 );
 8033ad8:	2202      	movs	r2, #2
 8033ada:	a906      	add	r1, sp, #24
 8033adc:	2006      	movs	r0, #6
                    LoRaMacCommandsAddCmd( MOTE_MAC_BEACON_FREQ_ANS, macCmdPayload, 1 );
 8033ade:	f001 ff67 	bl	80359b0 <LoRaMacCommandsAddCmd>
                break;
 8033ae2:	e72d      	b.n	8033940 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                uint8_t batteryLevel = BAT_LEVEL_NO_MEASURE;
 8033ae4:	20ff      	movs	r0, #255	; 0xff
 8033ae6:	e7f1      	b.n	8033acc <ProcessMacCommands.isra.0.constprop.0+0x248>
                status = 0x03;
 8033ae8:	2303      	movs	r3, #3
 8033aea:	f88d 3015 	strb.w	r3, [sp, #21]
                newChannelReq.ChannelId = payload[macIndex++];
 8033aee:	5d33      	ldrb	r3, [r6, r4]
 8033af0:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
                newChannelReq.NewChannel = &chParam;
 8033af4:	ab0c      	add	r3, sp, #48	; 0x30
 8033af6:	9308      	str	r3, [sp, #32]
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033af8:	f109 0204 	add.w	r2, r9, #4
                chParam.Frequency = ( uint32_t ) payload[macIndex++];
 8033afc:	f109 0303 	add.w	r3, r9, #3
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033b00:	b2db      	uxtb	r3, r3
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033b02:	b2d2      	uxtb	r2, r2
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033b04:	5cf1      	ldrb	r1, [r6, r3]
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033b06:	5cb3      	ldrb	r3, [r6, r2]
                status = ( uint8_t )RegionNewChannelReq( Nvm.MacGroup2.Region, &newChannelReq );
 8033b08:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
                newChannelReq.ChannelId = payload[macIndex++];
 8033b0c:	f109 0202 	add.w	r2, r9, #2
                chParam.Frequency = ( uint32_t ) payload[macIndex++];
 8033b10:	b2d2      	uxtb	r2, r2
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033b12:	041b      	lsls	r3, r3, #16
                chParam.Frequency = ( uint32_t ) payload[macIndex++];
 8033b14:	5cb2      	ldrb	r2, [r6, r2]
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033b16:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8033b1a:	4313      	orrs	r3, r2
                chParam.DrRange.Value = payload[macIndex++];
 8033b1c:	f109 0406 	add.w	r4, r9, #6
                chParam.Frequency *= 100;
 8033b20:	2264      	movs	r2, #100	; 0x64
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033b22:	f109 0905 	add.w	r9, r9, #5
                chParam.Frequency *= 100;
 8033b26:	4353      	muls	r3, r2
                chParam.DrRange.Value = payload[macIndex++];
 8033b28:	fa5f f989 	uxtb.w	r9, r9
                chParam.Frequency *= 100;
 8033b2c:	930c      	str	r3, [sp, #48]	; 0x30
                chParam.Rx1Frequency = 0;
 8033b2e:	2300      	movs	r3, #0
 8033b30:	930d      	str	r3, [sp, #52]	; 0x34
                status = ( uint8_t )RegionNewChannelReq( Nvm.MacGroup2.Region, &newChannelReq );
 8033b32:	a908      	add	r1, sp, #32
                chParam.DrRange.Value = payload[macIndex++];
 8033b34:	f816 3009 	ldrb.w	r3, [r6, r9]
 8033b38:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
                status = ( uint8_t )RegionNewChannelReq( Nvm.MacGroup2.Region, &newChannelReq );
 8033b3c:	f002 fe62 	bl	8036804 <RegionNewChannelReq>
 8033b40:	b2c3      	uxtb	r3, r0
                if( ( int8_t )status >= 0 )
 8033b42:	2800      	cmp	r0, #0
                chParam.DrRange.Value = payload[macIndex++];
 8033b44:	b2e4      	uxtb	r4, r4
                status = ( uint8_t )RegionNewChannelReq( Nvm.MacGroup2.Region, &newChannelReq );
 8033b46:	f88d 3015 	strb.w	r3, [sp, #21]
                if( ( int8_t )status >= 0 )
 8033b4a:	f6ff aef9 	blt.w	8033940 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                    macCmdPayload[0] = status;
 8033b4e:	f88d 3018 	strb.w	r3, [sp, #24]
                    LoRaMacCommandsAddCmd( MOTE_MAC_NEW_CHANNEL_ANS, macCmdPayload, 1 );
 8033b52:	2201      	movs	r2, #1
 8033b54:	a906      	add	r1, sp, #24
 8033b56:	2007      	movs	r0, #7
 8033b58:	e7c1      	b.n	8033ade <ProcessMacCommands.isra.0.constprop.0+0x25a>
                uint8_t delay = payload[macIndex++] & 0x0F;
 8033b5a:	5d33      	ldrb	r3, [r6, r4]
 8033b5c:	f003 030f 	and.w	r3, r3, #15
                Nvm.MacGroup2.MacParams.ReceiveDelay1 = delay * 1000;
 8033b60:	2b01      	cmp	r3, #1
 8033b62:	bf38      	it	cc
 8033b64:	2301      	movcc	r3, #1
 8033b66:	461a      	mov	r2, r3
 8033b68:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8033b6c:	4353      	muls	r3, r2
 8033b6e:	f8c5 355c 	str.w	r3, [r5, #1372]	; 0x55c
                LoRaMacCommandsAddCmd( MOTE_MAC_RX_TIMING_SETUP_ANS, macCmdPayload, 0 );
 8033b72:	2200      	movs	r2, #0
                Nvm.MacGroup2.MacParams.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay1 + 1000;
 8033b74:	f503 737a 	add.w	r3, r3, #1000	; 0x3e8
                LoRaMacCommandsAddCmd( MOTE_MAC_RX_TIMING_SETUP_ANS, macCmdPayload, 0 );
 8033b78:	a906      	add	r1, sp, #24
 8033b7a:	2008      	movs	r0, #8
                Nvm.MacGroup2.MacParams.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay1 + 1000;
 8033b7c:	f8c5 3560 	str.w	r3, [r5, #1376]	; 0x560
                LoRaMacCommandsAddCmd( MOTE_MAC_RX_TIMING_SETUP_ANS, macCmdPayload, 0 );
 8033b80:	f001 ff16 	bl	80359b0 <LoRaMacCommandsAddCmd>
    MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 1;
 8033b84:	f895 3485 	ldrb.w	r3, [r5, #1157]	; 0x485
                uint8_t delay = payload[macIndex++] & 0x0F;
 8033b88:	f109 0902 	add.w	r9, r9, #2
    MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 1;
 8033b8c:	f043 0310 	orr.w	r3, r3, #16
                uint8_t delay = payload[macIndex++] & 0x0F;
 8033b90:	fa5f f989 	uxtb.w	r9, r9
    MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 1;
 8033b94:	f885 3485 	strb.w	r3, [r5, #1157]	; 0x485
                uint8_t delay = payload[macIndex++] & 0x0F;
 8033b98:	464c      	mov	r4, r9
}
 8033b9a:	e6d1      	b.n	8033940 <ProcessMacCommands.isra.0.constprop.0+0xbc>
 8033b9c:	20004aa4 	.word	0x20004aa4
                uint8_t eirpDwellTime = payload[macIndex++];
 8033ba0:	5d33      	ldrb	r3, [r6, r4]
                if( RegionTxParamSetupReq( Nvm.MacGroup2.Region, &txParamSetupReq ) != -1 )
 8033ba2:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
                txParamSetupReq.UplinkDwellTime = 0;
 8033ba6:	2200      	movs	r2, #0
 8033ba8:	f88d 201c 	strb.w	r2, [sp, #28]
                if( ( eirpDwellTime & 0x20 ) == 0x20 )
 8033bac:	f013 0220 	ands.w	r2, r3, #32
                    txParamSetupReq.DownlinkDwellTime = 1;
 8033bb0:	bf18      	it	ne
 8033bb2:	2201      	movne	r2, #1
 8033bb4:	f88d 201d 	strb.w	r2, [sp, #29]
                if( ( eirpDwellTime & 0x10 ) == 0x10 )
 8033bb8:	06da      	lsls	r2, r3, #27
                    txParamSetupReq.UplinkDwellTime = 1;
 8033bba:	bf48      	it	mi
 8033bbc:	2201      	movmi	r2, #1
                txParamSetupReq.MaxEirp = eirpDwellTime & 0x0F;
 8033bbe:	f003 030f 	and.w	r3, r3, #15
                if( RegionTxParamSetupReq( Nvm.MacGroup2.Region, &txParamSetupReq ) != -1 )
 8033bc2:	a907      	add	r1, sp, #28
                    txParamSetupReq.UplinkDwellTime = 1;
 8033bc4:	bf48      	it	mi
 8033bc6:	f88d 201c 	strbmi.w	r2, [sp, #28]
                txParamSetupReq.MaxEirp = eirpDwellTime & 0x0F;
 8033bca:	f88d 301e 	strb.w	r3, [sp, #30]
                if( RegionTxParamSetupReq( Nvm.MacGroup2.Region, &txParamSetupReq ) != -1 )
 8033bce:	f002 fe25 	bl	803681c <RegionTxParamSetupReq>
                uint8_t eirpDwellTime = payload[macIndex++];
 8033bd2:	f109 0902 	add.w	r9, r9, #2
                if( RegionTxParamSetupReq( Nvm.MacGroup2.Region, &txParamSetupReq ) != -1 )
 8033bd6:	3001      	adds	r0, #1
                uint8_t eirpDwellTime = payload[macIndex++];
 8033bd8:	fa5f f989 	uxtb.w	r9, r9
                if( RegionTxParamSetupReq( Nvm.MacGroup2.Region, &txParamSetupReq ) != -1 )
 8033bdc:	d0dc      	beq.n	8033b98 <ProcessMacCommands.isra.0.constprop.0+0x314>
                    Nvm.MacGroup2.MacParams.UplinkDwellTime = txParamSetupReq.UplinkDwellTime;
 8033bde:	f8bd 301c 	ldrh.w	r3, [sp, #28]
                    Nvm.MacGroup2.MacParams.MaxEirp = LoRaMacMaxEirpTable[txParamSetupReq.MaxEirp];
 8033be2:	4a8e      	ldr	r2, [pc, #568]	; (8033e1c <ProcessMacCommands.isra.0.constprop.0+0x598>)
                    Nvm.MacGroup2.MacParams.UplinkDwellTime = txParamSetupReq.UplinkDwellTime;
 8033be4:	f8a5 3580 	strh.w	r3, [r5, #1408]	; 0x580
                    Nvm.MacGroup2.MacParams.MaxEirp = LoRaMacMaxEirpTable[txParamSetupReq.MaxEirp];
 8033be8:	f89d 301e 	ldrb.w	r3, [sp, #30]
                    Nvm.MacGroup2.MacParams.UplinkDwellTime = txParamSetupReq.UplinkDwellTime;
 8033bec:	f89d 401c 	ldrb.w	r4, [sp, #28]
                    Nvm.MacGroup2.MacParams.MaxEirp = LoRaMacMaxEirpTable[txParamSetupReq.MaxEirp];
 8033bf0:	5cd0      	ldrb	r0, [r2, r3]
 8033bf2:	f7f7 ff4f 	bl	802ba94 <__aeabi_ui2f>
                    getPhy.Attribute = PHY_MIN_TX_DR;
 8033bf6:	2302      	movs	r3, #2
                    Nvm.MacGroup2.MacParams.MaxEirp = LoRaMacMaxEirpTable[txParamSetupReq.MaxEirp];
 8033bf8:	f8c5 0584 	str.w	r0, [r5, #1412]	; 0x584
                    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8033bfc:	a90c      	add	r1, sp, #48	; 0x30
 8033bfe:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
                    getPhy.Attribute = PHY_MIN_TX_DR;
 8033c02:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
                    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8033c06:	f88d 4032 	strb.w	r4, [sp, #50]	; 0x32
                    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8033c0a:	f002 fd5e 	bl	80366ca <RegionGetPhyParam>
                    Nvm.MacGroup1.ChannelsDatarate = MAX( Nvm.MacGroup1.ChannelsDatarate, ( int8_t )phyParam.Value );
 8033c0e:	f995 3545 	ldrsb.w	r3, [r5, #1349]	; 0x545
                    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8033c12:	9008      	str	r0, [sp, #32]
                    Nvm.MacGroup1.ChannelsDatarate = MAX( Nvm.MacGroup1.ChannelsDatarate, ( int8_t )phyParam.Value );
 8033c14:	b240      	sxtb	r0, r0
 8033c16:	4298      	cmp	r0, r3
 8033c18:	bfb8      	it	lt
 8033c1a:	4618      	movlt	r0, r3
 8033c1c:	f885 0545 	strb.w	r0, [r5, #1349]	; 0x545
                    LoRaMacCommandsAddCmd( MOTE_MAC_TX_PARAM_SETUP_ANS, macCmdPayload, 0 );
 8033c20:	2200      	movs	r2, #0
 8033c22:	a906      	add	r1, sp, #24
 8033c24:	2009      	movs	r0, #9
 8033c26:	e6fc      	b.n	8033a22 <ProcessMacCommands.isra.0.constprop.0+0x19e>
                status = 0x03;
 8033c28:	2303      	movs	r3, #3
 8033c2a:	f88d 3015 	strb.w	r3, [sp, #21]
                dlChannelReq.ChannelId = payload[macIndex++];
 8033c2e:	5d33      	ldrb	r3, [r6, r4]
 8033c30:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033c34:	f109 0204 	add.w	r2, r9, #4
                dlChannelReq.Rx1Frequency = ( uint32_t ) payload[macIndex++];
 8033c38:	f109 0303 	add.w	r3, r9, #3
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033c3c:	b2db      	uxtb	r3, r3
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033c3e:	b2d2      	uxtb	r2, r2
 8033c40:	f109 0405 	add.w	r4, r9, #5
                dlChannelReq.ChannelId = payload[macIndex++];
 8033c44:	f109 0902 	add.w	r9, r9, #2
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8033c48:	5cf1      	ldrb	r1, [r6, r3]
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033c4a:	5cb3      	ldrb	r3, [r6, r2]
                status = ( uint8_t )RegionDlChannelReq( Nvm.MacGroup2.Region, &dlChannelReq );
 8033c4c:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
                dlChannelReq.Rx1Frequency = ( uint32_t ) payload[macIndex++];
 8033c50:	fa5f f989 	uxtb.w	r9, r9
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033c54:	041b      	lsls	r3, r3, #16
                dlChannelReq.Rx1Frequency = ( uint32_t ) payload[macIndex++];
 8033c56:	f816 2009 	ldrb.w	r2, [r6, r9]
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033c5a:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8033c5e:	4313      	orrs	r3, r2
                dlChannelReq.Rx1Frequency *= 100;
 8033c60:	2264      	movs	r2, #100	; 0x64
 8033c62:	4353      	muls	r3, r2
                status = ( uint8_t )RegionDlChannelReq( Nvm.MacGroup2.Region, &dlChannelReq );
 8033c64:	a90c      	add	r1, sp, #48	; 0x30
                dlChannelReq.Rx1Frequency *= 100;
 8033c66:	930d      	str	r3, [sp, #52]	; 0x34
                status = ( uint8_t )RegionDlChannelReq( Nvm.MacGroup2.Region, &dlChannelReq );
 8033c68:	f002 fde4 	bl	8036834 <RegionDlChannelReq>
 8033c6c:	b2c3      	uxtb	r3, r0
                if( ( int8_t )status >= 0 )
 8033c6e:	2800      	cmp	r0, #0
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8033c70:	b2e4      	uxtb	r4, r4
                status = ( uint8_t )RegionDlChannelReq( Nvm.MacGroup2.Region, &dlChannelReq );
 8033c72:	f88d 3015 	strb.w	r3, [sp, #21]
                if( ( int8_t )status >= 0 )
 8033c76:	f6ff ae63 	blt.w	8033940 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                    macCmdPayload[0] = status;
 8033c7a:	f88d 3018 	strb.w	r3, [sp, #24]
                    LoRaMacCommandsAddCmd( MOTE_MAC_DL_CHANNEL_ANS, macCmdPayload, 1 );
 8033c7e:	2201      	movs	r2, #1
 8033c80:	a906      	add	r1, sp, #24
 8033c82:	200a      	movs	r0, #10
 8033c84:	e713      	b.n	8033aae <ProcessMacCommands.isra.0.constprop.0+0x22a>
                if( LoRaMacConfirmQueueIsCmdActive( MLME_DEVICE_TIME ) == true )
 8033c86:	200a      	movs	r0, #10
 8033c88:	f002 f82e 	bl	8035ce8 <LoRaMacConfirmQueueIsCmdActive>
 8033c8c:	2800      	cmp	r0, #0
 8033c8e:	f43f ae57 	beq.w	8033940 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_DEVICE_TIME );
 8033c92:	210a      	movs	r1, #10
 8033c94:	2000      	movs	r0, #0
 8033c96:	f001 ffeb 	bl	8035c70 <LoRaMacConfirmQueueSetStatus>
                    SysTime_t sysTime = { 0 };
 8033c9a:	2300      	movs	r3, #0
 8033c9c:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 8;
 8033ca0:	f109 0203 	add.w	r2, r9, #3
                    gpsEpochTime.Seconds = ( uint32_t )payload[macIndex++];
 8033ca4:	f109 0302 	add.w	r3, r9, #2
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 8;
 8033ca8:	b2db      	uxtb	r3, r3
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 16;
 8033caa:	b2d2      	uxtb	r2, r2
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 8;
 8033cac:	5cf1      	ldrb	r1, [r6, r3]
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 16;
 8033cae:	5cb3      	ldrb	r3, [r6, r2]
                    gpsEpochTime.Seconds = ( uint32_t )payload[macIndex++];
 8033cb0:	5d32      	ldrb	r2, [r6, r4]
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 16;
 8033cb2:	041b      	lsls	r3, r3, #16
 8033cb4:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8033cb8:	4313      	orrs	r3, r2
 8033cba:	f109 0204 	add.w	r2, r9, #4
                    gpsEpochTime.SubSeconds = payload[macIndex++];
 8033cbe:	f109 0406 	add.w	r4, r9, #6
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 24;
 8033cc2:	b2d2      	uxtb	r2, r2
 8033cc4:	f109 0905 	add.w	r9, r9, #5
                    gpsEpochTime.SubSeconds = payload[macIndex++];
 8033cc8:	fa5f f989 	uxtb.w	r9, r9
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 24;
 8033ccc:	5cb2      	ldrb	r2, [r6, r2]
                    gpsEpochTime.SubSeconds = ( int16_t )( ( ( int32_t )gpsEpochTime.SubSeconds * 1000 ) >> 8 );
 8033cce:	f816 1009 	ldrb.w	r1, [r6, r9]
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 24;
 8033cd2:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
                    gpsEpochTime.SubSeconds = ( int16_t )( ( ( int32_t )gpsEpochTime.SubSeconds * 1000 ) >> 8 );
 8033cd6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8033cda:	434a      	muls	r2, r1
                    sysTimeCurrent = SysTimeGet( );
 8033cdc:	f10d 0a30 	add.w	sl, sp, #48	; 0x30
                    gpsEpochTime.SubSeconds = ( int16_t )( ( ( int32_t )gpsEpochTime.SubSeconds * 1000 ) >> 8 );
 8033ce0:	1212      	asrs	r2, r2, #8
                    sysTimeCurrent = SysTimeGet( );
 8033ce2:	4650      	mov	r0, sl
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 24;
 8033ce4:	9303      	str	r3, [sp, #12]
                    gpsEpochTime.SubSeconds = ( int16_t )( ( ( int32_t )gpsEpochTime.SubSeconds * 1000 ) >> 8 );
 8033ce6:	f8ad 2024 	strh.w	r2, [sp, #36]	; 0x24
                    sysTimeCurrent = SysTimeGet( );
 8033cea:	f007 fa0f 	bl	803b10c <SysTimeGet>
                    sysTime.Seconds += UNIX_GPS_EPOCH_OFFSET;
 8033cee:	9b03      	ldr	r3, [sp, #12]
 8033cf0:	f103 5396 	add.w	r3, r3, #314572800	; 0x12c00000
 8033cf4:	f503 13a9 	add.w	r3, r3, #1384448	; 0x152000
 8033cf8:	f503 53ec 	add.w	r3, r3, #7552	; 0x1d80
                    sysTime = SysTimeAdd( sysTimeCurrent, SysTimeSub( sysTime, MacCtx.LastTxSysTime ) );
 8033cfc:	9308      	str	r3, [sp, #32]
 8033cfe:	f8d5 3340 	ldr.w	r3, [r5, #832]	; 0x340
 8033d02:	9300      	str	r3, [sp, #0]
 8033d04:	f10d 0920 	add.w	r9, sp, #32
 8033d08:	e899 0006 	ldmia.w	r9, {r1, r2}
 8033d0c:	f8d5 333c 	ldr.w	r3, [r5, #828]	; 0x33c
 8033d10:	a80a      	add	r0, sp, #40	; 0x28
 8033d12:	f007 f9b7 	bl	803b084 <SysTimeSub>
 8033d16:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8033d18:	9300      	str	r3, [sp, #0]
 8033d1a:	e89a 0006 	ldmia.w	sl, {r1, r2}
 8033d1e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8033d20:	4648      	mov	r0, r9
 8033d22:	f007 f993 	bl	803b04c <SysTimeAdd>
                    SysTimeSet( sysTime );
 8033d26:	e899 0003 	ldmia.w	r9, {r0, r1}
 8033d2a:	f007 f9c7 	bl	803b0bc <SysTimeSet>
                    LoRaMacClassBDeviceTimeAns( );
 8033d2e:	f001 fe29 	bl	8035984 <LoRaMacClassBDeviceTimeAns>
                    MacCtx.McpsIndication.DeviceTimeAnsReceived = true;
 8033d32:	2301      	movs	r3, #1
                    gpsEpochTime.SubSeconds = payload[macIndex++];
 8033d34:	b2e4      	uxtb	r4, r4
                    MacCtx.McpsIndication.DeviceTimeAnsReceived = true;
 8033d36:	f885 3438 	strb.w	r3, [r5, #1080]	; 0x438
 8033d3a:	e601      	b.n	8033940 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                if( LoRaMacConfirmQueueIsCmdActive( MLME_PING_SLOT_INFO ) == true )
 8033d3c:	200d      	movs	r0, #13
 8033d3e:	f001 ffd3 	bl	8035ce8 <LoRaMacConfirmQueueIsCmdActive>
 8033d42:	2800      	cmp	r0, #0
 8033d44:	f43f adfc 	beq.w	8033940 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_PING_SLOT_INFO );
 8033d48:	210d      	movs	r1, #13
 8033d4a:	2000      	movs	r0, #0
 8033d4c:	f001 ff90 	bl	8035c70 <LoRaMacConfirmQueueSetStatus>
                    if( ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_PING_SLOT ) && ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT ) )
 8033d50:	f895 3484 	ldrb.w	r3, [r5, #1156]	; 0x484
 8033d54:	3b04      	subs	r3, #4
 8033d56:	2b01      	cmp	r3, #1
 8033d58:	f67f adf2 	bls.w	8033940 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                        LoRaMacClassBPingSlotInfoAns( );
 8033d5c:	f001 fe0e 	bl	803597c <LoRaMacClassBPingSlotInfoAns>
 8033d60:	e5ee      	b.n	8033940 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                frequency = ( uint32_t )payload[macIndex++];
 8033d62:	f109 0202 	add.w	r2, r9, #2
                frequency |= ( uint32_t )payload[macIndex++] << 8;
 8033d66:	b2d2      	uxtb	r2, r2
                frequency = ( uint32_t )payload[macIndex++];
 8033d68:	5d31      	ldrb	r1, [r6, r4]
                frequency |= ( uint32_t )payload[macIndex++] << 8;
 8033d6a:	5cb0      	ldrb	r0, [r6, r2]
 8033d6c:	f109 0203 	add.w	r2, r9, #3
                frequency |= ( uint32_t )payload[macIndex++] << 16;
 8033d70:	b2d2      	uxtb	r2, r2
                datarate = payload[macIndex++] & 0x0F;
 8033d72:	f109 0405 	add.w	r4, r9, #5
                frequency |= ( uint32_t )payload[macIndex++] << 16;
 8033d76:	5cb3      	ldrb	r3, [r6, r2]
 8033d78:	f109 0904 	add.w	r9, r9, #4
                datarate = payload[macIndex++] & 0x0F;
 8033d7c:	fa5f f989 	uxtb.w	r9, r9
                frequency |= ( uint32_t )payload[macIndex++] << 16;
 8033d80:	041b      	lsls	r3, r3, #16
 8033d82:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
                datarate = payload[macIndex++] & 0x0F;
 8033d86:	f816 0009 	ldrb.w	r0, [r6, r9]
                frequency |= ( uint32_t )payload[macIndex++] << 16;
 8033d8a:	430b      	orrs	r3, r1
                status = LoRaMacClassBPingSlotChannelReq( datarate, frequency );
 8033d8c:	2164      	movs	r1, #100	; 0x64
 8033d8e:	4359      	muls	r1, r3
 8033d90:	f000 000f 	and.w	r0, r0, #15
 8033d94:	f001 fdf3 	bl	803597e <LoRaMacClassBPingSlotChannelReq>
                datarate = payload[macIndex++] & 0x0F;
 8033d98:	b2e4      	uxtb	r4, r4
                macCmdPayload[0] = status;
 8033d9a:	f88d 0018 	strb.w	r0, [sp, #24]
                LoRaMacCommandsAddCmd( MOTE_MAC_PING_SLOT_FREQ_ANS, macCmdPayload, 1 );
 8033d9e:	2201      	movs	r2, #1
 8033da0:	a906      	add	r1, sp, #24
 8033da2:	2011      	movs	r0, #17
 8033da4:	e69b      	b.n	8033ade <ProcessMacCommands.isra.0.constprop.0+0x25a>
                if( LoRaMacConfirmQueueIsCmdActive( MLME_BEACON_TIMING ) == true )
 8033da6:	200e      	movs	r0, #14
 8033da8:	f001 ff9e 	bl	8035ce8 <LoRaMacConfirmQueueIsCmdActive>
 8033dac:	2800      	cmp	r0, #0
 8033dae:	f43f adc7 	beq.w	8033940 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_BEACON_TIMING );
 8033db2:	210e      	movs	r1, #14
 8033db4:	2000      	movs	r0, #0
 8033db6:	f001 ff5b 	bl	8035c70 <LoRaMacConfirmQueueSetStatus>
                    beaconTimingDelay = ( uint16_t )payload[macIndex++];
 8033dba:	f109 0302 	add.w	r3, r9, #2
                    beaconTimingDelay |= ( uint16_t )payload[macIndex++] << 8;
 8033dbe:	b2db      	uxtb	r3, r3
                    LoRaMacClassBBeaconTimingAns( beaconTimingDelay, beaconTimingChannel, RxDoneParams.LastRxDone );
 8033dc0:	4a17      	ldr	r2, [pc, #92]	; (8033e20 <ProcessMacCommands.isra.0.constprop.0+0x59c>)
                    beaconTimingDelay |= ( uint16_t )payload[macIndex++] << 8;
 8033dc2:	5cf0      	ldrb	r0, [r6, r3]
 8033dc4:	5d33      	ldrb	r3, [r6, r4]
                    LoRaMacClassBBeaconTimingAns( beaconTimingDelay, beaconTimingChannel, RxDoneParams.LastRxDone );
 8033dc6:	6812      	ldr	r2, [r2, #0]
                    beaconTimingChannel = payload[macIndex++];
 8033dc8:	f109 0404 	add.w	r4, r9, #4
                    beaconTimingDelay |= ( uint16_t )payload[macIndex++] << 8;
 8033dcc:	f109 0903 	add.w	r9, r9, #3
                    beaconTimingChannel = payload[macIndex++];
 8033dd0:	fa5f f989 	uxtb.w	r9, r9
                    LoRaMacClassBBeaconTimingAns( beaconTimingDelay, beaconTimingChannel, RxDoneParams.LastRxDone );
 8033dd4:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 8033dd8:	f816 1009 	ldrb.w	r1, [r6, r9]
                    beaconTimingChannel = payload[macIndex++];
 8033ddc:	b2e4      	uxtb	r4, r4
                    LoRaMacClassBBeaconTimingAns( beaconTimingDelay, beaconTimingChannel, RxDoneParams.LastRxDone );
 8033dde:	f001 fdd0 	bl	8035982 <LoRaMacClassBBeaconTimingAns>
 8033de2:	e5ad      	b.n	8033940 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                    frequency = ( uint32_t )payload[macIndex++];
 8033de4:	5d30      	ldrb	r0, [r6, r4]
 8033de6:	f109 0302 	add.w	r3, r9, #2
                    frequency |= ( uint32_t )payload[macIndex++] << 16;
 8033dea:	f109 0404 	add.w	r4, r9, #4
                    frequency |= ( uint32_t )payload[macIndex++] << 8;
 8033dee:	f109 0903 	add.w	r9, r9, #3
 8033df2:	b2db      	uxtb	r3, r3
                    frequency |= ( uint32_t )payload[macIndex++] << 16;
 8033df4:	fa5f f989 	uxtb.w	r9, r9
                    frequency |= ( uint32_t )payload[macIndex++] << 8;
 8033df8:	5cf2      	ldrb	r2, [r6, r3]
                    frequency |= ( uint32_t )payload[macIndex++] << 16;
 8033dfa:	f816 3009 	ldrb.w	r3, [r6, r9]
 8033dfe:	041b      	lsls	r3, r3, #16
 8033e00:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8033e04:	4303      	orrs	r3, r0
                    if( LoRaMacClassBBeaconFreqReq( frequency ) == true )
 8033e06:	2064      	movs	r0, #100	; 0x64
 8033e08:	4358      	muls	r0, r3
 8033e0a:	f001 fdbc 	bl	8035986 <LoRaMacClassBBeaconFreqReq>
                    frequency |= ( uint32_t )payload[macIndex++] << 16;
 8033e0e:	b2e4      	uxtb	r4, r4
                    if( LoRaMacClassBBeaconFreqReq( frequency ) == true )
 8033e10:	f88d 0018 	strb.w	r0, [sp, #24]
                    LoRaMacCommandsAddCmd( MOTE_MAC_BEACON_FREQ_ANS, macCmdPayload, 1 );
 8033e14:	2201      	movs	r2, #1
 8033e16:	a906      	add	r1, sp, #24
 8033e18:	2013      	movs	r0, #19
 8033e1a:	e660      	b.n	8033ade <ProcessMacCommands.isra.0.constprop.0+0x25a>
 8033e1c:	0803ba62 	.word	0x0803ba62
 8033e20:	20006314 	.word	0x20006314

08033e24 <LoRaMacIsBusy>:
    if( ( MacCtx.MacState == LORAMAC_IDLE ) &&
 8033e24:	4b05      	ldr	r3, [pc, #20]	; (8033e3c <LoRaMacIsBusy+0x18>)
 8033e26:	f8d3 2344 	ldr.w	r2, [r3, #836]	; 0x344
 8033e2a:	b92a      	cbnz	r2, 8033e38 <LoRaMacIsBusy+0x14>
 8033e2c:	f893 0486 	ldrb.w	r0, [r3, #1158]	; 0x486
 8033e30:	3801      	subs	r0, #1
 8033e32:	bf18      	it	ne
 8033e34:	2001      	movne	r0, #1
 8033e36:	4770      	bx	lr
    return true;
 8033e38:	2001      	movs	r0, #1
}
 8033e3a:	4770      	bx	lr
 8033e3c:	20004aa4 	.word	0x20004aa4

08033e40 <LoRaMacProcess>:
{
 8033e40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8033e44:	b0a5      	sub	sp, #148	; 0x94
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8033e46:	f3ef 8210 	mrs	r2, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8033e4a:	b672      	cpsid	i
    events = LoRaMacRadioEvents;
 8033e4c:	4ccf      	ldr	r4, [pc, #828]	; (803418c <LoRaMacProcess+0x34c>)
    LoRaMacRadioEvents.Value = 0;
 8033e4e:	2100      	movs	r1, #0
    events = LoRaMacRadioEvents;
 8033e50:	6823      	ldr	r3, [r4, #0]
    LoRaMacRadioEvents.Value = 0;
 8033e52:	6021      	str	r1, [r4, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8033e54:	f382 8810 	msr	PRIMASK, r2
    if( events.Value != 0 )
 8033e58:	2b00      	cmp	r3, #0
 8033e5a:	f000 80cd 	beq.w	8033ff8 <LoRaMacProcess+0x1b8>
        if( events.Events.TxDone == 1 )
 8033e5e:	06da      	lsls	r2, r3, #27
 8033e60:	fa5f fa83 	uxtb.w	sl, r3
 8033e64:	d560      	bpl.n	8033f28 <LoRaMacProcess+0xe8>
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 8033e66:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 8033e6a:	2b02      	cmp	r3, #2
 8033e6c:	d002      	beq.n	8033e74 <LoRaMacProcess+0x34>
        Radio.Sleep( );
 8033e6e:	4bc8      	ldr	r3, [pc, #800]	; (8034190 <LoRaMacProcess+0x350>)
 8033e70:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8033e72:	4798      	blx	r3
    TimerSetValue( &MacCtx.RxWindowTimer1, MacCtx.RxWindow1Delay );
 8033e74:	f8d4 13b4 	ldr.w	r1, [r4, #948]	; 0x3b4
 8033e78:	48c6      	ldr	r0, [pc, #792]	; (8034194 <LoRaMacProcess+0x354>)
 8033e7a:	f007 fabf 	bl	803b3fc <UTIL_TIMER_SetPeriod>
    TimerStart( &MacCtx.RxWindowTimer1 );
 8033e7e:	48c5      	ldr	r0, [pc, #788]	; (8034194 <LoRaMacProcess+0x354>)
 8033e80:	f007 fa82 	bl	803b388 <UTIL_TIMER_Start>
    TimerSetValue( &MacCtx.RxWindowTimer2, MacCtx.RxWindow2Delay );
 8033e84:	f8d4 13b8 	ldr.w	r1, [r4, #952]	; 0x3b8
 8033e88:	48c3      	ldr	r0, [pc, #780]	; (8034198 <LoRaMacProcess+0x358>)
 8033e8a:	f007 fab7 	bl	803b3fc <UTIL_TIMER_SetPeriod>
    TimerStart( &MacCtx.RxWindowTimer2 );
 8033e8e:	48c2      	ldr	r0, [pc, #776]	; (8034198 <LoRaMacProcess+0x358>)
 8033e90:	f007 fa7a 	bl	803b388 <UTIL_TIMER_Start>
    if( ( Nvm.MacGroup2.DeviceClass == CLASS_C ) || ( MacCtx.NodeAckRequested == true ) )
 8033e94:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 8033e98:	2b02      	cmp	r3, #2
 8033e9a:	d002      	beq.n	8033ea2 <LoRaMacProcess+0x62>
 8033e9c:	f894 3418 	ldrb.w	r3, [r4, #1048]	; 0x418
 8033ea0:	b18b      	cbz	r3, 8033ec6 <LoRaMacProcess+0x86>
        getPhy.Attribute = PHY_ACK_TIMEOUT;
 8033ea2:	2316      	movs	r3, #22
        phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8033ea4:	a90e      	add	r1, sp, #56	; 0x38
 8033ea6:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
        getPhy.Attribute = PHY_ACK_TIMEOUT;
 8033eaa:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
        phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8033eae:	f002 fc0c 	bl	80366ca <RegionGetPhyParam>
        TimerSetValue( &MacCtx.AckTimeoutTimer, MacCtx.RxWindow2Delay + phyParam.Value );
 8033eb2:	f8d4 13b8 	ldr.w	r1, [r4, #952]	; 0x3b8
        phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8033eb6:	900c      	str	r0, [sp, #48]	; 0x30
        TimerSetValue( &MacCtx.AckTimeoutTimer, MacCtx.RxWindow2Delay + phyParam.Value );
 8033eb8:	4401      	add	r1, r0
 8033eba:	48b8      	ldr	r0, [pc, #736]	; (803419c <LoRaMacProcess+0x35c>)
 8033ebc:	f007 fa9e 	bl	803b3fc <UTIL_TIMER_SetPeriod>
        TimerStart( &MacCtx.AckTimeoutTimer );
 8033ec0:	48b6      	ldr	r0, [pc, #728]	; (803419c <LoRaMacProcess+0x35c>)
 8033ec2:	f007 fa61 	bl	803b388 <UTIL_TIMER_Start>
    Nvm.MacGroup1.LastTxDoneTime = TxDoneParams.CurTime;
 8033ec6:	4bb6      	ldr	r3, [pc, #728]	; (80341a0 <LoRaMacProcess+0x360>)
    txDone.Channel = MacCtx.Channel;
 8033ec8:	f894 2419 	ldrb.w	r2, [r4, #1049]	; 0x419
    Nvm.MacGroup1.LastTxDoneTime = TxDoneParams.CurTime;
 8033ecc:	681b      	ldr	r3, [r3, #0]
 8033ece:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    txDone.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );
 8033ed2:	ae0a      	add	r6, sp, #40	; 0x28
 8033ed4:	4630      	mov	r0, r6
    txDone.Channel = MacCtx.Channel;
 8033ed6:	f88d 2060 	strb.w	r2, [sp, #96]	; 0x60
    txDone.LastTxDoneTime = TxDoneParams.CurTime;
 8033eda:	9319      	str	r3, [sp, #100]	; 0x64
    txDone.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );
 8033edc:	f007 f93c 	bl	803b158 <SysTimeGetMcuTime>
 8033ee0:	f8d4 3614 	ldr.w	r3, [r4, #1556]	; 0x614
 8033ee4:	9300      	str	r3, [sp, #0]
 8033ee6:	ad04      	add	r5, sp, #16
 8033ee8:	e896 0006 	ldmia.w	r6, {r1, r2}
 8033eec:	f8d4 3610 	ldr.w	r3, [r4, #1552]	; 0x610
 8033ef0:	4628      	mov	r0, r5
 8033ef2:	f007 f8c7 	bl	803b084 <SysTimeSub>
 8033ef6:	e895 0003 	ldmia.w	r5, {r0, r1}
 8033efa:	ab1b      	add	r3, sp, #108	; 0x6c
 8033efc:	e883 0003 	stmia.w	r3, {r0, r1}
    txDone.LastTxAirTime = MacCtx.TxTimeOnAir;
 8033f00:	f8d4 341c 	ldr.w	r3, [r4, #1052]	; 0x41c
 8033f04:	931a      	str	r3, [sp, #104]	; 0x68
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 8033f06:	f894 361c 	ldrb.w	r3, [r4, #1564]	; 0x61c
    RegionSetBandTxDone( Nvm.MacGroup2.Region, &txDone );
 8033f0a:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
        txDone.Joined  = false;
 8033f0e:	2b00      	cmp	r3, #0
 8033f10:	bf18      	it	ne
 8033f12:	2301      	movne	r3, #1
    RegionSetBandTxDone( Nvm.MacGroup2.Region, &txDone );
 8033f14:	a918      	add	r1, sp, #96	; 0x60
        txDone.Joined  = false;
 8033f16:	f88d 3061 	strb.w	r3, [sp, #97]	; 0x61
    RegionSetBandTxDone( Nvm.MacGroup2.Region, &txDone );
 8033f1a:	f002 fbe6 	bl	80366ea <RegionSetBandTxDone>
    if( MacCtx.NodeAckRequested == false )
 8033f1e:	f894 3418 	ldrb.w	r3, [r4, #1048]	; 0x418
 8033f22:	b90b      	cbnz	r3, 8033f28 <LoRaMacProcess+0xe8>
        MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;
 8033f24:	f884 343d 	strb.w	r3, [r4, #1085]	; 0x43d
        if( events.Events.RxDone == 1 )
 8033f28:	f01a 0f08 	tst.w	sl, #8
 8033f2c:	d039      	beq.n	8033fa2 <LoRaMacProcess+0x162>
    uint8_t *payload = RxDoneParams.Payload;
 8033f2e:	4b9d      	ldr	r3, [pc, #628]	; (80341a4 <LoRaMacProcess+0x364>)
    uint32_t address = Nvm.MacGroup2.DevAddr;
 8033f30:	f8d4 25d8 	ldr.w	r2, [r4, #1496]	; 0x5d8
    uint8_t *payload = RxDoneParams.Payload;
 8033f34:	685e      	ldr	r6, [r3, #4]
    uint16_t size = RxDoneParams.Size;
 8033f36:	891d      	ldrh	r5, [r3, #8]
    int16_t rssi = RxDoneParams.Rssi;
 8033f38:	f9b3 700a 	ldrsh.w	r7, [r3, #10]
    int8_t snr = RxDoneParams.Snr;
 8033f3c:	f993 900c 	ldrsb.w	r9, [r3, #12]
    uint32_t address = Nvm.MacGroup2.DevAddr;
 8033f40:	9203      	str	r2, [sp, #12]
    uint32_t downLinkCounter = 0;
 8033f42:	2300      	movs	r3, #0
 8033f44:	9307      	str	r3, [sp, #28]
    MacCtx.McpsConfirm.AckReceived = false;
 8033f46:	f884 3440 	strb.w	r3, [r4, #1088]	; 0x440
    MacCtx.McpsIndication.Multicast = 0;
 8033f4a:	f8a4 3422 	strh.w	r3, [r4, #1058]	; 0x422
    MacCtx.McpsIndication.FramePending = 0;
 8033f4e:	f884 3425 	strb.w	r3, [r4, #1061]	; 0x425
    MacCtx.McpsIndication.Buffer = NULL;
 8033f52:	f8c4 3428 	str.w	r3, [r4, #1064]	; 0x428
    MacCtx.McpsIndication.BufferSize = 0;
 8033f56:	f8a4 342c 	strh.w	r3, [r4, #1068]	; 0x42c
    MacCtx.McpsIndication.AckReceived = false;
 8033f5a:	f884 342e 	strb.w	r3, [r4, #1070]	; 0x42e
    MacCtx.McpsIndication.DownLinkCounter = 0;
 8033f5e:	f8c4 3430 	str.w	r3, [r4, #1072]	; 0x430
    MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED;
 8033f62:	f884 3420 	strb.w	r3, [r4, #1056]	; 0x420
    MacCtx.McpsIndication.DevAddress = 0;
 8033f66:	f8c4 3434 	str.w	r3, [r4, #1076]	; 0x434
    MacCtx.McpsIndication.DeviceTimeAnsReceived = false;
 8033f6a:	f884 3438 	strb.w	r3, [r4, #1080]	; 0x438
    Radio.Sleep( );
 8033f6e:	4b88      	ldr	r3, [pc, #544]	; (8034190 <LoRaMacProcess+0x350>)
    MacCtx.RxStatus.RxSlot = MacCtx.RxSlot;
 8033f70:	f894 2484 	ldrb.w	r2, [r4, #1156]	; 0x484
    Radio.Sleep( );
 8033f74:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    MacCtx.RxStatus.RxSlot = MacCtx.RxSlot;
 8033f76:	f884 2483 	strb.w	r2, [r4, #1155]	; 0x483
    MacCtx.RxStatus.Rssi = rssi;
 8033f7a:	f8a4 7480 	strh.w	r7, [r4, #1152]	; 0x480
    MacCtx.RxStatus.Snr = snr;
 8033f7e:	f884 9482 	strb.w	r9, [r4, #1154]	; 0x482
    Radio.Sleep( );
 8033f82:	4798      	blx	r3
    TimerStop( &MacCtx.RxWindowTimer2 );
 8033f84:	4884      	ldr	r0, [pc, #528]	; (8034198 <LoRaMacProcess+0x358>)
 8033f86:	f007 f9af 	bl	803b2e8 <UTIL_TIMER_Stop>
    if( LoRaMacClassBRxBeacon( payload, size ) == true )
 8033f8a:	4629      	mov	r1, r5
 8033f8c:	4630      	mov	r0, r6
 8033f8e:	f001 fce2 	bl	8035956 <LoRaMacClassBRxBeacon>
 8033f92:	4680      	mov	r8, r0
 8033f94:	2800      	cmp	r0, #0
 8033f96:	f000 8169 	beq.w	803426c <LoRaMacProcess+0x42c>
        MacCtx.MlmeIndication.BeaconInfo.Rssi = rssi;
 8033f9a:	f8a4 7476 	strh.w	r7, [r4, #1142]	; 0x476
        MacCtx.MlmeIndication.BeaconInfo.Snr = snr;
 8033f9e:	f884 9478 	strb.w	r9, [r4, #1144]	; 0x478
        if( events.Events.TxTimeout == 1 )
 8033fa2:	f01a 0f04 	tst.w	sl, #4
 8033fa6:	d019      	beq.n	8033fdc <LoRaMacProcess+0x19c>
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 8033fa8:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 8033fac:	2b02      	cmp	r3, #2
 8033fae:	d002      	beq.n	8033fb6 <LoRaMacProcess+0x176>
        Radio.Sleep( );
 8033fb0:	4b77      	ldr	r3, [pc, #476]	; (8034190 <LoRaMacProcess+0x350>)
 8033fb2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8033fb4:	4798      	blx	r3
    UpdateRxSlotIdleState( );
 8033fb6:	f7fe ffdd 	bl	8032f74 <UpdateRxSlotIdleState>
    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT;
 8033fba:	2002      	movs	r0, #2
 8033fbc:	f884 043d 	strb.w	r0, [r4, #1085]	; 0x43d
    LoRaMacConfirmQueueSetStatusCmn( LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT );
 8033fc0:	f001 fe78 	bl	8035cb4 <LoRaMacConfirmQueueSetStatusCmn>
    if( MacCtx.NodeAckRequested == true )
 8033fc4:	f894 3418 	ldrb.w	r3, [r4, #1048]	; 0x418
 8033fc8:	b113      	cbz	r3, 8033fd0 <LoRaMacProcess+0x190>
        MacCtx.AckTimeoutRetry = true;
 8033fca:	2301      	movs	r3, #1
 8033fcc:	f884 3417 	strb.w	r3, [r4, #1047]	; 0x417
    MacCtx.MacFlags.Bits.MacDone = 1;
 8033fd0:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 8033fd4:	f043 0320 	orr.w	r3, r3, #32
 8033fd8:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
        if( events.Events.RxError == 1 )
 8033fdc:	f01a 0f02 	tst.w	sl, #2
 8033fe0:	d003      	beq.n	8033fea <LoRaMacProcess+0x1aa>
    HandleRadioRxErrorTimeout( LORAMAC_EVENT_INFO_STATUS_RX1_ERROR, LORAMAC_EVENT_INFO_STATUS_RX2_ERROR );
 8033fe2:	2106      	movs	r1, #6
 8033fe4:	2005      	movs	r0, #5
 8033fe6:	f7ff f84d 	bl	8033084 <HandleRadioRxErrorTimeout>
        if( events.Events.RxTimeout == 1 )
 8033fea:	f01a 0f01 	tst.w	sl, #1
 8033fee:	d003      	beq.n	8033ff8 <LoRaMacProcess+0x1b8>
    HandleRadioRxErrorTimeout( LORAMAC_EVENT_INFO_STATUS_RX1_TIMEOUT, LORAMAC_EVENT_INFO_STATUS_RX2_TIMEOUT );
 8033ff0:	2104      	movs	r1, #4
 8033ff2:	2003      	movs	r0, #3
 8033ff4:	f7ff f846 	bl	8033084 <HandleRadioRxErrorTimeout>
    LoRaMacClassBProcess( );
 8033ff8:	f001 fccb 	bl	8035992 <LoRaMacClassBProcess>
    if( MacCtx.MacFlags.Bits.MacDone == 1 )
 8033ffc:	f894 2485 	ldrb.w	r2, [r4, #1157]	; 0x485
 8034000:	0697      	lsls	r7, r2, #26
 8034002:	f140 80f9 	bpl.w	80341f8 <LoRaMacProcess+0x3b8>
    MacCtx.AllowRequests = requestState;
 8034006:	2300      	movs	r3, #0
 8034008:	f884 3486 	strb.w	r3, [r4, #1158]	; 0x486
    if( ( MacCtx.MacState & LORAMAC_RX_ABORT ) == LORAMAC_RX_ABORT )
 803400c:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 8034010:	061e      	lsls	r6, r3, #24
        MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 8034012:	bf44      	itt	mi
 8034014:	f023 0382 	bicmi.w	r3, r3, #130	; 0x82
 8034018:	f8c4 3344 	strmi.w	r3, [r4, #836]	; 0x344
    MacCtx.McpsConfirm.NbRetries = MacCtx.AckTimeoutRetriesCounter;
}

static uint8_t IsRequestPending( void )
{
    if( ( MacCtx.MacFlags.Bits.MlmeReq == 1 ) ||
 803401c:	f012 0f05 	tst.w	r2, #5
 8034020:	f000 832c 	beq.w	803467c <LoRaMacProcess+0x83c>
    if( ( LoRaMacConfirmQueueIsCmdActive( MLME_BEACON_ACQUISITION ) == true ) &&
 8034024:	200c      	movs	r0, #12
 8034026:	f001 fe5f 	bl	8035ce8 <LoRaMacConfirmQueueIsCmdActive>
 803402a:	2800      	cmp	r0, #0
 803402c:	f000 8326 	beq.w	803467c <LoRaMacProcess+0x83c>
        ( MacCtx.MacFlags.Bits.McpsReq == 0 ) )
 8034030:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
    if( ( LoRaMacConfirmQueueIsCmdActive( MLME_BEACON_ACQUISITION ) == true ) &&
 8034034:	07dd      	lsls	r5, r3, #31
 8034036:	f100 8321 	bmi.w	803467c <LoRaMacProcess+0x83c>
        if( MacCtx.MacFlags.Bits.MlmeReq == 1 )
 803403a:	0758      	lsls	r0, r3, #29
 803403c:	f140 8332 	bpl.w	80346a4 <LoRaMacProcess+0x864>
            MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 8034040:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 8034044:	f023 0302 	bic.w	r3, r3, #2
 8034048:	f8c4 3344 	str.w	r3, [r4, #836]	; 0x344
    if( MacCtx.MacState == LORAMAC_IDLE )
 803404c:	f8d4 2344 	ldr.w	r2, [r4, #836]	; 0x344
 8034050:	2a00      	cmp	r2, #0
 8034052:	f040 80ce 	bne.w	80341f2 <LoRaMacProcess+0x3b2>
 8034056:	f894 5485 	ldrb.w	r5, [r4, #1157]	; 0x485
        if( MacCtx.MacFlags.Bits.McpsReq == 1 )
 803405a:	f015 0101 	ands.w	r1, r5, #1
            MacCtx.MacFlags.Bits.McpsReq = 0;
 803405e:	bf1e      	ittt	ne
 8034060:	462b      	movne	r3, r5
 8034062:	f362 0300 	bfine	r3, r2, #0, #1
 8034066:	f884 3485 	strbne.w	r3, [r4, #1157]	; 0x485
        if( MacCtx.MacFlags.Bits.MlmeReq == 1 )
 803406a:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 803406e:	075e      	lsls	r6, r3, #29
            MacCtx.MacFlags.Bits.MlmeReq = 0;
 8034070:	bf44      	itt	mi
 8034072:	f36f 0382 	bfcmi	r3, #2, #1
 8034076:	f884 3485 	strbmi.w	r3, [r4, #1157]	; 0x485
    MacCtx.AllowRequests = requestState;
 803407a:	2301      	movs	r3, #1
 803407c:	f884 3486 	strb.w	r3, [r4, #1158]	; 0x486
        if( reqEvents.Bits.McpsReq == 1 )
 8034080:	b121      	cbz	r1, 803408c <LoRaMacProcess+0x24c>
            MacCtx.MacPrimitives->MacMcpsConfirm( &MacCtx.McpsConfirm );
 8034082:	f8d4 3348 	ldr.w	r3, [r4, #840]	; 0x348
 8034086:	4848      	ldr	r0, [pc, #288]	; (80341a8 <LoRaMacProcess+0x368>)
 8034088:	681b      	ldr	r3, [r3, #0]
 803408a:	4798      	blx	r3
        if( reqEvents.Bits.MlmeReq == 1 )
 803408c:	076d      	lsls	r5, r5, #29
 803408e:	d50b      	bpl.n	80340a8 <LoRaMacProcess+0x268>
            LoRaMacConfirmQueueHandleCb( &MacCtx.MlmeConfirm );
 8034090:	4846      	ldr	r0, [pc, #280]	; (80341ac <LoRaMacProcess+0x36c>)
 8034092:	f001 fe35 	bl	8035d00 <LoRaMacConfirmQueueHandleCb>
            if( LoRaMacConfirmQueueGetCnt( ) > 0 )
 8034096:	f001 fe5d 	bl	8035d54 <LoRaMacConfirmQueueGetCnt>
 803409a:	b128      	cbz	r0, 80340a8 <LoRaMacProcess+0x268>
                MacCtx.MacFlags.Bits.MlmeReq = 1;
 803409c:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 80340a0:	f043 0304 	orr.w	r3, r3, #4
 80340a4:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
        LoRaMacClassBResumeBeaconing( );
 80340a8:	f001 fc61 	bl	803596e <LoRaMacClassBResumeBeaconing>
        MacCtx.MacFlags.Bits.MacDone = 0;
 80340ac:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 80340b0:	f36f 1345 	bfc	r3, #5, #1
 80340b4:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
    if( MacCtx.MacState == LORAMAC_IDLE )
 80340b8:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 80340bc:	2b00      	cmp	r3, #0
 80340be:	f040 8098 	bne.w	80341f2 <LoRaMacProcess+0x3b2>
        LoRaMacCommandsStickyCmdsPending( &isStickyMacCommandPending );
 80340c2:	a818      	add	r0, sp, #96	; 0x60
        bool isStickyMacCommandPending = false;
 80340c4:	f88d 3060 	strb.w	r3, [sp, #96]	; 0x60
        LoRaMacCommandsStickyCmdsPending( &isStickyMacCommandPending );
 80340c8:	f001 fd4a 	bl	8035b60 <LoRaMacCommandsStickyCmdsPending>
        if( isStickyMacCommandPending == true )
 80340cc:	f89d 3060 	ldrb.w	r3, [sp, #96]	; 0x60
 80340d0:	b12b      	cbz	r3, 80340de <LoRaMacProcess+0x29e>
    MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 1;
 80340d2:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 80340d6:	f043 0310 	orr.w	r3, r3, #16
 80340da:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
    if( MacCtx.MacState != LORAMAC_IDLE )
 80340de:	f8d4 5344 	ldr.w	r5, [r4, #836]	; 0x344
 80340e2:	2d00      	cmp	r5, #0
 80340e4:	f040 8085 	bne.w	80341f2 <LoRaMacProcess+0x3b2>
    crc = Crc32( ( uint8_t* ) &nvmData->Crypto, sizeof( nvmData->Crypto ) -
 80340e8:	2124      	movs	r1, #36	; 0x24
 80340ea:	4831      	ldr	r0, [pc, #196]	; (80341b0 <LoRaMacProcess+0x370>)
 80340ec:	f004 ff10 	bl	8038f10 <Crc32>
    if( crc != nvmData->Crypto.Crc32 )
 80340f0:	f8d4 3530 	ldr.w	r3, [r4, #1328]	; 0x530
 80340f4:	4298      	cmp	r0, r3
        nvmData->Crypto.Crc32 = crc;
 80340f6:	bf18      	it	ne
 80340f8:	f8c4 0530 	strne.w	r0, [r4, #1328]	; 0x530
    crc = Crc32( ( uint8_t* ) &nvmData->MacGroup1, sizeof( nvmData->MacGroup1 ) -
 80340fc:	f04f 0114 	mov.w	r1, #20
 8034100:	482c      	ldr	r0, [pc, #176]	; (80341b4 <LoRaMacProcess+0x374>)
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_CRYPTO;
 8034102:	bf18      	it	ne
 8034104:	2501      	movne	r5, #1
    crc = Crc32( ( uint8_t* ) &nvmData->MacGroup1, sizeof( nvmData->MacGroup1 ) -
 8034106:	f004 ff03 	bl	8038f10 <Crc32>
    if( crc != nvmData->MacGroup1.Crc32 )
 803410a:	f8d4 3548 	ldr.w	r3, [r4, #1352]	; 0x548
 803410e:	4298      	cmp	r0, r3
        nvmData->MacGroup1.Crc32 = crc;
 8034110:	bf18      	it	ne
 8034112:	f8c4 0548 	strne.w	r0, [r4, #1352]	; 0x548
    crc = Crc32( ( uint8_t* ) &nvmData->MacGroup2, sizeof( nvmData->MacGroup2 ) -
 8034116:	f04f 01d4 	mov.w	r1, #212	; 0xd4
 803411a:	4827      	ldr	r0, [pc, #156]	; (80341b8 <LoRaMacProcess+0x378>)
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_MAC_GROUP1;
 803411c:	bf18      	it	ne
 803411e:	f045 0502 	orrne.w	r5, r5, #2
    crc = Crc32( ( uint8_t* ) &nvmData->MacGroup2, sizeof( nvmData->MacGroup2 ) -
 8034122:	f004 fef5 	bl	8038f10 <Crc32>
    if( crc != nvmData->MacGroup2.Crc32 )
 8034126:	f8d4 3620 	ldr.w	r3, [r4, #1568]	; 0x620
 803412a:	4298      	cmp	r0, r3
        nvmData->MacGroup2.Crc32 = crc;
 803412c:	bf18      	it	ne
 803412e:	f8c4 0620 	strne.w	r0, [r4, #1568]	; 0x620
    crc = Crc32( ( uint8_t* ) &nvmData->SecureElement, sizeof( nvmData->SecureElement ) -
 8034132:	f44f 7180 	mov.w	r1, #256	; 0x100
 8034136:	4821      	ldr	r0, [pc, #132]	; (80341bc <LoRaMacProcess+0x37c>)
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_MAC_GROUP2;
 8034138:	bf18      	it	ne
 803413a:	f045 0504 	orrne.w	r5, r5, #4
    crc = Crc32( ( uint8_t* ) &nvmData->SecureElement, sizeof( nvmData->SecureElement ) -
 803413e:	f004 fee7 	bl	8038f10 <Crc32>
    if( crc != nvmData->SecureElement.Crc32 )
 8034142:	f8d4 3724 	ldr.w	r3, [r4, #1828]	; 0x724
 8034146:	4298      	cmp	r0, r3
        nvmData->SecureElement.Crc32 = crc;
 8034148:	bf18      	it	ne
 803414a:	f8c4 0724 	strne.w	r0, [r4, #1828]	; 0x724
    crc = Crc32( ( uint8_t* ) &nvmData->RegionGroup1, sizeof( nvmData->RegionGroup1 ) -
 803414e:	f04f 01a0 	mov.w	r1, #160	; 0xa0
 8034152:	481b      	ldr	r0, [pc, #108]	; (80341c0 <LoRaMacProcess+0x380>)
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_SECURE_ELEMENT;
 8034154:	bf18      	it	ne
 8034156:	f045 0508 	orrne.w	r5, r5, #8
    crc = Crc32( ( uint8_t* ) &nvmData->RegionGroup1, sizeof( nvmData->RegionGroup1 ) -
 803415a:	f004 fed9 	bl	8038f10 <Crc32>
    if( crc != nvmData->RegionGroup1.Crc32 )
 803415e:	f8d4 37c8 	ldr.w	r3, [r4, #1992]	; 0x7c8
 8034162:	4298      	cmp	r0, r3
        nvmData->RegionGroup1.Crc32 = crc;
 8034164:	bf18      	it	ne
 8034166:	f8c4 07c8 	strne.w	r0, [r4, #1992]	; 0x7c8
    crc = Crc32( ( uint8_t* ) &nvmData->RegionGroup2, sizeof( nvmData->RegionGroup2 ) -
 803416a:	f44f 715e 	mov.w	r1, #888	; 0x378
 803416e:	4815      	ldr	r0, [pc, #84]	; (80341c4 <LoRaMacProcess+0x384>)
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_REGION_GROUP1;
 8034170:	bf18      	it	ne
 8034172:	f045 0510 	orrne.w	r5, r5, #16
    crc = Crc32( ( uint8_t* ) &nvmData->RegionGroup2, sizeof( nvmData->RegionGroup2 ) -
 8034176:	f004 fecb 	bl	8038f10 <Crc32>
    if( crc != nvmData->RegionGroup2.Crc32 )
 803417a:	f8d4 3b44 	ldr.w	r3, [r4, #2884]	; 0xb44
 803417e:	4298      	cmp	r0, r3
        nvmData->RegionGroup2.Crc32 = crc;
 8034180:	bf18      	it	ne
 8034182:	f8c4 0b44 	strne.w	r0, [r4, #2884]	; 0xb44
    crc = Crc32( ( uint8_t* ) &nvmData->ClassB, sizeof( nvmData->ClassB ) -
 8034186:	f04f 0114 	mov.w	r1, #20
 803418a:	e01d      	b.n	80341c8 <LoRaMacProcess+0x388>
 803418c:	20004aa4 	.word	0x20004aa4
 8034190:	0803bbd8 	.word	0x0803bbd8
 8034194:	20004e28 	.word	0x20004e28
 8034198:	20004e40 	.word	0x20004e40
 803419c:	20004ea0 	.word	0x20004ea0
 80341a0:	20006310 	.word	0x20006310
 80341a4:	20006314 	.word	0x20006314
 80341a8:	20004ee0 	.word	0x20004ee0
 80341ac:	20004ef4 	.word	0x20004ef4
 80341b0:	20004fb0 	.word	0x20004fb0
 80341b4:	20004fd8 	.word	0x20004fd8
 80341b8:	20004ff0 	.word	0x20004ff0
 80341bc:	200050c8 	.word	0x200050c8
 80341c0:	200051cc 	.word	0x200051cc
 80341c4:	20005270 	.word	0x20005270
 80341c8:	487f      	ldr	r0, [pc, #508]	; (80343c8 <LoRaMacProcess+0x588>)
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_REGION_GROUP2;
 80341ca:	bf18      	it	ne
 80341cc:	f045 0520 	orrne.w	r5, r5, #32
    crc = Crc32( ( uint8_t* ) &nvmData->ClassB, sizeof( nvmData->ClassB ) -
 80341d0:	f004 fe9e 	bl	8038f10 <Crc32>
    if( crc != nvmData->ClassB.Crc32 )
 80341d4:	f8d4 3b5c 	ldr.w	r3, [r4, #2908]	; 0xb5c
 80341d8:	4298      	cmp	r0, r3
    if( ( MacCtx.MacCallbacks != NULL ) &&
 80341da:	f8d4 334c 	ldr.w	r3, [r4, #844]	; 0x34c
        nvmData->ClassB.Crc32 = crc;
 80341de:	bf1c      	itt	ne
 80341e0:	f8c4 0b5c 	strne.w	r0, [r4, #2908]	; 0xb5c
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_CLASS_B;
 80341e4:	f045 0540 	orrne.w	r5, r5, #64	; 0x40
    if( ( MacCtx.MacCallbacks != NULL ) &&
 80341e8:	b11b      	cbz	r3, 80341f2 <LoRaMacProcess+0x3b2>
        ( MacCtx.MacCallbacks->NvmDataChange  != NULL ) )
 80341ea:	68db      	ldr	r3, [r3, #12]
    if( ( MacCtx.MacCallbacks != NULL ) &&
 80341ec:	b10b      	cbz	r3, 80341f2 <LoRaMacProcess+0x3b2>
        MacCtx.MacCallbacks->NvmDataChange ( notifyFlags );
 80341ee:	4628      	mov	r0, r5
 80341f0:	4798      	blx	r3
    MacCtx.AllowRequests = requestState;
 80341f2:	2301      	movs	r3, #1
 80341f4:	f884 3486 	strb.w	r3, [r4, #1158]	; 0x486
    if( MacCtx.MacFlags.Bits.MlmeInd == 1 )
 80341f8:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 80341fc:	0718      	lsls	r0, r3, #28
 80341fe:	d50a      	bpl.n	8034216 <LoRaMacProcess+0x3d6>
        MacCtx.MacFlags.Bits.MlmeInd = 0;
 8034200:	f36f 03c3 	bfc	r3, #3, #1
        MacCtx.MacPrimitives->MacMlmeIndication( &MacCtx.MlmeIndication, &MacCtx.RxStatus );
 8034204:	4971      	ldr	r1, [pc, #452]	; (80343cc <LoRaMacProcess+0x58c>)
        MacCtx.MacFlags.Bits.MlmeInd = 0;
 8034206:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
        MacCtx.MacPrimitives->MacMlmeIndication( &MacCtx.MlmeIndication, &MacCtx.RxStatus );
 803420a:	f8d4 3348 	ldr.w	r3, [r4, #840]	; 0x348
 803420e:	f1a1 001c 	sub.w	r0, r1, #28
 8034212:	68db      	ldr	r3, [r3, #12]
 8034214:	4798      	blx	r3
    if( MacCtx.MacFlags.Bits.MlmeSchedUplinkInd == 1 )
 8034216:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 803421a:	06d9      	lsls	r1, r3, #27
 803421c:	d50e      	bpl.n	803423c <LoRaMacProcess+0x3fc>
        schduleUplinkIndication.MlmeIndication = MLME_SCHEDULE_UPLINK;
 803421e:	2307      	movs	r3, #7
 8034220:	f8ad 3060 	strh.w	r3, [sp, #96]	; 0x60
        MacCtx.MacPrimitives->MacMlmeIndication( &schduleUplinkIndication, &MacCtx.RxStatus );
 8034224:	f8d4 3348 	ldr.w	r3, [r4, #840]	; 0x348
 8034228:	4968      	ldr	r1, [pc, #416]	; (80343cc <LoRaMacProcess+0x58c>)
 803422a:	68db      	ldr	r3, [r3, #12]
 803422c:	a818      	add	r0, sp, #96	; 0x60
 803422e:	4798      	blx	r3
        MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 0;
 8034230:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 8034234:	f36f 1304 	bfc	r3, #4, #1
 8034238:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
    if( MacCtx.MacFlags.Bits.McpsInd == 1 )
 803423c:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 8034240:	079a      	lsls	r2, r3, #30
 8034242:	d50a      	bpl.n	803425a <LoRaMacProcess+0x41a>
        MacCtx.MacFlags.Bits.McpsInd = 0;
 8034244:	f36f 0341 	bfc	r3, #1, #1
        MacCtx.MacPrimitives->MacMcpsIndication( &MacCtx.McpsIndication, &MacCtx.RxStatus );
 8034248:	4960      	ldr	r1, [pc, #384]	; (80343cc <LoRaMacProcess+0x58c>)
        MacCtx.MacFlags.Bits.McpsInd = 0;
 803424a:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
        MacCtx.MacPrimitives->MacMcpsIndication( &MacCtx.McpsIndication, &MacCtx.RxStatus );
 803424e:	f8d4 3348 	ldr.w	r3, [r4, #840]	; 0x348
 8034252:	f1a1 0060 	sub.w	r0, r1, #96	; 0x60
 8034256:	685b      	ldr	r3, [r3, #4]
 8034258:	4798      	blx	r3
    if( MacCtx.RxSlot == RX_SLOT_WIN_CLASS_C )
 803425a:	f894 3484 	ldrb.w	r3, [r4, #1156]	; 0x484
 803425e:	2b02      	cmp	r3, #2
 8034260:	d101      	bne.n	8034266 <LoRaMacProcess+0x426>
        OpenContinuousRxCWindow( );
 8034262:	f7ff fa27 	bl	80336b4 <OpenContinuousRxCWindow>
}
 8034266:	b025      	add	sp, #148	; 0x94
 8034268:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 803426c:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 8034270:	2b01      	cmp	r3, #1
 8034272:	d10c      	bne.n	803428e <LoRaMacProcess+0x44e>
        if( LoRaMacClassBIsPingExpected( ) == true )
 8034274:	f001 fb73 	bl	803595e <LoRaMacClassBIsPingExpected>
 8034278:	4607      	mov	r7, r0
 803427a:	b1c8      	cbz	r0, 80342b0 <LoRaMacProcess+0x470>
            LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 803427c:	4640      	mov	r0, r8
 803427e:	f001 fb63 	bl	8035948 <LoRaMacClassBSetPingSlotState>
            LoRaMacClassBPingSlotTimerEvent( NULL );
 8034282:	4640      	mov	r0, r8
 8034284:	f001 fb65 	bl	8035952 <LoRaMacClassBPingSlotTimerEvent>
            MacCtx.RxStatus.RxSlot = RX_SLOT_WIN_CLASS_B_PING_SLOT;
 8034288:	2304      	movs	r3, #4
            MacCtx.RxStatus.RxSlot = RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT;
 803428a:	f884 3483 	strb.w	r3, [r4, #1155]	; 0x483
    macHdr.Value = payload[pktHeaderLen++];
 803428e:	f896 b000 	ldrb.w	fp, [r6]
    switch( macHdr.Bits.MType )
 8034292:	ea4f 135b 	mov.w	r3, fp, lsr #5
 8034296:	3b01      	subs	r3, #1
 8034298:	2b06      	cmp	r3, #6
 803429a:	f200 81e3 	bhi.w	8034664 <LoRaMacProcess+0x824>
 803429e:	e8df f013 	tbh	[pc, r3, lsl #1]
 80342a2:	0013      	.short	0x0013
 80342a4:	009a01e1 	.word	0x009a01e1
 80342a8:	009701e1 	.word	0x009701e1
 80342ac:	01d201e1 	.word	0x01d201e1
        else if( LoRaMacClassBIsMulticastExpected( ) == true )
 80342b0:	f001 fb57 	bl	8035962 <LoRaMacClassBIsMulticastExpected>
 80342b4:	2800      	cmp	r0, #0
 80342b6:	d0ea      	beq.n	803428e <LoRaMacProcess+0x44e>
            LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 80342b8:	4638      	mov	r0, r7
 80342ba:	f001 fb46 	bl	803594a <LoRaMacClassBSetMulticastSlotState>
            LoRaMacClassBMulticastSlotTimerEvent( NULL );
 80342be:	4638      	mov	r0, r7
 80342c0:	f001 fb48 	bl	8035954 <LoRaMacClassBMulticastSlotTimerEvent>
            MacCtx.RxStatus.RxSlot = RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT;
 80342c4:	2305      	movs	r3, #5
 80342c6:	e7e0      	b.n	803428a <LoRaMacProcess+0x44a>
            if( size < LORAMAC_JOIN_ACCEPT_FRAME_MIN_SIZE )
 80342c8:	2d10      	cmp	r5, #16
 80342ca:	d803      	bhi.n	80342d4 <LoRaMacProcess+0x494>
                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 80342cc:	2301      	movs	r3, #1
 80342ce:	f884 3421 	strb.w	r3, [r4, #1057]	; 0x421
 80342d2:	e123      	b.n	803451c <LoRaMacProcess+0x6dc>
            if( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE )
 80342d4:	f894 361c 	ldrb.w	r3, [r4, #1564]	; 0x61c
            macMsgJoinAccept.Buffer = payload;
 80342d8:	960e      	str	r6, [sp, #56]	; 0x38
            macMsgJoinAccept.BufSize = size;
 80342da:	b2ed      	uxtb	r5, r5
 80342dc:	f88d 503c 	strb.w	r5, [sp, #60]	; 0x3c
            if( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE )
 80342e0:	2b00      	cmp	r3, #0
 80342e2:	d1f3      	bne.n	80342cc <LoRaMacProcess+0x48c>
            macCryptoStatus = LoRaMacCryptoHandleJoinAccept( JOIN_REQ, SecureElementGetJoinEui( ), &macMsgJoinAccept );
 80342e4:	f004 fdd0 	bl	8038e88 <SecureElementGetJoinEui>
 80342e8:	aa0e      	add	r2, sp, #56	; 0x38
 80342ea:	4601      	mov	r1, r0
 80342ec:	20ff      	movs	r0, #255	; 0xff
 80342ee:	f001 ffdb 	bl	80362a8 <LoRaMacCryptoHandleJoinAccept>
            if( LORAMAC_CRYPTO_SUCCESS == macCryptoStatus )
 80342f2:	2800      	cmp	r0, #0
 80342f4:	d160      	bne.n	80343b8 <LoRaMacProcess+0x578>
                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[2] << 16 );
 80342f6:	f89d 3043 	ldrb.w	r3, [sp, #67]	; 0x43
                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[1] << 8 );
 80342fa:	f89d 2042 	ldrb.w	r2, [sp, #66]	; 0x42
                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[2] << 16 );
 80342fe:	041b      	lsls	r3, r3, #16
 8034300:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
                Nvm.MacGroup2.NetID = ( uint32_t ) macMsgJoinAccept.NetID[0];
 8034304:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[2] << 16 );
 8034308:	4313      	orrs	r3, r2
 803430a:	f8c4 35d4 	str.w	r3, [r4, #1492]	; 0x5d4
                Nvm.MacGroup2.DevAddr = macMsgJoinAccept.DevAddr;
 803430e:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8034310:	f8c4 35d8 	str.w	r3, [r4, #1496]	; 0x5d8
                Nvm.MacGroup2.MacParams.Rx1DrOffset = macMsgJoinAccept.DLSettings.Bits.RX1DRoffset;
 8034314:	f89d 3048 	ldrb.w	r3, [sp, #72]	; 0x48
 8034318:	f3c3 1202 	ubfx	r2, r3, #4, #3
                Nvm.MacGroup2.MacParams.Rx2Channel.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;
 803431c:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8034320:	f884 3574 	strb.w	r3, [r4, #1396]	; 0x574
                Nvm.MacGroup2.MacParams.RxCChannel.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;
 8034324:	f884 357c 	strb.w	r3, [r4, #1404]	; 0x57c
                Nvm.MacGroup2.MacParams.ReceiveDelay1 = macMsgJoinAccept.RxDelay;
 8034328:	f89d 3049 	ldrb.w	r3, [sp, #73]	; 0x49
                Nvm.MacGroup2.MacParams.Rx1DrOffset = macMsgJoinAccept.DLSettings.Bits.RX1DRoffset;
 803432c:	f884 256d 	strb.w	r2, [r4, #1389]	; 0x56d
                if( Nvm.MacGroup2.MacParams.ReceiveDelay1 == 0 )
 8034330:	2b00      	cmp	r3, #0
 8034332:	d03f      	beq.n	80343b4 <LoRaMacProcess+0x574>
                    Nvm.MacGroup2.MacParams.ReceiveDelay1 = 1;
 8034334:	f8c4 355c 	str.w	r3, [r4, #1372]	; 0x55c
                Nvm.MacGroup2.MacParams.ReceiveDelay1 *= 1000;
 8034338:	f8d4 255c 	ldr.w	r2, [r4, #1372]	; 0x55c
                RegionApplyCFList( Nvm.MacGroup2.Region, &applyCFList );
 803433c:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
                Nvm.MacGroup2.MacParams.ReceiveDelay1 *= 1000;
 8034340:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8034344:	4353      	muls	r3, r2
 8034346:	f8c4 355c 	str.w	r3, [r4, #1372]	; 0x55c
                Nvm.MacGroup2.MacParams.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay1 + 1000;
 803434a:	f503 737a 	add.w	r3, r3, #1000	; 0x3e8
 803434e:	f8c4 3560 	str.w	r3, [r4, #1376]	; 0x560
                Nvm.MacGroup2.Version.Fields.Minor = 0;
 8034352:	2600      	movs	r6, #0
                applyCFList.Payload = macMsgJoinAccept.CFList;
 8034354:	f10d 034a 	add.w	r3, sp, #74	; 0x4a
                applyCFList.Size = size - 17;
 8034358:	3d11      	subs	r5, #17
                RegionApplyCFList( Nvm.MacGroup2.Region, &applyCFList );
 803435a:	a90c      	add	r1, sp, #48	; 0x30
                applyCFList.Payload = macMsgJoinAccept.CFList;
 803435c:	930c      	str	r3, [sp, #48]	; 0x30
                Nvm.MacGroup2.Version.Fields.Minor = 0;
 803435e:	f884 661a 	strb.w	r6, [r4, #1562]	; 0x61a
                applyCFList.Size = size - 17;
 8034362:	f88d 5034 	strb.w	r5, [sp, #52]	; 0x34
                RegionApplyCFList( Nvm.MacGroup2.Region, &applyCFList );
 8034366:	f002 f9e3 	bl	8036730 <RegionApplyCFList>
                Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_OTAA;
 803436a:	2302      	movs	r3, #2
                if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )
 803436c:	2001      	movs	r0, #1
                Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_OTAA;
 803436e:	f884 361c 	strb.w	r3, [r4, #1564]	; 0x61c
                if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )
 8034372:	f001 fcb9 	bl	8035ce8 <LoRaMacConfirmQueueIsCmdActive>
 8034376:	b118      	cbz	r0, 8034380 <LoRaMacProcess+0x540>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_JOIN );
 8034378:	2101      	movs	r1, #1
 803437a:	4630      	mov	r0, r6
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL, MLME_JOIN );
 803437c:	f001 fc78 	bl	8035c70 <LoRaMacConfirmQueueSetStatus>
            MacCtx.MacFlags.Bits.MlmeInd = 1;
 8034380:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 8034384:	f043 0308 	orr.w	r3, r3, #8
            MacCtx.MacFlags.Bits.McpsInd = 1;
 8034388:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
    if( MacCtx.NodeAckRequested == true )
 803438c:	f894 3418 	ldrb.w	r3, [r4, #1048]	; 0x418
 8034390:	2b00      	cmp	r3, #0
 8034392:	f000 816d 	beq.w	8034670 <LoRaMacProcess+0x830>
        if( MacCtx.McpsConfirm.AckReceived == true )
 8034396:	f894 3440 	ldrb.w	r3, [r4, #1088]	; 0x440
 803439a:	b113      	cbz	r3, 80343a2 <LoRaMacProcess+0x562>
            OnAckTimeoutTimerEvent( NULL );
 803439c:	2000      	movs	r0, #0
 803439e:	f7fe fe33 	bl	8033008 <OnAckTimeoutTimerEvent>
    MacCtx.MacFlags.Bits.MacDone = 1;
 80343a2:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 80343a6:	f043 0320 	orr.w	r3, r3, #32
 80343aa:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
    UpdateRxSlotIdleState( );
 80343ae:	f7fe fde1 	bl	8032f74 <UpdateRxSlotIdleState>
 80343b2:	e5f6      	b.n	8033fa2 <LoRaMacProcess+0x162>
                    Nvm.MacGroup2.MacParams.ReceiveDelay1 = 1;
 80343b4:	2301      	movs	r3, #1
 80343b6:	e7bd      	b.n	8034334 <LoRaMacProcess+0x4f4>
                if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )
 80343b8:	2001      	movs	r0, #1
 80343ba:	f001 fc95 	bl	8035ce8 <LoRaMacConfirmQueueIsCmdActive>
 80343be:	2800      	cmp	r0, #0
 80343c0:	d0de      	beq.n	8034380 <LoRaMacProcess+0x540>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL, MLME_JOIN );
 80343c2:	2101      	movs	r1, #1
 80343c4:	2007      	movs	r0, #7
 80343c6:	e7d9      	b.n	803437c <LoRaMacProcess+0x53c>
 80343c8:	200055ec 	.word	0x200055ec
 80343cc:	20004f24 	.word	0x20004f24
            MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED;
 80343d0:	2301      	movs	r3, #1
 80343d2:	f884 3420 	strb.w	r3, [r4, #1056]	; 0x420
            getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 80343d6:	f894 3581 	ldrb.w	r3, [r4, #1409]	; 0x581
 80343da:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
            getPhy.Datarate = MacCtx.McpsIndication.RxDatarate;
 80343de:	f894 3424 	ldrb.w	r3, [r4, #1060]	; 0x424
 80343e2:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
            getPhy.Attribute = PHY_MAX_PAYLOAD;
 80343e6:	230d      	movs	r3, #13
 80343e8:	f88d 3020 	strb.w	r3, [sp, #32]
            if( Nvm.MacGroup2.MacParams.RepeaterSupport == true )
 80343ec:	f894 358c 	ldrb.w	r3, [r4, #1420]	; 0x58c
 80343f0:	b113      	cbz	r3, 80343f8 <LoRaMacProcess+0x5b8>
                getPhy.Attribute = PHY_MAX_PAYLOAD_REPEATER;
 80343f2:	230e      	movs	r3, #14
 80343f4:	f88d 3020 	strb.w	r3, [sp, #32]
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80343f8:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
 80343fc:	a908      	add	r1, sp, #32
 80343fe:	f002 f964 	bl	80366ca <RegionGetPhyParam>
            if( ( MAX( 0, ( int16_t )( ( int16_t ) size - ( int16_t ) LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE ) ) > ( int16_t )phyParam.Value ) ||
 8034402:	f1a5 030d 	sub.w	r3, r5, #13
 8034406:	b21b      	sxth	r3, r3
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034408:	9006      	str	r0, [sp, #24]
            if( ( MAX( 0, ( int16_t )( ( int16_t ) size - ( int16_t ) LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE ) ) > ( int16_t )phyParam.Value ) ||
 803440a:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 803440e:	b200      	sxth	r0, r0
 8034410:	4283      	cmp	r3, r0
 8034412:	f73f af5b 	bgt.w	80342cc <LoRaMacProcess+0x48c>
 8034416:	2d0b      	cmp	r5, #11
 8034418:	f67f af58 	bls.w	80342cc <LoRaMacProcess+0x48c>
            macMsgData.FRMPayload = MacCtx.RxPayload;
 803441c:	4bb9      	ldr	r3, [pc, #740]	; (8034704 <LoRaMacProcess+0x8c4>)
 803441e:	9321      	str	r3, [sp, #132]	; 0x84
            if( LORAMAC_PARSER_SUCCESS != LoRaMacParserData( &macMsgData ) )
 8034420:	a818      	add	r0, sp, #96	; 0x60
            macMsgData.FRMPayloadSize = LORAMAC_PHY_MAXPAYLOAD;
 8034422:	23ff      	movs	r3, #255	; 0xff
            macMsgData.Buffer = payload;
 8034424:	9618      	str	r6, [sp, #96]	; 0x60
            macMsgData.BufSize = size;
 8034426:	f88d 5064 	strb.w	r5, [sp, #100]	; 0x64
            macMsgData.FRMPayloadSize = LORAMAC_PHY_MAXPAYLOAD;
 803442a:	f88d 3088 	strb.w	r3, [sp, #136]	; 0x88
            if( LORAMAC_PARSER_SUCCESS != LoRaMacParserData( &macMsgData ) )
 803442e:	f002 f843 	bl	80364b8 <LoRaMacParserData>
 8034432:	4606      	mov	r6, r0
 8034434:	2800      	cmp	r0, #0
 8034436:	f47f af49 	bne.w	80342cc <LoRaMacProcess+0x48c>
    if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen > 0 ) && ( macMsg->FPort > 0 ) )
 803443a:	f89d 306c 	ldrb.w	r3, [sp, #108]	; 0x6c
            MacCtx.McpsIndication.DevAddress = macMsgData.FHDR.DevAddr;
 803443e:	991a      	ldr	r1, [sp, #104]	; 0x68
 8034440:	f8c4 1434 	str.w	r1, [r4, #1076]	; 0x434
    if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen > 0 ) && ( macMsg->FPort > 0 ) )
 8034444:	f013 020f 	ands.w	r2, r3, #15
 8034448:	d003      	beq.n	8034452 <LoRaMacProcess+0x612>
 803444a:	f89d 0080 	ldrb.w	r0, [sp, #128]	; 0x80
 803444e:	2800      	cmp	r0, #0
 8034450:	d167      	bne.n	8034522 <LoRaMacProcess+0x6e2>
    else if( macMsg->FRMPayloadSize == 0 )
 8034452:	f89d 0088 	ldrb.w	r0, [sp, #136]	; 0x88
 8034456:	2800      	cmp	r0, #0
 8034458:	d065      	beq.n	8034526 <LoRaMacProcess+0x6e6>
    else if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen == 0 ) && ( macMsg->FPort == 0 ) )
 803445a:	2a00      	cmp	r2, #0
 803445c:	f47f af36 	bne.w	80342cc <LoRaMacProcess+0x48c>
 8034460:	f89d 2080 	ldrb.w	r2, [sp, #128]	; 0x80
        *fType = FRAME_TYPE_D;
 8034464:	2a00      	cmp	r2, #0
 8034466:	bf0c      	ite	eq
 8034468:	2502      	moveq	r5, #2
 803446a:	2503      	movne	r5, #3
            downLinkCounter = 0;
 803446c:	2200      	movs	r2, #0
 803446e:	9207      	str	r2, [sp, #28]
                if( ( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.Address == macMsgData.FHDR.DevAddr ) &&
 8034470:	f8d4 25e0 	ldr.w	r2, [r4, #1504]	; 0x5e0
 8034474:	4291      	cmp	r1, r2
 8034476:	d158      	bne.n	803452a <LoRaMacProcess+0x6ea>
 8034478:	f894 15de 	ldrb.w	r1, [r4, #1502]	; 0x5de
 803447c:	2900      	cmp	r1, #0
 803447e:	d054      	beq.n	803452a <LoRaMacProcess+0x6ea>
                    downLinkCounter = *( Nvm.MacGroup2.MulticastChannelList[i].DownLinkCounter );
 8034480:	f8d4 15fc 	ldr.w	r1, [r4, #1532]	; 0x5fc
                    addrID = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.GroupID;
 8034484:	f894 85df 	ldrb.w	r8, [r4, #1503]	; 0x5df
                    downLinkCounter = *( Nvm.MacGroup2.MulticastChannelList[i].DownLinkCounter );
 8034488:	6809      	ldr	r1, [r1, #0]
 803448a:	9107      	str	r1, [sp, #28]
                    if( Nvm.MacGroup2.DeviceClass == CLASS_C )
 803448c:	f894 1608 	ldrb.w	r1, [r4, #1544]	; 0x608
 8034490:	2902      	cmp	r1, #2
 8034492:	d102      	bne.n	803449a <LoRaMacProcess+0x65a>
                        MacCtx.RxStatus.RxSlot = RX_SLOT_WIN_CLASS_C_MULTICAST;
 8034494:	2103      	movs	r1, #3
 8034496:	f884 1483 	strb.w	r1, [r4, #1155]	; 0x483
            if( ( multicast == 1 ) && ( ( fType != FRAME_TYPE_D ) ||
 803449a:	2d03      	cmp	r5, #3
 803449c:	f47f af16 	bne.w	80342cc <LoRaMacProcess+0x48c>
                                        ( macMsgData.FHDR.FCtrl.Bits.Ack != 0 ) ||
 80344a0:	f013 0f60 	tst.w	r3, #96	; 0x60
 80344a4:	f47f af12 	bne.w	80342cc <LoRaMacProcess+0x48c>
 80344a8:	9203      	str	r2, [sp, #12]
 80344aa:	2601      	movs	r6, #1
            getPhy.Attribute = PHY_MAX_FCNT_GAP;
 80344ac:	2315      	movs	r3, #21
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80344ae:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
            getPhy.Attribute = PHY_MAX_FCNT_GAP;
 80344b2:	f88d 3020 	strb.w	r3, [sp, #32]
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80344b6:	a908      	add	r1, sp, #32
 80344b8:	f002 f907 	bl	80366ca <RegionGetPhyParam>
            macCryptoStatus = GetFCntDown( addrID, fType, &macMsgData, Nvm.MacGroup2.Version, phyParam.Value, &fCntID, &downLinkCounter );
 80344bc:	f894 761a 	ldrb.w	r7, [r4, #1562]	; 0x61a
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80344c0:	9006      	str	r0, [sp, #24]
    switch( addrID )
 80344c2:	f1b8 0f00 	cmp.w	r8, #0
 80344c6:	d033      	beq.n	8034530 <LoRaMacProcess+0x6f0>
 80344c8:	f1b8 0f01 	cmp.w	r8, #1
 80344cc:	d13c      	bne.n	8034548 <LoRaMacProcess+0x708>
            if( lrWanVersion.Fields.Minor == 1 )
 80344ce:	2f01      	cmp	r7, #1
 80344d0:	d130      	bne.n	8034534 <LoRaMacProcess+0x6f4>
                if( ( fType == FRAME_TYPE_A ) || ( fType == FRAME_TYPE_D ) )
 80344d2:	b38d      	cbz	r5, 8034538 <LoRaMacProcess+0x6f8>
                    *fCntID = A_FCNT_DOWN;
 80344d4:	2d03      	cmp	r5, #3
 80344d6:	bf14      	ite	ne
 80344d8:	4647      	movne	r7, r8
 80344da:	2702      	moveq	r7, #2
    return LoRaMacCryptoGetFCntDown( *fCntID, maxFCntGap, macMsg->FHDR.FCnt, currentDown );
 80344dc:	f8bd 206e 	ldrh.w	r2, [sp, #110]	; 0x6e
 80344e0:	f8bd 1018 	ldrh.w	r1, [sp, #24]
 80344e4:	ab07      	add	r3, sp, #28
 80344e6:	4638      	mov	r0, r7
 80344e8:	f001 fd6c 	bl	8035fc4 <LoRaMacCryptoGetFCntDown>
            if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS )
 80344ec:	b370      	cbz	r0, 803454c <LoRaMacProcess+0x70c>
                if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_FCNT_DUPLICATED )
 80344ee:	2807      	cmp	r0, #7
 80344f0:	d124      	bne.n	803453c <LoRaMacProcess+0x6fc>
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_REPEATED;
 80344f2:	2308      	movs	r3, #8
 80344f4:	f884 3421 	strb.w	r3, [r4, #1057]	; 0x421
                    if( ( Nvm.MacGroup2.Version.Fields.Minor == 0 ) && ( macHdr.Bits.MType == FRAME_TYPE_DATA_CONFIRMED_DOWN ) && ( Nvm.MacGroup1.LastRxMic == macMsgData.MIC ) )
 80344f8:	f894 361a 	ldrb.w	r3, [r4, #1562]	; 0x61a
 80344fc:	b95b      	cbnz	r3, 8034516 <LoRaMacProcess+0x6d6>
 80344fe:	f00b 03e0 	and.w	r3, fp, #224	; 0xe0
 8034502:	2ba0      	cmp	r3, #160	; 0xa0
 8034504:	d107      	bne.n	8034516 <LoRaMacProcess+0x6d6>
 8034506:	f8d4 2540 	ldr.w	r2, [r4, #1344]	; 0x540
 803450a:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 803450c:	429a      	cmp	r2, r3
 803450e:	d102      	bne.n	8034516 <LoRaMacProcess+0x6d6>
                        Nvm.MacGroup1.SrvAckRequested = true;
 8034510:	2301      	movs	r3, #1
 8034512:	f884 3546 	strb.w	r3, [r4, #1350]	; 0x546
                MacCtx.McpsIndication.DownLinkCounter = downLinkCounter;
 8034516:	9b07      	ldr	r3, [sp, #28]
 8034518:	f8c4 3430 	str.w	r3, [r4, #1072]	; 0x430
                PrepareRxDoneAbort( );
 803451c:	f7fe fd96 	bl	803304c <PrepareRxDoneAbort>
                return;
 8034520:	e53f      	b.n	8033fa2 <LoRaMacProcess+0x162>
        *fType = FRAME_TYPE_A;
 8034522:	4635      	mov	r5, r6
 8034524:	e7a2      	b.n	803446c <LoRaMacProcess+0x62c>
        *fType = FRAME_TYPE_B;
 8034526:	2501      	movs	r5, #1
 8034528:	e7a0      	b.n	803446c <LoRaMacProcess+0x62c>
 803452a:	f04f 0801 	mov.w	r8, #1
 803452e:	e7bd      	b.n	80344ac <LoRaMacProcess+0x66c>
    switch( addrID )
 8034530:	2704      	movs	r7, #4
 8034532:	e7d3      	b.n	80344dc <LoRaMacProcess+0x69c>
                *fCntID = FCNT_DOWN;
 8034534:	2703      	movs	r7, #3
 8034536:	e7d1      	b.n	80344dc <LoRaMacProcess+0x69c>
                    *fCntID = A_FCNT_DOWN;
 8034538:	2702      	movs	r7, #2
 803453a:	e7cf      	b.n	80344dc <LoRaMacProcess+0x69c>
                else if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_MAX_GAP_FCNT )
 803453c:	2808      	cmp	r0, #8
 803453e:	d103      	bne.n	8034548 <LoRaMacProcess+0x708>
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_TOO_MANY_FRAMES_LOSS;
 8034540:	230a      	movs	r3, #10
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 8034542:	f884 3421 	strb.w	r3, [r4, #1057]	; 0x421
 8034546:	e7e6      	b.n	8034516 <LoRaMacProcess+0x6d6>
 8034548:	2301      	movs	r3, #1
 803454a:	e7fa      	b.n	8034542 <LoRaMacProcess+0x702>
            macCryptoStatus = LoRaMacCryptoUnsecureMessage( addrID, address, fCntID, downLinkCounter, &macMsgData );
 803454c:	ab18      	add	r3, sp, #96	; 0x60
 803454e:	9300      	str	r3, [sp, #0]
 8034550:	9903      	ldr	r1, [sp, #12]
 8034552:	9b07      	ldr	r3, [sp, #28]
 8034554:	463a      	mov	r2, r7
 8034556:	4640      	mov	r0, r8
 8034558:	f001 fe04 	bl	8036164 <LoRaMacCryptoUnsecureMessage>
            if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS )
 803455c:	b120      	cbz	r0, 8034568 <LoRaMacProcess+0x728>
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_MIC_FAIL;
 803455e:	2802      	cmp	r0, #2
 8034560:	bf0c      	ite	eq
 8034562:	230b      	moveq	r3, #11
 8034564:	230c      	movne	r3, #12
 8034566:	e6b2      	b.n	80342ce <LoRaMacProcess+0x48e>
            MacCtx.McpsIndication.FramePending = macMsgData.FHDR.FCtrl.Bits.FPending;
 8034568:	f89d 306c 	ldrb.w	r3, [sp, #108]	; 0x6c
            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK;
 803456c:	f884 0421 	strb.w	r0, [r4, #1057]	; 0x421
            MacCtx.McpsIndication.FramePending = macMsgData.FHDR.FCtrl.Bits.FPending;
 8034570:	f3c3 1200 	ubfx	r2, r3, #4, #1
 8034574:	f884 2425 	strb.w	r2, [r4, #1061]	; 0x425
            MacCtx.McpsIndication.DownLinkCounter = downLinkCounter;
 8034578:	9a07      	ldr	r2, [sp, #28]
 803457a:	f8c4 2430 	str.w	r2, [r4, #1072]	; 0x430
            if( ( MacCtx.RxStatus.RxSlot == RX_SLOT_WIN_1 ) ||
 803457e:	f894 2483 	ldrb.w	r2, [r4, #1155]	; 0x483
            MacCtx.McpsIndication.Multicast = multicast;
 8034582:	f884 6422 	strb.w	r6, [r4, #1058]	; 0x422
            if( ( MacCtx.RxStatus.RxSlot == RX_SLOT_WIN_1 ) ||
 8034586:	2a01      	cmp	r2, #1
            MacCtx.McpsIndication.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;
 8034588:	f3c3 1340 	ubfx	r3, r3, #5, #1
                Nvm.MacGroup1.AdrAckCounter = 0;
 803458c:	bf98      	it	ls
 803458e:	f8c4 0534 	strls.w	r0, [r4, #1332]	; 0x534
            if( multicast == 1 )
 8034592:	2e01      	cmp	r6, #1
            MacCtx.McpsIndication.Buffer = NULL;
 8034594:	f8c4 0428 	str.w	r0, [r4, #1064]	; 0x428
            MacCtx.McpsIndication.BufferSize = 0;
 8034598:	f884 042c 	strb.w	r0, [r4, #1068]	; 0x42c
            MacCtx.McpsIndication.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;
 803459c:	f884 342e 	strb.w	r3, [r4, #1070]	; 0x42e
            MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;
 80345a0:	f884 043d 	strb.w	r0, [r4, #1085]	; 0x43d
            MacCtx.McpsConfirm.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;
 80345a4:	f884 3440 	strb.w	r3, [r4, #1088]	; 0x440
            if( multicast == 1 )
 80345a8:	d12b      	bne.n	8034602 <LoRaMacProcess+0x7c2>
                MacCtx.McpsIndication.McpsIndication = MCPS_MULTICAST;
 80345aa:	2302      	movs	r3, #2
    if( rxSlot == RX_SLOT_WIN_1 || rxSlot == RX_SLOT_WIN_2  )
 80345ac:	2a01      	cmp	r2, #1
                    MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED;
 80345ae:	f884 3420 	strb.w	r3, [r4, #1056]	; 0x420
            RemoveMacCommands( MacCtx.RxStatus.RxSlot, macMsgData.FHDR.FCtrl, MacCtx.McpsConfirm.McpsRequest );
 80345b2:	f894 143c 	ldrb.w	r1, [r4, #1084]	; 0x43c
 80345b6:	f89d 306c 	ldrb.w	r3, [sp, #108]	; 0x6c
    if( rxSlot == RX_SLOT_WIN_1 || rxSlot == RX_SLOT_WIN_2  )
 80345ba:	d805      	bhi.n	80345c8 <LoRaMacProcess+0x788>
        if( request == MCPS_CONFIRMED )
 80345bc:	2901      	cmp	r1, #1
 80345be:	d101      	bne.n	80345c4 <LoRaMacProcess+0x784>
            if( fCtrl.Bits.Ack == 1 )
 80345c0:	069b      	lsls	r3, r3, #26
 80345c2:	d501      	bpl.n	80345c8 <LoRaMacProcess+0x788>
                LoRaMacCommandsRemoveStickyAnsCmds( );
 80345c4:	f001 fa7c 	bl	8035ac0 <LoRaMacCommandsRemoveStickyAnsCmds>
            switch( fType )
 80345c8:	2d02      	cmp	r5, #2
 80345ca:	d02d      	beq.n	8034628 <LoRaMacProcess+0x7e8>
 80345cc:	2d03      	cmp	r5, #3
 80345ce:	d009      	beq.n	80345e4 <LoRaMacProcess+0x7a4>
 80345d0:	f89d 106c 	ldrb.w	r1, [sp, #108]	; 0x6c
 80345d4:	2d01      	cmp	r5, #1
                    ProcessMacCommands( macMsgData.FHDR.FOpts, 0, macMsgData.FHDR.FCtrl.Bits.FOptsLen, snr, MacCtx.RxStatus.RxSlot );
 80345d6:	464a      	mov	r2, r9
 80345d8:	f001 010f 	and.w	r1, r1, #15
 80345dc:	a81c      	add	r0, sp, #112	; 0x70
 80345de:	d027      	beq.n	8034630 <LoRaMacProcess+0x7f0>
 80345e0:	f7ff f950 	bl	8033884 <ProcessMacCommands.isra.0.constprop.0>
                    MacCtx.McpsIndication.Port = macMsgData.FPort;
 80345e4:	f89d 3080 	ldrb.w	r3, [sp, #128]	; 0x80
 80345e8:	f884 3423 	strb.w	r3, [r4, #1059]	; 0x423
                    MacCtx.McpsIndication.Buffer = macMsgData.FRMPayload;
 80345ec:	9b21      	ldr	r3, [sp, #132]	; 0x84
 80345ee:	f8c4 3428 	str.w	r3, [r4, #1064]	; 0x428
                    MacCtx.McpsIndication.BufferSize = macMsgData.FRMPayloadSize;
 80345f2:	f89d 3088 	ldrb.w	r3, [sp, #136]	; 0x88
 80345f6:	f884 342c 	strb.w	r3, [r4, #1068]	; 0x42c
                    MacCtx.McpsIndication.RxData = true;
 80345fa:	2301      	movs	r3, #1
 80345fc:	f884 342d 	strb.w	r3, [r4, #1069]	; 0x42d
                    break;
 8034600:	e01c      	b.n	803463c <LoRaMacProcess+0x7fc>
                if( macHdr.Bits.MType == FRAME_TYPE_DATA_CONFIRMED_DOWN )
 8034602:	f00b 03e0 	and.w	r3, fp, #224	; 0xe0
 8034606:	2ba0      	cmp	r3, #160	; 0xa0
 8034608:	d10a      	bne.n	8034620 <LoRaMacProcess+0x7e0>
                    if( Nvm.MacGroup2.Version.Fields.Minor == 0 )
 803460a:	f894 161a 	ldrb.w	r1, [r4, #1562]	; 0x61a
                    Nvm.MacGroup1.SrvAckRequested = true;
 803460e:	2301      	movs	r3, #1
 8034610:	f884 3546 	strb.w	r3, [r4, #1350]	; 0x546
                    if( Nvm.MacGroup2.Version.Fields.Minor == 0 )
 8034614:	2900      	cmp	r1, #0
 8034616:	d1c9      	bne.n	80345ac <LoRaMacProcess+0x76c>
                        Nvm.MacGroup1.LastRxMic = macMsgData.MIC;
 8034618:	9923      	ldr	r1, [sp, #140]	; 0x8c
 803461a:	f8c4 1540 	str.w	r1, [r4, #1344]	; 0x540
                    MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED;
 803461e:	e7c5      	b.n	80345ac <LoRaMacProcess+0x76c>
                    Nvm.MacGroup1.SrvAckRequested = false;
 8034620:	2300      	movs	r3, #0
 8034622:	f884 3546 	strb.w	r3, [r4, #1350]	; 0x546
 8034626:	e7c1      	b.n	80345ac <LoRaMacProcess+0x76c>
                    ProcessMacCommands( macMsgData.FRMPayload, 0, macMsgData.FRMPayloadSize, snr, MacCtx.RxStatus.RxSlot );
 8034628:	f89d 1088 	ldrb.w	r1, [sp, #136]	; 0x88
 803462c:	9821      	ldr	r0, [sp, #132]	; 0x84
 803462e:	464a      	mov	r2, r9
 8034630:	f7ff f928 	bl	8033884 <ProcessMacCommands.isra.0.constprop.0>
                    MacCtx.McpsIndication.Port = macMsgData.FPort;
 8034634:	f89d 3080 	ldrb.w	r3, [sp, #128]	; 0x80
 8034638:	f884 3423 	strb.w	r3, [r4, #1059]	; 0x423
            MacCtx.MacFlags.Bits.McpsInd = 1;
 803463c:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 8034640:	f043 0302 	orr.w	r3, r3, #2
 8034644:	e6a0      	b.n	8034388 <LoRaMacProcess+0x548>
            memcpy1( MacCtx.RxPayload, &payload[pktHeaderLen], size - pktHeaderLen );
 8034646:	4f2f      	ldr	r7, [pc, #188]	; (8034704 <LoRaMacProcess+0x8c4>)
 8034648:	3d01      	subs	r5, #1
 803464a:	b2aa      	uxth	r2, r5
 803464c:	1c71      	adds	r1, r6, #1
 803464e:	4638      	mov	r0, r7
 8034650:	f004 fc42 	bl	8038ed8 <memcpy1>
            MacCtx.McpsIndication.McpsIndication = MCPS_PROPRIETARY;
 8034654:	2303      	movs	r3, #3
 8034656:	f8a4 3420 	strh.w	r3, [r4, #1056]	; 0x420
            MacCtx.McpsIndication.Buffer = MacCtx.RxPayload;
 803465a:	f8c4 7428 	str.w	r7, [r4, #1064]	; 0x428
            MacCtx.McpsIndication.BufferSize = size - pktHeaderLen;
 803465e:	f884 542c 	strb.w	r5, [r4, #1068]	; 0x42c
            MacCtx.MacFlags.Bits.McpsInd = 1;
 8034662:	e7eb      	b.n	803463c <LoRaMacProcess+0x7fc>
            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 8034664:	2301      	movs	r3, #1
 8034666:	f884 3421 	strb.w	r3, [r4, #1057]	; 0x421
            PrepareRxDoneAbort( );
 803466a:	f7fe fcef 	bl	803304c <PrepareRxDoneAbort>
            break;
 803466e:	e68d      	b.n	803438c <LoRaMacProcess+0x54c>
        if( Nvm.MacGroup2.DeviceClass == CLASS_C )
 8034670:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 8034674:	2b02      	cmp	r3, #2
 8034676:	f47f ae94 	bne.w	80343a2 <LoRaMacProcess+0x562>
 803467a:	e68f      	b.n	803439c <LoRaMacProcess+0x55c>
    if( MacCtx.MacFlags.Bits.MlmeReq == 1 )
 803467c:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 8034680:	0759      	lsls	r1, r3, #29
 8034682:	d50f      	bpl.n	80346a4 <LoRaMacProcess+0x864>
        if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )
 8034684:	2001      	movs	r0, #1
 8034686:	f001 fb2f 	bl	8035ce8 <LoRaMacConfirmQueueIsCmdActive>
 803468a:	b380      	cbz	r0, 80346ee <LoRaMacProcess+0x8ae>
            if( LoRaMacConfirmQueueGetStatus( MLME_JOIN ) == LORAMAC_EVENT_INFO_STATUS_OK )
 803468c:	2001      	movs	r0, #1
 803468e:	f001 fb01 	bl	8035c94 <LoRaMacConfirmQueueGetStatus>
 8034692:	b908      	cbnz	r0, 8034698 <LoRaMacProcess+0x858>
                MacCtx.ChannelsNbTransCounter = 0;
 8034694:	f884 0414 	strb.w	r0, [r4, #1044]	; 0x414
            MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 8034698:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 803469c:	f023 0302 	bic.w	r3, r3, #2
 80346a0:	f8c4 3344 	str.w	r3, [r4, #836]	; 0x344
    if( MacCtx.MacFlags.Bits.McpsReq == 1 )
 80346a4:	f894 1485 	ldrb.w	r1, [r4, #1157]	; 0x485
 80346a8:	07ca      	lsls	r2, r1, #31
 80346aa:	f57f accf 	bpl.w	803404c <LoRaMacProcess+0x20c>
        if( ( MacCtx.McpsConfirm.McpsRequest == MCPS_UNCONFIRMED ) ||
 80346ae:	f894 343c 	ldrb.w	r3, [r4, #1084]	; 0x43c
 80346b2:	b10b      	cbz	r3, 80346b8 <LoRaMacProcess+0x878>
 80346b4:	2b03      	cmp	r3, #3
 80346b6:	d129      	bne.n	803470c <LoRaMacProcess+0x8cc>
    if( MacCtx.ChannelsNbTransCounter >=
 80346b8:	f894 2414 	ldrb.w	r2, [r4, #1044]	; 0x414
 80346bc:	f894 356c 	ldrb.w	r3, [r4, #1388]	; 0x56c
 80346c0:	429a      	cmp	r2, r3
 80346c2:	d208      	bcs.n	80346d6 <LoRaMacProcess+0x896>
    else if( MacCtx.MacFlags.Bits.McpsInd == 1 )
 80346c4:	078b      	lsls	r3, r1, #30
 80346c6:	d553      	bpl.n	8034770 <LoRaMacProcess+0x930>
        if( Nvm.MacGroup2.DeviceClass == CLASS_A )
 80346c8:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 80346cc:	b11b      	cbz	r3, 80346d6 <LoRaMacProcess+0x896>
            if( MacCtx.RxStatus.RxSlot == RX_SLOT_WIN_1 )
 80346ce:	f894 3483 	ldrb.w	r3, [r4, #1155]	; 0x483
 80346d2:	2b00      	cmp	r3, #0
 80346d4:	d14c      	bne.n	8034770 <LoRaMacProcess+0x930>
            TimerStop( &MacCtx.TxDelayedTimer );
 80346d6:	480c      	ldr	r0, [pc, #48]	; (8034708 <LoRaMacProcess+0x8c8>)
 80346d8:	f006 fe06 	bl	803b2e8 <UTIL_TIMER_Stop>
            MacCtx.MacState &= ~LORAMAC_TX_DELAYED;
 80346dc:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 80346e0:	f023 0320 	bic.w	r3, r3, #32
 80346e4:	f8c4 3344 	str.w	r3, [r4, #836]	; 0x344
            StopRetransmission( );
 80346e8:	f7fe fc50 	bl	8032f8c <StopRetransmission>
 80346ec:	e4ae      	b.n	803404c <LoRaMacProcess+0x20c>
        else if( ( LoRaMacConfirmQueueIsCmdActive( MLME_TXCW ) == true ) ||
 80346ee:	2005      	movs	r0, #5
 80346f0:	f001 fafa 	bl	8035ce8 <LoRaMacConfirmQueueIsCmdActive>
 80346f4:	2800      	cmp	r0, #0
 80346f6:	d1cf      	bne.n	8034698 <LoRaMacProcess+0x858>
                 ( LoRaMacConfirmQueueIsCmdActive( MLME_TXCW_1 ) == true ) )
 80346f8:	2006      	movs	r0, #6
 80346fa:	f001 faf5 	bl	8035ce8 <LoRaMacConfirmQueueIsCmdActive>
        else if( ( LoRaMacConfirmQueueIsCmdActive( MLME_TXCW ) == true ) ||
 80346fe:	2800      	cmp	r0, #0
 8034700:	d1ca      	bne.n	8034698 <LoRaMacProcess+0x858>
 8034702:	e7cf      	b.n	80346a4 <LoRaMacProcess+0x864>
 8034704:	20004ce0 	.word	0x20004ce0
 8034708:	20004e10 	.word	0x20004e10
        else if( MacCtx.McpsConfirm.McpsRequest == MCPS_CONFIRMED )
 803470c:	2b01      	cmp	r3, #1
 803470e:	d12f      	bne.n	8034770 <LoRaMacProcess+0x930>
            if( MacCtx.AckTimeoutRetry == true )
 8034710:	f894 2417 	ldrb.w	r2, [r4, #1047]	; 0x417
 8034714:	2a00      	cmp	r2, #0
 8034716:	f43f ac99 	beq.w	803404c <LoRaMacProcess+0x20c>
    if( MacCtx.AckTimeoutRetriesCounter >=
 803471a:	f894 3416 	ldrb.w	r3, [r4, #1046]	; 0x416
        MacCtx.AckTimeoutRetries )
 803471e:	f894 0415 	ldrb.w	r0, [r4, #1045]	; 0x415
    if( MacCtx.AckTimeoutRetriesCounter >=
 8034722:	4283      	cmp	r3, r0
 8034724:	d204      	bcs.n	8034730 <LoRaMacProcess+0x8f0>
    else if( MacCtx.MacFlags.Bits.McpsInd == 1 )
 8034726:	f011 0202 	ands.w	r2, r1, #2
        if( MacCtx.McpsConfirm.AckReceived == true )
 803472a:	bf18      	it	ne
 803472c:	f894 2440 	ldrbne.w	r2, [r4, #1088]	; 0x440
                if( Nvm.MacGroup2.Version.Fields.Minor == 0 )
 8034730:	f894 161a 	ldrb.w	r1, [r4, #1562]	; 0x61a
 8034734:	2900      	cmp	r1, #0
 8034736:	d13f      	bne.n	80347b8 <LoRaMacProcess+0x978>
                    if( stopRetransmission == false )
 8034738:	bb32      	cbnz	r2, 8034788 <LoRaMacProcess+0x948>
    if( MacCtx.AckTimeoutRetriesCounter < MacCtx.AckTimeoutRetries )
 803473a:	4283      	cmp	r3, r0
 803473c:	d218      	bcs.n	8034770 <LoRaMacProcess+0x930>
        MacCtx.AckTimeoutRetriesCounter++;
 803473e:	3301      	adds	r3, #1
 8034740:	b2db      	uxtb	r3, r3
        if( ( MacCtx.AckTimeoutRetriesCounter % 2 ) == 1 )
 8034742:	07df      	lsls	r7, r3, #31
        MacCtx.AckTimeoutRetriesCounter++;
 8034744:	f884 3416 	strb.w	r3, [r4, #1046]	; 0x416
        if( ( MacCtx.AckTimeoutRetriesCounter % 2 ) == 1 )
 8034748:	d512      	bpl.n	8034770 <LoRaMacProcess+0x930>
            getPhy.Attribute = PHY_NEXT_LOWER_TX_DR;
 803474a:	2322      	movs	r3, #34	; 0x22
 803474c:	f88d 3060 	strb.w	r3, [sp, #96]	; 0x60
            getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8034750:	f894 3580 	ldrb.w	r3, [r4, #1408]	; 0x580
 8034754:	f88d 3062 	strb.w	r3, [sp, #98]	; 0x62
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034758:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
            getPhy.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 803475c:	f894 3545 	ldrb.w	r3, [r4, #1349]	; 0x545
 8034760:	f88d 3061 	strb.w	r3, [sp, #97]	; 0x61
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034764:	a918      	add	r1, sp, #96	; 0x60
 8034766:	f001 ffb0 	bl	80366ca <RegionGetPhyParam>
 803476a:	900e      	str	r0, [sp, #56]	; 0x38
            Nvm.MacGroup1.ChannelsDatarate = phyParam.Value;
 803476c:	f884 0545 	strb.w	r0, [r4, #1349]	; 0x545
            MacCtx.MacFlags.Bits.MacDone = 0;
 8034770:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
            MacCtx.AckTimeoutRetry = false;
 8034774:	2000      	movs	r0, #0
            MacCtx.MacFlags.Bits.MacDone = 0;
 8034776:	f36f 1345 	bfc	r3, #5, #1
 803477a:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
            MacCtx.AckTimeoutRetry = false;
 803477e:	f884 0417 	strb.w	r0, [r4, #1047]	; 0x417
            OnTxDelayedTimerEvent( NULL );
 8034782:	f7fe ff71 	bl	8033668 <OnTxDelayedTimerEvent>
 8034786:	e461      	b.n	803404c <LoRaMacProcess+0x20c>
    if( MacCtx.McpsConfirm.AckReceived == false )
 8034788:	f894 5440 	ldrb.w	r5, [r4, #1088]	; 0x440
 803478c:	b97d      	cbnz	r5, 80347ae <LoRaMacProcess+0x96e>
        params.Type = INIT_TYPE_ACTIVATE_DEFAULT_CHANNELS;
 803478e:	2302      	movs	r3, #2
 8034790:	f88d 3068 	strb.w	r3, [sp, #104]	; 0x68
        params.NvmGroup1 = &Nvm.RegionGroup1;
 8034794:	4b0a      	ldr	r3, [pc, #40]	; (80347c0 <LoRaMacProcess+0x980>)
 8034796:	9318      	str	r3, [sp, #96]	; 0x60
        RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 8034798:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
        params.NvmGroup2 = &Nvm.RegionGroup2;
 803479c:	33a4      	adds	r3, #164	; 0xa4
        RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 803479e:	a918      	add	r1, sp, #96	; 0x60
        params.NvmGroup2 = &Nvm.RegionGroup2;
 80347a0:	9319      	str	r3, [sp, #100]	; 0x64
        RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 80347a2:	f001 ffad 	bl	8036700 <RegionInitDefaults>
        MacCtx.NodeAckRequested = false;
 80347a6:	f884 5418 	strb.w	r5, [r4, #1048]	; 0x418
        MacCtx.McpsConfirm.AckReceived = false;
 80347aa:	f884 5440 	strb.w	r5, [r4, #1088]	; 0x440
    MacCtx.McpsConfirm.NbRetries = MacCtx.AckTimeoutRetriesCounter;
 80347ae:	f894 3416 	ldrb.w	r3, [r4, #1046]	; 0x416
 80347b2:	f884 3441 	strb.w	r3, [r4, #1089]	; 0x441
        if( stopRetransmission == true )
 80347b6:	e78e      	b.n	80346d6 <LoRaMacProcess+0x896>
 80347b8:	2a00      	cmp	r2, #0
 80347ba:	d0d9      	beq.n	8034770 <LoRaMacProcess+0x930>
 80347bc:	e78b      	b.n	80346d6 <LoRaMacProcess+0x896>
 80347be:	bf00      	nop
 80347c0:	200051cc 	.word	0x200051cc

080347c4 <LoRaMacInitialization>:
    return 0;
}


LoRaMacStatus_t LoRaMacInitialization( LoRaMacPrimitives_t* primitives, LoRaMacCallback_t* callbacks, LoRaMacRegion_t region )
{
 80347c4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80347c8:	4688      	mov	r8, r1
 80347ca:	b08a      	sub	sp, #40	; 0x28
 80347cc:	4691      	mov	r9, r2
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;

    if( ( primitives == NULL ) ||
 80347ce:	4606      	mov	r6, r0
 80347d0:	2800      	cmp	r0, #0
 80347d2:	f000 8197 	beq.w	8034b04 <LoRaMacInitialization+0x340>
 80347d6:	2900      	cmp	r1, #0
 80347d8:	f000 8194 	beq.w	8034b04 <LoRaMacInitialization+0x340>
        ( callbacks == NULL ) )
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }

    if( ( primitives->MacMcpsConfirm == NULL ) ||
 80347dc:	6803      	ldr	r3, [r0, #0]
 80347de:	2b00      	cmp	r3, #0
 80347e0:	f000 8190 	beq.w	8034b04 <LoRaMacInitialization+0x340>
 80347e4:	6843      	ldr	r3, [r0, #4]
 80347e6:	2b00      	cmp	r3, #0
 80347e8:	f000 818c 	beq.w	8034b04 <LoRaMacInitialization+0x340>
        ( primitives->MacMcpsIndication == NULL ) ||
 80347ec:	6883      	ldr	r3, [r0, #8]
 80347ee:	2b00      	cmp	r3, #0
 80347f0:	f000 8188 	beq.w	8034b04 <LoRaMacInitialization+0x340>
        ( primitives->MacMlmeConfirm == NULL ) ||
 80347f4:	68c3      	ldr	r3, [r0, #12]
 80347f6:	2b00      	cmp	r3, #0
 80347f8:	f000 8184 	beq.w	8034b04 <LoRaMacInitialization+0x340>
        ( primitives->MacMlmeIndication == NULL ) )
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }
    // Verify if the region is supported
    if( RegionIsActive( region ) == false )
 80347fc:	4610      	mov	r0, r2
 80347fe:	f001 ff5b 	bl	80366b8 <RegionIsActive>
 8034802:	2800      	cmp	r0, #0
 8034804:	f000 8180 	beq.w	8034b08 <LoRaMacInitialization+0x344>

    // Confirm queue reset
    LoRaMacConfirmQueueInit( primitives );

    // Initialize the module context with zeros
    memset1( ( uint8_t* ) &Nvm, 0x00, sizeof( LoRaMacNvmData_t ) );
 8034808:	4cc1      	ldr	r4, [pc, #772]	; (8034b10 <LoRaMacInitialization+0x34c>)
    LoRaMacConfirmQueueInit( primitives );
 803480a:	4630      	mov	r0, r6
 803480c:	f001 f9e4 	bl	8035bd8 <LoRaMacConfirmQueueInit>
    memset1( ( uint8_t* ) &Nvm, 0x00, sizeof( LoRaMacNvmData_t ) );
 8034810:	f240 6254 	movw	r2, #1620	; 0x654
 8034814:	2100      	movs	r1, #0
 8034816:	f204 500c 	addw	r0, r4, #1292	; 0x50c
 803481a:	f004 fb71 	bl	8038f00 <memset1>
    memset1( ( uint8_t* ) &MacCtx, 0x00, sizeof( LoRaMacCtx_t ) );
 803481e:	f44f 62a1 	mov.w	r2, #1288	; 0x508
 8034822:	2100      	movs	r1, #0
 8034824:	1d20      	adds	r0, r4, #4
 8034826:	f004 fb6b 	bl	8038f00 <memset1>
    Nvm.MacGroup2.Region = region;
    Nvm.MacGroup2.DeviceClass = CLASS_A;
    Nvm.MacGroup2.MacParams.RepeaterSupport = false; /* ST_WORKAROUND: Keep repeater feature */

    // Setup version
    Nvm.MacGroup2.Version.Value = LORAMAC_VERSION;
 803482a:	4bba      	ldr	r3, [pc, #744]	; (8034b14 <LoRaMacInitialization+0x350>)
 803482c:	f8c4 3618 	str.w	r3, [r4, #1560]	; 0x618
    Nvm.MacGroup2.DeviceClass = CLASS_A;
 8034830:	2500      	movs	r5, #0
    MacCtx.AckTimeoutRetriesCounter = 1;
 8034832:	2701      	movs	r7, #1

    // Reset to defaults
    getPhy.Attribute = PHY_DUTY_CYCLE;
 8034834:	230f      	movs	r3, #15
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034836:	a905      	add	r1, sp, #20
 8034838:	4648      	mov	r0, r9
    getPhy.Attribute = PHY_DUTY_CYCLE;
 803483a:	f88d 3014 	strb.w	r3, [sp, #20]
    Nvm.MacGroup2.Region = region;
 803483e:	f884 954c 	strb.w	r9, [r4, #1356]	; 0x54c
    Nvm.MacGroup2.DeviceClass = CLASS_A;
 8034842:	f884 5608 	strb.w	r5, [r4, #1544]	; 0x608
    Nvm.MacGroup2.MacParams.RepeaterSupport = false; /* ST_WORKAROUND: Keep repeater feature */
 8034846:	f884 558c 	strb.w	r5, [r4, #1420]	; 0x58c
    MacCtx.AckTimeoutRetriesCounter = 1;
 803484a:	f884 7416 	strb.w	r7, [r4, #1046]	; 0x416
    MacCtx.AckTimeoutRetries = 1;
 803484e:	f884 7415 	strb.w	r7, [r4, #1045]	; 0x415
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034852:	f001 ff3a 	bl	80366ca <RegionGetPhyParam>
    Nvm.MacGroup2.DutyCycleOn = ( bool ) phyParam.Value;
 8034856:	1b40      	subs	r0, r0, r5
 8034858:	bf18      	it	ne
 803485a:	2001      	movne	r0, #1

    getPhy.Attribute = PHY_DEF_TX_POWER;
 803485c:	f04f 0a0a 	mov.w	sl, #10
    Nvm.MacGroup2.DutyCycleOn = ( bool ) phyParam.Value;
 8034860:	f884 060c 	strb.w	r0, [r4, #1548]	; 0x60c
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034864:	a905      	add	r1, sp, #20
 8034866:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_TX_POWER;
 803486a:	f88d a014 	strb.w	sl, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803486e:	f001 ff2c 	bl	80366ca <RegionGetPhyParam>
    Nvm.MacGroup2.ChannelsTxPowerDefault = phyParam.Value;

    getPhy.Attribute = PHY_DEF_TX_DR;
 8034872:	f04f 0906 	mov.w	r9, #6
    Nvm.MacGroup2.ChannelsTxPowerDefault = phyParam.Value;
 8034876:	f884 05d0 	strb.w	r0, [r4, #1488]	; 0x5d0
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803487a:	a905      	add	r1, sp, #20
 803487c:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_TX_DR;
 8034880:	f88d 9014 	strb.w	r9, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034884:	f001 ff21 	bl	80366ca <RegionGetPhyParam>
    Nvm.MacGroup2.ChannelsDatarateDefault = phyParam.Value;

    getPhy.Attribute = PHY_MAX_RX_WINDOW;
 8034888:	2310      	movs	r3, #16
    Nvm.MacGroup2.ChannelsDatarateDefault = phyParam.Value;
 803488a:	f884 05d1 	strb.w	r0, [r4, #1489]	; 0x5d1
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803488e:	a905      	add	r1, sp, #20
 8034890:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_MAX_RX_WINDOW;
 8034894:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034898:	f001 ff17 	bl	80366ca <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.MaxRxWindow = phyParam.Value;

    getPhy.Attribute = PHY_RECEIVE_DELAY1;
 803489c:	2311      	movs	r3, #17
    Nvm.MacGroup2.MacParamsDefaults.MaxRxWindow = phyParam.Value;
 803489e:	f8c4 0598 	str.w	r0, [r4, #1432]	; 0x598
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348a2:	a905      	add	r1, sp, #20
 80348a4:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_RECEIVE_DELAY1;
 80348a8:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348ac:	f001 ff0d 	bl	80366ca <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay1 = phyParam.Value;

    getPhy.Attribute = PHY_RECEIVE_DELAY2;
 80348b0:	2312      	movs	r3, #18
    Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay1 = phyParam.Value;
 80348b2:	f8c4 059c 	str.w	r0, [r4, #1436]	; 0x59c
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348b6:	a905      	add	r1, sp, #20
 80348b8:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_RECEIVE_DELAY2;
 80348bc:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348c0:	f001 ff03 	bl	80366ca <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay2 = phyParam.Value;

    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY1;
 80348c4:	2313      	movs	r3, #19
    Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay2 = phyParam.Value;
 80348c6:	f8c4 05a0 	str.w	r0, [r4, #1440]	; 0x5a0
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348ca:	a905      	add	r1, sp, #20
 80348cc:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY1;
 80348d0:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348d4:	f001 fef9 	bl	80366ca <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay1 = phyParam.Value;

    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY2;
 80348d8:	2314      	movs	r3, #20
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348da:	eb0d 0103 	add.w	r1, sp, r3
    Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay1 = phyParam.Value;
 80348de:	f8c4 05a4 	str.w	r0, [r4, #1444]	; 0x5a4
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348e2:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY2;
 80348e6:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348ea:	f001 feee 	bl	80366ca <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay2 = phyParam.Value;

    getPhy.Attribute = PHY_DEF_DR1_OFFSET;
 80348ee:	2317      	movs	r3, #23
    Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay2 = phyParam.Value;
 80348f0:	f8c4 05a8 	str.w	r0, [r4, #1448]	; 0x5a8
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348f4:	a905      	add	r1, sp, #20
 80348f6:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_DR1_OFFSET;
 80348fa:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80348fe:	f001 fee4 	bl	80366ca <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.Rx1DrOffset = phyParam.Value;

    getPhy.Attribute = PHY_DEF_RX2_FREQUENCY;
 8034902:	2318      	movs	r3, #24
    Nvm.MacGroup2.MacParamsDefaults.Rx1DrOffset = phyParam.Value;
 8034904:	f884 05ad 	strb.w	r0, [r4, #1453]	; 0x5ad
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034908:	a905      	add	r1, sp, #20
 803490a:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_RX2_FREQUENCY;
 803490e:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034912:	f001 feda 	bl	80366ca <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.Rx2Channel.Frequency = phyParam.Value;
    Nvm.MacGroup2.MacParamsDefaults.RxCChannel.Frequency = phyParam.Value;

    getPhy.Attribute = PHY_DEF_RX2_DR;
 8034916:	2319      	movs	r3, #25
    Nvm.MacGroup2.MacParamsDefaults.Rx2Channel.Frequency = phyParam.Value;
 8034918:	f8c4 05b0 	str.w	r0, [r4, #1456]	; 0x5b0
    Nvm.MacGroup2.MacParamsDefaults.RxCChannel.Frequency = phyParam.Value;
 803491c:	f8c4 05b8 	str.w	r0, [r4, #1464]	; 0x5b8
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034920:	a905      	add	r1, sp, #20
 8034922:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_RX2_DR;
 8034926:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803492a:	f001 fece 	bl	80366ca <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.Rx2Channel.Datarate = phyParam.Value;
 803492e:	b2c0      	uxtb	r0, r0
    Nvm.MacGroup2.MacParamsDefaults.RxCChannel.Datarate = phyParam.Value;

    getPhy.Attribute = PHY_DEF_UPLINK_DWELL_TIME;
 8034930:	231e      	movs	r3, #30
    Nvm.MacGroup2.MacParamsDefaults.Rx2Channel.Datarate = phyParam.Value;
 8034932:	f884 05b4 	strb.w	r0, [r4, #1460]	; 0x5b4
    Nvm.MacGroup2.MacParamsDefaults.RxCChannel.Datarate = phyParam.Value;
 8034936:	f884 05bc 	strb.w	r0, [r4, #1468]	; 0x5bc
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803493a:	a905      	add	r1, sp, #20
 803493c:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_UPLINK_DWELL_TIME;
 8034940:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034944:	f001 fec1 	bl	80366ca <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.UplinkDwellTime = phyParam.Value;

    getPhy.Attribute = PHY_DEF_DOWNLINK_DWELL_TIME;
 8034948:	231f      	movs	r3, #31
    Nvm.MacGroup2.MacParamsDefaults.UplinkDwellTime = phyParam.Value;
 803494a:	f884 05c0 	strb.w	r0, [r4, #1472]	; 0x5c0
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803494e:	a905      	add	r1, sp, #20
 8034950:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_DOWNLINK_DWELL_TIME;
 8034954:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034958:	f001 feb7 	bl	80366ca <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.DownlinkDwellTime = phyParam.Value;

    getPhy.Attribute = PHY_DEF_MAX_EIRP;
 803495c:	2320      	movs	r3, #32
    Nvm.MacGroup2.MacParamsDefaults.DownlinkDwellTime = phyParam.Value;
 803495e:	f884 05c1 	strb.w	r0, [r4, #1473]	; 0x5c1
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034962:	a905      	add	r1, sp, #20
 8034964:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_MAX_EIRP;
 8034968:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803496c:	f001 fead 	bl	80366ca <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.MaxEirp = phyParam.fValue;

    getPhy.Attribute = PHY_DEF_ANTENNA_GAIN;
 8034970:	2321      	movs	r3, #33	; 0x21
    Nvm.MacGroup2.MacParamsDefaults.MaxEirp = phyParam.fValue;
 8034972:	f8c4 05c4 	str.w	r0, [r4, #1476]	; 0x5c4
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034976:	a905      	add	r1, sp, #20
 8034978:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_ANTENNA_GAIN;
 803497c:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034980:	f001 fea3 	bl	80366ca <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.AntennaGain = phyParam.fValue;

    getPhy.Attribute = PHY_DEF_ADR_ACK_LIMIT;
 8034984:	230b      	movs	r3, #11
    Nvm.MacGroup2.MacParamsDefaults.AntennaGain = phyParam.fValue;
 8034986:	f8c4 05c8 	str.w	r0, [r4, #1480]	; 0x5c8
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803498a:	a905      	add	r1, sp, #20
 803498c:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_ADR_ACK_LIMIT;
 8034990:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034994:	f001 fe99 	bl	80366ca <RegionGetPhyParam>
    MacCtx.AdrAckLimit = phyParam.Value;

    getPhy.Attribute = PHY_DEF_ADR_ACK_DELAY;
 8034998:	230c      	movs	r3, #12
    MacCtx.AdrAckLimit = phyParam.Value;
 803499a:	f8a4 03f8 	strh.w	r0, [r4, #1016]	; 0x3f8
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 803499e:	a905      	add	r1, sp, #20
 80349a0:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_DEF_ADR_ACK_DELAY;
 80349a4:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80349a8:	f001 fe8f 	bl	80366ca <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError = 10;
    Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols = 6;

    Nvm.MacGroup2.MacParams.SystemMaxRxError = Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError;
    Nvm.MacGroup2.MacParams.MinRxSymbols = Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols;
    Nvm.MacGroup2.MacParams.MaxRxWindow = Nvm.MacGroup2.MacParamsDefaults.MaxRxWindow;
 80349ac:	f8d4 3598 	ldr.w	r3, [r4, #1432]	; 0x598
 80349b0:	f8c4 3558 	str.w	r3, [r4, #1368]	; 0x558
    Nvm.MacGroup2.MacParams.ReceiveDelay1 = Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay1;
 80349b4:	f8d4 359c 	ldr.w	r3, [r4, #1436]	; 0x59c
 80349b8:	f8c4 355c 	str.w	r3, [r4, #1372]	; 0x55c
    Nvm.MacGroup2.MacParams.ReceiveDelay2 = Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay2;
 80349bc:	f8d4 35a0 	ldr.w	r3, [r4, #1440]	; 0x5a0
 80349c0:	f8c4 3560 	str.w	r3, [r4, #1376]	; 0x560
    Nvm.MacGroup2.MacParams.JoinAcceptDelay1 = Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay1;
 80349c4:	f8d4 35a4 	ldr.w	r3, [r4, #1444]	; 0x5a4
 80349c8:	f8c4 3564 	str.w	r3, [r4, #1380]	; 0x564
    Nvm.MacGroup2.MacParams.JoinAcceptDelay2 = Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay2;
 80349cc:	f8d4 35a8 	ldr.w	r3, [r4, #1448]	; 0x5a8
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80349d0:	9004      	str	r0, [sp, #16]

    InitDefaultsParams_t params;
    params.Type = INIT_TYPE_DEFAULTS;
    params.NvmGroup1 = &Nvm.RegionGroup1;
    params.NvmGroup2 = &Nvm.RegionGroup2;
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 80349d2:	a907      	add	r1, sp, #28
    MacCtx.AdrAckDelay = phyParam.Value;
 80349d4:	f8a4 03fa 	strh.w	r0, [r4, #1018]	; 0x3fa
    Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols = 6;
 80349d8:	f884 9594 	strb.w	r9, [r4, #1428]	; 0x594
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 80349dc:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    Nvm.MacGroup2.MacParams.MinRxSymbols = Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols;
 80349e0:	f884 9554 	strb.w	r9, [r4, #1364]	; 0x554
    Nvm.MacGroup2.MacParams.JoinAcceptDelay2 = Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay2;
 80349e4:	f8c4 3568 	str.w	r3, [r4, #1384]	; 0x568
    params.NvmGroup1 = &Nvm.RegionGroup1;
 80349e8:	f504 69e5 	add.w	r9, r4, #1832	; 0x728
    params.NvmGroup2 = &Nvm.RegionGroup2;
 80349ec:	f204 73cc 	addw	r3, r4, #1996	; 0x7cc
 80349f0:	9308      	str	r3, [sp, #32]
    params.Type = INIT_TYPE_DEFAULTS;
 80349f2:	f88d 5024 	strb.w	r5, [sp, #36]	; 0x24
    Nvm.MacGroup2.MacParamsDefaults.ChannelsNbTrans = 1;
 80349f6:	f884 75ac 	strb.w	r7, [r4, #1452]	; 0x5ac
    Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError = 10;
 80349fa:	f8c4 a590 	str.w	sl, [r4, #1424]	; 0x590
    Nvm.MacGroup2.MacParams.SystemMaxRxError = Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError;
 80349fe:	f8c4 a550 	str.w	sl, [r4, #1360]	; 0x550
    Nvm.MacGroup2.MacParams.ChannelsNbTrans = Nvm.MacGroup2.MacParamsDefaults.ChannelsNbTrans;
 8034a02:	f884 756c 	strb.w	r7, [r4, #1388]	; 0x56c
    params.NvmGroup1 = &Nvm.RegionGroup1;
 8034a06:	f8cd 901c 	str.w	r9, [sp, #28]
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 8034a0a:	f001 fe79 	bl	8036700 <RegionInitDefaults>

    MacCtx.MacCallbacks = callbacks;
 8034a0e:	f8c4 834c 	str.w	r8, [r4, #844]	; 0x34c
    ResetMacParameters( );
 8034a12:	f7fe fc1b 	bl	803324c <ResetMacParameters>
    // Reset duty cycle times
    Nvm.MacGroup1.LastTxDoneTime = 0;
    Nvm.MacGroup1.AggregatedTimeOff = 0;

    // Initialize timers
    TimerInit( &MacCtx.TxDelayedTimer, OnTxDelayedTimerEvent );
 8034a16:	462a      	mov	r2, r5
 8034a18:	4b3f      	ldr	r3, [pc, #252]	; (8034b18 <LoRaMacInitialization+0x354>)
 8034a1a:	9500      	str	r5, [sp, #0]
 8034a1c:	f04f 31ff 	mov.w	r1, #4294967295
 8034a20:	f504 705b 	add.w	r0, r4, #876	; 0x36c
    MacCtx.MacPrimitives = primitives;
 8034a24:	f8c4 6348 	str.w	r6, [r4, #840]	; 0x348
    MacCtx.MacFlags.Value = 0;
 8034a28:	f884 5485 	strb.w	r5, [r4, #1157]	; 0x485
    Nvm.MacGroup1.LastTxDoneTime = 0;
 8034a2c:	f8c4 5538 	str.w	r5, [r4, #1336]	; 0x538
    Nvm.MacGroup1.AggregatedTimeOff = 0;
 8034a30:	f8c4 553c 	str.w	r5, [r4, #1340]	; 0x53c
    Nvm.MacGroup2.PublicNetwork = true;
 8034a34:	f884 7609 	strb.w	r7, [r4, #1545]	; 0x609
    MacCtx.MacState = LORAMAC_STOPPED;
 8034a38:	f8c4 7344 	str.w	r7, [r4, #836]	; 0x344
    TimerInit( &MacCtx.TxDelayedTimer, OnTxDelayedTimerEvent );
 8034a3c:	f006 fbf6 	bl	803b22c <UTIL_TIMER_Create>
    TimerInit( &MacCtx.RxWindowTimer1, OnRxWindow1TimerEvent );
 8034a40:	462a      	mov	r2, r5
 8034a42:	4b36      	ldr	r3, [pc, #216]	; (8034b1c <LoRaMacInitialization+0x358>)
 8034a44:	9500      	str	r5, [sp, #0]
 8034a46:	f04f 31ff 	mov.w	r1, #4294967295
 8034a4a:	f504 7061 	add.w	r0, r4, #900	; 0x384
 8034a4e:	f006 fbed 	bl	803b22c <UTIL_TIMER_Create>
    TimerInit( &MacCtx.RxWindowTimer2, OnRxWindow2TimerEvent );
 8034a52:	462a      	mov	r2, r5
 8034a54:	4b32      	ldr	r3, [pc, #200]	; (8034b20 <LoRaMacInitialization+0x35c>)
 8034a56:	9500      	str	r5, [sp, #0]
 8034a58:	f04f 31ff 	mov.w	r1, #4294967295
 8034a5c:	f504 7067 	add.w	r0, r4, #924	; 0x39c
 8034a60:	f006 fbe4 	bl	803b22c <UTIL_TIMER_Create>
    TimerInit( &MacCtx.AckTimeoutTimer, OnAckTimeoutTimerEvent );
 8034a64:	462a      	mov	r2, r5
 8034a66:	4b2f      	ldr	r3, [pc, #188]	; (8034b24 <LoRaMacInitialization+0x360>)
 8034a68:	9500      	str	r5, [sp, #0]
 8034a6a:	f04f 31ff 	mov.w	r1, #4294967295

    // Store the current initialization time
    Nvm.MacGroup2.InitializationTime = SysTimeGetMcuTime( );
 8034a6e:	ad02      	add	r5, sp, #8
    TimerInit( &MacCtx.AckTimeoutTimer, OnAckTimeoutTimerEvent );
 8034a70:	f504 707f 	add.w	r0, r4, #1020	; 0x3fc
 8034a74:	f006 fbda 	bl	803b22c <UTIL_TIMER_Create>
    Nvm.MacGroup2.InitializationTime = SysTimeGetMcuTime( );
 8034a78:	4628      	mov	r0, r5
 8034a7a:	f006 fb6d 	bl	803b158 <SysTimeGetMcuTime>
 8034a7e:	e895 0003 	ldmia.w	r5, {r0, r1}
 8034a82:	f504 63c2 	add.w	r3, r4, #1552	; 0x610
 8034a86:	e883 0003 	stmia.w	r3, {r0, r1}

    // Initialize Radio driver
    MacCtx.RadioEvents.TxDone = OnRadioTxDone;
 8034a8a:	4b27      	ldr	r3, [pc, #156]	; (8034b28 <LoRaMacInitialization+0x364>)
 8034a8c:	f8c4 3350 	str.w	r3, [r4, #848]	; 0x350
    MacCtx.RadioEvents.RxDone = OnRadioRxDone;
 8034a90:	4b26      	ldr	r3, [pc, #152]	; (8034b2c <LoRaMacInitialization+0x368>)
 8034a92:	f8c4 3358 	str.w	r3, [r4, #856]	; 0x358
    MacCtx.RadioEvents.RxError = OnRadioRxError;
 8034a96:	4b26      	ldr	r3, [pc, #152]	; (8034b30 <LoRaMacInitialization+0x36c>)
 8034a98:	f8c4 3360 	str.w	r3, [r4, #864]	; 0x360
    MacCtx.RadioEvents.TxTimeout = OnRadioTxTimeout;
    MacCtx.RadioEvents.RxTimeout = OnRadioRxTimeout;
    Radio.Init( &MacCtx.RadioEvents );
 8034a9c:	4e25      	ldr	r6, [pc, #148]	; (8034b34 <LoRaMacInitialization+0x370>)
    MacCtx.RadioEvents.TxTimeout = OnRadioTxTimeout;
 8034a9e:	4b26      	ldr	r3, [pc, #152]	; (8034b38 <LoRaMacInitialization+0x374>)
 8034aa0:	f8c4 3354 	str.w	r3, [r4, #852]	; 0x354
    MacCtx.RadioEvents.RxTimeout = OnRadioRxTimeout;
 8034aa4:	4b25      	ldr	r3, [pc, #148]	; (8034b3c <LoRaMacInitialization+0x378>)
 8034aa6:	f8c4 335c 	str.w	r3, [r4, #860]	; 0x35c
    Radio.Init( &MacCtx.RadioEvents );
 8034aaa:	f504 7054 	add.w	r0, r4, #848	; 0x350
 8034aae:	6833      	ldr	r3, [r6, #0]
 8034ab0:	4798      	blx	r3

    // Initialize the Secure Element driver
    if( SecureElementInit( &Nvm.SecureElement, callbacks->GetUniqueId ) != SECURE_ELEMENT_SUCCESS ) /* ST_WORKAROUND: Add unique ID callback as input parameter */
 8034ab2:	f8d8 1008 	ldr.w	r1, [r8, #8]
 8034ab6:	f204 6024 	addw	r0, r4, #1572	; 0x624
 8034aba:	f003 feeb 	bl	8038894 <SecureElementInit>
 8034abe:	b120      	cbz	r0, 8034aca <LoRaMacInitialization+0x306>
    {
        return LORAMAC_STATUS_CRYPTO_ERROR;
 8034ac0:	2511      	movs	r5, #17
    Radio.Sleep( );

    LoRaMacEnableRequests( LORAMAC_REQUEST_HANDLING_ON );

    return LORAMAC_STATUS_OK;
}
 8034ac2:	4628      	mov	r0, r5
 8034ac4:	b00a      	add	sp, #40	; 0x28
 8034ac6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if( LoRaMacCryptoInit( &Nvm.Crypto ) != LORAMAC_CRYPTO_SUCCESS )
 8034aca:	f5a9 7007 	sub.w	r0, r9, #540	; 0x21c
 8034ace:	f001 fa49 	bl	8035f64 <LoRaMacCryptoInit>
 8034ad2:	2800      	cmp	r0, #0
 8034ad4:	d1f4      	bne.n	8034ac0 <LoRaMacInitialization+0x2fc>
    if( LoRaMacCommandsInit( ) != LORAMAC_COMMANDS_SUCCESS )
 8034ad6:	f000 ff5d 	bl	8035994 <LoRaMacCommandsInit>
 8034ada:	b9b8      	cbnz	r0, 8034b0c <LoRaMacInitialization+0x348>
    if( LoRaMacCryptoSetMulticastReference( Nvm.MacGroup2.MulticastChannelList ) != LORAMAC_CRYPTO_SUCCESS )
 8034adc:	4818      	ldr	r0, [pc, #96]	; (8034b40 <LoRaMacInitialization+0x37c>)
 8034ade:	f001 faa7 	bl	8036030 <LoRaMacCryptoSetMulticastReference>
 8034ae2:	4605      	mov	r5, r0
 8034ae4:	2800      	cmp	r0, #0
 8034ae6:	d1eb      	bne.n	8034ac0 <LoRaMacInitialization+0x2fc>
    srand1( Radio.Random( ) );
 8034ae8:	6973      	ldr	r3, [r6, #20]
 8034aea:	4798      	blx	r3
 8034aec:	f004 f9d2 	bl	8038e94 <srand1>
    Radio.SetPublicNetwork( Nvm.MacGroup2.PublicNetwork );
 8034af0:	6db3      	ldr	r3, [r6, #88]	; 0x58
 8034af2:	f894 0609 	ldrb.w	r0, [r4, #1545]	; 0x609
 8034af6:	4798      	blx	r3
    Radio.Sleep( );
 8034af8:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8034afa:	4798      	blx	r3
    MacCtx.AllowRequests = requestState;
 8034afc:	2301      	movs	r3, #1
 8034afe:	f884 3486 	strb.w	r3, [r4, #1158]	; 0x486
    return LORAMAC_STATUS_OK;
 8034b02:	e7de      	b.n	8034ac2 <LoRaMacInitialization+0x2fe>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 8034b04:	2503      	movs	r5, #3
 8034b06:	e7dc      	b.n	8034ac2 <LoRaMacInitialization+0x2fe>
        return LORAMAC_STATUS_REGION_NOT_SUPPORTED;
 8034b08:	2509      	movs	r5, #9
 8034b0a:	e7da      	b.n	8034ac2 <LoRaMacInitialization+0x2fe>
        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 8034b0c:	2513      	movs	r5, #19
 8034b0e:	e7d8      	b.n	8034ac2 <LoRaMacInitialization+0x2fe>
 8034b10:	20004aa4 	.word	0x20004aa4
 8034b14:	01000300 	.word	0x01000300
 8034b18:	08033669 	.word	0x08033669
 8034b1c:	08033809 	.word	0x08033809
 8034b20:	08033841 	.word	0x08033841
 8034b24:	08033009 	.word	0x08033009
 8034b28:	080331f9 	.word	0x080331f9
 8034b2c:	080331a9 	.word	0x080331a9
 8034b30:	08032f59 	.word	0x08032f59
 8034b34:	0803bbd8 	.word	0x0803bbd8
 8034b38:	08033179 	.word	0x08033179
 8034b3c:	08033149 	.word	0x08033149
 8034b40:	20005080 	.word	0x20005080

08034b44 <LoRaMacStart>:

LoRaMacStatus_t LoRaMacStart( void )
{
    MacCtx.MacState = LORAMAC_IDLE;
 8034b44:	4b02      	ldr	r3, [pc, #8]	; (8034b50 <LoRaMacStart+0xc>)
 8034b46:	2000      	movs	r0, #0
 8034b48:	f8c3 0344 	str.w	r0, [r3, #836]	; 0x344
    return LORAMAC_STATUS_OK;
}
 8034b4c:	4770      	bx	lr
 8034b4e:	bf00      	nop
 8034b50:	20004aa4 	.word	0x20004aa4

08034b54 <LoRaMacQueryTxPossible>:
    }
    return LORAMAC_STATUS_BUSY;
}

LoRaMacStatus_t LoRaMacQueryTxPossible( uint8_t size, LoRaMacTxInfo_t* txInfo )
{
 8034b54:	b530      	push	{r4, r5, lr}
    CalcNextAdrParams_t adrNext;
    uint32_t adrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 8034b56:	4b2a      	ldr	r3, [pc, #168]	; (8034c00 <LoRaMacQueryTxPossible+0xac>)
{
 8034b58:	b089      	sub	sp, #36	; 0x24
 8034b5a:	4605      	mov	r5, r0
    int8_t datarate = Nvm.MacGroup2.ChannelsDatarateDefault;
 8034b5c:	f893 05d1 	ldrb.w	r0, [r3, #1489]	; 0x5d1
 8034b60:	f88d 0002 	strb.w	r0, [sp, #2]
    int8_t txPower = Nvm.MacGroup2.ChannelsTxPowerDefault;
 8034b64:	f893 05d0 	ldrb.w	r0, [r3, #1488]	; 0x5d0
    uint32_t adrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 8034b68:	f8d3 2534 	ldr.w	r2, [r3, #1332]	; 0x534
    int8_t txPower = Nvm.MacGroup2.ChannelsTxPowerDefault;
 8034b6c:	f88d 0003 	strb.w	r0, [sp, #3]
    size_t macCmdsSize = 0;
 8034b70:	2000      	movs	r0, #0
    uint32_t adrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 8034b72:	9201      	str	r2, [sp, #4]
    size_t macCmdsSize = 0;
 8034b74:	9002      	str	r0, [sp, #8]

    if( txInfo == NULL )
 8034b76:	460c      	mov	r4, r1
 8034b78:	2900      	cmp	r1, #0
 8034b7a:	d03c      	beq.n	8034bf6 <LoRaMacQueryTxPossible+0xa2>

    // Setup ADR request
    adrNext.Version = Nvm.MacGroup2.Version;
    adrNext.UpdateChanMask = false;
    adrNext.AdrEnabled = Nvm.MacGroup2.AdrCtrlOn;
    adrNext.AdrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 8034b7c:	9205      	str	r2, [sp, #20]
    adrNext.AdrAckLimit = MacCtx.AdrAckLimit;
 8034b7e:	f8d3 23f8 	ldr.w	r2, [r3, #1016]	; 0x3f8
 8034b82:	9206      	str	r2, [sp, #24]
    adrNext.AdrAckDelay = MacCtx.AdrAckDelay;
    adrNext.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 8034b84:	f8b3 2544 	ldrh.w	r2, [r3, #1348]	; 0x544
    adrNext.Version = Nvm.MacGroup2.Version;
 8034b88:	f8d3 1618 	ldr.w	r1, [r3, #1560]	; 0x618
 8034b8c:	9103      	str	r1, [sp, #12]
    adrNext.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 8034b8e:	ba52      	rev16	r2, r2
    adrNext.AdrEnabled = Nvm.MacGroup2.AdrCtrlOn;
 8034b90:	f893 160a 	ldrb.w	r1, [r3, #1546]	; 0x60a
    adrNext.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 8034b94:	f8ad 201c 	strh.w	r2, [sp, #28]
    adrNext.TxPower = Nvm.MacGroup1.ChannelsTxPower;
    adrNext.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8034b98:	f893 2580 	ldrb.w	r2, [r3, #1408]	; 0x580
    adrNext.Region = Nvm.MacGroup2.Region;
 8034b9c:	f893 354c 	ldrb.w	r3, [r3, #1356]	; 0x54c
    adrNext.UpdateChanMask = false;
 8034ba0:	f88d 0010 	strb.w	r0, [sp, #16]
    adrNext.AdrEnabled = Nvm.MacGroup2.AdrCtrlOn;
 8034ba4:	f88d 1011 	strb.w	r1, [sp, #17]
    adrNext.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8034ba8:	f88d 201e 	strb.w	r2, [sp, #30]
    adrNext.Region = Nvm.MacGroup2.Region;
 8034bac:	f88d 301f 	strb.w	r3, [sp, #31]

    // We call the function for information purposes only. We don't want to
    // apply the datarate, the tx power and the ADR ack counter.
    LoRaMacAdrCalcNext( &adrNext, &datarate, &txPower, &adrAckCounter );
 8034bb0:	f10d 0203 	add.w	r2, sp, #3
 8034bb4:	ab01      	add	r3, sp, #4
 8034bb6:	f10d 0102 	add.w	r1, sp, #2
 8034bba:	a803      	add	r0, sp, #12
 8034bbc:	f000 fe54 	bl	8035868 <LoRaMacAdrCalcNext>

    txInfo->CurrentPossiblePayloadSize = GetMaxAppPayloadWithoutFOptsLength( datarate );
 8034bc0:	f99d 0002 	ldrsb.w	r0, [sp, #2]
 8034bc4:	f7fe fa04 	bl	8032fd0 <GetMaxAppPayloadWithoutFOptsLength>
 8034bc8:	7060      	strb	r0, [r4, #1]

    if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )
 8034bca:	a802      	add	r0, sp, #8
 8034bcc:	f000 ff8a 	bl	8035ae4 <LoRaMacCommandsGetSizeSerializedCmds>
 8034bd0:	b998      	cbnz	r0, 8034bfa <LoRaMacQueryTxPossible+0xa6>
    {
        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
    }

    // Verify if the MAC commands fit into the FOpts and into the maximum payload.
    if( ( LORA_MAC_COMMAND_MAX_FOPTS_LENGTH >= macCmdsSize ) && ( txInfo->CurrentPossiblePayloadSize >= macCmdsSize ) )
 8034bd2:	9b02      	ldr	r3, [sp, #8]
 8034bd4:	2b0f      	cmp	r3, #15
 8034bd6:	d80a      	bhi.n	8034bee <LoRaMacQueryTxPossible+0x9a>
 8034bd8:	7862      	ldrb	r2, [r4, #1]
 8034bda:	4293      	cmp	r3, r2
 8034bdc:	d807      	bhi.n	8034bee <LoRaMacQueryTxPossible+0x9a>
    {
        txInfo->MaxPossibleApplicationDataSize = txInfo->CurrentPossiblePayloadSize - macCmdsSize;
 8034bde:	1ad1      	subs	r1, r2, r3

        // Verify if the application data together with MAC command fit into the maximum payload.
        if( txInfo->CurrentPossiblePayloadSize >= ( macCmdsSize + size ) )
 8034be0:	441d      	add	r5, r3
        txInfo->MaxPossibleApplicationDataSize = txInfo->CurrentPossiblePayloadSize - macCmdsSize;
 8034be2:	7021      	strb	r1, [r4, #0]
        {
            return LORAMAC_STATUS_OK;
        }
        else
        {
           return LORAMAC_STATUS_LENGTH_ERROR;
 8034be4:	42aa      	cmp	r2, r5
 8034be6:	bf38      	it	cc
 8034be8:	2008      	movcc	r0, #8
    else
    {
        txInfo->MaxPossibleApplicationDataSize = 0;
        return LORAMAC_STATUS_LENGTH_ERROR;
    }
}
 8034bea:	b009      	add	sp, #36	; 0x24
 8034bec:	bd30      	pop	{r4, r5, pc}
        txInfo->MaxPossibleApplicationDataSize = 0;
 8034bee:	2300      	movs	r3, #0
 8034bf0:	7023      	strb	r3, [r4, #0]
        return LORAMAC_STATUS_LENGTH_ERROR;
 8034bf2:	2008      	movs	r0, #8
 8034bf4:	e7f9      	b.n	8034bea <LoRaMacQueryTxPossible+0x96>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 8034bf6:	2003      	movs	r0, #3
 8034bf8:	e7f7      	b.n	8034bea <LoRaMacQueryTxPossible+0x96>
        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 8034bfa:	2013      	movs	r0, #19
 8034bfc:	e7f5      	b.n	8034bea <LoRaMacQueryTxPossible+0x96>
 8034bfe:	bf00      	nop
 8034c00:	20004aa4 	.word	0x20004aa4

08034c04 <LoRaMacMibGetRequestConfirm>:

LoRaMacStatus_t LoRaMacMibGetRequestConfirm( MibRequestConfirm_t* mibGet )
{
 8034c04:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;

    if( mibGet == NULL )
 8034c06:	4604      	mov	r4, r0
 8034c08:	2800      	cmp	r0, #0
 8034c0a:	f000 80a8 	beq.w	8034d5e <LoRaMacMibGetRequestConfirm+0x15a>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }

    switch( mibGet->Type )
 8034c0e:	7800      	ldrb	r0, [r0, #0]
 8034c10:	2828      	cmp	r0, #40	; 0x28
 8034c12:	f200 80a0 	bhi.w	8034d56 <LoRaMacMibGetRequestConfirm+0x152>
 8034c16:	e8df f000 	tbb	[pc, r0]
 8034c1a:	1b15      	.short	0x1b15
 8034c1c:	2c282520 	.word	0x2c282520
 8034c20:	9e9e9e31 	.word	0x9e9e9e31
 8034c24:	9e9e9e9e 	.word	0x9e9e9e9e
 8034c28:	3d39359e 	.word	0x3d39359e
 8034c2c:	54514e47 	.word	0x54514e47
 8034c30:	5f5b5759 	.word	0x5f5b5759
 8034c34:	6f6b6763 	.word	0x6f6b6763
 8034c38:	7b7f7773 	.word	0x7b7f7773
 8034c3c:	928b8783 	.word	0x928b8783
 8034c40:	9e90      	.short	0x9e90
 8034c42:	96          	.byte	0x96
 8034c43:	00          	.byte	0x00
    {
        case MIB_DEVICE_CLASS:
        {
            mibGet->Param.Class = Nvm.MacGroup2.DeviceClass;
 8034c44:	4b47      	ldr	r3, [pc, #284]	; (8034d64 <LoRaMacMibGetRequestConfirm+0x160>)
 8034c46:	f893 3608 	ldrb.w	r3, [r3, #1544]	; 0x608
 8034c4a:	7123      	strb	r3, [r4, #4]
            status = LoRaMacClassBMibGetRequestConfirm( mibGet );
            break;
        }
    }
    return status;
}
 8034c4c:	b004      	add	sp, #16
 8034c4e:	bd10      	pop	{r4, pc}
            mibGet->Param.NetworkActivation = Nvm.MacGroup2.NetworkActivation;
 8034c50:	4b44      	ldr	r3, [pc, #272]	; (8034d64 <LoRaMacMibGetRequestConfirm+0x160>)
 8034c52:	f893 361c 	ldrb.w	r3, [r3, #1564]	; 0x61c
            mibGet->Param.AdrEnable = Nvm.MacGroup2.AdrCtrlOn;
 8034c56:	7123      	strb	r3, [r4, #4]
            break;
 8034c58:	e002      	b.n	8034c60 <LoRaMacMibGetRequestConfirm+0x5c>
            mibGet->Param.DevEui = SecureElementGetDevEui( );
 8034c5a:	f004 f8ff 	bl	8038e5c <SecureElementGetDevEui>
            mibGet->Param.JoinEui = SecureElementGetJoinEui( );
 8034c5e:	6060      	str	r0, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 8034c60:	2000      	movs	r0, #0
            break;
 8034c62:	e7f3      	b.n	8034c4c <LoRaMacMibGetRequestConfirm+0x48>
            mibGet->Param.JoinEui = SecureElementGetJoinEui( );
 8034c64:	f004 f910 	bl	8038e88 <SecureElementGetJoinEui>
 8034c68:	e7f9      	b.n	8034c5e <LoRaMacMibGetRequestConfirm+0x5a>
            mibGet->Param.AdrEnable = Nvm.MacGroup2.AdrCtrlOn;
 8034c6a:	4b3e      	ldr	r3, [pc, #248]	; (8034d64 <LoRaMacMibGetRequestConfirm+0x160>)
 8034c6c:	f893 360a 	ldrb.w	r3, [r3, #1546]	; 0x60a
 8034c70:	e7f1      	b.n	8034c56 <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.NetID = Nvm.MacGroup2.NetID;
 8034c72:	4b3c      	ldr	r3, [pc, #240]	; (8034d64 <LoRaMacMibGetRequestConfirm+0x160>)
 8034c74:	f8d3 35d4 	ldr.w	r3, [r3, #1492]	; 0x5d4
            mibGet->Param.Contexts = GetNvmData( );
 8034c78:	6063      	str	r3, [r4, #4]
            break;
 8034c7a:	e7f1      	b.n	8034c60 <LoRaMacMibGetRequestConfirm+0x5c>
            mibGet->Param.DevAddr = Nvm.MacGroup2.DevAddr;
 8034c7c:	4b39      	ldr	r3, [pc, #228]	; (8034d64 <LoRaMacMibGetRequestConfirm+0x160>)
 8034c7e:	f8d3 35d8 	ldr.w	r3, [r3, #1496]	; 0x5d8
 8034c82:	e7f9      	b.n	8034c78 <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.EnablePublicNetwork = Nvm.MacGroup2.PublicNetwork;
 8034c84:	4b37      	ldr	r3, [pc, #220]	; (8034d64 <LoRaMacMibGetRequestConfirm+0x160>)
 8034c86:	f893 3609 	ldrb.w	r3, [r3, #1545]	; 0x609
 8034c8a:	e7e4      	b.n	8034c56 <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.EnableRepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport;
 8034c8c:	4b35      	ldr	r3, [pc, #212]	; (8034d64 <LoRaMacMibGetRequestConfirm+0x160>)
 8034c8e:	f893 358c 	ldrb.w	r3, [r3, #1420]	; 0x58c
 8034c92:	e7e0      	b.n	8034c56 <LoRaMacMibGetRequestConfirm+0x52>
            getPhy.Attribute = PHY_CHANNELS;
 8034c94:	231d      	movs	r3, #29
            getPhy.Attribute = PHY_CHANNELS_MASK;
 8034c96:	f88d 3008 	strb.w	r3, [sp, #8]
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8034c9a:	4b32      	ldr	r3, [pc, #200]	; (8034d64 <LoRaMacMibGetRequestConfirm+0x160>)
 8034c9c:	a902      	add	r1, sp, #8
 8034c9e:	f893 054c 	ldrb.w	r0, [r3, #1356]	; 0x54c
 8034ca2:	f001 fd12 	bl	80366ca <RegionGetPhyParam>
 8034ca6:	e7da      	b.n	8034c5e <LoRaMacMibGetRequestConfirm+0x5a>
            mibGet->Param.Rx2Channel = Nvm.MacGroup2.MacParams.Rx2Channel;
 8034ca8:	4b2f      	ldr	r3, [pc, #188]	; (8034d68 <LoRaMacMibGetRequestConfirm+0x164>)
 8034caa:	3404      	adds	r4, #4
            mibGet->Param.RxCChannel = Nvm.MacGroup2.MacParamsDefaults.RxCChannel;
 8034cac:	e893 0003 	ldmia.w	r3, {r0, r1}
 8034cb0:	e884 0003 	stmia.w	r4, {r0, r1}
            break;
 8034cb4:	e7d4      	b.n	8034c60 <LoRaMacMibGetRequestConfirm+0x5c>
            mibGet->Param.Rx2Channel = Nvm.MacGroup2.MacParamsDefaults.Rx2Channel;
 8034cb6:	4b2d      	ldr	r3, [pc, #180]	; (8034d6c <LoRaMacMibGetRequestConfirm+0x168>)
 8034cb8:	3404      	adds	r4, #4
 8034cba:	e7f7      	b.n	8034cac <LoRaMacMibGetRequestConfirm+0xa8>
            mibGet->Param.RxCChannel = Nvm.MacGroup2.MacParams.RxCChannel;
 8034cbc:	4b2c      	ldr	r3, [pc, #176]	; (8034d70 <LoRaMacMibGetRequestConfirm+0x16c>)
 8034cbe:	3404      	adds	r4, #4
 8034cc0:	e7f4      	b.n	8034cac <LoRaMacMibGetRequestConfirm+0xa8>
            mibGet->Param.RxCChannel = Nvm.MacGroup2.MacParamsDefaults.RxCChannel;
 8034cc2:	4b2c      	ldr	r3, [pc, #176]	; (8034d74 <LoRaMacMibGetRequestConfirm+0x170>)
 8034cc4:	3404      	adds	r4, #4
 8034cc6:	e7f1      	b.n	8034cac <LoRaMacMibGetRequestConfirm+0xa8>
            getPhy.Attribute = PHY_CHANNELS_DEFAULT_MASK;
 8034cc8:	231b      	movs	r3, #27
 8034cca:	e7e4      	b.n	8034c96 <LoRaMacMibGetRequestConfirm+0x92>
            getPhy.Attribute = PHY_CHANNELS_MASK;
 8034ccc:	231a      	movs	r3, #26
 8034cce:	e7e2      	b.n	8034c96 <LoRaMacMibGetRequestConfirm+0x92>
            mibGet->Param.ChannelsNbTrans = Nvm.MacGroup2.MacParams.ChannelsNbTrans;
 8034cd0:	4b24      	ldr	r3, [pc, #144]	; (8034d64 <LoRaMacMibGetRequestConfirm+0x160>)
 8034cd2:	f893 356c 	ldrb.w	r3, [r3, #1388]	; 0x56c
 8034cd6:	e7be      	b.n	8034c56 <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.MaxRxWindow = Nvm.MacGroup2.MacParams.MaxRxWindow;
 8034cd8:	4b22      	ldr	r3, [pc, #136]	; (8034d64 <LoRaMacMibGetRequestConfirm+0x160>)
 8034cda:	f8d3 3558 	ldr.w	r3, [r3, #1368]	; 0x558
 8034cde:	e7cb      	b.n	8034c78 <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.ReceiveDelay1 = Nvm.MacGroup2.MacParams.ReceiveDelay1;
 8034ce0:	4b20      	ldr	r3, [pc, #128]	; (8034d64 <LoRaMacMibGetRequestConfirm+0x160>)
 8034ce2:	f8d3 355c 	ldr.w	r3, [r3, #1372]	; 0x55c
 8034ce6:	e7c7      	b.n	8034c78 <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay2;
 8034ce8:	4b1e      	ldr	r3, [pc, #120]	; (8034d64 <LoRaMacMibGetRequestConfirm+0x160>)
 8034cea:	f8d3 3560 	ldr.w	r3, [r3, #1376]	; 0x560
 8034cee:	e7c3      	b.n	8034c78 <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.JoinAcceptDelay1 = Nvm.MacGroup2.MacParams.JoinAcceptDelay1;
 8034cf0:	4b1c      	ldr	r3, [pc, #112]	; (8034d64 <LoRaMacMibGetRequestConfirm+0x160>)
 8034cf2:	f8d3 3564 	ldr.w	r3, [r3, #1380]	; 0x564
 8034cf6:	e7bf      	b.n	8034c78 <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.JoinAcceptDelay2 = Nvm.MacGroup2.MacParams.JoinAcceptDelay2;
 8034cf8:	4b1a      	ldr	r3, [pc, #104]	; (8034d64 <LoRaMacMibGetRequestConfirm+0x160>)
 8034cfa:	f8d3 3568 	ldr.w	r3, [r3, #1384]	; 0x568
 8034cfe:	e7bb      	b.n	8034c78 <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.ChannelsDefaultDatarate = Nvm.MacGroup2.ChannelsDatarateDefault;
 8034d00:	4b18      	ldr	r3, [pc, #96]	; (8034d64 <LoRaMacMibGetRequestConfirm+0x160>)
 8034d02:	f893 35d1 	ldrb.w	r3, [r3, #1489]	; 0x5d1
 8034d06:	e7a6      	b.n	8034c56 <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.ChannelsDatarate = Nvm.MacGroup1.ChannelsDatarate;
 8034d08:	4b16      	ldr	r3, [pc, #88]	; (8034d64 <LoRaMacMibGetRequestConfirm+0x160>)
 8034d0a:	f893 3545 	ldrb.w	r3, [r3, #1349]	; 0x545
 8034d0e:	e7a2      	b.n	8034c56 <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.ChannelsDefaultTxPower = Nvm.MacGroup2.ChannelsTxPowerDefault;
 8034d10:	4b14      	ldr	r3, [pc, #80]	; (8034d64 <LoRaMacMibGetRequestConfirm+0x160>)
 8034d12:	f893 35d0 	ldrb.w	r3, [r3, #1488]	; 0x5d0
 8034d16:	e79e      	b.n	8034c56 <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.ChannelsTxPower = Nvm.MacGroup1.ChannelsTxPower;
 8034d18:	4b12      	ldr	r3, [pc, #72]	; (8034d64 <LoRaMacMibGetRequestConfirm+0x160>)
 8034d1a:	f893 3544 	ldrb.w	r3, [r3, #1348]	; 0x544
 8034d1e:	e79a      	b.n	8034c56 <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.SystemMaxRxError = Nvm.MacGroup2.MacParams.SystemMaxRxError;
 8034d20:	4b10      	ldr	r3, [pc, #64]	; (8034d64 <LoRaMacMibGetRequestConfirm+0x160>)
 8034d22:	f8d3 3550 	ldr.w	r3, [r3, #1360]	; 0x550
 8034d26:	e7a7      	b.n	8034c78 <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.MinRxSymbols = Nvm.MacGroup2.MacParams.MinRxSymbols;
 8034d28:	4b0e      	ldr	r3, [pc, #56]	; (8034d64 <LoRaMacMibGetRequestConfirm+0x160>)
 8034d2a:	f893 3554 	ldrb.w	r3, [r3, #1364]	; 0x554
 8034d2e:	e792      	b.n	8034c56 <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.AntennaGain = Nvm.MacGroup2.MacParams.AntennaGain;
 8034d30:	4b0c      	ldr	r3, [pc, #48]	; (8034d64 <LoRaMacMibGetRequestConfirm+0x160>)
 8034d32:	f8d3 3588 	ldr.w	r3, [r3, #1416]	; 0x588
            mibGet->Param.DefaultAntennaGain = Nvm.MacGroup2.MacParamsDefaults.AntennaGain;
 8034d36:	6063      	str	r3, [r4, #4]
            break;
 8034d38:	e792      	b.n	8034c60 <LoRaMacMibGetRequestConfirm+0x5c>
            mibGet->Param.Contexts = GetNvmData( );
 8034d3a:	4b0f      	ldr	r3, [pc, #60]	; (8034d78 <LoRaMacMibGetRequestConfirm+0x174>)
 8034d3c:	e79c      	b.n	8034c78 <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.DefaultAntennaGain = Nvm.MacGroup2.MacParamsDefaults.AntennaGain;
 8034d3e:	4b09      	ldr	r3, [pc, #36]	; (8034d64 <LoRaMacMibGetRequestConfirm+0x160>)
 8034d40:	f8d3 35c8 	ldr.w	r3, [r3, #1480]	; 0x5c8
 8034d44:	e7f7      	b.n	8034d36 <LoRaMacMibGetRequestConfirm+0x132>
            mibGet->Param.LrWanVersion.LoRaWan = Nvm.MacGroup2.Version;
 8034d46:	4b07      	ldr	r3, [pc, #28]	; (8034d64 <LoRaMacMibGetRequestConfirm+0x160>)
 8034d48:	f8d3 3618 	ldr.w	r3, [r3, #1560]	; 0x618
 8034d4c:	6063      	str	r3, [r4, #4]
            mibGet->Param.LrWanVersion.LoRaWanRegion = RegionGetVersion( );
 8034d4e:	f001 fdbb 	bl	80368c8 <RegionGetVersion>
 8034d52:	60a0      	str	r0, [r4, #8]
 8034d54:	e784      	b.n	8034c60 <LoRaMacMibGetRequestConfirm+0x5c>
            status = LoRaMacClassBMibGetRequestConfirm( mibGet );
 8034d56:	4620      	mov	r0, r4
 8034d58:	f000 fe0c 	bl	8035974 <LoRaMacClassBMibGetRequestConfirm>
            break;
 8034d5c:	e776      	b.n	8034c4c <LoRaMacMibGetRequestConfirm+0x48>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 8034d5e:	2003      	movs	r0, #3
 8034d60:	e774      	b.n	8034c4c <LoRaMacMibGetRequestConfirm+0x48>
 8034d62:	bf00      	nop
 8034d64:	20004aa4 	.word	0x20004aa4
 8034d68:	20005014 	.word	0x20005014
 8034d6c:	20005054 	.word	0x20005054
 8034d70:	2000501c 	.word	0x2000501c
 8034d74:	2000505c 	.word	0x2000505c
 8034d78:	20004fb0 	.word	0x20004fb0

08034d7c <LoRaMacMibSetRequestConfirm>:

LoRaMacStatus_t LoRaMacMibSetRequestConfirm( MibRequestConfirm_t* mibSet )
{
 8034d7c:	b573      	push	{r0, r1, r4, r5, r6, lr}
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
    ChanMaskSetParams_t chanMaskSet;
    VerifyParams_t verify;

    if( mibSet == NULL )
 8034d7e:	4604      	mov	r4, r0
 8034d80:	2800      	cmp	r0, #0
 8034d82:	d044      	beq.n	8034e0e <LoRaMacMibSetRequestConfirm+0x92>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }
    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 8034d84:	4da5      	ldr	r5, [pc, #660]	; (803501c <LoRaMacMibSetRequestConfirm+0x2a0>)
 8034d86:	f8d5 3344 	ldr.w	r3, [r5, #836]	; 0x344
 8034d8a:	079a      	lsls	r2, r3, #30
 8034d8c:	f100 8206 	bmi.w	803519c <LoRaMacMibSetRequestConfirm+0x420>
    {
        return LORAMAC_STATUS_BUSY;
    }

    switch( mibSet->Type )
 8034d90:	7802      	ldrb	r2, [r0, #0]
 8034d92:	2a27      	cmp	r2, #39	; 0x27
 8034d94:	f200 81ff 	bhi.w	8035196 <LoRaMacMibSetRequestConfirm+0x41a>
 8034d98:	e8df f012 	tbh	[pc, r2, lsl #1]
 8034d9c:	002d0028 	.word	0x002d0028
 8034da0:	003b0034 	.word	0x003b0034
 8034da4:	0043003f 	.word	0x0043003f
 8034da8:	004b0047 	.word	0x004b0047
 8034dac:	005a0055 	.word	0x005a0055
 8034db0:	0064005f 	.word	0x0064005f
 8034db4:	006e0069 	.word	0x006e0069
 8034db8:	00780073 	.word	0x00780073
 8034dbc:	01fd0081 	.word	0x01fd0081
 8034dc0:	00a40085 	.word	0x00a40085
 8034dc4:	00da00b5 	.word	0x00da00b5
 8034dc8:	00ec00fa 	.word	0x00ec00fa
 8034dcc:	010600fe 	.word	0x010600fe
 8034dd0:	010e010a 	.word	0x010e010a
 8034dd4:	01160112 	.word	0x01160112
 8034dd8:	012b011a 	.word	0x012b011a
 8034ddc:	014c015d 	.word	0x014c015d
 8034de0:	0174016e 	.word	0x0174016e
 8034de4:	017e017a 	.word	0x017e017a
 8034de8:	01f20182 	.word	0x01f20182
    {
        case MIB_DEVICE_CLASS:
        {
            status = SwitchClass( mibSet->Param.Class );
 8034dec:	7900      	ldrb	r0, [r0, #4]
 8034dee:	f7fe fc8b 	bl	8033708 <SwitchClass>
            status = LoRaMacMibClassBSetRequestConfirm( mibSet );
            break;
        }
    }
    return status;
}
 8034df2:	b002      	add	sp, #8
 8034df4:	bd70      	pop	{r4, r5, r6, pc}
            if( mibSet->Param.NetworkActivation != ACTIVATION_TYPE_OTAA  )
 8034df6:	7903      	ldrb	r3, [r0, #4]
 8034df8:	2b02      	cmp	r3, #2
 8034dfa:	d008      	beq.n	8034e0e <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup2.NetworkActivation = mibSet->Param.NetworkActivation;
 8034dfc:	f885 361c 	strb.w	r3, [r5, #1564]	; 0x61c
    return LORAMAC_STATUS_OK;
 8034e00:	2000      	movs	r0, #0
 8034e02:	e7f6      	b.n	8034df2 <LoRaMacMibSetRequestConfirm+0x76>
            if( SecureElementSetDevEui( mibSet->Param.DevEui ) != SECURE_ELEMENT_SUCCESS )
 8034e04:	6840      	ldr	r0, [r0, #4]
 8034e06:	f004 f81b 	bl	8038e40 <SecureElementSetDevEui>
 8034e0a:	2800      	cmp	r0, #0
 8034e0c:	d0f8      	beq.n	8034e00 <LoRaMacMibSetRequestConfirm+0x84>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 8034e0e:	2003      	movs	r0, #3
 8034e10:	e7ef      	b.n	8034df2 <LoRaMacMibSetRequestConfirm+0x76>
            if( SecureElementSetJoinEui( mibSet->Param.JoinEui ) != SECURE_ELEMENT_SUCCESS )
 8034e12:	6840      	ldr	r0, [r0, #4]
 8034e14:	f004 f828 	bl	8038e68 <SecureElementSetJoinEui>
 8034e18:	e7f7      	b.n	8034e0a <LoRaMacMibSetRequestConfirm+0x8e>
            Nvm.MacGroup2.AdrCtrlOn = mibSet->Param.AdrEnable;
 8034e1a:	7903      	ldrb	r3, [r0, #4]
 8034e1c:	f885 360a 	strb.w	r3, [r5, #1546]	; 0x60a
            break;
 8034e20:	e7ee      	b.n	8034e00 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.NetID = mibSet->Param.NetID;
 8034e22:	6843      	ldr	r3, [r0, #4]
 8034e24:	f8c5 35d4 	str.w	r3, [r5, #1492]	; 0x5d4
            break;
 8034e28:	e7ea      	b.n	8034e00 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.DevAddr = mibSet->Param.DevAddr;
 8034e2a:	6843      	ldr	r3, [r0, #4]
 8034e2c:	f8c5 35d8 	str.w	r3, [r5, #1496]	; 0x5d8
            break;
 8034e30:	e7e6      	b.n	8034e00 <LoRaMacMibSetRequestConfirm+0x84>
            if( mibSet->Param.AppKey != NULL )
 8034e32:	6841      	ldr	r1, [r0, #4]
 8034e34:	2900      	cmp	r1, #0
 8034e36:	d0ea      	beq.n	8034e0e <LoRaMacMibSetRequestConfirm+0x92>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( APP_KEY, mibSet->Param.AppKey ) )
 8034e38:	2000      	movs	r0, #0
 8034e3a:	f001 fa1f 	bl	803627c <LoRaMacCryptoSetKey>
 8034e3e:	2800      	cmp	r0, #0
 8034e40:	d0de      	beq.n	8034e00 <LoRaMacMibSetRequestConfirm+0x84>
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 8034e42:	2011      	movs	r0, #17
 8034e44:	e7d5      	b.n	8034df2 <LoRaMacMibSetRequestConfirm+0x76>
            if( mibSet->Param.NwkKey != NULL )
 8034e46:	6841      	ldr	r1, [r0, #4]
 8034e48:	2900      	cmp	r1, #0
 8034e4a:	d0e0      	beq.n	8034e0e <LoRaMacMibSetRequestConfirm+0x92>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( NWK_KEY, mibSet->Param.NwkKey ) )
 8034e4c:	2001      	movs	r0, #1
 8034e4e:	e7f4      	b.n	8034e3a <LoRaMacMibSetRequestConfirm+0xbe>
            if( mibSet->Param.NwkSKey != NULL )
 8034e50:	6841      	ldr	r1, [r0, #4]
 8034e52:	2900      	cmp	r1, #0
 8034e54:	d0db      	beq.n	8034e0e <LoRaMacMibSetRequestConfirm+0x92>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( NWK_S_KEY, mibSet->Param.NwkSKey ) )
 8034e56:	2002      	movs	r0, #2
 8034e58:	e7ef      	b.n	8034e3a <LoRaMacMibSetRequestConfirm+0xbe>
            if( mibSet->Param.AppSKey != NULL )
 8034e5a:	6841      	ldr	r1, [r0, #4]
 8034e5c:	2900      	cmp	r1, #0
 8034e5e:	d0d6      	beq.n	8034e0e <LoRaMacMibSetRequestConfirm+0x92>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( APP_S_KEY, mibSet->Param.AppSKey ) )
 8034e60:	2003      	movs	r0, #3
 8034e62:	e7ea      	b.n	8034e3a <LoRaMacMibSetRequestConfirm+0xbe>
            if( mibSet->Param.McKEKey != NULL )
 8034e64:	6841      	ldr	r1, [r0, #4]
 8034e66:	2900      	cmp	r1, #0
 8034e68:	d0d1      	beq.n	8034e0e <LoRaMacMibSetRequestConfirm+0x92>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KE_KEY, mibSet->Param.McKEKey ) )
 8034e6a:	207f      	movs	r0, #127	; 0x7f
 8034e6c:	e7e5      	b.n	8034e3a <LoRaMacMibSetRequestConfirm+0xbe>
            if( mibSet->Param.McKey0 != NULL )
 8034e6e:	6841      	ldr	r1, [r0, #4]
 8034e70:	2900      	cmp	r1, #0
 8034e72:	d0cc      	beq.n	8034e0e <LoRaMacMibSetRequestConfirm+0x92>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KEY_0, mibSet->Param.McKey0 ) )
 8034e74:	2080      	movs	r0, #128	; 0x80
 8034e76:	e7e0      	b.n	8034e3a <LoRaMacMibSetRequestConfirm+0xbe>
            if( mibSet->Param.McAppSKey0 != NULL )
 8034e78:	6841      	ldr	r1, [r0, #4]
 8034e7a:	2900      	cmp	r1, #0
 8034e7c:	d0c7      	beq.n	8034e0e <LoRaMacMibSetRequestConfirm+0x92>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_APP_S_KEY_0, mibSet->Param.McAppSKey0 ) )
 8034e7e:	2081      	movs	r0, #129	; 0x81
 8034e80:	e7db      	b.n	8034e3a <LoRaMacMibSetRequestConfirm+0xbe>
            if( mibSet->Param.McNwkSKey0 != NULL )
 8034e82:	6841      	ldr	r1, [r0, #4]
 8034e84:	2900      	cmp	r1, #0
 8034e86:	d0c2      	beq.n	8034e0e <LoRaMacMibSetRequestConfirm+0x92>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_NWK_S_KEY_0, mibSet->Param.McNwkSKey0 ) )
 8034e88:	2082      	movs	r0, #130	; 0x82
 8034e8a:	e7d6      	b.n	8034e3a <LoRaMacMibSetRequestConfirm+0xbe>
            Radio.SetPublicNetwork( Nvm.MacGroup2.PublicNetwork );
 8034e8c:	4c64      	ldr	r4, [pc, #400]	; (8035020 <LoRaMacMibSetRequestConfirm+0x2a4>)
            Nvm.MacGroup2.PublicNetwork = mibSet->Param.EnablePublicNetwork;
 8034e8e:	7900      	ldrb	r0, [r0, #4]
            Radio.SetPublicNetwork( Nvm.MacGroup2.PublicNetwork );
 8034e90:	6da3      	ldr	r3, [r4, #88]	; 0x58
            Nvm.MacGroup2.PublicNetwork = mibSet->Param.EnablePublicNetwork;
 8034e92:	f885 0609 	strb.w	r0, [r5, #1545]	; 0x609
            Radio.SetPublicNetwork( Nvm.MacGroup2.PublicNetwork );
 8034e96:	4798      	blx	r3
            Radio.Sleep( );
 8034e98:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8034e9a:	4798      	blx	r3
            break;
 8034e9c:	e7b0      	b.n	8034e00 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.RepeaterSupport = mibSet->Param.EnableRepeaterSupport;
 8034e9e:	7903      	ldrb	r3, [r0, #4]
 8034ea0:	f885 358c 	strb.w	r3, [r5, #1420]	; 0x58c
            break;
 8034ea4:	e7ac      	b.n	8034e00 <LoRaMacMibSetRequestConfirm+0x84>
            verify.DatarateParams.Datarate = mibSet->Param.Rx2Channel.Datarate;
 8034ea6:	7a03      	ldrb	r3, [r0, #8]
 8034ea8:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) != true )
 8034eac:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 8034eb0:	f895 3581 	ldrb.w	r3, [r5, #1409]	; 0x581
 8034eb4:	f88d 3001 	strb.w	r3, [sp, #1]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) != true )
 8034eb8:	2207      	movs	r2, #7
 8034eba:	4669      	mov	r1, sp
 8034ebc:	f001 fc2b 	bl	8036716 <RegionVerify>
 8034ec0:	2800      	cmp	r0, #0
 8034ec2:	d0a4      	beq.n	8034e0e <LoRaMacMibSetRequestConfirm+0x92>
                verify.Frequency = mibSet->Param.Rx2Channel.Frequency;
 8034ec4:	6863      	ldr	r3, [r4, #4]
                if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_FREQUENCY ) != true )
 8034ec6:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
                verify.Frequency = mibSet->Param.Rx2Channel.Frequency;
 8034eca:	9300      	str	r3, [sp, #0]
                if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_FREQUENCY ) != true )
 8034ecc:	2200      	movs	r2, #0
 8034ece:	4669      	mov	r1, sp
 8034ed0:	f001 fc21 	bl	8036716 <RegionVerify>
 8034ed4:	2800      	cmp	r0, #0
 8034ed6:	d09a      	beq.n	8034e0e <LoRaMacMibSetRequestConfirm+0x92>
                    Nvm.MacGroup2.MacParams.Rx2Channel = mibSet->Param.Rx2Channel;
 8034ed8:	4b52      	ldr	r3, [pc, #328]	; (8035024 <LoRaMacMibSetRequestConfirm+0x2a8>)
                Nvm.MacGroup2.MacParamsDefaults.Rx2Channel = mibSet->Param.Rx2DefaultChannel;
 8034eda:	e9d4 0101 	ldrd	r0, r1, [r4, #4]
 8034ede:	e883 0003 	stmia.w	r3, {r0, r1}
 8034ee2:	e78d      	b.n	8034e00 <LoRaMacMibSetRequestConfirm+0x84>
            verify.DatarateParams.Datarate = mibSet->Param.Rx2Channel.Datarate;
 8034ee4:	7a03      	ldrb	r3, [r0, #8]
 8034ee6:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 8034eea:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 8034eee:	f895 3581 	ldrb.w	r3, [r5, #1409]	; 0x581
 8034ef2:	f88d 3001 	strb.w	r3, [sp, #1]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 8034ef6:	2207      	movs	r2, #7
 8034ef8:	4669      	mov	r1, sp
 8034efa:	f001 fc0c 	bl	8036716 <RegionVerify>
 8034efe:	2800      	cmp	r0, #0
 8034f00:	d085      	beq.n	8034e0e <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup2.MacParamsDefaults.Rx2Channel = mibSet->Param.Rx2DefaultChannel;
 8034f02:	4b49      	ldr	r3, [pc, #292]	; (8035028 <LoRaMacMibSetRequestConfirm+0x2ac>)
 8034f04:	e7e9      	b.n	8034eda <LoRaMacMibSetRequestConfirm+0x15e>
            verify.DatarateParams.Datarate = mibSet->Param.RxCChannel.Datarate;
 8034f06:	7a03      	ldrb	r3, [r0, #8]
 8034f08:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 8034f0c:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 8034f10:	f895 3581 	ldrb.w	r3, [r5, #1409]	; 0x581
 8034f14:	f88d 3001 	strb.w	r3, [sp, #1]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 8034f18:	2207      	movs	r2, #7
 8034f1a:	4669      	mov	r1, sp
 8034f1c:	f001 fbfb 	bl	8036716 <RegionVerify>
 8034f20:	2800      	cmp	r0, #0
 8034f22:	f43f af74 	beq.w	8034e0e <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup2.MacParams.RxCChannel = mibSet->Param.RxCChannel;
 8034f26:	e9d4 0101 	ldrd	r0, r1, [r4, #4]
 8034f2a:	4b40      	ldr	r3, [pc, #256]	; (803502c <LoRaMacMibSetRequestConfirm+0x2b0>)
 8034f2c:	e883 0003 	stmia.w	r3, {r0, r1}
                if( ( Nvm.MacGroup2.DeviceClass == CLASS_C ) && ( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE ) )
 8034f30:	f895 3608 	ldrb.w	r3, [r5, #1544]	; 0x608
 8034f34:	2b02      	cmp	r3, #2
 8034f36:	f47f af63 	bne.w	8034e00 <LoRaMacMibSetRequestConfirm+0x84>
 8034f3a:	f895 361c 	ldrb.w	r3, [r5, #1564]	; 0x61c
 8034f3e:	2b00      	cmp	r3, #0
 8034f40:	f43f af5e 	beq.w	8034e00 <LoRaMacMibSetRequestConfirm+0x84>
                    Radio.Sleep( );
 8034f44:	4b36      	ldr	r3, [pc, #216]	; (8035020 <LoRaMacMibSetRequestConfirm+0x2a4>)
 8034f46:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8034f48:	4798      	blx	r3
                    OpenContinuousRxCWindow( );
 8034f4a:	f7fe fbb3 	bl	80336b4 <OpenContinuousRxCWindow>
 8034f4e:	e757      	b.n	8034e00 <LoRaMacMibSetRequestConfirm+0x84>
            verify.DatarateParams.Datarate = mibSet->Param.RxCChannel.Datarate;
 8034f50:	7a03      	ldrb	r3, [r0, #8]
 8034f52:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 8034f56:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 8034f5a:	f895 3581 	ldrb.w	r3, [r5, #1409]	; 0x581
 8034f5e:	f88d 3001 	strb.w	r3, [sp, #1]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 8034f62:	2207      	movs	r2, #7
 8034f64:	4669      	mov	r1, sp
 8034f66:	f001 fbd6 	bl	8036716 <RegionVerify>
 8034f6a:	2800      	cmp	r0, #0
 8034f6c:	f43f af4f 	beq.w	8034e0e <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup2.MacParamsDefaults.RxCChannel = mibSet->Param.RxCDefaultChannel;
 8034f70:	4b2f      	ldr	r3, [pc, #188]	; (8035030 <LoRaMacMibSetRequestConfirm+0x2b4>)
 8034f72:	e7b2      	b.n	8034eda <LoRaMacMibSetRequestConfirm+0x15e>
            chanMaskSet.ChannelsMaskIn = mibSet->Param.ChannelsDefaultMask;
 8034f74:	6843      	ldr	r3, [r0, #4]
 8034f76:	9300      	str	r3, [sp, #0]
            chanMaskSet.ChannelsMaskType = CHANNELS_DEFAULT_MASK;
 8034f78:	2301      	movs	r3, #1
            if( RegionChanMaskSet( Nvm.MacGroup2.Region, &chanMaskSet ) == false )
 8034f7a:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            chanMaskSet.ChannelsMaskType = CHANNELS_MASK;
 8034f7e:	f88d 3004 	strb.w	r3, [sp, #4]
            if( RegionChanMaskSet( Nvm.MacGroup2.Region, &chanMaskSet ) == false )
 8034f82:	4669      	mov	r1, sp
 8034f84:	f001 fbdf 	bl	8036746 <RegionChanMaskSet>
 8034f88:	2800      	cmp	r0, #0
 8034f8a:	f47f af39 	bne.w	8034e00 <LoRaMacMibSetRequestConfirm+0x84>
 8034f8e:	e73e      	b.n	8034e0e <LoRaMacMibSetRequestConfirm+0x92>
            chanMaskSet.ChannelsMaskIn = mibSet->Param.ChannelsMask;
 8034f90:	6843      	ldr	r3, [r0, #4]
 8034f92:	9300      	str	r3, [sp, #0]
            chanMaskSet.ChannelsMaskType = CHANNELS_MASK;
 8034f94:	2300      	movs	r3, #0
 8034f96:	e7f0      	b.n	8034f7a <LoRaMacMibSetRequestConfirm+0x1fe>
            if( ( mibSet->Param.ChannelsNbTrans >= 1 ) &&
 8034f98:	7903      	ldrb	r3, [r0, #4]
 8034f9a:	1e5a      	subs	r2, r3, #1
 8034f9c:	2a0e      	cmp	r2, #14
 8034f9e:	f63f af36 	bhi.w	8034e0e <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup2.MacParams.ChannelsNbTrans = mibSet->Param.ChannelsNbTrans;
 8034fa2:	f885 356c 	strb.w	r3, [r5, #1388]	; 0x56c
 8034fa6:	e72b      	b.n	8034e00 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.MaxRxWindow = mibSet->Param.MaxRxWindow;
 8034fa8:	6843      	ldr	r3, [r0, #4]
 8034faa:	f8c5 3558 	str.w	r3, [r5, #1368]	; 0x558
            break;
 8034fae:	e727      	b.n	8034e00 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.ReceiveDelay1 = mibSet->Param.ReceiveDelay1;
 8034fb0:	6843      	ldr	r3, [r0, #4]
 8034fb2:	f8c5 355c 	str.w	r3, [r5, #1372]	; 0x55c
            break;
 8034fb6:	e723      	b.n	8034e00 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.ReceiveDelay2 = mibSet->Param.ReceiveDelay2;
 8034fb8:	6843      	ldr	r3, [r0, #4]
 8034fba:	f8c5 3560 	str.w	r3, [r5, #1376]	; 0x560
            break;
 8034fbe:	e71f      	b.n	8034e00 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.JoinAcceptDelay1 = mibSet->Param.JoinAcceptDelay1;
 8034fc0:	6843      	ldr	r3, [r0, #4]
 8034fc2:	f8c5 3564 	str.w	r3, [r5, #1380]	; 0x564
            break;
 8034fc6:	e71b      	b.n	8034e00 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.JoinAcceptDelay2 = mibSet->Param.JoinAcceptDelay2;
 8034fc8:	6843      	ldr	r3, [r0, #4]
 8034fca:	f8c5 3568 	str.w	r3, [r5, #1384]	; 0x568
            break;
 8034fce:	e717      	b.n	8034e00 <LoRaMacMibSetRequestConfirm+0x84>
            verify.DatarateParams.Datarate = mibSet->Param.ChannelsDefaultDatarate;
 8034fd0:	7903      	ldrb	r3, [r0, #4]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_DR ) == true )
 8034fd2:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            verify.DatarateParams.Datarate = mibSet->Param.ChannelsDefaultDatarate;
 8034fd6:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_DR ) == true )
 8034fda:	2206      	movs	r2, #6
 8034fdc:	4669      	mov	r1, sp
 8034fde:	f001 fb9a 	bl	8036716 <RegionVerify>
 8034fe2:	2800      	cmp	r0, #0
 8034fe4:	f43f af13 	beq.w	8034e0e <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup2.ChannelsDatarateDefault = verify.DatarateParams.Datarate;
 8034fe8:	f89d 3000 	ldrb.w	r3, [sp]
 8034fec:	f885 35d1 	strb.w	r3, [r5, #1489]	; 0x5d1
 8034ff0:	e706      	b.n	8034e00 <LoRaMacMibSetRequestConfirm+0x84>
            verify.DatarateParams.Datarate = mibSet->Param.ChannelsDatarate;
 8034ff2:	7903      	ldrb	r3, [r0, #4]
 8034ff4:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_DR ) == true )
 8034ff8:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            verify.DatarateParams.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8034ffc:	f895 3580 	ldrb.w	r3, [r5, #1408]	; 0x580
 8035000:	f88d 3002 	strb.w	r3, [sp, #2]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_DR ) == true )
 8035004:	2205      	movs	r2, #5
 8035006:	4669      	mov	r1, sp
 8035008:	f001 fb85 	bl	8036716 <RegionVerify>
 803500c:	2800      	cmp	r0, #0
 803500e:	f43f aefe 	beq.w	8034e0e <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup1.ChannelsDatarate = verify.DatarateParams.Datarate;
 8035012:	f89d 3000 	ldrb.w	r3, [sp]
 8035016:	f885 3545 	strb.w	r3, [r5, #1349]	; 0x545
 803501a:	e6f1      	b.n	8034e00 <LoRaMacMibSetRequestConfirm+0x84>
 803501c:	20004aa4 	.word	0x20004aa4
 8035020:	0803bbd8 	.word	0x0803bbd8
 8035024:	20005014 	.word	0x20005014
 8035028:	20005054 	.word	0x20005054
 803502c:	2000501c 	.word	0x2000501c
 8035030:	2000505c 	.word	0x2000505c
            verify.TxPower = mibSet->Param.ChannelsDefaultTxPower;
 8035034:	7903      	ldrb	r3, [r0, #4]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_POWER ) == true )
 8035036:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            verify.TxPower = mibSet->Param.ChannelsDefaultTxPower;
 803503a:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_POWER ) == true )
 803503e:	220a      	movs	r2, #10
 8035040:	4669      	mov	r1, sp
 8035042:	f001 fb68 	bl	8036716 <RegionVerify>
 8035046:	2800      	cmp	r0, #0
 8035048:	f43f aee1 	beq.w	8034e0e <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup2.ChannelsTxPowerDefault = verify.TxPower;
 803504c:	f89d 3000 	ldrb.w	r3, [sp]
 8035050:	f885 35d0 	strb.w	r3, [r5, #1488]	; 0x5d0
 8035054:	e6d4      	b.n	8034e00 <LoRaMacMibSetRequestConfirm+0x84>
            verify.TxPower = mibSet->Param.ChannelsTxPower;
 8035056:	7903      	ldrb	r3, [r0, #4]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_POWER ) == true )
 8035058:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
            verify.TxPower = mibSet->Param.ChannelsTxPower;
 803505c:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_POWER ) == true )
 8035060:	2209      	movs	r2, #9
 8035062:	4669      	mov	r1, sp
 8035064:	f001 fb57 	bl	8036716 <RegionVerify>
 8035068:	2800      	cmp	r0, #0
 803506a:	f43f aed0 	beq.w	8034e0e <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup1.ChannelsTxPower = verify.TxPower;
 803506e:	f89d 3000 	ldrb.w	r3, [sp]
 8035072:	f885 3544 	strb.w	r3, [r5, #1348]	; 0x544
 8035076:	e6c3      	b.n	8034e00 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.SystemMaxRxError = Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError = mibSet->Param.SystemMaxRxError;
 8035078:	6843      	ldr	r3, [r0, #4]
 803507a:	f8c5 3590 	str.w	r3, [r5, #1424]	; 0x590
 803507e:	f8c5 3550 	str.w	r3, [r5, #1360]	; 0x550
            break;
 8035082:	e6bd      	b.n	8034e00 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.MinRxSymbols = Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols = mibSet->Param.MinRxSymbols;
 8035084:	7903      	ldrb	r3, [r0, #4]
 8035086:	f885 3594 	strb.w	r3, [r5, #1428]	; 0x594
 803508a:	f885 3554 	strb.w	r3, [r5, #1364]	; 0x554
            break;
 803508e:	e6b7      	b.n	8034e00 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParams.AntennaGain = mibSet->Param.AntennaGain;
 8035090:	6843      	ldr	r3, [r0, #4]
 8035092:	f8c5 3588 	str.w	r3, [r5, #1416]	; 0x588
            break;
 8035096:	e6b3      	b.n	8034e00 <LoRaMacMibSetRequestConfirm+0x84>
            Nvm.MacGroup2.MacParamsDefaults.AntennaGain = mibSet->Param.DefaultAntennaGain;
 8035098:	6843      	ldr	r3, [r0, #4]
 803509a:	f8c5 35c8 	str.w	r3, [r5, #1480]	; 0x5c8
            break;
 803509e:	e6af      	b.n	8034e00 <LoRaMacMibSetRequestConfirm+0x84>
            if( mibSet->Param.Contexts != 0 )
 80350a0:	6844      	ldr	r4, [r0, #4]
 80350a2:	2c00      	cmp	r4, #0
 80350a4:	f43f aeb3 	beq.w	8034e0e <LoRaMacMibSetRequestConfirm+0x92>
    if( MacCtx.MacState != LORAMAC_STOPPED )
 80350a8:	2b01      	cmp	r3, #1
 80350aa:	d177      	bne.n	803519c <LoRaMacMibSetRequestConfirm+0x420>
    crc = Crc32( ( uint8_t* ) &nvm->Crypto, sizeof( nvm->Crypto ) -
 80350ac:	2124      	movs	r1, #36	; 0x24
 80350ae:	4620      	mov	r0, r4
 80350b0:	f003 ff2e 	bl	8038f10 <Crc32>
    if( crc == nvm->Crypto.Crc32 )
 80350b4:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80350b6:	4298      	cmp	r0, r3
 80350b8:	d104      	bne.n	80350c4 <LoRaMacMibSetRequestConfirm+0x348>
        memcpy1( ( uint8_t* ) &Nvm.Crypto, ( uint8_t* ) &nvm->Crypto,
 80350ba:	4839      	ldr	r0, [pc, #228]	; (80351a0 <LoRaMacMibSetRequestConfirm+0x424>)
 80350bc:	2228      	movs	r2, #40	; 0x28
 80350be:	4621      	mov	r1, r4
 80350c0:	f003 ff0a 	bl	8038ed8 <memcpy1>
    crc = Crc32( ( uint8_t* ) &nvm->MacGroup1, sizeof( nvm->MacGroup1 ) -
 80350c4:	f104 0628 	add.w	r6, r4, #40	; 0x28
 80350c8:	2114      	movs	r1, #20
 80350ca:	4630      	mov	r0, r6
 80350cc:	f003 ff20 	bl	8038f10 <Crc32>
    if( crc == nvm->MacGroup1.Crc32 )
 80350d0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80350d2:	4298      	cmp	r0, r3
 80350d4:	d104      	bne.n	80350e0 <LoRaMacMibSetRequestConfirm+0x364>
        memcpy1( ( uint8_t* ) &Nvm.MacGroup1, ( uint8_t* ) &nvm->MacGroup1,
 80350d6:	4833      	ldr	r0, [pc, #204]	; (80351a4 <LoRaMacMibSetRequestConfirm+0x428>)
 80350d8:	2218      	movs	r2, #24
 80350da:	4631      	mov	r1, r6
 80350dc:	f003 fefc 	bl	8038ed8 <memcpy1>
    crc = Crc32( ( uint8_t* ) &nvm->MacGroup2, sizeof( nvm->MacGroup2 ) -
 80350e0:	f104 0640 	add.w	r6, r4, #64	; 0x40
 80350e4:	21d4      	movs	r1, #212	; 0xd4
 80350e6:	4630      	mov	r0, r6
 80350e8:	f003 ff12 	bl	8038f10 <Crc32>
    if( crc == nvm->MacGroup2.Crc32 )
 80350ec:	f8d4 3114 	ldr.w	r3, [r4, #276]	; 0x114
 80350f0:	4298      	cmp	r0, r3
 80350f2:	d114      	bne.n	803511e <LoRaMacMibSetRequestConfirm+0x3a2>
        memcpy1( ( uint8_t* ) &Nvm.MacGroup2, ( uint8_t* ) &nvm->MacGroup2,
 80350f4:	482c      	ldr	r0, [pc, #176]	; (80351a8 <LoRaMacMibSetRequestConfirm+0x42c>)
 80350f6:	22d8      	movs	r2, #216	; 0xd8
 80350f8:	4631      	mov	r1, r6
 80350fa:	f003 feed 	bl	8038ed8 <memcpy1>
        MacCtx.RxWindowCConfig.Channel = MacCtx.Channel;
 80350fe:	f895 3419 	ldrb.w	r3, [r5, #1049]	; 0x419
 8035102:	f885 33e4 	strb.w	r3, [r5, #996]	; 0x3e4
        MacCtx.RxWindowCConfig.Frequency = Nvm.MacGroup2.MacParams.RxCChannel.Frequency;
 8035106:	f8d5 3578 	ldr.w	r3, [r5, #1400]	; 0x578
 803510a:	f8c5 33e8 	str.w	r3, [r5, #1000]	; 0x3e8
        MacCtx.RxWindowCConfig.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 803510e:	f895 3581 	ldrb.w	r3, [r5, #1409]	; 0x581
 8035112:	f885 33f4 	strb.w	r3, [r5, #1012]	; 0x3f4
        MacCtx.RxWindowCConfig.RxContinuous = true;
 8035116:	f240 2301 	movw	r3, #513	; 0x201
 803511a:	f8a5 33f6 	strh.w	r3, [r5, #1014]	; 0x3f6
    crc = Crc32( ( uint8_t* ) &nvm->SecureElement, sizeof( nvm->SecureElement ) -
 803511e:	f504 758c 	add.w	r5, r4, #280	; 0x118
 8035122:	f44f 7180 	mov.w	r1, #256	; 0x100
 8035126:	4628      	mov	r0, r5
 8035128:	f003 fef2 	bl	8038f10 <Crc32>
    if( crc == nvm->SecureElement.Crc32 )
 803512c:	f8d4 3218 	ldr.w	r3, [r4, #536]	; 0x218
 8035130:	4298      	cmp	r0, r3
 8035132:	d105      	bne.n	8035140 <LoRaMacMibSetRequestConfirm+0x3c4>
        memcpy1( ( uint8_t* ) &Nvm.SecureElement,( uint8_t* ) &nvm->SecureElement,
 8035134:	481d      	ldr	r0, [pc, #116]	; (80351ac <LoRaMacMibSetRequestConfirm+0x430>)
 8035136:	f44f 7282 	mov.w	r2, #260	; 0x104
 803513a:	4629      	mov	r1, r5
 803513c:	f003 fecc 	bl	8038ed8 <memcpy1>
    crc = Crc32( ( uint8_t* ) &nvm->RegionGroup1, sizeof( nvm->RegionGroup1 ) -
 8035140:	f504 7507 	add.w	r5, r4, #540	; 0x21c
 8035144:	21a0      	movs	r1, #160	; 0xa0
 8035146:	4628      	mov	r0, r5
 8035148:	f003 fee2 	bl	8038f10 <Crc32>
    if( crc == nvm->RegionGroup1.Crc32 )
 803514c:	f8d4 32bc 	ldr.w	r3, [r4, #700]	; 0x2bc
 8035150:	4298      	cmp	r0, r3
 8035152:	d104      	bne.n	803515e <LoRaMacMibSetRequestConfirm+0x3e2>
        memcpy1( ( uint8_t* ) &Nvm.RegionGroup1,( uint8_t* ) &nvm->RegionGroup1,
 8035154:	4816      	ldr	r0, [pc, #88]	; (80351b0 <LoRaMacMibSetRequestConfirm+0x434>)
 8035156:	22a4      	movs	r2, #164	; 0xa4
 8035158:	4629      	mov	r1, r5
 803515a:	f003 febd 	bl	8038ed8 <memcpy1>
    crc = Crc32( ( uint8_t* ) &nvm->ClassB, sizeof( nvm->ClassB ) -
 803515e:	f204 653c 	addw	r5, r4, #1596	; 0x63c
 8035162:	2114      	movs	r1, #20
 8035164:	4628      	mov	r0, r5
 8035166:	f003 fed3 	bl	8038f10 <Crc32>
    if( crc == nvm->ClassB.Crc32 )
 803516a:	f8d4 3650 	ldr.w	r3, [r4, #1616]	; 0x650
 803516e:	4298      	cmp	r0, r3
 8035170:	f47f ae46 	bne.w	8034e00 <LoRaMacMibSetRequestConfirm+0x84>
        memcpy1( ( uint8_t* ) &Nvm.ClassB,( uint8_t* ) &nvm->ClassB,
 8035174:	480f      	ldr	r0, [pc, #60]	; (80351b4 <LoRaMacMibSetRequestConfirm+0x438>)
 8035176:	2218      	movs	r2, #24
 8035178:	4629      	mov	r1, r5
 803517a:	f003 fead 	bl	8038ed8 <memcpy1>
 803517e:	e63f      	b.n	8034e00 <LoRaMacMibSetRequestConfirm+0x84>
            if( mibSet->Param.AbpLrWanVersion.Fields.Minor <= 1 )
 8035180:	7983      	ldrb	r3, [r0, #6]
 8035182:	2b01      	cmp	r3, #1
 8035184:	f63f ae43 	bhi.w	8034e0e <LoRaMacMibSetRequestConfirm+0x92>
                Nvm.MacGroup2.Version = mibSet->Param.AbpLrWanVersion;
 8035188:	6843      	ldr	r3, [r0, #4]
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetLrWanVersion( mibSet->Param.AbpLrWanVersion ) )
 803518a:	6840      	ldr	r0, [r0, #4]
                Nvm.MacGroup2.Version = mibSet->Param.AbpLrWanVersion;
 803518c:	f8c5 3618 	str.w	r3, [r5, #1560]	; 0x618
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetLrWanVersion( mibSet->Param.AbpLrWanVersion ) )
 8035190:	f000 ff04 	bl	8035f9c <LoRaMacCryptoSetLrWanVersion>
 8035194:	e653      	b.n	8034e3e <LoRaMacMibSetRequestConfirm+0xc2>
            status = LoRaMacMibClassBSetRequestConfirm( mibSet );
 8035196:	f000 fbef 	bl	8035978 <LoRaMacMibClassBSetRequestConfirm>
            break;
 803519a:	e62a      	b.n	8034df2 <LoRaMacMibSetRequestConfirm+0x76>
        return LORAMAC_STATUS_BUSY;
 803519c:	2001      	movs	r0, #1
 803519e:	e628      	b.n	8034df2 <LoRaMacMibSetRequestConfirm+0x76>
 80351a0:	20004fb0 	.word	0x20004fb0
 80351a4:	20004fd8 	.word	0x20004fd8
 80351a8:	20004ff0 	.word	0x20004ff0
 80351ac:	200050c8 	.word	0x200050c8
 80351b0:	200051cc 	.word	0x200051cc
 80351b4:	200055ec 	.word	0x200055ec

080351b8 <LoRaMacMcChannelSetup>:
    return LORAMAC_STATUS_OK;
}

LoRaMacStatus_t LoRaMacMcChannelSetup( McChannelParams_t *channel )
{
    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 80351b8:	4b24      	ldr	r3, [pc, #144]	; (803524c <LoRaMacMcChannelSetup+0x94>)
 80351ba:	f8d3 2344 	ldr.w	r2, [r3, #836]	; 0x344
 80351be:	f012 0f02 	tst.w	r2, #2
{
 80351c2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80351c6:	4604      	mov	r4, r0
 80351c8:	4698      	mov	r8, r3
    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 80351ca:	d13b      	bne.n	8035244 <LoRaMacMcChannelSetup+0x8c>
    {
        return LORAMAC_STATUS_BUSY;
    }

    if( channel->GroupID >= LORAMAC_MAX_MC_CTX )
 80351cc:	78c7      	ldrb	r7, [r0, #3]
 80351ce:	2f00      	cmp	r7, #0
 80351d0:	d13a      	bne.n	8035248 <LoRaMacMcChannelSetup+0x90>
    {
        return LORAMAC_STATUS_MC_GROUP_UNDEFINED;
    }

    Nvm.MacGroup2.MulticastChannelList[channel->GroupID].ChannelParams = *channel;
 80351d2:	4606      	mov	r6, r0
 80351d4:	f203 55dc 	addw	r5, r3, #1500	; 0x5dc
 80351d8:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80351da:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80351dc:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
 80351e0:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}

    if( channel->IsRemotelySetup == true )
 80351e4:	7823      	ldrb	r3, [r4, #0]
#if ( LORAMAC_MAX_MC_CTX > 3 )
            , MC_KEY_3
#endif /* LORAMAC_MAX_MC_CTX > 3 */
        };
        /* ST_WORKAROUND_END */
        if( LoRaMacCryptoSetKey( mcKeys[channel->GroupID], channel->McKeys.McKeyE ) != LORAMAC_CRYPTO_SUCCESS )
 80351e6:	68a1      	ldr	r1, [r4, #8]
    if( channel->IsRemotelySetup == true )
 80351e8:	b313      	cbz	r3, 8035230 <LoRaMacMcChannelSetup+0x78>
        if( LoRaMacCryptoSetKey( mcKeys[channel->GroupID], channel->McKeys.McKeyE ) != LORAMAC_CRYPTO_SUCCESS )
 80351ea:	2080      	movs	r0, #128	; 0x80
 80351ec:	f001 f846 	bl	803627c <LoRaMacCryptoSetKey>
 80351f0:	b118      	cbz	r0, 80351fa <LoRaMacMcChannelSetup+0x42>
{
 80351f2:	2711      	movs	r7, #17
    }

    // Reset multicast channel downlink counter to initial value.
    *Nvm.MacGroup2.MulticastChannelList[channel->GroupID].DownLinkCounter = FCNT_DOWN_INITAL_VALUE;
    return LORAMAC_STATUS_OK;
}
 80351f4:	4638      	mov	r0, r7
 80351f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if( LoRaMacCryptoDeriveMcSessionKeyPair( channel->GroupID, channel->Address ) != LORAMAC_CRYPTO_SUCCESS )
 80351fa:	6861      	ldr	r1, [r4, #4]
 80351fc:	78e0      	ldrb	r0, [r4, #3]
 80351fe:	f001 f8c5 	bl	803638c <LoRaMacCryptoDeriveMcSessionKeyPair>
        if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( mcNwkSKeys[channel->GroupID], channel->McKeys.Session.McNwkSKey ) )
 8035202:	2800      	cmp	r0, #0
 8035204:	d1f5      	bne.n	80351f2 <LoRaMacMcChannelSetup+0x3a>
    if( channel->Class == CLASS_B )
 8035206:	7863      	ldrb	r3, [r4, #1]
 8035208:	2b01      	cmp	r3, #1
 803520a:	d107      	bne.n	803521c <LoRaMacMcChannelSetup+0x64>
        LoRaMacClassBSetMulticastPeriodicity( &Nvm.MacGroup2.MulticastChannelList[channel->GroupID] );
 803520c:	78e0      	ldrb	r0, [r4, #3]
 803520e:	4b10      	ldr	r3, [pc, #64]	; (8035250 <LoRaMacMcChannelSetup+0x98>)
 8035210:	222c      	movs	r2, #44	; 0x2c
 8035212:	fb02 3000 	mla	r0, r2, r0, r3
 8035216:	30d0      	adds	r0, #208	; 0xd0
 8035218:	f000 fbba 	bl	8035990 <LoRaMacClassBSetMulticastPeriodicity>
    *Nvm.MacGroup2.MulticastChannelList[channel->GroupID].DownLinkCounter = FCNT_DOWN_INITAL_VALUE;
 803521c:	78e3      	ldrb	r3, [r4, #3]
 803521e:	222c      	movs	r2, #44	; 0x2c
 8035220:	fb02 8803 	mla	r8, r2, r3, r8
 8035224:	f04f 32ff 	mov.w	r2, #4294967295
 8035228:	f8d8 35fc 	ldr.w	r3, [r8, #1532]	; 0x5fc
 803522c:	601a      	str	r2, [r3, #0]
    return LORAMAC_STATUS_OK;
 803522e:	e7e1      	b.n	80351f4 <LoRaMacMcChannelSetup+0x3c>
        if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( mcAppSKeys[channel->GroupID], channel->McKeys.Session.McAppSKey ) )
 8035230:	2081      	movs	r0, #129	; 0x81
 8035232:	f001 f823 	bl	803627c <LoRaMacCryptoSetKey>
 8035236:	2800      	cmp	r0, #0
 8035238:	d1db      	bne.n	80351f2 <LoRaMacMcChannelSetup+0x3a>
        if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( mcNwkSKeys[channel->GroupID], channel->McKeys.Session.McNwkSKey ) )
 803523a:	68e1      	ldr	r1, [r4, #12]
 803523c:	2082      	movs	r0, #130	; 0x82
 803523e:	f001 f81d 	bl	803627c <LoRaMacCryptoSetKey>
 8035242:	e7de      	b.n	8035202 <LoRaMacMcChannelSetup+0x4a>
        return LORAMAC_STATUS_BUSY;
 8035244:	2701      	movs	r7, #1
 8035246:	e7d5      	b.n	80351f4 <LoRaMacMcChannelSetup+0x3c>
        return LORAMAC_STATUS_MC_GROUP_UNDEFINED;
 8035248:	2716      	movs	r7, #22
 803524a:	e7d3      	b.n	80351f4 <LoRaMacMcChannelSetup+0x3c>
 803524c:	20004aa4 	.word	0x20004aa4
 8035250:	20004fb0 	.word	0x20004fb0

08035254 <LoRaMacMcChannelDelete>:

LoRaMacStatus_t LoRaMacMcChannelDelete( AddressIdentifier_t groupID )
{
 8035254:	b570      	push	{r4, r5, r6, lr}
    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 8035256:	4c10      	ldr	r4, [pc, #64]	; (8035298 <LoRaMacMcChannelDelete+0x44>)
 8035258:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 803525c:	079b      	lsls	r3, r3, #30
{
 803525e:	b088      	sub	sp, #32
 8035260:	4606      	mov	r6, r0
    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 8035262:	d414      	bmi.n	803528e <LoRaMacMcChannelDelete+0x3a>
    {
        return LORAMAC_STATUS_BUSY;
    }

    if( ( groupID >= LORAMAC_MAX_MC_CTX ) ||
 8035264:	b9a8      	cbnz	r0, 8035292 <LoRaMacMcChannelDelete+0x3e>
 8035266:	f894 35de 	ldrb.w	r3, [r4, #1502]	; 0x5de
 803526a:	b193      	cbz	r3, 8035292 <LoRaMacMcChannelDelete+0x3e>
    }

    McChannelParams_t channel;

    // Set all channel fields with 0
    memset1( ( uint8_t* )&channel, 0, sizeof( McChannelParams_t ) );
 803526c:	4601      	mov	r1, r0
 803526e:	2220      	movs	r2, #32
 8035270:	4668      	mov	r0, sp

    Nvm.MacGroup2.MulticastChannelList[groupID].ChannelParams = channel;
 8035272:	466d      	mov	r5, sp
    memset1( ( uint8_t* )&channel, 0, sizeof( McChannelParams_t ) );
 8035274:	f003 fe44 	bl	8038f00 <memset1>
    Nvm.MacGroup2.MulticastChannelList[groupID].ChannelParams = channel;
 8035278:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 803527a:	f204 54dc 	addw	r4, r4, #1500	; 0x5dc
 803527e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8035280:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8035284:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    return LORAMAC_STATUS_OK;
}
 8035288:	4630      	mov	r0, r6
 803528a:	b008      	add	sp, #32
 803528c:	bd70      	pop	{r4, r5, r6, pc}
        return LORAMAC_STATUS_BUSY;
 803528e:	2601      	movs	r6, #1
 8035290:	e7fa      	b.n	8035288 <LoRaMacMcChannelDelete+0x34>
        return LORAMAC_STATUS_MC_GROUP_UNDEFINED;
 8035292:	2616      	movs	r6, #22
 8035294:	e7f8      	b.n	8035288 <LoRaMacMcChannelDelete+0x34>
 8035296:	bf00      	nop
 8035298:	20004aa4 	.word	0x20004aa4

0803529c <LoRaMacMcChannelGetGroupId>:

uint8_t LoRaMacMcChannelGetGroupId( uint32_t mcAddress )
{
    for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
    {
        if( mcAddress == Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.Address )
 803529c:	4b03      	ldr	r3, [pc, #12]	; (80352ac <LoRaMacMcChannelGetGroupId+0x10>)
 803529e:	f8d3 35e0 	ldr.w	r3, [r3, #1504]	; 0x5e0
        {
            return i;
        }
    }
    return 0xFF;
}
 80352a2:	4283      	cmp	r3, r0
 80352a4:	bf14      	ite	ne
 80352a6:	20ff      	movne	r0, #255	; 0xff
 80352a8:	2000      	moveq	r0, #0
 80352aa:	4770      	bx	lr
 80352ac:	20004aa4 	.word	0x20004aa4

080352b0 <LoRaMacMcChannelSetupRxParams>:

LoRaMacStatus_t LoRaMacMcChannelSetupRxParams( AddressIdentifier_t groupID, McRxParams_t *rxParams, uint8_t *status )
{
   *status = 0x1C + ( groupID & 0x03 );
 80352b0:	f000 0303 	and.w	r3, r0, #3
{
 80352b4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   *status = 0x1C + ( groupID & 0x03 );
 80352b6:	331c      	adds	r3, #28

    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 80352b8:	4e24      	ldr	r6, [pc, #144]	; (803534c <LoRaMacMcChannelSetupRxParams+0x9c>)
   *status = 0x1C + ( groupID & 0x03 );
 80352ba:	7013      	strb	r3, [r2, #0]
{
 80352bc:	4615      	mov	r5, r2
    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 80352be:	f8d6 2344 	ldr.w	r2, [r6, #836]	; 0x344
 80352c2:	0792      	lsls	r2, r2, #30
{
 80352c4:	4604      	mov	r4, r0
 80352c6:	460f      	mov	r7, r1
    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 80352c8:	d439      	bmi.n	803533e <LoRaMacMcChannelSetupRxParams+0x8e>
    {
        return LORAMAC_STATUS_BUSY;
    }

    DeviceClass_t devClass = Nvm.MacGroup2.MulticastChannelList[groupID].ChannelParams.Class;
 80352ca:	222c      	movs	r2, #44	; 0x2c
 80352cc:	fb02 6200 	mla	r2, r2, r0, r6
 80352d0:	f892 25dd 	ldrb.w	r2, [r2, #1501]	; 0x5dd
    if( ( devClass == CLASS_A ) || ( devClass > CLASS_C ) )
 80352d4:	1e51      	subs	r1, r2, #1
 80352d6:	2901      	cmp	r1, #1
 80352d8:	d833      	bhi.n	8035342 <LoRaMacMcChannelSetupRxParams+0x92>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }

    if( ( groupID >= LORAMAC_MAX_MC_CTX ) ||
 80352da:	bba0      	cbnz	r0, 8035346 <LoRaMacMcChannelSetupRxParams+0x96>
 80352dc:	f896 15de 	ldrb.w	r1, [r6, #1502]	; 0x5de
 80352e0:	b389      	cbz	r1, 8035346 <LoRaMacMcChannelSetupRxParams+0x96>
        ( Nvm.MacGroup2.MulticastChannelList[groupID].ChannelParams.IsEnabled == false ) )
    {
        return LORAMAC_STATUS_MC_GROUP_UNDEFINED;
    }
    *status &= 0x0F; // groupID OK
 80352e2:	f003 030f 	and.w	r3, r3, #15
 80352e6:	702b      	strb	r3, [r5, #0]

    VerifyParams_t verify;
    // Check datarate
    if( devClass == CLASS_B )
    {
        verify.DatarateParams.Datarate = rxParams->ClassB.Datarate;
 80352e8:	f997 3004 	ldrsb.w	r3, [r7, #4]
 80352ec:	f88d 3004 	strb.w	r3, [sp, #4]
    {
        verify.DatarateParams.Datarate = rxParams->ClassC.Datarate;
    }
    verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;

    if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 80352f0:	f896 054c 	ldrb.w	r0, [r6, #1356]	; 0x54c
    verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 80352f4:	f896 3581 	ldrb.w	r3, [r6, #1409]	; 0x581
 80352f8:	f88d 3005 	strb.w	r3, [sp, #5]
    if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 80352fc:	2207      	movs	r2, #7
 80352fe:	a901      	add	r1, sp, #4
 8035300:	f001 fa09 	bl	8036716 <RegionVerify>
 8035304:	b118      	cbz	r0, 803530e <LoRaMacMcChannelSetupRxParams+0x5e>
    {
        *status &= 0xFB; // datarate OK
 8035306:	782b      	ldrb	r3, [r5, #0]
 8035308:	f023 0304 	bic.w	r3, r3, #4
 803530c:	702b      	strb	r3, [r5, #0]
    }

    // Check frequency
    if( devClass == CLASS_B )
 803530e:	683b      	ldr	r3, [r7, #0]
    }
    else
    {
        verify.Frequency = rxParams->ClassC.Frequency;
    }
    if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_FREQUENCY ) == true )
 8035310:	f896 054c 	ldrb.w	r0, [r6, #1356]	; 0x54c
 8035314:	9301      	str	r3, [sp, #4]
 8035316:	2200      	movs	r2, #0
 8035318:	a901      	add	r1, sp, #4
 803531a:	f001 f9fc 	bl	8036716 <RegionVerify>
 803531e:	b118      	cbz	r0, 8035328 <LoRaMacMcChannelSetupRxParams+0x78>
    {
        *status &= 0xF7; // frequency OK
 8035320:	782b      	ldrb	r3, [r5, #0]
 8035322:	f023 0308 	bic.w	r3, r3, #8
 8035326:	702b      	strb	r3, [r5, #0]
    }

    if( *status == ( groupID & 0x03 ) )
 8035328:	782b      	ldrb	r3, [r5, #0]
 803532a:	b92b      	cbnz	r3, 8035338 <LoRaMacMcChannelSetupRxParams+0x88>
    {
        // Apply parameters
        Nvm.MacGroup2.MulticastChannelList[groupID].ChannelParams.RxParams = *rxParams;
 803532c:	e897 0003 	ldmia.w	r7, {r0, r1}
 8035330:	4a07      	ldr	r2, [pc, #28]	; (8035350 <LoRaMacMcChannelSetupRxParams+0xa0>)
 8035332:	e882 0003 	stmia.w	r2, {r0, r1}
    }
    return LORAMAC_STATUS_OK;
 8035336:	461c      	mov	r4, r3
}
 8035338:	4620      	mov	r0, r4
 803533a:	b003      	add	sp, #12
 803533c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return LORAMAC_STATUS_BUSY;
 803533e:	2401      	movs	r4, #1
 8035340:	e7fa      	b.n	8035338 <LoRaMacMcChannelSetupRxParams+0x88>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 8035342:	2403      	movs	r4, #3
 8035344:	e7f8      	b.n	8035338 <LoRaMacMcChannelSetupRxParams+0x88>
        return LORAMAC_STATUS_MC_GROUP_UNDEFINED;
 8035346:	2416      	movs	r4, #22
 8035348:	e7f6      	b.n	8035338 <LoRaMacMcChannelSetupRxParams+0x88>
 803534a:	bf00      	nop
 803534c:	20004aa4 	.word	0x20004aa4
 8035350:	20005098 	.word	0x20005098

08035354 <LoRaMacMlmeRequest>:

LoRaMacStatus_t LoRaMacMlmeRequest( MlmeReq_t* mlmeRequest )
{
 8035354:	b5f0      	push	{r4, r5, r6, r7, lr}
 8035356:	b087      	sub	sp, #28
    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;
    MlmeConfirmQueue_t queueElement;
    uint8_t macCmdPayload[2] = { 0x00, 0x00 };
 8035358:	2300      	movs	r3, #0
 803535a:	f8ad 3000 	strh.w	r3, [sp]

    if( mlmeRequest == NULL )
 803535e:	4606      	mov	r6, r0
 8035360:	2800      	cmp	r0, #0
 8035362:	f000 80df 	beq.w	8035524 <LoRaMacMlmeRequest+0x1d0>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }
    if( LoRaMacIsBusy( ) == true )
 8035366:	f7fe fd5d 	bl	8033e24 <LoRaMacIsBusy>
 803536a:	b118      	cbz	r0, 8035374 <LoRaMacMlmeRequest+0x20>
    {
        return LORAMAC_STATUS_BUSY;
 803536c:	2501      	movs	r5, #1
    else
    {
        LoRaMacConfirmQueueAdd( &queueElement );
    }
    return status;
}
 803536e:	4628      	mov	r0, r5
 8035370:	b007      	add	sp, #28
 8035372:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if( LoRaMacConfirmQueueIsFull( ) == true )
 8035374:	f000 fcf4 	bl	8035d60 <LoRaMacConfirmQueueIsFull>
 8035378:	2800      	cmp	r0, #0
 803537a:	d1f7      	bne.n	803536c <LoRaMacMlmeRequest+0x18>
    if( LoRaMacConfirmQueueGetCnt( ) == 0 )
 803537c:	f000 fcea 	bl	8035d54 <LoRaMacConfirmQueueGetCnt>
 8035380:	4601      	mov	r1, r0
 8035382:	b918      	cbnz	r0, 803538c <LoRaMacMlmeRequest+0x38>
        memset1( ( uint8_t* ) &MacCtx.MlmeConfirm, 0, sizeof( MacCtx.MlmeConfirm ) );
 8035384:	4868      	ldr	r0, [pc, #416]	; (8035528 <LoRaMacMlmeRequest+0x1d4>)
 8035386:	2214      	movs	r2, #20
 8035388:	f003 fdba 	bl	8038f00 <memset1>
    MacCtx.MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 803538c:	4c67      	ldr	r4, [pc, #412]	; (803552c <LoRaMacMlmeRequest+0x1d8>)
    MacCtx.MacFlags.Bits.MlmeReq = 1;
 803538e:	f894 2485 	ldrb.w	r2, [r4, #1157]	; 0x485
    MacCtx.MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 8035392:	2301      	movs	r3, #1
    MacCtx.MacFlags.Bits.MlmeReq = 1;
 8035394:	f042 0204 	orr.w	r2, r2, #4
    MacCtx.MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 8035398:	f884 3451 	strb.w	r3, [r4, #1105]	; 0x451
    MacCtx.MacFlags.Bits.MlmeReq = 1;
 803539c:	f884 2485 	strb.w	r2, [r4, #1157]	; 0x485
    queueElement.Request = mlmeRequest->Type;
 80353a0:	7832      	ldrb	r2, [r6, #0]
 80353a2:	f88d 2004 	strb.w	r2, [sp, #4]
    queueElement.RestrictCommonReadyToHandle = false;
 80353a6:	2100      	movs	r1, #0
 80353a8:	3a01      	subs	r2, #1
    queueElement.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 80353aa:	f88d 3005 	strb.w	r3, [sp, #5]
    queueElement.RestrictCommonReadyToHandle = false;
 80353ae:	f88d 1007 	strb.w	r1, [sp, #7]
    switch( mlmeRequest->Type )
 80353b2:	2a0d      	cmp	r2, #13
 80353b4:	f200 80ae 	bhi.w	8035514 <LoRaMacMlmeRequest+0x1c0>
 80353b8:	e8df f002 	tbb	[pc, r2]
 80353bc:	57acac07 	.word	0x57acac07
 80353c0:	acac8261 	.word	0xacac8261
 80353c4:	a0ac8aac 	.word	0xa0ac8aac
 80353c8:	9c8e      	.short	0x9c8e
            if( ( MacCtx.MacState & LORAMAC_TX_DELAYED ) == LORAMAC_TX_DELAYED )
 80353ca:	f8d4 5344 	ldr.w	r5, [r4, #836]	; 0x344
 80353ce:	f015 0520 	ands.w	r5, r5, #32
 80353d2:	d1cb      	bne.n	803536c <LoRaMacMlmeRequest+0x18>
            ResetMacParameters( );
 80353d4:	f7fd ff3a 	bl	803324c <ResetMacParameters>
            Nvm.MacGroup1.ChannelsDatarate = RegionAlternateDr( Nvm.MacGroup2.Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR );
 80353d8:	462a      	mov	r2, r5
 80353da:	f996 1004 	ldrsb.w	r1, [r6, #4]
 80353de:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
            MacCtx.TxMsg.Message.JoinReq.Buffer = MacCtx.PktBuffer;
 80353e2:	4f53      	ldr	r7, [pc, #332]	; (8035530 <LoRaMacMlmeRequest+0x1dc>)
            Nvm.MacGroup1.ChannelsDatarate = RegionAlternateDr( Nvm.MacGroup2.Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR );
 80353e4:	f001 fa32 	bl	803684c <RegionAlternateDr>
            queueElement.Status = LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL;
 80353e8:	2307      	movs	r3, #7
            Nvm.MacGroup1.ChannelsDatarate = RegionAlternateDr( Nvm.MacGroup2.Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR );
 80353ea:	f884 0545 	strb.w	r0, [r4, #1349]	; 0x545
            SwitchClass( CLASS_A );
 80353ee:	4628      	mov	r0, r5
            queueElement.Status = LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL;
 80353f0:	f88d 3005 	strb.w	r3, [sp, #5]
            SwitchClass( CLASS_A );
 80353f4:	f7fe f988 	bl	8033708 <SwitchClass>
            MacCtx.TxMsg.Message.JoinReq.BufSize = LORAMAC_PHY_MAXPAYLOAD;
 80353f8:	23ff      	movs	r3, #255	; 0xff
 80353fa:	f884 3110 	strb.w	r3, [r4, #272]	; 0x110
            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_JOIN_REQUEST;
 80353fe:	f884 5108 	strb.w	r5, [r4, #264]	; 0x108
            MacCtx.TxMsg.Message.JoinReq.MHDR.Value = macHdr.Value;
 8035402:	f884 5111 	strb.w	r5, [r4, #273]	; 0x111
            MacCtx.TxMsg.Message.JoinReq.Buffer = MacCtx.PktBuffer;
 8035406:	f8c4 710c 	str.w	r7, [r4, #268]	; 0x10c
            memcpy1( MacCtx.TxMsg.Message.JoinReq.JoinEUI, SecureElementGetJoinEui( ), LORAMAC_JOIN_EUI_FIELD_SIZE );
 803540a:	f003 fd3d 	bl	8038e88 <SecureElementGetJoinEui>
 803540e:	2208      	movs	r2, #8
 8035410:	4601      	mov	r1, r0
 8035412:	f507 7086 	add.w	r0, r7, #268	; 0x10c
 8035416:	f003 fd5f 	bl	8038ed8 <memcpy1>
            memcpy1( MacCtx.TxMsg.Message.JoinReq.DevEUI, SecureElementGetDevEui( ), LORAMAC_DEV_EUI_FIELD_SIZE );
 803541a:	f003 fd1f 	bl	8038e5c <SecureElementGetDevEui>
 803541e:	2208      	movs	r2, #8
 8035420:	4601      	mov	r1, r0
 8035422:	f507 708a 	add.w	r0, r7, #276	; 0x114
 8035426:	f003 fd57 	bl	8038ed8 <memcpy1>
    status = ScheduleTx( allowDelayedTx );
 803542a:	4628      	mov	r0, r5
 803542c:	f7fd ffa2 	bl	8033374 <ScheduleTx>
            if( status != LORAMAC_STATUS_OK )
 8035430:	4605      	mov	r5, r0
 8035432:	b140      	cbz	r0, 8035446 <LoRaMacMlmeRequest+0xf2>
                Nvm.MacGroup1.ChannelsDatarate = RegionAlternateDr( Nvm.MacGroup2.Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR_RESTORE );
 8035434:	f996 1004 	ldrsb.w	r1, [r6, #4]
 8035438:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
 803543c:	2201      	movs	r2, #1
 803543e:	f001 fa05 	bl	803684c <RegionAlternateDr>
 8035442:	f884 0545 	strb.w	r0, [r4, #1349]	; 0x545
    mlmeRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;
 8035446:	f8d4 3488 	ldr.w	r3, [r4, #1160]	; 0x488
 803544a:	6133      	str	r3, [r6, #16]
    if( status != LORAMAC_STATUS_OK )
 803544c:	2d00      	cmp	r5, #0
 803544e:	d065      	beq.n	803551c <LoRaMacMlmeRequest+0x1c8>
        if( LoRaMacConfirmQueueGetCnt( ) == 0 )
 8035450:	f000 fc80 	bl	8035d54 <LoRaMacConfirmQueueGetCnt>
 8035454:	2800      	cmp	r0, #0
 8035456:	d18a      	bne.n	803536e <LoRaMacMlmeRequest+0x1a>
            MacCtx.MacFlags.Bits.MlmeReq = 0;
 8035458:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
            MacCtx.NodeAckRequested = false;
 803545c:	f884 0418 	strb.w	r0, [r4, #1048]	; 0x418
            MacCtx.MacFlags.Bits.MlmeReq = 0;
 8035460:	f360 0382 	bfi	r3, r0, #2, #1
 8035464:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
 8035468:	e781      	b.n	803536e <LoRaMacMlmeRequest+0x1a>
            if( LoRaMacCommandsAddCmd( MOTE_MAC_LINK_CHECK_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )
 803546a:	2200      	movs	r2, #0
 803546c:	4669      	mov	r1, sp
 803546e:	2002      	movs	r0, #2
 8035470:	f000 fa9e 	bl	80359b0 <LoRaMacCommandsAddCmd>
 8035474:	b908      	cbnz	r0, 803547a <LoRaMacMlmeRequest+0x126>
            status = SetTxContinuousWave( mlmeRequest->Req.TxCw.Timeout );
 8035476:	2500      	movs	r5, #0
            break;
 8035478:	e7e5      	b.n	8035446 <LoRaMacMlmeRequest+0xf2>
                status = LORAMAC_STATUS_MAC_COMMAD_ERROR;
 803547a:	2513      	movs	r5, #19
 803547c:	e7e3      	b.n	8035446 <LoRaMacMlmeRequest+0xf2>
    continuousWave.Channel = MacCtx.Channel;
 803547e:	f894 2419 	ldrb.w	r2, [r4, #1049]	; 0x419
 8035482:	f88d 2008 	strb.w	r2, [sp, #8]
    continuousWave.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 8035486:	f894 2545 	ldrb.w	r2, [r4, #1349]	; 0x545
 803548a:	f88d 2009 	strb.w	r2, [sp, #9]
    continuousWave.TxPower = Nvm.MacGroup1.ChannelsTxPower;
 803548e:	f894 2544 	ldrb.w	r2, [r4, #1348]	; 0x544
 8035492:	f88d 200a 	strb.w	r2, [sp, #10]
    continuousWave.MaxEirp = Nvm.MacGroup2.MacParams.MaxEirp;
 8035496:	f8d4 2584 	ldr.w	r2, [r4, #1412]	; 0x584
            status = SetTxContinuousWave( mlmeRequest->Req.TxCw.Timeout );
 803549a:	88b3      	ldrh	r3, [r6, #4]
    continuousWave.MaxEirp = Nvm.MacGroup2.MacParams.MaxEirp;
 803549c:	9203      	str	r2, [sp, #12]
    RegionSetContinuousWave( Nvm.MacGroup2.Region, &continuousWave );
 803549e:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    continuousWave.AntennaGain = Nvm.MacGroup2.MacParams.AntennaGain;
 80354a2:	f8d4 2588 	ldr.w	r2, [r4, #1416]	; 0x588
 80354a6:	9204      	str	r2, [sp, #16]
    RegionSetContinuousWave( Nvm.MacGroup2.Region, &continuousWave );
 80354a8:	a902      	add	r1, sp, #8
    continuousWave.Timeout = timeout;
 80354aa:	f8ad 3014 	strh.w	r3, [sp, #20]
    RegionSetContinuousWave( Nvm.MacGroup2.Region, &continuousWave );
 80354ae:	f001 f9ed 	bl	803688c <RegionSetContinuousWave>
    MacCtx.MacState |= LORAMAC_TX_RUNNING;
 80354b2:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 80354b6:	f043 0302 	orr.w	r3, r3, #2
 80354ba:	f8c4 3344 	str.w	r3, [r4, #836]	; 0x344
 80354be:	e7da      	b.n	8035476 <LoRaMacMlmeRequest+0x122>
    Radio.SetTxContinuousWave( frequency, power, timeout );
 80354c0:	4b1c      	ldr	r3, [pc, #112]	; (8035534 <LoRaMacMlmeRequest+0x1e0>)
 80354c2:	88b2      	ldrh	r2, [r6, #4]
 80354c4:	f996 100c 	ldrsb.w	r1, [r6, #12]
 80354c8:	68b0      	ldr	r0, [r6, #8]
 80354ca:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80354cc:	4798      	blx	r3
    MacCtx.MacState |= LORAMAC_TX_RUNNING;
 80354ce:	e7f0      	b.n	80354b2 <LoRaMacMlmeRequest+0x15e>
            if( LoRaMacCommandsAddCmd( MOTE_MAC_DEVICE_TIME_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )
 80354d0:	2200      	movs	r2, #0
 80354d2:	4669      	mov	r1, sp
 80354d4:	200d      	movs	r0, #13
 80354d6:	e7cb      	b.n	8035470 <LoRaMacMlmeRequest+0x11c>
            if( Nvm.MacGroup2.DeviceClass == CLASS_A )
 80354d8:	f894 3608 	ldrb.w	r3, [r4, #1544]	; 0x608
 80354dc:	b9d3      	cbnz	r3, 8035514 <LoRaMacMlmeRequest+0x1c0>
                uint8_t value = mlmeRequest->Req.PingSlotInfo.PingSlot.Value;
 80354de:	7935      	ldrb	r5, [r6, #4]
                LoRaMacClassBSetPingSlotInfo( mlmeRequest->Req.PingSlotInfo.PingSlot.Fields.Periodicity );
 80354e0:	f005 0007 	and.w	r0, r5, #7
 80354e4:	f000 fa41 	bl	803596a <LoRaMacClassBSetPingSlotInfo>
                macCmdPayload[0] = value;
 80354e8:	f88d 5000 	strb.w	r5, [sp]
                if( LoRaMacCommandsAddCmd( MOTE_MAC_PING_SLOT_INFO_REQ, macCmdPayload, 1 ) != LORAMAC_COMMANDS_SUCCESS )
 80354ec:	2201      	movs	r2, #1
 80354ee:	4669      	mov	r1, sp
 80354f0:	2010      	movs	r0, #16
 80354f2:	e7bd      	b.n	8035470 <LoRaMacMlmeRequest+0x11c>
            if( LoRaMacCommandsAddCmd( MOTE_MAC_BEACON_TIMING_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )
 80354f4:	2200      	movs	r2, #0
 80354f6:	4669      	mov	r1, sp
 80354f8:	2012      	movs	r0, #18
 80354fa:	e7b9      	b.n	8035470 <LoRaMacMlmeRequest+0x11c>
            queueElement.RestrictCommonReadyToHandle = true;
 80354fc:	f88d 3007 	strb.w	r3, [sp, #7]
            if( LoRaMacClassBIsAcquisitionInProgress( ) == false )
 8035500:	f000 fa24 	bl	803594c <LoRaMacClassBIsAcquisitionInProgress>
 8035504:	4605      	mov	r5, r0
 8035506:	b938      	cbnz	r0, 8035518 <LoRaMacMlmeRequest+0x1c4>
                LoRaMacClassBSetBeaconState( BEACON_STATE_ACQUISITION );
 8035508:	f000 fa1d 	bl	8035946 <LoRaMacClassBSetBeaconState>
                LoRaMacClassBBeaconTimerEvent( NULL );
 803550c:	4628      	mov	r0, r5
 803550e:	f000 fa1f 	bl	8035950 <LoRaMacClassBBeaconTimerEvent>
                status = LORAMAC_STATUS_OK;
 8035512:	e798      	b.n	8035446 <LoRaMacMlmeRequest+0xf2>
    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;
 8035514:	2502      	movs	r5, #2
 8035516:	e796      	b.n	8035446 <LoRaMacMlmeRequest+0xf2>
                status = LORAMAC_STATUS_BUSY;
 8035518:	2501      	movs	r5, #1
 803551a:	e794      	b.n	8035446 <LoRaMacMlmeRequest+0xf2>
        LoRaMacConfirmQueueAdd( &queueElement );
 803551c:	a801      	add	r0, sp, #4
 803551e:	f000 fb6f 	bl	8035c00 <LoRaMacConfirmQueueAdd>
 8035522:	e724      	b.n	803536e <LoRaMacMlmeRequest+0x1a>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 8035524:	2503      	movs	r5, #3
 8035526:	e722      	b.n	803536e <LoRaMacMlmeRequest+0x1a>
 8035528:	20004ef4 	.word	0x20004ef4
 803552c:	20004aa4 	.word	0x20004aa4
 8035530:	20004aaa 	.word	0x20004aaa
 8035534:	0803bbd8 	.word	0x0803bbd8

08035538 <LoRaMacMcpsRequest>:

/* ST_WORKAROUND_BEGIN: Update MCPS request with new input parameter to allow delayed tx */
LoRaMacStatus_t LoRaMacMcpsRequest( McpsReq_t* mcpsRequest, bool allowDelayedTx )
{
 8035538:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 803553c:	b08f      	sub	sp, #60	; 0x3c
 803553e:	2600      	movs	r6, #0
 8035540:	9101      	str	r1, [sp, #4]
    /* ST_WORKAROUND_END */
    uint16_t fBufferSize;
    int8_t datarate = DR_0;
    bool readyToSend = false;

    if( mcpsRequest == NULL )
 8035542:	4605      	mov	r5, r0
 8035544:	b918      	cbnz	r0, 803554e <LoRaMacMcpsRequest+0x16>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
 8035546:	2003      	movs	r0, #3

    // Fill return structure
    mcpsRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;

    return status;
}
 8035548:	b00f      	add	sp, #60	; 0x3c
 803554a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( LoRaMacIsBusy( ) == true )
 803554e:	f7fe fc69 	bl	8033e24 <LoRaMacIsBusy>
 8035552:	4680      	mov	r8, r0
 8035554:	2800      	cmp	r0, #0
 8035556:	f040 815f 	bne.w	8035818 <LoRaMacMcpsRequest+0x2e0>
    memset1( ( uint8_t* ) &MacCtx.McpsConfirm, 0, sizeof( MacCtx.McpsConfirm ) );
 803555a:	4cb5      	ldr	r4, [pc, #724]	; (8035830 <LoRaMacMcpsRequest+0x2f8>)
 803555c:	4601      	mov	r1, r0
    macHdr.Value = 0;
 803555e:	4607      	mov	r7, r0
    memset1( ( uint8_t* ) &MacCtx.McpsConfirm, 0, sizeof( MacCtx.McpsConfirm ) );
 8035560:	2214      	movs	r2, #20
 8035562:	f204 403c 	addw	r0, r4, #1084	; 0x43c
 8035566:	f003 fccb 	bl	8038f00 <memset1>
    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 803556a:	2101      	movs	r1, #1
 803556c:	f884 143d 	strb.w	r1, [r4, #1085]	; 0x43d
    MacCtx.AckTimeoutRetriesCounter = 1;
 8035570:	f884 1416 	strb.w	r1, [r4, #1046]	; 0x416
    switch( mcpsRequest->Type )
 8035574:	7828      	ldrb	r0, [r5, #0]
 8035576:	4288      	cmp	r0, r1
 8035578:	f000 80ac 	beq.w	80356d4 <LoRaMacMcpsRequest+0x19c>
 803557c:	2803      	cmp	r0, #3
 803557e:	f000 80bb 	beq.w	80356f8 <LoRaMacMcpsRequest+0x1c0>
 8035582:	2800      	cmp	r0, #0
 8035584:	f040 80c5 	bne.w	8035712 <LoRaMacMcpsRequest+0x1da>
            MacCtx.AckTimeoutRetries = 1;
 8035588:	f884 1415 	strb.w	r1, [r4, #1045]	; 0x415
            macHdr.Bits.MType = FRAME_TYPE_DATA_UNCONFIRMED_UP;
 803558c:	2302      	movs	r3, #2
            fPort = mcpsRequest->Req.Unconfirmed.fPort;
 803558e:	f895 a004 	ldrb.w	sl, [r5, #4]
            fBuffer = mcpsRequest->Req.Unconfirmed.fBuffer;
 8035592:	f8d5 9008 	ldr.w	r9, [r5, #8]
            fBufferSize = mcpsRequest->Req.Unconfirmed.fBufferSize;
 8035596:	89ae      	ldrh	r6, [r5, #12]
            datarate = mcpsRequest->Req.Unconfirmed.Datarate;
 8035598:	f995 b00e 	ldrsb.w	fp, [r5, #14]
            macHdr.Bits.MType = FRAME_TYPE_DATA_UNCONFIRMED_UP;
 803559c:	f363 1747 	bfi	r7, r3, #5, #3
            readyToSend = true;
 80355a0:	4688      	mov	r8, r1
    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 80355a2:	f894 1580 	ldrb.w	r1, [r4, #1408]	; 0x580
 80355a6:	f88d 101e 	strb.w	r1, [sp, #30]
    getPhy.Attribute = PHY_MIN_TX_DR;
 80355aa:	2302      	movs	r3, #2
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80355ac:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
    getPhy.Attribute = PHY_MIN_TX_DR;
 80355b0:	f88d 301c 	strb.w	r3, [sp, #28]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80355b4:	a907      	add	r1, sp, #28
 80355b6:	f001 f888 	bl	80366ca <RegionGetPhyParam>
    if( readyToSend == true )
 80355ba:	2302      	movs	r3, #2
 80355bc:	f1b8 0f00 	cmp.w	r8, #0
 80355c0:	f000 8128 	beq.w	8035814 <LoRaMacMcpsRequest+0x2dc>
        if( Nvm.MacGroup2.AdrCtrlOn == false )
 80355c4:	f894 360a 	ldrb.w	r3, [r4, #1546]	; 0x60a
 80355c8:	b9ab      	cbnz	r3, 80355f6 <LoRaMacMcpsRequest+0xbe>
    datarate = MAX( datarate, ( int8_t )phyParam.Value );
 80355ca:	b240      	sxtb	r0, r0
 80355cc:	4558      	cmp	r0, fp
 80355ce:	bfb8      	it	lt
 80355d0:	4658      	movlt	r0, fp
            verify.DatarateParams.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 80355d2:	f894 3580 	ldrb.w	r3, [r4, #1408]	; 0x580
            verify.DatarateParams.Datarate = datarate;
 80355d6:	f88d 000c 	strb.w	r0, [sp, #12]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_DR ) == true )
 80355da:	2205      	movs	r2, #5
 80355dc:	f894 054c 	ldrb.w	r0, [r4, #1356]	; 0x54c
            verify.DatarateParams.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 80355e0:	f88d 300e 	strb.w	r3, [sp, #14]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_DR ) == true )
 80355e4:	a903      	add	r1, sp, #12
 80355e6:	f001 f896 	bl	8036716 <RegionVerify>
 80355ea:	2800      	cmp	r0, #0
 80355ec:	d0ab      	beq.n	8035546 <LoRaMacMcpsRequest+0xe>
                Nvm.MacGroup1.ChannelsDatarate = verify.DatarateParams.Datarate;
 80355ee:	f89d 300c 	ldrb.w	r3, [sp, #12]
 80355f2:	f884 3545 	strb.w	r3, [r4, #1349]	; 0x545
    int8_t txPower = Nvm.MacGroup1.ChannelsTxPower;
 80355f6:	f8b4 2544 	ldrh.w	r2, [r4, #1348]	; 0x544
 80355fa:	f8b4 3544 	ldrh.w	r3, [r4, #1348]	; 0x544
 80355fe:	9200      	str	r2, [sp, #0]
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 8035600:	f894 261c 	ldrb.w	r2, [r4, #1564]	; 0x61c
    uint32_t adrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 8035604:	f8d4 1534 	ldr.w	r1, [r4, #1332]	; 0x534
 8035608:	9104      	str	r1, [sp, #16]
 803560a:	ba5b      	rev16	r3, r3
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 803560c:	2a00      	cmp	r2, #0
 803560e:	f000 80ff 	beq.w	8035810 <LoRaMacMcpsRequest+0x2d8>
    if( Nvm.MacGroup2.MaxDCycle == 0 )
 8035612:	f894 260b 	ldrb.w	r2, [r4, #1547]	; 0x60b
 8035616:	b90a      	cbnz	r2, 803561c <LoRaMacMcpsRequest+0xe4>
        Nvm.MacGroup1.AggregatedTimeOff = 0;
 8035618:	f8c4 253c 	str.w	r2, [r4, #1340]	; 0x53c
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 803561c:	f894 2608 	ldrb.w	r2, [r4, #1544]	; 0x608
    fCtrl.Bits.Adr           = Nvm.MacGroup2.AdrCtrlOn;
 8035620:	f894 060a 	ldrb.w	r0, [r4, #1546]	; 0x60a
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 8035624:	f102 3cff 	add.w	ip, r2, #4294967295
    fCtrl.Value = 0;
 8035628:	f04f 0800 	mov.w	r8, #0
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 803562c:	f1dc 0200 	rsbs	r2, ip, #0
 8035630:	eb42 020c 	adc.w	r2, r2, ip
    fCtrl.Bits.Adr           = Nvm.MacGroup2.AdrCtrlOn;
 8035634:	f360 18c7 	bfi	r8, r0, #7, #1
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 8035638:	f362 1804 	bfi	r8, r2, #4, #1
    if( Nvm.MacGroup1.SrvAckRequested == true )
 803563c:	f894 2546 	ldrb.w	r2, [r4, #1350]	; 0x546
 8035640:	b10a      	cbz	r2, 8035646 <LoRaMacMcpsRequest+0x10e>
        fCtrl.Bits.Ack = 1;
 8035642:	f048 0820 	orr.w	r8, r8, #32
    adrNext.Version = Nvm.MacGroup2.Version;
 8035646:	f8d4 2618 	ldr.w	r2, [r4, #1560]	; 0x618
 803564a:	9209      	str	r2, [sp, #36]	; 0x24
    adrNext.AdrAckLimit = MacCtx.AdrAckLimit;
 803564c:	f8d4 23f8 	ldr.w	r2, [r4, #1016]	; 0x3f8
 8035650:	920c      	str	r2, [sp, #48]	; 0x30
    adrNext.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 8035652:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
    fCtrl.Bits.AdrAckReq = LoRaMacAdrCalcNext( &adrNext, &Nvm.MacGroup1.ChannelsDatarate,
 8035656:	4a77      	ldr	r2, [pc, #476]	; (8035834 <LoRaMacMcpsRequest+0x2fc>)
    adrNext.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8035658:	f894 3580 	ldrb.w	r3, [r4, #1408]	; 0x580
 803565c:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    adrNext.UpdateChanMask = true;
 8035660:	f04f 0b01 	mov.w	fp, #1
    adrNext.Region = Nvm.MacGroup2.Region;
 8035664:	f894 354c 	ldrb.w	r3, [r4, #1356]	; 0x54c
    adrNext.AdrEnabled = fCtrl.Bits.Adr;
 8035668:	f88d 0029 	strb.w	r0, [sp, #41]	; 0x29
    adrNext.AdrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 803566c:	910b      	str	r1, [sp, #44]	; 0x2c
    adrNext.Region = Nvm.MacGroup2.Region;
 803566e:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    fCtrl.Bits.AdrAckReq = LoRaMacAdrCalcNext( &adrNext, &Nvm.MacGroup1.ChannelsDatarate,
 8035672:	eb02 010b 	add.w	r1, r2, fp
 8035676:	ab04      	add	r3, sp, #16
 8035678:	a809      	add	r0, sp, #36	; 0x24
    adrNext.UpdateChanMask = true;
 803567a:	f88d b028 	strb.w	fp, [sp, #40]	; 0x28
    fCtrl.Bits.AdrAckReq = LoRaMacAdrCalcNext( &adrNext, &Nvm.MacGroup1.ChannelsDatarate,
 803567e:	f000 f8f3 	bl	8035868 <LoRaMacAdrCalcNext>
    MacCtx.PktBufferLen = 0;
 8035682:	2300      	movs	r3, #0
        fBufferSize = 0;
 8035684:	4599      	cmp	r9, r3
 8035686:	bf08      	it	eq
 8035688:	461e      	moveq	r6, r3
    memcpy1( MacCtx.AppData, ( uint8_t* ) fBuffer, fBufferSize );
 803568a:	4632      	mov	r2, r6
    fCtrl.Bits.AdrAckReq = LoRaMacAdrCalcNext( &adrNext, &Nvm.MacGroup1.ChannelsDatarate,
 803568c:	f360 1886 	bfi	r8, r0, #6, #1
    memcpy1( MacCtx.AppData, ( uint8_t* ) fBuffer, fBufferSize );
 8035690:	4649      	mov	r1, r9
 8035692:	4869      	ldr	r0, [pc, #420]	; (8035838 <LoRaMacMcpsRequest+0x300>)
    MacCtx.PktBufferLen = 0;
 8035694:	80a3      	strh	r3, [r4, #4]
    size_t macCmdsSize = 0;
 8035696:	e9cd 3305 	strd	r3, r3, [sp, #20]
    MacCtx.NodeAckRequested = false;
 803569a:	f884 3418 	strb.w	r3, [r4, #1048]	; 0x418
    memcpy1( MacCtx.AppData, ( uint8_t* ) fBuffer, fBufferSize );
 803569e:	f003 fc1b 	bl	8038ed8 <memcpy1>
    MacCtx.PktBuffer[0] = macHdr->Value;
 80356a2:	b2fb      	uxtb	r3, r7
 80356a4:	71a7      	strb	r7, [r4, #6]
    switch( macHdr->Bits.MType )
 80356a6:	f3c7 1742 	ubfx	r7, r7, #5, #3
    MacCtx.AppDataSize = fBufferSize;
 80356aa:	b2f2      	uxtb	r2, r6
    switch( macHdr->Bits.MType )
 80356ac:	2f04      	cmp	r7, #4
    MacCtx.AppDataSize = fBufferSize;
 80356ae:	f884 223b 	strb.w	r2, [r4, #571]	; 0x23b
    switch( macHdr->Bits.MType )
 80356b2:	d032      	beq.n	803571a <LoRaMacMcpsRequest+0x1e2>
 80356b4:	2f07      	cmp	r7, #7
 80356b6:	f000 809b 	beq.w	80357f0 <LoRaMacMcpsRequest+0x2b8>
 80356ba:	2f02      	cmp	r7, #2
 80356bc:	d02f      	beq.n	803571e <LoRaMacMcpsRequest+0x1e6>
            return LORAMAC_STATUS_SERVICE_UNKNOWN;
 80356be:	2002      	movs	r0, #2
        Nvm.MacGroup1.ChannelsTxPower = txPower;
 80356c0:	9b00      	ldr	r3, [sp, #0]
 80356c2:	f8a4 3544 	strh.w	r3, [r4, #1348]	; 0x544
            MacCtx.NodeAckRequested = false;
 80356c6:	2300      	movs	r3, #0
 80356c8:	f884 3418 	strb.w	r3, [r4, #1048]	; 0x418
    mcpsRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;
 80356cc:	f8d4 3488 	ldr.w	r3, [r4, #1160]	; 0x488
 80356d0:	612b      	str	r3, [r5, #16]
    return status;
 80356d2:	e739      	b.n	8035548 <LoRaMacMcpsRequest+0x10>
            MacCtx.AckTimeoutRetries = MIN( mcpsRequest->Req.Confirmed.NbTrials, MAX_ACK_RETRIES );
 80356d4:	7beb      	ldrb	r3, [r5, #15]
 80356d6:	2b08      	cmp	r3, #8
 80356d8:	bf28      	it	cs
 80356da:	2308      	movcs	r3, #8
 80356dc:	f884 3415 	strb.w	r3, [r4, #1045]	; 0x415
            macHdr.Bits.MType = FRAME_TYPE_DATA_CONFIRMED_UP;
 80356e0:	2304      	movs	r3, #4
            fPort = mcpsRequest->Req.Confirmed.fPort;
 80356e2:	f895 a004 	ldrb.w	sl, [r5, #4]
            fBuffer = mcpsRequest->Req.Confirmed.fBuffer;
 80356e6:	f8d5 9008 	ldr.w	r9, [r5, #8]
            fBufferSize = mcpsRequest->Req.Confirmed.fBufferSize;
 80356ea:	89ae      	ldrh	r6, [r5, #12]
            datarate = mcpsRequest->Req.Confirmed.Datarate;
 80356ec:	f995 b00e 	ldrsb.w	fp, [r5, #14]
            macHdr.Bits.MType = FRAME_TYPE_DATA_CONFIRMED_UP;
 80356f0:	f363 1747 	bfi	r7, r3, #5, #3
            readyToSend = true;
 80356f4:	4680      	mov	r8, r0
            break;
 80356f6:	e754      	b.n	80355a2 <LoRaMacMcpsRequest+0x6a>
            MacCtx.AckTimeoutRetries = 1;
 80356f8:	f884 1415 	strb.w	r1, [r4, #1045]	; 0x415
            fBuffer = mcpsRequest->Req.Proprietary.fBuffer;
 80356fc:	f8d5 9004 	ldr.w	r9, [r5, #4]
            fBufferSize = mcpsRequest->Req.Proprietary.fBufferSize;
 8035700:	892e      	ldrh	r6, [r5, #8]
            datarate = mcpsRequest->Req.Proprietary.Datarate;
 8035702:	f995 b00a 	ldrsb.w	fp, [r5, #10]
            macHdr.Bits.MType = FRAME_TYPE_PROPRIETARY;
 8035706:	f067 071f 	orn	r7, r7, #31
            readyToSend = true;
 803570a:	4688      	mov	r8, r1
    uint8_t fPort = 0;
 803570c:	f04f 0a00 	mov.w	sl, #0
            break;
 8035710:	e747      	b.n	80355a2 <LoRaMacMcpsRequest+0x6a>
    switch( mcpsRequest->Type )
 8035712:	46c3      	mov	fp, r8
 8035714:	46c1      	mov	r9, r8
 8035716:	46c2      	mov	sl, r8
 8035718:	e743      	b.n	80355a2 <LoRaMacMcpsRequest+0x6a>
            MacCtx.NodeAckRequested = true;
 803571a:	f884 b418 	strb.w	fp, [r4, #1048]	; 0x418
            MacCtx.TxMsg.Message.Data.Buffer = MacCtx.PktBuffer;
 803571e:	4f47      	ldr	r7, [pc, #284]	; (803583c <LoRaMacMcpsRequest+0x304>)
            MacCtx.TxMsg.Message.Data.MHDR.Value = macHdr->Value;
 8035720:	f884 3111 	strb.w	r3, [r4, #273]	; 0x111
            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_DATA;
 8035724:	2104      	movs	r1, #4
            MacCtx.TxMsg.Message.Data.FHDR.DevAddr = Nvm.MacGroup2.DevAddr;
 8035726:	f8d4 35d8 	ldr.w	r3, [r4, #1496]	; 0x5d8
            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_DATA;
 803572a:	f884 1108 	strb.w	r1, [r4, #264]	; 0x108
            MacCtx.TxMsg.Message.Data.FHDR.DevAddr = Nvm.MacGroup2.DevAddr;
 803572e:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
            MacCtx.TxMsg.Message.Data.BufSize = LORAMAC_PHY_MAXPAYLOAD;
 8035732:	21ff      	movs	r1, #255	; 0xff
            MacCtx.TxMsg.Message.Data.FRMPayload = MacCtx.AppData;
 8035734:	f507 739b 	add.w	r3, r7, #310	; 0x136
            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetFCntUp( &fCntUp ) )
 8035738:	a805      	add	r0, sp, #20
            MacCtx.TxMsg.Message.Data.Buffer = MacCtx.PktBuffer;
 803573a:	f8c4 710c 	str.w	r7, [r4, #268]	; 0x10c
            MacCtx.TxMsg.Message.Data.BufSize = LORAMAC_PHY_MAXPAYLOAD;
 803573e:	f884 1110 	strb.w	r1, [r4, #272]	; 0x110
            MacCtx.TxMsg.Message.Data.FPort = fPort;
 8035742:	f884 a12c 	strb.w	sl, [r4, #300]	; 0x12c
            MacCtx.TxMsg.Message.Data.FHDR.FCtrl.Value = fCtrl->Value;
 8035746:	f884 8118 	strb.w	r8, [r4, #280]	; 0x118
            MacCtx.TxMsg.Message.Data.FRMPayloadSize = MacCtx.AppDataSize;
 803574a:	f884 2134 	strb.w	r2, [r4, #308]	; 0x134
            MacCtx.TxMsg.Message.Data.FRMPayload = MacCtx.AppData;
 803574e:	f8c4 3130 	str.w	r3, [r4, #304]	; 0x130
            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetFCntUp( &fCntUp ) )
 8035752:	f000 fc2b 	bl	8035fac <LoRaMacCryptoGetFCntUp>
 8035756:	2800      	cmp	r0, #0
 8035758:	d158      	bne.n	803580c <LoRaMacMcpsRequest+0x2d4>
            MacCtx.TxMsg.Message.Data.FHDR.FCnt = ( uint16_t )fCntUp;
 803575a:	9b05      	ldr	r3, [sp, #20]
            MacCtx.McpsConfirm.AckReceived = false;
 803575c:	f8a4 0440 	strh.w	r0, [r4, #1088]	; 0x440
            if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )
 8035760:	a806      	add	r0, sp, #24
            MacCtx.TxMsg.Message.Data.FHDR.FCnt = ( uint16_t )fCntUp;
 8035762:	f8a4 311a 	strh.w	r3, [r4, #282]	; 0x11a
            MacCtx.McpsConfirm.UpLinkCounter = fCntUp;
 8035766:	f8c4 3448 	str.w	r3, [r4, #1096]	; 0x448
            if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )
 803576a:	f000 f9bb 	bl	8035ae4 <LoRaMacCommandsGetSizeSerializedCmds>
 803576e:	bb68      	cbnz	r0, 80357cc <LoRaMacMcpsRequest+0x294>
            if( macCmdsSize > 0 )
 8035770:	9b06      	ldr	r3, [sp, #24]
 8035772:	b1ab      	cbz	r3, 80357a0 <LoRaMacMcpsRequest+0x268>
                availableSize = GetMaxAppPayloadWithoutFOptsLength( Nvm.MacGroup1.ChannelsDatarate );
 8035774:	f994 0545 	ldrsb.w	r0, [r4, #1349]	; 0x545
 8035778:	f7fd fc2a 	bl	8032fd0 <GetMaxAppPayloadWithoutFOptsLength>
                if( ( MacCtx.AppDataSize > 0 ) && ( macCmdsSize <= LORA_MAC_COMMAND_MAX_FOPTS_LENGTH ) )
 803577c:	f894 323b 	ldrb.w	r3, [r4, #571]	; 0x23b
 8035780:	b333      	cbz	r3, 80357d0 <LoRaMacMcpsRequest+0x298>
 8035782:	9b06      	ldr	r3, [sp, #24]
 8035784:	2b0f      	cmp	r3, #15
 8035786:	d81a      	bhi.n	80357be <LoRaMacMcpsRequest+0x286>
                    if( LoRaMacCommandsSerializeCmds( LORA_MAC_COMMAND_MAX_FOPTS_LENGTH, &macCmdsSize, MacCtx.TxMsg.Message.Data.FHDR.FOpts ) != LORAMAC_COMMANDS_SUCCESS )
 8035788:	f507 728b 	add.w	r2, r7, #278	; 0x116
 803578c:	a906      	add	r1, sp, #24
 803578e:	200f      	movs	r0, #15
 8035790:	f000 f9b4 	bl	8035afc <LoRaMacCommandsSerializeCmds>
 8035794:	b9d0      	cbnz	r0, 80357cc <LoRaMacMcpsRequest+0x294>
                    fCtrl->Bits.FOptsLen = macCmdsSize;
 8035796:	9b06      	ldr	r3, [sp, #24]
 8035798:	f363 0803 	bfi	r8, r3, #0, #4
                    MacCtx.TxMsg.Message.Data.FHDR.FCtrl.Value = fCtrl->Value;
 803579c:	f884 8118 	strb.w	r8, [r4, #280]	; 0x118
        status = ScheduleTx( allowDelayedTx ); /* ST_WORKAROUND: Update Send request with new input parameter to allow delayed tx */
 80357a0:	9801      	ldr	r0, [sp, #4]
 80357a2:	f7fd fde7 	bl	8033374 <ScheduleTx>
    if( status != LORAMAC_STATUS_OK )
 80357a6:	2800      	cmp	r0, #0
 80357a8:	d18a      	bne.n	80356c0 <LoRaMacMcpsRequest+0x188>
        Nvm.MacGroup1.AdrAckCounter = adrAckCounter;
 80357aa:	9b04      	ldr	r3, [sp, #16]
        Nvm.MacGroup1.SrvAckRequested = false;
 80357ac:	f884 0546 	strb.w	r0, [r4, #1350]	; 0x546
        Nvm.MacGroup1.AdrAckCounter = adrAckCounter;
 80357b0:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
        if( LoRaMacCommandsRemoveNoneStickyCmds( ) != LORAMAC_COMMANDS_SUCCESS )
 80357b4:	f000 f976 	bl	8035aa4 <LoRaMacCommandsRemoveNoneStickyCmds>
 80357b8:	b380      	cbz	r0, 803581c <LoRaMacMcpsRequest+0x2e4>
            return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 80357ba:	2013      	movs	r0, #19
 80357bc:	e783      	b.n	80356c6 <LoRaMacMcpsRequest+0x18e>
                    if( LoRaMacCommandsSerializeCmds( availableSize, &macCmdsSize, MacCtx.MacCommandsBuffer ) != LORAMAC_COMMANDS_SUCCESS )
 80357be:	f207 4286 	addw	r2, r7, #1158	; 0x486
 80357c2:	a906      	add	r1, sp, #24
 80357c4:	f000 f99a 	bl	8035afc <LoRaMacCommandsSerializeCmds>
 80357c8:	2800      	cmp	r0, #0
 80357ca:	d0e9      	beq.n	80357a0 <LoRaMacMcpsRequest+0x268>
                        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 80357cc:	2013      	movs	r0, #19
 80357ce:	e777      	b.n	80356c0 <LoRaMacMcpsRequest+0x188>
                    if( LoRaMacCommandsSerializeCmds( availableSize, &macCmdsSize, MacCtx.MacCommandsBuffer ) != LORAMAC_COMMANDS_SUCCESS )
 80357d0:	f207 4786 	addw	r7, r7, #1158	; 0x486
 80357d4:	463a      	mov	r2, r7
 80357d6:	a906      	add	r1, sp, #24
 80357d8:	f000 f990 	bl	8035afc <LoRaMacCommandsSerializeCmds>
 80357dc:	2800      	cmp	r0, #0
 80357de:	d1f5      	bne.n	80357cc <LoRaMacMcpsRequest+0x294>
                    MacCtx.TxMsg.Message.Data.FRMPayloadSize = macCmdsSize;
 80357e0:	9b06      	ldr	r3, [sp, #24]
                    MacCtx.TxMsg.Message.Data.FPort = 0;
 80357e2:	f884 012c 	strb.w	r0, [r4, #300]	; 0x12c
                    MacCtx.TxMsg.Message.Data.FRMPayload = MacCtx.MacCommandsBuffer;
 80357e6:	f8c4 7130 	str.w	r7, [r4, #304]	; 0x130
                    MacCtx.TxMsg.Message.Data.FRMPayloadSize = macCmdsSize;
 80357ea:	f884 3134 	strb.w	r3, [r4, #308]	; 0x134
    if( ( status == LORAMAC_STATUS_OK ) || ( status == LORAMAC_STATUS_SKIPPED_APP_DATA ) )
 80357ee:	e7d7      	b.n	80357a0 <LoRaMacMcpsRequest+0x268>
            if( ( fBuffer != NULL ) && ( MacCtx.AppDataSize > 0 ) )
 80357f0:	f1b9 0f00 	cmp.w	r9, #0
 80357f4:	d0d4      	beq.n	80357a0 <LoRaMacMcpsRequest+0x268>
 80357f6:	2a00      	cmp	r2, #0
 80357f8:	d0d2      	beq.n	80357a0 <LoRaMacMcpsRequest+0x268>
                memcpy1( MacCtx.PktBuffer + LORAMAC_MHDR_FIELD_SIZE, ( uint8_t* ) fBuffer, MacCtx.AppDataSize );
 80357fa:	4811      	ldr	r0, [pc, #68]	; (8035840 <LoRaMacMcpsRequest+0x308>)
 80357fc:	4649      	mov	r1, r9
 80357fe:	f003 fb6b 	bl	8038ed8 <memcpy1>
                MacCtx.PktBufferLen = LORAMAC_MHDR_FIELD_SIZE + MacCtx.AppDataSize;
 8035802:	f894 323b 	ldrb.w	r3, [r4, #571]	; 0x23b
 8035806:	3301      	adds	r3, #1
 8035808:	80a3      	strh	r3, [r4, #4]
    if( ( status == LORAMAC_STATUS_OK ) || ( status == LORAMAC_STATUS_SKIPPED_APP_DATA ) )
 803580a:	e7c9      	b.n	80357a0 <LoRaMacMcpsRequest+0x268>
                return LORAMAC_STATUS_FCNT_HANDLER_ERROR;
 803580c:	2012      	movs	r0, #18
 803580e:	e757      	b.n	80356c0 <LoRaMacMcpsRequest+0x188>
        return LORAMAC_STATUS_NO_NETWORK_JOINED;
 8035810:	2007      	movs	r0, #7
 8035812:	e758      	b.n	80356c6 <LoRaMacMcpsRequest+0x18e>
    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;
 8035814:	4618      	mov	r0, r3
 8035816:	e759      	b.n	80356cc <LoRaMacMcpsRequest+0x194>
        return LORAMAC_STATUS_BUSY;
 8035818:	2001      	movs	r0, #1
 803581a:	e695      	b.n	8035548 <LoRaMacMcpsRequest+0x10>
            MacCtx.McpsConfirm.McpsRequest = mcpsRequest->Type;
 803581c:	782b      	ldrb	r3, [r5, #0]
 803581e:	f884 343c 	strb.w	r3, [r4, #1084]	; 0x43c
            MacCtx.MacFlags.Bits.McpsReq = 1;
 8035822:	f894 3485 	ldrb.w	r3, [r4, #1157]	; 0x485
 8035826:	f043 0301 	orr.w	r3, r3, #1
 803582a:	f884 3485 	strb.w	r3, [r4, #1157]	; 0x485
 803582e:	e74d      	b.n	80356cc <LoRaMacMcpsRequest+0x194>
 8035830:	20004aa4 	.word	0x20004aa4
 8035834:	20004fe8 	.word	0x20004fe8
 8035838:	20004be0 	.word	0x20004be0
 803583c:	20004aaa 	.word	0x20004aaa
 8035840:	20004aab 	.word	0x20004aab

08035844 <LoRaMacTestSetDutyCycleOn>:
/* ST_WORKAROUND_END */

void LoRaMacTestSetDutyCycleOn( bool enable )
{
 8035844:	b537      	push	{r0, r1, r2, r4, r5, lr}
    VerifyParams_t verify;

    verify.DutyCycle = enable;

    if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DUTY_CYCLE ) == true )
 8035846:	4d07      	ldr	r5, [pc, #28]	; (8035864 <LoRaMacTestSetDutyCycleOn+0x20>)
    verify.DutyCycle = enable;
 8035848:	f88d 0004 	strb.w	r0, [sp, #4]
{
 803584c:	4604      	mov	r4, r0
    if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DUTY_CYCLE ) == true )
 803584e:	220f      	movs	r2, #15
 8035850:	f895 054c 	ldrb.w	r0, [r5, #1356]	; 0x54c
 8035854:	a901      	add	r1, sp, #4
 8035856:	f000 ff5e 	bl	8036716 <RegionVerify>
 803585a:	b108      	cbz	r0, 8035860 <LoRaMacTestSetDutyCycleOn+0x1c>
    {
        Nvm.MacGroup2.DutyCycleOn = enable;
 803585c:	f885 460c 	strb.w	r4, [r5, #1548]	; 0x60c
    }
}
 8035860:	b003      	add	sp, #12
 8035862:	bd30      	pop	{r4, r5, pc}
 8035864:	20004aa4 	.word	0x20004aa4

08035868 <LoRaMacAdrCalcNext>:
 * \param [OUT] adrAckCounter The calculated ADR acknowledgement counter.
 *
 * \retval Returns true, if an ADR request should be performed.
 */
bool LoRaMacAdrCalcNext( CalcNextAdrParams_t* adrNext, int8_t* drOut, int8_t* txPowOut, uint32_t* adrAckCounter )
{
 8035868:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if( adrNext->Version.Fields.Minor == 0 )
 803586c:	f890 9002 	ldrb.w	r9, [r0, #2]
{
 8035870:	b08b      	sub	sp, #44	; 0x2c
 8035872:	4604      	mov	r4, r0
 8035874:	468a      	mov	sl, r1
 8035876:	9201      	str	r2, [sp, #4]
    if( adrNext->Version.Fields.Minor == 0 )
 8035878:	f1b9 0f00 	cmp.w	r9, #0
 803587c:	d160      	bne.n	8035940 <LoRaMacAdrCalcNext+0xd8>
    if( adrNext->AdrEnabled == true )
 803587e:	7945      	ldrb	r5, [r0, #5]
    *adrAckCounter = adrNext->AdrAckCounter;
 8035880:	6881      	ldr	r1, [r0, #8]
    int8_t datarate = adrNext->Datarate;
 8035882:	f990 2010 	ldrsb.w	r2, [r0, #16]
    int8_t txPower = adrNext->TxPower;
 8035886:	f990 8011 	ldrsb.w	r8, [r0, #17]
    *adrAckCounter = adrNext->AdrAckCounter;
 803588a:	6019      	str	r1, [r3, #0]
    if( adrNext->AdrEnabled == true )
 803588c:	2d00      	cmp	r5, #0
 803588e:	d055      	beq.n	803593c <LoRaMacAdrCalcNext+0xd4>
        getPhy.UplinkDwellTime = adrNext->UplinkDwellTime;
 8035890:	7c81      	ldrb	r1, [r0, #18]
 8035892:	f88d 1016 	strb.w	r1, [sp, #22]
        phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 8035896:	7cc0      	ldrb	r0, [r0, #19]
        getPhy.Attribute = PHY_MIN_TX_DR;
 8035898:	f04f 0b02 	mov.w	fp, #2
        phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 803589c:	a905      	add	r1, sp, #20
 803589e:	e9cd 2302 	strd	r2, r3, [sp, #8]
        getPhy.Attribute = PHY_MIN_TX_DR;
 80358a2:	f88d b014 	strb.w	fp, [sp, #20]
        phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 80358a6:	f000 ff10 	bl	80366ca <RegionGetPhyParam>
        datarate = MAX( datarate, minTxDatarate );
 80358aa:	9a02      	ldr	r2, [sp, #8]
        minTxDatarate = phyParam.Value;
 80358ac:	b247      	sxtb	r7, r0
        datarate = MAX( datarate, minTxDatarate );
 80358ae:	42ba      	cmp	r2, r7
 80358b0:	4616      	mov	r6, r2
 80358b2:	bfb8      	it	lt
 80358b4:	463e      	movlt	r6, r7
        if( datarate == minTxDatarate )
 80358b6:	42ba      	cmp	r2, r7
 80358b8:	dc0c      	bgt.n	80358d4 <LoRaMacAdrCalcNext+0x6c>
            *adrAckCounter = 0;
 80358ba:	9b03      	ldr	r3, [sp, #12]
 80358bc:	f8c3 9000 	str.w	r9, [r3]
                        adrAckReq = false;
 80358c0:	464d      	mov	r5, r9
    *txPowOut = txPower;
 80358c2:	9b01      	ldr	r3, [sp, #4]
    *drOut = datarate;
 80358c4:	f88a 6000 	strb.w	r6, [sl]
    *txPowOut = txPower;
 80358c8:	f883 8000 	strb.w	r8, [r3]
    {
        return CalcNextV10X( adrNext, drOut, txPowOut, adrAckCounter );
    }
    return false;
}
 80358cc:	4628      	mov	r0, r5
 80358ce:	b00b      	add	sp, #44	; 0x2c
 80358d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            if( adrNext->AdrAckCounter >=  adrNext->AdrAckLimit )
 80358d4:	68a2      	ldr	r2, [r4, #8]
 80358d6:	89a1      	ldrh	r1, [r4, #12]
            if( adrNext->AdrAckCounter >= ( adrNext->AdrAckLimit + adrNext->AdrAckDelay ) )
 80358d8:	89e3      	ldrh	r3, [r4, #14]
            if( adrNext->AdrAckCounter >=  adrNext->AdrAckLimit )
 80358da:	428a      	cmp	r2, r1
            if( adrNext->AdrAckCounter >= ( adrNext->AdrAckLimit + adrNext->AdrAckDelay ) )
 80358dc:	440b      	add	r3, r1
            if( adrNext->AdrAckCounter >=  adrNext->AdrAckLimit )
 80358de:	bf34      	ite	cc
 80358e0:	2500      	movcc	r5, #0
 80358e2:	2501      	movcs	r5, #1
            if( adrNext->AdrAckCounter >= ( adrNext->AdrAckLimit + adrNext->AdrAckDelay ) )
 80358e4:	429a      	cmp	r2, r3
 80358e6:	d3ec      	bcc.n	80358c2 <LoRaMacAdrCalcNext+0x5a>
                getPhy.Attribute = PHY_MAX_TX_POWER;
 80358e8:	2308      	movs	r3, #8
                phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 80358ea:	a905      	add	r1, sp, #20
 80358ec:	7ce0      	ldrb	r0, [r4, #19]
                getPhy.Attribute = PHY_MAX_TX_POWER;
 80358ee:	f88d 3014 	strb.w	r3, [sp, #20]
                phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 80358f2:	f000 feea 	bl	80366ca <RegionGetPhyParam>
                if( ( adrNext->AdrAckCounter % adrNext->AdrAckDelay ) == 1 )
 80358f6:	89e2      	ldrh	r2, [r4, #14]
 80358f8:	68a1      	ldr	r1, [r4, #8]
 80358fa:	fbb1 f3f2 	udiv	r3, r1, r2
 80358fe:	fb02 1313 	mls	r3, r2, r3, r1
 8035902:	2b01      	cmp	r3, #1
                txPower = phyParam.Value;
 8035904:	fa4f f880 	sxtb.w	r8, r0
                if( ( adrNext->AdrAckCounter % adrNext->AdrAckDelay ) == 1 )
 8035908:	d1db      	bne.n	80358c2 <LoRaMacAdrCalcNext+0x5a>
                    getPhy.Attribute = PHY_NEXT_LOWER_TX_DR;
 803590a:	2322      	movs	r3, #34	; 0x22
 803590c:	f88d 3014 	strb.w	r3, [sp, #20]
                    phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 8035910:	7ce0      	ldrb	r0, [r4, #19]
                    getPhy.UplinkDwellTime = adrNext->UplinkDwellTime;
 8035912:	7ca3      	ldrb	r3, [r4, #18]
                    getPhy.Datarate = datarate;
 8035914:	f88d 6015 	strb.w	r6, [sp, #21]
                    phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 8035918:	a905      	add	r1, sp, #20
                    getPhy.UplinkDwellTime = adrNext->UplinkDwellTime;
 803591a:	f88d 3016 	strb.w	r3, [sp, #22]
                    phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 803591e:	f000 fed4 	bl	80366ca <RegionGetPhyParam>
                    datarate = phyParam.Value;
 8035922:	b246      	sxtb	r6, r0
                    if( datarate == minTxDatarate )
 8035924:	42b7      	cmp	r7, r6
 8035926:	d1cc      	bne.n	80358c2 <LoRaMacAdrCalcNext+0x5a>
                        if( adrNext->UpdateChanMask == true )
 8035928:	7925      	ldrb	r5, [r4, #4]
 803592a:	2d00      	cmp	r5, #0
 803592c:	d0c9      	beq.n	80358c2 <LoRaMacAdrCalcNext+0x5a>
                            RegionInitDefaults( adrNext->Region, &params );
 803592e:	7ce0      	ldrb	r0, [r4, #19]
                            params.Type = INIT_TYPE_ACTIVATE_DEFAULT_CHANNELS;
 8035930:	f88d b024 	strb.w	fp, [sp, #36]	; 0x24
                            RegionInitDefaults( adrNext->Region, &params );
 8035934:	a907      	add	r1, sp, #28
 8035936:	f000 fee3 	bl	8036700 <RegionInitDefaults>
 803593a:	e7c1      	b.n	80358c0 <LoRaMacAdrCalcNext+0x58>
    int8_t datarate = adrNext->Datarate;
 803593c:	4616      	mov	r6, r2
 803593e:	e7c0      	b.n	80358c2 <LoRaMacAdrCalcNext+0x5a>
    return false;
 8035940:	2500      	movs	r5, #0
 8035942:	e7c3      	b.n	80358cc <LoRaMacAdrCalcNext+0x64>

08035944 <LoRaMacClassBInit>:
    TimerInit( &Ctx.PingSlotTimer, LoRaMacClassBPingSlotTimerEvent );
    TimerInit( &Ctx.MulticastSlotTimer, LoRaMacClassBMulticastSlotTimerEvent );

    InitClassB( );
#endif /* LORAMAC_CLASSB_ENABLED */
}
 8035944:	4770      	bx	lr

08035946 <LoRaMacClassBSetBeaconState>:
        {
            Ctx.BeaconState = beaconState;
        }
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 8035946:	4770      	bx	lr

08035948 <LoRaMacClassBSetPingSlotState>:
 8035948:	4770      	bx	lr

0803594a <LoRaMacClassBSetMulticastSlotState>:
 803594a:	4770      	bx	lr

0803594c <LoRaMacClassBIsAcquisitionInProgress>:
    }
    return false;
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 803594c:	2000      	movs	r0, #0
 803594e:	4770      	bx	lr

08035950 <LoRaMacClassBBeaconTimerEvent>:
    if( Ctx.LoRaMacClassBCallbacks.MacProcessNotify != NULL )
    {
        Ctx.LoRaMacClassBCallbacks.MacProcessNotify( );
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 8035950:	4770      	bx	lr

08035952 <LoRaMacClassBPingSlotTimerEvent>:
 8035952:	4770      	bx	lr

08035954 <LoRaMacClassBMulticastSlotTimerEvent>:
 8035954:	4770      	bx	lr

08035956 <LoRaMacClassBRxBeacon>:
    }
    return beaconProcessed;
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 8035956:	2000      	movs	r0, #0
 8035958:	4770      	bx	lr

0803595a <LoRaMacClassBIsBeaconExpected>:
 803595a:	2000      	movs	r0, #0
 803595c:	4770      	bx	lr

0803595e <LoRaMacClassBIsPingExpected>:
 803595e:	2000      	movs	r0, #0
 8035960:	4770      	bx	lr

08035962 <LoRaMacClassBIsMulticastExpected>:
 8035962:	2000      	movs	r0, #0
 8035964:	4770      	bx	lr

08035966 <LoRaMacClassBIsBeaconModeActive>:
 8035966:	2000      	movs	r0, #0
 8035968:	4770      	bx	lr

0803596a <LoRaMacClassBSetPingSlotInfo>:
 803596a:	4770      	bx	lr

0803596c <LoRaMacClassBHaltBeaconing>:

        // Halt ping and multicast slot state machines
        LoRaMacClassBStopRxSlots( );
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 803596c:	4770      	bx	lr

0803596e <LoRaMacClassBResumeBeaconing>:
 803596e:	4770      	bx	lr

08035970 <LoRaMacClassBSwitchClass>:
    }
    return LORAMAC_STATUS_SERVICE_UNKNOWN;
#else
    return LORAMAC_STATUS_SERVICE_UNKNOWN;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 8035970:	2002      	movs	r0, #2
 8035972:	4770      	bx	lr

08035974 <LoRaMacClassBMibGetRequestConfirm>:
    }
    return status;
#else
    return LORAMAC_STATUS_SERVICE_UNKNOWN;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 8035974:	2002      	movs	r0, #2
 8035976:	4770      	bx	lr

08035978 <LoRaMacMibClassBSetRequestConfirm>:
 8035978:	2002      	movs	r0, #2
 803597a:	4770      	bx	lr

0803597c <LoRaMacClassBPingSlotInfoAns>:
 803597c:	4770      	bx	lr

0803597e <LoRaMacClassBPingSlotChannelReq>:

    return status;
#else
    return 0;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 803597e:	2000      	movs	r0, #0
 8035980:	4770      	bx	lr

08035982 <LoRaMacClassBBeaconTimingAns>:

        Ctx.LoRaMacClassBParams.MlmeConfirm->BeaconTimingDelay = Ctx.BeaconCtx.BeaconTimingDelay;
        Ctx.LoRaMacClassBParams.MlmeConfirm->BeaconTimingChannel = Ctx.BeaconCtx.BeaconTimingChannel;
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 8035982:	4770      	bx	lr

08035984 <LoRaMacClassBDeviceTimeAns>:
 8035984:	4770      	bx	lr

08035986 <LoRaMacClassBBeaconFreqReq>:
    }
    return false;
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 8035986:	2000      	movs	r0, #0
 8035988:	4770      	bx	lr

0803598a <LoRaMacClassBIsUplinkCollision>:
    }
    return 0;
#else
    return 0;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 803598a:	2000      	movs	r0, #0
 803598c:	4770      	bx	lr

0803598e <LoRaMacClassBStopRxSlots>:
 803598e:	4770      	bx	lr

08035990 <LoRaMacClassBSetMulticastPeriodicity>:
 8035990:	4770      	bx	lr

08035992 <LoRaMacClassBProcess>:
 8035992:	4770      	bx	lr

08035994 <LoRaMacCommandsInit>:
            return false;
    }
}

LoRaMacCommandStatus_t LoRaMacCommandsInit( void )
{
 8035994:	b510      	push	{r4, lr}
    // Initialize with default
    memset1( ( uint8_t* )&CommandsCtx, 0, sizeof( CommandsCtx ) );
 8035996:	4c05      	ldr	r4, [pc, #20]	; (80359ac <LoRaMacCommandsInit+0x18>)
 8035998:	22fc      	movs	r2, #252	; 0xfc
 803599a:	4620      	mov	r0, r4
 803599c:	2100      	movs	r1, #0
 803599e:	f003 faaf 	bl	8038f00 <memset1>
    list->First = NULL;
 80359a2:	2000      	movs	r0, #0
    list->Last = NULL;
 80359a4:	e9c4 0000 	strd	r0, r0, [r4]

    LinkedListInit( &CommandsCtx.MacCommandList );

    return LORAMAC_COMMANDS_SUCCESS;
}
 80359a8:	bd10      	pop	{r4, pc}
 80359aa:	bf00      	nop
 80359ac:	20005604 	.word	0x20005604

080359b0 <LoRaMacCommandsAddCmd>:

LoRaMacCommandStatus_t LoRaMacCommandsAddCmd( uint8_t cid, uint8_t* payload, size_t payloadSize )
{
 80359b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80359b4:	4680      	mov	r8, r0
 80359b6:	4616      	mov	r6, r2
    if( payload == NULL )
 80359b8:	2900      	cmp	r1, #0
 80359ba:	d03d      	beq.n	8035a38 <LoRaMacCommandsAddCmd+0x88>
 80359bc:	4c22      	ldr	r4, [pc, #136]	; (8035a48 <LoRaMacCommandsAddCmd+0x98>)
 80359be:	2300      	movs	r3, #0
    while( IsSlotFree( ( const MacCommand_t* )&CommandsCtx.MacCommandSlots[itr] ) == false )
 80359c0:	1c65      	adds	r5, r4, #1
 80359c2:	4622      	mov	r2, r4
 80359c4:	0118      	lsls	r0, r3, #4
 80359c6:	3410      	adds	r4, #16
        if( mem[size] != 0x00 )
 80359c8:	f812 7f01 	ldrb.w	r7, [r2, #1]!
 80359cc:	bbb7      	cbnz	r7, 8035a3c <LoRaMacCommandsAddCmd+0x8c>
    for( uint16_t size = 0; size < sizeof( MacCommand_t ); size++ )
 80359ce:	42a2      	cmp	r2, r4
 80359d0:	d1fa      	bne.n	80359c8 <LoRaMacCommandsAddCmd+0x18>
    if( list->First == NULL )
 80359d2:	4c1e      	ldr	r4, [pc, #120]	; (8035a4c <LoRaMacCommandsAddCmd+0x9c>)
 80359d4:	6822      	ldr	r2, [r4, #0]
 80359d6:	b902      	cbnz	r2, 80359da <LoRaMacCommandsAddCmd+0x2a>
        list->First = element;
 80359d8:	6025      	str	r5, [r4, #0]
    if( list->Last )
 80359da:	6862      	ldr	r2, [r4, #4]
 80359dc:	b102      	cbz	r2, 80359e0 <LoRaMacCommandsAddCmd+0x30>
        list->Last->Next = element;
 80359de:	6015      	str	r5, [r2, #0]
    list->Last = element;
 80359e0:	6065      	str	r5, [r4, #4]
        return LORAMAC_COMMANDS_ERROR;
    }

    // Set Values
    newCmd->CID = cid;
    newCmd->PayloadSize = payloadSize;
 80359e2:	1c5d      	adds	r5, r3, #1
    element->Next = NULL;
 80359e4:	1822      	adds	r2, r4, r0
    newCmd->PayloadSize = payloadSize;
 80359e6:	012b      	lsls	r3, r5, #4
    element->Next = NULL;
 80359e8:	f04f 0c00 	mov.w	ip, #0
    memcpy1( ( uint8_t* )newCmd->Payload, payload, payloadSize );
 80359ec:	300d      	adds	r0, #13
    element->Next = NULL;
 80359ee:	f8c2 c008 	str.w	ip, [r2, #8]
    newCmd->CID = cid;
 80359f2:	f882 800c 	strb.w	r8, [r2, #12]
    newCmd->PayloadSize = payloadSize;
 80359f6:	50e6      	str	r6, [r4, r3]
    memcpy1( ( uint8_t* )newCmd->Payload, payload, payloadSize );
 80359f8:	b2b2      	uxth	r2, r6
 80359fa:	4420      	add	r0, r4
 80359fc:	f003 fa6c 	bl	8038ed8 <memcpy1>
    switch( cid )
 8035a00:	f1b8 0f05 	cmp.w	r8, #5
 8035a04:	d015      	beq.n	8035a32 <LoRaMacCommandsAddCmd+0x82>
 8035a06:	f1a8 0808 	sub.w	r8, r8, #8
 8035a0a:	f1b8 0f02 	cmp.w	r8, #2
 8035a0e:	bf8c      	ite	hi
 8035a10:	f04f 0800 	movhi.w	r8, #0
 8035a14:	f04f 0801 	movls.w	r8, #1
    newCmd->IsSticky = IsSticky( cid );
 8035a18:	eb04 1305 	add.w	r3, r4, r5, lsl #4
 8035a1c:	f883 8004 	strb.w	r8, [r3, #4]

    CommandsCtx.SerializedCmdsSize += ( CID_FIELD_SIZE + payloadSize );
 8035a20:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
 8035a24:	3301      	adds	r3, #1
 8035a26:	4433      	add	r3, r6
 8035a28:	f8c4 30f8 	str.w	r3, [r4, #248]	; 0xf8

    return LORAMAC_COMMANDS_SUCCESS;
}
 8035a2c:	4638      	mov	r0, r7
 8035a2e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            return true;
 8035a32:	f04f 0801 	mov.w	r8, #1
 8035a36:	e7ef      	b.n	8035a18 <LoRaMacCommandsAddCmd+0x68>
        return LORAMAC_COMMANDS_ERROR_NPE;
 8035a38:	2701      	movs	r7, #1
 8035a3a:	e7f7      	b.n	8035a2c <LoRaMacCommandsAddCmd+0x7c>
        if( itr == NUM_OF_MAC_COMMANDS )
 8035a3c:	3301      	adds	r3, #1
 8035a3e:	2b0f      	cmp	r3, #15
 8035a40:	d1be      	bne.n	80359c0 <LoRaMacCommandsAddCmd+0x10>
        return LORAMAC_COMMANDS_ERROR_MEMORY;
 8035a42:	2702      	movs	r7, #2
 8035a44:	e7f2      	b.n	8035a2c <LoRaMacCommandsAddCmd+0x7c>
 8035a46:	bf00      	nop
 8035a48:	2000560b 	.word	0x2000560b
 8035a4c:	20005604 	.word	0x20005604

08035a50 <LoRaMacCommandsRemoveCmd>:

LoRaMacCommandStatus_t LoRaMacCommandsRemoveCmd( MacCommand_t* macCmd )
{
 8035a50:	b510      	push	{r4, lr}
    if( macCmd == NULL )
 8035a52:	b310      	cbz	r0, 8035a9a <LoRaMacCommandsRemoveCmd+0x4a>
    curElement = list->First;
 8035a54:	4b12      	ldr	r3, [pc, #72]	; (8035aa0 <LoRaMacCommandsRemoveCmd+0x50>)
 8035a56:	681a      	ldr	r2, [r3, #0]
    if( element != curElement )
 8035a58:	4290      	cmp	r0, r2
 8035a5a:	d104      	bne.n	8035a66 <LoRaMacCommandsRemoveCmd+0x16>
        list->First = element->Next;
 8035a5c:	6802      	ldr	r2, [r0, #0]
 8035a5e:	601a      	str	r2, [r3, #0]
 8035a60:	2200      	movs	r2, #0
 8035a62:	e004      	b.n	8035a6e <LoRaMacCommandsRemoveCmd+0x1e>
 8035a64:	460a      	mov	r2, r1
        while( ( curElement != NULL ) && ( curElement->Next != element ) )
 8035a66:	b112      	cbz	r2, 8035a6e <LoRaMacCommandsRemoveCmd+0x1e>
 8035a68:	6811      	ldr	r1, [r2, #0]
 8035a6a:	4288      	cmp	r0, r1
 8035a6c:	d1fa      	bne.n	8035a64 <LoRaMacCommandsRemoveCmd+0x14>
    if( list->Last == element )
 8035a6e:	6859      	ldr	r1, [r3, #4]
 8035a70:	4288      	cmp	r0, r1
        list->Last = PrevElement;
 8035a72:	bf08      	it	eq
 8035a74:	605a      	streq	r2, [r3, #4]
    if( PrevElement != NULL )
 8035a76:	b10a      	cbz	r2, 8035a7c <LoRaMacCommandsRemoveCmd+0x2c>
        PrevElement->Next = element->Next;
 8035a78:	6801      	ldr	r1, [r0, #0]
 8035a7a:	6011      	str	r1, [r2, #0]
    if( LinkedListRemove( &CommandsCtx.MacCommandList, macCmd ) == false )
    {
        return LORAMAC_COMMANDS_ERROR_CMD_NOT_FOUND;
    }

    CommandsCtx.SerializedCmdsSize -= ( CID_FIELD_SIZE + macCmd->PayloadSize );
 8035a7c:	f8d3 20f8 	ldr.w	r2, [r3, #248]	; 0xf8
 8035a80:	6881      	ldr	r1, [r0, #8]
 8035a82:	3a01      	subs	r2, #1
    element->Next = NULL;
 8035a84:	2400      	movs	r4, #0
    CommandsCtx.SerializedCmdsSize -= ( CID_FIELD_SIZE + macCmd->PayloadSize );
 8035a86:	1a52      	subs	r2, r2, r1
    element->Next = NULL;
 8035a88:	6004      	str	r4, [r0, #0]
    memset1( ( uint8_t* )slot, 0x00, sizeof( MacCommand_t ) );
 8035a8a:	4621      	mov	r1, r4
    CommandsCtx.SerializedCmdsSize -= ( CID_FIELD_SIZE + macCmd->PayloadSize );
 8035a8c:	f8c3 20f8 	str.w	r2, [r3, #248]	; 0xf8
    memset1( ( uint8_t* )slot, 0x00, sizeof( MacCommand_t ) );
 8035a90:	2210      	movs	r2, #16
 8035a92:	f003 fa35 	bl	8038f00 <memset1>
    return true;
 8035a96:	4620      	mov	r0, r4
    {
        return LORAMAC_COMMANDS_ERROR;
    }

    return LORAMAC_COMMANDS_SUCCESS;
}
 8035a98:	bd10      	pop	{r4, pc}
        return LORAMAC_COMMANDS_ERROR_NPE;
 8035a9a:	2001      	movs	r0, #1
 8035a9c:	e7fc      	b.n	8035a98 <LoRaMacCommandsRemoveCmd+0x48>
 8035a9e:	bf00      	nop
 8035aa0:	20005604 	.word	0x20005604

08035aa4 <LoRaMacCommandsRemoveNoneStickyCmds>:
    }
    return LORAMAC_COMMANDS_SUCCESS;
}

LoRaMacCommandStatus_t LoRaMacCommandsRemoveNoneStickyCmds( void )
{
 8035aa4:	b510      	push	{r4, lr}
    MacCommand_t* curElement;
    MacCommand_t* nexElement;

    // Start at the head of the list
    curElement = CommandsCtx.MacCommandList.First;
 8035aa6:	4b05      	ldr	r3, [pc, #20]	; (8035abc <LoRaMacCommandsRemoveNoneStickyCmds+0x18>)
 8035aa8:	6818      	ldr	r0, [r3, #0]

    // Loop through all elements
    while( curElement != NULL )
 8035aaa:	b900      	cbnz	r0, 8035aae <LoRaMacCommandsRemoveNoneStickyCmds+0xa>
            curElement = curElement->Next;
        }
    }

    return LORAMAC_COMMANDS_SUCCESS;
}
 8035aac:	bd10      	pop	{r4, pc}
        if( curElement->IsSticky == false )
 8035aae:	7b03      	ldrb	r3, [r0, #12]
 8035ab0:	6804      	ldr	r4, [r0, #0]
 8035ab2:	b90b      	cbnz	r3, 8035ab8 <LoRaMacCommandsRemoveNoneStickyCmds+0x14>
            LoRaMacCommandsRemoveCmd( curElement );
 8035ab4:	f7ff ffcc 	bl	8035a50 <LoRaMacCommandsRemoveCmd>
{
 8035ab8:	4620      	mov	r0, r4
 8035aba:	e7f6      	b.n	8035aaa <LoRaMacCommandsRemoveNoneStickyCmds+0x6>
 8035abc:	20005604 	.word	0x20005604

08035ac0 <LoRaMacCommandsRemoveStickyAnsCmds>:

LoRaMacCommandStatus_t LoRaMacCommandsRemoveStickyAnsCmds( void )
{
 8035ac0:	b510      	push	{r4, lr}
    MacCommand_t* curElement;
    MacCommand_t* nexElement;

    // Start at the head of the list
    curElement = CommandsCtx.MacCommandList.First;
 8035ac2:	4b07      	ldr	r3, [pc, #28]	; (8035ae0 <LoRaMacCommandsRemoveStickyAnsCmds+0x20>)
 8035ac4:	6818      	ldr	r0, [r3, #0]

    // Loop through all elements
    while( curElement != NULL )
 8035ac6:	b900      	cbnz	r0, 8035aca <LoRaMacCommandsRemoveStickyAnsCmds+0xa>
        }
        curElement = nexElement;
    }

    return LORAMAC_COMMANDS_SUCCESS;
}
 8035ac8:	bd10      	pop	{r4, pc}
        if( IsSticky( curElement->CID ) == true )
 8035aca:	7903      	ldrb	r3, [r0, #4]
        nexElement = curElement->Next;
 8035acc:	6804      	ldr	r4, [r0, #0]
    switch( cid )
 8035ace:	2b05      	cmp	r3, #5
 8035ad0:	d002      	beq.n	8035ad8 <LoRaMacCommandsRemoveStickyAnsCmds+0x18>
 8035ad2:	3b08      	subs	r3, #8
 8035ad4:	2b02      	cmp	r3, #2
 8035ad6:	d801      	bhi.n	8035adc <LoRaMacCommandsRemoveStickyAnsCmds+0x1c>
            LoRaMacCommandsRemoveCmd( curElement );
 8035ad8:	f7ff ffba 	bl	8035a50 <LoRaMacCommandsRemoveCmd>
{
 8035adc:	4620      	mov	r0, r4
 8035ade:	e7f2      	b.n	8035ac6 <LoRaMacCommandsRemoveStickyAnsCmds+0x6>
 8035ae0:	20005604 	.word	0x20005604

08035ae4 <LoRaMacCommandsGetSizeSerializedCmds>:

LoRaMacCommandStatus_t LoRaMacCommandsGetSizeSerializedCmds( size_t* size )
{
    if( size == NULL )
 8035ae4:	b128      	cbz	r0, 8035af2 <LoRaMacCommandsGetSizeSerializedCmds+0xe>
    {
        return LORAMAC_COMMANDS_ERROR_NPE;
    }
    *size = CommandsCtx.SerializedCmdsSize;
 8035ae6:	4b04      	ldr	r3, [pc, #16]	; (8035af8 <LoRaMacCommandsGetSizeSerializedCmds+0x14>)
 8035ae8:	f8d3 30f8 	ldr.w	r3, [r3, #248]	; 0xf8
 8035aec:	6003      	str	r3, [r0, #0]
    return LORAMAC_COMMANDS_SUCCESS;
 8035aee:	2000      	movs	r0, #0
 8035af0:	4770      	bx	lr
        return LORAMAC_COMMANDS_ERROR_NPE;
 8035af2:	2001      	movs	r0, #1
}
 8035af4:	4770      	bx	lr
 8035af6:	bf00      	nop
 8035af8:	20005604 	.word	0x20005604

08035afc <LoRaMacCommandsSerializeCmds>:

LoRaMacCommandStatus_t LoRaMacCommandsSerializeCmds( size_t availableSize, size_t* effectiveSize, uint8_t* buffer )
{
 8035afc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8035b00:	4607      	mov	r7, r0
 8035b02:	460e      	mov	r6, r1
    MacCommand_t* curElement = CommandsCtx.MacCommandList.First;
    MacCommand_t* nextElement;
    uint8_t itr = 0;

    if( ( buffer == NULL ) || ( effectiveSize == NULL ) )
 8035b04:	4615      	mov	r5, r2
 8035b06:	b332      	cbz	r2, 8035b56 <LoRaMacCommandsSerializeCmds+0x5a>
 8035b08:	b329      	cbz	r1, 8035b56 <LoRaMacCommandsSerializeCmds+0x5a>
    MacCommand_t* curElement = CommandsCtx.MacCommandList.First;
 8035b0a:	4b14      	ldr	r3, [pc, #80]	; (8035b5c <LoRaMacCommandsSerializeCmds+0x60>)
 8035b0c:	681c      	ldr	r4, [r3, #0]
    uint8_t itr = 0;
 8035b0e:	2300      	movs	r3, #0
    {
        return LORAMAC_COMMANDS_ERROR_NPE;
    }

    // Loop through all elements which fits into the buffer
    while( curElement != NULL )
 8035b10:	b92c      	cbnz	r4, 8035b1e <LoRaMacCommandsSerializeCmds+0x22>
        LoRaMacCommandsRemoveCmd( curElement );
        curElement = nextElement;
    }

    // Fetch the effective size of the mac commands
    LoRaMacCommandsGetSizeSerializedCmds( effectiveSize );
 8035b12:	4630      	mov	r0, r6
 8035b14:	f7ff ffe6 	bl	8035ae4 <LoRaMacCommandsGetSizeSerializedCmds>

    return LORAMAC_COMMANDS_SUCCESS;
 8035b18:	2000      	movs	r0, #0
}
 8035b1a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if( ( availableSize - itr ) >= ( CID_FIELD_SIZE + curElement->PayloadSize ) )
 8035b1e:	68a2      	ldr	r2, [r4, #8]
 8035b20:	1af9      	subs	r1, r7, r3
 8035b22:	3201      	adds	r2, #1
 8035b24:	4291      	cmp	r1, r2
 8035b26:	d30f      	bcc.n	8035b48 <LoRaMacCommandsSerializeCmds+0x4c>
            buffer[itr++] = curElement->CID;
 8035b28:	7922      	ldrb	r2, [r4, #4]
 8035b2a:	54ea      	strb	r2, [r5, r3]
 8035b2c:	1c58      	adds	r0, r3, #1
            memcpy1( &buffer[itr], curElement->Payload, curElement->PayloadSize );
 8035b2e:	8922      	ldrh	r2, [r4, #8]
            buffer[itr++] = curElement->CID;
 8035b30:	fa5f f880 	uxtb.w	r8, r0
            memcpy1( &buffer[itr], curElement->Payload, curElement->PayloadSize );
 8035b34:	1d61      	adds	r1, r4, #5
 8035b36:	fa55 f080 	uxtab	r0, r5, r0
 8035b3a:	f003 f9cd 	bl	8038ed8 <memcpy1>
            itr += curElement->PayloadSize;
 8035b3e:	68a3      	ldr	r3, [r4, #8]
        curElement = curElement->Next;
 8035b40:	6824      	ldr	r4, [r4, #0]
            itr += curElement->PayloadSize;
 8035b42:	4443      	add	r3, r8
 8035b44:	b2db      	uxtb	r3, r3
        curElement = curElement->Next;
 8035b46:	e7e3      	b.n	8035b10 <LoRaMacCommandsSerializeCmds+0x14>
        nextElement = curElement->Next;
 8035b48:	4620      	mov	r0, r4
 8035b4a:	6824      	ldr	r4, [r4, #0]
        LoRaMacCommandsRemoveCmd( curElement );
 8035b4c:	f7ff ff80 	bl	8035a50 <LoRaMacCommandsRemoveCmd>
    while( curElement != NULL )
 8035b50:	2c00      	cmp	r4, #0
 8035b52:	d1f9      	bne.n	8035b48 <LoRaMacCommandsSerializeCmds+0x4c>
 8035b54:	e7dd      	b.n	8035b12 <LoRaMacCommandsSerializeCmds+0x16>
        return LORAMAC_COMMANDS_ERROR_NPE;
 8035b56:	2001      	movs	r0, #1
 8035b58:	e7df      	b.n	8035b1a <LoRaMacCommandsSerializeCmds+0x1e>
 8035b5a:	bf00      	nop
 8035b5c:	20005604 	.word	0x20005604

08035b60 <LoRaMacCommandsStickyCmdsPending>:

LoRaMacCommandStatus_t LoRaMacCommandsStickyCmdsPending( bool* cmdsPending )
{
    if( cmdsPending == NULL )
 8035b60:	4603      	mov	r3, r0
 8035b62:	b168      	cbz	r0, 8035b80 <LoRaMacCommandsStickyCmdsPending+0x20>
    {
        return LORAMAC_COMMANDS_ERROR_NPE;
    }
    MacCommand_t* curElement;
    curElement = CommandsCtx.MacCommandList.First;
 8035b64:	4a07      	ldr	r2, [pc, #28]	; (8035b84 <LoRaMacCommandsStickyCmdsPending+0x24>)
 8035b66:	6810      	ldr	r0, [r2, #0]

    *cmdsPending = false;
 8035b68:	2200      	movs	r2, #0
 8035b6a:	701a      	strb	r2, [r3, #0]

    // Loop through all elements
    while( curElement != NULL )
 8035b6c:	b900      	cbnz	r0, 8035b70 <LoRaMacCommandsStickyCmdsPending+0x10>
 8035b6e:	4770      	bx	lr
    {
        if( curElement->IsSticky == true )
 8035b70:	7b02      	ldrb	r2, [r0, #12]
 8035b72:	b11a      	cbz	r2, 8035b7c <LoRaMacCommandsStickyCmdsPending+0x1c>
        {
            // Found one sticky MAC command
            *cmdsPending = true;
 8035b74:	2201      	movs	r2, #1
 8035b76:	701a      	strb	r2, [r3, #0]
            return LORAMAC_COMMANDS_SUCCESS;
 8035b78:	2000      	movs	r0, #0
 8035b7a:	4770      	bx	lr
        }
        curElement = curElement->Next;
 8035b7c:	6800      	ldr	r0, [r0, #0]
 8035b7e:	e7f5      	b.n	8035b6c <LoRaMacCommandsStickyCmdsPending+0xc>
        return LORAMAC_COMMANDS_ERROR_NPE;
 8035b80:	2001      	movs	r0, #1
    }

    return LORAMAC_COMMANDS_SUCCESS;
}
 8035b82:	4770      	bx	lr
 8035b84:	20005604 	.word	0x20005604

08035b88 <LoRaMacCommandsGetCmdSize>:
uint8_t LoRaMacCommandsGetCmdSize( uint8_t cid )
{
    uint8_t cidSize = 0;

    // Decode Frame MAC commands
    switch( cid )
 8035b88:	3802      	subs	r0, #2
 8035b8a:	b2c0      	uxtb	r0, r0
 8035b8c:	2811      	cmp	r0, #17
 8035b8e:	bf9a      	itte	ls
 8035b90:	4b01      	ldrls	r3, [pc, #4]	; (8035b98 <LoRaMacCommandsGetCmdSize+0x10>)
 8035b92:	5c18      	ldrbls	r0, [r3, r0]
{
 8035b94:	2000      	movhi	r0, #0
            // Unknown command. ABORT MAC commands processing
            break;
        }
    }
    return cidSize;
}
 8035b96:	4770      	bx	lr
 8035b98:	0803ba72 	.word	0x0803ba72

08035b9c <GetElement.isra.0>:
        return true;
    }
    return false;
}

static MlmeConfirmQueue_t* GetElement( Mlme_t request, MlmeConfirmQueue_t* bufferStart, MlmeConfirmQueue_t* bufferEnd )
 8035b9c:	b530      	push	{r4, r5, lr}
{
    MlmeConfirmQueue_t* element = bufferStart;

    if( IsListEmpty( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == true )
 8035b9e:	4b0c      	ldr	r3, [pc, #48]	; (8035bd0 <GetElement.isra.0+0x34>)
 8035ba0:	f893 2020 	ldrb.w	r2, [r3, #32]
static MlmeConfirmQueue_t* GetElement( Mlme_t request, MlmeConfirmQueue_t* bufferStart, MlmeConfirmQueue_t* bufferEnd )
 8035ba4:	4604      	mov	r4, r0
 8035ba6:	4608      	mov	r0, r1
    if( count == 0 )
 8035ba8:	b17a      	cbz	r2, 8035bca <GetElement.isra.0+0x2e>
 8035baa:	2100      	movs	r1, #0
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 8035bac:	331c      	adds	r3, #28
    {
        return NULL;
    }

    for( uint8_t elementCnt = 0; elementCnt < ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt; elementCnt++ )
 8035bae:	b2cd      	uxtb	r5, r1
 8035bb0:	42aa      	cmp	r2, r5
 8035bb2:	d801      	bhi.n	8035bb8 <GetElement.isra.0+0x1c>
        return NULL;
 8035bb4:	2000      	movs	r0, #0
        }
        element = IncreaseBufferPointer( element );
    }

    return NULL;
}
 8035bb6:	bd30      	pop	{r4, r5, pc}
        if( element->Request == request )
 8035bb8:	7805      	ldrb	r5, [r0, #0]
 8035bba:	42a5      	cmp	r5, r4
 8035bbc:	d0fb      	beq.n	8035bb6 <GetElement.isra.0+0x1a>
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 8035bbe:	4298      	cmp	r0, r3
        bufferPointer = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 8035bc0:	bf0c      	ite	eq
 8035bc2:	4804      	ldreq	r0, [pc, #16]	; (8035bd4 <GetElement.isra.0+0x38>)
        bufferPointer++;
 8035bc4:	3004      	addne	r0, #4
    for( uint8_t elementCnt = 0; elementCnt < ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt; elementCnt++ )
 8035bc6:	3101      	adds	r1, #1
 8035bc8:	e7f1      	b.n	8035bae <GetElement.isra.0+0x12>
        return NULL;
 8035bca:	4610      	mov	r0, r2
 8035bcc:	e7f3      	b.n	8035bb6 <GetElement.isra.0+0x1a>
 8035bce:	bf00      	nop
 8035bd0:	20005700 	.word	0x20005700
 8035bd4:	2000570c 	.word	0x2000570c

08035bd8 <LoRaMacConfirmQueueInit>:

void LoRaMacConfirmQueueInit( LoRaMacPrimitives_t* primitives )
{
 8035bd8:	b510      	push	{r4, lr}
    ConfirmQueueCtx.Primitives = primitives;
 8035bda:	4c08      	ldr	r4, [pc, #32]	; (8035bfc <LoRaMacConfirmQueueInit+0x24>)

    // Init counter
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt = 0;
 8035bdc:	2300      	movs	r3, #0
    ConfirmQueueCtx.Primitives = primitives;
 8035bde:	6020      	str	r0, [r4, #0]

    // Init buffer
    ConfirmQueueCtx.BufferStart = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
    ConfirmQueueCtx.BufferEnd = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;

    memset1( ( uint8_t* )ConfirmQueueCtx.Nvm.MlmeConfirmQueue, 0xFF, sizeof( ConfirmQueueCtx.Nvm.MlmeConfirmQueue ) );
 8035be0:	2214      	movs	r2, #20
    ConfirmQueueCtx.BufferStart = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 8035be2:	f104 000c 	add.w	r0, r4, #12
    memset1( ( uint8_t* )ConfirmQueueCtx.Nvm.MlmeConfirmQueue, 0xFF, sizeof( ConfirmQueueCtx.Nvm.MlmeConfirmQueue ) );
 8035be6:	21ff      	movs	r1, #255	; 0xff
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt = 0;
 8035be8:	f884 3020 	strb.w	r3, [r4, #32]
    ConfirmQueueCtx.BufferEnd = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 8035bec:	e9c4 0001 	strd	r0, r0, [r4, #4]
    memset1( ( uint8_t* )ConfirmQueueCtx.Nvm.MlmeConfirmQueue, 0xFF, sizeof( ConfirmQueueCtx.Nvm.MlmeConfirmQueue ) );
 8035bf0:	f003 f986 	bl	8038f00 <memset1>

    // Common status
    ConfirmQueueCtx.Nvm.CommonStatus = LORAMAC_EVENT_INFO_STATUS_ERROR;
 8035bf4:	2301      	movs	r3, #1
 8035bf6:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
}
 8035bfa:	bd10      	pop	{r4, pc}
 8035bfc:	20005700 	.word	0x20005700

08035c00 <LoRaMacConfirmQueueAdd>:

bool LoRaMacConfirmQueueAdd( MlmeConfirmQueue_t* mlmeConfirm )
{
    if( IsListFull( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == true )
 8035c00:	4b0f      	ldr	r3, [pc, #60]	; (8035c40 <LoRaMacConfirmQueueAdd+0x40>)
    if( count >= LORA_MAC_MLME_CONFIRM_QUEUE_LEN )
 8035c02:	f893 2020 	ldrb.w	r2, [r3, #32]
 8035c06:	2a04      	cmp	r2, #4
 8035c08:	d817      	bhi.n	8035c3a <LoRaMacConfirmQueueAdd+0x3a>
        // Protect the buffer against overwrites
        return false;
    }

    // Add the element to the ring buffer
    ConfirmQueueCtx.BufferEnd->Request = mlmeConfirm->Request;
 8035c0a:	689a      	ldr	r2, [r3, #8]
 8035c0c:	7801      	ldrb	r1, [r0, #0]
 8035c0e:	7011      	strb	r1, [r2, #0]
    ConfirmQueueCtx.BufferEnd->Status = mlmeConfirm->Status;
 8035c10:	7841      	ldrb	r1, [r0, #1]
 8035c12:	7051      	strb	r1, [r2, #1]
    ConfirmQueueCtx.BufferEnd->RestrictCommonReadyToHandle = mlmeConfirm->RestrictCommonReadyToHandle;
 8035c14:	78c1      	ldrb	r1, [r0, #3]
 8035c16:	70d1      	strb	r1, [r2, #3]
    ConfirmQueueCtx.BufferEnd->ReadyToHandle = false;
 8035c18:	2100      	movs	r1, #0
 8035c1a:	7091      	strb	r1, [r2, #2]
    // Increase counter
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt++;
 8035c1c:	f893 1020 	ldrb.w	r1, [r3, #32]
 8035c20:	3101      	adds	r1, #1
 8035c22:	f883 1020 	strb.w	r1, [r3, #32]
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 8035c26:	f103 011c 	add.w	r1, r3, #28
 8035c2a:	428a      	cmp	r2, r1
        bufferPointer++;
 8035c2c:	bf14      	ite	ne
 8035c2e:	3204      	addne	r2, #4
        bufferPointer = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 8035c30:	f103 020c 	addeq.w	r2, r3, #12
    // Update end pointer
    ConfirmQueueCtx.BufferEnd = IncreaseBufferPointer( ConfirmQueueCtx.BufferEnd );
 8035c34:	609a      	str	r2, [r3, #8]
 8035c36:	2001      	movs	r0, #1
 8035c38:	4770      	bx	lr
        return false;
 8035c3a:	2000      	movs	r0, #0

    return true;
}
 8035c3c:	4770      	bx	lr
 8035c3e:	bf00      	nop
 8035c40:	20005700 	.word	0x20005700

08035c44 <LoRaMacConfirmQueueRemoveFirst>:
    return true;
}

bool LoRaMacConfirmQueueRemoveFirst( void )
{
    if( IsListEmpty( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == true )
 8035c44:	4b09      	ldr	r3, [pc, #36]	; (8035c6c <LoRaMacConfirmQueueRemoveFirst+0x28>)
 8035c46:	f893 0020 	ldrb.w	r0, [r3, #32]
    if( count == 0 )
 8035c4a:	b168      	cbz	r0, 8035c68 <LoRaMacConfirmQueueRemoveFirst+0x24>
    }

    // Increase counter
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt--;
    // Update start pointer
    ConfirmQueueCtx.BufferStart = IncreaseBufferPointer( ConfirmQueueCtx.BufferStart );
 8035c4c:	685a      	ldr	r2, [r3, #4]
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 8035c4e:	f103 011c 	add.w	r1, r3, #28
 8035c52:	428a      	cmp	r2, r1
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt--;
 8035c54:	f100 30ff 	add.w	r0, r0, #4294967295
        bufferPointer++;
 8035c58:	bf14      	ite	ne
 8035c5a:	3204      	addne	r2, #4
        bufferPointer = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 8035c5c:	f103 020c 	addeq.w	r2, r3, #12
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt--;
 8035c60:	f883 0020 	strb.w	r0, [r3, #32]
    ConfirmQueueCtx.BufferStart = IncreaseBufferPointer( ConfirmQueueCtx.BufferStart );
 8035c64:	605a      	str	r2, [r3, #4]

    return true;
 8035c66:	2001      	movs	r0, #1
}
 8035c68:	4770      	bx	lr
 8035c6a:	bf00      	nop
 8035c6c:	20005700 	.word	0x20005700

08035c70 <LoRaMacConfirmQueueSetStatus>:

void LoRaMacConfirmQueueSetStatus( LoRaMacEventInfoStatus_t status, Mlme_t request )
{
 8035c70:	b510      	push	{r4, lr}
    MlmeConfirmQueue_t* element = NULL;

    if( IsListEmpty( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == false )
 8035c72:	4b07      	ldr	r3, [pc, #28]	; (8035c90 <LoRaMacConfirmQueueSetStatus+0x20>)
    if( count == 0 )
 8035c74:	f893 2020 	ldrb.w	r2, [r3, #32]
{
 8035c78:	4604      	mov	r4, r0
 8035c7a:	4608      	mov	r0, r1
    if( count == 0 )
 8035c7c:	b132      	cbz	r2, 8035c8c <LoRaMacConfirmQueueSetStatus+0x1c>
    {
        element = GetElement( request, ConfirmQueueCtx.BufferStart, ConfirmQueueCtx.BufferEnd );
 8035c7e:	6859      	ldr	r1, [r3, #4]
 8035c80:	f7ff ff8c 	bl	8035b9c <GetElement.isra.0>
        if( element != NULL )
 8035c84:	b110      	cbz	r0, 8035c8c <LoRaMacConfirmQueueSetStatus+0x1c>
        {
            element->Status = status;
            element->ReadyToHandle = true;
 8035c86:	2301      	movs	r3, #1
            element->Status = status;
 8035c88:	7044      	strb	r4, [r0, #1]
            element->ReadyToHandle = true;
 8035c8a:	7083      	strb	r3, [r0, #2]
        }
    }
}
 8035c8c:	bd10      	pop	{r4, pc}
 8035c8e:	bf00      	nop
 8035c90:	20005700 	.word	0x20005700

08035c94 <LoRaMacConfirmQueueGetStatus>:

LoRaMacEventInfoStatus_t LoRaMacConfirmQueueGetStatus( Mlme_t request )
{
 8035c94:	b508      	push	{r3, lr}
    MlmeConfirmQueue_t* element = NULL;

    if( IsListEmpty( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == false )
 8035c96:	4b06      	ldr	r3, [pc, #24]	; (8035cb0 <LoRaMacConfirmQueueGetStatus+0x1c>)
    if( count == 0 )
 8035c98:	f893 2020 	ldrb.w	r2, [r3, #32]
 8035c9c:	b12a      	cbz	r2, 8035caa <LoRaMacConfirmQueueGetStatus+0x16>
    {
        element = GetElement( request, ConfirmQueueCtx.BufferStart, ConfirmQueueCtx.BufferEnd );
 8035c9e:	6859      	ldr	r1, [r3, #4]
 8035ca0:	f7ff ff7c 	bl	8035b9c <GetElement.isra.0>
        if( element != NULL )
 8035ca4:	b108      	cbz	r0, 8035caa <LoRaMacConfirmQueueGetStatus+0x16>
        {
            return element->Status;
 8035ca6:	7840      	ldrb	r0, [r0, #1]
        }
    }
    return LORAMAC_EVENT_INFO_STATUS_ERROR;
}
 8035ca8:	bd08      	pop	{r3, pc}
    return LORAMAC_EVENT_INFO_STATUS_ERROR;
 8035caa:	2001      	movs	r0, #1
 8035cac:	e7fc      	b.n	8035ca8 <LoRaMacConfirmQueueGetStatus+0x14>
 8035cae:	bf00      	nop
 8035cb0:	20005700 	.word	0x20005700

08035cb4 <LoRaMacConfirmQueueSetStatusCmn>:

void LoRaMacConfirmQueueSetStatusCmn( LoRaMacEventInfoStatus_t status )
{
 8035cb4:	b530      	push	{r4, r5, lr}
    MlmeConfirmQueue_t* element = ConfirmQueueCtx.BufferStart;
 8035cb6:	4a0a      	ldr	r2, [pc, #40]	; (8035ce0 <LoRaMacConfirmQueueSetStatusCmn+0x2c>)
    if( count == 0 )
 8035cb8:	f892 1020 	ldrb.w	r1, [r2, #32]
    MlmeConfirmQueue_t* element = ConfirmQueueCtx.BufferStart;
 8035cbc:	6853      	ldr	r3, [r2, #4]

    ConfirmQueueCtx.Nvm.CommonStatus = status;
 8035cbe:	f882 0021 	strb.w	r0, [r2, #33]	; 0x21
    if( count == 0 )
 8035cc2:	b161      	cbz	r1, 8035cde <LoRaMacConfirmQueueSetStatusCmn+0x2a>
            if( element->RestrictCommonReadyToHandle == false )
            {
                element->ReadyToHandle = true;
            }
            element = IncreaseBufferPointer( element );
        }while( element != ConfirmQueueCtx.BufferEnd );
 8035cc4:	6891      	ldr	r1, [r2, #8]
                element->ReadyToHandle = true;
 8035cc6:	2401      	movs	r4, #1
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 8035cc8:	321c      	adds	r2, #28
            if( element->RestrictCommonReadyToHandle == false )
 8035cca:	78dd      	ldrb	r5, [r3, #3]
            element->Status = status;
 8035ccc:	7058      	strb	r0, [r3, #1]
            if( element->RestrictCommonReadyToHandle == false )
 8035cce:	b905      	cbnz	r5, 8035cd2 <LoRaMacConfirmQueueSetStatusCmn+0x1e>
                element->ReadyToHandle = true;
 8035cd0:	709c      	strb	r4, [r3, #2]
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 8035cd2:	4293      	cmp	r3, r2
        bufferPointer = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 8035cd4:	bf0c      	ite	eq
 8035cd6:	4b03      	ldreq	r3, [pc, #12]	; (8035ce4 <LoRaMacConfirmQueueSetStatusCmn+0x30>)
        bufferPointer++;
 8035cd8:	3304      	addne	r3, #4
        }while( element != ConfirmQueueCtx.BufferEnd );
 8035cda:	4299      	cmp	r1, r3
 8035cdc:	d1f5      	bne.n	8035cca <LoRaMacConfirmQueueSetStatusCmn+0x16>
    }
}
 8035cde:	bd30      	pop	{r4, r5, pc}
 8035ce0:	20005700 	.word	0x20005700
 8035ce4:	2000570c 	.word	0x2000570c

08035ce8 <LoRaMacConfirmQueueIsCmdActive>:
{
    return ConfirmQueueCtx.Nvm.CommonStatus;
}

bool LoRaMacConfirmQueueIsCmdActive( Mlme_t request )
{
 8035ce8:	b508      	push	{r3, lr}
    if( GetElement( request, ConfirmQueueCtx.BufferStart, ConfirmQueueCtx.BufferEnd ) != NULL )
 8035cea:	4b04      	ldr	r3, [pc, #16]	; (8035cfc <LoRaMacConfirmQueueIsCmdActive+0x14>)
 8035cec:	6859      	ldr	r1, [r3, #4]
 8035cee:	f7ff ff55 	bl	8035b9c <GetElement.isra.0>
    {
        return true;
    }
    return false;
}
 8035cf2:	3800      	subs	r0, #0
 8035cf4:	bf18      	it	ne
 8035cf6:	2001      	movne	r0, #1
 8035cf8:	bd08      	pop	{r3, pc}
 8035cfa:	bf00      	nop
 8035cfc:	20005700 	.word	0x20005700

08035d00 <LoRaMacConfirmQueueHandleCb>:

void LoRaMacConfirmQueueHandleCb( MlmeConfirm_t* mlmeConfirm )
{
 8035d00:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    uint8_t nbElements = ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt;
 8035d04:	4d12      	ldr	r5, [pc, #72]	; (8035d50 <LoRaMacConfirmQueueHandleCb+0x50>)
 8035d06:	f895 8020 	ldrb.w	r8, [r5, #32]
{
 8035d0a:	4604      	mov	r4, r0
    bool readyToHandle = false;
    MlmeConfirmQueue_t mlmeConfirmToStore;

    for( uint8_t i = 0; i < nbElements; i++ )
 8035d0c:	2600      	movs	r6, #0
 8035d0e:	b2f3      	uxtb	r3, r6
 8035d10:	4598      	cmp	r8, r3
 8035d12:	d802      	bhi.n	8035d1a <LoRaMacConfirmQueueHandleCb+0x1a>
        {
            // Add a request which has not been finished again to the queue
            LoRaMacConfirmQueueAdd( &mlmeConfirmToStore );
        }
    }
}
 8035d14:	b002      	add	sp, #8
 8035d16:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        mlmeConfirm->MlmeRequest = ConfirmQueueCtx.BufferStart->Request;
 8035d1a:	686b      	ldr	r3, [r5, #4]
 8035d1c:	7819      	ldrb	r1, [r3, #0]
 8035d1e:	7021      	strb	r1, [r4, #0]
        mlmeConfirm->Status = ConfirmQueueCtx.BufferStart->Status;
 8035d20:	785a      	ldrb	r2, [r3, #1]
 8035d22:	7062      	strb	r2, [r4, #1]
        readyToHandle = ConfirmQueueCtx.BufferStart->ReadyToHandle;
 8035d24:	789f      	ldrb	r7, [r3, #2]
        if( readyToHandle == true )
 8035d26:	b15f      	cbz	r7, 8035d40 <LoRaMacConfirmQueueHandleCb+0x40>
            ConfirmQueueCtx.Primitives->MacMlmeConfirm( mlmeConfirm );
 8035d28:	682b      	ldr	r3, [r5, #0]
 8035d2a:	4620      	mov	r0, r4
 8035d2c:	689b      	ldr	r3, [r3, #8]
 8035d2e:	4798      	blx	r3
        LoRaMacConfirmQueueRemoveFirst( );
 8035d30:	f7ff ff88 	bl	8035c44 <LoRaMacConfirmQueueRemoveFirst>
        if( readyToHandle == false )
 8035d34:	b917      	cbnz	r7, 8035d3c <LoRaMacConfirmQueueHandleCb+0x3c>
            LoRaMacConfirmQueueAdd( &mlmeConfirmToStore );
 8035d36:	a801      	add	r0, sp, #4
 8035d38:	f7ff ff62 	bl	8035c00 <LoRaMacConfirmQueueAdd>
    for( uint8_t i = 0; i < nbElements; i++ )
 8035d3c:	3601      	adds	r6, #1
 8035d3e:	e7e6      	b.n	8035d0e <LoRaMacConfirmQueueHandleCb+0xe>
            mlmeConfirmToStore.RestrictCommonReadyToHandle = ConfirmQueueCtx.BufferStart->RestrictCommonReadyToHandle;
 8035d40:	78db      	ldrb	r3, [r3, #3]
            mlmeConfirmToStore.Request = ConfirmQueueCtx.BufferStart->Request;
 8035d42:	f88d 1004 	strb.w	r1, [sp, #4]
            mlmeConfirmToStore.Status = ConfirmQueueCtx.BufferStart->Status;
 8035d46:	f88d 2005 	strb.w	r2, [sp, #5]
            mlmeConfirmToStore.RestrictCommonReadyToHandle = ConfirmQueueCtx.BufferStart->RestrictCommonReadyToHandle;
 8035d4a:	f88d 3007 	strb.w	r3, [sp, #7]
 8035d4e:	e7ef      	b.n	8035d30 <LoRaMacConfirmQueueHandleCb+0x30>
 8035d50:	20005700 	.word	0x20005700

08035d54 <LoRaMacConfirmQueueGetCnt>:

uint8_t LoRaMacConfirmQueueGetCnt( void )
{
    return ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt;
}
 8035d54:	4b01      	ldr	r3, [pc, #4]	; (8035d5c <LoRaMacConfirmQueueGetCnt+0x8>)
 8035d56:	f893 0020 	ldrb.w	r0, [r3, #32]
 8035d5a:	4770      	bx	lr
 8035d5c:	20005700 	.word	0x20005700

08035d60 <LoRaMacConfirmQueueIsFull>:

bool LoRaMacConfirmQueueIsFull( void )
{
    if( IsListFull( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == true )
 8035d60:	4b03      	ldr	r3, [pc, #12]	; (8035d70 <LoRaMacConfirmQueueIsFull+0x10>)
    if( count >= LORA_MAC_MLME_CONFIRM_QUEUE_LEN )
 8035d62:	f893 0020 	ldrb.w	r0, [r3, #32]
    }
    else
    {
        return false;
    }
}
 8035d66:	2804      	cmp	r0, #4
 8035d68:	bf94      	ite	ls
 8035d6a:	2000      	movls	r0, #0
 8035d6c:	2001      	movhi	r0, #1
 8035d6e:	4770      	bx	lr
 8035d70:	20005700 	.word	0x20005700

08035d74 <DeriveSessionKey10x>:
 * \param[IN]  netID          - Network Identifier
 * \param[IN]  deviceNonce    - Device nonce
 * \retval                    - Status of the operation
 */
static LoRaMacCryptoStatus_t DeriveSessionKey10x( KeyIdentifier_t keyID, uint32_t joinNonce, uint32_t netID, uint16_t devNonce )
{
 8035d74:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    uint8_t compBase[16] = { 0 };
 8035d76:	2400      	movs	r4, #0
 8035d78:	e9cd 4402 	strd	r4, r4, [sp, #8]

    /* ST_WORKAROUND_BEGIN: integrate 1.1.x keys only if required */
    switch( keyID )
 8035d7c:	1e44      	subs	r4, r0, #1
 8035d7e:	f88d 4000 	strb.w	r4, [sp]
        default:
            return LORAMAC_CRYPTO_ERROR_INVALID_KEY_ID;
    }
   /* ST_WORKAROUND_END */

    compBase[1] = ( uint8_t )( ( joinNonce >> 0 ) & 0xFF );
 8035d82:	f88d 1001 	strb.w	r1, [sp, #1]
    compBase[2] = ( uint8_t )( ( joinNonce >> 8 ) & 0xFF );
 8035d86:	0a0c      	lsrs	r4, r1, #8
    compBase[3] = ( uint8_t )( ( joinNonce >> 16 ) & 0xFF );

    compBase[4] = ( uint8_t )( ( netID >> 0 ) & 0xFF );
 8035d88:	f8ad 2004 	strh.w	r2, [sp, #4]
    compBase[3] = ( uint8_t )( ( joinNonce >> 16 ) & 0xFF );
 8035d8c:	0c09      	lsrs	r1, r1, #16
    compBase[5] = ( uint8_t )( ( netID >> 8 ) & 0xFF );
    compBase[6] = ( uint8_t )( ( netID >> 16 ) & 0xFF );
 8035d8e:	0c12      	lsrs	r2, r2, #16
    compBase[3] = ( uint8_t )( ( joinNonce >> 16 ) & 0xFF );
 8035d90:	f88d 1003 	strb.w	r1, [sp, #3]
    compBase[6] = ( uint8_t )( ( netID >> 16 ) & 0xFF );
 8035d94:	f88d 2006 	strb.w	r2, [sp, #6]

    compBase[7] = ( uint8_t )( ( devNonce >> 0 ) & 0xFF );
 8035d98:	f88d 3007 	strb.w	r3, [sp, #7]
    compBase[8] = ( uint8_t )( ( devNonce >> 8 ) & 0xFF );

    if( SecureElementDeriveAndStoreKey( compBase, NWK_KEY, keyID ) != SECURE_ELEMENT_SUCCESS )
 8035d9c:	4602      	mov	r2, r0
    compBase[8] = ( uint8_t )( ( devNonce >> 8 ) & 0xFF );
 8035d9e:	0a1b      	lsrs	r3, r3, #8
    if( SecureElementDeriveAndStoreKey( compBase, NWK_KEY, keyID ) != SECURE_ELEMENT_SUCCESS )
 8035da0:	2101      	movs	r1, #1
 8035da2:	4668      	mov	r0, sp
    compBase[2] = ( uint8_t )( ( joinNonce >> 8 ) & 0xFF );
 8035da4:	f88d 4002 	strb.w	r4, [sp, #2]
    compBase[8] = ( uint8_t )( ( devNonce >> 8 ) & 0xFF );
 8035da8:	f88d 3008 	strb.w	r3, [sp, #8]
    if( SecureElementDeriveAndStoreKey( compBase, NWK_KEY, keyID ) != SECURE_ELEMENT_SUCCESS )
 8035dac:	f002 ffa0 	bl	8038cf0 <SecureElementDeriveAndStoreKey>
 8035db0:	2800      	cmp	r0, #0
    {
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
    }

    return LORAMAC_CRYPTO_SUCCESS;
}
 8035db2:	bf18      	it	ne
 8035db4:	200f      	movne	r0, #15
 8035db6:	b004      	add	sp, #16
 8035db8:	bd10      	pop	{r4, pc}

08035dba <PayloadEncrypt>:
{
 8035dba:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8035dbe:	b088      	sub	sp, #32
 8035dc0:	4617      	mov	r7, r2
 8035dc2:	460d      	mov	r5, r1
 8035dc4:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    if( buffer == 0 )
 8035dc6:	4606      	mov	r6, r0
 8035dc8:	2800      	cmp	r0, #0
 8035dca:	d04d      	beq.n	8035e68 <PayloadEncrypt+0xae>
    uint8_t sBlock[16] = { 0 };
 8035dcc:	2400      	movs	r4, #0
    aBlock[0] = 0x01;
 8035dce:	2101      	movs	r1, #1
    uint8_t aBlock[16] = { 0 };
 8035dd0:	e9cd 4404 	strd	r4, r4, [sp, #16]
    aBlock[0] = 0x01;
 8035dd4:	f88d 1010 	strb.w	r1, [sp, #16]
    aBlock[5] = dir;
 8035dd8:	f89d 1038 	ldrb.w	r1, [sp, #56]	; 0x38
 8035ddc:	f88d 1015 	strb.w	r1, [sp, #21]
    aBlock[6] = address & 0xFF;
 8035de0:	f8ad 3016 	strh.w	r3, [sp, #22]
    aBlock[8] = ( address >> 16 ) & 0xFF;
 8035de4:	0c19      	lsrs	r1, r3, #16
    uint8_t sBlock[16] = { 0 };
 8035de6:	e9cd 4400 	strd	r4, r4, [sp]
    aBlock[9] = ( address >> 24 ) & 0xFF;
 8035dea:	0e1b      	lsrs	r3, r3, #24
    uint8_t sBlock[16] = { 0 };
 8035dec:	e9cd 4402 	strd	r4, r4, [sp, #8]
    aBlock[9] = ( address >> 24 ) & 0xFF;
 8035df0:	f88d 3019 	strb.w	r3, [sp, #25]
    aBlock[10] = frameCounter & 0xFF;
 8035df4:	f8ad 201a 	strh.w	r2, [sp, #26]
    aBlock[12] = ( frameCounter >> 16 ) & 0xFF;
 8035df8:	0c13      	lsrs	r3, r2, #16
    aBlock[13] = ( frameCounter >> 24 ) & 0xFF;
 8035dfa:	0e12      	lsrs	r2, r2, #24
    uint8_t aBlock[16] = { 0 };
 8035dfc:	9407      	str	r4, [sp, #28]
    aBlock[8] = ( address >> 16 ) & 0xFF;
 8035dfe:	f88d 1018 	strb.w	r1, [sp, #24]
    aBlock[12] = ( frameCounter >> 16 ) & 0xFF;
 8035e02:	f88d 301c 	strb.w	r3, [sp, #28]
    aBlock[13] = ( frameCounter >> 24 ) & 0xFF;
 8035e06:	f88d 201d 	strb.w	r2, [sp, #29]
    while( size > 0 )
 8035e0a:	b2e3      	uxtb	r3, r4
 8035e0c:	ea4f 1803 	mov.w	r8, r3, lsl #4
 8035e10:	2d00      	cmp	r5, #0
 8035e12:	fa5f f888 	uxtb.w	r8, r8
 8035e16:	dc03      	bgt.n	8035e20 <PayloadEncrypt+0x66>
    return LORAMAC_CRYPTO_SUCCESS;
 8035e18:	2000      	movs	r0, #0
}
 8035e1a:	b008      	add	sp, #32
 8035e1c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        aBlock[15] = ctr & 0xFF;
 8035e20:	3301      	adds	r3, #1
        if( SecureElementAesEncrypt( aBlock, 16, keyID, sBlock ) != SECURE_ELEMENT_SUCCESS )
 8035e22:	2110      	movs	r1, #16
        aBlock[15] = ctr & 0xFF;
 8035e24:	f88d 301f 	strb.w	r3, [sp, #31]
        if( SecureElementAesEncrypt( aBlock, 16, keyID, sBlock ) != SECURE_ELEMENT_SUCCESS )
 8035e28:	463a      	mov	r2, r7
 8035e2a:	466b      	mov	r3, sp
 8035e2c:	eb0d 0001 	add.w	r0, sp, r1
 8035e30:	f002 fe76 	bl	8038b20 <SecureElementAesEncrypt>
 8035e34:	4603      	mov	r3, r0
 8035e36:	b9c8      	cbnz	r0, 8035e6c <PayloadEncrypt+0xb2>
        for( uint8_t i = 0; i < ( ( size > 16 ) ? 16 : size ); i++ )
 8035e38:	2d10      	cmp	r5, #16
 8035e3a:	46ac      	mov	ip, r5
 8035e3c:	bfa8      	it	ge
 8035e3e:	f04f 0c10 	movge.w	ip, #16
 8035e42:	b2da      	uxtb	r2, r3
 8035e44:	4562      	cmp	r2, ip
 8035e46:	f103 0301 	add.w	r3, r3, #1
 8035e4a:	db03      	blt.n	8035e54 <PayloadEncrypt+0x9a>
        size -= 16;
 8035e4c:	3d10      	subs	r5, #16
 8035e4e:	b22d      	sxth	r5, r5
        bufferIndex += 16;
 8035e50:	3401      	adds	r4, #1
 8035e52:	e7da      	b.n	8035e0a <PayloadEncrypt+0x50>
            buffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i];
 8035e54:	a908      	add	r1, sp, #32
 8035e56:	eb08 0002 	add.w	r0, r8, r2
 8035e5a:	440a      	add	r2, r1
 8035e5c:	5c31      	ldrb	r1, [r6, r0]
 8035e5e:	f812 2c20 	ldrb.w	r2, [r2, #-32]
 8035e62:	404a      	eors	r2, r1
 8035e64:	5432      	strb	r2, [r6, r0]
        for( uint8_t i = 0; i < ( ( size > 16 ) ? 16 : size ); i++ )
 8035e66:	e7ec      	b.n	8035e42 <PayloadEncrypt+0x88>
        return LORAMAC_CRYPTO_ERROR_NPE;
 8035e68:	200a      	movs	r0, #10
 8035e6a:	e7d6      	b.n	8035e1a <PayloadEncrypt+0x60>
            return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 8035e6c:	200f      	movs	r0, #15
 8035e6e:	e7d4      	b.n	8035e1a <PayloadEncrypt+0x60>

08035e70 <GetLastFcntDown>:
{
    if( lastDown == NULL )
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
    }
    switch( fCntID )
 8035e70:	3801      	subs	r0, #1
 8035e72:	2803      	cmp	r0, #3
 8035e74:	d81c      	bhi.n	8035eb0 <GetLastFcntDown+0x40>
 8035e76:	e8df f000 	tbb	[pc, r0]
 8035e7a:	0a02      	.short	0x0a02
 8035e7c:	1610      	.short	0x1610
    {
        case N_FCNT_DOWN:
            *lastDown = CryptoNvm->FCntList.NFCntDown;
 8035e7e:	4b0d      	ldr	r3, [pc, #52]	; (8035eb4 <GetLastFcntDown+0x44>)
 8035e80:	681b      	ldr	r3, [r3, #0]
 8035e82:	691a      	ldr	r2, [r3, #16]
 8035e84:	600a      	str	r2, [r1, #0]
            CryptoNvm->LastDownFCnt = CryptoNvm->FCntList.NFCntDown;
 8035e86:	691a      	ldr	r2, [r3, #16]
            break;
        case A_FCNT_DOWN:
            *lastDown = CryptoNvm->FCntList.AFCntDown;
            CryptoNvm->LastDownFCnt = CryptoNvm->FCntList.AFCntDown;
 8035e88:	621a      	str	r2, [r3, #32]
            break;
#endif /* LORAMAC_MAX_MC_CTX > 3 */
        default:
            return LORAMAC_CRYPTO_FAIL_FCNT_ID;
    }
    return LORAMAC_CRYPTO_SUCCESS;
 8035e8a:	2000      	movs	r0, #0
            break;
 8035e8c:	4770      	bx	lr
            *lastDown = CryptoNvm->FCntList.AFCntDown;
 8035e8e:	4b09      	ldr	r3, [pc, #36]	; (8035eb4 <GetLastFcntDown+0x44>)
 8035e90:	681b      	ldr	r3, [r3, #0]
 8035e92:	695a      	ldr	r2, [r3, #20]
 8035e94:	600a      	str	r2, [r1, #0]
            CryptoNvm->LastDownFCnt = CryptoNvm->FCntList.AFCntDown;
 8035e96:	695a      	ldr	r2, [r3, #20]
 8035e98:	e7f6      	b.n	8035e88 <GetLastFcntDown+0x18>
            *lastDown = CryptoNvm->FCntList.FCntDown;
 8035e9a:	4b06      	ldr	r3, [pc, #24]	; (8035eb4 <GetLastFcntDown+0x44>)
 8035e9c:	681b      	ldr	r3, [r3, #0]
 8035e9e:	699a      	ldr	r2, [r3, #24]
 8035ea0:	600a      	str	r2, [r1, #0]
            CryptoNvm->LastDownFCnt = CryptoNvm->FCntList.FCntDown;
 8035ea2:	699a      	ldr	r2, [r3, #24]
 8035ea4:	e7f0      	b.n	8035e88 <GetLastFcntDown+0x18>
            *lastDown = CryptoNvm->FCntList.McFCntDown[0];
 8035ea6:	4b03      	ldr	r3, [pc, #12]	; (8035eb4 <GetLastFcntDown+0x44>)
 8035ea8:	681b      	ldr	r3, [r3, #0]
 8035eaa:	69db      	ldr	r3, [r3, #28]
 8035eac:	600b      	str	r3, [r1, #0]
            break;
 8035eae:	e7ec      	b.n	8035e8a <GetLastFcntDown+0x1a>
            CryptoNvm->LastDownFCnt = CryptoNvm->FCntList.NFCntDown;
 8035eb0:	2005      	movs	r0, #5
}
 8035eb2:	4770      	bx	lr
 8035eb4:	20005724 	.word	0x20005724

08035eb8 <LoRaMacCryptoDeriveMcKEKey.part.0>:
    }

    return LORAMAC_CRYPTO_SUCCESS;
}

LoRaMacCryptoStatus_t LoRaMacCryptoDeriveMcKEKey( KeyIdentifier_t keyID )
 8035eb8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    // Prevent other keys than McRootKey
    if( keyID != MC_ROOT_KEY )
    {
        return LORAMAC_CRYPTO_ERROR_INVALID_KEY_ID;
    }
    uint8_t compBase[16] = { 0 };
 8035eba:	2300      	movs	r3, #0

    if( SecureElementDeriveAndStoreKey( compBase, keyID, MC_KE_KEY ) != SECURE_ELEMENT_SUCCESS )
 8035ebc:	227f      	movs	r2, #127	; 0x7f
 8035ebe:	2104      	movs	r1, #4
 8035ec0:	4668      	mov	r0, sp
    uint8_t compBase[16] = { 0 };
 8035ec2:	e9cd 3300 	strd	r3, r3, [sp]
 8035ec6:	e9cd 3302 	strd	r3, r3, [sp, #8]
    if( SecureElementDeriveAndStoreKey( compBase, keyID, MC_KE_KEY ) != SECURE_ELEMENT_SUCCESS )
 8035eca:	f002 ff11 	bl	8038cf0 <SecureElementDeriveAndStoreKey>
 8035ece:	2800      	cmp	r0, #0
    {
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
    }

    return LORAMAC_CRYPTO_SUCCESS;
}
 8035ed0:	bf18      	it	ne
 8035ed2:	200f      	movne	r0, #15
 8035ed4:	b005      	add	sp, #20
 8035ed6:	f85d fb04 	ldr.w	pc, [sp], #4

08035eda <VerifyCmacB0.isra.0.constprop.0>:
static LoRaMacCryptoStatus_t VerifyCmacB0( uint8_t* msg, uint16_t len, KeyIdentifier_t keyID, bool isAck, uint8_t dir, uint32_t devAddr, uint32_t fCnt, uint32_t expectedCmac )
 8035eda:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8035ede:	b0c4      	sub	sp, #272	; 0x110
 8035ee0:	460c      	mov	r4, r1
 8035ee2:	9e4a      	ldr	r6, [sp, #296]	; 0x128
 8035ee4:	4617      	mov	r7, r2
 8035ee6:	461d      	mov	r5, r3
    if( msg == 0 )
 8035ee8:	4680      	mov	r8, r0
 8035eea:	b3b8      	cbz	r0, 8035f5c <VerifyCmacB0.isra.0.constprop.0+0x82>
    if( len > CRYPTO_MAXMESSAGE_SIZE )
 8035eec:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 8035ef0:	d836      	bhi.n	8035f60 <VerifyCmacB0.isra.0.constprop.0+0x86>
    memset1( micBuff, 0, CRYPTO_BUFFER_SIZE );
 8035ef2:	f44f 7288 	mov.w	r2, #272	; 0x110
 8035ef6:	2100      	movs	r1, #0
 8035ef8:	4668      	mov	r0, sp
 8035efa:	f003 f801 	bl	8038f00 <memset1>
    b0[0] = 0x49;
 8035efe:	2349      	movs	r3, #73	; 0x49
 8035f00:	9300      	str	r3, [sp, #0]
    b0[4] = 0x00;
 8035f02:	f44f 7380 	mov.w	r3, #256	; 0x100
 8035f06:	f8ad 3004 	strh.w	r3, [sp, #4]
    b0[8] = ( devAddr >> 16 ) & 0xFF;
 8035f0a:	0c2b      	lsrs	r3, r5, #16
 8035f0c:	f88d 3008 	strb.w	r3, [sp, #8]
    b0[12] = ( fCnt >> 16 ) & 0xFF;
 8035f10:	0c33      	lsrs	r3, r6, #16
    b0[6] = devAddr & 0xFF;
 8035f12:	f8ad 5006 	strh.w	r5, [sp, #6]
    b0[10] = fCnt & 0xFF;
 8035f16:	f8ad 600a 	strh.w	r6, [sp, #10]
    b0[12] = ( fCnt >> 16 ) & 0xFF;
 8035f1a:	f88d 300c 	strb.w	r3, [sp, #12]
    memcpy1( ( micBuff + MIC_BLOCK_BX_SIZE ), msg, len );
 8035f1e:	4622      	mov	r2, r4
    b0[14] = 0x00;
 8035f20:	2300      	movs	r3, #0
    memcpy1( ( micBuff + MIC_BLOCK_BX_SIZE ), msg, len );
 8035f22:	4641      	mov	r1, r8
 8035f24:	a804      	add	r0, sp, #16
    b0[9] = ( devAddr >> 24 ) & 0xFF;
 8035f26:	0e2d      	lsrs	r5, r5, #24
    b0[13] = ( fCnt >> 24 ) & 0xFF;
 8035f28:	0e36      	lsrs	r6, r6, #24
    b0[14] = 0x00;
 8035f2a:	f88d 300e 	strb.w	r3, [sp, #14]
    b0[9] = ( devAddr >> 24 ) & 0xFF;
 8035f2e:	f88d 5009 	strb.w	r5, [sp, #9]
    b0[13] = ( fCnt >> 24 ) & 0xFF;
 8035f32:	f88d 600d 	strb.w	r6, [sp, #13]
    b0[15] = msgLen & 0xFF;
 8035f36:	f88d 400f 	strb.w	r4, [sp, #15]
    memcpy1( ( micBuff + MIC_BLOCK_BX_SIZE ), msg, len );
 8035f3a:	f002 ffcd 	bl	8038ed8 <memcpy1>
    retval = SecureElementVerifyAesCmac( micBuff, ( len + MIC_BLOCK_BX_SIZE ), expectedCmac, keyID );
 8035f3e:	f104 0110 	add.w	r1, r4, #16
 8035f42:	9a4b      	ldr	r2, [sp, #300]	; 0x12c
 8035f44:	463b      	mov	r3, r7
 8035f46:	b289      	uxth	r1, r1
 8035f48:	4668      	mov	r0, sp
 8035f4a:	f002 fdab 	bl	8038aa4 <SecureElementVerifyAesCmac>
    if( retval == SECURE_ELEMENT_SUCCESS )
 8035f4e:	b110      	cbz	r0, 8035f56 <VerifyCmacB0.isra.0.constprop.0+0x7c>
    return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 8035f50:	2801      	cmp	r0, #1
 8035f52:	bf18      	it	ne
 8035f54:	200f      	movne	r0, #15
}
 8035f56:	b044      	add	sp, #272	; 0x110
 8035f58:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return LORAMAC_CRYPTO_ERROR_NPE;
 8035f5c:	200a      	movs	r0, #10
 8035f5e:	e7fa      	b.n	8035f56 <VerifyCmacB0.isra.0.constprop.0+0x7c>
        return LORAMAC_CRYPTO_ERROR_BUF_SIZE;
 8035f60:	200e      	movs	r0, #14
 8035f62:	e7f8      	b.n	8035f56 <VerifyCmacB0.isra.0.constprop.0+0x7c>

08035f64 <LoRaMacCryptoInit>:
{
 8035f64:	b510      	push	{r4, lr}
    if( nvm == NULL )
 8035f66:	b190      	cbz	r0, 8035f8e <LoRaMacCryptoInit+0x2a>
    CryptoNvm = nvm;
 8035f68:	4c0a      	ldr	r4, [pc, #40]	; (8035f94 <LoRaMacCryptoInit+0x30>)
    memset1( ( uint8_t* )CryptoNvm, 0, sizeof( LoRaMacCryptoNvmData_t ) );
 8035f6a:	2228      	movs	r2, #40	; 0x28
 8035f6c:	2100      	movs	r1, #0
    CryptoNvm = nvm;
 8035f6e:	6020      	str	r0, [r4, #0]
    memset1( ( uint8_t* )CryptoNvm, 0, sizeof( LoRaMacCryptoNvmData_t ) );
 8035f70:	f002 ffc6 	bl	8038f00 <memset1>
    CryptoNvm->LrWanVersion.Fields.Major = 1;
 8035f74:	6823      	ldr	r3, [r4, #0]
    CryptoNvm->LrWanVersion.Fields.Revision = 0;
 8035f76:	4a08      	ldr	r2, [pc, #32]	; (8035f98 <LoRaMacCryptoInit+0x34>)
 8035f78:	601a      	str	r2, [r3, #0]
    CryptoNvm->FCntList.NFCntDown = FCNT_DOWN_INITAL_VALUE;
 8035f7a:	2000      	movs	r0, #0
 8035f7c:	f04f 32ff 	mov.w	r2, #4294967295
 8035f80:	e9c3 0203 	strd	r0, r2, [r3, #12]
    CryptoNvm->FCntList.FCntDown = FCNT_DOWN_INITAL_VALUE;
 8035f84:	e9c3 2205 	strd	r2, r2, [r3, #20]
        CryptoNvm->FCntList.McFCntDown[i] = FCNT_DOWN_INITAL_VALUE;
 8035f88:	e9c3 2207 	strd	r2, r2, [r3, #28]
}
 8035f8c:	bd10      	pop	{r4, pc}
        return LORAMAC_CRYPTO_FAIL_PARAM;
 8035f8e:	2009      	movs	r0, #9
 8035f90:	e7fc      	b.n	8035f8c <LoRaMacCryptoInit+0x28>
 8035f92:	bf00      	nop
 8035f94:	20005724 	.word	0x20005724
 8035f98:	01010100 	.word	0x01010100

08035f9c <LoRaMacCryptoSetLrWanVersion>:
    CryptoNvm->LrWanVersion = version;
 8035f9c:	4b02      	ldr	r3, [pc, #8]	; (8035fa8 <LoRaMacCryptoSetLrWanVersion+0xc>)
 8035f9e:	681b      	ldr	r3, [r3, #0]
 8035fa0:	6018      	str	r0, [r3, #0]
}
 8035fa2:	2000      	movs	r0, #0
 8035fa4:	4770      	bx	lr
 8035fa6:	bf00      	nop
 8035fa8:	20005724 	.word	0x20005724

08035fac <LoRaMacCryptoGetFCntUp>:
    if( currentUp == NULL )
 8035fac:	b130      	cbz	r0, 8035fbc <LoRaMacCryptoGetFCntUp+0x10>
    *currentUp = CryptoNvm->FCntList.FCntUp + 1;
 8035fae:	4b04      	ldr	r3, [pc, #16]	; (8035fc0 <LoRaMacCryptoGetFCntUp+0x14>)
 8035fb0:	681b      	ldr	r3, [r3, #0]
 8035fb2:	68db      	ldr	r3, [r3, #12]
 8035fb4:	3301      	adds	r3, #1
 8035fb6:	6003      	str	r3, [r0, #0]
    return LORAMAC_CRYPTO_SUCCESS;
 8035fb8:	2000      	movs	r0, #0
 8035fba:	4770      	bx	lr
        return LORAMAC_CRYPTO_ERROR_NPE;
 8035fbc:	200a      	movs	r0, #10
}
 8035fbe:	4770      	bx	lr
 8035fc0:	20005724 	.word	0x20005724

08035fc4 <LoRaMacCryptoGetFCntDown>:
{
 8035fc4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8035fc6:	4617      	mov	r7, r2
    uint32_t lastDown = 0;
 8035fc8:	2200      	movs	r2, #0
{
 8035fca:	460e      	mov	r6, r1
    uint32_t lastDown = 0;
 8035fcc:	9201      	str	r2, [sp, #4]
    if( currentDown == NULL )
 8035fce:	461c      	mov	r4, r3
 8035fd0:	b353      	cbz	r3, 8036028 <LoRaMacCryptoGetFCntDown+0x64>
    cryptoStatus = GetLastFcntDown( fCntID, &lastDown );
 8035fd2:	a901      	add	r1, sp, #4
 8035fd4:	f7ff ff4c 	bl	8035e70 <GetLastFcntDown>
    if( cryptoStatus != LORAMAC_CRYPTO_SUCCESS )
 8035fd8:	b9e8      	cbnz	r0, 8036016 <LoRaMacCryptoGetFCntDown+0x52>
    if( lastDown == FCNT_DOWN_INITAL_VALUE )
 8035fda:	9d01      	ldr	r5, [sp, #4]
 8035fdc:	1c6b      	adds	r3, r5, #1
 8035fde:	d110      	bne.n	8036002 <LoRaMacCryptoGetFCntDown+0x3e>
        *currentDown = frameFcnt;
 8035fe0:	6027      	str	r7, [r4, #0]
    if( CryptoNvm->LrWanVersion.Fields.Minor == 0 )
 8035fe2:	4b12      	ldr	r3, [pc, #72]	; (803602c <LoRaMacCryptoGetFCntDown+0x68>)
 8035fe4:	681b      	ldr	r3, [r3, #0]
 8035fe6:	789b      	ldrb	r3, [r3, #2]
 8035fe8:	b9ab      	cbnz	r3, 8036016 <LoRaMacCryptoGetFCntDown+0x52>
        if( ( ( int64_t )*currentDown - ( int64_t )lastDown ) >= maxFCntGap )
 8035fea:	6822      	ldr	r2, [r4, #0]
 8035fec:	b2b6      	uxth	r6, r6
 8035fee:	1b52      	subs	r2, r2, r5
 8035ff0:	eb62 0302 	sbc.w	r3, r2, r2
 8035ff4:	2700      	movs	r7, #0
 8035ff6:	42b2      	cmp	r2, r6
 8035ff8:	41bb      	sbcs	r3, r7
            return LORAMAC_CRYPTO_FAIL_MAX_GAP_FCNT;
 8035ffa:	bfb4      	ite	lt
 8035ffc:	2000      	movlt	r0, #0
 8035ffe:	2008      	movge	r0, #8
 8036000:	e009      	b.n	8036016 <LoRaMacCryptoGetFCntDown+0x52>
        fCntDiff = ( int32_t )( ( int64_t )frameFcnt - ( int64_t )( lastDown & 0x0000FFFF ) );
 8036002:	b2a9      	uxth	r1, r5
 8036004:	1a79      	subs	r1, r7, r1
        if( fCntDiff > 0 )
 8036006:	2900      	cmp	r1, #0
 8036008:	dd02      	ble.n	8036010 <LoRaMacCryptoGetFCntDown+0x4c>
            *currentDown = lastDown + fCntDiff;
 803600a:	4429      	add	r1, r5
 803600c:	6021      	str	r1, [r4, #0]
 803600e:	e7e8      	b.n	8035fe2 <LoRaMacCryptoGetFCntDown+0x1e>
        else if( fCntDiff == 0 )
 8036010:	d103      	bne.n	803601a <LoRaMacCryptoGetFCntDown+0x56>
            *currentDown = lastDown;
 8036012:	6025      	str	r5, [r4, #0]
            return LORAMAC_CRYPTO_FAIL_FCNT_DUPLICATED;
 8036014:	2007      	movs	r0, #7
}
 8036016:	b003      	add	sp, #12
 8036018:	bdf0      	pop	{r4, r5, r6, r7, pc}
            *currentDown = ( lastDown & 0xFFFF0000 ) + 0x10000 + frameFcnt;
 803601a:	0c2b      	lsrs	r3, r5, #16
 803601c:	041b      	lsls	r3, r3, #16
 803601e:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 8036022:	443b      	add	r3, r7
 8036024:	6023      	str	r3, [r4, #0]
 8036026:	e7dc      	b.n	8035fe2 <LoRaMacCryptoGetFCntDown+0x1e>
        return LORAMAC_CRYPTO_ERROR_NPE;
 8036028:	200a      	movs	r0, #10
 803602a:	e7f4      	b.n	8036016 <LoRaMacCryptoGetFCntDown+0x52>
 803602c:	20005724 	.word	0x20005724

08036030 <LoRaMacCryptoSetMulticastReference>:
    if( multicastList == NULL )
 8036030:	b128      	cbz	r0, 803603e <LoRaMacCryptoSetMulticastReference+0xe>
        multicastList[i].DownLinkCounter = &CryptoNvm->FCntList.McFCntDown[i];
 8036032:	4b04      	ldr	r3, [pc, #16]	; (8036044 <LoRaMacCryptoSetMulticastReference+0x14>)
 8036034:	681b      	ldr	r3, [r3, #0]
 8036036:	331c      	adds	r3, #28
 8036038:	6203      	str	r3, [r0, #32]
    return LORAMAC_CRYPTO_SUCCESS;
 803603a:	2000      	movs	r0, #0
 803603c:	4770      	bx	lr
        return LORAMAC_CRYPTO_ERROR_NPE;
 803603e:	200a      	movs	r0, #10
}
 8036040:	4770      	bx	lr
 8036042:	bf00      	nop
 8036044:	20005724 	.word	0x20005724

08036048 <LoRaMacCryptoPrepareJoinRequest>:
{
 8036048:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    if( macMsg == 0 )
 803604a:	4604      	mov	r4, r0
 803604c:	b1f0      	cbz	r0, 803608c <LoRaMacCryptoPrepareJoinRequest+0x44>
    uint32_t devNonce = 0;
 803604e:	2300      	movs	r3, #0
    SecureElementRandomNumber( &devNonce );
 8036050:	a803      	add	r0, sp, #12
    uint32_t devNonce = 0;
 8036052:	9303      	str	r3, [sp, #12]
    SecureElementRandomNumber( &devNonce );
 8036054:	f002 fee6 	bl	8038e24 <SecureElementRandomNumber>
    CryptoNvm->DevNonce = devNonce;
 8036058:	4a0e      	ldr	r2, [pc, #56]	; (8036094 <LoRaMacCryptoPrepareJoinRequest+0x4c>)
 803605a:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 803605e:	6812      	ldr	r2, [r2, #0]
    if( LoRaMacSerializerJoinRequest( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 8036060:	4620      	mov	r0, r4
    CryptoNvm->DevNonce = devNonce;
 8036062:	8093      	strh	r3, [r2, #4]
    macMsg->DevNonce = CryptoNvm->DevNonce;
 8036064:	82e3      	strh	r3, [r4, #22]
    if( LoRaMacSerializerJoinRequest( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 8036066:	f000 fa82 	bl	803656e <LoRaMacSerializerJoinRequest>
 803606a:	b960      	cbnz	r0, 8036086 <LoRaMacCryptoPrepareJoinRequest+0x3e>
    if( SecureElementComputeAesCmac( NULL, macMsg->Buffer, ( LORAMAC_JOIN_REQ_MSG_SIZE - LORAMAC_MIC_FIELD_SIZE ), micComputationKeyID, &macMsg->MIC ) != SECURE_ELEMENT_SUCCESS )
 803606c:	f104 0318 	add.w	r3, r4, #24
 8036070:	9300      	str	r3, [sp, #0]
 8036072:	6821      	ldr	r1, [r4, #0]
 8036074:	2301      	movs	r3, #1
 8036076:	2213      	movs	r2, #19
 8036078:	f002 fcae 	bl	80389d8 <SecureElementComputeAesCmac>
 803607c:	b940      	cbnz	r0, 8036090 <LoRaMacCryptoPrepareJoinRequest+0x48>
    if( LoRaMacSerializerJoinRequest( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 803607e:	4620      	mov	r0, r4
 8036080:	f000 fa75 	bl	803656e <LoRaMacSerializerJoinRequest>
 8036084:	b100      	cbz	r0, 8036088 <LoRaMacCryptoPrepareJoinRequest+0x40>
        return LORAMAC_CRYPTO_ERROR_SERIALIZER;
 8036086:	2011      	movs	r0, #17
}
 8036088:	b004      	add	sp, #16
 803608a:	bd10      	pop	{r4, pc}
        return LORAMAC_CRYPTO_ERROR_NPE;
 803608c:	200a      	movs	r0, #10
 803608e:	e7fb      	b.n	8036088 <LoRaMacCryptoPrepareJoinRequest+0x40>
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 8036090:	200f      	movs	r0, #15
 8036092:	e7f9      	b.n	8036088 <LoRaMacCryptoPrepareJoinRequest+0x40>
 8036094:	20005724 	.word	0x20005724

08036098 <LoRaMacCryptoSecureMessage>:
{
 8036098:	b5f0      	push	{r4, r5, r6, r7, lr}
 803609a:	4605      	mov	r5, r0
 803609c:	b087      	sub	sp, #28
    if( macMsg == NULL )
 803609e:	461c      	mov	r4, r3
 80360a0:	b323      	cbz	r3, 80360ec <LoRaMacCryptoSecureMessage+0x54>
    if( fCntUp < CryptoNvm->FCntList.FCntUp )
 80360a2:	4e2f      	ldr	r6, [pc, #188]	; (8036160 <LoRaMacCryptoSecureMessage+0xc8>)
 80360a4:	6833      	ldr	r3, [r6, #0]
 80360a6:	68db      	ldr	r3, [r3, #12]
 80360a8:	4283      	cmp	r3, r0
 80360aa:	d856      	bhi.n	803615a <LoRaMacCryptoSecureMessage+0xc2>
    if( macMsg->FPort == 0 )
 80360ac:	f894 2020 	ldrb.w	r2, [r4, #32]
        payloadDecryptionKeyID = NWK_S_KEY;
 80360b0:	2a00      	cmp	r2, #0
 80360b2:	bf14      	ite	ne
 80360b4:	2203      	movne	r2, #3
 80360b6:	2202      	moveq	r2, #2
    if( fCntUp > CryptoNvm->FCntList.FCntUp )
 80360b8:	4283      	cmp	r3, r0
 80360ba:	d305      	bcc.n	80360c8 <LoRaMacCryptoSecureMessage+0x30>
    if( LoRaMacSerializerData( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 80360bc:	4620      	mov	r0, r4
 80360be:	f000 fa8a 	bl	80365d6 <LoRaMacSerializerData>
 80360c2:	b170      	cbz	r0, 80360e2 <LoRaMacCryptoSecureMessage+0x4a>
        return LORAMAC_CRYPTO_ERROR_SERIALIZER;
 80360c4:	2011      	movs	r0, #17
 80360c6:	e00a      	b.n	80360de <LoRaMacCryptoSecureMessage+0x46>
        retval = PayloadEncrypt( macMsg->FRMPayload, macMsg->FRMPayloadSize, payloadDecryptionKeyID, macMsg->FHDR.DevAddr, UPLINK, fCntUp );
 80360c8:	2300      	movs	r3, #0
 80360ca:	9001      	str	r0, [sp, #4]
 80360cc:	9300      	str	r3, [sp, #0]
 80360ce:	68a3      	ldr	r3, [r4, #8]
 80360d0:	f894 1028 	ldrb.w	r1, [r4, #40]	; 0x28
 80360d4:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80360d6:	f7ff fe70 	bl	8035dba <PayloadEncrypt>
        if( retval != LORAMAC_CRYPTO_SUCCESS )
 80360da:	2800      	cmp	r0, #0
 80360dc:	d0ee      	beq.n	80360bc <LoRaMacCryptoSecureMessage+0x24>
}
 80360de:	b007      	add	sp, #28
 80360e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
        retval = ComputeCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), payloadDecryptionKeyID, false, UPLINK, macMsg->FHDR.DevAddr, fCntUp, &macMsg->MIC );
 80360e2:	7923      	ldrb	r3, [r4, #4]
 80360e4:	6821      	ldr	r1, [r4, #0]
 80360e6:	3b04      	subs	r3, #4
 80360e8:	b29a      	uxth	r2, r3
    if( ( msg == 0 ) || ( cmac == 0 ) )
 80360ea:	b909      	cbnz	r1, 80360f0 <LoRaMacCryptoSecureMessage+0x58>
        return LORAMAC_CRYPTO_ERROR_NPE;
 80360ec:	200a      	movs	r0, #10
 80360ee:	e7f6      	b.n	80360de <LoRaMacCryptoSecureMessage+0x46>
    if( len > CRYPTO_MAXMESSAGE_SIZE )
 80360f0:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 80360f4:	d82f      	bhi.n	8036156 <LoRaMacCryptoSecureMessage+0xbe>
        retval = ComputeCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), payloadDecryptionKeyID, false, UPLINK, macMsg->FHDR.DevAddr, fCntUp, &macMsg->MIC );
 80360f6:	68a7      	ldr	r7, [r4, #8]
    b0[5] = dir;
 80360f8:	f8b4 c008 	ldrh.w	ip, [r4, #8]
    b0[6] = devAddr & 0xFF;
 80360fc:	f8ad c00e 	strh.w	ip, [sp, #14]
    b0[8] = ( devAddr >> 16 ) & 0xFF;
 8036100:	ea4f 4c17 	mov.w	ip, r7, lsr #16
    b0[9] = ( devAddr >> 24 ) & 0xFF;
 8036104:	0e3f      	lsrs	r7, r7, #24
 8036106:	f88d 7011 	strb.w	r7, [sp, #17]
    b0[15] = msgLen & 0xFF;
 803610a:	f88d 3017 	strb.w	r3, [sp, #23]
    b0[12] = ( fCnt >> 16 ) & 0xFF;
 803610e:	0c2f      	lsrs	r7, r5, #16
        retval = ComputeCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), payloadDecryptionKeyID, false, UPLINK, macMsg->FHDR.DevAddr, fCntUp, &macMsg->MIC );
 8036110:	f104 032c 	add.w	r3, r4, #44	; 0x2c
    b0[0] = 0x49;
 8036114:	f04f 0e49 	mov.w	lr, #73	; 0x49
    b0[4] = 0x00;
 8036118:	f8ad 000c 	strh.w	r0, [sp, #12]
    b0[12] = ( fCnt >> 16 ) & 0xFF;
 803611c:	f88d 7014 	strb.w	r7, [sp, #20]
    b0[14] = 0x00;
 8036120:	f88d 0016 	strb.w	r0, [sp, #22]
    b0[13] = ( fCnt >> 24 ) & 0xFF;
 8036124:	0e2f      	lsrs	r7, r5, #24
    if( SecureElementComputeAesCmac( micBuff, msg, len, keyID, cmac ) != SECURE_ELEMENT_SUCCESS )
 8036126:	9300      	str	r3, [sp, #0]
 8036128:	a802      	add	r0, sp, #8
 803612a:	2302      	movs	r3, #2
    b0[0] = 0x49;
 803612c:	f8cd e008 	str.w	lr, [sp, #8]
    b0[8] = ( devAddr >> 16 ) & 0xFF;
 8036130:	f88d c010 	strb.w	ip, [sp, #16]
    b0[10] = fCnt & 0xFF;
 8036134:	f8ad 5012 	strh.w	r5, [sp, #18]
    b0[13] = ( fCnt >> 24 ) & 0xFF;
 8036138:	f88d 7015 	strb.w	r7, [sp, #21]
    if( SecureElementComputeAesCmac( micBuff, msg, len, keyID, cmac ) != SECURE_ELEMENT_SUCCESS )
 803613c:	f002 fc4c 	bl	80389d8 <SecureElementComputeAesCmac>
 8036140:	b108      	cbz	r0, 8036146 <LoRaMacCryptoSecureMessage+0xae>
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 8036142:	200f      	movs	r0, #15
 8036144:	e7cb      	b.n	80360de <LoRaMacCryptoSecureMessage+0x46>
    if( LoRaMacSerializerData( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 8036146:	4620      	mov	r0, r4
 8036148:	f000 fa45 	bl	80365d6 <LoRaMacSerializerData>
 803614c:	2800      	cmp	r0, #0
 803614e:	d1b9      	bne.n	80360c4 <LoRaMacCryptoSecureMessage+0x2c>
    CryptoNvm->FCntList.FCntUp = fCntUp;
 8036150:	6833      	ldr	r3, [r6, #0]
 8036152:	60dd      	str	r5, [r3, #12]
    return LORAMAC_CRYPTO_SUCCESS;
 8036154:	e7c3      	b.n	80360de <LoRaMacCryptoSecureMessage+0x46>
        return LORAMAC_CRYPTO_ERROR_BUF_SIZE;
 8036156:	200e      	movs	r0, #14
 8036158:	e7c1      	b.n	80360de <LoRaMacCryptoSecureMessage+0x46>
        return LORAMAC_CRYPTO_FAIL_FCNT_SMALLER;
 803615a:	2006      	movs	r0, #6
 803615c:	e7bf      	b.n	80360de <LoRaMacCryptoSecureMessage+0x46>
 803615e:	bf00      	nop
 8036160:	20005724 	.word	0x20005724

08036164 <LoRaMacCryptoUnsecureMessage>:
{
 8036164:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 8036168:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 803616a:	4680      	mov	r8, r0
 803616c:	460f      	mov	r7, r1
 803616e:	4616      	mov	r6, r2
 8036170:	461c      	mov	r4, r3
    if( macMsg == 0 )
 8036172:	2d00      	cmp	r5, #0
 8036174:	d059      	beq.n	803622a <LoRaMacCryptoUnsecureMessage+0xc6>
    uint32_t lastDown = 0;
 8036176:	2300      	movs	r3, #0
    if( GetLastFcntDown( fCntID, &lastDown ) != LORAMAC_CRYPTO_SUCCESS )
 8036178:	a903      	add	r1, sp, #12
 803617a:	4610      	mov	r0, r2
    uint32_t lastDown = 0;
 803617c:	9303      	str	r3, [sp, #12]
    if( GetLastFcntDown( fCntID, &lastDown ) != LORAMAC_CRYPTO_SUCCESS )
 803617e:	f7ff fe77 	bl	8035e70 <GetLastFcntDown>
 8036182:	b118      	cbz	r0, 803618c <LoRaMacCryptoUnsecureMessage+0x28>
        return LORAMAC_CRYPTO_FAIL_FCNT_SMALLER;
 8036184:	2006      	movs	r0, #6
}
 8036186:	b004      	add	sp, #16
 8036188:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if( ( currentDown > lastDown ) ||
 803618c:	9b03      	ldr	r3, [sp, #12]
 803618e:	429c      	cmp	r4, r3
 8036190:	d801      	bhi.n	8036196 <LoRaMacCryptoUnsecureMessage+0x32>
 8036192:	3301      	adds	r3, #1
 8036194:	d1f6      	bne.n	8036184 <LoRaMacCryptoUnsecureMessage+0x20>
    if( LoRaMacParserData( macMsg ) != LORAMAC_PARSER_SUCCESS )
 8036196:	4628      	mov	r0, r5
 8036198:	f000 f98e 	bl	80364b8 <LoRaMacParserData>
 803619c:	2800      	cmp	r0, #0
 803619e:	d146      	bne.n	803622e <LoRaMacCryptoUnsecureMessage+0xca>
        if( KeyAddrList[i].AddrID == addrID )
 80361a0:	4b26      	ldr	r3, [pc, #152]	; (803623c <LoRaMacCryptoUnsecureMessage+0xd8>)
 80361a2:	781a      	ldrb	r2, [r3, #0]
 80361a4:	4542      	cmp	r2, r8
 80361a6:	d003      	beq.n	80361b0 <LoRaMacCryptoUnsecureMessage+0x4c>
 80361a8:	791a      	ldrb	r2, [r3, #4]
 80361aa:	4542      	cmp	r2, r8
 80361ac:	d141      	bne.n	8036232 <LoRaMacCryptoUnsecureMessage+0xce>
 80361ae:	2001      	movs	r0, #1
    if( address != macMsg->FHDR.DevAddr )
 80361b0:	68aa      	ldr	r2, [r5, #8]
 80361b2:	42ba      	cmp	r2, r7
 80361b4:	d13f      	bne.n	8036236 <LoRaMacCryptoUnsecureMessage+0xd2>
    payloadDecryptionKeyID = curItem->AppSkey;
 80361b6:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    retval = VerifyCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), micComputationKeyID, isAck, DOWNLINK, address, fCntDown, macMsg->MIC );
 80361ba:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    payloadDecryptionKeyID = curItem->AppSkey;
 80361bc:	f890 8001 	ldrb.w	r8, [r0, #1]
    retval = VerifyCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), micComputationKeyID, isAck, DOWNLINK, address, fCntDown, macMsg->MIC );
 80361c0:	7929      	ldrb	r1, [r5, #4]
 80361c2:	e9cd 4300 	strd	r4, r3, [sp]
 80361c6:	3904      	subs	r1, #4
 80361c8:	7882      	ldrb	r2, [r0, #2]
 80361ca:	6828      	ldr	r0, [r5, #0]
 80361cc:	463b      	mov	r3, r7
 80361ce:	b289      	uxth	r1, r1
 80361d0:	f7ff fe83 	bl	8035eda <VerifyCmacB0.isra.0.constprop.0>
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 80361d4:	2800      	cmp	r0, #0
 80361d6:	d1d6      	bne.n	8036186 <LoRaMacCryptoUnsecureMessage+0x22>
    if( macMsg->FPort == 0 )
 80361d8:	f895 3020 	ldrb.w	r3, [r5, #32]
    retval = PayloadEncrypt( macMsg->FRMPayload, macMsg->FRMPayloadSize, payloadDecryptionKeyID, address, DOWNLINK, fCntDown );
 80361dc:	9401      	str	r4, [sp, #4]
        payloadDecryptionKeyID = NWK_S_KEY;
 80361de:	2b00      	cmp	r3, #0
    retval = PayloadEncrypt( macMsg->FRMPayload, macMsg->FRMPayloadSize, payloadDecryptionKeyID, address, DOWNLINK, fCntDown );
 80361e0:	f04f 0301 	mov.w	r3, #1
 80361e4:	9300      	str	r3, [sp, #0]
 80361e6:	bf14      	ite	ne
 80361e8:	4642      	movne	r2, r8
 80361ea:	2202      	moveq	r2, #2
 80361ec:	f895 1028 	ldrb.w	r1, [r5, #40]	; 0x28
 80361f0:	6a68      	ldr	r0, [r5, #36]	; 0x24
 80361f2:	463b      	mov	r3, r7
 80361f4:	f7ff fde1 	bl	8035dba <PayloadEncrypt>
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 80361f8:	2800      	cmp	r0, #0
 80361fa:	d1c4      	bne.n	8036186 <LoRaMacCryptoUnsecureMessage+0x22>
    switch( fCntID )
 80361fc:	3e01      	subs	r6, #1
 80361fe:	2e03      	cmp	r6, #3
 8036200:	d8c1      	bhi.n	8036186 <LoRaMacCryptoUnsecureMessage+0x22>
 8036202:	e8df f006 	tbb	[pc, r6]
 8036206:	0602      	.short	0x0602
 8036208:	0e0a      	.short	0x0e0a
            CryptoNvm->FCntList.NFCntDown = currentDown;
 803620a:	4b0d      	ldr	r3, [pc, #52]	; (8036240 <LoRaMacCryptoUnsecureMessage+0xdc>)
 803620c:	681b      	ldr	r3, [r3, #0]
 803620e:	611c      	str	r4, [r3, #16]
            break;
 8036210:	e7b9      	b.n	8036186 <LoRaMacCryptoUnsecureMessage+0x22>
            CryptoNvm->FCntList.AFCntDown = currentDown;
 8036212:	4b0b      	ldr	r3, [pc, #44]	; (8036240 <LoRaMacCryptoUnsecureMessage+0xdc>)
 8036214:	681b      	ldr	r3, [r3, #0]
 8036216:	615c      	str	r4, [r3, #20]
            break;
 8036218:	e7b5      	b.n	8036186 <LoRaMacCryptoUnsecureMessage+0x22>
            CryptoNvm->FCntList.FCntDown = currentDown;
 803621a:	4b09      	ldr	r3, [pc, #36]	; (8036240 <LoRaMacCryptoUnsecureMessage+0xdc>)
 803621c:	681b      	ldr	r3, [r3, #0]
 803621e:	619c      	str	r4, [r3, #24]
            break;
 8036220:	e7b1      	b.n	8036186 <LoRaMacCryptoUnsecureMessage+0x22>
            CryptoNvm->FCntList.McFCntDown[0] = currentDown;
 8036222:	4b07      	ldr	r3, [pc, #28]	; (8036240 <LoRaMacCryptoUnsecureMessage+0xdc>)
 8036224:	681b      	ldr	r3, [r3, #0]
 8036226:	61dc      	str	r4, [r3, #28]
            break;
 8036228:	e7ad      	b.n	8036186 <LoRaMacCryptoUnsecureMessage+0x22>
        return LORAMAC_CRYPTO_ERROR_NPE;
 803622a:	200a      	movs	r0, #10
 803622c:	e7ab      	b.n	8036186 <LoRaMacCryptoUnsecureMessage+0x22>
        return LORAMAC_CRYPTO_ERROR_PARSER;
 803622e:	2010      	movs	r0, #16
 8036230:	e7a9      	b.n	8036186 <LoRaMacCryptoUnsecureMessage+0x22>
    return LORAMAC_CRYPTO_ERROR_INVALID_ADDR_ID;
 8036232:	200c      	movs	r0, #12
 8036234:	e7a7      	b.n	8036186 <LoRaMacCryptoUnsecureMessage+0x22>
        return LORAMAC_CRYPTO_FAIL_ADDRESS;
 8036236:	2002      	movs	r0, #2
 8036238:	e7a5      	b.n	8036186 <LoRaMacCryptoUnsecureMessage+0x22>
 803623a:	bf00      	nop
 803623c:	20003594 	.word	0x20003594
 8036240:	20005724 	.word	0x20005724

08036244 <LoRaMacCryptoDeriveMcRootKey>:
{
 8036244:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    if( keyID != APP_KEY )
 8036246:	b9b1      	cbnz	r1, 8036276 <LoRaMacCryptoDeriveMcRootKey+0x32>
    if( versionMinor == 1 )
 8036248:	2801      	cmp	r0, #1
    uint8_t compBase[16] = { 0 };
 803624a:	e9cd 1100 	strd	r1, r1, [sp]
        compBase[0] = 0x20;
 803624e:	bf08      	it	eq
 8036250:	2320      	moveq	r3, #32
    uint8_t compBase[16] = { 0 };
 8036252:	e9cd 1102 	strd	r1, r1, [sp, #8]
    if( SecureElementDeriveAndStoreKey( compBase, keyID, MC_ROOT_KEY ) != SECURE_ELEMENT_SUCCESS )
 8036256:	f04f 0204 	mov.w	r2, #4
 803625a:	f04f 0100 	mov.w	r1, #0
 803625e:	4668      	mov	r0, sp
        compBase[0] = 0x20;
 8036260:	bf08      	it	eq
 8036262:	f88d 3000 	strbeq.w	r3, [sp]
    if( SecureElementDeriveAndStoreKey( compBase, keyID, MC_ROOT_KEY ) != SECURE_ELEMENT_SUCCESS )
 8036266:	f002 fd43 	bl	8038cf0 <SecureElementDeriveAndStoreKey>
 803626a:	2800      	cmp	r0, #0
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 803626c:	bf18      	it	ne
 803626e:	200f      	movne	r0, #15
}
 8036270:	b005      	add	sp, #20
 8036272:	f85d fb04 	ldr.w	pc, [sp], #4
        return LORAMAC_CRYPTO_ERROR_INVALID_KEY_ID;
 8036276:	200b      	movs	r0, #11
 8036278:	e7fa      	b.n	8036270 <LoRaMacCryptoDeriveMcRootKey+0x2c>
	...

0803627c <LoRaMacCryptoSetKey>:
{
 803627c:	b538      	push	{r3, r4, r5, lr}
 803627e:	4605      	mov	r5, r0
    if( SecureElementSetKey( keyID, key ) != SECURE_ELEMENT_SUCCESS )
 8036280:	f002 fcb0 	bl	8038be4 <SecureElementSetKey>
 8036284:	4604      	mov	r4, r0
 8036286:	b950      	cbnz	r0, 803629e <LoRaMacCryptoSetKey+0x22>
    if( keyID == APP_KEY )
 8036288:	b955      	cbnz	r5, 80362a0 <LoRaMacCryptoSetKey+0x24>
        if( LoRaMacCryptoDeriveMcRootKey( CryptoNvm->LrWanVersion.Fields.Minor, keyID ) != LORAMAC_CRYPTO_SUCCESS )
 803628a:	4b06      	ldr	r3, [pc, #24]	; (80362a4 <LoRaMacCryptoSetKey+0x28>)
 803628c:	681b      	ldr	r3, [r3, #0]
 803628e:	4601      	mov	r1, r0
 8036290:	7898      	ldrb	r0, [r3, #2]
 8036292:	f7ff ffd7 	bl	8036244 <LoRaMacCryptoDeriveMcRootKey>
 8036296:	b910      	cbnz	r0, 803629e <LoRaMacCryptoSetKey+0x22>
    if( keyID != MC_ROOT_KEY )
 8036298:	f7ff fe0e 	bl	8035eb8 <LoRaMacCryptoDeriveMcKEKey.part.0>
        if( LoRaMacCryptoDeriveMcKEKey( MC_ROOT_KEY ) != LORAMAC_CRYPTO_SUCCESS )
 803629c:	b100      	cbz	r0, 80362a0 <LoRaMacCryptoSetKey+0x24>
            return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 803629e:	240f      	movs	r4, #15
}
 80362a0:	4620      	mov	r0, r4
 80362a2:	bd38      	pop	{r3, r4, r5, pc}
 80362a4:	20005724 	.word	0x20005724

080362a8 <LoRaMacCryptoHandleJoinAccept>:
{
 80362a8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80362ac:	4680      	mov	r8, r0
 80362ae:	b08f      	sub	sp, #60	; 0x3c
 80362b0:	460d      	mov	r5, r1
    if( ( macMsg == 0 ) || ( joinEUI == 0 ) )
 80362b2:	4614      	mov	r4, r2
 80362b4:	2a00      	cmp	r2, #0
 80362b6:	d05f      	beq.n	8036378 <LoRaMacCryptoHandleJoinAccept+0xd0>
 80362b8:	2900      	cmp	r1, #0
 80362ba:	d05d      	beq.n	8036378 <LoRaMacCryptoHandleJoinAccept+0xd0>
    uint8_t decJoinAccept[LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE] = { 0 };
 80362bc:	2600      	movs	r6, #0
 80362be:	4631      	mov	r1, r6
 80362c0:	221d      	movs	r2, #29
 80362c2:	a806      	add	r0, sp, #24
 80362c4:	9605      	str	r6, [sp, #20]
 80362c6:	f005 fa33 	bl	803b730 <memset>
    uint8_t versionMinor         = 0;
 80362ca:	f88d 6013 	strb.w	r6, [sp, #19]
    uint16_t nonce               = CryptoNvm->DevNonce;
 80362ce:	4e2e      	ldr	r6, [pc, #184]	; (8036388 <LoRaMacCryptoHandleJoinAccept+0xe0>)
 80362d0:	6833      	ldr	r3, [r6, #0]
    if( SecureElementProcessJoinAccept( joinReqType, joinEUI, nonce, macMsg->Buffer,
 80362d2:	f10d 0914 	add.w	r9, sp, #20
    uint16_t nonce               = CryptoNvm->DevNonce;
 80362d6:	889f      	ldrh	r7, [r3, #4]
    if( SecureElementProcessJoinAccept( joinReqType, joinEUI, nonce, macMsg->Buffer,
 80362d8:	f8cd 9004 	str.w	r9, [sp, #4]
 80362dc:	f10d 0313 	add.w	r3, sp, #19
 80362e0:	9302      	str	r3, [sp, #8]
 80362e2:	7923      	ldrb	r3, [r4, #4]
 80362e4:	9300      	str	r3, [sp, #0]
 80362e6:	6823      	ldr	r3, [r4, #0]
 80362e8:	463a      	mov	r2, r7
 80362ea:	4629      	mov	r1, r5
 80362ec:	4640      	mov	r0, r8
 80362ee:	f002 fd55 	bl	8038d9c <SecureElementProcessJoinAccept>
 80362f2:	2800      	cmp	r0, #0
 80362f4:	d142      	bne.n	803637c <LoRaMacCryptoHandleJoinAccept+0xd4>
    memcpy1( macMsg->Buffer, decJoinAccept, macMsg->BufSize );
 80362f6:	4649      	mov	r1, r9
 80362f8:	7922      	ldrb	r2, [r4, #4]
 80362fa:	6820      	ldr	r0, [r4, #0]
 80362fc:	f002 fdec 	bl	8038ed8 <memcpy1>
    if( LoRaMacParserJoinAccept( macMsg ) != LORAMAC_PARSER_SUCCESS )
 8036300:	4620      	mov	r0, r4
 8036302:	f000 f88b 	bl	803641c <LoRaMacParserJoinAccept>
 8036306:	4601      	mov	r1, r0
 8036308:	2800      	cmp	r0, #0
 803630a:	d139      	bne.n	8036380 <LoRaMacCryptoHandleJoinAccept+0xd8>
    currentJoinNonce |= ( ( uint32_t )macMsg->JoinNonce[2] << 16 );
 803630c:	7a25      	ldrb	r5, [r4, #8]
    currentJoinNonce |= ( ( uint32_t )macMsg->JoinNonce[1] << 8 );
 803630e:	79e2      	ldrb	r2, [r4, #7]
    currentJoinNonce = ( uint32_t )macMsg->JoinNonce[0];
 8036310:	79a3      	ldrb	r3, [r4, #6]
    currentJoinNonce |= ( ( uint32_t )macMsg->JoinNonce[2] << 16 );
 8036312:	042d      	lsls	r5, r5, #16
 8036314:	ea45 2502 	orr.w	r5, r5, r2, lsl #8
 8036318:	431d      	orrs	r5, r3
    if( currentJoinNonce != CryptoNvm->JoinNonce )
 803631a:	6833      	ldr	r3, [r6, #0]
 803631c:	689a      	ldr	r2, [r3, #8]
 803631e:	42aa      	cmp	r2, r5
 8036320:	d030      	beq.n	8036384 <LoRaMacCryptoHandleJoinAccept+0xdc>
    retval = LoRaMacCryptoDeriveMcRootKey( versionMinor, APP_KEY );
 8036322:	f89d 0013 	ldrb.w	r0, [sp, #19]
        CryptoNvm->JoinNonce = currentJoinNonce;
 8036326:	609d      	str	r5, [r3, #8]
    retval = LoRaMacCryptoDeriveMcRootKey( versionMinor, APP_KEY );
 8036328:	f7ff ff8c 	bl	8036244 <LoRaMacCryptoDeriveMcRootKey>
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 803632c:	bb08      	cbnz	r0, 8036372 <LoRaMacCryptoHandleJoinAccept+0xca>
    if( keyID != MC_ROOT_KEY )
 803632e:	f7ff fdc3 	bl	8035eb8 <LoRaMacCryptoDeriveMcKEKey.part.0>
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 8036332:	b9f0      	cbnz	r0, 8036372 <LoRaMacCryptoHandleJoinAccept+0xca>
        netID = ( uint32_t )macMsg->NetID[0];
 8036334:	7a62      	ldrb	r2, [r4, #9]
        netID |= ( ( uint32_t )macMsg->NetID[1] << 8 );
 8036336:	7aa3      	ldrb	r3, [r4, #10]
        netID |= ( ( uint32_t )macMsg->NetID[2] << 16 );
 8036338:	7ae4      	ldrb	r4, [r4, #11]
 803633a:	0424      	lsls	r4, r4, #16
 803633c:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
 8036340:	4314      	orrs	r4, r2
        retval = DeriveSessionKey10x( APP_S_KEY, currentJoinNonce, netID, nonce );
 8036342:	463b      	mov	r3, r7
 8036344:	4622      	mov	r2, r4
 8036346:	4629      	mov	r1, r5
 8036348:	2003      	movs	r0, #3
 803634a:	f7ff fd13 	bl	8035d74 <DeriveSessionKey10x>
        if( retval != LORAMAC_CRYPTO_SUCCESS )
 803634e:	b980      	cbnz	r0, 8036372 <LoRaMacCryptoHandleJoinAccept+0xca>
        retval = DeriveSessionKey10x( NWK_S_KEY, currentJoinNonce, netID, nonce );
 8036350:	463b      	mov	r3, r7
 8036352:	4622      	mov	r2, r4
 8036354:	4629      	mov	r1, r5
 8036356:	2002      	movs	r0, #2
 8036358:	f7ff fd0c 	bl	8035d74 <DeriveSessionKey10x>
        if( retval != LORAMAC_CRYPTO_SUCCESS )
 803635c:	b948      	cbnz	r0, 8036372 <LoRaMacCryptoHandleJoinAccept+0xca>
    CryptoNvm->LrWanVersion.Fields.Minor = versionMinor;
 803635e:	6833      	ldr	r3, [r6, #0]
 8036360:	f89d 2013 	ldrb.w	r2, [sp, #19]
 8036364:	709a      	strb	r2, [r3, #2]
    CryptoNvm->FCntList.FCntDown = FCNT_DOWN_INITAL_VALUE;
 8036366:	f04f 32ff 	mov.w	r2, #4294967295
    CryptoNvm->FCntList.AFCntDown = FCNT_DOWN_INITAL_VALUE;
 803636a:	e9c3 2204 	strd	r2, r2, [r3, #16]
    CryptoNvm->FCntList.FCntUp = 0;
 803636e:	60d8      	str	r0, [r3, #12]
    CryptoNvm->FCntList.FCntDown = FCNT_DOWN_INITAL_VALUE;
 8036370:	619a      	str	r2, [r3, #24]
}
 8036372:	b00f      	add	sp, #60	; 0x3c
 8036374:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        return LORAMAC_CRYPTO_ERROR_NPE;
 8036378:	200a      	movs	r0, #10
 803637a:	e7fa      	b.n	8036372 <LoRaMacCryptoHandleJoinAccept+0xca>
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 803637c:	200f      	movs	r0, #15
 803637e:	e7f8      	b.n	8036372 <LoRaMacCryptoHandleJoinAccept+0xca>
        return LORAMAC_CRYPTO_ERROR_PARSER;
 8036380:	2010      	movs	r0, #16
 8036382:	e7f6      	b.n	8036372 <LoRaMacCryptoHandleJoinAccept+0xca>
        return LORAMAC_CRYPTO_FAIL_JOIN_NONCE;
 8036384:	2003      	movs	r0, #3
 8036386:	e7f4      	b.n	8036372 <LoRaMacCryptoHandleJoinAccept+0xca>
 8036388:	20005724 	.word	0x20005724

0803638c <LoRaMacCryptoDeriveMcSessionKeyPair>:

LoRaMacCryptoStatus_t LoRaMacCryptoDeriveMcSessionKeyPair( AddressIdentifier_t addrID, uint32_t mcAddr )
{
 803638c:	b570      	push	{r4, r5, r6, lr}
 803638e:	b088      	sub	sp, #32
    if( mcAddr == 0 )
 8036390:	2900      	cmp	r1, #0
 8036392:	d03d      	beq.n	8036410 <LoRaMacCryptoDeriveMcSessionKeyPair+0x84>
        if( KeyAddrList[i].AddrID == addrID )
 8036394:	4c20      	ldr	r4, [pc, #128]	; (8036418 <LoRaMacCryptoDeriveMcSessionKeyPair+0x8c>)
 8036396:	7823      	ldrb	r3, [r4, #0]
 8036398:	4283      	cmp	r3, r0
 803639a:	d037      	beq.n	803640c <LoRaMacCryptoDeriveMcSessionKeyPair+0x80>
 803639c:	7923      	ldrb	r3, [r4, #4]
 803639e:	4283      	cmp	r3, r0
 80363a0:	d138      	bne.n	8036414 <LoRaMacCryptoDeriveMcSessionKeyPair+0x88>
 80363a2:	2201      	movs	r2, #1
    }

    // McAppSKey = aes128_encrypt(McKey, 0x01 | McAddr | pad16)
    // McNwkSKey = aes128_encrypt(McKey, 0x02 | McAddr | pad16)

    uint8_t compBaseAppS[16] = { 0 };
 80363a4:	2300      	movs	r3, #0
 80363a6:	e9cd 3301 	strd	r3, r3, [sp, #4]
    uint8_t compBaseNwkS[16] = { 0 };
 80363aa:	e9cd 3305 	strd	r3, r3, [sp, #20]
    compBaseNwkS[1] = mcAddr & 0xFF;
    compBaseNwkS[2] = ( mcAddr >> 8 ) & 0xFF;
    compBaseNwkS[3] = ( mcAddr >> 16 ) & 0xFF;
    compBaseNwkS[4] = ( mcAddr >> 24 ) & 0xFF;

    if( SecureElementDeriveAndStoreKey( compBaseAppS, curItem->RootKey, curItem->AppSkey ) != SECURE_ELEMENT_SUCCESS )
 80363ae:	eb04 0482 	add.w	r4, r4, r2, lsl #2
    uint8_t compBaseAppS[16] = { 0 };
 80363b2:	9303      	str	r3, [sp, #12]
    uint8_t compBaseNwkS[16] = { 0 };
 80363b4:	9307      	str	r3, [sp, #28]
    compBaseAppS[0] = 0x01;
 80363b6:	2301      	movs	r3, #1
    compBaseAppS[2] = ( mcAddr >> 8 ) & 0xFF;
 80363b8:	f3c1 2007 	ubfx	r0, r1, #8, #8
    compBaseAppS[1] = mcAddr & 0xFF;
 80363bc:	b2cd      	uxtb	r5, r1
    compBaseAppS[0] = 0x01;
 80363be:	f88d 3000 	strb.w	r3, [sp]
    compBaseAppS[3] = ( mcAddr >> 16 ) & 0xFF;
 80363c2:	f3c1 4307 	ubfx	r3, r1, #16, #8
    compBaseAppS[4] = ( mcAddr >> 24 ) & 0xFF;
 80363c6:	0e09      	lsrs	r1, r1, #24
    compBaseAppS[2] = ( mcAddr >> 8 ) & 0xFF;
 80363c8:	f88d 0002 	strb.w	r0, [sp, #2]
    compBaseAppS[4] = ( mcAddr >> 24 ) & 0xFF;
 80363cc:	f88d 1004 	strb.w	r1, [sp, #4]
    compBaseNwkS[0] = 0x02;
 80363d0:	2602      	movs	r6, #2
    compBaseNwkS[2] = ( mcAddr >> 8 ) & 0xFF;
 80363d2:	f88d 0012 	strb.w	r0, [sp, #18]
    compBaseNwkS[4] = ( mcAddr >> 24 ) & 0xFF;
 80363d6:	f88d 1014 	strb.w	r1, [sp, #20]
    if( SecureElementDeriveAndStoreKey( compBaseAppS, curItem->RootKey, curItem->AppSkey ) != SECURE_ELEMENT_SUCCESS )
 80363da:	7862      	ldrb	r2, [r4, #1]
 80363dc:	78e1      	ldrb	r1, [r4, #3]
    compBaseAppS[1] = mcAddr & 0xFF;
 80363de:	f88d 5001 	strb.w	r5, [sp, #1]
    if( SecureElementDeriveAndStoreKey( compBaseAppS, curItem->RootKey, curItem->AppSkey ) != SECURE_ELEMENT_SUCCESS )
 80363e2:	4668      	mov	r0, sp
    compBaseAppS[3] = ( mcAddr >> 16 ) & 0xFF;
 80363e4:	f88d 3003 	strb.w	r3, [sp, #3]
    compBaseNwkS[0] = 0x02;
 80363e8:	f88d 6010 	strb.w	r6, [sp, #16]
    compBaseNwkS[1] = mcAddr & 0xFF;
 80363ec:	f88d 5011 	strb.w	r5, [sp, #17]
    compBaseNwkS[3] = ( mcAddr >> 16 ) & 0xFF;
 80363f0:	f88d 3013 	strb.w	r3, [sp, #19]
    if( SecureElementDeriveAndStoreKey( compBaseAppS, curItem->RootKey, curItem->AppSkey ) != SECURE_ELEMENT_SUCCESS )
 80363f4:	f002 fc7c 	bl	8038cf0 <SecureElementDeriveAndStoreKey>
 80363f8:	b928      	cbnz	r0, 8036406 <LoRaMacCryptoDeriveMcSessionKeyPair+0x7a>
    {
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
    }

    if( SecureElementDeriveAndStoreKey( compBaseNwkS, curItem->RootKey, curItem->NwkSkey ) != SECURE_ELEMENT_SUCCESS )
 80363fa:	78a2      	ldrb	r2, [r4, #2]
 80363fc:	78e1      	ldrb	r1, [r4, #3]
 80363fe:	a804      	add	r0, sp, #16
 8036400:	f002 fc76 	bl	8038cf0 <SecureElementDeriveAndStoreKey>
 8036404:	b100      	cbz	r0, 8036408 <LoRaMacCryptoDeriveMcSessionKeyPair+0x7c>
    {
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 8036406:	200f      	movs	r0, #15
    }

    return LORAMAC_CRYPTO_SUCCESS;
}
 8036408:	b008      	add	sp, #32
 803640a:	bd70      	pop	{r4, r5, r6, pc}
        if( KeyAddrList[i].AddrID == addrID )
 803640c:	2200      	movs	r2, #0
 803640e:	e7c9      	b.n	80363a4 <LoRaMacCryptoDeriveMcSessionKeyPair+0x18>
        return LORAMAC_CRYPTO_ERROR_NPE;
 8036410:	200a      	movs	r0, #10
 8036412:	e7f9      	b.n	8036408 <LoRaMacCryptoDeriveMcSessionKeyPair+0x7c>
    return LORAMAC_CRYPTO_ERROR_INVALID_ADDR_ID;
 8036414:	200c      	movs	r0, #12
 8036416:	e7f7      	b.n	8036408 <LoRaMacCryptoDeriveMcSessionKeyPair+0x7c>
 8036418:	20003594 	.word	0x20003594

0803641c <LoRaMacParserJoinAccept>:
 */
#include "LoRaMacParser.h"
#include "utilities.h"

LoRaMacParserStatus_t LoRaMacParserJoinAccept( LoRaMacMessageJoinAccept_t* macMsg )
{
 803641c:	b510      	push	{r4, lr}
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 803641e:	4604      	mov	r4, r0
 8036420:	2800      	cmp	r0, #0
 8036422:	d045      	beq.n	80364b0 <LoRaMacParserJoinAccept+0x94>
 8036424:	6801      	ldr	r1, [r0, #0]
 8036426:	2900      	cmp	r1, #0
 8036428:	d042      	beq.n	80364b0 <LoRaMacParserJoinAccept+0x94>
        return LORAMAC_PARSER_ERROR_NPE;
    }

    uint16_t bufItr = 0;

    macMsg->MHDR.Value = macMsg->Buffer[bufItr++];
 803642a:	f811 3b01 	ldrb.w	r3, [r1], #1
 803642e:	7143      	strb	r3, [r0, #5]

    memcpy1( macMsg->JoinNonce, &macMsg->Buffer[bufItr], 3 );
 8036430:	2203      	movs	r2, #3
 8036432:	3006      	adds	r0, #6
 8036434:	f002 fd50 	bl	8038ed8 <memcpy1>
    bufItr = bufItr + 3;

    memcpy1( macMsg->NetID, &macMsg->Buffer[bufItr], 3 );
 8036438:	4620      	mov	r0, r4
 803643a:	2203      	movs	r2, #3
 803643c:	f850 1b09 	ldr.w	r1, [r0], #9
 8036440:	3104      	adds	r1, #4
 8036442:	f002 fd49 	bl	8038ed8 <memcpy1>
    bufItr = bufItr + 3;

    macMsg->DevAddr = ( uint32_t ) macMsg->Buffer[bufItr++];
 8036446:	6821      	ldr	r1, [r4, #0]
 8036448:	79cb      	ldrb	r3, [r1, #7]
 803644a:	60e3      	str	r3, [r4, #12]
    macMsg->DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 803644c:	7a0a      	ldrb	r2, [r1, #8]
 803644e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8036452:	60e3      	str	r3, [r4, #12]
    macMsg->DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 8036454:	7a4a      	ldrb	r2, [r1, #9]
 8036456:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 803645a:	60e3      	str	r3, [r4, #12]
    macMsg->DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 24 );
 803645c:	7a8a      	ldrb	r2, [r1, #10]
 803645e:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8036462:	60e3      	str	r3, [r4, #12]

    macMsg->DLSettings.Value = macMsg->Buffer[bufItr++];
 8036464:	7acb      	ldrb	r3, [r1, #11]
 8036466:	7423      	strb	r3, [r4, #16]

    macMsg->RxDelay = macMsg->Buffer[bufItr++];
 8036468:	7b0b      	ldrb	r3, [r1, #12]
 803646a:	7463      	strb	r3, [r4, #17]

    if( ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE - bufItr ) == LORAMAC_CF_LIST_FIELD_SIZE )
 803646c:	7923      	ldrb	r3, [r4, #4]
 803646e:	2b21      	cmp	r3, #33	; 0x21
 8036470:	d11a      	bne.n	80364a8 <LoRaMacParserJoinAccept+0x8c>
    {
        memcpy1( macMsg->CFList, &macMsg->Buffer[bufItr], LORAMAC_CF_LIST_FIELD_SIZE );
 8036472:	2210      	movs	r2, #16
 8036474:	310d      	adds	r1, #13
 8036476:	f104 0012 	add.w	r0, r4, #18
 803647a:	f002 fd2d 	bl	8038ed8 <memcpy1>
        bufItr = bufItr + LORAMAC_CF_LIST_FIELD_SIZE;
 803647e:	221d      	movs	r2, #29
    else if( ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE - bufItr ) > 0 )
    {
        return LORAMAC_PARSER_FAIL;
    }

    macMsg->MIC = ( uint32_t ) macMsg->Buffer[bufItr++];
 8036480:	6821      	ldr	r1, [r4, #0]
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 8036482:	1c50      	adds	r0, r2, #1
    macMsg->MIC = ( uint32_t ) macMsg->Buffer[bufItr++];
 8036484:	5c8b      	ldrb	r3, [r1, r2]
 8036486:	6263      	str	r3, [r4, #36]	; 0x24
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 8036488:	5c08      	ldrb	r0, [r1, r0]
 803648a:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 803648e:	1c90      	adds	r0, r2, #2
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 8036490:	6263      	str	r3, [r4, #36]	; 0x24
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 8036492:	5c08      	ldrb	r0, [r1, r0]
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 24 );
 8036494:	3203      	adds	r2, #3
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 8036496:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
 803649a:	6263      	str	r3, [r4, #36]	; 0x24
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 24 );
 803649c:	5c8a      	ldrb	r2, [r1, r2]
 803649e:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80364a2:	6263      	str	r3, [r4, #36]	; 0x24

    return LORAMAC_PARSER_SUCCESS;
 80364a4:	2000      	movs	r0, #0
}
 80364a6:	bd10      	pop	{r4, pc}
    else if( ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE - bufItr ) > 0 )
 80364a8:	2b11      	cmp	r3, #17
 80364aa:	dc03      	bgt.n	80364b4 <LoRaMacParserJoinAccept+0x98>
    macMsg->RxDelay = macMsg->Buffer[bufItr++];
 80364ac:	220d      	movs	r2, #13
 80364ae:	e7e7      	b.n	8036480 <LoRaMacParserJoinAccept+0x64>
        return LORAMAC_PARSER_ERROR_NPE;
 80364b0:	2002      	movs	r0, #2
 80364b2:	e7f8      	b.n	80364a6 <LoRaMacParserJoinAccept+0x8a>
        return LORAMAC_PARSER_FAIL;
 80364b4:	2001      	movs	r0, #1
 80364b6:	e7f6      	b.n	80364a6 <LoRaMacParserJoinAccept+0x8a>

080364b8 <LoRaMacParserData>:

LoRaMacParserStatus_t LoRaMacParserData( LoRaMacMessageData_t* macMsg )
{
 80364b8:	b510      	push	{r4, lr}
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 80364ba:	4604      	mov	r4, r0
 80364bc:	2800      	cmp	r0, #0
 80364be:	d054      	beq.n	803656a <LoRaMacParserData+0xb2>
 80364c0:	6801      	ldr	r1, [r0, #0]
 80364c2:	2900      	cmp	r1, #0
 80364c4:	d051      	beq.n	803656a <LoRaMacParserData+0xb2>
        return LORAMAC_PARSER_ERROR_NPE;
    }

    uint16_t bufItr = 0;

    macMsg->MHDR.Value = macMsg->Buffer[bufItr++];
 80364c6:	780b      	ldrb	r3, [r1, #0]
 80364c8:	7143      	strb	r3, [r0, #5]

    macMsg->FHDR.DevAddr = macMsg->Buffer[bufItr++];
 80364ca:	784b      	ldrb	r3, [r1, #1]
 80364cc:	6083      	str	r3, [r0, #8]
    macMsg->FHDR.DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 80364ce:	788a      	ldrb	r2, [r1, #2]
 80364d0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80364d4:	6083      	str	r3, [r0, #8]
    macMsg->FHDR.DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 80364d6:	78ca      	ldrb	r2, [r1, #3]
 80364d8:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80364dc:	6083      	str	r3, [r0, #8]
    macMsg->FHDR.DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 24 );
 80364de:	790a      	ldrb	r2, [r1, #4]
 80364e0:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80364e4:	6083      	str	r3, [r0, #8]

    macMsg->FHDR.FCtrl.Value = macMsg->Buffer[bufItr++];
 80364e6:	794b      	ldrb	r3, [r1, #5]
 80364e8:	7303      	strb	r3, [r0, #12]

    macMsg->FHDR.FCnt = macMsg->Buffer[bufItr++];
 80364ea:	798b      	ldrb	r3, [r1, #6]
 80364ec:	81c3      	strh	r3, [r0, #14]
    macMsg->FHDR.FCnt |= macMsg->Buffer[bufItr++] << 8;
 80364ee:	79ca      	ldrb	r2, [r1, #7]
 80364f0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8

    if( macMsg->FHDR.FCtrl.Bits.FOptsLen <= 15 )
    {
        memcpy1( macMsg->FHDR.FOpts, &macMsg->Buffer[bufItr], macMsg->FHDR.FCtrl.Bits.FOptsLen );
 80364f4:	7b02      	ldrb	r2, [r0, #12]
    macMsg->FHDR.FCnt |= macMsg->Buffer[bufItr++] << 8;
 80364f6:	81c3      	strh	r3, [r0, #14]
        memcpy1( macMsg->FHDR.FOpts, &macMsg->Buffer[bufItr], macMsg->FHDR.FCtrl.Bits.FOptsLen );
 80364f8:	f002 020f 	and.w	r2, r2, #15
 80364fc:	3108      	adds	r1, #8
 80364fe:	3010      	adds	r0, #16
 8036500:	f002 fcea 	bl	8038ed8 <memcpy1>
        bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 8036504:	7b23      	ldrb	r3, [r4, #12]
    {
        return LORAMAC_PARSER_FAIL;
    }

    // Initialize anyway with zero.
    macMsg->FPort = 0;
 8036506:	2200      	movs	r2, #0
        bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 8036508:	f003 030f 	and.w	r3, r3, #15
    macMsg->FPort = 0;
 803650c:	f884 2020 	strb.w	r2, [r4, #32]
    macMsg->FRMPayloadSize = 0;
 8036510:	f884 2028 	strb.w	r2, [r4, #40]	; 0x28

    if( ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE ) > 0 )
 8036514:	7922      	ldrb	r2, [r4, #4]
        bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 8036516:	f103 0008 	add.w	r0, r3, #8
    if( ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE ) > 0 )
 803651a:	1a11      	subs	r1, r2, r0
 803651c:	2904      	cmp	r1, #4
 803651e:	dd0d      	ble.n	803653c <LoRaMacParserData+0x84>
    {
        macMsg->FPort = macMsg->Buffer[bufItr++];
 8036520:	6821      	ldr	r1, [r4, #0]
 8036522:	3309      	adds	r3, #9

        macMsg->FRMPayloadSize = ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE );
 8036524:	3a04      	subs	r2, #4
 8036526:	1ad2      	subs	r2, r2, r3
        macMsg->FPort = macMsg->Buffer[bufItr++];
 8036528:	5c08      	ldrb	r0, [r1, r0]
 803652a:	f884 0020 	strb.w	r0, [r4, #32]
        macMsg->FRMPayloadSize = ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE );
 803652e:	b2d2      	uxtb	r2, r2
        memcpy1( macMsg->FRMPayload, &macMsg->Buffer[bufItr], macMsg->FRMPayloadSize );
 8036530:	6a60      	ldr	r0, [r4, #36]	; 0x24
        macMsg->FRMPayloadSize = ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE );
 8036532:	f884 2028 	strb.w	r2, [r4, #40]	; 0x28
        memcpy1( macMsg->FRMPayload, &macMsg->Buffer[bufItr], macMsg->FRMPayloadSize );
 8036536:	4419      	add	r1, r3
 8036538:	f002 fcce 	bl	8038ed8 <memcpy1>
        bufItr = bufItr + macMsg->FRMPayloadSize;
    }

    macMsg->MIC = ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE )];
 803653c:	7923      	ldrb	r3, [r4, #4]
 803653e:	6822      	ldr	r2, [r4, #0]
 8036540:	441a      	add	r2, r3
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 1] << 8 );
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 2] << 16 );
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 3] << 24 );

    return LORAMAC_PARSER_SUCCESS;
 8036542:	2000      	movs	r0, #0
    macMsg->MIC = ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE )];
 8036544:	f812 3c04 	ldrb.w	r3, [r2, #-4]
 8036548:	62e3      	str	r3, [r4, #44]	; 0x2c
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 1] << 8 );
 803654a:	f812 1c03 	ldrb.w	r1, [r2, #-3]
 803654e:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8036552:	62e3      	str	r3, [r4, #44]	; 0x2c
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 2] << 16 );
 8036554:	f812 1c02 	ldrb.w	r1, [r2, #-2]
 8036558:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 803655c:	62e3      	str	r3, [r4, #44]	; 0x2c
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 3] << 24 );
 803655e:	f812 2c01 	ldrb.w	r2, [r2, #-1]
 8036562:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8036566:	62e3      	str	r3, [r4, #44]	; 0x2c
}
 8036568:	bd10      	pop	{r4, pc}
        return LORAMAC_PARSER_ERROR_NPE;
 803656a:	2002      	movs	r0, #2
 803656c:	e7fc      	b.n	8036568 <LoRaMacParserData+0xb0>

0803656e <LoRaMacSerializerJoinRequest>:
 */
#include "LoRaMacSerializer.h"
#include "utilities.h"

LoRaMacSerializerStatus_t LoRaMacSerializerJoinRequest( LoRaMacMessageJoinRequest_t* macMsg )
{
 803656e:	b510      	push	{r4, lr}
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 8036570:	4604      	mov	r4, r0
 8036572:	b360      	cbz	r0, 80365ce <LoRaMacSerializerJoinRequest+0x60>
 8036574:	6803      	ldr	r3, [r0, #0]
 8036576:	b353      	cbz	r3, 80365ce <LoRaMacSerializerJoinRequest+0x60>
    }

    uint16_t bufItr = 0;

    // Check macMsg->BufSize
    if( macMsg->BufSize < LORAMAC_JOIN_REQ_MSG_SIZE )
 8036578:	7902      	ldrb	r2, [r0, #4]
 803657a:	2a16      	cmp	r2, #22
 803657c:	d929      	bls.n	80365d2 <LoRaMacSerializerJoinRequest+0x64>
    {
        return LORAMAC_SERIALIZER_ERROR_BUF_SIZE;
    }

    macMsg->Buffer[bufItr++] = macMsg->MHDR.Value;
 803657e:	7942      	ldrb	r2, [r0, #5]
 8036580:	701a      	strb	r2, [r3, #0]

    memcpyr( &macMsg->Buffer[bufItr], macMsg->JoinEUI, LORAMAC_JOIN_EUI_FIELD_SIZE );
 8036582:	4601      	mov	r1, r0
 8036584:	2208      	movs	r2, #8
 8036586:	f851 0b06 	ldr.w	r0, [r1], #6
 803658a:	3001      	adds	r0, #1
 803658c:	f002 fcae 	bl	8038eec <memcpyr>
    bufItr += LORAMAC_JOIN_EUI_FIELD_SIZE;

    memcpyr( &macMsg->Buffer[bufItr], macMsg->DevEUI, LORAMAC_DEV_EUI_FIELD_SIZE );
 8036590:	4621      	mov	r1, r4
 8036592:	2208      	movs	r2, #8
 8036594:	f851 0b0e 	ldr.w	r0, [r1], #14
 8036598:	3009      	adds	r0, #9
 803659a:	f002 fca7 	bl	8038eec <memcpyr>
    bufItr += LORAMAC_DEV_EUI_FIELD_SIZE;

    macMsg->Buffer[bufItr++] = macMsg->DevNonce & 0xFF;
 803659e:	6823      	ldr	r3, [r4, #0]
 80365a0:	8ae2      	ldrh	r2, [r4, #22]
 80365a2:	745a      	strb	r2, [r3, #17]
    macMsg->Buffer[bufItr++] = ( macMsg->DevNonce >> 8 ) & 0xFF;
 80365a4:	8ae3      	ldrh	r3, [r4, #22]
 80365a6:	6822      	ldr	r2, [r4, #0]
 80365a8:	0a1b      	lsrs	r3, r3, #8
 80365aa:	7493      	strb	r3, [r2, #18]

    macMsg->Buffer[bufItr++] = macMsg->MIC & 0xFF;
 80365ac:	6823      	ldr	r3, [r4, #0]
 80365ae:	69a2      	ldr	r2, [r4, #24]
 80365b0:	74da      	strb	r2, [r3, #19]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 8 ) & 0xFF;
 80365b2:	69a3      	ldr	r3, [r4, #24]
 80365b4:	6822      	ldr	r2, [r4, #0]
 80365b6:	0a1b      	lsrs	r3, r3, #8
 80365b8:	7513      	strb	r3, [r2, #20]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 16 ) & 0xFF;
 80365ba:	6823      	ldr	r3, [r4, #0]
 80365bc:	8b62      	ldrh	r2, [r4, #26]
 80365be:	755a      	strb	r2, [r3, #21]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 24 ) & 0xFF;
 80365c0:	6823      	ldr	r3, [r4, #0]
 80365c2:	7ee2      	ldrb	r2, [r4, #27]
 80365c4:	759a      	strb	r2, [r3, #22]

    macMsg->BufSize = bufItr;
 80365c6:	2317      	movs	r3, #23
 80365c8:	7123      	strb	r3, [r4, #4]

    return LORAMAC_SERIALIZER_SUCCESS;
 80365ca:	2000      	movs	r0, #0
}
 80365cc:	bd10      	pop	{r4, pc}
        return LORAMAC_SERIALIZER_ERROR_NPE;
 80365ce:	2001      	movs	r0, #1
 80365d0:	e7fc      	b.n	80365cc <LoRaMacSerializerJoinRequest+0x5e>
        return LORAMAC_SERIALIZER_ERROR_BUF_SIZE;
 80365d2:	2002      	movs	r0, #2
 80365d4:	e7fa      	b.n	80365cc <LoRaMacSerializerJoinRequest+0x5e>

080365d6 <LoRaMacSerializerData>:

    return LORAMAC_SERIALIZER_SUCCESS;
}

LoRaMacSerializerStatus_t LoRaMacSerializerData( LoRaMacMessageData_t* macMsg )
{
 80365d6:	b538      	push	{r3, r4, r5, lr}
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 80365d8:	4604      	mov	r4, r0
 80365da:	2800      	cmp	r0, #0
 80365dc:	d063      	beq.n	80366a6 <LoRaMacSerializerData+0xd0>
 80365de:	6801      	ldr	r1, [r0, #0]
 80365e0:	2900      	cmp	r1, #0
 80365e2:	d060      	beq.n	80366a6 <LoRaMacSerializerData+0xd0>
    uint16_t computedBufSize =   LORAMAC_MHDR_FIELD_SIZE
                               + LORAMAC_FHDR_DEV_ADDR_FIELD_SIZE
                               + LORAMAC_FHDR_F_CTRL_FIELD_SIZE
                               + LORAMAC_FHDR_F_CNT_FIELD_SIZE;

    computedBufSize += macMsg->FHDR.FCtrl.Bits.FOptsLen;
 80365e4:	7b03      	ldrb	r3, [r0, #12]

    if( macMsg->FRMPayloadSize > 0 )
 80365e6:	f890 2028 	ldrb.w	r2, [r0, #40]	; 0x28
    computedBufSize += macMsg->FHDR.FCtrl.Bits.FOptsLen;
 80365ea:	f003 030f 	and.w	r3, r3, #15
    if( macMsg->FRMPayloadSize > 0 )
 80365ee:	2a00      	cmp	r2, #0
 80365f0:	d157      	bne.n	80366a2 <LoRaMacSerializerData+0xcc>
    computedBufSize += macMsg->FHDR.FCtrl.Bits.FOptsLen;
 80365f2:	3308      	adds	r3, #8
    }

    computedBufSize += macMsg->FRMPayloadSize;
    computedBufSize += LORAMAC_MIC_FIELD_SIZE;

    if( macMsg->BufSize < computedBufSize )
 80365f4:	7920      	ldrb	r0, [r4, #4]
    computedBufSize += LORAMAC_MIC_FIELD_SIZE;
 80365f6:	3204      	adds	r2, #4
    if( macMsg->BufSize < computedBufSize )
 80365f8:	4413      	add	r3, r2
 80365fa:	4298      	cmp	r0, r3
 80365fc:	d355      	bcc.n	80366aa <LoRaMacSerializerData+0xd4>
    {
        return LORAMAC_SERIALIZER_ERROR_BUF_SIZE;
    }

    macMsg->Buffer[bufItr++] = macMsg->MHDR.Value;
 80365fe:	7963      	ldrb	r3, [r4, #5]
 8036600:	700b      	strb	r3, [r1, #0]

    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr ) & 0xFF;
 8036602:	6823      	ldr	r3, [r4, #0]
 8036604:	68a2      	ldr	r2, [r4, #8]
 8036606:	705a      	strb	r2, [r3, #1]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr >> 8 ) & 0xFF;
 8036608:	68a3      	ldr	r3, [r4, #8]
 803660a:	6822      	ldr	r2, [r4, #0]
 803660c:	0a1b      	lsrs	r3, r3, #8
 803660e:	7093      	strb	r3, [r2, #2]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr >> 16 ) & 0xFF;
 8036610:	6823      	ldr	r3, [r4, #0]
 8036612:	8962      	ldrh	r2, [r4, #10]
 8036614:	70da      	strb	r2, [r3, #3]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr >> 24 ) & 0xFF;
 8036616:	6823      	ldr	r3, [r4, #0]
 8036618:	7ae2      	ldrb	r2, [r4, #11]
 803661a:	711a      	strb	r2, [r3, #4]

    macMsg->Buffer[bufItr++] = macMsg->FHDR.FCtrl.Value;
 803661c:	6823      	ldr	r3, [r4, #0]
 803661e:	7b22      	ldrb	r2, [r4, #12]
 8036620:	715a      	strb	r2, [r3, #5]

    macMsg->Buffer[bufItr++] = macMsg->FHDR.FCnt & 0xFF;
 8036622:	6823      	ldr	r3, [r4, #0]
 8036624:	89e2      	ldrh	r2, [r4, #14]
 8036626:	719a      	strb	r2, [r3, #6]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.FCnt >> 8 ) & 0xFF;
 8036628:	89e3      	ldrh	r3, [r4, #14]
 803662a:	6822      	ldr	r2, [r4, #0]
 803662c:	0a1b      	lsrs	r3, r3, #8

    memcpy1( &macMsg->Buffer[bufItr], macMsg->FHDR.FOpts, macMsg->FHDR.FCtrl.Bits.FOptsLen );
 803662e:	4621      	mov	r1, r4
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.FCnt >> 8 ) & 0xFF;
 8036630:	71d3      	strb	r3, [r2, #7]
    memcpy1( &macMsg->Buffer[bufItr], macMsg->FHDR.FOpts, macMsg->FHDR.FCtrl.Bits.FOptsLen );
 8036632:	7b22      	ldrb	r2, [r4, #12]
 8036634:	f851 0b10 	ldr.w	r0, [r1], #16
 8036638:	f002 020f 	and.w	r2, r2, #15
 803663c:	3008      	adds	r0, #8
 803663e:	f002 fc4b 	bl	8038ed8 <memcpy1>
    bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 8036642:	7b23      	ldrb	r3, [r4, #12]

    if( macMsg->FRMPayloadSize > 0 )
 8036644:	f894 2028 	ldrb.w	r2, [r4, #40]	; 0x28
    bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 8036648:	f003 030f 	and.w	r3, r3, #15
 803664c:	f103 0508 	add.w	r5, r3, #8
    if( macMsg->FRMPayloadSize > 0 )
 8036650:	b12a      	cbz	r2, 803665e <LoRaMacSerializerData+0x88>
    {
        macMsg->Buffer[bufItr++] = macMsg->FPort;
 8036652:	6822      	ldr	r2, [r4, #0]
 8036654:	f894 1020 	ldrb.w	r1, [r4, #32]
 8036658:	5551      	strb	r1, [r2, r5]
 803665a:	f103 0509 	add.w	r5, r3, #9
    }

    memcpy1( &macMsg->Buffer[bufItr], macMsg->FRMPayload, macMsg->FRMPayloadSize );
 803665e:	6820      	ldr	r0, [r4, #0]
 8036660:	f894 2028 	ldrb.w	r2, [r4, #40]	; 0x28
 8036664:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8036666:	4428      	add	r0, r5
 8036668:	f002 fc36 	bl	8038ed8 <memcpy1>
    bufItr = bufItr + macMsg->FRMPayloadSize;
 803666c:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28

    macMsg->Buffer[bufItr++] = macMsg->MIC & 0xFF;
 8036670:	6822      	ldr	r2, [r4, #0]
 8036672:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
    bufItr = bufItr + macMsg->FRMPayloadSize;
 8036674:	442b      	add	r3, r5
    macMsg->Buffer[bufItr++] = macMsg->MIC & 0xFF;
 8036676:	54d1      	strb	r1, [r2, r3]
 8036678:	1c5a      	adds	r2, r3, #1
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 8 ) & 0xFF;
 803667a:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 803667c:	6820      	ldr	r0, [r4, #0]
 803667e:	b292      	uxth	r2, r2
 8036680:	0a09      	lsrs	r1, r1, #8
 8036682:	5481      	strb	r1, [r0, r2]
 8036684:	1c9a      	adds	r2, r3, #2
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 16 ) & 0xFF;
 8036686:	6821      	ldr	r1, [r4, #0]
 8036688:	8de0      	ldrh	r0, [r4, #46]	; 0x2e
 803668a:	b292      	uxth	r2, r2
 803668c:	5488      	strb	r0, [r1, r2]
 803668e:	1cda      	adds	r2, r3, #3
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 24 ) & 0xFF;
 8036690:	6821      	ldr	r1, [r4, #0]
 8036692:	f894 002f 	ldrb.w	r0, [r4, #47]	; 0x2f
 8036696:	b292      	uxth	r2, r2
 8036698:	3304      	adds	r3, #4
 803669a:	5488      	strb	r0, [r1, r2]

    macMsg->BufSize = bufItr;
 803669c:	7123      	strb	r3, [r4, #4]

    return LORAMAC_SERIALIZER_SUCCESS;
 803669e:	2000      	movs	r0, #0
}
 80366a0:	bd38      	pop	{r3, r4, r5, pc}
        computedBufSize += LORAMAC_F_PORT_FIELD_SIZE;
 80366a2:	3309      	adds	r3, #9
 80366a4:	e7a6      	b.n	80365f4 <LoRaMacSerializerData+0x1e>
        return LORAMAC_SERIALIZER_ERROR_NPE;
 80366a6:	2001      	movs	r0, #1
 80366a8:	e7fa      	b.n	80366a0 <LoRaMacSerializerData+0xca>
        return LORAMAC_SERIALIZER_ERROR_BUF_SIZE;
 80366aa:	2002      	movs	r0, #2
 80366ac:	e7f8      	b.n	80366a0 <LoRaMacSerializerData+0xca>

080366ae <NvmDataMgmtEvent>:
void NvmDataMgmtEvent( uint16_t notifyFlags )
{
#if( CONTEXT_MANAGEMENT_ENABLED == 1 )
    NvmNotifyFlags = notifyFlags;
#endif /* CONTEXT_MANAGEMENT_ENABLED == 1 */
}
 80366ae:	4770      	bx	lr

080366b0 <NvmDataMgmtStore>:
    LoRaMacStart( );
    return dataSize;
#else
    return 0;
#endif
}
 80366b0:	2000      	movs	r0, #0
 80366b2:	4770      	bx	lr

080366b4 <NvmDataMgmtRestore>:
 80366b4:	2000      	movs	r0, #0
 80366b6:	4770      	bx	lr

080366b8 <RegionIsActive>:
#define RU864_RX_BEACON_SETUP( )
#endif

bool RegionIsActive( LoRaMacRegion_t region )
{
    switch( region )
 80366b8:	2805      	cmp	r0, #5
 80366ba:	d004      	beq.n	80366c6 <RegionIsActive+0xe>
 80366bc:	f1a0 0308 	sub.w	r3, r0, #8
 80366c0:	4258      	negs	r0, r3
 80366c2:	4158      	adcs	r0, r3
 80366c4:	4770      	bx	lr
        AS923_IS_ACTIVE( );
        AU915_IS_ACTIVE( );
        CN470_IS_ACTIVE( );
        CN779_IS_ACTIVE( );
        EU433_IS_ACTIVE( );
        EU868_IS_ACTIVE( );
 80366c6:	2001      	movs	r0, #1
        default:
        {
            return false;
        }
    }
}
 80366c8:	4770      	bx	lr

080366ca <RegionGetPhyParam>:

PhyParam_t RegionGetPhyParam( LoRaMacRegion_t region, GetPhyParams_t* getPhy )
{
 80366ca:	4603      	mov	r3, r0
    PhyParam_t phyParam = { 0 };
    switch( region )
 80366cc:	2b05      	cmp	r3, #5
{
 80366ce:	b082      	sub	sp, #8
 80366d0:	4608      	mov	r0, r1
    switch( region )
 80366d2:	d004      	beq.n	80366de <RegionGetPhyParam+0x14>
 80366d4:	2b08      	cmp	r3, #8
 80366d6:	d005      	beq.n	80366e4 <RegionGetPhyParam+0x1a>
        default:
        {
            return phyParam;
        }
    }
}
 80366d8:	2000      	movs	r0, #0
 80366da:	b002      	add	sp, #8
 80366dc:	4770      	bx	lr
 80366de:	b002      	add	sp, #8
        EU868_GET_PHY_PARAM( );
 80366e0:	f000 bcf4 	b.w	80370cc <RegionEU868GetPhyParam>
}
 80366e4:	b002      	add	sp, #8
        US915_GET_PHY_PARAM( );
 80366e6:	f001 ba35 	b.w	8037b54 <RegionUS915GetPhyParam>

080366ea <RegionSetBandTxDone>:

void RegionSetBandTxDone( LoRaMacRegion_t region, SetBandTxDoneParams_t* txDone )
{
 80366ea:	4603      	mov	r3, r0
    switch( region )
 80366ec:	2b05      	cmp	r3, #5
{
 80366ee:	4608      	mov	r0, r1
    switch( region )
 80366f0:	d002      	beq.n	80366f8 <RegionSetBandTxDone+0xe>
 80366f2:	2b08      	cmp	r3, #8
 80366f4:	d002      	beq.n	80366fc <RegionSetBandTxDone+0x12>
 80366f6:	4770      	bx	lr
        AS923_SET_BAND_TX_DONE( );
        AU915_SET_BAND_TX_DONE( );
        CN470_SET_BAND_TX_DONE( );
        CN779_SET_BAND_TX_DONE( );
        EU433_SET_BAND_TX_DONE( );
        EU868_SET_BAND_TX_DONE( );
 80366f8:	f000 bd88 	b.w	803720c <RegionEU868SetBandTxDone>
        KR920_SET_BAND_TX_DONE( );
        IN865_SET_BAND_TX_DONE( );
        US915_SET_BAND_TX_DONE( );
 80366fc:	f001 bad4 	b.w	8037ca8 <RegionUS915SetBandTxDone>

08036700 <RegionInitDefaults>:
        }
    }
}

void RegionInitDefaults( LoRaMacRegion_t region, InitDefaultsParams_t* params )
{
 8036700:	4603      	mov	r3, r0
    switch( region )
 8036702:	2b05      	cmp	r3, #5
{
 8036704:	4608      	mov	r0, r1
    switch( region )
 8036706:	d002      	beq.n	803670e <RegionInitDefaults+0xe>
 8036708:	2b08      	cmp	r3, #8
 803670a:	d002      	beq.n	8036712 <RegionInitDefaults+0x12>
 803670c:	4770      	bx	lr
        AS923_INIT_DEFAULTS( );
        AU915_INIT_DEFAULTS( );
        CN470_INIT_DEFAULTS( );
        CN779_INIT_DEFAULTS( );
        EU433_INIT_DEFAULTS( );
        EU868_INIT_DEFAULTS( );
 803670e:	f000 bd95 	b.w	803723c <RegionEU868InitDefaults>
        KR920_INIT_DEFAULTS( );
        IN865_INIT_DEFAULTS( );
        US915_INIT_DEFAULTS( );
 8036712:	f001 bae1 	b.w	8037cd8 <RegionUS915InitDefaults>

08036716 <RegionVerify>:
        }
    }
}

bool RegionVerify( LoRaMacRegion_t region, VerifyParams_t* verify, PhyAttribute_t phyAttribute )
{
 8036716:	4603      	mov	r3, r0
    switch( region )
 8036718:	2b05      	cmp	r3, #5
{
 803671a:	4608      	mov	r0, r1
 803671c:	4611      	mov	r1, r2
    switch( region )
 803671e:	d003      	beq.n	8036728 <RegionVerify+0x12>
 8036720:	2b08      	cmp	r3, #8
 8036722:	d003      	beq.n	803672c <RegionVerify+0x16>
        default:
        {
            return false;
        }
    }
}
 8036724:	2000      	movs	r0, #0
 8036726:	4770      	bx	lr
        EU868_VERIFY( );
 8036728:	f000 bdea 	b.w	8037300 <RegionEU868Verify>
        US915_VERIFY( );
 803672c:	f001 bb56 	b.w	8037ddc <RegionUS915Verify>

08036730 <RegionApplyCFList>:

void RegionApplyCFList( LoRaMacRegion_t region, ApplyCFListParams_t* applyCFList )
{
 8036730:	4603      	mov	r3, r0
    switch( region )
 8036732:	2b05      	cmp	r3, #5
{
 8036734:	4608      	mov	r0, r1
    switch( region )
 8036736:	d002      	beq.n	803673e <RegionApplyCFList+0xe>
 8036738:	2b08      	cmp	r3, #8
 803673a:	d002      	beq.n	8036742 <RegionApplyCFList+0x12>
 803673c:	4770      	bx	lr
        AS923_APPLY_CF_LIST( );
        AU915_APPLY_CF_LIST( );
        CN470_APPLY_CF_LIST( );
        CN779_APPLY_CF_LIST( );
        EU433_APPLY_CF_LIST( );
        EU868_APPLY_CF_LIST( );
 803673e:	f001 b93f 	b.w	80379c0 <RegionEU868ApplyCFList>
        KR920_APPLY_CF_LIST( );
        IN865_APPLY_CF_LIST( );
        US915_APPLY_CF_LIST( );
 8036742:	f001 bb6d 	b.w	8037e20 <RegionUS915ApplyCFList>

08036746 <RegionChanMaskSet>:
        }
    }
}

bool RegionChanMaskSet( LoRaMacRegion_t region, ChanMaskSetParams_t* chanMaskSet )
{
 8036746:	4603      	mov	r3, r0
    switch( region )
 8036748:	2b05      	cmp	r3, #5
{
 803674a:	4608      	mov	r0, r1
    switch( region )
 803674c:	d003      	beq.n	8036756 <RegionChanMaskSet+0x10>
 803674e:	2b08      	cmp	r3, #8
 8036750:	d003      	beq.n	803675a <RegionChanMaskSet+0x14>
        default:
        {
            return false;
        }
    }
}
 8036752:	2000      	movs	r0, #0
 8036754:	4770      	bx	lr
        EU868_CHAN_MASK_SET( );
 8036756:	f000 bdfb 	b.w	8037350 <RegionEU868ChanMaskSet>
        US915_CHAN_MASK_SET( );
 803675a:	f001 bb8b 	b.w	8037e74 <RegionUS915ChanMaskSet>

0803675e <RegionComputeRxWindowParameters>:

void RegionComputeRxWindowParameters( LoRaMacRegion_t region, int8_t datarate, uint8_t minRxSymbols, uint32_t rxError, RxConfigParams_t *rxConfigParams )
{
 803675e:	b410      	push	{r4}
 8036760:	4604      	mov	r4, r0
    switch( region )
 8036762:	2c05      	cmp	r4, #5
{
 8036764:	4608      	mov	r0, r1
 8036766:	4611      	mov	r1, r2
 8036768:	461a      	mov	r2, r3
 803676a:	9b01      	ldr	r3, [sp, #4]
    switch( region )
 803676c:	d003      	beq.n	8036776 <RegionComputeRxWindowParameters+0x18>
 803676e:	2c08      	cmp	r4, #8
 8036770:	d004      	beq.n	803677c <RegionComputeRxWindowParameters+0x1e>
        default:
        {
            break;
        }
    }
}
 8036772:	bc10      	pop	{r4}
 8036774:	4770      	bx	lr
 8036776:	bc10      	pop	{r4}
        EU868_COMPUTE_RX_WINDOW_PARAMETERS( );
 8036778:	f000 be08 	b.w	803738c <RegionEU868ComputeRxWindowParameters>
}
 803677c:	bc10      	pop	{r4}
        US915_COMPUTE_RX_WINDOW_PARAMETERS( );
 803677e:	f001 bbb3 	b.w	8037ee8 <RegionUS915ComputeRxWindowParameters>

08036782 <RegionRxConfig>:

bool RegionRxConfig( LoRaMacRegion_t region, RxConfigParams_t* rxConfig, int8_t* datarate )
{
 8036782:	4603      	mov	r3, r0
    switch( region )
 8036784:	2b05      	cmp	r3, #5
{
 8036786:	4608      	mov	r0, r1
 8036788:	4611      	mov	r1, r2
    switch( region )
 803678a:	d003      	beq.n	8036794 <RegionRxConfig+0x12>
 803678c:	2b08      	cmp	r3, #8
 803678e:	d003      	beq.n	8036798 <RegionRxConfig+0x16>
        default:
        {
            return false;
        }
    }
}
 8036790:	2000      	movs	r0, #0
 8036792:	4770      	bx	lr
        EU868_RX_CONFIG( );
 8036794:	f000 be2c 	b.w	80373f0 <RegionEU868RxConfig>
        US915_RX_CONFIG( );
 8036798:	f001 bbd2 	b.w	8037f40 <RegionUS915RxConfig>

0803679c <RegionTxConfig>:

bool RegionTxConfig( LoRaMacRegion_t region, TxConfigParams_t* txConfig, int8_t* txPower, TimerTime_t* txTimeOnAir )
{
 803679c:	b410      	push	{r4}
 803679e:	4604      	mov	r4, r0
    switch( region )
 80367a0:	2c05      	cmp	r4, #5
{
 80367a2:	4608      	mov	r0, r1
 80367a4:	4611      	mov	r1, r2
 80367a6:	461a      	mov	r2, r3
    switch( region )
 80367a8:	d004      	beq.n	80367b4 <RegionTxConfig+0x18>
 80367aa:	2c08      	cmp	r4, #8
 80367ac:	d005      	beq.n	80367ba <RegionTxConfig+0x1e>
        default:
        {
            return false;
        }
    }
}
 80367ae:	2000      	movs	r0, #0
 80367b0:	bc10      	pop	{r4}
 80367b2:	4770      	bx	lr
 80367b4:	bc10      	pop	{r4}
        EU868_TX_CONFIG( );
 80367b6:	f000 be99 	b.w	80374ec <RegionEU868TxConfig>
}
 80367ba:	bc10      	pop	{r4}
        US915_TX_CONFIG( );
 80367bc:	f001 bc14 	b.w	8037fe8 <RegionUS915TxConfig>

080367c0 <RegionLinkAdrReq>:

uint8_t RegionLinkAdrReq( LoRaMacRegion_t region, LinkAdrReqParams_t* linkAdrReq, int8_t* drOut, int8_t* txPowOut, uint8_t* nbRepOut, uint8_t* nbBytesParsed )
{
 80367c0:	b430      	push	{r4, r5}
 80367c2:	4604      	mov	r4, r0
    switch( region )
 80367c4:	2c05      	cmp	r4, #5
{
 80367c6:	4608      	mov	r0, r1
 80367c8:	4611      	mov	r1, r2
 80367ca:	461a      	mov	r2, r3
 80367cc:	e9dd 3502 	ldrd	r3, r5, [sp, #8]
    switch( region )
 80367d0:	d004      	beq.n	80367dc <RegionLinkAdrReq+0x1c>
 80367d2:	2c08      	cmp	r4, #8
 80367d4:	d006      	beq.n	80367e4 <RegionLinkAdrReq+0x24>
        default:
        {
            return 0;
        }
    }
}
 80367d6:	2000      	movs	r0, #0
 80367d8:	bc30      	pop	{r4, r5}
 80367da:	4770      	bx	lr
        EU868_LINK_ADR_REQ( );
 80367dc:	9502      	str	r5, [sp, #8]
}
 80367de:	bc30      	pop	{r4, r5}
        EU868_LINK_ADR_REQ( );
 80367e0:	f000 bf08 	b.w	80375f4 <RegionEU868LinkAdrReq>
        US915_LINK_ADR_REQ( );
 80367e4:	9502      	str	r5, [sp, #8]
}
 80367e6:	bc30      	pop	{r4, r5}
        US915_LINK_ADR_REQ( );
 80367e8:	f001 bc86 	b.w	80380f8 <RegionUS915LinkAdrReq>

080367ec <RegionRxParamSetupReq>:

uint8_t RegionRxParamSetupReq( LoRaMacRegion_t region, RxParamSetupReqParams_t* rxParamSetupReq )
{
 80367ec:	4603      	mov	r3, r0
    switch( region )
 80367ee:	2b05      	cmp	r3, #5
{
 80367f0:	4608      	mov	r0, r1
    switch( region )
 80367f2:	d003      	beq.n	80367fc <RegionRxParamSetupReq+0x10>
 80367f4:	2b08      	cmp	r3, #8
 80367f6:	d003      	beq.n	8036800 <RegionRxParamSetupReq+0x14>
        default:
        {
            return 0;
        }
    }
}
 80367f8:	2000      	movs	r0, #0
 80367fa:	4770      	bx	lr
        EU868_RX_PARAM_SETUP_REQ( );
 80367fc:	f000 bfa8 	b.w	8037750 <RegionEU868RxParamSetupReq>
        US915_RX_PARAM_SETUP_REQ( );
 8036800:	f001 bd90 	b.w	8038324 <RegionUS915RxParamSetupReq>

08036804 <RegionNewChannelReq>:

int8_t RegionNewChannelReq( LoRaMacRegion_t region, NewChannelReqParams_t* newChannelReq )
{
 8036804:	4603      	mov	r3, r0
    switch( region )
 8036806:	2b05      	cmp	r3, #5
{
 8036808:	4608      	mov	r0, r1
    switch( region )
 803680a:	d003      	beq.n	8036814 <RegionNewChannelReq+0x10>
 803680c:	2b08      	cmp	r3, #8
 803680e:	d003      	beq.n	8036818 <RegionNewChannelReq+0x14>
        default:
        {
            return 0;
        }
    }
}
 8036810:	2000      	movs	r0, #0
 8036812:	4770      	bx	lr
        EU868_NEW_CHANNEL_REQ( );
 8036814:	f001 b912 	b.w	8037a3c <RegionEU868NewChannelReq>
        US915_NEW_CHANNEL_REQ( );
 8036818:	f001 bdb0 	b.w	803837c <RegionUS915NewChannelReq>

0803681c <RegionTxParamSetupReq>:

int8_t RegionTxParamSetupReq( LoRaMacRegion_t region, TxParamSetupReqParams_t* txParamSetupReq )
{
 803681c:	4603      	mov	r3, r0
    switch( region )
 803681e:	2b05      	cmp	r3, #5
{
 8036820:	4608      	mov	r0, r1
    switch( region )
 8036822:	d003      	beq.n	803682c <RegionTxParamSetupReq+0x10>
 8036824:	2b08      	cmp	r3, #8
 8036826:	d003      	beq.n	8036830 <RegionTxParamSetupReq+0x14>
        default:
        {
            return 0;
        }
    }
}
 8036828:	2000      	movs	r0, #0
 803682a:	4770      	bx	lr
        EU868_TX_PARAM_SETUP_REQ( );
 803682c:	f000 bfb3 	b.w	8037796 <RegionEU868TxParamSetupReq>
        US915_TX_PARAM_SETUP_REQ( );
 8036830:	f001 bda7 	b.w	8038382 <RegionUS915TxParamSetupReq>

08036834 <RegionDlChannelReq>:

int8_t RegionDlChannelReq( LoRaMacRegion_t region, DlChannelReqParams_t* dlChannelReq )
{
 8036834:	4603      	mov	r3, r0
    switch( region )
 8036836:	2b05      	cmp	r3, #5
{
 8036838:	4608      	mov	r0, r1
    switch( region )
 803683a:	d003      	beq.n	8036844 <RegionDlChannelReq+0x10>
 803683c:	2b08      	cmp	r3, #8
 803683e:	d003      	beq.n	8036848 <RegionDlChannelReq+0x14>
        default:
        {
            return 0;
        }
    }
}
 8036840:	2000      	movs	r0, #0
 8036842:	4770      	bx	lr
        EU868_DL_CHANNEL_REQ( );
 8036844:	f000 bfaa 	b.w	803779c <RegionEU868DlChannelReq>
        US915_DL_CHANNEL_REQ( );
 8036848:	f001 bd9e 	b.w	8038388 <RegionUS915DlChannelReq>

0803684c <RegionAlternateDr>:

int8_t RegionAlternateDr( LoRaMacRegion_t region, int8_t currentDr, AlternateDrType_t type )
{
 803684c:	4603      	mov	r3, r0
    switch( region )
 803684e:	2b05      	cmp	r3, #5
{
 8036850:	4608      	mov	r0, r1
 8036852:	4611      	mov	r1, r2
    switch( region )
 8036854:	d003      	beq.n	803685e <RegionAlternateDr+0x12>
 8036856:	2b08      	cmp	r3, #8
 8036858:	d003      	beq.n	8036862 <RegionAlternateDr+0x16>
        default:
        {
            return 0;
        }
    }
}
 803685a:	2000      	movs	r0, #0
 803685c:	4770      	bx	lr
        EU868_ALTERNATE_DR( );
 803685e:	f000 bfc1 	b.w	80377e4 <RegionEU868AlternateDr>
        US915_ALTERNATE_DR( );
 8036862:	f001 bd95 	b.w	8038390 <RegionUS915AlternateDr>

08036866 <RegionNextChannel>:

LoRaMacStatus_t RegionNextChannel( LoRaMacRegion_t region, NextChanParams_t* nextChanParams, uint8_t* channel, TimerTime_t* time, TimerTime_t* aggregatedTimeOff )
{
 8036866:	b410      	push	{r4}
 8036868:	4604      	mov	r4, r0
    switch( region )
 803686a:	2c05      	cmp	r4, #5
{
 803686c:	4608      	mov	r0, r1
 803686e:	4611      	mov	r1, r2
 8036870:	461a      	mov	r2, r3
 8036872:	9b01      	ldr	r3, [sp, #4]
    switch( region )
 8036874:	d004      	beq.n	8036880 <RegionNextChannel+0x1a>
 8036876:	2c08      	cmp	r4, #8
 8036878:	d005      	beq.n	8036886 <RegionNextChannel+0x20>
        default:
        {
            return LORAMAC_STATUS_REGION_NOT_SUPPORTED;
        }
    }
}
 803687a:	2009      	movs	r0, #9
 803687c:	bc10      	pop	{r4}
 803687e:	4770      	bx	lr
 8036880:	bc10      	pop	{r4}
        EU868_NEXT_CHANNEL( );
 8036882:	f000 bfb1 	b.w	80377e8 <RegionEU868NextChannel>
}
 8036886:	bc10      	pop	{r4}
        US915_NEXT_CHANNEL( );
 8036888:	f001 bd9a 	b.w	80383c0 <RegionUS915NextChannel>

0803688c <RegionSetContinuousWave>:
        }
    }
}

void RegionSetContinuousWave( LoRaMacRegion_t region, ContinuousWaveParams_t* continuousWave )
{
 803688c:	4603      	mov	r3, r0
    switch( region )
 803688e:	2b05      	cmp	r3, #5
{
 8036890:	4608      	mov	r0, r1
    switch( region )
 8036892:	d002      	beq.n	803689a <RegionSetContinuousWave+0xe>
 8036894:	2b08      	cmp	r3, #8
 8036896:	d002      	beq.n	803689e <RegionSetContinuousWave+0x12>
 8036898:	4770      	bx	lr
        AS923_SET_CONTINUOUS_WAVE( );
        AU915_SET_CONTINUOUS_WAVE( );
        CN470_SET_CONTINUOUS_WAVE( );
        CN779_SET_CONTINUOUS_WAVE( );
        EU433_SET_CONTINUOUS_WAVE( );
        EU868_SET_CONTINUOUS_WAVE( );
 803689a:	f001 b8f1 	b.w	8037a80 <RegionEU868SetContinuousWave>
        KR920_SET_CONTINUOUS_WAVE( );
        IN865_SET_CONTINUOUS_WAVE( );
        US915_SET_CONTINUOUS_WAVE( );
 803689e:	f001 be2b 	b.w	80384f8 <RegionUS915SetContinuousWave>

080368a2 <RegionApplyDrOffset>:
        }
    }
}

uint8_t RegionApplyDrOffset( LoRaMacRegion_t region, uint8_t downlinkDwellTime, int8_t dr, int8_t drOffset )
{
 80368a2:	b410      	push	{r4}
 80368a4:	4604      	mov	r4, r0
    switch( region )
 80368a6:	2c05      	cmp	r4, #5
{
 80368a8:	4608      	mov	r0, r1
 80368aa:	4611      	mov	r1, r2
 80368ac:	461a      	mov	r2, r3
    switch( region )
 80368ae:	d004      	beq.n	80368ba <RegionApplyDrOffset+0x18>
 80368b0:	2c08      	cmp	r4, #8
 80368b2:	d005      	beq.n	80368c0 <RegionApplyDrOffset+0x1e>
        default:
        {
            return dr;
        }
    }
}
 80368b4:	b2c8      	uxtb	r0, r1
 80368b6:	bc10      	pop	{r4}
 80368b8:	4770      	bx	lr
 80368ba:	bc10      	pop	{r4}
        EU868_APPLY_DR_OFFSET( );
 80368bc:	f001 b908 	b.w	8037ad0 <RegionEU868ApplyDrOffset>
}
 80368c0:	bc10      	pop	{r4}
        US915_APPLY_DR_OFFSET( );
 80368c2:	f001 be61 	b.w	8038588 <RegionUS915ApplyDrOffset>
	...

080368c8 <RegionGetVersion>:
    Version_t version;

    version.Value = REGION_VERSION;

    return version;
}
 80368c8:	4800      	ldr	r0, [pc, #0]	; (80368cc <RegionGetVersion+0x4>)
 80368ca:	4770      	bx	lr
 80368cc:	01000300 	.word	0x01000300

080368d0 <RegionBaseUSComputeNext125kHzJoinChannel>:
    return LORAMAC_STATUS_OK;
}

LoRaMacStatus_t RegionBaseUSComputeNext125kHzJoinChannel( uint16_t* channelsMaskRemaining,
                                                          uint8_t* groupsCurrentIndex, uint8_t* newChannelIndex )
{
 80368d0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    uint8_t currentChannelMaskLeftIndex;
    uint16_t currentChannelMaskLeft;
    uint8_t findAvailableChannelsIndex[8] = { 0 };
 80368d4:	2300      	movs	r3, #0
 80368d6:	e9cd 3300 	strd	r3, r3, [sp]
{
 80368da:	460e      	mov	r6, r1
 80368dc:	4690      	mov	r8, r2
    uint8_t availableChannels = 0;
    uint8_t startIndex;

    // Null pointer check
    if( channelsMaskRemaining == NULL || groupsCurrentIndex == NULL || newChannelIndex == NULL )
 80368de:	4607      	mov	r7, r0
 80368e0:	b918      	cbnz	r0, 80368ea <RegionBaseUSComputeNext125kHzJoinChannel+0x1a>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
 80368e2:	2003      	movs	r0, #3
        *groupsCurrentIndex = startIndex;
        return LORAMAC_STATUS_OK;
    }

    return LORAMAC_STATUS_PARAMETER_INVALID;
}
 80368e4:	b002      	add	sp, #8
 80368e6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if( channelsMaskRemaining == NULL || groupsCurrentIndex == NULL || newChannelIndex == NULL )
 80368ea:	2900      	cmp	r1, #0
 80368ec:	d0f9      	beq.n	80368e2 <RegionBaseUSComputeNext125kHzJoinChannel+0x12>
 80368ee:	2a00      	cmp	r2, #0
 80368f0:	d0f7      	beq.n	80368e2 <RegionBaseUSComputeNext125kHzJoinChannel+0x12>
    startIndex = *groupsCurrentIndex;
 80368f2:	780c      	ldrb	r4, [r1, #0]
        if( ( startIndex % 2 ) == 0 )
 80368f4:	0863      	lsrs	r3, r4, #1
 80368f6:	07e0      	lsls	r0, r4, #31
            currentChannelMaskLeft = ( channelsMaskRemaining[currentChannelMaskLeftIndex] & 0x00FF );
 80368f8:	f837 1013 	ldrh.w	r1, [r7, r3, lsl #1]
{
 80368fc:	f04f 0300 	mov.w	r3, #0
            currentChannelMaskLeft = ( channelsMaskRemaining[currentChannelMaskLeftIndex] & 0x00FF );
 8036900:	bf54      	ite	pl
 8036902:	b2c9      	uxtbpl	r1, r1
            currentChannelMaskLeft = ( ( channelsMaskRemaining[currentChannelMaskLeftIndex] >> 8 ) & 0x00FF );
 8036904:	0a09      	lsrmi	r1, r1, #8
    *availableChannels = 0;
 8036906:	461d      	mov	r5, r3
        if( ( currentChannelMaskLeft & ( 1 << i ) ) != 0 )
 8036908:	fa41 f203 	asr.w	r2, r1, r3
 803690c:	07d2      	lsls	r2, r2, #31
 803690e:	b2d8      	uxtb	r0, r3
 8036910:	d505      	bpl.n	803691e <RegionBaseUSComputeNext125kHzJoinChannel+0x4e>
            findAvailableChannelsIndex[*availableChannels] = i;
 8036912:	aa02      	add	r2, sp, #8
 8036914:	442a      	add	r2, r5
            ( *availableChannels )++;
 8036916:	3501      	adds	r5, #1
            findAvailableChannelsIndex[*availableChannels] = i;
 8036918:	f802 0c08 	strb.w	r0, [r2, #-8]
            ( *availableChannels )++;
 803691c:	b2ed      	uxtb	r5, r5
    for( uint8_t i = 0; i < 8; i++ )
 803691e:	3301      	adds	r3, #1
 8036920:	2b08      	cmp	r3, #8
 8036922:	d1f1      	bne.n	8036908 <RegionBaseUSComputeNext125kHzJoinChannel+0x38>
        if ( availableChannels > 0 )
 8036924:	b15d      	cbz	r5, 803693e <RegionBaseUSComputeNext125kHzJoinChannel+0x6e>
            *newChannelIndex = ( startIndex * 8 ) + findAvailableChannelsIndex[randr( 0, ( availableChannels - 1 ) )];
 8036926:	1e69      	subs	r1, r5, #1
 8036928:	2000      	movs	r0, #0
 803692a:	f002 fab9 	bl	8038ea0 <randr>
 803692e:	ab02      	add	r3, sp, #8
 8036930:	4418      	add	r0, r3
 8036932:	f810 3c08 	ldrb.w	r3, [r0, #-8]
 8036936:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 803693a:	f888 3000 	strb.w	r3, [r8]
        startIndex++;
 803693e:	3401      	adds	r4, #1
 8036940:	b2e4      	uxtb	r4, r4
            startIndex = 0;
 8036942:	2c08      	cmp	r4, #8
 8036944:	bf28      	it	cs
 8036946:	2400      	movcs	r4, #0
    } while( ( availableChannels == 0 ) && ( startIndex != *groupsCurrentIndex ) );
 8036948:	b91d      	cbnz	r5, 8036952 <RegionBaseUSComputeNext125kHzJoinChannel+0x82>
 803694a:	7833      	ldrb	r3, [r6, #0]
 803694c:	42a3      	cmp	r3, r4
 803694e:	d1d1      	bne.n	80368f4 <RegionBaseUSComputeNext125kHzJoinChannel+0x24>
 8036950:	e7c7      	b.n	80368e2 <RegionBaseUSComputeNext125kHzJoinChannel+0x12>
        *groupsCurrentIndex = startIndex;
 8036952:	7034      	strb	r4, [r6, #0]
        return LORAMAC_STATUS_OK;
 8036954:	2000      	movs	r0, #0
 8036956:	e7c5      	b.n	80368e4 <RegionBaseUSComputeNext125kHzJoinChannel+0x14>

08036958 <RegionBaseUSCalcDownlinkFrequency>:
uint32_t RegionBaseUSCalcDownlinkFrequency( uint8_t channel, uint32_t frequency,
                                            uint32_t stepwidth )
{
    // Calculate the frequency
    return frequency + ( channel * stepwidth );
}
 8036958:	fb02 1000 	mla	r0, r2, r0, r1
 803695c:	4770      	bx	lr

0803695e <RegionCommonChanVerifyDr>:
    }
    return nbActiveBits;
}

bool RegionCommonChanVerifyDr( uint8_t nbChannels, uint16_t* channelsMask, int8_t dr, int8_t minDr, int8_t maxDr, ChannelParams_t* channels )
{
 803695e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    return false;
}

uint8_t RegionCommonValueInRange( int8_t value, int8_t min, int8_t max )
{
    if( ( value >= min ) && ( value <= max ) )
 8036962:	429a      	cmp	r2, r3
{
 8036964:	9f07      	ldr	r7, [sp, #28]
    if( ( value >= min ) && ( value <= max ) )
 8036966:	db03      	blt.n	8036970 <RegionCommonChanVerifyDr+0x12>
 8036968:	f99d 3018 	ldrsb.w	r3, [sp, #24]
 803696c:	429a      	cmp	r2, r3
 803696e:	dd24      	ble.n	80369ba <RegionCommonChanVerifyDr+0x5c>
        return false;
 8036970:	2000      	movs	r0, #0
}
 8036972:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            if( ( ( channelsMask[k] & ( 1 << j ) ) != 0 ) )
 8036976:	f831 8014 	ldrh.w	r8, [r1, r4, lsl #1]
 803697a:	fb1e 7303 	smlabb	r3, lr, r3, r7
 803697e:	2500      	movs	r5, #0
 8036980:	fa48 f605 	asr.w	r6, r8, r5
 8036984:	07f6      	lsls	r6, r6, #31
 8036986:	d50e      	bpl.n	80369a6 <RegionCommonChanVerifyDr+0x48>
                if( RegionCommonValueInRange( dr, ( channels[i + j].DrRange.Fields.Min & 0x0F ),
 8036988:	fb0e 3605 	mla	r6, lr, r5, r3
                                                  ( channels[i + j].DrRange.Fields.Max & 0x0F ) ) == 1 )
 803698c:	f896 c008 	ldrb.w	ip, [r6, #8]
 8036990:	f34c 1603 	sbfx	r6, ip, #4, #4
    if( ( value >= min ) && ( value <= max ) )
 8036994:	f00c 0c0f 	and.w	ip, ip, #15
 8036998:	4562      	cmp	r2, ip
                                                  ( channels[i + j].DrRange.Fields.Max & 0x0F ) ) == 1 )
 803699a:	b276      	sxtb	r6, r6
    if( ( value >= min ) && ( value <= max ) )
 803699c:	db03      	blt.n	80369a6 <RegionCommonChanVerifyDr+0x48>
 803699e:	f006 060f 	and.w	r6, r6, #15
 80369a2:	42b2      	cmp	r2, r6
 80369a4:	dd0d      	ble.n	80369c2 <RegionCommonChanVerifyDr+0x64>
        for( uint8_t j = 0; j < 16; j++ )
 80369a6:	3501      	adds	r5, #1
 80369a8:	2d10      	cmp	r5, #16
 80369aa:	d1e9      	bne.n	8036980 <RegionCommonChanVerifyDr+0x22>
    for( uint8_t i = 0, k = 0; i < nbChannels; i += 16, k++ )
 80369ac:	3401      	adds	r4, #1
 80369ae:	b2e4      	uxtb	r4, r4
 80369b0:	0123      	lsls	r3, r4, #4
 80369b2:	b2db      	uxtb	r3, r3
 80369b4:	4298      	cmp	r0, r3
 80369b6:	d8de      	bhi.n	8036976 <RegionCommonChanVerifyDr+0x18>
 80369b8:	e7da      	b.n	8036970 <RegionCommonChanVerifyDr+0x12>
 80369ba:	2400      	movs	r4, #0
 80369bc:	f04f 0e0c 	mov.w	lr, #12
 80369c0:	e7f6      	b.n	80369b0 <RegionCommonChanVerifyDr+0x52>
                    return true;
 80369c2:	2001      	movs	r0, #1
 80369c4:	e7d5      	b.n	8036972 <RegionCommonChanVerifyDr+0x14>

080369c6 <RegionCommonValueInRange>:
    if( ( value >= min ) && ( value <= max ) )
 80369c6:	4288      	cmp	r0, r1
 80369c8:	db04      	blt.n	80369d4 <RegionCommonValueInRange+0xe>
    {
        return 1;
 80369ca:	4290      	cmp	r0, r2
 80369cc:	bfcc      	ite	gt
 80369ce:	2000      	movgt	r0, #0
 80369d0:	2001      	movle	r0, #1
 80369d2:	4770      	bx	lr
    }
    return 0;
 80369d4:	2000      	movs	r0, #0
}
 80369d6:	4770      	bx	lr

080369d8 <RegionCommonChanDisable>:

bool RegionCommonChanDisable( uint16_t* channelsMask, uint8_t id, uint8_t maxChannels )
{
 80369d8:	b510      	push	{r4, lr}
    uint8_t index = id / 16;

    if( ( index > ( maxChannels / 16 ) ) || ( id >= maxChannels ) )
 80369da:	0914      	lsrs	r4, r2, #4
 80369dc:	ebb4 1f11 	cmp.w	r4, r1, lsr #4
{
 80369e0:	4603      	mov	r3, r0
    uint8_t index = id / 16;
 80369e2:	ea4f 1011 	mov.w	r0, r1, lsr #4
    if( ( index > ( maxChannels / 16 ) ) || ( id >= maxChannels ) )
 80369e6:	d30e      	bcc.n	8036a06 <RegionCommonChanDisable+0x2e>
 80369e8:	4291      	cmp	r1, r2
 80369ea:	d20c      	bcs.n	8036a06 <RegionCommonChanDisable+0x2e>
    {
        return false;
    }

    // Deactivate channel
    channelsMask[index] &= ~( 1 << ( id % 16 ) );
 80369ec:	b202      	sxth	r2, r0
 80369ee:	f001 010f 	and.w	r1, r1, #15
 80369f2:	f833 4012 	ldrh.w	r4, [r3, r2, lsl #1]
 80369f6:	2001      	movs	r0, #1
 80369f8:	fa00 f101 	lsl.w	r1, r0, r1
 80369fc:	ea24 0101 	bic.w	r1, r4, r1
 8036a00:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]

    return true;
}
 8036a04:	bd10      	pop	{r4, pc}
        return false;
 8036a06:	2000      	movs	r0, #0
 8036a08:	e7fc      	b.n	8036a04 <RegionCommonChanDisable+0x2c>

08036a0a <RegionCommonCountChannels>:

uint8_t RegionCommonCountChannels( uint16_t* channelsMask, uint8_t startIdx, uint8_t stopIdx )
{
 8036a0a:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint8_t nbChannels = 0;

    if( channelsMask == NULL )
 8036a0c:	b128      	cbz	r0, 8036a1a <RegionCommonCountChannels+0x10>
 8036a0e:	eb00 0541 	add.w	r5, r0, r1, lsl #1
        if( ( mask & ( 1 << j ) ) == ( 1 << j ) )
 8036a12:	2601      	movs	r6, #1
    uint8_t nbChannels = 0;
 8036a14:	2000      	movs	r0, #0
    {
        return 0;
    }

    for( uint8_t i = startIdx; i < stopIdx; i++ )
 8036a16:	4291      	cmp	r1, r2
 8036a18:	d300      	bcc.n	8036a1c <RegionCommonCountChannels+0x12>
    {
        nbChannels += CountChannels( channelsMask[i], 16 );
    }

    return nbChannels;
}
 8036a1a:	bdf0      	pop	{r4, r5, r6, r7, pc}
        nbChannels += CountChannels( channelsMask[i], 16 );
 8036a1c:	2400      	movs	r4, #0
 8036a1e:	f835 7b02 	ldrh.w	r7, [r5], #2
    uint8_t nbActiveBits = 0;
 8036a22:	4623      	mov	r3, r4
        if( ( mask & ( 1 << j ) ) == ( 1 << j ) )
 8036a24:	fa06 fc04 	lsl.w	ip, r6, r4
 8036a28:	ea3c 0c07 	bics.w	ip, ip, r7
            nbActiveBits++;
 8036a2c:	bf08      	it	eq
 8036a2e:	3301      	addeq	r3, #1
 8036a30:	f104 0401 	add.w	r4, r4, #1
 8036a34:	bf08      	it	eq
 8036a36:	b2db      	uxtbeq	r3, r3
    for( uint8_t j = 0; j < nbBits; j++ )
 8036a38:	2c10      	cmp	r4, #16
 8036a3a:	d1f3      	bne.n	8036a24 <RegionCommonCountChannels+0x1a>
        nbChannels += CountChannels( channelsMask[i], 16 );
 8036a3c:	4418      	add	r0, r3
    for( uint8_t i = startIdx; i < stopIdx; i++ )
 8036a3e:	3101      	adds	r1, #1
        nbChannels += CountChannels( channelsMask[i], 16 );
 8036a40:	b2c0      	uxtb	r0, r0
    for( uint8_t i = startIdx; i < stopIdx; i++ )
 8036a42:	b2c9      	uxtb	r1, r1
 8036a44:	e7e7      	b.n	8036a16 <RegionCommonCountChannels+0xc>

08036a46 <RegionCommonChanMaskCopy>:

void RegionCommonChanMaskCopy( uint16_t* channelsMaskDest, uint16_t* channelsMaskSrc, uint8_t len )
{
 8036a46:	b510      	push	{r4, lr}
    if( ( channelsMaskDest != NULL ) && ( channelsMaskSrc != NULL ) )
 8036a48:	b100      	cbz	r0, 8036a4c <RegionCommonChanMaskCopy+0x6>
 8036a4a:	b949      	cbnz	r1, 8036a60 <RegionCommonChanMaskCopy+0x1a>
        for( uint8_t i = 0; i < len; i++ )
        {
            channelsMaskDest[i] = channelsMaskSrc[i];
        }
    }
}
 8036a4c:	bd10      	pop	{r4, pc}
            channelsMaskDest[i] = channelsMaskSrc[i];
 8036a4e:	f831 4013 	ldrh.w	r4, [r1, r3, lsl #1]
 8036a52:	f820 4013 	strh.w	r4, [r0, r3, lsl #1]
        for( uint8_t i = 0; i < len; i++ )
 8036a56:	3301      	adds	r3, #1
 8036a58:	b2dc      	uxtb	r4, r3
 8036a5a:	42a2      	cmp	r2, r4
 8036a5c:	d8f7      	bhi.n	8036a4e <RegionCommonChanMaskCopy+0x8>
 8036a5e:	e7f5      	b.n	8036a4c <RegionCommonChanMaskCopy+0x6>
 8036a60:	2300      	movs	r3, #0
 8036a62:	e7f9      	b.n	8036a58 <RegionCommonChanMaskCopy+0x12>

08036a64 <RegionCommonSetBandTxDone>:

void RegionCommonSetBandTxDone( Band_t* band, TimerTime_t lastTxAirTime, bool joined, SysTime_t elapsedTimeSinceStartup )
{
 8036a64:	b082      	sub	sp, #8
 8036a66:	b530      	push	{r4, r5, lr}
    // Get the band duty cycle. If not joined, the function either returns the join duty cycle
    // or the band duty cycle, whichever is more restrictive.
    uint16_t dutyCycle = GetDutyCycle( band, joined, elapsedTimeSinceStartup );
 8036a68:	8804      	ldrh	r4, [r0, #0]
{
 8036a6a:	9304      	str	r3, [sp, #16]
    if( joined == false )
 8036a6c:	b972      	cbnz	r2, 8036a8c <RegionCommonSetBandTxDone+0x28>
        if( elapsedTimeSinceStartup.Seconds < BACKOFF_DUTY_CYCLE_1_HOUR_IN_S )
 8036a6e:	f5b3 6f61 	cmp.w	r3, #3600	; 0xe10
 8036a72:	d319      	bcc.n	8036aa8 <RegionCommonSetBandTxDone+0x44>
            joinDutyCycle = BACKOFF_DC_24_HOURS;
 8036a74:	f649 25af 	movw	r5, #39599	; 0x9aaf
 8036a78:	f242 7210 	movw	r2, #10000	; 0x2710
 8036a7c:	42ab      	cmp	r3, r5
 8036a7e:	bf8c      	ite	hi
 8036a80:	4613      	movhi	r3, r2
 8036a82:	f44f 737a 	movls.w	r3, #1000	; 0x3e8
        dutyCycle = MAX( dutyCycle, joinDutyCycle );
 8036a86:	429c      	cmp	r4, r3
 8036a88:	bf38      	it	cc
 8036a8a:	461c      	movcc	r4, r3

    // Reduce with transmission time
    if( band->TimeCredits > ( lastTxAirTime * dutyCycle ) )
 8036a8c:	2c01      	cmp	r4, #1
 8036a8e:	bf38      	it	cc
 8036a90:	2401      	movcc	r4, #1
 8036a92:	4361      	muls	r1, r4
    }
    else
    {
        band->TimeCredits = 0;
    }
}
 8036a94:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    if( band->TimeCredits > ( lastTxAirTime * dutyCycle ) )
 8036a98:	68c3      	ldr	r3, [r0, #12]
 8036a9a:	428b      	cmp	r3, r1
        band->TimeCredits -= ( lastTxAirTime * dutyCycle );
 8036a9c:	bf8c      	ite	hi
 8036a9e:	1a59      	subhi	r1, r3, r1
        band->TimeCredits = 0;
 8036aa0:	2100      	movls	r1, #0
 8036aa2:	60c1      	str	r1, [r0, #12]
}
 8036aa4:	b002      	add	sp, #8
 8036aa6:	4770      	bx	lr
            joinDutyCycle = BACKOFF_DC_1_HOUR;
 8036aa8:	2364      	movs	r3, #100	; 0x64
 8036aaa:	e7ec      	b.n	8036a86 <RegionCommonSetBandTxDone+0x22>

08036aac <RegionCommonUpdateBandTimeOff>:

TimerTime_t RegionCommonUpdateBandTimeOff( bool joined, Band_t* bands,
                                           uint8_t nbBands, bool dutyCycleEnabled,
                                           bool lastTxIsJoinRequest, SysTime_t elapsedTimeSinceStartup,
                                           TimerTime_t expectedTimeOnAir )
{
 8036aac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8036ab0:	b091      	sub	sp, #68	; 0x44
 8036ab2:	4615      	mov	r5, r2
 8036ab4:	f8dd 806c 	ldr.w	r8, [sp, #108]	; 0x6c
 8036ab8:	9305      	str	r3, [sp, #20]
 8036aba:	f89d 3068 	ldrb.w	r3, [sp, #104]	; 0x68
 8036abe:	9309      	str	r3, [sp, #36]	; 0x24
 8036ac0:	460c      	mov	r4, r1
 8036ac2:	4606      	mov	r6, r0
    TimerTime_t minTimeToWait = TIMERTIME_T_MAX;
    TimerTime_t currentTime = TimerGetCurrentTime( );
 8036ac4:	f004 fbcc 	bl	803b260 <UTIL_TIMER_GetCurrentTime>
                timeDiff.Seconds = ( elapsedTimeSinceStartup.Seconds - BACKOFF_DUTY_CYCLE_24_HOURS_IN_S ) / BACKOFF_24_HOURS_IN_S;
 8036ac8:	4b68      	ldr	r3, [pc, #416]	; (8036c6c <RegionCommonUpdateBandTimeOff+0x1c0>)
 8036aca:	f8df b1b8 	ldr.w	fp, [pc, #440]	; 8036c84 <RegionCommonUpdateBandTimeOff+0x1d8>
    TimerTime_t currentTime = TimerGetCurrentTime( );
 8036ace:	9006      	str	r0, [sp, #24]
                timeDiff.Seconds = ( elapsedTimeSinceStartup.Seconds - BACKOFF_DUTY_CYCLE_24_HOURS_IN_S ) / BACKOFF_24_HOURS_IN_S;
 8036ad0:	f5a8 32f6 	sub.w	r2, r8, #125952	; 0x1ec00
 8036ad4:	3a30      	subs	r2, #48	; 0x30
 8036ad6:	fbb2 f2f3 	udiv	r2, r2, r3
                timeDiff.Seconds *= BACKOFF_24_HOURS_IN_S;
 8036ada:	4353      	muls	r3, r2
                timeDiff.Seconds += BACKOFF_DUTY_CYCLE_24_HOURS_IN_S;
 8036adc:	f503 32f6 	add.w	r2, r3, #125952	; 0x1ec00
 8036ae0:	3230      	adds	r2, #48	; 0x30
                    backoffTimeRange.Seconds = BACKOFF_DUTY_CYCLE_24_HOURS_IN_S;
                }
                // Calculate the time to wait.
                if( elapsedTimeSinceStartup.Seconds > BACKOFF_DUTY_CYCLE_24_HOURS_IN_S )
                {
                    backoffTimeRange.Seconds += BACKOFF_24_HOURS_IN_S * ( ( ( elapsedTimeSinceStartup.Seconds - BACKOFF_DUTY_CYCLE_24_HOURS_IN_S ) / BACKOFF_24_HOURS_IN_S ) + 1 );
 8036ae2:	f503 33a8 	add.w	r3, r3, #86016	; 0x15000
 8036ae6:	f503 73c0 	add.w	r3, r3, #384	; 0x180
                timeDiff.Seconds += BACKOFF_DUTY_CYCLE_24_HOURS_IN_S;
 8036aea:	9204      	str	r2, [sp, #16]
 8036aec:	2218      	movs	r2, #24
                    backoffTimeRange.Seconds += BACKOFF_24_HOURS_IN_S * ( ( ( elapsedTimeSinceStartup.Seconds - BACKOFF_DUTY_CYCLE_24_HOURS_IN_S ) / BACKOFF_24_HOURS_IN_S ) + 1 );
 8036aee:	9303      	str	r3, [sp, #12]
 8036af0:	fb12 4305 	smlabb	r3, r2, r5, r4
 8036af4:	9307      	str	r3, [sp, #28]
    uint8_t validBands = 0;
 8036af6:	2500      	movs	r5, #0
    TimerTime_t minTimeToWait = TIMERTIME_T_MAX;
 8036af8:	f04f 3aff 	mov.w	sl, #4294967295
    for( uint8_t i = 0; i < nbBands; i++ )
 8036afc:	9b07      	ldr	r3, [sp, #28]
 8036afe:	42a3      	cmp	r3, r4
 8036b00:	d107      	bne.n	8036b12 <RegionCommonUpdateBandTimeOff+0x66>

    if( validBands == 0 )
    {
        // There is no valid band available to handle a transmission
        // in the given DUTY_CYCLE_TIME_PERIOD.
        return TIMERTIME_T_MAX;
 8036b02:	2d00      	cmp	r5, #0
    }
    return minTimeToWait;
}
 8036b04:	bf14      	ite	ne
 8036b06:	4650      	movne	r0, sl
 8036b08:	f04f 30ff 	moveq.w	r0, #4294967295
 8036b0c:	b011      	add	sp, #68	; 0x44
 8036b0e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        dutyCycle = UpdateTimeCredits( &bands[i], joined, dutyCycleEnabled,
 8036b12:	f9bd 3070 	ldrsh.w	r3, [sp, #112]	; 0x70
 8036b16:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
    TimerTime_t elapsedTime = SysTimeToMs( elapsedTimeSinceStartup );
 8036b1a:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8036b1c:	f8cd 806c 	str.w	r8, [sp, #108]	; 0x6c
 8036b20:	4640      	mov	r0, r8
 8036b22:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
 8036b26:	f004 fb2d 	bl	803b184 <SysTimeToMs>
    dutyCycle = GetDutyCycle( band, joined, elapsedTimeSinceStartup );
 8036b2a:	f8b4 9000 	ldrh.w	r9, [r4]
    if( joined == false )
 8036b2e:	b96e      	cbnz	r6, 8036b4c <RegionCommonUpdateBandTimeOff+0xa0>
        if( elapsedTimeSinceStartup.Seconds < BACKOFF_DUTY_CYCLE_1_HOUR_IN_S )
 8036b30:	f5b8 6f61 	cmp.w	r8, #3600	; 0xe10
 8036b34:	d35b      	bcc.n	8036bee <RegionCommonUpdateBandTimeOff+0x142>
            joinDutyCycle = BACKOFF_DC_24_HOURS;
 8036b36:	f649 22af 	movw	r2, #39599	; 0x9aaf
 8036b3a:	f242 7310 	movw	r3, #10000	; 0x2710
 8036b3e:	4590      	cmp	r8, r2
 8036b40:	bf98      	it	ls
 8036b42:	f44f 737a 	movls.w	r3, #1000	; 0x3e8
        dutyCycle = MAX( dutyCycle, joinDutyCycle );
 8036b46:	4599      	cmp	r9, r3
 8036b48:	bf38      	it	cc
 8036b4a:	4699      	movcc	r9, r3
    if( dutyCycle == 0 )
 8036b4c:	464b      	mov	r3, r9
 8036b4e:	2b01      	cmp	r3, #1
 8036b50:	bf38      	it	cc
 8036b52:	2301      	movcc	r3, #1
 8036b54:	9308      	str	r3, [sp, #32]
    if( joined == false )
 8036b56:	2e00      	cmp	r6, #0
 8036b58:	d152      	bne.n	8036c00 <RegionCommonUpdateBandTimeOff+0x154>
        if( dutyCycle == BACKOFF_DC_1_HOUR )
 8036b5a:	f1b9 0f64 	cmp.w	r9, #100	; 0x64
 8036b5e:	d148      	bne.n	8036bf2 <RegionCommonUpdateBandTimeOff+0x146>
            band->LastMaxCreditAssignTime = elapsedTime;
 8036b60:	60a0      	str	r0, [r4, #8]
            maxCredits = DUTY_CYCLE_TIME_PERIOD;
 8036b62:	465f      	mov	r7, fp
        timeDiff = SysTimeSub( elapsedTimeSinceStartup, SysTimeFromMs( band->LastMaxCreditAssignTime ) );
 8036b64:	68a1      	ldr	r1, [r4, #8]
 8036b66:	a80e      	add	r0, sp, #56	; 0x38
 8036b68:	f004 fb2c 	bl	803b1c4 <SysTimeFromMs>
 8036b6c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8036b6e:	9300      	str	r3, [sp, #0]
 8036b70:	e9dd 120a 	ldrd	r1, r2, [sp, #40]	; 0x28
 8036b74:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8036b76:	a80c      	add	r0, sp, #48	; 0x30
 8036b78:	f004 fa84 	bl	803b084 <SysTimeSub>
        if( ( ( dutyCycleEnabled == false ) && ( lastTxIsJoinRequest == false ) ) ||
 8036b7c:	9b05      	ldr	r3, [sp, #20]
 8036b7e:	b90b      	cbnz	r3, 8036b84 <RegionCommonUpdateBandTimeOff+0xd8>
 8036b80:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8036b82:	b133      	cbz	r3, 8036b92 <RegionCommonUpdateBandTimeOff+0xe6>
 8036b84:	6923      	ldr	r3, [r4, #16]
 8036b86:	42bb      	cmp	r3, r7
 8036b88:	d103      	bne.n	8036b92 <RegionCommonUpdateBandTimeOff+0xe6>
            ( band->MaxTimeCredits != maxCredits ) ||
 8036b8a:	4b39      	ldr	r3, [pc, #228]	; (8036c70 <RegionCommonUpdateBandTimeOff+0x1c4>)
 8036b8c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8036b8e:	429a      	cmp	r2, r3
 8036b90:	d90d      	bls.n	8036bae <RegionCommonUpdateBandTimeOff+0x102>
            if( elapsedTimeSinceStartup.Seconds >= BACKOFF_DUTY_CYCLE_24_HOURS_IN_S )
 8036b92:	4b38      	ldr	r3, [pc, #224]	; (8036c74 <RegionCommonUpdateBandTimeOff+0x1c8>)
            band->TimeCredits = maxCredits;
 8036b94:	60e7      	str	r7, [r4, #12]
            if( elapsedTimeSinceStartup.Seconds >= BACKOFF_DUTY_CYCLE_24_HOURS_IN_S )
 8036b96:	4598      	cmp	r8, r3
 8036b98:	d909      	bls.n	8036bae <RegionCommonUpdateBandTimeOff+0x102>
                timeDiff.SubSeconds = 0;
 8036b9a:	2300      	movs	r3, #0
 8036b9c:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
                band->LastMaxCreditAssignTime = SysTimeToMs( timeDiff );
 8036ba0:	9b04      	ldr	r3, [sp, #16]
 8036ba2:	990d      	ldr	r1, [sp, #52]	; 0x34
 8036ba4:	930c      	str	r3, [sp, #48]	; 0x30
 8036ba6:	4618      	mov	r0, r3
 8036ba8:	f004 faec 	bl	803b184 <SysTimeToMs>
 8036bac:	60a0      	str	r0, [r4, #8]
    if( band->LastBandUpdateTime == 0 )
 8036bae:	6860      	ldr	r0, [r4, #4]
 8036bb0:	b900      	cbnz	r0, 8036bb4 <RegionCommonUpdateBandTimeOff+0x108>
        band->TimeCredits = maxCredits;
 8036bb2:	60e7      	str	r7, [r4, #12]
    band->MaxTimeCredits = maxCredits;
 8036bb4:	6127      	str	r7, [r4, #16]
    if( joined == true )
 8036bb6:	b126      	cbz	r6, 8036bc2 <RegionCommonUpdateBandTimeOff+0x116>
        band->TimeCredits += TimerGetElapsedTime( band->LastBandUpdateTime );
 8036bb8:	f004 fb5c 	bl	803b274 <UTIL_TIMER_GetElapsedTime>
 8036bbc:	68e3      	ldr	r3, [r4, #12]
 8036bbe:	4403      	add	r3, r0
 8036bc0:	60e3      	str	r3, [r4, #12]
    if( band->TimeCredits > band->MaxTimeCredits )
 8036bc2:	e9d4 3203 	ldrd	r3, r2, [r4, #12]
 8036bc6:	4293      	cmp	r3, r2
    band->LastBandUpdateTime = currentTime;
 8036bc8:	9b06      	ldr	r3, [sp, #24]
        creditCosts = expectedTimeOnAir * dutyCycle;
 8036bca:	991d      	ldr	r1, [sp, #116]	; 0x74
    band->LastBandUpdateTime = currentTime;
 8036bcc:	6063      	str	r3, [r4, #4]
        creditCosts = expectedTimeOnAir * dutyCycle;
 8036bce:	9b08      	ldr	r3, [sp, #32]
        band->TimeCredits = band->MaxTimeCredits;
 8036bd0:	bf88      	it	hi
 8036bd2:	60e2      	strhi	r2, [r4, #12]
        creditCosts = expectedTimeOnAir * dutyCycle;
 8036bd4:	434b      	muls	r3, r1
        if( ( bands[i].TimeCredits > creditCosts ) ||
 8036bd6:	68e1      	ldr	r1, [r4, #12]
 8036bd8:	4299      	cmp	r1, r3
 8036bda:	d802      	bhi.n	8036be2 <RegionCommonUpdateBandTimeOff+0x136>
 8036bdc:	9805      	ldr	r0, [sp, #20]
 8036bde:	b9a8      	cbnz	r0, 8036c0c <RegionCommonUpdateBandTimeOff+0x160>
            ( ( dutyCycleEnabled == false ) && ( joined == true ) ) )
 8036be0:	b1a6      	cbz	r6, 8036c0c <RegionCommonUpdateBandTimeOff+0x160>
            bands[i].ReadyForTransmission = true;
 8036be2:	2301      	movs	r3, #1
            validBands++;
 8036be4:	441d      	add	r5, r3
            bands[i].ReadyForTransmission = true;
 8036be6:	7523      	strb	r3, [r4, #20]
            validBands++;
 8036be8:	b2ed      	uxtb	r5, r5
    for( uint8_t i = 0; i < nbBands; i++ )
 8036bea:	3418      	adds	r4, #24
 8036bec:	e786      	b.n	8036afc <RegionCommonUpdateBandTimeOff+0x50>
            joinDutyCycle = BACKOFF_DC_1_HOUR;
 8036bee:	2364      	movs	r3, #100	; 0x64
 8036bf0:	e7a9      	b.n	8036b46 <RegionCommonUpdateBandTimeOff+0x9a>
        else if( dutyCycle == BACKOFF_DC_10_HOURS )
 8036bf2:	f5b9 7f7a 	cmp.w	r9, #1000	; 0x3e8
            maxCredits = DUTY_CYCLE_TIME_PERIOD * 10;
 8036bf6:	bf0a      	itet	eq
 8036bf8:	4f1f      	ldreq	r7, [pc, #124]	; (8036c78 <RegionCommonUpdateBandTimeOff+0x1cc>)
            maxCredits = DUTY_CYCLE_TIME_PERIOD * 24;
 8036bfa:	4f20      	ldrne	r7, [pc, #128]	; (8036c7c <RegionCommonUpdateBandTimeOff+0x1d0>)
            band->LastMaxCreditAssignTime = elapsedTime;
 8036bfc:	60a0      	streq	r0, [r4, #8]
 8036bfe:	e7b1      	b.n	8036b64 <RegionCommonUpdateBandTimeOff+0xb8>
        if( dutyCycleEnabled == false )
 8036c00:	9b05      	ldr	r3, [sp, #20]
 8036c02:	b90b      	cbnz	r3, 8036c08 <RegionCommonUpdateBandTimeOff+0x15c>
            band->TimeCredits = maxCredits;
 8036c04:	f8c4 b00c 	str.w	fp, [r4, #12]
    TimerTime_t maxCredits = DUTY_CYCLE_TIME_PERIOD;
 8036c08:	465f      	mov	r7, fp
 8036c0a:	e7d0      	b.n	8036bae <RegionCommonUpdateBandTimeOff+0x102>
            bands[i].ReadyForTransmission = false;
 8036c0c:	2000      	movs	r0, #0
            if( bands[i].MaxTimeCredits > creditCosts )
 8036c0e:	4293      	cmp	r3, r2
            bands[i].ReadyForTransmission = false;
 8036c10:	7520      	strb	r0, [r4, #20]
            if( bands[i].MaxTimeCredits > creditCosts )
 8036c12:	d206      	bcs.n	8036c22 <RegionCommonUpdateBandTimeOff+0x176>
                minTimeToWait = MIN( minTimeToWait, ( creditCosts - bands[i].TimeCredits ) );
 8036c14:	1a5b      	subs	r3, r3, r1
 8036c16:	459a      	cmp	sl, r3
                validBands++;
 8036c18:	f105 0501 	add.w	r5, r5, #1
                minTimeToWait = MIN( minTimeToWait, ( creditCosts - bands[i].TimeCredits ) );
 8036c1c:	bf28      	it	cs
 8036c1e:	469a      	movcs	sl, r3
                validBands++;
 8036c20:	b2ed      	uxtb	r5, r5
            if( joined == false )
 8036c22:	2e00      	cmp	r6, #0
 8036c24:	d1e1      	bne.n	8036bea <RegionCommonUpdateBandTimeOff+0x13e>
                if( dutyCycle == BACKOFF_DC_1_HOUR )
 8036c26:	f1b9 0f64 	cmp.w	r9, #100	; 0x64
 8036c2a:	4a15      	ldr	r2, [pc, #84]	; (8036c80 <RegionCommonUpdateBandTimeOff+0x1d4>)
                SysTime_t backoffTimeRange = {
 8036c2c:	f8ad 6034 	strh.w	r6, [sp, #52]	; 0x34
                if( dutyCycle == BACKOFF_DC_1_HOUR )
 8036c30:	d019      	beq.n	8036c66 <RegionCommonUpdateBandTimeOff+0x1ba>
                    backoffTimeRange.Seconds = BACKOFF_DUTY_CYCLE_24_HOURS_IN_S;
 8036c32:	f649 23b0 	movw	r3, #39600	; 0x9ab0
 8036c36:	f5b9 7f7a 	cmp.w	r9, #1000	; 0x3e8
 8036c3a:	bf18      	it	ne
 8036c3c:	4613      	movne	r3, r2
                if( elapsedTimeSinceStartup.Seconds > BACKOFF_DUTY_CYCLE_24_HOURS_IN_S )
 8036c3e:	4590      	cmp	r8, r2
                    backoffTimeRange.Seconds += BACKOFF_24_HOURS_IN_S * ( ( ( elapsedTimeSinceStartup.Seconds - BACKOFF_DUTY_CYCLE_24_HOURS_IN_S ) / BACKOFF_24_HOURS_IN_S ) + 1 );
 8036c40:	bf84      	itt	hi
 8036c42:	9a03      	ldrhi	r2, [sp, #12]
 8036c44:	189b      	addhi	r3, r3, r2
                backoffTimeRange  = SysTimeSub( backoffTimeRange, elapsedTimeSinceStartup );
 8036c46:	930c      	str	r3, [sp, #48]	; 0x30
 8036c48:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8036c4a:	9300      	str	r3, [sp, #0]
 8036c4c:	af0c      	add	r7, sp, #48	; 0x30
 8036c4e:	e897 0006 	ldmia.w	r7, {r1, r2}
 8036c52:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8036c54:	4638      	mov	r0, r7
 8036c56:	f004 fa15 	bl	803b084 <SysTimeSub>
                minTimeToWait = SysTimeToMs( backoffTimeRange );
 8036c5a:	e897 0003 	ldmia.w	r7, {r0, r1}
 8036c5e:	f004 fa91 	bl	803b184 <SysTimeToMs>
 8036c62:	4682      	mov	sl, r0
 8036c64:	e7c1      	b.n	8036bea <RegionCommonUpdateBandTimeOff+0x13e>
                    backoffTimeRange.Seconds = BACKOFF_DUTY_CYCLE_1_HOUR_IN_S;
 8036c66:	f44f 6361 	mov.w	r3, #3600	; 0xe10
 8036c6a:	e7e8      	b.n	8036c3e <RegionCommonUpdateBandTimeOff+0x192>
 8036c6c:	00015180 	.word	0x00015180
 8036c70:	0001517f 	.word	0x0001517f
 8036c74:	0001ec2f 	.word	0x0001ec2f
 8036c78:	0112a880 	.word	0x0112a880
 8036c7c:	02932e00 	.word	0x02932e00
 8036c80:	0001ec30 	.word	0x0001ec30
 8036c84:	001b7740 	.word	0x001b7740

08036c88 <RegionCommonParseLinkAdrReq>:

uint8_t RegionCommonParseLinkAdrReq( uint8_t* payload, RegionCommonLinkAdrParams_t* linkAdrParams )
{
    uint8_t retIndex = 0;

    if( payload[0] == SRV_MAC_LINK_ADR_REQ )
 8036c88:	7803      	ldrb	r3, [r0, #0]
 8036c8a:	2b03      	cmp	r3, #3
 8036c8c:	d114      	bne.n	8036cb8 <RegionCommonParseLinkAdrReq+0x30>
    {
        // Parse datarate and tx power
        linkAdrParams->Datarate = payload[1];
 8036c8e:	7843      	ldrb	r3, [r0, #1]
        linkAdrParams->TxPower = linkAdrParams->Datarate & 0x0F;
 8036c90:	f003 020f 	and.w	r2, r3, #15
        linkAdrParams->Datarate = ( linkAdrParams->Datarate >> 4 ) & 0x0F;
 8036c94:	091b      	lsrs	r3, r3, #4
        linkAdrParams->TxPower = linkAdrParams->Datarate & 0x0F;
 8036c96:	708a      	strb	r2, [r1, #2]
        linkAdrParams->Datarate = ( linkAdrParams->Datarate >> 4 ) & 0x0F;
 8036c98:	704b      	strb	r3, [r1, #1]
        // Parse ChMask
        linkAdrParams->ChMask = ( uint16_t )payload[2];
 8036c9a:	7883      	ldrb	r3, [r0, #2]
 8036c9c:	808b      	strh	r3, [r1, #4]
        linkAdrParams->ChMask |= ( uint16_t )payload[3] << 8;
 8036c9e:	78c2      	ldrb	r2, [r0, #3]
 8036ca0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8036ca4:	808b      	strh	r3, [r1, #4]
        // Parse ChMaskCtrl and nbRep
        linkAdrParams->NbRep = payload[4];
 8036ca6:	7903      	ldrb	r3, [r0, #4]
        linkAdrParams->ChMaskCtrl = ( linkAdrParams->NbRep >> 4 ) & 0x07;
 8036ca8:	f3c3 1202 	ubfx	r2, r3, #4, #3
        linkAdrParams->NbRep &= 0x0F;
 8036cac:	f003 030f 	and.w	r3, r3, #15
        linkAdrParams->ChMaskCtrl = ( linkAdrParams->NbRep >> 4 ) & 0x07;
 8036cb0:	70ca      	strb	r2, [r1, #3]
        linkAdrParams->NbRep &= 0x0F;
 8036cb2:	700b      	strb	r3, [r1, #0]

        // LinkAdrReq has 4 bytes length + 1 byte CMD
        retIndex = 5;
 8036cb4:	2005      	movs	r0, #5
 8036cb6:	4770      	bx	lr
    uint8_t retIndex = 0;
 8036cb8:	2000      	movs	r0, #0
    }
    return retIndex;
}
 8036cba:	4770      	bx	lr

08036cbc <RegionCommonLinkAdrReqVerifyParams>:

uint8_t RegionCommonLinkAdrReqVerifyParams( RegionCommonLinkAdrReqVerifyParams_t* verifyParams, int8_t* dr, int8_t* txPow, uint8_t* nbRep )
{
 8036cbc:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 8036cc0:	4698      	mov	r8, r3
    int8_t datarate = verifyParams->Datarate;
    int8_t txPower = verifyParams->TxPower;
    int8_t nbRepetitions = verifyParams->NbRep;

    // Handle the case when ADR is off.
    if( verifyParams->AdrEnabled == false )
 8036cc2:	7943      	ldrb	r3, [r0, #5]
    uint8_t status = verifyParams->Status;
 8036cc4:	7905      	ldrb	r5, [r0, #4]
    int8_t txPower = verifyParams->TxPower;
 8036cc6:	f990 7007 	ldrsb.w	r7, [r0, #7]
    int8_t nbRepetitions = verifyParams->NbRep;
 8036cca:	7a06      	ldrb	r6, [r0, #8]
{
 8036ccc:	4691      	mov	r9, r2
 8036cce:	4604      	mov	r4, r0
    int8_t datarate = verifyParams->Datarate;
 8036cd0:	f990 2006 	ldrsb.w	r2, [r0, #6]
{
 8036cd4:	468a      	mov	sl, r1
    if( verifyParams->AdrEnabled == false )
 8036cd6:	b31b      	cbz	r3, 8036d20 <RegionCommonLinkAdrReqVerifyParams+0x64>
    int8_t nbRepetitions = verifyParams->NbRep;
 8036cd8:	b276      	sxtb	r6, r6
        nbRepetitions = verifyParams->CurrentNbRep;
        datarate =  verifyParams->CurrentDatarate;
        txPower =  verifyParams->CurrentTxPower;
    }

    if( status != 0 )
 8036cda:	b1bd      	cbz	r5, 8036d0c <RegionCommonLinkAdrReqVerifyParams+0x50>
    {
        // Verify datarate. The variable phyParam. Value contains the minimum allowed datarate.
        if( RegionCommonChanVerifyDr( verifyParams->NbChannels, verifyParams->ChannelsMask, datarate,
 8036cdc:	69a3      	ldr	r3, [r4, #24]
 8036cde:	9301      	str	r3, [sp, #4]
 8036ce0:	f994 3015 	ldrsb.w	r3, [r4, #21]
 8036ce4:	9300      	str	r3, [sp, #0]
 8036ce6:	6921      	ldr	r1, [r4, #16]
 8036ce8:	f994 3014 	ldrsb.w	r3, [r4, #20]
 8036cec:	7b20      	ldrb	r0, [r4, #12]
 8036cee:	f7ff fe36 	bl	803695e <RegionCommonChanVerifyDr>
 8036cf2:	b908      	cbnz	r0, 8036cf8 <RegionCommonLinkAdrReqVerifyParams+0x3c>
                                      verifyParams->MinDatarate, verifyParams->MaxDatarate, verifyParams->Channels  ) == false )
        {
            status &= 0xFD; // Datarate KO
 8036cf4:	f005 05fd 	and.w	r5, r5, #253	; 0xfd
        }

        // Verify tx power
        if( RegionCommonValueInRange( txPower, verifyParams->MaxTxPower, verifyParams->MinTxPower ) == 0 )
 8036cf8:	f994 301d 	ldrsb.w	r3, [r4, #29]
 8036cfc:	f994 101c 	ldrsb.w	r1, [r4, #28]
    if( ( value >= min ) && ( value <= max ) )
 8036d00:	42bb      	cmp	r3, r7
 8036d02:	dc14      	bgt.n	8036d2e <RegionCommonLinkAdrReqVerifyParams+0x72>
 8036d04:	42b9      	cmp	r1, r7
 8036d06:	da13      	bge.n	8036d30 <RegionCommonLinkAdrReqVerifyParams+0x74>
            { // Apply maximum TX power. Accept TX power.
                txPower = verifyParams->MaxTxPower;
            }
            else
            {
                status &= 0xFB; // TxPower KO
 8036d08:	f005 05fb 	and.w	r5, r5, #251	; 0xfb
    *dr = datarate;
    *txPow = txPower;
    *nbRep = nbRepetitions;

    return status;
}
 8036d0c:	4628      	mov	r0, r5
    *dr = datarate;
 8036d0e:	f88a 2000 	strb.w	r2, [sl]
    *txPow = txPower;
 8036d12:	f889 7000 	strb.w	r7, [r9]
    *nbRep = nbRepetitions;
 8036d16:	f888 6000 	strb.w	r6, [r8]
}
 8036d1a:	b002      	add	sp, #8
 8036d1c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        nbRepetitions = verifyParams->CurrentNbRep;
 8036d20:	f990 600b 	ldrsb.w	r6, [r0, #11]
        datarate =  verifyParams->CurrentDatarate;
 8036d24:	f990 2009 	ldrsb.w	r2, [r0, #9]
        txPower =  verifyParams->CurrentTxPower;
 8036d28:	f990 700a 	ldrsb.w	r7, [r0, #10]
 8036d2c:	e7d5      	b.n	8036cda <RegionCommonLinkAdrReqVerifyParams+0x1e>
 8036d2e:	461f      	mov	r7, r3
    if( status == 0x07 )
 8036d30:	2d07      	cmp	r5, #7
 8036d32:	d1eb      	bne.n	8036d0c <RegionCommonLinkAdrReqVerifyParams+0x50>
            nbRepetitions = 1;
 8036d34:	2e00      	cmp	r6, #0
 8036d36:	bf08      	it	eq
 8036d38:	2601      	moveq	r6, #1
 8036d3a:	e7e7      	b.n	8036d0c <RegionCommonLinkAdrReqVerifyParams+0x50>

08036d3c <RegionCommonComputeSymbolTimeLoRa>:

uint32_t RegionCommonComputeSymbolTimeLoRa( uint8_t phyDr, uint32_t bandwidthInHz )
{
    return ( 1 << phyDr ) * 1000000 / bandwidthInHz;
 8036d3c:	4b02      	ldr	r3, [pc, #8]	; (8036d48 <RegionCommonComputeSymbolTimeLoRa+0xc>)
 8036d3e:	fa03 f000 	lsl.w	r0, r3, r0
}
 8036d42:	fbb0 f0f1 	udiv	r0, r0, r1
 8036d46:	4770      	bx	lr
 8036d48:	000f4240 	.word	0x000f4240

08036d4c <RegionCommonComputeSymbolTimeFsk>:

uint32_t RegionCommonComputeSymbolTimeFsk( uint8_t phyDrInKbps )
{
    return 8000 / ( uint32_t )phyDrInKbps; // 1 symbol equals 1 byte
}
 8036d4c:	f44f 53fa 	mov.w	r3, #8000	; 0x1f40
 8036d50:	fbb3 f0f0 	udiv	r0, r3, r0
 8036d54:	4770      	bx	lr

08036d56 <RegionCommonComputeRxWindowParameters>:

void RegionCommonComputeRxWindowParameters( uint32_t tSymbolInUs, uint8_t minRxSymbols, uint32_t rxErrorInMs, uint32_t wakeUpTimeInMs, uint32_t* windowTimeoutInSymbols, int32_t* windowOffsetInMs )
{
 8036d56:	b530      	push	{r4, r5, lr}
    *windowTimeoutInSymbols = MAX( DIV_CEIL( ( ( 2 * minRxSymbols - 8 ) * tSymbolInUs + 2 * ( rxErrorInMs * 1000 ) ),  tSymbolInUs ), minRxSymbols ); // Computed number of symbols
 8036d58:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 8036d5c:	1f0c      	subs	r4, r1, #4
 8036d5e:	436a      	muls	r2, r5
 8036d60:	fb00 2204 	mla	r2, r0, r4, r2
 8036d64:	0052      	lsls	r2, r2, #1
 8036d66:	bf1e      	ittt	ne
 8036d68:	f100 34ff 	addne.w	r4, r0, #4294967295
 8036d6c:	1912      	addne	r2, r2, r4
 8036d6e:	fbb2 f2f0 	udivne	r2, r2, r0
 8036d72:	428a      	cmp	r2, r1
 8036d74:	bf38      	it	cc
 8036d76:	460a      	movcc	r2, r1
 8036d78:	9903      	ldr	r1, [sp, #12]
 8036d7a:	600a      	str	r2, [r1, #0]
    *windowOffsetInMs = ( int32_t )DIV_CEIL( ( int32_t )( 4 * tSymbolInUs ) -
 8036d7c:	0081      	lsls	r1, r0, #2
 8036d7e:	4350      	muls	r0, r2
 8036d80:	bf1c      	itt	ne
 8036d82:	3001      	addne	r0, #1
 8036d84:	0840      	lsrne	r0, r0, #1
 8036d86:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8036d8a:	1a08      	subs	r0, r1, r0
 8036d8c:	fb02 0313 	mls	r3, r2, r3, r0
 8036d90:	2b00      	cmp	r3, #0
 8036d92:	bfca      	itet	gt
 8036d94:	f203 33e7 	addwgt	r3, r3, #999	; 0x3e7
 8036d98:	fb93 f3f2 	sdivle	r3, r3, r2
 8036d9c:	fbb3 f3f2 	udivgt	r3, r3, r2
 8036da0:	9a04      	ldr	r2, [sp, #16]
 8036da2:	6013      	str	r3, [r2, #0]
                                               ( int32_t )DIV_CEIL( ( *windowTimeoutInSymbols * tSymbolInUs ), 2 ) -
                                               ( int32_t )( wakeUpTimeInMs * 1000 ), 1000 );
}
 8036da4:	bd30      	pop	{r4, r5, pc}

08036da6 <RegionCommonComputeTxPower>:

int8_t RegionCommonComputeTxPower( int8_t txPowerIndex, float maxEirp, float antennaGain )
{
 8036da6:	b538      	push	{r3, r4, r5, lr}
    int8_t phyTxPower = 0;

    phyTxPower = ( int8_t )floor( ( maxEirp - ( txPowerIndex * 2U ) ) - antennaGain );
 8036da8:	0040      	lsls	r0, r0, #1
{
 8036daa:	4614      	mov	r4, r2
 8036dac:	460d      	mov	r5, r1
    phyTxPower = ( int8_t )floor( ( maxEirp - ( txPowerIndex * 2U ) ) - antennaGain );
 8036dae:	f7f4 fe71 	bl	802ba94 <__aeabi_ui2f>
 8036db2:	4601      	mov	r1, r0
 8036db4:	4628      	mov	r0, r5
 8036db6:	f7f4 fdbb 	bl	802b930 <__aeabi_fsub>
 8036dba:	4621      	mov	r1, r4
 8036dbc:	f7f4 fdb8 	bl	802b930 <__aeabi_fsub>
 8036dc0:	f7f4 fcaa 	bl	802b718 <__aeabi_f2d>
 8036dc4:	f004 fcbc 	bl	803b740 <floor>
 8036dc8:	f7f4 fd86 	bl	802b8d8 <__aeabi_d2iz>

    return phyTxPower;
}
 8036dcc:	b240      	sxtb	r0, r0
 8036dce:	bd38      	pop	{r3, r4, r5, pc}

08036dd0 <RegionCommonCountNbOfEnabledChannels>:
    /* ST_WORKAROUND_END */
}

void RegionCommonCountNbOfEnabledChannels( RegionCommonCountNbOfEnabledChannelsParams_t* countNbOfEnabledChannelsParams,
                                           uint8_t* enabledChannels, uint8_t* nbEnabledChannels, uint8_t* nbRestrictedChannels )
{
 8036dd0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8036dd4:	e9cd 2300 	strd	r2, r3, [sp]
    uint8_t nbChannelCount = 0;
    uint8_t nbRestrictedChannelsCount = 0;

    for( uint8_t i = 0, k = 0; i < countNbOfEnabledChannelsParams->MaxNbChannels; i += 16, k++ )
 8036dd8:	2300      	movs	r3, #0
    uint8_t nbRestrictedChannelsCount = 0;
 8036dda:	461d      	mov	r5, r3
    uint8_t nbChannelCount = 0;
 8036ddc:	461e      	mov	r6, r3
    {
        for( uint8_t j = 0; j < 16; j++ )
        {
            if( ( countNbOfEnabledChannelsParams->ChannelsMask[k] & ( 1 << j ) ) != 0 )
            {
                if( countNbOfEnabledChannelsParams->Channels[i + j].Frequency == 0 )
 8036dde:	f04f 090c 	mov.w	r9, #12
 8036de2:	011a      	lsls	r2, r3, #4
    for( uint8_t i = 0, k = 0; i < countNbOfEnabledChannelsParams->MaxNbChannels; i += 16, k++ )
 8036de4:	8a04      	ldrh	r4, [r0, #16]
 8036de6:	fa5f f882 	uxtb.w	r8, r2
 8036dea:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 8036dee:	4294      	cmp	r4, r2
 8036df0:	d806      	bhi.n	8036e00 <RegionCommonCountNbOfEnabledChannels+0x30>
                }
                enabledChannels[nbChannelCount++] = i + j;
            }
        }
    }
    *nbEnabledChannels = nbChannelCount;
 8036df2:	9b00      	ldr	r3, [sp, #0]
 8036df4:	701e      	strb	r6, [r3, #0]
    *nbRestrictedChannels = nbRestrictedChannelsCount;
 8036df6:	9b01      	ldr	r3, [sp, #4]
 8036df8:	701d      	strb	r5, [r3, #0]
}
 8036dfa:	b003      	add	sp, #12
 8036dfc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            if( ( countNbOfEnabledChannelsParams->ChannelsMask[k] & ( 1 << j ) ) != 0 )
 8036e00:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8036e04:	2200      	movs	r2, #0
 8036e06:	6844      	ldr	r4, [r0, #4]
 8036e08:	f834 400c 	ldrh.w	r4, [r4, ip]
 8036e0c:	4114      	asrs	r4, r2
 8036e0e:	07e7      	lsls	r7, r4, #31
 8036e10:	d52a      	bpl.n	8036e68 <RegionCommonCountNbOfEnabledChannels+0x98>
                if( countNbOfEnabledChannelsParams->Channels[i + j].Frequency == 0 )
 8036e12:	eb02 0e08 	add.w	lr, r2, r8
 8036e16:	6887      	ldr	r7, [r0, #8]
 8036e18:	fb09 f40e 	mul.w	r4, r9, lr
 8036e1c:	eb07 0a04 	add.w	sl, r7, r4
 8036e20:	593c      	ldr	r4, [r7, r4]
 8036e22:	b30c      	cbz	r4, 8036e68 <RegionCommonCountNbOfEnabledChannels+0x98>
                if( ( countNbOfEnabledChannelsParams->Joined == false ) &&
 8036e24:	7804      	ldrb	r4, [r0, #0]
 8036e26:	b934      	cbnz	r4, 8036e36 <RegionCommonCountNbOfEnabledChannels+0x66>
                    ( countNbOfEnabledChannelsParams->JoinChannels != NULL ) )
 8036e28:	6944      	ldr	r4, [r0, #20]
                if( ( countNbOfEnabledChannelsParams->Joined == false ) &&
 8036e2a:	b124      	cbz	r4, 8036e36 <RegionCommonCountNbOfEnabledChannels+0x66>
                    if( ( countNbOfEnabledChannelsParams->JoinChannels[k] & ( 1 << j ) ) == 0 )
 8036e2c:	f834 400c 	ldrh.w	r4, [r4, ip]
 8036e30:	4114      	asrs	r4, r2
 8036e32:	07e4      	lsls	r4, r4, #31
 8036e34:	d518      	bpl.n	8036e68 <RegionCommonCountNbOfEnabledChannels+0x98>
                                              countNbOfEnabledChannelsParams->Channels[i + j].DrRange.Fields.Min,
 8036e36:	f89a 4008 	ldrb.w	r4, [sl, #8]
                if( RegionCommonValueInRange( countNbOfEnabledChannelsParams->Datarate,
 8036e3a:	f990 b001 	ldrsb.w	fp, [r0, #1]
                                              countNbOfEnabledChannelsParams->Channels[i + j].DrRange.Fields.Min,
 8036e3e:	f344 0703 	sbfx	r7, r4, #0, #4
    if( ( value >= min ) && ( value <= max ) )
 8036e42:	b27f      	sxtb	r7, r7
 8036e44:	455f      	cmp	r7, fp
 8036e46:	dc0f      	bgt.n	8036e68 <RegionCommonCountNbOfEnabledChannels+0x98>
                                              countNbOfEnabledChannelsParams->Channels[i + j].DrRange.Fields.Max ) == false )
 8036e48:	f344 1403 	sbfx	r4, r4, #4, #4
    if( ( value >= min ) && ( value <= max ) )
 8036e4c:	b264      	sxtb	r4, r4
 8036e4e:	455c      	cmp	r4, fp
 8036e50:	db0a      	blt.n	8036e68 <RegionCommonCountNbOfEnabledChannels+0x98>
                if( countNbOfEnabledChannelsParams->Bands[countNbOfEnabledChannelsParams->Channels[i + j].Band].ReadyForTransmission == false )
 8036e52:	f89a 4009 	ldrb.w	r4, [sl, #9]
 8036e56:	eb04 0744 	add.w	r7, r4, r4, lsl #1
 8036e5a:	68c4      	ldr	r4, [r0, #12]
 8036e5c:	eb04 04c7 	add.w	r4, r4, r7, lsl #3
 8036e60:	7d24      	ldrb	r4, [r4, #20]
 8036e62:	b93c      	cbnz	r4, 8036e74 <RegionCommonCountNbOfEnabledChannels+0xa4>
                    nbRestrictedChannelsCount++;
 8036e64:	3501      	adds	r5, #1
 8036e66:	b2ed      	uxtb	r5, r5
        for( uint8_t j = 0; j < 16; j++ )
 8036e68:	3201      	adds	r2, #1
 8036e6a:	2a10      	cmp	r2, #16
 8036e6c:	d1cb      	bne.n	8036e06 <RegionCommonCountNbOfEnabledChannels+0x36>
    for( uint8_t i = 0, k = 0; i < countNbOfEnabledChannelsParams->MaxNbChannels; i += 16, k++ )
 8036e6e:	3301      	adds	r3, #1
 8036e70:	b2db      	uxtb	r3, r3
 8036e72:	e7b6      	b.n	8036de2 <RegionCommonCountNbOfEnabledChannels+0x12>
                enabledChannels[nbChannelCount++] = i + j;
 8036e74:	1c74      	adds	r4, r6, #1
 8036e76:	f801 e006 	strb.w	lr, [r1, r6]
 8036e7a:	b2e6      	uxtb	r6, r4
 8036e7c:	e7f4      	b.n	8036e68 <RegionCommonCountNbOfEnabledChannels+0x98>

08036e7e <RegionCommonIdentifyChannels>:

LoRaMacStatus_t RegionCommonIdentifyChannels( RegionCommonIdentifyChannelsParam_t* identifyChannelsParam,
                                              TimerTime_t* aggregatedTimeOff, uint8_t* enabledChannels,
                                              uint8_t* nbEnabledChannels, uint8_t* nbRestrictedChannels,
                                              TimerTime_t* nextTxDelay )
{
 8036e7e:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 8036e82:	4604      	mov	r4, r0
    TimerTime_t elapsed = TimerGetElapsedTime( identifyChannelsParam->LastAggrTx );
 8036e84:	6840      	ldr	r0, [r0, #4]
{
 8036e86:	e9dd 780c 	ldrd	r7, r8, [sp, #48]	; 0x30
 8036e8a:	461e      	mov	r6, r3
 8036e8c:	468a      	mov	sl, r1
 8036e8e:	4691      	mov	r9, r2
    TimerTime_t elapsed = TimerGetElapsedTime( identifyChannelsParam->LastAggrTx );
 8036e90:	f004 f9f0 	bl	803b274 <UTIL_TIMER_GetElapsedTime>
    *nextTxDelay = identifyChannelsParam->AggrTimeOff - elapsed;
 8036e94:	6823      	ldr	r3, [r4, #0]
 8036e96:	1a1b      	subs	r3, r3, r0
 8036e98:	f8c8 3000 	str.w	r3, [r8]
    *nbRestrictedChannels = 1;
    *nbEnabledChannels = 0;
 8036e9c:	2500      	movs	r5, #0
    *nbRestrictedChannels = 1;
 8036e9e:	2301      	movs	r3, #1
 8036ea0:	703b      	strb	r3, [r7, #0]
    *nbEnabledChannels = 0;
 8036ea2:	7035      	strb	r5, [r6, #0]

    if( ( identifyChannelsParam->LastAggrTx == 0 ) ||
 8036ea4:	6863      	ldr	r3, [r4, #4]
 8036ea6:	b113      	cbz	r3, 8036eae <RegionCommonIdentifyChannels+0x30>
 8036ea8:	6823      	ldr	r3, [r4, #0]
 8036eaa:	4283      	cmp	r3, r0
 8036eac:	d825      	bhi.n	8036efa <RegionCommonIdentifyChannels+0x7c>
        ( identifyChannelsParam->AggrTimeOff <= elapsed ) )
    {
        // Reset Aggregated time off
        *aggregatedTimeOff = 0;
 8036eae:	f8ca 5000 	str.w	r5, [sl]

        // Update bands Time OFF
        *nextTxDelay = RegionCommonUpdateBandTimeOff( identifyChannelsParam->CountNbOfEnabledChannelsParam->Joined,
 8036eb2:	f8d4 c01c 	ldr.w	ip, [r4, #28]
 8036eb6:	69a3      	ldr	r3, [r4, #24]
 8036eb8:	f89c e000 	ldrb.w	lr, [ip]
 8036ebc:	9303      	str	r3, [sp, #12]
 8036ebe:	e9d4 0103 	ldrd	r0, r1, [r4, #12]
 8036ec2:	ab01      	add	r3, sp, #4
 8036ec4:	e883 0003 	stmia.w	r3, {r0, r1}
 8036ec8:	7d23      	ldrb	r3, [r4, #20]
 8036eca:	9300      	str	r3, [sp, #0]
 8036ecc:	f8dc 100c 	ldr.w	r1, [ip, #12]
 8036ed0:	7a23      	ldrb	r3, [r4, #8]
 8036ed2:	7a62      	ldrb	r2, [r4, #9]
 8036ed4:	4670      	mov	r0, lr
 8036ed6:	f7ff fde9 	bl	8036aac <RegionCommonUpdateBandTimeOff>
                                                      identifyChannelsParam->DutyCycleEnabled,
                                                      identifyChannelsParam->LastTxIsJoinRequest,
                                                      identifyChannelsParam->ElapsedTimeSinceStartUp,
                                                      identifyChannelsParam->ExpectedTimeOnAir );

        RegionCommonCountNbOfEnabledChannels( identifyChannelsParam->CountNbOfEnabledChannelsParam, enabledChannels,
 8036eda:	463b      	mov	r3, r7
        *nextTxDelay = RegionCommonUpdateBandTimeOff( identifyChannelsParam->CountNbOfEnabledChannelsParam->Joined,
 8036edc:	f8c8 0000 	str.w	r0, [r8]
        RegionCommonCountNbOfEnabledChannels( identifyChannelsParam->CountNbOfEnabledChannelsParam, enabledChannels,
 8036ee0:	4632      	mov	r2, r6
 8036ee2:	69e0      	ldr	r0, [r4, #28]
 8036ee4:	4649      	mov	r1, r9
 8036ee6:	f7ff ff73 	bl	8036dd0 <RegionCommonCountNbOfEnabledChannels>
                                              nbEnabledChannels, nbRestrictedChannels );
    }

    if( *nbEnabledChannels > 0 )
 8036eea:	7833      	ldrb	r3, [r6, #0]
 8036eec:	b12b      	cbz	r3, 8036efa <RegionCommonIdentifyChannels+0x7c>
    {
        *nextTxDelay = 0;
 8036eee:	f8c8 5000 	str.w	r5, [r8]
        return LORAMAC_STATUS_OK;
 8036ef2:	2000      	movs	r0, #0
    }
    else
    {
        return LORAMAC_STATUS_NO_CHANNEL_FOUND;
    }
}
 8036ef4:	b004      	add	sp, #16
 8036ef6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    else if( *nbRestrictedChannels > 0 )
 8036efa:	783b      	ldrb	r3, [r7, #0]
        return LORAMAC_STATUS_NO_CHANNEL_FOUND;
 8036efc:	2b00      	cmp	r3, #0
 8036efe:	bf14      	ite	ne
 8036f00:	200b      	movne	r0, #11
 8036f02:	200c      	moveq	r0, #12
 8036f04:	e7f6      	b.n	8036ef4 <RegionCommonIdentifyChannels+0x76>

08036f06 <RegionCommonGetNextLowerTxDr>:

int8_t RegionCommonGetNextLowerTxDr( RegionCommonGetNextLowerTxDrParams_t *params )
{
 8036f06:	b537      	push	{r0, r1, r2, r4, r5, lr}
    int8_t drLocal = params->CurrentDr;
 8036f08:	f990 2000 	ldrsb.w	r2, [r0]

    if( params->CurrentDr == params->MinDr )
 8036f0c:	f990 5002 	ldrsb.w	r5, [r0, #2]
 8036f10:	4295      	cmp	r5, r2
{
 8036f12:	4604      	mov	r4, r0
    if( params->CurrentDr == params->MinDr )
 8036f14:	d00f      	beq.n	8036f36 <RegionCommonGetNextLowerTxDr+0x30>
    }
    else
    {
        do
        {
            drLocal = ( drLocal - 1 );
 8036f16:	3a01      	subs	r2, #1
 8036f18:	b252      	sxtb	r2, r2
        } while( ( drLocal != params->MinDr ) &&
                 ( RegionCommonChanVerifyDr( params->NbChannels, params->ChannelsMask, drLocal, params->MinDr, params->MaxDr, params->Channels  ) == false ) );
 8036f1a:	42aa      	cmp	r2, r5
 8036f1c:	d00b      	beq.n	8036f36 <RegionCommonGetNextLowerTxDr+0x30>
 8036f1e:	68a3      	ldr	r3, [r4, #8]
 8036f20:	9301      	str	r3, [sp, #4]
 8036f22:	f994 3001 	ldrsb.w	r3, [r4, #1]
 8036f26:	9300      	str	r3, [sp, #0]
 8036f28:	6861      	ldr	r1, [r4, #4]
 8036f2a:	78e0      	ldrb	r0, [r4, #3]
 8036f2c:	462b      	mov	r3, r5
 8036f2e:	f7ff fd16 	bl	803695e <RegionCommonChanVerifyDr>
        } while( ( drLocal != params->MinDr ) &&
 8036f32:	2800      	cmp	r0, #0
 8036f34:	d0ef      	beq.n	8036f16 <RegionCommonGetNextLowerTxDr+0x10>

        return drLocal;
    }
}
 8036f36:	4610      	mov	r0, r2
 8036f38:	b003      	add	sp, #12
 8036f3a:	bd30      	pop	{r4, r5, pc}

08036f3c <RegionCommonLimitTxPower>:

int8_t RegionCommonLimitTxPower( int8_t txPower, int8_t maxBandTxPower )
{
    // Limit tx power to the band max
    return MAX( txPower, maxBandTxPower );
}
 8036f3c:	4288      	cmp	r0, r1
 8036f3e:	bfb8      	it	lt
 8036f40:	4608      	movlt	r0, r1
 8036f42:	4770      	bx	lr

08036f44 <RegionCommonGetBandwidth>:

uint32_t RegionCommonGetBandwidth( uint32_t drIndex, const uint32_t* bandwidths )
{
    switch( bandwidths[drIndex] )
 8036f44:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
 8036f48:	4b05      	ldr	r3, [pc, #20]	; (8036f60 <RegionCommonGetBandwidth+0x1c>)
 8036f4a:	4298      	cmp	r0, r3
 8036f4c:	d005      	beq.n	8036f5a <RegionCommonGetBandwidth+0x16>
        case 125000:
            return 0;
        case 250000:
            return 1;
        case 500000:
            return 2;
 8036f4e:	4b05      	ldr	r3, [pc, #20]	; (8036f64 <RegionCommonGetBandwidth+0x20>)
 8036f50:	4298      	cmp	r0, r3
 8036f52:	bf0c      	ite	eq
 8036f54:	2002      	moveq	r0, #2
 8036f56:	2000      	movne	r0, #0
 8036f58:	4770      	bx	lr
    switch( bandwidths[drIndex] )
 8036f5a:	2001      	movs	r0, #1
    }
}
 8036f5c:	4770      	bx	lr
 8036f5e:	bf00      	nop
 8036f60:	0003d090 	.word	0x0003d090
 8036f64:	0007a120 	.word	0x0007a120

08036f68 <RegionCommonRxConfigPrint>:

/* ST_WORKAROUND_BEGIN: Print Tx/Rx config */
void RegionCommonRxConfigPrint(LoRaMacRxSlot_t rxSlot, uint32_t frequency, int8_t dr)
{
 8036f68:	b5f0      	push	{r4, r5, r6, r7, lr}
    const char *slotStrings[] = { "1", "2", "C", "Multi_C", "P", "Multi_P" };
 8036f6a:	4d13      	ldr	r5, [pc, #76]	; (8036fb8 <RegionCommonRxConfigPrint+0x50>)
{
 8036f6c:	4606      	mov	r6, r0
 8036f6e:	460f      	mov	r7, r1
 8036f70:	4694      	mov	ip, r2
    const char *slotStrings[] = { "1", "2", "C", "Multi_C", "P", "Multi_P" };
 8036f72:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
{
 8036f74:	b08b      	sub	sp, #44	; 0x2c
    const char *slotStrings[] = { "1", "2", "C", "Multi_C", "P", "Multi_P" };
 8036f76:	ac04      	add	r4, sp, #16
 8036f78:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8036f7a:	e895 0003 	ldmia.w	r5, {r0, r1}

    if ( rxSlot < RX_SLOT_NONE )
 8036f7e:	2e05      	cmp	r6, #5
    const char *slotStrings[] = { "1", "2", "C", "Multi_C", "P", "Multi_P" };
 8036f80:	e884 0003 	stmia.w	r4, {r0, r1}
    if ( rxSlot < RX_SLOT_NONE )
 8036f84:	d80f      	bhi.n	8036fa6 <RegionCommonRxConfigPrint+0x3e>
    {
        MW_LOG(TS_ON, VLEVEL_M,  "RX_%s on freq %d Hz at DR %d\r\n", slotStrings[rxSlot], frequency, dr );
 8036f86:	ab0a      	add	r3, sp, #40	; 0x28
 8036f88:	e9cd 7c01 	strd	r7, ip, [sp, #4]
 8036f8c:	eb03 0686 	add.w	r6, r3, r6, lsl #2
 8036f90:	2201      	movs	r2, #1
 8036f92:	f856 3c18 	ldr.w	r3, [r6, #-24]
 8036f96:	9300      	str	r3, [sp, #0]
 8036f98:	2100      	movs	r1, #0
 8036f9a:	4b08      	ldr	r3, [pc, #32]	; (8036fbc <RegionCommonRxConfigPrint+0x54>)
 8036f9c:	2002      	movs	r0, #2
 8036f9e:	f003 fe81 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
    }
    else
    {
        MW_LOG(TS_ON, VLEVEL_M,  "RX on freq %d Hz at DR %d\r\n", frequency, dr );
    }
}
 8036fa2:	b00b      	add	sp, #44	; 0x2c
 8036fa4:	bdf0      	pop	{r4, r5, r6, r7, pc}
        MW_LOG(TS_ON, VLEVEL_M,  "RX on freq %d Hz at DR %d\r\n", frequency, dr );
 8036fa6:	e9cd 7c00 	strd	r7, ip, [sp]
 8036faa:	4b05      	ldr	r3, [pc, #20]	; (8036fc0 <RegionCommonRxConfigPrint+0x58>)
 8036fac:	2201      	movs	r2, #1
 8036fae:	2100      	movs	r1, #0
 8036fb0:	2002      	movs	r0, #2
 8036fb2:	f003 fe77 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
}
 8036fb6:	e7f4      	b.n	8036fa2 <RegionCommonRxConfigPrint+0x3a>
 8036fb8:	0803ba84 	.word	0x0803ba84
 8036fbc:	0803c307 	.word	0x0803c307
 8036fc0:	0803c326 	.word	0x0803c326

08036fc4 <RegionCommonTxConfigPrint>:

void RegionCommonTxConfigPrint(uint32_t frequency, int8_t dr)
{
 8036fc4:	b507      	push	{r0, r1, r2, lr}
    MW_LOG(TS_ON, VLEVEL_M,  "TX on freq %d Hz at DR %d\r\n", frequency, dr );
 8036fc6:	4b05      	ldr	r3, [pc, #20]	; (8036fdc <RegionCommonTxConfigPrint+0x18>)
 8036fc8:	e9cd 0100 	strd	r0, r1, [sp]
 8036fcc:	2201      	movs	r2, #1
 8036fce:	2100      	movs	r1, #0
 8036fd0:	2002      	movs	r0, #2
 8036fd2:	f003 fe67 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
}
 8036fd6:	b003      	add	sp, #12
 8036fd8:	f85d fb04 	ldr.w	pc, [sp], #4
 8036fdc:	0803c342 	.word	0x0803c342

08036fe0 <GetTimeOnAir>:
    }
    return true;
}

static TimerTime_t GetTimeOnAir( int8_t datarate, uint16_t pktLen )
{
 8036fe0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8036fe2:	460c      	mov	r4, r1
    int8_t phyDr = DataratesEU868[datarate];
 8036fe4:	4910      	ldr	r1, [pc, #64]	; (8037028 <GetTimeOnAir+0x48>)
{
 8036fe6:	b085      	sub	sp, #20
    int8_t phyDr = DataratesEU868[datarate];
 8036fe8:	560f      	ldrsb	r7, [r1, r0]
    uint32_t bandwidth = RegionCommonGetBandwidth( datarate, BandwidthsEU868 );
 8036fea:	3108      	adds	r1, #8
{
 8036fec:	4605      	mov	r5, r0
    uint32_t bandwidth = RegionCommonGetBandwidth( datarate, BandwidthsEU868 );
 8036fee:	f7ff ffa9 	bl	8036f44 <RegionCommonGetBandwidth>
 8036ff2:	4b0e      	ldr	r3, [pc, #56]	; (803702c <GetTimeOnAir+0x4c>)
 8036ff4:	b2e4      	uxtb	r4, r4
 8036ff6:	6a5e      	ldr	r6, [r3, #36]	; 0x24
    TimerTime_t timeOnAir = 0;

    if( datarate == DR_7 )
 8036ff8:	2d07      	cmp	r5, #7
 8036ffa:	f04f 0301 	mov.w	r3, #1
    { // High Speed FSK channel
        timeOnAir = Radio.TimeOnAir( MODEM_FSK, bandwidth, phyDr * 1000, 0, 5, false, pktLen, true );
 8036ffe:	e9cd 4302 	strd	r4, r3, [sp, #8]
    uint32_t bandwidth = RegionCommonGetBandwidth( datarate, BandwidthsEU868 );
 8037002:	4601      	mov	r1, r0
    if( datarate == DR_7 )
 8037004:	d10a      	bne.n	803701c <GetTimeOnAir+0x3c>
        timeOnAir = Radio.TimeOnAir( MODEM_FSK, bandwidth, phyDr * 1000, 0, 5, false, pktLen, true );
 8037006:	2205      	movs	r2, #5
 8037008:	2300      	movs	r3, #0
 803700a:	e9cd 2300 	strd	r2, r3, [sp]
 803700e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8037012:	437a      	muls	r2, r7
    }
    else
    {
        timeOnAir = Radio.TimeOnAir( MODEM_LORA, bandwidth, phyDr, 1, 8, false, pktLen, true );
 8037014:	4618      	mov	r0, r3
 8037016:	47b0      	blx	r6
    }
    return timeOnAir;
}
 8037018:	b005      	add	sp, #20
 803701a:	bdf0      	pop	{r4, r5, r6, r7, pc}
        timeOnAir = Radio.TimeOnAir( MODEM_LORA, bandwidth, phyDr, 1, 8, false, pktLen, true );
 803701c:	2208      	movs	r2, #8
 803701e:	2000      	movs	r0, #0
 8037020:	e9cd 2000 	strd	r2, r0, [sp]
 8037024:	463a      	mov	r2, r7
 8037026:	e7f5      	b.n	8037014 <GetTimeOnAir+0x34>
 8037028:	0803ba9c 	.word	0x0803ba9c
 803702c:	0803bbd8 	.word	0x0803bbd8

08037030 <VerifyRfFreq>:
{
 8037030:	b538      	push	{r3, r4, r5, lr}
    if( Radio.CheckRfFrequency( freq ) == false )
 8037032:	4b19      	ldr	r3, [pc, #100]	; (8037098 <VerifyRfFreq+0x68>)
 8037034:	6a1b      	ldr	r3, [r3, #32]
{
 8037036:	4605      	mov	r5, r0
 8037038:	460c      	mov	r4, r1
    if( Radio.CheckRfFrequency( freq ) == false )
 803703a:	4798      	blx	r3
 803703c:	b130      	cbz	r0, 803704c <VerifyRfFreq+0x1c>
    if( ( freq >= 863000000 ) && ( freq < 865000000 ) )
 803703e:	4b17      	ldr	r3, [pc, #92]	; (803709c <VerifyRfFreq+0x6c>)
 8037040:	4a17      	ldr	r2, [pc, #92]	; (80370a0 <VerifyRfFreq+0x70>)
 8037042:	442b      	add	r3, r5
 8037044:	4293      	cmp	r3, r2
 8037046:	d802      	bhi.n	803704e <VerifyRfFreq+0x1e>
        *band = 2;
 8037048:	2302      	movs	r3, #2
        *band = 3;
 803704a:	7023      	strb	r3, [r4, #0]
}
 803704c:	bd38      	pop	{r3, r4, r5, pc}
    else if( ( freq >= 865000000 ) && ( freq <= 868000000 ) )
 803704e:	4b15      	ldr	r3, [pc, #84]	; (80370a4 <VerifyRfFreq+0x74>)
 8037050:	4a15      	ldr	r2, [pc, #84]	; (80370a8 <VerifyRfFreq+0x78>)
 8037052:	442b      	add	r3, r5
 8037054:	4293      	cmp	r3, r2
 8037056:	d801      	bhi.n	803705c <VerifyRfFreq+0x2c>
        *band = 0;
 8037058:	2300      	movs	r3, #0
 803705a:	e7f6      	b.n	803704a <VerifyRfFreq+0x1a>
    else if( ( freq > 868000000 ) && ( freq <= 868600000 ) )
 803705c:	4b13      	ldr	r3, [pc, #76]	; (80370ac <VerifyRfFreq+0x7c>)
 803705e:	4a14      	ldr	r2, [pc, #80]	; (80370b0 <VerifyRfFreq+0x80>)
 8037060:	442b      	add	r3, r5
 8037062:	4293      	cmp	r3, r2
 8037064:	d801      	bhi.n	803706a <VerifyRfFreq+0x3a>
        *band = 1;
 8037066:	2301      	movs	r3, #1
 8037068:	e7ef      	b.n	803704a <VerifyRfFreq+0x1a>
    else if( ( freq >= 868700000 ) && ( freq <= 869200000 ) )
 803706a:	4b12      	ldr	r3, [pc, #72]	; (80370b4 <VerifyRfFreq+0x84>)
 803706c:	4a12      	ldr	r2, [pc, #72]	; (80370b8 <VerifyRfFreq+0x88>)
 803706e:	442b      	add	r3, r5
 8037070:	4293      	cmp	r3, r2
 8037072:	d801      	bhi.n	8037078 <VerifyRfFreq+0x48>
        *band = 5;
 8037074:	2305      	movs	r3, #5
 8037076:	e7e8      	b.n	803704a <VerifyRfFreq+0x1a>
    else if( ( freq >= 869400000 ) && ( freq <= 869650000 ) )
 8037078:	4b10      	ldr	r3, [pc, #64]	; (80370bc <VerifyRfFreq+0x8c>)
 803707a:	4a11      	ldr	r2, [pc, #68]	; (80370c0 <VerifyRfFreq+0x90>)
 803707c:	442b      	add	r3, r5
 803707e:	4293      	cmp	r3, r2
 8037080:	d801      	bhi.n	8037086 <VerifyRfFreq+0x56>
        *band = 3;
 8037082:	2303      	movs	r3, #3
 8037084:	e7e1      	b.n	803704a <VerifyRfFreq+0x1a>
    else if( ( freq >= 869700000 ) && ( freq <= 870000000 ) )
 8037086:	4b0f      	ldr	r3, [pc, #60]	; (80370c4 <VerifyRfFreq+0x94>)
 8037088:	4a0f      	ldr	r2, [pc, #60]	; (80370c8 <VerifyRfFreq+0x98>)
 803708a:	442b      	add	r3, r5
 803708c:	4293      	cmp	r3, r2
 803708e:	d801      	bhi.n	8037094 <VerifyRfFreq+0x64>
        *band = 4;
 8037090:	2304      	movs	r3, #4
 8037092:	e7da      	b.n	803704a <VerifyRfFreq+0x1a>
        return false;
 8037094:	2000      	movs	r0, #0
 8037096:	e7d9      	b.n	803704c <VerifyRfFreq+0x1c>
 8037098:	0803bbd8 	.word	0x0803bbd8
 803709c:	cc8faa40 	.word	0xcc8faa40
 80370a0:	001e847f 	.word	0x001e847f
 80370a4:	cc7125c0 	.word	0xcc7125c0
 80370a8:	002dc6c0 	.word	0x002dc6c0
 80370ac:	cc435eff 	.word	0xcc435eff
 80370b0:	000927bf 	.word	0x000927bf
 80370b4:	cc38b0a0 	.word	0xcc38b0a0
 80370b8:	0007a120 	.word	0x0007a120
 80370bc:	cc2e0240 	.word	0xcc2e0240
 80370c0:	0003d090 	.word	0x0003d090
 80370c4:	cc296e60 	.word	0xcc296e60
 80370c8:	000493e0 	.word	0x000493e0

080370cc <RegionEU868GetPhyParam>:
#endif /* REGION_EU868 */

PhyParam_t RegionEU868GetPhyParam( GetPhyParams_t* getPhy )
{
 80370cc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 80370ce:	7802      	ldrb	r2, [r0, #0]
    PhyParam_t phyParam = { 0 };
 80370d0:	2300      	movs	r3, #0
 80370d2:	3a0b      	subs	r2, #11
 80370d4:	9300      	str	r3, [sp, #0]

#if defined( REGION_EU868 )
    switch( getPhy->Attribute )
 80370d6:	2a2e      	cmp	r2, #46	; 0x2e
 80370d8:	d871      	bhi.n	80371be <RegionEU868GetPhyParam+0xf2>
 80370da:	e8df f002 	tbb	[pc, r2]
 80370de:	302d      	.short	0x302d
 80370e0:	42403932 	.word	0x42403932
 80370e4:	4e4b4845 	.word	0x4e4b4845
 80370e8:	5c705451 	.word	0x5c705451
 80370ec:	68635e70 	.word	0x68635e70
 80370f0:	6d70706a 	.word	0x6d70706a
 80370f4:	70701874 	.word	0x70701874
 80370f8:	70707070 	.word	0x70707070
 80370fc:	70707070 	.word	0x70707070
 8037100:	5c707070 	.word	0x5c707070
 8037104:	70707d76 	.word	0x70707d76
 8037108:	7f707d5c 	.word	0x7f707d5c
 803710c:	84          	.byte	0x84
 803710d:	00          	.byte	0x00
            phyParam.Value = EU868_DEFAULT_DATARATE;
            break;
        }
        case PHY_NEXT_LOWER_TX_DR:
        {
            RegionCommonGetNextLowerTxDrParams_t nextLowerTxDrParams =
 803710e:	7843      	ldrb	r3, [r0, #1]
 8037110:	f88d 3004 	strb.w	r3, [sp, #4]
 8037114:	2307      	movs	r3, #7
 8037116:	f88d 3005 	strb.w	r3, [sp, #5]
 803711a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 803711e:	f8ad 3006 	strh.w	r3, [sp, #6]
            {
                .CurrentDr = getPhy->Datarate,
                .MaxDr = ( int8_t )EU868_TX_MAX_DATARATE,
                .MinDr = ( int8_t )EU868_TX_MIN_DATARATE,
                .NbChannels = EU868_MAX_NB_CHANNELS,
                .ChannelsMask = RegionNvmGroup2->ChannelsMask,
 8037122:	4b34      	ldr	r3, [pc, #208]	; (80371f4 <RegionEU868GetPhyParam+0x128>)
 8037124:	681b      	ldr	r3, [r3, #0]
                .Channels = RegionNvmGroup2->Channels,
            };
            phyParam.Value = RegionCommonGetNextLowerTxDr( &nextLowerTxDrParams );
 8037126:	a801      	add	r0, sp, #4
                .ChannelsMask = RegionNvmGroup2->ChannelsMask,
 8037128:	f503 7258 	add.w	r2, r3, #864	; 0x360
            RegionCommonGetNextLowerTxDrParams_t nextLowerTxDrParams =
 803712c:	e9cd 2302 	strd	r2, r3, [sp, #8]
            phyParam.Value = RegionCommonGetNextLowerTxDr( &nextLowerTxDrParams );
 8037130:	f7ff fee9 	bl	8036f06 <RegionCommonGetNextLowerTxDr>
            phyParam.Value = DataratesEU868[getPhy->Datarate];
            break;
        }
        case PHY_BW_FROM_DR:
        {
            phyParam.Value = RegionCommonGetBandwidth( getPhy->Datarate, BandwidthsEU868 );
 8037134:	9000      	str	r0, [sp, #0]
            break;
 8037136:	e042      	b.n	80371be <RegionEU868GetPhyParam+0xf2>
            phyParam.Value = REGION_COMMON_DEFAULT_ADR_ACK_LIMIT;
 8037138:	2340      	movs	r3, #64	; 0x40
            phyParam.Value = EU868_BEACON_CHANNEL_DR;
 803713a:	9300      	str	r3, [sp, #0]
            break;
 803713c:	e03f      	b.n	80371be <RegionEU868GetPhyParam+0xf2>
            phyParam.Value = REGION_COMMON_DEFAULT_ADR_ACK_DELAY;
 803713e:	2320      	movs	r3, #32
 8037140:	e7fb      	b.n	803713a <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = MaxPayloadOfDatarateEU868[getPhy->Datarate];
 8037142:	f990 2001 	ldrsb.w	r2, [r0, #1]
 8037146:	4b2c      	ldr	r3, [pc, #176]	; (80371f8 <RegionEU868GetPhyParam+0x12c>)
 8037148:	4413      	add	r3, r2
 803714a:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 803714e:	e7f4      	b.n	803713a <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = MaxPayloadOfDatarateRepeaterEU868[getPhy->Datarate];
 8037150:	f990 2001 	ldrsb.w	r2, [r0, #1]
 8037154:	4b28      	ldr	r3, [pc, #160]	; (80371f8 <RegionEU868GetPhyParam+0x12c>)
 8037156:	4413      	add	r3, r2
 8037158:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 803715c:	e7ed      	b.n	803713a <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = EU868_DUTY_CYCLE_ENABLED;
 803715e:	2301      	movs	r3, #1
 8037160:	e7eb      	b.n	803713a <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = EU868_MAX_RX_WINDOW;
 8037162:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8037166:	e7e8      	b.n	803713a <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = REGION_COMMON_DEFAULT_RECEIVE_DELAY1;
 8037168:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 803716c:	e7e5      	b.n	803713a <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = REGION_COMMON_DEFAULT_RECEIVE_DELAY2;
 803716e:	f44f 63fa 	mov.w	r3, #2000	; 0x7d0
 8037172:	e7e2      	b.n	803713a <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = REGION_COMMON_DEFAULT_JOIN_ACCEPT_DELAY1;
 8037174:	f241 3388 	movw	r3, #5000	; 0x1388
 8037178:	e7df      	b.n	803713a <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = REGION_COMMON_DEFAULT_JOIN_ACCEPT_DELAY2;
 803717a:	f241 7370 	movw	r3, #6000	; 0x1770
 803717e:	e7dc      	b.n	803713a <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = REGION_COMMON_DEFAULT_MAX_FCNT_GAP;
 8037180:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8037184:	e7d9      	b.n	803713a <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = ( REGION_COMMON_DEFAULT_ACK_TIMEOUT + randr( -REGION_COMMON_DEFAULT_ACK_TIMEOUT_RND, REGION_COMMON_DEFAULT_ACK_TIMEOUT_RND ) );
 8037186:	481d      	ldr	r0, [pc, #116]	; (80371fc <RegionEU868GetPhyParam+0x130>)
 8037188:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 803718c:	f001 fe88 	bl	8038ea0 <randr>
 8037190:	f500 60fa 	add.w	r0, r0, #2000	; 0x7d0
 8037194:	e7ce      	b.n	8037134 <RegionEU868GetPhyParam+0x68>
            phyParam.Value = EU868_RX_WND_2_FREQ;
 8037196:	4b1a      	ldr	r3, [pc, #104]	; (8037200 <RegionEU868GetPhyParam+0x134>)
 8037198:	e7cf      	b.n	803713a <RegionEU868GetPhyParam+0x6e>
            phyParam.ChannelsMask = RegionNvmGroup2->ChannelsMask;
 803719a:	4b16      	ldr	r3, [pc, #88]	; (80371f4 <RegionEU868GetPhyParam+0x128>)
 803719c:	681b      	ldr	r3, [r3, #0]
 803719e:	f503 7358 	add.w	r3, r3, #864	; 0x360
 80371a2:	e7ca      	b.n	803713a <RegionEU868GetPhyParam+0x6e>
            phyParam.ChannelsMask = RegionNvmGroup2->ChannelsDefaultMask;
 80371a4:	4b13      	ldr	r3, [pc, #76]	; (80371f4 <RegionEU868GetPhyParam+0x128>)
 80371a6:	681b      	ldr	r3, [r3, #0]
 80371a8:	f503 735b 	add.w	r3, r3, #876	; 0x36c
 80371ac:	e7c5      	b.n	803713a <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = EU868_MAX_NB_CHANNELS;
 80371ae:	2310      	movs	r3, #16
 80371b0:	e7c3      	b.n	803713a <RegionEU868GetPhyParam+0x6e>
            phyParam.Channels = RegionNvmGroup2->Channels;
 80371b2:	4b10      	ldr	r3, [pc, #64]	; (80371f4 <RegionEU868GetPhyParam+0x128>)
 80371b4:	681b      	ldr	r3, [r3, #0]
 80371b6:	e7c0      	b.n	803713a <RegionEU868GetPhyParam+0x6e>
            phyParam.fValue = EU868_DEFAULT_MAX_EIRP;
 80371b8:	f04f 4383 	mov.w	r3, #1098907648	; 0x41800000
            phyParam.fValue = EU868_DEFAULT_ANTENNA_GAIN;
 80371bc:	9300      	str	r3, [sp, #0]
        }
    }

#endif /* REGION_EU868 */
    return phyParam;
}
 80371be:	9800      	ldr	r0, [sp, #0]
 80371c0:	b005      	add	sp, #20
 80371c2:	f85d fb04 	ldr.w	pc, [sp], #4
            phyParam.fValue = EU868_DEFAULT_ANTENNA_GAIN;
 80371c6:	4b0f      	ldr	r3, [pc, #60]	; (8037204 <RegionEU868GetPhyParam+0x138>)
 80371c8:	e7f8      	b.n	80371bc <RegionEU868GetPhyParam+0xf0>
            phyParam.BeaconFormat.BeaconSize = EU868_BEACON_SIZE;
 80371ca:	f240 2211 	movw	r2, #529	; 0x211
 80371ce:	f8ad 2000 	strh.w	r2, [sp]
            phyParam.BeaconFormat.Rfu2Size = EU868_RFU2_SIZE;
 80371d2:	f88d 3002 	strb.w	r3, [sp, #2]
            break;
 80371d6:	e7f2      	b.n	80371be <RegionEU868GetPhyParam+0xf2>
            phyParam.Value = EU868_BEACON_CHANNEL_DR;
 80371d8:	2303      	movs	r3, #3
 80371da:	e7ae      	b.n	803713a <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = DataratesEU868[getPhy->Datarate];
 80371dc:	f990 3001 	ldrsb.w	r3, [r0, #1]
 80371e0:	4a05      	ldr	r2, [pc, #20]	; (80371f8 <RegionEU868GetPhyParam+0x12c>)
 80371e2:	5cd3      	ldrb	r3, [r2, r3]
 80371e4:	e7a9      	b.n	803713a <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = RegionCommonGetBandwidth( getPhy->Datarate, BandwidthsEU868 );
 80371e6:	4908      	ldr	r1, [pc, #32]	; (8037208 <RegionEU868GetPhyParam+0x13c>)
 80371e8:	f990 0001 	ldrsb.w	r0, [r0, #1]
 80371ec:	f7ff feaa 	bl	8036f44 <RegionCommonGetBandwidth>
 80371f0:	e7a0      	b.n	8037134 <RegionEU868GetPhyParam+0x68>
 80371f2:	bf00      	nop
 80371f4:	20005728 	.word	0x20005728
 80371f8:	0803ba9c 	.word	0x0803ba9c
 80371fc:	fffffc18 	.word	0xfffffc18
 8037200:	33d3e608 	.word	0x33d3e608
 8037204:	4009999a 	.word	0x4009999a
 8037208:	0803baa4 	.word	0x0803baa4

0803720c <RegionEU868SetBandTxDone>:

void RegionEU868SetBandTxDone( SetBandTxDoneParams_t* txDone )
{
 803720c:	b537      	push	{r0, r1, r2, r4, r5, lr}
#if defined( REGION_EU868 )
    RegionCommonSetBandTxDone( &RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txDone->Channel].Band],
 803720e:	4a0a      	ldr	r2, [pc, #40]	; (8037238 <RegionEU868SetBandTxDone+0x2c>)
 8037210:	7803      	ldrb	r3, [r0, #0]
 8037212:	6811      	ldr	r1, [r2, #0]
 8037214:	6855      	ldr	r5, [r2, #4]
 8037216:	240c      	movs	r4, #12
 8037218:	fb04 1303 	mla	r3, r4, r3, r1
 803721c:	7a5b      	ldrb	r3, [r3, #9]
 803721e:	eb03 0443 	add.w	r4, r3, r3, lsl #1
 8037222:	6903      	ldr	r3, [r0, #16]
 8037224:	9300      	str	r3, [sp, #0]
 8037226:	68c3      	ldr	r3, [r0, #12]
 8037228:	7842      	ldrb	r2, [r0, #1]
 803722a:	6881      	ldr	r1, [r0, #8]
 803722c:	eb05 00c4 	add.w	r0, r5, r4, lsl #3
 8037230:	f7ff fc18 	bl	8036a64 <RegionCommonSetBandTxDone>
                               txDone->LastTxAirTime, txDone->Joined, txDone->ElapsedTimeSinceStartUp );
#endif /* REGION_EU868 */
}
 8037234:	b003      	add	sp, #12
 8037236:	bd30      	pop	{r4, r5, pc}
 8037238:	20005728 	.word	0x20005728

0803723c <RegionEU868InitDefaults>:

void RegionEU868InitDefaults( InitDefaultsParams_t* params )
{
 803723c:	b530      	push	{r4, r5, lr}
 803723e:	b0a5      	sub	sp, #148	; 0x94
 8037240:	4604      	mov	r4, r0
#if defined( REGION_EU868 )
    Band_t bands[EU868_MAX_NB_BANDS] =
 8037242:	2290      	movs	r2, #144	; 0x90
 8037244:	2100      	movs	r1, #0
 8037246:	4668      	mov	r0, sp
 8037248:	f004 fa72 	bl	803b730 <memset>
 803724c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8037250:	f8ad 2030 	strh.w	r2, [sp, #48]	; 0x30
 8037254:	f8ad 2078 	strh.w	r2, [sp, #120]	; 0x78
        EU868_BAND3,
        EU868_BAND4,
        EU868_BAND5,
    };

    switch( params->Type )
 8037258:	7a22      	ldrb	r2, [r4, #8]
    Band_t bands[EU868_MAX_NB_BANDS] =
 803725a:	2364      	movs	r3, #100	; 0x64
 803725c:	210a      	movs	r1, #10
    switch( params->Type )
 803725e:	2a01      	cmp	r2, #1
    Band_t bands[EU868_MAX_NB_BANDS] =
 8037260:	f8ad 3000 	strh.w	r3, [sp]
 8037264:	f8ad 3018 	strh.w	r3, [sp, #24]
 8037268:	f8ad 1048 	strh.w	r1, [sp, #72]	; 0x48
 803726c:	f8ad 3060 	strh.w	r3, [sp, #96]	; 0x60
    switch( params->Type )
 8037270:	d02d      	beq.n	80372ce <RegionEU868InitDefaults+0x92>
 8037272:	2a02      	cmp	r2, #2
 8037274:	d036      	beq.n	80372e4 <RegionEU868InitDefaults+0xa8>
 8037276:	bb42      	cbnz	r2, 80372ca <RegionEU868InitDefaults+0x8e>
    {
        case INIT_TYPE_DEFAULTS:
        {
            if( ( params->NvmGroup1 == NULL ) || ( params->NvmGroup2 == NULL ) )
 8037278:	6820      	ldr	r0, [r4, #0]
 803727a:	b330      	cbz	r0, 80372ca <RegionEU868InitDefaults+0x8e>
 803727c:	6863      	ldr	r3, [r4, #4]
 803727e:	b323      	cbz	r3, 80372ca <RegionEU868InitDefaults+0x8e>
            {
                return;
            }

            RegionNvmGroup1 = (RegionNvmDataGroup1_t*) params->NvmGroup1;
 8037280:	4c1d      	ldr	r4, [pc, #116]	; (80372f8 <RegionEU868InitDefaults+0xbc>)
            RegionNvmGroup2 = (RegionNvmDataGroup2_t*) params->NvmGroup2;

            // Default bands
            memcpy1( ( uint8_t* )RegionNvmGroup1->Bands, ( uint8_t* )bands, sizeof( Band_t ) * EU868_MAX_NB_BANDS );
 8037282:	2290      	movs	r2, #144	; 0x90
 8037284:	4669      	mov	r1, sp
            RegionNvmGroup2 = (RegionNvmDataGroup2_t*) params->NvmGroup2;
 8037286:	e9c4 3000 	strd	r3, r0, [r4]
            memcpy1( ( uint8_t* )RegionNvmGroup1->Bands, ( uint8_t* )bands, sizeof( Band_t ) * EU868_MAX_NB_BANDS );
 803728a:	f001 fe25 	bl	8038ed8 <memcpy1>

            // Default channels
            RegionNvmGroup2->Channels[0] = ( ChannelParams_t ) EU868_LC1;
 803728e:	4b1b      	ldr	r3, [pc, #108]	; (80372fc <RegionEU868InitDefaults+0xc0>)
 8037290:	6824      	ldr	r4, [r4, #0]
 8037292:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8037296:	e884 0007 	stmia.w	r4, {r0, r1, r2}
            RegionNvmGroup2->Channels[1] = ( ChannelParams_t ) EU868_LC2;
 803729a:	f103 020c 	add.w	r2, r3, #12
 803729e:	ca07      	ldmia	r2, {r0, r1, r2}
 80372a0:	f104 050c 	add.w	r5, r4, #12
            RegionNvmGroup2->Channels[2] = ( ChannelParams_t ) EU868_LC3;
 80372a4:	3318      	adds	r3, #24
            RegionNvmGroup2->Channels[1] = ( ChannelParams_t ) EU868_LC2;
 80372a6:	e885 0007 	stmia.w	r5, {r0, r1, r2}
            RegionNvmGroup2->Channels[2] = ( ChannelParams_t ) EU868_LC3;
 80372aa:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 80372ae:	f104 0518 	add.w	r5, r4, #24

            // Default ChannelsMask
            RegionNvmGroup2->ChannelsDefaultMask[0] = LC( 1 ) + LC( 2 ) + LC( 3 );
 80372b2:	2307      	movs	r3, #7
            RegionNvmGroup2->Channels[2] = ( ChannelParams_t ) EU868_LC3;
 80372b4:	e885 0007 	stmia.w	r5, {r0, r1, r2}
            RegionNvmGroup2->ChannelsDefaultMask[0] = LC( 1 ) + LC( 2 ) + LC( 3 );
 80372b8:	f8a4 336c 	strh.w	r3, [r4, #876]	; 0x36c

            // Update the channels mask
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
 80372bc:	2201      	movs	r2, #1
 80372be:	f504 715b 	add.w	r1, r4, #876	; 0x36c
 80372c2:	f504 7058 	add.w	r0, r4, #864	; 0x360
            // Reset Channels Rx1Frequency to default 0
            RegionNvmGroup2->Channels[0].Rx1Frequency = 0;
            RegionNvmGroup2->Channels[1].Rx1Frequency = 0;
            RegionNvmGroup2->Channels[2].Rx1Frequency = 0;
            // Update the channels mask
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
 80372c6:	f7ff fbbe 	bl	8036a46 <RegionCommonChanMaskCopy>
        {
            break;
        }
    }
#endif /* REGION_EU868 */
}
 80372ca:	b025      	add	sp, #148	; 0x94
 80372cc:	bd30      	pop	{r4, r5, pc}
            RegionNvmGroup2->Channels[0].Rx1Frequency = 0;
 80372ce:	4b0a      	ldr	r3, [pc, #40]	; (80372f8 <RegionEU868InitDefaults+0xbc>)
 80372d0:	6818      	ldr	r0, [r3, #0]
 80372d2:	2300      	movs	r3, #0
 80372d4:	6043      	str	r3, [r0, #4]
            RegionNvmGroup2->Channels[1].Rx1Frequency = 0;
 80372d6:	6103      	str	r3, [r0, #16]
            RegionNvmGroup2->Channels[2].Rx1Frequency = 0;
 80372d8:	61c3      	str	r3, [r0, #28]
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
 80372da:	f500 715b 	add.w	r1, r0, #876	; 0x36c
 80372de:	f500 7058 	add.w	r0, r0, #864	; 0x360
 80372e2:	e7f0      	b.n	80372c6 <RegionEU868InitDefaults+0x8a>
            RegionNvmGroup2->ChannelsMask[0] |= RegionNvmGroup2->ChannelsDefaultMask[0];
 80372e4:	4b04      	ldr	r3, [pc, #16]	; (80372f8 <RegionEU868InitDefaults+0xbc>)
 80372e6:	681b      	ldr	r3, [r3, #0]
 80372e8:	f8b3 2360 	ldrh.w	r2, [r3, #864]	; 0x360
 80372ec:	f8b3 136c 	ldrh.w	r1, [r3, #876]	; 0x36c
 80372f0:	430a      	orrs	r2, r1
 80372f2:	f8a3 2360 	strh.w	r2, [r3, #864]	; 0x360
            break;
 80372f6:	e7e8      	b.n	80372ca <RegionEU868InitDefaults+0x8e>
 80372f8:	20005728 	.word	0x20005728
 80372fc:	0803bad4 	.word	0x0803bad4

08037300 <RegionEU868Verify>:

bool RegionEU868Verify( VerifyParams_t* verify, PhyAttribute_t phyAttribute )
{
 8037300:	b507      	push	{r0, r1, r2, lr}
 8037302:	290f      	cmp	r1, #15
 8037304:	d809      	bhi.n	803731a <RegionEU868Verify+0x1a>
 8037306:	e8df f001 	tbb	[pc, r1]
 803730a:	080c      	.short	0x080c
 803730c:	1f080808 	.word	0x1f080808
 8037310:	1f081f15 	.word	0x1f081f15
 8037314:	0808081f 	.word	0x0808081f
 8037318:	2108      	.short	0x2108
            // Remark: switched min and max!
            return RegionCommonValueInRange( verify->TxPower, EU868_MAX_TX_POWER, EU868_MIN_TX_POWER );
        }
        case PHY_DUTY_CYCLE:
        {
            return EU868_DUTY_CYCLE_ENABLED;
 803731a:	2000      	movs	r0, #0
            return false;
    }
#else
    return false;
#endif /* REGION_EU868 */
}
 803731c:	b003      	add	sp, #12
 803731e:	f85d fb04 	ldr.w	pc, [sp], #4
            uint8_t band = 0;
 8037322:	2300      	movs	r3, #0
            return VerifyRfFreq( verify->Frequency, &band );
 8037324:	f10d 0107 	add.w	r1, sp, #7
 8037328:	6800      	ldr	r0, [r0, #0]
            uint8_t band = 0;
 803732a:	f88d 3007 	strb.w	r3, [sp, #7]
            return VerifyRfFreq( verify->Frequency, &band );
 803732e:	f7ff fe7f 	bl	8037030 <VerifyRfFreq>
 8037332:	e7f3      	b.n	803731c <RegionEU868Verify+0x1c>
            return RegionCommonValueInRange( verify->DatarateParams.Datarate, DR_0, DR_5 );
 8037334:	2205      	movs	r2, #5
 8037336:	f990 0000 	ldrsb.w	r0, [r0]
 803733a:	2100      	movs	r1, #0
 803733c:	f7ff fb43 	bl	80369c6 <RegionCommonValueInRange>
 8037340:	3800      	subs	r0, #0
 8037342:	bf18      	it	ne
 8037344:	2001      	movne	r0, #1
 8037346:	e7e9      	b.n	803731c <RegionEU868Verify+0x1c>
            return RegionCommonValueInRange( verify->TxPower, EU868_MAX_TX_POWER, EU868_MIN_TX_POWER );
 8037348:	2207      	movs	r2, #7
 803734a:	e7f4      	b.n	8037336 <RegionEU868Verify+0x36>
            return EU868_DUTY_CYCLE_ENABLED;
 803734c:	2001      	movs	r0, #1
 803734e:	e7e5      	b.n	803731c <RegionEU868Verify+0x1c>

08037350 <RegionEU868ChanMaskSet>:
    }
#endif /* REGION_EU868 */
}

bool RegionEU868ChanMaskSet( ChanMaskSetParams_t* chanMaskSet )
{
 8037350:	b510      	push	{r4, lr}
#if defined( REGION_EU868 )
    switch( chanMaskSet->ChannelsMaskType )
 8037352:	7904      	ldrb	r4, [r0, #4]
 8037354:	b11c      	cbz	r4, 803735e <RegionEU868ChanMaskSet+0xe>
 8037356:	2c01      	cmp	r4, #1
 8037358:	d00b      	beq.n	8037372 <RegionEU868ChanMaskSet+0x22>
 803735a:	2000      	movs	r0, #0
    }
    return true;
#else
    return false;
#endif /* REGION_EU868 */
}
 803735c:	bd10      	pop	{r4, pc}
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, chanMaskSet->ChannelsMaskIn, CHANNELS_MASK_SIZE );
 803735e:	4b0a      	ldr	r3, [pc, #40]	; (8037388 <RegionEU868ChanMaskSet+0x38>)
 8037360:	6801      	ldr	r1, [r0, #0]
 8037362:	681b      	ldr	r3, [r3, #0]
 8037364:	2201      	movs	r2, #1
 8037366:	f503 7058 	add.w	r0, r3, #864	; 0x360
 803736a:	f7ff fb6c 	bl	8036a46 <RegionCommonChanMaskCopy>
    return true;
 803736e:	2001      	movs	r0, #1
            break;
 8037370:	e7f4      	b.n	803735c <RegionEU868ChanMaskSet+0xc>
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsDefaultMask, chanMaskSet->ChannelsMaskIn, CHANNELS_MASK_SIZE );
 8037372:	4b05      	ldr	r3, [pc, #20]	; (8037388 <RegionEU868ChanMaskSet+0x38>)
 8037374:	6801      	ldr	r1, [r0, #0]
 8037376:	681b      	ldr	r3, [r3, #0]
 8037378:	4622      	mov	r2, r4
 803737a:	f503 705b 	add.w	r0, r3, #876	; 0x36c
 803737e:	f7ff fb62 	bl	8036a46 <RegionCommonChanMaskCopy>
    return true;
 8037382:	4620      	mov	r0, r4
            break;
 8037384:	e7ea      	b.n	803735c <RegionEU868ChanMaskSet+0xc>
 8037386:	bf00      	nop
 8037388:	20005728 	.word	0x20005728

0803738c <RegionEU868ComputeRxWindowParameters>:

void RegionEU868ComputeRxWindowParameters( int8_t datarate, uint8_t minRxSymbols, uint32_t rxError, RxConfigParams_t *rxConfigParams )
{
 803738c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
#if defined( REGION_EU868 )
    uint32_t tSymbolInUs = 0;

    // Get the datarate, perform a boundary check
    rxConfigParams->Datarate = MIN( datarate, EU868_RX_MAX_DATARATE );
 803738e:	2807      	cmp	r0, #7
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsEU868 );
 8037390:	4d15      	ldr	r5, [pc, #84]	; (80373e8 <RegionEU868ComputeRxWindowParameters+0x5c>)
{
 8037392:	461c      	mov	r4, r3
    rxConfigParams->Datarate = MIN( datarate, EU868_RX_MAX_DATARATE );
 8037394:	bfa8      	it	ge
 8037396:	2007      	movge	r0, #7
 8037398:	7058      	strb	r0, [r3, #1]
{
 803739a:	460e      	mov	r6, r1
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsEU868 );
 803739c:	f105 0108 	add.w	r1, r5, #8
{
 80373a0:	4617      	mov	r7, r2
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsEU868 );
 80373a2:	f7ff fdcf 	bl	8036f44 <RegionCommonGetBandwidth>

    if( rxConfigParams->Datarate == DR_7 )
 80373a6:	f994 3001 	ldrsb.w	r3, [r4, #1]
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsEU868 );
 80373aa:	70a0      	strb	r0, [r4, #2]
    if( rxConfigParams->Datarate == DR_7 )
 80373ac:	2b07      	cmp	r3, #7
 80373ae:	d113      	bne.n	80373d8 <RegionEU868ComputeRxWindowParameters+0x4c>
    { // FSK
        tSymbolInUs = RegionCommonComputeSymbolTimeFsk( DataratesEU868[rxConfigParams->Datarate] );
 80373b0:	2032      	movs	r0, #50	; 0x32
 80373b2:	f7ff fccb 	bl	8036d4c <RegionCommonComputeSymbolTimeFsk>
    else
    { // LoRa
        tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesEU868[rxConfigParams->Datarate], BandwidthsEU868[rxConfigParams->Datarate] );
    }

    RegionCommonComputeRxWindowParameters( tSymbolInUs, minRxSymbols, rxError, Radio.GetWakeupTime( ), &rxConfigParams->WindowTimeout, &rxConfigParams->WindowOffset );
 80373b6:	4b0d      	ldr	r3, [pc, #52]	; (80373ec <RegionEU868ComputeRxWindowParameters+0x60>)
 80373b8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
        tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesEU868[rxConfigParams->Datarate], BandwidthsEU868[rxConfigParams->Datarate] );
 80373ba:	4605      	mov	r5, r0
    RegionCommonComputeRxWindowParameters( tSymbolInUs, minRxSymbols, rxError, Radio.GetWakeupTime( ), &rxConfigParams->WindowTimeout, &rxConfigParams->WindowOffset );
 80373bc:	4798      	blx	r3
 80373be:	f104 020c 	add.w	r2, r4, #12
 80373c2:	3408      	adds	r4, #8
 80373c4:	4603      	mov	r3, r0
 80373c6:	9201      	str	r2, [sp, #4]
 80373c8:	9400      	str	r4, [sp, #0]
 80373ca:	463a      	mov	r2, r7
 80373cc:	4631      	mov	r1, r6
 80373ce:	4628      	mov	r0, r5
 80373d0:	f7ff fcc1 	bl	8036d56 <RegionCommonComputeRxWindowParameters>
#endif /* REGION_EU868 */
}
 80373d4:	b003      	add	sp, #12
 80373d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
        tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesEU868[rxConfigParams->Datarate], BandwidthsEU868[rxConfigParams->Datarate] );
 80373d8:	eb05 0283 	add.w	r2, r5, r3, lsl #2
 80373dc:	5ce8      	ldrb	r0, [r5, r3]
 80373de:	6891      	ldr	r1, [r2, #8]
 80373e0:	f7ff fcac 	bl	8036d3c <RegionCommonComputeSymbolTimeLoRa>
 80373e4:	e7e7      	b.n	80373b6 <RegionEU868ComputeRxWindowParameters+0x2a>
 80373e6:	bf00      	nop
 80373e8:	0803ba9c 	.word	0x0803ba9c
 80373ec:	0803bbd8 	.word	0x0803bbd8

080373f0 <RegionEU868RxConfig>:

bool RegionEU868RxConfig( RxConfigParams_t* rxConfig, int8_t* datarate )
{
 80373f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int8_t dr = rxConfig->Datarate;
    uint8_t maxPayload = 0;
    int8_t phyDr = 0;
    uint32_t frequency = rxConfig->Frequency;

    if( Radio.GetStatus( ) != RF_IDLE )
 80373f4:	4e39      	ldr	r6, [pc, #228]	; (80374dc <RegionEU868RxConfig+0xec>)
    int8_t dr = rxConfig->Datarate;
 80373f6:	f990 7001 	ldrsb.w	r7, [r0, #1]
    if( Radio.GetStatus( ) != RF_IDLE )
 80373fa:	6873      	ldr	r3, [r6, #4]
    uint32_t frequency = rxConfig->Frequency;
 80373fc:	f8d0 9004 	ldr.w	r9, [r0, #4]
{
 8037400:	b08d      	sub	sp, #52	; 0x34
 8037402:	4604      	mov	r4, r0
 8037404:	468a      	mov	sl, r1
    if( Radio.GetStatus( ) != RF_IDLE )
 8037406:	4798      	blx	r3
 8037408:	46b0      	mov	r8, r6
 803740a:	4605      	mov	r5, r0
 803740c:	2800      	cmp	r0, #0
 803740e:	d163      	bne.n	80374d8 <RegionEU868RxConfig+0xe8>
    {
        return false;
    }

    if( rxConfig->RxSlot == RX_SLOT_WIN_1 )
 8037410:	7ce3      	ldrb	r3, [r4, #19]
 8037412:	b963      	cbnz	r3, 803742e <RegionEU868RxConfig+0x3e>
    {
        // Apply window 1 frequency
        frequency = RegionNvmGroup2->Channels[rxConfig->Channel].Frequency;
 8037414:	4a32      	ldr	r2, [pc, #200]	; (80374e0 <RegionEU868RxConfig+0xf0>)
 8037416:	7823      	ldrb	r3, [r4, #0]
 8037418:	6812      	ldr	r2, [r2, #0]
 803741a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 803741e:	eb02 0183 	add.w	r1, r2, r3, lsl #2
 8037422:	f852 9023 	ldr.w	r9, [r2, r3, lsl #2]
        // Apply the alternative RX 1 window frequency, if it is available
        if( RegionNvmGroup2->Channels[rxConfig->Channel].Rx1Frequency != 0 )
 8037426:	684b      	ldr	r3, [r1, #4]
 8037428:	2b00      	cmp	r3, #0
 803742a:	bf18      	it	ne
 803742c:	4699      	movne	r9, r3
            frequency = RegionNvmGroup2->Channels[rxConfig->Channel].Rx1Frequency;
        }
    }

    // Read the physical datarate from the datarates table
    phyDr = DataratesEU868[dr];
 803742e:	4e2d      	ldr	r6, [pc, #180]	; (80374e4 <RegionEU868RxConfig+0xf4>)

    Radio.SetChannel( frequency );
 8037430:	f8d8 300c 	ldr.w	r3, [r8, #12]
    phyDr = DataratesEU868[dr];
 8037434:	f916 b007 	ldrsb.w	fp, [r6, r7]
    Radio.SetChannel( frequency );
 8037438:	4648      	mov	r0, r9
 803743a:	4798      	blx	r3

    // Radio configuration
    if( dr == DR_7 )
 803743c:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8037440:	68a0      	ldr	r0, [r4, #8]
 8037442:	960b      	str	r6, [sp, #44]	; 0x2c
 8037444:	469c      	mov	ip, r3
 8037446:	2f07      	cmp	r7, #7
 8037448:	7ca3      	ldrb	r3, [r4, #18]
    {
        modem = MODEM_FSK;
        Radio.SetRxConfig( modem, 50000, phyDr * 1000, 0, 83333, 5, rxConfig->WindowTimeout, false, 0, true, 0, 0, false, rxConfig->RxContinuous );
 803744a:	9309      	str	r3, [sp, #36]	; 0x24
    if( dr == DR_7 )
 803744c:	d12d      	bne.n	80374aa <RegionEU868RxConfig+0xba>
        Radio.SetRxConfig( modem, 50000, phyDr * 1000, 0, 83333, 5, rxConfig->WindowTimeout, false, 0, true, 0, 0, false, rxConfig->RxContinuous );
 803744e:	2300      	movs	r3, #0
 8037450:	2101      	movs	r1, #1
 8037452:	e9cd 3104 	strd	r3, r1, [sp, #16]
 8037456:	4924      	ldr	r1, [pc, #144]	; (80374e8 <RegionEU868RxConfig+0xf8>)
 8037458:	9306      	str	r3, [sp, #24]
 803745a:	2205      	movs	r2, #5
 803745c:	e9cd 3307 	strd	r3, r3, [sp, #28]
 8037460:	e9cd 1200 	strd	r1, r2, [sp]
 8037464:	b280      	uxth	r0, r0
 8037466:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 803746a:	9002      	str	r0, [sp, #8]
 803746c:	9303      	str	r3, [sp, #12]
 803746e:	fb02 f20b 	mul.w	r2, r2, fp
 8037472:	f24c 3150 	movw	r1, #50000	; 0xc350
 8037476:	4618      	mov	r0, r3
    }
    else
    {
        modem = MODEM_LORA;
        Radio.SetRxConfig( modem, rxConfig->Bandwidth, phyDr, 1, 0, 8, rxConfig->WindowTimeout, false, 0, false, 0, 0, true, rxConfig->RxContinuous );
 8037478:	4666      	mov	r6, ip
 803747a:	47b0      	blx	r6
    }

    /* ST_WORKAROUND_BEGIN: Keep repeater feature */
    if( rxConfig->RepeaterSupport == true )
 803747c:	7c63      	ldrb	r3, [r4, #17]
 803747e:	b333      	cbz	r3, 80374ce <RegionEU868RxConfig+0xde>
    {
        maxPayload = MaxPayloadOfDatarateRepeaterEU868[dr];
 8037480:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8037482:	443b      	add	r3, r7
 8037484:	f893 1030 	ldrb.w	r1, [r3, #48]	; 0x30
    else
    {
        maxPayload = MaxPayloadOfDatarateEU868[dr];
    }

    Radio.SetMaxPayloadLength( modem, maxPayload + LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE );
 8037488:	f8d8 3054 	ldr.w	r3, [r8, #84]	; 0x54
 803748c:	310d      	adds	r1, #13
 803748e:	b2c9      	uxtb	r1, r1
 8037490:	4628      	mov	r0, r5
 8037492:	4798      	blx	r3
    /* ST_WORKAROUND_END */

    /* ST_WORKAROUND_BEGIN: Print Rx config */
    RegionCommonRxConfigPrint(rxConfig->RxSlot, frequency, dr);
 8037494:	7ce0      	ldrb	r0, [r4, #19]
 8037496:	463a      	mov	r2, r7
 8037498:	4649      	mov	r1, r9
 803749a:	f7ff fd65 	bl	8036f68 <RegionCommonRxConfigPrint>
    /* ST_WORKAROUND_END */

    *datarate = (uint8_t) dr;
 803749e:	f88a 7000 	strb.w	r7, [sl]
    return true;
 80374a2:	2001      	movs	r0, #1
#else
    return false;
#endif /* REGION_EU868 */
}
 80374a4:	b00d      	add	sp, #52	; 0x34
 80374a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        Radio.SetRxConfig( modem, rxConfig->Bandwidth, phyDr, 1, 0, 8, rxConfig->WindowTimeout, false, 0, false, 0, 0, true, rxConfig->RxContinuous );
 80374aa:	2100      	movs	r1, #0
 80374ac:	2501      	movs	r5, #1
 80374ae:	b280      	uxth	r0, r0
 80374b0:	2308      	movs	r3, #8
 80374b2:	e9cd 1300 	strd	r1, r3, [sp]
 80374b6:	e9cd 1507 	strd	r1, r5, [sp, #28]
 80374ba:	e9cd 1105 	strd	r1, r1, [sp, #20]
 80374be:	e9cd 1103 	strd	r1, r1, [sp, #12]
 80374c2:	9002      	str	r0, [sp, #8]
 80374c4:	78a1      	ldrb	r1, [r4, #2]
 80374c6:	462b      	mov	r3, r5
 80374c8:	465a      	mov	r2, fp
 80374ca:	4628      	mov	r0, r5
 80374cc:	e7d4      	b.n	8037478 <RegionEU868RxConfig+0x88>
        maxPayload = MaxPayloadOfDatarateEU868[dr];
 80374ce:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80374d0:	443b      	add	r3, r7
 80374d2:	f893 1028 	ldrb.w	r1, [r3, #40]	; 0x28
 80374d6:	e7d7      	b.n	8037488 <RegionEU868RxConfig+0x98>
        return false;
 80374d8:	2000      	movs	r0, #0
 80374da:	e7e3      	b.n	80374a4 <RegionEU868RxConfig+0xb4>
 80374dc:	0803bbd8 	.word	0x0803bbd8
 80374e0:	20005728 	.word	0x20005728
 80374e4:	0803ba9c 	.word	0x0803ba9c
 80374e8:	00014585 	.word	0x00014585

080374ec <RegionEU868TxConfig>:

bool RegionEU868TxConfig( TxConfigParams_t* txConfig, int8_t* txPower, TimerTime_t* txTimeOnAir )
{
 80374ec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if defined( REGION_EU868 )
    RadioModems_t modem;
    int8_t phyDr = DataratesEU868[txConfig->Datarate];
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
 80374f0:	4f3d      	ldr	r7, [pc, #244]	; (80375e8 <RegionEU868TxConfig+0xfc>)
    int8_t phyDr = DataratesEU868[txConfig->Datarate];
 80374f2:	f990 3001 	ldrsb.w	r3, [r0, #1]
 80374f6:	4e3d      	ldr	r6, [pc, #244]	; (80375ec <RegionEU868TxConfig+0x100>)
{
 80374f8:	b08f      	sub	sp, #60	; 0x3c
 80374fa:	e9cd 120b 	strd	r1, r2, [sp, #44]	; 0x2c
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
 80374fe:	e9d7 1200 	ldrd	r1, r2, [r7]
{
 8037502:	4604      	mov	r4, r0
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
 8037504:	7800      	ldrb	r0, [r0, #0]
    int8_t phyDr = DataratesEU868[txConfig->Datarate];
 8037506:	56f3      	ldrsb	r3, [r6, r3]
 8037508:	930d      	str	r3, [sp, #52]	; 0x34
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
 803750a:	250c      	movs	r5, #12
 803750c:	fb05 1100 	mla	r1, r5, r0, r1
 8037510:	2018      	movs	r0, #24
 8037512:	7a49      	ldrb	r1, [r1, #9]
 8037514:	fb00 2201 	mla	r2, r0, r1, r2
 8037518:	f994 0002 	ldrsb.w	r0, [r4, #2]
 803751c:	f992 1002 	ldrsb.w	r1, [r2, #2]
 8037520:	f7ff fd0c 	bl	8036f3c <RegionCommonLimitTxPower>
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsEU868 );
 8037524:	f106 0108 	add.w	r1, r6, #8
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
 8037528:	4681      	mov	r9, r0
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsEU868 );
 803752a:	f994 0001 	ldrsb.w	r0, [r4, #1]
 803752e:	f7ff fd09 	bl	8036f44 <RegionCommonGetBandwidth>
    int8_t phyTxPower = 0;

    // Calculate physical TX power
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, txConfig->MaxEirp, txConfig->AntennaGain );
 8037532:	68a2      	ldr	r2, [r4, #8]
 8037534:	6861      	ldr	r1, [r4, #4]
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsEU868 );
 8037536:	4683      	mov	fp, r0
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, txConfig->MaxEirp, txConfig->AntennaGain );
 8037538:	4648      	mov	r0, r9
 803753a:	f7ff fc34 	bl	8036da6 <RegionCommonComputeTxPower>
 803753e:	4682      	mov	sl, r0

    // Setup the radio frequency
    Radio.SetChannel( RegionNvmGroup2->Channels[txConfig->Channel].Frequency );
 8037540:	7820      	ldrb	r0, [r4, #0]
 8037542:	6839      	ldr	r1, [r7, #0]
 8037544:	4368      	muls	r0, r5
 8037546:	4d2a      	ldr	r5, [pc, #168]	; (80375f0 <RegionEU868TxConfig+0x104>)
 8037548:	5808      	ldr	r0, [r1, r0]
 803754a:	68ea      	ldr	r2, [r5, #12]
 803754c:	4790      	blx	r2

    if( txConfig->Datarate == DR_7 )
 803754e:	f994 2001 	ldrsb.w	r2, [r4, #1]
 8037552:	69eb      	ldr	r3, [r5, #28]
 8037554:	2a07      	cmp	r2, #7
 8037556:	46a8      	mov	r8, r5
 8037558:	f44f 627a 	mov.w	r2, #4000	; 0xfa0
 803755c:	f04f 0500 	mov.w	r5, #0
 8037560:	469c      	mov	ip, r3
    { // High Speed FSK channel
        modem = MODEM_FSK;
        Radio.SetTxConfig( modem, phyTxPower, 25000, bandwidth, phyDr * 1000, 0, 5, false, true, 0, 0, false, 4000 );
 8037562:	e9cd 5207 	strd	r5, r2, [sp, #28]
 8037566:	e9cd 5505 	strd	r5, r5, [sp, #20]
    if( txConfig->Datarate == DR_7 )
 803756a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 803756c:	d12c      	bne.n	80375c8 <RegionEU868TxConfig+0xdc>
        Radio.SetTxConfig( modem, phyTxPower, 25000, bandwidth, phyDr * 1000, 0, 5, false, true, 0, 0, false, 4000 );
 803756e:	2201      	movs	r2, #1
 8037570:	e9cd 5203 	strd	r5, r2, [sp, #12]
 8037574:	2205      	movs	r2, #5
 8037576:	e9cd 5201 	strd	r5, r2, [sp, #4]
 803757a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 803757e:	4353      	muls	r3, r2
 8037580:	9300      	str	r3, [sp, #0]
 8037582:	f246 12a8 	movw	r2, #25000	; 0x61a8
 8037586:	465b      	mov	r3, fp
 8037588:	4651      	mov	r1, sl
 803758a:	4628      	mov	r0, r5
 803758c:	4666      	mov	r6, ip
 803758e:	47b0      	blx	r6
    {
        modem = MODEM_LORA;
        Radio.SetTxConfig( modem, phyTxPower, 0, bandwidth, phyDr, 1, 8, false, true, 0, 0, false, 4000 );
    }
    /* ST_WORKAROUND_BEGIN: Print Tx config */
    RegionCommonTxConfigPrint(RegionNvmGroup2->Channels[txConfig->Channel].Frequency, txConfig->Datarate);
 8037590:	7821      	ldrb	r1, [r4, #0]
 8037592:	683a      	ldr	r2, [r7, #0]
 8037594:	230c      	movs	r3, #12
 8037596:	434b      	muls	r3, r1
 8037598:	f994 1001 	ldrsb.w	r1, [r4, #1]
 803759c:	58d0      	ldr	r0, [r2, r3]
 803759e:	f7ff fd11 	bl	8036fc4 <RegionCommonTxConfigPrint>
    /* ST_WORKAROUND_END */

    // Update time-on-air
    *txTimeOnAir = GetTimeOnAir( txConfig->Datarate, txConfig->PktLen );
 80375a2:	89a1      	ldrh	r1, [r4, #12]
 80375a4:	f994 0001 	ldrsb.w	r0, [r4, #1]
 80375a8:	f7ff fd1a 	bl	8036fe0 <GetTimeOnAir>
 80375ac:	9b0c      	ldr	r3, [sp, #48]	; 0x30

    // Setup maximum payload length of the radio driver
    Radio.SetMaxPayloadLength( modem, txConfig->PktLen );
 80375ae:	7b21      	ldrb	r1, [r4, #12]
    *txTimeOnAir = GetTimeOnAir( txConfig->Datarate, txConfig->PktLen );
 80375b0:	6018      	str	r0, [r3, #0]
    Radio.SetMaxPayloadLength( modem, txConfig->PktLen );
 80375b2:	f8d8 3054 	ldr.w	r3, [r8, #84]	; 0x54
 80375b6:	4628      	mov	r0, r5
 80375b8:	4798      	blx	r3

    *txPower = txPowerLimited;
 80375ba:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    return true;
#else
    return false;
#endif /* REGION_EU868 */
}
 80375bc:	2001      	movs	r0, #1
    *txPower = txPowerLimited;
 80375be:	f883 9000 	strb.w	r9, [r3]
}
 80375c2:	b00f      	add	sp, #60	; 0x3c
 80375c4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        Radio.SetTxConfig( modem, phyTxPower, 0, bandwidth, phyDr, 1, 8, false, true, 0, 0, false, 4000 );
 80375c8:	2601      	movs	r6, #1
 80375ca:	2208      	movs	r2, #8
 80375cc:	e9cd 5603 	strd	r5, r6, [sp, #12]
 80375d0:	e9cd 6201 	strd	r6, r2, [sp, #4]
 80375d4:	9300      	str	r3, [sp, #0]
 80375d6:	462a      	mov	r2, r5
 80375d8:	465b      	mov	r3, fp
 80375da:	4665      	mov	r5, ip
 80375dc:	4651      	mov	r1, sl
 80375de:	4630      	mov	r0, r6
 80375e0:	47a8      	blx	r5
        modem = MODEM_LORA;
 80375e2:	4635      	mov	r5, r6
 80375e4:	e7d4      	b.n	8037590 <RegionEU868TxConfig+0xa4>
 80375e6:	bf00      	nop
 80375e8:	20005728 	.word	0x20005728
 80375ec:	0803ba9c 	.word	0x0803ba9c
 80375f0:	0803bbd8 	.word	0x0803bbd8

080375f4 <RegionEU868LinkAdrReq>:

uint8_t RegionEU868LinkAdrReq( LinkAdrReqParams_t* linkAdrReq, int8_t* drOut, int8_t* txPowOut, uint8_t* nbRepOut, uint8_t* nbBytesParsed )
{
 80375f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80375f8:	b08d      	sub	sp, #52	; 0x34
    uint8_t status = 0x07;
#if defined( REGION_EU868 )
    RegionCommonLinkAdrParams_t linkAdrParams = { 0 };
 80375fa:	2400      	movs	r4, #0
{
 80375fc:	4605      	mov	r5, r0
 80375fe:	468a      	mov	sl, r1
 8037600:	4691      	mov	r9, r2
 8037602:	4698      	mov	r8, r3
    RegionCommonLinkAdrParams_t linkAdrParams = { 0 };
 8037604:	9402      	str	r4, [sp, #8]
 8037606:	f8ad 400c 	strh.w	r4, [sp, #12]
    uint8_t nextIndex = 0;
    uint8_t bytesProcessed = 0;
    uint16_t chMask = 0;
 803760a:	f8ad 4006 	strh.w	r4, [sp, #6]
    uint8_t status = 0x07;
 803760e:	2607      	movs	r6, #7
            {
                if( linkAdrParams.ChMaskCtrl == 6 )
                {
                    if( RegionNvmGroup2->Channels[i].Frequency != 0 )
                    {
                        chMask |= 1 << i;
 8037610:	f04f 0b01 	mov.w	fp, #1
    while( bytesProcessed < linkAdrReq->PayloadSize )
 8037614:	7a2b      	ldrb	r3, [r5, #8]
 8037616:	42a3      	cmp	r3, r4
 8037618:	d906      	bls.n	8037628 <RegionEU868LinkAdrReq+0x34>
        nextIndex = RegionCommonParseLinkAdrReq( &( linkAdrReq->Payload[bytesProcessed] ), &linkAdrParams );
 803761a:	6868      	ldr	r0, [r5, #4]
 803761c:	a902      	add	r1, sp, #8
 803761e:	4420      	add	r0, r4
 8037620:	f7ff fb32 	bl	8036c88 <RegionCommonParseLinkAdrReq>
        if( nextIndex == 0 )
 8037624:	2800      	cmp	r0, #0
 8037626:	d154      	bne.n	80376d2 <RegionEU868LinkAdrReq+0xde>
    getPhy.Attribute = PHY_MIN_TX_DR;
    getPhy.UplinkDwellTime = linkAdrReq->UplinkDwellTime;
    phyParam = RegionEU868GetPhyParam( &getPhy );

    linkAdrVerifyParams.Status = status;
    linkAdrVerifyParams.AdrEnabled = linkAdrReq->AdrEnabled;
 8037628:	7aab      	ldrb	r3, [r5, #10]
 803762a:	f88d 3015 	strb.w	r3, [sp, #21]
    linkAdrVerifyParams.Datarate = linkAdrParams.Datarate;
 803762e:	f89d 3009 	ldrb.w	r3, [sp, #9]
 8037632:	f88d 3016 	strb.w	r3, [sp, #22]
    linkAdrVerifyParams.TxPower = linkAdrParams.TxPower;
 8037636:	f89d 300a 	ldrb.w	r3, [sp, #10]
 803763a:	f88d 3017 	strb.w	r3, [sp, #23]
    linkAdrVerifyParams.NbRep = linkAdrParams.NbRep;
 803763e:	f89d 3008 	ldrb.w	r3, [sp, #8]
 8037642:	f88d 3018 	strb.w	r3, [sp, #24]
    linkAdrVerifyParams.CurrentDatarate = linkAdrReq->CurrentDatarate;
 8037646:	7aeb      	ldrb	r3, [r5, #11]
 8037648:	f88d 3019 	strb.w	r3, [sp, #25]
    linkAdrVerifyParams.CurrentTxPower = linkAdrReq->CurrentTxPower;
 803764c:	7b2b      	ldrb	r3, [r5, #12]
 803764e:	f88d 301a 	strb.w	r3, [sp, #26]
    linkAdrVerifyParams.CurrentNbRep = linkAdrReq->CurrentNbRep;
 8037652:	7b6b      	ldrb	r3, [r5, #13]
 8037654:	f88d 301b 	strb.w	r3, [sp, #27]
    linkAdrVerifyParams.NbChannels = EU868_MAX_NB_CHANNELS;
 8037658:	2310      	movs	r3, #16
    linkAdrVerifyParams.Status = status;
 803765a:	f88d 6014 	strb.w	r6, [sp, #20]
    linkAdrVerifyParams.NbChannels = EU868_MAX_NB_CHANNELS;
 803765e:	f88d 301c 	strb.w	r3, [sp, #28]
    linkAdrVerifyParams.ChannelsMask = &chMask;
    linkAdrVerifyParams.MinDatarate = ( int8_t )phyParam.Value;
    linkAdrVerifyParams.MaxDatarate = EU868_TX_MAX_DATARATE;
    linkAdrVerifyParams.Channels = RegionNvmGroup2->Channels;
 8037662:	4e3a      	ldr	r6, [pc, #232]	; (803774c <RegionEU868LinkAdrReq+0x158>)
    linkAdrVerifyParams.ChannelsMask = &chMask;
 8037664:	f10d 0306 	add.w	r3, sp, #6
 8037668:	9308      	str	r3, [sp, #32]
    linkAdrVerifyParams.MinDatarate = ( int8_t )phyParam.Value;
 803766a:	f44f 63e0 	mov.w	r3, #1792	; 0x700
 803766e:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
    linkAdrVerifyParams.Channels = RegionNvmGroup2->Channels;
 8037672:	6833      	ldr	r3, [r6, #0]
 8037674:	930a      	str	r3, [sp, #40]	; 0x28
    linkAdrVerifyParams.MinTxPower = EU868_MIN_TX_POWER;
 8037676:	2307      	movs	r3, #7
 8037678:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
    linkAdrVerifyParams.MaxTxPower = EU868_MAX_TX_POWER;
    linkAdrVerifyParams.Version = linkAdrReq->Version;
 803767c:	682b      	ldr	r3, [r5, #0]
 803767e:	9304      	str	r3, [sp, #16]

    // Verify the parameters and update, if necessary
    status = RegionCommonLinkAdrReqVerifyParams( &linkAdrVerifyParams, &linkAdrParams.Datarate, &linkAdrParams.TxPower, &linkAdrParams.NbRep );
 8037680:	f10d 020a 	add.w	r2, sp, #10
 8037684:	ab02      	add	r3, sp, #8
 8037686:	f10d 0109 	add.w	r1, sp, #9
 803768a:	a804      	add	r0, sp, #16
 803768c:	f7ff fb16 	bl	8036cbc <RegionCommonLinkAdrReqVerifyParams>

    // Update channelsMask if everything is correct
    if( status == 0x07 )
 8037690:	2807      	cmp	r0, #7
    status = RegionCommonLinkAdrReqVerifyParams( &linkAdrVerifyParams, &linkAdrParams.Datarate, &linkAdrParams.TxPower, &linkAdrParams.NbRep );
 8037692:	4605      	mov	r5, r0
    if( status == 0x07 )
 8037694:	d10b      	bne.n	80376ae <RegionEU868LinkAdrReq+0xba>
    {
        // Set the channels mask to a default value
        memset1( ( uint8_t* ) RegionNvmGroup2->ChannelsMask, 0, sizeof( RegionNvmGroup2->ChannelsMask ) );
 8037696:	6830      	ldr	r0, [r6, #0]
 8037698:	220c      	movs	r2, #12
 803769a:	2100      	movs	r1, #0
 803769c:	f500 7058 	add.w	r0, r0, #864	; 0x360
 80376a0:	f001 fc2e 	bl	8038f00 <memset1>
        // Update the channels mask
        RegionNvmGroup2->ChannelsMask[0] = chMask;
 80376a4:	6833      	ldr	r3, [r6, #0]
 80376a6:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 80376aa:	f8a3 2360 	strh.w	r2, [r3, #864]	; 0x360
    }

    // Update status variables
    *drOut = linkAdrParams.Datarate;
 80376ae:	f89d 3009 	ldrb.w	r3, [sp, #9]
 80376b2:	f88a 3000 	strb.w	r3, [sl]
    *txPowOut = linkAdrParams.TxPower;
 80376b6:	f89d 300a 	ldrb.w	r3, [sp, #10]
 80376ba:	f889 3000 	strb.w	r3, [r9]
    *nbRepOut = linkAdrParams.NbRep;
 80376be:	f89d 3008 	ldrb.w	r3, [sp, #8]
 80376c2:	f888 3000 	strb.w	r3, [r8]
    *nbBytesParsed = bytesProcessed;
 80376c6:	9b16      	ldr	r3, [sp, #88]	; 0x58

#endif /* REGION_EU868 */
    return status;
}
 80376c8:	4628      	mov	r0, r5
    *nbBytesParsed = bytesProcessed;
 80376ca:	701c      	strb	r4, [r3, #0]
}
 80376cc:	b00d      	add	sp, #52	; 0x34
 80376ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if( ( linkAdrParams.ChMaskCtrl == 0 ) && ( chMask == 0 ) )
 80376d2:	f89d 300b 	ldrb.w	r3, [sp, #11]
        chMask = linkAdrParams.ChMask;
 80376d6:	f8bd 700c 	ldrh.w	r7, [sp, #12]
 80376da:	f8ad 7006 	strh.w	r7, [sp, #6]
        bytesProcessed += nextIndex;
 80376de:	4404      	add	r4, r0
 80376e0:	b2e4      	uxtb	r4, r4
        if( ( linkAdrParams.ChMaskCtrl == 0 ) && ( chMask == 0 ) )
 80376e2:	b9f3      	cbnz	r3, 8037722 <RegionEU868LinkAdrReq+0x12e>
 80376e4:	b317      	cbz	r7, 803772c <RegionEU868LinkAdrReq+0x138>
                        ( RegionNvmGroup2->Channels[i].Frequency == 0 ) )
 80376e6:	4a19      	ldr	r2, [pc, #100]	; (803774c <RegionEU868LinkAdrReq+0x158>)
 80376e8:	2000      	movs	r0, #0
 80376ea:	6811      	ldr	r1, [r2, #0]
 80376ec:	2607      	movs	r6, #7
 80376ee:	4602      	mov	r2, r0
 80376f0:	f04f 0c0c 	mov.w	ip, #12
                if( linkAdrParams.ChMaskCtrl == 6 )
 80376f4:	2b06      	cmp	r3, #6
 80376f6:	d11b      	bne.n	8037730 <RegionEU868LinkAdrReq+0x13c>
                    if( RegionNvmGroup2->Channels[i].Frequency != 0 )
 80376f8:	fb0c fe00 	mul.w	lr, ip, r0
 80376fc:	f851 e00e 	ldr.w	lr, [r1, lr]
 8037700:	f1be 0f00 	cmp.w	lr, #0
 8037704:	d004      	beq.n	8037710 <RegionEU868LinkAdrReq+0x11c>
                        chMask |= 1 << i;
 8037706:	fa0b f200 	lsl.w	r2, fp, r0
 803770a:	4317      	orrs	r7, r2
 803770c:	b2bf      	uxth	r7, r7
 803770e:	2201      	movs	r2, #1
            for( uint8_t i = 0; i < EU868_MAX_NB_CHANNELS; i++ )
 8037710:	3001      	adds	r0, #1
 8037712:	2810      	cmp	r0, #16
 8037714:	d1ee      	bne.n	80376f4 <RegionEU868LinkAdrReq+0x100>
 8037716:	2a00      	cmp	r2, #0
 8037718:	f43f af7c 	beq.w	8037614 <RegionEU868LinkAdrReq+0x20>
 803771c:	f8ad 7006 	strh.w	r7, [sp, #6]
 8037720:	e778      	b.n	8037614 <RegionEU868LinkAdrReq+0x20>
        else if( ( ( linkAdrParams.ChMaskCtrl >= 1 ) && ( linkAdrParams.ChMaskCtrl <= 5 )) ||
 8037722:	1e5a      	subs	r2, r3, #1
 8037724:	2a04      	cmp	r2, #4
 8037726:	d901      	bls.n	803772c <RegionEU868LinkAdrReq+0x138>
 8037728:	2b06      	cmp	r3, #6
 803772a:	d0dc      	beq.n	80376e6 <RegionEU868LinkAdrReq+0xf2>
            status &= 0xFE; // Channel mask KO
 803772c:	2606      	movs	r6, #6
 803772e:	e771      	b.n	8037614 <RegionEU868LinkAdrReq+0x20>
                    if( ( ( chMask & ( 1 << i ) ) != 0 ) &&
 8037730:	fa47 fe00 	asr.w	lr, r7, r0
 8037734:	f01e 0f01 	tst.w	lr, #1
 8037738:	d0ea      	beq.n	8037710 <RegionEU868LinkAdrReq+0x11c>
                        ( RegionNvmGroup2->Channels[i].Frequency == 0 ) )
 803773a:	fb0c fe00 	mul.w	lr, ip, r0
                    if( ( ( chMask & ( 1 << i ) ) != 0 ) &&
 803773e:	f851 e00e 	ldr.w	lr, [r1, lr]
                        status &= 0xFE; // Channel mask KO
 8037742:	f1be 0f00 	cmp.w	lr, #0
 8037746:	bf08      	it	eq
 8037748:	2606      	moveq	r6, #6
 803774a:	e7e1      	b.n	8037710 <RegionEU868LinkAdrReq+0x11c>
 803774c:	20005728 	.word	0x20005728

08037750 <RegionEU868RxParamSetupReq>:

uint8_t RegionEU868RxParamSetupReq( RxParamSetupReqParams_t* rxParamSetupReq )
{
 8037750:	b573      	push	{r0, r1, r4, r5, r6, lr}
    uint8_t status = 0x07;
#if defined( REGION_EU868 )
    uint8_t band = 0;
 8037752:	2600      	movs	r6, #0
{
 8037754:	4605      	mov	r5, r0

    // Verify radio frequency
    if( VerifyRfFreq( rxParamSetupReq->Frequency, &band ) == false )
 8037756:	f10d 0107 	add.w	r1, sp, #7
 803775a:	6840      	ldr	r0, [r0, #4]
    uint8_t band = 0;
 803775c:	f88d 6007 	strb.w	r6, [sp, #7]
    if( VerifyRfFreq( rxParamSetupReq->Frequency, &band ) == false )
 8037760:	f7ff fc66 	bl	8037030 <VerifyRfFreq>
    {
        status &= 0xFE; // Channel frequency KO
    }

    // Verify datarate
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, EU868_RX_MIN_DATARATE, EU868_RX_MAX_DATARATE ) == false )
 8037764:	2207      	movs	r2, #7
    if( VerifyRfFreq( rxParamSetupReq->Frequency, &band ) == false )
 8037766:	42b0      	cmp	r0, r6
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, EU868_RX_MIN_DATARATE, EU868_RX_MAX_DATARATE ) == false )
 8037768:	4631      	mov	r1, r6
 803776a:	f995 0000 	ldrsb.w	r0, [r5]
        status &= 0xFE; // Channel frequency KO
 803776e:	bf14      	ite	ne
 8037770:	2407      	movne	r4, #7
 8037772:	2406      	moveq	r4, #6
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, EU868_RX_MIN_DATARATE, EU868_RX_MAX_DATARATE ) == false )
 8037774:	f7ff f927 	bl	80369c6 <RegionCommonValueInRange>
 8037778:	b908      	cbnz	r0, 803777e <RegionEU868RxParamSetupReq+0x2e>
    {
        status &= 0xFD; // Datarate KO
 803777a:	f004 0405 	and.w	r4, r4, #5
    }

    // Verify datarate offset
    if( RegionCommonValueInRange( rxParamSetupReq->DrOffset, EU868_MIN_RX1_DR_OFFSET, EU868_MAX_RX1_DR_OFFSET ) == false )
 803777e:	f995 0001 	ldrsb.w	r0, [r5, #1]
 8037782:	2205      	movs	r2, #5
 8037784:	2100      	movs	r1, #0
 8037786:	f7ff f91e 	bl	80369c6 <RegionCommonValueInRange>
 803778a:	b908      	cbnz	r0, 8037790 <RegionEU868RxParamSetupReq+0x40>
    {
        status &= 0xFB; // Rx1DrOffset range KO
 803778c:	f004 04fb 	and.w	r4, r4, #251	; 0xfb
    }

#endif /* REGION_EU868 */
    return status;
}
 8037790:	4620      	mov	r0, r4
 8037792:	b002      	add	sp, #8
 8037794:	bd70      	pop	{r4, r5, r6, pc}

08037796 <RegionEU868TxParamSetupReq>:

int8_t RegionEU868TxParamSetupReq( TxParamSetupReqParams_t* txParamSetupReq )
{
    // Do not accept the request
    return -1;
}
 8037796:	f04f 30ff 	mov.w	r0, #4294967295
 803779a:	4770      	bx	lr

0803779c <RegionEU868DlChannelReq>:

int8_t RegionEU868DlChannelReq( DlChannelReqParams_t* dlChannelReq )
{
 803779c:	b513      	push	{r0, r1, r4, lr}
 803779e:	4604      	mov	r4, r0
    uint8_t status = 0x03;
#if defined( REGION_EU868 )
    uint8_t band = 0;
 80377a0:	2300      	movs	r3, #0

    // Verify if the frequency is supported
    if( VerifyRfFreq( dlChannelReq->Rx1Frequency, &band ) == false )
 80377a2:	f10d 0107 	add.w	r1, sp, #7
 80377a6:	6840      	ldr	r0, [r0, #4]
    uint8_t band = 0;
 80377a8:	f88d 3007 	strb.w	r3, [sp, #7]
    if( VerifyRfFreq( dlChannelReq->Rx1Frequency, &band ) == false )
 80377ac:	f7ff fc40 	bl	8037030 <VerifyRfFreq>
 80377b0:	7823      	ldrb	r3, [r4, #0]
 80377b2:	4a0b      	ldr	r2, [pc, #44]	; (80377e0 <RegionEU868DlChannelReq+0x44>)
 80377b4:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80377b8:	6812      	ldr	r2, [r2, #0]
 80377ba:	eb02 0183 	add.w	r1, r2, r3, lsl #2
    {
        status &= 0xFE;
    }

    // Verify if an uplink frequency exists
    if( RegionNvmGroup2->Channels[dlChannelReq->ChannelId].Frequency == 0 )
 80377be:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    if( VerifyRfFreq( dlChannelReq->Rx1Frequency, &band ) == false )
 80377c2:	2800      	cmp	r0, #0
        status &= 0xFE;
 80377c4:	bf14      	ite	ne
 80377c6:	2003      	movne	r0, #3
 80377c8:	2002      	moveq	r0, #2
    if( RegionNvmGroup2->Channels[dlChannelReq->ChannelId].Frequency == 0 )
 80377ca:	b91b      	cbnz	r3, 80377d4 <RegionEU868DlChannelReq+0x38>
    {
        status &= 0xFD;
 80377cc:	f000 0001 	and.w	r0, r0, #1
        RegionNvmGroup2->Channels[dlChannelReq->ChannelId].Rx1Frequency = dlChannelReq->Rx1Frequency;
    }

#endif /* REGION_EU868 */
    return status;
}
 80377d0:	b002      	add	sp, #8
 80377d2:	bd10      	pop	{r4, pc}
    if( status == 0x03 )
 80377d4:	2803      	cmp	r0, #3
        RegionNvmGroup2->Channels[dlChannelReq->ChannelId].Rx1Frequency = dlChannelReq->Rx1Frequency;
 80377d6:	bf06      	itte	eq
 80377d8:	6863      	ldreq	r3, [r4, #4]
 80377da:	604b      	streq	r3, [r1, #4]
 80377dc:	2002      	movne	r0, #2
 80377de:	e7f7      	b.n	80377d0 <RegionEU868DlChannelReq+0x34>
 80377e0:	20005728 	.word	0x20005728

080377e4 <RegionEU868AlternateDr>:
#if defined( REGION_EU868 )
    return currentDr;
#else
    return -1;
#endif /* REGION_EU868 */
}
 80377e4:	4770      	bx	lr
	...

080377e8 <RegionEU868NextChannel>:

LoRaMacStatus_t RegionEU868NextChannel( NextChanParams_t* nextChanParams, uint8_t* channel, TimerTime_t* time, TimerTime_t* aggregatedTimeOff )
{
 80377e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    RegionCommonIdentifyChannelsParam_t identifyChannelsParam;
    RegionCommonCountNbOfEnabledChannelsParams_t countChannelsParams;
    LoRaMacStatus_t status = LORAMAC_STATUS_NO_CHANNEL_FOUND;
    uint16_t joinChannels = EU868_JOIN_CHANNELS;

    if( RegionCommonCountChannels( RegionNvmGroup2->ChannelsMask, 0, 1 ) == 0 )
 80377ec:	4d38      	ldr	r5, [pc, #224]	; (80378d0 <RegionEU868NextChannel+0xe8>)
{
 80377ee:	4604      	mov	r4, r0
    if( RegionCommonCountChannels( RegionNvmGroup2->ChannelsMask, 0, 1 ) == 0 )
 80377f0:	6828      	ldr	r0, [r5, #0]
{
 80377f2:	b096      	sub	sp, #88	; 0x58
 80377f4:	460e      	mov	r6, r1
 80377f6:	4690      	mov	r8, r2
    uint8_t nbEnabledChannels = 0;
 80377f8:	2100      	movs	r1, #0
{
 80377fa:	461f      	mov	r7, r3
    if( RegionCommonCountChannels( RegionNvmGroup2->ChannelsMask, 0, 1 ) == 0 )
 80377fc:	2201      	movs	r2, #1
    uint16_t joinChannels = EU868_JOIN_CHANNELS;
 80377fe:	2307      	movs	r3, #7
    if( RegionCommonCountChannels( RegionNvmGroup2->ChannelsMask, 0, 1 ) == 0 )
 8037800:	f500 7058 	add.w	r0, r0, #864	; 0x360
    uint8_t enabledChannels[EU868_MAX_NB_CHANNELS] = { 0 };
 8037804:	e9cd 1104 	strd	r1, r1, [sp, #16]
 8037808:	e9cd 1106 	strd	r1, r1, [sp, #24]
    uint8_t nbEnabledChannels = 0;
 803780c:	f88d 100c 	strb.w	r1, [sp, #12]
    uint8_t nbRestrictedChannels = 0;
 8037810:	f88d 100d 	strb.w	r1, [sp, #13]
    uint16_t joinChannels = EU868_JOIN_CHANNELS;
 8037814:	f8ad 300e 	strh.w	r3, [sp, #14]
    if( RegionCommonCountChannels( RegionNvmGroup2->ChannelsMask, 0, 1 ) == 0 )
 8037818:	f7ff f8f7 	bl	8036a0a <RegionCommonCountChannels>
 803781c:	b930      	cbnz	r0, 803782c <RegionEU868NextChannel+0x44>
    { // Reactivate default channels
        RegionNvmGroup2->ChannelsMask[0] |= LC( 1 ) + LC( 2 ) + LC( 3 );
 803781e:	682a      	ldr	r2, [r5, #0]
 8037820:	f8b2 3360 	ldrh.w	r3, [r2, #864]	; 0x360
 8037824:	f043 0307 	orr.w	r3, r3, #7
 8037828:	f8a2 3360 	strh.w	r3, [r2, #864]	; 0x360
    }

    // Search how many channels are enabled
    countChannelsParams.Joined = nextChanParams->Joined;
    countChannelsParams.Datarate = nextChanParams->Datarate;
    countChannelsParams.ChannelsMask = RegionNvmGroup2->ChannelsMask;
 803782c:	682a      	ldr	r2, [r5, #0]
    countChannelsParams.Joined = nextChanParams->Joined;
 803782e:	7a63      	ldrb	r3, [r4, #9]
 8037830:	f88d 3020 	strb.w	r3, [sp, #32]
    countChannelsParams.ChannelsMask = RegionNvmGroup2->ChannelsMask;
 8037834:	f502 7158 	add.w	r1, r2, #864	; 0x360
    countChannelsParams.Channels = RegionNvmGroup2->Channels;
 8037838:	e9cd 1209 	strd	r1, r2, [sp, #36]	; 0x24
    countChannelsParams.Bands = RegionNvmGroup1->Bands;
 803783c:	686a      	ldr	r2, [r5, #4]
 803783e:	920b      	str	r2, [sp, #44]	; 0x2c
    countChannelsParams.MaxNbChannels = EU868_MAX_NB_CHANNELS;
 8037840:	2210      	movs	r2, #16
 8037842:	f8ad 2030 	strh.w	r2, [sp, #48]	; 0x30
    countChannelsParams.JoinChannels = &joinChannels;
 8037846:	f10d 020e 	add.w	r2, sp, #14
 803784a:	920d      	str	r2, [sp, #52]	; 0x34

    identifyChannelsParam.AggrTimeOff = nextChanParams->AggrTimeOff;
 803784c:	6822      	ldr	r2, [r4, #0]
 803784e:	920e      	str	r2, [sp, #56]	; 0x38
    identifyChannelsParam.LastAggrTx = nextChanParams->LastAggrTx;
 8037850:	6862      	ldr	r2, [r4, #4]
 8037852:	920f      	str	r2, [sp, #60]	; 0x3c
    identifyChannelsParam.DutyCycleEnabled = nextChanParams->DutyCycleEnabled;
    identifyChannelsParam.MaxBands = EU868_MAX_NB_BANDS;

    identifyChannelsParam.ElapsedTimeSinceStartUp = nextChanParams->ElapsedTimeSinceStartUp;
 8037854:	e9d4 0103 	ldrd	r0, r1, [r4, #12]
    identifyChannelsParam.DutyCycleEnabled = nextChanParams->DutyCycleEnabled;
 8037858:	7aa2      	ldrb	r2, [r4, #10]
    countChannelsParams.Datarate = nextChanParams->Datarate;
 803785a:	f994 3008 	ldrsb.w	r3, [r4, #8]
    identifyChannelsParam.DutyCycleEnabled = nextChanParams->DutyCycleEnabled;
 803785e:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
    identifyChannelsParam.MaxBands = EU868_MAX_NB_BANDS;
 8037862:	2206      	movs	r2, #6
 8037864:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
    identifyChannelsParam.ElapsedTimeSinceStartUp = nextChanParams->ElapsedTimeSinceStartUp;
 8037868:	aa11      	add	r2, sp, #68	; 0x44
 803786a:	e882 0003 	stmia.w	r2, {r0, r1}
    identifyChannelsParam.LastTxIsJoinRequest = nextChanParams->LastTxIsJoinRequest;
 803786e:	7d22      	ldrb	r2, [r4, #20]
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 8037870:	8ae1      	ldrh	r1, [r4, #22]
    countChannelsParams.Datarate = nextChanParams->Datarate;
 8037872:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 8037876:	4618      	mov	r0, r3
    identifyChannelsParam.LastTxIsJoinRequest = nextChanParams->LastTxIsJoinRequest;
 8037878:	f88d 204c 	strb.w	r2, [sp, #76]	; 0x4c
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 803787c:	f7ff fbb0 	bl	8036fe0 <GetTimeOnAir>

    identifyChannelsParam.CountNbOfEnabledChannelsParam = &countChannelsParams;
 8037880:	ab08      	add	r3, sp, #32
 8037882:	9315      	str	r3, [sp, #84]	; 0x54

    status = RegionCommonIdentifyChannels( &identifyChannelsParam, aggregatedTimeOff, enabledChannels,
 8037884:	f10d 030d 	add.w	r3, sp, #13
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 8037888:	9014      	str	r0, [sp, #80]	; 0x50
    status = RegionCommonIdentifyChannels( &identifyChannelsParam, aggregatedTimeOff, enabledChannels,
 803788a:	9300      	str	r3, [sp, #0]
 803788c:	f8cd 8004 	str.w	r8, [sp, #4]
 8037890:	ab03      	add	r3, sp, #12
 8037892:	aa04      	add	r2, sp, #16
 8037894:	4639      	mov	r1, r7
 8037896:	a80e      	add	r0, sp, #56	; 0x38
 8037898:	f7ff faf1 	bl	8036e7e <RegionCommonIdentifyChannels>
                                           &nbEnabledChannels, &nbRestrictedChannels, time );

    if( status == LORAMAC_STATUS_OK )
 803789c:	4604      	mov	r4, r0
 803789e:	b968      	cbnz	r0, 80378bc <RegionEU868NextChannel+0xd4>
    {
        // We found a valid channel
        *channel = enabledChannels[randr( 0, nbEnabledChannels - 1 )];
 80378a0:	f89d 100c 	ldrb.w	r1, [sp, #12]
 80378a4:	3901      	subs	r1, #1
 80378a6:	f001 fafb 	bl	8038ea0 <randr>
 80378aa:	ab16      	add	r3, sp, #88	; 0x58
 80378ac:	4418      	add	r0, r3
 80378ae:	f810 3c48 	ldrb.w	r3, [r0, #-72]
 80378b2:	7033      	strb	r3, [r6, #0]
    }
    return status;
#else
    return LORAMAC_STATUS_NO_CHANNEL_FOUND;
#endif /* REGION_EU868 */
}
 80378b4:	4620      	mov	r0, r4
 80378b6:	b016      	add	sp, #88	; 0x58
 80378b8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    else if( status == LORAMAC_STATUS_NO_CHANNEL_FOUND )
 80378bc:	280c      	cmp	r0, #12
        RegionNvmGroup2->ChannelsMask[0] |= LC( 1 ) + LC( 2 ) + LC( 3 );
 80378be:	bf01      	itttt	eq
 80378c0:	682a      	ldreq	r2, [r5, #0]
 80378c2:	f8b2 3360 	ldrheq.w	r3, [r2, #864]	; 0x360
 80378c6:	f043 0307 	orreq.w	r3, r3, #7
 80378ca:	f8a2 3360 	strheq.w	r3, [r2, #864]	; 0x360
 80378ce:	e7f1      	b.n	80378b4 <RegionEU868NextChannel+0xcc>
 80378d0:	20005728 	.word	0x20005728

080378d4 <RegionEU868ChannelAdd>:

LoRaMacStatus_t RegionEU868ChannelAdd( ChannelAddParams_t* channelAdd )
{
 80378d4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
#if defined( REGION_EU868 )
    uint8_t band = 0;
    bool drInvalid = false;
    bool freqInvalid = false;
    uint8_t id = channelAdd->ChannelId;
 80378d6:	7906      	ldrb	r6, [r0, #4]
    uint8_t band = 0;
 80378d8:	2700      	movs	r7, #0

    if( id < EU868_NUMB_DEFAULT_CHANNELS )
 80378da:	2e02      	cmp	r6, #2
{
 80378dc:	4605      	mov	r5, r0
    uint8_t band = 0;
 80378de:	f88d 7007 	strb.w	r7, [sp, #7]
    if( id < EU868_NUMB_DEFAULT_CHANNELS )
 80378e2:	d802      	bhi.n	80378ea <RegionEU868ChannelAdd+0x16>
    {
        return LORAMAC_STATUS_FREQ_AND_DR_INVALID;
 80378e4:	2006      	movs	r0, #6
    RegionNvmGroup2->ChannelsMask[0] |= ( 1 << id );
    return LORAMAC_STATUS_OK;
#else
    return LORAMAC_STATUS_NO_CHANNEL_FOUND;
#endif /* REGION_EU868 */
}
 80378e6:	b003      	add	sp, #12
 80378e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if( id >= EU868_MAX_NB_CHANNELS )
 80378ea:	2e0f      	cmp	r6, #15
 80378ec:	d82d      	bhi.n	803794a <RegionEU868ChannelAdd+0x76>
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Min, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 80378ee:	6803      	ldr	r3, [r0, #0]
 80378f0:	7a18      	ldrb	r0, [r3, #8]
 80378f2:	f340 0003 	sbfx	r0, r0, #0, #4
 80378f6:	2207      	movs	r2, #7
 80378f8:	4639      	mov	r1, r7
 80378fa:	b240      	sxtb	r0, r0
 80378fc:	f7ff f863 	bl	80369c6 <RegionCommonValueInRange>
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Max, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 8037900:	682b      	ldr	r3, [r5, #0]
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Min, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 8037902:	4604      	mov	r4, r0
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Max, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 8037904:	7a18      	ldrb	r0, [r3, #8]
 8037906:	f340 1003 	sbfx	r0, r0, #4, #4
 803790a:	2207      	movs	r2, #7
 803790c:	4639      	mov	r1, r7
 803790e:	b240      	sxtb	r0, r0
 8037910:	f7ff f859 	bl	80369c6 <RegionCommonValueInRange>
 8037914:	b1b8      	cbz	r0, 8037946 <RegionEU868ChannelAdd+0x72>
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Min, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 8037916:	fab4 f484 	clz	r4, r4
 803791a:	0964      	lsrs	r4, r4, #5
    if( channelAdd->NewChannel->DrRange.Fields.Min > channelAdd->NewChannel->DrRange.Fields.Max )
 803791c:	6828      	ldr	r0, [r5, #0]
 803791e:	7a03      	ldrb	r3, [r0, #8]
        if( VerifyRfFreq( channelAdd->NewChannel->Frequency, &band ) == false )
 8037920:	6800      	ldr	r0, [r0, #0]
    if( channelAdd->NewChannel->DrRange.Fields.Min > channelAdd->NewChannel->DrRange.Fields.Max )
 8037922:	f343 0203 	sbfx	r2, r3, #0, #4
 8037926:	f343 1303 	sbfx	r3, r3, #4, #4
 803792a:	b252      	sxtb	r2, r2
 803792c:	b25b      	sxtb	r3, r3
        if( VerifyRfFreq( channelAdd->NewChannel->Frequency, &band ) == false )
 803792e:	f10d 0107 	add.w	r1, sp, #7
        drInvalid = true;
 8037932:	429a      	cmp	r2, r3
 8037934:	bfc8      	it	gt
 8037936:	2401      	movgt	r4, #1
        if( VerifyRfFreq( channelAdd->NewChannel->Frequency, &band ) == false )
 8037938:	f7ff fb7a 	bl	8037030 <VerifyRfFreq>
 803793c:	b948      	cbnz	r0, 8037952 <RegionEU868ChannelAdd+0x7e>
    if( ( drInvalid == true ) && ( freqInvalid == true ) )
 803793e:	2c00      	cmp	r4, #0
 8037940:	d1d0      	bne.n	80378e4 <RegionEU868ChannelAdd+0x10>
        return LORAMAC_STATUS_FREQUENCY_INVALID;
 8037942:	2004      	movs	r0, #4
 8037944:	e7cf      	b.n	80378e6 <RegionEU868ChannelAdd+0x12>
        drInvalid = true;
 8037946:	2401      	movs	r4, #1
 8037948:	e7e8      	b.n	803791c <RegionEU868ChannelAdd+0x48>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 803794a:	2003      	movs	r0, #3
 803794c:	e7cb      	b.n	80378e6 <RegionEU868ChannelAdd+0x12>
        return LORAMAC_STATUS_DATARATE_INVALID;
 803794e:	2005      	movs	r0, #5
 8037950:	e7c9      	b.n	80378e6 <RegionEU868ChannelAdd+0x12>
    if( ( drInvalid == true ) && ( freqInvalid == true ) )
 8037952:	2c00      	cmp	r4, #0
 8037954:	d1fb      	bne.n	803794e <RegionEU868ChannelAdd+0x7a>
    memcpy1( ( uint8_t* ) &(RegionNvmGroup2->Channels[id]), ( uint8_t* ) channelAdd->NewChannel, sizeof( RegionNvmGroup2->Channels[id] ) );
 8037956:	4f0d      	ldr	r7, [pc, #52]	; (803798c <RegionEU868ChannelAdd+0xb8>)
 8037958:	6829      	ldr	r1, [r5, #0]
 803795a:	683b      	ldr	r3, [r7, #0]
 803795c:	eb06 0046 	add.w	r0, r6, r6, lsl #1
 8037960:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8037964:	220c      	movs	r2, #12
 8037966:	f001 fab7 	bl	8038ed8 <memcpy1>
    RegionNvmGroup2->Channels[id].Band = band;
 803796a:	683a      	ldr	r2, [r7, #0]
 803796c:	f89d 1007 	ldrb.w	r1, [sp, #7]
 8037970:	230c      	movs	r3, #12
 8037972:	fb03 2306 	mla	r3, r3, r6, r2
    return LORAMAC_STATUS_OK;
 8037976:	4620      	mov	r0, r4
    RegionNvmGroup2->Channels[id].Band = band;
 8037978:	7259      	strb	r1, [r3, #9]
    RegionNvmGroup2->ChannelsMask[0] |= ( 1 << id );
 803797a:	2301      	movs	r3, #1
 803797c:	fa03 f606 	lsl.w	r6, r3, r6
 8037980:	f8b2 3360 	ldrh.w	r3, [r2, #864]	; 0x360
 8037984:	431e      	orrs	r6, r3
 8037986:	f8a2 6360 	strh.w	r6, [r2, #864]	; 0x360
    return LORAMAC_STATUS_OK;
 803798a:	e7ac      	b.n	80378e6 <RegionEU868ChannelAdd+0x12>
 803798c:	20005728 	.word	0x20005728

08037990 <RegionEU868ChannelsRemove>:

bool RegionEU868ChannelsRemove( ChannelRemoveParams_t* channelRemove  )
{
 8037990:	b410      	push	{r4}
#if defined( REGION_EU868 )
    uint8_t id = channelRemove->ChannelId;
 8037992:	7801      	ldrb	r1, [r0, #0]

    if( id < EU868_NUMB_DEFAULT_CHANNELS )
 8037994:	2902      	cmp	r1, #2
 8037996:	d90e      	bls.n	80379b6 <RegionEU868ChannelsRemove+0x26>
    {
        return false;
    }

    // Remove the channel from the list of channels
    RegionNvmGroup2->Channels[id] = ( ChannelParams_t ){ 0, 0, { 0 }, 0 };
 8037998:	4b08      	ldr	r3, [pc, #32]	; (80379bc <RegionEU868ChannelsRemove+0x2c>)
 803799a:	6818      	ldr	r0, [r3, #0]
 803799c:	230c      	movs	r3, #12
 803799e:	434b      	muls	r3, r1
 80379a0:	18c4      	adds	r4, r0, r3
 80379a2:	2200      	movs	r2, #0
 80379a4:	50c2      	str	r2, [r0, r3]
 80379a6:	e9c4 2201 	strd	r2, r2, [r4, #4]

    return RegionCommonChanDisable( RegionNvmGroup2->ChannelsMask, id, EU868_MAX_NB_CHANNELS );
 80379aa:	f500 7058 	add.w	r0, r0, #864	; 0x360
#else
    return false;
#endif /* REGION_EU868 */
}
 80379ae:	bc10      	pop	{r4}
    return RegionCommonChanDisable( RegionNvmGroup2->ChannelsMask, id, EU868_MAX_NB_CHANNELS );
 80379b0:	2210      	movs	r2, #16
 80379b2:	f7ff b811 	b.w	80369d8 <RegionCommonChanDisable>
}
 80379b6:	2000      	movs	r0, #0
 80379b8:	bc10      	pop	{r4}
 80379ba:	4770      	bx	lr
 80379bc:	20005728 	.word	0x20005728

080379c0 <RegionEU868ApplyCFList>:
{
 80379c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80379c4:	b086      	sub	sp, #24
    newChannel.DrRange.Value = ( DR_5 << 4 ) | DR_0;
 80379c6:	2350      	movs	r3, #80	; 0x50
 80379c8:	f88d 3014 	strb.w	r3, [sp, #20]
    if( applyCFList->Size != 16 )
 80379cc:	7903      	ldrb	r3, [r0, #4]
 80379ce:	2b10      	cmp	r3, #16
{
 80379d0:	4607      	mov	r7, r0
    if( applyCFList->Size != 16 )
 80379d2:	d130      	bne.n	8037a36 <RegionEU868ApplyCFList+0x76>
    if( applyCFList->Payload[15] != 0 )
 80379d4:	6803      	ldr	r3, [r0, #0]
 80379d6:	7bdd      	ldrb	r5, [r3, #15]
 80379d8:	bb6d      	cbnz	r5, 8037a36 <RegionEU868ApplyCFList+0x76>
    for( uint8_t i = 0, chanIdx = EU868_NUMB_DEFAULT_CHANNELS; chanIdx < EU868_MAX_NB_CHANNELS; i+=3, chanIdx++ )
 80379da:	2403      	movs	r4, #3
            newChannel.Frequency = 0;
 80379dc:	46a8      	mov	r8, r5
            newChannel.Frequency *= 100;
 80379de:	2664      	movs	r6, #100	; 0x64
        if( chanIdx < ( EU868_NUMB_CHANNELS_CF_LIST + EU868_NUMB_DEFAULT_CHANNELS ) )
 80379e0:	2c07      	cmp	r4, #7
 80379e2:	d814      	bhi.n	8037a0e <RegionEU868ApplyCFList+0x4e>
            newChannel.Frequency = (uint32_t) applyCFList->Payload[i];
 80379e4:	683a      	ldr	r2, [r7, #0]
 80379e6:	5d53      	ldrb	r3, [r2, r5]
 80379e8:	9303      	str	r3, [sp, #12]
            newChannel.Frequency |= ( (uint32_t) applyCFList->Payload[i + 1] << 8 );
 80379ea:	442a      	add	r2, r5
 80379ec:	7851      	ldrb	r1, [r2, #1]
 80379ee:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 80379f2:	9303      	str	r3, [sp, #12]
            newChannel.Frequency |= ( (uint32_t) applyCFList->Payload[i + 2] << 16 );
 80379f4:	7892      	ldrb	r2, [r2, #2]
 80379f6:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
            newChannel.Frequency *= 100;
 80379fa:	4373      	muls	r3, r6
            newChannel.Rx1Frequency = 0;
 80379fc:	e9cd 3803 	strd	r3, r8, [sp, #12]
        if( newChannel.Frequency != 0 )
 8037a00:	b963      	cbnz	r3, 8037a1c <RegionEU868ApplyCFList+0x5c>
            RegionEU868ChannelsRemove( &channelRemove );
 8037a02:	4668      	mov	r0, sp
            channelRemove.ChannelId = chanIdx;
 8037a04:	f88d 4000 	strb.w	r4, [sp]
            RegionEU868ChannelsRemove( &channelRemove );
 8037a08:	f7ff ffc2 	bl	8037990 <RegionEU868ChannelsRemove>
 8037a0c:	e00d      	b.n	8037a2a <RegionEU868ApplyCFList+0x6a>
            newChannel.Frequency = 0;
 8037a0e:	f8cd 800c 	str.w	r8, [sp, #12]
            newChannel.DrRange.Value = 0;
 8037a12:	f88d 8014 	strb.w	r8, [sp, #20]
            newChannel.Rx1Frequency = 0;
 8037a16:	f8cd 8010 	str.w	r8, [sp, #16]
        if( newChannel.Frequency != 0 )
 8037a1a:	e7f2      	b.n	8037a02 <RegionEU868ApplyCFList+0x42>
            channelAdd.NewChannel = &newChannel;
 8037a1c:	ab03      	add	r3, sp, #12
            RegionEU868ChannelAdd( &channelAdd );
 8037a1e:	a801      	add	r0, sp, #4
            channelAdd.NewChannel = &newChannel;
 8037a20:	9301      	str	r3, [sp, #4]
            channelAdd.ChannelId = chanIdx;
 8037a22:	f88d 4008 	strb.w	r4, [sp, #8]
            RegionEU868ChannelAdd( &channelAdd );
 8037a26:	f7ff ff55 	bl	80378d4 <RegionEU868ChannelAdd>
    for( uint8_t i = 0, chanIdx = EU868_NUMB_DEFAULT_CHANNELS; chanIdx < EU868_MAX_NB_CHANNELS; i+=3, chanIdx++ )
 8037a2a:	3401      	adds	r4, #1
 8037a2c:	b2e4      	uxtb	r4, r4
 8037a2e:	2c10      	cmp	r4, #16
 8037a30:	f105 0503 	add.w	r5, r5, #3
 8037a34:	d1d4      	bne.n	80379e0 <RegionEU868ApplyCFList+0x20>
}
 8037a36:	b006      	add	sp, #24
 8037a38:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08037a3c <RegionEU868NewChannelReq>:
{
 8037a3c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    if( newChannelReq->NewChannel->Frequency == 0 )
 8037a3e:	6802      	ldr	r2, [r0, #0]
 8037a40:	7903      	ldrb	r3, [r0, #4]
 8037a42:	6811      	ldr	r1, [r2, #0]
 8037a44:	b951      	cbnz	r1, 8037a5c <RegionEU868NewChannelReq+0x20>
        if( RegionEU868ChannelsRemove( &channelRemove ) == false )
 8037a46:	a801      	add	r0, sp, #4
        channelRemove.ChannelId = newChannelReq->ChannelId;
 8037a48:	f88d 3004 	strb.w	r3, [sp, #4]
        if( RegionEU868ChannelsRemove( &channelRemove ) == false )
 8037a4c:	f7ff ffa0 	bl	8037990 <RegionEU868ChannelsRemove>
 8037a50:	b988      	cbnz	r0, 8037a76 <RegionEU868NewChannelReq+0x3a>
            status &= 0xFC;
 8037a52:	2000      	movs	r0, #0
}
 8037a54:	b240      	sxtb	r0, r0
 8037a56:	b005      	add	sp, #20
 8037a58:	f85d fb04 	ldr.w	pc, [sp], #4
        switch( RegionEU868ChannelAdd( &channelAdd ) )
 8037a5c:	a802      	add	r0, sp, #8
        channelAdd.NewChannel = newChannelReq->NewChannel;
 8037a5e:	9202      	str	r2, [sp, #8]
        channelAdd.ChannelId = newChannelReq->ChannelId;
 8037a60:	f88d 300c 	strb.w	r3, [sp, #12]
        switch( RegionEU868ChannelAdd( &channelAdd ) )
 8037a64:	f7ff ff36 	bl	80378d4 <RegionEU868ChannelAdd>
 8037a68:	2806      	cmp	r0, #6
 8037a6a:	d8f2      	bhi.n	8037a52 <RegionEU868NewChannelReq+0x16>
 8037a6c:	4b03      	ldr	r3, [pc, #12]	; (8037a7c <RegionEU868NewChannelReq+0x40>)
 8037a6e:	4418      	add	r0, r3
 8037a70:	f890 005c 	ldrb.w	r0, [r0, #92]	; 0x5c
 8037a74:	e7ee      	b.n	8037a54 <RegionEU868NewChannelReq+0x18>
    uint8_t status = 0x03;
 8037a76:	2003      	movs	r0, #3
 8037a78:	e7ec      	b.n	8037a54 <RegionEU868NewChannelReq+0x18>
 8037a7a:	bf00      	nop
 8037a7c:	0803ba9c 	.word	0x0803ba9c

08037a80 <RegionEU868SetContinuousWave>:

void RegionEU868SetContinuousWave( ContinuousWaveParams_t* continuousWave )
{
 8037a80:	b570      	push	{r4, r5, r6, lr}
#if defined( REGION_EU868 )
    int8_t txPowerLimited = RegionCommonLimitTxPower( continuousWave->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[continuousWave->Channel].Band].TxMaxPower );
 8037a82:	4e11      	ldr	r6, [pc, #68]	; (8037ac8 <RegionEU868SetContinuousWave+0x48>)
 8037a84:	7802      	ldrb	r2, [r0, #0]
 8037a86:	e9d6 3100 	ldrd	r3, r1, [r6]
 8037a8a:	250c      	movs	r5, #12
 8037a8c:	fb05 3202 	mla	r2, r5, r2, r3
{
 8037a90:	4604      	mov	r4, r0
    int8_t txPowerLimited = RegionCommonLimitTxPower( continuousWave->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[continuousWave->Channel].Band].TxMaxPower );
 8037a92:	7a53      	ldrb	r3, [r2, #9]
 8037a94:	f990 0002 	ldrsb.w	r0, [r0, #2]
 8037a98:	2218      	movs	r2, #24
 8037a9a:	fb02 1303 	mla	r3, r2, r3, r1
 8037a9e:	f993 1002 	ldrsb.w	r1, [r3, #2]
 8037aa2:	f7ff fa4b 	bl	8036f3c <RegionCommonLimitTxPower>
    int8_t phyTxPower = 0;
    uint32_t frequency = RegionNvmGroup2->Channels[continuousWave->Channel].Frequency;
 8037aa6:	7822      	ldrb	r2, [r4, #0]
 8037aa8:	6833      	ldr	r3, [r6, #0]

    // Calculate physical TX power
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, continuousWave->MaxEirp, continuousWave->AntennaGain );
 8037aaa:	6861      	ldr	r1, [r4, #4]
    uint32_t frequency = RegionNvmGroup2->Channels[continuousWave->Channel].Frequency;
 8037aac:	4355      	muls	r5, r2
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, continuousWave->MaxEirp, continuousWave->AntennaGain );
 8037aae:	68a2      	ldr	r2, [r4, #8]
    uint32_t frequency = RegionNvmGroup2->Channels[continuousWave->Channel].Frequency;
 8037ab0:	595d      	ldr	r5, [r3, r5]
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, continuousWave->MaxEirp, continuousWave->AntennaGain );
 8037ab2:	f7ff f978 	bl	8036da6 <RegionCommonComputeTxPower>

    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 8037ab6:	4b05      	ldr	r3, [pc, #20]	; (8037acc <RegionEU868SetContinuousWave+0x4c>)
 8037ab8:	89a2      	ldrh	r2, [r4, #12]
 8037aba:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, continuousWave->MaxEirp, continuousWave->AntennaGain );
 8037abc:	4601      	mov	r1, r0
    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 8037abe:	4628      	mov	r0, r5
#endif /* REGION_EU868 */
}
 8037ac0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 8037ac4:	4718      	bx	r3
 8037ac6:	bf00      	nop
 8037ac8:	20005728 	.word	0x20005728
 8037acc:	0803bbd8 	.word	0x0803bbd8

08037ad0 <RegionEU868ApplyDrOffset>:

uint8_t RegionEU868ApplyDrOffset( uint8_t downlinkDwellTime, int8_t dr, int8_t drOffset )
{
#if defined( REGION_EU868 )
    int8_t datarate = dr - drOffset;
 8037ad0:	1a88      	subs	r0, r1, r2
 8037ad2:	b240      	sxtb	r0, r0

    if( datarate < 0 )
    {
        datarate = DR_0;
    }
    return datarate;
 8037ad4:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
#else
    return 0;
#endif /* REGION_EU868 */
}
 8037ad8:	b2c0      	uxtb	r0, r0
 8037ada:	4770      	bx	lr

08037adc <GetTimeOnAir>:
    }
    return true;
}

static TimerTime_t GetTimeOnAir( int8_t datarate, uint16_t pktLen )
{
 8037adc:	b530      	push	{r4, r5, lr}
 8037ade:	460c      	mov	r4, r1
    int8_t phyDr = DataratesUS915[datarate];
 8037ae0:	490a      	ldr	r1, [pc, #40]	; (8037b0c <GetTimeOnAir+0x30>)
{
 8037ae2:	b085      	sub	sp, #20
    int8_t phyDr = DataratesUS915[datarate];
 8037ae4:	560d      	ldrsb	r5, [r1, r0]
    uint32_t bandwidth = RegionCommonGetBandwidth( datarate, BandwidthsUS915 );
 8037ae6:	3110      	adds	r1, #16
 8037ae8:	f7ff fa2c 	bl	8036f44 <RegionCommonGetBandwidth>

    return Radio.TimeOnAir( MODEM_LORA, bandwidth, phyDr, 1, 8, false, pktLen, true );
 8037aec:	2208      	movs	r2, #8
    uint32_t bandwidth = RegionCommonGetBandwidth( datarate, BandwidthsUS915 );
 8037aee:	4601      	mov	r1, r0
    return Radio.TimeOnAir( MODEM_LORA, bandwidth, phyDr, 1, 8, false, pktLen, true );
 8037af0:	2000      	movs	r0, #0
 8037af2:	e9cd 2000 	strd	r2, r0, [sp]
 8037af6:	4a06      	ldr	r2, [pc, #24]	; (8037b10 <GetTimeOnAir+0x34>)
 8037af8:	2301      	movs	r3, #1
 8037afa:	b2e4      	uxtb	r4, r4
 8037afc:	9402      	str	r4, [sp, #8]
 8037afe:	9303      	str	r3, [sp, #12]
 8037b00:	6a54      	ldr	r4, [r2, #36]	; 0x24
 8037b02:	4618      	mov	r0, r3
 8037b04:	462a      	mov	r2, r5
 8037b06:	47a0      	blx	r4
}
 8037b08:	b005      	add	sp, #20
 8037b0a:	bd30      	pop	{r4, r5, pc}
 8037b0c:	0803bb00 	.word	0x0803bb00
 8037b10:	0803bbd8 	.word	0x0803bbd8

08037b14 <VerifyRfFreq>:
    if( Radio.CheckRfFrequency( freq ) == false )
 8037b14:	4b0b      	ldr	r3, [pc, #44]	; (8037b44 <VerifyRfFreq+0x30>)
{
 8037b16:	b510      	push	{r4, lr}
    if( Radio.CheckRfFrequency( freq ) == false )
 8037b18:	6a1b      	ldr	r3, [r3, #32]
{
 8037b1a:	4604      	mov	r4, r0
    if( Radio.CheckRfFrequency( freq ) == false )
 8037b1c:	4798      	blx	r3
 8037b1e:	b168      	cbz	r0, 8037b3c <VerifyRfFreq+0x28>
    if( ( freq < US915_FIRST_RX1_CHANNEL ) ||
 8037b20:	4b09      	ldr	r3, [pc, #36]	; (8037b48 <VerifyRfFreq+0x34>)
 8037b22:	4a0a      	ldr	r2, [pc, #40]	; (8037b4c <VerifyRfFreq+0x38>)
 8037b24:	4423      	add	r3, r4
 8037b26:	4293      	cmp	r3, r2
 8037b28:	d809      	bhi.n	8037b3e <VerifyRfFreq+0x2a>
        ( freq > US915_LAST_RX1_CHANNEL ) ||
 8037b2a:	4a09      	ldr	r2, [pc, #36]	; (8037b50 <VerifyRfFreq+0x3c>)
 8037b2c:	4353      	muls	r3, r2
 8037b2e:	f641 32f6 	movw	r2, #7158	; 0x1bf6
 8037b32:	ebb2 1fb3 	cmp.w	r2, r3, ror #6
 8037b36:	bf2c      	ite	cs
 8037b38:	2001      	movcs	r0, #1
 8037b3a:	2000      	movcc	r0, #0
}
 8037b3c:	bd10      	pop	{r4, pc}
        return false;
 8037b3e:	2000      	movs	r0, #0
 8037b40:	e7fc      	b.n	8037b3c <VerifyRfFreq+0x28>
 8037b42:	bf00      	nop
 8037b44:	0803bbd8 	.word	0x0803bbd8
 8037b48:	c8f78f60 	.word	0xc8f78f60
 8037b4c:	00401640 	.word	0x00401640
 8037b50:	5943f75f 	.word	0x5943f75f

08037b54 <RegionUS915GetPhyParam>:
#endif /* REGION_US915 */

PhyParam_t RegionUS915GetPhyParam( GetPhyParams_t* getPhy )
{
 8037b54:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    PhyParam_t phyParam = { 0 };
 8037b56:	2300      	movs	r3, #0
 8037b58:	9300      	str	r3, [sp, #0]

#if defined( REGION_US915 )
    switch( getPhy->Attribute )
 8037b5a:	7803      	ldrb	r3, [r0, #0]
 8037b5c:	3b01      	subs	r3, #1
 8037b5e:	2b38      	cmp	r3, #56	; 0x38
 8037b60:	d875      	bhi.n	8037c4e <RegionUS915GetPhyParam+0xfa>
 8037b62:	e8df f003 	tbb	[pc, r3]
 8037b66:	741d      	.short	0x741d
 8037b68:	74747474 	.word	0x74747474
 8037b6c:	74747474 	.word	0x74747474
 8037b70:	40393735 	.word	0x40393735
 8037b74:	4d4a4774 	.word	0x4d4a4774
 8037b78:	59565350 	.word	0x59565350
 8037b7c:	631d6174 	.word	0x631d6174
 8037b80:	746f6d68 	.word	0x746f6d68
 8037b84:	20787274 	.word	0x20787274
 8037b88:	74747474 	.word	0x74747474
 8037b8c:	74747474 	.word	0x74747474
 8037b90:	74747474 	.word	0x74747474
 8037b94:	1d807a74 	.word	0x1d807a74
 8037b98:	1d7a741d 	.word	0x1d7a741d
 8037b9c:	881d      	.short	0x881d
 8037b9e:	8d          	.byte	0x8d
 8037b9f:	00          	.byte	0x00
    {
        case PHY_MIN_RX_DR:
        {
            phyParam.Value = US915_RX_MIN_DATARATE;
 8037ba0:	2308      	movs	r3, #8
            phyParam.Value = US915_BEACON_NB_CHANNELS;
            break;
        }
        case PHY_SF_FROM_DR:
        {
            phyParam.Value = DataratesUS915[getPhy->Datarate];
 8037ba2:	9300      	str	r3, [sp, #0]
            break;
 8037ba4:	e053      	b.n	8037c4e <RegionUS915GetPhyParam+0xfa>
            RegionCommonGetNextLowerTxDrParams_t nextLowerTxDrParams =
 8037ba6:	7843      	ldrb	r3, [r0, #1]
 8037ba8:	f88d 3004 	strb.w	r3, [sp, #4]
 8037bac:	2304      	movs	r3, #4
 8037bae:	f88d 3005 	strb.w	r3, [sp, #5]
 8037bb2:	f44f 4390 	mov.w	r3, #18432	; 0x4800
 8037bb6:	f8ad 3006 	strh.w	r3, [sp, #6]
                .ChannelsMask = RegionNvmGroup2->ChannelsMask,
 8037bba:	4b34      	ldr	r3, [pc, #208]	; (8037c8c <RegionUS915GetPhyParam+0x138>)
 8037bbc:	681b      	ldr	r3, [r3, #0]
            phyParam.Value = RegionCommonGetNextLowerTxDr( &nextLowerTxDrParams );
 8037bbe:	a801      	add	r0, sp, #4
                .ChannelsMask = RegionNvmGroup2->ChannelsMask,
 8037bc0:	f503 7258 	add.w	r2, r3, #864	; 0x360
            RegionCommonGetNextLowerTxDrParams_t nextLowerTxDrParams =
 8037bc4:	e9cd 2302 	strd	r2, r3, [sp, #8]
            phyParam.Value = RegionCommonGetNextLowerTxDr( &nextLowerTxDrParams );
 8037bc8:	f7ff f99d 	bl	8036f06 <RegionCommonGetNextLowerTxDr>
        }
        case PHY_BW_FROM_DR:
        {
            phyParam.Value = RegionCommonGetBandwidth( getPhy->Datarate, BandwidthsUS915 );
 8037bcc:	9000      	str	r0, [sp, #0]
            break;
 8037bce:	e03e      	b.n	8037c4e <RegionUS915GetPhyParam+0xfa>
            phyParam.Value = REGION_COMMON_DEFAULT_ADR_ACK_LIMIT;
 8037bd0:	2340      	movs	r3, #64	; 0x40
 8037bd2:	e7e6      	b.n	8037ba2 <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = REGION_COMMON_DEFAULT_ADR_ACK_DELAY;
 8037bd4:	2320      	movs	r3, #32
 8037bd6:	e7e4      	b.n	8037ba2 <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = MaxPayloadOfDatarateUS915[getPhy->Datarate];
 8037bd8:	f990 2001 	ldrsb.w	r2, [r0, #1]
 8037bdc:	4b2c      	ldr	r3, [pc, #176]	; (8037c90 <RegionUS915GetPhyParam+0x13c>)
 8037bde:	4413      	add	r3, r2
 8037be0:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 8037be4:	e7dd      	b.n	8037ba2 <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = MaxPayloadOfDatarateRepeaterUS915[getPhy->Datarate];
 8037be6:	f990 2001 	ldrsb.w	r2, [r0, #1]
 8037bea:	4b29      	ldr	r3, [pc, #164]	; (8037c90 <RegionUS915GetPhyParam+0x13c>)
 8037bec:	4413      	add	r3, r2
 8037bee:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8037bf2:	e7d6      	b.n	8037ba2 <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = US915_MAX_RX_WINDOW;
 8037bf4:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8037bf8:	e7d3      	b.n	8037ba2 <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = REGION_COMMON_DEFAULT_RECEIVE_DELAY1;
 8037bfa:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8037bfe:	e7d0      	b.n	8037ba2 <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = REGION_COMMON_DEFAULT_RECEIVE_DELAY2;
 8037c00:	f44f 63fa 	mov.w	r3, #2000	; 0x7d0
 8037c04:	e7cd      	b.n	8037ba2 <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = REGION_COMMON_DEFAULT_JOIN_ACCEPT_DELAY1;
 8037c06:	f241 3388 	movw	r3, #5000	; 0x1388
 8037c0a:	e7ca      	b.n	8037ba2 <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = REGION_COMMON_DEFAULT_JOIN_ACCEPT_DELAY2;
 8037c0c:	f241 7370 	movw	r3, #6000	; 0x1770
 8037c10:	e7c7      	b.n	8037ba2 <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = REGION_COMMON_DEFAULT_MAX_FCNT_GAP;
 8037c12:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8037c16:	e7c4      	b.n	8037ba2 <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = ( REGION_COMMON_DEFAULT_ACK_TIMEOUT + randr( -REGION_COMMON_DEFAULT_ACK_TIMEOUT_RND, REGION_COMMON_DEFAULT_ACK_TIMEOUT_RND ) );
 8037c18:	481e      	ldr	r0, [pc, #120]	; (8037c94 <RegionUS915GetPhyParam+0x140>)
 8037c1a:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8037c1e:	f001 f93f 	bl	8038ea0 <randr>
 8037c22:	f500 60fa 	add.w	r0, r0, #2000	; 0x7d0
 8037c26:	e7d1      	b.n	8037bcc <RegionUS915GetPhyParam+0x78>
            phyParam.Value = US915_RX_WND_2_FREQ;
 8037c28:	4b1b      	ldr	r3, [pc, #108]	; (8037c98 <RegionUS915GetPhyParam+0x144>)
 8037c2a:	e7ba      	b.n	8037ba2 <RegionUS915GetPhyParam+0x4e>
            phyParam.ChannelsMask = RegionNvmGroup2->ChannelsMask;
 8037c2c:	4b17      	ldr	r3, [pc, #92]	; (8037c8c <RegionUS915GetPhyParam+0x138>)
 8037c2e:	681b      	ldr	r3, [r3, #0]
 8037c30:	f503 7358 	add.w	r3, r3, #864	; 0x360
 8037c34:	e7b5      	b.n	8037ba2 <RegionUS915GetPhyParam+0x4e>
            phyParam.ChannelsMask = RegionNvmGroup2->ChannelsDefaultMask;
 8037c36:	4b15      	ldr	r3, [pc, #84]	; (8037c8c <RegionUS915GetPhyParam+0x138>)
 8037c38:	681b      	ldr	r3, [r3, #0]
 8037c3a:	f503 735b 	add.w	r3, r3, #876	; 0x36c
 8037c3e:	e7b0      	b.n	8037ba2 <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = US915_MAX_NB_CHANNELS;
 8037c40:	2348      	movs	r3, #72	; 0x48
 8037c42:	e7ae      	b.n	8037ba2 <RegionUS915GetPhyParam+0x4e>
            phyParam.Channels = RegionNvmGroup2->Channels;
 8037c44:	4b11      	ldr	r3, [pc, #68]	; (8037c8c <RegionUS915GetPhyParam+0x138>)
 8037c46:	681b      	ldr	r3, [r3, #0]
 8037c48:	e7ab      	b.n	8037ba2 <RegionUS915GetPhyParam+0x4e>
            phyParam.fValue = US915_DEFAULT_MAX_ERP + 2.15f;
 8037c4a:	4b14      	ldr	r3, [pc, #80]	; (8037c9c <RegionUS915GetPhyParam+0x148>)
            phyParam.fValue = 0;
 8037c4c:	9300      	str	r3, [sp, #0]
        }
    }

#endif /* REGION_US915 */
    return phyParam;
}
 8037c4e:	9800      	ldr	r0, [sp, #0]
 8037c50:	b005      	add	sp, #20
 8037c52:	f85d fb04 	ldr.w	pc, [sp], #4
            phyParam.fValue = 0;
 8037c56:	2300      	movs	r3, #0
 8037c58:	e7f8      	b.n	8037c4c <RegionUS915GetPhyParam+0xf8>
            phyParam.Value = RegionBaseUSCalcDownlinkFrequency( getPhy->Channel,
 8037c5a:	4a11      	ldr	r2, [pc, #68]	; (8037ca0 <RegionUS915GetPhyParam+0x14c>)
 8037c5c:	490e      	ldr	r1, [pc, #56]	; (8037c98 <RegionUS915GetPhyParam+0x144>)
 8037c5e:	7900      	ldrb	r0, [r0, #4]
 8037c60:	f7fe fe7a 	bl	8036958 <RegionBaseUSCalcDownlinkFrequency>
 8037c64:	e7b2      	b.n	8037bcc <RegionUS915GetPhyParam+0x78>
            phyParam.BeaconFormat.BeaconSize = US915_BEACON_SIZE;
 8037c66:	f240 5317 	movw	r3, #1303	; 0x517
 8037c6a:	f8ad 3000 	strh.w	r3, [sp]
            phyParam.BeaconFormat.Rfu2Size = US915_RFU2_SIZE;
 8037c6e:	2303      	movs	r3, #3
 8037c70:	f88d 3002 	strb.w	r3, [sp, #2]
            break;
 8037c74:	e7eb      	b.n	8037c4e <RegionUS915GetPhyParam+0xfa>
            phyParam.Value = DataratesUS915[getPhy->Datarate];
 8037c76:	f990 3001 	ldrsb.w	r3, [r0, #1]
 8037c7a:	4a05      	ldr	r2, [pc, #20]	; (8037c90 <RegionUS915GetPhyParam+0x13c>)
 8037c7c:	5cd3      	ldrb	r3, [r2, r3]
 8037c7e:	e790      	b.n	8037ba2 <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = RegionCommonGetBandwidth( getPhy->Datarate, BandwidthsUS915 );
 8037c80:	4908      	ldr	r1, [pc, #32]	; (8037ca4 <RegionUS915GetPhyParam+0x150>)
 8037c82:	f990 0001 	ldrsb.w	r0, [r0, #1]
 8037c86:	f7ff f95d 	bl	8036f44 <RegionCommonGetBandwidth>
 8037c8a:	e79f      	b.n	8037bcc <RegionUS915GetPhyParam+0x78>
 8037c8c:	20005730 	.word	0x20005730
 8037c90:	0803bb00 	.word	0x0803bb00
 8037c94:	fffffc18 	.word	0xfffffc18
 8037c98:	370870a0 	.word	0x370870a0
 8037c9c:	4200999a 	.word	0x4200999a
 8037ca0:	000927c0 	.word	0x000927c0
 8037ca4:	0803bb10 	.word	0x0803bb10

08037ca8 <RegionUS915SetBandTxDone>:

void RegionUS915SetBandTxDone( SetBandTxDoneParams_t* txDone )
{
 8037ca8:	b537      	push	{r0, r1, r2, r4, r5, lr}
#if defined( REGION_US915 )
    RegionCommonSetBandTxDone( &RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txDone->Channel].Band],
 8037caa:	4a0a      	ldr	r2, [pc, #40]	; (8037cd4 <RegionUS915SetBandTxDone+0x2c>)
 8037cac:	7803      	ldrb	r3, [r0, #0]
 8037cae:	6811      	ldr	r1, [r2, #0]
 8037cb0:	6855      	ldr	r5, [r2, #4]
 8037cb2:	240c      	movs	r4, #12
 8037cb4:	fb04 1303 	mla	r3, r4, r3, r1
 8037cb8:	7a5b      	ldrb	r3, [r3, #9]
 8037cba:	eb03 0443 	add.w	r4, r3, r3, lsl #1
 8037cbe:	6903      	ldr	r3, [r0, #16]
 8037cc0:	9300      	str	r3, [sp, #0]
 8037cc2:	68c3      	ldr	r3, [r0, #12]
 8037cc4:	7842      	ldrb	r2, [r0, #1]
 8037cc6:	6881      	ldr	r1, [r0, #8]
 8037cc8:	eb05 00c4 	add.w	r0, r5, r4, lsl #3
 8037ccc:	f7fe feca 	bl	8036a64 <RegionCommonSetBandTxDone>
                               txDone->LastTxAirTime, txDone->Joined, txDone->ElapsedTimeSinceStartUp );
#endif /* REGION_US915 */
}
 8037cd0:	b003      	add	sp, #12
 8037cd2:	bd30      	pop	{r4, r5, pc}
 8037cd4:	20005730 	.word	0x20005730

08037cd8 <RegionUS915InitDefaults>:

void RegionUS915InitDefaults( InitDefaultsParams_t* params )
{
 8037cd8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8037cda:	b087      	sub	sp, #28
#if defined( REGION_US915 )
    Band_t bands[US915_MAX_NB_BANDS] =
 8037cdc:	2301      	movs	r3, #1
    {
       US915_BAND0
    };

    switch( params->Type )
 8037cde:	7a04      	ldrb	r4, [r0, #8]
    Band_t bands[US915_MAX_NB_BANDS] =
 8037ce0:	f8ad 3000 	strh.w	r3, [sp]
 8037ce4:	2300      	movs	r3, #0
 8037ce6:	e9cd 3301 	strd	r3, r3, [sp, #4]
 8037cea:	e9cd 3303 	strd	r3, r3, [sp, #12]
{
 8037cee:	4602      	mov	r2, r0
    Band_t bands[US915_MAX_NB_BANDS] =
 8037cf0:	f88d 3002 	strb.w	r3, [sp, #2]
 8037cf4:	f88d 3014 	strb.w	r3, [sp, #20]
    switch( params->Type )
 8037cf8:	b124      	cbz	r4, 8037d04 <RegionUS915InitDefaults+0x2c>
 8037cfa:	3c01      	subs	r4, #1
 8037cfc:	2c01      	cmp	r4, #1
 8037cfe:	d94a      	bls.n	8037d96 <RegionUS915InitDefaults+0xbe>
        {
            break;
        }
    }
#endif /* REGION_US915 */
}
 8037d00:	b007      	add	sp, #28
 8037d02:	bdf0      	pop	{r4, r5, r6, r7, pc}
            if( ( params->NvmGroup1 == NULL ) || ( params->NvmGroup2 == NULL ) )
 8037d04:	6800      	ldr	r0, [r0, #0]
 8037d06:	2800      	cmp	r0, #0
 8037d08:	d0fa      	beq.n	8037d00 <RegionUS915InitDefaults+0x28>
 8037d0a:	6853      	ldr	r3, [r2, #4]
 8037d0c:	2b00      	cmp	r3, #0
 8037d0e:	d0f7      	beq.n	8037d00 <RegionUS915InitDefaults+0x28>
            RegionNvmGroup1 = (RegionNvmDataGroup1_t*) params->NvmGroup1;
 8037d10:	4d2d      	ldr	r5, [pc, #180]	; (8037dc8 <RegionUS915InitDefaults+0xf0>)
            RegionNvmGroup1->JoinChannelGroupsCurrentIndex = 0;
 8037d12:	f8a0 409c 	strh.w	r4, [r0, #156]	; 0x9c
            memcpy1( ( uint8_t* )RegionNvmGroup1->Bands, ( uint8_t* )bands, sizeof( Band_t ) * US915_MAX_NB_BANDS );
 8037d16:	2218      	movs	r2, #24
 8037d18:	4669      	mov	r1, sp
            RegionNvmGroup2 = (RegionNvmDataGroup2_t*) params->NvmGroup2;
 8037d1a:	e9c5 3000 	strd	r3, r0, [r5]
            memcpy1( ( uint8_t* )RegionNvmGroup1->Bands, ( uint8_t* )bands, sizeof( Band_t ) * US915_MAX_NB_BANDS );
 8037d1e:	f001 f8db 	bl	8038ed8 <memcpy1>
                RegionNvmGroup2->Channels[i].Frequency = 902300000 + i * 200000;
 8037d22:	6828      	ldr	r0, [r5, #0]
 8037d24:	4b29      	ldr	r3, [pc, #164]	; (8037dcc <RegionUS915InitDefaults+0xf4>)
            for( uint8_t i = 0; i < US915_MAX_NB_CHANNELS - 8; i++ )
 8037d26:	4e2a      	ldr	r6, [pc, #168]	; (8037dd0 <RegionUS915InitDefaults+0xf8>)
 8037d28:	4602      	mov	r2, r0
                RegionNvmGroup2->Channels[i].Frequency = 902300000 + i * 200000;
 8037d2a:	4601      	mov	r1, r0
                RegionNvmGroup2->Channels[i].DrRange.Value = ( DR_3 << 4 ) | DR_0;
 8037d2c:	2730      	movs	r7, #48	; 0x30
                RegionNvmGroup2->Channels[i].Frequency = 902300000 + i * 200000;
 8037d2e:	600b      	str	r3, [r1, #0]
                RegionNvmGroup2->Channels[i].DrRange.Value = ( DR_3 << 4 ) | DR_0;
 8037d30:	f503 3343 	add.w	r3, r3, #199680	; 0x30c00
 8037d34:	f503 73a0 	add.w	r3, r3, #320	; 0x140
            for( uint8_t i = 0; i < US915_MAX_NB_CHANNELS - 8; i++ )
 8037d38:	42b3      	cmp	r3, r6
                RegionNvmGroup2->Channels[i].DrRange.Value = ( DR_3 << 4 ) | DR_0;
 8037d3a:	720f      	strb	r7, [r1, #8]
                RegionNvmGroup2->Channels[i].Band = 0;
 8037d3c:	724c      	strb	r4, [r1, #9]
            for( uint8_t i = 0; i < US915_MAX_NB_CHANNELS - 8; i++ )
 8037d3e:	f101 010c 	add.w	r1, r1, #12
 8037d42:	d1f4      	bne.n	8037d2e <RegionUS915InitDefaults+0x56>
 8037d44:	4b23      	ldr	r3, [pc, #140]	; (8037dd4 <RegionUS915InitDefaults+0xfc>)
            for( uint8_t i = US915_MAX_NB_CHANNELS - 8; i < US915_MAX_NB_CHANNELS; i++ )
 8037d46:	4924      	ldr	r1, [pc, #144]	; (8037dd8 <RegionUS915InitDefaults+0x100>)
                RegionNvmGroup2->Channels[i].DrRange.Value = ( DR_4 << 4 ) | DR_4;
 8037d48:	2644      	movs	r6, #68	; 0x44
                RegionNvmGroup2->Channels[i].Band = 0;
 8037d4a:	2400      	movs	r4, #0
                RegionNvmGroup2->Channels[i].Frequency = 903000000 + ( i - ( US915_MAX_NB_CHANNELS - 8 ) ) * 1600000;
 8037d4c:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
                RegionNvmGroup2->Channels[i].DrRange.Value = ( DR_4 << 4 ) | DR_4;
 8037d50:	f503 13c3 	add.w	r3, r3, #1597440	; 0x186000
 8037d54:	f503 6320 	add.w	r3, r3, #2560	; 0xa00
            for( uint8_t i = US915_MAX_NB_CHANNELS - 8; i < US915_MAX_NB_CHANNELS; i++ )
 8037d58:	428b      	cmp	r3, r1
                RegionNvmGroup2->Channels[i].DrRange.Value = ( DR_4 << 4 ) | DR_4;
 8037d5a:	f882 6308 	strb.w	r6, [r2, #776]	; 0x308
                RegionNvmGroup2->Channels[i].Band = 0;
 8037d5e:	f882 4309 	strb.w	r4, [r2, #777]	; 0x309
            for( uint8_t i = US915_MAX_NB_CHANNELS - 8; i < US915_MAX_NB_CHANNELS; i++ )
 8037d62:	f102 020c 	add.w	r2, r2, #12
 8037d66:	d1f1      	bne.n	8037d4c <RegionUS915InitDefaults+0x74>
            RegionNvmGroup2->ChannelsDefaultMask[0] = 0xFFFF;
 8037d68:	f04f 33ff 	mov.w	r3, #4294967295
            RegionNvmGroup2->ChannelsDefaultMask[2] = 0xFFFF;
 8037d6c:	e9c0 33db 	strd	r3, r3, [r0, #876]	; 0x36c
            RegionNvmGroup2->ChannelsDefaultMask[4] = 0x00FF;
 8037d70:	23ff      	movs	r3, #255	; 0xff
 8037d72:	f8c0 3374 	str.w	r3, [r0, #884]	; 0x374
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
 8037d76:	f500 715b 	add.w	r1, r0, #876	; 0x36c
 8037d7a:	2206      	movs	r2, #6
 8037d7c:	f500 7058 	add.w	r0, r0, #864	; 0x360
 8037d80:	f7fe fe61 	bl	8036a46 <RegionCommonChanMaskCopy>
            RegionCommonChanMaskCopy( RegionNvmGroup1->ChannelsMaskRemaining, RegionNvmGroup2->ChannelsMask, CHANNELS_MASK_SIZE );
 8037d84:	e9d5 1000 	ldrd	r1, r0, [r5]
 8037d88:	2206      	movs	r2, #6
 8037d8a:	f501 7158 	add.w	r1, r1, #864	; 0x360
 8037d8e:	3090      	adds	r0, #144	; 0x90
 8037d90:	f7fe fe59 	bl	8036a46 <RegionCommonChanMaskCopy>
            break;
 8037d94:	e7b4      	b.n	8037d00 <RegionUS915InitDefaults+0x28>
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
 8037d96:	4c0c      	ldr	r4, [pc, #48]	; (8037dc8 <RegionUS915InitDefaults+0xf0>)
 8037d98:	6820      	ldr	r0, [r4, #0]
 8037d9a:	2206      	movs	r2, #6
 8037d9c:	f500 715b 	add.w	r1, r0, #876	; 0x36c
 8037da0:	f500 7058 	add.w	r0, r0, #864	; 0x360
 8037da4:	f7fe fe4f 	bl	8036a46 <RegionCommonChanMaskCopy>
                RegionNvmGroup1->ChannelsMaskRemaining[i] &= RegionNvmGroup2->ChannelsMask[i];
 8037da8:	6863      	ldr	r3, [r4, #4]
 8037daa:	6821      	ldr	r1, [r4, #0]
 8037dac:	f103 0290 	add.w	r2, r3, #144	; 0x90
 8037db0:	f501 7158 	add.w	r1, r1, #864	; 0x360
 8037db4:	339c      	adds	r3, #156	; 0x9c
 8037db6:	8810      	ldrh	r0, [r2, #0]
 8037db8:	f831 4b02 	ldrh.w	r4, [r1], #2
 8037dbc:	4020      	ands	r0, r4
 8037dbe:	f822 0b02 	strh.w	r0, [r2], #2
            for( uint8_t i = 0; i < CHANNELS_MASK_SIZE; i++ )
 8037dc2:	429a      	cmp	r2, r3
 8037dc4:	d1f7      	bne.n	8037db6 <RegionUS915InitDefaults+0xde>
 8037dc6:	e79b      	b.n	8037d00 <RegionUS915InitDefaults+0x28>
 8037dc8:	20005730 	.word	0x20005730
 8037dcc:	35c80160 	.word	0x35c80160
 8037dd0:	368b5160 	.word	0x368b5160
 8037dd4:	35d2afc0 	.word	0x35d2afc0
 8037dd8:	3695ffc0 	.word	0x3695ffc0

08037ddc <RegionUS915Verify>:

bool RegionUS915Verify( VerifyParams_t* verify, PhyAttribute_t phyAttribute )
{
 8037ddc:	b508      	push	{r3, lr}
 8037dde:	290a      	cmp	r1, #10
 8037de0:	d81b      	bhi.n	8037e1a <RegionUS915Verify+0x3e>
 8037de2:	e8df f001 	tbb	[pc, r1]
 8037de6:	1a06      	.short	0x1a06
 8037de8:	0b1a1a1a 	.word	0x0b1a1a1a
 8037dec:	181a0e0b 	.word	0x181a0e0b
 8037df0:	18          	.byte	0x18
 8037df1:	00          	.byte	0x00
            return false;
    }
#else
    return false;
#endif /* REGION_US915 */
}
 8037df2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            return VerifyRfFreq( verify->Frequency );
 8037df6:	6800      	ldr	r0, [r0, #0]
 8037df8:	f7ff be8c 	b.w	8037b14 <VerifyRfFreq>
            return RegionCommonValueInRange( verify->DatarateParams.Datarate, US915_TX_MIN_DATARATE, US915_TX_MAX_DATARATE );
 8037dfc:	2204      	movs	r2, #4
            return RegionCommonValueInRange( verify->TxPower, US915_MAX_TX_POWER, US915_MIN_TX_POWER );
 8037dfe:	2100      	movs	r1, #0
 8037e00:	e001      	b.n	8037e06 <RegionUS915Verify+0x2a>
            return RegionCommonValueInRange( verify->DatarateParams.Datarate, US915_RX_MIN_DATARATE, US915_RX_MAX_DATARATE );
 8037e02:	220d      	movs	r2, #13
 8037e04:	2108      	movs	r1, #8
            return RegionCommonValueInRange( verify->TxPower, US915_MAX_TX_POWER, US915_MIN_TX_POWER );
 8037e06:	f990 0000 	ldrsb.w	r0, [r0]
 8037e0a:	f7fe fddc 	bl	80369c6 <RegionCommonValueInRange>
 8037e0e:	3800      	subs	r0, #0
 8037e10:	bf18      	it	ne
 8037e12:	2001      	movne	r0, #1
}
 8037e14:	bd08      	pop	{r3, pc}
            return RegionCommonValueInRange( verify->TxPower, US915_MAX_TX_POWER, US915_MIN_TX_POWER );
 8037e16:	220e      	movs	r2, #14
 8037e18:	e7f1      	b.n	8037dfe <RegionUS915Verify+0x22>
{
 8037e1a:	2000      	movs	r0, #0
 8037e1c:	e7fa      	b.n	8037e14 <RegionUS915Verify+0x38>
	...

08037e20 <RegionUS915ApplyCFList>:

void RegionUS915ApplyCFList( ApplyCFListParams_t* applyCFList )
{
 8037e20:	b5f0      	push	{r4, r5, r6, r7, lr}
#if defined( REGION_US915 )
    // Size of the optional CF list must be 16 byte
    if( applyCFList->Size != 16 )
 8037e22:	7903      	ldrb	r3, [r0, #4]
 8037e24:	2b10      	cmp	r3, #16
 8037e26:	d122      	bne.n	8037e6e <RegionUS915ApplyCFList+0x4e>
    {
        return;
    }

    // Last byte CFListType must be 0x01 to indicate the CFList contains a series of ChMask fields
    if( applyCFList->Payload[15] != 0x01 )
 8037e28:	6804      	ldr	r4, [r0, #0]
 8037e2a:	7be3      	ldrb	r3, [r4, #15]
 8037e2c:	2b01      	cmp	r3, #1
 8037e2e:	d11e      	bne.n	8037e6e <RegionUS915ApplyCFList+0x4e>
    }

    // ChMask0 - ChMask4 must be set (every ChMask has 16 bit)
    for( uint8_t chMaskItr = 0, cntPayload = 0; chMaskItr <= 4; chMaskItr++, cntPayload+=2 )
    {
        RegionNvmGroup2->ChannelsMask[chMaskItr] = (uint16_t) (0x00FF & applyCFList->Payload[cntPayload]);
 8037e30:	4b0f      	ldr	r3, [pc, #60]	; (8037e70 <RegionUS915ApplyCFList+0x50>)
 8037e32:	681d      	ldr	r5, [r3, #0]
 8037e34:	6859      	ldr	r1, [r3, #4]
 8037e36:	f505 7058 	add.w	r0, r5, #864	; 0x360
 8037e3a:	3190      	adds	r1, #144	; 0x90
        if( chMaskItr == 4 )
        {
            RegionNvmGroup2->ChannelsMask[chMaskItr] = RegionNvmGroup2->ChannelsMask[chMaskItr] & CHANNELS_MASK_500KHZ_MASK;
        }
        // Set the channel mask to the remaining
        RegionNvmGroup1->ChannelsMaskRemaining[chMaskItr] &= RegionNvmGroup2->ChannelsMask[chMaskItr];
 8037e3c:	2200      	movs	r2, #0
        RegionNvmGroup2->ChannelsMask[chMaskItr] |= (uint16_t) (applyCFList->Payload[cntPayload+1] << 8);
 8037e3e:	1c67      	adds	r7, r4, #1
        RegionNvmGroup2->ChannelsMask[chMaskItr] = (uint16_t) (0x00FF & applyCFList->Payload[cntPayload]);
 8037e40:	f814 3012 	ldrb.w	r3, [r4, r2, lsl #1]
 8037e44:	8003      	strh	r3, [r0, #0]
        RegionNvmGroup2->ChannelsMask[chMaskItr] |= (uint16_t) (applyCFList->Payload[cntPayload+1] << 8);
 8037e46:	f817 6012 	ldrb.w	r6, [r7, r2, lsl #1]
        if( chMaskItr == 4 )
 8037e4a:	2a04      	cmp	r2, #4
        RegionNvmGroup2->ChannelsMask[chMaskItr] |= (uint16_t) (applyCFList->Payload[cntPayload+1] << 8);
 8037e4c:	ea43 2306 	orr.w	r3, r3, r6, lsl #8
 8037e50:	f820 3b02 	strh.w	r3, [r0], #2
            RegionNvmGroup2->ChannelsMask[chMaskItr] = RegionNvmGroup2->ChannelsMask[chMaskItr] & CHANNELS_MASK_500KHZ_MASK;
 8037e54:	bf04      	itt	eq
 8037e56:	b2db      	uxtbeq	r3, r3
 8037e58:	f8a5 3368 	strheq.w	r3, [r5, #872]	; 0x368
        RegionNvmGroup1->ChannelsMaskRemaining[chMaskItr] &= RegionNvmGroup2->ChannelsMask[chMaskItr];
 8037e5c:	880b      	ldrh	r3, [r1, #0]
 8037e5e:	f830 6c02 	ldrh.w	r6, [r0, #-2]
 8037e62:	3201      	adds	r2, #1
 8037e64:	4033      	ands	r3, r6
    for( uint8_t chMaskItr = 0, cntPayload = 0; chMaskItr <= 4; chMaskItr++, cntPayload+=2 )
 8037e66:	2a05      	cmp	r2, #5
        RegionNvmGroup1->ChannelsMaskRemaining[chMaskItr] &= RegionNvmGroup2->ChannelsMask[chMaskItr];
 8037e68:	f821 3b02 	strh.w	r3, [r1], #2
    for( uint8_t chMaskItr = 0, cntPayload = 0; chMaskItr <= 4; chMaskItr++, cntPayload+=2 )
 8037e6c:	d1e8      	bne.n	8037e40 <RegionUS915ApplyCFList+0x20>
    }
#endif /* REGION_US915 */
}
 8037e6e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8037e70:	20005730 	.word	0x20005730

08037e74 <RegionUS915ChanMaskSet>:

bool RegionUS915ChanMaskSet( ChanMaskSetParams_t* chanMaskSet )
{
 8037e74:	b570      	push	{r4, r5, r6, lr}
#if defined( REGION_US915 )
    uint8_t nbChannels = RegionCommonCountChannels( chanMaskSet->ChannelsMaskIn, 0, 4 );
 8037e76:	2204      	movs	r2, #4
{
 8037e78:	4605      	mov	r5, r0
    uint8_t nbChannels = RegionCommonCountChannels( chanMaskSet->ChannelsMaskIn, 0, 4 );
 8037e7a:	2100      	movs	r1, #0
 8037e7c:	6800      	ldr	r0, [r0, #0]
 8037e7e:	f7fe fdc4 	bl	8036a0a <RegionCommonCountChannels>

    // Check the number of active channels
    if( ( nbChannels < 2 ) &&
 8037e82:	2801      	cmp	r0, #1
 8037e84:	d003      	beq.n	8037e8e <RegionUS915ChanMaskSet+0x1a>
        ( nbChannels > 0 ) )
    {
        return false;
    }

    switch( chanMaskSet->ChannelsMaskType )
 8037e86:	792c      	ldrb	r4, [r5, #4]
 8037e88:	b11c      	cbz	r4, 8037e92 <RegionUS915ChanMaskSet+0x1e>
 8037e8a:	2c01      	cmp	r4, #1
 8037e8c:	d020      	beq.n	8037ed0 <RegionUS915ChanMaskSet+0x5c>
        return false;
 8037e8e:	2000      	movs	r0, #0
 8037e90:	e01d      	b.n	8037ece <RegionUS915ChanMaskSet+0x5a>
    {
        case CHANNELS_MASK:
        {
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, chanMaskSet->ChannelsMaskIn, CHANNELS_MASK_SIZE );
 8037e92:	4e14      	ldr	r6, [pc, #80]	; (8037ee4 <RegionUS915ChanMaskSet+0x70>)
 8037e94:	6829      	ldr	r1, [r5, #0]
 8037e96:	6830      	ldr	r0, [r6, #0]
 8037e98:	2206      	movs	r2, #6
 8037e9a:	f500 7058 	add.w	r0, r0, #864	; 0x360
 8037e9e:	f7fe fdd2 	bl	8036a46 <RegionCommonChanMaskCopy>

            RegionNvmGroup2->ChannelsDefaultMask[4] = RegionNvmGroup2->ChannelsDefaultMask[4] & CHANNELS_MASK_500KHZ_MASK;
 8037ea2:	6833      	ldr	r3, [r6, #0]
 8037ea4:	f893 2374 	ldrb.w	r2, [r3, #884]	; 0x374
 8037ea8:	f8a3 2374 	strh.w	r2, [r3, #884]	; 0x374
            RegionNvmGroup2->ChannelsDefaultMask[5] = 0x0000;

            for( uint8_t i = 0; i < CHANNELS_MASK_SIZE; i++ )
            { // Copy-And the channels mask
                RegionNvmGroup1->ChannelsMaskRemaining[i] &= RegionNvmGroup2->ChannelsMask[i];
 8037eac:	6872      	ldr	r2, [r6, #4]
            RegionNvmGroup2->ChannelsDefaultMask[5] = 0x0000;
 8037eae:	f8a3 4376 	strh.w	r4, [r3, #886]	; 0x376
            for( uint8_t i = 0; i < CHANNELS_MASK_SIZE; i++ )
 8037eb2:	f102 0190 	add.w	r1, r2, #144	; 0x90
 8037eb6:	f503 7358 	add.w	r3, r3, #864	; 0x360
 8037eba:	329c      	adds	r2, #156	; 0x9c
                RegionNvmGroup1->ChannelsMaskRemaining[i] &= RegionNvmGroup2->ChannelsMask[i];
 8037ebc:	8808      	ldrh	r0, [r1, #0]
 8037ebe:	f833 4b02 	ldrh.w	r4, [r3], #2
 8037ec2:	4020      	ands	r0, r4
 8037ec4:	f821 0b02 	strh.w	r0, [r1], #2
            for( uint8_t i = 0; i < CHANNELS_MASK_SIZE; i++ )
 8037ec8:	4291      	cmp	r1, r2
 8037eca:	d1f7      	bne.n	8037ebc <RegionUS915ChanMaskSet+0x48>
            break;
        }
        default:
            return false;
    }
    return true;
 8037ecc:	2001      	movs	r0, #1
#else
    return false;
#endif /* REGION_US915 */
}
 8037ece:	bd70      	pop	{r4, r5, r6, pc}
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsDefaultMask, chanMaskSet->ChannelsMaskIn, CHANNELS_MASK_SIZE );
 8037ed0:	4b04      	ldr	r3, [pc, #16]	; (8037ee4 <RegionUS915ChanMaskSet+0x70>)
 8037ed2:	6829      	ldr	r1, [r5, #0]
 8037ed4:	6818      	ldr	r0, [r3, #0]
 8037ed6:	2206      	movs	r2, #6
 8037ed8:	f500 705b 	add.w	r0, r0, #876	; 0x36c
 8037edc:	f7fe fdb3 	bl	8036a46 <RegionCommonChanMaskCopy>
            break;
 8037ee0:	e7f4      	b.n	8037ecc <RegionUS915ChanMaskSet+0x58>
 8037ee2:	bf00      	nop
 8037ee4:	20005730 	.word	0x20005730

08037ee8 <RegionUS915ComputeRxWindowParameters>:

void RegionUS915ComputeRxWindowParameters( int8_t datarate, uint8_t minRxSymbols, uint32_t rxError, RxConfigParams_t *rxConfigParams )
{
 8037ee8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
#if defined( REGION_US915 )
    uint32_t tSymbolInUs = 0;

    // Get the datarate, perform a boundary check
    rxConfigParams->Datarate = MIN( datarate, US915_RX_MAX_DATARATE );
 8037eea:	280d      	cmp	r0, #13
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsUS915 );
 8037eec:	4d12      	ldr	r5, [pc, #72]	; (8037f38 <RegionUS915ComputeRxWindowParameters+0x50>)
    rxConfigParams->Datarate = MIN( datarate, US915_RX_MAX_DATARATE );
 8037eee:	bfa8      	it	ge
 8037ef0:	200d      	movge	r0, #13
{
 8037ef2:	461c      	mov	r4, r3
 8037ef4:	460e      	mov	r6, r1
    rxConfigParams->Datarate = MIN( datarate, US915_RX_MAX_DATARATE );
 8037ef6:	7058      	strb	r0, [r3, #1]
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsUS915 );
 8037ef8:	f105 0110 	add.w	r1, r5, #16
{
 8037efc:	4617      	mov	r7, r2
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsUS915 );
 8037efe:	f7ff f821 	bl	8036f44 <RegionCommonGetBandwidth>

    tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesUS915[rxConfigParams->Datarate], BandwidthsUS915[rxConfigParams->Datarate] );
 8037f02:	f994 3001 	ldrsb.w	r3, [r4, #1]
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsUS915 );
 8037f06:	70a0      	strb	r0, [r4, #2]
    tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesUS915[rxConfigParams->Datarate], BandwidthsUS915[rxConfigParams->Datarate] );
 8037f08:	eb05 0283 	add.w	r2, r5, r3, lsl #2
 8037f0c:	5ce8      	ldrb	r0, [r5, r3]
 8037f0e:	6911      	ldr	r1, [r2, #16]
 8037f10:	f7fe ff14 	bl	8036d3c <RegionCommonComputeSymbolTimeLoRa>

    RegionCommonComputeRxWindowParameters( tSymbolInUs, minRxSymbols, rxError, Radio.GetWakeupTime( ), &rxConfigParams->WindowTimeout, &rxConfigParams->WindowOffset );
 8037f14:	4b09      	ldr	r3, [pc, #36]	; (8037f3c <RegionUS915ComputeRxWindowParameters+0x54>)
 8037f16:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesUS915[rxConfigParams->Datarate], BandwidthsUS915[rxConfigParams->Datarate] );
 8037f18:	4605      	mov	r5, r0
    RegionCommonComputeRxWindowParameters( tSymbolInUs, minRxSymbols, rxError, Radio.GetWakeupTime( ), &rxConfigParams->WindowTimeout, &rxConfigParams->WindowOffset );
 8037f1a:	4798      	blx	r3
 8037f1c:	f104 020c 	add.w	r2, r4, #12
 8037f20:	3408      	adds	r4, #8
 8037f22:	4603      	mov	r3, r0
 8037f24:	9201      	str	r2, [sp, #4]
 8037f26:	9400      	str	r4, [sp, #0]
 8037f28:	463a      	mov	r2, r7
 8037f2a:	4631      	mov	r1, r6
 8037f2c:	4628      	mov	r0, r5
 8037f2e:	f7fe ff12 	bl	8036d56 <RegionCommonComputeRxWindowParameters>
#endif /* REGION_US915 */
}
 8037f32:	b003      	add	sp, #12
 8037f34:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8037f36:	bf00      	nop
 8037f38:	0803bb00 	.word	0x0803bb00
 8037f3c:	0803bbd8 	.word	0x0803bbd8

08037f40 <RegionUS915RxConfig>:

bool RegionUS915RxConfig( RxConfigParams_t* rxConfig, int8_t* datarate )
{
 8037f40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int8_t dr = rxConfig->Datarate;
    uint8_t maxPayload = 0;
    int8_t phyDr = 0;
    uint32_t frequency = rxConfig->Frequency;

    if( Radio.GetStatus( ) != RF_IDLE )
 8037f44:	4e24      	ldr	r6, [pc, #144]	; (8037fd8 <RegionUS915RxConfig+0x98>)
    int8_t dr = rxConfig->Datarate;
 8037f46:	f990 9001 	ldrsb.w	r9, [r0, #1]
    if( Radio.GetStatus( ) != RF_IDLE )
 8037f4a:	6873      	ldr	r3, [r6, #4]
    uint32_t frequency = rxConfig->Frequency;
 8037f4c:	6845      	ldr	r5, [r0, #4]
{
 8037f4e:	b08b      	sub	sp, #44	; 0x2c
 8037f50:	4604      	mov	r4, r0
 8037f52:	468a      	mov	sl, r1
    if( Radio.GetStatus( ) != RF_IDLE )
 8037f54:	4798      	blx	r3
 8037f56:	2800      	cmp	r0, #0
 8037f58:	d13c      	bne.n	8037fd4 <RegionUS915RxConfig+0x94>
    {
        return false;
    }

    if( rxConfig->RxSlot == RX_SLOT_WIN_1 )
 8037f5a:	7ce3      	ldrb	r3, [r4, #19]
 8037f5c:	b933      	cbnz	r3, 8037f6c <RegionUS915RxConfig+0x2c>
    {
        // Apply window 1 frequency
        frequency = US915_FIRST_RX1_CHANNEL + ( rxConfig->Channel % 8 ) * US915_STEPWIDTH_RX1_CHANNEL;
 8037f5e:	7825      	ldrb	r5, [r4, #0]
 8037f60:	4a1e      	ldr	r2, [pc, #120]	; (8037fdc <RegionUS915RxConfig+0x9c>)
 8037f62:	4b1f      	ldr	r3, [pc, #124]	; (8037fe0 <RegionUS915RxConfig+0xa0>)
 8037f64:	f005 0507 	and.w	r5, r5, #7
 8037f68:	fb02 3505 	mla	r5, r2, r5, r3
    }

    // Read the physical datarate from the datarates table
    phyDr = DataratesUS915[dr];
 8037f6c:	f8df 8074 	ldr.w	r8, [pc, #116]	; 8037fe4 <RegionUS915RxConfig+0xa4>

    Radio.SetChannel( frequency );
 8037f70:	68f3      	ldr	r3, [r6, #12]
    phyDr = DataratesUS915[dr];
 8037f72:	f918 b009 	ldrsb.w	fp, [r8, r9]
    Radio.SetChannel( frequency );
 8037f76:	4628      	mov	r0, r5
 8037f78:	4798      	blx	r3

    // Radio configuration
    Radio.SetRxConfig( MODEM_LORA, rxConfig->Bandwidth, phyDr, 1, 0, 8, rxConfig->WindowTimeout, false, 0, false, 0, 0, true, rxConfig->RxContinuous );
 8037f7a:	8922      	ldrh	r2, [r4, #8]
 8037f7c:	9202      	str	r2, [sp, #8]
 8037f7e:	2000      	movs	r0, #0
 8037f80:	2208      	movs	r2, #8
 8037f82:	e9cd 0200 	strd	r0, r2, [sp]
 8037f86:	7ca3      	ldrb	r3, [r4, #18]
 8037f88:	69b2      	ldr	r2, [r6, #24]
 8037f8a:	9309      	str	r3, [sp, #36]	; 0x24
 8037f8c:	2301      	movs	r3, #1
 8037f8e:	e9cd 0307 	strd	r0, r3, [sp, #28]
 8037f92:	e9cd 0005 	strd	r0, r0, [sp, #20]
 8037f96:	e9cd 0003 	strd	r0, r0, [sp, #12]
 8037f9a:	4617      	mov	r7, r2
 8037f9c:	4618      	mov	r0, r3
 8037f9e:	78a1      	ldrb	r1, [r4, #2]
 8037fa0:	465a      	mov	r2, fp
 8037fa2:	47b8      	blx	r7

    /* ST_WORKAROUND_BEGIN: Keep repeater feature */
    if( rxConfig->RepeaterSupport == true )
 8037fa4:	7c63      	ldrb	r3, [r4, #17]
 8037fa6:	44c8      	add	r8, r9
 8037fa8:	b18b      	cbz	r3, 8037fce <RegionUS915RxConfig+0x8e>
    {
        maxPayload = MaxPayloadOfDatarateRepeaterUS915[dr];
 8037faa:	f898 1060 	ldrb.w	r1, [r8, #96]	; 0x60
    else
    {
        maxPayload = MaxPayloadOfDatarateUS915[dr];
    }

    Radio.SetMaxPayloadLength( MODEM_LORA, maxPayload + LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE );
 8037fae:	6d73      	ldr	r3, [r6, #84]	; 0x54
 8037fb0:	310d      	adds	r1, #13
 8037fb2:	b2c9      	uxtb	r1, r1
 8037fb4:	2001      	movs	r0, #1
 8037fb6:	4798      	blx	r3
    /* ST_WORKAROUND_END */

    /* ST_WORKAROUND_BEGIN: Print Rx config */
    RegionCommonRxConfigPrint(rxConfig->RxSlot, frequency, dr);
 8037fb8:	7ce0      	ldrb	r0, [r4, #19]
 8037fba:	464a      	mov	r2, r9
 8037fbc:	4629      	mov	r1, r5
 8037fbe:	f7fe ffd3 	bl	8036f68 <RegionCommonRxConfigPrint>
    /* ST_WORKAROUND_END */

    *datarate = (uint8_t) dr;
 8037fc2:	f88a 9000 	strb.w	r9, [sl]
    return true;
 8037fc6:	2001      	movs	r0, #1
#else
    return false;
#endif /* REGION_US915 */
}
 8037fc8:	b00b      	add	sp, #44	; 0x2c
 8037fca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        maxPayload = MaxPayloadOfDatarateUS915[dr];
 8037fce:	f898 1050 	ldrb.w	r1, [r8, #80]	; 0x50
 8037fd2:	e7ec      	b.n	8037fae <RegionUS915RxConfig+0x6e>
        return false;
 8037fd4:	2000      	movs	r0, #0
 8037fd6:	e7f7      	b.n	8037fc8 <RegionUS915RxConfig+0x88>
 8037fd8:	0803bbd8 	.word	0x0803bbd8
 8037fdc:	000927c0 	.word	0x000927c0
 8037fe0:	370870a0 	.word	0x370870a0
 8037fe4:	0803bb00 	.word	0x0803bb00

08037fe8 <RegionUS915TxConfig>:

bool RegionUS915TxConfig( TxConfigParams_t* txConfig, int8_t* txPower, TimerTime_t* txTimeOnAir )
{
 8037fe8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if defined( REGION_US915 )
    int8_t phyDr = DataratesUS915[txConfig->Datarate];
    int8_t txPowerLimited = LimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower, txConfig->Datarate, RegionNvmGroup2->ChannelsMask );
 8037fec:	4e3d      	ldr	r6, [pc, #244]	; (80380e4 <RegionUS915TxConfig+0xfc>)
    int8_t phyDr = DataratesUS915[txConfig->Datarate];
 8037fee:	f990 b001 	ldrsb.w	fp, [r0, #1]
 8037ff2:	4b3d      	ldr	r3, [pc, #244]	; (80380e8 <RegionUS915TxConfig+0x100>)
    int8_t txPowerLimited = LimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower, txConfig->Datarate, RegionNvmGroup2->ChannelsMask );
 8037ff4:	f990 8002 	ldrsb.w	r8, [r0, #2]
    int8_t phyDr = DataratesUS915[txConfig->Datarate];
 8037ff8:	f913 700b 	ldrsb.w	r7, [r3, fp]
    int8_t txPowerLimited = LimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower, txConfig->Datarate, RegionNvmGroup2->ChannelsMask );
 8037ffc:	7803      	ldrb	r3, [r0, #0]
{
 8037ffe:	b08f      	sub	sp, #60	; 0x3c
 8038000:	4692      	mov	sl, r2
    int8_t txPowerLimited = LimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower, txConfig->Datarate, RegionNvmGroup2->ChannelsMask );
 8038002:	e9d6 9200 	ldrd	r9, r2, [r6]
{
 8038006:	910b      	str	r1, [sp, #44]	; 0x2c
    int8_t txPowerLimited = LimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower, txConfig->Datarate, RegionNvmGroup2->ChannelsMask );
 8038008:	210c      	movs	r1, #12
 803800a:	fb01 9303 	mla	r3, r1, r3, r9
 803800e:	2118      	movs	r1, #24
 8038010:	7a5b      	ldrb	r3, [r3, #9]
 8038012:	fb01 2303 	mla	r3, r1, r3, r2
{
 8038016:	4604      	mov	r4, r0
    txPowerResult =  RegionCommonLimitTxPower( txPower, maxBandTxPower );
 8038018:	f993 1002 	ldrsb.w	r1, [r3, #2]
 803801c:	4640      	mov	r0, r8
 803801e:	f7fe ff8d 	bl	8036f3c <RegionCommonLimitTxPower>
    if( datarate == DR_4 )
 8038022:	f1bb 0f04 	cmp.w	fp, #4
    txPowerResult =  RegionCommonLimitTxPower( txPower, maxBandTxPower );
 8038026:	4605      	mov	r5, r0
    if( datarate == DR_4 )
 8038028:	d14e      	bne.n	80380c8 <RegionUS915TxConfig+0xe0>
        txPowerResult = MAX( txPower, TX_POWER_2 );
 803802a:	4645      	mov	r5, r8
 803802c:	2d02      	cmp	r5, #2
 803802e:	bfb8      	it	lt
 8038030:	2502      	movlt	r5, #2
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsUS915 );
 8038032:	492e      	ldr	r1, [pc, #184]	; (80380ec <RegionUS915TxConfig+0x104>)
 8038034:	f994 0001 	ldrsb.w	r0, [r4, #1]

    // Calculate physical TX power
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );

    // Setup the radio frequency
    Radio.SetChannel( RegionNvmGroup2->Channels[txConfig->Channel].Frequency );
 8038038:	f8df b0b8 	ldr.w	fp, [pc, #184]	; 80380f4 <RegionUS915TxConfig+0x10c>
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsUS915 );
 803803c:	f7fe ff82 	bl	8036f44 <RegionCommonGetBandwidth>
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );
 8038040:	492b      	ldr	r1, [pc, #172]	; (80380f0 <RegionUS915TxConfig+0x108>)
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsUS915 );
 8038042:	900d      	str	r0, [sp, #52]	; 0x34
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );
 8038044:	2200      	movs	r2, #0
 8038046:	4628      	mov	r0, r5
 8038048:	f7fe fead 	bl	8036da6 <RegionCommonComputeTxPower>
    Radio.SetChannel( RegionNvmGroup2->Channels[txConfig->Channel].Frequency );
 803804c:	f894 c000 	ldrb.w	ip, [r4]
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );
 8038050:	900c      	str	r0, [sp, #48]	; 0x30
    Radio.SetChannel( RegionNvmGroup2->Channels[txConfig->Channel].Frequency );
 8038052:	f04f 090c 	mov.w	r9, #12
 8038056:	fb09 fc0c 	mul.w	ip, r9, ip
 803805a:	6830      	ldr	r0, [r6, #0]
 803805c:	f8db 200c 	ldr.w	r2, [fp, #12]
 8038060:	f850 000c 	ldr.w	r0, [r0, ip]
 8038064:	4790      	blx	r2

    Radio.SetTxConfig( MODEM_LORA, phyTxPower, 0, bandwidth, phyDr, 1, 8, false, true, 0, 0, false, 4000 );
 8038066:	f04f 0801 	mov.w	r8, #1
 803806a:	2200      	movs	r2, #0
 803806c:	f44f 637a 	mov.w	r3, #4000	; 0xfa0
 8038070:	2008      	movs	r0, #8
 8038072:	e9cd 2307 	strd	r2, r3, [sp, #28]
 8038076:	e9cd 2205 	strd	r2, r2, [sp, #20]
 803807a:	e9dd 130c 	ldrd	r1, r3, [sp, #48]	; 0x30
 803807e:	e9cd 2803 	strd	r2, r8, [sp, #12]
 8038082:	e9cd 8001 	strd	r8, r0, [sp, #4]
 8038086:	9700      	str	r7, [sp, #0]
 8038088:	4640      	mov	r0, r8
 803808a:	f8db 701c 	ldr.w	r7, [fp, #28]
 803808e:	47b8      	blx	r7
    /* ST_WORKAROUND_BEGIN: Print Tx config */
    RegionCommonTxConfigPrint(RegionNvmGroup2->Channels[txConfig->Channel].Frequency, txConfig->Datarate);
 8038090:	7822      	ldrb	r2, [r4, #0]
 8038092:	6833      	ldr	r3, [r6, #0]
 8038094:	f994 1001 	ldrsb.w	r1, [r4, #1]
 8038098:	fb09 f902 	mul.w	r9, r9, r2
 803809c:	f853 0009 	ldr.w	r0, [r3, r9]
 80380a0:	f7fe ff90 	bl	8036fc4 <RegionCommonTxConfigPrint>
    /* ST_WORKAROUND_END */

    // Setup maximum payload length of the radio driver
    Radio.SetMaxPayloadLength( MODEM_LORA, txConfig->PktLen );
 80380a4:	f8db 3054 	ldr.w	r3, [fp, #84]	; 0x54
 80380a8:	7b21      	ldrb	r1, [r4, #12]
 80380aa:	4640      	mov	r0, r8
 80380ac:	4798      	blx	r3

    // Update time-on-air
    *txTimeOnAir = GetTimeOnAir( txConfig->Datarate, txConfig->PktLen );
 80380ae:	89a1      	ldrh	r1, [r4, #12]
 80380b0:	f994 0001 	ldrsb.w	r0, [r4, #1]
 80380b4:	f7ff fd12 	bl	8037adc <GetTimeOnAir>

    *txPower = txPowerLimited;
 80380b8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    *txTimeOnAir = GetTimeOnAir( txConfig->Datarate, txConfig->PktLen );
 80380ba:	f8ca 0000 	str.w	r0, [sl]
    return true;
#else
    return false;
#endif /* REGION_US915 */
}
 80380be:	4640      	mov	r0, r8
    *txPower = txPowerLimited;
 80380c0:	701d      	strb	r5, [r3, #0]
}
 80380c2:	b00f      	add	sp, #60	; 0x3c
 80380c4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if( RegionCommonCountChannels( channelsMask, 0, 4 ) < 50 )
 80380c8:	2204      	movs	r2, #4
 80380ca:	2100      	movs	r1, #0
 80380cc:	f509 7058 	add.w	r0, r9, #864	; 0x360
 80380d0:	f7fe fc9b 	bl	8036a0a <RegionCommonCountChannels>
 80380d4:	2831      	cmp	r0, #49	; 0x31
 80380d6:	d8ac      	bhi.n	8038032 <RegionUS915TxConfig+0x4a>
            txPowerResult = MAX( txPower, TX_POWER_5 );
 80380d8:	4645      	mov	r5, r8
 80380da:	2d05      	cmp	r5, #5
 80380dc:	bfb8      	it	lt
 80380de:	2505      	movlt	r5, #5
 80380e0:	e7a7      	b.n	8038032 <RegionUS915TxConfig+0x4a>
 80380e2:	bf00      	nop
 80380e4:	20005730 	.word	0x20005730
 80380e8:	0803bb00 	.word	0x0803bb00
 80380ec:	0803bb10 	.word	0x0803bb10
 80380f0:	41f00000 	.word	0x41f00000
 80380f4:	0803bbd8 	.word	0x0803bbd8

080380f8 <RegionUS915LinkAdrReq>:

uint8_t RegionUS915LinkAdrReq( LinkAdrReqParams_t* linkAdrReq, int8_t* drOut, int8_t* txPowOut, uint8_t* nbRepOut, uint8_t* nbBytesParsed )
{
 80380f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;
    RegionCommonLinkAdrReqVerifyParams_t linkAdrVerifyParams;

    // Initialize local copy of channels mask
    RegionCommonChanMaskCopy( channelsMask, RegionNvmGroup2->ChannelsMask, CHANNELS_MASK_SIZE );
 80380fc:	4e88      	ldr	r6, [pc, #544]	; (8038320 <RegionUS915LinkAdrReq+0x228>)
{
 80380fe:	b095      	sub	sp, #84	; 0x54
 8038100:	e9cd 1201 	strd	r1, r2, [sp, #4]
    RegionCommonChanMaskCopy( channelsMask, RegionNvmGroup2->ChannelsMask, CHANNELS_MASK_SIZE );
 8038104:	6831      	ldr	r1, [r6, #0]
{
 8038106:	9303      	str	r3, [sp, #12]
    uint16_t channelsMask[CHANNELS_MASK_SIZE] = { 0, 0, 0, 0, 0, 0 };
 8038108:	af09      	add	r7, sp, #36	; 0x24
    RegionCommonLinkAdrParams_t linkAdrParams = { 0 };
 803810a:	2400      	movs	r4, #0
{
 803810c:	4605      	mov	r5, r0
    RegionCommonChanMaskCopy( channelsMask, RegionNvmGroup2->ChannelsMask, CHANNELS_MASK_SIZE );
 803810e:	2206      	movs	r2, #6
 8038110:	f501 7158 	add.w	r1, r1, #864	; 0x360
 8038114:	4638      	mov	r0, r7
    uint16_t channelsMask[CHANNELS_MASK_SIZE] = { 0, 0, 0, 0, 0, 0 };
 8038116:	e9c7 4401 	strd	r4, r4, [r7, #4]
    RegionCommonLinkAdrParams_t linkAdrParams = { 0 };
 803811a:	9407      	str	r4, [sp, #28]
 803811c:	f8ad 4020 	strh.w	r4, [sp, #32]
    uint16_t channelsMask[CHANNELS_MASK_SIZE] = { 0, 0, 0, 0, 0, 0 };
 8038120:	9409      	str	r4, [sp, #36]	; 0x24
    RegionCommonChanMaskCopy( channelsMask, RegionNvmGroup2->ChannelsMask, CHANNELS_MASK_SIZE );
 8038122:	f7fe fc90 	bl	8036a46 <RegionCommonChanMaskCopy>
            channelsMask[4] = linkAdrParams.ChMask & CHANNELS_MASK_500KHZ_MASK;
        }
        else if( linkAdrParams.ChMaskCtrl == 7 )
        {
            // Disable all 125 kHz channels
            channelsMask[0] = 0x0000;
 8038126:	46a0      	mov	r8, r4
            channelsMask[0] = 0xFFFF;
 8038128:	f04f 39ff 	mov.w	r9, #4294967295
    while( bytesProcessed < linkAdrReq->PayloadSize )
 803812c:	7a2b      	ldrb	r3, [r5, #8]
 803812e:	42a3      	cmp	r3, r4
 8038130:	d907      	bls.n	8038142 <RegionUS915LinkAdrReq+0x4a>
        nextIndex = RegionCommonParseLinkAdrReq( &( linkAdrReq->Payload[bytesProcessed] ), &linkAdrParams );
 8038132:	6868      	ldr	r0, [r5, #4]
 8038134:	a907      	add	r1, sp, #28
 8038136:	4420      	add	r0, r4
 8038138:	f7fe fda6 	bl	8036c88 <RegionCommonParseLinkAdrReq>
        if( nextIndex == 0 )
 803813c:	2800      	cmp	r0, #0
 803813e:	f040 808c 	bne.w	803825a <RegionUS915LinkAdrReq+0x162>
            channelsMask[linkAdrParams.ChMaskCtrl] = linkAdrParams.ChMask;
        }
    }

    // FCC 15.247 paragraph F mandates to hop on at least 2 125 kHz channels
    if( ( linkAdrParams.Datarate < DR_4 ) && ( RegionCommonCountChannels( channelsMask, 0, 4 ) < 2 ) )
 8038142:	f99d 301d 	ldrsb.w	r3, [sp, #29]
 8038146:	2b03      	cmp	r3, #3
 8038148:	dc07      	bgt.n	803815a <RegionUS915LinkAdrReq+0x62>
 803814a:	2204      	movs	r2, #4
 803814c:	2100      	movs	r1, #0
 803814e:	a809      	add	r0, sp, #36	; 0x24
 8038150:	f7fe fc5b 	bl	8036a0a <RegionCommonCountChannels>
 8038154:	2801      	cmp	r0, #1
 8038156:	f240 80df 	bls.w	8038318 <RegionUS915LinkAdrReq+0x220>
    uint8_t bytesProcessed = 0;
 803815a:	f04f 0807 	mov.w	r8, #7
    {
        status &= 0xFE; // Channel mask KO
    }

    // Get the minimum possible datarate
    getPhy.Attribute = PHY_MIN_TX_DR;
 803815e:	2302      	movs	r3, #2
 8038160:	f88d 3014 	strb.w	r3, [sp, #20]
    getPhy.UplinkDwellTime = linkAdrReq->UplinkDwellTime;
    phyParam = RegionUS915GetPhyParam( &getPhy );
 8038164:	a805      	add	r0, sp, #20
    getPhy.UplinkDwellTime = linkAdrReq->UplinkDwellTime;
 8038166:	7a6b      	ldrb	r3, [r5, #9]
 8038168:	f88d 3016 	strb.w	r3, [sp, #22]
    phyParam = RegionUS915GetPhyParam( &getPhy );
 803816c:	f7ff fcf2 	bl	8037b54 <RegionUS915GetPhyParam>

    linkAdrVerifyParams.Status = status;
    linkAdrVerifyParams.AdrEnabled = linkAdrReq->AdrEnabled;
 8038170:	7aab      	ldrb	r3, [r5, #10]
 8038172:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
    linkAdrVerifyParams.Datarate = linkAdrParams.Datarate;
 8038176:	f89d 301d 	ldrb.w	r3, [sp, #29]
 803817a:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    linkAdrVerifyParams.TxPower = linkAdrParams.TxPower;
 803817e:	f89d 301e 	ldrb.w	r3, [sp, #30]
 8038182:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    linkAdrVerifyParams.NbRep = linkAdrParams.NbRep;
 8038186:	f89d 301c 	ldrb.w	r3, [sp, #28]
 803818a:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
    linkAdrVerifyParams.CurrentDatarate = linkAdrReq->CurrentDatarate;
 803818e:	7aeb      	ldrb	r3, [r5, #11]
 8038190:	f88d 3039 	strb.w	r3, [sp, #57]	; 0x39
    linkAdrVerifyParams.CurrentTxPower = linkAdrReq->CurrentTxPower;
 8038194:	7b2b      	ldrb	r3, [r5, #12]
 8038196:	f88d 303a 	strb.w	r3, [sp, #58]	; 0x3a
    linkAdrVerifyParams.CurrentNbRep = linkAdrReq->CurrentNbRep;
 803819a:	7b6b      	ldrb	r3, [r5, #13]
 803819c:	f88d 303b 	strb.w	r3, [sp, #59]	; 0x3b
    linkAdrVerifyParams.NbChannels = US915_MAX_NB_CHANNELS;
 80381a0:	2348      	movs	r3, #72	; 0x48
 80381a2:	f88d 303c 	strb.w	r3, [sp, #60]	; 0x3c
    linkAdrVerifyParams.ChannelsMask = channelsMask;
    linkAdrVerifyParams.MinDatarate = ( int8_t )phyParam.Value;
    linkAdrVerifyParams.MaxDatarate = US915_TX_MAX_DATARATE;
 80381a6:	2304      	movs	r3, #4
 80381a8:	f88d 3045 	strb.w	r3, [sp, #69]	; 0x45
    linkAdrVerifyParams.Channels = RegionNvmGroup2->Channels;
 80381ac:	6833      	ldr	r3, [r6, #0]
 80381ae:	9312      	str	r3, [sp, #72]	; 0x48
    linkAdrVerifyParams.MinTxPower = US915_MIN_TX_POWER;
 80381b0:	230e      	movs	r3, #14
 80381b2:	f8ad 304c 	strh.w	r3, [sp, #76]	; 0x4c
    linkAdrVerifyParams.MaxTxPower = US915_MAX_TX_POWER;
    linkAdrVerifyParams.Version = linkAdrReq->Version;
 80381b6:	682b      	ldr	r3, [r5, #0]
    phyParam = RegionUS915GetPhyParam( &getPhy );
 80381b8:	9004      	str	r0, [sp, #16]
    linkAdrVerifyParams.MinDatarate = ( int8_t )phyParam.Value;
 80381ba:	f88d 0044 	strb.w	r0, [sp, #68]	; 0x44
    linkAdrVerifyParams.Version = linkAdrReq->Version;
 80381be:	930c      	str	r3, [sp, #48]	; 0x30

    // Verify the parameters and update, if necessary
    status = RegionCommonLinkAdrReqVerifyParams( &linkAdrVerifyParams, &linkAdrParams.Datarate, &linkAdrParams.TxPower, &linkAdrParams.NbRep );
 80381c0:	f10d 021e 	add.w	r2, sp, #30
 80381c4:	ab07      	add	r3, sp, #28
 80381c6:	f10d 011d 	add.w	r1, sp, #29
 80381ca:	a80c      	add	r0, sp, #48	; 0x30
    linkAdrVerifyParams.Status = status;
 80381cc:	f88d 8034 	strb.w	r8, [sp, #52]	; 0x34
    linkAdrVerifyParams.ChannelsMask = channelsMask;
 80381d0:	9710      	str	r7, [sp, #64]	; 0x40
    status = RegionCommonLinkAdrReqVerifyParams( &linkAdrVerifyParams, &linkAdrParams.Datarate, &linkAdrParams.TxPower, &linkAdrParams.NbRep );
 80381d2:	f7fe fd73 	bl	8036cbc <RegionCommonLinkAdrReqVerifyParams>

    // Update channelsMask if everything is correct
    if( status == 0x07 )
 80381d6:	2807      	cmp	r0, #7
    status = RegionCommonLinkAdrReqVerifyParams( &linkAdrVerifyParams, &linkAdrParams.Datarate, &linkAdrParams.TxPower, &linkAdrParams.NbRep );
 80381d8:	4605      	mov	r5, r0
    if( status == 0x07 )
 80381da:	d12c      	bne.n	8038236 <RegionUS915LinkAdrReq+0x13e>
    {
        // Copy Mask
        RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, channelsMask, 6 );
 80381dc:	6830      	ldr	r0, [r6, #0]
 80381de:	2206      	movs	r2, #6
 80381e0:	4639      	mov	r1, r7
 80381e2:	f500 7058 	add.w	r0, r0, #864	; 0x360
 80381e6:	f7fe fc2e 	bl	8036a46 <RegionCommonChanMaskCopy>

        RegionNvmGroup1->ChannelsMaskRemaining[0] &= RegionNvmGroup2->ChannelsMask[0];
 80381ea:	e9d6 2300 	ldrd	r2, r3, [r6]
 80381ee:	f8b2 0360 	ldrh.w	r0, [r2, #864]	; 0x360
 80381f2:	f8b3 1090 	ldrh.w	r1, [r3, #144]	; 0x90
 80381f6:	4001      	ands	r1, r0
 80381f8:	f8a3 1090 	strh.w	r1, [r3, #144]	; 0x90
        RegionNvmGroup1->ChannelsMaskRemaining[1] &= RegionNvmGroup2->ChannelsMask[1];
 80381fc:	f8b2 0362 	ldrh.w	r0, [r2, #866]	; 0x362
 8038200:	f8b3 1092 	ldrh.w	r1, [r3, #146]	; 0x92
 8038204:	4001      	ands	r1, r0
 8038206:	f8a3 1092 	strh.w	r1, [r3, #146]	; 0x92
        RegionNvmGroup1->ChannelsMaskRemaining[2] &= RegionNvmGroup2->ChannelsMask[2];
 803820a:	f8b2 0364 	ldrh.w	r0, [r2, #868]	; 0x364
 803820e:	f8b3 1094 	ldrh.w	r1, [r3, #148]	; 0x94
 8038212:	4001      	ands	r1, r0
 8038214:	f8a3 1094 	strh.w	r1, [r3, #148]	; 0x94
        RegionNvmGroup1->ChannelsMaskRemaining[3] &= RegionNvmGroup2->ChannelsMask[3];
 8038218:	f8b2 0366 	ldrh.w	r0, [r2, #870]	; 0x366
 803821c:	f8b3 1096 	ldrh.w	r1, [r3, #150]	; 0x96
 8038220:	4001      	ands	r1, r0
 8038222:	f8a3 1096 	strh.w	r1, [r3, #150]	; 0x96
        RegionNvmGroup1->ChannelsMaskRemaining[4] = RegionNvmGroup2->ChannelsMask[4];
 8038226:	f8b2 1368 	ldrh.w	r1, [r2, #872]	; 0x368
        RegionNvmGroup1->ChannelsMaskRemaining[5] = RegionNvmGroup2->ChannelsMask[5];
 803822a:	f8b2 236a 	ldrh.w	r2, [r2, #874]	; 0x36a
        RegionNvmGroup1->ChannelsMaskRemaining[4] = RegionNvmGroup2->ChannelsMask[4];
 803822e:	f8a3 1098 	strh.w	r1, [r3, #152]	; 0x98
        RegionNvmGroup1->ChannelsMaskRemaining[5] = RegionNvmGroup2->ChannelsMask[5];
 8038232:	f8a3 209a 	strh.w	r2, [r3, #154]	; 0x9a
    }

    // Update status variables
    *drOut = linkAdrParams.Datarate;
 8038236:	9a01      	ldr	r2, [sp, #4]
 8038238:	f89d 301d 	ldrb.w	r3, [sp, #29]
 803823c:	7013      	strb	r3, [r2, #0]
    *txPowOut = linkAdrParams.TxPower;
 803823e:	9a02      	ldr	r2, [sp, #8]
 8038240:	f89d 301e 	ldrb.w	r3, [sp, #30]
 8038244:	7013      	strb	r3, [r2, #0]
    *nbRepOut = linkAdrParams.NbRep;
 8038246:	9a03      	ldr	r2, [sp, #12]
 8038248:	f89d 301c 	ldrb.w	r3, [sp, #28]
 803824c:	7013      	strb	r3, [r2, #0]
    *nbBytesParsed = bytesProcessed;
 803824e:	9b1e      	ldr	r3, [sp, #120]	; 0x78

#endif /* REGION_US915 */
    return status;
}
 8038250:	4628      	mov	r0, r5
    *nbBytesParsed = bytesProcessed;
 8038252:	701c      	strb	r4, [r3, #0]
}
 8038254:	b015      	add	sp, #84	; 0x54
 8038256:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if( linkAdrParams.ChMaskCtrl == 6 )
 803825a:	f89d 301f 	ldrb.w	r3, [sp, #31]
 803825e:	f8bd 2020 	ldrh.w	r2, [sp, #32]
        bytesProcessed += nextIndex;
 8038262:	4404      	add	r4, r0
        if( linkAdrParams.ChMaskCtrl == 6 )
 8038264:	2b06      	cmp	r3, #6
        bytesProcessed += nextIndex;
 8038266:	b2e4      	uxtb	r4, r4
        if( linkAdrParams.ChMaskCtrl == 6 )
 8038268:	d105      	bne.n	8038276 <RegionUS915LinkAdrReq+0x17e>
            channelsMask[2] = 0xFFFF;
 803826a:	e9cd 9909 	strd	r9, r9, [sp, #36]	; 0x24
            channelsMask[4] = linkAdrParams.ChMask & CHANNELS_MASK_500KHZ_MASK;
 803826e:	b2d2      	uxtb	r2, r2
 8038270:	f8ad 202c 	strh.w	r2, [sp, #44]	; 0x2c
 8038274:	e75a      	b.n	803812c <RegionUS915LinkAdrReq+0x34>
        else if( linkAdrParams.ChMaskCtrl == 7 )
 8038276:	2b07      	cmp	r3, #7
 8038278:	d102      	bne.n	8038280 <RegionUS915LinkAdrReq+0x188>
            channelsMask[2] = 0x0000;
 803827a:	e9cd 8809 	strd	r8, r8, [sp, #36]	; 0x24
 803827e:	e7f6      	b.n	803826e <RegionUS915LinkAdrReq+0x176>
        else if( linkAdrParams.ChMaskCtrl == 5 )
 8038280:	2b05      	cmp	r3, #5
 8038282:	d143      	bne.n	803830c <RegionUS915LinkAdrReq+0x214>
                if( ( ( linkAdrParams.ChMask & 0x00FF ) & ( bitMask << i ) ) != 0 )
 8038284:	f04f 0c00 	mov.w	ip, #0
 8038288:	b2d2      	uxtb	r2, r2
            uint8_t cntChannelMask = 0;
 803828a:	4661      	mov	r1, ip
                if( ( ( linkAdrParams.ChMask & 0x00FF ) & ( bitMask << i ) ) != 0 )
 803828c:	2301      	movs	r3, #1
 803828e:	fa03 fa0c 	lsl.w	sl, r3, ip
 8038292:	ea0c 0b03 	and.w	fp, ip, r3
 8038296:	ab14      	add	r3, sp, #80	; 0x50
 8038298:	eb03 0e41 	add.w	lr, r3, r1, lsl #1
 803829c:	ea12 0f0a 	tst.w	r2, sl
 80382a0:	f83e 3c2c 	ldrh.w	r3, [lr, #-44]
 80382a4:	fa0f f08a 	sxth.w	r0, sl
 80382a8:	d01d      	beq.n	80382e6 <RegionUS915LinkAdrReq+0x1ee>
                    if( ( i % 2 ) == 0 )
 80382aa:	f1bb 0f00 	cmp.w	fp, #0
 80382ae:	d10e      	bne.n	80382ce <RegionUS915LinkAdrReq+0x1d6>
                        channelsMask[cntChannelMask] |= 0x00FF;
 80382b0:	f043 03ff 	orr.w	r3, r3, #255	; 0xff
 80382b4:	f82e 3c2c 	strh.w	r3, [lr, #-44]
                        channelsMask[4] |= ( bitMask << i );
 80382b8:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
 80382bc:	4318      	orrs	r0, r3
                        channelsMask[4] &= ~( bitMask << i );
 80382be:	f8ad 002c 	strh.w	r0, [sp, #44]	; 0x2c
            for( uint8_t i = 0; i <= 7; i++ )
 80382c2:	f10c 0c01 	add.w	ip, ip, #1
 80382c6:	f1bc 0f08 	cmp.w	ip, #8
 80382ca:	d1df      	bne.n	803828c <RegionUS915LinkAdrReq+0x194>
 80382cc:	e72e      	b.n	803812c <RegionUS915LinkAdrReq+0x34>
                        channelsMask[cntChannelMask] |= 0xFF00;
 80382ce:	f063 03ff 	orn	r3, r3, #255	; 0xff
 80382d2:	f82e 3c2c 	strh.w	r3, [lr, #-44]
                        channelsMask[4] |= ( bitMask << i );
 80382d6:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
 80382da:	4318      	orrs	r0, r3
                        cntChannelMask++;
 80382dc:	3101      	adds	r1, #1
                        channelsMask[4] &= ~( bitMask << i );
 80382de:	f8ad 002c 	strh.w	r0, [sp, #44]	; 0x2c
                        cntChannelMask++;
 80382e2:	b2c9      	uxtb	r1, r1
 80382e4:	e7ed      	b.n	80382c2 <RegionUS915LinkAdrReq+0x1ca>
                    if( ( i % 2 ) == 0 )
 80382e6:	43c0      	mvns	r0, r0
 80382e8:	f1bb 0f00 	cmp.w	fp, #0
 80382ec:	d107      	bne.n	80382fe <RegionUS915LinkAdrReq+0x206>
                        channelsMask[cntChannelMask] &= 0xFF00;
 80382ee:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 80382f2:	f82e 3c2c 	strh.w	r3, [lr, #-44]
                        channelsMask[4] &= ~( bitMask << i );
 80382f6:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
 80382fa:	4018      	ands	r0, r3
 80382fc:	e7df      	b.n	80382be <RegionUS915LinkAdrReq+0x1c6>
                        channelsMask[cntChannelMask] &= 0x00FF;
 80382fe:	b2db      	uxtb	r3, r3
 8038300:	f82e 3c2c 	strh.w	r3, [lr, #-44]
                        channelsMask[4] &= ~( bitMask << i );
 8038304:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
 8038308:	4018      	ands	r0, r3
 803830a:	e7e7      	b.n	80382dc <RegionUS915LinkAdrReq+0x1e4>
            channelsMask[linkAdrParams.ChMaskCtrl] = linkAdrParams.ChMask;
 803830c:	a914      	add	r1, sp, #80	; 0x50
 803830e:	eb01 0343 	add.w	r3, r1, r3, lsl #1
 8038312:	f823 2c2c 	strh.w	r2, [r3, #-44]
 8038316:	e709      	b.n	803812c <RegionUS915LinkAdrReq+0x34>
        status &= 0xFE; // Channel mask KO
 8038318:	f04f 0806 	mov.w	r8, #6
 803831c:	e71f      	b.n	803815e <RegionUS915LinkAdrReq+0x66>
 803831e:	bf00      	nop
 8038320:	20005730 	.word	0x20005730

08038324 <RegionUS915RxParamSetupReq>:

uint8_t RegionUS915RxParamSetupReq( RxParamSetupReqParams_t* rxParamSetupReq )
{
 8038324:	b538      	push	{r3, r4, r5, lr}
 8038326:	4605      	mov	r5, r0
    uint8_t status = 0x07;
#if defined( REGION_US915 )

    // Verify radio frequency
    if( VerifyRfFreq( rxParamSetupReq->Frequency ) == false )
 8038328:	6840      	ldr	r0, [r0, #4]
 803832a:	f7ff fbf3 	bl	8037b14 <VerifyRfFreq>
    {
        status &= 0xFE; // Channel frequency KO
    }

    // Verify datarate
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, US915_RX_MIN_DATARATE, US915_RX_MAX_DATARATE ) == false )
 803832e:	220d      	movs	r2, #13
        status &= 0xFE; // Channel frequency KO
 8038330:	2800      	cmp	r0, #0
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, US915_RX_MIN_DATARATE, US915_RX_MAX_DATARATE ) == false )
 8038332:	f04f 0108 	mov.w	r1, #8
 8038336:	f995 0000 	ldrsb.w	r0, [r5]
        status &= 0xFE; // Channel frequency KO
 803833a:	bf14      	ite	ne
 803833c:	2407      	movne	r4, #7
 803833e:	2406      	moveq	r4, #6
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, US915_RX_MIN_DATARATE, US915_RX_MAX_DATARATE ) == false )
 8038340:	f7fe fb41 	bl	80369c6 <RegionCommonValueInRange>
 8038344:	b908      	cbnz	r0, 803834a <RegionUS915RxParamSetupReq+0x26>
    {
        status &= 0xFD; // Datarate KO
 8038346:	f004 0405 	and.w	r4, r4, #5
    }
    if( ( RegionCommonValueInRange( rxParamSetupReq->Datarate, DR_5, DR_7 ) == true ) ||
 803834a:	f995 0000 	ldrsb.w	r0, [r5]
 803834e:	2207      	movs	r2, #7
 8038350:	2105      	movs	r1, #5
 8038352:	f7fe fb38 	bl	80369c6 <RegionCommonValueInRange>
 8038356:	2801      	cmp	r0, #1
 8038358:	d003      	beq.n	8038362 <RegionUS915RxParamSetupReq+0x3e>
 803835a:	f995 3000 	ldrsb.w	r3, [r5]
 803835e:	2b0d      	cmp	r3, #13
 8038360:	dd01      	ble.n	8038366 <RegionUS915RxParamSetupReq+0x42>
        ( rxParamSetupReq->Datarate > DR_13 ) )
    {
        status &= 0xFD; // Datarate KO
 8038362:	f004 04fd 	and.w	r4, r4, #253	; 0xfd
    }

    // Verify datarate offset
    if( RegionCommonValueInRange( rxParamSetupReq->DrOffset, US915_MIN_RX1_DR_OFFSET, US915_MAX_RX1_DR_OFFSET ) == false )
 8038366:	f995 0001 	ldrsb.w	r0, [r5, #1]
 803836a:	2203      	movs	r2, #3
 803836c:	2100      	movs	r1, #0
 803836e:	f7fe fb2a 	bl	80369c6 <RegionCommonValueInRange>
 8038372:	b908      	cbnz	r0, 8038378 <RegionUS915RxParamSetupReq+0x54>
    {
        status &= 0xFB; // Rx1DrOffset range KO
 8038374:	f004 04fb 	and.w	r4, r4, #251	; 0xfb
    }

#endif /* REGION_US915 */
    return status;
}
 8038378:	4620      	mov	r0, r4
 803837a:	bd38      	pop	{r3, r4, r5, pc}

0803837c <RegionUS915NewChannelReq>:

int8_t RegionUS915NewChannelReq( NewChannelReqParams_t* newChannelReq )
{
    // Do not accept the request
    return -1;
}
 803837c:	f04f 30ff 	mov.w	r0, #4294967295
 8038380:	4770      	bx	lr

08038382 <RegionUS915TxParamSetupReq>:
 8038382:	f04f 30ff 	mov.w	r0, #4294967295
 8038386:	4770      	bx	lr

08038388 <RegionUS915DlChannelReq>:
 8038388:	f04f 30ff 	mov.w	r0, #4294967295
 803838c:	4770      	bx	lr
	...

08038390 <RegionUS915AlternateDr>:
int8_t RegionUS915AlternateDr( int8_t currentDr, AlternateDrType_t type )
{
#if defined( REGION_US915 )
    // Alternates the data rate according to the channel sequence:
    // Eight times a 125kHz DR_0 and then one 500kHz DR_4 channel
    if( type == ALTERNATE_DR )
 8038390:	4b0a      	ldr	r3, [pc, #40]	; (80383bc <RegionUS915AlternateDr+0x2c>)
 8038392:	685a      	ldr	r2, [r3, #4]
 8038394:	f892 309d 	ldrb.w	r3, [r2, #157]	; 0x9d
 8038398:	b971      	cbnz	r1, 80383b8 <RegionUS915AlternateDr+0x28>
    {
        RegionNvmGroup1->JoinTrialsCounter++;
 803839a:	3301      	adds	r3, #1
    }
    else
    {
        RegionNvmGroup1->JoinTrialsCounter--;
 803839c:	f882 309d 	strb.w	r3, [r2, #157]	; 0x9d
 80383a0:	f892 309d 	ldrb.w	r3, [r2, #157]	; 0x9d
 80383a4:	ebc3 02c3 	rsb	r2, r3, r3, lsl #3
 80383a8:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    }

    if( RegionNvmGroup1->JoinTrialsCounter % 9 == 0 )
 80383ac:	b2db      	uxtb	r3, r3
        // Use DR_4 every 9th times.
        currentDr = DR_4;
    }
    else
    {
        currentDr = DR_0;
 80383ae:	2b1d      	cmp	r3, #29
    }
    return currentDr;
#else
    return -1;
#endif /* REGION_US915 */
}
 80383b0:	bf34      	ite	cc
 80383b2:	2004      	movcc	r0, #4
 80383b4:	2000      	movcs	r0, #0
 80383b6:	4770      	bx	lr
        RegionNvmGroup1->JoinTrialsCounter--;
 80383b8:	3b01      	subs	r3, #1
 80383ba:	e7ef      	b.n	803839c <RegionUS915AlternateDr+0xc>
 80383bc:	20005730 	.word	0x20005730

080383c0 <RegionUS915NextChannel>:

LoRaMacStatus_t RegionUS915NextChannel( NextChanParams_t* nextChanParams, uint8_t* channel, TimerTime_t* time, TimerTime_t* aggregatedTimeOff )
{
 80383c0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
#if defined( REGION_US915 )
    uint8_t nbEnabledChannels = 0;
 80383c4:	2600      	movs	r6, #0
{
 80383c6:	b0a5      	sub	sp, #148	; 0x94
    RegionCommonIdentifyChannelsParam_t identifyChannelsParam;
    RegionCommonCountNbOfEnabledChannelsParams_t countChannelsParams;
    LoRaMacStatus_t status = LORAMAC_STATUS_NO_CHANNEL_FOUND;

    // Count 125kHz channels
    if( RegionCommonCountChannels( RegionNvmGroup1->ChannelsMaskRemaining, 0, 4 ) == 0 )
 80383c8:	4d4a      	ldr	r5, [pc, #296]	; (80384f4 <RegionUS915NextChannel+0x134>)
    uint8_t nbEnabledChannels = 0;
 80383ca:	f88d 600e 	strb.w	r6, [sp, #14]
{
 80383ce:	4604      	mov	r4, r0
 80383d0:	460f      	mov	r7, r1
 80383d2:	4691      	mov	r9, r2
    uint8_t enabledChannels[US915_MAX_NB_CHANNELS] = { 0 };
 80383d4:	4631      	mov	r1, r6
 80383d6:	2244      	movs	r2, #68	; 0x44
 80383d8:	a813      	add	r0, sp, #76	; 0x4c
{
 80383da:	4698      	mov	r8, r3
    uint8_t nbRestrictedChannels = 0;
 80383dc:	f88d 600f 	strb.w	r6, [sp, #15]
    uint8_t enabledChannels[US915_MAX_NB_CHANNELS] = { 0 };
 80383e0:	9612      	str	r6, [sp, #72]	; 0x48
 80383e2:	f003 f9a5 	bl	803b730 <memset>
    if( RegionCommonCountChannels( RegionNvmGroup1->ChannelsMaskRemaining, 0, 4 ) == 0 )
 80383e6:	6868      	ldr	r0, [r5, #4]
 80383e8:	4631      	mov	r1, r6
 80383ea:	2204      	movs	r2, #4
 80383ec:	3090      	adds	r0, #144	; 0x90
 80383ee:	f7fe fb0c 	bl	8036a0a <RegionCommonCountChannels>
 80383f2:	4606      	mov	r6, r0
 80383f4:	b950      	cbnz	r0, 803840c <RegionUS915NextChannel+0x4c>
    { // Reactivate default channels
        RegionCommonChanMaskCopy( RegionNvmGroup1->ChannelsMaskRemaining, RegionNvmGroup2->ChannelsMask, 4  );
 80383f6:	e9d5 1000 	ldrd	r1, r0, [r5]
 80383fa:	2204      	movs	r2, #4
 80383fc:	f501 7158 	add.w	r1, r1, #864	; 0x360
 8038400:	3090      	adds	r0, #144	; 0x90
 8038402:	f7fe fb20 	bl	8036a46 <RegionCommonChanMaskCopy>

        RegionNvmGroup1->JoinChannelGroupsCurrentIndex = 0;
 8038406:	686b      	ldr	r3, [r5, #4]
 8038408:	f883 609c 	strb.w	r6, [r3, #156]	; 0x9c
    }
    // Check other channels
    if( nextChanParams->Datarate >= DR_4 )
 803840c:	f994 3008 	ldrsb.w	r3, [r4, #8]
 8038410:	2b03      	cmp	r3, #3
 8038412:	e9d5 2100 	ldrd	r2, r1, [r5]
 8038416:	dd06      	ble.n	8038426 <RegionUS915NextChannel+0x66>
    {
        if( ( RegionNvmGroup1->ChannelsMaskRemaining[4] & CHANNELS_MASK_500KHZ_MASK ) == 0 )
 8038418:	f891 0098 	ldrb.w	r0, [r1, #152]	; 0x98
 803841c:	b918      	cbnz	r0, 8038426 <RegionUS915NextChannel+0x66>
        {
            RegionNvmGroup1->ChannelsMaskRemaining[4] = RegionNvmGroup2->ChannelsMask[4];
 803841e:	f8b2 0368 	ldrh.w	r0, [r2, #872]	; 0x368
 8038422:	f8a1 0098 	strh.w	r0, [r1, #152]	; 0x98
        }
    }

    // Search how many channels are enabled
    countChannelsParams.Joined = nextChanParams->Joined;
 8038426:	7a60      	ldrb	r0, [r4, #9]
 8038428:	f88d 0010 	strb.w	r0, [sp, #16]
    countChannelsParams.Datarate = nextChanParams->Datarate;
    countChannelsParams.ChannelsMask = RegionNvmGroup1->ChannelsMaskRemaining;
 803842c:	f101 0090 	add.w	r0, r1, #144	; 0x90
    countChannelsParams.Channels = RegionNvmGroup2->Channels;
 8038430:	e9cd 0205 	strd	r0, r2, [sp, #20]
    countChannelsParams.Bands = RegionNvmGroup1->Bands;
    countChannelsParams.MaxNbChannels = US915_MAX_NB_CHANNELS;
 8038434:	2248      	movs	r2, #72	; 0x48
 8038436:	f8ad 2020 	strh.w	r2, [sp, #32]
    countChannelsParams.JoinChannels = NULL;
 803843a:	2200      	movs	r2, #0
 803843c:	9209      	str	r2, [sp, #36]	; 0x24

    identifyChannelsParam.AggrTimeOff = nextChanParams->AggrTimeOff;
 803843e:	6822      	ldr	r2, [r4, #0]
 8038440:	920a      	str	r2, [sp, #40]	; 0x28
    identifyChannelsParam.LastAggrTx = nextChanParams->LastAggrTx;
 8038442:	6862      	ldr	r2, [r4, #4]
    countChannelsParams.Bands = RegionNvmGroup1->Bands;
 8038444:	9107      	str	r1, [sp, #28]
    identifyChannelsParam.LastAggrTx = nextChanParams->LastAggrTx;
 8038446:	920b      	str	r2, [sp, #44]	; 0x2c
    identifyChannelsParam.DutyCycleEnabled = nextChanParams->DutyCycleEnabled;
    identifyChannelsParam.MaxBands = US915_MAX_NB_BANDS;

    identifyChannelsParam.ElapsedTimeSinceStartUp = nextChanParams->ElapsedTimeSinceStartUp;
 8038448:	e9d4 0103 	ldrd	r0, r1, [r4, #12]
    identifyChannelsParam.DutyCycleEnabled = nextChanParams->DutyCycleEnabled;
 803844c:	7aa2      	ldrb	r2, [r4, #10]
 803844e:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
    identifyChannelsParam.MaxBands = US915_MAX_NB_BANDS;
 8038452:	2201      	movs	r2, #1
 8038454:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
    identifyChannelsParam.ElapsedTimeSinceStartUp = nextChanParams->ElapsedTimeSinceStartUp;
 8038458:	aa0d      	add	r2, sp, #52	; 0x34
 803845a:	e882 0003 	stmia.w	r2, {r0, r1}
    identifyChannelsParam.LastTxIsJoinRequest = nextChanParams->LastTxIsJoinRequest;
 803845e:	7d22      	ldrb	r2, [r4, #20]
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 8038460:	8ae1      	ldrh	r1, [r4, #22]
    countChannelsParams.Datarate = nextChanParams->Datarate;
 8038462:	f88d 3011 	strb.w	r3, [sp, #17]
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 8038466:	4618      	mov	r0, r3
    identifyChannelsParam.LastTxIsJoinRequest = nextChanParams->LastTxIsJoinRequest;
 8038468:	f88d 203c 	strb.w	r2, [sp, #60]	; 0x3c
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 803846c:	f7ff fb36 	bl	8037adc <GetTimeOnAir>

    identifyChannelsParam.CountNbOfEnabledChannelsParam = &countChannelsParams;
 8038470:	ab04      	add	r3, sp, #16
 8038472:	9311      	str	r3, [sp, #68]	; 0x44

    status = RegionCommonIdentifyChannels( &identifyChannelsParam, aggregatedTimeOff, enabledChannels,
 8038474:	f10d 030f 	add.w	r3, sp, #15
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 8038478:	9010      	str	r0, [sp, #64]	; 0x40
    status = RegionCommonIdentifyChannels( &identifyChannelsParam, aggregatedTimeOff, enabledChannels,
 803847a:	9300      	str	r3, [sp, #0]
 803847c:	f8cd 9004 	str.w	r9, [sp, #4]
 8038480:	f10d 030e 	add.w	r3, sp, #14
 8038484:	aa12      	add	r2, sp, #72	; 0x48
 8038486:	4641      	mov	r1, r8
 8038488:	a80a      	add	r0, sp, #40	; 0x28
 803848a:	f7fe fcf8 	bl	8036e7e <RegionCommonIdentifyChannels>
                                           &nbEnabledChannels, &nbRestrictedChannels, time );

    if( status == LORAMAC_STATUS_OK )
 803848e:	4606      	mov	r6, r0
 8038490:	b988      	cbnz	r0, 80384b6 <RegionUS915NextChannel+0xf6>
    {
        if( nextChanParams->Joined == true )
 8038492:	7a63      	ldrb	r3, [r4, #9]
 8038494:	b19b      	cbz	r3, 80384be <RegionUS915NextChannel+0xfe>
        {
            // Choose randomly on of the remaining channels
            *channel = enabledChannels[randr( 0, nbEnabledChannels - 1 )];
 8038496:	f89d 100e 	ldrb.w	r1, [sp, #14]
 803849a:	3901      	subs	r1, #1
 803849c:	f000 fd00 	bl	8038ea0 <randr>
 80384a0:	ab24      	add	r3, sp, #144	; 0x90
 80384a2:	4418      	add	r0, r3
 80384a4:	f810 3c48 	ldrb.w	r3, [r0, #-72]
                uint8_t i = 0;
                while( ( ( RegionNvmGroup1->ChannelsMaskRemaining[4] & CHANNELS_MASK_500KHZ_MASK ) & ( 1 << i ) ) == 0 )
                {
                    i++;
                }
                *channel = 64 + i;
 80384a8:	703b      	strb	r3, [r7, #0]
            }
        }

        // Disable the channel in the mask
        RegionCommonChanDisable( RegionNvmGroup1->ChannelsMaskRemaining, *channel, US915_MAX_NB_CHANNELS );
 80384aa:	6868      	ldr	r0, [r5, #4]
 80384ac:	7839      	ldrb	r1, [r7, #0]
 80384ae:	2248      	movs	r2, #72	; 0x48
 80384b0:	3090      	adds	r0, #144	; 0x90
 80384b2:	f7fe fa91 	bl	80369d8 <RegionCommonChanDisable>
    }
    return status;
#else
    return LORAMAC_STATUS_NO_CHANNEL_FOUND;
#endif /* REGION_US915 */
}
 80384b6:	4630      	mov	r0, r6
 80384b8:	b025      	add	sp, #148	; 0x94
 80384ba:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            if( nextChanParams->Datarate == DR_0 )
 80384be:	f994 3008 	ldrsb.w	r3, [r4, #8]
 80384c2:	6868      	ldr	r0, [r5, #4]
 80384c4:	b15b      	cbz	r3, 80384de <RegionUS915NextChannel+0x11e>
                while( ( ( RegionNvmGroup1->ChannelsMaskRemaining[4] & CHANNELS_MASK_500KHZ_MASK ) & ( 1 << i ) ) == 0 )
 80384c6:	f890 0098 	ldrb.w	r0, [r0, #152]	; 0x98
 80384ca:	4632      	mov	r2, r6
 80384cc:	b2d3      	uxtb	r3, r2
 80384ce:	fa40 f103 	asr.w	r1, r0, r3
 80384d2:	07c9      	lsls	r1, r1, #31
 80384d4:	f102 0201 	add.w	r2, r2, #1
 80384d8:	d5f8      	bpl.n	80384cc <RegionUS915NextChannel+0x10c>
                *channel = 64 + i;
 80384da:	3340      	adds	r3, #64	; 0x40
 80384dc:	e7e4      	b.n	80384a8 <RegionUS915NextChannel+0xe8>
                if( RegionBaseUSComputeNext125kHzJoinChannel( ( uint16_t* ) RegionNvmGroup1->ChannelsMaskRemaining,
 80384de:	f100 019c 	add.w	r1, r0, #156	; 0x9c
 80384e2:	463a      	mov	r2, r7
 80384e4:	3090      	adds	r0, #144	; 0x90
 80384e6:	f7fe f9f3 	bl	80368d0 <RegionBaseUSComputeNext125kHzJoinChannel>
 80384ea:	2803      	cmp	r0, #3
 80384ec:	d1dd      	bne.n	80384aa <RegionUS915NextChannel+0xea>
                    return LORAMAC_STATUS_PARAMETER_INVALID;
 80384ee:	4606      	mov	r6, r0
 80384f0:	e7e1      	b.n	80384b6 <RegionUS915NextChannel+0xf6>
 80384f2:	bf00      	nop
 80384f4:	20005730 	.word	0x20005730

080384f8 <RegionUS915SetContinuousWave>:
{
    return LORAMAC_STATUS_PARAMETER_INVALID;
}

void RegionUS915SetContinuousWave( ContinuousWaveParams_t* continuousWave )
{
 80384f8:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
#if defined( REGION_US915 )
    int8_t txPowerLimited = LimitTxPower( continuousWave->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[continuousWave->Channel].Band].TxMaxPower, continuousWave->Datarate, RegionNvmGroup2->ChannelsMask );
 80384fc:	4e1f      	ldr	r6, [pc, #124]	; (803857c <RegionUS915SetContinuousWave+0x84>)
 80384fe:	7802      	ldrb	r2, [r0, #0]
 8038500:	f8d6 8000 	ldr.w	r8, [r6]
 8038504:	6871      	ldr	r1, [r6, #4]
 8038506:	f990 7002 	ldrsb.w	r7, [r0, #2]
 803850a:	f990 9001 	ldrsb.w	r9, [r0, #1]
 803850e:	230c      	movs	r3, #12
 8038510:	fb03 8202 	mla	r2, r3, r2, r8
{
 8038514:	4604      	mov	r4, r0
    int8_t txPowerLimited = LimitTxPower( continuousWave->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[continuousWave->Channel].Band].TxMaxPower, continuousWave->Datarate, RegionNvmGroup2->ChannelsMask );
 8038516:	7a53      	ldrb	r3, [r2, #9]
 8038518:	2218      	movs	r2, #24
 803851a:	fb02 1303 	mla	r3, r2, r3, r1
    txPowerResult =  RegionCommonLimitTxPower( txPower, maxBandTxPower );
 803851e:	4638      	mov	r0, r7
 8038520:	f993 1002 	ldrsb.w	r1, [r3, #2]
 8038524:	f7fe fd0a 	bl	8036f3c <RegionCommonLimitTxPower>
    if( datarate == DR_4 )
 8038528:	f1b9 0f04 	cmp.w	r9, #4
    txPowerResult =  RegionCommonLimitTxPower( txPower, maxBandTxPower );
 803852c:	4605      	mov	r5, r0
    if( datarate == DR_4 )
 803852e:	d117      	bne.n	8038560 <RegionUS915SetContinuousWave+0x68>
        txPowerResult = MAX( txPower, TX_POWER_2 );
 8038530:	2f02      	cmp	r7, #2
 8038532:	463d      	mov	r5, r7
 8038534:	bfb8      	it	lt
 8038536:	2502      	movlt	r5, #2
    int8_t phyTxPower = 0;
    uint32_t frequency = RegionNvmGroup2->Channels[continuousWave->Channel].Frequency;
 8038538:	7821      	ldrb	r1, [r4, #0]
 803853a:	6832      	ldr	r2, [r6, #0]
 803853c:	230c      	movs	r3, #12
 803853e:	434b      	muls	r3, r1

    // Calculate physical TX power
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );
 8038540:	4628      	mov	r0, r5
    uint32_t frequency = RegionNvmGroup2->Channels[continuousWave->Channel].Frequency;
 8038542:	58d6      	ldr	r6, [r2, r3]
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );
 8038544:	490e      	ldr	r1, [pc, #56]	; (8038580 <RegionUS915SetContinuousWave+0x88>)
 8038546:	2200      	movs	r2, #0
 8038548:	f7fe fc2d 	bl	8036da6 <RegionCommonComputeTxPower>

    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 803854c:	4b0d      	ldr	r3, [pc, #52]	; (8038584 <RegionUS915SetContinuousWave+0x8c>)
 803854e:	89a2      	ldrh	r2, [r4, #12]
 8038550:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8038552:	9301      	str	r3, [sp, #4]
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );
 8038554:	4601      	mov	r1, r0
    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 8038556:	4630      	mov	r0, r6
#endif /* REGION_US915 */
}
 8038558:	b003      	add	sp, #12
 803855a:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 803855e:	4718      	bx	r3
        if( RegionCommonCountChannels( channelsMask, 0, 4 ) < 50 )
 8038560:	2204      	movs	r2, #4
 8038562:	2100      	movs	r1, #0
 8038564:	f508 7058 	add.w	r0, r8, #864	; 0x360
 8038568:	f7fe fa4f 	bl	8036a0a <RegionCommonCountChannels>
 803856c:	2831      	cmp	r0, #49	; 0x31
 803856e:	d8e3      	bhi.n	8038538 <RegionUS915SetContinuousWave+0x40>
            txPowerResult = MAX( txPower, TX_POWER_5 );
 8038570:	2f05      	cmp	r7, #5
 8038572:	463d      	mov	r5, r7
 8038574:	bfb8      	it	lt
 8038576:	2505      	movlt	r5, #5
 8038578:	e7de      	b.n	8038538 <RegionUS915SetContinuousWave+0x40>
 803857a:	bf00      	nop
 803857c:	20005730 	.word	0x20005730
 8038580:	41f00000 	.word	0x41f00000
 8038584:	0803bbd8 	.word	0x0803bbd8

08038588 <RegionUS915ApplyDrOffset>:

uint8_t RegionUS915ApplyDrOffset( uint8_t downlinkDwellTime, int8_t dr, int8_t drOffset )
{
#if defined( REGION_US915 )
    int8_t datarate = DatarateOffsetsUS915[dr][drOffset];
 8038588:	4b04      	ldr	r3, [pc, #16]	; (803859c <RegionUS915ApplyDrOffset+0x14>)
 803858a:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 803858e:	4413      	add	r3, r2
 8038590:	f993 0070 	ldrsb.w	r0, [r3, #112]	; 0x70

    if( datarate < 0 )
    {
        datarate = DR_0;
    }
    return datarate;
 8038594:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
#else
    return 0;
#endif /* REGION_US915 */
}
 8038598:	b2c0      	uxtb	r0, r0
 803859a:	4770      	bx	lr
 803859c:	0803bb00 	.word	0x0803bb00

080385a0 <GetKeyIndexByID>:
 */
static SecureElementStatus_t GetKeyIndexByID( KeyIdentifier_t keyID, CK_OBJECT_HANDLE *keyIndex )
{
    for (uint8_t i = 0; i < NUM_OF_KEYS; i++)
    {
        if (SeNvm->KeyList[i].KeyID == keyID)
 80385a0:	4b0a      	ldr	r3, [pc, #40]	; (80385cc <GetKeyIndexByID+0x2c>)
 80385a2:	681a      	ldr	r2, [r3, #0]
{
 80385a4:	b5f0      	push	{r4, r5, r6, r7, lr}
        if (SeNvm->KeyList[i].KeyID == keyID)
 80385a6:	2300      	movs	r3, #0
 80385a8:	f102 0510 	add.w	r5, r2, #16
 80385ac:	2618      	movs	r6, #24
 80385ae:	fb06 f403 	mul.w	r4, r6, r3
 80385b2:	5d2f      	ldrb	r7, [r5, r4]
 80385b4:	4287      	cmp	r7, r0
 80385b6:	d104      	bne.n	80385c2 <GetKeyIndexByID+0x22>
        {
            *keyIndex = SeNvm->KeyList[i].Object_Index;
 80385b8:	4422      	add	r2, r4
            return SECURE_ELEMENT_SUCCESS;
 80385ba:	2000      	movs	r0, #0
            *keyIndex = SeNvm->KeyList[i].Object_Index;
 80385bc:	6a53      	ldr	r3, [r2, #36]	; 0x24
 80385be:	600b      	str	r3, [r1, #0]
        }
    }
    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
}
 80385c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    for (uint8_t i = 0; i < NUM_OF_KEYS; i++)
 80385c2:	3301      	adds	r3, #1
 80385c4:	2b0a      	cmp	r3, #10
 80385c6:	d1f2      	bne.n	80385ae <GetKeyIndexByID+0xe>
    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 80385c8:	2003      	movs	r0, #3
 80385ca:	e7f9      	b.n	80385c0 <GetKeyIndexByID+0x20>
 80385cc:	20005738 	.word	0x20005738

080385d0 <SecureElementGetKeyByID>:
    return SECURE_ELEMENT_SUCCESS;
}

/* ST_WORKAROUND_BEGIN: Add KMS specific functions */
SecureElementStatus_t SecureElementGetKeyByID( KeyIdentifier_t keyID, Key_t **keyItem )
{
 80385d0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80385d4:	b08d      	sub	sp, #52	; 0x34
    CK_SESSION_HANDLE session;
    CK_FLAGS session_flags = CKF_SERIAL_SESSION;  /* Read ONLY session */
    CK_OBJECT_HANDLE key_handle = (CK_OBJECT_HANDLE)(~0UL);
    CK_ULONG derive_key_template_class = CKO_SECRET_KEY;
    uint8_t extractable_key[16] = {0};
    CK_ATTRIBUTE key_attribute_template = {CKA_VALUE, (CK_VOID_PTR) &derive_key_template_class, 16UL};
 80385d6:	2211      	movs	r2, #17
    CK_ULONG derive_key_template_class = CKO_SECRET_KEY;
 80385d8:	2304      	movs	r3, #4
    uint8_t index_keylist = 0;
    for (index_keylist = 0; index_keylist < NUM_OF_KEYS; index_keylist++)
    {
        if (SeNvm->KeyList[index_keylist].KeyID == keyID)
 80385da:	4e27      	ldr	r6, [pc, #156]	; (8038678 <SecureElementGetKeyByID+0xa8>)
    CK_ATTRIBUTE key_attribute_template = {CKA_VALUE, (CK_VOID_PTR) &derive_key_template_class, 16UL};
 80385dc:	9205      	str	r2, [sp, #20]
 80385de:	aa04      	add	r2, sp, #16
    CK_ULONG derive_key_template_class = CKO_SECRET_KEY;
 80385e0:	9304      	str	r3, [sp, #16]
    CK_ATTRIBUTE key_attribute_template = {CKA_VALUE, (CK_VOID_PTR) &derive_key_template_class, 16UL};
 80385e2:	9206      	str	r2, [sp, #24]
    uint8_t extractable_key[16] = {0};
 80385e4:	2300      	movs	r3, #0
    CK_ATTRIBUTE key_attribute_template = {CKA_VALUE, (CK_VOID_PTR) &derive_key_template_class, 16UL};
 80385e6:	2210      	movs	r2, #16
 80385e8:	9207      	str	r2, [sp, #28]
    uint8_t extractable_key[16] = {0};
 80385ea:	e9cd 3308 	strd	r3, r3, [sp, #32]
        if (SeNvm->KeyList[index_keylist].KeyID == keyID)
 80385ee:	6832      	ldr	r2, [r6, #0]
    uint8_t extractable_key[16] = {0};
 80385f0:	e9cd 330a 	strd	r3, r3, [sp, #40]	; 0x28
{
 80385f4:	460f      	mov	r7, r1
        if (SeNvm->KeyList[index_keylist].KeyID == keyID)
 80385f6:	2418      	movs	r4, #24
 80385f8:	f102 0110 	add.w	r1, r2, #16
 80385fc:	fb04 f503 	mul.w	r5, r4, r3
 8038600:	f811 c005 	ldrb.w	ip, [r1, r5]
 8038604:	4584      	cmp	ip, r0
 8038606:	d107      	bne.n	8038618 <SecureElementGetKeyByID+0x48>
        {
            key_handle = SeNvm->KeyList[index_keylist].Object_Index;
 8038608:	442a      	add	r2, r5
 803860a:	f8d2 9024 	ldr.w	r9, [r2, #36]	; 0x24
            break;
        }
    }
    if (key_handle == (CK_OBJECT_HANDLE)(~0UL))
 803860e:	f1b9 3fff 	cmp.w	r9, #4294967295
 8038612:	d105      	bne.n	8038620 <SecureElementGetKeyByID+0x50>
    {
        return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 8038614:	2003      	movs	r0, #3
 8038616:	e02c      	b.n	8038672 <SecureElementGetKeyByID+0xa2>
    for (index_keylist = 0; index_keylist < NUM_OF_KEYS; index_keylist++)
 8038618:	3301      	adds	r3, #1
 803861a:	2b0a      	cmp	r3, #10
 803861c:	d1ee      	bne.n	80385fc <SecureElementGetKeyByID+0x2c>
 803861e:	e7f9      	b.n	8038614 <SecureElementGetKeyByID+0x44>
    }

    /* Open session with KMS */
    rv = C_OpenSession(0, session_flags, NULL, 0, &session);
 8038620:	ab03      	add	r3, sp, #12
 8038622:	9300      	str	r3, [sp, #0]
 8038624:	2300      	movs	r3, #0
 8038626:	461a      	mov	r2, r3
 8038628:	2104      	movs	r1, #4
 803862a:	4618      	mov	r0, r3
 803862c:	f7d0 fb96 	bl	8008d5c <SE_KMS_OpenSession>

    /* Get key to display */
    if (rv == CKR_OK)
 8038630:	4604      	mov	r4, r0
 8038632:	b9b8      	cbnz	r0, 8038664 <SecureElementGetKeyByID+0x94>
    {
        key_attribute_template.pValue = extractable_key;
        rv = C_GetAttributeValue(session, key_handle, &key_attribute_template, 1UL);
 8038634:	9803      	ldr	r0, [sp, #12]
        key_attribute_template.pValue = extractable_key;
 8038636:	f10d 0820 	add.w	r8, sp, #32
        rv = C_GetAttributeValue(session, key_handle, &key_attribute_template, 1UL);
 803863a:	2301      	movs	r3, #1
 803863c:	aa05      	add	r2, sp, #20
 803863e:	4649      	mov	r1, r9
        key_attribute_template.pValue = extractable_key;
 8038640:	f8cd 8018 	str.w	r8, [sp, #24]
        rv = C_GetAttributeValue(session, key_handle, &key_attribute_template, 1UL);
 8038644:	f7d0 fbfa 	bl	8008e3c <SE_KMS_GetAttributeValue>
    }
    if (rv == CKR_OK)
 8038648:	4604      	mov	r4, r0
 803864a:	b958      	cbnz	r0, 8038664 <SecureElementGetKeyByID+0x94>
    {
        memcpy1(SeNvm->KeyList[index_keylist].KeyValue, extractable_key, sizeof(extractable_key));
 803864c:	6833      	ldr	r3, [r6, #0]
 803864e:	f105 0011 	add.w	r0, r5, #17
 8038652:	4418      	add	r0, r3
 8038654:	2210      	movs	r2, #16
 8038656:	4641      	mov	r1, r8
 8038658:	f000 fc3e 	bl	8038ed8 <memcpy1>
        *keyItem = &(SeNvm->KeyList[index_keylist]);
 803865c:	6833      	ldr	r3, [r6, #0]
 803865e:	3510      	adds	r5, #16
 8038660:	441d      	add	r5, r3
 8038662:	603d      	str	r5, [r7, #0]
    }

    /* Close sessions */
    (void)C_CloseSession(session);
 8038664:	9803      	ldr	r0, [sp, #12]
 8038666:	f7d0 fb99 	bl	8008d9c <SE_KMS_CloseSession>

    if (rv != CKR_OK)
    {
        return SECURE_ELEMENT_ERROR;
 803866a:	2c00      	cmp	r4, #0
 803866c:	bf0c      	ite	eq
 803866e:	2000      	moveq	r0, #0
 8038670:	2006      	movne	r0, #6
    }
    return SECURE_ELEMENT_SUCCESS;

#endif /* LORAWAN_KMS == 1 */
}
 8038672:	b00d      	add	sp, #52	; 0x34
 8038674:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8038678:	20005738 	.word	0x20005738

0803867c <PrintKey>:
{
 803867c:	b510      	push	{r4, lr}
 803867e:	b092      	sub	sp, #72	; 0x48
    retval = SecureElementGetKeyByID(key, &keyItem);
 8038680:	a911      	add	r1, sp, #68	; 0x44
{
 8038682:	4604      	mov	r4, r0
    retval = SecureElementGetKeyByID(key, &keyItem);
 8038684:	f7ff ffa4 	bl	80385d0 <SecureElementGetKeyByID>
    if (retval == SECURE_ELEMENT_SUCCESS)
 8038688:	4602      	mov	r2, r0
 803868a:	2800      	cmp	r0, #0
 803868c:	d131      	bne.n	80386f2 <PrintKey+0x76>
        if (key == APP_KEY)
 803868e:	b914      	cbnz	r4, 8038696 <PrintKey+0x1a>
            MW_LOG(TS_OFF, VLEVEL_M, "###### AppKey:      ");
 8038690:	4b27      	ldr	r3, [pc, #156]	; (8038730 <PrintKey+0xb4>)
            MW_LOG(TS_OFF, VLEVEL_M, "###### MCNwkSKey_0: ");
 8038692:	2200      	movs	r2, #0
 8038694:	e002      	b.n	803869c <PrintKey+0x20>
        else if (key == NWK_KEY)
 8038696:	2c01      	cmp	r4, #1
 8038698:	d12d      	bne.n	80386f6 <PrintKey+0x7a>
            MW_LOG(TS_OFF, VLEVEL_M, "###### NwkKey:      ");
 803869a:	4b26      	ldr	r3, [pc, #152]	; (8038734 <PrintKey+0xb8>)
            MW_LOG(TS_OFF, VLEVEL_M, "###### MCNwkSKey_0: ");
 803869c:	4611      	mov	r1, r2
 803869e:	2002      	movs	r0, #2
 80386a0:	f002 fb00 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
        MW_LOG(TS_OFF, VLEVEL_M, "%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\r\n",
 80386a4:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80386a6:	7c1a      	ldrb	r2, [r3, #16]
 80386a8:	920f      	str	r2, [sp, #60]	; 0x3c
 80386aa:	7bda      	ldrb	r2, [r3, #15]
 80386ac:	920e      	str	r2, [sp, #56]	; 0x38
 80386ae:	7b9a      	ldrb	r2, [r3, #14]
 80386b0:	920d      	str	r2, [sp, #52]	; 0x34
 80386b2:	7b5a      	ldrb	r2, [r3, #13]
 80386b4:	920c      	str	r2, [sp, #48]	; 0x30
 80386b6:	7b1a      	ldrb	r2, [r3, #12]
 80386b8:	920b      	str	r2, [sp, #44]	; 0x2c
 80386ba:	7ada      	ldrb	r2, [r3, #11]
 80386bc:	920a      	str	r2, [sp, #40]	; 0x28
 80386be:	7a9a      	ldrb	r2, [r3, #10]
 80386c0:	9209      	str	r2, [sp, #36]	; 0x24
 80386c2:	7a5a      	ldrb	r2, [r3, #9]
 80386c4:	9208      	str	r2, [sp, #32]
 80386c6:	7a1a      	ldrb	r2, [r3, #8]
 80386c8:	9207      	str	r2, [sp, #28]
 80386ca:	79da      	ldrb	r2, [r3, #7]
 80386cc:	9206      	str	r2, [sp, #24]
 80386ce:	799a      	ldrb	r2, [r3, #6]
 80386d0:	9205      	str	r2, [sp, #20]
 80386d2:	795a      	ldrb	r2, [r3, #5]
 80386d4:	9204      	str	r2, [sp, #16]
 80386d6:	791a      	ldrb	r2, [r3, #4]
 80386d8:	9203      	str	r2, [sp, #12]
 80386da:	78da      	ldrb	r2, [r3, #3]
 80386dc:	9202      	str	r2, [sp, #8]
 80386de:	789a      	ldrb	r2, [r3, #2]
 80386e0:	9201      	str	r2, [sp, #4]
 80386e2:	785b      	ldrb	r3, [r3, #1]
 80386e4:	9300      	str	r3, [sp, #0]
 80386e6:	2200      	movs	r2, #0
 80386e8:	4b13      	ldr	r3, [pc, #76]	; (8038738 <PrintKey+0xbc>)
 80386ea:	4611      	mov	r1, r2
 80386ec:	2002      	movs	r0, #2
 80386ee:	f002 fad9 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
}
 80386f2:	b012      	add	sp, #72	; 0x48
 80386f4:	bd10      	pop	{r4, pc}
        else if (key == APP_S_KEY)
 80386f6:	2c03      	cmp	r4, #3
 80386f8:	d101      	bne.n	80386fe <PrintKey+0x82>
            MW_LOG(TS_OFF, VLEVEL_M, "###### AppSKey:     ");
 80386fa:	4b10      	ldr	r3, [pc, #64]	; (803873c <PrintKey+0xc0>)
 80386fc:	e7ce      	b.n	803869c <PrintKey+0x20>
        else if (key == NWK_S_KEY)
 80386fe:	2c02      	cmp	r4, #2
 8038700:	d101      	bne.n	8038706 <PrintKey+0x8a>
            MW_LOG(TS_OFF, VLEVEL_M, "###### NwkSKey:     ");
 8038702:	4b0f      	ldr	r3, [pc, #60]	; (8038740 <PrintKey+0xc4>)
 8038704:	e7ca      	b.n	803869c <PrintKey+0x20>
        else if (key == MC_ROOT_KEY)
 8038706:	2c04      	cmp	r4, #4
 8038708:	d101      	bne.n	803870e <PrintKey+0x92>
            MW_LOG(TS_OFF, VLEVEL_M, "###### MCRootKey:   ");
 803870a:	4b0e      	ldr	r3, [pc, #56]	; (8038744 <PrintKey+0xc8>)
 803870c:	e7c6      	b.n	803869c <PrintKey+0x20>
        else if (key == MC_KE_KEY)
 803870e:	2c7f      	cmp	r4, #127	; 0x7f
 8038710:	d101      	bne.n	8038716 <PrintKey+0x9a>
            MW_LOG(TS_OFF, VLEVEL_M, "###### MCKEKey:     ");
 8038712:	4b0d      	ldr	r3, [pc, #52]	; (8038748 <PrintKey+0xcc>)
 8038714:	e7c2      	b.n	803869c <PrintKey+0x20>
        else if (key == MC_KEY_0)
 8038716:	2c80      	cmp	r4, #128	; 0x80
 8038718:	d101      	bne.n	803871e <PrintKey+0xa2>
            MW_LOG(TS_OFF, VLEVEL_M, "###### MCKey_0:     ");
 803871a:	4b0c      	ldr	r3, [pc, #48]	; (803874c <PrintKey+0xd0>)
 803871c:	e7be      	b.n	803869c <PrintKey+0x20>
        else if (key == MC_APP_S_KEY_0)
 803871e:	2c81      	cmp	r4, #129	; 0x81
 8038720:	d101      	bne.n	8038726 <PrintKey+0xaa>
            MW_LOG(TS_OFF, VLEVEL_M, "###### MCAppSKey_0: ");
 8038722:	4b0b      	ldr	r3, [pc, #44]	; (8038750 <PrintKey+0xd4>)
 8038724:	e7ba      	b.n	803869c <PrintKey+0x20>
        else if (key == MC_NWK_S_KEY_0)
 8038726:	2c82      	cmp	r4, #130	; 0x82
 8038728:	d1bc      	bne.n	80386a4 <PrintKey+0x28>
            MW_LOG(TS_OFF, VLEVEL_M, "###### MCNwkSKey_0: ");
 803872a:	4b0a      	ldr	r3, [pc, #40]	; (8038754 <PrintKey+0xd8>)
 803872c:	e7b1      	b.n	8038692 <PrintKey+0x16>
 803872e:	bf00      	nop
 8038730:	0803c35e 	.word	0x0803c35e
 8038734:	0803c373 	.word	0x0803c373
 8038738:	0803c41b 	.word	0x0803c41b
 803873c:	0803c388 	.word	0x0803c388
 8038740:	0803c39d 	.word	0x0803c39d
 8038744:	0803c3b2 	.word	0x0803c3b2
 8038748:	0803c3c7 	.word	0x0803c3c7
 803874c:	0803c3dc 	.word	0x0803c3dc
 8038750:	0803c3f1 	.word	0x0803c3f1
 8038754:	0803c406 	.word	0x0803c406

08038758 <SecureElementDeleteDynamicKeys>:

SecureElementStatus_t SecureElementDeleteDynamicKeys( KeyIdentifier_t keyID, uint32_t *key_label )
{
 8038758:	b530      	push	{r4, r5, lr}
 803875a:	b095      	sub	sp, #84	; 0x54
#else /* LORAWAN_KMS == 1 */
    CK_RV rv;
    CK_SESSION_HANDLE session;
    CK_FLAGS session_flags = CKF_SERIAL_SESSION;    /* Read ONLY session */
    CK_OBJECT_HANDLE hObject[NUM_OF_KEYS];
    CK_ULONG local_template_label[] = {GlobalTemplateLabel, 0UL};
 803875c:	4b37      	ldr	r3, [pc, #220]	; (803883c <SecureElementDeleteDynamicKeys+0xe4>)
 803875e:	9305      	str	r3, [sp, #20]
    CK_ATTRIBUTE dynamic_key_template = {CKA_LABEL, (CK_VOID_PTR)local_template_label, sizeof(local_template_label)};
 8038760:	2303      	movs	r3, #3
 8038762:	9307      	str	r3, [sp, #28]
 8038764:	ab05      	add	r3, sp, #20
 8038766:	9308      	str	r3, [sp, #32]
 8038768:	2308      	movs	r3, #8
 803876a:	9309      	str	r3, [sp, #36]	; 0x24
    switch (keyID)
 803876c:	2804      	cmp	r0, #4
    uint32_t ulCount = 0;
 803876e:	f04f 0300 	mov.w	r3, #0
 8038772:	9304      	str	r3, [sp, #16]
    switch (keyID)
 8038774:	d90b      	bls.n	803878e <SecureElementDeleteDynamicKeys+0x36>
 8038776:	387f      	subs	r0, #127	; 0x7f
 8038778:	b2c3      	uxtb	r3, r0
 803877a:	2b03      	cmp	r3, #3
 803877c:	d901      	bls.n	8038782 <SecureElementDeleteDynamicKeys+0x2a>
 803877e:	2006      	movs	r0, #6
 8038780:	e038      	b.n	80387f4 <SecureElementDeleteDynamicKeys+0x9c>
 8038782:	2803      	cmp	r0, #3
 8038784:	d8fb      	bhi.n	803877e <SecureElementDeleteDynamicKeys+0x26>
 8038786:	e8df f000 	tbb	[pc, r0]
 803878a:	413f      	.short	0x413f
 803878c:	4543      	.short	0x4543
 803878e:	3801      	subs	r0, #1
 8038790:	2803      	cmp	r0, #3
 8038792:	d803      	bhi.n	803879c <SecureElementDeleteDynamicKeys+0x44>
 8038794:	e8df f000 	tbb	[pc, r0]
 8038798:	36343230 	.word	0x36343230
            *specificLabel = 0x5F505041U;
 803879c:	4b28      	ldr	r3, [pc, #160]	; (8038840 <SecureElementDeleteDynamicKeys+0xe8>)
            *specificLabel = 0x30534E4DU;
 803879e:	9306      	str	r3, [sp, #24]

    if (SECURE_ELEMENT_SUCCESS != GetSpecificLabelByID(keyID, &local_template_label[1]))
    {
        return SECURE_ELEMENT_ERROR;
    }
    *key_label = local_template_label[1];
 80387a0:	9b06      	ldr	r3, [sp, #24]
 80387a2:	600b      	str	r3, [r1, #0]

    /* Open session with KMS */
    rv = C_OpenSession(0,    session_flags, NULL, 0, &session);
 80387a4:	ab03      	add	r3, sp, #12
 80387a6:	9300      	str	r3, [sp, #0]
 80387a8:	2300      	movs	r3, #0
 80387aa:	461a      	mov	r2, r3
 80387ac:	2104      	movs	r1, #4
 80387ae:	4618      	mov	r0, r3
 80387b0:	f7d0 fad4 	bl	8008d5c <SE_KMS_OpenSession>

    /* Search from Template pattern */
    if (rv == CKR_OK)
 80387b4:	4604      	mov	r4, r0
 80387b6:	b990      	cbnz	r0, 80387de <SecureElementDeleteDynamicKeys+0x86>
    {
        rv = C_FindObjectsInit(session, &dynamic_key_template, sizeof(dynamic_key_template) / sizeof(CK_ATTRIBUTE));
 80387b8:	9803      	ldr	r0, [sp, #12]
 80387ba:	2201      	movs	r2, #1
 80387bc:	a907      	add	r1, sp, #28
 80387be:	f7d0 fb79 	bl	8008eb4 <SE_KMS_FindObjectsInit>
    }

    /* Find all existing keys handle Template pattern */
    if (rv == CKR_OK)
 80387c2:	4604      	mov	r4, r0
 80387c4:	b958      	cbnz	r0, 80387de <SecureElementDeleteDynamicKeys+0x86>
    {
        rv = C_FindObjects(session, hObject, NUM_OF_KEYS, (CK_ULONG *) &ulCount);
 80387c6:	9803      	ldr	r0, [sp, #12]
 80387c8:	ab04      	add	r3, sp, #16
 80387ca:	220a      	movs	r2, #10
 80387cc:	a90a      	add	r1, sp, #40	; 0x28
 80387ce:	f7d0 fb8d 	bl	8008eec <SE_KMS_FindObjects>
    }

    if (rv == CKR_OK)
 80387d2:	4604      	mov	r4, r0
 80387d4:	b918      	cbnz	r0, 80387de <SecureElementDeleteDynamicKeys+0x86>
    {
        rv = C_FindObjectsFinal(session);
 80387d6:	9803      	ldr	r0, [sp, #12]
 80387d8:	f7d0 fba6 	bl	8008f28 <SE_KMS_FindObjectsFinal>
 80387dc:	4604      	mov	r4, r0
    }

    if (ulCount <= NUM_OF_KEYS)
 80387de:	9b04      	ldr	r3, [sp, #16]
 80387e0:	2b0a      	cmp	r3, #10
 80387e2:	d929      	bls.n	8038838 <SecureElementDeleteDynamicKeys+0xe0>
            }
        }
    }

    /* Close sessions */
    if (session > 0)
 80387e4:	9803      	ldr	r0, [sp, #12]
 80387e6:	b108      	cbz	r0, 80387ec <SecureElementDeleteDynamicKeys+0x94>
    {
        (void)C_CloseSession(session);
 80387e8:	f7d0 fad8 	bl	8008d9c <SE_KMS_CloseSession>
    }

    if (rv != CKR_OK)
    {
        return SECURE_ELEMENT_ERROR;
 80387ec:	2c00      	cmp	r4, #0
 80387ee:	bf0c      	ite	eq
 80387f0:	2000      	moveq	r0, #0
 80387f2:	2006      	movne	r0, #6
    }
    return SECURE_ELEMENT_SUCCESS;
#endif /* LORAWAN_KMS == 1 */
}
 80387f4:	b015      	add	sp, #84	; 0x54
 80387f6:	bd30      	pop	{r4, r5, pc}
            *specificLabel = 0x5F4B574EU;
 80387f8:	4b12      	ldr	r3, [pc, #72]	; (8038844 <SecureElementDeleteDynamicKeys+0xec>)
 80387fa:	e7d0      	b.n	803879e <SecureElementDeleteDynamicKeys+0x46>
            *specificLabel = 0x534B574EU;
 80387fc:	4b12      	ldr	r3, [pc, #72]	; (8038848 <SecureElementDeleteDynamicKeys+0xf0>)
 80387fe:	e7ce      	b.n	803879e <SecureElementDeleteDynamicKeys+0x46>
            *specificLabel = 0x53505041U;
 8038800:	4b12      	ldr	r3, [pc, #72]	; (803884c <SecureElementDeleteDynamicKeys+0xf4>)
 8038802:	e7cc      	b.n	803879e <SecureElementDeleteDynamicKeys+0x46>
            *specificLabel = 0x5452434DU;
 8038804:	4b12      	ldr	r3, [pc, #72]	; (8038850 <SecureElementDeleteDynamicKeys+0xf8>)
 8038806:	e7ca      	b.n	803879e <SecureElementDeleteDynamicKeys+0x46>
            *specificLabel = 0x454B434DU;
 8038808:	4b12      	ldr	r3, [pc, #72]	; (8038854 <SecureElementDeleteDynamicKeys+0xfc>)
 803880a:	e7c8      	b.n	803879e <SecureElementDeleteDynamicKeys+0x46>
            *specificLabel = 0x304B434DU;
 803880c:	4b12      	ldr	r3, [pc, #72]	; (8038858 <SecureElementDeleteDynamicKeys+0x100>)
 803880e:	e7c6      	b.n	803879e <SecureElementDeleteDynamicKeys+0x46>
            *specificLabel = 0x3053414DU;
 8038810:	4b12      	ldr	r3, [pc, #72]	; (803885c <SecureElementDeleteDynamicKeys+0x104>)
 8038812:	e7c4      	b.n	803879e <SecureElementDeleteDynamicKeys+0x46>
            *specificLabel = 0x30534E4DU;
 8038814:	4b12      	ldr	r3, [pc, #72]	; (8038860 <SecureElementDeleteDynamicKeys+0x108>)
 8038816:	e7c2      	b.n	803879e <SecureElementDeleteDynamicKeys+0x46>
            if (rv == CKR_OK)
 8038818:	b944      	cbnz	r4, 803882c <SecureElementDeleteDynamicKeys+0xd4>
                rv = C_DestroyObject(session, hObject[i]);
 803881a:	aa14      	add	r2, sp, #80	; 0x50
 803881c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8038820:	9803      	ldr	r0, [sp, #12]
 8038822:	f853 1c28 	ldr.w	r1, [r3, #-40]
 8038826:	f7d0 faef 	bl	8008e08 <SE_KMS_DestroyObject>
 803882a:	4604      	mov	r4, r0
        for (uint8_t i = 0; i < ulCount; i++)
 803882c:	3501      	adds	r5, #1
 803882e:	9a04      	ldr	r2, [sp, #16]
 8038830:	b2eb      	uxtb	r3, r5
 8038832:	429a      	cmp	r2, r3
 8038834:	d8f0      	bhi.n	8038818 <SecureElementDeleteDynamicKeys+0xc0>
 8038836:	e7d5      	b.n	80387e4 <SecureElementDeleteDynamicKeys+0x8c>
 8038838:	2500      	movs	r5, #0
 803883a:	e7f8      	b.n	803882e <SecureElementDeleteDynamicKeys+0xd6>
 803883c:	444e524c 	.word	0x444e524c
 8038840:	5f505041 	.word	0x5f505041
 8038844:	5f4b574e 	.word	0x5f4b574e
 8038848:	534b574e 	.word	0x534b574e
 803884c:	53505041 	.word	0x53505041
 8038850:	5452434d 	.word	0x5452434d
 8038854:	454b434d 	.word	0x454b434d
 8038858:	304b434d 	.word	0x304b434d
 803885c:	3053414d 	.word	0x3053414d
 8038860:	30534e4d 	.word	0x30534e4d

08038864 <SecureElementSetObjHandler>:
#if (!defined (LORAWAN_KMS) || (LORAWAN_KMS == 0))
    return SECURE_ELEMENT_ERROR;
#else /* LORAWAN_KMS == 1 */
    for (uint8_t i = 0; i < NUM_OF_KEYS; i++)
    {
        if (SeNvm->KeyList[i].KeyID == keyID)
 8038864:	4b0a      	ldr	r3, [pc, #40]	; (8038890 <SecureElementSetObjHandler+0x2c>)
 8038866:	681a      	ldr	r2, [r3, #0]
{
 8038868:	b5f0      	push	{r4, r5, r6, r7, lr}
        if (SeNvm->KeyList[i].KeyID == keyID)
 803886a:	2300      	movs	r3, #0
 803886c:	f102 0510 	add.w	r5, r2, #16
 8038870:	2618      	movs	r6, #24
 8038872:	fb06 f403 	mul.w	r4, r6, r3
 8038876:	5d2f      	ldrb	r7, [r5, r4]
 8038878:	4287      	cmp	r7, r0
 803887a:	d103      	bne.n	8038884 <SecureElementSetObjHandler+0x20>
        {
            SeNvm->KeyList[i].Object_Index = (CK_OBJECT_HANDLE) keyIndex;
 803887c:	4422      	add	r2, r4
            return SECURE_ELEMENT_SUCCESS;
 803887e:	2000      	movs	r0, #0
            SeNvm->KeyList[i].Object_Index = (CK_OBJECT_HANDLE) keyIndex;
 8038880:	6251      	str	r1, [r2, #36]	; 0x24
        }
    }
    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
#endif /* LORAWAN_KMS */
}
 8038882:	bdf0      	pop	{r4, r5, r6, r7, pc}
    for (uint8_t i = 0; i < NUM_OF_KEYS; i++)
 8038884:	3301      	adds	r3, #1
 8038886:	2b0a      	cmp	r3, #10
 8038888:	d1f3      	bne.n	8038872 <SecureElementSetObjHandler+0xe>
    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 803888a:	2003      	movs	r0, #3
 803888c:	e7f9      	b.n	8038882 <SecureElementSetObjHandler+0x1e>
 803888e:	bf00      	nop
 8038890:	20005738 	.word	0x20005738

08038894 <SecureElementInit>:
{
 8038894:	b510      	push	{r4, lr}
    uint8_t devEUI[SE_EUI_SIZE] = LORAWAN_DEVICE_EUI;
 8038896:	4b4c      	ldr	r3, [pc, #304]	; (80389c8 <SecureElementInit+0x134>)
{
 8038898:	b092      	sub	sp, #72	; 0x48
    uint8_t devEUI[SE_EUI_SIZE] = LORAWAN_DEVICE_EUI;
 803889a:	6859      	ldr	r1, [r3, #4]
{
 803889c:	4602      	mov	r2, r0
    uint8_t devEUI[SE_EUI_SIZE] = LORAWAN_DEVICE_EUI;
 803889e:	6818      	ldr	r0, [r3, #0]
 80388a0:	ac04      	add	r4, sp, #16
 80388a2:	c403      	stmia	r4!, {r0, r1}
    uint8_t joinEUI[SE_EUI_SIZE] = LORAWAN_JOIN_EUI;
 80388a4:	f853 0f08 	ldr.w	r0, [r3, #8]!
 80388a8:	6859      	ldr	r1, [r3, #4]
 80388aa:	ac06      	add	r4, sp, #24
 80388ac:	c403      	stmia	r4!, {r0, r1}
    if (nvm == NULL)
 80388ae:	4610      	mov	r0, r2
 80388b0:	2a00      	cmp	r2, #0
 80388b2:	f000 8087 	beq.w	80389c4 <SecureElementInit+0x130>
    SeNvm = nvm;
 80388b6:	4c45      	ldr	r4, [pc, #276]	; (80389cc <SecureElementInit+0x138>)
    memcpy1((uint8_t *)SeNvm->DevEui, devEUI, SE_EUI_SIZE);
 80388b8:	a904      	add	r1, sp, #16
    SeNvm = nvm;
 80388ba:	6022      	str	r2, [r4, #0]
    memcpy1((uint8_t *)SeNvm->DevEui, devEUI, SE_EUI_SIZE);
 80388bc:	2208      	movs	r2, #8
 80388be:	f000 fb0b 	bl	8038ed8 <memcpy1>
    memcpy1((uint8_t *)SeNvm->JoinEui, joinEUI, SE_EUI_SIZE);
 80388c2:	6820      	ldr	r0, [r4, #0]
 80388c4:	2208      	movs	r2, #8
 80388c6:	4410      	add	r0, r2
 80388c8:	a906      	add	r1, sp, #24
 80388ca:	f000 fb05 	bl	8038ed8 <memcpy1>
    SeNvm->KeyList[itr++].KeyID = APP_KEY;
 80388ce:	6822      	ldr	r2, [r4, #0]
    SeNvm->KeyList[itr++].KeyID = MC_KE_KEY;
 80388d0:	207f      	movs	r0, #127	; 0x7f
 80388d2:	f882 0088 	strb.w	r0, [r2, #136]	; 0x88
    SeNvm->KeyList[itr++].KeyID = NWK_KEY;
 80388d6:	2101      	movs	r1, #1
    SeNvm->KeyList[itr++].KeyID = MC_KEY_0;
 80388d8:	2080      	movs	r0, #128	; 0x80
    SeNvm->KeyList[itr++].KeyID = NWK_KEY;
 80388da:	f882 1028 	strb.w	r1, [r2, #40]	; 0x28
    SeNvm->KeyList[itr++].KeyID = MC_KEY_0;
 80388de:	f882 00a0 	strb.w	r0, [r2, #160]	; 0xa0
    SeNvm->KeyList[itr++].KeyID = NWK_S_KEY;
 80388e2:	2102      	movs	r1, #2
    SeNvm->KeyList[itr++].KeyID = MC_APP_S_KEY_0;
 80388e4:	2081      	movs	r0, #129	; 0x81
    SeNvm->KeyList[itr++].KeyID = NWK_S_KEY;
 80388e6:	f882 1040 	strb.w	r1, [r2, #64]	; 0x40
    SeNvm->KeyList[itr++].KeyID = MC_APP_S_KEY_0;
 80388ea:	f882 00b8 	strb.w	r0, [r2, #184]	; 0xb8
    SeNvm->KeyList[itr++].KeyID = APP_S_KEY;
 80388ee:	2103      	movs	r1, #3
    SeNvm->KeyList[itr++].KeyID = MC_NWK_S_KEY_0;
 80388f0:	2082      	movs	r0, #130	; 0x82
    SeNvm->KeyList[itr++].KeyID = APP_KEY;
 80388f2:	2300      	movs	r3, #0
    SeNvm->KeyList[itr++].KeyID = APP_S_KEY;
 80388f4:	f882 1058 	strb.w	r1, [r2, #88]	; 0x58
    SeNvm->KeyList[itr++].KeyID = MC_NWK_S_KEY_0;
 80388f8:	f882 00d0 	strb.w	r0, [r2, #208]	; 0xd0
    SeNvm->KeyList[itr++].KeyID = MC_ROOT_KEY;
 80388fc:	2104      	movs	r1, #4
    SeNvm->KeyList[itr].KeyID = SLOT_RAND_ZERO_KEY;
 80388fe:	2083      	movs	r0, #131	; 0x83
 8038900:	f882 00e8 	strb.w	r0, [r2, #232]	; 0xe8
    SeNvm->KeyList[itr++].KeyID = APP_KEY;
 8038904:	7413      	strb	r3, [r2, #16]
    SeNvm->KeyList[itr++].KeyID = MC_ROOT_KEY;
 8038906:	f882 1070 	strb.w	r1, [r2, #112]	; 0x70
    rv = C_OpenSession(0,  session_flags, NULL, 0, &session);
 803890a:	aa02      	add	r2, sp, #8
 803890c:	9200      	str	r2, [sp, #0]
 803890e:	4618      	mov	r0, r3
 8038910:	461a      	mov	r2, r3
    uint32_t ulCount = 0;
 8038912:	9303      	str	r3, [sp, #12]
    rv = C_OpenSession(0,  session_flags, NULL, 0, &session);
 8038914:	f7d0 fa22 	bl	8008d5c <SE_KMS_OpenSession>
    if (rv == CKR_OK)
 8038918:	b978      	cbnz	r0, 803893a <SecureElementInit+0xa6>
        rv = C_FindObjectsInit(session, NULL, 0);
 803891a:	4602      	mov	r2, r0
 803891c:	4601      	mov	r1, r0
 803891e:	9802      	ldr	r0, [sp, #8]
 8038920:	f7d0 fac8 	bl	8008eb4 <SE_KMS_FindObjectsInit>
    if (rv == CKR_OK)
 8038924:	b948      	cbnz	r0, 803893a <SecureElementInit+0xa6>
        rv = C_FindObjects(session, hObject, NUM_OF_KEYS, (CK_ULONG *) &ulCount);
 8038926:	9802      	ldr	r0, [sp, #8]
 8038928:	ab03      	add	r3, sp, #12
 803892a:	220a      	movs	r2, #10
 803892c:	a908      	add	r1, sp, #32
 803892e:	f7d0 fadd 	bl	8008eec <SE_KMS_FindObjects>
    if (rv == CKR_OK)
 8038932:	b910      	cbnz	r0, 803893a <SecureElementInit+0xa6>
        rv = C_FindObjectsFinal(session);
 8038934:	9802      	ldr	r0, [sp, #8]
 8038936:	f7d0 faf7 	bl	8008f28 <SE_KMS_FindObjectsFinal>
    if (ulCount <= NUM_OF_KEYS)
 803893a:	9b03      	ldr	r3, [sp, #12]
 803893c:	2b0a      	cmp	r3, #10
 803893e:	d93f      	bls.n	80389c0 <SecureElementInit+0x12c>
    if (session > 0)
 8038940:	9802      	ldr	r0, [sp, #8]
 8038942:	b108      	cbz	r0, 8038948 <SecureElementInit+0xb4>
        (void)C_CloseSession(session);
 8038944:	f7d0 fa2a 	bl	8008d9c <SE_KMS_CloseSession>
    SecureElementSetObjHandler(APP_KEY, KMS_APP_KEY_OBJECT_HANDLE);
 8038948:	210e      	movs	r1, #14
 803894a:	2000      	movs	r0, #0
 803894c:	f7ff ff8a 	bl	8038864 <SecureElementSetObjHandler>
    SecureElementSetObjHandler(NWK_KEY, KMS_NWK_KEY_OBJECT_HANDLE);
 8038950:	210f      	movs	r1, #15
 8038952:	2001      	movs	r0, #1
 8038954:	f7ff ff86 	bl	8038864 <SecureElementSetObjHandler>
    SecureElementSetObjHandler(APP_S_KEY, KMS_APP_S_KEY_OBJECT_HANDLE);
 8038958:	2111      	movs	r1, #17
 803895a:	2003      	movs	r0, #3
 803895c:	f7ff ff82 	bl	8038864 <SecureElementSetObjHandler>
    SecureElementSetObjHandler(NWK_S_KEY, KMS_NWK_S_KEY_OBJECT_HANDLE);
 8038960:	2110      	movs	r1, #16
 8038962:	2002      	movs	r0, #2
 8038964:	f7ff ff7e 	bl	8038864 <SecureElementSetObjHandler>
    MW_LOG(TS_OFF, VLEVEL_M, "###### OTAA ######\r\n");
 8038968:	2200      	movs	r2, #0
 803896a:	4611      	mov	r1, r2
 803896c:	4b18      	ldr	r3, [pc, #96]	; (80389d0 <SecureElementInit+0x13c>)
 803896e:	2002      	movs	r0, #2
 8038970:	f002 f998 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
    PrintKey(APP_KEY);
 8038974:	2000      	movs	r0, #0
 8038976:	f7ff fe81 	bl	803867c <PrintKey>
    PrintKey(NWK_KEY);
 803897a:	2001      	movs	r0, #1
 803897c:	f7ff fe7e 	bl	803867c <PrintKey>
    MW_LOG(TS_OFF, VLEVEL_M, "###### ABP  ######\r\n");
 8038980:	2200      	movs	r2, #0
 8038982:	4b14      	ldr	r3, [pc, #80]	; (80389d4 <SecureElementInit+0x140>)
 8038984:	4611      	mov	r1, r2
 8038986:	2002      	movs	r0, #2
 8038988:	f002 f98c 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
    PrintKey(APP_S_KEY);
 803898c:	2003      	movs	r0, #3
 803898e:	f7ff fe75 	bl	803867c <PrintKey>
    PrintKey(NWK_S_KEY);
 8038992:	2002      	movs	r0, #2
 8038994:	f7ff fe72 	bl	803867c <PrintKey>
    return SECURE_ELEMENT_SUCCESS;
 8038998:	2000      	movs	r0, #0
}
 803899a:	b012      	add	sp, #72	; 0x48
 803899c:	bd10      	pop	{r4, pc}
            if (hObject[i] > LAST_KMS_KEY_OBJECT_HANDLE)
 803899e:	aa12      	add	r2, sp, #72	; 0x48
 80389a0:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80389a4:	f853 1c28 	ldr.w	r1, [r3, #-40]
 80389a8:	2912      	cmp	r1, #18
 80389aa:	d903      	bls.n	80389b4 <SecureElementInit+0x120>
                if (rv == CKR_OK)
 80389ac:	b910      	cbnz	r0, 80389b4 <SecureElementInit+0x120>
                    rv = C_DestroyObject(session, hObject[i]);
 80389ae:	9802      	ldr	r0, [sp, #8]
 80389b0:	f7d0 fa2a 	bl	8008e08 <SE_KMS_DestroyObject>
        for (uint8_t i = 0; i < ulCount; i++)
 80389b4:	3401      	adds	r4, #1
 80389b6:	9a03      	ldr	r2, [sp, #12]
 80389b8:	b2e3      	uxtb	r3, r4
 80389ba:	4293      	cmp	r3, r2
 80389bc:	d3ef      	bcc.n	803899e <SecureElementInit+0x10a>
 80389be:	e7bf      	b.n	8038940 <SecureElementInit+0xac>
 80389c0:	2400      	movs	r4, #0
 80389c2:	e7f8      	b.n	80389b6 <SecureElementInit+0x122>
        return SECURE_ELEMENT_ERROR_NPE;
 80389c4:	2002      	movs	r0, #2
 80389c6:	e7e8      	b.n	803899a <SecureElementInit+0x106>
 80389c8:	0803bb84 	.word	0x0803bb84
 80389cc:	20005738 	.word	0x20005738
 80389d0:	0803c46d 	.word	0x0803c46d
 80389d4:	0803c482 	.word	0x0803c482

080389d8 <SecureElementComputeAesCmac>:
#endif /* LORAWAN_KMS */
}

SecureElementStatus_t SecureElementComputeAesCmac( uint8_t* micBxBuffer, uint8_t* buffer, uint16_t size,
                                                   KeyIdentifier_t keyID, uint32_t* cmac )
{
 80389d8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80389dc:	b089      	sub	sp, #36	; 0x24
    if( keyID >= LORAMAC_CRYPTO_MULTICAST_KEYS )
 80389de:	2b7e      	cmp	r3, #126	; 0x7e
{
 80389e0:	4681      	mov	r9, r0
 80389e2:	9f10      	ldr	r7, [sp, #64]	; 0x40
 80389e4:	4688      	mov	r8, r1
 80389e6:	4616      	mov	r6, r2
 80389e8:	4618      	mov	r0, r3
    if( keyID >= LORAMAC_CRYPTO_MULTICAST_KEYS )
 80389ea:	d851      	bhi.n	8038a90 <SecureElementComputeAesCmac+0xb8>
    if( ( buffer == NULL ) || ( cmac == NULL ) )
 80389ec:	2900      	cmp	r1, #0
 80389ee:	d04d      	beq.n	8038a8c <SecureElementComputeAesCmac+0xb4>
 80389f0:	2f00      	cmp	r7, #0
 80389f2:	d04b      	beq.n	8038a8c <SecureElementComputeAesCmac+0xb4>
    uint32_t tag_lenth = 0;
 80389f4:	2300      	movs	r3, #0
    CK_MECHANISM aes_cmac_mechanism = { CKM_AES_CMAC, (CK_VOID_PTR)NULL, 0 };
 80389f6:	f241 028a 	movw	r2, #4234	; 0x108a
    SecureElementStatus_t retval = GetKeyIndexByID(keyID, &key_handle);
 80389fa:	a904      	add	r1, sp, #16
    CK_MECHANISM aes_cmac_mechanism = { CKM_AES_CMAC, (CK_VOID_PTR)NULL, 0 };
 80389fc:	e9cd 2305 	strd	r2, r3, [sp, #20]
    uint32_t tag_lenth = 0;
 8038a00:	9303      	str	r3, [sp, #12]
    CK_MECHANISM aes_cmac_mechanism = { CKM_AES_CMAC, (CK_VOID_PTR)NULL, 0 };
 8038a02:	9307      	str	r3, [sp, #28]
    SecureElementStatus_t retval = GetKeyIndexByID(keyID, &key_handle);
 8038a04:	f7ff fdcc 	bl	80385a0 <GetKeyIndexByID>
    if (retval != SECURE_ELEMENT_SUCCESS)
 8038a08:	4605      	mov	r5, r0
 8038a0a:	2800      	cmp	r0, #0
 8038a0c:	d131      	bne.n	8038a72 <SecureElementComputeAesCmac+0x9a>
    rv = C_OpenSession(0,    session_flags, NULL, 0, &session);
 8038a0e:	ab02      	add	r3, sp, #8
 8038a10:	9300      	str	r3, [sp, #0]
 8038a12:	4602      	mov	r2, r0
 8038a14:	4603      	mov	r3, r0
 8038a16:	2104      	movs	r1, #4
 8038a18:	f7d0 f9a0 	bl	8008d5c <SE_KMS_OpenSession>
    if (rv == CKR_OK)
 8038a1c:	4604      	mov	r4, r0
 8038a1e:	b9f0      	cbnz	r0, 8038a5e <SecureElementComputeAesCmac+0x86>
        rv = C_SignInit(session, &aes_cmac_mechanism, key_handle);
 8038a20:	9a04      	ldr	r2, [sp, #16]
 8038a22:	9802      	ldr	r0, [sp, #8]
 8038a24:	a905      	add	r1, sp, #20
 8038a26:	f7d0 fbf9 	bl	800921c <SE_KMS_SignInit>
    if (rv == CKR_OK)
 8038a2a:	4604      	mov	r4, r0
 8038a2c:	b9b8      	cbnz	r0, 8038a5e <SecureElementComputeAesCmac+0x86>
        if (micBxBuffer != NULL)
 8038a2e:	ac03      	add	r4, sp, #12
 8038a30:	f1b9 0f00 	cmp.w	r9, #0
 8038a34:	d021      	beq.n	8038a7a <SecureElementComputeAesCmac+0xa2>
            memcpy1((uint8_t *) &input_align_combined_buf[0], (uint8_t *) micBxBuffer, SE_KEY_SIZE);
 8038a36:	4817      	ldr	r0, [pc, #92]	; (8038a94 <SecureElementComputeAesCmac+0xbc>)
 8038a38:	2210      	movs	r2, #16
 8038a3a:	4649      	mov	r1, r9
 8038a3c:	f000 fa4c 	bl	8038ed8 <memcpy1>
            memcpy1((uint8_t *) &input_align_combined_buf[SE_KEY_SIZE], (uint8_t *) buffer, size);
 8038a40:	4632      	mov	r2, r6
 8038a42:	4815      	ldr	r0, [pc, #84]	; (8038a98 <SecureElementComputeAesCmac+0xc0>)
 8038a44:	4641      	mov	r1, r8
 8038a46:	f000 fa47 	bl	8038ed8 <memcpy1>
            rv = C_Sign(session, (CK_BYTE_PTR)&input_align_combined_buf[0], size + SE_KEY_SIZE, &tag[0],
 8038a4a:	4b14      	ldr	r3, [pc, #80]	; (8038a9c <SecureElementComputeAesCmac+0xc4>)
 8038a4c:	9400      	str	r4, [sp, #0]
 8038a4e:	f106 0210 	add.w	r2, r6, #16
            rv = C_Sign(session, (CK_BYTE_PTR)&input_align_combined_buf[0], size, &tag[0],
 8038a52:	9802      	ldr	r0, [sp, #8]
 8038a54:	f5a3 7190 	sub.w	r1, r3, #288	; 0x120
 8038a58:	f7d0 fbfc 	bl	8009254 <SE_KMS_Sign>
 8038a5c:	4604      	mov	r4, r0
    (void)C_CloseSession(session);
 8038a5e:	9802      	ldr	r0, [sp, #8]
 8038a60:	f7d0 f99c 	bl	8008d9c <SE_KMS_CloseSession>
    *cmac = (uint32_t)((uint32_t) tag[3] << 24 | (uint32_t) tag[2] << 16 | (uint32_t) tag[1] << 8 |
 8038a64:	4b0e      	ldr	r3, [pc, #56]	; (8038aa0 <SecureElementComputeAesCmac+0xc8>)
        retval = SECURE_ELEMENT_ERROR;
 8038a66:	2c00      	cmp	r4, #0
    *cmac = (uint32_t)((uint32_t) tag[3] << 24 | (uint32_t) tag[2] << 16 | (uint32_t) tag[1] << 8 |
 8038a68:	f8d3 3124 	ldr.w	r3, [r3, #292]	; 0x124
 8038a6c:	603b      	str	r3, [r7, #0]
        retval = SECURE_ELEMENT_ERROR;
 8038a6e:	bf18      	it	ne
 8038a70:	2506      	movne	r5, #6
        // Never accept multicast key identifier for cmac computation
        return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
    }

    return ComputeCmac( micBxBuffer, buffer, size, keyID, cmac );
}
 8038a72:	4628      	mov	r0, r5
 8038a74:	b009      	add	sp, #36	; 0x24
 8038a76:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            memcpy1((uint8_t *) &input_align_combined_buf[0], (uint8_t *) buffer, size);
 8038a7a:	4632      	mov	r2, r6
 8038a7c:	4805      	ldr	r0, [pc, #20]	; (8038a94 <SecureElementComputeAesCmac+0xbc>)
 8038a7e:	4641      	mov	r1, r8
 8038a80:	f000 fa2a 	bl	8038ed8 <memcpy1>
            rv = C_Sign(session, (CK_BYTE_PTR)&input_align_combined_buf[0], size, &tag[0],
 8038a84:	4b05      	ldr	r3, [pc, #20]	; (8038a9c <SecureElementComputeAesCmac+0xc4>)
 8038a86:	9400      	str	r4, [sp, #0]
 8038a88:	4632      	mov	r2, r6
 8038a8a:	e7e2      	b.n	8038a52 <SecureElementComputeAesCmac+0x7a>
        return SECURE_ELEMENT_ERROR_NPE;
 8038a8c:	2502      	movs	r5, #2
    return ComputeCmac( micBxBuffer, buffer, size, keyID, cmac );
 8038a8e:	e7f0      	b.n	8038a72 <SecureElementComputeAesCmac+0x9a>
        return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 8038a90:	2503      	movs	r5, #3
 8038a92:	e7ee      	b.n	8038a72 <SecureElementComputeAesCmac+0x9a>
 8038a94:	2000573c 	.word	0x2000573c
 8038a98:	2000574c 	.word	0x2000574c
 8038a9c:	2000585c 	.word	0x2000585c
 8038aa0:	20005738 	.word	0x20005738

08038aa4 <SecureElementVerifyAesCmac>:

SecureElementStatus_t SecureElementVerifyAesCmac( uint8_t* buffer, uint16_t size, uint32_t expectedCmac,
                                                  KeyIdentifier_t keyID )
{
 8038aa4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8038aa6:	b08b      	sub	sp, #44	; 0x2c
 8038aa8:	460e      	mov	r6, r1
 8038aaa:	9203      	str	r2, [sp, #12]
    if( buffer == NULL )
 8038aac:	4607      	mov	r7, r0
 8038aae:	2800      	cmp	r0, #0
 8038ab0:	d032      	beq.n	8038b18 <SecureElementVerifyAesCmac+0x74>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

    /* AES CMAC Authentication variables */
    CK_MECHANISM aes_cmac_mechanism = { CKM_AES_CMAC, (CK_VOID_PTR)NULL, 0 };
 8038ab2:	2200      	movs	r2, #0
 8038ab4:	f241 018a 	movw	r1, #4234	; 0x108a
 8038ab8:	e9cd 1207 	strd	r1, r2, [sp, #28]

    retval = GetKeyIndexByID(keyID, &object_handle);
 8038abc:	4618      	mov	r0, r3
 8038abe:	a906      	add	r1, sp, #24
    CK_MECHANISM aes_cmac_mechanism = { CKM_AES_CMAC, (CK_VOID_PTR)NULL, 0 };
 8038ac0:	9209      	str	r2, [sp, #36]	; 0x24
    retval = GetKeyIndexByID(keyID, &object_handle);
 8038ac2:	f7ff fd6d 	bl	80385a0 <GetKeyIndexByID>
    if (retval != SECURE_ELEMENT_SUCCESS)
 8038ac6:	4605      	mov	r5, r0
 8038ac8:	bb18      	cbnz	r0, 8038b12 <SecureElementVerifyAesCmac+0x6e>
    {
        return retval;
    }

    /* Open session with KMS */
    rv = C_OpenSession(0,    session_flags, NULL, 0, &session);
 8038aca:	ab05      	add	r3, sp, #20
 8038acc:	9300      	str	r3, [sp, #0]
 8038ace:	4602      	mov	r2, r0
 8038ad0:	4603      	mov	r3, r0
 8038ad2:	2104      	movs	r1, #4
 8038ad4:	f7d0 f942 	bl	8008d5c <SE_KMS_OpenSession>

    /* Configure session to Verify the message in AES CMAC with settings included into the mechanism */
    if (rv == CKR_OK)
 8038ad8:	4604      	mov	r4, r0
 8038ada:	b9a0      	cbnz	r0, 8038b06 <SecureElementVerifyAesCmac+0x62>
    {
        rv = C_VerifyInit(session, &aes_cmac_mechanism, object_handle);
 8038adc:	9a06      	ldr	r2, [sp, #24]
 8038ade:	9805      	ldr	r0, [sp, #20]
 8038ae0:	a907      	add	r1, sp, #28
 8038ae2:	f7d0 fbd7 	bl	8009294 <SE_KMS_VerifyInit>
    }

    /* Verify the message */
    if (rv == CKR_OK)
 8038ae6:	4604      	mov	r4, r0
 8038ae8:	b968      	cbnz	r0, 8038b06 <SecureElementVerifyAesCmac+0x62>
    {
        memcpy1(input_align_combined_buf, buffer, size);
 8038aea:	480c      	ldr	r0, [pc, #48]	; (8038b1c <SecureElementVerifyAesCmac+0x78>)
 8038aec:	4632      	mov	r2, r6
 8038aee:	4639      	mov	r1, r7
 8038af0:	f000 f9f2 	bl	8038ed8 <memcpy1>
        rv = C_Verify(session, (CK_BYTE_PTR)input_align_combined_buf, size, (CK_BYTE_PTR)&expectedCmac, 4);
 8038af4:	2304      	movs	r3, #4
 8038af6:	9300      	str	r3, [sp, #0]
 8038af8:	4908      	ldr	r1, [pc, #32]	; (8038b1c <SecureElementVerifyAesCmac+0x78>)
 8038afa:	9805      	ldr	r0, [sp, #20]
 8038afc:	ab03      	add	r3, sp, #12
 8038afe:	4632      	mov	r2, r6
 8038b00:	f7d0 fbe4 	bl	80092cc <SE_KMS_Verify>
 8038b04:	4604      	mov	r4, r0
    }

    (void)C_CloseSession(session);
 8038b06:	9805      	ldr	r0, [sp, #20]
 8038b08:	f7d0 f948 	bl	8008d9c <SE_KMS_CloseSession>

    if (rv != CKR_OK)
    {
        retval = SECURE_ELEMENT_ERROR;
 8038b0c:	2c00      	cmp	r4, #0
 8038b0e:	bf18      	it	ne
 8038b10:	2506      	movne	r5, #6
    }

#endif /* LORAWAN_KMS */

    return retval;
}
 8038b12:	4628      	mov	r0, r5
 8038b14:	b00b      	add	sp, #44	; 0x2c
 8038b16:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 8038b18:	2502      	movs	r5, #2
 8038b1a:	e7fa      	b.n	8038b12 <SecureElementVerifyAesCmac+0x6e>
 8038b1c:	2000573c 	.word	0x2000573c

08038b20 <SecureElementAesEncrypt>:

SecureElementStatus_t SecureElementAesEncrypt( uint8_t* buffer, uint16_t size, KeyIdentifier_t keyID,
                                               uint8_t* encBuffer )
{
 8038b20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8038b24:	460e      	mov	r6, r1
 8038b26:	b08e      	sub	sp, #56	; 0x38
 8038b28:	461f      	mov	r7, r3
    if( buffer == NULL || encBuffer == NULL )
 8038b2a:	4680      	mov	r8, r0
 8038b2c:	2800      	cmp	r0, #0
 8038b2e:	d050      	beq.n	8038bd2 <SecureElementAesEncrypt+0xb2>
 8038b30:	2b00      	cmp	r3, #0
 8038b32:	d04e      	beq.n	8038bd2 <SecureElementAesEncrypt+0xb2>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

    // Check if the size is divisible by 16,
    if( ( size % 16 ) != 0 )
 8038b34:	f011 040f 	ands.w	r4, r1, #15
 8038b38:	d14d      	bne.n	8038bd6 <SecureElementAesEncrypt+0xb6>
    uint32_t encrypted_length = 0;
    CK_OBJECT_HANDLE object_handle;
    uint8_t dummy_tag[SE_KEY_SIZE] = {0};
    uint32_t dummy_tag_lenth = 0;

    CK_MECHANISM aes_ecb_mechanism = { CKM_AES_ECB, (CK_VOID_PTR *) NULL, 0 };
 8038b3a:	f241 0381 	movw	r3, #4225	; 0x1081

    SecureElementStatus_t retval = GetKeyIndexByID(keyID, &object_handle);
 8038b3e:	a905      	add	r1, sp, #20
 8038b40:	4610      	mov	r0, r2
    uint8_t dummy_tag[SE_KEY_SIZE] = {0};
 8038b42:	e9cd 440a 	strd	r4, r4, [sp, #40]	; 0x28
 8038b46:	e9cd 440c 	strd	r4, r4, [sp, #48]	; 0x30
    CK_MECHANISM aes_ecb_mechanism = { CKM_AES_ECB, (CK_VOID_PTR *) NULL, 0 };
 8038b4a:	e9cd 3407 	strd	r3, r4, [sp, #28]
    uint32_t encrypted_length = 0;
 8038b4e:	9404      	str	r4, [sp, #16]
    uint32_t dummy_tag_lenth = 0;
 8038b50:	9406      	str	r4, [sp, #24]
    CK_MECHANISM aes_ecb_mechanism = { CKM_AES_ECB, (CK_VOID_PTR *) NULL, 0 };
 8038b52:	9409      	str	r4, [sp, #36]	; 0x24
    SecureElementStatus_t retval = GetKeyIndexByID(keyID, &object_handle);
 8038b54:	f7ff fd24 	bl	80385a0 <GetKeyIndexByID>
    if (retval != SECURE_ELEMENT_SUCCESS)
 8038b58:	4605      	mov	r5, r0
 8038b5a:	2800      	cmp	r0, #0
 8038b5c:	d135      	bne.n	8038bca <SecureElementAesEncrypt+0xaa>
    {
        return retval;
    }

    /* Open session with KMS */
    rv = C_OpenSession(0,    session_flags, NULL, 0, &session);
 8038b5e:	ab03      	add	r3, sp, #12
 8038b60:	9300      	str	r3, [sp, #0]
 8038b62:	4602      	mov	r2, r0
 8038b64:	4603      	mov	r3, r0
 8038b66:	2104      	movs	r1, #4
 8038b68:	f7d0 f8f8 	bl	8008d5c <SE_KMS_OpenSession>

    /* Configure session to encrypt message in AES ECB with settings included into the mechanism */
    if (rv == CKR_OK)
 8038b6c:	4604      	mov	r4, r0
 8038b6e:	bb30      	cbnz	r0, 8038bbe <SecureElementAesEncrypt+0x9e>
    {
        rv = C_EncryptInit(session, &aes_ecb_mechanism, object_handle);
 8038b70:	9a05      	ldr	r2, [sp, #20]
 8038b72:	9803      	ldr	r0, [sp, #12]
 8038b74:	a907      	add	r1, sp, #28
 8038b76:	f7d0 f9ef 	bl	8008f58 <SE_KMS_EncryptInit>
    }

    /* Encrypt clear message */
    if (rv == CKR_OK)
 8038b7a:	4604      	mov	r4, r0
 8038b7c:	b9f8      	cbnz	r0, 8038bbe <SecureElementAesEncrypt+0x9e>
    {
        memcpy1(input_align_combined_buf, buffer, size);
 8038b7e:	4817      	ldr	r0, [pc, #92]	; (8038bdc <SecureElementAesEncrypt+0xbc>)
 8038b80:	4632      	mov	r2, r6
 8038b82:	4641      	mov	r1, r8
 8038b84:	f000 f9a8 	bl	8038ed8 <memcpy1>
        encrypted_length = sizeof(output_align);
 8038b88:	f44f 7387 	mov.w	r3, #270	; 0x10e
 8038b8c:	9304      	str	r3, [sp, #16]
        rv = C_EncryptUpdate(session, (CK_BYTE_PTR)input_align_combined_buf, size,
 8038b8e:	ab04      	add	r3, sp, #16
 8038b90:	9300      	str	r3, [sp, #0]
 8038b92:	4b13      	ldr	r3, [pc, #76]	; (8038be0 <SecureElementAesEncrypt+0xc0>)
 8038b94:	9803      	ldr	r0, [sp, #12]
 8038b96:	4632      	mov	r2, r6
 8038b98:	f5a3 7198 	sub.w	r1, r3, #304	; 0x130
 8038b9c:	f7d0 fa18 	bl	8008fd0 <SE_KMS_EncryptUpdate>
                             output_align, (CK_ULONG_PTR)&encrypted_length);
        memcpy1(encBuffer, output_align, size);
 8038ba0:	490f      	ldr	r1, [pc, #60]	; (8038be0 <SecureElementAesEncrypt+0xc0>)
        rv = C_EncryptUpdate(session, (CK_BYTE_PTR)input_align_combined_buf, size,
 8038ba2:	4604      	mov	r4, r0
        memcpy1(encBuffer, output_align, size);
 8038ba4:	4632      	mov	r2, r6
 8038ba6:	4638      	mov	r0, r7
 8038ba8:	f000 f996 	bl	8038ed8 <memcpy1>
    }

    /* In this case C_EncryptFinal is just called to Free the Alloc mem */
    if (rv == CKR_OK)
 8038bac:	b93c      	cbnz	r4, 8038bbe <SecureElementAesEncrypt+0x9e>
    {
        dummy_tag_lenth = sizeof(tag);
 8038bae:	2310      	movs	r3, #16
        rv = C_EncryptFinal(session, &dummy_tag[0], (CK_ULONG_PTR)&dummy_tag_lenth);
 8038bb0:	9803      	ldr	r0, [sp, #12]
        dummy_tag_lenth = sizeof(tag);
 8038bb2:	9306      	str	r3, [sp, #24]
        rv = C_EncryptFinal(session, &dummy_tag[0], (CK_ULONG_PTR)&dummy_tag_lenth);
 8038bb4:	aa06      	add	r2, sp, #24
 8038bb6:	a90a      	add	r1, sp, #40	; 0x28
 8038bb8:	f7d0 fa2a 	bl	8009010 <SE_KMS_EncryptFinal>
 8038bbc:	4604      	mov	r4, r0
    }

    /* Close session with KMS */
    (void)C_CloseSession(session);
 8038bbe:	9803      	ldr	r0, [sp, #12]
 8038bc0:	f7d0 f8ec 	bl	8008d9c <SE_KMS_CloseSession>

    if (rv != CKR_OK)
    {
        retval = SECURE_ELEMENT_ERROR;
 8038bc4:	2c00      	cmp	r4, #0
 8038bc6:	bf18      	it	ne
 8038bc8:	2506      	movne	r5, #6
    }
#endif /* LORAWAN_KMS */

    return retval;
}
 8038bca:	4628      	mov	r0, r5
 8038bcc:	b00e      	add	sp, #56	; 0x38
 8038bce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 8038bd2:	2502      	movs	r5, #2
 8038bd4:	e7f9      	b.n	8038bca <SecureElementAesEncrypt+0xaa>
        return SECURE_ELEMENT_ERROR_BUF_SIZE;
 8038bd6:	2505      	movs	r5, #5
 8038bd8:	e7f7      	b.n	8038bca <SecureElementAesEncrypt+0xaa>
 8038bda:	bf00      	nop
 8038bdc:	2000573c 	.word	0x2000573c
 8038be0:	2000586c 	.word	0x2000586c

08038be4 <SecureElementSetKey>:
{
 8038be4:	b570      	push	{r4, r5, r6, lr}
 8038be6:	4606      	mov	r6, r0
 8038be8:	b0a0      	sub	sp, #128	; 0x80
    if( key == NULL )
 8038bea:	4608      	mov	r0, r1
 8038bec:	2900      	cmp	r1, #0
 8038bee:	d07a      	beq.n	8038ce6 <SecureElementSetKey+0x102>
    CK_ULONG template_type = CKK_AES;
 8038bf0:	2204      	movs	r2, #4
 8038bf2:	231f      	movs	r3, #31
 8038bf4:	e9cd 2304 	strd	r2, r3, [sp, #16]
    CK_ULONG template_true = CK_TRUE;
 8038bf8:	680b      	ldr	r3, [r1, #0]
 8038bfa:	ba1b      	rev	r3, r3
    uint32_t key_ui32[] =
 8038bfc:	9309      	str	r3, [sp, #36]	; 0x24
 8038bfe:	684b      	ldr	r3, [r1, #4]
 8038c00:	ba1b      	rev	r3, r3
 8038c02:	930a      	str	r3, [sp, #40]	; 0x28
 8038c04:	688b      	ldr	r3, [r1, #8]
 8038c06:	ba1b      	rev	r3, r3
 8038c08:	930b      	str	r3, [sp, #44]	; 0x2c
 8038c0a:	68cb      	ldr	r3, [r1, #12]
    uint32_t specific_label[] = {GlobalTemplateLabel, 0UL};
 8038c0c:	4937      	ldr	r1, [pc, #220]	; (8038cec <SecureElementSetKey+0x108>)
 8038c0e:	ba1b      	rev	r3, r3
    uint32_t key_ui32[] =
 8038c10:	930c      	str	r3, [sp, #48]	; 0x30
    uint32_t specific_label[] = {GlobalTemplateLabel, 0UL};
 8038c12:	2300      	movs	r3, #0
    CK_ULONG template_true = CK_TRUE;
 8038c14:	2201      	movs	r2, #1
    uint32_t specific_label[] = {GlobalTemplateLabel, 0UL};
 8038c16:	e9cd 1307 	strd	r1, r3, [sp, #28]
    CK_ATTRIBUTE key_attribute_template[] =
 8038c1a:	a904      	add	r1, sp, #16
 8038c1c:	e9cd 1212 	strd	r1, r2, [sp, #72]	; 0x48
 8038c20:	f44f 7180 	mov.w	r1, #256	; 0x100
 8038c24:	9114      	str	r1, [sp, #80]	; 0x50
 8038c26:	a905      	add	r1, sp, #20
 8038c28:	e9cd 1215 	strd	r1, r2, [sp, #84]	; 0x54
 8038c2c:	2111      	movs	r1, #17
 8038c2e:	9117      	str	r1, [sp, #92]	; 0x5c
 8038c30:	a909      	add	r1, sp, #36	; 0x24
 8038c32:	f44f 74b1 	mov.w	r4, #354	; 0x162
 8038c36:	9118      	str	r1, [sp, #96]	; 0x60
 8038c38:	2110      	movs	r1, #16
 8038c3a:	e9cd 1419 	strd	r1, r4, [sp, #100]	; 0x64
 8038c3e:	ac06      	add	r4, sp, #24
 8038c40:	e9cd 421b 	strd	r4, r2, [sp, #108]	; 0x6c
    CK_ULONG template_true = CK_TRUE;
 8038c44:	9206      	str	r2, [sp, #24]
    CK_ATTRIBUTE key_attribute_template[] =
 8038c46:	2203      	movs	r2, #3
 8038c48:	921d      	str	r2, [sp, #116]	; 0x74
 8038c4a:	aa07      	add	r2, sp, #28
 8038c4c:	921e      	str	r2, [sp, #120]	; 0x78
    if ( keyID == MC_KEY_0 )
 8038c4e:	2e80      	cmp	r6, #128	; 0x80
    CK_ATTRIBUTE key_attribute_template[] =
 8038c50:	f04f 0208 	mov.w	r2, #8
 8038c54:	9311      	str	r3, [sp, #68]	; 0x44
 8038c56:	921f      	str	r2, [sp, #124]	; 0x7c
    if ( keyID == MC_KEY_0 )
 8038c58:	d118      	bne.n	8038c8c <SecureElementSetKey+0xa8>
        uint8_t decryptedKey[16] = { 0 };
 8038c5a:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
 8038c5e:	e9cd 330f 	strd	r3, r3, [sp, #60]	; 0x3c
        if (SECURE_ELEMENT_SUCCESS != SecureElementAesEncrypt( key, 16, MC_KE_KEY, decryptedKey ))
 8038c62:	227f      	movs	r2, #127	; 0x7f
 8038c64:	ab0d      	add	r3, sp, #52	; 0x34
 8038c66:	f7ff ff5b 	bl	8038b20 <SecureElementAesEncrypt>
 8038c6a:	b118      	cbz	r0, 8038c74 <SecureElementSetKey+0x90>
        return SECURE_ELEMENT_ERROR;
 8038c6c:	2406      	movs	r4, #6
}
 8038c6e:	4620      	mov	r0, r4
 8038c70:	b020      	add	sp, #128	; 0x80
 8038c72:	bd70      	pop	{r4, r5, r6, pc}
        key_ui32[0] = decryptedKey[3]  | (decryptedKey[2] << 8)  | (decryptedKey[1] << 16)  | (decryptedKey[0] << 24);
 8038c74:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8038c76:	ba1b      	rev	r3, r3
 8038c78:	9309      	str	r3, [sp, #36]	; 0x24
        key_ui32[1] = decryptedKey[7]  | (decryptedKey[6] << 8)  | (decryptedKey[5] << 16)  | (decryptedKey[4] << 24);
 8038c7a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8038c7c:	ba1b      	rev	r3, r3
 8038c7e:	930a      	str	r3, [sp, #40]	; 0x28
        key_ui32[2] = decryptedKey[11] | (decryptedKey[10] << 8) | (decryptedKey[9] << 16)  | (decryptedKey[8] << 24);
 8038c80:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8038c82:	ba1b      	rev	r3, r3
 8038c84:	930b      	str	r3, [sp, #44]	; 0x2c
        key_ui32[3] = decryptedKey[15] | (decryptedKey[14] << 8) | (decryptedKey[13] << 16) | (decryptedKey[12] << 24);
 8038c86:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8038c88:	ba1b      	rev	r3, r3
 8038c8a:	930c      	str	r3, [sp, #48]	; 0x30
    if (SECURE_ELEMENT_SUCCESS != GetKeyIndexByID(keyID, &key_handle))
 8038c8c:	a90d      	add	r1, sp, #52	; 0x34
 8038c8e:	4630      	mov	r0, r6
 8038c90:	f7ff fc86 	bl	80385a0 <GetKeyIndexByID>
 8038c94:	2800      	cmp	r0, #0
 8038c96:	d1e9      	bne.n	8038c6c <SecureElementSetKey+0x88>
    if (SECURE_ELEMENT_SUCCESS != SecureElementDeleteDynamicKeys(keyID, &specific_label[1]))
 8038c98:	a908      	add	r1, sp, #32
 8038c9a:	4630      	mov	r0, r6
 8038c9c:	f7ff fd5c 	bl	8038758 <SecureElementDeleteDynamicKeys>
 8038ca0:	4603      	mov	r3, r0
 8038ca2:	2800      	cmp	r0, #0
 8038ca4:	d1e2      	bne.n	8038c6c <SecureElementSetKey+0x88>
    rv = C_OpenSession(0, session_flags, NULL, 0, &session);
 8038ca6:	aa03      	add	r2, sp, #12
 8038ca8:	9200      	str	r2, [sp, #0]
 8038caa:	2104      	movs	r1, #4
 8038cac:	4602      	mov	r2, r0
 8038cae:	f7d0 f855 	bl	8008d5c <SE_KMS_OpenSession>
    if (rv == CKR_OK)
 8038cb2:	4605      	mov	r5, r0
 8038cb4:	b9a8      	cbnz	r0, 8038ce2 <SecureElementSetKey+0xfe>
        rv = C_CreateObject(session, key_attribute_template, sizeof(key_attribute_template) / sizeof(CK_ATTRIBUTE),
 8038cb6:	9803      	ldr	r0, [sp, #12]
 8038cb8:	ab0d      	add	r3, sp, #52	; 0x34
 8038cba:	2205      	movs	r2, #5
 8038cbc:	a911      	add	r1, sp, #68	; 0x44
 8038cbe:	f7d0 f885 	bl	8008dcc <SE_KMS_CreateObject>
    if (rv == CKR_OK)
 8038cc2:	4605      	mov	r5, r0
 8038cc4:	b968      	cbnz	r0, 8038ce2 <SecureElementSetKey+0xfe>
        retval = SecureElementSetObjHandler(keyID, key_handle);
 8038cc6:	990d      	ldr	r1, [sp, #52]	; 0x34
 8038cc8:	4630      	mov	r0, r6
 8038cca:	f7ff fdcb 	bl	8038864 <SecureElementSetObjHandler>
 8038cce:	4604      	mov	r4, r0
    PrintKey(keyID);
 8038cd0:	4630      	mov	r0, r6
 8038cd2:	f7ff fcd3 	bl	803867c <PrintKey>
    (void)C_CloseSession(session);
 8038cd6:	9803      	ldr	r0, [sp, #12]
 8038cd8:	f7d0 f860 	bl	8008d9c <SE_KMS_CloseSession>
    if (rv != CKR_OK)
 8038cdc:	2d00      	cmp	r5, #0
 8038cde:	d0c6      	beq.n	8038c6e <SecureElementSetKey+0x8a>
 8038ce0:	e7c4      	b.n	8038c6c <SecureElementSetKey+0x88>
    SecureElementStatus_t retval = SECURE_ELEMENT_ERROR;
 8038ce2:	2406      	movs	r4, #6
 8038ce4:	e7f4      	b.n	8038cd0 <SecureElementSetKey+0xec>
        return SECURE_ELEMENT_ERROR_NPE;
 8038ce6:	2402      	movs	r4, #2
 8038ce8:	e7c1      	b.n	8038c6e <SecureElementSetKey+0x8a>
 8038cea:	bf00      	nop
 8038cec:	444e524c 	.word	0x444e524c

08038cf0 <SecureElementDeriveAndStoreKey>:

SecureElementStatus_t SecureElementDeriveAndStoreKey( uint8_t* input, KeyIdentifier_t rootKeyID,
                                                      KeyIdentifier_t targetKeyID )
{
 8038cf0:	b570      	push	{r4, r5, r6, lr}
 8038cf2:	460b      	mov	r3, r1
 8038cf4:	b08e      	sub	sp, #56	; 0x38
 8038cf6:	4616      	mov	r6, r2
    if( input == NULL )
 8038cf8:	2800      	cmp	r0, #0
 8038cfa:	d049      	beq.n	8038d90 <SecureElementDeriveAndStoreKey+0xa0>
    }

    SecureElementStatus_t retval  = SECURE_ELEMENT_ERROR;

    // In case of MC_KE_KEY, only McRootKey can be used as root key
    if( targetKeyID == MC_KE_KEY )
 8038cfc:	2a7f      	cmp	r2, #127	; 0x7f
 8038cfe:	d101      	bne.n	8038d04 <SecureElementDeriveAndStoreKey+0x14>
    {
        if( rootKeyID != MC_ROOT_KEY )
 8038d00:	2904      	cmp	r1, #4
 8038d02:	d147      	bne.n	8038d94 <SecureElementDeriveAndStoreKey+0xa4>
#else /* LORAWAN_KMS == 1 */
    CK_RV rv;
    CK_SESSION_HANDLE session;
    CK_FLAGS session_flags = CKF_SERIAL_SESSION;    /* Read ONLY session */
    /* Key derivation */
    CK_MECHANISM            mech = {CKM_AES_ECB_ENCRYPT_DATA, input, SE_KEY_SIZE};
 8038d04:	f241 1204 	movw	r2, #4356	; 0x1104
 8038d08:	e9cd 2008 	strd	r2, r0, [sp, #32]
    CK_OBJECT_HANDLE  derived_object_handle;
    CK_OBJECT_HANDLE    rootkey_object_handle;
    uint32_t specific_label[] = {GlobalTemplateLabel, 0UL};
 8038d0c:	4822      	ldr	r0, [pc, #136]	; (8038d98 <SecureElementDeriveAndStoreKey+0xa8>)
    CK_MECHANISM            mech = {CKM_AES_ECB_ENCRYPT_DATA, input, SE_KEY_SIZE};
 8038d0e:	2210      	movs	r2, #16
 8038d10:	920a      	str	r2, [sp, #40]	; 0x28
    uint32_t specific_label[] = {GlobalTemplateLabel, 0UL};
 8038d12:	2200      	movs	r2, #0
 8038d14:	e9cd 0206 	strd	r0, r2, [sp, #24]
    CK_ATTRIBUTE DeriveKey_template = {CKA_LABEL, (CK_VOID_PTR)specific_label, sizeof(specific_label)};
 8038d18:	2203      	movs	r2, #3
 8038d1a:	920b      	str	r2, [sp, #44]	; 0x2c
 8038d1c:	aa06      	add	r2, sp, #24
 8038d1e:	920c      	str	r2, [sp, #48]	; 0x30

    /* Derive key */
    if (SECURE_ELEMENT_SUCCESS != GetKeyIndexByID(rootKeyID, &rootkey_object_handle))
 8038d20:	a905      	add	r1, sp, #20
    CK_ATTRIBUTE DeriveKey_template = {CKA_LABEL, (CK_VOID_PTR)specific_label, sizeof(specific_label)};
 8038d22:	2208      	movs	r2, #8
    if (SECURE_ELEMENT_SUCCESS != GetKeyIndexByID(rootKeyID, &rootkey_object_handle))
 8038d24:	4618      	mov	r0, r3
    CK_ATTRIBUTE DeriveKey_template = {CKA_LABEL, (CK_VOID_PTR)specific_label, sizeof(specific_label)};
 8038d26:	920d      	str	r2, [sp, #52]	; 0x34
    if (SECURE_ELEMENT_SUCCESS != GetKeyIndexByID(rootKeyID, &rootkey_object_handle))
 8038d28:	f7ff fc3a 	bl	80385a0 <GetKeyIndexByID>
 8038d2c:	bb50      	cbnz	r0, 8038d84 <SecureElementDeriveAndStoreKey+0x94>
    {
        return SECURE_ELEMENT_ERROR;
    }

    if (SECURE_ELEMENT_SUCCESS != GetKeyIndexByID(targetKeyID, &derived_object_handle))
 8038d2e:	ac04      	add	r4, sp, #16
 8038d30:	4621      	mov	r1, r4
 8038d32:	4630      	mov	r0, r6
 8038d34:	f7ff fc34 	bl	80385a0 <GetKeyIndexByID>
 8038d38:	bb20      	cbnz	r0, 8038d84 <SecureElementDeriveAndStoreKey+0x94>
    {
        return SECURE_ELEMENT_ERROR;
    }

    if (SECURE_ELEMENT_SUCCESS != SecureElementDeleteDynamicKeys(targetKeyID, &specific_label[1]))
 8038d3a:	a907      	add	r1, sp, #28
 8038d3c:	4630      	mov	r0, r6
 8038d3e:	f7ff fd0b 	bl	8038758 <SecureElementDeleteDynamicKeys>
 8038d42:	4603      	mov	r3, r0
 8038d44:	b9f0      	cbnz	r0, 8038d84 <SecureElementDeriveAndStoreKey+0x94>
    {
        return SECURE_ELEMENT_ERROR;
    }

    /* Open session with KMS */
    rv = C_OpenSession(0,    session_flags, NULL, 0, &session);
 8038d46:	aa03      	add	r2, sp, #12
 8038d48:	9200      	str	r2, [sp, #0]
 8038d4a:	2104      	movs	r1, #4
 8038d4c:	4602      	mov	r2, r0
 8038d4e:	f7d0 f805 	bl	8008d5c <SE_KMS_OpenSession>

    /* Derive key with pass phrase */
    if (rv == CKR_OK)
 8038d52:	4605      	mov	r5, r0
 8038d54:	b9d0      	cbnz	r0, 8038d8c <SecureElementDeriveAndStoreKey+0x9c>
    {
        rv = C_DeriveKey(session, &(mech), rootkey_object_handle,
 8038d56:	2301      	movs	r3, #1
 8038d58:	9300      	str	r3, [sp, #0]
 8038d5a:	9a05      	ldr	r2, [sp, #20]
 8038d5c:	9803      	ldr	r0, [sp, #12]
 8038d5e:	9401      	str	r4, [sp, #4]
 8038d60:	ab0b      	add	r3, sp, #44	; 0x2c
 8038d62:	a908      	add	r1, sp, #32
 8038d64:	f7d0 fad2 	bl	800930c <SE_KMS_DeriveKey>
                         &DeriveKey_template, sizeof(DeriveKey_template) / sizeof(CK_ATTRIBUTE), &derived_object_handle);
    }

    if (rv == CKR_OK)
 8038d68:	4605      	mov	r5, r0
 8038d6a:	b978      	cbnz	r0, 8038d8c <SecureElementDeriveAndStoreKey+0x9c>
    {
        /* Store Derived Index in table */
        retval = SecureElementSetObjHandler(targetKeyID, derived_object_handle);
 8038d6c:	9904      	ldr	r1, [sp, #16]
 8038d6e:	4630      	mov	r0, r6
 8038d70:	f7ff fd78 	bl	8038864 <SecureElementSetObjHandler>
 8038d74:	4604      	mov	r4, r0
    }

    PrintKey(targetKeyID);
 8038d76:	4630      	mov	r0, r6
 8038d78:	f7ff fc80 	bl	803867c <PrintKey>

    /* Close session with KMS */
    (void)C_CloseSession(session);
 8038d7c:	9803      	ldr	r0, [sp, #12]
 8038d7e:	f7d0 f80d 	bl	8008d9c <SE_KMS_CloseSession>

    if (rv != CKR_OK)
 8038d82:	b105      	cbz	r5, 8038d86 <SecureElementDeriveAndStoreKey+0x96>
    {
        retval = SECURE_ELEMENT_ERROR;
 8038d84:	2406      	movs	r4, #6
    }
    return retval;
#endif /* LORAWAN_KMS */
}
 8038d86:	4620      	mov	r0, r4
 8038d88:	b00e      	add	sp, #56	; 0x38
 8038d8a:	bd70      	pop	{r4, r5, r6, pc}
    SecureElementStatus_t retval  = SECURE_ELEMENT_ERROR;
 8038d8c:	2406      	movs	r4, #6
 8038d8e:	e7f2      	b.n	8038d76 <SecureElementDeriveAndStoreKey+0x86>
        return SECURE_ELEMENT_ERROR_NPE;
 8038d90:	2402      	movs	r4, #2
 8038d92:	e7f8      	b.n	8038d86 <SecureElementDeriveAndStoreKey+0x96>
            return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 8038d94:	2403      	movs	r4, #3
 8038d96:	e7f6      	b.n	8038d86 <SecureElementDeriveAndStoreKey+0x96>
 8038d98:	444e524c 	.word	0x444e524c

08038d9c <SecureElementProcessJoinAccept>:

SecureElementStatus_t SecureElementProcessJoinAccept( JoinReqIdentifier_t joinReqType, uint8_t* joinEui,
                                                      uint16_t devNonce, uint8_t* encJoinAccept,
                                                      uint8_t encJoinAcceptSize, uint8_t* decJoinAccept,
                                                      uint8_t* versionMinor )
{
 8038d9c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if( ( encJoinAccept == NULL ) || ( decJoinAccept == NULL ) || ( versionMinor == NULL ) )
 8038da0:	461f      	mov	r7, r3
{
 8038da2:	e9dd 5807 	ldrd	r5, r8, [sp, #28]
 8038da6:	f89d 4018 	ldrb.w	r4, [sp, #24]
    if( ( encJoinAccept == NULL ) || ( decJoinAccept == NULL ) || ( versionMinor == NULL ) )
 8038daa:	b393      	cbz	r3, 8038e12 <SecureElementProcessJoinAccept+0x76>
 8038dac:	b38d      	cbz	r5, 8038e12 <SecureElementProcessJoinAccept+0x76>
 8038dae:	f1b8 0f00 	cmp.w	r8, #0
 8038db2:	d02e      	beq.n	8038e12 <SecureElementProcessJoinAccept+0x76>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

    // Check that frame size isn't bigger than a JoinAccept with CFList size
    if( encJoinAcceptSize > LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE )
 8038db4:	2c21      	cmp	r4, #33	; 0x21
 8038db6:	d82e      	bhi.n	8038e16 <SecureElementProcessJoinAccept+0x7a>
    {
        encKeyID = J_S_ENC_KEY;
    }
#endif /* USE_LRWAN_1_1_X_CRYPTO == 1 */

    memcpy1( decJoinAccept, encJoinAccept, encJoinAcceptSize );
 8038db8:	b2a6      	uxth	r6, r4
 8038dba:	4619      	mov	r1, r3
 8038dbc:	4632      	mov	r2, r6
 8038dbe:	4628      	mov	r0, r5
 8038dc0:	f000 f88a 	bl	8038ed8 <memcpy1>

    // Decrypt JoinAccept, skip MHDR
    if( SecureElementAesEncrypt( encJoinAccept + LORAMAC_MHDR_FIELD_SIZE, encJoinAcceptSize - LORAMAC_MHDR_FIELD_SIZE,
 8038dc4:	1e71      	subs	r1, r6, #1
 8038dc6:	2201      	movs	r2, #1
 8038dc8:	1c6b      	adds	r3, r5, #1
 8038dca:	b289      	uxth	r1, r1
 8038dcc:	18b8      	adds	r0, r7, r2
 8038dce:	f7ff fea7 	bl	8038b20 <SecureElementAesEncrypt>
 8038dd2:	bb10      	cbnz	r0, 8038e1a <SecureElementProcessJoinAccept+0x7e>
                                 encKeyID, decJoinAccept + LORAMAC_MHDR_FIELD_SIZE ) != SECURE_ELEMENT_SUCCESS )
    {
        return SECURE_ELEMENT_FAIL_ENCRYPT;
    }

    *versionMinor = ( ( decJoinAccept[11] & 0x80 ) == 0x80 ) ? 1 : 0;
 8038dd4:	7aeb      	ldrb	r3, [r5, #11]
 8038dd6:	09db      	lsrs	r3, r3, #7
 8038dd8:	f888 3000 	strb.w	r3, [r8]
    //  - Header buffer to be used for MIC computation
    //        - LoRaWAN 1.0.x : micHeader = [MHDR(1)]
    //        - LoRaWAN 1.1.x : micHeader = [JoinReqType(1), JoinEUI(8), DevNonce(2), MHDR(1)]

    // Verify mic
    if( *versionMinor == 0 )
 8038ddc:	b9fb      	cbnz	r3, 8038e1e <SecureElementProcessJoinAccept+0x82>
    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 2] << 16 );
 8038dde:	192b      	adds	r3, r5, r4
    {
        // For LoRaWAN 1.0.x
        //   cmac = aes128_cmac(NwkKey, MHDR |  JoinNonce | NetID | DevAddr | DLSettings | RxDelay | CFList |
        //   CFListType)
        if( SecureElementVerifyAesCmac( decJoinAccept, ( encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE ), mic, NWK_KEY ) !=
 8038de0:	1f31      	subs	r1, r6, #4
    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 3] << 24 );
 8038de2:	f813 0c01 	ldrb.w	r0, [r3, #-1]
    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 2] << 16 );
 8038de6:	f813 2c02 	ldrb.w	r2, [r3, #-2]
    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 3] << 24 );
 8038dea:	0600      	lsls	r0, r0, #24
 8038dec:	ea40 4002 	orr.w	r0, r0, r2, lsl #16
    mic = ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE] << 0 );
 8038df0:	f813 2c04 	ldrb.w	r2, [r3, #-4]
 8038df4:	4310      	orrs	r0, r2
    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 1] << 8 );
 8038df6:	f813 2c03 	ldrb.w	r2, [r3, #-3]
        if( SecureElementVerifyAesCmac( decJoinAccept, ( encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE ), mic, NWK_KEY ) !=
 8038dfa:	b289      	uxth	r1, r1
 8038dfc:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
 8038e00:	2301      	movs	r3, #1
 8038e02:	4628      	mov	r0, r5
 8038e04:	f7ff fe4e 	bl	8038aa4 <SecureElementVerifyAesCmac>
        return SECURE_ELEMENT_ERROR_NPE;
 8038e08:	3800      	subs	r0, #0
 8038e0a:	bf18      	it	ne
 8038e0c:	2001      	movne	r0, #1
    {
        return SECURE_ELEMENT_ERROR_INVALID_LORAWAM_SPEC_VERSION;
    }

    return SECURE_ELEMENT_SUCCESS;
}
 8038e0e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 8038e12:	2002      	movs	r0, #2
 8038e14:	e7fb      	b.n	8038e0e <SecureElementProcessJoinAccept+0x72>
        return SECURE_ELEMENT_ERROR_BUF_SIZE;
 8038e16:	2005      	movs	r0, #5
 8038e18:	e7f9      	b.n	8038e0e <SecureElementProcessJoinAccept+0x72>
        return SECURE_ELEMENT_FAIL_ENCRYPT;
 8038e1a:	2007      	movs	r0, #7
 8038e1c:	e7f7      	b.n	8038e0e <SecureElementProcessJoinAccept+0x72>
        return SECURE_ELEMENT_ERROR_INVALID_LORAWAM_SPEC_VERSION;
 8038e1e:	2004      	movs	r0, #4
 8038e20:	e7f5      	b.n	8038e0e <SecureElementProcessJoinAccept+0x72>
	...

08038e24 <SecureElementRandomNumber>:

SecureElementStatus_t SecureElementRandomNumber( uint32_t* randomNum )
{
 8038e24:	b510      	push	{r4, lr}
    if( randomNum == NULL )
 8038e26:	4604      	mov	r4, r0
 8038e28:	b128      	cbz	r0, 8038e36 <SecureElementRandomNumber+0x12>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }
    *randomNum = Radio.Random();
 8038e2a:	4b04      	ldr	r3, [pc, #16]	; (8038e3c <SecureElementRandomNumber+0x18>)
 8038e2c:	695b      	ldr	r3, [r3, #20]
 8038e2e:	4798      	blx	r3
 8038e30:	6020      	str	r0, [r4, #0]
    return SECURE_ELEMENT_SUCCESS;
 8038e32:	2000      	movs	r0, #0
}
 8038e34:	bd10      	pop	{r4, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 8038e36:	2002      	movs	r0, #2
 8038e38:	e7fc      	b.n	8038e34 <SecureElementRandomNumber+0x10>
 8038e3a:	bf00      	nop
 8038e3c:	0803bbd8 	.word	0x0803bbd8

08038e40 <SecureElementSetDevEui>:

SecureElementStatus_t SecureElementSetDevEui( uint8_t* devEui )
{
 8038e40:	b508      	push	{r3, lr}
    if( devEui == NULL )
 8038e42:	4601      	mov	r1, r0
 8038e44:	b130      	cbz	r0, 8038e54 <SecureElementSetDevEui+0x14>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }
    memcpy1( SeNvm->DevEui, devEui, SE_EUI_SIZE );
 8038e46:	4b04      	ldr	r3, [pc, #16]	; (8038e58 <SecureElementSetDevEui+0x18>)
 8038e48:	2208      	movs	r2, #8
 8038e4a:	6818      	ldr	r0, [r3, #0]
 8038e4c:	f000 f844 	bl	8038ed8 <memcpy1>
    return SECURE_ELEMENT_SUCCESS;
 8038e50:	2000      	movs	r0, #0
}
 8038e52:	bd08      	pop	{r3, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 8038e54:	2002      	movs	r0, #2
 8038e56:	e7fc      	b.n	8038e52 <SecureElementSetDevEui+0x12>
 8038e58:	20005738 	.word	0x20005738

08038e5c <SecureElementGetDevEui>:

uint8_t* SecureElementGetDevEui( void )
{
    return SeNvm->DevEui;
}
 8038e5c:	4b01      	ldr	r3, [pc, #4]	; (8038e64 <SecureElementGetDevEui+0x8>)
 8038e5e:	6818      	ldr	r0, [r3, #0]
 8038e60:	4770      	bx	lr
 8038e62:	bf00      	nop
 8038e64:	20005738 	.word	0x20005738

08038e68 <SecureElementSetJoinEui>:

SecureElementStatus_t SecureElementSetJoinEui( uint8_t* joinEui )
{
 8038e68:	b508      	push	{r3, lr}
    if( joinEui == NULL )
 8038e6a:	4601      	mov	r1, r0
 8038e6c:	b138      	cbz	r0, 8038e7e <SecureElementSetJoinEui+0x16>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }
    memcpy1( SeNvm->JoinEui, joinEui, SE_EUI_SIZE );
 8038e6e:	4b05      	ldr	r3, [pc, #20]	; (8038e84 <SecureElementSetJoinEui+0x1c>)
 8038e70:	6818      	ldr	r0, [r3, #0]
 8038e72:	2208      	movs	r2, #8
 8038e74:	4410      	add	r0, r2
 8038e76:	f000 f82f 	bl	8038ed8 <memcpy1>
    return SECURE_ELEMENT_SUCCESS;
 8038e7a:	2000      	movs	r0, #0
}
 8038e7c:	bd08      	pop	{r3, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 8038e7e:	2002      	movs	r0, #2
 8038e80:	e7fc      	b.n	8038e7c <SecureElementSetJoinEui+0x14>
 8038e82:	bf00      	nop
 8038e84:	20005738 	.word	0x20005738

08038e88 <SecureElementGetJoinEui>:

uint8_t* SecureElementGetJoinEui( void )
{
    return SeNvm->JoinEui;
 8038e88:	4b01      	ldr	r3, [pc, #4]	; (8038e90 <SecureElementGetJoinEui+0x8>)
 8038e8a:	6818      	ldr	r0, [r3, #0]
}
 8038e8c:	3008      	adds	r0, #8
 8038e8e:	4770      	bx	lr
 8038e90:	20005738 	.word	0x20005738

08038e94 <srand1>:
    return ( ( next = next * 1103515245L + 12345L ) % RAND_LOCAL_MAX );
}

void srand1( uint32_t seed )
{
    next = seed;
 8038e94:	4b01      	ldr	r3, [pc, #4]	; (8038e9c <srand1+0x8>)
 8038e96:	6018      	str	r0, [r3, #0]
}
 8038e98:	4770      	bx	lr
 8038e9a:	bf00      	nop
 8038e9c:	2000359c 	.word	0x2000359c

08038ea0 <randr>:
    return ( ( next = next * 1103515245L + 12345L ) % RAND_LOCAL_MAX );
 8038ea0:	4a0b      	ldr	r2, [pc, #44]	; (8038ed0 <randr+0x30>)
// Standard random functions redefinition end

int32_t randr( int32_t min, int32_t max )
{
 8038ea2:	b530      	push	{r4, r5, lr}
    return ( ( next = next * 1103515245L + 12345L ) % RAND_LOCAL_MAX );
 8038ea4:	6813      	ldr	r3, [r2, #0]
 8038ea6:	4d0b      	ldr	r5, [pc, #44]	; (8038ed4 <randr+0x34>)
 8038ea8:	f243 0439 	movw	r4, #12345	; 0x3039
 8038eac:	fb05 4303 	mla	r3, r5, r3, r4
 8038eb0:	6013      	str	r3, [r2, #0]
    return ( int32_t )rand1( ) % ( max - min + 1 ) + min;
 8038eb2:	1a09      	subs	r1, r1, r0
    return ( ( next = next * 1103515245L + 12345L ) % RAND_LOCAL_MAX );
 8038eb4:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
 8038eb8:	fbb3 f2f2 	udiv	r2, r3, r2
 8038ebc:	ebc2 72c2 	rsb	r2, r2, r2, lsl #31
    return ( int32_t )rand1( ) % ( max - min + 1 ) + min;
 8038ec0:	3101      	adds	r1, #1
    return ( ( next = next * 1103515245L + 12345L ) % RAND_LOCAL_MAX );
 8038ec2:	1a9b      	subs	r3, r3, r2
    return ( int32_t )rand1( ) % ( max - min + 1 ) + min;
 8038ec4:	fb93 f2f1 	sdiv	r2, r3, r1
 8038ec8:	fb01 3312 	mls	r3, r1, r2, r3
}
 8038ecc:	4418      	add	r0, r3
 8038ece:	bd30      	pop	{r4, r5, pc}
 8038ed0:	2000359c 	.word	0x2000359c
 8038ed4:	41c64e6d 	.word	0x41c64e6d

08038ed8 <memcpy1>:

void memcpy1( uint8_t *dst, const uint8_t *src, uint16_t size )
{
    while( size-- )
 8038ed8:	3801      	subs	r0, #1
 8038eda:	440a      	add	r2, r1
 8038edc:	4291      	cmp	r1, r2
 8038ede:	d100      	bne.n	8038ee2 <memcpy1+0xa>
    {
        *dst++ = *src++;
    }
}
 8038ee0:	4770      	bx	lr
        *dst++ = *src++;
 8038ee2:	f811 3b01 	ldrb.w	r3, [r1], #1
 8038ee6:	f800 3f01 	strb.w	r3, [r0, #1]!
 8038eea:	e7f7      	b.n	8038edc <memcpy1+0x4>

08038eec <memcpyr>:

void memcpyr( uint8_t *dst, const uint8_t *src, uint16_t size )
{
    dst = dst + ( size - 1 );
    while( size-- )
 8038eec:	4410      	add	r0, r2
 8038eee:	440a      	add	r2, r1
 8038ef0:	4291      	cmp	r1, r2
 8038ef2:	d100      	bne.n	8038ef6 <memcpyr+0xa>
    {
        *dst-- = *src++;
    }
}
 8038ef4:	4770      	bx	lr
        *dst-- = *src++;
 8038ef6:	f811 3b01 	ldrb.w	r3, [r1], #1
 8038efa:	f800 3d01 	strb.w	r3, [r0, #-1]!
 8038efe:	e7f7      	b.n	8038ef0 <memcpyr+0x4>

08038f00 <memset1>:

void memset1( uint8_t *dst, uint8_t value, uint16_t size )
{
    while( size-- )
 8038f00:	4402      	add	r2, r0
 8038f02:	4290      	cmp	r0, r2
 8038f04:	d100      	bne.n	8038f08 <memset1+0x8>
    {
        *dst++ = value;
    }
}
 8038f06:	4770      	bx	lr
        *dst++ = value;
 8038f08:	f800 1b01 	strb.w	r1, [r0], #1
 8038f0c:	e7f9      	b.n	8038f02 <memset1+0x2>
	...

08038f10 <Crc32>:
        return '?';
    }
}

uint32_t Crc32( uint8_t *buffer, uint16_t length )
{
 8038f10:	b530      	push	{r4, r5, lr}
    const uint32_t reversedPolynom = 0xEDB88320;

    // CRC initial value
    uint32_t crc = 0xFFFFFFFF;

    if( buffer == NULL )
 8038f12:	b130      	cbz	r0, 8038f22 <Crc32+0x12>
    for( uint16_t i = 0; i < length; ++i )
    {
        crc ^= ( uint32_t )buffer[i];
        for( uint16_t i = 0; i < 8; i++ )
        {
            crc = ( crc >> 1 ) ^ ( reversedPolynom & ~( ( crc & 0x01 ) - 1 ) );
 8038f14:	4d0a      	ldr	r5, [pc, #40]	; (8038f40 <Crc32+0x30>)
 8038f16:	4401      	add	r1, r0
    uint32_t crc = 0xFFFFFFFF;
 8038f18:	f04f 33ff 	mov.w	r3, #4294967295
    for( uint16_t i = 0; i < length; ++i )
 8038f1c:	4281      	cmp	r1, r0
 8038f1e:	d101      	bne.n	8038f24 <Crc32+0x14>
        }
    }

    return ~crc;
 8038f20:	43d8      	mvns	r0, r3
}
 8038f22:	bd30      	pop	{r4, r5, pc}
        crc ^= ( uint32_t )buffer[i];
 8038f24:	f810 2b01 	ldrb.w	r2, [r0], #1
 8038f28:	4053      	eors	r3, r2
 8038f2a:	2208      	movs	r2, #8
            crc = ( crc >> 1 ) ^ ( reversedPolynom & ~( ( crc & 0x01 ) - 1 ) );
 8038f2c:	f343 0400 	sbfx	r4, r3, #0, #1
 8038f30:	3a01      	subs	r2, #1
 8038f32:	402c      	ands	r4, r5
 8038f34:	b292      	uxth	r2, r2
 8038f36:	ea84 0353 	eor.w	r3, r4, r3, lsr #1
        for( uint16_t i = 0; i < 8; i++ )
 8038f3a:	2a00      	cmp	r2, #0
 8038f3c:	d1f6      	bne.n	8038f2c <Crc32+0x1c>
 8038f3e:	e7ed      	b.n	8038f1c <Crc32+0xc>
 8038f40:	edb88320 	.word	0xedb88320

08038f44 <RadioCheckRfFrequency>:
}

static bool RadioCheckRfFrequency( uint32_t frequency )
{
    return true;
}
 8038f44:	2001      	movs	r0, #1
 8038f46:	4770      	bx	lr

08038f48 <RadioOnTxTimeoutIrq>:
{
    /* ST_WORKAROUND_BEGIN: Reset DBG pin */
    DBG_GPIO_RADIO_TX(RST);
    /* ST_WORKAROUND_END */

    if( ( RadioEvents != NULL ) && ( RadioEvents->TxTimeout != NULL ) )
 8038f48:	4b03      	ldr	r3, [pc, #12]	; (8038f58 <RadioOnTxTimeoutIrq+0x10>)
 8038f4a:	681b      	ldr	r3, [r3, #0]
 8038f4c:	b113      	cbz	r3, 8038f54 <RadioOnTxTimeoutIrq+0xc>
 8038f4e:	685b      	ldr	r3, [r3, #4]
 8038f50:	b103      	cbz	r3, 8038f54 <RadioOnTxTimeoutIrq+0xc>
    {
        RadioEvents->TxTimeout( );
 8038f52:	4718      	bx	r3
}
 8038f54:	4770      	bx	lr
 8038f56:	bf00      	nop
 8038f58:	2000597c 	.word	0x2000597c

08038f5c <RadioOnRxTimeoutIrq>:
{
    /* ST_WORKAROUND_BEGIN: Reset DBG pin */
    DBG_GPIO_RADIO_RX(RST);
    /* ST_WORKAROUND_END */

    if( ( RadioEvents != NULL ) && ( RadioEvents->RxTimeout != NULL ) )
 8038f5c:	4b03      	ldr	r3, [pc, #12]	; (8038f6c <RadioOnRxTimeoutIrq+0x10>)
 8038f5e:	681b      	ldr	r3, [r3, #0]
 8038f60:	b113      	cbz	r3, 8038f68 <RadioOnRxTimeoutIrq+0xc>
 8038f62:	68db      	ldr	r3, [r3, #12]
 8038f64:	b103      	cbz	r3, 8038f68 <RadioOnRxTimeoutIrq+0xc>
    {
        RadioEvents->RxTimeout( );
 8038f66:	4718      	bx	r3
}
 8038f68:	4770      	bx	lr
 8038f6a:	bf00      	nop
 8038f6c:	2000597c 	.word	0x2000597c

08038f70 <RadioRead>:
    return SUBGRF_ReadRegister(addr);
 8038f70:	f001 baf4 	b.w	803a55c <SUBGRF_ReadRegister>

08038f74 <RadioWrite>:
    SUBGRF_WriteRegister(addr, data );
 8038f74:	f001 ba2c 	b.w	803a3d0 <SUBGRF_WriteRegister>

08038f78 <RadioTxCw>:
    SUBGRF_SetTxInfinitePreamble( );
    SUBGRF_SetTx( 0x0fffff );
}

static void RadioTxCw( int8_t power )
{
 8038f78:	b508      	push	{r3, lr}
    uint8_t paselect = SUBGRF_SetRfTxPower( power );
 8038f7a:	f001 fd1c 	bl	803a9b6 <SUBGRF_SetRfTxPower>
    SUBGRF_SetSwitch( paselect, RFSWITCH_TX );
 8038f7e:	2101      	movs	r1, #1
 8038f80:	f001 fd03 	bl	803a98a <SUBGRF_SetSwitch>
    SUBGRF_SetTxContinuousWave( );
}
 8038f84:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    SUBGRF_SetTxContinuousWave( );
 8038f88:	f001 b90c 	b.w	803a1a4 <SUBGRF_SetTxContinuousWave>

08038f8c <RadioSetRxDutyCycle>:
{
 8038f8c:	b538      	push	{r3, r4, r5, lr}
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_RX);
 8038f8e:	4b07      	ldr	r3, [pc, #28]	; (8038fac <RadioSetRxDutyCycle+0x20>)
{
 8038f90:	4604      	mov	r4, r0
 8038f92:	460d      	mov	r5, r1
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_RX);
 8038f94:	f893 0056 	ldrb.w	r0, [r3, #86]	; 0x56
 8038f98:	2100      	movs	r1, #0
 8038f9a:	f001 fcf6 	bl	803a98a <SUBGRF_SetSwitch>
    SUBGRF_SetRxDutyCycle( rxTime, sleepTime );
 8038f9e:	4629      	mov	r1, r5
 8038fa0:	4620      	mov	r0, r4
}
 8038fa2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    SUBGRF_SetRxDutyCycle( rxTime, sleepTime );
 8038fa6:	f001 b8d5 	b.w	803a154 <SUBGRF_SetRxDutyCycle>
 8038faa:	bf00      	nop
 8038fac:	20006324 	.word	0x20006324

08038fb0 <RadioStandby>:
    SUBGRF_SetStandby( STDBY_RC );
 8038fb0:	2000      	movs	r0, #0
 8038fb2:	f001 b88d 	b.w	803a0d0 <SUBGRF_SetStandby>
	...

08038fb8 <RadioGetStatus>:
{
 8038fb8:	b508      	push	{r3, lr}
    switch( SUBGRF_GetOperatingMode( ) )
 8038fba:	f001 f883 	bl	803a0c4 <SUBGRF_GetOperatingMode>
 8038fbe:	3804      	subs	r0, #4
 8038fc0:	b2c0      	uxtb	r0, r0
 8038fc2:	2803      	cmp	r0, #3
 8038fc4:	bf96      	itet	ls
 8038fc6:	4b02      	ldrls	r3, [pc, #8]	; (8038fd0 <RadioGetStatus+0x18>)
 8038fc8:	2000      	movhi	r0, #0
 8038fca:	5c18      	ldrbls	r0, [r3, r0]
}
 8038fcc:	bd08      	pop	{r3, pc}
 8038fce:	bf00      	nop
 8038fd0:	0803bb94 	.word	0x0803bb94

08038fd4 <RadioIrqProcess>:
{
 8038fd4:	b573      	push	{r0, r1, r4, r5, r6, lr}
    switch ( SubgRf.RadioIrq )
 8038fd6:	4e84      	ldr	r6, [pc, #528]	; (80391e8 <RadioIrqProcess+0x214>)
 8038fd8:	f8b6 3054 	ldrh.w	r3, [r6, #84]	; 0x54
    uint8_t size = 0;
 8038fdc:	2400      	movs	r4, #0
    switch ( SubgRf.RadioIrq )
 8038fde:	2b20      	cmp	r3, #32
    uint8_t size = 0;
 8038fe0:	f88d 4003 	strb.w	r4, [sp, #3]
    int32_t cfo = 0;
 8038fe4:	9401      	str	r4, [sp, #4]
    switch ( SubgRf.RadioIrq )
 8038fe6:	4635      	mov	r5, r6
 8038fe8:	f000 80d9 	beq.w	803919e <RadioIrqProcess+0x1ca>
 8038fec:	d810      	bhi.n	8039010 <RadioIrqProcess+0x3c>
 8038fee:	2b08      	cmp	r3, #8
 8038ff0:	d809      	bhi.n	8039006 <RadioIrqProcess+0x32>
 8038ff2:	b15b      	cbz	r3, 803900c <RadioIrqProcess+0x38>
 8038ff4:	3b01      	subs	r3, #1
 8038ff6:	2b07      	cmp	r3, #7
 8038ff8:	d808      	bhi.n	803900c <RadioIrqProcess+0x38>
 8038ffa:	e8df f003 	tbb	[pc, r3]
 8038ffe:	4e39      	.short	0x4e39
 8039000:	0707b907 	.word	0x0707b907
 8039004:	c007      	.short	0xc007
 8039006:	2b10      	cmp	r3, #16
 8039008:	f000 80c7 	beq.w	803919a <RadioIrqProcess+0x1c6>
}
 803900c:	b002      	add	sp, #8
 803900e:	bd70      	pop	{r4, r5, r6, pc}
    switch ( SubgRf.RadioIrq )
 8039010:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8039014:	f000 808c 	beq.w	8039130 <RadioIrqProcess+0x15c>
 8039018:	d811      	bhi.n	803903e <RadioIrqProcess+0x6a>
 803901a:	2b40      	cmp	r3, #64	; 0x40
 803901c:	f000 80d2 	beq.w	80391c4 <RadioIrqProcess+0x1f0>
 8039020:	2b80      	cmp	r3, #128	; 0x80
 8039022:	d1f3      	bne.n	803900c <RadioIrqProcess+0x38>
        SUBGRF_SetStandby( STDBY_RC );
 8039024:	4620      	mov	r0, r4
 8039026:	f001 f853 	bl	803a0d0 <SUBGRF_SetStandby>
        if( ( RadioEvents != NULL ) && ( RadioEvents->CadDone != NULL ) )
 803902a:	4b70      	ldr	r3, [pc, #448]	; (80391ec <RadioIrqProcess+0x218>)
 803902c:	681b      	ldr	r3, [r3, #0]
 803902e:	2b00      	cmp	r3, #0
 8039030:	d0ec      	beq.n	803900c <RadioIrqProcess+0x38>
 8039032:	699b      	ldr	r3, [r3, #24]
 8039034:	2b00      	cmp	r3, #0
 8039036:	d0e9      	beq.n	803900c <RadioIrqProcess+0x38>
            RadioEvents->CadDone( false );
 8039038:	4620      	mov	r0, r4
            RadioEvents->CadDone( true );
 803903a:	4798      	blx	r3
 803903c:	e7e6      	b.n	803900c <RadioIrqProcess+0x38>
    switch ( SubgRf.RadioIrq )
 803903e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8039042:	d1e3      	bne.n	803900c <RadioIrqProcess+0x38>
        MW_LOG( TS_ON, VLEVEL_M,  "IRQ_RX_TX_TIMEOUT\r\n" );
 8039044:	4b6a      	ldr	r3, [pc, #424]	; (80391f0 <RadioIrqProcess+0x21c>)
 8039046:	2201      	movs	r2, #1
 8039048:	4621      	mov	r1, r4
 803904a:	2002      	movs	r0, #2
 803904c:	f001 fe2a 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
        if( SUBGRF_GetOperatingMode( ) == MODE_TX )
 8039050:	f001 f838 	bl	803a0c4 <SUBGRF_GetOperatingMode>
 8039054:	2804      	cmp	r0, #4
 8039056:	d179      	bne.n	803914c <RadioIrqProcess+0x178>
            TimerStop( &TxTimeoutTimer );
 8039058:	4866      	ldr	r0, [pc, #408]	; (80391f4 <RadioIrqProcess+0x220>)
 803905a:	f002 f945 	bl	803b2e8 <UTIL_TIMER_Stop>
            SUBGRF_SetStandby( STDBY_RC );
 803905e:	4620      	mov	r0, r4
 8039060:	f001 f836 	bl	803a0d0 <SUBGRF_SetStandby>
            if( ( RadioEvents != NULL ) && ( RadioEvents->TxTimeout != NULL ) )
 8039064:	4b61      	ldr	r3, [pc, #388]	; (80391ec <RadioIrqProcess+0x218>)
 8039066:	681b      	ldr	r3, [r3, #0]
 8039068:	2b00      	cmp	r3, #0
 803906a:	d0cf      	beq.n	803900c <RadioIrqProcess+0x38>
 803906c:	685b      	ldr	r3, [r3, #4]
 803906e:	e010      	b.n	8039092 <RadioIrqProcess+0xbe>
        TimerStop( &TxTimeoutTimer );
 8039070:	4860      	ldr	r0, [pc, #384]	; (80391f4 <RadioIrqProcess+0x220>)
 8039072:	f002 f939 	bl	803b2e8 <UTIL_TIMER_Stop>
        SUBGRF_SetStandby( STDBY_RC );
 8039076:	2000      	movs	r0, #0
 8039078:	f001 f82a 	bl	803a0d0 <SUBGRF_SetStandby>
        if ( RFW_Is_LongPacketModeEnabled() == 1 )
 803907c:	f001 fd56 	bl	803ab2c <RFW_Is_LongPacketModeEnabled>
 8039080:	2801      	cmp	r0, #1
 8039082:	d101      	bne.n	8039088 <RadioIrqProcess+0xb4>
            RFW_DeInit_TxLongPacket( );
 8039084:	f001 fd5b 	bl	803ab3e <RFW_DeInit_TxLongPacket>
        if( ( RadioEvents != NULL ) && ( RadioEvents->TxDone != NULL ) )
 8039088:	4b58      	ldr	r3, [pc, #352]	; (80391ec <RadioIrqProcess+0x218>)
 803908a:	681b      	ldr	r3, [r3, #0]
 803908c:	2b00      	cmp	r3, #0
 803908e:	d0bd      	beq.n	803900c <RadioIrqProcess+0x38>
 8039090:	681b      	ldr	r3, [r3, #0]
        if( ( RadioEvents != NULL ) && ( RadioEvents->RxError ) )
 8039092:	2b00      	cmp	r3, #0
 8039094:	d0ba      	beq.n	803900c <RadioIrqProcess+0x38>
            RadioEvents->RxError( );
 8039096:	4798      	blx	r3
}
 8039098:	e7b8      	b.n	803900c <RadioIrqProcess+0x38>
        TimerStop( &RxTimeoutTimer );
 803909a:	4857      	ldr	r0, [pc, #348]	; (80391f8 <RadioIrqProcess+0x224>)
 803909c:	f002 f924 	bl	803b2e8 <UTIL_TIMER_Stop>
        if( SubgRf.RxContinuous == false )
 80390a0:	7874      	ldrb	r4, [r6, #1]
 80390a2:	b994      	cbnz	r4, 80390ca <RadioIrqProcess+0xf6>
            SUBGRF_SetStandby( STDBY_RC );
 80390a4:	4620      	mov	r0, r4
 80390a6:	f001 f813 	bl	803a0d0 <SUBGRF_SetStandby>
            SUBGRF_WriteRegister( 0x0902, 0x00 );
 80390aa:	4621      	mov	r1, r4
 80390ac:	f640 1002 	movw	r0, #2306	; 0x902
 80390b0:	f001 f98e 	bl	803a3d0 <SUBGRF_WriteRegister>
            SUBGRF_WriteRegister( 0x0944, SUBGRF_ReadRegister( 0x0944 ) | ( 1 << 1 ) );
 80390b4:	f640 1044 	movw	r0, #2372	; 0x944
 80390b8:	f001 fa50 	bl	803a55c <SUBGRF_ReadRegister>
 80390bc:	f040 0102 	orr.w	r1, r0, #2
 80390c0:	b2c9      	uxtb	r1, r1
 80390c2:	f640 1044 	movw	r0, #2372	; 0x944
 80390c6:	f001 f983 	bl	803a3d0 <SUBGRF_WriteRegister>
        SUBGRF_GetPayload( RadioBuffer, &size , 255 );
 80390ca:	4c48      	ldr	r4, [pc, #288]	; (80391ec <RadioIrqProcess+0x218>)
 80390cc:	22ff      	movs	r2, #255	; 0xff
 80390ce:	f10d 0103 	add.w	r1, sp, #3
 80390d2:	1d20      	adds	r0, r4, #4
 80390d4:	f001 fc40 	bl	803a958 <SUBGRF_GetPayload>
        SUBGRF_GetPacketStatus( &(SubgRf.PacketStatus) );
 80390d8:	4848      	ldr	r0, [pc, #288]	; (80391fc <RadioIrqProcess+0x228>)
 80390da:	f001 f93f 	bl	803a35c <SUBGRF_GetPacketStatus>
        if( ( RadioEvents != NULL ) && ( RadioEvents->RxDone != NULL ) )
 80390de:	6823      	ldr	r3, [r4, #0]
 80390e0:	2b00      	cmp	r3, #0
 80390e2:	d093      	beq.n	803900c <RadioIrqProcess+0x38>
 80390e4:	689e      	ldr	r6, [r3, #8]
 80390e6:	2e00      	cmp	r6, #0
 80390e8:	d090      	beq.n	803900c <RadioIrqProcess+0x38>
            switch ( SubgRf.PacketStatus.packetType )
 80390ea:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
 80390ee:	2b01      	cmp	r3, #1
 80390f0:	d108      	bne.n	8039104 <RadioIrqProcess+0x130>
                RadioEvents->RxDone( RadioBuffer, size, SubgRf.PacketStatus.Params.LoRa.RssiPkt, SubgRf.PacketStatus.Params.LoRa.SnrPkt );
 80390f2:	f995 3031 	ldrsb.w	r3, [r5, #49]	; 0x31
 80390f6:	f995 2030 	ldrsb.w	r2, [r5, #48]	; 0x30
 80390fa:	f89d 1003 	ldrb.w	r1, [sp, #3]
 80390fe:	1d20      	adds	r0, r4, #4
 8039100:	47b0      	blx	r6
                break;
 8039102:	e783      	b.n	803900c <RadioIrqProcess+0x38>
                SUBGRF_GetCFO( SubgRf.ModulationParams.Params.Gfsk.BitRate, &cfo );
 8039104:	6be8      	ldr	r0, [r5, #60]	; 0x3c
 8039106:	a901      	add	r1, sp, #4
 8039108:	f001 fcc4 	bl	803aa94 <SUBGRF_GetCFO>
                RadioEvents->RxDone( RadioBuffer, size, SubgRf.PacketStatus.Params.Gfsk.RssiAvg, (int8_t) DIVR(cfo, 1000) );
 803910c:	4620      	mov	r0, r4
 803910e:	9b01      	ldr	r3, [sp, #4]
 8039110:	f89d 1003 	ldrb.w	r1, [sp, #3]
 8039114:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8039118:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
 803911c:	fb93 f3f2 	sdiv	r3, r3, r2
 8039120:	f850 2b04 	ldr.w	r2, [r0], #4
 8039124:	b25b      	sxtb	r3, r3
 8039126:	6894      	ldr	r4, [r2, #8]
 8039128:	f995 2029 	ldrsb.w	r2, [r5, #41]	; 0x29
 803912c:	47a0      	blx	r4
                break;
 803912e:	e76d      	b.n	803900c <RadioIrqProcess+0x38>
        SUBGRF_SetStandby( STDBY_RC );
 8039130:	4620      	mov	r0, r4
 8039132:	f000 ffcd 	bl	803a0d0 <SUBGRF_SetStandby>
        if( ( RadioEvents != NULL ) && ( RadioEvents->CadDone != NULL ) )
 8039136:	4b2d      	ldr	r3, [pc, #180]	; (80391ec <RadioIrqProcess+0x218>)
 8039138:	681b      	ldr	r3, [r3, #0]
 803913a:	2b00      	cmp	r3, #0
 803913c:	f43f af66 	beq.w	803900c <RadioIrqProcess+0x38>
 8039140:	699b      	ldr	r3, [r3, #24]
 8039142:	2b00      	cmp	r3, #0
 8039144:	f43f af62 	beq.w	803900c <RadioIrqProcess+0x38>
            RadioEvents->CadDone( true );
 8039148:	2001      	movs	r0, #1
 803914a:	e776      	b.n	803903a <RadioIrqProcess+0x66>
        else if( SUBGRF_GetOperatingMode( ) == MODE_RX )
 803914c:	f000 ffba 	bl	803a0c4 <SUBGRF_GetOperatingMode>
 8039150:	2805      	cmp	r0, #5
 8039152:	f47f af5b 	bne.w	803900c <RadioIrqProcess+0x38>
            TimerStop( &RxTimeoutTimer );
 8039156:	4828      	ldr	r0, [pc, #160]	; (80391f8 <RadioIrqProcess+0x224>)
 8039158:	f002 f8c6 	bl	803b2e8 <UTIL_TIMER_Stop>
            SUBGRF_SetStandby( STDBY_RC );
 803915c:	4620      	mov	r0, r4
 803915e:	f000 ffb7 	bl	803a0d0 <SUBGRF_SetStandby>
            if( ( RadioEvents != NULL ) && ( RadioEvents->RxTimeout != NULL ) )
 8039162:	4b22      	ldr	r3, [pc, #136]	; (80391ec <RadioIrqProcess+0x218>)
 8039164:	681b      	ldr	r3, [r3, #0]
 8039166:	2b00      	cmp	r3, #0
 8039168:	f43f af50 	beq.w	803900c <RadioIrqProcess+0x38>
 803916c:	68db      	ldr	r3, [r3, #12]
 803916e:	e790      	b.n	8039092 <RadioIrqProcess+0xbe>
        MW_LOG( TS_ON, VLEVEL_M,  "PRE OK\r\n" );
 8039170:	4b23      	ldr	r3, [pc, #140]	; (8039200 <RadioIrqProcess+0x22c>)
            MW_LOG( TS_ON, VLEVEL_M,  "HDR KO\r\n" );
 8039172:	2201      	movs	r2, #1
 8039174:	2100      	movs	r1, #0
 8039176:	2002      	movs	r0, #2
 8039178:	f001 fd94 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
 803917c:	e746      	b.n	803900c <RadioIrqProcess+0x38>
        MW_LOG( TS_ON, VLEVEL_M,  "SYNC OK\r\n" );
 803917e:	4b21      	ldr	r3, [pc, #132]	; (8039204 <RadioIrqProcess+0x230>)
 8039180:	2201      	movs	r2, #1
 8039182:	2100      	movs	r1, #0
 8039184:	2002      	movs	r0, #2
 8039186:	f001 fd8d 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
        if ( 1UL == RFW_Is_Init( ) )
 803918a:	f001 fccd 	bl	803ab28 <RFW_Is_Init>
 803918e:	2801      	cmp	r0, #1
 8039190:	f47f af3c 	bne.w	803900c <RadioIrqProcess+0x38>
            RFW_ReceivePayload( );
 8039194:	f001 fcd4 	bl	803ab40 <RFW_ReceivePayload>
 8039198:	e738      	b.n	803900c <RadioIrqProcess+0x38>
        MW_LOG( TS_ON, VLEVEL_M,  "HDR OK\r\n" );
 803919a:	4b1b      	ldr	r3, [pc, #108]	; (8039208 <RadioIrqProcess+0x234>)
 803919c:	e7e9      	b.n	8039172 <RadioIrqProcess+0x19e>
        TimerStop( &RxTimeoutTimer );
 803919e:	4816      	ldr	r0, [pc, #88]	; (80391f8 <RadioIrqProcess+0x224>)
 80391a0:	f002 f8a2 	bl	803b2e8 <UTIL_TIMER_Stop>
        if( SubgRf.RxContinuous == false )
 80391a4:	7870      	ldrb	r0, [r6, #1]
 80391a6:	b908      	cbnz	r0, 80391ac <RadioIrqProcess+0x1d8>
            SUBGRF_SetStandby( STDBY_RC );
 80391a8:	f000 ff92 	bl	803a0d0 <SUBGRF_SetStandby>
        if( ( RadioEvents != NULL ) && ( RadioEvents->RxTimeout != NULL ) )
 80391ac:	4b0f      	ldr	r3, [pc, #60]	; (80391ec <RadioIrqProcess+0x218>)
 80391ae:	681b      	ldr	r3, [r3, #0]
 80391b0:	2b00      	cmp	r3, #0
 80391b2:	f43f af2b 	beq.w	803900c <RadioIrqProcess+0x38>
 80391b6:	68db      	ldr	r3, [r3, #12]
 80391b8:	2b00      	cmp	r3, #0
 80391ba:	f43f af27 	beq.w	803900c <RadioIrqProcess+0x38>
            RadioEvents->RxTimeout( );
 80391be:	4798      	blx	r3
            MW_LOG( TS_ON, VLEVEL_M,  "HDR KO\r\n" );
 80391c0:	4b12      	ldr	r3, [pc, #72]	; (803920c <RadioIrqProcess+0x238>)
 80391c2:	e7d6      	b.n	8039172 <RadioIrqProcess+0x19e>
        MW_LOG( TS_ON, VLEVEL_M,  "IRQ_CRC_ERROR\r\n" );
 80391c4:	4b12      	ldr	r3, [pc, #72]	; (8039210 <RadioIrqProcess+0x23c>)
 80391c6:	2201      	movs	r2, #1
 80391c8:	4621      	mov	r1, r4
 80391ca:	2002      	movs	r0, #2
 80391cc:	f001 fd6a 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
        if( SubgRf.RxContinuous == false )
 80391d0:	7870      	ldrb	r0, [r6, #1]
 80391d2:	b908      	cbnz	r0, 80391d8 <RadioIrqProcess+0x204>
            SUBGRF_SetStandby( STDBY_RC );
 80391d4:	f000 ff7c 	bl	803a0d0 <SUBGRF_SetStandby>
        if( ( RadioEvents != NULL ) && ( RadioEvents->RxError ) )
 80391d8:	4b04      	ldr	r3, [pc, #16]	; (80391ec <RadioIrqProcess+0x218>)
 80391da:	681b      	ldr	r3, [r3, #0]
 80391dc:	2b00      	cmp	r3, #0
 80391de:	f43f af15 	beq.w	803900c <RadioIrqProcess+0x38>
 80391e2:	691b      	ldr	r3, [r3, #16]
 80391e4:	e755      	b.n	8039092 <RadioIrqProcess+0xbe>
 80391e6:	bf00      	nop
 80391e8:	20006324 	.word	0x20006324
 80391ec:	2000597c 	.word	0x2000597c
 80391f0:	0803c497 	.word	0x0803c497
 80391f4:	2000637c 	.word	0x2000637c
 80391f8:	20006394 	.word	0x20006394
 80391fc:	20006348 	.word	0x20006348
 8039200:	0803c4ab 	.word	0x0803c4ab
 8039204:	0803c4b4 	.word	0x0803c4b4
 8039208:	0803c4be 	.word	0x0803c4be
 803920c:	0803c4c7 	.word	0x0803c4c7
 8039210:	0803c4d0 	.word	0x0803c4d0

08039214 <RadioOnDioIrq>:
    SubgRf.RadioIrq = radioIrq;
 8039214:	4b02      	ldr	r3, [pc, #8]	; (8039220 <RadioOnDioIrq+0xc>)
 8039216:	f8a3 0054 	strh.w	r0, [r3, #84]	; 0x54
    RADIO_IRQ_PROCESS();
 803921a:	f7ff bedb 	b.w	8038fd4 <RadioIrqProcess>
 803921e:	bf00      	nop
 8039220:	20006324 	.word	0x20006324

08039224 <RadioGetWakeupTime>:
{
 8039224:	b508      	push	{r3, lr}
    return SUBGRF_GetRadioWakeUpTime() + RADIO_WAKEUP_TIME;
 8039226:	f001 fbdb 	bl	803a9e0 <SUBGRF_GetRadioWakeUpTime>
}
 803922a:	3003      	adds	r0, #3
 803922c:	bd08      	pop	{r3, pc}

0803922e <RadioReadRegisters>:
    SUBGRF_ReadRegisters( addr, buffer, size );
 803922e:	f001 bb21 	b.w	803a874 <SUBGRF_ReadRegisters>

08039232 <RadioWriteRegisters>:
    SUBGRF_WriteRegisters( addr, buffer, size );
 8039232:	f001 ba7f 	b.w	803a734 <SUBGRF_WriteRegisters>

08039236 <RadioRssi>:
{
 8039236:	b508      	push	{r3, lr}
    return SUBGRF_GetRssiInst( );
 8039238:	f001 f883 	bl	803a342 <SUBGRF_GetRssiInst>
}
 803923c:	b200      	sxth	r0, r0
 803923e:	bd08      	pop	{r3, pc}

08039240 <RadioSetTxContinuousWave>:
{
 8039240:	b538      	push	{r3, r4, r5, lr}
 8039242:	460d      	mov	r5, r1
 8039244:	4614      	mov	r4, r2
    SUBGRF_SetRfFrequency( freq );
 8039246:	f001 f851 	bl	803a2ec <SUBGRF_SetRfFrequency>
    antswitchpow = SUBGRF_SetRfTxPower( power );
 803924a:	4628      	mov	r0, r5
 803924c:	f001 fbb3 	bl	803a9b6 <SUBGRF_SetRfTxPower>
    TimerSetValue( &TxTimeoutTimer, timeout );
 8039250:	4d08      	ldr	r5, [pc, #32]	; (8039274 <RadioSetTxContinuousWave+0x34>)
    SUBGRF_SetSwitch(antswitchpow, RFSWITCH_TX);
 8039252:	2101      	movs	r1, #1
 8039254:	f001 fb99 	bl	803a98a <SUBGRF_SetSwitch>
    SUBGRF_SetTxContinuousWave( );
 8039258:	f000 ffa4 	bl	803a1a4 <SUBGRF_SetTxContinuousWave>
    TimerSetValue( &TxTimeoutTimer, timeout );
 803925c:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8039260:	4361      	muls	r1, r4
 8039262:	4628      	mov	r0, r5
 8039264:	f002 f8ca 	bl	803b3fc <UTIL_TIMER_SetPeriod>
    TimerStart( &TxTimeoutTimer );
 8039268:	4628      	mov	r0, r5
}
 803926a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    TimerStart( &TxTimeoutTimer );
 803926e:	f002 b88b 	b.w	803b388 <UTIL_TIMER_Start>
 8039272:	bf00      	nop
 8039274:	2000637c 	.word	0x2000637c

08039278 <RadioSetChannel>:
    SUBGRF_SetRfFrequency( freq );
 8039278:	f001 b838 	b.w	803a2ec <SUBGRF_SetRfFrequency>

0803927c <RadioStartCad>:
{
 803927c:	b508      	push	{r3, lr}
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_RX);
 803927e:	4b08      	ldr	r3, [pc, #32]	; (80392a0 <RadioStartCad+0x24>)
 8039280:	2100      	movs	r1, #0
 8039282:	f893 0056 	ldrb.w	r0, [r3, #86]	; 0x56
 8039286:	f001 fb80 	bl	803a98a <SUBGRF_SetSwitch>
    SUBGRF_SetDioIrqParams( IRQ_CAD_CLEAR | IRQ_CAD_DETECTED,
 803928a:	2300      	movs	r3, #0
 803928c:	f44f 71c0 	mov.w	r1, #384	; 0x180
 8039290:	461a      	mov	r2, r3
 8039292:	4608      	mov	r0, r1
 8039294:	f001 f800 	bl	803a298 <SUBGRF_SetDioIrqParams>
}
 8039298:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    SUBGRF_SetCad( );
 803929c:	f000 bf76 	b.w	803a18c <SUBGRF_SetCad>
 80392a0:	20006324 	.word	0x20006324

080392a4 <RadioSleep>:
{
 80392a4:	b508      	push	{r3, lr}
    SUBGRF_SetSleep( params );
 80392a6:	f04f 0004 	mov.w	r0, #4
 80392aa:	f001 f9ab 	bl	803a604 <SUBGRF_SetSleep>
}
 80392ae:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RADIO_DELAY_MS( 2 );
 80392b2:	2002      	movs	r0, #2
 80392b4:	f7f3 b9c8 	b.w	802c648 <HAL_Delay>

080392b8 <RadioTimeOnAir>:
{
 80392b8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80392ba:	f8bd 5014 	ldrh.w	r5, [sp, #20]
 80392be:	f89d e018 	ldrb.w	lr, [sp, #24]
 80392c2:	f89d c01c 	ldrb.w	ip, [sp, #28]
 80392c6:	f89d 4020 	ldrb.w	r4, [sp, #32]
    switch( modem )
 80392ca:	b140      	cbz	r0, 80392de <RadioTimeOnAir+0x26>
 80392cc:	2801      	cmp	r0, #1
 80392ce:	d019      	beq.n	8039304 <RadioTimeOnAir+0x4c>
 80392d0:	2201      	movs	r2, #1
 80392d2:	2300      	movs	r3, #0
    return DIVC(numerator, denominator); /* ST_WORKAROUND : simplified calculation with macro usage */
 80392d4:	4413      	add	r3, r2
 80392d6:	1e58      	subs	r0, r3, #1
 80392d8:	fbb0 f0f2 	udiv	r0, r0, r2
}
 80392dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
           ( ( fixLen == false ) ? 8 : 0 ) + 24 +
 80392de:	f1be 0f00 	cmp.w	lr, #0
 80392e2:	bf0c      	ite	eq
 80392e4:	2308      	moveq	r3, #8
 80392e6:	2300      	movne	r3, #0
           ( ( payloadLen + ( ( crcOn == true ) ? 2 : 0 ) ) << 3 );
 80392e8:	2c00      	cmp	r4, #0
    return ( preambleLen << 3 ) +
 80392ea:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
           ( ( payloadLen + ( ( crcOn == true ) ? 2 : 0 ) ) << 3 );
 80392ee:	bf14      	ite	ne
 80392f0:	2402      	movne	r4, #2
 80392f2:	2400      	moveq	r4, #0
           ( ( fixLen == false ) ? 8 : 0 ) + 24 +
 80392f4:	3318      	adds	r3, #24
           ( ( payloadLen + ( ( crcOn == true ) ? 2 : 0 ) ) << 3 );
 80392f6:	4464      	add	r4, ip
           ( ( fixLen == false ) ? 8 : 0 ) + 24 +
 80392f8:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
            numerator   = 1000U * RadioGetGfskTimeOnAirNumerator( datarate, coderate,
 80392fc:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8039300:	4363      	muls	r3, r4
        break;
 8039302:	e7e7      	b.n	80392d4 <RadioTimeOnAir+0x1c>
    int32_t crDenom           = coderate + 4;
 8039304:	1d1e      	adds	r6, r3, #4
    if( ( datarate == 5 ) || ( datarate == 6 ) )
 8039306:	1f53      	subs	r3, r2, #5
 8039308:	2b01      	cmp	r3, #1
 803930a:	d802      	bhi.n	8039312 <RadioTimeOnAir+0x5a>
        if( preambleLen < 12 )
 803930c:	2d0c      	cmp	r5, #12
 803930e:	bf38      	it	cc
 8039310:	250c      	movcc	r5, #12
    if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 8039312:	2900      	cmp	r1, #0
 8039314:	d138      	bne.n	8039388 <RadioTimeOnAir+0xd0>
 8039316:	f1a2 070b 	sub.w	r7, r2, #11
 803931a:	2f01      	cmp	r7, #1
 803931c:	bf8c      	ite	hi
 803931e:	2700      	movhi	r7, #0
 8039320:	2701      	movls	r7, #1
                            ( crcOn ? 16 : 0 ) -
 8039322:	2c00      	cmp	r4, #0
 8039324:	bf14      	ite	ne
 8039326:	2410      	movne	r4, #16
 8039328:	2400      	moveq	r4, #0
    int32_t ceilNumerator = ( payloadLen << 3 ) +
 803932a:	eb04 04cc 	add.w	r4, r4, ip, lsl #3
                            ( fixLen ? 0 : 20 );
 803932e:	f1be 0f00 	cmp.w	lr, #0
 8039332:	bf14      	ite	ne
 8039334:	2000      	movne	r0, #0
 8039336:	2014      	moveq	r0, #20
                            ( crcOn ? 16 : 0 ) -
 8039338:	eba4 0482 	sub.w	r4, r4, r2, lsl #2
    if( datarate <= 6 )
 803933c:	2a06      	cmp	r2, #6
                            ( 4 * datarate ) +
 803933e:	4404      	add	r4, r0
 8039340:	ea4f 0382 	mov.w	r3, r2, lsl #2
 8039344:	f1a2 0002 	sub.w	r0, r2, #2
    if( datarate <= 6 )
 8039348:	d902      	bls.n	8039350 <RadioTimeOnAir+0x98>
        ceilNumerator += 8;
 803934a:	3408      	adds	r4, #8
        if( lowDatareOptimize == true )
 803934c:	b107      	cbz	r7, 8039350 <RadioTimeOnAir+0x98>
            ceilDenominator = 4 * ( datarate - 2 );
 803934e:	0083      	lsls	r3, r0, #2
        ( ( ceilNumerator + ceilDenominator - 1 ) / ceilDenominator ) * crDenom + preambleLen + 12;
 8039350:	2c00      	cmp	r4, #0
 8039352:	bfac      	ite	ge
 8039354:	191c      	addge	r4, r3, r4
 8039356:	1c1c      	addlt	r4, r3, #0
 8039358:	3c01      	subs	r4, #1
 803935a:	fb94 f3f3 	sdiv	r3, r4, r3
            denominator = RadioGetLoRaBandwidthInHz( Bandwidths[bandwidth] );
 803935e:	4c0f      	ldr	r4, [pc, #60]	; (803939c <RadioTimeOnAir+0xe4>)
 8039360:	4421      	add	r1, r4
    if( datarate <= 6 )
 8039362:	2a06      	cmp	r2, #6
            denominator = RadioGetLoRaBandwidthInHz( Bandwidths[bandwidth] );
 8039364:	7909      	ldrb	r1, [r1, #4]
        ( ( ceilNumerator + ceilDenominator - 1 ) / ceilDenominator ) * crDenom + preambleLen + 12;
 8039366:	fb06 5303 	mla	r3, r6, r3, r5
    int32_t intermediate =
 803936a:	bf8c      	ite	hi
 803936c:	330c      	addhi	r3, #12
        intermediate += 2;
 803936e:	330e      	addls	r3, #14
    switch( bw )
 8039370:	290a      	cmp	r1, #10
 8039372:	d812      	bhi.n	803939a <RadioTimeOnAir+0xe2>
    return ( uint32_t )( ( 4 * intermediate + 1 ) * ( 1 << ( datarate - 2 ) ) );
 8039374:	009b      	lsls	r3, r3, #2
 8039376:	3301      	adds	r3, #1
 8039378:	eb04 0481 	add.w	r4, r4, r1, lsl #2
            numerator   = 1000U * RadioGetLoRaTimeOnAirNumerator( bandwidth, datarate,
 803937c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    return ( uint32_t )( ( 4 * intermediate + 1 ) * ( 1 << ( datarate - 2 ) ) );
 8039380:	4083      	lsls	r3, r0
            numerator   = 1000U * RadioGetLoRaTimeOnAirNumerator( bandwidth, datarate,
 8039382:	4353      	muls	r3, r2
 8039384:	68a2      	ldr	r2, [r4, #8]
 8039386:	e7a5      	b.n	80392d4 <RadioTimeOnAir+0x1c>
    if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 8039388:	2901      	cmp	r1, #1
 803938a:	d104      	bne.n	8039396 <RadioTimeOnAir+0xde>
        ( ( bandwidth == 1 ) && ( datarate == 12 ) ) )
 803938c:	f1a2 030c 	sub.w	r3, r2, #12
 8039390:	425f      	negs	r7, r3
 8039392:	415f      	adcs	r7, r3
 8039394:	e7c5      	b.n	8039322 <RadioTimeOnAir+0x6a>
    bool    lowDatareOptimize = false;
 8039396:	2700      	movs	r7, #0
 8039398:	e7c3      	b.n	8039322 <RadioTimeOnAir+0x6a>
    return DIVC(numerator, denominator); /* ST_WORKAROUND : simplified calculation with macro usage */
 803939a:	deff      	udf	#255	; 0xff
 803939c:	0803bb94 	.word	0x0803bb94

080393a0 <RadioSetMaxPayloadLength>:
    if( modem == MODEM_LORA )
 80393a0:	2801      	cmp	r0, #1
 80393a2:	4808      	ldr	r0, [pc, #32]	; (80393c4 <RadioSetMaxPayloadLength+0x24>)
 80393a4:	d105      	bne.n	80393b2 <RadioSetMaxPayloadLength+0x12>
        SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength = max;
 80393a6:	4b08      	ldr	r3, [pc, #32]	; (80393c8 <RadioSetMaxPayloadLength+0x28>)
 80393a8:	77c1      	strb	r1, [r0, #31]
 80393aa:	7019      	strb	r1, [r3, #0]
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 80393ac:	300e      	adds	r0, #14
 80393ae:	f001 b9ff 	b.w	803a7b0 <SUBGRF_SetPacketParams>
        if( SubgRf.PacketParams.Params.Gfsk.HeaderType == RADIO_PACKET_VARIABLE_LENGTH )
 80393b2:	7d43      	ldrb	r3, [r0, #21]
 80393b4:	2b01      	cmp	r3, #1
 80393b6:	d103      	bne.n	80393c0 <RadioSetMaxPayloadLength+0x20>
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength = max;
 80393b8:	4b03      	ldr	r3, [pc, #12]	; (80393c8 <RadioSetMaxPayloadLength+0x28>)
 80393ba:	7581      	strb	r1, [r0, #22]
 80393bc:	7019      	strb	r1, [r3, #0]
 80393be:	e7f5      	b.n	80393ac <RadioSetMaxPayloadLength+0xc>
}
 80393c0:	4770      	bx	lr
 80393c2:	bf00      	nop
 80393c4:	20006324 	.word	0x20006324
 80393c8:	200035a0 	.word	0x200035a0

080393cc <RadioRxBoosted>:
{
 80393cc:	b510      	push	{r4, lr}
 80393ce:	4604      	mov	r4, r0
    if (1UL==RFW_Is_Init())
 80393d0:	f001 fbaa 	bl	803ab28 <RFW_Is_Init>
 80393d4:	2801      	cmp	r0, #1
 80393d6:	d117      	bne.n	8039408 <RadioRxBoosted+0x3c>
      RFW_ReceiveInit();
 80393d8:	f001 fbae 	bl	803ab38 <RFW_ReceiveInit>
    if( timeout != 0 )
 80393dc:	b134      	cbz	r4, 80393ec <RadioRxBoosted+0x20>
        TimerSetValue( &RxTimeoutTimer, timeout );
 80393de:	4810      	ldr	r0, [pc, #64]	; (8039420 <RadioRxBoosted+0x54>)
 80393e0:	4621      	mov	r1, r4
 80393e2:	f002 f80b 	bl	803b3fc <UTIL_TIMER_SetPeriod>
        TimerStart( &RxTimeoutTimer );
 80393e6:	480e      	ldr	r0, [pc, #56]	; (8039420 <RadioRxBoosted+0x54>)
 80393e8:	f001 ffce 	bl	803b388 <UTIL_TIMER_Start>
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_RX);
 80393ec:	4c0d      	ldr	r4, [pc, #52]	; (8039424 <RadioRxBoosted+0x58>)
 80393ee:	2100      	movs	r1, #0
 80393f0:	f894 0056 	ldrb.w	r0, [r4, #86]	; 0x56
 80393f4:	f001 fac9 	bl	803a98a <SUBGRF_SetSwitch>
    if( SubgRf.RxContinuous == true )
 80393f8:	7863      	ldrb	r3, [r4, #1]
 80393fa:	b16b      	cbz	r3, 8039418 <RadioRxBoosted+0x4c>
        SUBGRF_SetRxBoosted( 0xFFFFFF ); // Rx Continuous
 80393fc:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
}
 8039400:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        SUBGRF_SetRxBoosted( SubgRf.RxTimeout << 6 );
 8039404:	f000 bff4 	b.w	803a3f0 <SUBGRF_SetRxBoosted>
      SUBGRF_SetDioIrqParams( IRQ_RX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_CRC_ERROR | IRQ_HEADER_ERROR | IRQ_RX_DBG,
 8039408:	2300      	movs	r3, #0
 803940a:	f240 2162 	movw	r1, #610	; 0x262
 803940e:	461a      	mov	r2, r3
 8039410:	4608      	mov	r0, r1
 8039412:	f000 ff41 	bl	803a298 <SUBGRF_SetDioIrqParams>
 8039416:	e7e1      	b.n	80393dc <RadioRxBoosted+0x10>
        SUBGRF_SetRxBoosted( SubgRf.RxTimeout << 6 );
 8039418:	68a0      	ldr	r0, [r4, #8]
 803941a:	0180      	lsls	r0, r0, #6
 803941c:	e7f0      	b.n	8039400 <RadioRxBoosted+0x34>
 803941e:	bf00      	nop
 8039420:	20006394 	.word	0x20006394
 8039424:	20006324 	.word	0x20006324

08039428 <RadioRx>:
{
 8039428:	b510      	push	{r4, lr}
 803942a:	4604      	mov	r4, r0
    if ( 1UL == RFW_Is_Init( ) )
 803942c:	f001 fb7c 	bl	803ab28 <RFW_Is_Init>
 8039430:	2801      	cmp	r0, #1
 8039432:	d117      	bne.n	8039464 <RadioRx+0x3c>
      RFW_ReceiveInit( );
 8039434:	f001 fb80 	bl	803ab38 <RFW_ReceiveInit>
    if( timeout != 0 )
 8039438:	b134      	cbz	r4, 8039448 <RadioRx+0x20>
        TimerSetValue( &RxTimeoutTimer, timeout );
 803943a:	4810      	ldr	r0, [pc, #64]	; (803947c <RadioRx+0x54>)
 803943c:	4621      	mov	r1, r4
 803943e:	f001 ffdd 	bl	803b3fc <UTIL_TIMER_SetPeriod>
        TimerStart( &RxTimeoutTimer );
 8039442:	480e      	ldr	r0, [pc, #56]	; (803947c <RadioRx+0x54>)
 8039444:	f001 ffa0 	bl	803b388 <UTIL_TIMER_Start>
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_RX);
 8039448:	4c0d      	ldr	r4, [pc, #52]	; (8039480 <RadioRx+0x58>)
 803944a:	2100      	movs	r1, #0
 803944c:	f894 0056 	ldrb.w	r0, [r4, #86]	; 0x56
 8039450:	f001 fa9b 	bl	803a98a <SUBGRF_SetSwitch>
    if( SubgRf.RxContinuous == true )
 8039454:	7863      	ldrb	r3, [r4, #1]
 8039456:	b16b      	cbz	r3, 8039474 <RadioRx+0x4c>
        SUBGRF_SetRx( 0xFFFFFF ); // Rx Continuous
 8039458:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
}
 803945c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        SUBGRF_SetRx( SubgRf.RxTimeout << 6 );
 8039460:	f000 be62 	b.w	803a128 <SUBGRF_SetRx>
      SUBGRF_SetDioIrqParams( IRQ_RX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_CRC_ERROR | IRQ_HEADER_ERROR | IRQ_RX_DBG,
 8039464:	2300      	movs	r3, #0
 8039466:	f240 2162 	movw	r1, #610	; 0x262
 803946a:	461a      	mov	r2, r3
 803946c:	4608      	mov	r0, r1
 803946e:	f000 ff13 	bl	803a298 <SUBGRF_SetDioIrqParams>
 8039472:	e7e1      	b.n	8039438 <RadioRx+0x10>
        SUBGRF_SetRx( SubgRf.RxTimeout << 6 );
 8039474:	68a0      	ldr	r0, [r4, #8]
 8039476:	0180      	lsls	r0, r0, #6
 8039478:	e7f0      	b.n	803945c <RadioRx+0x34>
 803947a:	bf00      	nop
 803947c:	20006394 	.word	0x20006394
 8039480:	20006324 	.word	0x20006324

08039484 <RadioSetPublicNetwork>:
    SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous = enable;
 8039484:	4b0d      	ldr	r3, [pc, #52]	; (80394bc <RadioSetPublicNetwork+0x38>)
{
 8039486:	b510      	push	{r4, lr}
 8039488:	4604      	mov	r4, r0
    SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous = enable;
 803948a:	7318      	strb	r0, [r3, #12]
 803948c:	7358      	strb	r0, [r3, #13]
    RadioSetModem( MODEM_LORA );
 803948e:	2001      	movs	r0, #1
 8039490:	f000 f816 	bl	80394c0 <RadioSetModem>
    if( enable == true )
 8039494:	b15c      	cbz	r4, 80394ae <RadioSetPublicNetwork+0x2a>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD, ( LORA_MAC_PUBLIC_SYNCWORD >> 8 ) & 0xFF );
 8039496:	2134      	movs	r1, #52	; 0x34
 8039498:	f44f 60e8 	mov.w	r0, #1856	; 0x740
 803949c:	f000 ff98 	bl	803a3d0 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PUBLIC_SYNCWORD & 0xFF );
 80394a0:	2144      	movs	r1, #68	; 0x44
}
 80394a2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PRIVATE_SYNCWORD & 0xFF );
 80394a6:	f240 7041 	movw	r0, #1857	; 0x741
 80394aa:	f000 bf91 	b.w	803a3d0 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD, ( LORA_MAC_PRIVATE_SYNCWORD >> 8 ) & 0xFF );
 80394ae:	2114      	movs	r1, #20
 80394b0:	f44f 60e8 	mov.w	r0, #1856	; 0x740
 80394b4:	f000 ff8c 	bl	803a3d0 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PRIVATE_SYNCWORD & 0xFF );
 80394b8:	2124      	movs	r1, #36	; 0x24
 80394ba:	e7f2      	b.n	80394a2 <RadioSetPublicNetwork+0x1e>
 80394bc:	20006324 	.word	0x20006324

080394c0 <RadioSetModem>:
{
 80394c0:	b538      	push	{r3, r4, r5, lr}
    SubgRf.Modem = modem;
 80394c2:	4d0f      	ldr	r5, [pc, #60]	; (8039500 <RadioSetModem+0x40>)
{
 80394c4:	4604      	mov	r4, r0
    SubgRf.Modem = modem;
 80394c6:	7028      	strb	r0, [r5, #0]
    RFW_SetRadioModem(modem);
 80394c8:	f001 fb3b 	bl	803ab42 <RFW_SetRadioModem>
    switch( modem )
 80394cc:	2c01      	cmp	r4, #1
 80394ce:	d00a      	beq.n	80394e6 <RadioSetModem+0x26>
 80394d0:	3c02      	subs	r4, #2
 80394d2:	2c01      	cmp	r4, #1
 80394d4:	f04f 0400 	mov.w	r4, #0
        SUBGRF_SetPacketType( PACKET_TYPE_BPSK );
 80394d8:	bf94      	ite	ls
 80394da:	2002      	movls	r0, #2
        SUBGRF_SetPacketType( PACKET_TYPE_GFSK );
 80394dc:	4620      	movhi	r0, r4
 80394de:	f000 ffbb 	bl	803a458 <SUBGRF_SetPacketType>
        SubgRf.PublicNetwork.Current = false;
 80394e2:	736c      	strb	r4, [r5, #13]
}
 80394e4:	bd38      	pop	{r3, r4, r5, pc}
        SUBGRF_SetPacketType( PACKET_TYPE_LORA );
 80394e6:	4620      	mov	r0, r4
 80394e8:	f000 ffb6 	bl	803a458 <SUBGRF_SetPacketType>
        if( SubgRf.PublicNetwork.Current != SubgRf.PublicNetwork.Previous )
 80394ec:	7b28      	ldrb	r0, [r5, #12]
 80394ee:	7b6b      	ldrb	r3, [r5, #13]
 80394f0:	4283      	cmp	r3, r0
 80394f2:	d0f7      	beq.n	80394e4 <RadioSetModem+0x24>
            SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous;
 80394f4:	7368      	strb	r0, [r5, #13]
}
 80394f6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
            RadioSetPublicNetwork( SubgRf.PublicNetwork.Current );
 80394fa:	f7ff bfc3 	b.w	8039484 <RadioSetPublicNetwork>
 80394fe:	bf00      	nop
 8039500:	20006324 	.word	0x20006324

08039504 <RadioSetTxGenericConfig>:
    }
    return status;
}

static int32_t RadioSetTxGenericConfig( GenericModems_t modem, TxConfigGeneric_t* config, int8_t power, uint32_t timeout )
{
 8039504:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8039508:	4605      	mov	r5, r0
 803950a:	b087      	sub	sp, #28
    uint8_t syncword[8] = {0};
 803950c:	2700      	movs	r7, #0
 803950e:	e9cd 7701 	strd	r7, r7, [sp, #4]
{
 8039512:	460c      	mov	r4, r1
 8039514:	4691      	mov	r9, r2
 8039516:	4698      	mov	r8, r3
    RFW_DeInit( ); /* switch Off FwPacketDecoding by default */
 8039518:	f001 fb05 	bl	803ab26 <RFW_DeInit>
    switch( modem )
 803951c:	2d01      	cmp	r5, #1
 803951e:	d078      	beq.n	8039612 <RadioSetTxGenericConfig+0x10e>
 8039520:	2d02      	cmp	r5, #2
 8039522:	f000 80c4 	beq.w	80396ae <RadioSetTxGenericConfig+0x1aa>
 8039526:	2d00      	cmp	r5, #0
 8039528:	d15c      	bne.n	80395e4 <RadioSetTxGenericConfig+0xe0>
    {
    case GENERIC_FSK:
        if( ( config->fsk.BitRate == 0 ) || ( config->fsk.PreambleLen == 0 ) )
 803952a:	68a3      	ldr	r3, [r4, #8]
 803952c:	2b00      	cmp	r3, #0
 803952e:	f000 80d2 	beq.w	80396d6 <RadioSetTxGenericConfig+0x1d2>
 8039532:	6922      	ldr	r2, [r4, #16]
 8039534:	2a00      	cmp	r2, #0
 8039536:	f000 80ce 	beq.w	80396d6 <RadioSetTxGenericConfig+0x1d2>
        {
            return -1;
        }
        if( config->fsk.SyncWordLength > 8 )
 803953a:	7d22      	ldrb	r2, [r4, #20]
 803953c:	2a08      	cmp	r2, #8
 803953e:	f200 80ca 	bhi.w	80396d6 <RadioSetTxGenericConfig+0x1d2>
        }
        else
        {
            for(int i = 0; i < config->fsk.SyncWordLength; i++)
            {
                syncword[i] = config->fsk.SyncWord[i];
 8039542:	a901      	add	r1, sp, #4
            for(int i = 0; i < config->fsk.SyncWordLength; i++)
 8039544:	42aa      	cmp	r2, r5
 8039546:	dc5b      	bgt.n	8039600 <RadioSetTxGenericConfig+0xfc>
            }
        }
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 8039548:	4d64      	ldr	r5, [pc, #400]	; (80396dc <RadioSetTxGenericConfig+0x1d8>)
 803954a:	2600      	movs	r6, #0
 803954c:	f885 6038 	strb.w	r6, [r5, #56]	; 0x38
        SubgRf.ModulationParams.Params.Gfsk.BitRate = config->fsk.BitRate;
 8039550:	63eb      	str	r3, [r5, #60]	; 0x3c
        SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = ( RadioModShapings_t ) config->fsk.ModulationShaping;
 8039552:	7823      	ldrb	r3, [r4, #0]
 8039554:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
        SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( config->fsk.Bandwidth );
 8039558:	6860      	ldr	r0, [r4, #4]
 803955a:	f001 fa85 	bl	803aa68 <SUBGRF_GetFskBandwidthRegValue>
 803955e:	f885 0045 	strb.w	r0, [r5, #69]	; 0x45
        SubgRf.ModulationParams.Params.Gfsk.Fdev = config->fsk.FrequencyDeviation;
 8039562:	68e3      	ldr	r3, [r4, #12]
 8039564:	642b      	str	r3, [r5, #64]	; 0x40
    
        SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
        SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( config->fsk.PreambleLen ) << 3; // convert byte into bit
 8039566:	6923      	ldr	r3, [r4, #16]
        SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS; // don't care in tx
        SubgRf.PacketParams.Params.Gfsk.SyncWordLength = ( config->fsk.SyncWordLength ) << 3; // convert byte into bit
        SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF; // don't care in tx

        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING ) || ( config->fsk.HeaderType == RADIO_FSK_PACKET_2BYTES_LENGTH ) )
 8039568:	f894 1024 	ldrb.w	r1, [r4, #36]	; 0x24
        SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 803956c:	73ae      	strb	r6, [r5, #14]
        SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( config->fsk.PreambleLen ) << 3; // convert byte into bit
 803956e:	00db      	lsls	r3, r3, #3
 8039570:	822b      	strh	r3, [r5, #16]
        SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS; // don't care in tx
 8039572:	2304      	movs	r3, #4
 8039574:	74ab      	strb	r3, [r5, #18]
        SubgRf.PacketParams.Params.Gfsk.SyncWordLength = ( config->fsk.SyncWordLength ) << 3; // convert byte into bit
 8039576:	7d23      	ldrb	r3, [r4, #20]
        SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF; // don't care in tx
 8039578:	752e      	strb	r6, [r5, #20]
        SubgRf.PacketParams.Params.Gfsk.SyncWordLength = ( config->fsk.SyncWordLength ) << 3; // convert byte into bit
 803957a:	00db      	lsls	r3, r3, #3
        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING ) || ( config->fsk.HeaderType == RADIO_FSK_PACKET_2BYTES_LENGTH ) )
 803957c:	2902      	cmp	r1, #2
        SubgRf.PacketParams.Params.Gfsk.SyncWordLength = ( config->fsk.SyncWordLength ) << 3; // convert byte into bit
 803957e:	74eb      	strb	r3, [r5, #19]
        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING ) || ( config->fsk.HeaderType == RADIO_FSK_PACKET_2BYTES_LENGTH ) )
 8039580:	462e      	mov	r6, r5
 8039582:	7fe3      	ldrb	r3, [r4, #31]
 8039584:	d002      	beq.n	803958c <RadioSetTxGenericConfig+0x88>
 8039586:	7fa2      	ldrb	r2, [r4, #30]
 8039588:	2a02      	cmp	r2, #2
 803958a:	d13e      	bne.n	803960a <RadioSetTxGenericConfig+0x106>
        {
            /* Supports only RADIO_FSK_CRC_2_BYTES_IBM or RADIO_FSK_CRC_2_BYTES_CCIT */
            if( ( config->fsk.CrcLength != RADIO_FSK_CRC_2_BYTES_IBM ) && ( config->fsk.CrcLength != RADIO_FSK_CRC_2_BYTES_CCIT ) &&( config->fsk.CrcLength != RADIO_FSK_CRC_OFF ) )
 803958c:	f103 020f 	add.w	r2, r3, #15
 8039590:	b2d2      	uxtb	r2, r2
 8039592:	2a01      	cmp	r2, #1
 8039594:	d902      	bls.n	803959c <RadioSetTxGenericConfig+0x98>
 8039596:	2b01      	cmp	r3, #1
 8039598:	f040 809d 	bne.w	80396d6 <RadioSetTxGenericConfig+0x1d2>
                return -1;
            }
            ConfigGeneric_t ConfigGeneric;
            ConfigGeneric.rtx = CONFIG_TX;
            ConfigGeneric.TxConfig = config;
            if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &TxTimeoutTimer ) )
 803959c:	4b50      	ldr	r3, [pc, #320]	; (80396e0 <RadioSetTxGenericConfig+0x1dc>)
 803959e:	4a51      	ldr	r2, [pc, #324]	; (80396e4 <RadioSetTxGenericConfig+0x1e0>)
 80395a0:	6819      	ldr	r1, [r3, #0]
            ConfigGeneric.TxConfig = config;
 80395a2:	9403      	str	r4, [sp, #12]
            ConfigGeneric.rtx = CONFIG_TX;
 80395a4:	2501      	movs	r5, #1
            if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &TxTimeoutTimer ) )
 80395a6:	a803      	add	r0, sp, #12
            ConfigGeneric.rtx = CONFIG_TX;
 80395a8:	f88d 5014 	strb.w	r5, [sp, #20]
            if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &TxTimeoutTimer ) )
 80395ac:	f001 fab8 	bl	803ab20 <RFW_Init>
 80395b0:	2800      	cmp	r0, #0
 80395b2:	f040 8090 	bne.w	80396d6 <RadioSetTxGenericConfig+0x1d2>
            {
              return -1;
            }
            /* whitening off, will be processed by FW, switch off built-in radio whitening */
            SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) RADIO_FSK_DC_FREE_OFF;
 80395b6:	7630      	strb	r0, [r6, #24]
            /* Crc processed by FW, switch off built-in radio Crc */
            SubgRf.PacketParams.Params.Gfsk.CrcLength = (RadioCrcTypes_t) RADIO_CRC_OFF;
 80395b8:	75f5      	strb	r5, [r6, #23]
            /* length contained in Tx, but will be processed by FW after de-whitening */
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) RADIO_PACKET_FIXED_LENGTH;
 80395ba:	7570      	strb	r0, [r6, #21]
          SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) config->fsk.CrcLength;
          SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) config->fsk.Whitening;
          SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) config->fsk.HeaderType;
        }

        RadioStandby( );
 80395bc:	f7ff fcf8 	bl	8038fb0 <RadioStandby>
        RadioSetModem( MODEM_FSK );
 80395c0:	2000      	movs	r0, #0
 80395c2:	f7ff ff7d 	bl	80394c0 <RadioSetModem>
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 80395c6:	4848      	ldr	r0, [pc, #288]	; (80396e8 <RadioSetTxGenericConfig+0x1e4>)
 80395c8:	f000 ff5c 	bl	803a484 <SUBGRF_SetModulationParams>
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 80395cc:	4847      	ldr	r0, [pc, #284]	; (80396ec <RadioSetTxGenericConfig+0x1e8>)
 80395ce:	f001 f8ef 	bl	803a7b0 <SUBGRF_SetPacketParams>
        SUBGRF_SetSyncWord( syncword );
 80395d2:	a801      	add	r0, sp, #4
 80395d4:	f001 f8be 	bl	803a754 <SUBGRF_SetSyncWord>
        SUBGRF_SetWhiteningSeed( config->fsk.whiteSeed );
 80395d8:	8ba0      	ldrh	r0, [r4, #28]
 80395da:	f001 f82d 	bl	803a638 <SUBGRF_SetWhiteningSeed>
        SUBGRF_SetCrcPolynomial(config->fsk.CrcPolynomial );
 80395de:	8c20      	ldrh	r0, [r4, #32]
 80395e0:	f001 f8d4 	bl	803a78c <SUBGRF_SetCrcPolynomial>
        break;
    default:
        break;
    }

    SubgRf.AntSwitchPaSelect = SUBGRF_SetRfTxPower( power );
 80395e4:	4648      	mov	r0, r9
 80395e6:	f001 f9e6 	bl	803a9b6 <SUBGRF_SetRfTxPower>
 80395ea:	4c3c      	ldr	r4, [pc, #240]	; (80396dc <RadioSetTxGenericConfig+0x1d8>)
 80395ec:	f884 0056 	strb.w	r0, [r4, #86]	; 0x56
    RFW_SetAntSwitch( SubgRf.AntSwitchPaSelect );
 80395f0:	f001 fa9e 	bl	803ab30 <RFW_SetAntSwitch>
    SubgRf.TxTimeout = timeout;
 80395f4:	f8c4 8004 	str.w	r8, [r4, #4]
    return 0;
 80395f8:	2000      	movs	r0, #0
}
 80395fa:	b007      	add	sp, #28
 80395fc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
                syncword[i] = config->fsk.SyncWord[i];
 8039600:	69a0      	ldr	r0, [r4, #24]
 8039602:	5d40      	ldrb	r0, [r0, r5]
 8039604:	5468      	strb	r0, [r5, r1]
            for(int i = 0; i < config->fsk.SyncWordLength; i++)
 8039606:	3501      	adds	r5, #1
 8039608:	e79c      	b.n	8039544 <RadioSetTxGenericConfig+0x40>
          SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) config->fsk.CrcLength;
 803960a:	75eb      	strb	r3, [r5, #23]
          SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) config->fsk.Whitening;
 803960c:	7629      	strb	r1, [r5, #24]
          SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) config->fsk.HeaderType;
 803960e:	756a      	strb	r2, [r5, #21]
 8039610:	e7d4      	b.n	80395bc <RadioSetTxGenericConfig+0xb8>
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_LORA;
 8039612:	4e32      	ldr	r6, [pc, #200]	; (80396dc <RadioSetTxGenericConfig+0x1d8>)
 8039614:	f886 5038 	strb.w	r5, [r6, #56]	; 0x38
        SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t ) config->lora.SpreadingFactor;
 8039618:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 803961c:	f886 3050 	strb.w	r3, [r6, #80]	; 0x50
        SubgRf.ModulationParams.Params.LoRa.Bandwidth = ( RadioLoRaBandwidths_t ) config->lora.Bandwidth;
 8039620:	f894 2029 	ldrb.w	r2, [r4, #41]	; 0x29
 8039624:	f886 2051 	strb.w	r2, [r6, #81]	; 0x51
        SubgRf.ModulationParams.Params.LoRa.CodingRate = ( RadioLoRaCodingRates_t ) config->lora.Coderate;
 8039628:	f894 202a 	ldrb.w	r2, [r4, #42]	; 0x2a
 803962c:	f886 2052 	strb.w	r2, [r6, #82]	; 0x52
        switch( config->lora.LowDatarateOptimize )
 8039630:	f894 102b 	ldrb.w	r1, [r4, #43]	; 0x2b
 8039634:	2901      	cmp	r1, #1
 8039636:	d002      	beq.n	803963e <RadioSetTxGenericConfig+0x13a>
 8039638:	2902      	cmp	r1, #2
 803963a:	d02b      	beq.n	8039694 <RadioSetTxGenericConfig+0x190>
 803963c:	b909      	cbnz	r1, 8039642 <RadioSetTxGenericConfig+0x13e>
            SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 1;
 803963e:	f886 1053 	strb.w	r1, [r6, #83]	; 0x53
        SubgRf.PacketParams.Params.LoRa.PreambleLength = config->lora.PreambleLen;
 8039642:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 8039644:	83b3      	strh	r3, [r6, #28]
        SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t ) config->lora.LengthMode;
 8039646:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
 803964a:	77b3      	strb	r3, [r6, #30]
        SubgRf.PacketParams.Params.LoRa.CrcMode = ( RadioLoRaCrcModes_t ) config->lora.CrcMode;
 803964c:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
 8039650:	f886 3020 	strb.w	r3, [r6, #32]
        SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 8039654:	2501      	movs	r5, #1
        SubgRf.PacketParams.Params.LoRa.InvertIQ = ( RadioLoRaIQModes_t ) config->lora.IqInverted;
 8039656:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
 803965a:	f886 3021 	strb.w	r3, [r6, #33]	; 0x21
        SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 803965e:	73b5      	strb	r5, [r6, #14]
        RadioStandby( );
 8039660:	f7ff fca6 	bl	8038fb0 <RadioStandby>
        RadioSetModem( MODEM_LORA );
 8039664:	4628      	mov	r0, r5
 8039666:	f7ff ff2b 	bl	80394c0 <RadioSetModem>
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 803966a:	481f      	ldr	r0, [pc, #124]	; (80396e8 <RadioSetTxGenericConfig+0x1e4>)
 803966c:	f000 ff0a 	bl	803a484 <SUBGRF_SetModulationParams>
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039670:	481e      	ldr	r0, [pc, #120]	; (80396ec <RadioSetTxGenericConfig+0x1e8>)
 8039672:	f001 f89d 	bl	803a7b0 <SUBGRF_SetPacketParams>
        if( SubgRf.ModulationParams.Params.LoRa.Bandwidth == LORA_BW_500 )
 8039676:	f896 3051 	ldrb.w	r3, [r6, #81]	; 0x51
 803967a:	2b06      	cmp	r3, #6
            SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) & ~( 1 << 2 ) );
 803967c:	f640 0089 	movw	r0, #2185	; 0x889
        if( SubgRf.ModulationParams.Params.LoRa.Bandwidth == LORA_BW_500 )
 8039680:	d10f      	bne.n	80396a2 <RadioSetTxGenericConfig+0x19e>
            SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) & ~( 1 << 2 ) );
 8039682:	f000 ff6b 	bl	803a55c <SUBGRF_ReadRegister>
 8039686:	f000 01fb 	and.w	r1, r0, #251	; 0xfb
            SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) | ( 1 << 2 ) );
 803968a:	f640 0089 	movw	r0, #2185	; 0x889
 803968e:	f000 fe9f 	bl	803a3d0 <SUBGRF_WriteRegister>
 8039692:	e7a7      	b.n	80395e4 <RadioSetTxGenericConfig+0xe0>
            if( ( config->lora.SpreadingFactor == RADIO_LORA_SF11 ) || ( config->lora.SpreadingFactor == RADIO_LORA_SF12 ) )
 8039694:	3b0b      	subs	r3, #11
              SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 1;
 8039696:	2b01      	cmp	r3, #1
 8039698:	bf88      	it	hi
 803969a:	463d      	movhi	r5, r7
 803969c:	f886 5053 	strb.w	r5, [r6, #83]	; 0x53
 80396a0:	e7cf      	b.n	8039642 <RadioSetTxGenericConfig+0x13e>
            SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) | ( 1 << 2 ) );
 80396a2:	f000 ff5b 	bl	803a55c <SUBGRF_ReadRegister>
 80396a6:	f040 0104 	orr.w	r1, r0, #4
 80396aa:	b2c9      	uxtb	r1, r1
 80396ac:	e7ed      	b.n	803968a <RadioSetTxGenericConfig+0x186>
        if( ( config->bpsk.BitRate == 0 ) || ( config->bpsk.BitRate > 1000 ) )
 80396ae:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80396b0:	3b01      	subs	r3, #1
 80396b2:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 80396b6:	d20e      	bcs.n	80396d6 <RadioSetTxGenericConfig+0x1d2>
        RadioSetModem( MODEM_BPSK );
 80396b8:	4628      	mov	r0, r5
 80396ba:	f7ff ff01 	bl	80394c0 <RadioSetModem>
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_BPSK;
 80396be:	4807      	ldr	r0, [pc, #28]	; (80396dc <RadioSetTxGenericConfig+0x1d8>)
 80396c0:	f880 5038 	strb.w	r5, [r0, #56]	; 0x38
        SubgRf.ModulationParams.Params.Bpsk.BitRate = config->bpsk.BitRate;
 80396c4:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80396c6:	6483      	str	r3, [r0, #72]	; 0x48
        SubgRf.ModulationParams.Params.Bpsk.ModulationShaping = MOD_SHAPING_DBPSK;
 80396c8:	2316      	movs	r3, #22
 80396ca:	f880 304c 	strb.w	r3, [r0, #76]	; 0x4c
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 80396ce:	3038      	adds	r0, #56	; 0x38
 80396d0:	f000 fed8 	bl	803a484 <SUBGRF_SetModulationParams>
        break;
 80396d4:	e786      	b.n	80395e4 <RadioSetTxGenericConfig+0xe0>
            return -1;
 80396d6:	f04f 30ff 	mov.w	r0, #4294967295
 80396da:	e78e      	b.n	80395fa <RadioSetTxGenericConfig+0xf6>
 80396dc:	20006324 	.word	0x20006324
 80396e0:	2000597c 	.word	0x2000597c
 80396e4:	2000637c 	.word	0x2000637c
 80396e8:	2000635c 	.word	0x2000635c
 80396ec:	20006332 	.word	0x20006332

080396f0 <RadioSetRxGenericConfig>:
{
 80396f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uint8_t syncword[8] = {0};
 80396f4:	2600      	movs	r6, #0
{
 80396f6:	b086      	sub	sp, #24
 80396f8:	4698      	mov	r8, r3
 80396fa:	4614      	mov	r4, r2
    uint8_t syncword[8] = {0};
 80396fc:	e9cd 6601 	strd	r6, r6, [sp, #4]
{
 8039700:	4607      	mov	r7, r0
 8039702:	460d      	mov	r5, r1
    RFW_DeInit( ); /* switch Off FwPacketDecoding by default */
 8039704:	f001 fa0f 	bl	803ab26 <RFW_DeInit>
        symbTimeout = 0;
 8039708:	42b4      	cmp	r4, r6
    SubgRf.RxContinuous = ( rxContinuous == 0 ) ? false : true;
 803970a:	4c77      	ldr	r4, [pc, #476]	; (80398e8 <RadioSetRxGenericConfig+0x1f8>)
 803970c:	bf16      	itet	ne
 803970e:	2301      	movne	r3, #1
 8039710:	4633      	moveq	r3, r6
        symbTimeout = 0;
 8039712:	46b0      	movne	r8, r6
    SubgRf.RxContinuous = ( rxContinuous == 0 ) ? false : true;
 8039714:	7063      	strb	r3, [r4, #1]
    switch( modem )
 8039716:	b137      	cbz	r7, 8039726 <RadioSetRxGenericConfig+0x36>
 8039718:	2f01      	cmp	r7, #1
 803971a:	f000 8082 	beq.w	8039822 <RadioSetRxGenericConfig+0x132>
    return status;
 803971e:	2000      	movs	r0, #0
}
 8039720:	b006      	add	sp, #24
 8039722:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if( ( config->fsk.BitRate == 0 ) || ( config->fsk.PreambleLen == 0 ) )
 8039726:	68eb      	ldr	r3, [r5, #12]
 8039728:	2b00      	cmp	r3, #0
 803972a:	f000 80d9 	beq.w	80398e0 <RadioSetRxGenericConfig+0x1f0>
 803972e:	692b      	ldr	r3, [r5, #16]
 8039730:	2b00      	cmp	r3, #0
 8039732:	f000 80d5 	beq.w	80398e0 <RadioSetRxGenericConfig+0x1f0>
        if( config->fsk.SyncWordLength > 8 )
 8039736:	7d6b      	ldrb	r3, [r5, #21]
 8039738:	2b08      	cmp	r3, #8
 803973a:	f200 80d1 	bhi.w	80398e0 <RadioSetRxGenericConfig+0x1f0>
            for(int i = 0; i < config->fsk.SyncWordLength; i++)
 803973e:	4638      	mov	r0, r7
                syncword[i] = config->fsk.SyncWord[i];
 8039740:	aa01      	add	r2, sp, #4
            for(int i = 0; i < config->fsk.SyncWordLength; i++)
 8039742:	4283      	cmp	r3, r0
 8039744:	dc62      	bgt.n	803980c <RadioSetRxGenericConfig+0x11c>
        SUBGRF_SetStopRxTimerOnPreambleDetect( ( config->fsk.StopTimerOnPreambleDetect == 0 ) ? false : true );
 8039746:	6828      	ldr	r0, [r5, #0]
 8039748:	3800      	subs	r0, #0
 803974a:	bf18      	it	ne
 803974c:	2001      	movne	r0, #1
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 803974e:	2600      	movs	r6, #0
        SUBGRF_SetStopRxTimerOnPreambleDetect( ( config->fsk.StopTimerOnPreambleDetect == 0 ) ? false : true );
 8039750:	f000 fd32 	bl	803a1b8 <SUBGRF_SetStopRxTimerOnPreambleDetect>
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 8039754:	f884 6038 	strb.w	r6, [r4, #56]	; 0x38
        SubgRf.ModulationParams.Params.Gfsk.BitRate = config->fsk.BitRate;
 8039758:	68eb      	ldr	r3, [r5, #12]
 803975a:	63e3      	str	r3, [r4, #60]	; 0x3c
        SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = (RadioModShapings_t) config->fsk.ModulationShaping;
 803975c:	792b      	ldrb	r3, [r5, #4]
 803975e:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
        SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( config->fsk.Bandwidth );
 8039762:	68a8      	ldr	r0, [r5, #8]
 8039764:	f001 f980 	bl	803aa68 <SUBGRF_GetFskBandwidthRegValue>
 8039768:	f884 0045 	strb.w	r0, [r4, #69]	; 0x45
        SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( config->fsk.PreambleLen ) << 3 ; // convert byte into bit
 803976c:	692b      	ldr	r3, [r5, #16]
        SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 803976e:	73a6      	strb	r6, [r4, #14]
        SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( config->fsk.PreambleLen ) << 3 ; // convert byte into bit
 8039770:	00db      	lsls	r3, r3, #3
 8039772:	8223      	strh	r3, [r4, #16]
        SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = ( RadioPreambleDetection_t ) config->fsk.PreambleMinDetect;
 8039774:	7d2b      	ldrb	r3, [r5, #20]
 8039776:	74a3      	strb	r3, [r4, #18]
        SubgRf.PacketParams.Params.Gfsk.SyncWordLength = ( config->fsk.SyncWordLength ) << 3; // convert byte into bit
 8039778:	7d6b      	ldrb	r3, [r5, #21]
 803977a:	00db      	lsls	r3, r3, #3
 803977c:	74e3      	strb	r3, [r4, #19]
        SubgRf.PacketParams.Params.Gfsk.AddrComp = ( RadioAddressComp_t ) config->fsk.AddrComp;
 803977e:	f895 3022 	ldrb.w	r3, [r5, #34]	; 0x22
 8039782:	7523      	strb	r3, [r4, #20]
        if( config->fsk.LengthMode == RADIO_FSK_PACKET_FIXED_LENGTH )
 8039784:	f895 3023 	ldrb.w	r3, [r5, #35]	; 0x23
 8039788:	2b00      	cmp	r3, #0
 803978a:	d144      	bne.n	8039816 <RadioSetRxGenericConfig+0x126>
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = config->fsk.MaxPayloadLength;
 803978c:	69ea      	ldr	r2, [r5, #28]
        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING ) || ( config->fsk.LengthMode == RADIO_FSK_PACKET_2BYTES_LENGTH ) )
 803978e:	f895 102a 	ldrb.w	r1, [r5, #42]	; 0x2a
          SubgRf.PacketParams.Params.Gfsk.PayloadLength = 0xFF;
 8039792:	75a2      	strb	r2, [r4, #22]
        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING ) || ( config->fsk.LengthMode == RADIO_FSK_PACKET_2BYTES_LENGTH ) )
 8039794:	2902      	cmp	r1, #2
 8039796:	f895 2024 	ldrb.w	r2, [r5, #36]	; 0x24
 803979a:	d001      	beq.n	80397a0 <RadioSetRxGenericConfig+0xb0>
 803979c:	2b02      	cmp	r3, #2
 803979e:	d13c      	bne.n	803981a <RadioSetRxGenericConfig+0x12a>
          if( ( config->fsk.CrcLength != RADIO_FSK_CRC_2_BYTES_IBM ) && ( config->fsk.CrcLength != RADIO_FSK_CRC_2_BYTES_CCIT ) && ( config->fsk.CrcLength != RADIO_FSK_CRC_OFF ) )
 80397a0:	f102 030f 	add.w	r3, r2, #15
 80397a4:	b2db      	uxtb	r3, r3
 80397a6:	2b01      	cmp	r3, #1
 80397a8:	d902      	bls.n	80397b0 <RadioSetRxGenericConfig+0xc0>
 80397aa:	2a01      	cmp	r2, #1
 80397ac:	f040 8098 	bne.w	80398e0 <RadioSetRxGenericConfig+0x1f0>
          ConfigGeneric.rtx = CONFIG_RX;
 80397b0:	2300      	movs	r3, #0
 80397b2:	f88d 3014 	strb.w	r3, [sp, #20]
          if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &RxTimeoutTimer ) )
 80397b6:	4b4d      	ldr	r3, [pc, #308]	; (80398ec <RadioSetRxGenericConfig+0x1fc>)
 80397b8:	4a4d      	ldr	r2, [pc, #308]	; (80398f0 <RadioSetRxGenericConfig+0x200>)
 80397ba:	6819      	ldr	r1, [r3, #0]
          ConfigGeneric.RxConfig = config;
 80397bc:	9504      	str	r5, [sp, #16]
          if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &RxTimeoutTimer ) )
 80397be:	a803      	add	r0, sp, #12
 80397c0:	f001 f9ae 	bl	803ab20 <RFW_Init>
 80397c4:	2800      	cmp	r0, #0
 80397c6:	f040 808b 	bne.w	80398e0 <RadioSetRxGenericConfig+0x1f0>
          SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) RADIO_CRC_OFF;
 80397ca:	2301      	movs	r3, #1
          SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) RADIO_FSK_DC_FREE_OFF;
 80397cc:	7620      	strb	r0, [r4, #24]
          SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) RADIO_CRC_OFF;
 80397ce:	75e3      	strb	r3, [r4, #23]
          SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) RADIO_PACKET_FIXED_LENGTH;
 80397d0:	7560      	strb	r0, [r4, #21]
        RadioStandby( );
 80397d2:	f7ff fbed 	bl	8038fb0 <RadioStandby>
        RadioSetModem( MODEM_FSK );
 80397d6:	2000      	movs	r0, #0
 80397d8:	f7ff fe72 	bl	80394c0 <RadioSetModem>
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 80397dc:	4845      	ldr	r0, [pc, #276]	; (80398f4 <RadioSetRxGenericConfig+0x204>)
 80397de:	f000 fe51 	bl	803a484 <SUBGRF_SetModulationParams>
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 80397e2:	4845      	ldr	r0, [pc, #276]	; (80398f8 <RadioSetRxGenericConfig+0x208>)
 80397e4:	f000 ffe4 	bl	803a7b0 <SUBGRF_SetPacketParams>
        SUBGRF_SetSyncWord( syncword );
 80397e8:	a801      	add	r0, sp, #4
 80397ea:	f000 ffb3 	bl	803a754 <SUBGRF_SetSyncWord>
        SUBGRF_SetWhiteningSeed( config->fsk.whiteSeed );
 80397ee:	8c28      	ldrh	r0, [r5, #32]
 80397f0:	f000 ff22 	bl	803a638 <SUBGRF_SetWhiteningSeed>
        SUBGRF_SetCrcPolynomial( config->fsk.CrcPolynomial );
 80397f4:	8ce8      	ldrh	r0, [r5, #38]	; 0x26
 80397f6:	f000 ffc9 	bl	803a78c <SUBGRF_SetCrcPolynomial>
        SubgRf.RxTimeout = ( uint32_t )( ( symbTimeout * 1000 * 8 ) / config->fsk.BitRate );
 80397fa:	f44f 53fa 	mov.w	r3, #8000	; 0x1f40
 80397fe:	fb03 f808 	mul.w	r8, r3, r8
 8039802:	68eb      	ldr	r3, [r5, #12]
 8039804:	fbb8 f3f3 	udiv	r3, r8, r3
        SubgRf.RxTimeout = 0xFFFF;
 8039808:	60a3      	str	r3, [r4, #8]
 803980a:	e788      	b.n	803971e <RadioSetRxGenericConfig+0x2e>
                syncword[i] = config->fsk.SyncWord[i];
 803980c:	69a9      	ldr	r1, [r5, #24]
 803980e:	5c09      	ldrb	r1, [r1, r0]
 8039810:	5481      	strb	r1, [r0, r2]
            for(int i = 0; i < config->fsk.SyncWordLength; i++)
 8039812:	3001      	adds	r0, #1
 8039814:	e795      	b.n	8039742 <RadioSetRxGenericConfig+0x52>
          SubgRf.PacketParams.Params.Gfsk.PayloadLength = 0xFF;
 8039816:	22ff      	movs	r2, #255	; 0xff
 8039818:	e7b9      	b.n	803978e <RadioSetRxGenericConfig+0x9e>
          SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) config->fsk.CrcLength;
 803981a:	75e2      	strb	r2, [r4, #23]
          SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) config->fsk.Whitening;
 803981c:	7621      	strb	r1, [r4, #24]
          SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) config->fsk.LengthMode;
 803981e:	7563      	strb	r3, [r4, #21]
 8039820:	e7d7      	b.n	80397d2 <RadioSetRxGenericConfig+0xe2>
        if( config->lora.PreambleLen == 0 )
 8039822:	8eab      	ldrh	r3, [r5, #52]	; 0x34
 8039824:	2b00      	cmp	r3, #0
 8039826:	d05b      	beq.n	80398e0 <RadioSetRxGenericConfig+0x1f0>
        if( config->lora.LengthMode == RADIO_LORA_PACKET_FIXED_LENGTH )
 8039828:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
        SUBGRF_SetStopRxTimerOnPreambleDetect( ( config->lora.StopTimerOnPreambleDetect == 0 ) ? false : true );
 803982c:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
        if( config->lora.LengthMode == RADIO_LORA_PACKET_FIXED_LENGTH )
 803982e:	2b01      	cmp	r3, #1
            MaxPayloadLength = config->fsk.MaxPayloadLength;
 8039830:	bf0c      	ite	eq
 8039832:	7f2f      	ldrbeq	r7, [r5, #28]
            MaxPayloadLength = 0xFF;
 8039834:	27ff      	movne	r7, #255	; 0xff
        SUBGRF_SetStopRxTimerOnPreambleDetect( ( config->lora.StopTimerOnPreambleDetect == 0 ) ? false : true );
 8039836:	3800      	subs	r0, #0
 8039838:	bf18      	it	ne
 803983a:	2001      	movne	r0, #1
 803983c:	f000 fcbc 	bl	803a1b8 <SUBGRF_SetStopRxTimerOnPreambleDetect>
        SUBGRF_SetLoRaSymbNumTimeout( symbTimeout );
 8039840:	fa5f f088 	uxtb.w	r0, r8
 8039844:	f000 fdf0 	bl	803a428 <SUBGRF_SetLoRaSymbNumTimeout>
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_LORA;
 8039848:	2101      	movs	r1, #1
 803984a:	f884 1038 	strb.w	r1, [r4, #56]	; 0x38
        SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t ) config->lora.SpreadingFactor;
 803984e:	f895 2030 	ldrb.w	r2, [r5, #48]	; 0x30
 8039852:	f884 2050 	strb.w	r2, [r4, #80]	; 0x50
        SubgRf.ModulationParams.Params.LoRa.Bandwidth = ( RadioLoRaBandwidths_t ) config->lora.Bandwidth;
 8039856:	f895 3031 	ldrb.w	r3, [r5, #49]	; 0x31
 803985a:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
        SubgRf.ModulationParams.Params.LoRa.CodingRate = ( RadioLoRaCodingRates_t ) config->lora.Coderate;
 803985e:	f895 3032 	ldrb.w	r3, [r5, #50]	; 0x32
 8039862:	f884 3052 	strb.w	r3, [r4, #82]	; 0x52
        switch( config->lora.LowDatarateOptimize )
 8039866:	f895 3033 	ldrb.w	r3, [r5, #51]	; 0x33
 803986a:	428b      	cmp	r3, r1
 803986c:	d002      	beq.n	8039874 <RadioSetRxGenericConfig+0x184>
 803986e:	2b02      	cmp	r3, #2
 8039870:	d003      	beq.n	803987a <RadioSetRxGenericConfig+0x18a>
 8039872:	b93b      	cbnz	r3, 8039884 <RadioSetRxGenericConfig+0x194>
              SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0;
 8039874:	f884 3053 	strb.w	r3, [r4, #83]	; 0x53
 8039878:	e004      	b.n	8039884 <RadioSetRxGenericConfig+0x194>
            if( ( config->lora.SpreadingFactor == RADIO_LORA_SF11 ) || ( config->lora.SpreadingFactor == RADIO_LORA_SF12 ) )
 803987a:	3a0b      	subs	r2, #11
 803987c:	2a01      	cmp	r2, #1
 803987e:	d827      	bhi.n	80398d0 <RadioSetRxGenericConfig+0x1e0>
              SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 1;
 8039880:	f884 1053 	strb.w	r1, [r4, #83]	; 0x53
        SubgRf.PacketParams.Params.LoRa.PreambleLength = config->lora.PreambleLen;
 8039884:	8eab      	ldrh	r3, [r5, #52]	; 0x34
 8039886:	83a3      	strh	r3, [r4, #28]
        SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t ) config->lora.LengthMode;
 8039888:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
 803988c:	77a3      	strb	r3, [r4, #30]
        SubgRf.PacketParams.Params.LoRa.CrcMode = ( RadioLoRaCrcModes_t ) config->lora.CrcMode;
 803988e:	8f2b      	ldrh	r3, [r5, #56]	; 0x38
 8039890:	8423      	strh	r3, [r4, #32]
        SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 8039892:	2601      	movs	r6, #1
 8039894:	73a6      	strb	r6, [r4, #14]
        SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength;
 8039896:	77e7      	strb	r7, [r4, #31]
        RadioStandby( );
 8039898:	f7ff fb8a 	bl	8038fb0 <RadioStandby>
        RadioSetModem( MODEM_LORA );
 803989c:	4630      	mov	r0, r6
 803989e:	f7ff fe0f 	bl	80394c0 <RadioSetModem>
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 80398a2:	4814      	ldr	r0, [pc, #80]	; (80398f4 <RadioSetRxGenericConfig+0x204>)
 80398a4:	f000 fdee 	bl	803a484 <SUBGRF_SetModulationParams>
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 80398a8:	4813      	ldr	r0, [pc, #76]	; (80398f8 <RadioSetRxGenericConfig+0x208>)
 80398aa:	f000 ff81 	bl	803a7b0 <SUBGRF_SetPacketParams>
        if( SubgRf.PacketParams.Params.LoRa.InvertIQ == LORA_IQ_INVERTED )
 80398ae:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
 80398b2:	42b3      	cmp	r3, r6
            SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) & ~( 1 << 2 ) );
 80398b4:	f240 7036 	movw	r0, #1846	; 0x736
        if( SubgRf.PacketParams.Params.LoRa.InvertIQ == LORA_IQ_INVERTED )
 80398b8:	d10c      	bne.n	80398d4 <RadioSetRxGenericConfig+0x1e4>
            SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) & ~( 1 << 2 ) );
 80398ba:	f000 fe4f 	bl	803a55c <SUBGRF_ReadRegister>
 80398be:	f000 01fb 	and.w	r1, r0, #251	; 0xfb
            SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) | ( 1 << 2 ) );
 80398c2:	f240 7036 	movw	r0, #1846	; 0x736
 80398c6:	f000 fd83 	bl	803a3d0 <SUBGRF_WriteRegister>
        SubgRf.RxTimeout = 0xFFFF;
 80398ca:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80398ce:	e79b      	b.n	8039808 <RadioSetRxGenericConfig+0x118>
              SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0;
 80398d0:	2300      	movs	r3, #0
 80398d2:	e7cf      	b.n	8039874 <RadioSetRxGenericConfig+0x184>
            SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) | ( 1 << 2 ) );
 80398d4:	f000 fe42 	bl	803a55c <SUBGRF_ReadRegister>
 80398d8:	f040 0104 	orr.w	r1, r0, #4
 80398dc:	b2c9      	uxtb	r1, r1
 80398de:	e7f0      	b.n	80398c2 <RadioSetRxGenericConfig+0x1d2>
            return -1;
 80398e0:	f04f 30ff 	mov.w	r0, #4294967295
 80398e4:	e71c      	b.n	8039720 <RadioSetRxGenericConfig+0x30>
 80398e6:	bf00      	nop
 80398e8:	20006324 	.word	0x20006324
 80398ec:	2000597c 	.word	0x2000597c
 80398f0:	20006394 	.word	0x20006394
 80398f4:	2000635c 	.word	0x2000635c
 80398f8:	20006332 	.word	0x20006332

080398fc <RadioSetTxConfig>:
{
 80398fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8039900:	b085      	sub	sp, #20
 8039902:	4682      	mov	sl, r0
 8039904:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 8039906:	f8bd b040 	ldrh.w	fp, [sp, #64]	; 0x40
 803990a:	f89d 7044 	ldrb.w	r7, [sp, #68]	; 0x44
 803990e:	f89d 9048 	ldrb.w	r9, [sp, #72]	; 0x48
 8039912:	9201      	str	r2, [sp, #4]
 8039914:	4688      	mov	r8, r1
 8039916:	461e      	mov	r6, r3
    RFW_DeInit(); /* ST_WORKAROUND: Switch Off FwPacketDecoding by default */
 8039918:	f001 f905 	bl	803ab26 <RFW_DeInit>
    switch( modem )
 803991c:	f1ba 0f01 	cmp.w	sl, #1
 8039920:	4c54      	ldr	r4, [pc, #336]	; (8039a74 <RadioSetTxConfig+0x178>)
 8039922:	d051      	beq.n	80399c8 <RadioSetTxConfig+0xcc>
 8039924:	f1ba 0f03 	cmp.w	sl, #3
 8039928:	f000 8094 	beq.w	8039a54 <RadioSetTxConfig+0x158>
 803992c:	f1ba 0f00 	cmp.w	sl, #0
 8039930:	d13e      	bne.n	80399b0 <RadioSetTxConfig+0xb4>
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_1;
 8039932:	220b      	movs	r2, #11
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8039934:	4630      	mov	r0, r6
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_1;
 8039936:	f884 2044 	strb.w	r2, [r4, #68]	; 0x44
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 803993a:	f884 a038 	strb.w	sl, [r4, #56]	; 0x38
            SubgRf.ModulationParams.Params.Gfsk.BitRate = datarate;
 803993e:	63e5      	str	r5, [r4, #60]	; 0x3c
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8039940:	f001 f892 	bl	803aa68 <SUBGRF_GetFskBandwidthRegValue>
            SubgRf.ModulationParams.Params.Gfsk.Fdev = fdev;
 8039944:	9b01      	ldr	r3, [sp, #4]
 8039946:	6423      	str	r3, [r4, #64]	; 0x40
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 8039948:	ea4f 03cb 	mov.w	r3, fp, lsl #3
            if( crcOn == true )
 803994c:	f1b9 0f00 	cmp.w	r9, #0
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 8039950:	8223      	strh	r3, [r4, #16]
            SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS;
 8039952:	f641 0304 	movw	r3, #6148	; 0x1804
 8039956:	8263      	strh	r3, [r4, #18]
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 8039958:	bf14      	ite	ne
 803995a:	23f2      	movne	r3, #242	; 0xf2
 803995c:	2301      	moveq	r3, #1
 803995e:	75e3      	strb	r3, [r4, #23]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( fixLen == true ) ? RADIO_PACKET_FIXED_LENGTH : RADIO_PACKET_VARIABLE_LENGTH;
 8039960:	f087 0701 	eor.w	r7, r7, #1
            SubgRf.PacketParams.Params.Gfsk.DcFree = RADIO_DC_FREEWHITENING;
 8039964:	2301      	movs	r3, #1
 8039966:	7623      	strb	r3, [r4, #24]
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8039968:	f884 0045 	strb.w	r0, [r4, #69]	; 0x45
            SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 803996c:	f884 a00e 	strb.w	sl, [r4, #14]
            SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF;
 8039970:	f884 a014 	strb.w	sl, [r4, #20]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( fixLen == true ) ? RADIO_PACKET_FIXED_LENGTH : RADIO_PACKET_VARIABLE_LENGTH;
 8039974:	7567      	strb	r7, [r4, #21]
            RadioStandby( );
 8039976:	f7ff fb1b 	bl	8038fb0 <RadioStandby>
            RadioSetModem( ( SubgRf.ModulationParams.PacketType == PACKET_TYPE_GFSK ) ? MODEM_FSK : MODEM_LORA );
 803997a:	f894 0038 	ldrb.w	r0, [r4, #56]	; 0x38
 803997e:	3800      	subs	r0, #0
 8039980:	bf18      	it	ne
 8039982:	2001      	movne	r0, #1
 8039984:	f7ff fd9c 	bl	80394c0 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8039988:	f104 0038 	add.w	r0, r4, #56	; 0x38
 803998c:	f000 fd7a 	bl	803a484 <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039990:	f104 000e 	add.w	r0, r4, #14
 8039994:	f000 ff0c 	bl	803a7b0 <SUBGRF_SetPacketParams>
            SUBGRF_SetSyncWord( ( uint8_t[] ){ 0xC1, 0x94, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00 } );
 8039998:	4a37      	ldr	r2, [pc, #220]	; (8039a78 <RadioSetTxConfig+0x17c>)
 803999a:	6810      	ldr	r0, [r2, #0]
 803999c:	6851      	ldr	r1, [r2, #4]
 803999e:	ab02      	add	r3, sp, #8
 80399a0:	c303      	stmia	r3!, {r0, r1}
 80399a2:	a802      	add	r0, sp, #8
 80399a4:	f000 fed6 	bl	803a754 <SUBGRF_SetSyncWord>
            SUBGRF_SetWhiteningSeed( 0x01FF );
 80399a8:	f240 10ff 	movw	r0, #511	; 0x1ff
 80399ac:	f000 fe44 	bl	803a638 <SUBGRF_SetWhiteningSeed>
    SubgRf.AntSwitchPaSelect = SUBGRF_SetRfTxPower( power );
 80399b0:	4640      	mov	r0, r8
 80399b2:	f001 f800 	bl	803a9b6 <SUBGRF_SetRfTxPower>
 80399b6:	f884 0056 	strb.w	r0, [r4, #86]	; 0x56
    RFW_SetAntSwitch( SubgRf.AntSwitchPaSelect ); /* ST_WORKAROUND: ?????? */
 80399ba:	f001 f8b9 	bl	803ab30 <RFW_SetAntSwitch>
    SubgRf.TxTimeout = timeout;
 80399be:	9b16      	ldr	r3, [sp, #88]	; 0x58
 80399c0:	6063      	str	r3, [r4, #4]
}
 80399c2:	b005      	add	sp, #20
 80399c4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            SubgRf.ModulationParams.Params.LoRa.Bandwidth =  Bandwidths[bandwidth];
 80399c8:	492c      	ldr	r1, [pc, #176]	; (8039a7c <RadioSetTxConfig+0x180>)
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_LORA;
 80399ca:	f884 a038 	strb.w	sl, [r4, #56]	; 0x38
            SubgRf.ModulationParams.Params.LoRa.Bandwidth =  Bandwidths[bandwidth];
 80399ce:	4431      	add	r1, r6
            SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t ) datarate;
 80399d0:	b2ea      	uxtb	r2, r5
            SubgRf.ModulationParams.Params.LoRa.Bandwidth =  Bandwidths[bandwidth];
 80399d2:	7909      	ldrb	r1, [r1, #4]
 80399d4:	f884 1051 	strb.w	r1, [r4, #81]	; 0x51
            SubgRf.ModulationParams.Params.LoRa.CodingRate= ( RadioLoRaCodingRates_t )coderate;
 80399d8:	f89d 103c 	ldrb.w	r1, [sp, #60]	; 0x3c
            SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t ) datarate;
 80399dc:	f884 2050 	strb.w	r2, [r4, #80]	; 0x50
            SubgRf.ModulationParams.Params.LoRa.CodingRate= ( RadioLoRaCodingRates_t )coderate;
 80399e0:	f884 1052 	strb.w	r1, [r4, #82]	; 0x52
            if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 80399e4:	bb56      	cbnz	r6, 8039a3c <RadioSetTxConfig+0x140>
 80399e6:	3d0b      	subs	r5, #11
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x00;
 80399e8:	2d01      	cmp	r5, #1
 80399ea:	bf8c      	ite	hi
 80399ec:	2500      	movhi	r5, #0
 80399ee:	2501      	movls	r5, #1
            SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 80399f0:	2101      	movs	r1, #1
            if( ( SubgRf.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF5 ) ||
 80399f2:	3a05      	subs	r2, #5
 80399f4:	428a      	cmp	r2, r1
 80399f6:	f884 5053 	strb.w	r5, [r4, #83]	; 0x53
            SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 80399fa:	73a1      	strb	r1, [r4, #14]
            if( ( SubgRf.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF5 ) ||
 80399fc:	d827      	bhi.n	8039a4e <RadioSetTxConfig+0x152>
                if( preambleLen < 12 )
 80399fe:	f1bb 0f0b 	cmp.w	fp, #11
 8039a02:	d824      	bhi.n	8039a4e <RadioSetTxConfig+0x152>
                    SubgRf.PacketParams.Params.LoRa.PreambleLength = 12;
 8039a04:	230c      	movs	r3, #12
 8039a06:	83a3      	strh	r3, [r4, #28]
            SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength;
 8039a08:	4b1d      	ldr	r3, [pc, #116]	; (8039a80 <RadioSetTxConfig+0x184>)
            SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t )fixLen;
 8039a0a:	77a7      	strb	r7, [r4, #30]
            SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength;
 8039a0c:	781b      	ldrb	r3, [r3, #0]
 8039a0e:	77e3      	strb	r3, [r4, #31]
            SubgRf.PacketParams.Params.LoRa.InvertIQ = ( RadioLoRaIQModes_t )iqInverted;
 8039a10:	f89d 3054 	ldrb.w	r3, [sp, #84]	; 0x54
 8039a14:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
            SubgRf.PacketParams.Params.LoRa.CrcMode = ( RadioLoRaCrcModes_t )crcOn;
 8039a18:	f884 9020 	strb.w	r9, [r4, #32]
            RadioStandby( );
 8039a1c:	f7ff fac8 	bl	8038fb0 <RadioStandby>
            RadioSetModem( ( SubgRf.ModulationParams.PacketType == PACKET_TYPE_GFSK ) ? MODEM_FSK : MODEM_LORA );
 8039a20:	f894 0038 	ldrb.w	r0, [r4, #56]	; 0x38
 8039a24:	3800      	subs	r0, #0
 8039a26:	bf18      	it	ne
 8039a28:	2001      	movne	r0, #1
 8039a2a:	f7ff fd49 	bl	80394c0 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8039a2e:	4815      	ldr	r0, [pc, #84]	; (8039a84 <RadioSetTxConfig+0x188>)
 8039a30:	f000 fd28 	bl	803a484 <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039a34:	4814      	ldr	r0, [pc, #80]	; (8039a88 <RadioSetTxConfig+0x18c>)
 8039a36:	f000 febb 	bl	803a7b0 <SUBGRF_SetPacketParams>
            break;
 8039a3a:	e7b9      	b.n	80399b0 <RadioSetTxConfig+0xb4>
            if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 8039a3c:	2e01      	cmp	r6, #1
 8039a3e:	d104      	bne.n	8039a4a <RadioSetTxConfig+0x14e>
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x00;
 8039a40:	f1a5 030c 	sub.w	r3, r5, #12
 8039a44:	425d      	negs	r5, r3
 8039a46:	415d      	adcs	r5, r3
 8039a48:	e7d2      	b.n	80399f0 <RadioSetTxConfig+0xf4>
 8039a4a:	2500      	movs	r5, #0
 8039a4c:	e7d0      	b.n	80399f0 <RadioSetTxConfig+0xf4>
                    SubgRf.PacketParams.Params.LoRa.PreambleLength = preambleLen;
 8039a4e:	f8a4 b01c 	strh.w	fp, [r4, #28]
 8039a52:	e7d9      	b.n	8039a08 <RadioSetTxConfig+0x10c>
            RadioSetModem(MODEM_SIGFOX_TX);
 8039a54:	4650      	mov	r0, sl
 8039a56:	f7ff fd33 	bl	80394c0 <RadioSetModem>
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_BPSK;
 8039a5a:	2302      	movs	r3, #2
 8039a5c:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8039a60:	f104 0038 	add.w	r0, r4, #56	; 0x38
            SubgRf.ModulationParams.Params.Bpsk.ModulationShaping = MOD_SHAPING_DBPSK;
 8039a64:	2316      	movs	r3, #22
            SubgRf.ModulationParams.Params.Bpsk.BitRate           = datarate;
 8039a66:	64a5      	str	r5, [r4, #72]	; 0x48
            SubgRf.ModulationParams.Params.Bpsk.ModulationShaping = MOD_SHAPING_DBPSK;
 8039a68:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8039a6c:	f000 fd0a 	bl	803a484 <SUBGRF_SetModulationParams>
            break;
 8039a70:	e79e      	b.n	80399b0 <RadioSetTxConfig+0xb4>
 8039a72:	bf00      	nop
 8039a74:	20006324 	.word	0x20006324
 8039a78:	0803bbc8 	.word	0x0803bbc8
 8039a7c:	0803bb94 	.word	0x0803bb94
 8039a80:	200035a0 	.word	0x200035a0
 8039a84:	2000635c 	.word	0x2000635c
 8039a88:	20006332 	.word	0x20006332

08039a8c <RadioSetRxConfig>:
{
 8039a8c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8039a90:	b087      	sub	sp, #28
    SubgRf.RxContinuous = rxContinuous;
 8039a92:	f8df b2d4 	ldr.w	fp, [pc, #724]	; 8039d68 <RadioSetRxConfig+0x2dc>
{
 8039a96:	9301      	str	r3, [sp, #4]
 8039a98:	4605      	mov	r5, r0
 8039a9a:	f89d 3054 	ldrb.w	r3, [sp, #84]	; 0x54
 8039a9e:	f89d 0050 	ldrb.w	r0, [sp, #80]	; 0x50
 8039aa2:	f8bd 8048 	ldrh.w	r8, [sp, #72]	; 0x48
 8039aa6:	f89d 904c 	ldrb.w	r9, [sp, #76]	; 0x4c
 8039aaa:	9003      	str	r0, [sp, #12]
 8039aac:	460f      	mov	r7, r1
 8039aae:	f89d 1064 	ldrb.w	r1, [sp, #100]	; 0x64
    SubgRf.RxContinuous = rxContinuous;
 8039ab2:	f88b 1001 	strb.w	r1, [fp, #1]
 8039ab6:	9102      	str	r1, [sp, #8]
{
 8039ab8:	f8bd 6044 	ldrh.w	r6, [sp, #68]	; 0x44
 8039abc:	9300      	str	r3, [sp, #0]
 8039abe:	4614      	mov	r4, r2
    RFW_DeInit(); /* ST_WORKAROUND: Switch Off FwPacketDecoding by default */
 8039ac0:	f001 f831 	bl	803ab26 <RFW_DeInit>
        symbTimeout = 0;
 8039ac4:	9902      	ldr	r1, [sp, #8]
        MaxPayloadLength = 0xFF;
 8039ac6:	9803      	ldr	r0, [sp, #12]
        symbTimeout = 0;
 8039ac8:	2900      	cmp	r1, #0
 8039aca:	bf18      	it	ne
 8039acc:	f04f 0800 	movne.w	r8, #0
    if( fixLen == true )
 8039ad0:	499f      	ldr	r1, [pc, #636]	; (8039d50 <RadioSetRxConfig+0x2c4>)
        MaxPayloadLength = 0xFF;
 8039ad2:	f1b9 0f00 	cmp.w	r9, #0
 8039ad6:	bf08      	it	eq
 8039ad8:	20ff      	moveq	r0, #255	; 0xff
    switch( modem )
 8039ada:	2d01      	cmp	r5, #1
 8039adc:	46da      	mov	sl, fp
 8039ade:	7008      	strb	r0, [r1, #0]
 8039ae0:	f000 80cc 	beq.w	8039c7c <RadioSetRxConfig+0x1f0>
 8039ae4:	2d04      	cmp	r5, #4
 8039ae6:	d04c      	beq.n	8039b82 <RadioSetRxConfig+0xf6>
 8039ae8:	2d00      	cmp	r5, #0
 8039aea:	f040 80c4 	bne.w	8039c76 <RadioSetRxConfig+0x1ea>
            SUBGRF_SetStopRxTimerOnPreambleDetect( false );
 8039aee:	4628      	mov	r0, r5
 8039af0:	f000 fb62 	bl	803a1b8 <SUBGRF_SetStopRxTimerOnPreambleDetect>
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_1;
 8039af4:	220b      	movs	r2, #11
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8039af6:	4638      	mov	r0, r7
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_1;
 8039af8:	f88b 2044 	strb.w	r2, [fp, #68]	; 0x44
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 8039afc:	f88b 5038 	strb.w	r5, [fp, #56]	; 0x38
            SubgRf.ModulationParams.Params.Gfsk.BitRate = datarate;
 8039b00:	f8cb 403c 	str.w	r4, [fp, #60]	; 0x3c
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8039b04:	f000 ffb0 	bl	803aa68 <SUBGRF_GetFskBandwidthRegValue>
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 8039b08:	9b00      	ldr	r3, [sp, #0]
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength;
 8039b0a:	4991      	ldr	r1, [pc, #580]	; (8039d50 <RadioSetRxConfig+0x2c4>)
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8039b0c:	f88b 0045 	strb.w	r0, [fp, #69]	; 0x45
            SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS;
 8039b10:	f641 0204 	movw	r2, #6148	; 0x1804
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 8039b14:	2b00      	cmp	r3, #0
            SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS;
 8039b16:	f8ab 2012 	strh.w	r2, [fp, #18]
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength;
 8039b1a:	780a      	ldrb	r2, [r1, #0]
 8039b1c:	f88b 2016 	strb.w	r2, [fp, #22]
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 8039b20:	bf14      	ite	ne
 8039b22:	22f2      	movne	r2, #242	; 0xf2
 8039b24:	2201      	moveq	r2, #1
 8039b26:	f88b 2017 	strb.w	r2, [fp, #23]
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 8039b2a:	00f6      	lsls	r6, r6, #3
            SubgRf.PacketParams.Params.Gfsk.DcFree = RADIO_DC_FREEWHITENING;
 8039b2c:	2201      	movs	r2, #1
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( fixLen == true ) ? RADIO_PACKET_FIXED_LENGTH : RADIO_PACKET_VARIABLE_LENGTH;
 8039b2e:	f089 0901 	eor.w	r9, r9, #1
            SubgRf.PacketParams.Params.Gfsk.DcFree = RADIO_DC_FREEWHITENING;
 8039b32:	f88b 2018 	strb.w	r2, [fp, #24]
            SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 8039b36:	f88b 500e 	strb.w	r5, [fp, #14]
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 8039b3a:	f8ab 6010 	strh.w	r6, [fp, #16]
            SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF;
 8039b3e:	f88b 5014 	strb.w	r5, [fp, #20]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( fixLen == true ) ? RADIO_PACKET_FIXED_LENGTH : RADIO_PACKET_VARIABLE_LENGTH;
 8039b42:	f88b 9015 	strb.w	r9, [fp, #21]
            RadioStandby( );
 8039b46:	f7ff fa33 	bl	8038fb0 <RadioStandby>
            RadioSetModem( ( SubgRf.ModulationParams.PacketType == PACKET_TYPE_GFSK ) ? MODEM_FSK : MODEM_LORA );
 8039b4a:	f89b 0038 	ldrb.w	r0, [fp, #56]	; 0x38
 8039b4e:	3800      	subs	r0, #0
 8039b50:	bf18      	it	ne
 8039b52:	2001      	movne	r0, #1
 8039b54:	f7ff fcb4 	bl	80394c0 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8039b58:	f10b 0038 	add.w	r0, fp, #56	; 0x38
 8039b5c:	f000 fc92 	bl	803a484 <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039b60:	f10b 000e 	add.w	r0, fp, #14
 8039b64:	f000 fe24 	bl	803a7b0 <SUBGRF_SetPacketParams>
            SUBGRF_SetSyncWord( ( uint8_t[] ){ 0xC1, 0x94, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00 } );
 8039b68:	497a      	ldr	r1, [pc, #488]	; (8039d54 <RadioSetRxConfig+0x2c8>)
 8039b6a:	6808      	ldr	r0, [r1, #0]
 8039b6c:	6849      	ldr	r1, [r1, #4]
 8039b6e:	aa04      	add	r2, sp, #16
 8039b70:	c203      	stmia	r2!, {r0, r1}
 8039b72:	a804      	add	r0, sp, #16
 8039b74:	f000 fdee 	bl	803a754 <SUBGRF_SetSyncWord>
            SUBGRF_SetWhiteningSeed( 0x01FF );
 8039b78:	f240 10ff 	movw	r0, #511	; 0x1ff
 8039b7c:	f000 fd5c 	bl	803a638 <SUBGRF_SetWhiteningSeed>
 8039b80:	e071      	b.n	8039c66 <RadioSetRxConfig+0x1da>
            SUBGRF_SetStopRxTimerOnPreambleDetect( true );
 8039b82:	2001      	movs	r0, #1
 8039b84:	f000 fb18 	bl	803a1b8 <SUBGRF_SetStopRxTimerOnPreambleDetect>
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_05;
 8039b88:	2209      	movs	r2, #9
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 8039b8a:	f04f 0900 	mov.w	r9, #0
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_05;
 8039b8e:	f88b 2044 	strb.w	r2, [fp, #68]	; 0x44
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8039b92:	4638      	mov	r0, r7
            SubgRf.ModulationParams.Params.Gfsk.Fdev = 800;
 8039b94:	f44f 7248 	mov.w	r2, #800	; 0x320
 8039b98:	f8cb 2040 	str.w	r2, [fp, #64]	; 0x40
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 8039b9c:	f88b 9038 	strb.w	r9, [fp, #56]	; 0x38
            SubgRf.ModulationParams.Params.Gfsk.BitRate = datarate;
 8039ba0:	f8cb 403c 	str.w	r4, [fp, #60]	; 0x3c
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8039ba4:	f000 ff60 	bl	803aa68 <SUBGRF_GetFskBandwidthRegValue>
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength;
 8039ba8:	4969      	ldr	r1, [pc, #420]	; (8039d50 <RadioSetRxConfig+0x2c4>)
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8039baa:	f88b 0045 	strb.w	r0, [fp, #69]	; 0x45
            SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_OFF;
 8039bae:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8039bb2:	f8ab 2012 	strh.w	r2, [fp, #18]
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength;
 8039bb6:	780a      	ldrb	r2, [r1, #0]
 8039bb8:	f88b 2016 	strb.w	r2, [fp, #22]
            RadioSetModem( MODEM_SIGFOX_RX );
 8039bbc:	4628      	mov	r0, r5
            SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 8039bbe:	2201      	movs	r2, #1
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 8039bc0:	00f6      	lsls	r6, r6, #3
            SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 8039bc2:	f88b 2017 	strb.w	r2, [fp, #23]
            SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 8039bc6:	f88b 900e 	strb.w	r9, [fp, #14]
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 8039bca:	f8ab 6010 	strh.w	r6, [fp, #16]
            SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF;
 8039bce:	f8ab 9014 	strh.w	r9, [fp, #20]
            SubgRf.PacketParams.Params.Gfsk.DcFree = RADIO_DC_FREE_OFF;
 8039bd2:	f88b 9018 	strb.w	r9, [fp, #24]
            RadioSetModem( MODEM_SIGFOX_RX );
 8039bd6:	f7ff fc73 	bl	80394c0 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8039bda:	f10b 0038 	add.w	r0, fp, #56	; 0x38
 8039bde:	f000 fc51 	bl	803a484 <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039be2:	f10b 000e 	add.w	r0, fp, #14
 8039be6:	f000 fde3 	bl	803a7b0 <SUBGRF_SetPacketParams>
            SUBGRF_SetSyncWord( ( uint8_t[] ){0xB2, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } );
 8039bea:	495b      	ldr	r1, [pc, #364]	; (8039d58 <RadioSetRxConfig+0x2cc>)
 8039bec:	6808      	ldr	r0, [r1, #0]
 8039bee:	6849      	ldr	r1, [r1, #4]
 8039bf0:	aa04      	add	r2, sp, #16
 8039bf2:	c203      	stmia	r2!, {r0, r1}
 8039bf4:	a804      	add	r0, sp, #16
 8039bf6:	f000 fdad 	bl	803a754 <SUBGRF_SetSyncWord>
            SUBGRF_SetWhiteningSeed( 0x01FF );
 8039bfa:	f240 10ff 	movw	r0, #511	; 0x1ff
 8039bfe:	f000 fd1b 	bl	803a638 <SUBGRF_SetWhiteningSeed>
    return SUBGRF_ReadRegister(addr);
 8039c02:	f640 00b8 	movw	r0, #2232	; 0x8b8
 8039c06:	f000 fca9 	bl	803a55c <SUBGRF_ReadRegister>
    SUBGRF_WriteRegister(addr, data );
 8039c0a:	f000 01ef 	and.w	r1, r0, #239	; 0xef
 8039c0e:	f640 00b8 	movw	r0, #2232	; 0x8b8
 8039c12:	f000 fbdd 	bl	803a3d0 <SUBGRF_WriteRegister>
 8039c16:	4629      	mov	r1, r5
 8039c18:	f640 00b9 	movw	r0, #2233	; 0x8b9
 8039c1c:	f000 fbd8 	bl	803a3d0 <SUBGRF_WriteRegister>
    return SUBGRF_ReadRegister(addr);
 8039c20:	f640 009b 	movw	r0, #2203	; 0x89b
 8039c24:	f000 fc9a 	bl	803a55c <SUBGRF_ReadRegister>
            RadioWrite(0x89b, (modReg| (0x1<<3) ) );
 8039c28:	f000 01e3 	and.w	r1, r0, #227	; 0xe3
    SUBGRF_WriteRegister(addr, data );
 8039c2c:	f041 0108 	orr.w	r1, r1, #8
 8039c30:	f640 009b 	movw	r0, #2203	; 0x89b
 8039c34:	f000 fbcc 	bl	803a3d0 <SUBGRF_WriteRegister>
    return SUBGRF_ReadRegister(addr);
 8039c38:	f240 60d1 	movw	r0, #1745	; 0x6d1
 8039c3c:	f000 fc8e 	bl	803a55c <SUBGRF_ReadRegister>
            RadioWrite(0x6d1, (modReg| (0x3<<3) ));
 8039c40:	f040 0118 	orr.w	r1, r0, #24
    SUBGRF_WriteRegister(addr, data );
 8039c44:	b2c9      	uxtb	r1, r1
 8039c46:	f240 60d1 	movw	r0, #1745	; 0x6d1
 8039c4a:	f000 fbc1 	bl	803a3d0 <SUBGRF_WriteRegister>
    return SUBGRF_ReadRegister(addr);
 8039c4e:	f240 60ac 	movw	r0, #1708	; 0x6ac
 8039c52:	f000 fc83 	bl	803a55c <SUBGRF_ReadRegister>
            RadioWrite(0x6ac, (modReg| (0x5<<4) ));
 8039c56:	f000 018f 	and.w	r1, r0, #143	; 0x8f
    SUBGRF_WriteRegister(addr, data );
 8039c5a:	f041 0150 	orr.w	r1, r1, #80	; 0x50
 8039c5e:	f240 60ac 	movw	r0, #1708	; 0x6ac
 8039c62:	f000 fbb5 	bl	803a3d0 <SUBGRF_WriteRegister>
            SubgRf.RxTimeout = ( uint32_t )(( symbTimeout * 8 * 1000 ) /datarate);
 8039c66:	f44f 52fa 	mov.w	r2, #8000	; 0x1f40
 8039c6a:	fb02 f808 	mul.w	r8, r2, r8
 8039c6e:	fbb8 f4f4 	udiv	r4, r8, r4
 8039c72:	f8cb 4008 	str.w	r4, [fp, #8]
}
 8039c76:	b007      	add	sp, #28
 8039c78:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            SUBGRF_SetStopRxTimerOnPreambleDetect( false );
 8039c7c:	2000      	movs	r0, #0
 8039c7e:	f000 fa9b 	bl	803a1b8 <SUBGRF_SetStopRxTimerOnPreambleDetect>
            SubgRf.ModulationParams.Params.LoRa.Bandwidth = Bandwidths[bandwidth];
 8039c82:	4936      	ldr	r1, [pc, #216]	; (8039d5c <RadioSetRxConfig+0x2d0>)
            SubgRf.ModulationParams.Params.LoRa.CodingRate = ( RadioLoRaCodingRates_t )coderate;
 8039c84:	9a01      	ldr	r2, [sp, #4]
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_LORA;
 8039c86:	f88b 5038 	strb.w	r5, [fp, #56]	; 0x38
            SubgRf.ModulationParams.Params.LoRa.Bandwidth = Bandwidths[bandwidth];
 8039c8a:	4439      	add	r1, r7
            SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t )datarate;
 8039c8c:	b2e3      	uxtb	r3, r4
            SubgRf.ModulationParams.Params.LoRa.Bandwidth = Bandwidths[bandwidth];
 8039c8e:	7909      	ldrb	r1, [r1, #4]
            SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t )datarate;
 8039c90:	f88b 3050 	strb.w	r3, [fp, #80]	; 0x50
            SubgRf.ModulationParams.Params.LoRa.Bandwidth = Bandwidths[bandwidth];
 8039c94:	f88b 1051 	strb.w	r1, [fp, #81]	; 0x51
            SubgRf.ModulationParams.Params.LoRa.CodingRate = ( RadioLoRaCodingRates_t )coderate;
 8039c98:	f88b 2052 	strb.w	r2, [fp, #82]	; 0x52
            if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 8039c9c:	2f00      	cmp	r7, #0
 8039c9e:	d144      	bne.n	8039d2a <RadioSetRxConfig+0x29e>
 8039ca0:	3c0b      	subs	r4, #11
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x00;
 8039ca2:	2c01      	cmp	r4, #1
 8039ca4:	bf8c      	ite	hi
 8039ca6:	2400      	movhi	r4, #0
 8039ca8:	2401      	movls	r4, #1
            SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 8039caa:	2101      	movs	r1, #1
            if( ( SubgRf.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF5 ) ||
 8039cac:	3b05      	subs	r3, #5
 8039cae:	428b      	cmp	r3, r1
 8039cb0:	f88a 4053 	strb.w	r4, [sl, #83]	; 0x53
            SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 8039cb4:	f88a 100e 	strb.w	r1, [sl, #14]
            if( ( SubgRf.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF5 ) ||
 8039cb8:	d840      	bhi.n	8039d3c <RadioSetRxConfig+0x2b0>
                if( preambleLen < 12 )
 8039cba:	2e0b      	cmp	r6, #11
 8039cbc:	d83e      	bhi.n	8039d3c <RadioSetRxConfig+0x2b0>
                    SubgRf.PacketParams.Params.LoRa.PreambleLength = 12;
 8039cbe:	230c      	movs	r3, #12
 8039cc0:	f8aa 301c 	strh.w	r3, [sl, #28]
            SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength;
 8039cc4:	4b22      	ldr	r3, [pc, #136]	; (8039d50 <RadioSetRxConfig+0x2c4>)
            SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t )fixLen;
 8039cc6:	f88a 901e 	strb.w	r9, [sl, #30]
            SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength;
 8039cca:	781b      	ldrb	r3, [r3, #0]
 8039ccc:	f88a 301f 	strb.w	r3, [sl, #31]
            SubgRf.PacketParams.Params.LoRa.CrcMode = ( RadioLoRaCrcModes_t )crcOn;
 8039cd0:	9b00      	ldr	r3, [sp, #0]
 8039cd2:	f88a 3020 	strb.w	r3, [sl, #32]
            SubgRf.PacketParams.Params.LoRa.InvertIQ = ( RadioLoRaIQModes_t )iqInverted;
 8039cd6:	f89d 3060 	ldrb.w	r3, [sp, #96]	; 0x60
 8039cda:	f88a 3021 	strb.w	r3, [sl, #33]	; 0x21
            RadioStandby( );
 8039cde:	f7ff f967 	bl	8038fb0 <RadioStandby>
            RadioSetModem( ( SubgRf.ModulationParams.PacketType == PACKET_TYPE_GFSK ) ? MODEM_FSK : MODEM_LORA );
 8039ce2:	f89a 0038 	ldrb.w	r0, [sl, #56]	; 0x38
 8039ce6:	3800      	subs	r0, #0
 8039ce8:	bf18      	it	ne
 8039cea:	2001      	movne	r0, #1
 8039cec:	f7ff fbe8 	bl	80394c0 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8039cf0:	481b      	ldr	r0, [pc, #108]	; (8039d60 <RadioSetRxConfig+0x2d4>)
 8039cf2:	f000 fbc7 	bl	803a484 <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039cf6:	481b      	ldr	r0, [pc, #108]	; (8039d64 <RadioSetRxConfig+0x2d8>)
 8039cf8:	f000 fd5a 	bl	803a7b0 <SUBGRF_SetPacketParams>
            SUBGRF_SetLoRaSymbNumTimeout( symbTimeout );
 8039cfc:	fa5f f088 	uxtb.w	r0, r8
 8039d00:	f000 fb92 	bl	803a428 <SUBGRF_SetLoRaSymbNumTimeout>
            if( SubgRf.PacketParams.Params.LoRa.InvertIQ == LORA_IQ_INVERTED )
 8039d04:	f89a 3021 	ldrb.w	r3, [sl, #33]	; 0x21
 8039d08:	2b01      	cmp	r3, #1
                SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) & ~( 1 << 2 ) );
 8039d0a:	f240 7036 	movw	r0, #1846	; 0x736
            if( SubgRf.PacketParams.Params.LoRa.InvertIQ == LORA_IQ_INVERTED )
 8039d0e:	d118      	bne.n	8039d42 <RadioSetRxConfig+0x2b6>
                SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) & ~( 1 << 2 ) );
 8039d10:	f000 fc24 	bl	803a55c <SUBGRF_ReadRegister>
 8039d14:	f000 01fb 	and.w	r1, r0, #251	; 0xfb
                SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) | ( 1 << 2 ) );
 8039d18:	f240 7036 	movw	r0, #1846	; 0x736
 8039d1c:	f000 fb58 	bl	803a3d0 <SUBGRF_WriteRegister>
            SubgRf.RxTimeout = 0xFFFF;
 8039d20:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8039d24:	f8ca 3008 	str.w	r3, [sl, #8]
}
 8039d28:	e7a5      	b.n	8039c76 <RadioSetRxConfig+0x1ea>
            if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 8039d2a:	2f01      	cmp	r7, #1
 8039d2c:	d104      	bne.n	8039d38 <RadioSetRxConfig+0x2ac>
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x00;
 8039d2e:	f1a4 020c 	sub.w	r2, r4, #12
 8039d32:	4254      	negs	r4, r2
 8039d34:	4154      	adcs	r4, r2
 8039d36:	e7b8      	b.n	8039caa <RadioSetRxConfig+0x21e>
 8039d38:	2400      	movs	r4, #0
 8039d3a:	e7b6      	b.n	8039caa <RadioSetRxConfig+0x21e>
                    SubgRf.PacketParams.Params.LoRa.PreambleLength = preambleLen;
 8039d3c:	f8aa 601c 	strh.w	r6, [sl, #28]
 8039d40:	e7c0      	b.n	8039cc4 <RadioSetRxConfig+0x238>
                SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) | ( 1 << 2 ) );
 8039d42:	f000 fc0b 	bl	803a55c <SUBGRF_ReadRegister>
 8039d46:	f040 0104 	orr.w	r1, r0, #4
 8039d4a:	b2c9      	uxtb	r1, r1
 8039d4c:	e7e4      	b.n	8039d18 <RadioSetRxConfig+0x28c>
 8039d4e:	bf00      	nop
 8039d50:	200035a0 	.word	0x200035a0
 8039d54:	0803bbc8 	.word	0x0803bbc8
 8039d58:	0803bbd0 	.word	0x0803bbd0
 8039d5c:	0803bb94 	.word	0x0803bb94
 8039d60:	2000635c 	.word	0x2000635c
 8039d64:	20006332 	.word	0x20006332
 8039d68:	20006324 	.word	0x20006324

08039d6c <RadioRandom>:
{
 8039d6c:	b508      	push	{r3, lr}
    RadioSetModem( MODEM_LORA );
 8039d6e:	2001      	movs	r0, #1
 8039d70:	f7ff fba6 	bl	80394c0 <RadioSetModem>
    SUBGRF_SetDioIrqParams( IRQ_RADIO_NONE, IRQ_RADIO_NONE, IRQ_RADIO_NONE, IRQ_RADIO_NONE );
 8039d74:	2300      	movs	r3, #0
 8039d76:	461a      	mov	r2, r3
 8039d78:	4619      	mov	r1, r3
 8039d7a:	4618      	mov	r0, r3
 8039d7c:	f000 fa8c 	bl	803a298 <SUBGRF_SetDioIrqParams>
}
 8039d80:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    rnd = SUBGRF_GetRandom();
 8039d84:	f000 bd86 	b.w	803a894 <SUBGRF_GetRandom>

08039d88 <RadioIsChannelFree>:
{
 8039d88:	b5f0      	push	{r4, r5, r6, r7, lr}
 8039d8a:	b08b      	sub	sp, #44	; 0x2c
 8039d8c:	460d      	mov	r5, r1
 8039d8e:	4604      	mov	r4, r0
 8039d90:	4617      	mov	r7, r2
 8039d92:	461e      	mov	r6, r3
    RadioStandby( );
 8039d94:	f7ff f90c 	bl	8038fb0 <RadioStandby>
    RadioSetModem( MODEM_FSK );
 8039d98:	2000      	movs	r0, #0
 8039d9a:	f7ff fb91 	bl	80394c0 <RadioSetModem>
    SUBGRF_SetRfFrequency( freq );
 8039d9e:	4620      	mov	r0, r4
 8039da0:	f000 faa4 	bl	803a2ec <SUBGRF_SetRfFrequency>
    RadioSetRxConfig( MODEM_FSK, rxBandwidth, 600, 0, rxBandwidth, 3, 0, false,
 8039da4:	2400      	movs	r4, #0
 8039da6:	2301      	movs	r3, #1
 8039da8:	e9cd 4308 	strd	r4, r3, [sp, #32]
 8039dac:	2303      	movs	r3, #3
 8039dae:	f44f 7216 	mov.w	r2, #600	; 0x258
 8039db2:	4629      	mov	r1, r5
 8039db4:	4620      	mov	r0, r4
 8039db6:	e9cd 4406 	strd	r4, r4, [sp, #24]
 8039dba:	e9cd 4404 	strd	r4, r4, [sp, #16]
 8039dbe:	e9cd 4402 	strd	r4, r4, [sp, #8]
 8039dc2:	e9cd 5300 	strd	r5, r3, [sp]
 8039dc6:	4623      	mov	r3, r4
 8039dc8:	f7ff fe60 	bl	8039a8c <RadioSetRxConfig>
    RadioRx( 0 );
 8039dcc:	4620      	mov	r0, r4
 8039dce:	f7ff fb2b 	bl	8039428 <RadioRx>
    RADIO_DELAY_MS( RadioGetWakeupTime( ) );
 8039dd2:	f7ff fa27 	bl	8039224 <RadioGetWakeupTime>
 8039dd6:	f7f2 fc37 	bl	802c648 <HAL_Delay>
    carrierSenseTime = TimerGetCurrentTime( );
 8039dda:	f001 fa41 	bl	803b260 <UTIL_TIMER_GetCurrentTime>
 8039dde:	4604      	mov	r4, r0
    while( TimerGetElapsedTime( carrierSenseTime ) < maxCarrierSenseTime )
 8039de0:	4620      	mov	r0, r4
 8039de2:	f001 fa47 	bl	803b274 <UTIL_TIMER_GetElapsedTime>
 8039de6:	42b0      	cmp	r0, r6
 8039de8:	d305      	bcc.n	8039df6 <RadioIsChannelFree+0x6e>
    bool status = true;
 8039dea:	2401      	movs	r4, #1
    RadioStandby( );
 8039dec:	f7ff f8e0 	bl	8038fb0 <RadioStandby>
}
 8039df0:	4620      	mov	r0, r4
 8039df2:	b00b      	add	sp, #44	; 0x2c
 8039df4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return SUBGRF_GetRssiInst( );
 8039df6:	f000 faa4 	bl	803a342 <SUBGRF_GetRssiInst>
        if( rssi > rssiThresh )
 8039dfa:	b200      	sxth	r0, r0
 8039dfc:	4287      	cmp	r7, r0
 8039dfe:	daef      	bge.n	8039de0 <RadioIsChannelFree+0x58>
            status = false;
 8039e00:	2400      	movs	r4, #0
 8039e02:	e7f3      	b.n	8039dec <RadioIsChannelFree+0x64>

08039e04 <RadioInit>:
    RadioEvents = events;
 8039e04:	4b1e      	ldr	r3, [pc, #120]	; (8039e80 <RadioInit+0x7c>)
{
 8039e06:	b573      	push	{r0, r1, r4, r5, r6, lr}
    RadioEvents = events;
 8039e08:	6018      	str	r0, [r3, #0]
    SubgRf.RxContinuous = false;
 8039e0a:	4b1e      	ldr	r3, [pc, #120]	; (8039e84 <RadioInit+0x80>)
    SUBGRF_Init( RadioOnDioIrq );
 8039e0c:	481e      	ldr	r0, [pc, #120]	; (8039e88 <RadioInit+0x84>)
    TimerInit( &TxTimeoutTimer, RadioOnTxTimeoutIrq );
 8039e0e:	4e1f      	ldr	r6, [pc, #124]	; (8039e8c <RadioInit+0x88>)
    TimerInit( &RxTimeoutTimer, RadioOnRxTimeoutIrq );
 8039e10:	4d1f      	ldr	r5, [pc, #124]	; (8039e90 <RadioInit+0x8c>)
    SubgRf.RxContinuous = false;
 8039e12:	2400      	movs	r4, #0
    SubgRf.RxTimeout = 0;
 8039e14:	e9c3 4401 	strd	r4, r4, [r3, #4]
    SubgRf.RxContinuous = false;
 8039e18:	705c      	strb	r4, [r3, #1]
    SUBGRF_Init( RadioOnDioIrq );
 8039e1a:	f000 fbc3 	bl	803a5a4 <SUBGRF_Init>
    RadioSetPublicNetwork( false );
 8039e1e:	4620      	mov	r0, r4
 8039e20:	f7ff fb30 	bl	8039484 <RadioSetPublicNetwork>
    SUBGRF_SetRegulatorMode(  );
 8039e24:	f000 f9d4 	bl	803a1d0 <SUBGRF_SetRegulatorMode>
    SUBGRF_SetBufferBaseAddress( 0x00, 0x00 );
 8039e28:	4621      	mov	r1, r4
 8039e2a:	4620      	mov	r0, r4
 8039e2c:	f000 fa7c 	bl	803a328 <SUBGRF_SetBufferBaseAddress>
    SUBGRF_SetTxParams(RFO_LP, 0, RADIO_RAMP_200_US);
 8039e30:	4621      	mov	r1, r4
 8039e32:	2204      	movs	r2, #4
 8039e34:	2001      	movs	r0, #1
 8039e36:	f000 fc1b 	bl	803a670 <SUBGRF_SetTxParams>
    SUBGRF_SetDioIrqParams( IRQ_RADIO_ALL, IRQ_RADIO_ALL, IRQ_RADIO_NONE, IRQ_RADIO_NONE );
 8039e3a:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8039e3e:	4623      	mov	r3, r4
 8039e40:	4622      	mov	r2, r4
 8039e42:	4608      	mov	r0, r1
 8039e44:	f000 fa28 	bl	803a298 <SUBGRF_SetDioIrqParams>
    RadioSleep();
 8039e48:	f7ff fa2c 	bl	80392a4 <RadioSleep>
    TimerInit( &TxTimeoutTimer, RadioOnTxTimeoutIrq );
 8039e4c:	4622      	mov	r2, r4
 8039e4e:	4b11      	ldr	r3, [pc, #68]	; (8039e94 <RadioInit+0x90>)
 8039e50:	9400      	str	r4, [sp, #0]
 8039e52:	f04f 31ff 	mov.w	r1, #4294967295
 8039e56:	4630      	mov	r0, r6
 8039e58:	f001 f9e8 	bl	803b22c <UTIL_TIMER_Create>
    TimerInit( &RxTimeoutTimer, RadioOnRxTimeoutIrq );
 8039e5c:	4b0e      	ldr	r3, [pc, #56]	; (8039e98 <RadioInit+0x94>)
 8039e5e:	9400      	str	r4, [sp, #0]
 8039e60:	4622      	mov	r2, r4
 8039e62:	f04f 31ff 	mov.w	r1, #4294967295
 8039e66:	4628      	mov	r0, r5
 8039e68:	f001 f9e0 	bl	803b22c <UTIL_TIMER_Create>
    TimerStop( &TxTimeoutTimer );
 8039e6c:	4630      	mov	r0, r6
 8039e6e:	f001 fa3b 	bl	803b2e8 <UTIL_TIMER_Stop>
    TimerStop( &RxTimeoutTimer );
 8039e72:	4628      	mov	r0, r5
}
 8039e74:	b002      	add	sp, #8
 8039e76:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    TimerStop( &RxTimeoutTimer );
 8039e7a:	f001 ba35 	b.w	803b2e8 <UTIL_TIMER_Stop>
 8039e7e:	bf00      	nop
 8039e80:	2000597c 	.word	0x2000597c
 8039e84:	20006324 	.word	0x20006324
 8039e88:	08039215 	.word	0x08039215
 8039e8c:	2000637c 	.word	0x2000637c
 8039e90:	20006394 	.word	0x20006394
 8039e94:	08038f49 	.word	0x08038f49
 8039e98:	08038f5d 	.word	0x08038f5d

08039e9c <RadioSend>:
{
 8039e9c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    SUBGRF_SetDioIrqParams( IRQ_TX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_TX_DBG,
 8039e9e:	2300      	movs	r3, #0
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_TX);
 8039ea0:	4d66      	ldr	r5, [pc, #408]	; (803a03c <RadioSend+0x1a0>)
{
 8039ea2:	460c      	mov	r4, r1
    SUBGRF_SetDioIrqParams( IRQ_TX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_TX_DBG,
 8039ea4:	f240 2101 	movw	r1, #513	; 0x201
 8039ea8:	461a      	mov	r2, r3
{
 8039eaa:	4606      	mov	r6, r0
    SUBGRF_SetDioIrqParams( IRQ_TX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_TX_DBG,
 8039eac:	4608      	mov	r0, r1
 8039eae:	f000 f9f3 	bl	803a298 <SUBGRF_SetDioIrqParams>
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_TX);
 8039eb2:	f895 0056 	ldrb.w	r0, [r5, #86]	; 0x56
 8039eb6:	2101      	movs	r1, #1
 8039eb8:	f000 fd67 	bl	803a98a <SUBGRF_SetSwitch>
    if((SubgRf.Modem==MODEM_LORA) && (SubgRf.ModulationParams.Params.LoRa.Bandwidth == LORA_BW_500 ))
 8039ebc:	782b      	ldrb	r3, [r5, #0]
 8039ebe:	2b01      	cmp	r3, #1
        SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) & ~( 1 << 2 ) );
 8039ec0:	f640 0089 	movw	r0, #2185	; 0x889
    if((SubgRf.Modem==MODEM_LORA) && (SubgRf.ModulationParams.Params.LoRa.Bandwidth == LORA_BW_500 ))
 8039ec4:	d112      	bne.n	8039eec <RadioSend+0x50>
 8039ec6:	f895 3051 	ldrb.w	r3, [r5, #81]	; 0x51
 8039eca:	2b06      	cmp	r3, #6
 8039ecc:	d10e      	bne.n	8039eec <RadioSend+0x50>
        SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) & ~( 1 << 2 ) );
 8039ece:	f000 fb45 	bl	803a55c <SUBGRF_ReadRegister>
 8039ed2:	f000 01fb 	and.w	r1, r0, #251	; 0xfb
        SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) | ( 1 << 2 ) );
 8039ed6:	f640 0089 	movw	r0, #2185	; 0x889
 8039eda:	f000 fa79 	bl	803a3d0 <SUBGRF_WriteRegister>
    switch(SubgRf.Modem)
 8039ede:	782b      	ldrb	r3, [r5, #0]
 8039ee0:	2b03      	cmp	r3, #3
 8039ee2:	d86f      	bhi.n	8039fc4 <RadioSend+0x128>
 8039ee4:	e8df f003 	tbb	[pc, r3]
 8039ee8:	08804e55 	.word	0x08804e55
        SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) | ( 1 << 2 ) );
 8039eec:	f000 fb36 	bl	803a55c <SUBGRF_ReadRegister>
 8039ef0:	f040 0104 	orr.w	r1, r0, #4
 8039ef4:	b2c9      	uxtb	r1, r1
 8039ef6:	e7ee      	b.n	8039ed6 <RadioSend+0x3a>
 8039ef8:	4a51      	ldr	r2, [pc, #324]	; (803a040 <RadioSend+0x1a4>)
 8039efa:	1e73      	subs	r3, r6, #1
 8039efc:	4610      	mov	r0, r2
    for (i = 0; i < size; i++)
 8039efe:	f1c6 0701 	rsb	r7, r6, #1
        outBuffer[i] = 0;
 8039f02:	f04f 0c00 	mov.w	ip, #0
    for (i = 0; i < size; i++)
 8039f06:	18f9      	adds	r1, r7, r3
 8039f08:	428c      	cmp	r4, r1
 8039f0a:	dc71      	bgt.n	8039ff0 <RadioSend+0x154>
    for (i = 0; i < (size * 8); i++)
 8039f0c:	2300      	movs	r3, #0
 8039f0e:	00e7      	lsls	r7, r4, #3
    uint8_t prevInt = 0;
 8039f10:	4619      	mov	r1, r3
    for (i = 0; i < (size * 8); i++)
 8039f12:	42bb      	cmp	r3, r7
 8039f14:	d173      	bne.n	8039ffe <RadioSend+0x162>
    outBuffer[size] = ( prevInt << 7 ) | ( prevInt << 6 ) | ( ( ( !prevInt ) & 0x01 ) << 5 ) ;
 8039f16:	4a4b      	ldr	r2, [pc, #300]	; (803a044 <RadioSend+0x1a8>)
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039f18:	484b      	ldr	r0, [pc, #300]	; (803a048 <RadioSend+0x1ac>)
    outBuffer[size] = ( prevInt << 7 ) | ( prevInt << 6 ) | ( ( ( !prevInt ) & 0x01 ) << 5 ) ;
 8039f1a:	2900      	cmp	r1, #0
 8039f1c:	ea4f 1381 	mov.w	r3, r1, lsl #6
 8039f20:	ea43 13c1 	orr.w	r3, r3, r1, lsl #7
 8039f24:	4422      	add	r2, r4
 8039f26:	bf0c      	ite	eq
 8039f28:	2120      	moveq	r1, #32
 8039f2a:	2100      	movne	r1, #0
 8039f2c:	430b      	orrs	r3, r1
            SubgRf.PacketParams.Params.Bpsk.PayloadLength = size + 1;
 8039f2e:	1c66      	adds	r6, r4, #1
    outBuffer[size] = ( prevInt << 7 ) | ( prevInt << 6 ) | ( ( ( !prevInt ) & 0x01 ) << 5 ) ;
 8039f30:	7113      	strb	r3, [r2, #4]
            SubgRf.PacketParams.Params.Bpsk.PayloadLength = size + 1;
 8039f32:	b2f6      	uxtb	r6, r6
            SubgRf.PacketParams.PacketType = PACKET_TYPE_BPSK;
 8039f34:	2302      	movs	r3, #2
 8039f36:	73ab      	strb	r3, [r5, #14]
            SubgRf.PacketParams.Params.Bpsk.PayloadLength = size + 1;
 8039f38:	76ae      	strb	r6, [r5, #26]
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039f3a:	f000 fc39 	bl	803a7b0 <SUBGRF_SetPacketParams>
    SUBGRF_WriteRegister(addr, data );
 8039f3e:	2100      	movs	r1, #0
 8039f40:	20f1      	movs	r0, #241	; 0xf1
 8039f42:	f000 fa45 	bl	803a3d0 <SUBGRF_WriteRegister>
 8039f46:	2100      	movs	r1, #0
 8039f48:	20f0      	movs	r0, #240	; 0xf0
 8039f4a:	f000 fa41 	bl	803a3d0 <SUBGRF_WriteRegister>
            if( SubgRf.ModulationParams.Params.Bpsk.BitRate == 100 )
 8039f4e:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8039f50:	2b64      	cmp	r3, #100	; 0x64
 8039f52:	d16d      	bne.n	803a030 <RadioSend+0x194>
    SUBGRF_WriteRegister(addr, data );
 8039f54:	2170      	movs	r1, #112	; 0x70
 8039f56:	20f3      	movs	r0, #243	; 0xf3
 8039f58:	f000 fa3a 	bl	803a3d0 <SUBGRF_WriteRegister>
 8039f5c:	211d      	movs	r1, #29
 8039f5e:	20f2      	movs	r0, #242	; 0xf2
 8039f60:	f000 fa36 	bl	803a3d0 <SUBGRF_WriteRegister>
            uint16_t bitNum = ( size * 8 ) + 2;
 8039f64:	00e1      	lsls	r1, r4, #3
 8039f66:	1c8c      	adds	r4, r1, #2
    SUBGRF_WriteRegister(addr, data );
 8039f68:	20f4      	movs	r0, #244	; 0xf4
 8039f6a:	0a09      	lsrs	r1, r1, #8
 8039f6c:	f000 fa30 	bl	803a3d0 <SUBGRF_WriteRegister>
 8039f70:	f004 01fe 	and.w	r1, r4, #254	; 0xfe
 8039f74:	20f5      	movs	r0, #245	; 0xf5
 8039f76:	f000 fa2b 	bl	803a3d0 <SUBGRF_WriteRegister>
            SUBGRF_SendPayload( RadioBuffer, size+1 , 0xFFFFFF );
 8039f7a:	4831      	ldr	r0, [pc, #196]	; (803a040 <RadioSend+0x1a4>)
 8039f7c:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
 8039f80:	4631      	mov	r1, r6
 8039f82:	e01d      	b.n	8039fc0 <RadioSend+0x124>
            SubgRf.PacketParams.Params.LoRa.PayloadLength = size;
 8039f84:	77ec      	strb	r4, [r5, #31]
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039f86:	4830      	ldr	r0, [pc, #192]	; (803a048 <RadioSend+0x1ac>)
 8039f88:	f000 fc12 	bl	803a7b0 <SUBGRF_SetPacketParams>
            SUBGRF_SendPayload( buffer, size, 0 );
 8039f8c:	2200      	movs	r2, #0
 8039f8e:	4621      	mov	r1, r4
 8039f90:	e015      	b.n	8039fbe <RadioSend+0x122>
            if ( 1UL == RFW_Is_Init( ) )
 8039f92:	f000 fdc9 	bl	803ab28 <RFW_Is_Init>
 8039f96:	2801      	cmp	r0, #1
 8039f98:	4607      	mov	r7, r0
 8039f9a:	d123      	bne.n	8039fe4 <RadioSend+0x148>
              if ( 0UL == RFW_TransmitInit( buffer,size, &outsize ) )
 8039f9c:	4621      	mov	r1, r4
 8039f9e:	f10d 0207 	add.w	r2, sp, #7
 8039fa2:	4630      	mov	r0, r6
 8039fa4:	f000 fdc5 	bl	803ab32 <RFW_TransmitInit>
 8039fa8:	4604      	mov	r4, r0
 8039faa:	b998      	cbnz	r0, 8039fd4 <RadioSend+0x138>
                  SubgRf.PacketParams.Params.Gfsk.PayloadLength = outsize;
 8039fac:	f89d 3007 	ldrb.w	r3, [sp, #7]
                  SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039fb0:	4825      	ldr	r0, [pc, #148]	; (803a048 <RadioSend+0x1ac>)
                  SubgRf.PacketParams.Params.Gfsk.PayloadLength = outsize;
 8039fb2:	75ab      	strb	r3, [r5, #22]
                  SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039fb4:	f000 fbfc 	bl	803a7b0 <SUBGRF_SetPacketParams>
                  SUBGRF_SendPayload( buffer, outsize, 0 );
 8039fb8:	f89d 1007 	ldrb.w	r1, [sp, #7]
 8039fbc:	4622      	mov	r2, r4
            SUBGRF_SendPayload( buffer, size, 0 );
 8039fbe:	4630      	mov	r0, r6
            SUBGRF_SendPayload( RadioBuffer, size+1 , 0xFFFFFF );
 8039fc0:	f000 fcb1 	bl	803a926 <SUBGRF_SendPayload>
    TimerSetValue( &TxTimeoutTimer, SubgRf.TxTimeout );
 8039fc4:	6869      	ldr	r1, [r5, #4]
 8039fc6:	4821      	ldr	r0, [pc, #132]	; (803a04c <RadioSend+0x1b0>)
 8039fc8:	f001 fa18 	bl	803b3fc <UTIL_TIMER_SetPeriod>
    TimerStart( &TxTimeoutTimer );
 8039fcc:	481f      	ldr	r0, [pc, #124]	; (803a04c <RadioSend+0x1b0>)
 8039fce:	f001 f9db 	bl	803b388 <UTIL_TIMER_Start>
 8039fd2:	e005      	b.n	8039fe0 <RadioSend+0x144>
                MW_LOG( TS_ON, VLEVEL_M, "RadioSend Oversize\r\n");
 8039fd4:	4b1e      	ldr	r3, [pc, #120]	; (803a050 <RadioSend+0x1b4>)
 8039fd6:	463a      	mov	r2, r7
 8039fd8:	2100      	movs	r1, #0
 8039fda:	2002      	movs	r0, #2
 8039fdc:	f000 fe62 	bl	803aca4 <UTIL_ADV_TRACE_COND_FSend>
}
 8039fe0:	b003      	add	sp, #12
 8039fe2:	bdf0      	pop	{r4, r5, r6, r7, pc}
              SubgRf.PacketParams.Params.Gfsk.PayloadLength = size;
 8039fe4:	75ac      	strb	r4, [r5, #22]
              SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8039fe6:	e7ce      	b.n	8039f86 <RadioSend+0xea>
            SubgRf.PacketParams.PacketType = PACKET_TYPE_BPSK;
 8039fe8:	2302      	movs	r3, #2
 8039fea:	73ab      	strb	r3, [r5, #14]
            SubgRf.PacketParams.Params.Bpsk.PayloadLength = size;
 8039fec:	76ac      	strb	r4, [r5, #26]
 8039fee:	e7ca      	b.n	8039f86 <RadioSend+0xea>
        inBuffer[i] = ~inBuffer[i];
 8039ff0:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 8039ff4:	43c9      	mvns	r1, r1
 8039ff6:	7019      	strb	r1, [r3, #0]
        outBuffer[i] = 0;
 8039ff8:	f802 cb01 	strb.w	ip, [r2], #1
    for (i = 0; i < size; i++)
 8039ffc:	e783      	b.n	8039f06 <RadioSend+0x6a>
        index_bit = 7 - ( i % 8 );
 8039ffe:	43da      	mvns	r2, r3
 803a000:	f002 0c07 	and.w	ip, r2, #7
        index_byte = i / 8;
 803a004:	10da      	asrs	r2, r3, #3
        index_bit_out = 7 - ( ( i + 1 ) % 8 );
 803a006:	3301      	adds	r3, #1
        currBit = ( inBuffer[index_byte] >> index_bit ) & 0x01;
 803a008:	5cb2      	ldrb	r2, [r6, r2]
 803a00a:	fa42 f20c 	asr.w	r2, r2, ip
 803a00e:	f002 0201 	and.w	r2, r2, #1
        index_byte_out = ( i + 1 ) / 8;
 803a012:	ea4f 0ce3 	mov.w	ip, r3, asr #3
        prevInt ^= currBit;
 803a016:	4051      	eors	r1, r2
        index_bit_out = 7 - ( ( i + 1 ) % 8 );
 803a018:	43da      	mvns	r2, r3
        outBuffer[index_byte_out] |= ( prevInt << index_bit_out );
 803a01a:	f810 e00c 	ldrb.w	lr, [r0, ip]
 803a01e:	f002 0207 	and.w	r2, r2, #7
 803a022:	fa01 f202 	lsl.w	r2, r1, r2
 803a026:	ea42 020e 	orr.w	r2, r2, lr
 803a02a:	f800 200c 	strb.w	r2, [r0, ip]
    for (i = 0; i < (size * 8); i++)
 803a02e:	e770      	b.n	8039f12 <RadioSend+0x76>
    SUBGRF_WriteRegister(addr, data );
 803a030:	21e1      	movs	r1, #225	; 0xe1
 803a032:	20f3      	movs	r0, #243	; 0xf3
 803a034:	f000 f9cc 	bl	803a3d0 <SUBGRF_WriteRegister>
 803a038:	2104      	movs	r1, #4
 803a03a:	e790      	b.n	8039f5e <RadioSend+0xc2>
 803a03c:	20006324 	.word	0x20006324
 803a040:	20005980 	.word	0x20005980
 803a044:	2000597c 	.word	0x2000597c
 803a048:	20006332 	.word	0x20006332
 803a04c:	2000637c 	.word	0x2000637c
 803a050:	0803c4e0 	.word	0x0803c4e0

0803a054 <RadioTxPrbs>:
{
 803a054:	b508      	push	{r3, lr}
    SUBGRF_SetSwitch( SubgRf.AntSwitchPaSelect, RFSWITCH_TX );
 803a056:	4b09      	ldr	r3, [pc, #36]	; (803a07c <RadioTxPrbs+0x28>)
 803a058:	2101      	movs	r1, #1
 803a05a:	f893 0056 	ldrb.w	r0, [r3, #86]	; 0x56
 803a05e:	f000 fc94 	bl	803a98a <SUBGRF_SetSwitch>
    SUBGRF_WriteRegister(addr, data );
 803a062:	f44f 60d7 	mov.w	r0, #1720	; 0x6b8
 803a066:	212d      	movs	r1, #45	; 0x2d
 803a068:	f000 f9b2 	bl	803a3d0 <SUBGRF_WriteRegister>
    SUBGRF_SetTxInfinitePreamble( );
 803a06c:	f000 f89f 	bl	803a1ae <SUBGRF_SetTxInfinitePreamble>
}
 803a070:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    SUBGRF_SetTx( 0x0fffff );
 803a074:	4802      	ldr	r0, [pc, #8]	; (803a080 <RadioTxPrbs+0x2c>)
 803a076:	f000 b841 	b.w	803a0fc <SUBGRF_SetTx>
 803a07a:	bf00      	nop
 803a07c:	20006324 	.word	0x20006324
 803a080:	000fffff 	.word	0x000fffff

0803a084 <SUBGRF_WriteCommand>:
    CRITICAL_SECTION_END();
}

void SUBGRF_WriteCommand( SUBGHZ_RadioSetCmd_t Command, uint8_t *pBuffer,
                                        uint16_t Size )
{
 803a084:	b510      	push	{r4, lr}
 803a086:	4613      	mov	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803a088:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803a08c:	b672      	cpsid	i
    CRITICAL_SECTION_BEGIN();
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 803a08e:	460a      	mov	r2, r1
 803a090:	4601      	mov	r1, r0
 803a092:	4803      	ldr	r0, [pc, #12]	; (803a0a0 <SUBGRF_WriteCommand+0x1c>)
 803a094:	f7f5 fd18 	bl	802fac8 <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803a098:	f384 8810 	msr	PRIMASK, r4
    CRITICAL_SECTION_END();
}
 803a09c:	bd10      	pop	{r4, pc}
 803a09e:	bf00      	nop
 803a0a0:	200061f0 	.word	0x200061f0

0803a0a4 <SUBGRF_ReadCommand>:

void SUBGRF_ReadCommand( SUBGHZ_RadioGetCmd_t Command, uint8_t *pBuffer,
                                        uint16_t Size )
{
 803a0a4:	b510      	push	{r4, lr}
 803a0a6:	4613      	mov	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803a0a8:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803a0ac:	b672      	cpsid	i
    CRITICAL_SECTION_BEGIN();
    HAL_SUBGHZ_ExecGetCmd( &hsubghz, Command, pBuffer, Size );
 803a0ae:	460a      	mov	r2, r1
 803a0b0:	4601      	mov	r1, r0
 803a0b2:	4803      	ldr	r0, [pc, #12]	; (803a0c0 <SUBGRF_ReadCommand+0x1c>)
 803a0b4:	f7f5 fdaa 	bl	802fc0c <HAL_SUBGHZ_ExecGetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803a0b8:	f384 8810 	msr	PRIMASK, r4
    CRITICAL_SECTION_END();
}
 803a0bc:	bd10      	pop	{r4, pc}
 803a0be:	bf00      	nop
 803a0c0:	200061f0 	.word	0x200061f0

0803a0c4 <SUBGRF_GetOperatingMode>:
}
 803a0c4:	4b01      	ldr	r3, [pc, #4]	; (803a0cc <SUBGRF_GetOperatingMode+0x8>)
 803a0c6:	7818      	ldrb	r0, [r3, #0]
 803a0c8:	4770      	bx	lr
 803a0ca:	bf00      	nop
 803a0cc:	20005a80 	.word	0x20005a80

0803a0d0 <SUBGRF_SetStandby>:
{
 803a0d0:	b507      	push	{r0, r1, r2, lr}
    SUBGRF_WriteCommand( RADIO_SET_STANDBY, ( uint8_t* )&standbyConfig, 1 );
 803a0d2:	2201      	movs	r2, #1
{
 803a0d4:	f88d 0007 	strb.w	r0, [sp, #7]
    SUBGRF_WriteCommand( RADIO_SET_STANDBY, ( uint8_t* )&standbyConfig, 1 );
 803a0d8:	f10d 0107 	add.w	r1, sp, #7
 803a0dc:	2080      	movs	r0, #128	; 0x80
 803a0de:	f7ff ffd1 	bl	803a084 <SUBGRF_WriteCommand>
    if( standbyConfig == STDBY_RC )
 803a0e2:	f89d 3007 	ldrb.w	r3, [sp, #7]
 803a0e6:	2b00      	cmp	r3, #0
 803a0e8:	4b03      	ldr	r3, [pc, #12]	; (803a0f8 <SUBGRF_SetStandby+0x28>)
        OperatingMode = MODE_STDBY_XOSC;
 803a0ea:	bf0c      	ite	eq
 803a0ec:	2201      	moveq	r2, #1
 803a0ee:	2202      	movne	r2, #2
 803a0f0:	701a      	strb	r2, [r3, #0]
}
 803a0f2:	b003      	add	sp, #12
 803a0f4:	f85d fb04 	ldr.w	pc, [sp], #4
 803a0f8:	20005a80 	.word	0x20005a80

0803a0fc <SUBGRF_SetTx>:
{
 803a0fc:	b507      	push	{r0, r1, r2, lr}
    OperatingMode = MODE_TX;
 803a0fe:	4b09      	ldr	r3, [pc, #36]	; (803a124 <SUBGRF_SetTx+0x28>)
    buf[2] = ( uint8_t )( timeout & 0xFF );
 803a100:	f88d 0006 	strb.w	r0, [sp, #6]
    OperatingMode = MODE_TX;
 803a104:	2204      	movs	r2, #4
 803a106:	701a      	strb	r2, [r3, #0]
    buf[0] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 803a108:	0c03      	lsrs	r3, r0, #16
 803a10a:	f88d 3004 	strb.w	r3, [sp, #4]
    SUBGRF_WriteCommand( RADIO_SET_TX, buf, 3 );
 803a10e:	2203      	movs	r2, #3
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 803a110:	0a03      	lsrs	r3, r0, #8
    SUBGRF_WriteCommand( RADIO_SET_TX, buf, 3 );
 803a112:	a901      	add	r1, sp, #4
 803a114:	2083      	movs	r0, #131	; 0x83
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 803a116:	f88d 3005 	strb.w	r3, [sp, #5]
    SUBGRF_WriteCommand( RADIO_SET_TX, buf, 3 );
 803a11a:	f7ff ffb3 	bl	803a084 <SUBGRF_WriteCommand>
}
 803a11e:	b003      	add	sp, #12
 803a120:	f85d fb04 	ldr.w	pc, [sp], #4
 803a124:	20005a80 	.word	0x20005a80

0803a128 <SUBGRF_SetRx>:
{
 803a128:	b507      	push	{r0, r1, r2, lr}
    OperatingMode = MODE_RX;
 803a12a:	4b09      	ldr	r3, [pc, #36]	; (803a150 <SUBGRF_SetRx+0x28>)
    buf[2] = ( uint8_t )( timeout & 0xFF );
 803a12c:	f88d 0006 	strb.w	r0, [sp, #6]
    OperatingMode = MODE_RX;
 803a130:	2205      	movs	r2, #5
 803a132:	701a      	strb	r2, [r3, #0]
    buf[0] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 803a134:	0c03      	lsrs	r3, r0, #16
 803a136:	f88d 3004 	strb.w	r3, [sp, #4]
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 803a13a:	2203      	movs	r2, #3
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 803a13c:	0a03      	lsrs	r3, r0, #8
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 803a13e:	a901      	add	r1, sp, #4
 803a140:	2082      	movs	r0, #130	; 0x82
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 803a142:	f88d 3005 	strb.w	r3, [sp, #5]
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 803a146:	f7ff ff9d 	bl	803a084 <SUBGRF_WriteCommand>
}
 803a14a:	b003      	add	sp, #12
 803a14c:	f85d fb04 	ldr.w	pc, [sp], #4
 803a150:	20005a80 	.word	0x20005a80

0803a154 <SUBGRF_SetRxDutyCycle>:
{
 803a154:	b507      	push	{r0, r1, r2, lr}
    buf[0] = ( uint8_t )( ( rxTime >> 16 ) & 0xFF );
 803a156:	0c03      	lsrs	r3, r0, #16
 803a158:	f88d 3000 	strb.w	r3, [sp]
    buf[1] = ( uint8_t )( ( rxTime >> 8 ) & 0xFF );
 803a15c:	0a03      	lsrs	r3, r0, #8
 803a15e:	f88d 3001 	strb.w	r3, [sp, #1]
    buf[3] = ( uint8_t )( ( sleepTime >> 16 ) & 0xFF );
 803a162:	0c0b      	lsrs	r3, r1, #16
    buf[4] = ( uint8_t )( ( sleepTime >> 8 ) & 0xFF );
 803a164:	ba49      	rev16	r1, r1
    buf[2] = ( uint8_t )( rxTime & 0xFF );
 803a166:	f88d 0002 	strb.w	r0, [sp, #2]
    buf[4] = ( uint8_t )( ( sleepTime >> 8 ) & 0xFF );
 803a16a:	f8ad 1004 	strh.w	r1, [sp, #4]
    SUBGRF_WriteCommand( RADIO_SET_RXDUTYCYCLE, buf, 6 );
 803a16e:	2206      	movs	r2, #6
 803a170:	4669      	mov	r1, sp
 803a172:	2094      	movs	r0, #148	; 0x94
    buf[3] = ( uint8_t )( ( sleepTime >> 16 ) & 0xFF );
 803a174:	f88d 3003 	strb.w	r3, [sp, #3]
    SUBGRF_WriteCommand( RADIO_SET_RXDUTYCYCLE, buf, 6 );
 803a178:	f7ff ff84 	bl	803a084 <SUBGRF_WriteCommand>
    OperatingMode = MODE_RX_DC;
 803a17c:	4b02      	ldr	r3, [pc, #8]	; (803a188 <SUBGRF_SetRxDutyCycle+0x34>)
 803a17e:	2206      	movs	r2, #6
 803a180:	701a      	strb	r2, [r3, #0]
}
 803a182:	b003      	add	sp, #12
 803a184:	f85d fb04 	ldr.w	pc, [sp], #4
 803a188:	20005a80 	.word	0x20005a80

0803a18c <SUBGRF_SetCad>:
    SUBGRF_WriteCommand( RADIO_SET_CAD, 0, 0 );
 803a18c:	2200      	movs	r2, #0
{
 803a18e:	b508      	push	{r3, lr}
    SUBGRF_WriteCommand( RADIO_SET_CAD, 0, 0 );
 803a190:	4611      	mov	r1, r2
 803a192:	20c5      	movs	r0, #197	; 0xc5
 803a194:	f7ff ff76 	bl	803a084 <SUBGRF_WriteCommand>
    OperatingMode = MODE_CAD;
 803a198:	4b01      	ldr	r3, [pc, #4]	; (803a1a0 <SUBGRF_SetCad+0x14>)
 803a19a:	2207      	movs	r2, #7
 803a19c:	701a      	strb	r2, [r3, #0]
}
 803a19e:	bd08      	pop	{r3, pc}
 803a1a0:	20005a80 	.word	0x20005a80

0803a1a4 <SUBGRF_SetTxContinuousWave>:
    SUBGRF_WriteCommand( RADIO_SET_TXCONTINUOUSWAVE, 0, 0 );
 803a1a4:	2200      	movs	r2, #0
 803a1a6:	4611      	mov	r1, r2
 803a1a8:	20d1      	movs	r0, #209	; 0xd1
 803a1aa:	f7ff bf6b 	b.w	803a084 <SUBGRF_WriteCommand>

0803a1ae <SUBGRF_SetTxInfinitePreamble>:
    SUBGRF_WriteCommand( RADIO_SET_TXCONTINUOUSPREAMBLE, 0, 0 );
 803a1ae:	2200      	movs	r2, #0
 803a1b0:	4611      	mov	r1, r2
 803a1b2:	20d2      	movs	r0, #210	; 0xd2
 803a1b4:	f7ff bf66 	b.w	803a084 <SUBGRF_WriteCommand>

0803a1b8 <SUBGRF_SetStopRxTimerOnPreambleDetect>:
{
 803a1b8:	b507      	push	{r0, r1, r2, lr}
    SUBGRF_WriteCommand( RADIO_SET_STOPRXTIMERONPREAMBLE, ( uint8_t* )&enable, 1 );
 803a1ba:	2201      	movs	r2, #1
{
 803a1bc:	f88d 0007 	strb.w	r0, [sp, #7]
    SUBGRF_WriteCommand( RADIO_SET_STOPRXTIMERONPREAMBLE, ( uint8_t* )&enable, 1 );
 803a1c0:	f10d 0107 	add.w	r1, sp, #7
 803a1c4:	209f      	movs	r0, #159	; 0x9f
 803a1c6:	f7ff ff5d 	bl	803a084 <SUBGRF_WriteCommand>
}
 803a1ca:	b003      	add	sp, #12
 803a1cc:	f85d fb04 	ldr.w	pc, [sp], #4

0803a1d0 <SUBGRF_SetRegulatorMode>:
{
 803a1d0:	b507      	push	{r0, r1, r2, lr}
    if ( ( 1UL == RBI_IsDCDC() ) && ( 1UL == DCDC_ENABLE ) )
 803a1d2:	f7f2 ffb1 	bl	802d138 <RBI_IsDCDC>
 803a1d6:	1e43      	subs	r3, r0, #1
 803a1d8:	4258      	negs	r0, r3
 803a1da:	4158      	adcs	r0, r3
 803a1dc:	f88d 0007 	strb.w	r0, [sp, #7]
    SUBGRF_WriteCommand( RADIO_SET_REGULATORMODE, ( uint8_t* )&mode, 1 );
 803a1e0:	2201      	movs	r2, #1
 803a1e2:	f10d 0107 	add.w	r1, sp, #7
 803a1e6:	2096      	movs	r0, #150	; 0x96
 803a1e8:	f7ff ff4c 	bl	803a084 <SUBGRF_WriteCommand>
}
 803a1ec:	b003      	add	sp, #12
 803a1ee:	f85d fb04 	ldr.w	pc, [sp], #4

0803a1f2 <SUBGRF_Calibrate>:
{
 803a1f2:	b507      	push	{r0, r1, r2, lr}
                      ( ( uint8_t )calibParam.Fields.RC13MEnable << 1 ) |
 803a1f4:	f000 007f 	and.w	r0, r0, #127	; 0x7f
    uint8_t value = ( ( ( uint8_t )calibParam.Fields.ImgEnable << 6 ) |
 803a1f8:	f88d 0007 	strb.w	r0, [sp, #7]
    SUBGRF_WriteCommand( RADIO_CALIBRATE, &value, 1 );
 803a1fc:	2201      	movs	r2, #1
 803a1fe:	f10d 0107 	add.w	r1, sp, #7
 803a202:	2089      	movs	r0, #137	; 0x89
 803a204:	f7ff ff3e 	bl	803a084 <SUBGRF_WriteCommand>
}
 803a208:	b003      	add	sp, #12
 803a20a:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0803a210 <SUBGRF_CalibrateImage>:
    if( freq > 900000000 )
 803a210:	4b13      	ldr	r3, [pc, #76]	; (803a260 <SUBGRF_CalibrateImage+0x50>)
 803a212:	4298      	cmp	r0, r3
{
 803a214:	b507      	push	{r0, r1, r2, lr}
    if( freq > 900000000 )
 803a216:	d90b      	bls.n	803a230 <SUBGRF_CalibrateImage+0x20>
        calFreq[0] = 0xE1;
 803a218:	f64e 13e1 	movw	r3, #59873	; 0xe9e1
        calFreq[0] = 0x6B;
 803a21c:	f8ad 3004 	strh.w	r3, [sp, #4]
    SUBGRF_WriteCommand( RADIO_CALIBRATEIMAGE, calFreq, 2 );
 803a220:	2202      	movs	r2, #2
 803a222:	a901      	add	r1, sp, #4
 803a224:	2098      	movs	r0, #152	; 0x98
 803a226:	f7ff ff2d 	bl	803a084 <SUBGRF_WriteCommand>
}
 803a22a:	b003      	add	sp, #12
 803a22c:	f85d fb04 	ldr.w	pc, [sp], #4
    else if( freq > 850000000 )
 803a230:	4b0c      	ldr	r3, [pc, #48]	; (803a264 <SUBGRF_CalibrateImage+0x54>)
 803a232:	4298      	cmp	r0, r3
 803a234:	d902      	bls.n	803a23c <SUBGRF_CalibrateImage+0x2c>
        calFreq[0] = 0xD7;
 803a236:	f64d 33d7 	movw	r3, #56279	; 0xdbd7
 803a23a:	e7ef      	b.n	803a21c <SUBGRF_CalibrateImage+0xc>
    else if( freq > 770000000 )
 803a23c:	4b0a      	ldr	r3, [pc, #40]	; (803a268 <SUBGRF_CalibrateImage+0x58>)
 803a23e:	4298      	cmp	r0, r3
 803a240:	d902      	bls.n	803a248 <SUBGRF_CalibrateImage+0x38>
        calFreq[0] = 0xC1;
 803a242:	f24c 53c1 	movw	r3, #50625	; 0xc5c1
 803a246:	e7e9      	b.n	803a21c <SUBGRF_CalibrateImage+0xc>
    else if( freq > 460000000 )
 803a248:	4b08      	ldr	r3, [pc, #32]	; (803a26c <SUBGRF_CalibrateImage+0x5c>)
 803a24a:	4298      	cmp	r0, r3
 803a24c:	d902      	bls.n	803a254 <SUBGRF_CalibrateImage+0x44>
        calFreq[0] = 0x75;
 803a24e:	f248 1375 	movw	r3, #33141	; 0x8175
 803a252:	e7e3      	b.n	803a21c <SUBGRF_CalibrateImage+0xc>
    else if( freq > 425000000 )
 803a254:	4b06      	ldr	r3, [pc, #24]	; (803a270 <SUBGRF_CalibrateImage+0x60>)
 803a256:	4298      	cmp	r0, r3
 803a258:	d9e2      	bls.n	803a220 <SUBGRF_CalibrateImage+0x10>
        calFreq[0] = 0x6B;
 803a25a:	f646 736b 	movw	r3, #28523	; 0x6f6b
 803a25e:	e7dd      	b.n	803a21c <SUBGRF_CalibrateImage+0xc>
 803a260:	35a4e900 	.word	0x35a4e900
 803a264:	32a9f880 	.word	0x32a9f880
 803a268:	2de54480 	.word	0x2de54480
 803a26c:	1b6b0b00 	.word	0x1b6b0b00
 803a270:	1954fc40 	.word	0x1954fc40

0803a274 <SUBGRF_SetPaConfig>:
{
 803a274:	b507      	push	{r0, r1, r2, lr}
    buf[2] = deviceSel;
 803a276:	f88d 2006 	strb.w	r2, [sp, #6]
    SUBGRF_WriteCommand( RADIO_SET_PACONFIG, buf, 4 );
 803a27a:	2204      	movs	r2, #4
    buf[0] = paDutyCycle;
 803a27c:	f88d 0004 	strb.w	r0, [sp, #4]
    buf[1] = hpMax;
 803a280:	f88d 1005 	strb.w	r1, [sp, #5]
    SUBGRF_WriteCommand( RADIO_SET_PACONFIG, buf, 4 );
 803a284:	2095      	movs	r0, #149	; 0x95
 803a286:	eb0d 0102 	add.w	r1, sp, r2
    buf[3] = paLut;
 803a28a:	f88d 3007 	strb.w	r3, [sp, #7]
    SUBGRF_WriteCommand( RADIO_SET_PACONFIG, buf, 4 );
 803a28e:	f7ff fef9 	bl	803a084 <SUBGRF_WriteCommand>
}
 803a292:	b003      	add	sp, #12
 803a294:	f85d fb04 	ldr.w	pc, [sp], #4

0803a298 <SUBGRF_SetDioIrqParams>:
{
 803a298:	b507      	push	{r0, r1, r2, lr}
    buf[4] = ( uint8_t )( ( dio2Mask >> 8 ) & 0x00FF );
 803a29a:	ba52      	rev16	r2, r2
 803a29c:	f8ad 2004 	strh.w	r2, [sp, #4]
    buf[0] = ( uint8_t )( ( irqMask >> 8 ) & 0x00FF );
 803a2a0:	ba40      	rev16	r0, r0
    SUBGRF_WriteCommand( RADIO_CFG_DIOIRQ, buf, 8 );
 803a2a2:	2208      	movs	r2, #8
    buf[2] = ( uint8_t )( ( dio1Mask >> 8 ) & 0x00FF );
 803a2a4:	ba49      	rev16	r1, r1
    buf[0] = ( uint8_t )( ( irqMask >> 8 ) & 0x00FF );
 803a2a6:	f8ad 0000 	strh.w	r0, [sp]
    buf[2] = ( uint8_t )( ( dio1Mask >> 8 ) & 0x00FF );
 803a2aa:	f8ad 1002 	strh.w	r1, [sp, #2]
    buf[6] = ( uint8_t )( ( dio3Mask >> 8 ) & 0x00FF );
 803a2ae:	ba5b      	rev16	r3, r3
    SUBGRF_WriteCommand( RADIO_CFG_DIOIRQ, buf, 8 );
 803a2b0:	4669      	mov	r1, sp
 803a2b2:	4610      	mov	r0, r2
    buf[6] = ( uint8_t )( ( dio3Mask >> 8 ) & 0x00FF );
 803a2b4:	f8ad 3006 	strh.w	r3, [sp, #6]
    SUBGRF_WriteCommand( RADIO_CFG_DIOIRQ, buf, 8 );
 803a2b8:	f7ff fee4 	bl	803a084 <SUBGRF_WriteCommand>
}
 803a2bc:	b003      	add	sp, #12
 803a2be:	f85d fb04 	ldr.w	pc, [sp], #4

0803a2c2 <SUBGRF_SetTcxoMode>:
{
 803a2c2:	b507      	push	{r0, r1, r2, lr}
    buf[1] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 803a2c4:	0c0b      	lsrs	r3, r1, #16
    SUBGRF_WriteCommand( RADIO_SET_TCXOMODE, buf, 4 );
 803a2c6:	2204      	movs	r2, #4
    buf[0] = tcxoVoltage & 0x07;
 803a2c8:	f000 0007 	and.w	r0, r0, #7
    buf[2] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 803a2cc:	ba49      	rev16	r1, r1
    buf[0] = tcxoVoltage & 0x07;
 803a2ce:	f88d 0004 	strb.w	r0, [sp, #4]
    buf[2] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 803a2d2:	f8ad 1006 	strh.w	r1, [sp, #6]
    SUBGRF_WriteCommand( RADIO_SET_TCXOMODE, buf, 4 );
 803a2d6:	2097      	movs	r0, #151	; 0x97
 803a2d8:	eb0d 0102 	add.w	r1, sp, r2
    buf[1] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 803a2dc:	f88d 3005 	strb.w	r3, [sp, #5]
    SUBGRF_WriteCommand( RADIO_SET_TCXOMODE, buf, 4 );
 803a2e0:	f7ff fed0 	bl	803a084 <SUBGRF_WriteCommand>
}
 803a2e4:	b003      	add	sp, #12
 803a2e6:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0803a2ec <SUBGRF_SetRfFrequency>:
{
 803a2ec:	b537      	push	{r0, r1, r2, r4, r5, lr}
    if( ImageCalibrated == false )
 803a2ee:	4d0c      	ldr	r5, [pc, #48]	; (803a320 <SUBGRF_SetRfFrequency+0x34>)
 803a2f0:	786b      	ldrb	r3, [r5, #1]
{
 803a2f2:	4604      	mov	r4, r0
    if( ImageCalibrated == false )
 803a2f4:	b91b      	cbnz	r3, 803a2fe <SUBGRF_SetRfFrequency+0x12>
        SUBGRF_CalibrateImage( frequency );
 803a2f6:	f7ff ff8b 	bl	803a210 <SUBGRF_CalibrateImage>
        ImageCalibrated = true;
 803a2fa:	2301      	movs	r3, #1
 803a2fc:	706b      	strb	r3, [r5, #1]
    SX_FREQ_TO_CHANNEL(chan, frequency);   
 803a2fe:	2300      	movs	r3, #0
 803a300:	4a08      	ldr	r2, [pc, #32]	; (803a324 <SUBGRF_SetRfFrequency+0x38>)
 803a302:	0660      	lsls	r0, r4, #25
 803a304:	09e1      	lsrs	r1, r4, #7
 803a306:	f7f1 fc1d 	bl	802bb44 <__aeabi_uldivmod>
    SUBGRF_WriteCommand( RADIO_SET_RFFREQUENCY, buf, 4 );
 803a30a:	2204      	movs	r2, #4
 803a30c:	ba00      	rev	r0, r0
    buf[0] = ( uint8_t )( ( chan >> 24 ) & 0xFF );
 803a30e:	9001      	str	r0, [sp, #4]
    SUBGRF_WriteCommand( RADIO_SET_RFFREQUENCY, buf, 4 );
 803a310:	eb0d 0102 	add.w	r1, sp, r2
 803a314:	2086      	movs	r0, #134	; 0x86
 803a316:	f7ff feb5 	bl	803a084 <SUBGRF_WriteCommand>
}
 803a31a:	b003      	add	sp, #12
 803a31c:	bd30      	pop	{r4, r5, pc}
 803a31e:	bf00      	nop
 803a320:	20005a80 	.word	0x20005a80
 803a324:	01e84800 	.word	0x01e84800

0803a328 <SUBGRF_SetBufferBaseAddress>:
{
 803a328:	b507      	push	{r0, r1, r2, lr}
    SUBGRF_WriteCommand( RADIO_SET_BUFFERBASEADDRESS, buf, 2 );
 803a32a:	2202      	movs	r2, #2
    buf[0] = txBaseAddress;
 803a32c:	f88d 0004 	strb.w	r0, [sp, #4]
    buf[1] = rxBaseAddress;
 803a330:	f88d 1005 	strb.w	r1, [sp, #5]
    SUBGRF_WriteCommand( RADIO_SET_BUFFERBASEADDRESS, buf, 2 );
 803a334:	208f      	movs	r0, #143	; 0x8f
 803a336:	a901      	add	r1, sp, #4
 803a338:	f7ff fea4 	bl	803a084 <SUBGRF_WriteCommand>
}
 803a33c:	b003      	add	sp, #12
 803a33e:	f85d fb04 	ldr.w	pc, [sp], #4

0803a342 <SUBGRF_GetRssiInst>:
{
 803a342:	b507      	push	{r0, r1, r2, lr}
    SUBGRF_ReadCommand( RADIO_GET_RSSIINST, buf, 1 );
 803a344:	2201      	movs	r2, #1
 803a346:	a901      	add	r1, sp, #4
 803a348:	2015      	movs	r0, #21
 803a34a:	f7ff feab 	bl	803a0a4 <SUBGRF_ReadCommand>
    rssi = -buf[0] >> 1;
 803a34e:	f89d 0004 	ldrb.w	r0, [sp, #4]
 803a352:	4240      	negs	r0, r0
}
 803a354:	1040      	asrs	r0, r0, #1
 803a356:	b003      	add	sp, #12
 803a358:	f85d fb04 	ldr.w	pc, [sp], #4

0803a35c <SUBGRF_GetPacketStatus>:
{
 803a35c:	b513      	push	{r0, r1, r4, lr}
    SUBGRF_ReadCommand( RADIO_GET_PACKETSTATUS, status, 3 );
 803a35e:	2203      	movs	r2, #3
{
 803a360:	4604      	mov	r4, r0
    SUBGRF_ReadCommand( RADIO_GET_PACKETSTATUS, status, 3 );
 803a362:	a901      	add	r1, sp, #4
 803a364:	2014      	movs	r0, #20
 803a366:	f7ff fe9d 	bl	803a0a4 <SUBGRF_ReadCommand>
    return PacketType;
 803a36a:	4918      	ldr	r1, [pc, #96]	; (803a3cc <SUBGRF_GetPacketStatus+0x70>)
 803a36c:	788a      	ldrb	r2, [r1, #2]
    pktStatus->packetType = SUBGRF_GetPacketType( );
 803a36e:	7022      	strb	r2, [r4, #0]
    switch( pktStatus->packetType )
 803a370:	b14a      	cbz	r2, 803a386 <SUBGRF_GetPacketStatus+0x2a>
 803a372:	2a01      	cmp	r2, #1
 803a374:	d017      	beq.n	803a3a6 <SUBGRF_GetPacketStatus+0x4a>
            RADIO_MEMSET8( pktStatus, 0, sizeof( PacketStatus_t ) );
 803a376:	2214      	movs	r2, #20
 803a378:	2100      	movs	r1, #0
 803a37a:	4620      	mov	r0, r4
 803a37c:	f000 fda4 	bl	803aec8 <UTIL_MEM_set_8>
            pktStatus->packetType = PACKET_TYPE_NONE;
 803a380:	230f      	movs	r3, #15
 803a382:	7023      	strb	r3, [r4, #0]
}
 803a384:	e00d      	b.n	803a3a2 <SUBGRF_GetPacketStatus+0x46>
            pktStatus->Params.Gfsk.RxStatus = status[0];
 803a386:	f89d 3004 	ldrb.w	r3, [sp, #4]
 803a38a:	7123      	strb	r3, [r4, #4]
            pktStatus->Params.Gfsk.RssiSync = -status[1] >> 1;
 803a38c:	f89d 3005 	ldrb.w	r3, [sp, #5]
            pktStatus->Params.Gfsk.FreqError = 0;
 803a390:	60a2      	str	r2, [r4, #8]
            pktStatus->Params.Gfsk.RssiSync = -status[1] >> 1;
 803a392:	425b      	negs	r3, r3
 803a394:	105b      	asrs	r3, r3, #1
 803a396:	71a3      	strb	r3, [r4, #6]
            pktStatus->Params.Gfsk.RssiAvg = -status[2] >> 1;
 803a398:	f89d 3006 	ldrb.w	r3, [sp, #6]
 803a39c:	425b      	negs	r3, r3
 803a39e:	105b      	asrs	r3, r3, #1
 803a3a0:	7163      	strb	r3, [r4, #5]
}
 803a3a2:	b002      	add	sp, #8
 803a3a4:	bd10      	pop	{r4, pc}
            pktStatus->Params.LoRa.RssiPkt = -status[0] >> 1;
 803a3a6:	f89d 3004 	ldrb.w	r3, [sp, #4]
 803a3aa:	425b      	negs	r3, r3
 803a3ac:	105b      	asrs	r3, r3, #1
 803a3ae:	7323      	strb	r3, [r4, #12]
            pktStatus->Params.LoRa.SnrPkt = ( ( ( int8_t )status[1] ) + 2 ) >> 2;
 803a3b0:	f99d 3005 	ldrsb.w	r3, [sp, #5]
 803a3b4:	3302      	adds	r3, #2
 803a3b6:	109b      	asrs	r3, r3, #2
 803a3b8:	7363      	strb	r3, [r4, #13]
            pktStatus->Params.LoRa.SignalRssiPkt = -status[2] >> 1;
 803a3ba:	f89d 3006 	ldrb.w	r3, [sp, #6]
 803a3be:	425b      	negs	r3, r3
 803a3c0:	105b      	asrs	r3, r3, #1
 803a3c2:	73a3      	strb	r3, [r4, #14]
            pktStatus->Params.LoRa.FreqError = FrequencyError;
 803a3c4:	684b      	ldr	r3, [r1, #4]
 803a3c6:	6123      	str	r3, [r4, #16]
            break;
 803a3c8:	e7eb      	b.n	803a3a2 <SUBGRF_GetPacketStatus+0x46>
 803a3ca:	bf00      	nop
 803a3cc:	20005a80 	.word	0x20005a80

0803a3d0 <SUBGRF_WriteRegister>:
{
 803a3d0:	b507      	push	{r0, r1, r2, lr}
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 803a3d2:	2301      	movs	r3, #1
{
 803a3d4:	f88d 1007 	strb.w	r1, [sp, #7]
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 803a3d8:	f10d 0207 	add.w	r2, sp, #7
 803a3dc:	4601      	mov	r1, r0
 803a3de:	4803      	ldr	r0, [pc, #12]	; (803a3ec <SUBGRF_WriteRegister+0x1c>)
 803a3e0:	f7f5 fafe 	bl	802f9e0 <HAL_SUBGHZ_WriteRegisters>
}
 803a3e4:	b003      	add	sp, #12
 803a3e6:	f85d fb04 	ldr.w	pc, [sp], #4
 803a3ea:	bf00      	nop
 803a3ec:	200061f0 	.word	0x200061f0

0803a3f0 <SUBGRF_SetRxBoosted>:
{
 803a3f0:	b513      	push	{r0, r1, r4, lr}
    OperatingMode = MODE_RX;
 803a3f2:	4b0c      	ldr	r3, [pc, #48]	; (803a424 <SUBGRF_SetRxBoosted+0x34>)
{
 803a3f4:	4604      	mov	r4, r0
    OperatingMode = MODE_RX;
 803a3f6:	2205      	movs	r2, #5
    SUBGRF_WriteRegister( REG_RX_GAIN, 0x97 ); // max LNA gain, increase current by ~2mA for around ~3dB in sensitivity
 803a3f8:	2197      	movs	r1, #151	; 0x97
 803a3fa:	f640 00ac 	movw	r0, #2220	; 0x8ac
    OperatingMode = MODE_RX;
 803a3fe:	701a      	strb	r2, [r3, #0]
    SUBGRF_WriteRegister( REG_RX_GAIN, 0x97 ); // max LNA gain, increase current by ~2mA for around ~3dB in sensitivity
 803a400:	f7ff ffe6 	bl	803a3d0 <SUBGRF_WriteRegister>
    buf[0] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 803a404:	0c23      	lsrs	r3, r4, #16
 803a406:	f88d 3004 	strb.w	r3, [sp, #4]
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 803a40a:	2203      	movs	r2, #3
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 803a40c:	0a23      	lsrs	r3, r4, #8
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 803a40e:	a901      	add	r1, sp, #4
 803a410:	2082      	movs	r0, #130	; 0x82
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 803a412:	f88d 3005 	strb.w	r3, [sp, #5]
    buf[2] = ( uint8_t )( timeout & 0xFF );
 803a416:	f88d 4006 	strb.w	r4, [sp, #6]
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 803a41a:	f7ff fe33 	bl	803a084 <SUBGRF_WriteCommand>
}
 803a41e:	b002      	add	sp, #8
 803a420:	bd10      	pop	{r4, pc}
 803a422:	bf00      	nop
 803a424:	20005a80 	.word	0x20005a80

0803a428 <SUBGRF_SetLoRaSymbNumTimeout>:
{
 803a428:	b507      	push	{r0, r1, r2, lr}
    SUBGRF_WriteCommand( RADIO_SET_LORASYMBTIMEOUT, &symbNum, 1 );
 803a42a:	2201      	movs	r2, #1
{
 803a42c:	f88d 0007 	strb.w	r0, [sp, #7]
    SUBGRF_WriteCommand( RADIO_SET_LORASYMBTIMEOUT, &symbNum, 1 );
 803a430:	f10d 0107 	add.w	r1, sp, #7
 803a434:	20a0      	movs	r0, #160	; 0xa0
 803a436:	f7ff fe25 	bl	803a084 <SUBGRF_WriteCommand>
    if( symbNum >= 64 )
 803a43a:	f89d 1007 	ldrb.w	r1, [sp, #7]
 803a43e:	293f      	cmp	r1, #63	; 0x3f
 803a440:	d907      	bls.n	803a452 <SUBGRF_SetLoRaSymbNumTimeout+0x2a>
        reg = exp + ( mant << 3 );
 803a442:	f001 01f8 	and.w	r1, r1, #248	; 0xf8
 803a446:	3101      	adds	r1, #1
        SUBGRF_WriteRegister( REG_LR_SYNCH_TIMEOUT, reg );
 803a448:	b2c9      	uxtb	r1, r1
 803a44a:	f240 7006 	movw	r0, #1798	; 0x706
 803a44e:	f7ff ffbf 	bl	803a3d0 <SUBGRF_WriteRegister>
}
 803a452:	b003      	add	sp, #12
 803a454:	f85d fb04 	ldr.w	pc, [sp], #4

0803a458 <SUBGRF_SetPacketType>:
{
 803a458:	b507      	push	{r0, r1, r2, lr}
    PacketType = packetType;
 803a45a:	4b09      	ldr	r3, [pc, #36]	; (803a480 <SUBGRF_SetPacketType+0x28>)
{
 803a45c:	f88d 0007 	strb.w	r0, [sp, #7]
 803a460:	4601      	mov	r1, r0
    PacketType = packetType;
 803a462:	7098      	strb	r0, [r3, #2]
    if( packetType == PACKET_TYPE_GFSK )
 803a464:	b918      	cbnz	r0, 803a46e <SUBGRF_SetPacketType+0x16>
        SUBGRF_WriteRegister( REG_BIT_SYNC, 0x00 );
 803a466:	f240 60ac 	movw	r0, #1708	; 0x6ac
 803a46a:	f7ff ffb1 	bl	803a3d0 <SUBGRF_WriteRegister>
    SUBGRF_WriteCommand( RADIO_SET_PACKETTYPE, ( uint8_t* )&packetType, 1 );
 803a46e:	2201      	movs	r2, #1
 803a470:	f10d 0107 	add.w	r1, sp, #7
 803a474:	208a      	movs	r0, #138	; 0x8a
 803a476:	f7ff fe05 	bl	803a084 <SUBGRF_WriteCommand>
}
 803a47a:	b003      	add	sp, #12
 803a47c:	f85d fb04 	ldr.w	pc, [sp], #4
 803a480:	20005a80 	.word	0x20005a80

0803a484 <SUBGRF_SetModulationParams>:
{
 803a484:	b513      	push	{r0, r1, r4, lr}
    uint8_t buf[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 803a486:	4a31      	ldr	r2, [pc, #196]	; (803a54c <SUBGRF_SetModulationParams+0xc8>)
{
 803a488:	4604      	mov	r4, r0
    uint8_t buf[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 803a48a:	6851      	ldr	r1, [r2, #4]
 803a48c:	6810      	ldr	r0, [r2, #0]
 803a48e:	466b      	mov	r3, sp
 803a490:	c303      	stmia	r3!, {r0, r1}
    if( PacketType != modulationParams->PacketType )
 803a492:	4b2f      	ldr	r3, [pc, #188]	; (803a550 <SUBGRF_SetModulationParams+0xcc>)
 803a494:	7820      	ldrb	r0, [r4, #0]
 803a496:	789b      	ldrb	r3, [r3, #2]
 803a498:	4283      	cmp	r3, r0
 803a49a:	d001      	beq.n	803a4a0 <SUBGRF_SetModulationParams+0x1c>
        SUBGRF_SetPacketType( modulationParams->PacketType );
 803a49c:	f7ff ffdc 	bl	803a458 <SUBGRF_SetPacketType>
    switch( modulationParams->PacketType )
 803a4a0:	7823      	ldrb	r3, [r4, #0]
 803a4a2:	2b03      	cmp	r3, #3
 803a4a4:	d827      	bhi.n	803a4f6 <SUBGRF_SetModulationParams+0x72>
 803a4a6:	e8df f003 	tbb	[pc, r3]
 803a4aa:	3902      	.short	0x3902
 803a4ac:	3c28      	.short	0x3c28
        tempVal = ( uint32_t )(( 32 * XTAL_FREQ ) / modulationParams->Params.Gfsk.BitRate );
 803a4ae:	6862      	ldr	r2, [r4, #4]
 803a4b0:	4b28      	ldr	r3, [pc, #160]	; (803a554 <SUBGRF_SetModulationParams+0xd0>)
 803a4b2:	fbb3 f3f2 	udiv	r3, r3, r2
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 803a4b6:	0c1a      	lsrs	r2, r3, #16
        SX_FREQ_TO_CHANNEL(tempVal, modulationParams->Params.Gfsk.Fdev);
 803a4b8:	68a1      	ldr	r1, [r4, #8]
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 803a4ba:	f88d 2000 	strb.w	r2, [sp]
        buf[2] = tempVal & 0xFF;
 803a4be:	f88d 3002 	strb.w	r3, [sp, #2]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 803a4c2:	0a1a      	lsrs	r2, r3, #8
        buf[3] = modulationParams->Params.Gfsk.ModulationShaping;
 803a4c4:	7b23      	ldrb	r3, [r4, #12]
 803a4c6:	f88d 3003 	strb.w	r3, [sp, #3]
        buf[4] = modulationParams->Params.Gfsk.Bandwidth;
 803a4ca:	7b63      	ldrb	r3, [r4, #13]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 803a4cc:	f88d 2001 	strb.w	r2, [sp, #1]
        buf[4] = modulationParams->Params.Gfsk.Bandwidth;
 803a4d0:	f88d 3004 	strb.w	r3, [sp, #4]
        SX_FREQ_TO_CHANNEL(tempVal, modulationParams->Params.Gfsk.Fdev);
 803a4d4:	4a20      	ldr	r2, [pc, #128]	; (803a558 <SUBGRF_SetModulationParams+0xd4>)
 803a4d6:	2300      	movs	r3, #0
 803a4d8:	0648      	lsls	r0, r1, #25
 803a4da:	09c9      	lsrs	r1, r1, #7
 803a4dc:	f7f1 fb32 	bl	802bb44 <__aeabi_uldivmod>
        buf[5] = ( tempVal >> 16 ) & 0xFF;
 803a4e0:	0c03      	lsrs	r3, r0, #16
        buf[6] = ( tempVal >> 8 ) & 0xFF;
 803a4e2:	ba40      	rev16	r0, r0
        buf[5] = ( tempVal >> 16 ) & 0xFF;
 803a4e4:	f88d 3005 	strb.w	r3, [sp, #5]
        buf[6] = ( tempVal >> 8 ) & 0xFF;
 803a4e8:	f8ad 0006 	strh.w	r0, [sp, #6]
        SUBGRF_WriteCommand( RADIO_SET_MODULATIONPARAMS, buf, n );
 803a4ec:	2208      	movs	r2, #8
        SUBGRF_WriteCommand( RADIO_SET_MODULATIONPARAMS, buf, n );
 803a4ee:	4669      	mov	r1, sp
 803a4f0:	208b      	movs	r0, #139	; 0x8b
 803a4f2:	f7ff fdc7 	bl	803a084 <SUBGRF_WriteCommand>
}
 803a4f6:	b002      	add	sp, #8
 803a4f8:	bd10      	pop	{r4, pc}
        tempVal = ( uint32_t ) (( 32 * XTAL_FREQ) / modulationParams->Params.Bpsk.BitRate );
 803a4fa:	6922      	ldr	r2, [r4, #16]
 803a4fc:	4b15      	ldr	r3, [pc, #84]	; (803a554 <SUBGRF_SetModulationParams+0xd0>)
 803a4fe:	fbb3 f3f2 	udiv	r3, r3, r2
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 803a502:	0c1a      	lsrs	r2, r3, #16
 803a504:	f88d 2000 	strb.w	r2, [sp]
        buf[2] = tempVal & 0xFF;
 803a508:	f88d 3002 	strb.w	r3, [sp, #2]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 803a50c:	0a1a      	lsrs	r2, r3, #8
        buf[3] = modulationParams->Params.Bpsk.ModulationShaping;
 803a50e:	7d23      	ldrb	r3, [r4, #20]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 803a510:	f88d 2001 	strb.w	r2, [sp, #1]
        buf[3] = modulationParams->Params.Bpsk.ModulationShaping;
 803a514:	f88d 3003 	strb.w	r3, [sp, #3]
        SUBGRF_WriteCommand( RADIO_SET_MODULATIONPARAMS, buf, n );
 803a518:	2204      	movs	r2, #4
 803a51a:	e7e8      	b.n	803a4ee <SUBGRF_SetModulationParams+0x6a>
        buf[0] = modulationParams->Params.LoRa.SpreadingFactor;
 803a51c:	69a3      	ldr	r3, [r4, #24]
 803a51e:	9300      	str	r3, [sp, #0]
 803a520:	e7fa      	b.n	803a518 <SUBGRF_SetModulationParams+0x94>
        tempVal = ( uint32_t )(( 32 *XTAL_FREQ) / modulationParams->Params.Gfsk.BitRate );
 803a522:	6862      	ldr	r2, [r4, #4]
 803a524:	4b0b      	ldr	r3, [pc, #44]	; (803a554 <SUBGRF_SetModulationParams+0xd0>)
 803a526:	fbb3 f3f2 	udiv	r3, r3, r2
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 803a52a:	0c1a      	lsrs	r2, r3, #16
 803a52c:	f88d 2000 	strb.w	r2, [sp]
        buf[2] = tempVal & 0xFF;
 803a530:	f88d 3002 	strb.w	r3, [sp, #2]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 803a534:	0a1a      	lsrs	r2, r3, #8
        buf[3] = modulationParams->Params.Gfsk.ModulationShaping;
 803a536:	7b23      	ldrb	r3, [r4, #12]
 803a538:	f88d 3003 	strb.w	r3, [sp, #3]
        buf[4] = modulationParams->Params.Gfsk.Bandwidth;
 803a53c:	7b63      	ldrb	r3, [r4, #13]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 803a53e:	f88d 2001 	strb.w	r2, [sp, #1]
        buf[4] = modulationParams->Params.Gfsk.Bandwidth;
 803a542:	f88d 3004 	strb.w	r3, [sp, #4]
        SUBGRF_WriteCommand( RADIO_SET_MODULATIONPARAMS, buf, n );
 803a546:	2205      	movs	r2, #5
 803a548:	e7d1      	b.n	803a4ee <SUBGRF_SetModulationParams+0x6a>
 803a54a:	bf00      	nop
 803a54c:	0803bc5c 	.word	0x0803bc5c
 803a550:	20005a80 	.word	0x20005a80
 803a554:	3d090000 	.word	0x3d090000
 803a558:	01e84800 	.word	0x01e84800

0803a55c <SUBGRF_ReadRegister>:
{
 803a55c:	b507      	push	{r0, r1, r2, lr}
    HAL_SUBGHZ_ReadRegisters( &hsubghz, addr, &data, 1 );
 803a55e:	2301      	movs	r3, #1
{
 803a560:	4601      	mov	r1, r0
    HAL_SUBGHZ_ReadRegisters( &hsubghz, addr, &data, 1 );
 803a562:	f10d 0207 	add.w	r2, sp, #7
 803a566:	4804      	ldr	r0, [pc, #16]	; (803a578 <SUBGRF_ReadRegister+0x1c>)
 803a568:	f7f5 fa73 	bl	802fa52 <HAL_SUBGHZ_ReadRegisters>
}
 803a56c:	f89d 0007 	ldrb.w	r0, [sp, #7]
 803a570:	b003      	add	sp, #12
 803a572:	f85d fb04 	ldr.w	pc, [sp], #4
 803a576:	bf00      	nop
 803a578:	200061f0 	.word	0x200061f0

0803a57c <Radio_SMPS_Set>:
{
    RadioOnDioIrqCb( IRQ_HEADER_VALID );
}

static void Radio_SMPS_Set(uint8_t level)
{
 803a57c:	b510      	push	{r4, lr}
 803a57e:	4604      	mov	r4, r0
  if ( 1U == RBI_IsDCDC() )
 803a580:	f7f2 fdda 	bl	802d138 <RBI_IsDCDC>
 803a584:	2801      	cmp	r0, #1
 803a586:	d10c      	bne.n	803a5a2 <Radio_SMPS_Set+0x26>
  {
    uint8_t modReg;
    modReg= SUBGRF_ReadRegister(SUBGHZ_SMPSC2R);
 803a588:	f640 1023 	movw	r0, #2339	; 0x923
 803a58c:	f7ff ffe6 	bl	803a55c <SUBGRF_ReadRegister>
    modReg&= (~SMPS_DRV_MASK);
    SUBGRF_WriteRegister(SUBGHZ_SMPSC2R, modReg | level);
 803a590:	f000 01f9 	and.w	r1, r0, #249	; 0xf9
 803a594:	4321      	orrs	r1, r4
 803a596:	f640 1023 	movw	r0, #2339	; 0x923
  }
}
 803a59a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    SUBGRF_WriteRegister(SUBGHZ_SMPSC2R, modReg | level);
 803a59e:	f7ff bf17 	b.w	803a3d0 <SUBGRF_WriteRegister>
}
 803a5a2:	bd10      	pop	{r4, pc}

0803a5a4 <SUBGRF_Init>:
{
 803a5a4:	b538      	push	{r3, r4, r5, lr}
 803a5a6:	4c16      	ldr	r4, [pc, #88]	; (803a600 <SUBGRF_Init+0x5c>)
    if ( dioIrq != NULL)
 803a5a8:	b100      	cbz	r0, 803a5ac <SUBGRF_Init+0x8>
        RadioOnDioIrqCb = dioIrq;
 803a5aa:	60a0      	str	r0, [r4, #8]
    RADIO_INIT();
 803a5ac:	f7f1 ff4e 	bl	802c44c <MX_SUBGHZ_Init>
    ImageCalibrated = false;
 803a5b0:	2500      	movs	r5, #0
    Radio_SMPS_Set(SMPS_DRIVE_SETTING_DEFAULT);
 803a5b2:	2002      	movs	r0, #2
 803a5b4:	f7ff ffe2 	bl	803a57c <Radio_SMPS_Set>
    SUBGRF_SetStandby( STDBY_RC );
 803a5b8:	4628      	mov	r0, r5
    ImageCalibrated = false;
 803a5ba:	7065      	strb	r5, [r4, #1]
    SUBGRF_SetStandby( STDBY_RC );
 803a5bc:	f7ff fd88 	bl	803a0d0 <SUBGRF_SetStandby>
    if (1U == RBI_IsTCXO() )
 803a5c0:	f7f2 fdb8 	bl	802d134 <RBI_IsTCXO>
 803a5c4:	2801      	cmp	r0, #1
 803a5c6:	d110      	bne.n	803a5ea <SUBGRF_Init+0x46>
        SUBGRF_SetTcxoMode( TCXO_CTRL_VOLTAGE, RF_WAKEUP_TIME << 6 );// 100 ms
 803a5c8:	2140      	movs	r1, #64	; 0x40
 803a5ca:	f7ff fe7a 	bl	803a2c2 <SUBGRF_SetTcxoMode>
        SUBGRF_WriteRegister( REG_XTA_TRIM, 0x00 );
 803a5ce:	f640 1011 	movw	r0, #2321	; 0x911
 803a5d2:	4629      	mov	r1, r5
 803a5d4:	f7ff fefc 	bl	803a3d0 <SUBGRF_WriteRegister>
        SUBGRF_Calibrate( calibParam );
 803a5d8:	f04f 007f 	mov.w	r0, #127	; 0x7f
 803a5dc:	f7ff fe09 	bl	803a1f2 <SUBGRF_Calibrate>
    RBI_Init();
 803a5e0:	f7f2 fda2 	bl	802d128 <RBI_Init>
    OperatingMode = MODE_STDBY_RC;
 803a5e4:	2301      	movs	r3, #1
 803a5e6:	7023      	strb	r3, [r4, #0]
}
 803a5e8:	bd38      	pop	{r3, r4, r5, pc}
        SUBGRF_WriteRegister( REG_XTA_TRIM, XTAL_DEFAULT_CAP_VALUE );
 803a5ea:	2120      	movs	r1, #32
 803a5ec:	f640 1011 	movw	r0, #2321	; 0x911
 803a5f0:	f7ff feee 	bl	803a3d0 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_XTB_TRIM, XTAL_DEFAULT_CAP_VALUE );
 803a5f4:	2120      	movs	r1, #32
 803a5f6:	f640 1012 	movw	r0, #2322	; 0x912
 803a5fa:	f7ff fee9 	bl	803a3d0 <SUBGRF_WriteRegister>
 803a5fe:	e7ef      	b.n	803a5e0 <SUBGRF_Init+0x3c>
 803a600:	20005a80 	.word	0x20005a80

0803a604 <SUBGRF_SetSleep>:
{
 803a604:	b513      	push	{r0, r1, r4, lr}
 803a606:	4604      	mov	r4, r0
    RBI_ConfigRFSwitch(RBI_SWITCH_OFF);
 803a608:	2000      	movs	r0, #0
 803a60a:	f7f2 fd8f 	bl	802d12c <RBI_ConfigRFSwitch>
    Radio_SMPS_Set(SMPS_DRIVE_SETTING_DEFAULT);
 803a60e:	2002      	movs	r0, #2
 803a610:	f7ff ffb4 	bl	803a57c <Radio_SMPS_Set>
                      ( ( uint8_t )sleepConfig.Fields.Reset << 1 ) |
 803a614:	f004 0407 	and.w	r4, r4, #7
    SUBGRF_WriteCommand( RADIO_SET_SLEEP, &value, 1 );
 803a618:	2201      	movs	r2, #1
 803a61a:	f10d 0107 	add.w	r1, sp, #7
 803a61e:	2084      	movs	r0, #132	; 0x84
    uint8_t value = ( ( ( uint8_t )sleepConfig.Fields.WarmStart << 2 ) |
 803a620:	f88d 4007 	strb.w	r4, [sp, #7]
    SUBGRF_WriteCommand( RADIO_SET_SLEEP, &value, 1 );
 803a624:	f7ff fd2e 	bl	803a084 <SUBGRF_WriteCommand>
    OperatingMode = MODE_SLEEP;
 803a628:	4b02      	ldr	r3, [pc, #8]	; (803a634 <SUBGRF_SetSleep+0x30>)
 803a62a:	2200      	movs	r2, #0
 803a62c:	701a      	strb	r2, [r3, #0]
}
 803a62e:	b002      	add	sp, #8
 803a630:	bd10      	pop	{r4, pc}
 803a632:	bf00      	nop
 803a634:	20005a80 	.word	0x20005a80

0803a638 <SUBGRF_SetWhiteningSeed>:
{
 803a638:	b510      	push	{r4, lr}
    return PacketType;
 803a63a:	4b0c      	ldr	r3, [pc, #48]	; (803a66c <SUBGRF_SetWhiteningSeed+0x34>)
    switch( SUBGRF_GetPacketType( ) )
 803a63c:	789b      	ldrb	r3, [r3, #2]
{
 803a63e:	4604      	mov	r4, r0
    switch( SUBGRF_GetPacketType( ) )
 803a640:	b99b      	cbnz	r3, 803a66a <SUBGRF_SetWhiteningSeed+0x32>
            regValue = SUBGRF_ReadRegister( REG_LR_WHITSEEDBASEADDR_MSB ) & 0xFE;
 803a642:	f44f 60d7 	mov.w	r0, #1720	; 0x6b8
 803a646:	f7ff ff89 	bl	803a55c <SUBGRF_ReadRegister>
            regValue = ( ( seed >> 8 ) & 0x01 ) | regValue;
 803a64a:	f3c4 2100 	ubfx	r1, r4, #8, #1
 803a64e:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
            SUBGRF_WriteRegister( REG_LR_WHITSEEDBASEADDR_MSB, regValue ); // only 1 bit.
 803a652:	4301      	orrs	r1, r0
 803a654:	f44f 60d7 	mov.w	r0, #1720	; 0x6b8
 803a658:	f7ff feba 	bl	803a3d0 <SUBGRF_WriteRegister>
            SUBGRF_WriteRegister( REG_LR_WHITSEEDBASEADDR_LSB, (uint8_t)seed );
 803a65c:	b2e1      	uxtb	r1, r4
 803a65e:	f240 60b9 	movw	r0, #1721	; 0x6b9
}
 803a662:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            SUBGRF_WriteRegister( REG_LR_WHITSEEDBASEADDR_LSB, (uint8_t)seed );
 803a666:	f7ff beb3 	b.w	803a3d0 <SUBGRF_WriteRegister>
}
 803a66a:	bd10      	pop	{r4, pc}
 803a66c:	20005a80 	.word	0x20005a80

0803a670 <SUBGRF_SetTxParams>:
    if( paSelect == RFO_LP )
 803a670:	2801      	cmp	r0, #1
{
 803a672:	b537      	push	{r0, r1, r2, r4, r5, lr}
 803a674:	4603      	mov	r3, r0
 803a676:	460c      	mov	r4, r1
 803a678:	4615      	mov	r5, r2
    if( paSelect == RFO_LP )
 803a67a:	d120      	bne.n	803a6be <SUBGRF_SetTxParams+0x4e>
        if( power == 15 )
 803a67c:	2c0f      	cmp	r4, #15
            SUBGRF_SetPaConfig( 0x06, 0x00, 0x01, 0x01 );
 803a67e:	4602      	mov	r2, r0
 803a680:	f04f 0100 	mov.w	r1, #0
 803a684:	bf0c      	ite	eq
 803a686:	2006      	moveq	r0, #6
            SUBGRF_SetPaConfig( 0x04, 0x00, 0x01, 0x01 );
 803a688:	2004      	movne	r0, #4
 803a68a:	f7ff fdf3 	bl	803a274 <SUBGRF_SetPaConfig>
        if( power >= 14 )
 803a68e:	f06f 0110 	mvn.w	r1, #16
 803a692:	428c      	cmp	r4, r1
 803a694:	bfb8      	it	lt
 803a696:	460c      	movlt	r4, r1
 803a698:	2c0e      	cmp	r4, #14
 803a69a:	bfa8      	it	ge
 803a69c:	240e      	movge	r4, #14
        SUBGRF_WriteRegister( REG_OCP, 0x18 ); // current max is 80 mA for the whole device
 803a69e:	2118      	movs	r1, #24
        SUBGRF_WriteRegister( REG_OCP, 0x38 ); // current max 160mA for the whole device
 803a6a0:	f640 00e7 	movw	r0, #2279	; 0x8e7
 803a6a4:	f7ff fe94 	bl	803a3d0 <SUBGRF_WriteRegister>
    SUBGRF_WriteCommand( RADIO_SET_TXPARAMS, buf, 2 );
 803a6a8:	2202      	movs	r2, #2
 803a6aa:	a901      	add	r1, sp, #4
 803a6ac:	208e      	movs	r0, #142	; 0x8e
    buf[0] = power;
 803a6ae:	f88d 4004 	strb.w	r4, [sp, #4]
    buf[1] = ( uint8_t )rampTime;
 803a6b2:	f88d 5005 	strb.w	r5, [sp, #5]
    SUBGRF_WriteCommand( RADIO_SET_TXPARAMS, buf, 2 );
 803a6b6:	f7ff fce5 	bl	803a084 <SUBGRF_WriteCommand>
}
 803a6ba:	b003      	add	sp, #12
 803a6bc:	bd30      	pop	{r4, r5, pc}
        SUBGRF_WriteRegister( REG_TX_CLAMP, SUBGRF_ReadRegister( REG_TX_CLAMP ) | ( 0x0F << 1 ) );
 803a6be:	f640 00d8 	movw	r0, #2264	; 0x8d8
 803a6c2:	f7ff ff4b 	bl	803a55c <SUBGRF_ReadRegister>
 803a6c6:	f040 011e 	orr.w	r1, r0, #30
 803a6ca:	b2c9      	uxtb	r1, r1
 803a6cc:	f640 00d8 	movw	r0, #2264	; 0x8d8
 803a6d0:	f7ff fe7e 	bl	803a3d0 <SUBGRF_WriteRegister>
        SUBGRF_SetPaConfig( 0x04, 0x07, 0x00, 0x01 );
 803a6d4:	2107      	movs	r1, #7
 803a6d6:	2301      	movs	r3, #1
 803a6d8:	2200      	movs	r2, #0
 803a6da:	2004      	movs	r0, #4
 803a6dc:	f7ff fdca 	bl	803a274 <SUBGRF_SetPaConfig>
        if( power > 22 )
 803a6e0:	f06f 0108 	mvn.w	r1, #8
 803a6e4:	428c      	cmp	r4, r1
 803a6e6:	bfb8      	it	lt
 803a6e8:	460c      	movlt	r4, r1
 803a6ea:	2c16      	cmp	r4, #22
 803a6ec:	bfa8      	it	ge
 803a6ee:	2416      	movge	r4, #22
        SUBGRF_WriteRegister( REG_OCP, 0x38 ); // current max 160mA for the whole device
 803a6f0:	2138      	movs	r1, #56	; 0x38
 803a6f2:	e7d5      	b.n	803a6a0 <SUBGRF_SetTxParams+0x30>

0803a6f4 <SUBGRF_GetRxBufferStatus>:
{
 803a6f4:	b537      	push	{r0, r1, r2, r4, r5, lr}
    SUBGRF_ReadCommand( RADIO_GET_RXBUFFERSTATUS, status, 2 );
 803a6f6:	2202      	movs	r2, #2
{
 803a6f8:	4604      	mov	r4, r0
 803a6fa:	460d      	mov	r5, r1
    SUBGRF_ReadCommand( RADIO_GET_RXBUFFERSTATUS, status, 2 );
 803a6fc:	2013      	movs	r0, #19
 803a6fe:	a901      	add	r1, sp, #4
 803a700:	f7ff fcd0 	bl	803a0a4 <SUBGRF_ReadCommand>
    return PacketType;
 803a704:	4b0a      	ldr	r3, [pc, #40]	; (803a730 <SUBGRF_GetRxBufferStatus+0x3c>)
    if( ( SUBGRF_GetPacketType( ) == PACKET_TYPE_LORA ) && ( LoRaHeaderType == LORA_PACKET_FIXED_LENGTH ) )
 803a706:	789a      	ldrb	r2, [r3, #2]
 803a708:	2a01      	cmp	r2, #1
 803a70a:	d10c      	bne.n	803a726 <SUBGRF_GetRxBufferStatus+0x32>
 803a70c:	7b1b      	ldrb	r3, [r3, #12]
 803a70e:	2b01      	cmp	r3, #1
 803a710:	d109      	bne.n	803a726 <SUBGRF_GetRxBufferStatus+0x32>
        *payloadLength = SUBGRF_ReadRegister( REG_LR_PAYLOADLENGTH );
 803a712:	f240 7002 	movw	r0, #1794	; 0x702
 803a716:	f7ff ff21 	bl	803a55c <SUBGRF_ReadRegister>
 803a71a:	7020      	strb	r0, [r4, #0]
    *rxStartBufferPointer = status[1];
 803a71c:	f89d 3005 	ldrb.w	r3, [sp, #5]
 803a720:	702b      	strb	r3, [r5, #0]
}
 803a722:	b003      	add	sp, #12
 803a724:	bd30      	pop	{r4, r5, pc}
        *payloadLength = status[0];
 803a726:	f89d 3004 	ldrb.w	r3, [sp, #4]
 803a72a:	7023      	strb	r3, [r4, #0]
 803a72c:	e7f6      	b.n	803a71c <SUBGRF_GetRxBufferStatus+0x28>
 803a72e:	bf00      	nop
 803a730:	20005a80 	.word	0x20005a80

0803a734 <SUBGRF_WriteRegisters>:
{
 803a734:	b510      	push	{r4, lr}
 803a736:	4613      	mov	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803a738:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803a73c:	b672      	cpsid	i
    HAL_SUBGHZ_WriteRegisters( &hsubghz, address, buffer, size );
 803a73e:	460a      	mov	r2, r1
 803a740:	4601      	mov	r1, r0
 803a742:	4803      	ldr	r0, [pc, #12]	; (803a750 <SUBGRF_WriteRegisters+0x1c>)
 803a744:	f7f5 f94c 	bl	802f9e0 <HAL_SUBGHZ_WriteRegisters>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803a748:	f384 8810 	msr	PRIMASK, r4
}
 803a74c:	bd10      	pop	{r4, pc}
 803a74e:	bf00      	nop
 803a750:	200061f0 	.word	0x200061f0

0803a754 <SUBGRF_SetSyncWord>:
{
 803a754:	b508      	push	{r3, lr}
 803a756:	4601      	mov	r1, r0
    SUBGRF_WriteRegisters( REG_LR_SYNCWORDBASEADDRESS, syncWord, 8 );
 803a758:	2208      	movs	r2, #8
 803a75a:	f44f 60d8 	mov.w	r0, #1728	; 0x6c0
 803a75e:	f7ff ffe9 	bl	803a734 <SUBGRF_WriteRegisters>
}
 803a762:	2000      	movs	r0, #0
 803a764:	bd08      	pop	{r3, pc}
	...

0803a768 <SUBGRF_SetCrcSeed>:
{
 803a768:	b507      	push	{r0, r1, r2, lr}
    return PacketType;
 803a76a:	4b07      	ldr	r3, [pc, #28]	; (803a788 <SUBGRF_SetCrcSeed+0x20>)
    switch( SUBGRF_GetPacketType( ) )
 803a76c:	789b      	ldrb	r3, [r3, #2]
    buf[0] = ( uint8_t )( ( seed >> 8 ) & 0xFF );
 803a76e:	ba40      	rev16	r0, r0
 803a770:	f8ad 0004 	strh.w	r0, [sp, #4]
    switch( SUBGRF_GetPacketType( ) )
 803a774:	b92b      	cbnz	r3, 803a782 <SUBGRF_SetCrcSeed+0x1a>
            SUBGRF_WriteRegisters( REG_LR_CRCSEEDBASEADDR, buf, 2 );
 803a776:	2202      	movs	r2, #2
 803a778:	a901      	add	r1, sp, #4
 803a77a:	f240 60bc 	movw	r0, #1724	; 0x6bc
 803a77e:	f7ff ffd9 	bl	803a734 <SUBGRF_WriteRegisters>
}
 803a782:	b003      	add	sp, #12
 803a784:	f85d fb04 	ldr.w	pc, [sp], #4
 803a788:	20005a80 	.word	0x20005a80

0803a78c <SUBGRF_SetCrcPolynomial>:
{
 803a78c:	b507      	push	{r0, r1, r2, lr}
    return PacketType;
 803a78e:	4b07      	ldr	r3, [pc, #28]	; (803a7ac <SUBGRF_SetCrcPolynomial+0x20>)
    switch( SUBGRF_GetPacketType( ) )
 803a790:	789b      	ldrb	r3, [r3, #2]
    buf[0] = ( uint8_t )( ( polynomial >> 8 ) & 0xFF );
 803a792:	ba40      	rev16	r0, r0
 803a794:	f8ad 0004 	strh.w	r0, [sp, #4]
    switch( SUBGRF_GetPacketType( ) )
 803a798:	b92b      	cbnz	r3, 803a7a6 <SUBGRF_SetCrcPolynomial+0x1a>
            SUBGRF_WriteRegisters( REG_LR_CRCPOLYBASEADDR, buf, 2 );
 803a79a:	2202      	movs	r2, #2
 803a79c:	a901      	add	r1, sp, #4
 803a79e:	f240 60be 	movw	r0, #1726	; 0x6be
 803a7a2:	f7ff ffc7 	bl	803a734 <SUBGRF_WriteRegisters>
}
 803a7a6:	b003      	add	sp, #12
 803a7a8:	f85d fb04 	ldr.w	pc, [sp], #4
 803a7ac:	20005a80 	.word	0x20005a80

0803a7b0 <SUBGRF_SetPacketParams>:
{
 803a7b0:	b530      	push	{r4, r5, lr}
    uint8_t buf[9] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 803a7b2:	4a2e      	ldr	r2, [pc, #184]	; (803a86c <SUBGRF_SetPacketParams+0xbc>)
    if( PacketType != packetParams->PacketType )
 803a7b4:	4d2e      	ldr	r5, [pc, #184]	; (803a870 <SUBGRF_SetPacketParams+0xc0>)
    uint8_t buf[9] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 803a7b6:	6851      	ldr	r1, [r2, #4]
{
 803a7b8:	4604      	mov	r4, r0
 803a7ba:	b085      	sub	sp, #20
    uint8_t buf[9] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 803a7bc:	6810      	ldr	r0, [r2, #0]
 803a7be:	7a12      	ldrb	r2, [r2, #8]
 803a7c0:	ab01      	add	r3, sp, #4
 803a7c2:	c303      	stmia	r3!, {r0, r1}
    if( PacketType != packetParams->PacketType )
 803a7c4:	7820      	ldrb	r0, [r4, #0]
    uint8_t buf[9] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 803a7c6:	701a      	strb	r2, [r3, #0]
    if( PacketType != packetParams->PacketType )
 803a7c8:	78aa      	ldrb	r2, [r5, #2]
 803a7ca:	4282      	cmp	r2, r0
 803a7cc:	d001      	beq.n	803a7d2 <SUBGRF_SetPacketParams+0x22>
        SUBGRF_SetPacketType( packetParams->PacketType );
 803a7ce:	f7ff fe43 	bl	803a458 <SUBGRF_SetPacketType>
    switch( packetParams->PacketType )
 803a7d2:	7823      	ldrb	r3, [r4, #0]
 803a7d4:	2b03      	cmp	r3, #3
 803a7d6:	d826      	bhi.n	803a826 <SUBGRF_SetPacketParams+0x76>
 803a7d8:	e8df f003 	tbb	[pc, r3]
 803a7dc:	02333802 	.word	0x02333802
        if( packetParams->Params.Gfsk.CrcLength == RADIO_CRC_2_BYTES_IBM )
 803a7e0:	7a63      	ldrb	r3, [r4, #9]
 803a7e2:	2bf1      	cmp	r3, #241	; 0xf1
 803a7e4:	d121      	bne.n	803a82a <SUBGRF_SetPacketParams+0x7a>
            SUBGRF_SetCrcSeed( CRC_IBM_SEED );
 803a7e6:	f64f 70ff 	movw	r0, #65535	; 0xffff
 803a7ea:	f7ff ffbd 	bl	803a768 <SUBGRF_SetCrcSeed>
            SUBGRF_SetCrcPolynomial( CRC_POLYNOMIAL_IBM );
 803a7ee:	f248 0005 	movw	r0, #32773	; 0x8005
 803a7f2:	f7ff ffcb 	bl	803a78c <SUBGRF_SetCrcPolynomial>
            crcVal = RADIO_CRC_2_BYTES;
 803a7f6:	2302      	movs	r3, #2
        buf[0] = ( packetParams->Params.Gfsk.PreambleLength >> 8 ) & 0xFF;
 803a7f8:	8862      	ldrh	r2, [r4, #2]
        buf[2] = packetParams->Params.Gfsk.PreambleMinDetect;
 803a7fa:	88a1      	ldrh	r1, [r4, #4]
 803a7fc:	f8ad 1006 	strh.w	r1, [sp, #6]
        buf[0] = ( packetParams->Params.Gfsk.PreambleLength >> 8 ) & 0xFF;
 803a800:	ba52      	rev16	r2, r2
        buf[4] = packetParams->Params.Gfsk.AddrComp;
 803a802:	88e1      	ldrh	r1, [r4, #6]
        buf[0] = ( packetParams->Params.Gfsk.PreambleLength >> 8 ) & 0xFF;
 803a804:	f8ad 2004 	strh.w	r2, [sp, #4]
        buf[7] = crcVal;
 803a808:	f88d 300b 	strb.w	r3, [sp, #11]
        buf[6] = packetParams->Params.Gfsk.PayloadLength;
 803a80c:	7a22      	ldrb	r2, [r4, #8]
        buf[8] = packetParams->Params.Gfsk.DcFree;
 803a80e:	7aa3      	ldrb	r3, [r4, #10]
        buf[6] = packetParams->Params.Gfsk.PayloadLength;
 803a810:	f88d 200a 	strb.w	r2, [sp, #10]
        buf[4] = packetParams->Params.Gfsk.AddrComp;
 803a814:	f8ad 1008 	strh.w	r1, [sp, #8]
        buf[8] = packetParams->Params.Gfsk.DcFree;
 803a818:	f88d 300c 	strb.w	r3, [sp, #12]
        n = 9;
 803a81c:	2209      	movs	r2, #9
    SUBGRF_WriteCommand( RADIO_SET_PACKETPARAMS, buf, n );
 803a81e:	a901      	add	r1, sp, #4
 803a820:	208c      	movs	r0, #140	; 0x8c
 803a822:	f7ff fc2f 	bl	803a084 <SUBGRF_WriteCommand>
}
 803a826:	b005      	add	sp, #20
 803a828:	bd30      	pop	{r4, r5, pc}
        else if( packetParams->Params.Gfsk.CrcLength == RADIO_CRC_2_BYTES_CCIT )
 803a82a:	2bf2      	cmp	r3, #242	; 0xf2
 803a82c:	d1e4      	bne.n	803a7f8 <SUBGRF_SetPacketParams+0x48>
            SUBGRF_SetCrcSeed( CRC_CCITT_SEED );
 803a82e:	f641 500f 	movw	r0, #7439	; 0x1d0f
 803a832:	f7ff ff99 	bl	803a768 <SUBGRF_SetCrcSeed>
            SUBGRF_SetCrcPolynomial( CRC_POLYNOMIAL_CCITT );
 803a836:	f241 0021 	movw	r0, #4129	; 0x1021
 803a83a:	f7ff ffa7 	bl	803a78c <SUBGRF_SetCrcPolynomial>
            crcVal = RADIO_CRC_2_BYTES_INV;
 803a83e:	2306      	movs	r3, #6
 803a840:	e7da      	b.n	803a7f8 <SUBGRF_SetPacketParams+0x48>
        buf[0] = packetParams->Params.Bpsk.PayloadLength;
 803a842:	7b23      	ldrb	r3, [r4, #12]
 803a844:	f88d 3004 	strb.w	r3, [sp, #4]
        n = 1;
 803a848:	2201      	movs	r2, #1
        break;
 803a84a:	e7e8      	b.n	803a81e <SUBGRF_SetPacketParams+0x6e>
        buf[0] = ( packetParams->Params.LoRa.PreambleLength >> 8 ) & 0xFF;
 803a84c:	89e3      	ldrh	r3, [r4, #14]
 803a84e:	ba5b      	rev16	r3, r3
 803a850:	f8ad 3004 	strh.w	r3, [sp, #4]
        buf[2] = LoRaHeaderType = packetParams->Params.LoRa.HeaderType;
 803a854:	7c23      	ldrb	r3, [r4, #16]
 803a856:	732b      	strb	r3, [r5, #12]
 803a858:	f88d 3006 	strb.w	r3, [sp, #6]
        buf[3] = packetParams->Params.LoRa.PayloadLength;
 803a85c:	7c63      	ldrb	r3, [r4, #17]
 803a85e:	f88d 3007 	strb.w	r3, [sp, #7]
        buf[4] = packetParams->Params.LoRa.CrcMode;
 803a862:	8a63      	ldrh	r3, [r4, #18]
 803a864:	f8ad 3008 	strh.w	r3, [sp, #8]
        n = 6;
 803a868:	2206      	movs	r2, #6
        break;
 803a86a:	e7d8      	b.n	803a81e <SUBGRF_SetPacketParams+0x6e>
 803a86c:	0803bc64 	.word	0x0803bc64
 803a870:	20005a80 	.word	0x20005a80

0803a874 <SUBGRF_ReadRegisters>:
{
 803a874:	b510      	push	{r4, lr}
 803a876:	4613      	mov	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803a878:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803a87c:	b672      	cpsid	i
    HAL_SUBGHZ_ReadRegisters( &hsubghz, address, buffer, size );
 803a87e:	460a      	mov	r2, r1
 803a880:	4601      	mov	r1, r0
 803a882:	4803      	ldr	r0, [pc, #12]	; (803a890 <SUBGRF_ReadRegisters+0x1c>)
 803a884:	f7f5 f8e5 	bl	802fa52 <HAL_SUBGHZ_ReadRegisters>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803a888:	f384 8810 	msr	PRIMASK, r4
}
 803a88c:	bd10      	pop	{r4, pc}
 803a88e:	bf00      	nop
 803a890:	200061f0 	.word	0x200061f0

0803a894 <SUBGRF_GetRandom>:
{
 803a894:	b573      	push	{r0, r1, r4, r5, r6, lr}
    uint32_t number = 0;
 803a896:	2600      	movs	r6, #0
    regAnaLna = SUBGRF_ReadRegister( REG_ANA_LNA );
 803a898:	f640 00e2 	movw	r0, #2274	; 0x8e2
    uint32_t number = 0;
 803a89c:	9601      	str	r6, [sp, #4]
    regAnaLna = SUBGRF_ReadRegister( REG_ANA_LNA );
 803a89e:	f7ff fe5d 	bl	803a55c <SUBGRF_ReadRegister>
    SUBGRF_WriteRegister( REG_ANA_LNA, regAnaLna & ~( 1 << 0 ) );
 803a8a2:	f000 01fe 	and.w	r1, r0, #254	; 0xfe
    regAnaLna = SUBGRF_ReadRegister( REG_ANA_LNA );
 803a8a6:	4605      	mov	r5, r0
    SUBGRF_WriteRegister( REG_ANA_LNA, regAnaLna & ~( 1 << 0 ) );
 803a8a8:	f640 00e2 	movw	r0, #2274	; 0x8e2
 803a8ac:	f7ff fd90 	bl	803a3d0 <SUBGRF_WriteRegister>
    regAnaMixer = SUBGRF_ReadRegister( REG_ANA_MIXER );
 803a8b0:	f640 00e5 	movw	r0, #2277	; 0x8e5
 803a8b4:	f7ff fe52 	bl	803a55c <SUBGRF_ReadRegister>
    SUBGRF_WriteRegister( REG_ANA_MIXER, regAnaMixer & ~( 1 << 7 ) );
 803a8b8:	f000 017f 	and.w	r1, r0, #127	; 0x7f
    regAnaMixer = SUBGRF_ReadRegister( REG_ANA_MIXER );
 803a8bc:	4604      	mov	r4, r0
    SUBGRF_WriteRegister( REG_ANA_MIXER, regAnaMixer & ~( 1 << 7 ) );
 803a8be:	f640 00e5 	movw	r0, #2277	; 0x8e5
 803a8c2:	f7ff fd85 	bl	803a3d0 <SUBGRF_WriteRegister>
    SUBGRF_SetRx( 0xFFFFFF ); // Rx Continuous
 803a8c6:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 803a8ca:	f7ff fc2d 	bl	803a128 <SUBGRF_SetRx>
    SUBGRF_ReadRegisters( RANDOM_NUMBER_GENERATORBASEADDR, ( uint8_t* )&number, 4 );
 803a8ce:	2204      	movs	r2, #4
 803a8d0:	eb0d 0102 	add.w	r1, sp, r2
 803a8d4:	f640 0019 	movw	r0, #2073	; 0x819
 803a8d8:	f7ff ffcc 	bl	803a874 <SUBGRF_ReadRegisters>
    SUBGRF_SetStandby( STDBY_RC );
 803a8dc:	4630      	mov	r0, r6
 803a8de:	f7ff fbf7 	bl	803a0d0 <SUBGRF_SetStandby>
    SUBGRF_WriteRegister( REG_ANA_LNA, regAnaLna );
 803a8e2:	4629      	mov	r1, r5
 803a8e4:	f640 00e2 	movw	r0, #2274	; 0x8e2
 803a8e8:	f7ff fd72 	bl	803a3d0 <SUBGRF_WriteRegister>
    SUBGRF_WriteRegister( REG_ANA_MIXER, regAnaMixer );
 803a8ec:	4621      	mov	r1, r4
 803a8ee:	f640 00e5 	movw	r0, #2277	; 0x8e5
 803a8f2:	f7ff fd6d 	bl	803a3d0 <SUBGRF_WriteRegister>
}
 803a8f6:	9801      	ldr	r0, [sp, #4]
 803a8f8:	b002      	add	sp, #8
 803a8fa:	bd70      	pop	{r4, r5, r6, pc}

0803a8fc <SUBGRF_WriteBuffer>:
{
 803a8fc:	b510      	push	{r4, lr}
 803a8fe:	4613      	mov	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803a900:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803a904:	b672      	cpsid	i
    HAL_SUBGHZ_WriteBuffer( &hsubghz, offset, buffer, size );
 803a906:	460a      	mov	r2, r1
 803a908:	4601      	mov	r1, r0
 803a90a:	4803      	ldr	r0, [pc, #12]	; (803a918 <SUBGRF_WriteBuffer+0x1c>)
 803a90c:	f7f5 f914 	bl	802fb38 <HAL_SUBGHZ_WriteBuffer>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803a910:	f384 8810 	msr	PRIMASK, r4
}
 803a914:	bd10      	pop	{r4, pc}
 803a916:	bf00      	nop
 803a918:	200061f0 	.word	0x200061f0

0803a91c <SUBGRF_SetPayload>:
{
 803a91c:	460a      	mov	r2, r1
    SUBGRF_WriteBuffer( 0x00, payload, size );
 803a91e:	4601      	mov	r1, r0
 803a920:	2000      	movs	r0, #0
 803a922:	f7ff bfeb 	b.w	803a8fc <SUBGRF_WriteBuffer>

0803a926 <SUBGRF_SendPayload>:
{
 803a926:	b510      	push	{r4, lr}
 803a928:	4614      	mov	r4, r2
    SUBGRF_SetPayload( payload, size );
 803a92a:	f7ff fff7 	bl	803a91c <SUBGRF_SetPayload>
    SUBGRF_SetTx( timeout );
 803a92e:	4620      	mov	r0, r4
}
 803a930:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    SUBGRF_SetTx( timeout );
 803a934:	f7ff bbe2 	b.w	803a0fc <SUBGRF_SetTx>

0803a938 <SUBGRF_ReadBuffer>:
{
 803a938:	b510      	push	{r4, lr}
 803a93a:	4613      	mov	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803a93c:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803a940:	b672      	cpsid	i
    HAL_SUBGHZ_ReadBuffer( &hsubghz, offset, buffer, size );
 803a942:	460a      	mov	r2, r1
 803a944:	4601      	mov	r1, r0
 803a946:	4803      	ldr	r0, [pc, #12]	; (803a954 <SUBGRF_ReadBuffer+0x1c>)
 803a948:	f7f5 f929 	bl	802fb9e <HAL_SUBGHZ_ReadBuffer>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803a94c:	f384 8810 	msr	PRIMASK, r4
}
 803a950:	bd10      	pop	{r4, pc}
 803a952:	bf00      	nop
 803a954:	200061f0 	.word	0x200061f0

0803a958 <SUBGRF_GetPayload>:
{
 803a958:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 803a95a:	460d      	mov	r5, r1
 803a95c:	4606      	mov	r6, r0
    uint8_t offset = 0;
 803a95e:	2400      	movs	r4, #0
    SUBGRF_GetRxBufferStatus( size, &offset );
 803a960:	f10d 0107 	add.w	r1, sp, #7
 803a964:	4628      	mov	r0, r5
{
 803a966:	4617      	mov	r7, r2
    uint8_t offset = 0;
 803a968:	f88d 4007 	strb.w	r4, [sp, #7]
    SUBGRF_GetRxBufferStatus( size, &offset );
 803a96c:	f7ff fec2 	bl	803a6f4 <SUBGRF_GetRxBufferStatus>
    if( *size > maxSize )
 803a970:	782a      	ldrb	r2, [r5, #0]
 803a972:	42ba      	cmp	r2, r7
 803a974:	d807      	bhi.n	803a986 <SUBGRF_GetPayload+0x2e>
    SUBGRF_ReadBuffer( offset, buffer, *size );
 803a976:	f89d 0007 	ldrb.w	r0, [sp, #7]
 803a97a:	4631      	mov	r1, r6
 803a97c:	f7ff ffdc 	bl	803a938 <SUBGRF_ReadBuffer>
    return 0;
 803a980:	4620      	mov	r0, r4
}
 803a982:	b003      	add	sp, #12
 803a984:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return 1;
 803a986:	2001      	movs	r0, #1
 803a988:	e7fb      	b.n	803a982 <SUBGRF_GetPayload+0x2a>

0803a98a <SUBGRF_SetSwitch>:
    if (rxtx == RFSWITCH_TX)
 803a98a:	2901      	cmp	r1, #1
{
 803a98c:	b508      	push	{r3, lr}
 803a98e:	4603      	mov	r3, r0
 803a990:	4608      	mov	r0, r1
    if (rxtx == RFSWITCH_TX)
 803a992:	d10e      	bne.n	803a9b2 <SUBGRF_SetSwitch+0x28>
        if (paSelect == RFO_LP)
 803a994:	2b01      	cmp	r3, #1
 803a996:	d107      	bne.n	803a9a8 <SUBGRF_SetSwitch+0x1e>
            Radio_SMPS_Set(SMPS_DRIVE_SETTING_MAX);
 803a998:	2004      	movs	r0, #4
 803a99a:	f7ff fdef 	bl	803a57c <Radio_SMPS_Set>
            state = RBI_SWITCH_RFO_LP;
 803a99e:	2002      	movs	r0, #2
}
 803a9a0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RBI_ConfigRFSwitch(state);
 803a9a4:	f7f2 bbc2 	b.w	802d12c <RBI_ConfigRFSwitch>
        if (paSelect == RFO_HP)
 803a9a8:	2b02      	cmp	r3, #2
            state = RBI_SWITCH_RFO_HP;
 803a9aa:	bf14      	ite	ne
 803a9ac:	4608      	movne	r0, r1
 803a9ae:	2003      	moveq	r0, #3
 803a9b0:	e7f6      	b.n	803a9a0 <SUBGRF_SetSwitch+0x16>
    RBI_Switch_TypeDef state = RBI_SWITCH_RX;
 803a9b2:	2001      	movs	r0, #1
 803a9b4:	e7f4      	b.n	803a9a0 <SUBGRF_SetSwitch+0x16>

0803a9b6 <SUBGRF_SetRfTxPower>:
{
 803a9b6:	b538      	push	{r3, r4, r5, lr}
 803a9b8:	4604      	mov	r4, r0
    int32_t TxConfig = RBI_GetTxConfig();
 803a9ba:	f7f2 fbb9 	bl	802d130 <RBI_GetTxConfig>
    switch (TxConfig)
 803a9be:	b150      	cbz	r0, 803a9d6 <SUBGRF_SetRfTxPower+0x20>
 803a9c0:	2802      	cmp	r0, #2
 803a9c2:	bf14      	ite	ne
 803a9c4:	2501      	movne	r5, #1
 803a9c6:	2502      	moveq	r5, #2
    SUBGRF_SetTxParams( paSelect, power, RADIO_RAMP_40_US );
 803a9c8:	4628      	mov	r0, r5
 803a9ca:	2202      	movs	r2, #2
 803a9cc:	4621      	mov	r1, r4
 803a9ce:	f7ff fe4f 	bl	803a670 <SUBGRF_SetTxParams>
}
 803a9d2:	4628      	mov	r0, r5
 803a9d4:	bd38      	pop	{r3, r4, r5, pc}
            if (power > 15)
 803a9d6:	2c0f      	cmp	r4, #15
                paSelect = RFO_LP;
 803a9d8:	bfcc      	ite	gt
 803a9da:	2502      	movgt	r5, #2
 803a9dc:	2501      	movle	r5, #1
 803a9de:	e7f3      	b.n	803a9c8 <SUBGRF_SetRfTxPower+0x12>

0803a9e0 <SUBGRF_GetRadioWakeUpTime>:
}
 803a9e0:	2001      	movs	r0, #1
 803a9e2:	4770      	bx	lr

0803a9e4 <HAL_SUBGHZ_TxCpltCallback>:
    RadioOnDioIrqCb( IRQ_TX_DONE );
 803a9e4:	4b01      	ldr	r3, [pc, #4]	; (803a9ec <HAL_SUBGHZ_TxCpltCallback+0x8>)
 803a9e6:	2001      	movs	r0, #1
 803a9e8:	689b      	ldr	r3, [r3, #8]
 803a9ea:	4718      	bx	r3
 803a9ec:	20005a80 	.word	0x20005a80

0803a9f0 <HAL_SUBGHZ_RxCpltCallback>:
    RadioOnDioIrqCb( IRQ_RX_DONE );
 803a9f0:	4b01      	ldr	r3, [pc, #4]	; (803a9f8 <HAL_SUBGHZ_RxCpltCallback+0x8>)
 803a9f2:	2002      	movs	r0, #2
 803a9f4:	689b      	ldr	r3, [r3, #8]
 803a9f6:	4718      	bx	r3
 803a9f8:	20005a80 	.word	0x20005a80

0803a9fc <HAL_SUBGHZ_CRCErrorCallback>:
    RadioOnDioIrqCb( IRQ_CRC_ERROR);
 803a9fc:	4b01      	ldr	r3, [pc, #4]	; (803aa04 <HAL_SUBGHZ_CRCErrorCallback+0x8>)
 803a9fe:	2040      	movs	r0, #64	; 0x40
 803aa00:	689b      	ldr	r3, [r3, #8]
 803aa02:	4718      	bx	r3
 803aa04:	20005a80 	.word	0x20005a80

0803aa08 <HAL_SUBGHZ_CADStatusCallback>:
    switch (cadstatus)
 803aa08:	b111      	cbz	r1, 803aa10 <HAL_SUBGHZ_CADStatusCallback+0x8>
 803aa0a:	2901      	cmp	r1, #1
 803aa0c:	d004      	beq.n	803aa18 <HAL_SUBGHZ_CADStatusCallback+0x10>
 803aa0e:	4770      	bx	lr
            RadioOnDioIrqCb( IRQ_CAD_CLEAR);
 803aa10:	4b04      	ldr	r3, [pc, #16]	; (803aa24 <HAL_SUBGHZ_CADStatusCallback+0x1c>)
 803aa12:	689b      	ldr	r3, [r3, #8]
 803aa14:	2080      	movs	r0, #128	; 0x80
            RadioOnDioIrqCb( IRQ_CAD_DETECTED);
 803aa16:	4718      	bx	r3
 803aa18:	4b02      	ldr	r3, [pc, #8]	; (803aa24 <HAL_SUBGHZ_CADStatusCallback+0x1c>)
 803aa1a:	f44f 7080 	mov.w	r0, #256	; 0x100
 803aa1e:	689b      	ldr	r3, [r3, #8]
 803aa20:	e7f9      	b.n	803aa16 <HAL_SUBGHZ_CADStatusCallback+0xe>
 803aa22:	bf00      	nop
 803aa24:	20005a80 	.word	0x20005a80

0803aa28 <HAL_SUBGHZ_RxTxTimeoutCallback>:
    RadioOnDioIrqCb( IRQ_RX_TX_TIMEOUT );
 803aa28:	4b02      	ldr	r3, [pc, #8]	; (803aa34 <HAL_SUBGHZ_RxTxTimeoutCallback+0xc>)
 803aa2a:	f44f 7000 	mov.w	r0, #512	; 0x200
 803aa2e:	689b      	ldr	r3, [r3, #8]
 803aa30:	4718      	bx	r3
 803aa32:	bf00      	nop
 803aa34:	20005a80 	.word	0x20005a80

0803aa38 <HAL_SUBGHZ_HeaderErrorCallback>:
    RadioOnDioIrqCb( IRQ_HEADER_ERROR );
 803aa38:	4b01      	ldr	r3, [pc, #4]	; (803aa40 <HAL_SUBGHZ_HeaderErrorCallback+0x8>)
 803aa3a:	2020      	movs	r0, #32
 803aa3c:	689b      	ldr	r3, [r3, #8]
 803aa3e:	4718      	bx	r3
 803aa40:	20005a80 	.word	0x20005a80

0803aa44 <HAL_SUBGHZ_PreambleDetectedCallback>:
    RadioOnDioIrqCb( IRQ_PREAMBLE_DETECTED );
 803aa44:	4b01      	ldr	r3, [pc, #4]	; (803aa4c <HAL_SUBGHZ_PreambleDetectedCallback+0x8>)
 803aa46:	2004      	movs	r0, #4
 803aa48:	689b      	ldr	r3, [r3, #8]
 803aa4a:	4718      	bx	r3
 803aa4c:	20005a80 	.word	0x20005a80

0803aa50 <HAL_SUBGHZ_SyncWordValidCallback>:
    RadioOnDioIrqCb( IRQ_SYNCWORD_VALID );
 803aa50:	4b01      	ldr	r3, [pc, #4]	; (803aa58 <HAL_SUBGHZ_SyncWordValidCallback+0x8>)
 803aa52:	2008      	movs	r0, #8
 803aa54:	689b      	ldr	r3, [r3, #8]
 803aa56:	4718      	bx	r3
 803aa58:	20005a80 	.word	0x20005a80

0803aa5c <HAL_SUBGHZ_HeaderValidCallback>:
    RadioOnDioIrqCb( IRQ_HEADER_VALID );
 803aa5c:	4b01      	ldr	r3, [pc, #4]	; (803aa64 <HAL_SUBGHZ_HeaderValidCallback+0x8>)
 803aa5e:	2010      	movs	r0, #16
 803aa60:	689b      	ldr	r3, [r3, #8]
 803aa62:	4718      	bx	r3
 803aa64:	20005a80 	.word	0x20005a80

0803aa68 <SUBGRF_GetFskBandwidthRegValue>:

uint8_t SUBGRF_GetFskBandwidthRegValue( uint32_t bandwidth )
{
 803aa68:	b510      	push	{r4, lr}
    uint8_t i;

    if( bandwidth == 0 )
 803aa6a:	b178      	cbz	r0, 803aa8c <SUBGRF_GetFskBandwidthRegValue+0x24>
    }

    /* ST_WORKAROUND_BEGIN: Simplified loop */
    for( i = 0; i < ( sizeof( FskBandwidths ) / sizeof( FskBandwidth_t ) ); i++ )
    {
        if ( bandwidth < FskBandwidths[i].bandwidth )
 803aa6c:	4a08      	ldr	r2, [pc, #32]	; (803aa90 <SUBGRF_GetFskBandwidthRegValue+0x28>)
 803aa6e:	2300      	movs	r3, #0
 803aa70:	f102 0114 	add.w	r1, r2, #20
 803aa74:	f851 4033 	ldr.w	r4, [r1, r3, lsl #3]
 803aa78:	4284      	cmp	r4, r0
 803aa7a:	d903      	bls.n	803aa84 <SUBGRF_GetFskBandwidthRegValue+0x1c>
        {
            return FskBandwidths[i].RegValue;
 803aa7c:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 803aa80:	7e18      	ldrb	r0, [r3, #24]
        }
    }
    /* ST_WORKAROUND_END */
    // ERROR: Value not found
    while( 1 );
}
 803aa82:	bd10      	pop	{r4, pc}
    for( i = 0; i < ( sizeof( FskBandwidths ) / sizeof( FskBandwidth_t ) ); i++ )
 803aa84:	3301      	adds	r3, #1
 803aa86:	2b16      	cmp	r3, #22
 803aa88:	d1f4      	bne.n	803aa74 <SUBGRF_GetFskBandwidthRegValue+0xc>
    while( 1 );
 803aa8a:	e7fe      	b.n	803aa8a <SUBGRF_GetFskBandwidthRegValue+0x22>
        return( 0x1F );
 803aa8c:	201f      	movs	r0, #31
 803aa8e:	e7f8      	b.n	803aa82 <SUBGRF_GetFskBandwidthRegValue+0x1a>
 803aa90:	0803bc5c 	.word	0x0803bc5c

0803aa94 <SUBGRF_GetCFO>:
void SUBGRF_GetCFO( uint32_t bitRate, int32_t *cfo)
{
 803aa94:	b573      	push	{r0, r1, r4, r5, r6, lr}
  uint8_t BwMant[] = {4, 8, 10, 12};
 803aa96:	4b1d      	ldr	r3, [pc, #116]	; (803ab0c <SUBGRF_GetCFO+0x78>)
 803aa98:	9301      	str	r3, [sp, #4]
{
 803aa9a:	4604      	mov	r4, r0
  /* read demod bandwidth: mant bit4:3, exp bits 2:0 */
  uint8_t reg = (SUBGRF_ReadRegister( SUBGHZ_BWSEL ));
 803aa9c:	f640 0007 	movw	r0, #2055	; 0x807
{
 803aaa0:	460d      	mov	r5, r1
  uint8_t reg = (SUBGRF_ReadRegister( SUBGHZ_BWSEL ));
 803aaa2:	f7ff fd5b 	bl	803a55c <SUBGRF_ReadRegister>
  uint8_t bandwidth_mant = BwMant[( reg >> 3 ) & 0x3];
 803aaa6:	aa02      	add	r2, sp, #8
 803aaa8:	f3c0 03c1 	ubfx	r3, r0, #3, #2
 803aaac:	4413      	add	r3, r2
  uint8_t bandwidth_exp = reg & 0x7;
  uint32_t cf_fs = XTAL_FREQ / ( bandwidth_mant * ( 1 << ( bandwidth_exp - 1 )));
 803aaae:	f813 2c04 	ldrb.w	r2, [r3, #-4]
 803aab2:	f000 0307 	and.w	r3, r0, #7
 803aab6:	3b01      	subs	r3, #1
 803aab8:	fa02 f003 	lsl.w	r0, r2, r3
 803aabc:	4b14      	ldr	r3, [pc, #80]	; (803ab10 <SUBGRF_GetCFO+0x7c>)
 803aabe:	fbb3 f3f0 	udiv	r3, r3, r0
  uint32_t cf_osr = cf_fs / bitRate;
 803aac2:	fbb3 f0f4 	udiv	r0, r3, r4
  uint8_t interp = 1;
  /* calculate demod interpolation factor */
  if (cf_osr * interp < 8)
 803aac6:	2807      	cmp	r0, #7
 803aac8:	d81d      	bhi.n	803ab06 <SUBGRF_GetCFO+0x72>
  {
    interp = 2;
  }
  if (cf_osr * interp < 4)
 803aaca:	0040      	lsls	r0, r0, #1
  {
    interp = 4;
 803aacc:	2803      	cmp	r0, #3
 803aace:	bf8c      	ite	hi
 803aad0:	2402      	movhi	r4, #2
 803aad2:	2404      	movls	r4, #4
  }
  /* calculate demod sampling frequency */
  uint32_t fs = cf_fs* interp;
  /* get the cfo registers */
  int32_t cfo_bin = ( SUBGRF_ReadRegister( SUBGHZ_CFO_H ) & 0xF ) << 8;
 803aad4:	f44f 60d6 	mov.w	r0, #1712	; 0x6b0
  uint32_t fs = cf_fs* interp;
 803aad8:	435c      	muls	r4, r3
  int32_t cfo_bin = ( SUBGRF_ReadRegister( SUBGHZ_CFO_H ) & 0xF ) << 8;
 803aada:	f7ff fd3f 	bl	803a55c <SUBGRF_ReadRegister>
 803aade:	0200      	lsls	r0, r0, #8
 803aae0:	f400 6670 	and.w	r6, r0, #3840	; 0xf00
  cfo_bin |= SUBGRF_ReadRegister( SUBGHZ_CFO_L );
 803aae4:	f240 60b1 	movw	r0, #1713	; 0x6b1
 803aae8:	f7ff fd38 	bl	803a55c <SUBGRF_ReadRegister>
 803aaec:	4330      	orrs	r0, r6
  /* negate if 12 bits sign bit is 1 */
  if (( cfo_bin & 0x800 ) == 0x800 )
 803aaee:	0503      	lsls	r3, r0, #20
  {
    cfo_bin |= 0xFFFFF000;
 803aaf0:	bf44      	itt	mi
 803aaf2:	ea6f 5000 	mvnmi.w	r0, r0, lsl #20
 803aaf6:	ea6f 5010 	mvnmi.w	r0, r0, lsr #20
  }
  /* calculate cfo in Hz */
  /* shift by 5 first to not saturate, cfo_bin on 12bits */
  *cfo = ((int32_t)( cfo_bin * ( fs >> 5 ))) >> ( 12 - 5 );
 803aafa:	0963      	lsrs	r3, r4, #5
 803aafc:	4358      	muls	r0, r3
 803aafe:	11c0      	asrs	r0, r0, #7
 803ab00:	6028      	str	r0, [r5, #0]
}
 803ab02:	b002      	add	sp, #8
 803ab04:	bd70      	pop	{r4, r5, r6, pc}
  uint8_t interp = 1;
 803ab06:	2401      	movs	r4, #1
 803ab08:	e7e4      	b.n	803aad4 <SUBGRF_GetCFO+0x40>
 803ab0a:	bf00      	nop
 803ab0c:	0c0a0804 	.word	0x0c0a0804
 803ab10:	01e84800 	.word	0x01e84800

0803ab14 <RFW_TransmitLongPacket>:
  }
#else
  status= -1;
#endif
  return status;
}
 803ab14:	f04f 30ff 	mov.w	r0, #4294967295
 803ab18:	4770      	bx	lr

0803ab1a <RFW_ReceiveLongPacket>:
  }
#else
  status= -1;
#endif
  return status;
}
 803ab1a:	f04f 30ff 	mov.w	r0, #4294967295
 803ab1e:	4770      	bx	lr

0803ab20 <RFW_Init>:
  TimerInit( &RFWPacket.Timer, RFW_GetPayloadTimerEvent );
  return 0;
#else
  return -1;
#endif
}
 803ab20:	f04f 30ff 	mov.w	r0, #4294967295
 803ab24:	4770      	bx	lr

0803ab26 <RFW_DeInit>:
void RFW_DeInit( void)
{
#if (RFW_ENABLE ==1 )
  RFWPacket.Init.Enable=0; /*Disable the RFWPacket decoding*/
#endif
}
 803ab26:	4770      	bx	lr

0803ab28 <RFW_Is_Init>:
#if (RFW_ENABLE ==1 )
  return RFWPacket.Init.Enable;
#else
  return 0;
#endif
}
 803ab28:	2000      	movs	r0, #0
 803ab2a:	4770      	bx	lr

0803ab2c <RFW_Is_LongPacketModeEnabled>:
 803ab2c:	2000      	movs	r0, #0
 803ab2e:	4770      	bx	lr

0803ab30 <RFW_SetAntSwitch>:
 803ab30:	4770      	bx	lr

0803ab32 <RFW_TransmitInit>:
    
    status= 0;
  }
#endif
  return status;
}
 803ab32:	f04f 30ff 	mov.w	r0, #4294967295
 803ab36:	4770      	bx	lr

0803ab38 <RFW_ReceiveInit>:
  RFWPacket.LongPacketModeEnable=0;
  return 0;
#else
  return -1;
#endif
}
 803ab38:	f04f 30ff 	mov.w	r0, #4294967295
 803ab3c:	4770      	bx	lr

0803ab3e <RFW_DeInit_TxLongPacket>:
 803ab3e:	4770      	bx	lr

0803ab40 <RFW_ReceivePayload>:
 803ab40:	4770      	bx	lr

0803ab42 <RFW_SetRadioModem>:
void RFW_SetRadioModem(RadioModems_t Modem)
{
#if (RFW_ENABLE ==1 )
  RFWPacket.Init.Modem= Modem;
#endif
}
 803ab42:	4770      	bx	lr

0803ab44 <TRACE_AllocateBufer>:
 * @param  Size to allocate within fifo
 * @param  Pos position within the fifo
 * @retval write position inside the buffer is -1 no space available.
 */
static int16_t TRACE_AllocateBufer(uint16_t Size, uint16_t *Pos)
{
 803ab44:	b570      	push	{r4, r5, r6, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803ab46:	f3ef 8610 	mrs	r6, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803ab4a:	b672      	cpsid	i
  uint16_t freesize;
  int16_t ret = -1;

  UTIL_ADV_TRACE_ENTER_CRITICAL_SECTION();

  if(ADV_TRACE_Ctx.TraceWrPtr == ADV_TRACE_Ctx.TraceRdPtr)
 803ab4c:	4b14      	ldr	r3, [pc, #80]	; (803aba0 <TRACE_AllocateBufer+0x5c>)
 803ab4e:	8a5c      	ldrh	r4, [r3, #18]
 803ab50:	8a1a      	ldrh	r2, [r3, #16]
 803ab52:	4294      	cmp	r4, r2
 803ab54:	d113      	bne.n	803ab7e <TRACE_AllocateBufer+0x3a>
  {
#ifdef UTIL_ADV_TRACE_UNCHUNK_MODE
    freesize = (uint16_t)(UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceWrPtr);
 803ab56:	f5c4 6280 	rsb	r2, r4, #1024	; 0x400
    if((Size >= freesize) && (ADV_TRACE_Ctx.TraceRdPtr > Size))
 803ab5a:	b292      	uxth	r2, r2
 803ab5c:	4290      	cmp	r0, r2
 803ab5e:	d306      	bcc.n	803ab6e <TRACE_AllocateBufer+0x2a>
 803ab60:	4284      	cmp	r4, r0
  {
#ifdef UTIL_ADV_TRACE_UNCHUNK_MODE
    if (ADV_TRACE_Ctx.TraceWrPtr > ADV_TRACE_Ctx.TraceRdPtr)
    {
      freesize = (uint16_t)(UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceWrPtr);
      if((Size >= freesize) && (ADV_TRACE_Ctx.TraceRdPtr > Size)) 
 803ab62:	d918      	bls.n	803ab96 <TRACE_AllocateBufer+0x52>
      {
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_DETECTED;
 803ab64:	2201      	movs	r2, #1
 803ab66:	709a      	strb	r2, [r3, #2]
        ADV_TRACE_Ctx.unchunk_enabled = ADV_TRACE_Ctx.TraceWrPtr;
        freesize = ADV_TRACE_Ctx.TraceRdPtr;
        ADV_TRACE_Ctx.TraceWrPtr = 0;
 803ab68:	2200      	movs	r2, #0
        ADV_TRACE_Ctx.unchunk_enabled = ADV_TRACE_Ctx.TraceWrPtr;
 803ab6a:	801c      	strh	r4, [r3, #0]
        ADV_TRACE_Ctx.TraceWrPtr = 0;
 803ab6c:	825a      	strh	r2, [r3, #18]
#endif
  }

  if(freesize > Size)
  {
    *Pos = ADV_TRACE_Ctx.TraceWrPtr;
 803ab6e:	8a5a      	ldrh	r2, [r3, #18]
 803ab70:	800a      	strh	r2, [r1, #0]
    ADV_TRACE_Ctx.TraceWrPtr = (ADV_TRACE_Ctx.TraceWrPtr + Size) % UTIL_ADV_TRACE_FIFO_SIZE;
 803ab72:	4410      	add	r0, r2
 803ab74:	f3c0 0009 	ubfx	r0, r0, #0, #10
 803ab78:	8258      	strh	r0, [r3, #18]
    ret = 0;
 803ab7a:	2000      	movs	r0, #0
 803ab7c:	e00d      	b.n	803ab9a <TRACE_AllocateBufer+0x56>
    if (ADV_TRACE_Ctx.TraceWrPtr > ADV_TRACE_Ctx.TraceRdPtr)
 803ab7e:	d906      	bls.n	803ab8e <TRACE_AllocateBufer+0x4a>
      freesize = (uint16_t)(UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceWrPtr);
 803ab80:	f5c4 6580 	rsb	r5, r4, #1024	; 0x400
      if((Size >= freesize) && (ADV_TRACE_Ctx.TraceRdPtr > Size)) 
 803ab84:	b2ad      	uxth	r5, r5
 803ab86:	4285      	cmp	r5, r0
 803ab88:	d8f1      	bhi.n	803ab6e <TRACE_AllocateBufer+0x2a>
 803ab8a:	4282      	cmp	r2, r0
 803ab8c:	e7e9      	b.n	803ab62 <TRACE_AllocateBufer+0x1e>
      freesize = (uint16_t)(ADV_TRACE_Ctx.TraceRdPtr - ADV_TRACE_Ctx.TraceWrPtr);
 803ab8e:	1b12      	subs	r2, r2, r4
  if(freesize > Size)
 803ab90:	b292      	uxth	r2, r2
 803ab92:	4282      	cmp	r2, r0
 803ab94:	d8eb      	bhi.n	803ab6e <TRACE_AllocateBufer+0x2a>
  int16_t ret = -1;
 803ab96:	f04f 30ff 	mov.w	r0, #4294967295
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803ab9a:	f386 8810 	msr	PRIMASK, r6
  }
#endif

  UTIL_ADV_TRACE_EXIT_CRITICAL_SECTION();
  return ret;
}
 803ab9e:	bd70      	pop	{r4, r5, r6, pc}
 803aba0:	20005a90 	.word	0x20005a90

0803aba4 <TRACE_Lock>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803aba4:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803aba8:	b672      	cpsid	i
 * @retval None.
 */
static void TRACE_Lock(void)
{
  UTIL_ADV_TRACE_ENTER_CRITICAL_SECTION();
  ADV_TRACE_Ctx.TraceLock++;
 803abaa:	4a03      	ldr	r2, [pc, #12]	; (803abb8 <TRACE_Lock+0x14>)
 803abac:	8ad3      	ldrh	r3, [r2, #22]
 803abae:	3301      	adds	r3, #1
 803abb0:	82d3      	strh	r3, [r2, #22]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803abb2:	f381 8810 	msr	PRIMASK, r1
  UTIL_ADV_TRACE_EXIT_CRITICAL_SECTION();
}
 803abb6:	4770      	bx	lr
 803abb8:	20005a90 	.word	0x20005a90

0803abbc <TRACE_UnLock>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803abbc:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803abc0:	b672      	cpsid	i
 * @retval None.
 */
static void TRACE_UnLock(void)
{
  UTIL_ADV_TRACE_ENTER_CRITICAL_SECTION();
  ADV_TRACE_Ctx.TraceLock--;
 803abc2:	4a03      	ldr	r2, [pc, #12]	; (803abd0 <TRACE_UnLock+0x14>)
 803abc4:	8ad3      	ldrh	r3, [r2, #22]
 803abc6:	3b01      	subs	r3, #1
 803abc8:	82d3      	strh	r3, [r2, #22]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803abca:	f381 8810 	msr	PRIMASK, r1
  UTIL_ADV_TRACE_EXIT_CRITICAL_SECTION();
}
 803abce:	4770      	bx	lr
 803abd0:	20005a90 	.word	0x20005a90

0803abd4 <UTIL_ADV_TRACE_Init>:
{
 803abd4:	b510      	push	{r4, lr}
  (void)UTIL_ADV_TRACE_MEMSET8(&ADV_TRACE_Ctx, 0x0, sizeof(ADV_TRACE_Context));
 803abd6:	4c09      	ldr	r4, [pc, #36]	; (803abfc <UTIL_ADV_TRACE_Init+0x28>)
 803abd8:	2218      	movs	r2, #24
 803abda:	4620      	mov	r0, r4
 803abdc:	2100      	movs	r1, #0
 803abde:	f000 f973 	bl	803aec8 <UTIL_MEM_set_8>
  (void)UTIL_ADV_TRACE_MEMSET8(&ADV_TRACE_Buffer, 0x0, sizeof(ADV_TRACE_Buffer));
 803abe2:	f104 0018 	add.w	r0, r4, #24
 803abe6:	f44f 6280 	mov.w	r2, #1024	; 0x400
 803abea:	2100      	movs	r1, #0
 803abec:	f000 f96c 	bl	803aec8 <UTIL_MEM_set_8>
  return UTIL_TraceDriver.Init(TRACE_TxCpltCallback);
 803abf0:	4b03      	ldr	r3, [pc, #12]	; (803ac00 <UTIL_ADV_TRACE_Init+0x2c>)
 803abf2:	4804      	ldr	r0, [pc, #16]	; (803ac04 <UTIL_ADV_TRACE_Init+0x30>)
 803abf4:	681b      	ldr	r3, [r3, #0]
}
 803abf6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return UTIL_TraceDriver.Init(TRACE_TxCpltCallback);
 803abfa:	4718      	bx	r3
 803abfc:	20005a90 	.word	0x20005a90
 803ac00:	0803b8b0 	.word	0x0803b8b0
 803ac04:	0803ad75 	.word	0x0803ad75

0803ac08 <UTIL_ADV_TRACE_RegisterTimeStampFunction>:
  ADV_TRACE_Ctx.timestamp_func = *cb;
 803ac08:	4b01      	ldr	r3, [pc, #4]	; (803ac10 <UTIL_ADV_TRACE_RegisterTimeStampFunction+0x8>)
 803ac0a:	6058      	str	r0, [r3, #4]
}
 803ac0c:	4770      	bx	lr
 803ac0e:	bf00      	nop
 803ac10:	20005a90 	.word	0x20005a90

0803ac14 <UTIL_ADV_TRACE_SetVerboseLevel>:
  ADV_TRACE_Ctx.CurrentVerboseLevel = Level;
 803ac14:	4b01      	ldr	r3, [pc, #4]	; (803ac1c <UTIL_ADV_TRACE_SetVerboseLevel+0x8>)
 803ac16:	7218      	strb	r0, [r3, #8]
}
 803ac18:	4770      	bx	lr
 803ac1a:	bf00      	nop
 803ac1c:	20005a90 	.word	0x20005a90

0803ac20 <TRACE_Send>:
{
 803ac20:	b573      	push	{r0, r1, r4, r5, r6, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803ac22:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803ac26:	b672      	cpsid	i
 * @brief  UnLock the trace buffer.
 * @retval None.
 */
static uint32_t TRACE_IsLocked(void)
{
  return (ADV_TRACE_Ctx.TraceLock == 0u? 0u: 1u);
 803ac28:	4c1b      	ldr	r4, [pc, #108]	; (803ac98 <TRACE_Send+0x78>)
  if(TRACE_IsLocked() == 0u)
 803ac2a:	8ae0      	ldrh	r0, [r4, #22]
 803ac2c:	2800      	cmp	r0, #0
 803ac2e:	d12e      	bne.n	803ac8e <TRACE_Send+0x6e>
    TRACE_Lock();
 803ac30:	f7ff ffb8 	bl	803aba4 <TRACE_Lock>
    if(ADV_TRACE_Ctx.TraceRdPtr != ADV_TRACE_Ctx.TraceWrPtr)
 803ac34:	8a26      	ldrh	r6, [r4, #16]
 803ac36:	8a62      	ldrh	r2, [r4, #18]
 803ac38:	4296      	cmp	r6, r2
 803ac3a:	d026      	beq.n	803ac8a <TRACE_Send+0x6a>
      if(TRACE_UNCHUNK_DETECTED == ADV_TRACE_Ctx.unchunk_status)
 803ac3c:	78a1      	ldrb	r1, [r4, #2]
 803ac3e:	2901      	cmp	r1, #1
 803ac40:	d111      	bne.n	803ac66 <TRACE_Send+0x46>
        ADV_TRACE_Ctx.TraceSentSize = (uint16_t) (ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr);
 803ac42:	8823      	ldrh	r3, [r4, #0]
        ADV_TRACE_Ctx.unchunk_enabled = 0;
 803ac44:	8020      	strh	r0, [r4, #0]
        ADV_TRACE_Ctx.TraceSentSize = (uint16_t) (ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr);
 803ac46:	1b9b      	subs	r3, r3, r6
 803ac48:	b29b      	uxth	r3, r3
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_TRANSFER;
 803ac4a:	2102      	movs	r1, #2
        ADV_TRACE_Ctx.TraceSentSize = (uint16_t) (ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr);
 803ac4c:	82a3      	strh	r3, [r4, #20]
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_TRANSFER;
 803ac4e:	70a1      	strb	r1, [r4, #2]
        if(0u == ADV_TRACE_Ctx.TraceSentSize)
 803ac50:	b95b      	cbnz	r3, 803ac6a <TRACE_Send+0x4a>
          ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_NONE;
 803ac52:	70a3      	strb	r3, [r4, #2]
          ADV_TRACE_Ctx.TraceRdPtr = 0;
 803ac54:	8223      	strh	r3, [r4, #16]
        if(ADV_TRACE_Ctx.TraceWrPtr > ADV_TRACE_Ctx.TraceRdPtr)
 803ac56:	8a23      	ldrh	r3, [r4, #16]
 803ac58:	429a      	cmp	r2, r3
          ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.TraceWrPtr - ADV_TRACE_Ctx.TraceRdPtr;
 803ac5a:	bf8c      	ite	hi
 803ac5c:	1ad3      	subhi	r3, r2, r3
          ADV_TRACE_Ctx.TraceSentSize = UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceRdPtr;
 803ac5e:	f5c3 6380 	rsbls	r3, r3, #1024	; 0x400
 803ac62:	82a3      	strh	r3, [r4, #20]
 803ac64:	e001      	b.n	803ac6a <TRACE_Send+0x4a>
      if(TRACE_UNCHUNK_NONE == ADV_TRACE_Ctx.unchunk_status)
 803ac66:	2900      	cmp	r1, #0
 803ac68:	d0f5      	beq.n	803ac56 <TRACE_Send+0x36>
      ptr = &ADV_TRACE_Buffer[ADV_TRACE_Ctx.TraceRdPtr];
 803ac6a:	8a20      	ldrh	r0, [r4, #16]
 803ac6c:	4e0b      	ldr	r6, [pc, #44]	; (803ac9c <TRACE_Send+0x7c>)
 803ac6e:	4406      	add	r6, r0
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803ac70:	f385 8810 	msr	PRIMASK, r5
      UTIL_ADV_TRACE_PreSendHook();
 803ac74:	f7f1 fcdc 	bl	802c630 <UTIL_ADV_TRACE_PreSendHook>
      ret = UTIL_TraceDriver.Send(ptr, ADV_TRACE_Ctx.TraceSentSize);
 803ac78:	4b09      	ldr	r3, [pc, #36]	; (803aca0 <TRACE_Send+0x80>)
 803ac7a:	8aa1      	ldrh	r1, [r4, #20]
 803ac7c:	68db      	ldr	r3, [r3, #12]
 803ac7e:	9301      	str	r3, [sp, #4]
 803ac80:	4630      	mov	r0, r6
}
 803ac82:	b002      	add	sp, #8
 803ac84:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      ret = UTIL_TraceDriver.Send(ptr, ADV_TRACE_Ctx.TraceSentSize);
 803ac88:	4718      	bx	r3
      TRACE_UnLock();
 803ac8a:	f7ff ff97 	bl	803abbc <TRACE_UnLock>
 803ac8e:	f385 8810 	msr	PRIMASK, r5
}
 803ac92:	2000      	movs	r0, #0
 803ac94:	b002      	add	sp, #8
 803ac96:	bd70      	pop	{r4, r5, r6, pc}
 803ac98:	20005a90 	.word	0x20005a90
 803ac9c:	20005aa8 	.word	0x20005aa8
 803aca0:	0803b8b0 	.word	0x0803b8b0

0803aca4 <UTIL_ADV_TRACE_COND_FSend>:
{
 803aca4:	b408      	push	{r3}
 803aca6:	b5f0      	push	{r4, r5, r6, r7, lr}
  if(!(ADV_TRACE_Ctx.CurrentVerboseLevel >= VerboseLevel))
 803aca8:	4c2f      	ldr	r4, [pc, #188]	; (803ad68 <UTIL_ADV_TRACE_COND_FSend+0xc4>)
{
 803acaa:	b086      	sub	sp, #24
  uint16_t timestamp_size = 0u;
 803acac:	2300      	movs	r3, #0
 803acae:	f8ad 3000 	strh.w	r3, [sp]
  if(!(ADV_TRACE_Ctx.CurrentVerboseLevel >= VerboseLevel))
 803acb2:	7a23      	ldrb	r3, [r4, #8]
{
 803acb4:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
  if(!(ADV_TRACE_Ctx.CurrentVerboseLevel >= VerboseLevel))
 803acb6:	4283      	cmp	r3, r0
 803acb8:	d34f      	bcc.n	803ad5a <UTIL_ADV_TRACE_COND_FSend+0xb6>
  if((Region & ADV_TRACE_Ctx.RegionMask) != Region)
 803acba:	68e3      	ldr	r3, [r4, #12]
 803acbc:	ea31 0303 	bics.w	r3, r1, r3
 803acc0:	d14e      	bne.n	803ad60 <UTIL_ADV_TRACE_COND_FSend+0xbc>
  if((ADV_TRACE_Ctx.timestamp_func != NULL) && (TimeStampState != 0u))
 803acc2:	6863      	ldr	r3, [r4, #4]
 803acc4:	b11b      	cbz	r3, 803acce <UTIL_ADV_TRACE_COND_FSend+0x2a>
 803acc6:	b112      	cbz	r2, 803acce <UTIL_ADV_TRACE_COND_FSend+0x2a>
    ADV_TRACE_Ctx.timestamp_func(buf,&timestamp_size);
 803acc8:	4669      	mov	r1, sp
 803acca:	a802      	add	r0, sp, #8
 803accc:	4798      	blx	r3
  va_start( vaArgs, strFormat);
 803acce:	ab0c      	add	r3, sp, #48	; 0x30
  buff_size =(uint16_t)UTIL_ADV_TRACE_VSNPRINTF((char *)sztmp,UTIL_ADV_TRACE_TMP_BUF_SIZE, strFormat, vaArgs);
 803acd0:	462a      	mov	r2, r5
 803acd2:	f44f 7100 	mov.w	r1, #512	; 0x200
 803acd6:	4825      	ldr	r0, [pc, #148]	; (803ad6c <UTIL_ADV_TRACE_COND_FSend+0xc8>)
  va_start( vaArgs, strFormat);
 803acd8:	9301      	str	r3, [sp, #4]
  buff_size =(uint16_t)UTIL_ADV_TRACE_VSNPRINTF((char *)sztmp,UTIL_ADV_TRACE_TMP_BUF_SIZE, strFormat, vaArgs);
 803acda:	f000 fbeb 	bl	803b4b4 <tiny_vsnprintf_like>
  TRACE_Lock();
 803acde:	f7ff ff61 	bl	803aba4 <TRACE_Lock>
  if (TRACE_AllocateBufer((buff_size+timestamp_size),&writepos) != -1)
 803ace2:	f8bd 3000 	ldrh.w	r3, [sp]
 803ace6:	4418      	add	r0, r3
 803ace8:	f10d 0102 	add.w	r1, sp, #2
 803acec:	b280      	uxth	r0, r0
 803acee:	f7ff ff29 	bl	803ab44 <TRACE_AllocateBufer>
 803acf2:	3001      	adds	r0, #1
 803acf4:	d02c      	beq.n	803ad50 <UTIL_ADV_TRACE_COND_FSend+0xac>
    for (idx = 0u; idx < timestamp_size; idx++)
 803acf6:	2200      	movs	r2, #0
 803acf8:	f8bd 3000 	ldrh.w	r3, [sp]
 803acfc:	f8bd 7002 	ldrh.w	r7, [sp, #2]
 803ad00:	4616      	mov	r6, r2
      ADV_TRACE_Buffer[writepos] = buf[idx];
 803ad02:	f10d 0c08 	add.w	ip, sp, #8
 803ad06:	b290      	uxth	r0, r2
 803ad08:	fa17 f182 	uxtah	r1, r7, r2
    for (idx = 0u; idx < timestamp_size; idx++)
 803ad0c:	4283      	cmp	r3, r0
 803ad0e:	b289      	uxth	r1, r1
 803ad10:	d817      	bhi.n	803ad42 <UTIL_ADV_TRACE_COND_FSend+0x9e>
 803ad12:	443b      	add	r3, r7
 803ad14:	b29b      	uxth	r3, r3
 803ad16:	b10e      	cbz	r6, 803ad1c <UTIL_ADV_TRACE_COND_FSend+0x78>
 803ad18:	f8ad 3002 	strh.w	r3, [sp, #2]
    (void)UTIL_ADV_TRACE_VSNPRINTF((char *)(&ADV_TRACE_Buffer[writepos]), UTIL_ADV_TRACE_TMP_BUF_SIZE, strFormat, vaArgs);
 803ad1c:	f8bd 0002 	ldrh.w	r0, [sp, #2]
 803ad20:	4c13      	ldr	r4, [pc, #76]	; (803ad70 <UTIL_ADV_TRACE_COND_FSend+0xcc>)
 803ad22:	9b01      	ldr	r3, [sp, #4]
 803ad24:	462a      	mov	r2, r5
 803ad26:	f44f 7100 	mov.w	r1, #512	; 0x200
 803ad2a:	4420      	add	r0, r4
 803ad2c:	f000 fbc2 	bl	803b4b4 <tiny_vsnprintf_like>
    TRACE_UnLock();
 803ad30:	f7ff ff44 	bl	803abbc <TRACE_UnLock>
    return TRACE_Send();
 803ad34:	f7ff ff74 	bl	803ac20 <TRACE_Send>
}
 803ad38:	b006      	add	sp, #24
 803ad3a:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 803ad3e:	b001      	add	sp, #4
 803ad40:	4770      	bx	lr
      ADV_TRACE_Buffer[writepos] = buf[idx];
 803ad42:	4421      	add	r1, r4
 803ad44:	f812 000c 	ldrb.w	r0, [r2, ip]
 803ad48:	7608      	strb	r0, [r1, #24]
    for (idx = 0u; idx < timestamp_size; idx++)
 803ad4a:	3201      	adds	r2, #1
      ADV_TRACE_Buffer[writepos] = buf[idx];
 803ad4c:	2601      	movs	r6, #1
 803ad4e:	e7da      	b.n	803ad06 <UTIL_ADV_TRACE_COND_FSend+0x62>
  TRACE_UnLock();
 803ad50:	f7ff ff34 	bl	803abbc <TRACE_UnLock>
  return UTIL_ADV_TRACE_MEM_FULL;
 803ad54:	f06f 0002 	mvn.w	r0, #2
 803ad58:	e7ee      	b.n	803ad38 <UTIL_ADV_TRACE_COND_FSend+0x94>
    return UTIL_ADV_TRACE_GIVEUP;
 803ad5a:	f06f 0004 	mvn.w	r0, #4
 803ad5e:	e7eb      	b.n	803ad38 <UTIL_ADV_TRACE_COND_FSend+0x94>
    return UTIL_ADV_TRACE_REGIONMASKED;
 803ad60:	f06f 0005 	mvn.w	r0, #5
 803ad64:	e7e8      	b.n	803ad38 <UTIL_ADV_TRACE_COND_FSend+0x94>
 803ad66:	bf00      	nop
 803ad68:	20005a90 	.word	0x20005a90
 803ad6c:	20005ea8 	.word	0x20005ea8
 803ad70:	20005aa8 	.word	0x20005aa8

0803ad74 <TRACE_TxCpltCallback>:
{
 803ad74:	b537      	push	{r0, r1, r2, r4, r5, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803ad76:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803ad7a:	b672      	cpsid	i
  if(TRACE_UNCHUNK_TRANSFER == ADV_TRACE_Ctx.unchunk_status)
 803ad7c:	4b21      	ldr	r3, [pc, #132]	; (803ae04 <TRACE_TxCpltCallback+0x90>)
 803ad7e:	789a      	ldrb	r2, [r3, #2]
 803ad80:	2a02      	cmp	r2, #2
    ADV_TRACE_Ctx.TraceRdPtr = (ADV_TRACE_Ctx.TraceRdPtr + ADV_TRACE_Ctx.TraceSentSize) % UTIL_ADV_TRACE_FIFO_SIZE;
 803ad82:	bf1d      	ittte	ne
 803ad84:	8a1a      	ldrhne	r2, [r3, #16]
 803ad86:	8a99      	ldrhne	r1, [r3, #20]
 803ad88:	1852      	addne	r2, r2, r1
    ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_NONE;
 803ad8a:	2200      	moveq	r2, #0
    ADV_TRACE_Ctx.TraceRdPtr = (ADV_TRACE_Ctx.TraceRdPtr + ADV_TRACE_Ctx.TraceSentSize) % UTIL_ADV_TRACE_FIFO_SIZE;
 803ad8c:	bf18      	it	ne
 803ad8e:	f3c2 0209 	ubfxne	r2, r2, #0, #10
 803ad92:	821a      	strh	r2, [r3, #16]
  if((ADV_TRACE_Ctx.TraceRdPtr != ADV_TRACE_Ctx.TraceWrPtr) && (1u == ADV_TRACE_Ctx.TraceLock))
 803ad94:	8a1d      	ldrh	r5, [r3, #16]
 803ad96:	8a59      	ldrh	r1, [r3, #18]
    ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_NONE;
 803ad98:	bf08      	it	eq
 803ad9a:	709a      	strbeq	r2, [r3, #2]
  if((ADV_TRACE_Ctx.TraceRdPtr != ADV_TRACE_Ctx.TraceWrPtr) && (1u == ADV_TRACE_Ctx.TraceLock))
 803ad9c:	428d      	cmp	r5, r1
 803ad9e:	d027      	beq.n	803adf0 <TRACE_TxCpltCallback+0x7c>
 803ada0:	8ada      	ldrh	r2, [r3, #22]
 803ada2:	2a01      	cmp	r2, #1
 803ada4:	d124      	bne.n	803adf0 <TRACE_TxCpltCallback+0x7c>
    if(TRACE_UNCHUNK_DETECTED == ADV_TRACE_Ctx.unchunk_status)
 803ada6:	7898      	ldrb	r0, [r3, #2]
 803ada8:	2801      	cmp	r0, #1
 803adaa:	d112      	bne.n	803add2 <TRACE_TxCpltCallback+0x5e>
      ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr;
 803adac:	881a      	ldrh	r2, [r3, #0]
      ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_TRANSFER;
 803adae:	2002      	movs	r0, #2
      ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr;
 803adb0:	1b52      	subs	r2, r2, r5
 803adb2:	b292      	uxth	r2, r2
      ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_TRANSFER;
 803adb4:	7098      	strb	r0, [r3, #2]
      ADV_TRACE_Ctx.unchunk_enabled = 0;
 803adb6:	2000      	movs	r0, #0
      ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr;
 803adb8:	829a      	strh	r2, [r3, #20]
      ADV_TRACE_Ctx.unchunk_enabled = 0;
 803adba:	8018      	strh	r0, [r3, #0]
      if(0u == ADV_TRACE_Ctx.TraceSentSize)
 803adbc:	b95a      	cbnz	r2, 803add6 <TRACE_TxCpltCallback+0x62>
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_NONE;
 803adbe:	709a      	strb	r2, [r3, #2]
        ADV_TRACE_Ctx.TraceRdPtr = 0;
 803adc0:	821a      	strh	r2, [r3, #16]
      if(ADV_TRACE_Ctx.TraceWrPtr > ADV_TRACE_Ctx.TraceRdPtr)
 803adc2:	8a1a      	ldrh	r2, [r3, #16]
 803adc4:	4291      	cmp	r1, r2
        ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.TraceWrPtr - ADV_TRACE_Ctx.TraceRdPtr;
 803adc6:	bf8c      	ite	hi
 803adc8:	1a8a      	subhi	r2, r1, r2
        ADV_TRACE_Ctx.TraceSentSize = UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceRdPtr;
 803adca:	f5c2 6280 	rsbls	r2, r2, #1024	; 0x400
 803adce:	829a      	strh	r2, [r3, #20]
 803add0:	e001      	b.n	803add6 <TRACE_TxCpltCallback+0x62>
    if(TRACE_UNCHUNK_NONE == ADV_TRACE_Ctx.unchunk_status)
 803add2:	2800      	cmp	r0, #0
 803add4:	d0f5      	beq.n	803adc2 <TRACE_TxCpltCallback+0x4e>
    ptr = &ADV_TRACE_Buffer[ADV_TRACE_Ctx.TraceRdPtr];
 803add6:	8a1a      	ldrh	r2, [r3, #16]
 803add8:	480b      	ldr	r0, [pc, #44]	; (803ae08 <TRACE_TxCpltCallback+0x94>)
 803adda:	4410      	add	r0, r2
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803addc:	f384 8810 	msr	PRIMASK, r4
    UTIL_TraceDriver.Send(ptr, ADV_TRACE_Ctx.TraceSentSize);
 803ade0:	4a0a      	ldr	r2, [pc, #40]	; (803ae0c <TRACE_TxCpltCallback+0x98>)
 803ade2:	8a99      	ldrh	r1, [r3, #20]
 803ade4:	68d3      	ldr	r3, [r2, #12]
 803ade6:	9301      	str	r3, [sp, #4]
}
 803ade8:	b003      	add	sp, #12
 803adea:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    UTIL_TraceDriver.Send(ptr, ADV_TRACE_Ctx.TraceSentSize);
 803adee:	4718      	bx	r3
 803adf0:	f384 8810 	msr	PRIMASK, r4
    UTIL_ADV_TRACE_PostSendHook();
 803adf4:	f7f1 fc20 	bl	802c638 <UTIL_ADV_TRACE_PostSendHook>
}
 803adf8:	b003      	add	sp, #12
 803adfa:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    TRACE_UnLock();
 803adfe:	f7ff bedd 	b.w	803abbc <TRACE_UnLock>
 803ae02:	bf00      	nop
 803ae04:	20005a90 	.word	0x20005a90
 803ae08:	20005aa8 	.word	0x20005aa8
 803ae0c:	0803b8b0 	.word	0x0803b8b0

0803ae10 <UTIL_LPM_Init>:
/** @addtogroup TINY_LPM_Exported_function
  * @{
  */
void UTIL_LPM_Init( void )
{
  StopModeDisable = UTIL_LPM_NO_BIT_SET;
 803ae10:	4b02      	ldr	r3, [pc, #8]	; (803ae1c <UTIL_LPM_Init+0xc>)
 803ae12:	2200      	movs	r2, #0
  OffModeDisable = UTIL_LPM_NO_BIT_SET;
 803ae14:	e9c3 2200 	strd	r2, r2, [r3]
  UTIL_LPM_INIT_CRITICAL_SECTION( );
}
 803ae18:	4770      	bx	lr
 803ae1a:	bf00      	nop
 803ae1c:	200060a8 	.word	0x200060a8

0803ae20 <UTIL_LPM_SetStopMode>:
void UTIL_LPM_DeInit( void )
{
}

void UTIL_LPM_SetStopMode( UTIL_LPM_bm_t lpm_id_bm, UTIL_LPM_State_t state )
{
 803ae20:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803ae22:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803ae26:	b672      	cpsid	i
  UTIL_LPM_ENTER_CRITICAL_SECTION( );
  
  switch( state )
 803ae28:	b141      	cbz	r1, 803ae3c <UTIL_LPM_SetStopMode+0x1c>
 803ae2a:	2901      	cmp	r1, #1
 803ae2c:	d103      	bne.n	803ae36 <UTIL_LPM_SetStopMode+0x16>
  {
  case UTIL_LPM_DISABLE:
    {
      StopModeDisable |= lpm_id_bm;
 803ae2e:	4a06      	ldr	r2, [pc, #24]	; (803ae48 <UTIL_LPM_SetStopMode+0x28>)
 803ae30:	6813      	ldr	r3, [r2, #0]
 803ae32:	4318      	orrs	r0, r3
      break;
    }
  case UTIL_LPM_ENABLE:
    {
      StopModeDisable &= ( ~lpm_id_bm );
 803ae34:	6010      	str	r0, [r2, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803ae36:	f384 8810 	msr	PRIMASK, r4
      break;
    }
  }
  
  UTIL_LPM_EXIT_CRITICAL_SECTION( );
}
 803ae3a:	bd10      	pop	{r4, pc}
      StopModeDisable &= ( ~lpm_id_bm );
 803ae3c:	4a02      	ldr	r2, [pc, #8]	; (803ae48 <UTIL_LPM_SetStopMode+0x28>)
 803ae3e:	6813      	ldr	r3, [r2, #0]
 803ae40:	ea23 0000 	bic.w	r0, r3, r0
 803ae44:	e7f6      	b.n	803ae34 <UTIL_LPM_SetStopMode+0x14>
 803ae46:	bf00      	nop
 803ae48:	200060a8 	.word	0x200060a8

0803ae4c <UTIL_LPM_SetOffMode>:

void UTIL_LPM_SetOffMode( UTIL_LPM_bm_t lpm_id_bm, UTIL_LPM_State_t state )
{
 803ae4c:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803ae4e:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803ae52:	b672      	cpsid	i
  UTIL_LPM_ENTER_CRITICAL_SECTION( );
  
  switch(state)
 803ae54:	b141      	cbz	r1, 803ae68 <UTIL_LPM_SetOffMode+0x1c>
 803ae56:	2901      	cmp	r1, #1
 803ae58:	d103      	bne.n	803ae62 <UTIL_LPM_SetOffMode+0x16>
  {
  case UTIL_LPM_DISABLE:
    {
      OffModeDisable |= lpm_id_bm;
 803ae5a:	4a06      	ldr	r2, [pc, #24]	; (803ae74 <UTIL_LPM_SetOffMode+0x28>)
 803ae5c:	6853      	ldr	r3, [r2, #4]
 803ae5e:	4318      	orrs	r0, r3
      break;
    }
  case UTIL_LPM_ENABLE:
    {
      OffModeDisable &= ( ~lpm_id_bm );
 803ae60:	6050      	str	r0, [r2, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803ae62:	f384 8810 	msr	PRIMASK, r4
      break;
    }
  }
  
  UTIL_LPM_EXIT_CRITICAL_SECTION( );
}
 803ae66:	bd10      	pop	{r4, pc}
      OffModeDisable &= ( ~lpm_id_bm );
 803ae68:	4a02      	ldr	r2, [pc, #8]	; (803ae74 <UTIL_LPM_SetOffMode+0x28>)
 803ae6a:	6853      	ldr	r3, [r2, #4]
 803ae6c:	ea23 0000 	bic.w	r0, r3, r0
 803ae70:	e7f6      	b.n	803ae60 <UTIL_LPM_SetOffMode+0x14>
 803ae72:	bf00      	nop
 803ae74:	200060a8 	.word	0x200060a8

0803ae78 <UTIL_LPM_EnterLowPower>:

  return mode_selected;
}

void UTIL_LPM_EnterLowPower( void )
{
 803ae78:	b538      	push	{r3, r4, r5, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803ae7a:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803ae7e:	b672      	cpsid	i
  UTIL_LPM_ENTER_CRITICAL_SECTION_ELP( );

  if( StopModeDisable != UTIL_LPM_NO_BIT_SET )
 803ae80:	4b0a      	ldr	r3, [pc, #40]	; (803aeac <UTIL_LPM_EnterLowPower+0x34>)
 803ae82:	4c0b      	ldr	r4, [pc, #44]	; (803aeb0 <UTIL_LPM_EnterLowPower+0x38>)
 803ae84:	681a      	ldr	r2, [r3, #0]
 803ae86:	b132      	cbz	r2, 803ae96 <UTIL_LPM_EnterLowPower+0x1e>
  {
    /**
     * At least one user disallows Stop Mode
     * SLEEP mode is required
     */
      UTIL_PowerDriver.EnterSleepMode( );
 803ae88:	6823      	ldr	r3, [r4, #0]
 803ae8a:	4798      	blx	r3
      UTIL_PowerDriver.ExitSleepMode( );
 803ae8c:	6863      	ldr	r3, [r4, #4]
    {
      /**
       * OFF mode is required
       */
      UTIL_PowerDriver.EnterOffMode( );
      UTIL_PowerDriver.ExitOffMode( );
 803ae8e:	4798      	blx	r3
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803ae90:	f385 8810 	msr	PRIMASK, r5
    }
  }
  
  UTIL_LPM_EXIT_CRITICAL_SECTION_ELP( );
}
 803ae94:	bd38      	pop	{r3, r4, r5, pc}
    if( OffModeDisable != UTIL_LPM_NO_BIT_SET )
 803ae96:	685b      	ldr	r3, [r3, #4]
 803ae98:	b11b      	cbz	r3, 803aea2 <UTIL_LPM_EnterLowPower+0x2a>
        UTIL_PowerDriver.EnterStopMode( );
 803ae9a:	68a3      	ldr	r3, [r4, #8]
 803ae9c:	4798      	blx	r3
        UTIL_PowerDriver.ExitStopMode( );
 803ae9e:	68e3      	ldr	r3, [r4, #12]
 803aea0:	e7f5      	b.n	803ae8e <UTIL_LPM_EnterLowPower+0x16>
      UTIL_PowerDriver.EnterOffMode( );
 803aea2:	6923      	ldr	r3, [r4, #16]
 803aea4:	4798      	blx	r3
      UTIL_PowerDriver.ExitOffMode( );
 803aea6:	6963      	ldr	r3, [r4, #20]
 803aea8:	e7f1      	b.n	803ae8e <UTIL_LPM_EnterLowPower+0x16>
 803aeaa:	bf00      	nop
 803aeac:	200060a8 	.word	0x200060a8
 803aeb0:	0803b858 	.word	0x0803b858

0803aeb4 <UTIL_MEM_cpy_8>:
void UTIL_MEM_cpy_8( void *dst, const void *src, uint16_t size )
{
  uint8_t* dst8= (uint8_t *) dst;
  uint8_t* src8= (uint8_t *) src;

  while( size-- )
 803aeb4:	3801      	subs	r0, #1
 803aeb6:	440a      	add	r2, r1
 803aeb8:	4291      	cmp	r1, r2
 803aeba:	d100      	bne.n	803aebe <UTIL_MEM_cpy_8+0xa>
    {
        *dst8++ = *src8++;
    }
}
 803aebc:	4770      	bx	lr
        *dst8++ = *src8++;
 803aebe:	f811 3b01 	ldrb.w	r3, [r1], #1
 803aec2:	f800 3f01 	strb.w	r3, [r0, #1]!
 803aec6:	e7f7      	b.n	803aeb8 <UTIL_MEM_cpy_8+0x4>

0803aec8 <UTIL_MEM_set_8>:
}

void UTIL_MEM_set_8( void *dst, uint8_t value, uint16_t size )
{
  uint8_t* dst8= (uint8_t *) dst;
  while( size-- )
 803aec8:	4402      	add	r2, r0
 803aeca:	4290      	cmp	r0, r2
 803aecc:	d100      	bne.n	803aed0 <UTIL_MEM_set_8+0x8>
  {
    *dst8++ = value;
  }
}
 803aece:	4770      	bx	lr
    *dst8++ = value;
 803aed0:	f800 1b01 	strb.w	r1, [r0], #1
 803aed4:	e7f9      	b.n	803aeca <UTIL_MEM_set_8+0x2>
	...

0803aed8 <UTIL_SEQ_SetTask>:

  return;
}

void UTIL_SEQ_SetTask( UTIL_SEQ_bm_t TaskId_bm , uint32_t Task_Prio )
{
 803aed8:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803aeda:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803aede:	b672      	cpsid	i
  UTIL_SEQ_ENTER_CRITICAL_SECTION( );

  TaskSet |= TaskId_bm;
 803aee0:	4b06      	ldr	r3, [pc, #24]	; (803aefc <UTIL_SEQ_SetTask+0x24>)
 803aee2:	681a      	ldr	r2, [r3, #0]
 803aee4:	4302      	orrs	r2, r0
 803aee6:	601a      	str	r2, [r3, #0]
  TaskPrio[Task_Prio].priority |= TaskId_bm;
 803aee8:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 803aeec:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 803aef0:	4310      	orrs	r0, r2
 803aef2:	f8c3 0090 	str.w	r0, [r3, #144]	; 0x90
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803aef6:	f384 8810 	msr	PRIMASK, r4

  UTIL_SEQ_EXIT_CRITICAL_SECTION( );

  return;
}
 803aefa:	bd10      	pop	{r4, pc}
 803aefc:	200060b0 	.word	0x200060b0

0803af00 <UTIL_SEQ_PreIdle>:
 803af00:	4770      	bx	lr

0803af02 <UTIL_SEQ_PostIdle>:
 803af02:	4770      	bx	lr

0803af04 <SEQ_BitPosition>:
 */
uint8_t SEQ_BitPosition(uint32_t Value)
{
  uint8_t n = 0U;

  if ((Value & 0xFFFF0000U) == 0U)  { n  = 16U; Value <<= 16U;  }
 803af04:	0c03      	lsrs	r3, r0, #16
 803af06:	041b      	lsls	r3, r3, #16
 803af08:	b9c3      	cbnz	r3, 803af3c <SEQ_BitPosition+0x38>
 803af0a:	0400      	lsls	r0, r0, #16
 803af0c:	2310      	movs	r3, #16
  if ((Value & 0xFF000000U) == 0U)  { n +=  8U; Value <<=  8U;  }
 803af0e:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
 803af12:	bf02      	ittt	eq
 803af14:	3308      	addeq	r3, #8
 803af16:	0200      	lsleq	r0, r0, #8
 803af18:	b2db      	uxtbeq	r3, r3
  if ((Value & 0xF0000000U) == 0U)  { n +=  4U; Value <<=  4U;  }
 803af1a:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
 803af1e:	bf08      	it	eq
 803af20:	0100      	lsleq	r0, r0, #4

  n += SEQ_clz_table_4bit[Value >> (32-4)];

  return (uint8_t)(31U-n);
 803af22:	4a07      	ldr	r2, [pc, #28]	; (803af40 <SEQ_BitPosition+0x3c>)
  n += SEQ_clz_table_4bit[Value >> (32-4)];
 803af24:	ea4f 7010 	mov.w	r0, r0, lsr #28
  if ((Value & 0xF0000000U) == 0U)  { n +=  4U; Value <<=  4U;  }
 803af28:	bf08      	it	eq
 803af2a:	3304      	addeq	r3, #4
  return (uint8_t)(31U-n);
 803af2c:	5c10      	ldrb	r0, [r2, r0]
  if ((Value & 0xF0000000U) == 0U)  { n +=  4U; Value <<=  4U;  }
 803af2e:	bf08      	it	eq
 803af30:	b2db      	uxtbeq	r3, r3
  return (uint8_t)(31U-n);
 803af32:	f1c3 031f 	rsb	r3, r3, #31
 803af36:	1a18      	subs	r0, r3, r0
}
 803af38:	b2c0      	uxtb	r0, r0
 803af3a:	4770      	bx	lr
  uint8_t n = 0U;
 803af3c:	2300      	movs	r3, #0
 803af3e:	e7e6      	b.n	803af0e <SEQ_BitPosition+0xa>
 803af40:	0803bd20 	.word	0x0803bd20

0803af44 <UTIL_SEQ_Run>:
{
 803af44:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  super_mask_backup = SuperMask;
 803af48:	4d36      	ldr	r5, [pc, #216]	; (803b024 <UTIL_SEQ_Run+0xe0>)
  while(((TaskSet & TaskMask & SuperMask) != 0U) && ((EvtSet & EvtWaited)==0U))
 803af4a:	f8df 80dc 	ldr.w	r8, [pc, #220]	; 803b028 <UTIL_SEQ_Run+0xe4>
  super_mask_backup = SuperMask;
 803af4e:	686e      	ldr	r6, [r5, #4]
  SuperMask &= Mask_bm;
 803af50:	4030      	ands	r0, r6
 803af52:	6068      	str	r0, [r5, #4]
  while(((TaskSet & TaskMask & SuperMask) != 0U) && ((EvtSet & EvtWaited)==0U))
 803af54:	4644      	mov	r4, r8
      counter++;
 803af56:	2701      	movs	r7, #1
  while(((TaskSet & TaskMask & SuperMask) != 0U) && ((EvtSet & EvtWaited)==0U))
 803af58:	e9d5 2000 	ldrd	r2, r0, [r5]
 803af5c:	f8d8 3000 	ldr.w	r3, [r8]
 803af60:	4013      	ands	r3, r2
 803af62:	4203      	tst	r3, r0
 803af64:	d043      	beq.n	803afee <UTIL_SEQ_Run+0xaa>
 803af66:	e9d8 3101 	ldrd	r3, r1, [r8, #4]
 803af6a:	400b      	ands	r3, r1
 803af6c:	d13f      	bne.n	803afee <UTIL_SEQ_Run+0xaa>
    while((TaskPrio[counter].priority & TaskMask & SuperMask)== 0U)
 803af6e:	4002      	ands	r2, r0
 803af70:	f8d8 0090 	ldr.w	r0, [r8, #144]	; 0x90
 803af74:	4010      	ands	r0, r2
 803af76:	d103      	bne.n	803af80 <UTIL_SEQ_Run+0x3c>
 803af78:	f8d8 0098 	ldr.w	r0, [r8, #152]	; 0x98
      counter++;
 803af7c:	2301      	movs	r3, #1
    while((TaskPrio[counter].priority & TaskMask & SuperMask)== 0U)
 803af7e:	4010      	ands	r0, r2
    if ((TaskPrio[counter].round_robin & current_task_set) == 0U)
 803af80:	00d9      	lsls	r1, r3, #3
 803af82:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
    CurrentTaskIdx = (SEQ_BitPosition(current_task_set & TaskPrio[counter].round_robin));
 803af86:	4421      	add	r1, r4
    if ((TaskPrio[counter].round_robin & current_task_set) == 0U)
 803af88:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 803af8c:	4210      	tst	r0, r2
      TaskPrio[counter].round_robin = UTIL_SEQ_ALL_BIT_SET;
 803af8e:	bf04      	itt	eq
 803af90:	f04f 32ff 	moveq.w	r2, #4294967295
 803af94:	f8c3 2094 	streq.w	r2, [r3, #148]	; 0x94
    CurrentTaskIdx = (SEQ_BitPosition(current_task_set & TaskPrio[counter].round_robin));
 803af98:	f8d1 9094 	ldr.w	r9, [r1, #148]	; 0x94
 803af9c:	ea09 0000 	and.w	r0, r9, r0
 803afa0:	f7ff ffb0 	bl	803af04 <SEQ_BitPosition>
 803afa4:	60e0      	str	r0, [r4, #12]
    TaskPrio[counter].round_robin &= ~(1U << CurrentTaskIdx);
 803afa6:	fa07 f000 	lsl.w	r0, r7, r0
 803afaa:	ea29 0000 	bic.w	r0, r9, r0
 803afae:	f8c1 0094 	str.w	r0, [r1, #148]	; 0x94
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803afb2:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803afb6:	b672      	cpsid	i
    TaskSet &= ~(1U << CurrentTaskIdx);
 803afb8:	68e3      	ldr	r3, [r4, #12]
 803afba:	6822      	ldr	r2, [r4, #0]
 803afbc:	fa07 f303 	lsl.w	r3, r7, r3
 803afc0:	ea22 0203 	bic.w	r2, r2, r3
 803afc4:	6022      	str	r2, [r4, #0]
      TaskPrio[counter - 1U].priority &= ~(1U << CurrentTaskIdx);
 803afc6:	f8d4 2098 	ldr.w	r2, [r4, #152]	; 0x98
 803afca:	ea22 0203 	bic.w	r2, r2, r3
 803afce:	f8c4 2098 	str.w	r2, [r4, #152]	; 0x98
 803afd2:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
 803afd6:	ea22 0303 	bic.w	r3, r2, r3
 803afda:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803afde:	f381 8810 	msr	PRIMASK, r1
    TaskCb[CurrentTaskIdx]( );
 803afe2:	68e3      	ldr	r3, [r4, #12]
 803afe4:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 803afe8:	691b      	ldr	r3, [r3, #16]
 803afea:	4798      	blx	r3
 803afec:	e7b4      	b.n	803af58 <UTIL_SEQ_Run+0x14>
  CurrentTaskIdx = UTIL_SEQ_NOTASKRUNNING;
 803afee:	f04f 33ff 	mov.w	r3, #4294967295
 803aff2:	60e3      	str	r3, [r4, #12]
  UTIL_SEQ_PreIdle( );
 803aff4:	f7ff ff84 	bl	803af00 <UTIL_SEQ_PreIdle>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803aff8:	f3ef 8710 	mrs	r7, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803affc:	b672      	cpsid	i
  if (!(((TaskSet & TaskMask & SuperMask) != 0U) || ((EvtSet & EvtWaited)!= 0U))) 
 803affe:	682a      	ldr	r2, [r5, #0]
 803b000:	6823      	ldr	r3, [r4, #0]
 803b002:	4013      	ands	r3, r2
 803b004:	686a      	ldr	r2, [r5, #4]
 803b006:	4013      	ands	r3, r2
 803b008:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 803b00c:	400a      	ands	r2, r1
 803b00e:	4313      	orrs	r3, r2
 803b010:	d101      	bne.n	803b016 <UTIL_SEQ_Run+0xd2>
	UTIL_SEQ_Idle( );
 803b012:	f7f1 fa97 	bl	802c544 <UTIL_SEQ_Idle>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803b016:	f387 8810 	msr	PRIMASK, r7
  UTIL_SEQ_PostIdle( );
 803b01a:	f7ff ff72 	bl	803af02 <UTIL_SEQ_PostIdle>
  SuperMask = super_mask_backup;
 803b01e:	606e      	str	r6, [r5, #4]
}
 803b020:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 803b024:	200035a4 	.word	0x200035a4
 803b028:	200060b0 	.word	0x200060b0

0803b02c <UTIL_SEQ_RegTask>:
{
 803b02c:	b510      	push	{r4, lr}
 803b02e:	4611      	mov	r1, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803b030:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803b034:	b672      	cpsid	i
  TaskCb[SEQ_BitPosition(TaskId_bm)] = Task;
 803b036:	f7ff ff65 	bl	803af04 <SEQ_BitPosition>
 803b03a:	4b03      	ldr	r3, [pc, #12]	; (803b048 <UTIL_SEQ_RegTask+0x1c>)
 803b03c:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 803b040:	6119      	str	r1, [r3, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803b042:	f384 8810 	msr	PRIMASK, r4
}
 803b046:	bd10      	pop	{r4, pc}
 803b048:	200060b0 	.word	0x200060b0

0803b04c <SysTimeAdd>:
  * @addtogroup SYSTIME_exported_function
  *  @{
  */

SysTime_t SysTimeAdd( SysTime_t a, SysTime_t b )
{
 803b04c:	b082      	sub	sp, #8
 803b04e:	b082      	sub	sp, #8
 803b050:	f10d 0c08 	add.w	ip, sp, #8
 803b054:	e90c 0006 	stmdb	ip, {r1, r2}
  SysTime_t c =  { .Seconds = 0, .SubSeconds = 0 };

  c.Seconds = a.Seconds + b.Seconds;
 803b058:	9a00      	ldr	r2, [sp, #0]
  c.SubSeconds = a.SubSeconds + b.SubSeconds;
 803b05a:	f8bd 1010 	ldrh.w	r1, [sp, #16]
{
 803b05e:	9303      	str	r3, [sp, #12]
  c.Seconds = a.Seconds + b.Seconds;
 803b060:	4413      	add	r3, r2
  c.SubSeconds = a.SubSeconds + b.SubSeconds;
 803b062:	f8bd 2004 	ldrh.w	r2, [sp, #4]
 803b066:	440a      	add	r2, r1
 803b068:	b291      	uxth	r1, r2
 803b06a:	b212      	sxth	r2, r2
  if( c.SubSeconds >= 1000 )
 803b06c:	f5b2 7f7a 	cmp.w	r2, #1000	; 0x3e8
  {
    c.Seconds++;
    c.SubSeconds -= 1000;
 803b070:	bfa2      	ittt	ge
 803b072:	f5a1 727a 	subge.w	r2, r1, #1000	; 0x3e8
    c.Seconds++;
 803b076:	3301      	addge	r3, #1
    c.SubSeconds -= 1000;
 803b078:	b212      	sxthge	r2, r2
  }
  return c;
 803b07a:	6003      	str	r3, [r0, #0]
 803b07c:	8082      	strh	r2, [r0, #4]
}
 803b07e:	b002      	add	sp, #8
 803b080:	b002      	add	sp, #8
 803b082:	4770      	bx	lr

0803b084 <SysTimeSub>:

SysTime_t SysTimeSub( SysTime_t a, SysTime_t b )
{
 803b084:	b082      	sub	sp, #8
 803b086:	b082      	sub	sp, #8
 803b088:	f10d 0c08 	add.w	ip, sp, #8
 803b08c:	e90c 0006 	stmdb	ip, {r1, r2}
  SysTime_t c = { .Seconds = 0, .SubSeconds = 0 };

  c.Seconds = a.Seconds - b.Seconds;
 803b090:	9a00      	ldr	r2, [sp, #0]
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 803b092:	f8bd 1010 	ldrh.w	r1, [sp, #16]
{
 803b096:	9303      	str	r3, [sp, #12]
  c.Seconds = a.Seconds - b.Seconds;
 803b098:	1ad3      	subs	r3, r2, r3
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 803b09a:	f8bd 2004 	ldrh.w	r2, [sp, #4]
 803b09e:	1a52      	subs	r2, r2, r1
 803b0a0:	b291      	uxth	r1, r2
 803b0a2:	b212      	sxth	r2, r2
  if( c.SubSeconds < 0 )
 803b0a4:	2a00      	cmp	r2, #0
  {
    c.Seconds--;
    c.SubSeconds += 1000;
 803b0a6:	bfbe      	ittt	lt
 803b0a8:	f501 727a 	addlt.w	r2, r1, #1000	; 0x3e8
    c.Seconds--;
 803b0ac:	f103 33ff 	addlt.w	r3, r3, #4294967295
    c.SubSeconds += 1000;
 803b0b0:	b212      	sxthlt	r2, r2
  }
  return c;
 803b0b2:	6003      	str	r3, [r0, #0]
 803b0b4:	8082      	strh	r2, [r0, #4]
}
 803b0b6:	b002      	add	sp, #8
 803b0b8:	b002      	add	sp, #8
 803b0ba:	4770      	bx	lr

0803b0bc <SysTimeSet>:

void SysTimeSet( SysTime_t sysTime )
{
 803b0bc:	b530      	push	{r4, r5, lr}
 803b0be:	b085      	sub	sp, #20
  SysTime_t DeltaTime;
  
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };

  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 803b0c0:	4d11      	ldr	r5, [pc, #68]	; (803b108 <SysTimeSet+0x4c>)
{
 803b0c2:	466b      	mov	r3, sp
 803b0c4:	e883 0003 	stmia.w	r3, {r0, r1}
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 803b0c8:	2300      	movs	r3, #0
 803b0ca:	9302      	str	r3, [sp, #8]
 803b0cc:	f8ad 300c 	strh.w	r3, [sp, #12]
  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 803b0d0:	a803      	add	r0, sp, #12
 803b0d2:	692b      	ldr	r3, [r5, #16]
 803b0d4:	4798      	blx	r3
  c.Seconds = a.Seconds - b.Seconds;
 803b0d6:	9b00      	ldr	r3, [sp, #0]
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 803b0d8:	f8bd 4004 	ldrh.w	r4, [sp, #4]
  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 803b0dc:	9002      	str	r0, [sp, #8]
  c.Seconds = a.Seconds - b.Seconds;
 803b0de:	1a18      	subs	r0, r3, r0
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 803b0e0:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 803b0e4:	1ae4      	subs	r4, r4, r3
 803b0e6:	b2a3      	uxth	r3, r4
 803b0e8:	b224      	sxth	r4, r4
  if( c.SubSeconds < 0 )
 803b0ea:	2c00      	cmp	r4, #0
    c.SubSeconds += 1000;
 803b0ec:	bfbe      	ittt	lt
 803b0ee:	f503 747a 	addlt.w	r4, r3, #1000	; 0x3e8
    c.Seconds--;
 803b0f2:	f100 30ff 	addlt.w	r0, r0, #4294967295
    c.SubSeconds += 1000;
 803b0f6:	b224      	sxthlt	r4, r4

  // sysTime is UNIX epoch
  DeltaTime = SysTimeSub( sysTime, calendarTime );

  UTIL_SYSTIMDriver.BKUPWrite_Seconds( DeltaTime.Seconds );
 803b0f8:	682b      	ldr	r3, [r5, #0]
 803b0fa:	4798      	blx	r3
  UTIL_SYSTIMDriver.BKUPWrite_SubSeconds( ( uint32_t ) DeltaTime.SubSeconds );
 803b0fc:	68ab      	ldr	r3, [r5, #8]
 803b0fe:	4620      	mov	r0, r4
 803b100:	4798      	blx	r3
}
 803b102:	b005      	add	sp, #20
 803b104:	bd30      	pop	{r4, r5, pc}
 803b106:	bf00      	nop
 803b108:	0803b870 	.word	0x0803b870

0803b10c <SysTimeGet>:

SysTime_t SysTimeGet( void )
{
 803b10c:	b573      	push	{r0, r1, r4, r5, r6, lr}
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
  SysTime_t sysTime = { .Seconds = 0, .SubSeconds = 0 };
  SysTime_t DeltaTime;

  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 803b10e:	4e11      	ldr	r6, [pc, #68]	; (803b154 <SysTimeGet+0x48>)
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 803b110:	2300      	movs	r3, #0
{
 803b112:	4605      	mov	r5, r0
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 803b114:	9300      	str	r3, [sp, #0]
 803b116:	f8ad 3004 	strh.w	r3, [sp, #4]
  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 803b11a:	a801      	add	r0, sp, #4
 803b11c:	6933      	ldr	r3, [r6, #16]
 803b11e:	4798      	blx	r3

  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b120:	68f3      	ldr	r3, [r6, #12]
  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 803b122:	9000      	str	r0, [sp, #0]
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b124:	4798      	blx	r3
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 803b126:	6873      	ldr	r3, [r6, #4]
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b128:	4604      	mov	r4, r0
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 803b12a:	4798      	blx	r3
  c.Seconds = a.Seconds + b.Seconds;
 803b12c:	9b00      	ldr	r3, [sp, #0]
 803b12e:	4418      	add	r0, r3
  c.SubSeconds = a.SubSeconds + b.SubSeconds;
 803b130:	f8bd 3004 	ldrh.w	r3, [sp, #4]
 803b134:	4423      	add	r3, r4
 803b136:	b29a      	uxth	r2, r3
 803b138:	b21b      	sxth	r3, r3
  if( c.SubSeconds >= 1000 )
 803b13a:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
    c.Seconds++;
 803b13e:	bfa2      	ittt	ge
 803b140:	3001      	addge	r0, #1
    c.SubSeconds -= 1000;
 803b142:	f5a2 737a 	subge.w	r3, r2, #1000	; 0x3e8
 803b146:	b21b      	sxthge	r3, r3

  sysTime = SysTimeAdd( DeltaTime, calendarTime );

  return sysTime;
 803b148:	6028      	str	r0, [r5, #0]
}
 803b14a:	4628      	mov	r0, r5
  return sysTime;
 803b14c:	80ab      	strh	r3, [r5, #4]
}
 803b14e:	b002      	add	sp, #8
 803b150:	bd70      	pop	{r4, r5, r6, pc}
 803b152:	bf00      	nop
 803b154:	0803b870 	.word	0x0803b870

0803b158 <SysTimeGetMcuTime>:


SysTime_t SysTimeGetMcuTime( void )
{
 803b158:	b537      	push	{r0, r1, r2, r4, r5, lr}
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 803b15a:	2300      	movs	r3, #0
 803b15c:	9300      	str	r3, [sp, #0]
 803b15e:	f8ad 3004 	strh.w	r3, [sp, #4]

  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 803b162:	4b07      	ldr	r3, [pc, #28]	; (803b180 <SysTimeGetMcuTime+0x28>)
{
 803b164:	4604      	mov	r4, r0
  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 803b166:	691b      	ldr	r3, [r3, #16]
 803b168:	a801      	add	r0, sp, #4
 803b16a:	4798      	blx	r3
 803b16c:	466d      	mov	r5, sp
 803b16e:	9000      	str	r0, [sp, #0]
  
  return calendarTime;
 803b170:	e895 0003 	ldmia.w	r5, {r0, r1}
 803b174:	e884 0003 	stmia.w	r4, {r0, r1}
}
 803b178:	4620      	mov	r0, r4
 803b17a:	b003      	add	sp, #12
 803b17c:	bd30      	pop	{r4, r5, pc}
 803b17e:	bf00      	nop
 803b180:	0803b870 	.word	0x0803b870

0803b184 <SysTimeToMs>:

uint32_t SysTimeToMs( SysTime_t sysTime )
{
 803b184:	b537      	push	{r0, r1, r2, r4, r5, lr}
  SysTime_t DeltaTime;
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b186:	4d0e      	ldr	r5, [pc, #56]	; (803b1c0 <SysTimeToMs+0x3c>)
{
 803b188:	ab02      	add	r3, sp, #8
 803b18a:	e903 0003 	stmdb	r3, {r0, r1}
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b18e:	68eb      	ldr	r3, [r5, #12]
 803b190:	4798      	blx	r3
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 803b192:	686b      	ldr	r3, [r5, #4]
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b194:	4604      	mov	r4, r0
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 803b196:	4798      	blx	r3
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 803b198:	f8bd 3004 	ldrh.w	r3, [sp, #4]
  c.Seconds = a.Seconds - b.Seconds;
 803b19c:	9a00      	ldr	r2, [sp, #0]
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 803b19e:	1b1b      	subs	r3, r3, r4
  c.Seconds = a.Seconds - b.Seconds;
 803b1a0:	1a12      	subs	r2, r2, r0
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 803b1a2:	b298      	uxth	r0, r3
 803b1a4:	b21b      	sxth	r3, r3
  if( c.SubSeconds < 0 )
 803b1a6:	2b00      	cmp	r3, #0
    c.SubSeconds += 1000;
 803b1a8:	bfbe      	ittt	lt
 803b1aa:	f500 707a 	addlt.w	r0, r0, #1000	; 0x3e8
 803b1ae:	b203      	sxthlt	r3, r0
    c.Seconds--;
 803b1b0:	f102 32ff 	addlt.w	r2, r2, #4294967295
  
  SysTime_t calendarTime = SysTimeSub( sysTime, DeltaTime );
  return calendarTime.Seconds * 1000 + calendarTime.SubSeconds;
}
 803b1b4:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 803b1b8:	fb00 3002 	mla	r0, r0, r2, r3
 803b1bc:	b003      	add	sp, #12
 803b1be:	bd30      	pop	{r4, r5, pc}
 803b1c0:	0803b870 	.word	0x0803b870

0803b1c4 <SysTimeFromMs>:

SysTime_t SysTimeFromMs( uint32_t timeMs )
{
 803b1c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t seconds = timeMs / 1000;
 803b1c8:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 803b1cc:	fbb1 f5f5 	udiv	r5, r1, r5
  SysTime_t sysTime = { .Seconds = seconds, .SubSeconds =  timeMs - seconds * 1000 };
 803b1d0:	ebc5 1345 	rsb	r3, r5, r5, lsl #5
  SysTime_t DeltaTime = { 0 };

  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b1d4:	f8df 803c 	ldr.w	r8, [pc, #60]	; 803b214 <SysTimeFromMs+0x50>
  SysTime_t sysTime = { .Seconds = seconds, .SubSeconds =  timeMs - seconds * 1000 };
 803b1d8:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 803b1dc:	eba1 03c3 	sub.w	r3, r1, r3, lsl #3
 803b1e0:	b29c      	uxth	r4, r3
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b1e2:	f8d8 300c 	ldr.w	r3, [r8, #12]
{
 803b1e6:	4606      	mov	r6, r0
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b1e8:	4798      	blx	r3
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 803b1ea:	f8d8 3004 	ldr.w	r3, [r8, #4]
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803b1ee:	4607      	mov	r7, r0
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 803b1f0:	4798      	blx	r3
  c.SubSeconds = a.SubSeconds + b.SubSeconds;
 803b1f2:	19e3      	adds	r3, r4, r7
 803b1f4:	b29a      	uxth	r2, r3
 803b1f6:	b21b      	sxth	r3, r3
  if( c.SubSeconds >= 1000 )
 803b1f8:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
  c.Seconds = a.Seconds + b.Seconds;
 803b1fc:	4405      	add	r5, r0
    c.SubSeconds -= 1000;
 803b1fe:	bfa2      	ittt	ge
 803b200:	f5a2 737a 	subge.w	r3, r2, #1000	; 0x3e8
    c.Seconds++;
 803b204:	3501      	addge	r5, #1
    c.SubSeconds -= 1000;
 803b206:	b21b      	sxthge	r3, r3
  return c;
 803b208:	6035      	str	r5, [r6, #0]
 803b20a:	80b3      	strh	r3, [r6, #4]
  return SysTimeAdd( sysTime, DeltaTime );
}
 803b20c:	4630      	mov	r0, r6
 803b20e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 803b212:	bf00      	nop
 803b214:	0803b870 	.word	0x0803b870

0803b218 <UTIL_TIMER_Init>:
  */

UTIL_TIMER_Status_t UTIL_TIMER_Init(void)
{
  UTIL_TIMER_INIT_CRITICAL_SECTION();
  TimerListHead = NULL;
 803b218:	4b02      	ldr	r3, [pc, #8]	; (803b224 <UTIL_TIMER_Init+0xc>)
 803b21a:	2200      	movs	r2, #0
 803b21c:	601a      	str	r2, [r3, #0]
  return UTIL_TimerDriver.InitTimer();
 803b21e:	4b02      	ldr	r3, [pc, #8]	; (803b228 <UTIL_TIMER_Init+0x10>)
 803b220:	681b      	ldr	r3, [r3, #0]
 803b222:	4718      	bx	r3
 803b224:	20006150 	.word	0x20006150
 803b228:	0803b884 	.word	0x0803b884

0803b22c <UTIL_TIMER_Create>:
{
  return UTIL_TimerDriver.DeInitTimer();
}

UTIL_TIMER_Status_t UTIL_TIMER_Create( UTIL_TIMER_Object_t *TimerObject, uint32_t PeriodValue, UTIL_TIMER_Mode_t Mode, void ( *Callback )( void *), void *Argument)
{
 803b22c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 803b22e:	4604      	mov	r4, r0
 803b230:	4617      	mov	r7, r2
 803b232:	4608      	mov	r0, r1
 803b234:	461e      	mov	r6, r3
  if((TimerObject != NULL) && (Callback != NULL))
 803b236:	b17c      	cbz	r4, 803b258 <UTIL_TIMER_Create+0x2c>
 803b238:	b173      	cbz	r3, 803b258 <UTIL_TIMER_Create+0x2c>
  {
    TimerObject->Timestamp = 0U;
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(PeriodValue);
 803b23a:	4b08      	ldr	r3, [pc, #32]	; (803b25c <UTIL_TIMER_Create+0x30>)
    TimerObject->Timestamp = 0U;
 803b23c:	2500      	movs	r5, #0
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(PeriodValue);
 803b23e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    TimerObject->Timestamp = 0U;
 803b240:	6025      	str	r5, [r4, #0]
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(PeriodValue);
 803b242:	4798      	blx	r3
    TimerObject->IsPending = 0U;
    TimerObject->IsRunning = 0U;
    TimerObject->IsReloadStopped = 0U;
    TimerObject->Callback = Callback;
    TimerObject->argument = Argument;
 803b244:	9b06      	ldr	r3, [sp, #24]
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(PeriodValue);
 803b246:	6060      	str	r0, [r4, #4]
    TimerObject->IsPending = 0U;
 803b248:	8125      	strh	r5, [r4, #8]
    TimerObject->IsReloadStopped = 0U;
 803b24a:	72a5      	strb	r5, [r4, #10]
    TimerObject->Callback = Callback;
 803b24c:	60e6      	str	r6, [r4, #12]
    TimerObject->argument = Argument;
 803b24e:	6123      	str	r3, [r4, #16]
    TimerObject->Mode = Mode;
 803b250:	72e7      	strb	r7, [r4, #11]
    TimerObject->Next = NULL;
 803b252:	6165      	str	r5, [r4, #20]
    return UTIL_TIMER_OK;
 803b254:	4628      	mov	r0, r5
  }
  else
  {
    return UTIL_TIMER_INVALID_PARAM;
  }
}
 803b256:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return UTIL_TIMER_INVALID_PARAM;
 803b258:	2001      	movs	r0, #1
 803b25a:	e7fc      	b.n	803b256 <UTIL_TIMER_Create+0x2a>
 803b25c:	0803b884 	.word	0x0803b884

0803b260 <UTIL_TIMER_GetCurrentTime>:
  }
  UTIL_TIMER_EXIT_CRITICAL_SECTION();
}

UTIL_TIMER_Time_t UTIL_TIMER_GetCurrentTime(void)
{
 803b260:	b510      	push	{r4, lr}
  uint32_t now = UTIL_TimerDriver.GetTimerValue( );
 803b262:	4c03      	ldr	r4, [pc, #12]	; (803b270 <UTIL_TIMER_GetCurrentTime+0x10>)
 803b264:	69e3      	ldr	r3, [r4, #28]
 803b266:	4798      	blx	r3
  return  UTIL_TimerDriver.Tick2ms(now);
 803b268:	6aa3      	ldr	r3, [r4, #40]	; 0x28
}
 803b26a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return  UTIL_TimerDriver.Tick2ms(now);
 803b26e:	4718      	bx	r3
 803b270:	0803b884 	.word	0x0803b884

0803b274 <UTIL_TIMER_GetElapsedTime>:

UTIL_TIMER_Time_t UTIL_TIMER_GetElapsedTime(UTIL_TIMER_Time_t past )
{
 803b274:	b570      	push	{r4, r5, r6, lr}
  uint32_t nowInTicks = UTIL_TimerDriver.GetTimerValue( );
 803b276:	4d06      	ldr	r5, [pc, #24]	; (803b290 <UTIL_TIMER_GetElapsedTime+0x1c>)
 803b278:	69eb      	ldr	r3, [r5, #28]
{
 803b27a:	4606      	mov	r6, r0
  uint32_t nowInTicks = UTIL_TimerDriver.GetTimerValue( );
 803b27c:	4798      	blx	r3
  uint32_t pastInTicks = UTIL_TimerDriver.ms2Tick( past );
 803b27e:	6a6b      	ldr	r3, [r5, #36]	; 0x24
  uint32_t nowInTicks = UTIL_TimerDriver.GetTimerValue( );
 803b280:	4604      	mov	r4, r0
  uint32_t pastInTicks = UTIL_TimerDriver.ms2Tick( past );
 803b282:	4630      	mov	r0, r6
 803b284:	4798      	blx	r3
  /* intentional wrap around. Works Ok if tick duation below 1ms */
  return UTIL_TimerDriver.Tick2ms( nowInTicks- pastInTicks );
 803b286:	6aab      	ldr	r3, [r5, #40]	; 0x28
 803b288:	1a20      	subs	r0, r4, r0
}
 803b28a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  return UTIL_TimerDriver.Tick2ms( nowInTicks- pastInTicks );
 803b28e:	4718      	bx	r3
 803b290:	0803b884 	.word	0x0803b884

0803b294 <TimerExists>:
 * @param TimerObject Structure containing the timer object parameters
 * @retval 1 (the object is already in the list) or 0
 */
bool TimerExists( UTIL_TIMER_Object_t *TimerObject )
{
  UTIL_TIMER_Object_t* cur = TimerListHead;
 803b294:	4a05      	ldr	r2, [pc, #20]	; (803b2ac <TimerExists+0x18>)
{
 803b296:	4603      	mov	r3, r0
  UTIL_TIMER_Object_t* cur = TimerListHead;
 803b298:	6810      	ldr	r0, [r2, #0]

  while( cur != NULL )
 803b29a:	b900      	cbnz	r0, 803b29e <TimerExists+0xa>
 803b29c:	4770      	bx	lr
  {
    if( cur == TimerObject )
 803b29e:	4298      	cmp	r0, r3
 803b2a0:	d001      	beq.n	803b2a6 <TimerExists+0x12>
    {
      return true;
    }
    cur = cur->Next;
 803b2a2:	6940      	ldr	r0, [r0, #20]
 803b2a4:	e7f9      	b.n	803b29a <TimerExists+0x6>
      return true;
 803b2a6:	2001      	movs	r0, #1
  }
  return false;
}
 803b2a8:	4770      	bx	lr
 803b2aa:	bf00      	nop
 803b2ac:	20006150 	.word	0x20006150

0803b2b0 <TimerSetTimeout>:
 * @brief Sets a timeout with the duration "timestamp"
 *
 * @param TimerObject Structure containing the timer object parameters
 */
void TimerSetTimeout( UTIL_TIMER_Object_t *TimerObject )
{
 803b2b0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  uint32_t minTicks= UTIL_TimerDriver.GetMinimumTimeout( );
 803b2b4:	4d0b      	ldr	r5, [pc, #44]	; (803b2e4 <TimerSetTimeout+0x34>)
 803b2b6:	6a2b      	ldr	r3, [r5, #32]
{
 803b2b8:	4604      	mov	r4, r0
  uint32_t minTicks= UTIL_TimerDriver.GetMinimumTimeout( );
 803b2ba:	4798      	blx	r3
  TimerObject->IsPending = 1;
 803b2bc:	2301      	movs	r3, #1

  /* In case deadline too soon */
  if(TimerObject->Timestamp  < (UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks) )
 803b2be:	69af      	ldr	r7, [r5, #24]
  TimerObject->IsPending = 1;
 803b2c0:	7223      	strb	r3, [r4, #8]
  if(TimerObject->Timestamp  < (UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks) )
 803b2c2:	f8d4 8000 	ldr.w	r8, [r4]
  uint32_t minTicks= UTIL_TimerDriver.GetMinimumTimeout( );
 803b2c6:	4606      	mov	r6, r0
  if(TimerObject->Timestamp  < (UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks) )
 803b2c8:	47b8      	blx	r7
 803b2ca:	4430      	add	r0, r6
 803b2cc:	4580      	cmp	r8, r0
 803b2ce:	d202      	bcs.n	803b2d6 <TimerSetTimeout+0x26>
  {
	  TimerObject->Timestamp = UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks;
 803b2d0:	47b8      	blx	r7
 803b2d2:	4406      	add	r6, r0
 803b2d4:	6026      	str	r6, [r4, #0]
  }
  UTIL_TimerDriver.StartTimerEvt( TimerObject->Timestamp );
 803b2d6:	68ab      	ldr	r3, [r5, #8]
 803b2d8:	6820      	ldr	r0, [r4, #0]
 803b2da:	9301      	str	r3, [sp, #4]
}
 803b2dc:	b002      	add	sp, #8
 803b2de:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  UTIL_TimerDriver.StartTimerEvt( TimerObject->Timestamp );
 803b2e2:	4718      	bx	r3
 803b2e4:	0803b884 	.word	0x0803b884

0803b2e8 <UTIL_TIMER_Stop>:
{
 803b2e8:	b570      	push	{r4, r5, r6, lr}
  if (NULL != TimerObject)
 803b2ea:	b320      	cbz	r0, 803b336 <UTIL_TIMER_Stop+0x4e>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803b2ec:	f3ef 8610 	mrs	r6, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803b2f0:	b672      	cpsid	i
    UTIL_TIMER_Object_t* prev = TimerListHead;
 803b2f2:	4d12      	ldr	r5, [pc, #72]	; (803b33c <UTIL_TIMER_Stop+0x54>)
 803b2f4:	682b      	ldr	r3, [r5, #0]
    TimerObject->IsReloadStopped = 1U;
 803b2f6:	2201      	movs	r2, #1
 803b2f8:	7282      	strb	r2, [r0, #10]
    if(NULL != TimerListHead)
 803b2fa:	b153      	cbz	r3, 803b312 <UTIL_TIMER_Stop+0x2a>
      TimerObject->IsRunning = 0U;
 803b2fc:	2200      	movs	r2, #0
      if( TimerListHead == TimerObject ) /* Stop the Head */
 803b2fe:	4298      	cmp	r0, r3
      TimerObject->IsRunning = 0U;
 803b300:	7242      	strb	r2, [r0, #9]
      if( TimerListHead == TimerObject ) /* Stop the Head */
 803b302:	d10f      	bne.n	803b324 <UTIL_TIMER_Stop+0x3c>
 803b304:	6944      	ldr	r4, [r0, #20]
          TimerListHead->IsPending = 0;
 803b306:	7202      	strb	r2, [r0, #8]
          if( TimerListHead->Next != NULL )
 803b308:	b13c      	cbz	r4, 803b31a <UTIL_TIMER_Stop+0x32>
            TimerSetTimeout( TimerListHead );
 803b30a:	4620      	mov	r0, r4
            TimerListHead = TimerListHead->Next;
 803b30c:	602c      	str	r4, [r5, #0]
            TimerSetTimeout( TimerListHead );
 803b30e:	f7ff ffcf 	bl	803b2b0 <TimerSetTimeout>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803b312:	f386 8810 	msr	PRIMASK, r6
}
 803b316:	2000      	movs	r0, #0
}
 803b318:	bd70      	pop	{r4, r5, r6, pc}
            UTIL_TimerDriver.StopTimerEvt( );
 803b31a:	4b09      	ldr	r3, [pc, #36]	; (803b340 <UTIL_TIMER_Stop+0x58>)
 803b31c:	68db      	ldr	r3, [r3, #12]
 803b31e:	4798      	blx	r3
            TimerListHead = NULL;
 803b320:	602c      	str	r4, [r5, #0]
 803b322:	e7f6      	b.n	803b312 <UTIL_TIMER_Stop+0x2a>
            cur = cur->Next;
 803b324:	461a      	mov	r2, r3
 803b326:	695b      	ldr	r3, [r3, #20]
        while( cur != NULL )
 803b328:	2b00      	cmp	r3, #0
 803b32a:	d0f2      	beq.n	803b312 <UTIL_TIMER_Stop+0x2a>
          if( cur == TimerObject )
 803b32c:	4298      	cmp	r0, r3
 803b32e:	d1f9      	bne.n	803b324 <UTIL_TIMER_Stop+0x3c>
            if( cur->Next != NULL )
 803b330:	6943      	ldr	r3, [r0, #20]
              prev->Next = cur;
 803b332:	6153      	str	r3, [r2, #20]
 803b334:	e7ed      	b.n	803b312 <UTIL_TIMER_Stop+0x2a>
    ret = UTIL_TIMER_INVALID_PARAM;
 803b336:	2001      	movs	r0, #1
 803b338:	e7ee      	b.n	803b318 <UTIL_TIMER_Stop+0x30>
 803b33a:	bf00      	nop
 803b33c:	20006150 	.word	0x20006150
 803b340:	0803b884 	.word	0x0803b884

0803b344 <TimerInsertTimer>:
 *
 * @param TimerObject Structure containing the timer object parameters
 */
void TimerInsertTimer( UTIL_TIMER_Object_t *TimerObject)
{
  UTIL_TIMER_Object_t* cur = TimerListHead;
 803b344:	4b09      	ldr	r3, [pc, #36]	; (803b36c <TimerInsertTimer+0x28>)
{
 803b346:	b510      	push	{r4, lr}
  UTIL_TIMER_Object_t* cur = TimerListHead;
 803b348:	681b      	ldr	r3, [r3, #0]
  UTIL_TIMER_Object_t* next = TimerListHead->Next;
 803b34a:	695a      	ldr	r2, [r3, #20]

  while (cur->Next != NULL )
 803b34c:	6959      	ldr	r1, [r3, #20]
 803b34e:	b911      	cbnz	r1, 803b356 <TimerInsertTimer+0x12>
        TimerObject->Next = next;
        return;

    }
  }
  cur->Next = TimerObject;
 803b350:	6158      	str	r0, [r3, #20]
  TimerObject->Next = NULL;
 803b352:	6141      	str	r1, [r0, #20]
 803b354:	e008      	b.n	803b368 <TimerInsertTimer+0x24>
    if( TimerObject->Timestamp  > next->Timestamp )
 803b356:	6804      	ldr	r4, [r0, #0]
 803b358:	6811      	ldr	r1, [r2, #0]
 803b35a:	428c      	cmp	r4, r1
 803b35c:	d902      	bls.n	803b364 <TimerInsertTimer+0x20>
        next = next->Next;
 803b35e:	4613      	mov	r3, r2
 803b360:	6952      	ldr	r2, [r2, #20]
 803b362:	e7f3      	b.n	803b34c <TimerInsertTimer+0x8>
        cur->Next = TimerObject;
 803b364:	6158      	str	r0, [r3, #20]
        TimerObject->Next = next;
 803b366:	6142      	str	r2, [r0, #20]
}
 803b368:	bd10      	pop	{r4, pc}
 803b36a:	bf00      	nop
 803b36c:	20006150 	.word	0x20006150

0803b370 <TimerInsertNewHeadTimer>:
 * @remark The list is automatically sorted. The list head always contains the
 *         next timer to expire.
 */
void TimerInsertNewHeadTimer( UTIL_TIMER_Object_t *TimerObject )
{
  UTIL_TIMER_Object_t* cur = TimerListHead;
 803b370:	4b04      	ldr	r3, [pc, #16]	; (803b384 <TimerInsertNewHeadTimer+0x14>)
 803b372:	681a      	ldr	r2, [r3, #0]

  if( cur != NULL )
 803b374:	b10a      	cbz	r2, 803b37a <TimerInsertNewHeadTimer+0xa>
  {
    cur->IsPending = 0;
 803b376:	2100      	movs	r1, #0
 803b378:	7211      	strb	r1, [r2, #8]
  }

  TimerObject->Next = cur;
 803b37a:	6142      	str	r2, [r0, #20]
  TimerListHead = TimerObject;
 803b37c:	6018      	str	r0, [r3, #0]
  TimerSetTimeout( TimerListHead );
 803b37e:	f7ff bf97 	b.w	803b2b0 <TimerSetTimeout>
 803b382:	bf00      	nop
 803b384:	20006150 	.word	0x20006150

0803b388 <UTIL_TIMER_Start>:
{
 803b388:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if(( TimerObject != NULL ) && ( TimerExists( TimerObject ) == false ) && (TimerObject->IsRunning == 0U))
 803b38c:	4604      	mov	r4, r0
 803b38e:	2800      	cmp	r0, #0
 803b390:	d02d      	beq.n	803b3ee <UTIL_TIMER_Start+0x66>
 803b392:	f7ff ff7f 	bl	803b294 <TimerExists>
 803b396:	bb50      	cbnz	r0, 803b3ee <UTIL_TIMER_Start+0x66>
 803b398:	7a65      	ldrb	r5, [r4, #9]
 803b39a:	bb45      	cbnz	r5, 803b3ee <UTIL_TIMER_Start+0x66>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803b39c:	f3ef 8810 	mrs	r8, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803b3a0:	b672      	cpsid	i
    minValue = UTIL_TimerDriver.GetMinimumTimeout( );
 803b3a2:	4e14      	ldr	r6, [pc, #80]	; (803b3f4 <UTIL_TIMER_Start+0x6c>)
    ticks = TimerObject->ReloadValue;
 803b3a4:	6867      	ldr	r7, [r4, #4]
    minValue = UTIL_TimerDriver.GetMinimumTimeout( );
 803b3a6:	6a33      	ldr	r3, [r6, #32]
 803b3a8:	4798      	blx	r3
    TimerObject->Timestamp = ticks;
 803b3aa:	4287      	cmp	r7, r0
 803b3ac:	bf2c      	ite	cs
 803b3ae:	6027      	strcs	r7, [r4, #0]
 803b3b0:	6020      	strcc	r0, [r4, #0]
    if( TimerListHead == NULL )
 803b3b2:	4f11      	ldr	r7, [pc, #68]	; (803b3f8 <UTIL_TIMER_Start+0x70>)
    TimerObject->IsReloadStopped = 0U;
 803b3b4:	72a5      	strb	r5, [r4, #10]
    TimerObject->IsPending = 0U;
 803b3b6:	f44f 7380 	mov.w	r3, #256	; 0x100
 803b3ba:	8123      	strh	r3, [r4, #8]
    if( TimerListHead == NULL )
 803b3bc:	683b      	ldr	r3, [r7, #0]
 803b3be:	b94b      	cbnz	r3, 803b3d4 <UTIL_TIMER_Start+0x4c>
      UTIL_TimerDriver.SetTimerContext();
 803b3c0:	6933      	ldr	r3, [r6, #16]
 803b3c2:	4798      	blx	r3
      TimerInsertNewHeadTimer( TimerObject ); /* insert a timeout at now+obj->Timestamp */
 803b3c4:	4620      	mov	r0, r4
        TimerInsertNewHeadTimer( TimerObject);
 803b3c6:	f7ff ffd3 	bl	803b370 <TimerInsertNewHeadTimer>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803b3ca:	f388 8810 	msr	PRIMASK, r8
}
 803b3ce:	4628      	mov	r0, r5
 803b3d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      elapsedTime = UTIL_TimerDriver.GetTimerElapsedTime( );
 803b3d4:	69b3      	ldr	r3, [r6, #24]
 803b3d6:	4798      	blx	r3
      TimerObject->Timestamp += elapsedTime;
 803b3d8:	6823      	ldr	r3, [r4, #0]
 803b3da:	4418      	add	r0, r3
      if( TimerObject->Timestamp < TimerListHead->Timestamp )
 803b3dc:	683b      	ldr	r3, [r7, #0]
      TimerObject->Timestamp += elapsedTime;
 803b3de:	6020      	str	r0, [r4, #0]
      if( TimerObject->Timestamp < TimerListHead->Timestamp )
 803b3e0:	681b      	ldr	r3, [r3, #0]
 803b3e2:	4298      	cmp	r0, r3
        TimerInsertNewHeadTimer( TimerObject);
 803b3e4:	4620      	mov	r0, r4
      if( TimerObject->Timestamp < TimerListHead->Timestamp )
 803b3e6:	d3ee      	bcc.n	803b3c6 <UTIL_TIMER_Start+0x3e>
        TimerInsertTimer( TimerObject);
 803b3e8:	f7ff ffac 	bl	803b344 <TimerInsertTimer>
 803b3ec:	e7ed      	b.n	803b3ca <UTIL_TIMER_Start+0x42>
    ret =  UTIL_TIMER_INVALID_PARAM;
 803b3ee:	2501      	movs	r5, #1
 803b3f0:	e7ed      	b.n	803b3ce <UTIL_TIMER_Start+0x46>
 803b3f2:	bf00      	nop
 803b3f4:	0803b884 	.word	0x0803b884
 803b3f8:	20006150 	.word	0x20006150

0803b3fc <UTIL_TIMER_SetPeriod>:
{
 803b3fc:	b510      	push	{r4, lr}
 803b3fe:	4604      	mov	r4, r0
 803b400:	4608      	mov	r0, r1
  if(NULL == TimerObject)
 803b402:	b17c      	cbz	r4, 803b424 <UTIL_TIMER_SetPeriod+0x28>
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(NewPeriodValue);
 803b404:	4b08      	ldr	r3, [pc, #32]	; (803b428 <UTIL_TIMER_SetPeriod+0x2c>)
 803b406:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 803b408:	4798      	blx	r3
 803b40a:	6060      	str	r0, [r4, #4]
    if(TimerExists(TimerObject))
 803b40c:	4620      	mov	r0, r4
 803b40e:	f7ff ff41 	bl	803b294 <TimerExists>
 803b412:	b140      	cbz	r0, 803b426 <UTIL_TIMER_SetPeriod+0x2a>
      (void)UTIL_TIMER_Stop(TimerObject);
 803b414:	4620      	mov	r0, r4
 803b416:	f7ff ff67 	bl	803b2e8 <UTIL_TIMER_Stop>
      ret = UTIL_TIMER_Start(TimerObject);
 803b41a:	4620      	mov	r0, r4
}
 803b41c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      ret = UTIL_TIMER_Start(TimerObject);
 803b420:	f7ff bfb2 	b.w	803b388 <UTIL_TIMER_Start>
	  ret = UTIL_TIMER_INVALID_PARAM;
 803b424:	2001      	movs	r0, #1
}
 803b426:	bd10      	pop	{r4, pc}
 803b428:	0803b884 	.word	0x0803b884

0803b42c <UTIL_TIMER_IRQ_Handler>:
{
 803b42c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803b430:	f3ef 8710 	mrs	r7, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803b434:	b672      	cpsid	i
  old  =  UTIL_TimerDriver.GetTimerContext( );
 803b436:	4e1d      	ldr	r6, [pc, #116]	; (803b4ac <UTIL_TIMER_IRQ_Handler+0x80>)
  if ( TimerListHead != NULL )
 803b438:	4c1d      	ldr	r4, [pc, #116]	; (803b4b0 <UTIL_TIMER_IRQ_Handler+0x84>)
  old  =  UTIL_TimerDriver.GetTimerContext( );
 803b43a:	6973      	ldr	r3, [r6, #20]
 803b43c:	4798      	blx	r3
  now  =  UTIL_TimerDriver.SetTimerContext( );
 803b43e:	6933      	ldr	r3, [r6, #16]
  old  =  UTIL_TimerDriver.GetTimerContext( );
 803b440:	4605      	mov	r5, r0
  now  =  UTIL_TimerDriver.SetTimerContext( );
 803b442:	4798      	blx	r3
  if ( TimerListHead != NULL )
 803b444:	6823      	ldr	r3, [r4, #0]
 803b446:	b94b      	cbnz	r3, 803b45c <UTIL_TIMER_IRQ_Handler+0x30>
      cur->IsPending = 0;
 803b448:	f04f 0800 	mov.w	r8, #0
  while ((TimerListHead != NULL) && ((TimerListHead->Timestamp == 0U) || (TimerListHead->Timestamp < UTIL_TimerDriver.GetTimerElapsedTime(  ))))
 803b44c:	6823      	ldr	r3, [r4, #0]
 803b44e:	b98b      	cbnz	r3, 803b474 <UTIL_TIMER_IRQ_Handler+0x48>
  if(( TimerListHead != NULL ) && (TimerListHead->IsPending == 0U))
 803b450:	6820      	ldr	r0, [r4, #0]
 803b452:	bb28      	cbnz	r0, 803b4a0 <UTIL_TIMER_IRQ_Handler+0x74>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803b454:	f387 8810 	msr	PRIMASK, r7
}
 803b458:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  DeltaContext = now  - old; /*intentional wrap around */
 803b45c:	1b41      	subs	r1, r0, r5
        cur->Timestamp -= DeltaContext;
 803b45e:	1a2d      	subs	r5, r5, r0
      if (cur->Timestamp > DeltaContext)
 803b460:	681a      	ldr	r2, [r3, #0]
 803b462:	428a      	cmp	r2, r1
        cur->Timestamp -= DeltaContext;
 803b464:	bf8c      	ite	hi
 803b466:	1952      	addhi	r2, r2, r5
        cur->Timestamp = 0;
 803b468:	2200      	movls	r2, #0
 803b46a:	601a      	str	r2, [r3, #0]
      cur = cur->Next;
 803b46c:	695b      	ldr	r3, [r3, #20]
    } while(cur != NULL);
 803b46e:	2b00      	cmp	r3, #0
 803b470:	d1f6      	bne.n	803b460 <UTIL_TIMER_IRQ_Handler+0x34>
 803b472:	e7e9      	b.n	803b448 <UTIL_TIMER_IRQ_Handler+0x1c>
  while ((TimerListHead != NULL) && ((TimerListHead->Timestamp == 0U) || (TimerListHead->Timestamp < UTIL_TimerDriver.GetTimerElapsedTime(  ))))
 803b474:	681d      	ldr	r5, [r3, #0]
 803b476:	b11d      	cbz	r5, 803b480 <UTIL_TIMER_IRQ_Handler+0x54>
 803b478:	69b3      	ldr	r3, [r6, #24]
 803b47a:	4798      	blx	r3
 803b47c:	4285      	cmp	r5, r0
 803b47e:	d2e7      	bcs.n	803b450 <UTIL_TIMER_IRQ_Handler+0x24>
      cur = TimerListHead;
 803b480:	6825      	ldr	r5, [r4, #0]
      TimerListHead = TimerListHead->Next;
 803b482:	696b      	ldr	r3, [r5, #20]
 803b484:	6023      	str	r3, [r4, #0]
      cur->IsPending = 0;
 803b486:	f8a5 8008 	strh.w	r8, [r5, #8]
      cur->Callback(cur->argument);
 803b48a:	e9d5 3003 	ldrd	r3, r0, [r5, #12]
 803b48e:	4798      	blx	r3
      if(( cur->Mode == UTIL_TIMER_PERIODIC) && (cur->IsReloadStopped == 0U))
 803b490:	896b      	ldrh	r3, [r5, #10]
 803b492:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 803b496:	d1d9      	bne.n	803b44c <UTIL_TIMER_IRQ_Handler+0x20>
        (void)UTIL_TIMER_Start(cur);
 803b498:	4628      	mov	r0, r5
 803b49a:	f7ff ff75 	bl	803b388 <UTIL_TIMER_Start>
 803b49e:	e7d5      	b.n	803b44c <UTIL_TIMER_IRQ_Handler+0x20>
  if(( TimerListHead != NULL ) && (TimerListHead->IsPending == 0U))
 803b4a0:	7a03      	ldrb	r3, [r0, #8]
 803b4a2:	2b00      	cmp	r3, #0
 803b4a4:	d1d6      	bne.n	803b454 <UTIL_TIMER_IRQ_Handler+0x28>
    TimerSetTimeout( TimerListHead );
 803b4a6:	f7ff ff03 	bl	803b2b0 <TimerSetTimeout>
 803b4aa:	e7d3      	b.n	803b454 <UTIL_TIMER_IRQ_Handler+0x28>
 803b4ac:	0803b884 	.word	0x0803b884
 803b4b0:	20006150 	.word	0x20006150

0803b4b4 <tiny_vsnprintf_like>:

#define CHECK_STR_SIZE(_buf, _str, _size) \
  if ((((_str) - (_buf)) >= ((_size)-1))) { break; }

int tiny_vsnprintf_like(char *buf, const int size, const char *fmt, va_list args)
{
 803b4b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 803b4b8:	b099      	sub	sp, #100	; 0x64

  int field_width;      // Width of output field
  int precision;        // Min. # of digits for integers; max number of chars for from string
  int qualifier;        // 'h', 'l', or 'L' for integer fields

  if (size <= 0)
 803b4ba:	2900      	cmp	r1, #0
{
 803b4bc:	4683      	mov	fp, r0
  if (size <= 0)
 803b4be:	9105      	str	r1, [sp, #20]
 803b4c0:	f340 8109 	ble.w	803b6d6 <tiny_vsnprintf_like+0x222>
  {
    return 0;
  }
  
  for (str = buf; *fmt || ((str - buf) >= size-1); fmt++)
 803b4c4:	4604      	mov	r4, r0
  if (!(type & (ZEROPAD /* TINY option   | LEFT */))) while (size-- > 0) ASSIGN_STR(' ');
 803b4c6:	f04f 0920 	mov.w	r9, #32
  for (str = buf; *fmt || ((str - buf) >= size-1); fmt++)
 803b4ca:	9905      	ldr	r1, [sp, #20]
 803b4cc:	7815      	ldrb	r5, [r2, #0]
 803b4ce:	eba4 000b 	sub.w	r0, r4, fp
 803b4d2:	3901      	subs	r1, #1
 803b4d4:	b925      	cbnz	r5, 803b4e0 <tiny_vsnprintf_like+0x2c>
      num = va_arg(args, unsigned int);

    str = ee_number(str, ((size - 1) - (str - buf)), num, base, field_width, precision, flags);
  }

  *str = '\0';
 803b4d6:	2300      	movs	r3, #0
 803b4d8:	7023      	strb	r3, [r4, #0]
  return str - buf;
}
 803b4da:	b019      	add	sp, #100	; 0x64
 803b4dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    CHECK_STR_SIZE(buf, str, size);
 803b4e0:	4288      	cmp	r0, r1
 803b4e2:	daf8      	bge.n	803b4d6 <tiny_vsnprintf_like+0x22>
    if (*fmt != '%')
 803b4e4:	2d25      	cmp	r5, #37	; 0x25
 803b4e6:	d004      	beq.n	803b4f2 <tiny_vsnprintf_like+0x3e>
      *str++ = *fmt;
 803b4e8:	f804 5b01 	strb.w	r5, [r4], #1
      continue;
 803b4ec:	4616      	mov	r6, r2
  for (str = buf; *fmt || ((str - buf) >= size-1); fmt++)
 803b4ee:	1c72      	adds	r2, r6, #1
 803b4f0:	e7eb      	b.n	803b4ca <tiny_vsnprintf_like+0x16>
    if (*fmt == '0')
 803b4f2:	f892 e001 	ldrb.w	lr, [r2, #1]
 803b4f6:	1c56      	adds	r6, r2, #1
 803b4f8:	f1ae 0230 	sub.w	r2, lr, #48	; 0x30
 803b4fc:	4250      	negs	r0, r2
 803b4fe:	4150      	adcs	r0, r2
    if (is_digit(*fmt))
 803b500:	f1ae 0230 	sub.w	r2, lr, #48	; 0x30
 803b504:	2a09      	cmp	r2, #9
 803b506:	d828      	bhi.n	803b55a <tiny_vsnprintf_like+0xa6>
 803b508:	4637      	mov	r7, r6
  int i = 0;
 803b50a:	2500      	movs	r5, #0
 803b50c:	463e      	mov	r6, r7
  while (is_digit(**s)) i = i*10 + *((*s)++) - '0';
 803b50e:	f817 2b01 	ldrb.w	r2, [r7], #1
 803b512:	f1a2 0c30 	sub.w	ip, r2, #48	; 0x30
 803b516:	f1bc 0f09 	cmp.w	ip, #9
 803b51a:	d919      	bls.n	803b550 <tiny_vsnprintf_like+0x9c>
    switch (*fmt)
 803b51c:	7832      	ldrb	r2, [r6, #0]
 803b51e:	2a69      	cmp	r2, #105	; 0x69
 803b520:	f000 8097 	beq.w	803b652 <tiny_vsnprintf_like+0x19e>
 803b524:	d81c      	bhi.n	803b560 <tiny_vsnprintf_like+0xac>
 803b526:	2a63      	cmp	r2, #99	; 0x63
 803b528:	d028      	beq.n	803b57c <tiny_vsnprintf_like+0xc8>
 803b52a:	2a64      	cmp	r2, #100	; 0x64
 803b52c:	f000 8091 	beq.w	803b652 <tiny_vsnprintf_like+0x19e>
 803b530:	2a58      	cmp	r2, #88	; 0x58
 803b532:	d059      	beq.n	803b5e8 <tiny_vsnprintf_like+0x134>
        if (*fmt != '%') *str++ = '%';
 803b534:	2a25      	cmp	r2, #37	; 0x25
 803b536:	d119      	bne.n	803b56c <tiny_vsnprintf_like+0xb8>
        if (*fmt)
 803b538:	7832      	ldrb	r2, [r6, #0]
 803b53a:	2a00      	cmp	r2, #0
 803b53c:	f000 808d 	beq.w	803b65a <tiny_vsnprintf_like+0x1a6>
          *str++ = *fmt;
 803b540:	f804 2b01 	strb.w	r2, [r4], #1
        CHECK_STR_SIZE(buf, str, size);
 803b544:	eba4 020b 	sub.w	r2, r4, fp
 803b548:	428a      	cmp	r2, r1
 803b54a:	f280 8084 	bge.w	803b656 <tiny_vsnprintf_like+0x1a2>
 803b54e:	e7ce      	b.n	803b4ee <tiny_vsnprintf_like+0x3a>
  while (is_digit(**s)) i = i*10 + *((*s)++) - '0';
 803b550:	260a      	movs	r6, #10
 803b552:	fb06 2505 	mla	r5, r6, r5, r2
 803b556:	3d30      	subs	r5, #48	; 0x30
 803b558:	e7d8      	b.n	803b50c <tiny_vsnprintf_like+0x58>
    field_width = -1;
 803b55a:	f04f 35ff 	mov.w	r5, #4294967295
 803b55e:	e7dd      	b.n	803b51c <tiny_vsnprintf_like+0x68>
    switch (*fmt)
 803b560:	2a75      	cmp	r2, #117	; 0x75
 803b562:	d078      	beq.n	803b656 <tiny_vsnprintf_like+0x1a2>
 803b564:	2a78      	cmp	r2, #120	; 0x78
 803b566:	d041      	beq.n	803b5ec <tiny_vsnprintf_like+0x138>
 803b568:	2a73      	cmp	r2, #115	; 0x73
 803b56a:	d01c      	beq.n	803b5a6 <tiny_vsnprintf_like+0xf2>
        if (*fmt != '%') *str++ = '%';
 803b56c:	2225      	movs	r2, #37	; 0x25
 803b56e:	f804 2b01 	strb.w	r2, [r4], #1
        CHECK_STR_SIZE(buf, str, size);
 803b572:	eba4 020b 	sub.w	r2, r4, fp
 803b576:	428a      	cmp	r2, r1
 803b578:	da6d      	bge.n	803b656 <tiny_vsnprintf_like+0x1a2>
 803b57a:	e7dd      	b.n	803b538 <tiny_vsnprintf_like+0x84>
 803b57c:	1e61      	subs	r1, r4, #1
    switch (*fmt)
 803b57e:	462a      	mov	r2, r5
          while (--field_width > 0) *str++ = ' ';
 803b580:	3a01      	subs	r2, #1
 803b582:	2a00      	cmp	r2, #0
 803b584:	dc0c      	bgt.n	803b5a0 <tiny_vsnprintf_like+0xec>
 803b586:	2d00      	cmp	r5, #0
 803b588:	f105 32ff 	add.w	r2, r5, #4294967295
 803b58c:	bfd8      	it	le
 803b58e:	2200      	movle	r2, #0
 803b590:	4422      	add	r2, r4
        *str++ = (unsigned char) va_arg(args, int);
 803b592:	f853 1b04 	ldr.w	r1, [r3], #4
 803b596:	7011      	strb	r1, [r2, #0]
 803b598:	bfd8      	it	le
 803b59a:	2501      	movle	r5, #1
 803b59c:	442c      	add	r4, r5
        continue;
 803b59e:	e7a6      	b.n	803b4ee <tiny_vsnprintf_like+0x3a>
          while (--field_width > 0) *str++ = ' ';
 803b5a0:	f801 9f01 	strb.w	r9, [r1, #1]!
 803b5a4:	e7ec      	b.n	803b580 <tiny_vsnprintf_like+0xcc>
        s = va_arg(args, char *);
 803b5a6:	4698      	mov	r8, r3
        if (!s) s = "<NULL>";
 803b5a8:	4b4c      	ldr	r3, [pc, #304]	; (803b6dc <tiny_vsnprintf_like+0x228>)
        s = va_arg(args, char *);
 803b5aa:	f858 7b04 	ldr.w	r7, [r8], #4
        if (!s) s = "<NULL>";
 803b5ae:	2f00      	cmp	r7, #0
 803b5b0:	bf08      	it	eq
 803b5b2:	461f      	moveq	r7, r3
        len = strlen(s);
 803b5b4:	4638      	mov	r0, r7
 803b5b6:	f7ef ff43 	bl	802b440 <strlen>
          while (len < field_width--) *str++ = ' ';
 803b5ba:	4623      	mov	r3, r4
 803b5bc:	1961      	adds	r1, r4, r5
 803b5be:	1aca      	subs	r2, r1, r3
 803b5c0:	4290      	cmp	r0, r2
 803b5c2:	db0a      	blt.n	803b5da <tiny_vsnprintf_like+0x126>
 803b5c4:	1a2b      	subs	r3, r5, r0
 803b5c6:	4285      	cmp	r5, r0
 803b5c8:	bfb8      	it	lt
 803b5ca:	2300      	movlt	r3, #0
 803b5cc:	441c      	add	r4, r3
        for (i = 0; i < len; ++i) *str++ = *s++;
 803b5ce:	2300      	movs	r3, #0
 803b5d0:	4283      	cmp	r3, r0
 803b5d2:	db05      	blt.n	803b5e0 <tiny_vsnprintf_like+0x12c>
 803b5d4:	4404      	add	r4, r0
        s = va_arg(args, char *);
 803b5d6:	4643      	mov	r3, r8
 803b5d8:	e789      	b.n	803b4ee <tiny_vsnprintf_like+0x3a>
          while (len < field_width--) *str++ = ' ';
 803b5da:	f803 9b01 	strb.w	r9, [r3], #1
 803b5de:	e7ee      	b.n	803b5be <tiny_vsnprintf_like+0x10a>
        for (i = 0; i < len; ++i) *str++ = *s++;
 803b5e0:	5cfa      	ldrb	r2, [r7, r3]
 803b5e2:	54e2      	strb	r2, [r4, r3]
 803b5e4:	3301      	adds	r3, #1
 803b5e6:	e7f3      	b.n	803b5d0 <tiny_vsnprintf_like+0x11c>
        flags |= UPPERCASE;
 803b5e8:	f040 0040 	orr.w	r0, r0, #64	; 0x40
    switch (*fmt)
 803b5ec:	2710      	movs	r7, #16
    str = ee_number(str, ((size - 1) - (str - buf)), num, base, field_width, precision, flags);
 803b5ee:	eba4 020b 	sub.w	r2, r4, fp
 803b5f2:	9302      	str	r3, [sp, #8]
 803b5f4:	1a8b      	subs	r3, r1, r2
 803b5f6:	9301      	str	r3, [sp, #4]
 803b5f8:	9b02      	ldr	r3, [sp, #8]
  char *dig = lower_digits;
 803b5fa:	4a39      	ldr	r2, [pc, #228]	; (803b6e0 <tiny_vsnprintf_like+0x22c>)
    str = ee_number(str, ((size - 1) - (str - buf)), num, base, field_width, precision, flags);
 803b5fc:	f853 1b04 	ldr.w	r1, [r3], #4
 803b600:	9302      	str	r3, [sp, #8]
  char *dig = lower_digits;
 803b602:	f010 0f40 	tst.w	r0, #64	; 0x40
 803b606:	4b37      	ldr	r3, [pc, #220]	; (803b6e4 <tiny_vsnprintf_like+0x230>)
 803b608:	bf08      	it	eq
 803b60a:	4613      	moveq	r3, r2
  c = (type & ZEROPAD) ? '0' : ' ';
 803b60c:	f1be 0f30 	cmp.w	lr, #48	; 0x30
  char *dig = lower_digits;
 803b610:	9303      	str	r3, [sp, #12]
  c = (type & ZEROPAD) ? '0' : ' ';
 803b612:	bf0c      	ite	eq
 803b614:	2330      	moveq	r3, #48	; 0x30
 803b616:	2320      	movne	r3, #32
 803b618:	9304      	str	r3, [sp, #16]
  if (type & SIGN)
 803b61a:	0783      	lsls	r3, r0, #30
 803b61c:	d51f      	bpl.n	803b65e <tiny_vsnprintf_like+0x1aa>
    if (num < 0)
 803b61e:	2900      	cmp	r1, #0
 803b620:	da1d      	bge.n	803b65e <tiny_vsnprintf_like+0x1aa>
      num = -num;
 803b622:	4249      	negs	r1, r1
      size--;
 803b624:	3d01      	subs	r5, #1
      sign = '-';
 803b626:	f04f 0c2d 	mov.w	ip, #45	; 0x2d
    while (num != 0)
 803b62a:	ab07      	add	r3, sp, #28
 803b62c:	461a      	mov	r2, r3
  i = 0;
 803b62e:	2000      	movs	r0, #0
      tmp[i++] = dig[((unsigned long) num) % (unsigned) base];
 803b630:	4688      	mov	r8, r1
 803b632:	9b03      	ldr	r3, [sp, #12]
 803b634:	fbb1 f1f7 	udiv	r1, r1, r7
 803b638:	fb07 8a11 	mls	sl, r7, r1, r8
    while (num != 0)
 803b63c:	4547      	cmp	r7, r8
      tmp[i++] = dig[((unsigned long) num) % (unsigned) base];
 803b63e:	f813 a00a 	ldrb.w	sl, [r3, sl]
 803b642:	4613      	mov	r3, r2
 803b644:	f100 0001 	add.w	r0, r0, #1
 803b648:	f803 ab01 	strb.w	sl, [r3], #1
 803b64c:	461a      	mov	r2, r3
    while (num != 0)
 803b64e:	d9ef      	bls.n	803b630 <tiny_vsnprintf_like+0x17c>
 803b650:	e00e      	b.n	803b670 <tiny_vsnprintf_like+0x1bc>
        flags |= SIGN;
 803b652:	f040 0002 	orr.w	r0, r0, #2
    base = 10;
 803b656:	270a      	movs	r7, #10
 803b658:	e7c9      	b.n	803b5ee <tiny_vsnprintf_like+0x13a>
          --fmt;
 803b65a:	3e01      	subs	r6, #1
        CHECK_STR_SIZE(buf, str, size);
 803b65c:	e747      	b.n	803b4ee <tiny_vsnprintf_like+0x3a>
  if (num == 0)
 803b65e:	b111      	cbz	r1, 803b666 <tiny_vsnprintf_like+0x1b2>
 803b660:	f04f 0c00 	mov.w	ip, #0
 803b664:	e7e1      	b.n	803b62a <tiny_vsnprintf_like+0x176>
    tmp[i++] = '0';
 803b666:	2030      	movs	r0, #48	; 0x30
 803b668:	f88d 001c 	strb.w	r0, [sp, #28]
 803b66c:	468c      	mov	ip, r1
 803b66e:	2001      	movs	r0, #1
  if (!(type & (ZEROPAD /* TINY option   | LEFT */))) while (size-- > 0) ASSIGN_STR(' ');
 803b670:	f1be 0f30 	cmp.w	lr, #48	; 0x30
  size -= precision;
 803b674:	eba5 0500 	sub.w	r5, r5, r0
  if (!(type & (ZEROPAD /* TINY option   | LEFT */))) while (size-- > 0) ASSIGN_STR(' ');
 803b678:	d110      	bne.n	803b69c <tiny_vsnprintf_like+0x1e8>
  if (sign) ASSIGN_STR(sign);
 803b67a:	f1bc 0f00 	cmp.w	ip, #0
 803b67e:	d028      	beq.n	803b6d2 <tiny_vsnprintf_like+0x21e>
 803b680:	9b01      	ldr	r3, [sp, #4]
 803b682:	f804 cb01 	strb.w	ip, [r4], #1
 803b686:	3b01      	subs	r3, #1
 803b688:	9301      	str	r3, [sp, #4]
 803b68a:	d122      	bne.n	803b6d2 <tiny_vsnprintf_like+0x21e>
 803b68c:	9b02      	ldr	r3, [sp, #8]
 803b68e:	e72e      	b.n	803b4ee <tiny_vsnprintf_like+0x3a>
  if (!(type & (ZEROPAD /* TINY option   | LEFT */))) while (size-- > 0) ASSIGN_STR(' ');
 803b690:	9b01      	ldr	r3, [sp, #4]
 803b692:	f804 9b01 	strb.w	r9, [r4], #1
 803b696:	3b01      	subs	r3, #1
 803b698:	9301      	str	r3, [sp, #4]
 803b69a:	d0f7      	beq.n	803b68c <tiny_vsnprintf_like+0x1d8>
 803b69c:	2d00      	cmp	r5, #0
 803b69e:	f105 35ff 	add.w	r5, r5, #4294967295
 803b6a2:	dcf5      	bgt.n	803b690 <tiny_vsnprintf_like+0x1dc>
 803b6a4:	e7e9      	b.n	803b67a <tiny_vsnprintf_like+0x1c6>
  while (size-- > 0) ASSIGN_STR(c);
 803b6a6:	9b04      	ldr	r3, [sp, #16]
 803b6a8:	f804 3b01 	strb.w	r3, [r4], #1
 803b6ac:	9b01      	ldr	r3, [sp, #4]
 803b6ae:	3b01      	subs	r3, #1
 803b6b0:	9301      	str	r3, [sp, #4]
 803b6b2:	d0eb      	beq.n	803b68c <tiny_vsnprintf_like+0x1d8>
 803b6b4:	1b29      	subs	r1, r5, r4
 803b6b6:	2900      	cmp	r1, #0
 803b6b8:	dcf5      	bgt.n	803b6a6 <tiny_vsnprintf_like+0x1f2>
  while (i-- > 0) ASSIGN_STR(tmp[i]);
 803b6ba:	9b01      	ldr	r3, [sp, #4]
 803b6bc:	4423      	add	r3, r4
 803b6be:	461a      	mov	r2, r3
 803b6c0:	3801      	subs	r0, #1
 803b6c2:	d3e3      	bcc.n	803b68c <tiny_vsnprintf_like+0x1d8>
 803b6c4:	ab07      	add	r3, sp, #28
 803b6c6:	5c19      	ldrb	r1, [r3, r0]
 803b6c8:	f804 1b01 	strb.w	r1, [r4], #1
 803b6cc:	4294      	cmp	r4, r2
 803b6ce:	d1f7      	bne.n	803b6c0 <tiny_vsnprintf_like+0x20c>
 803b6d0:	e7dc      	b.n	803b68c <tiny_vsnprintf_like+0x1d8>
 803b6d2:	4425      	add	r5, r4
 803b6d4:	e7ee      	b.n	803b6b4 <tiny_vsnprintf_like+0x200>
    return 0;
 803b6d6:	2000      	movs	r0, #0
 803b6d8:	e6ff      	b.n	803b4da <tiny_vsnprintf_like+0x26>
 803b6da:	bf00      	nop
 803b6dc:	0803c4f5 	.word	0x0803c4f5
 803b6e0:	0803c521 	.word	0x0803c521
 803b6e4:	0803c4fc 	.word	0x0803c4fc

0803b6e8 <__libc_init_array>:
 803b6e8:	b570      	push	{r4, r5, r6, lr}
 803b6ea:	4d0d      	ldr	r5, [pc, #52]	; (803b720 <__libc_init_array+0x38>)
 803b6ec:	4c0d      	ldr	r4, [pc, #52]	; (803b724 <__libc_init_array+0x3c>)
 803b6ee:	1b64      	subs	r4, r4, r5
 803b6f0:	10a4      	asrs	r4, r4, #2
 803b6f2:	2600      	movs	r6, #0
 803b6f4:	42a6      	cmp	r6, r4
 803b6f6:	d109      	bne.n	803b70c <__libc_init_array+0x24>
 803b6f8:	4d0b      	ldr	r5, [pc, #44]	; (803b728 <__libc_init_array+0x40>)
 803b6fa:	4c0c      	ldr	r4, [pc, #48]	; (803b72c <__libc_init_array+0x44>)
 803b6fc:	f000 f8a0 	bl	803b840 <_init>
 803b700:	1b64      	subs	r4, r4, r5
 803b702:	10a4      	asrs	r4, r4, #2
 803b704:	2600      	movs	r6, #0
 803b706:	42a6      	cmp	r6, r4
 803b708:	d105      	bne.n	803b716 <__libc_init_array+0x2e>
 803b70a:	bd70      	pop	{r4, r5, r6, pc}
 803b70c:	f855 3b04 	ldr.w	r3, [r5], #4
 803b710:	4798      	blx	r3
 803b712:	3601      	adds	r6, #1
 803b714:	e7ee      	b.n	803b6f4 <__libc_init_array+0xc>
 803b716:	f855 3b04 	ldr.w	r3, [r5], #4
 803b71a:	4798      	blx	r3
 803b71c:	3601      	adds	r6, #1
 803b71e:	e7f2      	b.n	803b706 <__libc_init_array+0x1e>
 803b720:	0803c550 	.word	0x0803c550
 803b724:	0803c550 	.word	0x0803c550
 803b728:	0803c550 	.word	0x0803c550
 803b72c:	0803c554 	.word	0x0803c554

0803b730 <memset>:
 803b730:	4402      	add	r2, r0
 803b732:	4603      	mov	r3, r0
 803b734:	4293      	cmp	r3, r2
 803b736:	d100      	bne.n	803b73a <memset+0xa>
 803b738:	4770      	bx	lr
 803b73a:	f803 1b01 	strb.w	r1, [r3], #1
 803b73e:	e7f9      	b.n	803b734 <memset+0x4>

0803b740 <floor>:
 803b740:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 803b744:	f3c1 580a 	ubfx	r8, r1, #20, #11
 803b748:	f2a8 36ff 	subw	r6, r8, #1023	; 0x3ff
 803b74c:	2e13      	cmp	r6, #19
 803b74e:	4602      	mov	r2, r0
 803b750:	460b      	mov	r3, r1
 803b752:	4607      	mov	r7, r0
 803b754:	460c      	mov	r4, r1
 803b756:	4605      	mov	r5, r0
 803b758:	dc34      	bgt.n	803b7c4 <floor+0x84>
 803b75a:	2e00      	cmp	r6, #0
 803b75c:	da15      	bge.n	803b78a <floor+0x4a>
 803b75e:	a334      	add	r3, pc, #208	; (adr r3, 803b830 <floor+0xf0>)
 803b760:	e9d3 2300 	ldrd	r2, r3, [r3]
 803b764:	f7ef fe7a 	bl	802b45c <__adddf3>
 803b768:	2200      	movs	r2, #0
 803b76a:	2300      	movs	r3, #0
 803b76c:	f7f0 f8aa 	bl	802b8c4 <__aeabi_dcmpgt>
 803b770:	b140      	cbz	r0, 803b784 <floor+0x44>
 803b772:	2c00      	cmp	r4, #0
 803b774:	da59      	bge.n	803b82a <floor+0xea>
 803b776:	f024 4300 	bic.w	r3, r4, #2147483648	; 0x80000000
 803b77a:	ea57 0503 	orrs.w	r5, r7, r3
 803b77e:	d001      	beq.n	803b784 <floor+0x44>
 803b780:	4c2d      	ldr	r4, [pc, #180]	; (803b838 <floor+0xf8>)
 803b782:	2500      	movs	r5, #0
 803b784:	4623      	mov	r3, r4
 803b786:	462f      	mov	r7, r5
 803b788:	e025      	b.n	803b7d6 <floor+0x96>
 803b78a:	4a2c      	ldr	r2, [pc, #176]	; (803b83c <floor+0xfc>)
 803b78c:	fa42 f806 	asr.w	r8, r2, r6
 803b790:	ea01 0208 	and.w	r2, r1, r8
 803b794:	4302      	orrs	r2, r0
 803b796:	d01e      	beq.n	803b7d6 <floor+0x96>
 803b798:	a325      	add	r3, pc, #148	; (adr r3, 803b830 <floor+0xf0>)
 803b79a:	e9d3 2300 	ldrd	r2, r3, [r3]
 803b79e:	f7ef fe5d 	bl	802b45c <__adddf3>
 803b7a2:	2200      	movs	r2, #0
 803b7a4:	2300      	movs	r3, #0
 803b7a6:	f7f0 f88d 	bl	802b8c4 <__aeabi_dcmpgt>
 803b7aa:	2800      	cmp	r0, #0
 803b7ac:	d0ea      	beq.n	803b784 <floor+0x44>
 803b7ae:	2c00      	cmp	r4, #0
 803b7b0:	bfbe      	ittt	lt
 803b7b2:	f44f 1380 	movlt.w	r3, #1048576	; 0x100000
 803b7b6:	fa43 f606 	asrlt.w	r6, r3, r6
 803b7ba:	19a4      	addlt	r4, r4, r6
 803b7bc:	ea24 0408 	bic.w	r4, r4, r8
 803b7c0:	2500      	movs	r5, #0
 803b7c2:	e7df      	b.n	803b784 <floor+0x44>
 803b7c4:	2e33      	cmp	r6, #51	; 0x33
 803b7c6:	dd0a      	ble.n	803b7de <floor+0x9e>
 803b7c8:	f5b6 6f80 	cmp.w	r6, #1024	; 0x400
 803b7cc:	d103      	bne.n	803b7d6 <floor+0x96>
 803b7ce:	f7ef fe45 	bl	802b45c <__adddf3>
 803b7d2:	4607      	mov	r7, r0
 803b7d4:	460b      	mov	r3, r1
 803b7d6:	4638      	mov	r0, r7
 803b7d8:	4619      	mov	r1, r3
 803b7da:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 803b7de:	f2a8 4813 	subw	r8, r8, #1043	; 0x413
 803b7e2:	f04f 32ff 	mov.w	r2, #4294967295
 803b7e6:	fa22 f808 	lsr.w	r8, r2, r8
 803b7ea:	ea18 0f00 	tst.w	r8, r0
 803b7ee:	d0f2      	beq.n	803b7d6 <floor+0x96>
 803b7f0:	a30f      	add	r3, pc, #60	; (adr r3, 803b830 <floor+0xf0>)
 803b7f2:	e9d3 2300 	ldrd	r2, r3, [r3]
 803b7f6:	f7ef fe31 	bl	802b45c <__adddf3>
 803b7fa:	2200      	movs	r2, #0
 803b7fc:	2300      	movs	r3, #0
 803b7fe:	f7f0 f861 	bl	802b8c4 <__aeabi_dcmpgt>
 803b802:	2800      	cmp	r0, #0
 803b804:	d0be      	beq.n	803b784 <floor+0x44>
 803b806:	2c00      	cmp	r4, #0
 803b808:	da02      	bge.n	803b810 <floor+0xd0>
 803b80a:	2e14      	cmp	r6, #20
 803b80c:	d103      	bne.n	803b816 <floor+0xd6>
 803b80e:	3401      	adds	r4, #1
 803b810:	ea25 0508 	bic.w	r5, r5, r8
 803b814:	e7b6      	b.n	803b784 <floor+0x44>
 803b816:	2301      	movs	r3, #1
 803b818:	f1c6 0634 	rsb	r6, r6, #52	; 0x34
 803b81c:	fa03 f606 	lsl.w	r6, r3, r6
 803b820:	4435      	add	r5, r6
 803b822:	42bd      	cmp	r5, r7
 803b824:	bf38      	it	cc
 803b826:	18e4      	addcc	r4, r4, r3
 803b828:	e7f2      	b.n	803b810 <floor+0xd0>
 803b82a:	2500      	movs	r5, #0
 803b82c:	462c      	mov	r4, r5
 803b82e:	e7a9      	b.n	803b784 <floor+0x44>
 803b830:	8800759c 	.word	0x8800759c
 803b834:	7e37e43c 	.word	0x7e37e43c
 803b838:	bff00000 	.word	0xbff00000
 803b83c:	000fffff 	.word	0x000fffff

0803b840 <_init>:
 803b840:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 803b842:	bf00      	nop
 803b844:	bcf8      	pop	{r3, r4, r5, r6, r7}
 803b846:	bc08      	pop	{r3}
 803b848:	469e      	mov	lr, r3
 803b84a:	4770      	bx	lr

0803b84c <_fini>:
 803b84c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 803b84e:	bf00      	nop
 803b850:	bcf8      	pop	{r3, r4, r5, r6, r7}
 803b852:	bc08      	pop	{r3}
 803b854:	469e      	mov	lr, r3
 803b856:	4770      	bx	lr
