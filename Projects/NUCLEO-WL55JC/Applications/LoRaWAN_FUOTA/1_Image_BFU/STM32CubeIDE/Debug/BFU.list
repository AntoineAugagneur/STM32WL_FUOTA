
BFU.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000138  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 SE_CORE_Bin   000083d0  08000200  08000200  00010200  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .SE_IF_Code   00000d70  08008700  08008700  00018700  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .text         000068f8  08009600  08009600  00019600  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001540  0800fef8  0800fef8  0001fef8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .ARM.extab    00000000  08011438  08011438  00023480  2**0
                  CONTENTS
  6 .ARM          00000008  08011438  08011438  00021438  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .preinit_array 00000000  08011440  08011440  00023480  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  8 .init_array   00000008  08011440  08011440  00021440  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .fini_array   00000008  08011448  08011448  00021448  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .data         00000080  20003400  08011450  00023400  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .bss          00000ab0  20003480  080114d0  00023480  2**3
                  ALLOC
 12 ._user_heap_stack 00002000  20003f30  080114d0  00023f30  2**0
                  ALLOC
 13 .ARM.attributes 0000002a  00000000  00000000  00023480  2**0
                  CONTENTS, READONLY
 14 .debug_info   0003386e  00000000  00000000  000234aa  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_abbrev 00007187  00000000  00000000  00056d18  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_loc    00012881  00000000  00000000  0005de9f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_aranges 000012c8  00000000  00000000  00070720  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_ranges 00001ee8  00000000  00000000  000719e8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_macro  00026a2b  00000000  00000000  000738d0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_line   00028f56  00000000  00000000  0009a2fb  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_str    000d40ce  00000000  00000000  000c3251  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .comment      00000053  00000000  00000000  0019731f  2**0
                  CONTENTS, READONLY
 23 .debug_frame  00003a40  00000000  00000000  00197374  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .SE_IF_Code:

08008700 <SE_APP_GetActiveFwInfo>:
  * @param pFwInfo Active Firmware Info structure that will be filled.
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
__root SE_ErrorStatus SE_APP_GetActiveFwInfo(SE_StatusTypeDef *peSE_Status, uint32_t SlotNumber,
                                             SE_APP_ActiveFwInfo_t *pFwInfo)
{
 8008700:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 8008702:	460d      	mov	r5, r1
 8008704:	4616      	mov	r6, r2
 8008706:	4604      	mov	r4, r0

    /* Set the CallGate function pointer */
    SET_CALLGATE();

    /*Enter Secure Mode*/
    SE_EnterSecureMode(&primask_bit);
 8008708:	a803      	add	r0, sp, #12
 800870a:	f000 fa67 	bl	8008bdc <SE_EnterSecureMode>

    /*Secure Engine Call*/
    e_ret_status = (*SE_CallGatePtr)(SE_APP_GET_ACTIVE_FW_INFO, peSE_Status, primask_bit, SlotNumber, pFwInfo);
 800870e:	4621      	mov	r1, r4
 8008710:	9a03      	ldr	r2, [sp, #12]
 8008712:	4c06      	ldr	r4, [pc, #24]	; (800872c <SE_APP_GetActiveFwInfo+0x2c>)
 8008714:	9600      	str	r6, [sp, #0]
 8008716:	462b      	mov	r3, r5
 8008718:	2020      	movs	r0, #32
 800871a:	47a0      	blx	r4
 800871c:	4604      	mov	r4, r0

    /*Exit Secure Mode*/
    SE_ExitSecureMode(primask_bit);
 800871e:	9803      	ldr	r0, [sp, #12]
 8008720:	f000 fa61 	bl	8008be6 <SE_ExitSecureMode>

#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  return e_ret_status;
}
 8008724:	4620      	mov	r0, r4
 8008726:	b004      	add	sp, #16
 8008728:	bd70      	pop	{r4, r5, r6, pc}
 800872a:	bf00      	nop
 800872c:	08000205 	.word	0x08000205

08008730 <SE_Init>:
  *        This parameter can be a value of @ref SE_Status_Structure_definition.
  * @param uSystemCoreClock System clock value.
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_Init(SE_StatusTypeDef *peSE_Status, uint32_t uSystemCoreClock)
{
 8008730:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8008732:	4604      	mov	r4, r0
 8008734:	460d      	mov	r5, r1
}
#elif defined(__GNUC__)
static inline uint32_t __get_LR(void)
{
  register uint32_t result;
  __asm volatile("MOV %0, LR\n" : "=r"(result));
 8008736:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 8008738:	4b0c      	ldr	r3, [pc, #48]	; (800876c <SE_Init+0x3c>)
 800873a:	429a      	cmp	r2, r3
 800873c:	d314      	bcc.n	8008768 <SE_Init+0x38>
 800873e:	4672      	mov	r2, lr
 8008740:	4b0b      	ldr	r3, [pc, #44]	; (8008770 <SE_Init+0x40>)
 8008742:	429a      	cmp	r2, r3
 8008744:	d810      	bhi.n	8008768 <SE_Init+0x38>

  /* Check the pointers allocation */
  if (peSE_Status == NULL)
 8008746:	b178      	cbz	r0, 8008768 <SE_Init+0x38>

  /* Set the CallGate function pointer */
  SET_CALLGATE();

  /* Enter Secure Mode */
  SE_EnterSecureMode(&primask_bit);
 8008748:	a801      	add	r0, sp, #4
 800874a:	f000 fa47 	bl	8008bdc <SE_EnterSecureMode>

  /* Secure Engine Call */
  e_ret_status = (*SE_CallGatePtr)(SE_INIT_ID, peSE_Status, primask_bit, uSystemCoreClock);
 800874e:	4621      	mov	r1, r4
 8008750:	9a01      	ldr	r2, [sp, #4]
 8008752:	4c08      	ldr	r4, [pc, #32]	; (8008774 <SE_Init+0x44>)
 8008754:	462b      	mov	r3, r5
 8008756:	2000      	movs	r0, #0
 8008758:	47a0      	blx	r4
 800875a:	4604      	mov	r4, r0

  /* Exit Secure Mode */
  SE_ExitSecureMode(primask_bit);
 800875c:	9801      	ldr	r0, [sp, #4]
 800875e:	f000 fa42 	bl	8008be6 <SE_ExitSecureMode>


  return e_ret_status;
}
 8008762:	4620      	mov	r0, r4
 8008764:	b003      	add	sp, #12
 8008766:	bd30      	pop	{r4, r5, pc}
  __IS_SFU_RESERVED();
 8008768:	4c03      	ldr	r4, [pc, #12]	; (8008778 <SE_Init+0x48>)
 800876a:	e7fa      	b.n	8008762 <SE_Init+0x32>
 800876c:	08009600 	.word	0x08009600
 8008770:	08012fff 	.word	0x08012fff
 8008774:	08000205 	.word	0x08000205
 8008778:	00018799 	.word	0x00018799

0800877c <SE_Startup>:
  *        This function must be called only one time so an internal check is executed.
  * @param None.
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_Startup(void)
{
 800877c:	b538      	push	{r3, r4, r5, lr}
 800877e:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  static uint8_t b_startup_already_done = 0U;
  static SE_ErrorStatus(*SE_StartupPtr)(void);            /*!< Secure Engine STARTUP  pointer function*/

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 8008780:	4b0a      	ldr	r3, [pc, #40]	; (80087ac <SE_Startup+0x30>)
 8008782:	429a      	cmp	r2, r3
 8008784:	d30e      	bcc.n	80087a4 <SE_Startup+0x28>
 8008786:	4672      	mov	r2, lr
 8008788:	4b09      	ldr	r3, [pc, #36]	; (80087b0 <SE_Startup+0x34>)
 800878a:	429a      	cmp	r2, r3
 800878c:	d80a      	bhi.n	80087a4 <SE_Startup+0x28>

  /* Need to be sure to execute this initialization only one time! */
  if (b_startup_already_done == 0U)
 800878e:	4d09      	ldr	r5, [pc, #36]	; (80087b4 <SE_Startup+0x38>)
 8008790:	4c09      	ldr	r4, [pc, #36]	; (80087b8 <SE_Startup+0x3c>)
 8008792:	782b      	ldrb	r3, [r5, #0]
 8008794:	b943      	cbnz	r3, 80087a8 <SE_Startup+0x2c>
  {
    /* Secure Core Initialization */
    SE_StartupPtr = (SE_ErrorStatus(*)(void))((uint32_t) SE_STARTUP_REGION_ROM_START + 1U);
 8008796:	4b09      	ldr	r3, [pc, #36]	; (80087bc <SE_Startup+0x40>)
    e_ret_status = (*SE_StartupPtr)();
 8008798:	4798      	blx	r3
    if (e_ret_status == SE_SUCCESS)
 800879a:	42a0      	cmp	r0, r4
 800879c:	d101      	bne.n	80087a2 <SE_Startup+0x26>
    {
      b_startup_already_done = 1U;
 800879e:	2301      	movs	r3, #1
 80087a0:	702b      	strb	r3, [r5, #0]
    /* This function has been already successfully called */
    e_ret_status = SE_SUCCESS;
  }

  return e_ret_status;
}
 80087a2:	bd38      	pop	{r3, r4, r5, pc}
  __IS_SFU_RESERVED();
 80087a4:	4806      	ldr	r0, [pc, #24]	; (80087c0 <SE_Startup+0x44>)
 80087a6:	e7fc      	b.n	80087a2 <SE_Startup+0x26>
    e_ret_status = SE_SUCCESS;
 80087a8:	4620      	mov	r0, r4
 80087aa:	e7fa      	b.n	80087a2 <SE_Startup+0x26>
 80087ac:	08009600 	.word	0x08009600
 80087b0:	08012fff 	.word	0x08012fff
 80087b4:	20003c5c 	.word	0x20003c5c
 80087b8:	0012310f 	.word	0x0012310f
 80087bc:	08000601 	.word	0x08000601
 80087c0:	00018799 	.word	0x00018799

080087c4 <SE_LockRestrictServices>:
  * @brief call by SFU to lock part of Secure Engine services
  * @param  pSE_Status Secure Engine Status.
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_LockRestrictServices(SE_StatusTypeDef *pSE_Status)
{
 80087c4:	b513      	push	{r0, r1, r4, lr}
 80087c6:	4604      	mov	r4, r0
 80087c8:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 80087ca:	4b0c      	ldr	r3, [pc, #48]	; (80087fc <SE_LockRestrictServices+0x38>)
 80087cc:	429a      	cmp	r2, r3
 80087ce:	d313      	bcc.n	80087f8 <SE_LockRestrictServices+0x34>
 80087d0:	4672      	mov	r2, lr
 80087d2:	4b0b      	ldr	r3, [pc, #44]	; (8008800 <SE_LockRestrictServices+0x3c>)
 80087d4:	429a      	cmp	r2, r3
 80087d6:	d80f      	bhi.n	80087f8 <SE_LockRestrictServices+0x34>
#endif /* SFU_ISOLATE_SE_WITH_MPU */

    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 80087d8:	a801      	add	r0, sp, #4
 80087da:	f000 f9ff 	bl	8008bdc <SE_EnterSecureMode>
    e_ret_status = (*SE_CallGatePtr)(SE_LOCK_RESTRICT_SERVICES, pSE_Status, primask_bit);
 80087de:	4621      	mov	r1, r4
 80087e0:	9a01      	ldr	r2, [sp, #4]
 80087e2:	4b08      	ldr	r3, [pc, #32]	; (8008804 <SE_LockRestrictServices+0x40>)
 80087e4:	f44f 7080 	mov.w	r0, #256	; 0x100
 80087e8:	4798      	blx	r3
 80087ea:	4604      	mov	r4, r0
    SE_ExitSecureMode(primask_bit);
 80087ec:	9801      	ldr	r0, [sp, #4]
 80087ee:	f000 f9fa 	bl	8008be6 <SE_ExitSecureMode>
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  return e_ret_status;
}
 80087f2:	4620      	mov	r0, r4
 80087f4:	b002      	add	sp, #8
 80087f6:	bd10      	pop	{r4, pc}
  __IS_SFU_RESERVED();
 80087f8:	4c03      	ldr	r4, [pc, #12]	; (8008808 <SE_LockRestrictServices+0x44>)
 80087fa:	e7fa      	b.n	80087f2 <SE_LockRestrictServices+0x2e>
 80087fc:	08009600 	.word	0x08009600
 8008800:	08012fff 	.word	0x08012fff
 8008804:	08000205 	.word	0x08000205
 8008808:	00018799 	.word	0x00018799

0800880c <SE_CM0_Update>:
  * @brief call by SFU to trigg FUS or wireless stack update process managed by CM0
  * @param  pSE_Status Secure Engine Status.
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_CM0_Update(SE_StatusTypeDef *pSE_Status)
{
 800880c:	b513      	push	{r0, r1, r4, lr}
 800880e:	4604      	mov	r4, r0
 8008810:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 8008812:	4b0c      	ldr	r3, [pc, #48]	; (8008844 <SE_CM0_Update+0x38>)
 8008814:	429a      	cmp	r2, r3
 8008816:	d313      	bcc.n	8008840 <SE_CM0_Update+0x34>
 8008818:	4672      	mov	r2, lr
 800881a:	4b0b      	ldr	r3, [pc, #44]	; (8008848 <SE_CM0_Update+0x3c>)
 800881c:	429a      	cmp	r2, r3
 800881e:	d80f      	bhi.n	8008840 <SE_CM0_Update+0x34>
#endif /* SFU_ISOLATE_SE_WITH_MPU */

    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 8008820:	a801      	add	r0, sp, #4
 8008822:	f000 f9db 	bl	8008bdc <SE_EnterSecureMode>
    e_ret_status = (*SE_CallGatePtr)(SE_CM0_UPDATE, pSE_Status, primask_bit);
 8008826:	4621      	mov	r1, r4
 8008828:	9a01      	ldr	r2, [sp, #4]
 800882a:	4b08      	ldr	r3, [pc, #32]	; (800884c <SE_CM0_Update+0x40>)
 800882c:	f44f 7090 	mov.w	r0, #288	; 0x120
 8008830:	4798      	blx	r3
 8008832:	4604      	mov	r4, r0
    SE_ExitSecureMode(primask_bit);
 8008834:	9801      	ldr	r0, [sp, #4]
 8008836:	f000 f9d6 	bl	8008be6 <SE_ExitSecureMode>
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  return e_ret_status;
}
 800883a:	4620      	mov	r0, r4
 800883c:	b002      	add	sp, #8
 800883e:	bd10      	pop	{r4, pc}
  __IS_SFU_RESERVED();
 8008840:	4c03      	ldr	r4, [pc, #12]	; (8008850 <SE_CM0_Update+0x44>)
 8008842:	e7fa      	b.n	800883a <SE_CM0_Update+0x2e>
 8008844:	08009600 	.word	0x08009600
 8008848:	08012fff 	.word	0x08012fff
 800884c:	08000205 	.word	0x08000205
 8008850:	00018799 	.word	0x00018799

08008854 <SE_ExtFlash_Decrypt_Init>:
  *        This parameter can be a value of @ref SE_Status_Structure_definition.
  * @param pxSE_Metadata Metadata that will be used to fill the Crypto Init structure.
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_ExtFlash_Decrypt_Init(SE_StatusTypeDef *pSE_Status, SE_FwRawHeaderTypeDef *pxSE_Metadata)
{
 8008854:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8008856:	4604      	mov	r4, r0
 8008858:	460d      	mov	r5, r1
 800885a:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 800885c:	4b0c      	ldr	r3, [pc, #48]	; (8008890 <SE_ExtFlash_Decrypt_Init+0x3c>)
 800885e:	429a      	cmp	r2, r3
 8008860:	d314      	bcc.n	800888c <SE_ExtFlash_Decrypt_Init+0x38>
 8008862:	4672      	mov	r2, lr
 8008864:	4b0b      	ldr	r3, [pc, #44]	; (8008894 <SE_ExtFlash_Decrypt_Init+0x40>)
 8008866:	429a      	cmp	r2, r3
 8008868:	d810      	bhi.n	800888c <SE_ExtFlash_Decrypt_Init+0x38>
#endif /* SFU_ISOLATE_SE_WITH_MPU */

    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 800886a:	a801      	add	r0, sp, #4
 800886c:	f000 f9b6 	bl	8008bdc <SE_EnterSecureMode>
    e_ret_status = (*SE_CallGatePtr)(SE_EXTFLASH_DECRYPT_INIT, pSE_Status, primask_bit, pxSE_Metadata);
 8008870:	4621      	mov	r1, r4
 8008872:	9a01      	ldr	r2, [sp, #4]
 8008874:	4c08      	ldr	r4, [pc, #32]	; (8008898 <SE_ExtFlash_Decrypt_Init+0x44>)
 8008876:	462b      	mov	r3, r5
 8008878:	f44f 7088 	mov.w	r0, #272	; 0x110
 800887c:	47a0      	blx	r4
 800887e:	4604      	mov	r4, r0
    SE_ExitSecureMode(primask_bit);
 8008880:	9801      	ldr	r0, [sp, #4]
 8008882:	f000 f9b0 	bl	8008be6 <SE_ExitSecureMode>
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  return e_ret_status;
}
 8008886:	4620      	mov	r0, r4
 8008888:	b003      	add	sp, #12
 800888a:	bd30      	pop	{r4, r5, pc}
  __IS_SFU_RESERVED();
 800888c:	4c03      	ldr	r4, [pc, #12]	; (800889c <SE_ExtFlash_Decrypt_Init+0x48>)
 800888e:	e7fa      	b.n	8008886 <SE_ExtFlash_Decrypt_Init+0x32>
 8008890:	08009600 	.word	0x08009600
 8008894:	08012fff 	.word	0x08012fff
 8008898:	08000205 	.word	0x08000205
 800889c:	00018799 	.word	0x00018799

080088a0 <SE_SFU_IMG_Read>:
  * @param  Length: number of bytes to read from flash
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_SFU_IMG_Read(SE_StatusTypeDef *pSE_Status, uint8_t *pDestination, const uint8_t *pSource,
                               uint32_t Length)
{
 80088a0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80088a2:	4604      	mov	r4, r0
 80088a4:	b085      	sub	sp, #20
 80088a6:	460d      	mov	r5, r1
 80088a8:	4616      	mov	r6, r2
 80088aa:	461f      	mov	r7, r3
 80088ac:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 80088ae:	4b0d      	ldr	r3, [pc, #52]	; (80088e4 <SE_SFU_IMG_Read+0x44>)
 80088b0:	429a      	cmp	r2, r3
 80088b2:	d315      	bcc.n	80088e0 <SE_SFU_IMG_Read+0x40>
 80088b4:	4672      	mov	r2, lr
 80088b6:	4b0c      	ldr	r3, [pc, #48]	; (80088e8 <SE_SFU_IMG_Read+0x48>)
 80088b8:	429a      	cmp	r2, r3
 80088ba:	d811      	bhi.n	80088e0 <SE_SFU_IMG_Read+0x40>

    /* Set the CallGate function pointer */
    SET_CALLGATE();

    /* Enter Secure Mode */
    SE_EnterSecureMode(&primask_bit);
 80088bc:	a803      	add	r0, sp, #12
 80088be:	f000 f98d 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    e_ret_status = (*SE_CallGatePtr)(SE_IMG_READ, pSE_Status, primask_bit, pDestination, pSource, Length);;
 80088c2:	4621      	mov	r1, r4
 80088c4:	e9cd 6700 	strd	r6, r7, [sp]
 80088c8:	4c08      	ldr	r4, [pc, #32]	; (80088ec <SE_SFU_IMG_Read+0x4c>)
 80088ca:	9a03      	ldr	r2, [sp, #12]
 80088cc:	462b      	mov	r3, r5
 80088ce:	2092      	movs	r0, #146	; 0x92
 80088d0:	47a0      	blx	r4
 80088d2:	4604      	mov	r4, r0

    /* Exit Secure Mode */
    SE_ExitSecureMode(primask_bit);
 80088d4:	9803      	ldr	r0, [sp, #12]
 80088d6:	f000 f986 	bl	8008be6 <SE_ExitSecureMode>
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  return e_ret_status;
}
 80088da:	4620      	mov	r0, r4
 80088dc:	b005      	add	sp, #20
 80088de:	bdf0      	pop	{r4, r5, r6, r7, pc}
  __IS_SFU_RESERVED();
 80088e0:	4c03      	ldr	r4, [pc, #12]	; (80088f0 <SE_SFU_IMG_Read+0x50>)
 80088e2:	e7fa      	b.n	80088da <SE_SFU_IMG_Read+0x3a>
 80088e4:	08009600 	.word	0x08009600
 80088e8:	08012fff 	.word	0x08012fff
 80088ec:	08000205 	.word	0x08000205
 80088f0:	00018799 	.word	0x00018799

080088f4 <SE_SFU_IMG_Write>:
  * @param  Length: number of bytes to write to flash
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_SFU_IMG_Write(SE_StatusTypeDef *pSE_Status, uint8_t *pDestination, const uint8_t *pSource,
                                uint32_t Length)
{
 80088f4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80088f6:	4604      	mov	r4, r0
 80088f8:	b085      	sub	sp, #20
 80088fa:	460d      	mov	r5, r1
 80088fc:	4616      	mov	r6, r2
 80088fe:	461f      	mov	r7, r3
 8008900:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 8008902:	4b0d      	ldr	r3, [pc, #52]	; (8008938 <SE_SFU_IMG_Write+0x44>)
 8008904:	429a      	cmp	r2, r3
 8008906:	d315      	bcc.n	8008934 <SE_SFU_IMG_Write+0x40>
 8008908:	4672      	mov	r2, lr
 800890a:	4b0c      	ldr	r3, [pc, #48]	; (800893c <SE_SFU_IMG_Write+0x48>)
 800890c:	429a      	cmp	r2, r3
 800890e:	d811      	bhi.n	8008934 <SE_SFU_IMG_Write+0x40>
#endif /* SFU_ISOLATE_SE_WITH_MPU */

    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 8008910:	a803      	add	r0, sp, #12
 8008912:	f000 f963 	bl	8008bdc <SE_EnterSecureMode>
    e_ret_status = (*SE_CallGatePtr)(SE_IMG_WRITE, pSE_Status, primask_bit, pDestination, pSource, Length);
 8008916:	4621      	mov	r1, r4
 8008918:	e9cd 6700 	strd	r6, r7, [sp]
 800891c:	4c08      	ldr	r4, [pc, #32]	; (8008940 <SE_SFU_IMG_Write+0x4c>)
 800891e:	9a03      	ldr	r2, [sp, #12]
 8008920:	462b      	mov	r3, r5
 8008922:	2093      	movs	r0, #147	; 0x93
 8008924:	47a0      	blx	r4
 8008926:	4604      	mov	r4, r0
    SE_ExitSecureMode(primask_bit);
 8008928:	9803      	ldr	r0, [sp, #12]
 800892a:	f000 f95c 	bl	8008be6 <SE_ExitSecureMode>
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  return e_ret_status;
}
 800892e:	4620      	mov	r0, r4
 8008930:	b005      	add	sp, #20
 8008932:	bdf0      	pop	{r4, r5, r6, r7, pc}
  __IS_SFU_RESERVED();
 8008934:	4c03      	ldr	r4, [pc, #12]	; (8008944 <SE_SFU_IMG_Write+0x50>)
 8008936:	e7fa      	b.n	800892e <SE_SFU_IMG_Write+0x3a>
 8008938:	08009600 	.word	0x08009600
 800893c:	08012fff 	.word	0x08012fff
 8008940:	08000205 	.word	0x08000205
 8008944:	00018799 	.word	0x00018799

08008948 <SE_SFU_IMG_Erase>:
  * @param  pDestination: pointer to flash area to erase.
  * @param  Length: number of bytes to erase in flash
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_SFU_IMG_Erase(SE_StatusTypeDef *pSE_Status, uint8_t *pDestination, uint32_t Length)
{
 8008948:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 800894a:	4604      	mov	r4, r0
 800894c:	460d      	mov	r5, r1
 800894e:	4616      	mov	r6, r2
 8008950:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 8008952:	4b0d      	ldr	r3, [pc, #52]	; (8008988 <SE_SFU_IMG_Erase+0x40>)
 8008954:	429a      	cmp	r2, r3
 8008956:	d314      	bcc.n	8008982 <SE_SFU_IMG_Erase+0x3a>
 8008958:	4672      	mov	r2, lr
 800895a:	4b0c      	ldr	r3, [pc, #48]	; (800898c <SE_SFU_IMG_Erase+0x44>)
 800895c:	429a      	cmp	r2, r3
 800895e:	d810      	bhi.n	8008982 <SE_SFU_IMG_Erase+0x3a>
#endif /* SFU_ISOLATE_SE_WITH_MPU */

    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 8008960:	a803      	add	r0, sp, #12
 8008962:	f000 f93b 	bl	8008bdc <SE_EnterSecureMode>
    e_ret_status = (*SE_CallGatePtr)(SE_IMG_ERASE, pSE_Status, primask_bit, pDestination, Length);
 8008966:	4621      	mov	r1, r4
 8008968:	9a03      	ldr	r2, [sp, #12]
 800896a:	4c09      	ldr	r4, [pc, #36]	; (8008990 <SE_SFU_IMG_Erase+0x48>)
 800896c:	9600      	str	r6, [sp, #0]
 800896e:	462b      	mov	r3, r5
 8008970:	2094      	movs	r0, #148	; 0x94
 8008972:	47a0      	blx	r4
 8008974:	4604      	mov	r4, r0
    SE_ExitSecureMode(primask_bit);
 8008976:	9803      	ldr	r0, [sp, #12]
 8008978:	f000 f935 	bl	8008be6 <SE_ExitSecureMode>
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  return e_ret_status;
}
 800897c:	4620      	mov	r0, r4
 800897e:	b004      	add	sp, #16
 8008980:	bd70      	pop	{r4, r5, r6, pc}
  __IS_SFU_RESERVED();
 8008982:	4c04      	ldr	r4, [pc, #16]	; (8008994 <SE_SFU_IMG_Erase+0x4c>)
 8008984:	e7fa      	b.n	800897c <SE_SFU_IMG_Erase+0x34>
 8008986:	bf00      	nop
 8008988:	08009600 	.word	0x08009600
 800898c:	08012fff 	.word	0x08012fff
 8008990:	08000205 	.word	0x08000205
 8008994:	00018799 	.word	0x00018799

08008998 <SE_Decrypt_Init>:
  * @param SE_FwType Type of Fw Image.
  *        This parameter can be SE_FW_IMAGE_COMPLETE or SE_FW_IMAGE_PARTIAL.
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_Decrypt_Init(SE_StatusTypeDef *peSE_Status, SE_FwRawHeaderTypeDef *pxSE_Metadata, uint32_t SE_FwType)
{
 8008998:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 800899a:	4605      	mov	r5, r0
 800899c:	460e      	mov	r6, r1
 800899e:	4614      	mov	r4, r2
 80089a0:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 80089a2:	4b0e      	ldr	r3, [pc, #56]	; (80089dc <SE_Decrypt_Init+0x44>)
 80089a4:	429a      	cmp	r2, r3
 80089a6:	d316      	bcc.n	80089d6 <SE_Decrypt_Init+0x3e>
 80089a8:	4672      	mov	r2, lr
 80089aa:	4b0d      	ldr	r3, [pc, #52]	; (80089e0 <SE_Decrypt_Init+0x48>)
 80089ac:	429a      	cmp	r2, r3
 80089ae:	d812      	bhi.n	80089d6 <SE_Decrypt_Init+0x3e>

  /* Check the parameter */
  if ((SE_FwType != SE_FW_IMAGE_COMPLETE) && (SE_FwType != SE_FW_IMAGE_PARTIAL))
 80089b0:	2c01      	cmp	r4, #1
 80089b2:	d810      	bhi.n	80089d6 <SE_Decrypt_Init+0x3e>

    /* Set the CallGate function pointer */
    SET_CALLGATE();

    /* Enter Secure Mode */
    SE_EnterSecureMode(&primask_bit);
 80089b4:	a803      	add	r0, sp, #12
 80089b6:	f000 f911 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    e_ret_status = (*SE_CallGatePtr)(SE_CRYPTO_LL_DECRYPT_INIT_ID, peSE_Status, primask_bit, pxSE_Metadata, SE_FwType);
 80089ba:	9400      	str	r4, [sp, #0]
 80089bc:	9a03      	ldr	r2, [sp, #12]
 80089be:	4c09      	ldr	r4, [pc, #36]	; (80089e4 <SE_Decrypt_Init+0x4c>)
 80089c0:	4633      	mov	r3, r6
 80089c2:	4629      	mov	r1, r5
 80089c4:	2004      	movs	r0, #4
 80089c6:	47a0      	blx	r4
 80089c8:	4604      	mov	r4, r0

    /* Exit Secure Mode */
    SE_ExitSecureMode(primask_bit);
 80089ca:	9803      	ldr	r0, [sp, #12]
 80089cc:	f000 f90b 	bl	8008be6 <SE_ExitSecureMode>
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  return e_ret_status;
}
 80089d0:	4620      	mov	r0, r4
 80089d2:	b004      	add	sp, #16
 80089d4:	bd70      	pop	{r4, r5, r6, pc}
  __IS_SFU_RESERVED();
 80089d6:	4c04      	ldr	r4, [pc, #16]	; (80089e8 <SE_Decrypt_Init+0x50>)
 80089d8:	e7fa      	b.n	80089d0 <SE_Decrypt_Init+0x38>
 80089da:	bf00      	nop
 80089dc:	08009600 	.word	0x08009600
 80089e0:	08012fff 	.word	0x08012fff
 80089e4:	08000205 	.word	0x08000205
 80089e8:	00018799 	.word	0x00018799

080089ec <SE_Decrypt_Append>:
  * @param pOutputSize pointer to Output Size (bytes).
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_Decrypt_Append(SE_StatusTypeDef *peSE_Status, const uint8_t *pInputBuffer, int32_t InputSize,
                                 uint8_t *pOutputBuffer, int32_t *pOutputSize)
{
 80089ec:	b5f0      	push	{r4, r5, r6, r7, lr}
 80089ee:	4604      	mov	r4, r0
 80089f0:	b087      	sub	sp, #28
 80089f2:	460d      	mov	r5, r1
 80089f4:	4616      	mov	r6, r2
 80089f6:	461f      	mov	r7, r3
 80089f8:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 80089fa:	4b0e      	ldr	r3, [pc, #56]	; (8008a34 <SE_Decrypt_Append+0x48>)
 80089fc:	429a      	cmp	r2, r3
 80089fe:	d317      	bcc.n	8008a30 <SE_Decrypt_Append+0x44>
 8008a00:	4672      	mov	r2, lr
 8008a02:	4b0d      	ldr	r3, [pc, #52]	; (8008a38 <SE_Decrypt_Append+0x4c>)
 8008a04:	429a      	cmp	r2, r3
 8008a06:	d813      	bhi.n	8008a30 <SE_Decrypt_Append+0x44>

    /* Set the CallGate function pointer */
    SET_CALLGATE();

    /* Enter Secure Mode */
    SE_EnterSecureMode(&primask_bit);
 8008a08:	a805      	add	r0, sp, #20
 8008a0a:	f000 f8e7 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    e_ret_status = (*SE_CallGatePtr)(SE_CRYPTO_LL_DECRYPT_APPEND_ID, peSE_Status, primask_bit, pInputBuffer, InputSize,
 8008a0e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8008a10:	9a05      	ldr	r2, [sp, #20]
 8008a12:	9600      	str	r6, [sp, #0]
 8008a14:	e9cd 7301 	strd	r7, r3, [sp, #4]
 8008a18:	4621      	mov	r1, r4
 8008a1a:	462b      	mov	r3, r5
 8008a1c:	4c07      	ldr	r4, [pc, #28]	; (8008a3c <SE_Decrypt_Append+0x50>)
 8008a1e:	2005      	movs	r0, #5
 8008a20:	47a0      	blx	r4
 8008a22:	4604      	mov	r4, r0
                                     pOutputBuffer, pOutputSize);

    /* Exit Secure Mode */
    SE_ExitSecureMode(primask_bit);
 8008a24:	9805      	ldr	r0, [sp, #20]
 8008a26:	f000 f8de 	bl	8008be6 <SE_ExitSecureMode>
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  return e_ret_status;
}
 8008a2a:	4620      	mov	r0, r4
 8008a2c:	b007      	add	sp, #28
 8008a2e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  __IS_SFU_RESERVED();
 8008a30:	4c03      	ldr	r4, [pc, #12]	; (8008a40 <SE_Decrypt_Append+0x54>)
 8008a32:	e7fa      	b.n	8008a2a <SE_Decrypt_Append+0x3e>
 8008a34:	08009600 	.word	0x08009600
 8008a38:	08012fff 	.word	0x08012fff
 8008a3c:	08000205 	.word	0x08000205
 8008a40:	00018799 	.word	0x00018799

08008a44 <SE_Decrypt_Finish>:
  * @param pOutputBuffer pointer to Output Buffer.
  * @param pOutputSize pointer to Output Size (bytes).
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_Decrypt_Finish(SE_StatusTypeDef *peSE_Status, uint8_t *pOutputBuffer, int32_t *pOutputSize)
{
 8008a44:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 8008a46:	4604      	mov	r4, r0
 8008a48:	460d      	mov	r5, r1
 8008a4a:	4616      	mov	r6, r2
 8008a4c:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 8008a4e:	4b0d      	ldr	r3, [pc, #52]	; (8008a84 <SE_Decrypt_Finish+0x40>)
 8008a50:	429a      	cmp	r2, r3
 8008a52:	d314      	bcc.n	8008a7e <SE_Decrypt_Finish+0x3a>
 8008a54:	4672      	mov	r2, lr
 8008a56:	4b0c      	ldr	r3, [pc, #48]	; (8008a88 <SE_Decrypt_Finish+0x44>)
 8008a58:	429a      	cmp	r2, r3
 8008a5a:	d810      	bhi.n	8008a7e <SE_Decrypt_Finish+0x3a>

    /* Set the CallGate function pointer */
    SET_CALLGATE();

    /* Enter Secure Mode */
    SE_EnterSecureMode(&primask_bit);
 8008a5c:	a803      	add	r0, sp, #12
 8008a5e:	f000 f8bd 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    e_ret_status = (*SE_CallGatePtr)(SE_CRYPTO_LL_DECRYPT_FINISH_ID, peSE_Status, primask_bit, pOutputBuffer,
 8008a62:	4621      	mov	r1, r4
 8008a64:	9a03      	ldr	r2, [sp, #12]
 8008a66:	4c09      	ldr	r4, [pc, #36]	; (8008a8c <SE_Decrypt_Finish+0x48>)
 8008a68:	9600      	str	r6, [sp, #0]
 8008a6a:	462b      	mov	r3, r5
 8008a6c:	2006      	movs	r0, #6
 8008a6e:	47a0      	blx	r4
 8008a70:	4604      	mov	r4, r0
                                     pOutputSize);

    /* Exit Secure Mode */
    SE_ExitSecureMode(primask_bit);
 8008a72:	9803      	ldr	r0, [sp, #12]
 8008a74:	f000 f8b7 	bl	8008be6 <SE_ExitSecureMode>
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  return e_ret_status;
}
 8008a78:	4620      	mov	r0, r4
 8008a7a:	b004      	add	sp, #16
 8008a7c:	bd70      	pop	{r4, r5, r6, pc}
  __IS_SFU_RESERVED();
 8008a7e:	4c04      	ldr	r4, [pc, #16]	; (8008a90 <SE_Decrypt_Finish+0x4c>)
 8008a80:	e7fa      	b.n	8008a78 <SE_Decrypt_Finish+0x34>
 8008a82:	bf00      	nop
 8008a84:	08009600 	.word	0x08009600
 8008a88:	08012fff 	.word	0x08012fff
 8008a8c:	08000205 	.word	0x08000205
 8008a90:	00018799 	.word	0x00018799

08008a94 <SE_AuthenticateFW_Init>:
  *        This parameter can be SE_FW_IMAGE_COMPLETE or SE_FW_IMAGE_PARTIAL.
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_AuthenticateFW_Init(SE_StatusTypeDef *peSE_Status, SE_FwRawHeaderTypeDef *pxSE_Metadata,
                                      uint32_t SE_FwType)
{
 8008a94:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 8008a96:	4605      	mov	r5, r0
 8008a98:	460e      	mov	r6, r1
 8008a9a:	4614      	mov	r4, r2
 8008a9c:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 8008a9e:	4b0e      	ldr	r3, [pc, #56]	; (8008ad8 <SE_AuthenticateFW_Init+0x44>)
 8008aa0:	429a      	cmp	r2, r3
 8008aa2:	d316      	bcc.n	8008ad2 <SE_AuthenticateFW_Init+0x3e>
 8008aa4:	4672      	mov	r2, lr
 8008aa6:	4b0d      	ldr	r3, [pc, #52]	; (8008adc <SE_AuthenticateFW_Init+0x48>)
 8008aa8:	429a      	cmp	r2, r3
 8008aaa:	d812      	bhi.n	8008ad2 <SE_AuthenticateFW_Init+0x3e>

  /* Check the parameter */
  if ((SE_FwType != SE_FW_IMAGE_COMPLETE) && (SE_FwType != SE_FW_IMAGE_PARTIAL))
 8008aac:	2c01      	cmp	r4, #1
 8008aae:	d810      	bhi.n	8008ad2 <SE_AuthenticateFW_Init+0x3e>

    /* Set the CallGate function pointer */
    SET_CALLGATE();

    /* Enter Secure Mode */
    SE_EnterSecureMode(&primask_bit);
 8008ab0:	a803      	add	r0, sp, #12
 8008ab2:	f000 f893 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    e_ret_status = (*SE_CallGatePtr)(SE_CRYPTO_LL_AUTHENTICATE_FW_INIT_ID, peSE_Status, primask_bit, pxSE_Metadata,
 8008ab6:	9400      	str	r4, [sp, #0]
 8008ab8:	9a03      	ldr	r2, [sp, #12]
 8008aba:	4c09      	ldr	r4, [pc, #36]	; (8008ae0 <SE_AuthenticateFW_Init+0x4c>)
 8008abc:	4633      	mov	r3, r6
 8008abe:	4629      	mov	r1, r5
 8008ac0:	2007      	movs	r0, #7
 8008ac2:	47a0      	blx	r4
 8008ac4:	4604      	mov	r4, r0
                                     SE_FwType);

    /* Exit Secure Mode */
    SE_ExitSecureMode(primask_bit);
 8008ac6:	9803      	ldr	r0, [sp, #12]
 8008ac8:	f000 f88d 	bl	8008be6 <SE_ExitSecureMode>
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */

  return e_ret_status;
}
 8008acc:	4620      	mov	r0, r4
 8008ace:	b004      	add	sp, #16
 8008ad0:	bd70      	pop	{r4, r5, r6, pc}
  __IS_SFU_RESERVED();
 8008ad2:	4c04      	ldr	r4, [pc, #16]	; (8008ae4 <SE_AuthenticateFW_Init+0x50>)
 8008ad4:	e7fa      	b.n	8008acc <SE_AuthenticateFW_Init+0x38>
 8008ad6:	bf00      	nop
 8008ad8:	08009600 	.word	0x08009600
 8008adc:	08012fff 	.word	0x08012fff
 8008ae0:	08000205 	.word	0x08000205
 8008ae4:	00018799 	.word	0x00018799

08008ae8 <SE_AuthenticateFW_Append>:
  * @param pOutputSize pointer to Output Size (bytes).
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_AuthenticateFW_Append(SE_StatusTypeDef *peSE_Status, const uint8_t *pInputBuffer, int32_t InputSize,
                                        uint8_t *pOutputBuffer, int32_t *pOutputSize)
{
 8008ae8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008aea:	4604      	mov	r4, r0
 8008aec:	b087      	sub	sp, #28
 8008aee:	460d      	mov	r5, r1
 8008af0:	4616      	mov	r6, r2
 8008af2:	461f      	mov	r7, r3
 8008af4:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 8008af6:	4b0e      	ldr	r3, [pc, #56]	; (8008b30 <SE_AuthenticateFW_Append+0x48>)
 8008af8:	429a      	cmp	r2, r3
 8008afa:	d317      	bcc.n	8008b2c <SE_AuthenticateFW_Append+0x44>
 8008afc:	4672      	mov	r2, lr
 8008afe:	4b0d      	ldr	r3, [pc, #52]	; (8008b34 <SE_AuthenticateFW_Append+0x4c>)
 8008b00:	429a      	cmp	r2, r3
 8008b02:	d813      	bhi.n	8008b2c <SE_AuthenticateFW_Append+0x44>

    /* Set the CallGate function pointer */
    SET_CALLGATE();

    /* Enter Secure Mode */
    SE_EnterSecureMode(&primask_bit);
 8008b04:	a805      	add	r0, sp, #20
 8008b06:	f000 f869 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    e_ret_status = (*SE_CallGatePtr)(SE_CRYPTO_LL_AUTHENTICATE_FW_APPEND_ID, peSE_Status, primask_bit, pInputBuffer,
 8008b0a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8008b0c:	9a05      	ldr	r2, [sp, #20]
 8008b0e:	9600      	str	r6, [sp, #0]
 8008b10:	e9cd 7301 	strd	r7, r3, [sp, #4]
 8008b14:	4621      	mov	r1, r4
 8008b16:	462b      	mov	r3, r5
 8008b18:	4c07      	ldr	r4, [pc, #28]	; (8008b38 <SE_AuthenticateFW_Append+0x50>)
 8008b1a:	2008      	movs	r0, #8
 8008b1c:	47a0      	blx	r4
 8008b1e:	4604      	mov	r4, r0
                                     InputSize, pOutputBuffer, pOutputSize);

    /* Exit Secure Mode */
    SE_ExitSecureMode(primask_bit);
 8008b20:	9805      	ldr	r0, [sp, #20]
 8008b22:	f000 f860 	bl	8008be6 <SE_ExitSecureMode>
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */

  return e_ret_status;
}
 8008b26:	4620      	mov	r0, r4
 8008b28:	b007      	add	sp, #28
 8008b2a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  __IS_SFU_RESERVED();
 8008b2c:	4c03      	ldr	r4, [pc, #12]	; (8008b3c <SE_AuthenticateFW_Append+0x54>)
 8008b2e:	e7fa      	b.n	8008b26 <SE_AuthenticateFW_Append+0x3e>
 8008b30:	08009600 	.word	0x08009600
 8008b34:	08012fff 	.word	0x08012fff
 8008b38:	08000205 	.word	0x08000205
 8008b3c:	00018799 	.word	0x00018799

08008b40 <SE_AuthenticateFW_Finish>:
  * @param pOutputBuffer pointer to Output Buffer.
  * @param pOutputSize pointer to Output Size (bytes).
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_AuthenticateFW_Finish(SE_StatusTypeDef *peSE_Status, uint8_t *pOutputBuffer, int32_t *pOutputSize)
{
 8008b40:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 8008b42:	4604      	mov	r4, r0
 8008b44:	460d      	mov	r5, r1
 8008b46:	4616      	mov	r6, r2
 8008b48:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 8008b4a:	4b0d      	ldr	r3, [pc, #52]	; (8008b80 <SE_AuthenticateFW_Finish+0x40>)
 8008b4c:	429a      	cmp	r2, r3
 8008b4e:	d314      	bcc.n	8008b7a <SE_AuthenticateFW_Finish+0x3a>
 8008b50:	4672      	mov	r2, lr
 8008b52:	4b0c      	ldr	r3, [pc, #48]	; (8008b84 <SE_AuthenticateFW_Finish+0x44>)
 8008b54:	429a      	cmp	r2, r3
 8008b56:	d810      	bhi.n	8008b7a <SE_AuthenticateFW_Finish+0x3a>

    /* Set the CallGate function pointer */
    SET_CALLGATE();

    /* Enter Secure Mode */
    SE_EnterSecureMode(&primask_bit);
 8008b58:	a803      	add	r0, sp, #12
 8008b5a:	f000 f83f 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    e_ret_status = (*SE_CallGatePtr)(SE_CRYPTO_LL_AUTHENTICATE_FW_FINISH_ID, peSE_Status, primask_bit, pOutputBuffer,
 8008b5e:	4621      	mov	r1, r4
 8008b60:	9a03      	ldr	r2, [sp, #12]
 8008b62:	4c09      	ldr	r4, [pc, #36]	; (8008b88 <SE_AuthenticateFW_Finish+0x48>)
 8008b64:	9600      	str	r6, [sp, #0]
 8008b66:	462b      	mov	r3, r5
 8008b68:	2009      	movs	r0, #9
 8008b6a:	47a0      	blx	r4
 8008b6c:	4604      	mov	r4, r0
                                     pOutputSize);

    /* Exit Secure Mode */
    SE_ExitSecureMode(primask_bit);
 8008b6e:	9803      	ldr	r0, [sp, #12]
 8008b70:	f000 f839 	bl	8008be6 <SE_ExitSecureMode>
#ifdef SFU_ISOLATE_SE_WITH_MPU
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */

  return e_ret_status;
}
 8008b74:	4620      	mov	r0, r4
 8008b76:	b004      	add	sp, #16
 8008b78:	bd70      	pop	{r4, r5, r6, pc}
  __IS_SFU_RESERVED();
 8008b7a:	4c04      	ldr	r4, [pc, #16]	; (8008b8c <SE_AuthenticateFW_Finish+0x4c>)
 8008b7c:	e7fa      	b.n	8008b74 <SE_AuthenticateFW_Finish+0x34>
 8008b7e:	bf00      	nop
 8008b80:	08009600 	.word	0x08009600
 8008b84:	08012fff 	.word	0x08012fff
 8008b88:	08000205 	.word	0x08000205
 8008b8c:	00018799 	.word	0x00018799

08008b90 <SE_VerifyHeaderSignature>:
  *        This parameter can be a value of @ref SE_Status_Structure_definition.
  * @param pxFwRawHeader pointer to RawHeader Buffer.
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SE_VerifyHeaderSignature(SE_StatusTypeDef *peSE_Status, SE_FwRawHeaderTypeDef *pxFwRawHeader)
{
 8008b90:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8008b92:	4604      	mov	r4, r0
 8008b94:	460d      	mov	r5, r1
 8008b96:	4672      	mov	r2, lr
  SE_ErrorStatus e_ret_status;
  uint32_t primask_bit; /*!< interruption mask saved when disabling ITs then restore when re-enabling ITs */

  /* Check if the call is coming from SFU code */
  __IS_SFU_RESERVED();
 8008b98:	4b0c      	ldr	r3, [pc, #48]	; (8008bcc <SE_VerifyHeaderSignature+0x3c>)
 8008b9a:	429a      	cmp	r2, r3
 8008b9c:	d313      	bcc.n	8008bc6 <SE_VerifyHeaderSignature+0x36>
 8008b9e:	4672      	mov	r2, lr
 8008ba0:	4b0b      	ldr	r3, [pc, #44]	; (8008bd0 <SE_VerifyHeaderSignature+0x40>)
 8008ba2:	429a      	cmp	r2, r3
 8008ba4:	d80f      	bhi.n	8008bc6 <SE_VerifyHeaderSignature+0x36>

    /* Set the CallGate function pointer */
    SET_CALLGATE();

    /* Enter Secure Mode */
    SE_EnterSecureMode(&primask_bit);
 8008ba6:	a801      	add	r0, sp, #4
 8008ba8:	f000 f818 	bl	8008bdc <SE_EnterSecureMode>

    e_ret_status = (*SE_CallGatePtr)(SE_CRYPTO_HL_AUTHENTICATE_METADATA, peSE_Status, primask_bit, pxFwRawHeader);
 8008bac:	4621      	mov	r1, r4
 8008bae:	9a01      	ldr	r2, [sp, #4]
 8008bb0:	4c08      	ldr	r4, [pc, #32]	; (8008bd4 <SE_VerifyHeaderSignature+0x44>)
 8008bb2:	462b      	mov	r3, r5
 8008bb4:	2010      	movs	r0, #16
 8008bb6:	47a0      	blx	r4
 8008bb8:	4604      	mov	r4, r0

    /* Exit Secure Mode */
    SE_ExitSecureMode(primask_bit);
 8008bba:	9801      	ldr	r0, [sp, #4]
 8008bbc:	f000 f813 	bl	8008be6 <SE_ExitSecureMode>
  }
#endif /* SFU_ISOLATE_SE_WITH_MPU */

  return e_ret_status;

}
 8008bc0:	4620      	mov	r0, r4
 8008bc2:	b003      	add	sp, #12
 8008bc4:	bd30      	pop	{r4, r5, pc}
  __IS_SFU_RESERVED();
 8008bc6:	4c04      	ldr	r4, [pc, #16]	; (8008bd8 <SE_VerifyHeaderSignature+0x48>)
 8008bc8:	e7fa      	b.n	8008bc0 <SE_VerifyHeaderSignature+0x30>
 8008bca:	bf00      	nop
 8008bcc:	08009600 	.word	0x08009600
 8008bd0:	08012fff 	.word	0x08012fff
 8008bd4:	08000205 	.word	0x08000205
 8008bd8:	00018799 	.word	0x00018799

08008bdc <SE_EnterSecureMode>:
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8008bdc:	f3ef 8310 	mrs	r3, PRIMASK
  */
void SE_EnterSecureMode(uint32_t *pPrimaskBit)
{
#if !defined(CKS_ENABLED)
  /* Disable interrupts */
  *pPrimaskBit = __get_PRIMASK();
 8008be0:	6003      	str	r3, [r0, #0]
  __ASM volatile ("cpsid i" : : : "memory");
 8008be2:	b672      	cpsid	i
  __disable_irq();
#endif /* !CKS_ENABLED */
}
 8008be4:	4770      	bx	lr

08008be6 <SE_ExitSecureMode>:
  \details Assigns the given value to the Priority Mask Register.
  \param [in]    priMask  Priority Mask
 */
__STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8008be6:	f380 8810 	msr	PRIMASK, r0
  __ASM volatile ("cpsie i" : : : "memory");
 8008bea:	b662      	cpsie	i
#if !defined(CKS_ENABLED)
  /* Re-enable the interrupts */
  __set_PRIMASK(PrimaskBit);
  __enable_irq();
#endif /* !CKS_ENABLED */
}
 8008bec:	4770      	bx	lr
	...

08008bf0 <SE_KMS_Initialize>:
  *         for more details on the APIs, parameters and possible returned values
  * @param  pInitArgs
  * @retval Operation status
  */
__root CK_RV SE_KMS_Initialize(CK_VOID_PTR pInitArgs)
{
 8008bf0:	b513      	push	{r0, r1, r4, lr}
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8008bf2:	2305      	movs	r3, #5
{
 8008bf4:	4604      	mov	r4, r0
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 8008bf6:	a801      	add	r0, sp, #4
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8008bf8:	9300      	str	r3, [sp, #0]
    SE_EnterSecureMode(&primask_bit);
 8008bfa:	f7ff ffef 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_INITIALIZE_FCT_ID),
 8008bfe:	4623      	mov	r3, r4
 8008c00:	9a01      	ldr	r2, [sp, #4]
 8008c02:	4c05      	ldr	r4, [pc, #20]	; (8008c18 <SE_KMS_Initialize+0x28>)
 8008c04:	4805      	ldr	r0, [pc, #20]	; (8008c1c <SE_KMS_Initialize+0x2c>)
 8008c06:	4669      	mov	r1, sp
 8008c08:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit, pInitArgs);

    SE_ExitSecureMode(primask_bit);
 8008c0a:	9801      	ldr	r0, [sp, #4]
 8008c0c:	f7ff ffeb 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 8008c10:	9800      	ldr	r0, [sp, #0]
 8008c12:	b002      	add	sp, #8
 8008c14:	bd10      	pop	{r4, pc}
 8008c16:	bf00      	nop
 8008c18:	08000205 	.word	0x08000205
 8008c1c:	10000001 	.word	0x10000001

08008c20 <SE_KMS_Finalize>:
  *         for more details on the APIs, parameters and possible returned values
  * @param  pReserved
  * @retval Operation status
  */
__root CK_RV SE_KMS_Finalize(CK_VOID_PTR pReserved)
{
 8008c20:	b513      	push	{r0, r1, r4, lr}
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8008c22:	2305      	movs	r3, #5
{
 8008c24:	4604      	mov	r4, r0
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 8008c26:	a801      	add	r0, sp, #4
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8008c28:	9300      	str	r3, [sp, #0]
    SE_EnterSecureMode(&primask_bit);
 8008c2a:	f7ff ffd7 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_FINALIZE_FCT_ID),
 8008c2e:	4623      	mov	r3, r4
 8008c30:	9a01      	ldr	r2, [sp, #4]
 8008c32:	4c05      	ldr	r4, [pc, #20]	; (8008c48 <SE_KMS_Finalize+0x28>)
 8008c34:	4805      	ldr	r0, [pc, #20]	; (8008c4c <SE_KMS_Finalize+0x2c>)
 8008c36:	4669      	mov	r1, sp
 8008c38:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit, pReserved);

    SE_ExitSecureMode(primask_bit);
 8008c3a:	9801      	ldr	r0, [sp, #4]
 8008c3c:	f7ff ffd3 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 8008c40:	9800      	ldr	r0, [sp, #0]
 8008c42:	b002      	add	sp, #8
 8008c44:	bd10      	pop	{r4, pc}
 8008c46:	bf00      	nop
 8008c48:	08000205 	.word	0x08000205
 8008c4c:	10000002 	.word	0x10000002

08008c50 <SE_KMS_GetInfo>:
  *         for more details on the APIs, parameters and possible returned values
  * @param  pInfo
  * @retval Operation status
  */
__root CK_RV SE_KMS_GetInfo(CK_INFO_PTR   pInfo)
{
 8008c50:	b513      	push	{r0, r1, r4, lr}
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8008c52:	2305      	movs	r3, #5
{
 8008c54:	4604      	mov	r4, r0
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 8008c56:	a801      	add	r0, sp, #4
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8008c58:	9300      	str	r3, [sp, #0]
    SE_EnterSecureMode(&primask_bit);
 8008c5a:	f7ff ffbf 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_GET_INFO_FCT_ID),
 8008c5e:	4623      	mov	r3, r4
 8008c60:	9a01      	ldr	r2, [sp, #4]
 8008c62:	4c05      	ldr	r4, [pc, #20]	; (8008c78 <SE_KMS_GetInfo+0x28>)
 8008c64:	4805      	ldr	r0, [pc, #20]	; (8008c7c <SE_KMS_GetInfo+0x2c>)
 8008c66:	4669      	mov	r1, sp
 8008c68:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit, pInfo);

    SE_ExitSecureMode(primask_bit);
 8008c6a:	9801      	ldr	r0, [sp, #4]
 8008c6c:	f7ff ffbb 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 8008c70:	9800      	ldr	r0, [sp, #0]
 8008c72:	b002      	add	sp, #8
 8008c74:	bd10      	pop	{r4, pc}
 8008c76:	bf00      	nop
 8008c78:	08000205 	.word	0x08000205
 8008c7c:	10000003 	.word	0x10000003

08008c80 <SE_KMS_GetFunctionList>:

  return ck_rv_ret_status;
#else /* KMS_PKCS11_GET_FUNCTION_LIST_SUPPORT */
  return CKR_FUNCTION_NOT_SUPPORTED;
#endif /* KMS_PKCS11_GET_FUNCTION_LIST_SUPPORT */
}
 8008c80:	2054      	movs	r0, #84	; 0x54
 8008c82:	4770      	bx	lr

08008c84 <SE_KMS_GetSlotList>:
  * @param  pulCount
  * @retval Operation status
  */
__root CK_RV SE_KMS_GetSlotList(CK_BBOOL tokenPresent, CK_SLOT_ID_PTR pSlotList,
                                CK_ULONG_PTR pulCount)
{
 8008c84:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 8008c86:	460d      	mov	r5, r1
 8008c88:	4616      	mov	r6, r2
 8008c8a:	4604      	mov	r4, r0
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8008c8c:	2305      	movs	r3, #5
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 8008c8e:	a803      	add	r0, sp, #12
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8008c90:	9302      	str	r3, [sp, #8]
    SE_EnterSecureMode(&primask_bit);
 8008c92:	f7ff ffa3 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_GET_SLOT_LIST_FCT_ID),
 8008c96:	4623      	mov	r3, r4
 8008c98:	9a03      	ldr	r2, [sp, #12]
 8008c9a:	4c06      	ldr	r4, [pc, #24]	; (8008cb4 <SE_KMS_GetSlotList+0x30>)
 8008c9c:	4806      	ldr	r0, [pc, #24]	; (8008cb8 <SE_KMS_GetSlotList+0x34>)
 8008c9e:	a902      	add	r1, sp, #8
 8008ca0:	e9cd 5600 	strd	r5, r6, [sp]
 8008ca4:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit, tokenPresent, pSlotList, pulCount);

    SE_ExitSecureMode(primask_bit);
 8008ca6:	9803      	ldr	r0, [sp, #12]
 8008ca8:	f7ff ff9d 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 8008cac:	9802      	ldr	r0, [sp, #8]
 8008cae:	b004      	add	sp, #16
 8008cb0:	bd70      	pop	{r4, r5, r6, pc}
 8008cb2:	bf00      	nop
 8008cb4:	08000205 	.word	0x08000205
 8008cb8:	10000004 	.word	0x10000004

08008cbc <SE_KMS_GetSlotInfo>:
  * @param  slotID
  * @param  pInfo
  * @retval Operation status
  */
__root CK_RV SE_KMS_GetSlotInfo(CK_SLOT_ID slotID, CK_SLOT_INFO_PTR pInfo)
{
 8008cbc:	b530      	push	{r4, r5, lr}
 8008cbe:	b085      	sub	sp, #20
 8008cc0:	460d      	mov	r5, r1
 8008cc2:	4604      	mov	r4, r0
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8008cc4:	2305      	movs	r3, #5
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 8008cc6:	a803      	add	r0, sp, #12
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8008cc8:	9302      	str	r3, [sp, #8]
    SE_EnterSecureMode(&primask_bit);
 8008cca:	f7ff ff87 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_GET_SLOT_INFO_FCT_ID),
 8008cce:	4623      	mov	r3, r4
 8008cd0:	9a03      	ldr	r2, [sp, #12]
 8008cd2:	4c05      	ldr	r4, [pc, #20]	; (8008ce8 <SE_KMS_GetSlotInfo+0x2c>)
 8008cd4:	9500      	str	r5, [sp, #0]
 8008cd6:	a902      	add	r1, sp, #8
 8008cd8:	4804      	ldr	r0, [pc, #16]	; (8008cec <SE_KMS_GetSlotInfo+0x30>)
 8008cda:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit,
                      slotID,
                      pInfo);

    SE_ExitSecureMode(primask_bit);
 8008cdc:	9803      	ldr	r0, [sp, #12]
 8008cde:	f7ff ff82 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 8008ce2:	9802      	ldr	r0, [sp, #8]
 8008ce4:	b005      	add	sp, #20
 8008ce6:	bd30      	pop	{r4, r5, pc}
 8008ce8:	08000205 	.word	0x08000205
 8008cec:	10000005 	.word	0x10000005

08008cf0 <SE_KMS_GetTokenInfo>:
  * @param  slotID
  * @param  pInfo
  * @retval Operation status
  */
__root CK_RV SE_KMS_GetTokenInfo(CK_SLOT_ID slotID, CK_TOKEN_INFO_PTR pInfo)
{
 8008cf0:	b530      	push	{r4, r5, lr}
 8008cf2:	b085      	sub	sp, #20
 8008cf4:	460d      	mov	r5, r1
 8008cf6:	4604      	mov	r4, r0
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8008cf8:	2305      	movs	r3, #5
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 8008cfa:	a803      	add	r0, sp, #12
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8008cfc:	9302      	str	r3, [sp, #8]
    SE_EnterSecureMode(&primask_bit);
 8008cfe:	f7ff ff6d 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_GET_TOKEN_INFO_FCT_ID),
 8008d02:	4623      	mov	r3, r4
 8008d04:	9a03      	ldr	r2, [sp, #12]
 8008d06:	4c05      	ldr	r4, [pc, #20]	; (8008d1c <SE_KMS_GetTokenInfo+0x2c>)
 8008d08:	9500      	str	r5, [sp, #0]
 8008d0a:	a902      	add	r1, sp, #8
 8008d0c:	4804      	ldr	r0, [pc, #16]	; (8008d20 <SE_KMS_GetTokenInfo+0x30>)
 8008d0e:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit, slotID,
                      pInfo);

    SE_ExitSecureMode(primask_bit);
 8008d10:	9803      	ldr	r0, [sp, #12]
 8008d12:	f7ff ff68 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 8008d16:	9802      	ldr	r0, [sp, #8]
 8008d18:	b005      	add	sp, #20
 8008d1a:	bd30      	pop	{r4, r5, pc}
 8008d1c:	08000205 	.word	0x08000205
 8008d20:	10000006 	.word	0x10000006

08008d24 <SE_KMS_GetMechanismInfo>:
  * @param  type
  * @param  pInfo
  * @retval Operation status
  */
__root CK_RV SE_KMS_GetMechanismInfo(CK_SLOT_ID slotID, CK_MECHANISM_TYPE type, CK_MECHANISM_INFO_PTR pInfo)
{
 8008d24:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 8008d26:	460d      	mov	r5, r1
 8008d28:	4616      	mov	r6, r2
 8008d2a:	4604      	mov	r4, r0
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8008d2c:	2305      	movs	r3, #5
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 8008d2e:	a803      	add	r0, sp, #12
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8008d30:	9302      	str	r3, [sp, #8]
    SE_EnterSecureMode(&primask_bit);
 8008d32:	f7ff ff53 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_GET_MECHANISM_INFO_FCT_ID),
 8008d36:	4623      	mov	r3, r4
 8008d38:	9a03      	ldr	r2, [sp, #12]
 8008d3a:	4c06      	ldr	r4, [pc, #24]	; (8008d54 <SE_KMS_GetMechanismInfo+0x30>)
 8008d3c:	4806      	ldr	r0, [pc, #24]	; (8008d58 <SE_KMS_GetMechanismInfo+0x34>)
 8008d3e:	a902      	add	r1, sp, #8
 8008d40:	e9cd 5600 	strd	r5, r6, [sp]
 8008d44:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit, slotID, type, pInfo);

    SE_ExitSecureMode(primask_bit);
 8008d46:	9803      	ldr	r0, [sp, #12]
 8008d48:	f7ff ff4d 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 8008d4c:	9802      	ldr	r0, [sp, #8]
 8008d4e:	b004      	add	sp, #16
 8008d50:	bd70      	pop	{r4, r5, r6, pc}
 8008d52:	bf00      	nop
 8008d54:	08000205 	.word	0x08000205
 8008d58:	10000008 	.word	0x10000008

08008d5c <SE_KMS_OpenSession>:
  * @retval Operation status
  */
__root CK_RV SE_KMS_OpenSession(CK_SLOT_ID slotID, CK_FLAGS flags,
                                CK_VOID_PTR pApplication, CK_NOTIFY Notify,
                                CK_SESSION_HANDLE_PTR phSession)
{
 8008d5c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008d5e:	b087      	sub	sp, #28
 8008d60:	4604      	mov	r4, r0
 8008d62:	461f      	mov	r7, r3
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 8008d64:	a805      	add	r0, sp, #20
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8008d66:	2305      	movs	r3, #5
{
 8008d68:	460d      	mov	r5, r1
 8008d6a:	4616      	mov	r6, r2
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8008d6c:	9304      	str	r3, [sp, #16]
    SE_EnterSecureMode(&primask_bit);
 8008d6e:	f7ff ff35 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_OPEN_SESSION_FCT_ID),
 8008d72:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8008d74:	9a05      	ldr	r2, [sp, #20]
 8008d76:	4807      	ldr	r0, [pc, #28]	; (8008d94 <SE_KMS_OpenSession+0x38>)
 8008d78:	e9cd 7302 	strd	r7, r3, [sp, #8]
 8008d7c:	a904      	add	r1, sp, #16
 8008d7e:	4623      	mov	r3, r4
 8008d80:	e9cd 5600 	strd	r5, r6, [sp]
 8008d84:	4c04      	ldr	r4, [pc, #16]	; (8008d98 <SE_KMS_OpenSession+0x3c>)
 8008d86:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit,
                      slotID, flags, pApplication, Notify, phSession);

    SE_ExitSecureMode(primask_bit);
 8008d88:	9805      	ldr	r0, [sp, #20]
 8008d8a:	f7ff ff2c 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 8008d8e:	9804      	ldr	r0, [sp, #16]
 8008d90:	b007      	add	sp, #28
 8008d92:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008d94:	1000000c 	.word	0x1000000c
 8008d98:	08000205 	.word	0x08000205

08008d9c <SE_KMS_CloseSession>:
  *         for more details on the APIs, parameters and possible returned values
  * @param  hSession
  * @retval Operation status
  */
__root CK_RV SE_KMS_CloseSession(CK_SESSION_HANDLE hSession)
{
 8008d9c:	b513      	push	{r0, r1, r4, lr}
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8008d9e:	2305      	movs	r3, #5
{
 8008da0:	4604      	mov	r4, r0
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 8008da2:	a801      	add	r0, sp, #4
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8008da4:	9300      	str	r3, [sp, #0]
    SE_EnterSecureMode(&primask_bit);
 8008da6:	f7ff ff19 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_CLOSE_SESSION_FCT_ID),
 8008daa:	4623      	mov	r3, r4
 8008dac:	9a01      	ldr	r2, [sp, #4]
 8008dae:	4c05      	ldr	r4, [pc, #20]	; (8008dc4 <SE_KMS_CloseSession+0x28>)
 8008db0:	4805      	ldr	r0, [pc, #20]	; (8008dc8 <SE_KMS_CloseSession+0x2c>)
 8008db2:	4669      	mov	r1, sp
 8008db4:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit, hSession);

    SE_ExitSecureMode(primask_bit);
 8008db6:	9801      	ldr	r0, [sp, #4]
 8008db8:	f7ff ff15 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 8008dbc:	9800      	ldr	r0, [sp, #0]
 8008dbe:	b002      	add	sp, #8
 8008dc0:	bd10      	pop	{r4, pc}
 8008dc2:	bf00      	nop
 8008dc4:	08000205 	.word	0x08000205
 8008dc8:	1000000d 	.word	0x1000000d

08008dcc <SE_KMS_CreateObject>:
  * @param  phObject
  * @retval Operation status
  */
__root CK_RV SE_KMS_CreateObject(CK_SESSION_HANDLE hSession, CK_ATTRIBUTE_PTR pTemplate,
                                 CK_ULONG ulCount, CK_OBJECT_HANDLE_PTR phObject)
{
 8008dcc:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008dce:	b087      	sub	sp, #28
 8008dd0:	460d      	mov	r5, r1
 8008dd2:	4616      	mov	r6, r2
 8008dd4:	4604      	mov	r4, r0
 8008dd6:	461f      	mov	r7, r3
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 8008dd8:	a805      	add	r0, sp, #20
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8008dda:	2305      	movs	r3, #5
 8008ddc:	9304      	str	r3, [sp, #16]
    SE_EnterSecureMode(&primask_bit);
 8008dde:	f7ff fefd 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_CREATE_OBJECT_FCT_ID),
 8008de2:	4623      	mov	r3, r4
 8008de4:	9a05      	ldr	r2, [sp, #20]
 8008de6:	4c06      	ldr	r4, [pc, #24]	; (8008e00 <SE_KMS_CreateObject+0x34>)
 8008de8:	9500      	str	r5, [sp, #0]
 8008dea:	a904      	add	r1, sp, #16
 8008dec:	e9cd 6701 	strd	r6, r7, [sp, #4]
 8008df0:	4804      	ldr	r0, [pc, #16]	; (8008e04 <SE_KMS_CreateObject+0x38>)
 8008df2:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit,
                      hSession, pTemplate, ulCount, phObject);

    SE_ExitSecureMode(primask_bit);
 8008df4:	9805      	ldr	r0, [sp, #20]
 8008df6:	f7ff fef6 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 8008dfa:	9804      	ldr	r0, [sp, #16]
 8008dfc:	b007      	add	sp, #28
 8008dfe:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008e00:	08000205 	.word	0x08000205
 8008e04:	10000014 	.word	0x10000014

08008e08 <SE_KMS_DestroyObject>:
  * @param  hObject
  * @retval Operation status
  */
__root CK_RV SE_KMS_DestroyObject(CK_SESSION_HANDLE hSession,
                                  CK_OBJECT_HANDLE hObject)
{
 8008e08:	b530      	push	{r4, r5, lr}
 8008e0a:	b085      	sub	sp, #20
 8008e0c:	460d      	mov	r5, r1
 8008e0e:	4604      	mov	r4, r0
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8008e10:	2305      	movs	r3, #5
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 8008e12:	a803      	add	r0, sp, #12
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8008e14:	9302      	str	r3, [sp, #8]
    SE_EnterSecureMode(&primask_bit);
 8008e16:	f7ff fee1 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_DESTROY_OBJECT_FCT_ID),
 8008e1a:	4623      	mov	r3, r4
 8008e1c:	9a03      	ldr	r2, [sp, #12]
 8008e1e:	4c05      	ldr	r4, [pc, #20]	; (8008e34 <SE_KMS_DestroyObject+0x2c>)
 8008e20:	9500      	str	r5, [sp, #0]
 8008e22:	a902      	add	r1, sp, #8
 8008e24:	4804      	ldr	r0, [pc, #16]	; (8008e38 <SE_KMS_DestroyObject+0x30>)
 8008e26:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit,
                      hSession, hObject);

    SE_ExitSecureMode(primask_bit);
 8008e28:	9803      	ldr	r0, [sp, #12]
 8008e2a:	f7ff fedc 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 8008e2e:	9802      	ldr	r0, [sp, #8]
 8008e30:	b005      	add	sp, #20
 8008e32:	bd30      	pop	{r4, r5, pc}
 8008e34:	08000205 	.word	0x08000205
 8008e38:	10000016 	.word	0x10000016

08008e3c <SE_KMS_GetAttributeValue>:
  * @param  ulCount
  * @retval Operation status
  */
__root CK_RV SE_KMS_GetAttributeValue(CK_SESSION_HANDLE hSession, CK_OBJECT_HANDLE hObject,
                                      CK_ATTRIBUTE_PTR pTemplate, CK_ULONG ulCount)
{
 8008e3c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008e3e:	b087      	sub	sp, #28
 8008e40:	460d      	mov	r5, r1
 8008e42:	4616      	mov	r6, r2
 8008e44:	4604      	mov	r4, r0
 8008e46:	461f      	mov	r7, r3
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 8008e48:	a805      	add	r0, sp, #20
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8008e4a:	2305      	movs	r3, #5
 8008e4c:	9304      	str	r3, [sp, #16]
    SE_EnterSecureMode(&primask_bit);
 8008e4e:	f7ff fec5 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_GET_ATTRIBUTE_VALUE_FCT_ID),
 8008e52:	4623      	mov	r3, r4
 8008e54:	9a05      	ldr	r2, [sp, #20]
 8008e56:	4c06      	ldr	r4, [pc, #24]	; (8008e70 <SE_KMS_GetAttributeValue+0x34>)
 8008e58:	9500      	str	r5, [sp, #0]
 8008e5a:	a904      	add	r1, sp, #16
 8008e5c:	e9cd 6701 	strd	r6, r7, [sp, #4]
 8008e60:	4804      	ldr	r0, [pc, #16]	; (8008e74 <SE_KMS_GetAttributeValue+0x38>)
 8008e62:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit,
                      hSession, hObject, pTemplate, ulCount);

    SE_ExitSecureMode(primask_bit);
 8008e64:	9805      	ldr	r0, [sp, #20]
 8008e66:	f7ff febe 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 8008e6a:	9804      	ldr	r0, [sp, #16]
 8008e6c:	b007      	add	sp, #28
 8008e6e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008e70:	08000205 	.word	0x08000205
 8008e74:	10000018 	.word	0x10000018

08008e78 <SE_KMS_SetAttributeValue>:
  * @param  ulCount
  * @retval Operation status
  */
__root CK_RV SE_KMS_SetAttributeValue(CK_SESSION_HANDLE hSession, CK_OBJECT_HANDLE hObject,
                                      CK_ATTRIBUTE_PTR pTemplate, CK_ULONG ulCount)
{
 8008e78:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008e7a:	b087      	sub	sp, #28
 8008e7c:	460d      	mov	r5, r1
 8008e7e:	4616      	mov	r6, r2
 8008e80:	4604      	mov	r4, r0
 8008e82:	461f      	mov	r7, r3
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 8008e84:	a805      	add	r0, sp, #20
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8008e86:	2305      	movs	r3, #5
 8008e88:	9304      	str	r3, [sp, #16]
    SE_EnterSecureMode(&primask_bit);
 8008e8a:	f7ff fea7 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_SET_ATTRIBUTE_VALUE_FCT_ID),
 8008e8e:	4623      	mov	r3, r4
 8008e90:	9a05      	ldr	r2, [sp, #20]
 8008e92:	4c06      	ldr	r4, [pc, #24]	; (8008eac <SE_KMS_SetAttributeValue+0x34>)
 8008e94:	9500      	str	r5, [sp, #0]
 8008e96:	a904      	add	r1, sp, #16
 8008e98:	e9cd 6701 	strd	r6, r7, [sp, #4]
 8008e9c:	4804      	ldr	r0, [pc, #16]	; (8008eb0 <SE_KMS_SetAttributeValue+0x38>)
 8008e9e:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit,
                      hSession, hObject, pTemplate, ulCount);

    SE_ExitSecureMode(primask_bit);
 8008ea0:	9805      	ldr	r0, [sp, #20]
 8008ea2:	f7ff fea0 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 8008ea6:	9804      	ldr	r0, [sp, #16]
 8008ea8:	b007      	add	sp, #28
 8008eaa:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008eac:	08000205 	.word	0x08000205
 8008eb0:	10000019 	.word	0x10000019

08008eb4 <SE_KMS_FindObjectsInit>:
  * @param  ulCount
  * @retval Operation status
  */
__root CK_RV SE_KMS_FindObjectsInit(CK_SESSION_HANDLE hSession, CK_ATTRIBUTE_PTR pTemplate,
                                    CK_ULONG ulCount)
{
 8008eb4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 8008eb6:	460d      	mov	r5, r1
 8008eb8:	4616      	mov	r6, r2
 8008eba:	4604      	mov	r4, r0
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8008ebc:	2305      	movs	r3, #5
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 8008ebe:	a803      	add	r0, sp, #12
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8008ec0:	9302      	str	r3, [sp, #8]
    SE_EnterSecureMode(&primask_bit);
 8008ec2:	f7ff fe8b 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_FIND_OBJECTS_INIT_FCT_ID),
 8008ec6:	4623      	mov	r3, r4
 8008ec8:	9a03      	ldr	r2, [sp, #12]
 8008eca:	4c06      	ldr	r4, [pc, #24]	; (8008ee4 <SE_KMS_FindObjectsInit+0x30>)
 8008ecc:	4806      	ldr	r0, [pc, #24]	; (8008ee8 <SE_KMS_FindObjectsInit+0x34>)
 8008ece:	a902      	add	r1, sp, #8
 8008ed0:	e9cd 5600 	strd	r5, r6, [sp]
 8008ed4:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit,
                      hSession, pTemplate, ulCount);

    SE_ExitSecureMode(primask_bit);
 8008ed6:	9803      	ldr	r0, [sp, #12]
 8008ed8:	f7ff fe85 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 8008edc:	9802      	ldr	r0, [sp, #8]
 8008ede:	b004      	add	sp, #16
 8008ee0:	bd70      	pop	{r4, r5, r6, pc}
 8008ee2:	bf00      	nop
 8008ee4:	08000205 	.word	0x08000205
 8008ee8:	1000001a 	.word	0x1000001a

08008eec <SE_KMS_FindObjects>:
  * @param  pulObjectCount
  * @retval Operation status
  */
__root CK_RV SE_KMS_FindObjects(CK_SESSION_HANDLE hSession, CK_OBJECT_HANDLE_PTR phObject,
                                CK_ULONG ulMaxObjectCount,  CK_ULONG_PTR pulObjectCount)
{
 8008eec:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008eee:	b087      	sub	sp, #28
 8008ef0:	460d      	mov	r5, r1
 8008ef2:	4616      	mov	r6, r2
 8008ef4:	4604      	mov	r4, r0
 8008ef6:	461f      	mov	r7, r3
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 8008ef8:	a805      	add	r0, sp, #20
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8008efa:	2305      	movs	r3, #5
 8008efc:	9304      	str	r3, [sp, #16]
    SE_EnterSecureMode(&primask_bit);
 8008efe:	f7ff fe6d 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_FIND_OBJECTS_FCT_ID),
 8008f02:	4623      	mov	r3, r4
 8008f04:	9a05      	ldr	r2, [sp, #20]
 8008f06:	4c06      	ldr	r4, [pc, #24]	; (8008f20 <SE_KMS_FindObjects+0x34>)
 8008f08:	9500      	str	r5, [sp, #0]
 8008f0a:	a904      	add	r1, sp, #16
 8008f0c:	e9cd 6701 	strd	r6, r7, [sp, #4]
 8008f10:	4804      	ldr	r0, [pc, #16]	; (8008f24 <SE_KMS_FindObjects+0x38>)
 8008f12:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit,
                      hSession, phObject, ulMaxObjectCount, pulObjectCount);

    SE_ExitSecureMode(primask_bit);
 8008f14:	9805      	ldr	r0, [sp, #20]
 8008f16:	f7ff fe66 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 8008f1a:	9804      	ldr	r0, [sp, #16]
 8008f1c:	b007      	add	sp, #28
 8008f1e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008f20:	08000205 	.word	0x08000205
 8008f24:	1000001b 	.word	0x1000001b

08008f28 <SE_KMS_FindObjectsFinal>:
  *         for more details on the APIs, parameters and possible returned values
  * @param  hSession
  * @retval Operation status
  */
__root CK_RV SE_KMS_FindObjectsFinal(CK_SESSION_HANDLE hSession)
{
 8008f28:	b513      	push	{r0, r1, r4, lr}
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8008f2a:	2305      	movs	r3, #5
{
 8008f2c:	4604      	mov	r4, r0
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 8008f2e:	a801      	add	r0, sp, #4
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8008f30:	9300      	str	r3, [sp, #0]
    SE_EnterSecureMode(&primask_bit);
 8008f32:	f7ff fe53 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_FIND_OBJECTS_FINAL_FCT_ID),
 8008f36:	4623      	mov	r3, r4
 8008f38:	9a01      	ldr	r2, [sp, #4]
 8008f3a:	4c05      	ldr	r4, [pc, #20]	; (8008f50 <SE_KMS_FindObjectsFinal+0x28>)
 8008f3c:	4805      	ldr	r0, [pc, #20]	; (8008f54 <SE_KMS_FindObjectsFinal+0x2c>)
 8008f3e:	4669      	mov	r1, sp
 8008f40:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit,
                      hSession);

    SE_ExitSecureMode(primask_bit);
 8008f42:	9801      	ldr	r0, [sp, #4]
 8008f44:	f7ff fe4f 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 8008f48:	9800      	ldr	r0, [sp, #0]
 8008f4a:	b002      	add	sp, #8
 8008f4c:	bd10      	pop	{r4, pc}
 8008f4e:	bf00      	nop
 8008f50:	08000205 	.word	0x08000205
 8008f54:	1000001c 	.word	0x1000001c

08008f58 <SE_KMS_EncryptInit>:
  * @param  hKey
  * @retval Operation status
  */
__root CK_RV SE_KMS_EncryptInit(CK_SESSION_HANDLE hSession,
                                CK_MECHANISM_PTR  pMechanism, CK_OBJECT_HANDLE  hKey)
{
 8008f58:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 8008f5a:	460d      	mov	r5, r1
 8008f5c:	4616      	mov	r6, r2
 8008f5e:	4604      	mov	r4, r0
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8008f60:	2305      	movs	r3, #5
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 8008f62:	a803      	add	r0, sp, #12
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8008f64:	9302      	str	r3, [sp, #8]
    SE_EnterSecureMode(&primask_bit);
 8008f66:	f7ff fe39 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_ENCRYPT_INIT_FCT_ID),
 8008f6a:	4623      	mov	r3, r4
 8008f6c:	9a03      	ldr	r2, [sp, #12]
 8008f6e:	4c06      	ldr	r4, [pc, #24]	; (8008f88 <SE_KMS_EncryptInit+0x30>)
 8008f70:	4806      	ldr	r0, [pc, #24]	; (8008f8c <SE_KMS_EncryptInit+0x34>)
 8008f72:	a902      	add	r1, sp, #8
 8008f74:	e9cd 5600 	strd	r5, r6, [sp]
 8008f78:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit,
                      hSession, pMechanism, hKey);

    SE_ExitSecureMode(primask_bit);
 8008f7a:	9803      	ldr	r0, [sp, #12]
 8008f7c:	f7ff fe33 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 8008f80:	9802      	ldr	r0, [sp, #8]
 8008f82:	b004      	add	sp, #16
 8008f84:	bd70      	pop	{r4, r5, r6, pc}
 8008f86:	bf00      	nop
 8008f88:	08000205 	.word	0x08000205
 8008f8c:	1000001d 	.word	0x1000001d

08008f90 <SE_KMS_Encrypt>:
  * @retval Operation status
  */
__root CK_RV SE_KMS_Encrypt(CK_SESSION_HANDLE hSession, CK_BYTE_PTR pData,
                            CK_ULONG  ulDataLen, CK_BYTE_PTR  pEncryptedData,
                            CK_ULONG_PTR      pulEncryptedDataLen)
{
 8008f90:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008f92:	b087      	sub	sp, #28
 8008f94:	4604      	mov	r4, r0
 8008f96:	461f      	mov	r7, r3
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 8008f98:	a805      	add	r0, sp, #20
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8008f9a:	2305      	movs	r3, #5
{
 8008f9c:	460d      	mov	r5, r1
 8008f9e:	4616      	mov	r6, r2
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8008fa0:	9304      	str	r3, [sp, #16]
    SE_EnterSecureMode(&primask_bit);
 8008fa2:	f7ff fe1b 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_ENCRYPT_FCT_ID),
 8008fa6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8008fa8:	9a05      	ldr	r2, [sp, #20]
 8008faa:	4807      	ldr	r0, [pc, #28]	; (8008fc8 <SE_KMS_Encrypt+0x38>)
 8008fac:	e9cd 7302 	strd	r7, r3, [sp, #8]
 8008fb0:	a904      	add	r1, sp, #16
 8008fb2:	4623      	mov	r3, r4
 8008fb4:	e9cd 5600 	strd	r5, r6, [sp]
 8008fb8:	4c04      	ldr	r4, [pc, #16]	; (8008fcc <SE_KMS_Encrypt+0x3c>)
 8008fba:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit,
                      hSession, pData, ulDataLen, pEncryptedData,
                      pulEncryptedDataLen);

    SE_ExitSecureMode(primask_bit);
 8008fbc:	9805      	ldr	r0, [sp, #20]
 8008fbe:	f7ff fe12 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 8008fc2:	9804      	ldr	r0, [sp, #16]
 8008fc4:	b007      	add	sp, #28
 8008fc6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008fc8:	1000001e 	.word	0x1000001e
 8008fcc:	08000205 	.word	0x08000205

08008fd0 <SE_KMS_EncryptUpdate>:

__root CK_RV SE_KMS_EncryptUpdate(CK_SESSION_HANDLE hSession, CK_BYTE_PTR pPart,
                                  CK_ULONG          ulPartLen,
                                  CK_BYTE_PTR       pEncryptedPart,
                                  CK_ULONG_PTR      pulEncryptedPartLen)
{
 8008fd0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008fd2:	b087      	sub	sp, #28
 8008fd4:	4604      	mov	r4, r0
 8008fd6:	461f      	mov	r7, r3
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 8008fd8:	a805      	add	r0, sp, #20
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8008fda:	2305      	movs	r3, #5
{
 8008fdc:	460d      	mov	r5, r1
 8008fde:	4616      	mov	r6, r2
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8008fe0:	9304      	str	r3, [sp, #16]
    SE_EnterSecureMode(&primask_bit);
 8008fe2:	f7ff fdfb 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_ENCRYPT_UPDATE_FCT_ID),
 8008fe6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8008fe8:	9a05      	ldr	r2, [sp, #20]
 8008fea:	4807      	ldr	r0, [pc, #28]	; (8009008 <SE_KMS_EncryptUpdate+0x38>)
 8008fec:	e9cd 7302 	strd	r7, r3, [sp, #8]
 8008ff0:	a904      	add	r1, sp, #16
 8008ff2:	4623      	mov	r3, r4
 8008ff4:	e9cd 5600 	strd	r5, r6, [sp]
 8008ff8:	4c04      	ldr	r4, [pc, #16]	; (800900c <SE_KMS_EncryptUpdate+0x3c>)
 8008ffa:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit,
                      hSession, pPart, ulPartLen, pEncryptedPart,
                      pulEncryptedPartLen);

    SE_ExitSecureMode(primask_bit);
 8008ffc:	9805      	ldr	r0, [sp, #20]
 8008ffe:	f7ff fdf2 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 8009002:	9804      	ldr	r0, [sp, #16]
 8009004:	b007      	add	sp, #28
 8009006:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8009008:	1000001f 	.word	0x1000001f
 800900c:	08000205 	.word	0x08000205

08009010 <SE_KMS_EncryptFinal>:
  * @retval Operation status
  */
__root CK_RV SE_KMS_EncryptFinal(CK_SESSION_HANDLE hSession,
                                 CK_BYTE_PTR       pLastEncryptedPart,
                                 CK_ULONG_PTR      pulLastEncryptedPartLen)
{
 8009010:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 8009012:	460d      	mov	r5, r1
 8009014:	4616      	mov	r6, r2
 8009016:	4604      	mov	r4, r0
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8009018:	2305      	movs	r3, #5
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 800901a:	a803      	add	r0, sp, #12
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 800901c:	9302      	str	r3, [sp, #8]
    SE_EnterSecureMode(&primask_bit);
 800901e:	f7ff fddd 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_ENCRYPT_FINAL_FCT_ID),
 8009022:	4623      	mov	r3, r4
 8009024:	9a03      	ldr	r2, [sp, #12]
 8009026:	4c06      	ldr	r4, [pc, #24]	; (8009040 <SE_KMS_EncryptFinal+0x30>)
 8009028:	4806      	ldr	r0, [pc, #24]	; (8009044 <SE_KMS_EncryptFinal+0x34>)
 800902a:	a902      	add	r1, sp, #8
 800902c:	e9cd 5600 	strd	r5, r6, [sp]
 8009030:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit,
                      hSession, pLastEncryptedPart, pulLastEncryptedPartLen);

    SE_ExitSecureMode(primask_bit);
 8009032:	9803      	ldr	r0, [sp, #12]
 8009034:	f7ff fdd7 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 8009038:	9802      	ldr	r0, [sp, #8]
 800903a:	b004      	add	sp, #16
 800903c:	bd70      	pop	{r4, r5, r6, pc}
 800903e:	bf00      	nop
 8009040:	08000205 	.word	0x08000205
 8009044:	10000020 	.word	0x10000020

08009048 <SE_KMS_DecryptInit>:
  * @retval Operation status
  */
__root CK_RV SE_KMS_DecryptInit(CK_SESSION_HANDLE hSession,
                                CK_MECHANISM_PTR  pMechanism,
                                CK_OBJECT_HANDLE  hKey)
{
 8009048:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 800904a:	460d      	mov	r5, r1
 800904c:	4616      	mov	r6, r2
 800904e:	4604      	mov	r4, r0
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8009050:	2305      	movs	r3, #5
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 8009052:	a803      	add	r0, sp, #12
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8009054:	9302      	str	r3, [sp, #8]
    SE_EnterSecureMode(&primask_bit);
 8009056:	f7ff fdc1 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_DECRYPT_INIT_FCT_ID),
 800905a:	4623      	mov	r3, r4
 800905c:	9a03      	ldr	r2, [sp, #12]
 800905e:	4c06      	ldr	r4, [pc, #24]	; (8009078 <SE_KMS_DecryptInit+0x30>)
 8009060:	4806      	ldr	r0, [pc, #24]	; (800907c <SE_KMS_DecryptInit+0x34>)
 8009062:	a902      	add	r1, sp, #8
 8009064:	e9cd 5600 	strd	r5, r6, [sp]
 8009068:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit,
                      hSession, pMechanism, hKey);

    SE_ExitSecureMode(primask_bit);
 800906a:	9803      	ldr	r0, [sp, #12]
 800906c:	f7ff fdbb 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 8009070:	9802      	ldr	r0, [sp, #8]
 8009072:	b004      	add	sp, #16
 8009074:	bd70      	pop	{r4, r5, r6, pc}
 8009076:	bf00      	nop
 8009078:	08000205 	.word	0x08000205
 800907c:	10000021 	.word	0x10000021

08009080 <SE_KMS_Decrypt>:
  * @retval Operation status
  */
__root CK_RV SE_KMS_Decrypt(CK_SESSION_HANDLE hSession, CK_BYTE_PTR pEncryptedData,
                            CK_ULONG  ulEncryptedDataLen, CK_BYTE_PTR  pData,
                            CK_ULONG_PTR pulDataLen)
{
 8009080:	b5f0      	push	{r4, r5, r6, r7, lr}
 8009082:	b087      	sub	sp, #28
 8009084:	4604      	mov	r4, r0
 8009086:	461f      	mov	r7, r3
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 8009088:	a805      	add	r0, sp, #20
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 800908a:	2305      	movs	r3, #5
{
 800908c:	460d      	mov	r5, r1
 800908e:	4616      	mov	r6, r2
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8009090:	9304      	str	r3, [sp, #16]
    SE_EnterSecureMode(&primask_bit);
 8009092:	f7ff fda3 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_DECRYPT_FCT_ID),
 8009096:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8009098:	9a05      	ldr	r2, [sp, #20]
 800909a:	4807      	ldr	r0, [pc, #28]	; (80090b8 <SE_KMS_Decrypt+0x38>)
 800909c:	e9cd 7302 	strd	r7, r3, [sp, #8]
 80090a0:	a904      	add	r1, sp, #16
 80090a2:	4623      	mov	r3, r4
 80090a4:	e9cd 5600 	strd	r5, r6, [sp]
 80090a8:	4c04      	ldr	r4, [pc, #16]	; (80090bc <SE_KMS_Decrypt+0x3c>)
 80090aa:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit,
                      hSession, pEncryptedData, ulEncryptedDataLen,
                      pData, pulDataLen);

    SE_ExitSecureMode(primask_bit);
 80090ac:	9805      	ldr	r0, [sp, #20]
 80090ae:	f7ff fd9a 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 80090b2:	9804      	ldr	r0, [sp, #16]
 80090b4:	b007      	add	sp, #28
 80090b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80090b8:	10000022 	.word	0x10000022
 80090bc:	08000205 	.word	0x08000205

080090c0 <SE_KMS_DecryptUpdate>:
__root CK_RV SE_KMS_DecryptUpdate(CK_SESSION_HANDLE hSession,
                                  CK_BYTE_PTR       pEncryptedPart,
                                  CK_ULONG          ulEncryptedPartLen,
                                  CK_BYTE_PTR       pPart,
                                  CK_ULONG_PTR      pulPartLen)
{
 80090c0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80090c2:	b087      	sub	sp, #28
 80090c4:	4604      	mov	r4, r0
 80090c6:	461f      	mov	r7, r3
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 80090c8:	a805      	add	r0, sp, #20
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 80090ca:	2305      	movs	r3, #5
{
 80090cc:	460d      	mov	r5, r1
 80090ce:	4616      	mov	r6, r2
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 80090d0:	9304      	str	r3, [sp, #16]
    SE_EnterSecureMode(&primask_bit);
 80090d2:	f7ff fd83 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_DECRYPT_UPDATE_FCT_ID),
 80090d6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80090d8:	9a05      	ldr	r2, [sp, #20]
 80090da:	4807      	ldr	r0, [pc, #28]	; (80090f8 <SE_KMS_DecryptUpdate+0x38>)
 80090dc:	e9cd 7302 	strd	r7, r3, [sp, #8]
 80090e0:	a904      	add	r1, sp, #16
 80090e2:	4623      	mov	r3, r4
 80090e4:	e9cd 5600 	strd	r5, r6, [sp]
 80090e8:	4c04      	ldr	r4, [pc, #16]	; (80090fc <SE_KMS_DecryptUpdate+0x3c>)
 80090ea:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit,
                      hSession, pEncryptedPart, ulEncryptedPartLen,
                      pPart, pulPartLen);

    SE_ExitSecureMode(primask_bit);
 80090ec:	9805      	ldr	r0, [sp, #20]
 80090ee:	f7ff fd7a 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 80090f2:	9804      	ldr	r0, [sp, #16]
 80090f4:	b007      	add	sp, #28
 80090f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80090f8:	10000023 	.word	0x10000023
 80090fc:	08000205 	.word	0x08000205

08009100 <SE_KMS_DecryptFinal>:
  * @retval Operation status
  */
__root CK_RV SE_KMS_DecryptFinal(CK_SESSION_HANDLE hSession,
                                 CK_BYTE_PTR       pLastPart,
                                 CK_ULONG_PTR      pulLastPartLen)
{
 8009100:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 8009102:	460d      	mov	r5, r1
 8009104:	4616      	mov	r6, r2
 8009106:	4604      	mov	r4, r0
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8009108:	2305      	movs	r3, #5
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 800910a:	a803      	add	r0, sp, #12
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 800910c:	9302      	str	r3, [sp, #8]
    SE_EnterSecureMode(&primask_bit);
 800910e:	f7ff fd65 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_DECRYPT_FINAL_FCT_ID),
 8009112:	4623      	mov	r3, r4
 8009114:	9a03      	ldr	r2, [sp, #12]
 8009116:	4c06      	ldr	r4, [pc, #24]	; (8009130 <SE_KMS_DecryptFinal+0x30>)
 8009118:	4806      	ldr	r0, [pc, #24]	; (8009134 <SE_KMS_DecryptFinal+0x34>)
 800911a:	a902      	add	r1, sp, #8
 800911c:	e9cd 5600 	strd	r5, r6, [sp]
 8009120:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit,
                      hSession, pLastPart, pulLastPartLen);

    SE_ExitSecureMode(primask_bit);
 8009122:	9803      	ldr	r0, [sp, #12]
 8009124:	f7ff fd5f 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 8009128:	9802      	ldr	r0, [sp, #8]
 800912a:	b004      	add	sp, #16
 800912c:	bd70      	pop	{r4, r5, r6, pc}
 800912e:	bf00      	nop
 8009130:	08000205 	.word	0x08000205
 8009134:	10000024 	.word	0x10000024

08009138 <SE_KMS_DigestInit>:
  * @param  hSession
  * @param  pMechanism
  * @retval Operation status
  */
__root CK_RV SE_KMS_DigestInit(CK_SESSION_HANDLE hSession, CK_MECHANISM_PTR pMechanism)
{
 8009138:	b530      	push	{r4, r5, lr}
 800913a:	b085      	sub	sp, #20
 800913c:	460d      	mov	r5, r1
 800913e:	4604      	mov	r4, r0
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8009140:	2305      	movs	r3, #5
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 8009142:	a803      	add	r0, sp, #12
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8009144:	9302      	str	r3, [sp, #8]
    SE_EnterSecureMode(&primask_bit);
 8009146:	f7ff fd49 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_DIGEST_INIT_FCT_ID),
 800914a:	4623      	mov	r3, r4
 800914c:	9a03      	ldr	r2, [sp, #12]
 800914e:	4c05      	ldr	r4, [pc, #20]	; (8009164 <SE_KMS_DigestInit+0x2c>)
 8009150:	9500      	str	r5, [sp, #0]
 8009152:	a902      	add	r1, sp, #8
 8009154:	4804      	ldr	r0, [pc, #16]	; (8009168 <SE_KMS_DigestInit+0x30>)
 8009156:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit,
                      hSession, pMechanism);

    SE_ExitSecureMode(primask_bit);
 8009158:	9803      	ldr	r0, [sp, #12]
 800915a:	f7ff fd44 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 800915e:	9802      	ldr	r0, [sp, #8]
 8009160:	b005      	add	sp, #20
 8009162:	bd30      	pop	{r4, r5, pc}
 8009164:	08000205 	.word	0x08000205
 8009168:	10000025 	.word	0x10000025

0800916c <SE_KMS_Digest>:
  * @retval Operation status
  */
__root CK_RV SE_KMS_Digest(CK_SESSION_HANDLE hSession, CK_BYTE_PTR pData,
                           CK_ULONG ulDataLen, CK_BYTE_PTR pDigest,
                           CK_ULONG_PTR pulDigestLen)
{
 800916c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800916e:	b087      	sub	sp, #28
 8009170:	4604      	mov	r4, r0
 8009172:	461f      	mov	r7, r3
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 8009174:	a805      	add	r0, sp, #20
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8009176:	2305      	movs	r3, #5
{
 8009178:	460d      	mov	r5, r1
 800917a:	4616      	mov	r6, r2
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 800917c:	9304      	str	r3, [sp, #16]
    SE_EnterSecureMode(&primask_bit);
 800917e:	f7ff fd2d 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_DIGEST_FCT_ID),
 8009182:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8009184:	9a05      	ldr	r2, [sp, #20]
 8009186:	4807      	ldr	r0, [pc, #28]	; (80091a4 <SE_KMS_Digest+0x38>)
 8009188:	e9cd 7302 	strd	r7, r3, [sp, #8]
 800918c:	a904      	add	r1, sp, #16
 800918e:	4623      	mov	r3, r4
 8009190:	e9cd 5600 	strd	r5, r6, [sp]
 8009194:	4c04      	ldr	r4, [pc, #16]	; (80091a8 <SE_KMS_Digest+0x3c>)
 8009196:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit,
                      hSession, pData, ulDataLen, pDigest, pulDigestLen);

    SE_ExitSecureMode(primask_bit);
 8009198:	9805      	ldr	r0, [sp, #20]
 800919a:	f7ff fd24 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 800919e:	9804      	ldr	r0, [sp, #16]
 80091a0:	b007      	add	sp, #28
 80091a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80091a4:	10000026 	.word	0x10000026
 80091a8:	08000205 	.word	0x08000205

080091ac <SE_KMS_DigestUpdate>:
  * @param  pPart
  * @param  ulPartLen
  * @retval Operation status
  */
__root CK_RV SE_KMS_DigestUpdate(CK_SESSION_HANDLE hSession, CK_BYTE_PTR pPart, CK_ULONG ulPartLen)
{
 80091ac:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 80091ae:	460d      	mov	r5, r1
 80091b0:	4616      	mov	r6, r2
 80091b2:	4604      	mov	r4, r0
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 80091b4:	2305      	movs	r3, #5
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 80091b6:	a803      	add	r0, sp, #12
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 80091b8:	9302      	str	r3, [sp, #8]
    SE_EnterSecureMode(&primask_bit);
 80091ba:	f7ff fd0f 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_DIGEST_UPDATE_FCT_ID),
 80091be:	4623      	mov	r3, r4
 80091c0:	9a03      	ldr	r2, [sp, #12]
 80091c2:	4c06      	ldr	r4, [pc, #24]	; (80091dc <SE_KMS_DigestUpdate+0x30>)
 80091c4:	4806      	ldr	r0, [pc, #24]	; (80091e0 <SE_KMS_DigestUpdate+0x34>)
 80091c6:	a902      	add	r1, sp, #8
 80091c8:	e9cd 5600 	strd	r5, r6, [sp]
 80091cc:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit,
                      hSession, pPart, ulPartLen);

    SE_ExitSecureMode(primask_bit);
 80091ce:	9803      	ldr	r0, [sp, #12]
 80091d0:	f7ff fd09 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 80091d4:	9802      	ldr	r0, [sp, #8]
 80091d6:	b004      	add	sp, #16
 80091d8:	bd70      	pop	{r4, r5, r6, pc}
 80091da:	bf00      	nop
 80091dc:	08000205 	.word	0x08000205
 80091e0:	10000027 	.word	0x10000027

080091e4 <SE_KMS_DigestFinal>:
  * @param  pulDigestLen
  * @retval Operation status
  */
__root CK_RV SE_KMS_DigestFinal(CK_SESSION_HANDLE hSession, CK_BYTE_PTR pDigest,
                                CK_ULONG_PTR pulDigestLen)
{
 80091e4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 80091e6:	460d      	mov	r5, r1
 80091e8:	4616      	mov	r6, r2
 80091ea:	4604      	mov	r4, r0
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 80091ec:	2305      	movs	r3, #5
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 80091ee:	a803      	add	r0, sp, #12
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 80091f0:	9302      	str	r3, [sp, #8]
    SE_EnterSecureMode(&primask_bit);
 80091f2:	f7ff fcf3 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_DIGEST_FINAL_FCT_ID),
 80091f6:	4623      	mov	r3, r4
 80091f8:	9a03      	ldr	r2, [sp, #12]
 80091fa:	4c06      	ldr	r4, [pc, #24]	; (8009214 <SE_KMS_DigestFinal+0x30>)
 80091fc:	4806      	ldr	r0, [pc, #24]	; (8009218 <SE_KMS_DigestFinal+0x34>)
 80091fe:	a902      	add	r1, sp, #8
 8009200:	e9cd 5600 	strd	r5, r6, [sp]
 8009204:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit,
                      hSession, pDigest, pulDigestLen);

    SE_ExitSecureMode(primask_bit);
 8009206:	9803      	ldr	r0, [sp, #12]
 8009208:	f7ff fced 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 800920c:	9802      	ldr	r0, [sp, #8]
 800920e:	b004      	add	sp, #16
 8009210:	bd70      	pop	{r4, r5, r6, pc}
 8009212:	bf00      	nop
 8009214:	08000205 	.word	0x08000205
 8009218:	10000029 	.word	0x10000029

0800921c <SE_KMS_SignInit>:
  * @retval Operation status
  */
__root CK_RV SE_KMS_SignInit(CK_SESSION_HANDLE hSession,
                             CK_MECHANISM_PTR  pMechanism,
                             CK_OBJECT_HANDLE  hKey)
{
 800921c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 800921e:	460d      	mov	r5, r1
 8009220:	4616      	mov	r6, r2
 8009222:	4604      	mov	r4, r0
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8009224:	2305      	movs	r3, #5
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 8009226:	a803      	add	r0, sp, #12
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8009228:	9302      	str	r3, [sp, #8]
    SE_EnterSecureMode(&primask_bit);
 800922a:	f7ff fcd7 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_SIGN_INIT_FCT_ID),
 800922e:	4623      	mov	r3, r4
 8009230:	9a03      	ldr	r2, [sp, #12]
 8009232:	4c06      	ldr	r4, [pc, #24]	; (800924c <SE_KMS_SignInit+0x30>)
 8009234:	4806      	ldr	r0, [pc, #24]	; (8009250 <SE_KMS_SignInit+0x34>)
 8009236:	a902      	add	r1, sp, #8
 8009238:	e9cd 5600 	strd	r5, r6, [sp]
 800923c:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit,
                      hSession, pMechanism, hKey);

    SE_ExitSecureMode(primask_bit);
 800923e:	9803      	ldr	r0, [sp, #12]
 8009240:	f7ff fcd1 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 8009244:	9802      	ldr	r0, [sp, #8]
 8009246:	b004      	add	sp, #16
 8009248:	bd70      	pop	{r4, r5, r6, pc}
 800924a:	bf00      	nop
 800924c:	08000205 	.word	0x08000205
 8009250:	1000002a 	.word	0x1000002a

08009254 <SE_KMS_Sign>:
  * @retval Operation status
  */
__root CK_RV SE_KMS_Sign(CK_SESSION_HANDLE hSession, CK_BYTE_PTR pData,
                         CK_ULONG  ulDataLen, CK_BYTE_PTR  pSignature,
                         CK_ULONG_PTR pulSignatureLen)
{
 8009254:	b5f0      	push	{r4, r5, r6, r7, lr}
 8009256:	b087      	sub	sp, #28
 8009258:	4604      	mov	r4, r0
 800925a:	461f      	mov	r7, r3
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 800925c:	a805      	add	r0, sp, #20
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 800925e:	2305      	movs	r3, #5
{
 8009260:	460d      	mov	r5, r1
 8009262:	4616      	mov	r6, r2
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8009264:	9304      	str	r3, [sp, #16]
    SE_EnterSecureMode(&primask_bit);
 8009266:	f7ff fcb9 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_SIGN_FCT_ID),
 800926a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800926c:	9a05      	ldr	r2, [sp, #20]
 800926e:	4807      	ldr	r0, [pc, #28]	; (800928c <SE_KMS_Sign+0x38>)
 8009270:	e9cd 7302 	strd	r7, r3, [sp, #8]
 8009274:	a904      	add	r1, sp, #16
 8009276:	4623      	mov	r3, r4
 8009278:	e9cd 5600 	strd	r5, r6, [sp]
 800927c:	4c04      	ldr	r4, [pc, #16]	; (8009290 <SE_KMS_Sign+0x3c>)
 800927e:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status,
                      primask_bit,
                      hSession, pData, ulDataLen,
                      pSignature, pulSignatureLen);

    SE_ExitSecureMode(primask_bit);
 8009280:	9805      	ldr	r0, [sp, #20]
 8009282:	f7ff fcb0 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 8009286:	9804      	ldr	r0, [sp, #16]
 8009288:	b007      	add	sp, #28
 800928a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800928c:	1000002b 	.word	0x1000002b
 8009290:	08000205 	.word	0x08000205

08009294 <SE_KMS_VerifyInit>:
  * @retval Operation status
  */
__root CK_RV SE_KMS_VerifyInit(CK_SESSION_HANDLE hSession,
                               CK_MECHANISM_PTR  pMechanism,
                               CK_OBJECT_HANDLE  hKey)
{
 8009294:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 8009296:	460d      	mov	r5, r1
 8009298:	4616      	mov	r6, r2
 800929a:	4604      	mov	r4, r0
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 800929c:	2305      	movs	r3, #5
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 800929e:	a803      	add	r0, sp, #12
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 80092a0:	9302      	str	r3, [sp, #8]
    SE_EnterSecureMode(&primask_bit);
 80092a2:	f7ff fc9b 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_VERIFY_INIT_FCT_ID),
 80092a6:	4623      	mov	r3, r4
 80092a8:	9a03      	ldr	r2, [sp, #12]
 80092aa:	4c06      	ldr	r4, [pc, #24]	; (80092c4 <SE_KMS_VerifyInit+0x30>)
 80092ac:	4806      	ldr	r0, [pc, #24]	; (80092c8 <SE_KMS_VerifyInit+0x34>)
 80092ae:	a902      	add	r1, sp, #8
 80092b0:	e9cd 5600 	strd	r5, r6, [sp]
 80092b4:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit,
                      hSession, pMechanism, hKey);

    SE_ExitSecureMode(primask_bit);
 80092b6:	9803      	ldr	r0, [sp, #12]
 80092b8:	f7ff fc95 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 80092bc:	9802      	ldr	r0, [sp, #8]
 80092be:	b004      	add	sp, #16
 80092c0:	bd70      	pop	{r4, r5, r6, pc}
 80092c2:	bf00      	nop
 80092c4:	08000205 	.word	0x08000205
 80092c8:	10000030 	.word	0x10000030

080092cc <SE_KMS_Verify>:
  * @retval Operation status
  */
__root CK_RV SE_KMS_Verify(CK_SESSION_HANDLE hSession, CK_BYTE_PTR pData,
                           CK_ULONG  ulDataLen, CK_BYTE_PTR  pSignature,
                           CK_ULONG  ulSignatureLen)
{
 80092cc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80092ce:	b087      	sub	sp, #28
 80092d0:	4604      	mov	r4, r0
 80092d2:	461f      	mov	r7, r3
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 80092d4:	a805      	add	r0, sp, #20
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 80092d6:	2305      	movs	r3, #5
{
 80092d8:	460d      	mov	r5, r1
 80092da:	4616      	mov	r6, r2
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 80092dc:	9304      	str	r3, [sp, #16]
    SE_EnterSecureMode(&primask_bit);
 80092de:	f7ff fc7d 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_VERIFY_FCT_ID),
 80092e2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80092e4:	9a05      	ldr	r2, [sp, #20]
 80092e6:	4807      	ldr	r0, [pc, #28]	; (8009304 <SE_KMS_Verify+0x38>)
 80092e8:	e9cd 7302 	strd	r7, r3, [sp, #8]
 80092ec:	a904      	add	r1, sp, #16
 80092ee:	4623      	mov	r3, r4
 80092f0:	e9cd 5600 	strd	r5, r6, [sp]
 80092f4:	4c04      	ldr	r4, [pc, #16]	; (8009308 <SE_KMS_Verify+0x3c>)
 80092f6:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit,
                      hSession, pData, ulDataLen,
                      pSignature, ulSignatureLen);

    SE_ExitSecureMode(primask_bit);
 80092f8:	9805      	ldr	r0, [sp, #20]
 80092fa:	f7ff fc74 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 80092fe:	9804      	ldr	r0, [sp, #16]
 8009300:	b007      	add	sp, #28
 8009302:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8009304:	10000031 	.word	0x10000031
 8009308:	08000205 	.word	0x08000205

0800930c <SE_KMS_DeriveKey>:
  * @retval Operation status
  */
__root CK_RV SE_KMS_DeriveKey(CK_SESSION_HANDLE hSession, CK_MECHANISM_PTR pMechanism,
                              CK_OBJECT_HANDLE hBaseKey, CK_ATTRIBUTE_PTR  pTemplate,
                              CK_ULONG  ulAttributeCount, CK_OBJECT_HANDLE_PTR  phKey)
{
 800930c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800930e:	b089      	sub	sp, #36	; 0x24
 8009310:	4604      	mov	r4, r0
 8009312:	461f      	mov	r7, r3
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 8009314:	a807      	add	r0, sp, #28
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8009316:	2305      	movs	r3, #5
{
 8009318:	460d      	mov	r5, r1
 800931a:	4616      	mov	r6, r2
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 800931c:	9306      	str	r3, [sp, #24]
    SE_EnterSecureMode(&primask_bit);
 800931e:	f7ff fc5d 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_DERIVE_KEY_FCT_ID),
 8009322:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8009324:	9304      	str	r3, [sp, #16]
 8009326:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8009328:	9a07      	ldr	r2, [sp, #28]
 800932a:	4807      	ldr	r0, [pc, #28]	; (8009348 <SE_KMS_DeriveKey+0x3c>)
 800932c:	e9cd 7302 	strd	r7, r3, [sp, #8]
 8009330:	a906      	add	r1, sp, #24
 8009332:	4623      	mov	r3, r4
 8009334:	e9cd 5600 	strd	r5, r6, [sp]
 8009338:	4c04      	ldr	r4, [pc, #16]	; (800934c <SE_KMS_DeriveKey+0x40>)
 800933a:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit,
                      hSession, pMechanism, hBaseKey, pTemplate, ulAttributeCount, phKey);

    SE_ExitSecureMode(primask_bit);
 800933c:	9807      	ldr	r0, [sp, #28]
 800933e:	f7ff fc52 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 8009342:	9806      	ldr	r0, [sp, #24]
 8009344:	b009      	add	sp, #36	; 0x24
 8009346:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8009348:	1000003e 	.word	0x1000003e
 800934c:	08000205 	.word	0x08000205

08009350 <SE_KMS_GenerateKeyPair>:
  */
__root CK_RV SE_KMS_GenerateKeyPair(CK_SESSION_HANDLE hSession, CK_MECHANISM_PTR pMechanism,
                                    CK_ATTRIBUTE_PTR pPublicKeyTemplate, CK_ULONG  ulPublicKeyAttributeCount,
                                    CK_ATTRIBUTE_PTR pPrivateKeyTemplate, CK_ULONG ulPrivateKeyAttributeCount,
                                    CK_OBJECT_HANDLE_PTR phPublicKey, CK_OBJECT_HANDLE_PTR phPrivateKey)
{
 8009350:	b5f0      	push	{r4, r5, r6, r7, lr}
 8009352:	b08b      	sub	sp, #44	; 0x2c
 8009354:	4604      	mov	r4, r0
 8009356:	461f      	mov	r7, r3
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 8009358:	a809      	add	r0, sp, #36	; 0x24
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 800935a:	2305      	movs	r3, #5
{
 800935c:	460d      	mov	r5, r1
 800935e:	4616      	mov	r6, r2
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8009360:	9308      	str	r3, [sp, #32]
    SE_EnterSecureMode(&primask_bit);
 8009362:	f7ff fc3b 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_GENERATE_KEYPAIR_FCT_ID),
 8009366:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8009368:	9306      	str	r3, [sp, #24]
 800936a:	9b12      	ldr	r3, [sp, #72]	; 0x48
 800936c:	9305      	str	r3, [sp, #20]
 800936e:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8009370:	9304      	str	r3, [sp, #16]
 8009372:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8009374:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8009376:	4807      	ldr	r0, [pc, #28]	; (8009394 <SE_KMS_GenerateKeyPair+0x44>)
 8009378:	e9cd 7302 	strd	r7, r3, [sp, #8]
 800937c:	a908      	add	r1, sp, #32
 800937e:	4623      	mov	r3, r4
 8009380:	e9cd 5600 	strd	r5, r6, [sp]
 8009384:	4c04      	ldr	r4, [pc, #16]	; (8009398 <SE_KMS_GenerateKeyPair+0x48>)
 8009386:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit, hSession,  pMechanism,
                      pPublicKeyTemplate,   ulPublicKeyAttributeCount,  pPrivateKeyTemplate,
                      ulPrivateKeyAttributeCount, phPublicKey,  phPrivateKey);

    SE_ExitSecureMode(primask_bit);
 8009388:	9809      	ldr	r0, [sp, #36]	; 0x24
 800938a:	f7ff fc2c 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 800938e:	9808      	ldr	r0, [sp, #32]
 8009390:	b00b      	add	sp, #44	; 0x2c
 8009392:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8009394:	1000003b 	.word	0x1000003b
 8009398:	08000205 	.word	0x08000205

0800939c <SE_KMS_GenerateRandom>:
  * @param  ulRandomLen
  * @retval Operation status
  */
__root CK_RV SE_KMS_GenerateRandom(CK_SESSION_HANDLE hSession, CK_BYTE_PTR  pRandomData,
                                   CK_ULONG  ulRandomLen)
{
 800939c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 800939e:	460d      	mov	r5, r1
 80093a0:	4616      	mov	r6, r2
 80093a2:	4604      	mov	r4, r0
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 80093a4:	2305      	movs	r3, #5
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 80093a6:	a803      	add	r0, sp, #12
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 80093a8:	9302      	str	r3, [sp, #8]
    SE_EnterSecureMode(&primask_bit);
 80093aa:	f7ff fc17 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_GENERATE_RANDOM_FCT_ID),
 80093ae:	4623      	mov	r3, r4
 80093b0:	9a03      	ldr	r2, [sp, #12]
 80093b2:	4c06      	ldr	r4, [pc, #24]	; (80093cc <SE_KMS_GenerateRandom+0x30>)
 80093b4:	4806      	ldr	r0, [pc, #24]	; (80093d0 <SE_KMS_GenerateRandom+0x34>)
 80093b6:	a902      	add	r1, sp, #8
 80093b8:	e9cd 5600 	strd	r5, r6, [sp]
 80093bc:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit,
                      hSession, pRandomData, ulRandomLen);

    SE_ExitSecureMode(primask_bit);
 80093be:	9803      	ldr	r0, [sp, #12]
 80093c0:	f7ff fc11 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 80093c4:	9802      	ldr	r0, [sp, #8]
 80093c6:	b004      	add	sp, #16
 80093c8:	bd70      	pop	{r4, r5, r6, pc}
 80093ca:	bf00      	nop
 80093cc:	08000205 	.word	0x08000205
 80093d0:	10000040 	.word	0x10000040

080093d4 <SE_KMS_ImportBlob>:
  * @param  pHdr is the pointer to the encrypted blob header
  * @param  pFlash is the pointer to the blob location in flash
  * @retval Operation status
  */
__root CK_RV SE_KMS_ImportBlob(CK_BYTE_PTR pHdr, CK_BYTE_PTR pFlash)
{
 80093d4:	b530      	push	{r4, r5, lr}
 80093d6:	b085      	sub	sp, #20
 80093d8:	460d      	mov	r5, r1
 80093da:	4604      	mov	r4, r0
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 80093dc:	2305      	movs	r3, #5
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 80093de:	a803      	add	r0, sp, #12
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 80093e0:	9302      	str	r3, [sp, #8]
    SE_EnterSecureMode(&primask_bit);
 80093e2:	f7ff fbfb 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_IMPORT_BLOB_FCT_ID),
 80093e6:	4623      	mov	r3, r4
 80093e8:	9a03      	ldr	r2, [sp, #12]
 80093ea:	4c05      	ldr	r4, [pc, #20]	; (8009400 <SE_KMS_ImportBlob+0x2c>)
 80093ec:	9500      	str	r5, [sp, #0]
 80093ee:	a902      	add	r1, sp, #8
 80093f0:	4804      	ldr	r0, [pc, #16]	; (8009404 <SE_KMS_ImportBlob+0x30>)
 80093f2:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit,
                      pHdr, pFlash);

    SE_ExitSecureMode(primask_bit);
 80093f4:	9803      	ldr	r0, [sp, #12]
 80093f6:	f7ff fbf6 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 80093fa:	9802      	ldr	r0, [sp, #8]
 80093fc:	b005      	add	sp, #20
 80093fe:	bd30      	pop	{r4, r5, pc}
 8009400:	08000205 	.word	0x08000205
 8009404:	10000044 	.word	0x10000044

08009408 <SE_KMS_LockKeys>:
  * @param  pKeys Pointer to key handles to be locked
  * @param  ulCount Number of keys to lock
  * @retval Operation status
  */
__root CK_RV SE_KMS_LockKeys(CK_OBJECT_HANDLE_PTR pKeys, CK_ULONG ulCount)
{
 8009408:	b530      	push	{r4, r5, lr}
 800940a:	b085      	sub	sp, #20
 800940c:	460d      	mov	r5, r1
 800940e:	4604      	mov	r4, r0
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8009410:	2305      	movs	r3, #5
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 8009412:	a803      	add	r0, sp, #12
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8009414:	9302      	str	r3, [sp, #8]
    SE_EnterSecureMode(&primask_bit);
 8009416:	f7ff fbe1 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_LOCK_KEYS_FCT_ID),
 800941a:	4623      	mov	r3, r4
 800941c:	9a03      	ldr	r2, [sp, #12]
 800941e:	4c05      	ldr	r4, [pc, #20]	; (8009434 <SE_KMS_LockKeys+0x2c>)
 8009420:	9500      	str	r5, [sp, #0]
 8009422:	a902      	add	r1, sp, #8
 8009424:	4804      	ldr	r0, [pc, #16]	; (8009438 <SE_KMS_LockKeys+0x30>)
 8009426:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit,
                      pKeys, ulCount);

    SE_ExitSecureMode(primask_bit);
 8009428:	9803      	ldr	r0, [sp, #12]
 800942a:	f7ff fbdc 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 800942e:	9802      	ldr	r0, [sp, #8]
 8009430:	b005      	add	sp, #20
 8009432:	bd30      	pop	{r4, r5, pc}
 8009434:	08000205 	.word	0x08000205
 8009438:	10000045 	.word	0x10000045

0800943c <SE_KMS_LockServices>:
  * @param  pServices Pointer to services function identifier to be locked
  * @param  ulCount Number of services to lock
  * @retval Operation status
  */
__root CK_RV SE_KMS_LockServices(CK_ULONG_PTR pServices, CK_ULONG ulCount)
{
 800943c:	b530      	push	{r4, r5, lr}
 800943e:	b085      	sub	sp, #20
 8009440:	460d      	mov	r5, r1
 8009442:	4604      	mov	r4, r0
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8009444:	2305      	movs	r3, #5
#endif /* SFU_ISOLATE_SE_WITH_MPU */
  {
    /* Set the CallGate function pointer */
    SET_CALLGATE();

    SE_EnterSecureMode(&primask_bit);
 8009446:	a803      	add	r0, sp, #12
  CK_RV ck_rv_ret_status = CKR_GENERAL_ERROR;
 8009448:	9302      	str	r3, [sp, #8]
    SE_EnterSecureMode(&primask_bit);
 800944a:	f7ff fbc7 	bl	8008bdc <SE_EnterSecureMode>

    /* Secure Engine Call */
    (*SE_CallGatePtr)((SE_FunctionIDTypeDef)(SE_MW_ADDON_KMS_MSB | KMS_LOCK_SERVICES_FCT_ID),
 800944e:	4623      	mov	r3, r4
 8009450:	9a03      	ldr	r2, [sp, #12]
 8009452:	4c05      	ldr	r4, [pc, #20]	; (8009468 <SE_KMS_LockServices+0x2c>)
 8009454:	9500      	str	r5, [sp, #0]
 8009456:	a902      	add	r1, sp, #8
 8009458:	4804      	ldr	r0, [pc, #16]	; (800946c <SE_KMS_LockServices+0x30>)
 800945a:	47a0      	blx	r4
                      (SE_StatusTypeDef *)(uint32_t)&ck_rv_ret_status, primask_bit,
                      pServices, ulCount);

    SE_ExitSecureMode(primask_bit);
 800945c:	9803      	ldr	r0, [sp, #12]
 800945e:	f7ff fbc2 	bl	8008be6 <SE_ExitSecureMode>
  }

  return ck_rv_ret_status;
}
 8009462:	9802      	ldr	r0, [sp, #8]
 8009464:	b005      	add	sp, #20
 8009466:	bd30      	pop	{r4, r5, pc}
 8009468:	08000205 	.word	0x08000205
 800946c:	10000046 	.word	0x10000046

Disassembly of section .text:

08009600 <__do_global_dtors_aux>:
 8009600:	b510      	push	{r4, lr}
 8009602:	4c05      	ldr	r4, [pc, #20]	; (8009618 <__do_global_dtors_aux+0x18>)
 8009604:	7823      	ldrb	r3, [r4, #0]
 8009606:	b933      	cbnz	r3, 8009616 <__do_global_dtors_aux+0x16>
 8009608:	4b04      	ldr	r3, [pc, #16]	; (800961c <__do_global_dtors_aux+0x1c>)
 800960a:	b113      	cbz	r3, 8009612 <__do_global_dtors_aux+0x12>
 800960c:	4804      	ldr	r0, [pc, #16]	; (8009620 <__do_global_dtors_aux+0x20>)
 800960e:	f3af 8000 	nop.w
 8009612:	2301      	movs	r3, #1
 8009614:	7023      	strb	r3, [r4, #0]
 8009616:	bd10      	pop	{r4, pc}
 8009618:	20003480 	.word	0x20003480
 800961c:	00000000 	.word	0x00000000
 8009620:	0800fedc 	.word	0x0800fedc

08009624 <frame_dummy>:
 8009624:	b508      	push	{r3, lr}
 8009626:	4b03      	ldr	r3, [pc, #12]	; (8009634 <frame_dummy+0x10>)
 8009628:	b11b      	cbz	r3, 8009632 <frame_dummy+0xe>
 800962a:	4903      	ldr	r1, [pc, #12]	; (8009638 <frame_dummy+0x14>)
 800962c:	4803      	ldr	r0, [pc, #12]	; (800963c <frame_dummy+0x18>)
 800962e:	f3af 8000 	nop.w
 8009632:	bd08      	pop	{r3, pc}
 8009634:	00000000 	.word	0x00000000
 8009638:	20003484 	.word	0x20003484
 800963c:	0800fedc 	.word	0x0800fedc

08009640 <memchr>:
 8009640:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8009644:	2a10      	cmp	r2, #16
 8009646:	db2b      	blt.n	80096a0 <memchr+0x60>
 8009648:	f010 0f07 	tst.w	r0, #7
 800964c:	d008      	beq.n	8009660 <memchr+0x20>
 800964e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8009652:	3a01      	subs	r2, #1
 8009654:	428b      	cmp	r3, r1
 8009656:	d02d      	beq.n	80096b4 <memchr+0x74>
 8009658:	f010 0f07 	tst.w	r0, #7
 800965c:	b342      	cbz	r2, 80096b0 <memchr+0x70>
 800965e:	d1f6      	bne.n	800964e <memchr+0xe>
 8009660:	b4f0      	push	{r4, r5, r6, r7}
 8009662:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8009666:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800966a:	f022 0407 	bic.w	r4, r2, #7
 800966e:	f07f 0700 	mvns.w	r7, #0
 8009672:	2300      	movs	r3, #0
 8009674:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8009678:	3c08      	subs	r4, #8
 800967a:	ea85 0501 	eor.w	r5, r5, r1
 800967e:	ea86 0601 	eor.w	r6, r6, r1
 8009682:	fa85 f547 	uadd8	r5, r5, r7
 8009686:	faa3 f587 	sel	r5, r3, r7
 800968a:	fa86 f647 	uadd8	r6, r6, r7
 800968e:	faa5 f687 	sel	r6, r5, r7
 8009692:	b98e      	cbnz	r6, 80096b8 <memchr+0x78>
 8009694:	d1ee      	bne.n	8009674 <memchr+0x34>
 8009696:	bcf0      	pop	{r4, r5, r6, r7}
 8009698:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800969c:	f002 0207 	and.w	r2, r2, #7
 80096a0:	b132      	cbz	r2, 80096b0 <memchr+0x70>
 80096a2:	f810 3b01 	ldrb.w	r3, [r0], #1
 80096a6:	3a01      	subs	r2, #1
 80096a8:	ea83 0301 	eor.w	r3, r3, r1
 80096ac:	b113      	cbz	r3, 80096b4 <memchr+0x74>
 80096ae:	d1f8      	bne.n	80096a2 <memchr+0x62>
 80096b0:	2000      	movs	r0, #0
 80096b2:	4770      	bx	lr
 80096b4:	3801      	subs	r0, #1
 80096b6:	4770      	bx	lr
 80096b8:	2d00      	cmp	r5, #0
 80096ba:	bf06      	itte	eq
 80096bc:	4635      	moveq	r5, r6
 80096be:	3803      	subeq	r0, #3
 80096c0:	3807      	subne	r0, #7
 80096c2:	f015 0f01 	tst.w	r5, #1
 80096c6:	d107      	bne.n	80096d8 <memchr+0x98>
 80096c8:	3001      	adds	r0, #1
 80096ca:	f415 7f80 	tst.w	r5, #256	; 0x100
 80096ce:	bf02      	ittt	eq
 80096d0:	3001      	addeq	r0, #1
 80096d2:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 80096d6:	3001      	addeq	r0, #1
 80096d8:	bcf0      	pop	{r4, r5, r6, r7}
 80096da:	3801      	subs	r0, #1
 80096dc:	4770      	bx	lr
 80096de:	bf00      	nop

080096e0 <__aeabi_uldivmod>:
 80096e0:	b953      	cbnz	r3, 80096f8 <__aeabi_uldivmod+0x18>
 80096e2:	b94a      	cbnz	r2, 80096f8 <__aeabi_uldivmod+0x18>
 80096e4:	2900      	cmp	r1, #0
 80096e6:	bf08      	it	eq
 80096e8:	2800      	cmpeq	r0, #0
 80096ea:	bf1c      	itt	ne
 80096ec:	f04f 31ff 	movne.w	r1, #4294967295
 80096f0:	f04f 30ff 	movne.w	r0, #4294967295
 80096f4:	f000 b96c 	b.w	80099d0 <__aeabi_idiv0>
 80096f8:	f1ad 0c08 	sub.w	ip, sp, #8
 80096fc:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8009700:	f000 f806 	bl	8009710 <__udivmoddi4>
 8009704:	f8dd e004 	ldr.w	lr, [sp, #4]
 8009708:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800970c:	b004      	add	sp, #16
 800970e:	4770      	bx	lr

08009710 <__udivmoddi4>:
 8009710:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8009714:	9e08      	ldr	r6, [sp, #32]
 8009716:	460d      	mov	r5, r1
 8009718:	4604      	mov	r4, r0
 800971a:	468e      	mov	lr, r1
 800971c:	2b00      	cmp	r3, #0
 800971e:	f040 8082 	bne.w	8009826 <__udivmoddi4+0x116>
 8009722:	428a      	cmp	r2, r1
 8009724:	4617      	mov	r7, r2
 8009726:	d946      	bls.n	80097b6 <__udivmoddi4+0xa6>
 8009728:	fab2 f282 	clz	r2, r2
 800972c:	b14a      	cbz	r2, 8009742 <__udivmoddi4+0x32>
 800972e:	f1c2 0120 	rsb	r1, r2, #32
 8009732:	fa05 f302 	lsl.w	r3, r5, r2
 8009736:	fa20 f101 	lsr.w	r1, r0, r1
 800973a:	4097      	lsls	r7, r2
 800973c:	ea41 0e03 	orr.w	lr, r1, r3
 8009740:	4094      	lsls	r4, r2
 8009742:	ea4f 4817 	mov.w	r8, r7, lsr #16
 8009746:	0c23      	lsrs	r3, r4, #16
 8009748:	fbbe fcf8 	udiv	ip, lr, r8
 800974c:	b2b9      	uxth	r1, r7
 800974e:	fb08 ee1c 	mls	lr, r8, ip, lr
 8009752:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
 8009756:	fb0c f001 	mul.w	r0, ip, r1
 800975a:	4298      	cmp	r0, r3
 800975c:	d90a      	bls.n	8009774 <__udivmoddi4+0x64>
 800975e:	18fb      	adds	r3, r7, r3
 8009760:	f10c 35ff 	add.w	r5, ip, #4294967295
 8009764:	f080 8116 	bcs.w	8009994 <__udivmoddi4+0x284>
 8009768:	4298      	cmp	r0, r3
 800976a:	f240 8113 	bls.w	8009994 <__udivmoddi4+0x284>
 800976e:	f1ac 0c02 	sub.w	ip, ip, #2
 8009772:	443b      	add	r3, r7
 8009774:	1a1b      	subs	r3, r3, r0
 8009776:	b2a4      	uxth	r4, r4
 8009778:	fbb3 f0f8 	udiv	r0, r3, r8
 800977c:	fb08 3310 	mls	r3, r8, r0, r3
 8009780:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8009784:	fb00 f101 	mul.w	r1, r0, r1
 8009788:	42a1      	cmp	r1, r4
 800978a:	d909      	bls.n	80097a0 <__udivmoddi4+0x90>
 800978c:	193c      	adds	r4, r7, r4
 800978e:	f100 33ff 	add.w	r3, r0, #4294967295
 8009792:	f080 8101 	bcs.w	8009998 <__udivmoddi4+0x288>
 8009796:	42a1      	cmp	r1, r4
 8009798:	f240 80fe 	bls.w	8009998 <__udivmoddi4+0x288>
 800979c:	3802      	subs	r0, #2
 800979e:	443c      	add	r4, r7
 80097a0:	1a64      	subs	r4, r4, r1
 80097a2:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 80097a6:	2100      	movs	r1, #0
 80097a8:	b11e      	cbz	r6, 80097b2 <__udivmoddi4+0xa2>
 80097aa:	40d4      	lsrs	r4, r2
 80097ac:	2300      	movs	r3, #0
 80097ae:	e9c6 4300 	strd	r4, r3, [r6]
 80097b2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80097b6:	b902      	cbnz	r2, 80097ba <__udivmoddi4+0xaa>
 80097b8:	deff      	udf	#255	; 0xff
 80097ba:	fab2 f282 	clz	r2, r2
 80097be:	2a00      	cmp	r2, #0
 80097c0:	d14f      	bne.n	8009862 <__udivmoddi4+0x152>
 80097c2:	1bcb      	subs	r3, r1, r7
 80097c4:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 80097c8:	fa1f f887 	uxth.w	r8, r7
 80097cc:	2101      	movs	r1, #1
 80097ce:	fbb3 fcfe 	udiv	ip, r3, lr
 80097d2:	0c25      	lsrs	r5, r4, #16
 80097d4:	fb0e 331c 	mls	r3, lr, ip, r3
 80097d8:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 80097dc:	fb08 f30c 	mul.w	r3, r8, ip
 80097e0:	42ab      	cmp	r3, r5
 80097e2:	d907      	bls.n	80097f4 <__udivmoddi4+0xe4>
 80097e4:	197d      	adds	r5, r7, r5
 80097e6:	f10c 30ff 	add.w	r0, ip, #4294967295
 80097ea:	d202      	bcs.n	80097f2 <__udivmoddi4+0xe2>
 80097ec:	42ab      	cmp	r3, r5
 80097ee:	f200 80e7 	bhi.w	80099c0 <__udivmoddi4+0x2b0>
 80097f2:	4684      	mov	ip, r0
 80097f4:	1aed      	subs	r5, r5, r3
 80097f6:	b2a3      	uxth	r3, r4
 80097f8:	fbb5 f0fe 	udiv	r0, r5, lr
 80097fc:	fb0e 5510 	mls	r5, lr, r0, r5
 8009800:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
 8009804:	fb08 f800 	mul.w	r8, r8, r0
 8009808:	45a0      	cmp	r8, r4
 800980a:	d907      	bls.n	800981c <__udivmoddi4+0x10c>
 800980c:	193c      	adds	r4, r7, r4
 800980e:	f100 33ff 	add.w	r3, r0, #4294967295
 8009812:	d202      	bcs.n	800981a <__udivmoddi4+0x10a>
 8009814:	45a0      	cmp	r8, r4
 8009816:	f200 80d7 	bhi.w	80099c8 <__udivmoddi4+0x2b8>
 800981a:	4618      	mov	r0, r3
 800981c:	eba4 0408 	sub.w	r4, r4, r8
 8009820:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 8009824:	e7c0      	b.n	80097a8 <__udivmoddi4+0x98>
 8009826:	428b      	cmp	r3, r1
 8009828:	d908      	bls.n	800983c <__udivmoddi4+0x12c>
 800982a:	2e00      	cmp	r6, #0
 800982c:	f000 80af 	beq.w	800998e <__udivmoddi4+0x27e>
 8009830:	2100      	movs	r1, #0
 8009832:	e9c6 0500 	strd	r0, r5, [r6]
 8009836:	4608      	mov	r0, r1
 8009838:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800983c:	fab3 f183 	clz	r1, r3
 8009840:	2900      	cmp	r1, #0
 8009842:	d14b      	bne.n	80098dc <__udivmoddi4+0x1cc>
 8009844:	42ab      	cmp	r3, r5
 8009846:	d302      	bcc.n	800984e <__udivmoddi4+0x13e>
 8009848:	4282      	cmp	r2, r0
 800984a:	f200 80b7 	bhi.w	80099bc <__udivmoddi4+0x2ac>
 800984e:	1a84      	subs	r4, r0, r2
 8009850:	eb65 0303 	sbc.w	r3, r5, r3
 8009854:	2001      	movs	r0, #1
 8009856:	469e      	mov	lr, r3
 8009858:	2e00      	cmp	r6, #0
 800985a:	d0aa      	beq.n	80097b2 <__udivmoddi4+0xa2>
 800985c:	e9c6 4e00 	strd	r4, lr, [r6]
 8009860:	e7a7      	b.n	80097b2 <__udivmoddi4+0xa2>
 8009862:	f1c2 0c20 	rsb	ip, r2, #32
 8009866:	fa01 f302 	lsl.w	r3, r1, r2
 800986a:	4097      	lsls	r7, r2
 800986c:	fa20 f00c 	lsr.w	r0, r0, ip
 8009870:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8009874:	fa21 fc0c 	lsr.w	ip, r1, ip
 8009878:	4318      	orrs	r0, r3
 800987a:	fbbc f1fe 	udiv	r1, ip, lr
 800987e:	0c05      	lsrs	r5, r0, #16
 8009880:	fb0e cc11 	mls	ip, lr, r1, ip
 8009884:	fa1f f887 	uxth.w	r8, r7
 8009888:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
 800988c:	fb01 f308 	mul.w	r3, r1, r8
 8009890:	42ab      	cmp	r3, r5
 8009892:	fa04 f402 	lsl.w	r4, r4, r2
 8009896:	d909      	bls.n	80098ac <__udivmoddi4+0x19c>
 8009898:	197d      	adds	r5, r7, r5
 800989a:	f101 3cff 	add.w	ip, r1, #4294967295
 800989e:	f080 808b 	bcs.w	80099b8 <__udivmoddi4+0x2a8>
 80098a2:	42ab      	cmp	r3, r5
 80098a4:	f240 8088 	bls.w	80099b8 <__udivmoddi4+0x2a8>
 80098a8:	3902      	subs	r1, #2
 80098aa:	443d      	add	r5, r7
 80098ac:	1aeb      	subs	r3, r5, r3
 80098ae:	b285      	uxth	r5, r0
 80098b0:	fbb3 f0fe 	udiv	r0, r3, lr
 80098b4:	fb0e 3310 	mls	r3, lr, r0, r3
 80098b8:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 80098bc:	fb00 f308 	mul.w	r3, r0, r8
 80098c0:	42ab      	cmp	r3, r5
 80098c2:	d907      	bls.n	80098d4 <__udivmoddi4+0x1c4>
 80098c4:	197d      	adds	r5, r7, r5
 80098c6:	f100 3cff 	add.w	ip, r0, #4294967295
 80098ca:	d271      	bcs.n	80099b0 <__udivmoddi4+0x2a0>
 80098cc:	42ab      	cmp	r3, r5
 80098ce:	d96f      	bls.n	80099b0 <__udivmoddi4+0x2a0>
 80098d0:	3802      	subs	r0, #2
 80098d2:	443d      	add	r5, r7
 80098d4:	1aeb      	subs	r3, r5, r3
 80098d6:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 80098da:	e778      	b.n	80097ce <__udivmoddi4+0xbe>
 80098dc:	f1c1 0c20 	rsb	ip, r1, #32
 80098e0:	408b      	lsls	r3, r1
 80098e2:	fa22 f70c 	lsr.w	r7, r2, ip
 80098e6:	431f      	orrs	r7, r3
 80098e8:	fa20 f40c 	lsr.w	r4, r0, ip
 80098ec:	fa05 f301 	lsl.w	r3, r5, r1
 80098f0:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 80098f4:	fa25 f50c 	lsr.w	r5, r5, ip
 80098f8:	431c      	orrs	r4, r3
 80098fa:	0c23      	lsrs	r3, r4, #16
 80098fc:	fbb5 f9fe 	udiv	r9, r5, lr
 8009900:	fa1f f887 	uxth.w	r8, r7
 8009904:	fb0e 5519 	mls	r5, lr, r9, r5
 8009908:	ea43 4505 	orr.w	r5, r3, r5, lsl #16
 800990c:	fb09 fa08 	mul.w	sl, r9, r8
 8009910:	45aa      	cmp	sl, r5
 8009912:	fa02 f201 	lsl.w	r2, r2, r1
 8009916:	fa00 f301 	lsl.w	r3, r0, r1
 800991a:	d908      	bls.n	800992e <__udivmoddi4+0x21e>
 800991c:	197d      	adds	r5, r7, r5
 800991e:	f109 30ff 	add.w	r0, r9, #4294967295
 8009922:	d247      	bcs.n	80099b4 <__udivmoddi4+0x2a4>
 8009924:	45aa      	cmp	sl, r5
 8009926:	d945      	bls.n	80099b4 <__udivmoddi4+0x2a4>
 8009928:	f1a9 0902 	sub.w	r9, r9, #2
 800992c:	443d      	add	r5, r7
 800992e:	eba5 050a 	sub.w	r5, r5, sl
 8009932:	b2a4      	uxth	r4, r4
 8009934:	fbb5 f0fe 	udiv	r0, r5, lr
 8009938:	fb0e 5510 	mls	r5, lr, r0, r5
 800993c:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 8009940:	fb00 f808 	mul.w	r8, r0, r8
 8009944:	45a0      	cmp	r8, r4
 8009946:	d907      	bls.n	8009958 <__udivmoddi4+0x248>
 8009948:	193c      	adds	r4, r7, r4
 800994a:	f100 35ff 	add.w	r5, r0, #4294967295
 800994e:	d22d      	bcs.n	80099ac <__udivmoddi4+0x29c>
 8009950:	45a0      	cmp	r8, r4
 8009952:	d92b      	bls.n	80099ac <__udivmoddi4+0x29c>
 8009954:	3802      	subs	r0, #2
 8009956:	443c      	add	r4, r7
 8009958:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 800995c:	eba4 0408 	sub.w	r4, r4, r8
 8009960:	fba0 8902 	umull	r8, r9, r0, r2
 8009964:	454c      	cmp	r4, r9
 8009966:	46c6      	mov	lr, r8
 8009968:	464d      	mov	r5, r9
 800996a:	d319      	bcc.n	80099a0 <__udivmoddi4+0x290>
 800996c:	d016      	beq.n	800999c <__udivmoddi4+0x28c>
 800996e:	b15e      	cbz	r6, 8009988 <__udivmoddi4+0x278>
 8009970:	ebb3 020e 	subs.w	r2, r3, lr
 8009974:	eb64 0405 	sbc.w	r4, r4, r5
 8009978:	fa04 fc0c 	lsl.w	ip, r4, ip
 800997c:	40ca      	lsrs	r2, r1
 800997e:	ea4c 0202 	orr.w	r2, ip, r2
 8009982:	40cc      	lsrs	r4, r1
 8009984:	e9c6 2400 	strd	r2, r4, [r6]
 8009988:	2100      	movs	r1, #0
 800998a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800998e:	4631      	mov	r1, r6
 8009990:	4630      	mov	r0, r6
 8009992:	e70e      	b.n	80097b2 <__udivmoddi4+0xa2>
 8009994:	46ac      	mov	ip, r5
 8009996:	e6ed      	b.n	8009774 <__udivmoddi4+0x64>
 8009998:	4618      	mov	r0, r3
 800999a:	e701      	b.n	80097a0 <__udivmoddi4+0x90>
 800999c:	4543      	cmp	r3, r8
 800999e:	d2e6      	bcs.n	800996e <__udivmoddi4+0x25e>
 80099a0:	ebb8 0e02 	subs.w	lr, r8, r2
 80099a4:	eb69 0507 	sbc.w	r5, r9, r7
 80099a8:	3801      	subs	r0, #1
 80099aa:	e7e0      	b.n	800996e <__udivmoddi4+0x25e>
 80099ac:	4628      	mov	r0, r5
 80099ae:	e7d3      	b.n	8009958 <__udivmoddi4+0x248>
 80099b0:	4660      	mov	r0, ip
 80099b2:	e78f      	b.n	80098d4 <__udivmoddi4+0x1c4>
 80099b4:	4681      	mov	r9, r0
 80099b6:	e7ba      	b.n	800992e <__udivmoddi4+0x21e>
 80099b8:	4661      	mov	r1, ip
 80099ba:	e777      	b.n	80098ac <__udivmoddi4+0x19c>
 80099bc:	4608      	mov	r0, r1
 80099be:	e74b      	b.n	8009858 <__udivmoddi4+0x148>
 80099c0:	f1ac 0c02 	sub.w	ip, ip, #2
 80099c4:	443d      	add	r5, r7
 80099c6:	e715      	b.n	80097f4 <__udivmoddi4+0xe4>
 80099c8:	3802      	subs	r0, #2
 80099ca:	443c      	add	r4, r7
 80099cc:	e726      	b.n	800981c <__udivmoddi4+0x10c>
 80099ce:	bf00      	nop

080099d0 <__aeabi_idiv0>:
 80099d0:	4770      	bx	lr
 80099d2:	bf00      	nop

080099d4 <SFU_BOOT_SM_HandleCriticalFailure>:
  * @param  None
  * @note   After a Critical Failure a Reboot will be called.
  * @retval None
  */
static void SFU_BOOT_SM_HandleCriticalFailure(void)
{
 80099d4:	b508      	push	{r3, lr}
  TRACE("\r\n= [SBOOT] STATE: HANDLE CRITICAL FAILURE");
 80099d6:	4805      	ldr	r0, [pc, #20]	; (80099ec <SFU_BOOT_SM_HandleCriticalFailure+0x18>)
 80099d8:	f005 f98e 	bl	800ecf8 <iprintf>

  /* It's not possible to continue without compromising the stability or the security of the solution.
     The State Machine needs to be aborted and a Reset must be triggered */
  SFU_SET_SM_IF_CURR_STATE(SFU_ERROR, SFU_STATE_REBOOT_STATE_MACHINE, SFU_STATE_REBOOT_STATE_MACHINE);
 80099dc:	4b04      	ldr	r3, [pc, #16]	; (80099f0 <SFU_BOOT_SM_HandleCriticalFailure+0x1c>)
 80099de:	785a      	ldrb	r2, [r3, #1]
 80099e0:	b2d2      	uxtb	r2, r2
 80099e2:	701a      	strb	r2, [r3, #0]
 80099e4:	220c      	movs	r2, #12
 80099e6:	705a      	strb	r2, [r3, #1]
}
 80099e8:	bd08      	pop	{r3, pc}
 80099ea:	bf00      	nop
 80099ec:	080101ec 	.word	0x080101ec
 80099f0:	200034ac 	.word	0x200034ac

080099f4 <SFU_BOOT_SM_RollbackInstallPrevUserFw>:
{
 80099f4:	b508      	push	{r3, lr}
  TRACE("\r\n= [SBOOT] STATE: ROLLBACK NOT SUPPORTED");
 80099f6:	4805      	ldr	r0, [pc, #20]	; (8009a0c <SFU_BOOT_SM_RollbackInstallPrevUserFw+0x18>)
 80099f8:	f005 f97e 	bl	800ecf8 <iprintf>
  SFU_SET_SM_CURR_STATE(SFU_STATE_HANDLE_CRITICAL_FAILURE);
 80099fc:	4b04      	ldr	r3, [pc, #16]	; (8009a10 <SFU_BOOT_SM_RollbackInstallPrevUserFw+0x1c>)
 80099fe:	785a      	ldrb	r2, [r3, #1]
 8009a00:	b2d2      	uxtb	r2, r2
 8009a02:	701a      	strb	r2, [r3, #0]
 8009a04:	220b      	movs	r2, #11
 8009a06:	705a      	strb	r2, [r3, #1]
}
 8009a08:	bd08      	pop	{r3, pc}
 8009a0a:	bf00      	nop
 8009a0c:	08010217 	.word	0x08010217
 8009a10:	200034ac 	.word	0x200034ac

08009a14 <SFU_BOOT_SM_CheckNewFwToDownload>:
{
 8009a14:	b508      	push	{r3, lr}
  if (initialDeviceStatusCheck == 1U)
 8009a16:	4b0d      	ldr	r3, [pc, #52]	; (8009a4c <SFU_BOOT_SM_CheckNewFwToDownload+0x38>)
 8009a18:	781b      	ldrb	r3, [r3, #0]
 8009a1a:	2b01      	cmp	r3, #1
 8009a1c:	d00b      	beq.n	8009a36 <SFU_BOOT_SM_CheckNewFwToDownload+0x22>
    e_ret_status = SFU_SUCCESS;
 8009a1e:	490c      	ldr	r1, [pc, #48]	; (8009a50 <SFU_BOOT_SM_CheckNewFwToDownload+0x3c>)
  SFU_SET_SM_IF_CURR_STATE(e_ret_status, SFU_STATE_DOWNLOAD_NEW_USER_FW, SFU_STATE_CHECK_KMS_BLOB_TO_INSTALL);
 8009a20:	4b0c      	ldr	r3, [pc, #48]	; (8009a54 <SFU_BOOT_SM_CheckNewFwToDownload+0x40>)
 8009a22:	785a      	ldrb	r2, [r3, #1]
 8009a24:	b2d2      	uxtb	r2, r2
 8009a26:	701a      	strb	r2, [r3, #0]
 8009a28:	4a09      	ldr	r2, [pc, #36]	; (8009a50 <SFU_BOOT_SM_CheckNewFwToDownload+0x3c>)
 8009a2a:	4291      	cmp	r1, r2
 8009a2c:	bf0c      	ite	eq
 8009a2e:	2202      	moveq	r2, #2
 8009a30:	2203      	movne	r2, #3
 8009a32:	705a      	strb	r2, [r3, #1]
}
 8009a34:	bd08      	pop	{r3, pc}
    TRACE("\r\n= [SBOOT] STATE: CHECK NEW FIRMWARE TO DOWNLOAD");
 8009a36:	4808      	ldr	r0, [pc, #32]	; (8009a58 <SFU_BOOT_SM_CheckNewFwToDownload+0x44>)
 8009a38:	f005 f95e 	bl	800ecf8 <iprintf>
    if (0U != BUTTON_PUSHED())
 8009a3c:	2000      	movs	r0, #0
 8009a3e:	f003 fbbd 	bl	800d1bc <BSP_PB_GetState>
 8009a42:	2800      	cmp	r0, #0
 8009a44:	d0eb      	beq.n	8009a1e <SFU_BOOT_SM_CheckNewFwToDownload+0xa>
      e_ret_status = SFU_ERROR;
 8009a46:	f641 71e1 	movw	r1, #8161	; 0x1fe1
 8009a4a:	e7e9      	b.n	8009a20 <SFU_BOOT_SM_CheckNewFwToDownload+0xc>
 8009a4c:	20003c68 	.word	0x20003c68
 8009a50:	00122f11 	.word	0x00122f11
 8009a54:	200034ac 	.word	0x200034ac
 8009a58:	08010241 	.word	0x08010241

08009a5c <SFU_BOOT_SM_CheckUserFwStatus>:
{
 8009a5c:	b538      	push	{r3, r4, r5, lr}
  if (initialDeviceStatusCheck == 1U)
 8009a5e:	4d48      	ldr	r5, [pc, #288]	; (8009b80 <SFU_BOOT_SM_CheckUserFwStatus+0x124>)
 8009a60:	782b      	ldrb	r3, [r5, #0]
 8009a62:	2b01      	cmp	r3, #1
 8009a64:	d102      	bne.n	8009a6c <SFU_BOOT_SM_CheckUserFwStatus+0x10>
    TRACE("\r\n= [SBOOT] STATE: CHECK USER FW STATUS");
 8009a66:	4847      	ldr	r0, [pc, #284]	; (8009b84 <SFU_BOOT_SM_CheckUserFwStatus+0x128>)
 8009a68:	f005 f946 	bl	800ecf8 <iprintf>
  e_PendingInstallStatus = SFU_IMG_CheckPendingInstallation(&m_DwlSlotToInstall, &m_ActiveSlotToResume,
 8009a6c:	4a46      	ldr	r2, [pc, #280]	; (8009b88 <SFU_BOOT_SM_CheckUserFwStatus+0x12c>)
 8009a6e:	4947      	ldr	r1, [pc, #284]	; (8009b8c <SFU_BOOT_SM_CheckUserFwStatus+0x130>)
 8009a70:	4847      	ldr	r0, [pc, #284]	; (8009b90 <SFU_BOOT_SM_CheckUserFwStatus+0x134>)
 8009a72:	f002 f8bf 	bl	800bbf4 <SFU_IMG_CheckPendingInstallation>
  switch (e_PendingInstallStatus)
 8009a76:	2803      	cmp	r0, #3
 8009a78:	d844      	bhi.n	8009b04 <SFU_BOOT_SM_CheckUserFwStatus+0xa8>
 8009a7a:	e8df f000 	tbb	[pc, r0]
 8009a7e:	1220      	.short	0x1220
 8009a80:	022c      	.short	0x022c
      m_DwlSlotToInstall = m_ActiveSlotToRollback - SLOT_ACTIVE_1 + SLOT_DWL_1;
 8009a82:	4b41      	ldr	r3, [pc, #260]	; (8009b88 <SFU_BOOT_SM_CheckUserFwStatus+0x12c>)
      TRACE("\r\n\t  Installation not validated: rollback procedure initiated (SLOT_ACTIVE_%d / SLOT_DWL_%d)",
 8009a84:	4843      	ldr	r0, [pc, #268]	; (8009b94 <SFU_BOOT_SM_CheckUserFwStatus+0x138>)
      m_DwlSlotToInstall = m_ActiveSlotToRollback - SLOT_ACTIVE_1 + SLOT_DWL_1;
 8009a86:	681a      	ldr	r2, [r3, #0]
 8009a88:	4b41      	ldr	r3, [pc, #260]	; (8009b90 <SFU_BOOT_SM_CheckUserFwStatus+0x134>)
 8009a8a:	1c51      	adds	r1, r2, #1
 8009a8c:	6019      	str	r1, [r3, #0]
      TRACE("\r\n\t  Installation not validated: rollback procedure initiated (SLOT_ACTIVE_%d / SLOT_DWL_%d)",
 8009a8e:	4611      	mov	r1, r2
 8009a90:	f005 f932 	bl	800ecf8 <iprintf>
      SFU_SET_SM_CURR_STATE(SFU_STATE_ROLLBACK_PREV_USER_FW);
 8009a94:	4b40      	ldr	r3, [pc, #256]	; (8009b98 <SFU_BOOT_SM_CheckUserFwStatus+0x13c>)
 8009a96:	785a      	ldrb	r2, [r3, #1]
 8009a98:	b2d2      	uxtb	r2, r2
 8009a9a:	701a      	strb	r2, [r3, #0]
 8009a9c:	220a      	movs	r2, #10
      SFU_SET_SM_CURR_STATE(SFU_STATE_HANDLE_CRITICAL_FAILURE);
 8009a9e:	705a      	strb	r2, [r3, #1]
}
 8009aa0:	e02f      	b.n	8009b02 <SFU_BOOT_SM_CheckUserFwStatus+0xa6>
      TRACE("\r\n\t  Installation Failed: resume installation procedure initiated (SLOT_ACTIVE_%d / SLOT_DWL_%d)",
 8009aa2:	4b3b      	ldr	r3, [pc, #236]	; (8009b90 <SFU_BOOT_SM_CheckUserFwStatus+0x134>)
 8009aa4:	483d      	ldr	r0, [pc, #244]	; (8009b9c <SFU_BOOT_SM_CheckUserFwStatus+0x140>)
 8009aa6:	681a      	ldr	r2, [r3, #0]
 8009aa8:	4b38      	ldr	r3, [pc, #224]	; (8009b8c <SFU_BOOT_SM_CheckUserFwStatus+0x130>)
 8009aaa:	3a01      	subs	r2, #1
 8009aac:	6819      	ldr	r1, [r3, #0]
 8009aae:	f005 f923 	bl	800ecf8 <iprintf>
      SFU_SET_SM_CURR_STATE(SFU_STATE_RESUME_INSTALL_NEW_USER_FW);
 8009ab2:	4b39      	ldr	r3, [pc, #228]	; (8009b98 <SFU_BOOT_SM_CheckUserFwStatus+0x13c>)
 8009ab4:	785a      	ldrb	r2, [r3, #1]
 8009ab6:	b2d2      	uxtb	r2, r2
 8009ab8:	701a      	strb	r2, [r3, #0]
 8009aba:	2209      	movs	r2, #9
 8009abc:	e7ef      	b.n	8009a9e <SFU_BOOT_SM_CheckUserFwStatus+0x42>
      TRACE("\r\n\t  New Fw to be installed from slot SLOT_DWL_%d", m_DwlSlotToInstall - SLOT_DWL_1 + 1U);
 8009abe:	4b34      	ldr	r3, [pc, #208]	; (8009b90 <SFU_BOOT_SM_CheckUserFwStatus+0x134>)
 8009ac0:	4837      	ldr	r0, [pc, #220]	; (8009ba0 <SFU_BOOT_SM_CheckUserFwStatus+0x144>)
 8009ac2:	6819      	ldr	r1, [r3, #0]
 8009ac4:	3901      	subs	r1, #1
 8009ac6:	f005 f917 	bl	800ecf8 <iprintf>
      SFU_SET_SM_CURR_STATE(SFU_STATE_INSTALL_NEW_USER_FW);
 8009aca:	4b33      	ldr	r3, [pc, #204]	; (8009b98 <SFU_BOOT_SM_CheckUserFwStatus+0x13c>)
 8009acc:	785a      	ldrb	r2, [r3, #1]
 8009ace:	b2d2      	uxtb	r2, r2
 8009ad0:	701a      	strb	r2, [r3, #0]
 8009ad2:	2206      	movs	r2, #6
 8009ad4:	e7e3      	b.n	8009a9e <SFU_BOOT_SM_CheckUserFwStatus+0x42>
      m_ActiveSlotToExecute = 0U;
 8009ad6:	4c33      	ldr	r4, [pc, #204]	; (8009ba4 <SFU_BOOT_SM_CheckUserFwStatus+0x148>)
 8009ad8:	2300      	movs	r3, #0
        if (SFU_SUCCESS == SFU_IMG_DetectFW(MASTER_SLOT))
 8009ada:	2001      	movs	r0, #1
      m_ActiveSlotToExecute = 0U;
 8009adc:	6023      	str	r3, [r4, #0]
        if (SFU_SUCCESS == SFU_IMG_DetectFW(MASTER_SLOT))
 8009ade:	f001 f9e7 	bl	800aeb0 <SFU_IMG_DetectFW>
 8009ae2:	4b31      	ldr	r3, [pc, #196]	; (8009ba8 <SFU_BOOT_SM_CheckUserFwStatus+0x14c>)
 8009ae4:	4298      	cmp	r0, r3
 8009ae6:	d10a      	bne.n	8009afe <SFU_BOOT_SM_CheckUserFwStatus+0xa2>
          m_ActiveSlotToExecute = MASTER_SLOT;
 8009ae8:	2101      	movs	r1, #1
          TRACE("\r\n\t  A FW is detected in the slot SLOT_ACTIVE_%d", m_ActiveSlotToExecute);
 8009aea:	4830      	ldr	r0, [pc, #192]	; (8009bac <SFU_BOOT_SM_CheckUserFwStatus+0x150>)
          m_ActiveSlotToExecute = MASTER_SLOT;
 8009aec:	6021      	str	r1, [r4, #0]
          TRACE("\r\n\t  A FW is detected in the slot SLOT_ACTIVE_%d", m_ActiveSlotToExecute);
 8009aee:	f005 f903 	bl	800ecf8 <iprintf>
          SFU_SET_SM_CURR_STATE(SFU_STATE_VERIFY_USER_FW_SIGNATURE);
 8009af2:	4b29      	ldr	r3, [pc, #164]	; (8009b98 <SFU_BOOT_SM_CheckUserFwStatus+0x13c>)
 8009af4:	785a      	ldrb	r2, [r3, #1]
 8009af6:	b2d2      	uxtb	r2, r2
 8009af8:	701a      	strb	r2, [r3, #0]
 8009afa:	2207      	movs	r2, #7
 8009afc:	705a      	strb	r2, [r3, #1]
      if (m_ActiveSlotToExecute == 0U)
 8009afe:	6823      	ldr	r3, [r4, #0]
 8009b00:	b14b      	cbz	r3, 8009b16 <SFU_BOOT_SM_CheckUserFwStatus+0xba>
}
 8009b02:	bd38      	pop	{r3, r4, r5, pc}
      TRACE("\r\n\t  Flash State Unknown, Critical failure");
 8009b04:	482a      	ldr	r0, [pc, #168]	; (8009bb0 <SFU_BOOT_SM_CheckUserFwStatus+0x154>)
 8009b06:	f005 f8f7 	bl	800ecf8 <iprintf>
      SFU_SET_SM_CURR_STATE(SFU_STATE_HANDLE_CRITICAL_FAILURE);
 8009b0a:	4b23      	ldr	r3, [pc, #140]	; (8009b98 <SFU_BOOT_SM_CheckUserFwStatus+0x13c>)
 8009b0c:	785a      	ldrb	r2, [r3, #1]
 8009b0e:	b2d2      	uxtb	r2, r2
 8009b10:	701a      	strb	r2, [r3, #0]
 8009b12:	220b      	movs	r2, #11
 8009b14:	e7c3      	b.n	8009a9e <SFU_BOOT_SM_CheckUserFwStatus+0x42>
          if (SlotStartAdd[SLOT_ACTIVE_1 + i] != 0U)         /* Slot configured ? */
 8009b16:	4b27      	ldr	r3, [pc, #156]	; (8009bb4 <SFU_BOOT_SM_CheckUserFwStatus+0x158>)
 8009b18:	685b      	ldr	r3, [r3, #4]
 8009b1a:	b303      	cbz	r3, 8009b5e <SFU_BOOT_SM_CheckUserFwStatus+0x102>
            if (SFU_SUCCESS == SFU_IMG_DetectFW(SLOT_ACTIVE_1 + i))
 8009b1c:	2001      	movs	r0, #1
 8009b1e:	f001 f9c7 	bl	800aeb0 <SFU_IMG_DetectFW>
 8009b22:	4b21      	ldr	r3, [pc, #132]	; (8009ba8 <SFU_BOOT_SM_CheckUserFwStatus+0x14c>)
 8009b24:	4298      	cmp	r0, r3
 8009b26:	d10a      	bne.n	8009b3e <SFU_BOOT_SM_CheckUserFwStatus+0xe2>
              m_ActiveSlotToExecute = SLOT_ACTIVE_1 + i;
 8009b28:	2101      	movs	r1, #1
              TRACE("\r\n\t  A FW is detected in the slot SLOT_ACTIVE_%d", m_ActiveSlotToExecute);
 8009b2a:	4820      	ldr	r0, [pc, #128]	; (8009bac <SFU_BOOT_SM_CheckUserFwStatus+0x150>)
              m_ActiveSlotToExecute = SLOT_ACTIVE_1 + i;
 8009b2c:	6021      	str	r1, [r4, #0]
              TRACE("\r\n\t  A FW is detected in the slot SLOT_ACTIVE_%d", m_ActiveSlotToExecute);
 8009b2e:	f005 f8e3 	bl	800ecf8 <iprintf>
              SFU_SET_SM_CURR_STATE(SFU_STATE_VERIFY_USER_FW_SIGNATURE);
 8009b32:	4b19      	ldr	r3, [pc, #100]	; (8009b98 <SFU_BOOT_SM_CheckUserFwStatus+0x13c>)
 8009b34:	785a      	ldrb	r2, [r3, #1]
 8009b36:	b2d2      	uxtb	r2, r2
 8009b38:	701a      	strb	r2, [r3, #0]
 8009b3a:	2207      	movs	r2, #7
 8009b3c:	705a      	strb	r2, [r3, #1]
      if (m_ActiveSlotToExecute == 0U)
 8009b3e:	6823      	ldr	r3, [r4, #0]
 8009b40:	2b00      	cmp	r3, #0
 8009b42:	d1de      	bne.n	8009b02 <SFU_BOOT_SM_CheckUserFwStatus+0xa6>
            if (SFU_IMG_VerifyEmptyActiveSlot(SLOT_ACTIVE_1 + i) != SFU_SUCCESS)
 8009b44:	2001      	movs	r0, #1
 8009b46:	f001 f8bd 	bl	800acc4 <SFU_IMG_VerifyEmptyActiveSlot>
 8009b4a:	4b17      	ldr	r3, [pc, #92]	; (8009ba8 <SFU_BOOT_SM_CheckUserFwStatus+0x14c>)
 8009b4c:	4298      	cmp	r0, r3
 8009b4e:	d006      	beq.n	8009b5e <SFU_BOOT_SM_CheckUserFwStatus+0x102>
              TRACE("\r\n\t  Slot SLOT_ACTIVE_%d not empty : erasing ...", SLOT_ACTIVE_1 + i);
 8009b50:	4819      	ldr	r0, [pc, #100]	; (8009bb8 <SFU_BOOT_SM_CheckUserFwStatus+0x15c>)
 8009b52:	2101      	movs	r1, #1
 8009b54:	f005 f8d0 	bl	800ecf8 <iprintf>
              (void)SFU_IMG_InvalidateCurrentFirmware(SLOT_ACTIVE_1 + i); /* If this fails we continue anyhow */
 8009b58:	2001      	movs	r0, #1
 8009b5a:	f001 f879 	bl	800ac50 <SFU_IMG_InvalidateCurrentFirmware>
        if (1U == initialDeviceStatusCheck)
 8009b5e:	782b      	ldrb	r3, [r5, #0]
 8009b60:	2b01      	cmp	r3, #1
 8009b62:	d107      	bne.n	8009b74 <SFU_BOOT_SM_CheckUserFwStatus+0x118>
          TRACE("\r\n\t  No valid FW found in the active slots nor new FW to be installed");
 8009b64:	4815      	ldr	r0, [pc, #84]	; (8009bbc <SFU_BOOT_SM_CheckUserFwStatus+0x160>)
 8009b66:	f005 f8c7 	bl	800ecf8 <iprintf>
          TRACE("\r\n\t  Waiting for the local download to start... ");
 8009b6a:	4815      	ldr	r0, [pc, #84]	; (8009bc0 <SFU_BOOT_SM_CheckUserFwStatus+0x164>)
 8009b6c:	f005 f8c4 	bl	800ecf8 <iprintf>
          initialDeviceStatusCheck = 0U;
 8009b70:	2300      	movs	r3, #0
 8009b72:	702b      	strb	r3, [r5, #0]
        SFU_SET_SM_CURR_STATE(SFU_STATE_CHECK_NEW_FW_TO_DOWNLOAD);
 8009b74:	4b08      	ldr	r3, [pc, #32]	; (8009b98 <SFU_BOOT_SM_CheckUserFwStatus+0x13c>)
 8009b76:	785a      	ldrb	r2, [r3, #1]
 8009b78:	b2d2      	uxtb	r2, r2
 8009b7a:	701a      	strb	r2, [r3, #0]
 8009b7c:	2201      	movs	r2, #1
 8009b7e:	e78e      	b.n	8009a9e <SFU_BOOT_SM_CheckUserFwStatus+0x42>
 8009b80:	20003c68 	.word	0x20003c68
 8009b84:	08010273 	.word	0x08010273
 8009b88:	200034a4 	.word	0x200034a4
 8009b8c:	200034a0 	.word	0x200034a0
 8009b90:	200034a8 	.word	0x200034a8
 8009b94:	0801029b 	.word	0x0801029b
 8009b98:	200034ac 	.word	0x200034ac
 8009b9c:	080102f8 	.word	0x080102f8
 8009ba0:	08010359 	.word	0x08010359
 8009ba4:	2000349c 	.word	0x2000349c
 8009ba8:	00122f11 	.word	0x00122f11
 8009bac:	0801038b 	.word	0x0801038b
 8009bb0:	08010464 	.word	0x08010464
 8009bb4:	08010f28 	.word	0x08010f28
 8009bb8:	080103bc 	.word	0x080103bc
 8009bbc:	080103ed 	.word	0x080103ed
 8009bc0:	08010433 	.word	0x08010433

08009bc4 <SFU_BOOT_SM_InstallKMSBlob>:
{
 8009bc4:	b513      	push	{r0, r1, r4, lr}
  TRACE("\r\n= [SBOOT] STATE: INSTALL KMS BLOB");
 8009bc6:	4825      	ldr	r0, [pc, #148]	; (8009c5c <SFU_BOOT_SM_InstallKMSBlob+0x98>)
 8009bc8:	f005 f896 	bl	800ecf8 <iprintf>
  e_ret_status = SFU_KMS_GetBlobInstallInfo(&pBlobHdr, &pBlobInFlash);
 8009bcc:	a901      	add	r1, sp, #4
 8009bce:	4668      	mov	r0, sp
 8009bd0:	f002 fb66 	bl	800c2a0 <SFU_KMS_GetBlobInstallInfo>
  if (e_ret_status != SFU_SUCCESS)
 8009bd4:	4b22      	ldr	r3, [pc, #136]	; (8009c60 <SFU_BOOT_SM_InstallKMSBlob+0x9c>)
 8009bd6:	4298      	cmp	r0, r3
 8009bd8:	d00a      	beq.n	8009bf0 <SFU_BOOT_SM_InstallKMSBlob+0x2c>
    TRACE("\r\n= [SBOOT] INSTALL KMS: ERROR WHEN RETRIEVING BLOB LOCATION");
 8009bda:	4822      	ldr	r0, [pc, #136]	; (8009c64 <SFU_BOOT_SM_InstallKMSBlob+0xa0>)
        TRACE("\r\n= [SBOOT] INSTALL KMS: UNKNOWN STATUS");
 8009bdc:	f005 f88c 	bl	800ecf8 <iprintf>
  SFU_SET_SM_CURR_STATE(SFU_STATE_VERIFY_USER_FW_STATUS);
 8009be0:	4b21      	ldr	r3, [pc, #132]	; (8009c68 <SFU_BOOT_SM_InstallKMSBlob+0xa4>)
 8009be2:	785a      	ldrb	r2, [r3, #1]
 8009be4:	b2d2      	uxtb	r2, r2
 8009be6:	701a      	strb	r2, [r3, #0]
 8009be8:	2205      	movs	r2, #5
 8009bea:	705a      	strb	r2, [r3, #1]
}
 8009bec:	b002      	add	sp, #8
 8009bee:	bd10      	pop	{r4, pc}
    e_status = C_Initialize(NULL);
 8009bf0:	2000      	movs	r0, #0
 8009bf2:	f7fe fffd 	bl	8008bf0 <SE_KMS_Initialize>
    if (e_status == CKR_OK)
 8009bf6:	4604      	mov	r4, r0
 8009bf8:	b940      	cbnz	r0, 8009c0c <SFU_BOOT_SM_InstallKMSBlob+0x48>
      e_status = C_STM_ImportBlob(pBlobHdr, pBlobInFlash);
 8009bfa:	e9dd 0100 	ldrd	r0, r1, [sp]
 8009bfe:	f7ff fbe9 	bl	80093d4 <SE_KMS_ImportBlob>
      if (e_status != CKR_OK)
 8009c02:	4604      	mov	r4, r0
 8009c04:	b130      	cbz	r0, 8009c14 <SFU_BOOT_SM_InstallKMSBlob+0x50>
        (void)C_Finalize(NULL);
 8009c06:	2000      	movs	r0, #0
 8009c08:	f7ff f80a 	bl	8008c20 <SE_KMS_Finalize>
      TRACE("\r\n= [SBOOT] INSTALL KMS: ERROR WHEN COMMUNICATING WITH KMS");
 8009c0c:	4817      	ldr	r0, [pc, #92]	; (8009c6c <SFU_BOOT_SM_InstallKMSBlob+0xa8>)
 8009c0e:	f005 f873 	bl	800ecf8 <iprintf>
 8009c12:	e004      	b.n	8009c1e <SFU_BOOT_SM_InstallKMSBlob+0x5a>
        e_status = C_Finalize(NULL);
 8009c14:	f7ff f804 	bl	8008c20 <SE_KMS_Finalize>
    if (e_status != CKR_OK)
 8009c18:	4604      	mov	r4, r0
 8009c1a:	2800      	cmp	r0, #0
 8009c1c:	d1f6      	bne.n	8009c0c <SFU_BOOT_SM_InstallKMSBlob+0x48>
    e_ret_status = SFU_KMS_EraseBlob();
 8009c1e:	f002 fb59 	bl	800c2d4 <SFU_KMS_EraseBlob>
    if (e_ret_status != SFU_SUCCESS)
 8009c22:	4b0f      	ldr	r3, [pc, #60]	; (8009c60 <SFU_BOOT_SM_InstallKMSBlob+0x9c>)
 8009c24:	4298      	cmp	r0, r3
 8009c26:	d002      	beq.n	8009c2e <SFU_BOOT_SM_InstallKMSBlob+0x6a>
      TRACE("\r\n= [SBOOT] INSTALL KMS: ERROR WHEN ERASING KMS BLOB");
 8009c28:	4811      	ldr	r0, [pc, #68]	; (8009c70 <SFU_BOOT_SM_InstallKMSBlob+0xac>)
 8009c2a:	f005 f865 	bl	800ecf8 <iprintf>
    switch (e_status)
 8009c2e:	2c30      	cmp	r4, #48	; 0x30
 8009c30:	d00f      	beq.n	8009c52 <SFU_BOOT_SM_InstallKMSBlob+0x8e>
 8009c32:	d804      	bhi.n	8009c3e <SFU_BOOT_SM_InstallKMSBlob+0x7a>
 8009c34:	b14c      	cbz	r4, 8009c4a <SFU_BOOT_SM_InstallKMSBlob+0x86>
 8009c36:	2c20      	cmp	r4, #32
 8009c38:	d009      	beq.n	8009c4e <SFU_BOOT_SM_InstallKMSBlob+0x8a>
        TRACE("\r\n= [SBOOT] INSTALL KMS: UNKNOWN STATUS");
 8009c3a:	480e      	ldr	r0, [pc, #56]	; (8009c74 <SFU_BOOT_SM_InstallKMSBlob+0xb0>)
 8009c3c:	e7ce      	b.n	8009bdc <SFU_BOOT_SM_InstallKMSBlob+0x18>
    switch (e_status)
 8009c3e:	2c90      	cmp	r4, #144	; 0x90
 8009c40:	d009      	beq.n	8009c56 <SFU_BOOT_SM_InstallKMSBlob+0x92>
 8009c42:	2cc0      	cmp	r4, #192	; 0xc0
 8009c44:	d1f9      	bne.n	8009c3a <SFU_BOOT_SM_InstallKMSBlob+0x76>
        TRACE("\r\n= [SBOOT] INSTALL KMS: BLOB AUTHENT ERROR WHEN INSTALLING KMS BLOB");
 8009c46:	480c      	ldr	r0, [pc, #48]	; (8009c78 <SFU_BOOT_SM_InstallKMSBlob+0xb4>)
 8009c48:	e7c8      	b.n	8009bdc <SFU_BOOT_SM_InstallKMSBlob+0x18>
        TRACE("\r\n= [SBOOT] INSTALL KMS: KMS BLOB WELL INSTALLED");
 8009c4a:	480c      	ldr	r0, [pc, #48]	; (8009c7c <SFU_BOOT_SM_InstallKMSBlob+0xb8>)
 8009c4c:	e7c6      	b.n	8009bdc <SFU_BOOT_SM_InstallKMSBlob+0x18>
        TRACE("\r\n= [SBOOT] INSTALL KMS: BLOB FORM ERROR WHEN INSTALLING KMS BLOB");
 8009c4e:	480c      	ldr	r0, [pc, #48]	; (8009c80 <SFU_BOOT_SM_InstallKMSBlob+0xbc>)
 8009c50:	e7c4      	b.n	8009bdc <SFU_BOOT_SM_InstallKMSBlob+0x18>
        TRACE("\r\n= [SBOOT] INSTALL KMS: NVM ERROR WHEN INSTALLING KMS BLOB");
 8009c52:	480c      	ldr	r0, [pc, #48]	; (8009c84 <SFU_BOOT_SM_InstallKMSBlob+0xc0>)
 8009c54:	e7c2      	b.n	8009bdc <SFU_BOOT_SM_InstallKMSBlob+0x18>
        TRACE("\r\n= [SBOOT] INSTALL KMS: KMS KEYS IN USE WHEN INSTALLING KMS BLOB");
 8009c56:	480c      	ldr	r0, [pc, #48]	; (8009c88 <SFU_BOOT_SM_InstallKMSBlob+0xc4>)
 8009c58:	e7c0      	b.n	8009bdc <SFU_BOOT_SM_InstallKMSBlob+0x18>
 8009c5a:	bf00      	nop
 8009c5c:	0801048f 	.word	0x0801048f
 8009c60:	00122f11 	.word	0x00122f11
 8009c64:	080104b3 	.word	0x080104b3
 8009c68:	200034ac 	.word	0x200034ac
 8009c6c:	080104f0 	.word	0x080104f0
 8009c70:	0801052b 	.word	0x0801052b
 8009c74:	08010696 	.word	0x08010696
 8009c78:	08010591 	.word	0x08010591
 8009c7c:	08010560 	.word	0x08010560
 8009c80:	080105d6 	.word	0x080105d6
 8009c84:	08010618 	.word	0x08010618
 8009c88:	08010654 	.word	0x08010654

08009c8c <SFU_BOOT_SM_CheckKMSBlobToInstall>:
{
 8009c8c:	b508      	push	{r3, lr}
  TRACE("\r\n= [SBOOT] STATE: CHECK KMS BLOB TO INSTALL");
 8009c8e:	480b      	ldr	r0, [pc, #44]	; (8009cbc <SFU_BOOT_SM_CheckKMSBlobToInstall+0x30>)
 8009c90:	f005 f832 	bl	800ecf8 <iprintf>
  e_PendingInstallStatus = SFU_KMS_CheckPendingBlobInstallation();
 8009c94:	f002 fb36 	bl	800c304 <SFU_KMS_CheckPendingBlobInstallation>
  if (SFU_KMS_NO_BLOBUPDATE != e_PendingInstallStatus)
 8009c98:	4909      	ldr	r1, [pc, #36]	; (8009cc0 <SFU_BOOT_SM_CheckKMSBlobToInstall+0x34>)
    e_ret_status = SFU_SUCCESS;
 8009c9a:	f641 73e1 	movw	r3, #8161	; 0x1fe1
 8009c9e:	2801      	cmp	r0, #1
 8009ca0:	bf0c      	ite	eq
 8009ca2:	4618      	moveq	r0, r3
 8009ca4:	4608      	movne	r0, r1
  SFU_SET_SM_IF_CURR_STATE(e_ret_status, SFU_STATE_INSTALL_KMS_BLOB, SFU_STATE_VERIFY_USER_FW_STATUS);
 8009ca6:	4b07      	ldr	r3, [pc, #28]	; (8009cc4 <SFU_BOOT_SM_CheckKMSBlobToInstall+0x38>)
 8009ca8:	785a      	ldrb	r2, [r3, #1]
 8009caa:	4288      	cmp	r0, r1
 8009cac:	b2d2      	uxtb	r2, r2
 8009cae:	701a      	strb	r2, [r3, #0]
 8009cb0:	bf0c      	ite	eq
 8009cb2:	2204      	moveq	r2, #4
 8009cb4:	2205      	movne	r2, #5
 8009cb6:	705a      	strb	r2, [r3, #1]
}
 8009cb8:	bd08      	pop	{r3, pc}
 8009cba:	bf00      	nop
 8009cbc:	080106be 	.word	0x080106be
 8009cc0:	00122f11 	.word	0x00122f11
 8009cc4:	200034ac 	.word	0x200034ac

08009cc8 <SFU_BOOT_SM_DownloadNewUserFw>:
{
 8009cc8:	b530      	push	{r4, r5, lr}
 8009cca:	b085      	sub	sp, #20
  SFU_LOADER_StatusTypeDef  e_ret_status_app = SFU_LOADER_ERR_COM;
 8009ccc:	2301      	movs	r3, #1
 8009cce:	f88d 3007 	strb.w	r3, [sp, #7]
  TRACE("\r\n= [SBOOT] STATE: DOWNLOAD NEW USER FIRMWARE");
 8009cd2:	4825      	ldr	r0, [pc, #148]	; (8009d68 <SFU_BOOT_SM_DownloadNewUserFw+0xa0>)
  if (e_ret_status == SFU_SUCCESS)
 8009cd4:	4d25      	ldr	r5, [pc, #148]	; (8009d6c <SFU_BOOT_SM_DownloadNewUserFw+0xa4>)
  uint32_t                  u_size = 0;
 8009cd6:	2300      	movs	r3, #0
 8009cd8:	9303      	str	r3, [sp, #12]
  TRACE("\r\n= [SBOOT] STATE: DOWNLOAD NEW USER FIRMWARE");
 8009cda:	f005 f80d 	bl	800ecf8 <iprintf>
  e_ret_status = SFU_LOADER_DownloadNewUserFw(&e_ret_status_app, &dwl_slot, &u_size);
 8009cde:	aa03      	add	r2, sp, #12
 8009ce0:	a902      	add	r1, sp, #8
 8009ce2:	f10d 0007 	add.w	r0, sp, #7
 8009ce6:	f002 fbf5 	bl	800c4d4 <SFU_LOADER_DownloadNewUserFw>
  if (e_ret_status == SFU_SUCCESS)
 8009cea:	42a8      	cmp	r0, r5
  e_ret_status = SFU_LOADER_DownloadNewUserFw(&e_ret_status_app, &dwl_slot, &u_size);
 8009cec:	4604      	mov	r4, r0
  if (e_ret_status == SFU_SUCCESS)
 8009cee:	d11f      	bne.n	8009d30 <SFU_BOOT_SM_DownloadNewUserFw+0x68>
    e_ret_status = SFU_LL_FLASH_Read((uint8_t *) &fw_image_header_validated, (uint8_t *) SlotStartAdd[dwl_slot],
 8009cf0:	4b1f      	ldr	r3, [pc, #124]	; (8009d70 <SFU_BOOT_SM_DownloadNewUserFw+0xa8>)
 8009cf2:	9902      	ldr	r1, [sp, #8]
 8009cf4:	481f      	ldr	r0, [pc, #124]	; (8009d74 <SFU_BOOT_SM_DownloadNewUserFw+0xac>)
 8009cf6:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 8009cfa:	f44f 72a0 	mov.w	r2, #320	; 0x140
 8009cfe:	f002 fe89 	bl	800ca14 <SFU_LL_FLASH_Read>
  if (e_ret_status == SFU_SUCCESS)
 8009d02:	42a8      	cmp	r0, r5
    e_ret_status = SFU_LL_FLASH_Read((uint8_t *) &fw_image_header_validated, (uint8_t *) SlotStartAdd[dwl_slot],
 8009d04:	4604      	mov	r4, r0
  if (e_ret_status == SFU_SUCCESS)
 8009d06:	d113      	bne.n	8009d30 <SFU_BOOT_SM_DownloadNewUserFw+0x68>
    if (SFU_IMG_InstallAtNextReset((uint8_t *) &fw_image_header_validated) != SFU_SUCCESS)
 8009d08:	481a      	ldr	r0, [pc, #104]	; (8009d74 <SFU_BOOT_SM_DownloadNewUserFw+0xac>)
 8009d0a:	f002 fd3f 	bl	800c78c <SFU_IMG_InstallAtNextReset>
 8009d0e:	42a0      	cmp	r0, r4
 8009d10:	d002      	beq.n	8009d18 <SFU_BOOT_SM_DownloadNewUserFw+0x50>
      (void) SFU_IMG_EraseDownloadedImg(dwl_slot);
 8009d12:	9802      	ldr	r0, [sp, #8]
 8009d14:	f001 ffac 	bl	800bc70 <SFU_IMG_EraseDownloadedImg>
  SFU_SET_SM_IF_CURR_STATE(e_ret_status, SFU_STATE_REBOOT_STATE_MACHINE, SFU_STATE_HANDLE_CRITICAL_FAILURE);
 8009d18:	4b17      	ldr	r3, [pc, #92]	; (8009d78 <SFU_BOOT_SM_DownloadNewUserFw+0xb0>)
 8009d1a:	785a      	ldrb	r2, [r3, #1]
 8009d1c:	b2d2      	uxtb	r2, r2
 8009d1e:	701a      	strb	r2, [r3, #0]
 8009d20:	4a12      	ldr	r2, [pc, #72]	; (8009d6c <SFU_BOOT_SM_DownloadNewUserFw+0xa4>)
 8009d22:	4294      	cmp	r4, r2
 8009d24:	bf0c      	ite	eq
 8009d26:	220c      	moveq	r2, #12
 8009d28:	220b      	movne	r2, #11
 8009d2a:	705a      	strb	r2, [r3, #1]
}
 8009d2c:	b005      	add	sp, #20
 8009d2e:	bd30      	pop	{r4, r5, pc}
    (void) SFU_IMG_EraseDownloadedImg(dwl_slot);
 8009d30:	9802      	ldr	r0, [sp, #8]
 8009d32:	f001 ff9d 	bl	800bc70 <SFU_IMG_EraseDownloadedImg>
    switch (e_ret_status_app)
 8009d36:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8009d3a:	3b01      	subs	r3, #1
 8009d3c:	2b05      	cmp	r3, #5
 8009d3e:	d8eb      	bhi.n	8009d18 <SFU_BOOT_SM_DownloadNewUserFw+0x50>
 8009d40:	e8df f003 	tbb	[pc, r3]
 8009d44:	07090b03 	.word	0x07090b03
 8009d48:	0f0d      	.short	0x0f0d
        SFU_EXCPT_SetError(SFU_EXCPT_COM_ERR);
 8009d4a:	2006      	movs	r0, #6
        SFU_EXCPT_SetError(SFU_EXCPT_DECRYPT_ERR);
 8009d4c:	f000 fc8c 	bl	800a668 <SFU_EXCPT_SetError>
        break;
 8009d50:	e7e2      	b.n	8009d18 <SFU_BOOT_SM_DownloadNewUserFw+0x50>
        SFU_EXCPT_SetError(SFU_EXCPT_VERSION_ERR);
 8009d52:	2017      	movs	r0, #23
 8009d54:	e7fa      	b.n	8009d4c <SFU_BOOT_SM_DownloadNewUserFw+0x84>
        SFU_EXCPT_SetError(SFU_EXCPT_FW_TOO_BIG);
 8009d56:	2005      	movs	r0, #5
 8009d58:	e7f8      	b.n	8009d4c <SFU_BOOT_SM_DownloadNewUserFw+0x84>
        SFU_EXCPT_SetError(SFU_EXCPT_HEADER_AUTH_ERR);
 8009d5a:	2007      	movs	r0, #7
 8009d5c:	e7f6      	b.n	8009d4c <SFU_BOOT_SM_DownloadNewUserFw+0x84>
        SFU_EXCPT_SetError(SFU_EXCPT_FLASH_ERR);
 8009d5e:	200a      	movs	r0, #10
 8009d60:	e7f4      	b.n	8009d4c <SFU_BOOT_SM_DownloadNewUserFw+0x84>
        SFU_EXCPT_SetError(SFU_EXCPT_DECRYPT_ERR);
 8009d62:	2008      	movs	r0, #8
 8009d64:	e7f2      	b.n	8009d4c <SFU_BOOT_SM_DownloadNewUserFw+0x84>
 8009d66:	bf00      	nop
 8009d68:	080106eb 	.word	0x080106eb
 8009d6c:	00122f11 	.word	0x00122f11
 8009d70:	08010f28 	.word	0x08010f28
 8009d74:	20003db4 	.word	0x20003db4
 8009d78:	200034ac 	.word	0x200034ac

08009d7c <SFU_BOOT_SM_CheckStatusOnReset>:
{
 8009d7c:	b507      	push	{r0, r1, r2, lr}
  TRACE("\r\n= [SBOOT] STATE: CHECK STATUS ON RESET");
 8009d7e:	4817      	ldr	r0, [pc, #92]	; (8009ddc <SFU_BOOT_SM_CheckStatusOnReset+0x60>)
 8009d80:	f004 ffba 	bl	800ecf8 <iprintf>
  * @param  None
  * @retval None
  */
static void SFU_BOOT_ManageResetSources(void)
{
  SFU_RESET_IdTypeDef e_wakeup_source_id = SFU_RESET_UNKNOWN;
 8009d84:	2300      	movs	r3, #0

  /* Check the wakeup sources */
  SFU_LL_SECU_GetResetSources(&e_wakeup_source_id);
 8009d86:	f10d 0007 	add.w	r0, sp, #7
  SFU_RESET_IdTypeDef e_wakeup_source_id = SFU_RESET_UNKNOWN;
 8009d8a:	f88d 3007 	strb.w	r3, [sp, #7]
  SFU_LL_SECU_GetResetSources(&e_wakeup_source_id);
 8009d8e:	f003 f845 	bl	800ce1c <SFU_LL_SECU_GetResetSources>
  switch (e_wakeup_source_id)
 8009d92:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8009d96:	3b01      	subs	r3, #1
 8009d98:	2b05      	cmp	r3, #5
 8009d9a:	d81c      	bhi.n	8009dd6 <SFU_BOOT_SM_CheckStatusOnReset+0x5a>
 8009d9c:	e8df f003 	tbb	[pc, r3]
 8009da0:	15131103 	.word	0x15131103
 8009da4:	1917      	.short	0x1917
     * Please note that the example of reset causes handling below is only a basic example to illustrate the way the
     * RCC_CSR flags can be used to do so.
     */

    case SFU_RESET_WDG_RESET:
      TRACE("\r\n\t  WARNING: A Reboot has been triggered by a Watchdog reset!");
 8009da6:	480e      	ldr	r0, [pc, #56]	; (8009de0 <SFU_BOOT_SM_CheckStatusOnReset+0x64>)
         ...
      */
      break;

    default:
      TRACE("\r\n\t  WARNING: A Reboot has been triggered by an Unknown reset source!");
 8009da8:	f004 ffa6 	bl	800ecf8 <iprintf>
      */
      break;
  }

  /* Once the reset sources has been managed and a possible error has been set, clear the reset sources */
  SFU_LL_SECU_ClearResetSources();
 8009dac:	f003 f85c 	bl	800ce68 <SFU_LL_SECU_ClearResetSources>
  SFU_SET_SM_CURR_STATE(SFU_STATE_CHECK_NEW_FW_TO_DOWNLOAD);
 8009db0:	4b0c      	ldr	r3, [pc, #48]	; (8009de4 <SFU_BOOT_SM_CheckStatusOnReset+0x68>)
 8009db2:	785a      	ldrb	r2, [r3, #1]
 8009db4:	b2d2      	uxtb	r2, r2
 8009db6:	701a      	strb	r2, [r3, #0]
 8009db8:	2201      	movs	r2, #1
 8009dba:	705a      	strb	r2, [r3, #1]
}
 8009dbc:	b003      	add	sp, #12
 8009dbe:	f85d fb04 	ldr.w	pc, [sp], #4
      TRACE("\r\n\t  INFO: A Reboot has been triggered by a LowPower reset!");
 8009dc2:	4809      	ldr	r0, [pc, #36]	; (8009de8 <SFU_BOOT_SM_CheckStatusOnReset+0x6c>)
 8009dc4:	e7f0      	b.n	8009da8 <SFU_BOOT_SM_CheckStatusOnReset+0x2c>
      TRACE("\r\n\t  INFO: A Reboot has been triggered by a Hardware reset!");
 8009dc6:	4809      	ldr	r0, [pc, #36]	; (8009dec <SFU_BOOT_SM_CheckStatusOnReset+0x70>)
 8009dc8:	e7ee      	b.n	8009da8 <SFU_BOOT_SM_CheckStatusOnReset+0x2c>
      TRACE("\r\n\t  INFO: A Reboot has been triggered by a BOR reset!");
 8009dca:	4809      	ldr	r0, [pc, #36]	; (8009df0 <SFU_BOOT_SM_CheckStatusOnReset+0x74>)
 8009dcc:	e7ec      	b.n	8009da8 <SFU_BOOT_SM_CheckStatusOnReset+0x2c>
      TRACE("\r\n\t  INFO: A Reboot has been triggered by a Software reset!");
 8009dce:	4809      	ldr	r0, [pc, #36]	; (8009df4 <SFU_BOOT_SM_CheckStatusOnReset+0x78>)
 8009dd0:	e7ea      	b.n	8009da8 <SFU_BOOT_SM_CheckStatusOnReset+0x2c>
      TRACE("\r\n\t  WARNING: A Reboot has been triggered by an Option Bytes reload!");
 8009dd2:	4809      	ldr	r0, [pc, #36]	; (8009df8 <SFU_BOOT_SM_CheckStatusOnReset+0x7c>)
 8009dd4:	e7e8      	b.n	8009da8 <SFU_BOOT_SM_CheckStatusOnReset+0x2c>
      TRACE("\r\n\t  WARNING: A Reboot has been triggered by an Unknown reset source!");
 8009dd6:	4809      	ldr	r0, [pc, #36]	; (8009dfc <SFU_BOOT_SM_CheckStatusOnReset+0x80>)
 8009dd8:	e7e6      	b.n	8009da8 <SFU_BOOT_SM_CheckStatusOnReset+0x2c>
 8009dda:	bf00      	nop
 8009ddc:	08010719 	.word	0x08010719
 8009de0:	08010742 	.word	0x08010742
 8009de4:	200034ac 	.word	0x200034ac
 8009de8:	08010781 	.word	0x08010781
 8009dec:	080107bd 	.word	0x080107bd
 8009df0:	080107f9 	.word	0x080107f9
 8009df4:	08010830 	.word	0x08010830
 8009df8:	0801086c 	.word	0x0801086c
 8009dfc:	080108b1 	.word	0x080108b1

08009e00 <SFU_BOOT_DeInit>:
{
 8009e00:	b538      	push	{r3, r4, r5, lr}
  if (SFU_EXCPT_DeInit() != SFU_SUCCESS)
 8009e02:	f000 fc83 	bl	800a70c <SFU_EXCPT_DeInit>
 8009e06:	4b0a      	ldr	r3, [pc, #40]	; (8009e30 <SFU_BOOT_DeInit+0x30>)
 8009e08:	4298      	cmp	r0, r3
 8009e0a:	4604      	mov	r4, r0
 8009e0c:	d10d      	bne.n	8009e2a <SFU_BOOT_DeInit+0x2a>
  if (SFU_LOADER_DeInit() != SFU_SUCCESS)
 8009e0e:	f002 fb5d 	bl	800c4cc <SFU_LOADER_DeInit>
 8009e12:	42a0      	cmp	r0, r4
 8009e14:	4605      	mov	r5, r0
 8009e16:	d108      	bne.n	8009e2a <SFU_BOOT_DeInit+0x2a>
  if (SFU_COM_DeInit() != SFU_SUCCESS)
 8009e18:	f000 fc0a 	bl	800a630 <SFU_COM_DeInit>
 8009e1c:	42a8      	cmp	r0, r5
 8009e1e:	4604      	mov	r4, r0
 8009e20:	d103      	bne.n	8009e2a <SFU_BOOT_DeInit+0x2a>
  if (SFU_LL_DeInit() != SFU_SUCCESS)
 8009e22:	f002 fced 	bl	800c800 <SFU_LL_DeInit>
 8009e26:	42a0      	cmp	r0, r4
 8009e28:	d001      	beq.n	8009e2e <SFU_BOOT_DeInit+0x2e>
    return SFU_ERROR;
 8009e2a:	f641 70e1 	movw	r0, #8161	; 0x1fe1
}
 8009e2e:	bd38      	pop	{r3, r4, r5, pc}
 8009e30:	00122f11 	.word	0x00122f11

08009e34 <SFU_BOOT_SM_VerifyUserFwSignature>:
{
 8009e34:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  FLOW_CONTROL_CHECK(uFlowProtectValue, FLOW_CTRL_RUNTIME_PROTECT);
 8009e36:	4d35      	ldr	r5, [pc, #212]	; (8009f0c <SFU_BOOT_SM_VerifyUserFwSignature+0xd8>)
  TRACE("\r\n= [SBOOT] STATE: VERIFY USER FW SIGNATURE");
 8009e38:	4835      	ldr	r0, [pc, #212]	; (8009f10 <SFU_BOOT_SM_VerifyUserFwSignature+0xdc>)
 8009e3a:	f004 ff5d 	bl	800ecf8 <iprintf>
  FLOW_CONTROL_CHECK(uFlowProtectValue, FLOW_CTRL_RUNTIME_PROTECT);
 8009e3e:	682a      	ldr	r2, [r5, #0]
 8009e40:	f243 03f1 	movw	r3, #12529	; 0x30f1
 8009e44:	429a      	cmp	r2, r3
 8009e46:	d001      	beq.n	8009e4c <SFU_BOOT_SM_VerifyUserFwSignature+0x18>
 8009e48:	f000 fc40 	bl	800a6cc <SFU_EXCPT_Security_Error>
  FLOW_CONTROL_INIT(uFlowProtectValue, FLOW_CTRL_INIT_VALUE);
 8009e4c:	f245 7376 	movw	r3, #22390	; 0x5776
 8009e50:	602b      	str	r3, [r5, #0]
  e_ret_status = SFU_LL_SECU_CheckApplyStaticProtections();
 8009e52:	f002 ff79 	bl	800cd48 <SFU_LL_SECU_CheckApplyStaticProtections>
  FLOW_CONTROL_CHECK(uFlowProtectValue, FLOW_CTRL_STATIC_PROTECT);
 8009e56:	682a      	ldr	r2, [r5, #0]
 8009e58:	f243 03f1 	movw	r3, #12529	; 0x30f1
 8009e5c:	429a      	cmp	r2, r3
  e_ret_status = SFU_LL_SECU_CheckApplyStaticProtections();
 8009e5e:	4604      	mov	r4, r0
  FLOW_CONTROL_CHECK(uFlowProtectValue, FLOW_CTRL_STATIC_PROTECT);
 8009e60:	d001      	beq.n	8009e66 <SFU_BOOT_SM_VerifyUserFwSignature+0x32>
 8009e62:	f000 fc33 	bl	800a6cc <SFU_EXCPT_Security_Error>
  if (e_ret_status == SFU_SUCCESS)
 8009e66:	4b2b      	ldr	r3, [pc, #172]	; (8009f14 <SFU_BOOT_SM_VerifyUserFwSignature+0xe0>)
 8009e68:	429c      	cmp	r4, r3
 8009e6a:	d103      	bne.n	8009e74 <SFU_BOOT_SM_VerifyUserFwSignature+0x40>
    e_ret_status = SFU_LL_SECU_CheckApplyRuntimeProtections(SFU_THIRD_CONFIGURATION);
 8009e6c:	2002      	movs	r0, #2
 8009e6e:	f002 ffd1 	bl	800ce14 <SFU_LL_SECU_CheckApplyRuntimeProtections>
 8009e72:	4604      	mov	r4, r0
  FLOW_CONTROL_CHECK(uFlowProtectValue, FLOW_CTRL_RUNTIME_PROTECT);
 8009e74:	682a      	ldr	r2, [r5, #0]
 8009e76:	f243 03f1 	movw	r3, #12529	; 0x30f1
 8009e7a:	429a      	cmp	r2, r3
 8009e7c:	d001      	beq.n	8009e82 <SFU_BOOT_SM_VerifyUserFwSignature+0x4e>
 8009e7e:	f000 fc25 	bl	800a6cc <SFU_EXCPT_Security_Error>
  if (e_ret_status != SFU_SUCCESS)
 8009e82:	4b24      	ldr	r3, [pc, #144]	; (8009f14 <SFU_BOOT_SM_VerifyUserFwSignature+0xe0>)
 8009e84:	4e24      	ldr	r6, [pc, #144]	; (8009f18 <SFU_BOOT_SM_VerifyUserFwSignature+0xe4>)
 8009e86:	429c      	cmp	r4, r3
 8009e88:	d015      	beq.n	8009eb6 <SFU_BOOT_SM_VerifyUserFwSignature+0x82>
    SFU_SET_SM_CURR_STATE(SFU_STATE_HANDLE_CRITICAL_FAILURE);
 8009e8a:	7873      	ldrb	r3, [r6, #1]
 8009e8c:	b2db      	uxtb	r3, r3
 8009e8e:	7033      	strb	r3, [r6, #0]
  SFU_SET_SM_IF_CURR_STATE(e_ret_status, SFU_STATE_EXECUTE_USER_FW, SFU_STATE_HANDLE_CRITICAL_FAILURE);
 8009e90:	230b      	movs	r3, #11
 8009e92:	e039      	b.n	8009f08 <SFU_BOOT_SM_VerifyUserFwSignature+0xd4>
          FLOW_CONTROL_CHECK(uFlowCryptoValue, FLOW_CTRL_INTEGRITY);
 8009e94:	683a      	ldr	r2, [r7, #0]
 8009e96:	f248 435a 	movw	r3, #33882	; 0x845a
 8009e9a:	429a      	cmp	r2, r3
 8009e9c:	d02d      	beq.n	8009efa <SFU_BOOT_SM_VerifyUserFwSignature+0xc6>
 8009e9e:	f000 fc15 	bl	800a6cc <SFU_EXCPT_Security_Error>
 8009ea2:	e02a      	b.n	8009efa <SFU_BOOT_SM_VerifyUserFwSignature+0xc6>
        if (SFU_IMG_VerifyEmptyActiveSlot(SLOT_ACTIVE_1 + i) != SFU_SUCCESS)
 8009ea4:	2001      	movs	r0, #1
 8009ea6:	f000 ff0d 	bl	800acc4 <SFU_IMG_VerifyEmptyActiveSlot>
 8009eaa:	42a0      	cmp	r0, r4
 8009eac:	d025      	beq.n	8009efa <SFU_BOOT_SM_VerifyUserFwSignature+0xc6>
          (void)SFU_IMG_InvalidateCurrentFirmware(SLOT_ACTIVE_1 + i); /* If this fails we continue anyhow */
 8009eae:	2001      	movs	r0, #1
 8009eb0:	f000 fece 	bl	800ac50 <SFU_IMG_InvalidateCurrentFirmware>
 8009eb4:	e021      	b.n	8009efa <SFU_BOOT_SM_VerifyUserFwSignature+0xc6>
    if (SlotStartAdd[SLOT_ACTIVE_1 + i] != 0U)
 8009eb6:	4b19      	ldr	r3, [pc, #100]	; (8009f1c <SFU_BOOT_SM_VerifyUserFwSignature+0xe8>)
 8009eb8:	685b      	ldr	r3, [r3, #4]
 8009eba:	b1f3      	cbz	r3, 8009efa <SFU_BOOT_SM_VerifyUserFwSignature+0xc6>
      if (SFU_SUCCESS == SFU_IMG_DetectFW(SLOT_ACTIVE_1 + i))
 8009ebc:	2001      	movs	r0, #1
 8009ebe:	f000 fff7 	bl	800aeb0 <SFU_IMG_DetectFW>
 8009ec2:	42a0      	cmp	r0, r4
 8009ec4:	d1ee      	bne.n	8009ea4 <SFU_BOOT_SM_VerifyUserFwSignature+0x70>
        FLOW_CONTROL_INIT(uFlowCryptoValue, FLOW_CTRL_INIT_VALUE);
 8009ec6:	4f16      	ldr	r7, [pc, #88]	; (8009f20 <SFU_BOOT_SM_VerifyUserFwSignature+0xec>)
 8009ec8:	f245 7376 	movw	r3, #22390	; 0x5776
        e_ret_status = SFU_IMG_VerifyActiveImgMetadata(SLOT_ACTIVE_1 + i);
 8009ecc:	2001      	movs	r0, #1
        FLOW_CONTROL_INIT(uFlowCryptoValue, FLOW_CTRL_INIT_VALUE);
 8009ece:	603b      	str	r3, [r7, #0]
        e_ret_status = SFU_IMG_VerifyActiveImgMetadata(SLOT_ACTIVE_1 + i);
 8009ed0:	f000 ffd8 	bl	800ae84 <SFU_IMG_VerifyActiveImgMetadata>
        if (SFU_SUCCESS == e_ret_status)
 8009ed4:	42a0      	cmp	r0, r4
        e_ret_status = SFU_IMG_VerifyActiveImgMetadata(SLOT_ACTIVE_1 + i);
 8009ed6:	4605      	mov	r5, r0
        if (SFU_SUCCESS == e_ret_status)
 8009ed8:	d10b      	bne.n	8009ef2 <SFU_BOOT_SM_VerifyUserFwSignature+0xbe>
          e_ret_status = SFU_IMG_VerifyActiveImg(SLOT_ACTIVE_1 + i);
 8009eda:	2001      	movs	r0, #1
 8009edc:	f000 fece 	bl	800ac7c <SFU_IMG_VerifyActiveImg>
          if (SFU_SUCCESS == e_ret_status)
 8009ee0:	42a0      	cmp	r0, r4
          e_ret_status = SFU_IMG_VerifyActiveImg(SLOT_ACTIVE_1 + i);
 8009ee2:	4605      	mov	r5, r0
          if (SFU_SUCCESS == e_ret_status)
 8009ee4:	d105      	bne.n	8009ef2 <SFU_BOOT_SM_VerifyUserFwSignature+0xbe>
            e_ret_status = SFU_IMG_VerifyActiveSlot(SLOT_ACTIVE_1 + i);
 8009ee6:	2001      	movs	r0, #1
 8009ee8:	f000 fed8 	bl	800ac9c <SFU_IMG_VerifyActiveSlot>
        if (SFU_SUCCESS != e_ret_status)
 8009eec:	42a0      	cmp	r0, r4
            e_ret_status = SFU_IMG_VerifyActiveSlot(SLOT_ACTIVE_1 + i);
 8009eee:	4605      	mov	r5, r0
        if (SFU_SUCCESS != e_ret_status)
 8009ef0:	d0d0      	beq.n	8009e94 <SFU_BOOT_SM_VerifyUserFwSignature+0x60>
          (void)SFU_IMG_InvalidateCurrentFirmware(SLOT_ACTIVE_1 + i); /* If this fails we continue anyhow */
 8009ef2:	2001      	movs	r0, #1
 8009ef4:	f000 feac 	bl	800ac50 <SFU_IMG_InvalidateCurrentFirmware>
 8009ef8:	462c      	mov	r4, r5
  SFU_SET_SM_IF_CURR_STATE(e_ret_status, SFU_STATE_EXECUTE_USER_FW, SFU_STATE_HANDLE_CRITICAL_FAILURE);
 8009efa:	7873      	ldrb	r3, [r6, #1]
 8009efc:	b2db      	uxtb	r3, r3
 8009efe:	7033      	strb	r3, [r6, #0]
 8009f00:	4b04      	ldr	r3, [pc, #16]	; (8009f14 <SFU_BOOT_SM_VerifyUserFwSignature+0xe0>)
 8009f02:	429c      	cmp	r4, r3
 8009f04:	d1c4      	bne.n	8009e90 <SFU_BOOT_SM_VerifyUserFwSignature+0x5c>
 8009f06:	2308      	movs	r3, #8
 8009f08:	7073      	strb	r3, [r6, #1]
}
 8009f0a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8009f0c:	20003404 	.word	0x20003404
 8009f10:	080108f7 	.word	0x080108f7
 8009f14:	00122f11 	.word	0x00122f11
 8009f18:	200034ac 	.word	0x200034ac
 8009f1c:	08010f28 	.word	0x08010f28
 8009f20:	20003400 	.word	0x20003400

08009f24 <SFU_BOOT_ForceReboot>:
{
 8009f24:	b508      	push	{r3, lr}
  TRACE("\r\n========= End of Execution ==========");
 8009f26:	4809      	ldr	r0, [pc, #36]	; (8009f4c <SFU_BOOT_ForceReboot+0x28>)
 8009f28:	f004 fee6 	bl	800ecf8 <iprintf>
  TRACE("\r\n\r\n\r\n");
 8009f2c:	4808      	ldr	r0, [pc, #32]	; (8009f50 <SFU_BOOT_ForceReboot+0x2c>)
 8009f2e:	f004 ff7d 	bl	800ee2c <puts>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8009f32:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8009f36:	4907      	ldr	r1, [pc, #28]	; (8009f54 <SFU_BOOT_ForceReboot+0x30>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8009f38:	4b07      	ldr	r3, [pc, #28]	; (8009f58 <SFU_BOOT_ForceReboot+0x34>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8009f3a:	68ca      	ldr	r2, [r1, #12]
 8009f3c:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8009f40:	4313      	orrs	r3, r2
 8009f42:	60cb      	str	r3, [r1, #12]
 8009f44:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 8009f48:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 8009f4a:	e7fd      	b.n	8009f48 <SFU_BOOT_ForceReboot+0x24>
 8009f4c:	08010923 	.word	0x08010923
 8009f50:	0801094b 	.word	0x0801094b
 8009f54:	e000ed00 	.word	0xe000ed00
 8009f58:	05fa0004 	.word	0x05fa0004

08009f5c <SFU_BOOT_RunSecureBootService>:
{
 8009f5c:	b573      	push	{r0, r1, r4, r5, r6, lr}
  if (SE_Startup() == SE_SUCCESS)
 8009f5e:	f7fe fc0d 	bl	800877c <SE_Startup>
 8009f62:	4d3e      	ldr	r5, [pc, #248]	; (800a05c <SFU_BOOT_RunSecureBootService+0x100>)
 8009f64:	42a8      	cmp	r0, r5
 8009f66:	d177      	bne.n	800a058 <SFU_BOOT_RunSecureBootService+0xfc>
  (void) SFU_COM_Init();
 8009f68:	f000 fb52 	bl	800a610 <SFU_COM_Init>
  if (SFU_LL_SECU_CheckApplyStaticProtections() == SFU_SUCCESS)
 8009f6c:	f002 feec 	bl	800cd48 <SFU_LL_SECU_CheckApplyStaticProtections>
 8009f70:	4b3b      	ldr	r3, [pc, #236]	; (800a060 <SFU_BOOT_RunSecureBootService+0x104>)
 8009f72:	4298      	cmp	r0, r3
 8009f74:	4604      	mov	r4, r0
 8009f76:	d005      	beq.n	8009f84 <SFU_BOOT_RunSecureBootService+0x28>
    TRACE("\r\n= [SBOOT] System Security Check failed! Rebooting...");
 8009f78:	483a      	ldr	r0, [pc, #232]	; (800a064 <SFU_BOOT_RunSecureBootService+0x108>)
 8009f7a:	f004 febd 	bl	800ecf8 <iprintf>
      e_ret_code = SFU_BOOT_SECIPS_CFG_FAIL;
 8009f7e:	2001      	movs	r0, #1
}
 8009f80:	b002      	add	sp, #8
 8009f82:	bd70      	pop	{r4, r5, r6, pc}
    e_ret_status = SFU_LL_SECU_CheckApplyRuntimeProtections(SFU_INITIAL_CONFIGURATION);
 8009f84:	2000      	movs	r0, #0
 8009f86:	f002 ff45 	bl	800ce14 <SFU_LL_SECU_CheckApplyRuntimeProtections>
  if (SFU_BOOT_CheckApplySecurityProtections() != SFU_SUCCESS)
 8009f8a:	42a0      	cmp	r0, r4
 8009f8c:	d1f4      	bne.n	8009f78 <SFU_BOOT_RunSecureBootService+0x1c>
    TRACE("\r\n= [SBOOT] System Security Check successfully passed. Starting...");
 8009f8e:	4836      	ldr	r0, [pc, #216]	; (800a068 <SFU_BOOT_RunSecureBootService+0x10c>)
 8009f90:	f004 feb2 	bl	800ecf8 <iprintf>
  (void) BSP_LED_Init(SFU_STATUS_LED);
 8009f94:	2001      	movs	r0, #1
 8009f96:	f003 f873 	bl	800d080 <BSP_LED_Init>
  BUTTON_INIT();
 8009f9a:	2100      	movs	r1, #0
 8009f9c:	4608      	mov	r0, r1
 8009f9e:	f003 f8b7 	bl	800d110 <BSP_PB_Init>
 8009fa2:	2000      	movs	r0, #0
 8009fa4:	f003 f90a 	bl	800d1bc <BSP_PB_GetState>
 8009fa8:	b910      	cbnz	r0, 8009fb0 <SFU_BOOT_RunSecureBootService+0x54>
 8009faa:	2006      	movs	r0, #6
 8009fac:	f003 f974 	bl	800d298 <HAL_Delay>
  initialDeviceStatusCheck = 1U;
 8009fb0:	4b2e      	ldr	r3, [pc, #184]	; (800a06c <SFU_BOOT_RunSecureBootService+0x110>)
 8009fb2:	2201      	movs	r2, #1
 8009fb4:	701a      	strb	r2, [r3, #0]
  if (SFU_LL_Init() != SFU_SUCCESS)
 8009fb6:	f002 fc65 	bl	800c884 <SFU_LL_Init>
 8009fba:	4b29      	ldr	r3, [pc, #164]	; (800a060 <SFU_BOOT_RunSecureBootService+0x104>)
 8009fbc:	4298      	cmp	r0, r3
 8009fbe:	4604      	mov	r4, r0
 8009fc0:	d135      	bne.n	800a02e <SFU_BOOT_RunSecureBootService+0xd2>
  if (SFU_LL_FLASH_Init() != SFU_SUCCESS)
 8009fc2:	f002 fd0b 	bl	800c9dc <SFU_LL_FLASH_Init>
 8009fc6:	42a0      	cmp	r0, r4
 8009fc8:	4606      	mov	r6, r0
 8009fca:	d130      	bne.n	800a02e <SFU_BOOT_RunSecureBootService+0xd2>
  if (SFU_COM_Init() != SFU_SUCCESS)
 8009fcc:	f000 fb20 	bl	800a610 <SFU_COM_Init>
 8009fd0:	42b0      	cmp	r0, r6
 8009fd2:	4604      	mov	r4, r0
 8009fd4:	d12b      	bne.n	800a02e <SFU_BOOT_RunSecureBootService+0xd2>
  if (SFU_LOADER_Init() != SFU_SUCCESS)
 8009fd6:	f002 fa75 	bl	800c4c4 <SFU_LOADER_Init>
 8009fda:	42a0      	cmp	r0, r4
 8009fdc:	4606      	mov	r6, r0
 8009fde:	d126      	bne.n	800a02e <SFU_BOOT_RunSecureBootService+0xd2>
  if (SFU_EXCPT_Init() != SFU_SUCCESS)
 8009fe0:	f000 fb90 	bl	800a704 <SFU_EXCPT_Init>
 8009fe4:	42b0      	cmp	r0, r6
 8009fe6:	4604      	mov	r4, r0
 8009fe8:	d121      	bne.n	800a02e <SFU_BOOT_RunSecureBootService+0xd2>
  if (SFU_IMG_InitImageHandling() != SFU_IMG_INIT_OK)
 8009fea:	f000 fd9f 	bl	800ab2c <SFU_IMG_InitImageHandling>
 8009fee:	b9f0      	cbnz	r0, 800a02e <SFU_BOOT_RunSecureBootService+0xd2>
  TRACE("\r\n\r\n");
 8009ff0:	481f      	ldr	r0, [pc, #124]	; (800a070 <SFU_BOOT_RunSecureBootService+0x114>)
 8009ff2:	f004 ff1b 	bl	800ee2c <puts>
  TRACE("\r\n======================================================================");
 8009ff6:	481f      	ldr	r0, [pc, #124]	; (800a074 <SFU_BOOT_RunSecureBootService+0x118>)
 8009ff8:	f004 fe7e 	bl	800ecf8 <iprintf>
  TRACE("\r\n=              (C) COPYRIGHT 2017 STMicroelectronics                 =");
 8009ffc:	481e      	ldr	r0, [pc, #120]	; (800a078 <SFU_BOOT_RunSecureBootService+0x11c>)
 8009ffe:	f004 fe7b 	bl	800ecf8 <iprintf>
  TRACE("\r\n=                                                                    =");
 800a002:	481e      	ldr	r0, [pc, #120]	; (800a07c <SFU_BOOT_RunSecureBootService+0x120>)
 800a004:	f004 fe78 	bl	800ecf8 <iprintf>
  TRACE("\r\n=              Secure Boot and Secure Firmware Update                =");
 800a008:	481d      	ldr	r0, [pc, #116]	; (800a080 <SFU_BOOT_RunSecureBootService+0x124>)
 800a00a:	f004 fe75 	bl	800ecf8 <iprintf>
  TRACE("\r\n======================================================================");
 800a00e:	4819      	ldr	r0, [pc, #100]	; (800a074 <SFU_BOOT_RunSecureBootService+0x118>)
 800a010:	f004 fe72 	bl	800ecf8 <iprintf>
  TRACE("\r\n\r\n");
 800a014:	4816      	ldr	r0, [pc, #88]	; (800a070 <SFU_BOOT_RunSecureBootService+0x114>)
 800a016:	f004 ff09 	bl	800ee2c <puts>
  if (SE_Init(&e_se_status, SystemCoreClock) != SE_SUCCESS)
 800a01a:	4b1a      	ldr	r3, [pc, #104]	; (800a084 <SFU_BOOT_RunSecureBootService+0x128>)
 800a01c:	a801      	add	r0, sp, #4
 800a01e:	6819      	ldr	r1, [r3, #0]
 800a020:	f7fe fb86 	bl	8008730 <SE_Init>
 800a024:	42a8      	cmp	r0, r5
 800a026:	d004      	beq.n	800a032 <SFU_BOOT_RunSecureBootService+0xd6>
    TRACE("\r\n= [SBOOT] SECURE ENGINE INITIALIZATION CRITICAL FAILURE!");
 800a028:	4817      	ldr	r0, [pc, #92]	; (800a088 <SFU_BOOT_RunSecureBootService+0x12c>)
 800a02a:	f004 fe65 	bl	800ecf8 <iprintf>
        e_ret_code = SFU_BOOT_INIT_FAIL;
 800a02e:	2002      	movs	r0, #2
 800a030:	e7a6      	b.n	8009f80 <SFU_BOOT_RunSecureBootService+0x24>
    TRACE("\r\n= [SBOOT] SECURE ENGINE INITIALIZATION SUCCESSFUL");
 800a032:	4816      	ldr	r0, [pc, #88]	; (800a08c <SFU_BOOT_RunSecureBootService+0x130>)
      fnStateMachineFunction = fnStateMachineTable[(uint8_t)m_StateMachineContext.CurrState];
 800a034:	4d16      	ldr	r5, [pc, #88]	; (800a090 <SFU_BOOT_RunSecureBootService+0x134>)
 800a036:	4e17      	ldr	r6, [pc, #92]	; (800a094 <SFU_BOOT_RunSecureBootService+0x138>)
    TRACE("\r\n= [SBOOT] SECURE ENGINE INITIALIZATION SUCCESSFUL");
 800a038:	f004 fe5e 	bl	800ecf8 <iprintf>
  e_ret_status = SFU_LL_SECU_IWDG_Refresh();
 800a03c:	f002 ff1e 	bl	800ce7c <SFU_LL_SECU_IWDG_Refresh>
    if (SFU_BOOT_SecuritySafetyCheck() == SFU_SUCCESS)
 800a040:	42a0      	cmp	r0, r4
 800a042:	d004      	beq.n	800a04e <SFU_BOOT_RunSecureBootService+0xf2>
  SFU_EXCPT_SetError(SFU_EXCPT_UNKNOWN);
 800a044:	2018      	movs	r0, #24
 800a046:	f000 fb0f 	bl	800a668 <SFU_EXCPT_SetError>
  SFU_BOOT_ForceReboot();
 800a04a:	f7ff ff6b 	bl	8009f24 <SFU_BOOT_ForceReboot>
      fnStateMachineFunction = fnStateMachineTable[(uint8_t)m_StateMachineContext.CurrState];
 800a04e:	786b      	ldrb	r3, [r5, #1]
      fnStateMachineFunction();
 800a050:	f856 3023 	ldr.w	r3, [r6, r3, lsl #2]
 800a054:	4798      	blx	r3
 800a056:	e7f1      	b.n	800a03c <SFU_BOOT_RunSecureBootService+0xe0>
    e_ret_code = SFU_BOOT_SECENG_INIT_FAIL;
 800a058:	2000      	movs	r0, #0
 800a05a:	e791      	b.n	8009f80 <SFU_BOOT_RunSecureBootService+0x24>
 800a05c:	0012310f 	.word	0x0012310f
 800a060:	00122f11 	.word	0x00122f11
 800a064:	08010951 	.word	0x08010951
 800a068:	08010988 	.word	0x08010988
 800a06c:	20003c68 	.word	0x20003c68
 800a070:	0801094d 	.word	0x0801094d
 800a074:	080109cb 	.word	0x080109cb
 800a078:	08010a14 	.word	0x08010a14
 800a07c:	08010a5d 	.word	0x08010a5d
 800a080:	08010aa6 	.word	0x08010aa6
 800a084:	2000340c 	.word	0x2000340c
 800a088:	08010aef 	.word	0x08010aef
 800a08c:	08010b2a 	.word	0x08010b2a
 800a090:	200034ac 	.word	0x200034ac
 800a094:	08010c1c 	.word	0x08010c1c

0800a098 <SFU_BOOT_SM_RebootStateMachine>:
{
 800a098:	b508      	push	{r3, lr}
  TRACE("\r\n= [SBOOT] STATE: REBOOT STATE MACHINE");
 800a09a:	4803      	ldr	r0, [pc, #12]	; (800a0a8 <SFU_BOOT_SM_RebootStateMachine+0x10>)
 800a09c:	f004 fe2c 	bl	800ecf8 <iprintf>
  (void)SFU_BOOT_DeInit();
 800a0a0:	f7ff feae 	bl	8009e00 <SFU_BOOT_DeInit>
  SFU_BOOT_ForceReboot();
 800a0a4:	f7ff ff3e 	bl	8009f24 <SFU_BOOT_ForceReboot>
 800a0a8:	08010b5e 	.word	0x08010b5e

0800a0ac <SFU_BOOT_SM_ResumeInstallNewUserFw>:
{
 800a0ac:	b508      	push	{r3, lr}
  TRACE("\r\n= [SBOOT] STATE: RESUME INSTALLATION OF NEW USER FIRMWARE");
 800a0ae:	480a      	ldr	r0, [pc, #40]	; (800a0d8 <SFU_BOOT_SM_ResumeInstallNewUserFw+0x2c>)
 800a0b0:	f004 fe22 	bl	800ecf8 <iprintf>
  e_ret_status = SFU_IMG_TriggerResumeInstallation(m_ActiveSlotToResume, m_DwlSlotToInstall);
 800a0b4:	4b09      	ldr	r3, [pc, #36]	; (800a0dc <SFU_BOOT_SM_ResumeInstallNewUserFw+0x30>)
 800a0b6:	6819      	ldr	r1, [r3, #0]
 800a0b8:	4b09      	ldr	r3, [pc, #36]	; (800a0e0 <SFU_BOOT_SM_ResumeInstallNewUserFw+0x34>)
 800a0ba:	6818      	ldr	r0, [r3, #0]
 800a0bc:	f001 ff10 	bl	800bee0 <SFU_IMG_TriggerResumeInstallation>
  if (SFU_SUCCESS == e_ret_status)
 800a0c0:	4b08      	ldr	r3, [pc, #32]	; (800a0e4 <SFU_BOOT_SM_ResumeInstallNewUserFw+0x38>)
 800a0c2:	4298      	cmp	r0, r3
 800a0c4:	d101      	bne.n	800a0ca <SFU_BOOT_SM_ResumeInstallNewUserFw+0x1e>
    SFU_BOOT_ForceReboot();
 800a0c6:	f7ff ff2d 	bl	8009f24 <SFU_BOOT_ForceReboot>
    SFU_SET_SM_CURR_STATE(SFU_STATE_HANDLE_CRITICAL_FAILURE);
 800a0ca:	4b07      	ldr	r3, [pc, #28]	; (800a0e8 <SFU_BOOT_SM_ResumeInstallNewUserFw+0x3c>)
 800a0cc:	785a      	ldrb	r2, [r3, #1]
 800a0ce:	b2d2      	uxtb	r2, r2
 800a0d0:	701a      	strb	r2, [r3, #0]
 800a0d2:	220b      	movs	r2, #11
 800a0d4:	705a      	strb	r2, [r3, #1]
}
 800a0d6:	bd08      	pop	{r3, pc}
 800a0d8:	08010b86 	.word	0x08010b86
 800a0dc:	200034a8 	.word	0x200034a8
 800a0e0:	200034a0 	.word	0x200034a0
 800a0e4:	00122f11 	.word	0x00122f11
 800a0e8:	200034ac 	.word	0x200034ac

0800a0ec <SFU_BOOT_SM_ExecuteUserFw>:
{
 800a0ec:	b573      	push	{r0, r1, r4, r5, r6, lr}
  FLOW_CONTROL_CHECK(uFlowCryptoValue, FLOW_CTRL_INTEGRITY);
 800a0ee:	4c2f      	ldr	r4, [pc, #188]	; (800a1ac <SFU_BOOT_SM_ExecuteUserFw+0xc0>)
  SE_StatusTypeDef e_se_status = SE_KO;
 800a0f0:	4b2f      	ldr	r3, [pc, #188]	; (800a1b0 <SFU_BOOT_SM_ExecuteUserFw+0xc4>)
  TRACE("\r\n= [SBOOT] STATE: EXECUTE USER FIRMWARE");
 800a0f2:	4830      	ldr	r0, [pc, #192]	; (800a1b4 <SFU_BOOT_SM_ExecuteUserFw+0xc8>)
  SE_StatusTypeDef e_se_status = SE_KO;
 800a0f4:	9301      	str	r3, [sp, #4]
  TRACE("\r\n= [SBOOT] STATE: EXECUTE USER FIRMWARE");
 800a0f6:	f004 fdff 	bl	800ecf8 <iprintf>
  (void) SFU_LL_SECU_IWDG_Refresh();
 800a0fa:	f002 febf 	bl	800ce7c <SFU_LL_SECU_IWDG_Refresh>
  FLOW_CONTROL_CHECK(uFlowCryptoValue, FLOW_CTRL_INTEGRITY);
 800a0fe:	6822      	ldr	r2, [r4, #0]
 800a100:	f248 435a 	movw	r3, #33882	; 0x845a
 800a104:	429a      	cmp	r2, r3
 800a106:	d001      	beq.n	800a10c <SFU_BOOT_SM_ExecuteUserFw+0x20>
 800a108:	f000 fae0 	bl	800a6cc <SFU_EXCPT_Security_Error>
    if (SlotStartAdd[SLOT_ACTIVE_1 + i] != 0U)
 800a10c:	4b2a      	ldr	r3, [pc, #168]	; (800a1b8 <SFU_BOOT_SM_ExecuteUserFw+0xcc>)
 800a10e:	685b      	ldr	r3, [r3, #4]
 800a110:	b133      	cbz	r3, 800a120 <SFU_BOOT_SM_ExecuteUserFw+0x34>
      if (SFU_SUCCESS == SFU_IMG_DetectFW(SLOT_ACTIVE_1 + i))
 800a112:	2001      	movs	r0, #1
 800a114:	f000 fecc 	bl	800aeb0 <SFU_IMG_DetectFW>
 800a118:	4b28      	ldr	r3, [pc, #160]	; (800a1bc <SFU_BOOT_SM_ExecuteUserFw+0xd0>)
 800a11a:	4298      	cmp	r0, r3
 800a11c:	4605      	mov	r5, r0
 800a11e:	d024      	beq.n	800a16a <SFU_BOOT_SM_ExecuteUserFw+0x7e>
  e_ret_status = SFU_LL_FLASH_Config_Exe(m_ActiveSlotToExecute);
 800a120:	4e27      	ldr	r6, [pc, #156]	; (800a1c0 <SFU_BOOT_SM_ExecuteUserFw+0xd4>)
 800a122:	6830      	ldr	r0, [r6, #0]
 800a124:	f002 fc84 	bl	800ca30 <SFU_LL_FLASH_Config_Exe>
  if (e_ret_status != SFU_SUCCESS)
 800a128:	4b24      	ldr	r3, [pc, #144]	; (800a1bc <SFU_BOOT_SM_ExecuteUserFw+0xd0>)
 800a12a:	4298      	cmp	r0, r3
 800a12c:	d137      	bne.n	800a19e <SFU_BOOT_SM_ExecuteUserFw+0xb2>
    if (SE_LockRestrictServices(&e_se_status) == SE_SUCCESS)
 800a12e:	a801      	add	r0, sp, #4
 800a130:	f7fe fb48 	bl	80087c4 <SE_LockRestrictServices>
 800a134:	4b23      	ldr	r3, [pc, #140]	; (800a1c4 <SFU_BOOT_SM_ExecuteUserFw+0xd8>)
 800a136:	4298      	cmp	r0, r3
 800a138:	4605      	mov	r5, r0
 800a13a:	d135      	bne.n	800a1a8 <SFU_BOOT_SM_ExecuteUserFw+0xbc>
      if (SE_LockRestrictServices(&e_se_status) == SE_SUCCESS)
 800a13c:	a801      	add	r0, sp, #4
 800a13e:	f7fe fb41 	bl	80087c4 <SE_LockRestrictServices>
 800a142:	42a8      	cmp	r0, r5
 800a144:	d130      	bne.n	800a1a8 <SFU_BOOT_SM_ExecuteUserFw+0xbc>
        (void)SFU_BOOT_DeInit(); /* the return value is not checked, we will always try launching the UserApp */
 800a146:	f7ff fe5b 	bl	8009e00 <SFU_BOOT_DeInit>
        FLOW_CONTROL_STEP(uFlowCryptoValue, FLOW_STEP_LOCK_SERVICE, FLOW_CTRL_LOCK_SERVICE);
 800a14a:	6822      	ldr	r2, [r4, #0]
 800a14c:	f482 4334 	eor.w	r3, r2, #46080	; 0xb400
 800a150:	f083 03ab 	eor.w	r3, r3, #171	; 0xab
 800a154:	6023      	str	r3, [r4, #0]
 800a156:	f248 435a 	movw	r3, #33882	; 0x845a
 800a15a:	429a      	cmp	r2, r3
 800a15c:	d001      	beq.n	800a162 <SFU_BOOT_SM_ExecuteUserFw+0x76>
 800a15e:	f000 fab5 	bl	800a6cc <SFU_EXCPT_Security_Error>
        e_ret_status = SFU_IMG_LaunchActiveImg(m_ActiveSlotToExecute);
 800a162:	6830      	ldr	r0, [r6, #0]
 800a164:	f000 fdde 	bl	800ad24 <SFU_IMG_LaunchActiveImg>
        while (1 == 1)
 800a168:	e7fe      	b.n	800a168 <SFU_BOOT_SM_ExecuteUserFw+0x7c>
        FLOW_CONTROL_INIT(uFlowCryptoValue, FLOW_CTRL_INIT_VALUE);
 800a16a:	f245 7376 	movw	r3, #22390	; 0x5776
        if (SFU_IMG_VerifyActiveImgMetadata(SLOT_ACTIVE_1 + i) != SFU_SUCCESS)
 800a16e:	2001      	movs	r0, #1
        FLOW_CONTROL_INIT(uFlowCryptoValue, FLOW_CTRL_INIT_VALUE);
 800a170:	6023      	str	r3, [r4, #0]
        if (SFU_IMG_VerifyActiveImgMetadata(SLOT_ACTIVE_1 + i) != SFU_SUCCESS)
 800a172:	f000 fe87 	bl	800ae84 <SFU_IMG_VerifyActiveImgMetadata>
 800a176:	42a8      	cmp	r0, r5
 800a178:	d001      	beq.n	800a17e <SFU_BOOT_SM_ExecuteUserFw+0x92>
          SFU_EXCPT_Security_Error();
 800a17a:	f000 faa7 	bl	800a6cc <SFU_EXCPT_Security_Error>
        if (SFU_IMG_ControlActiveImgTag(SLOT_ACTIVE_1 + i) != SFU_SUCCESS)
 800a17e:	2001      	movs	r0, #1
 800a180:	f000 fdb0 	bl	800ace4 <SFU_IMG_ControlActiveImgTag>
 800a184:	4b0d      	ldr	r3, [pc, #52]	; (800a1bc <SFU_BOOT_SM_ExecuteUserFw+0xd0>)
 800a186:	4298      	cmp	r0, r3
 800a188:	d001      	beq.n	800a18e <SFU_BOOT_SM_ExecuteUserFw+0xa2>
          SFU_EXCPT_Security_Error();
 800a18a:	f000 fa9f 	bl	800a6cc <SFU_EXCPT_Security_Error>
        FLOW_CONTROL_CHECK(uFlowCryptoValue, FLOW_CTRL_INTEGRITY);
 800a18e:	6822      	ldr	r2, [r4, #0]
 800a190:	f248 435a 	movw	r3, #33882	; 0x845a
 800a194:	429a      	cmp	r2, r3
 800a196:	d0c3      	beq.n	800a120 <SFU_BOOT_SM_ExecuteUserFw+0x34>
 800a198:	f000 fa98 	bl	800a6cc <SFU_EXCPT_Security_Error>
  for (i = 0U; i < SFU_NB_MAX_ACTIVE_IMAGE; i++)
 800a19c:	e7c0      	b.n	800a120 <SFU_BOOT_SM_ExecuteUserFw+0x34>
    SFU_EXCPT_SetError(SFU_EXCPT_FLASH_CFG_ERR);
 800a19e:	200b      	movs	r0, #11
        SFU_EXCPT_SetError(SFU_EXCPT_LOCK_SE_SERVICES_ERR);
 800a1a0:	f000 fa62 	bl	800a668 <SFU_EXCPT_SetError>
        SFU_BOOT_ForceReboot();
 800a1a4:	f7ff febe 	bl	8009f24 <SFU_BOOT_ForceReboot>
        SFU_EXCPT_SetError(SFU_EXCPT_LOCK_SE_SERVICES_ERR);
 800a1a8:	2004      	movs	r0, #4
 800a1aa:	e7f9      	b.n	800a1a0 <SFU_BOOT_SM_ExecuteUserFw+0xb4>
 800a1ac:	20003400 	.word	0x20003400
 800a1b0:	0013023d 	.word	0x0013023d
 800a1b4:	08010bc2 	.word	0x08010bc2
 800a1b8:	08010f28 	.word	0x08010f28
 800a1bc:	00122f11 	.word	0x00122f11
 800a1c0:	2000349c 	.word	0x2000349c
 800a1c4:	0012310f 	.word	0x0012310f

0800a1c8 <SFU_BOOT_SM_InstallNewUserFw>:
{
 800a1c8:	b570      	push	{r4, r5, r6, lr}
  FLOW_CONTROL_CHECK(uFlowProtectValue, FLOW_CTRL_RUNTIME_PROTECT);
 800a1ca:	4d22      	ldr	r5, [pc, #136]	; (800a254 <SFU_BOOT_SM_InstallNewUserFw+0x8c>)
  TRACE("\r\n= [SBOOT] STATE: INSTALL NEW USER FIRMWARE ");
 800a1cc:	4822      	ldr	r0, [pc, #136]	; (800a258 <SFU_BOOT_SM_InstallNewUserFw+0x90>)
 800a1ce:	f004 fd93 	bl	800ecf8 <iprintf>
  FLOW_CONTROL_CHECK(uFlowProtectValue, FLOW_CTRL_RUNTIME_PROTECT);
 800a1d2:	682a      	ldr	r2, [r5, #0]
 800a1d4:	f243 03f1 	movw	r3, #12529	; 0x30f1
 800a1d8:	429a      	cmp	r2, r3
 800a1da:	d001      	beq.n	800a1e0 <SFU_BOOT_SM_InstallNewUserFw+0x18>
 800a1dc:	f000 fa76 	bl	800a6cc <SFU_EXCPT_Security_Error>
  FLOW_CONTROL_INIT(uFlowProtectValue, FLOW_CTRL_INIT_VALUE);
 800a1e0:	f245 7376 	movw	r3, #22390	; 0x5776
 800a1e4:	602b      	str	r3, [r5, #0]
  e_ret_status = SFU_LL_SECU_CheckApplyStaticProtections();
 800a1e6:	f002 fdaf 	bl	800cd48 <SFU_LL_SECU_CheckApplyStaticProtections>
  FLOW_CONTROL_CHECK(uFlowProtectValue, FLOW_CTRL_STATIC_PROTECT);
 800a1ea:	682a      	ldr	r2, [r5, #0]
 800a1ec:	f243 03f1 	movw	r3, #12529	; 0x30f1
 800a1f0:	429a      	cmp	r2, r3
  e_ret_status = SFU_LL_SECU_CheckApplyStaticProtections();
 800a1f2:	4604      	mov	r4, r0
  FLOW_CONTROL_CHECK(uFlowProtectValue, FLOW_CTRL_STATIC_PROTECT);
 800a1f4:	d001      	beq.n	800a1fa <SFU_BOOT_SM_InstallNewUserFw+0x32>
 800a1f6:	f000 fa69 	bl	800a6cc <SFU_EXCPT_Security_Error>
  if (e_ret_status == SFU_SUCCESS)
 800a1fa:	4b18      	ldr	r3, [pc, #96]	; (800a25c <SFU_BOOT_SM_InstallNewUserFw+0x94>)
 800a1fc:	429c      	cmp	r4, r3
 800a1fe:	d103      	bne.n	800a208 <SFU_BOOT_SM_InstallNewUserFw+0x40>
    e_ret_status = SFU_LL_SECU_CheckApplyRuntimeProtections(SFU_SECOND_CONFIGURATION);
 800a200:	2001      	movs	r0, #1
 800a202:	f002 fe07 	bl	800ce14 <SFU_LL_SECU_CheckApplyRuntimeProtections>
 800a206:	4604      	mov	r4, r0
  FLOW_CONTROL_CHECK(uFlowProtectValue, FLOW_CTRL_RUNTIME_PROTECT);
 800a208:	682a      	ldr	r2, [r5, #0]
 800a20a:	f243 03f1 	movw	r3, #12529	; 0x30f1
 800a20e:	429a      	cmp	r2, r3
 800a210:	d001      	beq.n	800a216 <SFU_BOOT_SM_InstallNewUserFw+0x4e>
 800a212:	f000 fa5b 	bl	800a6cc <SFU_EXCPT_Security_Error>
  if (e_ret_status != SFU_SUCCESS)
 800a216:	4b11      	ldr	r3, [pc, #68]	; (800a25c <SFU_BOOT_SM_InstallNewUserFw+0x94>)
 800a218:	4d11      	ldr	r5, [pc, #68]	; (800a260 <SFU_BOOT_SM_InstallNewUserFw+0x98>)
 800a21a:	429c      	cmp	r4, r3
 800a21c:	d005      	beq.n	800a22a <SFU_BOOT_SM_InstallNewUserFw+0x62>
    SFU_SET_SM_CURR_STATE(SFU_STATE_HANDLE_CRITICAL_FAILURE);
 800a21e:	786b      	ldrb	r3, [r5, #1]
 800a220:	b2db      	uxtb	r3, r3
 800a222:	702b      	strb	r3, [r5, #0]
 800a224:	230b      	movs	r3, #11
 800a226:	706b      	strb	r3, [r5, #1]
}
 800a228:	bd70      	pop	{r4, r5, r6, pc}
  e_ret_status = SFU_IMG_CheckCandidateVersion(m_DwlSlotToInstall);
 800a22a:	4e0e      	ldr	r6, [pc, #56]	; (800a264 <SFU_BOOT_SM_InstallNewUserFw+0x9c>)
 800a22c:	6830      	ldr	r0, [r6, #0]
 800a22e:	f000 fa71 	bl	800a714 <SFU_IMG_CheckCandidateVersion>
  if (SFU_SUCCESS != e_ret_status)
 800a232:	42a0      	cmp	r0, r4
    (void) SFU_IMG_EraseDownloadedImg(m_DwlSlotToInstall);
 800a234:	6830      	ldr	r0, [r6, #0]
  if (SFU_SUCCESS != e_ret_status)
 800a236:	d002      	beq.n	800a23e <SFU_BOOT_SM_InstallNewUserFw+0x76>
    (void) SFU_IMG_EraseDownloadedImg(m_DwlSlotToInstall);
 800a238:	f001 fd1a 	bl	800bc70 <SFU_IMG_EraseDownloadedImg>
  if (SFU_SUCCESS == e_ret_status)
 800a23c:	e7ef      	b.n	800a21e <SFU_BOOT_SM_InstallNewUserFw+0x56>
    e_ret_status = SFU_IMG_CheckCandidateVersion(m_DwlSlotToInstall);
 800a23e:	f000 fa69 	bl	800a714 <SFU_IMG_CheckCandidateVersion>
  if (SFU_SUCCESS == e_ret_status)
 800a242:	42a0      	cmp	r0, r4
 800a244:	d1eb      	bne.n	800a21e <SFU_BOOT_SM_InstallNewUserFw+0x56>
    e_ret_status = SFU_IMG_TriggerImageInstallation(m_DwlSlotToInstall);
 800a246:	6830      	ldr	r0, [r6, #0]
 800a248:	f001 fd62 	bl	800bd10 <SFU_IMG_TriggerImageInstallation>
  if (SFU_SUCCESS == e_ret_status)
 800a24c:	42a0      	cmp	r0, r4
 800a24e:	d1e6      	bne.n	800a21e <SFU_BOOT_SM_InstallNewUserFw+0x56>
    SFU_BOOT_ForceReboot();
 800a250:	f7ff fe68 	bl	8009f24 <SFU_BOOT_ForceReboot>
 800a254:	20003404 	.word	0x20003404
 800a258:	08010beb 	.word	0x08010beb
 800a25c:	00122f11 	.word	0x00122f11
 800a260:	200034ac 	.word	0x200034ac
 800a264:	200034a8 	.word	0x200034a8

0800a268 <MemManage_Handler>:
  * @param  None
  * @retval None
  */
void SFU_CALLBACK_MEMORYFAULT(void)
{
  SFU_EXCPT_IrqExceptionHandler(SFU_EXCPT_MEMORY_FAULT);
 800a268:	2001      	movs	r0, #1
 800a26a:	f000 ba0b 	b.w	800a684 <SFU_EXCPT_IrqExceptionHandler>

0800a26e <SFU_COM_Serial_PutByte>:
  * @brief  Transmit a byte to the COM Port.
  * @param  uParam: The byte to be sent.
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
  */
SFU_ErrorStatus SFU_COM_Serial_PutByte(uint8_t uParam)
{
 800a26e:	b507      	push	{r0, r1, r2, lr}
  return SFU_LL_UART_Transmit(&uParam, 1U, SFU_COM_LOADER_SERIAL_TIME_OUT);
 800a270:	2264      	movs	r2, #100	; 0x64
{
 800a272:	f88d 0007 	strb.w	r0, [sp, #7]
  return SFU_LL_UART_Transmit(&uParam, 1U, SFU_COM_LOADER_SERIAL_TIME_OUT);
 800a276:	2101      	movs	r1, #1
 800a278:	f10d 0007 	add.w	r0, sp, #7
 800a27c:	f002 fb34 	bl	800c8e8 <SFU_LL_UART_Transmit>
}
 800a280:	b003      	add	sp, #12
 800a282:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800a288 <SFU_COM_YMODEM_Receive>:
{
 800a288:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a28c:	b08b      	sub	sp, #44	; 0x2c
  if ((peCOMStatus == NULL) || (puSize == NULL))
 800a28e:	4605      	mov	r5, r0
{
 800a290:	9102      	str	r1, [sp, #8]
  if ((peCOMStatus == NULL) || (puSize == NULL))
 800a292:	b920      	cbnz	r0, 800a29e <SFU_COM_YMODEM_Receive+0x16>
                      return SFU_ERROR;
 800a294:	f641 70e1 	movw	r0, #8161	; 0x1fe1
}
 800a298:	b00b      	add	sp, #44	; 0x2c
 800a29a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if ((peCOMStatus == NULL) || (puSize == NULL))
 800a29e:	9b02      	ldr	r3, [sp, #8]
 800a2a0:	2b00      	cmp	r3, #0
 800a2a2:	d0f7      	beq.n	800a294 <SFU_COM_YMODEM_Receive+0xc>
  *peCOMStatus = SFU_COM_YMODEM_OK;
 800a2a4:	2400      	movs	r4, #0
        break;
      default:
        status = HAL_ERROR;
        break;
    }
    *pData = char1;
 800a2a6:	f8df 825c 	ldr.w	r8, [pc, #604]	; 800a504 <SFU_COM_YMODEM_Receive+0x27c>
  *peCOMStatus = SFU_COM_YMODEM_OK;
 800a2aa:	7004      	strb	r4, [r0, #0]
  uint32_t session_begin = 0U;
 800a2ac:	9401      	str	r4, [sp, #4]
  uint32_t errors = 0U;
 800a2ae:	4626      	mov	r6, r4
  if (eRetStatus == SFU_SUCCESS)
 800a2b0:	4f92      	ldr	r7, [pc, #584]	; (800a4fc <SFU_COM_YMODEM_Receive+0x274>)
{
 800a2b2:	f04f 0900 	mov.w	r9, #0
 800a2b6:	e133      	b.n	800a520 <SFU_COM_YMODEM_Receive+0x298>
    switch (char1)
 800a2b8:	2b61      	cmp	r3, #97	; 0x61
 800a2ba:	d03b      	beq.n	800a334 <SFU_COM_YMODEM_Receive+0xac>
 800a2bc:	2b72      	cmp	r3, #114	; 0x72
 800a2be:	d01e      	beq.n	800a2fe <SFU_COM_YMODEM_Receive+0x76>
        status = HAL_BUSY;
 800a2c0:	2b41      	cmp	r3, #65	; 0x41
 800a2c2:	bf14      	ite	ne
 800a2c4:	f04f 0a01 	movne.w	sl, #1
 800a2c8:	f04f 0a02 	moveq.w	sl, #2
  uint32_t packet_size = 0U;
 800a2cc:	f04f 0b00 	mov.w	fp, #0
 800a2d0:	e149      	b.n	800a566 <SFU_COM_YMODEM_Receive+0x2de>
        if ((SFU_LL_UART_Receive(&char1, 1U, uTimeout) == SFU_SUCCESS) && (char1 == SFU_COM_YMODEM_CA))
 800a2d2:	f640 32b8 	movw	r2, #3000	; 0xbb8
 800a2d6:	2101      	movs	r1, #1
 800a2d8:	f10d 0013 	add.w	r0, sp, #19
 800a2dc:	f002 fb18 	bl	800c910 <SFU_LL_UART_Receive>
 800a2e0:	42b8      	cmp	r0, r7
 800a2e2:	d12a      	bne.n	800a33a <SFU_COM_YMODEM_Receive+0xb2>
 800a2e4:	f89d 3013 	ldrb.w	r3, [sp, #19]
    status = HAL_OK;
 800a2e8:	2b18      	cmp	r3, #24
 800a2ea:	bf15      	itete	ne
 800a2ec:	f04f 0a01 	movne.w	sl, #1
 800a2f0:	f04f 0a00 	moveq.w	sl, #0
 800a2f4:	f04f 0b00 	movne.w	fp, #0
 800a2f8:	f04f 0b02 	moveq.w	fp, #2
 800a2fc:	e133      	b.n	800a566 <SFU_COM_YMODEM_Receive+0x2de>
        (void) SFU_LL_UART_Receive(&char1, 1U, uTimeout);             /* Ymodem startup sequence : rb ==> 0x72 + 0x62 + 0x0D */
 800a2fe:	f640 32b8 	movw	r2, #3000	; 0xbb8
 800a302:	2101      	movs	r1, #1
 800a304:	f10d 0013 	add.w	r0, sp, #19
 800a308:	f002 fb02 	bl	800c910 <SFU_LL_UART_Receive>
        (void) SFU_LL_UART_Receive(&char1, 1U, uTimeout);
 800a30c:	f640 32b8 	movw	r2, #3000	; 0xbb8
 800a310:	2101      	movs	r1, #1
 800a312:	f10d 0013 	add.w	r0, sp, #19
 800a316:	f002 fafb 	bl	800c910 <SFU_LL_UART_Receive>
    status = HAL_OK;
 800a31a:	f04f 0a00 	mov.w	sl, #0
        packet_size = 3U;
 800a31e:	f04f 0b03 	mov.w	fp, #3
        break;
 800a322:	e120      	b.n	800a566 <SFU_COM_YMODEM_Receive+0x2de>
    status = HAL_OK;
 800a324:	f04f 0a00 	mov.w	sl, #0
        packet_size = SFU_COM_YMODEM_PACKET_1K_SIZE;
 800a328:	f44f 6b80 	mov.w	fp, #1024	; 0x400
 800a32c:	e11b      	b.n	800a566 <SFU_COM_YMODEM_Receive+0x2de>
    status = HAL_OK;
 800a32e:	f04f 0a00 	mov.w	sl, #0
 800a332:	e7cb      	b.n	800a2cc <SFU_COM_YMODEM_Receive+0x44>
        status = HAL_BUSY;
 800a334:	f04f 0a02 	mov.w	sl, #2
 800a338:	e7c8      	b.n	800a2cc <SFU_COM_YMODEM_Receive+0x44>
          status = HAL_ERROR;
 800a33a:	f04f 0a01 	mov.w	sl, #1
 800a33e:	e7c5      	b.n	800a2cc <SFU_COM_YMODEM_Receive+0x44>
      switch (ReceivePacket(m_aPacketData, &packet_length, SFU_COM_YMODEM_DOWNLOAD_TIMEOUT))
 800a340:	f1ba 0f00 	cmp.w	sl, #0
 800a344:	d012      	beq.n	800a36c <SFU_COM_YMODEM_Receive+0xe4>
 800a346:	f1ba 0f02 	cmp.w	sl, #2
 800a34a:	f000 80dd 	beq.w	800a508 <SFU_COM_YMODEM_Receive+0x280>
          if (session_begin > 0U)
 800a34e:	9b01      	ldr	r3, [sp, #4]
 800a350:	b103      	cbz	r3, 800a354 <SFU_COM_YMODEM_Receive+0xcc>
            errors ++;
 800a352:	3601      	adds	r6, #1
          if (errors > SFU_COM_YMODEM_MAX_ERRORS)
 800a354:	2e03      	cmp	r6, #3
 800a356:	f240 814a 	bls.w	800a5ee <SFU_COM_YMODEM_Receive+0x366>
            (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_CA);
 800a35a:	2018      	movs	r0, #24
 800a35c:	f7ff ff87 	bl	800a26e <SFU_COM_Serial_PutByte>
            (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_CA);
 800a360:	2018      	movs	r0, #24
 800a362:	f7ff ff84 	bl	800a26e <SFU_COM_Serial_PutByte>
            *peCOMStatus = SFU_COM_YMODEM_ABORT;
 800a366:	2302      	movs	r3, #2
 800a368:	702b      	strb	r3, [r5, #0]
 800a36a:	e0d5      	b.n	800a518 <SFU_COM_YMODEM_Receive+0x290>
          switch (packet_length)
 800a36c:	f1bb 0f02 	cmp.w	fp, #2
 800a370:	d010      	beq.n	800a394 <SFU_COM_YMODEM_Receive+0x10c>
 800a372:	f1bb 0f03 	cmp.w	fp, #3
 800a376:	d012      	beq.n	800a39e <SFU_COM_YMODEM_Receive+0x116>
 800a378:	f1bb 0f00 	cmp.w	fp, #0
 800a37c:	f040 8124 	bne.w	800a5c8 <SFU_COM_YMODEM_Receive+0x340>
              (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_ACK);
 800a380:	2006      	movs	r0, #6
 800a382:	f7ff ff74 	bl	800a26e <SFU_COM_Serial_PutByte>
              *puSize = filesize;
 800a386:	9b02      	ldr	r3, [sp, #8]
 800a388:	465e      	mov	r6, fp
 800a38a:	601c      	str	r4, [r3, #0]
  while ((session_done == 0U) && (*peCOMStatus == SFU_COM_YMODEM_OK))
 800a38c:	782b      	ldrb	r3, [r5, #0]
 800a38e:	2b00      	cmp	r3, #0
 800a390:	d08e      	beq.n	800a2b0 <SFU_COM_YMODEM_Receive+0x28>
 800a392:	e099      	b.n	800a4c8 <SFU_COM_YMODEM_Receive+0x240>
              (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_ACK);
 800a394:	2006      	movs	r0, #6
 800a396:	f7ff ff6a 	bl	800a26e <SFU_COM_Serial_PutByte>
              *peCOMStatus = SFU_COM_YMODEM_ABORT;
 800a39a:	f885 b000 	strb.w	fp, [r5]
              break;
 800a39e:	4656      	mov	r6, sl
 800a3a0:	e0ba      	b.n	800a518 <SFU_COM_YMODEM_Receive+0x290>
                      i++;
 800a3a2:	3101      	adds	r1, #1
                    while ((*file_ptr != 0U) && (i < SFU_COM_YMODEM_FILE_NAME_LENGTH))
 800a3a4:	f812 3b01 	ldrb.w	r3, [r2], #1
 800a3a8:	b113      	cbz	r3, 800a3b0 <SFU_COM_YMODEM_Receive+0x128>
 800a3aa:	2940      	cmp	r1, #64	; 0x40
 800a3ac:	d1f9      	bne.n	800a3a2 <SFU_COM_YMODEM_Receive+0x11a>
 800a3ae:	2300      	movs	r3, #0
 800a3b0:	a805      	add	r0, sp, #20
 800a3b2:	e001      	b.n	800a3b8 <SFU_COM_YMODEM_Receive+0x130>
                      file_size[i] = *file_ptr;
 800a3b4:	5419      	strb	r1, [r3, r0]
                      i++;
 800a3b6:	3301      	adds	r3, #1
                    while ((*file_ptr != (uint8_t) ' ') && (i < SFU_COM_YMODEM_FILE_SIZE_LENGTH))
 800a3b8:	5cd1      	ldrb	r1, [r2, r3]
 800a3ba:	2920      	cmp	r1, #32
 800a3bc:	d001      	beq.n	800a3c2 <SFU_COM_YMODEM_Receive+0x13a>
 800a3be:	2b10      	cmp	r3, #16
 800a3c0:	d1f8      	bne.n	800a3b4 <SFU_COM_YMODEM_Receive+0x12c>
                    file_size[i] = (uint8_t) '\0';
 800a3c2:	aa0a      	add	r2, sp, #40	; 0x28
 800a3c4:	4413      	add	r3, r2
 800a3c6:	2600      	movs	r6, #0
 800a3c8:	f803 6c14 	strb.w	r6, [r3, #-20]
  if ((pInputStr[0] == (uint8_t)'0') && ((pInputStr[1] == (uint8_t)'x') || (pInputStr[1] == (uint8_t)'X')))
 800a3cc:	f89d 3014 	ldrb.w	r3, [sp, #20]
 800a3d0:	2b30      	cmp	r3, #48	; 0x30
 800a3d2:	d140      	bne.n	800a456 <SFU_COM_YMODEM_Receive+0x1ce>
 800a3d4:	f89d 3015 	ldrb.w	r3, [sp, #21]
 800a3d8:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 800a3dc:	2b58      	cmp	r3, #88	; 0x58
 800a3de:	d13a      	bne.n	800a456 <SFU_COM_YMODEM_Receive+0x1ce>
 800a3e0:	2102      	movs	r1, #2
 800a3e2:	e00f      	b.n	800a404 <SFU_COM_YMODEM_Receive+0x17c>
        digit = CONVERTHEX(pInputStr[i]);
 800a3e4:	2b09      	cmp	r3, #9
 800a3e6:	d908      	bls.n	800a3fa <SFU_COM_YMODEM_Receive+0x172>
 800a3e8:	f1ac 0341 	sub.w	r3, ip, #65	; 0x41
 800a3ec:	2b05      	cmp	r3, #5
 800a3ee:	bf94      	ite	ls
 800a3f0:	f1ac 0337 	subls.w	r3, ip, #55	; 0x37
 800a3f4:	f1ac 0357 	subhi.w	r3, ip, #87	; 0x57
 800a3f8:	b2db      	uxtb	r3, r3
      i++;
 800a3fa:	3101      	adds	r1, #1
    while ((i < 11U) && (pInputStr[i] != (uint8_t)'\0'))
 800a3fc:	290b      	cmp	r1, #11
        val = (val << 4U) + digit;
 800a3fe:	eb03 1606 	add.w	r6, r3, r6, lsl #4
    while ((i < 11U) && (pInputStr[i] != (uint8_t)'\0'))
 800a402:	d00e      	beq.n	800a422 <SFU_COM_YMODEM_Receive+0x19a>
 800a404:	f811 c000 	ldrb.w	ip, [r1, r0]
 800a408:	f1bc 0f00 	cmp.w	ip, #0
 800a40c:	d009      	beq.n	800a422 <SFU_COM_YMODEM_Receive+0x19a>
      if (ISVALIDHEX(pInputStr[i]))
 800a40e:	f1ac 0230 	sub.w	r2, ip, #48	; 0x30
 800a412:	b2d3      	uxtb	r3, r2
 800a414:	f02c 0220 	bic.w	r2, ip, #32
 800a418:	3a41      	subs	r2, #65	; 0x41
 800a41a:	2a05      	cmp	r2, #5
 800a41c:	d9e2      	bls.n	800a3e4 <SFU_COM_YMODEM_Receive+0x15c>
 800a41e:	2b09      	cmp	r3, #9
 800a420:	d9eb      	bls.n	800a3fa <SFU_COM_YMODEM_Receive+0x172>
    if (pInputStr[i] == (uint8_t)'\0')
 800a422:	ab0a      	add	r3, sp, #40	; 0x28
 800a424:	4419      	add	r1, r3
 800a426:	f811 3c14 	ldrb.w	r3, [r1, #-20]
 800a42a:	2b00      	cmp	r3, #0
 800a42c:	bf08      	it	eq
 800a42e:	4634      	moveq	r4, r6
                    if (SFU_COM_YMODEM_HeaderPktRxCpltCallback((uint32_t) filesize) == SFU_SUCCESS)
 800a430:	4620      	mov	r0, r4
 800a432:	f002 f8a7 	bl	800c584 <SFU_COM_YMODEM_HeaderPktRxCpltCallback>
 800a436:	42b8      	cmp	r0, r7
 800a438:	d131      	bne.n	800a49e <SFU_COM_YMODEM_Receive+0x216>
                      (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_ACK);
 800a43a:	2006      	movs	r0, #6
 800a43c:	f7ff ff17 	bl	800a26e <SFU_COM_Serial_PutByte>
                      (void) SFU_LL_UART_Flush();
 800a440:	f002 fa7a 	bl	800c938 <SFU_LL_UART_Flush>
                      (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_CRC16);
 800a444:	2043      	movs	r0, #67	; 0x43
                    (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_ACK);
 800a446:	f7ff ff12 	bl	800a26e <SFU_COM_Serial_PutByte>
                session_begin = 1;
 800a44a:	2301      	movs	r3, #1
                packets_received ++;
 800a44c:	f109 0901 	add.w	r9, r9, #1
                session_begin = 1;
 800a450:	9301      	str	r3, [sp, #4]
          errors = 0U;
 800a452:	2600      	movs	r6, #0
    while ((file_done == 0U) && (*peCOMStatus == SFU_COM_YMODEM_OK))
 800a454:	e060      	b.n	800a518 <SFU_COM_YMODEM_Receive+0x290>
 800a456:	2300      	movs	r3, #0
 800a458:	4619      	mov	r1, r3
        val = (val * 10U) + digit;
 800a45a:	260a      	movs	r6, #10
      if (pInputStr[i] == (uint8_t)'\0')
 800a45c:	f810 2b01 	ldrb.w	r2, [r0], #1
 800a460:	b12a      	cbz	r2, 800a46e <SFU_COM_YMODEM_Receive+0x1e6>
      else if (((pInputStr[i] == (uint8_t)'k') || (pInputStr[i] == (uint8_t)'K')) && (i > 0U))
 800a462:	2a6b      	cmp	r2, #107	; 0x6b
 800a464:	d001      	beq.n	800a46a <SFU_COM_YMODEM_Receive+0x1e2>
 800a466:	2a4b      	cmp	r2, #75	; 0x4b
 800a468:	d104      	bne.n	800a474 <SFU_COM_YMODEM_Receive+0x1ec>
 800a46a:	b159      	cbz	r1, 800a484 <SFU_COM_YMODEM_Receive+0x1fc>
        val = val << 10U;
 800a46c:	029b      	lsls	r3, r3, #10
        res = 1U;
 800a46e:	461c      	mov	r4, r3
        res = 1U;
 800a470:	2201      	movs	r2, #1
 800a472:	e00e      	b.n	800a492 <SFU_COM_YMODEM_Receive+0x20a>
      else if (((pInputStr[i] == (uint8_t)'m') || (pInputStr[i] == (uint8_t)'M')) && (i > 0U))
 800a474:	f002 0cdf 	and.w	ip, r2, #223	; 0xdf
 800a478:	f1bc 0f4d 	cmp.w	ip, #77	; 0x4d
 800a47c:	d102      	bne.n	800a484 <SFU_COM_YMODEM_Receive+0x1fc>
 800a47e:	b109      	cbz	r1, 800a484 <SFU_COM_YMODEM_Receive+0x1fc>
        val = val << 20U;
 800a480:	051b      	lsls	r3, r3, #20
        res = 1U;
 800a482:	e7f4      	b.n	800a46e <SFU_COM_YMODEM_Receive+0x1e6>
      else if (ISVALIDDEC(pInputStr[i]))
 800a484:	3a30      	subs	r2, #48	; 0x30
 800a486:	b2d2      	uxtb	r2, r2
 800a488:	2a09      	cmp	r2, #9
 800a48a:	d8d1      	bhi.n	800a430 <SFU_COM_YMODEM_Receive+0x1a8>
        val = (val * 10U) + digit;
 800a48c:	fb06 2303 	mla	r3, r6, r3, r2
 800a490:	2200      	movs	r2, #0
      i++;
 800a492:	3101      	adds	r1, #1
    while ((i < 11U) && (res != 1U))
 800a494:	290b      	cmp	r1, #11
 800a496:	d0cb      	beq.n	800a430 <SFU_COM_YMODEM_Receive+0x1a8>
 800a498:	2a00      	cmp	r2, #0
 800a49a:	d0df      	beq.n	800a45c <SFU_COM_YMODEM_Receive+0x1d4>
 800a49c:	e7c8      	b.n	800a430 <SFU_COM_YMODEM_Receive+0x1a8>
                      tmp = SFU_COM_YMODEM_CA;
 800a49e:	2318      	movs	r3, #24
                      (void) SFU_LL_UART_Transmit(&tmp, 1U, SFU_COM_YMODEM_NAK_TIMEOUT);
 800a4a0:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 800a4a4:	2101      	movs	r1, #1
 800a4a6:	f10d 0013 	add.w	r0, sp, #19
                      tmp = SFU_COM_YMODEM_CA;
 800a4aa:	f88d 3013 	strb.w	r3, [sp, #19]
                      (void) SFU_LL_UART_Transmit(&tmp, 1U, SFU_COM_YMODEM_NAK_TIMEOUT);
 800a4ae:	f002 fa1b 	bl	800c8e8 <SFU_LL_UART_Transmit>
                      (void) SFU_LL_UART_Transmit(&tmp, 1U, SFU_COM_YMODEM_NAK_TIMEOUT);
 800a4b2:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 800a4b6:	2101      	movs	r1, #1
 800a4b8:	f10d 0013 	add.w	r0, sp, #19
 800a4bc:	f002 fa14 	bl	800c8e8 <SFU_LL_UART_Transmit>
 800a4c0:	e6e8      	b.n	800a294 <SFU_COM_YMODEM_Receive+0xc>
                    (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_ACK);
 800a4c2:	2006      	movs	r0, #6
 800a4c4:	f7ff fed3 	bl	800a26e <SFU_COM_Serial_PutByte>
  (void) BSP_LED_Off(SFU_STATUS_LED);
 800a4c8:	2001      	movs	r0, #1
 800a4ca:	f002 fe01 	bl	800d0d0 <BSP_LED_Off>
  if (*peCOMStatus == SFU_COM_YMODEM_OK)
 800a4ce:	782b      	ldrb	r3, [r5, #0]
 800a4d0:	2b00      	cmp	r3, #0
 800a4d2:	f47f aedf 	bne.w	800a294 <SFU_COM_YMODEM_Receive+0xc>
    return SFU_SUCCESS;
 800a4d6:	4809      	ldr	r0, [pc, #36]	; (800a4fc <SFU_COM_YMODEM_Receive+0x274>)
 800a4d8:	e6de      	b.n	800a298 <SFU_COM_YMODEM_Receive+0x10>
                  if (SFU_COM_YMODEM_DataPktRxCpltCallback(&m_aPacketData[SFU_COM_YMODEM_PACKET_DATA_INDEX],
 800a4da:	4809      	ldr	r0, [pc, #36]	; (800a500 <SFU_COM_YMODEM_Receive+0x278>)
 800a4dc:	4659      	mov	r1, fp
 800a4de:	f002 f86b 	bl	800c5b8 <SFU_COM_YMODEM_DataPktRxCpltCallback>
 800a4e2:	42b8      	cmp	r0, r7
 800a4e4:	d101      	bne.n	800a4ea <SFU_COM_YMODEM_Receive+0x262>
                    (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_ACK);
 800a4e6:	2006      	movs	r0, #6
 800a4e8:	e7ad      	b.n	800a446 <SFU_COM_YMODEM_Receive+0x1be>
                    (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_CA);
 800a4ea:	2018      	movs	r0, #24
 800a4ec:	f7ff febf 	bl	800a26e <SFU_COM_Serial_PutByte>
                    (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_CA);
 800a4f0:	2018      	movs	r0, #24
 800a4f2:	f7ff febc 	bl	800a26e <SFU_COM_Serial_PutByte>
                    *peCOMStatus = SFU_COM_YMODEM_DATA;
 800a4f6:	2304      	movs	r3, #4
 800a4f8:	702b      	strb	r3, [r5, #0]
 800a4fa:	e7a6      	b.n	800a44a <SFU_COM_YMODEM_Receive+0x1c2>
 800a4fc:	00122f11 	.word	0x00122f11
 800a500:	200034b4 	.word	0x200034b4
 800a504:	200034b0 	.word	0x200034b0
          (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_CA);
 800a508:	2018      	movs	r0, #24
 800a50a:	f7ff feb0 	bl	800a26e <SFU_COM_Serial_PutByte>
          (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_CA);
 800a50e:	2018      	movs	r0, #24
 800a510:	f7ff fead 	bl	800a26e <SFU_COM_Serial_PutByte>
          *peCOMStatus = SFU_COM_YMODEM_ABORT;
 800a514:	f885 a000 	strb.w	sl, [r5]
    while ((file_done == 0U) && (*peCOMStatus == SFU_COM_YMODEM_OK))
 800a518:	782b      	ldrb	r3, [r5, #0]
 800a51a:	2b00      	cmp	r3, #0
 800a51c:	f47f af36 	bne.w	800a38c <SFU_COM_YMODEM_Receive+0x104>
  (void) SFU_LL_SECU_IWDG_Refresh();
 800a520:	f002 fcac 	bl	800ce7c <SFU_LL_SECU_IWDG_Refresh>
  eRetStatus = SFU_LL_UART_Receive(&char1, 1, uTimeout);
 800a524:	f640 32b8 	movw	r2, #3000	; 0xbb8
 800a528:	2101      	movs	r1, #1
 800a52a:	f10d 0013 	add.w	r0, sp, #19
 800a52e:	f002 f9ef 	bl	800c910 <SFU_LL_UART_Receive>
  if (eRetStatus == SFU_SUCCESS)
 800a532:	42b8      	cmp	r0, r7
 800a534:	f47f af0b 	bne.w	800a34e <SFU_COM_YMODEM_Receive+0xc6>
    switch (char1)
 800a538:	f89d 3013 	ldrb.w	r3, [sp, #19]
 800a53c:	2b18      	cmp	r3, #24
 800a53e:	f43f aec8 	beq.w	800a2d2 <SFU_COM_YMODEM_Receive+0x4a>
 800a542:	f63f aeb9 	bhi.w	800a2b8 <SFU_COM_YMODEM_Receive+0x30>
 800a546:	2b02      	cmp	r3, #2
 800a548:	f43f aeec 	beq.w	800a324 <SFU_COM_YMODEM_Receive+0x9c>
 800a54c:	2b04      	cmp	r3, #4
 800a54e:	f43f aeee 	beq.w	800a32e <SFU_COM_YMODEM_Receive+0xa6>
 800a552:	2b01      	cmp	r3, #1
 800a554:	bf15      	itete	ne
 800a556:	f04f 0a01 	movne.w	sl, #1
 800a55a:	f04f 0a00 	moveq.w	sl, #0
 800a55e:	f04f 0b00 	movne.w	fp, #0
 800a562:	f04f 0b80 	moveq.w	fp, #128	; 0x80
    *pData = char1;
 800a566:	f89d 1013 	ldrb.w	r1, [sp, #19]
 800a56a:	f888 1000 	strb.w	r1, [r8]

    if (packet_size >= SFU_COM_YMODEM_PACKET_SIZE)
 800a56e:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
 800a572:	f67f aee5 	bls.w	800a340 <SFU_COM_YMODEM_Receive+0xb8>
    {

#ifndef MINICOM_YMODEM
      eRetStatus = SFU_LL_UART_Receive(&pData[SFU_COM_YMODEM_PACKET_NUMBER_INDEX],
 800a576:	4823      	ldr	r0, [pc, #140]	; (800a604 <SFU_COM_YMODEM_Receive+0x37c>)
 800a578:	f640 32b8 	movw	r2, #3000	; 0xbb8
 800a57c:	f10b 0104 	add.w	r1, fp, #4
 800a580:	f002 f9c6 	bl	800c910 <SFU_LL_UART_Receive>
        eRetStatus = SFU_SUCCESS;
      }
#endif /* MINICOM_YMODEM */

      /* Simple packet sanity check */
      if (eRetStatus == SFU_SUCCESS)
 800a584:	42b8      	cmp	r0, r7
 800a586:	f47f aee2 	bne.w	800a34e <SFU_COM_YMODEM_Receive+0xc6>
      {
        status = HAL_OK;

        if (pData[SFU_COM_YMODEM_PACKET_NUMBER_INDEX] != ((pData[SFU_COM_YMODEM_PACKET_CNUMBER_INDEX]) ^
 800a58a:	f898 2003 	ldrb.w	r2, [r8, #3]
 800a58e:	f898 1002 	ldrb.w	r1, [r8, #2]
 800a592:	43d2      	mvns	r2, r2
 800a594:	b2d2      	uxtb	r2, r2
 800a596:	4291      	cmp	r1, r2
 800a598:	f47f aed9 	bne.w	800a34e <SFU_COM_YMODEM_Receive+0xc6>
          status = HAL_ERROR;
        }
        else
        {
          /* Check packet CRC*/
          crc = (((uint32_t)pData[ packet_size + SFU_COM_YMODEM_PACKET_DATA_INDEX ]) << 8U) & 0x0000FF00U;
 800a59c:	eb08 020b 	add.w	r2, r8, fp
          crc += pData[ packet_size + SFU_COM_YMODEM_PACKET_DATA_INDEX + 1U ];

          /*Configure CRC with 16-bit polynomial*/
          if (SFU_LL_CRC_Config(SFU_CRC_CONFIG_16BIT) == SFU_SUCCESS)
 800a5a0:	2002      	movs	r0, #2
          crc = (((uint32_t)pData[ packet_size + SFU_COM_YMODEM_PACKET_DATA_INDEX ]) << 8U) & 0x0000FF00U;
 800a5a2:	7913      	ldrb	r3, [r2, #4]
          crc += pData[ packet_size + SFU_COM_YMODEM_PACKET_DATA_INDEX + 1U ];
 800a5a4:	f892 a005 	ldrb.w	sl, [r2, #5]
          crc = (((uint32_t)pData[ packet_size + SFU_COM_YMODEM_PACKET_DATA_INDEX ]) << 8U) & 0x0000FF00U;
 800a5a8:	9303      	str	r3, [sp, #12]
          if (SFU_LL_CRC_Config(SFU_CRC_CONFIG_16BIT) == SFU_SUCCESS)
 800a5aa:	f002 f92d 	bl	800c808 <SFU_LL_CRC_Config>
 800a5ae:	42b8      	cmp	r0, r7
 800a5b0:	f47f aecd 	bne.w	800a34e <SFU_COM_YMODEM_Receive+0xc6>
          {
            if (SFU_LL_CRC_Calculate((uint32_t *)(uint32_t)&pData[SFU_COM_YMODEM_PACKET_DATA_INDEX], packet_size) != crc)
 800a5b4:	4814      	ldr	r0, [pc, #80]	; (800a608 <SFU_COM_YMODEM_Receive+0x380>)
 800a5b6:	4659      	mov	r1, fp
 800a5b8:	f002 f966 	bl	800c888 <SFU_LL_CRC_Calculate>
          crc += pData[ packet_size + SFU_COM_YMODEM_PACKET_DATA_INDEX + 1U ];
 800a5bc:	9b03      	ldr	r3, [sp, #12]
 800a5be:	eb0a 2203 	add.w	r2, sl, r3, lsl #8
            if (SFU_LL_CRC_Calculate((uint32_t *)(uint32_t)&pData[SFU_COM_YMODEM_PACKET_DATA_INDEX], packet_size) != crc)
 800a5c2:	4282      	cmp	r2, r0
 800a5c4:	f47f aec3 	bne.w	800a34e <SFU_COM_YMODEM_Receive+0xc6>
              if (m_aPacketData[SFU_COM_YMODEM_PACKET_NUMBER_INDEX] != (packets_received & 0x000000FFU))
 800a5c8:	f898 1002 	ldrb.w	r1, [r8, #2]
 800a5cc:	fa5f f289 	uxtb.w	r2, r9
 800a5d0:	4291      	cmp	r1, r2
 800a5d2:	f47f af3e 	bne.w	800a452 <SFU_COM_YMODEM_Receive+0x1ca>
                if (packets_received == 0U)
 800a5d6:	f1b9 0f00 	cmp.w	r9, #0
 800a5da:	f47f af7e 	bne.w	800a4da <SFU_COM_YMODEM_Receive+0x252>
                  if (m_aPacketData[SFU_COM_YMODEM_PACKET_DATA_INDEX] != 0U)
 800a5de:	f898 3004 	ldrb.w	r3, [r8, #4]
 800a5e2:	2b00      	cmp	r3, #0
 800a5e4:	f43f af6d 	beq.w	800a4c2 <SFU_COM_YMODEM_Receive+0x23a>
                    file_ptr = m_aPacketData + SFU_COM_YMODEM_PACKET_DATA_INDEX;
 800a5e8:	4a07      	ldr	r2, [pc, #28]	; (800a608 <SFU_COM_YMODEM_Receive+0x380>)
                    i = 0U;
 800a5ea:	4649      	mov	r1, r9
 800a5ec:	e6da      	b.n	800a3a4 <SFU_COM_YMODEM_Receive+0x11c>
            (void) SFU_COM_Serial_PutByte(SFU_COM_YMODEM_CRC16); /* Ask for a packet */
 800a5ee:	2043      	movs	r0, #67	; 0x43
 800a5f0:	f7ff fe3d 	bl	800a26e <SFU_COM_Serial_PutByte>
            TRACE("\b.");                                 /* Replace C char by . on display console */
 800a5f4:	4805      	ldr	r0, [pc, #20]	; (800a60c <SFU_COM_YMODEM_Receive+0x384>)
 800a5f6:	f004 fb7f 	bl	800ecf8 <iprintf>
            (void) BSP_LED_Toggle(SFU_STATUS_LED);
 800a5fa:	2001      	movs	r0, #1
 800a5fc:	f002 fd78 	bl	800d0f0 <BSP_LED_Toggle>
 800a600:	e78a      	b.n	800a518 <SFU_COM_YMODEM_Receive+0x290>
 800a602:	bf00      	nop
 800a604:	200034b2 	.word	0x200034b2
 800a608:	200034b4 	.word	0x200034b4
 800a60c:	08010c50 	.word	0x08010c50

0800a610 <SFU_COM_Init>:
  * @brief  SFU Com Init function.
  * @param  None.
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
  */
SFU_ErrorStatus SFU_COM_Init(void)
{
 800a610:	b508      	push	{r3, lr}
#if defined(__GNUC__) && !defined(__ARMCC_VERSION)
  setvbuf(stdout, NULL, _IONBF, 0);
 800a612:	4b06      	ldr	r3, [pc, #24]	; (800a62c <SFU_COM_Init+0x1c>)
 800a614:	6818      	ldr	r0, [r3, #0]
 800a616:	2300      	movs	r3, #0
 800a618:	4619      	mov	r1, r3
 800a61a:	6880      	ldr	r0, [r0, #8]
 800a61c:	2202      	movs	r2, #2
 800a61e:	f004 fc0d 	bl	800ee3c <setvbuf>
#endif /* __GNUC__ */
  return SFU_LL_UART_Init();
}
 800a622:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  return SFU_LL_UART_Init();
 800a626:	f002 b937 	b.w	800c898 <SFU_LL_UART_Init>
 800a62a:	bf00      	nop
 800a62c:	20003418 	.word	0x20003418

0800a630 <SFU_COM_DeInit>:
  * @param  None.
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
  */
SFU_ErrorStatus SFU_COM_DeInit(void)
{
  return SFU_LL_UART_DeInit();
 800a630:	f002 b956 	b.w	800c8e0 <SFU_LL_UART_DeInit>

0800a634 <SFU_COM_Serial_PutString>:
SFU_ErrorStatus SFU_COM_Serial_PutString(uint8_t *pString)
{
  uint16_t length = 0U;

  /* Check the pointers allocation */
  if (pString == NULL)
 800a634:	b140      	cbz	r0, 800a648 <SFU_COM_Serial_PutString+0x14>
 800a636:	2300      	movs	r3, #0
 800a638:	b299      	uxth	r1, r3
  {
    return SFU_ERROR;
  }

  while (pString[length] != (uint8_t)'\0')
 800a63a:	3301      	adds	r3, #1
 800a63c:	5c42      	ldrb	r2, [r0, r1]
 800a63e:	2a00      	cmp	r2, #0
 800a640:	d1fa      	bne.n	800a638 <SFU_COM_Serial_PutString+0x4>
  {
    length++;
  }

  return SFU_LL_UART_Transmit(pString, length, SFU_COM_TRACE_SERIAL_TIME_OUT);
 800a642:	2264      	movs	r2, #100	; 0x64
 800a644:	f002 b950 	b.w	800c8e8 <SFU_LL_UART_Transmit>

}
 800a648:	f641 70e1 	movw	r0, #8161	; 0x1fe1
 800a64c:	4770      	bx	lr

0800a64e <__io_putchar>:
  * @brief  Retargets the C library printf function to SFU UART.
  * @param  None
  * @retval ch
  */
PUTCHAR_PROTOTYPE
{
 800a64e:	b507      	push	{r0, r1, r2, lr}
  /* Place your implementation of fputc here */
  /* e.g. write a character to the USART1 and Loop until the end of transmission */
  (void) SFU_LL_UART_Transmit((uint8_t *)&ch, 1U, 0xFFFFU);
 800a650:	f64f 72ff 	movw	r2, #65535	; 0xffff
{
 800a654:	9001      	str	r0, [sp, #4]
  (void) SFU_LL_UART_Transmit((uint8_t *)&ch, 1U, 0xFFFFU);
 800a656:	2101      	movs	r1, #1
 800a658:	a801      	add	r0, sp, #4
 800a65a:	f002 f945 	bl	800c8e8 <SFU_LL_UART_Transmit>

  return ch;
}
 800a65e:	9801      	ldr	r0, [sp, #4]
 800a660:	b003      	add	sp, #12
 800a662:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800a668 <SFU_EXCPT_SetError>:
  * @param  Error Error code.
  * @retval None
  */
void SFU_EXCPT_SetError(SFU_EXCPT_IdTypeDef eExceptionId)
{
  if (eExceptionId <= SFU_EXCPT_UNKNOWN)
 800a668:	2818      	cmp	r0, #24
 800a66a:	d805      	bhi.n	800a678 <SFU_EXCPT_SetError+0x10>
  {
#ifdef SFU_DEBUG_MODE
    TRACE("\r\n\t%s",m_aErrorStrings[(uint32_t) eExceptionId]);
 800a66c:	4b03      	ldr	r3, [pc, #12]	; (800a67c <SFU_EXCPT_SetError+0x14>)
 800a66e:	f853 1020 	ldr.w	r1, [r3, r0, lsl #2]
 800a672:	4803      	ldr	r0, [pc, #12]	; (800a680 <SFU_EXCPT_SetError+0x18>)
 800a674:	f004 bb40 	b.w	800ecf8 <iprintf>
#endif /* SFU_DEBUG_MODE */
  }
}
 800a678:	4770      	bx	lr
 800a67a:	bf00      	nop
 800a67c:	08010ec4 	.word	0x08010ec4
 800a680:	08010c53 	.word	0x08010c53

0800a684 <SFU_EXCPT_IrqExceptionHandler>:
  *         it's not possible to continue without compromising the stability or
  *         the security of the solution. A System Reset is forced at the end.
  * @retval None
  */
void SFU_EXCPT_IrqExceptionHandler(SFU_EXCPT_IdTypeDef eExceptionId)
{
 800a684:	b510      	push	{r4, lr}
#ifdef SFU_DEBUG_MODE
  uint8_t message[150];
  uint32_t i = 0U;

  /* Avoid warning with cast frombetween char* and uint8_t* */
  while ((m_aErrorStrings[(uint32_t) eExceptionId][i] != 0u) && (i < 149U))
 800a686:	4b0f      	ldr	r3, [pc, #60]	; (800a6c4 <SFU_EXCPT_IrqExceptionHandler+0x40>)
{
 800a688:	b0a6      	sub	sp, #152	; 0x98
 800a68a:	466a      	mov	r2, sp
  while ((m_aErrorStrings[(uint32_t) eExceptionId][i] != 0u) && (i < 149U))
 800a68c:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 800a690:	4614      	mov	r4, r2
  uint32_t i = 0U;
 800a692:	2300      	movs	r3, #0
  while ((m_aErrorStrings[(uint32_t) eExceptionId][i] != 0u) && (i < 149U))
 800a694:	5cc1      	ldrb	r1, [r0, r3]
 800a696:	b109      	cbz	r1, 800a69c <SFU_EXCPT_IrqExceptionHandler+0x18>
 800a698:	2b95      	cmp	r3, #149	; 0x95
 800a69a:	d10e      	bne.n	800a6ba <SFU_EXCPT_IrqExceptionHandler+0x36>
  {
    message[i] = m_aErrorStrings[(uint32_t) eExceptionId][i];
    i++;
  }
  message[i] = 0U;
 800a69c:	aa26      	add	r2, sp, #152	; 0x98
 800a69e:	4413      	add	r3, r2

  /* Print relevant error message */
  TRACE_IRQ((uint8_t *)"\r\n\t  ");
 800a6a0:	4809      	ldr	r0, [pc, #36]	; (800a6c8 <SFU_EXCPT_IrqExceptionHandler+0x44>)
  message[i] = 0U;
 800a6a2:	2200      	movs	r2, #0
 800a6a4:	f803 2c98 	strb.w	r2, [r3, #-152]
  TRACE_IRQ((uint8_t *)"\r\n\t  ");
 800a6a8:	f7ff ffc4 	bl	800a634 <SFU_COM_Serial_PutString>
  TRACE_IRQ(message);
 800a6ac:	4620      	mov	r0, r4
 800a6ae:	f7ff ffc1 	bl	800a634 <SFU_COM_Serial_PutString>
  /* Try to take an action */
  SFU_EXCPT_RuntimeExceptionHandler(eExceptionId);

  /* It's not possible to continue without compromising the stability or the security of the solution.
  The State Machine needs to be aborted and a Reset must be triggered */
  SFU_BOOT_ForceReboot();
 800a6b2:	f7ff fc37 	bl	8009f24 <SFU_BOOT_ForceReboot>
}
 800a6b6:	b026      	add	sp, #152	; 0x98
 800a6b8:	bd10      	pop	{r4, pc}
    message[i] = m_aErrorStrings[(uint32_t) eExceptionId][i];
 800a6ba:	f802 1b01 	strb.w	r1, [r2], #1
    i++;
 800a6be:	3301      	adds	r3, #1
 800a6c0:	e7e8      	b.n	800a694 <SFU_EXCPT_IrqExceptionHandler+0x10>
 800a6c2:	bf00      	nop
 800a6c4:	08010ec4 	.word	0x08010ec4
 800a6c8:	08010c59 	.word	0x08010c59

0800a6cc <SFU_EXCPT_Security_Error>:
  *         This parameter can be a value of @ref SFU_EXCPT_ID_Structure_definition.
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
  */

void SFU_EXCPT_Security_Error(void)
{
 800a6cc:	b508      	push	{r3, lr}
  TRACE("\r\n= [SBOOT] Security issue : execution stopped !");
 800a6ce:	480a      	ldr	r0, [pc, #40]	; (800a6f8 <SFU_EXCPT_Security_Error+0x2c>)
 800a6d0:	f004 fb12 	bl	800ecf8 <iprintf>
  HAL_Delay(1000);
 800a6d4:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800a6d8:	f002 fdde 	bl	800d298 <HAL_Delay>
 800a6dc:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800a6e0:	4906      	ldr	r1, [pc, #24]	; (800a6fc <SFU_EXCPT_Security_Error+0x30>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800a6e2:	4b07      	ldr	r3, [pc, #28]	; (800a700 <SFU_EXCPT_Security_Error+0x34>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800a6e4:	68ca      	ldr	r2, [r1, #12]
 800a6e6:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800a6ea:	4313      	orrs	r3, r2
 800a6ec:	60cb      	str	r3, [r1, #12]
 800a6ee:	f3bf 8f4f 	dsb	sy
    __NOP();
 800a6f2:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 800a6f4:	e7fd      	b.n	800a6f2 <SFU_EXCPT_Security_Error+0x26>
 800a6f6:	bf00      	nop
 800a6f8:	08010c5f 	.word	0x08010c5f
 800a6fc:	e000ed00 	.word	0xe000ed00
 800a700:	05fa0004 	.word	0x05fa0004

0800a704 <SFU_EXCPT_Init>:
       ...
  */
  e_ret_status = SFU_SUCCESS;

  return e_ret_status;
}
 800a704:	4800      	ldr	r0, [pc, #0]	; (800a708 <SFU_EXCPT_Init+0x4>)
 800a706:	4770      	bx	lr
 800a708:	00122f11 	.word	0x00122f11

0800a70c <SFU_EXCPT_DeInit>:
 800a70c:	4800      	ldr	r0, [pc, #0]	; (800a710 <SFU_EXCPT_DeInit+0x4>)
 800a70e:	4770      	bx	lr
 800a710:	00122f11 	.word	0x00122f11

0800a714 <SFU_IMG_CheckCandidateVersion>:
#elif defined(__GNUC__)
__attribute__((optimize("O0")))
#endif /* __ICCARM__ */

SFU_ErrorStatus SFU_IMG_CheckCandidateVersion(uint32_t DwlSlot)
{
 800a714:	b580      	push	{r7, lr}
 800a716:	b086      	sub	sp, #24
 800a718:	af00      	add	r7, sp, #0
 800a71a:	6078      	str	r0, [r7, #4]
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
 800a71c:	f641 73e1 	movw	r3, #8161	; 0x1fe1
 800a720:	617b      	str	r3, [r7, #20]
   * - Check version is allowed
   *      SFU_IMG_GetActiveFwVersion() returns 0 if the header of active firmware is not valid
   */

  /* Header analysis to find slot based on number with magic tag */
  active_slot = SFU_IMG_GetFwImageSlot(&fw_image_header_to_test);
 800a722:	4828      	ldr	r0, [pc, #160]	; (800a7c4 <SFU_IMG_CheckCandidateVersion+0xb0>)
 800a724:	f000 fb5e 	bl	800ade4 <SFU_IMG_GetFwImageSlot>
 800a728:	6138      	str	r0, [r7, #16]

  /* Get the version of active_slot */
  cur_ver = SFU_IMG_GetActiveFwVersion(active_slot);
 800a72a:	6938      	ldr	r0, [r7, #16]
 800a72c:	f000 fbb0 	bl	800ae90 <SFU_IMG_GetActiveFwVersion>
 800a730:	4603      	mov	r3, r0
 800a732:	81fb      	strh	r3, [r7, #14]

  if (SFU_IMG_CheckFwVersion(active_slot, cur_ver, fw_image_header_to_test.FwVersion) != SFU_SUCCESS)
 800a734:	4b23      	ldr	r3, [pc, #140]	; (800a7c4 <SFU_IMG_CheckCandidateVersion+0xb0>)
 800a736:	88da      	ldrh	r2, [r3, #6]
 800a738:	89fb      	ldrh	r3, [r7, #14]
 800a73a:	4619      	mov	r1, r3
 800a73c:	6938      	ldr	r0, [r7, #16]
 800a73e:	f000 fbe1 	bl	800af04 <SFU_IMG_CheckFwVersion>
 800a742:	4603      	mov	r3, r0
 800a744:	4a20      	ldr	r2, [pc, #128]	; (800a7c8 <SFU_IMG_CheckCandidateVersion+0xb4>)
 800a746:	4293      	cmp	r3, r2
 800a748:	d029      	beq.n	800a79e <SFU_IMG_CheckCandidateVersion+0x8a>
  {
    /* The installation is forbidden */
    /* Memorize this error as this will be handled as a critical failure */
    SFU_EXCPT_SetError(SFU_EXCPT_VERSION_ERR);
 800a74a:	2017      	movs	r0, #23
 800a74c:	f7ff ff8c 	bl	800a668 <SFU_EXCPT_SetError>

    /* We would enter an infinite loop of installation attempts if we do not clean-up the dwl slot header */
    e_ret_status = SFU_LL_FLASH_Erase_Size(&flash_if_status, (uint8_t *)SlotStartAdd[DwlSlot], SFU_IMG_IMAGE_OFFSET);
 800a750:	4a1e      	ldr	r2, [pc, #120]	; (800a7cc <SFU_IMG_CheckCandidateVersion+0xb8>)
 800a752:	687b      	ldr	r3, [r7, #4]
 800a754:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800a758:	4619      	mov	r1, r3
 800a75a:	f107 030b 	add.w	r3, r7, #11
 800a75e:	f44f 7200 	mov.w	r2, #512	; 0x200
 800a762:	4618      	mov	r0, r3
 800a764:	f002 f948 	bl	800c9f8 <SFU_LL_FLASH_Erase_Size>
 800a768:	6178      	str	r0, [r7, #20]
    STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_ERASE_FAILED);
 800a76a:	697b      	ldr	r3, [r7, #20]
 800a76c:	f641 72e1 	movw	r2, #8161	; 0x1fe1
 800a770:	4293      	cmp	r3, r2
 800a772:	d10f      	bne.n	800a794 <SFU_IMG_CheckCandidateVersion+0x80>
 800a774:	4b16      	ldr	r3, [pc, #88]	; (800a7d0 <SFU_IMG_CheckCandidateVersion+0xbc>)
 800a776:	2201      	movs	r2, #1
 800a778:	701a      	strb	r2, [r3, #0]
 800a77a:	4b16      	ldr	r3, [pc, #88]	; (800a7d4 <SFU_IMG_CheckCandidateVersion+0xc0>)
 800a77c:	f240 4261 	movw	r2, #1121	; 0x461
 800a780:	601a      	str	r2, [r3, #0]
 800a782:	4b13      	ldr	r3, [pc, #76]	; (800a7d0 <SFU_IMG_CheckCandidateVersion+0xbc>)
 800a784:	781b      	ldrb	r3, [r3, #0]
 800a786:	4619      	mov	r1, r3
 800a788:	4b12      	ldr	r3, [pc, #72]	; (800a7d4 <SFU_IMG_CheckCandidateVersion+0xc0>)
 800a78a:	681a      	ldr	r2, [r3, #0]
 800a78c:	4b12      	ldr	r3, [pc, #72]	; (800a7d8 <SFU_IMG_CheckCandidateVersion+0xc4>)
 800a78e:	4813      	ldr	r0, [pc, #76]	; (800a7dc <SFU_IMG_CheckCandidateVersion+0xc8>)
 800a790:	f004 fab2 	bl	800ecf8 <iprintf>
 800a794:	bf00      	nop

    /* leave now to handle the critical failure in the appropriate FSM state */
    e_ret_status = SFU_ERROR;
 800a796:	f641 73e1 	movw	r3, #8161	; 0x1fe1
 800a79a:	617b      	str	r3, [r7, #20]
 800a79c:	e00c      	b.n	800a7b8 <SFU_IMG_CheckCandidateVersion+0xa4>
  }
  else
  {
    /* the anti-rollback check succeeds: the version is fine */
    /* double check to avoid basic hardware attack attack */
    verif_ver = SFU_IMG_GetActiveFwVersion(active_slot);
 800a79e:	6938      	ldr	r0, [r7, #16]
 800a7a0:	f000 fb76 	bl	800ae90 <SFU_IMG_GetActiveFwVersion>
 800a7a4:	4603      	mov	r3, r0
 800a7a6:	81bb      	strh	r3, [r7, #12]
    e_ret_status = SFU_IMG_CheckFwVersion(active_slot, verif_ver, fw_image_header_to_test.FwVersion);
 800a7a8:	4b06      	ldr	r3, [pc, #24]	; (800a7c4 <SFU_IMG_CheckCandidateVersion+0xb0>)
 800a7aa:	88da      	ldrh	r2, [r3, #6]
 800a7ac:	89bb      	ldrh	r3, [r7, #12]
 800a7ae:	4619      	mov	r1, r3
 800a7b0:	6938      	ldr	r0, [r7, #16]
 800a7b2:	f000 fba7 	bl	800af04 <SFU_IMG_CheckFwVersion>
 800a7b6:	6178      	str	r0, [r7, #20]
  }

  /* Return the result */
  return (e_ret_status);
 800a7b8:	697b      	ldr	r3, [r7, #20]
}
 800a7ba:	4618      	mov	r0, r3
 800a7bc:	3718      	adds	r7, #24
 800a7be:	46bd      	mov	sp, r7
 800a7c0:	bd80      	pop	{r7, pc}
 800a7c2:	bf00      	nop
 800a7c4:	20003c6c 	.word	0x20003c6c
 800a7c8:	00122f11 	.word	0x00122f11
 800a7cc:	08010f28 	.word	0x08010f28
 800a7d0:	20003db0 	.word	0x20003db0
 800a7d4:	20003dac 	.word	0x20003dac
 800a7d8:	0800fef8 	.word	0x0800fef8
 800a7dc:	0800ff80 	.word	0x0800ff80

0800a7e0 <MemoryCompare>:
  for (i = 0U; i < Size; i++)
 800a7e0:	2300      	movs	r3, #0
{
 800a7e2:	b570      	push	{r4, r5, r6, lr}
  uint8_t result = 0x00U;
 800a7e4:	461c      	mov	r4, r3
  for (i = 0U; i < Size; i++)
 800a7e6:	4293      	cmp	r3, r2
 800a7e8:	d106      	bne.n	800a7f8 <MemoryCompare+0x18>
}
 800a7ea:	4806      	ldr	r0, [pc, #24]	; (800a804 <MemoryCompare+0x24>)
 800a7ec:	f641 73e1 	movw	r3, #8161	; 0x1fe1
 800a7f0:	2c00      	cmp	r4, #0
 800a7f2:	bf18      	it	ne
 800a7f4:	4618      	movne	r0, r3
 800a7f6:	bd70      	pop	{r4, r5, r6, pc}
    result |= pAdd1[i] ^ pAdd2[i];
 800a7f8:	5cc5      	ldrb	r5, [r0, r3]
 800a7fa:	5cce      	ldrb	r6, [r1, r3]
 800a7fc:	4075      	eors	r5, r6
 800a7fe:	432c      	orrs	r4, r5
  for (i = 0U; i < Size; i++)
 800a800:	3301      	adds	r3, #1
 800a802:	e7f0      	b.n	800a7e6 <MemoryCompare+0x6>
 800a804:	00122f11 	.word	0x00122f11

0800a808 <VerifyFwSignatureScatter.part.0>:
SFU_ErrorStatus VerifyFwSignatureScatter(SE_StatusTypeDef *pSeStatus, uint32_t SlotNumber,
 800a808:	e92d 4f70 	stmdb	sp!, {r4, r5, r6, r8, r9, sl, fp, lr}
 800a80c:	f5ad 6d05 	sub.w	sp, sp, #2128	; 0x850
 800a810:	4604      	mov	r4, r0
 800a812:	9106      	str	r1, [sp, #24]
 800a814:	4611      	mov	r1, r2
 800a816:	f8dd 2870 	ldr.w	r2, [sp, #2160]	; 0x870
 800a81a:	4698      	mov	r8, r3
  if (SE_FwType == SE_FW_IMAGE_COMPLETE)
 800a81c:	2a00      	cmp	r2, #0
 800a81e:	d16e      	bne.n	800a8fe <VerifyFwSignatureScatter.part.0+0xf6>
    fw_size = pSE_Metadata->FwSize;
 800a820:	688b      	ldr	r3, [r1, #8]
 800a822:	9303      	str	r3, [sp, #12]
    fw_tag = pSE_Metadata->FwTag;
 800a824:	f101 0314 	add.w	r3, r1, #20
 800a828:	9305      	str	r3, [sp, #20]
  if ((pSE_Payload->PayloadSize[0] + pSE_Payload->PayloadSize[1]) != fw_size)
 800a82a:	e9d8 3002 	ldrd	r3, r0, [r8, #8]
 800a82e:	9d03      	ldr	r5, [sp, #12]
 800a830:	4403      	add	r3, r0
 800a832:	42ab      	cmp	r3, r5
 800a834:	d165      	bne.n	800a902 <VerifyFwSignatureScatter.part.0+0xfa>
    scatter_nb = 1U;
 800a836:	2800      	cmp	r0, #0
  se_ret_status = SE_AuthenticateFW_Init(pSeStatus, pSE_Metadata, SE_FwType);
 800a838:	4620      	mov	r0, r4
    scatter_nb = 1U;
 800a83a:	bf14      	ite	ne
 800a83c:	2502      	movne	r5, #2
 800a83e:	2501      	moveq	r5, #1
  se_ret_status = SE_AuthenticateFW_Init(pSeStatus, pSE_Metadata, SE_FwType);
 800a840:	f001 fc10 	bl	800c064 <SFU_AuthenticateFW_Init>
  if ((se_ret_status == SE_SUCCESS) && (*pSeStatus == SE_OK))
 800a844:	4a66      	ldr	r2, [pc, #408]	; (800a9e0 <VerifyFwSignatureScatter.part.0+0x1d8>)
 800a846:	9207      	str	r2, [sp, #28]
 800a848:	4290      	cmp	r0, r2
  se_ret_status = SE_AuthenticateFW_Init(pSeStatus, pSE_Metadata, SE_FwType);
 800a84a:	4603      	mov	r3, r0
  if ((se_ret_status == SE_SUCCESS) && (*pSeStatus == SE_OK))
 800a84c:	d159      	bne.n	800a902 <VerifyFwSignatureScatter.part.0+0xfa>
 800a84e:	6821      	ldr	r1, [r4, #0]
 800a850:	4a64      	ldr	r2, [pc, #400]	; (800a9e4 <VerifyFwSignatureScatter.part.0+0x1dc>)
 800a852:	4291      	cmp	r1, r2
 800a854:	d155      	bne.n	800a902 <VerifyFwSignatureScatter.part.0+0xfa>
 800a856:	eb08 0285 	add.w	r2, r8, r5, lsl #2
  SFU_ErrorStatus sfu_ret_status = SFU_SUCCESS;
 800a85a:	4d63      	ldr	r5, [pc, #396]	; (800a9e8 <VerifyFwSignatureScatter.part.0+0x1e0>)
 800a85c:	9209      	str	r2, [sp, #36]	; 0x24
  uint32_t fw_verified_total_size = 0; /* number of bytes that have been processed during authentication check */
 800a85e:	f04f 0900 	mov.w	r9, #0
      fw_chunk_size = CHUNK_SIZE_SIGN_VERIFICATION;
 800a862:	ae0b      	add	r6, sp, #44	; 0x2c
      payloadsize = pSE_Payload->PayloadSize[j];
 800a864:	f8d8 2008 	ldr.w	r2, [r8, #8]
 800a868:	9204      	str	r2, [sp, #16]
      fw_chunk_size = CHUNK_SIZE_SIGN_VERIFICATION;
 800a86a:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800a86e:	6032      	str	r2, [r6, #0]
      while ((i < (payloadsize / CHUNK_SIZE_SIGN_VERIFICATION)) && (*pSeStatus == SE_OK) &&
 800a870:	9a04      	ldr	r2, [sp, #16]
      ppayload = pSE_Payload->pPayload[j];
 800a872:	f858 ab04 	ldr.w	sl, [r8], #4
      while ((i < (payloadsize / CHUNK_SIZE_SIGN_VERIFICATION)) && (*pSeStatus == SE_OK) &&
 800a876:	0a92      	lsrs	r2, r2, #10
 800a878:	9208      	str	r2, [sp, #32]
      i = 0;
 800a87a:	f04f 0b00 	mov.w	fp, #0
      while ((i < (payloadsize / CHUNK_SIZE_SIGN_VERIFICATION)) && (*pSeStatus == SE_OK) &&
 800a87e:	9a08      	ldr	r2, [sp, #32]
 800a880:	4593      	cmp	fp, r2
 800a882:	d151      	bne.n	800a928 <VerifyFwSignatureScatter.part.0+0x120>
      fw_chunk_size = pSE_Payload->pPayload[j] + pSE_Payload->PayloadSize[j] - ppayload;
 800a884:	f858 2c04 	ldr.w	r2, [r8, #-4]
 800a888:	f8d8 1004 	ldr.w	r1, [r8, #4]
 800a88c:	440a      	add	r2, r1
 800a88e:	eba2 020a 	sub.w	r2, r2, sl
 800a892:	6032      	str	r2, [r6, #0]
      if ((fw_chunk_size != 0U) && (se_ret_status == SE_SUCCESS) && (*pSeStatus == SE_OK))
 800a894:	2a00      	cmp	r2, #0
 800a896:	d167      	bne.n	800a968 <VerifyFwSignatureScatter.part.0+0x160>
    for (j = 0; j < scatter_nb; j++)
 800a898:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800a89a:	4590      	cmp	r8, r2
 800a89c:	d1e2      	bne.n	800a864 <VerifyFwSignatureScatter.part.0+0x5c>
  if ((sfu_ret_status == SFU_SUCCESS) && (se_ret_status == SE_SUCCESS) && (*pSeStatus == SE_OK))
 800a89e:	4a52      	ldr	r2, [pc, #328]	; (800a9e8 <VerifyFwSignatureScatter.part.0+0x1e0>)
 800a8a0:	4295      	cmp	r5, r2
 800a8a2:	d12e      	bne.n	800a902 <VerifyFwSignatureScatter.part.0+0xfa>
 800a8a4:	9a07      	ldr	r2, [sp, #28]
 800a8a6:	4293      	cmp	r3, r2
 800a8a8:	d12b      	bne.n	800a902 <VerifyFwSignatureScatter.part.0+0xfa>
 800a8aa:	6826      	ldr	r6, [r4, #0]
 800a8ac:	4a4d      	ldr	r2, [pc, #308]	; (800a9e4 <VerifyFwSignatureScatter.part.0+0x1dc>)
 800a8ae:	4296      	cmp	r6, r2
 800a8b0:	d127      	bne.n	800a902 <VerifyFwSignatureScatter.part.0+0xfa>
    if (fw_verified_total_size <= fw_size)
 800a8b2:	9a03      	ldr	r2, [sp, #12]
 800a8b4:	454a      	cmp	r2, r9
 800a8b6:	d324      	bcc.n	800a902 <VerifyFwSignatureScatter.part.0+0xfa>
      fw_tag_len = sizeof(fw_tag_output);
 800a8b8:	2220      	movs	r2, #32
 800a8ba:	920a      	str	r2, [sp, #40]	; 0x28
      se_ret_status =   SE_AuthenticateFW_Finish(pSeStatus, fw_tag_output, (int32_t *)&fw_tag_len);
 800a8bc:	a90c      	add	r1, sp, #48	; 0x30
 800a8be:	aa0a      	add	r2, sp, #40	; 0x28
 800a8c0:	4620      	mov	r0, r4
 800a8c2:	9303      	str	r3, [sp, #12]
 800a8c4:	f001 fc1c 	bl	800c100 <SFU_AuthenticateFW_Finish>
      if ((se_ret_status == SE_SUCCESS) && (*pSeStatus == SE_OK) && (fw_tag_len == SE_TAG_LEN))
 800a8c8:	9b03      	ldr	r3, [sp, #12]
 800a8ca:	4298      	cmp	r0, r3
 800a8cc:	d119      	bne.n	800a902 <VerifyFwSignatureScatter.part.0+0xfa>
 800a8ce:	6823      	ldr	r3, [r4, #0]
 800a8d0:	42b3      	cmp	r3, r6
 800a8d2:	d116      	bne.n	800a902 <VerifyFwSignatureScatter.part.0+0xfa>
 800a8d4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800a8d6:	2a20      	cmp	r2, #32
 800a8d8:	d113      	bne.n	800a902 <VerifyFwSignatureScatter.part.0+0xfa>
        if (MemoryCompare(fw_tag_output, fw_tag, SE_TAG_LEN) != SFU_SUCCESS)
 800a8da:	9905      	ldr	r1, [sp, #20]
 800a8dc:	a80c      	add	r0, sp, #48	; 0x30
 800a8de:	f7ff ff7f 	bl	800a7e0 <MemoryCompare>
 800a8e2:	42a8      	cmp	r0, r5
 800a8e4:	4602      	mov	r2, r0
 800a8e6:	d063      	beq.n	800a9b0 <VerifyFwSignatureScatter.part.0+0x1a8>
          *pSeStatus = SE_SIGNATURE_ERR;
 800a8e8:	4b40      	ldr	r3, [pc, #256]	; (800a9ec <VerifyFwSignatureScatter.part.0+0x1e4>)
 800a8ea:	6023      	str	r3, [r4, #0]
          if ((SlotNumber >= SLOT_ACTIVE_1) && (SlotNumber < SLOT_DWL_1))
 800a8ec:	9b06      	ldr	r3, [sp, #24]
 800a8ee:	2b01      	cmp	r3, #1
 800a8f0:	d107      	bne.n	800a902 <VerifyFwSignatureScatter.part.0+0xfa>
            (void) memset(&fw_tag_validated[SlotNumber - SLOT_ACTIVE_1][0U], 0x00, SE_TAG_LEN);
 800a8f2:	2220      	movs	r2, #32
 800a8f4:	2100      	movs	r1, #0
 800a8f6:	483e      	ldr	r0, [pc, #248]	; (800a9f0 <VerifyFwSignatureScatter.part.0+0x1e8>)
 800a8f8:	f004 f9f6 	bl	800ece8 <memset>
 800a8fc:	e001      	b.n	800a902 <VerifyFwSignatureScatter.part.0+0xfa>
  else if (SE_FwType == SE_FW_IMAGE_PARTIAL)
 800a8fe:	2a01      	cmp	r2, #1
 800a900:	d006      	beq.n	800a910 <VerifyFwSignatureScatter.part.0+0x108>
          sfu_ret_status = SFU_ERROR;
 800a902:	f641 72e1 	movw	r2, #8161	; 0x1fe1
}
 800a906:	4610      	mov	r0, r2
 800a908:	f50d 6d05 	add.w	sp, sp, #2128	; 0x850
 800a90c:	e8bd 8f70 	ldmia.w	sp!, {r4, r5, r6, r8, r9, sl, fp, pc}
    fw_size = pSE_Metadata->PartialFwSize;
 800a910:	690b      	ldr	r3, [r1, #16]
 800a912:	9303      	str	r3, [sp, #12]
    fw_tag = pSE_Metadata->PartialFwTag;
 800a914:	f101 0334 	add.w	r3, r1, #52	; 0x34
 800a918:	9305      	str	r3, [sp, #20]
 800a91a:	e786      	b.n	800a82a <VerifyFwSignatureScatter.part.0+0x22>
          *pSeStatus = SE_ERR_FLASH_READ;
 800a91c:	4b35      	ldr	r3, [pc, #212]	; (800a9f4 <VerifyFwSignatureScatter.part.0+0x1ec>)
 800a91e:	6023      	str	r3, [r4, #0]
          sfu_ret_status = SFU_ERROR;
 800a920:	f641 75e1 	movw	r5, #8161	; 0x1fe1
          se_ret_status = SE_ERROR;
 800a924:	4b34      	ldr	r3, [pc, #208]	; (800a9f8 <VerifyFwSignatureScatter.part.0+0x1f0>)
 800a926:	e019      	b.n	800a95c <VerifyFwSignatureScatter.part.0+0x154>
      while ((i < (payloadsize / CHUNK_SIZE_SIGN_VERIFICATION)) && (*pSeStatus == SE_OK) &&
 800a928:	6822      	ldr	r2, [r4, #0]
 800a92a:	492e      	ldr	r1, [pc, #184]	; (800a9e4 <VerifyFwSignatureScatter.part.0+0x1dc>)
 800a92c:	428a      	cmp	r2, r1
 800a92e:	d1a9      	bne.n	800a884 <VerifyFwSignatureScatter.part.0+0x7c>
 800a930:	4a2d      	ldr	r2, [pc, #180]	; (800a9e8 <VerifyFwSignatureScatter.part.0+0x1e0>)
 800a932:	4295      	cmp	r5, r2
 800a934:	d1a6      	bne.n	800a884 <VerifyFwSignatureScatter.part.0+0x7c>
        sfu_ret_status = SFU_LL_FLASH_Read(fw_image_chunk, (uint8_t *)ppayload, fw_chunk_size) ;
 800a936:	6832      	ldr	r2, [r6, #0]
 800a938:	4651      	mov	r1, sl
 800a93a:	f50d 608a 	add.w	r0, sp, #1104	; 0x450
 800a93e:	f002 f869 	bl	800ca14 <SFU_LL_FLASH_Read>
        if (sfu_ret_status == SFU_SUCCESS)
 800a942:	4b29      	ldr	r3, [pc, #164]	; (800a9e8 <VerifyFwSignatureScatter.part.0+0x1e0>)
 800a944:	4298      	cmp	r0, r3
        sfu_ret_status = SFU_LL_FLASH_Read(fw_image_chunk, (uint8_t *)ppayload, fw_chunk_size) ;
 800a946:	4605      	mov	r5, r0
        if (sfu_ret_status == SFU_SUCCESS)
 800a948:	d1e8      	bne.n	800a91c <VerifyFwSignatureScatter.part.0+0x114>
          se_ret_status = SE_AuthenticateFW_Append(pSeStatus, fw_image_chunk, (int32_t)fw_chunk_size,
 800a94a:	9600      	str	r6, [sp, #0]
 800a94c:	ab14      	add	r3, sp, #80	; 0x50
 800a94e:	6832      	ldr	r2, [r6, #0]
 800a950:	f50d 618a 	add.w	r1, sp, #1104	; 0x450
 800a954:	4620      	mov	r0, r4
 800a956:	f001 fbb9 	bl	800c0cc <SFU_AuthenticateFW_Append>
 800a95a:	4603      	mov	r3, r0
        ppayload += fw_chunk_size;
 800a95c:	6832      	ldr	r2, [r6, #0]
        i++;
 800a95e:	f10b 0b01 	add.w	fp, fp, #1
        ppayload += fw_chunk_size;
 800a962:	4492      	add	sl, r2
        fw_verified_total_size += fw_chunk_size;
 800a964:	4491      	add	r9, r2
        i++;
 800a966:	e78a      	b.n	800a87e <VerifyFwSignatureScatter.part.0+0x76>
      if ((fw_chunk_size != 0U) && (se_ret_status == SE_SUCCESS) && (*pSeStatus == SE_OK))
 800a968:	9907      	ldr	r1, [sp, #28]
 800a96a:	428b      	cmp	r3, r1
 800a96c:	d194      	bne.n	800a898 <VerifyFwSignatureScatter.part.0+0x90>
 800a96e:	6820      	ldr	r0, [r4, #0]
 800a970:	491c      	ldr	r1, [pc, #112]	; (800a9e4 <VerifyFwSignatureScatter.part.0+0x1dc>)
 800a972:	4288      	cmp	r0, r1
 800a974:	d190      	bne.n	800a898 <VerifyFwSignatureScatter.part.0+0x90>
        sfu_ret_status = SFU_LL_FLASH_Read(fw_image_chunk, (uint8_t *)ppayload, fw_chunk_size) ;
 800a976:	4651      	mov	r1, sl
 800a978:	f50d 608a 	add.w	r0, sp, #1104	; 0x450
 800a97c:	f002 f84a 	bl	800ca14 <SFU_LL_FLASH_Read>
        if (sfu_ret_status == SFU_SUCCESS)
 800a980:	4b19      	ldr	r3, [pc, #100]	; (800a9e8 <VerifyFwSignatureScatter.part.0+0x1e0>)
 800a982:	4298      	cmp	r0, r3
        sfu_ret_status = SFU_LL_FLASH_Read(fw_image_chunk, (uint8_t *)ppayload, fw_chunk_size) ;
 800a984:	4605      	mov	r5, r0
        if (sfu_ret_status == SFU_SUCCESS)
 800a986:	d10d      	bne.n	800a9a4 <VerifyFwSignatureScatter.part.0+0x19c>
          se_ret_status = SE_AuthenticateFW_Append(pSeStatus, fw_image_chunk,
 800a988:	9a04      	ldr	r2, [sp, #16]
 800a98a:	9600      	str	r6, [sp, #0]
 800a98c:	ab14      	add	r3, sp, #80	; 0x50
 800a98e:	eba2 228b 	sub.w	r2, r2, fp, lsl #10
 800a992:	f50d 618a 	add.w	r1, sp, #1104	; 0x450
 800a996:	4620      	mov	r0, r4
 800a998:	f001 fb98 	bl	800c0cc <SFU_AuthenticateFW_Append>
 800a99c:	4603      	mov	r3, r0
        fw_verified_total_size += fw_chunk_size;
 800a99e:	6832      	ldr	r2, [r6, #0]
 800a9a0:	4491      	add	r9, r2
 800a9a2:	e779      	b.n	800a898 <VerifyFwSignatureScatter.part.0+0x90>
          *pSeStatus = SE_ERR_FLASH_READ;
 800a9a4:	4b13      	ldr	r3, [pc, #76]	; (800a9f4 <VerifyFwSignatureScatter.part.0+0x1ec>)
 800a9a6:	6023      	str	r3, [r4, #0]
          sfu_ret_status = SFU_ERROR;
 800a9a8:	f641 75e1 	movw	r5, #8161	; 0x1fe1
          se_ret_status = SE_ERROR;
 800a9ac:	4b12      	ldr	r3, [pc, #72]	; (800a9f8 <VerifyFwSignatureScatter.part.0+0x1f0>)
 800a9ae:	e7f6      	b.n	800a99e <VerifyFwSignatureScatter.part.0+0x196>
          FLOW_STEP(uFlowCryptoValue, FLOW_STEP_INTEGRITY);
 800a9b0:	4912      	ldr	r1, [pc, #72]	; (800a9fc <VerifyFwSignatureScatter.part.0+0x1f4>)
 800a9b2:	680b      	ldr	r3, [r1, #0]
 800a9b4:	f483 432a 	eor.w	r3, r3, #43520	; 0xaa00
 800a9b8:	f083 03b5 	eor.w	r3, r3, #181	; 0xb5
 800a9bc:	600b      	str	r3, [r1, #0]
          if ((SlotNumber >= SLOT_ACTIVE_1) && (SlotNumber < SLOT_DWL_1))
 800a9be:	9b06      	ldr	r3, [sp, #24]
 800a9c0:	2b01      	cmp	r3, #1
 800a9c2:	d1a0      	bne.n	800a906 <VerifyFwSignatureScatter.part.0+0xfe>
            (void) memcpy(&fw_tag_validated[SlotNumber - SLOT_ACTIVE_1][0U], fw_tag_output, SE_TAG_LEN);
 800a9c4:	4d0a      	ldr	r5, [pc, #40]	; (800a9f0 <VerifyFwSignatureScatter.part.0+0x1e8>)
 800a9c6:	ab0c      	add	r3, sp, #48	; 0x30
 800a9c8:	ae14      	add	r6, sp, #80	; 0x50
 800a9ca:	461c      	mov	r4, r3
 800a9cc:	cc03      	ldmia	r4!, {r0, r1}
 800a9ce:	42b4      	cmp	r4, r6
 800a9d0:	6028      	str	r0, [r5, #0]
 800a9d2:	6069      	str	r1, [r5, #4]
 800a9d4:	4623      	mov	r3, r4
 800a9d6:	f105 0508 	add.w	r5, r5, #8
 800a9da:	d1f6      	bne.n	800a9ca <VerifyFwSignatureScatter.part.0+0x1c2>
 800a9dc:	e793      	b.n	800a906 <VerifyFwSignatureScatter.part.0+0xfe>
 800a9de:	bf00      	nop
 800a9e0:	0012310f 	.word	0x0012310f
 800a9e4:	0012e223 	.word	0x0012e223
 800a9e8:	00122f11 	.word	0x00122f11
 800a9ec:	00146ac1 	.word	0x00146ac1
 800a9f0:	200038b6 	.word	0x200038b6
 800a9f4:	0014b817 	.word	0x0014b817
 800a9f8:	00018799 	.word	0x00018799
 800a9fc:	20003400 	.word	0x20003400

0800aa00 <VerifyFwSignatureScatter>:
{
 800aa00:	b430      	push	{r4, r5}
 800aa02:	9c02      	ldr	r4, [sp, #8]
  if ((pSeStatus == NULL) || (pSE_Metadata == NULL) || (pSE_Payload == NULL))
 800aa04:	b158      	cbz	r0, 800aa1e <VerifyFwSignatureScatter+0x1e>
 800aa06:	b152      	cbz	r2, 800aa1e <VerifyFwSignatureScatter+0x1e>
 800aa08:	b14b      	cbz	r3, 800aa1e <VerifyFwSignatureScatter+0x1e>
  if ((pSE_Payload->pPayload[0] == 0U) || ((pSE_Payload->pPayload[1] == 0U) && (pSE_Payload->PayloadSize[1] != 0U)))
 800aa0a:	681d      	ldr	r5, [r3, #0]
 800aa0c:	b13d      	cbz	r5, 800aa1e <VerifyFwSignatureScatter+0x1e>
 800aa0e:	685d      	ldr	r5, [r3, #4]
 800aa10:	b90d      	cbnz	r5, 800aa16 <VerifyFwSignatureScatter+0x16>
 800aa12:	68dd      	ldr	r5, [r3, #12]
 800aa14:	b91d      	cbnz	r5, 800aa1e <VerifyFwSignatureScatter+0x1e>
 800aa16:	9402      	str	r4, [sp, #8]
}
 800aa18:	bc30      	pop	{r4, r5}
 800aa1a:	f7ff bef5 	b.w	800a808 <VerifyFwSignatureScatter.part.0>
 800aa1e:	f641 70e1 	movw	r0, #8161	; 0x1fe1
 800aa22:	bc30      	pop	{r4, r5}
 800aa24:	4770      	bx	lr
	...

0800aa28 <ParseFWInfo>:
{
 800aa28:	b508      	push	{r3, lr}
  if ((pFwHeader == NULL) || (pBuffer == NULL))
 800aa2a:	b130      	cbz	r0, 800aa3a <ParseFWInfo+0x12>
 800aa2c:	b129      	cbz	r1, 800aa3a <ParseFWInfo+0x12>
  (void) memcpy(pFwHeader, pBuffer, sizeof(*pFwHeader));
 800aa2e:	f44f 72a0 	mov.w	r2, #320	; 0x140
 800aa32:	f004 f94b 	bl	800eccc <memcpy>
  return SFU_SUCCESS;
 800aa36:	4802      	ldr	r0, [pc, #8]	; (800aa40 <ParseFWInfo+0x18>)
}
 800aa38:	bd08      	pop	{r3, pc}
    return SFU_ERROR;
 800aa3a:	f641 70e1 	movw	r0, #8161	; 0x1fe1
 800aa3e:	e7fb      	b.n	800aa38 <ParseFWInfo+0x10>
 800aa40:	00122f11 	.word	0x00122f11

0800aa44 <VerifyFwSignature>:
{
 800aa44:	b570      	push	{r4, r5, r6, lr}
  *pSeStatus = SE_OK;
 800aa46:	4c14      	ldr	r4, [pc, #80]	; (800aa98 <VerifyFwSignature+0x54>)
 800aa48:	6004      	str	r4, [r0, #0]
{
 800aa4a:	b086      	sub	sp, #24
  if (pFwImageHeader == NULL)
 800aa4c:	b302      	cbz	r2, 800aa90 <VerifyFwSignature+0x4c>
  if ((SE_FwType != SE_FW_IMAGE_PARTIAL) && (SE_FwType != SE_FW_IMAGE_COMPLETE))
 800aa4e:	2b01      	cmp	r3, #1
 800aa50:	d81e      	bhi.n	800aa90 <VerifyFwSignature+0x4c>
  switch (SE_FwType)
 800aa52:	d012      	beq.n	800aa7a <VerifyFwSignature+0x36>
      fw_size = pFwImageHeader->FwSize;
 800aa54:	6896      	ldr	r6, [r2, #8]
      fw_offset = 0U;
 800aa56:	2500      	movs	r5, #0
  pse_payload.pPayload[0] = SlotStartAdd[SlotNumber] + fw_offset + SFU_IMG_IMAGE_OFFSET;
 800aa58:	4c10      	ldr	r4, [pc, #64]	; (800aa9c <VerifyFwSignature+0x58>)
  return  VerifyFwSignatureScatter(pSeStatus, SlotNumber, pFwImageHeader, &pse_payload, SE_FwType);
 800aa5a:	9300      	str	r3, [sp, #0]
  pse_payload.pPayload[0] = SlotStartAdd[SlotNumber] + fw_offset + SFU_IMG_IMAGE_OFFSET;
 800aa5c:	f854 4021 	ldr.w	r4, [r4, r1, lsl #2]
  pse_payload.PayloadSize[0] = fw_size;
 800aa60:	9604      	str	r6, [sp, #16]
  pse_payload.pPayload[0] = SlotStartAdd[SlotNumber] + fw_offset + SFU_IMG_IMAGE_OFFSET;
 800aa62:	f504 7400 	add.w	r4, r4, #512	; 0x200
 800aa66:	442c      	add	r4, r5
 800aa68:	9402      	str	r4, [sp, #8]
  return  VerifyFwSignatureScatter(pSeStatus, SlotNumber, pFwImageHeader, &pse_payload, SE_FwType);
 800aa6a:	ab02      	add	r3, sp, #8
  pse_payload.pPayload[1] = 0U;
 800aa6c:	2400      	movs	r4, #0
 800aa6e:	9403      	str	r4, [sp, #12]
  pse_payload.PayloadSize[1] = 0U;
 800aa70:	9405      	str	r4, [sp, #20]
  return  VerifyFwSignatureScatter(pSeStatus, SlotNumber, pFwImageHeader, &pse_payload, SE_FwType);
 800aa72:	f7ff ffc5 	bl	800aa00 <VerifyFwSignatureScatter>
}
 800aa76:	b006      	add	sp, #24
 800aa78:	bd70      	pop	{r4, r5, r6, pc}
      fw_offset = pFwImageHeader->PartialFwOffset % SLOT_SIZE(SLOT_SWAP);
 800aa7a:	4c09      	ldr	r4, [pc, #36]	; (800aaa0 <VerifyFwSignature+0x5c>)
 800aa7c:	4d09      	ldr	r5, [pc, #36]	; (800aaa4 <VerifyFwSignature+0x60>)
 800aa7e:	f8d2 c00c 	ldr.w	ip, [r2, #12]
      fw_size = pFwImageHeader->PartialFwSize;
 800aa82:	6916      	ldr	r6, [r2, #16]
      fw_offset = pFwImageHeader->PartialFwOffset % SLOT_SIZE(SLOT_SWAP);
 800aa84:	1b2d      	subs	r5, r5, r4
 800aa86:	fbbc f4f5 	udiv	r4, ip, r5
 800aa8a:	fb05 c514 	mls	r5, r5, r4, ip
      break;
 800aa8e:	e7e3      	b.n	800aa58 <VerifyFwSignature+0x14>
    return SFU_ERROR;
 800aa90:	f641 70e1 	movw	r0, #8161	; 0x1fe1
 800aa94:	e7ef      	b.n	800aa76 <VerifyFwSignature+0x32>
 800aa96:	bf00      	nop
 800aa98:	0012e223 	.word	0x0012e223
 800aa9c:	08010f28 	.word	0x08010f28
 800aaa0:	08015000 	.word	0x08015000
 800aaa4:	08016000 	.word	0x08016000

0800aaa8 <VerifySlot>:
{
 800aaa8:	b410      	push	{r4}
  length = uSlotSize - SFU_IMG_IMAGE_OFFSET - uFwSize;
 800aaaa:	f5a1 7300 	sub.w	r3, r1, #512	; 0x200
  pdata = pSlotBegin + SFU_IMG_IMAGE_OFFSET + uFwSize;
 800aaae:	f502 7400 	add.w	r4, r2, #512	; 0x200
  e_ret_status = SFU_LL_FLASH_Compare(pdata, 0x00000000U, 0xFFFFFFFFU, length);
 800aab2:	1a9b      	subs	r3, r3, r2
 800aab4:	4420      	add	r0, r4
 800aab6:	f04f 32ff 	mov.w	r2, #4294967295
}
 800aaba:	bc10      	pop	{r4}
  e_ret_status = SFU_LL_FLASH_Compare(pdata, 0x00000000U, 0xFFFFFFFFU, length);
 800aabc:	2100      	movs	r1, #0
 800aabe:	f001 bfb0 	b.w	800ca22 <SFU_LL_FLASH_Compare>
	...

0800aac4 <CleanUpSlot>:
{
 800aac4:	e92d 4170 	stmdb	sp!, {r4, r5, r6, r8, lr}
 800aac8:	2400      	movs	r4, #0
 800aaca:	2500      	movs	r5, #0
 800aacc:	b087      	sub	sp, #28
    if (e_ret_status == SFU_SUCCESS)
 800aace:	f8df 8058 	ldr.w	r8, [pc, #88]	; 800ab28 <CleanUpSlot+0x64>
 800aad2:	e9cd 4502 	strd	r4, r5, [sp, #8]
  for (pdata = slot_begin + uOffset; pdata < (slot_begin + uSlotSize); pdata += sizeof(SFU_LL_FLASH_write_t))
 800aad6:	1846      	adds	r6, r0, r1
 800aad8:	1885      	adds	r5, r0, r2
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
 800aada:	f641 74e1 	movw	r4, #8161	; 0x1fe1
  for (pdata = slot_begin + uOffset; pdata < (slot_begin + uSlotSize); pdata += sizeof(SFU_LL_FLASH_write_t))
 800aade:	42ae      	cmp	r6, r5
 800aae0:	d803      	bhi.n	800aaea <CleanUpSlot+0x26>
}
 800aae2:	4620      	mov	r0, r4
 800aae4:	b007      	add	sp, #28
 800aae6:	e8bd 8170 	ldmia.w	sp!, {r4, r5, r6, r8, pc}
    e_ret_status =  SFU_LL_FLASH_Read((uint8_t *) &value, (uint8_t *) pdata, sizeof(SFU_LL_FLASH_write_t));
 800aaea:	2208      	movs	r2, #8
 800aaec:	4629      	mov	r1, r5
 800aaee:	a804      	add	r0, sp, #16
 800aaf0:	f001 ff90 	bl	800ca14 <SFU_LL_FLASH_Read>
    if (e_ret_status == SFU_SUCCESS)
 800aaf4:	4540      	cmp	r0, r8
    e_ret_status =  SFU_LL_FLASH_Read((uint8_t *) &value, (uint8_t *) pdata, sizeof(SFU_LL_FLASH_write_t));
 800aaf6:	4604      	mov	r4, r0
    if (e_ret_status == SFU_SUCCESS)
 800aaf8:	d106      	bne.n	800ab08 <CleanUpSlot+0x44>
      if (memcmp((void *) &value, (void *) &pattern, sizeof(SFU_LL_FLASH_write_t)) != 0)
 800aafa:	2208      	movs	r2, #8
 800aafc:	eb0d 0102 	add.w	r1, sp, r2
 800ab00:	a804      	add	r0, sp, #16
 800ab02:	f004 f8d5 	bl	800ecb0 <memcmp>
 800ab06:	b140      	cbz	r0, 800ab1a <CleanUpSlot+0x56>
      e_ret_status = SFU_LL_FLASH_Write(&flash_if_info, (uint8_t *) pdata, (uint8_t *) &pattern,
 800ab08:	2308      	movs	r3, #8
 800ab0a:	eb0d 0203 	add.w	r2, sp, r3
 800ab0e:	4629      	mov	r1, r5
 800ab10:	f10d 0007 	add.w	r0, sp, #7
 800ab14:	f001 ff77 	bl	800ca06 <SFU_LL_FLASH_Write>
 800ab18:	4604      	mov	r4, r0
    if ((pdata % 0x1000U) == 0U)
 800ab1a:	f3c5 030b 	ubfx	r3, r5, #0, #12
 800ab1e:	b90b      	cbnz	r3, 800ab24 <CleanUpSlot+0x60>
      (void) SFU_LL_SECU_IWDG_Refresh();
 800ab20:	f002 f9ac 	bl	800ce7c <SFU_LL_SECU_IWDG_Refresh>
  for (pdata = slot_begin + uOffset; pdata < (slot_begin + uSlotSize); pdata += sizeof(SFU_LL_FLASH_write_t))
 800ab24:	3508      	adds	r5, #8
 800ab26:	e7da      	b.n	800aade <CleanUpSlot+0x1a>
 800ab28:	00122f11 	.word	0x00122f11

0800ab2c <SFU_IMG_InitImageHandling>:
{
 800ab2c:	e92d 4170 	stmdb	sp!, {r4, r5, r6, r8, lr}
 800ab30:	b085      	sub	sp, #20
  (void) memset((uint8_t *) &fw_image_header_validated, 0xFE, sizeof(fw_image_header_validated));
 800ab32:	4833      	ldr	r0, [pc, #204]	; (800ac00 <SFU_IMG_InitImageHandling+0xd4>)
    start_add = SlotStartAdd[SLOT_ACTIVE_1 + i];
 800ab34:	4d33      	ldr	r5, [pc, #204]	; (800ac04 <SFU_IMG_InitImageHandling+0xd8>)
  (void) memset((uint8_t *) &fw_image_header_validated, 0xFE, sizeof(fw_image_header_validated));
 800ab36:	f44f 72a0 	mov.w	r2, #320	; 0x140
 800ab3a:	21fe      	movs	r1, #254	; 0xfe
 800ab3c:	f004 f8d4 	bl	800ece8 <memset>
    start_add = SlotStartAdd[SLOT_ACTIVE_1 + i];
 800ab40:	9500      	str	r5, [sp, #0]
    if (start_add != 0U)
 800ab42:	9c00      	ldr	r4, [sp, #0]
 800ab44:	b144      	cbz	r4, 800ab58 <SFU_IMG_InitImageHandling+0x2c>
      if (!IS_ALIGNED(SlotStartAdd[SLOT_ACTIVE_1 + i]))
 800ab46:	f3c5 040a 	ubfx	r4, r5, #0, #11
 800ab4a:	b12c      	cbz	r4, 800ab58 <SFU_IMG_InitImageHandling+0x2c>
        TRACE("\r\n= [FWIMG] SLOT_ACTIVE_%d (%x) is not properly aligned\r\n",
 800ab4c:	482e      	ldr	r0, [pc, #184]	; (800ac08 <SFU_IMG_InitImageHandling+0xdc>)
 800ab4e:	462a      	mov	r2, r5
 800ab50:	2101      	movs	r1, #1
 800ab52:	f004 f8d1 	bl	800ecf8 <iprintf>
        e_ret_status = SFU_IMG_INIT_FLASH_CONSTRAINTS_ERROR;
 800ab56:	2403      	movs	r4, #3
    start_add = SlotStartAdd[SLOT_DWL_1 + i];
 800ab58:	4e2c      	ldr	r6, [pc, #176]	; (800ac0c <SFU_IMG_InitImageHandling+0xe0>)
 800ab5a:	9601      	str	r6, [sp, #4]
    if (start_add != 0U)
 800ab5c:	9b01      	ldr	r3, [sp, #4]
 800ab5e:	b143      	cbz	r3, 800ab72 <SFU_IMG_InitImageHandling+0x46>
      if (!IS_ALIGNED(SlotStartAdd[SLOT_DWL_1 + i]))
 800ab60:	f3c6 030a 	ubfx	r3, r6, #0, #11
 800ab64:	b12b      	cbz	r3, 800ab72 <SFU_IMG_InitImageHandling+0x46>
        TRACE("\r\n= [FWIMG] SLOT_DWL_%d (%x) is not properly aligned\r\n",
 800ab66:	4a2a      	ldr	r2, [pc, #168]	; (800ac10 <SFU_IMG_InitImageHandling+0xe4>)
 800ab68:	482a      	ldr	r0, [pc, #168]	; (800ac14 <SFU_IMG_InitImageHandling+0xe8>)
 800ab6a:	2101      	movs	r1, #1
 800ab6c:	f004 f8c4 	bl	800ecf8 <iprintf>
        e_ret_status = SFU_IMG_INIT_FLASH_CONSTRAINTS_ERROR;
 800ab70:	2403      	movs	r4, #3
    start_add = SlotStartAdd[SLOT_ACTIVE_1 + i];
 800ab72:	9502      	str	r5, [sp, #8]
    if (start_add != 0U)
 800ab74:	9b02      	ldr	r3, [sp, #8]
 800ab76:	b153      	cbz	r3, 800ab8e <SFU_IMG_InitImageHandling+0x62>
      if (((SlotStartAdd[SLOT_ACTIVE_1 + i] - FLASH_BASE) / FLASH_PAGE_SIZE) <= SFU_PROTECT_WRP_PAGE_END_1)
 800ab78:	4b27      	ldr	r3, [pc, #156]	; (800ac18 <SFU_IMG_InitImageHandling+0xec>)
 800ab7a:	4a28      	ldr	r2, [pc, #160]	; (800ac1c <SFU_IMG_InitImageHandling+0xf0>)
 800ab7c:	0adb      	lsrs	r3, r3, #11
 800ab7e:	ebb3 2fd2 	cmp.w	r3, r2, lsr #11
 800ab82:	d304      	bcc.n	800ab8e <SFU_IMG_InitImageHandling+0x62>
        TRACE("\r\n= [FWIMG] SLOT_ACTIVE_%d overlaps SBSFU code area protected by WRP\r\n", i + 1U);
 800ab84:	4826      	ldr	r0, [pc, #152]	; (800ac20 <SFU_IMG_InitImageHandling+0xf4>)
 800ab86:	2101      	movs	r1, #1
 800ab88:	f004 f8b6 	bl	800ecf8 <iprintf>
        e_ret_status = SFU_IMG_INIT_FLASH_CONSTRAINTS_ERROR;
 800ab8c:	2403      	movs	r4, #3
    start_add = SlotStartAdd[SLOT_DWL_1 + i];
 800ab8e:	9603      	str	r6, [sp, #12]
    if (start_add != 0U)
 800ab90:	9b03      	ldr	r3, [sp, #12]
 800ab92:	b153      	cbz	r3, 800abaa <SFU_IMG_InitImageHandling+0x7e>
      if (((SlotStartAdd[SLOT_DWL_1 + i] - FLASH_BASE) / FLASH_PAGE_SIZE) <= SFU_PROTECT_WRP_PAGE_END_1)
 800ab94:	4b20      	ldr	r3, [pc, #128]	; (800ac18 <SFU_IMG_InitImageHandling+0xec>)
 800ab96:	4a23      	ldr	r2, [pc, #140]	; (800ac24 <SFU_IMG_InitImageHandling+0xf8>)
 800ab98:	0adb      	lsrs	r3, r3, #11
 800ab9a:	ebb3 2fd2 	cmp.w	r3, r2, lsr #11
 800ab9e:	d304      	bcc.n	800abaa <SFU_IMG_InitImageHandling+0x7e>
        TRACE("\r\n= [FWIMG] SLOT_DWL_%d overlaps SBSFU code area protected by WRP\r\n", i + 1U);
 800aba0:	4821      	ldr	r0, [pc, #132]	; (800ac28 <SFU_IMG_InitImageHandling+0xfc>)
 800aba2:	2101      	movs	r1, #1
 800aba4:	f004 f8a8 	bl	800ecf8 <iprintf>
        e_ret_status = SFU_IMG_INIT_FLASH_CONSTRAINTS_ERROR;
 800aba8:	2403      	movs	r4, #3
  if (!(((SB_REGION_ROM_START) > KMS_DATASTORAGE_END)
 800abaa:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 800ac4c <SFU_IMG_InitImageHandling+0x120>
 800abae:	4b1f      	ldr	r3, [pc, #124]	; (800ac2c <SFU_IMG_InitImageHandling+0x100>)
 800abb0:	4598      	cmp	r8, r3
 800abb2:	d307      	bcc.n	800abc4 <SFU_IMG_InitImageHandling+0x98>
 800abb4:	4a1e      	ldr	r2, [pc, #120]	; (800ac30 <SFU_IMG_InitImageHandling+0x104>)
 800abb6:	4b1f      	ldr	r3, [pc, #124]	; (800ac34 <SFU_IMG_InitImageHandling+0x108>)
 800abb8:	429a      	cmp	r2, r3
 800abba:	d803      	bhi.n	800abc4 <SFU_IMG_InitImageHandling+0x98>
    TRACE("\r\n= [FWIMG] KMS NVM area overlaps SB Code area\r\n");
 800abbc:	481e      	ldr	r0, [pc, #120]	; (800ac38 <SFU_IMG_InitImageHandling+0x10c>)
 800abbe:	f004 f935 	bl	800ee2c <puts>
    e_ret_status = SFU_IMG_INIT_FLASH_CONSTRAINTS_ERROR;
 800abc2:	2403      	movs	r4, #3
      if (!(((SlotStartAdd[SLOT_ACTIVE_1 + i]) > KMS_DATASTORAGE_END)
 800abc4:	4545      	cmp	r5, r8
 800abc6:	d808      	bhi.n	800abda <SFU_IMG_InitImageHandling+0xae>
 800abc8:	4a1c      	ldr	r2, [pc, #112]	; (800ac3c <SFU_IMG_InitImageHandling+0x110>)
 800abca:	4b19      	ldr	r3, [pc, #100]	; (800ac30 <SFU_IMG_InitImageHandling+0x104>)
 800abcc:	429a      	cmp	r2, r3
 800abce:	d304      	bcc.n	800abda <SFU_IMG_InitImageHandling+0xae>
        TRACE("\r\n= [FWIMG] KMS NVM area overlaps SLOT_ACTIVE_%d area\r\n", i + 1U);
 800abd0:	481b      	ldr	r0, [pc, #108]	; (800ac40 <SFU_IMG_InitImageHandling+0x114>)
 800abd2:	2101      	movs	r1, #1
 800abd4:	f004 f890 	bl	800ecf8 <iprintf>
        e_ret_status = SFU_IMG_INIT_FLASH_CONSTRAINTS_ERROR;
 800abd8:	2403      	movs	r4, #3
      if (!(((SlotStartAdd[SLOT_DWL_1 + i]) > KMS_DATASTORAGE_END)
 800abda:	4546      	cmp	r6, r8
 800abdc:	d808      	bhi.n	800abf0 <SFU_IMG_InitImageHandling+0xc4>
 800abde:	4a19      	ldr	r2, [pc, #100]	; (800ac44 <SFU_IMG_InitImageHandling+0x118>)
 800abe0:	4b13      	ldr	r3, [pc, #76]	; (800ac30 <SFU_IMG_InitImageHandling+0x104>)
 800abe2:	429a      	cmp	r2, r3
 800abe4:	d304      	bcc.n	800abf0 <SFU_IMG_InitImageHandling+0xc4>
        TRACE("\r\n= [FWIMG] KMS NVM area overlaps SLOT_DWL_%d area\r\n", i + 1U);
 800abe6:	4818      	ldr	r0, [pc, #96]	; (800ac48 <SFU_IMG_InitImageHandling+0x11c>)
 800abe8:	2101      	movs	r1, #1
 800abea:	f004 f885 	bl	800ecf8 <iprintf>
        e_ret_status = SFU_IMG_INIT_FLASH_CONSTRAINTS_ERROR;
 800abee:	2403      	movs	r4, #3
  e_swap_ret_status = SFU_IMG_CheckSwapImageHandling();
 800abf0:	f000 ff7c 	bl	800baec <SFU_IMG_CheckSwapImageHandling>
}
 800abf4:	2800      	cmp	r0, #0
 800abf6:	bf08      	it	eq
 800abf8:	4620      	moveq	r0, r4
 800abfa:	b005      	add	sp, #20
 800abfc:	e8bd 8170 	ldmia.w	sp!, {r4, r5, r6, r8, pc}
 800ac00:	20003db4 	.word	0x20003db4
 800ac04:	0802b000 	.word	0x0802b000
 800ac08:	0800ffba 	.word	0x0800ffba
 800ac0c:	08016000 	.word	0x08016000
 800ac10:	08015000 	.word	0x08015000
 800ac14:	0800fff4 	.word	0x0800fff4
 800ac18:	00012fff 	.word	0x00012fff
 800ac1c:	0002b000 	.word	0x0002b000
 800ac20:	0801002b 	.word	0x0801002b
 800ac24:	00016000 	.word	0x00016000
 800ac28:	08010072 	.word	0x08010072
 800ac2c:	08009600 	.word	0x08009600
 800ac30:	08013000 	.word	0x08013000
 800ac34:	08012fff 	.word	0x08012fff
 800ac38:	080100b6 	.word	0x080100b6
 800ac3c:	0803ffff 	.word	0x0803ffff
 800ac40:	080100e6 	.word	0x080100e6
 800ac44:	0802afff 	.word	0x0802afff
 800ac48:	0801011e 	.word	0x0801011e
 800ac4c:	08014fff 	.word	0x08014fff

0800ac50 <SFU_IMG_InvalidateCurrentFirmware>:
{
 800ac50:	b510      	push	{r4, lr}
 800ac52:	4604      	mov	r4, r0
  (void) SFU_LL_SECU_IWDG_Refresh();
 800ac54:	f002 f912 	bl	800ce7c <SFU_LL_SECU_IWDG_Refresh>
  e_ret_status = CleanUpSlot((uint8_t *) SlotStartAdd[SlotNumber], SLOT_SIZE(SlotNumber), SFU_IMG_IMAGE_OFFSET);
 800ac58:	4b06      	ldr	r3, [pc, #24]	; (800ac74 <SFU_IMG_InvalidateCurrentFirmware+0x24>)
 800ac5a:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 800ac5e:	4b06      	ldr	r3, [pc, #24]	; (800ac78 <SFU_IMG_InvalidateCurrentFirmware+0x28>)
 800ac60:	f853 1024 	ldr.w	r1, [r3, r4, lsl #2]
 800ac64:	3101      	adds	r1, #1
}
 800ac66:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  e_ret_status = CleanUpSlot((uint8_t *) SlotStartAdd[SlotNumber], SLOT_SIZE(SlotNumber), SFU_IMG_IMAGE_OFFSET);
 800ac6a:	f44f 7200 	mov.w	r2, #512	; 0x200
 800ac6e:	1a09      	subs	r1, r1, r0
 800ac70:	f7ff bf28 	b.w	800aac4 <CleanUpSlot>
 800ac74:	08010f28 	.word	0x08010f28
 800ac78:	08010f38 	.word	0x08010f38

0800ac7c <SFU_IMG_VerifyActiveImg>:
{
 800ac7c:	b507      	push	{r0, r1, r2, lr}
  SE_StatusTypeDef e_se_status = SE_KO;
 800ac7e:	4b05      	ldr	r3, [pc, #20]	; (800ac94 <SFU_IMG_VerifyActiveImg+0x18>)
 800ac80:	9301      	str	r3, [sp, #4]
{
 800ac82:	4601      	mov	r1, r0
  e_ret_status = VerifyFwSignature(&e_se_status, SlotNumber, &fw_image_header_validated, SE_FW_IMAGE_COMPLETE);
 800ac84:	4a04      	ldr	r2, [pc, #16]	; (800ac98 <SFU_IMG_VerifyActiveImg+0x1c>)
 800ac86:	2300      	movs	r3, #0
 800ac88:	a801      	add	r0, sp, #4
 800ac8a:	f7ff fedb 	bl	800aa44 <VerifyFwSignature>
}
 800ac8e:	b003      	add	sp, #12
 800ac90:	f85d fb04 	ldr.w	pc, [sp], #4
 800ac94:	0013023d 	.word	0x0013023d
 800ac98:	20003db4 	.word	0x20003db4

0800ac9c <SFU_IMG_VerifyActiveSlot>:
  return (VerifySlot((uint8_t *) SlotStartAdd[SlotNumber], SLOT_SIZE(SlotNumber), fw_image_header_validated.FwSize));
 800ac9c:	4a06      	ldr	r2, [pc, #24]	; (800acb8 <SFU_IMG_VerifyActiveSlot+0x1c>)
{
 800ac9e:	4603      	mov	r3, r0
  return (VerifySlot((uint8_t *) SlotStartAdd[SlotNumber], SLOT_SIZE(SlotNumber), fw_image_header_validated.FwSize));
 800aca0:	f852 0020 	ldr.w	r0, [r2, r0, lsl #2]
 800aca4:	4a05      	ldr	r2, [pc, #20]	; (800acbc <SFU_IMG_VerifyActiveSlot+0x20>)
 800aca6:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 800acaa:	4b05      	ldr	r3, [pc, #20]	; (800acc0 <SFU_IMG_VerifyActiveSlot+0x24>)
 800acac:	3101      	adds	r1, #1
 800acae:	689a      	ldr	r2, [r3, #8]
 800acb0:	1a09      	subs	r1, r1, r0
 800acb2:	f7ff bef9 	b.w	800aaa8 <VerifySlot>
 800acb6:	bf00      	nop
 800acb8:	08010f28 	.word	0x08010f28
 800acbc:	08010f38 	.word	0x08010f38
 800acc0:	20003db4 	.word	0x20003db4

0800acc4 <SFU_IMG_VerifyEmptyActiveSlot>:
  return (VerifySlot((uint8_t *) SlotStartAdd[SlotNumber], SLOT_SIZE(SlotNumber), 0U));
 800acc4:	4a05      	ldr	r2, [pc, #20]	; (800acdc <SFU_IMG_VerifyEmptyActiveSlot+0x18>)
{
 800acc6:	4603      	mov	r3, r0
  return (VerifySlot((uint8_t *) SlotStartAdd[SlotNumber], SLOT_SIZE(SlotNumber), 0U));
 800acc8:	f852 0020 	ldr.w	r0, [r2, r0, lsl #2]
 800accc:	4a04      	ldr	r2, [pc, #16]	; (800ace0 <SFU_IMG_VerifyEmptyActiveSlot+0x1c>)
 800acce:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 800acd2:	3101      	adds	r1, #1
 800acd4:	2200      	movs	r2, #0
 800acd6:	1a09      	subs	r1, r1, r0
 800acd8:	f7ff bee6 	b.w	800aaa8 <VerifySlot>
 800acdc:	08010f28 	.word	0x08010f28
 800ace0:	08010f38 	.word	0x08010f38

0800ace4 <SFU_IMG_ControlActiveImgTag>:
{
 800ace4:	b508      	push	{r3, lr}
  if (MemoryCompare(fw_tag_validated[SlotNumber - SLOT_ACTIVE_1], fw_image_header_validated.FwTag,
 800ace6:	4b0b      	ldr	r3, [pc, #44]	; (800ad14 <SFU_IMG_ControlActiveImgTag+0x30>)
 800ace8:	490b      	ldr	r1, [pc, #44]	; (800ad18 <SFU_IMG_ControlActiveImgTag+0x34>)
 800acea:	3801      	subs	r0, #1
 800acec:	2220      	movs	r2, #32
 800acee:	eb03 1040 	add.w	r0, r3, r0, lsl #5
 800acf2:	f7ff fd75 	bl	800a7e0 <MemoryCompare>
 800acf6:	4b09      	ldr	r3, [pc, #36]	; (800ad1c <SFU_IMG_ControlActiveImgTag+0x38>)
 800acf8:	4298      	cmp	r0, r3
    FLOW_STEP(uFlowCryptoValue, FLOW_STEP_INTEGRITY);
 800acfa:	bf01      	itttt	eq
 800acfc:	4a08      	ldreq	r2, [pc, #32]	; (800ad20 <SFU_IMG_ControlActiveImgTag+0x3c>)
 800acfe:	6813      	ldreq	r3, [r2, #0]
 800ad00:	f483 432a 	eoreq.w	r3, r3, #43520	; 0xaa00
 800ad04:	f083 03b5 	eoreq.w	r3, r3, #181	; 0xb5
 800ad08:	bf0c      	ite	eq
 800ad0a:	6013      	streq	r3, [r2, #0]
    return SFU_ERROR;
 800ad0c:	f641 70e1 	movwne	r0, #8161	; 0x1fe1
}
 800ad10:	bd08      	pop	{r3, pc}
 800ad12:	bf00      	nop
 800ad14:	200038b6 	.word	0x200038b6
 800ad18:	20003dc8 	.word	0x20003dc8
 800ad1c:	00122f11 	.word	0x00122f11
 800ad20:	20003400 	.word	0x20003400

0800ad24 <SFU_IMG_LaunchActiveImg>:
  FLOW_CONTROL_CHECK(uFlowCryptoValue, FLOW_CTRL_LOCK_SERVICE);
 800ad24:	4b0b      	ldr	r3, [pc, #44]	; (800ad54 <SFU_IMG_LaunchActiveImg+0x30>)
 800ad26:	681a      	ldr	r2, [r3, #0]
 800ad28:	f243 03f1 	movw	r3, #12529	; 0x30f1
 800ad2c:	429a      	cmp	r2, r3
{
 800ad2e:	b510      	push	{r4, lr}
 800ad30:	4604      	mov	r4, r0
  FLOW_CONTROL_CHECK(uFlowCryptoValue, FLOW_CTRL_LOCK_SERVICE);
 800ad32:	d001      	beq.n	800ad38 <SFU_IMG_LaunchActiveImg+0x14>
 800ad34:	f7ff fcca 	bl	800a6cc <SFU_EXCPT_Security_Error>
  HAL_SuspendTick();
 800ad38:	f002 fac2 	bl	800d2c0 <HAL_SuspendTick>
  jump_address = *(__IO uint32_t *)((SlotStartAdd[SlotNumber] + SFU_IMG_IMAGE_OFFSET + 4));
 800ad3c:	4b06      	ldr	r3, [pc, #24]	; (800ad58 <SFU_IMG_LaunchActiveImg+0x34>)
 800ad3e:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 800ad42:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
  __set_MSP(*(__IO uint32_t *)(SlotStartAdd[SlotNumber] + SFU_IMG_IMAGE_OFFSET));
 800ad46:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 800ad4a:	f383 8808 	msr	MSP, r3
    p_jump_to_function();
 800ad4e:	4790      	blx	r2
}
 800ad50:	4802      	ldr	r0, [pc, #8]	; (800ad5c <SFU_IMG_LaunchActiveImg+0x38>)
 800ad52:	bd10      	pop	{r4, pc}
 800ad54:	20003400 	.word	0x20003400
 800ad58:	08010f28 	.word	0x08010f28
 800ad5c:	00122f11 	.word	0x00122f11

0800ad60 <SFU_IMG_Validation>:
{
 800ad60:	e92d 4177 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r8, lr}
  e_ret_status = SFU_LL_FLASH_Write(&flash_if_status, (uint8_t *) SlotHeaderAdd[SlotNumber], (uint8_t *) pFWImageHeader,
 800ad64:	4b19      	ldr	r3, [pc, #100]	; (800adcc <SFU_IMG_Validation+0x6c>)
 800ad66:	f853 8020 	ldr.w	r8, [r3, r0, lsl #2]
 800ad6a:	460a      	mov	r2, r1
{
 800ad6c:	460d      	mov	r5, r1
  e_ret_status = SFU_LL_FLASH_Write(&flash_if_status, (uint8_t *) SlotHeaderAdd[SlotNumber], (uint8_t *) pFWImageHeader,
 800ad6e:	23c0      	movs	r3, #192	; 0xc0
 800ad70:	4641      	mov	r1, r8
 800ad72:	f10d 0007 	add.w	r0, sp, #7
 800ad76:	f001 fe46 	bl	800ca06 <SFU_LL_FLASH_Write>
  STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_WRITE_FAILED);
 800ad7a:	f641 76e1 	movw	r6, #8161	; 0x1fe1
 800ad7e:	42b0      	cmp	r0, r6
  e_ret_status = SFU_LL_FLASH_Write(&flash_if_status, (uint8_t *) SlotHeaderAdd[SlotNumber], (uint8_t *) pFWImageHeader,
 800ad80:	4604      	mov	r4, r0
  STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_WRITE_FAILED);
 800ad82:	d10e      	bne.n	800ada2 <SFU_IMG_Validation+0x42>
 800ad84:	4b12      	ldr	r3, [pc, #72]	; (800add0 <SFU_IMG_Validation+0x70>)
 800ad86:	2102      	movs	r1, #2
 800ad88:	7019      	strb	r1, [r3, #0]
 800ad8a:	f240 32bf 	movw	r2, #959	; 0x3bf
    STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_WRITE_FAILED);
 800ad8e:	4b11      	ldr	r3, [pc, #68]	; (800add4 <SFU_IMG_Validation+0x74>)
 800ad90:	4811      	ldr	r0, [pc, #68]	; (800add8 <SFU_IMG_Validation+0x78>)
 800ad92:	601a      	str	r2, [r3, #0]
 800ad94:	4b11      	ldr	r3, [pc, #68]	; (800addc <SFU_IMG_Validation+0x7c>)
 800ad96:	f003 ffaf 	bl	800ecf8 <iprintf>
}
 800ad9a:	4620      	mov	r0, r4
 800ad9c:	b003      	add	sp, #12
 800ad9e:	e8bd 8170 	ldmia.w	sp!, {r4, r5, r6, r8, pc}
  if (e_ret_status == SFU_SUCCESS)
 800ada2:	4b0f      	ldr	r3, [pc, #60]	; (800ade0 <SFU_IMG_Validation+0x80>)
 800ada4:	4298      	cmp	r0, r3
 800ada6:	d1f8      	bne.n	800ad9a <SFU_IMG_Validation+0x3a>
    e_ret_status = SFU_LL_FLASH_Write(&flash_if_status, (uint8_t *)(SlotHeaderAdd[SlotNumber] + SE_FW_HEADER_TOT_LEN -
 800ada8:	2320      	movs	r3, #32
 800adaa:	f505 7290 	add.w	r2, r5, #288	; 0x120
 800adae:	f508 7190 	add.w	r1, r8, #288	; 0x120
 800adb2:	f10d 0007 	add.w	r0, sp, #7
 800adb6:	f001 fe26 	bl	800ca06 <SFU_LL_FLASH_Write>
    STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_WRITE_FAILED);
 800adba:	42b0      	cmp	r0, r6
    e_ret_status = SFU_LL_FLASH_Write(&flash_if_status, (uint8_t *)(SlotHeaderAdd[SlotNumber] + SE_FW_HEADER_TOT_LEN -
 800adbc:	4604      	mov	r4, r0
    STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_WRITE_FAILED);
 800adbe:	d1ec      	bne.n	800ad9a <SFU_IMG_Validation+0x3a>
 800adc0:	4b03      	ldr	r3, [pc, #12]	; (800add0 <SFU_IMG_Validation+0x70>)
 800adc2:	2102      	movs	r1, #2
 800adc4:	7019      	strb	r1, [r3, #0]
 800adc6:	f240 32c9 	movw	r2, #969	; 0x3c9
 800adca:	e7e0      	b.n	800ad8e <SFU_IMG_Validation+0x2e>
 800adcc:	08010f48 	.word	0x08010f48
 800add0:	20003db0 	.word	0x20003db0
 800add4:	20003dac 	.word	0x20003dac
 800add8:	0800ff80 	.word	0x0800ff80
 800addc:	0800fef8 	.word	0x0800fef8
 800ade0:	00122f11 	.word	0x00122f11

0800ade4 <SFU_IMG_GetFwImageSlot>:
{
 800ade4:	b508      	push	{r3, lr}
  if (memcmp(pFwImageHeader->SFUMagic, SFUM_1, strlen(SFUM_1)) == 0)
 800ade6:	4904      	ldr	r1, [pc, #16]	; (800adf8 <SFU_IMG_GetFwImageSlot+0x14>)
 800ade8:	2204      	movs	r2, #4
 800adea:	f003 ff61 	bl	800ecb0 <memcmp>
}
 800adee:	fab0 f080 	clz	r0, r0
 800adf2:	0940      	lsrs	r0, r0, #5
 800adf4:	bd08      	pop	{r3, pc}
 800adf6:	bf00      	nop
 800adf8:	08010153 	.word	0x08010153

0800adfc <VerifyHeaderSignature>:
{
 800adfc:	b513      	push	{r0, r1, r4, lr}
 800adfe:	4604      	mov	r4, r0
  if (SFU_IMG_GetFwImageSlot(pFwImageHeader) != SLOT_INACTIVE)
 800ae00:	f7ff fff0 	bl	800ade4 <SFU_IMG_GetFwImageSlot>
 800ae04:	b918      	cbnz	r0, 800ae0e <VerifyHeaderSignature+0x12>
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
 800ae06:	f641 70e1 	movw	r0, #8161	; 0x1fe1
}
 800ae0a:	b002      	add	sp, #8
 800ae0c:	bd10      	pop	{r4, pc}
 800ae0e:	f104 0264 	add.w	r2, r4, #100	; 0x64
 800ae12:	f104 0180 	add.w	r1, r4, #128	; 0x80
  uint8_t result = 0x00U;
 800ae16:	2300      	movs	r3, #0
      result |= pFwImageHeader->Reserved[i] ^ 0x00U;
 800ae18:	f812 0b01 	ldrb.w	r0, [r2], #1
    for (i = 0U; i < sizeof(pFwImageHeader->Reserved); i++)
 800ae1c:	428a      	cmp	r2, r1
      result |= pFwImageHeader->Reserved[i] ^ 0x00U;
 800ae1e:	ea43 0300 	orr.w	r3, r3, r0
    for (i = 0U; i < sizeof(pFwImageHeader->Reserved); i++)
 800ae22:	d1f9      	bne.n	800ae18 <VerifyHeaderSignature+0x1c>
    if (result == 0x00U)
 800ae24:	2b00      	cmp	r3, #0
 800ae26:	d1ee      	bne.n	800ae06 <VerifyHeaderSignature+0xa>
      if (SE_VerifyHeaderSignature(&se_status, pFwImageHeader) == SE_SUCCESS)
 800ae28:	4621      	mov	r1, r4
 800ae2a:	a801      	add	r0, sp, #4
 800ae2c:	f001 f98e 	bl	800c14c <SFU_VerifyHeaderSignature>
 800ae30:	4b05      	ldr	r3, [pc, #20]	; (800ae48 <VerifyHeaderSignature+0x4c>)
 800ae32:	4298      	cmp	r0, r3
 800ae34:	d1e7      	bne.n	800ae06 <VerifyHeaderSignature+0xa>
        FLOW_STEP(uFlowCryptoValue, FLOW_STEP_AUTHENTICATE);
 800ae36:	4a05      	ldr	r2, [pc, #20]	; (800ae4c <VerifyHeaderSignature+0x50>)
 800ae38:	4805      	ldr	r0, [pc, #20]	; (800ae50 <VerifyHeaderSignature+0x54>)
 800ae3a:	6813      	ldr	r3, [r2, #0]
 800ae3c:	f483 43f3 	eor.w	r3, r3, #31104	; 0x7980
 800ae40:	f083 0319 	eor.w	r3, r3, #25
 800ae44:	6013      	str	r3, [r2, #0]
  return e_ret_status;
 800ae46:	e7e0      	b.n	800ae0a <VerifyHeaderSignature+0xe>
 800ae48:	0012310f 	.word	0x0012310f
 800ae4c:	20003400 	.word	0x20003400
 800ae50:	00122f11 	.word	0x00122f11

0800ae54 <CheckAndGetFWHeader>:
  e_ret_status = SFU_LL_FLASH_Read((uint8_t *) pFwImageHeader, (uint8_t *) SlotHeaderAdd[SlotNumber],
 800ae54:	4b09      	ldr	r3, [pc, #36]	; (800ae7c <CheckAndGetFWHeader+0x28>)
{
 800ae56:	b510      	push	{r4, lr}
 800ae58:	460c      	mov	r4, r1
  e_ret_status = SFU_LL_FLASH_Read((uint8_t *) pFwImageHeader, (uint8_t *) SlotHeaderAdd[SlotNumber],
 800ae5a:	f44f 72a0 	mov.w	r2, #320	; 0x140
 800ae5e:	f853 1020 	ldr.w	r1, [r3, r0, lsl #2]
 800ae62:	4620      	mov	r0, r4
 800ae64:	f001 fdd6 	bl	800ca14 <SFU_LL_FLASH_Read>
  if (e_ret_status == SFU_SUCCESS)
 800ae68:	4b05      	ldr	r3, [pc, #20]	; (800ae80 <CheckAndGetFWHeader+0x2c>)
 800ae6a:	4298      	cmp	r0, r3
 800ae6c:	d104      	bne.n	800ae78 <CheckAndGetFWHeader+0x24>
    e_ret_status = VerifyHeaderSignature(pFwImageHeader);
 800ae6e:	4620      	mov	r0, r4
}
 800ae70:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    e_ret_status = VerifyHeaderSignature(pFwImageHeader);
 800ae74:	f7ff bfc2 	b.w	800adfc <VerifyHeaderSignature>
}
 800ae78:	bd10      	pop	{r4, pc}
 800ae7a:	bf00      	nop
 800ae7c:	08010f48 	.word	0x08010f48
 800ae80:	00122f11 	.word	0x00122f11

0800ae84 <SFU_IMG_VerifyActiveImgMetadata>:
  return (CheckAndGetFWHeader(SlotNumber, &fw_image_header_validated));
 800ae84:	4901      	ldr	r1, [pc, #4]	; (800ae8c <SFU_IMG_VerifyActiveImgMetadata+0x8>)
 800ae86:	f7ff bfe5 	b.w	800ae54 <CheckAndGetFWHeader>
 800ae8a:	bf00      	nop
 800ae8c:	20003db4 	.word	0x20003db4

0800ae90 <SFU_IMG_GetActiveFwVersion>:
{
 800ae90:	b500      	push	{lr}
 800ae92:	b0d1      	sub	sp, #324	; 0x144
  e_ret_status = CheckAndGetFWHeader(SlotNumber, &fw_image_header);
 800ae94:	4669      	mov	r1, sp
 800ae96:	f7ff ffdd 	bl	800ae54 <CheckAndGetFWHeader>
  if (e_ret_status == SFU_SUCCESS)
 800ae9a:	4b04      	ldr	r3, [pc, #16]	; (800aeac <SFU_IMG_GetActiveFwVersion+0x1c>)
 800ae9c:	4298      	cmp	r0, r3
    version = fw_image_header.FwVersion;
 800ae9e:	bf0c      	ite	eq
 800aea0:	f8bd 0006 	ldrheq.w	r0, [sp, #6]
  uint16_t version = 0;
 800aea4:	2000      	movne	r0, #0
}
 800aea6:	b051      	add	sp, #324	; 0x144
 800aea8:	f85d fb04 	ldr.w	pc, [sp], #4
 800aeac:	00122f11 	.word	0x00122f11

0800aeb0 <SFU_IMG_DetectFW>:
{
 800aeb0:	b530      	push	{r4, r5, lr}
  if (SFU_LL_FLASH_Read(buffer, pbuffer, sizeof(buffer)) == SFU_SUCCESS)
 800aeb2:	4b11      	ldr	r3, [pc, #68]	; (800aef8 <SFU_IMG_DetectFW+0x48>)
{
 800aeb4:	b0d1      	sub	sp, #324	; 0x144
  if (SFU_LL_FLASH_Read(buffer, pbuffer, sizeof(buffer)) == SFU_SUCCESS)
 800aeb6:	f853 1020 	ldr.w	r1, [r3, r0, lsl #2]
{
 800aeba:	4605      	mov	r5, r0
  if (SFU_LL_FLASH_Read(buffer, pbuffer, sizeof(buffer)) == SFU_SUCCESS)
 800aebc:	f44f 72a0 	mov.w	r2, #320	; 0x140
 800aec0:	4668      	mov	r0, sp
 800aec2:	f001 fda7 	bl	800ca14 <SFU_LL_FLASH_Read>
 800aec6:	4b0d      	ldr	r3, [pc, #52]	; (800aefc <SFU_IMG_DetectFW+0x4c>)
 800aec8:	4298      	cmp	r0, r3
 800aeca:	4604      	mov	r4, r0
 800aecc:	d004      	beq.n	800aed8 <SFU_IMG_DetectFW+0x28>
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
 800aece:	f641 74e1 	movw	r4, #8161	; 0x1fe1
}
 800aed2:	4620      	mov	r0, r4
 800aed4:	b051      	add	sp, #324	; 0x144
 800aed6:	bd30      	pop	{r4, r5, pc}
    if (SFU_IMG_GetFwImageSlot(p_header) != SLOT_INACTIVE)
 800aed8:	4668      	mov	r0, sp
 800aeda:	f7ff ff83 	bl	800ade4 <SFU_IMG_GetFwImageSlot>
 800aede:	2800      	cmp	r0, #0
 800aee0:	d0f5      	beq.n	800aece <SFU_IMG_DetectFW+0x1e>
      if (VerifySlot((uint8_t *) SlotStartAdd[SlotNumber], SFU_IMG_IMAGE_OFFSET + 0x20U, 0U) != SFU_SUCCESS)
 800aee2:	4b07      	ldr	r3, [pc, #28]	; (800af00 <SFU_IMG_DetectFW+0x50>)
 800aee4:	2200      	movs	r2, #0
 800aee6:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
 800aeea:	f44f 7108 	mov.w	r1, #544	; 0x220
 800aeee:	f7ff fddb 	bl	800aaa8 <VerifySlot>
 800aef2:	42a0      	cmp	r0, r4
 800aef4:	d1ed      	bne.n	800aed2 <SFU_IMG_DetectFW+0x22>
 800aef6:	e7ea      	b.n	800aece <SFU_IMG_DetectFW+0x1e>
 800aef8:	08010f48 	.word	0x08010f48
 800aefc:	00122f11 	.word	0x00122f11
 800af00:	08010f28 	.word	0x08010f28

0800af04 <SFU_IMG_CheckFwVersion>:
  if (CurrentVersion == 0U)
 800af04:	b931      	cbnz	r1, 800af14 <SFU_IMG_CheckFwVersion+0x10>
      e_ret_status = SFU_SUCCESS;
 800af06:	4809      	ldr	r0, [pc, #36]	; (800af2c <SFU_IMG_CheckFwVersion+0x28>)
 800af08:	f641 73e1 	movw	r3, #8161	; 0x1fe1
 800af0c:	2a01      	cmp	r2, #1
 800af0e:	bf18      	it	ne
 800af10:	4618      	movne	r0, r3
 800af12:	4770      	bx	lr
    if ((CandidateVersion >= CurrentVersion) && (CandidateVersion >= SFU_FW_VERSION_START_NUM))
 800af14:	4291      	cmp	r1, r2
 800af16:	d806      	bhi.n	800af26 <SFU_IMG_CheckFwVersion+0x22>
      e_ret_status = SFU_SUCCESS;
 800af18:	4804      	ldr	r0, [pc, #16]	; (800af2c <SFU_IMG_CheckFwVersion+0x28>)
 800af1a:	f641 73e1 	movw	r3, #8161	; 0x1fe1
 800af1e:	2a00      	cmp	r2, #0
 800af20:	bf08      	it	eq
 800af22:	4618      	moveq	r0, r3
 800af24:	4770      	bx	lr
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
 800af26:	f641 70e1 	movw	r0, #8161	; 0x1fe1
}
 800af2a:	4770      	bx	lr
 800af2c:	00122f11 	.word	0x00122f11

0800af30 <CleanMagicValue>:
  * @brief  Clean Magic value
  * @param  DwlSlot identification of the downloaded area
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
  */
static SFU_ErrorStatus CleanMagicValue(uint32_t DwlSlot)
{
 800af30:	b530      	push	{r4, r5, lr}
 800af32:	b08b      	sub	sp, #44	; 0x2c
 800af34:	4604      	mov	r4, r0
  SFU_FLASH_StatusTypeDef flash_if_info;
  uint8_t clean_tag[MAGIC_LENGTH];

  /* set the clean tag into trailer */
  (void) memset(clean_tag, 0x55, MAGIC_LENGTH);
 800af36:	2220      	movs	r2, #32
 800af38:	2155      	movs	r1, #85	; 0x55
 800af3a:	a802      	add	r0, sp, #8
 800af3c:	f003 fed4 	bl	800ece8 <memset>
  return SFU_LL_FLASH_Write(&flash_if_info, TRAILER_CLEAN_ADDR(DwlSlot), clean_tag, MAGIC_LENGTH);
 800af40:	480d      	ldr	r0, [pc, #52]	; (800af78 <CleanMagicValue+0x48>)
 800af42:	4a0e      	ldr	r2, [pc, #56]	; (800af7c <CleanMagicValue+0x4c>)
 800af44:	f850 3024 	ldr.w	r3, [r0, r4, lsl #2]
 800af48:	f852 1024 	ldr.w	r1, [r2, r4, lsl #2]
 800af4c:	68d2      	ldr	r2, [r2, #12]
 800af4e:	f203 25a1 	addw	r5, r3, #673	; 0x2a1
 800af52:	3301      	adds	r3, #1
 800af54:	1a5b      	subs	r3, r3, r1
 800af56:	68c1      	ldr	r1, [r0, #12]
 800af58:	3101      	adds	r1, #1
 800af5a:	1a89      	subs	r1, r1, r2
 800af5c:	fbb3 f1f1 	udiv	r1, r3, r1
 800af60:	312c      	adds	r1, #44	; 0x2c
 800af62:	2320      	movs	r3, #32
 800af64:	aa02      	add	r2, sp, #8
 800af66:	eba5 1101 	sub.w	r1, r5, r1, lsl #4
 800af6a:	f10d 0007 	add.w	r0, sp, #7
 800af6e:	f001 fd4a 	bl	800ca06 <SFU_LL_FLASH_Write>
}
 800af72:	b00b      	add	sp, #44	; 0x2c
 800af74:	bd30      	pop	{r4, r5, pc}
 800af76:	bf00      	nop
 800af78:	08010f38 	.word	0x08010f38
 800af7c:	08010f28 	.word	0x08010f28

0800af80 <EraseSlotIndex>:
  * @param  SlotNumber index of the slot in the list
  * @param  Index This is the number of "swap size" we jump from the slot start
  * @retval SFU_ SUCCESS if valid, a SFU_ErrorStatus error otherwise.
  */
static SFU_ErrorStatus EraseSlotIndex(uint32_t SlotNumber, uint32_t index)
{
 800af80:	b573      	push	{r0, r1, r4, r5, r6, lr}
  SFU_FLASH_StatusTypeDef flash_if_status;
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
  uint32_t buffer;

  buffer = SlotStartAdd[SlotNumber];
 800af82:	4a1d      	ldr	r2, [pc, #116]	; (800aff8 <EraseSlotIndex+0x78>)
{
 800af84:	460b      	mov	r3, r1
  buffer = buffer + (SLOT_SIZE(SLOT_SWAP) * index);
 800af86:	491d      	ldr	r1, [pc, #116]	; (800affc <EraseSlotIndex+0x7c>)
  buffer = SlotStartAdd[SlotNumber];
 800af88:	f852 6020 	ldr.w	r6, [r2, r0, lsl #2]
  buffer = buffer + (SLOT_SIZE(SLOT_SWAP) * index);
 800af8c:	68cd      	ldr	r5, [r1, #12]
 800af8e:	68d2      	ldr	r2, [r2, #12]

  /* If this is an active slot and the index is 0 then header is concerned */
  if ((SlotNumber >= SLOT_ACTIVE_1) && (SlotNumber <= (SLOT_ACTIVE_1 + SFU_NB_MAX_ACTIVE_IMAGE)) && (index == 0U))
 800af90:	1e44      	subs	r4, r0, #1
  buffer = buffer + (SLOT_SIZE(SLOT_SWAP) * index);
 800af92:	1aad      	subs	r5, r5, r2
 800af94:	fb05 3103 	mla	r1, r5, r3, r3
  if ((SlotNumber >= SLOT_ACTIVE_1) && (SlotNumber <= (SLOT_ACTIVE_1 + SFU_NB_MAX_ACTIVE_IMAGE)) && (index == 0U))
 800af98:	2c01      	cmp	r4, #1
  buffer = buffer + (SLOT_SIZE(SLOT_SWAP) * index);
 800af9a:	f105 0201 	add.w	r2, r5, #1
 800af9e:	4431      	add	r1, r6
  if ((SlotNumber >= SLOT_ACTIVE_1) && (SlotNumber <= (SLOT_ACTIVE_1 + SFU_NB_MAX_ACTIVE_IMAGE)) && (index == 0U))
 800afa0:	d812      	bhi.n	800afc8 <EraseSlotIndex+0x48>
 800afa2:	b98b      	cbnz	r3, 800afc8 <EraseSlotIndex+0x48>
    /*
     *  As the header may not be contiguous with FW, this action is split in 2 actions :
     *    - HEADER : executed in secured environment
     *    - remaining part : done by SBSFU
     */
    e_ret_status = SFU_LL_FLASH_Erase_Size(&flash_if_status, (uint8_t *) SlotHeaderAdd[SlotNumber],
 800afa4:	4b16      	ldr	r3, [pc, #88]	; (800b000 <EraseSlotIndex+0x80>)
 800afa6:	f44f 7200 	mov.w	r2, #512	; 0x200
 800afaa:	f853 1020 	ldr.w	r1, [r3, r0, lsl #2]
 800afae:	f10d 0007 	add.w	r0, sp, #7
 800afb2:	f001 fd21 	bl	800c9f8 <SFU_LL_FLASH_Erase_Size>
                                           SFU_IMG_IMAGE_OFFSET) ;
    if (e_ret_status == SFU_SUCCESS)
 800afb6:	4b13      	ldr	r3, [pc, #76]	; (800b004 <EraseSlotIndex+0x84>)
 800afb8:	4298      	cmp	r0, r3
    e_ret_status = SFU_LL_FLASH_Erase_Size(&flash_if_status, (uint8_t *) SlotHeaderAdd[SlotNumber],
 800afba:	4604      	mov	r4, r0
    if (e_ret_status == SFU_SUCCESS)
 800afbc:	d109      	bne.n	800afd2 <EraseSlotIndex+0x52>
    {
      e_ret_status = SFU_LL_FLASH_Erase_Size(&flash_if_status, (uint8_t *) SlotStartAdd[SlotNumber] +
 800afbe:	f46f 73ff 	mvn.w	r3, #510	; 0x1fe
 800afc2:	18ea      	adds	r2, r5, r3
 800afc4:	f506 7100 	add.w	r1, r6, #512	; 0x200
                                             SFU_IMG_IMAGE_OFFSET, SLOT_SIZE(SLOT_SWAP) - SFU_IMG_IMAGE_OFFSET);
    }
  }
  else
  {
    e_ret_status = SFU_LL_FLASH_Erase_Size(&flash_if_status, (uint8_t *)buffer, SLOT_SIZE(SLOT_SWAP)) ;
 800afc8:	f10d 0007 	add.w	r0, sp, #7
 800afcc:	f001 fd14 	bl	800c9f8 <SFU_LL_FLASH_Erase_Size>
 800afd0:	4604      	mov	r4, r0
  }

  STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_ERASE_FAILED)
 800afd2:	f641 73e1 	movw	r3, #8161	; 0x1fe1
 800afd6:	429c      	cmp	r4, r3
 800afd8:	d10a      	bne.n	800aff0 <EraseSlotIndex+0x70>
 800afda:	4b0b      	ldr	r3, [pc, #44]	; (800b008 <EraseSlotIndex+0x88>)
 800afdc:	480b      	ldr	r0, [pc, #44]	; (800b00c <EraseSlotIndex+0x8c>)
 800afde:	2101      	movs	r1, #1
 800afe0:	7019      	strb	r1, [r3, #0]
 800afe2:	4b0b      	ldr	r3, [pc, #44]	; (800b010 <EraseSlotIndex+0x90>)
 800afe4:	f44f 72b6 	mov.w	r2, #364	; 0x16c
 800afe8:	601a      	str	r2, [r3, #0]
 800afea:	4b0a      	ldr	r3, [pc, #40]	; (800b014 <EraseSlotIndex+0x94>)
 800afec:	f003 fe84 	bl	800ecf8 <iprintf>
  return e_ret_status;
}
 800aff0:	4620      	mov	r0, r4
 800aff2:	b002      	add	sp, #8
 800aff4:	bd70      	pop	{r4, r5, r6, pc}
 800aff6:	bf00      	nop
 800aff8:	08010f28 	.word	0x08010f28
 800affc:	08010f38 	.word	0x08010f38
 800b000:	08010f48 	.word	0x08010f48
 800b004:	00122f11 	.word	0x00122f11
 800b008:	20003db0 	.word	0x20003db0
 800b00c:	08010fdd 	.word	0x08010fdd
 800b010:	20003dac 	.word	0x20003dac
 800b014:	08010f58 	.word	0x08010f58

0800b018 <FirmwareToInstall.constprop.0>:
  * @brief  Check that there is an Image to Install
  * @param  DwlSlot identification of the downloaded area
  * @param  pFwImageHeader pointer to fw header to install
  * @retval SFU_SUCCESS if Image can be installed, a SFU_ERROR  otherwise.
  */
static SFU_ErrorStatus FirmwareToInstall(uint32_t DwlSlot, SE_FwRawHeaderTypeDef *pFwImageHeader)
 800b018:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
{
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
  uint8_t *p_header_swap;
  uint8_t fw_header_dwl_slot[SE_FW_HEADER_TOT_LEN];
  uint32_t trailer_begin = (uint32_t) TRAILER_BEGIN(DwlSlot);
 800b01c:	4a20      	ldr	r2, [pc, #128]	; (800b0a0 <FirmwareToInstall.constprop.0+0x88>)
     * The anti-rollback check is implemented at installation stage (SFU_IMG_InstallNewVersion)
     * to be able to handle a specific error cause.
     */

  /*  check swap header */
  e_ret_status = CheckAndGetFWHeader(SLOT_SWAP, pFwImageHeader);
 800b01e:	f8df 908c 	ldr.w	r9, [pc, #140]	; 800b0ac <FirmwareToInstall.constprop.0+0x94>
  uint32_t trailer_begin = (uint32_t) TRAILER_BEGIN(DwlSlot);
 800b022:	4b20      	ldr	r3, [pc, #128]	; (800b0a4 <FirmwareToInstall.constprop.0+0x8c>)
  if (e_ret_status == SFU_SUCCESS)
 800b024:	4e20      	ldr	r6, [pc, #128]	; (800b0a8 <FirmwareToInstall.constprop.0+0x90>)
  uint32_t trailer_begin = (uint32_t) TRAILER_BEGIN(DwlSlot);
 800b026:	f8d3 8008 	ldr.w	r8, [r3, #8]
 800b02a:	68df      	ldr	r7, [r3, #12]
 800b02c:	e9d2 5202 	ldrd	r5, r2, [r2, #8]
static SFU_ErrorStatus FirmwareToInstall(uint32_t DwlSlot, SE_FwRawHeaderTypeDef *pFwImageHeader)
 800b030:	b0d3      	sub	sp, #332	; 0x14c
  e_ret_status = CheckAndGetFWHeader(SLOT_SWAP, pFwImageHeader);
 800b032:	4649      	mov	r1, r9
 800b034:	2003      	movs	r0, #3
  uint32_t trailer_begin = (uint32_t) TRAILER_BEGIN(DwlSlot);
 800b036:	9201      	str	r2, [sp, #4]
  e_ret_status = CheckAndGetFWHeader(SLOT_SWAP, pFwImageHeader);
 800b038:	f7ff ff0c 	bl	800ae54 <CheckAndGetFWHeader>
  if (e_ret_status == SFU_SUCCESS)
 800b03c:	42b0      	cmp	r0, r6
  e_ret_status = CheckAndGetFWHeader(SLOT_SWAP, pFwImageHeader);
 800b03e:	4604      	mov	r4, r0
  if (e_ret_status == SFU_SUCCESS)
 800b040:	d126      	bne.n	800b090 <FirmwareToInstall.constprop.0+0x78>
  {
    /*  compare the header in dwl slot with the header in swap */
    p_header_swap = (uint8_t *) pFwImageHeader;
    e_ret_status = SFU_LL_FLASH_Read(fw_header_dwl_slot, (uint8_t *) SlotStartAdd[DwlSlot],
 800b042:	f44f 72a0 	mov.w	r2, #320	; 0x140
 800b046:	4641      	mov	r1, r8
 800b048:	a802      	add	r0, sp, #8
 800b04a:	f001 fce3 	bl	800ca14 <SFU_LL_FLASH_Read>
                                     sizeof(fw_header_dwl_slot));
    if (e_ret_status == SFU_SUCCESS)
 800b04e:	42b0      	cmp	r0, r6
    e_ret_status = SFU_LL_FLASH_Read(fw_header_dwl_slot, (uint8_t *) SlotStartAdd[DwlSlot],
 800b050:	4604      	mov	r4, r0
    if (e_ret_status == SFU_SUCCESS)
 800b052:	d11d      	bne.n	800b090 <FirmwareToInstall.constprop.0+0x78>
  uint32_t trailer_begin = (uint32_t) TRAILER_BEGIN(DwlSlot);
 800b054:	9e01      	ldr	r6, [sp, #4]
 800b056:	f2a5 23bf 	subw	r3, r5, #703	; 0x2bf
 800b05a:	3601      	adds	r6, #1
 800b05c:	3501      	adds	r5, #1
 800b05e:	eba5 0508 	sub.w	r5, r5, r8
 800b062:	1bf7      	subs	r7, r6, r7
 800b064:	fbb5 f5f7 	udiv	r5, r5, r7
 800b068:	eba3 1505 	sub.w	r5, r3, r5, lsl #4
    {
      /* image header in dwl slot not consistent with swap header */
      end_of_test_image = (SlotStartAdd[DwlSlot] + pFwImageHeader->FwSize +
 800b06c:	f8d9 3008 	ldr.w	r3, [r9, #8]
 800b070:	4498      	add	r8, r3
 800b072:	f508 7800 	add.w	r8, r8, #512	; 0x200

      /* the header in swap must be the same as the header in dwl slot */
      ret = memcmp(fw_header_dwl_slot, p_header_swap, SE_FW_HEADER_TOT_LEN);

      /* Check if there is enough room for the trailers */
      if ((trailer_begin < end_of_test_image) || (ret != 0))
 800b076:	4545      	cmp	r5, r8
 800b078:	d30e      	bcc.n	800b098 <FirmwareToInstall.constprop.0+0x80>
      ret = memcmp(fw_header_dwl_slot, p_header_swap, SE_FW_HEADER_TOT_LEN);
 800b07a:	f44f 72a0 	mov.w	r2, #320	; 0x140
 800b07e:	4649      	mov	r1, r9
 800b080:	a802      	add	r0, sp, #8
 800b082:	f003 fe15 	bl	800ecb0 <memcmp>
        /*
          * These error causes are not memorized in the BootInfo area because there won't be any error handling
          * procedure.
          * If this function returns that no new firmware can be installed (as this may be a normal case).
          */
        e_ret_status = SFU_ERROR;
 800b086:	f641 73e1 	movw	r3, #8161	; 0x1fe1
 800b08a:	2800      	cmp	r0, #0
 800b08c:	bf18      	it	ne
 800b08e:	461c      	movne	r4, r3
        e_ret_status = SFU_SUCCESS;
      }
    }
  }
  return e_ret_status;
}
 800b090:	4620      	mov	r0, r4
 800b092:	b053      	add	sp, #332	; 0x14c
 800b094:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        e_ret_status = SFU_ERROR;
 800b098:	f641 74e1 	movw	r4, #8161	; 0x1fe1
 800b09c:	e7f8      	b.n	800b090 <FirmwareToInstall.constprop.0+0x78>
 800b09e:	bf00      	nop
 800b0a0:	08010f38 	.word	0x08010f38
 800b0a4:	08010f28 	.word	0x08010f28
 800b0a8:	00122f11 	.word	0x00122f11
 800b0ac:	20003c6c 	.word	0x20003c6c

0800b0b0 <DecryptImageInDwlSlot.constprop.0>:
static SFU_ErrorStatus DecryptImageInDwlSlot(uint32_t DwlSlot, SE_FwRawHeaderTypeDef *pFwImageHeader)
 800b0b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t NumberOfChunkPerSwap = SLOT_SIZE(SLOT_SWAP) / SFU_IMG_CHUNK_SIZE;
 800b0b4:	4b8c      	ldr	r3, [pc, #560]	; (800b2e8 <DecryptImageInDwlSlot.constprop.0+0x238>)
  se_ret_status = SE_Decrypt_Init(&e_se_status, pFwImageHeader, SE_FW_IMAGE_PARTIAL);
 800b0b6:	498d      	ldr	r1, [pc, #564]	; (800b2ec <DecryptImageInDwlSlot.constprop.0+0x23c>)
  uint32_t NumberOfChunkPerSwap = SLOT_SIZE(SLOT_SWAP) / SFU_IMG_CHUNK_SIZE;
 800b0b8:	68db      	ldr	r3, [r3, #12]
static SFU_ErrorStatus DecryptImageInDwlSlot(uint32_t DwlSlot, SE_FwRawHeaderTypeDef *pFwImageHeader)
 800b0ba:	f2ad 4d54 	subw	sp, sp, #1108	; 0x454
  se_ret_status = SE_Decrypt_Init(&e_se_status, pFwImageHeader, SE_FW_IMAGE_PARTIAL);
 800b0be:	2201      	movs	r2, #1
static SFU_ErrorStatus DecryptImageInDwlSlot(uint32_t DwlSlot, SE_FwRawHeaderTypeDef *pFwImageHeader)
 800b0c0:	9005      	str	r0, [sp, #20]
  se_ret_status = SE_Decrypt_Init(&e_se_status, pFwImageHeader, SE_FW_IMAGE_PARTIAL);
 800b0c2:	a809      	add	r0, sp, #36	; 0x24
  uint32_t NumberOfChunkPerSwap = SLOT_SIZE(SLOT_SWAP) / SFU_IMG_CHUNK_SIZE;
 800b0c4:	9304      	str	r3, [sp, #16]
  se_ret_status = SE_Decrypt_Init(&e_se_status, pFwImageHeader, SE_FW_IMAGE_PARTIAL);
 800b0c6:	f000 ff31 	bl	800bf2c <SFU_Decrypt_Init>
  if ((se_ret_status == SE_SUCCESS) && (e_se_status == SE_OK))
 800b0ca:	4b89      	ldr	r3, [pc, #548]	; (800b2f0 <DecryptImageInDwlSlot.constprop.0+0x240>)
 800b0cc:	9306      	str	r3, [sp, #24]
 800b0ce:	4298      	cmp	r0, r3
  se_ret_status = SE_Decrypt_Init(&e_se_status, pFwImageHeader, SE_FW_IMAGE_PARTIAL);
 800b0d0:	4680      	mov	r8, r0
  if ((se_ret_status == SE_SUCCESS) && (e_se_status == SE_OK))
 800b0d2:	f040 80be 	bne.w	800b252 <DecryptImageInDwlSlot.constprop.0+0x1a2>
 800b0d6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800b0d8:	4a86      	ldr	r2, [pc, #536]	; (800b2f4 <DecryptImageInDwlSlot.constprop.0+0x244>)
 800b0da:	4293      	cmp	r3, r2
 800b0dc:	f040 80b9 	bne.w	800b252 <DecryptImageInDwlSlot.constprop.0+0x1a2>
  uint32_t NumberOfChunkPerSwap = SLOT_SIZE(SLOT_SWAP) / SFU_IMG_CHUNK_SIZE;
 800b0e0:	4a85      	ldr	r2, [pc, #532]	; (800b2f8 <DecryptImageInDwlSlot.constprop.0+0x248>)
    while ((e_ret_status == SFU_SUCCESS) && (fw_decrypted_total_size < (pFwImageHeader->PartialFwSize)) &&
 800b0e2:	9307      	str	r3, [sp, #28]
  uint32_t NumberOfChunkPerSwap = SLOT_SIZE(SLOT_SWAP) / SFU_IMG_CHUNK_SIZE;
 800b0e4:	68d5      	ldr	r5, [r2, #12]
 800b0e6:	9a04      	ldr	r2, [sp, #16]
 800b0e8:	3501      	adds	r5, #1
  uint32_t fw_source_address = 0U;
 800b0ea:	2700      	movs	r7, #0
  uint32_t NumberOfChunkPerSwap = SLOT_SIZE(SLOT_SWAP) / SFU_IMG_CHUNK_SIZE;
 800b0ec:	1aad      	subs	r5, r5, r2
 800b0ee:	ea4f 2b55 	mov.w	fp, r5, lsr #9
  uint32_t erase_index = 0U;
 800b0f2:	9702      	str	r7, [sp, #8]
  uint32_t fw_dest_erase_address = 0U;
 800b0f4:	46b9      	mov	r9, r7
  uint32_t fw_dest_address_write = 0U;
 800b0f6:	46ba      	mov	sl, r7
  uint32_t fw_decrypted_total_size = 0U;
 800b0f8:	9703      	str	r7, [sp, #12]
  uint32_t pass_index = 0U;
 800b0fa:	463e      	mov	r6, r7
    while ((e_ret_status == SFU_SUCCESS) && (fw_decrypted_total_size < (pFwImageHeader->PartialFwSize)) &&
 800b0fc:	4b7b      	ldr	r3, [pc, #492]	; (800b2ec <DecryptImageInDwlSlot.constprop.0+0x23c>)
 800b0fe:	691a      	ldr	r2, [r3, #16]
 800b100:	9b03      	ldr	r3, [sp, #12]
 800b102:	429a      	cmp	r2, r3
 800b104:	f240 80bb 	bls.w	800b27e <DecryptImageInDwlSlot.constprop.0+0x1ce>
 800b108:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800b10a:	9907      	ldr	r1, [sp, #28]
 800b10c:	428b      	cmp	r3, r1
 800b10e:	f040 80a0 	bne.w	800b252 <DecryptImageInDwlSlot.constprop.0+0x1a2>
      if (pass_index == NumberOfChunkPerSwap)
 800b112:	45b3      	cmp	fp, r6
 800b114:	d106      	bne.n	800b124 <DecryptImageInDwlSlot.constprop.0+0x74>
        fw_dest_address_write = SlotStartAdd[DwlSlot];
 800b116:	4b74      	ldr	r3, [pc, #464]	; (800b2e8 <DecryptImageInDwlSlot.constprop.0+0x238>)
 800b118:	9905      	ldr	r1, [sp, #20]
 800b11a:	f8cd b008 	str.w	fp, [sp, #8]
 800b11e:	f853 a021 	ldr.w	sl, [r3, r1, lsl #2]
        fw_dest_erase_address =  fw_dest_address_write;
 800b122:	46d1      	mov	r9, sl
      if (pass_index == 0U)
 800b124:	ab0a      	add	r3, sp, #40	; 0x28
 800b126:	2e00      	cmp	r6, #0
 800b128:	d177      	bne.n	800b21a <DecryptImageInDwlSlot.constprop.0+0x16a>
                            (pFwImageHeader->PartialFwOffset % SLOT_SIZE(SLOT_SWAP));
 800b12a:	4970      	ldr	r1, [pc, #448]	; (800b2ec <DecryptImageInDwlSlot.constprop.0+0x23c>)
        fw_source_address = SlotStartAdd[DwlSlot] + SFU_IMG_IMAGE_OFFSET +
 800b12c:	9e05      	ldr	r6, [sp, #20]
                            (pFwImageHeader->PartialFwOffset % SLOT_SIZE(SLOT_SWAP));
 800b12e:	68c9      	ldr	r1, [r1, #12]
        fw_source_address = SlotStartAdd[DwlSlot] + SFU_IMG_IMAGE_OFFSET +
 800b130:	4c6d      	ldr	r4, [pc, #436]	; (800b2e8 <DecryptImageInDwlSlot.constprop.0+0x238>)
                            (pFwImageHeader->PartialFwOffset % SLOT_SIZE(SLOT_SWAP));
 800b132:	fbb1 f0f5 	udiv	r0, r1, r5
        fw_source_address = SlotStartAdd[DwlSlot] + SFU_IMG_IMAGE_OFFSET +
 800b136:	f854 7026 	ldr.w	r7, [r4, r6, lsl #2]
                            (pFwImageHeader->PartialFwOffset % SLOT_SIZE(SLOT_SWAP));
 800b13a:	fb05 1110 	mls	r1, r5, r0, r1
 800b13e:	f501 7000 	add.w	r0, r1, #512	; 0x200
        fw_source_address = SlotStartAdd[DwlSlot] + SFU_IMG_IMAGE_OFFSET +
 800b142:	4407      	add	r7, r0
                                                                                  SLOT_SIZE(SLOT_SWAP))) %
 800b144:	fbb0 f6f5 	udiv	r6, r0, r5
                                  ((SFU_IMG_IMAGE_OFFSET + (pFwImageHeader->PartialFwOffset % SLOT_SIZE(SLOT_SWAP))) %
 800b148:	f3c1 0108 	ubfx	r1, r1, #0, #9
                                                                                  SLOT_SIZE(SLOT_SWAP))) %
 800b14c:	fb05 0616 	mls	r6, r5, r6, r0
        fw_dest_address_write = fw_dest_erase_address + ((SFU_IMG_IMAGE_OFFSET + (pFwImageHeader->PartialFwOffset %
 800b150:	9804      	ldr	r0, [sp, #16]
        fw_decrypted_chunk_size = sizeof(fw_decrypted_chunk) -
 800b152:	f5c1 7100 	rsb	r1, r1, #512	; 0x200
        fw_dest_address_write = fw_dest_erase_address + ((SFU_IMG_IMAGE_OFFSET + (pFwImageHeader->PartialFwOffset %
 800b156:	eb00 0a06 	add.w	sl, r0, r6
        fw_decrypted_chunk_size = sizeof(fw_decrypted_chunk) -
 800b15a:	4291      	cmp	r1, r2
 800b15c:	bf94      	ite	ls
 800b15e:	6019      	strls	r1, [r3, #0]
 800b160:	601a      	strhi	r2, [r3, #0]
        pass_index = (((SFU_IMG_IMAGE_OFFSET + (pFwImageHeader->PartialFwOffset % SLOT_SIZE(SLOT_SWAP)))
 800b162:	0a76      	lsrs	r6, r6, #9
        fw_dest_erase_address = SlotStartAdd[SLOT_SWAP];
 800b164:	4681      	mov	r9, r0
      size = fw_decrypted_chunk_size;
 800b166:	681c      	ldr	r4, [r3, #0]
      e_ret_status = SFU_LL_FLASH_Read(fw_encrypted_chunk, (uint8_t *) fw_source_address, size);
 800b168:	4639      	mov	r1, r7
 800b16a:	4622      	mov	r2, r4
 800b16c:	a894      	add	r0, sp, #592	; 0x250
 800b16e:	f001 fc51 	bl	800ca14 <SFU_LL_FLASH_Read>
      if (e_ret_status != SFU_SUCCESS)
 800b172:	4a62      	ldr	r2, [pc, #392]	; (800b2fc <DecryptImageInDwlSlot.constprop.0+0x24c>)
 800b174:	4290      	cmp	r0, r2
 800b176:	d16c      	bne.n	800b252 <DecryptImageInDwlSlot.constprop.0+0x1a2>
      if (size != 0U)
 800b178:	ab0a      	add	r3, sp, #40	; 0x28
 800b17a:	2c00      	cmp	r4, #0
 800b17c:	d05c      	beq.n	800b238 <DecryptImageInDwlSlot.constprop.0+0x188>
        se_ret_status = SE_Decrypt_Append(&e_se_status, (uint8_t *)fw_encrypted_chunk, (int32_t)size,
 800b17e:	9300      	str	r3, [sp, #0]
 800b180:	4622      	mov	r2, r4
 800b182:	ab14      	add	r3, sp, #80	; 0x50
 800b184:	a994      	add	r1, sp, #592	; 0x250
 800b186:	a809      	add	r0, sp, #36	; 0x24
 800b188:	f000 ff14 	bl	800bfb4 <SFU_Decrypt_Append>
 800b18c:	4680      	mov	r8, r0
      if ((se_ret_status == SE_SUCCESS) && (e_se_status == SE_OK) && (fw_decrypted_chunk_size == size))
 800b18e:	9b06      	ldr	r3, [sp, #24]
 800b190:	4598      	cmp	r8, r3
 800b192:	d1b3      	bne.n	800b0fc <DecryptImageInDwlSlot.constprop.0+0x4c>
 800b194:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800b196:	9a07      	ldr	r2, [sp, #28]
 800b198:	4293      	cmp	r3, r2
 800b19a:	d1af      	bne.n	800b0fc <DecryptImageInDwlSlot.constprop.0+0x4c>
 800b19c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800b19e:	429c      	cmp	r4, r3
 800b1a0:	d1ac      	bne.n	800b0fc <DecryptImageInDwlSlot.constprop.0+0x4c>
        if ((pass_index == erase_index)
 800b1a2:	9b02      	ldr	r3, [sp, #8]
 800b1a4:	429e      	cmp	r6, r3
 800b1a6:	d00a      	beq.n	800b1be <DecryptImageInDwlSlot.constprop.0+0x10e>
            || (pass_index == ((SFU_IMG_IMAGE_OFFSET + (pFwImageHeader->PartialFwOffset % SLOT_SIZE(SLOT_SWAP))) /
 800b1a8:	4b50      	ldr	r3, [pc, #320]	; (800b2ec <DecryptImageInDwlSlot.constprop.0+0x23c>)
 800b1aa:	68da      	ldr	r2, [r3, #12]
 800b1ac:	fbb2 f3f5 	udiv	r3, r2, r5
 800b1b0:	fb05 2313 	mls	r3, r5, r3, r2
 800b1b4:	f503 7300 	add.w	r3, r3, #512	; 0x200
 800b1b8:	ebb6 2f53 	cmp.w	r6, r3, lsr #9
 800b1bc:	d112      	bne.n	800b1e4 <DecryptImageInDwlSlot.constprop.0+0x134>
          (void) SFU_LL_SECU_IWDG_Refresh();
 800b1be:	f001 fe5d 	bl	800ce7c <SFU_LL_SECU_IWDG_Refresh>
          e_ret_status = SFU_LL_FLASH_Erase_Size(&flash_if_status, (uint8_t *)fw_dest_erase_address,
 800b1c2:	462a      	mov	r2, r5
 800b1c4:	4649      	mov	r1, r9
 800b1c6:	f10d 0023 	add.w	r0, sp, #35	; 0x23
 800b1ca:	f001 fc15 	bl	800c9f8 <SFU_LL_FLASH_Erase_Size>
        STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_ERASE_FAILED);
 800b1ce:	f641 73e1 	movw	r3, #8161	; 0x1fe1
 800b1d2:	4298      	cmp	r0, r3
 800b1d4:	d032      	beq.n	800b23c <DecryptImageInDwlSlot.constprop.0+0x18c>
        if (e_ret_status == SFU_SUCCESS)
 800b1d6:	4b49      	ldr	r3, [pc, #292]	; (800b2fc <DecryptImageInDwlSlot.constprop.0+0x24c>)
 800b1d8:	4298      	cmp	r0, r3
 800b1da:	d13a      	bne.n	800b252 <DecryptImageInDwlSlot.constprop.0+0x1a2>
          erase_index += NumberOfChunkPerSwap;
 800b1dc:	9b02      	ldr	r3, [sp, #8]
 800b1de:	445b      	add	r3, fp
 800b1e0:	9302      	str	r3, [sp, #8]
          fw_dest_erase_address += SLOT_SIZE(SLOT_SWAP);
 800b1e2:	44a9      	add	r9, r5
          if ((size & ((uint32_t)sizeof(SFU_LL_FLASH_write_t) - 1U)) != 0U)
 800b1e4:	0763      	lsls	r3, r4, #29
 800b1e6:	d007      	beq.n	800b1f8 <DecryptImageInDwlSlot.constprop.0+0x148>
            size = size + ((uint32_t)sizeof(SFU_LL_FLASH_write_t) - (size % (uint32_t)sizeof(SFU_LL_FLASH_write_t)));
 800b1e8:	f024 0307 	bic.w	r3, r4, #7
 800b1ec:	3308      	adds	r3, #8
              fw_decrypted_chunk[oldsize] = 0xFF;
 800b1ee:	aa14      	add	r2, sp, #80	; 0x50
 800b1f0:	21ff      	movs	r1, #255	; 0xff
            while (oldsize < size)
 800b1f2:	42a3      	cmp	r3, r4
 800b1f4:	d830      	bhi.n	800b258 <DecryptImageInDwlSlot.constprop.0+0x1a8>
 800b1f6:	461c      	mov	r4, r3
          e_ret_status = SFU_LL_FLASH_Write(&flash_if_status, (uint8_t *)fw_dest_address_write,  fw_decrypted_chunk,
 800b1f8:	4623      	mov	r3, r4
 800b1fa:	aa14      	add	r2, sp, #80	; 0x50
 800b1fc:	4651      	mov	r1, sl
 800b1fe:	f10d 0023 	add.w	r0, sp, #35	; 0x23
 800b202:	f001 fc00 	bl	800ca06 <SFU_LL_FLASH_Write>
          STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_WRITE_FAILED);
 800b206:	f641 73e1 	movw	r3, #8161	; 0x1fe1
 800b20a:	4298      	cmp	r0, r3
 800b20c:	d127      	bne.n	800b25e <DecryptImageInDwlSlot.constprop.0+0x1ae>
 800b20e:	4b3c      	ldr	r3, [pc, #240]	; (800b300 <DecryptImageInDwlSlot.constprop.0+0x250>)
 800b210:	2102      	movs	r1, #2
 800b212:	7019      	strb	r1, [r3, #0]
 800b214:	f240 4297 	movw	r2, #1175	; 0x497
 800b218:	e015      	b.n	800b246 <DecryptImageInDwlSlot.constprop.0+0x196>
        if ((pFwImageHeader->PartialFwSize - fw_decrypted_total_size) < fw_decrypted_chunk_size)
 800b21a:	9903      	ldr	r1, [sp, #12]
 800b21c:	1a52      	subs	r2, r2, r1
 800b21e:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 800b222:	d201      	bcs.n	800b228 <DecryptImageInDwlSlot.constprop.0+0x178>
          fw_decrypted_chunk_size = ((pFwImageHeader->PartialFwSize - fw_decrypted_total_size) / 32U) * 16U;
 800b224:	601a      	str	r2, [r3, #0]
          if ((fw_decrypted_chunk_size & ((uint32_t)sizeof(SFU_LL_FLASH_write_t) - 1U)) != 0U)
 800b226:	e79e      	b.n	800b166 <DecryptImageInDwlSlot.constprop.0+0xb6>
        else if ((pFwImageHeader->PartialFwSize - fw_decrypted_total_size) < ((2U * fw_decrypted_chunk_size) - 16U))
 800b228:	f5b2 7f7c 	cmp.w	r2, #1008	; 0x3f0
          fw_decrypted_chunk_size = ((pFwImageHeader->PartialFwSize - fw_decrypted_total_size) / 32U) * 16U;
 800b22c:	bf36      	itet	cc
 800b22e:	0952      	lsrcc	r2, r2, #5
        fw_decrypted_chunk_size = sizeof(fw_decrypted_chunk);
 800b230:	f44f 7200 	movcs.w	r2, #512	; 0x200
          fw_decrypted_chunk_size = ((pFwImageHeader->PartialFwSize - fw_decrypted_total_size) / 32U) * 16U;
 800b234:	0112      	lslcc	r2, r2, #4
 800b236:	e7f5      	b.n	800b224 <DecryptImageInDwlSlot.constprop.0+0x174>
        fw_decrypted_chunk_size = 0U;
 800b238:	601c      	str	r4, [r3, #0]
 800b23a:	e7a8      	b.n	800b18e <DecryptImageInDwlSlot.constprop.0+0xde>
        STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_ERASE_FAILED);
 800b23c:	4b30      	ldr	r3, [pc, #192]	; (800b300 <DecryptImageInDwlSlot.constprop.0+0x250>)
 800b23e:	2101      	movs	r1, #1
 800b240:	7019      	strb	r1, [r3, #0]
 800b242:	f240 427c 	movw	r2, #1148	; 0x47c
          STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_WRITE_FAILED);
 800b246:	4b2f      	ldr	r3, [pc, #188]	; (800b304 <DecryptImageInDwlSlot.constprop.0+0x254>)
 800b248:	482f      	ldr	r0, [pc, #188]	; (800b308 <DecryptImageInDwlSlot.constprop.0+0x258>)
 800b24a:	601a      	str	r2, [r3, #0]
 800b24c:	4b2f      	ldr	r3, [pc, #188]	; (800b30c <DecryptImageInDwlSlot.constprop.0+0x25c>)
 800b24e:	f003 fd53 	bl	800ecf8 <iprintf>
    e_ret_status = SFU_ERROR;
 800b252:	f641 74e1 	movw	r4, #8161	; 0x1fe1
 800b256:	e041      	b.n	800b2dc <DecryptImageInDwlSlot.constprop.0+0x22c>
              fw_decrypted_chunk[oldsize] = 0xFF;
 800b258:	54a1      	strb	r1, [r4, r2]
              oldsize++;
 800b25a:	3401      	adds	r4, #1
 800b25c:	e7c9      	b.n	800b1f2 <DecryptImageInDwlSlot.constprop.0+0x142>
          if (e_ret_status == SFU_SUCCESS)
 800b25e:	4b27      	ldr	r3, [pc, #156]	; (800b2fc <DecryptImageInDwlSlot.constprop.0+0x24c>)
 800b260:	4298      	cmp	r0, r3
 800b262:	d1f6      	bne.n	800b252 <DecryptImageInDwlSlot.constprop.0+0x1a2>
            fw_decrypted_total_size += size;
 800b264:	9b03      	ldr	r3, [sp, #12]
            (void) memset(fw_decrypted_chunk, 0xff, sizeof(fw_decrypted_chunk));
 800b266:	f44f 7200 	mov.w	r2, #512	; 0x200
            fw_decrypted_total_size += size;
 800b26a:	4423      	add	r3, r4
            (void) memset(fw_decrypted_chunk, 0xff, sizeof(fw_decrypted_chunk));
 800b26c:	21ff      	movs	r1, #255	; 0xff
 800b26e:	a814      	add	r0, sp, #80	; 0x50
            fw_decrypted_total_size += size;
 800b270:	9303      	str	r3, [sp, #12]
            fw_dest_address_write  += (size);
 800b272:	44a2      	add	sl, r4
            (void) memset(fw_decrypted_chunk, 0xff, sizeof(fw_decrypted_chunk));
 800b274:	f003 fd38 	bl	800ece8 <memset>
            fw_source_address += size;
 800b278:	4427      	add	r7, r4
            pass_index += 1U;
 800b27a:	3601      	adds	r6, #1
    while ((e_ret_status == SFU_SUCCESS) && (fw_decrypted_total_size < (pFwImageHeader->PartialFwSize)) &&
 800b27c:	e73e      	b.n	800b0fc <DecryptImageInDwlSlot.constprop.0+0x4c>
  if ((se_ret_status == SE_SUCCESS) && (e_ret_status == SFU_SUCCESS) && (e_se_status == SE_OK))
 800b27e:	9b06      	ldr	r3, [sp, #24]
 800b280:	4598      	cmp	r8, r3
 800b282:	d1e6      	bne.n	800b252 <DecryptImageInDwlSlot.constprop.0+0x1a2>
 800b284:	9c09      	ldr	r4, [sp, #36]	; 0x24
 800b286:	4b1b      	ldr	r3, [pc, #108]	; (800b2f4 <DecryptImageInDwlSlot.constprop.0+0x244>)
 800b288:	429c      	cmp	r4, r3
 800b28a:	d1e2      	bne.n	800b252 <DecryptImageInDwlSlot.constprop.0+0x1a2>
    fw_tag_len = sizeof(fw_tag_output);
 800b28c:	2320      	movs	r3, #32
    se_ret_status = SE_Decrypt_Finish(&e_se_status, fw_tag_output, (int32_t *)&fw_tag_len);
 800b28e:	aa0b      	add	r2, sp, #44	; 0x2c
 800b290:	a90c      	add	r1, sp, #48	; 0x30
 800b292:	a809      	add	r0, sp, #36	; 0x24
    fw_tag_len = sizeof(fw_tag_output);
 800b294:	930b      	str	r3, [sp, #44]	; 0x2c
    se_ret_status = SE_Decrypt_Finish(&e_se_status, fw_tag_output, (int32_t *)&fw_tag_len);
 800b296:	f000 feaf 	bl	800bff8 <SFU_Decrypt_Finish>
    if ((se_ret_status != SE_SUCCESS) || (e_se_status != SE_OK))
 800b29a:	4540      	cmp	r0, r8
 800b29c:	d1d9      	bne.n	800b252 <DecryptImageInDwlSlot.constprop.0+0x1a2>
 800b29e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800b2a0:	42a3      	cmp	r3, r4
 800b2a2:	d1d6      	bne.n	800b252 <DecryptImageInDwlSlot.constprop.0+0x1a2>
      if (pass_index <= NumberOfChunkPerSwap)
 800b2a4:	45b3      	cmp	fp, r6
        fw_dest_erase_address = SlotStartAdd[DwlSlot];
 800b2a6:	bf22      	ittt	cs
 800b2a8:	4b0f      	ldrcs	r3, [pc, #60]	; (800b2e8 <DecryptImageInDwlSlot.constprop.0+0x238>)
 800b2aa:	9a05      	ldrcs	r2, [sp, #20]
 800b2ac:	f853 9022 	ldrcs.w	r9, [r3, r2, lsl #2]
      e_ret_status = SFU_LL_FLASH_Erase_Size(&flash_if_status, (uint8_t *)fw_dest_erase_address, SLOT_SIZE(SLOT_SWAP));
 800b2b0:	f10d 0023 	add.w	r0, sp, #35	; 0x23
 800b2b4:	462a      	mov	r2, r5
 800b2b6:	4649      	mov	r1, r9
 800b2b8:	f001 fb9e 	bl	800c9f8 <SFU_LL_FLASH_Erase_Size>
      STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_ERASE_FAILED);
 800b2bc:	f641 73e1 	movw	r3, #8161	; 0x1fe1
 800b2c0:	4298      	cmp	r0, r3
      e_ret_status = SFU_LL_FLASH_Erase_Size(&flash_if_status, (uint8_t *)fw_dest_erase_address, SLOT_SIZE(SLOT_SWAP));
 800b2c2:	4604      	mov	r4, r0
      STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_ERASE_FAILED);
 800b2c4:	d10a      	bne.n	800b2dc <DecryptImageInDwlSlot.constprop.0+0x22c>
 800b2c6:	4b0e      	ldr	r3, [pc, #56]	; (800b300 <DecryptImageInDwlSlot.constprop.0+0x250>)
 800b2c8:	480f      	ldr	r0, [pc, #60]	; (800b308 <DecryptImageInDwlSlot.constprop.0+0x258>)
 800b2ca:	2101      	movs	r1, #1
 800b2cc:	7019      	strb	r1, [r3, #0]
 800b2ce:	4b0d      	ldr	r3, [pc, #52]	; (800b304 <DecryptImageInDwlSlot.constprop.0+0x254>)
 800b2d0:	f240 42c4 	movw	r2, #1220	; 0x4c4
 800b2d4:	601a      	str	r2, [r3, #0]
 800b2d6:	4b0d      	ldr	r3, [pc, #52]	; (800b30c <DecryptImageInDwlSlot.constprop.0+0x25c>)
 800b2d8:	f003 fd0e 	bl	800ecf8 <iprintf>
}
 800b2dc:	4620      	mov	r0, r4
 800b2de:	f20d 4d54 	addw	sp, sp, #1108	; 0x454
 800b2e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800b2e6:	bf00      	nop
 800b2e8:	08010f28 	.word	0x08010f28
 800b2ec:	20003c6c 	.word	0x20003c6c
 800b2f0:	0012310f 	.word	0x0012310f
 800b2f4:	0012e223 	.word	0x0012e223
 800b2f8:	08010f38 	.word	0x08010f38
 800b2fc:	00122f11 	.word	0x00122f11
 800b300:	20003db0 	.word	0x20003db0
 800b304:	20003dac 	.word	0x20003dac
 800b308:	08010fdd 	.word	0x08010fdd
 800b30c:	08010f58 	.word	0x08010f58

0800b310 <FirmwareToResume.constprop.0>:
static SFU_ErrorStatus  FirmwareToResume(uint32_t ActiveSlot, uint32_t DwlSlot, SE_FwRawHeaderTypeDef *pValidHeader,
 800b310:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800b314:	f5ad 7d78 	sub.w	sp, sp, #992	; 0x3e0
  (void) memset(erased_flash_pattern, 0xFF, MAGIC_LENGTH);
 800b318:	2220      	movs	r2, #32
 800b31a:	21ff      	movs	r1, #255	; 0xff
 800b31c:	a8a8      	add	r0, sp, #672	; 0x2a0
 800b31e:	f003 fce3 	bl	800ece8 <memset>
                        (uint8_t *)((uint32_t)TRAILER_HDR_VALID(DwlSlot) + SE_FW_AUTH_LEN + (MAGIC_LENGTH / 2U)),
 800b322:	487e      	ldr	r0, [pc, #504]	; (800b51c <FirmwareToResume.constprop.0+0x20c>)
 800b324:	4a7e      	ldr	r2, [pc, #504]	; (800b520 <FirmwareToResume.constprop.0+0x210>)
 800b326:	6885      	ldr	r5, [r0, #8]
 800b328:	6891      	ldr	r1, [r2, #8]
 800b32a:	68d2      	ldr	r2, [r2, #12]
 800b32c:	1c6b      	adds	r3, r5, #1
 800b32e:	1a5b      	subs	r3, r3, r1
 800b330:	68c1      	ldr	r1, [r0, #12]
 800b332:	3101      	adds	r1, #1
 800b334:	1a89      	subs	r1, r1, r2
 800b336:	fbb3 f3f1 	udiv	r3, r3, r1
 800b33a:	f2a5 212f 	subw	r1, r5, #559	; 0x22f
  if (SFU_LL_FLASH_Read(signature_valid,
 800b33e:	eba1 1103 	sub.w	r1, r1, r3, lsl #4
 800b342:	2210      	movs	r2, #16
 800b344:	4668      	mov	r0, sp
                        (uint8_t *)((uint32_t)TRAILER_HDR_VALID(DwlSlot) + SE_FW_AUTH_LEN + (MAGIC_LENGTH / 2U)),
 800b346:	011e      	lsls	r6, r3, #4
  if (SFU_LL_FLASH_Read(signature_valid,
 800b348:	f001 fb64 	bl	800ca14 <SFU_LL_FLASH_Read>
 800b34c:	4b75      	ldr	r3, [pc, #468]	; (800b524 <FirmwareToResume.constprop.0+0x214>)
 800b34e:	4298      	cmp	r0, r3
 800b350:	4604      	mov	r4, r0
 800b352:	d006      	beq.n	800b362 <FirmwareToResume.constprop.0+0x52>
    return SFU_ERROR;
 800b354:	f641 74e1 	movw	r4, #8161	; 0x1fe1
}
 800b358:	4620      	mov	r0, r4
 800b35a:	f50d 7d78 	add.w	sp, sp, #992	; 0x3e0
 800b35e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                        (uint8_t *)((uint32_t) TRAILER_HDR_TEST(DwlSlot) + SE_FW_AUTH_LEN + (MAGIC_LENGTH / 2U)),
 800b362:	f506 7630 	add.w	r6, r6, #704	; 0x2c0
 800b366:	1bad      	subs	r5, r5, r6
  if (SFU_LL_FLASH_Read(signature_test,
 800b368:	2210      	movs	r2, #16
 800b36a:	f205 11d1 	addw	r1, r5, #465	; 0x1d1
 800b36e:	eb0d 0002 	add.w	r0, sp, r2
 800b372:	f001 fb4f 	bl	800ca14 <SFU_LL_FLASH_Read>
 800b376:	42a0      	cmp	r0, r4
 800b378:	4606      	mov	r6, r0
 800b37a:	d1eb      	bne.n	800b354 <FirmwareToResume.constprop.0+0x44>
  if (SFU_LL_FLASH_Read(magic, TRAILER_SWAP_ADDR(DwlSlot), MAGIC_LENGTH) != SFU_SUCCESS)
 800b37c:	2220      	movs	r2, #32
 800b37e:	f205 2181 	addw	r1, r5, #641	; 0x281
 800b382:	eb0d 0002 	add.w	r0, sp, r2
 800b386:	f001 fb45 	bl	800ca14 <SFU_LL_FLASH_Read>
 800b38a:	42b0      	cmp	r0, r6
 800b38c:	4604      	mov	r4, r0
 800b38e:	d1e1      	bne.n	800b354 <FirmwareToResume.constprop.0+0x44>
  if (SFU_LL_FLASH_Read(clean, TRAILER_CLEAN_ADDR(DwlSlot), MAGIC_LENGTH) != SFU_SUCCESS)
 800b390:	2220      	movs	r2, #32
 800b392:	f205 21a1 	addw	r1, r5, #673	; 0x2a1
 800b396:	a858      	add	r0, sp, #352	; 0x160
 800b398:	f001 fb3c 	bl	800ca14 <SFU_LL_FLASH_Read>
 800b39c:	42a0      	cmp	r0, r4
 800b39e:	4606      	mov	r6, r0
 800b3a0:	d1d8      	bne.n	800b354 <FirmwareToResume.constprop.0+0x44>
  if ((memcmp(magic, signature_valid, sizeof(signature_valid)) != 0)
 800b3a2:	2210      	movs	r2, #16
 800b3a4:	4669      	mov	r1, sp
 800b3a6:	a808      	add	r0, sp, #32
 800b3a8:	f003 fc82 	bl	800ecb0 <memcmp>
 800b3ac:	2800      	cmp	r0, #0
 800b3ae:	d1d1      	bne.n	800b354 <FirmwareToResume.constprop.0+0x44>
      || (memcmp(&magic[MAGIC_LENGTH / 2U], signature_test, sizeof(signature_test)) != 0)
 800b3b0:	2210      	movs	r2, #16
 800b3b2:	eb0d 0102 	add.w	r1, sp, r2
 800b3b6:	a80c      	add	r0, sp, #48	; 0x30
 800b3b8:	f003 fc7a 	bl	800ecb0 <memcmp>
 800b3bc:	2800      	cmp	r0, #0
 800b3be:	d1c9      	bne.n	800b354 <FirmwareToResume.constprop.0+0x44>
      || (memcmp(magic, erased_flash_pattern, MAGIC_LENGTH) == 0)
 800b3c0:	2220      	movs	r2, #32
 800b3c2:	a9a8      	add	r1, sp, #672	; 0x2a0
 800b3c4:	eb0d 0002 	add.w	r0, sp, r2
 800b3c8:	f003 fc72 	bl	800ecb0 <memcmp>
 800b3cc:	2800      	cmp	r0, #0
 800b3ce:	d0c1      	beq.n	800b354 <FirmwareToResume.constprop.0+0x44>
      || (memcmp(clean, erased_flash_pattern, MAGIC_LENGTH) != 0))
 800b3d0:	2220      	movs	r2, #32
 800b3d2:	a9a8      	add	r1, sp, #672	; 0x2a0
 800b3d4:	a858      	add	r0, sp, #352	; 0x160
 800b3d6:	f003 fc6b 	bl	800ecb0 <memcmp>
 800b3da:	2800      	cmp	r0, #0
 800b3dc:	d1ba      	bne.n	800b354 <FirmwareToResume.constprop.0+0x44>
    e_ret_status = SFU_LL_FLASH_Read(fw_header_trailer_test, TRAILER_HDR_TEST(DwlSlot), sizeof(fw_header_trailer_test));
 800b3de:	f44f 72a0 	mov.w	r2, #320	; 0x140
 800b3e2:	f205 1141 	addw	r1, r5, #321	; 0x141
 800b3e6:	a858      	add	r0, sp, #352	; 0x160
 800b3e8:	f001 fb14 	bl	800ca14 <SFU_LL_FLASH_Read>
    STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_READ_FAILED);
 800b3ec:	f641 73e1 	movw	r3, #8161	; 0x1fe1
 800b3f0:	4298      	cmp	r0, r3
    e_ret_status = SFU_LL_FLASH_Read(fw_header_trailer_test, TRAILER_HDR_TEST(DwlSlot), sizeof(fw_header_trailer_test));
 800b3f2:	4604      	mov	r4, r0
    STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_READ_FAILED);
 800b3f4:	d10b      	bne.n	800b40e <FirmwareToResume.constprop.0+0xfe>
 800b3f6:	4b4c      	ldr	r3, [pc, #304]	; (800b528 <FirmwareToResume.constprop.0+0x218>)
 800b3f8:	2103      	movs	r1, #3
 800b3fa:	7019      	strb	r1, [r3, #0]
 800b3fc:	f240 42ec 	movw	r2, #1260	; 0x4ec
    STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_READ_FAILED);
 800b400:	4b4a      	ldr	r3, [pc, #296]	; (800b52c <FirmwareToResume.constprop.0+0x21c>)
 800b402:	484b      	ldr	r0, [pc, #300]	; (800b530 <FirmwareToResume.constprop.0+0x220>)
 800b404:	601a      	str	r2, [r3, #0]
 800b406:	4b4b      	ldr	r3, [pc, #300]	; (800b534 <FirmwareToResume.constprop.0+0x224>)
 800b408:	f003 fc76 	bl	800ecf8 <iprintf>
    if (e_ret_status == SFU_SUCCESS)
 800b40c:	e7a4      	b.n	800b358 <FirmwareToResume.constprop.0+0x48>
  if (e_ret_status == SFU_SUCCESS)
 800b40e:	42b0      	cmp	r0, r6
 800b410:	d1a0      	bne.n	800b354 <FirmwareToResume.constprop.0+0x44>
    e_ret_status = ParseFWInfo(pTestHeader, fw_header_trailer_test);
 800b412:	4849      	ldr	r0, [pc, #292]	; (800b538 <FirmwareToResume.constprop.0+0x228>)
 800b414:	4f48      	ldr	r7, [pc, #288]	; (800b538 <FirmwareToResume.constprop.0+0x228>)
 800b416:	a958      	add	r1, sp, #352	; 0x160
 800b418:	f7ff fb06 	bl	800aa28 <ParseFWInfo>
  if (e_ret_status == SFU_SUCCESS)
 800b41c:	4b41      	ldr	r3, [pc, #260]	; (800b524 <FirmwareToResume.constprop.0+0x214>)
 800b41e:	4298      	cmp	r0, r3
    e_ret_status = ParseFWInfo(pTestHeader, fw_header_trailer_test);
 800b420:	4604      	mov	r4, r0
  if (e_ret_status == SFU_SUCCESS)
 800b422:	d197      	bne.n	800b354 <FirmwareToResume.constprop.0+0x44>
    if (ActiveSlot == SFU_IMG_GetFwImageSlot(pTestHeader))
 800b424:	4638      	mov	r0, r7
 800b426:	f7ff fcdd 	bl	800ade4 <SFU_IMG_GetFwImageSlot>
 800b42a:	2801      	cmp	r0, #1
 800b42c:	d192      	bne.n	800b354 <FirmwareToResume.constprop.0+0x44>
      e_ret_status = VerifyHeaderSignature((SE_FwRawHeaderTypeDef *)(uint32_t)fw_header_trailer_test);
 800b42e:	a858      	add	r0, sp, #352	; 0x160
 800b430:	f7ff fce4 	bl	800adfc <VerifyHeaderSignature>
  if (e_ret_status != SFU_SUCCESS)
 800b434:	42a0      	cmp	r0, r4
      e_ret_status = VerifyHeaderSignature((SE_FwRawHeaderTypeDef *)(uint32_t)fw_header_trailer_test);
 800b436:	4606      	mov	r6, r0
  if (e_ret_status != SFU_SUCCESS)
 800b438:	d18c      	bne.n	800b354 <FirmwareToResume.constprop.0+0x44>
  e_ret_status = SFU_LL_FLASH_Read(fw_header_active_slot, (uint8_t *) SlotHeaderAdd[ActiveSlot],
 800b43a:	4b40      	ldr	r3, [pc, #256]	; (800b53c <FirmwareToResume.constprop.0+0x22c>)
 800b43c:	f44f 72a0 	mov.w	r2, #320	; 0x140
 800b440:	6859      	ldr	r1, [r3, #4]
 800b442:	a8a8      	add	r0, sp, #672	; 0x2a0
 800b444:	f001 fae6 	bl	800ca14 <SFU_LL_FLASH_Read>
  STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_READ_FAILED);
 800b448:	f641 78e1 	movw	r8, #8161	; 0x1fe1
 800b44c:	4540      	cmp	r0, r8
  e_ret_status = SFU_LL_FLASH_Read(fw_header_active_slot, (uint8_t *) SlotHeaderAdd[ActiveSlot],
 800b44e:	4604      	mov	r4, r0
  STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_READ_FAILED);
 800b450:	d11b      	bne.n	800b48a <FirmwareToResume.constprop.0+0x17a>
 800b452:	4b35      	ldr	r3, [pc, #212]	; (800b528 <FirmwareToResume.constprop.0+0x218>)
 800b454:	4836      	ldr	r0, [pc, #216]	; (800b530 <FirmwareToResume.constprop.0+0x220>)
 800b456:	2103      	movs	r1, #3
 800b458:	7019      	strb	r1, [r3, #0]
 800b45a:	4b34      	ldr	r3, [pc, #208]	; (800b52c <FirmwareToResume.constprop.0+0x21c>)
 800b45c:	f240 520f 	movw	r2, #1295	; 0x50f
 800b460:	601a      	str	r2, [r3, #0]
 800b462:	4b34      	ldr	r3, [pc, #208]	; (800b534 <FirmwareToResume.constprop.0+0x224>)
 800b464:	f003 fc48 	bl	800ecf8 <iprintf>
    e_ret_status = SFU_LL_FLASH_Read(fw_header_trailer_valid, TRAILER_HDR_VALID(DwlSlot),
 800b468:	f44f 72a0 	mov.w	r2, #320	; 0x140
 800b46c:	1c69      	adds	r1, r5, #1
 800b46e:	a808      	add	r0, sp, #32
 800b470:	f001 fad0 	bl	800ca14 <SFU_LL_FLASH_Read>
    STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_READ_FAILED);
 800b474:	f641 73e1 	movw	r3, #8161	; 0x1fe1
 800b478:	4298      	cmp	r0, r3
    e_ret_status = SFU_LL_FLASH_Read(fw_header_trailer_valid, TRAILER_HDR_VALID(DwlSlot),
 800b47a:	4604      	mov	r4, r0
    STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_READ_FAILED);
 800b47c:	d137      	bne.n	800b4ee <FirmwareToResume.constprop.0+0x1de>
 800b47e:	4b2a      	ldr	r3, [pc, #168]	; (800b528 <FirmwareToResume.constprop.0+0x218>)
 800b480:	2103      	movs	r1, #3
 800b482:	7019      	strb	r1, [r3, #0]
 800b484:	f240 524c 	movw	r2, #1356	; 0x54c
 800b488:	e7ba      	b.n	800b400 <FirmwareToResume.constprop.0+0xf0>
  if (e_ret_status == SFU_SUCCESS)
 800b48a:	42b0      	cmp	r0, r6
 800b48c:	d1ec      	bne.n	800b468 <FirmwareToResume.constprop.0+0x158>
    e_ret_status = VerifyHeaderSignature((SE_FwRawHeaderTypeDef *)(uint32_t)fw_header_active_slot);
 800b48e:	a8a8      	add	r0, sp, #672	; 0x2a0
 800b490:	f7ff fcb4 	bl	800adfc <VerifyHeaderSignature>
  if (e_ret_status == SFU_SUCCESS)
 800b494:	42a0      	cmp	r0, r4
    e_ret_status = VerifyHeaderSignature((SE_FwRawHeaderTypeDef *)(uint32_t)fw_header_active_slot);
 800b496:	4606      	mov	r6, r0
  if (e_ret_status == SFU_SUCCESS)
 800b498:	d1e6      	bne.n	800b468 <FirmwareToResume.constprop.0+0x158>
    e_ret_status = ParseFWInfo(pValidHeader, fw_header_active_slot);
 800b49a:	4829      	ldr	r0, [pc, #164]	; (800b540 <FirmwareToResume.constprop.0+0x230>)
 800b49c:	a9a8      	add	r1, sp, #672	; 0x2a0
 800b49e:	f7ff fac3 	bl	800aa28 <ParseFWInfo>
    if (e_ret_status == SFU_SUCCESS)
 800b4a2:	42b0      	cmp	r0, r6
    e_ret_status = ParseFWInfo(pValidHeader, fw_header_active_slot);
 800b4a4:	4604      	mov	r4, r0
    if (e_ret_status == SFU_SUCCESS)
 800b4a6:	f47f af57 	bne.w	800b358 <FirmwareToResume.constprop.0+0x48>
      e_ret_status = SFU_LL_FLASH_Read(fw_header_trailer_valid, TRAILER_HDR_VALID(DwlSlot),
 800b4aa:	f44f 72a0 	mov.w	r2, #320	; 0x140
 800b4ae:	1c69      	adds	r1, r5, #1
 800b4b0:	a808      	add	r0, sp, #32
 800b4b2:	f001 faaf 	bl	800ca14 <SFU_LL_FLASH_Read>
      STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_READ_FAILED);
 800b4b6:	4540      	cmp	r0, r8
      e_ret_status = SFU_LL_FLASH_Read(fw_header_trailer_valid, TRAILER_HDR_VALID(DwlSlot),
 800b4b8:	4604      	mov	r4, r0
      STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_READ_FAILED);
 800b4ba:	d105      	bne.n	800b4c8 <FirmwareToResume.constprop.0+0x1b8>
 800b4bc:	4b1a      	ldr	r3, [pc, #104]	; (800b528 <FirmwareToResume.constprop.0+0x218>)
 800b4be:	2103      	movs	r1, #3
 800b4c0:	7019      	strb	r1, [r3, #0]
 800b4c2:	f240 5222 	movw	r2, #1314	; 0x522
 800b4c6:	e79b      	b.n	800b400 <FirmwareToResume.constprop.0+0xf0>
    if (e_ret_status == SFU_SUCCESS)
 800b4c8:	42b0      	cmp	r0, r6
 800b4ca:	f47f af45 	bne.w	800b358 <FirmwareToResume.constprop.0+0x48>
      if (memcmp(fw_header_active_slot, fw_header_trailer_valid, SE_FW_AUTH_LEN) != 0)
 800b4ce:	2280      	movs	r2, #128	; 0x80
 800b4d0:	a908      	add	r1, sp, #32
 800b4d2:	a8a8      	add	r0, sp, #672	; 0x2a0
 800b4d4:	f003 fbec 	bl	800ecb0 <memcmp>
 800b4d8:	2800      	cmp	r0, #0
 800b4da:	f47f af3b 	bne.w	800b354 <FirmwareToResume.constprop.0+0x44>
        e_ret_status = SFU_IMG_CheckFwVersion(ActiveSlot, pValidHeader->FwVersion, pTestHeader->FwVersion);
 800b4de:	4b18      	ldr	r3, [pc, #96]	; (800b540 <FirmwareToResume.constprop.0+0x230>)
 800b4e0:	88fa      	ldrh	r2, [r7, #6]
 800b4e2:	88d9      	ldrh	r1, [r3, #6]
          e_ret_status = SFU_IMG_CheckFwVersion(ActiveSlot, pValidHeader->FwVersion, pTestHeader->FwVersion);
 800b4e4:	2001      	movs	r0, #1
 800b4e6:	f7ff fd0d 	bl	800af04 <SFU_IMG_CheckFwVersion>
 800b4ea:	4604      	mov	r4, r0
 800b4ec:	e734      	b.n	800b358 <FirmwareToResume.constprop.0+0x48>
    if (e_ret_status == SFU_SUCCESS)
 800b4ee:	4b0d      	ldr	r3, [pc, #52]	; (800b524 <FirmwareToResume.constprop.0+0x214>)
 800b4f0:	4298      	cmp	r0, r3
 800b4f2:	f47f af31 	bne.w	800b358 <FirmwareToResume.constprop.0+0x48>
      e_ret_status = VerifyHeaderSignature((SE_FwRawHeaderTypeDef *)(uint32_t)fw_header_trailer_valid);
 800b4f6:	a808      	add	r0, sp, #32
 800b4f8:	f7ff fc80 	bl	800adfc <VerifyHeaderSignature>
      if (e_ret_status == SFU_SUCCESS)
 800b4fc:	42a0      	cmp	r0, r4
      e_ret_status = VerifyHeaderSignature((SE_FwRawHeaderTypeDef *)(uint32_t)fw_header_trailer_valid);
 800b4fe:	4605      	mov	r5, r0
      if (e_ret_status == SFU_SUCCESS)
 800b500:	f47f af2a 	bne.w	800b358 <FirmwareToResume.constprop.0+0x48>
        e_ret_status = ParseFWInfo(pValidHeader, fw_header_trailer_valid);
 800b504:	4e0e      	ldr	r6, [pc, #56]	; (800b540 <FirmwareToResume.constprop.0+0x230>)
 800b506:	a908      	add	r1, sp, #32
 800b508:	4630      	mov	r0, r6
 800b50a:	f7ff fa8d 	bl	800aa28 <ParseFWInfo>
        if (e_ret_status == SFU_SUCCESS)
 800b50e:	42a8      	cmp	r0, r5
        e_ret_status = ParseFWInfo(pValidHeader, fw_header_trailer_valid);
 800b510:	4604      	mov	r4, r0
        if (e_ret_status == SFU_SUCCESS)
 800b512:	f47f af21 	bne.w	800b358 <FirmwareToResume.constprop.0+0x48>
          e_ret_status = SFU_IMG_CheckFwVersion(ActiveSlot, pValidHeader->FwVersion, pTestHeader->FwVersion);
 800b516:	88fa      	ldrh	r2, [r7, #6]
 800b518:	88f1      	ldrh	r1, [r6, #6]
 800b51a:	e7e3      	b.n	800b4e4 <FirmwareToResume.constprop.0+0x1d4>
 800b51c:	08010f38 	.word	0x08010f38
 800b520:	08010f28 	.word	0x08010f28
 800b524:	00122f11 	.word	0x00122f11
 800b528:	20003db0 	.word	0x20003db0
 800b52c:	20003dac 	.word	0x20003dac
 800b530:	08010fdd 	.word	0x08010fdd
 800b534:	08010f58 	.word	0x08010f58
 800b538:	20003c6c 	.word	0x20003c6c
 800b53c:	08010f48 	.word	0x08010f48
 800b540:	20003db4 	.word	0x20003db4

0800b544 <SwapFirmwareImages.constprop.0>:
static SFU_ErrorStatus SwapFirmwareImages(uint32_t ActiveSlot, uint32_t DwlSlot, SE_FwRawHeaderTypeDef *pFwImageHeader)
 800b544:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t number_of_index_active_slot = SLOT_SIZE(ActiveSlot) / SLOT_SIZE(SLOT_SWAP);
 800b548:	4bb6      	ldr	r3, [pc, #728]	; (800b824 <SwapFirmwareImages.constprop.0+0x2e0>)
static SFU_ErrorStatus SwapFirmwareImages(uint32_t ActiveSlot, uint32_t DwlSlot, SE_FwRawHeaderTypeDef *pFwImageHeader)
 800b54a:	f5ad 7d25 	sub.w	sp, sp, #660	; 0x294
  uint32_t number_of_index_active_slot = SLOT_SIZE(ActiveSlot) / SLOT_SIZE(SLOT_SWAP);
 800b54e:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
 800b552:	9205      	str	r2, [sp, #20]
 800b554:	4ab4      	ldr	r2, [pc, #720]	; (800b828 <SwapFirmwareImages.constprop.0+0x2e4>)
static SFU_ErrorStatus SwapFirmwareImages(uint32_t ActiveSlot, uint32_t DwlSlot, SE_FwRawHeaderTypeDef *pFwImageHeader)
 800b556:	910f      	str	r1, [sp, #60]	; 0x3c
  uint32_t number_of_index_active_slot = SLOT_SIZE(ActiveSlot) / SLOT_SIZE(SLOT_SWAP);
 800b558:	f852 6020 	ldr.w	r6, [r2, r0, lsl #2]
 800b55c:	9905      	ldr	r1, [sp, #20]
static SFU_ErrorStatus SwapFirmwareImages(uint32_t ActiveSlot, uint32_t DwlSlot, SE_FwRawHeaderTypeDef *pFwImageHeader)
 800b55e:	9009      	str	r0, [sp, #36]	; 0x24
  uint32_t number_of_index_active_slot = SLOT_SIZE(ActiveSlot) / SLOT_SIZE(SLOT_SWAP);
 800b560:	3601      	adds	r6, #1
 800b562:	1a76      	subs	r6, r6, r1
 800b564:	68d9      	ldr	r1, [r3, #12]
 800b566:	9106      	str	r1, [sp, #24]
 800b568:	68d1      	ldr	r1, [r2, #12]
 800b56a:	9806      	ldr	r0, [sp, #24]
 800b56c:	3101      	adds	r1, #1
 800b56e:	1a0d      	subs	r5, r1, r0
 800b570:	9118      	str	r1, [sp, #96]	; 0x60
 800b572:	fbb6 f1f5 	udiv	r1, r6, r5
 800b576:	9111      	str	r1, [sp, #68]	; 0x44
  uint32_t number_of_index_dwl_slot = SLOT_SIZE(DwlSlot) / SLOT_SIZE(SLOT_SWAP);
 800b578:	990f      	ldr	r1, [sp, #60]	; 0x3c
  TRACE("\r\n\t  Image preparation done.\r\n\t  Swapping the firmware images");
 800b57a:	48ac      	ldr	r0, [pc, #688]	; (800b82c <SwapFirmwareImages.constprop.0+0x2e8>)
  uint32_t number_of_index_dwl_slot = SLOT_SIZE(DwlSlot) / SLOT_SIZE(SLOT_SWAP);
 800b57c:	f852 9021 	ldr.w	r9, [r2, r1, lsl #2]
 800b580:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 800b584:	930b      	str	r3, [sp, #44]	; 0x2c
 800b586:	f109 0801 	add.w	r8, r9, #1
 800b58a:	eba8 0703 	sub.w	r7, r8, r3
 800b58e:	fbb7 f3f5 	udiv	r3, r7, r5
 800b592:	9302      	str	r3, [sp, #8]
  TRACE("\r\n\t  Image preparation done.\r\n\t  Swapping the firmware images");
 800b594:	f003 fbb0 	bl	800ecf8 <iprintf>
  index_active_slot_partial_begin = (SFU_IMG_IMAGE_OFFSET + pFwImageHeader->PartialFwOffset) /
 800b598:	49a5      	ldr	r1, [pc, #660]	; (800b830 <SwapFirmwareImages.constprop.0+0x2ec>)
 800b59a:	68ca      	ldr	r2, [r1, #12]
 800b59c:	f502 7300 	add.w	r3, r2, #512	; 0x200
 800b5a0:	fbb3 f0f5 	udiv	r0, r3, r5
  offset_block_partial_begin = (SFU_IMG_IMAGE_OFFSET + pFwImageHeader->PartialFwOffset) %
 800b5a4:	fb05 3310 	mls	r3, r5, r0, r3
 800b5a8:	9312      	str	r3, [sp, #72]	; 0x48
  if ((pFwImageHeader->FwSize == pFwImageHeader->PartialFwSize) && (SLOT_SIZE(DwlSlot) >= SLOT_SIZE(ActiveSlot)))
 800b5aa:	688b      	ldr	r3, [r1, #8]
 800b5ac:	6909      	ldr	r1, [r1, #16]
  index_active_slot_partial_begin = (SFU_IMG_IMAGE_OFFSET + pFwImageHeader->PartialFwOffset) /
 800b5ae:	900c      	str	r0, [sp, #48]	; 0x30
  if ((pFwImageHeader->FwSize == pFwImageHeader->PartialFwSize) && (SLOT_SIZE(DwlSlot) >= SLOT_SIZE(ActiveSlot)))
 800b5b0:	428b      	cmp	r3, r1
  uint32_t number_of_chunk = SLOT_SIZE(SLOT_SWAP) / SFU_IMG_CHUNK_SIZE;
 800b5b2:	ea4f 2455 	mov.w	r4, r5, lsr #9
  if ((pFwImageHeader->FwSize == pFwImageHeader->PartialFwSize) && (SLOT_SIZE(DwlSlot) >= SLOT_SIZE(ActiveSlot)))
 800b5b6:	d11e      	bne.n	800b5f6 <SwapFirmwareImages.constprop.0+0xb2>
 800b5b8:	42be      	cmp	r6, r7
 800b5ba:	d81c      	bhi.n	800b5f6 <SwapFirmwareImages.constprop.0+0xb2>
    index_active_slot_partial_end = (SLOT_SIZE(ActiveSlot) - TRAILER_SIZE(DwlSlot)) / SLOT_SIZE(SLOT_SWAP);
 800b5bc:	9b02      	ldr	r3, [sp, #8]
 800b5be:	332c      	adds	r3, #44	; 0x2c
 800b5c0:	eba6 1603 	sub.w	r6, r6, r3, lsl #4
 800b5c4:	fbb6 f7f5 	udiv	r7, r6, r5
    offset_block_partial_end = (SLOT_SIZE(ActiveSlot) - TRAILER_SIZE(DwlSlot)) % SLOT_SIZE(SLOT_SWAP);
 800b5c8:	fb05 6317 	mls	r3, r5, r7, r6
 800b5cc:	9307      	str	r3, [sp, #28]
    index_dwl_slot_partial_end = ((SLOT_SIZE(ActiveSlot) - TRAILER_SIZE(DwlSlot)) / SLOT_SIZE(SLOT_SWAP)) - 1U;
 800b5ce:	f107 3bff 	add.w	fp, r7, #4294967295
    offset_block_final_end = (SLOT_SIZE(ActiveSlot) - TRAILER_SIZE(DwlSlot)) % SLOT_SIZE(SLOT_SWAP);
 800b5d2:	930a      	str	r3, [sp, #40]	; 0x28
    index_active_slot_final_end = (SLOT_SIZE(ActiveSlot) - TRAILER_SIZE(DwlSlot)) / SLOT_SIZE(SLOT_SWAP);
 800b5d4:	9701      	str	r7, [sp, #4]
    index_active_slot_partial_end = (SLOT_SIZE(ActiveSlot) - TRAILER_SIZE(DwlSlot)) / SLOT_SIZE(SLOT_SWAP);
 800b5d6:	9703      	str	r7, [sp, #12]
  if (offset_block_partial_end == 0)
 800b5d8:	9b07      	ldr	r3, [sp, #28]
 800b5da:	bbab      	cbnz	r3, 800b648 <SwapFirmwareImages.constprop.0+0x104>
    index_active_slot--;
 800b5dc:	9b03      	ldr	r3, [sp, #12]
    index_dwl_slot_read--;
 800b5de:	f10b 3bff 	add.w	fp, fp, #4294967295
    index_active_slot--;
 800b5e2:	1e5e      	subs	r6, r3, #1
  if (index_dwl_slot_read >= index_dwl_slot_write)
 800b5e4:	455f      	cmp	r7, fp
 800b5e6:	dc31      	bgt.n	800b64c <SwapFirmwareImages.constprop.0+0x108>
    return SFU_ERROR;
 800b5e8:	f641 74e1 	movw	r4, #8161	; 0x1fe1
}
 800b5ec:	4620      	mov	r0, r4
 800b5ee:	f50d 7d25 	add.w	sp, sp, #660	; 0x294
 800b5f2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    index_active_slot_partial_end = (SFU_IMG_IMAGE_OFFSET + pFwImageHeader->PartialFwOffset +
 800b5f6:	1850      	adds	r0, r2, r1
 800b5f8:	f500 7000 	add.w	r0, r0, #512	; 0x200
                                     pFwImageHeader->PartialFwSize) / SLOT_SIZE(SLOT_SWAP);
 800b5fc:	fbb0 f6f5 	udiv	r6, r0, r5
    offset_block_partial_end = (SFU_IMG_IMAGE_OFFSET + pFwImageHeader->PartialFwOffset +
 800b600:	fb05 0016 	mls	r0, r5, r6, r0
 800b604:	9007      	str	r0, [sp, #28]
    index_dwl_slot_partial_end = (((SFU_IMG_IMAGE_OFFSET + (pFwImageHeader->PartialFwOffset %
 800b606:	fbb2 f0f5 	udiv	r0, r2, r5
 800b60a:	fb05 2210 	mls	r2, r5, r0, r2
 800b60e:	f502 7200 	add.w	r2, r2, #512	; 0x200
    index_active_slot_final_end = ((SFU_IMG_IMAGE_OFFSET + pFwImageHeader->FwSize) / SLOT_SIZE(SLOT_SWAP));
 800b612:	f503 7300 	add.w	r3, r3, #512	; 0x200
                                                            SLOT_SIZE(SLOT_SWAP))) % SLOT_SIZE(SLOT_SWAP) +
 800b616:	fbb2 f0f5 	udiv	r0, r2, r5
 800b61a:	fb05 2210 	mls	r2, r5, r0, r2
 800b61e:	4411      	add	r1, r2
    index_active_slot_final_end = ((SFU_IMG_IMAGE_OFFSET + pFwImageHeader->FwSize) / SLOT_SIZE(SLOT_SWAP));
 800b620:	fbb3 f2f5 	udiv	r2, r3, r5
    offset_block_final_end = (SFU_IMG_IMAGE_OFFSET + pFwImageHeader->FwSize) % SLOT_SIZE(SLOT_SWAP);
 800b624:	fb05 3312 	mls	r3, r5, r2, r3
 800b628:	930a      	str	r3, [sp, #40]	; 0x28
    if (index_active_slot_partial_end == (number_of_index_active_slot - 1))
 800b62a:	9b11      	ldr	r3, [sp, #68]	; 0x44
                                   pFwImageHeader->PartialFwSize) / SLOT_SIZE(SLOT_SWAP)) - 1U;
 800b62c:	fbb1 f1f5 	udiv	r1, r1, r5
    if (index_active_slot_partial_end == (number_of_index_active_slot - 1))
 800b630:	3b01      	subs	r3, #1
 800b632:	429e      	cmp	r6, r3
      index_dwl_slot_write = number_of_index_dwl_slot - 1;
 800b634:	9b02      	ldr	r3, [sp, #8]
                                     pFwImageHeader->PartialFwSize) / SLOT_SIZE(SLOT_SWAP);
 800b636:	9603      	str	r6, [sp, #12]
                                   pFwImageHeader->PartialFwSize) / SLOT_SIZE(SLOT_SWAP)) - 1U;
 800b638:	f101 3bff 	add.w	fp, r1, #4294967295
    index_active_slot_final_end = ((SFU_IMG_IMAGE_OFFSET + pFwImageHeader->FwSize) / SLOT_SIZE(SLOT_SWAP));
 800b63c:	9201      	str	r2, [sp, #4]
      index_dwl_slot_write = number_of_index_dwl_slot - 1;
 800b63e:	bf0c      	ite	eq
 800b640:	f103 37ff 	addeq.w	r7, r3, #4294967295
      index_dwl_slot_write = number_of_index_dwl_slot - 2;
 800b644:	1e9f      	subne	r7, r3, #2
 800b646:	e7c7      	b.n	800b5d8 <SwapFirmwareImages.constprop.0+0x94>
  index_active_slot = index_active_slot_partial_end;
 800b648:	9e03      	ldr	r6, [sp, #12]
 800b64a:	e7cb      	b.n	800b5e4 <SwapFirmwareImages.constprop.0+0xa0>
                                     TRAILER_CPY_TO_DWL_SLOT(DwlSlot, TRAILER_INDEX(DwlSlot) - 1 - index_active_slot),
 800b64c:	9a02      	ldr	r2, [sp, #8]
 800b64e:	9902      	ldr	r1, [sp, #8]
 800b650:	9b02      	ldr	r3, [sp, #8]
 800b652:	eba9 1202 	sub.w	r2, r9, r2, lsl #4
 800b656:	920d      	str	r2, [sp, #52]	; 0x34
 800b658:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
 800b65c:	3201      	adds	r2, #1
 800b65e:	011b      	lsls	r3, r3, #4
 800b660:	921a      	str	r2, [sp, #104]	; 0x68
              write_len = TRAILER_BEGIN(DwlSlot) - CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write, chunk);
 800b662:	f503 7330 	add.w	r3, r3, #704	; 0x2c0
 800b666:	9a0d      	ldr	r2, [sp, #52]	; 0x34
              CHUNK_0_ADDR(ActiveSlot, index_active_slot_final_end, 0) + offset_block_final_end)
 800b668:	990a      	ldr	r1, [sp, #40]	; 0x28
              write_len = TRAILER_BEGIN(DwlSlot) - CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write, chunk);
 800b66a:	eba8 0303 	sub.w	r3, r8, r3
 800b66e:	3201      	adds	r2, #1
 800b670:	9319      	str	r3, [sp, #100]	; 0x64
 800b672:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800b674:	921d      	str	r2, [sp, #116]	; 0x74
              CHUNK_0_ADDR(ActiveSlot, index_active_slot_final_end, 0) + offset_block_final_end)
 800b676:	9a05      	ldr	r2, [sp, #20]
    if ((e_ret_status == SFU_SUCCESS) && (memcmp(&trailer, NOT_SWAPPED, sizeof(trailer)) == 0))
 800b678:	f8df 81b8 	ldr.w	r8, [pc, #440]	; 800b834 <SwapFirmwareImages.constprop.0+0x2f0>
 800b67c:	fb05 3307 	mla	r3, r5, r7, r3
              CHUNK_0_ADDR(ActiveSlot, index_active_slot_final_end, 0) + offset_block_final_end)
 800b680:	440a      	add	r2, r1
 800b682:	9304      	str	r3, [sp, #16]
 800b684:	9901      	ldr	r1, [sp, #4]
 800b686:	0263      	lsls	r3, r4, #9
 800b688:	9315      	str	r3, [sp, #84]	; 0x54
 800b68a:	1e63      	subs	r3, r4, #1
 800b68c:	fb05 2201 	mla	r2, r5, r1, r2
 800b690:	930e      	str	r3, [sp, #56]	; 0x38
 800b692:	025b      	lsls	r3, r3, #9
 800b694:	9217      	str	r2, [sp, #92]	; 0x5c
 800b696:	931c      	str	r3, [sp, #112]	; 0x70
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
 800b698:	f641 74e1 	movw	r4, #8161	; 0x1fe1
  while (index_active_slot >= 0)
 800b69c:	2e00      	cmp	r6, #0
 800b69e:	da13      	bge.n	800b6c8 <SwapFirmwareImages.constprop.0+0x184>
  if (offset_block_final_end == 0)
 800b6a0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800b6a2:	b113      	cbz	r3, 800b6aa <SwapFirmwareImages.constprop.0+0x166>
    index_active_slot_empty_begin = index_active_slot_final_end + 1;
 800b6a4:	9b01      	ldr	r3, [sp, #4]
 800b6a6:	3301      	adds	r3, #1
 800b6a8:	9301      	str	r3, [sp, #4]
  index_active_slot = number_of_index_active_slot - 1;
 800b6aa:	9b11      	ldr	r3, [sp, #68]	; 0x44
    if (e_ret_status !=  SFU_SUCCESS)
 800b6ac:	4e61      	ldr	r6, [pc, #388]	; (800b834 <SwapFirmwareImages.constprop.0+0x2f0>)
  index_active_slot = number_of_index_active_slot - 1;
 800b6ae:	1e5d      	subs	r5, r3, #1
  while (index_active_slot >= index_active_slot_empty_begin)
 800b6b0:	9b01      	ldr	r3, [sp, #4]
 800b6b2:	429d      	cmp	r5, r3
 800b6b4:	db9a      	blt.n	800b5ec <SwapFirmwareImages.constprop.0+0xa8>
    e_ret_status = EraseSlotIndex(ActiveSlot, index_active_slot);
 800b6b6:	9809      	ldr	r0, [sp, #36]	; 0x24
 800b6b8:	4629      	mov	r1, r5
 800b6ba:	f7ff fc61 	bl	800af80 <EraseSlotIndex>
    if (e_ret_status !=  SFU_SUCCESS)
 800b6be:	42b0      	cmp	r0, r6
    e_ret_status = EraseSlotIndex(ActiveSlot, index_active_slot);
 800b6c0:	4604      	mov	r4, r0
    if (e_ret_status !=  SFU_SUCCESS)
 800b6c2:	d191      	bne.n	800b5e8 <SwapFirmwareImages.constprop.0+0xa4>
    index_active_slot--;
 800b6c4:	3d01      	subs	r5, #1
 800b6c6:	e7f3      	b.n	800b6b0 <SwapFirmwareImages.constprop.0+0x16c>
    SFU_LL_SECU_IWDG_Refresh();
 800b6c8:	f001 fbd8 	bl	800ce7c <SFU_LL_SECU_IWDG_Refresh>
    TRACE(".");
 800b6cc:	202e      	movs	r0, #46	; 0x2e
 800b6ce:	f003 fb2b 	bl	800ed28 <putchar>
    if ((index_dwl_slot_write < -1) || (index_dwl_slot_read < -1))
 800b6d2:	1c78      	adds	r0, r7, #1
 800b6d4:	db88      	blt.n	800b5e8 <SwapFirmwareImages.constprop.0+0xa4>
 800b6d6:	f1bb 3fff 	cmp.w	fp, #4294967295
 800b6da:	db85      	blt.n	800b5e8 <SwapFirmwareImages.constprop.0+0xa4>
    e_ret_status = SFU_LL_FLASH_Read((uint8_t *) &trailer,
 800b6dc:	9b02      	ldr	r3, [sp, #8]
 800b6de:	1e5c      	subs	r4, r3, #1
                                     TRAILER_CPY_TO_DWL_SLOT(DwlSlot, TRAILER_INDEX(DwlSlot) - 1 - index_active_slot),
 800b6e0:	eba4 0a06 	sub.w	sl, r4, r6
 800b6e4:	ea4f 03ca 	mov.w	r3, sl, lsl #3
 800b6e8:	9310      	str	r3, [sp, #64]	; 0x40
 800b6ea:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 800b6ec:	eb03 03ca 	add.w	r3, r3, sl, lsl #3
    e_ret_status = SFU_LL_FLASH_Read((uint8_t *) &trailer,
 800b6f0:	2208      	movs	r2, #8
 800b6f2:	4619      	mov	r1, r3
 800b6f4:	a822      	add	r0, sp, #136	; 0x88
                                     TRAILER_CPY_TO_DWL_SLOT(DwlSlot, TRAILER_INDEX(DwlSlot) - 1 - index_active_slot),
 800b6f6:	9308      	str	r3, [sp, #32]
    e_ret_status = SFU_LL_FLASH_Read((uint8_t *) &trailer,
 800b6f8:	f001 f98c 	bl	800ca14 <SFU_LL_FLASH_Read>
    if ((e_ret_status == SFU_SUCCESS) && (memcmp(&trailer, NOT_SWAPPED, sizeof(trailer)) == 0))
 800b6fc:	4540      	cmp	r0, r8
 800b6fe:	d04e      	beq.n	800b79e <SwapFirmwareImages.constprop.0+0x25a>
                                     TRAILER_CPY_TO_ACTIVE_SLOT(DwlSlot, TRAILER_INDEX(DwlSlot) - 1 -
 800b700:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 800b702:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800b704:	4413      	add	r3, r2
    e_ret_status = SFU_LL_FLASH_Read((uint8_t *) &trailer,
 800b706:	4619      	mov	r1, r3
 800b708:	2208      	movs	r2, #8
 800b70a:	a822      	add	r0, sp, #136	; 0x88
                                     TRAILER_CPY_TO_ACTIVE_SLOT(DwlSlot, TRAILER_INDEX(DwlSlot) - 1 -
 800b70c:	9313      	str	r3, [sp, #76]	; 0x4c
    e_ret_status = SFU_LL_FLASH_Read((uint8_t *) &trailer,
 800b70e:	f001 f981 	bl	800ca14 <SFU_LL_FLASH_Read>
    if ((e_ret_status == SFU_SUCCESS) && (memcmp(&trailer, NOT_SWAPPED, sizeof(trailer)) == 0))
 800b712:	4540      	cmp	r0, r8
    e_ret_status = SFU_LL_FLASH_Read((uint8_t *) &trailer,
 800b714:	9014      	str	r0, [sp, #80]	; 0x50
    if ((e_ret_status == SFU_SUCCESS) && (memcmp(&trailer, NOT_SWAPPED, sizeof(trailer)) == 0))
 800b716:	f040 819f 	bne.w	800ba58 <SwapFirmwareImages.constprop.0+0x514>
 800b71a:	4947      	ldr	r1, [pc, #284]	; (800b838 <SwapFirmwareImages.constprop.0+0x2f4>)
 800b71c:	2208      	movs	r2, #8
 800b71e:	a822      	add	r0, sp, #136	; 0x88
 800b720:	f003 fac6 	bl	800ecb0 <memcmp>
 800b724:	2800      	cmp	r0, #0
 800b726:	f040 8197 	bne.w	800ba58 <SwapFirmwareImages.constprop.0+0x514>
      e_ret_status = EraseSlotIndex(ActiveSlot, index_active_slot);
 800b72a:	9809      	ldr	r0, [sp, #36]	; 0x24
 800b72c:	4631      	mov	r1, r6
 800b72e:	f7ff fc27 	bl	800af80 <EraseSlotIndex>
      if (e_ret_status !=  SFU_SUCCESS)
 800b732:	4540      	cmp	r0, r8
 800b734:	f47f af58 	bne.w	800b5e8 <SwapFirmwareImages.constprop.0+0xa4>
      for (chunk = (number_of_chunk - 1); chunk >= 0 ; chunk--)
 800b738:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800b73a:	9308      	str	r3, [sp, #32]
 800b73c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800b73e:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 800b740:	fb05 330b 	mla	r3, r5, fp, r3
 800b744:	931b      	str	r3, [sp, #108]	; 0x6c
 800b746:	9b05      	ldr	r3, [sp, #20]
 800b748:	eb03 0a02 	add.w	sl, r3, r2
 800b74c:	9b15      	ldr	r3, [sp, #84]	; 0x54
 800b74e:	f5a3 7900 	sub.w	r9, r3, #512	; 0x200
 800b752:	9b04      	ldr	r3, [sp, #16]
 800b754:	4499      	add	r9, r3
            e_ret_status = SFU_LL_FLASH_Read(buffer + (offset_block_partial_end % SFU_IMG_CHUNK_SIZE),
 800b756:	9b07      	ldr	r3, [sp, #28]
 800b758:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800b75c:	9310      	str	r3, [sp, #64]	; 0x40
 800b75e:	9a10      	ldr	r2, [sp, #64]	; 0x40
 800b760:	ab24      	add	r3, sp, #144	; 0x90
 800b762:	4413      	add	r3, r2
 800b764:	fb06 aa05 	mla	sl, r6, r5, sl
 800b768:	931e      	str	r3, [sp, #120]	; 0x78
      for (chunk = (number_of_chunk - 1); chunk >= 0 ; chunk--)
 800b76a:	9b08      	ldr	r3, [sp, #32]
 800b76c:	3301      	adds	r3, #1
 800b76e:	f040 80c7 	bne.w	800b900 <SwapFirmwareImages.constprop.0+0x3bc>
      if (index_active_slot != 0)
 800b772:	2e00      	cmp	r6, #0
 800b774:	f000 8170 	beq.w	800ba58 <SwapFirmwareImages.constprop.0+0x514>
  return SFU_LL_FLASH_Write(&flash_if_info, pAddr, (uint8_t *)pValue, sizeof(SFU_LL_FLASH_write_t));
 800b778:	2308      	movs	r3, #8
 800b77a:	4a30      	ldr	r2, [pc, #192]	; (800b83c <SwapFirmwareImages.constprop.0+0x2f8>)
 800b77c:	9913      	ldr	r1, [sp, #76]	; 0x4c
 800b77e:	f10d 0087 	add.w	r0, sp, #135	; 0x87
 800b782:	f001 f940 	bl	800ca06 <SFU_LL_FLASH_Write>
        STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_WRITE_FAILED);
 800b786:	f641 73e1 	movw	r3, #8161	; 0x1fe1
 800b78a:	4298      	cmp	r0, r3
  return SFU_LL_FLASH_Write(&flash_if_info, pAddr, (uint8_t *)pValue, sizeof(SFU_LL_FLASH_write_t));
 800b78c:	4604      	mov	r4, r0
        STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_WRITE_FAILED);
 800b78e:	f040 8160 	bne.w	800ba52 <SwapFirmwareImages.constprop.0+0x50e>
 800b792:	4b2b      	ldr	r3, [pc, #172]	; (800b840 <SwapFirmwareImages.constprop.0+0x2fc>)
 800b794:	2102      	movs	r1, #2
 800b796:	7019      	strb	r1, [r3, #0]
 800b798:	f240 3246 	movw	r2, #838	; 0x346
 800b79c:	e03a      	b.n	800b814 <SwapFirmwareImages.constprop.0+0x2d0>
    if ((e_ret_status == SFU_SUCCESS) && (memcmp(&trailer, NOT_SWAPPED, sizeof(trailer)) == 0))
 800b79e:	4926      	ldr	r1, [pc, #152]	; (800b838 <SwapFirmwareImages.constprop.0+0x2f4>)
 800b7a0:	2208      	movs	r2, #8
 800b7a2:	a822      	add	r0, sp, #136	; 0x88
 800b7a4:	f003 fa84 	bl	800ecb0 <memcmp>
 800b7a8:	2800      	cmp	r0, #0
 800b7aa:	d1a9      	bne.n	800b700 <SwapFirmwareImages.constprop.0+0x1bc>
      if (index_dwl_slot_write != (number_of_index_dwl_slot - 1))
 800b7ac:	42a7      	cmp	r7, r4
 800b7ae:	d11f      	bne.n	800b7f0 <SwapFirmwareImages.constprop.0+0x2ac>
      for (chunk = (number_of_chunk - 1); chunk >= 0 ; chunk--)
 800b7b0:	9b05      	ldr	r3, [sp, #20]
 800b7b2:	9a15      	ldr	r2, [sp, #84]	; 0x54
 800b7b4:	f8dd 9038 	ldr.w	r9, [sp, #56]	; 0x38
 800b7b8:	fb06 3305 	mla	r3, r6, r5, r3
 800b7bc:	9313      	str	r3, [sp, #76]	; 0x4c
 800b7be:	9b04      	ldr	r3, [sp, #16]
 800b7c0:	eb03 0a02 	add.w	sl, r3, r2
 800b7c4:	f1b9 3fff 	cmp.w	r9, #4294967295
 800b7c8:	d14a      	bne.n	800b860 <SwapFirmwareImages.constprop.0+0x31c>
  return SFU_LL_FLASH_Write(&flash_if_info, pAddr, (uint8_t *)pValue, sizeof(SFU_LL_FLASH_write_t));
 800b7ca:	2308      	movs	r3, #8
 800b7cc:	4a1b      	ldr	r2, [pc, #108]	; (800b83c <SwapFirmwareImages.constprop.0+0x2f8>)
 800b7ce:	9908      	ldr	r1, [sp, #32]
 800b7d0:	f10d 0087 	add.w	r0, sp, #135	; 0x87
 800b7d4:	f001 f917 	bl	800ca06 <SFU_LL_FLASH_Write>
      STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_WRITE_FAILED);
 800b7d8:	f641 73e1 	movw	r3, #8161	; 0x1fe1
 800b7dc:	4298      	cmp	r0, r3
  return SFU_LL_FLASH_Write(&flash_if_info, pAddr, (uint8_t *)pValue, sizeof(SFU_LL_FLASH_write_t));
 800b7de:	4604      	mov	r4, r0
      STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_WRITE_FAILED);
 800b7e0:	f040 808a 	bne.w	800b8f8 <SwapFirmwareImages.constprop.0+0x3b4>
 800b7e4:	4b16      	ldr	r3, [pc, #88]	; (800b840 <SwapFirmwareImages.constprop.0+0x2fc>)
 800b7e6:	2102      	movs	r1, #2
 800b7e8:	7019      	strb	r1, [r3, #0]
 800b7ea:	f240 229a 	movw	r2, #666	; 0x29a
 800b7ee:	e011      	b.n	800b814 <SwapFirmwareImages.constprop.0+0x2d0>
        if (index_dwl_slot_write == -1)
 800b7f0:	1c79      	adds	r1, r7, #1
 800b7f2:	d12d      	bne.n	800b850 <SwapFirmwareImages.constprop.0+0x30c>
          e_ret_status = SFU_LL_FLASH_Erase_Size(&flash_if_status, (uint8_t *) SlotStartAdd[SLOT_SWAP],
 800b7f4:	9906      	ldr	r1, [sp, #24]
 800b7f6:	462a      	mov	r2, r5
 800b7f8:	f10d 0086 	add.w	r0, sp, #134	; 0x86
 800b7fc:	f001 f8fc 	bl	800c9f8 <SFU_LL_FLASH_Erase_Size>
          STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_ERASE_FAILED)
 800b800:	f641 73e1 	movw	r3, #8161	; 0x1fe1
 800b804:	4298      	cmp	r0, r3
          e_ret_status = SFU_LL_FLASH_Erase_Size(&flash_if_status, (uint8_t *) SlotStartAdd[SLOT_SWAP],
 800b806:	4604      	mov	r4, r0
          STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_ERASE_FAILED)
 800b808:	d127      	bne.n	800b85a <SwapFirmwareImages.constprop.0+0x316>
 800b80a:	4b0d      	ldr	r3, [pc, #52]	; (800b840 <SwapFirmwareImages.constprop.0+0x2fc>)
 800b80c:	2101      	movs	r1, #1
 800b80e:	7019      	strb	r1, [r3, #0]
 800b810:	f44f 7218 	mov.w	r2, #608	; 0x260
        STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_WRITE_FAILED);
 800b814:	4b0b      	ldr	r3, [pc, #44]	; (800b844 <SwapFirmwareImages.constprop.0+0x300>)
 800b816:	480c      	ldr	r0, [pc, #48]	; (800b848 <SwapFirmwareImages.constprop.0+0x304>)
 800b818:	601a      	str	r2, [r3, #0]
 800b81a:	4b0c      	ldr	r3, [pc, #48]	; (800b84c <SwapFirmwareImages.constprop.0+0x308>)
 800b81c:	f003 fa6c 	bl	800ecf8 <iprintf>
        if (e_ret_status != SFU_SUCCESS)
 800b820:	e6e4      	b.n	800b5ec <SwapFirmwareImages.constprop.0+0xa8>
 800b822:	bf00      	nop
 800b824:	08010f28 	.word	0x08010f28
 800b828:	08010f38 	.word	0x08010f38
 800b82c:	08011017 	.word	0x08011017
 800b830:	20003c6c 	.word	0x20003c6c
 800b834:	00122f11 	.word	0x00122f11
 800b838:	08011238 	.word	0x08011238
 800b83c:	08011240 	.word	0x08011240
 800b840:	20003db0 	.word	0x20003db0
 800b844:	20003dac 	.word	0x20003dac
 800b848:	08010fdd 	.word	0x08010fdd
 800b84c:	08010f58 	.word	0x08010f58
          e_ret_status = EraseSlotIndex(DwlSlot, index_dwl_slot_write);
 800b850:	980f      	ldr	r0, [sp, #60]	; 0x3c
 800b852:	4639      	mov	r1, r7
 800b854:	f7ff fb94 	bl	800af80 <EraseSlotIndex>
 800b858:	4604      	mov	r4, r0
        if (e_ret_status !=  SFU_SUCCESS)
 800b85a:	4544      	cmp	r4, r8
 800b85c:	d0a8      	beq.n	800b7b0 <SwapFirmwareImages.constprop.0+0x26c>
 800b85e:	e6c3      	b.n	800b5e8 <SwapFirmwareImages.constprop.0+0xa4>
        (void)SFU_LL_FLASH_Read(buffer, CHUNK_0_ADDR_HEADER(ActiveSlot, index_active_slot, chunk), sizeof(buffer));
 800b860:	ea56 0309 	orrs.w	r3, r6, r9
 800b864:	bf05      	ittet	eq
 800b866:	9a09      	ldreq	r2, [sp, #36]	; 0x24
 800b868:	4b9e      	ldreq	r3, [pc, #632]	; (800bae4 <SwapFirmwareImages.constprop.0+0x5a0>)
 800b86a:	9b13      	ldrne	r3, [sp, #76]	; 0x4c
 800b86c:	f853 1022 	ldreq.w	r1, [r3, r2, lsl #2]
 800b870:	bf18      	it	ne
 800b872:	eb03 2149 	addne.w	r1, r3, r9, lsl #9
 800b876:	f44f 7200 	mov.w	r2, #512	; 0x200
 800b87a:	a824      	add	r0, sp, #144	; 0x90
 800b87c:	f001 f8ca 	bl	800ca14 <SFU_LL_FLASH_Read>
        if (index_dwl_slot_write == -1)
 800b880:	1c7a      	adds	r2, r7, #1
 800b882:	d114      	bne.n	800b8ae <SwapFirmwareImages.constprop.0+0x36a>
          e_ret_status = SFU_LL_FLASH_Write(&flash_if_status, CHUNK_SWAP_ADDR(chunk), buffer, write_len);
 800b884:	9906      	ldr	r1, [sp, #24]
 800b886:	f44f 7300 	mov.w	r3, #512	; 0x200
 800b88a:	aa24      	add	r2, sp, #144	; 0x90
 800b88c:	eb01 2149 	add.w	r1, r1, r9, lsl #9
 800b890:	f10d 0086 	add.w	r0, sp, #134	; 0x86
 800b894:	f001 f8b7 	bl	800ca06 <SFU_LL_FLASH_Write>
          STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_WRITE_FAILED);
 800b898:	f641 73e1 	movw	r3, #8161	; 0x1fe1
 800b89c:	4298      	cmp	r0, r3
          e_ret_status = SFU_LL_FLASH_Write(&flash_if_status, CHUNK_SWAP_ADDR(chunk), buffer, write_len);
 800b89e:	4604      	mov	r4, r0
          STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_WRITE_FAILED);
 800b8a0:	d122      	bne.n	800b8e8 <SwapFirmwareImages.constprop.0+0x3a4>
 800b8a2:	4b91      	ldr	r3, [pc, #580]	; (800bae8 <SwapFirmwareImages.constprop.0+0x5a4>)
 800b8a4:	2102      	movs	r1, #2
 800b8a6:	7019      	strb	r1, [r3, #0]
 800b8a8:	f240 2277 	movw	r2, #631	; 0x277
 800b8ac:	e7b2      	b.n	800b814 <SwapFirmwareImages.constprop.0+0x2d0>
          if (((uint32_t)CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write, chunk)) < (uint32_t)TRAILER_BEGIN(DwlSlot))
 800b8ae:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800b8b0:	f5aa 7100 	sub.w	r1, sl, #512	; 0x200
 800b8b4:	f2a3 23bf 	subw	r3, r3, #703	; 0x2bf
 800b8b8:	428b      	cmp	r3, r1
 800b8ba:	d918      	bls.n	800b8ee <SwapFirmwareImages.constprop.0+0x3aa>
            if ((uint32_t)(CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write, chunk) + write_len) >
 800b8bc:	4553      	cmp	r3, sl
              write_len = TRAILER_BEGIN(DwlSlot) - CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write, chunk);
 800b8be:	bf36      	itet	cc
 800b8c0:	9b19      	ldrcc	r3, [sp, #100]	; 0x64
        write_len = sizeof(buffer);
 800b8c2:	f44f 7300 	movcs.w	r3, #512	; 0x200
              write_len = TRAILER_BEGIN(DwlSlot) - CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write, chunk);
 800b8c6:	1a5b      	subcc	r3, r3, r1
            e_ret_status = SFU_LL_FLASH_Write(&flash_if_status, CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write, chunk),
 800b8c8:	aa24      	add	r2, sp, #144	; 0x90
 800b8ca:	f10d 0086 	add.w	r0, sp, #134	; 0x86
 800b8ce:	f001 f89a 	bl	800ca06 <SFU_LL_FLASH_Write>
            STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_WRITE_FAILED);
 800b8d2:	f641 73e1 	movw	r3, #8161	; 0x1fe1
 800b8d6:	4298      	cmp	r0, r3
            e_ret_status = SFU_LL_FLASH_Write(&flash_if_status, CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write, chunk),
 800b8d8:	4604      	mov	r4, r0
            STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_WRITE_FAILED);
 800b8da:	d105      	bne.n	800b8e8 <SwapFirmwareImages.constprop.0+0x3a4>
 800b8dc:	4b82      	ldr	r3, [pc, #520]	; (800bae8 <SwapFirmwareImages.constprop.0+0x5a4>)
 800b8de:	2102      	movs	r1, #2
 800b8e0:	7019      	strb	r1, [r3, #0]
 800b8e2:	f240 228a 	movw	r2, #650	; 0x28a
 800b8e6:	e795      	b.n	800b814 <SwapFirmwareImages.constprop.0+0x2d0>
            if (e_ret_status != SFU_SUCCESS)
 800b8e8:	4544      	cmp	r4, r8
 800b8ea:	f47f ae7d 	bne.w	800b5e8 <SwapFirmwareImages.constprop.0+0xa4>
      for (chunk = (number_of_chunk - 1); chunk >= 0 ; chunk--)
 800b8ee:	f109 39ff 	add.w	r9, r9, #4294967295
 800b8f2:	f5aa 7a00 	sub.w	sl, sl, #512	; 0x200
 800b8f6:	e765      	b.n	800b7c4 <SwapFirmwareImages.constprop.0+0x280>
      if (e_ret_status != SFU_SUCCESS)
 800b8f8:	4540      	cmp	r0, r8
 800b8fa:	f43f af01 	beq.w	800b700 <SwapFirmwareImages.constprop.0+0x1bc>
 800b8fe:	e673      	b.n	800b5e8 <SwapFirmwareImages.constprop.0+0xa4>
        if (index_dwl_slot_read == -1)
 800b900:	9b08      	ldr	r3, [sp, #32]
 800b902:	f1bb 3fff 	cmp.w	fp, #4294967295
 800b906:	ea4f 2143 	mov.w	r1, r3, lsl #9
          (void)SFU_LL_FLASH_Read(buffer, CHUNK_SWAP_ADDR(chunk), sizeof(buffer));
 800b90a:	bf0c      	ite	eq
 800b90c:	9b06      	ldreq	r3, [sp, #24]
          (void)SFU_LL_FLASH_Read(buffer, CHUNK_1_ADDR(DwlSlot, index_dwl_slot_read, chunk), sizeof(buffer));
 800b90e:	9b1b      	ldrne	r3, [sp, #108]	; 0x6c
          (void)SFU_LL_FLASH_Read(buffer, CHUNK_SWAP_ADDR(chunk), sizeof(buffer));
 800b910:	f44f 7200 	mov.w	r2, #512	; 0x200
          (void)SFU_LL_FLASH_Read(buffer, CHUNK_1_ADDR(DwlSlot, index_dwl_slot_read, chunk), sizeof(buffer));
 800b914:	4419      	add	r1, r3
 800b916:	a824      	add	r0, sp, #144	; 0x90
 800b918:	f001 f87c 	bl	800ca14 <SFU_LL_FLASH_Read>
        if (index_active_slot == index_active_slot_partial_end)
 800b91c:	9b03      	ldr	r3, [sp, #12]
 800b91e:	42b3      	cmp	r3, r6
 800b920:	d031      	beq.n	800b986 <SwapFirmwareImages.constprop.0+0x442>
        if (index_active_slot == index_active_slot_partial_begin)
 800b922:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800b924:	42b3      	cmp	r3, r6
 800b926:	d173      	bne.n	800ba10 <SwapFirmwareImages.constprop.0+0x4cc>
          if (CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write, (chunk + 1)) <=
 800b928:	f509 7300 	add.w	r3, r9, #512	; 0x200
 800b92c:	9a04      	ldr	r2, [sp, #16]
 800b92e:	9316      	str	r3, [sp, #88]	; 0x58
 800b930:	9b12      	ldr	r3, [sp, #72]	; 0x48
 800b932:	4413      	add	r3, r2
 800b934:	9a16      	ldr	r2, [sp, #88]	; 0x58
 800b936:	429a      	cmp	r2, r3
 800b938:	d93f      	bls.n	800b9ba <SwapFirmwareImages.constprop.0+0x476>
          if ((CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write, chunk) <
 800b93a:	4599      	cmp	r9, r3
 800b93c:	d353      	bcc.n	800b9e6 <SwapFirmwareImages.constprop.0+0x4a2>
        if (index_active_slot == index_active_slot_final_end)
 800b93e:	9b01      	ldr	r3, [sp, #4]
 800b940:	429e      	cmp	r6, r3
 800b942:	d109      	bne.n	800b958 <SwapFirmwareImages.constprop.0+0x414>
          if (CHUNK_0_ADDR(ActiveSlot, index_active_slot, chunk) >=
 800b944:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 800b946:	4553      	cmp	r3, sl
 800b948:	f200 809b 	bhi.w	800ba82 <SwapFirmwareImages.constprop.0+0x53e>
            memset(buffer, 0xFF, sizeof(buffer));
 800b94c:	f44f 7200 	mov.w	r2, #512	; 0x200
 800b950:	21ff      	movs	r1, #255	; 0xff
 800b952:	a824      	add	r0, sp, #144	; 0x90
            memset(buffer + (offset_block_final_end % SFU_IMG_CHUNK_SIZE), 0xFF,
 800b954:	f003 f9c8 	bl	800ece8 <memset>
        if ((index_active_slot == 0) && (chunk == 0))
 800b958:	9b08      	ldr	r3, [sp, #32]
 800b95a:	4333      	orrs	r3, r6
 800b95c:	f000 80b9 	beq.w	800bad2 <SwapFirmwareImages.constprop.0+0x58e>
        e_ret_status = SFU_LL_FLASH_Write(&flash_if_status, CHUNK_0_ADDR_MODIFIED(ActiveSlot, index_active_slot, chunk),
 800b960:	4651      	mov	r1, sl
 800b962:	f44f 7300 	mov.w	r3, #512	; 0x200
 800b966:	aa24      	add	r2, sp, #144	; 0x90
 800b968:	f10d 0086 	add.w	r0, sp, #134	; 0x86
 800b96c:	f001 f84b 	bl	800ca06 <SFU_LL_FLASH_Write>
        STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_WRITE_FAILED);
 800b970:	f641 73e1 	movw	r3, #8161	; 0x1fe1
 800b974:	4298      	cmp	r0, r3
        e_ret_status = SFU_LL_FLASH_Write(&flash_if_status, CHUNK_0_ADDR_MODIFIED(ActiveSlot, index_active_slot, chunk),
 800b976:	4604      	mov	r4, r0
        STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_WRITE_FAILED);
 800b978:	d160      	bne.n	800ba3c <SwapFirmwareImages.constprop.0+0x4f8>
 800b97a:	4b5b      	ldr	r3, [pc, #364]	; (800bae8 <SwapFirmwareImages.constprop.0+0x5a4>)
 800b97c:	2102      	movs	r1, #2
 800b97e:	7019      	strb	r1, [r3, #0]
 800b980:	f44f 724d 	mov.w	r2, #820	; 0x334
 800b984:	e746      	b.n	800b814 <SwapFirmwareImages.constprop.0+0x2d0>
          if (CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write, chunk) >= (CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write,
 800b986:	9b07      	ldr	r3, [sp, #28]
 800b988:	9a04      	ldr	r2, [sp, #16]
 800b98a:	4413      	add	r3, r2
 800b98c:	4599      	cmp	r9, r3
 800b98e:	f0c0 8087 	bcc.w	800baa0 <SwapFirmwareImages.constprop.0+0x55c>
            e_ret_status = SFU_LL_FLASH_Read(buffer, CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write, chunk),
 800b992:	f44f 7200 	mov.w	r2, #512	; 0x200
 800b996:	4649      	mov	r1, r9
 800b998:	a824      	add	r0, sp, #144	; 0x90
 800b99a:	f001 f83b 	bl	800ca14 <SFU_LL_FLASH_Read>
            STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_READ_FAILED);
 800b99e:	f641 73e1 	movw	r3, #8161	; 0x1fe1
 800b9a2:	4298      	cmp	r0, r3
            e_ret_status = SFU_LL_FLASH_Read(buffer, CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write, chunk),
 800b9a4:	4604      	mov	r4, r0
            STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_READ_FAILED);
 800b9a6:	d105      	bne.n	800b9b4 <SwapFirmwareImages.constprop.0+0x470>
 800b9a8:	4b4f      	ldr	r3, [pc, #316]	; (800bae8 <SwapFirmwareImages.constprop.0+0x5a4>)
 800b9aa:	2103      	movs	r1, #3
 800b9ac:	7019      	strb	r1, [r3, #0]
 800b9ae:	f240 22ce 	movw	r2, #718	; 0x2ce
 800b9b2:	e72f      	b.n	800b814 <SwapFirmwareImages.constprop.0+0x2d0>
            if (e_ret_status != SFU_SUCCESS)
 800b9b4:	4544      	cmp	r4, r8
 800b9b6:	d0b4      	beq.n	800b922 <SwapFirmwareImages.constprop.0+0x3de>
 800b9b8:	e616      	b.n	800b5e8 <SwapFirmwareImages.constprop.0+0xa4>
            e_ret_status = SFU_LL_FLASH_Read(buffer, CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write, chunk),
 800b9ba:	f44f 7200 	mov.w	r2, #512	; 0x200
 800b9be:	4649      	mov	r1, r9
 800b9c0:	a824      	add	r0, sp, #144	; 0x90
 800b9c2:	931f      	str	r3, [sp, #124]	; 0x7c
 800b9c4:	f001 f826 	bl	800ca14 <SFU_LL_FLASH_Read>
            STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_READ_FAILED);
 800b9c8:	f641 72e1 	movw	r2, #8161	; 0x1fe1
 800b9cc:	4290      	cmp	r0, r2
 800b9ce:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
            e_ret_status = SFU_LL_FLASH_Read(buffer, CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write, chunk),
 800b9d0:	4604      	mov	r4, r0
            STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_READ_FAILED);
 800b9d2:	d105      	bne.n	800b9e0 <SwapFirmwareImages.constprop.0+0x49c>
 800b9d4:	4b44      	ldr	r3, [pc, #272]	; (800bae8 <SwapFirmwareImages.constprop.0+0x5a4>)
 800b9d6:	2103      	movs	r1, #3
 800b9d8:	7019      	strb	r1, [r3, #0]
 800b9da:	f240 22f2 	movw	r2, #754	; 0x2f2
 800b9de:	e719      	b.n	800b814 <SwapFirmwareImages.constprop.0+0x2d0>
            if (e_ret_status != SFU_SUCCESS)
 800b9e0:	4540      	cmp	r0, r8
 800b9e2:	d0aa      	beq.n	800b93a <SwapFirmwareImages.constprop.0+0x3f6>
 800b9e4:	e600      	b.n	800b5e8 <SwapFirmwareImages.constprop.0+0xa4>
               (CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write, 0) + offset_block_partial_begin)) &&
 800b9e6:	9a16      	ldr	r2, [sp, #88]	; 0x58
 800b9e8:	429a      	cmp	r2, r3
 800b9ea:	d9a8      	bls.n	800b93e <SwapFirmwareImages.constprop.0+0x3fa>
            e_ret_status = SFU_LL_FLASH_Read(buffer, CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write, chunk),
 800b9ec:	9b12      	ldr	r3, [sp, #72]	; 0x48
 800b9ee:	4649      	mov	r1, r9
 800b9f0:	f3c3 0208 	ubfx	r2, r3, #0, #9
 800b9f4:	a824      	add	r0, sp, #144	; 0x90
 800b9f6:	f001 f80d 	bl	800ca14 <SFU_LL_FLASH_Read>
            STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_READ_FAILED);
 800b9fa:	f641 73e1 	movw	r3, #8161	; 0x1fe1
 800b9fe:	4298      	cmp	r0, r3
            e_ret_status = SFU_LL_FLASH_Read(buffer, CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write, chunk),
 800ba00:	4604      	mov	r4, r0
            STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_READ_FAILED);
 800ba02:	d118      	bne.n	800ba36 <SwapFirmwareImages.constprop.0+0x4f2>
 800ba04:	4b38      	ldr	r3, [pc, #224]	; (800bae8 <SwapFirmwareImages.constprop.0+0x5a4>)
 800ba06:	2103      	movs	r1, #3
 800ba08:	7019      	strb	r1, [r3, #0]
 800ba0a:	f240 3203 	movw	r2, #771	; 0x303
 800ba0e:	e701      	b.n	800b814 <SwapFirmwareImages.constprop.0+0x2d0>
        else if (index_active_slot == 0)
 800ba10:	2e00      	cmp	r6, #0
 800ba12:	d162      	bne.n	800bada <SwapFirmwareImages.constprop.0+0x596>
          e_ret_status = SFU_LL_FLASH_Read(buffer, CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write, chunk), sizeof(buffer));
 800ba14:	f44f 7200 	mov.w	r2, #512	; 0x200
 800ba18:	4649      	mov	r1, r9
 800ba1a:	a824      	add	r0, sp, #144	; 0x90
 800ba1c:	f000 fffa 	bl	800ca14 <SFU_LL_FLASH_Read>
          STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_READ_FAILED);
 800ba20:	f641 73e1 	movw	r3, #8161	; 0x1fe1
 800ba24:	4298      	cmp	r0, r3
          e_ret_status = SFU_LL_FLASH_Read(buffer, CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write, chunk), sizeof(buffer));
 800ba26:	4604      	mov	r4, r0
          STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_READ_FAILED);
 800ba28:	d105      	bne.n	800ba36 <SwapFirmwareImages.constprop.0+0x4f2>
 800ba2a:	4b2f      	ldr	r3, [pc, #188]	; (800bae8 <SwapFirmwareImages.constprop.0+0x5a4>)
 800ba2c:	2103      	movs	r1, #3
 800ba2e:	7019      	strb	r1, [r3, #0]
 800ba30:	f240 320f 	movw	r2, #783	; 0x30f
 800ba34:	e6ee      	b.n	800b814 <SwapFirmwareImages.constprop.0+0x2d0>
          if (e_ret_status != SFU_SUCCESS)
 800ba36:	4544      	cmp	r4, r8
 800ba38:	d081      	beq.n	800b93e <SwapFirmwareImages.constprop.0+0x3fa>
 800ba3a:	e5d5      	b.n	800b5e8 <SwapFirmwareImages.constprop.0+0xa4>
        if (e_ret_status != SFU_SUCCESS)
 800ba3c:	4540      	cmp	r0, r8
 800ba3e:	f5aa 7a00 	sub.w	sl, sl, #512	; 0x200
 800ba42:	f5a9 7900 	sub.w	r9, r9, #512	; 0x200
 800ba46:	f47f adcf 	bne.w	800b5e8 <SwapFirmwareImages.constprop.0+0xa4>
      for (chunk = (number_of_chunk - 1); chunk >= 0 ; chunk--)
 800ba4a:	9b08      	ldr	r3, [sp, #32]
 800ba4c:	3b01      	subs	r3, #1
 800ba4e:	9308      	str	r3, [sp, #32]
 800ba50:	e68b      	b.n	800b76a <SwapFirmwareImages.constprop.0+0x226>
        if (e_ret_status != SFU_SUCCESS)
 800ba52:	4540      	cmp	r0, r8
 800ba54:	f47f adc8 	bne.w	800b5e8 <SwapFirmwareImages.constprop.0+0xa4>
    if ((index_active_slot < index_active_slot_partial_begin) && (index_active_slot >= 0))
 800ba58:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    index_active_slot--;
 800ba5a:	3e01      	subs	r6, #1
    if ((index_active_slot < index_active_slot_partial_begin) && (index_active_slot >= 0))
 800ba5c:	42b3      	cmp	r3, r6
    index_dwl_slot_write--;
 800ba5e:	f107 37ff 	add.w	r7, r7, #4294967295
    index_dwl_slot_read--;
 800ba62:	f10b 3bff 	add.w	fp, fp, #4294967295
    if ((index_active_slot < index_active_slot_partial_begin) && (index_active_slot >= 0))
 800ba66:	dd04      	ble.n	800ba72 <SwapFirmwareImages.constprop.0+0x52e>
 800ba68:	1c73      	adds	r3, r6, #1
      index_dwl_slot_read = -1;  /* force read from swap area, to avoid exiting dwl slot / swap index allowed range */
 800ba6a:	bf1c      	itt	ne
 800ba6c:	f04f 3bff 	movne.w	fp, #4294967295
      index_active_slot = 0;
 800ba70:	2600      	movne	r6, #0
 800ba72:	9a18      	ldr	r2, [sp, #96]	; 0x60
 800ba74:	9b06      	ldr	r3, [sp, #24]
 800ba76:	9c14      	ldr	r4, [sp, #80]	; 0x50
 800ba78:	1a9b      	subs	r3, r3, r2
 800ba7a:	9a04      	ldr	r2, [sp, #16]
 800ba7c:	441a      	add	r2, r3
 800ba7e:	9204      	str	r2, [sp, #16]
 800ba80:	e60c      	b.n	800b69c <SwapFirmwareImages.constprop.0+0x158>
               (CHUNK_0_ADDR(ActiveSlot, index_active_slot_final_end, 0) + offset_block_final_end)) &&
 800ba82:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 800ba84:	f50a 7300 	add.w	r3, sl, #512	; 0x200
 800ba88:	429a      	cmp	r2, r3
 800ba8a:	f4bf af65 	bcs.w	800b958 <SwapFirmwareImages.constprop.0+0x414>
            memset(buffer + (offset_block_final_end % SFU_IMG_CHUNK_SIZE), 0xFF,
 800ba8e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800ba90:	f3c3 0008 	ubfx	r0, r3, #0, #9
 800ba94:	ab24      	add	r3, sp, #144	; 0x90
 800ba96:	f5c0 7200 	rsb	r2, r0, #512	; 0x200
 800ba9a:	21ff      	movs	r1, #255	; 0xff
 800ba9c:	4418      	add	r0, r3
 800ba9e:	e759      	b.n	800b954 <SwapFirmwareImages.constprop.0+0x410>
              && ((CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write, (chunk + 1))) >
 800baa0:	f509 7200 	add.w	r2, r9, #512	; 0x200
 800baa4:	4293      	cmp	r3, r2
 800baa6:	f4bf af3c 	bcs.w	800b922 <SwapFirmwareImages.constprop.0+0x3de>
            e_ret_status = SFU_LL_FLASH_Read(buffer + (offset_block_partial_end % SFU_IMG_CHUNK_SIZE),
 800baaa:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800baac:	981e      	ldr	r0, [sp, #120]	; 0x78
 800baae:	f5c3 7200 	rsb	r2, r3, #512	; 0x200
 800bab2:	eb03 0109 	add.w	r1, r3, r9
 800bab6:	f000 ffad 	bl	800ca14 <SFU_LL_FLASH_Read>
            STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_READ_FAILED);
 800baba:	f641 73e1 	movw	r3, #8161	; 0x1fe1
 800babe:	4298      	cmp	r0, r3
            e_ret_status = SFU_LL_FLASH_Read(buffer + (offset_block_partial_end % SFU_IMG_CHUNK_SIZE),
 800bac0:	4604      	mov	r4, r0
            STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_READ_FAILED);
 800bac2:	f47f af77 	bne.w	800b9b4 <SwapFirmwareImages.constprop.0+0x470>
 800bac6:	4b08      	ldr	r3, [pc, #32]	; (800bae8 <SwapFirmwareImages.constprop.0+0x5a4>)
 800bac8:	2103      	movs	r1, #3
 800baca:	7019      	strb	r1, [r3, #0]
 800bacc:	f44f 7238 	mov.w	r2, #736	; 0x2e0
 800bad0:	e6a0      	b.n	800b814 <SwapFirmwareImages.constprop.0+0x2d0>
        e_ret_status = SFU_LL_FLASH_Write(&flash_if_status, CHUNK_0_ADDR_MODIFIED(ActiveSlot, index_active_slot, chunk),
 800bad2:	9a05      	ldr	r2, [sp, #20]
 800bad4:	f502 7100 	add.w	r1, r2, #512	; 0x200
 800bad8:	e745      	b.n	800b966 <SwapFirmwareImages.constprop.0+0x422>
        if (index_active_slot == index_active_slot_final_end)
 800bada:	9b01      	ldr	r3, [sp, #4]
 800badc:	429e      	cmp	r6, r3
 800bade:	f47f af3f 	bne.w	800b960 <SwapFirmwareImages.constprop.0+0x41c>
 800bae2:	e72f      	b.n	800b944 <SwapFirmwareImages.constprop.0+0x400>
 800bae4:	08010f48 	.word	0x08010f48
 800bae8:	20003db0 	.word	0x20003db0

0800baec <SFU_IMG_CheckSwapImageHandling>:
   * Sanity check: let's make sure the slot sizes are correct
   * to avoid discrepancies between linker definitions and constants in sfu_fwimg_regions.h
   */
  for (i = 0U; i < SFU_NB_MAX_ACTIVE_IMAGE; i++)
  {
    if (SlotStartAdd[SLOT_ACTIVE_1 + i] != 0U)
 800baec:	4a35      	ldr	r2, [pc, #212]	; (800bbc4 <SFU_IMG_CheckSwapImageHandling+0xd8>)
{
 800baee:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    if (SlotStartAdd[SLOT_ACTIVE_1 + i] != 0U)
 800baf2:	4f35      	ldr	r7, [pc, #212]	; (800bbc8 <SFU_IMG_CheckSwapImageHandling+0xdc>)
 800baf4:	68d6      	ldr	r6, [r2, #12]
 800baf6:	68fd      	ldr	r5, [r7, #12]
 800baf8:	6878      	ldr	r0, [r7, #4]
 800bafa:	1c74      	adds	r4, r6, #1
 800bafc:	1b64      	subs	r4, r4, r5
 800bafe:	4690      	mov	r8, r2
 800bb00:	b168      	cbz	r0, 800bb1e <SFU_IMG_CheckSwapImageHandling+0x32>
    {
      if (!(SFU_IMG_REGION_IS_MULTIPLE(SLOT_SIZE(SLOT_ACTIVE_1 + i), SLOT_SIZE(SLOT_SWAP))))
 800bb02:	6853      	ldr	r3, [r2, #4]
 800bb04:	3301      	adds	r3, #1
 800bb06:	1a1a      	subs	r2, r3, r0
 800bb08:	fbb2 f3f4 	udiv	r3, r2, r4
 800bb0c:	4363      	muls	r3, r4
 800bb0e:	429a      	cmp	r2, r3
 800bb10:	d056      	beq.n	800bbc0 <SFU_IMG_CheckSwapImageHandling+0xd4>
      {
        TRACE("\r\n= [FWIMG] SLOT_ACTIVE_%d size (%d) must be a multiple of swap size (%d)\r\n",
 800bb12:	482e      	ldr	r0, [pc, #184]	; (800bbcc <SFU_IMG_CheckSwapImageHandling+0xe0>)
 800bb14:	4623      	mov	r3, r4
 800bb16:	2101      	movs	r1, #1
 800bb18:	f003 f8ee 	bl	800ecf8 <iprintf>
              SLOT_ACTIVE_1 + i, SLOT_SIZE(SLOT_ACTIVE_1 + i), SLOT_SIZE(SLOT_SWAP));
        e_ret_status = SFU_IMG_INIT_SLOTS_SIZE_ERROR;
 800bb1c:	2001      	movs	r0, #1
    }
  }

  for (i = 0U; i < SFU_NB_MAX_DWL_AREA; i++)
  {
    if (SlotStartAdd[SLOT_DWL_1 + i] != 0U)
 800bb1e:	68bf      	ldr	r7, [r7, #8]
 800bb20:	b1f7      	cbz	r7, 800bb60 <SFU_IMG_CheckSwapImageHandling+0x74>
    {
      if (!(SFU_IMG_REGION_IS_MULTIPLE(SLOT_SIZE(SLOT_DWL_1 + i), SLOT_SIZE(SLOT_SWAP))))
 800bb22:	f8d8 2008 	ldr.w	r2, [r8, #8]
 800bb26:	3201      	adds	r2, #1
 800bb28:	1bd2      	subs	r2, r2, r7
 800bb2a:	fbb2 f3f4 	udiv	r3, r2, r4
 800bb2e:	4363      	muls	r3, r4
 800bb30:	429a      	cmp	r2, r3
 800bb32:	d005      	beq.n	800bb40 <SFU_IMG_CheckSwapImageHandling+0x54>
      {
        TRACE("\r\n= [FWIMG] SLOT_DWL_%d size (%d) must be a multiple of swap size (%d)\r\n",
 800bb34:	4826      	ldr	r0, [pc, #152]	; (800bbd0 <SFU_IMG_CheckSwapImageHandling+0xe4>)
 800bb36:	4623      	mov	r3, r4
 800bb38:	2101      	movs	r1, #1
 800bb3a:	f003 f8dd 	bl	800ecf8 <iprintf>
              i + 1U, SLOT_SIZE(SLOT_DWL_1 + i), SLOT_SIZE(SLOT_SWAP));
        e_ret_status = SFU_IMG_INIT_SLOTS_SIZE_ERROR;
 800bb3e:	2001      	movs	r0, #1
   */
  for (i = 0U; i < SFU_NB_MAX_DWL_AREA; i++)
  {
    if (SlotStartAdd[SLOT_DWL_1 + i] != 0U)
    {
      if (((int32_t)(SFU_IMG_CHUNK_SIZE - (TRAILER_INDEX(SLOT_DWL_1 + i) * sizeof(SFU_LL_FLASH_write_t)))) < 0)
 800bb40:	f8d8 1008 	ldr.w	r1, [r8, #8]
 800bb44:	3101      	adds	r1, #1
 800bb46:	1bc9      	subs	r1, r1, r7
 800bb48:	fbb1 f1f4 	udiv	r1, r1, r4
 800bb4c:	f1c1 0340 	rsb	r3, r1, #64	; 0x40
 800bb50:	00db      	lsls	r3, r3, #3
 800bb52:	d505      	bpl.n	800bb60 <SFU_IMG_CheckSwapImageHandling+0x74>
      {
        e_ret_status = SFU_IMG_INIT_SWAP_SETTINGS_ERROR;
        TRACE("\r\n= [FWIMG] %d bytes required for the swap metadata of SLOT_DWL_%d is too much\r\n",
 800bb54:	481f      	ldr	r0, [pc, #124]	; (800bbd4 <SFU_IMG_CheckSwapImageHandling+0xe8>)
 800bb56:	2201      	movs	r2, #1
 800bb58:	00c9      	lsls	r1, r1, #3
 800bb5a:	f003 f8cd 	bl	800ecf8 <iprintf>
        e_ret_status = SFU_IMG_INIT_SWAP_SETTINGS_ERROR;
 800bb5e:	2002      	movs	r0, #2
  /*
   * Sanity check: let's make sure the swap size is correct with regards to the swap procedure constraints.
   * The swap size must be a multiple of the chunks size used to do the swap.
   */
#if defined(__GNUC__)
  __IO uint32_t swap_size = SLOT_SIZE(SLOT_SWAP), swap_chunk = SFU_IMG_CHUNK_SIZE;
 800bb60:	f44f 7100 	mov.w	r1, #512	; 0x200
 800bb64:	9400      	str	r4, [sp, #0]
 800bb66:	9101      	str	r1, [sp, #4]
  if (0U != ((uint32_t)(swap_size % swap_chunk)))
 800bb68:	9f00      	ldr	r7, [sp, #0]
 800bb6a:	9a01      	ldr	r2, [sp, #4]
 800bb6c:	fbb7 f3f2 	udiv	r3, r7, r2
 800bb70:	fb02 7313 	mls	r3, r2, r3, r7
 800bb74:	b123      	cbz	r3, 800bb80 <SFU_IMG_CheckSwapImageHandling+0x94>
#else
  if (0U != ((uint32_t)(SLOT_SIZE(SLOT_SWAP) % SFU_IMG_CHUNK_SIZE)))
#endif /* __GNUC__ */
  {
    e_ret_status = SFU_IMG_INIT_SWAP_SETTINGS_ERROR;
    TRACE("\r\n= [FWIMG] The swap procedure uses chunks of %d bytes but the swap size (%d) is not a multiple\r\n",
 800bb76:	4818      	ldr	r0, [pc, #96]	; (800bbd8 <SFU_IMG_CheckSwapImageHandling+0xec>)
 800bb78:	4622      	mov	r2, r4
 800bb7a:	f003 f8bd 	bl	800ecf8 <iprintf>
    e_ret_status = SFU_IMG_INIT_SWAP_SETTINGS_ERROR;
 800bb7e:	2002      	movs	r0, #2

  /*
   * Sanity check: let's make sure SWAP slot is properly aligned with regards to flash constraints
   */

  if (!IS_ALIGNED(SlotStartAdd[SLOT_SWAP]))
 800bb80:	f3c5 030a 	ubfx	r3, r5, #0, #11
 800bb84:	b123      	cbz	r3, 800bb90 <SFU_IMG_CheckSwapImageHandling+0xa4>
  {
    e_ret_status = SFU_IMG_INIT_FLASH_CONSTRAINTS_ERROR;
    TRACE("\r\n= [FWIMG] swap (%x) is not properly aligned\r\n",
 800bb86:	4815      	ldr	r0, [pc, #84]	; (800bbdc <SFU_IMG_CheckSwapImageHandling+0xf0>)
 800bb88:	4629      	mov	r1, r5
 800bb8a:	f003 f8b5 	bl	800ecf8 <iprintf>
    e_ret_status = SFU_IMG_INIT_FLASH_CONSTRAINTS_ERROR;
 800bb8e:	2003      	movs	r0, #3
  } /* else swap is properly aligned */

  /*
   * Sanity check: let's make sure the swap area does not overlap SB code area protected by WRP)
   */
  if (((SlotStartAdd[SLOT_SWAP] - FLASH_BASE) / FLASH_PAGE_SIZE) <= SFU_PROTECT_WRP_PAGE_END_1)
 800bb90:	4b13      	ldr	r3, [pc, #76]	; (800bbe0 <SFU_IMG_CheckSwapImageHandling+0xf4>)
 800bb92:	f105 4278 	add.w	r2, r5, #4160749568	; 0xf8000000
 800bb96:	0adb      	lsrs	r3, r3, #11
 800bb98:	ebb3 2fd2 	cmp.w	r3, r2, lsr #11
 800bb9c:	d303      	bcc.n	800bba6 <SFU_IMG_CheckSwapImageHandling+0xba>
  {
    TRACE("\r\n= [FWIMG] SWAP overlaps SBSFU code area protected by WRP\r\n");
 800bb9e:	4811      	ldr	r0, [pc, #68]	; (800bbe4 <SFU_IMG_CheckSwapImageHandling+0xf8>)
 800bba0:	f003 f944 	bl	800ee2c <puts>
    e_ret_status = SFU_IMG_INIT_FLASH_CONSTRAINTS_ERROR;
 800bba4:	2003      	movs	r0, #3
  }

  /*
   * Sanity check: let's make sure the KMS NVM area does not overlap Swap area)
   */
  if (!(((SlotStartAdd[SLOT_SWAP]) > KMS_DATASTORAGE_END)
 800bba6:	4b10      	ldr	r3, [pc, #64]	; (800bbe8 <SFU_IMG_CheckSwapImageHandling+0xfc>)
 800bba8:	429d      	cmp	r5, r3
 800bbaa:	d806      	bhi.n	800bbba <SFU_IMG_CheckSwapImageHandling+0xce>
 800bbac:	4b0f      	ldr	r3, [pc, #60]	; (800bbec <SFU_IMG_CheckSwapImageHandling+0x100>)
 800bbae:	429e      	cmp	r6, r3
 800bbb0:	d303      	bcc.n	800bbba <SFU_IMG_CheckSwapImageHandling+0xce>
        || ((SlotEndAdd[SLOT_SWAP]) < (KMS_DATASTORAGE_START))))
  {
    TRACE("\r\n= [FWIMG] KMS NVM area overlaps Swap area\r\n");
 800bbb2:	480f      	ldr	r0, [pc, #60]	; (800bbf0 <SFU_IMG_CheckSwapImageHandling+0x104>)
 800bbb4:	f003 f93a 	bl	800ee2c <puts>
    e_ret_status = SFU_IMG_INIT_FLASH_CONSTRAINTS_ERROR;
 800bbb8:	2003      	movs	r0, #3
  }

  /* FWIMG core initialization completed */
  return e_ret_status;
}
 800bbba:	b002      	add	sp, #8
 800bbbc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800bbc0:	2000      	movs	r0, #0
 800bbc2:	e7ac      	b.n	800bb1e <SFU_IMG_CheckSwapImageHandling+0x32>
 800bbc4:	08010f38 	.word	0x08010f38
 800bbc8:	08010f28 	.word	0x08010f28
 800bbcc:	08011055 	.word	0x08011055
 800bbd0:	080110a1 	.word	0x080110a1
 800bbd4:	080110ea 	.word	0x080110ea
 800bbd8:	0801113b 	.word	0x0801113b
 800bbdc:	0801119d 	.word	0x0801119d
 800bbe0:	00012fff 	.word	0x00012fff
 800bbe4:	080111cd 	.word	0x080111cd
 800bbe8:	08014fff 	.word	0x08014fff
 800bbec:	08013000 	.word	0x08013000
 800bbf0:	08011209 	.word	0x08011209

0800bbf4 <SFU_IMG_CheckPendingInstallation>:
  *         pending action)
  */
SFU_IMG_ImgInstallStateTypeDef SFU_IMG_CheckPendingInstallation(uint32_t *pDwlSlotToInstall, \
                                                                uint32_t *pActiveSlotToResume, \
                                                                uint32_t *pActiveSlotToRollback)
{
 800bbf4:	b538      	push	{r3, r4, r5, lr}
   *
   * B. Check if a Firmware image is waiting to be installed.
   */

  /* Init values */
  *pActiveSlotToResume = SLOT_INACTIVE;
 800bbf6:	2300      	movs	r3, #0
 800bbf8:	600b      	str	r3, [r1, #0]
  *pActiveSlotToRollback = SLOT_INACTIVE;
 800bbfa:	6013      	str	r3, [r2, #0]
  *pDwlSlotToInstall = SLOT_INACTIVE;
 800bbfc:	4a0f      	ldr	r2, [pc, #60]	; (800bc3c <SFU_IMG_CheckPendingInstallation+0x48>)
 800bbfe:	6003      	str	r3, [r0, #0]
  /* Check image installation stopped or installation to be done
     =========================================================== */
  for (i = 0U; i < SFU_NB_MAX_ACTIVE_IMAGE; i++)
  {
    /* Slot configured ? */
    if (SlotStartAdd[SLOT_ACTIVE_1 + i] != 0U)
 800bc00:	e9d2 2301 	ldrd	r2, r3, [r2, #4]
{
 800bc04:	4604      	mov	r4, r0
 800bc06:	460d      	mov	r5, r1
    if (SlotStartAdd[SLOT_ACTIVE_1 + i] != 0U)
 800bc08:	b162      	cbz	r2, 800bc24 <SFU_IMG_CheckPendingInstallation+0x30>
      /* Check trailer valid : installation stopped ?
         ============================================= */
      for (j = 0U; j < SFU_NB_MAX_DWL_AREA; j++)
      {
        /* Slot configured ? */
        if (SlotStartAdd[SLOT_DWL_1 + j] != 0U)
 800bc0a:	b90b      	cbnz	r3, 800bc10 <SFU_IMG_CheckPendingInstallation+0x1c>
        return SFU_IMG_FWIMAGE_TO_INSTALL;
      }
    }
  }

  return SFU_IMG_NO_FWUPDATE;
 800bc0c:	2002      	movs	r0, #2
}
 800bc0e:	bd38      	pop	{r3, r4, r5, pc}
          if (SFU_SUCCESS == FirmwareToResume(SLOT_ACTIVE_1 + i, SLOT_DWL_1 + j, &fw_image_header_validated,
 800bc10:	f7ff fb7e 	bl	800b310 <FirmwareToResume.constprop.0>
 800bc14:	4b0a      	ldr	r3, [pc, #40]	; (800bc40 <SFU_IMG_CheckPendingInstallation+0x4c>)
 800bc16:	4298      	cmp	r0, r3
 800bc18:	d106      	bne.n	800bc28 <SFU_IMG_CheckPendingInstallation+0x34>
            *pActiveSlotToResume = SLOT_ACTIVE_1 + i;
 800bc1a:	2001      	movs	r0, #1
            *pDwlSlotToInstall = SLOT_DWL_1 + j;
 800bc1c:	2302      	movs	r3, #2
            *pActiveSlotToResume = SLOT_ACTIVE_1 + i;
 800bc1e:	6028      	str	r0, [r5, #0]
            *pDwlSlotToInstall = SLOT_DWL_1 + j;
 800bc20:	6023      	str	r3, [r4, #0]
            return SFU_IMG_FWUPDATE_STOPPED;
 800bc22:	e7f4      	b.n	800bc0e <SFU_IMG_CheckPendingInstallation+0x1a>
    if (SlotStartAdd[SLOT_DWL_1 + j] != 0U)
 800bc24:	2b00      	cmp	r3, #0
 800bc26:	d0f1      	beq.n	800bc0c <SFU_IMG_CheckPendingInstallation+0x18>
      if (SFU_SUCCESS == FirmwareToInstall(SLOT_DWL_1 + j, &fw_image_header_to_test))
 800bc28:	f7ff f9f6 	bl	800b018 <FirmwareToInstall.constprop.0>
 800bc2c:	4b04      	ldr	r3, [pc, #16]	; (800bc40 <SFU_IMG_CheckPendingInstallation+0x4c>)
 800bc2e:	4298      	cmp	r0, r3
 800bc30:	d1ec      	bne.n	800bc0c <SFU_IMG_CheckPendingInstallation+0x18>
        *pDwlSlotToInstall = SLOT_DWL_1 + j;
 800bc32:	2302      	movs	r3, #2
 800bc34:	6023      	str	r3, [r4, #0]
        return SFU_IMG_FWIMAGE_TO_INSTALL;
 800bc36:	2000      	movs	r0, #0
 800bc38:	e7e9      	b.n	800bc0e <SFU_IMG_CheckPendingInstallation+0x1a>
 800bc3a:	bf00      	nop
 800bc3c:	08010f28 	.word	0x08010f28
 800bc40:	00122f11 	.word	0x00122f11

0800bc44 <SFU_IMG_GetTrailerSize>:
  * @param  SlotNumber index of the slot in the list
  * @retval Size of the trailer.
  */
uint32_t SFU_IMG_GetTrailerSize(uint32_t SlotNumber)
{
  return TRAILER_SIZE(SlotNumber);
 800bc44:	4908      	ldr	r1, [pc, #32]	; (800bc68 <SFU_IMG_GetTrailerSize+0x24>)
 800bc46:	4a09      	ldr	r2, [pc, #36]	; (800bc6c <SFU_IMG_GetTrailerSize+0x28>)
 800bc48:	f851 3020 	ldr.w	r3, [r1, r0, lsl #2]
 800bc4c:	f852 0020 	ldr.w	r0, [r2, r0, lsl #2]
 800bc50:	68d2      	ldr	r2, [r2, #12]
 800bc52:	3301      	adds	r3, #1
 800bc54:	1a18      	subs	r0, r3, r0
 800bc56:	68cb      	ldr	r3, [r1, #12]
 800bc58:	3301      	adds	r3, #1
 800bc5a:	1a9b      	subs	r3, r3, r2
 800bc5c:	fbb0 f0f3 	udiv	r0, r0, r3
 800bc60:	302c      	adds	r0, #44	; 0x2c
}
 800bc62:	0100      	lsls	r0, r0, #4
 800bc64:	4770      	bx	lr
 800bc66:	bf00      	nop
 800bc68:	08010f38 	.word	0x08010f38
 800bc6c:	08010f28 	.word	0x08010f28

0800bc70 <SFU_IMG_EraseDownloadedImg>:
  * @brief  Erase downloaded firmware in case of decryption/authentication/integrity error
  * @param  DwlSlot identification of the downloaded area
  * @retval SFU_SUCCESS if successful, a SFU_ErrorStatus error otherwise.
  */
SFU_ErrorStatus SFU_IMG_EraseDownloadedImg(uint32_t DwlSlot)
{
 800bc70:	b573      	push	{r0, r1, r4, r5, r6, lr}
  SFU_FLASH_StatusTypeDef flash_if_status;
  SFU_ErrorStatus e_ret_status_dwl = SFU_ERROR;
  SFU_ErrorStatus e_ret_status_swap = SFU_ERROR;

  e_ret_status_dwl = SFU_LL_FLASH_Erase_Size(&flash_if_status, (uint8_t *) SlotStartAdd[DwlSlot],
                                             SLOT_SIZE(DwlSlot));
 800bc72:	4c20      	ldr	r4, [pc, #128]	; (800bcf4 <SFU_IMG_EraseDownloadedImg+0x84>)
  e_ret_status_dwl = SFU_LL_FLASH_Erase_Size(&flash_if_status, (uint8_t *) SlotStartAdd[DwlSlot],
 800bc74:	4e20      	ldr	r6, [pc, #128]	; (800bcf8 <SFU_IMG_EraseDownloadedImg+0x88>)
 800bc76:	f854 2020 	ldr.w	r2, [r4, r0, lsl #2]
 800bc7a:	f856 1020 	ldr.w	r1, [r6, r0, lsl #2]
 800bc7e:	3201      	adds	r2, #1
 800bc80:	1a52      	subs	r2, r2, r1
 800bc82:	f10d 0007 	add.w	r0, sp, #7
 800bc86:	f000 feb7 	bl	800c9f8 <SFU_LL_FLASH_Erase_Size>
  STATUS_FWIMG(e_ret_status_dwl == SFU_ERROR, SFU_IMG_FLASH_ERASE_FAILED);
 800bc8a:	f641 73e1 	movw	r3, #8161	; 0x1fe1
 800bc8e:	4298      	cmp	r0, r3
  e_ret_status_dwl = SFU_LL_FLASH_Erase_Size(&flash_if_status, (uint8_t *) SlotStartAdd[DwlSlot],
 800bc90:	4605      	mov	r5, r0
  STATUS_FWIMG(e_ret_status_dwl == SFU_ERROR, SFU_IMG_FLASH_ERASE_FAILED);
 800bc92:	d10a      	bne.n	800bcaa <SFU_IMG_EraseDownloadedImg+0x3a>
 800bc94:	4b19      	ldr	r3, [pc, #100]	; (800bcfc <SFU_IMG_EraseDownloadedImg+0x8c>)
 800bc96:	481a      	ldr	r0, [pc, #104]	; (800bd00 <SFU_IMG_EraseDownloadedImg+0x90>)
 800bc98:	2101      	movs	r1, #1
 800bc9a:	7019      	strb	r1, [r3, #0]
 800bc9c:	4b19      	ldr	r3, [pc, #100]	; (800bd04 <SFU_IMG_EraseDownloadedImg+0x94>)
 800bc9e:	f640 1201 	movw	r2, #2305	; 0x901
 800bca2:	601a      	str	r2, [r3, #0]
 800bca4:	4b18      	ldr	r3, [pc, #96]	; (800bd08 <SFU_IMG_EraseDownloadedImg+0x98>)
 800bca6:	f003 f827 	bl	800ecf8 <iprintf>

  e_ret_status_swap = SFU_LL_FLASH_Erase_Size(&flash_if_status, (uint8_t *) SlotStartAdd[SLOT_SWAP],
 800bcaa:	68e2      	ldr	r2, [r4, #12]
 800bcac:	68f1      	ldr	r1, [r6, #12]
 800bcae:	3201      	adds	r2, #1
 800bcb0:	1a52      	subs	r2, r2, r1
 800bcb2:	f10d 0007 	add.w	r0, sp, #7
 800bcb6:	f000 fe9f 	bl	800c9f8 <SFU_LL_FLASH_Erase_Size>
                                              SLOT_SIZE(SLOT_SWAP));
  STATUS_FWIMG(e_ret_status_swap == SFU_ERROR, SFU_IMG_FLASH_ERASE_FAILED);
 800bcba:	f641 73e1 	movw	r3, #8161	; 0x1fe1
 800bcbe:	4298      	cmp	r0, r3
  e_ret_status_swap = SFU_LL_FLASH_Erase_Size(&flash_if_status, (uint8_t *) SlotStartAdd[SLOT_SWAP],
 800bcc0:	4604      	mov	r4, r0
  STATUS_FWIMG(e_ret_status_swap == SFU_ERROR, SFU_IMG_FLASH_ERASE_FAILED);
 800bcc2:	d10d      	bne.n	800bce0 <SFU_IMG_EraseDownloadedImg+0x70>
 800bcc4:	4b0d      	ldr	r3, [pc, #52]	; (800bcfc <SFU_IMG_EraseDownloadedImg+0x8c>)
 800bcc6:	480e      	ldr	r0, [pc, #56]	; (800bd00 <SFU_IMG_EraseDownloadedImg+0x90>)
 800bcc8:	2101      	movs	r1, #1
 800bcca:	7019      	strb	r1, [r3, #0]
 800bccc:	4b0d      	ldr	r3, [pc, #52]	; (800bd04 <SFU_IMG_EraseDownloadedImg+0x94>)
 800bcce:	f640 1205 	movw	r2, #2309	; 0x905
 800bcd2:	601a      	str	r2, [r3, #0]
 800bcd4:	4b0c      	ldr	r3, [pc, #48]	; (800bd08 <SFU_IMG_EraseDownloadedImg+0x98>)
 800bcd6:	f003 f80f 	bl	800ecf8 <iprintf>

  return (((e_ret_status_swap != SFU_SUCCESS) || (e_ret_status_dwl != SFU_SUCCESS)) ?  SFU_ERROR : SFU_SUCCESS);
}
 800bcda:	4620      	mov	r0, r4
 800bcdc:	b002      	add	sp, #8
 800bcde:	bd70      	pop	{r4, r5, r6, pc}
  return (((e_ret_status_swap != SFU_SUCCESS) || (e_ret_status_dwl != SFU_SUCCESS)) ?  SFU_ERROR : SFU_SUCCESS);
 800bce0:	4a0a      	ldr	r2, [pc, #40]	; (800bd0c <SFU_IMG_EraseDownloadedImg+0x9c>)
 800bce2:	4290      	cmp	r0, r2
 800bce4:	d103      	bne.n	800bcee <SFU_IMG_EraseDownloadedImg+0x7e>
 800bce6:	4285      	cmp	r5, r0
 800bce8:	bf18      	it	ne
 800bcea:	461c      	movne	r4, r3
 800bcec:	e7f5      	b.n	800bcda <SFU_IMG_EraseDownloadedImg+0x6a>
 800bcee:	461c      	mov	r4, r3
 800bcf0:	e7f3      	b.n	800bcda <SFU_IMG_EraseDownloadedImg+0x6a>
 800bcf2:	bf00      	nop
 800bcf4:	08010f38 	.word	0x08010f38
 800bcf8:	08010f28 	.word	0x08010f28
 800bcfc:	20003db0 	.word	0x20003db0
 800bd00:	08010fdd 	.word	0x08010fdd
 800bd04:	20003dac 	.word	0x20003dac
 800bd08:	08010f58 	.word	0x08010f58
 800bd0c:	00122f11 	.word	0x00122f11

0800bd10 <SFU_IMG_TriggerImageInstallation>:
{
 800bd10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  active_slot = SFU_IMG_GetFwImageSlot(&fw_image_header_to_test);
 800bd14:	f8df 91b4 	ldr.w	r9, [pc, #436]	; 800becc <SFU_IMG_TriggerImageInstallation+0x1bc>
{
 800bd18:	b08f      	sub	sp, #60	; 0x3c
 800bd1a:	4605      	mov	r5, r0
  active_slot = SFU_IMG_GetFwImageSlot(&fw_image_header_to_test);
 800bd1c:	4648      	mov	r0, r9
 800bd1e:	f7ff f861 	bl	800ade4 <SFU_IMG_GetFwImageSlot>
  e_ret_status = VerifySlot((uint8_t *) SlotStartAdd[DwlSlot], SLOT_SIZE(DwlSlot),
 800bd22:	4a67      	ldr	r2, [pc, #412]	; (800bec0 <SFU_IMG_TriggerImageInstallation+0x1b0>)
 800bd24:	4967      	ldr	r1, [pc, #412]	; (800bec4 <SFU_IMG_TriggerImageInstallation+0x1b4>)
 800bd26:	f852 3025 	ldr.w	r3, [r2, r5, lsl #2]
 800bd2a:	68d2      	ldr	r2, [r2, #12]
 800bd2c:	9303      	str	r3, [sp, #12]
 800bd2e:	f103 0801 	add.w	r8, r3, #1
                                                             SLOT_SIZE(SLOT_SWAP)));
 800bd32:	68cb      	ldr	r3, [r1, #12]
  e_ret_status = VerifySlot((uint8_t *) SlotStartAdd[DwlSlot], SLOT_SIZE(DwlSlot),
 800bd34:	f851 6025 	ldr.w	r6, [r1, r5, lsl #2]
                            pFwImageHeader->PartialFwSize + (pFwImageHeader->PartialFwOffset %
 800bd38:	f8d9 100c 	ldr.w	r1, [r9, #12]
                                                             SLOT_SIZE(SLOT_SWAP)));
 800bd3c:	9302      	str	r3, [sp, #8]
 800bd3e:	f102 0b01 	add.w	fp, r2, #1
 800bd42:	ebab 0403 	sub.w	r4, fp, r3
                            pFwImageHeader->PartialFwSize + (pFwImageHeader->PartialFwOffset %
 800bd46:	fbb1 f2f4 	udiv	r2, r1, r4
 800bd4a:	fb04 1212 	mls	r2, r4, r2, r1
  e_ret_status = VerifySlot((uint8_t *) SlotStartAdd[DwlSlot], SLOT_SIZE(DwlSlot),
 800bd4e:	f8d9 1010 	ldr.w	r1, [r9, #16]
 800bd52:	eba8 0806 	sub.w	r8, r8, r6
 800bd56:	440a      	add	r2, r1
  active_slot = SFU_IMG_GetFwImageSlot(&fw_image_header_to_test);
 800bd58:	4607      	mov	r7, r0
  e_ret_status = VerifySlot((uint8_t *) SlotStartAdd[DwlSlot], SLOT_SIZE(DwlSlot),
 800bd5a:	4641      	mov	r1, r8
 800bd5c:	4630      	mov	r0, r6
 800bd5e:	f7fe fea3 	bl	800aaa8 <VerifySlot>
  if (e_ret_status != SFU_SUCCESS)
 800bd62:	4959      	ldr	r1, [pc, #356]	; (800bec8 <SFU_IMG_TriggerImageInstallation+0x1b8>)
 800bd64:	4288      	cmp	r0, r1
  e_ret_status = VerifySlot((uint8_t *) SlotStartAdd[DwlSlot], SLOT_SIZE(DwlSlot),
 800bd66:	4682      	mov	sl, r0
  if (e_ret_status != SFU_SUCCESS)
 800bd68:	d009      	beq.n	800bd7e <SFU_IMG_TriggerImageInstallation+0x6e>
    SFU_EXCPT_SetError(SFU_EXCPT_ADDITIONAL_CODE_ERR);
 800bd6a:	200e      	movs	r0, #14
    SFU_EXCPT_SetError(SFU_EXCPT_FWIMG_MAGIC_ERR);
 800bd6c:	f7fe fc7c 	bl	800a668 <SFU_EXCPT_SetError>
    (void) SFU_IMG_EraseDownloadedImg(DwlSlot);
 800bd70:	4628      	mov	r0, r5
 800bd72:	f7ff ff7d 	bl	800bc70 <SFU_IMG_EraseDownloadedImg>
}
 800bd76:	4650      	mov	r0, sl
 800bd78:	b00f      	add	sp, #60	; 0x3c
 800bd7a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  e_ret_status =  DecryptImageInDwlSlot(DwlSlot, pFwImageHeader);
 800bd7e:	4628      	mov	r0, r5
 800bd80:	f7ff f996 	bl	800b0b0 <DecryptImageInDwlSlot.constprop.0>
  if (e_ret_status != SFU_SUCCESS)
 800bd84:	4950      	ldr	r1, [pc, #320]	; (800bec8 <SFU_IMG_TriggerImageInstallation+0x1b8>)
 800bd86:	4288      	cmp	r0, r1
  e_ret_status =  DecryptImageInDwlSlot(DwlSlot, pFwImageHeader);
 800bd88:	4682      	mov	sl, r0
  if (e_ret_status != SFU_SUCCESS)
 800bd8a:	d001      	beq.n	800bd90 <SFU_IMG_TriggerImageInstallation+0x80>
    SFU_EXCPT_SetError(SFU_EXCPT_DECRYPT_ERR);
 800bd8c:	2008      	movs	r0, #8
 800bd8e:	e7ed      	b.n	800bd6c <SFU_IMG_TriggerImageInstallation+0x5c>
  fw_offset = (SFU_IMG_IMAGE_OFFSET + (pFwImageHeader->PartialFwOffset % SLOT_SIZE(SLOT_SWAP))) %
 800bd90:	e9d9 0103 	ldrd	r0, r1, [r9, #12]
 800bd94:	fbb0 f2f4 	udiv	r2, r0, r4
 800bd98:	fb04 0212 	mls	r2, r4, r2, r0
 800bd9c:	f502 7200 	add.w	r2, r2, #512	; 0x200
  payload_desc.pPayload[0] = payload_desc.pPayload[0] + fw_offset;
 800bda0:	9b02      	ldr	r3, [sp, #8]
  fw_offset = (SFU_IMG_IMAGE_OFFSET + (pFwImageHeader->PartialFwOffset % SLOT_SIZE(SLOT_SWAP))) %
 800bda2:	fbb2 f0f4 	udiv	r0, r2, r4
 800bda6:	fb04 2210 	mls	r2, r4, r0, r2
  payload_desc.pPayload[0] = payload_desc.pPayload[0] + fw_offset;
 800bdaa:	1898      	adds	r0, r3, r2
 800bdac:	9006      	str	r0, [sp, #24]
  payload_desc.PayloadSize[0] = payload_desc.PayloadSize[0] - fw_offset;
 800bdae:	1aa0      	subs	r0, r4, r2
  if (fw_size <= payload_desc.PayloadSize[0])
 800bdb0:	4281      	cmp	r1, r0
  payload_desc.pPayload[1] = SlotStartAdd[DwlSlot];
 800bdb2:	9607      	str	r6, [sp, #28]
  payload_desc.PayloadSize[0] = payload_desc.PayloadSize[0] - fw_offset;
 800bdb4:	9008      	str	r0, [sp, #32]
  if (fw_size <= payload_desc.PayloadSize[0])
 800bdb6:	d827      	bhi.n	800be08 <SFU_IMG_TriggerImageInstallation+0xf8>
    payload_desc.PayloadSize[1] = 0U;
 800bdb8:	2300      	movs	r3, #0
    payload_desc.PayloadSize[0] = fw_size;
 800bdba:	9108      	str	r1, [sp, #32]
    payload_desc.PayloadSize[1] = 0U;
 800bdbc:	9309      	str	r3, [sp, #36]	; 0x24
    payload_desc.pPayload[1] = 0U;
 800bdbe:	9307      	str	r3, [sp, #28]
  return VerifyFwSignatureScatter(pSeStatus, DwlSlot, pFwImageHeader, &payload_desc, SE_FW_IMAGE_PARTIAL);
 800bdc0:	2301      	movs	r3, #1
 800bdc2:	f10d 0918 	add.w	r9, sp, #24
 800bdc6:	9300      	str	r3, [sp, #0]
 800bdc8:	4a40      	ldr	r2, [pc, #256]	; (800becc <SFU_IMG_TriggerImageInstallation+0x1bc>)
  if (e_ret_status != SFU_SUCCESS)
 800bdca:	4e3f      	ldr	r6, [pc, #252]	; (800bec8 <SFU_IMG_TriggerImageInstallation+0x1b8>)
  return VerifyFwSignatureScatter(pSeStatus, DwlSlot, pFwImageHeader, &payload_desc, SE_FW_IMAGE_PARTIAL);
 800bdcc:	464b      	mov	r3, r9
 800bdce:	4629      	mov	r1, r5
 800bdd0:	a805      	add	r0, sp, #20
 800bdd2:	f7fe fe15 	bl	800aa00 <VerifyFwSignatureScatter>
  if (e_ret_status != SFU_SUCCESS)
 800bdd6:	42b0      	cmp	r0, r6
  return VerifyFwSignatureScatter(pSeStatus, DwlSlot, pFwImageHeader, &payload_desc, SE_FW_IMAGE_PARTIAL);
 800bdd8:	4682      	mov	sl, r0
  if (e_ret_status != SFU_SUCCESS)
 800bdda:	d118      	bne.n	800be0e <SFU_IMG_TriggerImageInstallation+0xfe>
    e_ret_status = SFU_LL_FLASH_Read((uint8_t *) &fw_image_header_validated, pbuffer,
 800bddc:	4b3c      	ldr	r3, [pc, #240]	; (800bed0 <SFU_IMG_TriggerImageInstallation+0x1c0>)
 800bdde:	483d      	ldr	r0, [pc, #244]	; (800bed4 <SFU_IMG_TriggerImageInstallation+0x1c4>)
 800bde0:	f853 1027 	ldr.w	r1, [r3, r7, lsl #2]
 800bde4:	f44f 72a0 	mov.w	r2, #320	; 0x140
 800bde8:	f000 fe14 	bl	800ca14 <SFU_LL_FLASH_Read>
  if (SFU_SUCCESS == e_ret_status)
 800bdec:	42b0      	cmp	r0, r6
    e_ret_status = SFU_LL_FLASH_Read((uint8_t *) &fw_image_header_validated, pbuffer,
 800bdee:	4682      	mov	sl, r0
  if (SFU_SUCCESS == e_ret_status)
 800bdf0:	d1be      	bne.n	800bd70 <SFU_IMG_TriggerImageInstallation+0x60>
  e_ret_status = EraseSlotIndex(DwlSlot, (TRAILER_INDEX(DwlSlot) - 1U));
 800bdf2:	fbb8 f4f4 	udiv	r4, r8, r4
 800bdf6:	4628      	mov	r0, r5
 800bdf8:	1e61      	subs	r1, r4, #1
 800bdfa:	f7ff f8c1 	bl	800af80 <EraseSlotIndex>
  if (e_ret_status !=  SFU_SUCCESS)
 800bdfe:	42b0      	cmp	r0, r6
  e_ret_status = EraseSlotIndex(DwlSlot, (TRAILER_INDEX(DwlSlot) - 1U));
 800be00:	4682      	mov	sl, r0
  if (e_ret_status !=  SFU_SUCCESS)
 800be02:	d00f      	beq.n	800be24 <SFU_IMG_TriggerImageInstallation+0x114>
    SFU_EXCPT_SetError(SFU_EXCPT_TRAILER_ERASING_ERR);
 800be04:	2014      	movs	r0, #20
 800be06:	e7b1      	b.n	800bd6c <SFU_IMG_TriggerImageInstallation+0x5c>
    if ((payload_desc.pPayload[1] == 0U)
 800be08:	b91e      	cbnz	r6, 800be12 <SFU_IMG_TriggerImageInstallation+0x102>
      return SFU_ERROR;
 800be0a:	f641 7ae1 	movw	sl, #8161	; 0x1fe1
    SFU_EXCPT_SetError(SFU_EXCPT_SIGNATURE_ERR);
 800be0e:	2009      	movs	r0, #9
 800be10:	e7ac      	b.n	800bd6c <SFU_IMG_TriggerImageInstallation+0x5c>
        || (payload_desc.PayloadSize[1] < (fw_size - payload_desc.PayloadSize[0])))
 800be12:	9b02      	ldr	r3, [sp, #8]
 800be14:	440b      	add	r3, r1
 800be16:	eba3 0a0b 	sub.w	sl, r3, fp
 800be1a:	4452      	add	r2, sl
 800be1c:	4590      	cmp	r8, r2
 800be1e:	d3f4      	bcc.n	800be0a <SFU_IMG_TriggerImageInstallation+0xfa>
    payload_desc.PayloadSize[1] = fw_size - payload_desc.PayloadSize[0];
 800be20:	9209      	str	r2, [sp, #36]	; 0x24
 800be22:	e7cd      	b.n	800bdc0 <SFU_IMG_TriggerImageInstallation+0xb0>
  e_ret_status = SFU_LL_FLASH_Write(&flash_if_info, TRAILER_HDR_TEST(DwlSlot), (uint8_t *) pTestHeader,
 800be24:	9b03      	ldr	r3, [sp, #12]
 800be26:	4a29      	ldr	r2, [pc, #164]	; (800becc <SFU_IMG_TriggerImageInstallation+0x1bc>)
 800be28:	342c      	adds	r4, #44	; 0x2c
 800be2a:	eba3 1b04 	sub.w	fp, r3, r4, lsl #4
 800be2e:	f20b 1141 	addw	r1, fp, #321	; 0x141
 800be32:	f44f 73a0 	mov.w	r3, #320	; 0x140
 800be36:	a805      	add	r0, sp, #20
 800be38:	f000 fde5 	bl	800ca06 <SFU_LL_FLASH_Write>
  if (e_ret_status == SFU_SUCCESS)
 800be3c:	42b0      	cmp	r0, r6
  e_ret_status = SFU_LL_FLASH_Write(&flash_if_info, TRAILER_HDR_TEST(DwlSlot), (uint8_t *) pTestHeader,
 800be3e:	4682      	mov	sl, r0
  if (e_ret_status == SFU_SUCCESS)
 800be40:	d11f      	bne.n	800be82 <SFU_IMG_TriggerImageInstallation+0x172>
    e_ret_status = SFU_LL_FLASH_Write(&flash_if_info, TRAILER_HDR_VALID(DwlSlot), (uint8_t *) pValidHeader,
 800be42:	4a24      	ldr	r2, [pc, #144]	; (800bed4 <SFU_IMG_TriggerImageInstallation+0x1c4>)
 800be44:	f44f 73a0 	mov.w	r3, #320	; 0x140
 800be48:	f10b 0101 	add.w	r1, fp, #1
 800be4c:	a805      	add	r0, sp, #20
 800be4e:	f000 fdda 	bl	800ca06 <SFU_LL_FLASH_Write>
  if (e_ret_status == SFU_SUCCESS)
 800be52:	42b0      	cmp	r0, r6
    e_ret_status = SFU_LL_FLASH_Write(&flash_if_info, TRAILER_HDR_VALID(DwlSlot), (uint8_t *) pValidHeader,
 800be54:	4682      	mov	sl, r0
  if (e_ret_status == SFU_SUCCESS)
 800be56:	d114      	bne.n	800be82 <SFU_IMG_TriggerImageInstallation+0x172>
    (void) memcpy(&magic[0U], (uint8_t *)(buffer + SE_FW_AUTH_LEN + (MAGIC_LENGTH / 2U)), MAGIC_LENGTH / 2U);
 800be58:	4b1f      	ldr	r3, [pc, #124]	; (800bed8 <SFU_IMG_TriggerImageInstallation+0x1c8>)
    (void) memcpy(&magic[MAGIC_LENGTH / 2U], (uint8_t *)(buffer + SE_FW_AUTH_LEN + (MAGIC_LENGTH / 2U)),
 800be5a:	4c20      	ldr	r4, [pc, #128]	; (800bedc <SFU_IMG_TriggerImageInstallation+0x1cc>)
    (void) memcpy(&magic[0U], (uint8_t *)(buffer + SE_FW_AUTH_LEN + (MAGIC_LENGTH / 2U)), MAGIC_LENGTH / 2U);
 800be5c:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800be5e:	e889 000f 	stmia.w	r9, {r0, r1, r2, r3}
    (void) memcpy(&magic[MAGIC_LENGTH / 2U], (uint8_t *)(buffer + SE_FW_AUTH_LEN + (MAGIC_LENGTH / 2U)),
 800be62:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 800be66:	f10d 0c38 	add.w	ip, sp, #56	; 0x38
 800be6a:	e90c 000f 	stmdb	ip, {r0, r1, r2, r3}
    e_ret_status = SFU_LL_FLASH_Write(&flash_if_info, TRAILER_SWAP_ADDR(DwlSlot), magic, MAGIC_LENGTH);
 800be6e:	2320      	movs	r3, #32
 800be70:	464a      	mov	r2, r9
 800be72:	f20b 2181 	addw	r1, fp, #641	; 0x281
 800be76:	a805      	add	r0, sp, #20
 800be78:	f000 fdc5 	bl	800ca06 <SFU_LL_FLASH_Write>
  if (e_ret_status != SFU_SUCCESS)
 800be7c:	42b0      	cmp	r0, r6
    e_ret_status = SFU_LL_FLASH_Write(&flash_if_info, TRAILER_SWAP_ADDR(DwlSlot), magic, MAGIC_LENGTH);
 800be7e:	4682      	mov	sl, r0
  if (e_ret_status != SFU_SUCCESS)
 800be80:	d001      	beq.n	800be86 <SFU_IMG_TriggerImageInstallation+0x176>
    SFU_EXCPT_SetError(SFU_EXCPT_TRAILER_UPDATE_ERR);
 800be82:	2015      	movs	r0, #21
 800be84:	e772      	b.n	800bd6c <SFU_IMG_TriggerImageInstallation+0x5c>
  e_ret_status = SwapFirmwareImages(ActiveSlot, DwlSlot, pTestHeader);
 800be86:	4629      	mov	r1, r5
 800be88:	4638      	mov	r0, r7
 800be8a:	f7ff fb5b 	bl	800b544 <SwapFirmwareImages.constprop.0>
  if (e_ret_status != SFU_SUCCESS)
 800be8e:	42b0      	cmp	r0, r6
  e_ret_status = SwapFirmwareImages(ActiveSlot, DwlSlot, pTestHeader);
 800be90:	4682      	mov	sl, r0
  if (e_ret_status != SFU_SUCCESS)
 800be92:	d001      	beq.n	800be98 <SFU_IMG_TriggerImageInstallation+0x188>
    SFU_EXCPT_SetError(SFU_EXCPT_FWIMG_SWAP_ERR);
 800be94:	200f      	movs	r0, #15
 800be96:	e769      	b.n	800bd6c <SFU_IMG_TriggerImageInstallation+0x5c>
  e_ret_status = SFU_IMG_Validation(ActiveSlot, pTestHeader);
 800be98:	f1a4 0190 	sub.w	r1, r4, #144	; 0x90
 800be9c:	4638      	mov	r0, r7
 800be9e:	f7fe ff5f 	bl	800ad60 <SFU_IMG_Validation>
  if (SFU_SUCCESS != e_ret_status)
 800bea2:	42b0      	cmp	r0, r6
  e_ret_status = SFU_IMG_Validation(ActiveSlot, pTestHeader);
 800bea4:	4682      	mov	sl, r0
  if (SFU_SUCCESS != e_ret_status)
 800bea6:	d001      	beq.n	800beac <SFU_IMG_TriggerImageInstallation+0x19c>
    SFU_EXCPT_SetError(SFU_EXCPT_HEADER_VALIDATION_ERR);
 800bea8:	200d      	movs	r0, #13
 800beaa:	e75f      	b.n	800bd6c <SFU_IMG_TriggerImageInstallation+0x5c>
  e_ret_status = CleanMagicValue(DwlSlot);
 800beac:	4628      	mov	r0, r5
 800beae:	f7ff f83f 	bl	800af30 <CleanMagicValue>
  if (e_ret_status != SFU_SUCCESS)
 800beb2:	42b0      	cmp	r0, r6
  e_ret_status = CleanMagicValue(DwlSlot);
 800beb4:	4682      	mov	sl, r0
  if (e_ret_status != SFU_SUCCESS)
 800beb6:	f43f af5e 	beq.w	800bd76 <SFU_IMG_TriggerImageInstallation+0x66>
    SFU_EXCPT_SetError(SFU_EXCPT_FWIMG_MAGIC_ERR);
 800beba:	2016      	movs	r0, #22
 800bebc:	e756      	b.n	800bd6c <SFU_IMG_TriggerImageInstallation+0x5c>
 800bebe:	bf00      	nop
 800bec0:	08010f38 	.word	0x08010f38
 800bec4:	08010f28 	.word	0x08010f28
 800bec8:	00122f11 	.word	0x00122f11
 800becc:	20003c6c 	.word	0x20003c6c
 800bed0:	08010f48 	.word	0x08010f48
 800bed4:	20003db4 	.word	0x20003db4
 800bed8:	20003e44 	.word	0x20003e44
 800bedc:	20003cfc 	.word	0x20003cfc

0800bee0 <SFU_IMG_TriggerResumeInstallation>:
{
 800bee0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800bee2:	4607      	mov	r7, r0
 800bee4:	460d      	mov	r5, r1
  e_ret_status = SwapFirmwareImages(ActiveSlot, DwlSlot, &fw_image_header_to_test);
 800bee6:	f7ff fb2d 	bl	800b544 <SwapFirmwareImages.constprop.0>
  if (e_ret_status != SFU_SUCCESS)
 800beea:	4e0e      	ldr	r6, [pc, #56]	; (800bf24 <SFU_IMG_TriggerResumeInstallation+0x44>)
 800beec:	42b0      	cmp	r0, r6
  e_ret_status = SwapFirmwareImages(ActiveSlot, DwlSlot, &fw_image_header_to_test);
 800beee:	4604      	mov	r4, r0
  if (e_ret_status != SFU_SUCCESS)
 800bef0:	d007      	beq.n	800bf02 <SFU_IMG_TriggerResumeInstallation+0x22>
    SFU_EXCPT_SetError(SFU_EXCPT_FWIMG_SWAP_ERR);
 800bef2:	200f      	movs	r0, #15
      SFU_EXCPT_SetError(SFU_EXCPT_FWIMG_MAGIC_ERR);
 800bef4:	f7fe fbb8 	bl	800a668 <SFU_EXCPT_SetError>
    (void) SFU_IMG_EraseDownloadedImg(DwlSlot);
 800bef8:	4628      	mov	r0, r5
 800befa:	f7ff feb9 	bl	800bc70 <SFU_IMG_EraseDownloadedImg>
}
 800befe:	4620      	mov	r0, r4
 800bf00:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    e_ret_status = SFU_IMG_Validation(ActiveSlot, &fw_image_header_to_test);
 800bf02:	4909      	ldr	r1, [pc, #36]	; (800bf28 <SFU_IMG_TriggerResumeInstallation+0x48>)
 800bf04:	4638      	mov	r0, r7
 800bf06:	f7fe ff2b 	bl	800ad60 <SFU_IMG_Validation>
    if (e_ret_status != SFU_SUCCESS)
 800bf0a:	42b0      	cmp	r0, r6
    e_ret_status = SFU_IMG_Validation(ActiveSlot, &fw_image_header_to_test);
 800bf0c:	4604      	mov	r4, r0
    if (e_ret_status != SFU_SUCCESS)
 800bf0e:	d001      	beq.n	800bf14 <SFU_IMG_TriggerResumeInstallation+0x34>
      SFU_EXCPT_SetError(SFU_EXCPT_HEADER_VALIDATION_ERR);
 800bf10:	200d      	movs	r0, #13
 800bf12:	e7ef      	b.n	800bef4 <SFU_IMG_TriggerResumeInstallation+0x14>
    e_ret_status = CleanMagicValue(DwlSlot);
 800bf14:	4628      	mov	r0, r5
 800bf16:	f7ff f80b 	bl	800af30 <CleanMagicValue>
    if (e_ret_status != SFU_SUCCESS)
 800bf1a:	42b0      	cmp	r0, r6
    e_ret_status = CleanMagicValue(DwlSlot);
 800bf1c:	4604      	mov	r4, r0
    if (e_ret_status != SFU_SUCCESS)
 800bf1e:	d0ee      	beq.n	800befe <SFU_IMG_TriggerResumeInstallation+0x1e>
      SFU_EXCPT_SetError(SFU_EXCPT_FWIMG_MAGIC_ERR);
 800bf20:	2016      	movs	r0, #22
 800bf22:	e7e7      	b.n	800bef4 <SFU_IMG_TriggerResumeInstallation+0x14>
 800bf24:	00122f11 	.word	0x00122f11
 800bf28:	20003c6c 	.word	0x20003c6c

0800bf2c <SFU_Decrypt_Init>:
  *        This parameter can be a value of @ref SE_Status_Structure_definition.
  * @param pxSE_Metadata Metadata that will be used to fill the Crypto Init structure.
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SFU_Decrypt_Init(SE_StatusTypeDef *peSE_Status, SE_FwRawHeaderTypeDef *pxSE_Metadata, uint32_t SE_FwType)
{
 800bf2c:	b5f0      	push	{r4, r5, r6, r7, lr}
  SE_ErrorStatus se_status = SE_SUCCESS;
  *peSE_Status = SE_OK;
 800bf2e:	4b1b      	ldr	r3, [pc, #108]	; (800bf9c <SFU_Decrypt_Init+0x70>)
 800bf30:	6003      	str	r3, [r0, #0]
{
 800bf32:	b087      	sub	sp, #28
  CK_RV rv = CKR_OK;
  CK_FLAGS session_flags = CKF_SERIAL_SESSION;  /* Read ONLY session */
  uint8_t *iv_cbc = pxSE_Metadata->InitVector;
  CK_OBJECT_HANDLE hAESKey = 0UL;

  CK_MECHANISM cktest_aes_cbc_mechanism =
 800bf34:	f241 0382 	movw	r3, #4226	; 0x1082
 800bf38:	9303      	str	r3, [sp, #12]
  uint8_t *iv_cbc = pxSE_Metadata->InitVector;
 800bf3a:	f101 0354 	add.w	r3, r1, #84	; 0x54
  CK_MECHANISM cktest_aes_cbc_mechanism =
 800bf3e:	9304      	str	r3, [sp, #16]
 800bf40:	2310      	movs	r3, #16
{
 800bf42:	4605      	mov	r5, r0
 800bf44:	460e      	mov	r6, r1
  CK_MECHANISM cktest_aes_cbc_mechanism =
 800bf46:	9305      	str	r3, [sp, #20]
#else
#error "The current example does not support the selected crypto scheme."
#endif /* SECBOOT_AES128_GCM_AES128_GCM_AES128_GCM */

  /* Check the pointer allocation */
  if (pxSE_Metadata == NULL)
 800bf48:	b1b1      	cbz	r1, 800bf78 <SFU_Decrypt_Init+0x4c>
  {
    return SE_ERROR;
  }
#if (SECBOOT_CRYPTO_SCHEME == SECBOOT_AES128_GCM_AES128_GCM_AES128_GCM) || (SECBOOT_CRYPTO_SCHEME == SECBOOT_ECCDSA_WITH_AES128_CBC_SHA256)
  /* Initialize the KMS service */
  C_Initialize(NULL) ;
 800bf4a:	2000      	movs	r0, #0
 800bf4c:	f7fc fe50 	bl	8008bf0 <SE_KMS_Initialize>

  /* Start by opening a session */
  rv = C_OpenSession(0,  session_flags, NULL, 0, &DecryptSession);
 800bf50:	4f13      	ldr	r7, [pc, #76]	; (800bfa0 <SFU_Decrypt_Init+0x74>)
 800bf52:	9700      	str	r7, [sp, #0]
 800bf54:	2300      	movs	r3, #0
 800bf56:	461a      	mov	r2, r3
 800bf58:	2104      	movs	r1, #4
 800bf5a:	4618      	mov	r0, r3
 800bf5c:	f7fc fefe 	bl	8008d5c <SE_KMS_OpenSession>
  if (rv != CKR_OK)
 800bf60:	b160      	cbz	r0, 800bf7c <SFU_Decrypt_Init+0x50>
  {
    se_status = SE_ERROR;
    *peSE_Status = SE_KO;
 800bf62:	4b10      	ldr	r3, [pc, #64]	; (800bfa4 <SFU_Decrypt_Init+0x78>)
    se_status = SE_ERROR;
 800bf64:	4c10      	ldr	r4, [pc, #64]	; (800bfa8 <SFU_Decrypt_Init+0x7c>)
    *peSE_Status = SE_KO;
 800bf66:	602b      	str	r3, [r5, #0]
  if (memcmp(pxSE_Metadata->SFUMagic, SFUM_1, strlen(SFUM_1)) == 0)
 800bf68:	4910      	ldr	r1, [pc, #64]	; (800bfac <SFU_Decrypt_Init+0x80>)
 800bf6a:	2204      	movs	r2, #4
 800bf6c:	4630      	mov	r0, r6
 800bf6e:	f002 fe9f 	bl	800ecb0 <memcmp>
 800bf72:	b128      	cbz	r0, 800bf80 <SFU_Decrypt_Init+0x54>

  /* Identify the keys after FW header analysis (magic tag) */
  if (SFU_GetAESKeyObject(pxSE_Metadata, &hAESKey) != SE_SUCCESS)
  {
    se_status = SE_ERROR;
    *peSE_Status = SE_KO;
 800bf74:	4b0b      	ldr	r3, [pc, #44]	; (800bfa4 <SFU_Decrypt_Init+0x78>)
 800bf76:	602b      	str	r3, [r5, #0]
    return SE_ERROR;
 800bf78:	4c0b      	ldr	r4, [pc, #44]	; (800bfa8 <SFU_Decrypt_Init+0x7c>)
 800bf7a:	e00b      	b.n	800bf94 <SFU_Decrypt_Init+0x68>
  SE_ErrorStatus se_status = SE_SUCCESS;
 800bf7c:	4c0c      	ldr	r4, [pc, #48]	; (800bfb0 <SFU_Decrypt_Init+0x84>)
 800bf7e:	e7f3      	b.n	800bf68 <SFU_Decrypt_Init+0x3c>
    }
  }

#elif (SECBOOT_CRYPTO_SCHEME == SECBOOT_ECCDSA_WITH_AES128_CBC_SHA256)
  /* Initialize the decryption session */
  if (se_status == SE_SUCCESS)
 800bf80:	4b0b      	ldr	r3, [pc, #44]	; (800bfb0 <SFU_Decrypt_Init+0x84>)
 800bf82:	429c      	cmp	r4, r3
 800bf84:	d106      	bne.n	800bf94 <SFU_Decrypt_Init+0x68>
  {
    rv = C_DecryptInit(DecryptSession, &cktest_aes_cbc_mechanism, hAESKey);
 800bf86:	6838      	ldr	r0, [r7, #0]
 800bf88:	2203      	movs	r2, #3
 800bf8a:	a903      	add	r1, sp, #12
 800bf8c:	f7fd f85c 	bl	8009048 <SE_KMS_DecryptInit>
    if (rv != CKR_OK)
 800bf90:	2800      	cmp	r0, #0
 800bf92:	d1ef      	bne.n	800bf74 <SFU_Decrypt_Init+0x48>
#else
#error "The current example does not support the selected crypto scheme."
#endif /* SECBOOT_AES128_GCM_AES128_GCM_AES128_GCM */

  return se_status;
}
 800bf94:	4620      	mov	r0, r4
 800bf96:	b007      	add	sp, #28
 800bf98:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800bf9a:	bf00      	nop
 800bf9c:	0012e223 	.word	0x0012e223
 800bfa0:	20003f00 	.word	0x20003f00
 800bfa4:	0013023d 	.word	0x0013023d
 800bfa8:	00018799 	.word	0x00018799
 800bfac:	08011248 	.word	0x08011248
 800bfb0:	0012310f 	.word	0x0012310f

0800bfb4 <SFU_Decrypt_Append>:
  * @param puOutputSize pointer to Output Size (bytes).
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SFU_Decrypt_Append(SE_StatusTypeDef *peSE_Status, const uint8_t *pInputBuffer, int32_t InputSize,
                                  uint8_t *pOutputBuffer, int32_t *pOutputSize)
{
 800bfb4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800bfb6:	4604      	mov	r4, r0
  SE_ErrorStatus se_status = SE_SUCCESS;
  *peSE_Status = SE_OK;
 800bfb8:	4f0a      	ldr	r7, [pc, #40]	; (800bfe4 <SFU_Decrypt_Append+0x30>)
{
 800bfba:	9e08      	ldr	r6, [sp, #32]
  *peSE_Status = SE_OK;
 800bfbc:	6027      	str	r7, [r4, #0]
     || (SECBOOT_CRYPTO_SCHEME == SECBOOT_ECCDSA_WITH_AES128_CBC_SHA256))
  CK_RV rv = CKR_OK;
#endif /* SECBOOT_AES128_GCM_AES128_GCM_AES128_GCM) || SECBOOT_ECCDSA_WITH_AES128_CBC_SHA256 */

  /* DecryptImageInDwlSlot() always starts by calling the Decrypt service with a 0 byte buffer */
  if (0 == InputSize)
 800bfbe:	b912      	cbnz	r2, 800bfc6 <SFU_Decrypt_Append+0x12>
  {
    /* Nothing to do but we must return a success for the decrypt operation to continue */
    return (SE_SUCCESS);
 800bfc0:	4809      	ldr	r0, [pc, #36]	; (800bfe8 <SFU_Decrypt_Append+0x34>)
#else
#error "The current example does not support the selected crypto scheme."
#endif /* SECBOOT_AES128_GCM_AES128_GCM_AES128_GCM) || SECBOOT_ECCDSA_WITH_AES128_CBC_SHA256 */

  return se_status;
}
 800bfc2:	b003      	add	sp, #12
 800bfc4:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((pInputBuffer == NULL) || (pOutputBuffer == NULL) || (pOutputSize == NULL))
 800bfc6:	b151      	cbz	r1, 800bfde <SFU_Decrypt_Append+0x2a>
 800bfc8:	b14b      	cbz	r3, 800bfde <SFU_Decrypt_Append+0x2a>
 800bfca:	b146      	cbz	r6, 800bfde <SFU_Decrypt_Append+0x2a>
  rv = C_DecryptUpdate(DecryptSession, (CK_BYTE *)pInputBuffer, InputSize, pOutputBuffer, (CK_ULONG_PTR)pOutputSize);
 800bfcc:	4807      	ldr	r0, [pc, #28]	; (800bfec <SFU_Decrypt_Append+0x38>)
 800bfce:	9600      	str	r6, [sp, #0]
 800bfd0:	6800      	ldr	r0, [r0, #0]
 800bfd2:	f7fd f875 	bl	80090c0 <SE_KMS_DecryptUpdate>
  if (rv != CKR_OK)
 800bfd6:	2800      	cmp	r0, #0
 800bfd8:	d0f2      	beq.n	800bfc0 <SFU_Decrypt_Append+0xc>
    *peSE_Status = SE_KO;
 800bfda:	4b05      	ldr	r3, [pc, #20]	; (800bff0 <SFU_Decrypt_Append+0x3c>)
 800bfdc:	6023      	str	r3, [r4, #0]
    return SE_ERROR;
 800bfde:	4805      	ldr	r0, [pc, #20]	; (800bff4 <SFU_Decrypt_Append+0x40>)
 800bfe0:	e7ef      	b.n	800bfc2 <SFU_Decrypt_Append+0xe>
 800bfe2:	bf00      	nop
 800bfe4:	0012e223 	.word	0x0012e223
 800bfe8:	0012310f 	.word	0x0012310f
 800bfec:	20003f00 	.word	0x20003f00
 800bff0:	0013023d 	.word	0x0013023d
 800bff4:	00018799 	.word	0x00018799

0800bff8 <SFU_Decrypt_Finish>:
  * @param puOutputSize pointer to Output Size (bytes).
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SFU_Decrypt_Finish(SE_StatusTypeDef *peSE_Status, uint8_t *pOutputBuffer, int32_t *pOutputSize)
{
  *peSE_Status = SE_OK;
 800bff8:	4b14      	ldr	r3, [pc, #80]	; (800c04c <SFU_Decrypt_Finish+0x54>)
{
 800bffa:	b570      	push	{r4, r5, r6, lr}
 800bffc:	4605      	mov	r5, r0
  *peSE_Status = SE_OK;
 800bffe:	6003      	str	r3, [r0, #0]
#if ((SECBOOT_CRYPTO_SCHEME == SECBOOT_AES128_GCM_AES128_GCM_AES128_GCM) || (SECBOOT_CRYPTO_SCHEME == SECBOOT_ECCDSA_WITH_AES128_CBC_SHA256))
  CK_RV rv = CKR_OK;
#endif /* SECBOOT_AES128_GCM_AES128_GCM_AES128_GCM) || SECBOOT_ECCDSA_WITH_AES128_CBC_SHA256 */

  /* Check the pointers allocation */
  if ((pOutputBuffer == NULL) || (pOutputSize == NULL))
 800c000:	b311      	cbz	r1, 800c048 <SFU_Decrypt_Finish+0x50>
 800c002:	b30a      	cbz	r2, 800c048 <SFU_Decrypt_Finish+0x50>
    return SE_ERROR;
  }

#if ((SECBOOT_CRYPTO_SCHEME == SECBOOT_AES128_GCM_AES128_GCM_AES128_GCM)\
     || (SECBOOT_CRYPTO_SCHEME == SECBOOT_ECCDSA_WITH_AES128_CBC_SHA256))
  memcpy(pOutputBuffer, gcm_tag_header, 16);
 800c004:	4b12      	ldr	r3, [pc, #72]	; (800c050 <SFU_Decrypt_Finish+0x58>)
 800c006:	681b      	ldr	r3, [r3, #0]
 800c008:	4608      	mov	r0, r1
 800c00a:	f103 0410 	add.w	r4, r3, #16
 800c00e:	f853 6b04 	ldr.w	r6, [r3], #4
 800c012:	f840 6b04 	str.w	r6, [r0], #4
 800c016:	42a3      	cmp	r3, r4
 800c018:	d1f9      	bne.n	800c00e <SFU_Decrypt_Finish+0x16>

  /* End-up decryption session */
  rv = C_DecryptFinal(DecryptSession, pOutputBuffer, (CK_ULONG_PTR)pOutputSize);
 800c01a:	4c0e      	ldr	r4, [pc, #56]	; (800c054 <SFU_Decrypt_Finish+0x5c>)
 800c01c:	6820      	ldr	r0, [r4, #0]
 800c01e:	f7fd f86f 	bl	8009100 <SE_KMS_DecryptFinal>
  if (rv != CKR_OK)
 800c022:	4623      	mov	r3, r4
 800c024:	b170      	cbz	r0, 800c044 <SFU_Decrypt_Finish+0x4c>
  {
    se_status = SE_ERROR;
    *peSE_Status = SE_KO;
 800c026:	4a0c      	ldr	r2, [pc, #48]	; (800c058 <SFU_Decrypt_Finish+0x60>)
    se_status = SE_ERROR;
 800c028:	4c0c      	ldr	r4, [pc, #48]	; (800c05c <SFU_Decrypt_Finish+0x64>)
    *peSE_Status = SE_KO;
 800c02a:	602a      	str	r2, [r5, #0]
#error "The current example does not support the selected crypto scheme."
#endif /* SECBOOT_AES128_GCM_AES128_GCM_AES128_GCM) || SECBOOT_ECCDSA_WITH_AES128_CBC_SHA256 */

#if (SECBOOT_CRYPTO_SCHEME == SECBOOT_AES128_GCM_AES128_GCM_AES128_GCM) || (SECBOOT_CRYPTO_SCHEME == SECBOOT_ECCDSA_WITH_AES128_CBC_SHA256)
  /* Close the session */
  rv = C_CloseSession(DecryptSession);
 800c02c:	6818      	ldr	r0, [r3, #0]
 800c02e:	f7fc feb5 	bl	8008d9c <SE_KMS_CloseSession>
  if (rv != CKR_OK)
 800c032:	b110      	cbz	r0, 800c03a <SFU_Decrypt_Finish+0x42>
  {
    se_status = SE_ERROR;
    *peSE_Status = SE_KO;
 800c034:	4b08      	ldr	r3, [pc, #32]	; (800c058 <SFU_Decrypt_Finish+0x60>)
    se_status = SE_ERROR;
 800c036:	4c09      	ldr	r4, [pc, #36]	; (800c05c <SFU_Decrypt_Finish+0x64>)
    *peSE_Status = SE_KO;
 800c038:	602b      	str	r3, [r5, #0]
  }

  /* End-up the KMS service */
  C_Finalize(NULL) ;
 800c03a:	2000      	movs	r0, #0
 800c03c:	f7fc fdf0 	bl	8008c20 <SE_KMS_Finalize>
#endif /* (SECBOOT_CRYPTO_SCHEME == SECBOOT_AES128_GCM_AES128_GCM_AES128_GCM) || (SECBOOT_CRYPTO_SCHEME == SECBOOT_ECCDSA_WITH_AES128_CBC_SHA256) */

  return se_status;
}
 800c040:	4620      	mov	r0, r4
 800c042:	bd70      	pop	{r4, r5, r6, pc}
  SE_ErrorStatus se_status = SE_SUCCESS;
 800c044:	4c06      	ldr	r4, [pc, #24]	; (800c060 <SFU_Decrypt_Finish+0x68>)
 800c046:	e7f1      	b.n	800c02c <SFU_Decrypt_Finish+0x34>
    return SE_ERROR;
 800c048:	4c04      	ldr	r4, [pc, #16]	; (800c05c <SFU_Decrypt_Finish+0x64>)
 800c04a:	e7f9      	b.n	800c040 <SFU_Decrypt_Finish+0x48>
 800c04c:	0012e223 	.word	0x0012e223
 800c050:	200038d8 	.word	0x200038d8
 800c054:	20003f00 	.word	0x20003f00
 800c058:	0013023d 	.word	0x0013023d
 800c05c:	00018799 	.word	0x00018799
 800c060:	0012310f 	.word	0x0012310f

0800c064 <SFU_AuthenticateFW_Init>:
  * @param pxSE_Metadata Metadata that will be used to fill the Crypto Init structure.
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SFU_AuthenticateFW_Init(SE_StatusTypeDef *peSE_Status, SE_FwRawHeaderTypeDef *pxSE_Metadata,
                                       uint32_t SE_FwType)
{
 800c064:	b570      	push	{r4, r5, r6, lr}
  CK_FLAGS session_flags = CKF_SERIAL_SESSION;  /* Read ONLY session */
  CK_RV rv = CKR_OK;
  SE_ErrorStatus se_status = SE_SUCCESS;
  *peSE_Status = SE_OK;
 800c066:	4b14      	ldr	r3, [pc, #80]	; (800c0b8 <SFU_AuthenticateFW_Init+0x54>)
 800c068:	6003      	str	r3, [r0, #0]
{
 800c06a:	b086      	sub	sp, #24
    (CK_VOID_PTR *) &kms_test_gcm_params,
    sizeof(kms_test_gcm_params)
  };

#elif ((SECBOOT_CRYPTO_SCHEME == SECBOOT_ECCDSA_WITH_AES128_CBC_SHA256) || (SECBOOT_CRYPTO_SCHEME == SECBOOT_ECCDSA_WITHOUT_ENCRYPT_SHA256) )
  CK_MECHANISM cktest_sha_256_mechanism =
 800c06c:	2600      	movs	r6, #0
 800c06e:	f44f 7314 	mov.w	r3, #592	; 0x250
 800c072:	e9cd 3603 	strd	r3, r6, [sp, #12]
{
 800c076:	4604      	mov	r4, r0
  CK_MECHANISM cktest_sha_256_mechanism =
 800c078:	9605      	str	r6, [sp, #20]
    0
  };
#endif /* SECBOOT_AES128_GCM_AES128_GCM_AES128_GCM */

  /* Check the pointer allocation */
  if (pxSE_Metadata == NULL)
 800c07a:	b1b1      	cbz	r1, 800c0aa <SFU_AuthenticateFW_Init+0x46>

  /* Initialize the KMS service */
  C_Initialize(NULL) ;

  /* Start by opening a session */
  rv = C_OpenSession(0,  session_flags, NULL, 0, &AuthenticateSession);
 800c07c:	4d0f      	ldr	r5, [pc, #60]	; (800c0bc <SFU_AuthenticateFW_Init+0x58>)
  C_Initialize(NULL) ;
 800c07e:	4630      	mov	r0, r6
 800c080:	f7fc fdb6 	bl	8008bf0 <SE_KMS_Initialize>
  rv = C_OpenSession(0,  session_flags, NULL, 0, &AuthenticateSession);
 800c084:	4633      	mov	r3, r6
 800c086:	9500      	str	r5, [sp, #0]
 800c088:	4632      	mov	r2, r6
 800c08a:	2104      	movs	r1, #4
 800c08c:	4630      	mov	r0, r6
 800c08e:	f7fc fe65 	bl	8008d5c <SE_KMS_OpenSession>
  if (rv != CKR_OK)
 800c092:	462b      	mov	r3, r5
 800c094:	b168      	cbz	r0, 800c0b2 <SFU_AuthenticateFW_Init+0x4e>
  {
    se_status = SE_ERROR;
    *peSE_Status = SE_KO;
 800c096:	4a0a      	ldr	r2, [pc, #40]	; (800c0c0 <SFU_AuthenticateFW_Init+0x5c>)
    se_status = SE_ERROR;
 800c098:	4d0a      	ldr	r5, [pc, #40]	; (800c0c4 <SFU_AuthenticateFW_Init+0x60>)
    *peSE_Status = SE_KO;
 800c09a:	6022      	str	r2, [r4, #0]
    }
  }

#elif ((SECBOOT_CRYPTO_SCHEME == SECBOOT_ECCDSA_WITH_AES128_CBC_SHA256) || (SECBOOT_CRYPTO_SCHEME == SECBOOT_ECCDSA_WITHOUT_ENCRYPT_SHA256) )
  /* Digest initialization */
  rv = C_DigestInit(AuthenticateSession, &cktest_sha_256_mechanism);
 800c09c:	6818      	ldr	r0, [r3, #0]
 800c09e:	a903      	add	r1, sp, #12
 800c0a0:	f7fd f84a 	bl	8009138 <SE_KMS_DigestInit>
  if (rv != CKR_OK)
 800c0a4:	b110      	cbz	r0, 800c0ac <SFU_AuthenticateFW_Init+0x48>
  {
    se_status = SE_ERROR;
    *peSE_Status = SE_KO;
 800c0a6:	4b06      	ldr	r3, [pc, #24]	; (800c0c0 <SFU_AuthenticateFW_Init+0x5c>)
 800c0a8:	6023      	str	r3, [r4, #0]
    return SE_ERROR;
 800c0aa:	4d06      	ldr	r5, [pc, #24]	; (800c0c4 <SFU_AuthenticateFW_Init+0x60>)
#else
#error "The current example does not support the selected crypto scheme."
#endif /* SECBOOT_AES128_GCM_AES128_GCM_AES128_GCM */

  return se_status;
}
 800c0ac:	4628      	mov	r0, r5
 800c0ae:	b006      	add	sp, #24
 800c0b0:	bd70      	pop	{r4, r5, r6, pc}
  SE_ErrorStatus se_status = SE_SUCCESS;
 800c0b2:	4d05      	ldr	r5, [pc, #20]	; (800c0c8 <SFU_AuthenticateFW_Init+0x64>)
 800c0b4:	e7f2      	b.n	800c09c <SFU_AuthenticateFW_Init+0x38>
 800c0b6:	bf00      	nop
 800c0b8:	0012e223 	.word	0x0012e223
 800c0bc:	20003ef4 	.word	0x20003ef4
 800c0c0:	0013023d 	.word	0x0013023d
 800c0c4:	00018799 	.word	0x00018799
 800c0c8:	0012310f 	.word	0x0012310f

0800c0cc <SFU_AuthenticateFW_Append>:
  * @param puOutputSize pointer to Output Size (bytes).
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SFU_AuthenticateFW_Append(SE_StatusTypeDef *peSE_Status, const uint8_t *pInputBuffer, int32_t InputSize,
                                         uint8_t *pOutputBuffer, int32_t *pOutputSize)
{
 800c0cc:	b510      	push	{r4, lr}
 800c0ce:	4604      	mov	r4, r0
 800c0d0:	9802      	ldr	r0, [sp, #8]
  SE_ErrorStatus se_status = SE_SUCCESS;
  CK_RV rv = CKR_OK;

  /* Check the pointers allocation */
  if ((pInputBuffer == NULL) || (pOutputBuffer == NULL) || (pOutputSize == NULL))
 800c0d2:	b141      	cbz	r1, 800c0e6 <SFU_AuthenticateFW_Append+0x1a>
 800c0d4:	b13b      	cbz	r3, 800c0e6 <SFU_AuthenticateFW_Append+0x1a>
 800c0d6:	b130      	cbz	r0, 800c0e6 <SFU_AuthenticateFW_Append+0x1a>
    se_status = SE_ERROR;
    *peSE_Status = SE_KO;
  }
#elif ((SECBOOT_CRYPTO_SCHEME == SECBOOT_ECCDSA_WITH_AES128_CBC_SHA256) || (SECBOOT_CRYPTO_SCHEME == SECBOOT_ECCDSA_WITHOUT_ENCRYPT_SHA256) )
  /* Digest calculation */
  rv = C_DigestUpdate(AuthenticateSession, (CK_BYTE_PTR)pInputBuffer, InputSize);
 800c0d8:	4b05      	ldr	r3, [pc, #20]	; (800c0f0 <SFU_AuthenticateFW_Append+0x24>)
 800c0da:	6818      	ldr	r0, [r3, #0]
 800c0dc:	f7fd f866 	bl	80091ac <SE_KMS_DigestUpdate>
  if (rv != CKR_OK)
 800c0e0:	b118      	cbz	r0, 800c0ea <SFU_AuthenticateFW_Append+0x1e>
  {
    se_status = SE_ERROR;
    *peSE_Status = SE_KO;
 800c0e2:	4b04      	ldr	r3, [pc, #16]	; (800c0f4 <SFU_AuthenticateFW_Append+0x28>)
 800c0e4:	6023      	str	r3, [r4, #0]
    return SE_ERROR;
 800c0e6:	4804      	ldr	r0, [pc, #16]	; (800c0f8 <SFU_AuthenticateFW_Append+0x2c>)
#else
#error "The current example does not support the selected crypto scheme."
#endif /* SECBOOT_AES128_GCM_AES128_GCM_AES128_GCM */

  return se_status;
}
 800c0e8:	bd10      	pop	{r4, pc}
  SE_ErrorStatus se_status = SE_SUCCESS;
 800c0ea:	4804      	ldr	r0, [pc, #16]	; (800c0fc <SFU_AuthenticateFW_Append+0x30>)
 800c0ec:	e7fc      	b.n	800c0e8 <SFU_AuthenticateFW_Append+0x1c>
 800c0ee:	bf00      	nop
 800c0f0:	20003ef4 	.word	0x20003ef4
 800c0f4:	0013023d 	.word	0x0013023d
 800c0f8:	00018799 	.word	0x00018799
 800c0fc:	0012310f 	.word	0x0012310f

0800c100 <SFU_AuthenticateFW_Finish>:
  * @param pOutputBuffer pointer to Output Buffer.
  * @param puOutputSize pointer to Output Size (bytes).
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SFU_AuthenticateFW_Finish(SE_StatusTypeDef *peSE_Status, uint8_t *pOutputBuffer, int32_t *pOutputSize)
{
 800c100:	b538      	push	{r3, r4, r5, lr}
 800c102:	4605      	mov	r5, r0
  SE_ErrorStatus se_status = SE_SUCCESS;
  CK_RV rv = CKR_OK;

  /* Check the pointers allocation */
  if ((pOutputBuffer == NULL) || (pOutputSize == NULL))
 800c104:	b1b9      	cbz	r1, 800c136 <SFU_AuthenticateFW_Finish+0x36>
 800c106:	b1b2      	cbz	r2, 800c136 <SFU_AuthenticateFW_Finish+0x36>
    se_status = SE_ERROR;
    *peSE_Status = SE_KO;
  }
#elif ((SECBOOT_CRYPTO_SCHEME == SECBOOT_ECCDSA_WITH_AES128_CBC_SHA256) || (SECBOOT_CRYPTO_SCHEME == SECBOOT_ECCDSA_WITHOUT_ENCRYPT_SHA256) )
  /* End-up Digest calculation */
  rv = C_DigestFinal(AuthenticateSession, (CK_BYTE_PTR)pOutputBuffer, (CK_ULONG_PTR)pOutputSize);
 800c108:	4c0c      	ldr	r4, [pc, #48]	; (800c13c <SFU_AuthenticateFW_Finish+0x3c>)
 800c10a:	6820      	ldr	r0, [r4, #0]
 800c10c:	f7fd f86a 	bl	80091e4 <SE_KMS_DigestFinal>
  if (rv != CKR_OK)
 800c110:	4623      	mov	r3, r4
 800c112:	b170      	cbz	r0, 800c132 <SFU_AuthenticateFW_Finish+0x32>
  {
    se_status = SE_ERROR;
    *peSE_Status = SE_KO;
 800c114:	4a0a      	ldr	r2, [pc, #40]	; (800c140 <SFU_AuthenticateFW_Finish+0x40>)
    se_status = SE_ERROR;
 800c116:	4c0b      	ldr	r4, [pc, #44]	; (800c144 <SFU_AuthenticateFW_Finish+0x44>)
    *peSE_Status = SE_KO;
 800c118:	602a      	str	r2, [r5, #0]
#else
#error "The current example does not support the selected crypto scheme."
#endif /* SECBOOT_AES128_GCM_AES128_GCM_AES128_GCM */

  /* Close the session */
  rv = C_CloseSession(AuthenticateSession);
 800c11a:	6818      	ldr	r0, [r3, #0]
 800c11c:	f7fc fe3e 	bl	8008d9c <SE_KMS_CloseSession>
  if (rv != CKR_OK)
 800c120:	b110      	cbz	r0, 800c128 <SFU_AuthenticateFW_Finish+0x28>
  {
    se_status = SE_ERROR;
    *peSE_Status = SE_KO;
 800c122:	4b07      	ldr	r3, [pc, #28]	; (800c140 <SFU_AuthenticateFW_Finish+0x40>)
    se_status = SE_ERROR;
 800c124:	4c07      	ldr	r4, [pc, #28]	; (800c144 <SFU_AuthenticateFW_Finish+0x44>)
    *peSE_Status = SE_KO;
 800c126:	602b      	str	r3, [r5, #0]
  }

  /* End-up the KMS service */
  C_Finalize(NULL) ;
 800c128:	2000      	movs	r0, #0
 800c12a:	f7fc fd79 	bl	8008c20 <SE_KMS_Finalize>

  return se_status;
}
 800c12e:	4620      	mov	r0, r4
 800c130:	bd38      	pop	{r3, r4, r5, pc}
  SE_ErrorStatus se_status = SE_SUCCESS;
 800c132:	4c05      	ldr	r4, [pc, #20]	; (800c148 <SFU_AuthenticateFW_Finish+0x48>)
 800c134:	e7f1      	b.n	800c11a <SFU_AuthenticateFW_Finish+0x1a>
    return SE_ERROR;
 800c136:	4c03      	ldr	r4, [pc, #12]	; (800c144 <SFU_AuthenticateFW_Finish+0x44>)
 800c138:	e7f9      	b.n	800c12e <SFU_AuthenticateFW_Finish+0x2e>
 800c13a:	bf00      	nop
 800c13c:	20003ef4 	.word	0x20003ef4
 800c140:	0013023d 	.word	0x0013023d
 800c144:	00018799 	.word	0x00018799
 800c148:	0012310f 	.word	0x0012310f

0800c14c <SFU_VerifyHeaderSignature>:
  *        This parameter can be a value of @ref SE_Status_Structure_definition.
  * @param pFwRawHeader pointer to RawHeader Buffer.
  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
  */
SE_ErrorStatus SFU_VerifyHeaderSignature(SE_StatusTypeDef *peSE_Status, SE_FwRawHeaderTypeDef *pxFwRawHeader)
{
 800c14c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  CK_FLAGS session_flags = CKF_SERIAL_SESSION;  /* Read ONLY session */
  CK_RV rv = CKR_OK;
  SE_ErrorStatus se_status = SE_SUCCESS;
  *peSE_Status = SE_OK;
 800c150:	4b39      	ldr	r3, [pc, #228]	; (800c238 <SFU_VerifyHeaderSignature+0xec>)
 800c152:	6003      	str	r3, [r0, #0]
{
 800c154:	b086      	sub	sp, #24

  const uint8_t *pPayload;                        /* Metadata payload */
  int32_t payloadSize;                            /* Metadata length to be considered for hash */
  uint8_t *pSignature = pxFwRawHeader->HeaderSignature; /* Signature ECDSA */
  CK_OBJECT_HANDLE hECDSAKey = 0UL;
  CK_MECHANISM cktest_ecdsa_256_mechanism =
 800c156:	2400      	movs	r4, #0
 800c158:	f241 0344 	movw	r3, #4164	; 0x1044
 800c15c:	e9cd 3403 	strd	r3, r4, [sp, #12]
{
 800c160:	4605      	mov	r5, r0
 800c162:	460f      	mov	r7, r1
  uint8_t *pSignature = pxFwRawHeader->HeaderSignature; /* Signature ECDSA */
 800c164:	f101 0980 	add.w	r9, r1, #128	; 0x80
  CK_MECHANISM cktest_ecdsa_256_mechanism =
 800c168:	9405      	str	r4, [sp, #20]
    0
  };
#endif /* SECBOOT_AES128_GCM_AES128_GCM_AES128_GCM */

  /* Check the pointers allocation */
  if (NULL == pxFwRawHeader)
 800c16a:	b931      	cbnz	r1, 800c17a <SFU_VerifyHeaderSignature+0x2e>
  {
    *peSE_Status = SE_KO;
 800c16c:	4b33      	ldr	r3, [pc, #204]	; (800c23c <SFU_VerifyHeaderSignature+0xf0>)
    return SE_ERROR;
 800c16e:	4c34      	ldr	r4, [pc, #208]	; (800c240 <SFU_VerifyHeaderSignature+0xf4>)
    *peSE_Status = SE_KO;
 800c170:	6003      	str	r3, [r0, #0]
  /* End-up the KMS service */
  C_Finalize(NULL) ;

  return se_status;

}
 800c172:	4620      	mov	r0, r4
 800c174:	b006      	add	sp, #24
 800c176:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  gcm_tag_header = pxFwRawHeader->HeaderSignature;
 800c17a:	4b32      	ldr	r3, [pc, #200]	; (800c244 <SFU_VerifyHeaderSignature+0xf8>)
  rv = C_OpenSession(0,  session_flags, NULL, 0, &VerifySession);
 800c17c:	4e32      	ldr	r6, [pc, #200]	; (800c248 <SFU_VerifyHeaderSignature+0xfc>)
  gcm_tag_header = pxFwRawHeader->HeaderSignature;
 800c17e:	f8c3 9000 	str.w	r9, [r3]
  C_Initialize(NULL) ;
 800c182:	4620      	mov	r0, r4
 800c184:	f7fc fd34 	bl	8008bf0 <SE_KMS_Initialize>
  rv = C_OpenSession(0,  session_flags, NULL, 0, &VerifySession);
 800c188:	9600      	str	r6, [sp, #0]
 800c18a:	4623      	mov	r3, r4
 800c18c:	4622      	mov	r2, r4
 800c18e:	2104      	movs	r1, #4
 800c190:	4620      	mov	r0, r4
 800c192:	f7fc fde3 	bl	8008d5c <SE_KMS_OpenSession>
  if (rv != CKR_OK)
 800c196:	b330      	cbz	r0, 800c1e6 <SFU_VerifyHeaderSignature+0x9a>
    *peSE_Status = SE_KO;
 800c198:	4b28      	ldr	r3, [pc, #160]	; (800c23c <SFU_VerifyHeaderSignature+0xf0>)
    se_status = SE_ERROR;
 800c19a:	4c29      	ldr	r4, [pc, #164]	; (800c240 <SFU_VerifyHeaderSignature+0xf4>)
    *peSE_Status = SE_KO;
 800c19c:	602b      	str	r3, [r5, #0]
  if (memcmp(pxSE_Metadata->SFUMagic, SFUM_1, strlen(SFUM_1)) == 0)
 800c19e:	492b      	ldr	r1, [pc, #172]	; (800c24c <SFU_VerifyHeaderSignature+0x100>)
 800c1a0:	2204      	movs	r2, #4
 800c1a2:	4638      	mov	r0, r7
 800c1a4:	f002 fd84 	bl	800ecb0 <memcmp>
 800c1a8:	b1f8      	cbz	r0, 800c1ea <SFU_VerifyHeaderSignature+0x9e>
    *peSE_Status = SE_KO;
 800c1aa:	4b24      	ldr	r3, [pc, #144]	; (800c23c <SFU_VerifyHeaderSignature+0xf0>)
 800c1ac:	602b      	str	r3, [r5, #0]
  CK_OBJECT_HANDLE hECDSAKey = 0UL;
 800c1ae:	f04f 0800 	mov.w	r8, #0
      se_status = SE_ERROR;
 800c1b2:	4c23      	ldr	r4, [pc, #140]	; (800c240 <SFU_VerifyHeaderSignature+0xf4>)
  rv = C_Verify(VerifySession, (CK_BYTE_PTR)pPayload, payloadSize, (CK_BYTE_PTR)pSignature, SE_HEADER_SIGN_LEN);
 800c1b4:	6830      	ldr	r0, [r6, #0]
 800c1b6:	f04f 0a40 	mov.w	sl, #64	; 0x40
 800c1ba:	f8cd a000 	str.w	sl, [sp]
 800c1be:	464b      	mov	r3, r9
 800c1c0:	2280      	movs	r2, #128	; 0x80
 800c1c2:	4639      	mov	r1, r7
 800c1c4:	f7fd f882 	bl	80092cc <SE_KMS_Verify>
  if (rv != CKR_OK)
 800c1c8:	b300      	cbz	r0, 800c20c <SFU_VerifyHeaderSignature+0xc0>
    *peSE_Status = SE_KO;
 800c1ca:	4b1c      	ldr	r3, [pc, #112]	; (800c23c <SFU_VerifyHeaderSignature+0xf0>)
    se_status = SE_ERROR;
 800c1cc:	4c1c      	ldr	r4, [pc, #112]	; (800c240 <SFU_VerifyHeaderSignature+0xf4>)
    *peSE_Status = SE_KO;
 800c1ce:	602b      	str	r3, [r5, #0]
  rv = C_CloseSession(VerifySession);
 800c1d0:	6830      	ldr	r0, [r6, #0]
 800c1d2:	f7fc fde3 	bl	8008d9c <SE_KMS_CloseSession>
  if (rv != CKR_OK)
 800c1d6:	b110      	cbz	r0, 800c1de <SFU_VerifyHeaderSignature+0x92>
    *peSE_Status = SE_KO;
 800c1d8:	4b18      	ldr	r3, [pc, #96]	; (800c23c <SFU_VerifyHeaderSignature+0xf0>)
    se_status = SE_ERROR;
 800c1da:	4c19      	ldr	r4, [pc, #100]	; (800c240 <SFU_VerifyHeaderSignature+0xf4>)
    *peSE_Status = SE_KO;
 800c1dc:	602b      	str	r3, [r5, #0]
  C_Finalize(NULL) ;
 800c1de:	2000      	movs	r0, #0
 800c1e0:	f7fc fd1e 	bl	8008c20 <SE_KMS_Finalize>
  return se_status;
 800c1e4:	e7c5      	b.n	800c172 <SFU_VerifyHeaderSignature+0x26>
  SE_ErrorStatus se_status = SE_SUCCESS;
 800c1e6:	4c1a      	ldr	r4, [pc, #104]	; (800c250 <SFU_VerifyHeaderSignature+0x104>)
 800c1e8:	e7d9      	b.n	800c19e <SFU_VerifyHeaderSignature+0x52>
  if (se_status == SE_SUCCESS)
 800c1ea:	4b19      	ldr	r3, [pc, #100]	; (800c250 <SFU_VerifyHeaderSignature+0x104>)
 800c1ec:	429c      	cmp	r4, r3
 800c1ee:	d10a      	bne.n	800c206 <SFU_VerifyHeaderSignature+0xba>
    rv = C_VerifyInit(VerifySession, &cktest_ecdsa_256_mechanism, hECDSAKey);
 800c1f0:	6830      	ldr	r0, [r6, #0]
 800c1f2:	2206      	movs	r2, #6
 800c1f4:	a903      	add	r1, sp, #12
 800c1f6:	f7fd f84d 	bl	8009294 <SE_KMS_VerifyInit>
    if (rv != CKR_OK)
 800c1fa:	b120      	cbz	r0, 800c206 <SFU_VerifyHeaderSignature+0xba>
      *peSE_Status = SE_KO;
 800c1fc:	4b0f      	ldr	r3, [pc, #60]	; (800c23c <SFU_VerifyHeaderSignature+0xf0>)
 800c1fe:	602b      	str	r3, [r5, #0]
    *phECDSAKey = KMS_SBSFU_KEY_1_ECDSA_OBJECT_HANDLE;
 800c200:	f04f 0806 	mov.w	r8, #6
 800c204:	e7d5      	b.n	800c1b2 <SFU_VerifyHeaderSignature+0x66>
 800c206:	f04f 0806 	mov.w	r8, #6
 800c20a:	e7d3      	b.n	800c1b4 <SFU_VerifyHeaderSignature+0x68>
  if (se_status == SE_SUCCESS)
 800c20c:	4b10      	ldr	r3, [pc, #64]	; (800c250 <SFU_VerifyHeaderSignature+0x104>)
 800c20e:	429c      	cmp	r4, r3
 800c210:	d1de      	bne.n	800c1d0 <SFU_VerifyHeaderSignature+0x84>
    rv = C_VerifyInit(VerifySession, &cktest_ecdsa_256_mechanism, hECDSAKey);
 800c212:	6830      	ldr	r0, [r6, #0]
 800c214:	4642      	mov	r2, r8
 800c216:	a903      	add	r1, sp, #12
 800c218:	f7fd f83c 	bl	8009294 <SE_KMS_VerifyInit>
    if (rv != CKR_OK)
 800c21c:	2800      	cmp	r0, #0
 800c21e:	d1d4      	bne.n	800c1ca <SFU_VerifyHeaderSignature+0x7e>
      rv = C_Verify(VerifySession, (CK_BYTE_PTR)pPayload, payloadSize, (CK_BYTE_PTR)pSignature, SE_HEADER_SIGN_LEN);
 800c220:	6830      	ldr	r0, [r6, #0]
 800c222:	f8cd a000 	str.w	sl, [sp]
 800c226:	464b      	mov	r3, r9
 800c228:	2280      	movs	r2, #128	; 0x80
 800c22a:	4639      	mov	r1, r7
 800c22c:	f7fd f84e 	bl	80092cc <SE_KMS_Verify>
      if (rv != CKR_OK)
 800c230:	2800      	cmp	r0, #0
 800c232:	d1ca      	bne.n	800c1ca <SFU_VerifyHeaderSignature+0x7e>
 800c234:	e7cc      	b.n	800c1d0 <SFU_VerifyHeaderSignature+0x84>
 800c236:	bf00      	nop
 800c238:	0012e223 	.word	0x0012e223
 800c23c:	0013023d 	.word	0x0013023d
 800c240:	00018799 	.word	0x00018799
 800c244:	200038d8 	.word	0x200038d8
 800c248:	20003ef8 	.word	0x20003ef8
 800c24c:	08011248 	.word	0x08011248
 800c250:	0012310f 	.word	0x0012310f

0800c254 <SFU_KMS_BlobToInstall>:
   */

  for (uint32_t i = 0U; i < SFU_NB_MAX_DWL_AREA; i++)
  {
    /* Slot configured ? */
    if (SlotStartAdd[SLOT_DWL_1 + i] != 0U)
 800c254:	4b0d      	ldr	r3, [pc, #52]	; (800c28c <SFU_KMS_BlobToInstall+0x38>)
 800c256:	6899      	ldr	r1, [r3, #8]
{
 800c258:	b510      	push	{r4, lr}
    if (SlotStartAdd[SLOT_DWL_1 + i] != 0U)
 800c25a:	b919      	cbnz	r1, 800c264 <SFU_KMS_BlobToInstall+0x10>
  SFU_ErrorStatus  e_ret_status = SFU_ERROR;
 800c25c:	f641 74e1 	movw	r4, #8161	; 0x1fe1
      }
    }
  }

  return e_ret_status;
}
 800c260:	4620      	mov	r0, r4
 800c262:	bd10      	pop	{r4, pc}
      if (SFU_LL_FLASH_Read((uint8_t *)(uint32_t)(&kmsblob_image_header_to_test),
 800c264:	480a      	ldr	r0, [pc, #40]	; (800c290 <SFU_KMS_BlobToInstall+0x3c>)
 800c266:	f44f 72a0 	mov.w	r2, #320	; 0x140
 800c26a:	f000 fbd3 	bl	800ca14 <SFU_LL_FLASH_Read>
 800c26e:	4b09      	ldr	r3, [pc, #36]	; (800c294 <SFU_KMS_BlobToInstall+0x40>)
 800c270:	4298      	cmp	r0, r3
 800c272:	4604      	mov	r4, r0
 800c274:	d1f2      	bne.n	800c25c <SFU_KMS_BlobToInstall+0x8>
        if (memcmp((uint8_t *)&kmsblob_image_header_to_test.KMSMagic, kms_magic, sizeof(kms_magic)) == 0)
 800c276:	4908      	ldr	r1, [pc, #32]	; (800c298 <SFU_KMS_BlobToInstall+0x44>)
 800c278:	4805      	ldr	r0, [pc, #20]	; (800c290 <SFU_KMS_BlobToInstall+0x3c>)
 800c27a:	2204      	movs	r2, #4
 800c27c:	f002 fd18 	bl	800ecb0 <memcmp>
 800c280:	2800      	cmp	r0, #0
 800c282:	d1eb      	bne.n	800c25c <SFU_KMS_BlobToInstall+0x8>
          kmsblob_slot = SLOT_DWL_1 + i; /* Save also DWN slot for later use */
 800c284:	4b05      	ldr	r3, [pc, #20]	; (800c29c <SFU_KMS_BlobToInstall+0x48>)
 800c286:	2202      	movs	r2, #2
 800c288:	601a      	str	r2, [r3, #0]
  return e_ret_status;
 800c28a:	e7e9      	b.n	800c260 <SFU_KMS_BlobToInstall+0xc>
 800c28c:	08010f28 	.word	0x08010f28
 800c290:	200038dc 	.word	0x200038dc
 800c294:	00122f11 	.word	0x00122f11
 800c298:	20003408 	.word	0x20003408
 800c29c:	20003a1c 	.word	0x20003a1c

0800c2a0 <SFU_KMS_GetBlobInstallInfo>:
  * @retval none
  */
SFU_ErrorStatus SFU_KMS_GetBlobInstallInfo(uint8_t **ppHdr, uint8_t **ppFlash)
{
  SFU_ErrorStatus  e_ret_status = SFU_ERROR;
  if ((ppHdr != NULL) && (ppFlash != NULL))
 800c2a0:	b160      	cbz	r0, 800c2bc <SFU_KMS_GetBlobInstallInfo+0x1c>
 800c2a2:	b159      	cbz	r1, 800c2bc <SFU_KMS_GetBlobInstallInfo+0x1c>
  {
    *ppHdr = (uint8_t *)(uint32_t)&kmsblob_image_header_to_test;
 800c2a4:	4b07      	ldr	r3, [pc, #28]	; (800c2c4 <SFU_KMS_GetBlobInstallInfo+0x24>)
 800c2a6:	6003      	str	r3, [r0, #0]
    *ppFlash = (uint8_t *)(((uint32_t)SlotStartAdd[kmsblob_slot]) + sizeof(kmsblob_image_header_to_test));
 800c2a8:	4b07      	ldr	r3, [pc, #28]	; (800c2c8 <SFU_KMS_GetBlobInstallInfo+0x28>)
    e_ret_status = SFU_SUCCESS;
 800c2aa:	4808      	ldr	r0, [pc, #32]	; (800c2cc <SFU_KMS_GetBlobInstallInfo+0x2c>)
    *ppFlash = (uint8_t *)(((uint32_t)SlotStartAdd[kmsblob_slot]) + sizeof(kmsblob_image_header_to_test));
 800c2ac:	681a      	ldr	r2, [r3, #0]
 800c2ae:	4b08      	ldr	r3, [pc, #32]	; (800c2d0 <SFU_KMS_GetBlobInstallInfo+0x30>)
 800c2b0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800c2b4:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 800c2b8:	600b      	str	r3, [r1, #0]
    e_ret_status = SFU_SUCCESS;
 800c2ba:	4770      	bx	lr
  SFU_ErrorStatus  e_ret_status = SFU_ERROR;
 800c2bc:	f641 70e1 	movw	r0, #8161	; 0x1fe1
  }
  return e_ret_status;
}
 800c2c0:	4770      	bx	lr
 800c2c2:	bf00      	nop
 800c2c4:	200038dc 	.word	0x200038dc
 800c2c8:	20003a1c 	.word	0x20003a1c
 800c2cc:	00122f11 	.word	0x00122f11
 800c2d0:	08010f28 	.word	0x08010f28

0800c2d4 <SFU_KMS_EraseBlob>:
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
  SFU_FLASH_StatusTypeDef flash_if_status;

  /*  Erase in flash  */
  e_ret_status = SFU_LL_FLASH_Erase_Size(&flash_if_status,
                                         (uint8_t *) SlotStartAdd[kmsblob_slot],
 800c2d4:	4b08      	ldr	r3, [pc, #32]	; (800c2f8 <SFU_KMS_EraseBlob+0x24>)
{
 800c2d6:	b507      	push	{r0, r1, r2, lr}
                                         (uint8_t *) SlotStartAdd[kmsblob_slot],
 800c2d8:	681b      	ldr	r3, [r3, #0]
 800c2da:	4a08      	ldr	r2, [pc, #32]	; (800c2fc <SFU_KMS_EraseBlob+0x28>)
 800c2dc:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
                                         SLOT_SIZE(kmsblob_slot));
 800c2e0:	4a07      	ldr	r2, [pc, #28]	; (800c300 <SFU_KMS_EraseBlob+0x2c>)
  e_ret_status = SFU_LL_FLASH_Erase_Size(&flash_if_status,
 800c2e2:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 800c2e6:	3201      	adds	r2, #1
 800c2e8:	1a52      	subs	r2, r2, r1
 800c2ea:	f10d 0007 	add.w	r0, sp, #7
 800c2ee:	f000 fb83 	bl	800c9f8 <SFU_LL_FLASH_Erase_Size>

  return e_ret_status;
}
 800c2f2:	b003      	add	sp, #12
 800c2f4:	f85d fb04 	ldr.w	pc, [sp], #4
 800c2f8:	20003a1c 	.word	0x20003a1c
 800c2fc:	08010f28 	.word	0x08010f28
 800c300:	08010f38 	.word	0x08010f38

0800c304 <SFU_KMS_CheckPendingBlobInstallation>:
  *         If a KMS blob is present then it is copied in kmsblob_image_header_to_test.
  * @param  None.
  * @retval SFU_KMS_BlobInstallStateTypeDef Pending Installation status (installation requested or not)
  */
SFU_KMS_BlobInstallStateTypeDef SFU_KMS_CheckPendingBlobInstallation(void)
{
 800c304:	b508      	push	{r3, lr}

  /*
   * While the SWAP AREA contains a KMSB Magic, it means the KMSBlob installation is not finalized.
   *
   */
  if (SFU_SUCCESS == SFU_KMS_BlobToInstall())
 800c306:	f7ff ffa5 	bl	800c254 <SFU_KMS_BlobToInstall>
    /* No pending update */
    e_ret_state = SFU_KMS_NO_BLOBUPDATE;
  }

  return e_ret_state;
}
 800c30a:	4b02      	ldr	r3, [pc, #8]	; (800c314 <SFU_KMS_CheckPendingBlobInstallation+0x10>)
 800c30c:	1ac0      	subs	r0, r0, r3
 800c30e:	bf18      	it	ne
 800c310:	2001      	movne	r0, #1
 800c312:	bd08      	pop	{r3, pc}
 800c314:	00122f11 	.word	0x00122f11

0800c318 <SFU_LOADER_VerifyFwHeader>:
#elif defined(__GNUC__)
__attribute__((optimize("O0")))
#endif /* __ICCARM__ */

static SFU_ErrorStatus SFU_LOADER_VerifyFwHeader(uint8_t *pBuffer)
{
 800c318:	b580      	push	{r7, lr}
 800c31a:	b08c      	sub	sp, #48	; 0x30
 800c31c:	af00      	add	r7, sp, #0
 800c31e:	6078      	str	r0, [r7, #4]
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
 800c320:	f641 73e1 	movw	r3, #8161	; 0x1fe1
 800c324:	62fb      	str	r3, [r7, #44]	; 0x2c
  uint16_t                      cur_ver;
  uint16_t                      verif_ver;
  uint32_t                      active_slot;

  /*Parse the received buffer*/
  p_x_fw_raw_header = (SE_FwRawHeaderTypeDef *)(uint32_t)pBuffer;
 800c326:	687b      	ldr	r3, [r7, #4]
 800c328:	62bb      	str	r3, [r7, #40]	; 0x28
  /*Check if the received header packet is authentic*/
  if (SE_VerifyHeaderSignature(&e_se_status, p_x_fw_raw_header) != SE_ERROR)
 800c32a:	f107 031c 	add.w	r3, r7, #28
 800c32e:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800c330:	4618      	mov	r0, r3
 800c332:	f7ff ff0b 	bl	800c14c <SFU_VerifyHeaderSignature>
 800c336:	4603      	mov	r3, r0
 800c338:	4a59      	ldr	r2, [pc, #356]	; (800c4a0 <SFU_LOADER_VerifyFwHeader+0x188>)
 800c33a:	4293      	cmp	r3, r2
 800c33c:	f000 80a8 	beq.w	800c490 <SFU_LOADER_VerifyFwHeader+0x178>
  {
    active_slot = SFU_IMG_GetFwImageSlot(p_x_fw_raw_header);
 800c340:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800c342:	f7fe fd4f 	bl	800ade4 <SFU_IMG_GetFwImageSlot>
 800c346:	6278      	str	r0, [r7, #36]	; 0x24
     *   It will be based on SFU magic :
     *   - same number as active_slot if configured.
     *   - else : SLOT_DWL_1
     *    As example : Header magic is SFU2, active slot is SLOT_ACTIVE_2 and dwl slot will be SLOT_DWL2.
     */
    m_uDwlSlot = active_slot - SLOT_ACTIVE_1 + SLOT_DWL_1;
 800c348:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c34a:	3301      	adds	r3, #1
 800c34c:	4a55      	ldr	r2, [pc, #340]	; (800c4a4 <SFU_LOADER_VerifyFwHeader+0x18c>)
 800c34e:	6013      	str	r3, [r2, #0]
    if (SLOT_SIZE(m_uDwlSlot) == 1U)
 800c350:	4b54      	ldr	r3, [pc, #336]	; (800c4a4 <SFU_LOADER_VerifyFwHeader+0x18c>)
 800c352:	681b      	ldr	r3, [r3, #0]
 800c354:	4a54      	ldr	r2, [pc, #336]	; (800c4a8 <SFU_LOADER_VerifyFwHeader+0x190>)
 800c356:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 800c35a:	4b52      	ldr	r3, [pc, #328]	; (800c4a4 <SFU_LOADER_VerifyFwHeader+0x18c>)
 800c35c:	681b      	ldr	r3, [r3, #0]
 800c35e:	4953      	ldr	r1, [pc, #332]	; (800c4ac <SFU_LOADER_VerifyFwHeader+0x194>)
 800c360:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800c364:	429a      	cmp	r2, r3
 800c366:	d102      	bne.n	800c36e <SFU_LOADER_VerifyFwHeader+0x56>
    {
      m_uDwlSlot = SLOT_DWL_1;
 800c368:	4b4e      	ldr	r3, [pc, #312]	; (800c4a4 <SFU_LOADER_VerifyFwHeader+0x18c>)
 800c36a:	2202      	movs	r2, #2
 800c36c:	601a      	str	r2, [r3, #0]
    }
    SFU_IMG_GetDownloadAreaInfo(m_uDwlSlot, &fw_image_flash_data);
 800c36e:	4b4d      	ldr	r3, [pc, #308]	; (800c4a4 <SFU_LOADER_VerifyFwHeader+0x18c>)
 800c370:	681b      	ldr	r3, [r3, #0]
 800c372:	f107 020c 	add.w	r2, r7, #12
 800c376:	4611      	mov	r1, r2
 800c378:	4618      	mov	r0, r3
 800c37a:	f000 fa29 	bl	800c7d0 <SFU_IMG_GetDownloadAreaInfo>

    /* Assign the download flash address to be used during the YMODEM process */
    m_uDwlAreaStart = fw_image_flash_data.DownloadAddr;
 800c37e:	693b      	ldr	r3, [r7, #16]
 800c380:	4a4b      	ldr	r2, [pc, #300]	; (800c4b0 <SFU_LOADER_VerifyFwHeader+0x198>)
 800c382:	6013      	str	r3, [r2, #0]
    m_uDwlAreaSize = fw_image_flash_data.MaxSizeInBytes;
 800c384:	68fb      	ldr	r3, [r7, #12]
 800c386:	4a4b      	ldr	r2, [pc, #300]	; (800c4b4 <SFU_LOADER_VerifyFwHeader+0x19c>)
 800c388:	6013      	str	r3, [r2, #0]

    /*
     * Check if the version is allowed
     * ==> SFU_IMG_GetActiveFwVersion() returns 0 if the header of active firmware is not valid
     */
    cur_ver = SFU_IMG_GetActiveFwVersion(active_slot);
 800c38a:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800c38c:	f7fe fd80 	bl	800ae90 <SFU_IMG_GetActiveFwVersion>
 800c390:	4603      	mov	r3, r0
 800c392:	847b      	strh	r3, [r7, #34]	; 0x22
    if (SFU_IMG_CheckFwVersion(active_slot, cur_ver, p_x_fw_raw_header->FwVersion) == SFU_SUCCESS)
 800c394:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c396:	88da      	ldrh	r2, [r3, #6]
 800c398:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800c39a:	4619      	mov	r1, r3
 800c39c:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800c39e:	f7fe fdb1 	bl	800af04 <SFU_IMG_CheckFwVersion>
 800c3a2:	4603      	mov	r3, r0
 800c3a4:	4a44      	ldr	r2, [pc, #272]	; (800c4b8 <SFU_LOADER_VerifyFwHeader+0x1a0>)
 800c3a6:	4293      	cmp	r3, r2
 800c3a8:	d125      	bne.n	800c3f6 <SFU_LOADER_VerifyFwHeader+0xde>
       *      Nevertheless, we can still detect if the FW is too big to be downloaded (cannot be written in dwl slot).
       *      This will avoid download issues (but the installation itself can still be rejected) or overflows.
       *      The dwl slot must contain the HEADER and also the binary FW (encrypted).
       *      But there is an offset of FW_OFFSET_IMAGE bytes to respect.
       */
      if ((p_x_fw_raw_header->PartialFwSize + (p_x_fw_raw_header->PartialFwOffset % SLOT_SIZE(SLOT_SWAP))) >
 800c3aa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c3ac:	6919      	ldr	r1, [r3, #16]
 800c3ae:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c3b0:	68db      	ldr	r3, [r3, #12]
 800c3b2:	4a3d      	ldr	r2, [pc, #244]	; (800c4a8 <SFU_LOADER_VerifyFwHeader+0x190>)
 800c3b4:	68d0      	ldr	r0, [r2, #12]
 800c3b6:	4a3d      	ldr	r2, [pc, #244]	; (800c4ac <SFU_LOADER_VerifyFwHeader+0x194>)
 800c3b8:	68d2      	ldr	r2, [r2, #12]
 800c3ba:	1a82      	subs	r2, r0, r2
 800c3bc:	3201      	adds	r2, #1
 800c3be:	fbb3 f0f2 	udiv	r0, r3, r2
 800c3c2:	fb02 f200 	mul.w	r2, r2, r0
 800c3c6:	1a9b      	subs	r3, r3, r2
 800c3c8:	18ca      	adds	r2, r1, r3
          (SLOT_SIZE(m_uDwlSlot) - SFU_IMG_IMAGE_OFFSET))
 800c3ca:	4b36      	ldr	r3, [pc, #216]	; (800c4a4 <SFU_LOADER_VerifyFwHeader+0x18c>)
 800c3cc:	681b      	ldr	r3, [r3, #0]
 800c3ce:	4936      	ldr	r1, [pc, #216]	; (800c4a8 <SFU_LOADER_VerifyFwHeader+0x190>)
 800c3d0:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
 800c3d4:	4b33      	ldr	r3, [pc, #204]	; (800c4a4 <SFU_LOADER_VerifyFwHeader+0x18c>)
 800c3d6:	681b      	ldr	r3, [r3, #0]
 800c3d8:	4834      	ldr	r0, [pc, #208]	; (800c4ac <SFU_LOADER_VerifyFwHeader+0x194>)
 800c3da:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 800c3de:	1acb      	subs	r3, r1, r3
 800c3e0:	f2a3 13ff 	subw	r3, r3, #511	; 0x1ff
      if ((p_x_fw_raw_header->PartialFwSize + (p_x_fw_raw_header->PartialFwOffset % SLOT_SIZE(SLOT_SWAP))) >
 800c3e4:	429a      	cmp	r2, r3
 800c3e6:	d903      	bls.n	800c3f0 <SFU_LOADER_VerifyFwHeader+0xd8>
#endif /* SFU_NO_SWAP */
      {
        /* The firmware cannot be written in dwl slot */
        m_LoaderStatus = SFU_LOADER_ERR_FW_LENGTH;
 800c3e8:	4b34      	ldr	r3, [pc, #208]	; (800c4bc <SFU_LOADER_VerifyFwHeader+0x1a4>)
 800c3ea:	2203      	movs	r2, #3
 800c3ec:	701a      	strb	r2, [r3, #0]
 800c3ee:	e00d      	b.n	800c40c <SFU_LOADER_VerifyFwHeader+0xf4>
      }
      else
      {
        /* Installation authorized */
        e_ret_status = SFU_SUCCESS;
 800c3f0:	4b31      	ldr	r3, [pc, #196]	; (800c4b8 <SFU_LOADER_VerifyFwHeader+0x1a0>)
 800c3f2:	62fb      	str	r3, [r7, #44]	; 0x2c
 800c3f4:	e00a      	b.n	800c40c <SFU_LOADER_VerifyFwHeader+0xf4>
    }
    else
    {
      /* The installation is forbidden */
      TRACE("\r\n          Anti-rollback: candidate version(%d) rejected | current version(%d) , min.version(%d) !",
            p_x_fw_raw_header->FwVersion, cur_ver, SFU_FW_VERSION_START_NUM);
 800c3f6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c3f8:	88db      	ldrh	r3, [r3, #6]
      TRACE("\r\n          Anti-rollback: candidate version(%d) rejected | current version(%d) , min.version(%d) !",
 800c3fa:	4619      	mov	r1, r3
 800c3fc:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
 800c3fe:	2301      	movs	r3, #1
 800c400:	482f      	ldr	r0, [pc, #188]	; (800c4c0 <SFU_LOADER_VerifyFwHeader+0x1a8>)
 800c402:	f002 fc79 	bl	800ecf8 <iprintf>
      m_LoaderStatus = SFU_LOADER_ERR_FW_VERSION;
 800c406:	4b2d      	ldr	r3, [pc, #180]	; (800c4bc <SFU_LOADER_VerifyFwHeader+0x1a4>)
 800c408:	2204      	movs	r2, #4
 800c40a:	701a      	strb	r2, [r3, #0]
    /*
     * Control of version and length is done twice to avoid basic hardware attack
     * This more important for the 1 image configuration as the installation is done during the download procedure
     * For the 2 images configuration anti-rollback will be checked again during installation process
     */
    verif_ver = SFU_IMG_GetActiveFwVersion(active_slot);
 800c40c:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800c40e:	f7fe fd3f 	bl	800ae90 <SFU_IMG_GetActiveFwVersion>
 800c412:	4603      	mov	r3, r0
 800c414:	843b      	strh	r3, [r7, #32]
    if (SFU_IMG_CheckFwVersion(active_slot, verif_ver, p_x_fw_raw_header->FwVersion) == SFU_SUCCESS)
 800c416:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c418:	88da      	ldrh	r2, [r3, #6]
 800c41a:	8c3b      	ldrh	r3, [r7, #32]
 800c41c:	4619      	mov	r1, r3
 800c41e:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800c420:	f7fe fd70 	bl	800af04 <SFU_IMG_CheckFwVersion>
 800c424:	4603      	mov	r3, r0
 800c426:	4a24      	ldr	r2, [pc, #144]	; (800c4b8 <SFU_LOADER_VerifyFwHeader+0x1a0>)
 800c428:	4293      	cmp	r3, r2
 800c42a:	d125      	bne.n	800c478 <SFU_LOADER_VerifyFwHeader+0x160>
       *      Nevertheless, we can still detect if the FW is too big to be downloaded (cannot be written in dwl slot).
       *      This will avoid download issues (but the installation itself can still be rejected) or overflows.
       *      The dwl slot must contain the HEADER and also the binary FW (encrypted).
       *      But there is an offset of FW_OFFSET_IMAGE bytes to respect.
       */
      if ((p_x_fw_raw_header->PartialFwSize + (p_x_fw_raw_header->PartialFwOffset % SLOT_SIZE(SLOT_SWAP))) >
 800c42c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c42e:	6919      	ldr	r1, [r3, #16]
 800c430:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c432:	68db      	ldr	r3, [r3, #12]
 800c434:	4a1c      	ldr	r2, [pc, #112]	; (800c4a8 <SFU_LOADER_VerifyFwHeader+0x190>)
 800c436:	68d0      	ldr	r0, [r2, #12]
 800c438:	4a1c      	ldr	r2, [pc, #112]	; (800c4ac <SFU_LOADER_VerifyFwHeader+0x194>)
 800c43a:	68d2      	ldr	r2, [r2, #12]
 800c43c:	1a82      	subs	r2, r0, r2
 800c43e:	3201      	adds	r2, #1
 800c440:	fbb3 f0f2 	udiv	r0, r3, r2
 800c444:	fb02 f200 	mul.w	r2, r2, r0
 800c448:	1a9b      	subs	r3, r3, r2
 800c44a:	18ca      	adds	r2, r1, r3
          (SLOT_SIZE(m_uDwlSlot) - SFU_IMG_IMAGE_OFFSET))
 800c44c:	4b15      	ldr	r3, [pc, #84]	; (800c4a4 <SFU_LOADER_VerifyFwHeader+0x18c>)
 800c44e:	681b      	ldr	r3, [r3, #0]
 800c450:	4915      	ldr	r1, [pc, #84]	; (800c4a8 <SFU_LOADER_VerifyFwHeader+0x190>)
 800c452:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
 800c456:	4b13      	ldr	r3, [pc, #76]	; (800c4a4 <SFU_LOADER_VerifyFwHeader+0x18c>)
 800c458:	681b      	ldr	r3, [r3, #0]
 800c45a:	4814      	ldr	r0, [pc, #80]	; (800c4ac <SFU_LOADER_VerifyFwHeader+0x194>)
 800c45c:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 800c460:	1acb      	subs	r3, r1, r3
 800c462:	f2a3 13ff 	subw	r3, r3, #511	; 0x1ff
      if ((p_x_fw_raw_header->PartialFwSize + (p_x_fw_raw_header->PartialFwOffset % SLOT_SIZE(SLOT_SWAP))) >
 800c466:	429a      	cmp	r2, r3
 800c468:	d903      	bls.n	800c472 <SFU_LOADER_VerifyFwHeader+0x15a>
#endif /* SFU_NO_SWAP */
      {
        /* The firmware cannot be written in dwl slot */
        m_LoaderStatus = SFU_LOADER_ERR_FW_LENGTH;
 800c46a:	4b14      	ldr	r3, [pc, #80]	; (800c4bc <SFU_LOADER_VerifyFwHeader+0x1a4>)
 800c46c:	2203      	movs	r2, #3
 800c46e:	701a      	strb	r2, [r3, #0]
 800c470:	e011      	b.n	800c496 <SFU_LOADER_VerifyFwHeader+0x17e>
      }
      else
      {
        /* Installation authorized */
        e_ret_status = SFU_SUCCESS;
 800c472:	4b11      	ldr	r3, [pc, #68]	; (800c4b8 <SFU_LOADER_VerifyFwHeader+0x1a0>)
 800c474:	62fb      	str	r3, [r7, #44]	; 0x2c
 800c476:	e00e      	b.n	800c496 <SFU_LOADER_VerifyFwHeader+0x17e>
    }
    else
    {
      /* The installation is forbidden */
      TRACE("\r\n          Anti-rollback: candidate version(%d) rejected | current version(%d) , min.version(%d) !",
            p_x_fw_raw_header->FwVersion, verif_ver, SFU_FW_VERSION_START_NUM);
 800c478:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c47a:	88db      	ldrh	r3, [r3, #6]
      TRACE("\r\n          Anti-rollback: candidate version(%d) rejected | current version(%d) , min.version(%d) !",
 800c47c:	4619      	mov	r1, r3
 800c47e:	8c3a      	ldrh	r2, [r7, #32]
 800c480:	2301      	movs	r3, #1
 800c482:	480f      	ldr	r0, [pc, #60]	; (800c4c0 <SFU_LOADER_VerifyFwHeader+0x1a8>)
 800c484:	f002 fc38 	bl	800ecf8 <iprintf>
      m_LoaderStatus = SFU_LOADER_ERR_FW_VERSION;
 800c488:	4b0c      	ldr	r3, [pc, #48]	; (800c4bc <SFU_LOADER_VerifyFwHeader+0x1a4>)
 800c48a:	2204      	movs	r2, #4
 800c48c:	701a      	strb	r2, [r3, #0]
 800c48e:	e002      	b.n	800c496 <SFU_LOADER_VerifyFwHeader+0x17e>
    }
  }
  else
  {
    /* Header authentication failure */
    m_LoaderStatus = SFU_LOADER_ERR_AUTH_FAILED;
 800c490:	4b0a      	ldr	r3, [pc, #40]	; (800c4bc <SFU_LOADER_VerifyFwHeader+0x1a4>)
 800c492:	2202      	movs	r2, #2
 800c494:	701a      	strb	r2, [r3, #0]
  }

  return e_ret_status;
 800c496:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
 800c498:	4618      	mov	r0, r3
 800c49a:	3730      	adds	r7, #48	; 0x30
 800c49c:	46bd      	mov	sp, r7
 800c49e:	bd80      	pop	{r7, pc}
 800c4a0:	00018799 	.word	0x00018799
 800c4a4:	20003a20 	.word	0x20003a20
 800c4a8:	08010f38 	.word	0x08010f38
 800c4ac:	08010f28 	.word	0x08010f28
 800c4b0:	20003a28 	.word	0x20003a28
 800c4b4:	20003a24 	.word	0x20003a24
 800c4b8:	00122f11 	.word	0x00122f11
 800c4bc:	20003b70 	.word	0x20003b70
 800c4c0:	08010158 	.word	0x08010158

0800c4c4 <SFU_LOADER_Init>:
}
 800c4c4:	4800      	ldr	r0, [pc, #0]	; (800c4c8 <SFU_LOADER_Init+0x4>)
 800c4c6:	4770      	bx	lr
 800c4c8:	00122f11 	.word	0x00122f11

0800c4cc <SFU_LOADER_DeInit>:
 800c4cc:	4800      	ldr	r0, [pc, #0]	; (800c4d0 <SFU_LOADER_DeInit+0x4>)
 800c4ce:	4770      	bx	lr
 800c4d0:	00122f11 	.word	0x00122f11

0800c4d4 <SFU_LOADER_DownloadNewUserFw>:
{
 800c4d4:	e92d 4f73 	stmdb	sp!, {r0, r1, r4, r5, r6, r8, r9, sl, fp, lr}
  SFU_COM_YMODEM_StatusTypeDef e_com_status = SFU_COM_YMODEM_ERROR;
 800c4d8:	f04f 0b01 	mov.w	fp, #1
{
 800c4dc:	4689      	mov	r9, r1
 800c4de:	4616      	mov	r6, r2
  SFU_COM_YMODEM_StatusTypeDef e_com_status = SFU_COM_YMODEM_ERROR;
 800c4e0:	f88d b007 	strb.w	fp, [sp, #7]
  if ((peSFU_LOADER_Status == NULL) || (pSize == NULL) || (pDwlSlot == NULL))
 800c4e4:	4680      	mov	r8, r0
 800c4e6:	b920      	cbnz	r0, 800c4f2 <SFU_LOADER_DownloadNewUserFw+0x1e>
    return SFU_ERROR;
 800c4e8:	f641 70e1 	movw	r0, #8161	; 0x1fe1
}
 800c4ec:	b002      	add	sp, #8
 800c4ee:	e8bd 8f70 	ldmia.w	sp!, {r4, r5, r6, r8, r9, sl, fp, pc}
  if ((peSFU_LOADER_Status == NULL) || (pSize == NULL) || (pDwlSlot == NULL))
 800c4f2:	2a00      	cmp	r2, #0
 800c4f4:	d0f8      	beq.n	800c4e8 <SFU_LOADER_DownloadNewUserFw+0x14>
 800c4f6:	2900      	cmp	r1, #0
 800c4f8:	d0f6      	beq.n	800c4e8 <SFU_LOADER_DownloadNewUserFw+0x14>
  (void) SFU_LL_SECU_IWDG_Refresh();
 800c4fa:	f000 fcbf 	bl	800ce7c <SFU_LL_SECU_IWDG_Refresh>
  TRACE("\r\n\t  File> Transfer> YMODEM> Send ");
 800c4fe:	4817      	ldr	r0, [pc, #92]	; (800c55c <SFU_LOADER_DownloadNewUserFw+0x88>)
  m_uDwlSlot = SLOT_DWL_1;
 800c500:	f8df a07c 	ldr.w	sl, [pc, #124]	; 800c580 <SFU_LOADER_DownloadNewUserFw+0xac>
  m_LoaderStatus = SFU_LOADER_ERR_COM;
 800c504:	4d16      	ldr	r5, [pc, #88]	; (800c560 <SFU_LOADER_DownloadNewUserFw+0x8c>)
  TRACE("\r\n\t  File> Transfer> YMODEM> Send ");
 800c506:	f002 fbf7 	bl	800ecf8 <iprintf>
  m_uDwlAreaAddress = 0U;
 800c50a:	4b16      	ldr	r3, [pc, #88]	; (800c564 <SFU_LOADER_DownloadNewUserFw+0x90>)
  m_LoaderStatus = SFU_LOADER_ERR_COM;
 800c50c:	f885 b000 	strb.w	fp, [r5]
  m_uDwlAreaAddress = 0U;
 800c510:	2400      	movs	r4, #0
 800c512:	601c      	str	r4, [r3, #0]
  m_uDwlAreaStart = 0U;
 800c514:	4b14      	ldr	r3, [pc, #80]	; (800c568 <SFU_LOADER_DownloadNewUserFw+0x94>)
 800c516:	601c      	str	r4, [r3, #0]
  m_uDwlAreaSize = 0U;
 800c518:	4b14      	ldr	r3, [pc, #80]	; (800c56c <SFU_LOADER_DownloadNewUserFw+0x98>)
 800c51a:	601c      	str	r4, [r3, #0]
  m_uFileSizeYmodem = 0U;
 800c51c:	4b14      	ldr	r3, [pc, #80]	; (800c570 <SFU_LOADER_DownloadNewUserFw+0x9c>)
 800c51e:	601c      	str	r4, [r3, #0]
  m_uNbrBlocksYmodem = 0U;
 800c520:	4b14      	ldr	r3, [pc, #80]	; (800c574 <SFU_LOADER_DownloadNewUserFw+0xa0>)
 800c522:	601c      	str	r4, [r3, #0]
  m_uPacketsReceived = 0U;
 800c524:	4b14      	ldr	r3, [pc, #80]	; (800c578 <SFU_LOADER_DownloadNewUserFw+0xa4>)
  if (SFU_COM_YMODEM_Receive(&e_com_status, pSize) == SFU_SUCCESS)
 800c526:	4631      	mov	r1, r6
  m_uPacketsReceived = 0U;
 800c528:	601c      	str	r4, [r3, #0]
  if (SFU_COM_YMODEM_Receive(&e_com_status, pSize) == SFU_SUCCESS)
 800c52a:	f10d 0007 	add.w	r0, sp, #7
  m_uDwlSlot = SLOT_DWL_1;
 800c52e:	2302      	movs	r3, #2
 800c530:	f8ca 3000 	str.w	r3, [sl]
  if (SFU_COM_YMODEM_Receive(&e_com_status, pSize) == SFU_SUCCESS)
 800c534:	f7fd fea8 	bl	800a288 <SFU_COM_YMODEM_Receive>
 800c538:	4b10      	ldr	r3, [pc, #64]	; (800c57c <SFU_LOADER_DownloadNewUserFw+0xa8>)
 800c53a:	4298      	cmp	r0, r3
 800c53c:	d102      	bne.n	800c544 <SFU_LOADER_DownloadNewUserFw+0x70>
    if (*pSize > 0U)
 800c53e:	6833      	ldr	r3, [r6, #0]
 800c540:	b103      	cbz	r3, 800c544 <SFU_LOADER_DownloadNewUserFw+0x70>
      m_LoaderStatus = SFU_LOADER_OK;
 800c542:	702c      	strb	r4, [r5, #0]
  *pDwlSlot = m_uDwlSlot;
 800c544:	f8da 3000 	ldr.w	r3, [sl]
 800c548:	f8c9 3000 	str.w	r3, [r9]
  *peSFU_LOADER_Status = m_LoaderStatus;
 800c54c:	782b      	ldrb	r3, [r5, #0]
 800c54e:	f888 3000 	strb.w	r3, [r8]
  if (m_LoaderStatus == SFU_LOADER_OK)
 800c552:	2b00      	cmp	r3, #0
 800c554:	d1c8      	bne.n	800c4e8 <SFU_LOADER_DownloadNewUserFw+0x14>
    e_ret_status = SFU_SUCCESS;
 800c556:	4809      	ldr	r0, [pc, #36]	; (800c57c <SFU_LOADER_DownloadNewUserFw+0xa8>)
 800c558:	e7c8      	b.n	800c4ec <SFU_LOADER_DownloadNewUserFw+0x18>
 800c55a:	bf00      	nop
 800c55c:	080101bc 	.word	0x080101bc
 800c560:	20003b70 	.word	0x20003b70
 800c564:	20003b74 	.word	0x20003b74
 800c568:	20003a28 	.word	0x20003a28
 800c56c:	20003a24 	.word	0x20003a24
 800c570:	20003b7c 	.word	0x20003b7c
 800c574:	20003b80 	.word	0x20003b80
 800c578:	20003b84 	.word	0x20003b84
 800c57c:	00122f11 	.word	0x00122f11
 800c580:	20003a20 	.word	0x20003a20

0800c584 <SFU_COM_YMODEM_HeaderPktRxCpltCallback>:
{
 800c584:	b508      	push	{r3, lr}
  m_uPacketsReceived = 0U;
 800c586:	4b08      	ldr	r3, [pc, #32]	; (800c5a8 <SFU_COM_YMODEM_HeaderPktRxCpltCallback+0x24>)
 800c588:	2200      	movs	r2, #0
 800c58a:	601a      	str	r2, [r3, #0]
  m_uFileSizeYmodem = uFileSize;
 800c58c:	4b07      	ldr	r3, [pc, #28]	; (800c5ac <SFU_COM_YMODEM_HeaderPktRxCpltCallback+0x28>)
 800c58e:	6018      	str	r0, [r3, #0]
  m_uNbrBlocksYmodem = (m_uFileSizeYmodem + (SFU_COM_YMODEM_PACKET_1K_SIZE - 1U)) / SFU_COM_YMODEM_PACKET_1K_SIZE;
 800c590:	4b07      	ldr	r3, [pc, #28]	; (800c5b0 <SFU_COM_YMODEM_HeaderPktRxCpltCallback+0x2c>)
 800c592:	f200 30ff 	addw	r0, r0, #1023	; 0x3ff
 800c596:	0a80      	lsrs	r0, r0, #10
 800c598:	6018      	str	r0, [r3, #0]
  HAL_Delay(1000U);
 800c59a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800c59e:	f000 fe7b 	bl	800d298 <HAL_Delay>
}
 800c5a2:	4804      	ldr	r0, [pc, #16]	; (800c5b4 <SFU_COM_YMODEM_HeaderPktRxCpltCallback+0x30>)
 800c5a4:	bd08      	pop	{r3, pc}
 800c5a6:	bf00      	nop
 800c5a8:	20003b84 	.word	0x20003b84
 800c5ac:	20003b7c 	.word	0x20003b7c
 800c5b0:	20003b80 	.word	0x20003b80
 800c5b4:	00122f11 	.word	0x00122f11

0800c5b8 <SFU_COM_YMODEM_DataPktRxCpltCallback>:
{
 800c5b8:	e92d 4777 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r8, r9, sl, lr}
 800c5bc:	460c      	mov	r4, r1
  if (p_data == NULL)
 800c5be:	4606      	mov	r6, r0
 800c5c0:	2800      	cmp	r0, #0
 800c5c2:	f000 80c5 	beq.w	800c750 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x198>
  m_uPacketsReceived++;
 800c5c6:	4a64      	ldr	r2, [pc, #400]	; (800c758 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1a0>)
  if (m_uPacketsReceived == m_uNbrBlocksYmodem)
 800c5c8:	4964      	ldr	r1, [pc, #400]	; (800c75c <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1a4>)
  m_uPacketsReceived++;
 800c5ca:	6813      	ldr	r3, [r2, #0]
  if (m_uPacketsReceived == m_uNbrBlocksYmodem)
 800c5cc:	6808      	ldr	r0, [r1, #0]
  m_uPacketsReceived++;
 800c5ce:	3301      	adds	r3, #1
  if (m_uPacketsReceived == m_uNbrBlocksYmodem)
 800c5d0:	4283      	cmp	r3, r0
  m_uPacketsReceived++;
 800c5d2:	6013      	str	r3, [r2, #0]
  if (m_uPacketsReceived == m_uNbrBlocksYmodem)
 800c5d4:	4691      	mov	r9, r2
 800c5d6:	468a      	mov	sl, r1
 800c5d8:	d107      	bne.n	800c5ea <SFU_COM_YMODEM_DataPktRxCpltCallback+0x32>
    if (0U == (m_uFileSizeYmodem % SFU_COM_YMODEM_PACKET_1K_SIZE))
 800c5da:	4a61      	ldr	r2, [pc, #388]	; (800c760 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1a8>)
 800c5dc:	6814      	ldr	r4, [r2, #0]
 800c5de:	f3c4 0409 	ubfx	r4, r4, #0, #10
      rx_size = SFU_COM_YMODEM_PACKET_1K_SIZE;
 800c5e2:	2c00      	cmp	r4, #0
 800c5e4:	bf08      	it	eq
 800c5e6:	f44f 6480 	moveq.w	r4, #1024	; 0x400
  if (m_uPacketsReceived == 1U)
 800c5ea:	2b01      	cmp	r3, #1
 800c5ec:	d152      	bne.n	800c694 <SFU_COM_YMODEM_DataPktRxCpltCallback+0xdc>
    (void) memcpy(fw_header, p_data, SE_FW_HEADER_TOT_LEN);
 800c5ee:	f8df 8194 	ldr.w	r8, [pc, #404]	; 800c784 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1cc>
 800c5f2:	f44f 72a0 	mov.w	r2, #320	; 0x140
 800c5f6:	4631      	mov	r1, r6
 800c5f8:	4640      	mov	r0, r8
 800c5fa:	f002 fb67 	bl	800eccc <memcpy>
    e_ret_status = SFU_LOADER_VerifyFwHeader(p_data);
 800c5fe:	4630      	mov	r0, r6
 800c600:	f7ff fe8a 	bl	800c318 <SFU_LOADER_VerifyFwHeader>
    if (e_ret_status == SFU_SUCCESS)
 800c604:	4b57      	ldr	r3, [pc, #348]	; (800c764 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1ac>)
 800c606:	4298      	cmp	r0, r3
    e_ret_status = SFU_LOADER_VerifyFwHeader(p_data);
 800c608:	4605      	mov	r5, r0
    if (e_ret_status == SFU_SUCCESS)
 800c60a:	d12b      	bne.n	800c664 <SFU_COM_YMODEM_DataPktRxCpltCallback+0xac>
      m_uDwlAreaAddress = m_uDwlAreaStart;
 800c60c:	4b56      	ldr	r3, [pc, #344]	; (800c768 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1b0>)
                      (((SE_FwRawHeaderTypeDef *)(uint32_t)fw_header)->PartialFwOffset % SLOT_SIZE(SLOT_SWAP)) +
 800c60e:	4857      	ldr	r0, [pc, #348]	; (800c76c <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1b4>)
      m_uDwlAreaAddress = m_uDwlAreaStart;
 800c610:	6819      	ldr	r1, [r3, #0]
 800c612:	4b57      	ldr	r3, [pc, #348]	; (800c770 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1b8>)
                      (((SE_FwRawHeaderTypeDef *)(uint32_t)fw_header)->PartialFwOffset % SLOT_SIZE(SLOT_SWAP)) +
 800c614:	f8df c168 	ldr.w	ip, [pc, #360]	; 800c780 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1c8>
      m_uDwlAreaAddress = m_uDwlAreaStart;
 800c618:	6019      	str	r1, [r3, #0]
                      (((SE_FwRawHeaderTypeDef *)(uint32_t)fw_header)->PartialFwOffset % SLOT_SIZE(SLOT_SWAP)) +
 800c61a:	68c3      	ldr	r3, [r0, #12]
 800c61c:	f8dc 200c 	ldr.w	r2, [ip, #12]
 800c620:	f8d8 e00c 	ldr.w	lr, [r8, #12]
 800c624:	3301      	adds	r3, #1
 800c626:	1a9b      	subs	r3, r3, r2
 800c628:	fbbe f2f3 	udiv	r2, lr, r3
 800c62c:	fb03 e312 	mls	r3, r3, r2, lr
 800c630:	f8d8 2010 	ldr.w	r2, [r8, #16]
 800c634:	f502 7200 	add.w	r2, r2, #512	; 0x200
 800c638:	4413      	add	r3, r2
      m_uDwlImgSize = ((SE_FwRawHeaderTypeDef *)(uint32_t)fw_header)->PartialFwSize +
 800c63a:	4a4e      	ldr	r2, [pc, #312]	; (800c774 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1bc>)
 800c63c:	6013      	str	r3, [r2, #0]
      if (SFU_LL_FLASH_Erase_Size(&x_flash_info, (uint8_t *) m_uDwlAreaAddress, SLOT_SIZE(m_uDwlSlot)) !=
 800c63e:	4b4e      	ldr	r3, [pc, #312]	; (800c778 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1c0>)
 800c640:	681a      	ldr	r2, [r3, #0]
 800c642:	f850 3022 	ldr.w	r3, [r0, r2, lsl #2]
 800c646:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
 800c64a:	3301      	adds	r3, #1
 800c64c:	1a9a      	subs	r2, r3, r2
 800c64e:	f10d 0007 	add.w	r0, sp, #7
 800c652:	f000 f9d1 	bl	800c9f8 <SFU_LL_FLASH_Erase_Size>
 800c656:	42a8      	cmp	r0, r5
 800c658:	d01c      	beq.n	800c694 <SFU_COM_YMODEM_DataPktRxCpltCallback+0xdc>
        m_LoaderStatus = SFU_LOADER_ERR_FLASH;
 800c65a:	4b48      	ldr	r3, [pc, #288]	; (800c77c <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1c4>)
 800c65c:	2205      	movs	r2, #5
 800c65e:	701a      	strb	r2, [r3, #0]
        e_ret_status = SFU_ERROR;
 800c660:	f641 75e1 	movw	r5, #8161	; 0x1fe1
  if (m_uPacketsReceived == m_uNbrBlocksYmodem)
 800c664:	f8da 3000 	ldr.w	r3, [sl]
 800c668:	f8d9 2000 	ldr.w	r2, [r9]
 800c66c:	429a      	cmp	r2, r3
    m_uPacketsReceived = 0U;
 800c66e:	bf04      	itt	eq
 800c670:	2300      	moveq	r3, #0
 800c672:	f8c9 3000 	streq.w	r3, [r9]
  if (e_ret_status == SFU_ERROR)
 800c676:	f641 73e1 	movw	r3, #8161	; 0x1fe1
 800c67a:	429d      	cmp	r5, r3
 800c67c:	d106      	bne.n	800c68c <SFU_COM_YMODEM_DataPktRxCpltCallback+0xd4>
    m_uFileSizeYmodem = 0U;
 800c67e:	4a38      	ldr	r2, [pc, #224]	; (800c760 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1a8>)
 800c680:	2300      	movs	r3, #0
 800c682:	6013      	str	r3, [r2, #0]
    m_uPacketsReceived = 0U;
 800c684:	f8c9 3000 	str.w	r3, [r9]
    m_uNbrBlocksYmodem = 0U;
 800c688:	f8ca 3000 	str.w	r3, [sl]
}
 800c68c:	4628      	mov	r0, r5
 800c68e:	b003      	add	sp, #12
 800c690:	e8bd 8770 	ldmia.w	sp!, {r4, r5, r6, r8, r9, sl, pc}
    if ((m_uDwlAreaAddress < (m_uDwlAreaStart + SFU_IMG_IMAGE_OFFSET)) &&
 800c694:	4d34      	ldr	r5, [pc, #208]	; (800c768 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1b0>)
 800c696:	4a36      	ldr	r2, [pc, #216]	; (800c770 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1b8>)
 800c698:	682b      	ldr	r3, [r5, #0]
 800c69a:	6811      	ldr	r1, [r2, #0]
 800c69c:	f503 7300 	add.w	r3, r3, #512	; 0x200
 800c6a0:	428b      	cmp	r3, r1
 800c6a2:	4690      	mov	r8, r2
 800c6a4:	d923      	bls.n	800c6ee <SFU_COM_YMODEM_DataPktRxCpltCallback+0x136>
 800c6a6:	190a      	adds	r2, r1, r4
 800c6a8:	4293      	cmp	r3, r2
 800c6aa:	d820      	bhi.n	800c6ee <SFU_COM_YMODEM_DataPktRxCpltCallback+0x136>
      if (SFU_LL_FLASH_Write(&x_flash_info, (uint8_t *)m_uDwlAreaAddress, p_data, uLength) == SFU_SUCCESS)
 800c6ac:	f44f 7300 	mov.w	r3, #512	; 0x200
 800c6b0:	4632      	mov	r2, r6
 800c6b2:	f10d 0007 	add.w	r0, sp, #7
 800c6b6:	f000 f9a6 	bl	800ca06 <SFU_LL_FLASH_Write>
 800c6ba:	4b2a      	ldr	r3, [pc, #168]	; (800c764 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1ac>)
 800c6bc:	4298      	cmp	r0, r3
 800c6be:	d1cc      	bne.n	800c65a <SFU_COM_YMODEM_DataPktRxCpltCallback+0xa2>
                                        SLOT_SIZE(SLOT_SWAP));
 800c6c0:	4b2a      	ldr	r3, [pc, #168]	; (800c76c <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1b4>)
 800c6c2:	4a2f      	ldr	r2, [pc, #188]	; (800c780 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1c8>)
 800c6c4:	68db      	ldr	r3, [r3, #12]
 800c6c6:	68d2      	ldr	r2, [r2, #12]
 800c6c8:	3301      	adds	r3, #1
 800c6ca:	1a9b      	subs	r3, r3, r2
        m_uDwlAreaAddress += uLength + (((SE_FwRawHeaderTypeDef *)(uint32_t)fw_header)->PartialFwOffset %
 800c6cc:	4a2d      	ldr	r2, [pc, #180]	; (800c784 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1cc>)
 800c6ce:	68d1      	ldr	r1, [r2, #12]
 800c6d0:	fbb1 f2f3 	udiv	r2, r1, r3
 800c6d4:	fb03 1312 	mls	r3, r3, r2, r1
 800c6d8:	f8d8 2000 	ldr.w	r2, [r8]
 800c6dc:	f502 7200 	add.w	r2, r2, #512	; 0x200
 800c6e0:	4413      	add	r3, r2
 800c6e2:	f8c8 3000 	str.w	r3, [r8]
        rx_size -= uLength;
 800c6e6:	f5a4 7400 	sub.w	r4, r4, #512	; 0x200
        p_data += uLength;
 800c6ea:	f506 7600 	add.w	r6, r6, #512	; 0x200
    if ((m_uDwlAreaAddress + rx_size) > (m_uDwlAreaStart + m_uDwlImgSize))
 800c6ee:	4b21      	ldr	r3, [pc, #132]	; (800c774 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1bc>)
 800c6f0:	f8d8 1000 	ldr.w	r1, [r8]
 800c6f4:	6828      	ldr	r0, [r5, #0]
 800c6f6:	681b      	ldr	r3, [r3, #0]
 800c6f8:	190a      	adds	r2, r1, r4
 800c6fa:	4403      	add	r3, r0
 800c6fc:	429a      	cmp	r2, r3
 800c6fe:	d81e      	bhi.n	800c73e <SFU_COM_YMODEM_DataPktRxCpltCallback+0x186>
    if ((rx_size % (uint32_t)sizeof(SFU_LL_FLASH_write_t)) != 0U)
 800c700:	0763      	lsls	r3, r4, #29
 800c702:	d006      	beq.n	800c712 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x15a>
      rx_size = rx_size + ((uint32_t)sizeof(SFU_LL_FLASH_write_t) - (rx_size % (uint32_t)sizeof(SFU_LL_FLASH_write_t)));
 800c704:	f024 0307 	bic.w	r3, r4, #7
 800c708:	3308      	adds	r3, #8
        p_data[uOldSize] = 0xFF;
 800c70a:	22ff      	movs	r2, #255	; 0xff
      while (uOldSize < rx_size)
 800c70c:	429c      	cmp	r4, r3
 800c70e:	d31c      	bcc.n	800c74a <SFU_COM_YMODEM_DataPktRxCpltCallback+0x192>
 800c710:	461c      	mov	r4, r3
    if ((m_uDwlAreaAddress + rx_size) > (m_uDwlAreaStart + m_uDwlAreaSize))
 800c712:	4b1d      	ldr	r3, [pc, #116]	; (800c788 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1d0>)
 800c714:	681b      	ldr	r3, [r3, #0]
 800c716:	190a      	adds	r2, r1, r4
 800c718:	4403      	add	r3, r0
 800c71a:	429a      	cmp	r2, r3
 800c71c:	d80f      	bhi.n	800c73e <SFU_COM_YMODEM_DataPktRxCpltCallback+0x186>
    if (SFU_LL_FLASH_Write(&x_flash_info, (uint8_t *)m_uDwlAreaAddress, p_data, rx_size) == SFU_SUCCESS)
 800c71e:	4623      	mov	r3, r4
 800c720:	4632      	mov	r2, r6
 800c722:	f10d 0007 	add.w	r0, sp, #7
 800c726:	f000 f96e 	bl	800ca06 <SFU_LL_FLASH_Write>
 800c72a:	4b0e      	ldr	r3, [pc, #56]	; (800c764 <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1ac>)
 800c72c:	4298      	cmp	r0, r3
 800c72e:	4605      	mov	r5, r0
 800c730:	d193      	bne.n	800c65a <SFU_COM_YMODEM_DataPktRxCpltCallback+0xa2>
      m_uDwlAreaAddress += (rx_size);
 800c732:	f8d8 1000 	ldr.w	r1, [r8]
 800c736:	4421      	add	r1, r4
 800c738:	f8c8 1000 	str.w	r1, [r8]
 800c73c:	e792      	b.n	800c664 <SFU_COM_YMODEM_DataPktRxCpltCallback+0xac>
      m_LoaderStatus = SFU_LOADER_ERR_FW_LENGTH;
 800c73e:	4b0f      	ldr	r3, [pc, #60]	; (800c77c <SFU_COM_YMODEM_DataPktRxCpltCallback+0x1c4>)
 800c740:	2203      	movs	r2, #3
 800c742:	701a      	strb	r2, [r3, #0]
      e_ret_status = SFU_ERROR;
 800c744:	f641 75e1 	movw	r5, #8161	; 0x1fe1
 800c748:	e78c      	b.n	800c664 <SFU_COM_YMODEM_DataPktRxCpltCallback+0xac>
        p_data[uOldSize] = 0xFF;
 800c74a:	5532      	strb	r2, [r6, r4]
        uOldSize++;
 800c74c:	3401      	adds	r4, #1
 800c74e:	e7dd      	b.n	800c70c <SFU_COM_YMODEM_DataPktRxCpltCallback+0x154>
    return SFU_ERROR;
 800c750:	f641 75e1 	movw	r5, #8161	; 0x1fe1
 800c754:	e79a      	b.n	800c68c <SFU_COM_YMODEM_DataPktRxCpltCallback+0xd4>
 800c756:	bf00      	nop
 800c758:	20003b84 	.word	0x20003b84
 800c75c:	20003b80 	.word	0x20003b80
 800c760:	20003b7c 	.word	0x20003b7c
 800c764:	00122f11 	.word	0x00122f11
 800c768:	20003a28 	.word	0x20003a28
 800c76c:	08010f38 	.word	0x08010f38
 800c770:	20003b74 	.word	0x20003b74
 800c774:	20003b78 	.word	0x20003b78
 800c778:	20003a20 	.word	0x20003a20
 800c77c:	20003b70 	.word	0x20003b70
 800c780:	08010f28 	.word	0x08010f28
 800c784:	20003a30 	.word	0x20003a30
 800c788:	20003a24 	.word	0x20003a24

0800c78c <SFU_IMG_InstallAtNextReset>:
  *         This function is used by the local loader to request a Firmware installation (at next reboot).
  * @param  fw_header FW header of the FW to be installed
  * @retval SFU_SUCCESS if successful, otherwise SFU_ERROR
  */
SFU_ErrorStatus SFU_IMG_InstallAtNextReset(uint8_t *fw_header)
{
 800c78c:	b573      	push	{r0, r1, r4, r5, r6, lr}
#if  !defined(SFU_NO_SWAP)
  if (fw_header == NULL)
 800c78e:	4605      	mov	r5, r0
 800c790:	b1b0      	cbz	r0, 800c7c0 <SFU_IMG_InstallAtNextReset+0x34>
  ret = SFU_LL_FLASH_Erase_Size(&flash_if_info, (uint8_t *) SlotStartAdd[SLOT_SWAP], SFU_IMG_IMAGE_OFFSET);
 800c792:	4b0d      	ldr	r3, [pc, #52]	; (800c7c8 <SFU_IMG_InstallAtNextReset+0x3c>)
 800c794:	68de      	ldr	r6, [r3, #12]
 800c796:	f44f 7200 	mov.w	r2, #512	; 0x200
 800c79a:	4631      	mov	r1, r6
 800c79c:	f10d 0007 	add.w	r0, sp, #7
 800c7a0:	f000 f92a 	bl	800c9f8 <SFU_LL_FLASH_Erase_Size>
  if (ret == SFU_SUCCESS)
 800c7a4:	4b09      	ldr	r3, [pc, #36]	; (800c7cc <SFU_IMG_InstallAtNextReset+0x40>)
 800c7a6:	4298      	cmp	r0, r3
  ret = SFU_LL_FLASH_Erase_Size(&flash_if_info, (uint8_t *) SlotStartAdd[SLOT_SWAP], SFU_IMG_IMAGE_OFFSET);
 800c7a8:	4604      	mov	r4, r0
  if (ret == SFU_SUCCESS)
 800c7aa:	d109      	bne.n	800c7c0 <SFU_IMG_InstallAtNextReset+0x34>
    ret = SFU_LL_FLASH_Write(&flash_if_info, (uint8_t *)SlotStartAdd[SLOT_SWAP], pfw_header, SE_FW_HEADER_TOT_LEN);
 800c7ac:	f44f 73a0 	mov.w	r3, #320	; 0x140
 800c7b0:	462a      	mov	r2, r5
 800c7b2:	4631      	mov	r1, r6
 800c7b4:	f10d 0007 	add.w	r0, sp, #7
 800c7b8:	f000 f925 	bl	800ca06 <SFU_LL_FLASH_Write>
  {
    return SFU_ERROR;
  }
  if (WriteInstallHeader(fw_header) != SFU_SUCCESS)
 800c7bc:	42a0      	cmp	r0, r4
 800c7be:	d001      	beq.n	800c7c4 <SFU_IMG_InstallAtNextReset+0x38>
  {
    return SFU_ERROR;
 800c7c0:	f641 70e1 	movw	r0, #8161	; 0x1fe1
  }
  return SFU_SUCCESS;
#else
  return SFU_SUCCESS;           /* Nothing to do */
#endif /* !SFU_NO_SWAP*/
}
 800c7c4:	b002      	add	sp, #8
 800c7c6:	bd70      	pop	{r4, r5, r6, pc}
 800c7c8:	08010f28 	.word	0x08010f28
 800c7cc:	00122f11 	.word	0x00122f11

0800c7d0 <SFU_IMG_GetDownloadAreaInfo>:
  * @param  pArea pointer to area descriptor
  * @retval none
  */
void SFU_IMG_GetDownloadAreaInfo(uint32_t DwlSlot, SFU_FwImageFlashTypeDef *pArea)
{
  pArea->DownloadAddr = SlotStartAdd[DwlSlot];
 800c7d0:	4a09      	ldr	r2, [pc, #36]	; (800c7f8 <SFU_IMG_GetDownloadAreaInfo+0x28>)
{
 800c7d2:	b570      	push	{r4, r5, r6, lr}
  pArea->DownloadAddr = SlotStartAdd[DwlSlot];
 800c7d4:	f852 6020 	ldr.w	r6, [r2, r0, lsl #2]
#if  !defined(SFU_NO_SWAP)
  pArea->MaxSizeInBytes = (uint32_t)SLOT_SIZE(DwlSlot) - SFU_IMG_GetTrailerSize(DwlSlot);
 800c7d8:	4a08      	ldr	r2, [pc, #32]	; (800c7fc <SFU_IMG_GetDownloadAreaInfo+0x2c>)
  pArea->DownloadAddr = SlotStartAdd[DwlSlot];
 800c7da:	604e      	str	r6, [r1, #4]
  pArea->MaxSizeInBytes = (uint32_t)SLOT_SIZE(DwlSlot) - SFU_IMG_GetTrailerSize(DwlSlot);
 800c7dc:	f852 4020 	ldr.w	r4, [r2, r0, lsl #2]
{
 800c7e0:	460d      	mov	r5, r1
  pArea->MaxSizeInBytes = (uint32_t)SLOT_SIZE(DwlSlot) - SFU_IMG_GetTrailerSize(DwlSlot);
 800c7e2:	f7ff fa2f 	bl	800bc44 <SFU_IMG_GetTrailerSize>
 800c7e6:	3401      	adds	r4, #1
 800c7e8:	1ba4      	subs	r4, r4, r6
 800c7ea:	1a24      	subs	r4, r4, r0
#else
  pArea->MaxSizeInBytes = (uint32_t)SLOT_SIZE(DwlSlot);
#endif /* !(SFU_NO_SWAP) */
  pArea->ImageOffsetInBytes = SFU_IMG_IMAGE_OFFSET;
 800c7ec:	f44f 7300 	mov.w	r3, #512	; 0x200
  pArea->MaxSizeInBytes = (uint32_t)SLOT_SIZE(DwlSlot) - SFU_IMG_GetTrailerSize(DwlSlot);
 800c7f0:	602c      	str	r4, [r5, #0]
  pArea->ImageOffsetInBytes = SFU_IMG_IMAGE_OFFSET;
 800c7f2:	60ab      	str	r3, [r5, #8]
}
 800c7f4:	bd70      	pop	{r4, r5, r6, pc}
 800c7f6:	bf00      	nop
 800c7f8:	08010f28 	.word	0x08010f28
 800c7fc:	08010f38 	.word	0x08010f38

0800c800 <SFU_LL_DeInit>:

  /* ADD SRC CODE HERE
       ...
  */
  return e_ret_status;
}
 800c800:	f641 70e1 	movw	r0, #8161	; 0x1fe1
 800c804:	4770      	bx	lr
	...

0800c808 <SFU_LL_CRC_Config>:
  * @param  eCRCConfg: SFU_CRC_ConfigTypeDef.
  *         This parameter can be a value of @ref SFU_CRC_ConfigTypeDef.
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
  */
SFU_ErrorStatus SFU_LL_CRC_Config(SFU_CRC_ConfigTypeDef eCRCConfg)
{
 800c808:	b508      	push	{r3, lr}

  /* Check the parameters */
  assert_param(IS_SFU_CRC_CONF(eCRCConfg));

  /* Switch to the selected configuration */
  CrcHandle.Instance = CRC;
 800c80a:	4b13      	ldr	r3, [pc, #76]	; (800c858 <SFU_LL_CRC_Config+0x50>)
 800c80c:	4a13      	ldr	r2, [pc, #76]	; (800c85c <SFU_LL_CRC_Config+0x54>)
 800c80e:	601a      	str	r2, [r3, #0]
  CrcHandle.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_NONE;

  /* The output data are not inverted */
  CrcHandle.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;

  switch (eCRCConfg)
 800c810:	2801      	cmp	r0, #1
  CrcHandle.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_NONE;
 800c812:	f04f 0200 	mov.w	r2, #0
  CrcHandle.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;
 800c816:	e9c3 2205 	strd	r2, r2, [r3, #20]
  switch (eCRCConfg)
 800c81a:	d004      	beq.n	800c826 <SFU_LL_CRC_Config+0x1e>
 800c81c:	2802      	cmp	r0, #2
 800c81e:	d010      	beq.n	800c842 <SFU_LL_CRC_Config+0x3a>
 800c820:	f641 70e1 	movw	r0, #8161	; 0x1fe1
      e_ret_status = SFU_ERROR;
    }
  }

  return e_ret_status;
}
 800c824:	bd08      	pop	{r3, pc}
      CrcHandle.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_ENABLE;
 800c826:	809a      	strh	r2, [r3, #4]
      CrcHandle.InputDataFormat = CRC_INPUTDATA_FORMAT_WORDS;
 800c828:	2203      	movs	r2, #3
    if (HAL_CRC_Init(&CrcHandle) != HAL_OK)
 800c82a:	480b      	ldr	r0, [pc, #44]	; (800c858 <SFU_LL_CRC_Config+0x50>)
      CrcHandle.InputDataFormat              = CRC_INPUTDATA_FORMAT_BYTES;
 800c82c:	621a      	str	r2, [r3, #32]
    if (HAL_CRC_Init(&CrcHandle) != HAL_OK)
 800c82e:	f000 fe05 	bl	800d43c <HAL_CRC_Init>
      e_ret_status = SFU_ERROR;
 800c832:	4b0b      	ldr	r3, [pc, #44]	; (800c860 <SFU_LL_CRC_Config+0x58>)
 800c834:	f641 72e1 	movw	r2, #8161	; 0x1fe1
 800c838:	2800      	cmp	r0, #0
 800c83a:	bf0c      	ite	eq
 800c83c:	4618      	moveq	r0, r3
 800c83e:	4610      	movne	r0, r2
 800c840:	e7f0      	b.n	800c824 <SFU_LL_CRC_Config+0x1c>
      CrcHandle.Init.CRCLength               = CRC_POLYLENGTH_16B;
 800c842:	2108      	movs	r1, #8
 800c844:	f241 0021 	movw	r0, #4129	; 0x1021
 800c848:	e9c3 0102 	strd	r0, r1, [r3, #8]
      CrcHandle.Init.DefaultPolynomialUse    = DEFAULT_POLYNOMIAL_DISABLE;
 800c84c:	f240 1101 	movw	r1, #257	; 0x101
      CrcHandle.Init.InitValue               = 0U;
 800c850:	611a      	str	r2, [r3, #16]
      CrcHandle.Init.DefaultPolynomialUse    = DEFAULT_POLYNOMIAL_DISABLE;
 800c852:	8099      	strh	r1, [r3, #4]
      CrcHandle.InputDataFormat              = CRC_INPUTDATA_FORMAT_BYTES;
 800c854:	2201      	movs	r2, #1
 800c856:	e7e8      	b.n	800c82a <SFU_LL_CRC_Config+0x22>
 800c858:	20003b88 	.word	0x20003b88
 800c85c:	40023000 	.word	0x40023000
 800c860:	00122f11 	.word	0x00122f11

0800c864 <SFU_LL_CRC_Init>:
  * @retval None
  */
__STATIC_INLINE void LL_AHB1_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->AHB1ENR, Periphs);
 800c864:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
{
 800c868:	b082      	sub	sp, #8
 800c86a:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 800c86c:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 800c870:	649a      	str	r2, [r3, #72]	; 0x48
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 800c872:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800c874:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 800c878:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 800c87a:	9b01      	ldr	r3, [sp, #4]
  e_ret_status = SFU_LL_CRC_Config(SFU_CRC_CONFIG_DEFAULT);
 800c87c:	2001      	movs	r0, #1
}
 800c87e:	b002      	add	sp, #8
  e_ret_status = SFU_LL_CRC_Config(SFU_CRC_CONFIG_DEFAULT);
 800c880:	f7ff bfc2 	b.w	800c808 <SFU_LL_CRC_Config>

0800c884 <SFU_LL_Init>:
  e_ret_status = SFU_LL_CRC_Init();
 800c884:	f7ff bfee 	b.w	800c864 <SFU_LL_CRC_Init>

0800c888 <SFU_LL_CRC_Calculate>:
  * @param  pBuffer: pointer to data buffer.
  * @param  BufferLength: buffer length in bytes.
  * @retval uint32_t CRC (returned value LSBs for CRC shorter than 32 bits)
  */
uint32_t SFU_LL_CRC_Calculate(uint32_t pBuffer[], uint32_t BufferLength)
{
 800c888:	460a      	mov	r2, r1
  return HAL_CRC_Calculate(&CrcHandle, pBuffer, BufferLength);
 800c88a:	4601      	mov	r1, r0
 800c88c:	4801      	ldr	r0, [pc, #4]	; (800c894 <SFU_LL_CRC_Calculate+0xc>)
 800c88e:	f000 be0f 	b.w	800d4b0 <HAL_CRC_Calculate>
 800c892:	bf00      	nop
 800c894:	20003b88 	.word	0x20003b88

0800c898 <SFU_LL_UART_Init>:
  - One Stop Bit
  - No parity
  - Hardware flow control disabled (RTS and CTS signals)
  - Receive and transmit enabled
  */
  UartHandle.Instance = SFU_UART;
 800c898:	480e      	ldr	r0, [pc, #56]	; (800c8d4 <SFU_LL_UART_Init+0x3c>)
  UartHandle.Init.BaudRate = 115200U;
 800c89a:	4a0f      	ldr	r2, [pc, #60]	; (800c8d8 <SFU_LL_UART_Init+0x40>)
{
 800c89c:	b508      	push	{r3, lr}
  UartHandle.Init.BaudRate = 115200U;
 800c89e:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
 800c8a2:	e9c0 2300 	strd	r2, r3, [r0]
  UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
 800c8a6:	2300      	movs	r3, #0
  UartHandle.Init.StopBits = UART_STOPBITS_1;
 800c8a8:	e9c0 3302 	strd	r3, r3, [r0, #8]
  UartHandle.Init.Parity = UART_PARITY_NONE;
 800c8ac:	6103      	str	r3, [r0, #16]
  UartHandle.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 800c8ae:	6183      	str	r3, [r0, #24]
  UartHandle.Init.Mode = UART_MODE_RX | UART_MODE_TX;
 800c8b0:	230c      	movs	r3, #12
 800c8b2:	6143      	str	r3, [r0, #20]
  UartHandle.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_RXOVERRUNDISABLE_INIT;
 800c8b4:	2310      	movs	r3, #16
 800c8b6:	6283      	str	r3, [r0, #40]	; 0x28
  UartHandle.AdvancedInit.OverrunDisable = UART_ADVFEATURE_OVERRUN_DISABLE;
 800c8b8:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800c8bc:	63c3      	str	r3, [r0, #60]	; 0x3c
  if (HAL_UART_Init(&UartHandle) == HAL_OK)
 800c8be:	f002 f99c 	bl	800ebfa <HAL_UART_Init>
    e_ret_status = SFU_SUCCESS;
  }

  return e_ret_status;

}
 800c8c2:	4b06      	ldr	r3, [pc, #24]	; (800c8dc <SFU_LL_UART_Init+0x44>)
 800c8c4:	f641 72e1 	movw	r2, #8161	; 0x1fe1
 800c8c8:	2800      	cmp	r0, #0
 800c8ca:	bf14      	ite	ne
 800c8cc:	4610      	movne	r0, r2
 800c8ce:	4618      	moveq	r0, r3
 800c8d0:	bd08      	pop	{r3, pc}
 800c8d2:	bf00      	nop
 800c8d4:	20003bac 	.word	0x20003bac
 800c8d8:	40004400 	.word	0x40004400
 800c8dc:	00122f11 	.word	0x00122f11

0800c8e0 <SFU_LL_UART_DeInit>:

  e_ret_status = SFU_SUCCESS;

  return e_ret_status;

}
 800c8e0:	4800      	ldr	r0, [pc, #0]	; (800c8e4 <SFU_LL_UART_DeInit+0x4>)
 800c8e2:	4770      	bx	lr
 800c8e4:	00122f11 	.word	0x00122f11

0800c8e8 <SFU_LL_UART_Transmit>:
  * @retval status of the write operation
  *         SFU_ERROR : if the write operation is not performed
  *         SFU_SUCCESS : if the write operation is successfully performed
  */
SFU_ErrorStatus SFU_LL_UART_Transmit(uint8_t *pData, uint16_t DataLength, uint32_t Timeout)
{
 800c8e8:	b510      	push	{r4, lr}
 800c8ea:	4613      	mov	r3, r2
 800c8ec:	460c      	mov	r4, r1
  SFU_ErrorStatus e_ret_status = SFU_ERROR;

  /* Check the pointers allocation */
  if (pData == NULL)
 800c8ee:	4601      	mov	r1, r0
 800c8f0:	b910      	cbnz	r0, 800c8f8 <SFU_LL_UART_Transmit+0x10>
  {
    return SFU_ERROR;
 800c8f2:	f641 70e1 	movw	r0, #8161	; 0x1fe1
  {
    e_ret_status = SFU_SUCCESS;
  }

  return e_ret_status;
}
 800c8f6:	bd10      	pop	{r4, pc}
  if (HAL_UART_Transmit(&UartHandle, (uint8_t *)pData, DataLength, Timeout) == HAL_OK)
 800c8f8:	4803      	ldr	r0, [pc, #12]	; (800c908 <SFU_LL_UART_Transmit+0x20>)
 800c8fa:	4622      	mov	r2, r4
 800c8fc:	f002 f874 	bl	800e9e8 <HAL_UART_Transmit>
 800c900:	2800      	cmp	r0, #0
 800c902:	d1f6      	bne.n	800c8f2 <SFU_LL_UART_Transmit+0xa>
    e_ret_status = SFU_SUCCESS;
 800c904:	4801      	ldr	r0, [pc, #4]	; (800c90c <SFU_LL_UART_Transmit+0x24>)
 800c906:	e7f6      	b.n	800c8f6 <SFU_LL_UART_Transmit+0xe>
 800c908:	20003bac 	.word	0x20003bac
 800c90c:	00122f11 	.word	0x00122f11

0800c910 <SFU_LL_UART_Receive>:
  * @retval status of the read operation
  *         SFU_ERROR : if the read operation is not performed
  *         SFU_SUCCESS : if the read operation is successfully performed
  */
SFU_ErrorStatus SFU_LL_UART_Receive(uint8_t *pData, uint16_t DataLength, uint32_t Timeout)
{
 800c910:	b510      	push	{r4, lr}
 800c912:	4613      	mov	r3, r2
 800c914:	460c      	mov	r4, r1
  SFU_ErrorStatus e_ret_status = SFU_ERROR;

  /* Check the pointers allocation */
  if (pData == NULL)
 800c916:	4601      	mov	r1, r0
 800c918:	b910      	cbnz	r0, 800c920 <SFU_LL_UART_Receive+0x10>
  {
    return SFU_ERROR;
 800c91a:	f641 70e1 	movw	r0, #8161	; 0x1fe1
  {
    e_ret_status = SFU_SUCCESS;
  }

  return e_ret_status;
}
 800c91e:	bd10      	pop	{r4, pc}
  if (HAL_UART_Receive(&UartHandle, (uint8_t *)pData, DataLength, Timeout) == HAL_OK)
 800c920:	4803      	ldr	r0, [pc, #12]	; (800c930 <SFU_LL_UART_Receive+0x20>)
 800c922:	4622      	mov	r2, r4
 800c924:	f002 f8bc 	bl	800eaa0 <HAL_UART_Receive>
 800c928:	2800      	cmp	r0, #0
 800c92a:	d1f6      	bne.n	800c91a <SFU_LL_UART_Receive+0xa>
    e_ret_status = SFU_SUCCESS;
 800c92c:	4801      	ldr	r0, [pc, #4]	; (800c934 <SFU_LL_UART_Receive+0x24>)
 800c92e:	e7f6      	b.n	800c91e <SFU_LL_UART_Receive+0xe>
 800c930:	20003bac 	.word	0x20003bac
 800c934:	00122f11 	.word	0x00122f11

0800c938 <SFU_LL_UART_Flush>:
  * @retval status of the operation.
  */
SFU_ErrorStatus SFU_LL_UART_Flush(void)
{
  /* Clean the input path */
  __HAL_UART_FLUSH_DRREGISTER(&UartHandle);
 800c938:	4b05      	ldr	r3, [pc, #20]	; (800c950 <SFU_LL_UART_Flush+0x18>)

  return SFU_SUCCESS;
}
 800c93a:	4806      	ldr	r0, [pc, #24]	; (800c954 <SFU_LL_UART_Flush+0x1c>)
  __HAL_UART_FLUSH_DRREGISTER(&UartHandle);
 800c93c:	681b      	ldr	r3, [r3, #0]
 800c93e:	699a      	ldr	r2, [r3, #24]
 800c940:	f042 0208 	orr.w	r2, r2, #8
 800c944:	619a      	str	r2, [r3, #24]
 800c946:	699a      	ldr	r2, [r3, #24]
 800c948:	f042 0210 	orr.w	r2, r2, #16
 800c94c:	619a      	str	r2, [r3, #24]
}
 800c94e:	4770      	bx	lr
 800c950:	20003bac 	.word	0x20003bac
 800c954:	00122f11 	.word	0x00122f11

0800c958 <SFU_LL_UART_MspInit>:
  *        This function configures the hardware resources used in SFU application.
  * @param huart: UART handle pointer
  * @retval None
  */
void SFU_LL_UART_MspInit(UART_HandleTypeDef *huart)
{
 800c958:	b5f0      	push	{r4, r5, r6, r7, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if (huart->Instance == SFU_UART)
 800c95a:	6802      	ldr	r2, [r0, #0]
 800c95c:	4b1e      	ldr	r3, [pc, #120]	; (800c9d8 <SFU_LL_UART_MspInit+0x80>)
 800c95e:	429a      	cmp	r2, r3
{
 800c960:	b089      	sub	sp, #36	; 0x24
  if (huart->Instance == SFU_UART)
 800c962:	d136      	bne.n	800c9d2 <SFU_LL_UART_MspInit+0x7a>
  * @retval None
  */
__STATIC_INLINE void LL_APB1_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB1ENR1, Periphs);
 800c964:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
    SFU_UART_TX_GPIO_CLK_ENABLE();
    SFU_UART_RX_GPIO_CLK_ENABLE();

    /*Configure GPIO pins : SFU_UART_TX_Pin  */
    GPIO_InitStruct.Pin = SFU_UART_TX_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800c968:	2702      	movs	r7, #2
 800c96a:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800c96c:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800c970:	659a      	str	r2, [r3, #88]	; 0x58
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB1ENR1, Periphs);
 800c972:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800c974:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
 800c978:	9202      	str	r2, [sp, #8]
  (void)tmpreg;
 800c97a:	9a02      	ldr	r2, [sp, #8]
  SET_BIT(RCC->AHB2ENR, Periphs);
 800c97c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800c97e:	f042 0201 	orr.w	r2, r2, #1
 800c982:	64da      	str	r2, [r3, #76]	; 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 800c984:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800c986:	f002 0201 	and.w	r2, r2, #1
 800c98a:	9201      	str	r2, [sp, #4]
  (void)tmpreg;
 800c98c:	9a01      	ldr	r2, [sp, #4]
  SET_BIT(RCC->AHB2ENR, Periphs);
 800c98e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800c990:	f042 0201 	orr.w	r2, r2, #1
 800c994:	64da      	str	r2, [r3, #76]	; 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 800c996:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800c998:	f003 0301 	and.w	r3, r3, #1
 800c99c:	9300      	str	r3, [sp, #0]
  (void)tmpreg;
 800c99e:	9b00      	ldr	r3, [sp, #0]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800c9a0:	2600      	movs	r6, #0
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800c9a2:	2304      	movs	r3, #4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800c9a4:	2503      	movs	r5, #3
    GPIO_InitStruct.Alternate = SFU_UART_TX_AF;
 800c9a6:	2407      	movs	r4, #7
    HAL_GPIO_Init(SFU_UART_TX_GPIO_PORT, &GPIO_InitStruct);
 800c9a8:	a903      	add	r1, sp, #12
 800c9aa:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800c9ae:	e9cd 3703 	strd	r3, r7, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800c9b2:	e9cd 6505 	strd	r6, r5, [sp, #20]
    GPIO_InitStruct.Alternate = SFU_UART_TX_AF;
 800c9b6:	9407      	str	r4, [sp, #28]
    HAL_GPIO_Init(SFU_UART_TX_GPIO_PORT, &GPIO_InitStruct);
 800c9b8:	f001 f8b4 	bl	800db24 <HAL_GPIO_Init>

    /*Configure GPIO pins : SFU_UART_RX_Pin  */
    GPIO_InitStruct.Pin = SFU_UART_RX_PIN;
 800c9bc:	2308      	movs	r3, #8
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = SFU_UART_RX_AF;
    HAL_GPIO_Init(SFU_UART_RX_GPIO_PORT, &GPIO_InitStruct);
 800c9be:	a903      	add	r1, sp, #12
 800c9c0:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800c9c4:	e9cd 3703 	strd	r3, r7, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800c9c8:	e9cd 6505 	strd	r6, r5, [sp, #20]
    GPIO_InitStruct.Alternate = SFU_UART_RX_AF;
 800c9cc:	9407      	str	r4, [sp, #28]
    HAL_GPIO_Init(SFU_UART_RX_GPIO_PORT, &GPIO_InitStruct);
 800c9ce:	f001 f8a9 	bl	800db24 <HAL_GPIO_Init>

  }

}
 800c9d2:	b009      	add	sp, #36	; 0x24
 800c9d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800c9d6:	bf00      	nop
 800c9d8:	40004400 	.word	0x40004400

0800c9dc <SFU_LL_FLASH_Init>:
  * @brief  Initialize internal and external flash interface (OSPI/QSPI)
  * @param  none
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
  */
SFU_ErrorStatus SFU_LL_FLASH_Init(void)
{
 800c9dc:	b508      	push	{r3, lr}
  SFU_ErrorStatus e_ret_status = SFU_SUCCESS;

  e_ret_status = SFU_LL_FLASH_INT_Init();
 800c9de:	f000 f861 	bl	800caa4 <SFU_LL_FLASH_INT_Init>
  if (e_ret_status == SFU_SUCCESS)
 800c9e2:	4b04      	ldr	r3, [pc, #16]	; (800c9f4 <SFU_LL_FLASH_Init+0x18>)
 800c9e4:	4298      	cmp	r0, r3
 800c9e6:	d103      	bne.n	800c9f0 <SFU_LL_FLASH_Init+0x14>
  {
    e_ret_status = SFU_LL_FLASH_EXT_Init();
  }
  return e_ret_status;
}
 800c9e8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    e_ret_status = SFU_LL_FLASH_EXT_Init();
 800c9ec:	f000 b82e 	b.w	800ca4c <SFU_LL_FLASH_EXT_Init>
}
 800c9f0:	bd08      	pop	{r3, pc}
 800c9f2:	bf00      	nop
 800c9f4:	00122f11 	.word	0x00122f11

0800c9f8 <SFU_LL_FLASH_Erase_Size>:
  */
SFU_ErrorStatus SFU_LL_FLASH_Erase_Size(SFU_FLASH_StatusTypeDef *pFlashStatus, uint8_t *pStart, uint32_t Length)
{

  /* Check Flash start address */
  if ((uint32_t) pStart < EXTERNAL_FLASH_ADDRESS)
 800c9f8:	f1b1 4f10 	cmp.w	r1, #2415919104	; 0x90000000
 800c9fc:	d201      	bcs.n	800ca02 <SFU_LL_FLASH_Erase_Size+0xa>
  {
    return SFU_LL_FLASH_INT_Erase_Size(pFlashStatus, pStart, Length);
 800c9fe:	f000 b855 	b.w	800caac <SFU_LL_FLASH_INT_Erase_Size>
  }
  else
  {
    return SFU_LL_FLASH_EXT_Erase_Size(pFlashStatus, pStart, Length);
 800ca02:	f000 b827 	b.w	800ca54 <SFU_LL_FLASH_EXT_Erase_Size>

0800ca06 <SFU_LL_FLASH_Write>:
  */
SFU_ErrorStatus SFU_LL_FLASH_Write(SFU_FLASH_StatusTypeDef *pFlashStatus, uint8_t  *pDestination,
                                   const uint8_t *pSource, uint32_t Length)
{
  /* Check Flash destination address */
  if ((uint32_t) pDestination < EXTERNAL_FLASH_ADDRESS)
 800ca06:	f1b1 4f10 	cmp.w	r1, #2415919104	; 0x90000000
 800ca0a:	d201      	bcs.n	800ca10 <SFU_LL_FLASH_Write+0xa>
  {
    return SFU_LL_FLASH_INT_Write(pFlashStatus, pDestination, pSource, Length);
 800ca0c:	f000 b89a 	b.w	800cb44 <SFU_LL_FLASH_INT_Write>
  }
  else
  {
    return SFU_LL_FLASH_EXT_Write(pFlashStatus, pDestination, pSource, Length);
 800ca10:	f000 b823 	b.w	800ca5a <SFU_LL_FLASH_EXT_Write>

0800ca14 <SFU_LL_FLASH_Read>:
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
  */
SFU_ErrorStatus SFU_LL_FLASH_Read(uint8_t *pDestination, const uint8_t *pSource, uint32_t Length)
{
  /* Check Flash source address */
  if ((uint32_t) pSource < EXTERNAL_FLASH_ADDRESS)
 800ca14:	f1b1 4f10 	cmp.w	r1, #2415919104	; 0x90000000
 800ca18:	d201      	bcs.n	800ca1e <SFU_LL_FLASH_Read+0xa>
  {
    return SFU_LL_FLASH_INT_Read(pDestination, pSource, Length);
 800ca1a:	f000 b907 	b.w	800cc2c <SFU_LL_FLASH_INT_Read>
  }
  else
  {
    return SFU_LL_FLASH_EXT_Read(pDestination, pSource, Length);
 800ca1e:	f000 b81f 	b.w	800ca60 <SFU_LL_FLASH_EXT_Read>

0800ca22 <SFU_LL_FLASH_Compare>:
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
  */
SFU_ErrorStatus SFU_LL_FLASH_Compare(const uint8_t *pFlash, const uint32_t Pattern1, const uint32_t Pattern2, uint32_t Length)
{
  /* Check Flash source address */
  if ((uint32_t) pFlash < EXTERNAL_FLASH_ADDRESS)
 800ca22:	f1b0 4f10 	cmp.w	r0, #2415919104	; 0x90000000
 800ca26:	d201      	bcs.n	800ca2c <SFU_LL_FLASH_Compare+0xa>
  {
    return SFU_LL_FLASH_INT_Compare(pFlash, Pattern1, Pattern2, Length);
 800ca28:	f000 b93a 	b.w	800cca0 <SFU_LL_FLASH_INT_Compare>
  }
  else
  {
    return SFU_LL_FLASH_EXT_Compare(pFlash, Pattern1, Pattern2, Length);
 800ca2c:	f000 b81b 	b.w	800ca66 <SFU_LL_FLASH_EXT_Compare>

0800ca30 <SFU_LL_FLASH_Config_Exe>:
   * Internal flash : nothing to do
   * External flash : configure memory mapped mode
   */

  /* Check Flash address */
  if (SlotStartAdd[SlotNumber] < EXTERNAL_FLASH_ADDRESS)
 800ca30:	4b04      	ldr	r3, [pc, #16]	; (800ca44 <SFU_LL_FLASH_Config_Exe+0x14>)
 800ca32:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 800ca36:	f1b3 4f10 	cmp.w	r3, #2415919104	; 0x90000000
 800ca3a:	d301      	bcc.n	800ca40 <SFU_LL_FLASH_Config_Exe+0x10>
  {
    return SFU_SUCCESS;
  }
  else
  {
    return SFU_LL_FLASH_EXT_Config_Exe(SlotNumber);
 800ca3c:	f000 b816 	b.w	800ca6c <SFU_LL_FLASH_EXT_Config_Exe>
  }
}
 800ca40:	4801      	ldr	r0, [pc, #4]	; (800ca48 <SFU_LL_FLASH_Config_Exe+0x18>)
 800ca42:	4770      	bx	lr
 800ca44:	08010f28 	.word	0x08010f28
 800ca48:	00122f11 	.word	0x00122f11

0800ca4c <SFU_LL_FLASH_EXT_Init>:
       systematically during startup phase */

SFU_ErrorStatus SFU_LL_FLASH_EXT_Init(void)
{
  return SFU_SUCCESS;
}
 800ca4c:	4800      	ldr	r0, [pc, #0]	; (800ca50 <SFU_LL_FLASH_EXT_Init+0x4>)
 800ca4e:	4770      	bx	lr
 800ca50:	00122f11 	.word	0x00122f11

0800ca54 <SFU_LL_FLASH_EXT_Erase_Size>:
{
  UNUSED(pFlashStatus);
  UNUSED(pStart);
  UNUSED(Length);
  return SFU_ERROR;
}
 800ca54:	f641 70e1 	movw	r0, #8161	; 0x1fe1
 800ca58:	4770      	bx	lr

0800ca5a <SFU_LL_FLASH_EXT_Write>:
  UNUSED(pFlashStatus);
  UNUSED(pDestination);
  UNUSED(pSource);
  UNUSED(Length);
  return SFU_ERROR;
}
 800ca5a:	f641 70e1 	movw	r0, #8161	; 0x1fe1
 800ca5e:	4770      	bx	lr

0800ca60 <SFU_LL_FLASH_EXT_Read>:
 800ca60:	f641 70e1 	movw	r0, #8161	; 0x1fe1
 800ca64:	4770      	bx	lr

0800ca66 <SFU_LL_FLASH_EXT_Compare>:
  UNUSED(pFlash);
  UNUSED(Pattern1);
  UNUSED(Pattern2);
  UNUSED(Length);
  return SFU_ERROR;
}
 800ca66:	f641 70e1 	movw	r0, #8161	; 0x1fe1
 800ca6a:	4770      	bx	lr

0800ca6c <SFU_LL_FLASH_EXT_Config_Exe>:
SFU_ErrorStatus SFU_LL_FLASH_EXT_Config_Exe(uint32_t SlotNumber)
{
  UNUSED(SlotNumber);
  return SFU_SUCCESS;
}
 800ca6c:	4800      	ldr	r0, [pc, #0]	; (800ca70 <SFU_LL_FLASH_EXT_Config_Exe+0x4>)
 800ca6e:	4770      	bx	lr
 800ca70:	00122f11 	.word	0x00122f11

0800ca74 <SFU_LL_FLASH_INT_Clear_Error.part.0>:
/**
  * @brief  Clear error flags raised during previous operation
  * @param  None.
  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
  */
static SFU_ErrorStatus SFU_LL_FLASH_INT_Clear_Error(void)
 800ca74:	b508      	push	{r3, lr}
  /* Unlock the Program memory */
  if (HAL_FLASH_Unlock() == HAL_OK)
  {

    /* Clear all FLASH flags */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS);
 800ca76:	4b09      	ldr	r3, [pc, #36]	; (800ca9c <SFU_LL_FLASH_INT_Clear_Error.part.0+0x28>)
 800ca78:	699a      	ldr	r2, [r3, #24]
 800ca7a:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
 800ca7e:	619a      	str	r2, [r3, #24]
 800ca80:	f24c 32fa 	movw	r2, #50170	; 0xc3fa
 800ca84:	611a      	str	r2, [r3, #16]

    /* Unlock the Program memory */
    if (HAL_FLASH_Lock() == HAL_OK)
 800ca86:	f000 fd8f 	bl	800d5a8 <HAL_FLASH_Lock>
    }
  }

  return e_ret_status;

}
 800ca8a:	4b05      	ldr	r3, [pc, #20]	; (800caa0 <SFU_LL_FLASH_INT_Clear_Error.part.0+0x2c>)
 800ca8c:	f641 72e1 	movw	r2, #8161	; 0x1fe1
 800ca90:	2800      	cmp	r0, #0
 800ca92:	bf14      	ite	ne
 800ca94:	4610      	movne	r0, r2
 800ca96:	4618      	moveq	r0, r3
 800ca98:	bd08      	pop	{r3, pc}
 800ca9a:	bf00      	nop
 800ca9c:	58004000 	.word	0x58004000
 800caa0:	00122f11 	.word	0x00122f11

0800caa4 <SFU_LL_FLASH_INT_Init>:
}
 800caa4:	4800      	ldr	r0, [pc, #0]	; (800caa8 <SFU_LL_FLASH_INT_Init+0x4>)
 800caa6:	4770      	bx	lr
 800caa8:	00122f11 	.word	0x00122f11

0800caac <SFU_LL_FLASH_INT_Erase_Size>:
{
 800caac:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
  uint32_t page_error = 0U;
 800cab0:	2300      	movs	r3, #0
{
 800cab2:	460c      	mov	r4, r1
 800cab4:	4615      	mov	r5, r2
  uint32_t page_error = 0U;
 800cab6:	9300      	str	r3, [sp, #0]
  if (pFlashStatus == NULL)
 800cab8:	4607      	mov	r7, r0
 800caba:	b928      	cbnz	r0, 800cac8 <SFU_LL_FLASH_INT_Erase_Size+0x1c>
        e_ret_status = SFU_ERROR;
 800cabc:	f641 76e1 	movw	r6, #8161	; 0x1fe1
}
 800cac0:	4630      	mov	r0, r6
 800cac2:	b004      	add	sp, #16
 800cac4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  *pFlashStatus = SFU_FLASH_SUCCESS;
 800cac8:	2305      	movs	r3, #5
 800caca:	7003      	strb	r3, [r0, #0]
  if (HAL_FLASH_Unlock() == HAL_OK)
 800cacc:	f000 fd5a 	bl	800d584 <HAL_FLASH_Unlock>
 800cad0:	2800      	cmp	r0, #0
 800cad2:	d1f3      	bne.n	800cabc <SFU_LL_FLASH_INT_Erase_Size+0x10>
 800cad4:	f7ff ffce 	bl	800ca74 <SFU_LL_FLASH_INT_Clear_Error.part.0>
  if (e_ret_status == SFU_SUCCESS)
 800cad8:	4b19      	ldr	r3, [pc, #100]	; (800cb40 <SFU_LL_FLASH_INT_Erase_Size+0x94>)
 800cada:	4298      	cmp	r0, r3
 800cadc:	4606      	mov	r6, r0
 800cade:	d1ef      	bne.n	800cac0 <SFU_LL_FLASH_INT_Erase_Size+0x14>
    if (HAL_FLASH_Unlock() == HAL_OK)
 800cae0:	f000 fd50 	bl	800d584 <HAL_FLASH_Unlock>
 800cae4:	bb40      	cbnz	r0, 800cb38 <SFU_LL_FLASH_INT_Erase_Size+0x8c>
  page = (Addr - FLASH_BASE) / FLASH_PAGE_SIZE;
 800cae6:	f105 4278 	add.w	r2, r5, #4160749568	; 0xf8000000
 800caea:	3a01      	subs	r2, #1
 800caec:	f104 4378 	add.w	r3, r4, #4160749568	; 0xf8000000
 800caf0:	4414      	add	r4, r2
 800caf2:	0ae4      	lsrs	r4, r4, #11
      nb_pages = SFU_LL_FLASH_INT_GetPage(start + length - 1U) - first_page + 1U;
 800caf4:	3401      	adds	r4, #1
      p_erase_init.TypeErase   = FLASH_TYPEERASE_PAGES;
 800caf6:	2502      	movs	r5, #2
  page = (Addr - FLASH_BASE) / FLASH_PAGE_SIZE;
 800caf8:	ea4f 28d3 	mov.w	r8, r3, lsr #11
      nb_pages = SFU_LL_FLASH_INT_GetPage(start + length - 1U) - first_page + 1U;
 800cafc:	eba4 24d3 	sub.w	r4, r4, r3, lsr #11
      p_erase_init.TypeErase   = FLASH_TYPEERASE_PAGES;
 800cb00:	9501      	str	r5, [sp, #4]
        chunk_nb_pages = (nb_pages >= NB_PAGE_SECTOR_PER_ERASE) ? NB_PAGE_SECTOR_PER_ERASE : nb_pages;
 800cb02:	2c02      	cmp	r4, #2
 800cb04:	4623      	mov	r3, r4
        if (HAL_FLASHEx_Erase(&p_erase_init, &page_error) != HAL_OK)
 800cb06:	4669      	mov	r1, sp
        chunk_nb_pages = (nb_pages >= NB_PAGE_SECTOR_PER_ERASE) ? NB_PAGE_SECTOR_PER_ERASE : nb_pages;
 800cb08:	bf28      	it	cs
 800cb0a:	2302      	movcs	r3, #2
        if (HAL_FLASHEx_Erase(&p_erase_init, &page_error) != HAL_OK)
 800cb0c:	a801      	add	r0, sp, #4
        p_erase_init.NbPages = chunk_nb_pages;
 800cb0e:	e9cd 8302 	strd	r8, r3, [sp, #8]
        nb_pages -= chunk_nb_pages;
 800cb12:	1ae4      	subs	r4, r4, r3
        first_page += chunk_nb_pages;
 800cb14:	4498      	add	r8, r3
        if (HAL_FLASHEx_Erase(&p_erase_init, &page_error) != HAL_OK)
 800cb16:	f000 ffb7 	bl	800da88 <HAL_FLASHEx_Erase>
 800cb1a:	b110      	cbz	r0, 800cb22 <SFU_LL_FLASH_INT_Erase_Size+0x76>
          *pFlashStatus = SFU_FLASH_ERR_ERASE;
 800cb1c:	703d      	strb	r5, [r7, #0]
          e_ret_status = SFU_ERROR;
 800cb1e:	f641 76e1 	movw	r6, #8161	; 0x1fe1
        SFU_LL_SECU_IWDG_Refresh(); /* calling this function which checks the compiler switch */
 800cb22:	f000 f9ab 	bl	800ce7c <SFU_LL_SECU_IWDG_Refresh>
      } while (nb_pages > 0U);
 800cb26:	2c00      	cmp	r4, #0
 800cb28:	d1eb      	bne.n	800cb02 <SFU_LL_FLASH_INT_Erase_Size+0x56>
      if (HAL_FLASH_Lock() != HAL_OK)
 800cb2a:	f000 fd3d 	bl	800d5a8 <HAL_FLASH_Lock>
 800cb2e:	2800      	cmp	r0, #0
 800cb30:	d0c6      	beq.n	800cac0 <SFU_LL_FLASH_INT_Erase_Size+0x14>
        *pFlashStatus = SFU_FLASH_ERR_HAL;
 800cb32:	2301      	movs	r3, #1
 800cb34:	703b      	strb	r3, [r7, #0]
 800cb36:	e7c1      	b.n	800cabc <SFU_LL_FLASH_INT_Erase_Size+0x10>
      *pFlashStatus = SFU_FLASH_ERR_HAL;
 800cb38:	2301      	movs	r3, #1
 800cb3a:	703b      	strb	r3, [r7, #0]
 800cb3c:	e7c0      	b.n	800cac0 <SFU_LL_FLASH_INT_Erase_Size+0x14>
 800cb3e:	bf00      	nop
 800cb40:	00122f11 	.word	0x00122f11

0800cb44 <SFU_LL_FLASH_INT_Write>:
{
 800cb44:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800cb48:	460c      	mov	r4, r1
 800cb4a:	4617      	mov	r7, r2
 800cb4c:	461e      	mov	r6, r3
  uint32_t destination = (uint32_t)pDestination;
 800cb4e:	4689      	mov	r9, r1
  if ((pFlashStatus == NULL) || (pSource == NULL))
 800cb50:	4605      	mov	r5, r0
 800cb52:	b910      	cbnz	r0, 800cb5a <SFU_LL_FLASH_INT_Write+0x16>
          e_ret_status = SFU_ERROR;
 800cb54:	f641 74e1 	movw	r4, #8161	; 0x1fe1
 800cb58:	e019      	b.n	800cb8e <SFU_LL_FLASH_INT_Write+0x4a>
  if ((pFlashStatus == NULL) || (pSource == NULL))
 800cb5a:	2a00      	cmp	r2, #0
 800cb5c:	d0fa      	beq.n	800cb54 <SFU_LL_FLASH_INT_Write+0x10>
    if ((destination >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
 800cb5e:	4830      	ldr	r0, [pc, #192]	; (800cc20 <SFU_LL_FLASH_INT_Write+0xdc>)
 800cb60:	6840      	ldr	r0, [r0, #4]
 800cb62:	4288      	cmp	r0, r1
 800cb64:	d817      	bhi.n	800cb96 <SFU_LL_FLASH_INT_Write+0x52>
        ((destination + Length) <= (SlotHeaderAdd[SLOT_ACTIVE_1 + i] + SFU_IMG_IMAGE_OFFSET)))
 800cb66:	441c      	add	r4, r3
 800cb68:	f500 7000 	add.w	r0, r0, #512	; 0x200
    if ((destination >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
 800cb6c:	4284      	cmp	r4, r0
 800cb6e:	d812      	bhi.n	800cb96 <SFU_LL_FLASH_INT_Write+0x52>
  if ((inside_header == 1U) && (Length != 0U))
 800cb70:	b18b      	cbz	r3, 800cb96 <SFU_LL_FLASH_INT_Write+0x52>
    SE_ErrorStatus se_ret_status = SE_SFU_IMG_Write(&se_status, (uint8_t *)destination, pSource, Length);
 800cb72:	a801      	add	r0, sp, #4
 800cb74:	f7fb febe 	bl	80088f4 <SE_SFU_IMG_Write>
    if (se_ret_status == SE_SUCCESS)
 800cb78:	4b2a      	ldr	r3, [pc, #168]	; (800cc24 <SFU_LL_FLASH_INT_Write+0xe0>)
      *pFlashStatus = SFU_FLASH_ERROR;
 800cb7a:	4c2b      	ldr	r4, [pc, #172]	; (800cc28 <SFU_LL_FLASH_INT_Write+0xe4>)
 800cb7c:	4298      	cmp	r0, r3
 800cb7e:	bf0c      	ite	eq
 800cb80:	2305      	moveq	r3, #5
 800cb82:	2300      	movne	r3, #0
 800cb84:	f641 70e1 	movw	r0, #8161	; 0x1fe1
 800cb88:	bf18      	it	ne
 800cb8a:	4604      	movne	r4, r0
 800cb8c:	702b      	strb	r3, [r5, #0]
}
 800cb8e:	4620      	mov	r0, r4
 800cb90:	b003      	add	sp, #12
 800cb92:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    *pFlashStatus = SFU_FLASH_ERROR;
 800cb96:	2300      	movs	r3, #0
 800cb98:	702b      	strb	r3, [r5, #0]
  if (HAL_FLASH_Unlock() == HAL_OK)
 800cb9a:	f000 fcf3 	bl	800d584 <HAL_FLASH_Unlock>
 800cb9e:	2800      	cmp	r0, #0
 800cba0:	d1d8      	bne.n	800cb54 <SFU_LL_FLASH_INT_Write+0x10>
 800cba2:	f7ff ff67 	bl	800ca74 <SFU_LL_FLASH_INT_Clear_Error.part.0>
    if (e_ret_status == SFU_SUCCESS)
 800cba6:	4b20      	ldr	r3, [pc, #128]	; (800cc28 <SFU_LL_FLASH_INT_Write+0xe4>)
 800cba8:	4298      	cmp	r0, r3
 800cbaa:	4604      	mov	r4, r0
 800cbac:	d1ef      	bne.n	800cb8e <SFU_LL_FLASH_INT_Write+0x4a>
      if (HAL_FLASH_Unlock() != HAL_OK)
 800cbae:	f000 fce9 	bl	800d584 <HAL_FLASH_Unlock>
 800cbb2:	b968      	cbnz	r0, 800cbd0 <SFU_LL_FLASH_INT_Write+0x8c>
  uint32_t source = (uint32_t)pSource;
 800cbb4:	46b8      	mov	r8, r7
        for (i = 0U; (i < Length) && (e_ret_status == SFU_SUCCESS);  i += sizeof(SFU_LL_FLASH_write_t))
 800cbb6:	46a2      	mov	sl, r4
          *pFlashStatus = SFU_FLASH_ERROR;
 800cbb8:	4683      	mov	fp, r0
        for (i = 0U; (i < Length) && (e_ret_status == SFU_SUCCESS);  i += sizeof(SFU_LL_FLASH_write_t))
 800cbba:	eba8 0307 	sub.w	r3, r8, r7
 800cbbe:	42b3      	cmp	r3, r6
 800cbc0:	d30e      	bcc.n	800cbe0 <SFU_LL_FLASH_INT_Write+0x9c>
        if (HAL_FLASH_Lock() != HAL_OK)
 800cbc2:	f000 fcf1 	bl	800d5a8 <HAL_FLASH_Lock>
 800cbc6:	2800      	cmp	r0, #0
 800cbc8:	d0e1      	beq.n	800cb8e <SFU_LL_FLASH_INT_Write+0x4a>
          *pFlashStatus = SFU_FLASH_ERR_HAL;
 800cbca:	2301      	movs	r3, #1
 800cbcc:	702b      	strb	r3, [r5, #0]
 800cbce:	e7c1      	b.n	800cb54 <SFU_LL_FLASH_INT_Write+0x10>
        *pFlashStatus = SFU_FLASH_ERR_HAL;
 800cbd0:	2301      	movs	r3, #1
 800cbd2:	702b      	strb	r3, [r5, #0]
 800cbd4:	e7db      	b.n	800cb8e <SFU_LL_FLASH_INT_Write+0x4a>
            *pFlashStatus = SFU_FLASH_ERR_WRITING;
 800cbd6:	2303      	movs	r3, #3
 800cbd8:	702b      	strb	r3, [r5, #0]
            e_ret_status = SFU_ERROR;
 800cbda:	f641 74e1 	movw	r4, #8161	; 0x1fe1
 800cbde:	e01b      	b.n	800cc18 <SFU_LL_FLASH_INT_Write+0xd4>
        for (i = 0U; (i < Length) && (e_ret_status == SFU_SUCCESS);  i += sizeof(SFU_LL_FLASH_write_t))
 800cbe0:	4554      	cmp	r4, sl
 800cbe2:	d1ee      	bne.n	800cbc2 <SFU_LL_FLASH_INT_Write+0x7e>
          *pFlashStatus = SFU_FLASH_ERROR;
 800cbe4:	f885 b000 	strb.w	fp, [r5]
          if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, destination, *((uint64_t *)(source + i)))
 800cbe8:	e9d8 2300 	ldrd	r2, r3, [r8]
 800cbec:	4649      	mov	r1, r9
 800cbee:	2001      	movs	r0, #1
 800cbf0:	f000 fd40 	bl	800d674 <HAL_FLASH_Program>
 800cbf4:	2800      	cmp	r0, #0
 800cbf6:	d1ee      	bne.n	800cbd6 <SFU_LL_FLASH_INT_Write+0x92>
            if (*(uint64_t *)destination != *(uint64_t *)(source + i))
 800cbf8:	e9d8 2300 	ldrd	r2, r3, [r8]
 800cbfc:	e9d9 0100 	ldrd	r0, r1, [r9]
 800cc00:	4299      	cmp	r1, r3
 800cc02:	bf0b      	itete	eq
 800cc04:	4290      	cmpeq	r0, r2
              *pFlashStatus = SFU_FLASH_ERR_WRITINGCTRL;
 800cc06:	2304      	movne	r3, #4
              *pFlashStatus = SFU_FLASH_SUCCESS;
 800cc08:	2305      	moveq	r3, #5
              *pFlashStatus = SFU_FLASH_ERR_WRITINGCTRL;
 800cc0a:	702b      	strbne	r3, [r5, #0]
              e_ret_status = SFU_ERROR;
 800cc0c:	bf12      	itee	ne
 800cc0e:	f641 74e1 	movwne	r4, #8161	; 0x1fe1
              destination = destination + sizeof(SFU_LL_FLASH_write_t);
 800cc12:	f109 0908 	addeq.w	r9, r9, #8
              *pFlashStatus = SFU_FLASH_SUCCESS;
 800cc16:	702b      	strbeq	r3, [r5, #0]
        for (i = 0U; (i < Length) && (e_ret_status == SFU_SUCCESS);  i += sizeof(SFU_LL_FLASH_write_t))
 800cc18:	f108 0808 	add.w	r8, r8, #8
 800cc1c:	e7cd      	b.n	800cbba <SFU_LL_FLASH_INT_Write+0x76>
 800cc1e:	bf00      	nop
 800cc20:	08010f48 	.word	0x08010f48
 800cc24:	0012310f 	.word	0x0012310f
 800cc28:	00122f11 	.word	0x00122f11

0800cc2c <SFU_LL_FLASH_INT_Read>:
{
 800cc2c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800cc2e:	4613      	mov	r3, r2
    if ((source >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
 800cc30:	4a17      	ldr	r2, [pc, #92]	; (800cc90 <SFU_LL_FLASH_INT_Read+0x64>)
 800cc32:	4c18      	ldr	r4, [pc, #96]	; (800cc94 <SFU_LL_FLASH_INT_Read+0x68>)
 800cc34:	6852      	ldr	r2, [r2, #4]
 800cc36:	428a      	cmp	r2, r1
 800cc38:	d825      	bhi.n	800cc86 <SFU_LL_FLASH_INT_Read+0x5a>
        ((source + Length) <= (SlotHeaderAdd[SLOT_ACTIVE_1 + i] + SFU_IMG_IMAGE_OFFSET)))
 800cc3a:	18cd      	adds	r5, r1, r3
 800cc3c:	f502 7200 	add.w	r2, r2, #512	; 0x200
    if ((source >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
 800cc40:	4295      	cmp	r5, r2
 800cc42:	d820      	bhi.n	800cc86 <SFU_LL_FLASH_INT_Read+0x5a>
    DoubleECC_Error_Counter = 0U;
 800cc44:	2200      	movs	r2, #0
 800cc46:	6022      	str	r2, [r4, #0]
    se_ret_status = SE_SFU_IMG_Read(&se_status, pDestination, (uint8_t *)source, Length);
 800cc48:	460a      	mov	r2, r1
 800cc4a:	4601      	mov	r1, r0
 800cc4c:	a801      	add	r0, sp, #4
 800cc4e:	f7fb fe27 	bl	80088a0 <SE_SFU_IMG_Read>
    if ((se_ret_status == SE_SUCCESS) && (DoubleECC_Error_Counter == 0U))
 800cc52:	4b11      	ldr	r3, [pc, #68]	; (800cc98 <SFU_LL_FLASH_INT_Read+0x6c>)
 800cc54:	4298      	cmp	r0, r3
 800cc56:	d00b      	beq.n	800cc70 <SFU_LL_FLASH_INT_Read+0x44>
  SFU_ErrorStatus e_ret_status = SFU_ERROR;
 800cc58:	f641 70e1 	movw	r0, #8161	; 0x1fe1
 800cc5c:	e00f      	b.n	800cc7e <SFU_LL_FLASH_INT_Read+0x52>
      *pDestination = *pSource;
 800cc5e:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 800cc62:	f800 2b01 	strb.w	r2, [r0], #1
    for (i = 0; (i < Length) && (DoubleECC_Error_Counter == 0U); i++, pDestination++, pSource++)
 800cc66:	4298      	cmp	r0, r3
 800cc68:	d002      	beq.n	800cc70 <SFU_LL_FLASH_INT_Read+0x44>
 800cc6a:	6822      	ldr	r2, [r4, #0]
 800cc6c:	2a00      	cmp	r2, #0
 800cc6e:	d0f6      	beq.n	800cc5e <SFU_LL_FLASH_INT_Read+0x32>
    if ((se_ret_status == SE_SUCCESS) && (DoubleECC_Error_Counter == 0U))
 800cc70:	6822      	ldr	r2, [r4, #0]
      e_ret_status = SFU_SUCCESS;
 800cc72:	4b0a      	ldr	r3, [pc, #40]	; (800cc9c <SFU_LL_FLASH_INT_Read+0x70>)
 800cc74:	f641 70e1 	movw	r0, #8161	; 0x1fe1
 800cc78:	2a00      	cmp	r2, #0
 800cc7a:	bf08      	it	eq
 800cc7c:	4618      	moveq	r0, r3
    DoubleECC_Error_Counter = 0U;
 800cc7e:	2300      	movs	r3, #0
 800cc80:	6023      	str	r3, [r4, #0]
}
 800cc82:	b003      	add	sp, #12
 800cc84:	bd30      	pop	{r4, r5, pc}
    DoubleECC_Error_Counter = 0U;
 800cc86:	2200      	movs	r2, #0
 800cc88:	6022      	str	r2, [r4, #0]
    for (i = 0; (i < Length) && (DoubleECC_Error_Counter == 0U); i++, pDestination++, pSource++)
 800cc8a:	3901      	subs	r1, #1
 800cc8c:	4403      	add	r3, r0
 800cc8e:	e7ea      	b.n	800cc66 <SFU_LL_FLASH_INT_Read+0x3a>
 800cc90:	08010f48 	.word	0x08010f48
 800cc94:	20003c3c 	.word	0x20003c3c
 800cc98:	0012310f 	.word	0x0012310f
 800cc9c:	00122f11 	.word	0x00122f11

0800cca0 <SFU_LL_FLASH_INT_Compare>:
{
 800cca0:	b530      	push	{r4, r5, lr}
  for ( i = 0U; i < Length; i += 4U)
 800cca2:	2400      	movs	r4, #0
 800cca4:	429c      	cmp	r4, r3
 800cca6:	d301      	bcc.n	800ccac <SFU_LL_FLASH_INT_Compare+0xc>
  return SFU_SUCCESS;
 800cca8:	4805      	ldr	r0, [pc, #20]	; (800ccc0 <SFU_LL_FLASH_INT_Compare+0x20>)
}
 800ccaa:	bd30      	pop	{r4, r5, pc}
    if ((*(uint32_t *)(flash + i) != Pattern1) &&  (*(uint32_t *)(flash + i) != Pattern2))
 800ccac:	5905      	ldr	r5, [r0, r4]
 800ccae:	428d      	cmp	r5, r1
 800ccb0:	d001      	beq.n	800ccb6 <SFU_LL_FLASH_INT_Compare+0x16>
 800ccb2:	4295      	cmp	r5, r2
 800ccb4:	d101      	bne.n	800ccba <SFU_LL_FLASH_INT_Compare+0x1a>
  for ( i = 0U; i < Length; i += 4U)
 800ccb6:	3404      	adds	r4, #4
 800ccb8:	e7f4      	b.n	800cca4 <SFU_LL_FLASH_INT_Compare+0x4>
      return SFU_ERROR;
 800ccba:	f641 70e1 	movw	r0, #8161	; 0x1fe1
 800ccbe:	e7f4      	b.n	800ccaa <SFU_LL_FLASH_INT_Compare+0xa>
 800ccc0:	00122f11 	.word	0x00122f11

0800ccc4 <NMI_Handler>:
{
  uint32_t *p_sp;
  uint32_t lr;
  uint16_t opcode_msb;

  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_ECCD))
 800ccc4:	4b1c      	ldr	r3, [pc, #112]	; (800cd38 <NMI_Handler+0x74>)
 800ccc6:	699b      	ldr	r3, [r3, #24]
 800ccc8:	2b00      	cmp	r3, #0
 800ccca:	db05      	blt.n	800ccd8 <NMI_Handler+0x14>
{
 800cccc:	b510      	push	{r4, lr}
  }
  else
  {
    while (1 == 1)
    {
      SFU_EXCPT_IrqExceptionHandler(SFU_EXCPT_UNKNOWN);
 800ccce:	2418      	movs	r4, #24
 800ccd0:	4620      	mov	r0, r4
 800ccd2:	f7fd fcd7 	bl	800a684 <SFU_EXCPT_IrqExceptionHandler>
    while (1 == 1)
 800ccd6:	e7fb      	b.n	800ccd0 <NMI_Handler+0xc>
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ECCD);
 800ccd8:	4a17      	ldr	r2, [pc, #92]	; (800cd38 <NMI_Handler+0x74>)
 800ccda:	6993      	ldr	r3, [r2, #24]
 800ccdc:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800cce0:	6193      	str	r3, [r2, #24]
    DoubleECC_Error_Counter++;
 800cce2:	4a16      	ldr	r2, [pc, #88]	; (800cd3c <NMI_Handler+0x78>)
 800cce4:	6813      	ldr	r3, [r2, #0]
 800cce6:	3301      	adds	r3, #1
 800cce8:	6013      	str	r3, [r2, #0]
  __ASM volatile("MOV %0, LR" : "=r"(result));
 800ccea:	4673      	mov	r3, lr
    if (((lr) & (0xFU)) == 0xDU)
 800ccec:	f003 030f 	and.w	r3, r3, #15
 800ccf0:	2b0d      	cmp	r3, #13
 800ccf2:	d016      	beq.n	800cd22 <NMI_Handler+0x5e>
  __ASM volatile ("MRS %0, msp" : "=r" (result) );
 800ccf4:	f3ef 8308 	mrs	r3, MSP
    if ((*(p_sp + 7U) & (1U << xPSR_T_Pos)) != 0U)
 800ccf8:	69da      	ldr	r2, [r3, #28]
 800ccfa:	f012 7f80 	tst.w	r2, #16777216	; 0x1000000
 800ccfe:	d016      	beq.n	800cd2e <NMI_Handler+0x6a>
      opcode_msb = (*(uint16_t *)(*(p_sp + 6) & 0xFFFFFFFEU) & 0xF800U);
 800cd00:	699a      	ldr	r2, [r3, #24]
 800cd02:	f022 0101 	bic.w	r1, r2, #1
 800cd06:	8809      	ldrh	r1, [r1, #0]
      if ((opcode_msb == 0xE800U) || (opcode_msb == 0xF000U) || (opcode_msb == 0xF800U))
 800cd08:	f401 4068 	and.w	r0, r1, #59392	; 0xe800
 800cd0c:	f5b0 4f68 	cmp.w	r0, #59392	; 0xe800
 800cd10:	d00a      	beq.n	800cd28 <NMI_Handler+0x64>
 800cd12:	f401 4178 	and.w	r1, r1, #63488	; 0xf800
 800cd16:	f5b1 4f70 	cmp.w	r1, #61440	; 0xf000
 800cd1a:	d005      	beq.n	800cd28 <NMI_Handler+0x64>
        *(p_sp + 6U) += 2U;
 800cd1c:	3202      	adds	r2, #2
 800cd1e:	619a      	str	r2, [r3, #24]
 800cd20:	4770      	bx	lr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 800cd22:	f3ef 8309 	mrs	r3, PSP
  return(result);
 800cd26:	e7e7      	b.n	800ccf8 <NMI_Handler+0x34>
        *(p_sp + 6U) += 4U;
 800cd28:	3204      	adds	r2, #4
 800cd2a:	619a      	str	r2, [r3, #24]
 800cd2c:	4770      	bx	lr
      *(p_sp + 6U) += 4U;
 800cd2e:	699a      	ldr	r2, [r3, #24]
 800cd30:	3204      	adds	r2, #4
 800cd32:	619a      	str	r2, [r3, #24]
 800cd34:	4770      	bx	lr
 800cd36:	bf00      	nop
 800cd38:	58004000 	.word	0x58004000
 800cd3c:	20003c3c 	.word	0x20003c3c

0800cd40 <HardFault_Handler>:
  * @param  None.
  * @retval None.
  */
void HardFault_Handler(void)
{
  SFU_EXCPT_IrqExceptionHandler(SFU_EXCPT_HARD_FAULT);
 800cd40:	2002      	movs	r0, #2
 800cd42:	f7fd bc9f 	b.w	800a684 <SFU_EXCPT_IrqExceptionHandler>
	...

0800cd48 <SFU_LL_SECU_CheckApplyStaticProtections>:
  *         flash sections in order to maximize the security level for the specific MCU.
  * @retval uint32_t CRC (returned value is the combination of all the applied protections.
  *         If different from SFU_STD_PROTECTION_ALL, 1 or more protections cannot be applied)
  */
SFU_ErrorStatus SFU_LL_SECU_CheckApplyStaticProtections(void)
{
 800cd48:	b510      	push	{r4, lr}
 800cd4a:	b096      	sub	sp, #88	; 0x58
  SFU_ErrorStatus e_ret_status = SFU_SUCCESS;
  uint32_t i_protection_set = 0U;
  uint32_t i_ctrl = 0U;

  /* Unlock the Flash to enable the flash control register access *************/
  (void) HAL_FLASH_Unlock();
 800cd4c:	f000 fc1a 	bl	800d584 <HAL_FLASH_Unlock>

  /* Clear OPTVERR bit set on virgin samples */
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPTVERR);
 800cd50:	4b2c      	ldr	r3, [pc, #176]	; (800ce04 <SFU_LL_SECU_CheckApplyStaticProtections+0xbc>)
 800cd52:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 800cd56:	611a      	str	r2, [r3, #16]

  /* Unlock the Options Bytes *************************************************/
  (void) HAL_FLASH_OB_Unlock();
 800cd58:	f000 fc32 	bl	800d5c0 <HAL_FLASH_OB_Unlock>

  /* Get Option Bytes status for WRP AREA_A  **********/
  flash_option_bytes.WRPArea     = SFU_PROTECT_WRP_AREA_1;
 800cd5c:	2300      	movs	r3, #0
  (void) HAL_FLASHEx_OBGetConfig(&flash_option_bytes);
 800cd5e:	4668      	mov	r0, sp
  flash_option_bytes.WRPArea     = SFU_PROTECT_WRP_AREA_1;
 800cd60:	9301      	str	r3, [sp, #4]
  (void) HAL_FLASHEx_OBGetConfig(&flash_option_bytes);
 800cd62:	f000 fdd7 	bl	800d914 <HAL_FLASHEx_OBGetConfig>

  /* Check/Apply RDP_Level 1. This is the minimum protection allowed */
  /* if RDP_Level 2 is already applied it's not possible to modify the OptionBytes anymore */
  if (flash_option_bytes.RDPLevel == OB_RDP_LEVEL_2)
 800cd66:	9b04      	ldr	r3, [sp, #16]
 800cd68:	2bcc      	cmp	r3, #204	; 0xcc
 800cd6a:	9b06      	ldr	r3, [sp, #24]
 800cd6c:	d11c      	bne.n	800cda8 <SFU_LL_SECU_CheckApplyStaticProtections+0x60>
SFU_ErrorStatus SFU_LL_SECU_CheckFlashConfiguration(FLASH_OBProgramInitTypeDef *psFlashOptionBytes)
{
  SFU_ErrorStatus e_ret_status = SFU_ERROR;

  /* Check/Apply BOOT_LOCK ****************************************************/
  if ((psFlashOptionBytes->UserConfig & FLASH_OPTR_BOOT_LOCK) == OB_BOOT_LOCK_ENABLE)
 800cd6e:	f013 4f80 	tst.w	r3, #1073741824	; 0x40000000
 800cd72:	4c25      	ldr	r4, [pc, #148]	; (800ce08 <SFU_LL_SECU_CheckApplyStaticProtections+0xc0>)
 800cd74:	d105      	bne.n	800cd82 <SFU_LL_SECU_CheckApplyStaticProtections+0x3a>
      TRACE("\r\n= [SBOOT] Flash configuration failed! Product blocked.");
 800cd76:	4825      	ldr	r0, [pc, #148]	; (800ce0c <SFU_LL_SECU_CheckApplyStaticProtections+0xc4>)
 800cd78:	f001 ffbe 	bl	800ecf8 <iprintf>
    e_ret_status = SFU_SUCCESS;
  }
  if (e_ret_status == SFU_SUCCESS)
  {
    /* Execution stopped if flow control failed */
    FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_UBE, FLOW_CTRL_UBE);
 800cd7c:	f7fd fca6 	bl	800a6cc <SFU_EXCPT_Security_Error>
  }
  return e_ret_status;
 800cd80:	e009      	b.n	800cd96 <SFU_LL_SECU_CheckApplyStaticProtections+0x4e>
    FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_UBE, FLOW_CTRL_UBE);
 800cd82:	6822      	ldr	r2, [r4, #0]
 800cd84:	f482 43cf 	eor.w	r3, r2, #26496	; 0x6780
 800cd88:	f083 0307 	eor.w	r3, r3, #7
 800cd8c:	6023      	str	r3, [r4, #0]
 800cd8e:	f245 7376 	movw	r3, #22390	; 0x5776
 800cd92:	429a      	cmp	r2, r3
 800cd94:	d1f2      	bne.n	800cd7c <SFU_LL_SECU_CheckApplyStaticProtections+0x34>
    FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_RDP, FLOW_CTRL_RDP);
 800cd96:	6822      	ldr	r2, [r4, #0]
 800cd98:	f243 03f1 	movw	r3, #12529	; 0x30f1
 800cd9c:	429a      	cmp	r2, r3
 800cd9e:	d001      	beq.n	800cda4 <SFU_LL_SECU_CheckApplyStaticProtections+0x5c>
 800cda0:	f7fd fc94 	bl	800a6cc <SFU_EXCPT_Security_Error>
        (void) HAL_FLASH_OB_Launch();
 800cda4:	4c1a      	ldr	r4, [pc, #104]	; (800ce10 <SFU_LL_SECU_CheckApplyStaticProtections+0xc8>)
 800cda6:	e026      	b.n	800cdf6 <SFU_LL_SECU_CheckApplyStaticProtections+0xae>
  if ((psFlashOptionBytes->UserConfig & FLASH_OPTR_BOOT_LOCK) == OB_BOOT_LOCK_ENABLE)
 800cda8:	005a      	lsls	r2, r3, #1
 800cdaa:	d509      	bpl.n	800cdc0 <SFU_LL_SECU_CheckApplyStaticProtections+0x78>
    FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_UBE, FLOW_CTRL_UBE);
 800cdac:	4916      	ldr	r1, [pc, #88]	; (800ce08 <SFU_LL_SECU_CheckApplyStaticProtections+0xc0>)
 800cdae:	680a      	ldr	r2, [r1, #0]
 800cdb0:	f482 43cf 	eor.w	r3, r2, #26496	; 0x6780
 800cdb4:	f083 0307 	eor.w	r3, r3, #7
 800cdb8:	600b      	str	r3, [r1, #0]
 800cdba:	f245 7376 	movw	r3, #22390	; 0x5776
 800cdbe:	e7ed      	b.n	800cd9c <SFU_LL_SECU_CheckApplyStaticProtections+0x54>
    e_ret_status = SFU_SUCCESS;
  }
  else
  {
#if defined(SECBOOT_OB_DEV_MODE)
    psFlashOptionBytes->OptionType      = OPTIONBYTE_USER;
 800cdc0:	2204      	movs	r2, #4
    psFlashOptionBytes->UserConfig      &= ~OB_BOOT_LOCK_ENABLE;
    psFlashOptionBytes->UserConfig      |= OB_BOOT_LOCK_ENABLE;
 800cdc2:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    if (HAL_FLASHEx_OBProgram(psFlashOptionBytes) == HAL_OK)
 800cdc6:	4668      	mov	r0, sp
    psFlashOptionBytes->OptionType      = OPTIONBYTE_USER;
 800cdc8:	9200      	str	r2, [sp, #0]
    psFlashOptionBytes->UserConfig      |= OB_BOOT_LOCK_ENABLE;
 800cdca:	9306      	str	r3, [sp, #24]
    if (HAL_FLASHEx_OBProgram(psFlashOptionBytes) == HAL_OK)
 800cdcc:	f000 fc8a 	bl	800d6e4 <HAL_FLASHEx_OBProgram>
 800cdd0:	b978      	cbnz	r0, 800cdf2 <SFU_LL_SECU_CheckApplyStaticProtections+0xaa>
    {
      *pbIsProtectionToBeApplied |= 1U;
      e_ret_status = SFU_SUCCESS;
      /* Execution stopped if flow control failed */
      FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_UBE, FLOW_CTRL_UBE);
 800cdd2:	490d      	ldr	r1, [pc, #52]	; (800ce08 <SFU_LL_SECU_CheckApplyStaticProtections+0xc0>)
 800cdd4:	680a      	ldr	r2, [r1, #0]
 800cdd6:	f482 43cf 	eor.w	r3, r2, #26496	; 0x6780
 800cdda:	f083 0307 	eor.w	r3, r3, #7
 800cdde:	600b      	str	r3, [r1, #0]
 800cde0:	f245 7376 	movw	r3, #22390	; 0x5776
 800cde4:	429a      	cmp	r2, r3
 800cde6:	d001      	beq.n	800cdec <SFU_LL_SECU_CheckApplyStaticProtections+0xa4>
 800cde8:	f7fd fc70 	bl	800a6cc <SFU_EXCPT_Security_Error>
        (void) HAL_FLASH_OB_Launch();
 800cdec:	f000 fc0a 	bl	800d604 <HAL_FLASH_OB_Launch>
 800cdf0:	e7d8      	b.n	800cda4 <SFU_LL_SECU_CheckApplyStaticProtections+0x5c>
    e_ret_status = SFU_ERROR;
 800cdf2:	f641 74e1 	movw	r4, #8161	; 0x1fe1
  (void) HAL_FLASH_OB_Lock();
 800cdf6:	f000 fbf7 	bl	800d5e8 <HAL_FLASH_OB_Lock>
  (void) HAL_FLASH_Lock();
 800cdfa:	f000 fbd5 	bl	800d5a8 <HAL_FLASH_Lock>
}
 800cdfe:	4620      	mov	r0, r4
 800ce00:	b016      	add	sp, #88	; 0x58
 800ce02:	bd10      	pop	{r4, pc}
 800ce04:	58004000 	.word	0x58004000
 800ce08:	20003404 	.word	0x20003404
 800ce0c:	0801124d 	.word	0x0801124d
 800ce10:	00122f11 	.word	0x00122f11

0800ce14 <SFU_LL_SECU_CheckApplyRuntimeProtections>:
}
 800ce14:	4800      	ldr	r0, [pc, #0]	; (800ce18 <SFU_LL_SECU_CheckApplyRuntimeProtections+0x4>)
 800ce16:	4770      	bx	lr
 800ce18:	00122f11 	.word	0x00122f11

0800ce1c <SFU_LL_SECU_GetResetSources>:
  if ((__HAL_RCC_GET_FLAG(RCC_FLAG_IWDGRST) != RESET) ||
 800ce1c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800ce20:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 800ce24:	0091      	lsls	r1, r2, #2
 800ce26:	d403      	bmi.n	800ce30 <SFU_LL_SECU_GetResetSources+0x14>
      (__HAL_RCC_GET_FLAG(RCC_FLAG_WWDGRST) != RESET))
 800ce28:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
  if ((__HAL_RCC_GET_FLAG(RCC_FLAG_IWDGRST) != RESET) ||
 800ce2c:	0052      	lsls	r2, r2, #1
 800ce2e:	d502      	bpl.n	800ce36 <SFU_LL_SECU_GetResetSources+0x1a>
    *peResetpSourceId = SFU_RESET_WDG_RESET;
 800ce30:	2301      	movs	r3, #1
    *peResetpSourceId = SFU_RESET_UNKNOWN;
 800ce32:	7003      	strb	r3, [r0, #0]
}
 800ce34:	4770      	bx	lr
  else if (__HAL_RCC_GET_FLAG(RCC_FLAG_LPWRRST) != RESET)
 800ce36:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 800ce3a:	2a00      	cmp	r2, #0
 800ce3c:	da01      	bge.n	800ce42 <SFU_LL_SECU_GetResetSources+0x26>
    *peResetpSourceId = SFU_RESET_LOW_POWER;
 800ce3e:	2302      	movs	r3, #2
 800ce40:	e7f7      	b.n	800ce32 <SFU_LL_SECU_GetResetSources+0x16>
  else if (__HAL_RCC_GET_FLAG(RCC_FLAG_SFTRST) != RESET)
 800ce42:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 800ce46:	00d1      	lsls	r1, r2, #3
 800ce48:	d501      	bpl.n	800ce4e <SFU_LL_SECU_GetResetSources+0x32>
    *peResetpSourceId = SFU_RESET_SW_RESET;
 800ce4a:	2305      	movs	r3, #5
 800ce4c:	e7f1      	b.n	800ce32 <SFU_LL_SECU_GetResetSources+0x16>
  else if (__HAL_RCC_GET_FLAG(RCC_FLAG_OBLRST) != RESET)
 800ce4e:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 800ce52:	0192      	lsls	r2, r2, #6
 800ce54:	d501      	bpl.n	800ce5a <SFU_LL_SECU_GetResetSources+0x3e>
    *peResetpSourceId = SFU_RESET_OB_LOADER;
 800ce56:	2306      	movs	r3, #6
 800ce58:	e7eb      	b.n	800ce32 <SFU_LL_SECU_GetResetSources+0x16>
  else if (__HAL_RCC_GET_FLAG(RCC_FLAG_PINRST) != RESET)
 800ce5a:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800ce5e:	f013 6380 	ands.w	r3, r3, #67108864	; 0x4000000
    *peResetpSourceId = SFU_RESET_HW_RESET;
 800ce62:	bf18      	it	ne
 800ce64:	2303      	movne	r3, #3
 800ce66:	e7e4      	b.n	800ce32 <SFU_LL_SECU_GetResetSources+0x16>

0800ce68 <SFU_LL_SECU_ClearResetSources>:
  * @rmtoll CSR          RMVF          LL_RCC_ClearResetFlags
  * @retval None
  */
__STATIC_INLINE void LL_RCC_ClearResetFlags(void)
{
  SET_BIT(RCC->CSR, RCC_CSR_RMVF);
 800ce68:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800ce6c:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
 800ce70:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 800ce74:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
}
 800ce78:	4770      	bx	lr
	...

0800ce7c <SFU_LL_SECU_IWDG_Refresh>:
}
 800ce7c:	4800      	ldr	r0, [pc, #0]	; (800ce80 <SFU_LL_SECU_IWDG_Refresh+0x4>)
 800ce7e:	4770      	bx	lr
 800ce80:	00122f11 	.word	0x00122f11

0800ce84 <SystemClock_Config>:
  *            Flash Latency(WS)              = 2
  * @param  None
  * @retval None
  */
void SystemClock_Config(void)
{
 800ce84:	b510      	push	{r4, lr}
 800ce86:	b09a      	sub	sp, #104	; 0x68
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_OscInitTypeDef RCC_OscInitStruct;
  /* Activate PLL with HSI as source */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI |  RCC_OSCILLATORTYPE_LSE;
 800ce88:	2306      	movs	r3, #6
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 800ce8a:	f44f 7080 	mov.w	r0, #256	; 0x100
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI |  RCC_OSCILLATORTYPE_LSE;
 800ce8e:	9308      	str	r3, [sp, #32]
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 800ce90:	2381      	movs	r3, #129	; 0x81
 800ce92:	e9cd 300b 	strd	r3, r0, [sp, #44]	; 0x2c
  RCC_OscInitStruct.HSICalibrationValue = 70;
 800ce96:	2346      	movs	r3, #70	; 0x46
 800ce98:	930d      	str	r3, [sp, #52]	; 0x34
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLM = RCC_PLLM_DIV2;
  RCC_OscInitStruct.PLL.PLLN = 20;
 800ce9a:	f04f 0c10 	mov.w	ip, #16
 800ce9e:	2314      	movs	r3, #20
 800cea0:	e9cd c315 	strd	ip, r3, [sp, #84]	; 0x54
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV5;
 800cea4:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
 800cea8:	2402      	movs	r4, #2
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV5;
 800ceaa:	9319      	str	r3, [sp, #100]	; 0x64
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV5;
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV5;
 800ceac:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 800ceb0:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800ceb4:	a808      	add	r0, sp, #32
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800ceb6:	e9cd 4413 	strd	r4, r4, [sp, #76]	; 0x4c
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV5;
 800ceba:	e9cd 2317 	strd	r2, r3, [sp, #92]	; 0x5c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800cebe:	f001 f80b 	bl	800ded8 <HAL_RCC_OscConfig>
 800cec2:	b100      	cbz	r0, 800cec6 <SystemClock_Config+0x42>
  {
    /* Initialization Error */
    while (1);
 800cec4:	e7fe      	b.n	800cec4 <SystemClock_Config+0x40>
     clocks dividers */
  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2\
                                 | RCC_CLOCKTYPE_HCLK2 | RCC_CLOCKTYPE_HCLK3);
  RCC_ClkInitStruct.SYSCLKSource   = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider  = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 800cec6:	e9cd 0003 	strd	r0, r0, [sp, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.AHBCLK2Divider = RCC_SYSCLK_DIV1;
 800ceca:	e9cd 0005 	strd	r0, r0, [sp, #20]
  RCC_ClkInitStruct.SYSCLKSource   = RCC_SYSCLKSOURCE_PLLCLK;
 800cece:	226f      	movs	r2, #111	; 0x6f
 800ced0:	2303      	movs	r3, #3
  RCC_ClkInitStruct.AHBCLK3Divider = RCC_SYSCLK_DIV1;
 800ced2:	9007      	str	r0, [sp, #28]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
 800ced4:	4621      	mov	r1, r4
 800ced6:	a801      	add	r0, sp, #4
  RCC_ClkInitStruct.SYSCLKSource   = RCC_SYSCLKSOURCE_PLLCLK;
 800ced8:	e9cd 2301 	strd	r2, r3, [sp, #4]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
 800cedc:	f001 fa9c 	bl	800e418 <HAL_RCC_ClockConfig>
 800cee0:	b100      	cbz	r0, 800cee4 <SystemClock_Config+0x60>
  {
    /* Initialization Error */
    while (1);
 800cee2:	e7fe      	b.n	800cee2 <SystemClock_Config+0x5e>
  }
}
 800cee4:	b01a      	add	sp, #104	; 0x68
 800cee6:	bd10      	pop	{r4, pc}

0800cee8 <main>:
{
 800cee8:	b508      	push	{r3, lr}
  (void) HAL_Init();
 800ceea:	f000 f9ad 	bl	800d248 <HAL_Init>
  SystemClock_Config();
 800ceee:	f7ff ffc9 	bl	800ce84 <SystemClock_Config>
  (void)SFU_BOOT_RunSecureBootService(); /* no need to take care of the returned value as we reboot in all cases */
 800cef2:	f7fd f833 	bl	8009f5c <SFU_BOOT_RunSecureBootService>
  SFU_BOOT_ForceReboot();
 800cef6:	f7fd f815 	bl	8009f24 <SFU_BOOT_ForceReboot>
}
 800cefa:	2000      	movs	r0, #0
 800cefc:	bd08      	pop	{r3, pc}

0800cefe <HAL_MspInit>:
/* Functions Definition ------------------------------------------------------*/
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 800cefe:	b508      	push	{r3, lr}

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800cf00:	2003      	movs	r0, #3
 800cf02:	f000 f9e5 	bl	800d2d0 <HAL_NVIC_SetPriorityGrouping>

  /* System interrupt init*/
  /* MemoryManagement_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0U, 0U);
 800cf06:	2200      	movs	r2, #0
 800cf08:	4611      	mov	r1, r2
 800cf0a:	f06f 000b 	mvn.w	r0, #11
 800cf0e:	f000 f9f1 	bl	800d2f4 <HAL_NVIC_SetPriority>
  /* BusFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BusFault_IRQn, 0U, 0U);
 800cf12:	2200      	movs	r2, #0
 800cf14:	4611      	mov	r1, r2
 800cf16:	f06f 000a 	mvn.w	r0, #10
 800cf1a:	f000 f9eb 	bl	800d2f4 <HAL_NVIC_SetPriority>
  /* UsageFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(UsageFault_IRQn, 0U, 0U);
 800cf1e:	2200      	movs	r2, #0
 800cf20:	4611      	mov	r1, r2
 800cf22:	f06f 0009 	mvn.w	r0, #9
 800cf26:	f000 f9e5 	bl	800d2f4 <HAL_NVIC_SetPriority>
  /* DebugMonitor_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0U, 0U);
 800cf2a:	2200      	movs	r2, #0
 800cf2c:	4611      	mov	r1, r2
 800cf2e:	f06f 0003 	mvn.w	r0, #3
 800cf32:	f000 f9df 	bl	800d2f4 <HAL_NVIC_SetPriority>
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0U, 0U);
 800cf36:	2200      	movs	r2, #0

}
 800cf38:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_NVIC_SetPriority(SysTick_IRQn, 0U, 0U);
 800cf3c:	4611      	mov	r1, r2
 800cf3e:	f04f 30ff 	mov.w	r0, #4294967295
 800cf42:	f000 b9d7 	b.w	800d2f4 <HAL_NVIC_SetPriority>

0800cf46 <HAL_UART_MspInit>:
  * @param huart: UART handle pointer
  * @retval None
  */
void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
  SFU_LL_UART_MspInit(huart);
 800cf46:	f7ff bd07 	b.w	800c958 <SFU_LL_UART_MspInit>
	...

0800cf4c <__NVIC_SystemReset>:
  __ASM volatile ("dsb 0xF":::"memory");
 800cf4c:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800cf50:	4905      	ldr	r1, [pc, #20]	; (800cf68 <__NVIC_SystemReset+0x1c>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800cf52:	4b06      	ldr	r3, [pc, #24]	; (800cf6c <__NVIC_SystemReset+0x20>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800cf54:	68ca      	ldr	r2, [r1, #12]
 800cf56:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800cf5a:	4313      	orrs	r3, r2
 800cf5c:	60cb      	str	r3, [r1, #12]
 800cf5e:	f3bf 8f4f 	dsb	sy
    __NOP();
 800cf62:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 800cf64:	e7fd      	b.n	800cf62 <__NVIC_SystemReset+0x16>
 800cf66:	bf00      	nop
 800cf68:	e000ed00 	.word	0xe000ed00
 800cf6c:	05fa0004 	.word	0x05fa0004

0800cf70 <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
 800cf70:	b508      	push	{r3, lr}
  /* Go to infinite loop when Bus Fault exception occurs */
  while (1)
  {
    NVIC_SystemReset();
 800cf72:	f7ff ffeb 	bl	800cf4c <__NVIC_SystemReset>

0800cf76 <UsageFault_Handler>:
 800cf76:	b508      	push	{r3, lr}
 800cf78:	f7ff ffe8 	bl	800cf4c <__NVIC_SystemReset>

0800cf7c <SVC_Handler>:
  * @param  None
  * @retval None
  */
void SVC_Handler(void)
{
}
 800cf7c:	4770      	bx	lr

0800cf7e <DebugMon_Handler>:
 800cf7e:	4770      	bx	lr

0800cf80 <PendSV_Handler>:
 800cf80:	4770      	bx	lr

0800cf82 <SysTick_Handler>:
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
  HAL_IncTick();
 800cf82:	f000 b977 	b.w	800d274 <HAL_IncTick>

0800cf86 <_read>:
	_kill(status, -1);
	while (1) {}		/* Make sure we hang here */
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 800cf86:	b570      	push	{r4, r5, r6, lr}
 800cf88:	460e      	mov	r6, r1
 800cf8a:	4614      	mov	r4, r2
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800cf8c:	2500      	movs	r5, #0
 800cf8e:	42a5      	cmp	r5, r4
 800cf90:	db01      	blt.n	800cf96 <_read+0x10>
	{
		*ptr++ = __io_getchar();
	}

return len;
}
 800cf92:	4620      	mov	r0, r4
 800cf94:	bd70      	pop	{r4, r5, r6, pc}
		*ptr++ = __io_getchar();
 800cf96:	f3af 8000 	nop.w
 800cf9a:	5570      	strb	r0, [r6, r5]
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800cf9c:	3501      	adds	r5, #1
 800cf9e:	e7f6      	b.n	800cf8e <_read+0x8>

0800cfa0 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 800cfa0:	b570      	push	{r4, r5, r6, lr}
 800cfa2:	460e      	mov	r6, r1
 800cfa4:	4614      	mov	r4, r2
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800cfa6:	2500      	movs	r5, #0
 800cfa8:	42a5      	cmp	r5, r4
 800cfaa:	db01      	blt.n	800cfb0 <_write+0x10>
	{
		__io_putchar(*ptr++);
	}
	return len;
}
 800cfac:	4620      	mov	r0, r4
 800cfae:	bd70      	pop	{r4, r5, r6, pc}
		__io_putchar(*ptr++);
 800cfb0:	5d70      	ldrb	r0, [r6, r5]
 800cfb2:	f7fd fb4c 	bl	800a64e <__io_putchar>
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800cfb6:	3501      	adds	r5, #1
 800cfb8:	e7f6      	b.n	800cfa8 <_write+0x8>

0800cfba <_close>:

int _close(int file)
{
	return -1;
}
 800cfba:	f04f 30ff 	mov.w	r0, #4294967295
 800cfbe:	4770      	bx	lr

0800cfc0 <_fstat>:


int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
 800cfc0:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800cfc4:	604b      	str	r3, [r1, #4]
	return 0;
}
 800cfc6:	2000      	movs	r0, #0
 800cfc8:	4770      	bx	lr

0800cfca <_isatty>:

int _isatty(int file)
{
	return 1;
}
 800cfca:	2001      	movs	r0, #1
 800cfcc:	4770      	bx	lr

0800cfce <_lseek>:

int _lseek(int file, int ptr, int dir)
{
	return 0;
}
 800cfce:	2000      	movs	r0, #0
 800cfd0:	4770      	bx	lr
	...

0800cfd4 <_sbrk>:
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
  const uint8_t *max_heap = (uint8_t *)stack_limit;
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 800cfd4:	4b0b      	ldr	r3, [pc, #44]	; (800d004 <_sbrk+0x30>)
 800cfd6:	6819      	ldr	r1, [r3, #0]
{
 800cfd8:	b510      	push	{r4, lr}
 800cfda:	4602      	mov	r2, r0
  if (NULL == __sbrk_heap_end)
 800cfdc:	b909      	cbnz	r1, 800cfe2 <_sbrk+0xe>
  {
    __sbrk_heap_end = &_end;
 800cfde:	490a      	ldr	r1, [pc, #40]	; (800d008 <_sbrk+0x34>)
 800cfe0:	6019      	str	r1, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 800cfe2:	6818      	ldr	r0, [r3, #0]
 800cfe4:	4909      	ldr	r1, [pc, #36]	; (800d00c <_sbrk+0x38>)
 800cfe6:	4c0a      	ldr	r4, [pc, #40]	; (800d010 <_sbrk+0x3c>)
 800cfe8:	4402      	add	r2, r0
 800cfea:	1b09      	subs	r1, r1, r4
 800cfec:	428a      	cmp	r2, r1
 800cfee:	d906      	bls.n	800cffe <_sbrk+0x2a>
  {
    errno = ENOMEM;
 800cff0:	f001 fe34 	bl	800ec5c <__errno>
 800cff4:	230c      	movs	r3, #12
 800cff6:	6003      	str	r3, [r0, #0]
    return (void *)-1;
 800cff8:	f04f 30ff 	mov.w	r0, #4294967295

  prev_heap_end = __sbrk_heap_end;
  __sbrk_heap_end += incr;

  return (void *)prev_heap_end;
}
 800cffc:	bd10      	pop	{r4, pc}
  __sbrk_heap_end += incr;
 800cffe:	601a      	str	r2, [r3, #0]
  return (void *)prev_heap_end;
 800d000:	e7fc      	b.n	800cffc <_sbrk+0x28>
 800d002:	bf00      	nop
 800d004:	20003c40 	.word	0x20003c40
 800d008:	20003f30 	.word	0x20003f30
 800d00c:	20008000 	.word	0x20008000
 800d010:	00002000 	.word	0x00002000

0800d014 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 800d014:	480d      	ldr	r0, [pc, #52]	; (800d04c <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 800d016:	4685      	mov	sp, r0

/* Call the clock system initialization function.*/
  bl  SystemInit
 800d018:	f000 f8ee 	bl	800d1f8 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 800d01c:	480c      	ldr	r0, [pc, #48]	; (800d050 <LoopForever+0x6>)
  ldr r1, =_edata
 800d01e:	490d      	ldr	r1, [pc, #52]	; (800d054 <LoopForever+0xa>)
  ldr r2, =_sidata
 800d020:	4a0d      	ldr	r2, [pc, #52]	; (800d058 <LoopForever+0xe>)
  movs r3, #0
 800d022:	2300      	movs	r3, #0
  b LoopCopyDataInit
 800d024:	e002      	b.n	800d02c <LoopCopyDataInit>

0800d026 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 800d026:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 800d028:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 800d02a:	3304      	adds	r3, #4

0800d02c <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 800d02c:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 800d02e:	428c      	cmp	r4, r1
  bcc CopyDataInit
 800d030:	d3f9      	bcc.n	800d026 <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 800d032:	4a0a      	ldr	r2, [pc, #40]	; (800d05c <LoopForever+0x12>)
  ldr r4, =_ebss
 800d034:	4c0a      	ldr	r4, [pc, #40]	; (800d060 <LoopForever+0x16>)
  movs r3, #0
 800d036:	2300      	movs	r3, #0
  b LoopFillZerobss
 800d038:	e001      	b.n	800d03e <LoopFillZerobss>

0800d03a <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 800d03a:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 800d03c:	3204      	adds	r2, #4

0800d03e <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 800d03e:	42a2      	cmp	r2, r4
  bcc FillZerobss
 800d040:	d3fb      	bcc.n	800d03a <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 800d042:	f001 fe11 	bl	800ec68 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 800d046:	f7ff ff4f 	bl	800cee8 <main>

0800d04a <LoopForever>:

LoopForever:
    b LoopForever
 800d04a:	e7fe      	b.n	800d04a <LoopForever>
  ldr   r0, =_estack
 800d04c:	20008000 	.word	0x20008000
  ldr r0, =_sdata
 800d050:	20003400 	.word	0x20003400
  ldr r1, =_edata
 800d054:	20003480 	.word	0x20003480
  ldr r2, =_sidata
 800d058:	08011450 	.word	0x08011450
  ldr r2, =_sbss
 800d05c:	20003480 	.word	0x20003480
  ldr r4, =_ebss
 800d060:	20003f30 	.word	0x20003f30

0800d064 <ADC_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 800d064:	e7fe      	b.n	800d064 <ADC_IRQHandler>

0800d066 <LL_AHB2_GRP1_EnableClock>:
  SET_BIT(RCC->AHB2ENR, Periphs);
 800d066:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
{
 800d06a:	b082      	sub	sp, #8
  SET_BIT(RCC->AHB2ENR, Periphs);
 800d06c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800d06e:	4302      	orrs	r2, r0
 800d070:	64da      	str	r2, [r3, #76]	; 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 800d072:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800d074:	4018      	ands	r0, r3
 800d076:	9001      	str	r0, [sp, #4]
  (void)tmpreg;
 800d078:	9b01      	ldr	r3, [sp, #4]
}
 800d07a:	b002      	add	sp, #8
 800d07c:	4770      	bx	lr
	...

0800d080 <BSP_LED_Init>:
  *            @arg LED2
  *            @arg LED3
  * @retval BSP status
  */
int32_t BSP_LED_Init(Led_TypeDef Led)
{
 800d080:	b570      	push	{r4, r5, r6, lr}
 800d082:	b086      	sub	sp, #24
  GPIO_InitTypeDef  gpio_init_structure = {0};
 800d084:	2214      	movs	r2, #20
{
 800d086:	4604      	mov	r4, r0
  GPIO_InitTypeDef  gpio_init_structure = {0};
 800d088:	2100      	movs	r1, #0
 800d08a:	a801      	add	r0, sp, #4
 800d08c:	f001 fe2c 	bl	800ece8 <memset>
  
  /* Enable the GPIO_LED Clock */
  LEDx_GPIO_CLK_ENABLE(Led);
 800d090:	2002      	movs	r0, #2
 800d092:	f7ff ffe8 	bl	800d066 <LL_AHB2_GRP1_EnableClock>

  /* Configure the GPIO_LED pin */
  gpio_init_structure.Pin = LED_PIN[Led];
 800d096:	4b0c      	ldr	r3, [pc, #48]	; (800d0c8 <BSP_LED_Init+0x48>)
  gpio_init_structure.Mode = GPIO_MODE_OUTPUT_PP;
  gpio_init_structure.Pull = GPIO_NOPULL;
 800d098:	2500      	movs	r5, #0
  gpio_init_structure.Pin = LED_PIN[Led];
 800d09a:	f833 6014 	ldrh.w	r6, [r3, r4, lsl #1]
 800d09e:	9601      	str	r6, [sp, #4]
  gpio_init_structure.Pull = GPIO_NOPULL;
 800d0a0:	2301      	movs	r3, #1
 800d0a2:	e9cd 3502 	strd	r3, r5, [sp, #8]
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;
 800d0a6:	2302      	movs	r3, #2
 800d0a8:	9304      	str	r3, [sp, #16]
  
  HAL_GPIO_Init(LED_PORT[Led], &gpio_init_structure);
 800d0aa:	4b08      	ldr	r3, [pc, #32]	; (800d0cc <BSP_LED_Init+0x4c>)
 800d0ac:	f853 4024 	ldr.w	r4, [r3, r4, lsl #2]
 800d0b0:	a901      	add	r1, sp, #4
 800d0b2:	4620      	mov	r0, r4
 800d0b4:	f000 fd36 	bl	800db24 <HAL_GPIO_Init>
  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_RESET);
 800d0b8:	4620      	mov	r0, r4
 800d0ba:	462a      	mov	r2, r5
 800d0bc:	4631      	mov	r1, r6
 800d0be:	f000 fde3 	bl	800dc88 <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
}
 800d0c2:	4628      	mov	r0, r5
 800d0c4:	b006      	add	sp, #24
 800d0c6:	bd70      	pop	{r4, r5, r6, pc}
 800d0c8:	0801129c 	.word	0x0801129c
 800d0cc:	080112a4 	.word	0x080112a4

0800d0d0 <BSP_LED_Off>:
  *            @arg LED2
  *            @arg LED3
  * @retval BSP status
  */
int32_t BSP_LED_Off(Led_TypeDef Led)
{
 800d0d0:	b508      	push	{r3, lr}
  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_RESET); 
 800d0d2:	4b05      	ldr	r3, [pc, #20]	; (800d0e8 <BSP_LED_Off+0x18>)
 800d0d4:	f833 1010 	ldrh.w	r1, [r3, r0, lsl #1]
 800d0d8:	4b04      	ldr	r3, [pc, #16]	; (800d0ec <BSP_LED_Off+0x1c>)
 800d0da:	2200      	movs	r2, #0
 800d0dc:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 800d0e0:	f000 fdd2 	bl	800dc88 <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
}
 800d0e4:	2000      	movs	r0, #0
 800d0e6:	bd08      	pop	{r3, pc}
 800d0e8:	0801129c 	.word	0x0801129c
 800d0ec:	080112a4 	.word	0x080112a4

0800d0f0 <BSP_LED_Toggle>:
  *            @arg LED2
  *            @arg LED3
  * @retval BSP status
  */
int32_t BSP_LED_Toggle(Led_TypeDef Led)
{
 800d0f0:	b508      	push	{r3, lr}
  HAL_GPIO_TogglePin(LED_PORT[Led], LED_PIN[Led]);
 800d0f2:	4b05      	ldr	r3, [pc, #20]	; (800d108 <BSP_LED_Toggle+0x18>)
 800d0f4:	f833 1010 	ldrh.w	r1, [r3, r0, lsl #1]
 800d0f8:	4b04      	ldr	r3, [pc, #16]	; (800d10c <BSP_LED_Toggle+0x1c>)
 800d0fa:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 800d0fe:	f000 fdc8 	bl	800dc92 <HAL_GPIO_TogglePin>

  return BSP_ERROR_NONE;
}
 800d102:	2000      	movs	r0, #0
 800d104:	bd08      	pop	{r3, pc}
 800d106:	bf00      	nop
 800d108:	0801129c 	.word	0x0801129c
 800d10c:	080112a4 	.word	0x080112a4

0800d110 <BSP_PB_Init>:
  *     @arg BUTTON_MODE_EXTI: Button will be connected to EXTI line with interrupt
  *                            generation capability  
  * @retval BSP status
  */
int32_t BSP_PB_Init(Button_TypeDef Button, ButtonMode_TypeDef ButtonMode)
{
 800d110:	b530      	push	{r4, r5, lr}
 800d112:	b087      	sub	sp, #28
 800d114:	4604      	mov	r4, r0
 800d116:	460d      	mov	r5, r1
  GPIO_InitTypeDef gpio_init_structure = {0};
 800d118:	2214      	movs	r2, #20
 800d11a:	2100      	movs	r1, #0
 800d11c:	a801      	add	r0, sp, #4
 800d11e:	f001 fde3 	bl	800ece8 <memset>
  static BSP_EXTI_LineCallback button_callback[BUTTONn] = {BUTTON_SW1_EXTI_Callback, BUTTON_SW2_EXTI_Callback, BUTTON_SW3_EXTI_Callback};
  static uint32_t button_interrupt_priority[BUTTONn] = {BSP_BUTTON_SWx_IT_PRIORITY, BSP_BUTTON_SWx_IT_PRIORITY, BSP_BUTTON_SWx_IT_PRIORITY};
  static const uint32_t button_exti_line[BUTTONn] = {BUTTON_SW1_EXTI_LINE, BUTTON_SW2_EXTI_LINE, BUTTON_SW3_EXTI_LINE};

  /* Enable the BUTTON Clock */
  BUTTONx_GPIO_CLK_ENABLE(Button);
 800d122:	2c01      	cmp	r4, #1
 800d124:	d815      	bhi.n	800d152 <BSP_PB_Init+0x42>
 800d126:	2001      	movs	r0, #1
 800d128:	f7ff ff9d 	bl	800d066 <LL_AHB2_GRP1_EnableClock>
  
  gpio_init_structure.Pin = BUTTON_PIN[Button];
 800d12c:	4b1c      	ldr	r3, [pc, #112]	; (800d1a0 <BSP_PB_Init+0x90>)
 800d12e:	f833 3014 	ldrh.w	r3, [r3, r4, lsl #1]
 800d132:	9301      	str	r3, [sp, #4]
  gpio_init_structure.Pull = GPIO_PULLUP;
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;
 800d134:	2201      	movs	r2, #1
 800d136:	2302      	movs	r3, #2
 800d138:	e9cd 2303 	strd	r2, r3, [sp, #12]

  if(ButtonMode == BUTTON_MODE_GPIO)
 800d13c:	4b19      	ldr	r3, [pc, #100]	; (800d1a4 <BSP_PB_Init+0x94>)
 800d13e:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 800d142:	b955      	cbnz	r5, 800d15a <BSP_PB_Init+0x4a>
  {
    /* Configure Button pin as input */
    gpio_init_structure.Mode = GPIO_MODE_INPUT;
    HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
 800d144:	a901      	add	r1, sp, #4
    gpio_init_structure.Mode = GPIO_MODE_INPUT;
 800d146:	9502      	str	r5, [sp, #8]
    HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
 800d148:	f000 fcec 	bl	800db24 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority((BUTTON_IRQn[Button]), button_interrupt_priority[Button], 0x00);
    HAL_NVIC_EnableIRQ((BUTTON_IRQn[Button]));
  }

  return BSP_ERROR_NONE;
}
 800d14c:	2000      	movs	r0, #0
 800d14e:	b007      	add	sp, #28
 800d150:	bd30      	pop	{r4, r5, pc}
  BUTTONx_GPIO_CLK_ENABLE(Button);
 800d152:	2c02      	cmp	r4, #2
 800d154:	d1ea      	bne.n	800d12c <BSP_PB_Init+0x1c>
 800d156:	2004      	movs	r0, #4
 800d158:	e7e6      	b.n	800d128 <BSP_PB_Init+0x18>
    gpio_init_structure.Mode = GPIO_MODE_IT_FALLING;
 800d15a:	f44f 1304 	mov.w	r3, #2162688	; 0x210000
    HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
 800d15e:	a901      	add	r1, sp, #4
    (void)HAL_EXTI_GetHandle(&hpb_exti[Button], button_exti_line[Button]);
 800d160:	4d11      	ldr	r5, [pc, #68]	; (800d1a8 <BSP_PB_Init+0x98>)
    gpio_init_structure.Mode = GPIO_MODE_IT_FALLING;
 800d162:	9302      	str	r3, [sp, #8]
    HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
 800d164:	f000 fcde 	bl	800db24 <HAL_GPIO_Init>
    (void)HAL_EXTI_GetHandle(&hpb_exti[Button], button_exti_line[Button]);
 800d168:	4b10      	ldr	r3, [pc, #64]	; (800d1ac <BSP_PB_Init+0x9c>)
 800d16a:	eb05 05c4 	add.w	r5, r5, r4, lsl #3
 800d16e:	f853 1024 	ldr.w	r1, [r3, r4, lsl #2]
 800d172:	4628      	mov	r0, r5
 800d174:	f000 f9e8 	bl	800d548 <HAL_EXTI_GetHandle>
    (void)HAL_EXTI_RegisterCallback(&hpb_exti[Button],  HAL_EXTI_COMMON_CB_ID, button_callback[Button]);
 800d178:	4b0d      	ldr	r3, [pc, #52]	; (800d1b0 <BSP_PB_Init+0xa0>)
 800d17a:	2100      	movs	r1, #0
 800d17c:	f853 2024 	ldr.w	r2, [r3, r4, lsl #2]
 800d180:	4628      	mov	r0, r5
 800d182:	f000 f9da 	bl	800d53a <HAL_EXTI_RegisterCallback>
    HAL_NVIC_SetPriority((BUTTON_IRQn[Button]), button_interrupt_priority[Button], 0x00);
 800d186:	4b0b      	ldr	r3, [pc, #44]	; (800d1b4 <BSP_PB_Init+0xa4>)
 800d188:	571d      	ldrsb	r5, [r3, r4]
 800d18a:	4b0b      	ldr	r3, [pc, #44]	; (800d1b8 <BSP_PB_Init+0xa8>)
 800d18c:	4628      	mov	r0, r5
 800d18e:	f853 1024 	ldr.w	r1, [r3, r4, lsl #2]
 800d192:	2200      	movs	r2, #0
 800d194:	f000 f8ae 	bl	800d2f4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ((BUTTON_IRQn[Button]));
 800d198:	4628      	mov	r0, r5
 800d19a:	f000 f8dd 	bl	800d358 <HAL_NVIC_EnableIRQ>
 800d19e:	e7d5      	b.n	800d14c <BSP_PB_Init+0x3c>
 800d1a0:	0801128a 	.word	0x0801128a
 800d1a4:	08011290 	.word	0x08011290
 800d1a8:	20003f04 	.word	0x20003f04
 800d1ac:	080112bc 	.word	0x080112bc
 800d1b0:	080112b0 	.word	0x080112b0
 800d1b4:	08011286 	.word	0x08011286
 800d1b8:	080112c8 	.word	0x080112c8

0800d1bc <BSP_PB_GetState>:
  *           @arg BUTTON_SW2
  *           @arg BUTTON_SW3
  * @retval The Button GPIO pin value.
  */
int32_t BSP_PB_GetState(Button_TypeDef Button)
{
 800d1bc:	b508      	push	{r3, lr}
  return (int32_t)HAL_GPIO_ReadPin(BUTTON_PORT[Button], BUTTON_PIN[Button]);
 800d1be:	4b04      	ldr	r3, [pc, #16]	; (800d1d0 <BSP_PB_GetState+0x14>)
 800d1c0:	f833 1010 	ldrh.w	r1, [r3, r0, lsl #1]
 800d1c4:	4b03      	ldr	r3, [pc, #12]	; (800d1d4 <BSP_PB_GetState+0x18>)
 800d1c6:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 800d1ca:	f000 fd57 	bl	800dc7c <HAL_GPIO_ReadPin>
}
 800d1ce:	bd08      	pop	{r3, pc}
 800d1d0:	0801128a 	.word	0x0801128a
 800d1d4:	08011290 	.word	0x08011290

0800d1d8 <BSP_PB_Callback>:
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Button);

  /* This function should be implemented by the user application.
     It is called into this driver when an event on Button is triggered. */
}
 800d1d8:	4770      	bx	lr

0800d1da <BUTTON_SW3_EXTI_Callback>:
/**
  * @brief  Button SW3 EXTI line detection callback.
  * @retval None
  */
static void BUTTON_SW3_EXTI_Callback(void)
{
 800d1da:	b508      	push	{r3, lr}
  BSP_PB_Callback(BUTTON_SW3);
 800d1dc:	2002      	movs	r0, #2
 800d1de:	f7ff fffb 	bl	800d1d8 <BSP_PB_Callback>
}
 800d1e2:	bd08      	pop	{r3, pc}

0800d1e4 <BUTTON_SW2_EXTI_Callback>:
{
 800d1e4:	b508      	push	{r3, lr}
  BSP_PB_Callback(BUTTON_SW2);
 800d1e6:	2001      	movs	r0, #1
 800d1e8:	f7ff fff6 	bl	800d1d8 <BSP_PB_Callback>
}
 800d1ec:	bd08      	pop	{r3, pc}

0800d1ee <BUTTON_SW1_EXTI_Callback>:
{
 800d1ee:	b508      	push	{r3, lr}
  BSP_PB_Callback(BUTTON_SW1);
 800d1f0:	2000      	movs	r0, #0
 800d1f2:	f7ff fff1 	bl	800d1d8 <BSP_PB_Callback>
}
 800d1f6:	bd08      	pop	{r3, pc}

0800d1f8 <SystemInit>:

  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << (10UL*2UL))|(3UL << (11UL*2UL)));  /* set CP10 and CP11 Full Access */
#endif
}
 800d1f8:	4770      	bx	lr
	...

0800d1fc <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 800d1fc:	b538      	push	{r3, r4, r5, lr}
  HAL_StatusTypeDef  status = HAL_OK;

  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if ((uint32_t)uwTickFreq != 0U)
 800d1fe:	4c10      	ldr	r4, [pc, #64]	; (800d240 <HAL_InitTick+0x44>)
 800d200:	7823      	ldrb	r3, [r4, #0]
{
 800d202:	4605      	mov	r5, r0
  if ((uint32_t)uwTickFreq != 0U)
 800d204:	b90b      	cbnz	r3, 800d20a <HAL_InitTick+0xe>
      status = HAL_ERROR;
    }
  }
  else
  {
    status = HAL_ERROR;
 800d206:	2001      	movs	r0, #1
  }

  /* Return function status */
  return status;
}
 800d208:	bd38      	pop	{r3, r4, r5, pc}
    if (HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq() / (1000U / (uint32_t)uwTickFreq)) == 0U)
 800d20a:	f000 fe55 	bl	800deb8 <HAL_RCC_GetHCLKFreq>
 800d20e:	7822      	ldrb	r2, [r4, #0]
 800d210:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800d214:	fbb3 f3f2 	udiv	r3, r3, r2
 800d218:	fbb0 f0f3 	udiv	r0, r0, r3
 800d21c:	f000 f8aa 	bl	800d374 <HAL_SYSTICK_Config>
 800d220:	4604      	mov	r4, r0
 800d222:	2800      	cmp	r0, #0
 800d224:	d1ef      	bne.n	800d206 <HAL_InitTick+0xa>
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 800d226:	2d0f      	cmp	r5, #15
 800d228:	d8ed      	bhi.n	800d206 <HAL_InitTick+0xa>
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 800d22a:	4602      	mov	r2, r0
 800d22c:	4629      	mov	r1, r5
 800d22e:	f04f 30ff 	mov.w	r0, #4294967295
 800d232:	f000 f85f 	bl	800d2f4 <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
 800d236:	4b03      	ldr	r3, [pc, #12]	; (800d244 <HAL_InitTick+0x48>)
 800d238:	4620      	mov	r0, r4
 800d23a:	601d      	str	r5, [r3, #0]
  return status;
 800d23c:	e7e4      	b.n	800d208 <HAL_InitTick+0xc>
 800d23e:	bf00      	nop
 800d240:	20003410 	.word	0x20003410
 800d244:	20003414 	.word	0x20003414

0800d248 <HAL_Init>:
{
 800d248:	b510      	push	{r4, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800d24a:	2003      	movs	r0, #3
 800d24c:	f000 f840 	bl	800d2d0 <HAL_NVIC_SetPriorityGrouping>
  SystemCoreClock = HAL_RCC_GetHCLKFreq();
 800d250:	f000 fe32 	bl	800deb8 <HAL_RCC_GetHCLKFreq>
 800d254:	4b06      	ldr	r3, [pc, #24]	; (800d270 <HAL_Init+0x28>)
 800d256:	6018      	str	r0, [r3, #0]
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 800d258:	200f      	movs	r0, #15
 800d25a:	f7ff ffcf 	bl	800d1fc <HAL_InitTick>
 800d25e:	4604      	mov	r4, r0
 800d260:	b918      	cbnz	r0, 800d26a <HAL_Init+0x22>
    HAL_MspInit();
 800d262:	f7ff fe4c 	bl	800cefe <HAL_MspInit>
}
 800d266:	4620      	mov	r0, r4
 800d268:	bd10      	pop	{r4, pc}
    status = HAL_ERROR;
 800d26a:	2401      	movs	r4, #1
 800d26c:	e7fb      	b.n	800d266 <HAL_Init+0x1e>
 800d26e:	bf00      	nop
 800d270:	2000340c 	.word	0x2000340c

0800d274 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += (uint32_t)uwTickFreq;
 800d274:	4a03      	ldr	r2, [pc, #12]	; (800d284 <HAL_IncTick+0x10>)
 800d276:	4b04      	ldr	r3, [pc, #16]	; (800d288 <HAL_IncTick+0x14>)
 800d278:	6811      	ldr	r1, [r2, #0]
 800d27a:	781b      	ldrb	r3, [r3, #0]
 800d27c:	440b      	add	r3, r1
 800d27e:	6013      	str	r3, [r2, #0]
}
 800d280:	4770      	bx	lr
 800d282:	bf00      	nop
 800d284:	20003f1c 	.word	0x20003f1c
 800d288:	20003410 	.word	0x20003410

0800d28c <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 800d28c:	4b01      	ldr	r3, [pc, #4]	; (800d294 <HAL_GetTick+0x8>)
 800d28e:	6818      	ldr	r0, [r3, #0]
}
 800d290:	4770      	bx	lr
 800d292:	bf00      	nop
 800d294:	20003f1c 	.word	0x20003f1c

0800d298 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 800d298:	b538      	push	{r3, r4, r5, lr}
 800d29a:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 800d29c:	f7ff fff6 	bl	800d28c <HAL_GetTick>
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 800d2a0:	1c63      	adds	r3, r4, #1
  {
    wait += (uint32_t)(uwTickFreq);
 800d2a2:	bf1c      	itt	ne
 800d2a4:	4b05      	ldrne	r3, [pc, #20]	; (800d2bc <HAL_Delay+0x24>)
 800d2a6:	781b      	ldrbne	r3, [r3, #0]
  uint32_t tickstart = HAL_GetTick();
 800d2a8:	4605      	mov	r5, r0
    wait += (uint32_t)(uwTickFreq);
 800d2aa:	bf18      	it	ne
 800d2ac:	18e4      	addne	r4, r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
 800d2ae:	f7ff ffed 	bl	800d28c <HAL_GetTick>
 800d2b2:	1b43      	subs	r3, r0, r5
 800d2b4:	42a3      	cmp	r3, r4
 800d2b6:	d3fa      	bcc.n	800d2ae <HAL_Delay+0x16>
  {
  }
}
 800d2b8:	bd38      	pop	{r3, r4, r5, pc}
 800d2ba:	bf00      	nop
 800d2bc:	20003410 	.word	0x20003410

0800d2c0 <HAL_SuspendTick>:
  * @retval None
  */
__weak void HAL_SuspendTick(void)
{
  /* Disable SysTick Interrupt */
  CLEAR_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
 800d2c0:	4a02      	ldr	r2, [pc, #8]	; (800d2cc <HAL_SuspendTick+0xc>)
 800d2c2:	6813      	ldr	r3, [r2, #0]
 800d2c4:	f023 0302 	bic.w	r3, r3, #2
 800d2c8:	6013      	str	r3, [r2, #0]
}
 800d2ca:	4770      	bx	lr
 800d2cc:	e000e010 	.word	0xe000e010

0800d2d0 <HAL_NVIC_SetPriorityGrouping>:
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800d2d0:	4907      	ldr	r1, [pc, #28]	; (800d2f0 <HAL_NVIC_SetPriorityGrouping+0x20>)
 800d2d2:	68ca      	ldr	r2, [r1, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800d2d4:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800d2d8:	0203      	lsls	r3, r0, #8
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800d2da:	0412      	lsls	r2, r2, #16
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800d2dc:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800d2e0:	0c12      	lsrs	r2, r2, #16
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800d2e2:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 800d2e4:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 800d2e8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  SCB->AIRCR =  reg_value;
 800d2ec:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 800d2ee:	4770      	bx	lr
 800d2f0:	e000ed00 	.word	0xe000ed00

0800d2f4 <HAL_NVIC_SetPriority>:
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800d2f4:	4b16      	ldr	r3, [pc, #88]	; (800d350 <HAL_NVIC_SetPriority+0x5c>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800d2f6:	b530      	push	{r4, r5, lr}
 800d2f8:	68dc      	ldr	r4, [r3, #12]
 800d2fa:	f3c4 2402 	ubfx	r4, r4, #8, #3
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800d2fe:	f1c4 0307 	rsb	r3, r4, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800d302:	1d25      	adds	r5, r4, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800d304:	2b04      	cmp	r3, #4
 800d306:	bf28      	it	cs
 800d308:	2304      	movcs	r3, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800d30a:	2d06      	cmp	r5, #6
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800d30c:	f04f 35ff 	mov.w	r5, #4294967295
 800d310:	fa05 f303 	lsl.w	r3, r5, r3
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800d314:	bf8c      	ite	hi
 800d316:	3c03      	subhi	r4, #3
 800d318:	2400      	movls	r4, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800d31a:	ea21 0303 	bic.w	r3, r1, r3
 800d31e:	40a3      	lsls	r3, r4
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800d320:	fa05 f404 	lsl.w	r4, r5, r4
 800d324:	ea22 0204 	bic.w	r2, r2, r4
  if ((int32_t)(IRQn) >= 0)
 800d328:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800d32a:	ea43 0302 	orr.w	r3, r3, r2
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800d32e:	bfac      	ite	ge
 800d330:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800d334:	4a07      	ldrlt	r2, [pc, #28]	; (800d354 <HAL_NVIC_SetPriority+0x60>)
 800d336:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800d33a:	bfb8      	it	lt
 800d33c:	f000 000f 	andlt.w	r0, r0, #15
 800d340:	b2db      	uxtb	r3, r3
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800d342:	bfaa      	itet	ge
 800d344:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800d348:	5413      	strblt	r3, [r2, r0]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800d34a:	f880 3300 	strbge.w	r3, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 800d34e:	bd30      	pop	{r4, r5, pc}
 800d350:	e000ed00 	.word	0xe000ed00
 800d354:	e000ed14 	.word	0xe000ed14

0800d358 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 800d358:	2800      	cmp	r0, #0
 800d35a:	db08      	blt.n	800d36e <HAL_NVIC_EnableIRQ+0x16>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800d35c:	2301      	movs	r3, #1
 800d35e:	0942      	lsrs	r2, r0, #5
 800d360:	f000 001f 	and.w	r0, r0, #31
 800d364:	fa03 f000 	lsl.w	r0, r3, r0
 800d368:	4b01      	ldr	r3, [pc, #4]	; (800d370 <HAL_NVIC_EnableIRQ+0x18>)
 800d36a:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 800d36e:	4770      	bx	lr
 800d370:	e000e100 	.word	0xe000e100

0800d374 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 800d374:	3801      	subs	r0, #1
 800d376:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 800d37a:	d20a      	bcs.n	800d392 <HAL_SYSTICK_Config+0x1e>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800d37c:	4b06      	ldr	r3, [pc, #24]	; (800d398 <HAL_SYSTICK_Config+0x24>)
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800d37e:	4a07      	ldr	r2, [pc, #28]	; (800d39c <HAL_SYSTICK_Config+0x28>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800d380:	6058      	str	r0, [r3, #4]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800d382:	21f0      	movs	r1, #240	; 0xf0
 800d384:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800d388:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800d38a:	2207      	movs	r2, #7
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800d38c:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800d38e:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 800d390:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 800d392:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
  return SysTick_Config(TicksNumb);
}
 800d394:	4770      	bx	lr
 800d396:	bf00      	nop
 800d398:	e000e010 	.word	0xe000e010
 800d39c:	e000ed00 	.word	0xe000ed00

0800d3a0 <CRC_Handle_8>:
  * @param  pBuffer pointer to the input data buffer
  * @param  BufferLength input data buffer length
  * @retval uint32_t CRC (returned value LSBs for CRC shorter than 32 bits)
  */
static uint32_t CRC_Handle_8(CRC_HandleTypeDef *hcrc, uint8_t pBuffer[], uint32_t BufferLength)
{
 800d3a0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800d3a2:	f022 0703 	bic.w	r7, r2, #3
 800d3a6:	6805      	ldr	r5, [r0, #0]
 800d3a8:	460b      	mov	r3, r1
  __IO uint16_t *pReg;

  /* Processing time optimization: 4 bytes are entered in a row with a single word write,
   * last bytes must be carefully fed to the CRC calculator to ensure a correct type
   * handling by the peripheral */
  for (i = 0U; i < (BufferLength / 4U); i++)
 800d3aa:	0896      	lsrs	r6, r2, #2
 800d3ac:	440f      	add	r7, r1
 800d3ae:	42bb      	cmp	r3, r7
 800d3b0:	d108      	bne.n	800d3c4 <CRC_Handle_8+0x24>
                         ((uint32_t)pBuffer[(4U * i) + 1U] << 16U) | \
                         ((uint32_t)pBuffer[(4U * i) + 2U] << 8U)  | \
                         (uint32_t)pBuffer[(4U * i) + 3U];
  }
  /* last bytes specific handling */
  if ((BufferLength % 4U) != 0U)
 800d3b2:	f012 0203 	ands.w	r2, r2, #3
 800d3b6:	d01e      	beq.n	800d3f6 <CRC_Handle_8+0x56>
  {
    if ((BufferLength % 4U) == 1U)
 800d3b8:	2a01      	cmp	r2, #1
 800d3ba:	d114      	bne.n	800d3e6 <CRC_Handle_8+0x46>
    {
      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[4U * i];         /* Derogation MisraC2012 R.11.5 */
 800d3bc:	f811 3026 	ldrb.w	r3, [r1, r6, lsl #2]
    {
      data = ((uint16_t)(pBuffer[4U * i]) << 8U) | (uint16_t)pBuffer[(4U * i) + 1U];
      pReg = (__IO uint16_t *)(__IO void *)(&hcrc->Instance->DR);                    /* Derogation MisraC2012 R.11.5 */
      *pReg = data;

      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[(4U * i) + 2U];  /* Derogation MisraC2012 R.11.5 */
 800d3c0:	702b      	strb	r3, [r5, #0]
 800d3c2:	e018      	b.n	800d3f6 <CRC_Handle_8+0x56>
                         ((uint32_t)pBuffer[(4U * i) + 1U] << 16U) | \
 800d3c4:	785c      	ldrb	r4, [r3, #1]
    hcrc->Instance->DR = ((uint32_t)pBuffer[4U * i] << 24U) | \
 800d3c6:	f893 c000 	ldrb.w	ip, [r3]
                         ((uint32_t)pBuffer[(4U * i) + 1U] << 16U) | \
 800d3ca:	0424      	lsls	r4, r4, #16
                         ((uint32_t)pBuffer[(4U * i) + 2U] << 8U)  | \
 800d3cc:	ea44 640c 	orr.w	r4, r4, ip, lsl #24
                         (uint32_t)pBuffer[(4U * i) + 3U];
 800d3d0:	f893 c003 	ldrb.w	ip, [r3, #3]
                         ((uint32_t)pBuffer[(4U * i) + 2U] << 8U)  | \
 800d3d4:	ea44 040c 	orr.w	r4, r4, ip
 800d3d8:	f893 c002 	ldrb.w	ip, [r3, #2]
 800d3dc:	ea44 240c 	orr.w	r4, r4, ip, lsl #8
    hcrc->Instance->DR = ((uint32_t)pBuffer[4U * i] << 24U) | \
 800d3e0:	602c      	str	r4, [r5, #0]
  for (i = 0U; i < (BufferLength / 4U); i++)
 800d3e2:	3304      	adds	r3, #4
 800d3e4:	e7e3      	b.n	800d3ae <CRC_Handle_8+0xe>
    if ((BufferLength % 4U) == 2U)
 800d3e6:	2a02      	cmp	r2, #2
 800d3e8:	d108      	bne.n	800d3fc <CRC_Handle_8+0x5c>
      data = ((uint16_t)(pBuffer[4U * i]) << 8U) | (uint16_t)pBuffer[(4U * i) + 1U];
 800d3ea:	f811 2026 	ldrb.w	r2, [r1, r6, lsl #2]
 800d3ee:	785b      	ldrb	r3, [r3, #1]
 800d3f0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
      *pReg = data;
 800d3f4:	802b      	strh	r3, [r5, #0]
    }
  }

  /* Return the CRC computed value */
  return hcrc->Instance->DR;
 800d3f6:	6803      	ldr	r3, [r0, #0]
 800d3f8:	6818      	ldr	r0, [r3, #0]
}
 800d3fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
      data = ((uint16_t)(pBuffer[4U * i]) << 8U) | (uint16_t)pBuffer[(4U * i) + 1U];
 800d3fc:	785a      	ldrb	r2, [r3, #1]
 800d3fe:	f811 1026 	ldrb.w	r1, [r1, r6, lsl #2]
 800d402:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
      *pReg = data;
 800d406:	802a      	strh	r2, [r5, #0]
      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[(4U * i) + 2U];  /* Derogation MisraC2012 R.11.5 */
 800d408:	789b      	ldrb	r3, [r3, #2]
 800d40a:	e7d9      	b.n	800d3c0 <CRC_Handle_8+0x20>

0800d40c <CRC_Handle_16>:
  __IO uint16_t *pReg;

  /* Processing time optimization: 2 HalfWords are entered in a row with a single word write,
   * in case of odd length, last HalfWord must be carefully fed to the CRC calculator to ensure
   * a correct type handling by the peripheral */
  for (i = 0U; i < (BufferLength / 2U); i++)
 800d40c:	6800      	ldr	r0, [r0, #0]
{
 800d40e:	b5f0      	push	{r4, r5, r6, r7, lr}
  for (i = 0U; i < (BufferLength / 2U); i++)
 800d410:	2300      	movs	r3, #0
 800d412:	0855      	lsrs	r5, r2, #1
  {
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
 800d414:	1c8e      	adds	r6, r1, #2
  for (i = 0U; i < (BufferLength / 2U); i++)
 800d416:	429d      	cmp	r5, r3
 800d418:	d106      	bne.n	800d428 <CRC_Handle_16+0x1c>
  }
  if ((BufferLength % 2U) != 0U)
 800d41a:	07d3      	lsls	r3, r2, #31
  {
    pReg = (__IO uint16_t *)(__IO void *)(&hcrc->Instance->DR);                 /* Derogation MisraC2012 R.11.5 */
    *pReg = pBuffer[2U * i];
 800d41c:	bf44      	itt	mi
 800d41e:	f831 3025 	ldrhmi.w	r3, [r1, r5, lsl #2]
 800d422:	8003      	strhmi	r3, [r0, #0]
  }

  /* Return the CRC computed value */
  return hcrc->Instance->DR;
 800d424:	6800      	ldr	r0, [r0, #0]
}
 800d426:	bdf0      	pop	{r4, r5, r6, r7, pc}
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
 800d428:	f831 7023 	ldrh.w	r7, [r1, r3, lsl #2]
 800d42c:	f836 4023 	ldrh.w	r4, [r6, r3, lsl #2]
 800d430:	ea44 4407 	orr.w	r4, r4, r7, lsl #16
 800d434:	6004      	str	r4, [r0, #0]
  for (i = 0U; i < (BufferLength / 2U); i++)
 800d436:	3301      	adds	r3, #1
 800d438:	e7ed      	b.n	800d416 <CRC_Handle_16+0xa>

0800d43a <HAL_CRC_MspInit>:
}
 800d43a:	4770      	bx	lr

0800d43c <HAL_CRC_Init>:
{
 800d43c:	b510      	push	{r4, lr}
  if (hcrc == NULL)
 800d43e:	4604      	mov	r4, r0
 800d440:	b908      	cbnz	r0, 800d446 <HAL_CRC_Init+0xa>
    return HAL_ERROR;
 800d442:	2001      	movs	r0, #1
}
 800d444:	bd10      	pop	{r4, pc}
  if (hcrc->State == HAL_CRC_STATE_RESET)
 800d446:	7f43      	ldrb	r3, [r0, #29]
 800d448:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800d44c:	b913      	cbnz	r3, 800d454 <HAL_CRC_Init+0x18>
    hcrc->Lock = HAL_UNLOCKED;
 800d44e:	7702      	strb	r2, [r0, #28]
    HAL_CRC_MspInit(hcrc);
 800d450:	f7ff fff3 	bl	800d43a <HAL_CRC_MspInit>
  hcrc->State = HAL_CRC_STATE_BUSY;
 800d454:	2302      	movs	r3, #2
 800d456:	7763      	strb	r3, [r4, #29]
  if (hcrc->Init.DefaultPolynomialUse == DEFAULT_POLYNOMIAL_ENABLE)
 800d458:	7923      	ldrb	r3, [r4, #4]
 800d45a:	b9e3      	cbnz	r3, 800d496 <HAL_CRC_Init+0x5a>
    WRITE_REG(hcrc->Instance->POL, DEFAULT_CRC32_POLY);
 800d45c:	6823      	ldr	r3, [r4, #0]
 800d45e:	4a13      	ldr	r2, [pc, #76]	; (800d4ac <HAL_CRC_Init+0x70>)
 800d460:	615a      	str	r2, [r3, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, CRC_POLYLENGTH_32B);
 800d462:	689a      	ldr	r2, [r3, #8]
 800d464:	f022 0218 	bic.w	r2, r2, #24
 800d468:	609a      	str	r2, [r3, #8]
  if (hcrc->Init.DefaultInitValueUse == DEFAULT_INIT_VALUE_ENABLE)
 800d46a:	7962      	ldrb	r2, [r4, #5]
 800d46c:	6823      	ldr	r3, [r4, #0]
 800d46e:	b9d2      	cbnz	r2, 800d4a6 <HAL_CRC_Init+0x6a>
    WRITE_REG(hcrc->Instance->INIT, DEFAULT_CRC_INITVALUE);
 800d470:	f04f 32ff 	mov.w	r2, #4294967295
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 800d474:	611a      	str	r2, [r3, #16]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode);
 800d476:	689a      	ldr	r2, [r3, #8]
 800d478:	6961      	ldr	r1, [r4, #20]
 800d47a:	f022 0260 	bic.w	r2, r2, #96	; 0x60
 800d47e:	430a      	orrs	r2, r1
 800d480:	609a      	str	r2, [r3, #8]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);
 800d482:	689a      	ldr	r2, [r3, #8]
 800d484:	69a1      	ldr	r1, [r4, #24]
 800d486:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800d48a:	430a      	orrs	r2, r1
 800d48c:	609a      	str	r2, [r3, #8]
  hcrc->State = HAL_CRC_STATE_READY;
 800d48e:	2301      	movs	r3, #1
 800d490:	7763      	strb	r3, [r4, #29]
  return HAL_OK;
 800d492:	2000      	movs	r0, #0
 800d494:	e7d6      	b.n	800d444 <HAL_CRC_Init+0x8>
    if (HAL_CRCEx_Polynomial_Set(hcrc, hcrc->Init.GeneratingPolynomial, hcrc->Init.CRCLength) != HAL_OK)
 800d496:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
 800d49a:	4620      	mov	r0, r4
 800d49c:	f000 f82c 	bl	800d4f8 <HAL_CRCEx_Polynomial_Set>
 800d4a0:	2800      	cmp	r0, #0
 800d4a2:	d0e2      	beq.n	800d46a <HAL_CRC_Init+0x2e>
 800d4a4:	e7cd      	b.n	800d442 <HAL_CRC_Init+0x6>
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 800d4a6:	6922      	ldr	r2, [r4, #16]
 800d4a8:	e7e4      	b.n	800d474 <HAL_CRC_Init+0x38>
 800d4aa:	bf00      	nop
 800d4ac:	04c11db7 	.word	0x04c11db7

0800d4b0 <HAL_CRC_Calculate>:
{
 800d4b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  hcrc->State = HAL_CRC_STATE_BUSY;
 800d4b2:	2602      	movs	r6, #2
 800d4b4:	7746      	strb	r6, [r0, #29]
  __HAL_CRC_DR_RESET(hcrc);
 800d4b6:	6806      	ldr	r6, [r0, #0]
 800d4b8:	68b7      	ldr	r7, [r6, #8]
 800d4ba:	f047 0701 	orr.w	r7, r7, #1
 800d4be:	60b7      	str	r7, [r6, #8]
  switch (hcrc->InputDataFormat)
 800d4c0:	6a07      	ldr	r7, [r0, #32]
 800d4c2:	2f02      	cmp	r7, #2
{
 800d4c4:	4604      	mov	r4, r0
  switch (hcrc->InputDataFormat)
 800d4c6:	d014      	beq.n	800d4f2 <HAL_CRC_Calculate+0x42>
 800d4c8:	2f03      	cmp	r7, #3
 800d4ca:	d005      	beq.n	800d4d8 <HAL_CRC_Calculate+0x28>
 800d4cc:	2f01      	cmp	r7, #1
 800d4ce:	d00d      	beq.n	800d4ec <HAL_CRC_Calculate+0x3c>
 800d4d0:	2000      	movs	r0, #0
  hcrc->State = HAL_CRC_STATE_READY;
 800d4d2:	2301      	movs	r3, #1
 800d4d4:	7763      	strb	r3, [r4, #29]
}
 800d4d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800d4d8:	eb01 0582 	add.w	r5, r1, r2, lsl #2
      for (index = 0U; index < BufferLength; index++)
 800d4dc:	42a9      	cmp	r1, r5
 800d4de:	d101      	bne.n	800d4e4 <HAL_CRC_Calculate+0x34>
      temp = hcrc->Instance->DR;
 800d4e0:	6830      	ldr	r0, [r6, #0]
      break;
 800d4e2:	e7f6      	b.n	800d4d2 <HAL_CRC_Calculate+0x22>
        hcrc->Instance->DR = pBuffer[index];
 800d4e4:	f851 3b04 	ldr.w	r3, [r1], #4
 800d4e8:	6033      	str	r3, [r6, #0]
      for (index = 0U; index < BufferLength; index++)
 800d4ea:	e7f7      	b.n	800d4dc <HAL_CRC_Calculate+0x2c>
      temp = CRC_Handle_8(hcrc, (uint8_t *)pBuffer, BufferLength);
 800d4ec:	f7ff ff58 	bl	800d3a0 <CRC_Handle_8>
      break;
 800d4f0:	e7ef      	b.n	800d4d2 <HAL_CRC_Calculate+0x22>
      temp = CRC_Handle_16(hcrc, (uint16_t *)(void *)pBuffer, BufferLength);    /* Derogation MisraC2012 R.11.5 */
 800d4f2:	f7ff ff8b 	bl	800d40c <CRC_Handle_16>
      break;
 800d4f6:	e7ec      	b.n	800d4d2 <HAL_CRC_Calculate+0x22>

0800d4f8 <HAL_CRCEx_Polynomial_Set>:
  *          @arg @ref CRC_POLYLENGTH_16B 16-bit long CRC (generating polynomial of degree 16)
  *          @arg @ref CRC_POLYLENGTH_32B 32-bit long CRC (generating polynomial of degree 32)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CRCEx_Polynomial_Set(CRC_HandleTypeDef *hcrc, uint32_t Pol, uint32_t PolyLength)
{
 800d4f8:	b510      	push	{r4, lr}
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t msb = 31U; /* polynomial degree is 32 at most, so msb is initialized to max value */
 800d4fa:	231f      	movs	r3, #31
   * definition. HAL_ERROR is reported if Pol degree is
   * larger than that indicated by PolyLength.
   * Look for MSB position: msb will contain the degree of
   *  the second to the largest polynomial member. E.g., for
   *  X^7 + X^6 + X^5 + X^2 + 1, msb = 6. */
  while ((msb-- > 0U) && ((Pol & ((uint32_t)(0x1U) << (msb & 0x1FU))) == 0U))
 800d4fc:	3b01      	subs	r3, #1
 800d4fe:	d306      	bcc.n	800d50e <HAL_CRCEx_Polynomial_Set+0x16>
 800d500:	fa21 f403 	lsr.w	r4, r1, r3
 800d504:	07e4      	lsls	r4, r4, #31
 800d506:	d5f9      	bpl.n	800d4fc <HAL_CRCEx_Polynomial_Set+0x4>
  {
  }

  switch (PolyLength)
 800d508:	2a08      	cmp	r2, #8
 800d50a:	d014      	beq.n	800d536 <HAL_CRCEx_Polynomial_Set+0x3e>
 800d50c:	d802      	bhi.n	800d514 <HAL_CRCEx_Polynomial_Set+0x1c>
 800d50e:	b13a      	cbz	r2, 800d520 <HAL_CRCEx_Polynomial_Set+0x28>
      }
      break;
    case CRC_POLYLENGTH_8B:
      if (msb >= HAL_CRC_LENGTH_8B)
      {
        status =   HAL_ERROR;
 800d510:	2001      	movs	r0, #1

    /* set generating polynomial size */
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);
  }
  /* Return function status */
  return status;
 800d512:	e00d      	b.n	800d530 <HAL_CRCEx_Polynomial_Set+0x38>
  switch (PolyLength)
 800d514:	2a10      	cmp	r2, #16
 800d516:	d00c      	beq.n	800d532 <HAL_CRCEx_Polynomial_Set+0x3a>
 800d518:	2a18      	cmp	r2, #24
 800d51a:	d1f9      	bne.n	800d510 <HAL_CRCEx_Polynomial_Set+0x18>
      if (msb >= HAL_CRC_LENGTH_7B)
 800d51c:	2b06      	cmp	r3, #6
      if (msb >= HAL_CRC_LENGTH_16B)
 800d51e:	d8f7      	bhi.n	800d510 <HAL_CRCEx_Polynomial_Set+0x18>
    WRITE_REG(hcrc->Instance->POL, Pol);
 800d520:	6800      	ldr	r0, [r0, #0]
 800d522:	6141      	str	r1, [r0, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);
 800d524:	6883      	ldr	r3, [r0, #8]
 800d526:	f023 0318 	bic.w	r3, r3, #24
 800d52a:	431a      	orrs	r2, r3
 800d52c:	6082      	str	r2, [r0, #8]
 800d52e:	2000      	movs	r0, #0
}
 800d530:	bd10      	pop	{r4, pc}
      if (msb >= HAL_CRC_LENGTH_8B)
 800d532:	2b07      	cmp	r3, #7
 800d534:	e7f3      	b.n	800d51e <HAL_CRCEx_Polynomial_Set+0x26>
      if (msb >= HAL_CRC_LENGTH_16B)
 800d536:	2b0f      	cmp	r3, #15
 800d538:	e7f1      	b.n	800d51e <HAL_CRCEx_Polynomial_Set+0x26>

0800d53a <HAL_EXTI_RegisterCallback>:
  *         This parameter can be one of @arg @ref EXTI_CallbackIDTypeDef values.
  * @param  pPendingCbfn function pointer to be stored as callback.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_RegisterCallback(EXTI_HandleTypeDef *hexti, EXTI_CallbackIDTypeDef CallbackID, void (*pPendingCbfn)(void))
{
 800d53a:	4603      	mov	r3, r0
  HAL_StatusTypeDef status = HAL_OK;

  switch (CallbackID)
 800d53c:	4608      	mov	r0, r1
 800d53e:	b909      	cbnz	r1, 800d544 <HAL_EXTI_RegisterCallback+0xa>
  {
    case  HAL_EXTI_COMMON_CB_ID:
      hexti->PendingCallback = pPendingCbfn;
 800d540:	605a      	str	r2, [r3, #4]
      break;
 800d542:	4770      	bx	lr

    default:
      status = HAL_ERROR;
 800d544:	2001      	movs	r0, #1
      break;
  }

  return status;
}
 800d546:	4770      	bx	lr

0800d548 <HAL_EXTI_GetHandle>:
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(ExtiLine));

  /* Check null pointer */
  if (hexti == NULL)
 800d548:	b110      	cbz	r0, 800d550 <HAL_EXTI_GetHandle+0x8>
    return HAL_ERROR;
  }
  else
  {
    /* Store line number as handle private field */
    hexti->Line = ExtiLine;
 800d54a:	6001      	str	r1, [r0, #0]

    return HAL_OK;
 800d54c:	2000      	movs	r0, #0
 800d54e:	4770      	bx	lr
    return HAL_ERROR;
 800d550:	2001      	movs	r0, #1
  }
}
 800d552:	4770      	bx	lr

0800d554 <FLASH_Program_Fast>:

  /* Set FSTPG bit */
#ifdef CORE_CM0PLUS
  SET_BIT(FLASH->C2CR, FLASH_CR_FSTPG);
#else
  SET_BIT(FLASH->CR, FLASH_CR_FSTPG);
 800d554:	4b0a      	ldr	r3, [pc, #40]	; (800d580 <FLASH_Program_Fast+0x2c>)
 800d556:	695a      	ldr	r2, [r3, #20]
 800d558:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
{
 800d55c:	b530      	push	{r4, r5, lr}
  SET_BIT(FLASH->CR, FLASH_CR_FSTPG);
 800d55e:	615a      	str	r2, [r3, #20]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800d560:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 800d564:	b672      	cpsid	i
}
 800d566:	2200      	movs	r2, #0
  __disable_irq();

  /* Program the double word of the row */
  do
  {
    *dest_addr = *src_addr;
 800d568:	588d      	ldr	r5, [r1, r2]
 800d56a:	5085      	str	r5, [r0, r2]
    dest_addr++;
    src_addr++;
    row_index--;
  }
  while (row_index != 0U);
 800d56c:	3204      	adds	r2, #4
 800d56e:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 800d572:	d1f9      	bne.n	800d568 <FLASH_Program_Fast+0x14>

  /* wait for BSY in order to be sure that flash operation is ended before
     allowing prefetch in flash. Timeout does not return status, as it will
     be anyway done later */
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != 0U)
 800d574:	691a      	ldr	r2, [r3, #16]
 800d576:	03d2      	lsls	r2, r2, #15
 800d578:	d4fc      	bmi.n	800d574 <FLASH_Program_Fast+0x20>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800d57a:	f384 8810 	msr	PRIMASK, r4
  {
  }

  /* Exit critical section: restore previous priority mask */
  __set_PRIMASK(primask_bit);
}
 800d57e:	bd30      	pop	{r4, r5, pc}
 800d580:	58004000 	.word	0x58004000

0800d584 <HAL_FLASH_Unlock>:
  if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0U)
 800d584:	4b06      	ldr	r3, [pc, #24]	; (800d5a0 <HAL_FLASH_Unlock+0x1c>)
 800d586:	695a      	ldr	r2, [r3, #20]
 800d588:	2a00      	cmp	r2, #0
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 800d58a:	bfbf      	itttt	lt
 800d58c:	4a05      	ldrlt	r2, [pc, #20]	; (800d5a4 <HAL_FLASH_Unlock+0x20>)
 800d58e:	609a      	strlt	r2, [r3, #8]
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 800d590:	f102 3288 	addlt.w	r2, r2, #2290649224	; 0x88888888
 800d594:	609a      	strlt	r2, [r3, #8]
    if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0U)
 800d596:	bfba      	itte	lt
 800d598:	6958      	ldrlt	r0, [r3, #20]
  HAL_StatusTypeDef status = HAL_OK;
 800d59a:	0fc0      	lsrlt	r0, r0, #31
 800d59c:	2000      	movge	r0, #0
}
 800d59e:	4770      	bx	lr
 800d5a0:	58004000 	.word	0x58004000
 800d5a4:	45670123 	.word	0x45670123

0800d5a8 <HAL_FLASH_Lock>:
  SET_BIT(FLASH->CR, FLASH_CR_LOCK);
 800d5a8:	4b04      	ldr	r3, [pc, #16]	; (800d5bc <HAL_FLASH_Lock+0x14>)
 800d5aa:	695a      	ldr	r2, [r3, #20]
 800d5ac:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 800d5b0:	615a      	str	r2, [r3, #20]
  if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) == 0U)
 800d5b2:	6958      	ldr	r0, [r3, #20]
}
 800d5b4:	43c0      	mvns	r0, r0
 800d5b6:	0fc0      	lsrs	r0, r0, #31
 800d5b8:	4770      	bx	lr
 800d5ba:	bf00      	nop
 800d5bc:	58004000 	.word	0x58004000

0800d5c0 <HAL_FLASH_OB_Unlock>:
  if (READ_BIT(FLASH->CR, FLASH_CR_OPTLOCK) != 0U)
 800d5c0:	4b07      	ldr	r3, [pc, #28]	; (800d5e0 <HAL_FLASH_OB_Unlock+0x20>)
 800d5c2:	695a      	ldr	r2, [r3, #20]
 800d5c4:	0052      	lsls	r2, r2, #1
    WRITE_REG(FLASH->OPTKEYR, FLASH_OPTKEY1);
 800d5c6:	bf41      	itttt	mi
 800d5c8:	4a06      	ldrmi	r2, [pc, #24]	; (800d5e4 <HAL_FLASH_OB_Unlock+0x24>)
 800d5ca:	60da      	strmi	r2, [r3, #12]
    WRITE_REG(FLASH->OPTKEYR, FLASH_OPTKEY2);
 800d5cc:	f102 3244 	addmi.w	r2, r2, #1145324612	; 0x44444444
 800d5d0:	60da      	strmi	r2, [r3, #12]
    if (READ_BIT(FLASH->CR, FLASH_CR_OPTLOCK) == 0U)
 800d5d2:	bf46      	itte	mi
 800d5d4:	6958      	ldrmi	r0, [r3, #20]
  HAL_StatusTypeDef status = HAL_ERROR;
 800d5d6:	f3c0 7080 	ubfxmi	r0, r0, #30, #1
 800d5da:	2001      	movpl	r0, #1
}
 800d5dc:	4770      	bx	lr
 800d5de:	bf00      	nop
 800d5e0:	58004000 	.word	0x58004000
 800d5e4:	08192a3b 	.word	0x08192a3b

0800d5e8 <HAL_FLASH_OB_Lock>:
  SET_BIT(FLASH->CR, FLASH_CR_OPTLOCK);
 800d5e8:	4b05      	ldr	r3, [pc, #20]	; (800d600 <HAL_FLASH_OB_Lock+0x18>)
 800d5ea:	695a      	ldr	r2, [r3, #20]
 800d5ec:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 800d5f0:	615a      	str	r2, [r3, #20]
  if (READ_BIT(FLASH->CR, FLASH_CR_OPTLOCK) == 0U)
 800d5f2:	6958      	ldr	r0, [r3, #20]
 800d5f4:	f080 4080 	eor.w	r0, r0, #1073741824	; 0x40000000
}
 800d5f8:	f3c0 7080 	ubfx	r0, r0, #30, #1
 800d5fc:	4770      	bx	lr
 800d5fe:	bf00      	nop
 800d600:	58004000 	.word	0x58004000

0800d604 <HAL_FLASH_OB_Launch>:
  SET_BIT(FLASH->CR, FLASH_CR_OBL_LAUNCH);
 800d604:	4a03      	ldr	r2, [pc, #12]	; (800d614 <HAL_FLASH_OB_Launch+0x10>)
 800d606:	6953      	ldr	r3, [r2, #20]
 800d608:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 800d60c:	6153      	str	r3, [r2, #20]
}
 800d60e:	2001      	movs	r0, #1
 800d610:	4770      	bx	lr
 800d612:	bf00      	nop
 800d614:	58004000 	.word	0x58004000

0800d618 <FLASH_WaitForLastOperation>:
{
 800d618:	b570      	push	{r4, r5, r6, lr}
 800d61a:	4605      	mov	r5, r0
  uint32_t tickstart = HAL_GetTick();
 800d61c:	f7ff fe36 	bl	800d28c <HAL_GetTick>
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 800d620:	4e12      	ldr	r6, [pc, #72]	; (800d66c <FLASH_WaitForLastOperation+0x54>)
  uint32_t tickstart = HAL_GetTick();
 800d622:	4604      	mov	r4, r0
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 800d624:	6933      	ldr	r3, [r6, #16]
 800d626:	03d9      	lsls	r1, r3, #15
 800d628:	d413      	bmi.n	800d652 <FLASH_WaitForLastOperation+0x3a>
  error = FLASH->SR;
 800d62a:	6933      	ldr	r3, [r6, #16]
  if ((error & FLASH_FLAG_EOP) != 0U)
 800d62c:	07da      	lsls	r2, r3, #31
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 800d62e:	bf44      	itt	mi
 800d630:	2201      	movmi	r2, #1
 800d632:	6132      	strmi	r2, [r6, #16]
  error &= FLASH_FLAG_SR_ERRORS;
 800d634:	f24c 32fa 	movw	r2, #50170	; 0xc3fa
  __HAL_FLASH_CLEAR_FLAG(error);
 800d638:	4013      	ands	r3, r2
 800d63a:	d111      	bne.n	800d660 <FLASH_WaitForLastOperation+0x48>
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_CFGBSY))
 800d63c:	4e0b      	ldr	r6, [pc, #44]	; (800d66c <FLASH_WaitForLastOperation+0x54>)
 800d63e:	6930      	ldr	r0, [r6, #16]
 800d640:	f410 2080 	ands.w	r0, r0, #262144	; 0x40000
 800d644:	d00b      	beq.n	800d65e <FLASH_WaitForLastOperation+0x46>
    if ((HAL_GetTick() - tickstart) >= Timeout)
 800d646:	f7ff fe21 	bl	800d28c <HAL_GetTick>
 800d64a:	1b00      	subs	r0, r0, r4
 800d64c:	42a8      	cmp	r0, r5
 800d64e:	d3f6      	bcc.n	800d63e <FLASH_WaitForLastOperation+0x26>
 800d650:	e004      	b.n	800d65c <FLASH_WaitForLastOperation+0x44>
    if ((HAL_GetTick() - tickstart) >= Timeout)
 800d652:	f7ff fe1b 	bl	800d28c <HAL_GetTick>
 800d656:	1b00      	subs	r0, r0, r4
 800d658:	42a8      	cmp	r0, r5
 800d65a:	d3e3      	bcc.n	800d624 <FLASH_WaitForLastOperation+0xc>
      return HAL_TIMEOUT;
 800d65c:	2003      	movs	r0, #3
}
 800d65e:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_FLASH_CLEAR_FLAG(error);
 800d660:	4a02      	ldr	r2, [pc, #8]	; (800d66c <FLASH_WaitForLastOperation+0x54>)
 800d662:	6113      	str	r3, [r2, #16]
    pFlash.ErrorCode = error;
 800d664:	4a02      	ldr	r2, [pc, #8]	; (800d670 <FLASH_WaitForLastOperation+0x58>)
    return HAL_ERROR;
 800d666:	2001      	movs	r0, #1
    pFlash.ErrorCode = error;
 800d668:	6053      	str	r3, [r2, #4]
    return HAL_ERROR;
 800d66a:	e7f8      	b.n	800d65e <FLASH_WaitForLastOperation+0x46>
 800d66c:	58004000 	.word	0x58004000
 800d670:	20003c44 	.word	0x20003c44

0800d674 <HAL_FLASH_Program>:
{
 800d674:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __HAL_LOCK(&pFlash);
 800d678:	4c18      	ldr	r4, [pc, #96]	; (800d6dc <HAL_FLASH_Program+0x68>)
{
 800d67a:	4698      	mov	r8, r3
  __HAL_LOCK(&pFlash);
 800d67c:	7823      	ldrb	r3, [r4, #0]
 800d67e:	2b01      	cmp	r3, #1
{
 800d680:	4606      	mov	r6, r0
 800d682:	460d      	mov	r5, r1
 800d684:	4617      	mov	r7, r2
  __HAL_LOCK(&pFlash);
 800d686:	d026      	beq.n	800d6d6 <HAL_FLASH_Program+0x62>
 800d688:	2301      	movs	r3, #1
 800d68a:	7023      	strb	r3, [r4, #0]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 800d68c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 800d690:	2300      	movs	r3, #0
 800d692:	6063      	str	r3, [r4, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 800d694:	f7ff ffc0 	bl	800d618 <FLASH_WaitForLastOperation>
  if (status == HAL_OK)
 800d698:	b9a0      	cbnz	r0, 800d6c4 <HAL_FLASH_Program+0x50>
    if (TypeProgram == FLASH_TYPEPROGRAM_DOUBLEWORD)
 800d69a:	2e01      	cmp	r6, #1
 800d69c:	d116      	bne.n	800d6cc <HAL_FLASH_Program+0x58>
  SET_BIT(FLASH->CR, FLASH_CR_PG);
 800d69e:	4a10      	ldr	r2, [pc, #64]	; (800d6e0 <HAL_FLASH_Program+0x6c>)
 800d6a0:	6953      	ldr	r3, [r2, #20]
 800d6a2:	f043 0301 	orr.w	r3, r3, #1
 800d6a6:	6153      	str	r3, [r2, #20]
  *(uint32_t *)Address = (uint32_t)Data;
 800d6a8:	602f      	str	r7, [r5, #0]
  __ASM volatile ("isb 0xF":::"memory");
 800d6aa:	f3bf 8f6f 	isb	sy
  *(uint32_t *)(Address + 4U) = (uint32_t)(Data >> 32U);
 800d6ae:	f8c5 8004 	str.w	r8, [r5, #4]
    status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 800d6b2:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800d6b6:	f7ff ffaf 	bl	800d618 <FLASH_WaitForLastOperation>
    CLEAR_BIT(FLASH->CR, TypeProgram);
 800d6ba:	4a09      	ldr	r2, [pc, #36]	; (800d6e0 <HAL_FLASH_Program+0x6c>)
 800d6bc:	6953      	ldr	r3, [r2, #20]
 800d6be:	ea23 0606 	bic.w	r6, r3, r6
 800d6c2:	6156      	str	r6, [r2, #20]
  __HAL_UNLOCK(&pFlash);
 800d6c4:	2300      	movs	r3, #0
 800d6c6:	7023      	strb	r3, [r4, #0]
}
 800d6c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      FLASH_Program_Fast(Address, (uint32_t)Data);
 800d6cc:	4639      	mov	r1, r7
 800d6ce:	4628      	mov	r0, r5
 800d6d0:	f7ff ff40 	bl	800d554 <FLASH_Program_Fast>
 800d6d4:	e7ed      	b.n	800d6b2 <HAL_FLASH_Program+0x3e>
  __HAL_LOCK(&pFlash);
 800d6d6:	2002      	movs	r0, #2
 800d6d8:	e7f6      	b.n	800d6c8 <HAL_FLASH_Program+0x54>
 800d6da:	bf00      	nop
 800d6dc:	20003c44 	.word	0x20003c44
 800d6e0:	58004000 	.word	0x58004000

0800d6e4 <HAL_FLASHEx_OBProgram>:
  *         - a Power On Reset
  *         - an exit from Standby or Shutdown mode.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit)
{
 800d6e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  /* Check the parameters */
  assert_param(IS_OPTIONBYTE(pOBInit->OptionType));

  /* Process Locked */
  __HAL_LOCK(&pFlash);
 800d6e6:	4c86      	ldr	r4, [pc, #536]	; (800d900 <HAL_FLASHEx_OBProgram+0x21c>)
 800d6e8:	7823      	ldrb	r3, [r4, #0]
 800d6ea:	2b01      	cmp	r3, #1
 800d6ec:	f000 8106 	beq.w	800d8fc <HAL_FLASHEx_OBProgram+0x218>
 800d6f0:	2301      	movs	r3, #1
 800d6f2:	7023      	strb	r3, [r4, #0]

  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;

  /* Write protection configuration */
  if ((pOBInit->OptionType & OPTIONBYTE_WRP) != 0U)
 800d6f4:	6805      	ldr	r5, [r0, #0]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 800d6f6:	2300      	movs	r3, #0
 800d6f8:	6063      	str	r3, [r4, #4]
  if ((pOBInit->OptionType & OPTIONBYTE_WRP) != 0U)
 800d6fa:	07eb      	lsls	r3, r5, #31
 800d6fc:	d50d      	bpl.n	800d71a <HAL_FLASHEx_OBProgram+0x36>
  {
    /* Configure of Write protection on the selected area */
    FLASH_OB_WRPConfig(pOBInit->WRPArea, pOBInit->WRPStartOffset, pOBInit->WRPEndOffset);
 800d6fe:	e9d0 6302 	ldrd	r6, r3, [r0, #8]
 800d702:	0419      	lsls	r1, r3, #16
  assert_param(IS_OB_WRPAREA(WRPArea));
  assert_param(IS_FLASH_PAGE(WRPStartOffset));
  assert_param(IS_FLASH_PAGE(WRDPEndOffset));

  /* Configure the write protected area */
  if (WRPArea == OB_WRPAREA_BANK1_AREAA)
 800d704:	6843      	ldr	r3, [r0, #4]
 800d706:	4a7f      	ldr	r2, [pc, #508]	; (800d904 <HAL_FLASHEx_OBProgram+0x220>)
 800d708:	2b00      	cmp	r3, #0
 800d70a:	f040 80ae 	bne.w	800d86a <HAL_FLASHEx_OBProgram+0x186>
  {
    MODIFY_REG(FLASH->WRP1AR, (FLASH_WRP1AR_WRP1A_STRT | FLASH_WRP1AR_WRP1A_END),
 800d70e:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 800d710:	f023 137f 	bic.w	r3, r3, #8323199	; 0x7f007f
 800d714:	4333      	orrs	r3, r6
 800d716:	430b      	orrs	r3, r1
 800d718:	62d3      	str	r3, [r2, #44]	; 0x2c
  if ((pOBInit->OptionType & (OPTIONBYTE_RDP | OPTIONBYTE_USER)) == (OPTIONBYTE_RDP | OPTIONBYTE_USER))
 800d71a:	f005 0306 	and.w	r3, r5, #6
 800d71e:	2b06      	cmp	r3, #6
 800d720:	f040 80aa 	bne.w	800d878 <HAL_FLASHEx_OBProgram+0x194>
  assert_param(IS_OB_USER_TYPE(UserType));
  assert_param(IS_OB_USER_CONFIG(UserType, UserConfig));
  assert_param(IS_OB_RDP_LEVEL(RDPLevel));

  /* Configure the RDP level in the option bytes register */
  optr = FLASH->OPTR;
 800d724:	4977      	ldr	r1, [pc, #476]	; (800d904 <HAL_FLASHEx_OBProgram+0x220>)
  optr &= ~(UserType | FLASH_OPTR_RDP);
 800d726:	6942      	ldr	r2, [r0, #20]
  optr = FLASH->OPTR;
 800d728:	6a0b      	ldr	r3, [r1, #32]
  FLASH->OPTR = (optr | UserConfig | RDPLevel);
 800d72a:	6906      	ldr	r6, [r0, #16]
  optr &= ~(UserType | FLASH_OPTR_RDP);
 800d72c:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
 800d730:	ea23 0302 	bic.w	r3, r3, r2
  FLASH->OPTR = (optr | UserConfig | RDPLevel);
 800d734:	6982      	ldr	r2, [r0, #24]
 800d736:	4332      	orrs	r2, r6
 800d738:	4313      	orrs	r3, r2
 800d73a:	620b      	str	r3, [r1, #32]
  if ((pOBInit->OptionType & OPTIONBYTE_PCROP) != 0U)
 800d73c:	0729      	lsls	r1, r5, #28
 800d73e:	d526      	bpl.n	800d78e <HAL_FLASHEx_OBProgram+0xaa>
    if ((pOBInit->PCROPConfig & (OB_PCROP_ZONE_A | OB_PCROP_RDP_ERASE)) != 0U)
 800d740:	69c1      	ldr	r1, [r0, #28]
 800d742:	4b71      	ldr	r3, [pc, #452]	; (800d908 <HAL_FLASHEx_OBProgram+0x224>)
 800d744:	4219      	tst	r1, r3
 800d746:	d015      	beq.n	800d774 <HAL_FLASHEx_OBProgram+0x90>
  assert_param(IS_OB_PCROP_CONFIG(PCROPConfig));
  assert_param(IS_FLASH_MAIN_MEM_ADDRESS(PCROP1AStartAddr));
  assert_param(IS_FLASH_MAIN_MEM_ADDRESS(PCROP1AEndAddr));

  /* get pcrop 1A end register */
  pcrop1aend = FLASH->PCROP1AER;
 800d748:	4f6e      	ldr	r7, [pc, #440]	; (800d904 <HAL_FLASHEx_OBProgram+0x220>)

  /* Configure the Proprietary code readout protection offset */
  if ((PCROPConfig & OB_PCROP_ZONE_A) != 0U)
 800d74a:	07ca      	lsls	r2, r1, #31
  pcrop1aend = FLASH->PCROP1AER;
 800d74c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  if ((PCROPConfig & OB_PCROP_ZONE_A) != 0U)
 800d74e:	d50b      	bpl.n	800d768 <HAL_FLASHEx_OBProgram+0x84>
  {
    /* Compute offset depending on pcrop granularity */
    startoffset = ((PCROP1AStartAddr - FLASH_BASE) >> FLASH_PCROP_GRANULARITY_OFFSET); /* 2K pages */
 800d750:	6a02      	ldr	r2, [r0, #32]
    endoffset = ((PCROP1AEndAddr - FLASH_BASE) >> FLASH_PCROP_GRANULARITY_OFFSET); /* 2K pages */
 800d752:	6a46      	ldr	r6, [r0, #36]	; 0x24
    startoffset = ((PCROP1AStartAddr - FLASH_BASE) >> FLASH_PCROP_GRANULARITY_OFFSET); /* 2K pages */
 800d754:	f102 4278 	add.w	r2, r2, #4160749568	; 0xf8000000
 800d758:	0a92      	lsrs	r2, r2, #10
    endoffset = ((PCROP1AEndAddr - FLASH_BASE) >> FLASH_PCROP_GRANULARITY_OFFSET); /* 2K pages */
 800d75a:	f106 4678 	add.w	r6, r6, #4160749568	; 0xf8000000

    /* Set Zone A start offset */
    WRITE_REG(FLASH->PCROP1ASR, startoffset);

    /* Set Zone A end offset */
    pcrop1aend &= ~FLASH_PCROP1AER_PCROP1A_END;
 800d75e:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
    WRITE_REG(FLASH->PCROP1ASR, startoffset);
 800d762:	627a      	str	r2, [r7, #36]	; 0x24
    pcrop1aend |= endoffset;
 800d764:	ea43 2396 	orr.w	r3, r3, r6, lsr #10
  {
    pcrop1aend |= FLASH_PCROP1AER_PCROP_RDP;
  }

  /* set 1A End register */
  WRITE_REG(FLASH->PCROP1AER, pcrop1aend);
 800d768:	4a66      	ldr	r2, [pc, #408]	; (800d904 <HAL_FLASHEx_OBProgram+0x220>)
  if ((PCROPConfig & OB_PCROP_RDP_ERASE) != 0U)
 800d76a:	2900      	cmp	r1, #0
    pcrop1aend |= FLASH_PCROP1AER_PCROP_RDP;
 800d76c:	bfb8      	it	lt
 800d76e:	f043 4300 	orrlt.w	r3, r3, #2147483648	; 0x80000000
  WRITE_REG(FLASH->PCROP1AER, pcrop1aend);
 800d772:	6293      	str	r3, [r2, #40]	; 0x28
    if ((pOBInit->PCROPConfig & OB_PCROP_ZONE_B) != 0U)
 800d774:	078b      	lsls	r3, r1, #30
 800d776:	d50a      	bpl.n	800d78e <HAL_FLASHEx_OBProgram+0xaa>
  /* Check the parameters */
  assert_param(IS_FLASH_MAIN_MEM_ADDRESS(PCROP1BStartAddr));
  assert_param(IS_FLASH_MAIN_MEM_ADDRESS(PCROP1BEndAddr));

  /* Compute offset depending on pcrop granularity */
  startoffset = ((PCROP1BStartAddr - FLASH_BASE) >> FLASH_PCROP_GRANULARITY_OFFSET); /* 2K pages */
 800d778:	6a83      	ldr	r3, [r0, #40]	; 0x28
  endoffset = ((PCROP1BEndAddr - FLASH_BASE) >> FLASH_PCROP_GRANULARITY_OFFSET); /* 2K pages */

  /* Configure the Proprietary code readout protection start address */
  WRITE_REG(FLASH->PCROP1BSR, startoffset);
 800d77a:	4962      	ldr	r1, [pc, #392]	; (800d904 <HAL_FLASHEx_OBProgram+0x220>)
  startoffset = ((PCROP1BStartAddr - FLASH_BASE) >> FLASH_PCROP_GRANULARITY_OFFSET); /* 2K pages */
 800d77c:	f103 4378 	add.w	r3, r3, #4160749568	; 0xf8000000
 800d780:	0a9a      	lsrs	r2, r3, #10
  endoffset = ((PCROP1BEndAddr - FLASH_BASE) >> FLASH_PCROP_GRANULARITY_OFFSET); /* 2K pages */
 800d782:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  WRITE_REG(FLASH->PCROP1BSR, startoffset);
 800d784:	634a      	str	r2, [r1, #52]	; 0x34
  endoffset = ((PCROP1BEndAddr - FLASH_BASE) >> FLASH_PCROP_GRANULARITY_OFFSET); /* 2K pages */
 800d786:	f103 4378 	add.w	r3, r3, #4160749568	; 0xf8000000
 800d78a:	0a9b      	lsrs	r3, r3, #10

  /* Configure the Proprietary code readout protection end address */
  WRITE_REG(FLASH->PCROP1BER, endoffset);
 800d78c:	638b      	str	r3, [r1, #56]	; 0x38
  if ((pOBInit->OptionType & (OPTIONBYTE_SECURE_MODE | OPTIONBYTE_C2_BOOT_VECT | OPTIONBYTE_C2_DEBUG_ACCESS | OPTIONBYTE_SUBGHZSPI_SECURE_ACCESS)) != 0U)
 800d78e:	f415 6f70 	tst.w	r5, #3840	; 0xf00
 800d792:	d051      	beq.n	800d838 <HAL_FLASHEx_OBProgram+0x154>
  *         contains the configuration information for the programming
  * @retval void
  */
static void FLASH_OB_SecureConfig(FLASH_OBProgramInitTypeDef *pOBParam)
{
  uint32_t sfr_reg_val = READ_REG(FLASH->SFR);
 800d794:	4a5b      	ldr	r2, [pc, #364]	; (800d904 <HAL_FLASHEx_OBProgram+0x220>)
  uint32_t srrvr_reg_val = READ_REG(FLASH->SRRVR);

  if ((pOBParam->OptionType & OPTIONBYTE_SECURE_MODE) != 0U)
 800d796:	05af      	lsls	r7, r5, #22
  uint32_t sfr_reg_val = READ_REG(FLASH->SFR);
 800d798:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
  uint32_t srrvr_reg_val = READ_REG(FLASH->SRRVR);
 800d79c:	f8d2 2084 	ldr.w	r2, [r2, #132]	; 0x84
  if ((pOBParam->OptionType & OPTIONBYTE_SECURE_MODE) != 0U)
 800d7a0:	d523      	bpl.n	800d7ea <HAL_FLASHEx_OBProgram+0x106>
    assert_param(IS_OB_SNBRSA_START_ADDR(pOBParam->SecureSRAM1StartAddr));
    assert_param(IS_OB_HDPSA_START_ADDR(pOBParam->HideProtectionStartAddr));
    assert_param(IS_OB_SECURE_MODE(pOBParam->SecureMode));

    /* Configure SFR register content with start FLASH PAGE index to secure and start FLASH PAGE index for hide protection area */
    MODIFY_REG(sfr_reg_val, (FLASH_SFR_SFSA | FLASH_SFR_HDPSA), \
 800d7a2:	6b01      	ldr	r1, [r0, #48]	; 0x30
 800d7a4:	f023 137f 	bic.w	r3, r3, #8323199	; 0x7f007f
 800d7a8:	f101 4178 	add.w	r1, r1, #4160749568	; 0xf8000000
 800d7ac:	ea43 23d1 	orr.w	r3, r3, r1, lsr #11
 800d7b0:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
 800d7b2:	0149      	lsls	r1, r1, #5
 800d7b4:	0c09      	lsrs	r1, r1, #16
 800d7b6:	0409      	lsls	r1, r1, #16
 800d7b8:	430b      	orrs	r3, r1
               ((((pOBParam->SecureFlashStartAddr - FLASH_BASE) / FLASH_PAGE_SIZE) << FLASH_SFR_SFSA_Pos) | \
                (((pOBParam->HideProtectionStartAddr - FLASH_BASE) / FLASH_PAGE_SIZE) << FLASH_SFR_HDPSA_Pos)));

    /* Configure SRRVR register */
    MODIFY_REG(srrvr_reg_val, (FLASH_SRRVR_SBRSA | FLASH_SRRVR_SNBRSA), \
 800d7ba:	6b41      	ldr	r1, [r0, #52]	; 0x34
 800d7bc:	f101 4160 	add.w	r1, r1, #3758096384	; 0xe0000000
 800d7c0:	f5a1 4100 	sub.w	r1, r1, #32768	; 0x8000
 800d7c4:	0a8e      	lsrs	r6, r1, #10
 800d7c6:	6b81      	ldr	r1, [r0, #56]	; 0x38
 800d7c8:	03c9      	lsls	r1, r1, #15
 800d7ca:	f001 417e 	and.w	r1, r1, #4261412864	; 0xfe000000
 800d7ce:	f022 5279 	bic.w	r2, r2, #1044381696	; 0x3e400000
 800d7d2:	ea41 4186 	orr.w	r1, r1, r6, lsl #18
 800d7d6:	f422 1270 	bic.w	r2, r2, #3932160	; 0x3c0000
 800d7da:	430a      	orrs	r2, r1
               (((((pOBParam->SecureSRAM2StartAddr - SRAM2_BASE) >> SRAM_SECURE_PAGE_GRANULARITY_OFFSET) << FLASH_SRRVR_SBRSA_Pos)) | \
                ((((pOBParam->SecureSRAM1StartAddr - SRAM1_BASE) >> SRAM_SECURE_PAGE_GRANULARITY_OFFSET) << FLASH_SRRVR_SNBRSA_Pos))));

    /* If Full System Secure mode is requested, clear all the corresponding bit */
    /* Else set the corresponding bit */
    if (pOBParam->SecureMode == OB_SECURE_SYSTEM_AND_ALL_AREAS_ENABLE)
 800d7dc:	6c01      	ldr	r1, [r0, #64]	; 0x40
 800d7de:	290f      	cmp	r1, #15
 800d7e0:	d16c      	bne.n	800d8bc <HAL_FLASHEx_OBProgram+0x1d8>
    {
      CLEAR_BIT(sfr_reg_val, (FLASH_SFR_FSD | FLASH_SFR_HDPAD));
 800d7e2:	f023 1380 	bic.w	r3, r3, #8388736	; 0x800080
      CLEAR_BIT(srrvr_reg_val, (FLASH_SRRVR_BRSD | FLASH_SRRVR_NBRSD));
 800d7e6:	f022 4281 	bic.w	r2, r2, #1082130432	; 0x40800000
      FLASH_OB_ConfigSecureMode(pOBParam->SecureMode, &srrvr_reg_val, FLASH_SRRVR_BRSD, OB_SECURE_SRAM2_ENABLE);
    }
  }

  /* Boot vector */
  if ((pOBParam->OptionType & OPTIONBYTE_C2_BOOT_VECT) != 0U)
 800d7ea:	05ef      	lsls	r7, r5, #23
 800d7ec:	d513      	bpl.n	800d816 <HAL_FLASHEx_OBProgram+0x132>
    /* Check the parameters */
    assert_param(IS_OB_BOOT_VECTOR_ADDR(pOBParam->C2SecureBootVectAddr));
    assert_param(IS_OB_BOOT_REGION(pOBParam->C2BootRegion));

    /* Set the boot vector */
    if (pOBParam->C2BootRegion == OB_C2_BOOT_FROM_FLASH)
 800d7ee:	6cc7      	ldr	r7, [r0, #76]	; 0x4c
 800d7f0:	6d06      	ldr	r6, [r0, #80]	; 0x50
 800d7f2:	4946      	ldr	r1, [pc, #280]	; (800d90c <HAL_FLASHEx_OBProgram+0x228>)
 800d7f4:	f1b7 4f00 	cmp.w	r7, #2147483648	; 0x80000000
    {
      MODIFY_REG(srrvr_reg_val, (FLASH_SRRVR_SBRV | FLASH_SRRVR_C2OPT), (((pOBParam->C2SecureBootVectAddr - FLASH_BASE) >> 2) | pOBParam->C2BootRegion));
 800d7f8:	ea01 0102 	and.w	r1, r1, r2
    }
    else
    {
      MODIFY_REG(srrvr_reg_val, (FLASH_SRRVR_SBRV | FLASH_SRRVR_C2OPT), (((pOBParam->C2SecureBootVectAddr - SRAM1_BASE) >> 2) | pOBParam->C2BootRegion));
 800d7fc:	bf13      	iteet	ne
 800d7fe:	f106 4660 	addne.w	r6, r6, #3758096384	; 0xe0000000
      MODIFY_REG(srrvr_reg_val, (FLASH_SRRVR_SBRV | FLASH_SRRVR_C2OPT), (((pOBParam->C2SecureBootVectAddr - FLASH_BASE) >> 2) | pOBParam->C2BootRegion));
 800d802:	f106 4278 	addeq.w	r2, r6, #4160749568	; 0xf8000000
 800d806:	ea41 0292 	orreq.w	r2, r1, r2, lsr #2
      MODIFY_REG(srrvr_reg_val, (FLASH_SRRVR_SBRV | FLASH_SRRVR_C2OPT), (((pOBParam->C2SecureBootVectAddr - SRAM1_BASE) >> 2) | pOBParam->C2BootRegion));
 800d80a:	ea47 0296 	orrne.w	r2, r7, r6, lsr #2
      MODIFY_REG(srrvr_reg_val, (FLASH_SRRVR_SBRV | FLASH_SRRVR_C2OPT), (((pOBParam->C2SecureBootVectAddr - FLASH_BASE) >> 2) | pOBParam->C2BootRegion));
 800d80e:	bf0c      	ite	eq
 800d810:	f042 4200 	orreq.w	r2, r2, #2147483648	; 0x80000000
      MODIFY_REG(srrvr_reg_val, (FLASH_SRRVR_SBRV | FLASH_SRRVR_C2OPT), (((pOBParam->C2SecureBootVectAddr - SRAM1_BASE) >> 2) | pOBParam->C2BootRegion));
 800d814:	430a      	orrne	r2, r1
    }
  }

  /* CPU2 Debug Access */
  if ((pOBParam->OptionType & OPTIONBYTE_C2_DEBUG_ACCESS) != 0U)
 800d816:	056e      	lsls	r6, r5, #21
  {
    /* Check the parameters */
    assert_param(IS_OB_C2_DEBUG_MODE(pOBParam->C2DebugAccessMode));

    /* Set the CPU2 Debug Access */
    MODIFY_REG(sfr_reg_val, FLASH_SFR_DDS, (uint32_t)pOBParam->C2DebugAccessMode);
 800d818:	bf42      	ittt	mi
 800d81a:	6c81      	ldrmi	r1, [r0, #72]	; 0x48
 800d81c:	f423 5380 	bicmi.w	r3, r3, #4096	; 0x1000
 800d820:	430b      	orrmi	r3, r1
  }

  /* Sub-GHz radio SPI Access */
  if ((pOBParam->OptionType & OPTIONBYTE_SUBGHZSPI_SECURE_ACCESS) != 0U)
 800d822:	0529      	lsls	r1, r5, #20
  {
    /* Check the parameters */
    assert_param(IS_OB_SUBGHZSPI_SECURE_ACCESS(pOBParam->SUBGHZSPISecureAccess));

    /* Set the Sub-GHz radio SPI Secure Access */
    MODIFY_REG(sfr_reg_val, FLASH_SFR_SUBGHZSPISD, (uint32_t)pOBParam->SUBGHZSPISecureAccess);
 800d824:	bf42      	ittt	mi
 800d826:	6c41      	ldrmi	r1, [r0, #68]	; 0x44
 800d828:	f023 4300 	bicmi.w	r3, r3, #2147483648	; 0x80000000
 800d82c:	430b      	orrmi	r3, r1
  }

  /* Update Flash registers */
  WRITE_REG(FLASH->SFR, sfr_reg_val);
 800d82e:	4935      	ldr	r1, [pc, #212]	; (800d904 <HAL_FLASHEx_OBProgram+0x220>)
 800d830:	f8c1 3080 	str.w	r3, [r1, #128]	; 0x80
  WRITE_REG(FLASH->SRRVR, srrvr_reg_val);
 800d834:	f8c1 2084 	str.w	r2, [r1, #132]	; 0x84
  if ((pOBInit->OptionType & OPTIONBYTE_IPCC_BUF_ADDR) != 0U)
 800d838:	06eb      	lsls	r3, r5, #27
 800d83a:	d505      	bpl.n	800d848 <HAL_FLASHEx_OBProgram+0x164>
  WRITE_REG(FLASH->IPCCBR, (uint32_t)((IPCCDataBufAddr - SRAM1_BASE) >> 4));
 800d83c:	6d43      	ldr	r3, [r0, #84]	; 0x54
 800d83e:	4a31      	ldr	r2, [pc, #196]	; (800d904 <HAL_FLASHEx_OBProgram+0x220>)
 800d840:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 800d844:	091b      	lsrs	r3, r3, #4
 800d846:	63d3      	str	r3, [r2, #60]	; 0x3c
static HAL_StatusTypeDef FLASH_OB_ProceedWriteOperation(void)
{
  HAL_StatusTypeDef status;

  /* Verify that next operation can be proceed */
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 800d848:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800d84c:	f7ff fee4 	bl	800d618 <FLASH_WaitForLastOperation>

  if (status == HAL_OK)
 800d850:	b940      	cbnz	r0, 800d864 <HAL_FLASHEx_OBProgram+0x180>
  {
    /* Set OPTSTRT Bit */
    SET_BIT(FLASH->CR, FLASH_CR_OPTSTRT);
 800d852:	4a2c      	ldr	r2, [pc, #176]	; (800d904 <HAL_FLASHEx_OBProgram+0x220>)
 800d854:	6953      	ldr	r3, [r2, #20]
 800d856:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800d85a:	6153      	str	r3, [r2, #20]

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 800d85c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800d860:	f7ff feda 	bl	800d618 <FLASH_WaitForLastOperation>
  __HAL_UNLOCK(&pFlash);
 800d864:	2300      	movs	r3, #0
 800d866:	7023      	strb	r3, [r4, #0]
}
 800d868:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    MODIFY_REG(FLASH->WRP1BR, (FLASH_WRP1BR_WRP1B_STRT | FLASH_WRP1BR_WRP1B_END),
 800d86a:	6b13      	ldr	r3, [r2, #48]	; 0x30
 800d86c:	f023 137f 	bic.w	r3, r3, #8323199	; 0x7f007f
 800d870:	4333      	orrs	r3, r6
 800d872:	430b      	orrs	r3, r1
 800d874:	6313      	str	r3, [r2, #48]	; 0x30
 800d876:	e750      	b.n	800d71a <HAL_FLASHEx_OBProgram+0x36>
  else if ((pOBInit->OptionType & OPTIONBYTE_RDP) != 0U)
 800d878:	07af      	lsls	r7, r5, #30
 800d87a:	d50b      	bpl.n	800d894 <HAL_FLASHEx_OBProgram+0x1b0>
  uint32_t user_config = (READ_REG(FLASH->OPTR) & OB_USER_ALL);
 800d87c:	4921      	ldr	r1, [pc, #132]	; (800d904 <HAL_FLASHEx_OBProgram+0x220>)
    optr &= ~OB_USER_BOR_LEV;
 800d87e:	4a24      	ldr	r2, [pc, #144]	; (800d910 <HAL_FLASHEx_OBProgram+0x22c>)
  uint32_t user_config = (READ_REG(FLASH->OPTR) & OB_USER_ALL);
 800d880:	6a0b      	ldr	r3, [r1, #32]
    optr &= ~OB_USER_BOR_LEV;
 800d882:	401a      	ands	r2, r3
  optr = FLASH->OPTR;
 800d884:	6a0b      	ldr	r3, [r1, #32]
  optr &= ~(UserType | FLASH_OPTR_RDP);
 800d886:	f042 06ff 	orr.w	r6, r2, #255	; 0xff
 800d88a:	ea23 0306 	bic.w	r3, r3, r6
  FLASH->OPTR = (optr | UserConfig | RDPLevel);
 800d88e:	4313      	orrs	r3, r2
 800d890:	6902      	ldr	r2, [r0, #16]
 800d892:	e751      	b.n	800d738 <HAL_FLASHEx_OBProgram+0x54>
  else if ((pOBInit->OptionType & OPTIONBYTE_USER) != 0U)
 800d894:	076e      	lsls	r6, r5, #29
 800d896:	f57f af51 	bpl.w	800d73c <HAL_FLASHEx_OBProgram+0x58>
  uint32_t rdplvl = READ_BIT(FLASH->OPTR, FLASH_OPTR_RDP);
 800d89a:	491a      	ldr	r1, [pc, #104]	; (800d904 <HAL_FLASHEx_OBProgram+0x220>)
 800d89c:	6a0a      	ldr	r2, [r1, #32]
 800d89e:	b2d2      	uxtb	r2, r2
  if ((rdplvl != OB_RDP_LEVEL_0) && (rdplvl != OB_RDP_LEVEL_2))
 800d8a0:	2aaa      	cmp	r2, #170	; 0xaa
 800d8a2:	d002      	beq.n	800d8aa <HAL_FLASHEx_OBProgram+0x1c6>
    return (OB_RDP_LEVEL_1);
 800d8a4:	2acc      	cmp	r2, #204	; 0xcc
 800d8a6:	bf18      	it	ne
 800d8a8:	22bb      	movne	r2, #187	; 0xbb
  optr &= ~(UserType | FLASH_OPTR_RDP);
 800d8aa:	6946      	ldr	r6, [r0, #20]
  optr = FLASH->OPTR;
 800d8ac:	6a0b      	ldr	r3, [r1, #32]
  optr &= ~(UserType | FLASH_OPTR_RDP);
 800d8ae:	f046 06ff 	orr.w	r6, r6, #255	; 0xff
 800d8b2:	ea23 0306 	bic.w	r3, r3, r6
  FLASH->OPTR = (optr | UserConfig | RDPLevel);
 800d8b6:	6986      	ldr	r6, [r0, #24]
 800d8b8:	4333      	orrs	r3, r6
 800d8ba:	e73d      	b.n	800d738 <HAL_FLASHEx_OBProgram+0x54>
    else if (pOBParam->SecureMode == OB_SECURE_SYSTEM_AND_ALL_AREAS_DISABLE)
 800d8bc:	29f0      	cmp	r1, #240	; 0xf0
 800d8be:	d104      	bne.n	800d8ca <HAL_FLASHEx_OBProgram+0x1e6>
      SET_BIT(sfr_reg_val, (FLASH_SFR_FSD | FLASH_SFR_HDPAD));
 800d8c0:	f043 1380 	orr.w	r3, r3, #8388736	; 0x800080
      SET_BIT(srrvr_reg_val, (FLASH_SRRVR_BRSD | FLASH_SRRVR_NBRSD));
 800d8c4:	f042 4281 	orr.w	r2, r2, #1082130432	; 0x40800000
 800d8c8:	e78f      	b.n	800d7ea <HAL_FLASHEx_OBProgram+0x106>
  * @retval None
  */
static void FLASH_OB_ConfigSecureMode(uint32_t SecureMode, uint32_t *Reg, uint32_t Bit, uint32_t ValueEnable)
{
  /* Check if SecureMode is requested */
  if ((SecureMode & ValueEnable) == ValueEnable)
 800d8ca:	07ce      	lsls	r6, r1, #31
  {
    CLEAR_BIT(*Reg, Bit);
 800d8cc:	bf4c      	ite	mi
 800d8ce:	f023 0380 	bicmi.w	r3, r3, #128	; 0x80
  }
  else
  {
    SET_BIT(*Reg, Bit);
 800d8d2:	f043 0380 	orrpl.w	r3, r3, #128	; 0x80
  if ((SecureMode & ValueEnable) == ValueEnable)
 800d8d6:	078f      	lsls	r7, r1, #30
    CLEAR_BIT(*Reg, Bit);
 800d8d8:	bf4c      	ite	mi
 800d8da:	f423 0300 	bicmi.w	r3, r3, #8388608	; 0x800000
    SET_BIT(*Reg, Bit);
 800d8de:	f443 0300 	orrpl.w	r3, r3, #8388608	; 0x800000
  if ((SecureMode & ValueEnable) == ValueEnable)
 800d8e2:	074e      	lsls	r6, r1, #29
    CLEAR_BIT(*Reg, Bit);
 800d8e4:	bf4c      	ite	mi
 800d8e6:	f022 4280 	bicmi.w	r2, r2, #1073741824	; 0x40000000
    SET_BIT(*Reg, Bit);
 800d8ea:	f042 4280 	orrpl.w	r2, r2, #1073741824	; 0x40000000
  if ((SecureMode & ValueEnable) == ValueEnable)
 800d8ee:	0709      	lsls	r1, r1, #28
    CLEAR_BIT(*Reg, Bit);
 800d8f0:	bf4c      	ite	mi
 800d8f2:	f422 0200 	bicmi.w	r2, r2, #8388608	; 0x800000
    SET_BIT(*Reg, Bit);
 800d8f6:	f442 0200 	orrpl.w	r2, r2, #8388608	; 0x800000
 800d8fa:	e776      	b.n	800d7ea <HAL_FLASHEx_OBProgram+0x106>
  __HAL_LOCK(&pFlash);
 800d8fc:	2002      	movs	r0, #2
 800d8fe:	e7b3      	b.n	800d868 <HAL_FLASHEx_OBProgram+0x184>
 800d900:	20003c44 	.word	0x20003c44
 800d904:	58004000 	.word	0x58004000
 800d908:	80000001 	.word	0x80000001
 800d90c:	7fff0000 	.word	0x7fff0000
 800d910:	cf8f7000 	.word	0xcf8f7000

0800d914 <HAL_FLASHEx_OBGetConfig>:
  if ((pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAA) || (pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAB))
 800d914:	6842      	ldr	r2, [r0, #4]
  pOBInit->OptionType = OPTIONBYTE_ALL;
 800d916:	f640 731f 	movw	r3, #3871	; 0xf1f
  if ((pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAA) || (pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAB))
 800d91a:	2a01      	cmp	r2, #1
{
 800d91c:	b510      	push	{r4, lr}
  pOBInit->OptionType = OPTIONBYTE_ALL;
 800d91e:	6003      	str	r3, [r0, #0]
  if ((pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAA) || (pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAB))
 800d920:	d80b      	bhi.n	800d93a <HAL_FLASHEx_OBGetConfig+0x26>
  if (WRPArea == OB_WRPAREA_BANK1_AREAA)
 800d922:	4b4e      	ldr	r3, [pc, #312]	; (800da5c <HAL_FLASHEx_OBGetConfig+0x148>)
 800d924:	2a00      	cmp	r2, #0
 800d926:	f040 8092 	bne.w	800da4e <HAL_FLASHEx_OBGetConfig+0x13a>
    *WRPStartOffset = READ_BIT(FLASH->WRP1AR, FLASH_WRP1AR_WRP1A_STRT);
 800d92a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800d92c:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 800d930:	6082      	str	r2, [r0, #8]
    *WRDPEndOffset = (READ_BIT(FLASH->WRP1AR, FLASH_WRP1AR_WRP1A_END) >> FLASH_WRP1AR_WRP1A_END_Pos);
 800d932:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    *WRDPEndOffset = (READ_BIT(FLASH->WRP1BR, FLASH_WRP1BR_WRP1B_END) >> FLASH_WRP1BR_WRP1B_END_Pos);
 800d934:	f3c3 4306 	ubfx	r3, r3, #16, #7
 800d938:	60c3      	str	r3, [r0, #12]
  uint32_t rdplvl = READ_BIT(FLASH->OPTR, FLASH_OPTR_RDP);
 800d93a:	4b48      	ldr	r3, [pc, #288]	; (800da5c <HAL_FLASHEx_OBGetConfig+0x148>)
 800d93c:	6a1a      	ldr	r2, [r3, #32]
 800d93e:	b2d2      	uxtb	r2, r2
  if ((rdplvl != OB_RDP_LEVEL_0) && (rdplvl != OB_RDP_LEVEL_2))
 800d940:	2aaa      	cmp	r2, #170	; 0xaa
 800d942:	d002      	beq.n	800d94a <HAL_FLASHEx_OBGetConfig+0x36>
    return (OB_RDP_LEVEL_1);
 800d944:	2acc      	cmp	r2, #204	; 0xcc
 800d946:	bf18      	it	ne
 800d948:	22bb      	movne	r2, #187	; 0xbb
  pOBInit->RDPLevel = FLASH_OB_GetRDP();
 800d94a:	6102      	str	r2, [r0, #16]
  uint32_t user_config = (READ_REG(FLASH->OPTR) & OB_USER_ALL);
 800d94c:	6a1a      	ldr	r2, [r3, #32]
 800d94e:	4944      	ldr	r1, [pc, #272]	; (800da60 <HAL_FLASHEx_OBGetConfig+0x14c>)
 800d950:	400a      	ands	r2, r1
  pOBInit->UserType = OB_USER_ALL;
 800d952:	e9c0 1205 	strd	r1, r2, [r0, #20]
  pcrop             = (READ_BIT(FLASH->PCROP1BSR, FLASH_PCROP1BSR_PCROP1B_STRT));
 800d956:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  *PCROP1BStartAddr = ((pcrop << FLASH_PCROP_GRANULARITY_OFFSET) + FLASH_BASE);
 800d958:	0292      	lsls	r2, r2, #10
 800d95a:	f402 327f 	and.w	r2, r2, #261120	; 0x3fc00
 800d95e:	f102 6200 	add.w	r2, r2, #134217728	; 0x8000000
 800d962:	6282      	str	r2, [r0, #40]	; 0x28
  pcrop             = (READ_BIT(FLASH->PCROP1BER, FLASH_PCROP1BER_PCROP1B_END));
 800d964:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  *PCROP1BEndAddr   = ((pcrop << FLASH_PCROP_GRANULARITY_OFFSET) + FLASH_BASE);
 800d966:	0292      	lsls	r2, r2, #10
 800d968:	f402 327f 	and.w	r2, r2, #261120	; 0x3fc00
 800d96c:	f102 6200 	add.w	r2, r2, #134217728	; 0x8000000
 800d970:	62c2      	str	r2, [r0, #44]	; 0x2c
  pcrop             = (READ_BIT(FLASH->PCROP1ASR, FLASH_PCROP1ASR_PCROP1A_STRT));
 800d972:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  *PCROP1AStartAddr = ((pcrop << FLASH_PCROP_GRANULARITY_OFFSET) + FLASH_BASE);
 800d974:	0292      	lsls	r2, r2, #10
 800d976:	f402 327f 	and.w	r2, r2, #261120	; 0x3fc00
 800d97a:	f102 6200 	add.w	r2, r2, #134217728	; 0x8000000
 800d97e:	6202      	str	r2, [r0, #32]
  pcrop             = (READ_BIT(FLASH->PCROP1AER, FLASH_PCROP1AER_PCROP1A_END));
 800d980:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  *PCROP1AEndAddr   = ((pcrop << FLASH_PCROP_GRANULARITY_OFFSET) + FLASH_BASE);
 800d982:	0292      	lsls	r2, r2, #10
 800d984:	f402 327f 	and.w	r2, r2, #261120	; 0x3fc00
 800d988:	f102 6200 	add.w	r2, r2, #134217728	; 0x8000000
 800d98c:	6242      	str	r2, [r0, #36]	; 0x24
  *PCROPConfig      = (READ_REG(FLASH->PCROP1AER) & FLASH_PCROP1AER_PCROP_RDP);
 800d98e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800d990:	f002 4200 	and.w	r2, r2, #2147483648	; 0x80000000
  pOBInit->PCROPConfig |= (OB_PCROP_ZONE_A | OB_PCROP_ZONE_B);
 800d994:	f042 0203 	orr.w	r2, r2, #3
 800d998:	61c2      	str	r2, [r0, #28]
  return (uint32_t)((READ_BIT(FLASH->IPCCBR, FLASH_IPCCBR_IPCCDBA) << 4) + SRAM1_BASE);
 800d99a:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 800d99c:	4a31      	ldr	r2, [pc, #196]	; (800da64 <HAL_FLASHEx_OBGetConfig+0x150>)
 800d99e:	ea02 1201 	and.w	r2, r2, r1, lsl #4
 800d9a2:	f102 5200 	add.w	r2, r2, #536870912	; 0x20000000
  pOBInit->IPCCdataBufAddr = FLASH_OB_GetIPCCBufferAddr();
 800d9a6:	6542      	str	r2, [r0, #84]	; 0x54
  uint32_t sfr_reg_val = READ_REG(FLASH->SFR);
 800d9a8:	f8d3 1080 	ldr.w	r1, [r3, #128]	; 0x80
  uint32_t srrvr_reg_val = READ_REG(FLASH->SRRVR);
 800d9ac:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
  uint32_t user_config = (READ_BIT(sfr_reg_val, FLASH_SFR_SFSA) >> FLASH_SFR_SFSA_Pos);
 800d9b0:	f001 037f 	and.w	r3, r1, #127	; 0x7f
  *SecureFlashStartAddr = ((user_config * FLASH_PAGE_SIZE) + FLASH_BASE);
 800d9b4:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 800d9b8:	02db      	lsls	r3, r3, #11
 800d9ba:	6303      	str	r3, [r0, #48]	; 0x30
  user_config = (READ_BIT(sfr_reg_val, FLASH_SFR_HDPSA) >> FLASH_SFR_HDPSA_Pos);
 800d9bc:	f3c1 4306 	ubfx	r3, r1, #16, #7
  *HideProtectionStartAddr = ((user_config * FLASH_PAGE_SIZE) + FLASH_BASE);
 800d9c0:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 800d9c4:	02db      	lsls	r3, r3, #11
 800d9c6:	63c3      	str	r3, [r0, #60]	; 0x3c
  *SecureSRAM2StartAddr = ((user_config << SRAM_SECURE_PAGE_GRANULARITY_OFFSET) + SRAM2_BASE);
 800d9c8:	0a13      	lsrs	r3, r2, #8
 800d9ca:	f403 43f8 	and.w	r3, r3, #31744	; 0x7c00
 800d9ce:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 800d9d2:	f503 4300 	add.w	r3, r3, #32768	; 0x8000
 800d9d6:	6343      	str	r3, [r0, #52]	; 0x34
  *SecureSRAM1StartAddr = ((user_config << SRAM_SECURE_PAGE_GRANULARITY_OFFSET) + SRAM1_BASE);
 800d9d8:	0bd3      	lsrs	r3, r2, #15
  {
    return ValueEnable;
  }
  else
  {
    return ValueDisable;
 800d9da:	f011 0f80 	tst.w	r1, #128	; 0x80
  *SecureSRAM1StartAddr = ((user_config << SRAM_SECURE_PAGE_GRANULARITY_OFFSET) + SRAM1_BASE);
 800d9de:	f403 43f8 	and.w	r3, r3, #31744	; 0x7c00
 800d9e2:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
    return ValueDisable;
 800d9e6:	bf0c      	ite	eq
 800d9e8:	2401      	moveq	r4, #1
 800d9ea:	2410      	movne	r4, #16
 800d9ec:	f411 0f00 	tst.w	r1, #8388608	; 0x800000
  *SecureSRAM1StartAddr = ((user_config << SRAM_SECURE_PAGE_GRANULARITY_OFFSET) + SRAM1_BASE);
 800d9f0:	6383      	str	r3, [r0, #56]	; 0x38
    return ValueDisable;
 800d9f2:	bf0c      	ite	eq
 800d9f4:	2302      	moveq	r3, #2
 800d9f6:	2320      	movne	r3, #32
 800d9f8:	f012 4f80 	tst.w	r2, #1073741824	; 0x40000000
 800d9fc:	bf0c      	ite	eq
 800d9fe:	2104      	moveq	r1, #4
 800da00:	2140      	movne	r1, #64	; 0x40
  *SecureMode = (FLASH_OB_GetSecureMode(sfr_reg_val, FLASH_SFR_FSD, OB_SECURE_SYSTEM_AND_FLASH_ENABLE, OB_SECURE_SYSTEM_AND_FLASH_DISABLE) | \
 800da02:	4323      	orrs	r3, r4
    return ValueDisable;
 800da04:	f412 0f00 	tst.w	r2, #8388608	; 0x800000
 800da08:	bf0c      	ite	eq
 800da0a:	2208      	moveq	r2, #8
 800da0c:	2280      	movne	r2, #128	; 0x80
                 FLASH_OB_GetSecureMode(sfr_reg_val, FLASH_SFR_HDPAD, OB_SECURE_HIDE_PROTECTION_ENABLE, OB_SECURE_HIDE_PROTECTION_DISABLE) | \
 800da0e:	430b      	orrs	r3, r1
                 FLASH_OB_GetSecureMode(srrvr_reg_val, FLASH_SRRVR_NBRSD, OB_SECURE_SRAM1_ENABLE, OB_SECURE_SRAM1_DISABLE)                 | \
 800da10:	4313      	orrs	r3, r2
  *C2BootResetRegion = (READ_BIT(FLASH->SRRVR, FLASH_SRRVR_C2OPT));
 800da12:	4a12      	ldr	r2, [pc, #72]	; (800da5c <HAL_FLASHEx_OBGetConfig+0x148>)
  *SecureMode = (FLASH_OB_GetSecureMode(sfr_reg_val, FLASH_SFR_FSD, OB_SECURE_SYSTEM_AND_FLASH_ENABLE, OB_SECURE_SYSTEM_AND_FLASH_DISABLE) | \
 800da14:	6403      	str	r3, [r0, #64]	; 0x40
  *C2BootResetRegion = (READ_BIT(FLASH->SRRVR, FLASH_SRRVR_C2OPT));
 800da16:	f8d2 3084 	ldr.w	r3, [r2, #132]	; 0x84
 800da1a:	f003 4100 	and.w	r1, r3, #2147483648	; 0x80000000
 800da1e:	64c1      	str	r1, [r0, #76]	; 0x4c
    *C2BootResetVectAddr = (uint32_t)((READ_BIT(FLASH->SRRVR, FLASH_SRRVR_SBRV) << 2) + FLASH_BASE);
 800da20:	f8d2 1084 	ldr.w	r1, [r2, #132]	; 0x84
  if (*C2BootResetRegion == OB_C2_BOOT_FROM_FLASH)
 800da24:	2b00      	cmp	r3, #0
 800da26:	4b10      	ldr	r3, [pc, #64]	; (800da68 <HAL_FLASHEx_OBGetConfig+0x154>)
    *C2BootResetVectAddr = (uint32_t)((READ_BIT(FLASH->SRRVR, FLASH_SRRVR_SBRV) << 2) + FLASH_BASE);
 800da28:	ea03 0381 	and.w	r3, r3, r1, lsl #2
 800da2c:	bfb4      	ite	lt
 800da2e:	f103 6300 	addlt.w	r3, r3, #134217728	; 0x8000000
    *C2BootResetVectAddr = (uint32_t)((READ_BIT(FLASH->SRRVR, FLASH_SRRVR_SBRV) << 2) + SRAM1_BASE);
 800da32:	f103 5300 	addge.w	r3, r3, #536870912	; 0x20000000
 800da36:	6503      	str	r3, [r0, #80]	; 0x50
  return (READ_BIT(FLASH->SFR, FLASH_SFR_SUBGHZSPISD));
 800da38:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
 800da3c:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
  pOBInit->SUBGHZSPISecureAccess = FLASH_OB_GetSUBGHZSPISecureAccess();
 800da40:	6443      	str	r3, [r0, #68]	; 0x44
  return (READ_BIT(FLASH->SFR, FLASH_SFR_DDS));
 800da42:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
 800da46:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
  pOBInit->C2DebugAccessMode = FLASH_OB_GetC2DebugAccessMode();
 800da4a:	6483      	str	r3, [r0, #72]	; 0x48
}
 800da4c:	bd10      	pop	{r4, pc}
    *WRPStartOffset = READ_BIT(FLASH->WRP1BR, FLASH_WRP1BR_WRP1B_STRT);
 800da4e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800da50:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 800da54:	6082      	str	r2, [r0, #8]
    *WRDPEndOffset = (READ_BIT(FLASH->WRP1BR, FLASH_WRP1BR_WRP1B_END) >> FLASH_WRP1BR_WRP1B_END_Pos);
 800da56:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800da58:	e76c      	b.n	800d934 <HAL_FLASHEx_OBGetConfig+0x20>
 800da5a:	bf00      	nop
 800da5c:	58004000 	.word	0x58004000
 800da60:	cf8f7e00 	.word	0xcf8f7e00
 800da64:	0003fff0 	.word	0x0003fff0
 800da68:	0003fffc 	.word	0x0003fffc

0800da6c <FLASH_PageErase>:
  MODIFY_REG(FLASH->CR, FLASH_CR_PNB, ((Page << FLASH_CR_PNB_Pos) | FLASH_CR_PER | FLASH_CR_STRT));
 800da6c:	4a05      	ldr	r2, [pc, #20]	; (800da84 <FLASH_PageErase+0x18>)
 800da6e:	6953      	ldr	r3, [r2, #20]
 800da70:	f423 737e 	bic.w	r3, r3, #1016	; 0x3f8
 800da74:	ea43 00c0 	orr.w	r0, r3, r0, lsl #3
 800da78:	f440 3080 	orr.w	r0, r0, #65536	; 0x10000
 800da7c:	f040 0002 	orr.w	r0, r0, #2
 800da80:	6150      	str	r0, [r2, #20]
}
 800da82:	4770      	bx	lr
 800da84:	58004000 	.word	0x58004000

0800da88 <HAL_FLASHEx_Erase>:
{
 800da88:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __HAL_LOCK(&pFlash);
 800da8c:	4d23      	ldr	r5, [pc, #140]	; (800db1c <HAL_FLASHEx_Erase+0x94>)
 800da8e:	782b      	ldrb	r3, [r5, #0]
 800da90:	2b01      	cmp	r3, #1
{
 800da92:	4606      	mov	r6, r0
 800da94:	4688      	mov	r8, r1
  __HAL_LOCK(&pFlash);
 800da96:	d03f      	beq.n	800db18 <HAL_FLASHEx_Erase+0x90>
 800da98:	2301      	movs	r3, #1
 800da9a:	702b      	strb	r3, [r5, #0]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 800da9c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 800daa0:	2300      	movs	r3, #0
 800daa2:	606b      	str	r3, [r5, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 800daa4:	f7ff fdb8 	bl	800d618 <FLASH_WaitForLastOperation>
  if (status == HAL_OK)
 800daa8:	4604      	mov	r4, r0
 800daaa:	b988      	cbnz	r0, 800dad0 <HAL_FLASHEx_Erase+0x48>
    if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 800daac:	6833      	ldr	r3, [r6, #0]
 800daae:	2b04      	cmp	r3, #4
 800dab0:	d113      	bne.n	800dada <HAL_FLASHEx_Erase+0x52>
  SET_BIT(FLASH->CR, (FLASH_CR_MER | FLASH_CR_STRT));
 800dab2:	4a1b      	ldr	r2, [pc, #108]	; (800db20 <HAL_FLASHEx_Erase+0x98>)
 800dab4:	6953      	ldr	r3, [r2, #20]
 800dab6:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800daba:	f043 0304 	orr.w	r3, r3, #4
 800dabe:	6153      	str	r3, [r2, #20]
      status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 800dac0:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800dac4:	f7ff fda8 	bl	800d618 <FLASH_WaitForLastOperation>
 800dac8:	4604      	mov	r4, r0
  if (READ_BIT(FLASH->ACR, FLASH_ACR_ICEN) == 1U)
 800daca:	4b15      	ldr	r3, [pc, #84]	; (800db20 <HAL_FLASHEx_Erase+0x98>)
 800dacc:	681a      	ldr	r2, [r3, #0]
  if (READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) == 1U)
 800dace:	681b      	ldr	r3, [r3, #0]
  __HAL_UNLOCK(&pFlash);
 800dad0:	2300      	movs	r3, #0
 800dad2:	702b      	strb	r3, [r5, #0]
}
 800dad4:	4620      	mov	r0, r4
 800dad6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      *PageError = 0xFFFFFFFFU;
 800dada:	f04f 33ff 	mov.w	r3, #4294967295
 800dade:	f8c8 3000 	str.w	r3, [r8]
      for (index = pEraseInit->Page; index < (pEraseInit->Page + pEraseInit->NbPages); index++)
 800dae2:	6877      	ldr	r7, [r6, #4]
 800dae4:	e9d6 3201 	ldrd	r3, r2, [r6, #4]
 800dae8:	4413      	add	r3, r2
 800daea:	42bb      	cmp	r3, r7
 800daec:	d90a      	bls.n	800db04 <HAL_FLASHEx_Erase+0x7c>
        FLASH_PageErase(index);
 800daee:	4638      	mov	r0, r7
 800daf0:	f7ff ffbc 	bl	800da6c <FLASH_PageErase>
        status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 800daf4:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800daf8:	f7ff fd8e 	bl	800d618 <FLASH_WaitForLastOperation>
        if (status != HAL_OK)
 800dafc:	b150      	cbz	r0, 800db14 <HAL_FLASHEx_Erase+0x8c>
          *PageError = index;
 800dafe:	f8c8 7000 	str.w	r7, [r8]
        status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 800db02:	4604      	mov	r4, r0
  CLEAR_BIT(FLASH->CR, (FLASH_CR_PER | FLASH_CR_PNB));
 800db04:	4a06      	ldr	r2, [pc, #24]	; (800db20 <HAL_FLASHEx_Erase+0x98>)
 800db06:	6953      	ldr	r3, [r2, #20]
 800db08:	f423 737e 	bic.w	r3, r3, #1016	; 0x3f8
 800db0c:	f023 0302 	bic.w	r3, r3, #2
 800db10:	6153      	str	r3, [r2, #20]
}
 800db12:	e7da      	b.n	800daca <HAL_FLASHEx_Erase+0x42>
      for (index = pEraseInit->Page; index < (pEraseInit->Page + pEraseInit->NbPages); index++)
 800db14:	3701      	adds	r7, #1
 800db16:	e7e5      	b.n	800dae4 <HAL_FLASHEx_Erase+0x5c>
  __HAL_LOCK(&pFlash);
 800db18:	2402      	movs	r4, #2
 800db1a:	e7db      	b.n	800dad4 <HAL_FLASHEx_Erase+0x4c>
 800db1c:	20003c44 	.word	0x20003c44
 800db20:	58004000 	.word	0x58004000

0800db24 <HAL_GPIO_Init>:
  * @param GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 800db24:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

        /* Clear EXTI line configuration */
#ifdef CORE_CM0PLUS
        temp = EXTI->C2IMR1;
#else
        temp = EXTI->IMR1;
 800db28:	4c52      	ldr	r4, [pc, #328]	; (800dc74 <HAL_GPIO_Init+0x150>)
  uint32_t position = 0x00u;
 800db2a:	2300      	movs	r3, #0
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 800db2c:	f04f 090f 	mov.w	r9, #15
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 800db30:	680a      	ldr	r2, [r1, #0]
 800db32:	fa32 f503 	lsrs.w	r5, r2, r3
 800db36:	d101      	bne.n	800db3c <HAL_GPIO_Init+0x18>
      }
    }

    position++;
  }
}
 800db38:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 800db3c:	2501      	movs	r5, #1
 800db3e:	fa05 f803 	lsl.w	r8, r5, r3
    if (iocurrent != 0x00u)
 800db42:	ea18 0202 	ands.w	r2, r8, r2
 800db46:	f000 808f 	beq.w	800dc68 <HAL_GPIO_Init+0x144>
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 800db4a:	684e      	ldr	r6, [r1, #4]
 800db4c:	2703      	movs	r7, #3
 800db4e:	f006 0503 	and.w	r5, r6, #3
 800db52:	ea4f 0e43 	mov.w	lr, r3, lsl #1
 800db56:	fa07 fc0e 	lsl.w	ip, r7, lr
 800db5a:	1e6f      	subs	r7, r5, #1
 800db5c:	2f01      	cmp	r7, #1
 800db5e:	ea6f 0c0c 	mvn.w	ip, ip
 800db62:	d832      	bhi.n	800dbca <HAL_GPIO_Init+0xa6>
        temp = GPIOx->OSPEEDR;
 800db64:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 800db66:	ea07 0a0c 	and.w	sl, r7, ip
        temp |= (GPIO_Init->Speed << (position * 2U));
 800db6a:	68cf      	ldr	r7, [r1, #12]
 800db6c:	fa07 f70e 	lsl.w	r7, r7, lr
 800db70:	ea47 070a 	orr.w	r7, r7, sl
        GPIOx->OSPEEDR = temp;
 800db74:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 800db76:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 800db78:	ea27 0808 	bic.w	r8, r7, r8
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 800db7c:	f3c6 1700 	ubfx	r7, r6, #4, #1
 800db80:	409f      	lsls	r7, r3
 800db82:	ea47 0708 	orr.w	r7, r7, r8
        GPIOx->OTYPER = temp;
 800db86:	6047      	str	r7, [r0, #4]
        temp = GPIOx->PUPDR;
 800db88:	68c7      	ldr	r7, [r0, #12]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 800db8a:	ea07 080c 	and.w	r8, r7, ip
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 800db8e:	688f      	ldr	r7, [r1, #8]
 800db90:	fa07 f70e 	lsl.w	r7, r7, lr
 800db94:	ea47 0708 	orr.w	r7, r7, r8
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 800db98:	2d02      	cmp	r5, #2
        GPIOx->PUPDR = temp;
 800db9a:	60c7      	str	r7, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 800db9c:	d117      	bne.n	800dbce <HAL_GPIO_Init+0xaa>
        temp = GPIOx->AFR[position >> 3U];
 800db9e:	ea4f 08d3 	mov.w	r8, r3, lsr #3
 800dba2:	eb00 0888 	add.w	r8, r0, r8, lsl #2
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 800dba6:	f003 0a07 	and.w	sl, r3, #7
        temp = GPIOx->AFR[position >> 3U];
 800dbaa:	f8d8 7020 	ldr.w	r7, [r8, #32]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 800dbae:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 800dbb2:	fa09 fb0a 	lsl.w	fp, r9, sl
 800dbb6:	ea27 0b0b 	bic.w	fp, r7, fp
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 800dbba:	690f      	ldr	r7, [r1, #16]
 800dbbc:	fa07 f70a 	lsl.w	r7, r7, sl
 800dbc0:	ea47 070b 	orr.w	r7, r7, fp
        GPIOx->AFR[position >> 3u] = temp;
 800dbc4:	f8c8 7020 	str.w	r7, [r8, #32]
 800dbc8:	e001      	b.n	800dbce <HAL_GPIO_Init+0xaa>
      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 800dbca:	2d03      	cmp	r5, #3
 800dbcc:	d1dc      	bne.n	800db88 <HAL_GPIO_Init+0x64>
      temp = GPIOx->MODER;
 800dbce:	6807      	ldr	r7, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 800dbd0:	ea07 0c0c 	and.w	ip, r7, ip
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 800dbd4:	fa05 f70e 	lsl.w	r7, r5, lr
 800dbd8:	ea47 070c 	orr.w	r7, r7, ip
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 800dbdc:	f416 3f40 	tst.w	r6, #196608	; 0x30000
      GPIOx->MODER = temp;
 800dbe0:	6007      	str	r7, [r0, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 800dbe2:	d041      	beq.n	800dc68 <HAL_GPIO_Init+0x144>
        temp = SYSCFG->EXTICR[position >> 2u];
 800dbe4:	f023 0703 	bic.w	r7, r3, #3
 800dbe8:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
 800dbec:	f507 3780 	add.w	r7, r7, #65536	; 0x10000
        temp &= ~(0x07uL << (4U * (position & 0x03U)));
 800dbf0:	f003 0c03 	and.w	ip, r3, #3
        temp = SYSCFG->EXTICR[position >> 2u];
 800dbf4:	68bd      	ldr	r5, [r7, #8]
        temp &= ~(0x07uL << (4U * (position & 0x03U)));
 800dbf6:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 800dbfa:	f04f 0e07 	mov.w	lr, #7
 800dbfe:	fa0e fe0c 	lsl.w	lr, lr, ip
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 800dc02:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
        temp &= ~(0x07uL << (4U * (position & 0x03U)));
 800dc06:	ea25 0e0e 	bic.w	lr, r5, lr
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 800dc0a:	d02f      	beq.n	800dc6c <HAL_GPIO_Init+0x148>
 800dc0c:	4d1a      	ldr	r5, [pc, #104]	; (800dc78 <HAL_GPIO_Init+0x154>)
 800dc0e:	42a8      	cmp	r0, r5
 800dc10:	d02e      	beq.n	800dc70 <HAL_GPIO_Init+0x14c>
 800dc12:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 800dc16:	42a8      	cmp	r0, r5
 800dc18:	bf0c      	ite	eq
 800dc1a:	2502      	moveq	r5, #2
 800dc1c:	2507      	movne	r5, #7
 800dc1e:	fa05 f50c 	lsl.w	r5, r5, ip
 800dc22:	ea45 050e 	orr.w	r5, r5, lr
        SYSCFG->EXTICR[position >> 2u] = temp;
 800dc26:	60bd      	str	r5, [r7, #8]
        temp = EXTI->IMR1;
 800dc28:	f8d4 5080 	ldr.w	r5, [r4, #128]	; 0x80
        temp &= ~(iocurrent);
 800dc2c:	43d7      	mvns	r7, r2
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00u)
 800dc2e:	f416 3f80 	tst.w	r6, #65536	; 0x10000
        temp &= ~(iocurrent);
 800dc32:	bf0c      	ite	eq
 800dc34:	403d      	andeq	r5, r7
          temp |= iocurrent;
 800dc36:	4315      	orrne	r5, r2
        EXTI->IMR1 = temp;
 800dc38:	f8c4 5080 	str.w	r5, [r4, #128]	; 0x80
        temp = EXTI->EMR1;
 800dc3c:	f8d4 5084 	ldr.w	r5, [r4, #132]	; 0x84
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
 800dc40:	f416 3f00 	tst.w	r6, #131072	; 0x20000
        temp &= ~(iocurrent);
 800dc44:	bf0c      	ite	eq
 800dc46:	403d      	andeq	r5, r7
          temp |= iocurrent;
 800dc48:	4315      	orrne	r5, r2
        EXTI->EMR1 = temp;
 800dc4a:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
        temp = EXTI->RTSR1;
 800dc4e:	6825      	ldr	r5, [r4, #0]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
 800dc50:	f416 1f80 	tst.w	r6, #1048576	; 0x100000
        temp &= ~(iocurrent);
 800dc54:	bf0c      	ite	eq
 800dc56:	403d      	andeq	r5, r7
          temp |= iocurrent;
 800dc58:	4315      	orrne	r5, r2
        EXTI->RTSR1 = temp;
 800dc5a:	6025      	str	r5, [r4, #0]
        temp = EXTI->FTSR1;
 800dc5c:	6865      	ldr	r5, [r4, #4]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
 800dc5e:	02b6      	lsls	r6, r6, #10
        temp &= ~(iocurrent);
 800dc60:	bf54      	ite	pl
 800dc62:	403d      	andpl	r5, r7
          temp |= iocurrent;
 800dc64:	4315      	orrmi	r5, r2
        EXTI->FTSR1 = temp;
 800dc66:	6065      	str	r5, [r4, #4]
    position++;
 800dc68:	3301      	adds	r3, #1
 800dc6a:	e761      	b.n	800db30 <HAL_GPIO_Init+0xc>
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 800dc6c:	2500      	movs	r5, #0
 800dc6e:	e7d6      	b.n	800dc1e <HAL_GPIO_Init+0xfa>
 800dc70:	2501      	movs	r5, #1
 800dc72:	e7d4      	b.n	800dc1e <HAL_GPIO_Init+0xfa>
 800dc74:	58000800 	.word	0x58000800
 800dc78:	48000400 	.word	0x48000400

0800dc7c <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != 0x00u)
 800dc7c:	6903      	ldr	r3, [r0, #16]
 800dc7e:	4219      	tst	r1, r3
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
}
 800dc80:	bf14      	ite	ne
 800dc82:	2001      	movne	r0, #1
 800dc84:	2000      	moveq	r0, #0
 800dc86:	4770      	bx	lr

0800dc88 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 800dc88:	b10a      	cbz	r2, 800dc8e <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 800dc8a:	6181      	str	r1, [r0, #24]
 800dc8c:	4770      	bx	lr
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 800dc8e:	6281      	str	r1, [r0, #40]	; 0x28
  }
}
 800dc90:	4770      	bx	lr

0800dc92 <HAL_GPIO_TogglePin>:

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
 800dc92:	6943      	ldr	r3, [r0, #20]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
 800dc94:	ea01 0203 	and.w	r2, r1, r3
 800dc98:	ea21 0103 	bic.w	r1, r1, r3
 800dc9c:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 800dca0:	6181      	str	r1, [r0, #24]
}
 800dca2:	4770      	bx	lr

0800dca4 <HAL_PWR_EnableBkUpAccess>:
  *         backup domain.
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
 800dca4:	4a02      	ldr	r2, [pc, #8]	; (800dcb0 <HAL_PWR_EnableBkUpAccess+0xc>)
 800dca6:	6813      	ldr	r3, [r2, #0]
 800dca8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800dcac:	6013      	str	r3, [r2, #0]
}
 800dcae:	4770      	bx	lr
 800dcb0:	58000400 	.word	0x58000400

0800dcb4 <HAL_PWREx_GetVoltageRange>:
  * @brief Return Voltage Scaling Range.
  * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_SCALE1 or PWPWR_REGULATOR_VOLTAGE_SCALE2)
  */
uint32_t HAL_PWREx_GetVoltageRange(void)
{
  return (PWR->CR1 & PWR_CR1_VOS);
 800dcb4:	4b02      	ldr	r3, [pc, #8]	; (800dcc0 <HAL_PWREx_GetVoltageRange+0xc>)
 800dcb6:	6818      	ldr	r0, [r3, #0]
}
 800dcb8:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
 800dcbc:	4770      	bx	lr
 800dcbe:	bf00      	nop
 800dcc0:	58000400 	.word	0x58000400

0800dcc4 <LL_RCC_HSE_IsReady>:
  return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
 800dcc4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800dcc8:	6818      	ldr	r0, [r3, #0]
}
 800dcca:	f3c0 4040 	ubfx	r0, r0, #17, #1
 800dcce:	4770      	bx	lr

0800dcd0 <LL_RCC_HSI_IsReady>:
  return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
 800dcd0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800dcd4:	6818      	ldr	r0, [r3, #0]
}
 800dcd6:	f3c0 2080 	ubfx	r0, r0, #10, #1
 800dcda:	4770      	bx	lr

0800dcdc <LL_RCC_MSI_IsReady>:
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRDY) == (RCC_CR_MSIRDY)) ? 1UL : 0UL);
 800dcdc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800dce0:	6818      	ldr	r0, [r3, #0]
}
 800dce2:	f3c0 0040 	ubfx	r0, r0, #1, #1
 800dce6:	4770      	bx	lr

0800dce8 <LL_RCC_MSI_SetCalibTrimming>:
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_MSITRIM, Value << RCC_ICSCR_MSITRIM_Pos);
 800dce8:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800dcec:	6853      	ldr	r3, [r2, #4]
 800dcee:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 800dcf2:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 800dcf6:	6053      	str	r3, [r2, #4]
}
 800dcf8:	4770      	bx	lr

0800dcfa <LL_RCC_PLL_IsReady>:
  return ((READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY)) ? 1UL : 0UL);
 800dcfa:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800dcfe:	6818      	ldr	r0, [r3, #0]
}
 800dd00:	f3c0 6040 	ubfx	r0, r0, #25, #1
 800dd04:	4770      	bx	lr
	...

0800dd08 <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  MSI_Range  MSI range value from @ref RCC_MSIRANGE_0 to @ref RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t MSI_Range)
{
 800dd08:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  return (uint32_t)(READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPRE) << 4);
 800dd0a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
  uint32_t flash_clksrcfreq;
  uint32_t msifreq;

  /* MSI frequency range in Hz */
  msifreq           = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSIRANGESEL_RUN, MSI_Range);
  flash_clksrcfreq  = __LL_RCC_CALC_HCLK3_FREQ(msifreq, LL_RCC_GetAHB3Prescaler());
 800dd0e:	4a2c      	ldr	r2, [pc, #176]	; (800ddc0 <RCC_SetFlashLatencyFromMSIRange+0xb8>)
 800dd10:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
  msifreq           = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSIRANGESEL_RUN, MSI_Range);
 800dd14:	f3c0 1003 	ubfx	r0, r0, #4, #4
  flash_clksrcfreq  = __LL_RCC_CALC_HCLK3_FREQ(msifreq, LL_RCC_GetAHB3Prescaler());
 800dd18:	f003 030f 	and.w	r3, r3, #15
 800dd1c:	f852 4020 	ldr.w	r4, [r2, r0, lsl #2]
 800dd20:	4a28      	ldr	r2, [pc, #160]	; (800ddc4 <RCC_SetFlashLatencyFromMSIRange+0xbc>)
 800dd22:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800dd26:	fbb4 f4f3 	udiv	r4, r4, r3

  return RCC_SetFlashLatency((flash_clksrcfreq / MEGA_HZ), HAL_PWREx_GetVoltageRange());
 800dd2a:	f7ff ffc3 	bl	800dcb4 <HAL_PWREx_GetVoltageRange>

  /* Flash Clock source (HCLK3) range in MHz for VCORE range2 */
  const uint16_t FLASH_CLK_SRC_RANGE_VOS2[] = {6, 12, 16};

  /* Flash Latency range */
  const uint32_t FLASH_LATENCY_RANGE[] = {FLASH_LATENCY_0, FLASH_LATENCY_1, FLASH_LATENCY_2};
 800dd2e:	4b26      	ldr	r3, [pc, #152]	; (800ddc8 <RCC_SetFlashLatencyFromMSIRange+0xc0>)
  return RCC_SetFlashLatency((flash_clksrcfreq / MEGA_HZ), HAL_PWREx_GetVoltageRange());
 800dd30:	4605      	mov	r5, r0
  const uint32_t FLASH_LATENCY_RANGE[] = {FLASH_LATENCY_0, FLASH_LATENCY_1, FLASH_LATENCY_2};
 800dd32:	e893 0007 	ldmia.w	r3, {r0, r1, r2}

  uint32_t latency   = FLASH_LATENCY_0;  /* default value 0WS */
  uint32_t tickstart;

  if (VCORE_Voltage == PWR_REGULATOR_VOLTAGE_SCALE1)
 800dd36:	f5b5 7f00 	cmp.w	r5, #512	; 0x200
  const uint32_t FLASH_LATENCY_RANGE[] = {FLASH_LATENCY_0, FLASH_LATENCY_1, FLASH_LATENCY_2};
 800dd3a:	ab04      	add	r3, sp, #16
 800dd3c:	e903 0007 	stmdb	r3, {r0, r1, r2}
  if (VCORE_Voltage == PWR_REGULATOR_VOLTAGE_SCALE1)
 800dd40:	d010      	beq.n	800dd64 <RCC_SetFlashLatencyFromMSIRange+0x5c>
  }
  else  /* PWR_REGULATOR_VOLTAGE_SCALE2 */
  {
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
    {
      if (Flash_ClkSrcFreq <= FLASH_CLK_SRC_RANGE_VOS2[index])
 800dd42:	4b22      	ldr	r3, [pc, #136]	; (800ddcc <RCC_SetFlashLatencyFromMSIRange+0xc4>)
 800dd44:	429c      	cmp	r4, r3
 800dd46:	d318      	bcc.n	800dd7a <RCC_SetFlashLatencyFromMSIRange+0x72>
 800dd48:	f503 03b7 	add.w	r3, r3, #5996544	; 0x5b8000
 800dd4c:	f603 537f 	addw	r3, r3, #3455	; 0xd7f
 800dd50:	429c      	cmp	r4, r3
 800dd52:	d929      	bls.n	800dda8 <RCC_SetFlashLatencyFromMSIRange+0xa0>
 800dd54:	f503 1374 	add.w	r3, r3, #3997696	; 0x3d0000
 800dd58:	f503 6310 	add.w	r3, r3, #2304	; 0x900
      if (Flash_ClkSrcFreq <= FLASH_CLK_SRC_RANGE_VOS1[index])
 800dd5c:	429c      	cmp	r4, r3
 800dd5e:	d825      	bhi.n	800ddac <RCC_SetFlashLatencyFromMSIRange+0xa4>
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
 800dd60:	2302      	movs	r3, #2
 800dd62:	e00b      	b.n	800dd7c <RCC_SetFlashLatencyFromMSIRange+0x74>
      if (Flash_ClkSrcFreq <= FLASH_CLK_SRC_RANGE_VOS1[index])
 800dd64:	4b1a      	ldr	r3, [pc, #104]	; (800ddd0 <RCC_SetFlashLatencyFromMSIRange+0xc8>)
 800dd66:	429c      	cmp	r4, r3
 800dd68:	d907      	bls.n	800dd7a <RCC_SetFlashLatencyFromMSIRange+0x72>
 800dd6a:	4b1a      	ldr	r3, [pc, #104]	; (800ddd4 <RCC_SetFlashLatencyFromMSIRange+0xcc>)
 800dd6c:	429c      	cmp	r4, r3
 800dd6e:	d91b      	bls.n	800dda8 <RCC_SetFlashLatencyFromMSIRange+0xa0>
 800dd70:	f503 0337 	add.w	r3, r3, #11993088	; 0xb70000
 800dd74:	f503 53d8 	add.w	r3, r3, #6912	; 0x1b00
 800dd78:	e7f0      	b.n	800dd5c <RCC_SetFlashLatencyFromMSIRange+0x54>
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
 800dd7a:	2300      	movs	r3, #0
      {
        latency = FLASH_LATENCY_RANGE[index];
 800dd7c:	aa04      	add	r2, sp, #16
 800dd7e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 800dd82:	f853 4c0c 	ldr.w	r4, [r3, #-12]
        break;
      }
    }
  }

  __HAL_FLASH_SET_LATENCY(latency);
 800dd86:	4d14      	ldr	r5, [pc, #80]	; (800ddd8 <RCC_SetFlashLatencyFromMSIRange+0xd0>)
 800dd88:	682b      	ldr	r3, [r5, #0]
 800dd8a:	f023 0307 	bic.w	r3, r3, #7
 800dd8e:	4323      	orrs	r3, r4
 800dd90:	602b      	str	r3, [r5, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 800dd92:	f7ff fa7b 	bl	800d28c <HAL_GetTick>
 800dd96:	4606      	mov	r6, r0

  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  while (__HAL_FLASH_GET_LATENCY() != latency)
 800dd98:	682b      	ldr	r3, [r5, #0]
 800dd9a:	f003 0307 	and.w	r3, r3, #7
 800dd9e:	429c      	cmp	r4, r3
 800dda0:	d106      	bne.n	800ddb0 <RCC_SetFlashLatencyFromMSIRange+0xa8>
    if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
    {
      return HAL_TIMEOUT;
    }
  }
  return HAL_OK;
 800dda2:	2000      	movs	r0, #0
}
 800dda4:	b004      	add	sp, #16
 800dda6:	bd70      	pop	{r4, r5, r6, pc}
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
 800dda8:	2301      	movs	r3, #1
 800ddaa:	e7e7      	b.n	800dd7c <RCC_SetFlashLatencyFromMSIRange+0x74>
  uint32_t latency   = FLASH_LATENCY_0;  /* default value 0WS */
 800ddac:	2400      	movs	r4, #0
 800ddae:	e7ea      	b.n	800dd86 <RCC_SetFlashLatencyFromMSIRange+0x7e>
    if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 800ddb0:	f7ff fa6c 	bl	800d28c <HAL_GetTick>
 800ddb4:	1b80      	subs	r0, r0, r6
 800ddb6:	2802      	cmp	r0, #2
 800ddb8:	d9ee      	bls.n	800dd98 <RCC_SetFlashLatencyFromMSIRange+0x90>
      return HAL_TIMEOUT;
 800ddba:	2003      	movs	r0, #3
 800ddbc:	e7f2      	b.n	800dda4 <RCC_SetFlashLatencyFromMSIRange+0x9c>
 800ddbe:	bf00      	nop
 800ddc0:	08011334 	.word	0x08011334
 800ddc4:	080112d4 	.word	0x080112d4
 800ddc8:	080101e0 	.word	0x080101e0
 800ddcc:	006acfc0 	.word	0x006acfc0
 800ddd0:	0121eabf 	.word	0x0121eabf
 800ddd4:	0234933f 	.word	0x0234933f
 800ddd8:	58004000 	.word	0x58004000

0800dddc <HAL_RCC_GetSysClockFreq>:
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 800dddc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
{
 800dde0:	b510      	push	{r4, lr}
 800dde2:	689a      	ldr	r2, [r3, #8]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 800dde4:	68d9      	ldr	r1, [r3, #12]
  if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 800dde6:	f012 020c 	ands.w	r2, r2, #12
 800ddea:	d005      	beq.n	800ddf8 <HAL_RCC_GetSysClockFreq+0x1c>
 800ddec:	2a0c      	cmp	r2, #12
 800ddee:	d14a      	bne.n	800de86 <HAL_RCC_GetSysClockFreq+0xaa>
 800ddf0:	f001 0303 	and.w	r3, r1, #3
      ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pllsource == RCC_PLLSOURCE_MSI)))
 800ddf4:	2b01      	cmp	r3, #1
 800ddf6:	d150      	bne.n	800de9a <HAL_RCC_GetSysClockFreq+0xbe>
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == (RCC_CR_MSIRGSEL)) ? 1UL : 0UL);
 800ddf8:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800ddfc:	482b      	ldr	r0, [pc, #172]	; (800deac <HAL_RCC_GetSysClockFreq+0xd0>)
 800ddfe:	680b      	ldr	r3, [r1, #0]
 800de00:	f013 0308 	ands.w	r3, r3, #8
 800de04:	d006      	beq.n	800de14 <HAL_RCC_GetSysClockFreq+0x38>
 800de06:	680b      	ldr	r3, [r1, #0]
 800de08:	f013 0308 	ands.w	r3, r3, #8
 800de0c:	d137      	bne.n	800de7e <HAL_RCC_GetSysClockFreq+0xa2>
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 800de0e:	f8d1 1094 	ldr.w	r1, [r1, #148]	; 0x94
 800de12:	e007      	b.n	800de24 <HAL_RCC_GetSysClockFreq+0x48>
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == (RCC_CR_MSIRGSEL)) ? 1UL : 0UL);
 800de14:	680c      	ldr	r4, [r1, #0]
 800de16:	0724      	lsls	r4, r4, #28
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 800de18:	bf56      	itet	pl
 800de1a:	f8d1 3094 	ldrpl.w	r3, [r1, #148]	; 0x94
  return (uint32_t)(READ_BIT(RCC->CR, RCC_CR_MSIRANGE));
 800de1e:	6809      	ldrmi	r1, [r1, #0]
    msifreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
 800de20:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 800de24:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
      sysclockfreq = msifreq;
 800de28:	2a00      	cmp	r2, #0
 800de2a:	bf0c      	ite	eq
 800de2c:	4618      	moveq	r0, r3
 800de2e:	2000      	movne	r0, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 800de30:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800de34:	688a      	ldr	r2, [r1, #8]
 800de36:	f002 020c 	and.w	r2, r2, #12
  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800de3a:	2a0c      	cmp	r2, #12
 800de3c:	d11e      	bne.n	800de7c <HAL_RCC_GetSysClockFreq+0xa0>
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 800de3e:	68ca      	ldr	r2, [r1, #12]
 800de40:	f002 0203 	and.w	r2, r2, #3
    switch (pllsource)
 800de44:	2a02      	cmp	r2, #2
 800de46:	d02e      	beq.n	800dea6 <HAL_RCC_GetSysClockFreq+0xca>
 800de48:	2a03      	cmp	r2, #3
 800de4a:	d106      	bne.n	800de5a <HAL_RCC_GetSysClockFreq+0x7e>
  return ((READ_BIT(RCC->CR, RCC_CR_HSEPRE) == (RCC_CR_HSEPRE)) ? 1UL : 0UL);
 800de4c:	680b      	ldr	r3, [r1, #0]
          pllinputfreq = HSE_VALUE / 2U;
 800de4e:	4818      	ldr	r0, [pc, #96]	; (800deb0 <HAL_RCC_GetSysClockFreq+0xd4>)
 800de50:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 800de54:	4b17      	ldr	r3, [pc, #92]	; (800deb4 <HAL_RCC_GetSysClockFreq+0xd8>)
 800de56:	bf18      	it	ne
 800de58:	4603      	movne	r3, r0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 800de5a:	f04f 40b0 	mov.w	r0, #1476395008	; 0x58000000
 800de5e:	68c1      	ldr	r1, [r0, #12]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM));
 800de60:	68c2      	ldr	r2, [r0, #12]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR));
 800de62:	68c0      	ldr	r0, [r0, #12]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 800de64:	f3c1 2106 	ubfx	r1, r1, #8, #7
    sysclockfreq = __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
 800de68:	f3c2 1202 	ubfx	r2, r2, #4, #3
 800de6c:	0f40      	lsrs	r0, r0, #29
 800de6e:	434b      	muls	r3, r1
 800de70:	3201      	adds	r2, #1
 800de72:	3001      	adds	r0, #1
 800de74:	fbb3 f3f2 	udiv	r3, r3, r2
 800de78:	fbb3 f0f0 	udiv	r0, r3, r0
}
 800de7c:	bd10      	pop	{r4, pc}
  return (uint32_t)(READ_BIT(RCC->CR, RCC_CR_MSIRANGE));
 800de7e:	680b      	ldr	r3, [r1, #0]
    msifreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
 800de80:	f3c3 1303 	ubfx	r3, r3, #4, #4
 800de84:	e7ce      	b.n	800de24 <HAL_RCC_GetSysClockFreq+0x48>
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI)
 800de86:	2a04      	cmp	r2, #4
 800de88:	d00a      	beq.n	800dea0 <HAL_RCC_GetSysClockFreq+0xc4>
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 800de8a:	2a08      	cmp	r2, #8
 800de8c:	d105      	bne.n	800de9a <HAL_RCC_GetSysClockFreq+0xbe>
  return ((READ_BIT(RCC->CR, RCC_CR_HSEPRE) == (RCC_CR_HSEPRE)) ? 1UL : 0UL);
 800de8e:	681b      	ldr	r3, [r3, #0]
 800de90:	f413 1380 	ands.w	r3, r3, #1048576	; 0x100000
 800de94:	d104      	bne.n	800dea0 <HAL_RCC_GetSysClockFreq+0xc4>
      sysclockfreq = HSE_VALUE;
 800de96:	4807      	ldr	r0, [pc, #28]	; (800deb4 <HAL_RCC_GetSysClockFreq+0xd8>)
 800de98:	e7ca      	b.n	800de30 <HAL_RCC_GetSysClockFreq+0x54>
  uint32_t msifreq = 0U;
 800de9a:	2300      	movs	r3, #0
  uint32_t sysclockfreq = 0U;
 800de9c:	4618      	mov	r0, r3
 800de9e:	e7c7      	b.n	800de30 <HAL_RCC_GetSysClockFreq+0x54>
      sysclockfreq = HSE_VALUE / 2U;
 800dea0:	4803      	ldr	r0, [pc, #12]	; (800deb0 <HAL_RCC_GetSysClockFreq+0xd4>)
  uint32_t msifreq = 0U;
 800dea2:	2300      	movs	r3, #0
 800dea4:	e7c4      	b.n	800de30 <HAL_RCC_GetSysClockFreq+0x54>
        pllinputfreq = HSI_VALUE;
 800dea6:	4b02      	ldr	r3, [pc, #8]	; (800deb0 <HAL_RCC_GetSysClockFreq+0xd4>)
 800dea8:	e7d7      	b.n	800de5a <HAL_RCC_GetSysClockFreq+0x7e>
 800deaa:	bf00      	nop
 800deac:	08011334 	.word	0x08011334
 800deb0:	00f42400 	.word	0x00f42400
 800deb4:	01e84800 	.word	0x01e84800

0800deb8 <HAL_RCC_GetHCLKFreq>:
{
 800deb8:	b508      	push	{r3, lr}
  return ((uint32_t)(__LL_RCC_CALC_HCLK1_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler())));
 800deba:	f7ff ff8f 	bl	800dddc <HAL_RCC_GetSysClockFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
 800debe:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800dec2:	4a04      	ldr	r2, [pc, #16]	; (800ded4 <HAL_RCC_GetHCLKFreq+0x1c>)
 800dec4:	689b      	ldr	r3, [r3, #8]
 800dec6:	f3c3 1303 	ubfx	r3, r3, #4, #4
 800deca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
}
 800dece:	fbb0 f0f3 	udiv	r0, r0, r3
 800ded2:	bd08      	pop	{r3, pc}
 800ded4:	080112d4 	.word	0x080112d4

0800ded8 <HAL_RCC_OscConfig>:
{
 800ded8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (RCC_OscInitStruct == NULL)
 800dedc:	4604      	mov	r4, r0
 800dede:	2800      	cmp	r0, #0
 800dee0:	d055      	beq.n	800df8e <HAL_RCC_OscConfig+0xb6>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 800dee2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800dee6:	689e      	ldr	r6, [r3, #8]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 800dee8:	68dd      	ldr	r5, [r3, #12]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 800deea:	6803      	ldr	r3, [r0, #0]
 800deec:	0699      	lsls	r1, r3, #26
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 800deee:	f006 060c 	and.w	r6, r6, #12
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 800def2:	f005 0503 	and.w	r5, r5, #3
 800def6:	d56b      	bpl.n	800dfd0 <HAL_RCC_OscConfig+0xf8>
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 800def8:	b11e      	cbz	r6, 800df02 <HAL_RCC_OscConfig+0x2a>
 800defa:	2e0c      	cmp	r6, #12
 800defc:	d149      	bne.n	800df92 <HAL_RCC_OscConfig+0xba>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_MSI)))
 800defe:	2d01      	cmp	r5, #1
 800df00:	d147      	bne.n	800df92 <HAL_RCC_OscConfig+0xba>
      if ((LL_RCC_MSI_IsReady() != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 800df02:	f7ff feeb 	bl	800dcdc <LL_RCC_MSI_IsReady>
 800df06:	b110      	cbz	r0, 800df0e <HAL_RCC_OscConfig+0x36>
 800df08:	6a23      	ldr	r3, [r4, #32]
 800df0a:	2b00      	cmp	r3, #0
 800df0c:	d03f      	beq.n	800df8e <HAL_RCC_OscConfig+0xb6>
        if (RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 800df0e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800df12:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 800df14:	681a      	ldr	r2, [r3, #0]
 800df16:	0712      	lsls	r2, r2, #28
 800df18:	bf56      	itet	pl
 800df1a:	f8d3 3094 	ldrpl.w	r3, [r3, #148]	; 0x94
 800df1e:	681b      	ldrmi	r3, [r3, #0]
 800df20:	091b      	lsrpl	r3, r3, #4
 800df22:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800df26:	4298      	cmp	r0, r3
 800df28:	d91e      	bls.n	800df68 <HAL_RCC_OscConfig+0x90>
          if (RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 800df2a:	f7ff feed 	bl	800dd08 <RCC_SetFlashLatencyFromMSIRange>
 800df2e:	2800      	cmp	r0, #0
 800df30:	d12d      	bne.n	800df8e <HAL_RCC_OscConfig+0xb6>
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 800df32:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800df36:	6813      	ldr	r3, [r2, #0]
 800df38:	f043 0308 	orr.w	r3, r3, #8
 800df3c:	6013      	str	r3, [r2, #0]
 800df3e:	6813      	ldr	r3, [r2, #0]
 800df40:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 800df42:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800df46:	430b      	orrs	r3, r1
 800df48:	6013      	str	r3, [r2, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 800df4a:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800df4c:	f7ff fecc 	bl	800dce8 <LL_RCC_MSI_SetCalibTrimming>
        SystemCoreClock = HAL_RCC_GetHCLKFreq();
 800df50:	f7ff ffb2 	bl	800deb8 <HAL_RCC_GetHCLKFreq>
 800df54:	4bac      	ldr	r3, [pc, #688]	; (800e208 <HAL_RCC_OscConfig+0x330>)
 800df56:	6018      	str	r0, [r3, #0]
        status = HAL_InitTick(uwTickPrio);
 800df58:	4bac      	ldr	r3, [pc, #688]	; (800e20c <HAL_RCC_OscConfig+0x334>)
 800df5a:	6818      	ldr	r0, [r3, #0]
 800df5c:	f7ff f94e 	bl	800d1fc <HAL_InitTick>
        if (status != HAL_OK)
 800df60:	2800      	cmp	r0, #0
 800df62:	d035      	beq.n	800dfd0 <HAL_RCC_OscConfig+0xf8>
}
 800df64:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 800df68:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800df6c:	6813      	ldr	r3, [r2, #0]
 800df6e:	f043 0308 	orr.w	r3, r3, #8
 800df72:	6013      	str	r3, [r2, #0]
 800df74:	6813      	ldr	r3, [r2, #0]
 800df76:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800df7a:	4303      	orrs	r3, r0
 800df7c:	6013      	str	r3, [r2, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 800df7e:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800df80:	f7ff feb2 	bl	800dce8 <LL_RCC_MSI_SetCalibTrimming>
          if (RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 800df84:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 800df86:	f7ff febf 	bl	800dd08 <RCC_SetFlashLatencyFromMSIRange>
 800df8a:	2800      	cmp	r0, #0
 800df8c:	d0e0      	beq.n	800df50 <HAL_RCC_OscConfig+0x78>
          return HAL_ERROR;
 800df8e:	2001      	movs	r0, #1
 800df90:	e7e8      	b.n	800df64 <HAL_RCC_OscConfig+0x8c>
      if (RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 800df92:	6a22      	ldr	r2, [r4, #32]
 800df94:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800df98:	2a00      	cmp	r2, #0
 800df9a:	d054      	beq.n	800e046 <HAL_RCC_OscConfig+0x16e>
  SET_BIT(RCC->CR, RCC_CR_MSION);
 800df9c:	681a      	ldr	r2, [r3, #0]
 800df9e:	f042 0201 	orr.w	r2, r2, #1
 800dfa2:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 800dfa4:	f7ff f972 	bl	800d28c <HAL_GetTick>
 800dfa8:	4607      	mov	r7, r0
        while (LL_RCC_MSI_IsReady() == 0U)
 800dfaa:	f7ff fe97 	bl	800dcdc <LL_RCC_MSI_IsReady>
 800dfae:	2800      	cmp	r0, #0
 800dfb0:	d042      	beq.n	800e038 <HAL_RCC_OscConfig+0x160>
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 800dfb2:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800dfb6:	6813      	ldr	r3, [r2, #0]
 800dfb8:	f043 0308 	orr.w	r3, r3, #8
 800dfbc:	6013      	str	r3, [r2, #0]
 800dfbe:	6813      	ldr	r3, [r2, #0]
 800dfc0:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 800dfc2:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800dfc6:	430b      	orrs	r3, r1
 800dfc8:	6013      	str	r3, [r2, #0]
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 800dfca:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800dfcc:	f7ff fe8c 	bl	800dce8 <LL_RCC_MSI_SetCalibTrimming>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800dfd0:	6823      	ldr	r3, [r4, #0]
 800dfd2:	07db      	lsls	r3, r3, #31
 800dfd4:	d448      	bmi.n	800e068 <HAL_RCC_OscConfig+0x190>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800dfd6:	6823      	ldr	r3, [r4, #0]
 800dfd8:	079f      	lsls	r7, r3, #30
 800dfda:	f100 8090 	bmi.w	800e0fe <HAL_RCC_OscConfig+0x226>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800dfde:	6823      	ldr	r3, [r4, #0]
 800dfe0:	071d      	lsls	r5, r3, #28
 800dfe2:	f140 80fc 	bpl.w	800e1de <HAL_RCC_OscConfig+0x306>
    if (RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 800dfe6:	69a3      	ldr	r3, [r4, #24]
 800dfe8:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
 800dfec:	2b00      	cmp	r3, #0
 800dfee:	f000 80e3 	beq.w	800e1b8 <HAL_RCC_OscConfig+0x2e0>
      uint32_t csr_temp = RCC->CSR;
 800dff2:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
      if (RCC_OscInitStruct->LSIDiv != (csr_temp & RCC_CSR_LSIPRE))
 800dff6:	69e1      	ldr	r1, [r4, #28]
 800dff8:	f003 0210 	and.w	r2, r3, #16
 800dffc:	4291      	cmp	r1, r2
 800dffe:	f000 80c6 	beq.w	800e18e <HAL_RCC_OscConfig+0x2b6>
        if (((csr_temp & RCC_CSR_LSIRDY) == RCC_CSR_LSIRDY) && \
 800e002:	f003 0203 	and.w	r2, r3, #3
 800e006:	2a02      	cmp	r2, #2
 800e008:	d0c1      	beq.n	800df8e <HAL_RCC_OscConfig+0xb6>
        if ((csr_temp & RCC_CSR_LSION) == RCC_CSR_LSION)
 800e00a:	07d8      	lsls	r0, r3, #31
 800e00c:	f140 80b5 	bpl.w	800e17a <HAL_RCC_OscConfig+0x2a2>
  CLEAR_BIT(RCC->CSR, RCC_CSR_LSION);
 800e010:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 800e014:	f023 0301 	bic.w	r3, r3, #1
 800e018:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94
          tickstart = HAL_GetTick();
 800e01c:	f7ff f936 	bl	800d28c <HAL_GetTick>
 800e020:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == (RCC_CSR_LSIRDY)) ? 1UL : 0UL);
 800e022:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 800e026:	0799      	lsls	r1, r3, #30
 800e028:	f140 80a7 	bpl.w	800e17a <HAL_RCC_OscConfig+0x2a2>
            if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 800e02c:	f7ff f92e 	bl	800d28c <HAL_GetTick>
 800e030:	1bc3      	subs	r3, r0, r7
 800e032:	2b11      	cmp	r3, #17
 800e034:	d9f5      	bls.n	800e022 <HAL_RCC_OscConfig+0x14a>
 800e036:	e004      	b.n	800e042 <HAL_RCC_OscConfig+0x16a>
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 800e038:	f7ff f928 	bl	800d28c <HAL_GetTick>
 800e03c:	1bc0      	subs	r0, r0, r7
 800e03e:	2802      	cmp	r0, #2
 800e040:	d9b3      	bls.n	800dfaa <HAL_RCC_OscConfig+0xd2>
            return HAL_TIMEOUT;
 800e042:	2003      	movs	r0, #3
 800e044:	e78e      	b.n	800df64 <HAL_RCC_OscConfig+0x8c>
  CLEAR_BIT(RCC->CR, RCC_CR_MSION);
 800e046:	681a      	ldr	r2, [r3, #0]
 800e048:	f022 0201 	bic.w	r2, r2, #1
 800e04c:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 800e04e:	f7ff f91d 	bl	800d28c <HAL_GetTick>
 800e052:	4607      	mov	r7, r0
        while (LL_RCC_MSI_IsReady() != 0U)
 800e054:	f7ff fe42 	bl	800dcdc <LL_RCC_MSI_IsReady>
 800e058:	2800      	cmp	r0, #0
 800e05a:	d0b9      	beq.n	800dfd0 <HAL_RCC_OscConfig+0xf8>
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 800e05c:	f7ff f916 	bl	800d28c <HAL_GetTick>
 800e060:	1bc0      	subs	r0, r0, r7
 800e062:	2802      	cmp	r0, #2
 800e064:	d9f6      	bls.n	800e054 <HAL_RCC_OscConfig+0x17c>
 800e066:	e7ec      	b.n	800e042 <HAL_RCC_OscConfig+0x16a>
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE) ||
 800e068:	2e08      	cmp	r6, #8
 800e06a:	d003      	beq.n	800e074 <HAL_RCC_OscConfig+0x19c>
 800e06c:	2e0c      	cmp	r6, #12
 800e06e:	d109      	bne.n	800e084 <HAL_RCC_OscConfig+0x1ac>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSE)))
 800e070:	2d03      	cmp	r5, #3
 800e072:	d107      	bne.n	800e084 <HAL_RCC_OscConfig+0x1ac>
      if ((LL_RCC_HSE_IsReady() != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800e074:	f7ff fe26 	bl	800dcc4 <LL_RCC_HSE_IsReady>
 800e078:	2800      	cmp	r0, #0
 800e07a:	d0ac      	beq.n	800dfd6 <HAL_RCC_OscConfig+0xfe>
 800e07c:	6863      	ldr	r3, [r4, #4]
 800e07e:	2b00      	cmp	r3, #0
 800e080:	d1a9      	bne.n	800dfd6 <HAL_RCC_OscConfig+0xfe>
 800e082:	e784      	b.n	800df8e <HAL_RCC_OscConfig+0xb6>
      MODIFY_REG(RCC->CR, RCC_CR_HSEPRE, RCC_OscInitStruct->HSEDiv);
 800e084:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800e088:	68a1      	ldr	r1, [r4, #8]
 800e08a:	681a      	ldr	r2, [r3, #0]
 800e08c:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 800e090:	430a      	orrs	r2, r1
 800e092:	601a      	str	r2, [r3, #0]
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800e094:	6862      	ldr	r2, [r4, #4]
 800e096:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 800e09a:	d110      	bne.n	800e0be <HAL_RCC_OscConfig+0x1e6>
  SET_BIT(RCC->CR, RCC_CR_HSEON);
 800e09c:	681a      	ldr	r2, [r3, #0]
 800e09e:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 800e0a2:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 800e0a4:	f7ff f8f2 	bl	800d28c <HAL_GetTick>
 800e0a8:	4607      	mov	r7, r0
        while (LL_RCC_HSE_IsReady() == 0U)
 800e0aa:	f7ff fe0b 	bl	800dcc4 <LL_RCC_HSE_IsReady>
 800e0ae:	2800      	cmp	r0, #0
 800e0b0:	d191      	bne.n	800dfd6 <HAL_RCC_OscConfig+0xfe>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 800e0b2:	f7ff f8eb 	bl	800d28c <HAL_GetTick>
 800e0b6:	1bc0      	subs	r0, r0, r7
 800e0b8:	2864      	cmp	r0, #100	; 0x64
 800e0ba:	d9f6      	bls.n	800e0aa <HAL_RCC_OscConfig+0x1d2>
 800e0bc:	e7c1      	b.n	800e042 <HAL_RCC_OscConfig+0x16a>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800e0be:	f5b2 1f04 	cmp.w	r2, #2162688	; 0x210000
 800e0c2:	d104      	bne.n	800e0ce <HAL_RCC_OscConfig+0x1f6>
  SET_BIT(RCC->CR, RCC_CR_HSEBYPPWR);
 800e0c4:	681a      	ldr	r2, [r3, #0]
 800e0c6:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 800e0ca:	601a      	str	r2, [r3, #0]
 800e0cc:	e7e6      	b.n	800e09c <HAL_RCC_OscConfig+0x1c4>
  CLEAR_BIT(RCC->CR, RCC_CR_HSEON);
 800e0ce:	6819      	ldr	r1, [r3, #0]
 800e0d0:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 800e0d4:	6019      	str	r1, [r3, #0]
  CLEAR_BIT(RCC->CR, RCC_CR_HSEBYPPWR);
 800e0d6:	6819      	ldr	r1, [r3, #0]
 800e0d8:	f421 1100 	bic.w	r1, r1, #2097152	; 0x200000
 800e0dc:	6019      	str	r1, [r3, #0]
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 800e0de:	2a00      	cmp	r2, #0
 800e0e0:	d1e0      	bne.n	800e0a4 <HAL_RCC_OscConfig+0x1cc>
        tickstart = HAL_GetTick();
 800e0e2:	f7ff f8d3 	bl	800d28c <HAL_GetTick>
 800e0e6:	4607      	mov	r7, r0
        while (LL_RCC_HSE_IsReady() != 0U)
 800e0e8:	f7ff fdec 	bl	800dcc4 <LL_RCC_HSE_IsReady>
 800e0ec:	2800      	cmp	r0, #0
 800e0ee:	f43f af72 	beq.w	800dfd6 <HAL_RCC_OscConfig+0xfe>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 800e0f2:	f7ff f8cb 	bl	800d28c <HAL_GetTick>
 800e0f6:	1bc0      	subs	r0, r0, r7
 800e0f8:	2864      	cmp	r0, #100	; 0x64
 800e0fa:	d9f5      	bls.n	800e0e8 <HAL_RCC_OscConfig+0x210>
 800e0fc:	e7a1      	b.n	800e042 <HAL_RCC_OscConfig+0x16a>
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI) ||
 800e0fe:	2e04      	cmp	r6, #4
 800e100:	d003      	beq.n	800e10a <HAL_RCC_OscConfig+0x232>
 800e102:	2e0c      	cmp	r6, #12
 800e104:	d112      	bne.n	800e12c <HAL_RCC_OscConfig+0x254>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSI)))
 800e106:	2d02      	cmp	r5, #2
 800e108:	d110      	bne.n	800e12c <HAL_RCC_OscConfig+0x254>
      if ((LL_RCC_HSI_IsReady() != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 800e10a:	f7ff fde1 	bl	800dcd0 <LL_RCC_HSI_IsReady>
 800e10e:	b118      	cbz	r0, 800e118 <HAL_RCC_OscConfig+0x240>
 800e110:	6923      	ldr	r3, [r4, #16]
 800e112:	2b00      	cmp	r3, #0
 800e114:	f43f af3b 	beq.w	800df8e <HAL_RCC_OscConfig+0xb6>
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_HSITRIM, Value << RCC_ICSCR_HSITRIM_Pos);
 800e118:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800e11c:	6961      	ldr	r1, [r4, #20]
 800e11e:	6853      	ldr	r3, [r2, #4]
 800e120:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 800e124:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 800e128:	6053      	str	r3, [r2, #4]
}
 800e12a:	e758      	b.n	800dfde <HAL_RCC_OscConfig+0x106>
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 800e12c:	6922      	ldr	r2, [r4, #16]
 800e12e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800e132:	b182      	cbz	r2, 800e156 <HAL_RCC_OscConfig+0x27e>
  SET_BIT(RCC->CR, RCC_CR_HSION);
 800e134:	681a      	ldr	r2, [r3, #0]
 800e136:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 800e13a:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 800e13c:	f7ff f8a6 	bl	800d28c <HAL_GetTick>
 800e140:	4605      	mov	r5, r0
        while (LL_RCC_HSI_IsReady() == 0U)
 800e142:	f7ff fdc5 	bl	800dcd0 <LL_RCC_HSI_IsReady>
 800e146:	2800      	cmp	r0, #0
 800e148:	d1e6      	bne.n	800e118 <HAL_RCC_OscConfig+0x240>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 800e14a:	f7ff f89f 	bl	800d28c <HAL_GetTick>
 800e14e:	1b40      	subs	r0, r0, r5
 800e150:	2802      	cmp	r0, #2
 800e152:	d9f6      	bls.n	800e142 <HAL_RCC_OscConfig+0x26a>
 800e154:	e775      	b.n	800e042 <HAL_RCC_OscConfig+0x16a>
  CLEAR_BIT(RCC->CR, RCC_CR_HSION);
 800e156:	681a      	ldr	r2, [r3, #0]
 800e158:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 800e15c:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 800e15e:	f7ff f895 	bl	800d28c <HAL_GetTick>
 800e162:	4605      	mov	r5, r0
        while (LL_RCC_HSI_IsReady() != 0U)
 800e164:	f7ff fdb4 	bl	800dcd0 <LL_RCC_HSI_IsReady>
 800e168:	2800      	cmp	r0, #0
 800e16a:	f43f af38 	beq.w	800dfde <HAL_RCC_OscConfig+0x106>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 800e16e:	f7ff f88d 	bl	800d28c <HAL_GetTick>
 800e172:	1b40      	subs	r0, r0, r5
 800e174:	2802      	cmp	r0, #2
 800e176:	d9f5      	bls.n	800e164 <HAL_RCC_OscConfig+0x28c>
 800e178:	e763      	b.n	800e042 <HAL_RCC_OscConfig+0x16a>
        MODIFY_REG(RCC->CSR, RCC_CSR_LSIPRE, RCC_OscInitStruct->LSIDiv);
 800e17a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800e17e:	69e1      	ldr	r1, [r4, #28]
 800e180:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
 800e184:	f023 0310 	bic.w	r3, r3, #16
 800e188:	430b      	orrs	r3, r1
 800e18a:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
  SET_BIT(RCC->CSR, RCC_CSR_LSION);
 800e18e:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
 800e192:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 800e196:	f043 0301 	orr.w	r3, r3, #1
 800e19a:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94
      tickstart = HAL_GetTick();
 800e19e:	f7ff f875 	bl	800d28c <HAL_GetTick>
 800e1a2:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == (RCC_CSR_LSIRDY)) ? 1UL : 0UL);
 800e1a4:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 800e1a8:	079a      	lsls	r2, r3, #30
 800e1aa:	d418      	bmi.n	800e1de <HAL_RCC_OscConfig+0x306>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 800e1ac:	f7ff f86e 	bl	800d28c <HAL_GetTick>
 800e1b0:	1bc3      	subs	r3, r0, r7
 800e1b2:	2b11      	cmp	r3, #17
 800e1b4:	d9f6      	bls.n	800e1a4 <HAL_RCC_OscConfig+0x2cc>
 800e1b6:	e744      	b.n	800e042 <HAL_RCC_OscConfig+0x16a>
  CLEAR_BIT(RCC->CSR, RCC_CSR_LSION);
 800e1b8:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 800e1bc:	f023 0301 	bic.w	r3, r3, #1
 800e1c0:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94
      tickstart = HAL_GetTick();
 800e1c4:	f7ff f862 	bl	800d28c <HAL_GetTick>
 800e1c8:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == (RCC_CSR_LSIRDY)) ? 1UL : 0UL);
 800e1ca:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 800e1ce:	079b      	lsls	r3, r3, #30
 800e1d0:	d505      	bpl.n	800e1de <HAL_RCC_OscConfig+0x306>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 800e1d2:	f7ff f85b 	bl	800d28c <HAL_GetTick>
 800e1d6:	1bc3      	subs	r3, r0, r7
 800e1d8:	2b11      	cmp	r3, #17
 800e1da:	d9f6      	bls.n	800e1ca <HAL_RCC_OscConfig+0x2f2>
 800e1dc:	e731      	b.n	800e042 <HAL_RCC_OscConfig+0x16a>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800e1de:	6823      	ldr	r3, [r4, #0]
 800e1e0:	0758      	lsls	r0, r3, #29
 800e1e2:	d553      	bpl.n	800e28c <HAL_RCC_OscConfig+0x3b4>
  * @rmtoll CR1          DBP           LL_PWR_IsEnabledBkUpAccess
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_PWR_IsEnabledBkUpAccess(void)
{
  return ((READ_BIT(PWR->CR1, PWR_CR1_DBP) == (PWR_CR1_DBP)) ? 1UL : 0UL);
 800e1e4:	4d0a      	ldr	r5, [pc, #40]	; (800e210 <HAL_RCC_OscConfig+0x338>)
 800e1e6:	682b      	ldr	r3, [r5, #0]
 800e1e8:	05d9      	lsls	r1, r3, #23
 800e1ea:	d413      	bmi.n	800e214 <HAL_RCC_OscConfig+0x33c>
      HAL_PWR_EnableBkUpAccess();
 800e1ec:	f7ff fd5a 	bl	800dca4 <HAL_PWR_EnableBkUpAccess>
      tickstart = HAL_GetTick();
 800e1f0:	f7ff f84c 	bl	800d28c <HAL_GetTick>
 800e1f4:	4607      	mov	r7, r0
 800e1f6:	682b      	ldr	r3, [r5, #0]
 800e1f8:	05da      	lsls	r2, r3, #23
 800e1fa:	d40b      	bmi.n	800e214 <HAL_RCC_OscConfig+0x33c>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800e1fc:	f7ff f846 	bl	800d28c <HAL_GetTick>
 800e200:	1bc3      	subs	r3, r0, r7
 800e202:	2b02      	cmp	r3, #2
 800e204:	d9f7      	bls.n	800e1f6 <HAL_RCC_OscConfig+0x31e>
 800e206:	e71c      	b.n	800e042 <HAL_RCC_OscConfig+0x16a>
 800e208:	2000340c 	.word	0x2000340c
 800e20c:	20003414 	.word	0x20003414
 800e210:	58000400 	.word	0x58000400
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 800e214:	68e3      	ldr	r3, [r4, #12]
 800e216:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
 800e21a:	2b00      	cmp	r3, #0
 800e21c:	d058      	beq.n	800e2d0 <HAL_RCC_OscConfig+0x3f8>
          || (RCC_OscInitStruct->LSEState == RCC_LSE_BYPASS_RTC_ONLY))
 800e21e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800e222:	2b05      	cmp	r3, #5
        SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
 800e224:	bf02      	ittt	eq
 800e226:	f8d5 3090 	ldreq.w	r3, [r5, #144]	; 0x90
 800e22a:	f043 0304 	orreq.w	r3, r3, #4
 800e22e:	f8c5 3090 	streq.w	r3, [r5, #144]	; 0x90
      SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 800e232:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
      tickstart = HAL_GetTick();
 800e236:	f7ff f829 	bl	800d28c <HAL_GetTick>
      SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 800e23a:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 800e23e:	f043 0301 	orr.w	r3, r3, #1
      tickstart = HAL_GetTick();
 800e242:	4607      	mov	r7, r0
      SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 800e244:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800e248:	f241 3888 	movw	r8, #5000	; 0x1388
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? 1UL : 0UL);
 800e24c:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 800e250:	079b      	lsls	r3, r3, #30
 800e252:	d405      	bmi.n	800e260 <HAL_RCC_OscConfig+0x388>
 800e254:	f7ff f81a 	bl	800d28c <HAL_GetTick>
 800e258:	1bc3      	subs	r3, r0, r7
 800e25a:	4543      	cmp	r3, r8
 800e25c:	d9f6      	bls.n	800e24c <HAL_RCC_OscConfig+0x374>
 800e25e:	e6f0      	b.n	800e042 <HAL_RCC_OscConfig+0x16a>
      if ((RCC_OscInitStruct->LSEState == RCC_LSE_ON)
 800e260:	68e3      	ldr	r3, [r4, #12]
 800e262:	f023 0304 	bic.w	r3, r3, #4
 800e266:	2b81      	cmp	r3, #129	; 0x81
 800e268:	d11b      	bne.n	800e2a2 <HAL_RCC_OscConfig+0x3ca>
        tickstart = HAL_GetTick();
 800e26a:	f7ff f80f 	bl	800d28c <HAL_GetTick>
        SET_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 800e26e:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 800e272:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800e276:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        tickstart = HAL_GetTick();
 800e27a:	4607      	mov	r7, r0
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) == 0U)
 800e27c:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800e280:	f241 3888 	movw	r8, #5000	; 0x1388
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) == 0U)
 800e284:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 800e288:	0518      	lsls	r0, r3, #20
 800e28a:	d504      	bpl.n	800e296 <HAL_RCC_OscConfig+0x3be>
  if (RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 800e28c:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800e28e:	2800      	cmp	r0, #0
 800e290:	d14a      	bne.n	800e328 <HAL_RCC_OscConfig+0x450>
  return HAL_OK;
 800e292:	2000      	movs	r0, #0
 800e294:	e666      	b.n	800df64 <HAL_RCC_OscConfig+0x8c>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800e296:	f7fe fff9 	bl	800d28c <HAL_GetTick>
 800e29a:	1bc0      	subs	r0, r0, r7
 800e29c:	4540      	cmp	r0, r8
 800e29e:	d9f1      	bls.n	800e284 <HAL_RCC_OscConfig+0x3ac>
 800e2a0:	e6cf      	b.n	800e042 <HAL_RCC_OscConfig+0x16a>
        tickstart = HAL_GetTick();
 800e2a2:	f7fe fff3 	bl	800d28c <HAL_GetTick>
        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 800e2a6:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 800e2aa:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800e2ae:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        tickstart = HAL_GetTick();
 800e2b2:	4607      	mov	r7, r0
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 800e2b4:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800e2b8:	f241 3888 	movw	r8, #5000	; 0x1388
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 800e2bc:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 800e2c0:	0519      	lsls	r1, r3, #20
 800e2c2:	d5e3      	bpl.n	800e28c <HAL_RCC_OscConfig+0x3b4>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800e2c4:	f7fe ffe2 	bl	800d28c <HAL_GetTick>
 800e2c8:	1bc0      	subs	r0, r0, r7
 800e2ca:	4540      	cmp	r0, r8
 800e2cc:	d9f6      	bls.n	800e2bc <HAL_RCC_OscConfig+0x3e4>
 800e2ce:	e6b8      	b.n	800e042 <HAL_RCC_OscConfig+0x16a>
      tickstart = HAL_GetTick();
 800e2d0:	f7fe ffdc 	bl	800d28c <HAL_GetTick>
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 800e2d4:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 800e2d8:	f023 0380 	bic.w	r3, r3, #128	; 0x80
      tickstart = HAL_GetTick();
 800e2dc:	4607      	mov	r7, r0
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 800e2de:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800e2e2:	f241 3888 	movw	r8, #5000	; 0x1388
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 800e2e6:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 800e2ea:	051a      	lsls	r2, r3, #20
 800e2ec:	d416      	bmi.n	800e31c <HAL_RCC_OscConfig+0x444>
      tickstart = HAL_GetTick();
 800e2ee:	f7fe ffcd 	bl	800d28c <HAL_GetTick>
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 800e2f2:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 800e2f6:	f023 0301 	bic.w	r3, r3, #1
 800e2fa:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
      tickstart = HAL_GetTick();
 800e2fe:	4607      	mov	r7, r0
 800e300:	f04f 48b0 	mov.w	r8, #1476395008	; 0x58000000
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800e304:	f241 3588 	movw	r5, #5000	; 0x1388
 800e308:	f8d8 3090 	ldr.w	r3, [r8, #144]	; 0x90
 800e30c:	079b      	lsls	r3, r3, #30
 800e30e:	d5bd      	bpl.n	800e28c <HAL_RCC_OscConfig+0x3b4>
 800e310:	f7fe ffbc 	bl	800d28c <HAL_GetTick>
 800e314:	1bc3      	subs	r3, r0, r7
 800e316:	42ab      	cmp	r3, r5
 800e318:	d9f6      	bls.n	800e308 <HAL_RCC_OscConfig+0x430>
 800e31a:	e692      	b.n	800e042 <HAL_RCC_OscConfig+0x16a>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800e31c:	f7fe ffb6 	bl	800d28c <HAL_GetTick>
 800e320:	1bc0      	subs	r0, r0, r7
 800e322:	4540      	cmp	r0, r8
 800e324:	d9df      	bls.n	800e2e6 <HAL_RCC_OscConfig+0x40e>
 800e326:	e68c      	b.n	800e042 <HAL_RCC_OscConfig+0x16a>
    if (sysclk_source != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800e328:	2e0c      	cmp	r6, #12
 800e32a:	d053      	beq.n	800e3d4 <HAL_RCC_OscConfig+0x4fc>
      if (RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 800e32c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800e330:	2802      	cmp	r0, #2
  CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
 800e332:	681a      	ldr	r2, [r3, #0]
 800e334:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 800e338:	601a      	str	r2, [r3, #0]
 800e33a:	d133      	bne.n	800e3a4 <HAL_RCC_OscConfig+0x4cc>
        tickstart = HAL_GetTick();
 800e33c:	f7fe ffa6 	bl	800d28c <HAL_GetTick>
 800e340:	4605      	mov	r5, r0
        while (LL_RCC_PLL_IsReady() != 0U)
 800e342:	f7ff fcda 	bl	800dcfa <LL_RCC_PLL_IsReady>
 800e346:	bb38      	cbnz	r0, 800e398 <HAL_RCC_OscConfig+0x4c0>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 800e348:	e9d4 310c 	ldrd	r3, r1, [r4, #48]	; 0x30
 800e34c:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800e350:	430b      	orrs	r3, r1
 800e352:	68d0      	ldr	r0, [r2, #12]
 800e354:	492f      	ldr	r1, [pc, #188]	; (800e414 <HAL_RCC_OscConfig+0x53c>)
 800e356:	4001      	ands	r1, r0
 800e358:	430b      	orrs	r3, r1
 800e35a:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 800e35c:	430b      	orrs	r3, r1
 800e35e:	6c21      	ldr	r1, [r4, #64]	; 0x40
 800e360:	430b      	orrs	r3, r1
 800e362:	6c61      	ldr	r1, [r4, #68]	; 0x44
 800e364:	430b      	orrs	r3, r1
 800e366:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 800e368:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 800e36c:	60d3      	str	r3, [r2, #12]
  SET_BIT(RCC->CR, RCC_CR_PLLON);
 800e36e:	6813      	ldr	r3, [r2, #0]
 800e370:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800e374:	6013      	str	r3, [r2, #0]
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 800e376:	68d3      	ldr	r3, [r2, #12]
 800e378:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800e37c:	60d3      	str	r3, [r2, #12]
        tickstart = HAL_GetTick();
 800e37e:	f7fe ff85 	bl	800d28c <HAL_GetTick>
 800e382:	4604      	mov	r4, r0
        while (LL_RCC_PLL_IsReady() == 0U)
 800e384:	f7ff fcb9 	bl	800dcfa <LL_RCC_PLL_IsReady>
 800e388:	2800      	cmp	r0, #0
 800e38a:	d182      	bne.n	800e292 <HAL_RCC_OscConfig+0x3ba>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800e38c:	f7fe ff7e 	bl	800d28c <HAL_GetTick>
 800e390:	1b00      	subs	r0, r0, r4
 800e392:	280a      	cmp	r0, #10
 800e394:	d9f6      	bls.n	800e384 <HAL_RCC_OscConfig+0x4ac>
 800e396:	e654      	b.n	800e042 <HAL_RCC_OscConfig+0x16a>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800e398:	f7fe ff78 	bl	800d28c <HAL_GetTick>
 800e39c:	1b40      	subs	r0, r0, r5
 800e39e:	280a      	cmp	r0, #10
 800e3a0:	d9cf      	bls.n	800e342 <HAL_RCC_OscConfig+0x46a>
 800e3a2:	e64e      	b.n	800e042 <HAL_RCC_OscConfig+0x16a>
        MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PLLSOURCE_NONE);
 800e3a4:	68da      	ldr	r2, [r3, #12]
 800e3a6:	f022 0203 	bic.w	r2, r2, #3
 800e3aa:	60da      	str	r2, [r3, #12]
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_RNGCLK | RCC_PLL_ADCCLK);
 800e3ac:	68da      	ldr	r2, [r3, #12]
 800e3ae:	f022 5288 	bic.w	r2, r2, #285212672	; 0x11000000
 800e3b2:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800e3b6:	60da      	str	r2, [r3, #12]
        tickstart = HAL_GetTick();
 800e3b8:	f7fe ff68 	bl	800d28c <HAL_GetTick>
 800e3bc:	4604      	mov	r4, r0
        while (LL_RCC_PLL_IsReady() != 0U)
 800e3be:	f7ff fc9c 	bl	800dcfa <LL_RCC_PLL_IsReady>
 800e3c2:	2800      	cmp	r0, #0
 800e3c4:	f43f af65 	beq.w	800e292 <HAL_RCC_OscConfig+0x3ba>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800e3c8:	f7fe ff60 	bl	800d28c <HAL_GetTick>
 800e3cc:	1b00      	subs	r0, r0, r4
 800e3ce:	280a      	cmp	r0, #10
 800e3d0:	d9f5      	bls.n	800e3be <HAL_RCC_OscConfig+0x4e6>
 800e3d2:	e636      	b.n	800e042 <HAL_RCC_OscConfig+0x16a>
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 800e3d4:	2801      	cmp	r0, #1
 800e3d6:	f43f adc5 	beq.w	800df64 <HAL_RCC_OscConfig+0x8c>
        pll_config = RCC->PLLCFGR;
 800e3da:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
        if ((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource)
 800e3de:	6b22      	ldr	r2, [r4, #48]	; 0x30
        pll_config = RCC->PLLCFGR;
 800e3e0:	68db      	ldr	r3, [r3, #12]
        if ((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource)
 800e3e2:	f003 0103 	and.w	r1, r3, #3
 800e3e6:	4291      	cmp	r1, r2
 800e3e8:	f47f add1 	bne.w	800df8e <HAL_RCC_OscConfig+0xb6>
            || (READ_BIT(pll_config, RCC_PLLCFGR_PLLM)   != RCC_OscInitStruct->PLL.PLLM)
 800e3ec:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800e3ee:	f003 0270 	and.w	r2, r3, #112	; 0x70
 800e3f2:	428a      	cmp	r2, r1
 800e3f4:	f47f adcb 	bne.w	800df8e <HAL_RCC_OscConfig+0xb6>
            || (READ_BIT(pll_config, RCC_PLLCFGR_PLLN)   != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos))
 800e3f8:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 800e3fa:	f403 42fe 	and.w	r2, r3, #32512	; 0x7f00
 800e3fe:	ebb2 2f01 	cmp.w	r2, r1, lsl #8
 800e402:	f47f adc4 	bne.w	800df8e <HAL_RCC_OscConfig+0xb6>
            || (READ_BIT(pll_config, RCC_PLLCFGR_PLLR)   != RCC_OscInitStruct->PLL.PLLR))
 800e406:	6c62      	ldr	r2, [r4, #68]	; 0x44
 800e408:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
 800e40c:	4293      	cmp	r3, r2
 800e40e:	f43f af40 	beq.w	800e292 <HAL_RCC_OscConfig+0x3ba>
 800e412:	e5bc      	b.n	800df8e <HAL_RCC_OscConfig+0xb6>
 800e414:	11c1808c 	.word	0x11c1808c

0800e418 <HAL_RCC_ClockConfig>:
{
 800e418:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800e41c:	460d      	mov	r5, r1
  if (RCC_ClkInitStruct == NULL)
 800e41e:	4604      	mov	r4, r0
 800e420:	b910      	cbnz	r0, 800e428 <HAL_RCC_ClockConfig+0x10>
    return HAL_ERROR;
 800e422:	2001      	movs	r0, #1
}
 800e424:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 800e428:	4e74      	ldr	r6, [pc, #464]	; (800e5fc <HAL_RCC_ClockConfig+0x1e4>)
 800e42a:	6833      	ldr	r3, [r6, #0]
 800e42c:	f003 0307 	and.w	r3, r3, #7
 800e430:	428b      	cmp	r3, r1
 800e432:	d316      	bcc.n	800e462 <HAL_RCC_ClockConfig+0x4a>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800e434:	6823      	ldr	r3, [r4, #0]
 800e436:	079a      	lsls	r2, r3, #30
 800e438:	d527      	bpl.n	800e48a <HAL_RCC_ClockConfig+0x72>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
 800e43a:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
 800e43e:	68a2      	ldr	r2, [r4, #8]
 800e440:	68b3      	ldr	r3, [r6, #8]
 800e442:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800e446:	4313      	orrs	r3, r2
 800e448:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 800e44a:	f7fe ff1f 	bl	800d28c <HAL_GetTick>
 800e44e:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_HPREF) == (RCC_CFGR_HPREF)) ? 1UL : 0UL);
 800e450:	68b3      	ldr	r3, [r6, #8]
 800e452:	03db      	lsls	r3, r3, #15
 800e454:	d419      	bmi.n	800e48a <HAL_RCC_ClockConfig+0x72>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 800e456:	f7fe ff19 	bl	800d28c <HAL_GetTick>
 800e45a:	1bc3      	subs	r3, r0, r7
 800e45c:	2b02      	cmp	r3, #2
 800e45e:	d9f7      	bls.n	800e450 <HAL_RCC_ClockConfig+0x38>
 800e460:	e011      	b.n	800e486 <HAL_RCC_ClockConfig+0x6e>
    __HAL_FLASH_SET_LATENCY(FLatency);
 800e462:	6833      	ldr	r3, [r6, #0]
 800e464:	f023 0307 	bic.w	r3, r3, #7
 800e468:	430b      	orrs	r3, r1
 800e46a:	6033      	str	r3, [r6, #0]
    tickstart = HAL_GetTick();
 800e46c:	f7fe ff0e 	bl	800d28c <HAL_GetTick>
 800e470:	4607      	mov	r7, r0
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 800e472:	6833      	ldr	r3, [r6, #0]
 800e474:	f003 0307 	and.w	r3, r3, #7
 800e478:	42ab      	cmp	r3, r5
 800e47a:	d0db      	beq.n	800e434 <HAL_RCC_ClockConfig+0x1c>
      if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 800e47c:	f7fe ff06 	bl	800d28c <HAL_GetTick>
 800e480:	1bc0      	subs	r0, r0, r7
 800e482:	2802      	cmp	r0, #2
 800e484:	d9f5      	bls.n	800e472 <HAL_RCC_ClockConfig+0x5a>
        return HAL_TIMEOUT;
 800e486:	2003      	movs	r0, #3
 800e488:	e7cc      	b.n	800e424 <HAL_RCC_ClockConfig+0xc>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK2) == RCC_CLOCKTYPE_HCLK2)
 800e48a:	6823      	ldr	r3, [r4, #0]
 800e48c:	0698      	lsls	r0, r3, #26
 800e48e:	d516      	bpl.n	800e4be <HAL_RCC_ClockConfig+0xa6>
  MODIFY_REG(RCC->EXTCFGR, RCC_EXTCFGR_C2HPRE, Prescaler);
 800e490:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
 800e494:	6962      	ldr	r2, [r4, #20]
 800e496:	f8d6 3108 	ldr.w	r3, [r6, #264]	; 0x108
 800e49a:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800e49e:	4313      	orrs	r3, r2
 800e4a0:	f8c6 3108 	str.w	r3, [r6, #264]	; 0x108
    tickstart = HAL_GetTick();
 800e4a4:	f7fe fef2 	bl	800d28c <HAL_GetTick>
 800e4a8:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_C2HPREF) == (RCC_EXTCFGR_C2HPREF)) ? 1UL : 0UL);
 800e4aa:	f8d6 3108 	ldr.w	r3, [r6, #264]	; 0x108
 800e4ae:	0399      	lsls	r1, r3, #14
 800e4b0:	d405      	bmi.n	800e4be <HAL_RCC_ClockConfig+0xa6>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 800e4b2:	f7fe feeb 	bl	800d28c <HAL_GetTick>
 800e4b6:	1bc3      	subs	r3, r0, r7
 800e4b8:	2b02      	cmp	r3, #2
 800e4ba:	d9f6      	bls.n	800e4aa <HAL_RCC_ClockConfig+0x92>
 800e4bc:	e7e3      	b.n	800e486 <HAL_RCC_ClockConfig+0x6e>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK3) == RCC_CLOCKTYPE_HCLK3)
 800e4be:	6823      	ldr	r3, [r4, #0]
 800e4c0:	065a      	lsls	r2, r3, #25
 800e4c2:	d517      	bpl.n	800e4f4 <HAL_RCC_ClockConfig+0xdc>
  MODIFY_REG(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPRE, Prescaler >> 4);
 800e4c4:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
 800e4c8:	69a2      	ldr	r2, [r4, #24]
 800e4ca:	f8d6 3108 	ldr.w	r3, [r6, #264]	; 0x108
 800e4ce:	f023 030f 	bic.w	r3, r3, #15
 800e4d2:	ea43 1312 	orr.w	r3, r3, r2, lsr #4
 800e4d6:	f8c6 3108 	str.w	r3, [r6, #264]	; 0x108
    tickstart = HAL_GetTick();
 800e4da:	f7fe fed7 	bl	800d28c <HAL_GetTick>
 800e4de:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPREF) == (RCC_EXTCFGR_SHDHPREF)) ? 1UL : 0UL);
 800e4e0:	f8d6 3108 	ldr.w	r3, [r6, #264]	; 0x108
 800e4e4:	03db      	lsls	r3, r3, #15
 800e4e6:	d405      	bmi.n	800e4f4 <HAL_RCC_ClockConfig+0xdc>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 800e4e8:	f7fe fed0 	bl	800d28c <HAL_GetTick>
 800e4ec:	1bc3      	subs	r3, r0, r7
 800e4ee:	2b02      	cmp	r3, #2
 800e4f0:	d9f6      	bls.n	800e4e0 <HAL_RCC_ClockConfig+0xc8>
 800e4f2:	e7c8      	b.n	800e486 <HAL_RCC_ClockConfig+0x6e>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800e4f4:	6823      	ldr	r3, [r4, #0]
 800e4f6:	075e      	lsls	r6, r3, #29
 800e4f8:	d513      	bpl.n	800e522 <HAL_RCC_ClockConfig+0x10a>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, Prescaler);
 800e4fa:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
 800e4fe:	68e2      	ldr	r2, [r4, #12]
 800e500:	68b3      	ldr	r3, [r6, #8]
 800e502:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 800e506:	4313      	orrs	r3, r2
 800e508:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 800e50a:	f7fe febf 	bl	800d28c <HAL_GetTick>
 800e50e:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1F) == (RCC_CFGR_PPRE1F)) ? 1UL : 0UL);
 800e510:	68b3      	ldr	r3, [r6, #8]
 800e512:	0398      	lsls	r0, r3, #14
 800e514:	d405      	bmi.n	800e522 <HAL_RCC_ClockConfig+0x10a>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 800e516:	f7fe feb9 	bl	800d28c <HAL_GetTick>
 800e51a:	1bc3      	subs	r3, r0, r7
 800e51c:	2b02      	cmp	r3, #2
 800e51e:	d9f7      	bls.n	800e510 <HAL_RCC_ClockConfig+0xf8>
 800e520:	e7b1      	b.n	800e486 <HAL_RCC_ClockConfig+0x6e>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800e522:	6823      	ldr	r3, [r4, #0]
 800e524:	0719      	lsls	r1, r3, #28
 800e526:	d514      	bpl.n	800e552 <HAL_RCC_ClockConfig+0x13a>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, Prescaler);
 800e528:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
    LL_RCC_SetAPB2Prescaler((RCC_ClkInitStruct->APB2CLKDivider) << 3U);
 800e52c:	6922      	ldr	r2, [r4, #16]
 800e52e:	68b3      	ldr	r3, [r6, #8]
 800e530:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 800e534:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 800e538:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 800e53a:	f7fe fea7 	bl	800d28c <HAL_GetTick>
 800e53e:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2F) == (RCC_CFGR_PPRE2F)) ? 1UL : 0UL);
 800e540:	68b3      	ldr	r3, [r6, #8]
 800e542:	035a      	lsls	r2, r3, #13
 800e544:	d405      	bmi.n	800e552 <HAL_RCC_ClockConfig+0x13a>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 800e546:	f7fe fea1 	bl	800d28c <HAL_GetTick>
 800e54a:	1bc3      	subs	r3, r0, r7
 800e54c:	2b02      	cmp	r3, #2
 800e54e:	d9f7      	bls.n	800e540 <HAL_RCC_ClockConfig+0x128>
 800e550:	e799      	b.n	800e486 <HAL_RCC_ClockConfig+0x6e>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800e552:	6823      	ldr	r3, [r4, #0]
 800e554:	07db      	lsls	r3, r3, #31
 800e556:	d40f      	bmi.n	800e578 <HAL_RCC_ClockConfig+0x160>
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 800e558:	4c28      	ldr	r4, [pc, #160]	; (800e5fc <HAL_RCC_ClockConfig+0x1e4>)
 800e55a:	6823      	ldr	r3, [r4, #0]
 800e55c:	f003 0307 	and.w	r3, r3, #7
 800e560:	42ab      	cmp	r3, r5
 800e562:	d837      	bhi.n	800e5d4 <HAL_RCC_ClockConfig+0x1bc>
  SystemCoreClock = HAL_RCC_GetHCLKFreq();
 800e564:	f7ff fca8 	bl	800deb8 <HAL_RCC_GetHCLKFreq>
 800e568:	4b25      	ldr	r3, [pc, #148]	; (800e600 <HAL_RCC_ClockConfig+0x1e8>)
 800e56a:	6018      	str	r0, [r3, #0]
  return HAL_InitTick(uwTickPrio);
 800e56c:	4b25      	ldr	r3, [pc, #148]	; (800e604 <HAL_RCC_ClockConfig+0x1ec>)
}
 800e56e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  return HAL_InitTick(uwTickPrio);
 800e572:	6818      	ldr	r0, [r3, #0]
 800e574:	f7fe be42 	b.w	800d1fc <HAL_InitTick>
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800e578:	6863      	ldr	r3, [r4, #4]
 800e57a:	2b02      	cmp	r3, #2
 800e57c:	d11e      	bne.n	800e5bc <HAL_RCC_ClockConfig+0x1a4>
      if (LL_RCC_HSE_IsReady() == 0U)
 800e57e:	f7ff fba1 	bl	800dcc4 <LL_RCC_HSE_IsReady>
      if (LL_RCC_HSI_IsReady() == 0U)
 800e582:	2800      	cmp	r0, #0
 800e584:	f43f af4d 	beq.w	800e422 <HAL_RCC_ClockConfig+0xa>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
 800e588:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
 800e58c:	6862      	ldr	r2, [r4, #4]
 800e58e:	68b3      	ldr	r3, [r6, #8]
 800e590:	f023 0303 	bic.w	r3, r3, #3
 800e594:	4313      	orrs	r3, r2
 800e596:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 800e598:	f7fe fe78 	bl	800d28c <HAL_GetTick>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800e59c:	f241 3888 	movw	r8, #5000	; 0x1388
    tickstart = HAL_GetTick();
 800e5a0:	4607      	mov	r7, r0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 800e5a2:	68b3      	ldr	r3, [r6, #8]
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800e5a4:	6862      	ldr	r2, [r4, #4]
 800e5a6:	f003 030c 	and.w	r3, r3, #12
 800e5aa:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 800e5ae:	d0d3      	beq.n	800e558 <HAL_RCC_ClockConfig+0x140>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800e5b0:	f7fe fe6c 	bl	800d28c <HAL_GetTick>
 800e5b4:	1bc0      	subs	r0, r0, r7
 800e5b6:	4540      	cmp	r0, r8
 800e5b8:	d9f3      	bls.n	800e5a2 <HAL_RCC_ClockConfig+0x18a>
 800e5ba:	e764      	b.n	800e486 <HAL_RCC_ClockConfig+0x6e>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800e5bc:	2b03      	cmp	r3, #3
 800e5be:	d102      	bne.n	800e5c6 <HAL_RCC_ClockConfig+0x1ae>
      if (LL_RCC_PLL_IsReady() == 0U)
 800e5c0:	f7ff fb9b 	bl	800dcfa <LL_RCC_PLL_IsReady>
 800e5c4:	e7dd      	b.n	800e582 <HAL_RCC_ClockConfig+0x16a>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 800e5c6:	b913      	cbnz	r3, 800e5ce <HAL_RCC_ClockConfig+0x1b6>
      if (LL_RCC_MSI_IsReady() == 0U)
 800e5c8:	f7ff fb88 	bl	800dcdc <LL_RCC_MSI_IsReady>
 800e5cc:	e7d9      	b.n	800e582 <HAL_RCC_ClockConfig+0x16a>
      if (LL_RCC_HSI_IsReady() == 0U)
 800e5ce:	f7ff fb7f 	bl	800dcd0 <LL_RCC_HSI_IsReady>
 800e5d2:	e7d6      	b.n	800e582 <HAL_RCC_ClockConfig+0x16a>
    __HAL_FLASH_SET_LATENCY(FLatency);
 800e5d4:	6823      	ldr	r3, [r4, #0]
 800e5d6:	f023 0307 	bic.w	r3, r3, #7
 800e5da:	432b      	orrs	r3, r5
 800e5dc:	6023      	str	r3, [r4, #0]
    tickstart = HAL_GetTick();
 800e5de:	f7fe fe55 	bl	800d28c <HAL_GetTick>
 800e5e2:	4606      	mov	r6, r0
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 800e5e4:	6823      	ldr	r3, [r4, #0]
 800e5e6:	f003 0307 	and.w	r3, r3, #7
 800e5ea:	42ab      	cmp	r3, r5
 800e5ec:	d0ba      	beq.n	800e564 <HAL_RCC_ClockConfig+0x14c>
      if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 800e5ee:	f7fe fe4d 	bl	800d28c <HAL_GetTick>
 800e5f2:	1b80      	subs	r0, r0, r6
 800e5f4:	2802      	cmp	r0, #2
 800e5f6:	d9f5      	bls.n	800e5e4 <HAL_RCC_ClockConfig+0x1cc>
 800e5f8:	e745      	b.n	800e486 <HAL_RCC_ClockConfig+0x6e>
 800e5fa:	bf00      	nop
 800e5fc:	58004000 	.word	0x58004000
 800e600:	2000340c 	.word	0x2000340c
 800e604:	20003414 	.word	0x20003414

0800e608 <HAL_RCC_GetPCLK1Freq>:
{
 800e608:	b508      	push	{r3, lr}
  return ((uint32_t)(__LL_RCC_CALC_PCLK1_FREQ(HAL_RCC_GetHCLKFreq(), LL_RCC_GetAPB1Prescaler())));
 800e60a:	f7ff fc55 	bl	800deb8 <HAL_RCC_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1));
 800e60e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800e612:	4a04      	ldr	r2, [pc, #16]	; (800e624 <HAL_RCC_GetPCLK1Freq+0x1c>)
 800e614:	689b      	ldr	r3, [r3, #8]
 800e616:	f3c3 2302 	ubfx	r3, r3, #8, #3
 800e61a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
}
 800e61e:	40d8      	lsrs	r0, r3
 800e620:	bd08      	pop	{r3, pc}
 800e622:	bf00      	nop
 800e624:	08011314 	.word	0x08011314

0800e628 <HAL_RCC_GetPCLK2Freq>:
{
 800e628:	b508      	push	{r3, lr}
  return ((uint32_t)(__LL_RCC_CALC_PCLK2_FREQ(HAL_RCC_GetHCLKFreq(), LL_RCC_GetAPB2Prescaler())));
 800e62a:	f7ff fc45 	bl	800deb8 <HAL_RCC_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2));
 800e62e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800e632:	4a04      	ldr	r2, [pc, #16]	; (800e644 <HAL_RCC_GetPCLK2Freq+0x1c>)
 800e634:	689b      	ldr	r3, [r3, #8]
 800e636:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 800e63a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
}
 800e63e:	40d8      	lsrs	r0, r3
 800e640:	bd08      	pop	{r3, pc}
 800e642:	bf00      	nop
 800e644:	08011314 	.word	0x08011314

0800e648 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 800e648:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800e64a:	4604      	mov	r4, r0
  uint32_t pclk;

  /* Check the parameters */
  assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
  if (UART_INSTANCE_LOWPOWER(huart))
 800e64c:	6803      	ldr	r3, [r0, #0]
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800e64e:	6921      	ldr	r1, [r4, #16]
 800e650:	68a2      	ldr	r2, [r4, #8]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800e652:	681d      	ldr	r5, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800e654:	69c0      	ldr	r0, [r0, #28]
 800e656:	430a      	orrs	r2, r1
 800e658:	6961      	ldr	r1, [r4, #20]
 800e65a:	430a      	orrs	r2, r1
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800e65c:	497e      	ldr	r1, [pc, #504]	; (800e858 <UART_SetConfig+0x210>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800e65e:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800e660:	4029      	ands	r1, r5
 800e662:	430a      	orrs	r2, r1
 800e664:	601a      	str	r2, [r3, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800e666:	685a      	ldr	r2, [r3, #4]
 800e668:	68e1      	ldr	r1, [r4, #12]
 800e66a:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 800e66e:	430a      	orrs	r2, r1
 800e670:	605a      	str	r2, [r3, #4]
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;

  if (!(UART_INSTANCE_LOWPOWER(huart)))
 800e672:	4a7a      	ldr	r2, [pc, #488]	; (800e85c <UART_SetConfig+0x214>)
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 800e674:	69a1      	ldr	r1, [r4, #24]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 800e676:	4293      	cmp	r3, r2
  {
    tmpreg |= huart->Init.OneBitSampling;
 800e678:	bf1c      	itt	ne
 800e67a:	6a22      	ldrne	r2, [r4, #32]
 800e67c:	4311      	orrne	r1, r2
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 800e67e:	689a      	ldr	r2, [r3, #8]
 800e680:	f022 426e 	bic.w	r2, r2, #3992977408	; 0xee000000
 800e684:	f422 6230 	bic.w	r2, r2, #2816	; 0xb00
 800e688:	430a      	orrs	r2, r1
 800e68a:	609a      	str	r2, [r3, #8]

  /*-------------------------- USART PRESC Configuration -----------------------*/
  /* Configure
  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 800e68c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800e68e:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800e690:	f022 020f 	bic.w	r2, r2, #15
 800e694:	430a      	orrs	r2, r1
 800e696:	62da      	str	r2, [r3, #44]	; 0x2c

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 800e698:	4a71      	ldr	r2, [pc, #452]	; (800e860 <UART_SetConfig+0x218>)
 800e69a:	4293      	cmp	r3, r2
 800e69c:	d11c      	bne.n	800e6d8 <UART_SetConfig+0x90>
  return (uint32_t)(READ_BIT(RCC->CCIPR, USARTx) | (USARTx << 16));
 800e69e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800e6a2:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800e6a6:	f003 0303 	and.w	r3, r3, #3
 800e6aa:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
 800e6ae:	f5a3 3340 	sub.w	r3, r3, #196608	; 0x30000
 800e6b2:	3b01      	subs	r3, #1
 800e6b4:	2b02      	cmp	r3, #2
 800e6b6:	f200 80c8 	bhi.w	800e84a <UART_SetConfig+0x202>
 800e6ba:	4a6a      	ldr	r2, [pc, #424]	; (800e864 <UART_SetConfig+0x21c>)
 800e6bc:	5c9b      	ldrb	r3, [r3, r2]
      } /* if ( (lpuart_ker_ck_pres < (3 * huart->Init.BaudRate) ) ||
                (lpuart_ker_ck_pres > (4096 * huart->Init.BaudRate) )) */
    } /* if (pclk != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800e6be:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 800e6c2:	f040 808a 	bne.w	800e7da <UART_SetConfig+0x192>
  {
    switch (clocksource)
 800e6c6:	2b08      	cmp	r3, #8
 800e6c8:	d824      	bhi.n	800e714 <UART_SetConfig+0xcc>
 800e6ca:	e8df f003 	tbb	[pc, r3]
 800e6ce:	c161      	.short	0xc161
 800e6d0:	23812384 	.word	0x23812384
 800e6d4:	2323      	.short	0x2323
 800e6d6:	65          	.byte	0x65
 800e6d7:	00          	.byte	0x00
  UART_GETCLOCKSOURCE(huart, clocksource);
 800e6d8:	4a63      	ldr	r2, [pc, #396]	; (800e868 <UART_SetConfig+0x220>)
 800e6da:	4293      	cmp	r3, r2
 800e6dc:	d109      	bne.n	800e6f2 <UART_SetConfig+0xaa>
 800e6de:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800e6e2:	4a62      	ldr	r2, [pc, #392]	; (800e86c <UART_SetConfig+0x224>)
 800e6e4:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800e6e8:	f003 030c 	and.w	r3, r3, #12
 800e6ec:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
 800e6f0:	e7e4      	b.n	800e6bc <UART_SetConfig+0x74>
 800e6f2:	4a5a      	ldr	r2, [pc, #360]	; (800e85c <UART_SetConfig+0x214>)
 800e6f4:	4293      	cmp	r3, r2
 800e6f6:	d10d      	bne.n	800e714 <UART_SetConfig+0xcc>
  return (uint32_t)(READ_BIT(RCC->CCIPR, LPUARTx));
 800e6f8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800e6fc:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800e700:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
 800e704:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 800e708:	d01a      	beq.n	800e740 <UART_SetConfig+0xf8>
 800e70a:	d805      	bhi.n	800e718 <UART_SetConfig+0xd0>
 800e70c:	b153      	cbz	r3, 800e724 <UART_SetConfig+0xdc>
 800e70e:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800e712:	d012      	beq.n	800e73a <UART_SetConfig+0xf2>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800e714:	2001      	movs	r0, #1
 800e716:	e009      	b.n	800e72c <UART_SetConfig+0xe4>
  UART_GETCLOCKSOURCE(huart, clocksource);
 800e718:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 800e71c:	d1fa      	bne.n	800e714 <UART_SetConfig+0xcc>
        pclk = (uint32_t) LSE_VALUE;
 800e71e:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 800e722:	e00e      	b.n	800e742 <UART_SetConfig+0xfa>
        pclk = HAL_RCC_GetPCLK1Freq();
 800e724:	f7ff ff70 	bl	800e608 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 800e728:	b958      	cbnz	r0, 800e742 <UART_SetConfig+0xfa>
 800e72a:	2000      	movs	r0, #0
    }
  }

  /* Initialize the number of data to process during RX/TX ISR execution */
  huart->NbTxDataToProcess = 1;
  huart->NbRxDataToProcess = 1;
 800e72c:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 800e730:	66a3      	str	r3, [r4, #104]	; 0x68

  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 800e732:	2300      	movs	r3, #0
  huart->TxISR = NULL;
 800e734:	e9c4 331c 	strd	r3, r3, [r4, #112]	; 0x70

  return ret;
}
 800e738:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        pclk = HAL_RCC_GetSysClockFreq();
 800e73a:	f7ff fb4f 	bl	800dddc <HAL_RCC_GetSysClockFreq>
        break;
 800e73e:	e7f3      	b.n	800e728 <UART_SetConfig+0xe0>
  UART_GETCLOCKSOURCE(huart, clocksource);
 800e740:	484b      	ldr	r0, [pc, #300]	; (800e870 <UART_SetConfig+0x228>)
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 800e742:	6865      	ldr	r5, [r4, #4]
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 800e744:	4b4b      	ldr	r3, [pc, #300]	; (800e874 <UART_SetConfig+0x22c>)
 800e746:	6a62      	ldr	r2, [r4, #36]	; 0x24
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 800e748:	eb05 0145 	add.w	r1, r5, r5, lsl #1
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 800e74c:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
 800e750:	fbb0 f3f2 	udiv	r3, r0, r2
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 800e754:	4299      	cmp	r1, r3
 800e756:	d8dd      	bhi.n	800e714 <UART_SetConfig+0xcc>
 800e758:	ebb3 3f05 	cmp.w	r3, r5, lsl #12
 800e75c:	d8da      	bhi.n	800e714 <UART_SetConfig+0xcc>
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800e75e:	2300      	movs	r3, #0
 800e760:	2100      	movs	r1, #0
 800e762:	f7fa ffbd 	bl	80096e0 <__aeabi_uldivmod>
 800e766:	020f      	lsls	r7, r1, #8
 800e768:	ea47 6710 	orr.w	r7, r7, r0, lsr #24
 800e76c:	0206      	lsls	r6, r0, #8
 800e76e:	0868      	lsrs	r0, r5, #1
 800e770:	1830      	adds	r0, r6, r0
 800e772:	462a      	mov	r2, r5
 800e774:	f04f 0300 	mov.w	r3, #0
 800e778:	f147 0100 	adc.w	r1, r7, #0
 800e77c:	f7fa ffb0 	bl	80096e0 <__aeabi_uldivmod>
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 800e780:	4b3d      	ldr	r3, [pc, #244]	; (800e878 <UART_SetConfig+0x230>)
 800e782:	f5a0 7240 	sub.w	r2, r0, #768	; 0x300
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800e786:	429a      	cmp	r2, r3
 800e788:	d8c4      	bhi.n	800e714 <UART_SetConfig+0xcc>
        huart->Instance->BRR = usartdiv;
 800e78a:	6823      	ldr	r3, [r4, #0]
 800e78c:	60d8      	str	r0, [r3, #12]
 800e78e:	e7cc      	b.n	800e72a <UART_SetConfig+0xe2>
        pclk = HAL_RCC_GetPCLK1Freq();
 800e790:	f7ff ff3a 	bl	800e608 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 800e794:	2800      	cmp	r0, #0
 800e796:	d0c8      	beq.n	800e72a <UART_SetConfig+0xe2>
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800e798:	6862      	ldr	r2, [r4, #4]
 800e79a:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800e79c:	4b35      	ldr	r3, [pc, #212]	; (800e874 <UART_SetConfig+0x22c>)
 800e79e:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
 800e7a2:	fbb0 f3f3 	udiv	r3, r0, r3
 800e7a6:	0850      	lsrs	r0, r2, #1
 800e7a8:	eb00 0043 	add.w	r0, r0, r3, lsl #1
 800e7ac:	fbb0 f0f2 	udiv	r0, r0, r2
 800e7b0:	b283      	uxth	r3, r0
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800e7b2:	f1a3 0110 	sub.w	r1, r3, #16
 800e7b6:	f64f 72ef 	movw	r2, #65519	; 0xffef
 800e7ba:	4291      	cmp	r1, r2
 800e7bc:	d8aa      	bhi.n	800e714 <UART_SetConfig+0xcc>
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 800e7be:	f020 000f 	bic.w	r0, r0, #15
        huart->Instance->BRR = brrtemp;
 800e7c2:	6822      	ldr	r2, [r4, #0]
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 800e7c4:	b280      	uxth	r0, r0
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 800e7c6:	f3c3 0342 	ubfx	r3, r3, #1, #3
        huart->Instance->BRR = brrtemp;
 800e7ca:	4318      	orrs	r0, r3
 800e7cc:	60d0      	str	r0, [r2, #12]
 800e7ce:	e7ac      	b.n	800e72a <UART_SetConfig+0xe2>
        pclk = HAL_RCC_GetSysClockFreq();
 800e7d0:	f7ff fb04 	bl	800dddc <HAL_RCC_GetSysClockFreq>
        break;
 800e7d4:	e7de      	b.n	800e794 <UART_SetConfig+0x14c>
        pclk = (uint32_t) HSI_VALUE;
 800e7d6:	4826      	ldr	r0, [pc, #152]	; (800e870 <UART_SetConfig+0x228>)
 800e7d8:	e7de      	b.n	800e798 <UART_SetConfig+0x150>
    switch (clocksource)
 800e7da:	2b08      	cmp	r3, #8
 800e7dc:	d89a      	bhi.n	800e714 <UART_SetConfig+0xcc>
 800e7de:	a201      	add	r2, pc, #4	; (adr r2, 800e7e4 <UART_SetConfig+0x19c>)
 800e7e0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800e7e4:	0800e82f 	.word	0x0800e82f
 800e7e8:	0800e83b 	.word	0x0800e83b
 800e7ec:	0800e847 	.word	0x0800e847
 800e7f0:	0800e715 	.word	0x0800e715
 800e7f4:	0800e841 	.word	0x0800e841
 800e7f8:	0800e715 	.word	0x0800e715
 800e7fc:	0800e715 	.word	0x0800e715
 800e800:	0800e715 	.word	0x0800e715
 800e804:	0800e809 	.word	0x0800e809
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800e808:	f44f 4000 	mov.w	r0, #32768	; 0x8000
      usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800e80c:	6863      	ldr	r3, [r4, #4]
 800e80e:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800e810:	4a18      	ldr	r2, [pc, #96]	; (800e874 <UART_SetConfig+0x22c>)
 800e812:	f832 2011 	ldrh.w	r2, [r2, r1, lsl #1]
 800e816:	fbb0 f0f2 	udiv	r0, r0, r2
 800e81a:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 800e81e:	fbb0 f0f3 	udiv	r0, r0, r3
 800e822:	b280      	uxth	r0, r0
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800e824:	f1a0 0210 	sub.w	r2, r0, #16
 800e828:	f64f 73ef 	movw	r3, #65519	; 0xffef
 800e82c:	e7ab      	b.n	800e786 <UART_SetConfig+0x13e>
        pclk = HAL_RCC_GetPCLK1Freq();
 800e82e:	f7ff feeb 	bl	800e608 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 800e832:	2800      	cmp	r0, #0
 800e834:	f43f af79 	beq.w	800e72a <UART_SetConfig+0xe2>
 800e838:	e7e8      	b.n	800e80c <UART_SetConfig+0x1c4>
        pclk = HAL_RCC_GetPCLK2Freq();
 800e83a:	f7ff fef5 	bl	800e628 <HAL_RCC_GetPCLK2Freq>
        break;
 800e83e:	e7f8      	b.n	800e832 <UART_SetConfig+0x1ea>
        pclk = HAL_RCC_GetSysClockFreq();
 800e840:	f7ff facc 	bl	800dddc <HAL_RCC_GetSysClockFreq>
        break;
 800e844:	e7f5      	b.n	800e832 <UART_SetConfig+0x1ea>
        pclk = (uint32_t) HSI_VALUE;
 800e846:	480a      	ldr	r0, [pc, #40]	; (800e870 <UART_SetConfig+0x228>)
 800e848:	e7e0      	b.n	800e80c <UART_SetConfig+0x1c4>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800e84a:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 800e84e:	d1f4      	bne.n	800e83a <UART_SetConfig+0x1f2>
        pclk = HAL_RCC_GetPCLK2Freq();
 800e850:	f7ff feea 	bl	800e628 <HAL_RCC_GetPCLK2Freq>
        break;
 800e854:	e79e      	b.n	800e794 <UART_SetConfig+0x14c>
 800e856:	bf00      	nop
 800e858:	cfff69f3 	.word	0xcfff69f3
 800e85c:	40008000 	.word	0x40008000
 800e860:	40013800 	.word	0x40013800
 800e864:	08011374 	.word	0x08011374
 800e868:	40004400 	.word	0x40004400
 800e86c:	07f51377 	.word	0x07f51377
 800e870:	00f42400 	.word	0x00f42400
 800e874:	08011384 	.word	0x08011384
 800e878:	000ffcff 	.word	0x000ffcff

0800e87c <UART_AdvFeatureConfig>:
{
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 800e87c:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800e87e:	07da      	lsls	r2, r3, #31
{
 800e880:	b510      	push	{r4, lr}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 800e882:	d506      	bpl.n	800e892 <UART_AdvFeatureConfig+0x16>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 800e884:	6801      	ldr	r1, [r0, #0]
 800e886:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 800e888:	684a      	ldr	r2, [r1, #4]
 800e88a:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 800e88e:	4322      	orrs	r2, r4
 800e890:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 800e892:	079c      	lsls	r4, r3, #30
 800e894:	d506      	bpl.n	800e8a4 <UART_AdvFeatureConfig+0x28>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 800e896:	6801      	ldr	r1, [r0, #0]
 800e898:	6b04      	ldr	r4, [r0, #48]	; 0x30
 800e89a:	684a      	ldr	r2, [r1, #4]
 800e89c:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800e8a0:	4322      	orrs	r2, r4
 800e8a2:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 800e8a4:	0759      	lsls	r1, r3, #29
 800e8a6:	d506      	bpl.n	800e8b6 <UART_AdvFeatureConfig+0x3a>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 800e8a8:	6801      	ldr	r1, [r0, #0]
 800e8aa:	6b44      	ldr	r4, [r0, #52]	; 0x34
 800e8ac:	684a      	ldr	r2, [r1, #4]
 800e8ae:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800e8b2:	4322      	orrs	r2, r4
 800e8b4:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 800e8b6:	071a      	lsls	r2, r3, #28
 800e8b8:	d506      	bpl.n	800e8c8 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 800e8ba:	6801      	ldr	r1, [r0, #0]
 800e8bc:	6b84      	ldr	r4, [r0, #56]	; 0x38
 800e8be:	684a      	ldr	r2, [r1, #4]
 800e8c0:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800e8c4:	4322      	orrs	r2, r4
 800e8c6:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 800e8c8:	06dc      	lsls	r4, r3, #27
 800e8ca:	d506      	bpl.n	800e8da <UART_AdvFeatureConfig+0x5e>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 800e8cc:	6801      	ldr	r1, [r0, #0]
 800e8ce:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 800e8d0:	688a      	ldr	r2, [r1, #8]
 800e8d2:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 800e8d6:	4322      	orrs	r2, r4
 800e8d8:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 800e8da:	0699      	lsls	r1, r3, #26
 800e8dc:	d506      	bpl.n	800e8ec <UART_AdvFeatureConfig+0x70>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 800e8de:	6801      	ldr	r1, [r0, #0]
 800e8e0:	6c04      	ldr	r4, [r0, #64]	; 0x40
 800e8e2:	688a      	ldr	r2, [r1, #8]
 800e8e4:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 800e8e8:	4322      	orrs	r2, r4
 800e8ea:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 800e8ec:	065a      	lsls	r2, r3, #25
 800e8ee:	d50f      	bpl.n	800e910 <UART_AdvFeatureConfig+0x94>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 800e8f0:	6801      	ldr	r1, [r0, #0]
 800e8f2:	6c44      	ldr	r4, [r0, #68]	; 0x44
 800e8f4:	684a      	ldr	r2, [r1, #4]
 800e8f6:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 800e8fa:	4322      	orrs	r2, r4
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 800e8fc:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 800e900:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 800e902:	d105      	bne.n	800e910 <UART_AdvFeatureConfig+0x94>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 800e904:	684a      	ldr	r2, [r1, #4]
 800e906:	6c84      	ldr	r4, [r0, #72]	; 0x48
 800e908:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
 800e90c:	4322      	orrs	r2, r4
 800e90e:	604a      	str	r2, [r1, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 800e910:	061b      	lsls	r3, r3, #24
 800e912:	d506      	bpl.n	800e922 <UART_AdvFeatureConfig+0xa6>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 800e914:	6802      	ldr	r2, [r0, #0]
 800e916:	6cc1      	ldr	r1, [r0, #76]	; 0x4c
 800e918:	6853      	ldr	r3, [r2, #4]
 800e91a:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 800e91e:	430b      	orrs	r3, r1
 800e920:	6053      	str	r3, [r2, #4]
  }
}
 800e922:	bd10      	pop	{r4, pc}

0800e924 <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
 800e924:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800e928:	f8dd 8018 	ldr.w	r8, [sp, #24]
 800e92c:	4604      	mov	r4, r0
 800e92e:	460e      	mov	r6, r1
 800e930:	4615      	mov	r5, r2
 800e932:	461f      	mov	r7, r3
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800e934:	6822      	ldr	r2, [r4, #0]
 800e936:	69d3      	ldr	r3, [r2, #28]
 800e938:	ea36 0303 	bics.w	r3, r6, r3
 800e93c:	bf0c      	ite	eq
 800e93e:	2301      	moveq	r3, #1
 800e940:	2300      	movne	r3, #0
 800e942:	42ab      	cmp	r3, r5
 800e944:	d001      	beq.n	800e94a <UART_WaitOnFlagUntilTimeout+0x26>
          return HAL_TIMEOUT;
        }
      }
    }
  }
  return HAL_OK;
 800e946:	2000      	movs	r0, #0
 800e948:	e027      	b.n	800e99a <UART_WaitOnFlagUntilTimeout+0x76>
    if (Timeout != HAL_MAX_DELAY)
 800e94a:	f1b8 3fff 	cmp.w	r8, #4294967295
 800e94e:	d0f2      	beq.n	800e936 <UART_WaitOnFlagUntilTimeout+0x12>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800e950:	f7fe fc9c 	bl	800d28c <HAL_GetTick>
 800e954:	1bc0      	subs	r0, r0, r7
 800e956:	4540      	cmp	r0, r8
 800e958:	6820      	ldr	r0, [r4, #0]
 800e95a:	d802      	bhi.n	800e962 <UART_WaitOnFlagUntilTimeout+0x3e>
 800e95c:	f1b8 0f00 	cmp.w	r8, #0
 800e960:	d11d      	bne.n	800e99e <UART_WaitOnFlagUntilTimeout+0x7a>
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800e962:	e850 3f00 	ldrex	r3, [r0]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |
 800e966:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800e96a:	e840 3200 	strex	r2, r3, [r0]
 800e96e:	2a00      	cmp	r2, #0
 800e970:	d1f7      	bne.n	800e962 <UART_WaitOnFlagUntilTimeout+0x3e>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800e972:	f100 0308 	add.w	r3, r0, #8
 800e976:	e853 3f00 	ldrex	r3, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800e97a:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800e97e:	f100 0108 	add.w	r1, r0, #8
 800e982:	e841 3200 	strex	r2, r3, [r1]
 800e986:	2a00      	cmp	r2, #0
 800e988:	d1f3      	bne.n	800e972 <UART_WaitOnFlagUntilTimeout+0x4e>
        huart->gState = HAL_UART_STATE_READY;
 800e98a:	2320      	movs	r3, #32
 800e98c:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
        huart->RxState = HAL_UART_STATE_READY;
 800e990:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
          __HAL_UNLOCK(huart);
 800e994:	f884 2080 	strb.w	r2, [r4, #128]	; 0x80
          return HAL_TIMEOUT;
 800e998:	2003      	movs	r0, #3
}
 800e99a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 800e99e:	6803      	ldr	r3, [r0, #0]
 800e9a0:	075a      	lsls	r2, r3, #29
 800e9a2:	d5c7      	bpl.n	800e934 <UART_WaitOnFlagUntilTimeout+0x10>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 800e9a4:	69c3      	ldr	r3, [r0, #28]
 800e9a6:	051b      	lsls	r3, r3, #20
 800e9a8:	d5c4      	bpl.n	800e934 <UART_WaitOnFlagUntilTimeout+0x10>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 800e9aa:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800e9ae:	6203      	str	r3, [r0, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800e9b0:	e850 3f00 	ldrex	r3, [r0]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |
 800e9b4:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800e9b8:	e840 3200 	strex	r2, r3, [r0]
 800e9bc:	2a00      	cmp	r2, #0
 800e9be:	d1f7      	bne.n	800e9b0 <UART_WaitOnFlagUntilTimeout+0x8c>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800e9c0:	f100 0308 	add.w	r3, r0, #8
 800e9c4:	e853 3f00 	ldrex	r3, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800e9c8:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800e9cc:	f100 0108 	add.w	r1, r0, #8
 800e9d0:	e841 3200 	strex	r2, r3, [r1]
 800e9d4:	2a00      	cmp	r2, #0
 800e9d6:	d1f3      	bne.n	800e9c0 <UART_WaitOnFlagUntilTimeout+0x9c>
          huart->gState = HAL_UART_STATE_READY;
 800e9d8:	2320      	movs	r3, #32
 800e9da:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
          huart->RxState = HAL_UART_STATE_READY;
 800e9de:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 800e9e2:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
 800e9e6:	e7d5      	b.n	800e994 <UART_WaitOnFlagUntilTimeout+0x70>

0800e9e8 <HAL_UART_Transmit>:
{
 800e9e8:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 800e9ec:	4698      	mov	r8, r3
  if (huart->gState == HAL_UART_STATE_READY)
 800e9ee:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
 800e9f2:	2b20      	cmp	r3, #32
{
 800e9f4:	4604      	mov	r4, r0
 800e9f6:	460e      	mov	r6, r1
 800e9f8:	4617      	mov	r7, r2
  if (huart->gState == HAL_UART_STATE_READY)
 800e9fa:	d14f      	bne.n	800ea9c <HAL_UART_Transmit+0xb4>
    if ((pData == NULL) || (Size == 0U))
 800e9fc:	2900      	cmp	r1, #0
 800e9fe:	d04b      	beq.n	800ea98 <HAL_UART_Transmit+0xb0>
 800ea00:	2a00      	cmp	r2, #0
 800ea02:	d049      	beq.n	800ea98 <HAL_UART_Transmit+0xb0>
    __HAL_LOCK(huart);
 800ea04:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 800ea08:	2b01      	cmp	r3, #1
 800ea0a:	d047      	beq.n	800ea9c <HAL_UART_Transmit+0xb4>
 800ea0c:	2301      	movs	r3, #1
 800ea0e:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800ea12:	2500      	movs	r5, #0
    huart->gState = HAL_UART_STATE_BUSY_TX;
 800ea14:	2321      	movs	r3, #33	; 0x21
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800ea16:	f8c0 508c 	str.w	r5, [r0, #140]	; 0x8c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 800ea1a:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
    tickstart = HAL_GetTick();
 800ea1e:	f7fe fc35 	bl	800d28c <HAL_GetTick>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800ea22:	68a3      	ldr	r3, [r4, #8]
    huart->TxXferSize  = Size;
 800ea24:	f8a4 7054 	strh.w	r7, [r4, #84]	; 0x54
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800ea28:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    tickstart = HAL_GetTick();
 800ea2c:	4681      	mov	r9, r0
    huart->TxXferCount = Size;
 800ea2e:	f8a4 7056 	strh.w	r7, [r4, #86]	; 0x56
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800ea32:	d103      	bne.n	800ea3c <HAL_UART_Transmit+0x54>
 800ea34:	6923      	ldr	r3, [r4, #16]
 800ea36:	b90b      	cbnz	r3, 800ea3c <HAL_UART_Transmit+0x54>
 800ea38:	4635      	mov	r5, r6
      pdata8bits  = NULL;
 800ea3a:	461e      	mov	r6, r3
    __HAL_UNLOCK(huart);
 800ea3c:	2300      	movs	r3, #0
 800ea3e:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
    while (huart->TxXferCount > 0U)
 800ea42:	f8b4 2056 	ldrh.w	r2, [r4, #86]	; 0x56
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 800ea46:	f8cd 8000 	str.w	r8, [sp]
    while (huart->TxXferCount > 0U)
 800ea4a:	b292      	uxth	r2, r2
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 800ea4c:	464b      	mov	r3, r9
    while (huart->TxXferCount > 0U)
 800ea4e:	b942      	cbnz	r2, 800ea62 <HAL_UART_Transmit+0x7a>
    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 800ea50:	2140      	movs	r1, #64	; 0x40
 800ea52:	4620      	mov	r0, r4
 800ea54:	f7ff ff66 	bl	800e924 <UART_WaitOnFlagUntilTimeout>
 800ea58:	b948      	cbnz	r0, 800ea6e <HAL_UART_Transmit+0x86>
    huart->gState = HAL_UART_STATE_READY;
 800ea5a:	2320      	movs	r3, #32
 800ea5c:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
    return HAL_OK;
 800ea60:	e006      	b.n	800ea70 <HAL_UART_Transmit+0x88>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 800ea62:	2200      	movs	r2, #0
 800ea64:	2180      	movs	r1, #128	; 0x80
 800ea66:	4620      	mov	r0, r4
 800ea68:	f7ff ff5c 	bl	800e924 <UART_WaitOnFlagUntilTimeout>
 800ea6c:	b118      	cbz	r0, 800ea76 <HAL_UART_Transmit+0x8e>
        return HAL_TIMEOUT;
 800ea6e:	2003      	movs	r0, #3
}
 800ea70:	b003      	add	sp, #12
 800ea72:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      if (pdata8bits == NULL)
 800ea76:	6822      	ldr	r2, [r4, #0]
 800ea78:	b95e      	cbnz	r6, 800ea92 <HAL_UART_Transmit+0xaa>
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 800ea7a:	f835 3b02 	ldrh.w	r3, [r5], #2
 800ea7e:	f3c3 0308 	ubfx	r3, r3, #0, #9
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 800ea82:	6293      	str	r3, [r2, #40]	; 0x28
      huart->TxXferCount--;
 800ea84:	f8b4 2056 	ldrh.w	r2, [r4, #86]	; 0x56
 800ea88:	3a01      	subs	r2, #1
 800ea8a:	b292      	uxth	r2, r2
 800ea8c:	f8a4 2056 	strh.w	r2, [r4, #86]	; 0x56
 800ea90:	e7d7      	b.n	800ea42 <HAL_UART_Transmit+0x5a>
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 800ea92:	f816 3b01 	ldrb.w	r3, [r6], #1
 800ea96:	e7f4      	b.n	800ea82 <HAL_UART_Transmit+0x9a>
      return  HAL_ERROR;
 800ea98:	2001      	movs	r0, #1
 800ea9a:	e7e9      	b.n	800ea70 <HAL_UART_Transmit+0x88>
    return HAL_BUSY;
 800ea9c:	2002      	movs	r0, #2
 800ea9e:	e7e7      	b.n	800ea70 <HAL_UART_Transmit+0x88>

0800eaa0 <HAL_UART_Receive>:
{
 800eaa0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 800eaa4:	461f      	mov	r7, r3
  if (huart->RxState == HAL_UART_STATE_READY)
 800eaa6:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
 800eaaa:	2b20      	cmp	r3, #32
{
 800eaac:	4604      	mov	r4, r0
 800eaae:	460d      	mov	r5, r1
 800eab0:	4616      	mov	r6, r2
  if (huart->RxState == HAL_UART_STATE_READY)
 800eab2:	d16a      	bne.n	800eb8a <HAL_UART_Receive+0xea>
    if ((pData == NULL) || (Size == 0U))
 800eab4:	2900      	cmp	r1, #0
 800eab6:	d066      	beq.n	800eb86 <HAL_UART_Receive+0xe6>
 800eab8:	2a00      	cmp	r2, #0
 800eaba:	d064      	beq.n	800eb86 <HAL_UART_Receive+0xe6>
    __HAL_LOCK(huart);
 800eabc:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 800eac0:	2b01      	cmp	r3, #1
 800eac2:	d062      	beq.n	800eb8a <HAL_UART_Receive+0xea>
 800eac4:	2301      	movs	r3, #1
 800eac6:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800eaca:	f04f 0800 	mov.w	r8, #0
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 800eace:	2322      	movs	r3, #34	; 0x22
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800ead0:	f8c0 808c 	str.w	r8, [r0, #140]	; 0x8c
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 800ead4:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800ead8:	f8c0 806c 	str.w	r8, [r0, #108]	; 0x6c
    tickstart = HAL_GetTick();
 800eadc:	f7fe fbd6 	bl	800d28c <HAL_GetTick>
    UART_MASK_COMPUTATION(huart);
 800eae0:	68a3      	ldr	r3, [r4, #8]
    huart->RxXferSize  = Size;
 800eae2:	f8a4 605c 	strh.w	r6, [r4, #92]	; 0x5c
    UART_MASK_COMPUTATION(huart);
 800eae6:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    tickstart = HAL_GetTick();
 800eaea:	4681      	mov	r9, r0
    huart->RxXferCount = Size;
 800eaec:	f8a4 605e 	strh.w	r6, [r4, #94]	; 0x5e
    UART_MASK_COMPUTATION(huart);
 800eaf0:	d11d      	bne.n	800eb2e <HAL_UART_Receive+0x8e>
 800eaf2:	6922      	ldr	r2, [r4, #16]
 800eaf4:	b9ca      	cbnz	r2, 800eb2a <HAL_UART_Receive+0x8a>
 800eaf6:	f240 12ff 	movw	r2, #511	; 0x1ff
 800eafa:	f8a4 2060 	strh.w	r2, [r4, #96]	; 0x60
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800eafe:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    uhMask = huart->Mask;
 800eb02:	f8b4 8060 	ldrh.w	r8, [r4, #96]	; 0x60
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800eb06:	d123      	bne.n	800eb50 <HAL_UART_Receive+0xb0>
 800eb08:	6923      	ldr	r3, [r4, #16]
 800eb0a:	bb0b      	cbnz	r3, 800eb50 <HAL_UART_Receive+0xb0>
 800eb0c:	462e      	mov	r6, r5
      pdata8bits  = NULL;
 800eb0e:	461d      	mov	r5, r3
    __HAL_UNLOCK(huart);
 800eb10:	2300      	movs	r3, #0
 800eb12:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
    while (huart->RxXferCount > 0U)
 800eb16:	f8b4 005e 	ldrh.w	r0, [r4, #94]	; 0x5e
 800eb1a:	b280      	uxth	r0, r0
 800eb1c:	b9d0      	cbnz	r0, 800eb54 <HAL_UART_Receive+0xb4>
    huart->RxState = HAL_UART_STATE_READY;
 800eb1e:	2320      	movs	r3, #32
 800eb20:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
}
 800eb24:	b003      	add	sp, #12
 800eb26:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    UART_MASK_COMPUTATION(huart);
 800eb2a:	22ff      	movs	r2, #255	; 0xff
 800eb2c:	e7e5      	b.n	800eafa <HAL_UART_Receive+0x5a>
 800eb2e:	b923      	cbnz	r3, 800eb3a <HAL_UART_Receive+0x9a>
 800eb30:	6922      	ldr	r2, [r4, #16]
 800eb32:	2a00      	cmp	r2, #0
 800eb34:	d0f9      	beq.n	800eb2a <HAL_UART_Receive+0x8a>
 800eb36:	227f      	movs	r2, #127	; 0x7f
 800eb38:	e7df      	b.n	800eafa <HAL_UART_Receive+0x5a>
 800eb3a:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 800eb3e:	d104      	bne.n	800eb4a <HAL_UART_Receive+0xaa>
 800eb40:	6922      	ldr	r2, [r4, #16]
 800eb42:	2a00      	cmp	r2, #0
 800eb44:	d0f7      	beq.n	800eb36 <HAL_UART_Receive+0x96>
 800eb46:	223f      	movs	r2, #63	; 0x3f
 800eb48:	e7d7      	b.n	800eafa <HAL_UART_Receive+0x5a>
 800eb4a:	f8a4 8060 	strh.w	r8, [r4, #96]	; 0x60
 800eb4e:	e7d6      	b.n	800eafe <HAL_UART_Receive+0x5e>
      pdata16bits = NULL;
 800eb50:	2600      	movs	r6, #0
 800eb52:	e7dd      	b.n	800eb10 <HAL_UART_Receive+0x70>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
 800eb54:	9700      	str	r7, [sp, #0]
 800eb56:	464b      	mov	r3, r9
 800eb58:	2200      	movs	r2, #0
 800eb5a:	2120      	movs	r1, #32
 800eb5c:	4620      	mov	r0, r4
 800eb5e:	f7ff fee1 	bl	800e924 <UART_WaitOnFlagUntilTimeout>
 800eb62:	b9a0      	cbnz	r0, 800eb8e <HAL_UART_Receive+0xee>
      if (pdata8bits == NULL)
 800eb64:	6823      	ldr	r3, [r4, #0]
        *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);
 800eb66:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800eb68:	ea08 0303 	and.w	r3, r8, r3
      if (pdata8bits == NULL)
 800eb6c:	b945      	cbnz	r5, 800eb80 <HAL_UART_Receive+0xe0>
        *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);
 800eb6e:	f826 3b02 	strh.w	r3, [r6], #2
      huart->RxXferCount--;
 800eb72:	f8b4 205e 	ldrh.w	r2, [r4, #94]	; 0x5e
 800eb76:	3a01      	subs	r2, #1
 800eb78:	b292      	uxth	r2, r2
 800eb7a:	f8a4 205e 	strh.w	r2, [r4, #94]	; 0x5e
 800eb7e:	e7ca      	b.n	800eb16 <HAL_UART_Receive+0x76>
        *pdata8bits = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
 800eb80:	f805 3b01 	strb.w	r3, [r5], #1
        pdata8bits++;
 800eb84:	e7f5      	b.n	800eb72 <HAL_UART_Receive+0xd2>
      return  HAL_ERROR;
 800eb86:	2001      	movs	r0, #1
 800eb88:	e7cc      	b.n	800eb24 <HAL_UART_Receive+0x84>
    return HAL_BUSY;
 800eb8a:	2002      	movs	r0, #2
 800eb8c:	e7ca      	b.n	800eb24 <HAL_UART_Receive+0x84>
        return HAL_TIMEOUT;
 800eb8e:	2003      	movs	r0, #3
 800eb90:	e7c8      	b.n	800eb24 <HAL_UART_Receive+0x84>

0800eb92 <UART_CheckIdleState>:
{
 800eb92:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800eb94:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800eb96:	2600      	movs	r6, #0
 800eb98:	f8c0 608c 	str.w	r6, [r0, #140]	; 0x8c
  tickstart = HAL_GetTick();
 800eb9c:	f7fe fb76 	bl	800d28c <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800eba0:	6823      	ldr	r3, [r4, #0]
 800eba2:	681b      	ldr	r3, [r3, #0]
 800eba4:	071a      	lsls	r2, r3, #28
  tickstart = HAL_GetTick();
 800eba6:	4605      	mov	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800eba8:	d418      	bmi.n	800ebdc <UART_CheckIdleState+0x4a>
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 800ebaa:	6823      	ldr	r3, [r4, #0]
 800ebac:	681b      	ldr	r3, [r3, #0]
 800ebae:	075b      	lsls	r3, r3, #29
 800ebb0:	d50a      	bpl.n	800ebc8 <UART_CheckIdleState+0x36>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 800ebb2:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 800ebb6:	9300      	str	r3, [sp, #0]
 800ebb8:	2200      	movs	r2, #0
 800ebba:	462b      	mov	r3, r5
 800ebbc:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 800ebc0:	4620      	mov	r0, r4
 800ebc2:	f7ff feaf 	bl	800e924 <UART_WaitOnFlagUntilTimeout>
 800ebc6:	b9a8      	cbnz	r0, 800ebf4 <UART_CheckIdleState+0x62>
  huart->gState = HAL_UART_STATE_READY;
 800ebc8:	2320      	movs	r3, #32
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800ebca:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
 800ebcc:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  __HAL_UNLOCK(huart);
 800ebd0:	f884 0080 	strb.w	r0, [r4, #128]	; 0x80
  huart->RxState = HAL_UART_STATE_READY;
 800ebd4:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800ebd8:	66e0      	str	r0, [r4, #108]	; 0x6c
  return HAL_OK;
 800ebda:	e00c      	b.n	800ebf6 <UART_CheckIdleState+0x64>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 800ebdc:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 800ebe0:	9300      	str	r3, [sp, #0]
 800ebe2:	4632      	mov	r2, r6
 800ebe4:	4603      	mov	r3, r0
 800ebe6:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 800ebea:	4620      	mov	r0, r4
 800ebec:	f7ff fe9a 	bl	800e924 <UART_WaitOnFlagUntilTimeout>
 800ebf0:	2800      	cmp	r0, #0
 800ebf2:	d0da      	beq.n	800ebaa <UART_CheckIdleState+0x18>
      return HAL_TIMEOUT;
 800ebf4:	2003      	movs	r0, #3
}
 800ebf6:	b002      	add	sp, #8
 800ebf8:	bd70      	pop	{r4, r5, r6, pc}

0800ebfa <HAL_UART_Init>:
{
 800ebfa:	b510      	push	{r4, lr}
  if (huart == NULL)
 800ebfc:	4604      	mov	r4, r0
 800ebfe:	b350      	cbz	r0, 800ec56 <HAL_UART_Init+0x5c>
  if (huart->gState == HAL_UART_STATE_RESET)
 800ec00:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
 800ec04:	b91b      	cbnz	r3, 800ec0e <HAL_UART_Init+0x14>
    huart->Lock = HAL_UNLOCKED;
 800ec06:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
    HAL_UART_MspInit(huart);
 800ec0a:	f7fe f99c 	bl	800cf46 <HAL_UART_MspInit>
  __HAL_UART_DISABLE(huart);
 800ec0e:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 800ec10:	2324      	movs	r3, #36	; 0x24
 800ec12:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  __HAL_UART_DISABLE(huart);
 800ec16:	6813      	ldr	r3, [r2, #0]
 800ec18:	f023 0301 	bic.w	r3, r3, #1
 800ec1c:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 800ec1e:	4620      	mov	r0, r4
 800ec20:	f7ff fd12 	bl	800e648 <UART_SetConfig>
 800ec24:	2801      	cmp	r0, #1
 800ec26:	d016      	beq.n	800ec56 <HAL_UART_Init+0x5c>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 800ec28:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800ec2a:	b113      	cbz	r3, 800ec32 <HAL_UART_Init+0x38>
    UART_AdvFeatureConfig(huart);
 800ec2c:	4620      	mov	r0, r4
 800ec2e:	f7ff fe25 	bl	800e87c <UART_AdvFeatureConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 800ec32:	6823      	ldr	r3, [r4, #0]
 800ec34:	685a      	ldr	r2, [r3, #4]
 800ec36:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 800ec3a:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 800ec3c:	689a      	ldr	r2, [r3, #8]
 800ec3e:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 800ec42:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 800ec44:	681a      	ldr	r2, [r3, #0]
 800ec46:	f042 0201 	orr.w	r2, r2, #1
  return (UART_CheckIdleState(huart));
 800ec4a:	4620      	mov	r0, r4
  __HAL_UART_ENABLE(huart);
 800ec4c:	601a      	str	r2, [r3, #0]
}
 800ec4e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return (UART_CheckIdleState(huart));
 800ec52:	f7ff bf9e 	b.w	800eb92 <UART_CheckIdleState>
}
 800ec56:	2001      	movs	r0, #1
 800ec58:	bd10      	pop	{r4, pc}
	...

0800ec5c <__errno>:
 800ec5c:	4b01      	ldr	r3, [pc, #4]	; (800ec64 <__errno+0x8>)
 800ec5e:	6818      	ldr	r0, [r3, #0]
 800ec60:	4770      	bx	lr
 800ec62:	bf00      	nop
 800ec64:	20003418 	.word	0x20003418

0800ec68 <__libc_init_array>:
 800ec68:	b570      	push	{r4, r5, r6, lr}
 800ec6a:	4d0d      	ldr	r5, [pc, #52]	; (800eca0 <__libc_init_array+0x38>)
 800ec6c:	4c0d      	ldr	r4, [pc, #52]	; (800eca4 <__libc_init_array+0x3c>)
 800ec6e:	1b64      	subs	r4, r4, r5
 800ec70:	10a4      	asrs	r4, r4, #2
 800ec72:	2600      	movs	r6, #0
 800ec74:	42a6      	cmp	r6, r4
 800ec76:	d109      	bne.n	800ec8c <__libc_init_array+0x24>
 800ec78:	4d0b      	ldr	r5, [pc, #44]	; (800eca8 <__libc_init_array+0x40>)
 800ec7a:	4c0c      	ldr	r4, [pc, #48]	; (800ecac <__libc_init_array+0x44>)
 800ec7c:	f001 f92e 	bl	800fedc <_init>
 800ec80:	1b64      	subs	r4, r4, r5
 800ec82:	10a4      	asrs	r4, r4, #2
 800ec84:	2600      	movs	r6, #0
 800ec86:	42a6      	cmp	r6, r4
 800ec88:	d105      	bne.n	800ec96 <__libc_init_array+0x2e>
 800ec8a:	bd70      	pop	{r4, r5, r6, pc}
 800ec8c:	f855 3b04 	ldr.w	r3, [r5], #4
 800ec90:	4798      	blx	r3
 800ec92:	3601      	adds	r6, #1
 800ec94:	e7ee      	b.n	800ec74 <__libc_init_array+0xc>
 800ec96:	f855 3b04 	ldr.w	r3, [r5], #4
 800ec9a:	4798      	blx	r3
 800ec9c:	3601      	adds	r6, #1
 800ec9e:	e7f2      	b.n	800ec86 <__libc_init_array+0x1e>
 800eca0:	08011440 	.word	0x08011440
 800eca4:	08011440 	.word	0x08011440
 800eca8:	08011440 	.word	0x08011440
 800ecac:	08011444 	.word	0x08011444

0800ecb0 <memcmp>:
 800ecb0:	b530      	push	{r4, r5, lr}
 800ecb2:	3901      	subs	r1, #1
 800ecb4:	2400      	movs	r4, #0
 800ecb6:	42a2      	cmp	r2, r4
 800ecb8:	d101      	bne.n	800ecbe <memcmp+0xe>
 800ecba:	2000      	movs	r0, #0
 800ecbc:	e005      	b.n	800ecca <memcmp+0x1a>
 800ecbe:	5d03      	ldrb	r3, [r0, r4]
 800ecc0:	3401      	adds	r4, #1
 800ecc2:	5d0d      	ldrb	r5, [r1, r4]
 800ecc4:	42ab      	cmp	r3, r5
 800ecc6:	d0f6      	beq.n	800ecb6 <memcmp+0x6>
 800ecc8:	1b58      	subs	r0, r3, r5
 800ecca:	bd30      	pop	{r4, r5, pc}

0800eccc <memcpy>:
 800eccc:	440a      	add	r2, r1
 800ecce:	4291      	cmp	r1, r2
 800ecd0:	f100 33ff 	add.w	r3, r0, #4294967295
 800ecd4:	d100      	bne.n	800ecd8 <memcpy+0xc>
 800ecd6:	4770      	bx	lr
 800ecd8:	b510      	push	{r4, lr}
 800ecda:	f811 4b01 	ldrb.w	r4, [r1], #1
 800ecde:	f803 4f01 	strb.w	r4, [r3, #1]!
 800ece2:	4291      	cmp	r1, r2
 800ece4:	d1f9      	bne.n	800ecda <memcpy+0xe>
 800ece6:	bd10      	pop	{r4, pc}

0800ece8 <memset>:
 800ece8:	4402      	add	r2, r0
 800ecea:	4603      	mov	r3, r0
 800ecec:	4293      	cmp	r3, r2
 800ecee:	d100      	bne.n	800ecf2 <memset+0xa>
 800ecf0:	4770      	bx	lr
 800ecf2:	f803 1b01 	strb.w	r1, [r3], #1
 800ecf6:	e7f9      	b.n	800ecec <memset+0x4>

0800ecf8 <iprintf>:
 800ecf8:	b40f      	push	{r0, r1, r2, r3}
 800ecfa:	4b0a      	ldr	r3, [pc, #40]	; (800ed24 <iprintf+0x2c>)
 800ecfc:	b513      	push	{r0, r1, r4, lr}
 800ecfe:	681c      	ldr	r4, [r3, #0]
 800ed00:	b124      	cbz	r4, 800ed0c <iprintf+0x14>
 800ed02:	69a3      	ldr	r3, [r4, #24]
 800ed04:	b913      	cbnz	r3, 800ed0c <iprintf+0x14>
 800ed06:	4620      	mov	r0, r4
 800ed08:	f000 fb38 	bl	800f37c <__sinit>
 800ed0c:	ab05      	add	r3, sp, #20
 800ed0e:	9a04      	ldr	r2, [sp, #16]
 800ed10:	68a1      	ldr	r1, [r4, #8]
 800ed12:	9301      	str	r3, [sp, #4]
 800ed14:	4620      	mov	r0, r4
 800ed16:	f000 fd0d 	bl	800f734 <_vfiprintf_r>
 800ed1a:	b002      	add	sp, #8
 800ed1c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800ed20:	b004      	add	sp, #16
 800ed22:	4770      	bx	lr
 800ed24:	20003418 	.word	0x20003418

0800ed28 <putchar>:
 800ed28:	b538      	push	{r3, r4, r5, lr}
 800ed2a:	4b08      	ldr	r3, [pc, #32]	; (800ed4c <putchar+0x24>)
 800ed2c:	681c      	ldr	r4, [r3, #0]
 800ed2e:	4605      	mov	r5, r0
 800ed30:	b124      	cbz	r4, 800ed3c <putchar+0x14>
 800ed32:	69a3      	ldr	r3, [r4, #24]
 800ed34:	b913      	cbnz	r3, 800ed3c <putchar+0x14>
 800ed36:	4620      	mov	r0, r4
 800ed38:	f000 fb20 	bl	800f37c <__sinit>
 800ed3c:	68a2      	ldr	r2, [r4, #8]
 800ed3e:	4629      	mov	r1, r5
 800ed40:	4620      	mov	r0, r4
 800ed42:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 800ed46:	f000 bfb9 	b.w	800fcbc <_putc_r>
 800ed4a:	bf00      	nop
 800ed4c:	20003418 	.word	0x20003418

0800ed50 <_puts_r>:
 800ed50:	b570      	push	{r4, r5, r6, lr}
 800ed52:	460e      	mov	r6, r1
 800ed54:	4605      	mov	r5, r0
 800ed56:	b118      	cbz	r0, 800ed60 <_puts_r+0x10>
 800ed58:	6983      	ldr	r3, [r0, #24]
 800ed5a:	b90b      	cbnz	r3, 800ed60 <_puts_r+0x10>
 800ed5c:	f000 fb0e 	bl	800f37c <__sinit>
 800ed60:	69ab      	ldr	r3, [r5, #24]
 800ed62:	68ac      	ldr	r4, [r5, #8]
 800ed64:	b913      	cbnz	r3, 800ed6c <_puts_r+0x1c>
 800ed66:	4628      	mov	r0, r5
 800ed68:	f000 fb08 	bl	800f37c <__sinit>
 800ed6c:	4b2c      	ldr	r3, [pc, #176]	; (800ee20 <_puts_r+0xd0>)
 800ed6e:	429c      	cmp	r4, r3
 800ed70:	d120      	bne.n	800edb4 <_puts_r+0x64>
 800ed72:	686c      	ldr	r4, [r5, #4]
 800ed74:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800ed76:	07db      	lsls	r3, r3, #31
 800ed78:	d405      	bmi.n	800ed86 <_puts_r+0x36>
 800ed7a:	89a3      	ldrh	r3, [r4, #12]
 800ed7c:	0598      	lsls	r0, r3, #22
 800ed7e:	d402      	bmi.n	800ed86 <_puts_r+0x36>
 800ed80:	6da0      	ldr	r0, [r4, #88]	; 0x58
 800ed82:	f000 fb99 	bl	800f4b8 <__retarget_lock_acquire_recursive>
 800ed86:	89a3      	ldrh	r3, [r4, #12]
 800ed88:	0719      	lsls	r1, r3, #28
 800ed8a:	d51d      	bpl.n	800edc8 <_puts_r+0x78>
 800ed8c:	6923      	ldr	r3, [r4, #16]
 800ed8e:	b1db      	cbz	r3, 800edc8 <_puts_r+0x78>
 800ed90:	3e01      	subs	r6, #1
 800ed92:	68a3      	ldr	r3, [r4, #8]
 800ed94:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 800ed98:	3b01      	subs	r3, #1
 800ed9a:	60a3      	str	r3, [r4, #8]
 800ed9c:	bb39      	cbnz	r1, 800edee <_puts_r+0x9e>
 800ed9e:	2b00      	cmp	r3, #0
 800eda0:	da38      	bge.n	800ee14 <_puts_r+0xc4>
 800eda2:	4622      	mov	r2, r4
 800eda4:	210a      	movs	r1, #10
 800eda6:	4628      	mov	r0, r5
 800eda8:	f000 f90e 	bl	800efc8 <__swbuf_r>
 800edac:	3001      	adds	r0, #1
 800edae:	d011      	beq.n	800edd4 <_puts_r+0x84>
 800edb0:	250a      	movs	r5, #10
 800edb2:	e011      	b.n	800edd8 <_puts_r+0x88>
 800edb4:	4b1b      	ldr	r3, [pc, #108]	; (800ee24 <_puts_r+0xd4>)
 800edb6:	429c      	cmp	r4, r3
 800edb8:	d101      	bne.n	800edbe <_puts_r+0x6e>
 800edba:	68ac      	ldr	r4, [r5, #8]
 800edbc:	e7da      	b.n	800ed74 <_puts_r+0x24>
 800edbe:	4b1a      	ldr	r3, [pc, #104]	; (800ee28 <_puts_r+0xd8>)
 800edc0:	429c      	cmp	r4, r3
 800edc2:	bf08      	it	eq
 800edc4:	68ec      	ldreq	r4, [r5, #12]
 800edc6:	e7d5      	b.n	800ed74 <_puts_r+0x24>
 800edc8:	4621      	mov	r1, r4
 800edca:	4628      	mov	r0, r5
 800edcc:	f000 f94e 	bl	800f06c <__swsetup_r>
 800edd0:	2800      	cmp	r0, #0
 800edd2:	d0dd      	beq.n	800ed90 <_puts_r+0x40>
 800edd4:	f04f 35ff 	mov.w	r5, #4294967295
 800edd8:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800edda:	07da      	lsls	r2, r3, #31
 800eddc:	d405      	bmi.n	800edea <_puts_r+0x9a>
 800edde:	89a3      	ldrh	r3, [r4, #12]
 800ede0:	059b      	lsls	r3, r3, #22
 800ede2:	d402      	bmi.n	800edea <_puts_r+0x9a>
 800ede4:	6da0      	ldr	r0, [r4, #88]	; 0x58
 800ede6:	f000 fb68 	bl	800f4ba <__retarget_lock_release_recursive>
 800edea:	4628      	mov	r0, r5
 800edec:	bd70      	pop	{r4, r5, r6, pc}
 800edee:	2b00      	cmp	r3, #0
 800edf0:	da04      	bge.n	800edfc <_puts_r+0xac>
 800edf2:	69a2      	ldr	r2, [r4, #24]
 800edf4:	429a      	cmp	r2, r3
 800edf6:	dc06      	bgt.n	800ee06 <_puts_r+0xb6>
 800edf8:	290a      	cmp	r1, #10
 800edfa:	d004      	beq.n	800ee06 <_puts_r+0xb6>
 800edfc:	6823      	ldr	r3, [r4, #0]
 800edfe:	1c5a      	adds	r2, r3, #1
 800ee00:	6022      	str	r2, [r4, #0]
 800ee02:	7019      	strb	r1, [r3, #0]
 800ee04:	e7c5      	b.n	800ed92 <_puts_r+0x42>
 800ee06:	4622      	mov	r2, r4
 800ee08:	4628      	mov	r0, r5
 800ee0a:	f000 f8dd 	bl	800efc8 <__swbuf_r>
 800ee0e:	3001      	adds	r0, #1
 800ee10:	d1bf      	bne.n	800ed92 <_puts_r+0x42>
 800ee12:	e7df      	b.n	800edd4 <_puts_r+0x84>
 800ee14:	6823      	ldr	r3, [r4, #0]
 800ee16:	250a      	movs	r5, #10
 800ee18:	1c5a      	adds	r2, r3, #1
 800ee1a:	6022      	str	r2, [r4, #0]
 800ee1c:	701d      	strb	r5, [r3, #0]
 800ee1e:	e7db      	b.n	800edd8 <_puts_r+0x88>
 800ee20:	080113c0 	.word	0x080113c0
 800ee24:	080113e0 	.word	0x080113e0
 800ee28:	080113a0 	.word	0x080113a0

0800ee2c <puts>:
 800ee2c:	4b02      	ldr	r3, [pc, #8]	; (800ee38 <puts+0xc>)
 800ee2e:	4601      	mov	r1, r0
 800ee30:	6818      	ldr	r0, [r3, #0]
 800ee32:	f7ff bf8d 	b.w	800ed50 <_puts_r>
 800ee36:	bf00      	nop
 800ee38:	20003418 	.word	0x20003418

0800ee3c <setvbuf>:
 800ee3c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 800ee40:	461d      	mov	r5, r3
 800ee42:	4b5d      	ldr	r3, [pc, #372]	; (800efb8 <setvbuf+0x17c>)
 800ee44:	681f      	ldr	r7, [r3, #0]
 800ee46:	4604      	mov	r4, r0
 800ee48:	460e      	mov	r6, r1
 800ee4a:	4690      	mov	r8, r2
 800ee4c:	b127      	cbz	r7, 800ee58 <setvbuf+0x1c>
 800ee4e:	69bb      	ldr	r3, [r7, #24]
 800ee50:	b913      	cbnz	r3, 800ee58 <setvbuf+0x1c>
 800ee52:	4638      	mov	r0, r7
 800ee54:	f000 fa92 	bl	800f37c <__sinit>
 800ee58:	4b58      	ldr	r3, [pc, #352]	; (800efbc <setvbuf+0x180>)
 800ee5a:	429c      	cmp	r4, r3
 800ee5c:	d167      	bne.n	800ef2e <setvbuf+0xf2>
 800ee5e:	687c      	ldr	r4, [r7, #4]
 800ee60:	f1b8 0f02 	cmp.w	r8, #2
 800ee64:	d006      	beq.n	800ee74 <setvbuf+0x38>
 800ee66:	f1b8 0f01 	cmp.w	r8, #1
 800ee6a:	f200 809f 	bhi.w	800efac <setvbuf+0x170>
 800ee6e:	2d00      	cmp	r5, #0
 800ee70:	f2c0 809c 	blt.w	800efac <setvbuf+0x170>
 800ee74:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800ee76:	07db      	lsls	r3, r3, #31
 800ee78:	d405      	bmi.n	800ee86 <setvbuf+0x4a>
 800ee7a:	89a3      	ldrh	r3, [r4, #12]
 800ee7c:	0598      	lsls	r0, r3, #22
 800ee7e:	d402      	bmi.n	800ee86 <setvbuf+0x4a>
 800ee80:	6da0      	ldr	r0, [r4, #88]	; 0x58
 800ee82:	f000 fb19 	bl	800f4b8 <__retarget_lock_acquire_recursive>
 800ee86:	4621      	mov	r1, r4
 800ee88:	4638      	mov	r0, r7
 800ee8a:	f000 f9e3 	bl	800f254 <_fflush_r>
 800ee8e:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800ee90:	b141      	cbz	r1, 800eea4 <setvbuf+0x68>
 800ee92:	f104 0344 	add.w	r3, r4, #68	; 0x44
 800ee96:	4299      	cmp	r1, r3
 800ee98:	d002      	beq.n	800eea0 <setvbuf+0x64>
 800ee9a:	4638      	mov	r0, r7
 800ee9c:	f000 fb7a 	bl	800f594 <_free_r>
 800eea0:	2300      	movs	r3, #0
 800eea2:	6363      	str	r3, [r4, #52]	; 0x34
 800eea4:	2300      	movs	r3, #0
 800eea6:	61a3      	str	r3, [r4, #24]
 800eea8:	6063      	str	r3, [r4, #4]
 800eeaa:	89a3      	ldrh	r3, [r4, #12]
 800eeac:	0619      	lsls	r1, r3, #24
 800eeae:	d503      	bpl.n	800eeb8 <setvbuf+0x7c>
 800eeb0:	6921      	ldr	r1, [r4, #16]
 800eeb2:	4638      	mov	r0, r7
 800eeb4:	f000 fb6e 	bl	800f594 <_free_r>
 800eeb8:	89a3      	ldrh	r3, [r4, #12]
 800eeba:	f423 634a 	bic.w	r3, r3, #3232	; 0xca0
 800eebe:	f023 0303 	bic.w	r3, r3, #3
 800eec2:	f1b8 0f02 	cmp.w	r8, #2
 800eec6:	81a3      	strh	r3, [r4, #12]
 800eec8:	d06c      	beq.n	800efa4 <setvbuf+0x168>
 800eeca:	ab01      	add	r3, sp, #4
 800eecc:	466a      	mov	r2, sp
 800eece:	4621      	mov	r1, r4
 800eed0:	4638      	mov	r0, r7
 800eed2:	f000 faf3 	bl	800f4bc <__swhatbuf_r>
 800eed6:	89a3      	ldrh	r3, [r4, #12]
 800eed8:	4318      	orrs	r0, r3
 800eeda:	81a0      	strh	r0, [r4, #12]
 800eedc:	2d00      	cmp	r5, #0
 800eede:	d130      	bne.n	800ef42 <setvbuf+0x106>
 800eee0:	9d00      	ldr	r5, [sp, #0]
 800eee2:	4628      	mov	r0, r5
 800eee4:	f000 fb4e 	bl	800f584 <malloc>
 800eee8:	4606      	mov	r6, r0
 800eeea:	2800      	cmp	r0, #0
 800eeec:	d155      	bne.n	800ef9a <setvbuf+0x15e>
 800eeee:	f8dd 9000 	ldr.w	r9, [sp]
 800eef2:	45a9      	cmp	r9, r5
 800eef4:	d14a      	bne.n	800ef8c <setvbuf+0x150>
 800eef6:	f04f 35ff 	mov.w	r5, #4294967295
 800eefa:	2200      	movs	r2, #0
 800eefc:	60a2      	str	r2, [r4, #8]
 800eefe:	f104 0247 	add.w	r2, r4, #71	; 0x47
 800ef02:	6022      	str	r2, [r4, #0]
 800ef04:	6122      	str	r2, [r4, #16]
 800ef06:	2201      	movs	r2, #1
 800ef08:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800ef0c:	6162      	str	r2, [r4, #20]
 800ef0e:	6e62      	ldr	r2, [r4, #100]	; 0x64
 800ef10:	f043 0302 	orr.w	r3, r3, #2
 800ef14:	07d2      	lsls	r2, r2, #31
 800ef16:	81a3      	strh	r3, [r4, #12]
 800ef18:	d405      	bmi.n	800ef26 <setvbuf+0xea>
 800ef1a:	f413 7f00 	tst.w	r3, #512	; 0x200
 800ef1e:	d102      	bne.n	800ef26 <setvbuf+0xea>
 800ef20:	6da0      	ldr	r0, [r4, #88]	; 0x58
 800ef22:	f000 faca 	bl	800f4ba <__retarget_lock_release_recursive>
 800ef26:	4628      	mov	r0, r5
 800ef28:	b003      	add	sp, #12
 800ef2a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800ef2e:	4b24      	ldr	r3, [pc, #144]	; (800efc0 <setvbuf+0x184>)
 800ef30:	429c      	cmp	r4, r3
 800ef32:	d101      	bne.n	800ef38 <setvbuf+0xfc>
 800ef34:	68bc      	ldr	r4, [r7, #8]
 800ef36:	e793      	b.n	800ee60 <setvbuf+0x24>
 800ef38:	4b22      	ldr	r3, [pc, #136]	; (800efc4 <setvbuf+0x188>)
 800ef3a:	429c      	cmp	r4, r3
 800ef3c:	bf08      	it	eq
 800ef3e:	68fc      	ldreq	r4, [r7, #12]
 800ef40:	e78e      	b.n	800ee60 <setvbuf+0x24>
 800ef42:	2e00      	cmp	r6, #0
 800ef44:	d0cd      	beq.n	800eee2 <setvbuf+0xa6>
 800ef46:	69bb      	ldr	r3, [r7, #24]
 800ef48:	b913      	cbnz	r3, 800ef50 <setvbuf+0x114>
 800ef4a:	4638      	mov	r0, r7
 800ef4c:	f000 fa16 	bl	800f37c <__sinit>
 800ef50:	f1b8 0f01 	cmp.w	r8, #1
 800ef54:	bf08      	it	eq
 800ef56:	89a3      	ldrheq	r3, [r4, #12]
 800ef58:	6026      	str	r6, [r4, #0]
 800ef5a:	bf04      	itt	eq
 800ef5c:	f043 0301 	orreq.w	r3, r3, #1
 800ef60:	81a3      	strheq	r3, [r4, #12]
 800ef62:	89a2      	ldrh	r2, [r4, #12]
 800ef64:	f012 0308 	ands.w	r3, r2, #8
 800ef68:	e9c4 6504 	strd	r6, r5, [r4, #16]
 800ef6c:	d01c      	beq.n	800efa8 <setvbuf+0x16c>
 800ef6e:	07d3      	lsls	r3, r2, #31
 800ef70:	bf41      	itttt	mi
 800ef72:	2300      	movmi	r3, #0
 800ef74:	426d      	negmi	r5, r5
 800ef76:	60a3      	strmi	r3, [r4, #8]
 800ef78:	61a5      	strmi	r5, [r4, #24]
 800ef7a:	bf58      	it	pl
 800ef7c:	60a5      	strpl	r5, [r4, #8]
 800ef7e:	6e65      	ldr	r5, [r4, #100]	; 0x64
 800ef80:	f015 0501 	ands.w	r5, r5, #1
 800ef84:	d115      	bne.n	800efb2 <setvbuf+0x176>
 800ef86:	f412 7f00 	tst.w	r2, #512	; 0x200
 800ef8a:	e7c8      	b.n	800ef1e <setvbuf+0xe2>
 800ef8c:	4648      	mov	r0, r9
 800ef8e:	f000 faf9 	bl	800f584 <malloc>
 800ef92:	4606      	mov	r6, r0
 800ef94:	2800      	cmp	r0, #0
 800ef96:	d0ae      	beq.n	800eef6 <setvbuf+0xba>
 800ef98:	464d      	mov	r5, r9
 800ef9a:	89a3      	ldrh	r3, [r4, #12]
 800ef9c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800efa0:	81a3      	strh	r3, [r4, #12]
 800efa2:	e7d0      	b.n	800ef46 <setvbuf+0x10a>
 800efa4:	2500      	movs	r5, #0
 800efa6:	e7a8      	b.n	800eefa <setvbuf+0xbe>
 800efa8:	60a3      	str	r3, [r4, #8]
 800efaa:	e7e8      	b.n	800ef7e <setvbuf+0x142>
 800efac:	f04f 35ff 	mov.w	r5, #4294967295
 800efb0:	e7b9      	b.n	800ef26 <setvbuf+0xea>
 800efb2:	2500      	movs	r5, #0
 800efb4:	e7b7      	b.n	800ef26 <setvbuf+0xea>
 800efb6:	bf00      	nop
 800efb8:	20003418 	.word	0x20003418
 800efbc:	080113c0 	.word	0x080113c0
 800efc0:	080113e0 	.word	0x080113e0
 800efc4:	080113a0 	.word	0x080113a0

0800efc8 <__swbuf_r>:
 800efc8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800efca:	460e      	mov	r6, r1
 800efcc:	4614      	mov	r4, r2
 800efce:	4605      	mov	r5, r0
 800efd0:	b118      	cbz	r0, 800efda <__swbuf_r+0x12>
 800efd2:	6983      	ldr	r3, [r0, #24]
 800efd4:	b90b      	cbnz	r3, 800efda <__swbuf_r+0x12>
 800efd6:	f000 f9d1 	bl	800f37c <__sinit>
 800efda:	4b21      	ldr	r3, [pc, #132]	; (800f060 <__swbuf_r+0x98>)
 800efdc:	429c      	cmp	r4, r3
 800efde:	d12b      	bne.n	800f038 <__swbuf_r+0x70>
 800efe0:	686c      	ldr	r4, [r5, #4]
 800efe2:	69a3      	ldr	r3, [r4, #24]
 800efe4:	60a3      	str	r3, [r4, #8]
 800efe6:	89a3      	ldrh	r3, [r4, #12]
 800efe8:	071a      	lsls	r2, r3, #28
 800efea:	d52f      	bpl.n	800f04c <__swbuf_r+0x84>
 800efec:	6923      	ldr	r3, [r4, #16]
 800efee:	b36b      	cbz	r3, 800f04c <__swbuf_r+0x84>
 800eff0:	6923      	ldr	r3, [r4, #16]
 800eff2:	6820      	ldr	r0, [r4, #0]
 800eff4:	1ac0      	subs	r0, r0, r3
 800eff6:	6963      	ldr	r3, [r4, #20]
 800eff8:	b2f6      	uxtb	r6, r6
 800effa:	4283      	cmp	r3, r0
 800effc:	4637      	mov	r7, r6
 800effe:	dc04      	bgt.n	800f00a <__swbuf_r+0x42>
 800f000:	4621      	mov	r1, r4
 800f002:	4628      	mov	r0, r5
 800f004:	f000 f926 	bl	800f254 <_fflush_r>
 800f008:	bb30      	cbnz	r0, 800f058 <__swbuf_r+0x90>
 800f00a:	68a3      	ldr	r3, [r4, #8]
 800f00c:	3b01      	subs	r3, #1
 800f00e:	60a3      	str	r3, [r4, #8]
 800f010:	6823      	ldr	r3, [r4, #0]
 800f012:	1c5a      	adds	r2, r3, #1
 800f014:	6022      	str	r2, [r4, #0]
 800f016:	701e      	strb	r6, [r3, #0]
 800f018:	6963      	ldr	r3, [r4, #20]
 800f01a:	3001      	adds	r0, #1
 800f01c:	4283      	cmp	r3, r0
 800f01e:	d004      	beq.n	800f02a <__swbuf_r+0x62>
 800f020:	89a3      	ldrh	r3, [r4, #12]
 800f022:	07db      	lsls	r3, r3, #31
 800f024:	d506      	bpl.n	800f034 <__swbuf_r+0x6c>
 800f026:	2e0a      	cmp	r6, #10
 800f028:	d104      	bne.n	800f034 <__swbuf_r+0x6c>
 800f02a:	4621      	mov	r1, r4
 800f02c:	4628      	mov	r0, r5
 800f02e:	f000 f911 	bl	800f254 <_fflush_r>
 800f032:	b988      	cbnz	r0, 800f058 <__swbuf_r+0x90>
 800f034:	4638      	mov	r0, r7
 800f036:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800f038:	4b0a      	ldr	r3, [pc, #40]	; (800f064 <__swbuf_r+0x9c>)
 800f03a:	429c      	cmp	r4, r3
 800f03c:	d101      	bne.n	800f042 <__swbuf_r+0x7a>
 800f03e:	68ac      	ldr	r4, [r5, #8]
 800f040:	e7cf      	b.n	800efe2 <__swbuf_r+0x1a>
 800f042:	4b09      	ldr	r3, [pc, #36]	; (800f068 <__swbuf_r+0xa0>)
 800f044:	429c      	cmp	r4, r3
 800f046:	bf08      	it	eq
 800f048:	68ec      	ldreq	r4, [r5, #12]
 800f04a:	e7ca      	b.n	800efe2 <__swbuf_r+0x1a>
 800f04c:	4621      	mov	r1, r4
 800f04e:	4628      	mov	r0, r5
 800f050:	f000 f80c 	bl	800f06c <__swsetup_r>
 800f054:	2800      	cmp	r0, #0
 800f056:	d0cb      	beq.n	800eff0 <__swbuf_r+0x28>
 800f058:	f04f 37ff 	mov.w	r7, #4294967295
 800f05c:	e7ea      	b.n	800f034 <__swbuf_r+0x6c>
 800f05e:	bf00      	nop
 800f060:	080113c0 	.word	0x080113c0
 800f064:	080113e0 	.word	0x080113e0
 800f068:	080113a0 	.word	0x080113a0

0800f06c <__swsetup_r>:
 800f06c:	4b32      	ldr	r3, [pc, #200]	; (800f138 <__swsetup_r+0xcc>)
 800f06e:	b570      	push	{r4, r5, r6, lr}
 800f070:	681d      	ldr	r5, [r3, #0]
 800f072:	4606      	mov	r6, r0
 800f074:	460c      	mov	r4, r1
 800f076:	b125      	cbz	r5, 800f082 <__swsetup_r+0x16>
 800f078:	69ab      	ldr	r3, [r5, #24]
 800f07a:	b913      	cbnz	r3, 800f082 <__swsetup_r+0x16>
 800f07c:	4628      	mov	r0, r5
 800f07e:	f000 f97d 	bl	800f37c <__sinit>
 800f082:	4b2e      	ldr	r3, [pc, #184]	; (800f13c <__swsetup_r+0xd0>)
 800f084:	429c      	cmp	r4, r3
 800f086:	d10f      	bne.n	800f0a8 <__swsetup_r+0x3c>
 800f088:	686c      	ldr	r4, [r5, #4]
 800f08a:	89a3      	ldrh	r3, [r4, #12]
 800f08c:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 800f090:	0719      	lsls	r1, r3, #28
 800f092:	d42c      	bmi.n	800f0ee <__swsetup_r+0x82>
 800f094:	06dd      	lsls	r5, r3, #27
 800f096:	d411      	bmi.n	800f0bc <__swsetup_r+0x50>
 800f098:	2309      	movs	r3, #9
 800f09a:	6033      	str	r3, [r6, #0]
 800f09c:	f042 0340 	orr.w	r3, r2, #64	; 0x40
 800f0a0:	81a3      	strh	r3, [r4, #12]
 800f0a2:	f04f 30ff 	mov.w	r0, #4294967295
 800f0a6:	e03e      	b.n	800f126 <__swsetup_r+0xba>
 800f0a8:	4b25      	ldr	r3, [pc, #148]	; (800f140 <__swsetup_r+0xd4>)
 800f0aa:	429c      	cmp	r4, r3
 800f0ac:	d101      	bne.n	800f0b2 <__swsetup_r+0x46>
 800f0ae:	68ac      	ldr	r4, [r5, #8]
 800f0b0:	e7eb      	b.n	800f08a <__swsetup_r+0x1e>
 800f0b2:	4b24      	ldr	r3, [pc, #144]	; (800f144 <__swsetup_r+0xd8>)
 800f0b4:	429c      	cmp	r4, r3
 800f0b6:	bf08      	it	eq
 800f0b8:	68ec      	ldreq	r4, [r5, #12]
 800f0ba:	e7e6      	b.n	800f08a <__swsetup_r+0x1e>
 800f0bc:	0758      	lsls	r0, r3, #29
 800f0be:	d512      	bpl.n	800f0e6 <__swsetup_r+0x7a>
 800f0c0:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800f0c2:	b141      	cbz	r1, 800f0d6 <__swsetup_r+0x6a>
 800f0c4:	f104 0344 	add.w	r3, r4, #68	; 0x44
 800f0c8:	4299      	cmp	r1, r3
 800f0ca:	d002      	beq.n	800f0d2 <__swsetup_r+0x66>
 800f0cc:	4630      	mov	r0, r6
 800f0ce:	f000 fa61 	bl	800f594 <_free_r>
 800f0d2:	2300      	movs	r3, #0
 800f0d4:	6363      	str	r3, [r4, #52]	; 0x34
 800f0d6:	89a3      	ldrh	r3, [r4, #12]
 800f0d8:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 800f0dc:	81a3      	strh	r3, [r4, #12]
 800f0de:	2300      	movs	r3, #0
 800f0e0:	6063      	str	r3, [r4, #4]
 800f0e2:	6923      	ldr	r3, [r4, #16]
 800f0e4:	6023      	str	r3, [r4, #0]
 800f0e6:	89a3      	ldrh	r3, [r4, #12]
 800f0e8:	f043 0308 	orr.w	r3, r3, #8
 800f0ec:	81a3      	strh	r3, [r4, #12]
 800f0ee:	6923      	ldr	r3, [r4, #16]
 800f0f0:	b94b      	cbnz	r3, 800f106 <__swsetup_r+0x9a>
 800f0f2:	89a3      	ldrh	r3, [r4, #12]
 800f0f4:	f403 7320 	and.w	r3, r3, #640	; 0x280
 800f0f8:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800f0fc:	d003      	beq.n	800f106 <__swsetup_r+0x9a>
 800f0fe:	4621      	mov	r1, r4
 800f100:	4630      	mov	r0, r6
 800f102:	f000 f9ff 	bl	800f504 <__smakebuf_r>
 800f106:	89a0      	ldrh	r0, [r4, #12]
 800f108:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 800f10c:	f010 0301 	ands.w	r3, r0, #1
 800f110:	d00a      	beq.n	800f128 <__swsetup_r+0xbc>
 800f112:	2300      	movs	r3, #0
 800f114:	60a3      	str	r3, [r4, #8]
 800f116:	6963      	ldr	r3, [r4, #20]
 800f118:	425b      	negs	r3, r3
 800f11a:	61a3      	str	r3, [r4, #24]
 800f11c:	6923      	ldr	r3, [r4, #16]
 800f11e:	b943      	cbnz	r3, 800f132 <__swsetup_r+0xc6>
 800f120:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 800f124:	d1ba      	bne.n	800f09c <__swsetup_r+0x30>
 800f126:	bd70      	pop	{r4, r5, r6, pc}
 800f128:	0781      	lsls	r1, r0, #30
 800f12a:	bf58      	it	pl
 800f12c:	6963      	ldrpl	r3, [r4, #20]
 800f12e:	60a3      	str	r3, [r4, #8]
 800f130:	e7f4      	b.n	800f11c <__swsetup_r+0xb0>
 800f132:	2000      	movs	r0, #0
 800f134:	e7f7      	b.n	800f126 <__swsetup_r+0xba>
 800f136:	bf00      	nop
 800f138:	20003418 	.word	0x20003418
 800f13c:	080113c0 	.word	0x080113c0
 800f140:	080113e0 	.word	0x080113e0
 800f144:	080113a0 	.word	0x080113a0

0800f148 <__sflush_r>:
 800f148:	898a      	ldrh	r2, [r1, #12]
 800f14a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800f14e:	4605      	mov	r5, r0
 800f150:	0710      	lsls	r0, r2, #28
 800f152:	460c      	mov	r4, r1
 800f154:	d458      	bmi.n	800f208 <__sflush_r+0xc0>
 800f156:	684b      	ldr	r3, [r1, #4]
 800f158:	2b00      	cmp	r3, #0
 800f15a:	dc05      	bgt.n	800f168 <__sflush_r+0x20>
 800f15c:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 800f15e:	2b00      	cmp	r3, #0
 800f160:	dc02      	bgt.n	800f168 <__sflush_r+0x20>
 800f162:	2000      	movs	r0, #0
 800f164:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800f168:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 800f16a:	2e00      	cmp	r6, #0
 800f16c:	d0f9      	beq.n	800f162 <__sflush_r+0x1a>
 800f16e:	2300      	movs	r3, #0
 800f170:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 800f174:	682f      	ldr	r7, [r5, #0]
 800f176:	602b      	str	r3, [r5, #0]
 800f178:	d032      	beq.n	800f1e0 <__sflush_r+0x98>
 800f17a:	6d60      	ldr	r0, [r4, #84]	; 0x54
 800f17c:	89a3      	ldrh	r3, [r4, #12]
 800f17e:	075a      	lsls	r2, r3, #29
 800f180:	d505      	bpl.n	800f18e <__sflush_r+0x46>
 800f182:	6863      	ldr	r3, [r4, #4]
 800f184:	1ac0      	subs	r0, r0, r3
 800f186:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800f188:	b10b      	cbz	r3, 800f18e <__sflush_r+0x46>
 800f18a:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800f18c:	1ac0      	subs	r0, r0, r3
 800f18e:	2300      	movs	r3, #0
 800f190:	4602      	mov	r2, r0
 800f192:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 800f194:	6a21      	ldr	r1, [r4, #32]
 800f196:	4628      	mov	r0, r5
 800f198:	47b0      	blx	r6
 800f19a:	1c43      	adds	r3, r0, #1
 800f19c:	89a3      	ldrh	r3, [r4, #12]
 800f19e:	d106      	bne.n	800f1ae <__sflush_r+0x66>
 800f1a0:	6829      	ldr	r1, [r5, #0]
 800f1a2:	291d      	cmp	r1, #29
 800f1a4:	d82c      	bhi.n	800f200 <__sflush_r+0xb8>
 800f1a6:	4a2a      	ldr	r2, [pc, #168]	; (800f250 <__sflush_r+0x108>)
 800f1a8:	40ca      	lsrs	r2, r1
 800f1aa:	07d6      	lsls	r6, r2, #31
 800f1ac:	d528      	bpl.n	800f200 <__sflush_r+0xb8>
 800f1ae:	2200      	movs	r2, #0
 800f1b0:	6062      	str	r2, [r4, #4]
 800f1b2:	04d9      	lsls	r1, r3, #19
 800f1b4:	6922      	ldr	r2, [r4, #16]
 800f1b6:	6022      	str	r2, [r4, #0]
 800f1b8:	d504      	bpl.n	800f1c4 <__sflush_r+0x7c>
 800f1ba:	1c42      	adds	r2, r0, #1
 800f1bc:	d101      	bne.n	800f1c2 <__sflush_r+0x7a>
 800f1be:	682b      	ldr	r3, [r5, #0]
 800f1c0:	b903      	cbnz	r3, 800f1c4 <__sflush_r+0x7c>
 800f1c2:	6560      	str	r0, [r4, #84]	; 0x54
 800f1c4:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800f1c6:	602f      	str	r7, [r5, #0]
 800f1c8:	2900      	cmp	r1, #0
 800f1ca:	d0ca      	beq.n	800f162 <__sflush_r+0x1a>
 800f1cc:	f104 0344 	add.w	r3, r4, #68	; 0x44
 800f1d0:	4299      	cmp	r1, r3
 800f1d2:	d002      	beq.n	800f1da <__sflush_r+0x92>
 800f1d4:	4628      	mov	r0, r5
 800f1d6:	f000 f9dd 	bl	800f594 <_free_r>
 800f1da:	2000      	movs	r0, #0
 800f1dc:	6360      	str	r0, [r4, #52]	; 0x34
 800f1de:	e7c1      	b.n	800f164 <__sflush_r+0x1c>
 800f1e0:	6a21      	ldr	r1, [r4, #32]
 800f1e2:	2301      	movs	r3, #1
 800f1e4:	4628      	mov	r0, r5
 800f1e6:	47b0      	blx	r6
 800f1e8:	1c41      	adds	r1, r0, #1
 800f1ea:	d1c7      	bne.n	800f17c <__sflush_r+0x34>
 800f1ec:	682b      	ldr	r3, [r5, #0]
 800f1ee:	2b00      	cmp	r3, #0
 800f1f0:	d0c4      	beq.n	800f17c <__sflush_r+0x34>
 800f1f2:	2b1d      	cmp	r3, #29
 800f1f4:	d001      	beq.n	800f1fa <__sflush_r+0xb2>
 800f1f6:	2b16      	cmp	r3, #22
 800f1f8:	d101      	bne.n	800f1fe <__sflush_r+0xb6>
 800f1fa:	602f      	str	r7, [r5, #0]
 800f1fc:	e7b1      	b.n	800f162 <__sflush_r+0x1a>
 800f1fe:	89a3      	ldrh	r3, [r4, #12]
 800f200:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800f204:	81a3      	strh	r3, [r4, #12]
 800f206:	e7ad      	b.n	800f164 <__sflush_r+0x1c>
 800f208:	690f      	ldr	r7, [r1, #16]
 800f20a:	2f00      	cmp	r7, #0
 800f20c:	d0a9      	beq.n	800f162 <__sflush_r+0x1a>
 800f20e:	0793      	lsls	r3, r2, #30
 800f210:	680e      	ldr	r6, [r1, #0]
 800f212:	bf08      	it	eq
 800f214:	694b      	ldreq	r3, [r1, #20]
 800f216:	600f      	str	r7, [r1, #0]
 800f218:	bf18      	it	ne
 800f21a:	2300      	movne	r3, #0
 800f21c:	eba6 0807 	sub.w	r8, r6, r7
 800f220:	608b      	str	r3, [r1, #8]
 800f222:	f1b8 0f00 	cmp.w	r8, #0
 800f226:	dd9c      	ble.n	800f162 <__sflush_r+0x1a>
 800f228:	6a21      	ldr	r1, [r4, #32]
 800f22a:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 800f22c:	4643      	mov	r3, r8
 800f22e:	463a      	mov	r2, r7
 800f230:	4628      	mov	r0, r5
 800f232:	47b0      	blx	r6
 800f234:	2800      	cmp	r0, #0
 800f236:	dc06      	bgt.n	800f246 <__sflush_r+0xfe>
 800f238:	89a3      	ldrh	r3, [r4, #12]
 800f23a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800f23e:	81a3      	strh	r3, [r4, #12]
 800f240:	f04f 30ff 	mov.w	r0, #4294967295
 800f244:	e78e      	b.n	800f164 <__sflush_r+0x1c>
 800f246:	4407      	add	r7, r0
 800f248:	eba8 0800 	sub.w	r8, r8, r0
 800f24c:	e7e9      	b.n	800f222 <__sflush_r+0xda>
 800f24e:	bf00      	nop
 800f250:	20400001 	.word	0x20400001

0800f254 <_fflush_r>:
 800f254:	b538      	push	{r3, r4, r5, lr}
 800f256:	690b      	ldr	r3, [r1, #16]
 800f258:	4605      	mov	r5, r0
 800f25a:	460c      	mov	r4, r1
 800f25c:	b913      	cbnz	r3, 800f264 <_fflush_r+0x10>
 800f25e:	2500      	movs	r5, #0
 800f260:	4628      	mov	r0, r5
 800f262:	bd38      	pop	{r3, r4, r5, pc}
 800f264:	b118      	cbz	r0, 800f26e <_fflush_r+0x1a>
 800f266:	6983      	ldr	r3, [r0, #24]
 800f268:	b90b      	cbnz	r3, 800f26e <_fflush_r+0x1a>
 800f26a:	f000 f887 	bl	800f37c <__sinit>
 800f26e:	4b14      	ldr	r3, [pc, #80]	; (800f2c0 <_fflush_r+0x6c>)
 800f270:	429c      	cmp	r4, r3
 800f272:	d11b      	bne.n	800f2ac <_fflush_r+0x58>
 800f274:	686c      	ldr	r4, [r5, #4]
 800f276:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800f27a:	2b00      	cmp	r3, #0
 800f27c:	d0ef      	beq.n	800f25e <_fflush_r+0xa>
 800f27e:	6e62      	ldr	r2, [r4, #100]	; 0x64
 800f280:	07d0      	lsls	r0, r2, #31
 800f282:	d404      	bmi.n	800f28e <_fflush_r+0x3a>
 800f284:	0599      	lsls	r1, r3, #22
 800f286:	d402      	bmi.n	800f28e <_fflush_r+0x3a>
 800f288:	6da0      	ldr	r0, [r4, #88]	; 0x58
 800f28a:	f000 f915 	bl	800f4b8 <__retarget_lock_acquire_recursive>
 800f28e:	4628      	mov	r0, r5
 800f290:	4621      	mov	r1, r4
 800f292:	f7ff ff59 	bl	800f148 <__sflush_r>
 800f296:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800f298:	07da      	lsls	r2, r3, #31
 800f29a:	4605      	mov	r5, r0
 800f29c:	d4e0      	bmi.n	800f260 <_fflush_r+0xc>
 800f29e:	89a3      	ldrh	r3, [r4, #12]
 800f2a0:	059b      	lsls	r3, r3, #22
 800f2a2:	d4dd      	bmi.n	800f260 <_fflush_r+0xc>
 800f2a4:	6da0      	ldr	r0, [r4, #88]	; 0x58
 800f2a6:	f000 f908 	bl	800f4ba <__retarget_lock_release_recursive>
 800f2aa:	e7d9      	b.n	800f260 <_fflush_r+0xc>
 800f2ac:	4b05      	ldr	r3, [pc, #20]	; (800f2c4 <_fflush_r+0x70>)
 800f2ae:	429c      	cmp	r4, r3
 800f2b0:	d101      	bne.n	800f2b6 <_fflush_r+0x62>
 800f2b2:	68ac      	ldr	r4, [r5, #8]
 800f2b4:	e7df      	b.n	800f276 <_fflush_r+0x22>
 800f2b6:	4b04      	ldr	r3, [pc, #16]	; (800f2c8 <_fflush_r+0x74>)
 800f2b8:	429c      	cmp	r4, r3
 800f2ba:	bf08      	it	eq
 800f2bc:	68ec      	ldreq	r4, [r5, #12]
 800f2be:	e7da      	b.n	800f276 <_fflush_r+0x22>
 800f2c0:	080113c0 	.word	0x080113c0
 800f2c4:	080113e0 	.word	0x080113e0
 800f2c8:	080113a0 	.word	0x080113a0

0800f2cc <std>:
 800f2cc:	2300      	movs	r3, #0
 800f2ce:	b510      	push	{r4, lr}
 800f2d0:	4604      	mov	r4, r0
 800f2d2:	e9c0 3300 	strd	r3, r3, [r0]
 800f2d6:	e9c0 3304 	strd	r3, r3, [r0, #16]
 800f2da:	6083      	str	r3, [r0, #8]
 800f2dc:	8181      	strh	r1, [r0, #12]
 800f2de:	6643      	str	r3, [r0, #100]	; 0x64
 800f2e0:	81c2      	strh	r2, [r0, #14]
 800f2e2:	6183      	str	r3, [r0, #24]
 800f2e4:	4619      	mov	r1, r3
 800f2e6:	2208      	movs	r2, #8
 800f2e8:	305c      	adds	r0, #92	; 0x5c
 800f2ea:	f7ff fcfd 	bl	800ece8 <memset>
 800f2ee:	4b05      	ldr	r3, [pc, #20]	; (800f304 <std+0x38>)
 800f2f0:	6263      	str	r3, [r4, #36]	; 0x24
 800f2f2:	4b05      	ldr	r3, [pc, #20]	; (800f308 <std+0x3c>)
 800f2f4:	62a3      	str	r3, [r4, #40]	; 0x28
 800f2f6:	4b05      	ldr	r3, [pc, #20]	; (800f30c <std+0x40>)
 800f2f8:	62e3      	str	r3, [r4, #44]	; 0x2c
 800f2fa:	4b05      	ldr	r3, [pc, #20]	; (800f310 <std+0x44>)
 800f2fc:	6224      	str	r4, [r4, #32]
 800f2fe:	6323      	str	r3, [r4, #48]	; 0x30
 800f300:	bd10      	pop	{r4, pc}
 800f302:	bf00      	nop
 800f304:	0800fd6d 	.word	0x0800fd6d
 800f308:	0800fd8f 	.word	0x0800fd8f
 800f30c:	0800fdc7 	.word	0x0800fdc7
 800f310:	0800fdeb 	.word	0x0800fdeb

0800f314 <_cleanup_r>:
 800f314:	4901      	ldr	r1, [pc, #4]	; (800f31c <_cleanup_r+0x8>)
 800f316:	f000 b8af 	b.w	800f478 <_fwalk_reent>
 800f31a:	bf00      	nop
 800f31c:	0800f255 	.word	0x0800f255

0800f320 <__sfmoreglue>:
 800f320:	b570      	push	{r4, r5, r6, lr}
 800f322:	1e4a      	subs	r2, r1, #1
 800f324:	2568      	movs	r5, #104	; 0x68
 800f326:	4355      	muls	r5, r2
 800f328:	460e      	mov	r6, r1
 800f32a:	f105 0174 	add.w	r1, r5, #116	; 0x74
 800f32e:	f000 f97f 	bl	800f630 <_malloc_r>
 800f332:	4604      	mov	r4, r0
 800f334:	b140      	cbz	r0, 800f348 <__sfmoreglue+0x28>
 800f336:	2100      	movs	r1, #0
 800f338:	e9c0 1600 	strd	r1, r6, [r0]
 800f33c:	300c      	adds	r0, #12
 800f33e:	60a0      	str	r0, [r4, #8]
 800f340:	f105 0268 	add.w	r2, r5, #104	; 0x68
 800f344:	f7ff fcd0 	bl	800ece8 <memset>
 800f348:	4620      	mov	r0, r4
 800f34a:	bd70      	pop	{r4, r5, r6, pc}

0800f34c <__sfp_lock_acquire>:
 800f34c:	4801      	ldr	r0, [pc, #4]	; (800f354 <__sfp_lock_acquire+0x8>)
 800f34e:	f000 b8b3 	b.w	800f4b8 <__retarget_lock_acquire_recursive>
 800f352:	bf00      	nop
 800f354:	20003f28 	.word	0x20003f28

0800f358 <__sfp_lock_release>:
 800f358:	4801      	ldr	r0, [pc, #4]	; (800f360 <__sfp_lock_release+0x8>)
 800f35a:	f000 b8ae 	b.w	800f4ba <__retarget_lock_release_recursive>
 800f35e:	bf00      	nop
 800f360:	20003f28 	.word	0x20003f28

0800f364 <__sinit_lock_acquire>:
 800f364:	4801      	ldr	r0, [pc, #4]	; (800f36c <__sinit_lock_acquire+0x8>)
 800f366:	f000 b8a7 	b.w	800f4b8 <__retarget_lock_acquire_recursive>
 800f36a:	bf00      	nop
 800f36c:	20003f23 	.word	0x20003f23

0800f370 <__sinit_lock_release>:
 800f370:	4801      	ldr	r0, [pc, #4]	; (800f378 <__sinit_lock_release+0x8>)
 800f372:	f000 b8a2 	b.w	800f4ba <__retarget_lock_release_recursive>
 800f376:	bf00      	nop
 800f378:	20003f23 	.word	0x20003f23

0800f37c <__sinit>:
 800f37c:	b510      	push	{r4, lr}
 800f37e:	4604      	mov	r4, r0
 800f380:	f7ff fff0 	bl	800f364 <__sinit_lock_acquire>
 800f384:	69a3      	ldr	r3, [r4, #24]
 800f386:	b11b      	cbz	r3, 800f390 <__sinit+0x14>
 800f388:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800f38c:	f7ff bff0 	b.w	800f370 <__sinit_lock_release>
 800f390:	e9c4 3312 	strd	r3, r3, [r4, #72]	; 0x48
 800f394:	6523      	str	r3, [r4, #80]	; 0x50
 800f396:	4b13      	ldr	r3, [pc, #76]	; (800f3e4 <__sinit+0x68>)
 800f398:	4a13      	ldr	r2, [pc, #76]	; (800f3e8 <__sinit+0x6c>)
 800f39a:	681b      	ldr	r3, [r3, #0]
 800f39c:	62a2      	str	r2, [r4, #40]	; 0x28
 800f39e:	42a3      	cmp	r3, r4
 800f3a0:	bf04      	itt	eq
 800f3a2:	2301      	moveq	r3, #1
 800f3a4:	61a3      	streq	r3, [r4, #24]
 800f3a6:	4620      	mov	r0, r4
 800f3a8:	f000 f820 	bl	800f3ec <__sfp>
 800f3ac:	6060      	str	r0, [r4, #4]
 800f3ae:	4620      	mov	r0, r4
 800f3b0:	f000 f81c 	bl	800f3ec <__sfp>
 800f3b4:	60a0      	str	r0, [r4, #8]
 800f3b6:	4620      	mov	r0, r4
 800f3b8:	f000 f818 	bl	800f3ec <__sfp>
 800f3bc:	2200      	movs	r2, #0
 800f3be:	60e0      	str	r0, [r4, #12]
 800f3c0:	2104      	movs	r1, #4
 800f3c2:	6860      	ldr	r0, [r4, #4]
 800f3c4:	f7ff ff82 	bl	800f2cc <std>
 800f3c8:	68a0      	ldr	r0, [r4, #8]
 800f3ca:	2201      	movs	r2, #1
 800f3cc:	2109      	movs	r1, #9
 800f3ce:	f7ff ff7d 	bl	800f2cc <std>
 800f3d2:	68e0      	ldr	r0, [r4, #12]
 800f3d4:	2202      	movs	r2, #2
 800f3d6:	2112      	movs	r1, #18
 800f3d8:	f7ff ff78 	bl	800f2cc <std>
 800f3dc:	2301      	movs	r3, #1
 800f3de:	61a3      	str	r3, [r4, #24]
 800f3e0:	e7d2      	b.n	800f388 <__sinit+0xc>
 800f3e2:	bf00      	nop
 800f3e4:	0801139c 	.word	0x0801139c
 800f3e8:	0800f315 	.word	0x0800f315

0800f3ec <__sfp>:
 800f3ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800f3ee:	4607      	mov	r7, r0
 800f3f0:	f7ff ffac 	bl	800f34c <__sfp_lock_acquire>
 800f3f4:	4b1e      	ldr	r3, [pc, #120]	; (800f470 <__sfp+0x84>)
 800f3f6:	681e      	ldr	r6, [r3, #0]
 800f3f8:	69b3      	ldr	r3, [r6, #24]
 800f3fa:	b913      	cbnz	r3, 800f402 <__sfp+0x16>
 800f3fc:	4630      	mov	r0, r6
 800f3fe:	f7ff ffbd 	bl	800f37c <__sinit>
 800f402:	3648      	adds	r6, #72	; 0x48
 800f404:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
 800f408:	3b01      	subs	r3, #1
 800f40a:	d503      	bpl.n	800f414 <__sfp+0x28>
 800f40c:	6833      	ldr	r3, [r6, #0]
 800f40e:	b30b      	cbz	r3, 800f454 <__sfp+0x68>
 800f410:	6836      	ldr	r6, [r6, #0]
 800f412:	e7f7      	b.n	800f404 <__sfp+0x18>
 800f414:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
 800f418:	b9d5      	cbnz	r5, 800f450 <__sfp+0x64>
 800f41a:	4b16      	ldr	r3, [pc, #88]	; (800f474 <__sfp+0x88>)
 800f41c:	60e3      	str	r3, [r4, #12]
 800f41e:	f104 0058 	add.w	r0, r4, #88	; 0x58
 800f422:	6665      	str	r5, [r4, #100]	; 0x64
 800f424:	f000 f847 	bl	800f4b6 <__retarget_lock_init_recursive>
 800f428:	f7ff ff96 	bl	800f358 <__sfp_lock_release>
 800f42c:	e9c4 5501 	strd	r5, r5, [r4, #4]
 800f430:	e9c4 5504 	strd	r5, r5, [r4, #16]
 800f434:	6025      	str	r5, [r4, #0]
 800f436:	61a5      	str	r5, [r4, #24]
 800f438:	2208      	movs	r2, #8
 800f43a:	4629      	mov	r1, r5
 800f43c:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 800f440:	f7ff fc52 	bl	800ece8 <memset>
 800f444:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
 800f448:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
 800f44c:	4620      	mov	r0, r4
 800f44e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800f450:	3468      	adds	r4, #104	; 0x68
 800f452:	e7d9      	b.n	800f408 <__sfp+0x1c>
 800f454:	2104      	movs	r1, #4
 800f456:	4638      	mov	r0, r7
 800f458:	f7ff ff62 	bl	800f320 <__sfmoreglue>
 800f45c:	4604      	mov	r4, r0
 800f45e:	6030      	str	r0, [r6, #0]
 800f460:	2800      	cmp	r0, #0
 800f462:	d1d5      	bne.n	800f410 <__sfp+0x24>
 800f464:	f7ff ff78 	bl	800f358 <__sfp_lock_release>
 800f468:	230c      	movs	r3, #12
 800f46a:	603b      	str	r3, [r7, #0]
 800f46c:	e7ee      	b.n	800f44c <__sfp+0x60>
 800f46e:	bf00      	nop
 800f470:	0801139c 	.word	0x0801139c
 800f474:	ffff0001 	.word	0xffff0001

0800f478 <_fwalk_reent>:
 800f478:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800f47c:	4606      	mov	r6, r0
 800f47e:	4688      	mov	r8, r1
 800f480:	f100 0448 	add.w	r4, r0, #72	; 0x48
 800f484:	2700      	movs	r7, #0
 800f486:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 800f48a:	f1b9 0901 	subs.w	r9, r9, #1
 800f48e:	d505      	bpl.n	800f49c <_fwalk_reent+0x24>
 800f490:	6824      	ldr	r4, [r4, #0]
 800f492:	2c00      	cmp	r4, #0
 800f494:	d1f7      	bne.n	800f486 <_fwalk_reent+0xe>
 800f496:	4638      	mov	r0, r7
 800f498:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800f49c:	89ab      	ldrh	r3, [r5, #12]
 800f49e:	2b01      	cmp	r3, #1
 800f4a0:	d907      	bls.n	800f4b2 <_fwalk_reent+0x3a>
 800f4a2:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 800f4a6:	3301      	adds	r3, #1
 800f4a8:	d003      	beq.n	800f4b2 <_fwalk_reent+0x3a>
 800f4aa:	4629      	mov	r1, r5
 800f4ac:	4630      	mov	r0, r6
 800f4ae:	47c0      	blx	r8
 800f4b0:	4307      	orrs	r7, r0
 800f4b2:	3568      	adds	r5, #104	; 0x68
 800f4b4:	e7e9      	b.n	800f48a <_fwalk_reent+0x12>

0800f4b6 <__retarget_lock_init_recursive>:
 800f4b6:	4770      	bx	lr

0800f4b8 <__retarget_lock_acquire_recursive>:
 800f4b8:	4770      	bx	lr

0800f4ba <__retarget_lock_release_recursive>:
 800f4ba:	4770      	bx	lr

0800f4bc <__swhatbuf_r>:
 800f4bc:	b570      	push	{r4, r5, r6, lr}
 800f4be:	460e      	mov	r6, r1
 800f4c0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800f4c4:	2900      	cmp	r1, #0
 800f4c6:	b096      	sub	sp, #88	; 0x58
 800f4c8:	4614      	mov	r4, r2
 800f4ca:	461d      	mov	r5, r3
 800f4cc:	da07      	bge.n	800f4de <__swhatbuf_r+0x22>
 800f4ce:	2300      	movs	r3, #0
 800f4d0:	602b      	str	r3, [r5, #0]
 800f4d2:	89b3      	ldrh	r3, [r6, #12]
 800f4d4:	061a      	lsls	r2, r3, #24
 800f4d6:	d410      	bmi.n	800f4fa <__swhatbuf_r+0x3e>
 800f4d8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800f4dc:	e00e      	b.n	800f4fc <__swhatbuf_r+0x40>
 800f4de:	466a      	mov	r2, sp
 800f4e0:	f000 fcaa 	bl	800fe38 <_fstat_r>
 800f4e4:	2800      	cmp	r0, #0
 800f4e6:	dbf2      	blt.n	800f4ce <__swhatbuf_r+0x12>
 800f4e8:	9a01      	ldr	r2, [sp, #4]
 800f4ea:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 800f4ee:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
 800f4f2:	425a      	negs	r2, r3
 800f4f4:	415a      	adcs	r2, r3
 800f4f6:	602a      	str	r2, [r5, #0]
 800f4f8:	e7ee      	b.n	800f4d8 <__swhatbuf_r+0x1c>
 800f4fa:	2340      	movs	r3, #64	; 0x40
 800f4fc:	2000      	movs	r0, #0
 800f4fe:	6023      	str	r3, [r4, #0]
 800f500:	b016      	add	sp, #88	; 0x58
 800f502:	bd70      	pop	{r4, r5, r6, pc}

0800f504 <__smakebuf_r>:
 800f504:	898b      	ldrh	r3, [r1, #12]
 800f506:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800f508:	079d      	lsls	r5, r3, #30
 800f50a:	4606      	mov	r6, r0
 800f50c:	460c      	mov	r4, r1
 800f50e:	d507      	bpl.n	800f520 <__smakebuf_r+0x1c>
 800f510:	f104 0347 	add.w	r3, r4, #71	; 0x47
 800f514:	6023      	str	r3, [r4, #0]
 800f516:	6123      	str	r3, [r4, #16]
 800f518:	2301      	movs	r3, #1
 800f51a:	6163      	str	r3, [r4, #20]
 800f51c:	b002      	add	sp, #8
 800f51e:	bd70      	pop	{r4, r5, r6, pc}
 800f520:	ab01      	add	r3, sp, #4
 800f522:	466a      	mov	r2, sp
 800f524:	f7ff ffca 	bl	800f4bc <__swhatbuf_r>
 800f528:	9900      	ldr	r1, [sp, #0]
 800f52a:	4605      	mov	r5, r0
 800f52c:	4630      	mov	r0, r6
 800f52e:	f000 f87f 	bl	800f630 <_malloc_r>
 800f532:	b948      	cbnz	r0, 800f548 <__smakebuf_r+0x44>
 800f534:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800f538:	059a      	lsls	r2, r3, #22
 800f53a:	d4ef      	bmi.n	800f51c <__smakebuf_r+0x18>
 800f53c:	f023 0303 	bic.w	r3, r3, #3
 800f540:	f043 0302 	orr.w	r3, r3, #2
 800f544:	81a3      	strh	r3, [r4, #12]
 800f546:	e7e3      	b.n	800f510 <__smakebuf_r+0xc>
 800f548:	4b0d      	ldr	r3, [pc, #52]	; (800f580 <__smakebuf_r+0x7c>)
 800f54a:	62b3      	str	r3, [r6, #40]	; 0x28
 800f54c:	89a3      	ldrh	r3, [r4, #12]
 800f54e:	6020      	str	r0, [r4, #0]
 800f550:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800f554:	81a3      	strh	r3, [r4, #12]
 800f556:	9b00      	ldr	r3, [sp, #0]
 800f558:	6163      	str	r3, [r4, #20]
 800f55a:	9b01      	ldr	r3, [sp, #4]
 800f55c:	6120      	str	r0, [r4, #16]
 800f55e:	b15b      	cbz	r3, 800f578 <__smakebuf_r+0x74>
 800f560:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 800f564:	4630      	mov	r0, r6
 800f566:	f000 fc79 	bl	800fe5c <_isatty_r>
 800f56a:	b128      	cbz	r0, 800f578 <__smakebuf_r+0x74>
 800f56c:	89a3      	ldrh	r3, [r4, #12]
 800f56e:	f023 0303 	bic.w	r3, r3, #3
 800f572:	f043 0301 	orr.w	r3, r3, #1
 800f576:	81a3      	strh	r3, [r4, #12]
 800f578:	89a0      	ldrh	r0, [r4, #12]
 800f57a:	4305      	orrs	r5, r0
 800f57c:	81a5      	strh	r5, [r4, #12]
 800f57e:	e7cd      	b.n	800f51c <__smakebuf_r+0x18>
 800f580:	0800f315 	.word	0x0800f315

0800f584 <malloc>:
 800f584:	4b02      	ldr	r3, [pc, #8]	; (800f590 <malloc+0xc>)
 800f586:	4601      	mov	r1, r0
 800f588:	6818      	ldr	r0, [r3, #0]
 800f58a:	f000 b851 	b.w	800f630 <_malloc_r>
 800f58e:	bf00      	nop
 800f590:	20003418 	.word	0x20003418

0800f594 <_free_r>:
 800f594:	b538      	push	{r3, r4, r5, lr}
 800f596:	4605      	mov	r5, r0
 800f598:	2900      	cmp	r1, #0
 800f59a:	d045      	beq.n	800f628 <_free_r+0x94>
 800f59c:	f851 3c04 	ldr.w	r3, [r1, #-4]
 800f5a0:	1f0c      	subs	r4, r1, #4
 800f5a2:	2b00      	cmp	r3, #0
 800f5a4:	bfb8      	it	lt
 800f5a6:	18e4      	addlt	r4, r4, r3
 800f5a8:	f000 fc7a 	bl	800fea0 <__malloc_lock>
 800f5ac:	4a1f      	ldr	r2, [pc, #124]	; (800f62c <_free_r+0x98>)
 800f5ae:	6813      	ldr	r3, [r2, #0]
 800f5b0:	4610      	mov	r0, r2
 800f5b2:	b933      	cbnz	r3, 800f5c2 <_free_r+0x2e>
 800f5b4:	6063      	str	r3, [r4, #4]
 800f5b6:	6014      	str	r4, [r2, #0]
 800f5b8:	4628      	mov	r0, r5
 800f5ba:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 800f5be:	f000 bc75 	b.w	800feac <__malloc_unlock>
 800f5c2:	42a3      	cmp	r3, r4
 800f5c4:	d90b      	bls.n	800f5de <_free_r+0x4a>
 800f5c6:	6821      	ldr	r1, [r4, #0]
 800f5c8:	1862      	adds	r2, r4, r1
 800f5ca:	4293      	cmp	r3, r2
 800f5cc:	bf04      	itt	eq
 800f5ce:	681a      	ldreq	r2, [r3, #0]
 800f5d0:	685b      	ldreq	r3, [r3, #4]
 800f5d2:	6063      	str	r3, [r4, #4]
 800f5d4:	bf04      	itt	eq
 800f5d6:	1852      	addeq	r2, r2, r1
 800f5d8:	6022      	streq	r2, [r4, #0]
 800f5da:	6004      	str	r4, [r0, #0]
 800f5dc:	e7ec      	b.n	800f5b8 <_free_r+0x24>
 800f5de:	461a      	mov	r2, r3
 800f5e0:	685b      	ldr	r3, [r3, #4]
 800f5e2:	b10b      	cbz	r3, 800f5e8 <_free_r+0x54>
 800f5e4:	42a3      	cmp	r3, r4
 800f5e6:	d9fa      	bls.n	800f5de <_free_r+0x4a>
 800f5e8:	6811      	ldr	r1, [r2, #0]
 800f5ea:	1850      	adds	r0, r2, r1
 800f5ec:	42a0      	cmp	r0, r4
 800f5ee:	d10b      	bne.n	800f608 <_free_r+0x74>
 800f5f0:	6820      	ldr	r0, [r4, #0]
 800f5f2:	4401      	add	r1, r0
 800f5f4:	1850      	adds	r0, r2, r1
 800f5f6:	4283      	cmp	r3, r0
 800f5f8:	6011      	str	r1, [r2, #0]
 800f5fa:	d1dd      	bne.n	800f5b8 <_free_r+0x24>
 800f5fc:	6818      	ldr	r0, [r3, #0]
 800f5fe:	685b      	ldr	r3, [r3, #4]
 800f600:	6053      	str	r3, [r2, #4]
 800f602:	4401      	add	r1, r0
 800f604:	6011      	str	r1, [r2, #0]
 800f606:	e7d7      	b.n	800f5b8 <_free_r+0x24>
 800f608:	d902      	bls.n	800f610 <_free_r+0x7c>
 800f60a:	230c      	movs	r3, #12
 800f60c:	602b      	str	r3, [r5, #0]
 800f60e:	e7d3      	b.n	800f5b8 <_free_r+0x24>
 800f610:	6820      	ldr	r0, [r4, #0]
 800f612:	1821      	adds	r1, r4, r0
 800f614:	428b      	cmp	r3, r1
 800f616:	bf04      	itt	eq
 800f618:	6819      	ldreq	r1, [r3, #0]
 800f61a:	685b      	ldreq	r3, [r3, #4]
 800f61c:	6063      	str	r3, [r4, #4]
 800f61e:	bf04      	itt	eq
 800f620:	1809      	addeq	r1, r1, r0
 800f622:	6021      	streq	r1, [r4, #0]
 800f624:	6054      	str	r4, [r2, #4]
 800f626:	e7c7      	b.n	800f5b8 <_free_r+0x24>
 800f628:	bd38      	pop	{r3, r4, r5, pc}
 800f62a:	bf00      	nop
 800f62c:	20003c60 	.word	0x20003c60

0800f630 <_malloc_r>:
 800f630:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800f632:	1ccd      	adds	r5, r1, #3
 800f634:	f025 0503 	bic.w	r5, r5, #3
 800f638:	3508      	adds	r5, #8
 800f63a:	2d0c      	cmp	r5, #12
 800f63c:	bf38      	it	cc
 800f63e:	250c      	movcc	r5, #12
 800f640:	2d00      	cmp	r5, #0
 800f642:	4606      	mov	r6, r0
 800f644:	db01      	blt.n	800f64a <_malloc_r+0x1a>
 800f646:	42a9      	cmp	r1, r5
 800f648:	d903      	bls.n	800f652 <_malloc_r+0x22>
 800f64a:	230c      	movs	r3, #12
 800f64c:	6033      	str	r3, [r6, #0]
 800f64e:	2000      	movs	r0, #0
 800f650:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800f652:	f000 fc25 	bl	800fea0 <__malloc_lock>
 800f656:	4921      	ldr	r1, [pc, #132]	; (800f6dc <_malloc_r+0xac>)
 800f658:	680a      	ldr	r2, [r1, #0]
 800f65a:	4614      	mov	r4, r2
 800f65c:	b99c      	cbnz	r4, 800f686 <_malloc_r+0x56>
 800f65e:	4f20      	ldr	r7, [pc, #128]	; (800f6e0 <_malloc_r+0xb0>)
 800f660:	683b      	ldr	r3, [r7, #0]
 800f662:	b923      	cbnz	r3, 800f66e <_malloc_r+0x3e>
 800f664:	4621      	mov	r1, r4
 800f666:	4630      	mov	r0, r6
 800f668:	f000 fb70 	bl	800fd4c <_sbrk_r>
 800f66c:	6038      	str	r0, [r7, #0]
 800f66e:	4629      	mov	r1, r5
 800f670:	4630      	mov	r0, r6
 800f672:	f000 fb6b 	bl	800fd4c <_sbrk_r>
 800f676:	1c43      	adds	r3, r0, #1
 800f678:	d123      	bne.n	800f6c2 <_malloc_r+0x92>
 800f67a:	230c      	movs	r3, #12
 800f67c:	6033      	str	r3, [r6, #0]
 800f67e:	4630      	mov	r0, r6
 800f680:	f000 fc14 	bl	800feac <__malloc_unlock>
 800f684:	e7e3      	b.n	800f64e <_malloc_r+0x1e>
 800f686:	6823      	ldr	r3, [r4, #0]
 800f688:	1b5b      	subs	r3, r3, r5
 800f68a:	d417      	bmi.n	800f6bc <_malloc_r+0x8c>
 800f68c:	2b0b      	cmp	r3, #11
 800f68e:	d903      	bls.n	800f698 <_malloc_r+0x68>
 800f690:	6023      	str	r3, [r4, #0]
 800f692:	441c      	add	r4, r3
 800f694:	6025      	str	r5, [r4, #0]
 800f696:	e004      	b.n	800f6a2 <_malloc_r+0x72>
 800f698:	6863      	ldr	r3, [r4, #4]
 800f69a:	42a2      	cmp	r2, r4
 800f69c:	bf0c      	ite	eq
 800f69e:	600b      	streq	r3, [r1, #0]
 800f6a0:	6053      	strne	r3, [r2, #4]
 800f6a2:	4630      	mov	r0, r6
 800f6a4:	f000 fc02 	bl	800feac <__malloc_unlock>
 800f6a8:	f104 000b 	add.w	r0, r4, #11
 800f6ac:	1d23      	adds	r3, r4, #4
 800f6ae:	f020 0007 	bic.w	r0, r0, #7
 800f6b2:	1ac2      	subs	r2, r0, r3
 800f6b4:	d0cc      	beq.n	800f650 <_malloc_r+0x20>
 800f6b6:	1a1b      	subs	r3, r3, r0
 800f6b8:	50a3      	str	r3, [r4, r2]
 800f6ba:	e7c9      	b.n	800f650 <_malloc_r+0x20>
 800f6bc:	4622      	mov	r2, r4
 800f6be:	6864      	ldr	r4, [r4, #4]
 800f6c0:	e7cc      	b.n	800f65c <_malloc_r+0x2c>
 800f6c2:	1cc4      	adds	r4, r0, #3
 800f6c4:	f024 0403 	bic.w	r4, r4, #3
 800f6c8:	42a0      	cmp	r0, r4
 800f6ca:	d0e3      	beq.n	800f694 <_malloc_r+0x64>
 800f6cc:	1a21      	subs	r1, r4, r0
 800f6ce:	4630      	mov	r0, r6
 800f6d0:	f000 fb3c 	bl	800fd4c <_sbrk_r>
 800f6d4:	3001      	adds	r0, #1
 800f6d6:	d1dd      	bne.n	800f694 <_malloc_r+0x64>
 800f6d8:	e7cf      	b.n	800f67a <_malloc_r+0x4a>
 800f6da:	bf00      	nop
 800f6dc:	20003c60 	.word	0x20003c60
 800f6e0:	20003c64 	.word	0x20003c64

0800f6e4 <__sfputc_r>:
 800f6e4:	6893      	ldr	r3, [r2, #8]
 800f6e6:	3b01      	subs	r3, #1
 800f6e8:	2b00      	cmp	r3, #0
 800f6ea:	b410      	push	{r4}
 800f6ec:	6093      	str	r3, [r2, #8]
 800f6ee:	da07      	bge.n	800f700 <__sfputc_r+0x1c>
 800f6f0:	6994      	ldr	r4, [r2, #24]
 800f6f2:	42a3      	cmp	r3, r4
 800f6f4:	db01      	blt.n	800f6fa <__sfputc_r+0x16>
 800f6f6:	290a      	cmp	r1, #10
 800f6f8:	d102      	bne.n	800f700 <__sfputc_r+0x1c>
 800f6fa:	bc10      	pop	{r4}
 800f6fc:	f7ff bc64 	b.w	800efc8 <__swbuf_r>
 800f700:	6813      	ldr	r3, [r2, #0]
 800f702:	1c58      	adds	r0, r3, #1
 800f704:	6010      	str	r0, [r2, #0]
 800f706:	7019      	strb	r1, [r3, #0]
 800f708:	4608      	mov	r0, r1
 800f70a:	bc10      	pop	{r4}
 800f70c:	4770      	bx	lr

0800f70e <__sfputs_r>:
 800f70e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800f710:	4606      	mov	r6, r0
 800f712:	460f      	mov	r7, r1
 800f714:	4614      	mov	r4, r2
 800f716:	18d5      	adds	r5, r2, r3
 800f718:	42ac      	cmp	r4, r5
 800f71a:	d101      	bne.n	800f720 <__sfputs_r+0x12>
 800f71c:	2000      	movs	r0, #0
 800f71e:	e007      	b.n	800f730 <__sfputs_r+0x22>
 800f720:	f814 1b01 	ldrb.w	r1, [r4], #1
 800f724:	463a      	mov	r2, r7
 800f726:	4630      	mov	r0, r6
 800f728:	f7ff ffdc 	bl	800f6e4 <__sfputc_r>
 800f72c:	1c43      	adds	r3, r0, #1
 800f72e:	d1f3      	bne.n	800f718 <__sfputs_r+0xa>
 800f730:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0800f734 <_vfiprintf_r>:
 800f734:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800f738:	460d      	mov	r5, r1
 800f73a:	b09d      	sub	sp, #116	; 0x74
 800f73c:	4614      	mov	r4, r2
 800f73e:	4698      	mov	r8, r3
 800f740:	4606      	mov	r6, r0
 800f742:	b118      	cbz	r0, 800f74c <_vfiprintf_r+0x18>
 800f744:	6983      	ldr	r3, [r0, #24]
 800f746:	b90b      	cbnz	r3, 800f74c <_vfiprintf_r+0x18>
 800f748:	f7ff fe18 	bl	800f37c <__sinit>
 800f74c:	4b89      	ldr	r3, [pc, #548]	; (800f974 <_vfiprintf_r+0x240>)
 800f74e:	429d      	cmp	r5, r3
 800f750:	d11b      	bne.n	800f78a <_vfiprintf_r+0x56>
 800f752:	6875      	ldr	r5, [r6, #4]
 800f754:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 800f756:	07d9      	lsls	r1, r3, #31
 800f758:	d405      	bmi.n	800f766 <_vfiprintf_r+0x32>
 800f75a:	89ab      	ldrh	r3, [r5, #12]
 800f75c:	059a      	lsls	r2, r3, #22
 800f75e:	d402      	bmi.n	800f766 <_vfiprintf_r+0x32>
 800f760:	6da8      	ldr	r0, [r5, #88]	; 0x58
 800f762:	f7ff fea9 	bl	800f4b8 <__retarget_lock_acquire_recursive>
 800f766:	89ab      	ldrh	r3, [r5, #12]
 800f768:	071b      	lsls	r3, r3, #28
 800f76a:	d501      	bpl.n	800f770 <_vfiprintf_r+0x3c>
 800f76c:	692b      	ldr	r3, [r5, #16]
 800f76e:	b9eb      	cbnz	r3, 800f7ac <_vfiprintf_r+0x78>
 800f770:	4629      	mov	r1, r5
 800f772:	4630      	mov	r0, r6
 800f774:	f7ff fc7a 	bl	800f06c <__swsetup_r>
 800f778:	b1c0      	cbz	r0, 800f7ac <_vfiprintf_r+0x78>
 800f77a:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 800f77c:	07dc      	lsls	r4, r3, #31
 800f77e:	d50e      	bpl.n	800f79e <_vfiprintf_r+0x6a>
 800f780:	f04f 30ff 	mov.w	r0, #4294967295
 800f784:	b01d      	add	sp, #116	; 0x74
 800f786:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800f78a:	4b7b      	ldr	r3, [pc, #492]	; (800f978 <_vfiprintf_r+0x244>)
 800f78c:	429d      	cmp	r5, r3
 800f78e:	d101      	bne.n	800f794 <_vfiprintf_r+0x60>
 800f790:	68b5      	ldr	r5, [r6, #8]
 800f792:	e7df      	b.n	800f754 <_vfiprintf_r+0x20>
 800f794:	4b79      	ldr	r3, [pc, #484]	; (800f97c <_vfiprintf_r+0x248>)
 800f796:	429d      	cmp	r5, r3
 800f798:	bf08      	it	eq
 800f79a:	68f5      	ldreq	r5, [r6, #12]
 800f79c:	e7da      	b.n	800f754 <_vfiprintf_r+0x20>
 800f79e:	89ab      	ldrh	r3, [r5, #12]
 800f7a0:	0598      	lsls	r0, r3, #22
 800f7a2:	d4ed      	bmi.n	800f780 <_vfiprintf_r+0x4c>
 800f7a4:	6da8      	ldr	r0, [r5, #88]	; 0x58
 800f7a6:	f7ff fe88 	bl	800f4ba <__retarget_lock_release_recursive>
 800f7aa:	e7e9      	b.n	800f780 <_vfiprintf_r+0x4c>
 800f7ac:	2300      	movs	r3, #0
 800f7ae:	9309      	str	r3, [sp, #36]	; 0x24
 800f7b0:	2320      	movs	r3, #32
 800f7b2:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 800f7b6:	f8cd 800c 	str.w	r8, [sp, #12]
 800f7ba:	2330      	movs	r3, #48	; 0x30
 800f7bc:	f8df 81c0 	ldr.w	r8, [pc, #448]	; 800f980 <_vfiprintf_r+0x24c>
 800f7c0:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 800f7c4:	f04f 0901 	mov.w	r9, #1
 800f7c8:	4623      	mov	r3, r4
 800f7ca:	469a      	mov	sl, r3
 800f7cc:	f813 2b01 	ldrb.w	r2, [r3], #1
 800f7d0:	b10a      	cbz	r2, 800f7d6 <_vfiprintf_r+0xa2>
 800f7d2:	2a25      	cmp	r2, #37	; 0x25
 800f7d4:	d1f9      	bne.n	800f7ca <_vfiprintf_r+0x96>
 800f7d6:	ebba 0b04 	subs.w	fp, sl, r4
 800f7da:	d00b      	beq.n	800f7f4 <_vfiprintf_r+0xc0>
 800f7dc:	465b      	mov	r3, fp
 800f7de:	4622      	mov	r2, r4
 800f7e0:	4629      	mov	r1, r5
 800f7e2:	4630      	mov	r0, r6
 800f7e4:	f7ff ff93 	bl	800f70e <__sfputs_r>
 800f7e8:	3001      	adds	r0, #1
 800f7ea:	f000 80aa 	beq.w	800f942 <_vfiprintf_r+0x20e>
 800f7ee:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800f7f0:	445a      	add	r2, fp
 800f7f2:	9209      	str	r2, [sp, #36]	; 0x24
 800f7f4:	f89a 3000 	ldrb.w	r3, [sl]
 800f7f8:	2b00      	cmp	r3, #0
 800f7fa:	f000 80a2 	beq.w	800f942 <_vfiprintf_r+0x20e>
 800f7fe:	2300      	movs	r3, #0
 800f800:	f04f 32ff 	mov.w	r2, #4294967295
 800f804:	e9cd 2305 	strd	r2, r3, [sp, #20]
 800f808:	f10a 0a01 	add.w	sl, sl, #1
 800f80c:	9304      	str	r3, [sp, #16]
 800f80e:	9307      	str	r3, [sp, #28]
 800f810:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 800f814:	931a      	str	r3, [sp, #104]	; 0x68
 800f816:	4654      	mov	r4, sl
 800f818:	2205      	movs	r2, #5
 800f81a:	f814 1b01 	ldrb.w	r1, [r4], #1
 800f81e:	4858      	ldr	r0, [pc, #352]	; (800f980 <_vfiprintf_r+0x24c>)
 800f820:	f7f9 ff0e 	bl	8009640 <memchr>
 800f824:	9a04      	ldr	r2, [sp, #16]
 800f826:	b9d8      	cbnz	r0, 800f860 <_vfiprintf_r+0x12c>
 800f828:	06d1      	lsls	r1, r2, #27
 800f82a:	bf44      	itt	mi
 800f82c:	2320      	movmi	r3, #32
 800f82e:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 800f832:	0713      	lsls	r3, r2, #28
 800f834:	bf44      	itt	mi
 800f836:	232b      	movmi	r3, #43	; 0x2b
 800f838:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 800f83c:	f89a 3000 	ldrb.w	r3, [sl]
 800f840:	2b2a      	cmp	r3, #42	; 0x2a
 800f842:	d015      	beq.n	800f870 <_vfiprintf_r+0x13c>
 800f844:	9a07      	ldr	r2, [sp, #28]
 800f846:	4654      	mov	r4, sl
 800f848:	2000      	movs	r0, #0
 800f84a:	f04f 0c0a 	mov.w	ip, #10
 800f84e:	4621      	mov	r1, r4
 800f850:	f811 3b01 	ldrb.w	r3, [r1], #1
 800f854:	3b30      	subs	r3, #48	; 0x30
 800f856:	2b09      	cmp	r3, #9
 800f858:	d94e      	bls.n	800f8f8 <_vfiprintf_r+0x1c4>
 800f85a:	b1b0      	cbz	r0, 800f88a <_vfiprintf_r+0x156>
 800f85c:	9207      	str	r2, [sp, #28]
 800f85e:	e014      	b.n	800f88a <_vfiprintf_r+0x156>
 800f860:	eba0 0308 	sub.w	r3, r0, r8
 800f864:	fa09 f303 	lsl.w	r3, r9, r3
 800f868:	4313      	orrs	r3, r2
 800f86a:	9304      	str	r3, [sp, #16]
 800f86c:	46a2      	mov	sl, r4
 800f86e:	e7d2      	b.n	800f816 <_vfiprintf_r+0xe2>
 800f870:	9b03      	ldr	r3, [sp, #12]
 800f872:	1d19      	adds	r1, r3, #4
 800f874:	681b      	ldr	r3, [r3, #0]
 800f876:	9103      	str	r1, [sp, #12]
 800f878:	2b00      	cmp	r3, #0
 800f87a:	bfbb      	ittet	lt
 800f87c:	425b      	neglt	r3, r3
 800f87e:	f042 0202 	orrlt.w	r2, r2, #2
 800f882:	9307      	strge	r3, [sp, #28]
 800f884:	9307      	strlt	r3, [sp, #28]
 800f886:	bfb8      	it	lt
 800f888:	9204      	strlt	r2, [sp, #16]
 800f88a:	7823      	ldrb	r3, [r4, #0]
 800f88c:	2b2e      	cmp	r3, #46	; 0x2e
 800f88e:	d10c      	bne.n	800f8aa <_vfiprintf_r+0x176>
 800f890:	7863      	ldrb	r3, [r4, #1]
 800f892:	2b2a      	cmp	r3, #42	; 0x2a
 800f894:	d135      	bne.n	800f902 <_vfiprintf_r+0x1ce>
 800f896:	9b03      	ldr	r3, [sp, #12]
 800f898:	1d1a      	adds	r2, r3, #4
 800f89a:	681b      	ldr	r3, [r3, #0]
 800f89c:	9203      	str	r2, [sp, #12]
 800f89e:	2b00      	cmp	r3, #0
 800f8a0:	bfb8      	it	lt
 800f8a2:	f04f 33ff 	movlt.w	r3, #4294967295
 800f8a6:	3402      	adds	r4, #2
 800f8a8:	9305      	str	r3, [sp, #20]
 800f8aa:	f8df a0e4 	ldr.w	sl, [pc, #228]	; 800f990 <_vfiprintf_r+0x25c>
 800f8ae:	7821      	ldrb	r1, [r4, #0]
 800f8b0:	2203      	movs	r2, #3
 800f8b2:	4650      	mov	r0, sl
 800f8b4:	f7f9 fec4 	bl	8009640 <memchr>
 800f8b8:	b140      	cbz	r0, 800f8cc <_vfiprintf_r+0x198>
 800f8ba:	2340      	movs	r3, #64	; 0x40
 800f8bc:	eba0 000a 	sub.w	r0, r0, sl
 800f8c0:	fa03 f000 	lsl.w	r0, r3, r0
 800f8c4:	9b04      	ldr	r3, [sp, #16]
 800f8c6:	4303      	orrs	r3, r0
 800f8c8:	3401      	adds	r4, #1
 800f8ca:	9304      	str	r3, [sp, #16]
 800f8cc:	f814 1b01 	ldrb.w	r1, [r4], #1
 800f8d0:	482c      	ldr	r0, [pc, #176]	; (800f984 <_vfiprintf_r+0x250>)
 800f8d2:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 800f8d6:	2206      	movs	r2, #6
 800f8d8:	f7f9 feb2 	bl	8009640 <memchr>
 800f8dc:	2800      	cmp	r0, #0
 800f8de:	d03f      	beq.n	800f960 <_vfiprintf_r+0x22c>
 800f8e0:	4b29      	ldr	r3, [pc, #164]	; (800f988 <_vfiprintf_r+0x254>)
 800f8e2:	bb1b      	cbnz	r3, 800f92c <_vfiprintf_r+0x1f8>
 800f8e4:	9b03      	ldr	r3, [sp, #12]
 800f8e6:	3307      	adds	r3, #7
 800f8e8:	f023 0307 	bic.w	r3, r3, #7
 800f8ec:	3308      	adds	r3, #8
 800f8ee:	9303      	str	r3, [sp, #12]
 800f8f0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800f8f2:	443b      	add	r3, r7
 800f8f4:	9309      	str	r3, [sp, #36]	; 0x24
 800f8f6:	e767      	b.n	800f7c8 <_vfiprintf_r+0x94>
 800f8f8:	fb0c 3202 	mla	r2, ip, r2, r3
 800f8fc:	460c      	mov	r4, r1
 800f8fe:	2001      	movs	r0, #1
 800f900:	e7a5      	b.n	800f84e <_vfiprintf_r+0x11a>
 800f902:	2300      	movs	r3, #0
 800f904:	3401      	adds	r4, #1
 800f906:	9305      	str	r3, [sp, #20]
 800f908:	4619      	mov	r1, r3
 800f90a:	f04f 0c0a 	mov.w	ip, #10
 800f90e:	4620      	mov	r0, r4
 800f910:	f810 2b01 	ldrb.w	r2, [r0], #1
 800f914:	3a30      	subs	r2, #48	; 0x30
 800f916:	2a09      	cmp	r2, #9
 800f918:	d903      	bls.n	800f922 <_vfiprintf_r+0x1ee>
 800f91a:	2b00      	cmp	r3, #0
 800f91c:	d0c5      	beq.n	800f8aa <_vfiprintf_r+0x176>
 800f91e:	9105      	str	r1, [sp, #20]
 800f920:	e7c3      	b.n	800f8aa <_vfiprintf_r+0x176>
 800f922:	fb0c 2101 	mla	r1, ip, r1, r2
 800f926:	4604      	mov	r4, r0
 800f928:	2301      	movs	r3, #1
 800f92a:	e7f0      	b.n	800f90e <_vfiprintf_r+0x1da>
 800f92c:	ab03      	add	r3, sp, #12
 800f92e:	9300      	str	r3, [sp, #0]
 800f930:	462a      	mov	r2, r5
 800f932:	4b16      	ldr	r3, [pc, #88]	; (800f98c <_vfiprintf_r+0x258>)
 800f934:	a904      	add	r1, sp, #16
 800f936:	4630      	mov	r0, r6
 800f938:	f3af 8000 	nop.w
 800f93c:	4607      	mov	r7, r0
 800f93e:	1c78      	adds	r0, r7, #1
 800f940:	d1d6      	bne.n	800f8f0 <_vfiprintf_r+0x1bc>
 800f942:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 800f944:	07d9      	lsls	r1, r3, #31
 800f946:	d405      	bmi.n	800f954 <_vfiprintf_r+0x220>
 800f948:	89ab      	ldrh	r3, [r5, #12]
 800f94a:	059a      	lsls	r2, r3, #22
 800f94c:	d402      	bmi.n	800f954 <_vfiprintf_r+0x220>
 800f94e:	6da8      	ldr	r0, [r5, #88]	; 0x58
 800f950:	f7ff fdb3 	bl	800f4ba <__retarget_lock_release_recursive>
 800f954:	89ab      	ldrh	r3, [r5, #12]
 800f956:	065b      	lsls	r3, r3, #25
 800f958:	f53f af12 	bmi.w	800f780 <_vfiprintf_r+0x4c>
 800f95c:	9809      	ldr	r0, [sp, #36]	; 0x24
 800f95e:	e711      	b.n	800f784 <_vfiprintf_r+0x50>
 800f960:	ab03      	add	r3, sp, #12
 800f962:	9300      	str	r3, [sp, #0]
 800f964:	462a      	mov	r2, r5
 800f966:	4b09      	ldr	r3, [pc, #36]	; (800f98c <_vfiprintf_r+0x258>)
 800f968:	a904      	add	r1, sp, #16
 800f96a:	4630      	mov	r0, r6
 800f96c:	f000 f880 	bl	800fa70 <_printf_i>
 800f970:	e7e4      	b.n	800f93c <_vfiprintf_r+0x208>
 800f972:	bf00      	nop
 800f974:	080113c0 	.word	0x080113c0
 800f978:	080113e0 	.word	0x080113e0
 800f97c:	080113a0 	.word	0x080113a0
 800f980:	08011400 	.word	0x08011400
 800f984:	0801140a 	.word	0x0801140a
 800f988:	00000000 	.word	0x00000000
 800f98c:	0800f70f 	.word	0x0800f70f
 800f990:	08011406 	.word	0x08011406

0800f994 <_printf_common>:
 800f994:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800f998:	4616      	mov	r6, r2
 800f99a:	4699      	mov	r9, r3
 800f99c:	688a      	ldr	r2, [r1, #8]
 800f99e:	690b      	ldr	r3, [r1, #16]
 800f9a0:	f8dd 8020 	ldr.w	r8, [sp, #32]
 800f9a4:	4293      	cmp	r3, r2
 800f9a6:	bfb8      	it	lt
 800f9a8:	4613      	movlt	r3, r2
 800f9aa:	6033      	str	r3, [r6, #0]
 800f9ac:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 800f9b0:	4607      	mov	r7, r0
 800f9b2:	460c      	mov	r4, r1
 800f9b4:	b10a      	cbz	r2, 800f9ba <_printf_common+0x26>
 800f9b6:	3301      	adds	r3, #1
 800f9b8:	6033      	str	r3, [r6, #0]
 800f9ba:	6823      	ldr	r3, [r4, #0]
 800f9bc:	0699      	lsls	r1, r3, #26
 800f9be:	bf42      	ittt	mi
 800f9c0:	6833      	ldrmi	r3, [r6, #0]
 800f9c2:	3302      	addmi	r3, #2
 800f9c4:	6033      	strmi	r3, [r6, #0]
 800f9c6:	6825      	ldr	r5, [r4, #0]
 800f9c8:	f015 0506 	ands.w	r5, r5, #6
 800f9cc:	d106      	bne.n	800f9dc <_printf_common+0x48>
 800f9ce:	f104 0a19 	add.w	sl, r4, #25
 800f9d2:	68e3      	ldr	r3, [r4, #12]
 800f9d4:	6832      	ldr	r2, [r6, #0]
 800f9d6:	1a9b      	subs	r3, r3, r2
 800f9d8:	42ab      	cmp	r3, r5
 800f9da:	dc26      	bgt.n	800fa2a <_printf_common+0x96>
 800f9dc:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
 800f9e0:	1e13      	subs	r3, r2, #0
 800f9e2:	6822      	ldr	r2, [r4, #0]
 800f9e4:	bf18      	it	ne
 800f9e6:	2301      	movne	r3, #1
 800f9e8:	0692      	lsls	r2, r2, #26
 800f9ea:	d42b      	bmi.n	800fa44 <_printf_common+0xb0>
 800f9ec:	f104 0243 	add.w	r2, r4, #67	; 0x43
 800f9f0:	4649      	mov	r1, r9
 800f9f2:	4638      	mov	r0, r7
 800f9f4:	47c0      	blx	r8
 800f9f6:	3001      	adds	r0, #1
 800f9f8:	d01e      	beq.n	800fa38 <_printf_common+0xa4>
 800f9fa:	6823      	ldr	r3, [r4, #0]
 800f9fc:	68e5      	ldr	r5, [r4, #12]
 800f9fe:	6832      	ldr	r2, [r6, #0]
 800fa00:	f003 0306 	and.w	r3, r3, #6
 800fa04:	2b04      	cmp	r3, #4
 800fa06:	bf08      	it	eq
 800fa08:	1aad      	subeq	r5, r5, r2
 800fa0a:	68a3      	ldr	r3, [r4, #8]
 800fa0c:	6922      	ldr	r2, [r4, #16]
 800fa0e:	bf0c      	ite	eq
 800fa10:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 800fa14:	2500      	movne	r5, #0
 800fa16:	4293      	cmp	r3, r2
 800fa18:	bfc4      	itt	gt
 800fa1a:	1a9b      	subgt	r3, r3, r2
 800fa1c:	18ed      	addgt	r5, r5, r3
 800fa1e:	2600      	movs	r6, #0
 800fa20:	341a      	adds	r4, #26
 800fa22:	42b5      	cmp	r5, r6
 800fa24:	d11a      	bne.n	800fa5c <_printf_common+0xc8>
 800fa26:	2000      	movs	r0, #0
 800fa28:	e008      	b.n	800fa3c <_printf_common+0xa8>
 800fa2a:	2301      	movs	r3, #1
 800fa2c:	4652      	mov	r2, sl
 800fa2e:	4649      	mov	r1, r9
 800fa30:	4638      	mov	r0, r7
 800fa32:	47c0      	blx	r8
 800fa34:	3001      	adds	r0, #1
 800fa36:	d103      	bne.n	800fa40 <_printf_common+0xac>
 800fa38:	f04f 30ff 	mov.w	r0, #4294967295
 800fa3c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800fa40:	3501      	adds	r5, #1
 800fa42:	e7c6      	b.n	800f9d2 <_printf_common+0x3e>
 800fa44:	18e1      	adds	r1, r4, r3
 800fa46:	1c5a      	adds	r2, r3, #1
 800fa48:	2030      	movs	r0, #48	; 0x30
 800fa4a:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 800fa4e:	4422      	add	r2, r4
 800fa50:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 800fa54:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 800fa58:	3302      	adds	r3, #2
 800fa5a:	e7c7      	b.n	800f9ec <_printf_common+0x58>
 800fa5c:	2301      	movs	r3, #1
 800fa5e:	4622      	mov	r2, r4
 800fa60:	4649      	mov	r1, r9
 800fa62:	4638      	mov	r0, r7
 800fa64:	47c0      	blx	r8
 800fa66:	3001      	adds	r0, #1
 800fa68:	d0e6      	beq.n	800fa38 <_printf_common+0xa4>
 800fa6a:	3601      	adds	r6, #1
 800fa6c:	e7d9      	b.n	800fa22 <_printf_common+0x8e>
	...

0800fa70 <_printf_i>:
 800fa70:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 800fa74:	460c      	mov	r4, r1
 800fa76:	4691      	mov	r9, r2
 800fa78:	7e27      	ldrb	r7, [r4, #24]
 800fa7a:	990c      	ldr	r1, [sp, #48]	; 0x30
 800fa7c:	2f78      	cmp	r7, #120	; 0x78
 800fa7e:	4680      	mov	r8, r0
 800fa80:	469a      	mov	sl, r3
 800fa82:	f104 0243 	add.w	r2, r4, #67	; 0x43
 800fa86:	d807      	bhi.n	800fa98 <_printf_i+0x28>
 800fa88:	2f62      	cmp	r7, #98	; 0x62
 800fa8a:	d80a      	bhi.n	800faa2 <_printf_i+0x32>
 800fa8c:	2f00      	cmp	r7, #0
 800fa8e:	f000 80d8 	beq.w	800fc42 <_printf_i+0x1d2>
 800fa92:	2f58      	cmp	r7, #88	; 0x58
 800fa94:	f000 80a3 	beq.w	800fbde <_printf_i+0x16e>
 800fa98:	f104 0642 	add.w	r6, r4, #66	; 0x42
 800fa9c:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
 800faa0:	e03a      	b.n	800fb18 <_printf_i+0xa8>
 800faa2:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
 800faa6:	2b15      	cmp	r3, #21
 800faa8:	d8f6      	bhi.n	800fa98 <_printf_i+0x28>
 800faaa:	a001      	add	r0, pc, #4	; (adr r0, 800fab0 <_printf_i+0x40>)
 800faac:	f850 f023 	ldr.w	pc, [r0, r3, lsl #2]
 800fab0:	0800fb09 	.word	0x0800fb09
 800fab4:	0800fb1d 	.word	0x0800fb1d
 800fab8:	0800fa99 	.word	0x0800fa99
 800fabc:	0800fa99 	.word	0x0800fa99
 800fac0:	0800fa99 	.word	0x0800fa99
 800fac4:	0800fa99 	.word	0x0800fa99
 800fac8:	0800fb1d 	.word	0x0800fb1d
 800facc:	0800fa99 	.word	0x0800fa99
 800fad0:	0800fa99 	.word	0x0800fa99
 800fad4:	0800fa99 	.word	0x0800fa99
 800fad8:	0800fa99 	.word	0x0800fa99
 800fadc:	0800fc29 	.word	0x0800fc29
 800fae0:	0800fb4d 	.word	0x0800fb4d
 800fae4:	0800fc0b 	.word	0x0800fc0b
 800fae8:	0800fa99 	.word	0x0800fa99
 800faec:	0800fa99 	.word	0x0800fa99
 800faf0:	0800fc4b 	.word	0x0800fc4b
 800faf4:	0800fa99 	.word	0x0800fa99
 800faf8:	0800fb4d 	.word	0x0800fb4d
 800fafc:	0800fa99 	.word	0x0800fa99
 800fb00:	0800fa99 	.word	0x0800fa99
 800fb04:	0800fc13 	.word	0x0800fc13
 800fb08:	680b      	ldr	r3, [r1, #0]
 800fb0a:	1d1a      	adds	r2, r3, #4
 800fb0c:	681b      	ldr	r3, [r3, #0]
 800fb0e:	600a      	str	r2, [r1, #0]
 800fb10:	f104 0642 	add.w	r6, r4, #66	; 0x42
 800fb14:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 800fb18:	2301      	movs	r3, #1
 800fb1a:	e0a3      	b.n	800fc64 <_printf_i+0x1f4>
 800fb1c:	6825      	ldr	r5, [r4, #0]
 800fb1e:	6808      	ldr	r0, [r1, #0]
 800fb20:	062e      	lsls	r6, r5, #24
 800fb22:	f100 0304 	add.w	r3, r0, #4
 800fb26:	d50a      	bpl.n	800fb3e <_printf_i+0xce>
 800fb28:	6805      	ldr	r5, [r0, #0]
 800fb2a:	600b      	str	r3, [r1, #0]
 800fb2c:	2d00      	cmp	r5, #0
 800fb2e:	da03      	bge.n	800fb38 <_printf_i+0xc8>
 800fb30:	232d      	movs	r3, #45	; 0x2d
 800fb32:	426d      	negs	r5, r5
 800fb34:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 800fb38:	485e      	ldr	r0, [pc, #376]	; (800fcb4 <_printf_i+0x244>)
 800fb3a:	230a      	movs	r3, #10
 800fb3c:	e019      	b.n	800fb72 <_printf_i+0x102>
 800fb3e:	f015 0f40 	tst.w	r5, #64	; 0x40
 800fb42:	6805      	ldr	r5, [r0, #0]
 800fb44:	600b      	str	r3, [r1, #0]
 800fb46:	bf18      	it	ne
 800fb48:	b22d      	sxthne	r5, r5
 800fb4a:	e7ef      	b.n	800fb2c <_printf_i+0xbc>
 800fb4c:	680b      	ldr	r3, [r1, #0]
 800fb4e:	6825      	ldr	r5, [r4, #0]
 800fb50:	1d18      	adds	r0, r3, #4
 800fb52:	6008      	str	r0, [r1, #0]
 800fb54:	0628      	lsls	r0, r5, #24
 800fb56:	d501      	bpl.n	800fb5c <_printf_i+0xec>
 800fb58:	681d      	ldr	r5, [r3, #0]
 800fb5a:	e002      	b.n	800fb62 <_printf_i+0xf2>
 800fb5c:	0669      	lsls	r1, r5, #25
 800fb5e:	d5fb      	bpl.n	800fb58 <_printf_i+0xe8>
 800fb60:	881d      	ldrh	r5, [r3, #0]
 800fb62:	4854      	ldr	r0, [pc, #336]	; (800fcb4 <_printf_i+0x244>)
 800fb64:	2f6f      	cmp	r7, #111	; 0x6f
 800fb66:	bf0c      	ite	eq
 800fb68:	2308      	moveq	r3, #8
 800fb6a:	230a      	movne	r3, #10
 800fb6c:	2100      	movs	r1, #0
 800fb6e:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 800fb72:	6866      	ldr	r6, [r4, #4]
 800fb74:	60a6      	str	r6, [r4, #8]
 800fb76:	2e00      	cmp	r6, #0
 800fb78:	bfa2      	ittt	ge
 800fb7a:	6821      	ldrge	r1, [r4, #0]
 800fb7c:	f021 0104 	bicge.w	r1, r1, #4
 800fb80:	6021      	strge	r1, [r4, #0]
 800fb82:	b90d      	cbnz	r5, 800fb88 <_printf_i+0x118>
 800fb84:	2e00      	cmp	r6, #0
 800fb86:	d04d      	beq.n	800fc24 <_printf_i+0x1b4>
 800fb88:	4616      	mov	r6, r2
 800fb8a:	fbb5 f1f3 	udiv	r1, r5, r3
 800fb8e:	fb03 5711 	mls	r7, r3, r1, r5
 800fb92:	5dc7      	ldrb	r7, [r0, r7]
 800fb94:	f806 7d01 	strb.w	r7, [r6, #-1]!
 800fb98:	462f      	mov	r7, r5
 800fb9a:	42bb      	cmp	r3, r7
 800fb9c:	460d      	mov	r5, r1
 800fb9e:	d9f4      	bls.n	800fb8a <_printf_i+0x11a>
 800fba0:	2b08      	cmp	r3, #8
 800fba2:	d10b      	bne.n	800fbbc <_printf_i+0x14c>
 800fba4:	6823      	ldr	r3, [r4, #0]
 800fba6:	07df      	lsls	r7, r3, #31
 800fba8:	d508      	bpl.n	800fbbc <_printf_i+0x14c>
 800fbaa:	6923      	ldr	r3, [r4, #16]
 800fbac:	6861      	ldr	r1, [r4, #4]
 800fbae:	4299      	cmp	r1, r3
 800fbb0:	bfde      	ittt	le
 800fbb2:	2330      	movle	r3, #48	; 0x30
 800fbb4:	f806 3c01 	strble.w	r3, [r6, #-1]
 800fbb8:	f106 36ff 	addle.w	r6, r6, #4294967295
 800fbbc:	1b92      	subs	r2, r2, r6
 800fbbe:	6122      	str	r2, [r4, #16]
 800fbc0:	f8cd a000 	str.w	sl, [sp]
 800fbc4:	464b      	mov	r3, r9
 800fbc6:	aa03      	add	r2, sp, #12
 800fbc8:	4621      	mov	r1, r4
 800fbca:	4640      	mov	r0, r8
 800fbcc:	f7ff fee2 	bl	800f994 <_printf_common>
 800fbd0:	3001      	adds	r0, #1
 800fbd2:	d14c      	bne.n	800fc6e <_printf_i+0x1fe>
 800fbd4:	f04f 30ff 	mov.w	r0, #4294967295
 800fbd8:	b004      	add	sp, #16
 800fbda:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800fbde:	4835      	ldr	r0, [pc, #212]	; (800fcb4 <_printf_i+0x244>)
 800fbe0:	f884 7045 	strb.w	r7, [r4, #69]	; 0x45
 800fbe4:	6823      	ldr	r3, [r4, #0]
 800fbe6:	680e      	ldr	r6, [r1, #0]
 800fbe8:	061f      	lsls	r7, r3, #24
 800fbea:	f856 5b04 	ldr.w	r5, [r6], #4
 800fbee:	600e      	str	r6, [r1, #0]
 800fbf0:	d514      	bpl.n	800fc1c <_printf_i+0x1ac>
 800fbf2:	07d9      	lsls	r1, r3, #31
 800fbf4:	bf44      	itt	mi
 800fbf6:	f043 0320 	orrmi.w	r3, r3, #32
 800fbfa:	6023      	strmi	r3, [r4, #0]
 800fbfc:	b91d      	cbnz	r5, 800fc06 <_printf_i+0x196>
 800fbfe:	6823      	ldr	r3, [r4, #0]
 800fc00:	f023 0320 	bic.w	r3, r3, #32
 800fc04:	6023      	str	r3, [r4, #0]
 800fc06:	2310      	movs	r3, #16
 800fc08:	e7b0      	b.n	800fb6c <_printf_i+0xfc>
 800fc0a:	6823      	ldr	r3, [r4, #0]
 800fc0c:	f043 0320 	orr.w	r3, r3, #32
 800fc10:	6023      	str	r3, [r4, #0]
 800fc12:	2378      	movs	r3, #120	; 0x78
 800fc14:	4828      	ldr	r0, [pc, #160]	; (800fcb8 <_printf_i+0x248>)
 800fc16:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 800fc1a:	e7e3      	b.n	800fbe4 <_printf_i+0x174>
 800fc1c:	065e      	lsls	r6, r3, #25
 800fc1e:	bf48      	it	mi
 800fc20:	b2ad      	uxthmi	r5, r5
 800fc22:	e7e6      	b.n	800fbf2 <_printf_i+0x182>
 800fc24:	4616      	mov	r6, r2
 800fc26:	e7bb      	b.n	800fba0 <_printf_i+0x130>
 800fc28:	680b      	ldr	r3, [r1, #0]
 800fc2a:	6826      	ldr	r6, [r4, #0]
 800fc2c:	6960      	ldr	r0, [r4, #20]
 800fc2e:	1d1d      	adds	r5, r3, #4
 800fc30:	600d      	str	r5, [r1, #0]
 800fc32:	0635      	lsls	r5, r6, #24
 800fc34:	681b      	ldr	r3, [r3, #0]
 800fc36:	d501      	bpl.n	800fc3c <_printf_i+0x1cc>
 800fc38:	6018      	str	r0, [r3, #0]
 800fc3a:	e002      	b.n	800fc42 <_printf_i+0x1d2>
 800fc3c:	0671      	lsls	r1, r6, #25
 800fc3e:	d5fb      	bpl.n	800fc38 <_printf_i+0x1c8>
 800fc40:	8018      	strh	r0, [r3, #0]
 800fc42:	2300      	movs	r3, #0
 800fc44:	6123      	str	r3, [r4, #16]
 800fc46:	4616      	mov	r6, r2
 800fc48:	e7ba      	b.n	800fbc0 <_printf_i+0x150>
 800fc4a:	680b      	ldr	r3, [r1, #0]
 800fc4c:	1d1a      	adds	r2, r3, #4
 800fc4e:	600a      	str	r2, [r1, #0]
 800fc50:	681e      	ldr	r6, [r3, #0]
 800fc52:	6862      	ldr	r2, [r4, #4]
 800fc54:	2100      	movs	r1, #0
 800fc56:	4630      	mov	r0, r6
 800fc58:	f7f9 fcf2 	bl	8009640 <memchr>
 800fc5c:	b108      	cbz	r0, 800fc62 <_printf_i+0x1f2>
 800fc5e:	1b80      	subs	r0, r0, r6
 800fc60:	6060      	str	r0, [r4, #4]
 800fc62:	6863      	ldr	r3, [r4, #4]
 800fc64:	6123      	str	r3, [r4, #16]
 800fc66:	2300      	movs	r3, #0
 800fc68:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 800fc6c:	e7a8      	b.n	800fbc0 <_printf_i+0x150>
 800fc6e:	6923      	ldr	r3, [r4, #16]
 800fc70:	4632      	mov	r2, r6
 800fc72:	4649      	mov	r1, r9
 800fc74:	4640      	mov	r0, r8
 800fc76:	47d0      	blx	sl
 800fc78:	3001      	adds	r0, #1
 800fc7a:	d0ab      	beq.n	800fbd4 <_printf_i+0x164>
 800fc7c:	6823      	ldr	r3, [r4, #0]
 800fc7e:	079b      	lsls	r3, r3, #30
 800fc80:	d413      	bmi.n	800fcaa <_printf_i+0x23a>
 800fc82:	68e0      	ldr	r0, [r4, #12]
 800fc84:	9b03      	ldr	r3, [sp, #12]
 800fc86:	4298      	cmp	r0, r3
 800fc88:	bfb8      	it	lt
 800fc8a:	4618      	movlt	r0, r3
 800fc8c:	e7a4      	b.n	800fbd8 <_printf_i+0x168>
 800fc8e:	2301      	movs	r3, #1
 800fc90:	4632      	mov	r2, r6
 800fc92:	4649      	mov	r1, r9
 800fc94:	4640      	mov	r0, r8
 800fc96:	47d0      	blx	sl
 800fc98:	3001      	adds	r0, #1
 800fc9a:	d09b      	beq.n	800fbd4 <_printf_i+0x164>
 800fc9c:	3501      	adds	r5, #1
 800fc9e:	68e3      	ldr	r3, [r4, #12]
 800fca0:	9903      	ldr	r1, [sp, #12]
 800fca2:	1a5b      	subs	r3, r3, r1
 800fca4:	42ab      	cmp	r3, r5
 800fca6:	dcf2      	bgt.n	800fc8e <_printf_i+0x21e>
 800fca8:	e7eb      	b.n	800fc82 <_printf_i+0x212>
 800fcaa:	2500      	movs	r5, #0
 800fcac:	f104 0619 	add.w	r6, r4, #25
 800fcb0:	e7f5      	b.n	800fc9e <_printf_i+0x22e>
 800fcb2:	bf00      	nop
 800fcb4:	08011411 	.word	0x08011411
 800fcb8:	08011422 	.word	0x08011422

0800fcbc <_putc_r>:
 800fcbc:	b570      	push	{r4, r5, r6, lr}
 800fcbe:	460d      	mov	r5, r1
 800fcc0:	4614      	mov	r4, r2
 800fcc2:	4606      	mov	r6, r0
 800fcc4:	b118      	cbz	r0, 800fcce <_putc_r+0x12>
 800fcc6:	6983      	ldr	r3, [r0, #24]
 800fcc8:	b90b      	cbnz	r3, 800fcce <_putc_r+0x12>
 800fcca:	f7ff fb57 	bl	800f37c <__sinit>
 800fcce:	4b1c      	ldr	r3, [pc, #112]	; (800fd40 <_putc_r+0x84>)
 800fcd0:	429c      	cmp	r4, r3
 800fcd2:	d124      	bne.n	800fd1e <_putc_r+0x62>
 800fcd4:	6874      	ldr	r4, [r6, #4]
 800fcd6:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800fcd8:	07d8      	lsls	r0, r3, #31
 800fcda:	d405      	bmi.n	800fce8 <_putc_r+0x2c>
 800fcdc:	89a3      	ldrh	r3, [r4, #12]
 800fcde:	0599      	lsls	r1, r3, #22
 800fce0:	d402      	bmi.n	800fce8 <_putc_r+0x2c>
 800fce2:	6da0      	ldr	r0, [r4, #88]	; 0x58
 800fce4:	f7ff fbe8 	bl	800f4b8 <__retarget_lock_acquire_recursive>
 800fce8:	68a3      	ldr	r3, [r4, #8]
 800fcea:	3b01      	subs	r3, #1
 800fcec:	2b00      	cmp	r3, #0
 800fcee:	60a3      	str	r3, [r4, #8]
 800fcf0:	da05      	bge.n	800fcfe <_putc_r+0x42>
 800fcf2:	69a2      	ldr	r2, [r4, #24]
 800fcf4:	4293      	cmp	r3, r2
 800fcf6:	db1c      	blt.n	800fd32 <_putc_r+0x76>
 800fcf8:	b2eb      	uxtb	r3, r5
 800fcfa:	2b0a      	cmp	r3, #10
 800fcfc:	d019      	beq.n	800fd32 <_putc_r+0x76>
 800fcfe:	6823      	ldr	r3, [r4, #0]
 800fd00:	1c5a      	adds	r2, r3, #1
 800fd02:	6022      	str	r2, [r4, #0]
 800fd04:	701d      	strb	r5, [r3, #0]
 800fd06:	b2ed      	uxtb	r5, r5
 800fd08:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800fd0a:	07da      	lsls	r2, r3, #31
 800fd0c:	d405      	bmi.n	800fd1a <_putc_r+0x5e>
 800fd0e:	89a3      	ldrh	r3, [r4, #12]
 800fd10:	059b      	lsls	r3, r3, #22
 800fd12:	d402      	bmi.n	800fd1a <_putc_r+0x5e>
 800fd14:	6da0      	ldr	r0, [r4, #88]	; 0x58
 800fd16:	f7ff fbd0 	bl	800f4ba <__retarget_lock_release_recursive>
 800fd1a:	4628      	mov	r0, r5
 800fd1c:	bd70      	pop	{r4, r5, r6, pc}
 800fd1e:	4b09      	ldr	r3, [pc, #36]	; (800fd44 <_putc_r+0x88>)
 800fd20:	429c      	cmp	r4, r3
 800fd22:	d101      	bne.n	800fd28 <_putc_r+0x6c>
 800fd24:	68b4      	ldr	r4, [r6, #8]
 800fd26:	e7d6      	b.n	800fcd6 <_putc_r+0x1a>
 800fd28:	4b07      	ldr	r3, [pc, #28]	; (800fd48 <_putc_r+0x8c>)
 800fd2a:	429c      	cmp	r4, r3
 800fd2c:	bf08      	it	eq
 800fd2e:	68f4      	ldreq	r4, [r6, #12]
 800fd30:	e7d1      	b.n	800fcd6 <_putc_r+0x1a>
 800fd32:	4629      	mov	r1, r5
 800fd34:	4622      	mov	r2, r4
 800fd36:	4630      	mov	r0, r6
 800fd38:	f7ff f946 	bl	800efc8 <__swbuf_r>
 800fd3c:	4605      	mov	r5, r0
 800fd3e:	e7e3      	b.n	800fd08 <_putc_r+0x4c>
 800fd40:	080113c0 	.word	0x080113c0
 800fd44:	080113e0 	.word	0x080113e0
 800fd48:	080113a0 	.word	0x080113a0

0800fd4c <_sbrk_r>:
 800fd4c:	b538      	push	{r3, r4, r5, lr}
 800fd4e:	4d06      	ldr	r5, [pc, #24]	; (800fd68 <_sbrk_r+0x1c>)
 800fd50:	2300      	movs	r3, #0
 800fd52:	4604      	mov	r4, r0
 800fd54:	4608      	mov	r0, r1
 800fd56:	602b      	str	r3, [r5, #0]
 800fd58:	f7fd f93c 	bl	800cfd4 <_sbrk>
 800fd5c:	1c43      	adds	r3, r0, #1
 800fd5e:	d102      	bne.n	800fd66 <_sbrk_r+0x1a>
 800fd60:	682b      	ldr	r3, [r5, #0]
 800fd62:	b103      	cbz	r3, 800fd66 <_sbrk_r+0x1a>
 800fd64:	6023      	str	r3, [r4, #0]
 800fd66:	bd38      	pop	{r3, r4, r5, pc}
 800fd68:	20003f2c 	.word	0x20003f2c

0800fd6c <__sread>:
 800fd6c:	b510      	push	{r4, lr}
 800fd6e:	460c      	mov	r4, r1
 800fd70:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800fd74:	f000 f8a0 	bl	800feb8 <_read_r>
 800fd78:	2800      	cmp	r0, #0
 800fd7a:	bfab      	itete	ge
 800fd7c:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 800fd7e:	89a3      	ldrhlt	r3, [r4, #12]
 800fd80:	181b      	addge	r3, r3, r0
 800fd82:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 800fd86:	bfac      	ite	ge
 800fd88:	6563      	strge	r3, [r4, #84]	; 0x54
 800fd8a:	81a3      	strhlt	r3, [r4, #12]
 800fd8c:	bd10      	pop	{r4, pc}

0800fd8e <__swrite>:
 800fd8e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800fd92:	461f      	mov	r7, r3
 800fd94:	898b      	ldrh	r3, [r1, #12]
 800fd96:	05db      	lsls	r3, r3, #23
 800fd98:	4605      	mov	r5, r0
 800fd9a:	460c      	mov	r4, r1
 800fd9c:	4616      	mov	r6, r2
 800fd9e:	d505      	bpl.n	800fdac <__swrite+0x1e>
 800fda0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800fda4:	2302      	movs	r3, #2
 800fda6:	2200      	movs	r2, #0
 800fda8:	f000 f868 	bl	800fe7c <_lseek_r>
 800fdac:	89a3      	ldrh	r3, [r4, #12]
 800fdae:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 800fdb2:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800fdb6:	81a3      	strh	r3, [r4, #12]
 800fdb8:	4632      	mov	r2, r6
 800fdba:	463b      	mov	r3, r7
 800fdbc:	4628      	mov	r0, r5
 800fdbe:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 800fdc2:	f000 b817 	b.w	800fdf4 <_write_r>

0800fdc6 <__sseek>:
 800fdc6:	b510      	push	{r4, lr}
 800fdc8:	460c      	mov	r4, r1
 800fdca:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800fdce:	f000 f855 	bl	800fe7c <_lseek_r>
 800fdd2:	1c43      	adds	r3, r0, #1
 800fdd4:	89a3      	ldrh	r3, [r4, #12]
 800fdd6:	bf15      	itete	ne
 800fdd8:	6560      	strne	r0, [r4, #84]	; 0x54
 800fdda:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 800fdde:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 800fde2:	81a3      	strheq	r3, [r4, #12]
 800fde4:	bf18      	it	ne
 800fde6:	81a3      	strhne	r3, [r4, #12]
 800fde8:	bd10      	pop	{r4, pc}

0800fdea <__sclose>:
 800fdea:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800fdee:	f000 b813 	b.w	800fe18 <_close_r>
	...

0800fdf4 <_write_r>:
 800fdf4:	b538      	push	{r3, r4, r5, lr}
 800fdf6:	4d07      	ldr	r5, [pc, #28]	; (800fe14 <_write_r+0x20>)
 800fdf8:	4604      	mov	r4, r0
 800fdfa:	4608      	mov	r0, r1
 800fdfc:	4611      	mov	r1, r2
 800fdfe:	2200      	movs	r2, #0
 800fe00:	602a      	str	r2, [r5, #0]
 800fe02:	461a      	mov	r2, r3
 800fe04:	f7fd f8cc 	bl	800cfa0 <_write>
 800fe08:	1c43      	adds	r3, r0, #1
 800fe0a:	d102      	bne.n	800fe12 <_write_r+0x1e>
 800fe0c:	682b      	ldr	r3, [r5, #0]
 800fe0e:	b103      	cbz	r3, 800fe12 <_write_r+0x1e>
 800fe10:	6023      	str	r3, [r4, #0]
 800fe12:	bd38      	pop	{r3, r4, r5, pc}
 800fe14:	20003f2c 	.word	0x20003f2c

0800fe18 <_close_r>:
 800fe18:	b538      	push	{r3, r4, r5, lr}
 800fe1a:	4d06      	ldr	r5, [pc, #24]	; (800fe34 <_close_r+0x1c>)
 800fe1c:	2300      	movs	r3, #0
 800fe1e:	4604      	mov	r4, r0
 800fe20:	4608      	mov	r0, r1
 800fe22:	602b      	str	r3, [r5, #0]
 800fe24:	f7fd f8c9 	bl	800cfba <_close>
 800fe28:	1c43      	adds	r3, r0, #1
 800fe2a:	d102      	bne.n	800fe32 <_close_r+0x1a>
 800fe2c:	682b      	ldr	r3, [r5, #0]
 800fe2e:	b103      	cbz	r3, 800fe32 <_close_r+0x1a>
 800fe30:	6023      	str	r3, [r4, #0]
 800fe32:	bd38      	pop	{r3, r4, r5, pc}
 800fe34:	20003f2c 	.word	0x20003f2c

0800fe38 <_fstat_r>:
 800fe38:	b538      	push	{r3, r4, r5, lr}
 800fe3a:	4d07      	ldr	r5, [pc, #28]	; (800fe58 <_fstat_r+0x20>)
 800fe3c:	2300      	movs	r3, #0
 800fe3e:	4604      	mov	r4, r0
 800fe40:	4608      	mov	r0, r1
 800fe42:	4611      	mov	r1, r2
 800fe44:	602b      	str	r3, [r5, #0]
 800fe46:	f7fd f8bb 	bl	800cfc0 <_fstat>
 800fe4a:	1c43      	adds	r3, r0, #1
 800fe4c:	d102      	bne.n	800fe54 <_fstat_r+0x1c>
 800fe4e:	682b      	ldr	r3, [r5, #0]
 800fe50:	b103      	cbz	r3, 800fe54 <_fstat_r+0x1c>
 800fe52:	6023      	str	r3, [r4, #0]
 800fe54:	bd38      	pop	{r3, r4, r5, pc}
 800fe56:	bf00      	nop
 800fe58:	20003f2c 	.word	0x20003f2c

0800fe5c <_isatty_r>:
 800fe5c:	b538      	push	{r3, r4, r5, lr}
 800fe5e:	4d06      	ldr	r5, [pc, #24]	; (800fe78 <_isatty_r+0x1c>)
 800fe60:	2300      	movs	r3, #0
 800fe62:	4604      	mov	r4, r0
 800fe64:	4608      	mov	r0, r1
 800fe66:	602b      	str	r3, [r5, #0]
 800fe68:	f7fd f8af 	bl	800cfca <_isatty>
 800fe6c:	1c43      	adds	r3, r0, #1
 800fe6e:	d102      	bne.n	800fe76 <_isatty_r+0x1a>
 800fe70:	682b      	ldr	r3, [r5, #0]
 800fe72:	b103      	cbz	r3, 800fe76 <_isatty_r+0x1a>
 800fe74:	6023      	str	r3, [r4, #0]
 800fe76:	bd38      	pop	{r3, r4, r5, pc}
 800fe78:	20003f2c 	.word	0x20003f2c

0800fe7c <_lseek_r>:
 800fe7c:	b538      	push	{r3, r4, r5, lr}
 800fe7e:	4d07      	ldr	r5, [pc, #28]	; (800fe9c <_lseek_r+0x20>)
 800fe80:	4604      	mov	r4, r0
 800fe82:	4608      	mov	r0, r1
 800fe84:	4611      	mov	r1, r2
 800fe86:	2200      	movs	r2, #0
 800fe88:	602a      	str	r2, [r5, #0]
 800fe8a:	461a      	mov	r2, r3
 800fe8c:	f7fd f89f 	bl	800cfce <_lseek>
 800fe90:	1c43      	adds	r3, r0, #1
 800fe92:	d102      	bne.n	800fe9a <_lseek_r+0x1e>
 800fe94:	682b      	ldr	r3, [r5, #0]
 800fe96:	b103      	cbz	r3, 800fe9a <_lseek_r+0x1e>
 800fe98:	6023      	str	r3, [r4, #0]
 800fe9a:	bd38      	pop	{r3, r4, r5, pc}
 800fe9c:	20003f2c 	.word	0x20003f2c

0800fea0 <__malloc_lock>:
 800fea0:	4801      	ldr	r0, [pc, #4]	; (800fea8 <__malloc_lock+0x8>)
 800fea2:	f7ff bb09 	b.w	800f4b8 <__retarget_lock_acquire_recursive>
 800fea6:	bf00      	nop
 800fea8:	20003f24 	.word	0x20003f24

0800feac <__malloc_unlock>:
 800feac:	4801      	ldr	r0, [pc, #4]	; (800feb4 <__malloc_unlock+0x8>)
 800feae:	f7ff bb04 	b.w	800f4ba <__retarget_lock_release_recursive>
 800feb2:	bf00      	nop
 800feb4:	20003f24 	.word	0x20003f24

0800feb8 <_read_r>:
 800feb8:	b538      	push	{r3, r4, r5, lr}
 800feba:	4d07      	ldr	r5, [pc, #28]	; (800fed8 <_read_r+0x20>)
 800febc:	4604      	mov	r4, r0
 800febe:	4608      	mov	r0, r1
 800fec0:	4611      	mov	r1, r2
 800fec2:	2200      	movs	r2, #0
 800fec4:	602a      	str	r2, [r5, #0]
 800fec6:	461a      	mov	r2, r3
 800fec8:	f7fd f85d 	bl	800cf86 <_read>
 800fecc:	1c43      	adds	r3, r0, #1
 800fece:	d102      	bne.n	800fed6 <_read_r+0x1e>
 800fed0:	682b      	ldr	r3, [r5, #0]
 800fed2:	b103      	cbz	r3, 800fed6 <_read_r+0x1e>
 800fed4:	6023      	str	r3, [r4, #0]
 800fed6:	bd38      	pop	{r3, r4, r5, pc}
 800fed8:	20003f2c 	.word	0x20003f2c

0800fedc <_init>:
 800fedc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800fede:	bf00      	nop
 800fee0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800fee2:	bc08      	pop	{r3}
 800fee4:	469e      	mov	lr, r3
 800fee6:	4770      	bx	lr

0800fee8 <_fini>:
 800fee8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800feea:	bf00      	nop
 800feec:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800feee:	bc08      	pop	{r3}
 800fef0:	469e      	mov	lr, r3
 800fef2:	4770      	bx	lr
 800fef4:	0000      	movs	r0, r0
	...
